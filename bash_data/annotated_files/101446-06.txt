     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* rendering object for textual content of elements */
     1: 
 80467: #include "mozilla/Util.h"
 80467: 
     1: #include "nsCOMPtr.h"
     1: #include "nsHTMLParts.h"
     1: #include "nsCRT.h"
     1: #include "nsSplittableFrame.h"
     1: #include "nsLineLayout.h"
     1: #include "nsString.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsPresContext.h"
     1: #include "nsIContent.h"
     1: #include "nsStyleConsts.h"
     1: #include "nsStyleContext.h"
     1: #include "nsCoord.h"
 68481: #include "nsRenderingContext.h"
     1: #include "nsIPresShell.h"
     1: #include "nsITimer.h"
 24551: #include "nsTArray.h"
     1: #include "nsIDocument.h"
     1: #include "nsCSSPseudoElements.h"
 61565: #include "nsCSSFrameConstructor.h"
     1: #include "nsCompatibility.h"
     1: #include "nsCSSColorUtils.h"
     1: #include "nsLayoutUtils.h"
     1: #include "nsDisplayList.h"
     1: #include "nsFrame.h"
 32107: #include "nsPlaceholderFrame.h"
     1: #include "nsTextFrameUtils.h"
     1: #include "nsTextRunTransformations.h"
    60: #include "nsFrameManager.h"
  1328: #include "nsTextFrameTextRunCache.h"
  1328: #include "nsExpirationTracker.h"
  6247: #include "nsTextFrame.h"
 90892: #include "nsUnicodeProperties.h"
  5453: #include "nsUnicharUtilCIID.h"
     1: 
     1: #include "nsTextFragment.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsFrameSelection.h"
     1: #include "nsISelection.h"
     1: #include "nsIDOMRange.h"
 85101: #include "nsRange.h"
     1: #include "nsCSSRendering.h"
     1: #include "nsContentUtils.h"
     1: #include "nsLineBreaker.h"
  2319: #include "nsIWordBreaker.h"
 29809: #include "nsGenericDOMDataNode.h"
     1: 
     1: #include "nsILineIterator.h"
     1: 
     1: #include "nsIServiceManager.h"
     1: #ifdef ACCESSIBILITY
 61464: #include "nsAccessibilityService.h"
     1: #endif
     1: #include "nsAutoPtr.h"
     1: 
     1: #include "nsBidiUtils.h"
 77158: #include "nsPrintfCString.h"
     1: 
     1: #include "gfxFont.h"
     1: #include "gfxContext.h"
 15339: #include "gfxImageSurface.h"
 72149: 
 41930: #include "mozilla/dom/Element.h"
 72149: #include "mozilla/Util.h" // for DebugOnly
 78130: #include "mozilla/LookAndFeel.h"
     1: 
 96794: #include "sampler.h"
 96794: 
     1: #ifdef NS_DEBUG
     1: #undef NOISY_BLINK
     1: #undef NOISY_REFLOW
     1: #undef NOISY_TRIM
     1: #else
     1: #undef NOISY_BLINK
     1: #undef NOISY_REFLOW
     1: #undef NOISY_TRIM
     1: #endif
     1: 
 39965: using namespace mozilla;
 41641: using namespace mozilla::dom;
 39965: 
 62821: struct TabWidth {
 62821:   TabWidth(PRUint32 aOffset, PRUint32 aWidth)
 73750:     : mOffset(aOffset), mWidth(float(aWidth))
 62821:   { }
 62821: 
 62821:   PRUint32 mOffset; // character offset within the text covered by the
 62821:                     // PropertyProvider
 62821:   float    mWidth;  // extra space to be added at this position (in app units)
 62821: };
 62821: 
 62821: struct TabWidthStore {
 62821:   TabWidthStore()
 62821:     : mLimit(0)
 62821:   { }
 62821: 
 62821:   // Apply tab widths to the aSpacing array, which corresponds to characters
 62821:   // beginning at aOffset and has length aLength. (Width records outside this
 62821:   // range will be ignored.)
 62821:   void ApplySpacing(gfxTextRun::PropertyProvider::Spacing *aSpacing,
 62821:                     PRUint32 aOffset, PRUint32 aLength);
 62821: 
 62821:   PRUint32           mLimit;  // offset up to which tabs have been measured;
 62821:                               // positions beyond this have not been calculated
 62821:                               // yet but may be appended if needed later
 62821:   nsTArray<TabWidth> mWidths; // (offset,width) records for each tab character
 62821: };
 62821: 
 62821: void
 62821: TabWidthStore::ApplySpacing(gfxTextRun::PropertyProvider::Spacing *aSpacing,
 62821:                             PRUint32 aOffset, PRUint32 aLength)
 62821: {
 62821:   // We could binary-search for the first record that falls within the range,
 62821:   // but as the number of tabs is normally small and we usually process them
 62821:   // sequentially from the beginning of the line, it doesn't seem worth doing
 62821:   // at this point.
 62821:   for (PRUint32 i = 0; i < mWidths.Length(); ++i) {
 62821:     TabWidth& tw = mWidths[i];
 62821:     if (tw.mOffset < aOffset) {
 62821:       continue;
 62821:     }
 62821:     if (tw.mOffset - aOffset >= aLength) {
 62821:       break;
 62821:     }
 62821:     aSpacing[tw.mOffset - aOffset].mAfter += tw.mWidth;
 62821:   }
 62821: }
 62821: 
 39965: static void DestroyTabWidth(void* aPropertyValue)
 39965: {
 62821:   delete static_cast<TabWidthStore*>(aPropertyValue);
 39965: }
 39965: 
 39965: NS_DECLARE_FRAME_PROPERTY(TabWidthProperty, DestroyTabWidth)
 39965: 
 49293: NS_DECLARE_FRAME_PROPERTY(OffsetToFrameProperty, nsnull)
 49293: 
 82675: // text runs are destroyed by the text run cache
 82675: NS_DECLARE_FRAME_PROPERTY(UninflatedTextRunProperty, nsnull)
 82675: 
 82675: NS_DECLARE_FRAME_PROPERTY(FontSizeInflationProperty, nsnull)
 82675: 
     1: // The following flags are set during reflow
     1: 
     1: // This bit is set on the first frame in a continuation indicating
     1: // that it was chopped short because of :first-letter style.
 43376: #define TEXT_FIRST_LETTER    NS_FRAME_STATE_BIT(20)
     1: // This bit is set on frames that are logically adjacent to the start of the
     1: // line (i.e. no prior frame on line with actual displayed in-flow content).
 43376: #define TEXT_START_OF_LINE   NS_FRAME_STATE_BIT(21)
     1: // This bit is set on frames that are logically adjacent to the end of the
     1: // line (i.e. no following on line with actual displayed in-flow content).
 43376: #define TEXT_END_OF_LINE     NS_FRAME_STATE_BIT(22)
     1: // This bit is set on frames that end with a hyphenated break.
 43376: #define TEXT_HYPHEN_BREAK    NS_FRAME_STATE_BIT(23)
     8: // This bit is set on frames that trimmed trailing whitespace characters when
     8: // calculating their width during reflow.
 43376: #define TEXT_TRIMMED_TRAILING_WHITESPACE NS_FRAME_STATE_BIT(24)
 16575: // This bit is set on frames that have justification enabled. We record
 16575: // this in a state bit because we don't always have the containing block
 16575: // easily available to check text-align on.
 43376: #define TEXT_JUSTIFICATION_ENABLED       NS_FRAME_STATE_BIT(25)
 13714: // Set this bit if the textframe has overflow area for IME/spellcheck underline.
 43376: #define TEXT_SELECTION_UNDERLINE_OVERFLOWED NS_FRAME_STATE_BIT(26)
     1: 
     1: #define TEXT_REFLOW_FLAGS    \
     8:   (TEXT_FIRST_LETTER|TEXT_START_OF_LINE|TEXT_END_OF_LINE|TEXT_HYPHEN_BREAK| \
 16575:    TEXT_TRIMMED_TRAILING_WHITESPACE|TEXT_JUSTIFICATION_ENABLED| \
 16575:    TEXT_HAS_NONCOLLAPSED_CHARACTERS|TEXT_SELECTION_UNDERLINE_OVERFLOWED)
     1: 
     1: // Cache bits for IsEmpty().
     1: // Set this bit if the textframe is known to be only collapsible whitespace.
 43376: #define TEXT_IS_ONLY_WHITESPACE    NS_FRAME_STATE_BIT(27)
     1: // Set this bit if the textframe is known to be not only collapsible whitespace.
 43376: #define TEXT_ISNOT_ONLY_WHITESPACE NS_FRAME_STATE_BIT(28)
 43376: 
 43376: #define TEXT_WHITESPACE_FLAGS      (TEXT_IS_ONLY_WHITESPACE | \
 43376:                                     TEXT_ISNOT_ONLY_WHITESPACE)
 35581: // This bit is set while the frame is registered as a blinking frame.
 43376: #define TEXT_BLINK_ON              NS_FRAME_STATE_BIT(29)
 16737: 
 22875: // Set when this text frame is mentioned in the userdata for a textrun
 43376: #define TEXT_IN_TEXTRUN_USER_DATA  NS_FRAME_STATE_BIT(30)
 22875: 
 16737: // nsTextFrame.h has
 43376: // #define TEXT_HAS_NONCOLLAPSED_CHARACTERS NS_FRAME_STATE_BIT(31)
 82675: // #define TEXT_HAS_FONT_INFLATION          NS_FRAME_STATE_BIT(61)
     1: 
 77246: // If true, then this frame is being removed due to a SetLength() on a
 77246: // previous continuation and the style context of that previous
 77246: // continuation is the same as this frame's
 77246: #define TEXT_STYLE_MATCHES_PREV_CONTINUATION NS_FRAME_STATE_BIT(62)
 77246: 
 49293: // Whether this frame is cached in the Offset Frame Cache (OffsetToFrameProperty)
 49293: #define TEXT_IN_OFFSET_CACHE       NS_FRAME_STATE_BIT(63)
 49293: 
     1: /*
     1:  * Some general notes
     1:  * 
     1:  * Text frames delegate work to gfxTextRun objects. The gfxTextRun object
     1:  * transforms text to positioned glyphs. It can report the geometry of the
     1:  * glyphs and paint them. Text frames configure gfxTextRuns by providing text,
     1:  * spacing, language, and other information.
     1:  * 
     1:  * A gfxTextRun can cover more than one DOM text node. This is necessary to
     1:  * get kerning, ligatures and shaping for text that spans multiple text nodes
     1:  * but is all the same font. The userdata for a gfxTextRun object is a
     1:  * TextRunUserData* or an nsIFrame*.
     1:  * 
     1:  * We go to considerable effort to make sure things work even if in-flow
     1:  * siblings have different style contexts (i.e., first-letter and first-line).
     1:  * 
     1:  * Our convention is that unsigned integer character offsets are offsets into
     1:  * the transformed string. Signed integer character offsets are offsets into
     1:  * the DOM string.
     1:  * 
     1:  * XXX currently we don't handle hyphenated breaks between text frames where the
     1:  * hyphen occurs at the end of the first text frame, e.g.
     1:  *   <b>Kit&shy;</b>ty
     1:  */
     1: 
     1: /**
     1:  * We use an array of these objects to record which text frames
     1:  * are associated with the textrun. mStartFrame is the start of a list of
     1:  * text frames. Some sequence of its continuations are covered by the textrun.
     1:  * A content textnode can have at most one TextRunMappedFlow associated with it
     1:  * for a given textrun.
     1:  * 
     1:  * mDOMOffsetToBeforeTransformOffset is added to DOM offsets for those frames to obtain
     1:  * the offset into the before-transformation text of the textrun. It can be
     1:  * positive (when a text node starts in the middle of a text run) or
  2344:  * negative (when a text run starts in the middle of a text node). Of course
  2344:  * it can also be zero.
     1:  */
     1: struct TextRunMappedFlow {
     1:   nsTextFrame* mStartFrame;
     1:   PRInt32      mDOMOffsetToBeforeTransformOffset;
     1:   // The text mapped starts at mStartFrame->GetContentOffset() and is this long
     1:   PRUint32     mContentLength;
     1: };
     1: 
     1: /**
  2344:  * This is our user data for the textrun, when textRun->GetFlags() does not
 34012:  * have TEXT_IS_SIMPLE_FLOW set. When TEXT_IS_SIMPLE_FLOW is set, there is
 34012:  * just one flow, the textrun's user data pointer is a pointer to mStartFrame
  2344:  * for that flow, mDOMOffsetToBeforeTransformOffset is zero, and mContentLength
  2344:  * is the length of the text node.
     1:  */
     1: struct TextRunUserData {
     1:   TextRunMappedFlow* mMappedFlows;
 64106:   PRUint32           mMappedFlowCount;
     1:   PRUint32           mLastFlowIndex;
     1: };
     1: 
     1: /**
     1:  * This helper object computes colors used for painting, and also IME
     1:  * underline information. The data is computed lazily and cached as necessary.
     1:  * These live for just the duration of one paint operation.
     1:  */
     1: class nsTextPaintStyle {
     1: public:
     1:   nsTextPaintStyle(nsTextFrame* aFrame);
     1: 
     1:   nscolor GetTextColor();
     1:   /**
     1:    * Compute the colors for normally-selected text. Returns false if
     1:    * the normal selection is not being displayed.
     1:    */
 79445:   bool GetSelectionColors(nscolor* aForeColor,
     1:                             nscolor* aBackColor);
 16313:   void GetHighlightColors(nscolor* aForeColor,
 16313:                           nscolor* aBackColor);
 69254:   void GetURLSecondaryColor(nscolor* aForeColor);
     1:   void GetIMESelectionColors(PRInt32  aIndex,
     1:                              nscolor* aForeColor,
     1:                              nscolor* aBackColor);
 80486:   // if this returns false, we don't need to draw underline.
 79445:   bool GetSelectionUnderlineForPaint(PRInt32  aIndex,
 26883:                                        nscolor* aLineColor,
 26883:                                        float*   aRelativeSize,
 26883:                                        PRUint8* aStyle);
 26883: 
 80486:   // if this returns false, we don't need to draw underline.
 79445:   static bool GetSelectionUnderline(nsPresContext* aPresContext,
 26883:                                       PRInt32 aIndex,
     1:                                       nscolor* aLineColor,
  4728:                                       float* aRelativeSize,
  4728:                                       PRUint8* aStyle);
     1: 
 74795:   nsPresContext* PresContext() const { return mPresContext; }
     1: 
     1:   enum {
     1:     eIndexRawInput = 0,
     1:     eIndexSelRawText,
     1:     eIndexConvText,
 26883:     eIndexSelConvText,
 26883:     eIndexSpellChecker
     1:   };
     1: 
 26883:   static PRInt32 GetUnderlineStyleIndexForSelectionType(PRInt32 aSelectionType)
 26883:   {
 26883:     switch (aSelectionType) {
 26883:       case nsISelectionController::SELECTION_IME_RAWINPUT:
 26883:         return eIndexRawInput;
 26883:       case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
 26883:         return eIndexSelRawText;
 26883:       case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
 26883:         return eIndexConvText;
 26883:       case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT:
 26883:         return eIndexSelConvText;
 26883:       case nsISelectionController::SELECTION_SPELLCHECK:
 26883:         return eIndexSpellChecker;
 26883:       default:
 26883:         NS_WARNING("non-IME selection type");
 26883:         return eIndexRawInput;
 26883:     }
 26883:   }
 26883: 
     1: protected:
     1:   nsTextFrame*   mFrame;
     1:   nsPresContext* mPresContext;
 79445:   bool           mInitCommonColors;
 79445:   bool           mInitSelectionColors;
     1: 
     1:   // Selection data
     1: 
     1:   PRInt16      mSelectionStatus; // see nsIDocument.h SetDisplaySelection()
     1:   nscolor      mSelectionTextColor;
     1:   nscolor      mSelectionBGColor;
     1: 
     1:   // Common data
     1: 
     1:   PRInt32 mSufficientContrast;
     1:   nscolor mFrameBackgroundColor;
     1: 
 26883:   // selection colors and underline info, the colors are resolved colors,
 26883:   // i.e., the foreground color and background color are swapped if it's needed.
 26883:   // And also line color will be resolved from them.
 26883:   struct nsSelectionStyle {
 79445:     bool mInit;
     1:     nscolor mTextColor;
     1:     nscolor mBGColor;
     1:     nscolor mUnderlineColor;
  4728:     PRUint8 mUnderlineStyle;
 26883:     float   mUnderlineRelativeSize;
     1:   };
 26883:   nsSelectionStyle mSelectionStyle[5];
     1: 
     1:   // Color initializations
     1:   void InitCommonColors();
 79445:   bool InitSelectionColors();
     1: 
 26883:   nsSelectionStyle* GetSelectionStyle(PRInt32 aIndex);
 26883:   void InitSelectionStyle(PRInt32 aIndex);
     1: 
 79445:   bool EnsureSufficientContrast(nscolor *aForeColor, nscolor *aBackColor);
     1: 
     1:   nscolor GetResolvedForeColor(nscolor aColor, nscolor aDefaultForeColor,
     1:                                nscolor aBackColor);
     1: };
     1: 
  1328: static void
  1328: DestroyUserData(void* aUserData)
  1328: {
  3233:   TextRunUserData* userData = static_cast<TextRunUserData*>(aUserData);
  1328:   if (userData) {
  1328:     nsMemory::Free(userData);
  1328:   }
  1328: }
  1328: 
 55835: /**
 55835:  * Remove |aTextRun| from the frame continuation chain starting at
 55835:  * |aStartContinuation| if non-null, otherwise starting at |aFrame|.
 55835:  * Unmark |aFrame| as a text run owner if it's the frame we start at.
 80486:  * Return true if |aStartContinuation| is non-null and was found
 55835:  * in the next-continuation chain of |aFrame|.
 55835:  */
 79445: static bool
 55835: ClearAllTextRunReferences(nsTextFrame* aFrame, gfxTextRun* aTextRun,
 55835:                           nsTextFrame* aStartContinuation)
 55835: {
 55835:   NS_PRECONDITION(aFrame, "");
 55835:   NS_PRECONDITION(!aStartContinuation ||
 82675:                   (!aStartContinuation->GetTextRun(nsTextFrame::eInflated) ||
 82675:                    aStartContinuation->GetTextRun(nsTextFrame::eInflated) == aTextRun) ||
 82675:                   (!aStartContinuation->GetTextRun(nsTextFrame::eNotInflated) ||
 82675:                    aStartContinuation->GetTextRun(nsTextFrame::eNotInflated) == aTextRun),
 55835:                   "wrong aStartContinuation for this text run");
 55835: 
 55835:   if (!aStartContinuation || aStartContinuation == aFrame) {
 22875:     aFrame->RemoveStateBits(TEXT_IN_TEXTRUN_USER_DATA);
 55835:   } else {
 55835:     do {
 55835:       NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame, "Bad frame");
 55835:       aFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());
 55835:     } while (aFrame && aFrame != aStartContinuation);
 55835:   }
 79445:   bool found = aStartContinuation == aFrame;
  1328:   while (aFrame) {
 55835:     NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame, "Bad frame");
 99221:     if (!aFrame->RemoveTextRun(aTextRun)) {
  1328:       break;
 99221:     }
  3233:     aFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());
  1328:   }
 55835:   NS_POSTCONDITION(!found || aStartContinuation, "how did we find null?");
 55835:   return found;
 55835: }
 55835: 
 55835: /**
 55835:  * Kill all references to |aTextRun| starting at |aStartContinuation|.
 55835:  * It could be referenced by any of its owners, and all their in-flows.
 55835:  * If |aStartContinuation| is null then process all userdata frames
 55835:  * and their continuations.
 55835:  * @note the caller is expected to take care of possibly destroying the
 55835:  * text run if all userdata frames were reset (userdata is deallocated
 55835:  * by this function though). The caller can detect this has occured by
 55835:  * checking |aTextRun->GetUserData() == nsnull|.
 55835:  */
  1328: static void
 55835: UnhookTextRunFromFrames(gfxTextRun* aTextRun, nsTextFrame* aStartContinuation)
  1328: {
  1328:   if (!aTextRun->GetUserData())
  1328:     return;
  1328: 
  1328:   if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
 55835:     nsIFrame* userDataFrame = static_cast<nsIFrame*>(aTextRun->GetUserData());
 79445:     DebugOnly<bool> found =
 55835:       ClearAllTextRunReferences(static_cast<nsTextFrame*>(userDataFrame),
 55835:                                 aTextRun, aStartContinuation);
 55835:     NS_ASSERTION(!aStartContinuation || found,
 55835:                  "aStartContinuation wasn't found in simple flow text run");
 55835:     if (!(userDataFrame->GetStateBits() & TEXT_IN_TEXTRUN_USER_DATA)) {
 55835:       aTextRun->SetUserData(nsnull);
 55835:     }
  1328:   } else {
  1328:     TextRunUserData* userData =
  3233:       static_cast<TextRunUserData*>(aTextRun->GetUserData());
 55835:     PRInt32 destroyFromIndex = aStartContinuation ? -1 : 0;
 64106:     for (PRUint32 i = 0; i < userData->mMappedFlowCount; ++i) {
 55835:       nsTextFrame* userDataFrame = userData->mMappedFlows[i].mStartFrame;
 79445:       bool found =
 55835:         ClearAllTextRunReferences(userDataFrame, aTextRun,
 55835:                                   aStartContinuation);
 55835:       if (found) {
 55835:         if (userDataFrame->GetStateBits() & TEXT_IN_TEXTRUN_USER_DATA) {
 55835:           destroyFromIndex = i + 1;
 55835:         }
 55835:         else {
 55835:           destroyFromIndex = i;
 55835:         }
 55835:         aStartContinuation = nsnull;
 55835:       }
 55835:     }
 55835:     NS_ASSERTION(destroyFromIndex >= 0,
 55835:                  "aStartContinuation wasn't found in multi flow text run");
 55835:     if (destroyFromIndex == 0) {
  1328:       DestroyUserData(userData);
  1328:       aTextRun->SetUserData(nsnull);
  1328:     }
 55835:     else {
 64106:       userData->mMappedFlowCount = PRUint32(destroyFromIndex);
 64106:       if (userData->mLastFlowIndex >= PRUint32(destroyFromIndex)) {
 64106:         userData->mLastFlowIndex = PRUint32(destroyFromIndex) - 1;
 56311:       }
 55835:     }
 55835:   }
 55835: }
  1328: 
  1328: class FrameTextRunCache;
  1328: 
  1328: static FrameTextRunCache *gTextRuns = nsnull;
  1328: 
  1328: /*
  1328:  * Cache textruns and expire them after 3*10 seconds of no use.
  1328:  */
  1328: class FrameTextRunCache : public nsExpirationTracker<gfxTextRun,3> {
  1328: public:
  1328:   enum { TIMEOUT_SECONDS = 10 };
  1328:   FrameTextRunCache()
  1328:       : nsExpirationTracker<gfxTextRun,3>(TIMEOUT_SECONDS*1000) {}
  1328:   ~FrameTextRunCache() {
  1328:     AgeAllGenerations();
  1328:   }
  1328: 
  1328:   void RemoveFromCache(gfxTextRun* aTextRun) {
  2319:     if (aTextRun->GetExpirationState()->IsTracked()) {
  1328:       RemoveObject(aTextRun);
  2319:     }
  1328:   }
  1328: 
  1328:   // This gets called when the timeout has expired on a gfxTextRun
  1328:   virtual void NotifyExpired(gfxTextRun* aTextRun) {
 55835:     UnhookTextRunFromFrames(aTextRun, nsnull);
  1328:     RemoveFromCache(aTextRun);
  1328:     delete aTextRun;
  1328:   }
  1328: };
  1328: 
 86690: // Helper to create a textrun and remember it in the textframe cache,
 86690: // for either 8-bit or 16-bit text strings
 86690: template<typename T>
 86690: gfxTextRun *
 86690: MakeTextRun(const T *aText, PRUint32 aLength,
  1328:             gfxFontGroup *aFontGroup, const gfxFontGroup::Parameters* aParams,
  1328:             PRUint32 aFlags)
  1328: {
 86690:     nsAutoPtr<gfxTextRun> textRun(aFontGroup->MakeTextRun(aText, aLength,
 86690:                                                           aParams, aFlags));
 86690:     if (!textRun) {
  1328:         return nsnull;
 86690:     }
  1328:     nsresult rv = gTextRuns->AddObject(textRun);
  2319:     if (NS_FAILED(rv)) {
  2319:         gTextRuns->RemoveFromCache(textRun);
  1328:         return nsnull;
  2319:     }
 67826: #ifdef NOISY_BIDI
 67826:     printf("Created textrun\n");
 67826: #endif
  1328:     return textRun.forget();
  1328: }
  1328: 
 72507: void
  1328: nsTextFrameTextRunCache::Init() {
  1328:     gTextRuns = new FrameTextRunCache();
  1328: }
  1328: 
  1328: void
  1328: nsTextFrameTextRunCache::Shutdown() {
  1328:     delete gTextRuns;
  1328:     gTextRuns = nsnull;
  1328: }
  1328: 
  4678: PRInt32 nsTextFrame::GetContentEnd() const {
  4678:   nsTextFrame* next = static_cast<nsTextFrame*>(GetNextContinuation());
 35581:   return next ? next->GetContentOffset() : mContent->GetText()->GetLength();
  4678: }
  4678: 
 70231: struct FlowLengthProperty {
 70231:   PRInt32 mStartOffset;
 70231:   // The offset of the next fixed continuation after mStartOffset, or
 70231:   // of the end of the text if there is none
 70231:   PRInt32 mEndFlowOffset;
 70231: 
 70231:   static void Destroy(void* aObject, nsIAtom* aPropertyName,
 70231:                       void* aPropertyValue, void* aData)
 70231:   {
 70231:     delete static_cast<FlowLengthProperty*>(aPropertyValue);
 70231:   }
 70231: };
 70231: 
     1: PRInt32 nsTextFrame::GetInFlowContentLength() {
 70231:   if (!(mState & NS_FRAME_IS_BIDI)) {
 70231:     return mContent->TextLength() - mContentOffset;
 70231:   }
 70231: 
 70231:   FlowLengthProperty* flowLength =
 70231:     static_cast<FlowLengthProperty*>(mContent->GetProperty(nsGkAtoms::flowlength));
 70231: 
 71043:   /**
 71043:    * This frame must start inside the cached flow. If the flow starts at
 71043:    * mContentOffset but this frame is empty, logically it might be before the
 71043:    * start of the cached flow.
 71043:    */
 71043:   if (flowLength && 
 71043:       (flowLength->mStartOffset < mContentOffset ||
 71043:        (flowLength->mStartOffset == mContentOffset && GetContentEnd() > mContentOffset)) &&
 70231:       flowLength->mEndFlowOffset > mContentOffset) {
 70231: #ifdef DEBUG
 71043:     NS_ASSERTION(flowLength->mEndFlowOffset >= GetContentEnd(),
 70231: 		 "frame crosses fixed continuation boundary");
 70231: #endif
 70231:     return flowLength->mEndFlowOffset - mContentOffset;
 70231:   }
 70231: 
 71043:   nsTextFrame* nextBidi = static_cast<nsTextFrame*>(GetLastInFlow()->GetNextContinuation());
 71043:   PRInt32 endFlow = nextBidi ? nextBidi->GetContentOffset() : mContent->TextLength();
 70231: 
 70231:   if (!flowLength) {
 70231:     flowLength = new FlowLengthProperty;
 70231:     if (NS_FAILED(mContent->SetProperty(nsGkAtoms::flowlength, flowLength,
 70231:                                         FlowLengthProperty::Destroy))) {
 70231:       delete flowLength;
 70231:       flowLength = nsnull;
 70231:     }
 70231:   }
 70231:   if (flowLength) {
 70231:     flowLength->mStartOffset = mContentOffset;
 70231:     flowLength->mEndFlowOffset = endFlow;
 70231:   }
 70231: 
 70231:   return endFlow - mContentOffset;
     1: }
     1: 
     1: // Smarter versions of XP_IS_SPACE.
     1: // Unicode is really annoying; sometimes a space character isn't whitespace ---
     1: // when it combines with another character
     1: // So we have several versions of IsSpace for use in different contexts.
     1: 
 79445: static bool IsSpaceCombiningSequenceTail(const nsTextFragment* aFrag, PRUint32 aPos)
  2344: {
  2344:   NS_ASSERTION(aPos <= aFrag->GetLength(), "Bad offset");
  2344:   if (!aFrag->Is2b())
 80486:     return false;
  2344:   return nsTextFrameUtils::IsSpaceCombiningSequenceTail(
  2344:     aFrag->Get2b() + aPos, aFrag->GetLength() - aPos);
  2344: }
  2344: 
  2344: // Check whether aPos is a space for CSS 'word-spacing' purposes
 79445: static bool IsCSSWordSpacingSpace(const nsTextFragment* aFrag,
 22494:                                     PRUint32 aPos, const nsStyleText* aStyleText)
     1: {
     1:   NS_ASSERTION(aPos < aFrag->GetLength(), "No text for IsSpace!");
 16575: 
     1:   PRUnichar ch = aFrag->CharAt(aPos);
 22494:   switch (ch) {
 22494:   case ' ':
 22494:   case CH_NBSP:
  2344:     return !IsSpaceCombiningSequenceTail(aFrag, aPos + 1);
 46149:   case '\r':
 22494:   case '\t': return !aStyleText->WhiteSpaceIsSignificant();
 22494:   case '\n': return !aStyleText->NewlineIsSignificant();
 80486:   default: return false;
 22494:   }
 16575: }
 16575: 
 16575: // Check whether the string aChars/aLength starts with space that's
 16575: // trimmable according to CSS 'white-space:normal/nowrap'. 
 79445: static bool IsTrimmableSpace(const PRUnichar* aChars, PRUint32 aLength)
     1: {
     1:   NS_ASSERTION(aLength > 0, "No text for IsSpace!");
 16575: 
     1:   PRUnichar ch = *aChars;
  2344:   if (ch == ' ')
     1:     return !nsTextFrameUtils::IsSpaceCombiningSequenceTail(aChars + 1, aLength - 1);
 46149:   return ch == '\t' || ch == '\f' || ch == '\n' || ch == '\r';
 16575: }
 16575: 
 16575: // Check whether the character aCh is trimmable according to CSS
 16575: // 'white-space:normal/nowrap'
 79445: static bool IsTrimmableSpace(char aCh)
     1: {
 46149:   return aCh == ' ' || aCh == '\t' || aCh == '\f' || aCh == '\n' || aCh == '\r';
 16575: }
 16575: 
 79445: static bool IsTrimmableSpace(const nsTextFragment* aFrag, PRUint32 aPos,
 16575:                                const nsStyleText* aStyleText)
     1: {
     1:   NS_ASSERTION(aPos < aFrag->GetLength(), "No text for IsSpace!");
 16575: 
 16575:   switch (aFrag->CharAt(aPos)) {
 16575:   case ' ': return !aStyleText->WhiteSpaceIsSignificant() &&
 16575:                    !IsSpaceCombiningSequenceTail(aFrag, aPos + 1);
 16575:   case '\n': return !aStyleText->NewlineIsSignificant();
 16575:   case '\t':
 46149:   case '\r':
 16575:   case '\f': return !aStyleText->WhiteSpaceIsSignificant();
 80486:   default: return false;
 16575:   }
  6529: }
  6529: 
 79445: static bool IsSelectionSpace(const nsTextFragment* aFrag, PRUint32 aPos)
  2319: {
  2319:   NS_ASSERTION(aPos < aFrag->GetLength(), "No text for IsSpace!");
  2319:   PRUnichar ch = aFrag->CharAt(aPos);
  3049:   if (ch == ' ' || ch == CH_NBSP)
  2344:     return !IsSpaceCombiningSequenceTail(aFrag, aPos + 1);
 46149:   return ch == '\t' || ch == '\n' || ch == '\f' || ch == '\r';
  2319: }
  2344: 
 16575: // Count the amount of trimmable whitespace (as per CSS
 16575: // 'white-space:normal/nowrap') in a text fragment. The first
  2344: // character is at offset aStartOffset; the maximum number of characters
  2344: // to check is aLength. aDirection is -1 or 1 depending on whether we should
  2344: // progress backwards or forwards.
  2344: static PRUint32
 16575: GetTrimmableWhitespaceCount(const nsTextFragment* aFrag,
 16575:                             PRInt32 aStartOffset, PRInt32 aLength,
 16575:                             PRInt32 aDirection)
     1: {
     1:   PRInt32 count = 0;
  2344:   if (aFrag->Is2b()) {
  2344:     const PRUnichar* str = aFrag->Get2b() + aStartOffset;
  2344:     PRInt32 fragLen = aFrag->GetLength() - aStartOffset;
     1:     for (; count < aLength; ++count) {
  2344:       if (!IsTrimmableSpace(str, fragLen))
     1:         break;
     1:       str += aDirection;
     1:       fragLen -= aDirection;
     1:     }
     1:   } else {
  2344:     const char* str = aFrag->Get1b() + aStartOffset;
     1:     for (; count < aLength; ++count) {
  2344:       if (!IsTrimmableSpace(*str))
     1:         break;
     1:       str += aDirection;
     1:     }
     1:   }
     1:   return count;
     1: }
     1: 
 79445: static bool
 79445: IsAllWhitespace(const nsTextFragment* aFrag, bool aAllowNewline)
 16575: {
 16575:   if (aFrag->Is2b())
 80486:     return false;
 16575:   PRInt32 len = aFrag->GetLength();
 16575:   const char* str = aFrag->Get1b();
 16575:   for (PRInt32 i = 0; i < len; ++i) {
 16575:     char ch = str[i];
 46149:     if (ch == ' ' || ch == '\t' || ch == '\r' || (ch == '\n' && aAllowNewline))
 16575:       continue;
 80486:     return false;
 80486:   }
 80486:   return true;
 16575: }
 16575: 
     1: /**
     1:  * This class accumulates state as we scan a paragraph of text. It detects
     1:  * textrun boundaries (changes from text to non-text, hard
     1:  * line breaks, and font changes) and builds a gfxTextRun at each boundary.
     1:  * It also detects linebreaker run boundaries (changes from text to non-text,
     1:  * and hard line breaks) and at each boundary runs the linebreaker to compute
     1:  * potential line breaks. It also records actual line breaks to store them in
     1:  * the textruns.
     1:  */
     1: class BuildTextRunsScanner {
     1: public:
  2319:   BuildTextRunsScanner(nsPresContext* aPresContext, gfxContext* aContext,
 94144:       nsIFrame* aLineContainer, nsTextFrame::TextRunType aWhichTextRun) :
  1817:     mCurrentFramesAllSameTextRun(nsnull),
  2319:     mContext(aContext),
  2319:     mLineContainer(aLineContainer),
  2319:     mBidiEnabled(aPresContext->BidiEnabled()),
 80486:     mSkipIncompleteTextRuns(false),
 82675:     mWhichTextRun(aWhichTextRun),
 22917:     mNextRunContextInfo(nsTextFrameUtils::INCOMING_NONE),
 22935:     mCurrentRunContextInfo(nsTextFrameUtils::INCOMING_NONE) {
     1:     ResetRunInfo();
     1:   }
 23491:   ~BuildTextRunsScanner() {
 23491:     NS_ASSERTION(mBreakSinks.IsEmpty(), "Should have been cleared");
 23491:     NS_ASSERTION(mTextRunsToDelete.IsEmpty(), "Should have been cleared");
 23491:     NS_ASSERTION(mLineBreakBeforeFrames.IsEmpty(), "Should have been cleared");
 23491:     NS_ASSERTION(mMappedFlows.IsEmpty(), "Should have been cleared");
 23491:   }
     1: 
     1:   void SetAtStartOfLine() {
 80486:     mStartOfLine = true;
 80486:     mCanStopOnThisLine = false;
     1:   }
 79445:   void SetSkipIncompleteTextRuns(bool aSkip) {
  2319:     mSkipIncompleteTextRuns = aSkip;
  2319:   }
     1:   void SetCommonAncestorWithLastFrame(nsIFrame* aFrame) {
     1:     mCommonAncestorWithLastFrame = aFrame;
     1:   }
 79445:   bool CanStopOnThisLine() {
  7722:     return mCanStopOnThisLine;
  7722:   }
     1:   nsIFrame* GetCommonAncestorWithLastFrame() {
     1:     return mCommonAncestorWithLastFrame;
     1:   }
     8:   void LiftCommonAncestorWithLastFrameToParent(nsIFrame* aFrame) {
     8:     if (mCommonAncestorWithLastFrame &&
     8:         mCommonAncestorWithLastFrame->GetParent() == aFrame) {
     8:       mCommonAncestorWithLastFrame = aFrame;
     8:     }
     8:   }
     1:   void ScanFrame(nsIFrame* aFrame);
 79445:   bool IsTextRunValidForMappedFlows(gfxTextRun* aTextRun);
 79445:   void FlushFrames(bool aFlushLineBreaks, bool aSuppressTrailingBreak);
 23491:   void FlushLineBreaks(gfxTextRun* aTrailingTextRun);
     1:   void ResetRunInfo() {
     1:     mLastFrame = nsnull;
     1:     mMappedFlows.Clear();
     8:     mLineBreakBeforeFrames.Clear();
     1:     mMaxTextLength = 0;
 80486:     mDoubleByteText = false;
     1:   }
     1:   void AccumulateRunInfo(nsTextFrame* aFrame);
  8573:   /**
  8573:    * @return null to indicate either textrun construction failed or
  8573:    * we constructed just a partial textrun to set up linebreaker and other
  8573:    * state for following textruns.
  8573:    */
 87227:   gfxTextRun* BuildTextRunForFrames(void* aTextBuffer);
 86697:   bool SetupLineBreakerContext(gfxTextRun *aTextRun);
 94144:   void AssignTextRun(gfxTextRun* aTextRun, float aInflation);
     1:   nsTextFrame* GetNextBreakBeforeFrame(PRUint32* aIndex);
 86697:   enum SetupBreakSinksFlags {
 86697:     SBS_DOUBLE_BYTE =      (1 << 0),
 86697:     SBS_EXISTING_TEXTRUN = (1 << 1),
 86697:     SBS_SUPPRESS_SINK    = (1 << 2)
 86697:   };
 86697:   void SetupBreakSinksForTextRun(gfxTextRun* aTextRun,
 86697:                                  const void* aTextPtr,
 86697:                                  PRUint32    aFlags);
  2319:   struct FindBoundaryState {
  2319:     nsIFrame*    mStopAtFrame;
  2319:     nsTextFrame* mFirstTextFrame;
  2319:     nsTextFrame* mLastTextFrame;
 79445:     bool mSeenTextRunBoundaryOnLaterLine;
 79445:     bool mSeenTextRunBoundaryOnThisLine;
 79445:     bool mSeenSpaceForLineBreakingOnThisLine;
  2319:   };
  2319:   enum FindBoundaryResult {
  2319:     FB_CONTINUE,
  2319:     FB_STOPPED_AT_STOP_FRAME,
  2319:     FB_FOUND_VALID_TEXTRUN_BOUNDARY
  2319:   };
  2319:   FindBoundaryResult FindBoundaries(nsIFrame* aFrame, FindBoundaryState* aState);
     1: 
 79445:   bool ContinueTextRunAcrossFrames(nsTextFrame* aFrame1, nsTextFrame* aFrame2);
     1: 
     1:   // Like TextRunMappedFlow but with some differences. mStartFrame to mEndFrame
  6033:   // (exclusive) are a sequence of in-flow frames (if mEndFrame is null, then
  6033:   // continuations starting from mStartFrame are a sequence of in-flow frames).
     1:   struct MappedFlow {
     1:     nsTextFrame* mStartFrame;
     1:     nsTextFrame* mEndFrame;
  2013:     // When we consider breaking between elements, the nearest common
  2013:     // ancestor of the elements containing the characters is the one whose
     1:     // CSS 'white-space' property governs. So this records the nearest common
     1:     // ancestor of mStartFrame and the previous text frame, or null if there
     1:     // was no previous text frame on this line.
     1:     nsIFrame*    mAncestorControllingInitialBreak;
  6033:     
  6033:     PRInt32 GetContentEnd() {
  6033:       return mEndFrame ? mEndFrame->GetContentOffset()
 35581:           : mStartFrame->GetContent()->GetText()->GetLength();
  6033:     }
     1:   };
     1: 
     1:   class BreakSink : public nsILineBreakSink {
     1:   public:
  2834:     BreakSink(gfxTextRun* aTextRun, gfxContext* aContext, PRUint32 aOffsetIntoTextRun,
 79445:               bool aExistingTextRun) :
  2834:                 mTextRun(aTextRun), mContext(aContext),
  2834:                 mOffsetIntoTextRun(aOffsetIntoTextRun),
 80486:                 mChangedBreaks(false), mExistingTextRun(aExistingTextRun) {}
     1: 
     1:     virtual void SetBreaks(PRUint32 aOffset, PRUint32 aLength,
 69311:                            PRUint8* aBreakBefore) {
     1:       if (mTextRun->SetPotentialLineBreaks(aOffset + mOffsetIntoTextRun, aLength,
  2834:                                            aBreakBefore, mContext)) {
 80486:         mChangedBreaks = true;
  7069:         // Be conservative and assume that some breaks have been set
  7069:         mTextRun->ClearFlagBits(nsTextFrameUtils::TEXT_NO_BREAKS);
     1:       }
     1:     }
     1:     
  7832:     virtual void SetCapitalization(PRUint32 aOffset, PRUint32 aLength,
 79445:                                    bool* aCapitalize) {
  7832:       NS_ASSERTION(mTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_TRANSFORMED,
  7832:                    "Text run should be transformed!");
  7832:       nsTransformedTextRun* transformedTextRun =
  7832:         static_cast<nsTransformedTextRun*>(mTextRun);
  7832:       transformedTextRun->SetCapitalization(aOffset + mOffsetIntoTextRun, aLength,
  7832:                                             aCapitalize, mContext);
  7832:     }
  7832: 
 23491:     void Finish() {
 23491:       NS_ASSERTION(!(mTextRun->GetFlags() &
 86690:                      (gfxTextRunFactory::TEXT_UNUSED_FLAGS |
 23491:                       nsTextFrameUtils::TEXT_UNUSED_FLAG)),
 23491:                    "Flag set that should never be set! (memory safety error?)");
 23491:       if (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_TRANSFORMED) {
 23491:         nsTransformedTextRun* transformedTextRun =
 23491:           static_cast<nsTransformedTextRun*>(mTextRun);
 23491:         transformedTextRun->FinishSettingProperties(mContext);
 23491:       }
 23491:     }
 23491: 
     1:     gfxTextRun*  mTextRun;
  2834:     gfxContext*  mContext;
     1:     PRUint32     mOffsetIntoTextRun;
 79445:     bool mChangedBreaks;
 79445:     bool mExistingTextRun;
     1:   };
     1: 
     1: private:
     1:   nsAutoTArray<MappedFlow,10>   mMappedFlows;
     1:   nsAutoTArray<nsTextFrame*,50> mLineBreakBeforeFrames;
    60:   nsAutoTArray<nsAutoPtr<BreakSink>,10> mBreakSinks;
 23491:   nsAutoTArray<gfxTextRun*,5>   mTextRunsToDelete;
     1:   nsLineBreaker                 mLineBreaker;
     1:   gfxTextRun*                   mCurrentFramesAllSameTextRun;
     1:   gfxContext*                   mContext;
  2319:   nsIFrame*                     mLineContainer;
     1:   nsTextFrame*                  mLastFrame;
  8573:   // The common ancestor of the current frame and the previous leaf frame
  8573:   // on the line, or null if there was no previous leaf frame.
     1:   nsIFrame*                     mCommonAncestorWithLastFrame;
     1:   // mMaxTextLength is an upper bound on the size of the text in all mapped frames
 58221:   // The value PR_UINT32_MAX represents overflow; text will be discarded
     1:   PRUint32                      mMaxTextLength;
 79445:   bool                          mDoubleByteText;
 79445:   bool                          mBidiEnabled;
 79445:   bool                          mStartOfLine;
 79445:   bool                          mSkipIncompleteTextRuns;
 79445:   bool                          mCanStopOnThisLine;
 82675:   nsTextFrame::TextRunType      mWhichTextRun;
 22917:   PRUint8                       mNextRunContextInfo;
 22917:   PRUint8                       mCurrentRunContextInfo;
     1: };
     1: 
  1817: static nsIFrame*
  1817: FindLineContainer(nsIFrame* aFrame)
  1817: {
 16292:   while (aFrame && aFrame->CanContinueTextRun()) {
  1817:     aFrame = aFrame->GetParent();
  1817:   }
  1817:   return aFrame;
  1817: }
  1817: 
 79445: static bool
 32190: IsLineBreakingWhiteSpace(PRUnichar aChar)
 32190: {
 32190:   // 0x0A (\n) is not handled as white-space by the line breaker, since
 32190:   // we break before it, if it isn't transformed to a normal space.
 32190:   // (If we treat it as normal white-space then we'd only break after it.)
 32190:   // However, it does induce a line break or is converted to a regular
 32190:   // space, and either way it can be used to bound the region of text
 32190:   // that needs to be analyzed for line breaking.
 32190:   return nsLineBreaker::IsSpace(aChar) || aChar == 0x0A;
 32190: }
 32190: 
 79445: static bool
  2319: TextContainsLineBreakerWhiteSpace(const void* aText, PRUint32 aLength,
 79445:                                   bool aIsDoubleByte)
  2319: {
  2319:   PRUint32 i;
  2319:   if (aIsDoubleByte) {
  3233:     const PRUnichar* chars = static_cast<const PRUnichar*>(aText);
  2319:     for (i = 0; i < aLength; ++i) {
 32190:       if (IsLineBreakingWhiteSpace(chars[i]))
 80486:         return true;
 80486:     }
 80486:     return false;
  2319:   } else {
  3233:     const PRUint8* chars = static_cast<const PRUint8*>(aText);
  2319:     for (i = 0; i < aLength; ++i) {
 32190:       if (IsLineBreakingWhiteSpace(chars[i]))
 80486:         return true;
 80486:     }
 80486:     return false;
  2319:   }
  2319: }
  2319: 
 16292: struct FrameTextTraversal {
 21988:   // These fields identify which frames should be recursively scanned
 21988:   // The first normal frame to scan (or null, if no such frame should be scanned)
 21988:   nsIFrame*    mFrameToScan;
 21988:   // The first overflow frame to scan (or null, if no such frame should be scanned)
 21988:   nsIFrame*    mOverflowFrameToScan;
 21988:   // Whether to scan the siblings of mFrameToDescendInto/mOverflowFrameToDescendInto
 79445:   bool mScanSiblings;
 21988: 
 21988:   // These identify the boundaries of the context required for
 21988:   // line breaking or textrun construction
 79445:   bool mLineBreakerCanCrossFrameBoundary;
 79445:   bool mTextRunCanCrossFrameBoundary;
 21988: 
 21988:   nsIFrame* NextFrameToScan() {
 21988:     nsIFrame* f;
 21988:     if (mFrameToScan) {
 21988:       f = mFrameToScan;
 21988:       mFrameToScan = mScanSiblings ? f->GetNextSibling() : nsnull;
 21988:     } else if (mOverflowFrameToScan) {
 21988:       f = mOverflowFrameToScan;
 21988:       mOverflowFrameToScan = mScanSiblings ? f->GetNextSibling() : nsnull;
 21988:     } else {
 21988:       f = nsnull;
 21988:     }
 21988:     return f;
 21988:   }
 16292: };
 16292: 
 16292: static FrameTextTraversal
 16292: CanTextCrossFrameBoundary(nsIFrame* aFrame, nsIAtom* aType)
 16292: {
 16292:   NS_ASSERTION(aType == aFrame->GetType(), "Wrong type");
 16292: 
 16292:   FrameTextTraversal result;
 16292: 
 79445:   bool continuesTextRun = aFrame->CanContinueTextRun();
 16292:   if (aType == nsGkAtoms::placeholderFrame) {
  2742:     // placeholders are "invisible", so a text run should be able to span
 16292:     // across one. But don't descend into the out-of-flow.
 80486:     result.mLineBreakerCanCrossFrameBoundary = true;
 21988:     result.mOverflowFrameToScan = nsnull;
 16292:     if (continuesTextRun) {
 16292:       // ... Except for first-letter floats, which are really in-flow
 16292:       // from the point of view of capitalization etc, so we'd better
 16292:       // descend into them. But we actually need to break the textrun for
 16292:       // first-letter floats since things look bad if, say, we try to make a
 16292:       // ligature across the float boundary.
 21988:       result.mFrameToScan =
 16292:         (static_cast<nsPlaceholderFrame*>(aFrame))->GetOutOfFlowFrame();
 80486:       result.mScanSiblings = false;
 80486:       result.mTextRunCanCrossFrameBoundary = false;
 16292:     } else {
 21988:       result.mFrameToScan = nsnull;
 80486:       result.mTextRunCanCrossFrameBoundary = true;
 16292:     }
 16292:   } else {
 16292:     if (continuesTextRun) {
 77154:       result.mFrameToScan = aFrame->GetFirstPrincipalChild();
 77154:       result.mOverflowFrameToScan =
 77154:         aFrame->GetFirstChild(nsIFrame::kOverflowList);
 21988:       NS_WARN_IF_FALSE(!result.mOverflowFrameToScan,
 21988:                        "Scanning overflow inline frames is something we should avoid");
 80486:       result.mScanSiblings = true;
 80486:       result.mTextRunCanCrossFrameBoundary = true;
 80486:       result.mLineBreakerCanCrossFrameBoundary = true;
 16292:     } else {
 21988:       result.mFrameToScan = nsnull;
 21988:       result.mOverflowFrameToScan = nsnull;
 80486:       result.mTextRunCanCrossFrameBoundary = false;
 80486:       result.mLineBreakerCanCrossFrameBoundary = false;
 16292:     }
 16292:   }    
 16292:   return result;
  2742: }
  2742: 
  2319: BuildTextRunsScanner::FindBoundaryResult
  2319: BuildTextRunsScanner::FindBoundaries(nsIFrame* aFrame, FindBoundaryState* aState)
  2319: {
 16292:   nsIAtom* frameType = aFrame->GetType();
 16292:   nsTextFrame* textFrame = frameType == nsGkAtoms::textFrame
  3233:     ? static_cast<nsTextFrame*>(aFrame) : nsnull;
  2319:   if (textFrame) {
  2319:     if (aState->mLastTextFrame &&
  2319:         textFrame != aState->mLastTextFrame->GetNextInFlow() &&
  3009:         !ContinueTextRunAcrossFrames(aState->mLastTextFrame, textFrame)) {
 80486:       aState->mSeenTextRunBoundaryOnThisLine = true;
  2319:       if (aState->mSeenSpaceForLineBreakingOnThisLine)
  2319:         return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
  2319:     }
  2319:     if (!aState->mFirstTextFrame) {
  2319:       aState->mFirstTextFrame = textFrame;
  2319:     }
  2319:     aState->mLastTextFrame = textFrame;
  2319:   }
  2319:   
  2319:   if (aFrame == aState->mStopAtFrame)
  2319:     return FB_STOPPED_AT_STOP_FRAME;
  2319: 
  2319:   if (textFrame) {
  2319:     if (!aState->mSeenSpaceForLineBreakingOnThisLine) {
 35581:       const nsTextFragment* frag = textFrame->GetContent()->GetText();
  2319:       PRUint32 start = textFrame->GetContentOffset();
  2319:       const void* text = frag->Is2b()
  3233:           ? static_cast<const void*>(frag->Get2b() + start)
  3233:           : static_cast<const void*>(frag->Get1b() + start);
  2319:       if (TextContainsLineBreakerWhiteSpace(text, textFrame->GetContentLength(),
  2319:                                             frag->Is2b())) {
 80486:         aState->mSeenSpaceForLineBreakingOnThisLine = true;
  2319:         if (aState->mSeenTextRunBoundaryOnLaterLine)
  2319:           return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
  2319:       }
  2319:     }
  2319:     return FB_CONTINUE; 
  2319:   }
  2319: 
 16292:   FrameTextTraversal traversal =
 16292:     CanTextCrossFrameBoundary(aFrame, frameType);
 16292:   if (!traversal.mTextRunCanCrossFrameBoundary) {
 80486:     aState->mSeenTextRunBoundaryOnThisLine = true;
  2319:     if (aState->mSeenSpaceForLineBreakingOnThisLine)
  2319:       return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
  2319:   }
  2319:   
 21988:   for (nsIFrame* f = traversal.NextFrameToScan(); f;
 21988:        f = traversal.NextFrameToScan()) {
 16292:     FindBoundaryResult result = FindBoundaries(f, aState);
  2319:     if (result != FB_CONTINUE)
  2319:       return result;
 16292:   }
 16292: 
 16292:   if (!traversal.mTextRunCanCrossFrameBoundary) {
 80486:     aState->mSeenTextRunBoundaryOnThisLine = true;
  2319:     if (aState->mSeenSpaceForLineBreakingOnThisLine)
  2319:       return FB_FOUND_VALID_TEXTRUN_BOUNDARY;
  2319:   }
  2319: 
  2319:   return FB_CONTINUE;
  2319: }
  2319: 
  7722: // build text runs for the 200 lines following aForFrame, and stop after that
  7722: // when we get a chance.
  7722: #define NUM_LINES_TO_BUILD_TEXT_RUNS 200
  7722: 
     1: /**
     1:  * General routine for building text runs. This is hairy because of the need
  2319:  * to build text runs that span content nodes.
     1:  * 
 94144:  * @param aContext The gfxContext we're using to construct this text run.
 94144:  * @param aForFrame The nsTextFrame for which we're building this text run.
 94144:  * @param aLineContainer the line container containing aForFrame; if null,
 94144:  *        we'll walk the ancestors to find it.  It's required to be non-null
 94144:  *        when aForFrameLine is non-null.
     1:  * @param aForFrameLine the line containing aForFrame; if null, we'll figure
     1:  *        out the line (slowly)
 94144:  * @param aWhichTextRun The type of text run we want to build. If font inflation
 94144:  *        is enabled, this will be eInflated, otherwise it's eNotInflated.
     1:  */
     1: static void
  6862: BuildTextRuns(gfxContext* aContext, nsTextFrame* aForFrame,
 24819:               nsIFrame* aLineContainer,
 82675:               const nsLineList::iterator* aForFrameLine,
 94144:               nsTextFrame::TextRunType aWhichTextRun)
 24819: {
 24819:   NS_ASSERTION(aForFrame || aLineContainer,
 24819:                "One of aForFrame or aLineContainer must be set!");
 24819:   NS_ASSERTION(!aForFrameLine || aLineContainer,
 24819:                "line but no line container");
 24819:   
 90629:   nsIFrame* lineContainerChild = aForFrame;
 24819:   if (!aLineContainer) {
 90629:     if (aForFrame->IsFloatingFirstLetterChild()) {
 90629:       lineContainerChild = aForFrame->PresContext()->PresShell()->
 90629:         GetPlaceholderFrameFor(aForFrame->GetParent());
 90629:     }
 90629:     aLineContainer = FindLineContainer(lineContainerChild);
  1817:   } else {
 24819:     NS_ASSERTION(!aForFrame ||
 24819:                  (aLineContainer == FindLineContainer(aForFrame) ||
 24819:                   (aLineContainer->GetType() == nsGkAtoms::letterFrame &&
 24819:                    aLineContainer->GetStyleDisplay()->IsFloating())),
 24819:                  "Wrong line container hint");
  2319:   }
  2319: 
  2319:   nsPresContext* presContext = aLineContainer->PresContext();
 82675:   BuildTextRunsScanner scanner(presContext, aContext, aLineContainer,
 94144:                                aWhichTextRun);
  1817: 
 15909:   nsBlockFrame* block = nsLayoutUtils::GetAsBlock(aLineContainer);
  1817: 
  1817:   if (!block) {
  5145:     NS_ASSERTION(!aLineContainer->GetPrevInFlow() && !aLineContainer->GetNextInFlow(),
  5145:                  "Breakable non-block line containers not supported");
  1817:     // Just loop through all the children of the linecontainer ... it's really
  1817:     // just one line
  2319:     scanner.SetAtStartOfLine();
  2319:     scanner.SetCommonAncestorWithLastFrame(nsnull);
 77154:     nsIFrame* child = aLineContainer->GetFirstPrincipalChild();
  1817:     while (child) {
  1817:       scanner.ScanFrame(child);
  1817:       child = child->GetNextSibling();
  1817:     }
  1817:     // Set mStartOfLine so FlushFrames knows its textrun ends a line
  1817:     scanner.SetAtStartOfLine();
 80486:     scanner.FlushFrames(true, false);
  1817:     return;
  1817:   }
     1: 
 90629:   // Find the line containing 'lineContainerChild'.
 12355: 
 79445:   bool isValid = true;
 12355:   nsBlockInFlowLineIterator backIterator(block, &isValid);
     1:   if (aForFrameLine) {
 91751:     backIterator = nsBlockInFlowLineIterator(block, *aForFrameLine);
     1:   } else {
 90629:     backIterator = nsBlockInFlowLineIterator(block, lineContainerChild, &isValid);
 12355:     NS_ASSERTION(isValid, "aForFrame not found in block, someone lied to us");
 12355:     NS_ASSERTION(backIterator.GetContainer() == block,
 12355:                  "Someone lied to us about the block");
 12355:   }
 12355:   nsBlockFrame::line_iterator startLine = backIterator.GetLine();
  2319: 
  2319:   // Find a line where we can start building text runs. We choose the last line
  2319:   // where:
  2319:   // -- there is a textrun boundary between the start of the line and the
  2319:   // start of aForFrame
  2319:   // -- there is a space between the start of the line and the textrun boundary
  2319:   // (this is so we can be sure the line breaks will be set properly
  2319:   // on the textruns we construct).
  2319:   // The possibly-partial text runs up to and including the first space
  2319:   // are not reconstructed. We construct partial text runs for that text ---
  2319:   // for the sake of simplifying the code and feeding the linebreaker ---
  2319:   // but we discard them instead of assigning them to frames.
  2319:   // This is a little awkward because we traverse lines in the reverse direction
  2319:   // but we traverse the frames in each line in the forward direction.
 12355:   nsBlockInFlowLineIterator forwardIterator = backIterator;
 90629:   nsIFrame* stopAtFrame = lineContainerChild;
  2319:   nsTextFrame* nextLineFirstTextFrame = nsnull;
 79445:   bool seenTextRunBoundaryOnLaterLine = false;
 79445:   bool mayBeginInTextRun = true;
 80486:   while (true) {
 12355:     forwardIterator = backIterator;
 12355:     nsBlockFrame::line_iterator line = backIterator.GetLine();
  5145:     if (!backIterator.Prev() || backIterator.GetLine()->IsBlock()) {
 80486:       mayBeginInTextRun = false;
     1:       break;
     1:     }
  2319: 
  2319:     BuildTextRunsScanner::FindBoundaryState state = { stopAtFrame, nsnull, nsnull,
 79445:       bool(seenTextRunBoundaryOnLaterLine), false, false };
  2319:     nsIFrame* child = line->mFirstChild;
 79445:     bool foundBoundary = false;
  2319:     PRInt32 i;
  2319:     for (i = line->GetChildCount() - 1; i >= 0; --i) {
  2319:       BuildTextRunsScanner::FindBoundaryResult result =
  2319:           scanner.FindBoundaries(child, &state);
  2319:       if (result == BuildTextRunsScanner::FB_FOUND_VALID_TEXTRUN_BOUNDARY) {
 80486:         foundBoundary = true;
  2319:         break;
  2319:       } else if (result == BuildTextRunsScanner::FB_STOPPED_AT_STOP_FRAME) {
  2319:         break;
  2319:       }
  2319:       child = child->GetNextSibling();
  2319:     }
  2319:     if (foundBoundary)
  2319:       break;
  2319:     if (!stopAtFrame && state.mLastTextFrame && nextLineFirstTextFrame &&
  3009:         !scanner.ContinueTextRunAcrossFrames(state.mLastTextFrame, nextLineFirstTextFrame)) {
  3009:       // Found a usable textrun boundary at the end of the line
  2319:       if (state.mSeenSpaceForLineBreakingOnThisLine)
  2319:         break;
 80486:       seenTextRunBoundaryOnLaterLine = true;
  2319:     } else if (state.mSeenTextRunBoundaryOnThisLine) {
 80486:       seenTextRunBoundaryOnLaterLine = true;
  2319:     }
  2319:     stopAtFrame = nsnull;
  2319:     if (state.mFirstTextFrame) {
  2319:       nextLineFirstTextFrame = state.mFirstTextFrame;
  2319:     }
  2319:   }
  2319:   scanner.SetSkipIncompleteTextRuns(mayBeginInTextRun);
     1: 
     1:   // Now iterate over all text frames starting from the current line. First-in-flow
     1:   // text frames will be accumulated into textRunFrames as we go. When a
     1:   // text run boundary is required we flush textRunFrames ((re)building their
     1:   // gfxTextRuns as necessary).
 79445:   bool seenStartLine = false;
  7722:   PRUint32 linesAfterStartLine = 0;
     1:   do {
 12355:     nsBlockFrame::line_iterator line = forwardIterator.GetLine();
  5145:     if (line->IsBlock())
  5145:       break;
 80486:     line->SetInvalidateTextRuns(false);
     1:     scanner.SetAtStartOfLine();
     1:     scanner.SetCommonAncestorWithLastFrame(nsnull);
  5145:     nsIFrame* child = line->mFirstChild;
     1:     PRInt32 i;
     1:     for (i = line->GetChildCount() - 1; i >= 0; --i) {
     1:       scanner.ScanFrame(child);
     1:       child = child->GetNextSibling();
     1:     }
 13056:     if (line.get() == startLine.get()) {
 80486:       seenStartLine = true;
  7722:     }
  7722:     if (seenStartLine) {
  7722:       ++linesAfterStartLine;
  7722:       if (linesAfterStartLine >= NUM_LINES_TO_BUILD_TEXT_RUNS && scanner.CanStopOnThisLine()) {
 23491:         // Don't flush frames; we may be in the middle of a textrun
 23491:         // that we can't end here. That's OK, we just won't build it.
  7722:         // Note that we must already have finished the textrun for aForFrame,
  7722:         // because we've seen the end of a textrun in a line after the line
  7722:         // containing aForFrame.
 23491:         scanner.FlushLineBreaks(nsnull);
 23491:         // This flushes out mMappedFlows and mLineBreakBeforeFrames, which
 23491:         // silences assertions in the scanner destructor.
 23491:         scanner.ResetRunInfo();
  7722:         return;
  7722:       }
  7722:     }
  5145:   } while (forwardIterator.Next());
     1: 
     1:   // Set mStartOfLine so FlushFrames knows its textrun ends a line
     1:   scanner.SetAtStartOfLine();
 80486:   scanner.FlushFrames(true, false);
     1: }
     1: 
     1: static PRUnichar*
     1: ExpandBuffer(PRUnichar* aDest, PRUint8* aSrc, PRUint32 aCount)
     1: {
     1:   while (aCount) {
     1:     *aDest = *aSrc;
     1:     ++aDest;
     1:     ++aSrc;
     1:     --aCount;
     1:   }
     1:   return aDest;
     1: }
     1: 
 79445: bool BuildTextRunsScanner::IsTextRunValidForMappedFlows(gfxTextRun* aTextRun)
  6033: {
  6033:   if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW)
  6033:     return mMappedFlows.Length() == 1 &&
  6033:       mMappedFlows[0].mStartFrame == static_cast<nsTextFrame*>(aTextRun->GetUserData()) &&
  6033:       mMappedFlows[0].mEndFrame == nsnull;
  6033: 
  6033:   TextRunUserData* userData = static_cast<TextRunUserData*>(aTextRun->GetUserData());
 64106:   if (userData->mMappedFlowCount != mMappedFlows.Length())
 80486:     return false;
  6033:   PRUint32 i;
  6033:   for (i = 0; i < mMappedFlows.Length(); ++i) {
  6033:     if (userData->mMappedFlows[i].mStartFrame != mMappedFlows[i].mStartFrame ||
  6033:         PRInt32(userData->mMappedFlows[i].mContentLength) !=
  6033:             mMappedFlows[i].GetContentEnd() - mMappedFlows[i].mStartFrame->GetContentOffset())
 80486:       return false;
 80486:   }
 80486:   return true;
  6033: }
  6033: 
     1: /**
     1:  * This gets called when we need to make a text run for the current list of
     1:  * frames.
     1:  */
 79445: void BuildTextRunsScanner::FlushFrames(bool aFlushLineBreaks, bool aSuppressTrailingBreak)
     1: {
 23491:   gfxTextRun* textRun = nsnull;
 23491:   if (!mMappedFlows.IsEmpty()) {
  2319:     if (!mSkipIncompleteTextRuns && mCurrentFramesAllSameTextRun &&
     1:         ((mCurrentFramesAllSameTextRun->GetFlags() & nsTextFrameUtils::TEXT_INCOMING_WHITESPACE) != 0) ==
 22917:         ((mCurrentRunContextInfo & nsTextFrameUtils::INCOMING_WHITESPACE) != 0) &&
 86690:         ((mCurrentFramesAllSameTextRun->GetFlags() & gfxTextRunFactory::TEXT_INCOMING_ARABICCHAR) != 0) ==
 22917:         ((mCurrentRunContextInfo & nsTextFrameUtils::INCOMING_ARABICCHAR) != 0) &&
  6033:         IsTextRunValidForMappedFlows(mCurrentFramesAllSameTextRun)) {
  2319:       // Optimization: We do not need to (re)build the textrun.
  8573:       textRun = mCurrentFramesAllSameTextRun;
     1: 
 86697:       // Feed this run's text into the linebreaker to provide context.
 86697:       if (!SetupLineBreakerContext(textRun)) {
 86697:         return;
 86697:       }
 86697:  
 86697:       // Update mNextRunContextInfo appropriately
 22917:       mNextRunContextInfo = nsTextFrameUtils::INCOMING_NONE;
 22917:       if (textRun->GetFlags() & nsTextFrameUtils::TEXT_TRAILING_WHITESPACE) {
 22917:         mNextRunContextInfo |= nsTextFrameUtils::INCOMING_WHITESPACE;
 22917:       }
 86690:       if (textRun->GetFlags() & gfxTextRunFactory::TEXT_TRAILING_ARABICCHAR) {
 22917:         mNextRunContextInfo |= nsTextFrameUtils::INCOMING_ARABICCHAR;
 22917:       }
     1:     } else {
 87328:       AutoFallibleTArray<PRUint8,BIG_TEXT_NODE_SIZE> buffer;
 87227:       PRUint32 bufferSize = mMaxTextLength*(mDoubleByteText ? 2 : 1);
 87227:       if (bufferSize < mMaxTextLength || bufferSize == PR_UINT32_MAX ||
 87227:           !buffer.AppendElements(bufferSize)) {
     1:         return;
 58221:       }
 87227:       textRun = BuildTextRunForFrames(buffer.Elements());
     1:     }
 23491:   }
     1: 
     1:   if (aFlushLineBreaks) {
 23491:     FlushLineBreaks(aSuppressTrailingBreak ? nsnull : textRun);
 23491:   }
 23491: 
 80486:   mCanStopOnThisLine = true;
 23491:   ResetRunInfo();
 23491: }
 23491: 
 23491: void BuildTextRunsScanner::FlushLineBreaks(gfxTextRun* aTrailingTextRun)
 23491: {
 79445:   bool trailingLineBreak;
  8573:   nsresult rv = mLineBreaker.Reset(&trailingLineBreak);
  8573:   // textRun may be null for various reasons, including because we constructed
  8573:   // a partial textrun just to get the linebreaker and other state set up
  8573:   // to build the next textrun.
 23491:   if (NS_SUCCEEDED(rv) && trailingLineBreak && aTrailingTextRun) {
 23491:     aTrailingTextRun->SetFlagBits(nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK);
 23491:   }
 23491: 
     1:   PRUint32 i;
     1:   for (i = 0; i < mBreakSinks.Length(); ++i) {
    60:     if (!mBreakSinks[i]->mExistingTextRun || mBreakSinks[i]->mChangedBreaks) {
     1:       // TODO cause frames associated with the textrun to be reflowed, if they
     1:       // aren't being reflowed already!
     1:     }
 23491:     mBreakSinks[i]->Finish();
     1:   }
     1:   mBreakSinks.Clear();
 23491: 
 23491:   for (i = 0; i < mTextRunsToDelete.Length(); ++i) {
 23491:     gfxTextRun* deleteTextRun = mTextRunsToDelete[i];
 23491:     gTextRuns->RemoveFromCache(deleteTextRun);
 23491:     delete deleteTextRun;
 23491:   }
 23491:   mTextRunsToDelete.Clear();
     1: }
     1: 
     1: void BuildTextRunsScanner::AccumulateRunInfo(nsTextFrame* aFrame)
     1: {
 58221:   if (mMaxTextLength != PR_UINT32_MAX) {
 58221:     NS_ASSERTION(mMaxTextLength < PR_UINT32_MAX - aFrame->GetContentLength(), "integer overflow");
 58221:     if (mMaxTextLength >= PR_UINT32_MAX - aFrame->GetContentLength()) {
 58221:       mMaxTextLength = PR_UINT32_MAX;
 58221:     } else {
     1:       mMaxTextLength += aFrame->GetContentLength();
 58221:     }
 58221:   }
 35581:   mDoubleByteText |= aFrame->GetContent()->GetText()->Is2b();
     1:   mLastFrame = aFrame;
  8573:   mCommonAncestorWithLastFrame = aFrame->GetParent();
     1: 
  6033:   MappedFlow* mappedFlow = &mMappedFlows[mMappedFlows.Length() - 1];
  6033:   NS_ASSERTION(mappedFlow->mStartFrame == aFrame ||
  6033:                mappedFlow->GetContentEnd() == aFrame->GetContentOffset(),
  6033:                "Overlapping or discontiguous frames => BAD");
  6033:   mappedFlow->mEndFrame = static_cast<nsTextFrame*>(aFrame->GetNextContinuation());
 82675:   if (mCurrentFramesAllSameTextRun != aFrame->GetTextRun(mWhichTextRun)) {
  6033:     mCurrentFramesAllSameTextRun = nsnull;
  6033:   }
  6033: 
     1:   if (mStartOfLine) {
     1:     mLineBreakBeforeFrames.AppendElement(aFrame);
 80486:     mStartOfLine = false;
     1:   }
     1: }
     1: 
  2027: static nscoord StyleToCoord(const nsStyleCoord& aCoord)
  2027: {
  2027:   if (eStyleUnit_Coord == aCoord.GetUnit()) {
  2027:     return aCoord.GetCoordValue();
  2027:   } else {
  2027:     return 0;
  2027:   }
  2027: }
  2027: 
 79445: static bool
  3009: HasTerminalNewline(const nsTextFrame* aFrame)
  3009: {
  3009:   if (aFrame->GetContentLength() == 0)
 80486:     return false;
 35581:   const nsTextFragment* frag = aFrame->GetContent()->GetText();
  3009:   return frag->CharAt(aFrame->GetContentEnd() - 1) == '\n';
  3009: }
  3009: 
 79445: bool
  3009: BuildTextRunsScanner::ContinueTextRunAcrossFrames(nsTextFrame* aFrame1, nsTextFrame* aFrame2)
     1: {
 82675:   // We don't need to check font size inflation, since
 82675:   // |FindLineContainer| above (via |nsIFrame::CanContinueTextRun|)
 82675:   // ensures that text runs never cross block boundaries.  This means
 82675:   // that the font size inflation on all text frames in the text run is
 82675:   // already guaranteed to be the same as each other (and for the line
 82675:   // container).
     1:   if (mBidiEnabled &&
 93532:       (NS_GET_EMBEDDING_LEVEL(aFrame1) != NS_GET_EMBEDDING_LEVEL(aFrame2) ||
 93532:        NS_GET_PARAGRAPH_DEPTH(aFrame1) != NS_GET_PARAGRAPH_DEPTH(aFrame2)))
 80486:     return false;
     1: 
     1:   nsStyleContext* sc1 = aFrame1->GetStyleContext();
  3009:   const nsStyleText* textStyle1 = sc1->GetStyleText();
  3009:   // If the first frame ends in a preformatted newline, then we end the textrun
  3009:   // here. This avoids creating giant textruns for an entire plain text file.
  3009:   // Note that we create a single text frame for a preformatted text node,
  3009:   // even if it has newlines in it, so typically we won't see trailing newlines
  3009:   // until after reflow has broken up the frame into one (or more) frames per
  3009:   // line. That's OK though.
 16575:   if (textStyle1->NewlineIsSignificant() && HasTerminalNewline(aFrame1))
 80486:     return false;
  3009: 
 42257:   if (aFrame1->GetContent() == aFrame2->GetContent() &&
 42257:       aFrame1->GetNextInFlow() != aFrame2) {
 42257:     // aFrame2 must be a non-fluid continuation of aFrame1. This can happen
 42257:     // sometimes when the unicode-bidi property is used; the bidi resolver
 42257:     // breaks text into different frames even though the text has the same
 42257:     // direction. We can't allow these two frames to share the same textrun
 42257:     // because that would violate our invariant that two flows in the same
 42257:     // textrun have different content elements.
 80486:     return false;
 42257:   }
  7012: 
     1:   nsStyleContext* sc2 = aFrame2->GetStyleContext();
     1:   if (sc1 == sc2)
 80486:     return true;
  4032:   const nsStyleFont* fontStyle1 = sc1->GetStyleFont();
  4032:   const nsStyleFont* fontStyle2 = sc2->GetStyleFont();
  4032:   const nsStyleText* textStyle2 = sc2->GetStyleText();
  4032:   return fontStyle1->mFont.BaseEquals(fontStyle2->mFont) &&
 88039:     sc1->GetStyleFont()->mLanguage == sc2->GetStyleFont()->mLanguage &&
  4032:     nsLayoutUtils::GetTextRunFlagsForStyle(sc1, textStyle1, fontStyle1) ==
  4032:       nsLayoutUtils::GetTextRunFlagsForStyle(sc2, textStyle2, fontStyle2);
     1: }
     1: 
     1: void BuildTextRunsScanner::ScanFrame(nsIFrame* aFrame)
     1: {
     1:   // First check if we can extend the current mapped frame block. This is common.
     1:   if (mMappedFlows.Length() > 0) {
     1:     MappedFlow* mappedFlow = &mMappedFlows[mMappedFlows.Length() - 1];
  6033:     if (mappedFlow->mEndFrame == aFrame &&
  6033:         (aFrame->GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION)) {
     1:       NS_ASSERTION(aFrame->GetType() == nsGkAtoms::textFrame,
     1:                    "Flow-sibling of a text frame is not a text frame?");
     1: 
  3009:       // Don't do this optimization if mLastFrame has a terminal newline...
  3009:       // it's quite likely preformatted and we might want to end the textrun here.
  3009:       // This is almost always true:
  3009:       if (mLastFrame->GetStyleContext() == aFrame->GetStyleContext() &&
  3009:           !HasTerminalNewline(mLastFrame)) {
  6033:         AccumulateRunInfo(static_cast<nsTextFrame*>(aFrame));
     1:         return;
     1:       }
     1:     }
     1:   }
     1: 
  8857:   nsIAtom* frameType = aFrame->GetType();
     1:   // Now see if we can add a new set of frames to the current textrun
  8857:   if (frameType == nsGkAtoms::textFrame) {
  3233:     nsTextFrame* frame = static_cast<nsTextFrame*>(aFrame);
     1: 
  6033:     if (mLastFrame) {
  6033:       if (!ContinueTextRunAcrossFrames(mLastFrame, frame)) {
 80486:         FlushFrames(false, false);
  6033:       } else {
  6033:         if (mLastFrame->GetContent() == frame->GetContent()) {
  6033:           AccumulateRunInfo(frame);
  6033:           return;
  6033:         }
  6033:       }
     1:     }
     1: 
     1:     MappedFlow* mappedFlow = mMappedFlows.AppendElement();
     1:     if (!mappedFlow)
     1:       return;
     1: 
     1:     mappedFlow->mStartFrame = frame;
     1:     mappedFlow->mAncestorControllingInitialBreak = mCommonAncestorWithLastFrame;
     1: 
     1:     AccumulateRunInfo(frame);
     1:     if (mMappedFlows.Length() == 1) {
 82675:       mCurrentFramesAllSameTextRun = frame->GetTextRun(mWhichTextRun);
 22917:       mCurrentRunContextInfo = mNextRunContextInfo;
     1:     }
     1:     return;
     1:   }
     1: 
 16292:   FrameTextTraversal traversal =
 16292:     CanTextCrossFrameBoundary(aFrame, frameType);
 79445:   bool isBR = frameType == nsGkAtoms::brFrame;
 16292:   if (!traversal.mLineBreakerCanCrossFrameBoundary) {
  8857:     // BR frames are special. We do not need or want to record a break opportunity
  8857:     // before a BR frame.
 80486:     FlushFrames(true, isBR);
  8573:     mCommonAncestorWithLastFrame = aFrame;
 22917:     mNextRunContextInfo &= ~nsTextFrameUtils::INCOMING_WHITESPACE;
 80486:     mStartOfLine = false;
 16292:   } else if (!traversal.mTextRunCanCrossFrameBoundary) {
 80486:     FlushFrames(false, false);
 16292:   }
 16292: 
 21988:   for (nsIFrame* f = traversal.NextFrameToScan(); f;
 21988:        f = traversal.NextFrameToScan()) {
     1:     ScanFrame(f);
 16292:   }
 16292: 
 16292:   if (!traversal.mLineBreakerCanCrossFrameBoundary) {
  8857:     // Really if we're a BR frame this is unnecessary since descendInto will be
  8857:     // false. In fact this whole "if" statement should move into the descendInto.
 80486:     FlushFrames(true, isBR);
  8573:     mCommonAncestorWithLastFrame = aFrame;
 22917:     mNextRunContextInfo &= ~nsTextFrameUtils::INCOMING_WHITESPACE;
 16292:   } else if (!traversal.mTextRunCanCrossFrameBoundary) {
 80486:     FlushFrames(false, false);
     1:   }
  2319: 
  2319:   LiftCommonAncestorWithLastFrameToParent(aFrame->GetParent());
     1: }
     1: 
     1: nsTextFrame*
     1: BuildTextRunsScanner::GetNextBreakBeforeFrame(PRUint32* aIndex)
     1: {
     1:   PRUint32 index = *aIndex;
     1:   if (index >= mLineBreakBeforeFrames.Length())
     1:     return nsnull;
     1:   *aIndex = index + 1;
  3233:   return static_cast<nsTextFrame*>(mLineBreakBeforeFrames.ElementAt(index));
     1: }
     1: 
     1: static PRUint32
 23137: GetSpacingFlags(nscoord spacing)
 23137: {
 30879:   return spacing ? gfxTextRunFactory::TEXT_ENABLE_SPACING : 0;
     1: }
     1: 
     1: static gfxFontGroup*
 82675: GetFontGroupForFrame(nsIFrame* aFrame, float aFontSizeInflation,
 68493:                      nsFontMetrics** aOutFontMetrics = nsnull)
 13714: {
 13714:   if (aOutFontMetrics)
 13714:     *aOutFontMetrics = nsnull;
 13714: 
 68493:   nsRefPtr<nsFontMetrics> metrics;
 82675:   nsLayoutUtils::GetFontMetricsForFrame(aFrame, getter_AddRefs(metrics),
 82675:                                         aFontSizeInflation);
  4353: 
     1:   if (!metrics)
     1:     return nsnull;
     1: 
 13714:   if (aOutFontMetrics) {
 68491:     *aOutFontMetrics = metrics;
 13714:     NS_ADDREF(*aOutFontMetrics);
 13714:   }
 68491:   // XXX this is a bit bogus, we're releasing 'metrics' so the
 68491:   // returned font-group might actually be torn down, although because
 68491:   // of the way the device context caches font metrics, this seems to
 68491:   // not actually happen. But we should fix this.
 68491:   return metrics->GetThebesFontGroup();
     1: }
     1: 
  6862: static already_AddRefed<gfxContext>
 68481: GetReferenceRenderingContext(nsTextFrame* aTextFrame, nsRenderingContext* aRC)
 68481: {
 68481:   nsRefPtr<nsRenderingContext> tmp = aRC;
  6862:   if (!tmp) {
 51038:     tmp = aTextFrame->PresContext()->PresShell()->GetReferenceRenderingContext();
 51038:     if (!tmp)
  6862:       return nsnull;
  6862:   }
  6862: 
  9438:   gfxContext* ctx = tmp->ThebesContext();
  6862:   NS_ADDREF(ctx);
  6862:   return ctx;
  6862: }
  6862: 
  5724: /**
 86690:  * The returned textrun must be deleted when no longer needed.
  5724:  */
     1: static gfxTextRun*
  6862: GetHyphenTextRun(gfxTextRun* aTextRun, gfxContext* aContext, nsTextFrame* aTextFrame)
  6862: {
  6862:   nsRefPtr<gfxContext> ctx = aContext;
  6862:   if (!ctx) {
  6862:     ctx = GetReferenceRenderingContext(aTextFrame, nsnull);
  6862:   }
  6862:   if (!ctx)
  1563:     return nsnull;
  6862: 
  1328:   gfxFontGroup* fontGroup = aTextRun->GetFontGroup();
  1328:   PRUint32 flags = gfxFontGroup::TEXT_IS_PERSISTENT;
  1328: 
 24664:   // only use U+2010 if it is supported by the first font in the group;
 24664:   // it's better to use ASCII '-' from the primary font than to fall back to U+2010
 24664:   // from some other, possibly poorly-matching face
  1328:   static const PRUnichar unicodeHyphen = 0x2010;
 24664:   gfxFont *font = fontGroup->GetFontAt(0);
 24664:   if (font && font->HasCharacter(unicodeHyphen)) {
 86690:     return fontGroup->MakeTextRun(&unicodeHyphen, 1, ctx,
  1328:                                   aTextRun->GetAppUnitsPerDevUnit(), flags);
 24664:   }
  7729: 
  1328:   static const PRUint8 dash = '-';
 86690:   return fontGroup->MakeTextRun(&dash, 1, ctx,
 86690:                                 aTextRun->GetAppUnitsPerDevUnit(), flags);
     1: }
     1: 
     1: static gfxFont::Metrics
 13714: GetFirstFontMetrics(gfxFontGroup* aFontGroup)
     1: {
     1:   if (!aFontGroup)
     1:     return gfxFont::Metrics();
     1:   gfxFont* font = aFontGroup->GetFontAt(0);
     1:   if (!font)
     1:     return gfxFont::Metrics();
     1:   return font->GetMetrics();
     1: }
     1: 
 16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_NORMAL == 0);
 16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_PRE == 1);
 16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_NOWRAP == 2);
 16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_PRE_WRAP == 3);
 16575: PR_STATIC_ASSERT(NS_STYLE_WHITESPACE_PRE_LINE == 4);
 16575: 
 16575: static const nsTextFrameUtils::CompressionMode CSSWhitespaceToCompressionMode[] =
 16575: {
 16575:   nsTextFrameUtils::COMPRESS_WHITESPACE_NEWLINE, // normal
 16575:   nsTextFrameUtils::COMPRESS_NONE,               // pre
 16575:   nsTextFrameUtils::COMPRESS_WHITESPACE_NEWLINE, // nowrap
 16575:   nsTextFrameUtils::COMPRESS_NONE,               // pre-wrap
 16575:   nsTextFrameUtils::COMPRESS_WHITESPACE          // pre-line
 16575: };
 16575: 
  8573: gfxTextRun*
 87227: BuildTextRunsScanner::BuildTextRunForFrames(void* aTextBuffer)
     1: {
     1:   gfxSkipCharsBuilder builder;
     1: 
 87227:   const void* textPtr = aTextBuffer;
 79445:   bool anySmallcapsStyle = false;
 79445:   bool anyTextTransformStyle = false;
  6513:   PRUint32 textFlags = nsTextFrameUtils::TEXT_NO_BREAKS;
     8: 
 22917:   if (mCurrentRunContextInfo & nsTextFrameUtils::INCOMING_WHITESPACE) {
     8:     textFlags |= nsTextFrameUtils::TEXT_INCOMING_WHITESPACE;
     8:   }
 22917:   if (mCurrentRunContextInfo & nsTextFrameUtils::INCOMING_ARABICCHAR) {
 86690:     textFlags |= gfxTextRunFactory::TEXT_INCOMING_ARABICCHAR;
 22917:   }
     1: 
  5800:   nsAutoTArray<PRInt32,50> textBreakPoints;
     1:   TextRunUserData dummyData;
     1:   TextRunMappedFlow dummyMappedFlow;
     1: 
     1:   TextRunUserData* userData;
 23491:   TextRunUserData* userDataToDestroy;
     1:   // If the situation is particularly simple (and common) we don't need to
     1:   // allocate userData.
     1:   if (mMappedFlows.Length() == 1 && !mMappedFlows[0].mEndFrame &&
  6033:       mMappedFlows[0].mStartFrame->GetContentOffset() == 0) {
     1:     userData = &dummyData;
 23491:     userDataToDestroy = nsnull;
     1:     dummyData.mMappedFlows = &dummyMappedFlow;
     1:   } else {
  3233:     userData = static_cast<TextRunUserData*>
  3233:       (nsMemory::Alloc(sizeof(TextRunUserData) + mMappedFlows.Length()*sizeof(TextRunMappedFlow)));
 23491:     userDataToDestroy = userData;
  3233:     userData->mMappedFlows = reinterpret_cast<TextRunMappedFlow*>(userData + 1);
     1:   }
  6033:   userData->mMappedFlowCount = mMappedFlows.Length();
     1:   userData->mLastFlowIndex = 0;
     1: 
     1:   PRUint32 currentTransformedTextOffset = 0;
     1: 
     1:   PRUint32 nextBreakIndex = 0;
     1:   nsTextFrame* nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
 79445:   bool enabledJustification = mLineContainer &&
 87175:     (mLineContainer->GetStyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY ||
 87175:      mLineContainer->GetStyleText()->mTextAlignLast == NS_STYLE_TEXT_ALIGN_JUSTIFY);
     1: 
 97909:   // for word-break style
 97909:   switch (mLineContainer->GetStyleText()->mWordBreak) {
 97909:     case NS_STYLE_WORDBREAK_BREAK_ALL:
 97909:       mLineBreaker.SetWordBreak(nsILineBreaker::kWordBreak_BreakAll);
 97909:       break;
 97909:     case NS_STYLE_WORDBREAK_KEEP_ALL:
 97909:       mLineBreaker.SetWordBreak(nsILineBreaker::kWordBreak_KeepAll);
 97909:       break;
 97909:     default:
 97909:       mLineBreaker.SetWordBreak(nsILineBreaker::kWordBreak_Normal);
 97909:       break;
 97909:   }
 97909: 
     1:   PRUint32 i;
  4032:   const nsStyleText* textStyle = nsnull;
  4032:   const nsStyleFont* fontStyle = nsnull;
  4032:   nsStyleContext* lastStyleContext = nsnull;
     1:   for (i = 0; i < mMappedFlows.Length(); ++i) {
     1:     MappedFlow* mappedFlow = &mMappedFlows[i];
     1:     nsTextFrame* f = mappedFlow->mStartFrame;
     1: 
  4032:     lastStyleContext = f->GetStyleContext();
     1:     // Detect use of text-transform or font-variant anywhere in the run
  4032:     textStyle = f->GetStyleText();
     1:     if (NS_STYLE_TEXT_TRANSFORM_NONE != textStyle->mTextTransform) {
 80486:       anyTextTransformStyle = true;
     1:     }
 23137:     textFlags |= GetSpacingFlags(StyleToCoord(textStyle->mLetterSpacing));
     1:     textFlags |= GetSpacingFlags(textStyle->mWordSpacing);
 16575:     nsTextFrameUtils::CompressionMode compression =
 16575:       CSSWhitespaceToCompressionMode[textStyle->mWhiteSpace];
 16575:     if (enabledJustification && !textStyle->WhiteSpaceIsSignificant()) {
     1:       textFlags |= gfxTextRunFactory::TEXT_ENABLE_SPACING;
     1:     }
  4032:     fontStyle = f->GetStyleFont();
     1:     if (NS_STYLE_FONT_VARIANT_SMALL_CAPS == fontStyle->mFont.variant) {
 80486:       anySmallcapsStyle = true;
     1:     }
     1: 
     1:     // Figure out what content is included in this flow.
     1:     nsIContent* content = f->GetContent();
 35581:     const nsTextFragment* frag = content->GetText();
  6033:     PRInt32 contentStart = mappedFlow->mStartFrame->GetContentOffset();
  6033:     PRInt32 contentEnd = mappedFlow->GetContentEnd();
     1:     PRInt32 contentLength = contentEnd - contentStart;
     1: 
  6033:     TextRunMappedFlow* newFlow = &userData->mMappedFlows[i];
     1:     newFlow->mStartFrame = mappedFlow->mStartFrame;
  6033:     newFlow->mDOMOffsetToBeforeTransformOffset = builder.GetCharCount() -
  6033:       mappedFlow->mStartFrame->GetContentOffset();
     1:     newFlow->mContentLength = contentLength;
     1: 
     1:     while (nextBreakBeforeFrame && nextBreakBeforeFrame->GetContent() == content) {
  5800:       textBreakPoints.AppendElement(
  5800:           nextBreakBeforeFrame->GetContentOffset() + newFlow->mDOMOffsetToBeforeTransformOffset);
     1:       nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
     1:     }
     1: 
     1:     PRUint32 analysisFlags;
     1:     if (frag->Is2b()) {
     1:       NS_ASSERTION(mDoubleByteText, "Wrong buffer char size!");
 87227:       PRUnichar* bufStart = static_cast<PRUnichar*>(aTextBuffer);
     1:       PRUnichar* bufEnd = nsTextFrameUtils::TransformText(
     1:           frag->Get2b() + contentStart, contentLength, bufStart,
 22917:           compression, &mNextRunContextInfo, &builder, &analysisFlags);
 87227:       aTextBuffer = bufEnd;
     1:     } else {
     1:       if (mDoubleByteText) {
     1:         // Need to expand the text. First transform it into a temporary buffer,
     1:         // then expand.
 87328:         AutoFallibleTArray<PRUint8,BIG_TEXT_NODE_SIZE> tempBuf;
 87328:         PRUint8* bufStart = tempBuf.AppendElements(contentLength);
 87328:         if (!bufStart) {
 23491:           DestroyUserData(userDataToDestroy);
  8573:           return nsnull;
     1:         }
     1:         PRUint8* end = nsTextFrameUtils::TransformText(
  3233:             reinterpret_cast<const PRUint8*>(frag->Get1b()) + contentStart, contentLength,
 22917:             bufStart, compression, &mNextRunContextInfo, &builder, &analysisFlags);
 87227:         aTextBuffer = ExpandBuffer(static_cast<PRUnichar*>(aTextBuffer),
     1:                                    tempBuf.Elements(), end - tempBuf.Elements());
     1:       } else {
 87227:         PRUint8* bufStart = static_cast<PRUint8*>(aTextBuffer);
     1:         PRUint8* end = nsTextFrameUtils::TransformText(
  3233:             reinterpret_cast<const PRUint8*>(frag->Get1b()) + contentStart, contentLength,
 22917:             bufStart, compression, &mNextRunContextInfo, &builder, &analysisFlags);
 87227:         aTextBuffer = end;
     1:       }
     1:     }
     1:     textFlags |= analysisFlags;
     1: 
     1:     currentTransformedTextOffset =
 87227:       (static_cast<const PRUint8*>(aTextBuffer) - static_cast<const PRUint8*>(textPtr)) >> mDoubleByteText;
     1:   }
     1: 
     1:   // Check for out-of-memory in gfxSkipCharsBuilder
     1:   if (!builder.IsOK()) {
 23491:     DestroyUserData(userDataToDestroy);
  8573:     return nsnull;
     1:   }
     1: 
     1:   void* finalUserData;
     1:   if (userData == &dummyData) {
     1:     textFlags |= nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW;
     1:     userData = nsnull;
     1:     finalUserData = mMappedFlows[0].mStartFrame;
     1:   } else {
     1:     finalUserData = userData;
     1:   }
     1: 
     1:   PRUint32 transformedLength = currentTransformedTextOffset;
     1: 
     1:   // Now build the textrun
     1:   nsTextFrame* firstFrame = mMappedFlows[0].mStartFrame;
 94144:   float fontInflation;
 94144:   if (mWhichTextRun == nsTextFrame::eNotInflated) {
 94144:     fontInflation = 1.0f;
 94144:   } else {
 98995:     fontInflation = nsLayoutUtils::FontSizeInflationFor(firstFrame);
 94144:   }
 94144: 
 94144:   gfxFontGroup* fontGroup = GetFontGroupForFrame(firstFrame, fontInflation);
     1:   if (!fontGroup) {
 23491:     DestroyUserData(userDataToDestroy);
  8573:     return nsnull;
     1:   }
     1: 
     1:   if (textFlags & nsTextFrameUtils::TEXT_HAS_TAB) {
     1:     textFlags |= gfxTextRunFactory::TEXT_ENABLE_SPACING;
     1:   }
     1:   if (textFlags & nsTextFrameUtils::TEXT_HAS_SHY) {
     1:     textFlags |= gfxTextRunFactory::TEXT_ENABLE_HYPHEN_BREAKS;
     1:   }
     1:   if (mBidiEnabled && (NS_GET_EMBEDDING_LEVEL(firstFrame) & 1)) {
     1:     textFlags |= gfxTextRunFactory::TEXT_IS_RTL;
     1:   }
 22917:   if (mNextRunContextInfo & nsTextFrameUtils::INCOMING_WHITESPACE) {
  1328:     textFlags |= nsTextFrameUtils::TEXT_TRAILING_WHITESPACE;
  1328:   }
 22917:   if (mNextRunContextInfo & nsTextFrameUtils::INCOMING_ARABICCHAR) {
 86690:     textFlags |= gfxTextRunFactory::TEXT_TRAILING_ARABICCHAR;
 22917:   }
  4032:   // ContinueTextRunAcrossFrames guarantees that it doesn't matter which
  4032:   // frame's style is used, so use the last frame's
  4032:   textFlags |= nsLayoutUtils::GetTextRunFlagsForStyle(lastStyleContext,
  4032:       textStyle, fontStyle);
  6513:   // XXX this is a bit of a hack. For performance reasons, if we're favouring
  6513:   // performance over quality, don't try to get accurate glyph extents.
  6513:   if (!(textFlags & gfxTextRunFactory::TEXT_OPTIMIZE_SPEED)) {
  6513:     textFlags |= gfxTextRunFactory::TEXT_NEED_BOUNDING_BOX;
  6513:   }
     1: 
     1:   gfxSkipChars skipChars;
     1:   skipChars.TakeFrom(&builder);
     1:   // Convert linebreak coordinates to transformed string offsets
     1:   NS_ASSERTION(nextBreakIndex == mLineBreakBeforeFrames.Length(),
     1:                "Didn't find all the frames to break-before...");
     1:   gfxSkipCharsIterator iter(skipChars);
  5800:   nsAutoTArray<PRUint32,50> textBreakPointsAfterTransform;
  5800:   for (i = 0; i < textBreakPoints.Length(); ++i) {
  8330:     nsTextFrameUtils::AppendLineBreakOffset(&textBreakPointsAfterTransform, 
  5800:             iter.ConvertOriginalToSkipped(textBreakPoints[i]));
     1:   }
     1:   if (mStartOfLine) {
  8330:     nsTextFrameUtils::AppendLineBreakOffset(&textBreakPointsAfterTransform,
  8330:                                             transformedLength);
     1:   }
     1: 
  7114:   // Setup factory chain
  7114:   nsAutoPtr<nsTransformingTextRunFactory> transformingFactory;
  7114:   if (anySmallcapsStyle) {
  7114:     transformingFactory = new nsFontVariantTextRunFactory();
  7114:   }
  7114:   if (anyTextTransformStyle) {
  7114:     transformingFactory =
  7114:       new nsCaseTransformTextRunFactory(transformingFactory.forget());
  7114:   }
  7114:   nsTArray<nsStyleContext*> styles;
  7114:   if (transformingFactory) {
  7114:     iter.SetOriginalOffset(0);
  7114:     for (i = 0; i < mMappedFlows.Length(); ++i) {
  7114:       MappedFlow* mappedFlow = &mMappedFlows[i];
  7673:       nsTextFrame* f;
  7673:       for (f = mappedFlow->mStartFrame; f != mappedFlow->mEndFrame;
  7695:            f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
  7114:         PRUint32 offset = iter.GetSkippedOffset();
  7673:         iter.AdvanceOriginal(f->GetContentLength());
  7114:         PRUint32 end = iter.GetSkippedOffset();
  7673:         nsStyleContext* sc = f->GetStyleContext();
  7114:         PRUint32 j;
  7114:         for (j = offset; j < end; ++j) {
  7114:           styles.AppendElement(sc);
  7114:         }
  7114:       }
  7114:     }
  7832:     textFlags |= nsTextFrameUtils::TEXT_IS_TRANSFORMED;
  7673:     NS_ASSERTION(iter.GetSkippedOffset() == transformedLength,
  7673:                  "We didn't cover all the characters in the text run!");
  7673:   }
  7114: 
  2319:   gfxTextRun* textRun;
     1:   gfxTextRunFactory::Parameters params =
  1328:       { mContext, finalUserData, &skipChars,
  5800:         textBreakPointsAfterTransform.Elements(), textBreakPointsAfterTransform.Length(),
  1328:         firstFrame->PresContext()->AppUnitsPerDevPixel() };
     1: 
     1:   if (mDoubleByteText) {
  3233:     const PRUnichar* text = static_cast<const PRUnichar*>(textPtr);
     8:     if (transformingFactory) {
     8:       textRun = transformingFactory->MakeTextRun(text, transformedLength, &params,
  1328:                                                  fontGroup, textFlags, styles.Elements());
     8:       if (textRun) {
  1435:         // ownership of the factory has passed to the textrun
     8:         transformingFactory.forget();
     8:       }
     8:     } else {
  1328:       textRun = MakeTextRun(text, transformedLength, fontGroup, &params, textFlags);
     8:     }
     1:   } else {
  3233:     const PRUint8* text = static_cast<const PRUint8*>(textPtr);
  1328:     textFlags |= gfxFontGroup::TEXT_IS_8BIT;
     8:     if (transformingFactory) {
     8:       textRun = transformingFactory->MakeTextRun(text, transformedLength, &params,
  1328:                                                  fontGroup, textFlags, styles.Elements());
     8:       if (textRun) {
  1435:         // ownership of the factory has passed to the textrun
     8:         transformingFactory.forget();
     8:       }
     8:     } else {
  1328:       textRun = MakeTextRun(text, transformedLength, fontGroup, &params, textFlags);
     8:     }
  2319:   }
     1:   if (!textRun) {
 23491:     DestroyUserData(userDataToDestroy);
  8573:     return nsnull;
     1:   }
  2319: 
     1:   // We have to set these up after we've created the textrun, because
     1:   // the breaks may be stored in the textrun during this very call.
     1:   // This is a bit annoying because it requires another loop over the frames
     1:   // making up the textrun, but I don't see a way to avoid this.
 86697:   PRUint32 flags = 0;
 86697:   if (mDoubleByteText) {
 86697:     flags |= SBS_DOUBLE_BYTE;
 86697:   }
 86697:   if (mSkipIncompleteTextRuns) {
 86697:     flags |= SBS_SUPPRESS_SINK;
 86697:   }
 86697:   SetupBreakSinksForTextRun(textRun, textPtr, flags);
  2319: 
  2319:   if (mSkipIncompleteTextRuns) {
  2319:     mSkipIncompleteTextRuns = !TextContainsLineBreakerWhiteSpace(textPtr,
  2319:         transformedLength, mDoubleByteText);
 23491:     // Arrange for this textrun to be deleted the next time the linebreaker
 23491:     // is flushed out
 23491:     mTextRunsToDelete.AppendElement(textRun);
 23491:     // Since we're doing to destroy the user data now, avoid a dangling
 23491:     // pointer. Strictly speaking we don't need to do this since it should
 23491:     // not be used (since this textrun will not be used and will be
 23491:     // itself deleted soon), but it's always better to not have dangling
 23491:     // pointers around.
 23491:     textRun->SetUserData(nsnull);
 23491:     DestroyUserData(userDataToDestroy);
  8573:     return nsnull;
  2319:   }
     1: 
     1:   // Actually wipe out the textruns associated with the mapped frames and associate
     1:   // those frames with this text run.
 94144:   AssignTextRun(textRun, fontInflation);
  8573:   return textRun;
     1: }
     1: 
 86697: // This is a cut-down version of BuildTextRunForFrames used to set up
 86697: // context for the line-breaker, when the textrun has already been created.
 86697: // So it does the same walk over the mMappedFlows, but doesn't actually
 86697: // build a new textrun.
 86697: bool
 86697: BuildTextRunsScanner::SetupLineBreakerContext(gfxTextRun *aTextRun)
 86697: {
 86697:   AutoFallibleTArray<PRUint8,BIG_TEXT_NODE_SIZE> buffer;
 86697:   PRUint32 bufferSize = mMaxTextLength*(mDoubleByteText ? 2 : 1);
 87328:   if (bufferSize < mMaxTextLength || bufferSize == PR_UINT32_MAX) {
 86697:     return false;
 86697:   }
 87328:   void *textPtr = buffer.AppendElements(bufferSize);
 87328:   if (!textPtr) {
 87328:     return false;
 87328:   }
 86697: 
 86697:   gfxSkipCharsBuilder builder;
 86697: 
 86697:   nsAutoTArray<PRInt32,50> textBreakPoints;
 86697:   TextRunUserData dummyData;
 86697:   TextRunMappedFlow dummyMappedFlow;
 86697: 
 86697:   TextRunUserData* userData;
 86697:   TextRunUserData* userDataToDestroy;
 86697:   // If the situation is particularly simple (and common) we don't need to
 86697:   // allocate userData.
 86697:   if (mMappedFlows.Length() == 1 && !mMappedFlows[0].mEndFrame &&
 86697:       mMappedFlows[0].mStartFrame->GetContentOffset() == 0) {
 86697:     userData = &dummyData;
 86697:     userDataToDestroy = nsnull;
 86697:     dummyData.mMappedFlows = &dummyMappedFlow;
 86697:   } else {
 86697:     userData = static_cast<TextRunUserData*>
 86697:       (nsMemory::Alloc(sizeof(TextRunUserData) + mMappedFlows.Length()*sizeof(TextRunMappedFlow)));
 86697:     userDataToDestroy = userData;
 86697:     userData->mMappedFlows = reinterpret_cast<TextRunMappedFlow*>(userData + 1);
 86697:   }
 86697:   userData->mMappedFlowCount = mMappedFlows.Length();
 86697:   userData->mLastFlowIndex = 0;
 86697: 
 86697:   PRUint32 nextBreakIndex = 0;
 86697:   nsTextFrame* nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
 86697: 
 86697:   PRUint32 i;
 86697:   const nsStyleText* textStyle = nsnull;
 86697:   for (i = 0; i < mMappedFlows.Length(); ++i) {
 86697:     MappedFlow* mappedFlow = &mMappedFlows[i];
 86697:     nsTextFrame* f = mappedFlow->mStartFrame;
 86697: 
 86697:     textStyle = f->GetStyleText();
 86697:     nsTextFrameUtils::CompressionMode compression =
 86697:       CSSWhitespaceToCompressionMode[textStyle->mWhiteSpace];
 86697: 
 86697:     // Figure out what content is included in this flow.
 86697:     nsIContent* content = f->GetContent();
 86697:     const nsTextFragment* frag = content->GetText();
 86697:     PRInt32 contentStart = mappedFlow->mStartFrame->GetContentOffset();
 86697:     PRInt32 contentEnd = mappedFlow->GetContentEnd();
 86697:     PRInt32 contentLength = contentEnd - contentStart;
 86697: 
 86697:     TextRunMappedFlow* newFlow = &userData->mMappedFlows[i];
 86697:     newFlow->mStartFrame = mappedFlow->mStartFrame;
 86697:     newFlow->mDOMOffsetToBeforeTransformOffset = builder.GetCharCount() -
 86697:       mappedFlow->mStartFrame->GetContentOffset();
 86697:     newFlow->mContentLength = contentLength;
 86697: 
 86697:     while (nextBreakBeforeFrame && nextBreakBeforeFrame->GetContent() == content) {
 86697:       textBreakPoints.AppendElement(
 86697:           nextBreakBeforeFrame->GetContentOffset() + newFlow->mDOMOffsetToBeforeTransformOffset);
 86697:       nextBreakBeforeFrame = GetNextBreakBeforeFrame(&nextBreakIndex);
 86697:     }
 86697: 
 86697:     PRUint32 analysisFlags;
 86697:     if (frag->Is2b()) {
 86697:       NS_ASSERTION(mDoubleByteText, "Wrong buffer char size!");
 86697:       PRUnichar* bufStart = static_cast<PRUnichar*>(textPtr);
 86697:       PRUnichar* bufEnd = nsTextFrameUtils::TransformText(
 86697:           frag->Get2b() + contentStart, contentLength, bufStart,
 86697:           compression, &mNextRunContextInfo, &builder, &analysisFlags);
 86697:       textPtr = bufEnd;
 86697:     } else {
 86697:       if (mDoubleByteText) {
 86697:         // Need to expand the text. First transform it into a temporary buffer,
 86697:         // then expand.
 86697:         AutoFallibleTArray<PRUint8,BIG_TEXT_NODE_SIZE> tempBuf;
 87328:         PRUint8* bufStart = tempBuf.AppendElements(contentLength);
 87328:         if (!bufStart) {
 86697:           DestroyUserData(userDataToDestroy);
 86697:           return false;
 86697:         }
 86697:         PRUint8* end = nsTextFrameUtils::TransformText(
 86697:             reinterpret_cast<const PRUint8*>(frag->Get1b()) + contentStart, contentLength,
 86697:             bufStart, compression, &mNextRunContextInfo, &builder, &analysisFlags);
 86697:         textPtr = ExpandBuffer(static_cast<PRUnichar*>(textPtr),
 86697:                                tempBuf.Elements(), end - tempBuf.Elements());
 86697:       } else {
 86697:         PRUint8* bufStart = static_cast<PRUint8*>(textPtr);
 86697:         PRUint8* end = nsTextFrameUtils::TransformText(
 86697:             reinterpret_cast<const PRUint8*>(frag->Get1b()) + contentStart, contentLength,
 86697:             bufStart, compression, &mNextRunContextInfo, &builder, &analysisFlags);
 86697:         textPtr = end;
 86697:       }
 86697:     }
 86697:   }
 86697: 
 86697:   // We have to set these up after we've created the textrun, because
 86697:   // the breaks may be stored in the textrun during this very call.
 86697:   // This is a bit annoying because it requires another loop over the frames
 86697:   // making up the textrun, but I don't see a way to avoid this.
 86697:   PRUint32 flags = 0;
 86697:   if (mDoubleByteText) {
 86697:     flags |= SBS_DOUBLE_BYTE;
 86697:   }
 86697:   if (mSkipIncompleteTextRuns) {
 86697:     flags |= SBS_SUPPRESS_SINK;
 86697:   }
 86697:   SetupBreakSinksForTextRun(aTextRun, buffer.Elements(), flags);
 86697: 
 86697:   DestroyUserData(userDataToDestroy);
 86697: 
 86697:   return true;
 86697: }
 86697: 
 79445: static bool
 16575: HasCompressedLeadingWhitespace(nsTextFrame* aFrame, const nsStyleText* aStyleText,
 16575:                                PRInt32 aContentEndOffset,
  3006:                                const gfxSkipCharsIterator& aIterator)
  3006: {
  3006:   if (!aIterator.IsOriginalCharSkipped())
 80486:     return false;
  2013: 
  3006:   gfxSkipCharsIterator iter = aIterator;
  2013:   PRInt32 frameContentOffset = aFrame->GetContentOffset();
 35581:   const nsTextFragment* frag = aFrame->GetContent()->GetText();
  3006:   while (frameContentOffset < aContentEndOffset && iter.IsOriginalCharSkipped()) {
 16575:     if (IsTrimmableSpace(frag, frameContentOffset, aStyleText))
 80486:       return true;
  2013:     ++frameContentOffset;
  3006:     iter.AdvanceOriginal(1);
  3006:   }
 80486:   return false;
  2013: }
  2013: 
     1: void
  1328: BuildTextRunsScanner::SetupBreakSinksForTextRun(gfxTextRun* aTextRun,
 86697:                                                 const void* aTextPtr,
 86697:                                                 PRUint32    aFlags)
     1: {
     1:   // textruns have uniform language
 88039:   nsIAtom* language = mMappedFlows[0].mStartFrame->GetStyleFont()->mLanguage;
  2013:   // We keep this pointed at the skip-chars data for the current mappedFlow.
  2013:   // This lets us cheaply check whether the flow has compressed initial
  2013:   // whitespace...
  2013:   gfxSkipCharsIterator iter(aTextRun->GetSkipChars());
  2013: 
     1:   PRUint32 i;
     1:   for (i = 0; i < mMappedFlows.Length(); ++i) {
     1:     MappedFlow* mappedFlow = &mMappedFlows[i];
  7114:     PRUint32 offset = iter.GetSkippedOffset();
  7114:     gfxSkipCharsIterator iterNext = iter;
  7114:     iterNext.AdvanceOriginal(mappedFlow->GetContentEnd() -
  7114:             mappedFlow->mStartFrame->GetContentOffset());
  7114: 
    60:     nsAutoPtr<BreakSink>* breakSink = mBreakSinks.AppendElement(
 86697:       new BreakSink(aTextRun, mContext, offset,
 86697:                     (aFlags & SBS_EXISTING_TEXTRUN) != 0));
    60:     if (!breakSink || !*breakSink)
     1:       return;
  7114: 
  7114:     PRUint32 length = iterNext.GetSkippedOffset() - offset;
     1:     PRUint32 flags = 0;
  2319:     nsIFrame* initialBreakController = mappedFlow->mAncestorControllingInitialBreak;
  2319:     if (!initialBreakController) {
  2319:       initialBreakController = mLineContainer;
  2319:     }
  7069:     if (!initialBreakController->GetStyleText()->WhiteSpaceCanWrap()) {
  7069:       flags |= nsLineBreaker::BREAK_SUPPRESS_INITIAL;
  7069:     }
  7069:     nsTextFrame* startFrame = mappedFlow->mStartFrame;
  2013:     const nsStyleText* textStyle = startFrame->GetStyleText();
  7069:     if (!textStyle->WhiteSpaceCanWrap()) {
  7069:       flags |= nsLineBreaker::BREAK_SUPPRESS_INSIDE;
  7069:     }
  7069:     if (aTextRun->GetFlags() & nsTextFrameUtils::TEXT_NO_BREAKS) {
  7069:       flags |= nsLineBreaker::BREAK_SKIP_SETTING_NO_BREAKS;
  7069:     }
  7832:     if (textStyle->mTextTransform == NS_STYLE_TEXT_TRANSFORM_CAPITALIZE) {
  7832:       flags |= nsLineBreaker::BREAK_NEED_CAPITALIZATION;
  7832:     }
 69311:     if (textStyle->mHyphens == NS_STYLE_HYPHENS_AUTO) {
 69311:       flags |= nsLineBreaker::BREAK_USE_AUTO_HYPHENATION;
 69311:     }
  7069: 
 16575:     if (HasCompressedLeadingWhitespace(startFrame, textStyle,
 16575:                                        mappedFlow->GetContentEnd(), iter)) {
  7069:       mLineBreaker.AppendInvisibleWhitespace(flags);
  7069:     }
  7069: 
  7069:     if (length > 0) {
 86697:       BreakSink* sink =
 86697:         (aFlags & SBS_SUPPRESS_SINK) ? nsnull : (*breakSink).get();
 86697:       if (aFlags & SBS_DOUBLE_BYTE) {
 86697:         const PRUnichar* text = reinterpret_cast<const PRUnichar*>(aTextPtr);
 86697:         mLineBreaker.AppendText(language, text + offset,
  2319:                                 length, flags, sink);
     1:       } else {
 86697:         const PRUint8* text = reinterpret_cast<const PRUint8*>(aTextPtr);
 86697:         mLineBreaker.AppendText(language, text + offset,
  2319:                                 length, flags, sink);
     1:       }
     1:     }
  2013:     
  7114:     iter = iterNext;
  2013:   }
     1: }
     1: 
 56309: // Find the flow corresponding to aContent in aUserData
 56309: static inline TextRunMappedFlow*
 56309: FindFlowForContent(TextRunUserData* aUserData, nsIContent* aContent)
 56309: {
 56309:   // Find the flow that contains us
 56309:   PRInt32 i = aUserData->mLastFlowIndex;
 56309:   PRInt32 delta = 1;
 56309:   PRInt32 sign = 1;
 56309:   // Search starting at the current position and examine close-by
 56309:   // positions first, moving further and further away as we go.
 64106:   while (i >= 0 && PRUint32(i) < aUserData->mMappedFlowCount) {
 56309:     TextRunMappedFlow* flow = &aUserData->mMappedFlows[i];
 56309:     if (flow->mStartFrame->GetContent() == aContent) {
 56309:       return flow;
 56309:     }
 56309: 
 56309:     i += delta;
 56309:     sign = -sign;
 64106:     delta = -delta + sign;
 56309:   }
 56309: 
 56309:   // We ran into an array edge.  Add |delta| to |i| once more to get
 56309:   // back to the side where we still need to search, then step in
 56309:   // the |sign| direction.
 56309:   i += delta;
 56309:   if (sign > 0) {
 64106:     for (; i < PRInt32(aUserData->mMappedFlowCount); ++i) {
 56309:       TextRunMappedFlow* flow = &aUserData->mMappedFlows[i];
 56309:       if (flow->mStartFrame->GetContent() == aContent) {
 56309:         return flow;
 56309:       }
 56309:     }
 56309:   } else {
 56309:     for (; i >= 0; --i) {
 56309:       TextRunMappedFlow* flow = &aUserData->mMappedFlows[i];
 56309:       if (flow->mStartFrame->GetContent() == aContent) {
 56309:         return flow;
 56309:       }
 56309:     }
 56309:   }
 56309: 
 56309:   return nsnull;
 56309: }
 56309: 
     1: void
 94144: BuildTextRunsScanner::AssignTextRun(gfxTextRun* aTextRun, float aInflation)
     1: {
     1:   PRUint32 i;
     1:   for (i = 0; i < mMappedFlows.Length(); ++i) {
     1:     MappedFlow* mappedFlow = &mMappedFlows[i];
     8:     nsTextFrame* startFrame = mappedFlow->mStartFrame;
     8:     nsTextFrame* endFrame = mappedFlow->mEndFrame;
     8:     nsTextFrame* f;
     8:     for (f = startFrame; f != endFrame;
  6033:          f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
  2828: #ifdef DEBUG_roc
 82675:       if (f->GetTextRun(mWhichTextRun)) {
 82675:         gfxTextRun* textRun = f->GetTextRun(mWhichTextRun);
     8:         if (textRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
  3233:           if (mMappedFlows[0].mStartFrame != static_cast<nsTextFrame*>(textRun->GetUserData())) {
     8:             NS_WARNING("REASSIGNING SIMPLE FLOW TEXT RUN!");
     8:           }
     8:         } else {
     8:           TextRunUserData* userData =
  3233:             static_cast<TextRunUserData*>(textRun->GetUserData());
     8:          
 64106:           if (userData->mMappedFlowCount >= mMappedFlows.Length() ||
     8:               userData->mMappedFlows[userData->mMappedFlowCount - 1].mStartFrame !=
     8:               mMappedFlows[userData->mMappedFlowCount - 1].mStartFrame) {
     8:             NS_WARNING("REASSIGNING MULTIFLOW TEXT RUN (not append)!");
     8:           }
     8:         }
     8:       }
     8: #endif
 56309: 
 82675:       gfxTextRun* oldTextRun = f->GetTextRun(mWhichTextRun);
 56309:       if (oldTextRun) {
 55835:         nsTextFrame* firstFrame = nsnull;
 56309:         PRUint32 startOffset = 0;
 55835:         if (oldTextRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
 55835:           firstFrame = static_cast<nsTextFrame*>(oldTextRun->GetUserData());
 55835:         }
 55835:         else {
 56309:           TextRunUserData* userData = static_cast<TextRunUserData*>(oldTextRun->GetUserData());
 55835:           firstFrame = userData->mMappedFlows[0].mStartFrame;
 56309:           if (NS_UNLIKELY(f != firstFrame)) {
 56309:             TextRunMappedFlow* flow = FindFlowForContent(userData, f->GetContent());
 56309:             if (flow) {
 56309:               startOffset = flow->mDOMOffsetToBeforeTransformOffset;
 56309:             }
 56309:             else {
 56309:               NS_ERROR("Can't find flow containing frame 'f'");
 56309:             }
 56309:           }
 56309:         }
 56309: 
 56309:         // Optimization: if |f| is the first frame in the flow then there are no
 56309:         // prev-continuations that use |oldTextRun|.
 56309:         nsTextFrame* clearFrom = nsnull;
 56309:         if (NS_UNLIKELY(f != firstFrame)) {
 56309:           // If all the frames in the mapped flow starting at |f| (inclusive)
 56309:           // are empty then we let the prev-continuations keep the old text run.
 56309:           gfxSkipCharsIterator iter(oldTextRun->GetSkipChars(), startOffset, f->GetContentOffset());
 56309:           PRUint32 textRunOffset = iter.ConvertOriginalToSkipped(f->GetContentOffset());
 56309:           clearFrom = textRunOffset == oldTextRun->GetLength() ? f : nsnull;
 56309:         }
 82675:         f->ClearTextRun(clearFrom, mWhichTextRun);
 56309: 
 55835: #ifdef DEBUG
 82675:         if (firstFrame && !firstFrame->GetTextRun(mWhichTextRun)) {
 55835:           // oldTextRun was destroyed - assert that we don't reference it.
 55835:           for (PRUint32 i = 0; i < mBreakSinks.Length(); ++i) {
 55835:             NS_ASSERTION(oldTextRun != mBreakSinks[i]->mTextRun,
 55835:                          "destroyed text run is still in use");
 55835:           }
 55835:         }
 55835: #endif
 56309:       }
 94144:       f->SetTextRun(aTextRun, mWhichTextRun, aInflation);
     1:     }
 25414:     // Set this bit now; we can't set it any earlier because
 25414:     // f->ClearTextRun() might clear it out.
 25414:     startFrame->AddStateBits(TEXT_IN_TEXTRUN_USER_DATA);
     1:   }
     1: }
     1: 
     1: gfxSkipCharsIterator
 82675: nsTextFrame::EnsureTextRun(TextRunType aWhichTextRun,
 82675:                            gfxContext* aReferenceContext,
 82675:                            nsIFrame* aLineContainer,
     1:                            const nsLineList::iterator* aLine,
  4672:                            PRUint32* aFlowEndInTextRun)
  4672: {
 82675:   gfxTextRun *textRun = GetTextRun(aWhichTextRun);
 82675:   if (textRun && (!aLine || !(*aLine)->GetInvalidateTextRuns())) {
 82675:     if (textRun->GetExpirationState()->IsTracked()) {
 82675:       gTextRuns->MarkUsed(textRun);
  1328:     }
  1328:   } else {
  6862:     nsRefPtr<gfxContext> ctx = aReferenceContext;
  6862:     if (!ctx) {
  6862:       ctx = GetReferenceRenderingContext(this, nsnull);
  6862:     }
  6862:     if (ctx) {
 94144:       BuildTextRuns(ctx, this, aLineContainer, aLine, aWhichTextRun);
 82675:     }
 82675:     textRun = GetTextRun(aWhichTextRun);
 82675:     if (!textRun) {
     1:       // A text run was not constructed for this frame. This is bad. The caller
     1:       // will check mTextRun.
     1:       static const gfxSkipChars emptySkipChars;
     1:       return gfxSkipCharsIterator(emptySkipChars, 0);
     1:     }
     1:   }
     1: 
 82675:   if (textRun->GetFlags() & nsTextFrameUtils::TEXT_IS_SIMPLE_FLOW) {
     1:     if (aFlowEndInTextRun) {
 82675:       *aFlowEndInTextRun = textRun->GetLength();
 82675:     }
 82675:     return gfxSkipCharsIterator(textRun->GetSkipChars(), 0, mContentOffset);
 82675:   }
 82675: 
 82675:   TextRunUserData* userData = static_cast<TextRunUserData*>(textRun->GetUserData());
 47926:   TextRunMappedFlow* flow = FindFlowForContent(userData, mContent);
 47926:   if (flow) {
  7012:     // Since textruns can only contain one flow for a given content element,
  7012:     // this must be our flow.
 64106:     PRUint32 flowIndex = flow - userData->mMappedFlows;
 47926:     userData->mLastFlowIndex = flowIndex;
 82675:     gfxSkipCharsIterator iter(textRun->GetSkipChars(),
     1:                               flow->mDOMOffsetToBeforeTransformOffset, mContentOffset);
     1:     if (aFlowEndInTextRun) {
 47926:       if (flowIndex + 1 < userData->mMappedFlowCount) {
 82675:         gfxSkipCharsIterator end(textRun->GetSkipChars());
     1:         *aFlowEndInTextRun = end.ConvertOriginalToSkipped(
     1:               flow[1].mStartFrame->GetContentOffset() + flow[1].mDOMOffsetToBeforeTransformOffset);
     1:       } else {
 82675:         *aFlowEndInTextRun = textRun->GetLength();
     1:       }
     1:     }
     1:     return iter;
     1:   }
 47926: 
     1:   NS_ERROR("Can't find flow containing this frame???");
     1:   static const gfxSkipChars emptySkipChars;
     1:   return gfxSkipCharsIterator(emptySkipChars, 0);
     1: }
     1: 
     8: static PRUint32
 16575: GetEndOfTrimmedText(const nsTextFragment* aFrag, const nsStyleText* aStyleText,
     8:                     PRUint32 aStart, PRUint32 aEnd,
     8:                     gfxSkipCharsIterator* aIterator)
     8: {
     8:   aIterator->SetSkippedOffset(aEnd);
     8:   while (aIterator->GetSkippedOffset() > aStart) {
     8:     aIterator->AdvanceSkipped(-1);
 16575:     if (!IsTrimmableSpace(aFrag, aIterator->GetOriginalOffset(), aStyleText))
  2013:       return aIterator->GetSkippedOffset() + 1;
  2013:   }
  2013:   return aStart;
     8: }
     8: 
     8: nsTextFrame::TrimmedOffsets
     8: nsTextFrame::GetTrimmedOffsets(const nsTextFragment* aFrag,
 79445:                                bool aTrimAfter)
     1: {
     1:   NS_ASSERTION(mTextRun, "Need textrun here");
 16575:   // This should not be used during reflow. We need our TEXT_REFLOW_FLAGS
 86328:   // to be set correctly.  If our parent wasn't reflowed due to the frame
 86328:   // tree being too deep then the return value doesn't matter.
 86328:   NS_ASSERTION(!(GetStateBits() & NS_FRAME_FIRST_REFLOW) ||
 86328:                (GetParent()->GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE),
 16575:                "Can only call this on frames that have been reflowed");
 16575:   NS_ASSERTION(!(GetStateBits() & NS_FRAME_IN_REFLOW),
 16575:                "Can only call this on frames that are not being reflowed");
     1: 
  4678:   TrimmedOffsets offsets = { GetContentOffset(), GetContentLength() };
  1912:   const nsStyleText* textStyle = GetStyleText();
 16575:   // Note that pre-line newlines should still allow us to trim spaces
 16575:   // for display
  1912:   if (textStyle->WhiteSpaceIsSignificant())
     8:     return offsets;
     8: 
     8:   if (GetStateBits() & TEXT_START_OF_LINE) {
     8:     PRInt32 whitespaceCount =
 16575:       GetTrimmableWhitespaceCount(aFrag,
 16575:                                   offsets.mStart, offsets.mLength, 1);
     8:     offsets.mStart += whitespaceCount;
     8:     offsets.mLength -= whitespaceCount;
     8:   }
     8: 
  7069:   if (aTrimAfter && (GetStateBits() & TEXT_END_OF_LINE)) {
 16575:     // This treats a trailing 'pre-line' newline as trimmable. That's fine,
 16575:     // it's actually what we want since we want whitespace before it to
 16575:     // be trimmed.
     8:     PRInt32 whitespaceCount =
 16575:       GetTrimmableWhitespaceCount(aFrag,
 16575:                                   offsets.GetEnd() - 1, offsets.mLength, -1);
     8:     offsets.mLength -= whitespaceCount;
     8:   }
     8:   return offsets;
     1: }
     1: 
     1: /*
     1:  * Currently only Unicode characters below 0x10000 have their spacing modified
     1:  * by justification. If characters above 0x10000 turn out to need
     1:  * justification spacing, that will require extra work. Currently,
     1:  * this function must not include 0xd800 to 0xdbff because these characters
     1:  * are surrogates.
     1:  */
 79445: static bool IsJustifiableCharacter(const nsTextFragment* aFrag, PRInt32 aPos,
 79445:                                      bool aLangIsCJ)
     1: {
     1:   PRUnichar ch = aFrag->CharAt(aPos);
 46149:   if (ch == '\n' || ch == '\t' || ch == '\r')
 80486:     return true;
 37532:   if (ch == ' ' || ch == CH_NBSP) {
     1:     // Don't justify spaces that are combined with diacriticals
     1:     if (!aFrag->Is2b())
 80486:       return true;
     1:     return !nsTextFrameUtils::IsSpaceCombiningSequenceTail(
     1:         aFrag->Get2b() + aPos + 1, aFrag->GetLength() - (aPos + 1));
     1:   }
     1:   if (ch < 0x2150u)
 80486:     return false;
     1:   if (aLangIsCJ && (
     1:        (0x2150u <= ch && ch <= 0x22ffu) || // Number Forms, Arrows, Mathematical Operators
     1:        (0x2460u <= ch && ch <= 0x24ffu) || // Enclosed Alphanumerics
     1:        (0x2580u <= ch && ch <= 0x27bfu) || // Block Elements, Geometric Shapes, Miscellaneous Symbols, Dingbats
     1:        (0x27f0u <= ch && ch <= 0x2bffu) || // Supplemental Arrows-A, Braille Patterns, Supplemental Arrows-B,
     1:                                            // Miscellaneous Mathematical Symbols-B, Supplemental Mathematical Operators,
     1:                                            // Miscellaneous Symbols and Arrows
     1:        (0x2e80u <= ch && ch <= 0x312fu) || // CJK Radicals Supplement, CJK Radicals Supplement,
     1:                                            // Ideographic Description Characters, CJK Symbols and Punctuation,
     1:                                            // Hiragana, Katakana, Bopomofo
     1:        (0x3190u <= ch && ch <= 0xabffu) || // Kanbun, Bopomofo Extended, Katakana Phonetic Extensions,
     1:                                            // Enclosed CJK Letters and Months, CJK Compatibility,
     1:                                            // CJK Unified Ideographs Extension A, Yijing Hexagram Symbols,
     1:                                            // CJK Unified Ideographs, Yi Syllables, Yi Radicals
     1:        (0xf900u <= ch && ch <= 0xfaffu) || // CJK Compatibility Ideographs
     1:        (0xff5eu <= ch && ch <= 0xff9fu)    // Halfwidth and Fullwidth Forms(a part)
     1:      ))
 80486:     return true;
 80486:   return false;
     1: }
     1: 
 62671: void
 62671: nsTextFrame::ClearMetrics(nsHTMLReflowMetrics& aMetrics)
     1: {
     1:   aMetrics.width = 0;
     1:   aMetrics.height = 0;
     1:   aMetrics.ascent = 0;
 62671:   mAscent = 0;
     1: }
     1: 
     1: static PRInt32 FindChar(const nsTextFragment* frag,
     1:                         PRInt32 aOffset, PRInt32 aLength, PRUnichar ch)
     1: {
     1:   PRInt32 i = 0;
     1:   if (frag->Is2b()) {
     1:     const PRUnichar* str = frag->Get2b() + aOffset;
     1:     for (; i < aLength; ++i) {
     1:       if (*str == ch)
     1:         return i + aOffset;
     1:       ++str;
     1:     }
     1:   } else {
     1:     if (PRUint16(ch) <= 0xFF) {
     1:       const char* str = frag->Get1b() + aOffset;
  1344:       const void* p = memchr(str, ch, aLength);
     1:       if (p)
  3233:         return (static_cast<const char*>(p) - str) + aOffset;
     1:     }
     1:   }
     1:   return -1;
     1: }
     1: 
 79445: static bool IsChineseOrJapanese(nsIFrame* aFrame)
 38492: {
 88039:   nsIAtom* language = aFrame->GetStyleFont()->mLanguage;
 38492:   if (!language) {
 80486:     return false;
 38492:   }
 39100:   const PRUnichar *lang = language->GetUTF16String();
 39100:   return (!nsCRT::strncmp(lang, NS_LITERAL_STRING("ja").get(), 2) ||
 39100:           !nsCRT::strncmp(lang, NS_LITERAL_STRING("zh").get(), 2)) &&
 39100:          (language->GetLength() == 2 || lang[2] == '-');
     1: }
     1: 
     1: #ifdef DEBUG
 79445: static bool IsInBounds(const gfxSkipCharsIterator& aStart, PRInt32 aContentLength,
     1:                          PRUint32 aOffset, PRUint32 aLength) {
     1:   if (aStart.GetSkippedOffset() > aOffset)
 80486:     return false;
  8556:   if (aContentLength == PR_INT32_MAX)
 80486:     return true;
     1:   gfxSkipCharsIterator iter(aStart);
  1756:   iter.AdvanceOriginal(aContentLength);
  1756:   return iter.GetSkippedOffset() >= aOffset + aLength;
     1: }
     1: #endif
     1: 
 15599: class NS_STACK_CLASS PropertyProvider : public gfxTextRun::PropertyProvider {
     1: public:
     1:   /**
     1:    * Use this constructor for reflow, when we don't know what text is
     1:    * really mapped by the frame and we have a lot of other data around.
  8556:    * 
  8556:    * @param aLength can be PR_INT32_MAX to indicate we cover all the text
  8556:    * associated with aFrame up to where its flow chain ends in the given
  8556:    * textrun. If PR_INT32_MAX is passed, justification and hyphen-related methods
  8556:    * cannot be called, nor can GetOriginalLength().
     1:    */
     1:   PropertyProvider(gfxTextRun* aTextRun, const nsStyleText* aTextStyle,
     1:                    const nsTextFragment* aFrag, nsTextFrame* aFrame,
  1732:                    const gfxSkipCharsIterator& aStart, PRInt32 aLength,
  1732:                    nsIFrame* aLineContainer,
 82675:                    nscoord aOffsetFromBlockOriginForTabs,
 82675:                    nsTextFrame::TextRunType aWhichTextRun)
 13714:     : mTextRun(aTextRun), mFontGroup(nsnull),
 13714:       mTextStyle(aTextStyle), mFrag(aFrag),
  1732:       mLineContainer(aLineContainer),
  2013:       mFrame(aFrame), mStart(aStart), mTempIterator(aStart),
 62821:       mTabWidths(nsnull), mTabWidthsAnalyzedLimit(0),
 62821:       mLength(aLength),
 23137:       mWordSpacing(mTextStyle->mWordSpacing),
     1:       mLetterSpacing(StyleToCoord(mTextStyle->mLetterSpacing)),
     1:       mJustificationSpacing(0),
  1732:       mHyphenWidth(-1),
  1732:       mOffsetFromBlockOriginForTabs(aOffsetFromBlockOriginForTabs),
 82675:       mReflowing(true),
 82675:       mWhichTextRun(aWhichTextRun)
     1:   {
     1:     NS_ASSERTION(mStart.IsInitialized(), "Start not initialized?");
     1:   }
     1: 
     1:   /**
     1:    * Use this constructor after the frame has been reflowed and we don't
     1:    * have other data around. Gets everything from the frame. EnsureTextRun
     1:    * *must* be called before this!!!
     1:    */
 82675:   PropertyProvider(nsTextFrame* aFrame, const gfxSkipCharsIterator& aStart,
 82675:                    nsTextFrame::TextRunType aWhichTextRun)
 82675:     : mTextRun(aFrame->GetTextRun(aWhichTextRun)), mFontGroup(nsnull),
  1732:       mTextStyle(aFrame->GetStyleText()),
 35581:       mFrag(aFrame->GetContent()->GetText()),
  1732:       mLineContainer(nsnull),
  2013:       mFrame(aFrame), mStart(aStart), mTempIterator(aStart),
 62821:       mTabWidths(nsnull), mTabWidthsAnalyzedLimit(0),
  1732:       mLength(aFrame->GetContentLength()),
 23137:       mWordSpacing(mTextStyle->mWordSpacing),
     1:       mLetterSpacing(StyleToCoord(mTextStyle->mLetterSpacing)),
     1:       mJustificationSpacing(0),
  1732:       mHyphenWidth(-1),
  1732:       mOffsetFromBlockOriginForTabs(0),
 82675:       mReflowing(false),
 82675:       mWhichTextRun(aWhichTextRun)
     1:   {
     1:     NS_ASSERTION(mTextRun, "Textrun not initialized!");
     1:   }
     1: 
     1:   // Call this after construction if you're not going to reflow the text
 79445:   void InitializeForDisplay(bool aTrimAfter);
     1: 
     1:   virtual void GetSpacing(PRUint32 aStart, PRUint32 aLength, Spacing* aSpacing);
     1:   virtual gfxFloat GetHyphenWidth();
     1:   virtual void GetHyphenationBreaks(PRUint32 aStart, PRUint32 aLength,
 79445:                                     bool* aBreakBefore);
 69311:   virtual PRInt8 GetHyphensOption() {
 69311:     return mTextStyle->mHyphens;
 69311:   }
     1: 
  1732:   void GetSpacingInternal(PRUint32 aStart, PRUint32 aLength, Spacing* aSpacing,
 79445:                           bool aIgnoreTabs);
  1732: 
     1:   /**
     1:    * Count the number of justifiable characters in the given DOM range
     1:    */
     1:   PRUint32 ComputeJustifiableCharacters(PRInt32 aOffset, PRInt32 aLength);
  8514:   /**
  8514:    * Find the start and end of the justifiable characters. Does not depend on the
  8514:    * position of aStart or aEnd, although it's most efficient if they are near the
  8514:    * start and end of the text frame.
  8514:    */
  7076:   void FindJustificationRange(gfxSkipCharsIterator* aStart,
  7076:                               gfxSkipCharsIterator* aEnd);
     1: 
     8:   const nsStyleText* GetStyleText() { return mTextStyle; }
     1:   nsTextFrame* GetFrame() { return mFrame; }
     1:   // This may not be equal to the frame offset/length in because we may have
     1:   // adjusted for whitespace trimming according to the state bits set in the frame
     1:   // (for the static provider)
     1:   const gfxSkipCharsIterator& GetStart() { return mStart; }
  8474:   // May return PR_INT32_MAX if that was given to the constructor
  8556:   PRUint32 GetOriginalLength() {
  8556:     NS_ASSERTION(mLength != PR_INT32_MAX, "Length not known");
  8556:     return mLength;
  8556:   }
     1:   const nsTextFragment* GetFragment() { return mFrag; }
     1: 
     1:   gfxFontGroup* GetFontGroup() {
 13714:     if (!mFontGroup)
 13714:       InitFontGroupAndFontMetrics();
     1:     return mFontGroup;
     1:   }
     1: 
 68493:   nsFontMetrics* GetFontMetrics() {
 13714:     if (!mFontMetrics)
 13714:       InitFontGroupAndFontMetrics();
 13714:     return mFontMetrics;
 13714:   }
 13714: 
 62821:   void CalcTabWidths(PRUint32 aTransformedStart, PRUint32 aTransformedLength);
  1732: 
  2013:   const gfxSkipCharsIterator& GetEndHint() { return mTempIterator; }
  2013: 
     1: protected:
     1:   void SetupJustificationSpacing();
     1: 
 13714:   void InitFontGroupAndFontMetrics() {
 82675:     float inflation = (mWhichTextRun == nsTextFrame::eInflated)
 82675:       ? mFrame->GetFontSizeInflation() : 1.0f;
 82675:     mFontGroup = GetFontGroupForFrame(mFrame, inflation,
 82675:                                       getter_AddRefs(mFontMetrics));
 13714:   }
 13714: 
     1:   gfxTextRun*           mTextRun;
     1:   gfxFontGroup*         mFontGroup;
 68493:   nsRefPtr<nsFontMetrics> mFontMetrics;
     1:   const nsStyleText*    mTextStyle;
     1:   const nsTextFragment* mFrag;
  1732:   nsIFrame*             mLineContainer;
     1:   nsTextFrame*          mFrame;
     1:   gfxSkipCharsIterator  mStart;  // Offset in original and transformed string
  2013:   gfxSkipCharsIterator  mTempIterator;
 12350:   
 12350:   // Either null, or pointing to the frame's tabWidthProperty.
 62821:   TabWidthStore*        mTabWidths;
 62821:   // how far we've done tab-width calculation; this is ONLY valid
 62821:   // when mTabWidths is NULL (otherwise rely on mTabWidths->mLimit instead)
 62821:   PRUint32              mTabWidthsAnalyzedLimit;
 12350: 
  8556:   PRInt32               mLength; // DOM string length, may be PR_INT32_MAX
     1:   gfxFloat              mWordSpacing;     // space for each whitespace char
     1:   gfxFloat              mLetterSpacing;   // space for each letter
     1:   gfxFloat              mJustificationSpacing;
     1:   gfxFloat              mHyphenWidth;
  1732:   gfxFloat              mOffsetFromBlockOriginForTabs;
 79445:   bool                  mReflowing;
 82675:   nsTextFrame::TextRunType mWhichTextRun;
     1: };
     1: 
     1: PRUint32
     1: PropertyProvider::ComputeJustifiableCharacters(PRInt32 aOffset, PRInt32 aLength)
     1: {
     1:   // Scan non-skipped characters and count justifiable chars.
     1:   nsSkipCharsRunIterator
     1:     run(mStart, nsSkipCharsRunIterator::LENGTH_INCLUDES_SKIPPED, aLength);
     1:   run.SetOriginalOffset(aOffset);
     1:   PRUint32 justifiableChars = 0;
 79445:   bool isCJK = IsChineseOrJapanese(mFrame);
     1:   while (run.NextRun()) {
     1:     PRInt32 i;
     1:     for (i = 0; i < run.GetRunLength(); ++i) {
     1:       justifiableChars +=
     1:         IsJustifiableCharacter(mFrag, run.GetOriginalOffset() + i, isCJK);
     1:     }
     1:   }
     1:   return justifiableChars;
     1: }
     1: 
     1: /**
     1:  * Finds the offset of the first character of the cluster containing aPos
     1:  */
 38653: static void FindClusterStart(gfxTextRun* aTextRun, PRInt32 aOriginalStart,
     1:                              gfxSkipCharsIterator* aPos)
     1: {
 38653:   while (aPos->GetOriginalOffset() > aOriginalStart) {
     1:     if (aPos->IsOriginalCharSkipped() ||
     8:         aTextRun->IsClusterStart(aPos->GetSkippedOffset())) {
     1:       break;
     1:     }
     1:     aPos->AdvanceOriginal(-1);
     1:   }
     1: }
     1: 
     1: /**
     1:  * Finds the offset of the last character of the cluster containing aPos
     1:  */
     1: static void FindClusterEnd(gfxTextRun* aTextRun, PRInt32 aOriginalEnd,
     1:                            gfxSkipCharsIterator* aPos)
     1: {
     1:   NS_PRECONDITION(aPos->GetOriginalOffset() < aOriginalEnd,
     1:                   "character outside string");
     1:   aPos->AdvanceOriginal(1);
     1:   while (aPos->GetOriginalOffset() < aOriginalEnd) {
     1:     if (aPos->IsOriginalCharSkipped() ||
     8:         aTextRun->IsClusterStart(aPos->GetSkippedOffset())) {
     1:       break;
     1:     }
     1:     aPos->AdvanceOriginal(1);
     1:   }
     1:   aPos->AdvanceOriginal(-1);
     1: }
     1: 
     1: // aStart, aLength in transformed string offsets
     1: void
     1: PropertyProvider::GetSpacing(PRUint32 aStart, PRUint32 aLength,
     1:                              Spacing* aSpacing)
     1: {
  1732:   GetSpacingInternal(aStart, aLength, aSpacing,
  1732:                      (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TAB) == 0);
  1732: }
  1732: 
 79445: static bool
  2027: CanAddSpacingAfter(gfxTextRun* aTextRun, PRUint32 aOffset)
  2027: {
  2027:   if (aOffset + 1 >= aTextRun->GetLength())
 80486:     return true;
  2027:   return aTextRun->IsClusterStart(aOffset + 1) &&
  7715:     aTextRun->IsLigatureGroupStart(aOffset + 1);
  2027: }
  2027: 
  1732: void
  1732: PropertyProvider::GetSpacingInternal(PRUint32 aStart, PRUint32 aLength,
 79445:                                      Spacing* aSpacing, bool aIgnoreTabs)
  1732: {
     1:   NS_PRECONDITION(IsInBounds(mStart, mLength, aStart, aLength), "Range out of bounds");
     1: 
     1:   PRUint32 index;
     1:   for (index = 0; index < aLength; ++index) {
     1:     aSpacing[index].mBefore = 0.0;
     1:     aSpacing[index].mAfter = 0.0;
     1:   }
     1: 
     1:   // Find our offset into the original+transformed string
     1:   gfxSkipCharsIterator start(mStart);
     1:   start.SetSkippedOffset(aStart);
     1: 
     1:   // First, compute the word and letter spacing
     1:   if (mWordSpacing || mLetterSpacing) {
     1:     // Iterate over non-skipped characters
     1:     nsSkipCharsRunIterator
     1:       run(start, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
     1:     while (run.NextRun()) {
     1:       PRUint32 runOffsetInSubstring = run.GetSkippedOffset() - aStart;
     1:       PRInt32 i;
     8:       gfxSkipCharsIterator iter = run.GetPos();
     1:       for (i = 0; i < run.GetRunLength(); ++i) {
  2027:         if (CanAddSpacingAfter(mTextRun, run.GetSkippedOffset() + i)) {
  2027:           // End of a cluster, not in a ligature: put letter-spacing after it
     1:           aSpacing[runOffsetInSubstring + i].mAfter += mLetterSpacing;
     1:         }
 22494:         if (IsCSSWordSpacingSpace(mFrag, i + run.GetOriginalOffset(),
 22494:                                   mTextStyle)) {
     1:           // It kinda sucks, but space characters can be part of clusters,
     1:           // and even still be whitespace (I think!)
     8:           iter.SetSkippedOffset(run.GetSkippedOffset() + i);
     8:           FindClusterEnd(mTextRun, run.GetOriginalOffset() + run.GetRunLength(),
     8:                          &iter);
     8:           aSpacing[iter.GetSkippedOffset() - aStart].mAfter += mWordSpacing;
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
 33208:   // Ignore tab spacing rather than computing it, if the tab size is 0
 33208:   if (!aIgnoreTabs)
 33208:     aIgnoreTabs = mFrame->GetStyleText()->mTabSize == 0;
 33208: 
     1:   // Now add tab spacing, if there is any
  1732:   if (!aIgnoreTabs) {
 62821:     CalcTabWidths(aStart, aLength);
 62821:     if (mTabWidths) {
 62821:       mTabWidths->ApplySpacing(aSpacing,
 62821:                                aStart - mStart.GetSkippedOffset(), aLength);
     1:     }
     1:   }
     1: 
     1:   // Now add in justification spacing
     1:   if (mJustificationSpacing) {
     1:     gfxFloat halfJustificationSpace = mJustificationSpacing/2;
     1:     // Scan non-skipped characters and adjust justifiable chars, adding
     1:     // justification space on either side of the cluster
 79445:     bool isCJK = IsChineseOrJapanese(mFrame);
  7076:     gfxSkipCharsIterator justificationStart(mStart), justificationEnd(mStart);
  7076:     FindJustificationRange(&justificationStart, &justificationEnd);
     1: 
     1:     nsSkipCharsRunIterator
     1:       run(start, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
     1:     while (run.NextRun()) {
     1:       PRInt32 i;
     8:       gfxSkipCharsIterator iter = run.GetPos();
 38653:       PRInt32 runOriginalOffset = run.GetOriginalOffset();
     1:       for (i = 0; i < run.GetRunLength(); ++i) {
 38653:         PRInt32 iterOriginalOffset = runOriginalOffset + i;
 38653:         if (IsJustifiableCharacter(mFrag, iterOriginalOffset, isCJK)) {
 38653:           iter.SetOriginalOffset(iterOriginalOffset);
 38653:           FindClusterStart(mTextRun, runOriginalOffset, &iter);
     8:           PRUint32 clusterFirstChar = iter.GetSkippedOffset();
 38653:           FindClusterEnd(mTextRun, runOriginalOffset + run.GetRunLength(), &iter);
     8:           PRUint32 clusterLastChar = iter.GetSkippedOffset();
     1:           // Only apply justification to characters before justificationEnd
  7076:           if (clusterFirstChar >= justificationStart.GetSkippedOffset() &&
  7076:               clusterLastChar < justificationEnd.GetSkippedOffset()) {
     8:             aSpacing[clusterFirstChar - aStart].mBefore += halfJustificationSpace;
     8:             aSpacing[clusterLastChar - aStart].mAfter += halfJustificationSpace;
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
     1: 
 16705: static gfxFloat
 33208: ComputeTabWidthAppUnits(nsIFrame* aFrame, gfxTextRun* aTextRun)
 33208: {
 33208:   // Get the number of spaces from CSS -moz-tab-size
 33208:   const nsStyleText* textStyle = aFrame->GetStyleText();
 33208:   
 16705:   // Round the space width when converting to appunits the same way
 16705:   // textruns do
 16705:   gfxFloat spaceWidthAppUnits =
 82673:     NS_round(GetFirstFontMetrics(aTextRun->GetFontGroup()).spaceWidth *
 16705:               aTextRun->GetAppUnitsPerDevUnit());
 33208:   return textStyle->mTabSize * spaceWidthAppUnits;
 16705: }
 16705: 
 16705: // aX and the result are in whole appunits.
 16705: static gfxFloat
 33208: AdvanceToNextTab(gfxFloat aX, nsIFrame* aFrame,
 16705:                  gfxTextRun* aTextRun, gfxFloat* aCachedTabWidth)
 16705: {
 16705:   if (*aCachedTabWidth < 0) {
 33208:     *aCachedTabWidth = ComputeTabWidthAppUnits(aFrame, aTextRun);
 16705:   }
 16705: 
 16705:   // Advance aX to the next multiple of *aCachedTabWidth. We must advance
 16705:   // by at least 1 appunit.
 16705:   // XXX should we make this 1 CSS pixel?
 75359:   return ceil((aX + 1)/(*aCachedTabWidth))*(*aCachedTabWidth);
 16705: }
 16705: 
 62821: void
 62821: PropertyProvider::CalcTabWidths(PRUint32 aStart, PRUint32 aLength)
  1732: {
  1732:   if (!mTabWidths) {
 62821:     if (mReflowing && !mLineContainer) {
 16705:       // Intrinsic width computation does its own tab processing. We
 16705:       // just don't do anything here.
 62821:       return;
 62821:     }
 62821:     if (!mReflowing) {
 62821:       mTabWidths = static_cast<TabWidthStore*>
 62821:         (mFrame->Properties().Get(TabWidthProperty()));
 62821: #ifdef DEBUG
 62821:       // If we're not reflowing, we should have already computed the
 62821:       // tab widths; check that they're available as far as the last
 62821:       // tab character present (if any)
 62821:       for (PRUint32 i = aStart + aLength; i > aStart; --i) {
 86697:         if (mTextRun->CharIsTab(i - 1)) {
 62821:           NS_ASSERTION(mTabWidths && mTabWidths->mLimit >= i,
 62821:                        "Precomputed tab widths are missing!");
 62821:           break;
 62821:         }
 62821:       }
 62821: #endif
 62821:       return;
  1732:     }
  1732:   }
  1732: 
  1732:   PRUint32 startOffset = mStart.GetSkippedOffset();
 62821:   PRUint32 tabsEnd = mTabWidths ?
 72496:     mTabWidths->mLimit : NS_MAX(mTabWidthsAnalyzedLimit, startOffset);
 62821: 
  1732:   if (tabsEnd < aStart + aLength) {
 62821:     NS_ASSERTION(mReflowing,
 62821:                  "We need precomputed tab widths, but don't have enough.");
  1732: 
 16705:     gfxFloat tabWidth = -1;
 12350:     for (PRUint32 i = tabsEnd; i < aStart + aLength; ++i) {
  1732:       Spacing spacing;
 80486:       GetSpacingInternal(i, 1, &spacing, true);
  1732:       mOffsetFromBlockOriginForTabs += spacing.mBefore;
  1732: 
 86697:       if (!mTextRun->CharIsTab(i)) {
  1732:         if (mTextRun->IsClusterStart(i)) {
  1732:           PRUint32 clusterEnd = i + 1;
  1732:           while (clusterEnd < mTextRun->GetLength() &&
  1732:                  !mTextRun->IsClusterStart(clusterEnd)) {
  1732:             ++clusterEnd;
  1732:           }
  1732:           mOffsetFromBlockOriginForTabs +=
  1732:             mTextRun->GetAdvanceWidth(i, clusterEnd - i, nsnull);
  1732:         }
  1732:       } else {
 62821:         if (!mTabWidths) {
 62821:           mTabWidths = new TabWidthStore();
 62821:           mFrame->Properties().Set(TabWidthProperty(), mTabWidths);
 62821:         }
 16705:         double nextTab = AdvanceToNextTab(mOffsetFromBlockOriginForTabs,
 33208:                 mFrame, mTextRun, &tabWidth);
 73750:         mTabWidths->mWidths.AppendElement(TabWidth(i - startOffset, 
 73750:                 NSToIntRound(nextTab - mOffsetFromBlockOriginForTabs)));
  1732:         mOffsetFromBlockOriginForTabs = nextTab;
  1732:       }
  1732: 
  1732:       mOffsetFromBlockOriginForTabs += spacing.mAfter;
  1732:     }
 62821: 
 62821:     if (mTabWidths) {
 62821:       mTabWidths->mLimit = aStart + aLength;
 62821:     }
 62821:   }
 62821: 
 62821:   if (!mTabWidths) {
 62821:     // Delete any stale property that may be left on the frame
 62821:     mFrame->Properties().Delete(TabWidthProperty());
 72496:     mTabWidthsAnalyzedLimit = NS_MAX(mTabWidthsAnalyzedLimit,
 62821:                                      aStart + aLength);
 62821:   }
     1: }
     1: 
     1: gfxFloat
     1: PropertyProvider::GetHyphenWidth()
     1: {
     1:   if (mHyphenWidth < 0) {
 86690:     nsAutoPtr<gfxTextRun> hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, mFrame));
     1:     mHyphenWidth = mLetterSpacing;
  5724:     if (hyphenTextRun.get()) {
     1:       mHyphenWidth += hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull);
     1:     }
     1:   }
     1:   return mHyphenWidth;
     1: }
     1: 
     1: void
     1: PropertyProvider::GetHyphenationBreaks(PRUint32 aStart, PRUint32 aLength,
 79445:                                        bool* aBreakBefore)
     1: {
     1:   NS_PRECONDITION(IsInBounds(mStart, mLength, aStart, aLength), "Range out of bounds");
  8556:   NS_PRECONDITION(mLength != PR_INT32_MAX, "Can't call this with undefined length");
     1: 
 69311:   if (!mTextStyle->WhiteSpaceCanWrap() ||
 69311:       mTextStyle->mHyphens == NS_STYLE_HYPHENS_NONE)
 69311:   {
 89518:     memset(aBreakBefore, false, aLength*sizeof(bool));
     1:     return;
     1:   }
     1: 
     1:   // Iterate through the original-string character runs
     1:   nsSkipCharsRunIterator
   202:     run(mStart, nsSkipCharsRunIterator::LENGTH_UNSKIPPED_ONLY, aLength);
     1:   run.SetSkippedOffset(aStart);
     1:   // We need to visit skipped characters so that we can detect SHY
     1:   run.SetVisitSkipped();
     1: 
  5422:   PRInt32 prevTrailingCharOffset = run.GetPos().GetOriginalOffset() - 1;
 79445:   bool allowHyphenBreakBeforeNextChar =
  5422:     prevTrailingCharOffset >= mStart.GetOriginalOffset() &&
  5422:     prevTrailingCharOffset < mStart.GetOriginalOffset() + mLength &&
  5422:     mFrag->CharAt(prevTrailingCharOffset) == CH_SHY;
     1: 
     1:   while (run.NextRun()) {
     1:     NS_ASSERTION(run.GetRunLength() > 0, "Shouldn't return zero-length runs");
     1:     if (run.IsSkipped()) {
     1:       // Check if there's a soft hyphen which would let us hyphenate before
     1:       // the next non-skipped character. Don't look at soft hyphens followed
     1:       // by other skipped characters, we won't use them.
     1:       allowHyphenBreakBeforeNextChar =
     1:         mFrag->CharAt(run.GetOriginalOffset() + run.GetRunLength() - 1) == CH_SHY;
     1:     } else {
     1:       PRInt32 runOffsetInSubstring = run.GetSkippedOffset() - aStart;
 89518:       memset(aBreakBefore + runOffsetInSubstring, false, run.GetRunLength()*sizeof(bool));
  3006:       // Don't allow hyphen breaks at the start of the line
  3006:       aBreakBefore[runOffsetInSubstring] = allowHyphenBreakBeforeNextChar &&
  3006:           (!(mFrame->GetStateBits() & TEXT_START_OF_LINE) ||
  3006:            run.GetSkippedOffset() > mStart.GetSkippedOffset());
 80486:       allowHyphenBreakBeforeNextChar = false;
     1:     }
     1:   }
 69311: 
 69311:   if (mTextStyle->mHyphens == NS_STYLE_HYPHENS_AUTO) {
 69311:     for (PRUint32 i = 0; i < aLength; ++i) {
 69311:       if (mTextRun->CanHyphenateBefore(aStart + i)) {
 80486:         aBreakBefore[i] = true;
 69311:       }
 69311:     }
 69311:   }
     1: }
     1: 
     1: void
 79445: PropertyProvider::InitializeForDisplay(bool aTrimAfter)
     1: {
     8:   nsTextFrame::TrimmedOffsets trimmed =
     8:     mFrame->GetTrimmedOffsets(mFrag, aTrimAfter);
     8:   mStart.SetOriginalOffset(trimmed.mStart);
     8:   mLength = trimmed.mLength;
     1:   SetupJustificationSpacing();
     1: }
     1: 
     1: static PRUint32 GetSkippedDistance(const gfxSkipCharsIterator& aStart,
     1:                                    const gfxSkipCharsIterator& aEnd)
     1: {
     1:   return aEnd.GetSkippedOffset() - aStart.GetSkippedOffset();
     1: }
     1: 
     1: void
  7076: PropertyProvider::FindJustificationRange(gfxSkipCharsIterator* aStart,
  7076:                                          gfxSkipCharsIterator* aEnd)
  7076: {
  8556:   NS_PRECONDITION(mLength != PR_INT32_MAX, "Can't call this with undefined length");
  7076:   NS_ASSERTION(aStart && aEnd, "aStart or/and aEnd is null");
  8556: 
  7076:   aStart->SetOriginalOffset(mStart.GetOriginalOffset());
  7076:   aEnd->SetOriginalOffset(mStart.GetOriginalOffset() + mLength);
  7076: 
  7076:   // Ignore first cluster at start of line for justification purposes
  7076:   if (mFrame->GetStateBits() & TEXT_START_OF_LINE) {
  7076:     while (aStart->GetOriginalOffset() < aEnd->GetOriginalOffset()) {
  7076:       aStart->AdvanceOriginal(1);
  7076:       if (!aStart->IsOriginalCharSkipped() &&
  7076:           mTextRun->IsClusterStart(aStart->GetSkippedOffset()))
  7076:         break;
  7076:     }
  7076:   }
  7002: 
  7002:   // Ignore trailing cluster at end of line for justification purposes
  7076:   if (mFrame->GetStateBits() & TEXT_END_OF_LINE) {
  7076:     while (aEnd->GetOriginalOffset() > aStart->GetOriginalOffset()) {
  7076:       aEnd->AdvanceOriginal(-1);
  7076:       if (!aEnd->IsOriginalCharSkipped() &&
  7076:           mTextRun->IsClusterStart(aEnd->GetSkippedOffset()))
  6947:         break;
  6947:     }
  6947:   }
  7076: }
  1320: 
     1: void
     1: PropertyProvider::SetupJustificationSpacing()
     1: {
  8556:   NS_PRECONDITION(mLength != PR_INT32_MAX, "Can't call this with undefined length");
  8556: 
 16575:   if (!(mFrame->GetStateBits() & TEXT_JUSTIFICATION_ENABLED))
     1:     return;
     1: 
  7076:   gfxSkipCharsIterator start(mStart), end(mStart);
 32189:   // We can't just use our mLength here; when InitializeForDisplay is
 80486:   // called with false for aTrimAfter, we still shouldn't be assigning
 32189:   // justification space to any trailing whitespace.
 32189:   nsTextFrame::TrimmedOffsets trimmed =
 80486:     mFrame->GetTrimmedOffsets(mFrag, true);
 32189:   end.AdvanceOriginal(trimmed.mLength);
     1:   gfxSkipCharsIterator realEnd(end);
  7076:   FindJustificationRange(&start, &end);
     1: 
     1:   PRInt32 justifiableCharacters =
  7076:     ComputeJustifiableCharacters(start.GetOriginalOffset(),
  7076:                                  end.GetOriginalOffset() - start.GetOriginalOffset());
     1:   if (justifiableCharacters == 0) {
     1:     // Nothing to do, nothing is justifiable and we shouldn't have any
     1:     // justification space assigned
     1:     return;
     1:   }
     1: 
     1:   gfxFloat naturalWidth =
     1:     mTextRun->GetAdvanceWidth(mStart.GetSkippedOffset(),
     1:                               GetSkippedDistance(mStart, realEnd), this);
   202:   if (mFrame->GetStateBits() & TEXT_HYPHEN_BREAK) {
 86690:     nsAutoPtr<gfxTextRun> hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, mFrame));
  5724:     if (hyphenTextRun.get()) {
   202:       naturalWidth +=
  1328:         hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull);
   202:     }
   202:   }
     1:   gfxFloat totalJustificationSpace = mFrame->GetSize().width - naturalWidth;
     1:   if (totalJustificationSpace <= 0) {
     1:     // No space available
     1:     return;
     1:   }
     1:   
     1:   mJustificationSpacing = totalJustificationSpace/justifiableCharacters;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: // Helper class for managing blinking text
     1: 
     1: class nsBlinkTimer : public nsITimerCallback
     1: {
     1: public:
     1:   nsBlinkTimer();
     1:   virtual ~nsBlinkTimer();
     1: 
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   void AddFrame(nsPresContext* aPresContext, nsIFrame* aFrame);
     1: 
 79445:   bool RemoveFrame(nsIFrame* aFrame);
     1: 
     1:   PRInt32 FrameCount();
     1: 
     1:   void Start();
     1: 
     1:   void Stop();
     1: 
     1:   NS_DECL_NSITIMERCALLBACK
     1: 
 72507:   static void AddBlinkFrame(nsPresContext* aPresContext, nsIFrame* aFrame);
 72507:   static void RemoveBlinkFrame(nsIFrame* aFrame);
     1:   
 79445:   static bool     GetBlinkIsOff() { return sState == 3; }
     1:   
     1: protected:
     1: 
     1:   struct FrameData {
     1:     nsPresContext* mPresContext;  // pres context associated with the frame
     1:     nsIFrame*       mFrame;
     1: 
     1: 
     1:     FrameData(nsPresContext* aPresContext,
     1:               nsIFrame*       aFrame)
     1:       : mPresContext(aPresContext), mFrame(aFrame) {}
     1:   };
     1: 
 26081:   class FrameDataComparator {
 26081:     public:
 79445:       bool Equals(const FrameData& aTimer, nsIFrame* const& aFrame) const {
 26081:         return aTimer.mFrame == aFrame;
 26081:       }
 26081:   };
 26081: 
     1:   nsCOMPtr<nsITimer> mTimer;
 26081:   nsTArray<FrameData> mFrames;
     1:   nsPresContext* mPresContext;
     1: 
     1: protected:
     1: 
     1:   static nsBlinkTimer* sTextBlinker;
     1:   static PRUint32      sState; // 0-2 == on; 3 == off
     1:   
     1: };
     1: 
     1: nsBlinkTimer* nsBlinkTimer::sTextBlinker = nsnull;
     1: PRUint32      nsBlinkTimer::sState = 0;
     1: 
     1: #ifdef NOISY_BLINK
     1: static PRTime gLastTick;
     1: #endif
     1: 
     1: nsBlinkTimer::nsBlinkTimer()
     1: {
     1: }
     1: 
     1: nsBlinkTimer::~nsBlinkTimer()
     1: {
     1:   Stop();
     1:   sTextBlinker = nsnull;
     1: }
     1: 
     1: void nsBlinkTimer::Start()
     1: {
     1:   nsresult rv;
     1:   mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
     1:   if (NS_OK == rv) {
 69095:     mTimer->InitWithCallback(this, 250, nsITimer::TYPE_REPEATING_PRECISE_CAN_SKIP);
     1:   }
     1: }
     1: 
     1: void nsBlinkTimer::Stop()
     1: {
     1:   if (nsnull != mTimer) {
     1:     mTimer->Cancel();
  5854:     mTimer = nsnull;
     1:   }
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS1(nsBlinkTimer, nsITimerCallback)
     1: 
     1: void nsBlinkTimer::AddFrame(nsPresContext* aPresContext, nsIFrame* aFrame) {
 26081:   mFrames.AppendElement(FrameData(aPresContext, aFrame));
 24551:   if (1 == mFrames.Length()) {
     1:     Start();
     1:   }
     1: }
     1: 
 79445: bool nsBlinkTimer::RemoveFrame(nsIFrame* aFrame) {
 26081:   mFrames.RemoveElement(aFrame, FrameDataComparator());
 26081:   
 26081:   if (mFrames.IsEmpty()) {
     1:     Stop();
     1:   }
 80486:   return true;
     1: }
     1: 
     1: PRInt32 nsBlinkTimer::FrameCount() {
 24551:   return PRInt32(mFrames.Length());
     1: }
     1: 
     1: NS_IMETHODIMP nsBlinkTimer::Notify(nsITimer *timer)
     1: {
     1:   // Toggle blink state bit so that text code knows whether or not to
     1:   // render. All text code shares the same flag so that they all blink
     1:   // in unison.
     1:   sState = (sState + 1) % 4;
     1:   if (sState == 1 || sState == 2)
     1:     // States 0, 1, and 2 are all the same.
     1:     return NS_OK;
     1: 
     1: #ifdef NOISY_BLINK
     1:   PRTime now = PR_Now();
     1:   char buf[50];
     1:   PRTime delta;
     1:   LL_SUB(delta, now, gLastTick);
     1:   gLastTick = now;
     1:   PR_snprintf(buf, sizeof(buf), "%lldusec", delta);
     1:   printf("%s\n", buf);
     1: #endif
     1: 
 24551:   PRUint32 i, n = mFrames.Length();
     1:   for (i = 0; i < n; i++) {
 26081:     FrameData& frameData = mFrames.ElementAt(i);
     1: 
     1:     // Determine damaged area and tell view manager to redraw it
     1:     // blink doesn't blink outline ... I hope
 26081:     nsRect bounds(nsPoint(0, 0), frameData.mFrame->GetSize());
 26081:     frameData.mFrame->Invalidate(bounds);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // static
 72507: void nsBlinkTimer::AddBlinkFrame(nsPresContext* aPresContext, nsIFrame* aFrame)
     1: {
     1:   if (!sTextBlinker)
     1:   {
     1:     sTextBlinker = new nsBlinkTimer;
     1:   }
     1: 
     1:   NS_ADDREF(sTextBlinker);
     1: 
     1:   sTextBlinker->AddFrame(aPresContext, aFrame);
     1: }
     1: 
     1: 
     1: // static
 72507: void nsBlinkTimer::RemoveBlinkFrame(nsIFrame* aFrame)
     1: {
     1:   NS_ASSERTION(sTextBlinker, "Should have blink timer here");
     1: 
     1:   nsBlinkTimer* blinkTimer = sTextBlinker;    // copy so we can call NS_RELEASE on it
     1: 
     1:   blinkTimer->RemoveFrame(aFrame);  
     1:   NS_RELEASE(blinkTimer);
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: static nscolor
     1: EnsureDifferentColors(nscolor colorA, nscolor colorB)
     1: {
     1:   if (colorA == colorB) {
     1:     nscolor res;
     1:     res = NS_RGB(NS_GET_R(colorA) ^ 0xff,
     1:                  NS_GET_G(colorA) ^ 0xff,
     1:                  NS_GET_B(colorA) ^ 0xff);
     1:     return res;
     1:   }
     1:   return colorA;
     1: }
     1: 
     1: //-----------------------------------------------------------------------------
     1: 
     1: nsTextPaintStyle::nsTextPaintStyle(nsTextFrame* aFrame)
     1:   : mFrame(aFrame),
   280:     mPresContext(aFrame->PresContext()),
 80486:     mInitCommonColors(false),
 80486:     mInitSelectionColors(false)
     1: {
 80467:   for (PRUint32 i = 0; i < ArrayLength(mSelectionStyle); i++)
 80486:     mSelectionStyle[i].mInit = false;
     1: }
     1: 
 79445: bool
     1: nsTextPaintStyle::EnsureSufficientContrast(nscolor *aForeColor, nscolor *aBackColor)
     1: {
     1:   InitCommonColors();
     1: 
     1:   // If the combination of selection background color and frame background color
     1:   // is sufficient contrast, don't exchange the selection colors.
     1:   PRInt32 backLuminosityDifference =
     1:             NS_LUMINOSITY_DIFFERENCE(*aBackColor, mFrameBackgroundColor);
     1:   if (backLuminosityDifference >= mSufficientContrast)
 80486:     return false;
     1: 
     1:   // Otherwise, we should use the higher-contrast color for the selection
     1:   // background color.
     1:   PRInt32 foreLuminosityDifference =
     1:             NS_LUMINOSITY_DIFFERENCE(*aForeColor, mFrameBackgroundColor);
     1:   if (backLuminosityDifference < foreLuminosityDifference) {
     1:     nscolor tmpColor = *aForeColor;
     1:     *aForeColor = *aBackColor;
     1:     *aBackColor = tmpColor;
 80486:     return true;
 80486:   }
 80486:   return false;
     1: }
     1: 
     1: nscolor
     1: nsTextPaintStyle::GetTextColor()
     1: {
 75138:   return nsLayoutUtils::GetColor(mFrame, eCSSProperty_color);
     1: }
     1: 
 79445: bool
     1: nsTextPaintStyle::GetSelectionColors(nscolor* aForeColor,
     1:                                      nscolor* aBackColor)
     1: {
     1:   NS_ASSERTION(aForeColor, "aForeColor is null");
     1:   NS_ASSERTION(aBackColor, "aBackColor is null");
     1: 
     1:   if (!InitSelectionColors())
 80486:     return false;
     1: 
     1:   *aForeColor = mSelectionTextColor;
     1:   *aBackColor = mSelectionBGColor;
 80486:   return true;
     1: }
     1: 
     1: void
 16313: nsTextPaintStyle::GetHighlightColors(nscolor* aForeColor,
 16313:                                      nscolor* aBackColor)
 16313: {
 16313:   NS_ASSERTION(aForeColor, "aForeColor is null");
 16313:   NS_ASSERTION(aBackColor, "aBackColor is null");
 16313:   
 78130:   nscolor backColor =
 78130:     LookAndFeel::GetColor(LookAndFeel::eColorID_TextHighlightBackground);
 78130:   nscolor foreColor =
 78130:     LookAndFeel::GetColor(LookAndFeel::eColorID_TextHighlightForeground);
 16313:   EnsureSufficientContrast(&foreColor, &backColor);
 16313:   *aForeColor = foreColor;
 16313:   *aBackColor = backColor;
 16313: }
 16313: 
 16313: void
 69254: nsTextPaintStyle::GetURLSecondaryColor(nscolor* aForeColor)
 69254: {
 69254:   NS_ASSERTION(aForeColor, "aForeColor is null");
 69254: 
 71906:   nscolor textColor = GetTextColor();
 71906:   textColor = NS_RGBA(NS_GET_R(textColor),
 71906:                       NS_GET_G(textColor),
 71906:                       NS_GET_B(textColor),
 71906:                       (PRUint8)(255 * 0.5f));
 71906:   // Don't use true alpha color for readability.
 71906:   InitCommonColors();
 71906:   *aForeColor = NS_ComposeColors(mFrameBackgroundColor, textColor);
 69254: }
 69254: 
 69254: void
     1: nsTextPaintStyle::GetIMESelectionColors(PRInt32  aIndex,
     1:                                         nscolor* aForeColor,
     1:                                         nscolor* aBackColor)
     1: {
     1:   NS_ASSERTION(aForeColor, "aForeColor is null");
     1:   NS_ASSERTION(aBackColor, "aBackColor is null");
 26883:   NS_ASSERTION(aIndex >= 0 && aIndex < 5, "Index out of range");
 26883: 
 26883:   nsSelectionStyle* selectionStyle = GetSelectionStyle(aIndex);
 26883:   *aForeColor = selectionStyle->mTextColor;
 26883:   *aBackColor = selectionStyle->mBGColor;
     1: }
     1: 
 79445: bool
 26883: nsTextPaintStyle::GetSelectionUnderlineForPaint(PRInt32  aIndex,
     1:                                                 nscolor* aLineColor,
  4728:                                                 float*   aRelativeSize,
  4728:                                                 PRUint8* aStyle)
     1: {
     1:   NS_ASSERTION(aLineColor, "aLineColor is null");
     1:   NS_ASSERTION(aRelativeSize, "aRelativeSize is null");
 26883:   NS_ASSERTION(aIndex >= 0 && aIndex < 5, "Index out of range");
 26883: 
 26883:   nsSelectionStyle* selectionStyle = GetSelectionStyle(aIndex);
 26883:   if (selectionStyle->mUnderlineStyle == NS_STYLE_BORDER_STYLE_NONE ||
 26883:       selectionStyle->mUnderlineColor == NS_TRANSPARENT ||
 26883:       selectionStyle->mUnderlineRelativeSize <= 0.0f)
 80486:     return false;
     1: 
 26883:   *aLineColor = selectionStyle->mUnderlineColor;
 26883:   *aRelativeSize = selectionStyle->mUnderlineRelativeSize;
 26883:   *aStyle = selectionStyle->mUnderlineStyle;
 80486:   return true;
     1: }
     1: 
     1: void
     1: nsTextPaintStyle::InitCommonColors()
     1: {
     1:   if (mInitCommonColors)
     1:     return;
     1: 
 40588:   nsIFrame* bgFrame =
 40588:     nsCSSRendering::FindNonTransparentBackgroundFrame(mFrame);
 40588:   NS_ASSERTION(bgFrame, "Cannot find NonTransparentBackgroundFrame.");
 40178:   nscolor bgColor =
 40588:     bgFrame->GetVisitedDependentColor(eCSSProperty_background_color);
 19436: 
 19436:   nscolor defaultBgColor = mPresContext->DefaultBackgroundColor();
 40178:   mFrameBackgroundColor = NS_ComposeColors(defaultBgColor, bgColor);
 23494: 
 40588:   if (bgFrame->IsThemed()) {
 23494:     // Assume a native widget has sufficient contrast always
 23494:     mSufficientContrast = 0;
 80486:     mInitCommonColors = true;
 23494:     return;
 23494:   }
 23494: 
 19436:   NS_ASSERTION(NS_GET_A(defaultBgColor) == 255,
 19436:                "default background color is not opaque");
 19436: 
 78130:   nscolor defaultWindowBackgroundColor =
 78130:     LookAndFeel::GetColor(LookAndFeel::eColorID_WindowBackground);
 78130:   nscolor selectionTextColor =
 78130:     LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectForeground);
 78130:   nscolor selectionBGColor =
 78130:     LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectBackground);
     1: 
     1:   mSufficientContrast =
 32531:     NS_MIN(NS_MIN(NS_SUFFICIENT_LUMINOSITY_DIFFERENCE,
     1:                   NS_LUMINOSITY_DIFFERENCE(selectionTextColor,
     1:                                            selectionBGColor)),
     1:                   NS_LUMINOSITY_DIFFERENCE(defaultWindowBackgroundColor,
     1:                                            selectionBGColor));
     1: 
 80486:   mInitCommonColors = true;
     1: }
     1: 
 41641: static Element*
 40526: FindElementAncestorForMozSelection(nsIContent* aContent)
 40526: {
 40526:   NS_ENSURE_TRUE(aContent, nsnull);
 40526:   while (aContent && aContent->IsInNativeAnonymousSubtree()) {
 40526:     aContent = aContent->GetBindingParent();
 40526:   }
 40526:   NS_ASSERTION(aContent, "aContent isn't in non-anonymous tree?");
 41641:   while (aContent && !aContent->IsElement()) {
 40526:     aContent = aContent->GetParent();
 40526:   }
 41641:   return aContent ? aContent->AsElement() : nsnull;
     1: }
     1: 
 79445: bool
     1: nsTextPaintStyle::InitSelectionColors()
     1: {
     1:   if (mInitSelectionColors)
 80486:     return true;
     1: 
     1:   PRInt16 selectionFlags;
     1:   PRInt16 selectionStatus = mFrame->GetSelectionStatus(&selectionFlags);
     1:   if (!(selectionFlags & nsISelectionDisplay::DISPLAY_TEXT) ||
     1:       selectionStatus < nsISelectionController::SELECTION_ON) {
     1:     // Not displaying the normal selection.
     1:     // We're not caching this fact, so every call to GetSelectionColors
     1:     // will come through here. We could avoid this, but it's not really worth it.
 80486:     return false;
 80486:   }
 80486: 
 80486:   mInitSelectionColors = true;
     1: 
 21943:   nsIFrame* nonGeneratedAncestor = nsLayoutUtils::GetNonGeneratedAncestor(mFrame);
 41641:   Element* selectionElement =
 40526:     FindElementAncestorForMozSelection(nonGeneratedAncestor->GetContent());
     1: 
 41641:   if (selectionElement &&
     1:       selectionStatus == nsISelectionController::SELECTION_ON) {
     1:     nsRefPtr<nsStyleContext> sc = nsnull;
     1:     sc = mPresContext->StyleSet()->
 41641:       ProbePseudoElementStyle(selectionElement,
 35554:                               nsCSSPseudoElements::ePseudo_mozSelection,
     1:                               mFrame->GetStyleContext());
     1:     // Use -moz-selection pseudo class.
     1:     if (sc) {
 40178:       mSelectionBGColor =
 40178:         sc->GetVisitedDependentColor(eCSSProperty_background_color);
 40176:       mSelectionTextColor = sc->GetVisitedDependentColor(eCSSProperty_color);
 80486:       return true;
     1:     }
     1:   }
     1: 
 78130:   nscolor selectionBGColor =
 78130:     LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectBackground);
     1: 
     1:   if (selectionStatus == nsISelectionController::SELECTION_ATTENTION) {
 78130:     mSelectionBGColor =
 78130:       LookAndFeel::GetColor(
 78130:         LookAndFeel::eColorID_TextSelectBackgroundAttention);
     1:     mSelectionBGColor  = EnsureDifferentColors(mSelectionBGColor,
     1:                                                selectionBGColor);
     1:   } else if (selectionStatus != nsISelectionController::SELECTION_ON) {
 78130:     mSelectionBGColor =
 78130:       LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectBackgroundDisabled);
     1:     mSelectionBGColor  = EnsureDifferentColors(mSelectionBGColor,
     1:                                                selectionBGColor);
     1:   } else {
     1:     mSelectionBGColor = selectionBGColor;
     1:   }
     1: 
 78130:   mSelectionTextColor =
 78130:     LookAndFeel::GetColor(LookAndFeel::eColorID_TextSelectForeground);
     1: 
     1:   // On MacOS X, we don't exchange text color and BG color.
     1:   if (mSelectionTextColor == NS_DONT_CHANGE_COLOR) {
 93297:     nscolor frameColor = mFrame->GetVisitedDependentColor(eCSSProperty_color);
 40176:     mSelectionTextColor = EnsureDifferentColors(frameColor, mSelectionBGColor);
     1:   } else {
     1:     EnsureSufficientContrast(&mSelectionTextColor, &mSelectionBGColor);
     1:   }
 80486:   return true;
     1: }
     1: 
 26883: nsTextPaintStyle::nsSelectionStyle*
 26883: nsTextPaintStyle::GetSelectionStyle(PRInt32 aIndex)
 26883: {
 26883:   InitSelectionStyle(aIndex);
 26883:   return &mSelectionStyle[aIndex];
  4728: }
  4728: 
  4728: struct StyleIDs {
 78130:   LookAndFeel::ColorID mForeground, mBackground, mLine;
 78130:   LookAndFeel::IntID mLineStyle;
 78130:   LookAndFeel::FloatID mLineRelativeSize;
     1: };
 26883: static StyleIDs SelectionStyleIDs[] = {
 78130:   { LookAndFeel::eColorID_IMERawInputForeground,
 78130:     LookAndFeel::eColorID_IMERawInputBackground,
 78130:     LookAndFeel::eColorID_IMERawInputUnderline,
 78130:     LookAndFeel::eIntID_IMERawInputUnderlineStyle,
 78130:     LookAndFeel::eFloatID_IMEUnderlineRelativeSize },
 78130:   { LookAndFeel::eColorID_IMESelectedRawTextForeground,
 78130:     LookAndFeel::eColorID_IMESelectedRawTextBackground,
 78130:     LookAndFeel::eColorID_IMESelectedRawTextUnderline,
 78130:     LookAndFeel::eIntID_IMESelectedRawTextUnderlineStyle,
 78130:     LookAndFeel::eFloatID_IMEUnderlineRelativeSize },
 78130:   { LookAndFeel::eColorID_IMEConvertedTextForeground,
 78130:     LookAndFeel::eColorID_IMEConvertedTextBackground,
 78130:     LookAndFeel::eColorID_IMEConvertedTextUnderline,
 78130:     LookAndFeel::eIntID_IMEConvertedTextUnderlineStyle,
 78130:     LookAndFeel::eFloatID_IMEUnderlineRelativeSize },
 78130:   { LookAndFeel::eColorID_IMESelectedConvertedTextForeground,
 78130:     LookAndFeel::eColorID_IMESelectedConvertedTextBackground,
 78130:     LookAndFeel::eColorID_IMESelectedConvertedTextUnderline,
 78130:     LookAndFeel::eIntID_IMESelectedConvertedTextUnderline,
 78130:     LookAndFeel::eFloatID_IMEUnderlineRelativeSize },
 78130:   { LookAndFeel::eColorID_LAST_COLOR,
 78130:     LookAndFeel::eColorID_LAST_COLOR,
 78130:     LookAndFeel::eColorID_SpellCheckerUnderline,
 78130:     LookAndFeel::eIntID_SpellCheckerUnderlineStyle,
 78130:     LookAndFeel::eFloatID_SpellCheckerUnderlineRelativeSize }
     1: };
     1: 
     1: void
 26883: nsTextPaintStyle::InitSelectionStyle(PRInt32 aIndex)
 26883: {
 26883:   NS_ASSERTION(aIndex >= 0 && aIndex < 5, "aIndex is invalid");
 26883:   nsSelectionStyle* selectionStyle = &mSelectionStyle[aIndex];
 26883:   if (selectionStyle->mInit)
     1:     return;
     1: 
 26883:   StyleIDs* styleIDs = &SelectionStyleIDs[aIndex];
     1: 
 26883:   nscolor foreColor, backColor;
 78130:   if (styleIDs->mForeground == LookAndFeel::eColorID_LAST_COLOR) {
 26883:     foreColor = NS_SAME_AS_FOREGROUND_COLOR;
 26883:   } else {
 78130:     foreColor = LookAndFeel::GetColor(styleIDs->mForeground);
 78130:   }
 78130:   if (styleIDs->mBackground == LookAndFeel::eColorID_LAST_COLOR) {
 26883:     backColor = NS_TRANSPARENT;
 26883:   } else {
 78130:     backColor = LookAndFeel::GetColor(styleIDs->mBackground);
 26883:   }
     1: 
     1:   // Convert special color to actual color
     1:   NS_ASSERTION(foreColor != NS_TRANSPARENT,
     1:                "foreColor cannot be NS_TRANSPARENT");
     1:   NS_ASSERTION(backColor != NS_SAME_AS_FOREGROUND_COLOR,
     1:                "backColor cannot be NS_SAME_AS_FOREGROUND_COLOR");
     1:   NS_ASSERTION(backColor != NS_40PERCENT_FOREGROUND_COLOR,
     1:                "backColor cannot be NS_40PERCENT_FOREGROUND_COLOR");
     1: 
     1:   foreColor = GetResolvedForeColor(foreColor, GetTextColor(), backColor);
     1: 
     1:   if (NS_GET_A(backColor) > 0)
     1:     EnsureSufficientContrast(&foreColor, &backColor);
     1: 
 26883:   nscolor lineColor;
 26883:   float relativeSize;
 26883:   PRUint8 lineStyle;
 26883:   GetSelectionUnderline(mPresContext, aIndex,
 26883:                         &lineColor, &relativeSize, &lineStyle);
     1:   lineColor = GetResolvedForeColor(lineColor, foreColor, backColor);
     1: 
 26883:   selectionStyle->mTextColor       = foreColor;
 26883:   selectionStyle->mBGColor         = backColor;
 26883:   selectionStyle->mUnderlineColor  = lineColor;
 26883:   selectionStyle->mUnderlineStyle  = lineStyle;
 26883:   selectionStyle->mUnderlineRelativeSize = relativeSize;
 80486:   selectionStyle->mInit            = true;
 26883: }
 26883: 
 79445: /* static */ bool
 26883: nsTextPaintStyle::GetSelectionUnderline(nsPresContext* aPresContext,
 26883:                                         PRInt32 aIndex,
 26883:                                         nscolor* aLineColor,
 26883:                                         float* aRelativeSize,
 26883:                                         PRUint8* aStyle)
 26883: {
 26883:   NS_ASSERTION(aPresContext, "aPresContext is null");
 26883:   NS_ASSERTION(aRelativeSize, "aRelativeSize is null");
 26883:   NS_ASSERTION(aStyle, "aStyle is null");
 26883:   NS_ASSERTION(aIndex >= 0 && aIndex < 5, "Index out of range");
 26883: 
 26883:   StyleIDs& styleID = SelectionStyleIDs[aIndex];
 78130: 
 78130:   nscolor color = LookAndFeel::GetColor(styleID.mLine);
 78130:   PRInt32 style = LookAndFeel::GetInt(styleID.mLineStyle);
 64457:   if (style > NS_STYLE_TEXT_DECORATION_STYLE_MAX) {
 26883:     NS_ERROR("Invalid underline style value is specified");
 64457:     style = NS_STYLE_TEXT_DECORATION_STYLE_SOLID;
 26883:   }
 78130:   float size = LookAndFeel::GetFloat(styleID.mLineRelativeSize);
 26883: 
 26883:   NS_ASSERTION(size, "selection underline relative size must be larger than 0");
 26883: 
 26883:   if (aLineColor) {
 26883:     *aLineColor = color;
 26883:   }
 26883:   *aRelativeSize = size;
 64457:   *aStyle = style;
 64457: 
 64457:   return style != NS_STYLE_TEXT_DECORATION_STYLE_NONE &&
 26883:          color != NS_TRANSPARENT &&
 26883:          size > 0.0f;
     1: }
     1: 
     1: inline nscolor Get40PercentColor(nscolor aForeColor, nscolor aBackColor)
     1: {
     1:   nscolor foreColor = NS_RGBA(NS_GET_R(aForeColor),
     1:                               NS_GET_G(aForeColor),
     1:                               NS_GET_B(aForeColor),
     1:                               (PRUint8)(255 * 0.4f));
  4728:   // Don't use true alpha color for readability.
     1:   return NS_ComposeColors(aBackColor, foreColor);
     1: }
     1: 
     1: nscolor
     1: nsTextPaintStyle::GetResolvedForeColor(nscolor aColor,
     1:                                        nscolor aDefaultForeColor,
     1:                                        nscolor aBackColor)
     1: {
     1:   if (aColor == NS_SAME_AS_FOREGROUND_COLOR)
     1:     return aDefaultForeColor;
     1: 
     1:   if (aColor != NS_40PERCENT_FOREGROUND_COLOR)
     1:     return aColor;
     1: 
     1:   // Get actual background color
     1:   nscolor actualBGColor = aBackColor;
     1:   if (actualBGColor == NS_TRANSPARENT) {
     1:     InitCommonColors();
     1:     actualBGColor = mFrameBackgroundColor;
     1:   }
     1:   return Get40PercentColor(aDefaultForeColor, actualBGColor);
     1: }
     1: 
     1: //-----------------------------------------------------------------------------
     1: 
     1: #ifdef ACCESSIBILITY
 99648: already_AddRefed<Accessible>
 46338: nsTextFrame::CreateAccessible()
     1: {
  9480:   if (IsEmpty()) {
  9480:     nsAutoString renderedWhitespace;
  9480:     GetRenderedText(&renderedWhitespace, nsnull, nsnull, 0, 1);
  9480:     if (renderedWhitespace.IsEmpty()) {
 46338:       return nsnull;
  9480:     }
  9480:   }
     1: 
 61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
     1:   if (accService) {
 99295:     return accService->CreateTextLeafAccessible(mContent,
 46338:                                                 PresContext()->PresShell());
 46338:   }
 46338:   return nsnull;
     1: }
     1: #endif
     1: 
     1: 
     1: //-----------------------------------------------------------------------------
     1: NS_IMETHODIMP
     1: nsTextFrame::Init(nsIContent*      aContent,
     1:                   nsIFrame*        aParent,
     1:                   nsIFrame*        aPrevInFlow)
     1: {
     1:   NS_ASSERTION(!aPrevInFlow, "Can't be a continuation!");
     8:   NS_PRECONDITION(aContent->IsNodeOfType(nsINode::eTEXT),
     8:                   "Bogus content!");
 36903: 
 70231:   // Remove any NewlineOffsetProperty or InFlowContentLengthProperty since they
 70231:   // might be invalid if the content was modified while there was no frame
 36903:   aContent->DeleteProperty(nsGkAtoms::newline);
 70231:   if (PresContext()->BidiEnabled()) {
 70231:     aContent->DeleteProperty(nsGkAtoms::flowlength);
 70231:   }
 36903: 
 29809:   // Since our content has a frame now, this flag is no longer needed.
 29809:   aContent->UnsetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE);
 85101: 
     1:   // We're not a continuing frame.
     1:   // mContentOffset = 0; not necessary since we get zeroed out at init
  4678:   return nsFrame::Init(aContent, aParent, aPrevInFlow);
     1: }
     1: 
     1: void
 49293: nsTextFrame::ClearFrameOffsetCache()
 49293: {
 49293:   // See if we need to remove ourselves from the offset cache
 49293:   if (GetStateBits() & TEXT_IN_OFFSET_CACHE) {
 49293:     nsIFrame* primaryFrame = mContent->GetPrimaryFrame();
 49293:     if (primaryFrame) {
 49293:       // The primary frame might be null here.  For example, nsLineBox::DeleteLineList
 49293:       // just destroys the frames in order, which means that the primary frame is already
 49293:       // dead if we're a continuing text frame, in which case, all of its properties are
 49293:       // gone, and we don't need to worry about deleting this property here.
 49293:       primaryFrame->Properties().Delete(OffsetToFrameProperty());
 49293:     }
 49293:     RemoveStateBits(TEXT_IN_OFFSET_CACHE);
 49293:   }
 49293: }
 49293: 
 49293: void
 36647: nsTextFrame::DestroyFrom(nsIFrame* aDestructRoot)
     1: {
 49293:   ClearFrameOffsetCache();
 49293: 
 29809:   // We might want to clear NS_CREATE_FRAME_IF_NON_WHITESPACE or
 29809:   // NS_REFRAME_IF_WHITESPACE on mContent here, since our parent frame
 29809:   // type might be changing.  Not clear whether it's worth it.
 82675:   ClearTextRuns();
     1:   if (mNextContinuation) {
     1:     mNextContinuation->SetPrevInFlow(nsnull);
     1:   }
     1:   // Let the base class destroy the frame
 36647:   nsFrame::DestroyFrom(aDestructRoot);
     1: }
     1: 
     1: class nsContinuingTextFrame : public nsTextFrame {
     1: public:
 32423:   NS_DECL_FRAMEARENA_HELPERS
 32423: 
     1:   friend nsIFrame* NS_NewContinuingTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1:   NS_IMETHOD Init(nsIContent*      aContent,
     1:                   nsIFrame*        aParent,
     1:                   nsIFrame*        aPrevInFlow);
     1: 
 36647:   virtual void DestroyFrom(nsIFrame* aDestructRoot);
     1: 
     1:   virtual nsIFrame* GetPrevContinuation() const {
     1:     return mPrevContinuation;
     1:   }
     1:   NS_IMETHOD SetPrevContinuation(nsIFrame* aPrevContinuation) {
     1:     NS_ASSERTION (!aPrevContinuation || GetType() == aPrevContinuation->GetType(),
     1:                   "setting a prev continuation with incorrect type!");
     1:     NS_ASSERTION (!nsSplittableFrame::IsInPrevContinuationChain(aPrevContinuation, this),
     1:                   "creating a loop in continuation chain!");
     1:     mPrevContinuation = aPrevContinuation;
     1:     RemoveStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
     1:     return NS_OK;
     1:   }
     1:   virtual nsIFrame* GetPrevInFlowVirtual() const { return GetPrevInFlow(); }
     1:   nsIFrame* GetPrevInFlow() const {
     1:     return (GetStateBits() & NS_FRAME_IS_FLUID_CONTINUATION) ? mPrevContinuation : nsnull;
     1:   }
     1:   NS_IMETHOD SetPrevInFlow(nsIFrame* aPrevInFlow) {
     1:     NS_ASSERTION (!aPrevInFlow || GetType() == aPrevInFlow->GetType(),
     1:                   "setting a prev in flow with incorrect type!");
     1:     NS_ASSERTION (!nsSplittableFrame::IsInPrevContinuationChain(aPrevInFlow, this),
     1:                   "creating a loop in continuation chain!");
     1:     mPrevContinuation = aPrevInFlow;
     1:     AddStateBits(NS_FRAME_IS_FLUID_CONTINUATION);
     1:     return NS_OK;
     1:   }
     1:   virtual nsIFrame* GetFirstInFlow() const;
     1:   virtual nsIFrame* GetFirstContinuation() const;
     1: 
 68481:   virtual void AddInlineMinWidth(nsRenderingContext *aRenderingContext,
     1:                                  InlineMinWidthData *aData);
 68481:   virtual void AddInlinePrefWidth(nsRenderingContext *aRenderingContext,
     1:                                   InlinePrefWidthData *aData);
     1:   
  4261:   virtual nsresult GetRenderedText(nsAString* aString = nsnull,
  4261:                                    gfxSkipChars* aSkipChars = nsnull,
  4261:                                    gfxSkipCharsIterator* aSkipIter = nsnull,
  4261:                                    PRUint32 aSkippedStartOffset = 0,
  4261:                                    PRUint32 aSkippedMaxLength = PR_UINT32_MAX)
  4261:   { return NS_ERROR_NOT_IMPLEMENTED; } // Call on a primary text frame only
  4261: 
     1: protected:
     1:   nsContinuingTextFrame(nsStyleContext* aContext) : nsTextFrame(aContext) {}
     1:   nsIFrame* mPrevContinuation;
     1: };
     1: 
     1: NS_IMETHODIMP
     1: nsContinuingTextFrame::Init(nsIContent* aContent,
     1:                             nsIFrame*   aParent,
     1:                             nsIFrame*   aPrevInFlow)
     1: {
     1:   NS_ASSERTION(aPrevInFlow, "Must be a continuation!");
     1:   // NOTE: bypassing nsTextFrame::Init!!!
 26295:   nsresult rv = nsFrame::Init(aContent, aParent, aPrevInFlow);
     1: 
  9810: #ifdef IBMBIDI
  9810:   nsTextFrame* nextContinuation =
  9810:     static_cast<nsTextFrame*>(aPrevInFlow->GetNextContinuation());
  9810: #endif // IBMBIDI
     1:   // Hook the frame into the flow
  4104:   SetPrevInFlow(aPrevInFlow);
  4104:   aPrevInFlow->SetNextInFlow(this);
  3233:   nsTextFrame* prev = static_cast<nsTextFrame*>(aPrevInFlow);
  4678:   mContentOffset = prev->GetContentOffset() + prev->GetContentLengthHint();
 35581:   NS_ASSERTION(mContentOffset < PRInt32(aContent->GetText()->GetLength()),
  9001:                "Creating ContinuingTextFrame, but there is no more content");
  4678:   if (prev->GetStyleContext() != GetStyleContext()) {
  4678:     // We're taking part of prev's text, and its style may be different
  4678:     // so clear its textrun which may no longer be valid (and don't set ours)
 82675:     prev->ClearTextRuns();
  4678:   } else {
 82675:     float inflation = prev->GetFontSizeInflation();
 82675:     SetFontSizeInflation(inflation);
 82675:     mTextRun = prev->GetTextRun(nsTextFrame::eInflated);
 82675:     if (inflation != 1.0f) {
 82675:       gfxTextRun *uninflatedTextRun =
 82675:         prev->GetTextRun(nsTextFrame::eNotInflated);
 82675:       if (uninflatedTextRun) {
 82675:         SetTextRun(uninflatedTextRun, nsTextFrame::eNotInflated, 1.0f);
 82675:       }
 82675:     }
  4678:   }
     1: #ifdef IBMBIDI
  4104:   if (aPrevInFlow->GetStateBits() & NS_FRAME_IS_BIDI) {
 39965:     FramePropertyTable *propTable = PresContext()->PropertyTable();
 39965:     // Get all the properties from the prev-in-flow first to take
 39965:     // advantage of the propTable's cache and simplify the assertion below
 39965:     void* embeddingLevel = propTable->Get(aPrevInFlow, EmbeddingLevelProperty());
 39965:     void* baseLevel = propTable->Get(aPrevInFlow, BaseLevelProperty());
 93532:     void* paragraphDepth = propTable->Get(aPrevInFlow, ParagraphDepthProperty());
 39965:     propTable->Set(this, EmbeddingLevelProperty(), embeddingLevel);
 39965:     propTable->Set(this, BaseLevelProperty(), baseLevel);
 93532:     propTable->Set(this, ParagraphDepthProperty(), paragraphDepth);
 39965: 
     1:     if (nextContinuation) {
     1:       SetNextContinuation(nextContinuation);
     1:       nextContinuation->SetPrevContinuation(this);
  9810:       // Adjust next-continuations' content offset as needed.
  9810:       while (nextContinuation &&
  9810:              nextContinuation->GetContentOffset() < mContentOffset) {
  9810:         NS_ASSERTION(
 39965:           embeddingLevel == propTable->Get(nextContinuation, EmbeddingLevelProperty()) &&
 93532:           baseLevel == propTable->Get(nextContinuation, BaseLevelProperty()) &&
 93532:           paragraphDepth == propTable->Get(nextContinuation, ParagraphDepthProperty()),
  9810:           "stealing text from different type of BIDI continuation");
  9810:         nextContinuation->mContentOffset = mContentOffset;
  9810:         nextContinuation = static_cast<nsTextFrame*>(nextContinuation->GetNextContinuation());
  9810:       }
     1:     }
     1:     mState |= NS_FRAME_IS_BIDI;
     1:   } // prev frame is bidi
     1: #endif // IBMBIDI
     1: 
     1:   return rv;
     1: }
     1: 
     1: void
 36647: nsContinuingTextFrame::DestroyFrom(nsIFrame* aDestructRoot)
     1: {
 49293:   ClearFrameOffsetCache();
 49293: 
 22875:   // The text associated with this frame will become associated with our
 22875:   // prev-continuation. If that means the text has changed style, then
 22875:   // we need to wipe out the text run for the text.
 22875:   // Note that mPrevContinuation can be null if we're destroying the whole
 22875:   // frame chain from the start to the end.
 22875:   // If this frame is mentioned in the userData for a textrun (say
 22875:   // because there's a direction change at the start of this frame), then
 22875:   // we have to clear the textrun because we're going away and the
 22875:   // textrun had better not keep a dangling reference to us.
 22875:   if ((GetStateBits() & TEXT_IN_TEXTRUN_USER_DATA) ||
 77246:       (!mPrevContinuation &&
 77246:        !(GetStateBits() & TEXT_STYLE_MATCHES_PREV_CONTINUATION)) ||
 77246:       (mPrevContinuation &&
 77246:        mPrevContinuation->GetStyleContext() != GetStyleContext())) {
 82675:     ClearTextRuns();
 27927:     // Clear the previous continuation's text run also, so that it can rebuild
 27927:     // the text run to include our text.
 27927:     if (mPrevContinuation) {
 82675:       nsTextFrame *prevContinuationText =
 82675:         static_cast<nsTextFrame*>(mPrevContinuation);
 82675:       prevContinuationText->ClearTextRuns();
 27927:     }
 22875:   }
     1:   nsSplittableFrame::RemoveFromFlow(this);
     1:   // Let the base class destroy the frame
 36647:   nsFrame::DestroyFrom(aDestructRoot);
     1: }
     1: 
     1: nsIFrame*
     1: nsContinuingTextFrame::GetFirstInFlow() const
     1: {
     1:   // Can't cast to |nsContinuingTextFrame*| because the first one isn't.
     1:   nsIFrame *firstInFlow,
  3233:            *previous = const_cast<nsIFrame*>
  3233:                                  (static_cast<const nsIFrame*>(this));
     1:   do {
     1:     firstInFlow = previous;
     1:     previous = firstInFlow->GetPrevInFlow();
     1:   } while (previous);
     1:   return firstInFlow;
     1: }
     1: 
     1: nsIFrame*
     1: nsContinuingTextFrame::GetFirstContinuation() const
     1: {
     1:   // Can't cast to |nsContinuingTextFrame*| because the first one isn't.
     1:   nsIFrame *firstContinuation,
  3233:   *previous = const_cast<nsIFrame*>
  3233:                         (static_cast<const nsIFrame*>(mPrevContinuation));
 14508: 
 14508:   NS_ASSERTION(previous, "How can an nsContinuingTextFrame be the first continuation?");
 14508: 
     1:   do {
     1:     firstContinuation = previous;
     1:     previous = firstContinuation->GetPrevContinuation();
     1:   } while (previous);
     1:   return firstContinuation;
     1: }
     1: 
     1: // XXX Do we want to do all the work for the first-in-flow or do the
     1: // work for each part?  (Be careful of first-letter / first-line, though,
     1: // especially first-line!)  Doing all the work on the first-in-flow has
     1: // the advantage of avoiding the potential for incremental reflow bugs,
     1: // but depends on our maintining the frame tree in reasonable ways even
     1: // for edge cases (block-within-inline splits, nextBidi, etc.)
     1: 
     1: // XXX We really need to make :first-letter happen during frame
     1: // construction.
     1: 
     1: // Needed for text frames in XUL.
     1: /* virtual */ nscoord
 68481: nsTextFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   return nsLayoutUtils::MinWidthFromInline(this, aRenderingContext);
     1: }
     1: 
     1: // Needed for text frames in XUL.
     1: /* virtual */ nscoord
 68481: nsTextFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   return nsLayoutUtils::PrefWidthFromInline(this, aRenderingContext);
     1: }
     1: 
     1: /* virtual */ void
 68481: nsContinuingTextFrame::AddInlineMinWidth(nsRenderingContext *aRenderingContext,
     1:                                          InlineMinWidthData *aData)
     1: {
     1:   // Do nothing, since the first-in-flow accounts for everything.
     1:   return;
     1: }
     1: 
     1: /* virtual */ void
 68481: nsContinuingTextFrame::AddInlinePrefWidth(nsRenderingContext *aRenderingContext,
     1:                                           InlinePrefWidthData *aData)
     1: {
     1:   // Do nothing, since the first-in-flow accounts for everything.
     1:   return;
     1: }
     1: 
     1: static void 
     1: DestroySelectionDetails(SelectionDetails* aDetails)
     1: {
     1:   while (aDetails) {
     1:     SelectionDetails* next = aDetails->mNext;
     1:     delete aDetails;
     1:     aDetails = next;
     1:   }
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: #if defined(DEBUG_rbs) || defined(DEBUG_bzbarsky)
     1: static void
     1: VerifyNotDirty(nsFrameState state)
     1: {
 79445:   bool isZero = state & NS_FRAME_FIRST_REFLOW;
 79445:   bool isDirty = state & NS_FRAME_IS_DIRTY;
     1:   if (!isZero && isDirty)
     1:     NS_WARNING("internal offsets may be out-of-sync");
     1: }
     1: #define DEBUG_VERIFY_NOT_DIRTY(state) \
     1: VerifyNotDirty(state)
     1: #else
     1: #define DEBUG_VERIFY_NOT_DIRTY(state)
     1: #endif
     1: 
     1: nsIFrame*
     1: NS_NewTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsTextFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsTextFrame)
 32423: 
     1: nsIFrame*
     1: NS_NewContinuingTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsContinuingTextFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsContinuingTextFrame)
 32423: 
     1: nsTextFrame::~nsTextFrame()
     1: {
 35581:   if (0 != (mState & TEXT_BLINK_ON))
     1:   {
     1:     nsBlinkTimer::RemoveBlinkFrame(this);
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextFrame::GetCursor(const nsPoint& aPoint,
     1:                        nsIFrame::Cursor& aCursor)
     1: {
     1:   FillCursorInformationFromStyle(GetStyleUserInterface(), aCursor);  
     1:   if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
     1:     aCursor.mCursor = NS_STYLE_CURSOR_TEXT;
     1: 
     1:     // If tabindex >= 0, use default cursor to indicate it's not selectable
     1:     nsIFrame *ancestorFrame = this;
     1:     while ((ancestorFrame = ancestorFrame->GetParent()) != nsnull) {
     1:       nsIContent *ancestorContent = ancestorFrame->GetContent();
     1:       if (ancestorContent && ancestorContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
     1:         nsAutoString tabIndexStr;
     1:         ancestorContent->GetAttr(kNameSpaceID_None, nsGkAtoms::tabindex, tabIndexStr);
     1:         if (!tabIndexStr.IsEmpty()) {
     1:           PRInt32 rv, tabIndexVal = tabIndexStr.ToInteger(&rv);
     1:           if (NS_SUCCEEDED(rv) && tabIndexVal >= 0) {
     1:             aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
     1:             break;
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsIFrame*
     1: nsTextFrame::GetLastInFlow() const
     1: {
  3233:   nsTextFrame* lastInFlow = const_cast<nsTextFrame*>(this);
     1:   while (lastInFlow->GetNextInFlow())  {
  3233:     lastInFlow = static_cast<nsTextFrame*>(lastInFlow->GetNextInFlow());
     1:   }
     1:   NS_POSTCONDITION(lastInFlow, "illegal state in flow chain.");
     1:   return lastInFlow;
     1: }
     1: nsIFrame*
     1: nsTextFrame::GetLastContinuation() const
     1: {
  3233:   nsTextFrame* lastInFlow = const_cast<nsTextFrame*>(this);
     1:   while (lastInFlow->mNextContinuation)  {
  3233:     lastInFlow = static_cast<nsTextFrame*>(lastInFlow->mNextContinuation);
     1:   }
     1:   NS_POSTCONDITION(lastInFlow, "illegal state in continuation chain.");
     1:   return lastInFlow;
     1: }
     1: 
 82675: gfxTextRun*
 82675: nsTextFrame::GetUninflatedTextRun()
 82675: {
 82675:   return static_cast<gfxTextRun*>(
 82675:            Properties().Get(UninflatedTextRunProperty()));
 82675: }
 82675: 
     1: void
 82675: nsTextFrame::SetTextRun(gfxTextRun* aTextRun, TextRunType aWhichTextRun,
 82675:                         float aInflation)
 82675: {
 82675:   NS_ASSERTION(aTextRun, "must have text run");
 82675: 
 82675:   // Our inflated text run is always stored in mTextRun.  In the cases
 82675:   // where our current inflation is not 1.0, however, we store two text
 82675:   // runs, and the uninflated one goes in a frame property.  We never
 82675:   // store a single text run in both.
 82675:   if (aWhichTextRun == eInflated) {
 82675:     if (HasFontSizeInflation() && aInflation == 1.0f) {
 82675:       // FIXME: Probably shouldn't do this within each SetTextRun
 82675:       // method, but it doesn't hurt.
 82675:       ClearTextRun(nsnull, nsTextFrame::eNotInflated);
 82675:     }
 82675:     SetFontSizeInflation(aInflation);
 82675:   } else {
 82675:     NS_ABORT_IF_FALSE(aInflation == 1.0f, "unexpected inflation");
 82675:     if (HasFontSizeInflation()) {
 82675:       Properties().Set(UninflatedTextRunProperty(), aTextRun);
 82675:       return;
 82675:     }
 82675:     // fall through to setting mTextRun
 82675:   }
 82675: 
 82675:   mTextRun = aTextRun;
 82675: 
 82675:   // FIXME: Add assertions testing the relationship between
 82675:   // GetFontSizeInflation() and whether we have an uninflated text run
 82675:   // (but be aware that text runs can go away).
 82675: }
 82675: 
 82675: bool
 82675: nsTextFrame::RemoveTextRun(gfxTextRun* aTextRun)
 82675: {
 82675:   if (aTextRun == mTextRun) {
 82675:     mTextRun = nsnull;
 82675:     return true;
 82675:   }
 82675:   FrameProperties props = Properties();
 82675:   if ((GetStateBits() & TEXT_HAS_FONT_INFLATION) &&
 82675:       props.Get(UninflatedTextRunProperty()) == aTextRun) {
 82675:     props.Delete(UninflatedTextRunProperty());
 82675:     return true;
 82675:   }
 82675:   return false;
 82675: }
 82675: 
 82675: void
 82675: nsTextFrame::ClearTextRun(nsTextFrame* aStartContinuation,
 82675:                           TextRunType aWhichTextRun)
 55835: {
 82675:   gfxTextRun* textRun = GetTextRun(aWhichTextRun);
 99221:   if (!textRun) {
     1:     return;
 99221:   }
 99221: 
 99221:   DebugOnly<bool> checkmTextrun = textRun == mTextRun;
 55835:   UnhookTextRunFromFrames(textRun, aStartContinuation);
 99221:   MOZ_ASSERT(checkmTextrun ? !mTextRun
 99221:                            : !Properties().Get(UninflatedTextRunProperty()));
 99221: 
  2319:   // see comments in BuildTextRunForFrames...
  2319: //  if (textRun->GetFlags() & gfxFontGroup::TEXT_IS_PERSISTENT) {
  2319: //    NS_ERROR("Shouldn't reach here for now...");
  2319: //    // the textrun's text may be referencing a DOM node that has changed,
  2319: //    // so we'd better kill this textrun now.
  2319: //    if (textRun->GetExpirationState()->IsTracked()) {
  2319: //      gTextRuns->RemoveFromCache(textRun);
  2319: //    }
  2319: //    delete textRun;
  2319: //    return;
  2319: //  }
  2319: 
 86690:   if (!textRun->GetUserData()) {
  2319:     // Remove it now because it's not doing anything useful
  1328:     gTextRuns->RemoveFromCache(textRun);
  1328:     delete textRun;
  1328:   }
     1: }
     1: 
     1: NS_IMETHODIMP
 31131: nsTextFrame::CharacterDataChanged(CharacterDataChangeInfo* aInfo)
     1: {
 36903:   mContent->DeleteProperty(nsGkAtoms::newline);
 70231:   if (PresContext()->BidiEnabled()) {
 70231:     mContent->DeleteProperty(nsGkAtoms::flowlength);
 70231:   }
 36903: 
 34012:   // Find the first frame whose text has changed. Frames that are entirely
 34012:   // before the text change are completely unaffected.
 34012:   nsTextFrame* next;
 34012:   nsTextFrame* textFrame = this;
 80486:   while (true) {
 34012:     next = static_cast<nsTextFrame*>(textFrame->GetNextContinuation());
 34012:     if (!next || next->GetContentOffset() > PRInt32(aInfo->mChangeStart))
 34012:       break;
 34012:     textFrame = next;
 34012:   }
 34012: 
 34012:   PRInt32 endOfChangedText = aInfo->mChangeStart + aInfo->mReplaceLength;
 34012:   nsTextFrame* lastDirtiedFrame = nsnull;
 34012: 
 34012:   nsIPresShell* shell = PresContext()->GetPresShell();
 34012:   do {
 34012:     // textFrame contained deleted text (or the insertion point,
 34012:     // if this was a pure insertion).
 34012:     textFrame->mState &= ~TEXT_WHITESPACE_FLAGS;
 82675:     textFrame->ClearTextRuns();
 34012:     if (!lastDirtiedFrame ||
 34012:         lastDirtiedFrame->GetParent() != textFrame->GetParent()) {
 34012:       // Ask the parent frame to reflow me.
 34012:       shell->FrameNeedsReflow(textFrame, nsIPresShell::eStyleChange,
 34012:                               NS_FRAME_IS_DIRTY);
 34012:       lastDirtiedFrame = textFrame;
 31144:     } else {
 34012:       // if the parent is a block, we're cheating here because we should
 34012:       // be marking our line dirty, but we're not. nsTextFrame::SetLength
 34012:       // will do that when it gets called during reflow.
 34012:       textFrame->AddStateBits(NS_FRAME_IS_DIRTY);
 34012:     }
 34012: 
 34012:     // Below, frames that start after the deleted text will be adjusted so that
 34012:     // their offsets move with the trailing unchanged text. If this change
 34012:     // deletes more text than it inserts, those frame offsets will decrease.
 34012:     // We need to maintain the invariant that mContentOffset is non-decreasing
 34012:     // along the continuation chain. So we need to ensure that frames that
 34012:     // started in the deleted text are all still starting before the
 34012:     // unchanged text.
 34012:     if (textFrame->mContentOffset > endOfChangedText) {
 34012:       textFrame->mContentOffset = endOfChangedText;
 34012:     }
 34012: 
 31144:     textFrame = static_cast<nsTextFrame*>(textFrame->GetNextContinuation());
 34012:   } while (textFrame && textFrame->GetContentOffset() < PRInt32(aInfo->mChangeEnd));
 34012: 
 34012:   // This is how much the length of the string changed by --- i.e.,
 34012:   // how much the trailing unchanged text moved.
 34012:   PRInt32 sizeChange =
 34012:     aInfo->mChangeStart + aInfo->mReplaceLength - aInfo->mChangeEnd;
 34012: 
 34012:   if (sizeChange) {
 34012:     // Fix the offsets of the text frames that start in the trailing
 34012:     // unchanged text.
 34012:     while (textFrame) {
 34012:       textFrame->mContentOffset += sizeChange;
 34012:       // XXX we could rescue some text runs by adjusting their user data
 34012:       // to reflect the change in DOM offsets
 82675:       textFrame->ClearTextRuns();
 34012:       textFrame = static_cast<nsTextFrame*>(textFrame->GetNextContinuation());
 34012:     }
 34012:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 20441: /* virtual */ void
 20836: nsTextFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 20836: {
 20836:   nsFrame::DidSetStyleContext(aOldStyleContext);
 82675:   ClearTextRuns();
     1: } 
     1: 
 72260: class nsDisplayText : public nsCharClipDisplayItem {
     1: public:
 51260:   nsDisplayText(nsDisplayListBuilder* aBuilder, nsTextFrame* aFrame) :
 72260:     nsCharClipDisplayItem(aBuilder, aFrame),
 80486:     mDisableSubpixelAA(false) {
     1:     MOZ_COUNT_CTOR(nsDisplayText);
     1:   }
     1: #ifdef NS_BUILD_REFCNT_LOGGING
     1:   virtual ~nsDisplayText() {
     1:     MOZ_COUNT_DTOR(nsDisplayText);
     1:   }
     1: #endif
     1: 
 95051:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
 95051:     *aSnap = false;
 80733:     return mFrame->GetVisualOverflowRectRelativeToSelf() + ToReferenceFrame();
     1:   }
 40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
 40570:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames) {
 51261:     if (nsRect(ToReferenceFrame(), mFrame->GetSize()).Intersects(aRect)) {
 40570:       aOutFrames->AppendElement(mFrame);
 40570:     }
  6247:   }
 33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
 68481:                      nsRenderingContext* aCtx);
 47732:   NS_DISPLAY_DECL_NAME("Text", TYPE_TEXT)
 55291: 
 59781:   virtual nsRect GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder)
 59781:   {
 95051:     bool snap;
 95051:     return GetBounds(aBuilder, &snap);
 59781:   }
 59778: 
 80486:   virtual void DisableComponentAlpha() { mDisableSubpixelAA = true; }
 59778: 
 79445:   bool mDisableSubpixelAA;
     1: };
     1: 
     1: void
     1: nsDisplayText::Paint(nsDisplayListBuilder* aBuilder,
 68481:                      nsRenderingContext* aCtx) {
 96794:   SAMPLE_LABEL("nsDisplayText", "Paint");
 33368:   // Add 1 pixel of dirty area around mVisibleRect to allow us to paint
 33368:   // antialiased pixels beyond the measured text extents.
 33368:   // This is temporary until we do this in the actual calculation of text extents.
 33368:   nsRect extraVisible = mVisibleRect;
 33368:   nscoord appUnitsPerDevPixel = mFrame->PresContext()->AppUnitsPerDevPixel();
 33368:   extraVisible.Inflate(appUnitsPerDevPixel, appUnitsPerDevPixel);
 59778:   nsTextFrame* f = static_cast<nsTextFrame*>(mFrame);
 59778: 
 59778:   gfxContextAutoDisableSubpixelAntialiasing disable(aCtx->ThebesContext(),
 59778:                                                     mDisableSubpixelAA);
 72260:   NS_ASSERTION(mLeftEdge >= 0, "illegal left edge");
 72260:   NS_ASSERTION(mRightEdge >= 0, "illegal right edge");
 72260:   f->PaintText(aCtx, ToReferenceFrame(), extraVisible, *this);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                               const nsRect&           aDirtyRect,
     1:                               const nsDisplayListSet& aLists)
     1: {
     1:   if (!IsVisibleForPainting(aBuilder))
     1:     return NS_OK;
     1:   
     1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsTextFrame");
     1: 
 35581:   if ((0 != (mState & TEXT_BLINK_ON)) && nsBlinkTimer::GetBlinkIsOff() &&
 29529:       PresContext()->IsDynamic() && !aBuilder->IsForEventDelivery())
     1:     return NS_OK;
     1:     
 51260:   return aLists.Content()->AppendNewToTop(
 51260:       new (aBuilder) nsDisplayText(aBuilder, this));
     1: }
     1: 
     8: static nsIFrame*
 79445: GetGeneratedContentOwner(nsIFrame* aFrame, bool* aIsBefore)
     1: {
 80486:   *aIsBefore = false;
     8:   while (aFrame && (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT)) {
 34387:     if (aFrame->GetStyleContext()->GetPseudo() == nsCSSPseudoElements::before) {
 80486:       *aIsBefore = true;
     8:     }
     8:     aFrame = aFrame->GetParent();
     8:   }
     8:   return aFrame;
     1: }
     1: 
     1: SelectionDetails*
     1: nsTextFrame::GetSelectionDetails()
     1: {
  8295:   const nsFrameSelection* frameSelection = GetConstFrameSelection();
 85101:   if (frameSelection->GetTableCellSelection()) {
 85101:     return nsnull;
 85101:   }
     8:   if (!(GetStateBits() & NS_FRAME_GENERATED_CONTENT)) {
     8:     SelectionDetails* details =
  8295:       frameSelection->LookUpSelection(mContent, GetContentOffset(),
 80486:                                       GetContentLength(), false);
     8:     SelectionDetails* sd;
     8:     for (sd = details; sd; sd = sd->mNext) {
     8:       sd->mStart += mContentOffset;
     8:       sd->mEnd += mContentOffset;
     8:     }
     8:     return details;
     8:   }
     8: 
     8:   // Check if the beginning or end of the element is selected, depending on
     8:   // whether we're :before content or :after content.
 79445:   bool isBefore;
     8:   nsIFrame* owner = GetGeneratedContentOwner(this, &isBefore);
     8:   if (!owner || !owner->GetContent())
     8:     return nsnull;
     8: 
     8:   SelectionDetails* details =
  8295:     frameSelection->LookUpSelection(owner->GetContent(),
 80486:         isBefore ? 0 : owner->GetContent()->GetChildCount(), 0, false);
     8:   SelectionDetails* sd;
     8:   for (sd = details; sd; sd = sd->mNext) {
     8:     // The entire text is selected!
  3118:     sd->mStart = GetContentOffset();
  3118:     sd->mEnd = GetContentEnd();
     8:   }
     8:   return details;
     1: }
     1: 
     1: static void
     1: FillClippedRect(gfxContext* aCtx, nsPresContext* aPresContext,
     1:                 nscolor aColor, const gfxRect& aDirtyRect, const gfxRect& aRect)
     1: {
     1:   gfxRect r = aRect.Intersect(aDirtyRect);
     1:   // For now, we need to put this in pixel coordinates
  5147:   PRInt32 app = aPresContext->AppUnitsPerDevPixel();
     1:   aCtx->NewPath();
     1:   // pixel-snap
  5147:   aCtx->Rectangle(gfxRect(r.X() / app, r.Y() / app,
 80486:                           r.Width() / app, r.Height() / app), true);
     1:   aCtx->SetColor(gfxRGBA(aColor));
     1:   aCtx->Fill();
     1: }
     1: 
 74792: void
 74792: nsTextFrame::GetTextDecorations(nsPresContext* aPresContext,
 74792:                                 nsTextFrame::TextDecorations& aDecorations)
 74792: {
 57980:   const nsCompatibility compatMode = aPresContext->CompatibilityMode();
     1: 
 79445:   bool useOverride = false;
     1:   nscolor overrideColor;
     1: 
 74792:   // frameTopOffset represents the offset to f's top from our baseline in our
 74792:   // coordinate space
 74792:   // baselineOffset represents the offset from our baseline to f's baseline or
 74792:   // the nearest block's baseline, in our coordinate space, whichever is closest
 74792:   // during the particular iteration
 74792:   nscoord frameTopOffset = mAscent,
 74792:           baselineOffset = 0;
 74792: 
 74792:   bool nearestBlockFound = false;
 74792: 
 75236:   for (nsIFrame* f = this, *fChild = nsnull;
 75236:        f;
 75236:        fChild = f,
101446:        f = nsLayoutUtils::GetParentOrPlaceholderFor(f))
 75236:   {
 74792:     nsStyleContext *const context = f->GetStyleContext();
 68819:     if (!context->HasTextDecorationLines()) {
 57980:       break;
 57980:     }
 74792: 
 74792:     const nsStyleTextReset *const styleText = context->GetStyleTextReset();
 74792:     const PRUint8 textDecorations = styleText->mTextDecorationLine;
 74792: 
     1:     if (!useOverride &&
 75138:         (NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL & textDecorations)) {
     1:       // This handles the <a href="blah.html"><font color="green">La 
     1:       // la la</font></a> case. The link underline should be green.
 80486:       useOverride = true;
 75138:       overrideColor =
 75138:         nsLayoutUtils::GetColor(f, eCSSProperty_text_decoration_color);
     1:     }
     1: 
 75236:     const bool firstBlock = !nearestBlockFound && nsLayoutUtils::GetAsBlock(f);
 74792: 
 74792:     // Not updating positions once we hit a parent block is equivalent to
 74792:     // the CSS 2.1 spec that blocks should propagate decorations down to their
 74792:     // children (albeit the style should be preserved)
 74792:     // However, if we're vertically aligned within a block, then we need to
 74792:     // recover the right baseline from the line by querying the FrameProperty
 74792:     // that should be set (see nsLineLayout::VerticalAlignLine).
 75236:     if (firstBlock) {
 75236:       // At this point, fChild can't be null since TextFrames can't be blocks
 75236:       const nsStyleCoord& vAlign =
 75236:         fChild->GetStyleContext()->GetStyleTextReset()->mVerticalAlign;
 75236:       if (vAlign.GetUnit() != eStyleUnit_Enumerated ||
 75236:           vAlign.GetIntValue() != NS_STYLE_VERTICAL_ALIGN_BASELINE)
 75236:       {
 75236:         // Since offset is the offset in the child's coordinate space, we have
 75236:         // to undo the accumulation to bring the transform out of the block's
 75236:         // coordinate space
 75236:         baselineOffset =
 75236:           frameTopOffset - (fChild->GetRect().y - fChild->GetRelativeOffset().y)
 75236:           - NS_PTR_TO_INT32(
 75236:               fChild->Properties().Get(nsIFrame::LineBaselineOffset()));
 75236:       }
 74792:     }
 74792:     else if (!nearestBlockFound) {
 74792:       baselineOffset = frameTopOffset - f->GetBaseline();
 74792:     }
 74792: 
 74792:     nearestBlockFound = nearestBlockFound || firstBlock;
 75236:     frameTopOffset += f->GetRect().y - f->GetRelativeOffset().y;
 74792: 
 74792:     const PRUint8 style = styleText->GetDecorationStyle();
 74792:     // Accumulate only elements that have decorations with a genuine style
 74792:     if (textDecorations && style != NS_STYLE_TEXT_DECORATION_STYLE_NONE) {
 74792:       const nscolor color = useOverride ? overrideColor
 75138:         : nsLayoutUtils::GetColor(f, eCSSProperty_text_decoration_color);
 74792: 
 74792:       if (textDecorations & NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE) {
 74792:         aDecorations.mUnderlines.AppendElement(
 75138:           nsTextFrame::LineDecoration(f, baselineOffset, color, style));
 74792:       }
 74792:       if (textDecorations & NS_STYLE_TEXT_DECORATION_LINE_OVERLINE) {
 74792:         aDecorations.mOverlines.AppendElement(
 75138:           nsTextFrame::LineDecoration(f, baselineOffset, color, style));
 74792:       }
 74792:       if (textDecorations & NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH) {
 74792:         aDecorations.mStrikes.AppendElement(
 75138:           nsTextFrame::LineDecoration(f, baselineOffset, color, style));
 11780:       }
 11780:     }
 57980: 
 57980:     // In all modes, if we're on an inline-block or inline-table (or
 57980:     // inline-stack, inline-box, inline-grid), we're done.
 57980:     const nsStyleDisplay *disp = context->GetStyleDisplay();
 57980:     if (disp->mDisplay != NS_STYLE_DISPLAY_INLINE &&
 57980:         disp->IsInlineOutside()) {
 57980:       break;
 57980:     }
 57980: 
 57980:     if (compatMode == eCompatibility_NavQuirks) {
 57980:       // In quirks mode, if we're on an HTML table element, we're done.
 57980:       if (f->GetContent()->IsHTML(nsGkAtoms::table)) {
 57980:         break;
 57980:       }
 57980:     } else {
 57980:       // In standards/almost-standards mode, if we're on an
 57980:       // absolutely-positioned element or a floating element, we're done.
 57980:       if (disp->IsFloating() || disp->IsAbsolutelyPositioned()) {
 57980:         break;
 57980:       }
 57980:     }
 11780:   }
 11780: }
 11780: 
 11780: void
 74792: nsTextFrame::UnionAdditionalOverflow(nsPresContext* aPresContext,
 82674:                                      const nsHTMLReflowState& aBlockReflowState,
 14210:                                      PropertyProvider& aProvider,
 74792:                                      nsRect* aVisualOverflowRect,
 74792:                                      bool aIncludeTextDecorations)
 11780: {
 15339:   // Text-shadow overflows
 55028:   nsRect shadowRect =
 55028:     nsLayoutUtils::GetTextShadowRectsUnion(*aVisualOverflowRect, this);
 55028:   aVisualOverflowRect->UnionRect(*aVisualOverflowRect, shadowRect);
 15339: 
 14210:   if (IsFloatingFirstLetterChild()) {
 14210:     // The underline/overline drawable area must be contained in the overflow
 14210:     // rect when this is in floating first letter frame at *both* modes.
 68493:     nsFontMetrics* fm = aProvider.GetFontMetrics();
 68495:     nscoord fontAscent = fm->MaxAscent();
 68495:     nscoord fontHeight = fm->MaxHeight();
 14210:     nsRect fontRect(0, mAscent - fontAscent, GetSize().width, fontHeight);
 55028:     aVisualOverflowRect->UnionRect(*aVisualOverflowRect, fontRect);
 14210:   }
 74792:   if (aIncludeTextDecorations) {
 74792:     // Since CSS 2.1 requires that text-decoration defined on ancestors maintain
 74792:     // style and position, they can be drawn at virtually any y-offset, so
 74792:     // maxima and minima are required to reliably generate the rectangle for
 74792:     // them
 74792:     TextDecorations textDecs;
 74792:     GetTextDecorations(aPresContext, textDecs);
 74792:     if (textDecs.HasDecorationLines()) {
 82675:       nscoord inflationMinFontSize =
 98995:         nsLayoutUtils::InflationMinFontSizeFor(aBlockReflowState.frame);
 82675: 
 74792:       const nscoord width = GetSize().width;
 74792:       const gfxFloat appUnitsPerDevUnit = aPresContext->AppUnitsPerDevPixel(),
 74792:                      gfxWidth = width / appUnitsPerDevUnit,
 74792:                      ascent = gfxFloat(mAscent) / appUnitsPerDevUnit;
 74792:       nscoord top(nscoord_MAX), bottom(nscoord_MIN);
 74792:       // Below we loop through all text decorations and compute the rectangle
 74792:       // containing all of them, in this frame's coordinate space
 74792:       for (PRUint32 i = 0; i < textDecs.mUnderlines.Length(); ++i) {
 74792:         const LineDecoration& dec = textDecs.mUnderlines[i];
 74792: 
 82675:         float inflation = nsLayoutUtils::FontSizeInflationInner(dec.mFrame,
 82675:                             inflationMinFontSize);
 74792:         const gfxFont::Metrics metrics =
 82675:           GetFirstFontMetrics(GetFontGroupForFrame(dec.mFrame, inflation));
 74792: 
 74792:         const nsRect decorationRect =
 74792:           nsCSSRendering::GetTextDecorationRect(aPresContext,
 74792:             gfxSize(gfxWidth, metrics.underlineSize),
 74792:             ascent, metrics.underlineOffset,
 74792:             NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE, dec.mStyle) +
 74792:           nsPoint(0, -dec.mBaselineOffset);
 74792: 
 74792:         top = NS_MIN(decorationRect.y, top);
 74792:         bottom = NS_MAX(decorationRect.YMost(), bottom);
 74792:       }
 74792:       for (PRUint32 i = 0; i < textDecs.mOverlines.Length(); ++i) {
 74792:         const LineDecoration& dec = textDecs.mOverlines[i];
 74792: 
 82675:         float inflation = nsLayoutUtils::FontSizeInflationInner(dec.mFrame,
 82675:                             inflationMinFontSize);
 74792:         const gfxFont::Metrics metrics =
 82675:           GetFirstFontMetrics(GetFontGroupForFrame(dec.mFrame, inflation));
 74792: 
 74792:         const nsRect decorationRect =
 74792:           nsCSSRendering::GetTextDecorationRect(aPresContext,
 74792:             gfxSize(gfxWidth, metrics.underlineSize),
 74792:             ascent, metrics.maxAscent,
 74792:             NS_STYLE_TEXT_DECORATION_LINE_OVERLINE, dec.mStyle) +
 74792:           nsPoint(0, -dec.mBaselineOffset);
 74792: 
 74792:         top = NS_MIN(decorationRect.y, top);
 74792:         bottom = NS_MAX(decorationRect.YMost(), bottom);
 74792:       }
 74792:       for (PRUint32 i = 0; i < textDecs.mStrikes.Length(); ++i) {
 74792:         const LineDecoration& dec = textDecs.mStrikes[i];
 74792: 
 82675:         float inflation = nsLayoutUtils::FontSizeInflationInner(dec.mFrame,
 82675:                             inflationMinFontSize);
 74792:         const gfxFont::Metrics metrics =
 82675:           GetFirstFontMetrics(GetFontGroupForFrame(dec.mFrame, inflation));
 74792: 
 74792:         const nsRect decorationRect =
 74792:           nsCSSRendering::GetTextDecorationRect(aPresContext,
 74792:             gfxSize(gfxWidth, metrics.strikeoutSize),
 74792:             ascent, metrics.strikeoutOffset,
 74792:             NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH, dec.mStyle) +
 74792:           nsPoint(0, -dec.mBaselineOffset);
 74792:         top = NS_MIN(decorationRect.y, top);
 74792:         bottom = NS_MAX(decorationRect.YMost(), bottom);
 74792:       }
 74792: 
 74792:       aVisualOverflowRect->UnionRect(*aVisualOverflowRect,
 74792:                                      nsRect(0, top, width, bottom - top));
 74792:     }
 74792:   }
 13714:   // When this frame is not selected, the text-decoration area must be in
 13714:   // frame bounds.
 85101:   if (!IsSelected() ||
 55028:       !CombineSelectionUnderlineRect(aPresContext, *aVisualOverflowRect))
 13714:     return;
 13714:   AddStateBits(TEXT_SELECTION_UNDERLINE_OVERFLOWED);
 11780: }
 11780: 
 29850: static gfxFloat
 29850: ComputeDescentLimitForSelectionUnderline(nsPresContext* aPresContext,
 29850:                                          nsTextFrame* aFrame,
 29850:                                          const gfxFont::Metrics& aFontMetrics)
 29850: {
 29850:   gfxFloat app = aPresContext->AppUnitsPerDevPixel();
 29850:   nscoord lineHeightApp =
 82677:     nsHTMLReflowState::CalcLineHeight(aFrame->GetStyleContext(), NS_AUTOHEIGHT,
 82677:                                       aFrame->GetFontSizeInflation());
 29850:   gfxFloat lineHeight = gfxFloat(lineHeightApp) / app;
 29850:   if (lineHeight <= aFontMetrics.maxHeight) {
 29850:     return aFontMetrics.maxDescent;
 29850:   }
 29850:   return aFontMetrics.maxDescent + (lineHeight - aFontMetrics.maxHeight) / 2;
 29850: }
 29850: 
 29850: 
     1: // Make sure this stays in sync with DrawSelectionDecorations below
     1: static const SelectionType SelectionTypesWithDecorations =
     1:   nsISelectionController::SELECTION_SPELLCHECK |
     1:   nsISelectionController::SELECTION_IME_RAWINPUT |
     1:   nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT |
     1:   nsISelectionController::SELECTION_IME_CONVERTEDTEXT |
     1:   nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT;
     1: 
 31685: static gfxFloat
 31685: ComputeSelectionUnderlineHeight(nsPresContext* aPresContext,
 31685:                                 const gfxFont::Metrics& aFontMetrics,
 31685:                                 SelectionType aSelectionType)
 31685: {
 31685:   switch (aSelectionType) {
 31685:     case nsISelectionController::SELECTION_IME_RAWINPUT:
 31685:     case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
 31685:     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
 31685:     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT:
 31685:       return aFontMetrics.underlineSize;
 31685:     case nsISelectionController::SELECTION_SPELLCHECK: {
 31685:       // The thickness of the spellchecker underline shouldn't honor the font
 31685:       // metrics.  It should be constant pixels value which is decided from the
 31685:       // default font size.  Note that if the actual font size is smaller than
 31685:       // the default font size, we should use the actual font size because the
 31685:       // computed value from the default font size can be too thick for the
 31685:       // current font size.
 31685:       PRInt32 defaultFontSize =
 31685:         aPresContext->AppUnitsToDevPixels(nsStyleFont(aPresContext).mFont.size);
 32531:       gfxFloat fontSize = NS_MIN(gfxFloat(defaultFontSize),
 31685:                                  aFontMetrics.emHeight);
 32531:       fontSize = NS_MAX(fontSize, 1.0);
 75359:       return ceil(fontSize / 20);
 31685:     }
 31685:     default:
 31685:       NS_WARNING("Requested underline style is not valid");
 31685:       return aFontMetrics.underlineSize;
 31685:   }
 31685: }
 31685: 
     1: /**
     1:  * This, plus SelectionTypesWithDecorations, encapsulates all knowledge about
     1:  * drawing text decoration for selections.
     1:  */
 78406: static void DrawSelectionDecorations(gfxContext* aContext,
 78406:     const gfxRect& aDirtyRect,
 78406:     SelectionType aType,
 29850:     nsTextFrame* aFrame,
 27654:     nsTextPaintStyle& aTextPaintStyle,
 27654:     const nsTextRangeStyle &aRangeStyle,
 27654:     const gfxPoint& aPt, gfxFloat aWidth,
 13955:     gfxFloat aAscent, const gfxFont::Metrics& aFontMetrics)
  4302: {
 26883:   gfxPoint pt(aPt);
 31685:   gfxSize size(aWidth,
 31685:                ComputeSelectionUnderlineHeight(aTextPaintStyle.PresContext(),
 31685:                                                aFontMetrics, aType));
 29850:   gfxFloat descentLimit =
 29850:     ComputeDescentLimitForSelectionUnderline(aTextPaintStyle.PresContext(),
 29850:                                              aFrame, aFontMetrics);
     1: 
 27654:   float relativeSize;
 27654:   PRUint8 style;
 27654:   nscolor color;
 27654:   PRInt32 index =
 27654:     nsTextPaintStyle::GetUnderlineStyleIndexForSelectionType(aType);
 79445:   bool weDefineSelectionUnderline =
 27654:     aTextPaintStyle.GetSelectionUnderlineForPaint(index, &color,
 27654:                                                   &relativeSize, &style);
 27654: 
     1:   switch (aType) {
 26883:     case nsISelectionController::SELECTION_IME_RAWINPUT:
 26883:     case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
 26883:     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
 27654:     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT: {
 26883:       // IME decoration lines should not be drawn on the both ends, i.e., we
 26883:       // need to cut both edges of the decoration lines.  Because same style
 26883:       // IME selections can adjoin, but the users need to be able to know
 26883:       // where are the boundaries of the selections.
 26883:       //
 26883:       //  X: underline
 26883:       //
 26883:       //     IME selection #1        IME selection #2      IME selection #3
 26883:       //  |                     |                      |                    
 26883:       //  | XXXXXXXXXXXXXXXXXXX | XXXXXXXXXXXXXXXXXXXX | XXXXXXXXXXXXXXXXXXX
 26883:       //  +---------------------+----------------------+--------------------
 26883:       //   ^                   ^ ^                    ^ ^
 26883:       //  gap                  gap                    gap
 26883:       pt.x += 1.0;
 26883:       size.width -= 2.0;
 27654:       if (aRangeStyle.IsDefined()) {
 27654:         // If IME defines the style, that should override our definition.
 27654:         if (aRangeStyle.IsLineStyleDefined()) {
 27654:           if (aRangeStyle.mLineStyle == nsTextRangeStyle::LINESTYLE_NONE) {
 27654:             return;
 27654:           }
 64457:           style = aRangeStyle.mLineStyle;
 27654:           relativeSize = aRangeStyle.mIsBoldLine ? 2.0f : 1.0f;
 27654:         } else if (!weDefineSelectionUnderline) {
 27654:           // There is no underline style definition.
 27654:           return;
 27654:         }
 27654:         if (aRangeStyle.IsUnderlineColorDefined()) {
 27654:           color = aRangeStyle.mUnderlineColor;
 27654:         } else if (aRangeStyle.IsForegroundColorDefined()) {
 27654:           color = aRangeStyle.mForegroundColor;
 27654:         } else {
 27654:           NS_ASSERTION(!aRangeStyle.IsBackgroundColorDefined(),
 27654:                        "Only the background color is defined");
 27654:           color = aTextPaintStyle.GetTextColor();
 27654:         }
 27654:       } else if (!weDefineSelectionUnderline) {
 27654:         // IME doesn't specify the selection style and we don't define selection
 27654:         // underline.
 27654:         return;
 27654:       }
 27654:       break;
 27654:     }
 27654:     case nsISelectionController::SELECTION_SPELLCHECK:
 27654:       if (!weDefineSelectionUnderline)
 27654:         return;
 27654:       break;
 27654:     default:
 27654:       NS_WARNING("Requested selection decorations when there aren't any");
 27654:       return;
 27654:   }
 26883:   size.height *= relativeSize;
  4302:   nsCSSRendering::PaintDecorationLine(
 78406:     aContext, aDirtyRect, color, pt, size, aAscent, aFontMetrics.underlineOffset,
 68819:     NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE, style, descentLimit);
 26883: }
     1: 
     1: /**
     1:  * This function encapsulates all knowledge of how selections affect foreground
     1:  * and background colors.
     1:  * @return true if the selection affects colors, false otherwise
     1:  * @param aForeground the foreground color to use
     1:  * @param aBackground the background color to use, or RGBA(0,0,0,0) if no
     1:  * background should be painted
     1:  */
 79445: static bool GetSelectionTextColors(SelectionType aType,
 27654:                                      nsTextPaintStyle& aTextPaintStyle,
 27654:                                      const nsTextRangeStyle &aRangeStyle,
     1:                                      nscolor* aForeground, nscolor* aBackground)
     1: {
     1:   switch (aType) {
     1:     case nsISelectionController::SELECTION_NORMAL:
     1:       return aTextPaintStyle.GetSelectionColors(aForeground, aBackground);
 16313:     case nsISelectionController::SELECTION_FIND:
 16313:       aTextPaintStyle.GetHighlightColors(aForeground, aBackground);
 80486:       return true;
 69254:     case nsISelectionController::SELECTION_URLSECONDARY:
 69254:       aTextPaintStyle.GetURLSecondaryColor(aForeground);
 69254:       *aBackground = NS_RGBA(0,0,0,0);
 80486:       return true;
     1:     case nsISelectionController::SELECTION_IME_RAWINPUT:
     1:     case nsISelectionController::SELECTION_IME_SELECTEDRAWTEXT:
     1:     case nsISelectionController::SELECTION_IME_CONVERTEDTEXT:
     1:     case nsISelectionController::SELECTION_IME_SELECTEDCONVERTEDTEXT:
 27654:       if (aRangeStyle.IsDefined()) {
 27654:         *aForeground = aTextPaintStyle.GetTextColor();
 27654:         *aBackground = NS_RGBA(0,0,0,0);
 27654:         if (!aRangeStyle.IsForegroundColorDefined() &&
 27654:             !aRangeStyle.IsBackgroundColorDefined()) {
 80486:           return false;
 27654:         }
 27654:         if (aRangeStyle.IsForegroundColorDefined()) {
 27654:           *aForeground = aRangeStyle.mForegroundColor;
 27654:         }
 27654:         if (aRangeStyle.IsBackgroundColorDefined()) {
 27654:           *aBackground = aRangeStyle.mBackgroundColor;
 27654:         }
 80486:         return true;
 27654:       }
 26883:       aTextPaintStyle.GetIMESelectionColors(
 26883:         nsTextPaintStyle::GetUnderlineStyleIndexForSelectionType(aType),
     1:         aForeground, aBackground);
 80486:       return true;
     1:     default:
     1:       *aForeground = aTextPaintStyle.GetTextColor();
     1:       *aBackground = NS_RGBA(0,0,0,0);
 80486:       return false;
     1:   }
     1: }
     1: 
     1: /**
     1:  * This class lets us iterate over chunks of text in a uniform selection state,
     1:  * observing cluster boundaries, in content order, maintaining the current
     1:  * x-offset as we go, and telling whether the text chunk has a hyphen after
     1:  * it or not. The caller is responsible for actually computing the advance
     1:  * width of each chunk.
     1:  */
     1: class SelectionIterator {
     1: public:
     1:   /**
 27654:    * aStart and aLength are in the original string. aSelectionDetails is
     1:    * according to the original string.
 72762:    * @param aXOffset the offset from the origin of the frame to the start
 72762:    * of the text (the left baseline origin for LTR, the right baseline origin
 72762:    * for RTL)
     1:    */
 27654:   SelectionIterator(SelectionDetails** aSelectionDetails,
 27654:                     PRInt32 aStart, PRInt32 aLength,
 72762:                     PropertyProvider& aProvider, gfxTextRun* aTextRun,
 72762:                     gfxFloat aXOffset);
     1: 
     1:   /**
     1:    * Returns the next segment of uniformly selected (or not) text.
     1:    * @param aXOffset the offset from the origin of the frame to the start
     1:    * of the text (the left baseline origin for LTR, the right baseline origin
     1:    * for RTL)
     1:    * @param aOffset the transformed string offset of the text for this segment
     1:    * @param aLength the transformed string length of the text for this segment
     1:    * @param aHyphenWidth if a hyphen is to be rendered after the text, the
     1:    * width of the hyphen, otherwise zero
     1:    * @param aType the selection type for this segment
 27654:    * @param aStyle the selection style for this segment
     1:    * @return false if there are no more segments
     1:    */
 79445:   bool GetNextSegment(gfxFloat* aXOffset, PRUint32* aOffset, PRUint32* aLength,
 27654:                         gfxFloat* aHyphenWidth, SelectionType* aType,
 27654:                         nsTextRangeStyle* aStyle);
     1:   void UpdateWithAdvance(gfxFloat aAdvance) {
     1:     mXOffset += aAdvance*mTextRun->GetDirection();
     1:   }
     1: 
     1: private:
 27654:   SelectionDetails**      mSelectionDetails;
     1:   PropertyProvider&       mProvider;
     1:   gfxTextRun*             mTextRun;
     1:   gfxSkipCharsIterator    mIterator;
     1:   PRInt32                 mOriginalStart;
     1:   PRInt32                 mOriginalEnd;
     1:   gfxFloat                mXOffset;
     1: };
     1: 
 27654: SelectionIterator::SelectionIterator(SelectionDetails** aSelectionDetails,
     1:     PRInt32 aStart, PRInt32 aLength, PropertyProvider& aProvider,
 72762:     gfxTextRun* aTextRun, gfxFloat aXOffset)
 27654:   : mSelectionDetails(aSelectionDetails), mProvider(aProvider),
     1:     mTextRun(aTextRun), mIterator(aProvider.GetStart()),
     1:     mOriginalStart(aStart), mOriginalEnd(aStart + aLength),
 72762:     mXOffset(aXOffset)
     1: {
     1:   mIterator.SetOriginalOffset(aStart);
     1: }
     1: 
 79445: bool SelectionIterator::GetNextSegment(gfxFloat* aXOffset,
 27654:     PRUint32* aOffset, PRUint32* aLength, gfxFloat* aHyphenWidth,
 27654:     SelectionType* aType, nsTextRangeStyle* aStyle)
     1: {
     1:   if (mIterator.GetOriginalOffset() >= mOriginalEnd)
 80486:     return false;
     1:   
     1:   // save offset into transformed string now
     1:   PRUint32 runOffset = mIterator.GetSkippedOffset();
     1:   
     1:   PRInt32 index = mIterator.GetOriginalOffset() - mOriginalStart;
 27654:   SelectionDetails* sdptr = mSelectionDetails[index];
 27654:   SelectionType type =
 27654:     sdptr ? sdptr->mType : nsISelectionController::SELECTION_NONE;
 27654:   nsTextRangeStyle style;
 27654:   if (sdptr) {
 27654:     style = sdptr->mTextRangeStyle;
 27654:   }
  1380:   for (++index; mOriginalStart + index < mOriginalEnd; ++index) {
 27654:     if (sdptr != mSelectionDetails[index])
     1:       break;
  1380:   }
     1:   mIterator.SetOriginalOffset(index + mOriginalStart);
     1: 
     1:   // Advance to the next cluster boundary
     1:   while (mIterator.GetOriginalOffset() < mOriginalEnd &&
     1:          !mIterator.IsOriginalCharSkipped() &&
     8:          !mTextRun->IsClusterStart(mIterator.GetSkippedOffset())) {
     1:     mIterator.AdvanceOriginal(1);
     1:   }
     1: 
 79445:   bool haveHyphenBreak =
   202:     (mProvider.GetFrame()->GetStateBits() & TEXT_HYPHEN_BREAK) != 0;
     1:   *aOffset = runOffset;
     1:   *aLength = mIterator.GetSkippedOffset() - runOffset;
     1:   *aXOffset = mXOffset;
     1:   *aHyphenWidth = 0;
   202:   if (mIterator.GetOriginalOffset() == mOriginalEnd && haveHyphenBreak) {
     1:     *aHyphenWidth = mProvider.GetHyphenWidth();
     1:   }
     1:   *aType = type;
 27654:   *aStyle = style;
 80486:   return true;
     1: }
     1: 
 16706: static void
 16706: AddHyphenToMetrics(nsTextFrame* aTextFrame, gfxTextRun* aBaseTextRun,
 25417:                    gfxTextRun::Metrics* aMetrics,
 25417:                    gfxFont::BoundingBoxType aBoundingBoxType,
 16706:                    gfxContext* aContext)
 16706: {
 16706:   // Fix up metrics to include hyphen
 86690:   nsAutoPtr<gfxTextRun> hyphenTextRun(
 16706:     GetHyphenTextRun(aBaseTextRun, aContext, aTextFrame));
 16706:   if (!hyphenTextRun.get())
 16706:     return;
 16706: 
 16706:   gfxTextRun::Metrics hyphenMetrics =
 25417:     hyphenTextRun->MeasureText(0, hyphenTextRun->GetLength(),
 25417:                                aBoundingBoxType, aContext, nsnull);
 16706:   aMetrics->CombineWith(hyphenMetrics, aBaseTextRun->IsRightToLeft());
 16706: }
 16706: 
 15339: void
 15339: nsTextFrame::PaintOneShadow(PRUint32 aOffset, PRUint32 aLength,
 15699:                             nsCSSShadowItem* aShadowDetails,
 32863:                             PropertyProvider* aProvider, const nsRect& aDirtyRect,
 15339:                             const gfxPoint& aFramePt, const gfxPoint& aTextBaselinePt,
 72260:                             gfxContext* aCtx, const nscolor& aForegroundColor,
 72260:                             const nsCharClipDisplayItem::ClipEdges& aClipEdges,
 98803:                             nscoord aLeftSideOffset, gfxRect& aBoundingBox)
 15339: {
 98057:   SAMPLE_LABEL("nsTextFrame", "PaintOneShadow");
 19207:   gfxPoint shadowOffset(aShadowDetails->mXOffset, aShadowDetails->mYOffset);
 32531:   nscoord blurRadius = NS_MAX(aShadowDetails->mRadius, 0);
 15339: 
 15339:   // This rect is the box which is equivalent to where the shadow will be painted.
 98803:   // The origin of aBoundingBox is the text baseline left, so we must translate it by
 15339:   // that much in order to make the origin the top-left corner of the text bounding box.
 98803:   gfxRect shadowGfxRect = aBoundingBox +
 72260:     gfxPoint(aFramePt.x + aLeftSideOffset, aTextBaselinePt.y) + shadowOffset;
 73750:   nsRect shadowRect(NSToCoordRound(shadowGfxRect.X()),
 73750:                     NSToCoordRound(shadowGfxRect.Y()),
 73750:                     NSToCoordRound(shadowGfxRect.Width()),
 73750:                     NSToCoordRound(shadowGfxRect.Height()));
 15339: 
 15339:   nsContextBoxBlur contextBoxBlur;
 51264:   gfxContext* shadowContext = contextBoxBlur.Init(shadowRect, 0, blurRadius,
 15339:                                                   PresContext()->AppUnitsPerDevPixel(),
 40965:                                                   aCtx, aDirtyRect, nsnull);
 15339:   if (!shadowContext)
 15339:     return;
 15339: 
 15339:   nscolor shadowColor;
 74796:   const nscolor* decorationOverrideColor;
 74796:   if (aShadowDetails->mHasColor) {
 15339:     shadowColor = aShadowDetails->mColor;
 74796:     decorationOverrideColor = &shadowColor;
 74796:   } else {
 15339:     shadowColor = aForegroundColor;
 74796:     decorationOverrideColor = nsnull;
 74796:   }
 15339: 
 15339:   aCtx->Save();
 15339:   aCtx->NewPath();
 15339:   aCtx->SetColor(gfxRGBA(shadowColor));
 15339: 
 15339:   // Draw the text onto our alpha-only surface to capture the alpha values.
 15339:   // Remember that the box blur context has a device offset on it, so we don't need to
 15339:   // translate any coordinates to fit on the surface.
 16706:   gfxFloat advanceWidth;
 78406:   gfxRect dirtyRect(aDirtyRect.x, aDirtyRect.y,
 78406:                     aDirtyRect.width, aDirtyRect.height);
 78406:   DrawText(shadowContext, dirtyRect, aFramePt + shadowOffset,
 74795:            aTextBaselinePt + shadowOffset, aOffset, aLength, *aProvider,
 74795:            nsTextPaintStyle(this), aClipEdges, advanceWidth,
 74796:            (GetStateBits() & TEXT_HYPHEN_BREAK) != 0, decorationOverrideColor);
 15339: 
 15339:   contextBoxBlur.DoPaint();
 15339:   aCtx->Restore();
 15339: }
 15339: 
     1: // Paints selection backgrounds and text in the correct colors. Also computes
     1: // aAllTypes, the union of all selection types that are applying to this text.
 72764: bool
     1: nsTextFrame::PaintTextWithSelectionColors(gfxContext* aCtx,
 74795:     const gfxPoint& aFramePt, const gfxPoint& aTextBaselinePt,
 74795:     const gfxRect& aDirtyRect,
 72762:     PropertyProvider& aProvider,
 72762:     PRUint32 aContentOffset, PRUint32 aContentLength,
 72762:     nsTextPaintStyle& aTextPaintStyle, SelectionDetails* aDetails,
 74795:     SelectionType* aAllTypes,
 74795:     const nsCharClipDisplayItem::ClipEdges& aClipEdges)
 72762: {
     1:   // Figure out which selections control the colors to use for each character.
 87328:   AutoFallibleTArray<SelectionDetails*,BIG_TEXT_NODE_SIZE> prevailingSelectionsBuffer;
 87328:   SelectionDetails** prevailingSelections =
 87328:     prevailingSelectionsBuffer.AppendElements(aContentLength);
 87328:   if (!prevailingSelections) {
 72764:     return false;
 87328:   }
 27654: 
     1:   SelectionType allTypes = 0;
 72762:   for (PRUint32 i = 0; i < aContentLength; ++i) {
 27654:     prevailingSelections[i] = nsnull;
     1:   }
     1: 
     1:   SelectionDetails *sdptr = aDetails;
 79445:   bool anyBackgrounds = false;
     1:   while (sdptr) {
 72762:     PRInt32 start = NS_MAX(0, sdptr->mStart - PRInt32(aContentOffset));
 72762:     PRInt32 end = NS_MIN(PRInt32(aContentLength),
 72762:                          sdptr->mEnd - PRInt32(aContentOffset));
     1:     SelectionType type = sdptr->mType;
     1:     if (start < end) {
     1:       allTypes |= type;
     1:       // Ignore selections that don't set colors
     1:       nscolor foreground, background;
 27654:       if (GetSelectionTextColors(type, aTextPaintStyle, sdptr->mTextRangeStyle,
 27654:                                  &foreground, &background)) {
     1:         if (NS_GET_A(background) > 0) {
 80486:           anyBackgrounds = true;
     1:         }
 72762:         for (PRInt32 i = start; i < end; ++i) {
     1:           // Favour normal selection over IME selections
 27654:           if (!prevailingSelections[i] ||
 27654:               type < prevailingSelections[i]->mType) {
 27654:             prevailingSelections[i] = sdptr;
     1:           }
     1:         }
     1:       }
     1:     }
     1:     sdptr = sdptr->mNext;
     1:   }
     1:   *aAllTypes = allTypes;
     1: 
 72764:   if (!allTypes) {
 85101:     // Nothing is selected in the given text range. XXX can this still occur?
 72764:     return false;
 72764:   }
 72764: 
 72762:   const gfxFloat startXOffset = aTextBaselinePt.x - aFramePt.x;
     1:   gfxFloat xOffset, hyphenWidth;
     1:   PRUint32 offset, length; // in transformed string
     1:   SelectionType type;
 27654:   nsTextRangeStyle rangeStyle;
     1:   // Draw background colors
     1:   if (anyBackgrounds) {
 72762:     SelectionIterator iterator(prevailingSelections, aContentOffset, aContentLength,
 72762:                                aProvider, mTextRun, startXOffset);
 27654:     while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth,
 27654:                                    &type, &rangeStyle)) {
     1:       nscolor foreground, background;
 27654:       GetSelectionTextColors(type, aTextPaintStyle, rangeStyle,
 27654:                              &foreground, &background);
     1:       // Draw background color
     1:       gfxFloat advance = hyphenWidth +
     1:         mTextRun->GetAdvanceWidth(offset, length, &aProvider);
     1:       if (NS_GET_A(background) > 0) {
     1:         gfxFloat x = xOffset - (mTextRun->IsRightToLeft() ? advance : 0);
   280:         FillClippedRect(aCtx, aTextPaintStyle.PresContext(),
     1:                         background, aDirtyRect,
     1:                         gfxRect(aFramePt.x + x, aFramePt.y, advance, GetSize().height));
     1:       }
     1:       iterator.UpdateWithAdvance(advance);
     1:     }
     1:   }
     1:   
     1:   // Draw text
 80045:   const nsStyleText* textStyle = GetStyleText();
 80045:   nsRect dirtyRect(aDirtyRect.x, aDirtyRect.y,
 80045:                    aDirtyRect.width, aDirtyRect.height);
 72762:   SelectionIterator iterator(prevailingSelections, aContentOffset, aContentLength,
 72762:                              aProvider, mTextRun, startXOffset);
 27654:   while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth,
 27654:                                  &type, &rangeStyle)) {
     1:     nscolor foreground, background;
 27654:     GetSelectionTextColors(type, aTextPaintStyle, rangeStyle,
 27654:                            &foreground, &background);
 80045:     gfxPoint textBaselinePt(aFramePt.x + xOffset, aTextBaselinePt.y);
 80045: 
 80045:     // Draw shadows, if any
 80045:     if (textStyle->mTextShadow) {
 98803:       gfxTextRun::Metrics shadowMetrics =
 98803:         mTextRun->MeasureText(offset, length, gfxFont::LOOSE_INK_EXTENTS,
 98803:                               nsnull, &aProvider);
 98803:       if (GetStateBits() & TEXT_HYPHEN_BREAK) {
 98803:         AddHyphenToMetrics(this, mTextRun, &shadowMetrics,
 98803:                            gfxFont::LOOSE_INK_EXTENTS, aCtx);
 98803:       }
 80045:       for (PRUint32 i = textStyle->mTextShadow->Length(); i > 0; --i) {
 80045:         PaintOneShadow(offset, length,
 80045:                        textStyle->mTextShadow->ShadowAt(i - 1), &aProvider,
 80045:                        dirtyRect, aFramePt, textBaselinePt, aCtx,
 98803:                        foreground, aClipEdges, 
 98803:                        xOffset - (mTextRun->IsRightToLeft() ?
 98803:                                   shadowMetrics.mBoundingBox.width : 0),
 98803:                        shadowMetrics.mBoundingBox);
 80045:       }
 80045:     }
 80045: 
     1:     // Draw text segment
     1:     aCtx->SetColor(gfxRGBA(foreground));
     1:     gfxFloat advance;
 15339: 
 80045:     DrawText(aCtx, aDirtyRect, aFramePt, textBaselinePt,
 74795:              offset, length, aProvider, aTextPaintStyle, aClipEdges, advance,
 74795:              hyphenWidth > 0);
     1:     if (hyphenWidth) {
     1:       advance += hyphenWidth;
     1:     }
     1:     iterator.UpdateWithAdvance(advance);
     1:   }
 72764:   return true;
     1: }
     1: 
     1: void
     1: nsTextFrame::PaintTextSelectionDecorations(gfxContext* aCtx,
     1:     const gfxPoint& aFramePt,
     1:     const gfxPoint& aTextBaselinePt, const gfxRect& aDirtyRect,
 72762:     PropertyProvider& aProvider,
 72762:     PRUint32 aContentOffset, PRUint32 aContentLength,
 72762:     nsTextPaintStyle& aTextPaintStyle, SelectionDetails* aDetails,
 72762:     SelectionType aSelectionType)
     1: {
 62296:   // Hide text decorations if we're currently hiding @font-face fallback text
 62296:   if (aProvider.GetFontGroup()->ShouldSkipDrawing())
 62296:     return;
 62296: 
 27654:   // Figure out which characters will be decorated for this selection.
 87328:   AutoFallibleTArray<SelectionDetails*, BIG_TEXT_NODE_SIZE> selectedCharsBuffer;
 87328:   SelectionDetails** selectedChars =
 87328:     selectedCharsBuffer.AppendElements(aContentLength);
 87328:   if (!selectedChars) {
     1:     return;
 87328:   }
 72762:   for (PRUint32 i = 0; i < aContentLength; ++i) {
 27654:     selectedChars[i] = nsnull;
     1:   }
     1: 
     1:   SelectionDetails *sdptr = aDetails;
     1:   while (sdptr) {
     1:     if (sdptr->mType == aSelectionType) {
 72762:       PRInt32 start = NS_MAX(0, sdptr->mStart - PRInt32(aContentOffset));
 72762:       PRInt32 end = NS_MIN(PRInt32(aContentLength),
 72762:                            sdptr->mEnd - PRInt32(aContentOffset));
 72762:       for (PRInt32 i = start; i < end; ++i) {
 27654:         selectedChars[i] = sdptr;
     1:       }
     1:     }
     1:     sdptr = sdptr->mNext;
     1:   }
     1: 
 12989:   gfxFont* firstFont = aProvider.GetFontGroup()->GetFontAt(0);
 12989:   if (!firstFont)
 12989:     return; // OOM
 12989:   gfxFont::Metrics decorationMetrics(firstFont->GetMetrics());
 12989:   decorationMetrics.underlineOffset =
 12989:     aProvider.GetFontGroup()->GetUnderlineOffset();
     1: 
 72762:   gfxFloat startXOffset = aTextBaselinePt.x - aFramePt.x;
 72762:   SelectionIterator iterator(selectedChars, aContentOffset, aContentLength,
 72762:                              aProvider, mTextRun, startXOffset);
     1:   gfxFloat xOffset, hyphenWidth;
     1:   PRUint32 offset, length;
  5601:   PRInt32 app = aTextPaintStyle.PresContext()->AppUnitsPerDevPixel();
  5601:   // XXX aTextBaselinePt is in AppUnits, shouldn't it be nsFloatPoint?
  5601:   gfxPoint pt(0.0, (aTextBaselinePt.y - mAscent) / app);
 78406:   gfxRect dirtyRect(aDirtyRect.x / app, aDirtyRect.y / app,
 78406:                     aDirtyRect.width / app, aDirtyRect.height / app);
     1:   SelectionType type;
 27654:   nsTextRangeStyle selectedStyle;
 27654:   while (iterator.GetNextSegment(&xOffset, &offset, &length, &hyphenWidth,
 27654:                                  &type, &selectedStyle)) {
     1:     gfxFloat advance = hyphenWidth +
     1:       mTextRun->GetAdvanceWidth(offset, length, &aProvider);
     1:     if (type == aSelectionType) {
 13955:       pt.x = (aFramePt.x + xOffset -
 13955:              (mTextRun->IsRightToLeft() ? advance : 0)) / app;
 72496:       gfxFloat width = NS_ABS(advance) / app;
 78406:       DrawSelectionDecorations(aCtx, dirtyRect, aSelectionType, this, aTextPaintStyle,
 27654:                                selectedStyle,
 13955:                                pt, width, mAscent / app, decorationMetrics);
     1:     }
     1:     iterator.UpdateWithAdvance(advance);
     1:   }
     1: }
     1: 
 72764: bool
     1: nsTextFrame::PaintTextWithSelection(gfxContext* aCtx,
     1:     const gfxPoint& aFramePt,
     1:     const gfxPoint& aTextBaselinePt, const gfxRect& aDirtyRect,
 74795:     PropertyProvider& aProvider,
 74795:     PRUint32 aContentOffset, PRUint32 aContentLength,
 72762:     nsTextPaintStyle& aTextPaintStyle,
 72260:     const nsCharClipDisplayItem::ClipEdges& aClipEdges)
     1: {
 85101:   NS_ASSERTION(GetContent()->IsSelectionDescendant(), "wrong paint path");
 85101: 
     1:   SelectionDetails* details = GetSelectionDetails();
 72764:   if (!details) {
 72764:     return false;
 72764:   }
     1: 
     1:   SelectionType allTypes;
 72764:   if (!PaintTextWithSelectionColors(aCtx, aFramePt, aTextBaselinePt, aDirtyRect,
 72762:                                     aProvider, aContentOffset, aContentLength,
 74795:                                     aTextPaintStyle, details, &allTypes,
 85101:                                     aClipEdges)) {
 72764:     DestroySelectionDetails(details);
 72764:     return false;
 72764:   }
     1:   PRInt32 i;
     1:   // Iterate through just the selection types that paint decorations and
     1:   // paint decorations for any that actually occur in this frame. Paint
     1:   // higher-numbered selection types below lower-numered ones on the
     1:   // general principal that lower-numbered selections are higher priority.
     1:   allTypes &= SelectionTypesWithDecorations;
     1:   for (i = nsISelectionController::NUM_SELECTIONTYPES - 1; i >= 1; --i) {
     1:     SelectionType type = 1 << (i - 1);
     1:     if (allTypes & type) {
     1:       // There is some selection of this type. Try to paint its decorations
     1:       // (there might not be any for this type but that's OK,
     1:       // PaintTextSelectionDecorations will exit early).
     1:       PaintTextSelectionDecorations(aCtx, aFramePt, aTextBaselinePt, aDirtyRect,
 72762:                                     aProvider, aContentOffset, aContentLength,
 72762:                                     aTextPaintStyle, details, type);
     1:     }
     1:   }
     1: 
     1:   DestroySelectionDetails(details);
 72764:   return true;
     1: }
     1: 
 40078: nscolor
 40078: nsTextFrame::GetCaretColorAt(PRInt32 aOffset)
 40078: {
 40078:   NS_PRECONDITION(aOffset >= 0, "aOffset must be positive");
 40078: 
 82675:   gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
 82675:   PropertyProvider provider(this, iter, nsTextFrame::eInflated);
 40078:   PRInt32 contentOffset = provider.GetStart().GetOriginalOffset();
 40078:   PRInt32 contentLength = provider.GetOriginalLength();
 40078:   NS_PRECONDITION(aOffset >= contentOffset &&
 40078:                   aOffset <= contentOffset + contentLength,
 40078:                   "aOffset must be in the frame's range");
 40078:   PRInt32 offsetInFrame = aOffset - contentOffset;
 40078:   if (offsetInFrame < 0 || offsetInFrame >= contentLength) {
 40078:     return nsFrame::GetCaretColorAt(aOffset);
 40078:   }
 40078: 
 40078:   nsTextPaintStyle textPaintStyle(this);
 40078:   SelectionDetails* details = GetSelectionDetails();
 40078:   SelectionDetails* sdptr = details;
 40078:   nscolor result = nsFrame::GetCaretColorAt(aOffset);
 40078:   SelectionType type = 0;
 40078:   while (sdptr) {
 40078:     PRInt32 start = NS_MAX(0, sdptr->mStart - contentOffset);
 40078:     PRInt32 end = NS_MIN(contentLength, sdptr->mEnd - contentOffset);
 40078:     if (start <= offsetInFrame && offsetInFrame < end &&
 40078:         (type == 0 || sdptr->mType < type)) {
 40078:       nscolor foreground, background;
 40078:       if (GetSelectionTextColors(sdptr->mType, textPaintStyle,
 40078:                                  sdptr->mTextRangeStyle,
 40078:                                  &foreground, &background)) {
 40078:         result = foreground;
 40078:         type = sdptr->mType;
 40078:       }
 40078:     }
 40078:     sdptr = sdptr->mNext;
 40078:   }
 40078: 
 40078:   DestroySelectionDetails(details);
 40078:   return result;
 40078: }
 40078: 
     1: static PRUint32
     1: ComputeTransformedLength(PropertyProvider& aProvider)
     1: {
     1:   gfxSkipCharsIterator iter(aProvider.GetStart());
     1:   PRUint32 start = iter.GetSkippedOffset();
     1:   iter.AdvanceOriginal(aProvider.GetOriginalLength());
     1:   return iter.GetSkippedOffset() - start;
     1: }
     1: 
 72260: bool
 82676: nsTextFrame::MeasureCharClippedText(nscoord aLeftEdge, nscoord aRightEdge,
 72260:                                     nscoord* aSnappedLeftEdge,
 72260:                                     nscoord* aSnappedRightEdge)
 72260: {
 82676:   // We need a *reference* rendering context (not one that might have a
 82676:   // transform), so we don't have a rendering context argument.
 72260:   // XXX get the block and line passed to us somehow! This is slow!
 82675:   gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
 72260:   if (!mTextRun)
 72260:     return false;
 72260: 
 82675:   PropertyProvider provider(this, iter, nsTextFrame::eInflated);
 72260:   // Trim trailing whitespace
 80486:   provider.InitializeForDisplay(true);
 72260: 
 72260:   PRUint32 startOffset = provider.GetStart().GetSkippedOffset();
 72260:   PRUint32 maxLength = ComputeTransformedLength(provider);
 82676:   return MeasureCharClippedText(provider, aLeftEdge, aRightEdge,
 72260:                                 &startOffset, &maxLength,
 72260:                                 aSnappedLeftEdge, aSnappedRightEdge);
 72260: }
 72260: 
 72260: static PRUint32 GetClusterLength(gfxTextRun* aTextRun,
 72260:                                  PRUint32    aStartOffset,
 72260:                                  PRUint32    aMaxLength,
 72260:                                  bool        aIsRTL)
 72260: {
 72260:   PRUint32 clusterLength = aIsRTL ? 0 : 1;
 72260:   while (clusterLength < aMaxLength) {
 72260:     if (aTextRun->IsClusterStart(aStartOffset + clusterLength)) {
 72260:       if (aIsRTL) {
 72260:         ++clusterLength;
 72260:       }
 72260:       break;
 72260:     }
 72260:     ++clusterLength;
 72260:   }
 72260:   return clusterLength;
 72260: }
 72260: 
 72260: bool
 82676: nsTextFrame::MeasureCharClippedText(PropertyProvider& aProvider,
 72260:                                     nscoord aLeftEdge, nscoord aRightEdge,
 72260:                                     PRUint32* aStartOffset,
 72260:                                     PRUint32* aMaxLength,
 72260:                                     nscoord*  aSnappedLeftEdge,
 72260:                                     nscoord*  aSnappedRightEdge)
 72260: {
 72260:   *aSnappedLeftEdge = 0;
 72260:   *aSnappedRightEdge = 0;
 72260:   if (aLeftEdge <= 0 && aRightEdge <= 0) {
 72260:     return true;
 72260:   }
 72260: 
 72260:   PRUint32 offset = *aStartOffset;
 72260:   PRUint32 maxLength = *aMaxLength;
 72260:   const nscoord frameWidth = GetSize().width;
 79445:   const bool rtl = mTextRun->IsRightToLeft();
 72260:   gfxFloat advanceWidth = 0;
 72260:   const nscoord startEdge = rtl ? aRightEdge : aLeftEdge;
 72260:   if (startEdge > 0) {
 72260:     const gfxFloat maxAdvance = gfxFloat(startEdge);
 72260:     while (maxLength > 0) {
 72260:       PRUint32 clusterLength =
 72260:         GetClusterLength(mTextRun, offset, maxLength, rtl);
 72260:       advanceWidth +=
 72260:         mTextRun->GetAdvanceWidth(offset, clusterLength, &aProvider);
 72260:       maxLength -= clusterLength;
 72260:       offset += clusterLength;
 72260:       if (advanceWidth >= maxAdvance) {
 72260:         break;
 72260:       }
 72260:     }
 72260:     nscoord* snappedStartEdge = rtl ? aSnappedRightEdge : aSnappedLeftEdge;
 72260:     *snappedStartEdge = NSToCoordFloor(advanceWidth);
 72260:     *aStartOffset = offset;
 72260:   }
 72260: 
 72260:   const nscoord endEdge = rtl ? aLeftEdge : aRightEdge;
 72260:   if (endEdge > 0) {
 72260:     const gfxFloat maxAdvance = gfxFloat(frameWidth - endEdge);
 72260:     while (maxLength > 0) {
 72260:       PRUint32 clusterLength =
 72260:         GetClusterLength(mTextRun, offset, maxLength, rtl);
 72260:       gfxFloat nextAdvance = advanceWidth +
 72260:         mTextRun->GetAdvanceWidth(offset, clusterLength, &aProvider);
 72260:       if (nextAdvance > maxAdvance) {
 72260:         break;
 72260:       }
 72260:       // This cluster fits, include it.
 72260:       advanceWidth = nextAdvance;
 72260:       maxLength -= clusterLength;
 72260:       offset += clusterLength;
 72260:     }
 72260:     maxLength = offset - *aStartOffset;
 72260:     nscoord* snappedEndEdge = rtl ? aSnappedLeftEdge : aSnappedRightEdge;
 72260:     *snappedEndEdge = NSToCoordFloor(gfxFloat(frameWidth) - advanceWidth);
 72260:   }
 72260:   *aMaxLength = maxLength;
 72260:   return maxLength != 0;
 72260: }
 72260: 
     1: void
 68481: nsTextFrame::PaintText(nsRenderingContext* aRenderingContext, nsPoint aPt,
 72260:                        const nsRect& aDirtyRect,
 72260:                        const nsCharClipDisplayItem& aItem)
     1: {
  6862:   // Don't pass in aRenderingContext here, because we need a *reference*
  6862:   // context and aRenderingContext might have some transform in it
     1:   // XXX get the block and line passed to us somehow! This is slow!
 82675:   gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
     1:   if (!mTextRun)
     1:     return;
     1: 
 82675:   PropertyProvider provider(this, iter, nsTextFrame::eInflated);
     1:   // Trim trailing whitespace
 80486:   provider.InitializeForDisplay(true);
     1: 
  9438:   gfxContext* ctx = aRenderingContext->ThebesContext();
 79445:   const bool rtl = mTextRun->IsRightToLeft();
 72260:   const nscoord frameWidth = GetSize().width;
     1:   gfxPoint framePt(aPt.x, aPt.y);
 72260:   gfxPoint textBaselinePt(rtl ? gfxFloat(aPt.x + frameWidth) : framePt.x,
 72990:              nsLayoutUtils::GetSnappedBaselineY(this, ctx, aPt.y, mAscent));
 72260:   PRUint32 startOffset = provider.GetStart().GetSkippedOffset();
 72260:   PRUint32 maxLength = ComputeTransformedLength(provider);
 72260:   nscoord snappedLeftEdge, snappedRightEdge;
 82676:   if (!MeasureCharClippedText(provider, aItem.mLeftEdge, aItem.mRightEdge,
 72260:          &startOffset, &maxLength, &snappedLeftEdge, &snappedRightEdge)) {
 72260:     return;
 72260:   }
 72260:   textBaselinePt.x += rtl ? -snappedRightEdge : snappedLeftEdge;
 72260:   nsCharClipDisplayItem::ClipEdges clipEdges(aItem, snappedLeftEdge,
 72260:                                              snappedRightEdge);
 72260:   nsTextPaintStyle textPaintStyle(this);
 72260: 
 72260:   gfxRect dirtyRect(aDirtyRect.x, aDirtyRect.y,
 72260:                     aDirtyRect.width, aDirtyRect.height);
     1:   // Fork off to the (slower) paint-with-selection path if necessary.
 85101:   if (IsSelected()) {
 72762:     gfxSkipCharsIterator tmp(provider.GetStart());
 72762:     PRInt32 contentOffset = tmp.ConvertSkippedToOriginal(startOffset);
 72762:     PRInt32 contentLength =
 72762:       tmp.ConvertSkippedToOriginal(startOffset + maxLength) - contentOffset;
 72762:     if (PaintTextWithSelection(ctx, framePt, textBaselinePt, dirtyRect,
 72762:                                provider, contentOffset, contentLength,
 85101:                                textPaintStyle, clipEdges)) {
     1:       return;
     1:     }
 85101:   }
     1: 
 80045:   nscolor foregroundColor = textPaintStyle.GetTextColor();
 80045:   const nsStyleText* textStyle = GetStyleText();
 80045:   if (textStyle->mTextShadow) {
 80045:     // Text shadow happens with the last value being painted at the back,
 80045:     // ie. it is painted first.
 98803:     gfxTextRun::Metrics shadowMetrics = 
 98803:       mTextRun->MeasureText(startOffset, maxLength, gfxFont::LOOSE_INK_EXTENTS,
 98803:                             nsnull, &provider);
 80045:     for (PRUint32 i = textStyle->mTextShadow->Length(); i > 0; --i) {
 80045:       PaintOneShadow(startOffset, maxLength,
 80045:                      textStyle->mTextShadow->ShadowAt(i - 1), &provider,
 80045:                      aDirtyRect, framePt, textBaselinePt, ctx,
 98803:                      foregroundColor, clipEdges,
 98803:                      snappedLeftEdge, shadowMetrics.mBoundingBox);
 80045:     }
 80045:   }
 80045: 
 72260:   ctx->SetColor(gfxRGBA(foregroundColor));
 72260: 
 72260:   gfxFloat advanceWidth;
 78406:   DrawText(ctx, dirtyRect, framePt, textBaselinePt, startOffset, maxLength, provider,
 74795:            textPaintStyle, clipEdges, advanceWidth,
 74795:            (GetStateBits() & TEXT_HYPHEN_BREAK) != 0);
 15339: }
 15339: 
 15339: void
 74795: nsTextFrame::DrawTextRun(gfxContext* const aCtx,
 74795:                          const gfxPoint& aTextBaselinePt,
 15339:                          PRUint32 aOffset, PRUint32 aLength,
 74795:                          PropertyProvider& aProvider,
 74795:                          gfxFloat& aAdvanceWidth,
 79445:                          bool aDrawSoftHyphen)
 74795: {
 88295:   mTextRun->Draw(aCtx, aTextBaselinePt, gfxFont::GLYPH_FILL, aOffset, aLength,
 89450:                  &aProvider, &aAdvanceWidth, nsnull);
 15339: 
 15339:   if (aDrawSoftHyphen) {
  6862:     // Don't use ctx as the context, because we need a reference context here,
  6862:     // ctx may be transformed.
 86690:     nsAutoPtr<gfxTextRun> hyphenTextRun(GetHyphenTextRun(mTextRun, nsnull, this));
  5724:     if (hyphenTextRun.get()) {
 15965:       // For right-to-left text runs, the soft-hyphen is positioned at the left
 15965:       // of the text, minus its own width
 15965:       gfxFloat hyphenBaselineX = aTextBaselinePt.x + mTextRun->GetDirection() * aAdvanceWidth -
 15965:         (mTextRun->IsRightToLeft() ? hyphenTextRun->GetAdvanceWidth(0, hyphenTextRun->GetLength(), nsnull) : 0);
 15339:       hyphenTextRun->Draw(aCtx, gfxPoint(hyphenBaselineX, aTextBaselinePt.y),
 89450:                           gfxFont::GLYPH_FILL, 0, hyphenTextRun->GetLength(),
 89450:                           nsnull, nsnull, nsnull);
 15339:     }
 15339:   }
     1: }
     1: 
 74795: void
 74795: nsTextFrame::DrawTextRunAndDecorations(
 78406:     gfxContext* const aCtx, const gfxRect& aDirtyRect,
 74795:     const gfxPoint& aFramePt, const gfxPoint& aTextBaselinePt,
 74795:     PRUint32 aOffset, PRUint32 aLength,
 74795:     PropertyProvider& aProvider,
 74795:     const nsTextPaintStyle& aTextStyle,
 74795:     const nsCharClipDisplayItem::ClipEdges& aClipEdges,
 74795:     gfxFloat& aAdvanceWidth,
 79445:     bool aDrawSoftHyphen,
 74795:     const TextDecorations& aDecorations,
 74795:     const nscolor* const aDecorationOverrideColor)
 74795: {
 74795:     const gfxFloat app = aTextStyle.PresContext()->AppUnitsPerDevPixel();
 74795: 
 74795:     // XXX aFramePt is in AppUnits, shouldn't it be nsFloatPoint?
 74795:     nscoord x = NSToCoordRound(aFramePt.x);
 74795:     nscoord width = GetRect().width;
 74795:     aClipEdges.Intersect(&x, &width);
 74795: 
 74795:     gfxPoint decPt(x / app, 0);
 74795:     gfxSize decSize(width / app, 0);
 74795:     const gfxFloat ascent = gfxFloat(mAscent) / app;
 74795:     const gfxFloat frameTop = aFramePt.y;
 74795: 
 78406:     gfxRect dirtyRect(aDirtyRect.x / app, aDirtyRect.y / app,
 78406:                       aDirtyRect.Width() / app, aDirtyRect.Height() / app);
 78406: 
 82675:     nscoord inflationMinFontSize =
 98995:       nsLayoutUtils::InflationMinFontSizeFor(this);
 82675: 
 74795:     // Underlines
 74795:     for (PRUint32 i = aDecorations.mUnderlines.Length(); i-- > 0; ) {
 74795:       const LineDecoration& dec = aDecorations.mUnderlines[i];
 74795: 
 82675:       float inflation = nsLayoutUtils::FontSizeInflationInner(dec.mFrame,
 82675:                           inflationMinFontSize);
 74795:       const gfxFont::Metrics metrics =
 82675:         GetFirstFontMetrics(GetFontGroupForFrame(dec.mFrame, inflation));
 74795: 
 74795:       decSize.height = metrics.underlineSize;
 74795:       decPt.y = (frameTop - dec.mBaselineOffset) / app;
 74795: 
 74795:       const nscolor lineColor = aDecorationOverrideColor ? *aDecorationOverrideColor : dec.mColor;
 78406:       nsCSSRendering::PaintDecorationLine(aCtx, dirtyRect, lineColor, decPt, decSize, ascent,
 74795:         metrics.underlineOffset, NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE,
 74795:         dec.mStyle);
 74795:     }
 74795:     // Overlines
 74795:     for (PRUint32 i = aDecorations.mOverlines.Length(); i-- > 0; ) {
 74795:       const LineDecoration& dec = aDecorations.mOverlines[i];
 74795: 
 82675:       float inflation = nsLayoutUtils::FontSizeInflationInner(dec.mFrame,
 82675:                           inflationMinFontSize);
 74795:       const gfxFont::Metrics metrics =
 82675:         GetFirstFontMetrics(GetFontGroupForFrame(dec.mFrame, inflation));
 74795: 
 74795:       decSize.height = metrics.underlineSize;
 74795:       decPt.y = (frameTop - dec.mBaselineOffset) / app;
 74795: 
 74795:       const nscolor lineColor = aDecorationOverrideColor ? *aDecorationOverrideColor : dec.mColor;
 78406:       nsCSSRendering::PaintDecorationLine(aCtx, dirtyRect, lineColor, decPt, decSize, ascent,
 74795:         metrics.maxAscent, NS_STYLE_TEXT_DECORATION_LINE_OVERLINE, dec.mStyle);
 74795:     }
 74795: 
 74795:     // CSS 2.1 mandates that text be painted after over/underlines, and *then*
 74795:     // line-throughs
 74795:     DrawTextRun(aCtx, aTextBaselinePt, aOffset, aLength, aProvider, aAdvanceWidth,
 74795:                 aDrawSoftHyphen);
 74795: 
 74795:     // Line-throughs
 74795:     for (PRUint32 i = aDecorations.mStrikes.Length(); i-- > 0; ) {
 74795:       const LineDecoration& dec = aDecorations.mStrikes[i];
 74795: 
 82675:       float inflation = nsLayoutUtils::FontSizeInflationInner(dec.mFrame,
 82675:                           inflationMinFontSize);
 74795:       const gfxFont::Metrics metrics =
 82675:         GetFirstFontMetrics(GetFontGroupForFrame(dec.mFrame, inflation));
 74795: 
 74795:       decSize.height = metrics.strikeoutSize;
 74795:       decPt.y = (frameTop - dec.mBaselineOffset) / app;
 74795: 
 74795:       const nscolor lineColor = aDecorationOverrideColor ? *aDecorationOverrideColor : dec.mColor;
 78406:       nsCSSRendering::PaintDecorationLine(aCtx, dirtyRect, lineColor, decPt, decSize, ascent,
 74795:         metrics.strikeoutOffset, NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH,
 74795:         dec.mStyle);
 74795:     }
 74795: }
 74795: 
 74795: void
 74795: nsTextFrame::DrawText(
 78406:     gfxContext* const aCtx, const gfxRect& aDirtyRect,
 74795:     const gfxPoint& aFramePt, const gfxPoint& aTextBaselinePt,
 74795:     PRUint32 aOffset, PRUint32 aLength,
 74795:     PropertyProvider& aProvider,
 74795:     const nsTextPaintStyle& aTextStyle,
 74795:     const nsCharClipDisplayItem::ClipEdges& aClipEdges,
 74795:     gfxFloat& aAdvanceWidth,
 79445:     bool aDrawSoftHyphen,
 74795:     const nscolor* const aDecorationOverrideColor)
 74795: {
 74795:   TextDecorations decorations;
 74795:   GetTextDecorations(aTextStyle.PresContext(), decorations);
 74795: 
 74795:   // Hide text decorations if we're currently hiding @font-face fallback text
 74795:   const bool drawDecorations = !aProvider.GetFontGroup()->ShouldSkipDrawing() &&
 74795:                                decorations.HasDecorationLines();
 74795:   if (drawDecorations) {
 78406:     DrawTextRunAndDecorations(aCtx, aDirtyRect, aFramePt, aTextBaselinePt, aOffset, aLength,
 74795:                               aProvider, aTextStyle, aClipEdges, aAdvanceWidth,
 74795:                               aDrawSoftHyphen, decorations,
 74795:                               aDecorationOverrideColor);
 74795:   } else {
 74795:     DrawTextRun(aCtx, aTextBaselinePt, aOffset, aLength, aProvider,
 74795:                 aAdvanceWidth, aDrawSoftHyphen);
 74795:   }
 74795: }
 74795: 
     1: PRInt16
     1: nsTextFrame::GetSelectionStatus(PRInt16* aSelectionFlags)
     1: {
     1:   // get the selection controller
     1:   nsCOMPtr<nsISelectionController> selectionController;
   280:   nsresult rv = GetSelectionController(PresContext(),
     1:                                        getter_AddRefs(selectionController));
     1:   if (NS_FAILED(rv) || !selectionController)
     1:     return nsISelectionController::SELECTION_OFF;
     1: 
     1:   selectionController->GetSelectionFlags(aSelectionFlags);
     1: 
     1:   PRInt16 selectionValue;
     1:   selectionController->GetDisplaySelection(&selectionValue);
     1: 
     1:   return selectionValue;
     1: }
     1: 
 79445: bool
     1: nsTextFrame::IsVisibleInSelection(nsISelection* aSelection)
     1: {
     1:   // Check the quick way first
 85101:   if (!GetContent()->IsSelectionDescendant())
 80486:     return false;
     1:     
     1:   SelectionDetails* details = GetSelectionDetails();
 79445:   bool found = false;
     1:     
     1:   // where are the selection points "really"
     1:   SelectionDetails *sdptr = details;
     1:   while (sdptr) {
  3118:     if (sdptr->mEnd > GetContentOffset() &&
  3118:         sdptr->mStart < GetContentEnd() &&
     1:         sdptr->mType == nsISelectionController::SELECTION_NORMAL) {
 80486:       found = true;
     1:       break;
     1:     }
     1:     sdptr = sdptr->mNext;
     1:   }
     1:   DestroySelectionDetails(details);
     1: 
     1:   return found;
     1: }
     1: 
  1443: /**
  1443:  * Compute the longest prefix of text whose width is <= aWidth. Return
  1443:  * the length of the prefix. Also returns the width of the prefix in aFitWidth.
  1443:  */
     1: static PRUint32
     1: CountCharsFit(gfxTextRun* aTextRun, PRUint32 aStart, PRUint32 aLength,
     8:               gfxFloat aWidth, PropertyProvider* aProvider,
     8:               gfxFloat* aFitWidth)
     1: {
     1:   PRUint32 last = 0;
  1443:   gfxFloat width = 0;
     1:   PRUint32 i;
     1:   for (i = 1; i <= aLength; ++i) {
     8:     if (i == aLength || aTextRun->IsClusterStart(aStart + i)) {
  1443:       gfxFloat nextWidth = width +
  1443:           aTextRun->GetAdvanceWidth(aStart + last, i - last, aProvider);
  1443:       if (nextWidth > aWidth)
  1443:         break;
  1443:       last = i;
  1443:       width = nextWidth;
  1443:     }
  1443:   }
  1443:   *aFitWidth = width;
     1:   return last;
     8: }
     1: 
     1: nsIFrame::ContentOffsets
 28352: nsTextFrame::CalcContentOffsetsFromFramePoint(nsPoint aPoint)
 28352: {
 80486:   return GetCharacterOffsetAtFramePointInternal(aPoint, true);
 28352: }
 28352: 
 28352: nsIFrame::ContentOffsets
 28352: nsTextFrame::GetCharacterOffsetAtFramePoint(const nsPoint &aPoint)
 28352: {
 80486:   return GetCharacterOffsetAtFramePointInternal(aPoint, false);
 28352: }
 28352: 
 28352: nsIFrame::ContentOffsets
 28352: nsTextFrame::GetCharacterOffsetAtFramePointInternal(const nsPoint &aPoint,
 79445:                                                     bool aForInsertionPoint)
 28352: {
     1:   ContentOffsets offsets;
     1:   
 82675:   gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
     1:   if (!mTextRun)
     1:     return offsets;
     1:   
 82675:   PropertyProvider provider(this, iter, nsTextFrame::eInflated);
     1:   // Trim leading but not trailing whitespace if possible
 80486:   provider.InitializeForDisplay(false);
     1:   gfxFloat width = mTextRun->IsRightToLeft() ? mRect.width - aPoint.x : aPoint.x;
     8:   gfxFloat fitWidth;
     1:   PRUint32 skippedLength = ComputeTransformedLength(provider);
     1: 
     1:   PRUint32 charsFit = CountCharsFit(mTextRun,
     8:       provider.GetStart().GetSkippedOffset(), skippedLength, width, &provider, &fitWidth);
     1: 
     1:   PRInt32 selectedOffset;
     1:   if (charsFit < skippedLength) {
     1:     // charsFit characters fitted, but no more could fit. See if we're
     1:     // more than halfway through the cluster.. If we are, choose the next
     1:     // cluster.
     1:     gfxSkipCharsIterator extraCluster(provider.GetStart());
     1:     extraCluster.AdvanceSkipped(charsFit);
     1:     gfxSkipCharsIterator extraClusterLastChar(extraCluster);
     1:     FindClusterEnd(mTextRun,
     1:                    provider.GetStart().GetOriginalOffset() + provider.GetOriginalLength(),
     1:                    &extraClusterLastChar);
     1:     gfxFloat charWidth =
     1:         mTextRun->GetAdvanceWidth(extraCluster.GetSkippedOffset(),
     1:                                   GetSkippedDistance(extraCluster, extraClusterLastChar) + 1,
     1:                                   &provider);
 28352:     selectedOffset = !aForInsertionPoint || width <= fitWidth + charWidth/2
     1:         ? extraCluster.GetOriginalOffset()
     1:         : extraClusterLastChar.GetOriginalOffset() + 1;
     1:   } else {
     1:     // All characters fitted, we're at (or beyond) the end of the text.
     1:     // XXX This could be some pathological situation where negative spacing
     1:     // caused characters to move backwards. We can't really handle that
     1:     // in the current frame system because frames can't have negative
     1:     // intrinsic widths.
     1:     selectedOffset =
     1:         provider.GetStart().GetOriginalOffset() + provider.GetOriginalLength();
 53725:     // If we're at the end of a preformatted line which has a terminating
 53725:     // linefeed, we want to reduce the offset by one to make sure that the
 53725:     // selection is placed before the linefeed character.
 53725:     if (GetStyleText()->NewlineIsSignificant() &&
 53725:         HasTerminalNewline()) {
 53725:       --selectedOffset;
 53725:     }
     1:   }
     1: 
     1:   offsets.content = GetContent();
     1:   offsets.offset = offsets.secondaryOffset = selectedOffset;
     1:   offsets.associateWithNext = mContentOffset == offsets.offset;
     1:   return offsets;
     1: }
     1: 
 79445: bool
 26883: nsTextFrame::CombineSelectionUnderlineRect(nsPresContext* aPresContext,
 26883:                                            nsRect& aRect)
 26883: {
 26883:   if (aRect.IsEmpty())
 80486:     return false;
 13714: 
 26883:   nsRect givenRect = aRect;
 26883: 
 68493:   nsRefPtr<nsFontMetrics> fm;
 82681:   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm),
 82681:                                         GetFontSizeInflation());
 68491:   gfxFontGroup* fontGroup = fm->GetThebesFontGroup();
 26883:   gfxFont* firstFont = fontGroup->GetFontAt(0);
 26883:   if (!firstFont)
 80486:     return false; // OOM
 26883:   const gfxFont::Metrics& metrics = firstFont->GetMetrics();
 26883:   gfxFloat underlineOffset = fontGroup->GetUnderlineOffset();
 26883:   gfxFloat ascent = aPresContext->AppUnitsToGfxUnits(mAscent);
 29850:   gfxFloat descentLimit =
 29850:     ComputeDescentLimitForSelectionUnderline(aPresContext, this, metrics);
 26883: 
 16640:   SelectionDetails *details = GetSelectionDetails();
 16640:   for (SelectionDetails *sd = details; sd; sd = sd->mNext) {
 26883:     if (sd->mStart == sd->mEnd || !(sd->mType & SelectionTypesWithDecorations))
 26883:       continue;
 26883: 
 26883:     PRUint8 style;
 26883:     float relativeSize;
 26883:     PRInt32 index =
 26883:       nsTextPaintStyle::GetUnderlineStyleIndexForSelectionType(sd->mType);
 27654:     if (sd->mType == nsISelectionController::SELECTION_SPELLCHECK) {
 26883:       if (!nsTextPaintStyle::GetSelectionUnderline(aPresContext, index, nsnull,
 26883:                                                    &relativeSize, &style)) {
 26883:         continue;
 26883:       }
 27654:     } else {
 27654:       // IME selections
 27654:       nsTextRangeStyle& rangeStyle = sd->mTextRangeStyle;
 27654:       if (rangeStyle.IsDefined()) {
 27654:         if (!rangeStyle.IsLineStyleDefined() ||
 27654:             rangeStyle.mLineStyle == nsTextRangeStyle::LINESTYLE_NONE) {
 27654:           continue;
 27654:         }
 64457:         style = rangeStyle.mLineStyle;
 27654:         relativeSize = rangeStyle.mIsBoldLine ? 2.0f : 1.0f;
 27654:       } else if (!nsTextPaintStyle::GetSelectionUnderline(aPresContext, index,
 27654:                                                           nsnull, &relativeSize,
 27654:                                                           &style)) {
 27654:         continue;
 27654:       }
 27654:     }
 26883:     nsRect decorationArea;
 26883:     gfxSize size(aPresContext->AppUnitsToGfxUnits(aRect.width),
 31685:                  ComputeSelectionUnderlineHeight(aPresContext,
 31685:                                                  metrics, sd->mType));
 32531:     relativeSize = NS_MAX(relativeSize, 1.0f);
 26883:     size.height *= relativeSize;
 26883:     decorationArea =
 26883:       nsCSSRendering::GetTextDecorationRect(aPresContext, size,
 68819:         ascent, underlineOffset, NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE,
 26988:         style, descentLimit);
 26883:     aRect.UnionRect(aRect, decorationArea);
 16640:   }
 16640:   DestroySelectionDetails(details);
 16640: 
 26883:   return !aRect.IsEmpty() && !givenRect.Contains(aRect);
 13714: }
 13714: 
 85101: bool
 85101: nsTextFrame::IsFrameSelected() const
 85101: {
 85101:   NS_ASSERTION(!GetContent() || GetContent()->IsSelectionDescendant(),
 85101:                "use the public IsSelected() instead");
 85101:   return nsRange::IsNodeSelected(GetContent(), GetContentOffset(),
 85101:                                  GetContentEnd());
 85101: }
 85101: 
 30695: void
 85101: nsTextFrame::SetSelectedRange(PRUint32 aStart, PRUint32 aEnd, bool aSelected,
 18931:                               SelectionType aType)
     1: {
 30695:   NS_ASSERTION(!GetPrevContinuation(), "Should only be called for primary frame");
     1:   DEBUG_VERIFY_NOT_DIRTY(mState);
 30695: 
 30695:   // Selection is collapsed, which can't affect text frame rendering
 30695:   if (aStart == aEnd)
 30695:     return;
 30695: 
 30695:   nsTextFrame* f = this;
 38653:   while (f && f->GetContentEnd() <= PRInt32(aStart)) {
 30695:     f = static_cast<nsTextFrame*>(f->GetNextContinuation());
 30695:   }
 30695: 
 30695:   nsPresContext* presContext = PresContext();
 38653:   while (f && f->GetContentOffset() < PRInt32(aEnd)) {
 30695:     // We may need to reflow to recompute the overflow area for
 30695:     // spellchecking or IME underline if their underline is thicker than
 30695:     // the normal decoration line.
 40484:     if (aType & SelectionTypesWithDecorations) {
 79445:       bool didHaveOverflowingSelection =
 30695:         (f->GetStateBits() & TEXT_SELECTION_UNDERLINE_OVERFLOWED) != 0;
 26883:       nsRect r(nsPoint(0, 0), GetSize());
 79445:       bool willHaveOverflowingSelection =
 30695:         aSelected && f->CombineSelectionUnderlineRect(presContext, r);
 28372:       if (didHaveOverflowingSelection || willHaveOverflowingSelection) {
 30695:         presContext->PresShell()->FrameNeedsReflow(f,
 11780:                                                    nsIPresShell::eStyleChange,
 11780:                                                    NS_FRAME_IS_DIRTY);
 11780:       }
 40484:     }
     1:     // Selection might change anything. Invalidate the overflow area.
 30695:     f->InvalidateOverflowRect();
 30695: 
 30695:     f = static_cast<nsTextFrame*>(f->GetNextContinuation());
 30695:   }
     1: }
     1: 
     1: NS_IMETHODIMP
  4741: nsTextFrame::GetPointFromOffset(PRInt32 inOffset,
     1:                                 nsPoint* outPoint)
     1: {
  4741:   if (!outPoint)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
     1:   outPoint->x = 0;
     1:   outPoint->y = 0;
     1: 
     1:   DEBUG_VERIFY_NOT_DIRTY(mState);
     1:   if (mState & NS_FRAME_IS_DIRTY)
     1:     return NS_ERROR_UNEXPECTED;
     1: 
  4678:   if (GetContentLength() <= 0) {
     1:     return NS_OK;
     1:   }
     1: 
 82675:   gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
     1:   if (!mTextRun)
     1:     return NS_ERROR_FAILURE;
     1: 
 82675:   PropertyProvider properties(this, iter, nsTextFrame::eInflated);
     1:   // Don't trim trailing whitespace, we want the caret to appear in the right
     1:   // place if it's positioned there
 80486:   properties.InitializeForDisplay(false);  
     1: 
  3118:   if (inOffset < GetContentOffset()){
     1:     NS_WARNING("offset before this frame's content");
  3118:     inOffset = GetContentOffset();
  3118:   } else if (inOffset > GetContentEnd()) {
     1:     NS_WARNING("offset after this frame's content");
  3118:     inOffset = GetContentEnd();
     1:   }
     1:   PRInt32 trimmedOffset = properties.GetStart().GetOriginalOffset();
     1:   PRInt32 trimmedEnd = trimmedOffset + properties.GetOriginalLength();
 32531:   inOffset = NS_MAX(inOffset, trimmedOffset);
 32531:   inOffset = NS_MIN(inOffset, trimmedEnd);
     1: 
     1:   iter.SetOriginalOffset(inOffset);
     1: 
     1:   if (inOffset < trimmedEnd &&
     1:       !iter.IsOriginalCharSkipped() &&
     8:       !mTextRun->IsClusterStart(iter.GetSkippedOffset())) {
     1:     NS_WARNING("GetPointFromOffset called for non-cluster boundary");
 38653:     FindClusterStart(mTextRun, trimmedOffset, &iter);
     1:   }
     1: 
     1:   gfxFloat advanceWidth =
     1:     mTextRun->GetAdvanceWidth(properties.GetStart().GetSkippedOffset(),
     1:                               GetSkippedDistance(properties.GetStart(), iter),
     1:                               &properties);
 21989:   nscoord width = NSToCoordCeilClamped(advanceWidth);
     1: 
     1:   if (mTextRun->IsRightToLeft()) {
     1:     outPoint->x = mRect.width - width;
     1:   } else {
     1:     outPoint->x = width;
     1:   }
     1:   outPoint->y = 0;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
  1732: nsTextFrame::GetChildFrameContainingOffset(PRInt32   aContentOffset,
 79445:                                            bool      aHint,
  1732:                                            PRInt32*  aOutOffset,
  1732:                                            nsIFrame**aOutFrame)
     1: {
     1:   DEBUG_VERIFY_NOT_DIRTY(mState);
     1: #if 0 //XXXrbs disable due to bug 310227
     1:   if (mState & NS_FRAME_IS_DIRTY)
     1:     return NS_ERROR_UNEXPECTED;
     1: #endif
     1: 
  1732:   NS_ASSERTION(aOutOffset && aOutFrame, "Bad out parameters");
  1732:   NS_ASSERTION(aContentOffset >= 0, "Negative content offset, existing code was very broken!");
 49293:   nsIFrame* primaryFrame = mContent->GetPrimaryFrame();
 49293:   if (this != primaryFrame) {
 49293:     // This call needs to happen on the primary frame
 49293:     return primaryFrame->GetChildFrameContainingOffset(aContentOffset, aHint,
 49293:                                                        aOutOffset, aOutFrame);
 49293:   }
  1732: 
  1732:   nsTextFrame* f = this;
 49293:   PRInt32 offset = mContentOffset;
 49293: 
 49293:   // Try to look up the offset to frame property
 49293:   nsTextFrame* cachedFrame = static_cast<nsTextFrame*>
 49293:     (Properties().Get(OffsetToFrameProperty()));
 49293: 
 49293:   if (cachedFrame) {
 49293:     f = cachedFrame;
 49293:     offset = f->GetContentOffset();
 49293: 
 49293:     f->RemoveStateBits(TEXT_IN_OFFSET_CACHE);
 49293:   }
 49293: 
 49293:   if ((aContentOffset >= offset) &&
 49293:       (aHint || aContentOffset != offset)) {
 80486:     while (true) {
  3233:       nsTextFrame* next = static_cast<nsTextFrame*>(f->GetNextContinuation());
  1732:       if (!next || aContentOffset < next->GetContentOffset())
  1732:         break;
  1732:       if (aContentOffset == next->GetContentOffset()) {
  1732:         if (aHint) {
  1732:           f = next;
  1732:         }
  1732:         break;
  1732:       }
  1732:       f = next;
  1732:     }
  1732:   } else {
 80486:     while (true) {
  3233:       nsTextFrame* prev = static_cast<nsTextFrame*>(f->GetPrevContinuation());
  1732:       if (!prev || aContentOffset > f->GetContentOffset())
  1732:         break;
  1732:       if (aContentOffset == f->GetContentOffset()) {
  1732:         if (!aHint) {
  1732:           f = prev;
  1732:         }
  1732:         break;
  1732:       }
  1732:       f = prev;
  1732:     }
  1732:   }
  1732:   
  1732:   *aOutOffset = aContentOffset - f->GetContentOffset();
  1732:   *aOutFrame = f;
 49293: 
 49293:   // cache the frame we found
 49293:   Properties().Set(OffsetToFrameProperty(), f);
 49293:   f->AddStateBits(TEXT_IN_OFFSET_CACHE);
 49293: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
 79445: nsTextFrame::PeekOffsetNoAmount(bool aForward, PRInt32* aOffset)
     1: {
  4678:   NS_ASSERTION(aOffset && *aOffset <= GetContentLength(), "aOffset out of range");
     1: 
 82675:   gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
     1:   if (!mTextRun)
 80486:     return false;
 80486: 
 80486:   TrimmedOffsets trimmed = GetTrimmedOffsets(mContent->GetText(), true);
     1:   // Check whether there are nonskipped characters in the trimmmed range
  4261:   return iter.ConvertOriginalToSkipped(trimmed.GetEnd()) >
     8:          iter.ConvertOriginalToSkipped(trimmed.mStart);
     1: }
     1: 
  2319: /**
  2319:  * This class iterates through the clusters before or after the given
  2319:  * aPosition (which is a content offset). You can test each cluster
  2319:  * to see if it's whitespace (as far as selection/caret movement is concerned),
  2319:  * or punctuation, or if there is a word break before the cluster. ("Before"
  2319:  * is interpreted according to aDirection, so if aDirection is -1, "before"
  2319:  * means actually *after* the cluster content.)
  2319:  */
 15599: class NS_STACK_CLASS ClusterIterator {
  2319: public:
  7679:   ClusterIterator(nsTextFrame* aTextFrame, PRInt32 aPosition, PRInt32 aDirection,
  7679:                   nsString& aContext);
  2319: 
 79445:   bool NextCluster();
 79445:   bool IsWhitespace();
 79445:   bool IsPunctuation();
 79445:   bool HaveWordBreakBefore() { return mHaveWordBreak; }
  2319:   PRInt32 GetAfterOffset();
  2319:   PRInt32 GetBeforeOffset();
  2319: 
  2319: private:
  2319:   gfxSkipCharsIterator        mIterator;
  2319:   const nsTextFragment*       mFrag;
  2319:   nsTextFrame*                mTextFrame;
  2319:   PRInt32                     mDirection;
  2319:   PRInt32                     mCharIndex;
  2319:   nsTextFrame::TrimmedOffsets mTrimmed;
 79445:   nsTArray<bool>      mWordBreaks;
 79445:   bool                        mHaveWordBreak;
  2319: };
  2319: 
 79445: static bool
 59604: IsAcceptableCaretPosition(const gfxSkipCharsIterator& aIter,
 79445:                           bool aRespectClusters,
 59604:                           gfxTextRun* aTextRun,
  8085:                           nsIFrame* aFrame)
  8085: {
  8085:   if (aIter.IsOriginalCharSkipped())
 80486:     return false;
  8085:   PRUint32 index = aIter.GetSkippedOffset();
 59604:   if (aRespectClusters && !aTextRun->IsClusterStart(index))
 80486:     return false;
 59604:   if (index > 0) {
 59604:     // Check whether the proposed position is in between the two halves of a
 59604:     // surrogate pair; if so, this is not a valid character boundary.
 59604:     // (In the case where we are respecting clusters, we won't actually get
 59604:     // this far because the low surrogate is also marked as non-clusterStart
 59604:     // so we'll return FALSE above.)
 86697:     if (aTextRun->CharIsLowSurrogate(index)) {
 80486:       return false;
 80486:     }
 86697:   }
 80486:   return true;
  8085: }
  8085: 
 79445: bool
 79445: nsTextFrame::PeekOffsetCharacter(bool aForward, PRInt32* aOffset,
 79445:                                  bool aRespectClusters)
     1: {
  4678:   PRInt32 contentLength = GetContentLength();
  4678:   NS_ASSERTION(aOffset && *aOffset <= contentLength, "aOffset out of range");
     1: 
 79445:   bool selectable;
     1:   PRUint8 selectStyle;  
     1:   IsSelectable(&selectable, &selectStyle);
     1:   if (selectStyle == NS_STYLE_USER_SELECT_ALL)
 80486:     return false;
     1: 
 82675:   gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
     1:   if (!mTextRun)
 80486:     return false;
 80486: 
 80486:   TrimmedOffsets trimmed = GetTrimmedOffsets(mContent->GetText(), false);
     1: 
     1:   // A negative offset means "end of frame".
  4678:   PRInt32 startOffset = GetContentOffset() + (*aOffset < 0 ? contentLength : *aOffset);
     1: 
     1:   if (!aForward) {
 53724:     // If at the beginning of the line, look at the previous continuation
 53724:     for (PRInt32 i = NS_MIN(trimmed.GetEnd(), startOffset) - 1;
     8:          i >= trimmed.mStart; --i) {
     1:       iter.SetOriginalOffset(i);
 59604:       if (IsAcceptableCaretPosition(iter, aRespectClusters, mTextRun, this)) {
     1:         *aOffset = i - mContentOffset;
 80486:         return true;
     1:       }
     1:     }
   202:     *aOffset = 0;
     1:   } else {
 53724:     // If we're at the end of a line, look at the next continuation
 53724:     iter.SetOriginalOffset(startOffset);
 56878:     if (startOffset <= trimmed.GetEnd() &&
 56878:         !(startOffset < trimmed.GetEnd() &&
 53724:           GetStyleText()->NewlineIsSignificant() &&
 54373:           iter.GetSkippedOffset() < mTextRun->GetLength() &&
 86697:           mTextRun->CharIsNewline(iter.GetSkippedOffset()))) {
 53724:       for (PRInt32 i = startOffset + 1; i <= trimmed.GetEnd(); ++i) {
     1:         iter.SetOriginalOffset(i);
  4261:         if (i == trimmed.GetEnd() ||
 59604:             IsAcceptableCaretPosition(iter, aRespectClusters, mTextRun, this)) {
     1:           *aOffset = i - mContentOffset;
 80486:           return true;
     1:         }
     1:       }
 53724:     }
  4678:     *aOffset = contentLength;
     1:   }
     1:   
 80486:   return false;
     1: }
     1: 
 79445: bool
  2319: ClusterIterator::IsWhitespace()
  2319: {
  2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
  2319:   return IsSelectionSpace(mFrag, mCharIndex);
  2319: }
  2319: 
 79445: bool
  2319: ClusterIterator::IsPunctuation()
  2319: {
  2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
 90892:   nsIUGenCategory::nsUGenCategory c =
 90892:     mozilla::unicode::GetGenCategory(mFrag->CharAt(mCharIndex));
  5453:   return c == nsIUGenCategory::kPunctuation || c == nsIUGenCategory::kSymbol;
  2319: }
  2319: 
  2319: PRInt32
  2319: ClusterIterator::GetBeforeOffset()
  2319: {
  2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
  2319:   return mCharIndex + (mDirection > 0 ? 0 : 1);
  2319: }
  2319: 
  2319: PRInt32
  2319: ClusterIterator::GetAfterOffset()
  2319: {
  2678:   NS_ASSERTION(mCharIndex >= 0, "No cluster selected");
  2319:   return mCharIndex + (mDirection > 0 ? 1 : 0);
  2319: }
  2319: 
 79445: bool
  2319: ClusterIterator::NextCluster()
  2319: {
  2319:   if (!mDirection)
 80486:     return false;
 82675:   gfxTextRun* textRun = mTextFrame->GetTextRun(nsTextFrame::eInflated);
  2319: 
 80486:   mHaveWordBreak = false;
 80486:   while (true) {
 79445:     bool keepGoing = false;
  2319:     if (mDirection > 0) {
  4261:       if (mIterator.GetOriginalOffset() >= mTrimmed.GetEnd())
 80486:         return false;
  6802:       keepGoing = mIterator.IsOriginalCharSkipped() ||
  2319:           mIterator.GetOriginalOffset() < mTrimmed.mStart ||
  6802:           !textRun->IsClusterStart(mIterator.GetSkippedOffset());
  2319:       mCharIndex = mIterator.GetOriginalOffset();
  2319:       mIterator.AdvanceOriginal(1);
  2319:     } else {
  2319:       if (mIterator.GetOriginalOffset() <= mTrimmed.mStart)
 80486:         return false;
  2319:       mIterator.AdvanceOriginal(-1);
  6802:       keepGoing = mIterator.IsOriginalCharSkipped() ||
  4261:           mIterator.GetOriginalOffset() >= mTrimmed.GetEnd() ||
  6802:           !textRun->IsClusterStart(mIterator.GetSkippedOffset());
  2319:       mCharIndex = mIterator.GetOriginalOffset();
  2319:     }
  2319: 
  6802:     if (mWordBreaks[GetBeforeOffset() - mTextFrame->GetContentOffset()]) {
 80486:       mHaveWordBreak = true;
  6802:     }
  6802:     if (!keepGoing)
 80486:       return true;
  2319:   }
  2319: }
  2319: 
  2319: ClusterIterator::ClusterIterator(nsTextFrame* aTextFrame, PRInt32 aPosition,
  7679:                                  PRInt32 aDirection, nsString& aContext)
  2319:   : mTextFrame(aTextFrame), mDirection(aDirection), mCharIndex(-1)
  2319: {
 82675:   mIterator = aTextFrame->EnsureTextRun(nsTextFrame::eInflated);
 82675:   if (!aTextFrame->GetTextRun(nsTextFrame::eInflated)) {
  2319:     mDirection = 0; // signal failure
  2319:     return;
  2319:   }
  2319:   mIterator.SetOriginalOffset(aPosition);
  2319: 
 35581:   mFrag = aTextFrame->GetContent()->GetText();
 80486:   mTrimmed = aTextFrame->GetTrimmedOffsets(mFrag, true);
  2319: 
  6802:   PRInt32 textOffset = aTextFrame->GetContentOffset();
  3438:   PRInt32 textLen = aTextFrame->GetContentLength();
  5453:   if (!mWordBreaks.AppendElements(textLen + 1)) {
  2319:     mDirection = 0; // signal failure
  2319:     return;
  2319:   }
 89518:   memset(mWordBreaks.Elements(), false, (textLen + 1)*sizeof(bool));
  7679:   PRInt32 textStart;
  7679:   if (aDirection > 0) {
  7679:     if (aContext.IsEmpty()) {
  7679:       // No previous context, so it must be the start of a line or text run
 80486:       mWordBreaks[0] = true;
  7679:     }
  7679:     textStart = aContext.Length();
  7679:     mFrag->AppendTo(aContext, textOffset, textLen);
  7679:   } else {
  7679:     if (aContext.IsEmpty()) {
  7679:       // No following context, so it must be the end of a line or text run
 80486:       mWordBreaks[textLen] = true;
  7679:     }
  7679:     textStart = 0;
  7679:     nsAutoString str;
  7679:     mFrag->AppendTo(str, textOffset, textLen);
  7679:     aContext.Insert(str, 0);
  7679:   }
  2319:   nsIWordBreaker* wordBreaker = nsContentUtils::WordBreaker();
  7679:   PRInt32 i;
  7679:   for (i = 0; i <= textLen; ++i) {
  7679:     PRInt32 indexInText = i + textStart;
  7679:     mWordBreaks[i] |=
  7679:       wordBreaker->BreakInBetween(aContext.get(), indexInText,
  7679:                                   aContext.get() + indexInText,
  7679:                                   aContext.Length() - indexInText);
  6802:   }
  5453: }
  2319: 
 79445: bool
 79445: nsTextFrame::PeekOffsetWord(bool aForward, bool aWordSelectEatSpace, bool aIsKeyboardSelect,
  5453:                             PRInt32* aOffset, PeekWordState* aState)
     1: {
  4678:   PRInt32 contentLength = GetContentLength();
  4678:   NS_ASSERTION (aOffset && *aOffset <= contentLength, "aOffset out of range");
     1: 
 79445:   bool selectable;
     1:   PRUint8 selectStyle;
     1:   IsSelectable(&selectable, &selectStyle);
     1:   if (selectStyle == NS_STYLE_USER_SELECT_ALL)
 80486:     return false;
     1: 
  4678:   PRInt32 offset = GetContentOffset() + (*aOffset < 0 ? contentLength : *aOffset);
  7679:   ClusterIterator cIter(this, offset, aForward ? 1 : -1, aState->mContext);
  2678: 
  2678:   if (!cIter.NextCluster())
 80486:     return false;
  2678: 
  2678:   do {
 79445:     bool isPunctuation = cIter.IsPunctuation();
 79445:     bool isWhitespace = cIter.IsWhitespace();
 79445:     bool isWordBreakBefore = cIter.HaveWordBreakBefore();
 12505:     if (aWordSelectEatSpace == isWhitespace && !aState->mSawBeforeType) {
  5453:       aState->SetSawBeforeType();
 12505:       aState->Update(isPunctuation, isWhitespace);
  2678:       continue;
  2678:     }
  5453:     // See if we can break before the current cluster
  5453:     if (!aState->mAtStart) {
 79445:       bool canBreak;
 15752:       if (isPunctuation != aState->mLastCharWasPunctuation) {
 15752:         canBreak = BreakWordBetweenPunctuation(aState, aForward,
 15752:                      isPunctuation, isWhitespace, aIsKeyboardSelect);
 15752:       } else if (!aState->mLastCharWasWhitespace &&
 15752:                  !isWhitespace && !isPunctuation && isWordBreakBefore) {
 15752:         // if both the previous and the current character are not white
 15752:         // space but this can be word break before, we don't need to eat
 15752:         // a white space in this case. This case happens in some languages
 15752:         // that their words are not separated by white spaces. E.g.,
 15752:         // Japanese and Chinese.
 80486:         canBreak = true;
 15752:       } else {
 15752:         canBreak = isWordBreakBefore && aState->mSawBeforeType;
 15752:       }
  5453:       if (canBreak) {
  2319:         *aOffset = cIter.GetBeforeOffset() - mContentOffset;
 80486:         return true;
  2319:       }
  5453:     }
 12505:     aState->Update(isPunctuation, isWhitespace);
  2678:   } while (cIter.NextCluster());
  2678: 
  2319:   *aOffset = cIter.GetAfterOffset() - mContentOffset;
 80486:   return false;
     1: }
     1: 
     1:  // TODO this needs to be deCOMtaminated with the interface fixed in
     1: // nsIFrame.h, but we won't do that until the old textframe is gone.
     1: NS_IMETHODIMP
     1: nsTextFrame::CheckVisibility(nsPresContext* aContext, PRInt32 aStartIndex,
 79445:     PRInt32 aEndIndex, bool aRecurse, bool *aFinished, bool *aRetval)
     1: {
     1:   if (!aRetval)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
     1:   // Text in the range is visible if there is at least one character in the range
     1:   // that is not skipped and is mapped by this frame (which is the primary frame)
     1:   // or one of its continuations.
     1:   for (nsTextFrame* f = this; f;
  3233:        f = static_cast<nsTextFrame*>(GetNextContinuation())) {
 61939:     PRInt32 dummyOffset = 0;
 80486:     if (f->PeekOffsetNoAmount(true, &dummyOffset)) {
 80486:       *aRetval = true;
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
 80486:   *aRetval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextFrame::GetOffsets(PRInt32 &start, PRInt32 &end) const
     1: {
  3118:   start = GetContentOffset();
  3118:   end = GetContentEnd();
     1:   return NS_OK;
     1: }
     1: 
 15634: static PRInt32
 15634: FindEndOfPunctuationRun(const nsTextFragment* aFrag,
 15634:                         gfxTextRun* aTextRun,
 15634:                         gfxSkipCharsIterator* aIter,
 15634:                         PRInt32 aOffset,
 15634:                         PRInt32 aStart,
 15634:                         PRInt32 aEnd)
 15634: {
 15634:   PRInt32 i;
 15634: 
 15634:   for (i = aStart; i < aEnd - aOffset; ++i) {
 91335:     if (nsContentUtils::IsFirstLetterPunctuationAt(aFrag, aOffset + i)) {
 15634:       aIter->SetOriginalOffset(aOffset + i);
 15634:       FindClusterEnd(aTextRun, aEnd, aIter);
 15634:       i = aIter->GetOriginalOffset() - aOffset;
 15634:     } else {
 15634:       break;
 15634:     }
 15634:   }
 15634:   return i;
 15634: }
 15634: 
  3118: /**
 80486:  * Returns true if this text frame completes the first-letter, false
  3118:  * if it does not contain a true "letter".
 80486:  * If returns true, then it also updates aLength to cover just the first-letter
  3118:  * text.
  3118:  *
  3118:  * XXX :first-letter should be handled during frame construction
  3118:  * (and it has a good bit in common with nextBidi)
  3118:  * 
  3118:  * @param aLength an in/out parameter: on entry contains the maximum length to
  3118:  * return, on exit returns length of the first-letter fragment (which may
 15634:  * include leading and trailing punctuation, for example)
  3118:  */
 79445: static bool
     1: FindFirstLetterRange(const nsTextFragment* aFrag,
     1:                      gfxTextRun* aTextRun,
  3417:                      PRInt32 aOffset, const gfxSkipCharsIterator& aIter,
  3417:                      PRInt32* aLength)
     1: {
     1:   PRInt32 i;
     1:   PRInt32 length = *aLength;
 15634:   PRInt32 endOffset = aOffset + length;
 15634:   gfxSkipCharsIterator iter(aIter);
 15634: 
 15634:   // skip leading whitespace, then consume clusters that start with punctuation
 15634:   i = FindEndOfPunctuationRun(aFrag, aTextRun, &iter, aOffset, 
 15634:                               GetTrimmableWhitespaceCount(aFrag, aOffset, length, 1),
 15634:                               endOffset);
     1:   if (i == length)
 80486:     return false;
     1: 
 15634:   // If the next character is not a letter or number, there is no first-letter.
 80486:   // Return true so that we don't go on looking, but set aLength to 0.
 15634:   if (!nsContentUtils::IsAlphanumericAt(aFrag, aOffset + i)) {
 15634:     *aLength = 0;
 80486:     return true;
 15634:   }
 15634: 
 15634:   // consume another cluster (the actual first letter)
 15634:   iter.SetOriginalOffset(aOffset + i);
 15634:   FindClusterEnd(aTextRun, endOffset, &iter);
 15634:   i = iter.GetOriginalOffset() - aOffset;
 15634:   if (i + 1 == length)
 80486:     return true;
 15634: 
 15634:   // consume clusters that start with punctuation
 15634:   i = FindEndOfPunctuationRun(aFrag, aTextRun, &iter, aOffset, i + 1, endOffset);
 15634:   if (i < length)
 15634:     *aLength = i;
 80486:   return true;
     1: }
     1: 
     1: static PRUint32
     8: FindStartAfterSkippingWhitespace(PropertyProvider* aProvider,
     8:                                  nsIFrame::InlineIntrinsicWidthData* aData,
 16575:                                  const nsStyleText* aTextStyle,
     8:                                  gfxSkipCharsIterator* aIterator,
     8:                                  PRUint32 aFlowEndInTextRun)
     1: {
 16575:   if (aData->skipWhitespace) {
     8:     while (aIterator->GetSkippedOffset() < aFlowEndInTextRun &&
 16575:            IsTrimmableSpace(aProvider->GetFragment(), aIterator->GetOriginalOffset(), aTextStyle)) {
  2013:       aIterator->AdvanceOriginal(1);
     8:     }
     8:   }
     8:   return aIterator->GetSkippedOffset();
     1: }
     1: 
 82675: union VoidPtrOrFloat {
 82675:   VoidPtrOrFloat() : p(nsnull) {}
 82675: 
 82675:   void *p;
 82675:   float f;
 82675: };
 82675: 
 82675: float
 82675: nsTextFrame::GetFontSizeInflation() const
 82675: {
 82675:   if (!HasFontSizeInflation()) {
 82675:     return 1.0f;
 82675:   }
 82675:   VoidPtrOrFloat u;
 82675:   u.p = Properties().Get(FontSizeInflationProperty());
 82675:   return u.f;
 82675: }
 82675: 
 82675: void
 82675: nsTextFrame::SetFontSizeInflation(float aInflation)
 82675: {
 82675:   if (aInflation == 1.0f) {
 82675:     if (HasFontSizeInflation()) {
 82675:       RemoveStateBits(TEXT_HAS_FONT_INFLATION);
 82675:       Properties().Delete(FontSizeInflationProperty());
 82675:     }
 82675:     return;
 82675:   }
 82675: 
 82675:   AddStateBits(TEXT_HAS_FONT_INFLATION);
 82675:   VoidPtrOrFloat u;
 82675:   u.f = aInflation;
 82675:   Properties().Set(FontSizeInflationProperty(), u.p);
 82675: }
 82675: 
  1284: /* virtual */ 
  1284: void nsTextFrame::MarkIntrinsicWidthsDirty()
  1284: {
 82675:   ClearTextRuns();
  1284:   nsFrame::MarkIntrinsicWidthsDirty();
  1284: }
  1284: 
     1: // XXX this doesn't handle characters shaped by line endings. We need to
     1: // temporarily override the "current line ending" settings.
     1: void
 68481: nsTextFrame::AddInlineMinWidthForFlow(nsRenderingContext *aRenderingContext,
 88125:                                       nsIFrame::InlineMinWidthData *aData,
 88125:                                       TextRunType aTextRunType)
     1: {
     1:   PRUint32 flowEndInTextRun;
  9438:   gfxContext* ctx = aRenderingContext->ThebesContext();
     1:   gfxSkipCharsIterator iter =
 94144:     EnsureTextRun(aTextRunType, ctx, aData->lineContainer,
 82675:                   aData->line, &flowEndInTextRun);
 88125:   gfxTextRun *textRun = GetTextRun(aTextRunType);
 82675:   if (!textRun)
     1:     return;
     1: 
  1732:   // Pass null for the line container. This will disable tab spacing, but that's
  1732:   // OK since we can't really handle tabs for intrinsic sizing anyway.
 16575:   const nsStyleText* textStyle = GetStyleText();
 35581:   const nsTextFragment* frag = mContent->GetText();
 64410: 
 64410:   // If we're hyphenating, the PropertyProvider needs the actual length;
 64410:   // otherwise we can just pass PR_INT32_MAX to mean "all the text"
 64410:   PRInt32 len = PR_INT32_MAX;
 79445:   bool hyphenating = frag->GetLength() > 0 &&
 69311:     (textStyle->mHyphens == NS_STYLE_HYPHENS_AUTO ||
 69311:      (textStyle->mHyphens == NS_STYLE_HYPHENS_MANUAL &&
 82675:       (textRun->GetFlags() & gfxTextRunFactory::TEXT_ENABLE_HYPHEN_BREAKS) != 0));
 64410:   if (hyphenating) {
 68645:     gfxSkipCharsIterator tmp(iter);
 72496:     len = NS_MIN<PRInt32>(GetContentOffset() + GetInFlowContentLength(),
 68645:                  tmp.ConvertSkippedToOriginal(flowEndInTextRun)) - iter.GetOriginalOffset();
 64410:   }
 82675:   PropertyProvider provider(textRun, textStyle, frag, this,
 88125:                             iter, len, nsnull, 0, aTextRunType);
     8: 
 79445:   bool collapseWhitespace = !textStyle->WhiteSpaceIsSignificant();
 79445:   bool preformatNewlines = textStyle->NewlineIsSignificant();
 79445:   bool preformatTabs = textStyle->WhiteSpaceIsSignificant();
 16705:   gfxFloat tabWidth = -1;
     8:   PRUint32 start =
 16575:     FindStartAfterSkippingWhitespace(&provider, aData, textStyle, &iter, flowEndInTextRun);
     8: 
 87328:   AutoFallibleTArray<bool,BIG_TEXT_NODE_SIZE> hyphBuffer;
 79445:   bool *hyphBreakBefore = nsnull;
 64410:   if (hyphenating) {
 64410:     hyphBreakBefore = hyphBuffer.AppendElements(flowEndInTextRun - start);
 64410:     if (hyphBreakBefore) {
 64410:       provider.GetHyphenationBreaks(start, flowEndInTextRun - start,
 64410:                                     hyphBreakBefore);
 64410:     }
 64410:   }
 64410: 
  2668:   for (PRUint32 i = start, wordStart = start; i <= flowEndInTextRun; ++i) {
 79445:     bool preformattedNewline = false;
 79445:     bool preformattedTab = false;
  2668:     if (i < flowEndInTextRun) {
  2668:       // XXXldb Shouldn't we be including the newline as part of the
  2668:       // segment that it ends rather than part of the segment that it
  2668:       // starts?
 86697:       preformattedNewline = preformatNewlines && textRun->CharIsNewline(i);
 86697:       preformattedTab = preformatTabs && textRun->CharIsTab(i);
 82675:       if (!textRun->CanBreakLineBefore(i) &&
 64410:           !preformattedNewline &&
 64410:           !preformattedTab &&
 64410:           (!hyphBreakBefore || !hyphBreakBefore[i - start]))
 64410:       {
  2668:         // we can't break here (and it's not the end of the flow)
     8:         continue;
  2347:       }
  2347:     }
     8: 
  2668:     if (i > wordStart) {
     8:       nscoord width =
 82675:         NSToCoordCeilClamped(textRun->GetAdvanceWidth(wordStart, i - wordStart, &provider));
 21989:       aData->currentLine = NSCoordSaturatingAdd(aData->currentLine, width);
 80486:       aData->atStartOfLine = false;
     8: 
     8:       if (collapseWhitespace) {
 16575:         PRUint32 trimStart = GetEndOfTrimmedText(frag, textStyle, wordStart, i, &iter);
  2013:         if (trimStart == start) {
  6529:           // This is *all* trimmable whitespace, so whatever trailingWhitespace
  6529:           // we saw previously is still trailing...
  6529:           aData->trailingWhitespace += width;
     8:         } else {
  6529:           // Some non-whitespace so the old trailingWhitespace is no longer trailing
  6529:           aData->trailingWhitespace =
 82675:             NSToCoordCeilClamped(textRun->GetAdvanceWidth(trimStart, i - trimStart, &provider));
     8:         }
     8:       } else {
     1:         aData->trailingWhitespace = 0;
     8:       }
  2668:     }
  2668: 
 16705:     if (preformattedTab) {
 16705:       PropertyProvider::Spacing spacing;
 16705:       provider.GetSpacing(i, 1, &spacing);
 16705:       aData->currentLine += nscoord(spacing.mBefore);
 16705:       gfxFloat afterTab =
 33208:         AdvanceToNextTab(aData->currentLine, this,
 82675:                          textRun, &tabWidth);
 16705:       aData->currentLine = nscoord(afterTab + spacing.mAfter);
 16705:       wordStart = i + 1;
 16705:     } else if (i < flowEndInTextRun ||
 82675:         (i == textRun->GetLength() &&
 82675:          (textRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK))) {
  2668:       if (preformattedNewline) {
  2668:         aData->ForceBreak(aRenderingContext);
 69491:       } else if (i < flowEndInTextRun && hyphBreakBefore &&
 69491:                  hyphBreakBefore[i - start])
 69491:       {
 73750:         aData->OptionallyBreak(aRenderingContext, 
 73750:                                NSToCoordRound(provider.GetHyphenWidth()));
 69311:       } {
  2668:         aData->OptionallyBreak(aRenderingContext);
  2668:       }
     1:       wordStart = i;
     1:     }
     1:   }
     1: 
 21940:   if (start < flowEndInTextRun) {
  6529:     // Check if we have collapsible whitespace at the end
     8:     aData->skipWhitespace =
 16575:       IsTrimmableSpace(provider.GetFragment(),
 16575:                        iter.ConvertSkippedToOriginal(flowEndInTextRun - 1),
 16575:                        textStyle);
     1:   }
 21940: }
     1: 
     1: // XXX Need to do something here to avoid incremental reflow bugs due to
     1: // first-line and first-letter changing min-width
     1: /* virtual */ void
 68481: nsTextFrame::AddInlineMinWidth(nsRenderingContext *aRenderingContext,
     1:                                nsIFrame::InlineMinWidthData *aData)
     1: {
 98995:   float inflation = nsLayoutUtils::FontSizeInflationFor(this);
 88125:   TextRunType trtype = (inflation == 1.0f) ? eNotInflated : eInflated;
 88125: 
101218:   if (trtype == eInflated && inflation != GetFontSizeInflation()) {
101218:     // FIXME: Ideally, if we already have a text run, we'd move it to be
101218:     // the uninflated text run.
101218:     ClearTextRun(nsnull, nsTextFrame::eInflated);
101218:   }
101218: 
  2679:   nsTextFrame* f;
  2679:   gfxTextRun* lastTextRun = nsnull;
  2679:   // nsContinuingTextFrame does nothing for AddInlineMinWidth; all text frames
  2679:   // in the flow are handled right here.
  3233:   for (f = this; f; f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
 82675:     // f->GetTextRun(nsTextFrame::eNotInflated) could be null if we
 82675:     // haven't set up textruns yet for f.  Except in OOM situations,
 82675:     // lastTextRun will only be null for the first text frame.
 88125:     if (f == this || f->GetTextRun(trtype) != lastTextRun) {
 24819:       nsIFrame* lc;
 24819:       if (aData->lineContainer &&
 24819:           aData->lineContainer != (lc = FindLineContainer(f))) {
 24819:         NS_ASSERTION(f != this, "wrong InlineMinWidthData container"
 24819:                                 " for first continuation");
 24819:         aData->line = nsnull;
 24819:         aData->lineContainer = lc;
 24819:       }
 24819: 
  2679:       // This will process all the text frames that share the same textrun as f.
 94144:       f->AddInlineMinWidthForFlow(aRenderingContext, aData, trtype);
 88125:       lastTextRun = f->GetTextRun(trtype);
     1:     }
     1:   }
     1: }
     1: 
     1: // XXX this doesn't handle characters shaped by line endings. We need to
     1: // temporarily override the "current line ending" settings.
     1: void
 68481: nsTextFrame::AddInlinePrefWidthForFlow(nsRenderingContext *aRenderingContext,
 88125:                                        nsIFrame::InlinePrefWidthData *aData,
 88125:                                        TextRunType aTextRunType)
     1: {
     1:   PRUint32 flowEndInTextRun;
  9438:   gfxContext* ctx = aRenderingContext->ThebesContext();
     1:   gfxSkipCharsIterator iter =
 94144:     EnsureTextRun(aTextRunType, ctx, aData->lineContainer,
 82675:                   aData->line, &flowEndInTextRun);
 88125:   gfxTextRun *textRun = GetTextRun(aTextRunType);
 82675:   if (!textRun)
     1:     return;
     1: 
  1732:   // Pass null for the line container. This will disable tab spacing, but that's
  1732:   // OK since we can't really handle tabs for intrinsic sizing anyway.
 16575:   
 16575:   const nsStyleText* textStyle = GetStyleText();
 35581:   const nsTextFragment* frag = mContent->GetText();
 82675:   PropertyProvider provider(textRun, textStyle, frag, this,
 88125:                             iter, PR_INT32_MAX, nsnull, 0, aTextRunType);
     8: 
 79445:   bool collapseWhitespace = !textStyle->WhiteSpaceIsSignificant();
 79445:   bool preformatNewlines = textStyle->NewlineIsSignificant();
 79445:   bool preformatTabs = textStyle->WhiteSpaceIsSignificant();
 16705:   gfxFloat tabWidth = -1;
     8:   PRUint32 start =
 16575:     FindStartAfterSkippingWhitespace(&provider, aData, textStyle, &iter, flowEndInTextRun);
     8: 
 16575:   // XXX Should we consider hyphenation here?
 16705:   // If newlines and tabs aren't preformatted, nothing to do inside
 16705:   // the loop so make i skip to the end
 16705:   PRUint32 loopStart = (preformatNewlines || preformatTabs) ? start : flowEndInTextRun;
 16705:   for (PRUint32 i = loopStart, lineStart = start; i <= flowEndInTextRun; ++i) {
 79445:     bool preformattedNewline = false;
 79445:     bool preformattedTab = false;
 16575:     if (i < flowEndInTextRun) {
 16575:       // XXXldb Shouldn't we be including the newline as part of the
 16575:       // segment that it ends rather than part of the segment that it
 16575:       // starts?
 16575:       NS_ASSERTION(preformatNewlines, "We can't be here unless newlines are hard breaks");
 86697:       preformattedNewline = preformatNewlines && textRun->CharIsNewline(i);
 86697:       preformattedTab = preformatTabs && textRun->CharIsTab(i);
 16705:       if (!preformattedNewline && !preformattedTab) {
 16575:         // we needn't break here (and it's not the end of the flow)
 16575:         continue;
 16575:       }
 16575:     }
 16575: 
 16575:     if (i > lineStart) {
 16575:       nscoord width =
 82675:         NSToCoordCeilClamped(textRun->GetAdvanceWidth(lineStart, i - lineStart, &provider));
 16575:       aData->currentLine = NSCoordSaturatingAdd(aData->currentLine, width);
 16575: 
     8:       if (collapseWhitespace) {
 16575:         PRUint32 trimStart = GetEndOfTrimmedText(frag, textStyle, lineStart, i, &iter);
  2013:         if (trimStart == start) {
     8:           // This is *all* trimmable whitespace, so whatever trailingWhitespace
     8:           // we saw previously is still trailing...
  6529:           aData->trailingWhitespace += width;
     1:         } else {
     8:           // Some non-whitespace so the old trailingWhitespace is no longer trailing
  6529:           aData->trailingWhitespace =
 82675:             NSToCoordCeilClamped(textRun->GetAdvanceWidth(trimStart, i - trimStart, &provider));
     1:         }
     1:       } else {
  2742:         aData->trailingWhitespace = 0;
 16575:       }
 16575:     }
 16575: 
 16705:     if (preformattedTab) {
 16705:       PropertyProvider::Spacing spacing;
 16705:       provider.GetSpacing(i, 1, &spacing);
 16705:       aData->currentLine += nscoord(spacing.mBefore);
 16705:       gfxFloat afterTab =
 33208:         AdvanceToNextTab(aData->currentLine, this,
 82675:                          textRun, &tabWidth);
 16705:       aData->currentLine = nscoord(afterTab + spacing.mAfter);
 16705:       lineStart = i + 1;
 16705:     } else if (preformattedNewline) {
  2668:       aData->ForceBreak(aRenderingContext);
 16575:       lineStart = i;
  2742:     }
     8:   }
     8: 
  6529:   // Check if we have collapsible whitespace at the end
 21940:   if (start < flowEndInTextRun) {
     8:     aData->skipWhitespace =
 16575:       IsTrimmableSpace(provider.GetFragment(),
 16575:                        iter.ConvertSkippedToOriginal(flowEndInTextRun - 1),
 16575:                        textStyle);
     1:   }
 21940: }
     1: 
     1: // XXX Need to do something here to avoid incremental reflow bugs due to
     1: // first-line and first-letter changing pref-width
     1: /* virtual */ void
 68481: nsTextFrame::AddInlinePrefWidth(nsRenderingContext *aRenderingContext,
     1:                                 nsIFrame::InlinePrefWidthData *aData)
     1: {
 98995:   float inflation = nsLayoutUtils::FontSizeInflationFor(this);
 88125:   TextRunType trtype = (inflation == 1.0f) ? eNotInflated : eInflated;
 88125: 
101218:   if (trtype == eInflated && inflation != GetFontSizeInflation()) {
101218:     // FIXME: Ideally, if we already have a text run, we'd move it to be
101218:     // the uninflated text run.
101218:     ClearTextRun(nsnull, nsTextFrame::eInflated);
101218:   }
101218: 
  2679:   nsTextFrame* f;
  2679:   gfxTextRun* lastTextRun = nsnull;
  2679:   // nsContinuingTextFrame does nothing for AddInlineMinWidth; all text frames
  2679:   // in the flow are handled right here.
  3233:   for (f = this; f; f = static_cast<nsTextFrame*>(f->GetNextContinuation())) {
 82675:     // f->GetTextRun(nsTextFrame::eNotInflated) could be null if we
 82675:     // haven't set up textruns yet for f.  Except in OOM situations,
 82675:     // lastTextRun will only be null for the first text frame.
 88125:     if (f == this || f->GetTextRun(trtype) != lastTextRun) {
 24819:       nsIFrame* lc;
 24819:       if (aData->lineContainer &&
 24819:           aData->lineContainer != (lc = FindLineContainer(f))) {
 24819:         NS_ASSERTION(f != this, "wrong InlinePrefWidthData container"
 24819:                                 " for first continuation");
 24819:         aData->line = nsnull;
 24819:         aData->lineContainer = lc;
 24819:       }
 24819: 
  2679:       // This will process all the text frames that share the same textrun as f.
 94144:       f->AddInlinePrefWidthForFlow(aRenderingContext, aData, trtype);
 88125:       lastTextRun = f->GetTextRun(trtype);
     1:     }
     1:   }
     1: }
     1: 
     1: /* virtual */ nsSize
 68481: nsTextFrame::ComputeSize(nsRenderingContext *aRenderingContext,
     1:                          nsSize aCBSize, nscoord aAvailableWidth,
     1:                          nsSize aMargin, nsSize aBorder, nsSize aPadding,
 93353:                          PRUint32 aFlags)
     1: {
     1:   // Inlines and text don't compute size before reflow.
     1:   return nsSize(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
     1: }
     1: 
  6862: static nsRect
  6862: RoundOut(const gfxRect& aRect)
  6862: {
  6862:   nsRect r;
  6862:   r.x = NSToCoordFloor(aRect.X());
  6862:   r.y = NSToCoordFloor(aRect.Y());
  6862:   r.width = NSToCoordCeil(aRect.XMost()) - r.x;
  6862:   r.height = NSToCoordCeil(aRect.YMost()) - r.y;
  6862:   return r;
  6862: }
  6862: 
  6862: nsRect
  6862: nsTextFrame::ComputeTightBounds(gfxContext* aContext) const
  6862: {
 76925:   if (GetStyleContext()->HasTextDecorationLines() ||
  6862:       (GetStateBits() & TEXT_HYPHEN_BREAK)) {
  6862:     // This is conservative, but OK.
 55035:     return GetVisualOverflowRect();
  6862:   }
  6862: 
 82675:   gfxSkipCharsIterator iter =
 82675:     const_cast<nsTextFrame*>(this)->EnsureTextRun(nsTextFrame::eInflated);
  6862:   if (!mTextRun)
  6862:     return nsRect(0, 0, 0, 0);
  6862: 
 82675:   PropertyProvider provider(const_cast<nsTextFrame*>(this), iter,
 82675:                             nsTextFrame::eInflated);
  6862:   // Trim trailing whitespace
 80486:   provider.InitializeForDisplay(true);
  6862: 
  6862:   gfxTextRun::Metrics metrics =
  6862:         mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
 25417:                               ComputeTransformedLength(provider),
 25417:                               gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS,
  6862:                               aContext, &provider);
  6862:   // mAscent should be the same as metrics.mAscent, but it's what we use to
  6862:   // paint so that's the one we'll use.
  6862:   return RoundOut(metrics.mBoundingBox) + nsPoint(0, mAscent);
  6862: }
  6862: 
 79445: static bool
  3006: HasSoftHyphenBefore(const nsTextFragment* aFrag, gfxTextRun* aTextRun,
  3006:                     PRInt32 aStartOffset, const gfxSkipCharsIterator& aIter)
  3006: {
 69311:   if (aIter.GetSkippedOffset() < aTextRun->GetLength() &&
 69311:       aTextRun->CanHyphenateBefore(aIter.GetSkippedOffset())) {
 80486:     return true;
 69311:   }
  3006:   if (!(aTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_SHY))
 80486:     return false;
  3006:   gfxSkipCharsIterator iter = aIter;
  3006:   while (iter.GetOriginalOffset() > aStartOffset) {
  3006:     iter.AdvanceOriginal(-1);
  3006:     if (!iter.IsOriginalCharSkipped())
  3006:       break;
  3006:     if (aFrag->CharAt(iter.GetOriginalOffset()) == CH_SHY)
 80486:       return true;
 80486:   }
 80486:   return false;
  3006: }
  3006: 
 77246: static void
 99221: RemoveInFlows(nsTextFrame* aFrame, nsTextFrame* aFirstToNotRemove)
 77246: {
 77246:   NS_PRECONDITION(aFrame != aFirstToNotRemove, "This will go very badly");
 77246:   // We have to be careful here, because some RemoveFrame implementations
 77246:   // remove and destroy not only the passed-in frame but also all its following
 77246:   // in-flows (and sometimes all its following continuations in general).  So
 77246:   // we remove |f| and everything up to but not including firstToNotRemove from
 77246:   // the flow first, to make sure that only the things we want destroyed are
 77246:   // destroyed.
 77246: 
 77246:   // This sadly duplicates some of the logic from
 77246:   // nsSplittableFrame::RemoveFromFlow.  We can get away with not duplicating
 77246:   // all of it, because we know that the prev-continuation links of
 77246:   // firstToNotRemove and f are fluid, and non-null.
 77246:   NS_ASSERTION(aFirstToNotRemove->GetPrevContinuation() ==
 77246:                aFirstToNotRemove->GetPrevInFlow() &&
 77246:                aFirstToNotRemove->GetPrevInFlow() != nsnull,
 77246:                "aFirstToNotRemove should have a fluid prev continuation");
 77246:   NS_ASSERTION(aFrame->GetPrevContinuation() ==
 77246:                aFrame->GetPrevInFlow() &&
 77246:                aFrame->GetPrevInFlow() != nsnull,
 77246:                "aFrame should have a fluid prev continuation");
 77246:   
 77246:   nsIFrame* prevContinuation = aFrame->GetPrevContinuation();
 77246:   nsIFrame* lastRemoved = aFirstToNotRemove->GetPrevContinuation();
 99221:   nsIFrame* parent = aFrame->GetParent();
 99221:   nsBlockFrame* parentBlock = nsLayoutUtils::GetAsBlock(parent);
 99221:   if (!parentBlock) {
 99221:     // Clear the text run on the first frame we'll remove to make sure none of
 99221:     // the frames we keep shares its text run.  We need to do this now, before
 99221:     // we unlink the frames to remove from the flow, because DestroyFrom calls
 99221:     // ClearTextRuns() and that will start at the first frame with the text
 99221:     // run and walk the continuations.  We only need to care about the first
 99221:     // and last frames we remove since text runs are contiguous.
 99221:     aFrame->ClearTextRuns();
 99221:     if (aFrame != lastRemoved) {
 99221:       // Clear the text run on the last frame we'll remove for the same reason.
 99221:       static_cast<nsTextFrame*>(lastRemoved)->ClearTextRuns();
 99221:     }
 99221:   }
 77246: 
 77246:   prevContinuation->SetNextInFlow(aFirstToNotRemove);
 77246:   aFirstToNotRemove->SetPrevInFlow(prevContinuation);
 77246: 
 77246:   aFrame->SetPrevInFlow(nsnull);
 77246:   lastRemoved->SetNextInFlow(nsnull);
 77246: 
 77246:   if (parentBlock) {
 77246:     // Manually call DoRemoveFrame so we can tell it that we're
 77246:     // removing empty frames; this will keep it from blowing away
 77246:     // text runs.
 77246:     parentBlock->DoRemoveFrame(aFrame, nsBlockFrame::FRAMES_ARE_EMPTY);
 77246:   } else {
 99221:     // Just remove it normally; use kNoReflowPrincipalList to avoid posting
 99221:     // new reflows.
 77246:     parent->RemoveFrame(nsIFrame::kNoReflowPrincipalList, aFrame);
 77246:   }
 77246: }
 77246: 
  4678: void
 62893: nsTextFrame::SetLength(PRInt32 aLength, nsLineLayout* aLineLayout,
 62893:                        PRUint32 aSetLengthFlags)
  4678: {
  4678:   mContentLengthHint = aLength;
  4678:   PRInt32 end = GetContentOffset() + aLength;
  9735:   nsTextFrame* f = static_cast<nsTextFrame*>(GetNextInFlow());
  9735:   if (!f)
  4678:     return;
 34012: 
 34012:   // If our end offset is moving, then even if frames are not being pushed or
 34012:   // pulled, content is moving to or from the next line and the next line
 34012:   // must be reflowed.
 34012:   // If the next-continuation is dirty, then we should dirty the next line now
 34012:   // because we may have skipped doing it if we dirtied it in
 34012:   // CharacterDataChanged. This is ugly but teaching FrameNeedsReflow
 34012:   // and ChildIsDirty to handle a range of frames would be worse.
 34012:   if (aLineLayout &&
 34012:       (end != f->mContentOffset || (f->GetStateBits() & NS_FRAME_IS_DIRTY))) {
 34500:     aLineLayout->SetDirtyNextLine();
 34012:   }
 34012: 
  9735:   if (end < f->mContentOffset) {
  9735:     // Our frame is shrinking. Give the text to our next in flow.
 61565:     if (aLineLayout &&
 61565:         GetStyleText()->WhiteSpaceIsSignificant() &&
 61565:         HasTerminalNewline() &&
 62893:         GetParent()->GetType() != nsGkAtoms::letterFrame &&
 62893:         (aSetLengthFlags & ALLOW_FRAME_CREATION_AND_DESTRUCTION)) {
 61565:       // Whatever text we hand to our next-in-flow will end up in a frame all of
 61565:       // its own, since it ends in a forced linebreak.  Might as well just put
 61565:       // it in a separate frame now.  This is important to prevent text run
 61565:       // churn; if we did not do that, then we'd likely end up rebuilding
 61565:       // textruns for all our following continuations.
 61565:       // We skip this optimization when the parent is a first-letter frame
 61565:       // because it doesn't deal well with more than one child frame.
 62893:       // We also skip this optimization if we were called during bidi
 62893:       // resolution, so as not to create a new frame which doesn't appear in
 62893:       // the bidi resolver's list of frames
 61565:       nsPresContext* presContext = PresContext();
 61565:       nsIFrame* newFrame;
 61565:       nsresult rv = presContext->PresShell()->FrameConstructor()->
 61565:         CreateContinuingFrame(presContext, this, GetParent(), &newFrame);
 61565:       if (NS_SUCCEEDED(rv)) {
 61565:         nsTextFrame* next = static_cast<nsTextFrame*>(newFrame);
 61565:         nsFrameList temp(next, next);
 77154:         GetParent()->InsertFrames(kNoReflowPrincipalList, this, temp);
 61565:         f = next;
 61565:       }
 61565:     }
 61565: 
  9735:     f->mContentOffset = end;
 82675:     if (f->GetTextRun(nsTextFrame::eInflated) != mTextRun) {
 82675:       ClearTextRuns();
 82675:       f->ClearTextRuns();
  4678:     }
  4678:     return;
  4678:   }
 34012:   // Our frame is growing. Take text from our in-flow(s).
 34012:   // We can take text from frames in lines beyond just the next line.
 34012:   // We don't dirty those lines. That's OK, because when we reflow
 34012:   // our empty next-in-flow, it will take text from its next-in-flow and
 34012:   // dirty that line.
 77246: 
 77246:   // Note that in the process we may end up removing some frames from
 77246:   // the flow if they end up empty.
 99221:   nsTextFrame* framesToRemove = nsnull;
  9735:   while (f && f->mContentOffset < end) {
  9735:     f->mContentOffset = end;
 82675:     if (f->GetTextRun(nsTextFrame::eInflated) != mTextRun) {
 82675:       ClearTextRuns();
 82675:       f->ClearTextRuns();
  9735:     }
 61565:     nsTextFrame* next = static_cast<nsTextFrame*>(f->GetNextInFlow());
 61565:     // Note: the "f->GetNextSibling() == next" check below is to restrict
 61565:     // this optimization to the case where they are on the same child list.
 61565:     // Otherwise we might remove the only child of a nsFirstLetterFrame
 61565:     // for example and it can't handle that.  See bug 597627 for details.
 62893:     if (next && next->mContentOffset <= end && f->GetNextSibling() == next &&
 62893:         (aSetLengthFlags & ALLOW_FRAME_CREATION_AND_DESTRUCTION)) {
 61565:       // |f| is now empty.  We may as well remove it, instead of copying all
 61565:       // the text from |next| into it instead; the latter leads to use
 77246:       // rebuilding textruns for all following continuations.
 62893:       // We skip this optimization if we were called during bidi resolution,
 62893:       // since the bidi resolver may try to handle the destroyed frame later
 62893:       // and crash
 77246:       if (!framesToRemove) {
 77246:         // Remember that we have to remove this frame.
 77246:         framesToRemove = f;
 77246:       }
 77246: 
 77246:       // Important: if |f| has the same style context as its prev continuation,
 77246:       // mark it accordingly so we can skip clearing textruns as needed.  Note
 77246:       // that at this point f always has a prev continuation.
 77246:       if (f->GetStyleContext() == f->GetPrevContinuation()->GetStyleContext()) {
 77246:         f->AddStateBits(TEXT_STYLE_MATCHES_PREV_CONTINUATION);
 77246:       }
 77246:     } else if (framesToRemove) {
 77246:       RemoveInFlows(framesToRemove, f);
 77246:       framesToRemove = nsnull;
 61565:     }
 61565:     f = next;
  9735:   }
 77246:   NS_POSTCONDITION(!framesToRemove || (f && f->mContentOffset == end),
 77246:                    "How did we exit the loop if we null out framesToRemove if "
 77246:                    "!next || next->mContentOffset > end ?");
 77246:   if (framesToRemove) {
 77246:     // We are guaranteed that we exited the loop with f not null, per the
 77246:     // postcondition above
 77246:     RemoveInFlows(framesToRemove, f);
 77246:   }
 34012: 
  9810: #ifdef DEBUG
 30152:   f = this;
 30152:   PRInt32 iterations = 0;
 30152:   while (f && iterations < 10) {
  9810:     f->GetContentLength(); // Assert if negative length
  9810:     f = static_cast<nsTextFrame*>(f->GetNextContinuation());
 30152:     ++iterations;
 30152:   }
 30152:   f = this;
 30152:   iterations = 0;
 30152:   while (f && iterations < 10) {
 30152:     f->GetContentLength(); // Assert if negative length
 30152:     f = static_cast<nsTextFrame*>(f->GetPrevContinuation());
 30152:     ++iterations;
  9810:   }
  9810: #endif
  4678: }
  4678: 
 79445: bool
 90629: nsTextFrame::IsFloatingFirstLetterChild() const
 14210: {
 31623:   if (!(GetStateBits() & TEXT_FIRST_LETTER))
 80486:     return false;
 14210:   nsIFrame* frame = GetParent();
 14210:   if (!frame || frame->GetType() != nsGkAtoms::letterFrame)
 80486:     return false;
 14210:   return frame->GetStyleDisplay()->IsFloating();
 14210: }
 14210: 
 36903: struct NewlineProperty {
 36903:   PRInt32 mStartOffset;
 36903:   // The offset of the first \n after mStartOffset, or -1 if there is none
 36903:   PRInt32 mNewlineOffset;
 36903: 
 36903:   static void Destroy(void* aObject, nsIAtom* aPropertyName,
 36903:                       void* aPropertyValue, void* aData)
 36903:   {
 36903:     delete static_cast<NewlineProperty*>(aPropertyValue);
 36903:   }
 36903: };
 36903: 
     1: NS_IMETHODIMP
     1: nsTextFrame::Reflow(nsPresContext*           aPresContext,
     1:                     nsHTMLReflowMetrics&     aMetrics,
     1:                     const nsHTMLReflowState& aReflowState,
     1:                     nsReflowStatus&          aStatus)
     1: {
     1:   DO_GLOBAL_REFLOW_COUNT("nsTextFrame");
     1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
 51483: 
 51483:   // XXX If there's no line layout, we shouldn't even have created this
 51483:   // frame. This may happen if, for example, this is text inside a table
 51483:   // but not inside a cell. For now, just don't reflow.
 51483:   if (!aReflowState.mLineLayout) {
 51483:     ClearMetrics(aMetrics);
 51483:     aStatus = NS_FRAME_COMPLETE;
 51483:     return NS_OK;
 51483:   }
 51483: 
 51483:   ReflowText(*aReflowState.mLineLayout, aReflowState.availableWidth,
 51483:              aReflowState.rendContext, aReflowState.mFlags.mBlinks,
 51483:              aMetrics, aStatus);
 51483: 
 51483:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
 51483:   return NS_OK;
 51483: }
 51483: 
 83143: #ifdef ACCESSIBILITY
 83143: /**
 83143:  * Notifies accessibility about text reflow. Used by nsTextFrame::ReflowText.
 83143:  */
 83143: class NS_STACK_CLASS ReflowTextA11yNotifier
 83143: {
 83143: public:
 83143:   ReflowTextA11yNotifier(nsPresContext* aPresContext, nsIContent* aContent) :
 85981:     mContent(aContent), mPresContext(aPresContext)
 83143:   {
 83143:   }
 83143:   ~ReflowTextA11yNotifier()
 83143:   {
 83143:     nsAccessibilityService* accService = nsIPresShell::AccService();
 83143:     if (accService) {
 83143:       accService->UpdateText(mPresContext->PresShell(), mContent);
 83143:     }
 83143:   }
 83143: private:
 83143:   ReflowTextA11yNotifier();
 83143:   ReflowTextA11yNotifier(const ReflowTextA11yNotifier&);
 83143:   ReflowTextA11yNotifier& operator =(const ReflowTextA11yNotifier&);
 83143: 
 83143:   nsIContent* mContent;
 83143:   nsPresContext* mPresContext;
 83143: };
 83143: #endif
 83143: 
 51483: void
 51483: nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord aAvailableWidth,
 68481:                         nsRenderingContext* aRenderingContext,
 79445:                         bool aShouldBlink,
 51483:                         nsHTMLReflowMetrics& aMetrics,
 51483:                         nsReflowStatus& aStatus)
 51483: {
     1: #ifdef NOISY_REFLOW
     1:   ListTag(stdout);
 51483:   printf(": BeginReflow: availableWidth=%d\n", aAvailableWidth);
     1: #endif
     1: 
 51483:   nsPresContext* presContext = PresContext();
 51483: 
 83143: #ifdef ACCESSIBILITY
 83143:   // Schedule the update of accessible tree since rendered text might be changed.
 83143:   ReflowTextA11yNotifier(presContext, mContent);
 83143: #endif
 83143: 
     1:   /////////////////////////////////////////////////////////////////////
     1:   // Set up flags and clear out state
     1:   /////////////////////////////////////////////////////////////////////
     1: 
     1:   // Clear out the reflow state flags in mState (without destroying
 35581:   // the TEXT_BLINK_ON bit). We also clear the whitespace flags because this
 35581:   // can change whether the frame maps whitespace-only text or not.
     1:   RemoveStateBits(TEXT_REFLOW_FLAGS | TEXT_WHITESPACE_FLAGS);
     1: 
  4104:   // Temporarily map all possible content while we construct our new textrun.
  4104:   // so that when doing reflow our styles prevail over any part of the
  4104:   // textrun we look at. Note that next-in-flows may be mapping the same
  4104:   // content; gfxTextRun construction logic will ensure that we take priority.
     1:   PRInt32 maxContentLength = GetInFlowContentLength();
     1: 
 51483:   // We don't need to reflow if there is no content.
 51483:   if (!maxContentLength) {
     1:     ClearMetrics(aMetrics);
     1:     aStatus = NS_FRAME_COMPLETE;
 51483:     return;
 51483:   }
 51483: 
 51483:   if (aShouldBlink) {
 35581:     if (0 == (mState & TEXT_BLINK_ON)) {
 35581:       mState |= TEXT_BLINK_ON;
 51483:       nsBlinkTimer::AddBlinkFrame(presContext, this);
     1:     }
     1:   }
     1:   else {
 35581:     if (0 != (mState & TEXT_BLINK_ON)) {
 35581:       mState &= ~TEXT_BLINK_ON;
     1:       nsBlinkTimer::RemoveBlinkFrame(this);
     1:     }
     1:   }
     1: 
 67826: #ifdef NOISY_BIDI
 67826:     printf("Reflowed textframe\n");
 67826: #endif
 67826: 
     1:   const nsStyleText* textStyle = GetStyleText();
     1: 
 79445:   bool atStartOfLine = aLineLayout.LineAtStart();
     1:   if (atStartOfLine) {
     1:     AddStateBits(TEXT_START_OF_LINE);
     1:   }
     1: 
 16292:   PRUint32 flowEndInTextRun;
 51483:   nsIFrame* lineContainer = aLineLayout.GetLineContainerFrame();
 51483:   gfxContext* ctx = aRenderingContext->ThebesContext();
 35581:   const nsTextFragment* frag = mContent->GetText();
 16292: 
     1:   // DOM offsets of the text range we need to measure, after trimming
     1:   // whitespace, restricting to first-letter, and restricting preformatted text
     1:   // to nearest newline
  4678:   PRInt32 length = maxContentLength;
  4678:   PRInt32 offset = GetContentOffset();
     1: 
     1:   // Restrict preformatted text to the nearest newline
 10775:   PRInt32 newLineOffset = -1; // this will be -1 or a content offset
 57101:   PRInt32 contentNewLineOffset = -1;
 36903:   // Pointer to the nsGkAtoms::newline set on this frame's element
 37804:   NewlineProperty* cachedNewlineOffset = nsnull;
 16575:   if (textStyle->NewlineIsSignificant()) {
 36903:     cachedNewlineOffset =
 36903:       static_cast<NewlineProperty*>(mContent->GetProperty(nsGkAtoms::newline));
 36903:     if (cachedNewlineOffset && cachedNewlineOffset->mStartOffset <= offset &&
 36903:         (cachedNewlineOffset->mNewlineOffset == -1 ||
 36903:          cachedNewlineOffset->mNewlineOffset >= offset)) {
 57101:       contentNewLineOffset = cachedNewlineOffset->mNewlineOffset;
 36903:     } else {
 57101:       contentNewLineOffset = FindChar(frag, offset, 
 57101:                                       mContent->TextLength() - offset, '\n');
 57101:     }
 57101:     if (contentNewLineOffset < offset + length) {
 57101:       /*
 57101:         The new line offset could be outside this frame if the frame has been
 57101:         split by bidi resolution. In that case we won't use it in this reflow
 57101:         (newLineOffset will remain -1), but we will still cache it in mContent
 57101:       */
 57101:       newLineOffset = contentNewLineOffset;
 36903:     }
     1:     if (newLineOffset >= 0) {
     1:       length = newLineOffset + 1 - offset;
     1:     }
 16575:   }
 16575:   if (atStartOfLine && !textStyle->WhiteSpaceIsSignificant()) {
 16575:     // Skip leading whitespace. Make sure we don't skip a 'pre-line'
 16575:     // newline if there is one.
 16575:     PRInt32 skipLength = newLineOffset >= 0 ? length - 1 : length;
 16575:     PRInt32 whitespaceCount =
 16575:       GetTrimmableWhitespaceCount(frag, offset, skipLength, 1);
     8:     offset += whitespaceCount;
     8:     length -= whitespaceCount;
     8:   }
     1: 
 79445:   bool completedFirstLetter = false;
 16292:   // Layout dependent styles are a problem because we need to reconstruct
 16292:   // the gfxTextRun based on our layout.
 51483:   if (aLineLayout.GetInFirstLetter() || aLineLayout.GetInFirstLine()) {
 62893:     SetLength(maxContentLength, &aLineLayout,
 62893:               ALLOW_FRAME_CREATION_AND_DESTRUCTION);
 51483: 
 51483:     if (aLineLayout.GetInFirstLetter()) {
 16292:       // floating first-letter boundaries are significant in textrun
 16292:       // construction, so clear the textrun out every time we hit a first-letter
 16292:       // and have changed our length (which controls the first-letter boundary)
 82675:       ClearTextRuns();
 16292:       // Find the length of the first-letter. We need a textrun for this.
 82675:       // REVIEW: maybe-bogus inflation should be ok (fixed below)
 16292:       gfxSkipCharsIterator iter =
 94144:         EnsureTextRun(nsTextFrame::eInflated, ctx,
 82675:                       lineContainer, aLineLayout.GetLine(),
 82675:                       &flowEndInTextRun);
 16292: 
 16292:       if (mTextRun) {
 16575:         PRInt32 firstLetterLength = length;
 51483:         if (aLineLayout.GetFirstLetterStyleOK()) {
 16575:           completedFirstLetter =
 16575:             FindFirstLetterRange(frag, mTextRun, offset, iter, &firstLetterLength);
 16575:           if (newLineOffset >= 0) {
 16575:             // Don't allow a preformatted newline to be part of a first-letter.
 32531:             firstLetterLength = NS_MIN(firstLetterLength, length - 1);
 16575:             if (length == 1) {
 16575:               // There is no text to be consumed by the first-letter before the
 16575:               // preformatted newline. Note that the first letter is therefore
 16575:               // complete (FindFirstLetterRange will have returned false).
 80486:               completedFirstLetter = true;
 16575:             }
 16575:           }
 23308:         } else {
 23308:           // We're in a first-letter frame's first in flow, so if there
 23308:           // was a first-letter, we'd be it. However, for one reason
 23308:           // or another (e.g., preformatted line break before this text),
 23308:           // we're not actually supposed to have first-letter style. So
 23308:           // just make a zero-length first-letter.
 23308:           firstLetterLength = 0;
 80486:           completedFirstLetter = true;
 23308:         }
 16575:         length = firstLetterLength;
 16292:         if (length) {
 16292:           AddStateBits(TEXT_FIRST_LETTER);
 16292:         }
 16292:         // Change this frame's length to the first-letter length right now
 16292:         // so that when we rebuild the textrun it will be built with the
 16292:         // right first-letter boundary
 62893:         SetLength(offset + length - GetContentOffset(), &aLineLayout,
 62893:                   ALLOW_FRAME_CREATION_AND_DESTRUCTION);
 16292:         // Ensure that the textrun will be rebuilt
 82675:         ClearTextRuns();
 82675:       }
 82675:     } 
 82675:   }
 82675: 
 98995:   float fontSizeInflation = nsLayoutUtils::FontSizeInflationFor(this);
 82675: 
 82675:   if (fontSizeInflation != GetFontSizeInflation()) {
 82675:     // FIXME: Ideally, if we already have a text run, we'd move it to be
 82675:     // the uninflated text run.
 82675:     ClearTextRun(nsnull, nsTextFrame::eInflated);
 16292:   }
 16292: 
  6779:   gfxSkipCharsIterator iter =
 94144:     EnsureTextRun(nsTextFrame::eInflated, ctx,
 82675:                   lineContainer, aLineLayout.GetLine(), &flowEndInTextRun);
 82675: 
 82675:   NS_ABORT_IF_FALSE(GetFontSizeInflation() == fontSizeInflation,
 82675:                     "EnsureTextRun should have set font size inflation");
  6779: 
 22876:   if (mTextRun && iter.GetOriginalEnd() < offset + length) {
  6779:     // The textrun does not map enough text for this frame. This can happen
  6779:     // when the textrun was ended in the middle of a text node because a
  6779:     // preformatted newline was encountered, and prev-in-flow frames have
  6779:     // consumed all the text of the textrun. We need a new textrun.
 82675:     ClearTextRuns();
 94144:     iter = EnsureTextRun(nsTextFrame::eInflated, ctx,
 82675:                          lineContainer, aLineLayout.GetLine(),
 82675:                          &flowEndInTextRun);
  6779:   }
  6779: 
  6779:   if (!mTextRun) {
  6779:     ClearMetrics(aMetrics);
  6779:     aStatus = NS_FRAME_COMPLETE;
 51483:     return;
  6779:   }
  6779: 
  6779:   NS_ASSERTION(gfxSkipCharsIterator(iter).ConvertOriginalToSkipped(offset + length)
  6779:                     <= mTextRun->GetLength(),
  6779:                "Text run does not map enough text for our reflow");
  6779: 
     1:   /////////////////////////////////////////////////////////////////////
     1:   // See how much text should belong to this text frame, and measure it
     1:   /////////////////////////////////////////////////////////////////////
     1:   
     1:   iter.SetOriginalOffset(offset);
  1732:   nscoord xOffsetForTabs = (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TAB) ?
 51483:     (aLineLayout.GetCurrentFrameXDistanceFromBlock() -
 15447:        lineContainer->GetUsedBorderAndPadding().left)
 15447:     : -1;
  1732:   PropertyProvider provider(mTextRun, textStyle, frag, this, iter, length,
 82675:       lineContainer, xOffsetForTabs, nsTextFrame::eInflated);
     1: 
     1:   PRUint32 transformedOffset = provider.GetStart().GetSkippedOffset();
     1: 
     1:   // The metrics for the text go in here
     1:   gfxTextRun::Metrics textMetrics;
 25417:   gfxFont::BoundingBoxType boundingBoxType = IsFloatingFirstLetterChild() ?
 25417:                                                gfxFont::TIGHT_HINTED_OUTLINE_EXTENTS :
 25417:                                                gfxFont::LOOSE_INK_EXTENTS;
  6862:   NS_ASSERTION(!(NS_REFLOW_CALC_BOUNDING_METRICS & aMetrics.mFlags),
  6862:                "We shouldn't be passed NS_REFLOW_CALC_BOUNDING_METRICS anymore");
     1: 
     8:   PRInt32 limitLength = length;
 51483:   PRInt32 forceBreak = aLineLayout.GetForcedBreakPosition(mContent);
 79445:   bool forceBreakAfter = false;
  3055:   if (forceBreak >= offset + length) {
  8780:     forceBreakAfter = forceBreak == offset + length;
  3055:     // The break is not within the text considered for this textframe.
  3055:     forceBreak = -1;
  3055:   }
     8:   if (forceBreak >= 0) {
     8:     limitLength = forceBreak - offset;
     8:     NS_ASSERTION(limitLength >= 0, "Weird break found!");
     8:   }
     1:   // This is the heart of text reflow right here! We don't know where
     1:   // to break, so we need to see how much text fits in the available width.
     1:   PRUint32 transformedLength;
     8:   if (offset + limitLength >= PRInt32(frag->GetLength())) {
     8:     NS_ASSERTION(offset + limitLength == PRInt32(frag->GetLength()),
     1:                  "Content offset/length out of bounds");
     1:     NS_ASSERTION(flowEndInTextRun >= transformedOffset,
     1:                  "Negative flow length?");
     1:     transformedLength = flowEndInTextRun - transformedOffset;
     1:   } else {
     1:     // we're not looking at all the content, so we need to compute the
     1:     // length of the transformed substring we're looking at
     1:     gfxSkipCharsIterator iter(provider.GetStart());
     8:     iter.SetOriginalOffset(offset + limitLength);
     1:     transformedLength = iter.GetSkippedOffset() - transformedOffset;
     1:   }
     1:   PRUint32 transformedLastBreak = 0;
 79445:   bool usedHyphenation;
  1732:   gfxFloat trimmedWidth = 0;
 51483:   gfxFloat availWidth = aAvailableWidth;
 79445:   bool canTrimTrailingWhitespace = !textStyle->WhiteSpaceIsSignificant();
 16166:   PRInt32 unusedOffset;  
 16166:   gfxBreakPriority breakPriority;
 51483:   aLineLayout.GetLastOptionalBreakPosition(&unusedOffset, &breakPriority);
     1:   PRUint32 transformedCharsFit =
     1:     mTextRun->BreakAndMeasureText(transformedOffset, transformedLength,
     1:                                   (GetStateBits() & TEXT_START_OF_LINE) != 0,
  1732:                                   availWidth,
 51483:                                   &provider, !aLineLayout.LineIsBreakable(),
  1732:                                   canTrimTrailingWhitespace ? &trimmedWidth : nsnull,
 25417:                                   &textMetrics, boundingBoxType, ctx,
 16166:                                   &usedHyphenation, &transformedLastBreak,
 16166:                                   textStyle->WordCanWrap(), &breakPriority);
 56866:   if (!length && !textMetrics.mAscent && !textMetrics.mDescent) {
 56866:     // If we're measuring a zero-length piece of text, update
 56866:     // the height manually.
 68493:     nsFontMetrics* fm = provider.GetFontMetrics();
 56866:     if (fm) {
 68495:       textMetrics.mAscent = gfxFloat(fm->MaxAscent());
 68495:       textMetrics.mDescent = gfxFloat(fm->MaxDescent());
 56866:     }
 56866:   }
  2013:   // The "end" iterator points to the first character after the string mapped
  3006:   // by this frame. Basically, its original-string offset is offset+charsFit
  2013:   // after we've computed charsFit.
  2013:   gfxSkipCharsIterator end(provider.GetEndHint());
     1:   end.SetSkippedOffset(transformedOffset + transformedCharsFit);
     8:   PRInt32 charsFit = end.GetOriginalOffset() - offset;
 10775:   if (offset + charsFit == newLineOffset) {
 10775:     // We broke before a trailing preformatted '\n'. The newline should
 10775:     // be assigned to this frame. Note that newLineOffset will be -1 if
 10775:     // there was no preformatted newline, so we wouldn't get here in that
 10775:     // case.
 10775:     ++charsFit;
 10775:   }
  1732:   // That might have taken us beyond our assigned content range (because
  1732:   // we might have advanced over some skipped chars that extend outside
  1732:   // this frame), so get back in.
     8:   PRInt32 lastBreak = -1;
     8:   if (charsFit >= limitLength) {
     8:     charsFit = limitLength;
     1:     if (transformedLastBreak != PR_UINT32_MAX) {
  3006:       // lastBreak is needed.
     1:       // This may set lastBreak greater than 'length', but that's OK
  3006:       lastBreak = end.ConvertSkippedToOriginal(transformedOffset + transformedLastBreak);
  3006:     }
     1:     end.SetOriginalOffset(offset + charsFit);
  3006:     // If we were forced to fit, and the break position is after a soft hyphen,
  3006:     // note that this is a hyphenation break.
 16578:     if ((forceBreak >= 0 || forceBreakAfter) &&
 16578:         HasSoftHyphenBefore(frag, mTextRun, offset, end)) {
 80486:       usedHyphenation = true;
     1:     }
     1:   }
     1:   if (usedHyphenation) {
     1:     // Fix up metrics to include hyphen
 25417:     AddHyphenToMetrics(this, mTextRun, &textMetrics, boundingBoxType, ctx);
 16578:     AddStateBits(TEXT_HYPHEN_BREAK | TEXT_HAS_NONCOLLAPSED_CHARACTERS);
     1:   }
     1: 
  7069:   gfxFloat trimmableWidth = 0;
 79445:   bool brokeText = forceBreak >= 0 || transformedCharsFit < transformedLength;
  7069:   if (canTrimTrailingWhitespace) {
  7069:     // Optimization: if we trimmed trailing whitespace, and we can be sure
  7069:     // this frame will be at the end of the line, then leave it trimmed off.
  7069:     // Otherwise we have to undo the trimming, in case we're not at the end of
  7069:     // the line. (If we actually do end up at the end of the line, we'll have
  7069:     // to trim it off again in TrimTrailingWhiteSpace, and we'd like to avoid
  7069:     // having to re-do it.)
  8083:     if (brokeText) {
  7069:       // We're definitely going to break so our trailing whitespace should
  7069:       // definitely be timmed. Record that we've already done it.
  7069:       AddStateBits(TEXT_TRIMMED_TRAILING_WHITESPACE);
  7069:     } else {
  7069:       // We might not be at the end of the line. (Note that even if this frame
  7069:       // ends in breakable whitespace, it might not be at the end of the line
  7069:       // because it might be followed by breakable, but preformatted, whitespace.)
  7069:       // Undo the trimming.
  1732:       textMetrics.mAdvanceWidth += trimmedWidth;
  7069:       trimmableWidth = trimmedWidth;
  1732:       if (mTextRun->IsRightToLeft()) {
  1732:         // Space comes before text, so the bounding box is moved to the
  1732:         // right by trimmdWidth
  1732:         textMetrics.mBoundingBox.MoveBy(gfxPoint(trimmedWidth, 0));
  1732:       }
  8083:     }
  8083:   }
  8083: 
  8083:   if (!brokeText && lastBreak >= 0) {
  7069:     // Since everything fit and no break was forced,
  7069:     // record the last break opportunity
 51483:     NS_ASSERTION(textMetrics.mAdvanceWidth - trimmableWidth <= aAvailableWidth,
  8083:                  "If the text doesn't fit, and we have a break opportunity, why didn't MeasureText use it?");
 80486:     aLineLayout.NotifyOptionalBreakPosition(mContent, lastBreak, true, breakPriority);
  8083:   }
  8083: 
  4678:   PRInt32 contentLength = offset + charsFit - GetContentOffset();
     1: 
     1:   /////////////////////////////////////////////////////////////////////
     1:   // Compute output metrics
     1:   /////////////////////////////////////////////////////////////////////
     1: 
     1:   // first-letter frames should use the tight bounding box metrics for ascent/descent
     1:   // for good drop-cap effects
     1:   if (GetStateBits() & TEXT_FIRST_LETTER) {
 32531:     textMetrics.mAscent = NS_MAX(gfxFloat(0.0), -textMetrics.mBoundingBox.Y());
 32531:     textMetrics.mDescent = NS_MAX(gfxFloat(0.0), textMetrics.mBoundingBox.YMost());
     1:   }
     1: 
     1:   // Setup metrics for caller
     1:   // Disallow negative widths
 32531:   aMetrics.width = NSToCoordCeil(NS_MAX(gfxFloat(0.0), textMetrics.mAdvanceWidth));
 13714: 
 86415:   if (transformedCharsFit == 0 && !usedHyphenation) {
 15647:     aMetrics.ascent = 0;
 15647:     aMetrics.height = 0;
 25417:   } else if (boundingBoxType != gfxFont::LOOSE_INK_EXTENTS) {
 14210:     // Use actual text metrics for floating first letter frame.
 14210:     aMetrics.ascent = NSToCoordCeil(textMetrics.mAscent);
 14210:     aMetrics.height = aMetrics.ascent + NSToCoordCeil(textMetrics.mDescent);
 14210:   } else {
 14210:     // Otherwise, ascent should contain the overline drawable area.
 14210:     // And also descent should contain the underline drawable area.
 68493:     // nsFontMetrics::GetMaxAscent/GetMaxDescent contains them.
 68493:     nsFontMetrics* fm = provider.GetFontMetrics();
 68495:     nscoord fontAscent = fm->MaxAscent();
 68495:     nscoord fontDescent = fm->MaxDescent();
 32531:     aMetrics.ascent = NS_MAX(NSToCoordCeil(textMetrics.mAscent), fontAscent);
 32531:     nscoord descent = NS_MAX(NSToCoordCeil(textMetrics.mDescent), fontDescent);
 13714:     aMetrics.height = aMetrics.ascent + descent;
 14210:   }
 14210: 
     1:   NS_ASSERTION(aMetrics.ascent >= 0, "Negative ascent???");
     1:   NS_ASSERTION(aMetrics.height - aMetrics.ascent >= 0, "Negative descent???");
     1: 
     1:   mAscent = aMetrics.ascent;
     1: 
     1:   // Handle text that runs outside its normal bounds.
 13912:   nsRect boundingBox = RoundOut(textMetrics.mBoundingBox) + nsPoint(0, mAscent);
 55028:   aMetrics.SetOverflowAreasToDesiredBounds();
 55028:   aMetrics.VisualOverflow().UnionRect(aMetrics.VisualOverflow(), boundingBox);
 55028: 
 74792:   // When we have text decorations, we don't need to compute their overflow now
 74792:   // because we're guaranteed to do it later
 74792:   // (see nsLineLayout::RelativePositionFrames)
 82674:   UnionAdditionalOverflow(presContext, *aLineLayout.GetLineContainerRS(),
 82674:                           provider, &aMetrics.VisualOverflow(), false);
 11780: 
     1:   /////////////////////////////////////////////////////////////////////
     1:   // Clean up, update state
     1:   /////////////////////////////////////////////////////////////////////
     1: 
  7069:   // If all our characters are discarded or collapsed, then trimmable width
  7069:   // from the last textframe should be preserved. Otherwise the trimmable width
  7069:   // from this textframe overrides. (Currently in CSS trimmable width can be
  7069:   // at most one space so there's no way for trimmable width from a previous
  7069:   // frame to accumulate with trimmable width from this frame.)
  7069:   if (transformedCharsFit > 0) {
 51483:     aLineLayout.SetTrimmableWidth(NSToCoordFloor(trimmableWidth));
 11711:     AddStateBits(TEXT_HAS_NONCOLLAPSED_CHARACTERS);
  7069:   }
  7069:   if (charsFit > 0 && charsFit == length &&
 69311:       textStyle->mHyphens != NS_STYLE_HYPHENS_NONE &&
  7069:       HasSoftHyphenBefore(frag, mTextRun, offset, end)) {
  3006:     // Record a potential break after final soft hyphen
 51483:     aLineLayout.NotifyOptionalBreakPosition(mContent, offset + length,
 16166:         textMetrics.mAdvanceWidth + provider.GetHyphenWidth() <= availWidth,
 16166:                                            eNormalBreak);
  3006:   }
 79445:   bool breakAfter = forceBreakAfter;
 23490:   // length == 0 means either the text is empty or it's all collapsed away
 79445:   bool emptyTextAtStartOfLine = atStartOfLine && length == 0;
 23490:   if (!breakAfter && charsFit == length && !emptyTextAtStartOfLine &&
  8780:       transformedOffset + transformedLength == mTextRun->GetLength() &&
  8780:       (mTextRun->GetFlags() & nsTextFrameUtils::TEXT_HAS_TRAILING_BREAK)) {
  8780:     // We placed all the text in the textrun and we have a break opportunity at
  8780:     // the end of the textrun. We need to record it because the following
  8780:     // content may not care about nsLineBreaker.
  8780: 
  8573:     // Note that because we didn't break, we can be sure that (thanks to the
  8573:     // code up above) textMetrics.mAdvanceWidth includes the width of any
  8573:     // trailing whitespace. So we need to subtract trimmableWidth here
  8573:     // because if we did break at this point, that much width would be trimmed.
  8573:     if (textMetrics.mAdvanceWidth - trimmableWidth > availWidth) {
 80486:       breakAfter = true;
  8573:     } else {
 51483:       aLineLayout.NotifyOptionalBreakPosition(mContent, offset + length,
 80486:                                               true, eNormalBreak);
  8573:     }
  8573:   }
     1: 
     1:   // Compute reflow status
  4678:   aStatus = contentLength == maxContentLength
     1:     ? NS_FRAME_COMPLETE : NS_FRAME_NOT_COMPLETE;
     1: 
 69311:   if (charsFit == 0 && length > 0 && !usedHyphenation) {
     1:     // Couldn't place any text
     1:     aStatus = NS_INLINE_LINE_BREAK_BEFORE();
 10775:   } else if (contentLength > 0 && mContentOffset + contentLength - 1 == newLineOffset) {
     1:     // Ends in \n
     1:     aStatus = NS_INLINE_LINE_BREAK_AFTER(aStatus);
 80486:     aLineLayout.SetLineEndsInBR(true);
  8573:   } else if (breakAfter) {
  8573:     aStatus = NS_INLINE_LINE_BREAK_AFTER(aStatus);
     1:   }
 16409:   if (completedFirstLetter) {
 80486:     aLineLayout.SetFirstLetterStyleOK(false);
 16409:     aStatus |= NS_INLINE_BREAK_FIRST_LETTER_COMPLETE;
 16409:   }
     1: 
 36903:   // Updated the cached NewlineProperty, or delete it.
 36903:   if (contentLength < maxContentLength &&
 36903:       textStyle->NewlineIsSignificant() &&
 57101:       (contentNewLineOffset < 0 ||
 57101:        mContentOffset + contentLength <= contentNewLineOffset)) {
 36903:     if (!cachedNewlineOffset) {
 36903:       cachedNewlineOffset = new NewlineProperty;
 36903:       if (NS_FAILED(mContent->SetProperty(nsGkAtoms::newline, cachedNewlineOffset,
 36903:                                           NewlineProperty::Destroy))) {
 36903:         delete cachedNewlineOffset;
 36903:         cachedNewlineOffset = nsnull;
 36903:       }
 36903:     }
 36903:     if (cachedNewlineOffset) {
 36903:       cachedNewlineOffset->mStartOffset = offset;
 57101:       cachedNewlineOffset->mNewlineOffset = contentNewLineOffset;
 36903:     }
 36903:   } else if (cachedNewlineOffset) {
 36903:     mContent->DeleteProperty(nsGkAtoms::newline);
 36903:   }
 36903: 
     1:   // Compute space and letter counts for justification, if required
 16575:   if (!textStyle->WhiteSpaceIsSignificant() &&
 87175:       (lineContainer->GetStyleText()->mTextAlign == NS_STYLE_TEXT_ALIGN_JUSTIFY ||
 87175:        lineContainer->GetStyleText()->mTextAlignLast == NS_STYLE_TEXT_ALIGN_JUSTIFY)) {
 16575:     AddStateBits(TEXT_JUSTIFICATION_ENABLED);    // This will include a space for trailing whitespace, if any is present.
     1:     // This is corrected for in nsLineLayout::TrimWhiteSpaceIn.
     1:     PRInt32 numJustifiableCharacters =
     1:       provider.ComputeJustifiableCharacters(offset, charsFit);
  1764: 
  4435:     NS_ASSERTION(numJustifiableCharacters <= charsFit,
  5618:                  "Bad justifiable character count");
 51483:     aLineLayout.SetTextJustificationWeights(numJustifiableCharacters,
  4435:         charsFit - numJustifiableCharacters);
     1:   }
     1: 
 62893:   SetLength(contentLength, &aLineLayout, ALLOW_FRAME_CREATION_AND_DESTRUCTION);
     1: 
 55039:   Invalidate(aMetrics.VisualOverflow());
     1: 
     1: #ifdef NOISY_REFLOW
     1:   ListTag(stdout);
     1:   printf(": desiredSize=%d,%d(b=%d) status=%x\n",
     1:          aMetrics.width, aMetrics.height, aMetrics.ascent,
     1:          aStatus);
     1: #endif
     1: }
     1: 
 79445: /* virtual */ bool
     1: nsTextFrame::CanContinueTextRun() const
     1: {
     1:   // We can continue a text run through a text frame
 80486:   return true;
     1: }
     1: 
  8514: nsTextFrame::TrimOutput
 68481: nsTextFrame::TrimTrailingWhiteSpace(nsRenderingContext* aRC)
  8514: {
  8514:   TrimOutput result;
 80486:   result.mChanged = false;
 80486:   result.mLastCharIsJustifiable = false;
  8514:   result.mDeltaWidth = 0;
     1: 
     1:   AddStateBits(TEXT_END_OF_LINE);
     1: 
  4678:   PRInt32 contentLength = GetContentLength();
  4678:   if (!contentLength)
  8514:     return result;
     1: 
  9438:   gfxContext* ctx = aRC->ThebesContext();
 82675:   gfxSkipCharsIterator start =
 94144:     EnsureTextRun(nsTextFrame::eInflated, ctx);
  8514:   NS_ENSURE_TRUE(mTextRun, result);
  8514: 
  2319:   PRUint32 trimmedStart = start.GetSkippedOffset();
     1: 
 35581:   const nsTextFragment* frag = mContent->GetText();
 80486:   TrimmedOffsets trimmed = GetTrimmedOffsets(frag, true);
  8514:   gfxSkipCharsIterator trimmedEndIter = start;
     1:   const nsStyleText* textStyle = GetStyleText();
     1:   gfxFloat delta = 0;
  8514:   PRUint32 trimmedEnd = trimmedEndIter.ConvertOriginalToSkipped(trimmed.GetEnd());
     8:   
     8:   if (GetStateBits() & TEXT_TRIMMED_TRAILING_WHITESPACE) {
  8514:     // We pre-trimmed this frame, so the last character is justifiable
 80486:     result.mLastCharIsJustifiable = true;
  4261:   } else if (trimmed.GetEnd() < GetContentEnd()) {
  8514:     gfxSkipCharsIterator end = trimmedEndIter;
  4678:     PRUint32 endOffset = end.ConvertOriginalToSkipped(GetContentOffset() + contentLength);
     8:     if (trimmedEnd < endOffset) {
  1732:       // We can't be dealing with tabs here ... they wouldn't be trimmed. So it's
  1732:       // OK to pass null for the line container.
  4678:       PropertyProvider provider(mTextRun, textStyle, frag, this, start, contentLength,
 82675:                                 nsnull, 0, nsTextFrame::eInflated);
     8:       delta = mTextRun->GetAdvanceWidth(trimmedEnd, endOffset - trimmedEnd, &provider);
     1:       // non-compressed whitespace being skipped at end of line -> justifiable
     1:       // XXX should we actually *count* justifiable characters that should be
     8:       // removed from the overall count? I think so...
 80486:       result.mLastCharIsJustifiable = true;
 80486:       result.mChanged = true;
  8514:     }
  8514:   }
  8514: 
  8514:   if (!result.mLastCharIsJustifiable &&
 16575:       (GetStateBits() & TEXT_JUSTIFICATION_ENABLED)) {
     1:     // Check if any character in the last cluster is justifiable
  4678:     PropertyProvider provider(mTextRun, textStyle, frag, this, start, contentLength,
 82675:                               nsnull, 0, nsTextFrame::eInflated);
 79445:     bool isCJK = IsChineseOrJapanese(this);
  8514:     gfxSkipCharsIterator justificationStart(start), justificationEnd(trimmedEndIter);
  7076:     provider.FindJustificationRange(&justificationStart, &justificationEnd);
     1: 
     1:     PRInt32 i;
  4261:     for (i = justificationEnd.GetOriginalOffset(); i < trimmed.GetEnd(); ++i) {
     1:       if (IsJustifiableCharacter(frag, i, isCJK)) {
 80486:         result.mLastCharIsJustifiable = true;
     1:       }
     1:     }
     1:   }
     1: 
     1:   gfxFloat advanceDelta;
     1:   mTextRun->SetLineBreaks(trimmedStart, trimmedEnd - trimmedStart,
 80486:                           (GetStateBits() & TEXT_START_OF_LINE) != 0, true,
  2834:                           &advanceDelta, ctx);
  8514:   if (advanceDelta != 0) {
 80486:     result.mChanged = true;
  8514:   }
     1: 
     1:   // aDeltaWidth is *subtracted* from our width.
     1:   // If advanceDelta is positive then setting the line break made us longer,
     1:   // so aDeltaWidth could go negative.
  8514:   result.mDeltaWidth = NSToCoordFloor(delta - advanceDelta);
  8514:   // If aDeltaWidth goes negative, that means this frame might not actually fit
  8514:   // anymore!!! We need higher level line layout to recover somehow.
  8514:   // If it's because the frame has a soft hyphen that is now being displayed,
  8514:   // this should actually be OK, because our reflow recorded the break
  8514:   // opportunity that allowed the soft hyphen to be used, and we wouldn't
  8514:   // have recorded the opportunity unless the hyphen fit (or was the first
  8514:   // opportunity on the line).
  8514:   // Otherwise this can/ really only happen when we have glyphs with special
  8514:   // shapes at the end of lines, I think. Breaking inside a kerning pair won't
  8514:   // do it because that would mean we broke inside this textrun, and
  8514:   // BreakAndMeasureText should make sure the resulting shaped substring fits.
  8514:   // Maybe if we passed a maxTextLength? But that only happens at direction
  8514:   // changes (so we wouldn't kern across the boundary) or for first-letter
  8514:   // (which always fits because it starts the line!).
 16578:   NS_WARN_IF_FALSE(result.mDeltaWidth >= 0,
 16578:                    "Negative deltawidth, something odd is happening");
     1: 
     1: #ifdef NOISY_TRIM
     1:   ListTag(stdout);
  8514:   printf(": trim => %d\n", result.mDeltaWidth);
     1: #endif
  8514:   return result;
     1: }
     1: 
 55028: nsOverflowAreas
 82674: nsTextFrame::RecomputeOverflow(const nsHTMLReflowState& aBlockReflowState)
 55028: {
 55028:   nsRect bounds(nsPoint(0, 0), GetSize());
 55028:   nsOverflowAreas result(bounds, bounds);
 55028: 
 82675:   gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
  6247:   if (!mTextRun)
 55028:     return result;
  6247: 
 82675:   PropertyProvider provider(this, iter, nsTextFrame::eInflated);
 80486:   provider.InitializeForDisplay(true);
  6247: 
  6247:   gfxTextRun::Metrics textMetrics =
  6247:     mTextRun->MeasureText(provider.GetStart().GetSkippedOffset(),
 25417:                           ComputeTransformedLength(provider),
 25417:                           gfxFont::LOOSE_INK_EXTENTS, nsnull,
  6247:                           &provider);
 55028:   nsRect &vis = result.VisualOverflow();
 55028:   vis.UnionRect(vis, RoundOut(textMetrics.mBoundingBox) + nsPoint(0, mAscent));
 82674:   UnionAdditionalOverflow(PresContext(), aBlockReflowState, provider,
 82674:                           &vis, true);
 55028:   return result;
  6247: }
  4261: static PRUnichar TransformChar(const nsStyleText* aStyle, gfxTextRun* aTextRun,
  4261:                                PRUint32 aSkippedOffset, PRUnichar aChar)
  4261: {
 16575:   if (aChar == '\n') {
 16575:     return aStyle->NewlineIsSignificant() ? aChar : ' ';
  4261:   }
  4261:   switch (aStyle->mTextTransform) {
  4261:   case NS_STYLE_TEXT_TRANSFORM_LOWERCASE:
 48377:     aChar = ToLowerCase(aChar);
  4261:     break;
  4261:   case NS_STYLE_TEXT_TRANSFORM_UPPERCASE:
 48377:     aChar = ToUpperCase(aChar);
  4261:     break;
  4261:   case NS_STYLE_TEXT_TRANSFORM_CAPITALIZE:
  4261:     if (aTextRun->CanBreakLineBefore(aSkippedOffset)) {
 48377:       aChar = ToTitleCase(aChar);
  4261:     }
  4261:     break;
  4261:   }
  4261: 
  4261:   return aChar;
  4261: }
  4261: 
  4261: nsresult nsTextFrame::GetRenderedText(nsAString* aAppendToString,
  4261:                                       gfxSkipChars* aSkipChars,
  4261:                                       gfxSkipCharsIterator* aSkipIter,
  4261:                                       PRUint32 aSkippedStartOffset,
  4261:                                       PRUint32 aSkippedMaxLength)
  4261: {
  4261:   // The handling of aSkippedStartOffset and aSkippedMaxLength could be more efficient...
  4261:   gfxSkipCharsBuilder skipCharsBuilder;
  4261:   nsTextFrame* textFrame;
 35581:   const nsTextFragment* textFrag = mContent->GetText();
  4678:   PRUint32 keptCharsLength = 0;
  4678:   PRUint32 validCharsLength = 0;
  4261: 
  4261:   // Build skipChars and copy text, for each text frame in this continuation block
  4261:   for (textFrame = this; textFrame;
  4261:        textFrame = static_cast<nsTextFrame*>(textFrame->GetNextContinuation())) {
  4261:     // For each text frame continuation in this block ...
  4261: 
 80587:     if (textFrame->GetStateBits() & NS_FRAME_IS_DIRTY) {
 80587:       // We don't trust dirty frames, expecially when computing rendered text.
 80587:       break;
 80587:     }
 80587: 
  4261:     // Ensure the text run and grab the gfxSkipCharsIterator for it
 82675:     gfxSkipCharsIterator iter =
 82675:       textFrame->EnsureTextRun(nsTextFrame::eInflated);
  4261:     if (!textFrame->mTextRun)
  4261:       return NS_ERROR_FAILURE;
  4261: 
  4261:     // Skip to the start of the text run, past ignored chars at start of line
  4261:     // XXX In the future we may decide to trim extra spaces before a hard line
  4261:     // break, in which case we need to accurately detect those sitations and 
 80486:     // call GetTrimmedOffsets() with true to trim whitespace at the line's end
 80486:     TrimmedOffsets trimmedContentOffsets = textFrame->GetTrimmedOffsets(textFrag, false);
  4261:     PRInt32 startOfLineSkipChars = trimmedContentOffsets.mStart - textFrame->mContentOffset;
  4261:     if (startOfLineSkipChars > 0) {
  4261:       skipCharsBuilder.SkipChars(startOfLineSkipChars);
  4261:       iter.SetOriginalOffset(trimmedContentOffsets.mStart);
  4261:     }
  4261: 
  4261:     // Keep and copy the appropriate chars withing the caller's requested range
  4261:     const nsStyleText* textStyle = textFrame->GetStyleText();
  4261:     while (iter.GetOriginalOffset() < trimmedContentOffsets.GetEnd() &&
  4261:            keptCharsLength < aSkippedMaxLength) {
  4261:       // For each original char from content text
  4261:       if (iter.IsOriginalCharSkipped() || ++validCharsLength <= aSkippedStartOffset) {
  4261:         skipCharsBuilder.SkipChar();
  4261:       } else {
  4261:         ++keptCharsLength;
  4261:         skipCharsBuilder.KeepChar();
  4261:         if (aAppendToString) {
  4261:           aAppendToString->Append(
  4261:               TransformChar(textStyle, textFrame->mTextRun, iter.GetSkippedOffset(),
  4261:                             textFrag->CharAt(iter.GetOriginalOffset())));
  4261:         }
  4261:       }
  4261:       iter.AdvanceOriginal(1);
  4261:     }
  4261:     if (keptCharsLength >= aSkippedMaxLength) {
  4261:       break; // Already past the end, don't build string or gfxSkipCharsIter anymore
  4261:     }
  4261:   }
  4261:   
  4261:   if (aSkipChars) {
  4261:     aSkipChars->TakeFrom(&skipCharsBuilder); // Copy skipChars into aSkipChars
  4261:     if (aSkipIter) {
  4261:       // Caller must provide both pointers in order to retrieve a gfxSkipCharsIterator,
  4261:       // because the gfxSkipCharsIterator holds a weak pointer to the gfxSkipCars.
  4261:       *aSkipIter = gfxSkipCharsIterator(*aSkipChars, GetContentLength());
  4261:     }
  4261:   }
  4261: 
  4261:   return NS_OK;
  4261: }
  4261: 
     1: #ifdef DEBUG
     1: // Translate the mapped content into a string that's printable
     1: void
  8252: nsTextFrame::ToCString(nsCString& aBuf, PRInt32* aTotalContentLength) const
     1: {
     1:   // Get the frames text content
 35581:   const nsTextFragment* frag = mContent->GetText();
     1:   if (!frag) {
     1:     return;
     1:   }
     1: 
     1:   // Compute the total length of the text content.
     1:   *aTotalContentLength = frag->GetLength();
     1: 
  4678:   PRInt32 contentLength = GetContentLength();
     1:   // Set current fragment and current fragment offset
  4678:   if (0 == contentLength) {
     1:     return;
     1:   }
  4678:   PRInt32 fragOffset = GetContentOffset();
  4678:   PRInt32 n = fragOffset + contentLength;
     1:   while (fragOffset < n) {
     1:     PRUnichar ch = frag->CharAt(fragOffset++);
     1:     if (ch == '\r') {
     1:       aBuf.AppendLiteral("\\r");
     1:     } else if (ch == '\n') {
     1:       aBuf.AppendLiteral("\\n");
     1:     } else if (ch == '\t') {
     1:       aBuf.AppendLiteral("\\t");
     1:     } else if ((ch < ' ') || (ch >= 127)) {
  8252:       aBuf.Append(nsPrintfCString("\\u%04x", ch));
     1:     } else {
     1:       aBuf.Append(ch);
     1:     }
     1:   }
     1: }
     1: #endif
     1: 
     1: nsIAtom*
     1: nsTextFrame::GetType() const
     1: {
     1:   return nsGkAtoms::textFrame;
     1: }
     1: 
 79445: /* virtual */ bool
     1: nsTextFrame::IsEmpty()
     1: {
     1:   NS_ASSERTION(!(mState & TEXT_IS_ONLY_WHITESPACE) ||
     1:                !(mState & TEXT_ISNOT_ONLY_WHITESPACE),
     1:                "Invalid state");
     1:   
     1:   // XXXldb Should this check compatibility mode as well???
 16575:   const nsStyleText* textStyle = GetStyleText();
 16575:   if (textStyle->WhiteSpaceIsSignificant()) {
 16575:     // XXX shouldn't we return true if the length is zero?
 80486:     return false;
     1:   }
     1: 
     1:   if (mState & TEXT_ISNOT_ONLY_WHITESPACE) {
 80486:     return false;
     1:   }
     1: 
     1:   if (mState & TEXT_IS_ONLY_WHITESPACE) {
 80486:     return true;
     1:   }
     1:   
 79445:   bool isEmpty = IsAllWhitespace(mContent->GetText(),
 16575:           textStyle->mWhiteSpace != NS_STYLE_WHITESPACE_PRE_LINE);
     1:   mState |= (isEmpty ? TEXT_IS_ONLY_WHITESPACE : TEXT_ISNOT_ONLY_WHITESPACE);
     1:   return isEmpty;
     1: }
     1: 
     1: #ifdef DEBUG
     1: NS_IMETHODIMP
     1: nsTextFrame::GetFrameName(nsAString& aResult) const
     1: {
 82352:   MakeFrameName(NS_LITERAL_STRING("Text"), aResult);
 82352:   PRInt32 totalContentLength;
 82352:   nsCAutoString tmp;
 82352:   ToCString(tmp, &totalContentLength);
 82352:   tmp.SetLength(NS_MIN(tmp.Length(), 50u));
 82352:   aResult += NS_LITERAL_STRING("\"") + NS_ConvertASCIItoUTF16(tmp) + NS_LITERAL_STRING("\"");
 82352:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP_(nsFrameState)
     1: nsTextFrame::GetDebugStateBits() const
     1: {
     1:   // mask out our emptystate flags; those are just caches
     1:   return nsFrame::GetDebugStateBits() &
     1:     ~(TEXT_WHITESPACE_FLAGS | TEXT_REFLOW_FLAGS);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTextFrame::List(FILE* out, PRInt32 aIndent) const
     1: {
     1:   // Output the tag
     1:   IndentBy(out, aIndent);
     1:   ListTag(out);
     1:   if (HasView()) {
  3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
     1:   }
 56311:   fprintf(out, " [run=%p]", static_cast<void*>(mTextRun));
     1: 
     1:   // Output the first/last content offset and prev/next in flow info
 90629:   bool isComplete = PRUint32(GetContentEnd()) == GetContent()->TextLength();
     1:   fprintf(out, "[%d,%d,%c] ", 
  4678:           GetContentOffset(), GetContentLength(),
     1:           isComplete ? 'T':'F');
     1:   
 32845:   if (GetNextSibling()) {
 32845:     fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
     1:   }
     1:   nsIFrame* prevContinuation = GetPrevContinuation();
     1:   if (nsnull != prevContinuation) {
  3233:     fprintf(out, " prev-continuation=%p", static_cast<void*>(prevContinuation));
     1:   }
     1:   if (nsnull != mNextContinuation) {
  3233:     fprintf(out, " next-continuation=%p", static_cast<void*>(mNextContinuation));
     1:   }
     1: 
     1:   // Output the rect and state
     1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
 85981:   fprintf(out, " [state=%016llx]", (unsigned long long)mState);
 85101:   if (IsSelected()) {
 85101:     fprintf(out, " SELECTED");
     1:   }
  3233:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
 55040:   if (HasOverflowAreas()) {
 55040:     nsRect overflowArea = GetVisualOverflowRect();
 55040:     fprintf(out, " [vis-overflow=%d,%d,%d,%d]",
 55040:             overflowArea.x, overflowArea.y,
 55040:             overflowArea.width, overflowArea.height);
 55040:     overflowArea = GetScrollableOverflowRect();
 55040:     fprintf(out, " [scr-overflow=%d,%d,%d,%d]",
 55040:             overflowArea.x, overflowArea.y,
 11909:             overflowArea.width, overflowArea.height);
  6247:   }
  3233:   fprintf(out, " sc=%p", static_cast<void*>(mStyleContext));
 34387:   nsIAtom* pseudoTag = mStyleContext->GetPseudo();
     1:   if (pseudoTag) {
     1:     nsAutoString atomString;
     1:     pseudoTag->ToString(atomString);
     1:     fprintf(out, " pst=%s",
     1:             NS_LossyConvertUTF16toASCII(atomString).get());
     1:   }
 82352:   fputs("\n", out);
     1:   return NS_OK;
     1: }
     1: #endif
     1: 
     1: void
     1: nsTextFrame::AdjustOffsetsForBidi(PRInt32 aStart, PRInt32 aEnd)
     1: {
     1:   AddStateBits(NS_FRAME_IS_BIDI);
 70231:   mContent->DeleteProperty(nsGkAtoms::flowlength);
  4678: 
  5307:   /*
  5307:    * After Bidi resolution we may need to reassign text runs.
  5307:    * This is called during bidi resolution from the block container, so we
  5307:    * shouldn't be holding a local reference to a textrun anywhere.
  5307:    */
 82675:   ClearTextRuns();
  5307: 
  6383:   nsTextFrame* prev = static_cast<nsTextFrame*>(GetPrevContinuation());
  4678:   if (prev) {
  4678:     // the bidi resolver can be very evil when columns/pages are involved. Don't
  4678:     // let it violate our invariants.
  4678:     PRInt32 prevOffset = prev->GetContentOffset();
 32531:     aStart = NS_MAX(aStart, prevOffset);
 32531:     aEnd = NS_MAX(aEnd, prevOffset);
 82675:     prev->ClearTextRuns();
  4678:   }
  9810: 
  4678:   mContentOffset = aStart;
 62893:   SetLength(aEnd - aStart, nsnull, 0);
 73004: 
 73004:   /**
 73004:    * After inserting text the caret Bidi level must be set to the level of the
 73004:    * inserted text.This is difficult, because we cannot know what the level is
 73004:    * until after the Bidi algorithm is applied to the whole paragraph.
 73004:    *
 73004:    * So we set the caret Bidi level to UNDEFINED here, and the caret code will
 73004:    * set it correctly later
 73004:    */
 73004:   nsRefPtr<nsFrameSelection> frameSelection = GetFrameSelection();
 73004:   if (frameSelection) {
 73004:     frameSelection->UndefineCaretBidiLevel();
 73004:   }
     1: }
     1: 
     1: /**
 80486:  * @return true if this text frame ends with a newline character.  It should return
 80486:  * false if it is not a text frame.
     1:  */
 79445: bool
     1: nsTextFrame::HasTerminalNewline() const
     1: {
  3009:   return ::HasTerminalNewline(this);
  3009: }
  7677: 
 79445: bool
  7677: nsTextFrame::IsAtEndOfLine() const
  7677: {
  7677:   return (GetStateBits() & TEXT_END_OF_LINE) != 0;
  7677: }
 53735: 
 56866: nscoord
 56866: nsTextFrame::GetBaseline() const
 56866: {
 56866:   return mAscent;
 56866: }
 56866: 
 79445: bool
 53735: nsTextFrame::HasAnyNoncollapsedCharacters()
 53735: {
 82675:   gfxSkipCharsIterator iter = EnsureTextRun(nsTextFrame::eInflated);
 53735:   PRInt32 offset = GetContentOffset(),
 53735:           offsetEnd = GetContentEnd();
 53735:   PRInt32 skippedOffset = iter.ConvertOriginalToSkipped(offset);
 53735:   PRInt32 skippedOffsetEnd = iter.ConvertOriginalToSkipped(offsetEnd);
 53735:   return skippedOffset != skippedOffsetEnd;
 53735: }
