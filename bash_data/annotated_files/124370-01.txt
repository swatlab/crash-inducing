     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode:nil; c-basic-offset: 2 -*- */
  3640: /* vim:set ts=2 sts=2 sw=2 et cin: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsURILoader.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsIURIContentListener.h"
     1: #include "nsIContentHandler.h"
     1: #include "nsILoadGroup.h"
     1: #include "nsIDocumentLoader.h"
     1: #include "nsIWebProgress.h"
     1: #include "nsIWebProgressListener.h"
     1: #include "nsIIOService.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIStreamListener.h"
     1: #include "nsIURI.h"
     1: #include "nsIChannel.h"
     1: #include "nsIInterfaceRequestor.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsIProgressEventSink.h"
     1: #include "nsIInputStream.h"
     1: #include "nsIStreamConverterService.h"
     1: #include "nsWeakReference.h"
     1: #include "nsIHttpChannel.h"
     1: #include "nsIMultiPartChannel.h"
     1: #include "netCore.h"
     1: #include "nsCRT.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShellTreeOwner.h"
     1: 
     1: #include "nsXPIDLString.h"
     1: #include "nsString.h"
 25243: #include "nsNetUtil.h"
     1: #include "nsReadableUtils.h"
108290: #include "nsError.h"
     1: 
     1: #include "nsICategoryManager.h"
     1: #include "nsCExternalHandlerService.h" // contains contractids for the helper app service
     1: 
     1: #include "nsIMIMEHeaderParam.h"
     1: #include "nsNetCID.h"
     1: 
     1: #include "nsMimeTypes.h"
     1: 
     1: #include "nsDocLoader.h"
102220: #include "mozilla/Attributes.h"
     1: 
     1: #ifdef PR_LOGGING
106838: PRLogModuleInfo* nsURILoader::mLog = nullptr;
     1: #endif
     1: 
     1: #define LOG(args) PR_LOG(nsURILoader::mLog, PR_LOG_DEBUG, args)
     1: #define LOG_ERROR(args) PR_LOG(nsURILoader::mLog, PR_LOG_ERROR, args)
     1: #define LOG_ENABLED() PR_LOG_TEST(nsURILoader::mLog, PR_LOG_DEBUG)
     1: 
     1: /**
     1:  * The nsDocumentOpenInfo contains the state required when a single
     1:  * document is being opened in order to discover the content type...
     1:  * Each instance remains alive until its target URL has been loaded
     1:  * (or aborted).
     1:  */
102220: class nsDocumentOpenInfo MOZ_FINAL : public nsIStreamListener
     1: {
     1: public:
     1:   // Needed for nsCOMPtr to work right... Don't call this!
     1:   nsDocumentOpenInfo();
     1: 
     1:   // Real constructor
     1:   // aFlags is a combination of the flags on nsIURILoader
     1:   nsDocumentOpenInfo(nsIInterfaceRequestor* aWindowContext,
108991:                      uint32_t aFlags,
     1:                      nsURILoader* aURILoader);
     1: 
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   /**
     1:    * Prepares this object for receiving data. The stream
     1:    * listener methods of this class must not be called before calling this
     1:    * method.
     1:    */
     1:   nsresult Prepare();
     1: 
     1:   // Call this (from OnStartRequest) to attempt to find an nsIStreamListener to
     1:   // take the data off our hands.
     1:   nsresult DispatchContent(nsIRequest *request, nsISupports * aCtxt);
     1: 
     1:   // Call this if we need to insert a stream converter from aSrcContentType to
     1:   // aOutContentType into the StreamListener chain.  DO NOT call it if the two
     1:   // types are the same, since no conversion is needed in that case.
     1:   nsresult ConvertData(nsIRequest *request,
     1:                        nsIURIContentListener *aListener,
     1:                        const nsACString & aSrcContentType,
     1:                        const nsACString & aOutContentType);
     1: 
     1:   /**
     1:    * Function to attempt to use aListener to handle the load.  If
 80486:    * true is returned, nothing else needs to be done; if false
     1:    * is returned, then a different way of handling the load should be
     1:    * tried.
     1:    */
 79445:   bool TryContentListener(nsIURIContentListener* aListener,
     1:                             nsIChannel* aChannel);
     1: 
     1:   // nsIRequestObserver methods:
     1:   NS_DECL_NSIREQUESTOBSERVER
     1: 
     1:   // nsIStreamListener methods:
     1:   NS_DECL_NSISTREAMLISTENER
     1: 
     1: protected:
     1:   ~nsDocumentOpenInfo();
     1: 
     1: protected:
     1:   /**
     1:    * The first content listener to try dispatching data to.  Typically
     1:    * the listener associated with the entity that originated the load.
     1:    */
     1:   nsCOMPtr<nsIURIContentListener> m_contentListener;
     1: 
     1:   /**
     1:    * The stream listener to forward nsIStreamListener notifications
     1:    * to.  This is set once the load is dispatched.
     1:    */
     1:   nsCOMPtr<nsIStreamListener> m_targetStreamListener;
     1: 
     1:   /**
     1:    * A pointer to the entity that originated the load. We depend on getting
     1:    * things like nsIURIContentListeners, nsIDOMWindows, etc off of it.
     1:    */
     1:   nsCOMPtr<nsIInterfaceRequestor> m_originalContext;
     1: 
     1:   /**
     1:    * IS_CONTENT_PREFERRED is used for the boolean to pass to CanHandleContent
     1:    * (also determines whether we use CanHandleContent or IsPreferred).
     1:    * DONT_RETARGET means that we will only try m_originalContext, no other
     1:    * listeners.
     1:    */
108991:   uint32_t mFlags;
     1: 
     1:   /**
     1:    * The type of the data we will be trying to dispatch.
     1:    */
     1:   nsCString mContentType;
     1: 
     1:   /**
     1:    * Reference to the URILoader service so we can access its list of
     1:    * nsIURIContentListeners.
     1:    */
     1:   nsRefPtr<nsURILoader> mURILoader;
     1: };
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsDocumentOpenInfo)
     1: NS_IMPL_THREADSAFE_RELEASE(nsDocumentOpenInfo)
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsDocumentOpenInfo)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIRequestObserver)
     1:   NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
     1:   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: nsDocumentOpenInfo::nsDocumentOpenInfo()
     1: {
     1:   NS_NOTREACHED("This should never be called\n");
     1: }
     1: 
     1: nsDocumentOpenInfo::nsDocumentOpenInfo(nsIInterfaceRequestor* aWindowContext,
108991:                                        uint32_t aFlags,
     1:                                        nsURILoader* aURILoader)
     1:   : m_originalContext(aWindowContext),
     1:     mFlags(aFlags),
     1:     mURILoader(aURILoader)
     1: {
     1: }
     1: 
     1: nsDocumentOpenInfo::~nsDocumentOpenInfo()
     1: {
     1: }
     1: 
     1: nsresult nsDocumentOpenInfo::Prepare()
     1: {
     1:   LOG(("[0x%p] nsDocumentOpenInfo::Prepare", this));
     1: 
     1:   nsresult rv;
     1: 
     1:   // ask our window context if it has a uri content listener...
     1:   m_contentListener = do_GetInterface(m_originalContext, &rv);
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP nsDocumentOpenInfo::OnStartRequest(nsIRequest *request, nsISupports * aCtxt)
     1: {
     1:   LOG(("[0x%p] nsDocumentOpenInfo::OnStartRequest", this));
124370:   MOZ_ASSERT(request);
124370:   if (!request) {
124370:     return NS_ERROR_UNEXPECTED;
124370:   }
     1: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   //
     1:   // Deal with "special" HTTP responses:
     1:   // 
     1:   // - In the case of a 204 (No Content) or 205 (Reset Content) response, do
     1:   //   not try to find a content handler.  Return NS_BINDING_ABORTED to cancel
     1:   //   the request.  This has the effect of ensuring that the DocLoader does
     1:   //   not try to interpret this as a real request.
     1:   // 
     1:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(request, &rv));
     1: 
     1:   if (NS_SUCCEEDED(rv)) {
108991:     uint32_t responseCode = 0;
     1: 
     1:     rv = httpChannel->GetResponseStatus(&responseCode);
     1: 
     1:     if (NS_FAILED(rv)) {
     1:       LOG_ERROR(("  Failed to get HTTP response status"));
     1:       
     1:       // behave as in the canceled case
     1:       return NS_OK;
     1:     }
     1: 
     1:     LOG(("  HTTP response status: %d", responseCode));
     1: 
     1:     if (204 == responseCode || 205 == responseCode) {
     1:       return NS_BINDING_ABORTED;
     1:     }
     1:   }
     1: 
     1:   //
     1:   // Make sure that the transaction has succeeded, so far...
     1:   //
     1:   nsresult status;
     1: 
     1:   rv = request->GetStatus(&status);
     1:   
     1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Unable to get request status!");
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   if (NS_FAILED(status)) {
     1:     LOG_ERROR(("  Request failed, status: 0x%08X", rv));
     1:   
     1:     //
     1:     // The transaction has already reported an error - so it will be torn
     1:     // down. Therefore, it is not necessary to return an error code...
     1:     //
     1:     return NS_OK;
     1:   }
     1: 
     1:   rv = DispatchContent(request, aCtxt);
     1: 
     1:   LOG(("  After dispatch, m_targetStreamListener: 0x%p, rv: 0x%08X", m_targetStreamListener.get(), rv));
     1: 
     1:   NS_ASSERTION(NS_SUCCEEDED(rv) || !m_targetStreamListener,
     1:                "Must not have an m_targetStreamListener with a failure return!");
     1: 
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1:   
     1:   if (m_targetStreamListener)
     1:     rv = m_targetStreamListener->OnStartRequest(request, aCtxt);
     1: 
     1:   LOG(("  OnStartRequest returning: 0x%08X", rv));
     1:   
     1:   return rv;
     1: }
     1: 
111234: NS_IMETHODIMP
111234: nsDocumentOpenInfo::OnDataAvailable(nsIRequest *request, nsISupports * aCtxt,
111234:                                     nsIInputStream * inStr,
111234:                                     uint64_t sourceOffset, uint32_t count)
     1: {
     1:   // if we have retarged to the end stream listener, then forward the call....
     1:   // otherwise, don't do anything
     1: 
     1:   nsresult rv = NS_OK;
     1:   
     1:   if (m_targetStreamListener)
     1:     rv = m_targetStreamListener->OnDataAvailable(request, aCtxt, inStr, sourceOffset, count);
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP nsDocumentOpenInfo::OnStopRequest(nsIRequest *request, nsISupports *aCtxt, 
     1:                                                 nsresult aStatus)
     1: {
     1:   LOG(("[0x%p] nsDocumentOpenInfo::OnStopRequest", this));
     1:   
     1:   if ( m_targetStreamListener)
     1:   {
     1:     nsCOMPtr<nsIStreamListener> listener(m_targetStreamListener);
     1: 
     1:     // If this is a multipart stream, we could get another
     1:     // OnStartRequest after this... reset state.
     1:     m_targetStreamListener = 0;
     1:     mContentType.Truncate();
     1:     listener->OnStopRequest(request, aCtxt, aStatus);
     1:   }
     1: 
     1:   // Remember...
     1:   // In the case of multiplexed streams (such as multipart/x-mixed-replace)
     1:   // these stream listener methods could be called again :-)
     1:   //
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult nsDocumentOpenInfo::DispatchContent(nsIRequest *request, nsISupports * aCtxt)
     1: {
     1:   LOG(("[0x%p] nsDocumentOpenInfo::DispatchContent for type '%s'", this, mContentType.get()));
     1: 
     1:   NS_PRECONDITION(!m_targetStreamListener,
     1:                   "Why do we already have a target stream listener?");
     1:   
     1:   nsresult rv;
     1:   nsCOMPtr<nsIChannel> aChannel = do_QueryInterface(request);
     1:   if (!aChannel) {
     1:     LOG_ERROR(("  Request is not a channel.  Bailing."));
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   NS_NAMED_LITERAL_CSTRING(anyType, "*/*");
     1:   if (mContentType.IsEmpty() || mContentType == anyType) {
     1:     rv = aChannel->GetContentType(mContentType);
     1:     if (NS_FAILED(rv)) return rv;
     1:     LOG(("  Got type from channel: '%s'", mContentType.get()));
     1:   }
     1: 
 79445:   bool isGuessFromExt =
     1:     mContentType.LowerCaseEqualsASCII(APPLICATION_GUESS_FROM_EXT);
     1:   if (isGuessFromExt) {
     1:     // Reset to application/octet-stream for now; no one other than the
     1:     // external helper app service should see APPLICATION_GUESS_FROM_EXT.
     1:     mContentType = APPLICATION_OCTET_STREAM;
     1:     aChannel->SetContentType(NS_LITERAL_CSTRING(APPLICATION_OCTET_STREAM));
     1:   }
     1: 
     1:   // Check whether the data should be forced to be handled externally.  This
     1:   // could happen because the Content-Disposition header is set so, or, in the
     1:   // future, because the user has specified external handling for the MIME
     1:   // type.
 79445:   bool forceExternalHandling = false;
108991:   uint32_t disposition;
 78165:   rv = aChannel->GetContentDisposition(&disposition);
 78165:   if (NS_SUCCEEDED(rv) && disposition == nsIChannel::DISPOSITION_ATTACHMENT)
 80486:     forceExternalHandling = true;
     1: 
     1:   LOG(("  forceExternalHandling: %s", forceExternalHandling ? "yes" : "no"));
     1:     
     1:   // We're going to try to find a contentListener that can handle our data
     1:   nsCOMPtr<nsIURIContentListener> contentListener;
     1:   // The type or data the contentListener wants.
     1:   nsXPIDLCString desiredContentType;
     1: 
     1:   if (!forceExternalHandling)
     1:   {
     1:     //
     1:     // First step: See whether m_contentListener wants to handle this
     1:     // content type.
     1:     //
     1:     if (m_contentListener && TryContentListener(m_contentListener, aChannel)) {
     1:       LOG(("  Success!  Our default listener likes this type"));
     1:       // All done here
     1:       return NS_OK;
     1:     }
     1: 
 40647:     // If we aren't allowed to try other listeners, just skip through to
 40647:     // trying to convert the data.
     1:     if (!(mFlags & nsIURILoader::DONT_RETARGET)) {
     1: 
     1:       //
     1:       // Second step: See whether some other registered listener wants
     1:       // to handle this content type.
     1:       //
108991:       int32_t count = mURILoader->m_listeners.Count();
     1:       nsCOMPtr<nsIURIContentListener> listener;
108991:       for (int32_t i = 0; i < count; i++) {
     1:         listener = do_QueryReferent(mURILoader->m_listeners[i]);
     1:         if (listener) {
     1:           if (TryContentListener(listener, aChannel)) {
     1:             LOG(("  Found listener registered on the URILoader"));
     1:             return NS_OK;
     1:           }
     1:         } else {
     1:           // remove from the listener list, reset i and update count
     1:           mURILoader->m_listeners.RemoveObjectAt(i--);
     1:           --count;
     1:         }
     1:       }
     1: 
     1:       //
     1:       // Third step: Try to find a content listener that has not yet had
     1:       // the chance to register, as it is contained in a not-yet-loaded
     1:       // module, but which has registered a contract ID.
     1:       //
     1:       nsCOMPtr<nsICategoryManager> catman =
     1:         do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
     1:       if (catman) {
     1:         nsXPIDLCString contractidString;
     1:         rv = catman->GetCategoryEntry(NS_CONTENT_LISTENER_CATEGORYMANAGER_ENTRY,
     1:                                       mContentType.get(),
     1:                                       getter_Copies(contractidString));
     1:         if (NS_SUCCEEDED(rv) && !contractidString.IsEmpty()) {
     1:           LOG(("  Listener contractid for '%s' is '%s'",
     1:                mContentType.get(), contractidString.get()));
     1: 
     1:           listener = do_CreateInstance(contractidString);
     1:           LOG(("  Listener from category manager: 0x%p", listener.get()));
     1:           
     1:           if (listener && TryContentListener(listener, aChannel)) {
     1:             LOG(("  Listener from category manager likes this type"));
     1:             return NS_OK;
     1:           }
     1:         }
     1:       }
     1: 
     1:       //
     1:       // Fourth step: try to find an nsIContentHandler for our type.
     1:       //
110974:       nsAutoCString handlerContractID (NS_CONTENT_HANDLER_CONTRACTID_PREFIX);
     1:       handlerContractID += mContentType;
     1: 
     1:       nsCOMPtr<nsIContentHandler> contentHandler =
     1:         do_CreateInstance(handlerContractID.get());
     1:       if (contentHandler) {
     1:         LOG(("  Content handler found"));
     1:         rv = contentHandler->HandleContent(mContentType.get(),
     1:                                            m_originalContext, request);
     1:         // XXXbz returning an error code to represent handling the
     1:         // content is just bizarre!
     1:         if (rv != NS_ERROR_WONT_HANDLE_CONTENT) {
     1:           if (NS_FAILED(rv)) {
     1:             // The content handler has unexpectedly failed.  Cancel the request
     1:             // just in case the handler didn't...
     1:             LOG(("  Content handler failed.  Aborting load"));
     1:             request->Cancel(rv);
     1:           }
     1: #ifdef PR_LOGGING
     1:           else {
     1:             LOG(("  Content handler taking over load"));
     1:           }
     1: #endif
     1: 
     1:           return rv;
     1:         }
     1:       }
 40647:     } else {
 40647:       LOG(("  DONT_RETARGET flag set, so skipped over random other content "
 40647:            "listeners and content handlers"));
     1:     }
     1: 
     1:     //
     1:     // Fifth step:  If no listener prefers this type, see if any stream
     1:     //              converters exist to transform this content type into
     1:     //              some other.
     1:     //
     1:     // Don't do this if the server sent us a MIME type of "*/*" because they saw
     1:     // it in our Accept header and got confused.
     1:     // XXXbz have to be careful here; may end up in some sort of bizarre infinite
     1:     // decoding loop.
     1:     if (mContentType != anyType) {
     1:       rv = ConvertData(request, m_contentListener, mContentType, anyType);
     1:       if (NS_FAILED(rv)) {
106838:         m_targetStreamListener = nullptr;
     1:       } else if (m_targetStreamListener) {
     1:         // We found a converter for this MIME type.  We'll just pump data into it
     1:         // and let the downstream nsDocumentOpenInfo handle things.
     1:         LOG(("  Converter taking over now"));
     1:         return NS_OK;
     1:       }
     1:     }
 40647:   }
 40647: 
 40647:   NS_ASSERTION(!m_targetStreamListener,
 40647:                "If we found a listener, why are we not using it?");
     1:   
     1:   if (mFlags & nsIURILoader::DONT_RETARGET) {
 40647:     LOG(("  External handling forced or (listener not interested and no "
 40647:          "stream converter exists), and retargeting disallowed -> aborting"));
     1:     return NS_ERROR_WONT_HANDLE_CONTENT;
     1:   }
     1: 
     1:   // Before dispatching to the external helper app service, check for an HTTP
     1:   // error page.  If we got one, we don't want to handle it with a helper app,
     1:   // really.
 78165:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(request));
     1:   if (httpChannel) {
 79445:     bool requestSucceeded;
     1:     httpChannel->GetRequestSucceeded(&requestSucceeded);
     1:     if (!requestSucceeded) {
     1:       // returning error from OnStartRequest will cancel the channel
     1:       return NS_ERROR_FILE_NOT_FOUND;
     1:     }
     1:   }
     1:   
     1:   // Sixth step:
     1:   //
     1:   // All attempts to dispatch this content have failed.  Just pass it off to
     1:   // the helper app service.
     1:   //
     1:   nsCOMPtr<nsIExternalHelperAppService> helperAppService =
     1:     do_GetService(NS_EXTERNALHELPERAPPSERVICE_CONTRACTID, &rv);
     1:   if (helperAppService) {
     1:     LOG(("  Passing load off to helper app service"));
     1: 
     1:     // Set these flags to indicate that the channel has been targeted and that
     1:     // we are not using the original consumer.
     1:     nsLoadFlags loadFlags = 0;
     1:     request->GetLoadFlags(&loadFlags);
     1:     request->SetLoadFlags(loadFlags | nsIChannel::LOAD_RETARGETED_DOCUMENT_URI
     1:                                     | nsIChannel::LOAD_TARGETED);
     1: 
     1:     if (isGuessFromExt) {
     1:       mContentType = APPLICATION_GUESS_FROM_EXT;
     1:       aChannel->SetContentType(NS_LITERAL_CSTRING(APPLICATION_GUESS_FROM_EXT));
     1:     }
     1: 
     1:     rv = helperAppService->DoContent(mContentType,
     1:                                      request,
     1:                                      m_originalContext,
 80486:                                      false,
     1:                                      getter_AddRefs(m_targetStreamListener));
     1:     if (NS_FAILED(rv)) {
     1:       request->SetLoadFlags(loadFlags);
106838:       m_targetStreamListener = nullptr;
     1:     }
     1:   }
     1:       
     1:   NS_ASSERTION(m_targetStreamListener || NS_FAILED(rv),
     1:                "There is no way we should be successful at this point without a m_targetStreamListener");
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsDocumentOpenInfo::ConvertData(nsIRequest *request,
     1:                                 nsIURIContentListener* aListener,
     1:                                 const nsACString& aSrcContentType,
     1:                                 const nsACString& aOutContentType)
     1: {
     1:   LOG(("[0x%p] nsDocumentOpenInfo::ConvertData from '%s' to '%s'", this,
     1:        PromiseFlatCString(aSrcContentType).get(),
     1:        PromiseFlatCString(aOutContentType).get()));
     1: 
     1:   NS_PRECONDITION(aSrcContentType != aOutContentType,
     1:                   "ConvertData called when the two types are the same!");
     1:   nsresult rv = NS_OK;
     1: 
     1:   nsCOMPtr<nsIStreamConverterService> StreamConvService = 
     1:     do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID, &rv);
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   LOG(("  Got converter service"));
     1:   
     1:   // When applying stream decoders, it is necessary to "insert" an 
     1:   // intermediate nsDocumentOpenInfo instance to handle the targeting of
     1:   // the "final" stream or streams.
     1:   //
     1:   // For certain content types (ie. multi-part/x-mixed-replace) the input
     1:   // stream is split up into multiple destination streams.  This
     1:   // intermediate instance is used to target these "decoded" streams...
     1:   //
     1:   nsCOMPtr<nsDocumentOpenInfo> nextLink =
     1:     new nsDocumentOpenInfo(m_originalContext, mFlags, mURILoader);
     1:   if (!nextLink) return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   LOG(("  Downstream DocumentOpenInfo would be: 0x%p", nextLink.get()));
     1:   
     1:   // Make sure nextLink starts with the contentListener that said it wanted the
     1:   // results of this decode.
     1:   nextLink->m_contentListener = aListener;
     1:   // Also make sure it has to look for a stream listener to pump data into.
106838:   nextLink->m_targetStreamListener = nullptr;
     1: 
     1:   // Make sure that nextLink treats the data as aOutContentType when
     1:   // dispatching; that way even if the stream converters don't change the type
     1:   // on the channel we will still do the right thing.  If aOutContentType is
     1:   // */*, that's OK -- that will just indicate to nextLink that it should get
     1:   // the type off the channel.
     1:   nextLink->mContentType = aOutContentType;
     1: 
     1:   // The following call sets m_targetStreamListener to the input end of the
     1:   // stream converter and sets the output end of the stream converter to
     1:   // nextLink.  As we pump data into m_targetStreamListener the stream
     1:   // converter will convert it and pass the converted data to nextLink.
     1:   return StreamConvService->AsyncConvertData(PromiseFlatCString(aSrcContentType).get(), 
     1:                                              PromiseFlatCString(aOutContentType).get(), 
     1:                                              nextLink, 
     1:                                              request,
     1:                                              getter_AddRefs(m_targetStreamListener));
     1: }
     1: 
 79445: bool
     1: nsDocumentOpenInfo::TryContentListener(nsIURIContentListener* aListener,
     1:                                        nsIChannel* aChannel)
     1: {
     1:   LOG(("[0x%p] nsDocumentOpenInfo::TryContentListener; mFlags = 0x%x",
     1:        this, mFlags));
     1: 
     1:   NS_PRECONDITION(aListener, "Must have a non-null listener");
     1:   NS_PRECONDITION(aChannel, "Must have a channel");
     1:   
 79445:   bool listenerWantsContent = false;
     1:   nsXPIDLCString typeToUse;
     1:   
     1:   if (mFlags & nsIURILoader::IS_CONTENT_PREFERRED) {
     1:     aListener->IsPreferred(mContentType.get(),
     1:                            getter_Copies(typeToUse),
     1:                            &listenerWantsContent);
     1:   } else {
 80486:     aListener->CanHandleContent(mContentType.get(), false,
     1:                                 getter_Copies(typeToUse),
     1:                                 &listenerWantsContent);
     1:   }
     1:   if (!listenerWantsContent) {
     1:     LOG(("  Listener is not interested"));
 80486:     return false;
     1:   }
     1: 
     1:   if (!typeToUse.IsEmpty() && typeToUse != mContentType) {
     1:     // Need to do a conversion here.
     1: 
     1:     nsresult rv = ConvertData(aChannel, aListener, mContentType, typeToUse);
     1: 
     1:     if (NS_FAILED(rv)) {
     1:       // No conversion path -- we don't want this listener, if we got one
106838:       m_targetStreamListener = nullptr;
     1:     }
     1: 
     1:     LOG(("  Found conversion: %s", m_targetStreamListener ? "yes" : "no"));
     1:     
     1:     // m_targetStreamListener is now the input end of the converter, and we can
     1:     // just pump the data in there, if it exists.  If it does not, we need to
     1:     // try other nsIURIContentListeners.
106838:     return m_targetStreamListener != nullptr;
     1:   }
     1: 
     1:   // At this point, aListener wants data of type mContentType.  Let 'em have
     1:   // it.  But first, if we are retargeting, set an appropriate flag on the
     1:   // channel
     1:   nsLoadFlags loadFlags = 0;
     1:   aChannel->GetLoadFlags(&loadFlags);
     1: 
     1:   // Set this flag to indicate that the channel has been targeted at a final
     1:   // consumer.  This load flag is tested in nsDocLoader::OnProgress.
     1:   nsLoadFlags newLoadFlags = nsIChannel::LOAD_TARGETED;
     1: 
     1:   nsCOMPtr<nsIURIContentListener> originalListener =
     1:     do_GetInterface(m_originalContext);
     1:   if (originalListener != aListener) {
     1:     newLoadFlags |= nsIChannel::LOAD_RETARGETED_DOCUMENT_URI;
     1:   }
     1:   aChannel->SetLoadFlags(loadFlags | newLoadFlags);
     1:   
 79445:   bool abort = false;
 79445:   bool isPreferred = (mFlags & nsIURILoader::IS_CONTENT_PREFERRED) != 0;
     1:   nsresult rv = aListener->DoContent(mContentType.get(),
     1:                                      isPreferred,
     1:                                      aChannel,
     1:                                      getter_AddRefs(m_targetStreamListener),
     1:                                      &abort);
     1:     
     1:   if (NS_FAILED(rv)) {
     1:     LOG_ERROR(("  DoContent failed"));
     1:     
     1:     // Unset the RETARGETED_DOCUMENT_URI flag if we set it...
     1:     aChannel->SetLoadFlags(loadFlags);
106838:     m_targetStreamListener = nullptr;
 80486:     return false;
     1:   }
     1: 
     1:   if (abort) {
     1:     // Nothing else to do here -- aListener is handling it all.  Make
     1:     // sure m_targetStreamListener is null so we don't do anything
     1:     // after this point.
     1:     LOG(("  Listener has aborted the load"));
106838:     m_targetStreamListener = nullptr;
     1:   }
     1: 
     1:   NS_ASSERTION(abort || m_targetStreamListener, "DoContent returned no listener?");
     1: 
     1:   // aListener is handling the load from this point on.  
 80486:   return true;
     1: }
     1: 
     1: 
     1: ///////////////////////////////////////////////////////////////////////////////////////////////
     1: // Implementation of nsURILoader
     1: ///////////////////////////////////////////////////////////////////////////////////////////////
     1: 
     1: nsURILoader::nsURILoader()
     1: {
     1: #ifdef PR_LOGGING
     1:   if (!mLog) {
     1:     mLog = PR_NewLogModule("URILoader");
     1:   }
     1: #endif
     1: }
     1: 
     1: nsURILoader::~nsURILoader()
     1: {
     1: }
     1: 
     1: NS_IMPL_ADDREF(nsURILoader)
     1: NS_IMPL_RELEASE(nsURILoader)
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsURILoader)
     1:    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIURILoader)
     1:    NS_INTERFACE_MAP_ENTRY(nsIURILoader)
     1: NS_INTERFACE_MAP_END
     1: 
     1: NS_IMETHODIMP nsURILoader::RegisterContentListener(nsIURIContentListener * aContentListener)
     1: {
     1:   nsresult rv = NS_OK;
     1: 
     1:   nsWeakPtr weakListener = do_GetWeakReference(aContentListener);
     1:   NS_ASSERTION(weakListener, "your URIContentListener must support weak refs!\n");
     1:   
     1:   if (weakListener)
     1:     m_listeners.AppendObject(weakListener);
     1: 
     1:   return rv;
     1: } 
     1: 
     1: NS_IMETHODIMP nsURILoader::UnRegisterContentListener(nsIURIContentListener * aContentListener)
     1: {
     1:   nsWeakPtr weakListener = do_GetWeakReference(aContentListener);
     1:   if (weakListener)
     1:     m_listeners.RemoveObject(weakListener);
     1: 
     1:   return NS_OK;
     1:   
     1: }
     1: 
     1: NS_IMETHODIMP nsURILoader::OpenURI(nsIChannel *channel, 
 79445:                                    bool aIsContentPreferred,
     1:                                    nsIInterfaceRequestor *aWindowContext)
     1: {
     1:   NS_ENSURE_ARG_POINTER(channel);
     1: 
     1: #ifdef PR_LOGGING
     1:   if (LOG_ENABLED()) {
     1:     nsCOMPtr<nsIURI> uri;
     1:     channel->GetURI(getter_AddRefs(uri));
110974:     nsAutoCString spec;
     1:     uri->GetAsciiSpec(spec);
     1:     LOG(("nsURILoader::OpenURI for %s", spec.get()));
     1:   }
     1: #endif
     1: 
     1:   nsCOMPtr<nsIStreamListener> loader;
     1:   nsresult rv = OpenChannel(channel,
     1:                             aIsContentPreferred ? IS_CONTENT_PREFERRED : 0,
     1:                             aWindowContext,
 80486:                             false,
     1:                             getter_AddRefs(loader));
     1: 
     1:   if (NS_SUCCEEDED(rv)) {
     1:     // this method is not complete!!! Eventually, we should first go
     1:     // to the content listener and ask them for a protocol handler...
     1:     // if they don't give us one, we need to go to the registry and get
     1:     // the preferred protocol handler. 
     1: 
     1:     // But for now, I'm going to let necko do the work for us....
106838:     rv = channel->AsyncOpen(loader, nullptr);
     1: 
     1:     // no content from this load - that's OK.
     1:     if (rv == NS_ERROR_NO_CONTENT) {
     1:       LOG(("  rv is NS_ERROR_NO_CONTENT -- doing nothing"));
     1:       rv = NS_OK;
     1:     }
     1:   } else if (rv == NS_ERROR_WONT_HANDLE_CONTENT) {
     1:     // Not really an error, from this method's point of view
     1:     rv = NS_OK;
     1:   }
     1:   return rv;
     1: }
     1: 
     1: nsresult nsURILoader::OpenChannel(nsIChannel* channel,
108991:                                   uint32_t aFlags,
     1:                                   nsIInterfaceRequestor* aWindowContext,
 79445:                                   bool aChannelIsOpen,
     1:                                   nsIStreamListener** aListener)
     1: {
     1:   NS_ASSERTION(channel, "Trying to open a null channel!");
     1:   NS_ASSERTION(aWindowContext, "Window context must not be null");
     1: 
     1: #ifdef PR_LOGGING
     1:   if (LOG_ENABLED()) {
     1:     nsCOMPtr<nsIURI> uri;
     1:     channel->GetURI(getter_AddRefs(uri));
110974:     nsAutoCString spec;
     1:     uri->GetAsciiSpec(spec);
     1:     LOG(("nsURILoader::OpenChannel for %s", spec.get()));
     1:   }
     1: #endif
     1: 
     1:   // Let the window context's uriListener know that the open is starting.  This
     1:   // gives that window a chance to abort the load process.
     1:   nsCOMPtr<nsIURIContentListener> winContextListener(do_GetInterface(aWindowContext));
     1:   if (winContextListener) {
     1:     nsCOMPtr<nsIURI> uri;
     1:     channel->GetURI(getter_AddRefs(uri));
     1:     if (uri) {
 79445:       bool doAbort = false;
     1:       winContextListener->OnStartURIOpen(uri, &doAbort);
     1: 
     1:       if (doAbort) {
     1:         LOG(("  OnStartURIOpen aborted load"));
     1:         return NS_ERROR_WONT_HANDLE_CONTENT;
     1:       }
     1:     }
     1:   }
     1: 
     1:   // we need to create a DocumentOpenInfo object which will go ahead and open
     1:   // the url and discover the content type....
     1:   nsCOMPtr<nsDocumentOpenInfo> loader =
     1:     new nsDocumentOpenInfo(aWindowContext, aFlags, this);
     1: 
     1:   if (!loader) return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   // Set the correct loadgroup on the channel
     1:   nsCOMPtr<nsILoadGroup> loadGroup(do_GetInterface(aWindowContext));
     1: 
     1:   if (!loadGroup) {
     1:     // XXXbz This context is violating what we'd like to be the new uriloader
     1:     // api.... Set up a nsDocLoader to handle the loadgroup for this context.
     1:     // This really needs to go away!
     1:     nsCOMPtr<nsIURIContentListener> listener(do_GetInterface(aWindowContext));
     1:     if (listener) {
     1:       nsCOMPtr<nsISupports> cookie;
     1:       listener->GetLoadCookie(getter_AddRefs(cookie));
     1:       if (!cookie) {
     1:         nsRefPtr<nsDocLoader> newDocLoader = new nsDocLoader();
     1:         if (!newDocLoader)
     1:           return NS_ERROR_OUT_OF_MEMORY;
     1:         nsresult rv = newDocLoader->Init();
     1:         if (NS_FAILED(rv))
     1:           return rv;
     1:         rv = nsDocLoader::AddDocLoaderAsChildOfRoot(newDocLoader);
     1:         if (NS_FAILED(rv))
     1:           return rv;
  5204:         cookie = nsDocLoader::GetAsSupports(newDocLoader);
  5204:         listener->SetLoadCookie(cookie);
     1:       }
  5204:       loadGroup = do_GetInterface(cookie);
     1:     }
     1:   }
     1: 
     1:   // If the channel is pending, then we need to remove it from its current
     1:   // loadgroup
     1:   nsCOMPtr<nsILoadGroup> oldGroup;
     1:   channel->GetLoadGroup(getter_AddRefs(oldGroup));
  3640:   if (aChannelIsOpen && !SameCOMIdentity(oldGroup, loadGroup)) {
  3640:     // It is important to add the channel to the new group before
  3640:     // removing it from the old one, so that the load isn't considered
  3640:     // done as soon as the request is removed.
106838:     loadGroup->AddRequest(channel, nullptr);
  3640: 
     1:    if (oldGroup) {
106838:       oldGroup->RemoveRequest(channel, nullptr, NS_BINDING_RETARGETED);
     1:     }
     1:   }
     1: 
     1:   channel->SetLoadGroup(loadGroup);
     1: 
     1:   // prepare the loader for receiving data
     1:   nsresult rv = loader->Prepare();
     1:   if (NS_SUCCEEDED(rv))
     1:     NS_ADDREF(*aListener = loader);
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP nsURILoader::OpenChannel(nsIChannel* channel,
108991:                                        uint32_t aFlags,
     1:                                        nsIInterfaceRequestor* aWindowContext,
     1:                                        nsIStreamListener** aListener)
     1: {
 79445:   bool pending;
     1:   if (NS_FAILED(channel->IsPending(&pending))) {
 80486:     pending = false;
     1:   }
     1: 
     1:   return OpenChannel(channel, aFlags, aWindowContext, pending, aListener);
     1: }
     1: 
     1: NS_IMETHODIMP nsURILoader::Stop(nsISupports* aLoadCookie)
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsIDocumentLoader> docLoader;
     1: 
     1:   NS_ENSURE_ARG_POINTER(aLoadCookie);
     1: 
     1:   docLoader = do_GetInterface(aLoadCookie, &rv);
     1:   if (docLoader) {
     1:     rv = docLoader->Stop();
     1:   }
     1:   return rv;
     1: }
     1: 
