43264: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43264:  * vim: set ts=4 sw=4 et tw=99:
43264:  *
43264:  * ***** BEGIN LICENSE BLOCK *****
43264:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43264:  *
43264:  * The contents of this file are subject to the Mozilla Public License Version
43264:  * 1.1 (the "License"); you may not use this file except in compliance with
43264:  * the License. You may obtain a copy of the License at
43264:  * http://www.mozilla.org/MPL/
43264:  *
43264:  * Software distributed under the License is distributed on an "AS IS" basis,
43264:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43264:  * for the specific language governing rights and limitations under the
43264:  * License.
43264:  *
43264:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
43264:  * May 28, 2008.
43264:  *
43264:  * The Initial Developer of the Original Code is
43264:  *   Mozilla Foundation
43264:  * Portions created by the Initial Developer are Copyright (C) 2010
43264:  * the Initial Developer. All Rights Reserved.
43264:  *
43264:  * Contributor(s):
43264:  *   Andreas Gal <gal@mozilla.com>
43264:  *
43264:  * Alternatively, the contents of this file may be used under the terms of
43264:  * either of the GNU General Public License Version 2 or later (the "GPL"),
43264:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43264:  * in which case the provisions of the GPL or the LGPL are applicable instead
43264:  * of those above. If you wish to allow use of your version of this file only
43264:  * under the terms of either the GPL or the LGPL, and not to allow others to
43264:  * use your version of this file under the terms of the MPL, indicate your
43264:  * decision by deleting the provisions above and replace them with the notice
43264:  * and other provisions required by the GPL or the LGPL. If you do not delete
43264:  * the provisions above, a recipient may use your version of this file under
43264:  * the terms of any one of the MPL, the GPL or the LGPL.
43264:  *
43264:  * ***** END LICENSE BLOCK ***** */
43264: 
43264: #include "jsapi.h"
43264: #include "jscntxt.h"
76224: #include "jsexn.h"
68933: #include "jsgc.h"
68933: #include "jsgcmark.h"
43264: #include "jsiter.h"
43264: #include "jsnum.h"
43264: #include "jswrapper.h"
53391: #include "methodjit/PolyIC.h"
53405: #include "methodjit/MonoIC.h"
53391: #ifdef JS_METHODJIT
53391: # include "assembler/jit/ExecutableAllocator.h"
53391: #endif
54707: #include "jscompartment.h"
43264: 
89376: #include "jsobjinlines.h"
79981: 
89376: #include "vm/RegExpObject-inl.h"
43264: 
43264: using namespace js;
54707: using namespace js::gc;
43264: 
90605: namespace js {
90605: int sWrapperFamily;
90605: }
55599: 
55599: void *
79386: Wrapper::getWrapperFamily()
55599: {
55599:     return &sWrapperFamily;
55599: }
47516: 
79734: JS_FRIEND_API(JSObject *)
91237: js::UnwrapObject(JSObject *wrapped, bool stopAtOuter, unsigned *flagsp)
75451: {
91237:     unsigned flags = 0;
96339:     while (wrapped->isWrapper() &&
96339:            !JS_UNLIKELY(stopAtOuter && wrapped->getClass()->ext.innerObject)) {
79734:         flags |= static_cast<Wrapper *>(GetProxyHandler(wrapped))->flags();
79734:         wrapped = GetProxyPrivate(wrapped).toObjectOrNull();
47574:     }
47574:     if (flagsp)
47574:         *flagsp = flags;
47516:     return wrapped;
47516: }
47516: 
93956: JS_FRIEND_API(JSObject *)
93956: js::UnwrapObjectChecked(JSContext *cx, JSObject *obj)
93956: {
96339:     while (obj->isWrapper() &&
96339:            !JS_UNLIKELY(!!obj->getClass()->ext.innerObject)) {
93956:         JSObject *wrapper = obj;
95795:         AbstractWrapper *handler = AbstractWrapper::wrapperHandler(obj);
93956:         bool rvOnFailure;
93956:         if (!handler->enter(cx, wrapper, JSID_VOID,
93956:                             Wrapper::PUNCTURE, &rvOnFailure))
93956:             return rvOnFailure ? obj : NULL;
93956:         obj = Wrapper::wrappedObject(obj);
93956:         JS_ASSERT(obj);
93956:         handler->leave(cx, wrapper);
93956:     }
93956:     return obj;
93956: }
93956: 
79734: bool
79734: js::IsCrossCompartmentWrapper(const JSObject *wrapper)
79734: {
79734:     return wrapper->isWrapper() &&
79734:            !!(Wrapper::wrapperHandler(wrapper)->flags() & Wrapper::CROSS_COMPARTMENT);
79734: }
79734: 
95795: AbstractWrapper::AbstractWrapper(unsigned flags) :
95795:     ProxyHandler(&sWrapperFamily),
95795:     mFlags(flags)
95468: {
95468: }
95468: 
95795: Wrapper::Wrapper(unsigned flags) : AbstractWrapper(flags)
43264: {
43264: }
43264: 
79386: Wrapper::~Wrapper()
43264: {
43264: }
43264: 
55587: #define CHECKED(op, act)                                                     \
47574:     JS_BEGIN_MACRO                                                           \
61693:         bool status;                                                         \
61693:         if (!enter(cx, wrapper, id, act, &status))                           \
61693:             return status;                                                   \
47574:         bool ok = (op);                                                      \
47574:         leave(cx, wrapper);                                                  \
47574:         return ok;                                                           \
47574:     JS_END_MACRO
47574: 
55587: #define SET(action) CHECKED(action, SET)
55587: #define GET(action) CHECKED(action, GET)
47574: 
47565: bool
95468: AbstractWrapper::getPropertyDescriptor(JSContext *cx, JSObject *wrapper, jsid id, bool set,
79386:                                        PropertyDescriptor *desc)
47565: {
61693:     desc->obj = NULL; // default result if we refuse to perform this action
78614:     CHECKED(JS_GetPropertyDescriptorById(cx, wrappedObject(wrapper), id, JSRESOLVE_QUALIFIED, desc),
78614:             set ? SET : GET);
47565: }
47562: 
47574: static bool
91237: GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, unsigned flags, JSPropertyDescriptor *desc)
43264: {
73074:     // If obj is a proxy, we can do better than just guessing. This is
73074:     // important for certain types of wrappers that wrap other wrappers.
78614:     if (obj->isProxy())
79386:         return Proxy::getOwnPropertyDescriptor(cx, obj, id, flags & JSRESOLVE_ASSIGNING, desc);
73074: 
47574:     if (!JS_GetPropertyDescriptorById(cx, obj, id, flags, desc))
43264:         return false;
47574:     if (desc->obj != obj)
47574:         desc->obj = NULL;
43264:     return true;
43264: }
43264: 
43264: bool
95468: AbstractWrapper::getOwnPropertyDescriptor(JSContext *cx, JSObject *wrapper, jsid id, bool set,
48470:                                           PropertyDescriptor *desc)
43264: {
61693:     desc->obj = NULL; // default result if we refuse to perform this action
78614:     CHECKED(GetOwnPropertyDescriptor(cx, wrappedObject(wrapper), id, JSRESOLVE_QUALIFIED, desc),
78614:             set ? SET : GET);
43264: }
43264: 
43264: bool
95468: AbstractWrapper::defineProperty(JSContext *cx, JSObject *wrapper, jsid id, PropertyDescriptor *desc)
47574: {
78614:     SET(JS_DefinePropertyById(cx, wrappedObject(wrapper), id, desc->value,
78614:                               desc->getter, desc->setter, desc->attrs));
47574: }
47574: 
47574: bool
95468: AbstractWrapper::getOwnPropertyNames(JSContext *cx, JSObject *wrapper, AutoIdVector &props)
47574: {
61693:     // if we refuse to perform this action, props remains empty
48470:     jsid id = JSID_VOID;
54562:     GET(GetPropertyNames(cx, wrappedObject(wrapper), JSITER_OWNONLY | JSITER_HIDDEN, &props));
47574: }
47574: 
47574: static bool
48470: ValueToBoolean(Value *vp, bool *bp)
47574: {
47574:     *bp = js_ValueToBoolean(*vp);
47574:     return true;
47574: }
47574: 
47574: bool
95468: AbstractWrapper::delete_(JSContext *cx, JSObject *wrapper, jsid id, bool *bp)
47574: {
61693:     *bp = true; // default result if we refuse to perform this action
48470:     Value v;
78614:     SET(JS_DeletePropertyById2(cx, wrappedObject(wrapper), id, &v) &&
47574:         ValueToBoolean(&v, bp));
47574: }
47574: 
47574: bool
95468: AbstractWrapper::enumerate(JSContext *cx, JSObject *wrapper, AutoIdVector &props)
47574: {
61693:     // if we refuse to perform this action, props remains empty
48470:     static jsid id = JSID_VOID;
54562:     GET(GetPropertyNames(cx, wrappedObject(wrapper), 0, &props));
47574: }
47574: 
47574: bool
95468: AbstractWrapper::fix(JSContext *cx, JSObject *wrapper, Value *vp)
43264: {
48470:     vp->setUndefined();
43264:     return true;
43264: }
43264: 
47574: static bool
47574: Cond(JSBool b, bool *bp)
43264: {
47574:     *bp = !!b;
43264:     return true;
43264: }
43264: 
43264: bool
79386: Wrapper::has(JSContext *cx, JSObject *wrapper, jsid id, bool *bp)
47574: {
61693:     *bp = false; // default result if we refuse to perform this action
47574:     JSBool found;
47574:     GET(JS_HasPropertyById(cx, wrappedObject(wrapper), id, &found) &&
47574:         Cond(found, bp));
47574: }
47574: 
47574: bool
79386: Wrapper::hasOwn(JSContext *cx, JSObject *wrapper, jsid id, bool *bp)
47562: {
61693:     *bp = false; // default result if we refuse to perform this action
48470:     PropertyDescriptor desc;
47574:     JSObject *wobj = wrappedObject(wrapper);
78614:     GET(JS_GetPropertyDescriptorById(cx, wobj, id, JSRESOLVE_QUALIFIED, &desc) &&
47574:         Cond(desc.obj == wobj, bp));
47574: }
47574: 
47574: bool
79386: Wrapper::get(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id, Value *vp)
47574: {
61693:     vp->setUndefined(); // default result if we refuse to perform this action
78675:     GET(wrappedObject(wrapper)->getGeneric(cx, receiver, id, vp));
47574: }
47574: 
47574: bool
79386: Wrapper::set(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id, bool strict,
62395:                Value *vp)
47574: {
93362:     SET(wrappedObject(wrapper)->setGeneric(cx, id, vp, strict));
47574: }
47574: 
47574: bool
79386: Wrapper::keys(JSContext *cx, JSObject *wrapper, AutoIdVector &props)
47574: {
61693:     // if we refuse to perform this action, props remains empty
48470:     const jsid id = JSID_VOID;
54562:     GET(GetPropertyNames(cx, wrappedObject(wrapper), JSITER_OWNONLY, &props));
47574: }
47574: 
47574: bool
91237: Wrapper::iterate(JSContext *cx, JSObject *wrapper, unsigned flags, Value *vp)
47574: {
61693:     vp->setUndefined(); // default result if we refuse to perform this action
48470:     const jsid id = JSID_VOID;
95355:     GET(GetIterator(cx, RootedVarObject(cx, wrappedObject(wrapper)), flags, vp));
47574: }
47574: 
47574: bool
91237: Wrapper::call(JSContext *cx, JSObject *wrapper, unsigned argc, Value *vp)
47574: {
61693:     vp->setUndefined(); // default result if we refuse to perform this action
48470:     const jsid id = JSID_VOID;
79386:     CHECKED(ProxyHandler::call(cx, wrapper, argc, vp), CALL);
47574: }
47574: 
47574: bool
91237: Wrapper::construct(JSContext *cx, JSObject *wrapper, unsigned argc, Value *argv, Value *vp)
47574: {
61693:     vp->setUndefined(); // default result if we refuse to perform this action
48470:     const jsid id = JSID_VOID;
79386:     GET(ProxyHandler::construct(cx, wrapper, argc, argv, vp));
47574: }
47574: 
55650: bool
80203: Wrapper::nativeCall(JSContext *cx, JSObject *wrapper, Class *clasp, Native native, CallArgs args)
80203: {
80203:     const jsid id = JSID_VOID;
80203:     CHECKED(CallJSNative(cx, native, args), CALL);
80203: }
80203: 
80203: bool
79386: Wrapper::hasInstance(JSContext *cx, JSObject *wrapper, const Value *vp, bool *bp)
55650: {
70267:     *bp = false; // default result if we refuse to perform this action
55650:     const jsid id = JSID_VOID;
70267:     JSBool b = JS_FALSE;
78614:     GET(JS_HasInstance(cx, wrappedObject(wrapper), *vp, &b) && Cond(b, bp));
55650: }
55650: 
57775: JSType
79386: Wrapper::typeOf(JSContext *cx, JSObject *wrapper)
57775: {
57775:     return TypeOfValue(cx, ObjectValue(*wrappedObject(wrapper)));
57775: }
57775: 
79390: bool
79418: Wrapper::objectClassIs(JSObject *wrapper, ESClassValue classValue, JSContext *cx)
79390: {
79390:     return ObjectClassIs(*wrappedObject(wrapper), classValue, cx);
79390: }
79390: 
47574: JSString *
79386: Wrapper::obj_toString(JSContext *cx, JSObject *wrapper)
47574: {
61693:     bool status;
61693:     if (!enter(cx, wrapper, JSID_VOID, GET, &status)) {
61693:         if (status) {
61693:             // Perform some default behavior that doesn't leak any information.
61693:             return JS_NewStringCopyZ(cx, "[object Object]");
61693:         }
47574:         return NULL;
61693:     }
61693:     JSString *str = obj_toStringHelper(cx, wrappedObject(wrapper));
47574:     leave(cx, wrapper);
47574:     return str;
47574: }
47574: 
47574: JSString *
91237: Wrapper::fun_toString(JSContext *cx, JSObject *wrapper, unsigned indent)
47574: {
61693:     bool status;
61693:     if (!enter(cx, wrapper, JSID_VOID, GET, &status)) {
61693:         if (status) {
61693:             // Perform some default behavior that doesn't leak any information.
61693:             if (wrapper->isCallable())
61693:                 return JS_NewStringCopyZ(cx, "function () {\n    [native code]\n}");
61693:             js::Value v = ObjectValue(*wrapper);
61693:             js_ReportIsNotFunction(cx, &v, 0);
47574:             return NULL;
61693:         }
61693:         return NULL;
61693:     }
79386:     JSString *str = ProxyHandler::fun_toString(cx, wrapper, indent);
47574:     leave(cx, wrapper);
47574:     return str;
47574: }
47574: 
90851: bool
90851: Wrapper::regexp_toShared(JSContext *cx, JSObject *wrapper, RegExpGuard *g)
89376: {
96394:     return RegExpToShared(cx, *wrappedObject(wrapper), g);
89376: }
89376: 
72054: bool
79386: Wrapper::defaultValue(JSContext *cx, JSObject *wrapper, JSType hint, Value *vp)
72054: {
72054:     *vp = ObjectValue(*wrappedObject(wrapper));
72054:     if (hint == JSTYPE_VOID)
72054:         return ToPrimitive(cx, vp);
72054:     return ToPrimitive(cx, hint, vp);
72054: }
72054: 
89623: bool
89623: Wrapper::iteratorNext(JSContext *cx, JSObject *wrapper, Value *vp)
89623: {
95355:     if (!js_IteratorMore(cx, RootedVarObject(cx, wrappedObject(wrapper)), vp))
89623:         return false;
89623: 
89623:     if (vp->toBoolean()) {
89623:         *vp = cx->iterValue;
89623:         cx->iterValue.setUndefined();
89623:     } else {
89623:         vp->setMagic(JS_NO_ITER_VALUE);
89623:     }
89623:     return true;
89623: }
89623: 
47574: void
79386: Wrapper::trace(JSTracer *trc, JSObject *wrapper)
47574: {
91146:     MarkSlot(trc, &wrapper->getReservedSlotRef(JSSLOT_PROXY_PRIVATE), "wrappedObject");
47574: }
47574: 
77343: JSObject *
95468: AbstractWrapper::wrappedObject(const JSObject *wrapper)
77343: {
79734:     return GetProxyPrivate(wrapper).toObjectOrNull();
77343: }
77343: 
95795: AbstractWrapper *
95468: AbstractWrapper::wrapperHandler(const JSObject *wrapper)
77343: {
95795:     JS_ASSERT(wrapper->isWrapper());
95795:     return static_cast<AbstractWrapper *>(GetProxyHandler(wrapper));
77343: }
77343: 
47574: bool
95468: AbstractWrapper::enter(JSContext *cx, JSObject *wrapper, jsid id, Action act, bool *bp)
47574: {
61693:     *bp = true;
47565:     return true;
47562: }
47562: 
47574: void
95468: AbstractWrapper::leave(JSContext *cx, JSObject *wrapper)
43264: {
47562: }
47562: 
91237: Wrapper Wrapper::singleton((unsigned)0);
47498: 
47498: JSObject *
79386: Wrapper::New(JSContext *cx, JSObject *obj, JSObject *proto, JSObject *parent, Wrapper *handler)
47498: {
56819:     JS_ASSERT(parent);
57775:     if (obj->isXML()) {
57775:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_WRAP_XML_OBJECT);
57775:         return NULL;
57775:     }
48470:     return NewProxyObject(cx, handler, ObjectValue(*obj), proto, parent,
47498:                           obj->isCallable() ? obj : NULL, NULL);
47498: }
47498: 
47516: /* Compartments. */
47498: 
47516: namespace js {
47498: 
47516: extern JSObject *
55580: TransparentObjectWrapper(JSContext *cx, JSObject *obj, JSObject *wrappedProto, JSObject *parent,
91237:                          unsigned flags)
47498: {
54404:     // Allow wrapping outer window proxies.
54404:     JS_ASSERT(!obj->isWrapper() || obj->getClass()->ext.innerObject);
79386:     return Wrapper::New(cx, obj, wrappedProto, parent, &CrossCompartmentWrapper::singleton);
47498: }
47498: 
47498: }
47498: 
70264: ForceFrame::ForceFrame(JSContext *cx, JSObject *target)
70264:     : context(cx),
71704:       target(target),
71704:       frame(NULL)
70264: {
70264: }
70264: 
70461: ForceFrame::~ForceFrame()
70461: {
71704:     context->delete_(frame);
70461: }
70461: 
70264: bool
70264: ForceFrame::enter()
70264: {
71704:     frame = context->new_<DummyFrameGuard>();
71704:     if (!frame)
71704:        return false;
70264: 
70264:     JS_ASSERT(context->compartment == target->compartment());
76885:     JSCompartment *destination = context->compartment;
70264: 
86483:     JSObject &scopeChain = target->global();
86483:     JS_ASSERT(scopeChain.isNative());
70264: 
86483:     return context->stack.pushDummyFrame(context, destination, scopeChain, frame);
70264: }
70264: 
47498: AutoCompartment::AutoCompartment(JSContext *cx, JSObject *target)
47498:     : context(cx),
47498:       origin(cx->compartment),
47498:       target(target),
79734:       destination(target->compartment()),
48530:       entered(false)
47498: {
47498: }
43264: 
47498: AutoCompartment::~AutoCompartment()
43264: {
48530:     if (entered)
47498:         leave();
47498: }
47498: 
47498: bool
47498: AutoCompartment::enter()
47498: {
48530:     JS_ASSERT(!entered);
48530:     if (origin != destination) {
86483:         JSObject &scopeChain = target->global();
86483:         JS_ASSERT(scopeChain.isNative());
60245: 
47498:         frame.construct();
86483:         if (!context->stack.pushDummyFrame(context, destination, scopeChain, &frame.ref()))
48530:             return false;
60798: 
60798:         if (context->isExceptionPending())
60798:             context->wrapPendingException();
48530:     }
48530:     entered = true;
48530:     return true;
47498: }
47498: 
47498: void
47498: AutoCompartment::leave()
47498: {
48530:     JS_ASSERT(entered);
48530:     if (origin != destination) {
47498:         frame.destroy();
55607:         context->resetCompartment();
47498:     }
48530:     entered = false;
48530: }
47498: 
76224: ErrorCopier::~ErrorCopier()
76224: {
76224:     JSContext *cx = ac.context;
76224:     if (cx->compartment == ac.destination &&
76224:         ac.origin != ac.destination &&
76224:         cx->isExceptionPending())
76224:     {
76224:         Value exc = cx->getPendingException();
76810:         if (exc.isObject() && exc.toObject().isError() && exc.toObject().getPrivate()) {
76224:             cx->clearPendingException();
76224:             ac.leave();
76224:             JSObject *copyobj = js_CopyErrorObject(cx, &exc.toObject(), scope);
76224:             if (copyobj)
76224:                 cx->setPendingException(ObjectValue(*copyobj));
76224:         }
76224:     }
76224: }
76224: 
47498: /* Cross compartment wrappers. */
47498: 
91237: CrossCompartmentWrapper::CrossCompartmentWrapper(unsigned flags)
79386:   : Wrapper(CROSS_COMPARTMENT | flags)
47498: {
47498: }
47498: 
79386: CrossCompartmentWrapper::~CrossCompartmentWrapper()
47498: {
47498: }
47498: 
47574: #define PIERCE(cx, wrapper, mode, pre, op, post)            \
47516:     JS_BEGIN_MACRO                                          \
47574:         AutoCompartment call(cx, wrappedObject(wrapper));   \
47574:         if (!call.enter())                                  \
47516:             return false;                                   \
47574:         bool ok = (pre) && (op);                            \
47516:         call.leave();                                       \
47574:         return ok && (post);                                \
47516:     JS_END_MACRO
47516: 
47516: #define NOTHING (true)
47516: 
47498: bool
79386: CrossCompartmentWrapper::getPropertyDescriptor(JSContext *cx, JSObject *wrapper, jsid id,
55592:                                                bool set, PropertyDescriptor *desc)
47498: {
55592:     PIERCE(cx, wrapper, set ? SET : GET,
47498:            call.destination->wrapId(cx, &id),
79386:            Wrapper::getPropertyDescriptor(cx, wrapper, id, set, desc),
47498:            call.origin->wrap(cx, desc));
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::getOwnPropertyDescriptor(JSContext *cx, JSObject *wrapper, jsid id,
55592:                                                   bool set, PropertyDescriptor *desc)
47498: {
55592:     PIERCE(cx, wrapper, set ? SET : GET,
47498:            call.destination->wrapId(cx, &id),
79386:            Wrapper::getOwnPropertyDescriptor(cx, wrapper, id, set, desc),
47498:            call.origin->wrap(cx, desc));
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::defineProperty(JSContext *cx, JSObject *wrapper, jsid id, PropertyDescriptor *desc)
47498: {
48470:     AutoPropertyDescriptorRooter desc2(cx, desc);
47574:     PIERCE(cx, wrapper, SET,
47498:            call.destination->wrapId(cx, &id) && call.destination->wrap(cx, &desc2),
79386:            Wrapper::defineProperty(cx, wrapper, id, &desc2),
47498:            NOTHING);
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::getOwnPropertyNames(JSContext *cx, JSObject *wrapper, AutoIdVector &props)
47498: {
47574:     PIERCE(cx, wrapper, GET,
47498:            NOTHING,
79386:            Wrapper::getOwnPropertyNames(cx, wrapper, props),
47525:            call.origin->wrap(cx, props));
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::delete_(JSContext *cx, JSObject *wrapper, jsid id, bool *bp)
47498: {
47574:     PIERCE(cx, wrapper, SET,
47498:            call.destination->wrapId(cx, &id),
79386:            Wrapper::delete_(cx, wrapper, id, bp),
47498:            NOTHING);
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::enumerate(JSContext *cx, JSObject *wrapper, AutoIdVector &props)
47498: {
47574:     PIERCE(cx, wrapper, GET,
47498:            NOTHING,
79386:            Wrapper::enumerate(cx, wrapper, props),
47525:            call.origin->wrap(cx, props));
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::has(JSContext *cx, JSObject *wrapper, jsid id, bool *bp)
47498: {
47574:     PIERCE(cx, wrapper, GET,
47498:            call.destination->wrapId(cx, &id),
79386:            Wrapper::has(cx, wrapper, id, bp),
47498:            NOTHING);
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::hasOwn(JSContext *cx, JSObject *wrapper, jsid id, bool *bp)
47498: {
47574:     PIERCE(cx, wrapper, GET,
47498:            call.destination->wrapId(cx, &id),
79386:            Wrapper::hasOwn(cx, wrapper, id, bp),
47498:            NOTHING);
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::get(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id, Value *vp)
47498: {
47574:     PIERCE(cx, wrapper, GET,
47498:            call.destination->wrap(cx, &receiver) && call.destination->wrapId(cx, &id),
79386:            Wrapper::get(cx, wrapper, receiver, id, vp),
47498:            call.origin->wrap(cx, vp));
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::set(JSContext *cx, JSObject *wrapper, JSObject *receiver, jsid id,
62395:                              bool strict, Value *vp)
47498: {
47498:     AutoValueRooter tvr(cx, *vp);
47574:     PIERCE(cx, wrapper, SET,
62395:            call.destination->wrap(cx, &receiver) &&
62395:            call.destination->wrapId(cx, &id) &&
62395:            call.destination->wrap(cx, tvr.addr()),
79386:            Wrapper::set(cx, wrapper, receiver, id, strict, tvr.addr()),
47498:            NOTHING);
47498: }
47498: 
47498: bool
79386: CrossCompartmentWrapper::keys(JSContext *cx, JSObject *wrapper, AutoIdVector &props)
47498: {
47574:     PIERCE(cx, wrapper, GET,
47498:            NOTHING,
79386:            Wrapper::keys(cx, wrapper, props),
47525:            call.origin->wrap(cx, props));
47525: }
47525: 
47525: /*
47525:  * We can reify non-escaping iterator objects instead of having to wrap them. This
47525:  * allows fast iteration over objects across a compartment boundary.
47525:  */
47525: static bool
48470: CanReify(Value *vp)
47525: {
48470:     JSObject *obj;
48470:     return vp->isObject() &&
77817:            (obj = &vp->toObject())->getClass() == &IteratorClass &&
48470:            (obj->getNativeIterator()->flags & JSITER_ENUMERATE);
47525: }
47525: 
59240: struct AutoCloseIterator
59240: {
59240:     AutoCloseIterator(JSContext *cx, JSObject *obj) : cx(cx), obj(obj) {}
59240: 
91160:     ~AutoCloseIterator() { if (obj) CloseIterator(cx, obj); }
59240: 
59240:     void clear() { obj = NULL; }
59240: 
59240:   private:
59240:     JSContext *cx;
59240:     JSObject *obj;
59240: };
59240: 
47525: static bool
48470: Reify(JSContext *cx, JSCompartment *origin, Value *vp)
47525: {
48470:     JSObject *iterObj = &vp->toObject();
47525:     NativeIterator *ni = iterObj->getNativeIterator();
48470: 
59240:     AutoCloseIterator close(cx, iterObj);
59240: 
48470:     /* Wrap the iteratee. */
95355:     RootedVarObject obj(cx, ni->obj);
95355:     if (!origin->wrap(cx, obj.address()))
48470:         return false;
48470: 
48470:     /*
48470:      * Wrap the elements in the iterator's snapshot.
48470:      * N.B. the order of closing/creating iterators is important due to the
48470:      * implicit cx->enumerators state.
48470:      */
48470:     size_t length = ni->numKeys();
61055:     bool isKeyIter = ni->isKeyIter();
48470:     AutoIdVector keys(cx);
47525:     if (length > 0) {
94078:         if (!keys.reserve(length))
48470:             return false;
48470:         for (size_t i = 0; i < length; ++i) {
87655:             jsid id;
87655:             if (!ValueToId(cx, StringValue(ni->begin()[i]), &id))
87655:                 return false;
87655:             id = js_CheckForStringIndex(id);
94078:             keys.infallibleAppend(id);
48470:             if (!origin->wrapId(cx, &keys[i]))
48470:                 return false;
48470:         }
47525:     }
47525: 
59240:     close.clear();
91160:     if (!CloseIterator(cx, iterObj))
61055:         return false;
60785: 
61055:     if (isKeyIter)
61055:         return VectorToKeyIterator(cx, obj, ni->flags, keys, vp);
61055:     return VectorToValueIterator(cx, obj, ni->flags, keys, vp); 
47498: }
47498: 
47498: bool
91237: CrossCompartmentWrapper::iterate(JSContext *cx, JSObject *wrapper, unsigned flags, Value *vp)
47498: {
47574:     PIERCE(cx, wrapper, GET,
47498:            NOTHING,
79386:            Wrapper::iterate(cx, wrapper, flags, vp),
47525:            CanReify(vp) ? Reify(cx, call.origin, vp) : call.origin->wrap(cx, vp));
47498: }
47498: 
47498: bool
91237: CrossCompartmentWrapper::call(JSContext *cx, JSObject *wrapper, unsigned argc, Value *vp)
47498: {
47574:     AutoCompartment call(cx, wrappedObject(wrapper));
47498:     if (!call.enter())
47498:         return false;
47498: 
48470:     vp[0] = ObjectValue(*call.target);
47498:     if (!call.destination->wrap(cx, &vp[1]))
47498:         return false;
48470:     Value *argv = JS_ARGV(cx, vp);
47498:     for (size_t n = 0; n < argc; ++n) {
47498:         if (!call.destination->wrap(cx, &argv[n]))
47498:             return false;
47498:     }
79386:     if (!Wrapper::call(cx, wrapper, argc, vp))
47498:         return false;
47498: 
47498:     call.leave();
47498:     return call.origin->wrap(cx, vp);
47498: }
47498: 
47498: bool
91237: CrossCompartmentWrapper::construct(JSContext *cx, JSObject *wrapper, unsigned argc, Value *argv,
48470:                                    Value *rval)
47498: {
47574:     AutoCompartment call(cx, wrappedObject(wrapper));
47498:     if (!call.enter())
47498:         return false;
47498: 
47498:     for (size_t n = 0; n < argc; ++n) {
47498:         if (!call.destination->wrap(cx, &argv[n]))
47498:             return false;
47498:     }
79386:     if (!Wrapper::construct(cx, wrapper, argc, argv, rval))
47498:         return false;
47498: 
47498:     call.leave();
60245:     return call.origin->wrap(cx, rval);
47498: }
47498: 
80157: extern JSBool
91237: js_generic_native_method_dispatcher(JSContext *cx, unsigned argc, Value *vp);
80157: 
55650: bool
79388: CrossCompartmentWrapper::nativeCall(JSContext *cx, JSObject *wrapper, Class *clasp, Native native, CallArgs srcArgs)
79388: {
79390:     JS_ASSERT_IF(!srcArgs.calleev().isUndefined(),
83252:                  srcArgs.callee().toFunction()->native() == native ||
83252:                  srcArgs.callee().toFunction()->native() == js_generic_native_method_dispatcher);
79388:     JS_ASSERT(&srcArgs.thisv().toObject() == wrapper);
79779:     JS_ASSERT(!UnwrapObject(wrapper)->isCrossCompartmentWrapper());
79388: 
79388:     JSObject *wrapped = wrappedObject(wrapper);
79388:     AutoCompartment call(cx, wrapped);
79388:     if (!call.enter())
79388:         return false;
79388: 
79388:     InvokeArgsGuard dstArgs;
79388:     if (!cx->stack.pushInvokeArgs(cx, srcArgs.length(), &dstArgs))
79388:         return false;
79388: 
79388:     Value *src = srcArgs.base(); 
79388:     Value *srcend = srcArgs.array() + srcArgs.length();
79388:     Value *dst = dstArgs.base();
79388:     for (; src != srcend; ++src, ++dst) {
79388:         *dst = *src;
79388:         if (!call.destination->wrap(cx, dst))
79388:             return false;
79388:     }
79388: 
79388:     if (!Wrapper::nativeCall(cx, wrapper, clasp, native, dstArgs))
79388:         return false;
79388: 
90857:     srcArgs.rval() = dstArgs.rval();
79388:     dstArgs.pop();
79388:     call.leave();
79388:     return call.origin->wrap(cx, &srcArgs.rval());
79388: }
79388: 
79388: bool
79386: CrossCompartmentWrapper::hasInstance(JSContext *cx, JSObject *wrapper, const Value *vp, bool *bp)
55650: {
55650:     AutoCompartment call(cx, wrappedObject(wrapper));
55650:     if (!call.enter())
55650:         return false;
55650: 
55650:     Value v = *vp;
55650:     if (!call.destination->wrap(cx, &v))
55650:         return false;
79386:     return Wrapper::hasInstance(cx, wrapper, &v, bp);
55650: }
55650: 
47498: JSString *
79386: CrossCompartmentWrapper::obj_toString(JSContext *cx, JSObject *wrapper)
47498: {
47574:     AutoCompartment call(cx, wrappedObject(wrapper));
47498:     if (!call.enter())
43264:         return NULL;
47498: 
79386:     JSString *str = Wrapper::obj_toString(cx, wrapper);
47498:     if (!str)
43264:         return NULL;
47498: 
47498:     call.leave();
47498:     if (!call.origin->wrap(cx, &str))
47498:         return NULL;
47498:     return str;
43264: }
47498: 
47498: JSString *
91237: CrossCompartmentWrapper::fun_toString(JSContext *cx, JSObject *wrapper, unsigned indent)
47498: {
47574:     AutoCompartment call(cx, wrappedObject(wrapper));
47498:     if (!call.enter())
43264:         return NULL;
47498: 
79386:     JSString *str = Wrapper::fun_toString(cx, wrapper, indent);
47498:     if (!str)
47498:         return NULL;
47498: 
47498:     call.leave();
47498:     if (!call.origin->wrap(cx, &str))
47498:         return NULL;
47498:     return str;
43264: }
47498: 
72054: bool
79386: CrossCompartmentWrapper::defaultValue(JSContext *cx, JSObject *wrapper, JSType hint, Value *vp)
72054: {
72054:     AutoCompartment call(cx, wrappedObject(wrapper));
72054:     if (!call.enter())
72054:         return false;
72054: 
79386:     if (!Wrapper::defaultValue(cx, wrapper, hint, vp))
72054:         return false;
72054: 
72054:     call.leave();
72054:     return call.origin->wrap(cx, vp);
72054: }
72054: 
89623: bool
89623: CrossCompartmentWrapper::iteratorNext(JSContext *cx, JSObject *wrapper, Value *vp)
89623: {
89623:     PIERCE(cx, wrapper, GET,
89623:            NOTHING,
89623:            Wrapper::iteratorNext(cx, wrapper, vp),
89623:            call.origin->wrap(cx, vp));
89623: }
89623: 
73561: void
79386: CrossCompartmentWrapper::trace(JSTracer *trc, JSObject *wrapper)
73561: {
91146:     MarkCrossCompartmentSlot(trc, &wrapper->getReservedSlotRef(JSSLOT_PROXY_PRIVATE),
82129:                              "wrappedObject");
73561: }
73561: 
79386: CrossCompartmentWrapper CrossCompartmentWrapper::singleton(0u);
80203: 
80203: /* Security wrappers. */
80203: 
80203: template <class Base>
91237: SecurityWrapper<Base>::SecurityWrapper(unsigned flags)
80203:   : Base(flags)
80203: {}
80203: 
80203: template <class Base>
80203: bool
80203: SecurityWrapper<Base>::nativeCall(JSContext *cx, JSObject *wrapper, Class *clasp, Native native,
80203:                                   CallArgs args)
80203: {
87115:     /*
87115:      * Let this through until compartment-per-global lets us have stronger
87115:      * invariants wrt document.domain (bug 714547).
87115:      */
87115:     return Base::nativeCall(cx, wrapper, clasp, native, args);
80203: }
80203: 
80203: template <class Base>
80203: bool
80203: SecurityWrapper<Base>::objectClassIs(JSObject *obj, ESClassValue classValue, JSContext *cx)
80203: {
87115:     /*
87115:      * Let this through until compartment-per-global lets us have stronger
87115:      * invariants wrt document.domain (bug 714547).
87115:      */
87115:     return Base::objectClassIs(obj, classValue, cx);
80203: }
80203: 
89376: template <class Base>
90851: bool
90851: SecurityWrapper<Base>::regexp_toShared(JSContext *cx, JSObject *obj, RegExpGuard *g)
89376: {
90851:     return Base::regexp_toShared(cx, obj, g);
89376: }
89376: 
89376: 
80884: template class js::SecurityWrapper<Wrapper>;
80884: template class js::SecurityWrapper<CrossCompartmentWrapper>;
