    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Brian Ryner    <bryner@brianryner.com>
16225:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * the container for the style sheets that apply to a presentation, and
    1:  * the internal API that the style system exposes for creating (and
    1:  * potentially re-creating) style contexts
    1:  */
    1: 
    1: #ifndef nsStyleSet_h_
    1: #define nsStyleSet_h_
    1: 
    1: #include "nsIStyleRuleProcessor.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsBindingManager.h"
    1: #include "nsRuleNode.h"
 3959: #include "nsTArray.h"
 3959: #include "nsCOMArray.h"
21924: #include "nsAutoPtr.h"
22737: #include "nsIStyleRule.h"
    1: 
    1: class nsIURI;
21924: class nsCSSFontFaceRule;
30988: class nsRuleWalker;
30988: struct RuleProcessorData;
    1: 
22737: class nsEmptyStyleRule : public nsIStyleRule
22737: {
22737:   NS_DECL_ISUPPORTS
22737:   NS_IMETHOD MapRuleInfoInto(nsRuleData* aRuleData);
22737: #ifdef DEBUG
22737:   NS_IMETHOD List(FILE* out = stdout, PRInt32 aIndent = 0) const;
22737: #endif
22737: };
22737: 
    1: // The style set object is created by the document viewer and ownership is
    1: // then handed off to the PresShell.  Only the PresShell should delete a
    1: // style set.
    1: 
    1: class nsStyleSet
    1: {
    1:  public:
    1:   nsStyleSet();
    1: 
    1:   // Initialize the object.  You must check the return code and not use
    1:   // the nsStyleSet if Init() fails.
    1: 
    1:   nsresult Init(nsPresContext *aPresContext);
    1: 
    1:   // For getting the cached default data in case we hit out-of-memory.
    1:   // To be used only by nsRuleNode.
    1:   nsCachedStyleData* DefaultStyleData() { return &mDefaultStyleData; }
    1: 
24429:   nsRuleNode* GetRuleTree() { return mRuleTree; }
24429: 
    1:   // enable / disable the Quirk style sheet
    1:   void EnableQuirkStyleSheet(PRBool aEnable);
    1: 
    1:   // get a style context for a non-pseudo frame.
    1:   already_AddRefed<nsStyleContext>
    1:   ResolveStyleFor(nsIContent* aContent, nsStyleContext* aParentContext);
    1: 
31309:   // Get a style context (with the given parent and pseudo-tag) for a
31309:   // sequence of style rules consisting of the concatenation of:
31309:   //  (1) the rule sequence represented by aRuleNode (which is the empty
31309:   //      sequence if aRuleNode is null or the root of the rule tree), and
31309:   //  (2) the rules in the |aRules| array.
 3964:   already_AddRefed<nsStyleContext>
31309:   ResolveStyleForRules(nsStyleContext* aParentContext,
31309:                        nsIAtom* aPseudoTag,
31309:                        nsRuleNode *aRuleNode,
31309:                        const nsCOMArray<nsIStyleRule> &aRules);
 3964: 
    1:   // Get a style context for a non-element (which no rules will match),
    1:   // such as text nodes, placeholder frames, and the nsFirstLetterFrame
    1:   // for everything after the first letter.
    1:   //
    1:   // Perhaps this should go away and we shouldn't even create style
    1:   // contexts for such content nodes.  However, not doing any rule
    1:   // matching for them is a first step.
    1:   already_AddRefed<nsStyleContext>
    1:   ResolveStyleForNonElement(nsStyleContext* aParentContext);
    1: 
    1:   // get a style context for a pseudo-element (i.e.,
    1:   // |aPseudoTag == nsCOMPtr<nsIAtom>(do_GetAtom(":first-line"))|, in
    1:   // which case aParentContent must be non-null, or an anonymous box, in
    1:   // which case it may be null or non-null.
    1:   already_AddRefed<nsStyleContext>
    1:   ResolvePseudoStyleFor(nsIContent* aParentContent,
    1:                         nsIAtom* aPseudoTag,
    1:                         nsStyleContext* aParentContext,
    1:                         nsICSSPseudoComparator* aComparator = nsnull);
    1: 
    1:   // This functions just like ResolvePseudoStyleFor except that it will
    1:   // return nsnull if there are no explicit style rules for that
    1:   // pseudo element.  It should be used only for pseudo-elements.
    1:   already_AddRefed<nsStyleContext>
    1:   ProbePseudoStyleFor(nsIContent* aParentContent,
    1:                       nsIAtom* aPseudoTag,
    1:                       nsStyleContext* aParentContext);
    1: 
21924:   // Append all the currently-active font face rules to aArray.  Return
21924:   // true for success and false for failure.
21924:   PRBool AppendFontFaceRules(nsPresContext* aPresContext,
21983:                              nsTArray<nsFontFaceRuleContainer>& aArray);
21924: 
    1:   // Begin ignoring style context destruction, to avoid lots of unnecessary
    1:   // work on document teardown.
    1:   void BeginShutdown(nsPresContext* aPresContext);
    1: 
    1:   // Free all of the data associated with this style set.
    1:   void Shutdown(nsPresContext* aPresContext);
    1: 
    1:   // Notification that a style context is being destroyed.
    1:   void NotifyStyleContextDestroyed(nsPresContext* aPresContext,
    1:                                    nsStyleContext* aStyleContext);
    1: 
    1:   // Get a new style context that lives in a different parent
    1:   // The new context will be the same as the old if the new parent is the
    1:   // same as the old parent.
    1:   already_AddRefed<nsStyleContext>
    1:     ReParentStyleContext(nsPresContext* aPresContext,
    1:                          nsStyleContext* aStyleContext,
    1:                          nsStyleContext* aNewParentContext);
    1: 
    1:   // Test if style is dependent on content state
    1:   nsReStyleHint HasStateDependentStyle(nsPresContext* aPresContext,
    1:                                        nsIContent*     aContent,
    1:                                        PRInt32         aStateMask);
    1: 
    1:   // Test if style is dependent on the presence of an attribute.
    1:   nsReStyleHint HasAttributeDependentStyle(nsPresContext* aPresContext,
    1:                                            nsIContent*    aContent,
    1:                                            nsIAtom*       aAttribute,
 3410:                                            PRInt32        aModType,
 3410:                                            PRUint32       aStateMask);
    1: 
16225:   /*
16225:    * Do any processing that needs to happen as a result of a change in
16225:    * the characteristics of the medium, and return whether style rules
16225:    * may have changed as a result.
16225:    */
16225:   PRBool MediumFeaturesChanged(nsPresContext* aPresContext);
16225: 
    1:   // APIs for registering objects that can supply additional
    1:   // rules during processing.
    1:   void SetBindingManager(nsBindingManager* aBindingManager)
    1:   {
    1:     mBindingManager = aBindingManager;
    1:   }
    1: 
    1:   // The "origins" of the CSS cascade, from lowest precedence to
    1:   // highest (for non-!important rules).
    1:   enum sheetType {
    1:     eAgentSheet, // CSS
    1:     ePresHintSheet,
    1:     eUserSheet, // CSS
    1:     eHTMLPresHintSheet,
    1:     eDocSheet, // CSS
    1:     eStyleAttrSheet,
    1:     eOverrideSheet, // CSS
    1:     eSheetTypeCount
 1539:     // be sure to keep the number of bits in |mDirty| below and in
 1539:     // NS_RULE_NODE_LEVEL_MASK updated when changing the number of sheet
 1539:     // types
    1:   };
    1: 
    1:   // APIs to manipulate the style sheet lists.  The sheets in each
    1:   // list are stored with the most significant sheet last.
    1:   nsresult AppendStyleSheet(sheetType aType, nsIStyleSheet *aSheet);
    1:   nsresult PrependStyleSheet(sheetType aType, nsIStyleSheet *aSheet);
    1:   nsresult RemoveStyleSheet(sheetType aType, nsIStyleSheet *aSheet);
    1:   nsresult ReplaceSheets(sheetType aType,
    1:                          const nsCOMArray<nsIStyleSheet> &aNewSheets);
    1: 
    1:   //Enable/Disable entire author style level (Doc & PresHint levels)
    1:   PRBool GetAuthorStyleDisabled();
    1:   nsresult SetAuthorStyleDisabled(PRBool aStyleDisabled);
    1: 
    1:   PRInt32 SheetCount(sheetType aType) const {
    1:     return mSheets[aType].Count();
    1:   }
    1: 
    1:   nsIStyleSheet* StyleSheetAt(sheetType aType, PRInt32 aIndex) const {
    1:     return mSheets[aType].ObjectAt(aIndex);
    1:   }
    1: 
    1:   nsresult AddDocStyleSheet(nsIStyleSheet* aSheet, nsIDocument* aDocument);
    1: 
    1:   void     BeginUpdate();
    1:   nsresult EndUpdate();
    1: 
 3959:   // Methods for reconstructing the tree; BeginReconstruct basically moves the
 3959:   // old rule tree root and style context roots out of the way,
 3959:   // and EndReconstruct destroys the old rule tree when we're done
 3959:   nsresult BeginReconstruct();
 3959:   // Note: EndReconstruct should not be called if BeginReconstruct fails
 3959:   void EndReconstruct();
 3959: 
21209:   // Let the style set know that a particular sheet is the quirks sheet.  This
21209:   // sheet must already have been added to the UA sheets.  The pointer must not
21209:   // be null.  This should only be called once for a given style set.
21209:   void SetQuirkStyleSheet(nsIStyleSheet* aQuirkStyleSheet);
21209: 
23163:   // Return whether the rule tree has cached data such that we need to
23163:   // do dynamic change handling for changes that change the results of
23163:   // media queries or require rebuilding all style data.
23163:   // We don't care whether we have cached rule processors or whether
23163:   // they have cached rule cascades; getting the rule cascades again in
23163:   // order to do rule matching will get the correct rule cascade.
23163:   PRBool HasCachedStyleData() const {
23163:     return (mRuleTree && mRuleTree->TreeHasCachedData()) || !mRoots.IsEmpty();
23163:   }
23163: 
33020:   // Notify the style set that a rulenode is no longer in use, or was
33020:   // just created and is not in use yet.
33020:   void RuleNodeUnused() {
33020:     ++mUnusedRuleNodeCount;
33020:   }
33020: 
33020:   // Notify the style set that a rulenode that wasn't in use now is
33020:   void RuleNodeInUse() {
33020:     --mUnusedRuleNodeCount;
33020:   }
33020:   
    1:  private:
    1:   // Not to be implemented
    1:   nsStyleSet(const nsStyleSet& aCopy);
    1:   nsStyleSet& operator=(const nsStyleSet& aCopy);
    1: 
    1:   // Returns false on out-of-memory.
    1:   PRBool BuildDefaultStyleData(nsPresContext* aPresContext);
    1: 
24429:   // Run mark-and-sweep GC on mRuleTree and mOldRuleTrees, based on mRoots.
24429:   void GCRuleTrees();
24429: 
    1:   // Update the rule processor list after a change to the style sheet list.
    1:   nsresult GatherRuleProcessors(sheetType aType);
    1: 
    1:   void AddImportantRules(nsRuleNode* aCurrLevelNode,
33399:                          nsRuleNode* aLastPrevLevelNode,
33399:                          nsRuleWalker* aRuleWalker);
    1: 
33399:   // Move aRuleWalker forward by the appropriate rule if we need to add
22737:   // a rule due to property restrictions on pseudo-elements.
33399:   void WalkRestrictionRule(nsIAtom* aPseudoType,
33399:                            nsRuleWalker* aRuleWalker);
22737: 
    1: #ifdef DEBUG
    1:   // Just like AddImportantRules except it doesn't actually add anything; it
    1:   // just asserts that there are no important rules between aCurrLevelNode and
    1:   // aLastPrevLevelNode.
    1:   void AssertNoImportantRules(nsRuleNode* aCurrLevelNode,
    1:                               nsRuleNode* aLastPrevLevelNode);
    1:   
    1:   // Just like AddImportantRules except it doesn't actually add anything; it
    1:   // just asserts that there are no CSS rules between aCurrLevelNode and
    1:   // aLastPrevLevelNode.  Mostly useful for the preshint levels.
    1:   void AssertNoCSSRules(nsRuleNode* aCurrLevelNode,
    1:                         nsRuleNode* aLastPrevLevelNode);
    1: #endif
    1:   
    1:   // Enumerate the rules in a way that cares about the order of the
    1:   // rules.
    1:   void FileRules(nsIStyleRuleProcessor::EnumFunc aCollectorFunc,
33399:                  RuleProcessorData* aData, nsRuleWalker* aRuleWalker);
    1: 
    1:   // Enumerate all the rules in a way that doesn't care about the order
    1:   // of the rules and break out if the enumeration is halted.
    1:   void WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
    1:                           RuleProcessorData* aData);
    1: 
    1:   already_AddRefed<nsStyleContext> GetContext(nsPresContext* aPresContext,
    1:                                               nsStyleContext* aParentContext,
33399:                                               nsRuleNode* aRuleNode,
    1:                                               nsIAtom* aPseudoTag);
    1: 
    1:   nsPresContext* PresContext() { return mRuleTree->GetPresContext(); }
    1: 
    1:   // The sheets in each array in mSheets are stored with the most significant
    1:   // sheet last.
    1:   nsCOMArray<nsIStyleSheet> mSheets[eSheetTypeCount];
    1: 
    1:   nsCOMPtr<nsIStyleRuleProcessor> mRuleProcessors[eSheetTypeCount];
    1: 
    1:   // cached instance for enabling/disabling
    1:   nsCOMPtr<nsIStyleSheet> mQuirkStyleSheet;
    1: 
    1:   nsRefPtr<nsBindingManager> mBindingManager;
    1: 
    1:   // To be used only in case of emergency, such as being out of memory
    1:   // or operating on a deleted rule node.  The latter should never
    1:   // happen, of course.
    1:   nsCachedStyleData mDefaultStyleData;
    1: 
    1:   nsRuleNode* mRuleTree; // This is the root of our rule tree.  It is a
    1:                          // lexicographic tree of matched rules that style
    1:                          // contexts use to look up properties.
    1: 
33020:   PRUint32 mUnusedRuleNodeCount; // used to batch rule node GC
 3959:   nsTArray<nsStyleContext*> mRoots; // style contexts with no parent
    1: 
22737:   // Empty style rules to force things that restrict which properties
22737:   // apply into different branches of the rule tree.
22737:   nsRefPtr<nsEmptyStyleRule> mFirstLineRule, mFirstLetterRule;
22737: 
    1:   PRUint16 mBatching;
    1: 
24429:   // Old rule trees, which should only be non-empty between
24429:   // BeginReconstruct and EndReconstruct, but in case of bugs that cause
24429:   // style contexts to exist too long, may last longer.
24429:   nsTArray<nsRuleNode*> mOldRuleTrees;
 3959: 
    1:   unsigned mInShutdown : 1;
    1:   unsigned mAuthorStyleDisabled: 1;
24429:   unsigned mInReconstruct : 1;
    1:   unsigned mDirty : 7;  // one dirty bit is used per sheet type
 3959: 
    1: };
    1: 
33020: inline
33020: NS_HIDDEN_(void) nsRuleNode::AddRef()
33020: {
33020:   if (mRefCnt++ == 0 && !IsRoot()) {
33020:     mPresContext->StyleSet()->RuleNodeInUse();
33020:   }
33020: }
33020: 
33020: inline
33020: NS_HIDDEN_(void) nsRuleNode::Release()
33020: {
33020:   if (--mRefCnt == 0 && !IsRoot()) {
33020:     mPresContext->StyleSet()->RuleNodeUnused();
33020:   }
33020: }
    1: #endif
