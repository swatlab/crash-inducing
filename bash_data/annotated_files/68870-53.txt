    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.org.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corp.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Glazman (glazman@netscape.com) (Original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsHTMLEditor.h"
    1: 
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIEditor.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: 
    1: #include "nsISelection.h"
    1: 
    1: #include "nsTextEditUtils.h"
    1: #include "nsEditorUtils.h"
    1: #include "nsHTMLEditUtils.h"
    1: #include "nsTextEditRules.h"
    1: 
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMNSHTMLElement.h"
    1: #include "nsIDOMEventTarget.h"
    1: 
    1: #include "nsIDOMCSSValue.h"
    1: #include "nsIDOMCSSPrimitiveValue.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
13965: #include "nsIMutationObserver.h"
    1: #include "nsUnicharUtils.h"
14102: #include "nsContentUtils.h"
    1: 
    1: // retrieve an integer stored into a CSS computed float value
    1: static PRInt32 GetCSSFloatValue(nsIDOMCSSStyleDeclaration * aDecl,
    1:                                 const nsAString & aProperty)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDecl);
    1: 
    1:   nsCOMPtr<nsIDOMCSSValue> value;
    1:   // get the computed CSSValue of the property
    1:   nsresult res = aDecl->GetPropertyCSSValue(aProperty, getter_AddRefs(value));
    1:   if (NS_FAILED(res) || !value) return 0;
    1: 
    1:   // check the type of the returned CSSValue; we handle here only
    1:   // pixel and enum types
    1:   nsCOMPtr<nsIDOMCSSPrimitiveValue> val = do_QueryInterface(value);
    1:   PRUint16 type;
    1:   val->GetPrimitiveType(&type);
    1: 
    1:   float f = 0;
    1:   switch (type) {
    1:     case nsIDOMCSSPrimitiveValue::CSS_PX:
    1:       // the value is in pixels, just get it
    1:       res = val->GetFloatValue(nsIDOMCSSPrimitiveValue::CSS_PX, &f);
43805:       NS_ENSURE_SUCCESS(res, 0);
    1:       break;
    1:     case nsIDOMCSSPrimitiveValue::CSS_IDENT: {
    1:       // the value is keyword, we have to map these keywords into
    1:       // numeric values
    1:       nsAutoString str;
    1:       res = val->GetStringValue(str);
    1:       if (str.EqualsLiteral("thin"))
    1:         f = 1;
    1:       else if (str.EqualsLiteral("medium"))
    1:         f = 3;
    1:       else if (str.EqualsLiteral("thick"))
    1:         f = 5;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return (PRInt32) f;
    1: }
    1: 
13965: class nsElementDeletionObserver : public nsIMutationObserver
13965: {
13965: public:
13965:   nsElementDeletionObserver(nsINode* aNativeAnonNode, nsINode* aObservedNode)
13965:   : mNativeAnonNode(aNativeAnonNode), mObservedNode(aObservedNode) {}
13965:   NS_DECL_ISUPPORTS
13965:   NS_DECL_NSIMUTATIONOBSERVER
13965: protected:
13965:   nsINode* mNativeAnonNode;
13965:   nsINode* mObservedNode;
13965: };
13965: 
13965: NS_IMPL_ISUPPORTS1(nsElementDeletionObserver, nsIMutationObserver)
13965: NS_IMPL_NSIMUTATIONOBSERVER_CONTENT(nsElementDeletionObserver)
13965: 
13965: void
13965: nsElementDeletionObserver::NodeWillBeDestroyed(const nsINode* aNode)
13965: {
13965:   NS_ASSERTION(aNode == mNativeAnonNode || aNode == mObservedNode,
13965:                "Wrong aNode!");
13965:   if (aNode == mNativeAnonNode) {
13965:     mObservedNode->RemoveMutationObserver(this);
13965:   } else {
13965:     mNativeAnonNode->RemoveMutationObserver(this);
13965:     static_cast<nsIContent*>(mNativeAnonNode)->UnbindFromTree();
13965:   }
13965: 
13965:   NS_RELEASE_THIS();
13965: }
13965: 
    1: // Returns in *aReturn an anonymous nsDOMElement of type aTag,
    1: // child of aParentNode. If aIsCreatedHidden is true, the class
    1: // "hidden" is added to the created element. If aAnonClass is not
    1: // the empty string, it becomes the value of the attribute "_moz_anonclass"
    1: nsresult
    1: nsHTMLEditor::CreateAnonymousElement(const nsAString & aTag, nsIDOMNode *  aParentNode,
    1:                                      const nsAString & aAnonClass, PRBool aIsCreatedHidden,
    1:                                      nsIDOMElement ** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aParentNode);
    1:   NS_ENSURE_ARG_POINTER(aReturn);
13965:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIContent> parentContent( do_QueryInterface(aParentNode) );
43807:   NS_ENSURE_TRUE(parentContent, NS_OK);
    1: 
    1:   // Get the document
    1:   nsCOMPtr<nsIDOMDocument> domDoc;
    1:   GetDocument(getter_AddRefs(domDoc));
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
43806:   NS_ENSURE_TRUE(doc, NS_ERROR_NULL_POINTER);
    1: 
    1:   // Get the pres shell
63587:   nsCOMPtr<nsIPresShell> ps;
63587:   GetPresShell(getter_AddRefs(ps));
43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   // Create a new node through the element factory
    1:   nsCOMPtr<nsIContent> newContent;
    1:   nsresult res = CreateHTMLContent(aTag, getter_AddRefs(newContent));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   nsCOMPtr<nsIDOMElement> newElement = do_QueryInterface(newContent);
43807:   NS_ENSURE_TRUE(newElement, NS_ERROR_FAILURE);
    1: 
    1:   // add the "hidden" class if needed
    1:   if (aIsCreatedHidden) {
    1:     res = newElement->SetAttribute(NS_LITERAL_STRING("class"),
    1:                                    NS_LITERAL_STRING("hidden"));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   // add an _moz_anonclass attribute if needed
    1:   if (!aAnonClass.IsEmpty()) {
    1:     res = newElement->SetAttribute(NS_LITERAL_STRING("_moz_anonclass"),
    1:                                    aAnonClass);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
14102:   {
14102:     nsAutoScriptBlocker scriptBlocker;
14102: 
    1:     // establish parenthood of the element
 9807:     newContent->SetNativeAnonymous();
16126:     res = newContent->BindToTree(doc, parentContent, parentContent, PR_TRUE);
    1:     if (NS_FAILED(res)) {
    1:       newContent->UnbindFromTree();
    1:       return res;
    1:     }
14102:   }
    1: 
13965:   nsElementDeletionObserver* observer =
13965:     new nsElementDeletionObserver(newContent, parentContent);
13965:   if (!observer) {
13965:     newContent->UnbindFromTree();
13965:     return NS_ERROR_OUT_OF_MEMORY;
13965:   }
13965:   NS_ADDREF(observer); // NodeWillBeDestroyed releases.
13965:   parentContent->AddMutationObserver(observer);
13965:   newContent->AddMutationObserver(observer);
13965: 
    1:   // display the element
    1:   ps->RecreateFramesFor(newContent);
    1: 
    1:   *aReturn = newElement;
    1:   NS_IF_ADDREF(*aReturn);
    1:   return NS_OK;
    1: }
    1: 
    1: // Removes event listener and calls DeleteRefToAnonymousNode.
    1: void
    1: nsHTMLEditor::RemoveListenerAndDeleteRef(const nsAString& aEvent,
    1:                                          nsIDOMEventListener* aListener,
    1:                                          PRBool aUseCapture,
    1:                                          nsIDOMElement* aElement,
    1:                                          nsIContent * aParentContent,
    1:                                          nsIPresShell* aShell)
    1: {
    1:   nsCOMPtr<nsIDOMEventTarget> evtTarget(do_QueryInterface(aElement));
    1:   if (evtTarget) {
    1:     evtTarget->RemoveEventListener(aEvent, aListener, aUseCapture);
    1:   }
    1:   DeleteRefToAnonymousNode(aElement, aParentContent, aShell);
    1: }
    1: 
    1: // Deletes all references to an anonymous element
    1: void
    1: nsHTMLEditor::DeleteRefToAnonymousNode(nsIDOMElement* aElement,
    1:                                        nsIContent* aParentContent,
    1:                                        nsIPresShell* aShell)
    1: {
    1:   // call ContentRemoved() for the anonymous content
    1:   // node so its references get removed from the frame manager's
    1:   // undisplay map, and its layout frames get destroyed!
    1: 
    1:   if (aElement) {
    1:     nsCOMPtr<nsIContent> content = do_QueryInterface(aElement);
    1:     if (content) {
14102:       nsAutoScriptBlocker scriptBlocker;
    1:       // Need to check whether aShell has been destroyed (but not yet deleted).
    1:       // In that case presContext->GetPresShell() returns nsnull.
    1:       // See bug 338129.
    1:       if (aShell && aShell->GetPresContext() &&
    1:           aShell->GetPresContext()->GetPresShell() == aShell) {
    1:         nsCOMPtr<nsIDocumentObserver> docObserver = do_QueryInterface(aShell);
    1:         if (docObserver) {
10522:           // Call BeginUpdate() so that the nsCSSFrameConstructor/PresShell
10522:           // knows we're messing with the frame tree.
10522:           nsCOMPtr<nsIDOMDocument> domDocument;
23383:           GetDocument(getter_AddRefs(domDocument));
10522:           nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
10522:           if (document)
10522:             docObserver->BeginUpdate(document, UPDATE_CONTENT_MODEL);
10522: 
    1:           docObserver->ContentRemoved(content->GetCurrentDoc(),
48038:                                       aParentContent, content, -1,
48038:                                       content->GetPreviousSibling());
10522:           if (document)
10522:             docObserver->EndUpdate(document, UPDATE_CONTENT_MODEL);
    1:         }
    1:       }
    1:       content->UnbindFromTree();
    1:     }
    1:   }
    1: }  
    1: 
    1: // The following method is mostly called by a selection listener. When a
    1: // selection change is notified, the method is called to check if resizing
    1: // handles, a grabber and/or inline table editing UI need to be displayed
    1: // or refreshed
    1: NS_IMETHODIMP
    1: nsHTMLEditor::CheckSelectionStateForAnonymousButtons(nsISelection * aSelection)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSelection);
    1: 
    1:   // early way out if all contextual UI extensions are disabled
43807:   NS_ENSURE_TRUE(mIsObjectResizingEnabled ||
43807:       mIsAbsolutelyPositioningEnabled ||
43807:       mIsInlineTableEditingEnabled, NS_OK);
    1: 
 2386:   // Don't change selection state if we're moving.
 2386:   if (mIsMoving) {
 2386:     return NS_OK;
 2386:   }
 2386: 
    1:   nsCOMPtr<nsIDOMElement> focusElement;
    1:   // let's get the containing element of the selection
    1:   nsresult res  = GetSelectionContainer(getter_AddRefs(focusElement));
43806:   NS_ENSURE_TRUE(focusElement, NS_OK);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // what's its tag?
    1:   nsAutoString focusTagName;
    1:   res = focusElement->GetTagName(focusTagName);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   ToLowerCase(focusTagName);
    1:   nsCOMPtr<nsIAtom> focusTagAtom = do_GetAtom(focusTagName);
    1: 
    1:   nsCOMPtr<nsIDOMElement> absPosElement;
    1:   if (mIsAbsolutelyPositioningEnabled) {
    1:     // Absolute Positioning support is enabled, is the selection contained
    1:     // in an absolutely positioned element ?
    1:     res = GetAbsolutelyPositionedSelectionContainer(getter_AddRefs(absPosElement));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMElement> cellElement;
    1:   if (mIsObjectResizingEnabled || mIsInlineTableEditingEnabled) {
    1:     // Resizing or Inline Table Editing is enabled, we need to check if the
    1:     // selection is contained in a table cell
    1:     res = GetElementOrParentByTagName(NS_LITERAL_STRING("td"),
    1:                                       nsnull,
    1:                                       getter_AddRefs(cellElement));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   if (mIsObjectResizingEnabled && cellElement) {
    1:     // we are here because Resizing is enabled AND selection is contained in
    1:     // a cell
    1: 
    1:     // get the enclosing table
    1:     if (nsEditProperty::img != focusTagAtom) {
    1:       // the element container of the selection is not an image, so we'll show
    1:       // the resizers around the table
    1:       nsCOMPtr<nsIDOMNode> tableNode = GetEnclosingTable(cellElement);
    1:       focusElement = do_QueryInterface(tableNode);
    1:       focusTagAtom = nsEditProperty::table;
    1:     }
    1:   }
    1: 
    1:   // we allow resizers only around images, tables, and absolutely positioned
    1:   // elements. If we don't have image/table, let's look at the latter case.
    1:   if (nsEditProperty::img != focusTagAtom &&
    1:       nsEditProperty::table != focusTagAtom)
    1:     focusElement = absPosElement;
    1: 
    1:   // at this point, focusElement  contains the element for Resizing,
    1:   //                cellElement   contains the element for InlineTableEditing
    1:   //                absPosElement contains the element for Positioning
    1: 
14277:   // Note: All the Hide/Show methods below may change attributes on real
14277:   // content which means a DOMAttrModified handler may cause arbitrary
14277:   // side effects while this code runs (bug 420439).
    1: 
    1:   if (mIsAbsolutelyPositioningEnabled && mAbsolutelyPositionedObject &&
    1:       absPosElement != mAbsolutelyPositionedObject) {
    1:     res = HideGrabber();
43805:     NS_ENSURE_SUCCESS(res, res);
14277:     NS_ASSERTION(!mAbsolutelyPositionedObject, "HideGrabber failed");
    1:   }
    1: 
    1:   if (mIsObjectResizingEnabled && mResizedObject &&
    1:       mResizedObject != focusElement) {
    1:     res = HideResizers();
43805:     NS_ENSURE_SUCCESS(res, res);
14277:     NS_ASSERTION(!mResizedObject, "HideResizers failed");
    1:   }
    1: 
    1:   if (mIsInlineTableEditingEnabled && mInlineEditedCell &&
    1:       mInlineEditedCell != cellElement) {
    1:     res = HideInlineTableEditingUI();
43805:     NS_ENSURE_SUCCESS(res, res);
14277:     NS_ASSERTION(!mInlineEditedCell, "HideInlineTableEditingUI failed");
    1:   }
    1: 
    1:   // now, let's display all contextual UI for good
    1: 
 3723:   if (mIsObjectResizingEnabled && focusElement &&
 3723:       IsModifiableNode(focusElement)) {
    1:     if (nsEditProperty::img == focusTagAtom)
    1:       mResizedObjectIsAnImage = PR_TRUE;
14277:     if (mResizedObject)
    1:       res = RefreshResizers();
    1:     else
    1:       res = ShowResizers(focusElement);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
 3723:   if (mIsAbsolutelyPositioningEnabled && absPosElement &&
 3723:       IsModifiableNode(absPosElement)) {
14277:     if (mAbsolutelyPositionedObject)
    1:       res = RefreshGrabber();
    1:     else
    1:       res = ShowGrabberOnElement(absPosElement);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
 3723:   if (mIsInlineTableEditingEnabled && cellElement &&
 3723:       IsModifiableNode(cellElement)) {
14277:     if (mInlineEditedCell)
    1:       res = RefreshInlineTableEditingUI();
    1:     else
    1:       res = ShowInlineTableEditingUI(cellElement);
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: // Resizing and Absolute Positioning need to know everything about the
    1: // containing box of the element: position, size, margins, borders
    1: nsresult
    1: nsHTMLEditor::GetPositionAndDimensions(nsIDOMElement * aElement,
    1:                                        PRInt32 & aX, PRInt32 & aY,
    1:                                        PRInt32 & aW, PRInt32 & aH,
    1:                                        PRInt32 & aBorderLeft,
    1:                                        PRInt32 & aBorderTop,
    1:                                        PRInt32 & aMarginLeft,
    1:                                        PRInt32 & aMarginTop)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aElement);
    1: 
    1:   // Is the element positioned ? let's check the cheap way first...
    1:   PRBool isPositioned = PR_FALSE;
    1:   nsresult res = aElement->HasAttribute(NS_LITERAL_STRING("_moz_abspos"), &isPositioned);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!isPositioned) {
    1:     // hmmm... the expensive way now...
    1:     nsAutoString positionStr;
    1:     mHTMLCSSUtils->GetComputedProperty(aElement, nsEditProperty::cssPosition,
    1:                                        positionStr);
    1:     isPositioned = positionStr.EqualsLiteral("absolute");
    1:   }
    1: 
    1:   if (isPositioned) {
    1:     // Yes, it is absolutely positioned
    1:     mResizedObjectIsAbsolutelyPositioned = PR_TRUE;
    1: 
68870:     nsCOMPtr<nsIDOMViewCSS> viewCSS;
68870:     res = mHTMLCSSUtils->GetDefaultViewCSS(aElement, getter_AddRefs(viewCSS));
68870:     NS_ENSURE_TRUE(viewCSS, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl;
    1:     // Get the all the computed css styles attached to the element node
68870:     res = viewCSS->GetComputedStyle(aElement, EmptyString(), getter_AddRefs(cssDecl));
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     aBorderLeft = GetCSSFloatValue(cssDecl, NS_LITERAL_STRING("border-left-width"));
    1:     aBorderTop  = GetCSSFloatValue(cssDecl, NS_LITERAL_STRING("border-top-width"));
    1:     aMarginLeft = GetCSSFloatValue(cssDecl, NS_LITERAL_STRING("margin-left"));
    1:     aMarginTop  = GetCSSFloatValue(cssDecl, NS_LITERAL_STRING("margin-top"));
    1: 
    1:     aX = GetCSSFloatValue(cssDecl, NS_LITERAL_STRING("left")) +
    1:          aMarginLeft + aBorderLeft;
    1:     aY = GetCSSFloatValue(cssDecl, NS_LITERAL_STRING("top")) +
    1:          aMarginTop + aBorderTop;
    1:     aW = GetCSSFloatValue(cssDecl, NS_LITERAL_STRING("width"));
    1:     aH = GetCSSFloatValue(cssDecl, NS_LITERAL_STRING("height"));
    1:   }
    1:   else {
    1:     mResizedObjectIsAbsolutelyPositioned = PR_FALSE;
    1:     nsCOMPtr<nsIDOMNSHTMLElement> nsElement = do_QueryInterface(aElement);
    1:     if (!nsElement) {return NS_ERROR_NULL_POINTER; }
    1: 
    1:     GetElementOrigin(aElement, aX, aY);
    1: 
    1:     res = nsElement->GetOffsetWidth(&aW);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = nsElement->GetOffsetHeight(&aH);
    1: 
    1:     aBorderLeft = 0;
    1:     aBorderTop  = 0;
    1:     aMarginLeft = 0;
    1:     aMarginTop = 0;
    1:   }
    1:   return res;
    1: }
    1: 
    1: // self-explanatory
    1: void
    1: nsHTMLEditor::SetAnonymousElementPosition(PRInt32 aX, PRInt32 aY, nsIDOMElement *aElement)
    1: {
    1:   mHTMLCSSUtils->SetCSSPropertyPixels(aElement, NS_LITERAL_STRING("left"), aX);
    1:   mHTMLCSSUtils->SetCSSPropertyPixels(aElement, NS_LITERAL_STRING("top"), aY);
    1: }
