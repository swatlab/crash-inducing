29805: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
29805: /* vim: set sw=2 ts=2 et tw=79: */
29805: /* ***** BEGIN LICENSE BLOCK *****
29805:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
29805:  *
29805:  * The contents of this file are subject to the Mozilla Public License Version
29805:  * 1.1 (the "License"); you may not use this file except in compliance with
29805:  * the License. You may obtain a copy of the License at
29805:  * http://www.mozilla.org/MPL/
29805:  *
29805:  * Software distributed under the License is distributed on an "AS IS" basis,
29805:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
29805:  * for the specific language governing rights and limitations under the
29805:  * License.
29805:  *
29805:  * The Original Code is mozilla.org code.
29805:  *
29805:  * The Initial Developer of the Original Code is
29805:  * Netscape Communications Corporation.
29805:  * Portions created by the Initial Developer are Copyright (C) 1998
29805:  * the Initial Developer. All Rights Reserved.
29805:  *
29805:  * Contributor(s):
29805:  *   Pierre Phaneuf <pp@ludusdesign.com>
29805:  *   Henri Sivonen <hsivonen@iki.fi>
29805:  *
29805:  * Alternatively, the contents of this file may be used under the terms of
29805:  * either of the GNU General Public License Version 2 or later (the "GPL"),
29805:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
29805:  * in which case the provisions of the GPL or the LGPL are applicable instead
29805:  * of those above. If you wish to allow use of your version of this file only
29805:  * under the terms of either the GPL or the LGPL, and not to allow others to
29805:  * use your version of this file under the terms of the MPL, indicate your
29805:  * decision by deleting the provisions above and replace them with the notice
29805:  * and other provisions required by the GPL or the LGPL. If you do not delete
29805:  * the provisions above, a recipient may use your version of this file under
29805:  * the terms of any one of the MPL, the GPL or the LGPL.
29805:  *
29805:  * ***** END LICENSE BLOCK ***** */
29805: 
29805: #include "nsCompatibility.h"
29805: #include "nsScriptLoader.h"
29805: #include "nsNetUtil.h"
29805: #include "nsIStyleSheetLinkingElement.h"
29805: #include "nsICharsetAlias.h"
29805: #include "nsIWebShellServices.h"
29805: #include "nsIDocShell.h"
29805: #include "nsEncoderDecoderUtils.h"
29805: #include "nsContentUtils.h"
29805: #include "nsICharsetDetector.h"
29805: #include "nsIScriptElement.h"
29805: #include "nsIMarkupDocumentViewer.h"
29805: #include "nsIDocShellTreeItem.h"
29805: #include "nsIContentViewer.h"
29805: #include "nsIScriptGlobalObjectOwner.h"
29805: #include "nsIScriptSecurityManager.h"
29805: #include "nsHtml5DocumentMode.h"
29805: #include "nsHtml5Tokenizer.h"
29805: #include "nsHtml5UTF16Buffer.h"
29805: #include "nsHtml5TreeBuilder.h"
29805: #include "nsHtml5Parser.h"
34978: #include "nsHtml5AtomTable.h"
57328: #include "nsIDOMDocumentFragment.h"
80404: #include "nsHtml5DependentUTF16Buffer.h"
29805: 
32917: NS_INTERFACE_TABLE_HEAD(nsHtml5Parser)
34983:   NS_INTERFACE_TABLE2(nsHtml5Parser, nsIParser, nsISupportsWeakReference)
32917:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsHtml5Parser)
32917: NS_INTERFACE_MAP_END
32917: 
32917: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsHtml5Parser)
32917: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsHtml5Parser)
32917: 
29805: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHtml5Parser)
29805: 
32917: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsHtml5Parser)
40983:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mExecutor,
40983:                                                        nsIContentSink)
40983:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mStreamParser,
40983:                                                        nsIStreamListener)
29805: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
29805: 
32917: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsHtml5Parser)
32917:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mExecutor)
41396:   tmp->DropStreamParser();
29805: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
29805: 
29805: nsHtml5Parser::nsHtml5Parser()
80404:   : mFirstBuffer(new nsHtml5OwningUTF16Buffer((void*)nsnull))
32917:   , mLastBuffer(mFirstBuffer)
32917:   , mExecutor(new nsHtml5TreeOpExecutor())
38132:   , mTreeBuilder(new nsHtml5TreeBuilder(mExecutor, nsnull))
32917:   , mTokenizer(new nsHtml5Tokenizer(mTreeBuilder))
35294:   , mRootContextLineNumber(1)
29805: {
34979:   mAtomTable.Init(); // we aren't checking for OOM anyway...
34979:   mTokenizer->setInterner(&mAtomTable);
29805:   // There's a zeroing operator new for everything else
29805: }
29805: 
29805: nsHtml5Parser::~nsHtml5Parser()
29805: {
34979:   mTokenizer->end();
57849:   if (mDocWriteSpeculativeTokenizer) {
57849:     mDocWriteSpeculativeTokenizer->end();
57849:   }
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::SetContentSink(nsIContentSink* aSink)
29805: {
32917:   NS_ASSERTION(aSink == static_cast<nsIContentSink*> (mExecutor), 
30334:                "Attempt to set a foreign sink.");
29805: }
29805: 
29805: NS_IMETHODIMP_(nsIContentSink*)
40983: nsHtml5Parser::GetContentSink()
29805: {
32917:   return static_cast<nsIContentSink*> (mExecutor);
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::GetCommand(nsCString& aCommand)
29805: {
29805:   aCommand.Assign("view");
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::SetCommand(const char* aCommand)
29805: {
29805:   NS_ASSERTION(!strcmp(aCommand, "view"), "Parser command was not view");
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::SetCommand(eParserCommands aParserCommand)
29805: {
30334:   NS_ASSERTION(aParserCommand == eViewNormal, 
30334:                "Parser command was not eViewNormal.");
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
40983: nsHtml5Parser::SetDocumentCharset(const nsACString& aCharset,
40983:                                   PRInt32 aCharsetSource)
29805: {
34981:   NS_PRECONDITION(!mExecutor->HasStarted(),
32917:                   "Document charset set too late.");
40983:   NS_PRECONDITION(mStreamParser, "Setting charset on a script-only parser.");
60373:   nsCAutoString trimmed;
60373:   trimmed.Assign(aCharset);
60373:   trimmed.Trim(" \t\r\n\f");
60373:   mStreamParser->SetDocumentCharset(trimmed, aCharsetSource);
60373:   mExecutor->SetDocumentCharsetAndSource(trimmed,
40983:                                          aCharsetSource);
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::SetParserFilter(nsIParserFilter* aFilter)
29805: {
29805:   NS_ERROR("Attempt to set a parser filter on HTML5 parser.");
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::GetChannel(nsIChannel** aChannel)
29805: {
32917:   if (mStreamParser) {
32917:     return mStreamParser->GetChannel(aChannel);
32917:   } else {
32917:     return NS_ERROR_NOT_AVAILABLE;
32917:   }
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::GetDTD(nsIDTD** aDTD)
29805: {
29805:   *aDTD = nsnull;
29805:   return NS_OK;
29805: }
29805: 
29805: NS_IMETHODIMP
32917: nsHtml5Parser::GetStreamListener(nsIStreamListener** aListener)
32917: {
34983:   NS_IF_ADDREF(*aListener = mStreamParser);
32917:   return NS_OK;
32917: }
32917: 
32917: NS_IMETHODIMP
29805: nsHtml5Parser::ContinueInterruptedParsing()
29805: {
39737:   NS_NOTREACHED("Don't call. For interface compat only.");
39737:   return NS_ERROR_NOT_IMPLEMENTED;
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::BlockParser()
29805: {
80486:   mBlocked = true;
29805: }
29805: 
29805: NS_IMETHODIMP_(void)
29805: nsHtml5Parser::UnblockParser()
29805: {
80486:   mBlocked = false;
29805: }
29805: 
79445: NS_IMETHODIMP_(bool)
29805: nsHtml5Parser::IsParserEnabled()
29805: {
29805:   return !mBlocked;
29805: }
29805: 
79445: NS_IMETHODIMP_(bool)
29805: nsHtml5Parser::IsComplete()
29805: {
32917:   return mExecutor->IsComplete();
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::Parse(nsIURI* aURL, // legacy parameter; ignored
29805:                      nsIRequestObserver* aObserver,
29805:                      void* aKey,
29805:                      nsDTDMode aMode) // legacy; ignored
29805: {
32917:   /*
32917:    * Do NOT cause WillBuildModel to be called synchronously from here!
32917:    * The document won't be ready for it until OnStartRequest!
32917:    */
34981:   NS_PRECONDITION(!mExecutor->HasStarted(), 
40983:                   "Tried to start parse without initializing the parser.");
34983:   NS_PRECONDITION(mStreamParser, 
40983:                   "Can't call this Parse() variant on script-created parser");
32917:   mStreamParser->SetObserver(aObserver);
32917:   mExecutor->SetStreamParser(mStreamParser);
32917:   mExecutor->SetParser(this);
29805:   mRootContextKey = aKey;
29805:   return NS_OK;
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::Parse(const nsAString& aSourceBuffer,
29805:                      void* aKey,
29805:                      const nsACString& aContentType, // ignored
79445:                      bool aLastCall,
29805:                      nsDTDMode aMode) // ignored
29805: {
40983:   NS_PRECONDITION(!mExecutor->IsFragmentMode(),
40983:                   "Document.write called in fragment mode!");
80404:   if (mExecutor->IsBroken()) {
80404:     return NS_ERROR_OUT_OF_MEMORY;
80404:   }
80404:   if (aSourceBuffer.Length() > PR_INT32_MAX) {
80404:     mExecutor->MarkAsBroken();
80404:     return NS_ERROR_OUT_OF_MEMORY;
80404:   }
32917: 
32917:   // Maintain a reference to ourselves so we don't go away
32917:   // till we're completely done. The old parser grips itself in this method.
32917:   nsCOMPtr<nsIParser> kungFuDeathGrip(this);
32917:   
32917:   // Gripping the other objects just in case, since the other old grip
32917:   // required grips to these, too.
32917:   nsRefPtr<nsHtml5StreamParser> streamKungFuDeathGrip(mStreamParser);
32917:   nsRefPtr<nsHtml5TreeOpExecutor> treeOpKungFuDeathGrip(mExecutor);
32917: 
34981:   if (!mExecutor->HasStarted()) {
34979:     NS_ASSERTION(!mStreamParser,
34979:                  "Had stream parser but document.write started life cycle.");
39511:     // This is the first document.write() on a document.open()ed document
32917:     mExecutor->SetParser(this);
32917:     mTreeBuilder->setScriptingEnabled(mExecutor->IsScriptEnabled());
29805:     mTokenizer->start();
34979:     mExecutor->Start();
34979:     /*
34979:      * If you move the following line, be very careful not to cause 
34979:      * WillBuildModel to be called before the document has had its 
34979:      * script global object set.
34979:      */
34979:     mExecutor->WillBuildModel(eDTDMode_unknown);
29805:   }
40983: 
40983:   // Return early if the parser has processed EOF
34981:   if (mExecutor->IsComplete()) {
34981:     return NS_OK;
34981:   }
40983: 
29805:   if (aLastCall && aSourceBuffer.IsEmpty() && aKey == GetRootContextKey()) {
29805:     // document.close()
34979:     NS_ASSERTION(!mStreamParser,
34979:                  "Had stream parser but got document.close().");
80486:     mDocumentClosed = true;
81105:     if (!mBlocked && !mInDocumentWrite) {
34992:       ParseUntilBlocked();
34992:     }
29805:     return NS_OK;
29805:   }
29805: 
81105:   // If we got this far, we are dealing with a document.write or
81105:   // document.writeln call--not document.close().
81105: 
40983:   NS_ASSERTION(IsInsertionPointDefined(),
40983:                "Doc.write reached parser with undefined insertion point.");
34983: 
40983:   NS_ASSERTION(!(mStreamParser && !aKey),
40983:                "Got a null key in a non-script-created parser");
35294: 
81105:   // XXX is this optimization bogus?
34983:   if (aSourceBuffer.IsEmpty()) {
34983:     return NS_OK;
34983:   }
34983: 
81105:   // This guard is here to prevent document.close from tokenizing synchronously
81105:   // while a document.write (that wrote the script that called document.close!)
81105:   // is still on the call stack.
81070:   mozilla::AutoRestore<bool> guard(mInDocumentWrite);
81070:   mInDocumentWrite = true;
81070: 
81105:   // The script is identified by aKey. If there's nothing in the buffer
81105:   // chain for that key, we'll insert at the head of the queue.
81105:   // When the script leaves something in the queue, a zero-length
81105:   // key-holder "buffer" is inserted in the queue. If the same script
81105:   // leaves something in the chain again, it will be inserted immediately
81105:   // before the old key holder belonging to the same script.
81105:   //
81105:   // We don't do the actual data insertion yet in the hope that the data gets
81105:   // tokenized and there no data or less data to copy to the heap after
81105:   // tokenization. Also, this way, we avoid inserting one empty data buffer
81105:   // per document.write, which matters for performance when the parser isn't
81105:   // blocked and a badly-authored script calls document.write() once per
81105:   // input character. (As seen in a benchmark!)
81105:   //
81105:   // The insertion into the input stream happens conceptually before anything
81105:   // gets tokenized. To make sure multi-level document.write works right,
81105:   // it's necessary to establish the location of our parser key up front
81105:   // in case this is the first write with this key.
81105:   //
81105:   // In a document.open() case, the first write level has a null key, so that
81105:   // case is handled separately, because normal buffers containing data
81105:   // have null keys.
81105: 
81107:   // These don't need to be owning references, because they always point to
81107:   // the buffer queue and buffers can't be removed from the buffer queue
81107:   // before document.write() returns. The buffer queue clean-up happens the
81107:   // next time ParseUntilBlocked() is called.
81107:   // However, they are made owning just in case the reasoning above is flawed
81107:   // and a flaw would lead to worse problems with plain pointers. If this
81107:   // turns out to be a perf problem, it's worthwhile to consider making
81107:   // prevSearchbuf a plain pointer again.
81107:   nsRefPtr<nsHtml5OwningUTF16Buffer> prevSearchBuf;
81107:   nsRefPtr<nsHtml5OwningUTF16Buffer> firstLevelMarker;
81105: 
81105:   if (aKey) {
81105:     if (mFirstBuffer == mLastBuffer) {
81105:       nsHtml5OwningUTF16Buffer* keyHolder = new nsHtml5OwningUTF16Buffer(aKey);
81105:       keyHolder->next = mLastBuffer;
81105:       mFirstBuffer = keyHolder;
81107:     } else if (mFirstBuffer->key != aKey) {
81105:       prevSearchBuf = mFirstBuffer;
81105:       for (;;) {
81105:         if (prevSearchBuf->next == mLastBuffer) {
81105:           // key was not found
81105:           nsHtml5OwningUTF16Buffer* keyHolder =
81105:             new nsHtml5OwningUTF16Buffer(aKey);
81105:           keyHolder->next = mFirstBuffer;
81105:           mFirstBuffer = keyHolder;
81105:           prevSearchBuf = nsnull;
81105:           break;
81105:         }
81105:         if (prevSearchBuf->next->key == aKey) {
81105:           // found a key holder
81105:           break;
81105:         }
81105:         prevSearchBuf = prevSearchBuf->next;
81105:       }
81107:     } // else mFirstBuffer is the keyholder
81107: 
81105:     // prevSearchBuf is the previous buffer before the keyholder or null if
81105:     // there isn't one.
81105:   } else {
81105:     // We have a first-level write in the document.open() case. We insert
81105:     // before mLastBuffer. We need to put a marker there, because otherwise
81105:     // additional document.writes from nested event loops would insert in the
81105:     // wrong place. Sigh.
81105:     firstLevelMarker = new nsHtml5OwningUTF16Buffer((void*)nsnull);
81105:     if (mFirstBuffer == mLastBuffer) {
81105:       firstLevelMarker->next = mLastBuffer;
81105:       mFirstBuffer = firstLevelMarker;
81105:     } else {
81105:       prevSearchBuf = mFirstBuffer;
81105:       while (prevSearchBuf->next != mLastBuffer) {
81105:         prevSearchBuf = prevSearchBuf->next;
81105:       }
81105:       firstLevelMarker->next = mLastBuffer;
81105:       prevSearchBuf->next = firstLevelMarker;
81105:     }
81105:   }
81105: 
80404:   nsHtml5DependentUTF16Buffer stackBuffer(aSourceBuffer);
29805: 
80404:   while (!mBlocked && stackBuffer.hasMore()) {
80404:     stackBuffer.adjust(mLastWasCR);
80486:     mLastWasCR = false;
80404:     if (stackBuffer.hasMore()) {
35294:       PRInt32 lineNumberSave;
79445:       bool inRootContext = (!mStreamParser && (aKey == mRootContextKey));
35294:       if (inRootContext) {
35294:         mTokenizer->setLineNumber(mRootContextLineNumber);
35294:       } else {
35294:         // we aren't the root context, so save the line number on the
35294:         // *stack* so that we can restore it.
35294:         lineNumberSave = mTokenizer->getLineNumber();
35294:       }
35294: 
80404:       mLastWasCR = mTokenizer->tokenizeBuffer(&stackBuffer);
35294: 
35294:       if (inRootContext) {
35294:         mRootContextLineNumber = mTokenizer->getLineNumber();
35294:       } else {
35294:         mTokenizer->setLineNumber(lineNumberSave);
35294:       }
35294: 
34983:       if (mTreeBuilder->HasScript()) {
34983:         mTreeBuilder->Flush(); // Move ops to the executor
39737:         mExecutor->FlushDocumentWrite(); // run the ops
81070:         // Flushing tree ops can cause all sorts of things.
81070:         // Return early if the parser got terminated.
81070:         if (mExecutor->IsComplete()) {
81070:           return NS_OK;
81070:         }
34981:       }
34983:       // Ignore suspension requests
34983:     }
34983:   }
34983: 
80404:   nsRefPtr<nsHtml5OwningUTF16Buffer> heapBuffer;
80404:   if (stackBuffer.hasMore()) {
80404:     // The buffer wasn't tokenized to completion. Create a copy of the tail
80404:     // on the heap.
80404:     heapBuffer = stackBuffer.FalliblyCopyAsOwningBuffer();
80404:     if (!heapBuffer) {
80404:       // Allocation failed. The parser is now broken.
80404:       mExecutor->MarkAsBroken();
80404:       return NS_ERROR_OUT_OF_MEMORY;
80404:     }
80404:   }
80404: 
81105:   if (heapBuffer) {
81105:     // We have something to insert before the keyholder holding in the non-null
81105:     // aKey case and we have something to swap into firstLevelMarker in the
81105:     // null aKey case.
81074:     if (aKey) {
81105:       NS_ASSERTION(mFirstBuffer != mLastBuffer,
81105:         "Where's the keyholder?");
81105:       // the key holder is still somewhere further down the list from
81105:       // prevSearchBuf (which may be null)
81105:       if (mFirstBuffer->key == aKey) {
81105:         NS_ASSERTION(!prevSearchBuf,
81105:           "Non-null prevSearchBuf when mFirstBuffer is the key holder?");
81105:         heapBuffer->next = mFirstBuffer;
80404:         mFirstBuffer = heapBuffer;
80404:       } else {
81105:         if (!prevSearchBuf) {
81105:           prevSearchBuf = mFirstBuffer;
80404:         }
81105:         // We created a key holder earlier, so we will find it without walking
81105:         // past the end of the list.
81105:         while (prevSearchBuf->next->key != aKey) {
81105:           prevSearchBuf = prevSearchBuf->next;
80404:         }
81105:         heapBuffer->next = prevSearchBuf->next;
81105:         prevSearchBuf->next = heapBuffer;
81074:       }
80404:     } else {
81105:       NS_ASSERTION(firstLevelMarker, "How come we don't have a marker.");
81105:       firstLevelMarker->Swap(heapBuffer);
80404:     }
80404:   }
80404: 
34983:   if (!mBlocked) { // buffer was tokenized to completion
80404:     NS_ASSERTION(!stackBuffer.hasMore(),
80404:       "Buffer wasn't tokenized to completion?");
34981:     // Scripting semantics require a forced tree builder flush here
34981:     mTreeBuilder->Flush(); // Move ops to the executor
39737:     mExecutor->FlushDocumentWrite(); // run the ops
80404:   } else if (stackBuffer.hasMore()) {
57849:     // The buffer wasn't tokenized to completion. Tokenize the untokenized
57849:     // content in order to preload stuff. This content will be retokenized
57849:     // later for normal parsing.
57849:     if (!mDocWriteSpeculatorActive) {
80486:       mDocWriteSpeculatorActive = true;
57849:       if (!mDocWriteSpeculativeTreeBuilder) {
57849:         // Lazily initialize if uninitialized
57849:         mDocWriteSpeculativeTreeBuilder =
57849:             new nsHtml5TreeBuilder(nsnull, mExecutor->GetStage());
69057:         mDocWriteSpeculativeTreeBuilder->setScriptingEnabled(
69057:             mTreeBuilder->isScriptingEnabled());
57849:         mDocWriteSpeculativeTokenizer =
57849:             new nsHtml5Tokenizer(mDocWriteSpeculativeTreeBuilder);
57849:         mDocWriteSpeculativeTokenizer->setInterner(&mAtomTable);
57849:         mDocWriteSpeculativeTokenizer->start();
57849:       }
57849:       mDocWriteSpeculativeTokenizer->resetToDataState();
57849:       mDocWriteSpeculativeTreeBuilder->loadState(mTreeBuilder, &mAtomTable);
80486:       mDocWriteSpeculativeLastWasCR = false;
57849:     }
57849: 
57849:     // Note that with multilevel document.write if we didn't just activate the
57849:     // speculator, it's possible that the speculator is now in the wrong state.
57849:     // That's OK for the sake of simplicity. The worst that can happen is
57849:     // that the speculative loads aren't exactly right. The content will be
57849:     // reparsed anyway for non-preload purposes.
57849: 
80404:     // The buffer position for subsequent non-speculative parsing now lives
80404:     // in heapBuffer, so it's ok to let the buffer position of stackBuffer
80404:     // to be overwritten and not restored below.
80404:     while (stackBuffer.hasMore()) {
80404:       stackBuffer.adjust(mDocWriteSpeculativeLastWasCR);
80404:       if (stackBuffer.hasMore()) {
57849:         mDocWriteSpeculativeLastWasCR =
80404:             mDocWriteSpeculativeTokenizer->tokenizeBuffer(&stackBuffer);
57849:       }
57849:     }
57849: 
57849:     mDocWriteSpeculativeTreeBuilder->Flush();
57849:     mDocWriteSpeculativeTreeBuilder->DropHandles();
57849:     mExecutor->FlushSpeculativeLoads();
29805:   }
29805: 
29805:   return NS_OK;
29805: }
29805: 
29805: /**
29805:  * This magic value is passed to the previous method on document.close()
29805:  */
29805: NS_IMETHODIMP_(void *)
29805: nsHtml5Parser::GetRootContextKey()
29805: {
29805:   return mRootContextKey;
29805: }
29805: 
29805: NS_IMETHODIMP
40983: nsHtml5Parser::Terminate()
29805: {
29805:   // We should only call DidBuildModel once, so don't do anything if this is
29805:   // the second time that Terminate has been called.
34981:   if (mExecutor->IsComplete()) {
29805:     return NS_OK;
29805:   }
29805:   // XXX - [ until we figure out a way to break parser-sink circularity ]
29805:   // Hack - Hold a reference until we are completely done...
29805:   nsCOMPtr<nsIParser> kungFuDeathGrip(this);
32917:   nsRefPtr<nsHtml5StreamParser> streamKungFuDeathGrip(mStreamParser);
32917:   nsRefPtr<nsHtml5TreeOpExecutor> treeOpKungFuDeathGrip(mExecutor);
34979:   if (mStreamParser) {
34979:     mStreamParser->Terminate();
34979:   }
80486:   return mExecutor->DidBuildModel(true);
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::ParseFragment(const nsAString& aSourceBuffer,
74622:                              nsTArray<nsString>& aTagStack)
57561: {
57561:   return NS_ERROR_NOT_IMPLEMENTED;
57561: }
57561: 
76287: nsresult
57561: nsHtml5Parser::ParseHtml5Fragment(const nsAString& aSourceBuffer,
57561:                                   nsIContent* aTargetNode,
57561:                                   nsIAtom* aContextLocalName,
57561:                                   PRInt32 aContextNamespace,
79445:                                   bool aQuirks,
79445:                                   bool aPreventScriptExecution)
29805: {
80404:   NS_ENSURE_TRUE(aSourceBuffer.Length() <= PR_INT32_MAX,
80404:       NS_ERROR_OUT_OF_MEMORY);
80526:   nsIDocument* doc = aTargetNode->OwnerDoc();
30333:   
30333:   nsIURI* uri = doc->GetDocumentURI();
30333:   NS_ENSURE_TRUE(uri, NS_ERROR_NOT_AVAILABLE);
30333: 
69291:   mExecutor->EnableFragmentMode(aPreventScriptExecution);
69291: 
40983:   Initialize(doc, uri, nsnull, nsnull);
30333: 
32917:   mExecutor->SetParser(this);
40983:   mExecutor->SetNodeInfoManager(doc->NodeInfoManager());
30333: 
48066:   nsIContent* target = aTargetNode;
40983:   mTreeBuilder->setFragmentContext(aContextLocalName,
40983:                                    aContextNamespace,
48066:                                    &target,
40983:                                    aQuirks);
57328: 
57328: #ifdef DEBUG
57328:   if (!aPreventScriptExecution) {
74622:     NS_ASSERTION(!aTargetNode->IsInDoc(),
74622:         "If script execution isn't prevented, "
74622:         "the target node must not be in doc.");
57328:     nsCOMPtr<nsIDOMDocumentFragment> domFrag = do_QueryInterface(aTargetNode);
57328:     NS_ASSERTION(domFrag,
57328:         "If script execution isn't prevented, must parse to DOM fragment.");
57328:   }
57328: #endif
57328: 
40983:   NS_PRECONDITION(!mExecutor->HasStarted(),
40983:                   "Tried to start parse without initializing the parser.");
32917:   mTreeBuilder->setScriptingEnabled(mExecutor->IsScriptEnabled());
29805:   mTokenizer->start();
34979:   mExecutor->Start(); // Don't call WillBuildModel in fragment case
29805:   if (!aSourceBuffer.IsEmpty()) {
79445:     bool lastWasCR = false;
80404:     nsHtml5DependentUTF16Buffer buffer(aSourceBuffer);    
29805:     while (buffer.hasMore()) {
29805:       buffer.adjust(lastWasCR);
80486:       lastWasCR = false;
29805:       if (buffer.hasMore()) {
29805:         lastWasCR = mTokenizer->tokenizeBuffer(&buffer);
67568:         if (mTreeBuilder->HasScript()) {
67568:           // Flush on each script, because the execution prevention code
67568:           // can handle at most one script per flush.
67568:           mTreeBuilder->Flush(); // Move ops to the executor
67568:           mExecutor->FlushDocumentWrite(); // run the ops
67568:         }
29805:       }
29805:     }
29805:   }
29805:   mTokenizer->eof();
34979:   mTreeBuilder->StreamEnded();
34979:   mTreeBuilder->Flush();
39737:   mExecutor->FlushDocumentWrite();
29805:   mTokenizer->end();
32917:   mExecutor->DropParserAndPerfHint();
41067:   mExecutor->DropHeldElements();
57848:   mTreeBuilder->DropHandles();
34979:   mAtomTable.Clear();
29805:   return NS_OK;
29805: }
29805: 
29805: NS_IMETHODIMP
40983: nsHtml5Parser::BuildModel()
29805: {
34979:   NS_NOTREACHED("Don't call this!");
34979:   return NS_ERROR_NOT_IMPLEMENTED;
29805: }
29805: 
29805: NS_IMETHODIMP
29805: nsHtml5Parser::CancelParsingEvents()
29805: {
35293:   NS_NOTREACHED("Don't call this!");
35293:   return NS_ERROR_NOT_IMPLEMENTED;
29805: }
29805: 
29805: void
29805: nsHtml5Parser::Reset()
29805: {
57849:   NS_PRECONDITION(mExecutor->IsFragmentMode(),
57849:                   "Reset called on a non-fragment parser.");
32917:   mExecutor->Reset();
80486:   mLastWasCR = false;
32917:   UnblockParser();
80486:   mDocumentClosed = false;
32917:   mStreamParser = nsnull;
35294:   mRootContextLineNumber = 1;
34983:   mParserInsertedScriptsBeingEvaluated = 0;
29805:   mRootContextKey = nsnull;
34979:   mAtomTable.Clear(); // should be already cleared in the fragment case anyway
29805:   // Portable parser objects
34981:   mFirstBuffer->next = nsnull;
29805:   mFirstBuffer->setStart(0);
29805:   mFirstBuffer->setEnd(0);
55148:   mLastBuffer = mFirstBuffer;
29805: }
29805: 
79445: bool
29805: nsHtml5Parser::CanInterrupt()
29805: {
40983:   // nsContentSink needs this to let nsContentSink::DidProcessATokenImpl
40983:   // interrupt.
80486:   return true;
29805: }
29805: 
79445: bool
34983: nsHtml5Parser::IsInsertionPointDefined()
34983: {
34983:   return !mExecutor->IsFlushing() &&
34983:     (!mStreamParser || mParserInsertedScriptsBeingEvaluated);
34983: }
34983: 
34983: void
34983: nsHtml5Parser::BeginEvaluatingParserInsertedScript()
34983: {
34983:   ++mParserInsertedScriptsBeingEvaluated;
34983: }
34983: 
34983: void
34983: nsHtml5Parser::EndEvaluatingParserInsertedScript()
34983: {
34983:   --mParserInsertedScriptsBeingEvaluated;
34983: }
34983: 
34983: void
34983: nsHtml5Parser::MarkAsNotScriptCreated()
34983: {
34983:   NS_PRECONDITION(!mStreamParser, "Must not call this twice.");
34983:   mStreamParser = new nsHtml5StreamParser(mExecutor, this);
34983: }
34983: 
79445: bool
34983: nsHtml5Parser::IsScriptCreated()
34983: {
34983:   return !mStreamParser;
34983: }
34983: 
29805: /* End nsIParser  */
29805: 
29805: // not from interface
29805: void
34992: nsHtml5Parser::ParseUntilBlocked()
29805: {
40983:   NS_PRECONDITION(!mExecutor->IsFragmentMode(),
40983:                   "ParseUntilBlocked called in fragment mode.");
29805: 
81105:   if (mBlocked || mExecutor->IsComplete() || mExecutor->IsBroken()) {
29805:     return;
29805:   }
34981:   NS_ASSERTION(mExecutor->HasStarted(), "Bad life cycle.");
81105:   NS_ASSERTION(!mInDocumentWrite,
81105:     "ParseUntilBlocked entered while in doc.write!");
29805: 
80486:   mDocWriteSpeculatorActive = false;
57849: 
29805:   for (;;) {
29805:     if (!mFirstBuffer->hasMore()) {
29805:       if (mFirstBuffer == mLastBuffer) {
34981:         if (mExecutor->IsComplete()) {
29805:           // something like cache manisfests stopped the parse in mid-flight
29805:           return;
34981:         }
34979:         if (mDocumentClosed) {
34979:           NS_ASSERTION(!mStreamParser,
34979:                        "This should only happen with script-created parser.");
34979:           mTokenizer->eof();
34979:           mTreeBuilder->StreamEnded();
34979:           mTreeBuilder->Flush();
39737:           mExecutor->FlushDocumentWrite();
34979:           mTokenizer->end();
34979:           return;            
40983:         }
34981:         // never release the last buffer.
40983:         NS_ASSERTION(!mLastBuffer->getStart() && !mLastBuffer->getEnd(),
34981:                      "Sentinel buffer had its indeces changed.");
57562:         if (mStreamParser) {
57562:           if (mReturnToStreamParserPermitted &&
57562:               !mExecutor->IsScriptExecuting()) {
35295:             mTreeBuilder->Flush();
80486:             mReturnToStreamParserPermitted = false;
34979:             mStreamParser->ContinueAfterScripts(mTokenizer,
34979:                                                 mTreeBuilder,
34979:                                                 mLastWasCR);
32917:           }
57562:         } else {
57562:           // Script-created parser
57562:           mTreeBuilder->Flush();
57562:           // No need to flush the executor, because the executor is already
57562:           // in a flush
57562:           NS_ASSERTION(mExecutor->IsInFlushLoop(),
57562:               "How did we come here without being in the flush loop?");
57562:         }
29805:         return; // no more data for now but expecting more
29805:       }
29805:       mFirstBuffer = mFirstBuffer->next;
29805:       continue;
29805:     }
29805: 
34981:     if (mBlocked || mExecutor->IsComplete()) {
29805:       return;
29805:     }
29805: 
29805:     // now we have a non-empty buffer
29805:     mFirstBuffer->adjust(mLastWasCR);
80486:     mLastWasCR = false;
29805:     if (mFirstBuffer->hasMore()) {
79445:       bool inRootContext = (!mStreamParser &&
40983:                               (mFirstBuffer->key == mRootContextKey));
35294:       if (inRootContext) {
35294:         mTokenizer->setLineNumber(mRootContextLineNumber);
35294:       }
29805:       mLastWasCR = mTokenizer->tokenizeBuffer(mFirstBuffer);
35294:       if (inRootContext) {
35294:         mRootContextLineNumber = mTokenizer->getLineNumber();
35294:       }
34979:       if (mTreeBuilder->HasScript()) {
34979:         mTreeBuilder->Flush();
39737:         mExecutor->FlushDocumentWrite();
34979:       }
29805:       if (mBlocked) {
29805:         return;
29805:       }
30334:     }
29805:     continue;
29805:   }
29805: }
29805: 
29805: nsresult
29805: nsHtml5Parser::Initialize(nsIDocument* aDoc,
29805:                           nsIURI* aURI,
29805:                           nsISupports* aContainer,
29805:                           nsIChannel* aChannel)
29805: {
32917:   return mExecutor->Init(aDoc, aURI, aContainer, aChannel);
29805: }
29805: 
34979: void
79445: nsHtml5Parser::StartTokenizer(bool aScriptingEnabled) {
34979:   mTreeBuilder->setScriptingEnabled(aScriptingEnabled);
34979:   mTokenizer->start();
34979: }
34979: 
34979: void
40983: nsHtml5Parser::InitializeDocWriteParserState(nsAHtml5TreeBuilderState* aState,
40983:                                              PRInt32 aLine)
34979: {
34979:   mTokenizer->resetToDataState();
35294:   mTokenizer->setLineNumber(aLine);
34979:   mTreeBuilder->loadState(aState, &mAtomTable);
80486:   mLastWasCR = false;
80486:   mReturnToStreamParserPermitted = true;
34979: }
34986: 
34986: void
34986: nsHtml5Parser::ContinueAfterFailedCharsetSwitch()
34986: {
34986:   NS_PRECONDITION(mStreamParser, 
34986:     "Tried to continue after failed charset switch without a stream parser");
34986:   mStreamParser->ContinueAfterFailedCharsetSwitch();
34986: }
