    1: <?xml version="1.0"?>
    1: 
    1: <!DOCTYPE bindings SYSTEM "chrome://global/locale/preferences.dtd">
    1: 
    1: <bindings id="preferencesBindings"
    1:           xmlns="http://www.mozilla.org/xbl"
    1:           xmlns:xbl="http://www.mozilla.org/xbl"
    1:           xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
    1: 
    1: #
    1: # = Preferences Window Framework
    1: #
    1: #   The syntax for use looks something like:
    1: #
    1: #   <prefwindow>
    1: #     <prefpane id="prefPaneA">
    1: #       <preferences>
    1: #         <preference id="preference1" name="app.preference1" type="bool" onchange="foo();"/>
    1: #         <preference id="preference2" name="app.preference2" type="bool" useDefault="true"/>
    1: #       </preferences>
    1: #       <checkbox label="Preference" preference="preference1"/>
    1: #     </prefpane>
    1: #   </prefwindow>
    1: #
    1: 
    1:   <binding id="preferences">
    1:     <implementation implements="nsIObserver">
    1:       <method name="observe">
    1:         <parameter name="aSubject"/>
    1:         <parameter name="aTopic"/>
    1:         <parameter name="aData"/>
    1:         <body>
    1:         <![CDATA[
    1:           for (var i = 0; i < this.childNodes.length; ++i) {
    1:             var preference = this.childNodes[i];
    1:             if (preference.name == aData) {
    1:               preference.value = preference.valueFromPreferences;
    1:             }
    1:           }
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="fireChangedEvent">
    1:         <parameter name="aPreference"/>
    1:         <body>
    1:         <![CDATA[
    1:           // Value changed, synthesize an event
    1:           try {
    1:             var event = document.createEvent("Events");
    1:             event.initEvent("change", true, true);
    1:             aPreference.dispatchEvent(event);
    1:           }
    1:           catch (e) {
 6230:             Components.utils.reportError(e);
    1:           }
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <field name="service">
    1:         Components.classes["@mozilla.org/preferences-service;1"]
    1:                   .getService(Components.interfaces.nsIPrefService);
    1:       </field>
    1:       <field name="rootBranch">
    1:         Components.classes["@mozilla.org/preferences-service;1"]
    1:                   .getService(Components.interfaces.nsIPrefBranch);
    1:       </field>
    1:       <field name="defaultBranch">
    1:         this.service.getDefaultBranch("");
    1:       </field>
    1:       <field name="rootBranchInternal">
    1:         Components.classes["@mozilla.org/preferences-service;1"]
    1:                   .getService(Components.interfaces.nsIPrefBranchInternal);
    1:       </field>
20231:       <property name="type" readonly="true">
20231:         <getter>
20231:           <![CDATA[
20231:             var doc = document.documentElement;
20231:             return doc.type || "";
20231:           ]]>
20231:         </getter>
20231:       </property>
20231:       <property name="instantApply" readonly="true">
20231:         <getter>
20231:           <![CDATA[
20231:             var doc = document.documentElement;
20231:             return doc.instantApply || this.rootBranch.getBoolPref("browser.preferences.instantApply");
20231:           ]]>
20231:         </getter>
20231:       </property>
    1:     </implementation>
    1:   </binding>
    1: 
    1:   <binding id="preference">
    1:     <implementation>
    1:       <constructor>
    1:       <![CDATA[
10346:         // if the element has been inserted without the name attribute set,
10346:         // we have nothing to do here
10346:         if (!this.name)
10346:           return;
10346: 
    1:         this.preferences.rootBranchInternal
    1:             .addObserver(this.name, this.preferences, false);
    1:         // In non-instant apply mode, we must try and use the last saved state
    1:         // from any previous opens of a child dialog instead of the value from
    1:         // preferences, to pick up any edits a user may have made. 
20231:         if (this.preferences.type == "child" && 
    1:             !this.instantApply && window.opener) {
    1:           var pdoc = window.opener.document;
    1: 
    1:           // Try to find a preference element for the same preference.
    1:           var preference = null;
    1:           var parentPreferences = pdoc.getElementsByTagName("preferences");
    1:           for (var k = 0; (k < parentPreferences.length && !preference); ++k) {
    1:             var parentPrefs = parentPreferences[k]
    1:                                     .getElementsByAttribute("name", this.name);
    1:             for (var l = 0; (l < parentPrefs.length && !preference); ++l) {
    1:               if (parentPrefs[l].localName == "preference")
    1:                 preference = parentPrefs[l];
    1:             }
    1:           }
    1:           this._setValue(preference ? preference.value 
    1:                                     : this.valueFromPreferences, false);
    1:         }
    1:         else
    1:           this._setValue(this.valueFromPreferences, false);
    1:       ]]>
    1:       </constructor>
    1:       <destructor>
    1:         this.preferences.rootBranchInternal
    1:             .removeObserver(this.name, this.preferences);
    1:       </destructor>
    1:       
    1:       <property name="instantApply">
    1:         <getter>
20231:           return this.getAttribute("instantApply") == "true" || this.preferences.instantApply;
    1:         </getter>
    1:       </property>
    1: 
    1:       <property name="preferences" onget="return this.parentNode"/>
    1:       <property name="name" onget="return this.getAttribute('name');">
    1:         <setter>
    1:           if (val == this.name)
    1:             return val;
    1:             
    1:           this.preferences.rootBranchInternal
    1:               .removeObserver(this.name, this.preferences);
    1:           this.setAttribute('name', val);
    1:           this.preferences.rootBranchInternal
    1:               .addObserver(val, this.preferences, false);
    1:               
    1:           return val;
    1:         </setter>
    1:       </property>
    1:       <property name="type" onget="return this.getAttribute('type');"
    1:                             onset="this.setAttribute('type', val); return val;"/>
    1:       <property name="inverted" onget="return this.getAttribute('inverted') == 'true';"
    1:                                 onset="this.setAttribute('inverted', val); return val;"/>
    1:       <property name="readonly" onget="return this.getAttribute('readonly') == 'true';"
    1:                                 onset="this.setAttribute('readonly', val); return val;"/>
    1: 
    1:       <field name="_value">null</field>
    1:       <method name="_setValue">
    1:         <parameter name="aValue"/>
    1:         <parameter name="aUpdate"/>
    1:         <body>
    1:         <![CDATA[
19324:           if (aUpdate && this.value !== aValue) {
    1:             this._value = aValue;
    1:             if (this.instantApply)
    1:               this.valueFromPreferences = aValue;
    1:             this.preferences.fireChangedEvent(this);
    1:           }
    1:           else if (!aUpdate) {
    1:             this._value = aValue;
    1:             this.updateElements();
    1:           }
    1:           return aValue;
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       <property name="value" onget="return this._value" onset="return this._setValue(val, true);"/>
    1:       
    1:       <property name="locked">
    1:         <getter>
    1:           return this.preferences.rootBranch.prefIsLocked(this.name);
    1:         </getter>
    1:       </property>
    1:       
    1:       <property name="disabled">
    1:         <getter>
    1:           return this.getAttribute("disabled") == "true";
    1:         </getter>
    1:         <setter>
    1:         <![CDATA[
    1:           if (val) 
    1:             this.setAttribute("disabled", "true");
    1:           else
    1:             this.removeAttribute("disabled");
    1: 
    1:           if (!this.id)
    1:             return val;
    1: 
    1:           var elements = document.getElementsByAttribute("preference", this.id);
    1:           for (var i = 0; i < elements.length; ++i) {
    1:             elements[i].disabled = val;
    1:             
    1:             var labels = document.getElementsByAttribute("control", elements[i].id);
    1:             for (var j = 0; j < labels.length; ++j)
    1:               labels[j].disabled = val;
    1:           }
    1:             
    1:           return val;
    1:         ]]>
    1:         </setter>
    1:       </property>
    1:       
    1:       <property name="tabIndex">
    1:         <getter>
    1:           return parseInt(this.getAttribute("tabindex"));
    1:         </getter>
    1:         <setter>
    1:         <![CDATA[
    1:           if (val) 
    1:             this.setAttribute("tabindex", val);
    1:           else
    1:             this.removeAttribute("tabindex");
    1: 
    1:           if (!this.id)
    1:             return val;
    1: 
    1:           var elements = document.getElementsByAttribute("preference", this.id);
    1:           for (var i = 0; i < elements.length; ++i) {
    1:             elements[i].tabIndex = val;
    1:             
    1:             var labels = document.getElementsByAttribute("control", elements[i].id);
    1:             for (var j = 0; j < labels.length; ++j)
    1:               labels[j].tabIndex = val;
    1:           }
    1:             
    1:           return val;
    1:         ]]>
    1:         </setter>
    1:       </property>
    1: 
    1:       <property name="hasUserValue">
    1:         <getter>
19324:         <![CDATA[
19324:           return this.preferences.rootBranch.prefHasUserValue(this.name) &&
19324:                  this.value !== undefined;
19324:         ]]>
    1:         </getter>
    1:       </property>
    1:       
    1:       <method name="reset">
    1:         <body>
14698:           // defer reset until preference update
14698:           this.value = undefined;
    1:         </body>
    1:       </method>
    1: 
    1:       <field name="_useDefault">false</field>      
    1:       <property name="defaultValue">
    1:         <getter>
    1:         <![CDATA[
    1:           this._useDefault = true;
    1:           var val = this.valueFromPreferences;
    1:           this._useDefault = false;
    1:           return val;
    1:         ]]>
    1:         </getter>
    1:       </property>
    1:       
    1:       <property name="_branch">
    1:         <getter>
    1:           return this._useDefault ? this.preferences.defaultBranch : this.preferences.rootBranch;
    1:         </getter>
    1:       </property>
    1:       
    1:       <field name="batching">false</field>
    1:       
    1:       <method name="_reportUnknownType">
    1:         <body>
    1:         <![CDATA[
    1:           var consoleService = Components.classes["@mozilla.org/consoleservice;1"]
    1:                                          .getService(Components.interfaces.nsIConsoleService);
    1:           var msg = "<preference> with id='" + this.id + "' and name='" + 
    1:                     this.name + "' has unknown type '" + this.type + "'.";
    1:           consoleService.logStringMessage(msg);
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <property name="valueFromPreferences">
    1:         <getter>
    1:         <![CDATA[
    1:           try {
    1:             // Force a resync of value with preferences.
    1:             switch (this.type) {
    1:             case "int":
    1:               return this._branch.getIntPref(this.name);
    1:             case "bool":
    1:               var val = this._branch.getBoolPref(this.name);
    1:               return this.inverted ? !val : val;
    1:             case "wstring":
    1:               return this._branch
    1:                          .getComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString)
    1:                          .data;
    1:             case "string":
    1:             case "unichar":
    1:               return this._branch
    1:                          .getComplexValue(this.name, Components.interfaces.nsISupportsString)
    1:                          .data;
13003:             case "fontname":
13003:               var family = this._branch
13003:                                .getComplexValue(this.name, Components.interfaces.nsISupportsString)
13003:                                .data;
13242:               var fontEnumerator = Components.classes["@mozilla.org/gfx/fontenumerator;1"]
13242:                                              .createInstance(Components.interfaces.nsIFontEnumerator);
13242:               return fontEnumerator.getStandardFamilyName(family);
    1:             case "file":
    1:               var f = this._branch
    1:                           .getComplexValue(this.name, Components.interfaces.nsILocalFile);
    1:               return f;
    1:             default:
    1:               this._reportUnknownType();
    1:             }
    1:           }
    1:           catch (e) { }
    1:           return null;
    1:         ]]>
    1:         </getter>
    1:         <setter>
    1:         <![CDATA[
14698:           // Exit early if nothing to do.
    1:           if (this.readonly || this.valueFromPreferences == val)
    1:             return val;
    1: 
14698:           // The special value undefined means 'reset preference to default'.
14698:           if (val === undefined) {
14698:             this.preferences.rootBranch.clearUserPref(this.name);
14698:             return val;
14698:           }
14698: 
    1:           // Force a resync of preferences with value.
    1:           switch (this.type) {
    1:           case "int":
    1:             this.preferences.rootBranch.setIntPref(this.name, val);
    1:             break;
    1:           case "bool":
    1:             this.preferences.rootBranch.setBoolPref(this.name, this.inverted ? !val : val);
    1:             break;
    1:           case "wstring":
    1:             var pls = Components.classes["@mozilla.org/pref-localizedstring;1"]
    1:                                 .createInstance(Components.interfaces.nsIPrefLocalizedString);
    1:             pls.data = val;
    1:             this.preferences.rootBranch
    1:                 .setComplexValue(this.name, Components.interfaces.nsIPrefLocalizedString, pls);
    1:             break;
    1:           case "string":
    1:           case "unichar":
13003:           case "fontname":
    1:             var iss = Components.classes["@mozilla.org/supports-string;1"]
    1:                                 .createInstance(Components.interfaces.nsISupportsString);
    1:             iss.data = val;
    1:             this.preferences.rootBranch
    1:                 .setComplexValue(this.name, Components.interfaces.nsISupportsString, iss);
    1:             break;
    1:           case "file":
    1:             var lf;
    1:             if (typeof(val) == "string") {
    1:               lf = Components.classes["@mozilla.org/file/local;1"]
    1:                              .createInstance(Components.interfaces.nsILocalFile);
    1:               lf.persistentDescriptor = val;
    1:               if (!lf.exists())
    1:                 lf.initWithPath(val);
    1:             }
    1:             else 
    1:               lf = val.QueryInterface(Components.interfaces.nsILocalFile);
    1:             this.preferences.rootBranch
    1:                 .setComplexValue(this.name, Components.interfaces.nsILocalFile, lf);
    1:             break;
    1:           default:
    1:             this._reportUnknownType();
    1:           }
    1:           if (!this.batching)
    1:             this.preferences.service.savePrefFile(null);
    1:           return val;
    1:         ]]>
    1:         </setter>
    1:       </property>
    1:       
    1:       <method name="setElementValue">
    1:         <parameter name="aElement"/>
    1:         <body>
    1:         <![CDATA[
    1:           if (this.locked)
    1:             aElement.disabled = true;
    1: 
    1:           if (!this.isElementEditable(aElement))
    1:             return;
    1: 
    1:           var rv = undefined;
    1:           if (aElement.hasAttribute("onsyncfrompreference")) {
    1:             // Value changed, synthesize an event
    1:             try {
    1:               var event = document.createEvent("Events");
    1:               event.initEvent("syncfrompreference", true, true);
    1:               var f = new Function ("event", 
    1:                                     aElement.getAttribute("onsyncfrompreference"));
10290:               rv = f.call(aElement, event);
    1:             }
    1:             catch (e) {
 6230:               Components.utils.reportError(e);
    1:             }
    1:           }
    1:           var val = rv !== undefined ? rv : (this.instantApply ? this.valueFromPreferences : this.value);
14698:           // if the preference is marked for reset, show default value in UI
14698:           if (val === undefined)
14698:             val = this.defaultValue;
    1: 
    1:           /**
    1:            * Initialize a UI element property with a value. Handles the case 
    1:            * where an element has not yet had a XBL binding attached for it and
    1:            * the property setter does not yet exist by setting the same attribute
    1:            * on the XUL element using DOM apis and assuming the element's 
    1:            * constructor or property getters appropriately handle this state. 
    1:            */
    1:           function setValue(element, attribute, value) {
    1:             if (attribute in element) 
    1:               element[attribute] = value;
    1:             else
    1:               element.setAttribute(attribute, value);
    1:           }
12621:           if (aElement.localName == "checkbox" ||
12621:               aElement.localName == "listitem")
    1:             setValue(aElement, "checked", val);
    1:           else if (aElement.localName == "colorpicker")
    1:             setValue(aElement, "color", val);
    1:           else if (aElement.localName == "textbox") {
    1:             // XXXmano Bug 303998: Avoid a caret placement issue if either the
    1:             // preference observer or its setter calls updateElements as a result
    1:             // of the input event handler.
    1:             if (aElement.value !== val)
    1:               setValue(aElement, "value", val);
    1:           }
    1:           else
    1:             setValue(aElement, "value", val);
    1:         ]]>
    1:         </body>
    1:       </method>
    1: 
    1:       <method name="getElementValue">
    1:         <parameter name="aElement"/>
    1:         <body>
    1:         <![CDATA[
    1:           if (aElement.hasAttribute("onsynctopreference")) {
    1:             // Value changed, synthesize an event
    1:             try {
    1:               var event = document.createEvent("Events");
    1:               event.initEvent("synctopreference", true, true);
    1:               var f = new Function ("event", 
    1:                                     aElement.getAttribute("onsynctopreference"));
10290:               var rv = f.call(aElement, event);
    1:               if (rv !== undefined) 
    1:                 return rv;
    1:             }
    1:             catch (e) {
 6230:               Components.utils.reportError(e);
    1:             }
    1:           }
    1:           
    1:           /**
    1:            * Read the value of an attribute from an element, assuming the 
    1:            * attribute is a property on the element's node API. If the property
    1:            * is not present in the API, then assume its value is contained in
    1:            * an attribute, as is the case before a binding has been attached.
    1:            */
    1:           function getValue(element, attribute) {
    1:             if (attribute in element)
    1:               return element[attribute];
    1:             return element.getAttribute(attribute);
    1:           }
12621:           if (aElement.localName == "checkbox" ||
12621:               aElement.localName == "listitem")
    1:             var value = getValue(aElement, "checked");
    1:           else if (aElement.localName == "colorpicker")
    1:             value = getValue(aElement, "color");
    1:           else
    1:             value = getValue(aElement, "value");
    1: 
    1:           switch (this.type) {
    1:           case "int":
16325:             return parseInt(value, 10) || 0;
    1:           case "bool":
    1:             return typeof(value) == "boolean" ? value : value == "true";
    1:           }
    1:           return value;
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="isElementEditable">
    1:         <parameter name="aElement"/>
    1:         <body>
    1:         <![CDATA[
    1:           switch (aElement.localName) {
    1:           case "checkbox":
    1:           case "colorpicker":
    1:           case "radiogroup":
    1:           case "textbox":
    1:           case "listitem":
    1:           case "listbox":
    1:           case "menulist":
    1:             return true;
    1:           }
    1:           return aElement.getAttribute("preference-editable") == "true";
    1:         ]]> 
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="updateElements">
    1:         <body>
    1:         <![CDATA[
    1:           if (!this.id)
    1:             return;
    1: 
    1:           // This "change" event handler tracks changes made to preferences by 
    1:           // sources other than the user in this window. 
    1:           var elements = document.getElementsByAttribute("preference", this.id);
    1:           for (var i = 0; i < elements.length; ++i) 
    1:             this.setElementValue(elements[i]);
    1:         ]]>
    1:         </body>
    1:       </method>
    1:     </implementation>
    1:     
    1:     <handlers>
    1:       <handler event="change">
    1:         this.updateElements();
    1:       </handler>
    1:     </handlers>
    1:   </binding>
    1: 
    1:   <binding id="prefwindow"
    1:            extends="chrome://global/content/bindings/dialog.xml#dialog">
    1:     <resources>
    1:       <stylesheet src="chrome://global/skin/preferences.css"/>
    1:     </resources>
    1:     <content dlgbuttons="accept,cancel" persist="lastSelected screenX screenY"
    1:              closebuttonlabel="&preferencesCloseButton.label;"
    1:              closebuttonaccesskey="&preferencesCloseButton.accesskey;"
 8937:              role="dialog"
    1: #ifdef XP_WIN
    1:              title="&preferencesDefaultTitleWin.title;">
    1: #else
    1:              title="&preferencesDefaultTitleMac.title;">
    1: #endif
    1:       <xul:radiogroup anonid="selector" orient="horizontal" class="paneSelector chromeclass-toolbar"
 8937:                       role="listbox"/> <!-- Expose to accessibility APIs as a listbox -->
    1:       <xul:hbox flex="1" class="paneDeckContainer">
    1:         <xul:deck anonid="paneDeck" flex="1">
    1:           <children includes="prefpane"/>
    1:         </xul:deck>
    1:       </xul:hbox>
    1:       <xul:hbox anonid="dlg-buttons" class="prefWindow-dlgbuttons"
    1: #ifdef XP_UNIX
    1:                 >
    1:         <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
    1:         <xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
    1:         <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
    1:         <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
    1:         <xul:spacer anonid="spacer" flex="1"/>
    1:         <xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
    1:         <xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
    1: #else
    1:                 pack="end">
    1:         <xul:button dlgtype="extra2" class="dialog-button" hidden="true"/>
    1:         <xul:spacer anonid="spacer" flex="1"/>
    1:         <xul:button dlgtype="accept" class="dialog-button" icon="accept"/>
    1:         <xul:button dlgtype="extra1" class="dialog-button" hidden="true"/>
    1:         <xul:button dlgtype="cancel" class="dialog-button" icon="cancel"/>
    1:         <xul:button dlgtype="help" class="dialog-button" hidden="true" icon="help"/>
    1:         <xul:button dlgtype="disclosure" class="dialog-button" hidden="true"/>
    1: #endif
    1:       </xul:hbox>
    1:       <xul:hbox>
    1:         <children/>
    1:       </xul:hbox>
    1:     </content>
    1:     <implementation implements="nsITimerCallback">
    1:       <constructor>
    1:       <![CDATA[
    1:         if (this.type != "child") {
    1:           var psvc = Components.classes["@mozilla.org/preferences-service;1"]
    1:                                .getService(Components.interfaces.nsIPrefBranch);
    1:           this.instantApply = psvc.getBoolPref("browser.preferences.instantApply");
    1:           if (this.instantApply) {
    1:             var docElt = document.documentElement;
    1:             var acceptButton = docElt.getButton("accept");
    1:             acceptButton.hidden = true;
    1:             var cancelButton  = docElt.getButton("cancel");
    1: #ifdef XP_MACOSX
    1:             // no buttons on Mac except Help
    1:             cancelButton.hidden = true;
    1:             // Also, don't fire onDialogAccept on enter
    1:             acceptButton.disabled = true;
    1: #else
    1:             // morph the Cancel button into the Close button
    1:             cancelButton.setAttribute ("icon", "close");
    1:             cancelButton.label = docElt.getAttribute("closebuttonlabel");
    1:             cancelButton.accesskey = docElt.getAttribute("closebuttonaccesskey");
    1: #endif
    1:           }
    1:         }
 6216:         this.setAttribute("animated", this._shouldAnimate ? "true" : "false");
    1:         var panes = this.preferencePanes;
    1: 
    1:         var lastPane = null;
    1:         if (this.lastSelected) {
    1:           lastPane = document.getElementById(this.lastSelected);
    1:           if (!lastPane) {
    1:             this.lastSelected = null;
    1:           }
    1:         }
    1: 
    1:         var paneToLoad;
    1:         if ("arguments" in window && window.arguments[0] && document.getElementById(window.arguments[0]) && document.getElementById(window.arguments[0]).nodeName == "prefpane") {
    1:           paneToLoad = document.getElementById(window.arguments[0]);
    1:           this.lastSelected = paneToLoad.id;
    1:         }
    1:         else if (lastPane)
    1:           paneToLoad = lastPane;
    1:         else
    1:           paneToLoad = panes[0];
    1: 
    1:         for (var i = 0; i < panes.length; ++i) {
    1:           this._makePaneButton(panes[i]);
    1:           if (panes[i].loaded) {
    1:             // Inline pane content, fire load event to force initialization.
    1:             this._fireEvent("paneload", panes[i]);
    1:           }
    1:         }
    1:         this.showPane(paneToLoad);
    1: 
    1:         if (panes.length == 1)
    1:           this._selector.setAttribute("collapsed", "true");
    1:       ]]>
    1:       </constructor>
    1: 
    1:       <destructor>
    1:       <![CDATA[
    1:         // Release timers to avoid reference cycles.
    1:         if (this._animateTimer) {
    1:           this._animateTimer.cancel();
    1:           this._animateTimer = null;
    1:         }
    1:         if (this._fadeTimer) {
    1:           this._fadeTimer.cancel();
    1:           this._fadeTimer = null;
    1:         }
    1:       ]]>
    1:       </destructor>
    1: 
    1:       <field name="instantApply">false</field>
    1:       
    1:       <property name="preferencePanes"
    1:                 onget="return this.getElementsByTagName('prefpane');"/>
    1: 
    1:       <property name="type" onget="return this.getAttribute('type');"/>
    1:       <property name="_paneDeck"
    1:                 onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'paneDeck');"/>
 5571:       <property name="_paneDeckContainer"
 5571:                 onget="return document.getAnonymousElementByAttribute(this, 'class', 'paneDeckContainer');"/>
    1:       <property name="_selector"
    1:                 onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'selector');"/>
    1:       <property name="lastSelected" 
    1:                 onget="return this.getAttribute('lastSelected');">
    1:         <setter>
    1:           this.setAttribute("lastSelected", val); 
    1:           document.persist(this.id, "lastSelected");
    1:           return val;
    1:         </setter>          
    1:       </property>
13505:       <property name="currentPane"
13505:                 onset="return this._currentPane = val;">
13505:         <getter>
13505:           if (!this._currentPane)
13505:             this._currentPane = this.preferencePanes[0];
13505:           
13505:           return this._currentPane;
13505:         </getter> 
13505:       </property>
13505:       <field name="_currentPane">null</field>
13505:       
    1:       
    1:       <method name="_makePaneButton">
    1:         <parameter name="aPaneElement"/>
    1:         <body>
    1:         <![CDATA[
    1:           var radio = document.createElement("radio");
    1:           radio.setAttribute("pane", aPaneElement.id);
    1:           radio.setAttribute("label", aPaneElement.label);
    1:           // Expose preference group choice to accessibility APIs as an unchecked list item
    1:           // The parent group is exposed to accessibility APIs as a list
    1:           if (aPaneElement.image)
    1:             radio.setAttribute("src", aPaneElement.image);
    1:           radio.style.listStyleImage = aPaneElement.style.listStyleImage;
    1:           this._selector.appendChild(radio);
    1:           return radio;
    1:         ]]>
    1:         </body>
    1:       </method>
    1: 
    1:       <method name="showPane">
    1:         <parameter name="aPaneElement"/>
    1:         <body>
    1:         <![CDATA[
 6267:           if (!aPaneElement)
 6267:             return;
 6267: 
    1:           this._selector.selectedItem = document.getAnonymousElementByAttribute(this, "pane", aPaneElement.id);
    1:           if (!aPaneElement.loaded) {
    1:             function OverlayLoadObserver(aPane)
    1:             {
    1:               this._pane = aPane;
    1:             }
    1:             OverlayLoadObserver.prototype = { 
    1:               _outer: this,
    1:               observe: function (aSubject, aTopic, aData) 
    1:               {
    1:                 this._pane.loaded = true;
    1:                 this._outer._fireEvent("paneload", this._pane);
    1:                 this._outer._selectPane(this._pane);
    1:               }
    1:             };
    1:             
    1:             var obs = new OverlayLoadObserver(aPaneElement);
    1:             document.loadOverlay(aPaneElement.src, obs);
    1:           }
    1:           else
    1:             this._selectPane(aPaneElement);
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="_fireEvent">
    1:         <parameter name="aEventName"/>
    1:         <parameter name="aTarget"/>
    1:         <body>
    1:         <![CDATA[
    1:           // Panel loaded, synthesize a load event. 
    1:           try {
    1:             var event = document.createEvent("Events");
    1:             event.initEvent(aEventName, true, true);
    1:             var cancel = !aTarget.dispatchEvent(event);
    1:             if (aTarget.hasAttribute("on" + aEventName)) {
    1:               var fn = new Function ("event", aTarget.getAttribute("on" + aEventName));
    1:               var rv = fn.call(aTarget, event);
    1:               if (rv == false)
    1:                 cancel = true;
    1:             }
    1:             return !cancel;  
    1:           }
    1:           catch (e) { 
    1:             Components.utils.reportError(e);
    1:           }
    1:           return false;
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <field name="_initialized">false</field>
    1:       <method name="_selectPane">
    1:         <parameter name="aPaneElement"/>
    1:         <body>
    1:         <![CDATA[
    1: #ifdef XP_MACOSX
    1:           var paneTitle = aPaneElement.label;
    1:           if (paneTitle != "")
    1:             document.title = paneTitle;
    1: #endif
 8524:           var helpButton = document.documentElement.getButton("help");
13505:           if (aPaneElement.helpTopic)
 8524:             helpButton.hidden = false;
 8524:           else
 8524:             helpButton.hidden = true;
 8524: 
    1:           // Find this pane's index in the deck and set the deck's 
    1:           // selectedIndex to that value to switch to it.
    1:           var prefpanes = this.preferencePanes;
    1:           for (var i = 0; i < prefpanes.length; ++i) {
    1:             if (prefpanes[i] == aPaneElement) {
 3951:               this._paneDeck.selectedIndex = i;
    1:               
    1:               if (this.type != "child") {
 6216:                 if (aPaneElement.hasAttribute("flex") && this._shouldAnimate &&
 6216:                     prefpanes.length > 1)
 6216:                   aPaneElement.removeAttribute("flex");
 5970:                 // Calling sizeToContent after the first prefpane is loaded
 5970:                 // will size the windows contents so style information is
 5970:                 // available to calculate correct sizing.
 6086:                 if (!this._initialized && prefpanes.length > 1) {
 6086:                   if (this._shouldAnimate)
 6086:                     this.style.minHeight = 0;
 5970:                   window.sizeToContent();
 6086:                 }
 5970: 
    1:                 var oldPane = this.lastSelected ? document.getElementById(this.lastSelected) : this.preferencePanes[0];
    1:                 oldPane.selected = !(aPaneElement.selected = true);
    1:                 this.lastSelected = aPaneElement.id;
    1:                 this.currentPane = aPaneElement;
 5970:                 this._initialized = true;
 5970: 
    1:                 // Only animate if we've switched between prefpanes
    1:                 if (this._shouldAnimate && oldPane.id != aPaneElement.id) {
    1:                   aPaneElement.style.opacity = 0.0;
    1:                   this.animate(oldPane, aPaneElement);
    1:                 }
 6086:                 else if (!this._shouldAnimate && prefpanes.length > 1) {
 5571:                   var targetHeight = parseInt(window.getComputedStyle(this._paneDeckContainer, "").height);
 5970:                   var verticalPadding = parseInt(window.getComputedStyle(aPaneElement, "").paddingTop);
 5970:                   verticalPadding += parseInt(window.getComputedStyle(aPaneElement, "").paddingBottom);
 5970:                   if (aPaneElement.contentHeight > targetHeight - verticalPadding) {
 5571:                     // To workaround the bottom border of a groupbox from being
 5571:                     // cutoff an hbox with a class of bottomBox may enclose it.
 5571:                     // This needs to include its padding to resize properly.
 5571:                     // See bug 394433
 5571:                     var bottomPadding = 0;
 5571:                     var bottomBox = aPaneElement.getElementsByAttribute("class", "bottomBox")[0];
 5571:                     if (bottomBox)
 5571:                       bottomPadding = parseInt(window.getComputedStyle(bottomBox, "").paddingBottom);
 5970:                     window.innerHeight += bottomPadding + verticalPadding + aPaneElement.contentHeight - targetHeight;
 5571:                   }
 5970: 
 5970:                   // XXX rstrong - extend the contents of the prefpane to
 5970:                   // prevent elements from being cutoff (see bug 349098).
 5970:                   if (aPaneElement.contentHeight + verticalPadding < targetHeight)
 5970:                     aPaneElement._content.style.height = targetHeight - verticalPadding + "px";
 5571:                 }
    1:               }
    1:               break;
    1:             }
    1:           }
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <property name="_shouldAnimate">
    1:         <getter>
    1:         <![CDATA[
    1:           var psvc = Components.classes["@mozilla.org/preferences-service;1"]
    1:                                .getService(Components.interfaces.nsIPrefBranch);
 9097: #ifdef XP_MACOSX
 9097:           var animate = true;
 9097: #else
    1:           var animate = false;
 9097: #endif
    1:           try {
    1:             animate = psvc.getBoolPref("browser.preferences.animateFadeIn");
    1:           }
    1:           catch (e) { }
    1:           return animate;
    1:         ]]>
    1:         </getter>
    1:       </property>
    1:       
    1:       <method name="animate">
    1:         <parameter name="aOldPane"/>
    1:         <parameter name="aNewPane"/>
    1:         <body>
    1:         <![CDATA[
    1:           // if we are already resizing, use currentHeight
    1:           var oldHeight = this._currentHeight ? this._currentHeight : aOldPane.contentHeight;
    1:           
    1:           this._multiplier = aNewPane.contentHeight > oldHeight ? 1 : -1;
    1:           var sizeDelta = Math.abs(oldHeight - aNewPane.contentHeight);
    1:           this._animateRemainder = sizeDelta % this._animateIncrement;
    1: 
    1:           this._setUpAnimationTimer(oldHeight);
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <property name="_sizeIncrement">
    1:         <getter>
    1:         <![CDATA[
    1:           var lastSelectedPane = document.getElementById(this.lastSelected);
    1:           var increment = this._animateIncrement * this._multiplier;
    1:           var newHeight = this._currentHeight + increment;
    1:           if ((this._multiplier > 0 && this._currentHeight >= lastSelectedPane.contentHeight) ||
    1:               (this._multiplier < 0 && this._currentHeight <= lastSelectedPane.contentHeight))
    1:             return 0;
    1:           
    1:           if ((this._multiplier > 0 && newHeight > lastSelectedPane.contentHeight) ||
    1:               (this._multiplier < 0 && newHeight < lastSelectedPane.contentHeight))
    1:             increment = this._animateRemainder * this._multiplier;
    1:           return increment;
    1:         ]]>
    1:         </getter>
    1:       </property>
    1:       
    1:       <method name="notify">
    1:         <parameter name="aTimer"/>
    1:         <body>
    1:         <![CDATA[
    1:           if (!document)
    1:             aTimer.cancel();
    1:           
    1:           if (aTimer == this._animateTimer) {
    1:             var increment = this._sizeIncrement;
    1:             if (increment != 0) {
    1:               window.innerHeight += increment;
    1:               this._currentHeight += increment;
    1:             }
    1:             else {
    1:               aTimer.cancel();
    1:               this._setUpFadeTimer();
    1:             }
    1:           } else if (aTimer == this._fadeTimer) {
    1:             var elt = document.getElementById(this.lastSelected);
    1:             var newOpacity = parseFloat(window.getComputedStyle(elt, "").opacity) + this._fadeIncrement;
    1:             if (newOpacity < 1.0)
    1:               elt.style.opacity = newOpacity;
    1:             else {
    1:               aTimer.cancel();
    1:               elt.style.opacity = 1.0;
    1:             }
    1:           }
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="_setUpAnimationTimer">
    1:         <parameter name="aStartHeight"/>
    1:         <body>
    1:         <![CDATA[
    1:           if (!this._animateTimer) 
    1:             this._animateTimer = Components.classes["@mozilla.org/timer;1"]
    1:                                            .createInstance(Components.interfaces.nsITimer);
    1:           else
    1:             this._animateTimer.cancel();
    1:           this._currentHeight = aStartHeight;
    1:           
    1:           this._animateTimer.initWithCallback(this, this._animateDelay, 
    1:                                               Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="_setUpFadeTimer">
    1:         <body>
    1:         <![CDATA[
    1:           if (!this._fadeTimer) 
    1:             this._fadeTimer = Components.classes["@mozilla.org/timer;1"]
    1:                                         .createInstance(Components.interfaces.nsITimer);
    1:           else
    1:             this._fadeTimer.cancel();
    1:           
    1:           this._fadeTimer.initWithCallback(this, this._fadeDelay, 
    1:                                            Components.interfaces.nsITimer.TYPE_REPEATING_SLACK);
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <field name="_animateTimer">null</field>
    1:       <field name="_fadeTimer">null</field>
    1:       <field name="_animateDelay">15</field>
    1:       <field name="_animateIncrement">40</field>
    1:       <field name="_fadeDelay">5</field>
    1:       <field name="_fadeIncrement">0.40</field>
    1:       <field name="_animateRemainder">0</field>
    1:       <field name="_currentHeight">0</field>
    1:       <field name="_multiplier">0</field>
    1: 
    1:       <method name="addPane">
    1:         <parameter name="aPaneElement"/>
    1:         <body>
    1:         <![CDATA[
    1:           this.appendChild(aPaneElement);
    1:           
    1:           // Set up pane button
    1:           this._makePaneButton(aPaneElement);
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="openSubDialog">
    1:         <parameter name="aURL"/>
    1:         <parameter name="aFeatures"/>
    1:         <parameter name="aParams"/>
    1:         <body>
    1:           return openDialog(aURL, "", "modal,centerscreen,resizable=no" + (aFeatures != "" ? ("," + aFeatures) : ""), aParams);
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="openWindow">
    1:         <parameter name="aWindowType"/>
    1:         <parameter name="aURL"/>
    1:         <parameter name="aFeatures"/>
    1:         <parameter name="aParams"/>
    1:         <body>
    1:         <![CDATA[
    1:           var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]
    1:                              .getService(Components.interfaces.nsIWindowMediator);
    1:           var win = aWindowType ? wm.getMostRecentWindow(aWindowType) : null;
    1:           if (win) {
    1:             if ("initWithParams" in win)
    1:               win.initWithParams(aParams);
    1:             win.focus();
    1:           }
    1:           else {
    1:             var features = "resizable,dialog=no,centerscreen" + (aFeatures != "" ? ("," + aFeatures) : "");
    1:             var parentWindow = (this.instantApply || !window.opener || window.opener.closed) ? window : window.opener;
    1:             win = parentWindow.openDialog(aURL, "_blank", features, aParams);
    1:           }
    1:           return win;
    1:         ]]>
    1:         </body>
    1:       </method>
    1:     </implementation>
    1:     <handlers>
    1:       <handler event="dialogaccept">
    1:       <![CDATA[
    1:         if (!this._fireEvent("beforeaccept", this)) 
    1:           return;
    1:         
    1:         if (this.type == "child" && window.opener) {
    1:           var psvc = Components.classes["@mozilla.org/preferences-service;1"]
    1:                                .getService(Components.interfaces.nsIPrefBranch);
    1:           var instantApply = psvc.getBoolPref("browser.preferences.instantApply");
    1:           if (instantApply) {
    1:             var panes = this.preferencePanes;
    1:             for (var i = 0; i < panes.length; ++i)
    1:               panes[i].writePreferences(true);
    1:           }
    1:           else {
    1:             // Clone all the preferences elements from the child document and
    1:             // insert them into the pane collection of the parent. 
    1:             var pdoc = window.opener.document;
    1:             if (pdoc.documentElement.localName == "prefwindow") {
    1:               var currentPane = pdoc.documentElement.currentPane;
    1:               var id = window.location.href + "#childprefs";
    1:               var childPrefs = pdoc.getElementById(id);
    1:               if (!childPrefs) {
    1:                 var childPrefs = pdoc.createElement("preferences");
    1:                 currentPane.appendChild(childPrefs);
    1:                 childPrefs.id = id;
    1:               }
    1:               var panes = this.preferencePanes;
    1:               for (var i = 0; i < panes.length; ++i) {
    1:                 var preferences = panes[i].preferences;
    1:                 for (var j = 0; j < preferences.length; ++j) {
    1:                   // Try to find a preference element for the same preference.
    1:                   var preference = null;
    1:                   var parentPreferences = pdoc.getElementsByTagName("preferences");
    1:                   for (var k = 0; (k < parentPreferences.length && !preference); ++k) {
    1:                     var parentPrefs = parentPreferences[k]
    1:                                          .getElementsByAttribute("name", preferences[j].name);
    1:                     for (var l = 0; (l < parentPrefs.length && !preference); ++l) {
    1:                       if (parentPrefs[l].localName == "preference")
    1:                         preference = parentPrefs[l];
    1:                     }
    1:                   }
    1:                   if (!preference) {
    1:                     // No matching preference in the parent window.
    1:                     preference = pdoc.createElement("preference");
    1:                     childPrefs.appendChild(preference);
    1:                     preference.name     = preferences[j].name;
    1:                     preference.type     = preferences[j].type;
    1:                     preference.inverted = preferences[j].inverted;
    1:                     preference.readonly = preferences[j].readonly;
    1:                     preference.disabled = preferences[j].disabled;
    1:                   }
    1:                   preference.value = preferences[j].value;
    1:                 }
    1:               }
    1:             }
    1:           }
    1:         }
    1:         else {
    1:           var panes = this.preferencePanes;
    1:           for (var i = 0; i < panes.length; ++i)
    1:             panes[i].writePreferences(false);
    1: 
    1:           var psvc = Components.classes["@mozilla.org/preferences-service;1"]
    1:                                .getService(Components.interfaces.nsIPrefService);
    1:           psvc.savePrefFile(null);
    1:         }
    1:       ]]>
    1:       </handler>
    1:       <handler event="command">
    1:         if (event.originalTarget.hasAttribute("pane")) {
    1:           var pane = document.getElementById(event.originalTarget.getAttribute("pane"));
    1:           event.originalTarget.parentNode.parentNode.showPane(pane);
    1:         }
    1:       </handler>
    1: 
    1:       <handler event="keypress" key="&windowClose.key;" modifiers="accel" phase="capturing">
    1:         if (this.instantApply)
    1:           window.close();
    1:       </handler>
    1:     </handlers>
    1:   </binding>
    1:   
    1:   <binding id="prefpane">
    1:     <resources>
    1:       <stylesheet src="chrome://global/skin/preferences.css"/>
    1:     </resources>
    1:     <content>
    1:       <xul:vbox class="content-box" xbl:inherits="flex">
    1:         <children/>
    1:       </xul:vbox>
    1:     </content>
    1:     <implementation>
    1:       <method name="writePreferences">
    1:         <parameter name="aFlushToDisk"/>
    1:         <body>
    1:         <![CDATA[
    1:           // Write all values to preferences.
    1:           var preferences = this.preferences;
    1:           for (var i = 0; i < preferences.length; ++i) {
    1:             var preference = preferences[i];
    1:             preference.batching = true;
    1:             preference.valueFromPreferences = preference.value;
    1:             preference.batching = false;
    1:           }
    1:           if (aFlushToDisk) {
    1:             var psvc = Components.classes["@mozilla.org/preferences-service;1"]
    1:                                  .getService(Components.interfaces.nsIPrefService);
    1:             psvc.savePrefFile(null);
    1:           }
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <property name="src" 
    1:                 onget="return this.getAttribute('src');"
    1:                 onset="this.setAttribute('src', val); return val;"/>
    1:       <property name="selected" 
    1:                 onget="return this.getAttribute('selected') == 'true';"
    1:                 onset="this.setAttribute('selected', val); return val;"/>
    1:       <property name="image" 
    1:                 onget="return this.getAttribute('image');"
    1:                 onset="this.setAttribute('image', val); return val;"/>
    1:       <property name="label" 
    1:                 onget="return this.getAttribute('label');"
    1:                 onset="this.setAttribute('label', val); return val;"/>
    1:       
    1:       <property name="preferenceElements"
    1:                 onget="return this.getElementsByAttribute('preference', '*');"/>
    1:       <property name="preferences"
    1:                 onget="return this.getElementsByTagName('preference');"/>
    1: 
    1:       <property name="helpTopic">
    1:         <getter>
    1:         <![CDATA[
    1:           // if there are tabs, and the selected tab provides a helpTopic, return that
    1:           var box = this.getElementsByTagName("tabbox");
    1:           if (box[0]) {
    1:             var tab = box[0].selectedTab;
    1:             if (tab && tab.hasAttribute("helpTopic"))
    1:               return tab.getAttribute("helpTopic");
    1:           }
    1: 
    1:           // otherwise, return the helpTopic of the current panel
    1:           return this.getAttribute("helpTopic");
    1:         ]]>
    1:         </getter>
    1:       </property>
    1: 
    1:       <field name="_loaded">false</field>
    1:       <property name="loaded" 
    1:                 onget="return !this.src ? true : this._loaded;"
    1:                 onset="this._loaded = val; return val;"/>
    1:       
    1:       <method name="preferenceForElement">
    1:         <parameter name="aElement"/>
    1:         <body>
    1:           return document.getElementById(aElement.getAttribute("preference"));
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="getPreferenceElement">
    1:         <parameter name="aStartElement"/>
    1:         <body>
    1:         <![CDATA[
    1:           var temp = aStartElement;
    1:           while (temp && temp.nodeType == Node.ELEMENT_NODE && 
    1:                  !temp.hasAttribute("preference"))
    1:             temp = temp.parentNode;
    1:           return temp.nodeType == Node.ELEMENT_NODE ? temp : aStartElement;
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <method name="userChangedValue">
    1:         <parameter name="aElement"/>
    1:         <body>
    1:         <![CDATA[
    1:           var element = this.getPreferenceElement(aElement);
    1:           if (element.hasAttribute("preference")) {
    1:             var preference = document.getElementById(element.getAttribute("preference"));
    1:             var prefVal = preference.getElementValue(element);
    1:             preference.value = prefVal;
    1:           }
    1:         ]]>
    1:         </body>
    1:       </method>
    1:       
    1:       <property name="contentHeight">
    1:         <getter>
    1:           var targetHeight = parseInt(window.getComputedStyle(this._content, "").height);
    1:           targetHeight += parseInt(window.getComputedStyle(this._content, "").marginTop);
    1:           targetHeight += parseInt(window.getComputedStyle(this._content, "").marginBottom);
    1:           return targetHeight;
    1:         </getter>
    1:       </property>
    1:       <field name="_content">
    1:         document.getAnonymousElementByAttribute(this, "class", "content-box");
    1:       </field>
    1:     </implementation>
    1:     <handlers>
    1:       <handler event="command">
    1:         // This "command" event handler tracks changes made to preferences by 
    1:         // the user in this window. 
    1:         this.userChangedValue(event.target);
    1:       </handler>
    1:       <handler event="select">
    1:         // This "select" event handler tracks changes made to colorpicker 
    1:         // preferences by the user in this window.
    1:         if (event.target.localName == "colorpicker") 
    1:           this.userChangedValue(event.target);
    1:       </handler>
    1:       <handler event="change">
    1:         // This "change" event handler tracks changes made to preferences by 
    1:         // the user in this window. 
    1:         this.userChangedValue(event.target);
    1:       </handler>
    1:       <handler event="input">
    1:         // This "input" event handler tracks changes made to preferences by 
    1:         // the user in this window.
    1:         this.userChangedValue(event.target);
    1:       </handler>
    1:       <handler event="paneload">
    1:       <![CDATA[
    1:         // Initialize all values from preferences.
    1:         var elements = this.preferenceElements;
    1:         for (var i = 0; i < elements.length; ++i) {
    1:           try {
    1:             var preference = this.preferenceForElement(elements[i]);
    1:             preference.setElementValue(elements[i]);
    1:           }
    1:           catch (e) {
    1:             dump("*** No preference found for " + elements[i].getAttribute("preference") + "\n");
    1:           }
    1:         }
    1:       ]]>      
    1:       </handler>
    1:     </handlers>
    1:   </binding>
    1:           
    1:   <binding id="panebutton" extends="chrome://global/content/bindings/radio.xml#radio">
    1:     <resources>
    1:       <stylesheet src="chrome://global/skin/preferences.css"/>
    1:     </resources>
    1:     <content>
    1:       <xul:image class="paneButtonIcon" xbl:inherits="src"/>
    1:       <xul:label class="paneButtonLabel" xbl:inherits="value=label"/>
    1:     </content>
    1:     <implementation implements="nsIAccessible">
    1:       <property name="accessibleType" readonly="true">
    1:         <getter>
    1:           <![CDATA[
    1:             return Components.interfaces.nsIAccessibleProvider.XULListitem;
    1:           ]]>
    1:         </getter>
    1:       </property>
    1:     </implementation>
    1:   </binding>
    1: 
    1: </bindings>
    1: 
    1: # -*- Mode: Java; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1: # ***** BEGIN LICENSE BLOCK *****
    1: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1: #
    1: # The contents of this file are subject to the Mozilla Public License Version
    1: # 1.1 (the "License"); you may not use this file except in compliance with
    1: # the License. You may obtain a copy of the License at
    1: # http://www.mozilla.org/MPL/
    1: #
    1: # Software distributed under the License is distributed on an "AS IS" basis,
    1: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1: # for the specific language governing rights and limitations under the
    1: # License.
    1: #
    1: # The Original Code is the Preferences System.
    1: #
    1: # The Initial Developer of the Original Code is
    1: # Ben Goodger.
    1: # Portions created by the Initial Developer are Copyright (C) 2005
    1: # the Initial Developer. All Rights Reserved.
    1: #
    1: # Contributor(s):
    1: #   Ben Goodger <ben@mozilla.org>
    1: #   Josh Aas <josh@mozilla.com>
    1: #
    1: # Alternatively, the contents of this file may be used under the terms of
    1: # either the GNU General Public License Version 2 or later (the "GPL"), or
    1: # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1: # in which case the provisions of the GPL or the LGPL are applicable instead
    1: # of those above. If you wish to allow use of your version of this file only
    1: # under the terms of either the GPL or the LGPL, and not to allow others to
    1: # use your version of this file under the terms of the MPL, indicate your
    1: # decision by deleting the provisions above and replace them with the notice
    1: # and other provisions required by the GPL or the LGPL. If you do not delete
    1: # the provisions above, a recipient may use your version of this file under
    1: # the terms of any one of the MPL, the GPL or the LGPL.
    1: #
    1: # ***** END LICENSE BLOCK *****
    1: 
    1: #
    1: # This is PrefWindow 6. The Code Could Well Be Ready, Are You?
    1: #
    1: #    Historical References:
    1: #    PrefWindow V   (February 1, 2003)
    1: #    PrefWindow IV  (April 24, 2000)
    1: #    PrefWindow III (January 6, 2000)
    1: #    PrefWindow II  (???)
    1: #    PrefWindow I   (June 4, 1999)
    1: #
