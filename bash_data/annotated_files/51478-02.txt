    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Blake Ross <blakeross@telocity.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsTextControlFrame.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMNSHTMLTextAreaElement.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsIPlaintextEditor.h"
    1: #include "nsEditorCID.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsIDocumentEncoder.h"
15969: #include "nsCaret.h"
    1: #include "nsISelectionListener.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsIController.h"
    1: #include "nsIControllers.h"
    1: #include "nsIControllerContext.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsIEditorIMESupport.h"
    1: #include "nsIPhonetic.h"
    1: #include "nsIEditorObserver.h"
41743: #include "nsEditProperty.h"
    1: #include "nsIDOMHTMLTextAreaElement.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsFormControlFrame.h" //for registering accesskeys
    1: #include "nsIDeviceContext.h" // to measure fonts
    1: 
    1: #include "nsIContent.h"
    1: #include "nsIAtom.h"
    1: #include "nsPresContext.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIComponentManager.h"
    1: 
    1: #include "nsBoxLayoutState.h"
    1: //for keylistener for "return" check
    1: #include "nsIPrivateDOMEvent.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDocument.h" //observe documents to send onchangenotifications
    1: #include "nsIStyleSheet.h"//observe documents to send onchangenotifications
    1: #include "nsIStyleRule.h"//observe documents to send onchangenotifications
    1: #include "nsIDOMEventListener.h"//observe documents to send onchangenotifications
    1: #include "nsGUIEvent.h"
    1: #include "nsIDOMEventGroup.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsIDOMNSUIEvent.h"
    1: #include "nsIEventStateManager.h"
    1: 
    1: #include "nsIDOMFocusListener.h" //onchange events
    1: #include "nsIDOMCharacterData.h" //for selection setting helper func
    1: #include "nsIDOMNodeList.h" //for selection setting helper func
    1: #include "nsIDOMRange.h" //for selection setting helper func
    1: #include "nsPIDOMWindow.h" //needed for notify selection changed to update the menus ect.
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMNode.h"
    1: 
    1: #include "nsIEditorObserver.h"
    1: #include "nsITransactionManager.h"
    1: #include "nsIDOMText.h" //for multiline getselection
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsIDOMKeyListener.h"
    1: #include "nsIDOMEventGroup.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsINativeKeyBindings.h"
    1: #include "nsIJSContextStack.h"
29018: #include "nsFocusManager.h"
40692: #include "nsTextEditRules.h"
43129: #include "nsIFontMetrics.h"
48077: #include "nsIDOMNSHTMLElement.h"
    1: 
42480: #include "mozilla/FunctionTimer.h"
42480: 
    1: #define DEFAULT_COLUMN_WIDTH 20
    1: 
    1: #include "nsContentCID.h"
    1: static NS_DEFINE_IID(kRangeCID,     NS_RANGE_CID);
    1: 
    1: nsIFrame*
    1: NS_NewTextControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsTextControlFrame(aPresShell, aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsTextControlFrame)
32423: 
23554: NS_QUERYFRAME_HEAD(nsTextControlFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIFormControlFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIAnonymousContentCreator)
23554:   NS_QUERYFRAME_ENTRY(nsITextControlFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsBoxFrame)
    1: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsTextControlFrame::CreateAccessible()
    1: {
    1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
    1: 
    1:   if (accService) {
46338:     return accService->CreateHTMLTextFieldAccessible(mContent,
46338:                                                      PresContext()->PresShell());
    1:   }
    1: 
46338:   return nsnull;
    1: }
    1: #endif
    1: 
40693: #ifdef DEBUG
40693: class EditorInitializerEntryTracker {
40693: public:
40693:   explicit EditorInitializerEntryTracker(nsTextControlFrame &frame)
40693:     : mFrame(frame)
40693:     , mFirstEntry(PR_FALSE)
40693:   {
40693:     if (!mFrame.mInEditorInitialization) {
40693:       mFrame.mInEditorInitialization = PR_TRUE;
40693:       mFirstEntry = PR_TRUE;
40693:     }
40693:   }
40693:   ~EditorInitializerEntryTracker()
40693:   {
40693:     if (mFirstEntry) {
40693:       mFrame.mInEditorInitialization = PR_FALSE;
40693:     }
40693:   }
40693:   PRBool EnteredMoreThanOnce() const { return !mFirstEntry; }
40693: private:
40693:   nsTextControlFrame &mFrame;
40693:   PRBool mFirstEntry;
40693: };
40693: #endif
40693: 
    1: nsTextControlFrame::nsTextControlFrame(nsIPresShell* aShell, nsStyleContext* aContext)
    1:   : nsStackFrame(aShell, aContext)
    1:   , mUseEditor(PR_FALSE)
    1:   , mIsProcessing(PR_FALSE)
    1:   , mNotifyOnInput(PR_TRUE)
    1:   , mFireChangeEventState(PR_FALSE)
 6348:   , mInSecureKeyboardInputMode(PR_FALSE)
40693: #ifdef DEBUG
40693:   , mInEditorInitialization(PR_FALSE)
40693: #endif
    1: {
    1: }
    1: 
    1: nsTextControlFrame::~nsTextControlFrame()
    1: {
    1: }
    1: 
    1: void
36647: nsTextControlFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
 6348:   if (mInSecureKeyboardInputMode) {
 6348:     MaybeEndSecureKeyboardInput();
 6348:   }
43129: 
43129:   mScrollEvent.Revoke();
43129: 
43129:   // Unbind the text editor state object from the frame.  The editor will live
43129:   // on, but things like controllers will be released.
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   txtCtrl->UnbindFromFrame(this);
43129: 
43129:   nsFormControlFrame::RegUnRegAccessKey(static_cast<nsIFrame*>(this), PR_FALSE);
43129: 
36647:   nsBoxFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: nsIAtom*
    1: nsTextControlFrame::GetType() const 
    1: { 
    1:   return nsGkAtoms::textInputFrame;
    1: } 
    1: 
 6348: nsresult nsTextControlFrame::MaybeBeginSecureKeyboardInput()
 6348: {
 6348:   nsresult rv = NS_OK;
 6348:   if (IsPasswordTextControl() && !mInSecureKeyboardInputMode) {
47148:     nsIWidget* window = GetNearestWidget();
 6348:     NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 6348:     rv = window->BeginSecureKeyboardInput();
 6348:     mInSecureKeyboardInputMode = NS_SUCCEEDED(rv);
 6348:   }
 6348:   return rv;
 6348: }
 6348: 
 6348: void nsTextControlFrame::MaybeEndSecureKeyboardInput()
 6348: {
 6348:   if (mInSecureKeyboardInputMode) {
47148:     nsIWidget* window = GetNearestWidget();
 6348:     if (!window)
 6348:       return;
 6348:     window->EndSecureKeyboardInput();
 6348:     mInSecureKeyboardInputMode = PR_FALSE;
 6348:   }
 6348: }
 6348: 
    1: nsresult
    1: nsTextControlFrame::CalcIntrinsicSize(nsIRenderingContext* aRenderingContext,
    1:                                       nsSize&              aIntrinsicSize)
    1: {
    1:   // Get leading and the Average/MaxAdvance char width 
    1:   nscoord lineHeight  = 0;
    1:   nscoord charWidth   = 0;
    1:   nscoord charMaxAdvance  = 0;
    1: 
    1:   nsCOMPtr<nsIFontMetrics> fontMet;
    1:   nsresult rv =
    1:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   aRenderingContext->SetFont(fontMet);
    1: 
28519:   lineHeight =
28519:     nsHTMLReflowState::CalcLineHeight(GetStyleContext(), NS_AUTOHEIGHT);
    1:   fontMet->GetAveCharWidth(charWidth);
    1:   fontMet->GetMaxAdvance(charMaxAdvance);
    1: 
    1:   // Set the width equal to the width in characters
    1:   PRInt32 cols = GetCols();
    1:   aIntrinsicSize.width = cols * charWidth;
    1: 
    1:   // To better match IE, take the maximum character width(in twips) and remove
    1:   // 4 pixels add this on as additional padding(internalPadding). But only do
    1:   // this if charMaxAdvance != charWidth; if they are equal, this is almost
    1:   // certainly a fixed-width font.
    1:   if (charWidth != charMaxAdvance) {
32531:     nscoord internalPadding = NS_MAX(0, charMaxAdvance -
    1:                                         nsPresContext::CSSPixelsToAppUnits(4));
    1:     nscoord t = nsPresContext::CSSPixelsToAppUnits(1); 
    1:    // Round to a multiple of t
    1:     nscoord rest = internalPadding % t; 
    1:     if (rest < t - rest) {
    1:       internalPadding -= rest;
    1:     } else {
    1:       internalPadding += t - rest;
    1:     }
    1:     // Now add the extra padding on (so that small input sizes work well)
    1:     aIntrinsicSize.width += internalPadding;
    1:   } else {
15383:     // This is to account for the anonymous <br> having a 1 twip width
15383:     // in Full Standards mode, see BRFrame::Reflow and bug 228752.
15383:     if (PresContext()->CompatibilityMode() == eCompatibility_FullStandards) {
15383:       aIntrinsicSize.width += 1;
15383:     }
15383: 
38754:     // Also add in the padding of our value div child.  Note that it hasn't
 4199:     // been reflowed yet, so we can't get its used padding, but it shouldn't be
 4199:     // using percentage padding anyway.
 4199:     nsMargin childPadding;
51478:     nsIFrame* firstChild = GetFirstChild(nsnull);
51478:     if (firstChild && firstChild->GetStylePadding()->GetPadding(childPadding)) {
 4199:       aIntrinsicSize.width += childPadding.LeftRight();
 4199:     } else {
38754:       NS_ERROR("Percentage padding on value div?");
 4199:     }
    1:   }
    1: 
    1:   // Increment width with cols * letter-spacing.
    1:   {
    1:     const nsStyleCoord& lsCoord = GetStyleText()->mLetterSpacing;
    1:     if (eStyleUnit_Coord == lsCoord.GetUnit()) {
    1:       nscoord letterSpacing = lsCoord.GetCoordValue();
    1:       if (letterSpacing != 0) {
    1:         aIntrinsicSize.width += cols * letterSpacing;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Set the height equal to total number of rows (times the height of each
    1:   // line, of course)
    1:   aIntrinsicSize.height = lineHeight * GetRows();
    1: 
    1:   // Add in the size of the scrollbars for textarea
    1:   if (IsTextArea()) {
    1:     nsIFrame* first = GetFirstChild(nsnull);
    1: 
23554:     nsIScrollableFrame *scrollableFrame = do_QueryFrame(first);
    1:     NS_ASSERTION(scrollableFrame, "Child must be scrollable");
    1: 
51478:     if (scrollableFrame) {
14159:       nsMargin scrollbarSizes =
14159:       scrollableFrame->GetDesiredScrollbarSizes(PresContext(), aRenderingContext);
    1: 
    1:       aIntrinsicSize.width  += scrollbarSizes.LeftRight();
    1: 
    1:       aIntrinsicSize.height += scrollbarSizes.TopBottom();;
    1:     }
51478:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
24402: nsresult
40683: nsTextControlFrame::EnsureEditorInitialized()
40514: {
24402:   // This method initializes our editor, if needed.
24402: 
24402:   // This code used to be called from CreateAnonymousContent(), but
24402:   // when the editor set the initial string, it would trigger a
24402:   // PresShell listener which called FlushPendingNotifications()
24402:   // during frame construction. This was causing other form controls
40683:   // to display wrong values.  Additionally, calling this every time
40683:   // a text frame control is instantiated means that we're effectively
40683:   // instantiating the editor for all text fields, even if they
40692:   // never get used.  So, now this method is being called lazily only
40692:   // when we actually need an editor.
24402: 
24402:   // Check if this method has been called already.
24402:   // If so, just return early.
24402:   if (mUseEditor)
24402:     return NS_OK;
24402: 
42480:   NS_TIME_FUNCTION;
42480: 
40683:   nsIDocument* doc = mContent->GetCurrentDoc();
40683:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
40683: 
40683:   nsWeakFrame weakFrame(this);
40683: 
40683:   // Flush out content on our document.  Have to do this, because script
40683:   // blockers don't prevent the sink flushing out content and notifying in the
40683:   // process, which can destroy frames.
40683:   doc->FlushPendingNotifications(Flush_ContentAndNotify);
40683:   NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_ERROR_FAILURE);
40683: 
40683:   // Make sure that editor init doesn't do things that would kill us off
40683:   // (especially off the script blockers it'll create for its DOM mutations).
40683:   nsAutoScriptBlocker scriptBlocker;
40683: 
40683:   // Time to mess with our security context... See comments in GetValue()
40683:   // for why this is needed.
40683:   nsCxPusher pusher;
40683:   pusher.PushNull();
40683: 
40683:   // Make sure that we try to focus the content even if the method fails
40683:   class EnsureSetFocus {
40683:   public:
40683:     explicit EnsureSetFocus(nsTextControlFrame* aFrame)
40683:       : mFrame(aFrame) {}
40683:     ~EnsureSetFocus() {
43129:       if (nsContentUtils::IsFocusedContent(mFrame->GetContent()))
40683:         mFrame->SetFocus(PR_TRUE, PR_FALSE);
40683:     }
40683:   private:
40683:     nsTextControlFrame *mFrame;
40683:   };
40683:   EnsureSetFocus makeSureSetFocusHappens(this);
40683: 
40693: #ifdef DEBUG
40693:   // Make sure we are not being called again until we're finished.
40693:   // If reentrancy happens, just pretend that we don't have an editor.
40693:   const EditorInitializerEntryTracker tracker(*this);
40693:   NS_ASSERTION(!tracker.EnteredMoreThanOnce(),
40693:                "EnsureEditorInitialized has been called while a previous call was in progress");
40693: #endif
40693: 
43129:   // Create an editor for the frame, if one doesn't already exist
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   nsresult rv = txtCtrl->CreateEditor();
43129:   NS_ENSURE_SUCCESS(rv, rv);
40684: 
43129:   // Turn on mUseEditor so that subsequent calls will use the
43129:   // editor.
43129:   mUseEditor = PR_TRUE;
35024: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::CreateAnonymousContent(nsTArray<nsIContent*>& aElements)
    1: {
    1:   mState |= NS_FRAME_INDEPENDENT_SELECTION;
    1: 
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
    1: 
43129:   // Bind the frame to its text control
43129:   nsresult rv = txtCtrl->BindToFrame(this);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
43129:   nsIContent* rootNode = txtCtrl->GetRootEditorNode();
43129:   NS_ENSURE_TRUE(rootNode, NS_ERROR_OUT_OF_MEMORY);
37971: 
43129:   if (!aElements.AppendElement(rootNode))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
43129:   nsIContent* placeholderNode = txtCtrl->GetPlaceholderNode();
43129:   NS_ENSURE_TRUE(placeholderNode, NS_ERROR_OUT_OF_MEMORY);
43129: 
43129:   if (!aElements.AppendElement(placeholderNode))
43129:     return NS_ERROR_OUT_OF_MEMORY;
40695: 
40692:   rv = UpdateValueDisplay(PR_FALSE);
40692:   NS_ENSURE_SUCCESS(rv, rv);
40692: 
40692:   // textareas are eagerly initialized
48077:   PRBool initEagerly = !IsSingleLineTextControl();
48077:   if (!initEagerly) {
48077:     nsCOMPtr<nsIDOMNSHTMLElement> element = do_QueryInterface(txtCtrl);
48077:     if (element) {
48077:       // so are input text controls with spellcheck=true
48077:       element->GetSpellcheck(&initEagerly);
48077:     }
48077:   }
48077: 
48077:   if (initEagerly) {
24402:     NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
24402:                  "Someone forgot a script blocker?");
24402: 
24402:     if (!nsContentUtils::AddScriptRunner(new EditorInitializer(this))) {
24402:       return NS_ERROR_OUT_OF_MEMORY;
24402:     }
40692:   }
40522: 
    1:   return NS_OK;
    1: }
    1: 
38069: void
38357: nsTextControlFrame::AppendAnonymousContentTo(nsBaseContentList& aElements)
38069: {
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129: 
43129:   aElements.MaybeAppendElement(txtCtrl->GetRootEditorNode());
43129:   aElements.MaybeAppendElement(txtCtrl->GetPlaceholderNode());
38069: }
38069: 
    1: nscoord
    1: nsTextControlFrame::GetMinWidth(nsIRenderingContext* aRenderingContext)
    1: {
    1:   // Our min width is just our preferred width if we have auto width.
    1:   nscoord result;
    1:   DISPLAY_MIN_WIDTH(this, result);
    1: 
    1:   result = GetPrefWidth(aRenderingContext);
    1: 
    1:   return result;
    1: }
    1: 
 4887: nsSize
 4887: nsTextControlFrame::ComputeAutoSize(nsIRenderingContext *aRenderingContext,
 4887:                                     nsSize aCBSize, nscoord aAvailableWidth,
 4887:                                     nsSize aMargin, nsSize aBorder,
 4887:                                     nsSize aPadding, PRBool aShrinkWrap)
 4887: {
 4887:   nsSize autoSize;
 4887:   nsresult rv = CalcIntrinsicSize(aRenderingContext, autoSize);
 4887:   if (NS_FAILED(rv)) {
 4887:     // What now?
 4887:     autoSize.SizeTo(0, 0);
 4887:   }
 4887: #ifdef DEBUG
 4887:   // Note: Ancestor ComputeAutoSize only computes a width if we're auto-width
 4887:   else if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
 4887:     nsSize ancestorAutoSize =
 4887:       nsStackFrame::ComputeAutoSize(aRenderingContext,
 4887:                                     aCBSize, aAvailableWidth,
 4887:                                     aMargin, aBorder,
 4887:                                     aPadding, aShrinkWrap);
 4887:     NS_ASSERTION(ancestorAutoSize.width == autoSize.width,
 4887:                  "Incorrect size computed by ComputeAutoSize?");
 4887:   }
 4887: #endif
 4887:   
 4887:   return autoSize;
 4887: }
 4887: 
 4887: 
    1: // We inherit our GetPrefWidth from nsBoxFrame
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::Reflow(nsPresContext*   aPresContext,
    1:                            nsHTMLReflowMetrics&     aDesiredSize,
    1:                            const nsHTMLReflowState& aReflowState,
    1:                            nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsTextControlFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
    1:   // make sure the the form registers itself on the initial/first reflow
    1:   if (mState & NS_FRAME_FIRST_REFLOW) {
    1:     nsFormControlFrame::RegUnRegAccessKey(this, PR_TRUE);
    1:   }
    1: 
    1:   return nsStackFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
    1:                               aStatus);
    1: }
    1: 
    1: nsSize
    1: nsTextControlFrame::GetPrefSize(nsBoxLayoutState& aState)
    1: {
    1:   if (!DoesNeedRecalc(mPrefSize))
    1:      return mPrefSize;
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aState);
    1: #endif
    1: 
    1:   nsSize pref(0,0);
    1: 
    1:   nsresult rv = CalcIntrinsicSize(aState.GetRenderingContext(), pref);
    1:   NS_ENSURE_SUCCESS(rv, pref);
    1:   AddBorderAndPadding(pref);
    1: 
39607:   PRBool widthSet, heightSet;
39607:   nsIBox::AddCSSPrefSize(this, pref, widthSet, heightSet);
39603: 
39603:   nsSize minSize = GetMinSize(aState);
39603:   nsSize maxSize = GetMaxSize(aState);
39603:   mPrefSize = BoundsCheck(minSize, pref, maxSize);
    1: 
    1: #ifdef DEBUG_rods
    1:   {
    1:     nsMargin borderPadding(0,0,0,0);
    1:     GetBorderAndPadding(borderPadding);
    1:     nsSize size(169, 24);
    1:     nsSize actual(pref.width/15, 
    1:                   pref.height/15);
    1:     printf("nsGfxText(field) %d,%d  %d,%d  %d,%d\n", 
    1:            size.width, size.height, actual.width, actual.height, actual.width-size.width, actual.height-size.height);  // text field
    1:   }
    1: #endif
    1: 
39603:   return mPrefSize;
    1: }
    1: 
    1: nsSize
    1: nsTextControlFrame::GetMinSize(nsBoxLayoutState& aState)
    1: {
    1:   // XXXbz why?  Why not the nsBoxFrame sizes?
    1:   return nsBox::GetMinSize(aState);
    1: }
    1: 
    1: nsSize
    1: nsTextControlFrame::GetMaxSize(nsBoxLayoutState& aState)
    1: {
    1:   // XXXbz why?  Why not the nsBoxFrame sizes?
    1:   return nsBox::GetMaxSize(aState);
    1: }
    1: 
    1: nscoord
    1: nsTextControlFrame::GetBoxAscent(nsBoxLayoutState& aState)
    1: {
28519:   // Return the baseline of the first (nominal) row, with centering for
28519:   // single-line controls.
28519: 
28519:   // First calculate the ascent wrt the client rect
28519:   nsRect clientRect;
28519:   GetClientRect(clientRect);
28519:   nscoord lineHeight =
28519:     IsSingleLineTextControl() ? clientRect.height :
28519:     nsHTMLReflowState::CalcLineHeight(GetStyleContext(), NS_AUTOHEIGHT);
28519: 
28519:   nsCOMPtr<nsIFontMetrics> fontMet;
28519:   nsresult rv =
28519:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
28519:   NS_ENSURE_SUCCESS(rv, 0);
28519: 
28519:   nscoord ascent = nsLayoutUtils::GetCenteredFontBaseline(fontMet, lineHeight);
28519: 
28519:   // Now adjust for our borders and padding
28519:   ascent += clientRect.y;
    1: 
    1:   return ascent;
    1: }
    1: 
    1: PRBool
    1: nsTextControlFrame::IsCollapsed(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:   // We're never collapsed in the box sense.
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsTextControlFrame::IsLeaf() const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
42170: NS_IMETHODIMP
42170: nsTextControlFrame::ScrollOnFocusEvent::Run()
42170: {
43129:   if (mFrame) {
43129:     nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(mFrame->GetContent());
43129:     NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:     nsISelectionController* selCon = txtCtrl->GetSelectionController();
43129:     if (selCon) {
42170:       mFrame->mScrollEvent.Forget();
43129:       selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
42170:                                       nsISelectionController::SELECTION_FOCUS_REGION,
42170:                                       PR_TRUE);
42170:     }
43129:   }
42170:   return NS_OK;
42170: }
42170: 
    1: //IMPLEMENTING NS_IFORMCONTROLFRAME
    1: void nsTextControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)
    1: {
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129: 
42170:   // Revoke the previous scroll event if one exists
42170:   mScrollEvent.Revoke();
42170: 
29018:   if (!aOn) {
38754:     nsWeakFrame weakFrame(this);
38754: 
43129:     PRInt32 length;
43129:     nsresult rv = GetTextLength(&length);
43129:     NS_ENSURE_SUCCESS(rv, );
43129:     if (!length)
43129:       txtCtrl->SetPlaceholderClass(PR_TRUE, PR_TRUE);
38754: 
38754:     if (!weakFrame.IsAlive())
38754:     {
38754:       return;
38754:     }
38754: 
29018:     MaybeEndSecureKeyboardInput();
    1:     return;
29018:   }
29018: 
43129:   nsISelectionController* selCon = txtCtrl->GetSelectionController();
43129:   if (!selCon)
    1:     return;
    1: 
38754:   nsWeakFrame weakFrame(this);
38754: 
43129:   txtCtrl->SetPlaceholderClass(PR_FALSE, PR_TRUE);
38754: 
38754:   if (!weakFrame.IsAlive())
38754:   {
38754:     return;
38754:   }
38754: 
29018:   if (NS_SUCCEEDED(InitFocusedValue()))
29018:     MaybeBeginSecureKeyboardInput();
29018: 
42171:   nsCOMPtr<nsISelection> ourSel;
43129:   selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, 
42171:     getter_AddRefs(ourSel));
42171:   if (!ourSel) return;
42171: 
42171:   nsIPresShell* presShell = PresContext()->GetPresShell();
42171:   nsRefPtr<nsCaret> caret = presShell->GetCaret();
42171:   if (!caret) return;
42171: 
39593:   // Scroll the current selection into view
42171:   nsISelection *caretSelection = caret->GetCaretDOMSelection();
42171:   const PRBool isFocusedRightNow = ourSel == caretSelection;
42171:   if (!isFocusedRightNow) {
42170:     nsRefPtr<ScrollOnFocusEvent> event = new ScrollOnFocusEvent(this);
42170:     nsresult rv = NS_DispatchToCurrentThread(event);
42170:     if (NS_SUCCEEDED(rv)) {
42170:       mScrollEvent = event;
42170:     }
42171:   }
39593: 
    1:   // tell the caret to use our selection
    1:   caret->SetCaretDOMSelection(ourSel);
    1: 
    1:   // mutual-exclusion: the selection is either controlled by the
    1:   // document or by the text input/area. Clear any selection in the
    1:   // document since the focus is now on our independent selection.
    1: 
43129:   nsCOMPtr<nsISelectionController> selcon = do_QueryInterface(presShell);
    1:   nsCOMPtr<nsISelection> docSel;
43129:   selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:     getter_AddRefs(docSel));
    1:   if (!docSel) return;
    1: 
    1:   PRBool isCollapsed = PR_FALSE;
    1:   docSel->GetIsCollapsed(&isCollapsed);
    1:   if (!isCollapsed)
    1:     docSel->RemoveAllRanges();
    1: }
    1: 
    1: nsresult nsTextControlFrame::SetFormProperty(nsIAtom* aName, const nsAString& aValue)
    1: {
    1:   if (!mIsProcessing)//some kind of lock.
    1:   {
    1:     mIsProcessing = PR_TRUE;
43129:     if (nsGkAtoms::select == aName)
    1:     {
    1:       // Select all the text.
    1:       //
43129:       // XXX: This is lame, we can't call editor's SelectAll method
    1:       //      because that triggers AutoCopies in unix builds.
    1:       //      Instead, we have to call our own homegrown version
    1:       //      of select all which merely builds a range that selects
    1:       //      all of the content and adds that to the selection.
    1: 
37971:       SelectAllOrCollapseToEndOfText(PR_TRUE);
    1:     }
    1:     mIsProcessing = PR_FALSE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::GetFormProperty(nsIAtom* aName, nsAString& aValue) const
    1: {
43129:   NS_ASSERTION(nsGkAtoms::value != aName,
43129:                "Should get the value from the content node instead");
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::GetEditor(nsIEditor **aEditor)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEditor);
40691: 
40691:   nsresult rv = EnsureEditorInitialized();
40691:   NS_ENSURE_SUCCESS(rv, rv);
40691: 
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   *aEditor = txtCtrl->GetTextEditor();
    1:   NS_IF_ADDREF(*aEditor);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::GetTextLength(PRInt32* aTextLength)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aTextLength);
    1: 
    1:   nsAutoString   textContents;
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   txtCtrl->GetTextEditorValue(textContents, PR_FALSE);   // this is expensive!
    1:   *aTextLength = textContents.Length();
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::SetSelectionInternal(nsIDOMNode *aStartNode,
    1:                                          PRInt32 aStartOffset,
    1:                                          nsIDOMNode *aEndNode,
    1:                                          PRInt32 aEndOffset)
    1: {
    1:   // Create a new range to represent the new selection.
    1:   // Note that we use a new range to avoid having to do
    1:   // isIncreasing checks to avoid possible errors.
    1: 
    1:   nsCOMPtr<nsIDOMRange> range = do_CreateInstance(kRangeCID);
    1:   NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
    1: 
    1:   nsresult rv = range->SetStart(aStartNode, aStartOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = range->SetEnd(aEndNode, aEndOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Get the selection, clear it and add the new range to it!
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   nsISelectionController* selCon = txtCtrl->GetSelectionController();
43129:   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsISelection> selection;
43129:   selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));  
    1:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
    1: 
    1:   rv = selection->RemoveAllRanges();  
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
39592:   rv = selection->AddRange(range);
39592:   NS_ENSURE_SUCCESS(rv, rv);
39592: 
39592:   // Scroll the selection into view (see bug 231389)
43129:   return selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
39592:                                          nsISelectionController::SELECTION_FOCUS_REGION,
39592:                                          PR_FALSE);
    1: }
    1: 
    1: nsresult
43129: nsTextControlFrame::GetRootNodeAndInitializeEditor(nsIDOMElement **aRootElement)
43129: {
43129:   NS_ENSURE_ARG_POINTER(aRootElement);
43129: 
43412:   nsCOMPtr<nsIEditor> editor;
43412:   GetEditor(getter_AddRefs(editor));
43129:   if (!editor)
43129:     return NS_OK;
43129: 
43129:   return editor->GetRootElement(aRootElement);
43129: }
43129: 
43129: nsresult
37971: nsTextControlFrame::SelectAllOrCollapseToEndOfText(PRBool aSelect)
    1: {
    1:   nsCOMPtr<nsIDOMElement> rootElement;
43129:   nsresult rv = GetRootNodeAndInitializeEditor(getter_AddRefs(rootElement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIContent> rootContent = do_QueryInterface(rootElement);
37971:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
    1:   PRInt32 numChildren = rootContent->GetChildCount();
    1: 
    1:   if (numChildren > 0) {
    1:     // We never want to place the selection after the last
    1:     // br under the root node!
    1:     nsIContent *child = rootContent->GetChildAt(numChildren - 1);
    1:     if (child) {
    1:       if (child->Tag() == nsGkAtoms::br)
    1:         --numChildren;
    1:     }
37971:     if (!aSelect && numChildren) {
37971:       child = rootContent->GetChildAt(numChildren - 1);
37971:       if (child && child->IsNodeOfType(nsINode::eTEXT)) {
37971:         rootNode = do_QueryInterface(child);
37971:         const nsTextFragment* fragment = child->GetText();
37971:         numChildren = fragment ? fragment->GetLength() : 0;
    1:       }
37971:     }
37971:   }
37971: 
37971:   return SetSelectionInternal(rootNode, aSelect ? 0 : numChildren,
37971:                               rootNode, numChildren);
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::SetSelectionEndPoints(PRInt32 aSelStart, PRInt32 aSelEnd)
    1: {
    1:   NS_ASSERTION(aSelStart <= aSelEnd, "Invalid selection offsets!");
    1: 
    1:   if (aSelStart > aSelEnd)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:   PRInt32 startOffset, endOffset;
    1: 
    1:   // Calculate the selection start point.
    1: 
    1:   nsresult rv = OffsetToDOMPoint(aSelStart, getter_AddRefs(startNode), &startOffset);
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aSelStart == aSelEnd) {
    1:     // Collapsed selection, so start and end are the same!
    1:     endNode   = startNode;
    1:     endOffset = startOffset;
    1:   }
    1:   else {
    1:     // Selection isn't collapsed so we have to calculate
    1:     // the end point too.
    1: 
    1:     rv = OffsetToDOMPoint(aSelEnd, getter_AddRefs(endNode), &endOffset);
    1: 
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return SetSelectionInternal(startNode, startOffset, endNode, endOffset);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::SetSelectionRange(PRInt32 aSelStart, PRInt32 aSelEnd)
    1: {
40691:   nsresult rv = EnsureEditorInitialized();
40691:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aSelStart > aSelEnd) {
    1:     // Simulate what we'd see SetSelectionStart() was called, followed
    1:     // by a SetSelectionEnd().
    1: 
    1:     aSelStart   = aSelEnd;
    1:   }
    1: 
    1:   return SetSelectionEndPoints(aSelStart, aSelEnd);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::SetSelectionStart(PRInt32 aSelectionStart)
    1: {
40691:   nsresult rv = EnsureEditorInitialized();
40691:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt32 selStart = 0, selEnd = 0; 
    1: 
40691:   rv = GetSelectionRange(&selStart, &selEnd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aSelectionStart > selEnd) {
    1:     // Collapse to the new start point.
    1:     selEnd = aSelectionStart; 
    1:   }
    1: 
    1:   selStart = aSelectionStart;
    1:   
    1:   return SetSelectionEndPoints(selStart, selEnd);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::SetSelectionEnd(PRInt32 aSelectionEnd)
    1: {
40691:   nsresult rv = EnsureEditorInitialized();
40691:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRInt32 selStart = 0, selEnd = 0; 
    1: 
40691:   rv = GetSelectionRange(&selStart, &selEnd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aSelectionEnd < selStart) {
    1:     // Collapse to the new end point.
    1:     selStart = aSelectionEnd; 
    1:   }
    1: 
    1:   selEnd = aSelectionEnd;
    1:   
    1:   return SetSelectionEndPoints(selStart, selEnd);
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::DOMPointToOffset(nsIDOMNode* aNode,
    1:                                      PRInt32 aNodeOffset,
    1:                                      PRInt32* aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNode && aResult);
    1: 
    1:   *aResult = 0;
    1: 
    1:   nsCOMPtr<nsIDOMElement> rootElement;
43129:   nsresult rv = GetRootNodeAndInitializeEditor(getter_AddRefs(rootElement));
    1:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
    1: 
    1:   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1: 
40691:   rv = rootNode->GetChildNodes(getter_AddRefs(nodeList));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
    1: 
    1:   PRUint32 length = 0;
    1:   rv = nodeList->GetLength(&length);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!length || aNodeOffset < 0)
    1:     return NS_OK;
    1: 
    1:   PRInt32 i, textOffset = 0;
    1:   PRInt32 lastIndex = (PRInt32)length - 1;
    1: 
    1:   for (i = 0; i < (PRInt32)length; i++) {
    1:     if (rootNode == aNode && i == aNodeOffset) {
    1:       *aResult = textOffset;
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMNode> item;
    1:     rv = nodeList->Item(i, getter_AddRefs(item));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     NS_ENSURE_TRUE(item, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIDOMText> domText(do_QueryInterface(item));
    1: 
    1:     if (domText) {
    1:       PRUint32 textLength = 0;
    1: 
    1:       rv = domText->GetLength(&textLength);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       if (item == aNode) {
    1:         NS_ASSERTION((aNodeOffset >= 0 && aNodeOffset <= (PRInt32)textLength),
    1:                      "Invalid aNodeOffset!");
    1:         *aResult = textOffset + aNodeOffset;
    1:         return NS_OK;
    1:       }
    1: 
    1:       textOffset += textLength;
    1:     }
    1:     else {
    1:       // Must be a BR node. If it's not the last BR node
    1:       // under the root, count it as a newline.
    1: 
    1:       if (i != lastIndex)
    1:         ++textOffset;
    1:     }
    1:   }
    1: 
    1:   NS_ASSERTION((aNode == rootNode && aNodeOffset == (PRInt32)length),
    1:                "Invalid node offset!");
    1: 
    1:   *aResult = textOffset;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::OffsetToDOMPoint(PRInt32 aOffset,
    1:                                      nsIDOMNode** aResult,
    1:                                      PRInt32* aPosition)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult && aPosition);
    1: 
    1:   *aResult = nsnull;
    1:   *aPosition = 0;
    1: 
43129:   nsCOMPtr<nsIDOMElement> rootElement;
43129:   nsresult rv = GetRootNodeAndInitializeEditor(getter_AddRefs(rootElement));
40691:   NS_ENSURE_SUCCESS(rv, rv);
    1:   nsCOMPtr<nsIDOMNode> rootNode(do_QueryInterface(rootElement));
    1: 
    1:   NS_ENSURE_TRUE(rootNode, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1: 
40691:   rv = rootNode->GetChildNodes(getter_AddRefs(nodeList));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(nodeList, NS_ERROR_FAILURE);
    1: 
    1:   PRUint32 length = 0;
    1: 
    1:   rv = nodeList->GetLength(&length);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!length || aOffset < 0) {
    1:     *aPosition = 0;
    1:     *aResult = rootNode;
    1:     NS_ADDREF(*aResult);
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRInt32 textOffset = 0;
    1:   PRUint32 lastIndex = length - 1;
    1: 
    1:   for (PRUint32 i=0; i<length; i++) {
    1:     nsCOMPtr<nsIDOMNode> item;
    1:     rv = nodeList->Item(i, getter_AddRefs(item));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     NS_ENSURE_TRUE(item, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIDOMText> domText(do_QueryInterface(item));
    1: 
    1:     if (domText) {
    1:       PRUint32 textLength = 0;
    1: 
    1:       rv = domText->GetLength(&textLength);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       // Check if aOffset falls within this range.
    1:       if (aOffset >= textOffset && aOffset <= textOffset+(PRInt32)textLength) {
    1:         *aPosition = aOffset - textOffset;
    1:         *aResult = item;
    1:         NS_ADDREF(*aResult);
    1:         return NS_OK;
    1:       }
    1: 
    1:       textOffset += textLength;
    1: 
    1:       // If there aren't any more siblings after this text node,
    1:       // return the point at the end of this text node!
    1: 
    1:       if (i == lastIndex) {
    1:         *aPosition = textLength;
    1:         *aResult = item;
    1:         NS_ADDREF(*aResult);
    1:         return NS_OK;
    1:       }
    1:     }
    1:     else {
    1:       // Must be a BR node, count it as a newline.
    1: 
    1:       if (aOffset == textOffset || i == lastIndex) {
    1:         // We've found the correct position, or aOffset takes us
    1:         // beyond the last child under rootNode, just return the point
    1:         // under rootNode that is in front of this br.
    1: 
    1:         *aPosition = i;
    1:         *aResult = rootNode;
    1:         NS_ADDREF(*aResult);
    1:         return NS_OK;
    1:       }
    1: 
    1:       ++textOffset;
    1:     }
    1:   }
    1: 
31561:   NS_ERROR("We should never get here!");
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::GetSelectionRange(PRInt32* aSelectionStart, PRInt32* aSelectionEnd)
    1: {
    1:   // make sure we have an editor
40691:   nsresult rv = EnsureEditorInitialized();
40691:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *aSelectionStart = 0;
    1:   *aSelectionEnd = 0;
    1: 
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   nsISelectionController* selCon = txtCtrl->GetSelectionController();
43129:   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsISelection> selection;
43129:   rv = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));  
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 numRanges = 0;
    1:   selection->GetRangeCount(&numRanges);
    1: 
    1:   if (numRanges < 1)
    1:     return NS_OK;
    1: 
    1:   // We only operate on the first range in the selection!
    1: 
    1:   nsCOMPtr<nsIDOMRange> firstRange;
    1:   rv = selection->GetRangeAt(0, getter_AddRefs(firstRange));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(firstRange, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:   PRInt32 startOffset = 0, endOffset = 0;
    1: 
    1:   // Get the start point of the range.
    1: 
    1:   rv = firstRange->GetStartContainer(getter_AddRefs(startNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
    1: 
    1:   rv = firstRange->GetStartOffset(&startOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Get the end point of the range.
    1: 
    1:   rv = firstRange->GetEndContainer(getter_AddRefs(endNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   NS_ENSURE_TRUE(endNode, NS_ERROR_FAILURE);
    1: 
    1:   rv = firstRange->GetEndOffset(&endOffset);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Convert the start point to a selection offset.
    1: 
    1:   rv = DOMPointToOffset(startNode, startOffset, aSelectionStart);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Convert the end point to a selection offset.
    1: 
    1:   return DOMPointToOffset(endNode, endOffset, aSelectionEnd);
    1: }
    1: 
    1: /////END INTERFACE IMPLEMENTATIONS
    1: 
    1: ////NSIFRAME
    1: NS_IMETHODIMP
    1: nsTextControlFrame::AttributeChanged(PRInt32         aNameSpaceID,
    1:                                      nsIAtom*        aAttribute,
    1:                                      PRInt32         aModType)
    1: {
40695:   // First, check for the placeholder attribute, because it doesn't
40695:   // depend on the editor being present.
40695:   if (nsGkAtoms::placeholder == aAttribute)
40695:   {
40695:     nsWeakFrame weakFrame(this);
43129:     nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:     NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:     txtCtrl->UpdatePlaceholderText(PR_TRUE);
40695:     NS_ENSURE_STATE(weakFrame.IsAlive());
40695:   }
40695: 
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   nsISelectionController* selCon = txtCtrl->GetSelectionController();
43129:   const PRBool needEditor = nsGkAtoms::maxlength == aAttribute ||
43129:                             nsGkAtoms::readonly == aAttribute ||
46358:                             nsGkAtoms::disabled == aAttribute ||
46358:                             nsGkAtoms::spellcheck == aAttribute;
43412:   nsCOMPtr<nsIEditor> editor;
43129:   if (needEditor) {
43412:     GetEditor(getter_AddRefs(editor));
43129:   }
43129:   if ((needEditor && !editor) || !selCon)
24402:     return nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);;
24402: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (nsGkAtoms::maxlength == aAttribute) 
    1:   {
    1:     PRInt32 maxLength;
    1:     PRBool maxDefined = GetMaxLength(&maxLength);
    1:     
43129:     nsCOMPtr<nsIPlaintextEditor> textEditor = do_QueryInterface(editor);
    1:     if (textEditor)
    1:     {
    1:       if (maxDefined) 
    1:       {  // set the maxLength attribute
    1:           textEditor->SetMaxTextLength(maxLength);
    1:         // if maxLength>docLength, we need to truncate the doc content
    1:       }
    1:       else { // unset the maxLength attribute
    1:           textEditor->SetMaxTextLength(-1);
    1:       }
    1:     }
    1:     rv = NS_OK; // don't propagate the error
    1:   } 
    1:   else if (nsGkAtoms::readonly == aAttribute) 
    1:   {
    1:     PRUint32 flags;
43129:     editor->GetFlags(&flags);
    1:     if (AttributeExists(nsGkAtoms::readonly))
    1:     { // set readonly
    1:       flags |= nsIPlaintextEditor::eEditorReadonlyMask;
43129:       if (nsContentUtils::IsFocusedContent(mContent))
43129:         selCon->SetCaretEnabled(PR_FALSE);
    1:     }
    1:     else 
    1:     { // unset readonly
    1:       flags &= ~(nsIPlaintextEditor::eEditorReadonlyMask);
    1:       if (!(flags & nsIPlaintextEditor::eEditorDisabledMask) &&
43129:           nsContentUtils::IsFocusedContent(mContent))
43129:         selCon->SetCaretEnabled(PR_TRUE);
    1:     }
43129:     editor->SetFlags(flags);
    1:   }
24402:   else if (nsGkAtoms::disabled == aAttribute) 
    1:   {
    1:     PRUint32 flags;
43129:     editor->GetFlags(&flags);
    1:     if (AttributeExists(nsGkAtoms::disabled))
    1:     { // set disabled
    1:       flags |= nsIPlaintextEditor::eEditorDisabledMask;
43129:       selCon->SetDisplaySelection(nsISelectionController::SELECTION_OFF);
43129:       if (nsContentUtils::IsFocusedContent(mContent))
43129:         selCon->SetCaretEnabled(PR_FALSE);
    1:     }
    1:     else 
    1:     { // unset disabled
    1:       flags &= ~(nsIPlaintextEditor::eEditorDisabledMask);
43129:       selCon->SetDisplaySelection(nsISelectionController::SELECTION_HIDDEN);
50633:       if (nsContentUtils::IsFocusedContent(mContent)) {
50633:         selCon->SetCaretEnabled(PR_TRUE);
50633:       }
    1:     }
43129:     editor->SetFlags(flags);
    1:   }
40692:   else if (!mUseEditor && nsGkAtoms::value == aAttribute) {
40692:     UpdateValueDisplay(PR_TRUE);
40692:   }
    1:   // Allow the base class to handle common attributes supported
    1:   // by all form elements... 
    1:   else {
    1:     rv = nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
37971: nsresult
37971: nsTextControlFrame::GetText(nsString& aText)
    1: {
    1:   nsresult rv = NS_OK;
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
    1:   if (IsSingleLineTextControl()) {
48063:     // There will be no line breaks so we can ignore the wrap property.
43129:     txtCtrl->GetTextEditorValue(aText, PR_TRUE);
    1:   } else {
    1:     nsCOMPtr<nsIDOMHTMLTextAreaElement> textArea = do_QueryInterface(mContent);
    1:     if (textArea) {
37971:       rv = textArea->GetValue(aText);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: 
20884: nsresult
    1: nsTextControlFrame::GetPhonetic(nsAString& aPhonetic)
    1: {
    1:   aPhonetic.Truncate(0); 
40691: 
43129:   nsCOMPtr<nsIEditor> editor;
43129:   nsresult rv = GetEditor(getter_AddRefs(editor));
40691:   NS_ENSURE_SUCCESS(rv, rv);
40691: 
43129:   nsCOMPtr<nsIEditorIMESupport> imeSupport = do_QueryInterface(editor);
    1:   if (imeSupport) {
    1:     nsCOMPtr<nsIPhonetic> phonetic = do_QueryInterface(imeSupport);
    1:     if (phonetic)
    1:       phonetic->GetPhonetic(aPhonetic);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: ///END NSIFRAME OVERLOADS
    1: /////BEGIN PROTECTED METHODS
    1: 
    1: PRBool
    1: nsTextControlFrame::GetMaxLength(PRInt32* aSize)
    1: {
    1:   *aSize = -1;
    1: 
    1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
    1:   if (content) {
    1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::maxlength);
    1:     if (attr && attr->Type() == nsAttrValue::eInteger) {
    1:       *aSize = attr->GetIntegerValue();
    1: 
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: // this is where we propagate a content changed event
    1: void
    1: nsTextControlFrame::FireOnInput()
    1: {
    1:   if (!mNotifyOnInput)
    1:     return; // if notification is turned off, do nothing
    1:   
    1:   // Dispatch the "input" event
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsUIEvent event(PR_TRUE, NS_FORM_INPUT, 0);
    1: 
    1:   // Have the content handle the event, propagating it according to normal
    1:   // DOM rules.
  238:   nsCOMPtr<nsIPresShell> shell = PresContext()->PresShell();
   95:   shell->HandleEventWithTarget(&event, nsnull, mContent, &status);
    1: }
    1: 
    1: nsresult
    1: nsTextControlFrame::InitFocusedValue()
    1: {
37971:   return GetText(mFocusedValue);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::CheckFireOnChange()
    1: {
    1:   nsString value;
37971:   GetText(value);
    1:   if (!mFocusedValue.Equals(value))
    1:   {
    1:     mFocusedValue = value;
    1:     // Dispatch the change event
    1:     nsEventStatus status = nsEventStatus_eIgnore;
    1:     nsInputEvent event(PR_TRUE, NS_FORM_CHANGE, nsnull);
  238:     nsCOMPtr<nsIPresShell> shell = PresContext()->PresShell();
   95:     shell->HandleEventWithTarget(&event, nsnull, mContent, &status);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // END IMPLEMENTING NS_IFORMCONTROLFRAME
    1: 
    1: NS_IMETHODIMP
    1: nsTextControlFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                         nsFrameList&    aChildList)
    1: {
    1:   nsresult rv = nsBoxFrame::SetInitialChildList(aListName, aChildList);
24402: 
    1:   nsIFrame* first = GetFirstChild(nsnull);
    1: 
    1:   // Mark the scroll frame as being a reflow root. This will allow
    1:   // incremental reflows to be initiated at the scroll frame, rather
    1:   // than descending from the root frame of the frame hierarchy.
48888:   if (first) {
    1:     first->AddStateBits(NS_FRAME_REFLOW_ROOT);
48888:   }
    1: 
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   txtCtrl->InitializeKeyboardEventListeners();
    1:   return rv;
    1: }
    1: 
    1: PRBool
    1: nsTextControlFrame::IsScrollable() const
    1: {
    1:   return !IsSingleLineTextControl();
    1: }
    1: 
    1: void
    1: nsTextControlFrame::SetValueChanged(PRBool aValueChanged)
    1: {
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   txtCtrl->SetValueChanged(aValueChanged);
    1: }
    1: 
40692: 
40692: nsresult
40692: nsTextControlFrame::UpdateValueDisplay(PRBool aNotify,
40692:                                        PRBool aBeforeEditorInit,
40692:                                        const nsAString *aValue)
40692: {
40692:   if (!IsSingleLineTextControl()) // textareas don't use this
40692:     return NS_OK;
40692: 
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129:   nsIContent* rootNode = txtCtrl->GetRootEditorNode();
43129: 
43129:   NS_PRECONDITION(rootNode, "Must have a div content\n");
40692:   NS_PRECONDITION(!mUseEditor,
40692:                   "Do not call this after editor has been initialized");
43129:   NS_ASSERTION(txtCtrl->GetPlaceholderNode(), "A placeholder div must exist");
40692: 
43129:   nsIContent *textContent = rootNode->GetChildAt(0);
41322:   if (!textContent) {
41322:     // Set up a textnode with our value
41322:     nsCOMPtr<nsIContent> textNode;
41322:     nsresult rv = NS_NewTextNode(getter_AddRefs(textNode),
41322:                                  mContent->NodeInfo()->NodeInfoManager());
41322:     NS_ENSURE_SUCCESS(rv, rv);
41322: 
41322:     NS_ASSERTION(textNode, "Must have textcontent!\n");
41322: 
43129:     rootNode->AppendChildTo(textNode, aNotify);
41322:     textContent = textNode;
40692:   }
40692: 
41322:   NS_ENSURE_TRUE(textContent, NS_ERROR_UNEXPECTED);
41322: 
40692:   // Get the current value of the textfield from the content.
40692:   nsAutoString value;
40692:   if (aValue) {
40692:     value = *aValue;
40692:   } else {
43129:     txtCtrl->GetTextEditorValue(value, PR_TRUE);
40692:   }
40692: 
40695:   // Update the display of the placeholder value if needed.
40736:   // We don't need to do this if we're about to initialize the
40736:   // editor, since EnsureEditorInitialized takes care of this.
40736:   if (!aBeforeEditorInit)
40695:   {
40695:     nsWeakFrame weakFrame(this);
43129:     txtCtrl->SetPlaceholderClass(value.IsEmpty(), aNotify);
40695:     NS_ENSURE_STATE(weakFrame.IsAlive());
40695:   }
40695: 
40692:   if (aBeforeEditorInit && value.IsEmpty()) {
43129:     rootNode->RemoveChildAt(0, PR_TRUE, PR_FALSE);
40692:     return NS_OK;
40692:   }
40692: 
41322:   if (!value.IsEmpty() && IsPasswordTextControl()) {
41322:     nsTextEditRules::FillBufWithPWChars(&value, value.Length());
40692:   }
41322:   return textContent->SetText(value, aNotify);
40692: }
40692: 
43129: NS_IMETHODIMP
43129: nsTextControlFrame::GetOwnedSelectionController(nsISelectionController** aSelCon)
43129: {
43129:   NS_ENSURE_ARG_POINTER(aSelCon);
40692: 
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
37971: 
43129:   *aSelCon = txtCtrl->GetSelectionController();
43129:   NS_IF_ADDREF(*aSelCon);
38754: 
38754:   return NS_OK;
38754: }
38754: 
43129: nsFrameSelection*
43129: nsTextControlFrame::GetOwnedFrameSelection()
38754: {
43129:   nsCOMPtr<nsITextControlElement> txtCtrl = do_QueryInterface(GetContent());
43129:   NS_ASSERTION(txtCtrl, "Content not a text control element");
43129: 
43129:   return txtCtrl->GetConstFrameSelection();
38754: }
38754: 
