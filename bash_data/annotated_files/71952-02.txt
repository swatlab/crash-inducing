69269: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
69269:  * vim: sw=2 ts=8 et :
69269:  */
69269: /* ***** BEGIN LICENSE BLOCK *****
69269:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
69269:  *
69269:  * The contents of this file are subject to the Mozilla Public License Version
69269:  * 1.1 (the "License"); you may not use this file except in compliance with
69269:  * the License. You may obtain a copy of the License at:
69269:  * http://www.mozilla.org/MPL/
69269:  *
69269:  * Software distributed under the License is distributed on an "AS IS" basis,
69269:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
69269:  * for the specific language governing rights and limitations under the
69269:  * License.
69269:  *
69269:  * The Original Code is Mozilla Code.
69269:  *
69269:  * The Initial Developer of the Original Code is
69269:  *   The Mozilla Foundation
69269:  * Portions created by the Initial Developer are Copyright (C) 2010
69269:  * the Initial Developer. All Rights Reserved.
69269:  *
69269:  * Contributor(s):
69269:  *
69269:  * Alternatively, the contents of this file may be used under the terms of
69269:  * either the GNU General Public License Version 2 or later (the "GPL"), or
69269:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
69269:  * in which case the provisions of the GPL or the LGPL are applicable instead
69269:  * of those above. If you wish to allow use of your version of this file only
69269:  * under the terms of either the GPL or the LGPL, and not to allow others to
69269:  * use your version of this file under the terms of the MPL, indicate your
69269:  * decision by deleting the provisions above and replace them with the notice
69269:  * and other provisions required by the GPL or the LGPL. If you do not delete
69269:  * the provisions above, a recipient may use your version of this file under
69269:  * the terms of any one of the MPL, the GPL or the LGPL.
69269:  *
69269:  * ***** END LICENSE BLOCK ***** */
69269: 
69269: 
69269: //////////////////////////////////////////////////////////////////////////////
69269: //
69269: // Explanation: See bug 639842. Safely getting GL driver info on X11 is hard, because the only way to do
69269: // that is to create a GL context and call glGetString(), but with bad drivers,
69269: // just creating a GL context may crash.
69269: //
69269: // This file implements the idea to do that in a separate process.
69269: //
69269: // The only non-static function here is fire_glxtest_process(). It creates a pipe, publishes its 'read' end as the
69269: // mozilla::widget::glxtest_pipe global variable, forks, and runs that GLX probe in the child process,
69269: // which runs the glxtest() static function. This creates a X connection, a GLX context, calls glGetString, and writes that
69269: // to the 'write' end of the pipe.
69269: 
69269: #include <cstdio>
69269: #include <cstdlib>
69269: #include <unistd.h>
69269: #include <GL/gl.h>
69269: #include <GL/glx.h>
69269: #include <dlfcn.h>
69269: #include "nscore.h"
69269: 
69269: namespace mozilla {
69269: namespace widget {
69269: // the read end of the pipe, which will be used by GfxInfo
69269: extern int glxtest_pipe;
69269: // the PID of the glxtest process, to pass to waitpid()
69269: extern pid_t glxtest_pid;
69269: }
69269: }
69269: 
69269: // the write end of the pipe, which we're going to write to
69269: static int write_end_of_the_pipe = -1;
69269: 
69269: // C++ standard collides with C standard in that it doesn't allow casting void* to function pointer types.
69269: // So the work-around is to convert first to size_t.
69269: // http://www.trilithium.com/johan/2004/12/problem-with-dlsym/
69269: template<typename func_ptr_type>
69269: static func_ptr_type cast(void *ptr)
69269: {
69269:   return reinterpret_cast<func_ptr_type>(
69269:            reinterpret_cast<size_t>(ptr)
69269:          );
69269: }
69269: 
69269: static void fatal_error(const char *str)
69269: {
69269:   write(write_end_of_the_pipe, str, strlen(str));
69269:   write(write_end_of_the_pipe, "\n", 1);
69269:   exit(EXIT_FAILURE);
69269: }
69269: 
69269: static int
69269: x_error_handler(Display *, XErrorEvent *ev)
69269: {
69269:   enum { bufsize = 1024 };
69269:   char buf[bufsize];
69269:   int length = snprintf(buf, bufsize,
69269:                         "X error occurred in GLX probe, error_code=%d, request_code=%d, minor_code=%d\n",
69269:                         ev->error_code,
69269:                         ev->request_code,
69269:                         ev->minor_code);
69269:   write(write_end_of_the_pipe, buf, length);
69269:   exit(EXIT_FAILURE);
69269:   return 0;
69269: }
69269: 
69269: static void glxtest()
69269: {
69269:   ///// Open libGL and load needed symbols /////
69269:   void *libgl = dlopen("libGL.so.1", RTLD_LAZY);
69269:   if (!libgl)
69269:     fatal_error("Unable to load libGL.so.1");
69269: 
69269:   typedef GLXFBConfig* (* PFNGLXQUERYEXTENSION) (Display *, int *, int *);
69269:   PFNGLXQUERYEXTENSION glXQueryExtension = cast<PFNGLXQUERYEXTENSION>(dlsym(libgl, "glXQueryExtension"));
69269: 
69269:   typedef GLXFBConfig* (* PFNGLXCHOOSEFBCONFIG) (Display *, int, const int *, int *);
69269:   PFNGLXCHOOSEFBCONFIG glXChooseFBConfig = cast<PFNGLXCHOOSEFBCONFIG>(dlsym(libgl, "glXChooseFBConfig"));
69269: 
69269:   typedef XVisualInfo* (* PFNGLXGETVISUALFROMFBCONFIG) (Display *, GLXFBConfig);
69269:   PFNGLXGETVISUALFROMFBCONFIG glXGetVisualFromFBConfig = cast<PFNGLXGETVISUALFROMFBCONFIG>(dlsym(libgl, "glXGetVisualFromFBConfig"));
69269: 
69269:   typedef GLXPixmap (* PFNGLXCREATEPIXMAP) (Display *, GLXFBConfig, Pixmap, const int *);
69269:   PFNGLXCREATEPIXMAP glXCreatePixmap = cast<PFNGLXCREATEPIXMAP>(dlsym(libgl, "glXCreatePixmap"));
69269: 
69269:   typedef GLXContext (* PFNGLXCREATENEWCONTEXT) (Display *, GLXFBConfig, int, GLXContext, Bool);
69269:   PFNGLXCREATENEWCONTEXT glXCreateNewContext = cast<PFNGLXCREATENEWCONTEXT>(dlsym(libgl, "glXCreateNewContext"));
69269: 
69269:   typedef Bool (* PFNGLXMAKECURRENT) (Display*, GLXDrawable, GLXContext);
69269:   PFNGLXMAKECURRENT glXMakeCurrent = cast<PFNGLXMAKECURRENT>(dlsym(libgl, "glXMakeCurrent"));
69269: 
69269:   typedef void (* PFNGLXDESTROYPIXMAP) (Display *, GLXPixmap);
69269:   PFNGLXDESTROYPIXMAP glXDestroyPixmap = cast<PFNGLXDESTROYPIXMAP>(dlsym(libgl, "glXDestroyPixmap"));
69269: 
69269:   typedef void (* PFNGLXDESTROYCONTEXT) (Display*, GLXContext);
69269:   PFNGLXDESTROYCONTEXT glXDestroyContext = cast<PFNGLXDESTROYCONTEXT>(dlsym(libgl, "glXDestroyContext"));
69269: 
69269:   typedef GLubyte* (* PFNGLGETSTRING) (GLenum);
69269:   PFNGLGETSTRING glGetString = cast<PFNGLGETSTRING>(dlsym(libgl, "glGetString"));
69269: 
69269:   if (!glXQueryExtension ||
69269:       !glXChooseFBConfig ||
69269:       !glXGetVisualFromFBConfig ||
69269:       !glXCreatePixmap ||
69269:       !glXCreateNewContext ||
69269:       !glXMakeCurrent ||
69269:       !glXDestroyPixmap ||
69269:       !glXDestroyContext ||
69269:       !glGetString)
69269:   {
69269:     fatal_error("Unable to find required symbols in libGL.so.1");
69269:   }
69269:   ///// Open a connection to the X server /////
69269:   Display *dpy = XOpenDisplay(NULL);
69269:   if (!dpy)
69269:     fatal_error("Unable to open a connection to the X server");
69269:   
69269:   ///// Check that the GLX extension is present /////
69269:   if (!glXQueryExtension(dpy, NULL, NULL))
69269:     fatal_error("GLX extension missing");
69269: 
69269:   XSetErrorHandler(x_error_handler);
69269: 
69269:   ///// Get a FBConfig and a visual /////
69269:   int attribs[] = {
69269:     GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
69269:     GLX_X_RENDERABLE, True,
69269:     0
69269:   };
69269:   int numReturned;
69269:   GLXFBConfig *fbConfigs = glXChooseFBConfig(dpy, DefaultScreen(dpy), attribs, &numReturned );
71573:   if (!fbConfigs)
71573:     fatal_error("No FBConfigs found");
69269:   XVisualInfo *vInfo = glXGetVisualFromFBConfig(dpy, fbConfigs[0]);
71574:   if (!vInfo)
71574:     fatal_error("No visual found for first FBConfig");
69269: 
69269:   ///// Get a Pixmap and a GLXPixmap /////
69269:   Pixmap pixmap = XCreatePixmap(dpy, RootWindow(dpy, vInfo->screen), 4, 4, 32);
69269:   GLXPixmap glxpixmap = glXCreatePixmap(dpy, fbConfigs[0], pixmap, NULL);
69269: 
69269:   ///// Get a GL context and make it current //////
69269:   GLXContext context = glXCreateNewContext(dpy, fbConfigs[0], GLX_RGBA_TYPE, NULL, True);
69269:   glXMakeCurrent(dpy, glxpixmap, context);
69269: 
69269:   ///// Get GL vendor/renderer/versions strings /////
69269:   enum { bufsize = 1024 };
69269:   char buf[bufsize];
69269:   const GLubyte *vendorString = glGetString(GL_VENDOR);
69269:   const GLubyte *rendererString = glGetString(GL_RENDERER);
69269:   const GLubyte *versionString = glGetString(GL_VERSION);
69269:   
69269:   if (!vendorString || !rendererString || !versionString)
69269:     fatal_error("glGetString returned null");
69269: 
69269:   int length = snprintf(buf, bufsize,
69269:                         "VENDOR\n%s\nRENDERER\n%s\nVERSION\n%s\n",
69269:                         vendorString,
69269:                         rendererString,
69269:                         versionString);
69269:   if (length >= bufsize)
69269:     fatal_error("GL strings length too large for buffer size");
69269: 
69269:   ///// Check that no X error happened /////
69269:   // In case of X errors, our X error handler will exit() now.
69269:   // We really want to make sure that the system is able to create a GL context without generating X errors,
69269:   // as these would crash the application.
69269:   XSync(dpy, False);
69269:   
69269:   ///// Finally write data to the pipe /////
69269:   write(write_end_of_the_pipe, buf, length);
69269: 
69269:   ///// Clean up. Indeed, the parent process might fail to kill us (e.g. if it doesn't need to check GL info)
69269:   ///// so we might be staying alive for longer than expected, so it's important to consume as little memory as
71948:   ///// possible. Also we want to check that we're able to do that too without generating X errors.
71948:   glXMakeCurrent(dpy, None, NULL); // must release the GL context before destroying it
71952:   glXDestroyContext(dpy, context);
69269:   glXDestroyPixmap(dpy, glxpixmap);
69269:   XFreePixmap(dpy, pixmap);
69269:   XCloseDisplay(dpy);
69269:   dlclose(libgl);
69269: }
69269: 
71575: /** \returns true in the child glxtest process, false in the parent process */
71575: bool fire_glxtest_process()
69269: {
69269:   int pfd[2];
69269:   if (pipe(pfd) == -1) {
69269:       perror("pipe");
71575:       return false;
69269:   }
69269:   pid_t pid = fork();
69269:   if (pid < 0) {
69269:       perror("fork");
71575:       close(pfd[0]);
71575:       close(pfd[1]);
71575:       return false;
69269:   }
69269:   if (pid == 0) {
69269:       close(pfd[0]);
69269:       write_end_of_the_pipe = pfd[1];
69269:       glxtest();
69269:       close(pfd[1]);
71575:       return true;
69269:   }
69269: 
69269:   close(pfd[1]);
69269:   mozilla::widget::glxtest_pipe = pfd[0];
69269:   mozilla::widget::glxtest_pid = pid;
71575:   return false;
69269: }
