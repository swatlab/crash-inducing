 47525: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 47525:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
 47525:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 47525: 
105453: #include "WaiveXrayWrapper.h"
 47574: #include "FilteringWrapper.h"
 47574: #include "XrayWrapper.h"
 47525: #include "AccessCheck.h"
 55628: #include "XPCWrapper.h"
106723: #include "ChromeObjectWrapper.h"
144609: #include "WrapperFactory.h"
 47525: 
 47574: #include "xpcprivate.h"
 80384: #include "XPCMaps.h"
 97422: #include "mozilla/dom/BindingUtils.h"
 87284: #include "jsfriendapi.h"
 99716: #include "mozilla/Likely.h"
131970: #include "nsContentUtils.h"
 86985: 
159052: using namespace JS;
 79386: using namespace js;
126636: using namespace mozilla;
 79386: 
 47525: namespace xpc {
 47525: 
 47574: // When chrome pulls a naked property across the membrane using
 47574: // .wrappedJSObject, we want it to cross the membrane into the
 47574: // chrome compartment without automatically being wrapped into an
 47574: // X-ray wrapper. We achieve this by wrapping it into a special
 47574: // transparent wrapper in the origin (non-chrome) compartment. When
 47574: // an object with that special wrapper applied crosses into chrome,
 47574: // we know to not apply an X-ray wrapper.
120327: Wrapper XrayWaiver(WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG);
 47574: 
 47574: // When objects for which we waived the X-ray wrapper cross into
 47574: // chrome, we wrap them into a special cross-compartment wrapper
 47574: // that transitively extends the waiver to all properties we get
 47574: // off it.
105449: WaiveXrayWrapper WaiveXrayWrapper::singleton(0);
 55691: 
137025: bool
137025: WrapperFactory::IsCOW(JSObject *obj)
137025: {
137025:     return IsWrapper(obj) &&
137025:            Wrapper::wrapperHandler(obj) == &ChromeObjectWrapper::singleton;
137025: }
137025: 
 47574: JSObject *
106124: WrapperFactory::GetXrayWaiver(JSObject *obj)
106124: {
106124:     // Object should come fully unwrapped but outerized.
140272:     MOZ_ASSERT(obj == UncheckedUnwrap(obj));
106124:     MOZ_ASSERT(!js::GetObjectClass(obj)->ext.outerObject);
120051:     XPCWrappedNativeScope *scope = GetObjectScope(obj);
120049:     MOZ_ASSERT(scope);
106124: 
120049:     if (!scope->mWaiverWrapperMap)
106124:         return NULL;
159934: 
159934:     JSObject* xrayWaiver = scope->mWaiverWrapperMap->Find(obj);
159934:     if (xrayWaiver)
159934:         JS::ExposeObjectToActiveJS(xrayWaiver);
159934: 
159934:     return xrayWaiver;
106124: }
106124: 
106124: JSObject *
140359: WrapperFactory::CreateXrayWaiver(JSContext *cx, HandleObject obj)
106124: {
106124:     // The caller is required to have already done a lookup.
106124:     // NB: This implictly performs the assertions of GetXrayWaiver.
106124:     MOZ_ASSERT(!GetXrayWaiver(obj));
120051:     XPCWrappedNativeScope *scope = GetObjectScope(obj);
106124: 
106124:     // Get a waiver for the proto.
141365:     RootedObject proto(cx);
142622:     if (!js::GetObjectProto(cx, obj, &proto))
115022:         return nullptr;
106124:     if (proto && !(proto = WaiveXray(cx, proto)))
106838:         return nullptr;
106124: 
106124:     // Create the waiver.
109257:     JSAutoCompartment ac(cx, obj);
141365:     if (!JS_WrapObject(cx, proto.address()))
106838:         return nullptr;
106124:     JSObject *waiver = Wrapper::New(cx, obj, proto,
106124:                                     JS_GetGlobalForObject(cx, obj),
106124:                                     &XrayWaiver);
106124:     if (!waiver)
106838:         return nullptr;
106124: 
106124:     // Add the new waiver to the map. It's important that we only ever have
106124:     // one waiver for the lifetime of the target object.
120049:     if (!scope->mWaiverWrapperMap) {
120049:         scope->mWaiverWrapperMap =
120049:           JSObject2JSObjectMap::newMap(XPC_WRAPPER_MAP_SIZE);
120049:         MOZ_ASSERT(scope->mWaiverWrapperMap);
106124:     }
150286:     if (!scope->mWaiverWrapperMap->Add(cx, obj, waiver))
106838:         return nullptr;
106124:     return waiver;
106124: }
106124: 
106124: JSObject *
140359: WrapperFactory::WaiveXray(JSContext *cx, JSObject *objArg)
 60580: {
140359:     RootedObject obj(cx, objArg);
140272:     obj = UncheckedUnwrap(obj);
131422:     MOZ_ASSERT(!js::IsInnerObject(obj));
 60580: 
106124:     JSObject *waiver = GetXrayWaiver(obj);
106124:     if (waiver)
106124:         return waiver;
106124:     return CreateXrayWaiver(cx, obj);
 60580: }
 60580: 
 71303: // DoubleWrap is called from PrepareForWrapping to maintain the state that
 71303: // we're supposed to waive Xray wrappers for the given on. On entrance, it
 71303: // expects |cx->compartment != obj->compartment()|. The returned object will
 71303: // be in the same compartment as |obj|.
 60580: JSObject *
140359: WrapperFactory::DoubleWrap(JSContext *cx, HandleObject obj, unsigned flags)
 60580: {
 60580:     if (flags & WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG) {
109257:         JSAutoCompartment ac(cx, obj);
 60580:         return WaiveXray(cx, obj);
 60580:     }
 60580:     return obj;
 60580: }
 60580: 
 60580: JSObject *
140715: WrapperFactory::PrepareForWrapping(JSContext *cx, HandleObject scope,
140715:                                    HandleObject objArg, unsigned flags)
 55628: {
140359:     RootedObject obj(cx, objArg);
131422:     // Outerize any raw inner objects at the entry point here, so that we don't
131422:     // have to worry about them for the rest of the wrapping code.
131422:     if (js::IsInnerObject(obj)) {
131422:         JSAutoCompartment ac(cx, obj);
131422:         obj = JS_ObjectToOuterObject(cx, obj);
131422:         NS_ENSURE_TRUE(obj, nullptr);
131422:         // The outerization hook wraps, which means that we can end up with a
131422:         // CCW here if |obj| was a navigated-away-from inner. Strip any CCWs.
140272:         obj = js::UncheckedUnwrap(obj);
131422:         MOZ_ASSERT(js::IsOuterObject(obj));
131422:     }
131422: 
131422:     // If we've got an outer window, there's nothing special that needs to be
131422:     // done here, and we can move on to the next phase of wrapping. We handle
131422:     // this case first to allow us to assert against wrappers below.
131422:     if (js::IsOuterObject(obj))
 55691:         return DoubleWrap(cx, obj, flags);
 55691: 
 55628:     // Here are the rules for wrapping:
 55628:     // We should never get a proxy here (the JS engine unwraps those for us).
114348:     MOZ_ASSERT(!IsWrapper(obj));
 55628: 
144426:     // If the object being wrapped is a prototype for a standard class and the
144426:     // wrapper does not subsumes the wrappee, use the one from the content
144426:     // compartment. This is generally safer all-around, and in the COW case this
144426:     // lets us safely take advantage of things like .forEach() via the
144426:     // ChromeObjectWrapper machinery.
144426:     //
144426:     // If the prototype chain of chrome object |obj| looks like this:
144426:     //
144426:     // obj => foo => bar => chromeWin.StandardClass.prototype
144426:     //
144426:     // The prototype chain of COW(obj) looks lke this:
144426:     //
144426:     // COW(obj) => COW(foo) => COW(bar) => contentWin.StandardClass.prototype
144426:     //
144426:     // NB: We now remap all non-subsuming access of standard prototypes.
144872:     //
144872:     // NB: We need to ignore domain here so that the security relationship we
144872:     // compute here can't change over time. See the comment above the other
144872:     // subsumesIgnoringDomain call below.
144872:     bool subsumes = AccessCheck::subsumesIgnoringDomain(js::GetContextCompartment(cx),
144426:                                                         js::GetObjectCompartment(obj));
144426:     XrayType xrayType = GetXrayType(obj);
144426:     if (!subsumes && xrayType == NotXray) {
144426:         JSProtoKey key = JSProto_Null;
144426:         {
144426:             JSAutoCompartment ac(cx, obj);
144426:             key = JS_IdentifyClassPrototype(cx, obj);
144426:         }
144426:         if (key != JSProto_Null) {
144426:             RootedObject homeProto(cx);
144426:             if (!JS_GetClassPrototype(cx, key, homeProto.address()))
144426:                 return nullptr;
144426:             MOZ_ASSERT(homeProto);
144426:             // No need to double-wrap here. We should never have waivers to
144426:             // COWs.
144426:             return homeProto;
144426:         }
144426:     }
144426: 
 55628:     // Now, our object is ready to be wrapped, but several objects (notably
 55628:     // nsJSIIDs) have a wrapper per scope. If we are about to wrap one of
 55628:     // those objects in a security wrapper, then we need to hand back the
 55689:     // wrapper for the new scope instead. Also, global objects don't move
 55689:     // between scopes so for those we also want to return the wrapper. So...
147439:     if (!IS_WN_REFLECTOR(obj) || !js::GetObjectParent(obj))
 55691:         return DoubleWrap(cx, obj, flags);
 55628: 
148511:     XPCWrappedNative *wn = XPCWrappedNative::Get(obj);
 55628: 
109257:     JSAutoCompartment ac(cx, obj);
 55628:     XPCCallContext ccx(JS_CALLER, cx, obj);
140715:     RootedObject wrapScope(cx, scope);
 62582: 
 62582:     {
 55628:         if (NATIVE_HAS_FLAG(&ccx, WantPreCreate)) {
 55628:             // We have a precreate hook. This object might enforce that we only
 55628:             // ever create JS object for it.
 99716: 
 99716:             // Note: this penalizes objects that only have one wrapper, but are
 99716:             // being accessed across compartments. We would really prefer to
 99716:             // replace the above code with a test that says "do you only have one
 99716:             // wrapper?"
 55628:             nsresult rv = wn->GetScriptableInfo()->GetCallback()->
140715:                 PreCreate(wn->Native(), cx, scope, wrapScope.address());
 55691:             NS_ENSURE_SUCCESS(rv, DoubleWrap(cx, obj, flags));
 55628: 
 55628:             // If the handed back scope differs from the passed-in scope and is in
 55628:             // a separate compartment, then this object is explicitly requesting
 55628:             // that we don't create a second JS object for it: create a security
 55628:             // wrapper.
140715:             if (js::GetObjectCompartment(scope) != js::GetObjectCompartment(wrapScope))
 55691:                 return DoubleWrap(cx, obj, flags);
 55628: 
140359:             RootedObject currentScope(cx, JS_GetGlobalForObject(cx, obj));
140715:             if (MOZ_UNLIKELY(wrapScope != currentScope)) {
 99716:                 // The wrapper claims it wants to be in the new scope, but
 99716:                 // currently has a reflection that lives in the old scope. This
 99716:                 // can mean one of two things, both of which are rare:
 99716:                 //
 99716:                 // 1 - The object has a PreCreate hook (we checked for it above),
 99716:                 // but is deciding to request one-wrapper-per-scope (rather than
 99716:                 // one-wrapper-per-native) for some reason. Usually, a PreCreate
 99716:                 // hook indicates one-wrapper-per-native. In this case we want to
 99716:                 // make a new wrapper in the new scope.
 99716:                 //
 99716:                 // 2 - We're midway through wrapper reparenting. The document has
 99716:                 // moved to a new scope, but |wn| hasn't been moved yet, and
 99716:                 // we ended up calling JS_WrapObject() on its JS object. In this
 99716:                 // case, we want to return the existing wrapper.
 99716:                 //
 99716:                 // So we do a trick: call PreCreate _again_, but say that we're
 99716:                 // wrapping for the old scope, rather than the new one. If (1) is
 99716:                 // the case, then PreCreate will return the scope we pass to it
 99716:                 // (the old scope). If (2) is the case, PreCreate will return the
 99716:                 // scope of the document (the new scope).
140359:                 RootedObject probe(cx);
 99716:                 rv = wn->GetScriptableInfo()->GetCallback()->
140359:                     PreCreate(wn->Native(), cx, currentScope, probe.address());
 99716: 
 99716:                 // Check for case (2).
 99716:                 if (probe != currentScope) {
140715:                     MOZ_ASSERT(probe == wrapScope);
 99716:                     return DoubleWrap(cx, obj, flags);
 99716:                 }
 99716: 
 99716:                 // Ok, must be case (1). Fall through and create a new wrapper.
 99716:             }
108561: 
108561:             // Nasty hack for late-breaking bug 781476. This will confuse identity checks,
108561:             // but it's probably better than any of our alternatives.
113680:             //
113680:             // Note: We have to ignore domain here. The JS engine assumes that, given a
113680:             // compartment c, if c->wrap(x) returns a cross-compartment wrapper at time t0,
113680:             // it will also return a cross-compartment wrapper for any time t1 > t0 unless
113680:             // an explicit transplant is performed. In particular, wrapper recomputation
113680:             // assumes that recomputing a wrapper will always result in a wrapper.
113680:             //
113680:             // This doesn't actually pose a security issue, because we'll still compute
113680:             // the correct (opaque) wrapper for the object below given the security
113680:             // characteristics of the two compartments.
140715:             if (!AccessCheck::isChrome(js::GetObjectCompartment(wrapScope)) &&
140715:                  AccessCheck::subsumesIgnoringDomain(js::GetObjectCompartment(wrapScope),
108561:                                                      js::GetObjectCompartment(obj)))
108561:             {
108561:                 return DoubleWrap(cx, obj, flags);
108561:             }
 55628:         }
 62405:     }
 55628: 
 56818:     // NB: Passing a holder here inhibits slim wrappers under
 56818:     // WrapNativeToJSVal.
 56818:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
 62582: 
140715:     // This public WrapNativeToJSVal API enters the compartment of 'wrapScope'
 62582:     // so we don't have to.
140359:     RootedValue v(cx);
 55628:     nsresult rv =
146064:         nsXPConnect::XPConnect()->WrapNativeToJSVal(cx, wrapScope, wn->Native(), nullptr,
 80486:                                                     &NS_GET_IID(nsISupports), false,
140359:                                                     v.address(), getter_AddRefs(holder));
146294:     NS_ENSURE_SUCCESS(rv, nullptr);
146294: 
 55691:     obj = JSVAL_TO_OBJECT(v);
156319:     MOZ_ASSERT(IS_WN_REFLECTOR(obj), "bad object");
 56818: 
 93361:     // Because the underlying native didn't have a PreCreate hook, we had
 93361:     // to a new (or possibly pre-existing) XPCWN in our compartment.
 93361:     // This could be a problem for chrome code that passes XPCOM objects
 93361:     // across compartments, because the effects of QI would disappear across
 93361:     // compartments.
 93361:     //
 93361:     // So whenever we pull an XPCWN across compartments in this manner, we
 93361:     // give the destination object the union of the two native sets. We try
 93361:     // to do this cleverly in the common case to avoid too much overhead.
148511:     XPCWrappedNative *newwn = XPCWrappedNative::Get(obj);
146401:     XPCNativeSet *unionSet = XPCNativeSet::GetNewOrUsed(newwn->GetSet(),
 93361:                                                         wn->GetSet(), false);
 93361:     if (!unionSet)
106838:         return nullptr;
 93361:     newwn->SetSet(unionSet);
 56818: 
 55691:     return DoubleWrap(cx, obj, flags);
 55628: }
 55628: 
121897: #ifdef DEBUG
121897: static void
143131: DEBUG_CheckUnwrapSafety(HandleObject obj, js::Wrapper *handler,
121897:                         JSCompartment *origin, JSCompartment *target)
121897: {
121897:     if (AccessCheck::isChrome(target) || xpc::IsUniversalXPConnectEnabled(target)) {
121897:         // If the caller is chrome (or effectively so), unwrap should always be allowed.
121897:         MOZ_ASSERT(handler->isSafeToUnwrap());
142875:     } else if (WrapperFactory::IsComponentsObject(obj)) {
131970:         // The Components object that is restricted regardless of origin.
121897:         MOZ_ASSERT(!handler->isSafeToUnwrap());
164666:     } else if (AccessCheck::needsSystemOnlyWrapper(obj)) {
164666:         // The rules for SOWs are complicated enough. Just skip double-checking them here.
139305:     } else if (handler == &FilteringWrapper<CrossCompartmentSecurityWrapper, GentlyOpaque>::singleton) {
139305:         // We explicitly use a SecurityWrapper to protect privileged callers from
139305:         // less-privileged objects that they should never see. Skip the check in
139305:         // this case.
121897:     } else {
121897:         // Otherwise, it should depend on whether the target subsumes the origin.
121897:         MOZ_ASSERT(handler->isSafeToUnwrap() == AccessCheck::subsumes(target, origin));
121897:     }
121897: }
121897: #else
121897: #define DEBUG_CheckUnwrapSafety(obj, handler, origin, target) {}
121897: #endif
121897: 
130229: static Wrapper *
130229: SelectWrapper(bool securityWrapper, bool wantXrays, XrayType xrayType,
130229:               bool waiveXrays)
130229: {
130229:     // Waived Xray uses a modified CCW that has transparent behavior but
130229:     // transitively waives Xrays on arguments.
130229:     if (waiveXrays) {
130229:         MOZ_ASSERT(!securityWrapper);
130229:         return &WaiveXrayWrapper::singleton;
130229:     }
130229: 
130229:     // If we don't want or can't use Xrays, select a wrapper that's either
130229:     // entirely transparent or entirely opaque.
130229:     if (!wantXrays || xrayType == NotXray) {
130229:         if (!securityWrapper)
130229:             return &CrossCompartmentWrapper::singleton;
130229:         return &FilteringWrapper<CrossCompartmentSecurityWrapper, Opaque>::singleton;
130229:     }
130229: 
130229:     // Ok, we're using Xray. If this isn't a security wrapper, use the permissive
130229:     // version and skip the filter.
130229:     if (!securityWrapper) {
130229:         if (xrayType == XrayForWrappedNative)
130229:             return &PermissiveXrayXPCWN::singleton;
130229:         return &PermissiveXrayDOM::singleton;
130229:     }
130229: 
130229:     // This is a security wrapper. Use the security versions and filter.
130229:     if (xrayType == XrayForWrappedNative)
130229:         return &FilteringWrapper<SecurityXrayXPCWN,
130229:                                  CrossOriginAccessiblePropertiesOnly>::singleton;
130229:     return &FilteringWrapper<SecurityXrayDOM,
130229:                              CrossOriginAccessiblePropertiesOnly>::singleton;
130229: }
130229: 
 55628: JSObject *
140715: WrapperFactory::Rewrap(JSContext *cx, HandleObject existing, HandleObject obj,
140715:                        HandleObject wrappedProto, HandleObject parent,
 91237:                        unsigned flags)
 47525: {
130221:     MOZ_ASSERT(!IsWrapper(obj) ||
105455:                GetProxyHandler(obj) == &XrayWaiver ||
 79734:                js::GetObjectClass(obj)->ext.innerObject,
 54404:                "wrapped object passed to rewrap");
130221:     MOZ_ASSERT(JS_GetClass(obj) != &XrayUtils::HolderClass, "trying to wrap a holder");
131422:     MOZ_ASSERT(!js::IsInnerObject(obj));
134277:     // We sometimes end up here after nsContentUtils has been shut down but before
134277:     // XPConnect has been shut down, so check the context stack the roundabout way.
134277:     MOZ_ASSERT(XPCJSRuntime::Get()->GetJSContextStack()->Peek() == cx);
 47574: 
130226:     // Compute the information we need to select the right wrapper.
 79734:     JSCompartment *origin = js::GetObjectCompartment(obj);
 87284:     JSCompartment *target = js::GetContextCompartment(cx);
130226:     bool originIsChrome = AccessCheck::isChrome(origin);
130226:     bool targetIsChrome = AccessCheck::isChrome(target);
130226:     bool originSubsumesTarget = AccessCheck::subsumes(origin, target);
130226:     bool targetSubsumesOrigin = AccessCheck::subsumes(target, origin);
130226:     bool sameOrigin = targetSubsumesOrigin && originSubsumesTarget;
130226:     XrayType xrayType = GetXrayType(obj);
139305:     bool waiveXrayFlag = flags & WAIVE_XRAY_WRAPPER_FLAG;
 47574: 
106722:     // By default we use the wrapped proto of the underlying object as the
106722:     // prototype for our wrapper, but we may select something different below.
140359:     RootedObject proxyProto(cx, wrappedProto);
106722: 
 79386:     Wrapper *wrapper;
130224:     CompartmentPrivate *targetdata = EnsureCompartmentPrivate(target);
130228: 
130228:     //
130228:     // First, handle the special cases.
130228:     //
130228: 
130228:     // If UniversalXPConnect is enabled, this is just some dumb mochitest. Use
130228:     // a vanilla CCW.
130228:     if (xpc::IsUniversalXPConnectEnabled(target)) {
130228:         wrapper = &CrossCompartmentWrapper::singleton;
130228: 
130228:     // If this is a chrome object being exposed to content without Xrays, use
130228:     // a COW.
130228:     } else if (originIsChrome && !targetIsChrome && xrayType == NotXray) {
130228:         wrapper = &ChromeObjectWrapper::singleton;
130228: 
130228:     // If content is accessing a Components object or NAC, we need a special filter,
142874:     // even if the object is same origin. Note that we allow access to NAC for
142874:     // remote-XUL whitelisted domains, since they don't have XBL scopes.
130228:     } else if (IsComponentsObject(obj) && !AccessCheck::isChrome(target)) {
130228:         wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper,
130228:                                     ComponentsObjectPolicy>::singleton;
135899:     } else if (AccessCheck::needsSystemOnlyWrapper(obj) &&
142874:                xpc::AllowXBLScope(target) &&
135899:                !(targetIsChrome || (targetSubsumesOrigin && nsContentUtils::IsCallerXBL())))
135899:     {
142875:         wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper, Opaque>::singleton;
130228:     }
130228: 
139305:     // Normally, a non-xrayable non-waived content object that finds itself in
139305:     // a privileged scope is wrapped with a CrossCompartmentWrapper, even though
139305:     // the lack of a waiver _really_ should give it an opaque wrapper. This is
139305:     // a bit too entrenched to change for content-chrome, but we can at least fix
139305:     // it for XBL scopes.
139305:     //
139305:     // See bug 843829.
139305:     else if (targetSubsumesOrigin && !originSubsumesTarget &&
139305:              !waiveXrayFlag && xrayType == NotXray &&
139305:              IsXBLScope(target))
139305:     {
139305:         wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper, GentlyOpaque>::singleton;
139305:     }
139305: 
130228:     //
130228:     // Now, handle the regular cases.
130228:     //
130229:     // These are wrappers we can compute using a rule-based approach. In order
130229:     // to do so, we need to compute some parameters.
130229:     //
130229:     else {
130228: 
130229:         // The wrapper is a security wrapper (protecting the wrappee) if and
130229:         // only if the target does not subsume the origin.
130229:         bool securityWrapper = !targetSubsumesOrigin;
130229: 
130229:         // Xrays are warranted if either the target or the origin don't trust
130229:         // each other. This is generally the case, unless the two are same-origin
130229:         // and the caller has not requested same-origin Xrays.
130229:         //
130229:         // Xrays are a bidirectional protection, since it affords clarity to the
130229:         // caller and privacy to the callee.
130229:         bool wantXrays = !(sameOrigin && !targetdata->wantXrays);
130229: 
130229:         // If Xrays are warranted, the caller may waive them for non-security
130229:         // wrappers.
139305:         bool waiveXrays = wantXrays && !securityWrapper && waiveXrayFlag;
130229: 
130229:         wrapper = SelectWrapper(securityWrapper, wantXrays, xrayType, waiveXrays);
 55582:     }
 69850: 
130227:     if (wrapper == &ChromeObjectWrapper::singleton) {
130227:         // This shouldn't happen, but do a quick check to make some dumb addon
130227:         // doesn't expose chrome eval or Function().
130227:         JSFunction *fun = JS_GetObjectFunction(obj);
130227:         if (fun) {
130227:             if (JS_IsBuiltinEvalFunction(fun) || JS_IsBuiltinFunctionConstructor(fun)) {
130227:                 JS_ReportError(cx, "Not allowed to access chrome eval or Function from content");
130227:                 return nullptr;
130227:             }
130227:         }
130227:     }
130227: 
121897:     DEBUG_CheckUnwrapSafety(obj, wrapper, origin, target);
121897: 
121493:     if (existing && proxyProto == wrappedProto)
121493:         return Wrapper::Renew(cx, existing, obj, wrapper);
121493: 
116284:     return Wrapper::New(cx, obj, proxyProto, parent, wrapper);
 47525: }
 47525: 
 98431: JSObject *
140715: WrapperFactory::WrapForSameCompartment(JSContext *cx, HandleObject objArg)
 98431: {
140715:     RootedObject obj(cx, objArg);
131423:     MOZ_ASSERT(js::IsObjectInContextCompartment(obj, cx));
131423: 
 98431:     // NB: The contract of WrapForSameCompartment says that |obj| may or may not
126636:     // be a security wrapper. These checks implicitly handle the security
126636:     // wrapper case.
126636: 
131423:     // Outerize if necessary. This, in combination with the check in
131423:     // PrepareForUnwrapping, means that calling JS_Wrap* always outerizes.
131423:     obj = JS_ObjectToOuterObject(cx, obj);
131423:     NS_ENSURE_TRUE(obj, nullptr);
131423: 
140715:     if (dom::GetSameCompartmentWrapperForDOMBinding(*obj.address())) {
126636:         return obj;
126636:     }
126636: 
126636:     MOZ_ASSERT(!dom::IsDOMObject(obj));
126636: 
147439:     if (!IS_WN_REFLECTOR(obj))
 98431:         return obj;
 98431: 
 98431:     // Extract the WN. It should exist.
148511:     XPCWrappedNative *wn = XPCWrappedNative::Get(obj);
 98431:     MOZ_ASSERT(wn, "Trying to wrap a dead WN!");
 98431: 
 98431:     // The WN knows what to do.
140359:     RootedObject wrapper(cx, wn->GetSameCompartmentSecurityWrapper(cx));
140272:     MOZ_ASSERT_IF(wrapper != obj && IsComponentsObject(js::UncheckedUnwrap(obj)),
137014:                   !Wrapper::wrapperHandler(wrapper)->isSafeToUnwrap());
121897:     return wrapper;
 98431: }
 98431: 
 71303: // Call WaiveXrayAndWrap when you have a JS object that you don't want to be
 71303: // wrapped in an Xray wrapper. cx->compartment is the compartment that will be
 71303: // using the returned object. If the object to be wrapped is already in the
 71303: // correct compartment, then this returns the unwrapped object.
 55696: bool
 55696: WrapperFactory::WaiveXrayAndWrap(JSContext *cx, jsval *vp)
 55696: {
 55815:     if (JSVAL_IS_PRIMITIVE(*vp))
 55815:         return JS_WrapValue(cx, vp);
 55696: 
140272:     JSObject *obj = js::UncheckedUnwrap(JSVAL_TO_OBJECT(*vp));
131422:     MOZ_ASSERT(!js::IsInnerObject(obj));
 86111:     if (js::IsObjectInContextCompartment(obj, cx)) {
 71303:         *vp = OBJECT_TO_JSVAL(obj);
 71303:         return true;
 71303:     }
 55696: 
144425:     // Even though waivers have no effect on access by scopes that don't subsume
144425:     // the underlying object, good defense-in-depth dictates that we should avoid
144425:     // handing out waivers to callers that can't use them. The transitive waiving
144425:     // machinery unconditionally calls WaiveXrayAndWrap on return values from
144425:     // waived functions, even though the return value might be not be same-origin
144425:     // with the function. So if we find ourselves trying to create a waiver for
144425:     // |cx|, we should check whether the caller has any business with waivers
144425:     // to things in |obj|'s compartment.
144425:     JSCompartment *target = js::GetContextCompartment(cx);
144425:     JSCompartment *origin = js::GetObjectCompartment(obj);
144425:     obj = AccessCheck::subsumes(target, origin) ? WaiveXray(cx, obj) : obj;
 60580:     if (!obj)
 55696:         return false;
 58722: 
 55696:     *vp = OBJECT_TO_JSVAL(obj);
 55696:     return JS_WrapValue(cx, vp);
 55696: }
 55696: 
 55700: JSObject *
140359: WrapperFactory::WrapSOWObject(JSContext *cx, JSObject *objArg)
 55700: {
140359:     RootedObject obj(cx, objArg);
140359:     RootedObject proto(cx);
142874: 
142874:     // If we're not allowing XBL scopes, that means we're running as a remote
142874:     // XUL domain, in which we can't have SOWs. We should never be called in
142874:     // that case.
142874:     MOZ_ASSERT(xpc::AllowXBLScope(js::GetContextCompartment(cx)));
153963:     if (!JS_GetPrototype(cx, obj, &proto))
115023:         return NULL;
 55700:     JSObject *wrapperObj =
115023:         Wrapper::New(cx, obj, proto, JS_GetGlobalForObject(cx, obj),
 80203:                      &FilteringWrapper<SameCompartmentSecurityWrapper,
142875:                      Opaque>::singleton);
 55700:     return wrapperObj;
 55696: }
 55700: 
 97171: bool
 97171: WrapperFactory::IsComponentsObject(JSObject *obj)
 97171: {
 97171:     const char *name = js::GetObjectClass(obj)->name;
 97171:     return name[0] == 'n' && !strcmp(name, "nsXPCComponents");
 55700: }
 97171: 
 97171: JSObject *
140359: WrapperFactory::WrapComponentsObject(JSContext *cx, HandleObject obj)
 97171: {
140359:     RootedObject proto(cx);
153963:     if (!JS_GetPrototype(cx, obj, &proto))
115023:         return NULL;
 97171:     JSObject *wrapperObj =
115023:         Wrapper::New(cx, obj, proto, JS_GetGlobalForObject(cx, obj),
 97171:                      &FilteringWrapper<SameCompartmentSecurityWrapper, ComponentsObjectPolicy>::singleton);
 97171: 
 97171:     return wrapperObj;
 97171: }
 97171: 
109555: bool
109555: WrapperFactory::XrayWrapperNotShadowing(JSObject *wrapper, jsid id)
109555: {
109555:     ResolvingId *rid = ResolvingId::getResolvingIdFromWrapper(wrapper);
109555:     return rid->isXrayShadowing(id);
109555: }
109555: 
106125: /*
106125:  * Calls to JS_TransplantObject* should go through these helpers here so that
106125:  * waivers get fixed up properly.
106125:  */
106125: 
106125: static bool
140359: FixWaiverAfterTransplant(JSContext *cx, HandleObject oldWaiver, HandleObject newobj)
106125: {
106125:     MOZ_ASSERT(Wrapper::wrapperHandler(oldWaiver) == &XrayWaiver);
106125:     MOZ_ASSERT(!js::IsCrossCompartmentWrapper(newobj));
106125: 
106125:     // Create a waiver in the new compartment. We know there's not one already
106125:     // because we _just_ transplanted, which means that |newobj| was either
106125:     // created from scratch, or was previously cross-compartment wrapper (which
106125:     // should have no waiver). CreateXrayWaiver asserts this.
106125:     JSObject *newWaiver = WrapperFactory::CreateXrayWaiver(cx, newobj);
106125:     if (!newWaiver)
106125:         return false;
106125: 
106125:     // Update all the cross-compartment references to oldWaiver to point to
106125:     // newWaiver.
106125:     if (!js::RemapAllWrappersForObject(cx, oldWaiver, newWaiver))
106125:         return false;
106125: 
106125:     // There should be no same-compartment references to oldWaiver, and we
106125:     // just remapped all cross-compartment references. It's dead, so we can
106125:     // remove it from the map.
120051:     XPCWrappedNativeScope *scope = GetObjectScope(oldWaiver);
106125:     JSObject *key = Wrapper::wrappedObject(oldWaiver);
120049:     MOZ_ASSERT(scope->mWaiverWrapperMap->Find(key));
120049:     scope->mWaiverWrapperMap->Remove(key);
106125:     return true;
105649: }
106125: 
106125: JSObject *
148050: TransplantObject(JSContext *cx, JS::HandleObject origobj, JS::HandleObject target)
106125: {
140359:     RootedObject oldWaiver(cx, WrapperFactory::GetXrayWaiver(origobj));
140359:     RootedObject newIdentity(cx, JS_TransplantObject(cx, origobj, target));
106125:     if (!newIdentity || !oldWaiver)
106125:        return newIdentity;
106125: 
106125:     if (!FixWaiverAfterTransplant(cx, oldWaiver, newIdentity))
106125:         return NULL;
106125:     return newIdentity;
106125: }
106125: 
106125: JSObject *
106125: TransplantObjectWithWrapper(JSContext *cx,
148050:                             HandleObject origobj, HandleObject origwrapper,
148050:                             HandleObject targetobj, HandleObject targetwrapper)
106125: {
140359:     RootedObject oldWaiver(cx, WrapperFactory::GetXrayWaiver(origobj));
140359:     RootedObject newSameCompartmentWrapper(cx,
106125:       js_TransplantObjectWithWrapper(cx, origobj, origwrapper, targetobj,
140359:                                      targetwrapper));
106125:     if (!newSameCompartmentWrapper || !oldWaiver)
106125:         return newSameCompartmentWrapper;
106125: 
140359:     RootedObject newIdentity(cx, Wrapper::wrappedObject(newSameCompartmentWrapper));
164671:     MOZ_ASSERT(!js::IsWrapper(newIdentity));
106125:     if (!FixWaiverAfterTransplant(cx, oldWaiver, newIdentity))
106125:         return NULL;
106125:     return newSameCompartmentWrapper;
106125: }
106125: 
139415: nsIGlobalObject *
139415: GetNativeForGlobal(JSObject *obj)
139415: {
139415:     MOZ_ASSERT(JS_IsGlobalObject(obj));
139415:     if (!EnsureCompartmentPrivate(obj)->scope)
139415:         return nullptr;
139415: 
139415:     // Every global needs to hold a native as its private.
139415:     MOZ_ASSERT(GetObjectClass(obj)->flags & (JSCLASS_PRIVATE_IS_NSISUPPORTS |
139415:                                              JSCLASS_HAS_PRIVATE));
139415:     nsISupports *native =
139415:         static_cast<nsISupports *>(js::GetObjectPrivate(obj));
139415:     MOZ_ASSERT(native);
139415: 
139415:     // In some cases (like for windows) it is a wrapped native,
139415:     // in other cases (sandboxes, backstage passes) it's just
139415:     // a direct pointer to the native. If it's a wrapped native
139415:     // let's unwrap it first.
139415:     if (nsCOMPtr<nsIXPConnectWrappedNative> wn = do_QueryInterface(native)) {
139415:         native = wn->Native();
106125:     }
139415: 
139415:     nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(native);
139415:     MOZ_ASSERT(global, "Native held by global needs to implement nsIGlobalObject!");
139415: 
139415:     return global;
139415: }
139415: 
139415: }
