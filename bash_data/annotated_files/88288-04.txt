43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
43113:  *
43113:  * ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is nsDiskCacheStreams.cpp, released
43113:  * June 13, 2001.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Gordon Sheridan <gordon@netscape.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: 
43113: #include "nsDiskCache.h"
43113: #include "nsDiskCacheDevice.h"
43113: #include "nsDiskCacheStreams.h"
43113: #include "nsCacheService.h"
58167: #include "mozilla/FileUtils.h"
60325: #include "nsIDiskCacheStreamInternal.h"
86808: #include "nsThreadUtils.h"
86808: #include "mozilla/Telemetry.h"
86808: #include "mozilla/TimeStamp.h"
43113: 
43113: 
43113: 
43113: // Assumptions:
43113: //      - cache descriptors live for life of streams
43113: //      - streams will only be used by FileTransport,
43113: //         they will not be directly accessible to clients
43113: //      - overlapped I/O is NOT supported
43113: 
43113: 
43113: /******************************************************************************
43113:  *  nsDiskCacheInputStream
43113:  *****************************************************************************/
43113: class nsDiskCacheInputStream : public nsIInputStream {
43113: 
43113: public:
43113: 
43113:     nsDiskCacheInputStream( nsDiskCacheStreamIO * parent,
43113:                             PRFileDesc *          fileDesc,
43113:                             const char *          buffer,
43113:                             PRUint32              endOfStream);
43113: 
43113:     virtual ~nsDiskCacheInputStream();
43113:     
43113:     NS_DECL_ISUPPORTS
43113:     NS_DECL_NSIINPUTSTREAM
43113: 
43113: private:
43113:     nsDiskCacheStreamIO *           mStreamIO;  // backpointer to parent
43113:     PRFileDesc *                    mFD;
43113:     const char *                    mBuffer;
43113:     PRUint32                        mStreamEnd;
43113:     PRUint32                        mPos;       // stream position
79445:     bool                            mClosed;
43113: };
43113: 
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS1(nsDiskCacheInputStream, nsIInputStream)
43113: 
43113: 
43113: nsDiskCacheInputStream::nsDiskCacheInputStream( nsDiskCacheStreamIO * parent,
43113:                                                 PRFileDesc *          fileDesc,
43113:                                                 const char *          buffer,
43113:                                                 PRUint32              endOfStream)
43113:     : mStreamIO(parent)
43113:     , mFD(fileDesc)
43113:     , mBuffer(buffer)
43113:     , mStreamEnd(endOfStream)
43113:     , mPos(0)
80486:     , mClosed(false)
43113: {
43113:     NS_ADDREF(mStreamIO);
43113:     mStreamIO->IncrementInputStreamCount();
43113: }
43113: 
43113: 
43113: nsDiskCacheInputStream::~nsDiskCacheInputStream()
43113: {
43113:     Close();
43113:     mStreamIO->DecrementInputStreamCount();
43113:     NS_RELEASE(mStreamIO);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsDiskCacheInputStream::Close()
43113: {
43113:     if (!mClosed) {
43113:         if (mFD) {
43113:             (void) PR_Close(mFD);
43113:             mFD = nsnull;
43113:         }
80486:         mClosed = true;
43113:     }
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsDiskCacheInputStream::Available(PRUint32 * bytesAvailable)
43113: {
43113:     if (mClosed)  return NS_BASE_STREAM_CLOSED;
43113:     if (mStreamEnd < mPos)  return NS_ERROR_UNEXPECTED;
43113:     
43113:     *bytesAvailable = mStreamEnd - mPos;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsDiskCacheInputStream::Read(char * buffer, PRUint32 count, PRUint32 * bytesRead)
43113: {
43113:     *bytesRead = 0;
43113: 
43113:     if (mClosed)
43113:         return NS_OK;
43113:     
43113:     if (mPos == mStreamEnd)  return NS_OK;
43113:     if (mPos > mStreamEnd)   return NS_ERROR_UNEXPECTED;
43113:     
67724:     if (count > mStreamEnd - mPos)
67724:         count = mStreamEnd - mPos;
67724: 
43113:     if (mFD) {
43113:         // just read from file
43113:         PRInt32  result = PR_Read(mFD, buffer, count);
43113:         if (result < 0)  return  NS_ErrorAccordingToNSPR();
43113:         
43113:         mPos += (PRUint32)result;
43113:         *bytesRead = (PRUint32)result;
43113:         
43113:     } else if (mBuffer) {
43113:         // read data from mBuffer
43113:         memcpy(buffer, mBuffer + mPos, count);
43113:         mPos += count;
43113:         *bytesRead = count;
43113:     } else {
43113:         // no data source for input stream
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsDiskCacheInputStream::ReadSegments(nsWriteSegmentFun writer,
43113:                                      void *            closure,
43113:                                      PRUint32          count,
43113:                                      PRUint32 *        bytesRead)
43113: {
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
79445: nsDiskCacheInputStream::IsNonBlocking(bool * nonBlocking)
43113: {
80486:     *nonBlocking = false;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  *  nsDiskCacheOutputStream
43113:  *****************************************************************************/
60325: class nsDiskCacheOutputStream : public nsIOutputStream
60325:                               , public nsIDiskCacheStreamInternal
60325: {
43113: public:
43113:     nsDiskCacheOutputStream( nsDiskCacheStreamIO * parent);
43113:     virtual ~nsDiskCacheOutputStream();
43113: 
43113:     NS_DECL_ISUPPORTS
43113:     NS_DECL_NSIOUTPUTSTREAM
60325:     NS_DECL_NSIDISKCACHESTREAMINTERNAL
43113: 
43113:     void ReleaseStreamIO() { NS_IF_RELEASE(mStreamIO); }
43113: 
43113: private:
43113:     nsDiskCacheStreamIO *           mStreamIO;  // backpointer to parent
79445:     bool                            mClosed;
43113: };
43113: 
43113: 
60325: NS_IMPL_THREADSAFE_ISUPPORTS2(nsDiskCacheOutputStream,
60325:                               nsIOutputStream,
60325:                               nsIDiskCacheStreamInternal)
43113: 
43113: nsDiskCacheOutputStream::nsDiskCacheOutputStream( nsDiskCacheStreamIO * parent)
43113:     : mStreamIO(parent)
80486:     , mClosed(false)
43113: {
43113:     NS_ADDREF(mStreamIO);
43113: }
43113: 
43113: 
43113: nsDiskCacheOutputStream::~nsDiskCacheOutputStream()
43113: {
43113:     Close();
43113:     ReleaseStreamIO();
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsDiskCacheOutputStream::Close()
43113: {
88288:     nsresult rv = NS_OK;
86808:     mozilla::TimeStamp start = mozilla::TimeStamp::Now();
86808: 
43113:     if (!mClosed) {
80486:         mClosed = true;
43113:         // tell parent streamIO we are closing
88288:         rv = mStreamIO->CloseOutputStream(this);
43113:     }
86808: 
86808:     mozilla::Telemetry::ID id;
86808:     if (NS_IsMainThread())
86808:         id = mozilla::Telemetry::NETWORK_DISK_CACHE_OUTPUT_STREAM_CLOSE_MAIN_THREAD;
86808:     else
86808:         id = mozilla::Telemetry::NETWORK_DISK_CACHE_OUTPUT_STREAM_CLOSE;
86808: 
86808:     mozilla::Telemetry::AccumulateTimeDelta(id, start);
86808: 
88288:     return rv;
43113: }
43113: 
60325: NS_IMETHODIMP
60325: nsDiskCacheOutputStream::CloseInternal()
60325: {
88288:     nsresult rv = NS_OK;
86808:     mozilla::TimeStamp start = mozilla::TimeStamp::Now();
86808: 
60325:     if (!mClosed) {
80486:         mClosed = true;
60325:         // tell parent streamIO we are closing
88288:         rv = mStreamIO->CloseOutputStreamInternal(this);
60325:     }
86808: 
86808:     mozilla::Telemetry::ID id;
86808:     if (NS_IsMainThread())
86808:         id = mozilla::Telemetry::NETWORK_DISK_CACHE_OUTPUT_STREAM_CLOSE_INTERNAL_MAIN_THREAD;
86808:     else
86808:         id = mozilla::Telemetry::NETWORK_DISK_CACHE_OUTPUT_STREAM_CLOSE_INTERNAL;
86808: 
86808:     mozilla::Telemetry::AccumulateTimeDelta(id, start);
86808: 
88288:     return rv;
60325: }
43113: 
43113: NS_IMETHODIMP
43113: nsDiskCacheOutputStream::Flush()
43113: {
43113:     if (mClosed)  return NS_BASE_STREAM_CLOSED;
43113:     // yeah, yeah, well get to it...eventually...
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsDiskCacheOutputStream::Write(const char *buf, PRUint32 count, PRUint32 *bytesWritten)
43113: {
43113:     if (mClosed)  return NS_BASE_STREAM_CLOSED;
43113:     return mStreamIO->Write(buf, count, bytesWritten);
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsDiskCacheOutputStream::WriteFrom(nsIInputStream *inStream, PRUint32 count, PRUint32 *bytesWritten)
43113: {
43113:     NS_NOTREACHED("WriteFrom");
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsDiskCacheOutputStream::WriteSegments( nsReadSegmentFun reader,
43113:                                         void *           closure,
43113:                                         PRUint32         count,
43113:                                         PRUint32 *       bytesWritten)
43113: {
43113:     NS_NOTREACHED("WriteSegments");
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
79445: nsDiskCacheOutputStream::IsNonBlocking(bool * nonBlocking)
43113: {
80486:     *nonBlocking = false;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: 
43113: /******************************************************************************
43113:  *  nsDiskCacheStreamIO
43113:  *****************************************************************************/
43113: NS_IMPL_THREADSAFE_ISUPPORTS0(nsDiskCacheStreamIO)
43113: 
43113: // we pick 16k as the max buffer size because that is the threshold above which
43113: //      we are unable to store the data in the cache block files
43113: //      see nsDiskCacheMap.[cpp,h]
43113: #define kMaxBufferSize      (16 * 1024)
43113: 
43113: nsDiskCacheStreamIO::nsDiskCacheStreamIO(nsDiskCacheBinding *   binding)
43113:     : mBinding(binding)
43113:     , mOutStream(nsnull)
43113:     , mInStreamCount(0)
43113:     , mFD(nsnull)
43113:     , mStreamPos(0)
43113:     , mStreamEnd(0)
43113:     , mBufPos(0)
43113:     , mBufEnd(0)
43113:     , mBufSize(0)
80486:     , mBufDirty(false)
43113:     , mBuffer(nsnull)
43113: {
43113:     mDevice = (nsDiskCacheDevice *)mBinding->mCacheEntry->CacheDevice();
43113: 
43113:     // acquire "death grip" on cache service
43113:     nsCacheService *service = nsCacheService::GlobalInstance();
43113:     NS_ADDREF(service);
43113: }
43113: 
43113: 
43113: nsDiskCacheStreamIO::~nsDiskCacheStreamIO()
43113: {
43113:     Close();
43113: 
43113:     // release "death grip" on cache service
43113:     nsCacheService *service = nsCacheService::GlobalInstance();
43113:     NS_RELEASE(service);
43113: }
43113: 
43113: 
43113: void
43113: nsDiskCacheStreamIO::Close()
43113: {
43113:     // this should only be called from our destructor
43113:     // no one is interested in us anymore, so we don't need to grab any locks
43113:     
43113:     // assert streams closed
43113:     NS_ASSERTION(!mOutStream, "output stream still open");
43113:     NS_ASSERTION(mInStreamCount == 0, "input stream still open");
43113:     NS_ASSERTION(!mFD, "file descriptor not closed");
43113: 
43113:     DeleteBuffer();
43113: }
43113: 
43113: 
43113: // NOTE: called with service lock held
43113: nsresult
43113: nsDiskCacheStreamIO::GetInputStream(PRUint32 offset, nsIInputStream ** inputStream)
43113: {
43113:     NS_ENSURE_ARG_POINTER(inputStream);
43113:     NS_ENSURE_TRUE(offset == 0, NS_ERROR_NOT_IMPLEMENTED);
43113: 
43113:     *inputStream = nsnull;
43113:     
43113:     if (!mBinding)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     if (mOutStream) {
43113:         NS_WARNING("already have an output stream open");
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     }
43113: 
43113:     nsresult            rv;
43113:     PRFileDesc *        fd = nsnull;
43113: 
43113:     mStreamEnd = mBinding->mCacheEntry->DataSize();
43113:     if (mStreamEnd == 0) {
43113:         // there's no data to read
43113:         NS_ASSERTION(!mBinding->mRecord.DataLocationInitialized(), "storage allocated for zero data size");
43113:     } else if (mBinding->mRecord.DataFile() == 0) {
43113:         // open file desc for data
43113:         rv = OpenCacheFile(PR_RDONLY, &fd);
43113:         if (NS_FAILED(rv))  return rv;  // unable to open file        
43113:         NS_ASSERTION(fd, "cache stream lacking open file.");
43113:             
43113:     } else if (!mBuffer) {
43113:         // read block file for data
43113:         rv = ReadCacheBlocks();
43113:         if (NS_FAILED(rv))  return rv;
43113:     }
43113:     // else, mBuffer already contains all of the data (left over from a
43113:     // previous block-file read or write).
43113: 
43113:     NS_ASSERTION(!(fd && mBuffer), "ambiguous data sources for input stream");
43113: 
43113:     // create a new input stream
43113:     nsDiskCacheInputStream * inStream = new nsDiskCacheInputStream(this, fd, mBuffer, mStreamEnd);
43113:     if (!inStream)  return NS_ERROR_OUT_OF_MEMORY;
43113:     
43113:     NS_ADDREF(*inputStream = inStream);
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: // NOTE: called with service lock held
43113: nsresult
43113: nsDiskCacheStreamIO::GetOutputStream(PRUint32 offset, nsIOutputStream ** outputStream)
43113: {
43113:     NS_ENSURE_ARG_POINTER(outputStream);
43113:     *outputStream = nsnull;
43113: 
43113:     if (!mBinding)  return NS_ERROR_NOT_AVAILABLE;
43113:         
43113:     NS_ASSERTION(!mOutStream, "already have an output stream open");
43113:     NS_ASSERTION(mInStreamCount == 0, "we already have input streams open");
43113:     if (mOutStream || mInStreamCount)  return NS_ERROR_NOT_AVAILABLE;
43113:     
43113:     // mBuffer lazily allocated, but might exist if a previous stream already
43113:     // created one.
43113:     mBufPos    = 0;
43113:     mStreamPos = 0;
43113:     mStreamEnd = mBinding->mCacheEntry->DataSize();
43113: 
43113:     nsresult rv;
43113:     if (offset) {
43113:         rv = Seek(PR_SEEK_SET, offset);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113:     rv = SetEOF();
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // create a new output stream
43113:     mOutStream = new nsDiskCacheOutputStream(this);
43113:     if (!mOutStream)  return NS_ERROR_OUT_OF_MEMORY;
43113:     
43113:     NS_ADDREF(*outputStream = mOutStream);
43113:     return NS_OK;
43113: }
43113: 
88288: nsresult
43113: nsDiskCacheStreamIO::ClearBinding()
43113: {
88288:     nsresult rv = NS_OK;
43113:     if (mBinding && mOutStream)
88288:         rv = Flush();
43113:     mBinding = nsnull;
88288:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsDiskCacheStreamIO::CloseOutputStream(nsDiskCacheOutputStream *  outputStream)
43113: {
43113:     nsCacheServiceAutoLock lock; // grab service lock
60325:     return CloseOutputStreamInternal(outputStream);
60325: }
60325: 
60325: nsresult
60325: nsDiskCacheStreamIO::CloseOutputStreamInternal(
60325:     nsDiskCacheOutputStream * outputStream)
60325: {
43113:     nsresult   rv;
43113: 
43113:     if (outputStream != mOutStream) {
43113:         NS_WARNING("mismatched output streams");
43113:         return NS_ERROR_UNEXPECTED;
43113:     }
43113:     
43113:     // output stream is closing
43113:     if (!mBinding) {    // if we're severed, just clear member variables
43113:         NS_ASSERTION(!mBufDirty, "oops");
43113:         mOutStream = nsnull;
43113:         outputStream->ReleaseStreamIO();
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     }
43113: 
43113:     rv = Flush();
56313:     if (NS_FAILED(rv))
56313:         NS_WARNING("Flush() failed");
43113: 
43113:     mOutStream = nsnull;
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsDiskCacheStreamIO::Flush()
43113: {
43113:     NS_ASSERTION(mBinding, "oops");
43113: 
43113:     CACHE_LOG_DEBUG(("CACHE: Flush [%x doomed=%u]\n",
43113:         mBinding->mRecord.HashNumber(), mBinding->mDoomed));
43113: 
72221:     if (!mBufDirty) {
72221:         if (mFD) {
72221:             (void) PR_Close(mFD);
72221:             mFD = nsnull;
72221:         }
43113:         return NS_OK;
72221:     }
43113: 
43113:     // write data to cache blocks, or flush mBuffer to file
43113:     nsDiskCacheMap *cacheMap = mDevice->CacheMap();  // get map reference
43113:     nsresult rv;
43113: 
79445:     bool written = false;
60881: 
60881:     if ((mStreamEnd <= kMaxBufferSize) &&
60881:         (mBinding->mCacheEntry->StoragePolicy() != nsICache::STORE_ON_DISK_AS_FILE)) {
60881:         // store data (if any) in cache block files
60881: 
80486:         mBufDirty = false;
60881: 
60881:         // delete existing storage
60881:         nsDiskCacheRecord * record = &mBinding->mRecord;
60881:         if (record->DataLocationInitialized()) {
60881:             rv = cacheMap->DeleteStorage(record, nsDiskCache::kData);
60881:             if (NS_FAILED(rv)) {
60881:                 NS_WARNING("cacheMap->DeleteStorage() failed.");
60881:                 return rv;
60881:             }
60881:         }
60881: 
60881:         // flush buffer to block files
80486:         written = true;
60881:         if (mStreamEnd > 0) {
60881:             rv = cacheMap->WriteDataCacheBlocks(mBinding, mBuffer, mBufEnd);
60881:             if (NS_FAILED(rv)) {
60881:                 NS_WARNING("WriteDataCacheBlocks() failed.");
80486:                 written = false;
60881:             }
60881:         }
60881:     }
60881: 
60881:     if (!written) {
43113:         // make sure we save as separate file
60881:         rv = FlushBufferToFile(); // initializes DataFileLocation() if necessary
43113: 
43113:         if (mFD) {
43113:           // Update the file size of the disk file in the cache
43113:           UpdateFileSize();
43113: 
43113:           // close file descriptor
43113:           (void) PR_Close(mFD);
43113:           mFD = nsnull;
43113:         }
43113:         else
43113:           NS_WARNING("no file descriptor");
43113: 
43113:         // close mFD first if possible before returning if FlushBufferToFile
43113:         // failed
43113:         NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:         // since the data location is on disk as a single file, the only value
43113:         // in keeping mBuffer around is to avoid an extra malloc the next time
43113:         // we need to write to this file.  reading will use a file descriptor.
43113:         // therefore, it's probably not worth optimizing for the subsequent
43113:         // write, so we unconditionally delete mBuffer here.
43113:         DeleteBuffer();
43113:     }
43113:     
43113:     // XXX do we need this here?  WriteDataCacheBlocks() calls UpdateRecord()
43113:     // update cache map if entry isn't doomed
43113:     if (!mBinding->mDoomed) {
43113:         rv = cacheMap->UpdateRecord(&mBinding->mRecord);
43113:         if (NS_FAILED(rv)) {
43113:             NS_WARNING("cacheMap->UpdateRecord() failed.");
43113:             return rv;   // XXX doom cache entry
43113:         }
43113:     }
43113:     
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: // assumptions:
43113: //      only one thread writing at a time
43113: //      never have both output and input streams open
43113: //      OnDataSizeChanged() will have already been called to update entry->DataSize()
43113: 
43113: nsresult
43113: nsDiskCacheStreamIO::Write( const char * buffer,
43113:                             PRUint32     count,
43113:                             PRUint32 *   bytesWritten)
43113: {
43113:     nsresult    rv = NS_OK;
43113:     nsCacheServiceAutoLock lock; // grab service lock
43113:     if (!mBinding)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     if (mInStreamCount) {
43113:         // we have open input streams already
43113:         // this is an error until we support overlapped I/O
43113:         NS_WARNING("Attempting to write to cache entry with open input streams.\n");
43113:         return NS_ERROR_NOT_AVAILABLE;
43113:     }
43113: 
43113:     NS_ASSERTION(count, "Write called with count of zero");
43113:     NS_ASSERTION(mBufPos <= mBufEnd, "streamIO buffer corrupted");
43113: 
43113:     PRUint32 bytesLeft = count;
79445:     bool     flushed = false;
43113:     
43113:     while (bytesLeft) {
43113:         if (mBufPos == mBufSize) {
43113:             if (mBufSize < kMaxBufferSize) {
43113:                 mBufSize = kMaxBufferSize;
43113:                 char *buffer = mBuffer;
43113: 
43113:                 mBuffer  = (char *) realloc(mBuffer, mBufSize);
43113:                 if (!mBuffer) {
43113:                     free(buffer);
43113:                     mBufSize = 0;
43113:                     break;
43113:                 }
43113:             } else {
43113:                 nsresult rv = FlushBufferToFile();
43113:                 if (NS_FAILED(rv))  break;
80486:                 flushed = true;
43113:             }
43113:         }
43113:         
43113:         PRUint32 chunkSize = bytesLeft;
43113:         if (chunkSize > (mBufSize - mBufPos))
43113:             chunkSize =  mBufSize - mBufPos;
43113:         
43113:         memcpy(mBuffer + mBufPos, buffer, chunkSize);
80486:         mBufDirty = true;
43113:         mBufPos += chunkSize;
43113:         bytesLeft -= chunkSize;
43113:         buffer += chunkSize;
43113:         
43113:         if (mBufEnd < mBufPos)
43113:             mBufEnd = mBufPos;
43113:     }
43113:     if (bytesLeft) {
43113:         *bytesWritten = 0;
43113:         return NS_ERROR_FAILURE;
43113:     }
43113:     *bytesWritten = count;
43113: 
43113:     // update mStreamPos, mStreamEnd
43113:     mStreamPos += count;
43113:     if (mStreamEnd < mStreamPos) {
43113:         mStreamEnd = mStreamPos;
43113:         NS_ASSERTION(mBinding->mCacheEntry->DataSize() == mStreamEnd, "bad stream");
43113: 
43113:         // If we have flushed to a file, update the file size
43113:         if (flushed && mFD) {
43113:             UpdateFileSize();
43113:         }
43113:     }
43113:     
43113:     return rv;
43113: }
43113: 
43113: 
43113: void
43113: nsDiskCacheStreamIO::UpdateFileSize()
43113: {
43113:     NS_ASSERTION(mFD, "nsDiskCacheStreamIO::UpdateFileSize should not have been called");
43113:     
43113:     nsDiskCacheRecord * record = &mBinding->mRecord;
43113:     const PRUint32      oldSizeK  = record->DataFileSize();
70385:     PRUint32            newSizeK  = (mStreamEnd + 0x03FF) >> 10;
70385: 
70385:     // make sure the size won't overflow (bug #651100)
70385:     if (newSizeK > kMaxDataSizeK)
70385:         newSizeK = kMaxDataSizeK;
43113: 
43113:     if (newSizeK == oldSizeK)  return;
43113:     
43113:     record->SetDataFileSize(newSizeK);
43113: 
43113:     // update cache size totals
43113:     nsDiskCacheMap * cacheMap = mDevice->CacheMap();
43113:     cacheMap->DecrementTotalSize(oldSizeK);       // decrement old size
43113:     cacheMap->IncrementTotalSize(newSizeK);       // increment new size
43113:     
43113:     if (!mBinding->mDoomed) {
43113:         nsresult rv = cacheMap->UpdateRecord(record);
43113:         if (NS_FAILED(rv)) {
43113:             NS_WARNING("cacheMap->UpdateRecord() failed.");
43113:             // XXX doom cache entry?
43113:         }
43113:     }
43113: }
43113: 
43113: 
43113: nsresult
43113: nsDiskCacheStreamIO::OpenCacheFile(PRIntn flags, PRFileDesc ** fd)
43113: {
43113:     NS_ENSURE_ARG_POINTER(fd);
43113:     
43113:     nsresult         rv;
43113:     nsDiskCacheMap * cacheMap = mDevice->CacheMap();
43113:     
43113:     rv = cacheMap->GetLocalFileForDiskCacheRecord(&mBinding->mRecord,
43113:                                                   nsDiskCache::kData,
58733:                                                   !!(flags & PR_CREATE_FILE),
43113:                                                   getter_AddRefs(mLocalFile));
43113:     if (NS_FAILED(rv))  return rv;
43113:     
43113:     // create PRFileDesc for input stream - the 00600 is just for consistency
43113:     rv = mLocalFile->OpenNSPRFileDesc(flags, 00600, fd);
43113:     if (NS_FAILED(rv))  return rv;  // unable to open file
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsDiskCacheStreamIO::ReadCacheBlocks()
43113: {
43113:     NS_ASSERTION(mStreamEnd == mBinding->mCacheEntry->DataSize(), "bad stream");
43113:     NS_ASSERTION(mStreamEnd <= kMaxBufferSize, "data too large for buffer");
43113: 
43113:     nsDiskCacheRecord * record = &mBinding->mRecord;
43113:     if (!record->DataLocationInitialized()) return NS_OK;
43113: 
43113:     NS_ASSERTION(record->DataFile() != kSeparateFile, "attempt to read cache blocks on separate file");
43113: 
43113:     if (!mBuffer) {
43113:         // allocate buffer
43113:         mBuffer = (char *) malloc(mStreamEnd);
43113:         if (!mBuffer) {
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113:         }
43113:         mBufSize = mStreamEnd;
43113:     }
43113:     
43113:     // read data stored in cache block files
43113:     nsDiskCacheMap *map = mDevice->CacheMap();  // get map reference
43113:     nsresult rv = map->ReadDataCacheBlocks(mBinding, mBuffer, mStreamEnd);
43113:     if (NS_FAILED(rv)) return rv;
43113: 
43113:     // update streamIO variables
43113:     mBufPos = 0;
43113:     mBufEnd = mStreamEnd;
43113:     
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsDiskCacheStreamIO::FlushBufferToFile()
43113: {
43113:     nsresult  rv;
43113:     nsDiskCacheRecord * record = &mBinding->mRecord;
43113:     
43113:     if (!mFD) {
43113:         if (record->DataLocationInitialized() && (record->DataFile() > 0)) {
43113:             // remove cache block storage
43113:             nsDiskCacheMap * cacheMap = mDevice->CacheMap();
43113:             rv = cacheMap->DeleteStorage(record, nsDiskCache::kData);
43113:             if (NS_FAILED(rv))  return rv;
43113:         }
43113:         record->SetDataFileGeneration(mBinding->mGeneration);
43113:         
43113:         // allocate file
43113:         rv = OpenCacheFile(PR_RDWR | PR_CREATE_FILE, &mFD);
43113:         if (NS_FAILED(rv))  return rv;
58167: 
58167:         PRInt64 dataSize = mBinding->mCacheEntry->PredictedDataSize();
58167:         if (dataSize != -1)
72496:             mozilla::fallocate(mFD, NS_MIN<PRInt64>(dataSize, kPreallocateLimit));
43113:     }
43113:     
43113:     // write buffer
43113:     PRInt32 bytesWritten = PR_Write(mFD, mBuffer, mBufEnd);
43113:     if (PRUint32(bytesWritten) != mBufEnd) {
43113:         NS_WARNING("failed to flush all data");
43113:         return NS_ERROR_UNEXPECTED;     // NS_ErrorAccordingToNSPR()
43113:     }
80486:     mBufDirty = false;
43113:     
43113:     // reset buffer
43113:     mBufPos = 0;
43113:     mBufEnd = 0;
43113:     
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: void
43113: nsDiskCacheStreamIO::DeleteBuffer()
43113: {
43113:     if (mBuffer) {
43113:         NS_ASSERTION(!mBufDirty, "deleting dirty buffer");
43113:         free(mBuffer);
43113:         mBuffer = nsnull;
43113:         mBufPos = 0;
43113:         mBufEnd = 0;
43113:         mBufSize = 0;
43113:     }
43113: }
43113: 
43113: 
43113: // NOTE: called with service lock held
43113: nsresult
43113: nsDiskCacheStreamIO::Seek(PRInt32 whence, PRInt32 offset)
43113: {
43113:     PRInt32  newPos;
43113:     if (!mBinding)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     if (PRUint32(offset) > mStreamEnd)  return NS_ERROR_FAILURE;
43113:  
43113:     if (mBinding->mRecord.DataLocationInitialized()) {
43113:         if (mBinding->mRecord.DataFile() == 0) {
43113:             if (!mFD) {
43113:                 // we need an mFD, we better open it now
43113:                 nsresult rv = OpenCacheFile(PR_RDWR | PR_CREATE_FILE, &mFD);
43113:                 if (NS_FAILED(rv))  return rv;
43113:             }
43113:         }
43113:     }
43113: 
43113:     if (mFD) {
43113:         // do we have data in the buffer that needs to be flushed?
43113:         if (mBufDirty) {
43113:             // XXX optimization: are we just moving within the current buffer?
43113:             nsresult rv = FlushBufferToFile();
43113:             if (NS_FAILED(rv))  return rv;
43113:         }
43113:     
43113:         newPos = PR_Seek(mFD, offset, (PRSeekWhence)whence);
43113:         if (newPos == -1)
43113:             return NS_ErrorAccordingToNSPR();
43113:         
43113:         mStreamPos = (PRUint32) newPos;
43113:         mBufPos = 0;
43113:         mBufEnd = 0;
43113:         return NS_OK;
43113:     }
43113:     
43113:     // else, seek in mBuffer
43113:     
43113:     switch(whence) {
43113:         case PR_SEEK_SET:
43113:             newPos = offset;
43113:             break;
43113:         
43113:         case PR_SEEK_CUR:   // relative from current posistion
43113:             newPos = offset + (PRUint32)mStreamPos;
43113:             break;
43113:             
43113:         case PR_SEEK_END:   // relative from end
43113:             newPos = offset + (PRUint32)mBufEnd;
43113:             break;
43113:         
43113:         default:
43113:             return NS_ERROR_INVALID_ARG;
43113:     }
43113: 
43113:     // read data into mBuffer if not read yet.
43113:     if (mStreamEnd && !mBufEnd) {
43113:         if (newPos > 0) {
43113:             nsresult rv = ReadCacheBlocks();
43113:             if (NS_FAILED(rv))  return rv;
43113:         }
43113:     }
43113: 
43113:     // stream buffer sanity checks
43113:     NS_ASSERTION(mBufEnd <= kMaxBufferSize, "bad stream");
43113:     NS_ASSERTION(mBufPos <= mBufEnd,     "bad stream");
43113:     NS_ASSERTION(mStreamPos == mBufPos,  "bad stream");
43113:     NS_ASSERTION(mStreamEnd == mBufEnd,  "bad stream");
43113:     
43113:     if ((newPos < 0) || (PRUint32(newPos) > mBufEnd)) {
43113:         NS_WARNING("seek offset out of range");
43113:         return NS_ERROR_INVALID_ARG;
43113:     }
43113: 
43113:     mStreamPos = newPos;
43113:     mBufPos    = newPos;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: // called only from nsDiskCacheOutputStream::Tell
43113: nsresult
43113: nsDiskCacheStreamIO::Tell(PRUint32 * result)
43113: {
43113:     NS_ENSURE_ARG_POINTER(result);
43113:     *result = mStreamPos;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: // NOTE: called with service lock held
43113: nsresult
43113: nsDiskCacheStreamIO::SetEOF()
43113: {
43113:     nsresult    rv;
79445:     bool        needToCloseFD = false;
43113: 
43113:     NS_ASSERTION(mStreamPos <= mStreamEnd, "bad stream");
43113:     if (!mBinding)  return NS_ERROR_NOT_AVAILABLE;
43113:     
43113:     if (mBinding->mRecord.DataLocationInitialized()) {
43113:         if (mBinding->mRecord.DataFile() == 0) {
43113:             if (!mFD) {
43113:                 // we need an mFD, we better open it now
43113:                 rv = OpenCacheFile(PR_RDWR | PR_CREATE_FILE, &mFD);
43113:                 if (NS_FAILED(rv))  return rv;
80486:                 needToCloseFD = true;
43113:             }
43113:         } else {
43113:             // data in cache block files
43113:             if ((mStreamPos != 0) && (mStreamPos != mBufPos)) {
43113:                 // only read data if there will be some left after truncation
43113:                 rv = ReadCacheBlocks();
43113:                 if (NS_FAILED(rv))  return rv;
43113:             }
43113: 
43113:             // We need to make sure we reflect this change in Flush().
43113:             // In particular, if mStreamPos is 0 and we never write to
43113:             // the buffer, we want the storage to be deleted.
80486:             mBufDirty = true;
43113:         }
43113:     }
43113:     
43113:     if (mFD) {
43113:         rv = nsDiskCache::Truncate(mFD, mStreamPos);
43113: #ifdef DEBUG
43113:         PRUint32 oldSizeK = (mStreamEnd + 0x03FF) >> 10;
43113:         NS_ASSERTION(mBinding->mRecord.DataFileSize() == oldSizeK, "bad disk cache entry size");
43113:     } else {
43113:         // data stored in buffer.
43113:         NS_ASSERTION(mStreamEnd <= kMaxBufferSize, "buffer truncation inadequate");
43113:         NS_ASSERTION(mBufPos == mStreamPos, "bad stream");
80486:         NS_ASSERTION(mBuffer ? mBufEnd == mStreamEnd : true, "bad stream");
43113: #endif
43113:     }
43113: 
43113:     NS_ASSERTION(mStreamEnd == mBinding->mCacheEntry->DataSize(), "cache entry not updated");
43113:     // we expect nsCacheEntryDescriptor::TransportWrapper::OpenOutputStream()
43113:     // to eventually update the cache entry    
43113: 
43113:     mStreamEnd  = mStreamPos;
43113:     mBufEnd     = mBufPos;
43113:     
43113:     if (mFD) {
43113:         UpdateFileSize();
43113:         if (needToCloseFD) {
43113:             (void) PR_Close(mFD);
43113:             mFD = nsnull;
43113:         } 
43113:     }
43113: 
43113:     return  NS_OK;
43113: }
