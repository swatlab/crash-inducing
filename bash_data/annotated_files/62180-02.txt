 3037: /******* BEGIN LICENSE BLOCK *******
 3037:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 3037:  * 
 3037:  * The contents of this file are subject to the Mozilla Public License Version
 3037:  * 1.1 (the "License"); you may not use this file except in compliance with
 3037:  * the License. You may obtain a copy of the License at
 3037:  * http://www.mozilla.org/MPL/
 3037:  * 
 3037:  * Software distributed under the License is distributed on an "AS IS" basis,
 3037:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 3037:  * for the specific language governing rights and limitations under the
 3037:  * License.
 3037:  * 
 3037:  * The Initial Developers of the Original Code are Kevin Hendricks (MySpell)
 3042:  * and László Németh (Hunspell). Portions created by the Initial Developers
 3037:  * are Copyright (C) 2002-2005 the Initial Developers. All Rights Reserved.
 3037:  * 
 3037:  * Contributor(s): Kevin Hendricks (kevin.hendricks@sympatico.ca)
 3042:  *                 David Einstein (deinst@world.std.com)
 3037:  *                 László Németh (nemethl@gyorsposta.hu)
43385:  *                 Caolan McNamara (caolanm@redhat.com)
 3037:  *                 Davide Prina
 3037:  *                 Giuseppe Modugno
 3037:  *                 Gianluca Turconi
 3037:  *                 Simon Brouwer
 3037:  *                 Noll Janos
 3037:  *                 Biro Arpad
 3037:  *                 Goldman Eleonora
 3037:  *                 Sarlos Tamas
 3037:  *                 Bencsath Boldizsar
 3037:  *                 Halacsy Peter
 3037:  *                 Dvornik Laszlo
 3037:  *                 Gefferth Andras
 3037:  *                 Nagy Viktor
 3037:  *                 Varga Daniel
 3037:  *                 Chris Halls
 3037:  *                 Rene Engelhard
 3037:  *                 Bram Moolenaar
 3037:  *                 Dafydd Jones
 3037:  *                 Harri Pitkanen
 3037:  *                 Andras Timar
 3037:  *                 Tor Lillqvist
 3037:  * 
 3037:  * Alternatively, the contents of this file may be used under the terms of
 3037:  * either the GNU General Public License Version 2 or later (the "GPL"), or
 3037:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 3037:  * in which case the provisions of the GPL or the LGPL are applicable instead
 3037:  * of those above. If you wish to allow use of your version of this file only
 3037:  * under the terms of either the GPL or the LGPL, and not to allow others to
 3037:  * use your version of this file under the terms of the MPL, indicate your
 3037:  * decision by deleting the provisions above and replace them with the notice
 3037:  * and other provisions required by the GPL or the LGPL. If you do not delete
 3037:  * the provisions above, a recipient may use your version of this file under
 3037:  * the terms of any one of the MPL, the GPL or the LGPL.
 3037:  *
 3037:  ******* END LICENSE BLOCK *******/
 3037: 
 3037: #include <stdlib.h>
 3037: #include <string.h>
 3037: #include <stdio.h>
43385: 
43385: #include "hunspell.hxx"
43385: #include "hunspell.h"
46456: #ifndef MOZILLA_CLIENT
43385: #    include "config.h"
 3037: #endif
21326: #include "csutil.hxx"
 3037: 
21326: Hunspell::Hunspell(const char * affpath, const char * dpath, const char * key)
 3037: {
 3037:     encoding = NULL;
 3037:     csconv = NULL;
 3037:     utf8 = 0;
 3037:     complexprefixes = 0;
21326:     affixpath = mystrdup(affpath);
21326:     maxdic = 0;
 3037: 
 3037:     /* first set up the hash manager */
21326:     pHMgr[0] = new HashMgr(dpath, affpath, key);
21326:     if (pHMgr[0]) maxdic = 1;
 3037: 
 3037:     /* next set up the affix manager */
 3037:     /* it needs access to the hash manager lookup methods */
21326:     pAMgr = new AffixMgr(affpath, pHMgr, &maxdic, key);
 3037: 
 3037:     /* get the preferred try string and the dictionary */
 3037:     /* encoding from the Affix Manager for that dictionary */
 3037:     char * try_string = pAMgr->get_try_string();
 3037:     encoding = pAMgr->get_encoding();
 3037:     csconv = get_current_cs(encoding);
 3037:     langnum = pAMgr->get_langnum();
 3037:     utf8 = pAMgr->get_utf8();
 3037:     complexprefixes = pAMgr->get_complexprefixes();
 3037:     wordbreak = pAMgr->get_breaktable();
 3037: 
 3037:     /* and finally set up the suggestion manager */
 3037:     pSMgr = new SuggestMgr(try_string, MAXSUGGESTION, pAMgr);
 3037:     if (try_string) free(try_string);
 3037: }
 3037: 
 3037: Hunspell::~Hunspell()
 3037: {
 3037:     if (pSMgr) delete pSMgr;
 3037:     if (pAMgr) delete pAMgr;
21326:     for (int i = 0; i < maxdic; i++) delete pHMgr[i];
21326:     maxdic = 0;
 3037:     pSMgr = NULL;
 3037:     pAMgr = NULL;
 3037: #ifdef MOZILLA_CLIENT
43385:     delete [] csconv;
 3037: #endif
 3037:     csconv= NULL;
 3037:     if (encoding) free(encoding);
 3037:     encoding = NULL;
21326:     if (affixpath) free(affixpath);
21326:     affixpath = NULL;
 3037: }
 3037: 
21326: // load extra dictionaries
21326: int Hunspell::add_dic(const char * dpath, const char * key) {
21326:     if (maxdic == MAXDIC || !affixpath) return 1;
21326:     pHMgr[maxdic] = new HashMgr(dpath, affixpath, key);
21326:     if (pHMgr[maxdic]) maxdic++; else return 1;
21326:     return 0;
21326: }
 3037: 
 3037: // make a copy of src at destination while removing all leading
 3037: // blanks and removing any trailing periods after recording
 3037: // their presence with the abbreviation flag
 3037: // also since already going through character by character,
 3037: // set the capitalization type
 3037: // return the length of the "cleaned" (and UTF-8 encoded) word
 3037: 
 3037: int Hunspell::cleanword2(char * dest, const char * src,
 3037:     w_char * dest_utf, int * nc, int * pcaptype, int * pabbrev)
 3037: {
 3037:    unsigned char * p = (unsigned char *) dest;
 3037:    const unsigned char * q = (const unsigned char * ) src;
 3037: 
 3037:    // first skip over any leading blanks
 3037:    while ((*q != '\0') && (*q == ' ')) q++;
 3037: 
 3037:    // now strip off any trailing periods (recording their presence)
 3037:    *pabbrev = 0;
 3037:    int nl = strlen((const char *)q);
 3037:    while ((nl > 0) && (*(q+nl-1)=='.')) {
 3037:        nl--;
 3037:        (*pabbrev)++;
 3037:    }
 3037: 
 3037:    // if no characters are left it can't be capitalized
 3037:    if (nl <= 0) {
 3037:        *pcaptype = NOCAP;
 3037:        *p = '\0';
 3037:        return 0;
 3037:    }
 3037: 
 3037:    strncpy(dest, (char *) q, nl);
 3037:    *(dest + nl) = '\0';
 3037:    nl = strlen(dest);
 3037:    if (utf8) {
 3648:       *nc = u8_u16(dest_utf, MAXWORDLEN, dest);
 3037:       // don't check too long words
 3037:       if (*nc >= MAXWORDLEN) return 0;
 3037:       if (*nc == -1) { // big Unicode character (non BMP area)
 3037:          *pcaptype = NOCAP;
 3037:          return nl;
 3037:       }
 5768:      *pcaptype = get_captype_utf8(dest_utf, *nc, langnum);
 3037:    } else {
 3037:      *pcaptype = get_captype(dest, nl, csconv);
 3037:      *nc = nl;
 3037:    }
 3037:    return nl;
 3037: }
 3037: 
 3037: int Hunspell::cleanword(char * dest, const char * src,
 3037:     int * pcaptype, int * pabbrev)
 3037: {
 3037:    unsigned char * p = (unsigned char *) dest;
 3037:    const unsigned char * q = (const unsigned char * ) src;
 3037:    int firstcap = 0;
 3037: 
 3037:    // first skip over any leading blanks
 3037:    while ((*q != '\0') && (*q == ' ')) q++;
 3037: 
 3037:    // now strip off any trailing periods (recording their presence)
 3037:    *pabbrev = 0;
 3037:    int nl = strlen((const char *)q);
 3037:    while ((nl > 0) && (*(q+nl-1)=='.')) {
 3037:        nl--;
 3037:        (*pabbrev)++;
 3037:    }
 3037: 
 3037:    // if no characters are left it can't be capitalized
 3037:    if (nl <= 0) {
 3037:        *pcaptype = NOCAP;
 3037:        *p = '\0';
 3037:        return 0;
 3037:    }
 3037: 
 3037:    // now determine the capitalization type of the first nl letters
 3037:    int ncap = 0;
 3037:    int nneutral = 0;
 3037:    int nc = 0;
 3037: 
 3037:    if (!utf8) {
 3037:       while (nl > 0) {
 3037:          nc++;
 3037:          if (csconv[(*q)].ccase) ncap++;
 3037:          if (csconv[(*q)].cupper == csconv[(*q)].clower) nneutral++;
 3037:          *p++ = *q++;
 3037:          nl--;
 3037:       }
 3037:       // remember to terminate the destination string
 3037:       *p = '\0';
 3037:       firstcap = csconv[(unsigned char)(*dest)].ccase;
 3037:    } else {
 3037:       unsigned short idx;
 3037:       w_char t[MAXWORDLEN];
 3037:       nc = u8_u16(t, MAXWORDLEN, src);
 3037:       for (int i = 0; i < nc; i++) {
 3037:          idx = (t[i].h << 8) + t[i].l;
 5768:          unsigned short low = unicodetolower(idx, langnum);
 5768:          if (idx != low) ncap++;
 5768:          if (unicodetoupper(idx, langnum) == low) nneutral++;
 3037:       }
 3037:       u16_u8(dest, MAXWORDUTF8LEN, t, nc);
 3037:       if (ncap) {
 3037:          idx = (t[0].h << 8) + t[0].l;
 3037:          firstcap = (idx != unicodetolower(idx, langnum));
 3037:       }
 3037:    }
 3037: 
 3037:    // now finally set the captype
 3037:    if (ncap == 0) {
 3037:         *pcaptype = NOCAP;
 3037:    } else if ((ncap == 1) && firstcap) {
 3037:         *pcaptype = INITCAP;
 3037:    } else if ((ncap == nc) || ((ncap + nneutral) == nc)){
 3037:         *pcaptype = ALLCAP;
 3037:    } else if ((ncap > 1) && firstcap) {
 3037:         *pcaptype = HUHINITCAP;
 3037:    } else {
 3037:         *pcaptype = HUHCAP;
 3037:    }
 3037:    return strlen(dest);
 3037: }
 3037: 
 3037: void Hunspell::mkallcap(char * p)
 3037: {
 3037:   if (utf8) {
 3037:       w_char u[MAXWORDLEN];
 3037:       int nc = u8_u16(u, MAXWORDLEN, p);
 3037:       unsigned short idx;
 3037:       for (int i = 0; i < nc; i++) {
 3037:          idx = (u[i].h << 8) + u[i].l;
 3037:          if (idx != unicodetoupper(idx, langnum)) {
 3037:             u[i].h = (unsigned char) (unicodetoupper(idx, langnum) >> 8);
 3037:             u[i].l = (unsigned char) (unicodetoupper(idx, langnum) & 0x00FF);
 3037:          }
 3037:       }
 3037:       u16_u8(p, MAXWORDUTF8LEN, u, nc);
 3037:   } else {
 3037:     while (*p != '\0') {
 3037:         *p = csconv[((unsigned char) *p)].cupper;
 3037:         p++;
 3037:     }
 3037:   }
 3037: }
 3037: 
 3037: int Hunspell::mkallcap2(char * p, w_char * u, int nc)
 3037: {
 3037:   if (utf8) {
 3037:       unsigned short idx;
 3037:       for (int i = 0; i < nc; i++) {
 3037:          idx = (u[i].h << 8) + u[i].l;
 5768:          unsigned short up = unicodetoupper(idx, langnum);
 5768:          if (idx != up) {
 5768:             u[i].h = (unsigned char) (up >> 8);
 5768:             u[i].l = (unsigned char) (up & 0x00FF);
 3037:          }
 3037:       }
 3037:       u16_u8(p, MAXWORDUTF8LEN, u, nc);
 3037:       return strlen(p);
 3037:   } else {
 3037:     while (*p != '\0') {
 3037:         *p = csconv[((unsigned char) *p)].cupper;
 3037:         p++;
 3037:     }
 3037:   }
 3037:   return nc;
 3037: }
 3037: 
 3037: 
 3037: void Hunspell::mkallsmall(char * p)
 3037: {
 3037:     while (*p != '\0') {
 3037:         *p = csconv[((unsigned char) *p)].clower;
 3037:         p++;
 3037:     }
 3037: }
 3037: 
 3037: int Hunspell::mkallsmall2(char * p, w_char * u, int nc)
 3037: {
 3037:   if (utf8) {
 3037:       unsigned short idx;
 3037:       for (int i = 0; i < nc; i++) {
 3037:          idx = (u[i].h << 8) + u[i].l;
 5768:          unsigned short low = unicodetolower(idx, langnum);
 5768:          if (idx != low) {
 5768:             u[i].h = (unsigned char) (low >> 8);
 5768:             u[i].l = (unsigned char) (low & 0x00FF);
 3037:          }
 3037:       }
 3037:       u16_u8(p, MAXWORDUTF8LEN, u, nc);
 3037:       return strlen(p);
 3037:   } else {
 3037:     while (*p != '\0') {
 3037:         *p = csconv[((unsigned char) *p)].clower;
 3037:         p++;
 3037:     }
 3037:   }
 3037:   return nc;
 3037: }
 3037: 
 3037: // convert UTF-8 sharp S codes to latin 1
 3037: char * Hunspell::sharps_u8_l1(char * dest, char * source) {
 3037:     char * p = dest;
 3037:     *p = *source;
 3037:     for (p++, source++; *(source - 1); p++, source++) {
 3037:         *p = *source;
 3037:         if (*source == '\x9F') *--p = '\xDF';
 3037:     }
 3037:     return dest;
 3037: }
 3037: 
 3037: // recursive search for right ss - sharp s permutations
 3037: hentry * Hunspell::spellsharps(char * base, char * pos, int n,
 3037:         int repnum, char * tmp, int * info, char **root) {
 3037:     pos = strstr(pos, "ss");
 3037:     if (pos && (n < MAXSHARPS)) {
 3037:         *pos = '\xC3';
 3037:         *(pos + 1) = '\x9F';
 3037:         hentry * h = spellsharps(base, pos + 2, n + 1, repnum + 1, tmp, info, root);
 3037:         if (h) return h;
 3037:         *pos = 's';
 3037:         *(pos + 1) = 's';
 3037:         h = spellsharps(base, pos + 2, n + 1, repnum, tmp, info, root);
 3037:         if (h) return h;
 3037:     } else if (repnum > 0) {
 3037:         if (utf8) return checkword(base, info, root);
 3037:         return checkword(sharps_u8_l1(tmp, base), info, root);
 3037:     }
 3037:     return NULL;
 3037: }
 3037: 
 3037: int Hunspell::is_keepcase(const hentry * rv) {
 3037:     return pAMgr && rv->astr && pAMgr->get_keepcase() &&
 3037:         TESTAFF(rv->astr, pAMgr->get_keepcase(), rv->alen);
 3037: }
 3037: 
21326: /* insert a word to the beginning of the suggestion array and return ns */
 3037: int Hunspell::insert_sug(char ***slst, char * word, int ns) {
21326:     char * dup = mystrdup(word);
21326:     if (!dup) return ns;
 3037:     if (ns == MAXSUGGESTION) {
 3037:         ns--;
 3037:         free((*slst)[ns]);
 3037:     }
 3037:     for (int k = ns; k > 0; k--) (*slst)[k] = (*slst)[k - 1];
21326:     (*slst)[0] = dup;
 3037:     return ns + 1;
 3037: }
 3037: 
 3037: int Hunspell::spell(const char * word, int * info, char ** root)
 3037: {
 3037:   struct hentry * rv=NULL;
 3037:   // need larger vector. For example, Turkish capital letter I converted a
 3037:   // 2-byte UTF-8 character (dotless i) by mkallsmall.
 5768:   char cw[MAXWORDUTF8LEN];
 5768:   char wspace[MAXWORDUTF8LEN];
 5768:   w_char unicw[MAXWORDLEN];
21326:   // Hunspell supports XML input of the simplified API (see manual)
21326:   if (strcmp(word, SPELL_XML) == 0) return 1;
 3037:   int nc = strlen(word);
 3037:   int wl2 = 0;
 3037:   if (utf8) {
 3037:     if (nc >= MAXWORDUTF8LEN) return 0;
 3037:   } else {
 3037:     if (nc >= MAXWORDLEN) return 0;
 3037:   }
 3037:   int captype = 0;
 3037:   int abbv = 0;
21326:   int wl = 0;
21326: 
21326:   // input conversion
21326:   RepList * rl = (pAMgr) ? pAMgr->get_iconvtable() : NULL;
21326:   if (rl && rl->conv(word, wspace)) wl = cleanword2(cw, wspace, unicw, &nc, &captype, &abbv);
21326:   else wl = cleanword2(cw, word, unicw, &nc, &captype, &abbv);
21326: 
 3037:   int info2 = 0;
21326:   if (wl == 0 || maxdic == 0) return 1;
 3037:   if (root) *root = NULL;
 3037: 
21326:   // allow numbers with dots, dashes and commas (but forbid double separators: "..", "--" etc.)
 3037:   enum { NBEGIN, NNUM, NSEP };
 3037:   int nstate = NBEGIN;
 3037:   int i;
 3037: 
 3037:   for (i = 0; (i < wl); i++) {
 3037:     if ((cw[i] <= '9') && (cw[i] >= '0')) {
 3037:         nstate = NNUM;
 3037:     } else if ((cw[i] == ',') || (cw[i] == '.') || (cw[i] == '-')) {
 3037:         if ((nstate == NSEP) || (i == 0)) break;
 3037:         nstate = NSEP;
 3037:     } else break;
 3037:   }
 3037:   if ((i == wl) && (nstate == NNUM)) return 1;
 3037:   if (!info) info = &info2; else *info = 0;
 3037: 
 3037:   switch(captype) {
 3037:      case HUHCAP:
 3037:      case HUHINITCAP:
 3037:      case NOCAP: {
 3037:             rv = checkword(cw, info, root);
 3037:             if ((abbv) && !(rv)) {
 3037:                 memcpy(wspace,cw,wl);
 3037:                 *(wspace+wl) = '.';
 3037:                 *(wspace+wl+1) = '\0';
 3037:                 rv = checkword(wspace, info, root);
 3037:             }
 3037:             break;
 3037:          }
 3037:      case ALLCAP: {
 3037:             rv = checkword(cw, info, root);
 3037:             if (rv) break;
 3037:             if (abbv) {
 3037:                 memcpy(wspace,cw,wl);
 3037:                 *(wspace+wl) = '.';
 3037:                 *(wspace+wl+1) = '\0';
 3037:                 rv = checkword(wspace, info, root);
 3037:                 if (rv) break;
 3037:             }
 3648:             // Spec. prefix handling for Catalan, French, Italian:
 3648: 	    // prefixes separated by apostrophe (SANT'ELIA -> Sant'+Elia).
 3037:             if (pAMgr && strchr(cw, '\'')) {
 3037:                 wl = mkallsmall2(cw, unicw, nc);
43385:         	//There are no really sane circumstances where this could fail,
43385:         	//but anyway...
43385:         	if (char * apostrophe = strchr(cw, '\'')) {
 3037:                     if (utf8) {
 3037:             	        w_char tmpword[MAXWORDLEN];
 3037:             	        *apostrophe = '\0';
 3037:             	        wl2 = u8_u16(tmpword, MAXWORDLEN, cw);
 3037:             	        *apostrophe = '\'';
 3037: 		        if (wl2 < nc) {
 3037: 		            mkinitcap2(apostrophe + 1, unicw + wl2 + 1, nc - wl2 - 1);
 3037: 			    rv = checkword(cw, info, root);
 3037: 			    if (rv) break;
 3037: 		        }
 3037:                     } else {
 3037: 		        mkinitcap2(apostrophe + 1, unicw, nc);
 3037: 		        rv = checkword(cw, info, root);
 3037: 		        if (rv) break;
 3037: 		    }
43385: 		}
 3037: 		mkinitcap2(cw, unicw, nc);
 3037: 		rv = checkword(cw, info, root);
 3037: 		if (rv) break;
 3037:             }
 3037:             if (pAMgr && pAMgr->get_checksharps() && strstr(cw, "SS")) {
 3037:                 char tmpword[MAXWORDUTF8LEN];
 3037:                 wl = mkallsmall2(cw, unicw, nc);
 3037:                 memcpy(wspace,cw,(wl+1));
 3037:                 rv = spellsharps(wspace, wspace, 0, 0, tmpword, info, root);
 3037:                 if (!rv) {
 3037:                     wl2 = mkinitcap2(cw, unicw, nc);
 3037:                     rv = spellsharps(cw, cw, 0, 0, tmpword, info, root);
 3037:                 }
 3037:                 if ((abbv) && !(rv)) {
 3037:                     *(wspace+wl) = '.';
 3037:                     *(wspace+wl+1) = '\0';
 3037:                     rv = spellsharps(wspace, wspace, 0, 0, tmpword, info, root);
 3037:                     if (!rv) {
 3037:                         memcpy(wspace, cw, wl2);
 3037:                         *(wspace+wl2) = '.';
 3037:                         *(wspace+wl2+1) = '\0';
 3037:                         rv = spellsharps(wspace, wspace, 0, 0, tmpword, info, root);
 3037:                     }
 3037:                 }
 3037:                 if (rv) break;
 3037:             }
 3037:         }
 3037:      case INITCAP: {
 3037:              wl = mkallsmall2(cw, unicw, nc);
 3037:              memcpy(wspace,cw,(wl+1));
 3037:              wl2 = mkinitcap2(cw, unicw, nc);
 3037:     	     if (captype == INITCAP) *info += SPELL_INITCAP;
 3037:              rv = checkword(cw, info, root);
 3037:     	     if (captype == INITCAP) *info -= SPELL_INITCAP;
 3037:              // forbid bad capitalization
 3037:              // (for example, ijs -> Ijs instead of IJs in Dutch)
 3037:              // use explicit forms in dic: Ijs/F (F = FORBIDDENWORD flag)
 3037:              if (*info & SPELL_FORBIDDEN) {
 3037:                 rv = NULL;
 3037:                 break;
 3037:              }
 3037:              if (rv && is_keepcase(rv) && (captype == ALLCAP)) rv = NULL;
 3037:              if (rv) break;
 3648: 
 3037:              rv = checkword(wspace, info, root);
 3037:              if (abbv && !rv) {
 3648: 
 3037:                  *(wspace+wl) = '.';
 3037:                  *(wspace+wl+1) = '\0';
 3037:                  rv = checkword(wspace, info, root);
 3037:                  if (!rv) {
 3037:                     memcpy(wspace, cw, wl2);
 3037:                     *(wspace+wl2) = '.';
 3037:                     *(wspace+wl2+1) = '\0';
 3037:     	    	    if (captype == INITCAP) *info += SPELL_INITCAP;
 3037:                     rv = checkword(wspace, info, root);
 3037:     	    	    if (captype == INITCAP) *info -= SPELL_INITCAP;
 3037:                     if (rv && is_keepcase(rv) && (captype == ALLCAP)) rv = NULL;
 3037:                     break;
 3037:                  }
 3037:              }
 3037:              if (rv && is_keepcase(rv) &&
 3037:                 ((captype == ALLCAP) ||
 3037:                    // if CHECKSHARPS: KEEPCASE words with \xDF  are allowed
 3037:                    // in INITCAP form, too.
 3037:                    !(pAMgr->get_checksharps() &&
 3037:                       ((utf8 && strstr(wspace, "\xC3\x9F")) ||
 3037:                       (!utf8 && strchr(wspace, '\xDF')))))) rv = NULL;
 3037:              break;
 3037:            }
 3037:   }
 3037: 
 3037:   if (rv) return 1;
 3037: 
21326:   // recursive breaking at break points
 3037:   if (wordbreak) {
 3037:     char * s;
 3037:     char r;
43385:     int nbr = 0;
21326:     wl = strlen(cw);
 3648:     int numbreak = pAMgr ? pAMgr->get_numbreak() : 0;
43385: 
43385:     // calculate break points for recursion limit
43385:     for (int j = 0; j < numbreak; j++) {
43385:       s = cw;
43385:       do {
43385:       	s = (char *) strstr(s, wordbreak[j]);
43385:       	if (s) { 
43385: 		nbr++;
43385: 		s++;
43385: 	}
43385:       } while (s);
43385:     } 
43385:     if (nbr >= 10) return 0;
43385: 
21326:     // check boundary patterns (^begin and end$)
 3648:     for (int j = 0; j < numbreak; j++) {
21326:       int plen = strlen(wordbreak[j]);
21326:       if (plen == 1 || plen > wl) continue;
21326:       if (wordbreak[j][0] == '^' && strncmp(cw, wordbreak[j] + 1, plen - 1) == 0
21326:         && spell(cw + plen - 1)) return 1;
21326:       if (wordbreak[j][plen - 1] == '$' &&
21326:         strncmp(cw + wl - plen + 1, wordbreak[j], plen - 1) == 0) {
21326: 	    r = cw[wl - plen + 1];
21326: 	    cw[wl - plen + 1] = '\0';
21326:     	    if (spell(cw)) return 1;
21326: 	    cw[wl - plen + 1] = r;
21326: 	}
21326:     }
43385: 
21326:     // other patterns
21326:     for (int j = 0; j < numbreak; j++) {
21326:       int plen = strlen(wordbreak[j]);
21326:       s=(char *) strstr(cw, wordbreak[j]);
21326:       if (s && (s > cw) && (s < cw + wl - plen)) {
21326: 	if (!spell(s + plen)) continue;
 3037:         r = *s;
 3037:         *s = '\0';
 3037:         // examine 2 sides of the break point
21326:         if (spell(cw)) return 1;
 3037:         *s = r;
21326: 
21326:         // LANG_hu: spec. dash rule
21326: 	if (langnum == LANG_hu && strcmp(wordbreak[j], "-") == 0) {
21326: 	  r = s[1];
21326: 	  s[1] = '\0';
21326:           if (spell(cw)) return 1; // check the first part with dash
21326:           s[1] = r;
 3037: 	}
21326:         // end of LANG speficic region
21326: 
 3037:       }
 3037:     }
 3037:   }
 3037: 
 3037:   return 0;
 3037: }
 3037: 
 3037: struct hentry * Hunspell::checkword(const char * w, int * info, char ** root)
 3037: {
 3037:   struct hentry * he = NULL;
21326:   int len, i;
 3037:   char w2[MAXWORDUTF8LEN];
 3037:   const char * word;
 3037: 
 3037:   char * ignoredchars = pAMgr->get_ignore();
 3037:   if (ignoredchars != NULL) {
 3037:      strcpy(w2, w);
 3037:      if (utf8) {
 3037:         int ignoredchars_utf16_len;
 3037:         unsigned short * ignoredchars_utf16 = pAMgr->get_ignore_utf16(&ignoredchars_utf16_len);
 3037:         remove_ignored_chars_utf(w2, ignoredchars_utf16, ignoredchars_utf16_len);
 3037:      } else {
 3037:         remove_ignored_chars(w2,ignoredchars);
 3037:      }
 3037:      word = w2;
 3037:   } else word = w;
 3037: 
 3037:   // word reversing wrapper for complex prefixes
 3037:   if (complexprefixes) {
 3037:     if (word != w2) {
 3037:       strcpy(w2, word);
 3037:       word = w2;
 3037:     }
 3037:     if (utf8) reverseword_utf(w2); else reverseword(w2);
 3037:   }
 3037: 
 3037:   // look word in hash table
21326:   for (i = 0; (i < maxdic) && !he; i ++) {
21326:   he = (pHMgr[i])->lookup(word);
 3037: 
 3037:   // check forbidden and onlyincompound words
 3037:   if ((he) && (he->astr) && (pAMgr) && TESTAFF(he->astr, pAMgr->get_forbiddenword(), he->alen)) {
 3037:     if (info) *info += SPELL_FORBIDDEN;
 3037:     // LANG_hu section: set dash information for suggestions
 3037:     if (langnum == LANG_hu) {
 3037:         if (pAMgr->get_compoundflag() &&
 3037:             TESTAFF(he->astr, pAMgr->get_compoundflag(), he->alen)) {
 3037:                 if (info) *info += SPELL_COMPOUND;
 3037:         }
 3037:     }
 3037:     return NULL;
 3037:   }
 3037: 
21326:   // he = next not needaffix, onlyincompound homonym or onlyupcase word
 3037:   while (he && (he->astr) &&
21326:     ((pAMgr->get_needaffix() && TESTAFF(he->astr, pAMgr->get_needaffix(), he->alen)) ||
 3037:        (pAMgr->get_onlyincompound() && TESTAFF(he->astr, pAMgr->get_onlyincompound(), he->alen)) ||
 3037:        (info && (*info & SPELL_INITCAP) && TESTAFF(he->astr, ONLYUPCASEFLAG, he->alen))
 3037:     )) he = he->next_homonym;
21326:   }
 3037: 
 3037:   // check with affixes
 3037:   if (!he && pAMgr) {
 3037:      // try stripping off affixes */
 3037:      len = strlen(word);
 3037:      he = pAMgr->affix_check(word, len, 0);
 3037: 
 3037:      // check compound restriction and onlyupcase
 3037:      if (he && he->astr && (
 3037:         (pAMgr->get_onlyincompound() &&
 3037:     	    TESTAFF(he->astr, pAMgr->get_onlyincompound(), he->alen)) ||
 3037:         (info && (*info & SPELL_INITCAP) &&
 3037:     	    TESTAFF(he->astr, ONLYUPCASEFLAG, he->alen)))) {
 3037:     	    he = NULL;
 3037:      }
 3037: 
 3037:      if (he) {
 3037:         if ((he->astr) && (pAMgr) && TESTAFF(he->astr, pAMgr->get_forbiddenword(), he->alen)) {
 3037:             if (info) *info += SPELL_FORBIDDEN;
 3037:             return NULL;
 3037:         }
 3037:         if (root) {
43385:             *root = mystrdup(he->word);
21326:             if (*root && complexprefixes) {
 3037:                 if (utf8) reverseword_utf(*root); else reverseword(*root);
 3037:             }
 3037:         }
 3037:      // try check compound word
 3037:      } else if (pAMgr->get_compound()) {
21326:           he = pAMgr->compound_check(word, len, 0, 0, 100, 0, NULL, 0, 0);
 3037:           // LANG_hu section: `moving rule' with last dash
 3037:           if ((!he) && (langnum == LANG_hu) && (word[len-1] == '-')) {
 3037:              char * dup = mystrdup(word);
21326:              if (!dup) return NULL;
 3037:              dup[len-1] = '\0';
21326:              he = pAMgr->compound_check(dup, len-1, -5, 0, 100, 0, NULL, 1, 0);
 3037:              free(dup);
 3037:           }
 3037:           // end of LANG speficic region
 3037:           if (he) {
 3037:                 if (root) {
43385:                     *root = mystrdup(he->word);
21326:                     if (*root && complexprefixes) {
 3037:                         if (utf8) reverseword_utf(*root); else reverseword(*root);
 3037:                     }
 3037:                 }
 3037:                 if (info) *info += SPELL_COMPOUND;
 3037:           }
 3037:      }
 3037: 
 3037:   }
 3037: 
 3037:   return he;
 3037: }
 3037: 
 3037: int Hunspell::suggest(char*** slst, const char * word)
 3037: {
 5768:   int onlycmpdsug = 0;
 5768:   char cw[MAXWORDUTF8LEN];
 5768:   char wspace[MAXWORDUTF8LEN];
21326:   if (!pSMgr || maxdic == 0) return 0;
 5768:   w_char unicw[MAXWORDLEN];
21326:   *slst = NULL;
21326:   // process XML input of the simplified API (see manual)
21326:   if (strncmp(word, SPELL_XML, sizeof(SPELL_XML) - 3) == 0) {
21326:      return spellml(slst, word);
21326:   }
 3037:   int nc = strlen(word);
 3037:   if (utf8) {
 3037:     if (nc >= MAXWORDUTF8LEN) return 0;
 3037:   } else {
 3037:     if (nc >= MAXWORDLEN) return 0;
 3037:   }
 3037:   int captype = 0;
 3037:   int abbv = 0;
21326:   int wl = 0;
21326: 
21326:   // input conversion
21326:   RepList * rl = (pAMgr) ? pAMgr->get_iconvtable() : NULL;
21326:   if (rl && rl->conv(word, wspace)) wl = cleanword2(cw, wspace, unicw, &nc, &captype, &abbv);
21326:   else wl = cleanword2(cw, word, unicw, &nc, &captype, &abbv);
21326: 
 3037:   if (wl == 0) return 0;
 3037:   int ns = 0;
 3037:   int capwords = 0;
 3037: 
 3037:   switch(captype) {
 3037:      case NOCAP:   {
 5768:                      ns = pSMgr->suggest(slst, cw, ns, &onlycmpdsug);
 3037:                      break;
 3037:                    }
 3037: 
 3037:      case INITCAP: {
 3037:                      capwords = 1;
 5768:                      ns = pSMgr->suggest(slst, cw, ns, &onlycmpdsug);
 3037:                      if (ns == -1) break;
 3037:                      memcpy(wspace,cw,(wl+1));
 3037:                      mkallsmall2(wspace, unicw, nc);
 5768:                      ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);
 3037:                      break;
 3037:                    }
 3037:      case HUHINITCAP:
 3037:                     capwords = 1;
 3037:      case HUHCAP: {
 5768:                      ns = pSMgr->suggest(slst, cw, ns, &onlycmpdsug);
 3037:                      if (ns != -1) {
 3037:                         int prevns;
 3037:     		        // something.The -> something. The
 3037:                         char * dot = strchr(cw, '.');
 3037: 		        if (dot && (dot > cw)) {
 5768: 		            int captype_;
 5768: 		            if (utf8) {
 5768: 		               w_char w_[MAXWORDLEN];
 5768: 			       int wl_ = u8_u16(w_, MAXWORDLEN, dot + 1);
 5768: 		               captype_ = get_captype_utf8(w_, wl_, langnum);
 5768: 		            } else captype_ = get_captype(dot+1, strlen(dot+1), csconv);
 3648: 		    	    if (captype_ == INITCAP) {
 3037:                         	char * st = mystrdup(cw);
21326:                         	if (st) st = (char *) realloc(st, wl + 2);
 3648: 				if (st) {
 3037:                         		st[(dot - cw) + 1] = ' ';
 3037:                         		strcpy(st + (dot - cw) + 2, dot + 1);
 3037:                     			ns = insert_sug(slst, st, ns);
 3648: 					free(st);
 3648: 				}
 3037: 		    	    }
 3037: 		        }
 3037:                         if (captype == HUHINITCAP) {
 3037:                             // TheOpenOffice.org -> The OpenOffice.org
 3037:                             memcpy(wspace,cw,(wl+1));
 3037:                             mkinitsmall2(wspace, unicw, nc);
 5768:                             ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);
 3037:                         }
 3037:                         memcpy(wspace,cw,(wl+1));
 3037:                         mkallsmall2(wspace, unicw, nc);
 3037:                         if (spell(wspace)) ns = insert_sug(slst, wspace, ns);
 3037:                         prevns = ns;
 5768:                         ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);
 3037:                         if (captype == HUHINITCAP) {
 3037:                             mkinitcap2(wspace, unicw, nc);
 3037:                             if (spell(wspace)) ns = insert_sug(slst, wspace, ns);
 5768:                             ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);
 3037:                         }
 3037:                         // aNew -> "a New" (instead of "a new")
 3037:                         for (int j = prevns; j < ns; j++) {
 3037:                            char * space = strchr((*slst)[j],' ');
 3037:                            if (space) {
 3037:                                 int slen = strlen(space + 1);
 3037:                                 // different case after space (need capitalisation)
 3037:                                 if ((slen < wl) && strcmp(cw + wl - slen, space + 1)) {
 5768:                                     w_char w[MAXWORDLEN];
 3037:                                     int wc = 0;
 3037:                                     char * r = (*slst)[j];
 3037:                                     if (utf8) wc = u8_u16(w, MAXWORDLEN, space + 1);
 3037:                                     mkinitcap2(space + 1, w, wc);
 3037:                                     // set as first suggestion
 3037:                                     for (int k = j; k > 0; k--) (*slst)[k] = (*slst)[k - 1];
 3037:                                     (*slst)[0] = r;
 3037:                                 }
 3037:                            }
 3037:                         }
 3037:                      }
 3037:                      break;
 3037:                    }
 3037: 
 3037:      case ALLCAP: {
 3037:                      memcpy(wspace, cw, (wl+1));
 3037:                      mkallsmall2(wspace, unicw, nc);
 5768:                      ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);
 3037:                      if (ns == -1) break;
 3037:                      if (pAMgr && pAMgr->get_keepcase() && spell(wspace))
 3037:                         ns = insert_sug(slst, wspace, ns);
 3037:                      mkinitcap2(wspace, unicw, nc);
 5768:                      ns = pSMgr->suggest(slst, wspace, ns, &onlycmpdsug);
 3037:                      for (int j=0; j < ns; j++) {
 3037:                         mkallcap((*slst)[j]);
 3037:                         if (pAMgr && pAMgr->get_checksharps()) {
 3037:                             char * pos;
 3037:                             if (utf8) {
 3037:                                 pos = strstr((*slst)[j], "\xC3\x9F");
 3037:                                 while (pos) {
 3037:                                     *pos = 'S';
 3037:                                     *(pos+1) = 'S';
 3037:                                     pos = strstr(pos+2, "\xC3\x9F");
 3037:                                 }
 3037:                             } else {
 3037:                                 pos = strchr((*slst)[j], '\xDF');
 3037:                                 while (pos) {
 3037:                                     (*slst)[j] = (char *) realloc((*slst)[j], strlen((*slst)[j]) + 2);
 3037:                                     mystrrep((*slst)[j], "\xDF", "SS");
 3037:                                     pos = strchr((*slst)[j], '\xDF');
 3037:                                 }
 3037:                             }
 3037:                         }
 3037:                      }
 3037:                      break;
 3037:                    }
 3037:   }
 3037: 
 3037:   // LANG_hu section: replace '-' with ' ' in Hungarian
 3037:   if (langnum == LANG_hu) {
 3037:       for (int j=0; j < ns; j++) {
 3037:           char * pos = strchr((*slst)[j],'-');
 3037:           if (pos) {
 3037:               int info;
 3037:               char w[MAXWORDUTF8LEN];
 3037:               *pos = '\0';
 3037:               strcpy(w, (*slst)[j]);
 3037:               strcat(w, pos + 1);
 3037:               spell(w, &info, NULL);
 3037:               if ((info & SPELL_COMPOUND) && (info & SPELL_FORBIDDEN)) {
 3037:                   *pos = ' ';
 3037:               } else *pos = '-';
 3037:           }
 3037:       }
 3037:   }
 3037:   // END OF LANG_hu section
 3037: 
 3037:   // try ngram approach since found nothing
43385:   if ((ns == 0 || onlycmpdsug) && pAMgr && (pAMgr->get_maxngramsugs() != 0) && (*slst)) {
 3037:       switch(captype) {
 3037:           case NOCAP: {
21326:               ns = pSMgr->ngsuggest(*slst, cw, ns, pHMgr, maxdic);
 3037:               break;
 3037:           }
21326: 	  case HUHINITCAP:
21326:               capwords = 1;
 3037:           case HUHCAP: {
 3037:               memcpy(wspace,cw,(wl+1));
 3037:               mkallsmall2(wspace, unicw, nc);
21326:               ns = pSMgr->ngsuggest(*slst, wspace, ns, pHMgr, maxdic);
 3037: 	      break;
 3037:           }
 3037:          case INITCAP: {
 3037:               capwords = 1;
 3037:               memcpy(wspace,cw,(wl+1));
 3037:               mkallsmall2(wspace, unicw, nc);
21326:               ns = pSMgr->ngsuggest(*slst, wspace, ns, pHMgr, maxdic);
 3037:               break;
 3037:           }
 3037:           case ALLCAP: {
 3037:               memcpy(wspace,cw,(wl+1));
 3037:               mkallsmall2(wspace, unicw, nc);
 5768: 	      int oldns = ns;
21326:               ns = pSMgr->ngsuggest(*slst, wspace, ns, pHMgr, maxdic);
 5768:               for (int j = oldns; j < ns; j++)
 3037:                   mkallcap((*slst)[j]);
 3037:               break;
 3037:          }
 3037:       }
 3037:   }
 3037: 
21326:   // try dash suggestion (Afo-American -> Afro-American)
43385:   if (char * pos = strchr(cw, '-')) {
21326:      char * ppos = cw;
21326:      int nodashsug = 1;
21326:      char ** nlst = NULL;
21326:      int nn = 0;
21326:      int last = 0;
43385:      if (*slst) {
21326:         for (int j = 0; j < ns && nodashsug == 1; j++) {
21326:            if (strchr((*slst)[j], '-')) nodashsug = 0;
21326:         }
43385:      }
21326:      while (nodashsug && !last) {
21326: 	if (*pos == '\0') last = 1; else *pos = '\0';
21326:         if (!spell(ppos)) {
21326:           nn = suggest(&nlst, ppos);
21326:           for (int j = nn - 1; j >= 0; j--) {
21326:             strncpy(wspace, cw, ppos - cw);
21326:             strcpy(wspace + (ppos - cw), nlst[j]);
21326:             if (!last) {
21326:             	strcat(wspace, "-");
21326: 		strcat(wspace, pos + 1);
21326: 	    }
21326:             ns = insert_sug(slst, wspace, ns);
21326:             free(nlst[j]);
21326:           }
21326:           if (nlst != NULL) free(nlst);
21326:           nodashsug = 0;
21326:         }
21326: 	if (!last) {
21326:           *pos = '-';
21326:           ppos = pos + 1;
21326:           pos = strchr(ppos, '-');
21326:         }
21326: 	if (!pos) pos = cw + strlen(cw);
21326:      }
21326:   }
21326: 
 3037:   // word reversing wrapper for complex prefixes
 3037:   if (complexprefixes) {
 3037:     for (int j = 0; j < ns; j++) {
 3037:       if (utf8) reverseword_utf((*slst)[j]); else reverseword((*slst)[j]);
 3037:     }
 3037:   }
 3037: 
 3037:   // capitalize
 3037:   if (capwords) for (int j=0; j < ns; j++) {
 3037:       mkinitcap((*slst)[j]);
 3037:   }
 3037: 
 3037:   // expand suggestions with dot(s)
 3037:   if (abbv && pAMgr && pAMgr->get_sugswithdots()) {
 3037:     for (int j = 0; j < ns; j++) {
 3037:       (*slst)[j] = (char *) realloc((*slst)[j], strlen((*slst)[j]) + 1 + abbv);
 3037:       strcat((*slst)[j], word + strlen(word) - abbv);
 3037:     }
 3037:   }
 3037: 
 3037:   // remove bad capitalized and forbidden forms
 3648:   if (pAMgr && (pAMgr->get_keepcase() || pAMgr->get_forbiddenword())) {
 3037:   switch (captype) {
 3037:     case INITCAP:
 3037:     case ALLCAP: {
 3037:       int l = 0;
 3037:       for (int j=0; j < ns; j++) {
 3037:         if (!strchr((*slst)[j],' ') && !spell((*slst)[j])) {
 3037:           char s[MAXSWUTF8L];
 3037:           w_char w[MAXSWL];
 3037:           int len;
 3037:           if (utf8) {
 3037:             len = u8_u16(w, MAXSWL, (*slst)[j]);
 3037:           } else {
 3037:             strcpy(s, (*slst)[j]);
 3037:             len = strlen(s);
 3037:           }
 3037:           mkallsmall2(s, w, len);
 3037:           free((*slst)[j]);
 3037:           if (spell(s)) {
 3037:             (*slst)[l] = mystrdup(s);
21326:             if ((*slst)[l]) l++;
 3037:           } else {
 3037:             mkinitcap2(s, w, len);
 3037:             if (spell(s)) {
 3037:               (*slst)[l] = mystrdup(s);
21326:               if ((*slst)[l]) l++;
 3037:             }
 3037:           }
 3037:         } else {
 3037:           (*slst)[l] = (*slst)[j];
 3037:           l++;
 3037:         }
 3037:       }
 3037:       ns = l;
 3037:     }
 3037:   }
 3037:   }
 3037: 
 3037:   // remove duplications
 3037:   int l = 0;
 3037:   for (int j = 0; j < ns; j++) {
 3037:     (*slst)[l] = (*slst)[j];
 3037:     for (int k = 0; k < l; k++) {
 3037:       if (strcmp((*slst)[k], (*slst)[j]) == 0) {
 3037:         free((*slst)[j]);
 3037:         l--;
62180:         break;
 3037:       }
 3037:     }
 3037:     l++;
 3037:   }
62180:   ns = l;
21326: 
21326:   // output conversion
21326:   rl = (pAMgr) ? pAMgr->get_oconvtable() : NULL;
21326:   for (int j = 0; rl && j < ns; j++) {
21326:     if (rl->conv((*slst)[j], wspace)) {
21326:       free((*slst)[j]);
21326:       (*slst)[j] = mystrdup(wspace);
21326:     }
21326:   }
21326: 
21326:   // if suggestions removed by nosuggest, onlyincompound parameters
21326:   if (l == 0 && *slst) {
21326:     free(*slst);
21326:     *slst = NULL;
21326:   }
 3037:   return l;
 3037: }
 3037: 
21326: void Hunspell::free_list(char *** slst, int n) {
21326:         freelist(slst, n);
21326: }
21326: 
 3037: char * Hunspell::get_dic_encoding()
 3037: {
 3037:   return encoding;
 3037: }
 3037: 
 3037: #ifdef HUNSPELL_EXPERIMENTAL
 3037: // XXX need UTF-8 support
 3037: int Hunspell::suggest_auto(char*** slst, const char * word)
 3037: {
 5768:   char cw[MAXWORDUTF8LEN];
 5768:   char wspace[MAXWORDUTF8LEN];
21326:   if (!pSMgr || maxdic == 0) return 0;
 3037:   int wl = strlen(word);
 3037:   if (utf8) {
 3037:     if (wl >= MAXWORDUTF8LEN) return 0;
 3037:   } else {
 3037:     if (wl >= MAXWORDLEN) return 0;
 3037:   }
 3037:   int captype = 0;
 3037:   int abbv = 0;
 3037:   wl = cleanword(cw, word, &captype, &abbv);
 3037:   if (wl == 0) return 0;
 3037:   int ns = 0;
 3037:   *slst = NULL; // HU, nsug in pSMgr->suggest
 3037: 
 3037:   switch(captype) {
 3037:      case NOCAP:   {
 3037:                      ns = pSMgr->suggest_auto(slst, cw, ns);
 3037:                      if (ns>0) break;
 3037:                      break;
 3037:                    }
 3037: 
 3037:      case INITCAP: {
 3037:                      memcpy(wspace,cw,(wl+1));
 3037:                      mkallsmall(wspace);
 3037:                      ns = pSMgr->suggest_auto(slst, wspace, ns);
 3037:                      for (int j=0; j < ns; j++)
 3037:                        mkinitcap((*slst)[j]);
 3037:                      ns = pSMgr->suggest_auto(slst, cw, ns);
 3037:                      break;
 3037: 
 3037:                    }
 3037: 
21326:      case HUHINITCAP:
 3037:      case HUHCAP: {
 3037:                      ns = pSMgr->suggest_auto(slst, cw, ns);
 3037:                      if (ns == 0) {
 3037:                         memcpy(wspace,cw,(wl+1));
 3037:                         mkallsmall(wspace);
 3037:                         ns = pSMgr->suggest_auto(slst, wspace, ns);
 3037:                      }
 3037:                      break;
 3037:                    }
 3037: 
 3037:      case ALLCAP: {
 3037:                      memcpy(wspace,cw,(wl+1));
 3037:                      mkallsmall(wspace);
 3037:                      ns = pSMgr->suggest_auto(slst, wspace, ns);
 3037: 
 3037:                      mkinitcap(wspace);
 3037:                      ns = pSMgr->suggest_auto(slst, wspace, ns);
 3037: 
 3037:                      for (int j=0; j < ns; j++)
 3037:                        mkallcap((*slst)[j]);
 3037:                      break;
 3037:                    }
 3037:   }
 3037: 
 3037:   // word reversing wrapper for complex prefixes
 3037:   if (complexprefixes) {
 3037:     for (int j = 0; j < ns; j++) {
 3037:       if (utf8) reverseword_utf((*slst)[j]); else reverseword((*slst)[j]);
 3037:     }
 3037:   }
 3037: 
 3037:   // expand suggestions with dot(s)
 3037:   if (abbv && pAMgr && pAMgr->get_sugswithdots()) {
 3037:     for (int j = 0; j < ns; j++) {
 3037:       (*slst)[j] = (char *) realloc((*slst)[j], strlen((*slst)[j]) + 1 + abbv);
 3037:       strcat((*slst)[j], word + strlen(word) - abbv);
 3037:     }
 3037:   }
 3037: 
 3037:   // LANG_hu section: replace '-' with ' ' in Hungarian
 3037:   if (langnum == LANG_hu) {
 3037:       for (int j=0; j < ns; j++) {
 3037:           char * pos = strchr((*slst)[j],'-');
 3037:           if (pos) {
 3037:               int info;
 3037:               char w[MAXWORDUTF8LEN];
 3037:               *pos = '\0';
 3037:               strcpy(w, (*slst)[j]);
 3037:               strcat(w, pos + 1);
 3037:               spell(w, &info, NULL);
 3037:               if ((info & SPELL_COMPOUND) && (info & SPELL_FORBIDDEN)) {
 3037:                   *pos = ' ';
 3037:               } else *pos = '-';
 3037:           }
 3037:       }
 3037:   }
 3037:   // END OF LANG_hu section
 3037:   return ns;
 3037: }
21326: #endif
 3037: 
21326: int Hunspell::stem(char*** slst, char ** desc, int n)
 3037: {
21326:   char result[MAXLNLEN];
21326:   char result2[MAXLNLEN];
21326:   *slst = NULL;
21326:   if (n == 0) return 0;
21326:   *result2 = '\0';
21326:   for (int i = 0; i < n; i++) {
21326:     *result = '\0';
21326:     // add compound word parts (except the last one)
21326:     char * s = (char *) desc[i];
21326:     char * part = strstr(s, MORPH_PART);
21326:     if (part) {
21326:         char * nextpart = strstr(part + 1, MORPH_PART);
21326:         while (nextpart) {
21326:             copy_field(result + strlen(result), part, MORPH_PART);
21326:             part = nextpart;
21326:             nextpart = strstr(part + 1, MORPH_PART);
 3037:         }
21326:         s = part;
 3037:     }
 3037: 
21326:     char **pl;
21326:     char tok[MAXLNLEN];
21326:     strcpy(tok, s);
21326:     char * alt = strstr(tok, " | ");
21326:     while (alt) {
21326:         alt[1] = MSEP_ALT;
21326:         alt = strstr(alt, " | ");
 3037:     }
21326:     int pln = line_tok(tok, &pl, MSEP_ALT);
21326:     for (int k = 0; k < pln; k++) {
21326:         // add derivational suffixes
21326:         if (strstr(pl[k], MORPH_DERI_SFX)) {
21326:             // remove inflectional suffixes
21326:             char * is = strstr(pl[k], MORPH_INFL_SFX);
21326:             if (is) *is = '\0';
21326:             char * sg = pSMgr->suggest_gen(&(pl[k]), 1, pl[k]);
21326:             if (sg) {
21326:                 char ** gen;
21326:                 int genl = line_tok(sg, &gen, MSEP_REC);
21326:                 free(sg);
21326:                 for (int j = 0; j < genl; j++) {
21326:                     sprintf(result2 + strlen(result2), "%c%s%s",
21326:                             MSEP_REC, result, gen[j]);
21326:                 }
21326:                 freelist(&gen, genl);
21326:             }
21326:         } else {
21326:             sprintf(result2 + strlen(result2), "%c%s", MSEP_REC, result);
21326:             if (strstr(pl[k], MORPH_SURF_PFX)) {
21326:                 copy_field(result2 + strlen(result2), pl[k], MORPH_SURF_PFX);
21326:             }
21326:             copy_field(result2 + strlen(result2), pl[k], MORPH_STEM);
21326:         }
21326:     }
21326:     freelist(&pl, pln);
21326:   }
21326:   int sln = line_tok(result2, slst, MSEP_REC);
21326:   return uniqlist(*slst, sln);
 3037: 
 3037: }
 3037: 
21326: int Hunspell::stem(char*** slst, const char * word)
21326: {
21326:   char ** pl;
21326:   int pln = analyze(&pl, word);
21326:   int pln2 = stem(slst, pl, pln);
21326:   freelist(&pl, pln);
21326:   return pln2;
 3037: }
 3037: 
21326: #ifdef HUNSPELL_EXPERIMENTAL
 3037: int Hunspell::suggest_pos_stems(char*** slst, const char * word)
 3037: {
 5768:   char cw[MAXWORDUTF8LEN];
 5768:   char wspace[MAXWORDUTF8LEN];
21326:   if (! pSMgr || maxdic == 0) return 0;
 3037:   int wl = strlen(word);
 3037:   if (utf8) {
 3037:     if (wl >= MAXWORDUTF8LEN) return 0;
 3037:   } else {
 3037:     if (wl >= MAXWORDLEN) return 0;
 3037:   }
 3037:   int captype = 0;
 3037:   int abbv = 0;
 3037:   wl = cleanword(cw, word, &captype, &abbv);
 3037:   if (wl == 0) return 0;
 3037: 
 3037:   int ns = 0; // ns=0 = normalized input
 3037: 
 3037:   *slst = NULL; // HU, nsug in pSMgr->suggest
 3037: 
 3037:   switch(captype) {
 3037:      case HUHCAP:
 3037:      case NOCAP:   {
 3037:                      ns = pSMgr->suggest_pos_stems(slst, cw, ns);
 3037: 
 3037:                      if ((abbv) && (ns == 0)) {
 3037:                          memcpy(wspace,cw,wl);
 3037:                          *(wspace+wl) = '.';
 3037:                          *(wspace+wl+1) = '\0';
 3037:                          ns = pSMgr->suggest_pos_stems(slst, wspace, ns);
 3037:                      }
 3037: 
 3037:                      break;
 3037:                    }
 3037: 
 3037:      case INITCAP: {
 3037: 
 3037:                      ns = pSMgr->suggest_pos_stems(slst, cw, ns);
 3037: 
 3037:                      if (ns == 0 || ((*slst)[0][0] == '#')) {
 3037:                         memcpy(wspace,cw,(wl+1));
 3037:                         mkallsmall(wspace);
 3037:                         ns = pSMgr->suggest_pos_stems(slst, wspace, ns);
 3037:                      }
 3037: 
 3037:                      break;
 3037: 
 3037:                    }
 3037: 
 3037:      case ALLCAP: {
 3037:                      ns = pSMgr->suggest_pos_stems(slst, cw, ns);
 3037:                      if (ns != 0) break;
 3037: 
 3037:                      memcpy(wspace,cw,(wl+1));
 3037:                      mkallsmall(wspace);
 3037:                      ns = pSMgr->suggest_pos_stems(slst, wspace, ns);
 3037: 
 3037:                      if (ns == 0) {
 3037:                          mkinitcap(wspace);
 3037:                          ns = pSMgr->suggest_pos_stems(slst, wspace, ns);
 3037:                      }
 3037:                      break;
 3037:                    }
 3037:   }
 3037: 
 3037:   return ns;
 3037: }
 3037: #endif // END OF HUNSPELL_EXPERIMENTAL CODE
 3037: 
 3037: const char * Hunspell::get_wordchars()
 3037: {
 3037:   return pAMgr->get_wordchars();
 3037: }
 3037: 
 3037: unsigned short * Hunspell::get_wordchars_utf16(int * len)
 3037: {
 3037:   return pAMgr->get_wordchars_utf16(len);
 3037: }
 3037: 
 3037: void Hunspell::mkinitcap(char * p)
 3037: {
 3037:   if (!utf8) {
 3037:     if (*p != '\0') *p = csconv[((unsigned char)*p)].cupper;
 3037:   } else {
 3037:       int len;
 3037:       w_char u[MAXWORDLEN];
 3037:       len = u8_u16(u, MAXWORDLEN, p);
 3037:       unsigned short i = unicodetoupper((u[0].h << 8) + u[0].l, langnum);
 3037:       u[0].h = (unsigned char) (i >> 8);
 3037:       u[0].l = (unsigned char) (i & 0x00FF);
 3037:       u16_u8(p, MAXWORDUTF8LEN, u, len);
 3037:   }
 3037: }
 3037: 
 3037: int Hunspell::mkinitcap2(char * p, w_char * u, int nc)
 3037: {
 3037:   if (!utf8) {
 3037:     if (*p != '\0') *p = csconv[((unsigned char)*p)].cupper;
 3037:   } else if (nc > 0) {
 3037:       unsigned short i = unicodetoupper((u[0].h << 8) + u[0].l, langnum);
 3037:       u[0].h = (unsigned char) (i >> 8);
 3037:       u[0].l = (unsigned char) (i & 0x00FF);
 3037:       u16_u8(p, MAXWORDUTF8LEN, u, nc);
 3037:       return strlen(p);
 3037:   }
 3037:   return nc;
 3037: }
 3037: 
 3037: int Hunspell::mkinitsmall2(char * p, w_char * u, int nc)
 3037: {
 3037:   if (!utf8) {
 3037:     if (*p != '\0') *p = csconv[((unsigned char)*p)].clower;
 3037:   } else if (nc > 0) {
 3037:       unsigned short i = unicodetolower((u[0].h << 8) + u[0].l, langnum);
 3037:       u[0].h = (unsigned char) (i >> 8);
 3037:       u[0].l = (unsigned char) (i & 0x00FF);
 3037:       u16_u8(p, MAXWORDUTF8LEN, u, nc);
 3037:       return strlen(p);
 3037:   }
 3037:   return nc;
 3037: }
 3037: 
21326: int Hunspell::add(const char * word)
 3037: {
21326:     if (pHMgr[0]) return (pHMgr[0])->add(word);
 3037:     return 0;
 3037: }
 3037: 
21326: int Hunspell::add_with_affix(const char * word, const char * example)
 3037: {
21326:     if (pHMgr[0]) return (pHMgr[0])->add_with_affix(word, example);
21326:     return 0;
21326: }
21326: 
21326: int Hunspell::remove(const char * word)
21326: {
21326:     if (pHMgr[0]) return (pHMgr[0])->remove(word);
 3037:     return 0;
 3037: }
 3037: 
 3037: const char * Hunspell::get_version()
 3037: {
 3037:   return pAMgr->get_version();
 3037: }
 3037: 
 3037: struct cs_info * Hunspell::get_csconv()
 3037: {
 3037:   return csconv;
 3037: }
 3037: 
21326: void Hunspell::cat_result(char * result, char * st)
21326: {
21326:     if (st) {
21326:         if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:         mystrcat(result, st, MAXLNLEN);
21326:         free(st);
21326:     }
21326: }
21326: 
21326: int Hunspell::analyze(char*** slst, const char * word)
 3037: {
 5768:   char cw[MAXWORDUTF8LEN];
 5768:   char wspace[MAXWORDUTF8LEN];
21326:   w_char unicw[MAXWORDLEN];
21326:   int wl2 = 0;
21326:   *slst = NULL;
21326:   if (! pSMgr || maxdic == 0) return 0;
21326:   int nc = strlen(word);
 3037:   if (utf8) {
21326:     if (nc >= MAXWORDUTF8LEN) return 0;
 3037:   } else {
21326:     if (nc >= MAXWORDLEN) return 0;
 3037:   }
 3037:   int captype = 0;
 3037:   int abbv = 0;
21326:   int wl = 0;
21326: 
21326:   // input conversion
21326:   RepList * rl = (pAMgr) ? pAMgr->get_iconvtable() : NULL;
21326:   if (rl && rl->conv(word, wspace)) wl = cleanword2(cw, wspace, unicw, &nc, &captype, &abbv);
21326:   else wl = cleanword2(cw, word, unicw, &nc, &captype, &abbv);
21326: 
 3037:   if (wl == 0) {
 3037:       if (abbv) {
 3037:           for (wl = 0; wl < abbv; wl++) cw[wl] = '.';
 3037:           cw[wl] = '\0';
 3037:           abbv = 0;
 3037:       } else return 0;
 3037:   }
 3037: 
 3037:   char result[MAXLNLEN];
 3037:   char * st = NULL;
 3037: 
 3037:   *result = '\0';
 3037: 
 3037:   int n = 0;
 3037:   int n2 = 0;
 3037:   int n3 = 0;
 3037: 
 3037:   // test numbers
 3037:   // LANG_hu section: set dash information for suggestions
 3037:   if (langnum == LANG_hu) {
 3037:   while ((n < wl) &&
 3037:         (((cw[n] <= '9') && (cw[n] >= '0')) || (((cw[n] == '.') || (cw[n] == ',')) && (n > 0)))) {
 3037:         n++;
 3037:         if ((cw[n] == '.') || (cw[n] == ',')) {
 3037:                 if (((n2 == 0) && (n > 3)) ||
 3037:                         ((n2 > 0) && ((cw[n-1] == '.') || (cw[n-1] == ',')))) break;
 3037:                 n2++;
 3037:                 n3 = n;
 3037:         }
 3037:   }
 3037: 
21326:   if ((n == wl) && (n3 > 0) && (n - n3 > 3)) return 0;
 3037:   if ((n == wl) || ((n>0) && ((cw[n]=='%') || (cw[n]=='\xB0')) && checkword(cw+n, NULL, NULL))) {
21326:         mystrcat(result, cw, MAXLNLEN);
 3037:         result[n - 1] = '\0';
21326:         if (n == wl) cat_result(result, pSMgr->suggest_morph(cw + n - 1));
21326:         else {
 3037:                 char sign = cw[n];
 3037:                 cw[n] = '\0';
21326:                 cat_result(result, pSMgr->suggest_morph(cw + n - 1));
21326:                 mystrcat(result, "+", MAXLNLEN); // XXX SPEC. MORPHCODE
21326:                 cw[n] = sign;
21326:                 cat_result(result, pSMgr->suggest_morph(cw + n));
 3037:         }
21326:         return line_tok(result, slst, MSEP_REC);
 3037:   }
 3037:   }
 3037:   // END OF LANG_hu section
 3037: 
 3037:   switch(captype) {
21326:      case HUHCAP:
21326:      case HUHINITCAP:
 3037:      case NOCAP:  {
21326:                     cat_result(result, pSMgr->suggest_morph(cw));
 3037:                     if (abbv) {
 3037:                         memcpy(wspace,cw,wl);
 3037:                         *(wspace+wl) = '.';
 3037:                         *(wspace+wl+1) = '\0';
21326:                         cat_result(result, pSMgr->suggest_morph(wspace));
 3037:                     }
 3037:                     break;
 3037:                 }
 3037:      case INITCAP: {
21326:                      wl = mkallsmall2(cw, unicw, nc);
 3037:                      memcpy(wspace,cw,(wl+1));
21326:                      wl2 = mkinitcap2(cw, unicw, nc);
21326:                      cat_result(result, pSMgr->suggest_morph(wspace));
21326:                      cat_result(result, pSMgr->suggest_morph(cw));
21326:                      if (abbv) {
21326:                          *(wspace+wl) = '.';
21326:                          *(wspace+wl+1) = '\0';
21326:                          cat_result(result, pSMgr->suggest_morph(wspace));
21326: 
21326:                          memcpy(wspace, cw, wl2);
21326:                          *(wspace+wl2) = '.';
21326:                          *(wspace+wl2+1) = '\0';
21326: 
21326:                          cat_result(result, pSMgr->suggest_morph(wspace));
 3037:                      }
21326:                      break;
 3037:                    }
21326:      case ALLCAP: {
21326:                      cat_result(result, pSMgr->suggest_morph(cw));
 3037:                      if (abbv) {
 3037:                          memcpy(wspace,cw,wl);
 3037:                          *(wspace+wl) = '.';
 3037:                          *(wspace+wl+1) = '\0';
21326:                          cat_result(result, pSMgr->suggest_morph(cw));
 3037:                      }
21326:                      wl = mkallsmall2(cw, unicw, nc);
21326:                      memcpy(wspace,cw,(wl+1));
21326:                      wl2 = mkinitcap2(cw, unicw, nc);
21326: 
21326:                      cat_result(result, pSMgr->suggest_morph(wspace));
21326:                      cat_result(result, pSMgr->suggest_morph(cw));
21326:                      if (abbv) {
21326:                          *(wspace+wl) = '.';
21326:                          *(wspace+wl+1) = '\0';
21326:                          cat_result(result, pSMgr->suggest_morph(wspace));
21326: 
21326:                          memcpy(wspace, cw, wl2);
21326:                          *(wspace+wl2) = '.';
21326:                          *(wspace+wl2+1) = '\0';
21326: 
21326:                          cat_result(result, pSMgr->suggest_morph(wspace));
 3037:                      }
 3037:                      break;
 3037:                    }
 3037:   }
 3037: 
21326:   if (*result) {
 3037:     // word reversing wrapper for complex prefixes
 3037:     if (complexprefixes) {
 3037:       if (utf8) reverseword_utf(result); else reverseword(result);
 3037:     }
21326:     return line_tok(result, slst, MSEP_REC);
21326: 
 3037:   }
 3037: 
 3037:   // compound word with dash (HU) I18n
 3037:   char * dash = NULL;
 3037:   int nresult = 0;
 3037:   // LANG_hu section: set dash information for suggestions
 3037:   if (langnum == LANG_hu) dash = (char *) strchr(cw,'-');
 3037:   if ((langnum == LANG_hu) && dash) {
 3037:       *dash='\0';
 3037:       // examine 2 sides of the dash
 3037:       if (dash[1] == '\0') { // base word ending with dash
43385:         if (spell(cw)) {
43385: 		char * p = pSMgr->suggest_morph(cw);
61623: 		if (p) {
61623: 		    int ret = line_tok(p, slst, MSEP_REC);
61623: 		    free(p);
61623: 		    return ret;
61623: 		}
61623: 		
43385: 	}
 3037:       } else if ((dash[1] == 'e') && (dash[2] == '\0')) { // XXX (HU) -e hat.
 3037:         if (spell(cw) && (spell("-e"))) {
 3037:                         st = pSMgr->suggest_morph(cw);
 3037:                         if (st) {
21326:                                 mystrcat(result, st, MAXLNLEN);
 3037:                                 free(st);
 3037:                         }
21326:                         mystrcat(result,"+", MAXLNLEN); // XXX spec. separator in MORPHCODE
 3037:                         st = pSMgr->suggest_morph("-e");
 3037:                         if (st) {
21326:                                 mystrcat(result, st, MAXLNLEN);
 3037:                                 free(st);
 3037:                         }
21326:                         return line_tok(result, slst, MSEP_REC);
 3037:                 }
 3037:       } else {
 3037:       // first word ending with dash: word- XXX ???
 3037:         char r2 = *(dash + 1);
 3037:         dash[0]='-';
 3037:         dash[1]='\0';
 3037:         nresult = spell(cw);
 3037:         dash[1] = r2;
 3037:         dash[0]='\0';
 3037:         if (nresult && spell(dash+1) && ((strlen(dash+1) > 1) ||
 3037:                 ((dash[1] > '0') && (dash[1] < '9')))) {
21326:                             st = pSMgr->suggest_morph(cw);
 3037:                             if (st) {
21326:                                 mystrcat(result, st, MAXLNLEN);
 3037:                                     free(st);
21326:                                 mystrcat(result,"+", MAXLNLEN); // XXX spec. separator in MORPHCODE
 3037:                             }
21326:                             st = pSMgr->suggest_morph(dash+1);
 3037:                             if (st) {
21326:                                     mystrcat(result, st, MAXLNLEN);
 3037:                                     free(st);
 3037:                             }
21326:                             return line_tok(result, slst, MSEP_REC);
 3037:                         }
 3037:       }
 3037:       // affixed number in correct word
 3037:      if (nresult && (dash > cw) && (((*(dash-1)<='9') &&
 3037:                         (*(dash-1)>='0')) || (*(dash-1)=='.'))) {
 3037:          *dash='-';
 3037:          n = 1;
 3037:          if (*(dash - n) == '.') n++;
 3037:          // search first not a number character to left from dash
 3037:          while (((dash - n)>=cw) && ((*(dash - n)=='0') || (n < 3)) && (n < 6)) {
 3037:             n++;
 3037:          }
 3037:          if ((dash - n) < cw) n--;
 3037:          // numbers: valami1000000-hoz
 3037:          // examine 100000-hoz, 10000-hoz 1000-hoz, 10-hoz,
 3037:          // 56-hoz, 6-hoz
 3037:          for(; n >= 1; n--) {
 3037:             if ((*(dash - n) >= '0') && (*(dash - n) <= '9') && checkword(dash - n, NULL, NULL)) {
21326:                     mystrcat(result, cw, MAXLNLEN);
 3037:                     result[dash - cw - n] = '\0';
 3037:                         st = pSMgr->suggest_morph(dash - n);
 3037:                         if (st) {
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                                 free(st);
 3037:                         }
21326:                         return line_tok(result, slst, MSEP_REC);
 3037:             }
 3037:          }
 3037:      }
 3037:   }
21326:   return 0;
 3037: }
 3037: 
21326: int Hunspell::generate(char*** slst, const char * word, char ** pl, int pln)
21326: {
21326:   *slst = NULL;
21326:   if (!pSMgr || !pln) return 0;
21326:   char **pl2;
21326:   int pl2n = analyze(&pl2, word);
21326:   int captype = 0;
21326:   int abbv = 0;
21326:   char cw[MAXWORDUTF8LEN];
21326:   cleanword(cw, word, &captype, &abbv);
21326:   char result[MAXLNLEN];
21326:   *result = '\0';
21326: 
21326:   for (int i = 0; i < pln; i++) {
21326:     cat_result(result, pSMgr->suggest_gen(pl2, pl2n, pl[i]));
21326:   }
21326:   freelist(&pl2, pl2n);
21326: 
21326:   if (*result) {
21326:     // allcap
21326:     if (captype == ALLCAP) mkallcap(result);
21326: 
21326:     // line split
21326:     int linenum = line_tok(result, slst, MSEP_REC);
21326: 
21326:     // capitalize
21326:     if (captype == INITCAP || captype == HUHINITCAP) {
21326:         for (int j=0; j < linenum; j++) mkinitcap((*slst)[j]);
21326:     }
21326: 
21326:     // temporary filtering of prefix related errors (eg.
21326:     // generate("undrinkable", "eats") --> "undrinkables" and "*undrinks")
21326: 
21326:     int r = 0;
21326:     for (int j=0; j < linenum; j++) {
21326:         if (!spell((*slst)[j])) {
21326:             free((*slst)[j]);
21326:             (*slst)[j] = NULL;
21326:         } else {
21326:             if (r < j) (*slst)[r] = (*slst)[j];
21326:             r++;
21326:         }
21326:     }
21326:     if (r > 0) return r;
21326:     free(*slst);
21326:     *slst = NULL;
21326:   }
21326:   return 0;
21326: }
21326: 
21326: int Hunspell::generate(char*** slst, const char * word, const char * pattern)
21326: {
21326:   char **pl;
21326:   int pln = analyze(&pl, pattern);
21326:   int n = generate(slst, word, pl, pln);
21326:   freelist(&pl, pln);
21326:   return uniqlist(*slst, n);
21326: }
21326: 
21326: // minimal XML parser functions
21326: int Hunspell::get_xml_par(char * dest, const char * par, int max)
21326: {
21326:    char * d = dest;
21326:    if (!par) return 0;
21326:    char end = *par;
21326:    char * dmax = dest + max;
21326:    if (end == '>') end = '<';
21326:    else if (end != '\'' && end != '"') return 0; // bad XML
21326:    for (par++; d < dmax && *par != '\0' && *par != end; par++, d++) *d = *par;
21326:    *d = '\0';
21326:    mystrrep(dest, "&lt;", "<");
21326:    mystrrep(dest, "&amp;", "&");
43385:    return (int)(d - dest);
43385: }
43385: 
43385: int Hunspell::get_langnum() const
43385: {
43385:    return langnum;
21326: }
21326: 
21326: // return the beginning of the element (attr == NULL) or the attribute
21326: const char * Hunspell::get_xml_pos(const char * s, const char * attr)
21326: {
21326:   const char * end = strchr(s, '>');
21326:   const char * p = s;
21326:   if (attr == NULL) return end;
21326:   do {
21326:     p = strstr(p, attr);
21326:     if (!p || p >= end) return 0;
21326:   } while (*(p-1) != ' ' &&  *(p-1) != '\n');
21326:   return p + strlen(attr);
21326: }
21326: 
21326: int Hunspell::check_xml_par(const char * q, const char * attr, const char * value) {
21326:   char cw[MAXWORDUTF8LEN];
21326:   if (get_xml_par(cw, get_xml_pos(q, attr), MAXWORDUTF8LEN - 1) &&
21326:     strcmp(cw, value) == 0) return 1;
21326:   return 0;
21326: }
21326: 
21326: int Hunspell::get_xml_list(char ***slst, char * list, const char * tag) {
21326:     int n = 0;
21326:     char * p;
21326:     if (!list) return 0;
21326:     for (p = list; (p = strstr(p, tag)); p++) n++;
21326:     if (n == 0) return 0;
21326:     *slst = (char **) malloc(sizeof(char *) * n);
21326:     if (!*slst) return 0;
21326:     for (p = list, n = 0; (p = strstr(p, tag)); p++, n++) {
21326:         int l = strlen(p);
43385:         (*slst)[n] = (char *) malloc(l + 1);
61625:         if (!(*slst)[n]) return n;
43385:         if (!get_xml_par((*slst)[n], p + strlen(tag) - 1, l)) {
43385:             free((*slst)[n]);
43385:             break;
43385:         }
21326:     }
21326:     return n;
21326: }
21326: 
21326: int Hunspell::spellml(char*** slst, const char * word)
21326: {
21326:   char *q, *q2;
21326:   char cw[MAXWORDUTF8LEN], cw2[MAXWORDUTF8LEN];
21326:   q = (char *) strstr(word, "<query");
21326:   if (!q) return 0; // bad XML input
21326:   q2 = strchr(q, '>');
21326:   if (!q2) return 0; // bad XML input
21326:   q2 = strstr(q2, "<word");
21326:   if (!q2) return 0; // bad XML input
21326:   if (check_xml_par(q, "type=", "analyze")) {
21326:       int n = 0, s = 0;
43385:       if (get_xml_par(cw, strchr(q2, '>'), MAXWORDUTF8LEN - 10)) n = analyze(slst, cw);
21326:       if (n == 0) return 0;
21326:       // convert the result to <code><a>ana1</a><a>ana2</a></code> format
21326:       for (int i = 0; i < n; i++) s+= strlen((*slst)[i]);
21326:       char * r = (char *) malloc(6 + 5 * s + 7 * n + 7 + 1); // XXX 5*s->&->&amp;
21326:       if (!r) return 0;
21326:       strcpy(r, "<code>");
21326:       for (int i = 0; i < n; i++) {
21326:         int l = strlen(r);
21326:         strcpy(r + l, "<a>");
21326:         strcpy(r + l + 3, (*slst)[i]);
21326:         mystrrep(r + l + 3, "\t", " ");
21326:         mystrrep(r + l + 3, "<", "&lt;");
21326:         mystrrep(r + l + 3, "&", "&amp;");
21326:         strcat(r, "</a>");
21326:         free((*slst)[i]);
21326:       }
21326:       strcat(r, "</code>");
21326:       (*slst)[0] = r;
21326:       return 1;
21326:   } else if (check_xml_par(q, "type=", "stem")) {
43385:       if (get_xml_par(cw, strchr(q2, '>'), MAXWORDUTF8LEN - 1)) return stem(slst, cw);
21326:   } else if (check_xml_par(q, "type=", "generate")) {
43385:       int n = get_xml_par(cw, strchr(q2, '>'), MAXWORDUTF8LEN - 1);
21326:       if (n == 0) return 0;
21326:       char * q3 = strstr(q2 + 1, "<word");
21326:       if (q3) {
43385:         if (get_xml_par(cw2, strchr(q3, '>'), MAXWORDUTF8LEN - 1)) {
21326:             return generate(slst, cw, cw2);
21326:         }
21326:       } else {
61625:         if ((q2 = strstr(q2 + 1, "<code"))) {
21326:           char ** slst2;
61625:           if ((n = get_xml_list(&slst2, strchr(q2, '>'), "<a>"))) {
21326:             int n2 = generate(slst, cw, slst2, n);
21326:             freelist(&slst2, n);
21326:             return uniqlist(*slst, n2);
21326:           }
61625:           freelist(&slst2, n);
61625:         }
21326:       }
21326:   }
21326:   return 0;
21326: }
21326: 
21326: 
21326: #ifdef HUNSPELL_EXPERIMENTAL
 3037: // XXX need UTF-8 support
 3037: char * Hunspell::morph_with_correction(const char * word)
 3037: {
 5768:   char cw[MAXWORDUTF8LEN];
 5768:   char wspace[MAXWORDUTF8LEN];
21326:   if (! pSMgr || maxdic == 0) return NULL;
 3037:   int wl = strlen(word);
 3037:   if (utf8) {
21326:     if (wl >= MAXWORDUTF8LEN) return NULL;
 3037:   } else {
21326:     if (wl >= MAXWORDLEN) return NULL;
 3037:   }
 3037:   int captype = 0;
 3037:   int abbv = 0;
 3037:   wl = cleanword(cw, word, &captype, &abbv);
21326:   if (wl == 0) return NULL;
 3037: 
 3037:   char result[MAXLNLEN];
 3037:   char * st = NULL;
 3037: 
 3037:   *result = '\0';
 3037: 
 3037: 
 3037:   switch(captype) {
 3037:      case NOCAP:   {
 3037:                      st = pSMgr->suggest_morph_for_spelling_error(cw);
 3037:                      if (st) {
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                         free(st);
 3037:                      }
 3037:                      if (abbv) {
 3037:                          memcpy(wspace,cw,wl);
 3037:                          *(wspace+wl) = '.';
 3037:                          *(wspace+wl+1) = '\0';
 3037:                          st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                          if (st) {
21326:                             if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:                             mystrcat(result, st, MAXLNLEN);
 3037:                             free(st);
 3037:                                                  }
 3037:                      }
 3037:                                          break;
 3037:                    }
 3037:      case INITCAP: {
 3037:                      memcpy(wspace,cw,(wl+1));
 3037:                      mkallsmall(wspace);
 3037:                      st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                      if (st) {
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                         free(st);
 3037:                      }
 3037:                      st = pSMgr->suggest_morph_for_spelling_error(cw);
 3037:                      if (st) {
21326:                         if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                         free(st);
 3037:                      }
 3037:                      if (abbv) {
 3037:                          memcpy(wspace,cw,wl);
 3037:                          *(wspace+wl) = '.';
 3037:                          *(wspace+wl+1) = '\0';
 3037:                          mkallsmall(wspace);
 3037:                          st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                          if (st) {
21326:                             if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:                             mystrcat(result, st, MAXLNLEN);
 3037:                             free(st);
 3037:                          }
 3037:                          mkinitcap(wspace);
 3037:                          st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                          if (st) {
21326:                             if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:                             mystrcat(result, st, MAXLNLEN);
 3037:                             free(st);
 3037:                          }
 3037:                      }
 3037:                      break;
 3037:                    }
 3037:      case HUHCAP: {
 3037:                      st = pSMgr->suggest_morph_for_spelling_error(cw);
 3037:                      if (st) {
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                         free(st);
 3037:                      }
 3037:                      memcpy(wspace,cw,(wl+1));
 3037:                      mkallsmall(wspace);
 3037:                      st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                      if (st) {
21326:                         if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                         free(st);
 3037:                      }
 3037:                      break;
 3037:                  }
 3037:      case ALLCAP: {
 3037:                      memcpy(wspace,cw,(wl+1));
 3037:                      st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                      if (st) {
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                         free(st);
 3037:                      }
 3037:                      mkallsmall(wspace);
 3037:                      st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                      if (st) {
21326:                         if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                         free(st);
 3037:                      }
 3037:                      mkinitcap(wspace);
 3037:                      st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                      if (st) {
21326:                         if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:                         mystrcat(result, st, MAXLNLEN);
 3037:                         free(st);
 3037:                      }
 3037:                      if (abbv) {
 3037:                         memcpy(wspace,cw,(wl+1));
 3037:                         *(wspace+wl) = '.';
 3037:                         *(wspace+wl+1) = '\0';
21326:                         if (*result) mystrcat(result, "\n", MAXLNLEN);
 3037:                         st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                         if (st) {
21326:                             mystrcat(result, st, MAXLNLEN);
 3037:                             free(st);
 3037:                         }
 3037:                         mkallsmall(wspace);
 3037:                         st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                         if (st) {
21326:                           if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:                           mystrcat(result, st, MAXLNLEN);
 3037:                           free(st);
 3037:                         }
 3037:                         mkinitcap(wspace);
 3037:                         st = pSMgr->suggest_morph_for_spelling_error(wspace);
 3037:                         if (st) {
21326:                           if (*result) mystrcat(result, "\n", MAXLNLEN);
21326:                           mystrcat(result, st, MAXLNLEN);
 3037:                           free(st);
 3037:                         }
 3037:                      }
 3037:                      break;
 3037:                    }
 3037:   }
 3037: 
21326:   if (*result) return mystrdup(result);
 3037:   return NULL;
 3037: }
 3037: 
 3037: #endif // END OF HUNSPELL_EXPERIMENTAL CODE
 3037: 
 3037: Hunhandle *Hunspell_create(const char * affpath, const char * dpath)
 3037: {
 3037:         return (Hunhandle*)(new Hunspell(affpath, dpath));
 3037: }
 3037: 
21326: Hunhandle *Hunspell_create_key(const char * affpath, const char * dpath,
21326:     const char * key)
21326: {
21326:         return (Hunhandle*)(new Hunspell(affpath, dpath, key));
21326: }
21326: 
 3037: void Hunspell_destroy(Hunhandle *pHunspell)
 3037: {
 3037:         delete (Hunspell*)(pHunspell);
 3037: }
 3037: 
 3037: int Hunspell_spell(Hunhandle *pHunspell, const char *word)
 3037: {
 3037:         return ((Hunspell*)pHunspell)->spell(word);
 3037: }
 3037: 
 3037: char *Hunspell_get_dic_encoding(Hunhandle *pHunspell)
 3037: {
 3037:         return ((Hunspell*)pHunspell)->get_dic_encoding();
 3037: }
 3037: 
 3037: int Hunspell_suggest(Hunhandle *pHunspell, char*** slst, const char * word)
 3037: {
 3037:         return ((Hunspell*)pHunspell)->suggest(slst, word);
 3037: }
21326: 
21326: int Hunspell_analyze(Hunhandle *pHunspell, char*** slst, const char * word)
21326: {
21326:         return ((Hunspell*)pHunspell)->analyze(slst, word);
21326: }
21326: 
21326: int Hunspell_stem(Hunhandle *pHunspell, char*** slst, const char * word)
21326: {
21326:         return ((Hunspell*)pHunspell)->stem(slst, word);
21326: }
21326: 
43385: int Hunspell_stem2(Hunhandle *pHunspell, char*** slst, char** desc, int n)
21326: {
21326:         return ((Hunspell*)pHunspell)->stem(slst, desc, n);
21326: }
21326: 
21326: int Hunspell_generate(Hunhandle *pHunspell, char*** slst, const char * word,
21326:     const char * word2)
21326: {
21326:         return ((Hunspell*)pHunspell)->generate(slst, word, word2);
21326: }
21326: 
43385: int Hunspell_generate2(Hunhandle *pHunspell, char*** slst, const char * word,
21326:     char** desc, int n)
21326: {
21326:         return ((Hunspell*)pHunspell)->generate(slst, word, desc, n);
21326: }
21326: 
21326:   /* functions for run-time modification of the dictionary */
21326: 
21326:   /* add word to the run-time dictionary */
21326: 
21326: int Hunspell_add(Hunhandle *pHunspell, const char * word) {
21326:         return ((Hunspell*)pHunspell)->add(word);
21326: }
21326: 
21326:   /* add word to the run-time dictionary with affix flags of
21326:    * the example (a dictionary word): Hunspell will recognize
21326:    * affixed forms of the new word, too.
21326:    */
21326: 
21326: int Hunspell_add_with_affix(Hunhandle *pHunspell, const char * word,
21326:         const char * example) {
21326:         return ((Hunspell*)pHunspell)->add_with_affix(word, example);
21326: }
21326: 
21326:   /* remove word from the run-time dictionary */
21326: 
21326: int Hunspell_remove(Hunhandle *pHunspell, const char * word) {
21326:         return ((Hunspell*)pHunspell)->remove(word);
21326: }
21326: 
43385: void Hunspell_free_list(Hunhandle *, char *** slst, int n) {
21326:         freelist(slst, n);
21326: }
