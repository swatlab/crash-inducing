16198: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
16198: /* ***** BEGIN LICENSE BLOCK *****
16198:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
16198:  *
16198:  * The contents of this file are subject to the Mozilla Public License Version
16198:  * 1.1 (the "License"); you may not use this file except in compliance with
16198:  * the License. You may obtain a copy of the License at
16198:  * http://www.mozilla.org/MPL/
16198:  *
16198:  * Software distributed under the License is distributed on an "AS IS" basis,
16198:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
16198:  * for the specific language governing rights and limitations under the
16198:  * License.
16198:  *
16198:  * The Original Code is mozilla.org code.
16198:  *
16198:  * The Initial Developer of the Original Code is
16198:  * Markus Stange <mstange@themasta.com>
16198:  * Portions created by the Initial Developer are Copyright (C) 2008
16198:  * the Initial Developer. All Rights Reserved.
16198:  *
16198:  * Contributor(s):
16198:  *
16198:  * Alternatively, the contents of this file may be used under the terms of
16198:  * either the GNU General Public License Version 2 or later (the "GPL"), or
16198:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
16198:  * in which case the provisions of the GPL or the LGPL are applicable instead
16198:  * of those above. If you wish to allow use of your version of this file only
16198:  * under the terms of either the GPL or the LGPL, and not to allow others to
16198:  * use your version of this file under the terms of the MPL, indicate your
16198:  * decision by deleting the provisions above and replace them with the notice
16198:  * and other provisions required by the GPL or the LGPL. If you do not delete
16198:  * the provisions above, a recipient may use your version of this file under
16198:  * the terms of any one of the MPL, the GPL or the LGPL.
16198:  *
16198:  * ***** END LICENSE BLOCK ***** */
16198: 
16198: #include "nsDOMMouseScrollEvent.h"
16198: #include "nsGUIEvent.h"
16198: #include "nsIContent.h"
16198: #include "nsContentUtils.h"
16198: 
16198: nsDOMMouseScrollEvent::nsDOMMouseScrollEvent(nsPresContext* aPresContext,
16198:                                              nsInputEvent* aEvent)
16198:   : nsDOMMouseEvent(aPresContext, aEvent ? aEvent :
16198:                                   new nsMouseScrollEvent(PR_FALSE, 0, nsnull))
16198: {
22956:   if (aEvent) {
22956:     mEventIsInternal = PR_FALSE;
22956:   } else {
22956:     mEventIsInternal = PR_TRUE;
22956:     mEvent->time = PR_Now();
22956:     mEvent->refPoint.x = mEvent->refPoint.y = 0;
40485:     static_cast<nsMouseEvent*>(mEvent)->inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_UNKNOWN;
22956:   }
22956: 
16198:   if(mEvent->eventStructType == NS_MOUSE_SCROLL_EVENT) {
16198:     nsMouseScrollEvent* mouseEvent = static_cast<nsMouseScrollEvent*>(mEvent);
16198:     mDetail = mouseEvent->delta;
16198:   }
16198: }
16198: 
16198: nsDOMMouseScrollEvent::~nsDOMMouseScrollEvent()
16198: {
16198:   if (mEventIsInternal && mEvent) {
16198:     switch (mEvent->eventStructType)
16198:     {
16198:       case NS_MOUSE_SCROLL_EVENT:
16198:         delete static_cast<nsMouseScrollEvent*>(mEvent);
16198:         break;
16198:       default:
16198:         delete mEvent;
16198:         break;
16198:     }
16198:     mEvent = nsnull;
16198:   }
16198: }
16198: 
16198: NS_IMPL_ADDREF_INHERITED(nsDOMMouseScrollEvent, nsDOMMouseEvent)
16198: NS_IMPL_RELEASE_INHERITED(nsDOMMouseScrollEvent, nsDOMMouseEvent)
16198: 
40490: DOMCI_DATA(MouseScrollEvent, nsDOMMouseScrollEvent)
40490: 
16198: NS_INTERFACE_MAP_BEGIN(nsDOMMouseScrollEvent)
16198:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseScrollEvent)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MouseScrollEvent)
16198: NS_INTERFACE_MAP_END_INHERITING(nsDOMMouseEvent)
16198: 
16198: NS_IMETHODIMP
16198: nsDOMMouseScrollEvent::InitMouseScrollEvent(const nsAString & aType, PRBool aCanBubble, PRBool aCancelable,
68870:                                 nsIDOMAbstractView *aView, PRInt32 aDetail, PRInt32 aScreenX, 
16198:                                 PRInt32 aScreenY, PRInt32 aClientX, PRInt32 aClientY, 
16198:                                 PRBool aCtrlKey, PRBool aAltKey, PRBool aShiftKey, 
16198:                                 PRBool aMetaKey, PRUint16 aButton, nsIDOMEventTarget *aRelatedTarget,
16198:                                 PRInt32 aAxis)
16198: {
16198:   nsresult rv = nsDOMMouseEvent::InitMouseEvent(aType, aCanBubble, aCancelable, aView, aDetail,
16198:                                                 aScreenX, aScreenY, aClientX, aClientY, aCtrlKey,
16198:                                                 aAltKey, aShiftKey, aMetaKey, aButton, aRelatedTarget);
16198:   NS_ENSURE_SUCCESS(rv, rv);
16198:   
16198:   if (mEvent->eventStructType == NS_MOUSE_SCROLL_EVENT) {
16198:     static_cast<nsMouseScrollEvent*>(mEvent)->scrollFlags =
16198:         (aAxis == HORIZONTAL_AXIS) ? nsMouseScrollEvent::kIsHorizontal
16198:                                    : nsMouseScrollEvent::kIsVertical;
16198:   }
16198: 
16198:   return NS_OK;
16198: }
16198: 
16198: 
16198: NS_IMETHODIMP
16198: nsDOMMouseScrollEvent::GetAxis(PRInt32* aResult)
16198: {
16198:   NS_ENSURE_ARG_POINTER(aResult);
16198: 
16198:   if (mEvent->eventStructType == NS_MOUSE_SCROLL_EVENT) {
16198:     PRUint32 flags = static_cast<nsMouseScrollEvent*>(mEvent)->scrollFlags;
16198:     *aResult = (flags & nsMouseScrollEvent::kIsHorizontal)
16198:          ? PRInt32(HORIZONTAL_AXIS) : PRInt32(VERTICAL_AXIS);
16198:   } else {
16198:     *aResult = 0;
16198:   }
16198:   return NS_OK;
16198: }
16198: 
16198: nsresult NS_NewDOMMouseScrollEvent(nsIDOMEvent** aInstancePtrResult,
16198:                                    nsPresContext* aPresContext,
16198:                                    nsInputEvent *aEvent) 
16198: {
16198:   nsDOMMouseScrollEvent* it = new nsDOMMouseScrollEvent(aPresContext, aEvent);
68870:   if (nsnull == it) {
68870:     return NS_ERROR_OUT_OF_MEMORY;
68870:   }
68870: 
16198:   return CallQueryInterface(it, aInstancePtrResult);
16198: }
