41434: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
41434:  * ***** BEGIN LICENSE BLOCK *****
41434:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
41434:  *
41434:  * The contents of this file are subject to the Mozilla Public License Version
41434:  * 1.1 (the "License"); you may not use this file except in compliance with
41434:  * the License. You may obtain a copy of the License at
41434:  * http://www.mozilla.org/MPL/
41434:  *
41434:  * Software distributed under the License is distributed on an "AS IS" basis,
41434:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
41434:  * for the specific language governing rights and limitations under the
41434:  * License.
41434:  *
41434:  * The Initial Developer of the Original Code is Mozilla Foundation.
41434:  * Portions created by the Initial Developer are Copyright (C) 2010
41434:  * the Initial Developer. All Rights Reserved.
41434:  *
41434:  * Contributor(s):
41434:  *   Bas Schouten <bschouten@mozilla.com>
41434:  *   Matt Woodrow <mwoodrow@mozilla.com>
41434:  *
41434:  * Alternatively, the contents of this file may be used under the terms of
41434:  * either the GNU General Public License Version 2 or later (the "GPL"), or
41434:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
41434:  * in which case the provisions of the GPL or the LGPL are applicable instead
41434:  * of those above. If you wish to allow use of your version of this file only
41434:  * under the terms of either the GPL or the LGPL, and not to allow others to
41434:  * use your version of this file under the terms of the MPL, indicate your
41434:  * decision by deleting the provisions above and replace them with the notice
41434:  * and other provisions required by the GPL or the LGPL. If you do not delete
41434:  * the provisions above, a recipient may use your version of this file under
41434:  * the terms of any one of the MPL, the GPL or the LGPL.
41434:  *
41434:  * ***** END LICENSE BLOCK ***** */
41434: 
41434: #include "GLContextProvider.h"
41434: #include "nsDebug.h"
41434: #include "nsIWidget.h"
41434: #include "OpenGL/OpenGL.h"
41434: #include <OpenGL/gl.h>
41434: #include <AppKit/NSOpenGL.h>
44173: #include "gfxASurface.h"
46980: #include "gfxImageSurface.h"
57348: #include "gfxQuartzSurface.h"
46980: #include "gfxPlatform.h"
57545: #include "prenv.h"
41434: 
41434: namespace mozilla {
41434: namespace gl {
41434: 
57545: static PRBool gUseDoubleBufferedWindows = PR_TRUE;
57545: 
41434: class CGLLibrary
41434: {
41434: public:
47908:     CGLLibrary()
47908:       : mInitialized(PR_FALSE),
47908:         mOGLLibrary(nsnull),
47908:         mPixelFormat(nsnull)
47908:     { }
41434: 
41434:     PRBool EnsureInitialized()
41434:     {
41434:         if (mInitialized) {
41434:             return PR_TRUE;
41434:         }
41434:         if (!mOGLLibrary) {
41434:             mOGLLibrary = PR_LoadLibrary("/System/Library/Frameworks/OpenGL.framework/OpenGL");
41434:             if (!mOGLLibrary) {
41434:                 NS_WARNING("Couldn't load OpenGL Framework.");
41434:                 return PR_FALSE;
41434:             }
41434:         }
41434: 
57545:         const char* db = PR_GetEnv("MOZ_CGL_DB");
57545:         gUseDoubleBufferedWindows = (!db || *db != '0');
57545: 
41434:         mInitialized = PR_TRUE;
41434:         return PR_TRUE;
41434:     }
41434: 
47908:     NSOpenGLPixelFormat *PixelFormat()
47908:     {
47908:         if (mPixelFormat == nsnull) {
47908:             NSOpenGLPixelFormatAttribute attribs[] = {
47908:                 NSOpenGLPFAAccelerated,
57545:                 NSOpenGLPFADoubleBuffer,
47908:                 (NSOpenGLPixelFormatAttribute)nil 
47908:             };
47908: 
57545:             if (!gUseDoubleBufferedWindows) {
57545:               attribs[1] = (NSOpenGLPixelFormatAttribute)nil;
57545:             }
57545: 
47908:             mPixelFormat = [[NSOpenGLPixelFormat alloc] initWithAttributes:attribs];
47908:         }
47908: 
47908:         return mPixelFormat;
47908:     }
41434: private:
41434:     PRBool mInitialized;
41434:     PRLibrary *mOGLLibrary;
47908:     NSOpenGLPixelFormat *mPixelFormat;
41434: }; 
41434: 
41434: CGLLibrary sCGLLibrary;
41434: 
41434: class GLContextCGL : public GLContext
41434: {
47908:     friend class GLContextProviderCGL;
47908: 
41434: public:
47908:     GLContextCGL(const ContextFormat& aFormat,
47908:                  GLContext *aShareContext,
47908:                  NSOpenGLContext *aContext,
47908:                  PRBool aIsOffscreen = PR_FALSE)
47908:         : GLContext(aFormat, aIsOffscreen, aShareContext),
47908:           mContext(aContext),
47908:           mPBuffer(nsnull),
47908:           mTempTextureName(0)
42402:     { }
42402: 
47908:     GLContextCGL(const ContextFormat& aFormat,
47908:                  GLContext *aShareContext,
47908:                  NSOpenGLContext *aContext,
47908:                  NSOpenGLPixelBuffer *aPixelBuffer)
47908:         : GLContext(aFormat, PR_TRUE, aShareContext),
47908:           mContext(aContext),
47908:           mPBuffer(aPixelBuffer),
47908:           mTempTextureName(0)
42402:     { }
41434: 
41434:     ~GLContextCGL()
41434:     {
54505:         MarkDestroyed();
47908: 
42402:         if (mContext)
41434:             [mContext release];
42402: 
47908:         if (mPBuffer)
47908:             [mPBuffer release];
47908:     }
42402: 
47908:     GLContextType GetContextType() {
47908:         return ContextTypeCGL;
41434:     }
41434: 
41434:     PRBool Init()
41434:     {
41434:         MakeCurrent();
41434:         return InitWithPrefix("gl", PR_TRUE);
41434:     }
41434: 
42402:     void *GetNativeData(NativeDataType aType)
41434:     { 
42402:         switch (aType) {
42402:         case NativeGLContext:
41434:             return mContext;
42402: 
42402:         default:
42402:             return nsnull;
42402:         }
41434:     }
41434: 
55380:     PRBool MakeCurrentImpl(PRBool aForce = PR_FALSE)
41434:     {
42402:         if (mContext) {
41434:             [mContext makeCurrentContext];
42402:         }
41434:         return PR_TRUE;
41434:     }
41434: 
41434:     PRBool SetupLookupFunction()
41434:     {
41434:         return PR_FALSE;
41434:     }
41434: 
57545:     PRBool IsDoubleBuffered() 
57545:     { 
57545:       return gUseDoubleBufferedWindows; 
57545:     }
57545: 
57545:     PRBool SwapBuffers()
57545:     {
57545:       [mContext flushBuffer];
57545:       return PR_TRUE;
57545:     }
57545: 
47908:     PRBool BindTex2DOffscreen(GLContext *aOffscreen);
47908:     void UnbindTex2DOffscreen(GLContext *aOffscreen);
47908:     PRBool ResizeOffscreen(const gfxIntSize& aNewSize);
47908: 
46980:     virtual already_AddRefed<TextureImage>
46980:     CreateBasicTextureImage(GLuint aTexture,
46980:                             const nsIntSize& aSize,
57421:                             GLenum aWrapMode,
46980:                             TextureImage::ContentType aContentType,
46980:                             GLContext* aContext);
46980: 
41434:     NSOpenGLContext *mContext;
47908:     NSOpenGLPixelBuffer *mPBuffer;
47908:     GLuint mTempTextureName;
41434: };
41434: 
47908: PRBool
47908: GLContextCGL::BindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     if (aOffscreen->GetContextType() != ContextTypeCGL) {
47908:         NS_WARNING("non-CGL context");
47908:         return PR_FALSE;
47908:     }
47908: 
47908:     if (!aOffscreen->IsOffscreen()) {
47908:         NS_WARNING("non-offscreen context");
47908:         return PR_FALSE;
47908:     }
47908: 
47908:     GLContextCGL *offs = static_cast<GLContextCGL*>(aOffscreen);
47908: 
47908:     if (offs->mPBuffer) {
47908:         fGenTextures(1, &mTempTextureName);
47908:         fBindTexture(LOCAL_GL_TEXTURE_2D, mTempTextureName);
47908: 
47908:         [mContext
47908:          setTextureImageToPixelBuffer:offs->mPBuffer
47908:          colorBuffer:LOCAL_GL_FRONT];
47908:     } else if (offs->mOffscreenTexture) {
47908:         if (offs->GetSharedContext() != GLContextProviderCGL::GetGlobalContext())
47908:         {
47908:             NS_WARNING("offscreen FBO context can only be bound with context sharing!");
47908:             return PR_FALSE;
47908:         }
47908: 
47908:         fBindTexture(LOCAL_GL_TEXTURE_2D, offs->mOffscreenTexture);
47908:     } else {
47908:         NS_WARNING("don't know how to bind this!");
47908:         return PR_FALSE;
47908:     }
47908: 
47908:     return PR_TRUE;
47908: }
47908: 
47908: void
47908: GLContextCGL::UnbindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     NS_ASSERTION(aOffscreen->GetContextType() == ContextTypeCGL, "wrong type");
47908: 
47908:     GLContextCGL *offs = static_cast<GLContextCGL*>(aOffscreen);
47908:     if (offs->mPBuffer) {
47908:         NS_ASSERTION(mTempTextureName, "We didn't have an offscreen texture name?");
47908:         fDeleteTextures(1, &mTempTextureName);
47908:         mTempTextureName = 0;
47908:     }
47908: }
47908: 
47908: PRBool
47908: GLContextCGL::ResizeOffscreen(const gfxIntSize& aNewSize)
47908: {
47908:     if (mPBuffer) {
47908:         NSOpenGLPixelBuffer *pb = [[NSOpenGLPixelBuffer alloc]
47908:                                    initWithTextureTarget:LOCAL_GL_TEXTURE_2D
47908:                                    textureInternalFormat:(mCreationFormat.alpha ? LOCAL_GL_RGBA : LOCAL_GL_RGB)
47908:                                    textureMaxMipMapLevel:0
47908:                                    pixelsWide:aNewSize.width
47908:                                    pixelsHigh:aNewSize.height];
47908:         if (!pb) {
47908:             return PR_FALSE;
47908:         }
47908: 
47908:         [mPBuffer release];
47908:         mPBuffer = pb;
47908: 
47908:         mOffscreenSize = aNewSize;
47908:         mOffscreenActualSize = aNewSize;
47908: 
47908:         [mContext setPixelBuffer:pb cubeMapFace:0 mipMapLevel:0
47908:          currentVirtualScreen:[mContext currentVirtualScreen]];
47908: 
47908:         MakeCurrent();
47908:         ClearSafely();
47908: 
47908:         return PR_TRUE;
47908:     }
47908: 
47908:     return ResizeOffscreenFBO(aNewSize);
47908: }
47908: 
46980: class TextureImageCGL : public BasicTextureImage
46980: {
46980:     friend already_AddRefed<TextureImage>
46980:     GLContextCGL::CreateBasicTextureImage(GLuint,
46980:                                           const nsIntSize&,
57421:                                           GLenum,
46980:                                           TextureImage::ContentType,
46980:                                           GLContext*);
59442: public:
59442:     ~TextureImageCGL()
59442:     {
59442:         if (mPixelBuffer) {
59797:             mGLContext->MakeCurrent();
59442:             mGLContext->fDeleteBuffers(1, &mPixelBuffer);
59442:         }
59442:     }
46980: 
46980: protected:
59442:     already_AddRefed<gfxASurface>
59442:     GetSurfaceForUpdate(const gfxIntSize& aSize, ImageFormat aFmt)
57351:     {
59797:         mGLContext->MakeCurrent();
60713:         if (!mGLContext->
60713:             IsExtensionSupported(GLContext::ARB_pixel_buffer_object)) 
60713:         {
59442:             return gfxPlatform::GetPlatform()->
60713:                 CreateOffscreenSurface(aSize, 
60713:                                        gfxASurface::ContentFromFormat(aFmt));
57351:         }
57351: 
59442:         if (!mPixelBuffer) {
59442:             mGLContext->fGenBuffers(1, &mPixelBuffer);
59442:         }
59442:         mGLContext->fBindBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, mPixelBuffer);
59442:         PRInt32 size = aSize.width * 4 * aSize.height;
59442: 
59442:         if (size > mPixelBufferSize) {
59442:             mGLContext->fBufferData(LOCAL_GL_PIXEL_UNPACK_BUFFER, size,
59442:                                     NULL, LOCAL_GL_STREAM_DRAW);
59442:             mPixelBufferSize = size;
59442:         }
59442:         unsigned char* data = 
60713:             (unsigned char*)mGLContext->
60713:                 fMapBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, 
60713:                            LOCAL_GL_WRITE_ONLY);
59442: 
59442:         if (!data) {
60713:             mGLContext->fBindBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, 0);
60713:             return gfxPlatform::GetPlatform()->
60713:                 CreateOffscreenSurface(aSize, 
60713:                                        gfxASurface::ContentFromFormat(aFmt));
59439:         }
59439: 
59442:         nsRefPtr<gfxQuartzSurface> surf = 
59442:             new gfxQuartzSurface(data, aSize,
59442:                                  aSize.width * 4, aFmt);
57351: 
60713:         mBoundPixelBuffer = true;
59442:         return surf.forget();
57351:     }
57351:   
59442:     bool FinishedSurfaceUpdate()
57434:     {
60713:         if (mBoundPixelBuffer) {
59797:             mGLContext->MakeCurrent();
59442:             mGLContext->fUnmapBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER);
59442:             return true;
57434:         }
59442:         return false;
57351:     }
57351: 
59442:     void FinishedSurfaceUpload()
57351:     {
60713:         if (mBoundPixelBuffer) {
59797:             mGLContext->MakeCurrent();
59442:             mGLContext->fBindBuffer(LOCAL_GL_PIXEL_UNPACK_BUFFER, 0);
60713:             mBoundPixelBuffer = false;
57351:         }
46980:     }
46980: 
46980: private:
46980:     TextureImageCGL(GLuint aTexture,
46980:                     const nsIntSize& aSize,
57421:                     GLenum aWrapMode,
46980:                     ContentType aContentType,
46980:                     GLContext* aContext)
57421:         : BasicTextureImage(aTexture, aSize, aWrapMode, aContentType, aContext)
59442:         , mPixelBuffer(0)
59442:         , mPixelBufferSize(0)
60713:         , mBoundPixelBuffer(false)
46980:     {}
46980:     
59442:     GLuint mPixelBuffer;
59442:     PRInt32 mPixelBufferSize;
60713:     bool mBoundPixelBuffer;
46980: };
46980: 
46980: already_AddRefed<TextureImage>
46980: GLContextCGL::CreateBasicTextureImage(GLuint aTexture,
46980:                                       const nsIntSize& aSize,
57421:                                       GLenum aWrapMode,
46980:                                       TextureImage::ContentType aContentType,
46980:                                       GLContext* aContext)
46980: {
57421:     nsRefPtr<TextureImageCGL> teximage
57421:         (new TextureImageCGL(aTexture, aSize, aWrapMode, aContentType, aContext));
46980:     return teximage.forget();
46980: }
46980: 
47908: static GLContextCGL *
47908: GetGlobalContextCGL()
47908: {
47908:     return static_cast<GLContextCGL*>(GLContextProviderCGL::GetGlobalContext());
47908: }
47908: 
41434: already_AddRefed<GLContext>
47907: GLContextProviderCGL::CreateForWindow(nsIWidget *aWidget)
41434: {
41434:     if (!sCGLLibrary.EnsureInitialized()) {
41434:         return nsnull;
41434:     }
41434: 
47908:     GLContextCGL *shareContext = GetGlobalContextCGL();
47908: 
41434:     NSOpenGLContext *context = [[NSOpenGLContext alloc] 
47908:                                 initWithFormat:sCGLLibrary.PixelFormat()
47908:                                 shareContext:(shareContext ? shareContext->mContext : NULL)];
47908:     if (!context) {
41434:         return nsnull;
41434:     }
41434: 
47908:     NSView *childView = (NSView *)aWidget->GetNativeData(NS_NATIVE_WIDGET);
47908:     [context setView:childView];
47908: 
54467:     // make the context transparent
54777:     nsRefPtr<GLContextCGL> glContext = new GLContextCGL(ContextFormat(ContextFormat::BasicRGB24),
47908:                                                         shareContext,
47908:                                                         context);
41434:     if (!glContext->Init()) {
41434:         return nsnull;
41434:     }    
41434: 
47908:     return glContext.forget();
41434: }
41434: 
47908: static already_AddRefed<GLContextCGL>
47908: CreateOffscreenPBufferContext(const gfxIntSize& aSize,
47908:                               const ContextFormat& aFormat,
47908:                               PRBool aShare = PR_FALSE)
41434: {
42402:     if (!sCGLLibrary.EnsureInitialized()) {
41434:         return nsnull;
41434:     }
41434: 
47908:     GLContextCGL *shareContext = aShare ? GetGlobalContextCGL() : nsnull;
47908:     if (aShare && !shareContext) {
42402:         return nsnull;
42402:     }
42402: 
47908:     nsTArray<NSOpenGLPixelFormatAttribute> attribs;
47908: 
47908: #define A_(_x)  attribs.AppendElement(NSOpenGLPixelFormatAttribute(_x))
47908:     A_(NSOpenGLPFAAccelerated);
47908:     A_(NSOpenGLPFAPixelBuffer);
47908:     A_(NSOpenGLPFAMinimumPolicy);
47908: 
47908:     A_(NSOpenGLPFAColorSize);
47908:     A_(aFormat.colorBits());
47908: 
47908:     A_(NSOpenGLPFAAlphaSize);
47908:     A_(aFormat.alpha);
47908: 
47908:     A_(NSOpenGLPFADepthSize);
47908:     A_(aFormat.depth);
47908: 
47908:     A_(NSOpenGLPFAStencilSize);
47908:     A_(aFormat.stencil);
47908: 
47908:     A_(0);
47908: #undef A_
47908: 
47908:     printf_stderr("colorbits: %d alpha: %d depth: %d stencil: %d\n", aFormat.colorBits(), aFormat.alpha, aFormat.depth, aFormat.stencil);
47908: 
47908:     NSOpenGLPixelFormat *pbFormat = [[NSOpenGLPixelFormat alloc]
47908:                                      initWithAttributes:attribs.Elements()];
47908:     if (!pbFormat) {
42402:         return nsnull;
42402:     }
42402: 
47908:     NSOpenGLPixelBuffer *pb = [[NSOpenGLPixelBuffer alloc]
47908:                                initWithTextureTarget:LOCAL_GL_TEXTURE_2D
47908:                                textureInternalFormat:(aFormat.alpha ? LOCAL_GL_RGBA : LOCAL_GL_RGB)
47908:                                textureMaxMipMapLevel:0
47908:                                pixelsWide:aSize.width
47908:                                pixelsHigh:aSize.height];
47908:     if (!pb) {
47908:         [pbFormat release];
42402:         return nsnull;
42402:     }
42402: 
47908:     NSOpenGLContext *context = [[NSOpenGLContext alloc]
47908:                                 initWithFormat:pbFormat
47908:                                 shareContext:shareContext ? shareContext->mContext : NULL];
47908:     if (!context) {
47908:         [pbFormat release];
47908:         [pb release];
42402:         return nsnull;
42402:     }
42402: 
47908:     [context
47908:      setPixelBuffer:pb
47908:      cubeMapFace:0
47908:      mipMapLevel:0
47908:      currentVirtualScreen:[context currentVirtualScreen]];
47908: 
47908:     {
47908:         GLint l;
47908:         [pbFormat getValues:&l forAttribute:NSOpenGLPFADepthSize forVirtualScreen:[context currentVirtualScreen]];
47908:         printf_stderr("*** depth: %d (req: %d)\n", l, aFormat.depth);
47908:     }
47908: 
47908:     [pbFormat release];
47908: 
47908:     nsRefPtr<GLContextCGL> glContext = new GLContextCGL(aFormat, shareContext, context, pb);
47908:     return glContext.forget();
47908: }
47908: 
47908: static already_AddRefed<GLContextCGL>
47908: CreateOffscreenFBOContext(const gfxIntSize& aSize,
47908:                           const ContextFormat& aFormat,
47908:                           PRBool aShare = PR_TRUE)
47908: {
47908:     if (!sCGLLibrary.EnsureInitialized()) {
42402:         return nsnull;
42402:     }
42402: 
47908:     GLContextCGL *shareContext = aShare ? GetGlobalContextCGL() : nsnull;
47908:     if (aShare && !shareContext) {
47908:         // if there is no share context, then we can't use FBOs.
42402:         return nsnull;
42402:     }
42402: 
47908:     NSOpenGLContext *context = [[NSOpenGLContext alloc]
47908:                                 initWithFormat:sCGLLibrary.PixelFormat()
47908:                                 shareContext:shareContext ? shareContext->mContext : NULL];
47908:     if (!context) {
47908:         return nsnull;
47908:     }
47908: 
47908:     nsRefPtr<GLContextCGL> glContext = new GLContextCGL(aFormat, shareContext, context, PR_TRUE);
47908:     return glContext.forget();
47908: }
47908: 
47908: already_AddRefed<GLContext>
47908: GLContextProviderCGL::CreateOffscreen(const gfxIntSize& aSize,
47908:                                       const ContextFormat& aFormat)
47908: {
47908:     nsRefPtr<GLContextCGL> glContext;
47908: 
47908:     glContext = CreateOffscreenPBufferContext(aSize, aFormat);
47908:     if (glContext &&
47908:         glContext->Init())
47908:     {
47908:         glContext->mOffscreenSize = aSize;
47908:         glContext->mOffscreenActualSize = aSize;
47908: 
47908:         return glContext.forget();
47908:     }
47908: 
47908:     // try a FBO as second choice
47908:     glContext = CreateOffscreenFBOContext(aSize, aFormat);
47908:     if (glContext &&
47908:         glContext->Init() &&
47908:         glContext->ResizeOffscreenFBO(aSize))
47908:     {
47908:         return glContext.forget();
47908:     }
47908: 
47908:     // everything failed
47908:     return nsnull;
42402: }
42402: 
44173: already_AddRefed<GLContext>
47907: GLContextProviderCGL::CreateForNativePixmapSurface(gfxASurface *aSurface)
44173: {
44173:     return nsnull;
44173: }
44173: 
47908: static nsRefPtr<GLContext> gGlobalContext;
47908: 
47908: GLContext *
47908: GLContextProviderCGL::GetGlobalContext()
47908: {
47908:     if (!sCGLLibrary.EnsureInitialized()) {
47908:         return nsnull;
47908:     }
47908: 
47908:     if (!gGlobalContext) {
47908:         // There are bugs in some older drivers with pbuffers less
47908:         // than 16x16 in size; also 16x16 is POT so that we can do
47908:         // a FBO with it on older video cards.  A FBO context for
47908:         // sharing is preferred since it has no associated target.
47908:         gGlobalContext = CreateOffscreenFBOContext(gfxIntSize(16, 16),
47908:                                                    ContextFormat(ContextFormat::BasicRGB24),
47908:                                                    PR_FALSE);
52381:         if (!gGlobalContext || !static_cast<GLContextCGL*>(gGlobalContext.get())->Init()) {
48176:             NS_WARNING("Couldn't init gGlobalContext.");
48176:             gGlobalContext = nsnull;
48176:             return nsnull; 
48176:         }
49071: 
49071:         gGlobalContext->SetIsGlobalSharedContext(PR_TRUE);
47908:     }
47908: 
47908:     return gGlobalContext;
47908: }
47908: 
47967: void
47967: GLContextProviderCGL::Shutdown()
47967: {
51964:   gGlobalContext = nsnull;
47967: }
47967: 
41434: } /* namespace gl */
41434: } /* namespace mozilla */
