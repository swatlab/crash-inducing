 20627: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 20627: /* vim:set ts=2 sw=2 sts=2 et cindent: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 75263: 
126025: #include "mozilla/DebugOnly.h"
126025: 
 90148: #include "MediaResource.h"
165532: #include "RtspMediaResource.h"
 75263: 
 64576: #include "mozilla/Mutex.h"
 20627: #include "nsDebug.h"
121916: #include "MediaDecoder.h"
 20627: #include "nsNetUtil.h"
 20627: #include "nsThreadUtils.h"
 20627: #include "nsIFile.h"
 20627: #include "nsIFileChannel.h"
 20627: #include "nsIHttpChannel.h"
 20627: #include "nsISeekableStream.h"
 20627: #include "nsIInputStream.h"
 20627: #include "nsIRequestObserver.h"
 20627: #include "nsIStreamListener.h"
 20627: #include "nsIScriptSecurityManager.h"
 24155: #include "nsCrossSiteListenerProxy.h"
136597: #include "mozilla/dom/HTMLMediaElement.h"
108290: #include "nsError.h"
 26836: #include "nsICachingChannel.h"
 48889: #include "nsIAsyncVerifyRedirectCallback.h"
 75263: #include "nsContentUtils.h"
121327: #include "nsHostObjectProtocolHandler.h"
129543: #include <algorithm>
 20627: 
115534: #ifdef PR_LOGGING
115534: PRLogModuleInfo* gMediaResourceLog;
172276: #define LOG(msg, ...) PR_LOG(gMediaResourceLog, PR_LOG_DEBUG, \
115534:                              (msg, ##__VA_ARGS__))
115534: // Debug logging macro with object pointer and class name.
115534: #define CMLOG(msg, ...) \
172276:         LOG("%p [ChannelMediaResource]: " msg, this, ##__VA_ARGS__)
115534: #else
172276: #define LOG(msg, ...)
115534: #define CMLOG(msg, ...)
115534: #endif
115534: 
108991: static const uint32_t HTTP_OK_CODE = 200;
108991: static const uint32_t HTTP_PARTIAL_RESPONSE_CODE = 206;
 26836: 
121915: namespace mozilla {
 27222: 
121916: ChannelMediaResource::ChannelMediaResource(MediaDecoder* aDecoder,
132924:                                            nsIChannel* aChannel,
132924:                                            nsIURI* aURI,
132924:                                            const nsACString& aContentType)
132924:   : BaseMediaResource(aDecoder, aChannel, aURI, aContentType),
 28487:     mOffset(0), mSuspendCount(0),
 79547:     mReopenOnError(false), mIgnoreClose(false),
149851:     mCacheStream(MOZ_THIS_IN_INITIALIZER_LIST()),
 90148:     mLock("ChannelMediaResource.mLock"),
108662:     mIgnoreResume(false),
115534:     mSeekingForMetadata(false),
138772:     mIsTransportSeekable(true)
 20627: {
115534: #ifdef PR_LOGGING
115534:   if (!gMediaResourceLog) {
115534:     gMediaResourceLog = PR_NewLogModule("MediaResource");
115534:   }
115534: #endif
 20627: }
 20627: 
 90148: ChannelMediaResource::~ChannelMediaResource()
 26836: {
 26836:   if (mListener) {
 26836:     // Kill its reference to us since we're going away
 26836:     mListener->Revoke();
 26836:   }
 26836: }
 20627: 
 90148: // ChannelMediaResource::Listener just observes the channel and
 90148: // forwards notifications to the ChannelMediaResource. We use multiple
 26836: // listener objects so that when we open a new stream for a seek we can
 90148: // disconnect the old listener from the ChannelMediaResource and hook up
 26836: // a new listener, so notifications from the old channel are discarded
 26836: // and don't confuse us.
 90148: NS_IMPL_ISUPPORTS4(ChannelMediaResource::Listener,
 28370:                    nsIRequestObserver, nsIStreamListener, nsIChannelEventSink,
 28370:                    nsIInterfaceRequestor)
 26706: 
 26836: nsresult
 90148: ChannelMediaResource::Listener::OnStartRequest(nsIRequest* aRequest,
 26836:                                                nsISupports* aContext)
 26836: {
 90148:   if (!mResource)
 26836:     return NS_OK;
 90148:   return mResource->OnStartRequest(aRequest);
 26836: }
 26706: 
 26836: nsresult
 90148: ChannelMediaResource::Listener::OnStopRequest(nsIRequest* aRequest,
 26836:                                               nsISupports* aContext,
 26836:                                               nsresult aStatus)
 26836: {
 90148:   if (!mResource)
 26836:     return NS_OK;
 90148:   return mResource->OnStopRequest(aRequest, aStatus);
 26836: }
 20627: 
 26836: nsresult
 90148: ChannelMediaResource::Listener::OnDataAvailable(nsIRequest* aRequest,
 26836:                                                 nsISupports* aContext,
 26836:                                                 nsIInputStream* aStream,
111234:                                                 uint64_t aOffset,
108991:                                                 uint32_t aCount)
 26836: {
 90148:   if (!mResource)
 26836:     return NS_OK;
 90148:   return mResource->OnDataAvailable(aRequest, aStream, aCount);
 26836: }
 21394: 
 26836: nsresult
 90148: ChannelMediaResource::Listener::AsyncOnChannelRedirect(nsIChannel* aOldChannel,
 28370:                                                        nsIChannel* aNewChannel,
108991:                                                        uint32_t aFlags,
 48889:                                                        nsIAsyncVerifyRedirectCallback* cb)
 28370: {
 48889:   nsresult rv = NS_OK;
 90148:   if (mResource)
 90148:     rv = mResource->OnChannelRedirect(aOldChannel, aNewChannel, aFlags);
 48889: 
 48889:   if (NS_FAILED(rv))
 48889:     return rv;
 48889: 
 48889:   cb->OnRedirectVerifyCallback(NS_OK);
 28370:   return NS_OK;
 28370: }
 28370: 
 28370: nsresult
 90148: ChannelMediaResource::Listener::GetInterface(const nsIID & aIID, void **aResult)
 28370: {
 28370:   return QueryInterface(aIID, aResult);
 28370: }
 28370: 
 28370: nsresult
 90148: ChannelMediaResource::OnStartRequest(nsIRequest* aRequest)
 26836: {
 26836:   NS_ASSERTION(mChannel.get() == aRequest, "Wrong channel!");
 26706: 
121434:   MediaDecoderOwner* owner = mDecoder->GetMediaOwner();
121434:   NS_ENSURE_TRUE(owner, NS_ERROR_FAILURE);
171973:   dom::HTMLMediaElement* element = owner->GetMediaElement();
 26836:   NS_ENSURE_TRUE(element, NS_ERROR_FAILURE);
 33364:   nsresult status;
 33364:   nsresult rv = aRequest->GetStatus(&status);
 33364:   NS_ENSURE_SUCCESS(rv, rv);
 33364: 
 26836:   if (element->ShouldCheckAllowOrigin()) {
 64070:     // If the request was cancelled by nsCORSListenerProxy due to failing
 64070:     // the CORS security check, send an error through to the media element.
 33364:     if (status == NS_ERROR_DOM_BAD_URI) {
 26836:       mDecoder->NetworkError();
 26836:       return NS_ERROR_DOM_BAD_URI;
 26836:     }
 26836:   }
 26836: 
 26836:   nsCOMPtr<nsIHttpChannel> hc = do_QueryInterface(aRequest);
 79445:   bool seekable = false;
 26836:   if (hc) {
108991:     uint32_t responseStatus = 0;
 33364:     hc->GetResponseStatus(&responseStatus);
 79445:     bool succeeded = false;
 33364:     hc->GetRequestSucceeded(&succeeded);
 33364: 
 33364:     if (!succeeded && NS_SUCCEEDED(status)) {
 33364:       // HTTP-level error (e.g. 4xx); treat this as a fatal network-level error.
 33364:       // We might get this on a seek.
 33364:       // (Note that lower-level errors indicated by NS_FAILED(status) are
 33364:       // handled in OnStopRequest.)
 33364:       // A 416 error should treated as EOF here... it's possible
 33364:       // that we don't get Content-Length, we read N bytes, then we
 33364:       // suspend and resume, the resume reopens the channel and we seek to
 33364:       // offset N, but there are no more bytes, so we get a 416
 33364:       // "Requested Range Not Satisfiable".
141505:       if (responseStatus == HTTP_REQUESTED_RANGE_NOT_SATISFIABLE_CODE) {
141505:         // OnStopRequest will not be fired, so we need to do some of its
141505:         // work here.
141505:         mCacheStream.NotifyDataEnded(status);
141505:       } else {
 33364:         mDecoder->NetworkError();
 33364:       }
 33364: 
 33364:       // This disconnects our listener so we don't get any more data. We
 33364:       // certainly don't want an error page to end up in our cache!
 33364:       CloseChannel();
 33364:       return NS_OK;
 33364:     }
 33364: 
110974:     nsAutoCString ranges;
 26836:     hc->GetResponseHeader(NS_LITERAL_CSTRING("Accept-Ranges"),
 26836:                           ranges);
 79445:     bool acceptsRanges = ranges.EqualsLiteral("bytes");
155440:     // True if this channel will not return an unbounded amount of data
155440:     bool dataIsBounded = false;
155440: 
155440:     int64_t contentLength = -1;
155440:     hc->GetContentLength(&contentLength);
155440:     if (contentLength >= 0 && responseStatus == HTTP_OK_CODE) {
155440:       // "OK" status means Content-Length is for the whole resource.
155440:       // Since that's bounded, we know we have a finite-length resource.
155440:       dataIsBounded = true;
155440:     }
 26836: 
 28487:     if (mOffset == 0) {
 37543:       // Look for duration headers from known Ogg content systems.
 37543:       // In the case of multiple options for obtaining the duration
 37543:       // the order of precedence is:
 26836:       // 1) The Media resource metadata if possible (done by the decoder itself).
 37543:       // 2) Content-Duration message header.
 37543:       // 3) X-AMZ-Meta-Content-Duration.
 37543:       // 4) X-Content-Duration.
 37543:       // 5) Perform a seek in the decoder to find the value.
110974:       nsAutoCString durationText;
106878:       nsresult ec = NS_OK;
 37543:       rv = hc->GetResponseHeader(NS_LITERAL_CSTRING("Content-Duration"), durationText);
 26836:       if (NS_FAILED(rv)) {
 26836:         rv = hc->GetResponseHeader(NS_LITERAL_CSTRING("X-AMZ-Meta-Content-Duration"), durationText);
 26836:       }
 37543:       if (NS_FAILED(rv)) {
 37543:         rv = hc->GetResponseHeader(NS_LITERAL_CSTRING("X-Content-Duration"), durationText);
 37543:       }
 26836: 
155440:       // If there is a Content-Duration header with a valid value, record
155440:       // the duration.
 26836:       if (NS_SUCCEEDED(rv)) {
 63877:         double duration = durationText.ToDouble(&ec);
 26836:         if (ec == NS_OK && duration >= 0) {
 68450:           mDecoder->SetDuration(duration);
155440:           // We know the resource must be bounded.
155440:           dataIsBounded = true;
 26836:         }
 26836:       }
 26836:     }
 26836: 
155440:     // Assume Range requests have a bounded upper limit unless the
155440:     // Content-Range header tells us otherwise.
155440:     bool boundedSeekLimit = true;
115534:     // Check response code for byte-range requests (seeking, chunk requests).
115534:     if (!mByteRange.IsNull() && (responseStatus == HTTP_PARTIAL_RESPONSE_CODE)) {
115534:       // Parse Content-Range header.
115534:       int64_t rangeStart = 0;
115534:       int64_t rangeEnd = 0;
115534:       int64_t rangeTotal = 0;
115534:       rv = ParseContentRangeHeader(hc, rangeStart, rangeEnd, rangeTotal);
115534:       if (NS_FAILED(rv)) {
115534:         // Content-Range header text should be parse-able.
115534:         CMLOG("Error processing \'Content-Range' for "
125117:               "HTTP_PARTIAL_RESPONSE_CODE: rv[%x] channel[%p] decoder[%p]",
125117:               rv, hc.get(), mDecoder);
115534:         mDecoder->NetworkError();
115534:         CloseChannel();
115534:         return NS_OK;
115534:       }
115534: 
115534:       // Give some warnings if the ranges are unexpected.
115534:       // XXX These could be error conditions.
115534:       NS_WARN_IF_FALSE(mByteRange.mStart == rangeStart,
115534:                        "response range start does not match request");
115534:       NS_WARN_IF_FALSE(mOffset == rangeStart,
115534:                        "response range start does not match current offset");
115534:       NS_WARN_IF_FALSE(mByteRange.mEnd == rangeEnd,
115534:                        "response range end does not match request");
115534:       // Notify media cache about the length and start offset of data received.
115534:       // Note: If aRangeTotal == -1, then the total bytes is unknown at this stage.
115534:       //       For now, tell the decoder that the stream is infinite.
155440:       if (rangeTotal == -1) {
155440:         boundedSeekLimit = false;
155440:       } else {
115534:         mCacheStream.NotifyDataLength(rangeTotal);
115534:       }
115534:       mCacheStream.NotifyDataStarted(rangeStart);
115534: 
115534:       mOffset = rangeStart;
130348:       // We received 'Content-Range', so the server accepts range requests.
115534:       acceptsRanges = true;
115534:     } else if (((mOffset > 0) || !mByteRange.IsNull())
115534:                && (responseStatus == HTTP_OK_CODE)) {
115534:       // If we get an OK response but we were seeking, or requesting a byte
115534:       // range, then we have to assume that seeking doesn't work. We also need
115534:       // to tell the cache that it's getting data for the start of the stream.
 26836:       mCacheStream.NotifyDataStarted(0);
 28487:       mOffset = 0;
 62891: 
 62891:       // The server claimed it supported range requests.  It lied.
 79547:       acceptsRanges = false;
 28487:     } else if (mOffset == 0 &&
 26836:                (responseStatus == HTTP_OK_CODE ||
 26836:                 responseStatus == HTTP_PARTIAL_RESPONSE_CODE)) {
155440:       if (contentLength >= 0) {
155440:         mCacheStream.NotifyDataLength(contentLength);
 26836:       }
 26836:     }
 28487:     // XXX we probably should examine the Content-Range header in case
 28487:     // the server gave us a range which is not quite what we asked for
 26836: 
 26836:     // If we get an HTTP_OK_CODE response to our byte range request,
 26836:     // and the server isn't sending Accept-Ranges:bytes then we don't
 26836:     // support seeking.
 26836:     seekable =
 26836:       responseStatus == HTTP_PARTIAL_RESPONSE_CODE || acceptsRanges;
155440:     if (seekable && boundedSeekLimit) {
155440:       // If range requests are supported, and we did not see an unbounded
155440:       // upper range limit, we assume the resource is bounded.
155440:       dataIsBounded = true;
155440:     }
 74647: 
155440:     mDecoder->SetInfinite(!dataIsBounded);
 26836:   }
124451:   mDecoder->SetTransportSeekable(seekable);
124451:   mCacheStream.SetTransportSeekable(seekable);
 26836: 
 26836:   {
 64576:     MutexAutoLock lock(mLock);
131465:     mIsTransportSeekable = seekable;
125823:     mChannelStatistics->Start();
 26836:   }
 26836: 
 79547:   mReopenOnError = false;
108662:   // If we are seeking to get metadata, because we are playing an OGG file,
108662:   // ignore if the channel gets closed without us suspending it explicitly. We
108662:   // don't want to tell the element that the download has finished whereas we
108662:   // just happended to have reached the end of the media while seeking.
108662:   mIgnoreClose = mSeekingForMetadata;
108662: 
 26836:   if (mSuspendCount > 0) {
 26836:     // Re-suspend the channel if it needs to be suspended
 67657:     // No need to call PossiblySuspend here since the channel is
 91073:     // definitely in the right state for us in OnStartRequest.
 26836:     mChannel->Suspend();
 79547:     mIgnoreResume = false;
 26836:   }
 26836: 
 26836:   // Fires an initial progress event and sets up the stall counter so stall events
 26836:   // fire if no download occurs within the required time frame.
 79547:   mDecoder->Progress(false);
 26836: 
 26836:   return NS_OK;
 26836: }
 26836: 
131465: bool
131465: ChannelMediaResource::IsTransportSeekable()
131465: {
131465:   MutexAutoLock lock(mLock);
131465:   return mIsTransportSeekable;
131465: }
131465: 
 26836: nsresult
115534: ChannelMediaResource::ParseContentRangeHeader(nsIHttpChannel * aHttpChan,
115534:                                               int64_t& aRangeStart,
115534:                                               int64_t& aRangeEnd,
115534:                                               int64_t& aRangeTotal)
115534: {
115534:   NS_ENSURE_ARG(aHttpChan);
115534: 
115534:   nsAutoCString rangeStr;
115534:   nsresult rv = aHttpChan->GetResponseHeader(NS_LITERAL_CSTRING("Content-Range"),
115534:                                              rangeStr);
115534:   NS_ENSURE_SUCCESS(rv, rv);
115534:   NS_ENSURE_FALSE(rangeStr.IsEmpty(), NS_ERROR_ILLEGAL_VALUE);
115534: 
115534:   // Parse the range header: e.g. Content-Range: bytes 7000-7999/8000.
115534:   int32_t spacePos = rangeStr.Find(NS_LITERAL_CSTRING(" "));
115534:   int32_t dashPos = rangeStr.Find(NS_LITERAL_CSTRING("-"), true, spacePos);
115534:   int32_t slashPos = rangeStr.Find(NS_LITERAL_CSTRING("/"), true, dashPos);
115534: 
115534:   nsAutoCString aRangeStartText;
115534:   rangeStr.Mid(aRangeStartText, spacePos+1, dashPos-(spacePos+1));
115534:   aRangeStart = aRangeStartText.ToInteger64(&rv);
115534:   NS_ENSURE_SUCCESS(rv, rv);
115534:   NS_ENSURE_TRUE(0 <= aRangeStart, NS_ERROR_ILLEGAL_VALUE);
115534: 
115534:   nsAutoCString aRangeEndText;
115534:   rangeStr.Mid(aRangeEndText, dashPos+1, slashPos-(dashPos+1));
115534:   aRangeEnd = aRangeEndText.ToInteger64(&rv);
115534:   NS_ENSURE_SUCCESS(rv, rv);
115534:   NS_ENSURE_TRUE(aRangeStart < aRangeEnd, NS_ERROR_ILLEGAL_VALUE);
115534: 
115534:   nsAutoCString aRangeTotalText;
115534:   rangeStr.Right(aRangeTotalText, rangeStr.Length()-(slashPos+1));
115534:   if (aRangeTotalText[0] == '*') {
115534:     aRangeTotal = -1;
115534:   } else {
115534:     aRangeTotal = aRangeTotalText.ToInteger64(&rv);
115534:     NS_ENSURE_TRUE(aRangeEnd < aRangeTotal, NS_ERROR_ILLEGAL_VALUE);
115534:     NS_ENSURE_SUCCESS(rv, rv);
115534:   }
115534: 
125117:   CMLOG("Received bytes [%lld] to [%lld] of [%lld] for decoder[%p]",
125117:         aRangeStart, aRangeEnd, aRangeTotal, mDecoder);
115534: 
115534:   return NS_OK;
115534: }
115534: 
115534: nsresult
 90148: ChannelMediaResource::OnStopRequest(nsIRequest* aRequest, nsresult aStatus)
 26836: {
 26836:   NS_ASSERTION(mChannel.get() == aRequest, "Wrong channel!");
 28487:   NS_ASSERTION(mSuspendCount == 0,
 28487:                "How can OnStopRequest fire while we're suspended?");
 26836: 
 26836:   {
 64576:     MutexAutoLock lock(mLock);
125823:     mChannelStatistics->Stop();
 26836:   }
 26836: 
 33859:   // Note that aStatus might have succeeded --- this might be a normal close
 33859:   // --- even in situations where the server cut us off because we were
 33859:   // suspended. So we need to "reopen on error" in that case too. The only
 33859:   // cases where we don't need to reopen are when *we* closed the stream.
 33859:   // But don't reopen if we need to seek and we don't think we can... that would
 33859:   // cause us to just re-read the stream, which would be really bad.
 33859:   if (mReopenOnError &&
 33859:       aStatus != NS_ERROR_PARSED_DATA_CACHED && aStatus != NS_BINDING_ABORTED &&
124451:       (mOffset == 0 || mCacheStream.IsTransportSeekable())) {
 33859:     // If the stream did close normally, then if the server is seekable we'll
 33859:     // just seek to the end of the resource and get an HTTP 416 error because
 33859:     // there's nothing there, so this isn't bad.
 79547:     nsresult rv = CacheClientSeek(mOffset, false);
 28487:     if (NS_SUCCEEDED(rv))
 28487:       return rv;
 28487:     // If the reopen/reseek fails, just fall through and treat this
 28487:     // error as fatal.
 28487:   }
 28487: 
 28487:   if (!mIgnoreClose) {
 26836:     mCacheStream.NotifyDataEnded(aStatus);
 62568: 
 62568:     // Move this request back into the foreground.  This is necessary for
 62568:     // requests owned by video documents to ensure the load group fires
 62568:     // OnStopRequest when restoring from session history.
 62568:     nsLoadFlags loadFlags;
 72147:     DebugOnly<nsresult> rv = mChannel->GetLoadFlags(&loadFlags);
 62568:     NS_ASSERTION(NS_SUCCEEDED(rv), "GetLoadFlags() failed!");
 62568: 
 91073:     if (loadFlags & nsIRequest::LOAD_BACKGROUND) {
 91073:       ModifyLoadFlags(loadFlags & ~nsIRequest::LOAD_BACKGROUND);
 62568:     }
 28487:   }
 28487: 
 26836:   return NS_OK;
 26836: }
 26836: 
 28370: nsresult
 90148: ChannelMediaResource::OnChannelRedirect(nsIChannel* aOld, nsIChannel* aNew,
108991:                                         uint32_t aFlags)
 28370: {
 28370:   mChannel = aNew;
 28370:   SetupChannelHeaders();
 28370:   return NS_OK;
 28370: }
 28370: 
 28370: struct CopySegmentClosure {
 28370:   nsCOMPtr<nsIPrincipal> mPrincipal;
 90148:   ChannelMediaResource*  mResource;
 28370: };
 28370: 
 26836: NS_METHOD
 90148: ChannelMediaResource::CopySegmentToCache(nsIInputStream *aInStream,
 26836:                                          void *aClosure,
 26836:                                          const char *aFromSegment,
108991:                                          uint32_t aToOffset,
108991:                                          uint32_t aCount,
108991:                                          uint32_t *aWriteCount)
 26836: {
 28370:   CopySegmentClosure* closure = static_cast<CopySegmentClosure*>(aClosure);
 53765: 
 90148:   closure->mResource->mDecoder->NotifyDataArrived(aFromSegment, aCount, closure->mResource->mOffset);
 53765: 
125117:   // Keep track of where we're up to.
172276:   LOG("%p [ChannelMediaResource]: CopySegmentToCache at mOffset [%lld] add "
125117:       "[%d] bytes for decoder[%p]",
125117:       closure->mResource, closure->mResource->mOffset, aCount,
125117:       closure->mResource->mDecoder);
 90148:   closure->mResource->mOffset += aCount;
125117: 
 90148:   closure->mResource->mCacheStream.NotifyDataReceived(aCount, aFromSegment,
 28370:                                                       closure->mPrincipal);
 26836:   *aWriteCount = aCount;
 26836:   return NS_OK;
 26836: }
 26836: 
 26836: nsresult
 90148: ChannelMediaResource::OnDataAvailable(nsIRequest* aRequest,
 26836:                                       nsIInputStream* aStream,
108991:                                       uint32_t aCount)
 26836: {
 26836:   NS_ASSERTION(mChannel.get() == aRequest, "Wrong channel!");
 26836: 
 26836:   {
 64576:     MutexAutoLock lock(mLock);
125823:     mChannelStatistics->AddBytes(aCount);
 26836:   }
 26836: 
 28370:   CopySegmentClosure closure;
 28370:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 28370:   if (secMan && mChannel) {
 28370:     secMan->GetChannelPrincipal(mChannel, getter_AddRefs(closure.mPrincipal));
 28370:   }
 90148:   closure.mResource = this;
 28370: 
108991:   uint32_t count = aCount;
 26836:   while (count > 0) {
108991:     uint32_t read;
 28370:     nsresult rv = aStream->ReadSegments(CopySegmentToCache, &closure, count,
 26836:                                         &read);
 26836:     if (NS_FAILED(rv))
 26836:       return rv;
 26836:     NS_ASSERTION(read > 0, "Read 0 bytes while data was available?");
 26836:     count -= read;
 26836:   }
 26836: 
 26836:   return NS_OK;
 26836: }
 20627: 
 90148: nsresult ChannelMediaResource::Open(nsIStreamListener **aStreamListener)
 20627: {
 26836:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
125823:   if (!mChannelStatistics) {
125823:     mChannelStatistics = new MediaChannelStatistics();
125823:   }
125823: 
 26836:   nsresult rv = mCacheStream.Init();
 26836:   if (NS_FAILED(rv))
 26836:     return rv;
 28487:   NS_ASSERTION(mOffset == 0, "Who set mOffset already?");
 34505: 
 34505:   if (!mChannel) {
 34505:     // When we're a clone, the decoder might ask us to Open even though
 34505:     // we haven't established an mChannel (because we might not need one)
 34505:     NS_ASSERTION(!aStreamListener,
 34505:                  "Should have already been given a channel if we're to return a stream listener");
 34505:     return NS_OK;
 34505:   }
 34505: 
 28487:   return OpenChannel(aStreamListener);
 26706: }
 26706: 
 90148: nsresult ChannelMediaResource::OpenChannel(nsIStreamListener** aStreamListener)
 26706: {
 26706:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26706:   NS_ENSURE_TRUE(mChannel, NS_ERROR_NULL_POINTER);
 26836:   NS_ASSERTION(!mListener, "Listener should have been removed by now");
 26706: 
 21079:   if (aStreamListener) {
106838:     *aStreamListener = nullptr;
 21079:   }
 20627: 
144414:   if (mByteRange.IsNull()) {
144414:     // We're not making a byte range request, so set the content length,
144414:     // if it's available as an HTTP header. This ensures that MediaResource
144414:     // wrapping objects for platform libraries that expect to know
144414:     // the length of a resource can get it before OnStartRequest() fires.
144414:     nsCOMPtr<nsIHttpChannel> hc = do_QueryInterface(mChannel);
144414:     if (hc) {
144414:       int64_t cl = -1;
144414:       if (NS_SUCCEEDED(hc->GetContentLength(&cl)) && cl != -1) {
144414:         mCacheStream.NotifyDataLength(cl);
144414:       }
144414:     }
144414:   }
144414: 
 26836:   mListener = new Listener(this);
 26812:   NS_ENSURE_TRUE(mListener, NS_ERROR_OUT_OF_MEMORY);
 26796: 
 21079:   if (aStreamListener) {
 21079:     *aStreamListener = mListener;
 26706:     NS_ADDREF(*aStreamListener);
 21079:   } else {
 28370:     mChannel->SetNotificationCallbacks(mListener.get());
 28370: 
 26836:     nsCOMPtr<nsIStreamListener> listener = mListener.get();
 26836: 
 24155:     // Ensure that if we're loading cross domain, that the server is sending
 24155:     // an authorizing Access-Control header.
121434:     MediaDecoderOwner* owner = mDecoder->GetMediaOwner();
121434:     NS_ENSURE_TRUE(owner, NS_ERROR_FAILURE);
171973:     dom::HTMLMediaElement* element = owner->GetMediaElement();
 24155:     NS_ENSURE_TRUE(element, NS_ERROR_FAILURE);
 24155:     if (element->ShouldCheckAllowOrigin()) {
115775:       nsRefPtr<nsCORSListenerProxy> crossSiteListener =
 64070:         new nsCORSListenerProxy(mListener,
 24155:                                 element->NodePrincipal(),
114321:                                 false);
114321:       nsresult rv = crossSiteListener->Init(mChannel);
 36217:       listener = crossSiteListener;
 36217:       NS_ENSURE_TRUE(crossSiteListener, NS_ERROR_OUT_OF_MEMORY);
 24155:       NS_ENSURE_SUCCESS(rv, rv);
 24188:     } else {
 26836:       nsresult rv = nsContentUtils::GetSecurityManager()->
 24188:         CheckLoadURIWithPrincipal(element->NodePrincipal(),
 24188:                                   mURI,
 24188:                                   nsIScriptSecurityManager::STANDARD);
 24188:       NS_ENSURE_SUCCESS(rv, rv);
 26836:     }
 26812: 
 28370:     SetupChannelHeaders();
 26706: 
106838:     nsresult rv = mChannel->AsyncOpen(listener, nullptr);
 20627:     NS_ENSURE_SUCCESS(rv, rv);
 99848:     // Tell the media element that we are fetching data from a channel.
 99848:     element->DownloadResumed(true);
 21079:   }
 20627: 
 20627:   return NS_OK;
 20627: }
 20627: 
 90148: void ChannelMediaResource::SetupChannelHeaders()
 28370: {
 28370:   // Always use a byte range request even if we're reading from the start
 28370:   // of the resource.
 28370:   // This enables us to detect if the stream supports byte range
 28370:   // requests, and therefore seeking, early.
 28370:   nsCOMPtr<nsIHttpChannel> hc = do_QueryInterface(mChannel);
 28370:   if (hc) {
115534:     // Use |mByteRange| for a specific chunk, or |mOffset| if seeking in a
115534:     // complete file download.
110974:     nsAutoCString rangeString("bytes=");
115534:     if (!mByteRange.IsNull()) {
115534:       rangeString.AppendInt(mByteRange.mStart);
115534:       mOffset = mByteRange.mStart;
115534:     } else {
 28487:       rangeString.AppendInt(mOffset);
115534:     }
 28370:     rangeString.Append("-");
115534:     if (!mByteRange.IsNull()) {
115534:       rangeString.AppendInt(mByteRange.mEnd);
115534:     }
 79547:     hc->SetRequestHeader(NS_LITERAL_CSTRING("Range"), rangeString, false);
 48349: 
 48349:     // Send Accept header for video and audio types only (Bug 489071)
 48349:     NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
121434:     MediaDecoderOwner* owner = mDecoder->GetMediaOwner();
121434:     if (!owner) {
121434:       return;
121434:     }
171973:     dom::HTMLMediaElement* element = owner->GetMediaElement();
 48349:     if (!element) {
 48349:       return;
 48349:     }
 54200:     element->SetRequestHeaders(hc);
 28370:   } else {
 28487:     NS_ASSERTION(mOffset == 0, "Don't know how to seek on this channel type");
 28370:   }
 28370: }
 28370: 
 90148: nsresult ChannelMediaResource::Close()
 20627: {
 26706:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
 26836:   mCacheStream.Close();
 26836:   CloseChannel();
 26836:   return NS_OK;
 26836: }
 26836: 
 90148: already_AddRefed<nsIPrincipal> ChannelMediaResource::GetCurrentPrincipal()
 28370: {
 28370:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 28370: 
 28370:   nsCOMPtr<nsIPrincipal> principal = mCacheStream.GetCurrentPrincipal();
 28370:   return principal.forget();
 28370: }
 28370: 
 93550: bool ChannelMediaResource::CanClone()
 93550: {
 93550:   return mCacheStream.IsAvailableForSharing();
 93550: }
 93550: 
142463: already_AddRefed<MediaResource> ChannelMediaResource::CloneData(MediaDecoder* aDecoder)
 32901: {
 32901:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 93550:   NS_ASSERTION(mCacheStream.IsAvailableForSharing(), "Stream can't be cloned");
 32901: 
142463:   nsRefPtr<ChannelMediaResource> resource =
142463:     new ChannelMediaResource(aDecoder,
132924:                              nullptr,
132924:                              mURI,
132924:                              GetContentType());
 90148:   if (resource) {
 34505:     // Initially the clone is treated as suspended by the cache, because
 34505:     // we don't have a channel. If the cache needs to read data from the clone
 34505:     // it will call CacheClientResume (or CacheClientSeek with aResume true)
 34505:     // which will recreate the channel. This way, if all of the media data
141506:     // is already in the cache we don't create an unnecessary HTTP channel
 34505:     // and perform a useless HTTP transaction.
 90148:     resource->mSuspendCount = 1;
 90148:     resource->mCacheStream.InitAsClone(&mCacheStream);
130348:     resource->mChannelStatistics = new MediaChannelStatistics(mChannelStatistics);
125823:     resource->mChannelStatistics->Stop();
 32901:   }
142463:   return resource.forget();
 32901: }
 32901: 
 90148: void ChannelMediaResource::CloseChannel()
 26836: {
 26836:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
 26836:   {
 64576:     MutexAutoLock lock(mLock);
125823:     mChannelStatistics->Stop();
 26836:   }
 26836: 
 26836:   if (mListener) {
 26836:     mListener->Revoke();
106838:     mListener = nullptr;
 26836:   }
 26836: 
 20627:   if (mChannel) {
 26836:     if (mSuspendCount > 0) {
 26836:       // Resume the channel before we cancel it
 67657:       PossiblyResume();
 26836:     }
 26836:     // The status we use here won't be passed to the decoder, since
 26836:     // we've already revoked the listener. It can however be passed
124284:     // to nsDocumentViewer::LoadComplete if our channel is the one
 26836:     // that kicked off creation of a video document. We don't want that
 26836:     // document load to think there was an error.
 26836:     // NS_ERROR_PARSED_DATA_CACHED is the best thing we have for that
 26836:     // at the moment.
 26836:     mChannel->Cancel(NS_ERROR_PARSED_DATA_CACHED);
106838:     mChannel = nullptr;
 21756:   }
 20627: }
 20627: 
 90148: nsresult ChannelMediaResource::ReadFromCache(char* aBuffer,
108991:                                              int64_t aOffset,
108991:                                              uint32_t aCount)
 48904: {
 48904:   return mCacheStream.ReadFromCache(aBuffer, aOffset, aCount);
 48904: }
 48904: 
 90148: nsresult ChannelMediaResource::Read(char* aBuffer,
108991:                                     uint32_t aCount,
108991:                                     uint32_t* aBytes)
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 21394: 
162443:   int64_t offset = mCacheStream.Tell();
162443:   nsresult rv = mCacheStream.Read(aBuffer, aCount, aBytes);
162443:   if (NS_SUCCEEDED(rv)) {
162443:     DispatchBytesConsumed(*aBytes, offset);
162443:   }
162443:   return rv;
 20627: }
 20627: 
151965: nsresult ChannelMediaResource::ReadAt(int64_t aOffset,
151965:                                       char* aBuffer,
151965:                                       uint32_t aCount,
151965:                                       uint32_t* aBytes)
151965: {
151965:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
151965: 
162443:   nsresult rv = mCacheStream.ReadAt(aOffset, aBuffer, aCount, aBytes);
162443:   if (NS_SUCCEEDED(rv)) {
162443:     DispatchBytesConsumed(*aBytes, aOffset);
162443:   }
162443:   return rv;
151965: }
151965: 
108991: nsresult ChannelMediaResource::Seek(int32_t aWhence, int64_t aOffset)
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 26836: 
125117:   CMLOG("Seek requested for aOffset [%lld] for decoder [%p]",
125117:         aOffset, mDecoder);
 26836:   return mCacheStream.Seek(aWhence, aOffset);
 20627: }
 20627: 
108662: void ChannelMediaResource::StartSeekingForMetadata()
108662: {
108662:   mSeekingForMetadata = true;
108662: }
108662: 
108662: void ChannelMediaResource::EndSeekingForMetadata()
108662: {
108662:   mSeekingForMetadata = false;
108662: }
108662: 
108991: int64_t ChannelMediaResource::Tell()
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 20627: 
 26836:   return mCacheStream.Tell();
 20627: }
 20627: 
 90148: nsresult ChannelMediaResource::GetCachedRanges(nsTArray<MediaByteRange>& aRanges)
 63626: {
 63626:   return mCacheStream.GetCachedRanges(aRanges);
 63626: }
 63626: 
 90148: void ChannelMediaResource::Suspend(bool aCloseImmediately)
 24020: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 26836: 
121434:   MediaDecoderOwner* owner = mDecoder->GetMediaOwner();
121434:   if (!owner) {
121434:     // Shutting down; do nothing.
121434:     return;
121434:   }
171973:   dom::HTMLMediaElement* element = owner->GetMediaElement();
 28488:   if (!element) {
 28488:     // Shutting down; do nothing.
 28488:     return;
 28488:   }
 28488: 
 28487:   if (mChannel) {
124451:     if (aCloseImmediately && mCacheStream.IsTransportSeekable()) {
 28487:       // Kill off our channel right now, but don't tell anyone about it.
 79547:       mIgnoreClose = true;
 28487:       CloseChannel();
 28488:       element->DownloadSuspended();
 28487:     } else if (mSuspendCount == 0) {
 26836:       {
 64576:         MutexAutoLock lock(mLock);
125823:         mChannelStatistics->Stop();
 26836:       }
 67657:       PossiblySuspend();
 28488:       element->DownloadSuspended();
 24020:     }
 28487:   }
 28487: 
 26836:   ++mSuspendCount;
 26836: }
 24020: 
 90148: void ChannelMediaResource::Resume()
 24020: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 28487:   NS_ASSERTION(mSuspendCount > 0, "Too many resumes!");
 26836: 
121434:   MediaDecoderOwner* owner = mDecoder->GetMediaOwner();
121434:   if (!owner) {
121434:     // Shutting down; do nothing.
121434:     return;
121434:   }
171973:   dom::HTMLMediaElement* element = owner->GetMediaElement();
 28488:   if (!element) {
 28488:     // Shutting down; do nothing.
 28488:     return;
 28488:   }
 28488: 
 34505:   NS_ASSERTION(mSuspendCount > 0, "Resume without previous Suspend!");
 26836:   --mSuspendCount;
 28487:   if (mSuspendCount == 0) {
 28487:     if (mChannel) {
 28487:       // Just wake up our existing channel
 26836:       {
 64576:         MutexAutoLock lock(mLock);
125823:         mChannelStatistics->Start();
 26836:       }
 28487:       // if an error occurs after Resume, assume it's because the server
 28487:       // timed out the connection and we should reopen it.
 79547:       mReopenOnError = true;
 67657:       PossiblyResume();
 28488:       element->DownloadResumed();
 28487:     } else {
108991:       int64_t totalLength = mCacheStream.GetLength();
 32909:       // If mOffset is at the end of the stream, then we shouldn't try to
 32909:       // seek to it. The seek will fail and be wasted anyway. We can leave
 32909:       // the channel dead; if the media cache wants to read some other data
 32909:       // in the future, it will call CacheClientSeek itself which will reopen the
 32909:       // channel.
 32909:       if (totalLength < 0 || mOffset < totalLength) {
 32909:         // There is (or may be) data to read at mOffset, so start reading it.
 32909:         // Need to recreate the channel.
 79547:         CacheClientSeek(mOffset, false);
 32909:       }
 28488:       element->DownloadResumed();
 28487:     }
 26836:   }
 26836: }
 26836: 
 26836: nsresult
 90148: ChannelMediaResource::RecreateChannel()
 26836: {
 27217:   nsLoadFlags loadFlags =
 27217:     nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY |
 27217:     (mLoadInBackground ? nsIRequest::LOAD_BACKGROUND : 0);
 27217: 
121434:   MediaDecoderOwner* owner = mDecoder->GetMediaOwner();
121434:   if (!owner) {
121434:     // The decoder is being shut down, so don't bother opening a new channel
121434:     return NS_OK;
121434:   }
171973:   dom::HTMLMediaElement* element = owner->GetMediaElement();
 27217:   if (!element) {
 26836:     // The decoder is being shut down, so don't bother opening a new channel
 26836:     return NS_OK;
 26836:   }
 27217:   nsCOMPtr<nsILoadGroup> loadGroup = element->GetDocumentLoadGroup();
 27217:   NS_ENSURE_TRUE(loadGroup, NS_ERROR_NULL_POINTER);
 26836: 
111227:   nsresult rv = NS_NewChannel(getter_AddRefs(mChannel),
 32901:                               mURI,
111223:                               nullptr,
 32901:                               loadGroup,
111223:                               nullptr,
 32901:                               loadFlags);
111227: 
111227:   // We have cached the Content-Type, which should not change. Give a hint to
111227:   // the channel to avoid a sniffing failure, which would be expected because we
111227:   // are probably seeking in the middle of the bitstream, and sniffing relies
111227:   // on the presence of a magic number at the beginning of the stream.
132924:   NS_ASSERTION(!GetContentType().IsEmpty(),
111227:       "When recreating a channel, we should know the Content-Type.");
132924:   mChannel->SetContentType(GetContentType());
111227: 
111227:   return rv;
 32901: }
 32901: 
 32905: void
 90148: ChannelMediaResource::DoNotifyDataReceived()
 32905: {
 32905:   mDataReceivedEvent.Revoke();
 32905:   mDecoder->NotifyBytesDownloaded();
 32905: }
 32905: 
 32905: void
 90148: ChannelMediaResource::CacheClientNotifyDataReceived()
 32905: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 34206:   // NOTE: this can be called with the media cache lock held, so don't
 34206:   // block or do anything which might try to acquire a lock!
 32905: 
 32905:   if (mDataReceivedEvent.IsPending())
 32905:     return;
 32905: 
 32905:   mDataReceivedEvent =
 90148:     NS_NewNonOwningRunnableMethod(this, &ChannelMediaResource::DoNotifyDataReceived);
 32905:   NS_DispatchToMainThread(mDataReceivedEvent.get(), NS_DISPATCH_NORMAL);
 32905: }
 32905: 
 32905: class DataEnded : public nsRunnable {
 32905: public:
121916:   DataEnded(MediaDecoder* aDecoder, nsresult aStatus) :
 32905:     mDecoder(aDecoder), mStatus(aStatus) {}
 32905:   NS_IMETHOD Run() {
 32905:     mDecoder->NotifyDownloadEnded(mStatus);
 32905:     return NS_OK;
 32905:   }
 32905: private:
121916:   nsRefPtr<MediaDecoder> mDecoder;
 32905:   nsresult                 mStatus;
 32905: };
 32905: 
 32905: void
 90148: ChannelMediaResource::CacheClientNotifyDataEnded(nsresult aStatus)
 32905: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 34206:   // NOTE: this can be called with the media cache lock held, so don't
 34206:   // block or do anything which might try to acquire a lock!
 32905: 
 32905:   nsCOMPtr<nsIRunnable> event = new DataEnded(mDecoder, aStatus);
 32905:   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
 32905: }
 32905: 
 97204: void
 97204: ChannelMediaResource::CacheClientNotifyPrincipalChanged()
 97204: {
 97204:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 97204: 
 97204:   mDecoder->NotifyPrincipalChanged();
 97204: }
 97204: 
 32901: nsresult
108991: ChannelMediaResource::CacheClientSeek(int64_t aOffset, bool aResume)
 32901: {
 34206:   NS_ASSERTION(NS_IsMainThread(), "Don't call on non-main thread");
 32901: 
125117:   CMLOG("CacheClientSeek requested for aOffset [%lld] for decoder [%p]",
125117:         aOffset, mDecoder);
125117: 
138772:   CloseChannel();
 32901: 
 28487:   if (aResume) {
 28487:     NS_ASSERTION(mSuspendCount > 0, "Too many resumes!");
 28487:     // No need to mess with the channel, since we're making a new one
 28487:     --mSuspendCount;
 28487:   }
 28487: 
106506:   mOffset = aOffset;
106506: 
106506:   if (mSuspendCount > 0) {
106506:     // Close the existing channel to force the channel to be recreated at
106506:     // the correct offset upon resume.
106506:     if (mChannel) {
106506:       mIgnoreClose = true;
106506:       CloseChannel();
106506:     }
106506:     return NS_OK;
106506:   }
106506: 
 32901:   nsresult rv = RecreateChannel();
 26836:   if (NS_FAILED(rv))
 26836:     return rv;
 32901: 
106838:   return OpenChannel(nullptr);
 26836: }
 26836: 
125117: void
125117: ChannelMediaResource::FlushCache()
125117: {
125117:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
125117: 
125117:   // Ensure that data in the cache's partial block is written to disk.
125117:   mCacheStream.FlushPartialBlock();
125117: }
125117: 
125117: void
125117: ChannelMediaResource::NotifyLastByteRange()
125117: {
125117:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
125117: 
125117:   // Tell media cache that the last data has been downloaded.
125117:   // Note: subsequent seeks will require re-opening the channel etc.
125117:   mCacheStream.NotifyDataEnded(NS_OK);
125117: 
125117: }
125117: 
 26836: nsresult
 90148: ChannelMediaResource::CacheClientSuspend()
 26836: {
 79547:   Suspend(false);
 26836: 
 34206:   mDecoder->NotifySuspendedStatusChanged();
 26836:   return NS_OK;
 26836: }
 26836: 
 26836: nsresult
 90148: ChannelMediaResource::CacheClientResume()
 26836: {
 26836:   Resume();
 26836: 
 34206:   mDecoder->NotifySuspendedStatusChanged();
 26836:   return NS_OK;
 26836: }
 26836: 
108991: int64_t
108991: ChannelMediaResource::GetNextCachedData(int64_t aOffset)
 28471: {
 28471:   return mCacheStream.GetNextCachedData(aOffset);
 28471: }
 28471: 
108991: int64_t
108991: ChannelMediaResource::GetCachedDataEnd(int64_t aOffset)
 26836: {
 26836:   return mCacheStream.GetCachedDataEnd(aOffset);
 26836: }
 26836: 
 79445: bool
108991: ChannelMediaResource::IsDataCachedToEndOfResource(int64_t aOffset)
 26836: {
 26836:   return mCacheStream.IsDataCachedToEndOfStream(aOffset);
 26836: }
 26836: 
 82990: void
 90148: ChannelMediaResource::EnsureCacheUpToDate()
 82990: {
 82990:   mCacheStream.EnsureCacheUpdate();
 82990: }
 82990: 
 79445: bool
142463: ChannelMediaResource::IsSuspendedByCache()
 26836: {
142463:   return mCacheStream.AreAllStreamsForResourceSuspended();
 26836: }
 26836: 
 79445: bool
 90148: ChannelMediaResource::IsSuspended()
 50369: {
 64576:   MutexAutoLock lock(mLock);
 50369:   return mSuspendCount > 0;
 50369: }
 50369: 
 26836: void
121916: ChannelMediaResource::SetReadMode(MediaCacheStream::ReadMode aMode)
 26836: {
 26836:   mCacheStream.SetReadMode(aMode);
 26836: }
 26836: 
 26836: void
108991: ChannelMediaResource::SetPlaybackRate(uint32_t aBytesPerSecond)
 26836: {
 26836:   mCacheStream.SetPlaybackRate(aBytesPerSecond);
 26836: }
 26836: 
 26836: void
 90148: ChannelMediaResource::Pin()
 26836: {
 26836:   mCacheStream.Pin();
 26836: }
 26836: 
 26836: void
 90148: ChannelMediaResource::Unpin()
 26836: {
 26836:   mCacheStream.Unpin();
 26836: }
 26836: 
 26836: double
 90148: ChannelMediaResource::GetDownloadRate(bool* aIsReliable)
 26836: {
 64576:   MutexAutoLock lock(mLock);
125823:   return mChannelStatistics->GetRate(aIsReliable);
 26836: }
 26836: 
108991: int64_t
 90148: ChannelMediaResource::GetLength()
 26836: {
 26836:   return mCacheStream.GetLength();
 24020: }
 24020: 
 67657: void
 90148: ChannelMediaResource::PossiblySuspend()
 67657: {
 79445:   bool isPending = false;
 67657:   nsresult rv = mChannel->IsPending(&isPending);
 67657:   if (NS_SUCCEEDED(rv) && isPending) {
 67657:     mChannel->Suspend();
 79547:     mIgnoreResume = false;
 67657:   } else {
 79547:     mIgnoreResume = true;
 67657:   }
 67657: }
 67657: 
 67657: void
 90148: ChannelMediaResource::PossiblyResume()
 67657: {
 67657:   if (!mIgnoreResume) {
 67657:     mChannel->Resume();
 67657:   } else {
 79547:     mIgnoreResume = false;
 67657:   }
 67657: }
 67657: 
123588: class FileMediaResource : public BaseMediaResource
 20627: {
 20627: public:
132924:   FileMediaResource(MediaDecoder* aDecoder,
132924:                     nsIChannel* aChannel,
132924:                     nsIURI* aURI,
132924:                     const nsACString& aContentType) :
132924:     BaseMediaResource(aDecoder, aChannel, aURI, aContentType),
111035:     mSize(-1),
110604:     mLock("FileMediaResource.mLock"),
110604:     mSizeInitialized(false)
 20627:   {
 20627:   }
 90148:   ~FileMediaResource()
 26836:   {
 26836:   }
 20627: 
 26836:   // Main thread
 21079:   virtual nsresult Open(nsIStreamListener** aStreamListener);
 20627:   virtual nsresult Close();
 79445:   virtual void     Suspend(bool aCloseImmediately) {}
 26836:   virtual void     Resume() {}
 28370:   virtual already_AddRefed<nsIPrincipal> GetCurrentPrincipal();
 93550:   virtual bool     CanClone();
142463:   virtual already_AddRefed<MediaResource> CloneData(MediaDecoder* aDecoder);
108991:   virtual nsresult ReadFromCache(char* aBuffer, int64_t aOffset, uint32_t aCount);
 26836: 
 26836:   // These methods are called off the main thread.
 26836: 
 26836:   // Other thread
121916:   virtual void     SetReadMode(MediaCacheStream::ReadMode aMode) {}
108991:   virtual void     SetPlaybackRate(uint32_t aBytesPerSecond) {}
108991:   virtual nsresult Read(char* aBuffer, uint32_t aCount, uint32_t* aBytes);
151965:   virtual nsresult ReadAt(int64_t aOffset, char* aBuffer,
151965:                           uint32_t aCount, uint32_t* aBytes);
108991:   virtual nsresult Seek(int32_t aWhence, int64_t aOffset);
108662:   virtual void     StartSeekingForMetadata() {};
108662:   virtual void     EndSeekingForMetadata() {};
108991:   virtual int64_t  Tell();
 26836: 
 26836:   // Any thread
 26836:   virtual void    Pin() {}
 26836:   virtual void    Unpin() {}
 79445:   virtual double  GetDownloadRate(bool* aIsReliable)
 26836:   {
 26836:     // The data's all already here
 79547:     *aIsReliable = true;
 26836:     return 100*1024*1024; // arbitray, use 100MB/s
 26836:   }
110604:   virtual int64_t GetLength() {
110604:     MutexAutoLock lock(mLock);
128745: 
111035:     EnsureSizeInitialized();
111035:     return mSizeInitialized ? mSize : 0;
110604:   }
108991:   virtual int64_t GetNextCachedData(int64_t aOffset)
 28471:   {
111035:     MutexAutoLock lock(mLock);
128745: 
111035:     EnsureSizeInitialized();
 28471:     return (aOffset < mSize) ? aOffset : -1;
 28471:   }
111035:   virtual int64_t GetCachedDataEnd(int64_t aOffset) {
111035:     MutexAutoLock lock(mLock);
128745: 
111035:     EnsureSizeInitialized();
129543:     return std::max(aOffset, mSize);
111035:   }
108991:   virtual bool    IsDataCachedToEndOfResource(int64_t aOffset) { return true; }
147922:   virtual bool    IsSuspendedByCache() { return false; }
 79445:   virtual bool    IsSuspended() { return false; }
131465:   virtual bool    IsTransportSeekable() MOZ_OVERRIDE { return true; }
 20627: 
 90148:   nsresult GetCachedRanges(nsTArray<MediaByteRange>& aRanges);
 63626: 
151965: protected:
151965:   // These Unsafe variants of Read and Seek perform their operations
151965:   // without acquiring mLock. The caller must obtain the lock before
151965:   // calling. The implmentation of Read, Seek and ReadAt obtains the
151965:   // lock before calling these Unsafe variants to read or seek.
151965:   nsresult UnsafeRead(char* aBuffer, uint32_t aCount, uint32_t* aBytes);
151965:   nsresult UnsafeSeek(int32_t aWhence, int64_t aOffset);
 20627: private:
110604:   // Ensures mSize is initialized, if it can be.
111035:   // mLock must be held when this is called, and mInput must be non-null.
111035:   void EnsureSizeInitialized();
110604: 
 26836:   // The file size, or -1 if not known. Immutable after Open().
111035:   // Can be used from any thread.
108991:   int64_t mSize;
 26836: 
 26836:   // This lock handles synchronisation between calls to Close() and
 26836:   // the Read, Seek, etc calls. Close must not be called while a
 26836:   // Read or Seek is in progress since it resets various internal
 26836:   // values to null.
111035:   // This lock protects mSeekable, mInput, mSize, and mSizeInitialized.
 64576:   Mutex mLock;
 26836: 
 20627:   // Seekable stream interface to file. This can be used from any
 20627:   // thread.
 20627:   nsCOMPtr<nsISeekableStream> mSeekable;
 20627: 
 20627:   // Input stream for the media data. This can be used from any
128745:   // thread.
 20627:   nsCOMPtr<nsIInputStream>  mInput;
110604: 
110604:   // Whether we've attempted to initialize mSize. Note that mSize can be -1
110604:   // when mSizeInitialized is true if we tried and failed to get the size
110604:   // of the file.
110604:   bool mSizeInitialized;
 20627: };
 20627: 
111035: void FileMediaResource::EnsureSizeInitialized()
110604: {
110604:   mLock.AssertCurrentThreadOwns();
111035:   NS_ASSERTION(mInput, "Must have file input stream");
111035:   if (mSizeInitialized) {
110604:     return;
110604:   }
110604:   mSizeInitialized = true;
110604:   // Get the file size and inform the decoder.
110604:   uint64_t size;
110604:   nsresult res = mInput->Available(&size);
115367:   if (NS_SUCCEEDED(res) && size <= INT64_MAX) {
110604:     mSize = (int64_t)size;
169057:     nsCOMPtr<nsIRunnable> event = new DataEnded(mDecoder, NS_OK);
110604:     NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
110604:   }
110604: }
110604: 
 90148: nsresult FileMediaResource::GetCachedRanges(nsTArray<MediaByteRange>& aRanges)
 63626: {
110604:   MutexAutoLock lock(mLock);
128745: 
111035:   EnsureSizeInitialized();
 63626:   if (mSize == -1) {
 63626:     return NS_ERROR_FAILURE;
 63626:   }
 90148:   aRanges.AppendElement(MediaByteRange(0, mSize));
 63626:   return NS_OK;
 63626: }
 63626: 
 90148: nsresult FileMediaResource::Open(nsIStreamListener** aStreamListener)
 20627: {
 26836:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
 21079:   if (aStreamListener) {
106838:     *aStreamListener = nullptr;
 21079:   }
 21079: 
 68468:   nsresult rv = NS_OK;
 21079:   if (aStreamListener) {
 21079:     // The channel is already open. We need a synchronous stream that
 21079:     // implements nsISeekableStream, so we have to find the underlying
 21079:     // file and reopen it
 21079:     nsCOMPtr<nsIFileChannel> fc(do_QueryInterface(mChannel));
111255:     if (fc) {
 21079:       nsCOMPtr<nsIFile> file;
 21079:       rv = fc->GetFile(getter_AddRefs(file));
 21079:       NS_ENSURE_SUCCESS(rv, rv);
 21079: 
 21079:       rv = NS_NewLocalFileInputStream(getter_AddRefs(mInput), file);
111255:     } else if (IsBlobURI(mURI)) {
111255:       rv = NS_GetStreamForBlobURI(mURI, getter_AddRefs(mInput));
111255:     }
 21079:   } else {
 24189:     // Ensure that we never load a local file from some page on a
 24189:     // web server.
121434:     MediaDecoderOwner* owner = mDecoder->GetMediaOwner();
121434:     NS_ENSURE_TRUE(owner, NS_ERROR_FAILURE);
171973:     dom::HTMLMediaElement* element = owner->GetMediaElement();
 24189:     NS_ENSURE_TRUE(element, NS_ERROR_FAILURE);
 24189: 
 24189:     rv = nsContentUtils::GetSecurityManager()->
 24189:            CheckLoadURIWithPrincipal(element->NodePrincipal(),
 24189:                                      mURI,
 24189:                                      nsIScriptSecurityManager::STANDARD);
 24189:     NS_ENSURE_SUCCESS(rv, rv);
 24189: 
 20627:     rv = mChannel->Open(getter_AddRefs(mInput));
 21079:   }
 20627:   NS_ENSURE_SUCCESS(rv, rv);
 20627: 
 20627:   mSeekable = do_QueryInterface(mInput);
 21079:   if (!mSeekable) {
 21079:     // XXX The file may just be a .url or similar
 21079:     // shortcut that points to a Web site. We need to fix this by
 21079:     // doing an async open and waiting until we locate the real resource,
 21079:     // then using that (if it's still a file!).
 21079:     return NS_ERROR_FAILURE;
 21079:   }
 20627: 
 21079:   return NS_OK;
 20627: }
 20627: 
 90148: nsresult FileMediaResource::Close()
 20627: {
 26836:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 26836: 
128745:   // Since mChennel is only accessed by main thread, there is no necessary to
128745:   // take the lock.
 20627:   if (mChannel) {
 26836:     mChannel->Cancel(NS_ERROR_PARSED_DATA_CACHED);
106838:     mChannel = nullptr;
 20627:   }
 20627: 
 20627:   return NS_OK;
 20627: }
 20627: 
 90148: already_AddRefed<nsIPrincipal> FileMediaResource::GetCurrentPrincipal()
 28370: {
 28370:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 28370: 
 28370:   nsCOMPtr<nsIPrincipal> principal;
 28370:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 28370:   if (!secMan || !mChannel)
106838:     return nullptr;
 28370:   secMan->GetChannelPrincipal(mChannel, getter_AddRefs(principal));
 28370:   return principal.forget();
 28370: }
 28370: 
 93550: bool FileMediaResource::CanClone()
 93550: {
 93550:   return true;
 93550: }
 93550: 
142463: already_AddRefed<MediaResource> FileMediaResource::CloneData(MediaDecoder* aDecoder)
 32901: {
 32901:   NS_ASSERTION(NS_IsMainThread(), "Only call on main thread");
 32901: 
121434:   MediaDecoderOwner* owner = mDecoder->GetMediaOwner();
121434:   if (!owner) {
121434:     // The decoder is being shut down, so we can't clone
121434:     return nullptr;
121434:   }
171973:   dom::HTMLMediaElement* element = owner->GetMediaElement();
 32901:   if (!element) {
 32901:     // The decoder is being shut down, so we can't clone
106838:     return nullptr;
 32901:   }
 32901:   nsCOMPtr<nsILoadGroup> loadGroup = element->GetDocumentLoadGroup();
106838:   NS_ENSURE_TRUE(loadGroup, nullptr);
 32901: 
 32901:   nsCOMPtr<nsIChannel> channel;
 32901:   nsresult rv =
106838:     NS_NewChannel(getter_AddRefs(channel), mURI, nullptr, loadGroup, nullptr, 0);
 32901:   if (NS_FAILED(rv))
106838:     return nullptr;
 32901: 
142463:   nsRefPtr<MediaResource> resource(new FileMediaResource(aDecoder, channel, mURI, GetContentType()));
142463:   return resource.forget();
 32901: }
 32901: 
108991: nsresult FileMediaResource::ReadFromCache(char* aBuffer, int64_t aOffset, uint32_t aCount)
 48904: {
 64576:   MutexAutoLock lock(mLock);
128745: 
111035:   EnsureSizeInitialized();
108991:   int64_t offset = 0;
 48904:   nsresult res = mSeekable->Tell(&offset);
 48904:   NS_ENSURE_SUCCESS(res,res);
 48904:   res = mSeekable->Seek(nsISeekableStream::NS_SEEK_SET, aOffset);
 48904:   NS_ENSURE_SUCCESS(res,res);
108991:   uint32_t bytesRead = 0;
 48904:   do {
108991:     uint32_t x = 0;
108991:     uint32_t bytesToRead = aCount - bytesRead;
 48904:     res = mInput->Read(aBuffer, bytesToRead, &x);
 48904:     bytesRead += x;
 48904:   } while (bytesRead != aCount && res == NS_OK);
 48904: 
 48904:   // Reset read head to original position so we don't disturb any other
 48904:   // reading thread.
 48904:   nsresult seekres = mSeekable->Seek(nsISeekableStream::NS_SEEK_SET, offset);
 48904: 
 48904:   // If a read failed in the loop above, we want to return its failure code.
 48904:   NS_ENSURE_SUCCESS(res,res);
 48904: 
 48904:   // Else we succeed if the reset-seek succeeds.
 48904:   return seekres;
 48904: }
 48904: 
108991: nsresult FileMediaResource::Read(char* aBuffer, uint32_t aCount, uint32_t* aBytes)
 20627: {
162443:   nsresult rv;
162443:   int64_t offset = 0;
162443:   {
 64576:     MutexAutoLock lock(mLock);
162443:     mSeekable->Tell(&offset);
162443:     rv = UnsafeRead(aBuffer, aCount, aBytes);
162443:   }
162443:   if (NS_SUCCEEDED(rv)) {
162443:     DispatchBytesConsumed(*aBytes, offset);
162443:   }
162443:   return rv;
151965: }
128745: 
151965: nsresult FileMediaResource::UnsafeRead(char* aBuffer, uint32_t aCount, uint32_t* aBytes)
151965: {
111035:   EnsureSizeInitialized();
 24721:   return mInput->Read(aBuffer, aCount, aBytes);
 20627: }
 20627: 
151965: nsresult FileMediaResource::ReadAt(int64_t aOffset, char* aBuffer,
151965:                                    uint32_t aCount, uint32_t* aBytes)
151965: {
151965:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
151965: 
162443:   nsresult rv;
162443:   {
151965:     MutexAutoLock lock(mLock);
162443:     rv = UnsafeSeek(nsISeekableStream::NS_SEEK_SET, aOffset);
151965:     if (NS_FAILED(rv)) return rv;
162443:     rv = UnsafeRead(aBuffer, aCount, aBytes);
162443:   }
162443:   if (NS_SUCCEEDED(rv)) {
162443:     DispatchBytesConsumed(*aBytes, aOffset);
162443:   }
162443:   return rv;
151965: }
151965: 
108991: nsresult FileMediaResource::Seek(int32_t aWhence, int64_t aOffset)
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 26836: 
 64576:   MutexAutoLock lock(mLock);
151965:   return UnsafeSeek(aWhence, aOffset);
151965: }
151965: 
151965: nsresult FileMediaResource::UnsafeSeek(int32_t aWhence, int64_t aOffset)
151965: {
151965:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
151965: 
 24721:   if (!mSeekable)
 24721:     return NS_ERROR_FAILURE;
111035:   EnsureSizeInitialized();
 26836:   return mSeekable->Seek(aWhence, aOffset);
 20627: }
 20627: 
108991: int64_t FileMediaResource::Tell()
 20627: {
 26836:   NS_ASSERTION(!NS_IsMainThread(), "Don't call on main thread");
 26836: 
 64576:   MutexAutoLock lock(mLock);
 20627:   if (!mSeekable)
 20627:     return 0;
111035:   EnsureSizeInitialized();
 20627: 
108991:   int64_t offset = 0;
 20627:   mSeekable->Tell(&offset);
 20627:   return offset;
 20627: }
 20627: 
142463: already_AddRefed<MediaResource>
121916: MediaResource::Create(MediaDecoder* aDecoder, nsIChannel* aChannel)
 20627: {
 20627:   NS_ASSERTION(NS_IsMainThread(),
 90148:                "MediaResource::Open called on non-main thread");
 20627: 
 32899:   // If the channel was redirected, we want the post-redirect URI;
 32899:   // but if the URI scheme was expanded, say from chrome: to jar:file:,
 32899:   // we want the original URI.
 32899:   nsCOMPtr<nsIURI> uri;
 32899:   nsresult rv = NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
106838:   NS_ENSURE_SUCCESS(rv, nullptr);
 20627: 
132924:   nsAutoCString contentType;
132924:   aChannel->GetContentType(contentType);
132924: 
 32899:   nsCOMPtr<nsIFileChannel> fc = do_QueryInterface(aChannel);
142463:   nsRefPtr<MediaResource> resource;
111255:   if (fc || IsBlobURI(uri)) {
142463:     resource = new FileMediaResource(aDecoder, aChannel, uri, contentType);
165532:   } else if (IsRtspURI(uri)) {
165532:     resource = new RtspMediaResource(aDecoder, aChannel, uri, contentType);
142463:   } else {
142463:     resource = new ChannelMediaResource(aDecoder, aChannel, uri, contentType);
 26705:   }
142463:   return resource.forget();
 20627: }
 26836: 
123588: void BaseMediaResource::MoveLoadsToBackground() {
 27217:   NS_ASSERTION(!mLoadInBackground, "Why are you calling this more than once?");
 79547:   mLoadInBackground = true;
 27217:   if (!mChannel) {
 27217:     // No channel, resource is probably already loaded.
 27217:     return;
 27217:   }
 27217: 
121434:   MediaDecoderOwner* owner = mDecoder->GetMediaOwner();
121434:   if (!owner) {
121434:     NS_WARNING("Null owner in MediaResource::MoveLoadsToBackground()");
121434:     return;
121434:   }
171973:   dom::HTMLMediaElement* element = owner->GetMediaElement();
 27217:   if (!element) {
 90148:     NS_WARNING("Null element in MediaResource::MoveLoadsToBackground()");
 27217:     return;
 27217:   }
 62568: 
 79445:   bool isPending = false;
 62568:   if (NS_SUCCEEDED(mChannel->IsPending(&isPending)) &&
 27217:       isPending) {
 27217:     nsLoadFlags loadFlags;
 94314:     DebugOnly<nsresult> rv = mChannel->GetLoadFlags(&loadFlags);
 27217:     NS_ASSERTION(NS_SUCCEEDED(rv), "GetLoadFlags() failed!");
 27217: 
 27217:     loadFlags |= nsIRequest::LOAD_BACKGROUND;
 62568:     ModifyLoadFlags(loadFlags);
 62568:   }
 62568: }
 62568: 
123588: void BaseMediaResource::ModifyLoadFlags(nsLoadFlags aFlags)
 62568: {
 62568:   nsCOMPtr<nsILoadGroup> loadGroup;
 94314:   DebugOnly<nsresult> rv = mChannel->GetLoadGroup(getter_AddRefs(loadGroup));
 62568:   NS_ASSERTION(NS_SUCCEEDED(rv), "GetLoadGroup() failed!");
 62568: 
 62568:   nsresult status;
 62568:   mChannel->GetStatus(&status);
 62568: 
 62568:   // Note: if (NS_FAILED(status)), the channel won't be in the load group.
 62568:   if (loadGroup &&
 62568:       NS_SUCCEEDED(status)) {
106838:     rv = loadGroup->RemoveRequest(mChannel, nullptr, status);
 62568:     NS_ASSERTION(NS_SUCCEEDED(rv), "RemoveRequest() failed!");
 62568:   }
 62568: 
 62568:   rv = mChannel->SetLoadFlags(aFlags);
 27217:   NS_ASSERTION(NS_SUCCEEDED(rv), "SetLoadFlags() failed!");
 27217: 
 62568:   if (loadGroup &&
 62568:       NS_SUCCEEDED(status)) {
106838:     rv = loadGroup->AddRequest(mChannel, nullptr);
 27217:     NS_ASSERTION(NS_SUCCEEDED(rv), "AddRequest() failed!");
 27217:   }
 27217: }
121915: 
162443: class DispatchBytesConsumedEvent : public nsRunnable {
162443: public:
162443:   DispatchBytesConsumedEvent(MediaDecoder* aDecoder,
162443:                              int64_t aNumBytes,
162443:                              int64_t aOffset)
162443:     : mDecoder(aDecoder),
162443:       mNumBytes(aNumBytes),
162443:       mOffset(aOffset)
162443:   {
162443:     MOZ_COUNT_CTOR(DispatchBytesConsumedEvent);
162443:   }
162443: 
162443:   ~DispatchBytesConsumedEvent()
162443:   {
162443:     MOZ_COUNT_DTOR(DispatchBytesConsumedEvent);
162443:   }
162443: 
162443:   NS_IMETHOD Run() {
162443:     mDecoder->NotifyBytesConsumed(mNumBytes, mOffset);
162443:     // Drop ref to decoder on main thread, just in case this reference
162443:     // ends up being the last owning reference somehow.
162443:     mDecoder = nullptr;
162443:     return NS_OK;
162443:   }
162443: 
162443:   RefPtr<MediaDecoder> mDecoder;
162443:   int64_t mNumBytes;
162443:   int64_t mOffset;
162443: };
162443: 
162443: void BaseMediaResource::DispatchBytesConsumed(int64_t aNumBytes, int64_t aOffset)
162443: {
162443:   RefPtr<nsIRunnable> event(new DispatchBytesConsumedEvent(mDecoder, aNumBytes, aOffset));
162443:   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
162443: }
162443: 
121915: } // namespace mozilla
121915: 
