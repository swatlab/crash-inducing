     1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "gfxXlibSurface.h"
     1: 
     1: #include "cairo.h"
     1: #include "cairo-xlib.h"
     1: #include "cairo-xlib-xrender.h"
 47116: #include <X11/Xlibint.h>	/* For XESetCloseDisplay */
 47760: 
 47116: #include "nsTArray.h"
 47764: #include "nsAlgorithm.h"
 71640: #include "mozilla/Preferences.h"
     1: 
 71640: using namespace mozilla;
 71640: 
 46299: // Although the dimension parameters in the xCreatePixmapReq wire protocol are
 46299: // 16-bit unsigned integers, the server's CreatePixmap returns BadAlloc if
 46299: // either dimension cannot be represented by a 16-bit *signed* integer.
 46299: #define XLIB_IMAGE_SIDE_SIZE_LIMIT 0x7fff
  1349: 
     1: gfxXlibSurface::gfxXlibSurface(Display *dpy, Drawable drawable, Visual *visual)
 80486:     : mPixmapTaken(false), mDisplay(dpy), mDrawable(drawable)
118564: #if !defined(MOZ_PLATFORM_MAEMO)
 74909:     , mGLXPixmap(None)
 74909: #endif
     1: {
     1:     DoSizeQuery();
     1:     cairo_surface_t *surf = cairo_xlib_surface_create(dpy, drawable, visual, mSize.width, mSize.height);
     1:     Init(surf);
     1: }
     1: 
     1: gfxXlibSurface::gfxXlibSurface(Display *dpy, Drawable drawable, Visual *visual, const gfxIntSize& size)
 80486:     : mPixmapTaken(false), mDisplay(dpy), mDrawable(drawable), mSize(size)
118564: #if !defined(MOZ_PLATFORM_MAEMO)
 74909:     , mGLXPixmap(None)
 74909: #endif
     1: {
 47113:     NS_ASSERTION(CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT),
 47113:                  "Bad size");
  1349: 
     1:     cairo_surface_t *surf = cairo_xlib_surface_create(dpy, drawable, visual, mSize.width, mSize.height);
     1:     Init(surf);
     1: }
     1: 
 47113: gfxXlibSurface::gfxXlibSurface(Screen *screen, Drawable drawable, XRenderPictFormat *format,
 47113:                                const gfxIntSize& size)
 80486:     : mPixmapTaken(false), mDisplay(DisplayOfScreen(screen)),
 74909:       mDrawable(drawable), mSize(size)
118564: #if !defined(MOZ_PLATFORM_MAEMO)
 74909:       , mGLXPixmap(None)
 74909: #endif
 47113: {
 47113:     NS_ASSERTION(CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT),
 47113:                  "Bad Size");
     1: 
 47113:     cairo_surface_t *surf =
 47113:         cairo_xlib_surface_create_with_xrender_format(mDisplay, drawable,
 47113:                                                       screen, format,
 47113:                                                       mSize.width, mSize.height);
     1:     Init(surf);
     1: }
     1: 
     1: gfxXlibSurface::gfxXlibSurface(cairo_surface_t *csurf)
 80486:     : mPixmapTaken(false),
 44153:       mSize(cairo_xlib_surface_get_width(csurf),
 74909:             cairo_xlib_surface_get_height(csurf))
118564: #if !defined(MOZ_PLATFORM_MAEMO)
 74909:       , mGLXPixmap(None)
 74909: #endif
     1: {
 47113:     NS_PRECONDITION(cairo_surface_status(csurf) == 0,
 47113:                     "Not expecting an error surface");
 47113: 
     1:     mDrawable = cairo_xlib_surface_get_drawable(csurf);
     1:     mDisplay = cairo_xlib_surface_get_display(csurf);
     1: 
 80486:     Init(csurf, true);
     1: }
     1: 
     1: gfxXlibSurface::~gfxXlibSurface()
     1: {
118564: #if !defined(MOZ_PLATFORM_MAEMO)
 74902:     if (mGLXPixmap) {
111402:         gl::sDefGLXLib.DestroyPixmap(mGLXPixmap);
 74902:     }
 74909: #endif
 74887:     // gfxASurface's destructor calls RecordMemoryFreed().
 46300:     if (mPixmapTaken) {
 46300:         XFreePixmap (mDisplay, mDrawable);
 46300:     }
     1: }
     1: 
 47113: static Drawable
 47113: CreatePixmap(Screen *screen, const gfxIntSize& size, unsigned int depth,
 47113:              Drawable relatedDrawable)
 47113: {
 47113:     if (!gfxASurface::CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT))
 47113:         return None;
 47113: 
 47113:     if (relatedDrawable == None) {
 47113:         relatedDrawable = RootWindowOfScreen(screen);
 47113:     }
 47113:     Display *dpy = DisplayOfScreen(screen);
 47764:     // X gives us a fatal error if we try to create a pixmap of width
 47764:     // or height 0
 47113:     return XCreatePixmap(dpy, relatedDrawable,
 47764:                          NS_MAX(1, size.width), NS_MAX(1, size.height),
 47764:                          depth);
 47113: }
 47113: 
 74887: void
 74887: gfxXlibSurface::TakePixmap()
 74887: {
 74887:     NS_ASSERTION(!mPixmapTaken, "I already own the Pixmap!");
 80486:     mPixmapTaken = true;
 74887: 
 74887:     // Divide by 8 because surface_get_depth gives us the number of *bits* per
 74887:     // pixel.
 74887:     RecordMemoryUsed(mSize.width * mSize.height *
 74887:         cairo_xlib_surface_get_depth(CairoSurface()) / 8);
 74887: }
 74887: 
 74887: Drawable
 74887: gfxXlibSurface::ReleasePixmap() {
 74887:     NS_ASSERTION(mPixmapTaken, "I don't own the Pixmap!");
 80486:     mPixmapTaken = false;
 74887:     RecordMemoryFreed();
 74887:     return mDrawable;
 74887: }
 74887: 
 47113: /* static */
 47113: already_AddRefed<gfxXlibSurface>
 47113: gfxXlibSurface::Create(Screen *screen, Visual *visual,
 47113:                        const gfxIntSize& size, Drawable relatedDrawable)
 47113: {
 47113:     Drawable drawable =
 47113:         CreatePixmap(screen, size, DepthOfVisual(screen, visual),
 47113:                      relatedDrawable);
 47113:     if (!drawable)
106838:         return nullptr;
 47113: 
 47113:     nsRefPtr<gfxXlibSurface> result =
 47113:         new gfxXlibSurface(DisplayOfScreen(screen), drawable, visual, size);
 47113:     result->TakePixmap();
 47113: 
 47113:     if (result->CairoStatus() != 0)
106838:         return nullptr;
 47113: 
 47113:     return result.forget();
 47113: }
 47113: 
 47113: /* static */
 47113: already_AddRefed<gfxXlibSurface>
 47113: gfxXlibSurface::Create(Screen *screen, XRenderPictFormat *format,
 47113:                        const gfxIntSize& size, Drawable relatedDrawable)
 47113: {
 47113:     Drawable drawable =
 47113:         CreatePixmap(screen, size, format->depth, relatedDrawable);
 47113:     if (!drawable)
106838:         return nullptr;
 47113: 
 47113:     nsRefPtr<gfxXlibSurface> result =
 47113:         new gfxXlibSurface(screen, drawable, format, size);
 47113:     result->TakePixmap();
 47113: 
 47113:     if (result->CairoStatus() != 0)
106838:         return nullptr;
 47113: 
 47113:     return result.forget();
 47113: }
 47113: 
 79445: static bool GetForce24bppPref()
 47760: {
 79445:     return Preferences::GetBool("mozilla.widget.force-24bpp", false);
 47760: }
 47760: 
 47760: already_AddRefed<gfxASurface>
 47760: gfxXlibSurface::CreateSimilarSurface(gfxContentType aContent,
 47760:                                      const gfxIntSize& aSize)
 47760: {
 59394:     if (!mSurface || !mSurfaceValid) {
106838:       return nullptr;
 59394:     }
 59394: 
 47760:     if (aContent == CONTENT_COLOR) {
 48435:         // cairo_surface_create_similar will use a matching visual if it can.
 48435:         // However, systems with 16-bit or indexed default visuals may benefit
 48435:         // from rendering with 24-bit formats.
 79445:         static bool force24bpp = GetForce24bppPref();
 48435:         if (force24bpp
 48435:             && cairo_xlib_surface_get_depth(CairoSurface()) != 24) {
 47760:             XRenderPictFormat* format =
 48435:                 XRenderFindStandardFormat(mDisplay, PictStandardRGB24);
 47760:             if (format) {
 48435:                 // Cairo only performs simple self-copies as desired if it
 48435:                 // knows that this is a Pixmap surface.  It only knows that
 48435:                 // surfaces are pixmap surfaces if it creates the Pixmap
 48435:                 // itself, so we use cairo_surface_create_similar with a
 48435:                 // temporary reference surface to indicate the format.
 48435:                 Screen* screen = cairo_xlib_surface_get_screen(CairoSurface());
 48435:                 nsRefPtr<gfxXlibSurface> depth24reference =
 48435:                     gfxXlibSurface::Create(screen, format,
 48435:                                            gfxIntSize(1, 1), mDrawable);
 48435:                 if (depth24reference)
 48435:                     return depth24reference->
 48435:                         gfxASurface::CreateSimilarSurface(aContent, aSize);
 48435:             }
 48435:         }
 47760:     }
 47760: 
 47760:     return gfxASurface::CreateSimilarSurface(aContent, aSize);
 47760: }
 47760: 
     1: void
120512: gfxXlibSurface::Finish()
120512: {
120512: #if !defined(MOZ_PLATFORM_MAEMO)
120512:     if (mGLXPixmap) {
120512:         gl::sDefGLXLib.DestroyPixmap(mGLXPixmap);
120512:         mGLXPixmap = None;
120512:     }
120512: #endif
120512:     gfxASurface::Finish();
120512: }
120512: 
120512: void
     1: gfxXlibSurface::DoSizeQuery()
     1: {
     1:     // figure out width/height/depth
     1:     Window root_ignore;
     1:     int x_ignore, y_ignore;
     1:     unsigned int bwidth_ignore, width, height, depth;
     1: 
     1:     XGetGeometry(mDisplay,
     1:                  mDrawable,
     1:                  &root_ignore, &x_ignore, &y_ignore,
     1:                  &width, &height,
     1:                  &bwidth_ignore, &depth);
     1: 
     1:     mSize.width = width;
     1:     mSize.height = height;
     1: }
     1: 
 47116: class DisplayTable {
 47116: public:
 79445:     static bool GetColormapAndVisual(Screen* screen,
 47116:                                        XRenderPictFormat* format,
 47116:                                        Visual* visual, Colormap* colormap,
 47116:                                        Visual** visualForColormap);
 47116: 
 47116: private:
 47116:     struct ColormapEntry {
 47116:         XRenderPictFormat* mFormat;
 47116:         // The Screen is needed here because colormaps (and their visuals) may
 47116:         // only be used on one Screen, but XRenderPictFormats are not unique
 47116:         // to any one Screen.
 47116:         Screen* mScreen;
 47116:         Visual* mVisual;
 47116:         Colormap mColormap;
 47116:     };
 47116: 
 47116:     class DisplayInfo {
 47116:     public:
 47116:         DisplayInfo(Display* display) : mDisplay(display) { }
 47116:         Display* mDisplay;
 47116:         nsTArray<ColormapEntry> mColormapEntries;
 47116:     };
 47116: 
 47116:     // Comparator for finding the DisplayInfo
 47116:     class FindDisplay {
 47116:     public:
 79445:         bool Equals(const DisplayInfo& info, const Display *display) const
 47116:         {
 47116:             return info.mDisplay == display;
 47116:         }
 47116:     };
 47116: 
 47116:     static int DisplayClosing(Display *display, XExtCodes* codes);
 47116: 
 47116:     nsTArray<DisplayInfo> mDisplays;
 47116:     static DisplayTable* sDisplayTable;
 47116: };
 47116: 
 47116: DisplayTable* DisplayTable::sDisplayTable;
 47116: 
 47116: // Pixmaps don't have a particular associated visual but the pixel values are
 47116: // interpreted according to a visual/colormap pairs.
 47116: //
 47116: // cairo is designed for surfaces with either TrueColor visuals or the
 47116: // default visual (which may not be true color).  TrueColor visuals don't
 47116: // really need a colormap because the visual indicates the pixel format,
 47116: // and cairo uses the default visual with the default colormap, so cairo
 47116: // surfaces don't need an explicit colormap.
 47116: //
 47116: // However, some toolkits (e.g. GDK) need a colormap even with TrueColor
 47116: // visuals.  We can create a colormap for these visuals, but it will use about
 47116: // 20kB of memory in the server, so we use the default colormap when
 47116: // suitable and share colormaps between surfaces.  Another reason for
 47116: // minimizing colormap turnover is that the plugin process must leak resources
 47116: // for each new colormap id when using older GDK libraries (bug 569775).
 47116: //
 47116: // Only the format of the pixels is important for rendering to Pixmaps, so if
 47116: // the format of a visual matches that of the surface, then that visual can be
 47116: // used for rendering to the surface.  Multiple visuals can match the same
 47116: // format (but have different GLX properties), so the visual returned may
 47116: // differ from the visual passed in.  Colormaps are tied to a visual, so
 47116: // should only be used with their visual.
 47116: 
 79445: /* static */ bool
 47116: DisplayTable::GetColormapAndVisual(Screen* aScreen, XRenderPictFormat* aFormat,
 47116:                                    Visual* aVisual, Colormap* aColormap,
 47116:                                    Visual** aVisualForColormap)
 47116: 
 47116: {
 47116:     Display* display = DisplayOfScreen(aScreen);
 47116: 
 47116:     // Use the default colormap if the default visual matches.
 47116:     Visual *defaultVisual = DefaultVisualOfScreen(aScreen);
 47116:     if (aVisual == defaultVisual
 47116:         || (aFormat
 47116:             && aFormat == XRenderFindVisualFormat(display, defaultVisual)))
 47116:     {
 47116:         *aColormap = DefaultColormapOfScreen(aScreen);
 47116:         *aVisualForColormap = defaultVisual;
 80486:         return true;
 47116:     }
 47116: 
 47116:     // Only supporting TrueColor non-default visuals
 47116:     if (!aVisual || aVisual->c_class != TrueColor)
 80486:         return false;
 47116: 
 47116:     if (!sDisplayTable) {
 47116:         sDisplayTable = new DisplayTable();
 47116:     }
 47116: 
 47116:     nsTArray<DisplayInfo>* displays = &sDisplayTable->mDisplays;
108991:     uint32_t d = displays->IndexOf(display, 0, FindDisplay());
 47116: 
 47116:     if (d == displays->NoIndex) {
 47116:         d = displays->Length();
 47116:         // Register for notification of display closing, when this info
 47116:         // becomes invalid.
 47116:         XExtCodes *codes = XAddExtension(display);
 47116:         if (!codes)
 80486:             return false;
 47116: 
 47116:         XESetCloseDisplay(display, codes->extension, DisplayClosing);
 47116:         // Add a new DisplayInfo.
 47116:         displays->AppendElement(display);
 47116:     }
 47116: 
 47116:     nsTArray<ColormapEntry>* entries =
 47116:         &displays->ElementAt(d).mColormapEntries;
 47116: 
 47116:     // Only a small number of formats are expected to be used, so just do a
 47116:     // simple linear search.
108991:     for (uint32_t i = 0; i < entries->Length(); ++i) {
 47116:         const ColormapEntry& entry = entries->ElementAt(i);
 47116:         // Only the format and screen need to match.  (The visual may differ.)
 47116:         // If there is no format (e.g. no RENDER extension) then just compare
 47116:         // the visual.
 47116:         if ((aFormat && entry.mFormat == aFormat && entry.mScreen == aScreen)
 47116:             || aVisual == entry.mVisual) {
 47116:             *aColormap = entry.mColormap;
 47116:             *aVisualForColormap = entry.mVisual;
 80486:             return true;
 47116:         }
 47116:     }
 47116: 
 47116:     // No existing entry.  Create a colormap and add an entry.
 47116:     Colormap colormap = XCreateColormap(display, RootWindowOfScreen(aScreen),
 47116:                                         aVisual, AllocNone);
 47116:     ColormapEntry* newEntry = entries->AppendElement();
 47116:     newEntry->mFormat = aFormat;
 47116:     newEntry->mScreen = aScreen;
 47116:     newEntry->mVisual = aVisual;
 47116:     newEntry->mColormap = colormap;
 47116: 
 47116:     *aColormap = colormap;
 47116:     *aVisualForColormap = aVisual;
 80486:     return true;
 47116: }
 47116: 
 47116: /* static */ int
 47116: DisplayTable::DisplayClosing(Display *display, XExtCodes* codes)
 47116: {
 47116:     // No need to free the colormaps explicitly as they will be released when
 47116:     // the connection is closed.
 47116:     sDisplayTable->mDisplays.RemoveElement(display, FindDisplay());
 47116:     if (sDisplayTable->mDisplays.Length() == 0) {
 47116:         delete sDisplayTable;
106838:         sDisplayTable = nullptr;
 47116:     }
 47116:     return 0;
 47116: }
 47116: 
 79445: bool
 47116: gfxXlibSurface::GetColormapAndVisual(Colormap* aColormap, Visual** aVisual)
 47116: {
 47116:     if (!mSurfaceValid)
 80486:         return false;
 47116: 
 47116:     XRenderPictFormat* format =
 47116:         cairo_xlib_surface_get_xrender_format(CairoSurface());
 47116:     Screen* screen = cairo_xlib_surface_get_screen(CairoSurface());
 47116:     Visual* visual = cairo_xlib_surface_get_visual(CairoSurface());
 47116: 
 47116:     return DisplayTable::GetColormapAndVisual(screen, format, visual,
 47116:                                               aColormap, aVisual);
 47116: }
 47116: 
 47113: /* static */
 47113: int
 47113: gfxXlibSurface::DepthOfVisual(const Screen* screen, const Visual* visual)
 47113: {
 47113:     for (int d = 0; d < screen->ndepths; d++) {
 47113:         const Depth& d_info = screen->depths[d];
 47113:         if (visual >= &d_info.visuals[0]
 47113:             && visual < &d_info.visuals[d_info.nvisuals])
 47113:             return d_info.depth;
 47113:     }
 47113: 
 47113:     NS_ERROR("Visual not on Screen.");
 47113:     return 0;
 47113: }
 47113:     
 47113: /* static */
 48108: Visual*
 48108: gfxXlibSurface::FindVisual(Screen *screen, gfxImageFormat format)
 48108: {
 48108:     int depth;
 48108:     unsigned long red_mask, green_mask, blue_mask;
 48108:     switch (format) {
 48108:         case ImageFormatARGB32:
 48108:             depth = 32;
 48108:             red_mask = 0xff0000;
 48108:             green_mask = 0xff00;
 48108:             blue_mask = 0xff;
 48108:             break;
 48108:         case ImageFormatRGB24:
 48108:             depth = 24;
 48108:             red_mask = 0xff0000;
 48108:             green_mask = 0xff00;
 48108:             blue_mask = 0xff;
 48108:             break;
 48108:         case ImageFormatRGB16_565:
 48108:             depth = 16;
 48108:             red_mask = 0xf800;
 48108:             green_mask = 0x7e0;
 48108:             blue_mask = 0x1f;
 48108:             break;
 48108:         case ImageFormatA8:
 48108:         case ImageFormatA1:
 48108:         default:
 48108:             return NULL;
 48108:     }
 48108: 
 48108:     for (int d = 0; d < screen->ndepths; d++) {
 48108:         const Depth& d_info = screen->depths[d];
 48108:         if (d_info.depth != depth)
 48108:             continue;
 48108: 
 48108:         for (int v = 0; v < d_info.nvisuals; v++) {
 48108:             Visual* visual = &d_info.visuals[v];
 48108: 
 48108:             if (visual->c_class == TrueColor &&
 48108:                 visual->red_mask == red_mask &&
 48108:                 visual->green_mask == green_mask &&
 48108:                 visual->blue_mask == blue_mask)
 48108:                 return visual;
 48108:         }
 48108:     }
 48108: 
 48108:     return NULL;
 48108: }
 48108: 
 48108: /* static */
     1: XRenderPictFormat*
     1: gfxXlibSurface::FindRenderFormat(Display *dpy, gfxImageFormat format)
     1: {
     1:     switch (format) {
     1:         case ImageFormatARGB32:
     1:             return XRenderFindStandardFormat (dpy, PictStandardARGB32);
     1:         case ImageFormatRGB24:
     1:             return XRenderFindStandardFormat (dpy, PictStandardRGB24);
 43558:         case ImageFormatRGB16_565: {
 43558:             // PictStandardRGB16_565 is not standard Xrender format
 43558:             // we should try to find related visual
 43558:             // and find xrender format by visual
 48108:             Visual *visual = FindVisual(DefaultScreenOfDisplay(dpy), format);
 43558:             if (!visual)
 43558:                 return NULL;
 43558:             return XRenderFindVisualFormat(dpy, visual);
 43558:         }
     1:         case ImageFormatA8:
     1:             return XRenderFindStandardFormat (dpy, PictStandardA8);
     1:         case ImageFormatA1:
     1:             return XRenderFindStandardFormat (dpy, PictStandardA1);
 48108:         default:
     1:             break;
     1:     }
     1: 
     1:     return (XRenderPictFormat*)NULL;
     1: }
 52190: 
 54106: Screen*
 54106: gfxXlibSurface::XScreen()
 54106: {
 54106:     return cairo_xlib_surface_get_screen(CairoSurface());
 54106: }
 54106: 
 52190: XRenderPictFormat*
 52190: gfxXlibSurface::XRenderFormat()
 52190: {
 52190:     return cairo_xlib_surface_get_xrender_format(CairoSurface());
 52190: }
 52190: 
118564: #if !defined(MOZ_PLATFORM_MAEMO)
 74902: GLXPixmap
 74902: gfxXlibSurface::GetGLXPixmap()
 74902: {
 74902:     if (!mGLXPixmap) {
120512: #ifdef DEBUG
120512:         // cairo_surface_has_show_text_glyphs is used solely for the
120512:         // side-effect of setting the error on surface if
120512:         // cairo_surface_finish() has been called.
120512:         cairo_surface_has_show_text_glyphs(CairoSurface());
120512:         NS_ASSERTION(CairoStatus() != CAIRO_STATUS_SURFACE_FINISHED,
120512:             "GetGLXPixmap called after surface finished");
120512: #endif
111402:         mGLXPixmap = gl::sDefGLXLib.CreatePixmap(this);
 74902:     }
 74902:     return mGLXPixmap;
 74902: }
 74909: #endif
 74902: 
 74887: gfxASurface::MemoryLocation
 74887: gfxXlibSurface::GetMemoryLocation() const
 74887: {
 74887:     return MEMORY_OUT_OF_PROCESS;
 74887: }
