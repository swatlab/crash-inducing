36268: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
36268: /* vim: set sw=2 ts=8 et tw=80 : */
36268: /* ***** BEGIN LICENSE BLOCK *****
36268:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
36268:  *
36268:  * The contents of this file are subject to the Mozilla Public License Version
36268:  * 1.1 (the "License"); you may not use this file except in compliance with
36268:  * the License. You may obtain a copy of the License at
36268:  * http://www.mozilla.org/MPL/
36268:  *
36268:  * Software distributed under the License is distributed on an "AS IS" basis,
36268:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
36268:  * for the specific language governing rights and limitations under the
36268:  * License.
36268:  *
36268:  * The Original Code is mozilla.org code.
36268:  *
36268:  * The Initial Developer of the Original Code is
63651:  * the Mozilla Foundation.
36268:  * Portions created by the Initial Developer are Copyright (C) 2009
36268:  * the Initial Developer. All Rights Reserved.
36268:  *
36268:  * Contributor(s):
36268:  *   Jason Duell <jduell.mcbugs@gmail.com>
49375:  *   Honza Bambas <honzab@firemni.cz>
36268:  *
36268:  * Alternatively, the contents of this file may be used under the terms of
36268:  * either the GNU General Public License Version 2 or later (the "GPL"), or
36268:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
36268:  * in which case the provisions of the GPL or the LGPL are applicable instead
36268:  * of those above. If you wish to allow use of your version of this file only
36268:  * under the terms of either the GPL or the LGPL, and not to allow others to
36268:  * use your version of this file under the terms of the MPL, indicate your
36268:  * decision by deleting the provisions above and replace them with the notice
36268:  * and other provisions required by the GPL or the LGPL. If you do not delete
36268:  * the provisions above, a recipient may use your version of this file under
36268:  * the terms of any one of the MPL, the GPL or the LGPL.
36268:  *
36268:  * ***** END LICENSE BLOCK ***** */
36268: 
36268: #include "mozilla/net/HttpChannelParent.h"
46908: #include "mozilla/dom/TabParent.h"
49375: #include "mozilla/net/NeckoParent.h"
58111: #include "mozilla/unused.h"
49375: #include "HttpChannelParentListener.h"
46672: #include "nsHttpChannel.h"
46790: #include "nsHttpHandler.h"
46672: #include "nsNetUtil.h"
46793: #include "nsISupportsPriority.h"
46837: #include "nsIAuthPromptProvider.h"
46837: #include "nsIDocShellTreeItem.h"
46889: #include "nsIBadCertListener2.h"
46915: #include "nsICacheEntryDescriptor.h"
50566: #include "nsSerializationHelper.h"
50566: #include "nsISerializable.h"
50566: #include "nsIAssociatedContentSecurity.h"
56242: #include "nsIApplicationCacheService.h"
56242: #include "nsIOfflineCacheUpdate.h"
58111: #include "nsIRedirectChannelRegistrar.h"
36268: 
36268: namespace mozilla {
36268: namespace net {
36268: 
47933: HttpChannelParent::HttpChannelParent(PBrowserParent* iframeEmbedding)
46850:   : mIPCClosed(false)
67800:   , mStoredStatus(0)
67800:   , mStoredProgress(0)
67800:   , mStoredProgressMax(0)
73028:   , mHeadersToSyncToChild(nsnull)
36268: {
46790:   // Ensure gHttpHandler is initialized: we need the atom table up and running.
46790:   nsIHttpProtocolHandler* handler;
46790:   CallGetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &handler);
46790:   NS_ASSERTION(handler, "no http handler");
46908: 
77547:   mTabParent = do_QueryObject(static_cast<TabParent*>(iframeEmbedding));
36268: }
36268: 
36268: HttpChannelParent::~HttpChannelParent()
36268: {
46808:   gHttpHandler->Release();
36268: }
36268: 
46850: void
46850: HttpChannelParent::ActorDestroy(ActorDestroyReason why)
46850: {
46850:   // We may still have refcount>0 if nsHttpChannel hasn't called OnStopRequest
77793:   // yet, but child process has crashed.  We must not try to send any more msgs
77793:   // to child, or IPDL will kill chrome process, too.
46850:   mIPCClosed = true;
46850: }
46850: 
36268: //-----------------------------------------------------------------------------
46672: // HttpChannelParent::nsISupports
46672: //-----------------------------------------------------------------------------
46672: 
73028: NS_IMPL_ISUPPORTS7(HttpChannelParent,
58111:                    nsIInterfaceRequestor,
58111:                    nsIProgressEventSink,
58111:                    nsIRequestObserver,
58111:                    nsIStreamListener,
58111:                    nsIParentChannel,
73028:                    nsIParentRedirectingChannel,
73028:                    nsIHttpHeaderVisitor)
58111: 
58111: //-----------------------------------------------------------------------------
58111: // HttpChannelParent::nsIInterfaceRequestor
58111: //-----------------------------------------------------------------------------
58111: 
58111: NS_IMETHODIMP
58111: HttpChannelParent::GetInterface(const nsIID& aIID, void **result)
58111: {
58111:   if (aIID.Equals(NS_GET_IID(nsIAuthPromptProvider)) ||
58111:       aIID.Equals(NS_GET_IID(nsISecureBrowserUI))) {
58111:     if (!mTabParent)
58111:       return NS_NOINTERFACE;
58111: 
58111:     return mTabParent->QueryInterface(aIID, result);
58111:   }
58111: 
58111:   return QueryInterface(aIID, result);
58111: }
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelParent::PHttpChannelParent
46672: //-----------------------------------------------------------------------------
46672: 
46672: bool 
46810: HttpChannelParent::RecvAsyncOpen(const IPC::URI&            aURI,
46810:                                  const IPC::URI&            aOriginalURI,
46810:                                  const IPC::URI&            aDocURI,
46810:                                  const IPC::URI&            aReferrerURI,
46755:                                  const PRUint32&            loadFlags,
46790:                                  const RequestHeaderTuples& requestHeaders,
78638:                                  const nsHttpAtom&          requestMethod,
56318:                                  const IPC::InputStream&    uploadStream,
79445:                                  const bool&              uploadStreamHasHeaders,
46793:                                  const PRUint16&            priority,
46790:                                  const PRUint8&             redirectionLimit,
79445:                                  const bool&              allowPipelining,
79445:                                  const bool&              forceAllowThirdPartyCookie,
49379:                                  const bool&                doResumeAt,
49379:                                  const PRUint64&            startPos,
56242:                                  const nsCString&           entityID,
56242:                                  const bool&                chooseApplicationCache,
84396:                                  const nsCString&           appCacheClientID)
36268: {
48842:   nsCOMPtr<nsIURI> uri(aURI);
48842:   nsCOMPtr<nsIURI> originalUri(aOriginalURI);
48842:   nsCOMPtr<nsIURI> docUri(aDocURI);
48842:   nsCOMPtr<nsIURI> referrerUri(aReferrerURI);
46810: 
46810:   nsCString uriSpec;
46810:   uri->GetSpec(uriSpec);
46810:   LOG(("HttpChannelParent RecvAsyncOpen [this=%x uri=%s]\n", 
46810:        this, uriSpec.get()));
46790: 
46672:   nsresult rv;
46672: 
46672:   nsCOMPtr<nsIIOService> ios(do_GetIOService(&rv));
46672:   if (NS_FAILED(rv))
71646:     return SendFailedAsyncOpen(rv);
46672: 
46834:   rv = NS_NewChannel(getter_AddRefs(mChannel), uri, ios, nsnull, nsnull, loadFlags);
46672:   if (NS_FAILED(rv))
71646:     return SendFailedAsyncOpen(rv);
46672: 
46834:   nsHttpChannel *httpChan = static_cast<nsHttpChannel *>(mChannel.get());
46790: 
49379:   if (doResumeAt)
49379:     httpChan->ResumeAt(startPos, entityID);
49379: 
46810:   if (originalUri)
46791:     httpChan->SetOriginalURI(originalUri);
46810:   if (docUri)
46791:     httpChan->SetDocumentURI(docUri);
46810:   if (referrerUri)
46791:     httpChan->SetReferrerInternal(referrerUri);
46672:   if (loadFlags != nsIRequest::LOAD_NORMAL)
46791:     httpChan->SetLoadFlags(loadFlags);
46672: 
46906:   for (PRUint32 i = 0; i < requestHeaders.Length(); i++) {
46755:     httpChan->SetRequestHeader(requestHeaders[i].mHeader,
46755:                                requestHeaders[i].mValue,
46755:                                requestHeaders[i].mMerge);
46906:   }
46755: 
58111:   nsRefPtr<HttpChannelParentListener> channelListener =
58111:       new HttpChannelParentListener(this);
49375: 
58111:   httpChan->SetNotificationCallbacks(channelListener);
46672: 
78638:   httpChan->SetRequestMethod(nsDependentCString(requestMethod.get()));
46887: 
56318:   nsCOMPtr<nsIInputStream> stream(uploadStream);
56318:   if (stream) {
46887:     httpChan->InternalSetUploadStream(stream);
56318:     httpChan->SetUploadStreamHasHeaders(uploadStreamHasHeaders);
46887:   }
46887: 
46793:   if (priority != nsISupportsPriority::PRIORITY_NORMAL)
46793:     httpChan->SetPriority(priority);
46790:   httpChan->SetRedirectionLimit(redirectionLimit);
46790:   httpChan->SetAllowPipelining(allowPipelining);
46791:   httpChan->SetForceAllowThirdPartyCookie(forceAllowThirdPartyCookie);
46790: 
56242:   nsCOMPtr<nsIApplicationCacheChannel> appCacheChan =
56242:     do_QueryInterface(mChannel);
56242:   nsCOMPtr<nsIApplicationCacheService> appCacheService =
56242:     do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID);
56242: 
79445:   bool setChooseApplicationCache = chooseApplicationCache;
56242:   if (appCacheChan && appCacheService) {
56242:     // We might potentially want to drop this flag (that is TRUE by default)
56242:     // after we succefully associate the channel with an application cache
56242:     // reported by the channel child.  Dropping it here may be too early.
80486:     appCacheChan->SetInheritApplicationCache(false);
56242:     if (!appCacheClientID.IsEmpty()) {
56242:       nsCOMPtr<nsIApplicationCache> appCache;
56242:       rv = appCacheService->GetApplicationCache(appCacheClientID,
56242:                                                 getter_AddRefs(appCache));
56242:       if (NS_SUCCEEDED(rv)) {
56242:         appCacheChan->SetApplicationCache(appCache);
80486:         setChooseApplicationCache = false;
56242:       }
56242:     }
56242: 
56242:     if (setChooseApplicationCache) {
56242:       nsCOMPtr<nsIOfflineCacheUpdateService> offlineUpdateService =
56242:         do_GetService("@mozilla.org/offlinecacheupdate-service;1", &rv);
56242:       if (NS_SUCCEEDED(rv)) {
56242:         rv = offlineUpdateService->OfflineAppAllowedForURI(uri,
56242:                                                            nsnull,
56242:                                                            &setChooseApplicationCache);
56242: 
56242:         if (setChooseApplicationCache && NS_SUCCEEDED(rv))
80486:           appCacheChan->SetChooseApplicationCache(true);
56242:       }
56242:     }
56242:   }
56242: 
58111:   rv = httpChan->AsyncOpen(channelListener, nsnull);
46672:   if (NS_FAILED(rv))
71646:     return SendFailedAsyncOpen(rv);
46672: 
36268:   return true;
36268: }
36268: 
46793: bool
58111: HttpChannelParent::RecvConnectChannel(const PRUint32& channelId)
58111: {
58111:   nsresult rv;
58111: 
58111:   LOG(("Looking for a registered channel [this=%p, id=%d]", this, channelId));
58111:   rv = NS_LinkRedirectChannels(channelId, this, getter_AddRefs(mChannel));
58111:   LOG(("  found channel %p, rv=%08x", mChannel.get(), rv));
58111: 
58111:   return true;
58111: }
58111: 
58111: bool 
46793: HttpChannelParent::RecvSetPriority(const PRUint16& priority)
46793: {
71646:   if (mChannel) {
46835:     nsHttpChannel *httpChan = static_cast<nsHttpChannel *>(mChannel.get());
46835:     httpChan->SetPriority(priority);
71646:   }
55162: 
58111:   nsCOMPtr<nsISupportsPriority> priorityRedirectChannel =
58111:       do_QueryInterface(mRedirectChannel);
58111:   if (priorityRedirectChannel)
58111:     priorityRedirectChannel->SetPriority(priority);
55162: 
46793:   return true;
46793: }
46672: 
46915: bool
49379: HttpChannelParent::RecvSuspend()
49379: {
71646:   if (mChannel) {
49379:     mChannel->Suspend();
71646:   }
49379:   return true;
49379: }
49379: 
49379: bool
49379: HttpChannelParent::RecvResume()
49379: {
71646:   if (mChannel) {
49379:     mChannel->Resume();
71646:   }
49379:   return true;
49379: }
49379: 
49379: bool
50561: HttpChannelParent::RecvCancel(const nsresult& status)
50561: {
50561:   // May receive cancel before channel has been constructed!
50561:   if (mChannel) {
50561:     nsHttpChannel *httpChan = static_cast<nsHttpChannel *>(mChannel.get());
50561:     httpChan->Cancel(status);
50561:   }
50561:   return true;
50561: }
50561: 
50561: 
50561: bool
46915: HttpChannelParent::RecvSetCacheTokenCachedCharset(const nsCString& charset)
46915: {
61190:   if (mCacheDescriptor)
71901:     mCacheDescriptor->SetMetaDataElement("charset", charset.get());
46915:   return true;
46915: }
46915: 
49375: bool
50566: HttpChannelParent::RecvUpdateAssociatedContentSecurity(const PRInt32& high,
50566:                                                        const PRInt32& low,
50566:                                                        const PRInt32& broken,
50566:                                                        const PRInt32& no)
50566: {
77793:   if (mAssociatedContentSecurity) {
77793:     mAssociatedContentSecurity->SetCountSubRequestsHighSecurity(high);
77793:     mAssociatedContentSecurity->SetCountSubRequestsLowSecurity(low);
77793:     mAssociatedContentSecurity->SetCountSubRequestsBrokenSecurity(broken);
77793:     mAssociatedContentSecurity->SetCountSubRequestsNoSecurity(no);
77793:   }
50566:   return true;
50566: }
50566: 
50566: bool
55241: HttpChannelParent::RecvRedirect2Verify(const nsresult& result, 
49375:                                        const RequestHeaderTuples& changedHeaders)
49375: {
58111:   if (NS_SUCCEEDED(result)) {
58111:     nsCOMPtr<nsIHttpChannel> newHttpChannel =
58111:         do_QueryInterface(mRedirectChannel);
58111: 
58111:     if (newHttpChannel) {
58111:       for (PRUint32 i = 0; i < changedHeaders.Length(); i++) {
58111:         newHttpChannel->SetRequestHeader(changedHeaders[i].mHeader,
58111:                                          changedHeaders[i].mValue,
58111:                                          changedHeaders[i].mMerge);
58111:       }
58111:     }
58111:   }
58111: 
58111:   mRedirectCallback->OnRedirectVerifyCallback(result);
58111:   mRedirectCallback = nsnull;
49375:   return true;
49375: }
49375: 
50758: bool
50758: HttpChannelParent::RecvDocumentChannelCleanup()
50758: {
77793:   // From now on only using mAssociatedContentSecurity.  Free everything else.
77793:   mChannel = 0;          // Reclaim some memory sooner.
77793:   mCacheDescriptor = 0;  // Else we'll block other channels reading same URI
50758:   return true;
50758: }
50758: 
56242: bool 
56242: HttpChannelParent::RecvMarkOfflineCacheEntryAsForeign()
56242: {
56242:   nsHttpChannel *httpChan = static_cast<nsHttpChannel *>(mChannel.get());
56242:   httpChan->MarkOfflineCacheEntryAsForeign();
56242:   return true;
56242: }
56242: 
46672: //-----------------------------------------------------------------------------
58111: // HttpChannelParent::nsIRequestObserver
46672: //-----------------------------------------------------------------------------
46672: 
58111: NS_IMETHODIMP
46672: HttpChannelParent::OnStartRequest(nsIRequest *aRequest, nsISupports *aContext)
46672: {
46672:   LOG(("HttpChannelParent::OnStartRequest [this=%x]\n", this));
46672: 
46755:   nsHttpChannel *chan = static_cast<nsHttpChannel *>(aRequest);
46755:   nsHttpResponseHead *responseHead = chan->GetResponseHead();
54894:   nsHttpRequestHead  *requestHead = chan->GetRequestHead();
79445:   bool isFromCache = false;
46915:   chan->IsFromCache(&isFromCache);
50566:   PRUint32 expirationTime = nsICache::NO_EXPIRATION_TIME;
46915:   chan->GetCacheTokenExpirationTime(&expirationTime);
46915:   nsCString cachedCharset;
46915:   chan->GetCacheTokenCachedCharset(cachedCharset);
46915: 
79445:   bool loadedFromApplicationCache;
56242:   chan->GetLoadedFromApplicationCache(&loadedFromApplicationCache);
56242:   if (loadedFromApplicationCache) {
56242:     nsCOMPtr<nsIApplicationCache> appCache;
56242:     chan->GetApplicationCache(getter_AddRefs(appCache));
56242:     nsCString appCacheGroupId;
56242:     nsCString appCacheClientId;
56242:     appCache->GetGroupID(appCacheGroupId);
56242:     appCache->GetClientID(appCacheClientId);
56242:     if (mIPCClosed || 
56242:         !SendAssociateApplicationCache(appCacheGroupId, appCacheClientId))
56242:     {
56242:       return NS_ERROR_UNEXPECTED;
56242:     }
56242:   }
56242: 
53990:   nsCOMPtr<nsIEncodedChannel> encodedChannel = do_QueryInterface(aRequest);
53990:   if (encodedChannel)
80486:     encodedChannel->SetApplyConversion(false);
53990: 
61190:   // Keep the cache entry for future use in RecvSetCacheTokenCachedCharset().
61190:   // It could be already released by nsHttpChannel at that time.
61190:   chan->GetCacheToken(getter_AddRefs(mCacheDescriptor));
46915: 
50566:   nsCString secInfoSerialization;
50566:   nsCOMPtr<nsISupports> secInfoSupp;
50566:   chan->GetSecurityInfo(getter_AddRefs(secInfoSupp));
50566:   if (secInfoSupp) {
77793:     mAssociatedContentSecurity = do_QueryInterface(secInfoSupp);
50566:     nsCOMPtr<nsISerializable> secInfoSer = do_QueryInterface(secInfoSupp);
50566:     if (secInfoSer)
50566:       NS_SerializeToString(secInfoSer, secInfoSerialization);
50566:   }
50566: 
73028:   // sync request headers to child, in case they've changed
54894:   RequestHeaderTuples headers;
73028:   mHeadersToSyncToChild = &headers;
73028:   requestHead->Headers().VisitHeaders(this);
73028:   mHeadersToSyncToChild = 0;
54894: 
69351:   nsHttpChannel *httpChan = static_cast<nsHttpChannel *>(mChannel.get());
46915:   if (mIPCClosed || 
46915:       !SendOnStartRequest(responseHead ? *responseHead : nsHttpResponseHead(), 
54894:                           !!responseHead,
54894:                           headers,
54894:                           isFromCache,
80486:                           mCacheDescriptor ? true : false,
69351:                           expirationTime, cachedCharset, secInfoSerialization,
69351:                           httpChan->GetSelfAddr(), httpChan->GetPeerAddr())) 
50566:   {
46672:     return NS_ERROR_UNEXPECTED; 
46911:   }
46672:   return NS_OK;
46672: }
46672: 
58111: NS_IMETHODIMP
46672: HttpChannelParent::OnStopRequest(nsIRequest *aRequest, 
46672:                                  nsISupports *aContext, 
46672:                                  nsresult aStatusCode)
46672: {
46672:   LOG(("HttpChannelParent::OnStopRequest: [this=%x status=%ul]\n", 
46672:        this, aStatusCode));
46672: 
46850:   if (mIPCClosed || !SendOnStopRequest(aStatusCode))
46672:     return NS_ERROR_UNEXPECTED; 
46672:   return NS_OK;
46672: }
46672: 
58111: //-----------------------------------------------------------------------------
58111: // HttpChannelParent::nsIStreamListener
58111: //-----------------------------------------------------------------------------
58111: 
58111: NS_IMETHODIMP
46672: HttpChannelParent::OnDataAvailable(nsIRequest *aRequest, 
46672:                                    nsISupports *aContext, 
46672:                                    nsIInputStream *aInputStream, 
46672:                                    PRUint32 aOffset, 
46672:                                    PRUint32 aCount)
46672: {
46672:   LOG(("HttpChannelParent::OnDataAvailable [this=%x]\n", this));
46672: 
50562:   nsCString data;
50562:   nsresult rv = NS_ReadInputStreamToString(aInputStream, data, aCount);
50562:   if (NS_FAILED(rv))
50562:     return rv;
50562: 
67800:   // OnDataAvailable is always preceded by OnStatus/OnProgress calls that set
67800:   // mStoredStatus/mStoredProgress(Max) to appropriate values, unless
67800:   // LOAD_BACKGROUND set.  In that case, they'll have garbage values, but
67800:   // child doesn't use them.
67800:   if (mIPCClosed || !SendOnTransportAndData(mStoredStatus, mStoredProgress,
67800:                                             mStoredProgressMax, data, aOffset,
67800:                                             aCount)) {
50561:     return NS_ERROR_UNEXPECTED;
67800:   }
46672:   return NS_OK;
46672: }
46672: 
46672: //-----------------------------------------------------------------------------
46851: // HttpChannelParent::nsIProgressEventSink
46851: //-----------------------------------------------------------------------------
46851: 
46851: NS_IMETHODIMP
46851: HttpChannelParent::OnProgress(nsIRequest *aRequest, 
46851:                               nsISupports *aContext, 
46851:                               PRUint64 aProgress, 
46851:                               PRUint64 aProgressMax)
46851: {
67800:   // OnStatus has always just set mStoredStatus. If it indicates this precedes
67800:   // OnDataAvailable, store and ODA will send to child.
67800:   if (mStoredStatus == nsISocketTransport::STATUS_RECEIVING_FROM ||
67800:       mStoredStatus == nsITransport::STATUS_READING)
67800:   {
67800:     mStoredProgress = aProgress;
67800:     mStoredProgressMax = aProgressMax;
67800:   } else {
67800:     // Send to child now.  The only case I've observed that this handles (i.e.
67800:     // non-ODA status with progress > 0) is data upload progress notification
67800:     // (status == nsISocketTransport::STATUS_SENDING_TO)
46851:     if (mIPCClosed || !SendOnProgress(aProgress, aProgressMax))
46851:       return NS_ERROR_UNEXPECTED;
67800:   }
67800: 
46851:   return NS_OK;
46851: }
46851: 
46851: NS_IMETHODIMP
46851: HttpChannelParent::OnStatus(nsIRequest *aRequest, 
46851:                             nsISupports *aContext, 
46851:                             nsresult aStatus, 
46851:                             const PRUnichar *aStatusArg)
46851: {
67800:   // If this precedes OnDataAvailable, store and ODA will send to child.
67800:   if (aStatus == nsISocketTransport::STATUS_RECEIVING_FROM ||
67800:       aStatus == nsITransport::STATUS_READING)
67800:   {
67800:     mStoredStatus = aStatus;
67800:     return NS_OK;
67800:   }
67800:   // Otherwise, send to child now
67800:   if (mIPCClosed || !SendOnStatus(aStatus))
46851:     return NS_ERROR_UNEXPECTED;
46851:   return NS_OK;
46851: }
46851: 
58111: //-----------------------------------------------------------------------------
58111: // HttpChannelParent::nsIParentChannel
58111: //-----------------------------------------------------------------------------
58111: 
58111: NS_IMETHODIMP
58111: HttpChannelParent::Delete()
58111: {
58111:   if (!mIPCClosed)
63651:     unused << SendDeleteSelf();
58111: 
58111:   return NS_OK;
58111: }
58111: 
58111: //-----------------------------------------------------------------------------
58111: // HttpChannelParent::nsIParentRedirectingChannel
58111: //-----------------------------------------------------------------------------
58111: 
58111: NS_IMETHODIMP
58111: HttpChannelParent::StartRedirect(PRUint32 newChannelId,
58111:                                  nsIChannel* newChannel,
58111:                                  PRUint32 redirectFlags,
58111:                                  nsIAsyncVerifyRedirectCallback* callback)
58111: {
58111:   if (mIPCClosed)
58111:     return NS_BINDING_ABORTED;
58111: 
58111:   nsCOMPtr<nsIURI> newURI;
58111:   newChannel->GetURI(getter_AddRefs(newURI));
58111: 
58111:   nsHttpChannel *httpChan = static_cast<nsHttpChannel *>(mChannel.get());
58111:   nsHttpResponseHead *responseHead = httpChan->GetResponseHead();
58111:   bool result = SendRedirect1Begin(newChannelId,
58111:                                    IPC::URI(newURI),
58111:                                    redirectFlags,
58111:                                    responseHead ? *responseHead
58111:                                                 : nsHttpResponseHead());
58111:   if (!result)
58111:     return NS_BINDING_ABORTED;
58111: 
58111:   // Result is handled in RecvRedirect2Verify above
58111: 
58111:   mRedirectChannel = newChannel;
58111:   mRedirectCallback = callback;
58111:   return NS_OK;
58111: }
58111: 
58111: NS_IMETHODIMP
79445: HttpChannelParent::CompleteRedirect(bool succeeded)
58111: {
58111:   if (succeeded && !mIPCClosed) {
58111:     // TODO: check return value: assume child dead if failed
58111:     unused << SendRedirect3Complete();
58111:   }
58111: 
58111:   mRedirectChannel = nsnull;
58111:   return NS_OK;
58111: }
58111: 
73028: //-----------------------------------------------------------------------------
73028: // HttpChannelParent::nsIHttpHeaderVisitor
73028: //-----------------------------------------------------------------------------
73028: 
73028: nsresult
73028: HttpChannelParent::VisitHeader(const nsACString &header, const nsACString &value)
73028: {
73028:   // Will be set unless some random code QI's us to nsIHttpHeaderVisitor
73028:   NS_ENSURE_STATE(mHeadersToSyncToChild);
73028: 
73028:   RequestHeaderTuple* tuple = mHeadersToSyncToChild->AppendElement();
73028:   tuple->mHeader = header;
73028:   tuple->mValue  = value;
73028:   tuple->mMerge  = false;  // headers already merged:
73028:   return NS_OK;
73028: }
73028: 
36268: }} // mozilla::net
