130924: # This Source Code Form is subject to the terms of the Mozilla Public
130924: # License, v. 2.0. If a copy of the MPL was not distributed with this
130924: # file, You can obtain one at http://mozilla.org/MPL/2.0/.
130924: 
130924: from __future__ import unicode_literals
130924: 
166496: import json
130924: import os
162878: import unittest
130924: 
154196: from mozpack.manifests import (
154196:     InstallManifest,
154196: )
130924: from mozunit import main
130924: 
162878: from mozbuild.backend.recursivemake import (
162878:     RecursiveMakeBackend,
162878:     RecursiveMakeTraversal,
162878: )
130924: from mozbuild.frontend.emitter import TreeMetadataEmitter
130924: from mozbuild.frontend.reader import BuildReader
130924: 
130924: from mozbuild.test.backend.common import BackendTester
130924: 
130924: 
162878: class TestRecursiveMakeTraversal(unittest.TestCase):
162878:     def test_traversal(self):
162878:         traversal = RecursiveMakeTraversal()
162878:         traversal.add('', dirs=['A', 'B', 'C'])
162878:         traversal.add('', dirs=['D'])
162878:         traversal.add('A')
162878:         traversal.add('B', dirs=['E', 'F'])
162878:         traversal.add('C', parallel=['G', 'H'])
162878:         traversal.add('D', parallel=['I'], dirs=['K'])
162878:         traversal.add('D', parallel=['J'], dirs=['L'])
162878:         traversal.add('E')
162878:         traversal.add('F')
162878:         traversal.add('G')
162878:         traversal.add('H')
162878:         traversal.add('I', dirs=['M', 'N'])
162878:         traversal.add('J', parallel=['O', 'P'])
162878:         traversal.add('K', parallel=['Q', 'R'])
162878:         traversal.add('L', dirs=['S'])
162878:         traversal.add('M')
162878:         traversal.add('N', dirs=['T'])
162878:         traversal.add('O')
162878:         traversal.add('P', parallel=['U'])
162878:         traversal.add('Q')
162878:         traversal.add('R', dirs=['V'])
162878:         traversal.add('S', dirs=['W'])
162878:         traversal.add('T')
162878:         traversal.add('U')
162878:         traversal.add('V')
162878:         traversal.add('W', dirs=['X'])
162878:         traversal.add('X')
162878: 
162878:         start, deps = traversal.compute_dependencies()
162878:         self.assertEqual(start, ('X',))
162878:         self.assertEqual(deps, {
162878:             'A': ('',),
162878:             'B': ('A',),
162878:             'C': ('F',),
162878:             'D': ('G', 'H'),
162878:             'E': ('B',),
162878:             'F': ('E',),
162878:             'G': ('C',),
162878:             'H': ('C',),
162878:             'I': ('D',),
162878:             'J': ('D',),
162878:             'K': ('T', 'O', 'U'),
162878:             'L': ('Q', 'V'),
162878:             'M': ('I',),
162878:             'N': ('M',),
162878:             'O': ('J',),
162878:             'P': ('J',),
162878:             'Q': ('K',),
162878:             'R': ('K',),
162878:             'S': ('L',),
162878:             'T': ('N',),
162878:             'U': ('P',),
162878:             'V': ('R',),
162878:             'W': ('S',),
162878:             'X': ('W',),
162878:         })
162878: 
162878:         self.assertEqual(list(traversal.traverse('')),
162878:                          ['', 'A', 'B', 'E', 'F', 'C', 'G', 'H', 'D', 'I',
162878:                          'M', 'N', 'T', 'J', 'O', 'P', 'U', 'K', 'Q', 'R',
162878:                          'V', 'L', 'S', 'W', 'X'])
162878: 
162878:         self.assertEqual(list(traversal.traverse('C')),
162878:                          ['C', 'G', 'H'])
162878: 
162878:     def test_traversal_2(self):
162878:         traversal = RecursiveMakeTraversal()
162878:         traversal.add('', dirs=['A', 'B', 'C'])
162878:         traversal.add('A')
162878:         traversal.add('B', static=['D'], dirs=['E', 'F'])
162878:         traversal.add('C', parallel=['G', 'H'], dirs=['I'])
162878:         # Don't register D
162878:         traversal.add('E')
162878:         traversal.add('F')
162878:         traversal.add('G')
162878:         traversal.add('H')
162878:         traversal.add('I')
162878: 
162878:         start, deps = traversal.compute_dependencies()
162878:         self.assertEqual(start, ('I',))
162878:         self.assertEqual(deps, {
162878:             'A': ('',),
162878:             'B': ('A',),
162878:             'C': ('F',),
162878:             'D': ('B',),
162878:             'E': ('D',),
162878:             'F': ('E',),
162878:             'G': ('C',),
162878:             'H': ('C',),
162878:             'I': ('G', 'H'),
162878:         })
162878: 
162878:     def test_traversal_filter(self):
162878:         traversal = RecursiveMakeTraversal()
162878:         traversal.add('', dirs=['A', 'B', 'C'])
162878:         traversal.add('A')
162878:         traversal.add('B', static=['D'], dirs=['E', 'F'])
162878:         traversal.add('C', parallel=['G', 'H'], dirs=['I'])
162878:         traversal.add('D')
162878:         traversal.add('E')
162878:         traversal.add('F')
162878:         traversal.add('G')
162878:         traversal.add('H')
162878:         traversal.add('I')
162878: 
162878:         def filter(current, subdirs):
162878:             if current == 'B':
162878:                 current = None
162878:             return current, subdirs.parallel, subdirs.dirs
162878: 
162878:         start, deps = traversal.compute_dependencies(filter)
162878:         self.assertEqual(start, ('I',))
162878:         self.assertEqual(deps, {
162878:             'A': ('',),
162878:             'C': ('F',),
162878:             'E': ('A',),
162878:             'F': ('E',),
162878:             'G': ('C',),
162878:             'H': ('C',),
162878:             'I': ('G', 'H'),
162878:         })
162878: 
130924: class TestRecursiveMakeBackend(BackendTester):
130924:     def test_basic(self):
130924:         """Ensure the RecursiveMakeBackend works without error."""
130924:         env = self._consume('stub0', RecursiveMakeBackend)
130925:         self.assertTrue(os.path.exists(os.path.join(env.topobjdir,
168107:             'backend.RecursiveMakeBackend')))
144630:         self.assertTrue(os.path.exists(os.path.join(env.topobjdir,
168107:             'backend.RecursiveMakeBackend.pp')))
130924: 
130924:     def test_output_files(self):
130924:         """Ensure proper files are generated."""
130924:         env = self._consume('stub0', RecursiveMakeBackend)
130924: 
130924:         expected = ['', 'dir1', 'dir2']
130924: 
130924:         for d in expected:
130924:             out_makefile = os.path.join(env.topobjdir, d, 'Makefile')
130924:             out_backend = os.path.join(env.topobjdir, d, 'backend.mk')
130924: 
130924:             self.assertTrue(os.path.exists(out_makefile))
130924:             self.assertTrue(os.path.exists(out_backend))
130924: 
130924:     def test_makefile_conversion(self):
130924:         """Ensure Makefile.in is converted properly."""
130924:         env = self._consume('stub0', RecursiveMakeBackend)
130924: 
130924:         p = os.path.join(env.topobjdir, 'Makefile')
130924: 
159435:         lines = [l.strip() for l in open(p, 'rt').readlines()[1:] if not l.startswith('#')]
130924:         self.assertEqual(lines, [
130924:             'DEPTH := .',
130924:             'topsrcdir := %s' % env.topsrcdir,
130924:             'srcdir := %s' % env.topsrcdir,
159435:             'VPATH := %s' % env.topsrcdir,
159435:             'relativesrcdir := .',
130924:             'include $(DEPTH)/config/autoconf.mk',
130924:             '',
159435:             'FOO := foo',
159435:             '',
159546:             'include $(topsrcdir)/config/recurse.mk',
130924:         ])
130924: 
136385:     def test_missing_makefile_in(self):
136385:         """Ensure missing Makefile.in results in Makefile creation."""
136385:         env = self._consume('stub0', RecursiveMakeBackend)
136385: 
136385:         p = os.path.join(env.topobjdir, 'dir2', 'Makefile')
136385:         self.assertTrue(os.path.exists(p))
136385: 
136385:         lines = [l.strip() for l in open(p, 'rt').readlines()]
159546:         self.assertEqual(len(lines), 9)
136385: 
136385:         self.assertTrue(lines[0].startswith('# THIS FILE WAS AUTOMATICALLY'))
136385: 
130924:     def test_backend_mk(self):
130924:         """Ensure backend.mk file is written out properly."""
130924:         env = self._consume('stub0', RecursiveMakeBackend)
130924: 
130924:         p = os.path.join(env.topobjdir, 'backend.mk')
130924: 
144630:         lines = [l.strip() for l in open(p, 'rt').readlines()[2:]]
130924:         self.assertEqual(lines, [
134431:             'MOZBUILD_DERIVED := 1',
130924:             'DIRS := dir1',
130924:             'PARALLEL_DIRS := dir2',
130924:             'TEST_DIRS := dir3',
130924:         ])
130924: 
134431:     def test_mtime_no_change(self):
130924:         """Ensure mtime is not updated if file content does not change."""
130924: 
130924:         env = self._consume('stub0', RecursiveMakeBackend)
130924: 
130924:         makefile_path = os.path.join(env.topobjdir, 'Makefile')
130924:         backend_path = os.path.join(env.topobjdir, 'backend.mk')
130924:         makefile_mtime = os.path.getmtime(makefile_path)
130924:         backend_mtime = os.path.getmtime(backend_path)
130924: 
130924:         reader = BuildReader(env)
130924:         emitter = TreeMetadataEmitter(env)
130924:         backend = RecursiveMakeBackend(env)
130924:         backend.consume(emitter.emit(reader.read_topsrcdir()))
130924: 
130924:         self.assertEqual(os.path.getmtime(makefile_path), makefile_mtime)
130924:         self.assertEqual(os.path.getmtime(backend_path), backend_mtime)
130924: 
130926:     def test_external_make_dirs(self):
130926:         """Ensure we have make recursion into external make directories."""
130926:         env = self._consume('external_make_dirs', RecursiveMakeBackend)
130926: 
130926:         backend_path = os.path.join(env.topobjdir, 'backend.mk')
144630:         lines = [l.strip() for l in open(backend_path, 'rt').readlines()[2:]]
130926:         self.assertEqual(lines, [
134431:             'MOZBUILD_DERIVED := 1',
130926:             'DIRS := dir',
130926:             'PARALLEL_DIRS := p_dir',
130926:             'DIRS += external',
130926:             'PARALLEL_DIRS += p_external',
130926:         ])
130924: 
130928:     def test_substitute_config_files(self):
130928:         """Ensure substituted config files are produced."""
130928:         env = self._consume('substitute_config_files', RecursiveMakeBackend)
130928: 
130928:         p = os.path.join(env.topobjdir, 'foo')
130928:         self.assertTrue(os.path.exists(p))
130928:         lines = [l.strip() for l in open(p, 'rt').readlines()]
130928:         self.assertEqual(lines, [
130928:             'TEST = foo',
130928:         ])
130928: 
135843:     def test_variable_passthru(self):
135843:         """Ensure variable passthru is written out correctly."""
135843:         env = self._consume('variable_passthru', RecursiveMakeBackend)
135843: 
135843:         backend_path = os.path.join(env.topobjdir, 'backend.mk')
144630:         lines = [l.strip() for l in open(backend_path, 'rt').readlines()[2:]]
144360: 
144360:         expected = {
144534:             'ASFILES': [
144534:                 'ASFILES += bar.s',
144534:                 'ASFILES += foo.asm',
144534:             ],
146489:             'CMMSRCS': [
146489:                 'CMMSRCS += bar.mm',
146489:                 'CMMSRCS += foo.mm',
146489:             ],
152816:             'CPP_UNIT_TESTS': [
152816:                 'CPP_UNIT_TESTS += foo.cpp',
152816:             ],
145045:             'CSRCS': [
145045:                 'CSRCS += bar.c',
145045:                 'CSRCS += foo.c',
145045:             ],
146594:             'EXTRA_COMPONENTS': [
146594:                 'EXTRA_COMPONENTS += bar.js',
146594:                 'EXTRA_COMPONENTS += foo.js',
146594:             ],
147184:             'EXTRA_PP_COMPONENTS': [
147184:                 'EXTRA_PP_COMPONENTS += bar.pp.js',
147184:                 'EXTRA_PP_COMPONENTS += foo.pp.js',
147184:             ],
154109:             'EXTRA_JS_MODULES': [
154109:                 'EXTRA_JS_MODULES += bar.jsm',
154109:                 'EXTRA_JS_MODULES += foo.jsm',
154109:             ],
154109:             'EXTRA_PP_JS_MODULES': [
154109:                 'EXTRA_PP_JS_MODULES += bar.pp.jsm',
154109:                 'EXTRA_PP_JS_MODULES += foo.pp.jsm',
154109:             ],
157586:             'FAIL_ON_WARNINGS': [
157586:                 'FAIL_ON_WARNINGS := 1',
157586:             ],
150483:             'HOST_CPPSRCS': [
150483:                 'HOST_CPPSRCS += bar.cpp',
150483:                 'HOST_CPPSRCS += foo.cpp',
150483:             ],
146649:             'HOST_CSRCS': [
146649:                 'HOST_CSRCS += bar.c',
146649:                 'HOST_CSRCS += foo.c',
146649:             ],
146778:             'HOST_LIBRARY_NAME': [
146778:                 'HOST_LIBRARY_NAME := host_bar',
146778:             ],
157591:             'LIBXUL_LIBRARY': [
157591:                 'LIBXUL_LIBRARY := 1',
157591:             ],
157599:             'MSVC_ENABLE_PGO': [
157599:                 'MSVC_ENABLE_PGO := 1',
157599:             ],
160549:             'OS_LIBS': [
160549:                 'OS_LIBS += foo.so',
160549:                 'OS_LIBS += -l123',
160549:                 'OS_LIBS += bar.a',
160549:             ],
147832:             'SDK_LIBRARY': [
147832:                 'SDK_LIBRARY += bar.sdk',
147832:                 'SDK_LIBRARY += foo.sdk',
147832:             ],
146870:             'SSRCS': [
166801:                 'SSRCS += baz.S',
146870:                 'SSRCS += foo.S',
146870:             ],
168055:             'VISIBILITY_FLAGS': [
168055:                 'VISIBILITY_FLAGS :=',
168055:             ],
144360:         }
144360: 
144360:         for var, val in expected.items():
144360:             # print("test_variable_passthru[%s]" % (var))
144360:             found = [str for str in lines if str.startswith(var)]
144360:             self.assertEqual(found, val)
135843: 
139977:     def test_exports(self):
159381:         """Ensure EXPORTS is handled properly."""
139977:         env = self._consume('exports', RecursiveMakeBackend)
139977: 
159381:         # EXPORTS files should appear in the dist_include install manifest.
159381:         m = InstallManifest(path=os.path.join(env.topobjdir,
159381:             '_build_manifests', 'install', 'dist_include'))
159381:         self.assertEqual(len(m), 7)
159381:         self.assertIn('foo.h', m)
159381:         self.assertIn('mozilla/mozilla1.h', m)
159381:         self.assertIn('mozilla/dom/dom2.h', m)
150022: 
163244:     def test_test_manifests_files_written(self):
163244:         """Ensure test manifests get turned into files."""
163244:         env = self._consume('test-manifests-written', RecursiveMakeBackend)
142045: 
163244:         tests_dir = os.path.join(env.topobjdir, '_tests')
163244:         m_master = os.path.join(tests_dir, 'testing', 'mochitest', 'tests', 'mochitest.ini')
163244:         x_master = os.path.join(tests_dir, 'xpcshell', 'xpcshell.ini')
163244:         self.assertTrue(os.path.exists(m_master))
163244:         self.assertTrue(os.path.exists(x_master))
142045: 
163244:         lines = [l.strip() for l in open(x_master, 'rt').readlines()]
163244:         self.assertEqual(lines, [
163244:             '; THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT MODIFY BY HAND.',
163244:             '',
163244:             '[include:dir1/xpcshell.ini]',
163244:             '[include:xpcshell.ini]',
163244:         ])
130928: 
166496:         all_tests_path = os.path.join(env.topobjdir, 'all-tests.json')
166496:         self.assertTrue(os.path.exists(all_tests_path))
166496: 
166496:         with open(all_tests_path, 'rt') as fh:
166496:             o = json.load(fh)
166496: 
166496:             self.assertIn('xpcshell.js', o)
166496:             self.assertIn('dir1/test_bar.js', o)
166496: 
166496:             self.assertEqual(len(o['xpcshell.js']), 1)
166496: 
156517:     def test_xpidl_generation(self):
156517:         """Ensure xpidl files and directories are written out."""
156517:         env = self._consume('xpidl', RecursiveMakeBackend)
156517: 
162784:         # Install manifests should contain entries.
156517:         install_dir = os.path.join(env.topobjdir, '_build_manifests',
156517:             'install')
156517:         self.assertTrue(os.path.isfile(os.path.join(install_dir, 'dist_idl')))
162784:         self.assertTrue(os.path.isfile(os.path.join(install_dir, 'xpidl')))
156517: 
156517:         m = InstallManifest(path=os.path.join(install_dir, 'dist_idl'))
156517:         self.assertEqual(len(m), 2)
156517:         self.assertIn('bar.idl', m)
156517:         self.assertIn('foo.idl', m)
156517: 
162784:         m = InstallManifest(path=os.path.join(install_dir, 'xpidl'))
162784:         self.assertIn('.deps/my_module.pp', m)
162784:         self.assertIn('xpt/my_module.xpt', m)
162784: 
159381:         m = InstallManifest(path=os.path.join(install_dir, 'dist_include'))
159381:         self.assertIn('foo.h', m)
156517: 
156517:         p = os.path.join(env.topobjdir, 'config/makefiles/xpidl')
156517:         self.assertTrue(os.path.isdir(p))
156517: 
156517:         self.assertTrue(os.path.isfile(os.path.join(p, 'Makefile')))
156517: 
162784:     def test_old_install_manifest_deleted(self):
162784:         # Simulate an install manifest from a previous backend version. Ensure
162784:         # it is deleted.
150021:         env = self._get_environment('stub0')
162784:         purge_dir = os.path.join(env.topobjdir, '_build_manifests', 'install')
150021:         manifest_path = os.path.join(purge_dir, 'old_manifest')
150021:         os.makedirs(purge_dir)
162784:         m = InstallManifest()
152884:         m.write(path=manifest_path)
150021: 
150021:         self.assertTrue(os.path.exists(manifest_path))
150021:         self._consume('stub0', RecursiveMakeBackend, env)
150021:         self.assertFalse(os.path.exists(manifest_path))
150021: 
154196:     def test_install_manifests_written(self):
154196:         env, objs = self._emit('stub0')
154196:         backend = RecursiveMakeBackend(env)
154196: 
154196:         m = InstallManifest()
154196:         backend._install_manifests['testing'] = m
154196:         m.add_symlink(__file__, 'self')
154196:         backend.consume(objs)
154196: 
154196:         man_dir = os.path.join(env.topobjdir, '_build_manifests', 'install')
154196:         self.assertTrue(os.path.isdir(man_dir))
154196: 
154196:         expected = ['testing']
154196:         for e in expected:
154196:             full = os.path.join(man_dir, e)
154196:             self.assertTrue(os.path.exists(full))
154196: 
154196:             m2 = InstallManifest(path=full)
154196:             self.assertEqual(m, m2)
154196: 
150550:     def test_ipdl_sources(self):
150550:         """Test that IPDL_SOURCES are written to ipdlsrcs.mk correctly."""
150550:         env = self._consume('ipdl_sources', RecursiveMakeBackend)
150550: 
150550:         manifest_path = os.path.join(env.topobjdir,
150550:             'ipc', 'ipdl', 'ipdlsrcs.mk')
150550:         lines = [l.strip() for l in open(manifest_path, 'rt').readlines()]
150550: 
150550:         # Handle Windows paths correctly
150550:         topsrcdir = env.topsrcdir.replace(os.sep, '/')
150550: 
150550:         expected = [
163583:             "ALL_IPDLSRCS := %s/bar/bar.ipdl %s/bar/bar2.ipdlh %s/foo/foo.ipdl %s/foo/foo2.ipdlh" % tuple([topsrcdir] * 4),
164302:             "CPPSRCS := UnifiedProtocols0.cpp",
150550:             "IPDLDIRS := %s/bar %s/foo" % (topsrcdir, topsrcdir),
150550:         ]
164301: 
164301:         found = [str for str in lines if str.startswith(('ALL_IPDLSRCS',
164301:                                                          'CPPSRCS',
164301:                                                          'IPDLDIRS'))]
164301:         self.assertEqual(found, expected)
150021: 
162726:     def test_defines(self):
162726:         """Test that DEFINES are written to backend.mk correctly."""
162726:         env = self._consume('defines', RecursiveMakeBackend)
162726: 
162726:         backend_path = os.path.join(env.topobjdir, 'backend.mk')
162726:         lines = [l.strip() for l in open(backend_path, 'rt').readlines()[2:]]
162726: 
162726:         var = 'DEFINES'
162726:         defines = [val for val in lines if val.startswith(var)]
162726: 
173524:         expected = ['DEFINES += -DFOO -DBAZ=\'"ab\'\\\'\'cd"\' -DBAR=7 -DVALUE=\'xyz\'']
162726:         self.assertEqual(defines, expected)
162726: 
159584:     def test_local_includes(self):
159584:         """Test that LOCAL_INCLUDES are written to backend.mk correctly."""
159584:         env = self._consume('local_includes', RecursiveMakeBackend)
159584: 
159584:         backend_path = os.path.join(env.topobjdir, 'backend.mk')
159584:         lines = [l.strip() for l in open(backend_path, 'rt').readlines()[2:]]
159584: 
159584:         expected = [
159584:             'LOCAL_INCLUDES += -I$(topsrcdir)/bar/baz',
159584:             'LOCAL_INCLUDES += -I$(srcdir)/foo',
159584:         ]
159584: 
159584:         found = [str for str in lines if str.startswith('LOCAL_INCLUDES')]
159584:         self.assertEqual(found, expected)
159584: 
166712:     def test_generated_includes(self):
166712:         """Test that GENERATED_INCLUDES are written to backend.mk correctly."""
166712:         env = self._consume('generated_includes', RecursiveMakeBackend)
166712: 
166712:         backend_path = os.path.join(env.topobjdir, 'backend.mk')
166712:         lines = [l.strip() for l in open(backend_path, 'rt').readlines()[2:]]
166712: 
166712:         topobjdir = env.topobjdir.replace('\\', '/')
166712: 
166712:         expected = [
166712:             'LOCAL_INCLUDES += -I%s/bar/baz' % topobjdir,
166712:             'LOCAL_INCLUDES += -Ifoo',
166712:         ]
166712: 
166712:         found = [str for str in lines if str.startswith('LOCAL_INCLUDES')]
166712:         self.assertEqual(found, expected)
166712: 
166365:     def test_final_target(self):
166365:         """Test that FINAL_TARGET is written to backend.mk correctly."""
166365:         env = self._consume('final_target', RecursiveMakeBackend)
166365: 
166365:         final_target_rule = "FINAL_TARGET = $(if $(XPI_NAME),$(DIST)/xpi-stage/$(XPI_NAME),$(DIST)/bin)$(DIST_SUBDIR:%=/%)"
172472:         print([x for x in os.walk(env.topobjdir)])
166365:         expected = dict()
166365:         expected[env.topobjdir] = []
166365:         expected[os.path.join(env.topobjdir, 'both')] = [
166365:             'XPI_NAME = mycrazyxpi',
166365:             'DIST_SUBDIR = asubdir',
166365:             final_target_rule
166365:         ]
166365:         expected[os.path.join(env.topobjdir, 'dist-subdir')] = [
166365:             'DIST_SUBDIR = asubdir',
166365:             final_target_rule
166365:         ]
166365:         expected[os.path.join(env.topobjdir, 'xpi-name')] = [
166365:             'XPI_NAME = mycrazyxpi',
166365:             final_target_rule
166365:         ]
166365:         expected[os.path.join(env.topobjdir, 'final-target')] = [
166365:             'FINAL_TARGET = $(DEPTH)/random-final-target'
166365:         ]
166365:         for key, expected_rules in expected.iteritems():
166365:             backend_path = os.path.join(key, 'backend.mk')
166365:             lines = [l.strip() for l in open(backend_path, 'rt').readlines()[2:]]
166365:             found = [str for str in lines if
166365:                 str.startswith('FINAL_TARGET') or str.startswith('XPI_NAME') or
166365:                 str.startswith('DIST_SUBDIR')]
166365:             self.assertEqual(found, expected_rules)
166365: 
166365: 
130924: if __name__ == '__main__':
130924:     main()
