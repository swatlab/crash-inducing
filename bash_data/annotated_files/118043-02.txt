 19246: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 19246: 
 99806: #ifdef MOZ_WIDGET_ANDROID
101316: // For ScreenOrientation.h and Hal.h
 99806: #include "base/basictypes.h"
 99806: #endif
 99806: 
 19246: #include "prlog.h"
 19246: #include "prmem.h"
 19246: #include "nscore.h"
 19246: #include "prenv.h"
 19246: 
 19246: #include "nsNPAPIPluginInstance.h"
 19246: #include "nsNPAPIPlugin.h"
 19246: #include "nsNPAPIPluginStreamListener.h"
 29956: #include "nsPluginHost.h"
 19246: #include "nsPluginSafety.h"
 19246: #include "nsPluginLogging.h"
 61864: #include "nsContentUtils.h"
115860: #include "nsPluginInstanceOwner.h"
 19246: 
 19246: #include "nsIDocument.h"
 29808: #include "nsIScriptGlobalObject.h"
 29808: #include "nsIScriptContext.h"
 29834: #include "nsDirectoryServiceDefs.h"
 19246: #include "nsJSNPRuntime.h"
 60021: #include "nsPluginStreamListenerPeer.h"
 70185: #include "nsSize.h"
 70185: #include "nsNetCID.h"
 74131: #include "nsIContent.h"
 19246: 
 94707: #include "mozilla/Preferences.h"
116413: #include "nsVersionComparator.h"
 94707: 
 82142: #ifdef MOZ_WIDGET_ANDROID
 78424: #include "ANPBase.h"
 78424: #include <android/log.h>
 78424: #include "android_npapi.h"
 82979: #include "mozilla/Mutex.h"
 78424: #include "mozilla/CondVar.h"
 78424: #include "AndroidBridge.h"
 99806: #include "mozilla/dom/ScreenOrientation.h"
101316: #include "mozilla/Hal.h"
106178: #include "GLContextProvider.h"
106178: #include "TexturePoolOGL.h"
106178: 
106178: using namespace mozilla;
106178: using namespace mozilla::gl;
106178: 
106178: typedef nsNPAPIPluginInstance::TextureInfo TextureInfo;
106178: typedef nsNPAPIPluginInstance::VideoInfo VideoInfo;
 97692: 
 97692: class PluginEventRunnable : public nsRunnable
 97692: {
 97692: public:
 97692:   PluginEventRunnable(nsNPAPIPluginInstance* instance, ANPEvent* event)
 97692:     : mInstance(instance), mEvent(*event), mCanceled(false) {}
 97692: 
 97692:   virtual nsresult Run() {
 97692:     if (mCanceled)
 97692:       return NS_OK;
 97692: 
106838:     mInstance->HandleEvent(&mEvent, nullptr);
 97692:     mInstance->PopPostedEvent(this);
 97692:     return NS_OK;
 97692:   }
 97692: 
 97692:   void Cancel() { mCanceled = true; }
 97692: private:
 97692:   nsNPAPIPluginInstance* mInstance;
 97692:   ANPEvent mEvent;
 97692:   bool mCanceled;
 97692: };
 97692: 
106838: static nsRefPtr<GLContext> sPluginContext = nullptr;
106178: 
106178: static bool EnsureGLContext()
106178: {
106178:   if (!sPluginContext) {
106178:     sPluginContext = GLContextProvider::CreateOffscreen(gfxIntSize(16, 16));
106178:   }
106178: 
106838:   return sPluginContext != nullptr;
106178: }
106178: 
106178: class SharedPluginTexture {
106178: public:
106178:   NS_INLINE_DECL_REFCOUNTING(SharedPluginTexture)
106178: 
108549:   SharedPluginTexture() : mLock("SharedPluginTexture.mLock")
106178:   {
106178:   }
106178: 
106178:   ~SharedPluginTexture()
106178:   {
106178:   }
106178: 
106178:   TextureInfo Lock()
106178:   {
106178:     if (!EnsureGLContext()) {
106178:       mTextureInfo.mTexture = 0;
106178:       return mTextureInfo;
106178:     }
106178: 
106178:     if (!mTextureInfo.mTexture && sPluginContext->MakeCurrent()) {
106178:       sPluginContext->fGenTextures(1, &mTextureInfo.mTexture);
106178:     }
106178: 
106178:     mLock.Lock();
106178:     return mTextureInfo;
106178:   }
106178: 
106178:   void Release(TextureInfo& aTextureInfo)
106178:   { 
106178:     mTextureInfo = aTextureInfo;
106178:     mLock.Unlock();
106178:   } 
106178: 
106178:   SharedTextureHandle CreateSharedHandle()
106178:   {
106178:     MutexAutoLock lock(mLock);
106178: 
106178:     if (!EnsureGLContext())
107196:       return 0;
106178: 
106178:     if (mTextureInfo.mWidth == 0 || mTextureInfo.mHeight == 0)
107196:       return 0;
106178: 
108549:     SharedTextureHandle handle = sPluginContext->CreateSharedHandle(TextureImage::ThreadShared, (void*)mTextureInfo.mTexture, GLContext::TextureID);
106178: 
106178:     // We want forget about this now, so delete the texture. Assigning it to zero
106178:     // ensures that we create a new one in Lock()
106178:     sPluginContext->fDeleteTextures(1, &mTextureInfo.mTexture);
106178:     mTextureInfo.mTexture = 0;
106178:     
108549:     return handle;
106178:   }
106178: 
106178: private:
106178:   TextureInfo mTextureInfo;
106178:  
106178:   Mutex mLock;
106178: };
106178: 
 78424: #endif
 78424: 
 62473: using namespace mozilla;
 36125: using namespace mozilla::plugins::parent;
 36125: 
 47353: static NS_DEFINE_IID(kIOutputStreamIID, NS_IOUTPUTSTREAM_IID);
 19246: 
 78424: NS_IMPL_THREADSAFE_ISUPPORTS0(nsNPAPIPluginInstance)
 19246: 
 94603: nsNPAPIPluginInstance::nsNPAPIPluginInstance()
 47965:   :
 91345:     mDrawingModel(kDefaultDrawingModel),
 82142: #ifdef MOZ_WIDGET_ANDROID
 87577:     mANPDrawingModel(0),
 99806:     mFullScreenOrientation(dom::eScreenOrientation_LandscapePrimary),
101316:     mWakeLocked(false),
101317:     mFullScreen(false),
106178:     mInverted(false),
 78424: #endif
 39838:     mRunning(NOT_STARTED),
 79533:     mWindowless(false),
 79533:     mTransparent(false),
 82172:     mCached(false),
 79533:     mUsesDOMForCursor(false),
 79533:     mInPluginInitCall(false),
106838:     mPlugin(nullptr),
106838:     mMIMEType(nullptr),
106838:     mOwner(nullptr),
115090:     mCurrentPluginEvent(nullptr)
107562: #ifdef MOZ_WIDGET_ANDROID
107562:   , mOnScreen(true)
107562: #endif
116413:   , mHaveJavaC2PJSObjectQuirk(false)
 19246: {
 30212:   mNPP.pdata = NULL;
 30212:   mNPP.ndata = this;
 19246: 
 19246:   PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance ctor: this=%p\n",this));
 19246: }
 19246: 
 47301: nsNPAPIPluginInstance::~nsNPAPIPluginInstance()
 19246: {
 19246:   PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance dtor: this=%p\n",this));
 19246: 
 29808:   if (mMIMEType) {
 29808:     PR_Free((void *)mMIMEType);
106838:     mMIMEType = nullptr;
 29808:   }
 19246: }
 19246: 
118043: uint32_t nsNPAPIPluginInstance::gInPluginCalls = 0;
118043: 
 47965: void
 47965: nsNPAPIPluginInstance::Destroy()
 47965: {
 47965:   Stop();
106838:   mPlugin = nullptr;
106178: 
106178: #if MOZ_WIDGET_ANDROID
106565:   if (mContentSurface)
106838:     mContentSurface->SetFrameAvailableCallback(nullptr);
106565:   
106838:   mContentTexture = nullptr;
106838:   mContentSurface = nullptr;
106178: 
106178:   std::map<void*, VideoInfo*>::iterator it;
106178:   for (it = mVideos.begin(); it != mVideos.end(); it++) {
106838:     it->second->mSurfaceTexture->SetFrameAvailableCallback(nullptr);
106178:     delete it->second;
106178:   }
106178:   mVideos.clear();
106178:   SetWakeLock(false);
106178: #endif
 47965: }
 47965: 
 82172: TimeStamp
 82172: nsNPAPIPluginInstance::StopTime()
 82172: {
 82172:   return mStopTime;
 82172: }
 82172: 
115860: nsresult nsNPAPIPluginInstance::Initialize(nsNPAPIPlugin *aPlugin, nsPluginInstanceOwner* aOwner, const char* aMIMEType)
 19246: {
 19246:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Initialize this=%p\n",this));
 19246: 
 94603:   NS_ENSURE_ARG_POINTER(aPlugin);
 94603:   NS_ENSURE_ARG_POINTER(aOwner);
 94603: 
 94603:   mPlugin = aPlugin;
 29834:   mOwner = aOwner;
 29834: 
 29808:   if (aMIMEType) {
 30101:     mMIMEType = (char*)PR_Malloc(PL_strlen(aMIMEType) + 1);
 94603:     if (mMIMEType) {
 30101:       PL_strcpy(mMIMEType, aMIMEType);
 29808:     }
 19246:   }
 19246:   
 94603:   return Start();
 19246: }
 19246: 
 70007: nsresult nsNPAPIPluginInstance::Stop()
 19246: {
 19246:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Stop this=%p\n",this));
 19246: 
 19246:   // Make sure the plugin didn't leave popups enabled.
 26912:   if (mPopupStates.Length() > 0) {
 19246:     nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
 19246: 
 19246:     if (window) {
 19246:       window->PopPopupControlState(openAbused);
 19246:     }
 19246:   }
 19246: 
 39211:   if (RUNNING != mRunning) {
 19246:     return NS_OK;
 23529:   }
 19246: 
 29937:   // clean up all outstanding timers
108991:   for (uint32_t i = mTimers.Length(); i > 0; i--)
 29937:     UnscheduleTimer(mTimers[i - 1]->id);
 29937: 
 19246:   // If there's code from this plugin instance on the stack, delay the
 19246:   // destroy.
 19246:   if (PluginDestructionGuard::DelayDestroy(this)) {
 19246:     return NS_OK;
 19246:   }
 19246: 
 36355:   // Make sure we lock while we're writing to mRunning after we've
 19246:   // started as other threads might be checking that inside a lock.
 64576:   {
 64576:     AsyncCallbackAutoLock lock;
 39211:     mRunning = DESTROYING;
 82172:     mStopTime = TimeStamp::Now();
 64576:   }
 19246: 
 30212:   OnPluginDestroy(&mNPP);
 19246: 
 19246:   // clean up open streams
 60021:   while (mStreamListeners.Length() > 0) {
 60021:     nsRefPtr<nsNPAPIPluginStreamListener> currentListener(mStreamListeners[0]);
 49224:     currentListener->CleanUpStream(NPRES_USER_BREAK);
 60021:     mStreamListeners.RemoveElement(currentListener);
 19246:   }
 19246: 
 55810:   if (!mPlugin || !mPlugin->GetLibrary())
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
 47965: 
 39211:   NPError error = NPERR_GENERIC_ERROR;
 47965:   if (pluginFunctions->destroy) {
 39211:     NPSavedData *sdata = 0;
 39211: 
 55810:     NS_TRY_SAFE_CALL_RETURN(error, (*pluginFunctions->destroy)(&mNPP, &sdata), this);
 19246: 
 19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 30212:                    ("NPP Destroy called: this=%p, npp=%p, return=%d\n", this, &mNPP, error));
 39211:   }
 39211:   mRunning = DESTROYED;
 19246: 
 97692: #if MOZ_WIDGET_ANDROID
108991:   for (uint32_t i = 0; i < mPostedEvents.Length(); i++) {
 97692:     mPostedEvents[i]->Cancel();
 97692:   }
 97692: 
 97692:   mPostedEvents.Clear();
 97692: #endif
 97692: 
 30212:   nsJSNPRuntime::OnPluginDestroy(&mNPP);
 19246: 
 19246:   if (error != NPERR_NO_ERROR)
 19246:     return NS_ERROR_FAILURE;
 19246:   else
 19246:     return NS_OK;
 19246: }
 19246: 
 19246: already_AddRefed<nsPIDOMWindow>
 19246: nsNPAPIPluginInstance::GetDOMWindow()
 19246: {
115860:   if (!mOwner)
106838:     return nullptr;
 19246: 
115860:   nsRefPtr<nsPluginInstanceOwner> deathGrip(mOwner);
115860: 
 19246:   nsCOMPtr<nsIDocument> doc;
115860:   mOwner->GetDocument(getter_AddRefs(doc));
 21231:   if (!doc)
106838:     return nullptr;
 19246: 
 19246:   nsPIDOMWindow *window = doc->GetWindow();
 19246:   NS_IF_ADDREF(window);
 19246: 
 19246:   return window;
 19246: }
 19246: 
 29834: nsresult
 29834: nsNPAPIPluginInstance::GetTagType(nsPluginTagType *result)
 19246: {
115860:   if (!mOwner) {
115860:     return NS_ERROR_FAILURE;
 29834:   }
 19246: 
115860:   return mOwner->GetTagType(result);
 29834: }
 19246: 
 29834: nsresult
108991: nsNPAPIPluginInstance::GetAttributes(uint16_t& n, const char*const*& names,
 29834:                                      const char*const*& values)
 29834: {
115860:   if (!mOwner) {
115860:     return NS_ERROR_FAILURE;
 29834:   }
 29834: 
115860:   return mOwner->GetAttributes(n, names, values);
 29834: }
 29834: 
 29834: nsresult
108991: nsNPAPIPluginInstance::GetParameters(uint16_t& n, const char*const*& names,
 29834:                                      const char*const*& values)
 29834: {
115860:   if (!mOwner) {
115860:     return NS_ERROR_FAILURE;
 29834:   }
 29834: 
115860:   return mOwner->GetParameters(n, names, values);
 29834: }
 29834: 
 29834: nsresult
108991: nsNPAPIPluginInstance::GetMode(int32_t *result)
 29834: {
 29834:   if (mOwner)
 29834:     return mOwner->GetMode(result);
 29834:   else
 29834:     return NS_ERROR_FAILURE;
 29834: }
 29834: 
 47865: nsTArray<nsNPAPIPluginStreamListener*>*
 60021: nsNPAPIPluginInstance::StreamListeners()
 47865: {
 60021:   return &mStreamListeners;
 47865: }
 47865: 
 47865: nsTArray<nsPluginStreamListenerPeer*>*
 60021: nsNPAPIPluginInstance::FileCachedStreamListeners()
 47865: {
 60021:   return &mFileCachedStreamListeners;
 47865: }
 47865: 
 29834: nsresult
 94603: nsNPAPIPluginInstance::Start()
 29834: {
 94603:   if (mRunning == RUNNING) {
 94603:     return NS_OK;
 94603:   }
 94603: 
 19246:   PluginDestructionGuard guard(this);
 19246: 
108991:   uint16_t count = 0;
106838:   const char* const* names = nullptr;
106838:   const char* const* values = nullptr;
 19246:   nsPluginTagType tagtype;
 29834:   nsresult rv = GetTagType(&tagtype);
 19246:   if (NS_SUCCEEDED(rv)) {
 19246:     // Note: If we failed to get the tag type, we may be a full page plugin, so no arguments
 29834:     rv = GetAttributes(count, names, values);
 19246:     NS_ENSURE_SUCCESS(rv, rv);
 19246:     
 19246:     // nsPluginTagType_Object or Applet may also have PARAM tags
 19246:     // Note: The arrays handed back by GetParameters() are
 19246:     // crafted specially to be directly behind the arrays from GetAttributes()
 19246:     // with a null entry as a separator. This is for 4.x backwards compatibility!
 19246:     // see bug 111008 for details
 19246:     if (tagtype != nsPluginTagType_Embed) {
108991:       uint16_t pcount = 0;
106838:       const char* const* pnames = nullptr;
106838:       const char* const* pvalues = nullptr;    
 29834:       if (NS_SUCCEEDED(GetParameters(pcount, pnames, pvalues))) {
 80591:         // Android expects an empty string as the separator instead of null
 82142: #ifdef MOZ_WIDGET_ANDROID
 80591:         NS_ASSERTION(PL_strcmp(values[count], "") == 0, "attribute/parameter array not setup correctly for Android NPAPI plugins");
 80591: #else
 21231:         NS_ASSERTION(!values[count], "attribute/parameter array not setup correctly for NPAPI plugins");
 80591: #endif
 19246:         if (pcount)
 21231:           count += ++pcount; // if it's all setup correctly, then all we need is to
 21231:                              // change the count (attrs + PARAM/blank + params)
 19246:       }
 19246:     }
 19246:   }
 19246: 
108991:   int32_t       mode;
 30224:   const char*   mimetype;
 37569:   NPError       error = NPERR_GENERIC_ERROR;
 19246: 
 29834:   GetMode(&mode);
 29808:   GetMIMEType(&mimetype);
 19246: 
116413:   CheckJavaC2PJSObjectQuirk(count, names, values);
116413: 
 19246:   // Some older versions of Flash have a bug in them
 19246:   // that causes the stack to become currupt if we
 29923:   // pass swliveconnect=1 in the NPP_NewProc arrays.
 19246:   // See bug 149336 (UNIX), bug 186287 (Mac)
 19246:   //
 19246:   // The code below disables the attribute unless
 19246:   // the environment variable:
 19246:   // MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK
 19246:   // is set.
 19246:   //
 19246:   // It is okay to disable this attribute because
 19246:   // back in 4.x, scripting required liveconnect to
 19246:   // start Java which was slow. Scripting no longer
 19246:   // requires starting Java and is quick plus controled
 19246:   // from the browser, so Flash now ignores this attribute.
 19246:   //
 19246:   // This code can not be put at the time of creating
 19246:   // the array because we may need to examine the
 19246:   // stream header to determine we want Flash.
 19246: 
 19246:   static const char flashMimeType[] = "application/x-shockwave-flash";
 19246:   static const char blockedParam[] = "swliveconnect";
 19246:   if (count && !PL_strcasecmp(mimetype, flashMimeType)) {
 19246:     static int cachedDisableHack = 0;
 19246:     if (!cachedDisableHack) {
 19246:        if (PR_GetEnv("MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK"))
 19246:          cachedDisableHack = -1;
 19246:        else
 19246:          cachedDisableHack = 1;
 19246:     }
 19246:     if (cachedDisableHack > 0) {
108991:       for (uint16_t i=0; i<count; i++) {
 19246:         if (!PL_strcasecmp(names[i], blockedParam)) {
 19246:           // BIG FAT WARNIG:
 19246:           // I'm ugly casting |const char*| to |char*| and altering it
 19246:           // because I know we do malloc it values in
 19246:           // http://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/layout/html/base/src/nsObjectFrame.cpp&rev=1.349&root=/cvsroot#3020
 19246:           // and free it at line #2096, so it couldn't be a const ptr to string literal
 19246:           char *val = (char*) values[i];
 19246:           if (val && *val) {
 19246:             // we cannot just *val=0, it won't be free properly in such case
 19246:             val[0] = '0';
 19246:             val[1] = 0;
 19246:           }
 19246:           break;
 19246:         }
 19246:       }
 19246:     }
 19246:   }
 19246: 
 79445:   bool oldVal = mInPluginInitCall;
 79533:   mInPluginInitCall = true;
 19246: 
 35965:   // Need this on the stack before calling NPP_New otherwise some callbacks that
 35965:   // the plugin may make could fail (NPN_HasProperty, for example).
 35965:   NPPAutoPusher autopush(&mNPP);
 47965: 
 47965:   if (!mPlugin)
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   PluginLibrary* library = mPlugin->GetLibrary();
 47965:   if (!library)
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   // Mark this instance as running before calling NPP_New because the plugin may
 47965:   // call other NPAPI functions, like NPN_GetURLNotify, that assume this is set
 47965:   // before returning. If the plugin returns failure, we'll clear it out below.
 47965:   mRunning = RUNNING;
 47965: 
 99052: #if MOZ_WIDGET_ANDROID
 99052:   // Flash creates some local JNI references during initialization (NPP_New). It does not
 99052:   // remove these references later, so essentially they are leaked. AutoLocalJNIFrame
 99052:   // prevents this by pushing a JNI frame. As a result, all local references created
 99052:   // by Flash are contained in this frame. AutoLocalJNIFrame pops the frame once we
 99052:   // go out of scope and the local references are deleted, preventing the leak.
 99052:   JNIEnv* env = AndroidBridge::GetJNIEnv();
 99052:   if (!env)
 99052:     return NS_ERROR_FAILURE;
 99052: 
 99052:   mozilla::AutoLocalJNIFrame frame(env);
 99052: #endif
 99052: 
108991:   nsresult newResult = library->NPP_New((char*)mimetype, &mNPP, (uint16_t)mode, count, (char**)names, (char**)values, NULL, &error);
 19246:   mInPluginInitCall = oldVal;
 19246: 
 19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:   ("NPP New called: this=%p, npp=%p, mime=%s, mode=%d, argc=%d, return=%d\n",
 30212:   this, &mNPP, mimetype, mode, count, error));
 19246: 
 61875:   if (NS_FAILED(newResult) || error != NPERR_NO_ERROR) {
 39211:     mRunning = DESTROYED;
 61875:     nsJSNPRuntime::OnPluginDestroy(&mNPP);
 19246:     return NS_ERROR_FAILURE;
 19246:   }
 19246:   
 19246:   return NS_OK;
 19246: }
 19246: 
 70007: nsresult nsNPAPIPluginInstance::SetWindow(NPWindow* window)
 19246: {
 32019:   // NPAPI plugins don't want a SetWindow(NULL).
 39211:   if (!window || RUNNING != mRunning)
 19246:     return NS_OK;
 19246: 
 19246: #if defined(MOZ_WIDGET_GTK2)
 19246:   // bug 108347, flash plugin on linux doesn't like window->width <=
 19246:   // 0, but Java needs wants this call.
 32799:   if (!nsPluginHost::IsJavaMIMEType(mMIMEType) && window->type == NPWindowTypeWindow &&
 19246:       (window->width <= 0 || window->height <= 0)) {
 19246:     return NS_OK;
 19246:   }
 32019: #endif
 19246: 
 55810:   if (!mPlugin || !mPlugin->GetLibrary())
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
 47965: 
 47965:   if (pluginFunctions->setwindow) {
 19246:     PluginDestructionGuard guard(this);
 19246: 
 19246:     // XXX Turns out that NPPluginWindow and NPWindow are structurally
 19246:     // identical (on purpose!), so there's no need to make a copy.
 19246: 
 19246:     PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::SetWindow (about to call it) this=%p\n",this));
 19246: 
 79445:     bool oldVal = mInPluginInitCall;
 79533:     mInPluginInitCall = true;
 19246: 
 35965:     NPPAutoPusher nppPusher(&mNPP);
 35965: 
 32019:     NPError error;
 55810:     NS_TRY_SAFE_CALL_RETURN(error, (*pluginFunctions->setwindow)(&mNPP, (NPWindow*)window), this);
 19246: 
 19246:     mInPluginInitCall = oldVal;
 19246: 
 19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:     ("NPP SetWindow called: this=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d], return=%d\n",
 19246:     this, window->x, window->y, window->width, window->height,
 19246:     window->clipRect.top, window->clipRect.bottom, window->clipRect.left, window->clipRect.right, error));
 19246:   }
 19246:   return NS_OK;
 19246: }
 19246: 
 70007: nsresult
 30101: nsNPAPIPluginInstance::NewStreamFromPlugin(const char* type, const char* target,
 29834:                                            nsIOutputStream* *result)
 29834: {
 29834:   nsPluginStreamToFile* stream = new nsPluginStreamToFile(target, mOwner);
 29834:   if (!stream)
 29834:     return NS_ERROR_OUT_OF_MEMORY;
 29834: 
 29834:   return stream->QueryInterface(kIOutputStreamIID, (void**)result);
 29834: }
 29834: 
 60021: nsresult
 60021: nsNPAPIPluginInstance::NewStreamListener(const char* aURL, void* notifyData,
 98780:                                          nsNPAPIPluginStreamListener** listener)
 19246: {
 98780:   nsRefPtr<nsNPAPIPluginStreamListener> sl = new nsNPAPIPluginStreamListener(this, notifyData, aURL);
 19246: 
 98780:   mStreamListeners.AppendElement(sl);
 19246: 
 98780:   sl.forget(listener);
 98780: 
 98780:   return NS_OK;
 19246: }
 19246: 
 70007: nsresult nsNPAPIPluginInstance::Print(NPPrint* platformPrint)
 19246: {
 19246:   NS_ENSURE_TRUE(platformPrint, NS_ERROR_NULL_POINTER);
 19246: 
 19246:   PluginDestructionGuard guard(this);
 19246: 
 55810:   if (!mPlugin || !mPlugin->GetLibrary())
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
 47965: 
 19246:   NPPrint* thePrint = (NPPrint *)platformPrint;
 19246: 
 19246:   // to be compatible with the older SDK versions and to match what
 21231:   // NPAPI and other browsers do, overwrite |window.type| field with one
 19246:   // more copy of |platformPrint|. See bug 113264
108991:   uint16_t sdkmajorversion = (pluginFunctions->version & 0xff00)>>8;
108991:   uint16_t sdkminorversion = pluginFunctions->version & 0x00ff;
 19246:   if ((sdkmajorversion == 0) && (sdkminorversion < 11)) {
 19246:     // Let's copy platformPrint bytes over to where it was supposed to be
 19246:     // in older versions -- four bytes towards the beginning of the struct
 19246:     // but we should be careful about possible misalignments
 19246:     if (sizeof(NPWindowType) >= sizeof(void *)) {
 19246:       void* source = thePrint->print.embedPrint.platformPrint;
 19246:       void** destination = (void **)&(thePrint->print.embedPrint.window.type);
 19246:       *destination = source;
 31379:     } else {
 31379:       NS_ERROR("Incompatible OS for assignment");
 19246:     }
 19246:   }
 19246: 
 47965:   if (pluginFunctions->print)
 55810:       NS_TRY_SAFE_CALL_VOID((*pluginFunctions->print)(&mNPP, thePrint), this);
 19246: 
 19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:   ("NPP PrintProc called: this=%p, pDC=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d]\n",
 19246:   this,
 19246:   platformPrint->print.embedPrint.platformPrint,
 19246:   platformPrint->print.embedPrint.window.x,
 19246:   platformPrint->print.embedPrint.window.y,
 19246:   platformPrint->print.embedPrint.window.width,
 19246:   platformPrint->print.embedPrint.window.height,
 19246:   platformPrint->print.embedPrint.window.clipRect.top,
 19246:   platformPrint->print.embedPrint.window.clipRect.bottom,
 19246:   platformPrint->print.embedPrint.window.clipRect.left,
 19246:   platformPrint->print.embedPrint.window.clipRect.right));
 19246: 
 19246:   return NS_OK;
 19246: }
 19246: 
108991: nsresult nsNPAPIPluginInstance::HandleEvent(void* event, int16_t* result)
 19246: {
 39211:   if (RUNNING != mRunning)
 19246:     return NS_OK;
 19246: 
 19246:   if (!event)
 19246:     return NS_ERROR_FAILURE;
 19246: 
 19246:   PluginDestructionGuard guard(this);
 19246: 
 55810:   if (!mPlugin || !mPlugin->GetLibrary())
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
 47965: 
108991:   int16_t tmpResult = kNPEventNotHandled;
 19246: 
 47965:   if (pluginFunctions->event) {
 32019:     mCurrentPluginEvent = event;
 32799: #if defined(XP_WIN) || defined(XP_OS2)
 55810:     NS_TRY_SAFE_CALL_RETURN(tmpResult, (*pluginFunctions->event)(&mNPP, event), this);
 32799: #else
 47965:     tmpResult = (*pluginFunctions->event)(&mNPP, event);
 19246: #endif
 19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 32799:       ("NPP HandleEvent called: this=%p, npp=%p, event=%p, return=%d\n", 
 43436:       this, &mNPP, event, tmpResult));
 19246: 
 43436:     if (result)
 43436:       *result = tmpResult;
106838:     mCurrentPluginEvent = nullptr;
 19246:   }
 19246: 
 19246:   return NS_OK;
 19246: }
 19246: 
 70007: nsresult nsNPAPIPluginInstance::GetValueFromPlugin(NPPVariable variable, void* value)
 19246: {
 55810:   if (!mPlugin || !mPlugin->GetLibrary())
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
 47965: 
 47965:   nsresult rv = NS_ERROR_FAILURE;
 63555: 
 47965:   if (pluginFunctions->getvalue && RUNNING == mRunning) {
 19246:     PluginDestructionGuard guard(this);
 19246: 
 63555:     NPError pluginError = NPERR_GENERIC_ERROR;
 63555:     NS_TRY_SAFE_CALL_RETURN(pluginError, (*pluginFunctions->getvalue)(&mNPP, variable, value), this);
 19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:     ("NPP GetValue called: this=%p, npp=%p, var=%d, value=%d, return=%d\n", 
 63555:     this, &mNPP, variable, value, pluginError));
 63555: 
 63555:     if (pluginError == NPERR_NO_ERROR) {
 63555:       rv = NS_OK;
 63555:     }
 19246:   }
 19246: 
 47965:   return rv;
 47965: }
 47965: 
 47965: nsNPAPIPlugin* nsNPAPIPluginInstance::GetPlugin()
 47965: {
 47965:   return mPlugin;
 19246: }
 19246: 
 19246: nsresult nsNPAPIPluginInstance::GetNPP(NPP* aNPP) 
 19246: {
 21231:   if (aNPP)
 30212:     *aNPP = &mNPP;
 19246:   else
 19246:     return NS_ERROR_NULL_POINTER;
 19246: 
 19246:   return NS_OK;
 19246: }
 19246: 
 79445: NPError nsNPAPIPluginInstance::SetWindowless(bool aWindowless)
 19246: {
 19246:   mWindowless = aWindowless;
 40724: 
 40724:   if (mMIMEType) {
 40724:     // bug 558434 - Prior to 3.6.4, we assumed windowless was transparent.
 40724:     // Silverlight apparently relied on this quirk, so we default to
 40724:     // transparent unless they specify otherwise after setting the windowless
 57216:     // property. (Last tested version: sl 4.0).
 57216:     // Changes to this code should be matched with changes in
 57216:     // PluginInstanceChild::InitQuirksMode.
 40724:     NS_NAMED_LITERAL_CSTRING(silverlight, "application/x-silverlight");
 40724:     if (!PL_strncasecmp(mMIMEType, silverlight.get(), silverlight.Length())) {
 79533:       mTransparent = true;
 40724:     }
 40724:   }
 40724: 
 19246:   return NPERR_NO_ERROR;
 19246: }
 19246: 
 79445: NPError nsNPAPIPluginInstance::SetTransparent(bool aTransparent)
 19246: {
 19246:   mTransparent = aTransparent;
 19246:   return NPERR_NO_ERROR;
 19246: }
 19246: 
 79445: NPError nsNPAPIPluginInstance::SetUsesDOMForCursor(bool aUsesDOMForCursor)
 67677: {
 67677:   mUsesDOMForCursor = aUsesDOMForCursor;
 67677:   return NPERR_NO_ERROR;
 67677: }
 67677: 
 79445: bool
 67677: nsNPAPIPluginInstance::UsesDOMForCursor()
 67677: {
 67677:   return mUsesDOMForCursor;
 67677: }
 67677: 
 19246: void nsNPAPIPluginInstance::SetDrawingModel(NPDrawingModel aModel)
 19246: {
 19246:   mDrawingModel = aModel;
 19246: }
 19246: 
 91347: void nsNPAPIPluginInstance::RedrawPlugin()
 91347: {
 91347:   mOwner->RedrawPlugin();
 91347: }
 91347: 
 91345: #if defined(XP_MACOSX)
 32019: void nsNPAPIPluginInstance::SetEventModel(NPEventModel aModel)
 32019: {
 34717:   // the event model needs to be set for the object frame immediately
115860:   if (!mOwner) {
 34717:     NS_WARNING("Trying to set event model without a plugin instance owner!");
 34717:     return;
 34717:   }
 34717: 
115860:   mOwner->SetEventModel(aModel);
 32019: }
 78424: #endif
 78424: 
 82142: #if defined(MOZ_WIDGET_ANDROID)
 90194: 
108991: static void SendLifecycleEvent(nsNPAPIPluginInstance* aInstance, uint32_t aAction)
 90194: {
 90194:   ANPEvent event;
 90194:   event.inSize = sizeof(ANPEvent);
 90194:   event.eventType = kLifecycle_ANPEventType;
 90194:   event.data.lifecycle.action = aAction;
106838:   aInstance->HandleEvent(&event, nullptr);
 90194: }
 90194: 
 90194: void nsNPAPIPluginInstance::NotifyForeground(bool aForeground)
 90194: {
 90194:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::SetForeground this=%p\n foreground=%d",this, aForeground));
 90194:   if (RUNNING != mRunning)
 90194:     return;
 90194: 
 90194:   SendLifecycleEvent(this, aForeground ? kResume_ANPLifecycleAction : kPause_ANPLifecycleAction);
 90194: }
 90194: 
 90194: void nsNPAPIPluginInstance::NotifyOnScreen(bool aOnScreen)
 90194: {
 90194:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::SetOnScreen this=%p\n onScreen=%d",this, aOnScreen));
 90194:   if (RUNNING != mRunning || mOnScreen == aOnScreen)
 90194:     return;
 90194: 
 90194:   mOnScreen = aOnScreen;
 90194:   SendLifecycleEvent(this, aOnScreen ? kOnScreen_ANPLifecycleAction : kOffScreen_ANPLifecycleAction);
 90194: }
 90194: 
 90194: void nsNPAPIPluginInstance::MemoryPressure()
 90194: {
 90194:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::MemoryPressure this=%p\n",this));
 90194:   if (RUNNING != mRunning)
 90194:     return;
 90194: 
 90194:   SendLifecycleEvent(this, kFreeMemory_ANPLifecycleAction);
 90194: }
 90194: 
 99806: void nsNPAPIPluginInstance::NotifyFullScreen(bool aFullScreen)
 99806: {
 99806:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::NotifyFullScreen this=%p\n",this));
 99806: 
101317:   if (RUNNING != mRunning || mFullScreen == aFullScreen)
 99806:     return;
 99806: 
101317:   mFullScreen = aFullScreen;
101317:   SendLifecycleEvent(this, mFullScreen ? kEnterFullScreen_ANPLifecycleAction : kExitFullScreen_ANPLifecycleAction);
101317: 
101317:   if (mFullScreen && mFullScreenOrientation != dom::eScreenOrientation_None) {
101317:     AndroidBridge::Bridge()->LockScreenOrientation(mFullScreenOrientation);
101317:   }
 99806: }
 99806: 
106178: void nsNPAPIPluginInstance::NotifySize(nsIntSize size)
106178: {
106178:   if (kOpenGL_ANPDrawingModel != GetANPDrawingModel() ||
106178:       size == mCurrentSize)
106178:     return;
106178: 
106178:   mCurrentSize = size;
106178: 
106178:   ANPEvent event;
106178:   event.inSize = sizeof(ANPEvent);
106178:   event.eventType = kDraw_ANPEventType;
106178:   event.data.draw.model = kOpenGL_ANPDrawingModel;
106178:   event.data.draw.data.surfaceSize.width = size.width;
106178:   event.data.draw.data.surfaceSize.height = size.height;
106178: 
106838:   HandleEvent(&event, nullptr);
106178: }
106178: 
108991: void nsNPAPIPluginInstance::SetANPDrawingModel(uint32_t aModel)
 78424: {
 87577:   mANPDrawingModel = aModel;
 78424: }
 87577: 
 78424: void* nsNPAPIPluginInstance::GetJavaSurface()
 78424: {
106838:   void* surface = nullptr; 
 99806:   nsresult rv = GetValueFromPlugin(kJavaSurface_ANPGetValue, &surface);
 99806:   if (NS_FAILED(rv))
106838:     return nullptr;
 78424: 
 99806:   return surface;
 80592: }
 80592: 
 97692: void nsNPAPIPluginInstance::PostEvent(void* event)
 97692: {
 97692:   PluginEventRunnable *r = new PluginEventRunnable(this, (ANPEvent*)event);
 97692:   mPostedEvents.AppendElement(nsRefPtr<PluginEventRunnable>(r));
 97692: 
 97692:   NS_DispatchToMainThread(r);
 97692: }
 97692: 
108991: void nsNPAPIPluginInstance::SetFullScreenOrientation(uint32_t orientation)
101317: {
101317:   if (mFullScreenOrientation == orientation)
101317:     return;
101317: 
108991:   uint32_t oldOrientation = mFullScreenOrientation;
101317:   mFullScreenOrientation = orientation;
101317: 
101317:   if (mFullScreen) {
101317:     // We're already fullscreen so immediately apply the orientation change
101317: 
101317:     if (mFullScreenOrientation != dom::eScreenOrientation_None) {
101317:       AndroidBridge::Bridge()->LockScreenOrientation(mFullScreenOrientation);
101317:     } else if (oldOrientation != dom::eScreenOrientation_None) {
101317:       // We applied an orientation when we entered fullscreen, but
101317:       // we don't want it anymore
101317:       AndroidBridge::Bridge()->UnlockScreenOrientation();
101317:     }
101317:   }
101317: }
101317: 
 97692: void nsNPAPIPluginInstance::PopPostedEvent(PluginEventRunnable* r)
 97692: {
 97692:   mPostedEvents.RemoveElement(r);
 97692: }
 97692: 
101316: void nsNPAPIPluginInstance::SetWakeLock(bool aLocked)
101316: {
101316:   if (aLocked == mWakeLocked)
101316:     return;
101316: 
101316:   mWakeLocked = aLocked;
101316:   hal::ModifyWakeLock(NS_LITERAL_STRING("nsNPAPIPluginInstance"),
101316:                       mWakeLocked ? hal::WAKE_LOCK_ADD_ONE : hal::WAKE_LOCK_REMOVE_ONE,
101316:                       hal::WAKE_LOCK_NO_CHANGE);
101316: }
101316: 
106178: void nsNPAPIPluginInstance::EnsureSharedTexture()
106178: {
106178:   if (!mContentTexture)
106178:     mContentTexture = new SharedPluginTexture();
106178: }
106178: 
106178: GLContext* nsNPAPIPluginInstance::GLContext()
106178: {
106178:   if (!EnsureGLContext())
106838:     return nullptr;
106178: 
106178:   return sPluginContext;
106178: }
106178: 
106178: TextureInfo nsNPAPIPluginInstance::LockContentTexture()
106178: {
106178:   EnsureSharedTexture();
106178:   return mContentTexture->Lock();
106178: }
106178: 
106178: void nsNPAPIPluginInstance::ReleaseContentTexture(TextureInfo& aTextureInfo)
106178: {
106178:   EnsureSharedTexture();
106178:   mContentTexture->Release(aTextureInfo);
106178: }
106178: 
106178: nsSurfaceTexture* nsNPAPIPluginInstance::CreateSurfaceTexture()
106178: {
106178:   if (!EnsureGLContext())
106838:     return nullptr;
106178: 
106178:   GLuint texture = TexturePoolOGL::AcquireTexture();
106178:   if (!texture)
106838:     return nullptr;
106178: 
106178:   nsSurfaceTexture* surface = nsSurfaceTexture::Create(texture);
106178:   if (!surface)
106838:     return nullptr;
106178: 
106565:   nsCOMPtr<nsIRunnable> frameCallback = NS_NewRunnableMethod(this, &nsNPAPIPluginInstance::OnSurfaceTextureFrameAvailable);
106178:   surface->SetFrameAvailableCallback(frameCallback);
106178:   return surface;
106178: }
106178: 
106565: void nsNPAPIPluginInstance::OnSurfaceTextureFrameAvailable()
106565: {
106565:   if (mRunning == RUNNING && mOwner)
108548:     AndroidBridge::Bridge()->ScheduleComposite();
106565: }
106565: 
106178: void* nsNPAPIPluginInstance::AcquireContentWindow()
106178: {
106178:   if (!mContentSurface) {
106178:     mContentSurface = CreateSurfaceTexture();
106178: 
106178:     if (!mContentSurface)
106838:       return nullptr;
106178:   }
106178: 
106178:   return mContentSurface->GetNativeWindow();
106178: }
106178: 
106178: SharedTextureHandle nsNPAPIPluginInstance::CreateSharedHandle()
106178: {
106178:   if (mContentTexture) {
106178:     return mContentTexture->CreateSharedHandle();
106178:   } else if (mContentSurface) {
106178:     EnsureGLContext();
106178:     return sPluginContext->CreateSharedHandle(TextureImage::ThreadShared, mContentSurface, GLContext::SurfaceTexture);
107196:   } else return 0;
106178: }
106178: 
106178: void* nsNPAPIPluginInstance::AcquireVideoWindow()
106178: {
106178:   nsSurfaceTexture* surface = CreateSurfaceTexture();
106178:   if (!surface)
106838:     return nullptr;
106178: 
106178:   VideoInfo* info = new VideoInfo(surface);
106178: 
106178:   void* window = info->mSurfaceTexture->GetNativeWindow();
106178:   mVideos.insert(std::pair<void*, VideoInfo*>(window, info));
106178: 
106178:   return window;
106178: }
106178: 
106178: void nsNPAPIPluginInstance::ReleaseVideoWindow(void* window)
106178: {
106178:   std::map<void*, VideoInfo*>::iterator it = mVideos.find(window);
106178:   if (it == mVideos.end())
106178:     return;
106178: 
106178:   delete it->second;
106178:   mVideos.erase(window);
106178: }
106178: 
106178: void nsNPAPIPluginInstance::SetVideoDimensions(void* window, gfxRect aDimensions)
106178: {
106178:   std::map<void*, VideoInfo*>::iterator it;
106178: 
106178:   it = mVideos.find(window);
106178:   if (it == mVideos.end())
106178:     return;
106178: 
106178:   it->second->mDimensions = aDimensions;
106178: }
106178: 
106178: void nsNPAPIPluginInstance::GetVideos(nsTArray<VideoInfo*>& aVideos)
106178: {
106178:   std::map<void*, VideoInfo*>::iterator it;
106178:   for (it = mVideos.begin(); it != mVideos.end(); it++)
106178:     aVideos.AppendElement(it->second);
106178: }
106178: 
106178: void nsNPAPIPluginInstance::SetInverted(bool aInverted)
106178: {
106178:   if (aInverted == mInverted)
106178:     return;
106178: 
106178:   mInverted = aInverted;
106178: }
106178: 
 32799: #endif
 32799: 
108991: nsresult nsNPAPIPluginInstance::GetDrawingModel(int32_t* aModel)
 32019: {
 87577: #if defined(XP_MACOSX)
108991:   *aModel = (int32_t)mDrawingModel;
 32799:   return NS_OK;
 32799: #else
 32799:   return NS_ERROR_FAILURE;
 32799: #endif
 32019: }
 32799: 
 79445: nsresult nsNPAPIPluginInstance::IsRemoteDrawingCoreAnimation(bool* aDrawing)
 72866: {
 72866: #ifdef XP_MACOSX
 72866:   if (!mPlugin)
 72866:       return NS_ERROR_FAILURE;
 72866: 
 72866:   PluginLibrary* library = mPlugin->GetLibrary();
 72866:   if (!library)
 72866:       return NS_ERROR_FAILURE;
 72866:   
 72866:   return library->IsRemoteDrawingCoreAnimation(&mNPP, aDrawing);
 72866: #else
 72866:   return NS_ERROR_FAILURE;
 72866: #endif
 72866: }
 72866: 
117478: nsresult nsNPAPIPluginInstance::ContentsScaleFactorChanged(double aContentsScaleFactor)
117478: {
117478: #ifdef XP_MACOSX
117478:   if (!mPlugin)
117478:       return NS_ERROR_FAILURE;
117478: 
117478:   PluginLibrary* library = mPlugin->GetLibrary();
117478:   if (!library)
117478:       return NS_ERROR_FAILURE;
117478: 
117478:   // We only need to call this if the plugin is running OOP.
117478:   if (!library->IsOOP())
117478:       return NS_OK;
117478:   
117478:   return library->ContentsScaleFactorChanged(&mNPP, aContentsScaleFactor);
117478: #else
117478:   return NS_ERROR_FAILURE;
117478: #endif
117478: }
117478: 
 70007: nsresult
 29953: nsNPAPIPluginInstance::GetJSObject(JSContext *cx, JSObject** outObject)
 19246: {
116413:   if (mHaveJavaC2PJSObjectQuirk) {
116413:     return NS_ERROR_FAILURE;
116413:   }
116413: 
106838:   NPObject *npobj = nullptr;
 32799:   nsresult rv = GetValueFromPlugin(NPPVpluginScriptableNPObject, &npobj);
 29953:   if (NS_FAILED(rv) || !npobj)
 29953:     return NS_ERROR_FAILURE;
 19246: 
 30212:   *outObject = nsNPObjWrapper::GetNewOrUsed(&mNPP, cx, npobj);
 19246: 
 19246:   _releaseobject(npobj);
 29953: 
 29953:   return NS_OK;
 19246: }
 19246: 
108534: void
 82172: nsNPAPIPluginInstance::SetCached(bool aCache)
 82172: {
 82172:   mCached = aCache;
 82172: }
 82172: 
 82172: bool
 82172: nsNPAPIPluginInstance::ShouldCache()
 82172: {
 82172:   return mCached;
 82172: }
 82172: 
 82172: nsresult
 79445: nsNPAPIPluginInstance::IsWindowless(bool* isWindowless)
 32799: {
 82142: #ifdef MOZ_WIDGET_ANDROID
 78424:   // On android, pre-honeycomb, all plugins are treated as windowless.
 79533:   *isWindowless = true;
 78424: #else
 32799:   *isWindowless = mWindowless;
 78424: #endif
 32799:   return NS_OK;
 32799: }
 32799: 
 62473: class NS_STACK_CLASS AutoPluginLibraryCall
 62473: {
 62473: public:
 62473:   AutoPluginLibraryCall(nsNPAPIPluginInstance* aThis)
106838:     : mThis(aThis), mGuard(aThis), mLibrary(nullptr)
 62473:   {
 62473:     nsNPAPIPlugin* plugin = mThis->GetPlugin();
 62473:     if (plugin)
 62473:       mLibrary = plugin->GetLibrary();
 62473:   }
 62473:   operator bool() { return !!mLibrary; }
 62473:   PluginLibrary* operator->() { return mLibrary; }
 62473: 
 62473: private:
 62473:   nsNPAPIPluginInstance* mThis;
 62473:   PluginDestructionGuard mGuard;
 62473:   PluginLibrary* mLibrary;
 62473: };
 62473: 
 70007: nsresult
 52409: nsNPAPIPluginInstance::AsyncSetWindow(NPWindow* window)
 52409: {
 52409:   if (RUNNING != mRunning)
 52409:     return NS_OK;
 52409: 
 62704:   AutoPluginLibraryCall library(this);
 52409:   if (!library)
 52409:     return NS_ERROR_FAILURE;
 52409: 
 52409:   return library->AsyncSetWindow(&mNPP, window);
 52409: }
 52409: 
 77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
 77498: nsresult
 77498: nsNPAPIPluginInstance::HandleGUIEvent(const nsGUIEvent& anEvent, bool* handled)
 77498: {
 77498:   if (RUNNING != mRunning) {
 77498:     *handled = false;
 77498:     return NS_OK;
 77498:   }
 77498: 
 77498:   AutoPluginLibraryCall library(this);
 77498:   if (!library)
 77498:     return NS_ERROR_FAILURE;
 77498: 
 77498:   return library->HandleGUIEvent(&mNPP, anEvent, handled);
 77498: }
 77498: #endif
 77498: 
 70007: nsresult
 89708: nsNPAPIPluginInstance::GetImageContainer(ImageContainer**aContainer)
 62473: {
106838:   *aContainer = nullptr;
 62981: 
 62473:   if (RUNNING != mRunning)
 62473:     return NS_OK;
 62473: 
 62473:   AutoPluginLibraryCall library(this);
 89708:   return !library ? NS_ERROR_FAILURE : library->GetImageContainer(&mNPP, aContainer);
 62473: }
 52409: 
 70007: nsresult
 62981: nsNPAPIPluginInstance::GetImageSize(nsIntSize* aSize)
 62981: {
 62981:   *aSize = nsIntSize(0, 0);
 62981: 
 62981:   if (RUNNING != mRunning)
 62981:     return NS_OK;
 62981: 
 62981:   AutoPluginLibraryCall library(this);
 62981:   return !library ? NS_ERROR_FAILURE : library->GetImageSize(&mNPP, aSize);
 62981: }
 62981: 
 70007: nsresult
 52409: nsNPAPIPluginInstance::NotifyPainted(void)
 52409: {
 57225:   NS_NOTREACHED("Dead code, shouldn't be called.");
 57225:   return NS_ERROR_NOT_IMPLEMENTED;
 52409: }
 52409: 
 70007: nsresult
115090: nsNPAPIPluginInstance::GetIsOOP(bool* aIsAsync)
 53941: {
 62704:   AutoPluginLibraryCall library(this);
 53941:   if (!library)
 53941:     return NS_ERROR_FAILURE;
 53941: 
107141:   *aIsAsync = library->IsOOP();
 57203:   return NS_OK;
 53941: }
 52409: 
 70007: nsresult
 62704: nsNPAPIPluginInstance::SetBackgroundUnknown()
 62704: {
 62704:   if (RUNNING != mRunning)
 62704:     return NS_OK;
 62704: 
 62704:   AutoPluginLibraryCall library(this);
 62704:   if (!library)
 62704:     return NS_ERROR_FAILURE;
 62704: 
 62704:   return library->SetBackgroundUnknown(&mNPP);
 62704: }
 62704: 
 70007: nsresult
 62704: nsNPAPIPluginInstance::BeginUpdateBackground(nsIntRect* aRect,
 62704:                                              gfxContext** aContext)
 62704: {
 62704:   if (RUNNING != mRunning)
 62704:     return NS_OK;
 62704: 
 62704:   AutoPluginLibraryCall library(this);
 62704:   if (!library)
 62704:     return NS_ERROR_FAILURE;
 62704: 
 62704:   return library->BeginUpdateBackground(&mNPP, *aRect, aContext);
 62704: }
 62704: 
 70007: nsresult
 62704: nsNPAPIPluginInstance::EndUpdateBackground(gfxContext* aContext,
 62704:                                            nsIntRect* aRect)
 62704: {
 62704:   if (RUNNING != mRunning)
 62704:     return NS_OK;
 62704: 
 62704:   AutoPluginLibraryCall library(this);
 62704:   if (!library)
 62704:     return NS_ERROR_FAILURE;
 62704: 
 62704:   return library->EndUpdateBackground(&mNPP, aContext, *aRect);
 62704: }
 62704: 
 70007: nsresult
 79445: nsNPAPIPluginInstance::IsTransparent(bool* isTransparent)
 32799: {
 32799:   *isTransparent = mTransparent;
 32799:   return NS_OK;
 32799: }
 32799: 
 70007: nsresult
 19246: nsNPAPIPluginInstance::GetFormValue(nsAString& aValue)
 19246: {
 19246:   aValue.Truncate();
 19246: 
106838:   char *value = nullptr;
 32799:   nsresult rv = GetValueFromPlugin(NPPVformValue, &value);
 29953:   if (NS_FAILED(rv) || !value)
 29953:     return NS_ERROR_FAILURE;
 19246: 
 19246:   CopyUTF8toUTF16(value, aValue);
 19246: 
 19246:   // NPPVformValue allocates with NPN_MemAlloc(), which uses
 19246:   // nsMemory.
 19246:   nsMemory::Free(value);
 19246: 
 19246:   return NS_OK;
 19246: }
 19246: 
 70007: nsresult
 79445: nsNPAPIPluginInstance::PushPopupsEnabledState(bool aEnabled)
 19246: {
 19246:   nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
 19246:   if (!window)
 29953:     return NS_ERROR_FAILURE;
 19246: 
 19246:   PopupControlState oldState =
 19246:     window->PushPopupControlState(aEnabled ? openAllowed : openAbused,
 79533:                                   true);
 19246: 
 26912:   if (!mPopupStates.AppendElement(oldState)) {
 29953:     // Appending to our state stack failed, pop what we just pushed.
 19246:     window->PopPopupControlState(oldState);
 29953:     return NS_ERROR_FAILURE;
 19246:   }
 19246: 
 29953:   return NS_OK;
 29953: }
 29953: 
 70007: nsresult
 19246: nsNPAPIPluginInstance::PopPopupsEnabledState()
 19246: {
108991:   int32_t last = mPopupStates.Length() - 1;
 19246: 
 19246:   if (last < 0) {
 19246:     // Nothing to pop.
 29953:     return NS_OK;
 19246:   }
 19246: 
 19246:   nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
 19246:   if (!window)
 29953:     return NS_ERROR_FAILURE;
 19246: 
 26912:   PopupControlState &oldState = mPopupStates[last];
 19246: 
 19246:   window->PopPopupControlState(oldState);
 19246: 
 19246:   mPopupStates.RemoveElementAt(last);
 29953:   
 29953:   return NS_OK;
 19246: }
 19246: 
 70007: nsresult
108991: nsNPAPIPluginInstance::GetPluginAPIVersion(uint16_t* version)
 19246: {
 29953:   NS_ENSURE_ARG_POINTER(version);
 47965: 
 47965:   if (!mPlugin)
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   if (!mPlugin->GetLibrary())
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
 47965: 
 47965:   *version = pluginFunctions->version;
 47965: 
 29953:   return NS_OK;
 19246: }
 24475: 
 29937: nsresult
 96781: nsNPAPIPluginInstance::PrivateModeStateChanged(bool enabled)
 24475: {
 39211:   if (RUNNING != mRunning)
 24475:     return NS_OK;
 24475: 
 24475:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance informing plugin of private mode state change this=%p\n",this));
 24475: 
 55810:   if (!mPlugin || !mPlugin->GetLibrary())
 47965:     return NS_ERROR_FAILURE;
 47965: 
 47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
 47965: 
 96781:   if (!pluginFunctions->setvalue)
 96781:     return NS_ERROR_FAILURE;
 96781: 
 24475:   PluginDestructionGuard guard(this);
 24475:     
 24475:   NPError error;
 96781:   NPBool value = static_cast<NPBool>(enabled);
 55810:   NS_TRY_SAFE_CALL_RETURN(error, (*pluginFunctions->setvalue)(&mNPP, NPNVprivateModeBool, &value), this);
 24475:   return (error == NPERR_NO_ERROR) ? NS_OK : NS_ERROR_FAILURE;
 24475: }
 29603: 
 78424: class DelayUnscheduleEvent : public nsRunnable {
 78424: public:
 78424:   nsRefPtr<nsNPAPIPluginInstance> mInstance;
 78424:   uint32_t mTimerID;
 78424:   DelayUnscheduleEvent(nsNPAPIPluginInstance* aInstance, uint32_t aTimerId)
 78424:     : mInstance(aInstance)
 78424:     , mTimerID(aTimerId)
 78424:   {}
 78424: 
 78424:   ~DelayUnscheduleEvent() {}
 78424: 
 78424:   NS_IMETHOD Run();
 78424: };
 78424: 
 78424: NS_IMETHODIMP
 78424: DelayUnscheduleEvent::Run()
 78424: {
 78424:   mInstance->UnscheduleTimer(mTimerID);
 78424:   return NS_OK;
 78424: }
 78424: 
 78424: 
 29937: static void
 29937: PluginTimerCallback(nsITimer *aTimer, void *aClosure)
 29937: {
 29937:   nsNPAPITimer* t = (nsNPAPITimer*)aClosure;
 29937:   NPP npp = t->npp;
 29937:   uint32_t id = t->id;
 29937: 
 78424:   // Some plugins (Flash on Android) calls unscheduletimer
 78424:   // from this callback.
 79533:   t->inCallback = true;
 29937:   (*(t->callback))(npp, id);
 79533:   t->inCallback = false;
 29937: 
 29937:   // Make sure we still have an instance and the timer is still alive
 29937:   // after the callback.
 29937:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
 29937:   if (!inst || !inst->TimerWithID(id, NULL))
 29937:     return;
 29937: 
 29937:   // use UnscheduleTimer to clean up if this is a one-shot timer
108991:   uint32_t timerType;
 29937:   t->timer->GetType(&timerType);
 29937:   if (timerType == nsITimer::TYPE_ONE_SHOT)
 29937:       inst->UnscheduleTimer(id);
 29937: }
 29937: 
 29937: nsNPAPITimer*
108991: nsNPAPIPluginInstance::TimerWithID(uint32_t id, uint32_t* index)
 29937: {
108991:   uint32_t len = mTimers.Length();
108991:   for (uint32_t i = 0; i < len; i++) {
 29937:     if (mTimers[i]->id == id) {
 29937:       if (index)
 29937:         *index = i;
 29937:       return mTimers[i];
 29937:     }
 29937:   }
106838:   return nullptr;
 29937: }
 29937: 
 29937: uint32_t
 29937: nsNPAPIPluginInstance::ScheduleTimer(uint32_t interval, NPBool repeat, void (*timerFunc)(NPP npp, uint32_t timerID))
 29937: {
113675:   if (RUNNING != mRunning)
113675:     return 0;
113675: 
 29937:   nsNPAPITimer *newTimer = new nsNPAPITimer();
 29937: 
 79533:   newTimer->inCallback = false;
 30212:   newTimer->npp = &mNPP;
 29937: 
 29937:   // generate ID that is unique to this instance
 29937:   uint32_t uniqueID = mTimers.Length();
 29937:   while ((uniqueID == 0) || TimerWithID(uniqueID, NULL))
 29937:     uniqueID++;
 29937:   newTimer->id = uniqueID;
 29937: 
 29937:   // create new xpcom timer, scheduled correctly
 29937:   nsresult rv;
 29937:   nsCOMPtr<nsITimer> xpcomTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
 41331:   if (NS_FAILED(rv)) {
 41331:     delete newTimer;
 29937:     return 0;
 41331:   }
 29937:   const short timerType = (repeat ? (short)nsITimer::TYPE_REPEATING_SLACK : (short)nsITimer::TYPE_ONE_SHOT);
 29937:   xpcomTimer->InitWithFuncCallback(PluginTimerCallback, newTimer, interval, timerType);
 29937:   newTimer->timer = xpcomTimer;
 29937: 
 29937:   // save callback function
 29937:   newTimer->callback = timerFunc;
 29937: 
 29937:   // add timer to timers array
 29937:   mTimers.AppendElement(newTimer);
 29937: 
 29937:   return newTimer->id;
 29937: }
 29937: 
 29937: void
 29937: nsNPAPIPluginInstance::UnscheduleTimer(uint32_t timerID)
 29937: {
 29937:   // find the timer struct by ID
108991:   uint32_t index;
 29937:   nsNPAPITimer* t = TimerWithID(timerID, &index);
 29937:   if (!t)
 29937:     return;
 29937: 
 78424:   if (t->inCallback) {
 78424:     nsCOMPtr<nsIRunnable> e = new DelayUnscheduleEvent(this, timerID);
 78424:     NS_DispatchToCurrentThread(e);
 78424:     return;
 78424:   }
 78424: 
 29937:   // cancel the timer
 29937:   t->timer->Cancel();
 29937: 
 29937:   // remove timer struct from array
 29937:   mTimers.RemoveElementAt(index);
 29937: 
 29937:   // delete timer
 29937:   delete t;
 29937: }
 29937: 
 32019: // Show the context menu at the location for the current event.
 32019: // This can only be called from within an NPP_SendEvent call.
 32019: NPError
 32019: nsNPAPIPluginInstance::PopUpContextMenu(NPMenu* menu)
 32019: {
 32019:   if (mOwner && mCurrentPluginEvent)
 32019:     return mOwner->ShowNativeContextMenu(menu, mCurrentPluginEvent);
 32019: 
 32019:   return NPERR_GENERIC_ERROR;
 32019: }
 32019: 
 32019: NPBool
 32019: nsNPAPIPluginInstance::ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
 32019:                                     double *destX, double *destY, NPCoordinateSpace destSpace)
 32019: {
 32019:   if (mOwner)
 32019:     return mOwner->ConvertPoint(sourceX, sourceY, sourceSpace, destX, destY, destSpace);
 32019: 
 79533:   return false;
 32019: }
 32019: 
 29834: nsresult
 29834: nsNPAPIPluginInstance::GetDOMElement(nsIDOMElement* *result)
 29834: {
 29834:   if (!mOwner) {
106838:     *result = nullptr;
 29834:     return NS_ERROR_FAILURE;
 29834:   }
 29834: 
115860:   return mOwner->GetDOMElement(result);
 29834: }
 29834: 
 70007: nsresult
 32799: nsNPAPIPluginInstance::InvalidateRect(NPRect *invalidRect)
 29603: {
 59576:   if (RUNNING != mRunning)
 59576:     return NS_OK;
 59576: 
115860:   if (!mOwner)
 29603:     return NS_ERROR_FAILURE;
 29603: 
115860:   return mOwner->InvalidateRect(invalidRect);
 29603: }
 29603: 
 70007: nsresult
 32799: nsNPAPIPluginInstance::InvalidateRegion(NPRegion invalidRegion)
 29603: {
 59576:   if (RUNNING != mRunning)
 59576:     return NS_OK;
 59576: 
115860:   if (!mOwner)
 29603:     return NS_ERROR_FAILURE;
 29603: 
115860:   return mOwner->InvalidateRegion(invalidRegion);
 29603: }
 29603: 
 70007: nsresult
 30224: nsNPAPIPluginInstance::GetMIMEType(const char* *result)
 29808: {
 29808:   if (!mMIMEType)
 29808:     *result = "";
 29808:   else
 29808:     *result = mMIMEType;
 29808: 
 29808:   return NS_OK;
 29808: }
 29808: 
 70007: nsresult
 29808: nsNPAPIPluginInstance::GetJSContext(JSContext* *outContext)
 29808: {
115860:   if (!mOwner)
 29808:     return NS_ERROR_FAILURE;
 29808: 
115860:   nsRefPtr<nsPluginInstanceOwner> deathGrip(mOwner);
115860: 
 29808:   *outContext = NULL;
 29808:   nsCOMPtr<nsIDocument> document;
 29808: 
115860:   nsresult rv = mOwner->GetDocument(getter_AddRefs(document));
 29808: 
 29808:   if (NS_SUCCEEDED(rv) && document) {
 29808:     nsIScriptGlobalObject *global = document->GetScriptGlobalObject();
 29808: 
 29808:     if (global) {
 29808:       nsIScriptContext *context = global->GetContext();
 29808: 
 29808:       if (context) {
 78415:         *outContext = context->GetNativeContext();
 29808:       }
 29808:     }
 29808:   }
 29808: 
 29808:   return rv;
 29808: }
 29834: 
115860: nsPluginInstanceOwner*
115860: nsNPAPIPluginInstance::GetOwner()
 29834: {
115860:   return mOwner;
 29834: }
 29834: 
115860: void
115860: nsNPAPIPluginInstance::SetOwner(nsPluginInstanceOwner *aOwner)
 29834: {
 29834:   mOwner = aOwner;
 29834: }
 29834: 
 70007: nsresult
 29834: nsNPAPIPluginInstance::ShowStatus(const char* message)
 29834: {
 29834:   if (mOwner)
 29834:     return mOwner->ShowStatus(message);
 29834: 
 29834:   return NS_ERROR_FAILURE;
 29834: }
 29834: 
 70007: nsresult
 52409: nsNPAPIPluginInstance::AsyncSetWindow(NPWindow& window)
 52409: {
 52409:   return NS_ERROR_NOT_IMPLEMENTED;
 52409: }
 60021: 
 60021: void
 60021: nsNPAPIPluginInstance::URLRedirectResponse(void* notifyData, NPBool allow)
 60021: {
 60021:   if (!notifyData) {
 60021:     return;
 60021:   }
 60021: 
108991:   uint32_t listenerCount = mStreamListeners.Length();
108991:   for (uint32_t i = 0; i < listenerCount; i++) {
 60021:     nsNPAPIPluginStreamListener* currentListener = mStreamListeners[i];
 60021:     if (currentListener->GetNotifyData() == notifyData) {
 60021:       currentListener->URLRedirectResponse(allow);
 60021:     }
 60021:   }
 60021: }
 61864: 
 91341: NPError
 91341: nsNPAPIPluginInstance::InitAsyncSurface(NPSize *size, NPImageFormat format,
 91341:                                         void *initData, NPAsyncSurface *surface)
 91341: {
 91341:   if (mOwner)
 91341:     return mOwner->InitAsyncSurface(size, format, initData, surface);
 91341: 
 92071:   return NPERR_GENERIC_ERROR;
 91341: }
 91341: 
 91341: NPError
 91341: nsNPAPIPluginInstance::FinalizeAsyncSurface(NPAsyncSurface *surface)
 91341: {
 91341:   if (mOwner)
 91341:     return mOwner->FinalizeAsyncSurface(surface);
 91341: 
 92071:   return NPERR_GENERIC_ERROR;
 91341: }
 91341: 
 91341: void
 91341: nsNPAPIPluginInstance::SetCurrentAsyncSurface(NPAsyncSurface *surface, NPRect *changed)
 91341: {
 91341:   if (mOwner)
 91341:     mOwner->SetCurrentAsyncSurface(surface, changed);
 91341: }
 91341: 
 61864: class CarbonEventModelFailureEvent : public nsRunnable {
 61864: public:
 61864:   nsCOMPtr<nsIContent> mContent;
 61864: 
 61864:   CarbonEventModelFailureEvent(nsIContent* aContent)
 61864:     : mContent(aContent)
 61864:   {}
 61864: 
 61864:   ~CarbonEventModelFailureEvent() {}
 61864: 
 61864:   NS_IMETHOD Run();
 61864: };
 61864: 
 61864: NS_IMETHODIMP
 61864: CarbonEventModelFailureEvent::Run()
 61864: {
 61864:   nsString type = NS_LITERAL_STRING("npapi-carbon-event-model-failure");
 61864:   nsContentUtils::DispatchTrustedEvent(mContent->GetDocument(), mContent,
 79533:                                        type, true, true);
 61864:   return NS_OK;
 61864: }
 61864: 
 61864: void
 61864: nsNPAPIPluginInstance::CarbonNPAPIFailure()
 61864: {
 61864:   nsCOMPtr<nsIDOMElement> element;
 61864:   GetDOMElement(getter_AddRefs(element));
 61864:   if (!element) {
 61864:     return;
 61864:   }
 61864: 
 61864:   nsCOMPtr<nsIContent> content(do_QueryInterface(element));
 61864:   if (!content) {
 61864:     return;
 61864:   }
 61864: 
 61864:   nsCOMPtr<nsIRunnable> e = new CarbonEventModelFailureEvent(content);
 61864:   nsresult rv = NS_DispatchToCurrentThread(e);
 61864:   if (NS_FAILED(rv)) {
 61864:     NS_WARNING("Failed to dispatch CarbonEventModelFailureEvent.");
 61864:   }
 61864: }
115799: 
116413: static bool
116413: GetJavaVersionFromMimetype(nsPluginTag* pluginTag, nsCString& version)
116413: {
116413:   for (uint32_t i = 0; i < pluginTag->mMimeTypes.Length(); ++i) {
116413:     nsCString type = pluginTag->mMimeTypes[i];
116413:     nsAutoCString jpi("application/x-java-applet;jpi-version=");
116413: 
116413:     int32_t idx = type.Find(jpi, false, 0, -1);
116413:     if (idx != 0) {
116413:       continue;
116413:     }
116413: 
116413:     type.Cut(0, jpi.Length());
116413:     if (type.IsEmpty()) {
116413:       continue;
116413:     }
116413: 
116413:     type.ReplaceChar('_', '.');
116413:     version = type;
116413:     return true;
116413:   }
116413: 
116413:   return false;
116413: }
116413: 
116413: void
116413: nsNPAPIPluginInstance::CheckJavaC2PJSObjectQuirk(uint16_t paramCount,
116413:                                                  const char* const* paramNames,
116413:                                                  const char* const* paramValues)
116413: {
116413:   if (!mMIMEType || !mPlugin) {
116413:     return;
116413:   }
116413: 
116413:   nsPluginTagType tagtype;
116413:   nsresult rv = GetTagType(&tagtype);
116413:   if (NS_FAILED(rv) ||
116413:       (tagtype != nsPluginTagType_Applet)) {
116413:     return;
116413:   }
116413: 
116413:   nsRefPtr<nsPluginHost> pluginHost =
116413:     already_AddRefed<nsPluginHost>(nsPluginHost::GetInst());
117590:   if (!pluginHost) {
117590:     return;
117590:   }
117590: 
117590:   bool isClickToPlay;
117590:   nsAutoCString mimeType(mMIMEType);
117590:   rv = pluginHost->IsPluginClickToPlayForType(mimeType, &isClickToPlay);
117590:   if (NS_FAILED(rv) || !isClickToPlay) {
116413:     return;
116413:   }
116413: 
116413:   nsPluginTag* pluginTag = pluginHost->TagForPlugin(mPlugin);
116413:   if (!pluginTag ||
116413:       !pluginTag->mIsJavaPlugin) {
116413:     return;
116413:   }
116413: 
116413:   // check the params for "code" being present and non-empty
116413:   bool haveCodeParam = false;
116413:   bool isCodeParamEmpty = true;
116413: 
116413:   for (uint16_t i = 0; i < paramCount; ++i) {
116413:     if (PL_strcasecmp(paramNames[i], "code") == 0) {
116413:       haveCodeParam = true;
116413:       if (PL_strlen(paramValues[i]) > 0) {
116413:         isCodeParamEmpty = false;
116413:       }
116413:       break;
116413:     }
116413:   }
116413: 
116413:   // Due to the Java version being specified inconsistently across platforms
116413:   // check the version via the mimetype for choosing specific Java versions
116413:   nsCString javaVersion;
116413:   if (!GetJavaVersionFromMimetype(pluginTag, javaVersion)) {
116413:     return;
116413:   }
116413: 
116413:   mozilla::Version version = javaVersion.get();
116413: 
116413:   if (version >= "1.7.0.4") {
116413:     return;
116413:   }
116413: 
116413:   if (!haveCodeParam && version >= "1.6.0.34" && version < "1.7") {
116413:     return;
116413:   }
116413: 
116413:   if (haveCodeParam && !isCodeParamEmpty) {
116413:     return;
116413:   }
116413: 
116413:   mHaveJavaC2PJSObjectQuirk = true;
116413: }
116413: 
115799: double
115799: nsNPAPIPluginInstance::GetContentsScaleFactor()
115799: {
115799:   double scaleFactor = 1.0;
115799:   if (mOwner) {
115799:     mOwner->GetContentsScaleFactor(&scaleFactor);
115799:   }
115799:   return scaleFactor;
115799: }
