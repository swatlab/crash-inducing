    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef nsBaseWidget_h__
    1: #define nsBaseWidget_h__
    1: 
    1: #include "nsRect.h"
    1: #include "nsIWidget.h"
51049: #include "nsWidgetsCID.h"
    1: #include "nsILocalFile.h"
    1: #include "nsString.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsGUIEvent.h"
30515: #include "nsAutoPtr.h"
47746: #include "BasicLayers.h"
    1: 
 8591: class nsIContent;
 8591: class nsAutoRollup;
38805: class gfxContext;
 8591: 
87729: namespace mozilla {
87729: namespace layers {
87729: class CompositorChild;
87729: class CompositorParent;
87729: }
87729: }
87729: 
87729: namespace base {
87729: class Thread;
87729: }
87729: 
    1: /**
    1:  * Common widget implementation used as base class for native
    1:  * or crossplatform implementations of Widgets. 
    1:  * All cross-platform behavior that all widgets need to implement 
    1:  * should be placed in this class. 
    1:  * (Note: widget implementations are not required to use this
    1:  * class, but it gives them a head start.)
    1:  */
    1: 
63893: class nsBaseWidget : public nsIWidget
    1: {
 8591:   friend class nsAutoRollup;
    1: 
47746: protected:
47746:   typedef mozilla::layers::BasicLayerManager BasicLayerManager;
87729:   typedef mozilla::layers::CompositorChild CompositorChild;
87729:   typedef mozilla::layers::CompositorParent CompositorParent;
87729:   typedef base::Thread Thread;
47746: 
    1: public:
    1:   nsBaseWidget();
    1:   virtual ~nsBaseWidget();
    1:   
    1:   NS_DECL_ISUPPORTS
    1:   
    1:   // nsIWidget interface
79445:   NS_IMETHOD              CaptureMouse(bool aCapture);
    1:   NS_IMETHOD              GetClientData(void*& aClientData);
    1:   NS_IMETHOD              SetClientData(void* aClientData);
    1:   NS_IMETHOD              Destroy();
    1:   NS_IMETHOD              SetParent(nsIWidget* aNewParent);
    1:   virtual nsIWidget*      GetParent(void);
31093:   virtual nsIWidget*      GetTopLevelWidget();
14886:   virtual nsIWidget*      GetSheetWindowParent(void);
50782:   virtual float           GetDPI();
50782:   virtual double          GetDefaultScale();
    1:   virtual void            AddChild(nsIWidget* aChild);
    1:   virtual void            RemoveChild(nsIWidget* aChild);
    1: 
    1:   NS_IMETHOD              SetZIndex(PRInt32 aZIndex);
    1:   NS_IMETHOD              GetZIndex(PRInt32* aZIndex);
    1:   NS_IMETHOD              PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
79445:                                       nsIWidget *aWidget, bool aActivate);
    1: 
    1:   NS_IMETHOD              SetSizeMode(PRInt32 aMode);
    1:   NS_IMETHOD              GetSizeMode(PRInt32* aMode);
    1: 
    1:   virtual nscolor         GetForegroundColor(void);
    1:   NS_IMETHOD              SetForegroundColor(const nscolor &aColor);
    1:   virtual nscolor         GetBackgroundColor(void);
    1:   NS_IMETHOD              SetBackgroundColor(const nscolor &aColor);
    1:   virtual nsCursor        GetCursor();
    1:   NS_IMETHOD              SetCursor(nsCursor aCursor);
    1:   NS_IMETHOD              SetCursor(imgIContainer* aCursor,
    1:                                     PRUint32 aHotspotX, PRUint32 aHotspotY);
    1:   NS_IMETHOD              GetWindowType(nsWindowType& aWindowType);
16601:   virtual void            SetTransparencyMode(nsTransparencyMode aMode);
16601:   virtual nsTransparencyMode GetTransparencyMode();
30515:   virtual void            GetWindowClipRegion(nsTArray<nsIntRect>* aRects);
20467:   NS_IMETHOD              SetWindowShadowStyle(PRInt32 aStyle);
79445:   virtual void            SetShowsToolbarButton(bool aShow) {}
79445:   NS_IMETHOD              HideWindowChrome(bool aShouldHide);
79445:   NS_IMETHOD              MakeFullScreen(bool aFullScreen);
68668:   virtual nsDeviceContext* GetDeviceContext();
75149:   virtual LayerManager*   GetLayerManager(PLayersChild* aShadowManager = nsnull,
75149:                                           LayersBackend aBackendHint = LayerManager::LAYERS_NONE,
75149:                                           LayerManagerPersistence aPersistence = LAYER_MANAGER_CURRENT,
58812:                                           bool* aAllowRetaining = nsnull);
63893: 
87729:   virtual void            CreateCompositor();
87886:   virtual void            DrawWindowOverlay(LayerManager* aManager, nsIntRect aRect) {}
60289:   virtual void            UpdateThemeGeometries(const nsTArray<ThemeGeometry>& aThemeGeometries) {}
    1:   virtual gfxASurface*    GetThebesSurface();
79445:   NS_IMETHOD              SetModal(bool aModal); 
    1:   NS_IMETHOD              SetWindowClass(const nsAString& xulWinType);
83107:   NS_IMETHOD              MoveClient(PRInt32 aX, PRInt32 aY);
83107:   NS_IMETHOD              ResizeClient(PRInt32 aWidth, PRInt32 aHeight, bool aRepaint);
83107:   NS_IMETHOD              ResizeClient(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, bool aRepaint);
23738:   NS_IMETHOD              SetBounds(const nsIntRect &aRect);
23738:   NS_IMETHOD              GetBounds(nsIntRect &aRect);
23738:   NS_IMETHOD              GetClientBounds(nsIntRect &aRect);
23738:   NS_IMETHOD              GetScreenBounds(nsIntRect &aRect);
83107:   NS_IMETHOD              GetNonClientMargins(nsIntMargin &margins);
83107:   NS_IMETHOD              SetNonClientMargins(nsIntMargin &margins);
48256:   virtual nsIntPoint      GetClientOffset();
79445:   NS_IMETHOD              EnableDragDrop(bool aEnable);
    1:   NS_IMETHOD              GetAttention(PRInt32 aCycleCount);
79445:   virtual bool            HasPendingInputEvent();
    1:   NS_IMETHOD              SetIcon(const nsAString &anIconSpec);
 6348:   NS_IMETHOD              BeginSecureKeyboardInput();
 6348:   NS_IMETHOD              EndSecureKeyboardInput();
79445:   NS_IMETHOD              SetWindowTitlebarColor(nscolor aColor, bool aActive);
79445:   virtual void            SetDrawsInTitlebar(bool aState) {}
79445:   virtual bool            ShowsResizeIndicator(nsIntRect* aResizerRect);
 6348:   virtual void            FreeNativeData(void * data, PRUint32 aDataType) {}
 8892:   NS_IMETHOD              BeginResizeDrag(nsGUIEvent* aEvent, PRInt32 aHorizontal, PRInt32 aVertical);
47857:   NS_IMETHOD              BeginMoveDrag(nsMouseEvent* aEvent);
15578:   virtual nsresult        ActivateNativeMenuItemAt(const nsAString& indexString) { return NS_ERROR_NOT_IMPLEMENTED; }
21081:   virtual nsresult        ForceUpdateNativeMenuAt(const nsAString& indexString) { return NS_ERROR_NOT_IMPLEMENTED; }
24836:   NS_IMETHOD              ResetInputState() { return NS_OK; }
24836:   NS_IMETHOD              CancelIMEComposition() { return NS_OK; }
79445:   NS_IMETHOD              SetAcceleratedRendering(bool aEnabled);
79445:   virtual bool            GetAcceleratedRendering();
79445:   virtual bool            GetShouldAccelerate();
79445:   NS_IMETHOD              GetToggledKeyState(PRUint32 aKeyCode, bool* aLEDState) { return NS_ERROR_NOT_IMPLEMENTED; }
79445:   NS_IMETHOD              OnIMEFocusChange(bool aFocus) { return NS_ERROR_NOT_IMPLEMENTED; }
24836:   NS_IMETHOD              OnIMETextChange(PRUint32 aStart, PRUint32 aOldEnd, PRUint32 aNewEnd) { return NS_ERROR_NOT_IMPLEMENTED; }
24836:   NS_IMETHOD              OnIMESelectionChange(void) { return NS_ERROR_NOT_IMPLEMENTED; }
80486:   virtual nsIMEUpdatePreference GetIMEUpdatePreference() { return nsIMEUpdatePreference(false, false); }
30327:   NS_IMETHOD              OnDefaultButtonLoaded(const nsIntRect &aButtonRect) { return NS_ERROR_NOT_IMPLEMENTED; }
79445:   NS_IMETHOD              OverrideSystemMouseScrollSpeed(PRInt32 aOriginalDelta, bool aIsHorizontal, PRInt32 &aOverriddenDelta);
51049:   virtual already_AddRefed<nsIWidget>
51049:   CreateChild(const nsIntRect  &aRect,
51049:               EVENT_CALLBACK   aHandleEventFunction,
68668:               nsDeviceContext *aContext,
51049:               nsWidgetInitData *aInitData = nsnull,
79445:               bool             aForceUseIWidgetParent = false);
68668:   NS_IMETHOD              AttachViewToTopLevel(EVENT_CALLBACK aViewEventFunction, nsDeviceContext *aContext);
46192:   virtual ViewWrapper*    GetAttachedViewPtr();
46192:   NS_IMETHOD              SetAttachedViewPtr(ViewWrapper* aViewWrapper);
48711:   NS_IMETHOD              RegisterTouchWindow();
48711:   NS_IMETHOD              UnregisterTouchWindow();
    1: 
48254:   nsPopupLevel PopupLevel() { return mPopupLevel; }
48254: 
48256:   virtual nsIntSize       ClientToWindowSize(const nsIntSize& aClientSize)
48256:   {
48256:     return aClientSize;
48256:   }
48256: 
48256:   // return true if this is a popup widget with a native titlebar
79445:   bool IsPopupWithTitleBar() const
48256:   {
48256:     return (mWindowType == eWindowType_popup && 
48256:             mBorderStyle != eBorderStyle_default &&
48256:             mBorderStyle & eBorderStyle_title);
48256:   }
48256: 
54312:   NS_IMETHOD              ReparentNativeWidget(nsIWidget* aNewParent) = 0;
88239: 
88239:   virtual PRUint32 GetGLFrameBufferFormat() MOZ_OVERRIDE;
88239: 
38805:   /**
38805:    * Use this when GetLayerManager() returns a BasicLayerManager
38805:    * (nsBaseWidget::GetLayerManager() does). This sets up the widget's
38805:    * layer manager to temporarily render into aTarget.
38805:    */
38805:   class AutoLayerManagerSetup {
38805:   public:
47746:     AutoLayerManagerSetup(nsBaseWidget* aWidget, gfxContext* aTarget,
47746:                           BasicLayerManager::BufferMode aDoubleBuffering);
38805:     ~AutoLayerManagerSetup();
38805:   private:
38805:     nsBaseWidget* mWidget;
38805:   };
38805:   friend class AutoLayerManagerSetup;
38805: 
55858:   class AutoUseBasicLayerManager {
55858:   public:
55858:     AutoUseBasicLayerManager(nsBaseWidget* aWidget);
55858:     ~AutoUseBasicLayerManager();
55858:   private:
55858:     nsBaseWidget* mWidget;
55858:   };
55858:   friend class AutoUseBasicLayerManager;
55858: 
79445:   bool HasDestroyStarted() const 
79413:   {
79413:     return mOnDestroyCalled;
79413:   }
79413: 
79445:   bool                    Destroyed() { return mOnDestroyCalled; }
78623: 
    1: protected:
    1: 
    1:   virtual void            ResolveIconName(const nsAString &aIconName,
    1:                                           const nsAString &aIconSuffix,
    1:                                           nsILocalFile **aResult);
    1:   virtual void            OnDestroy();
    1:   virtual void            BaseCreate(nsIWidget *aParent,
23738:                                      const nsIntRect &aRect,
    1:                                      EVENT_CALLBACK aHandleEventFunction,
68668:                                      nsDeviceContext *aContext,
    1:                                      nsWidgetInitData *aInitData);
    1: 
 8591:   virtual nsIContent* GetLastRollup()
 8591:   {
 8591:     return mLastRollup;
 8591:   }
 8591: 
14998:   virtual nsresult SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
14962:                                             PRInt32 aNativeKeyCode,
14962:                                             PRUint32 aModifierFlags,
14962:                                             const nsAString& aCharacters,
14998:                                             const nsAString& aUnmodifiedCharacters)
14998:   { return NS_ERROR_UNEXPECTED; }
14962: 
32976:   virtual nsresult SynthesizeNativeMouseEvent(nsIntPoint aPoint,
32976:                                               PRUint32 aNativeMessage,
32976:                                               PRUint32 aModifierFlags)
32976:   { return NS_ERROR_UNEXPECTED; }
32976: 
30688:   // Stores the clip rectangles in aRects into mClipRects. Returns true
30688:   // if the new rectangles are different from the old rectangles.
79445:   bool StoreWindowClipRegion(const nsTArray<nsIntRect>& aRects);
30515: 
51049:   virtual already_AddRefed<nsIWidget>
51049:   AllocateChildPopupWidget()
51049:   {
51049:     static NS_DEFINE_IID(kCPopUpCID, NS_CHILD_CID);
51049:     nsCOMPtr<nsIWidget> widget = do_CreateInstance(kCPopUpCID);
51049:     return widget.forget();
51049:   }
51049: 
54111:   BasicLayerManager* CreateBasicLayerManager();
54111: 
    1: protected:
    1:   void*             mClientData;
46192:   ViewWrapper*      mViewWrapperPtr;
    1:   EVENT_CALLBACK    mEventCallback;
46192:   EVENT_CALLBACK    mViewCallback;
68668:   nsDeviceContext* mContext;
38805:   nsRefPtr<LayerManager> mLayerManager;
55858:   nsRefPtr<LayerManager> mBasicLayerManager;
87729:   nsRefPtr<CompositorChild> mCompositorChild;
87729:   nsRefPtr<CompositorParent> mCompositorParent;
87729:   Thread*           mCompositorThread;
    1:   nscolor           mBackground;
    1:   nscolor           mForeground;
    1:   nsCursor          mCursor;
    1:   nsWindowType      mWindowType;
    1:   nsBorderStyle     mBorderStyle;
79445:   bool              mOnDestroyCalled;
79445:   bool              mUseAcceleratedRendering;
88849:   bool              mForceLayersAcceleration;
79445:   bool              mTemporarilyUseBasicLayerManager;
23738:   nsIntRect         mBounds;
23738:   nsIntRect*        mOriginalBounds;
30515:   // When this pointer is null, the widget is not clipped
30515:   nsAutoArrayPtr<nsIntRect> mClipRects;
35698:   PRUint32          mClipRectCount;
    1:   PRInt32           mZIndex;
    1:   nsSizeMode        mSizeMode;
48254:   nsPopupLevel      mPopupLevel;
    1: 
 8591:   // the last rolled up popup. Only set this when an nsAutoRollup is in scope,
 8591:   // so it can be cleared automatically.
 8591:   static nsIContent* mLastRollup;
 8591: 
    1: #ifdef DEBUG
    1: protected:
    1:   static nsAutoString debug_GuiEventToString(nsGUIEvent * aGuiEvent);
79445:   static bool debug_WantPaintFlashing();
    1: 
    1:   static void debug_DumpInvalidate(FILE *                aFileOut,
    1:                                    nsIWidget *           aWidget,
23738:                                    const nsIntRect *     aRect,
    1:                                    const nsCAutoString & aWidgetName,
    1:                                    PRInt32               aWindowID);
    1: 
    1:   static void debug_DumpEvent(FILE *                aFileOut,
    1:                               nsIWidget *           aWidget,
    1:                               nsGUIEvent *          aGuiEvent,
    1:                               const nsCAutoString & aWidgetName,
    1:                               PRInt32               aWindowID);
    1: 
    1:   static void debug_DumpPaintEvent(FILE *                aFileOut,
    1:                                    nsIWidget *           aWidget,
    1:                                    nsPaintEvent *        aPaintEvent,
    1:                                    const nsCAutoString & aWidgetName,
    1:                                    PRInt32               aWindowID);
    1: 
79445:   static bool debug_GetCachedBoolPref(const char* aPrefName);
    1: #endif
    1: };
    1: 
 8591: // A situation can occur when a mouse event occurs over a menu label while the
 8591: // menu popup is already open. The expected behaviour is to close the popup.
 8591: // This happens by calling nsIRollupListener::Rollup before the mouse event is
 8591: // processed. However, in cases where the mouse event is not consumed, this
 8591: // event will then get targeted at the menu label causing the menu to open
 8591: // again. To prevent this, we store in mLastRollup a reference to the popup
 8591: // that was closed during the Rollup call, and prevent this popup from
 8591: // reopening while processing the mouse event.
 8591: // mLastRollup should only be set while an nsAutoRollup is in scope;
 8591: // when it goes out of scope mLastRollup is cleared automatically.
 8591: // As mLastRollup is static, it can be retrieved by calling
 8591: // nsIWidget::GetLastRollup on any widget.
 8591: class nsAutoRollup
 8591: {
79445:   bool wasClear;
 8591: 
 8591:   public:
 8591: 
 8591:   nsAutoRollup();
 8591:   ~nsAutoRollup();
 8591: };
 8591: 
    1: #endif // nsBaseWidget_h__
