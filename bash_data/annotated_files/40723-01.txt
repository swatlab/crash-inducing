36092: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
36166:  */
35734: /* ***** BEGIN LICENSE BLOCK *****
35734:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35734:  *
35734:  * The contents of this file are subject to the Mozilla Public License Version
35734:  * 1.1 (the "License"); you may not use this file except in compliance with
35734:  * the License. You may obtain a copy of the License at
35734:  * http://www.mozilla.org/MPL/
35734:  *
35734:  * Software distributed under the License is distributed on an "AS IS" basis,
35734:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35734:  * for the specific language governing rights and limitations under the
35734:  * License.
35734:  *
35734:  * The Original Code is Mozilla IPC.
35734:  *
35734:  * The Initial Developer of the Original Code is
35734:  *   Ben Turner <bent.mozilla@gmail.com>.
35734:  * Portions created by the Initial Developer are Copyright (C) 2009
35734:  * the Initial Developer. All Rights Reserved.
35734:  *
35734:  * Contributor(s):
35734:  *
35734:  * Alternatively, the contents of this file may be used under the terms of
35734:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35734:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35734:  * in which case the provisions of the GPL or the LGPL are applicable instead
35734:  * of those above. If you wish to allow use of your version of this file only
35734:  * under the terms of either the GPL or the LGPL, and not to allow others to
35734:  * use your version of this file under the terms of the MPL, indicate your
35734:  * decision by deleting the provisions above and replace them with the notice
35734:  * and other provisions required by the GPL or the LGPL. If you do not delete
35734:  * the provisions above, a recipient may use your version of this file under
35734:  * the terms of any one of the MPL, the GPL or the LGPL.
35734:  *
35734:  * ***** END LICENSE BLOCK ***** */
35734: 
35734: #include "GeckoChildProcessHost.h"
35734: 
35734: #include "base/command_line.h"
35734: #include "base/path_service.h"
35766: #include "base/string_util.h"
35734: #include "chrome/common/chrome_switches.h"
36096: #include "chrome/common/process_watcher.h"
35734: 
36016: #include "prprf.h"
36016: 
37203: #if defined(OS_LINUX)
37203: #  define XP_LINUX 1
37203: #endif
37203: #include "nsExceptionHandler.h"
37203: 
40628: #include "nsDirectoryServiceDefs.h"
40628: #include "nsIFile.h"
40628: 
37884: #include "mozilla/ipc/BrowserProcessSubThread.h"
35801: 
35801: using mozilla::MonitorAutoEnter;
35734: using mozilla::ipc::GeckoChildProcessHost;
35734: 
35801: template<>
35801: struct RunnableMethodTraits<GeckoChildProcessHost>
35801: {
35801:     static void RetainCallee(GeckoChildProcessHost* obj) { }
35801:     static void ReleaseCallee(GeckoChildProcessHost* obj) { }
35801: };
35801: 
35887: GeckoChildProcessHost::GeckoChildProcessHost(GeckoProcessType aProcessType,
35887:                                              base::WaitableEventWatcher::Delegate* aDelegate)
35766:   : ChildProcessHost(RENDER_PROCESS), // FIXME/cjones: we should own this enum
35801:     mProcessType(aProcessType),
35801:     mMonitor("mozilla.ipc.GeckChildProcessHost.mMonitor"),
35887:     mLaunched(false),
36092:     mChannelInitialized(false),
36016:     mDelegate(aDelegate),
36016:     mChildProcessHandle(0)
35734: {
36063:     MOZ_COUNT_CTOR(GeckoChildProcessHost);
36092:     
36092:     MessageLoop* ioLoop = 
36092:       BrowserProcessSubThread::GetMessageLoop(BrowserProcessSubThread::IO);
36092:     ioLoop->PostTask(FROM_HERE,
36092:                      NewRunnableMethod(this,
36092:                                        &GeckoChildProcessHost::InitializeChannel));
36063: }
36063: 
36063: GeckoChildProcessHost::~GeckoChildProcessHost()
36610: 
36063: {
36610:   AssertIOThread();
36610: 
36063:   MOZ_COUNT_DTOR(GeckoChildProcessHost);
36096: 
36165:   if (mChildProcessHandle > 0)
37240:     ProcessWatcher::EnsureProcessTerminated(mChildProcessHandle
37479: #if defined(NS_BUILD_REFCNT_LOGGING)
37240:                                             , false // don't "force"
37240: #endif
37240:     );
35734: }
35734: 
35734: bool
36050: GeckoChildProcessHost::SyncLaunch(std::vector<std::string> aExtraOpts)
35734: {
35801:   MessageLoop* ioLoop = 
35801:     BrowserProcessSubThread::GetMessageLoop(BrowserProcessSubThread::IO);
36050:   NS_ASSERTION(MessageLoop::current() != ioLoop, "sync launch from the IO thread NYI");
35801: 
35801:   ioLoop->PostTask(FROM_HERE,
35801:                    NewRunnableMethod(this,
36092:                                      &GeckoChildProcessHost::PerformAsyncLaunch,
35801:                                      aExtraOpts));
35801: 
35801:   // NB: this uses a different mechanism than the chromium parent
35801:   // class.
35801:   MonitorAutoEnter mon(mMonitor);
35801:   while (!mLaunched) {
35801:     mon.Wait();
35801:   }
35801: 
35801:   return true;
35801: }
35801: 
35801: bool
36050: GeckoChildProcessHost::AsyncLaunch(std::vector<std::string> aExtraOpts)
35801: {
36092:   MessageLoop* ioLoop = 
36092:     BrowserProcessSubThread::GetMessageLoop(BrowserProcessSubThread::IO);
36092:   ioLoop->PostTask(FROM_HERE,
36092:                    NewRunnableMethod(this,
36092:                                      &GeckoChildProcessHost::PerformAsyncLaunch,
36092:                                      aExtraOpts));
36092: 
36092:   // This may look like the sync launch wait, but we only delay as
36092:   // long as it takes to create the channel.
36092:   MonitorAutoEnter mon(mMonitor);
36092:   while (!mChannelInitialized) {
36092:     mon.Wait();
36092:   }
36092: 
36092:   return true;
36092: }
36092: 
36092: void
36092: GeckoChildProcessHost::InitializeChannel()
36092: {
36092:   CreateChannel();
36092: 
36092:   MonitorAutoEnter mon(mMonitor);
36092:   mChannelInitialized = true;
36092:   mon.Notify();
36092: }
36092: 
36092: bool
36092: GeckoChildProcessHost::PerformAsyncLaunch(std::vector<std::string> aExtraOpts)
36092: {
35801:   // FIXME/cjones: make this work from non-IO threads, too
35801: 
36092:   // We rely on the fact that InitializeChannel() has already been processed
36092:   // on the IO thread before this point is reached.
36092:   if (!GetChannel()) {
35734:     return false;
35734:   }
35734: 
36050:   base::ProcessHandle process;
36050: 
36050:   // send the child the PID so that it can open a ProcessHandle back to us.
36050:   // probably don't want to do this in the long run
36050:   char pidstring[32];
36050:   PR_snprintf(pidstring, sizeof(pidstring) - 1,
36050: 	      "%ld", base::Process::Current().pid());
36050: 
36050:   const char* const childProcessType =
36050:       XRE_ChildProcessTypeToString(mProcessType);
36050: 
36050: //--------------------------------------------------
36050: #if defined(OS_POSIX)
36050:   // For POSIX, we have to be extremely anal about *not* using
36050:   // std::wstring in code compiled with Mozilla's -fshort-wchar
36050:   // configuration, because chromium is compiled with -fno-short-wchar
36050:   // and passing wstrings from one config to the other is unsafe.  So
36050:   // we split the logic here.
36050: 
39465:   FilePath exePath;
40630: #ifdef OS_LINUX
40629:   base::environment_map newEnvVars;
40630: #endif
39465: 
39465:   nsCOMPtr<nsIProperties> directoryService(do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
39465:   nsCOMPtr<nsIFile> greDir;
39465:   nsresult rv = directoryService->Get(NS_GRE_DIR, NS_GET_IID(nsIFile), getter_AddRefs(greDir));
40628:   if (NS_SUCCEEDED(rv)) {
39465:     nsCString path;
39465:     greDir->GetNativePath(path);
39465:     exePath = FilePath(path.get());
40628: #ifdef OS_LINUX
40628:     newEnvVars["LD_LIBRARY_PATH"] = path.get();
40628: #endif
39465:   }
40628:   else {
39465:     exePath = FilePath(CommandLine::ForCurrentProcess()->argv()[0]);
36050:     exePath = exePath.DirName();
39465:   }
36050:   exePath = exePath.AppendASCII(MOZ_CHILD_PROCESS_NAME);
36050: 
36050:   // remap the IPC socket fd to a well-known int, as the OS does for
36050:   // STDOUT_FILENO, for example
36050:   int srcChannelFd, dstChannelFd;
36050:   channel().GetClientFileDescriptorMapping(&srcChannelFd, &dstChannelFd);
36050:   mFileMap.push_back(std::pair<int,int>(srcChannelFd, dstChannelFd));
36050: 
36050:   // no need for kProcessChannelID, the child process inherits the
36050:   // other end of the socketpair() from us
36050: 
36050:   std::vector<std::string> childArgv;
36050: 
36050:   childArgv.push_back(exePath.value());
36050: 
36050:   childArgv.insert(childArgv.end(), aExtraOpts.begin(), aExtraOpts.end());
36050: 
36050:   childArgv.push_back(pidstring);
36050:   childArgv.push_back(childProcessType);
36050: 
40723: #if defined(MOZ_CRASHREPORTER)
40723: #  if defined(OS_LINUX)
37203:   int childCrashFd, childCrashRemapFd;
37203:   if (!CrashReporter::CreateNotificationPipeForChild(
37203:         &childCrashFd, &childCrashRemapFd))
37203:     return false;
37203:   if (0 <= childCrashFd) {
37203:     mFileMap.push_back(std::pair<int,int>(childCrashFd, childCrashRemapFd));
37203:     // "true" == crash reporting enabled
37203:     childArgv.push_back("true");
37203:   }
37203:   else {
37203:     // "false" == crash reporting disabled
37203:     childArgv.push_back("false");
37203:   }
40723: #  elif defined(XP_MACOSX)
40723:   // Call the stub for initialization side effects.  Eventually this
40723:   // code will be unified with that above.
40723:   CrashReporter::CreateNotificationPipeForChild();
40723: #  endif  // OS_LINUX
37203: #endif
37203: 
40628:   base::LaunchApp(childArgv, mFileMap,
40628: #ifdef OS_LINUX
40628:                   newEnvVars,
40628: #endif
40628:                   false, &process);
36050: 
36050: //--------------------------------------------------
36050: #elif defined(OS_WIN)
36050: 
35734:   FilePath exePath =
35734:     FilePath::FromWStringHack(CommandLine::ForCurrentProcess()->program());
35734:   exePath = exePath.DirName();
35734: 
35766:   exePath = exePath.AppendASCII(MOZ_CHILD_PROCESS_NAME);
35734: 
35734:   CommandLine cmdLine(exePath.ToWStringHack());
35734:   cmdLine.AppendSwitchWithValue(switches::kProcessChannelID, channel_id());
35734: 
36050:   for (std::vector<std::string>::iterator it = aExtraOpts.begin();
35766:        it != aExtraOpts.end();
35766:        ++it) {
36050:       cmdLine.AppendLooseValue(UTF8ToWide(*it));
35766:   }
35766: 
36016:   cmdLine.AppendLooseValue(UTF8ToWide(pidstring));
36050:   cmdLine.AppendLooseValue(UTF8ToWide(childProcessType));
37203: #if defined(MOZ_CRASHREPORTER)
37203:   cmdLine.AppendLooseValue(
37208:     UTF8ToWide(CrashReporter::GetChildNotificationPipe()));
37203: #endif
36016: 
36050:   base::LaunchApp(cmdLine, false, false, &process);
35766: 
35734: #else
36050: #  error Sorry
35734: #endif
35734: 
35734:   if (!process) {
35734:     return false;
35734:   }
35734:   SetHandle(process);
35734: 
35734:   return true;
35734: }
35734: 
35734: void
35779: GeckoChildProcessHost::OnChannelConnected(int32 peer_pid)
35779: {
35801:   MonitorAutoEnter mon(mMonitor);
35801:   mLaunched = true;
36016: 
39798:   if (!base::OpenPrivilegedProcessHandle(peer_pid, &mChildProcessHandle))
36016:       NS_RUNTIMEABORT("can't open handle to child process");
36016: 
35801:   mon.Notify();
35779: }
35801: 
35801: // XXX/cjones: these next two methods should basically never be called.
35801: // after the process is launched, its channel will be used to create
35801: // one of our channels, AsyncChannel et al.
35779: void
35734: GeckoChildProcessHost::OnMessageReceived(const IPC::Message& aMsg)
35734: {
35734: }
35734: void
35734: GeckoChildProcessHost::OnChannelError()
35734: {
35734:   // XXXbent Notify that the child process is gone?
35734: }
35887: 
35887: void
35887: GeckoChildProcessHost::OnWaitableEventSignaled(base::WaitableEvent *event)
35887: {
35887:   if (mDelegate) {
35887:     mDelegate->OnWaitableEventSignaled(event);
35887:   }
35887:   ChildProcessHost::OnWaitableEventSignaled(event);
35887: }
