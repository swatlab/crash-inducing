    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* Private maps (hashtables). */
    1: 
    1: #ifndef xpcmaps_h___
    1: #define xpcmaps_h___
    1: 
    1: // Maps...
    1: 
    1: // Note that most of the declarations for hash table entries begin with
    1: // a pointer to something or another. This makes them look enough like
    1: // the JSDHashEntryStub struct that the default OPs (JS_DHashGetStubOps())
    1: // just do the right thing for most of our needs.
    1: 
    1: // no virtuals in the maps - all the common stuff inlined
    1: // templates could be used to good effect here.
    1: 
    1: class JSContext2XPCContextMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         JSContext*  key;
    1:         XPCContext* value;
    1:     };
    1: 
    1:     static JSContext2XPCContextMap* newMap(int size);
    1: 
    1:     inline XPCContext* Find(JSContext* cx)
    1:     {
    1:         NS_PRECONDITION(cx,"bad param");
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, cx, JS_DHASH_LOOKUP);
    1:         if(JS_DHASH_ENTRY_IS_FREE(entry))
    1:             return nsnull;
    1:         return entry->value;
    1:     }
    1: 
    1:     inline XPCContext* Add(XPCContext* xpcc)
    1:     {
    1:         NS_PRECONDITION(xpcc,"bad param");
    1:         JSContext* cx = xpcc->GetJSContext();
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, cx, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key)
    1:             return entry->value;
    1:         entry->key = cx;
    1:         entry->value = xpcc;
    1:         return xpcc;
    1:     }
    1: 
    1:     inline void Remove(XPCContext* xpcc)
    1:     {
    1:         NS_PRECONDITION(xpcc,"bad param");
    1:         JS_DHashTableOperate(mTable, xpcc->GetJSContext(), JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~JSContext2XPCContextMap();
    1: private:
    1:     JSContext2XPCContextMap();    // no implementation
    1:     JSContext2XPCContextMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /*************************/
    1: 
    1: class JSObject2WrappedJSMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         JSObject*       key;
    1:         nsXPCWrappedJS* value;
    1:     };
    1: 
    1:     static JSObject2WrappedJSMap* newMap(int size);
    1: 
    1:     inline nsXPCWrappedJS* Find(JSObject* Obj)
    1:     {
    1:         NS_PRECONDITION(Obj,"bad param");
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, Obj, JS_DHASH_LOOKUP);
    1:         if(JS_DHASH_ENTRY_IS_FREE(entry))
    1:             return nsnull;
    1:         return entry->value;
    1:     }
    1: 
    1:     inline nsXPCWrappedJS* Add(nsXPCWrappedJS* wrapper)
    1:     {
    1:         NS_PRECONDITION(wrapper,"bad param");
    1:         JSObject* obj = wrapper->GetJSObject();
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, obj, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key)
    1:             return entry->value;
    1:         entry->key = obj;
    1:         entry->value = wrapper;
    1:         return wrapper;
    1:     }
    1: 
    1:     inline void Remove(nsXPCWrappedJS* wrapper)
    1:     {
    1:         NS_PRECONDITION(wrapper,"bad param");
    1:         JS_DHashTableOperate(mTable, wrapper->GetJSObject(), JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~JSObject2WrappedJSMap();
    1: private:
    1:     JSObject2WrappedJSMap();    // no implementation
    1:     JSObject2WrappedJSMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /*************************/
    1: 
    1: class Native2WrappedNativeMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         nsISupports*      key;
    1:         XPCWrappedNative* value;
    1:     };
    1: 
    1:     static Native2WrappedNativeMap* newMap(int size);
    1: 
    1:     inline XPCWrappedNative* Find(nsISupports* Obj)
    1:     {
    1:         NS_PRECONDITION(Obj,"bad param");
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, Obj, JS_DHASH_LOOKUP);
    1:         if(JS_DHASH_ENTRY_IS_FREE(entry))
    1:             return nsnull;
    1:         return entry->value;
    1:     }
    1: 
    1:     inline XPCWrappedNative* Add(XPCWrappedNative* wrapper)
    1:     {
    1:         NS_PRECONDITION(wrapper,"bad param");
    1:         nsISupports* obj = wrapper->GetIdentityObject();
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, obj, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key)
    1:             return entry->value;
    1:         entry->key = obj;
    1:         entry->value = wrapper;
    1:         return wrapper;
    1:     }
    1: 
    1:     inline void Remove(XPCWrappedNative* wrapper)
    1:     {
    1:         NS_PRECONDITION(wrapper,"bad param");
14986: #ifdef DEBUG
14986:         XPCWrappedNative* wrapperInMap = Find(wrapper->GetIdentityObject());
14986:         NS_ASSERTION(!wrapperInMap || wrapperInMap == wrapper,
14986:                      "About to remove a different wrapper with the same "
14986:                      "nsISupports identity! This will most likely cause serious "
14986:                      "problems!");
14986: #endif
    1:         JS_DHashTableOperate(mTable, wrapper->GetIdentityObject(), JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~Native2WrappedNativeMap();
    1: private:
    1:     Native2WrappedNativeMap();    // no implementation
    1:     Native2WrappedNativeMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /*************************/
    1: 
    1: class IID2WrappedJSClassMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         const nsIID*         key;
    1:         nsXPCWrappedJSClass* value;
    1: 
    1:         static struct JSDHashTableOps sOps;
    1:     };
    1: 
    1:     static IID2WrappedJSClassMap* newMap(int size);
    1: 
    1:     inline nsXPCWrappedJSClass* Find(REFNSIID iid)
    1:     {
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, &iid, JS_DHASH_LOOKUP);
    1:         if(JS_DHASH_ENTRY_IS_FREE(entry))
    1:             return nsnull;
    1:         return entry->value;
    1:     }
    1: 
    1:     inline nsXPCWrappedJSClass* Add(nsXPCWrappedJSClass* clazz)
    1:     {
    1:         NS_PRECONDITION(clazz,"bad param");
    1:         const nsIID* iid = &clazz->GetIID();
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, iid, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key)
    1:             return entry->value;
    1:         entry->key = iid;
    1:         entry->value = clazz;
    1:         return clazz;
    1:     }
    1: 
    1:     inline void Remove(nsXPCWrappedJSClass* clazz)
    1:     {
    1:         NS_PRECONDITION(clazz,"bad param");
    1:         JS_DHashTableOperate(mTable, &clazz->GetIID(), JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~IID2WrappedJSClassMap();
    1: private:
    1:     IID2WrappedJSClassMap();    // no implementation
    1:     IID2WrappedJSClassMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /*************************/
    1: 
    1: class IID2NativeInterfaceMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         const nsIID*        key;
    1:         XPCNativeInterface* value;
    1: 
    1:         static struct JSDHashTableOps sOps;
    1:     };
    1: 
    1:     static IID2NativeInterfaceMap* newMap(int size);
    1: 
    1:     inline XPCNativeInterface* Find(REFNSIID iid)
    1:     {
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, &iid, JS_DHASH_LOOKUP);
    1:         if(JS_DHASH_ENTRY_IS_FREE(entry))
    1:             return nsnull;
    1:         return entry->value;
    1:     }
    1: 
    1:     inline XPCNativeInterface* Add(XPCNativeInterface* iface)
    1:     {
    1:         NS_PRECONDITION(iface,"bad param");
    1:         const nsIID* iid = iface->GetIID();
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, iid, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key)
    1:             return entry->value;
    1:         entry->key = iid;
    1:         entry->value = iface;
    1:         return iface;
    1:     }
    1: 
    1:     inline void Remove(XPCNativeInterface* iface)
    1:     {
    1:         NS_PRECONDITION(iface,"bad param");
    1:         JS_DHashTableOperate(mTable, iface->GetIID(), JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~IID2NativeInterfaceMap();
    1: private:
    1:     IID2NativeInterfaceMap();    // no implementation
    1:     IID2NativeInterfaceMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /*************************/
    1: 
    1: class ClassInfo2NativeSetMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         nsIClassInfo* key;
    1:         XPCNativeSet* value;
    1:     };
    1: 
    1:     static ClassInfo2NativeSetMap* newMap(int size);
    1: 
    1:     inline XPCNativeSet* Find(nsIClassInfo* info)
    1:     {
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, info, JS_DHASH_LOOKUP);
    1:         if(JS_DHASH_ENTRY_IS_FREE(entry))
    1:             return nsnull;
    1:         return entry->value;
    1:     }
    1: 
    1:     inline XPCNativeSet* Add(nsIClassInfo* info, XPCNativeSet* set)
    1:     {
    1:         NS_PRECONDITION(info,"bad param");
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, info, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key)
    1:             return entry->value;
    1:         entry->key = info;
    1:         entry->value = set;
    1:         return set;
    1:     }
    1: 
    1:     inline void Remove(nsIClassInfo* info)
    1:     {
    1:         NS_PRECONDITION(info,"bad param");
    1:         JS_DHashTableOperate(mTable, info, JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~ClassInfo2NativeSetMap();
    1: private:
    1:     ClassInfo2NativeSetMap();    // no implementation
    1:     ClassInfo2NativeSetMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /*************************/
    1: 
    1: class ClassInfo2WrappedNativeProtoMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         nsIClassInfo*          key;
    1:         XPCWrappedNativeProto* value;
    1:     };
    1: 
    1:     static ClassInfo2WrappedNativeProtoMap* newMap(int size);
    1: 
    1:     inline XPCWrappedNativeProto* Find(nsIClassInfo* info)
    1:     {
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, info, JS_DHASH_LOOKUP);
    1:         if(JS_DHASH_ENTRY_IS_FREE(entry))
    1:             return nsnull;
    1:         return entry->value;
    1:     }
    1: 
    1:     inline XPCWrappedNativeProto* Add(nsIClassInfo* info, XPCWrappedNativeProto* proto)
    1:     {
    1:         NS_PRECONDITION(info,"bad param");
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, info, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key)
    1:             return entry->value;
    1:         entry->key = info;
    1:         entry->value = proto;
    1:         return proto;
    1:     }
    1: 
    1:     inline void Remove(nsIClassInfo* info)
    1:     {
    1:         NS_PRECONDITION(info,"bad param");
    1:         JS_DHashTableOperate(mTable, info, JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~ClassInfo2WrappedNativeProtoMap();
    1: private:
    1:     ClassInfo2WrappedNativeProtoMap();    // no implementation
    1:     ClassInfo2WrappedNativeProtoMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /*************************/
    1: 
    1: class NativeSetMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         XPCNativeSet* key_value;
    1: 
    1:         static JSBool JS_DLL_CALLBACK
    1:         Match(JSDHashTable *table,
    1:               const JSDHashEntryHdr *entry,
    1:               const void *key);
    1: 
    1:         static struct JSDHashTableOps sOps;
    1:     };
    1: 
    1:     static NativeSetMap* newMap(int size);
    1: 
    1:     inline XPCNativeSet* Find(XPCNativeSetKey* key)
    1:     {
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, key, JS_DHASH_LOOKUP);
    1:         if(JS_DHASH_ENTRY_IS_FREE(entry))
    1:             return nsnull;
    1:         return entry->key_value;
    1:     }
    1: 
    1:     inline XPCNativeSet* Add(const XPCNativeSetKey* key, XPCNativeSet* set)
    1:     {
    1:         NS_PRECONDITION(key,"bad param");
    1:         NS_PRECONDITION(set,"bad param");
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, key, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key_value)
    1:             return entry->key_value;
    1:         entry->key_value = set;
    1:         return set;
    1:     }
    1: 
    1:     inline XPCNativeSet* Add(XPCNativeSet* set)
    1:     {
    1:         XPCNativeSetKey key(set, nsnull, 0);
    1:         return Add(&key, set);
    1:     }
    1: 
    1:     inline void Remove(XPCNativeSet* set)
    1:     {
    1:         NS_PRECONDITION(set,"bad param");
    1: 
    1:         XPCNativeSetKey key(set, nsnull, 0);
    1:         JS_DHashTableOperate(mTable, &key, JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~NativeSetMap();
    1: private:
    1:     NativeSetMap();    // no implementation
    1:     NativeSetMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: class IID2ThisTranslatorMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         nsIID                         key;
    1:         nsIXPCFunctionThisTranslator* value;
    1: 
    1:         static JSBool JS_DLL_CALLBACK
    1:         Match(JSDHashTable *table,
    1:               const JSDHashEntryHdr *entry,
    1:               const void *key);
    1: 
    1:         static void JS_DLL_CALLBACK
    1:         Clear(JSDHashTable *table, JSDHashEntryHdr *entry);
    1: 
    1:         static struct JSDHashTableOps sOps;
    1:     };
    1: 
    1:     static IID2ThisTranslatorMap* newMap(int size);
    1: 
    1:     inline nsIXPCFunctionThisTranslator* Find(REFNSIID iid)
    1:     {
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, &iid, JS_DHASH_LOOKUP);
    1:         if(JS_DHASH_ENTRY_IS_FREE(entry))
    1:             return nsnull;
    1:         return entry->value;
    1:     }
    1: 
    1:     inline nsIXPCFunctionThisTranslator* Add(REFNSIID iid,
    1:                                              nsIXPCFunctionThisTranslator* obj)
    1:     {
    1: 
    1:         Entry* entry = (Entry*)
    1:             JS_DHashTableOperate(mTable, &iid, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         NS_IF_ADDREF(obj);
    1:         NS_IF_RELEASE(entry->value);
    1:         entry->value = obj;
    1:         entry->key = iid;
    1:         return obj;
    1:     }
    1: 
    1:     inline void Remove(REFNSIID iid)
    1:     {
    1:         JS_DHashTableOperate(mTable, &iid, JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~IID2ThisTranslatorMap();
    1: private:
    1:     IID2ThisTranslatorMap();    // no implementation
    1:     IID2ThisTranslatorMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: class XPCNativeScriptableSharedMap
    1: {
    1: public:
    1:     struct Entry : public JSDHashEntryHdr
    1:     {
    1:         XPCNativeScriptableShared* key;
    1: 
    1:         static JSDHashNumber JS_DLL_CALLBACK
    1:         Hash(JSDHashTable *table, const void *key);
    1: 
    1:         static JSBool JS_DLL_CALLBACK
    1:         Match(JSDHashTable *table,
    1:               const JSDHashEntryHdr *entry,
    1:               const void *key);
    1: 
    1:         static struct JSDHashTableOps sOps;
    1:     };
    1: 
    1:     static XPCNativeScriptableSharedMap* newMap(int size);
    1: 
    1:     JSBool GetNewOrUsed(JSUint32 flags, char* name, PRBool isGlobal,
    1:                         XPCNativeScriptableInfo* si);
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~XPCNativeScriptableSharedMap();
    1: private:
    1:     XPCNativeScriptableSharedMap();    // no implementation
    1:     XPCNativeScriptableSharedMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: class XPCWrappedNativeProtoMap
    1: {
    1: public:
    1:     static XPCWrappedNativeProtoMap* newMap(int size);
    1: 
    1:     inline XPCWrappedNativeProto* Add(XPCWrappedNativeProto* proto)
    1:     {
    1:         NS_PRECONDITION(proto,"bad param");
    1:         JSDHashEntryStub* entry = (JSDHashEntryStub*)
    1:             JS_DHashTableOperate(mTable, proto, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key)
    1:             return (XPCWrappedNativeProto*) entry->key;
    1:         entry->key = proto;
    1:         return proto;
    1:     }
    1: 
    1:     inline void Remove(XPCWrappedNativeProto* proto)
    1:     {
    1:         NS_PRECONDITION(proto,"bad param");
    1:         JS_DHashTableOperate(mTable, proto, JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~XPCWrappedNativeProtoMap();
    1: private:
    1:     XPCWrappedNativeProtoMap();    // no implementation
    1:     XPCWrappedNativeProtoMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
    1: class XPCNativeWrapperMap
    1: {
    1: public:
    1:     static XPCNativeWrapperMap* newMap(int size);
    1: 
    1:     inline JSObject* Add(JSObject* nw)
    1:     {
    1:         NS_PRECONDITION(nw,"bad param");
    1:         JSDHashEntryStub* entry = (JSDHashEntryStub*)
    1:             JS_DHashTableOperate(mTable, nw, JS_DHASH_ADD);
    1:         if(!entry)
    1:             return nsnull;
    1:         if(entry->key)
    1:             return (JSObject*) entry->key;
    1:         entry->key = nw;
    1:         return nw;
    1:     }
    1: 
    1:     inline void Remove(JSObject* nw)
    1:     {
    1:         NS_PRECONDITION(nw,"bad param");
    1:         JS_DHashTableOperate(mTable, nw, JS_DHASH_REMOVE);
    1:     }
    1: 
    1:     inline uint32 Count() {return mTable->entryCount;}
    1:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
    1:         {return JS_DHashTableEnumerate(mTable, f, arg);}
    1: 
    1:     ~XPCNativeWrapperMap();
    1: private:
    1:     XPCNativeWrapperMap();    // no implementation
    1:     XPCNativeWrapperMap(int size);
    1: private:
    1:     JSDHashTable *mTable;
    1: };
    1: 
 4042: class WrappedNative2WrapperMap
 4042: {
 9848:     static struct JSDHashTableOps sOps;
 9848: 
 9848:     static void ClearLink(JSDHashTable* table, JSDHashEntryHdr* entry);
11430:     static void MoveLink(JSDHashTable* table, const JSDHashEntryHdr* from,
11430:                          JSDHashEntryHdr* to);
 9848: 
 4042: public:
 9848:     struct Link : public PRCList
 9848:     {
 9848:         JSObject *obj;
 9848:     };
 9848: 
 4042:     struct Entry : public JSDHashEntryHdr
 4042:     {
 4042:         // Note: key must be the flat JSObject for a wrapped native.
 4042:         JSObject*         key;
11430:         Link              value;
 4042:     };
 4042: 
 4042:     static WrappedNative2WrapperMap* newMap(int size);
 4042: 
 4042:     inline JSObject* Find(JSObject* wrapper)
 4042:     {
 4042:         NS_PRECONDITION(wrapper, "bad param");
 4042:         Entry* entry = (Entry*)
 4042:             JS_DHashTableOperate(mTable, wrapper, JS_DHASH_LOOKUP);
 4042:         if(JS_DHASH_ENTRY_IS_FREE(entry))
 4042:             return nsnull;
11430:         return entry->value.obj;
 4042:     }
 4042: 
 4042:     // Note: If the entry already exists, then this will overwrite the
 4042:     // existing entry, returning the old value.
 9848:     JSObject* Add(WrappedNative2WrapperMap* head,
 9848:                   JSObject* wrappedObject,
 9848:                   JSObject* wrapper);
 9848: 
 9848:     // Function to find a link.
 9848:     Link* FindLink(JSObject* wrappedObject)
 4042:     {
 4042:         Entry* entry = (Entry*)
 9848:             JS_DHashTableOperate(mTable, wrappedObject, JS_DHASH_LOOKUP);
 9848:         if(JS_DHASH_ENTRY_IS_BUSY(entry))
11430:             return &entry->value;
 4042:         return nsnull;
 4042:     }
 4042: 
 9848:     // "Internal" function to add an empty link without doing unnecessary
 9848:     // work.
 9848:     PRBool AddLink(JSObject* wrappedObject, Link* oldLink);
 9848: 
 4042:     inline void Remove(JSObject* wrapper)
 4042:     {
 4042:         NS_PRECONDITION(wrapper,"bad param");
 4042:         JS_DHashTableOperate(mTable, wrapper, JS_DHASH_REMOVE);
 4042:     }
 4042: 
 4042:     inline uint32 Count() {return mTable->entryCount;}
 4042:     inline uint32 Enumerate(JSDHashEnumerator f, void *arg)
 4042:         {return JS_DHashTableEnumerate(mTable, f, arg);}
 4042: 
 4042:     ~WrappedNative2WrapperMap();
 9848: 
 4042: private:
 4042:     WrappedNative2WrapperMap();    // no implementation
 4042:     WrappedNative2WrapperMap(int size);
 9848: 
 4042: private:
 4042:     JSDHashTable *mTable;
 4042: };
 4042: 
    1: #endif /* xpcmaps_h___ */
