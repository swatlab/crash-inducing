    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "imgIRequest.h"
    1: #include "imgIDecoderObserver.h"
18557: #include "nsISecurityInfoProvider.h"
    1: 
    1: #include "imgIContainer.h"
    1: #include "imgIDecoder.h"
    1: #include "nsIRequestObserver.h"
    1: #include "nsIChannel.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsISupportsPriority.h"
    1: #include "nsCOMPtr.h"
 6229: #include "nsAutoPtr.h"
22953: #include "nsThreadUtils.h"
    1: 
    1: #include "imgRequest.h"
    1: 
    1: #define NS_IMGREQUESTPROXY_CID \
    1: { /* 20557898-1dd2-11b2-8f65-9c462ee2bc95 */         \
    1:      0x20557898,                                     \
    1:      0x1dd2,                                         \
    1:      0x11b2,                                         \
    1:     {0x8f, 0x65, 0x9c, 0x46, 0x2e, 0xe2, 0xbc, 0x95} \
    1: }
    1: 
18557: class imgRequestProxy : public imgIRequest, public nsISupportsPriority, public nsISecurityInfoProvider
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_IMGIREQUEST
    1:   NS_DECL_NSIREQUEST
    1:   NS_DECL_NSISUPPORTSPRIORITY
18557:   NS_DECL_NSISECURITYINFOPROVIDER
    1: 
    1:   imgRequestProxy();
    1:   virtual ~imgRequestProxy();
    1: 
    1:   // Callers to Init or ChangeOwner are required to call
    1:   // NotifyProxyListener on the request after (although not immediately
    1:   // after) doing so.
    1:   nsresult Init(imgRequest *request, nsILoadGroup *aLoadGroup, imgIDecoderObserver *aObserver);
    1:   nsresult ChangeOwner(imgRequest *aNewOwner); // this will change mOwner.  Do not call this if the previous
    1:                                                // owner has already sent notifications out!
    1: 
    1:   void AddToLoadGroup();
    1:   void RemoveFromLoadGroup(PRBool releaseLoadGroup);
    1: 
    1: protected:
    1:   friend class imgRequest;
    1: 
22953:   class imgCancelRunnable;
22953:   friend class imgCancelRunnable;
22953: 
22953:   class imgCancelRunnable : public nsRunnable
22953:   {
22953:     public:
22953:       imgCancelRunnable(imgRequestProxy* owner, nsresult status)
22953:         : mOwner(owner), mStatus(status)
22953:       {}
22953: 
22953:       NS_IMETHOD Run() {
22953:         mOwner->DoCancel(mStatus);
22953:         return NS_OK;
22953:       }
22953: 
22953:     private:
22953:       nsRefPtr<imgRequestProxy> mOwner;
22953:       nsresult mStatus;
22953:   };
22953: 
22953: 
22953: 
    1:   /* non-virtual imgIDecoderObserver methods */
    1:   void OnStartDecode   ();
    1:   void OnStartContainer(imgIContainer *aContainer);
30479:   void OnStartFrame    (PRUint32 aFrame);
30479:   void OnDataAvailable (PRBool aCurrentFrame, const nsIntRect * aRect);
30479:   void OnStopFrame     (PRUint32 aFrame);
    1:   void OnStopContainer (imgIContainer *aContainer);
    1:   void OnStopDecode    (nsresult status, const PRUnichar *statusArg); 
32424:   void OnDiscard       ();
    1: 
    1:   /* non-virtual imgIContainerObserver methods */
30479:   void FrameChanged(imgIContainer *aContainer, nsIntRect * aDirtyRect);
    1: 
    1:   /* non-virtual nsIRequestObserver (plus some) methods */
    1:   void OnStartRequest(nsIRequest *request, nsISupports *ctxt);
    1:   void OnStopRequest(nsIRequest *request, nsISupports *ctxt, nsresult statusCode, PRBool aLastPart); 
    1: 
    1:   inline PRBool HasObserver() const {
    1:     return mListener != nsnull;
    1:   }
    1: 
22953:   /* Finish up canceling ourselves */
22953:   void DoCancel(nsresult status);
22953: 
13293:   /* Do the proper refcount management to null out mListener */
13293:   void NullOutListener();
13293: 
39122:   void DoRemoveFromLoadGroup() {
39122:     RemoveFromLoadGroup(PR_TRUE);
39122:   }
    1: private:
    1:   friend class imgCacheValidator;
    1: 
 6229:   // We maintain the following invariant:
 6229:   // The proxy is registered at most with a single imgRequest as an observer,
 6229:   // and whenever it is, mOwner points to that object. This helps ensure that
 6229:   // imgRequestProxy::~imgRequestProxy unregisters the proxy as an observer
 6229:   // from whatever request it was registered with (if any). This, in turn,
 6229:   // means that imgRequest::mObservers will not have any stale pointers in it.
 6229:   nsRefPtr<imgRequest> mOwner;
    1: 
13293:   // mListener is only promised to be a weak ref (see imgILoader.idl),
13293:   // but we actually keep a strong ref to it until we've seen our
13293:   // first OnStopRequest.
13293:   imgIDecoderObserver* mListener;
    1:   nsCOMPtr<nsILoadGroup> mLoadGroup;
    1: 
    1:   nsLoadFlags mLoadFlags;
32516:   PRUint32    mLocksHeld;
    1:   PRPackedBool mCanceled;
    1:   PRPackedBool mIsInLoadGroup;
13293:   PRPackedBool mListenerIsStrongRef;
32516:   PRPackedBool mDecodeRequested;
    1: };
