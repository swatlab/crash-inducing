162892: // Stuff to link the old imp to the new api - will go away!
162892: 
162892: #ifndef OLDWRAPPERS__H__
162892: #define OLDWRAPPERS__H__
162892: 
162892: #include "nsICacheEntry.h"
162892: #include "nsICacheListener.h"
162892: #include "nsICacheStorage.h"
162892: 
162892: #include "nsCOMPtr.h"
162892: #include "nsICacheEntryOpenCallback.h"
162892: #include "nsICacheEntryDescriptor.h"
201508: #include "nsICacheStorageVisitor.h"
162892: #include "nsThreadUtils.h"
163612: #include "mozilla/TimeStamp.h"
162892: 
162892: class nsIURI;
162892: class nsICacheEntryOpenCallback;
199617: class nsICacheStorageConsumptionObserver;
162892: class nsIApplicationCache;
162892: class nsILoadContextInfo;
162892: 
162892: namespace mozilla { namespace net {
162892: 
162892: class CacheStorage;
162892: 
162892: class _OldCacheEntryWrapper : public nsICacheEntry
162892: {
162892: public:
162892:   NS_DECL_THREADSAFE_ISUPPORTS
162892:   NS_FORWARD_SAFE_NSICACHEENTRYDESCRIPTOR(mOldDesc)
162892:   NS_FORWARD_NSICACHEENTRYINFO(mOldInfo->)
162892: 
162892:   NS_IMETHOD AsyncDoom(nsICacheEntryDoomCallback* listener);
184910:   NS_IMETHOD GetPersistent(bool *aPersistToDisk);
162892:   NS_IMETHOD SetValid() { return NS_OK; }
162892:   NS_IMETHOD MetaDataReady() { return NS_OK; }
184910:   NS_IMETHOD Recreate(bool, nsICacheEntry**);
162892:   NS_IMETHOD GetDataSize(int64_t *size);
162892:   NS_IMETHOD OpenInputStream(int64_t offset, nsIInputStream * *_retval);
162892:   NS_IMETHOD OpenOutputStream(int64_t offset, nsIOutputStream * *_retval);
162892:   NS_IMETHOD MaybeMarkValid();
162892:   NS_IMETHOD HasWriteAccess(bool aWriteOnly, bool *aWriteAccess);
201508:   NS_IMETHOD VisitMetaData(nsICacheEntryMetaDataVisitor*);
162892: 
162892:   _OldCacheEntryWrapper(nsICacheEntryDescriptor* desc);
162892:   _OldCacheEntryWrapper(nsICacheEntryInfo* info);
162892: 
212458: private:
162892:   virtual ~_OldCacheEntryWrapper();
162892: 
162892:   _OldCacheEntryWrapper() MOZ_DELETE;
162892:   nsICacheEntryDescriptor* mOldDesc; // ref holded in mOldInfo
162892:   nsCOMPtr<nsICacheEntryInfo> mOldInfo;
162892: };
162892: 
162892: 
162892: class _OldCacheLoad : public nsRunnable
162892:                     , public nsICacheListener
162892: {
162892: public:
162892:   NS_DECL_ISUPPORTS_INHERITED
162892:   NS_DECL_NSIRUNNABLE
162892:   NS_DECL_NSICACHELISTENER
162892: 
172236:   _OldCacheLoad(nsCSubstring const& aScheme,
172236:                 nsCSubstring const& aCacheKey,
162892:                 nsICacheEntryOpenCallback* aCallback,
162892:                 nsIApplicationCache* aAppCache,
162892:                 nsILoadContextInfo* aLoadInfo,
162892:                 bool aWriteToDisk,
162892:                 uint32_t aFlags);
162892: 
162892:   nsresult Start();
162892: 
214925: protected:
214925:   virtual ~_OldCacheLoad();
214925: 
162892: private:
162892:   void Check();
162892: 
162892:   nsCOMPtr<nsIEventTarget> mCacheThread;
162892: 
172237:   nsCString const mScheme;
172237:   nsCString const mCacheKey;
162892:   nsCOMPtr<nsICacheEntryOpenCallback> mCallback;
162892:   nsCOMPtr<nsILoadContextInfo> mLoadInfo;
172237:   uint32_t const mFlags;
162892: 
162892:   bool const mWriteToDisk : 1;
162892:   bool mNew : 1;
172237:   bool mOpening : 1;
172237:   bool mSync : 1;
162892: 
162892:   nsCOMPtr<nsICacheEntry> mCacheEntry;
162892:   nsresult mStatus;
162892:   uint32_t mRunCount;
162892:   nsCOMPtr<nsIApplicationCache> mAppCache;
163612: 
163612:   mozilla::TimeStamp mLoadStart;
162892: };
162892: 
162892: 
162892: class _OldStorage : public nsICacheStorage
162892: {
162892:   NS_DECL_THREADSAFE_ISUPPORTS
162892:   NS_DECL_NSICACHESTORAGE
162892: 
162892: public:
162892:   _OldStorage(nsILoadContextInfo* aInfo,
162892:               bool aAllowDisk,
162892:               bool aLookupAppCache,
162892:               bool aOfflineStorage,
162892:               nsIApplicationCache* aAppCache);
162892: 
162892: private:
162892:   virtual ~_OldStorage();
172236:   nsresult AssembleCacheKey(nsIURI *aURI, nsACString const & aIdExtension,
172236:                             nsACString & aCacheKey, nsACString & aScheme);
162892:   nsresult ChooseApplicationCache(nsCSubstring const &cacheKey, nsIApplicationCache** aCache);
162892: 
162892:   nsCOMPtr<nsILoadContextInfo> mLoadInfo;
162892:   nsCOMPtr<nsIApplicationCache> mAppCache;
162892:   bool const mWriteToDisk : 1;
162892:   bool const mLookupAppCache : 1;
162892:   bool const mOfflineStorage : 1;
162892: };
162892: 
201508: class _OldVisitCallbackWrapper : public nsICacheVisitor
201508: {
201508:   NS_DECL_THREADSAFE_ISUPPORTS
201508:   NS_DECL_NSICACHEVISITOR
201508: 
201508:   _OldVisitCallbackWrapper(char const * deviceID,
201508:                            nsICacheStorageVisitor * cb,
201508:                            bool visitEntries,
201508:                            nsILoadContextInfo * aInfo)
201508:   : mCB(cb)
201508:   , mVisitEntries(visitEntries)
201508:   , mDeviceID(deviceID)
201508:   , mLoadInfo(aInfo)
201508:   , mHit(false)
201508:   {
201508:     MOZ_COUNT_CTOR(_OldVisitCallbackWrapper);
201508:   }
201508: 
201508: private:
201508:   virtual ~_OldVisitCallbackWrapper();
201508:   nsCOMPtr<nsICacheStorageVisitor> mCB;
201508:   bool mVisitEntries;
201508:   char const * mDeviceID;
201508:   nsCOMPtr<nsILoadContextInfo> mLoadInfo;
201508:   bool mHit; // set to true when the device was found
201508: };
201508: 
199617: class _OldGetDiskConsumption : public nsRunnable,
199617:                                public nsICacheVisitor
199617: {
199617: public:
199617:   static nsresult Get(nsICacheStorageConsumptionObserver* aCallback);
199617: 
199617: private:
199617:   _OldGetDiskConsumption(nsICacheStorageConsumptionObserver* aCallback);
199617:   virtual ~_OldGetDiskConsumption() {}
199617:   NS_DECL_ISUPPORTS_INHERITED
199617:   NS_DECL_NSICACHEVISITOR
199617:   NS_DECL_NSIRUNNABLE
199617: 
199617:   nsCOMPtr<nsICacheStorageConsumptionObserver> mCallback;
199617:   int64_t mSize;
199617: };
199617: 
162892: }}
162892: 
162892: #endif
