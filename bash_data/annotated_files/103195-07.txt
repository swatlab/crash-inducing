 69223: /* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 69223:  * vim: set ts=4 sw=4 et tw=79 ft=cpp:
 69223:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 69223: 
 69223: #ifndef Stack_inl_h__
 69223: #define Stack_inl_h__
 69223: 
 70320: #include "jscntxt.h"
 70321: #include "jscompartment.h"
 70320: 
 86483: #include "methodjit/MethodJIT.h"
 86483: #include "vm/Stack.h"
 69223: 
 77884: #include "jsscriptinlines.h"
 86483: 
 69827: #include "ArgumentsObject-inl.h"
 86483: #include "ScopeObject-inl.h"
 78065: 
 69827: 
 69223: namespace js {
 69223: 
 83228: /*
 83228:  * We cache name lookup results only for the global object or for native
 83228:  * non-global objects without prototype or with prototype that never mutates,
 83228:  * see bug 462734 and bug 487039.
 83228:  */
 83228: static inline bool
 83228: IsCacheableNonGlobalScope(JSObject *obj)
 83228: {
 83228:     bool cacheable = (obj->isCall() || obj->isBlock() || obj->isDeclEnv());
 83228: 
 83228:     JS_ASSERT_IF(cacheable, !obj->getOps()->lookupProperty);
 83228:     return cacheable;
 83228: }
 83228: 
 96793: inline HandleObject
 83239: StackFrame::scopeChain() const
 83239: {
 83239:     JS_ASSERT_IF(!(flags_ & HAS_SCOPECHAIN), isFunctionFrame());
 83239:     if (!(flags_ & HAS_SCOPECHAIN)) {
 98921:         scopeChain_ = callee().environment();
 83239:         flags_ |= HAS_SCOPECHAIN;
 83239:     }
 96793:     return HandleObject::fromMarkedLocation(&scopeChain_);
 96793: }
 96793: 
 96793: inline GlobalObject &
 96793: StackFrame::global() const
 96793: {
 96793:     return scopeChain()->global();
 83239: }
 83239: 
 83239: inline JSObject &
 83239: StackFrame::varObj()
 83239: {
 96793:     JSObject *obj = scopeChain();
 83239:     while (!obj->isVarObj())
 86483:         obj = obj->enclosingScope();
 83239:     return *obj;
 83239: }
 83239: 
 83239: inline JSCompartment *
 83239: StackFrame::compartment() const
 83239: {
 96793:     JS_ASSERT_IF(isScriptFrame(), scopeChain()->compartment() == script()->compartment());
 96793:     return scopeChain()->compartment();
 83239: }
 83239: 
 98147: #ifdef JS_METHODJIT
 98147: inline mjit::JITScript *
 98147: StackFrame::jit()
 98147: {
 98147:     JSScript *script_ = script();
 98147:     return script_->getJIT(isConstructing(), script_->compartment()->needsBarrier());
 98147: }
 98147: #endif
 98147: 
 69223: inline void
 69223: StackFrame::initPrev(JSContext *cx)
 69223: {
 69223:     JS_ASSERT(flags_ & HAS_PREVPC);
 69223:     if (FrameRegs *regs = cx->maybeRegs()) {
 69223:         prev_ = regs->fp();
 69223:         prevpc_ = regs->pc;
 76193:         prevInline_ = regs->inlined();
 82642:         JS_ASSERT_IF(!prev_->isDummyFrame(),
 84755:                      uint32_t(prevpc_ - prev_->script()->code) < prev_->script()->length);
 69223:     } else {
 69223:         prev_ = NULL;
 69223: #ifdef DEBUG
 69223:         prevpc_ = (jsbytecode *)0xbadc;
101075:         prevInline_ = (InlinedSite *)0xbadc;
 69223: #endif
 69223:     }
 69223: }
 69223: 
 69223: inline void
 69223: StackFrame::resetGeneratorPrev(JSContext *cx)
 69223: {
 69223:     flags_ |= HAS_PREVPC;
 69223:     initPrev(cx);
 69223: }
 69223: 
 69223: inline void
 76193: StackFrame::initInlineFrame(JSFunction *fun, StackFrame *prevfp, jsbytecode *prevpc)
 76193: {
 77341:     /*
 77341:      * Note: no need to ensure the scopeChain is instantiated for inline
 77341:      * frames. Functions which use the scope chain are never inlined.
 77341:      */
 76193:     flags_ = StackFrame::FUNCTION;
 76193:     exec.fun = fun;
 76193:     resetInlinePrev(prevfp, prevpc);
 76193: }
 76193: 
 76193: inline void
 76193: StackFrame::resetInlinePrev(StackFrame *prevfp, jsbytecode *prevpc)
 76193: {
 76193:     JS_ASSERT_IF(flags_ & StackFrame::HAS_PREVPC, prevInline_);
 76193:     flags_ |= StackFrame::HAS_PREVPC;
 76193:     prev_ = prevfp;
 76193:     prevpc_ = prevpc;
 76193:     prevInline_ = NULL;
 76193: }
 76193: 
 76193: inline void
 83283: StackFrame::initCallFrame(JSContext *cx, JSFunction &callee,
 84755:                           JSScript *script, uint32_t nactual, StackFrame::Flags flagsArg)
 69223: {
 69223:     JS_ASSERT((flagsArg & ~(CONSTRUCTING |
 77341:                             LOWERED_CALL_APPLY |
 69223:                             OVERFLOW_ARGS |
 69223:                             UNDERFLOW_ARGS)) == 0);
 86773:     JS_ASSERT(script == callee.script());
 69223: 
 69223:     /* Initialize stack frame members. */
 86077:     flags_ = FUNCTION | HAS_PREVPC | HAS_SCOPECHAIN | HAS_BLOCKCHAIN | flagsArg;
 83283:     exec.fun = &callee;
 87583:     u.nactual = nactual;
 86773:     scopeChain_ = callee.environment();
 76193:     ncode_ = NULL;
 69223:     initPrev(cx);
 86077:     blockChain_= NULL;
 86077:     JS_ASSERT(!hasBlockChain());
 69223:     JS_ASSERT(!hasHookData());
 69223:     JS_ASSERT(annotation() == NULL);
 71695: 
101075:     initVarsToUndefined();
 69223: }
 69223: 
 89722: /*
 89722:  * Reinitialize the StackFrame fields that have been initialized up to the
 89722:  * point of FixupArity in the function prologue.
 89722:  */
 69223: inline void
 91237: StackFrame::initFixupFrame(StackFrame *prev, StackFrame::Flags flags, void *ncode, unsigned nactual)
 69223: {
 71695:     JS_ASSERT((flags & ~(CONSTRUCTING |
 77341:                          LOWERED_CALL_APPLY |
 69223:                          FUNCTION |
 69223:                          OVERFLOW_ARGS |
 69223:                          UNDERFLOW_ARGS)) == 0);
 69223: 
 71695:     flags_ = FUNCTION | flags;
 73495:     prev_ = prev;
 69223:     ncode_ = ncode;
 87583:     u.nactual = nactual;
 69223: }
 69223: 
101075: inline bool
101075: StackFrame::jitHeavyweightFunctionPrologue(JSContext *cx)
101075: {
101075:     JS_ASSERT(isNonEvalFunctionFrame());
101075:     JS_ASSERT(fun()->isHeavyweight());
101075: 
101075:     CallObject *callobj = CallObject::createForFunction(cx, this);
101075:     if (!callobj)
101075:         return false;
101075: 
101075:     pushOnScopeChain(*callobj);
101075:     flags_ |= HAS_CALL_OBJ;
101075: 
101075:     if (script()->nesting()) {
101075:         types::NestingPrologue(cx, this);
101075:         flags_ |= HAS_NESTING;
101075:     }
101075: 
101075:     return true;
101075: }
101075: 
101075: inline void
101075: StackFrame::jitTypeNestingPrologue(JSContext *cx)
101075: {
101075:     types::NestingPrologue(cx, this);
101075:     flags_ |= HAS_NESTING;
101075: }
101075: 
101075: inline void
101075: StackFrame::initVarsToUndefined()
101075: {
101075:     SetValueRangeToUndefined(slots(), script()->nfixed);
101075: }
101075: 
 99225: inline JSObject *
 99225: StackFrame::createRestParameter(JSContext *cx)
 99225: {
 99225:     JS_ASSERT(fun()->hasRest());
 99225:     unsigned nformal = fun()->nargs - 1, nactual = numActualArgs();
 99225:     unsigned nrest = (nactual > nformal) ? nactual - nformal : 0;
101075:     return NewDenseCopiedArray(cx, nrest, actuals() + nformal);
 99225: }
 99225: 
 69223: inline Value &
101075: StackFrame::unaliasedVar(unsigned i, MaybeCheckAliasing checkAliasing)
 69223: {
101075:     JS_ASSERT_IF(checkAliasing, !script()->varIsAliased(i));
101075:     JS_ASSERT(i < script()->nfixed);
101075:     return slots()[i];
101075: }
101075: 
101075: inline Value &
101075: StackFrame::unaliasedLocal(unsigned i, MaybeCheckAliasing checkAliasing)
101075: {
101075: #ifdef DEBUG
101075:     if (checkAliasing) {
101075:         JS_ASSERT(i < script()->nslots);
101075:         if (i < script()->nfixed) {
101075:             JS_ASSERT(!script()->varIsAliased(i));
101075:         } else {
101075:             unsigned depth = i - script()->nfixed;
101075:             for (StaticBlockObject *b = maybeBlockChain(); b; b = b->enclosingBlock()) {
101075:                 if (b->containsVarAtDepth(depth)) {
101075:                     JS_ASSERT(!b->isAliased(depth - b->stackDepth()));
101075:                     break;
101075:                 }
101075:             }
101075:         }
101075:     }
101075: #endif
101075:     return slots()[i];
101075: }
101075: 
101075: inline Value &
101075: StackFrame::unaliasedFormal(unsigned i, MaybeCheckAliasing checkAliasing)
101075: {
101075:     JS_ASSERT(i < numFormalArgs());
101075:     JS_ASSERT_IF(checkAliasing, !script()->formalIsAliased(i));
101075:     return formals()[i];
101075: }
101075: 
101075: inline Value &
102445: StackFrame::unaliasedActual(unsigned i, MaybeCheckAliasing checkAliasing)
101075: {
 69223:     JS_ASSERT(i < numActualArgs());
102445:     JS_ASSERT_IF(checkAliasing && i < numFormalArgs(), !script()->formalIsAliased(i));
101075:     return i < numFormalArgs() ? formals()[i] : actuals()[i];
 69223: }
 69223: 
 69223: template <class Op>
101075: inline void
101075: StackFrame::forEachUnaliasedActual(Op op)
 69223: {
101075:     JS_ASSERT(script()->numClosedArgs() == 0);
101075:     JS_ASSERT(!script()->needsArgsObj());
 70319: 
101075:     unsigned nformal = numFormalArgs();
 91237:     unsigned nactual = numActualArgs();
 70319: 
101075:     const Value *formalsEnd = (const Value *)this;
101075:     const Value *formals = formalsEnd - nformal;
 70319: 
101075:     if (nactual <= nformal) {
101075:         const Value *actualsEnd = formals + nactual;
101075:         for (const Value *p = formals; p < actualsEnd; ++p)
101075:             op(*p);
101075:     } else {
101075:         for (const Value *p = formals; p < formalsEnd; ++p)
101075:             op(*p);
101075: 
101075:         const Value *actualsEnd = formals - 2;
101075:         const Value *actuals = actualsEnd - nactual;
101075:         for (const Value *p = actuals + nformal; p < actualsEnd; ++p)
101075:             op(*p);
100006:     }
 69223: }
 69223: 
 69223: struct CopyTo
 69223: {
 69223:     Value *dst;
 69223:     CopyTo(Value *dst) : dst(dst) {}
101075:     void operator()(const Value &src) { *dst++ = src; }
101075: };
101075: 
101075: inline unsigned
101075: StackFrame::numFormalArgs() const
101075: {
101075:     JS_ASSERT(hasArgs());
101075:     return fun()->nargs;
100006: }
 99994: 
 99994: inline unsigned
 69223: StackFrame::numActualArgs() const
 69223: {
 77341:     /*
 87583:      * u.nactual is always coherent, except for method JIT frames where the
 77341:      * callee does not access its arguments and the number of actual arguments
 77341:      * matches the number of formal arguments. The JIT requires that all frames
 77341:      * which do not have an arguments object and use their arguments have a
 87583:      * coherent u.nactual (even though the below code may not use it), as
 77341:      * JIT code may access the field directly.
 77341:      */
 69223:     JS_ASSERT(hasArgs());
 69223:     if (JS_UNLIKELY(flags_ & (OVERFLOW_ARGS | UNDERFLOW_ARGS)))
 87583:         return u.nactual;
 69223:     return numFormalArgs();
 69223: }
 69223: 
101075: inline ArgumentsObject &
101075: StackFrame::argsObj() const
 69223: {
101075:     JS_ASSERT(script()->needsArgsObj());
101075:     JS_ASSERT(flags_ & HAS_ARGS_OBJ);
101075:     return *argsObj_;
100006: }
100006: 
101075: inline void
101075: StackFrame::initArgsObj(ArgumentsObject &argsobj)
100006: {
101075:     JS_ASSERT(script()->needsArgsObj());
101075:     flags_ |= HAS_ARGS_OBJ;
101075:     argsObj_ = &argsobj;
 69223: }
 69223: 
101073: inline ScopeObject &
101073: StackFrame::aliasedVarScope(ScopeCoordinate sc) const
101073: {
101073:     JSObject *scope = &scopeChain()->asScope();
101073:     for (unsigned i = sc.hops; i; i--)
101073:         scope = &scope->asScope().enclosingScope();
101073:     return scope->asScope();
101073: }
101073: 
 99994: inline void
101075: StackFrame::pushOnScopeChain(ScopeObject &scope)
 69223: {
101075:     JS_ASSERT(*scopeChain() == scope.enclosingScope() ||
101075:               *scopeChain() == scope.asCall().enclosingScope().asDeclEnv().enclosingScope());
101075:     scopeChain_ = &scope;
 69223:     flags_ |= HAS_SCOPECHAIN;
 69223: }
 69223: 
 69223: inline void
101075: StackFrame::popOffScopeChain()
 69223: {
101075:     JS_ASSERT(flags_ & HAS_SCOPECHAIN);
101075:     scopeChain_ = &scopeChain_->asScope().enclosingScope();
 69223: }
 69223: 
 78065: inline CallObject &
 69223: StackFrame::callObj() const
 69223: {
101075:     JS_ASSERT(fun()->isHeavyweight());
 69223: 
 96793:     JSObject *pobj = scopeChain();
 80154:     while (JS_UNLIKELY(!pobj->isCall()))
 86483:         pobj = pobj->enclosingScope();
 78065:     return pobj->asCall();
 69223: }
 69223: 
 69223: /*****************************************************************************/
 69223: 
 69223: STATIC_POSTCONDITION(!return || ubound(from) >= nvals)
 69223: JS_ALWAYS_INLINE bool
 76885: StackSpace::ensureSpace(JSContext *cx, MaybeReportError report, Value *from, ptrdiff_t nvals,
 76885:                         JSCompartment *dest) const
 69223: {
 73495:     assertInvariants();
 69223:     JS_ASSERT(from >= firstUnused());
 69223: #ifdef XP_WIN
 69223:     JS_ASSERT(from <= commitEnd_);
 73495: #endif
 73495:     if (JS_UNLIKELY(conservativeEnd_ - from < nvals))
 76885:         return ensureSpaceSlow(cx, report, from, nvals, dest);
 69223:     return true;
 69223: }
 69223: 
 69223: inline Value *
 73495: StackSpace::getStackLimit(JSContext *cx, MaybeReportError report)
 69223: {
 69223:     FrameRegs &regs = cx->regs();
101075:     unsigned nvals = regs.fp()->script()->nslots + STACK_JIT_EXTRA;
 73495:     return ensureSpace(cx, report, regs.sp, nvals)
 73495:            ? conservativeEnd_
 73495:            : NULL;
 69223: }
 69223: 
 69223: /*****************************************************************************/
 69223: 
 73495: JS_ALWAYS_INLINE StackFrame *
 73495: ContextStack::getCallFrame(JSContext *cx, MaybeReportError report, const CallArgs &args,
 89722:                            JSFunction *fun, JSScript *script, StackFrame::Flags *flags) const
 69223: {
 73495:     JS_ASSERT(fun->script() == script);
 91237:     unsigned nformal = fun->nargs;
 69223: 
 73495:     Value *firstUnused = args.end();
 73495:     JS_ASSERT(firstUnused == space().firstUnused());
 73495: 
 77354:     /* Include extra space to satisfy the method-jit stackLimit invariant. */
 91237:     unsigned nvals = VALUES_PER_STACK_FRAME + script->nslots + StackSpace::STACK_JIT_EXTRA;
 69223: 
101075:     /* Maintain layout invariant: &formals[0] == ((Value *)fp) - nformal. */
 69223: 
 79387:     if (args.length() == nformal) {
 73495:         if (!space().ensureSpace(cx, report, firstUnused, nvals))
 69223:             return NULL;
 69223:         return reinterpret_cast<StackFrame *>(firstUnused);
 69223:     }
 69223: 
 79387:     if (args.length() < nformal) {
 71695:         *flags = StackFrame::Flags(*flags | StackFrame::UNDERFLOW_ARGS);
 91237:         unsigned nmissing = nformal - args.length();
 73495:         if (!space().ensureSpace(cx, report, firstUnused, nmissing + nvals))
 69223:             return NULL;
 69223:         SetValueRangeToUndefined(firstUnused, nmissing);
 69223:         return reinterpret_cast<StackFrame *>(firstUnused + nmissing);
 69223:     }
 69223: 
 71695:     *flags = StackFrame::Flags(*flags | StackFrame::OVERFLOW_ARGS);
 91237:     unsigned ncopy = 2 + nformal;
 73495:     if (!space().ensureSpace(cx, report, firstUnused, ncopy + nvals))
 69223:         return NULL;
 69223:     Value *dst = firstUnused;
 71695:     Value *src = args.base();
 69223:     PodCopy(dst, src, ncopy);
 69223:     return reinterpret_cast<StackFrame *>(firstUnused + ncopy);
 69223: }
 69223: 
 71695: JS_ALWAYS_INLINE bool
 71695: ContextStack::pushInlineFrame(JSContext *cx, FrameRegs &regs, const CallArgs &args,
 83283:                               JSFunction &callee, JSScript *script,
 77354:                               InitialFrameFlags initial)
 69223: {
 71697:     JS_ASSERT(onTop());
 71695:     JS_ASSERT(regs.sp == args.end());
 71695:     /* Cannot assert callee == args.callee() since this is called from LeaveTree. */
 86773:     JS_ASSERT(script == callee.script());
 69223: 
 89722:     StackFrame::Flags flags = ToFrameFlags(initial);
 83283:     StackFrame *fp = getCallFrame(cx, REPORT_ERROR, args, &callee, script, &flags);
 71695:     if (!fp)
 71695:         return false;
 71695: 
 71695:     /* Initialize frame, locals, regs. */
 89722:     fp->initCallFrame(cx, callee, script, args.length(), flags);
 76193: 
 76193:     /*
 76193:      * N.B. regs may differ from the active registers, if the parent is about
 76193:      * to repoint the active registers to regs. See UncachedInlineCall.
 76193:      */
 71697:     regs.prepareToRun(*fp, script);
 71695:     return true;
 69223: }
 69223: 
 73495: JS_ALWAYS_INLINE bool
 73495: ContextStack::pushInlineFrame(JSContext *cx, FrameRegs &regs, const CallArgs &args,
 83283:                               JSFunction &callee, JSScript *script,
 77354:                               InitialFrameFlags initial, Value **stackLimit)
 73495: {
 83283:     if (!pushInlineFrame(cx, regs, args, callee, script, initial))
 73495:         return false;
 73495:     *stackLimit = space().conservativeEnd_;
 73495:     return true;
 73495: }
 73495: 
 69223: JS_ALWAYS_INLINE StackFrame *
 73495: ContextStack::getFixupFrame(JSContext *cx, MaybeReportError report,
 73495:                             const CallArgs &args, JSFunction *fun, JSScript *script,
 77354:                             void *ncode, InitialFrameFlags initial, Value **stackLimit)
 69223: {
 71697:     JS_ASSERT(onTop());
 83234:     JS_ASSERT(fun->script() == args.callee().toFunction()->script());
 71695:     JS_ASSERT(fun->script() == script);
 69223: 
 89722:     StackFrame::Flags flags = ToFrameFlags(initial);
 73495:     StackFrame *fp = getCallFrame(cx, report, args, fun, script, &flags);
 71695:     if (!fp)
 71695:         return NULL;
 69223: 
 71695:     /* Do not init late prologue or regs; this is done by jit code. */
 89722:     fp->initFixupFrame(cx->fp(), flags, ncode, args.length());
 73495: 
 73495:     *stackLimit = space().conservativeEnd_;
 71695:     return fp;
 69223: }
 69223: 
 69223: JS_ALWAYS_INLINE void
 71697: ContextStack::popInlineFrame(FrameRegs &regs)
 69223: {
 71697:     JS_ASSERT(onTop());
 71697:     JS_ASSERT(&regs == &seg_->regs());
 69223: 
 71697:     StackFrame *fp = regs.fp();
101075:     Value *newsp = fp->actuals() - 1;
 69223:     JS_ASSERT(newsp >= fp->prev()->base());
 69223: 
 69223:     newsp[-1] = fp->returnValue();
 71697:     regs.popFrame(newsp);
 69223: }
 69223: 
 71697: inline void
 71697: ContextStack::popFrameAfterOverflow()
 69223: {
 71697:     /* Restore the regs to what they were on entry to JSOP_CALL. */
 71697:     FrameRegs &regs = seg_->regs();
 71697:     StackFrame *fp = regs.fp();
101075:     regs.popFrame(fp->actuals() + fp->numActualArgs());
 69223: }
 69223: 
 76193: inline JSScript *
 76193: ContextStack::currentScript(jsbytecode **ppc) const
 76193: {
 76193:     if (ppc)
 76193:         *ppc = NULL;
 76193: 
 76193:     FrameRegs *regs = maybeRegs();
 76193:     StackFrame *fp = regs ? regs->fp() : NULL;
 76193:     while (fp && fp->isDummyFrame())
 76193:         fp = fp->prev();
 76193:     if (!fp)
 76193:         return NULL;
 76193: 
 76193: #ifdef JS_METHODJIT
 76193:     mjit::CallSite *inlined = regs->inlined();
 76193:     if (inlined) {
 87654:         mjit::JITChunk *chunk = fp->jit()->chunk(regs->pc);
 87654:         JS_ASSERT(inlined->inlineIndex < chunk->nInlineFrames);
 87654:         mjit::InlineFrame *frame = &chunk->inlineFrames()[inlined->inlineIndex];
 76193:         JSScript *script = frame->fun->script();
 77659:         if (script->compartment() != cx_->compartment)
 76193:             return NULL;
 76193:         if (ppc)
 76193:             *ppc = script->code + inlined->pcOffset;
 76193:         return script;
 76193:     }
 76193: #endif
 76193: 
 76193:     JSScript *script = fp->script();
 77659:     if (script->compartment() != cx_->compartment)
 76193:         return NULL;
 76193: 
 82642:     if (ppc)
 76193:         *ppc = fp->pcQuadratic(*this);
 76193:     return script;
 76193: }
 76193: 
 96793: inline HandleObject
 76193: ContextStack::currentScriptedScopeChain() const
 76193: {
 96793:     return fp()->scopeChain();
 76193: }
 76193: 
 69223: } /* namespace js */
 69223: #endif /* Stack_inl_h__ */
