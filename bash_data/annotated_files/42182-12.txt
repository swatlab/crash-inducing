    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Peter Annema <disttsc@bart.nl>
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: //
    1: // Eric Vaughan
    1: // Netscape Communications
    1: //
    1: // See documentation in associated header file
    1: //
    1: 
    1: #include "nsReadableUtils.h"
    1: #include "nsTextBoxFrame.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsPresContext.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIContent.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsMenuBarListener.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMXULLabelElement.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsITheme.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDisplayList.h"
 4302: #include "nsCSSRendering.h"
 4445: #include "nsIReflowCallback.h"
    1: 
    1: #ifdef IBMBIDI
    1: #include "nsBidiUtils.h"
    1: #include "nsBidiPresUtils.h"
    1: #endif // IBMBIDI
    1: 
    1: #define CROP_LEFT   "left"
    1: #define CROP_RIGHT  "right"
    1: #define CROP_CENTER "center"
    1: #define CROP_START  "start"
    1: #define CROP_END    "end"
    1: 
    1: #define NS_STATE_NEED_LAYOUT 0x01000000
    1: 
    1: class nsAccessKeyInfo
    1: {
    1: public:
    1:     PRInt32 mAccesskeyIndex;
    1:     nscoord mBeforeWidth, mAccessWidth, mAccessUnderlineSize, mAccessOffset;
    1: };
    1: 
    1: 
    1: PRBool nsTextBoxFrame::gAlwaysAppendAccessKey          = PR_FALSE;
    1: PRBool nsTextBoxFrame::gAccessKeyPrefInitialized       = PR_FALSE;
    1: PRBool nsTextBoxFrame::gInsertSeparatorBeforeAccessKey = PR_FALSE;
    1: PRBool nsTextBoxFrame::gInsertSeparatorPrefInitialized = PR_FALSE;
    1: 
    1: //
    1: // NS_NewToolbarFrame
    1: //
    1: // Creates a new Toolbar frame and returns it
    1: //
    1: nsIFrame*
    1: NS_NewTextBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:     return new (aPresShell) nsTextBoxFrame (aPresShell, aContext);
32423: }
32423: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsTextBoxFrame)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextBoxFrame::AttributeChanged(PRInt32         aNameSpaceID,
    1:                                  nsIAtom*        aAttribute,
    1:                                  PRInt32         aModType)
    1: {
    1:     mState |= NS_STATE_NEED_LAYOUT;
    1:     PRBool aResize;
    1:     PRBool aRedraw;
    1: 
    1:     UpdateAttributes(aAttribute, aResize, aRedraw);
    1: 
    1:     if (aResize) {
  238:         PresContext()->PresShell()->
 1158:             FrameNeedsReflow(this, nsIPresShell::eStyleChange,
 1158:                              NS_FRAME_IS_DIRTY);
    1:     } else if (aRedraw) {
  238:         nsBoxLayoutState state(PresContext());
    1:         Redraw(state);
    1:     }
    1: 
    1:     // If the accesskey changed, register for the new value
    1:     // The old value has been unregistered in nsXULElement::SetAttr
    1:     if (aAttribute == nsGkAtoms::accesskey || aAttribute == nsGkAtoms::control)
    1:         RegUnregAccessKey(PR_TRUE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsTextBoxFrame::nsTextBoxFrame(nsIPresShell* aShell, nsStyleContext* aContext):
28285:   nsLeafBoxFrame(aShell, aContext), mAccessKeyInfo(nsnull), mCropType(CropRight),
 5624:   mNeedsReflowCallback(PR_FALSE)
    1: {
    1:     mState |= NS_STATE_NEED_LAYOUT;
    1:     MarkIntrinsicWidthsDirty();
    1: }
    1: 
    1: nsTextBoxFrame::~nsTextBoxFrame()
    1: {
    1:     delete mAccessKeyInfo;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTextBoxFrame::Init(nsIContent*      aContent,
    1:                      nsIFrame*        aParent,
    1:                      nsIFrame*        aPrevInFlow)
    1: {
    1:     nsTextBoxFrameSuper::Init(aContent, aParent, aPrevInFlow);
    1: 
    1:     mState |= NS_STATE_NEED_LAYOUT;
    1:     PRBool aResize;
    1:     PRBool aRedraw;
    1:     UpdateAttributes(nsnull, aResize, aRedraw); /* update all */
    1: 
    1:     // register access key
    1:     RegUnregAccessKey(PR_TRUE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
36647: nsTextBoxFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:     // unregister access key
    1:     RegUnregAccessKey(PR_FALSE);
36647:     nsTextBoxFrameSuper::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: PRBool
    1: nsTextBoxFrame::AlwaysAppendAccessKey()
    1: {
    1:   if (!gAccessKeyPrefInitialized) 
    1:   {
    1:     gAccessKeyPrefInitialized = PR_TRUE;
    1: 
    1:     const char* prefName = "intl.menuitems.alwaysappendaccesskeys";
    1:     nsAdoptingString val = nsContentUtils::GetLocalizedStringPref(prefName);
    1:     gAlwaysAppendAccessKey = val.Equals(NS_LITERAL_STRING("true"));
    1:   }
    1:   return gAlwaysAppendAccessKey;
    1: }
    1: 
    1: PRBool
    1: nsTextBoxFrame::InsertSeparatorBeforeAccessKey()
    1: {
    1:   if (!gInsertSeparatorPrefInitialized)
    1:   {
    1:     gInsertSeparatorPrefInitialized = PR_TRUE;
    1: 
    1:     const char* prefName = "intl.menuitems.insertseparatorbeforeaccesskeys";
    1:     nsAdoptingString val = nsContentUtils::GetLocalizedStringPref(prefName);
    1:     gInsertSeparatorBeforeAccessKey = val.EqualsLiteral("true");
    1:   }
    1:   return gInsertSeparatorBeforeAccessKey;
    1: }
    1: 
 4445: class nsAsyncAccesskeyUpdate : public nsIReflowCallback
 4445: {
 4445: public:
 4445:     nsAsyncAccesskeyUpdate(nsIFrame* aFrame) : mWeakFrame(aFrame)
 4445:     {
 4445:     }
 4445: 
 4445:     virtual PRBool ReflowFinished()
 4445:     {
 4445:         PRBool shouldFlush = PR_FALSE;
 4445:         nsTextBoxFrame* frame =
 4445:             static_cast<nsTextBoxFrame*>(mWeakFrame.GetFrame());
 4445:         if (frame) {
 4445:             shouldFlush = frame->UpdateAccesskey(mWeakFrame);
 4445:         }
 4445:         delete this;
 4445:         return shouldFlush;
 4445:     }
 4445: 
 8509:     virtual void ReflowCallbackCanceled()
 8509:     {
 8509:         delete this;
 8509:     }
 8509: 
 4445:     nsWeakFrame mWeakFrame;
 4445: };
 4445: 
 4445: PRBool
 4445: nsTextBoxFrame::UpdateAccesskey(nsWeakFrame& aWeakThis)
 4445: {
 4445:     nsAutoString accesskey;
 4445:     nsCOMPtr<nsIDOMXULLabelElement> labelElement = do_QueryInterface(mContent);
30490:     NS_ENSURE_TRUE(aWeakThis.IsAlive(), PR_FALSE);
 4445:     if (labelElement) {
 4445:         // Accesskey may be stored on control.
 4773:         // Because this method is called by the reflow callback, current context
 4773:         // may not be the right one. Pushing the context of mContent so that
 4773:         // if nsIDOMXULLabelElement is implemented in XBL, we don't get a
 4773:         // security exception.
 6475:         nsCxPusher cx;
 6475:         if (cx.Push(mContent)) {
 4445:           labelElement->GetAccessKey(accesskey);
 4445:           NS_ENSURE_TRUE(aWeakThis.IsAlive(), PR_FALSE);
 4445:         }
 6475:     }
 4445:     else {
 4445:         mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accesskey);
 4445:     }
 4445: 
 4445:     if (!accesskey.Equals(mAccessKey)) {
 4445:         // Need to get clean mTitle.
 4445:         mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, mTitle);
 4445:         mAccessKey = accesskey;
 4445:         UpdateAccessTitle();
 4445:         PresContext()->PresShell()->
 4445:             FrameNeedsReflow(this, nsIPresShell::eStyleChange,
 4445:                              NS_FRAME_IS_DIRTY);
 4445:         return PR_TRUE;
 4445:     }
 4445:     return PR_FALSE;
 4445: }
 4445: 
    1: void
    1: nsTextBoxFrame::UpdateAttributes(nsIAtom*         aAttribute,
    1:                                  PRBool&          aResize,
    1:                                  PRBool&          aRedraw)
    1: {
    1:     PRBool doUpdateTitle = PR_FALSE;
    1:     aResize = PR_FALSE;
    1:     aRedraw = PR_FALSE;
    1: 
    1:     if (aAttribute == nsnull || aAttribute == nsGkAtoms::crop) {
    1:         static nsIContent::AttrValuesArray strings[] =
    1:           {&nsGkAtoms::left, &nsGkAtoms::start, &nsGkAtoms::center,
    1:            &nsGkAtoms::right, &nsGkAtoms::end, nsnull};
    1:         CroppingStyle cropType;
    1:         switch (mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::crop,
    1:                                           strings, eCaseMatters)) {
    1:           case 0:
    1:           case 1:
    1:             cropType = CropLeft;
    1:             break;
    1:           case 2:
    1:             cropType = CropCenter;
    1:             break;
    1:           case 3:
    1:           case 4:
    1:             cropType = CropRight;
    1:             break;
    1:           default:
    1:             cropType = CropNone;
    1:             break;
    1:         }
    1: 
    1:         if (cropType != mCropType) {
    1:             aResize = PR_TRUE;
    1:             mCropType = cropType;
    1:         }
    1:     }
    1: 
    1:     if (aAttribute == nsnull || aAttribute == nsGkAtoms::value) {
    1:         mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, mTitle);
    1:         doUpdateTitle = PR_TRUE;
    1:     }
    1: 
 5624:     if (aAttribute == nsnull || aAttribute == nsGkAtoms::accesskey) {
 5624:         mNeedsReflowCallback = PR_TRUE;
 4445:         // Ensure that layout is refreshed and reflow callback called.
 4445:         aResize = PR_TRUE;
    1:     }
    1: 
    1:     if (doUpdateTitle) {
    1:         UpdateAccessTitle();
    1:         aResize = PR_TRUE;
    1:     }
    1: 
    1: }
    1: 
    1: class nsDisplayXULTextBox : public nsDisplayItem {
    1: public:
    1:   nsDisplayXULTextBox(nsTextBoxFrame* aFrame) : nsDisplayItem(aFrame) {
    1:       MOZ_COUNT_CTOR(nsDisplayXULTextBox);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayXULTextBox() {
    1:       MOZ_COUNT_DTOR(nsDisplayXULTextBox);
    1:   }
    1: #endif
    1: 
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
33368:                      nsIRenderingContext* aCtx);
21991:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
    1:   NS_DISPLAY_DECL_NAME("XULTextBox")
    1: };
    1: 
21991: void
21991: nsDisplayXULTextBox::Paint(nsDisplayListBuilder* aBuilder,
33368:                            nsIRenderingContext* aCtx)
    1: {
 3233:   static_cast<nsTextBoxFrame*>(mFrame)->
33368:     PaintTitle(*aCtx, mVisibleRect, aBuilder->ToReferenceFrame(mFrame));
    1: }
    1: 
21991: nsRect
21991: nsDisplayXULTextBox::GetBounds(nsDisplayListBuilder* aBuilder) {
21991:   return mFrame->GetOverflowRect() + aBuilder->ToReferenceFrame(mFrame);
21991: }
21991: 
    1: NS_IMETHODIMP
    1: nsTextBoxFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                  const nsRect&           aDirtyRect,
    1:                                  const nsDisplayListSet& aLists)
    1: {
    1:     if (!IsVisibleForPainting(aBuilder))
    1:       return NS_OK;
    1: 
    1:     nsresult rv = nsLeafBoxFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     return aLists.Content()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayXULTextBox(this));
    1: }
    1: 
    1: void
    1: nsTextBoxFrame::PaintTitle(nsIRenderingContext& aRenderingContext,
    1:                            const nsRect&        aDirtyRect,
    1:                            nsPoint              aPt)
    1: {
    1:     if (mTitle.IsEmpty())
    1:         return;
    1: 
19949:     nsRect textRect(CalcTextRect(aRenderingContext, aPt));
    1: 
19949:     // Paint the text shadow before doing any foreground stuff
    1:     const nsStyleText* textStyle = GetStyleText();
19949:     if (textStyle->mTextShadow) {
19949:       // Text shadow happens with the last value being painted at the back,
19949:       // ie. it is painted first.
19949:       for (PRUint32 i = textStyle->mTextShadow->Length(); i > 0; --i) {
19949:         PaintOneShadow(aRenderingContext.ThebesContext(),
19949:                        textRect,
19949:                        textStyle->mTextShadow->ShadowAt(i - 1),
22183:                        GetStyleColor()->mColor,
22183:                        aDirtyRect);
    1:       }
    1:     }
    1: 
19961:     DrawText(aRenderingContext, textRect, nsnull);
19949: }
19949: 
19949: void
19949: nsTextBoxFrame::DrawText(nsIRenderingContext& aRenderingContext,
19949:                          const nsRect&        aTextRect,
19961:                          const nscolor*       aOverrideColor)
19949: {
19949:     nsPresContext* presContext = PresContext();
    1: 
    1:     // paint the title
    1:     nscolor overColor;
    1:     nscolor underColor;
    1:     nscolor strikeColor;
    1:     nsStyleContext* context = mStyleContext;
    1:   
    1:     PRUint8 decorations = NS_STYLE_TEXT_DECORATION_NONE; // Begin with no decorations
    1:     PRUint8 decorMask = NS_STYLE_TEXT_DECORATION_UNDERLINE | NS_STYLE_TEXT_DECORATION_OVERLINE |
    1:                         NS_STYLE_TEXT_DECORATION_LINE_THROUGH; // A mask of all possible decorations.
    1:     PRBool hasDecorations = context->HasTextDecorations();
    1: 
    1:     do {  // find decoration colors
    1:       const nsStyleTextReset* styleText = context->GetStyleTextReset();
    1:       
    1:       if (decorMask & styleText->mTextDecoration) {  // a decoration defined here
19961:         nscolor color = aOverrideColor ? *aOverrideColor : context->GetStyleColor()->mColor;
    1:     
    1:         if (NS_STYLE_TEXT_DECORATION_UNDERLINE & decorMask & styleText->mTextDecoration) {
    1:           underColor = color;
    1:           decorMask &= ~NS_STYLE_TEXT_DECORATION_UNDERLINE;
    1:           decorations |= NS_STYLE_TEXT_DECORATION_UNDERLINE;
    1:         }
    1:         if (NS_STYLE_TEXT_DECORATION_OVERLINE & decorMask & styleText->mTextDecoration) {
    1:           overColor = color;
    1:           decorMask &= ~NS_STYLE_TEXT_DECORATION_OVERLINE;
    1:           decorations |= NS_STYLE_TEXT_DECORATION_OVERLINE;
    1:         }
    1:         if (NS_STYLE_TEXT_DECORATION_LINE_THROUGH & decorMask & styleText->mTextDecoration) {
    1:           strikeColor = color;
    1:           decorMask &= ~NS_STYLE_TEXT_DECORATION_LINE_THROUGH;
    1:           decorations |= NS_STYLE_TEXT_DECORATION_LINE_THROUGH;
    1:         }
    1:       }
    1:       if (0 != decorMask) {
    1:         context = context->GetParent();
    1:         if (context) {
    1:           hasDecorations = context->HasTextDecorations();
    1:         }
    1:       }
    1:     } while (context && hasDecorations && (0 != decorMask));
    1: 
 4353:     nsCOMPtr<nsIFontMetrics> fontMet;
 4353:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
    1: 
    1:     nscoord offset;
    1:     nscoord size;
 5601:     nscoord ascent;
 5601:     fontMet->GetMaxAscent(ascent);
    1: 
 5601:     nscoord baseline =
19949:       presContext->RoundAppUnitsToNearestDevPixels(aTextRect.y + ascent);
 9438:     nsRefPtr<gfxContext> ctx = aRenderingContext.ThebesContext();
19949:     gfxPoint pt(presContext->AppUnitsToGfxUnits(aTextRect.x),
19949:                 presContext->AppUnitsToGfxUnits(aTextRect.y));
19949:     gfxFloat width = presContext->AppUnitsToGfxUnits(aTextRect.width);
 5601:     gfxFloat ascentPixel = presContext->AppUnitsToGfxUnits(ascent);
20037: 
20037:     // Underlines are drawn before overlines, and both before the text
20037:     // itself, per http://www.w3.org/TR/CSS21/zindex.html point 7.2.1.4.1.1.
20037:     // (We don't apply this rule to the access-key underline because we only
20037:     // find out where that is as a side effect of drawing the text, in the
20037:     // general case -- see below.)
20037:     if (decorations & (NS_FONT_DECORATION_OVERLINE |
20037:                        NS_FONT_DECORATION_UNDERLINE)) {
    1:       fontMet->GetUnderline(offset, size);
 5147:       gfxFloat offsetPixel = presContext->AppUnitsToGfxUnits(offset);
 5147:       gfxFloat sizePixel = presContext->AppUnitsToGfxUnits(size);
20037:       if (decorations & NS_FONT_DECORATION_UNDERLINE) {
20037:         nsCSSRendering::PaintDecorationLine(ctx, underColor,
20037:                           pt, gfxSize(width, sizePixel),
20037:                           ascentPixel, offsetPixel,
20037:                           NS_STYLE_TEXT_DECORATION_UNDERLINE,
26883:                           nsCSSRendering::DECORATION_STYLE_SOLID);
20037:       }
    1:       if (decorations & NS_FONT_DECORATION_OVERLINE) {
 4302:         nsCSSRendering::PaintDecorationLine(ctx, overColor,
 4302:                           pt, gfxSize(width, sizePixel),
 5601:                           ascentPixel, ascentPixel,
 4302:                           NS_STYLE_TEXT_DECORATION_OVERLINE,
26883:                           nsCSSRendering::DECORATION_STYLE_SOLID);
    1:       }
    1:     }
    1: 
 4353:     aRenderingContext.SetFont(fontMet);
    1: 
    1:     CalculateUnderline(aRenderingContext);
    1: 
19961:     aRenderingContext.SetColor(aOverrideColor ? *aOverrideColor : GetStyleColor()->mColor);
    1: 
    1: #ifdef IBMBIDI
    1:     nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:     if (mState & NS_FRAME_IS_BIDI) {
15376:       presContext->SetBidiEnabled();
    1:       nsBidiPresUtils* bidiUtils = presContext->GetBidiUtils();
    1: 
    1:       if (bidiUtils) {
    1:         const nsStyleVisibility* vis = GetStyleVisibility();
    1:         nsBidiDirection direction = (NS_STYLE_DIRECTION_RTL == vis->mDirection) ? NSBIDI_RTL : NSBIDI_LTR;
    1:         if (mAccessKeyInfo && mAccessKeyInfo->mAccesskeyIndex != kNotFound) {
    1:            // We let the RenderText function calculate the mnemonic's
    1:            // underline position for us.
    1:            nsBidiPositionResolve posResolve;
    1:            posResolve.logicalIndex = mAccessKeyInfo->mAccesskeyIndex;
    1:            rv = bidiUtils->RenderText(mCroppedTitle.get(), mCroppedTitle.Length(), direction,
    1:                                       presContext, aRenderingContext,
19949:                                       aTextRect.x, baseline,
    1:                                       &posResolve,
    1:                                       1);
    1:            mAccessKeyInfo->mBeforeWidth = posResolve.visualLeftTwips;
26442:            mAccessKeyInfo->mAccessWidth = posResolve.visualWidth;
    1:         }
    1:         else
    1:         {
    1:            rv = bidiUtils->RenderText(mCroppedTitle.get(), mCroppedTitle.Length(), direction,
    1:                                       presContext, aRenderingContext,
19949:                                       aTextRect.x, baseline);
    1:         }
    1:       }
    1:     }
    1:     if (NS_FAILED(rv) )
    1: #endif // IBMBIDI
    1:     {
    1:        aRenderingContext.SetTextRunRTL(PR_FALSE);
    1: 
    1:        if (mAccessKeyInfo && mAccessKeyInfo->mAccesskeyIndex != kNotFound) {
    1:            // In the simple (non-BiDi) case, we calculate the mnemonic's
    1:            // underline position by getting the text metric.
    1:            // XXX are attribute values always two byte?
    1:            if (mAccessKeyInfo->mAccesskeyIndex > 0)
    1:                aRenderingContext.GetWidth(mCroppedTitle.get(), mAccessKeyInfo->mAccesskeyIndex,
    1:                                           mAccessKeyInfo->mBeforeWidth);
    1:            else
    1:                mAccessKeyInfo->mBeforeWidth = 0;
    1:        }
    1: 
19949:        aRenderingContext.DrawString(mCroppedTitle, aTextRect.x, baseline);
    1:     }
    1: 
    1:     if (mAccessKeyInfo && mAccessKeyInfo->mAccesskeyIndex != kNotFound) {
19949:         aRenderingContext.FillRect(aTextRect.x + mAccessKeyInfo->mBeforeWidth,
19949:                                    aTextRect.y + mAccessKeyInfo->mAccessOffset,
    1:                                    mAccessKeyInfo->mAccessWidth,
    1:                                    mAccessKeyInfo->mAccessUnderlineSize);
    1:     }
20037: 
20037:     // Strikeout is drawn on top of the text, per
20037:     // http://www.w3.org/TR/CSS21/zindex.html point 7.2.1.4.1.1.
20037:     if (decorations & NS_FONT_DECORATION_LINE_THROUGH) {
20037:       fontMet->GetStrikeout(offset, size);
20037:       gfxFloat offsetPixel = presContext->AppUnitsToGfxUnits(offset);
20037:       gfxFloat sizePixel = presContext->AppUnitsToGfxUnits(size);
20037:       nsCSSRendering::PaintDecorationLine(ctx, strikeColor,
26883:                         pt, gfxSize(width, sizePixel), ascentPixel, offsetPixel,
20037:                         NS_STYLE_TEXT_DECORATION_LINE_THROUGH,
26883:                         nsCSSRendering::DECORATION_STYLE_SOLID);
20037:     }
    1: }
    1: 
19949: void nsTextBoxFrame::PaintOneShadow(gfxContext*      aCtx,
19949:                                     const nsRect&    aTextRect,
19949:                                     nsCSSShadowItem* aShadowDetails,
22183:                                     const nscolor&   aForegroundColor,
22183:                                     const nsRect&    aDirtyRect) {
19949:   nsPoint shadowOffset(aShadowDetails->mXOffset,
19949:                        aShadowDetails->mYOffset);
32531:   nscoord blurRadius = NS_MAX(aShadowDetails->mRadius, 0);
19949: 
19949:   nsRect shadowRect(aTextRect);
19949:   shadowRect.MoveBy(shadowOffset);
19949: 
19949:   nsContextBoxBlur contextBoxBlur;
32863:   gfxContext* shadowContext = contextBoxBlur.Init(shadowRect, blurRadius,
19949:                                                   PresContext()->AppUnitsPerDevPixel(),
40965:                                                   aCtx, aDirtyRect, nsnull);
32237: 
19949:   if (!shadowContext)
19949:     return;
19949: 
19949:   nscolor shadowColor;
19949:   if (aShadowDetails->mHasColor)
19949:     shadowColor = aShadowDetails->mColor;
19949:   else
19949:     shadowColor = aForegroundColor;
19949: 
19949:   // Conjure an nsIRenderingContext from a gfxContext for DrawText
19949:   nsCOMPtr<nsIRenderingContext> renderingContext = nsnull;
19949:   nsIDeviceContext* devCtx = PresContext()->DeviceContext();
19949:   devCtx->CreateRenderingContextInstance(*getter_AddRefs(renderingContext));
32863:   if (!renderingContext)
32863:     return;
19949:   renderingContext->Init(devCtx, shadowContext);
19949: 
19949:   aCtx->Save();
19949:   aCtx->NewPath();
19949:   aCtx->SetColor(gfxRGBA(shadowColor));
19949: 
19949:   // Draw the text onto our alpha-only surface to capture the alpha values.
19949:   // Remember that the box blur context has a device offset on it, so we don't need to
19949:   // translate any coordinates to fit on the surface.
19961:   DrawText(*renderingContext, shadowRect, &shadowColor);
19949:   contextBoxBlur.DoPaint();
19949:   aCtx->Restore();
19949: }
19949: 
    1: void
    1: nsTextBoxFrame::LayoutTitle(nsPresContext*      aPresContext,
    1:                             nsIRenderingContext& aRenderingContext,
    1:                             const nsRect&        aRect)
    1: {
    1:     // and do caculations if our size changed
    1:     if ((mState & NS_STATE_NEED_LAYOUT)) {
    1: 
    1:         // determine (cropped) title which fits in aRect.width and its width
    1:         CalculateTitleForWidth(aPresContext, aRenderingContext, aRect.width);
    1: 
    1:         // determine if and at which position to put the underline
    1:         UpdateAccessIndex();
    1: 
    1:         // ok layout complete
    1:         mState &= ~NS_STATE_NEED_LAYOUT;
    1:     }
    1: }
    1: 
    1: void
    1: nsTextBoxFrame::CalculateUnderline(nsIRenderingContext& aRenderingContext)
    1: {
    1:     if (mAccessKeyInfo && mAccessKeyInfo->mAccesskeyIndex != kNotFound) {
    1:          // Calculate all fields of mAccessKeyInfo which
    1:          // are the same for both BiDi and non-BiDi frames.
    1:          const PRUnichar *titleString = mCroppedTitle.get();
    1:          aRenderingContext.SetTextRunRTL(PR_FALSE);
    1:          aRenderingContext.GetWidth(titleString[mAccessKeyInfo->mAccesskeyIndex],
    1:                                     mAccessKeyInfo->mAccessWidth);
    1: 
    1:          nscoord offset, baseline;
    1:          nsIFontMetrics *metrics;
    1:          aRenderingContext.GetFontMetrics(metrics);
    1:          metrics->GetUnderline(offset, mAccessKeyInfo->mAccessUnderlineSize);
    1:          metrics->GetMaxAscent(baseline);
    1:          NS_RELEASE(metrics);
    1:          mAccessKeyInfo->mAccessOffset = baseline - offset;
    1:     }
    1: }
    1: 
    1: void
    1: nsTextBoxFrame::CalculateTitleForWidth(nsPresContext*      aPresContext,
    1:                                        nsIRenderingContext& aRenderingContext,
    1:                                        nscoord              aWidth)
    1: {
    1:     if (mTitle.IsEmpty())
    1:         return;
    1: 
 4353:     nsLayoutUtils::SetFontFromStyle(&aRenderingContext, GetStyleContext());
    1: 
    1:     // see if the text will completely fit in the width given
    1:     mTitleWidth = nsLayoutUtils::GetStringWidth(this, &aRenderingContext,
    1:                                                 mTitle.get(), mTitle.Length());
    1: 
    1:     if (mTitleWidth <= aWidth) {
    1:         mCroppedTitle = mTitle;
    1: #ifdef IBMBIDI
12922:         if (HasRTLChars(mTitle)) {
    1:             mState |= NS_FRAME_IS_BIDI;
    1:         }
    1: #endif // IBMBIDI
    1:         return;  // fits, done.
    1:     }
    1: 
10727:     const nsDependentString& kEllipsis = nsContentUtils::GetLocalizedEllipsis();
    1:     // start with an ellipsis
 8167:     mCroppedTitle.Assign(kEllipsis);
    1: 
    1:     // see if the width is even smaller than the ellipsis
    1:     // if so, clear the text (XXX set as many '.' as we can?).
    1:     aRenderingContext.SetTextRunRTL(PR_FALSE);
23390:     aRenderingContext.GetWidth(kEllipsis, mTitleWidth);
    1: 
23390:     if (mTitleWidth > aWidth) {
    1:         mCroppedTitle.SetLength(0);
23390:         mTitleWidth = 0;
    1:         return;
    1:     }
    1: 
    1:     // if the ellipsis fits perfectly, no use in trying to insert
23390:     if (mTitleWidth == aWidth)
    1:         return;
    1: 
23390:     aWidth -= mTitleWidth;
    1: 
    1:     // XXX: This whole block should probably take surrogates into account
    1:     // XXX and clusters!
    1:     // ok crop things
    1:     switch (mCropType)
    1:     {
    1:         case CropNone:
    1:         case CropRight:
    1:         {
    1:             nscoord cwidth;
    1:             nscoord twidth = 0;
    1:             int length = mTitle.Length();
    1:             int i;
    1:             for (i = 0; i < length; ++i) {
    1:                 PRUnichar ch = mTitle.CharAt(i);
    1:                 // still in LTR mode
    1:                 aRenderingContext.GetWidth(ch,cwidth);
    1:                 if (twidth + cwidth > aWidth)
    1:                     break;
    1: 
    1:                 twidth += cwidth;
    1: #ifdef IBMBIDI
    1:                 if (UCS2_CHAR_IS_BIDI(ch) ) {
    1:                   mState |= NS_FRAME_IS_BIDI;
    1:                 }
    1: #endif // IBMBIDI
    1:             }
    1: 
    1:             if (i == 0)
    1:                 return;
    1: 
    1:             // insert what character we can in.
    1:             nsAutoString title( mTitle );
    1:             title.Truncate(i);
    1:             mCroppedTitle.Insert(title, 0);
    1:         }
    1:         break;
    1: 
    1:         case CropLeft:
    1:         {
    1:             nscoord cwidth;
    1:             nscoord twidth = 0;
    1:             int length = mTitle.Length();
    1:             int i;
    1:             for (i=length-1; i >= 0; --i) {
    1:                 PRUnichar ch = mTitle.CharAt(i);
    1:                 aRenderingContext.GetWidth(ch,cwidth);
    1:                 if (twidth + cwidth > aWidth)
    1:                     break;
    1: 
    1:                 twidth += cwidth;
    1: #ifdef IBMBIDI
    1:                 if (UCS2_CHAR_IS_BIDI(ch) ) {
    1:                   mState |= NS_FRAME_IS_BIDI;
    1:                 }
    1: #endif // IBMBIDI
    1:             }
    1: 
    1:             if (i == length-1)
23390:                 return;
    1: 
    1:             nsAutoString copy;
    1:             mTitle.Right(copy, length-1-i);
    1:             mCroppedTitle += copy;
    1:         }
    1:         break;
    1: 
    1:         case CropCenter:
    1:         {
    1:             nscoord stringWidth =
    1:                 nsLayoutUtils::GetStringWidth(this, &aRenderingContext,
    1:                                               mTitle.get(), mTitle.Length());
    1:             if (stringWidth <= aWidth) {
    1:                 // the entire string will fit in the maximum width
    1:                 mCroppedTitle.Insert(mTitle, 0);
    1:                 break;
    1:             }
    1: 
    1:             // determine how much of the string will fit in the max width
    1:             nscoord charWidth = 0;
    1:             nscoord totalWidth = 0;
    1:             PRUnichar ch;
    1:             int leftPos, rightPos;
    1:             nsAutoString leftString, rightString;
    1: 
    1:             rightPos = mTitle.Length() - 1;
    1:             aRenderingContext.SetTextRunRTL(PR_FALSE);
    1:             for (leftPos = 0; leftPos <= rightPos;) {
    1:                 // look at the next character on the left end
    1:                 ch = mTitle.CharAt(leftPos);
    1:                 aRenderingContext.GetWidth(ch, charWidth);
    1:                 totalWidth += charWidth;
    1:                 if (totalWidth > aWidth)
    1:                     // greater than the allowable width
    1:                     break;
    1:                 leftString.Insert(ch, leftString.Length());
    1: 
    1: #ifdef IBMBIDI
    1:                 if (UCS2_CHAR_IS_BIDI(ch))
    1:                     mState |= NS_FRAME_IS_BIDI;
    1: #endif
    1: 
    1:                 // look at the next character on the right end
    1:                 if (rightPos > leftPos) {
    1:                     // haven't looked at this character yet
    1:                     ch = mTitle.CharAt(rightPos);
    1:                     aRenderingContext.GetWidth(ch, charWidth);
    1:                     totalWidth += charWidth;
    1:                     if (totalWidth > aWidth)
    1:                         // greater than the allowable width
    1:                         break;
    1:                     rightString.Insert(ch, 0);
    1: 
    1: #ifdef IBMBIDI
    1:                     if (UCS2_CHAR_IS_BIDI(ch))
    1:                         mState |= NS_FRAME_IS_BIDI;
    1: #endif
    1:                 }
    1: 
    1:                 // look at the next two characters
    1:                 leftPos++;
    1:                 rightPos--;
    1:             }
    1: 
 8167:             mCroppedTitle = leftString + kEllipsis + rightString;
    1:         }
    1:         break;
    1:     }
    1: 
    1:     mTitleWidth = nsLayoutUtils::GetStringWidth(this, &aRenderingContext,
    1:                                                 mCroppedTitle.get(), mCroppedTitle.Length());
    1: }
    1: 
 8167: #define OLD_ELLIPSIS NS_LITERAL_STRING("...")
 8167: 
    1: // the following block is to append the accesskey to mTitle if there is an accesskey
    1: // but the mTitle doesn't have the character
    1: void
    1: nsTextBoxFrame::UpdateAccessTitle()
    1: {
    1:     /*
    1:      * Note that if you change appending access key label spec,
    1:      * you need to maintain same logic in following methods. See bug 324159.
    1:      * toolkit/content/commonDialog.js (setLabelForNode)
    1:      * toolkit/content/widgets/text.xml (formatAccessKey)
    1:      */
    1:     PRInt32 menuAccessKey;
    1:     nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
    1:     if (!menuAccessKey || mAccessKey.IsEmpty())
    1:         return;
    1: 
    1:     if (!AlwaysAppendAccessKey() &&
    1:         FindInReadable(mAccessKey, mTitle, nsCaseInsensitiveStringComparator()))
    1:         return;
    1: 
    1:     nsAutoString accessKeyLabel;
    1:     accessKeyLabel += '(';
    1:     accessKeyLabel += mAccessKey;
    1:     ToUpperCase(accessKeyLabel);
    1:     accessKeyLabel += ')';
    1: 
    1:     if (mTitle.IsEmpty()) {
    1:         mTitle = accessKeyLabel;
    1:         return;
    1:     }
    1: 
10727:     const nsDependentString& kEllipsis = nsContentUtils::GetLocalizedEllipsis();
 8998:     PRUint32 offset = mTitle.Length();
 8998:     if (StringEndsWith(mTitle, kEllipsis)) {
 8998:         offset -= kEllipsis.Length();
 8998:     } else if (StringEndsWith(mTitle, OLD_ELLIPSIS)) {
 8167:         // Try to check with our old ellipsis (for old addons)
 8998:         offset -= OLD_ELLIPSIS.Length();
 8998:     } else {
 8998:         // Try to check with
 8998:         // our default ellipsis (for non-localized addons) or ':'
 8998:         const PRUnichar kLastChar = mTitle.Last();
 8998:         if (kLastChar == PRUnichar(0x2026) || kLastChar == PRUnichar(':'))
    1:             offset--;
    1:     }
    1: 
 8998:     if (InsertSeparatorBeforeAccessKey() &&
42182:         !NS_IS_SPACE(mTitle[offset - 1])) {
 8998:         mTitle.Insert(' ', offset);
    1:         offset++;
    1:     }
    1: 
 8998:     mTitle.Insert(accessKeyLabel, offset);
    1: }
    1: 
    1: void
    1: nsTextBoxFrame::UpdateAccessIndex()
    1: {
    1:     PRInt32 menuAccessKey;
    1:     nsMenuBarListener::GetMenuAccessKey(&menuAccessKey);
    1:     if (menuAccessKey) {
    1:         if (mAccessKey.IsEmpty()) {
    1:             if (mAccessKeyInfo) {
    1:                 delete mAccessKeyInfo;
    1:                 mAccessKeyInfo = nsnull;
    1:             }
    1:         } else {
    1:             if (!mAccessKeyInfo) {
    1:                 mAccessKeyInfo = new nsAccessKeyInfo();
    1:                 if (!mAccessKeyInfo)
    1:                     return;
    1:             }
    1: 
    1:             nsAString::const_iterator start, end;
    1:                 
    1:             mCroppedTitle.BeginReading(start);
    1:             mCroppedTitle.EndReading(end);
    1:             
    1:             // remember the beginning of the string
    1:             nsAString::const_iterator originalStart = start;
    1: 
    1:             PRBool found;
    1:             if (!AlwaysAppendAccessKey()) {
    1:                 // not appending access key - do case-sensitive search
    1:                 // first
    1:                 found = FindInReadable(mAccessKey, start, end);
    1:                 if (!found) {
    1:                     // didn't find it - perform a case-insensitive search
    1:                     start = originalStart;
    1:                     found = FindInReadable(mAccessKey, start, end,
    1:                                            nsCaseInsensitiveStringComparator());
    1:                 }
    1:             } else {
    1:                 found = RFindInReadable(mAccessKey, start, end,
    1:                                         nsCaseInsensitiveStringComparator());
    1:             }
    1:             
    1:             if (found)
    1:                 mAccessKeyInfo->mAccesskeyIndex = Distance(originalStart, start);
    1:             else
    1:                 mAccessKeyInfo->mAccesskeyIndex = kNotFound;
    1:         }
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTextBoxFrame::DoLayout(nsBoxLayoutState& aBoxLayoutState)
    1: {
 5624:     if (mNeedsReflowCallback) {
 5624:         nsIReflowCallback* cb = new nsAsyncAccesskeyUpdate(this);
 5624:         if (cb) {
 5624:             PresContext()->PresShell()->PostReflowCallback(cb);
 5624:         }
 5624:         mNeedsReflowCallback = PR_FALSE;
 5624:     }
 5624: 
    1:     mState |= NS_STATE_NEED_LAYOUT;
    1: 
19949:     nsresult rv = nsLeafBoxFrame::DoLayout(aBoxLayoutState);
19949: 
19949:     const nsStyleText* textStyle = GetStyleText();
19949:     if (textStyle->mTextShadow) {
19949:       nsPoint origin(0,0);
19949:       nsRect textRect = CalcTextRect(*aBoxLayoutState.GetRenderingContext(), origin);
19949:       nsRect overflowRect(nsLayoutUtils::GetTextShadowRectsUnion(textRect, this));
20143:       overflowRect.UnionRect(overflowRect, nsRect(nsPoint(0, 0), GetSize()));
19949:       FinishAndStoreOverflow(&overflowRect, GetSize());
19949:     }
19949:     return rv;
    1: }
    1: 
21991: PRBool
21991: nsTextBoxFrame::ComputesOwnOverflowArea()
21991: {
21991:     return PR_TRUE;
21991: }
21991: 
    1: /* virtual */ void
    1: nsTextBoxFrame::MarkIntrinsicWidthsDirty()
    1: {
    1:     mNeedsRecalc = PR_TRUE;
    1:     nsTextBoxFrameSuper::MarkIntrinsicWidthsDirty();
    1: }
    1: 
    1: void
    1: nsTextBoxFrame::GetTextSize(nsPresContext* aPresContext, nsIRenderingContext& aRenderingContext,
    1:                                 const nsString& aString, nsSize& aSize, nscoord& aAscent)
    1: {
    1:     nsCOMPtr<nsIFontMetrics> fontMet;
 4353:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fontMet));
    1:     fontMet->GetHeight(aSize.height);
    1:     aRenderingContext.SetFont(fontMet);
    1:     aSize.width =
    1:       nsLayoutUtils::GetStringWidth(this, &aRenderingContext, aString.get(), aString.Length());
    1:     fontMet->GetMaxAscent(aAscent);
    1: }
    1: 
    1: void
    1: nsTextBoxFrame::CalcTextSize(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:     if (mNeedsRecalc)
    1:     {
    1:         nsSize size;
    1:         nsPresContext* presContext = aBoxLayoutState.PresContext();
    1:         nsIRenderingContext* rendContext = aBoxLayoutState.GetRenderingContext();
    1:         if (rendContext) {
    1:             GetTextSize(presContext, *rendContext,
    1:                         mTitle, size, mAscent);
    1:             mTextSize = size;
    1:             mNeedsRecalc = PR_FALSE;
    1:         }
    1:     }
    1: }
    1: 
19949: nsRect
19949: nsTextBoxFrame::CalcTextRect(nsIRenderingContext &aRenderingContext, const nsPoint &aTextOrigin)
19949: {
19949:     nsRect textRect(aTextOrigin, GetSize());
20712:     nsMargin borderPadding;
20712:     GetBorderAndPadding(borderPadding);
20712:     textRect.Deflate(borderPadding);
19949:     // determine (cropped) title and underline position
19949:     nsPresContext* presContext = PresContext();
19949:     LayoutTitle(presContext, aRenderingContext, textRect);
19949: 
19949:     // make the rect as small as our (cropped) text.
19949:     nscoord outerWidth = textRect.width;
19949:     textRect.width = mTitleWidth;
19949: 
19949:     // Align our text within the overall rect by checking our text-align property.
19949:     const nsStyleVisibility* vis = GetStyleVisibility();
19949:     const nsStyleText* textStyle = GetStyleText();
19949: 
19949:     if (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_CENTER)
19949:       textRect.x += (outerWidth - textRect.width)/2;
24696:     else if (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_RIGHT ||
24696:              (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_DEFAULT &&
24696:               vis->mDirection == NS_STYLE_DIRECTION_RTL) ||
24696:              (textStyle->mTextAlign == NS_STYLE_TEXT_ALIGN_END &&
24696:               vis->mDirection == NS_STYLE_DIRECTION_LTR)) {
19949:       textRect.x += (outerWidth - textRect.width);
19949:     }
19949:     return textRect;
19949: }
19949: 
    1: /**
    1:  * Ok return our dimensions
    1:  */
    1: nsSize
    1: nsTextBoxFrame::GetPrefSize(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:     CalcTextSize(aBoxLayoutState);
    1: 
    1:     nsSize size = mTextSize;
    1:     DISPLAY_PREF_SIZE(this, size);
    1: 
    1:     AddBorderAndPadding(size);
39604:     PRBool widthSet, heightSet;
39604:     nsIBox::AddCSSPrefSize(this, size, widthSet, heightSet);
    1: 
    1:     return size;
    1: }
    1: 
    1: /**
    1:  * Ok return our dimensions
    1:  */
    1: nsSize
    1: nsTextBoxFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:     CalcTextSize(aBoxLayoutState);
    1: 
    1:     nsSize size = mTextSize;
    1:     DISPLAY_MIN_SIZE(this, size);
    1: 
    1:     // if there is cropping our min width becomes our border and padding
    1:     if (mCropType != CropNone)
    1:         size.width = 0;
    1: 
    1:     AddBorderAndPadding(size);
39604:     PRBool widthSet, heightSet;
39604:     nsIBox::AddCSSMinSize(aBoxLayoutState, this, size, widthSet, heightSet);
    1: 
    1:     return size;
    1: }
    1: 
    1: nscoord
    1: nsTextBoxFrame::GetBoxAscent(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:     CalcTextSize(aBoxLayoutState);
    1: 
    1:     nscoord ascent = mAscent;
    1: 
    1:     nsMargin m(0,0,0,0);
    1:     GetBorderAndPadding(m);
    1:     ascent += m.top;
    1: 
    1:     return ascent;
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsTextBoxFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:     MakeFrameName(NS_LITERAL_STRING("TextBox"), aResult);
    1:     aResult += NS_LITERAL_STRING("[value=") + mTitle + NS_LITERAL_STRING("]");
    1:     return NS_OK;
    1: }
    1: #endif
    1: 
    1: // If you make changes to this function, check its counterparts 
23176: // in nsBoxFrame and nsXULLabelFrame
    1: nsresult
    1: nsTextBoxFrame::RegUnregAccessKey(PRBool aDoReg)
    1: {
    1:     // if we have no content, we can't do anything
    1:     if (!mContent)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // check if we have a |control| attribute
    1:     // do this check first because few elements have control attributes, and we
    1:     // can weed out most of the elements quickly.
    1: 
    1:     // XXXjag a side-effect is that we filter out anonymous <label>s
    1:     // in e.g. <menu>, <menuitem>, <button>. These <label>s inherit
    1:     // |accesskey| and would otherwise register themselves, overwriting
    1:     // the content we really meant to be registered.
    1:     if (!mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::control))
    1:         return NS_OK;
    1: 
    1:     // see if we even have an access key
    1:     nsAutoString accessKey;
    1:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);
    1: 
    1:     if (accessKey.IsEmpty())
    1:         return NS_OK;
    1: 
    1:     nsresult rv;
    1: 
    1:     // With a valid PresContext we can get the ESM 
    1:     // and (un)register the access key
  238:     nsIEventStateManager *esm = PresContext()->EventStateManager();
    1: 
    1:     PRUint32 key = accessKey.First();
    1:     if (aDoReg)
    1:         rv = esm->RegisterAccessKey(mContent, key);
    1:     else
    1:         rv = esm->UnregisterAccessKey(mContent, key);
    1: 
    1:     return rv;
    1: }
