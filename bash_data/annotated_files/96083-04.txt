    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for DOM Core's nsIDOMComment, nsIDOMDocumentType, nsIDOMText,
    1:  * nsIDOMCDATASection, and nsIDOMProcessingInstruction nodes.
    1:  */
    1: 
    1: #include "nsGenericDOMDataNode.h"
    1: #include "nsGenericElement.h"
    1: #include "nsIDocument.h"
72328: #include "nsEventListenerManager.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsMutationEvent.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIURI.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIDOMText.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsDOMString.h"
    1: #include "nsIDOMUserDataHandler.h"
    1: #include "nsChangeHint.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsCOMArray.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsBindingManager.h"
13669: #include "nsCCUncollectableMarker.h"
14228: #include "mozAutoDocUpdate.h"
84833: #include "nsAsyncDOMEvent.h"
    1: 
    1: #include "pldhash.h"
    1: #include "prprf.h"
80074: #include "nsWrapperCacheInlines.h"
    1: 
74270: using namespace mozilla;
63693: 
94340: nsGenericDOMDataNode::nsGenericDOMDataNode(already_AddRefed<nsINodeInfo> aNodeInfo)
11169:   : nsIContent(aNodeInfo)
    1: {
71770:   NS_ABORT_IF_FALSE(mNodeInfo->NodeType() == nsIDOMNode::TEXT_NODE ||
71770:                     mNodeInfo->NodeType() == nsIDOMNode::CDATA_SECTION_NODE ||
71770:                     mNodeInfo->NodeType() == nsIDOMNode::COMMENT_NODE ||
71770:                     mNodeInfo->NodeType() ==
71770:                       nsIDOMNode::PROCESSING_INSTRUCTION_NODE ||
71770:                     mNodeInfo->NodeType() == nsIDOMNode::DOCUMENT_TYPE_NODE,
71770:                     "Bad NodeType in aNodeInfo");
    1: }
    1: 
    1: nsGenericDOMDataNode::~nsGenericDOMDataNode()
    1: {
    1:   NS_PRECONDITION(!IsInDoc(),
    1:                   "Please remove this from the document properly");
74344:   if (GetParent()) {
74344:     NS_RELEASE(mParent);
74344:   }
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGenericDOMDataNode)
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsGenericDOMDataNode)
77323:   nsINode::Trace(tmp, aCallback, aClosure);
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_END
30001: 
88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsGenericDOMDataNode)
89979:   return nsGenericElement::CanSkip(tmp, aRemovingAllowed);
88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
88521: 
88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsGenericDOMDataNode)
88521:   return nsGenericElement::CanSkipInCC(tmp);
88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
88521: 
88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsGenericDOMDataNode)
88521:   return nsGenericElement::CanSkipThis(tmp);
88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
88521: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGenericDOMDataNode)
30001:   // Always need to traverse script objects, so do that before we check
30001:   // if we're uncollectable.
30001:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
30001: 
77323:   if (!nsINode::Traverse(tmp, cb)) {
25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
13669:   }
13669: 
80527:   tmp->OwnerDoc()->BindingManager()->Traverse(tmp, cb);
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
67680: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGenericDOMDataNode)
77323:   nsINode::Unlink(tmp);
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
21618: NS_INTERFACE_MAP_BEGIN(nsGenericDOMDataNode)
21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
21618:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsGenericDOMDataNode)
    1:   NS_INTERFACE_MAP_ENTRY(nsIContent)
    1:   NS_INTERFACE_MAP_ENTRY(nsINode)
72322:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)
    1:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsISupportsWeakReference,
    1:                                  new nsNodeSupportsWeakRefTearoff(this))
29215:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMXPathNSResolver,
29215:                                  new nsNode3Tearoff(this))
 8856:   // nsNodeSH::PreCreate() depends on the identity pointer being the
 8856:   // same as nsINode (which nsIContent inherits), so if you change the
 8856:   // below line, make sure nsNodeSH::PreCreate() still does the right
 8856:   // thing!
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContent)
    1: NS_INTERFACE_MAP_END
    1: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsGenericDOMDataNode)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_DESTROY(nsGenericDOMDataNode,
 1391:                                               nsNodeUtils::LastRelease(this))
    1: 
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetNodeValue(nsAString& aNodeValue)
    1: {
    1:   return GetData(aNodeValue);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetNodeValue(const nsAString& aNodeValue)
    1: {
    1:   return SetTextInternal(0, mText.GetLength(), aNodeValue.BeginReading(),
80486:                          aNodeValue.Length(), true);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetNamespaceURI(nsAString& aNamespaceURI)
    1: {
    1:   SetDOMStringToNull(aNamespaceURI);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetPrefix(nsAString& aPrefix)
    1: {
    1:   SetDOMStringToNull(aPrefix);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::IsSupported(const nsAString& aFeature,
    1:                                   const nsAString& aVersion,
79445:                                   bool* aReturn)
    1: {
 3233:   return nsGenericElement::InternalIsSupported(static_cast<nsIContent*>(this),
    1:                                                aFeature, aVersion, aReturn);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Implementation of nsIDOMCharacterData
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetData(nsAString& aData) const
    1: {
    1:   if (mText.Is2b()) {
    1:     aData.Assign(mText.Get2b(), mText.GetLength());
    1:   } else {
    1:     // Must use Substring() since nsDependentCString() requires null
    1:     // terminated strings.
    1: 
    1:     const char *data = mText.Get1b();
    1: 
    1:     if (data) {
    1:       CopyASCIItoUTF16(Substring(data, data + mText.GetLength()), aData);
    1:     } else {
    1:       aData.Truncate();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetData(const nsAString& aData)
    1: {
    1:   return SetTextInternal(0, mText.GetLength(), aData.BeginReading(),
80486:                          aData.Length(), true);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::GetLength(PRUint32* aLength)
    1: {
    1:   *aLength = mText.GetLength();
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SubstringData(PRUint32 aStart, PRUint32 aCount,
    1:                                     nsAString& aReturn)
    1: {
    1:   aReturn.Truncate();
    1: 
40638:   PRUint32 textLength = mText.GetLength();
    1:   if (aStart > textLength) {
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1:   }
    1: 
    1:   PRUint32 amount = aCount;
    1:   if (amount > textLength - aStart) {
    1:     amount = textLength - aStart;
    1:   }
    1: 
    1:   if (mText.Is2b()) {
    1:     aReturn.Assign(mText.Get2b() + aStart, amount);
    1:   } else {
    1:     // Must use Substring() since nsDependentCString() requires null
    1:     // terminated strings.
    1: 
    1:     const char *data = mText.Get1b() + aStart;
    1:     CopyASCIItoUTF16(Substring(data, data + amount), aReturn);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::AppendData(const nsAString& aData)
    1: {
    1:   return SetTextInternal(mText.GetLength(), 0, aData.BeginReading(),
80486:                          aData.Length(), true);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::InsertData(PRUint32 aOffset,
    1:                                  const nsAString& aData)
    1: {
    1:   return SetTextInternal(aOffset, 0, aData.BeginReading(),
80486:                          aData.Length(), true);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::DeleteData(PRUint32 aOffset, PRUint32 aCount)
    1: {
80486:   return SetTextInternal(aOffset, aCount, nsnull, 0, true);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::ReplaceData(PRUint32 aOffset, PRUint32 aCount,
    1:                                   const nsAString& aData)
    1: {
    1:   return SetTextInternal(aOffset, aCount, aData.BeginReading(),
80486:                          aData.Length(), true);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetTextInternal(PRUint32 aOffset, PRUint32 aCount,
    1:                                       const PRUnichar* aBuffer,
79445:                                       PRUint32 aLength, bool aNotify,
76359:                                       CharacterDataChangeInfo::Details* aDetails)
    1: {
    1:   NS_PRECONDITION(aBuffer || !aLength,
    1:                   "Null buffer passed to SetTextInternal!");
    1: 
    1:   // sanitize arguments
    1:   PRUint32 textLength = mText.GetLength();
    1:   if (aOffset > textLength) {
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1:   }
    1: 
40638:   if (aCount > textLength - aOffset) {
40638:     aCount = textLength - aOffset;
40638:   }
40638: 
40638:   PRUint32 endOffset = aOffset + aCount;
40638: 
40638:   // Make sure the text fragment can hold the new data.
40638:   if (aLength > aCount && !mText.CanGrowBy(aLength - aCount)) {
95207:     return NS_ERROR_OUT_OF_MEMORY;
40638:   }
40638: 
    1:   nsIDocument *document = GetCurrentDoc();
    1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
    1: 
79445:   bool haveMutationListeners = aNotify &&
    1:     nsContentUtils::HasMutationListeners(this,
 3137:       NS_EVENT_BITS_MUTATION_CHARACTERDATAMODIFIED,
 3137:       this);
    1: 
    1:   nsCOMPtr<nsIAtom> oldValue;
    1:   if (haveMutationListeners) {
    1:     oldValue = GetCurrentValueAtom();
    1:   }
    1:     
 5681:   if (aNotify) {
 5681:     CharacterDataChangeInfo info = {
 5681:       aOffset == textLength,
 5681:       aOffset,
 5681:       endOffset,
76359:       aLength,
76359:       aDetails
 5681:     };
 5681:     nsNodeUtils::CharacterDataWillChange(this, &info);
 5681:   }
 5681: 
    1:   if (aOffset == 0 && endOffset == textLength) {
78157:     // Replacing whole text or old text was empty.  Don't bother to check for
78157:     // bidi in this string if the document already has bidi enabled.
78157:     mText.SetTo(aBuffer, aLength, !document || !document->GetBidiEnabled());
    1:   }
    1:   else if (aOffset == textLength) {
    1:     // Appending to existing
78157:     mText.Append(aBuffer, aLength, !document || !document->GetBidiEnabled());
    1:   }
    1:   else {
    1:     // Merging old and new
    1: 
    1:     // Allocate new buffer
    1:     PRInt32 newLength = textLength - aCount + aLength;
    1:     PRUnichar* to = new PRUnichar[newLength];
    1:     NS_ENSURE_TRUE(to, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     // Copy over appropriate data
40638:     if (aOffset) {
    1:       mText.CopyTo(to, 0, aOffset);
    1:     }
40638:     if (aLength) {
    1:       memcpy(to + aOffset, aBuffer, aLength * sizeof(PRUnichar));
    1:     }
    1:     if (endOffset != textLength) {
    1:       mText.CopyTo(to + aOffset + aLength, endOffset, textLength - endOffset);
    1:     }
    1: 
    1:     // XXX Add OOM checking to this
78157:     mText.SetTo(to, newLength, !document || !document->GetBidiEnabled());
    1: 
    1:     delete [] to;
    1:   }
    1: 
78157:   if (document && mText.IsBidi()) {
78157:     // If we found bidi characters in mText.SetTo() above, indicate that the
78157:     // document contains bidi characters.
78157:     document->SetBidiEnabled();
78157:   }
    1: 
    1:   // Notify observers
    1:   if (aNotify) {
 5845:     CharacterDataChangeInfo info = {
 5845:       aOffset == textLength,
 5845:       aOffset,
 5845:       endOffset,
76359:       aLength,
76359:       aDetails
 5845:     };
 5845:     nsNodeUtils::CharacterDataChanged(this, &info);
 5845: 
    1:     if (haveMutationListeners) {
80486:       nsMutationEvent mutation(true, NS_MUTATION_CHARACTERDATAMODIFIED);
    1: 
    1:       mutation.mPrevAttrValue = oldValue;
    1:       if (aLength > 0) {
    1:         nsAutoString val;
    1:         mText.AppendTo(val);
    1:         mutation.mNewAttrValue = do_GetAtom(val);
    1:       }
    1: 
80526:       mozAutoSubtreeModified subtree(OwnerDoc(), this);
84833:       (new nsAsyncDOMEvent(this, mutation))->RunDOMEventWhenSafe();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Implementation of nsIContent
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsGenericDOMDataNode::ToCString(nsAString& aBuf, PRInt32 aOffset,
    1:                                 PRInt32 aLen) const
    1: {
    1:   if (mText.Is2b()) {
    1:     const PRUnichar* cp = mText.Get2b() + aOffset;
    1:     const PRUnichar* end = cp + aLen;
    1: 
    1:     while (cp < end) {
    1:       PRUnichar ch = *cp++;
    1:       if (ch == '&') {
    1:         aBuf.AppendLiteral("&amp;");
    1:       } else if (ch == '<') {
    1:         aBuf.AppendLiteral("&lt;");
    1:       } else if (ch == '>') {
    1:         aBuf.AppendLiteral("&gt;");
    1:       } else if ((ch < ' ') || (ch >= 127)) {
    1:         char buf[10];
    1:         PR_snprintf(buf, sizeof(buf), "\\u%04x", ch);
    1:         AppendASCIItoUTF16(buf, aBuf);
    1:       } else {
    1:         aBuf.Append(ch);
    1:       }
    1:     }
    1:   } else {
    1:     unsigned char* cp = (unsigned char*)mText.Get1b() + aOffset;
    1:     const unsigned char* end = cp + aLen;
    1: 
    1:     while (cp < end) {
    1:       PRUnichar ch = *cp++;
    1:       if (ch == '&') {
    1:         aBuf.AppendLiteral("&amp;");
    1:       } else if (ch == '<') {
    1:         aBuf.AppendLiteral("&lt;");
    1:       } else if (ch == '>') {
    1:         aBuf.AppendLiteral("&gt;");
    1:       } else if ((ch < ' ') || (ch >= 127)) {
    1:         char buf[10];
    1:         PR_snprintf(buf, sizeof(buf), "\\u%04x", ch);
    1:         AppendASCIItoUTF16(buf, aBuf);
    1:       } else {
    1:         aBuf.Append(ch);
    1:       }
    1:     }
    1:   }
    1: }
    1: #endif
    1: 
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                                  nsIContent* aBindingParent,
79445:                                  bool aCompileEventHandlers)
    1: {
    1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
    1:   NS_PRECONDITION(HasSameOwnerDoc(NODE_FROM(aParent, aDocument)),
    1:                   "Must have the same owner document");
 1498:   NS_PRECONDITION(!aParent || aDocument == aParent->GetCurrentDoc(),
    1:                   "aDocument must be current doc of aParent");
    1:   NS_PRECONDITION(!GetCurrentDoc() && !IsInDoc(),
    1:                   "Already have a document.  Unbind first!");
    1:   // Note that as we recurse into the kids, they'll have a non-null parent.  So
    1:   // only assert if our parent is _changing_ while we have a parent.
    1:   NS_PRECONDITION(!GetParent() || aParent == GetParent(),
    1:                   "Already have a parent.  Unbind first!");
    1:   NS_PRECONDITION(!GetBindingParent() ||
    1:                   aBindingParent == GetBindingParent() ||
    1:                   (!aBindingParent && aParent &&
    1:                    aParent->GetBindingParent() == GetBindingParent()),
    1:                   "Already have a binding parent.  Unbind first!");
16126:   NS_PRECONDITION(aBindingParent != this,
16126:                   "Content must not be its own binding parent");
16126:   NS_PRECONDITION(!IsRootOfNativeAnonymousSubtree() || 
16126:                   aBindingParent == aParent,
16126:                   "Native anonymous content must have its parent as its "
 1111:                   "own binding parent");
    1: 
    1:   if (!aBindingParent && aParent) {
    1:     aBindingParent = aParent->GetBindingParent();
    1:   }
    1: 
    1:   // First set the binding parent
    1:   if (aBindingParent) {
    1:     nsDataSlots *slots = GetDataSlots();
    1:     NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
    1: 
16126:     NS_ASSERTION(IsRootOfNativeAnonymousSubtree() ||
16126:                  !HasFlag(NODE_IS_IN_ANONYMOUS_SUBTREE) ||
22217:                  (aParent && aParent->IsInNativeAnonymousSubtree()),
14239:                  "Trying to re-bind content from native anonymous subtree to "
14239:                  "non-native anonymous parent!");
    1:     slots->mBindingParent = aBindingParent; // Weak, so no addref happens.
25511:     if (aParent->IsInNativeAnonymousSubtree()) {
14239:       SetFlags(NODE_IS_IN_ANONYMOUS_SUBTREE);
14239:     }
    1:   }
    1: 
    1:   // Set parent
    1:   if (aParent) {
74344:     if (!GetParent()) {
74344:       NS_ADDREF(aParent);
74344:     }
67605:     mParent = aParent;
    1:   }
    1:   else {
67605:     mParent = aDocument;
    1:   }
67605:   SetParentIsContent(aParent);
    1: 
    1:   // XXXbz sXBL/XBL2 issue!
    1: 
    1:   // Set document
    1:   if (aDocument) {
    1:     // XXX See the comment in nsGenericElement::BindToTree
67605:     SetInDocument();
    1:     if (mText.IsBidi()) {
15376:       aDocument->SetBidiEnabled();
    1:     }
40938:     // Clear the lazy frame construction bits.
40938:     UnsetFlags(NODE_NEEDS_FRAME | NODE_DESCENDANTS_NEED_FRAMES);
    1:   }
    1: 
    1:   nsNodeUtils::ParentChainChanged(this);
    1: 
80486:   UpdateEditableState(false);
 2896: 
    1:   NS_POSTCONDITION(aDocument == GetCurrentDoc(), "Bound to wrong document");
    1:   NS_POSTCONDITION(aParent == GetParent(), "Bound to wrong parent");
    1:   NS_POSTCONDITION(aBindingParent == GetBindingParent(),
    1:                    "Bound to wrong binding parent");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
79445: nsGenericDOMDataNode::UnbindFromTree(bool aDeep, bool aNullParent)
    1: {
29809:   // Unset frame flags; if we need them again later, they'll get set again.
29809:   UnsetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE |
29809:              NS_REFRAME_IF_WHITESPACE);
27311:   
    1:   nsIDocument *document = GetCurrentDoc();
    1:   if (document) {
    1:     // Notify XBL- & nsIAnonymousContentCreator-generated
    1:     // anonymous content that the document is changing.
    1:     // This is needed to update the insertion point.
43087:     document->BindingManager()->RemovedFromDocument(this, document);
    1:   }
    1: 
67605:   if (aNullParent) {
74344:     if (GetParent()) {
74344:       NS_RELEASE(mParent);
74344:     } else {
67605:       mParent = nsnull;
74344:     }
67605:     SetParentIsContent(false);
67605:   }
67605:   ClearInDocument();
    1: 
    1:   nsDataSlots *slots = GetExistingDataSlots();
    1:   if (slots) {
    1:     slots->mBindingParent = nsnull;
    1:   }
    1: 
    1:   nsNodeUtils::ParentChainChanged(this);
    1: }
    1: 
38069: already_AddRefed<nsINodeList>
55877: nsGenericDOMDataNode::GetChildren(PRUint32 aFilter)
38069: {
38069:   return nsnull;
38069: }
38069: 
    1: nsIAtom *
 4036: nsGenericDOMDataNode::GetIDAttributeName() const
    1: {
    1:   return nsnull;
    1: }
    1: 
94340: already_AddRefed<nsINodeInfo>
    1: nsGenericDOMDataNode::GetExistingAttrNameFromQName(const nsAString& aStr) const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttr,
    1:                               nsIAtom* aPrefix, const nsAString& aValue,
79445:                               bool aNotify)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttr,
79445:                                 bool aNotify)
    1: {
    1:   return NS_OK;
    1: }
    1: 
79445: bool
    1: nsGenericDOMDataNode::GetAttr(PRInt32 aNameSpaceID, nsIAtom *aAttr,
    1:                               nsAString& aResult) const
    1: {
    1:   aResult.Truncate();
    1: 
80486:   return false;
    1: }
    1: 
79445: bool
    1: nsGenericDOMDataNode::HasAttr(PRInt32 aNameSpaceID, nsIAtom *aAttribute) const
    1: {
80486:   return false;
    1: }
    1: 
    1: const nsAttrName*
    1: nsGenericDOMDataNode::GetAttrNameAt(PRUint32 aIndex) const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: PRUint32
    1: nsGenericDOMDataNode::GetAttrCount() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: PRUint32
    1: nsGenericDOMDataNode::GetChildCount() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: nsIContent *
    1: nsGenericDOMDataNode::GetChildAt(PRUint32 aIndex) const
    1: {
    1:   return nsnull;
    1: }
    1: 
15810: nsIContent * const *
22251: nsGenericDOMDataNode::GetChildArray(PRUint32* aChildCount) const
15810: {
22251:   *aChildCount = 0;
15810:   return nsnull;
15810: }
15810: 
    1: PRInt32
    1: nsGenericDOMDataNode::IndexOf(nsINode* aPossibleChild) const
    1: {
    1:   return -1;
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
79445:                                     bool aNotify)
    1: {
    1:   return NS_OK;
    1: }
    1: 
94359: void
79445: nsGenericDOMDataNode::RemoveChildAt(PRUint32 aIndex, bool aNotify)
    1: {
    1: }
    1: 
    1: nsIContent *
    1: nsGenericDOMDataNode::GetBindingParent() const
    1: {
    1:   nsDataSlots *slots = GetExistingDataSlots();
    1:   return slots ? slots->mBindingParent : nsnull;
    1: }
    1: 
79445: bool
    1: nsGenericDOMDataNode::IsNodeOfType(PRUint32 aFlags) const
    1: {
    1:   return !(aFlags & ~(eCONTENT | eDATA_NODE));
    1: }
    1: 
 8462: void
14188: nsGenericDOMDataNode::SaveSubtreeState()
14188: {
14188: }
14188: 
14188: void
 8462: nsGenericDOMDataNode::DestroyContent()
 8462: {
21618:   // XXX We really should let cycle collection do this, but that currently still
21618:   //     leaks (see https://bugzilla.mozilla.org/show_bug.cgi?id=406684).
30001:   nsContentUtils::ReleaseWrapper(this, this);
 8462: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsGenericDOMDataNode::List(FILE* out, PRInt32 aIndent) const
    1: {
    1: }
    1: 
    1: void
    1: nsGenericDOMDataNode::DumpContent(FILE* out, PRInt32 aIndent,
79445:                                   bool aDumpAll) const 
    1: {
    1: }
    1: #endif
    1: 
79445: bool
    1: nsGenericDOMDataNode::IsLink(nsIURI** aURI) const
    1: {
    1:   *aURI = nsnull;
80486:   return false;
    1: }
    1: 
    1: nsINode::nsSlots*
    1: nsGenericDOMDataNode::CreateSlots()
    1: {
67604:   return new nsDataSlots();
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Implementation of the nsIDOMText interface
    1: 
    1: nsresult
16205: nsGenericDOMDataNode::SplitData(PRUint32 aOffset, nsIContent** aReturn,
79445:                                 bool aCloneAfterOriginal)
    1: {
16205:   *aReturn = nsnull;
    1:   nsresult rv = NS_OK;
    1:   nsAutoString cutText;
    1:   PRUint32 length = TextLength();
    1: 
    1:   if (aOffset > length) {
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1:   }
    1: 
16205:   PRUint32 cutStartOffset = aCloneAfterOriginal ? aOffset : 0;
16205:   PRUint32 cutLength = aCloneAfterOriginal ? length - aOffset : aOffset;
16205:   rv = SubstringData(cutStartOffset, cutLength, cutText);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
90032:   nsIDocument* document = GetCurrentDoc();
90032:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, true);
90032: 
76359:   // Use Clone for creating the new node so that the new node is of same class
76359:   // as this node!
80486:   nsCOMPtr<nsIContent> newContent = CloneDataNode(mNodeInfo, false);
76359:   if (!newContent) {
76359:     return NS_ERROR_OUT_OF_MEMORY;
76359:   }
80486:   newContent->SetText(cutText, true); // XXX should be false?
76359: 
76359:   CharacterDataChangeInfo::Details details = {
76359:     CharacterDataChangeInfo::Details::eSplit, newContent
76359:   };
80486:   rv = SetTextInternal(cutStartOffset, cutLength, nsnull, 0, true,
78096:                        aCloneAfterOriginal ? &details : nsnull);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
16205:   nsCOMPtr<nsINode> parent = GetNodeParent();
    1:   if (parent) {
16205:     PRInt32 insertionIndex = parent->IndexOf(this);
16205:     if (aCloneAfterOriginal) {
16205:       ++insertionIndex;
16205:     }
80486:     parent->InsertChildAt(newContent, insertionIndex, true);
    1:   }
    1: 
16205:   newContent.swap(*aReturn);
16205:   return rv;
16205: }
    1: 
16205: nsresult
16205: nsGenericDOMDataNode::SplitText(PRUint32 aOffset, nsIDOMText** aReturn)
16205: {
16205:   nsCOMPtr<nsIContent> newChild;
16205:   nsresult rv = SplitData(aOffset, getter_AddRefs(newChild));
16205:   if (NS_SUCCEEDED(rv)) {
16205:     rv = CallQueryInterface(newChild, aReturn);
16205:   }
16205:   return rv;
    1: }
    1: 
15899: /* static */ PRInt32
15250: nsGenericDOMDataNode::FirstLogicallyAdjacentTextNode(nsIContent* aParent,
15899:                                                      PRInt32 aIndex)
15250: {
15250:   while (aIndex-- > 0) {
15250:     nsIContent* sibling = aParent->GetChildAt(aIndex);
15250:     if (!sibling->IsNodeOfType(nsINode::eTEXT))
15250:       return aIndex + 1;
15250:   }
15250:   return 0;
15250: }
15250: 
15899: /* static */ PRInt32
15250: nsGenericDOMDataNode::LastLogicallyAdjacentTextNode(nsIContent* aParent,
15899:                                                     PRInt32 aIndex,
15250:                                                     PRUint32 aCount)
15250: {
15899:   while (++aIndex < PRInt32(aCount)) {
15250:     nsIContent* sibling = aParent->GetChildAt(aIndex);
15250:     if (!sibling->IsNodeOfType(nsINode::eTEXT))
15250:       return aIndex - 1;
15250:   }
15250:   return aCount - 1;
15250: }
15250: 
15250: nsresult
70839: nsGenericDOMDataNode::GetWholeText(nsAString& aWholeText)
15250: {
15250:   nsIContent* parent = GetParent();
15250: 
15250:   // Handle parent-less nodes
15250:   if (!parent)
15250:     return GetData(aWholeText);
15250: 
15899:   PRInt32 index = parent->IndexOf(this);
15899:   NS_WARN_IF_FALSE(index >= 0,
15899:                    "Trying to use .wholeText with an anonymous"
15899:                     "text node child of a binding parent?");
15899:   NS_ENSURE_TRUE(index >= 0, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
15899:   PRInt32 first =
15250:     FirstLogicallyAdjacentTextNode(parent, index);
15899:   PRInt32 last =
15250:     LastLogicallyAdjacentTextNode(parent, index, parent->GetChildCount());
15250: 
15250:   aWholeText.Truncate();
15250: 
15250:   nsCOMPtr<nsIDOMText> node;
15250:   nsAutoString tmp;
15250:   do {
15250:     node = do_QueryInterface(parent->GetChildAt(first));
15250:     node->GetData(tmp);
15250:     aWholeText.Append(tmp);
15250:   } while (first++ < last);
15250: 
15250:   return NS_OK;
15250: }
15250: 
15250: //----------------------------------------------------------------------
15250: 
    1: // Implementation of the nsIContent interface text functions
    1: 
    1: const nsTextFragment *
    1: nsGenericDOMDataNode::GetText()
    1: {
    1:   return &mText;
    1: }
    1: 
    1: PRUint32
94357: nsGenericDOMDataNode::TextLength() const
    1: {
    1:   return mText.GetLength();
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::SetText(const PRUnichar* aBuffer,
    1:                               PRUint32 aLength,
79445:                               bool aNotify)
    1: {
    1:   return SetTextInternal(0, mText.GetLength(), aBuffer, aLength, aNotify);
    1: }
    1: 
    1: nsresult
    1: nsGenericDOMDataNode::AppendText(const PRUnichar* aBuffer,
    1:                                  PRUint32 aLength,
79445:                                  bool aNotify)
    1: {
    1:   return SetTextInternal(mText.GetLength(), 0, aBuffer, aLength, aNotify);
    1: }
    1: 
79445: bool
82209: nsGenericDOMDataNode::TextIsOnlyWhitespace()
    1: {
    1:   if (mText.Is2b()) {
    1:     // The fragment contains non-8bit characters and such characters
    1:     // are never considered whitespace.
80486:     return false;
    1:   }
    1: 
    1:   const char* cp = mText.Get1b();
    1:   const char* end = cp + mText.GetLength();
    1: 
    1:   while (cp < end) {
    1:     char ch = *cp;
    1: 
    1:     if (!XP_IS_SPACE(ch)) {
80486:       return false;
    1:     }
    1: 
    1:     ++cp;
    1:   }
    1: 
80486:   return true;
    1: }
    1: 
    1: void
    1: nsGenericDOMDataNode::AppendTextTo(nsAString& aResult)
    1: {
    1:   mText.AppendTo(aResult);
    1: }
    1: 
    1: already_AddRefed<nsIAtom>
    1: nsGenericDOMDataNode::GetCurrentValueAtom()
    1: {
    1:   nsAutoString val;
    1:   GetData(val);
    1:   return NS_NewAtom(val);
    1: }
    1: 
    1: nsIAtom*
43079: nsGenericDOMDataNode::DoGetID() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: const nsAttrValue*
19132: nsGenericDOMDataNode::DoGetClasses() const
    1: {
19132:   NS_NOTREACHED("Shouldn't ever be called");
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericDOMDataNode::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
    1: {
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP_(bool)
    1: nsGenericDOMDataNode::IsAttributeMapped(const nsIAtom* aAttribute) const
    1: {
80486:   return false;
    1: }
    1: 
    1: nsChangeHint
    1: nsGenericDOMDataNode::GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                              PRInt32 aModType) const
    1: {
    1:   NS_NOTREACHED("Shouldn't be calling this!");
    1:   return nsChangeHint(0);
    1: }
    1: 
    1: nsIAtom*
    1: nsGenericDOMDataNode::GetClassAttributeName() const
    1: {
    1:   return nsnull;
    1: }
74270: 
93035: size_t
93035: nsGenericDOMDataNode::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const
74270: {
93035:   size_t n = nsIContent::SizeOfExcludingThis(aMallocSizeOf);
93035:   n += mText.SizeOfExcludingThis(aMallocSizeOf);
93035:   return n;
74270: }
74270: 
