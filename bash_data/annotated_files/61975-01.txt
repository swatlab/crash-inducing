35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
36124:  *   Jim Mathies <jmathies@mozilla.com>
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #include "PluginInstanceChild.h"
35925: #include "PluginModuleChild.h"
35895: #include "BrowserStreamChild.h"
35938: #include "PluginStreamChild.h"
35904: #include "StreamNotifyChild.h"
42302: #include "PluginProcessChild.h"
53942: #include "gfxASurface.h"
53942: #include "gfxContext.h"
53942: #ifdef MOZ_X11
53942: #include "gfxXlibSurface.h"
53942: #endif
57209: #ifdef XP_WIN
57209: #include "mozilla/gfx/SharedDIBSurface.h"
57209: 
57209: using mozilla::gfx::SharedDIBSurface;
57209: #endif
53942: #include "gfxSharedImageSurface.h"
53942: #include "gfxUtils.h"
53942: #include "gfxAlphaRecovery.h"
35746: 
36056: #include "mozilla/ipc/SyncChannel.h"
36056: 
42302: using mozilla::ipc::ProcessChild;
35925: using namespace mozilla::plugins;
35925: 
35957: #ifdef MOZ_WIDGET_GTK2
35747: 
35740: #include <gtk/gtk.h>
35740: #include <gdk/gdkx.h>
35740: #include <gdk/gdk.h>
35740: #include "gtk2xtbin.h"
35747: 
38045: #elif defined(MOZ_WIDGET_QT)
38045: #include <QX11Info>
35747: #elif defined(OS_WIN)
42423: #ifndef WM_MOUSEHWHEEL
42423: #define WM_MOUSEHWHEEL     0x020E
42423: #endif
38103: 
39729: #include "nsWindowsDllInterceptor.h"
39729: 
39729: typedef BOOL (WINAPI *User32TrackPopupMenu)(HMENU hMenu,
39729:                                             UINT uFlags,
39729:                                             int x,
39729:                                             int y,
39729:                                             int nReserved,
39729:                                             HWND hWnd,
39729:                                             CONST RECT *prcRect);
39729: static WindowsDllInterceptor sUser32Intercept;
39729: static HWND sWinlessPopupSurrogateHWND = NULL;
39729: static User32TrackPopupMenu sUser32TrackPopupMenuStub = NULL;
39729: 
36130: using mozilla::gfx::SharedDIB;
35747: 
35747: #include <windows.h>
38660: #include <windowsx.h>
35747: 
41342: // Flash WM_USER message delay time for PostDelayedTask. Borrowed
41342: // from Chromium's web plugin delegate src. See 'flash msg throttling
41342: // helpers' section for details.
41342: const int kFlashWMUSERMessageThrottleDelayMs = 5;
41342: 
56343: static const TCHAR kPluginIgnoreSubclassProperty[] = TEXT("PluginIgnoreSubclassProperty");
56343: 
39883: #elif defined(XP_MACOSX)
39883: #include <ApplicationServices/ApplicationServices.h>
39883: #endif // defined(XP_MACOSX)
35740: 
53942: template<>
53942: struct RunnableMethodTraits<PluginInstanceChild>
53942: {
53942:     static void RetainCallee(PluginInstanceChild* obj) { }
53942:     static void ReleaseCallee(PluginInstanceChild* obj) { }
53942: };
53942: 
58734: PluginInstanceChild::PluginInstanceChild(const NPPluginFuncs* aPluginIface)
39283:     : mPluginIface(aPluginIface)
38660:     , mCachedWindowActor(nsnull)
38660:     , mCachedElementActor(nsnull)
35980: #if defined(OS_WIN)
35980:     , mPluginWindowHWND(0)
35980:     , mPluginWndProc(0)
35980:     , mPluginParentHWND(0)
38103:     , mCachedWinlessPluginHWND(0)
39729:     , mWinlessPopupSurrogateHWND(0)
41342:     , mWinlessThrottleOldWndProc(0)
41997:     , mWinlessHiddenMsgHWND(0)
61919:     , mMouseHook(NULL)
37311: #endif // OS_WIN
39979:     , mAsyncCallMutex("PluginInstanceChild::mAsyncCallMutex")
40120: #if defined(OS_MACOSX)
54520: #if defined(__i386__)
54520:     , mEventModel(NPEventModelCarbon)
54520: #endif
41029:     , mShColorSpace(nsnull)
41029:     , mShContext(nsnull)
41029:     , mDrawingModel(NPDrawingModelCoreGraphics)
48383:     , mCurrentEvent(nsnull)
40120: #endif
57202:     , mLayersRendering(false)
61408: #ifdef XP_WIN
61408:     , mCurrentSurfaceActor(NULL)
61408:     , mBackSurfaceActor(NULL)
61408: #endif
53942:     , mAccumulatedInvalidRect(0,0,0,0)
57202:     , mIsTransparent(false)
53942:     , mSurfaceType(gfxASurface::SurfaceTypeMax)
53942:     , mCurrentInvalidateTask(nsnull)
58646:     , mCurrentAsyncSetWindowTask(nsnull)
57202:     , mPendingPluginCall(false)
57202:     , mDoAlphaExtraction(false)
60641:     , mHasPainted(false)
53942:     , mSurfaceDifferenceRect(0,0,0,0)
54931: #if (MOZ_PLATFORM_MAEMO == 5) || (MOZ_PLATFORM_MAEMO == 6)
54551:     , mMaemoImageRendering(PR_FALSE)
54551: #endif
35980: {
35980:     memset(&mWindow, 0, sizeof(mWindow));
35980:     mData.ndata = (void*) this;
39978:     mData.pdata = nsnull;
35980: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35980:     mWindow.ws_info = &mWsInfo;
35980:     memset(&mWsInfo, 0, sizeof(mWsInfo));
43912:     mWsInfo.display = DefaultXDisplay();
37311: #endif // MOZ_X11 && XP_UNIX && !XP_MACOSX
36270: #if defined(OS_WIN)
36270:     memset(&mAlphaExtract, 0, sizeof(mAlphaExtract));
37311: #endif // OS_WIN
39729: #if defined(OS_WIN)
39729:     InitPopupMenuHook();
60621:     HookSystemParametersInfo();
39729: #endif // OS_WIN
53942: #ifdef MOZ_X11
59840:     // Maemo flash can render plugin with any provided rectangle and not require this quirk.
59840: #ifndef MOZ_PLATFORM_MAEMO
53942:     const char *description = NULL;
53942:     mPluginIface->getvalue(GetNPP(), NPPVpluginDescriptionString,
53942:                            &description);
53942:     if (description) {
53942:         NS_NAMED_LITERAL_CSTRING(flash10Head, "Shockwave Flash 10.");
58735:         if (StringBeginsWith(nsDependentCString(description), flash10Head)) {
58735:           PluginModuleChild::current()->AddQuirk(PluginModuleChild::QUIRK_FLASH_EXPOSE_COORD_TRANSLATION);
58735:         }
53942:     }
53942: #endif
59840: #endif
35980: }
35980: 
35893: PluginInstanceChild::~PluginInstanceChild()
35747: {
35747: #if defined(OS_WIN)
58972:     NS_ASSERTION(!mPluginWindowHWND, "Destroying PluginInstanceChild without NPP_Destroy?");
35747: #endif
40120: #if defined(OS_MACOSX)
40120:     if (mShColorSpace) {
40120:         ::CGColorSpaceRelease(mShColorSpace);
40120:     }
40120:     if (mShContext) {
40120:         ::CGContextRelease(mShContext);
40120:     }
40120: #endif
35747: }
35747: 
58734: int
58734: PluginInstanceChild::GetQuirks()
38660: {
58734:     return PluginModuleChild::current()->GetQuirks();
38660: }
38660: 
35740: NPError
38354: PluginInstanceChild::InternalGetNPObjectForValue(NPNVariable aValue,
38354:                                                  NPObject** aObject)
38354: {
38354:     PluginScriptableObjectChild* actor;
38354:     NPError result = NPERR_NO_ERROR;
38354: 
38354:     switch (aValue) {
38354:         case NPNVWindowNPObject:
38354:             if (!(actor = mCachedWindowActor)) {
38354:                 PPluginScriptableObjectChild* actorProtocol;
38354:                 CallNPN_GetValue_NPNVWindowNPObject(&actorProtocol, &result);
38354:                 if (result == NPERR_NO_ERROR) {
38354:                     actor = mCachedWindowActor =
38354:                         static_cast<PluginScriptableObjectChild*>(actorProtocol);
38354:                     NS_ASSERTION(actor, "Null actor!");
38354:                     PluginModuleChild::sBrowserFuncs.retainobject(
38354:                         actor->GetObject(false));
38354:                 }
38354:             }
38354:             break;
38354: 
38354:         case NPNVPluginElementNPObject:
38354:             if (!(actor = mCachedElementActor)) {
38354:                 PPluginScriptableObjectChild* actorProtocol;
38354:                 CallNPN_GetValue_NPNVPluginElementNPObject(&actorProtocol,
38354:                                                            &result);
38354:                 if (result == NPERR_NO_ERROR) {
38354:                     actor = mCachedElementActor =
38354:                         static_cast<PluginScriptableObjectChild*>(actorProtocol);
38354:                     NS_ASSERTION(actor, "Null actor!");
38354:                     PluginModuleChild::sBrowserFuncs.retainobject(
38354:                         actor->GetObject(false));
38354:                 }
38354:             }
38354:             break;
38354: 
38354:         default:
38354:             NS_NOTREACHED("Don't know what to do with this value type!");
38354:     }
38354: 
38354: #ifdef DEBUG
38354:     {
38354:         NPError currentResult;
38354:         PPluginScriptableObjectChild* currentActor;
38354: 
38354:         switch (aValue) {
38354:             case NPNVWindowNPObject:
38354:                 CallNPN_GetValue_NPNVWindowNPObject(&currentActor,
38354:                                                     &currentResult);
38354:                 break;
38354:             case NPNVPluginElementNPObject:
38354:                 CallNPN_GetValue_NPNVPluginElementNPObject(&currentActor,
38354:                                                            &currentResult);
38354:                 break;
38354:             default:
38354:                 NS_NOTREACHED("Don't know what to do with this value type!");
38354:         }
38354: 
38354:         // Make sure that the current actor returned by the parent matches our
38354:         // cached actor!
38354:         NS_ASSERTION(static_cast<PluginScriptableObjectChild*>(currentActor) ==
38354:                      actor, "Cached actor is out of date!");
38354:         NS_ASSERTION(currentResult == result, "Results don't match?!");
38354:     }
38354: #endif
38354: 
38354:     if (result != NPERR_NO_ERROR) {
38354:         return result;
38354:     }
38354: 
38354:     NPObject* object = actor->GetObject(false);
38354:     NS_ASSERTION(object, "Null object?!");
38354: 
38354:     *aObject = PluginModuleChild::sBrowserFuncs.retainobject(object);
38354:     return NPERR_NO_ERROR;
38354: 
38354: }
38354: 
38354: NPError
35893: PluginInstanceChild::NPN_GetValue(NPNVariable aVar,
35893:                                   void* aValue)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aVar=%i)", FULLFUNCTION, (int) aVar));
35971:     AssertPluginThread();
35740: 
35746:     switch(aVar) {
35740: 
35746:     case NPNVSupportsWindowless:
36011: #if defined(OS_LINUX) || defined(OS_WIN)
35951:         *((NPBool*)aValue) = true;
35951: #else
35747:         *((NPBool*)aValue) = false;
35951: #endif
35746:         return NPERR_NO_ERROR;
35746: 
54931: #if (MOZ_PLATFORM_MAEMO == 5) || (MOZ_PLATFORM_MAEMO == 6)
54551:     case NPNVSupportsWindowlessLocal: {
54551: #ifdef MOZ_WIDGET_QT
54551:         const char *graphicsSystem = PR_GetEnv("MOZ_QT_GRAPHICSSYSTEM");
54551:         // we should set local rendering to false in order to render X-Plugin
54551:         // there is no possibility to change it later on maemo5 platform
54551:         mMaemoImageRendering = (!(graphicsSystem && !strcmp(graphicsSystem, "native")));
54551: #endif
54551:         *((NPBool*)aValue) = mMaemoImageRendering;
54551:         return NPERR_NO_ERROR;
54551:     }
54551: #endif
35746: #if defined(OS_LINUX)
35740:     case NPNVSupportsXEmbedBool:
35747:         *((NPBool*)aValue) = true;
35740:         return NPERR_NO_ERROR;
35740: 
35740:     case NPNVToolkit:
35740:         *((NPNToolkitType*)aValue) = NPNVGtk2;
35740:         return NPERR_NO_ERROR;
35740: 
35746: #elif defined(OS_WIN)
35746:     case NPNVToolkit:
35746:         return NPERR_GENERIC_ERROR;
35746: #endif
35923:     case NPNVjavascriptEnabledBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVjavascriptEnabledBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
35923:     case NPNVisOfflineBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVisOfflineBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
35923:     case NPNVprivateModeBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVprivateModeBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
38354:     case NPNVWindowNPObject: // Intentional fall-through
38354:     case NPNVPluginElementNPObject: {
38354:         NPObject* object;
38354:         NPError result = InternalGetNPObjectForValue(aVar, &object);
38354:         if (result == NPERR_NO_ERROR) {
38354:             *((NPObject**)aValue) = object;
35965:         }
35965:         return result;
35965:     }
35965: 
37168:     case NPNVnetscapeWindow: {
37168: #ifdef XP_WIN
37168:         if (mWindow.type == NPWindowTypeDrawable) {
38103:             if (mCachedWinlessPluginHWND) {
38103:               *static_cast<HWND*>(aValue) = mCachedWinlessPluginHWND;
38103:               return NPERR_NO_ERROR;
38103:             }
37168:             NPError result;
38103:             if (!CallNPN_GetValue_NPNVnetscapeWindow(&mCachedWinlessPluginHWND, &result)) {
37168:                 return NPERR_GENERIC_ERROR;
37168:             }
38103:             *static_cast<HWND*>(aValue) = mCachedWinlessPluginHWND;
37168:             return result;
37168:         }
37168:         else {
37168:             *static_cast<HWND*>(aValue) = mPluginWindowHWND;
37168:             return NPERR_NO_ERROR;
37168:         }
37308: #elif defined(MOZ_X11)
37308:         NPError result;
37308:         CallNPN_GetValue_NPNVnetscapeWindow(static_cast<XID*>(aValue), &result);
37308:         return result;
37168: #else
37168:         return NPERR_GENERIC_ERROR;
37168: #endif
37168:     }
37168: 
39883: #ifdef XP_MACOSX
39883:    case NPNVsupportsCoreGraphicsBool: {
39883:         *((NPBool*)aValue) = true;
39883:         return NPERR_NO_ERROR;
39883:     }
39883: 
39883:     case NPNVsupportsCoreAnimationBool: {
41029:         *((NPBool*)aValue) = true;
39883:         return NPERR_NO_ERROR;
39883:     }
39883: 
43370:     case NPNVsupportsInvalidatingCoreAnimationBool: {
43370:         *((NPBool*)aValue) = true;
43370:         return NPERR_NO_ERROR;
43370:     }
43370: 
39883:     case NPNVsupportsCocoaBool: {
39883:         *((NPBool*)aValue) = true;
39883:         return NPERR_NO_ERROR;
39883:     }
39883: 
61803: #ifndef NP_NO_CARBON
61803:     case NPNVsupportsCarbonBool: {
61803:       *((NPBool*)aValue) = false;
61803:       return NPERR_NO_ERROR;
61803:     }
61803: #endif
61803: 
61078:     case NPNVsupportsUpdatedCocoaTextInputBool: {
61078:       *static_cast<NPBool*>(aValue) = true;
61078:       return NPERR_NO_ERROR;
61078:     }
61078: 
39883: #ifndef NP_NO_QUICKDRAW
39883:     case NPNVsupportsQuickDrawBool: {
39883:         *((NPBool*)aValue) = false;
39883:         return NPERR_NO_ERROR;
39883:     }
39883: #endif /* NP_NO_QUICKDRAW */
39883: #endif /* XP_MACOSX */
39883: 
35740:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceChild::NPN_GetValue: Unhandled NPNVariable %i (%s)",
37099:                 (int) aVar, NPNVariableToString(aVar)));
35740:         return NPERR_GENERIC_ERROR;
35740:     }
35740: 
35740: }
35740: 
35951: 
35951: NPError
35951: PluginInstanceChild::NPN_SetValue(NPPVariable aVar, void* aValue)
35951: {
37099:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s (aVar=%i, aValue=%p)",
37099:                                       FULLFUNCTION, (int) aVar, aValue));
37099: 
35971:     AssertPluginThread();
35951: 
35951:     switch (aVar) {
35951:     case NPPVpluginWindowBool: {
35951:         NPError rv;
35951:         bool windowed = (NPBool) (intptr_t) aValue;
35951: 
35951:         if (!CallNPN_SetValue_NPPVpluginWindow(windowed, &rv))
35951:             return NPERR_GENERIC_ERROR;
35951: 
35951:         return rv;
35951:     }
35951: 
35951:     case NPPVpluginTransparentBool: {
35951:         NPError rv;
57216:         mIsTransparent = (!!aValue);
35951: 
53942:         if (!CallNPN_SetValue_NPPVpluginTransparent(mIsTransparent, &rv))
35951:             return NPERR_GENERIC_ERROR;
35951: 
35951:         return rv;
35951:     }
35951: 
39883: #ifdef XP_MACOSX
39883:     case NPPVpluginDrawingModel: {
39883:         NPError rv;
39883:         int drawingModel = (int16) (intptr_t) aValue;
39883: 
39883:         if (!CallNPN_SetValue_NPPVpluginDrawingModel(drawingModel, &rv))
39883:             return NPERR_GENERIC_ERROR;
41029:         mDrawingModel = drawingModel;
39883: 
39883:         return rv;
39883:     }
39883: 
39883:     case NPPVpluginEventModel: {
39883:         NPError rv;
39883:         int eventModel = (int16) (intptr_t) aValue;
39883: 
39883:         if (!CallNPN_SetValue_NPPVpluginEventModel(eventModel, &rv))
39883:             return NPERR_GENERIC_ERROR;
54520: #if defined(__i386__)
54520:         mEventModel = static_cast<NPEventModel>(eventModel);
54520: #endif
39883: 
39883:         return rv;
39883:     }
39883: #endif
39883: 
35951:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceChild::NPN_SetValue: Unhandled NPPVariable %i (%s)",
37099:                 (int) aVar, NPPVariableToString(aVar)));
35951:         return NPERR_GENERIC_ERROR;
35951:     }
35951: }
35951: 
35951: bool
35951: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginNeedsXEmbed(
35951:     bool* needs, NPError* rv)
35951: {
35971:     AssertPluginThread();
35971: 
38126: #ifdef MOZ_X11
38126:     // The documentation on the types for many variables in NP(N|P)_GetValue
38126:     // is vague.  Often boolean values are NPBool (1 byte), but
38126:     // https://developer.mozilla.org/en/XEmbed_Extension_for_Mozilla_Plugins
38126:     // treats NPPVpluginNeedsXEmbed as PRBool (int), and
36324:     // on x86/32-bit, flash stores to this using |movl 0x1,&needsXEmbed|.
38126:     // thus we can't use NPBool for needsXEmbed, or the three bytes above
38126:     // it on the stack would get clobbered. so protect with the larger PRBool.
38126:     PRBool needsXEmbed = 0;
38126:     if (!mPluginIface->getvalue) {
38126:         *rv = NPERR_GENERIC_ERROR;
38126:     }
38126:     else {
35951:         *rv = mPluginIface->getvalue(GetNPP(), NPPVpluginNeedsXEmbed,
38126:                                      &needsXEmbed);
38126:     }
35951:     *needs = needsXEmbed;
35951:     return true;
35951: 
35951: #else
35951: 
38126:     NS_RUNTIMEABORT("shouldn't be called on non-X11 platforms");
35952:     return false;               // not reached
35951: 
35951: #endif
35951: }
35951: 
35926: bool
35925: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginScriptableNPObject(
36078:                                           PPluginScriptableObjectChild** aValue,
36078:                                           NPError* aResult)
35746: {
35971:     AssertPluginThread();
35925: 
39411:     NPObject* object = nsnull;
38126:     NPError result = NPERR_GENERIC_ERROR;
38126:     if (mPluginIface->getvalue) {
38126:         result = mPluginIface->getvalue(GetNPP(), NPPVpluginScriptableNPObject,
35925:                                         &object);
38126:     }
36078:     if (result == NPERR_NO_ERROR && object) {
36078:         PluginScriptableObjectChild* actor = GetActorForNPObject(object);
36078: 
36078:         // If we get an actor then it has retained. Otherwise we don't need it
36078:         // any longer.
36078:         PluginModuleChild::sBrowserFuncs.releaseobject(object);
36078:         if (actor) {
36078:             *aValue = actor;
36078:             *aResult = NPERR_NO_ERROR;
35926:             return true;
35925:         }
35925: 
36078:         NS_ERROR("Failed to get actor!");
36078:         result = NPERR_GENERIC_ERROR;
35925:     }
39411:     else {
39411:         result = NPERR_GENERIC_ERROR;
39411:     }
35925: 
36078:     *aValue = nsnull;
36078:     *aResult = result;
35926:     return true;
35746: }
35746: 
35926: bool
37350: PluginInstanceChild::AnswerNPP_SetValue_NPNVprivateModeBool(const bool& value,
37350:                                                             NPError* result)
37350: {
37885:     if (!mPluginIface->setvalue) {
37885:         *result = NPERR_GENERIC_ERROR;
37885:         return true;
37885:     }
37885: 
39529:     NPBool v = value;
37350:     *result = mPluginIface->setvalue(GetNPP(), NPNVprivateModeBool, &v);
37350:     return true;
37350: }
37350: 
37350: bool
36011: PluginInstanceChild::AnswerNPP_HandleEvent(const NPRemoteEvent& event,
35933:                                            int16_t* handled)
35933: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35951: 
47100: #if defined(MOZ_X11) && defined(DEBUG)
36014:     if (GraphicsExpose == event.event.type)
38112:         PLUGIN_LOG_DEBUG(("  received drawable 0x%lx\n",
38112:                           event.event.xgraphicsexpose.drawable));
35951: #endif
35951: 
39883: #ifdef XP_MACOSX
39534:     // Mac OS X does not define an NPEvent structure. It defines more specific types.
39534:     NPCocoaEvent evcopy = event.event;
48383: 
48383:     // Make sure we reset mCurrentEvent in case of an exception
48383:     AutoRestore<const NPCocoaEvent*> savePreviousEvent(mCurrentEvent);
48383: 
48383:     // Track the current event for NPN_PopUpContextMenu.
48383:     mCurrentEvent = &event.event;
39534: #else
36124:     // Make a copy since we may modify values.
36011:     NPEvent evcopy = event.event;
39534: #endif
36124: 
36124: #ifdef OS_WIN
42810:     // FIXME/bug 567645: temporarily drop the "dummy event" on the floor
42810:     if (WM_NULL == evcopy.event)
42810:         return true;
42810: 
36270:     // Painting for win32. SharedSurfacePaint handles everything.
36270:     if (mWindow.type == NPWindowTypeDrawable) {
36270:        if (evcopy.event == WM_PAINT) {
36270:           *handled = SharedSurfacePaint(evcopy);
36270:           return true;
36270:        }
50668:        else if (DoublePassRenderingEvent() == evcopy.event) {
36270:             // We'll render to mSharedSurfaceDib first, then render to a cached bitmap
36270:             // we store locally. The two passes are for alpha extraction, so the second
36270:             // pass must be to a flat white surface in order for things to work.
36270:             mAlphaExtract.doublePass = RENDER_BACK_ONE;
36270:             *handled = true;
36270:             return true;
36270:        }
36270:     }
38103:     *handled = WinlessHandleEvent(evcopy);
38103:     return true;
36124: #endif
36124: 
60114:     // XXX A previous call to mPluginIface->event might block, e.g. right click
60114:     // for context menu. Still, we might get here again, calling into the plugin
60114:     // a second time while it's in the previous call.
39279:     if (!mPluginIface->event)
39279:         *handled = false;
39279:     else
35933:         *handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
35980: 
39994: #ifdef XP_MACOSX
39994:     // Release any reference counted objects created in the child process.
39994:     if (evcopy.type == NPCocoaEventKeyDown ||
39994:         evcopy.type == NPCocoaEventKeyUp) {
39994:       ::CFRelease((CFStringRef)evcopy.data.key.characters);
39994:       ::CFRelease((CFStringRef)evcopy.data.key.charactersIgnoringModifiers);
39994:     }
39994:     else if (evcopy.type == NPCocoaEventTextInput) {
39994:       ::CFRelease((CFStringRef)evcopy.data.text.text);
39994:     }
39994: #endif
39994: 
35980: #ifdef MOZ_X11
36013:     if (GraphicsExpose == event.event.type) {
35980:         // Make sure the X server completes the drawing before the parent
35980:         // draws on top and destroys the Drawable.
35980:         //
35980:         // XSync() waits for the X server to complete.  Really this child
35980:         // process does not need to wait; the parent is the process that needs
35980:         // to wait.  A possibly-slightly-better alternative would be to send
35980:         // an X event to the parent that the parent would wait for.
35980:         XSync(mWsInfo.display, False);
35980:     }
35980: #endif
35980: 
35933:     return true;
35933: }
35933: 
39883: #ifdef XP_MACOSX
41029: 
39883: bool
39883: PluginInstanceChild::AnswerNPP_HandleEvent_Shmem(const NPRemoteEvent& event,
39883:                                                  Shmem& mem,
39883:                                                  int16_t* handled,
39883:                                                  Shmem* rtnmem)
39883: {
39883:     PLUGIN_LOG_DEBUG_FUNCTION;
39883:     AssertPluginThread();
39883: 
44183:     PaintTracker pt;
44183: 
39883:     NPCocoaEvent evcopy = event.event;
39883: 
39883:     if (evcopy.type == NPCocoaEventDrawRect) {
40120:         if (!mShColorSpace) {
40120:             mShColorSpace = CreateSystemColorSpace();
40120:             if (!mShColorSpace) {
39883:                 PLUGIN_LOG_DEBUG(("Could not allocate ColorSpace."));
39883:                 *handled = false;
39883:                 *rtnmem = mem;
39883:                 return true;
39883:             } 
40120:         }
40120:         if (!mShContext) {
39883:             void* cgContextByte = mem.get<char>();
40120:             mShContext = ::CGBitmapContextCreate(cgContextByte, 
40120:                               mWindow.width, mWindow.height, 8, 
40120:                               mWindow.width * 4, mShColorSpace, 
40120:                               kCGImageAlphaPremultipliedFirst |
40120:                               kCGBitmapByteOrder32Host);
40120:     
40120:             if (!mShContext) {
39883:                 PLUGIN_LOG_DEBUG(("Could not allocate CGBitmapContext."));
39883:                 *handled = false;
39883:                 *rtnmem = mem;
39883:                 return true;
39883:             }
40120:         }
40494:         CGRect clearRect = ::CGRectMake(0, 0, mWindow.width, mWindow.height);
40494:         ::CGContextClearRect(mShContext, clearRect);
40120:         evcopy.data.draw.context = mShContext; 
39883:     } else {
39883:         PLUGIN_LOG_DEBUG(("Invalid event type for AnswerNNP_HandleEvent_Shmem."));
39883:         *handled = false;
39883:         *rtnmem = mem;
39883:         return true;
39883:     } 
39883: 
39883:     if (!mPluginIface->event) {
39883:         *handled = false;
39883:     } else {
42508:         ::CGContextSaveGState(evcopy.data.draw.context);
39883:         *handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
42508:         ::CGContextRestoreGState(evcopy.data.draw.context);
39883:     }
39883: 
39883:     *rtnmem = mem;
39883:     return true;
39883: }
39883: 
39883: #else
39883: bool
39883: PluginInstanceChild::AnswerNPP_HandleEvent_Shmem(const NPRemoteEvent& event,
39883:                                                  Shmem& mem,
39883:                                                  int16_t* handled,
39883:                                                  Shmem* rtnmem)
39883: {
39883:     NS_RUNTIMEABORT("not reached.");
39883:     *rtnmem = mem;
39883:     return true;
39883: }
39883: #endif
39883: 
41029: #ifdef XP_MACOSX
41029: bool
41029: PluginInstanceChild::AnswerNPP_HandleEvent_IOSurface(const NPRemoteEvent& event,
41029:                                                      const uint32_t &surfaceid,
41029:                                                      int16_t* handled)
41029: {
41029:     PLUGIN_LOG_DEBUG_FUNCTION;
41029:     AssertPluginThread();
41029: 
44183:     PaintTracker pt;
44183: 
41029:     NPCocoaEvent evcopy = event.event;
41029:     nsIOSurface* surf = nsIOSurface::LookupSurface(surfaceid);
41029:     if (!surf) {
43756:         NS_ERROR("Invalid IOSurface.");
41029:         *handled = false;
41029:         return false;
41029:     }
41029: 
41029:     if (evcopy.type == NPCocoaEventDrawRect) {
41029:         mCARenderer.AttachIOSurface(surf);
41029:         if (!mCARenderer.isInit()) {
41029:             void *caLayer = nsnull;
41029:             NPError result = mPluginIface->getvalue(GetNPP(), 
41029:                                      NPPVpluginCoreAnimationLayer,
41029:                                      &caLayer);
41029:             if (result != NPERR_NO_ERROR || !caLayer) {
41029:                 PLUGIN_LOG_DEBUG(("Plugin requested CoreAnimation but did not "
41029:                                   "provide CALayer."));
41029:                 *handled = false;
41029:                 return false;
41029:             }
41029:             mCARenderer.SetupRenderer(caLayer, mWindow.width, mWindow.height);
41029:             // Flash needs to have the window set again after this step
41029:             if (mPluginIface->setwindow)
41029:                 (void) mPluginIface->setwindow(&mData, &mWindow);
41029:         }
41029:     } else {
41029:         PLUGIN_LOG_DEBUG(("Invalid event type for "
41029:                           "AnswerNNP_HandleEvent_IOSurface."));
41029:         *handled = false;
41029:         return false;
41029:     } 
41029: 
41029:     mCARenderer.Render(mWindow.width, mWindow.height, nsnull);
41029: 
41029:     return true;
41029: 
41029: }
41029: 
41029: #else
41029: bool
41029: PluginInstanceChild::AnswerNPP_HandleEvent_IOSurface(const NPRemoteEvent& event,
41029:                                                      const uint32_t &surfaceid,
41029:                                                      int16_t* handled)
41029: {
41029:     NS_RUNTIMEABORT("NPP_HandleEvent_IOSurface is a OSX-only message");
41029:     return false;
41029: }
41029: #endif
41029: 
39720: bool
39720: PluginInstanceChild::RecvWindowPosChanged(const NPRemoteEvent& event)
39720: {
58646:     NS_ASSERTION(!mLayersRendering && !mPendingPluginCall,
58646:                  "Shouldn't be receiving WindowPosChanged with layer rendering");
58646: 
39720: #ifdef OS_WIN
39720:     int16_t dontcare;
39720:     return AnswerNPP_HandleEvent(event, &dontcare);
39720: #else
39720:     NS_RUNTIMEABORT("WindowPosChanged is a windows-only message");
39720:     return false;
39720: #endif
39720: }
39720: 
39720: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957: static bool
35957: XVisualIDToInfo(Display* aDisplay, VisualID aVisualID,
35957:                 Visual** aVisual, unsigned int* aDepth)
35957: {
35957:     if (aVisualID == None) {
35957:         *aVisual = NULL;
35957:         *aDepth = 0;
35957:         return true;
35957:     }
35957: 
35957:     const Screen* screen = DefaultScreenOfDisplay(aDisplay);
35957: 
35957:     for (int d = 0; d < screen->ndepths; d++) {
35957:         Depth *d_info = &screen->depths[d];
35957:         for (int v = 0; v < d_info->nvisuals; v++) {
35957:             Visual* visual = &d_info->visuals[v];
35957:             if (visual->visualid == aVisualID) {
35957:                 *aVisual = visual;
35957:                 *aDepth = d_info->depth;
35957:                 return true;
35957:             }
35957:         }
35957:     }
35957: 
35957:     NS_ERROR("VisualID not on Screen.");
35957:     return false;
35957: }
35957: #endif
35957: 
35933: bool
39279: PluginInstanceChild::AnswerNPP_SetWindow(const NPRemoteWindow& aWindow)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aWindow=<window: 0x%lx, x: %d, y: %d, width: %d, height: %d>)",
37099:                       FULLFUNCTION,
35957:                       aWindow.window,
35954:                       aWindow.x, aWindow.y,
37099:                       aWindow.width, aWindow.height));
58646:     NS_ASSERTION(!mLayersRendering && !mPendingPluginCall,
58646:                  "Shouldn't be receiving NPP_SetWindow with layer rendering");
35971:     AssertPluginThread();
35740: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:     // The minimum info is sent over IPC to allow this
35957:     // code to determine the rest.
35740: 
35957:     mWindow.window = reinterpret_cast<void*>(aWindow.window);
35957:     mWindow.x = aWindow.x;
35957:     mWindow.y = aWindow.y;
35957:     mWindow.width = aWindow.width;
35957:     mWindow.height = aWindow.height;
35957:     mWindow.clipRect = aWindow.clipRect;
35957:     mWindow.type = aWindow.type;
35740: 
35957:     mWsInfo.colormap = aWindow.colormap;
35957:     if (!XVisualIDToInfo(mWsInfo.display, aWindow.visualID,
35957:                          &mWsInfo.visual, &mWsInfo.depth))
35957:         return false;
35740: 
37621: #ifdef MOZ_WIDGET_GTK2
47114:     if (gtk_check_version(2,18,7) != NULL) { // older
47114:         if (aWindow.type == NPWindowTypeWindow) {
41542:             GdkWindow* socket_window = gdk_window_lookup(aWindow.window);
41542:             if (socket_window) {
37347:                 // A GdkWindow for the socket already exists.  Need to
37347:                 // workaround https://bugzilla.gnome.org/show_bug.cgi?id=607061
37347:                 // See wrap_gtk_plug_embedded in PluginModuleChild.cpp.
37347:                 g_object_set_data(G_OBJECT(socket_window),
37347:                                   "moz-existed-before-set-window",
37347:                                   GUINT_TO_POINTER(1));
37347:             }
41542:         }
47114: 
47114:         if (aWindow.visualID != None
47114:             && gtk_check_version(2, 12, 10) != NULL) { // older
47114:             // Workaround for a bug in Gtk+ (prior to 2.12.10) where deleting
47114:             // a foreign GdkColormap will also free the XColormap.
47114:             // http://git.gnome.org/browse/gtk+/log/gdk/x11/gdkcolor-x11.c?id=GTK_2_12_10
47114:             GdkVisual *gdkvisual = gdkx_visual_get(aWindow.visualID);
47114:             GdkColormap *gdkcolor =
47114:                 gdk_x11_colormap_foreign_new(gdkvisual, aWindow.colormap);
47114: 
47114:             if (g_object_get_data(G_OBJECT(gdkcolor), "moz-have-extra-ref")) {
47114:                 // We already have a ref to keep the object alive.
47114:                 g_object_unref(gdkcolor);
47114:             } else {
47114:                 // leak and mark as already leaked
47114:                 g_object_set_data(G_OBJECT(gdkcolor),
47114:                                   "moz-have-extra-ref", GUINT_TO_POINTER(1));
47114:             }
47114:         }
47114:     }
37621: #endif
37347: 
39279:     if (mPluginIface->setwindow)
39279:         (void) mPluginIface->setwindow(&mData, &mWindow);
35747: 
35746: #elif defined(OS_WIN)
36124:     switch (aWindow.type) {
36124:       case NPWindowTypeWindow:
36124:       {
36124:           if (!CreatePluginWindow())
36124:               return false;
36124: 
35747:           ReparentPluginWindow((HWND)aWindow.window);
35747:           SizePluginWindow(aWindow.width, aWindow.height);
35747: 
35747:           mWindow.window = (void*)mPluginWindowHWND;
35954:           mWindow.x = aWindow.x;
35954:           mWindow.y = aWindow.y;
35746:           mWindow.width = aWindow.width;
35746:           mWindow.height = aWindow.height;
36011:           mWindow.type = aWindow.type;
35740: 
39279:           if (mPluginIface->setwindow) {
56343:               SetProp(mPluginWindowHWND, kPluginIgnoreSubclassProperty, (HANDLE)1);
39279:               (void) mPluginIface->setwindow(&mData, &mWindow);
35747:               WNDPROC wndProc = reinterpret_cast<WNDPROC>(
35747:                   GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
35747:               if (wndProc != PluginWindowProc) {
35747:                   mPluginWndProc = reinterpret_cast<WNDPROC>(
35747:                       SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
47318:                                        reinterpret_cast<LONG_PTR>(PluginWindowProc)));
35747:               }
56343:               RemoveProp(mPluginWindowHWND, kPluginIgnoreSubclassProperty);
56343:               HookSetWindowLongPtr();
35747:           }
36124:       }
36124:       break;
36124: 
36124:       case NPWindowTypeDrawable:
41342:           mWindow.type = aWindow.type;
58734:           if (GetQuirks() & PluginModuleChild::QUIRK_WINLESS_TRACKPOPUP_HOOK)
39729:               CreateWinlessPopupSurrogate();
58734:           if (GetQuirks() & PluginModuleChild::QUIRK_FLASH_THROTTLE_WMUSER_EVENTS)
41342:               SetupFlashMsgThrottle();
39279:           return SharedSurfaceSetWindow(aWindow);
36124:       break;
36124: 
36124:       default:
36124:           NS_NOTREACHED("Bad plugin window type.");
36124:           return false;
36124:       break;
36124:     }
35747: 
39883: #elif defined(XP_MACOSX)
39534: 
39534:     mWindow.x = aWindow.x;
39534:     mWindow.y = aWindow.y;
39534:     mWindow.width = aWindow.width;
39534:     mWindow.height = aWindow.height;
39534:     mWindow.clipRect = aWindow.clipRect;
39534:     mWindow.type = aWindow.type;
36069: 
40120:     if (mShContext) {
40120:         // Release the shared context so that it is reallocated
40120:         // with the new size. 
40120:         ::CGContextRelease(mShContext);
41029:         mShContext = nsnull;
40120:     }
40120: 
39883:     if (mPluginIface->setwindow)
39883:         (void) mPluginIface->setwindow(&mData, &mWindow);
39883: 
46922: #elif defined(ANDROID)
46922: #  warning Need Android impl
35740: #else
35740: #  error Implement me for your OS
35740: #endif
35746: 
35926:     return true;
35740: }
35740: 
35747: bool
35893: PluginInstanceChild::Initialize()
35747: {
35747:     return true;
35747: }
35747: 
35747: #if defined(OS_WIN)
35747: 
35747: static const TCHAR kWindowClassName[] = TEXT("GeckoPluginWindow");
35893: static const TCHAR kPluginInstanceChildProperty[] = TEXT("PluginInstanceChildProperty");
56343: static const TCHAR kFlashThrottleProperty[] = TEXT("MozillaFlashThrottleProperty");
35747: 
35747: // static
35747: bool
35893: PluginInstanceChild::RegisterWindowClass()
35747: {
35747:     static bool alreadyRegistered = false;
35747:     if (alreadyRegistered)
35747:         return true;
35747: 
35747:     alreadyRegistered = true;
35747: 
35747:     WNDCLASSEX wcex;
35747:     wcex.cbSize         = sizeof(WNDCLASSEX);
35747:     wcex.style          = CS_DBLCLKS;
35747:     wcex.lpfnWndProc    = DummyWindowProc;
35747:     wcex.cbClsExtra     = 0;
35747:     wcex.cbWndExtra     = 0;
35747:     wcex.hInstance      = GetModuleHandle(NULL);
35747:     wcex.hIcon          = 0;
35747:     wcex.hCursor        = 0;
35748:     wcex.hbrBackground  = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
35747:     wcex.lpszMenuName   = 0;
35747:     wcex.lpszClassName  = kWindowClassName;
35747:     wcex.hIconSm        = 0;
35747: 
35747:     return RegisterClassEx(&wcex) ? true : false;
35747: }
35747: 
61919: static inline void
61919: HandleMouseCapture(HWND aWnd, UINT aMessage)
61919: {
61919:     // Make sure capture is released by the child on mouse events. Fixes a
61919:     // problem with flash full screen mode mouse input. Appears to be
61919:     // caused by a bug in flash, since we are not setting the capture
61919:     // on the window. (In non-oopp land, we would set and release via
61919:     // widget for other reasons.)
61919:     switch (aMessage) {
61919:         case WM_LBUTTONDOWN:
61919:         case WM_MBUTTONDOWN:
61919:         case WM_RBUTTONDOWN:
61919:             SetCapture(aWnd);
61919:             break;
61919:         case WM_LBUTTONUP:
61919:         case WM_MBUTTONUP:
61919:         case WM_RBUTTONUP:
61919:             ReleaseCapture();
61919:             break;
61919:     }
61919: }
61919: 
61919: LRESULT CALLBACK MouseHookProc(int code,
61919:                                WPARAM wParam,
61919:                                LPARAM lParam)
61919: {
61919:   if (code == HC_ACTION) {
61919:       MOUSEHOOKSTRUCT* hookStruct =
61919:           reinterpret_cast<MOUSEHOOKSTRUCT*>(lParam);
61919:       if (hookStruct)
61919:           HandleMouseCapture(hookStruct->hwnd, wParam);
61919:   }
61919: 
61919:   return CallNextHookEx(NULL, code, wParam, lParam);
61919: }
61919: 
35747: bool
35893: PluginInstanceChild::CreatePluginWindow()
35747: {
36124:     // already initialized
36124:     if (mPluginWindowHWND)
36124:         return true;
36124:         
35747:     if (!RegisterWindowClass())
35747:         return false;
35747: 
35747:     mPluginWindowHWND =
35747:         CreateWindowEx(WS_EX_LEFT | WS_EX_LTRREADING |
35747:                        WS_EX_NOPARENTNOTIFY | // XXXbent Get rid of this!
35747:                        WS_EX_RIGHTSCROLLBAR,
35747:                        kWindowClassName, 0,
35747:                        WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0, 0,
35747:                        0, 0, NULL, 0, GetModuleHandle(NULL), 0);
35747:     if (!mPluginWindowHWND)
35747:         return false;
35893:     if (!SetProp(mPluginWindowHWND, kPluginInstanceChildProperty, this))
35747:         return false;
35747: 
35747:     // Apparently some plugins require an ASCII WndProc.
35747:     SetWindowLongPtrA(mPluginWindowHWND, GWLP_WNDPROC,
47318:                       reinterpret_cast<LONG_PTR>(DefWindowProcA));
35747: 
61919:     // Mouse capture hook for flash full screen capture bug
61919:     if (GetQuirks() & PluginModuleChild::QUIRK_FLASH_HOOK_MOUSE_CAPTURE) {
61919:         mMouseHook = SetWindowsHookEx(WH_MOUSE, MouseHookProc, NULL,
61919:                                       GetCurrentThreadId());
61919:     }
35747:     return true;
35747: }
35747: 
35747: void
35893: PluginInstanceChild::DestroyPluginWindow()
35747: {
35747:     if (mPluginWindowHWND) {
35747:         // Unsubclass the window.
35747:         WNDPROC wndProc = reinterpret_cast<WNDPROC>(
35747:             GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
56343:         // Removed prior to SetWindowLongPtr, see HookSetWindowLongPtr.
56343:         RemoveProp(mPluginWindowHWND, kPluginInstanceChildProperty);
35747:         if (wndProc == PluginWindowProc) {
35747:             NS_ASSERTION(mPluginWndProc, "Should have old proc here!");
35747:             SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
47318:                              reinterpret_cast<LONG_PTR>(mPluginWndProc));
35747:             mPluginWndProc = 0;
35747:         }
35747:         DestroyWindow(mPluginWindowHWND);
35747:         mPluginWindowHWND = 0;
35747:     }
61919: 
61919:     if (mMouseHook) {
61919:         UnhookWindowsHookEx(mMouseHook);
61919:         mMouseHook = NULL;
61919:     }
35747: }
35747: 
35747: void
35893: PluginInstanceChild::ReparentPluginWindow(HWND hWndParent)
35747: {
35747:     if (hWndParent != mPluginParentHWND && IsWindow(hWndParent)) {
36082:         // Fix the child window's style to be a child window.
47318:         LONG_PTR style = GetWindowLongPtr(mPluginWindowHWND, GWL_STYLE);
35747:         style |= WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
36082:         style &= ~WS_POPUP;
35747:         SetWindowLongPtr(mPluginWindowHWND, GWL_STYLE, style);
36082: 
36082:         // Do the reparenting.
35747:         SetParent(mPluginWindowHWND, hWndParent);
36082: 
36082:         // Make sure we're visible.
35747:         ShowWindow(mPluginWindowHWND, SW_SHOWNA);
35747:     }
35747:     mPluginParentHWND = hWndParent;
35747: }
35747: 
35747: void
35893: PluginInstanceChild::SizePluginWindow(int width,
35747:                                       int height)
35747: {
35747:     if (mPluginWindowHWND) {
38281:         mPluginSize.x = width;
38281:         mPluginSize.y = height;
35747:         SetWindowPos(mPluginWindowHWND, NULL, 0, 0, width, height,
35747:                      SWP_NOZORDER | SWP_NOREPOSITION);
35747:     }
35747: }
35747: 
35747: // See chromium's webplugin_delegate_impl.cc for explanation of this function.
35747: // static
35747: LRESULT CALLBACK
35893: PluginInstanceChild::DummyWindowProc(HWND hWnd,
35747:                                      UINT message,
35747:                                      WPARAM wParam,
35747:                                      LPARAM lParam)
35747: {
35747:     return CallWindowProc(DefWindowProc, hWnd, message, wParam, lParam);
35747: }
35747: 
35747: // static
35747: LRESULT CALLBACK
35893: PluginInstanceChild::PluginWindowProc(HWND hWnd,
35747:                                       UINT message,
35747:                                       WPARAM wParam,
35747:                                       LPARAM lParam)
35747: {
36056:     NS_ASSERTION(!mozilla::ipc::SyncChannel::IsPumpingMessages(),
36056:                  "Failed to prevent a nonqueued message from running!");
35893:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
35893:         GetProp(hWnd, kPluginInstanceChildProperty));
35747:     if (!self) {
35747:         NS_NOTREACHED("Badness!");
35747:         return 0;
35747:     }
35747: 
35747:     NS_ASSERTION(self->mPluginWindowHWND == hWnd, "Wrong window!");
35747: 
38281:     // Adobe's shockwave positions the plugin window relative to the browser
38281:     // frame when it initializes. With oopp disabled, this wouldn't have an
38281:     // effect. With oopp, GeckoPluginWindow is a child of the parent plugin
38281:     // window, so the move offsets the child within the parent. Generally
38281:     // we don't want plugins moving or sizing our window, so we prevent these
38281:     // changes here.
38281:     if (message == WM_WINDOWPOSCHANGING) {
38281:       WINDOWPOS* pos = reinterpret_cast<WINDOWPOS*>(lParam);
38281:       if (pos && (!(pos->flags & SWP_NOMOVE) || !(pos->flags & SWP_NOSIZE))) {
38281:         pos->x = pos->y = 0;
38281:         pos->cx = self->mPluginSize.x;
38281:         pos->cy = self->mPluginSize.y;
38281:         LRESULT res = CallWindowProc(self->mPluginWndProc, hWnd, message, wParam,
38281:                                      lParam);
38281:         pos->x = pos->y = 0;
38281:         pos->cx = self->mPluginSize.x;
38281:         pos->cy = self->mPluginSize.y;
38281:         return res;
38281:       }
38281:     }
38281: 
37550:     // The plugin received keyboard focus, let the parent know so the dom is up to date.
37550:     if (message == WM_MOUSEACTIVATE)
57202:       self->CallPluginFocusChange(true);
37550: 
42423:     // Prevent lockups due to plugins making rpc calls when the parent
42423:     // is making a synchronous SendMessage call to the child window. Add
42423:     // more messages as needed.
42423:     if ((InSendMessageEx(NULL)&(ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
42423:         switch(message) {
42423:             case WM_KILLFOCUS:
42423:             case WM_MOUSEHWHEEL:
42423:             case WM_MOUSEWHEEL:
42423:             case WM_HSCROLL:
42423:             case WM_VSCROLL:
42423:             ReplyMessage(0);
42423:             break;
42423:         }
42423:     }
42423: 
44190:     if (message == WM_KILLFOCUS)
57202:       self->CallPluginFocusChange(false);
44190: 
41342:     if (message == WM_USER+1 &&
58734:         (self->GetQuirks() & PluginModuleChild::QUIRK_FLASH_THROTTLE_WMUSER_EVENTS)) {
41342:         self->FlashThrottleMessage(hWnd, message, wParam, lParam, true);
41342:         return 0;
41342:     }
41342: 
61919:     HandleMouseCapture(hWnd, message);
61919:     
59511:     LRESULT res = CallWindowProc(self->mPluginWndProc, hWnd, message, wParam,
59511:                                  lParam);
59511: 
35747:     if (message == WM_CLOSE)
35747:         self->DestroyPluginWindow();
35747: 
35747:     if (message == WM_NCDESTROY)
35893:         RemoveProp(hWnd, kPluginInstanceChildProperty);
35747: 
35747:     return res;
35747: }
35747: 
60621: /* system parameters info hook for flash */
60621: 
60621: typedef BOOL (WINAPI *User32SystemParametersInfoW)(UINT uiAction,
60621:                                                    UINT uiParam,
60621:                                                    PVOID pvParam,
60621:                                                    UINT fWinIni);
60621: 
60621: static User32SystemParametersInfoW sUser32SystemParametersInfoWStub = NULL;
60621: 
60621: static BOOL WINAPI User32SystemParametersInfoHook(UINT uiAction,
60621:                                                   UINT uiParam,
60621:                                                   PVOID pvParam,
60621:                                                   UINT fWinIni)
60621: {
60621:   if (!sUser32SystemParametersInfoWStub) {
60621:       NS_NOTREACHED("sUser32SystemParametersInfoWStub not set??");
60621:       return FALSE;
60621:   }
60621: 
60621:   // Tell them cleartype is disabled, so they don't mess with
60621:   // the alpha channel in our buffers.
60621:   if (uiAction == SPI_GETFONTSMOOTHINGTYPE && pvParam) {
60621:       *((UINT*)(pvParam)) = FE_FONTSMOOTHINGSTANDARD;
60621:       return TRUE;
60621:   }
60621: 
60621:   return sUser32SystemParametersInfoWStub(uiAction, uiParam, pvParam, fWinIni);
60621: }
60621: 
60621: void
60621: PluginInstanceChild::HookSystemParametersInfo()
60621: {
60621:     if (!(GetQuirks() & PluginModuleChild::QUIRK_FLASH_MASK_CLEARTYPE_SETTINGS))
60621:         return;
60621:     if (sUser32SystemParametersInfoWStub)
60621:         return;
60621:     sUser32Intercept.Init("gdi32.dll");
60621:     sUser32Intercept.AddHook("SystemParametersInfoW", User32SystemParametersInfoHook,
60621:                              (void**) &sUser32SystemParametersInfoWStub);
60621: }
60621: 
56343: /* set window long ptr hook for flash */
56343: 
56343: /*
56343:  * Flash will reset the subclass of our widget at various times.
56343:  * (Notably when entering and exiting full screen mode.) This
56343:  * occurs independent of the main plugin window event procedure.
56343:  * We trap these subclass calls to prevent our subclass hook from
56343:  * getting dropped.
56343:  * Note, ascii versions can be nixed once flash versions < 10.1
56343:  * are considered obsolete.
56343:  */
56343:  
56343: #ifdef _WIN64
56343: typedef LONG_PTR
56343:   (WINAPI *User32SetWindowLongPtrA)(HWND hWnd,
56343:                                     int nIndex,
56343:                                     LONG_PTR dwNewLong);
56343: typedef LONG_PTR
56343:   (WINAPI *User32SetWindowLongPtrW)(HWND hWnd,
56343:                                     int nIndex,
56343:                                     LONG_PTR dwNewLong);
56343: static User32SetWindowLongPtrA sUser32SetWindowLongAHookStub = NULL;
56343: static User32SetWindowLongPtrW sUser32SetWindowLongWHookStub = NULL;
56343: #else
56343: typedef LONG
56343: (WINAPI *User32SetWindowLongA)(HWND hWnd,
56343:                                int nIndex,
56343:                                LONG dwNewLong);
56343: typedef LONG
56343: (WINAPI *User32SetWindowLongW)(HWND hWnd,
56343:                                int nIndex,
56343:                                LONG dwNewLong);
56343: static User32SetWindowLongA sUser32SetWindowLongAHookStub = NULL;
56343: static User32SetWindowLongW sUser32SetWindowLongWHookStub = NULL;
56343: #endif
56343: 
56343: extern LRESULT CALLBACK
56343: NeuteredWindowProc(HWND hwnd,
56343:                    UINT uMsg,
56343:                    WPARAM wParam,
56343:                    LPARAM lParam);
56343: 
56343: const wchar_t kOldWndProcProp[] = L"MozillaIPCOldWndProc";
56343: 
56343: // static
56343: PRBool
56343: PluginInstanceChild::SetWindowLongHookCheck(HWND hWnd,
56343:                                             int nIndex,
56343:                                             LONG_PTR newLong)
56343: {
56343:       // Let this go through if it's not a subclass
56343:   if (nIndex != GWLP_WNDPROC ||
56343:       // if it's not a subclassed plugin window
56343:       !GetProp(hWnd, kPluginInstanceChildProperty) ||
56343:       // if we're not disabled
56343:       GetProp(hWnd, kPluginIgnoreSubclassProperty) ||
56343:       // if the subclass is set to a known procedure
56343:       newLong == reinterpret_cast<LONG_PTR>(PluginWindowProc) ||
56343:       newLong == reinterpret_cast<LONG_PTR>(NeuteredWindowProc) ||
56343:       newLong == reinterpret_cast<LONG_PTR>(DefWindowProcA) ||
56343:       newLong == reinterpret_cast<LONG_PTR>(DefWindowProcW) ||
56343:       // if the subclass is a WindowsMessageLoop subclass restore
56343:       GetProp(hWnd, kOldWndProcProp))
56343:       return PR_TRUE;
56343:   // prevent the subclass
56343:   return PR_FALSE;
56343: }
56343: 
56343: #ifdef _WIN64
56343: LONG_PTR WINAPI
56343: PluginInstanceChild::SetWindowLongPtrAHook(HWND hWnd,
56343:                                            int nIndex,
56343:                                            LONG_PTR newLong)
56343: #else
56343: LONG WINAPI
56343: PluginInstanceChild::SetWindowLongAHook(HWND hWnd,
56343:                                         int nIndex,
56343:                                         LONG newLong)
56343: #endif
56343: {
56343:     if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
56343:         return sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
56343: 
56343:     // Set flash's new subclass to get the result. 
56343:     LONG_PTR proc = sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
56343: 
56343:     // We already checked this in SetWindowLongHookCheck
56343:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
56343:         GetProp(hWnd, kPluginInstanceChildProperty));
56343: 
56343:     // Hook our subclass back up, just like we do on setwindow.   
61975:     WNDPROC currentProc =
61975:         reinterpret_cast<WNDPROC>(GetWindowLongPtr(hWnd, GWLP_WNDPROC));
61975:     if (currentProc != PluginWindowProc) {
56343:         self->mPluginWndProc =
56343:             reinterpret_cast<WNDPROC>(sUser32SetWindowLongAHookStub(hWnd, nIndex,
56343:                 reinterpret_cast<LONG_PTR>(PluginWindowProc)));
61975:     }
56343:     return proc;
56343: }
56343: 
56343: #ifdef _WIN64
56343: LONG_PTR WINAPI
56343: PluginInstanceChild::SetWindowLongPtrWHook(HWND hWnd,
56343:                                            int nIndex,
56343:                                            LONG_PTR newLong)
56343: #else
56343: LONG WINAPI
56343: PluginInstanceChild::SetWindowLongWHook(HWND hWnd,
56343:                                         int nIndex,
56343:                                         LONG newLong)
56343: #endif
56343: {
56343:     if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
56343:         return sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
56343: 
56343:     // Set flash's new subclass to get the result. 
56343:     LONG_PTR proc = sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
56343: 
56343:     // We already checked this in SetWindowLongHookCheck
56343:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
56343:         GetProp(hWnd, kPluginInstanceChildProperty));
56343: 
56343:     // Hook our subclass back up, just like we do on setwindow.   
61975:     WNDPROC currentProc =
61975:         reinterpret_cast<WNDPROC>(GetWindowLongPtr(hWnd, GWLP_WNDPROC));
61975:     if (currentProc != PluginWindowProc) {
56343:         self->mPluginWndProc =
61975:             reinterpret_cast<WNDPROC>(sUser32SetWindowLongAHookStub(hWnd, nIndex,
56343:                 reinterpret_cast<LONG_PTR>(PluginWindowProc)));
61975:     }
56343:     return proc;
56343: }
56343: 
56343: void
56343: PluginInstanceChild::HookSetWindowLongPtr()
56343: {
56343: #ifdef _WIN64
56343:     // XXX WindowsDllInterceptor doesn't support hooks
56343:     // in 64-bit builds, disabling this code for now.
56343:     return;
56343: #endif
56343: 
58734:     if (!(GetQuirks() & PluginModuleChild::QUIRK_FLASH_HOOK_SETLONGPTR))
56343:         return;
56343: 
56343:     sUser32Intercept.Init("user32.dll");
56343: #ifdef _WIN64
56343:     sUser32Intercept.AddHook("SetWindowLongPtrA", SetWindowLongPtrAHook,
56343:                              (void**) &sUser32SetWindowLongAHookStub);
56343:     sUser32Intercept.AddHook("SetWindowLongPtrW", SetWindowLongPtrWHook,
56343:                              (void**) &sUser32SetWindowLongWHookStub);
56343: #else
56343:     sUser32Intercept.AddHook("SetWindowLongA", SetWindowLongAHook,
56343:                              (void**) &sUser32SetWindowLongAHookStub);
56343:     sUser32Intercept.AddHook("SetWindowLongW", SetWindowLongWHook,
56343:                              (void**) &sUser32SetWindowLongWHookStub);
56343: #endif
56343: }
56343: 
39729: /* windowless track popup menu helpers */
39729: 
39729: BOOL
39729: WINAPI
39729: PluginInstanceChild::TrackPopupHookProc(HMENU hMenu,
39729:                                         UINT uFlags,
39729:                                         int x,
39729:                                         int y,
39729:                                         int nReserved,
39729:                                         HWND hWnd,
39729:                                         CONST RECT *prcRect)
39729: {
39729:   if (!sUser32TrackPopupMenuStub) {
39729:       NS_ERROR("TrackPopupMenu stub isn't set! Badness!");
39729:       return 0;
39729:   }
39729: 
39729:   // Only change the parent when we know this is a context on the plugin
39729:   // surface within the browser. Prevents resetting the parent on child ui
39729:   // displayed by plugins that have working parent-child relationships.
39729:   PRUnichar szClass[21];
39729:   bool haveClass = GetClassNameW(hWnd, szClass, NS_ARRAY_LENGTH(szClass));
39729:   if (!haveClass || 
39729:       (wcscmp(szClass, L"MozillaWindowClass") &&
39729:        wcscmp(szClass, L"SWFlash_Placeholder"))) {
39729:       // Unrecognized parent
39729:       return sUser32TrackPopupMenuStub(hMenu, uFlags, x, y, nReserved,
39729:                                        hWnd, prcRect);
39729:   }
39729: 
39729:   // Called on an unexpected event, warn.
39729:   if (!sWinlessPopupSurrogateHWND) {
39729:       NS_WARNING(
39729:           "Untraced TrackPopupHookProc call! Menu might not work right!");
39729:       return sUser32TrackPopupMenuStub(hMenu, uFlags, x, y, nReserved,
39729:                                        hWnd, prcRect);
39729:   }
39729: 
39729:   HWND surrogateHwnd = sWinlessPopupSurrogateHWND;
39729:   sWinlessPopupSurrogateHWND = NULL;
39729: 
39729:   // Popups that don't use TPM_RETURNCMD expect a final command message
39729:   // when an item is selected and the context closes. Since we replace
39729:   // the parent, we need to forward this back to the real parent so it
39729:   // can act on the menu item selected.
39729:   bool isRetCmdCall = (uFlags & TPM_RETURNCMD);
39729: 
39729:   // A little trick scrounged from chromium's code - set the focus
39729:   // to our surrogate parent so keyboard nav events go to the menu. 
39729:   HWND focusHwnd = SetFocus(surrogateHwnd);
39729:   DWORD res = sUser32TrackPopupMenuStub(hMenu, uFlags|TPM_RETURNCMD, x, y,
39729:                                         nReserved, surrogateHwnd, prcRect);
39729:   if (IsWindow(focusHwnd)) {
39729:       SetFocus(focusHwnd);
39729:   }
39729: 
39729:   if (!isRetCmdCall && res) {
39729:       SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(res, 0), 0);
39729:   }
39729: 
39729:   return res;
39729: }
39729: 
39729: void
39729: PluginInstanceChild::InitPopupMenuHook()
39729: {
58734:     if (!(GetQuirks() & PluginModuleChild::QUIRK_WINLESS_TRACKPOPUP_HOOK) ||
39729:         sUser32TrackPopupMenuStub)
39729:         return;
39729: 
39729:     // Note, once WindowsDllInterceptor is initialized for a module,
39729:     // it remains initialized for that particular module for it's
39729:     // lifetime. Additional instances are needed if other modules need
39729:     // to be hooked.
39729:     sUser32Intercept.Init("user32.dll");
39729:     sUser32Intercept.AddHook("TrackPopupMenu", TrackPopupHookProc,
39729:                              (void**) &sUser32TrackPopupMenuStub);
39729: }
39729: 
39729: void
39729: PluginInstanceChild::CreateWinlessPopupSurrogate()
39729: {
39729:     // already initialized
39729:     if (mWinlessPopupSurrogateHWND)
39729:         return;
39729: 
39729:     HWND hwnd = NULL;
39729:     NPError result;
39729:     if (!CallNPN_GetValue_NPNVnetscapeWindow(&hwnd, &result)) {
39729:         NS_ERROR("CallNPN_GetValue_NPNVnetscapeWindow failed.");
39729:         return;
39729:     }
39729: 
39729:     mWinlessPopupSurrogateHWND =
39729:         CreateWindowEx(WS_EX_NOPARENTNOTIFY, L"Static", NULL, WS_CHILD, 0, 0,
39729:                        0, 0, hwnd, 0, GetModuleHandle(NULL), 0);
39729:     if (!mWinlessPopupSurrogateHWND) {
39729:         NS_ERROR("CreateWindowEx failed for winless placeholder!");
39729:         return;
39729:     }
39729:     return;
39729: }
39729: 
39729: void
39729: PluginInstanceChild::DestroyWinlessPopupSurrogate()
39729: {
39729:     if (mWinlessPopupSurrogateHWND)
39729:         DestroyWindow(mWinlessPopupSurrogateHWND);
39729:     mWinlessPopupSurrogateHWND = NULL;
39729: }
39729: 
38660: /* windowless handle event helpers */
38660: 
38660: static bool
38660: NeedsNestedEventCoverage(UINT msg)
38660: {
38660:     // Events we assume some sort of modal ui *might* be generated.
38660:     switch (msg) {
38660:         case WM_LBUTTONUP:
38660:         case WM_RBUTTONUP:
38660:         case WM_MBUTTONUP:
38660:         case WM_LBUTTONDOWN:
38660:         case WM_RBUTTONDOWN:
38660:         case WM_MBUTTONDOWN:
38660:         case WM_CONTEXTMENU:
38660:             return true;
38660:     }
38660:     return false;
38660: }
38660: 
38660: static bool
38660: IsMouseInputEvent(UINT msg)
38660: {
38660:     switch (msg) {
38660:         case WM_MOUSEMOVE:
38660:         case WM_LBUTTONUP:
38660:         case WM_RBUTTONUP:
38660:         case WM_MBUTTONUP:
38660:         case WM_LBUTTONDOWN:
38660:         case WM_RBUTTONDOWN:
38660:         case WM_MBUTTONDOWN:
38660:         case WM_LBUTTONDBLCLK:
38660:         case WM_MBUTTONDBLCLK:
38660:         case WM_RBUTTONDBLCLK:
38660:             return true;
38660:     }
38660:     return false;
38660: }
38660: 
38103: int16_t
38103: PluginInstanceChild::WinlessHandleEvent(NPEvent& event)
38103: {
39279:     if (!mPluginIface->event)
39279:         return false;
39279: 
38660:     if (!NeedsNestedEventCoverage(event.event)) {
38103:         return mPluginIface->event(&mData, reinterpret_cast<void*>(&event));
38103:     }
38103: 
38660:     // Events that might generate nested event dispatch loops need
38660:     // special handling during delivery.
38103:     int16_t handled;
38103: 
39729:     // TrackPopupMenu will fail if the parent window is not associated with
39729:     // our ui thread. So we hook TrackPopupMenu so we can hand in a surrogate
39729:     // parent created in the child process.
58734:     if ((GetQuirks() & PluginModuleChild::QUIRK_WINLESS_TRACKPOPUP_HOOK) && // XXX turn on by default?
39729:           (event.event == WM_RBUTTONDOWN || // flash
39729:            event.event == WM_RBUTTONUP)) {  // silverlight
39729:       sWinlessPopupSurrogateHWND = mWinlessPopupSurrogateHWND;
39729:     }
39729: 
38103:     handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&event));
38103: 
39729:     sWinlessPopupSurrogateHWND = NULL;
38103: 
38103:     return handled;
38103: }
38103: 
36124: /* windowless drawing helpers */
36124: 
36124: bool
39279: PluginInstanceChild::SharedSurfaceSetWindow(const NPRemoteWindow& aWindow)
36124: {
36124:     // If the surfaceHandle is empty, parent is telling us we can reuse our cached
36124:     // memory surface and hdc. Otherwise, we need to reset, usually due to a
36124:     // expanding plugin port size.
36124:     if (!aWindow.surfaceHandle) {
36124:         if (!mSharedSurfaceDib.IsValid()) {
36124:             return false;
36124:         }
36124:     }
36124:     else {
36124:         // Attach to the new shared surface parent handed us.
36124:         if (NS_FAILED(mSharedSurfaceDib.Attach((SharedDIB::Handle)aWindow.surfaceHandle,
57212:                                                aWindow.width, aWindow.height, false)))
36124:           return false;
36270:         // Free any alpha extraction resources if needed. This will be reset
36270:         // the next time it's used.
36270:         AlphaExtractCacheRelease();
36124:     }
36124:       
36124:     // NPRemoteWindow's origin is the origin of our shared dib.
57214:     mWindow.x      = aWindow.x;
57214:     mWindow.y      = aWindow.y;
36124:     mWindow.width  = aWindow.width;
36124:     mWindow.height = aWindow.height;
36124:     mWindow.type   = aWindow.type;
36124: 
36124:     mWindow.window = reinterpret_cast<void*>(mSharedSurfaceDib.GetHDC());
57214:     ::SetViewportOrgEx(mSharedSurfaceDib.GetHDC(), -aWindow.x, -aWindow.y, NULL);
39279: 
39279:     if (mPluginIface->setwindow)
39279:         mPluginIface->setwindow(&mData, &mWindow);
36124: 
36124:     return true;
36124: }
36124: 
36124: void
36124: PluginInstanceChild::SharedSurfaceRelease()
36124: {
36124:     mSharedSurfaceDib.Close();
36270:     AlphaExtractCacheRelease();
36270: }
36270: 
36270: /* double pass cache buffer - (rarely) used in cases where alpha extraction
36270:  * occurs for windowless plugins. */
36270:  
36270: bool
36270: PluginInstanceChild::AlphaExtractCacheSetup()
36270: {
36270:     AlphaExtractCacheRelease();
36270: 
36270:     mAlphaExtract.hdc = ::CreateCompatibleDC(NULL);
36270: 
36270:     if (!mAlphaExtract.hdc)
36270:         return false;
36270: 
36270:     BITMAPINFOHEADER bmih;
36270:     memset((void*)&bmih, 0, sizeof(BITMAPINFOHEADER));
36270:     bmih.biSize        = sizeof(BITMAPINFOHEADER);
36270:     bmih.biWidth       = mWindow.width;
36270:     bmih.biHeight      = mWindow.height;
36270:     bmih.biPlanes      = 1;
36270:     bmih.biBitCount    = 32;
36270:     bmih.biCompression = BI_RGB;
36270: 
36270:     void* ppvBits = nsnull;
36270:     mAlphaExtract.bmp = ::CreateDIBSection(mAlphaExtract.hdc,
36270:                                            (BITMAPINFO*)&bmih,
36270:                                            DIB_RGB_COLORS,
36270:                                            (void**)&ppvBits,
36270:                                            NULL,
36270:                                            (unsigned long)sizeof(BITMAPINFOHEADER));
36270:     if (!mAlphaExtract.bmp)
36270:       return false;
36270: 
36270:     DeleteObject(::SelectObject(mAlphaExtract.hdc, mAlphaExtract.bmp));
36270:     return true;
36124: }
36124: 
36124: void
36270: PluginInstanceChild::AlphaExtractCacheRelease()
36124: {
36270:     if (mAlphaExtract.bmp)
36270:         ::DeleteObject(mAlphaExtract.bmp);
36270: 
36270:     if (mAlphaExtract.hdc)
36270:         ::DeleteObject(mAlphaExtract.hdc);
36270: 
36270:     mAlphaExtract.bmp = NULL;
36270:     mAlphaExtract.hdc = NULL;
36270: }
36270: 
36270: void
36270: PluginInstanceChild::UpdatePaintClipRect(RECT* aRect)
36270: {
36270:     if (aRect) {
36124:         // Update the clip rect on our internal hdc
36270:         HRGN clip = ::CreateRectRgnIndirect(aRect);
36124:         ::SelectClipRgn(mSharedSurfaceDib.GetHDC(), clip);
36124:         ::DeleteObject(clip);
36124:     }
36270: }
36270: 
36270: int16_t
36270: PluginInstanceChild::SharedSurfacePaint(NPEvent& evcopy)
36270: {
39279:     if (!mPluginIface->event)
39279:         return false;
39279: 
36270:     RECT* pRect = reinterpret_cast<RECT*>(evcopy.lParam);
36270: 
36270:     switch(mAlphaExtract.doublePass) {
36270:         case RENDER_NATIVE:
36124:             // pass the internal hdc to the plugin
36270:             UpdatePaintClipRect(pRect);
36124:             evcopy.wParam = WPARAM(mSharedSurfaceDib.GetHDC());
36270:             return mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
36270:         break;
36270:         case RENDER_BACK_ONE:
36270:               // Handle a double pass render used in alpha extraction for transparent
36270:               // plugins. (See nsObjectFrame and gfxWindowsNativeDrawing for details.)
36270:               // We render twice, once to the shared dib, and once to a cache which
36270:               // we copy back on a second paint. These paints can't be spread across
36270:               // multiple rpc messages as delays cause animation frame changes.
36270:               if (!mAlphaExtract.bmp && !AlphaExtractCacheSetup()) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270: 
36270:               // See gfxWindowsNativeDrawing, color order doesn't have to match.
40219:               UpdatePaintClipRect(pRect);
36270:               ::FillRect(mSharedSurfaceDib.GetHDC(), pRect, (HBRUSH)GetStockObject(WHITE_BRUSH));
36270:               evcopy.wParam = WPARAM(mSharedSurfaceDib.GetHDC());
36270:               if (!mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy))) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270: 
36270:               // Copy to cache. We render to shared dib so we don't have to call
36270:               // setwindow between calls (flash issue).  
36270:               ::BitBlt(mAlphaExtract.hdc,
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        pRect->right - pRect->left,
36270:                        pRect->bottom - pRect->top,
36270:                        mSharedSurfaceDib.GetHDC(),
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        SRCCOPY);
36270: 
36270:               ::FillRect(mSharedSurfaceDib.GetHDC(), pRect, (HBRUSH)GetStockObject(BLACK_BRUSH));
36270:               if (!mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy))) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270:               mAlphaExtract.doublePass = RENDER_BACK_TWO;
36270:               return true;
36270:         break;
36270:         case RENDER_BACK_TWO:
36270:               // copy our cached surface back
40219:               UpdatePaintClipRect(pRect);
36270:               ::BitBlt(mSharedSurfaceDib.GetHDC(),
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        pRect->right - pRect->left,
36270:                        pRect->bottom - pRect->top,
36270:                        mAlphaExtract.hdc,
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        SRCCOPY);
36270:               mAlphaExtract.doublePass = RENDER_NATIVE;
36270:               return true;
36270:         break;
36270:     }
36270:     return false;
36124: }
36124: 
41342: /* flash msg throttling helpers */
41342: 
41342: // Flash has the unfortunate habit of flooding dispatch loops with custom
41342: // windowing events they use for timing. We throttle these by dropping the
41342: // delivery priority below any other event, including pending ipc io
41342: // notifications. We do this for both windowed and windowless controls.
41997: // Note flash's windowless msg window can last longer than our instance,
41997: // so we try to unhook when the window is destroyed and in NPP_Destroy.
41997: 
41997: void
41997: PluginInstanceChild::UnhookWinlessFlashThrottle()
41997: {
41997:   // We may have already unhooked
41997:   if (!mWinlessThrottleOldWndProc)
41997:       return;
41997: 
41997:   WNDPROC tmpProc = mWinlessThrottleOldWndProc;
41997:   mWinlessThrottleOldWndProc = nsnull;
41997: 
41997:   NS_ASSERTION(mWinlessHiddenMsgHWND,
41997:                "Missing mWinlessHiddenMsgHWND w/subclass set??");
41997: 
41997:   // reset the subclass
41997:   SetWindowLongPtr(mWinlessHiddenMsgHWND, GWLP_WNDPROC,
47318:                    reinterpret_cast<LONG_PTR>(tmpProc));
41997: 
41997:   // Remove our instance prop
56343:   RemoveProp(mWinlessHiddenMsgHWND, kFlashThrottleProperty);
41997:   mWinlessHiddenMsgHWND = nsnull;
41997: }
41342: 
41342: // static
41342: LRESULT CALLBACK
41342: PluginInstanceChild::WinlessHiddenFlashWndProc(HWND hWnd,
41342:                                                UINT message,
41342:                                                WPARAM wParam,
41342:                                                LPARAM lParam)
41342: {
41342:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
56343:         GetProp(hWnd, kFlashThrottleProperty));
41342:     if (!self) {
41342:         NS_NOTREACHED("Badness!");
41342:         return 0;
41342:     }
41342: 
41342:     NS_ASSERTION(self->mWinlessThrottleOldWndProc,
41342:                  "Missing subclass procedure!!");
41342: 
41342:     // Throttle
41342:     if (message == WM_USER+1) {
41342:         self->FlashThrottleMessage(hWnd, message, wParam, lParam, false);
41342:         return 0;
41342:      }
41342: 
41342:     // Unhook
41997:     if (message == WM_CLOSE || message == WM_NCDESTROY) {
41342:         WNDPROC tmpProc = self->mWinlessThrottleOldWndProc;
41997:         self->UnhookWinlessFlashThrottle();
41342:         LRESULT res = CallWindowProc(tmpProc, hWnd, message, wParam, lParam);
41342:         return res;
41342:     }
41342: 
41342:     return CallWindowProc(self->mWinlessThrottleOldWndProc,
41342:                           hWnd, message, wParam, lParam);
41342: }
41342: 
41342: // Enumerate all thread windows looking for flash's hidden message window.
41342: // Once we find it, sub class it so we can throttle user msgs.  
41342: // static
41342: BOOL CALLBACK
41342: PluginInstanceChild::EnumThreadWindowsCallback(HWND hWnd,
41342:                                                LPARAM aParam)
41342: {
41342:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(aParam);
41342:     if (!self) {
41342:         NS_NOTREACHED("Enum befuddled!");
41342:         return FALSE;
41342:     }
41342: 
41342:     PRUnichar className[64];
41342:     if (!GetClassNameW(hWnd, className, sizeof(className)/sizeof(PRUnichar)))
41342:       return TRUE;
41342:     
41342:     if (!wcscmp(className, L"SWFlash_PlaceholderX")) {
41342:         WNDPROC oldWndProc =
41342:             reinterpret_cast<WNDPROC>(GetWindowLongPtr(hWnd, GWLP_WNDPROC));
41342:         // Only set this if we haven't already.
41342:         if (oldWndProc != WinlessHiddenFlashWndProc) {
41342:             if (self->mWinlessThrottleOldWndProc) {
41342:                 NS_WARNING("mWinlessThrottleWndProc already set???");
41342:                 return FALSE;
41342:             }
41342:             // Subsclass and store self as a property
41997:             self->mWinlessHiddenMsgHWND = hWnd;
41342:             self->mWinlessThrottleOldWndProc =
41342:                 reinterpret_cast<WNDPROC>(SetWindowLongPtr(hWnd, GWLP_WNDPROC,
47318:                 reinterpret_cast<LONG_PTR>(WinlessHiddenFlashWndProc)));
56343:             SetProp(hWnd, kFlashThrottleProperty, self);
41342:             NS_ASSERTION(self->mWinlessThrottleOldWndProc,
41342:                          "SetWindowLongPtr failed?!");
41342:         }
41342:         // Return no matter what once we find the right window.
41342:         return FALSE;
41342:     }
41342: 
41342:     return TRUE;
41342: }
41342: 
41342: 
41342: void
41342: PluginInstanceChild::SetupFlashMsgThrottle()
41342: {
41342:     if (mWindow.type == NPWindowTypeDrawable) {
41342:         // Search for the flash hidden message window and subclass it. Only
41342:         // search for flash windows belonging to our ui thread!
41342:         if (mWinlessThrottleOldWndProc)
41342:             return;
41342:         EnumThreadWindows(GetCurrentThreadId(), EnumThreadWindowsCallback,
41342:                           reinterpret_cast<LPARAM>(this));
41342:     }
41342:     else {
41342:         // Already setup through quirks and the subclass.
41342:         return;
41342:     }
41342: }
41342: 
41342: WNDPROC
41342: PluginInstanceChild::FlashThrottleAsyncMsg::GetProc()
41342: { 
41342:     if (mInstance) {
41342:         return mWindowed ? mInstance->mPluginWndProc :
41342:                            mInstance->mWinlessThrottleOldWndProc;
41342:     }
41342:     return nsnull;
41342: }
41342:  
41342: void
41342: PluginInstanceChild::FlashThrottleAsyncMsg::Run()
41342: {
41342:     RemoveFromAsyncList();
41342: 
41342:     // GetProc() checks mInstance, and pulls the procedure from
41342:     // PluginInstanceChild. We don't transport sub-class procedure
41342:     // ptrs around in FlashThrottleAsyncMsg msgs.
41342:     if (!GetProc())
41342:         return;
41342:   
41342:     // deliver the event to flash 
41342:     CallWindowProc(GetProc(), GetWnd(), GetMsg(), GetWParam(), GetLParam());
41342: }
41342: 
41342: void
41342: PluginInstanceChild::FlashThrottleMessage(HWND aWnd,
41342:                                           UINT aMsg,
41342:                                           WPARAM aWParam,
41342:                                           LPARAM aLParam,
41342:                                           bool isWindowed)
41342: {
41342:     // We reuse ChildAsyncCall so we get the cancelation work
41342:     // that's done in Destroy.
41342:     FlashThrottleAsyncMsg* task = new FlashThrottleAsyncMsg(this,
41342:         aWnd, aMsg, aWParam, aLParam, isWindowed);
41342:     if (!task)
41342:         return; 
41342: 
41342:     {
41342:         MutexAutoLock lock(mAsyncCallMutex);
41342:         mPendingAsyncCalls.AppendElement(task);
41342:     }
41342:     MessageLoop::current()->PostDelayedTask(FROM_HERE,
41342:         task, kFlashWMUSERMessageThrottleDelayMs);
41342: }
41342: 
35747: #endif // OS_WIN
35747: 
37550: bool
37550: PluginInstanceChild::AnswerSetPluginFocus()
37550: {
37550:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s", FULLFUNCTION));
37550: 
37550: #if defined(OS_WIN)
37550:     // Parent is letting us know something set focus to the plugin.
37550:     if (::GetFocus() == mPluginWindowHWND)
37550:         return true;
37550:     ::SetFocus(mPluginWindowHWND);
37550:     return true;
37550: #else
37550:     NS_NOTREACHED("PluginInstanceChild::AnswerSetPluginFocus not implemented!");
37550:     return false;
37550: #endif
37550: }
37550: 
37554: bool
37554: PluginInstanceChild::AnswerUpdateWindow()
37554: {
37554:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s", FULLFUNCTION));
37554: 
37554: #if defined(OS_WIN)
40218:     if (mPluginWindowHWND) {
40218:         RECT rect;
40218:         if (GetUpdateRect(GetParent(mPluginWindowHWND), &rect, FALSE)) {
40218:             ::InvalidateRect(mPluginWindowHWND, &rect, FALSE); 
40218:         }
37554:         UpdateWindow(mPluginWindowHWND);
40218:     }
37554:     return true;
37554: #else
37554:     NS_NOTREACHED("PluginInstanceChild::AnswerUpdateWindow not implemented!");
37554:     return false;
37554: #endif
37554: }
37554: 
35898: PPluginScriptableObjectChild*
35943: PluginInstanceChild::AllocPPluginScriptableObject()
35835: {
35971:     AssertPluginThread();
37311:     return new PluginScriptableObjectChild(Proxy);
35835: }
35835: 
35926: bool
35965: PluginInstanceChild::DeallocPPluginScriptableObject(
35965:     PPluginScriptableObjectChild* aObject)
35835: {
35971:     AssertPluginThread();
37477:     delete aObject;
35945:     return true;
35925: }
35890: 
35965: bool
38994: PluginInstanceChild::RecvPPluginScriptableObjectConstructor(
35965:                                            PPluginScriptableObjectChild* aActor)
35965: {
35971:     AssertPluginThread();
35971: 
35965:     // This is only called in response to the parent process requesting the
35965:     // creation of an actor. This actor will represent an NPObject that is
35965:     // created by the browser and returned to the plugin.
35965:     PluginScriptableObjectChild* actor =
35965:         static_cast<PluginScriptableObjectChild*>(aActor);
37311:     NS_ASSERTION(!actor->GetObject(false), "Actor already has an object?!");
37311: 
37311:     actor->InitializeProxy();
37311:     NS_ASSERTION(actor->GetObject(false), "Actor should have an object!");
35965: 
35965:     return true;
35965: }
35965: 
37126: bool
37126: PluginInstanceChild::AnswerPBrowserStreamConstructor(
37126:     PBrowserStreamChild* aActor,
37126:     const nsCString& url,
37126:     const uint32_t& length,
37126:     const uint32_t& lastmodified,
37126:     PStreamNotifyChild* notifyData,
37126:     const nsCString& headers,
37126:     const nsCString& mimeType,
37126:     const bool& seekable,
37126:     NPError* rv,
37126:     uint16_t* stype)
37126: {
37126:     AssertPluginThread();
37126:     *rv = static_cast<BrowserStreamChild*>(aActor)
39283:           ->StreamConstructed(mimeType, seekable, stype);
37126:     return true;
37126: }
37126: 
35898: PBrowserStreamChild*
35943: PluginInstanceChild::AllocPBrowserStream(const nsCString& url,
35893:                                          const uint32_t& length,
35890:                                          const uint32_t& lastmodified,
35990:                                          PStreamNotifyChild* notifyData,
35890:                                          const nsCString& headers,
35890:                                          const nsCString& mimeType,
35890:                                          const bool& seekable,
35893:                                          NPError* rv,
35893:                                          uint16_t *stype)
35890: {
35971:     AssertPluginThread();
39283:     return new BrowserStreamChild(this, url, length, lastmodified,
39283:                                   static_cast<StreamNotifyChild*>(notifyData),
35949:                                   headers, mimeType, seekable, rv, stype);
35890: }
35890: 
35926: bool
36138: PluginInstanceChild::DeallocPBrowserStream(PBrowserStreamChild* stream)
35890: {
35971:     AssertPluginThread();
35890:     delete stream;
35926:     return true;
35890: }
35890: 
35938: PPluginStreamChild*
35943: PluginInstanceChild::AllocPPluginStream(const nsCString& mimeType,
35938:                                         const nsCString& target,
35938:                                         NPError* result)
35938: {
35938:     NS_RUNTIMEABORT("not callable");
35938:     return NULL;
35938: }
35938: 
35938: bool
36138: PluginInstanceChild::DeallocPPluginStream(PPluginStreamChild* stream)
35938: {
35971:     AssertPluginThread();
35938:     delete stream;
35938:     return true;
35938: }
35938: 
35904: PStreamNotifyChild*
35943: PluginInstanceChild::AllocPStreamNotify(const nsCString& url,
35904:                                         const nsCString& target,
35904:                                         const bool& post,
35904:                                         const nsCString& buffer,
35904:                                         const bool& file,
35904:                                         NPError* result)
35904: {
35971:     AssertPluginThread();
35904:     NS_RUNTIMEABORT("not reached");
35904:     return NULL;
35904: }
35904: 
39283: void
39283: StreamNotifyChild::ActorDestroy(ActorDestroyReason why)
35904: {
39283:     if (AncestorDeletion == why && mBrowserStream) {
39283:         NS_ERROR("Pending NPP_URLNotify not called when closing an instance.");
39283: 
39283:         // reclaim responsibility for deleting ourself
39284:         mBrowserStream->mStreamNotify = NULL;
39283:         mBrowserStream = NULL;
39283:     }
39283: }
39283: 
39283: 
39283: void
39283: StreamNotifyChild::SetAssociatedStream(BrowserStreamChild* bs)
39283: {
39283:     NS_ASSERTION(bs, "Shouldn't be null");
39283:     NS_ASSERTION(!mBrowserStream, "Two streams for one streamnotify?");
39283: 
39283:     mBrowserStream = bs;
36138: }
35971: 
36138: bool
39283: StreamNotifyChild::Recv__delete__(const NPReason& reason)
36138: {
39283:     AssertPluginThread();
39283: 
39283:     if (mBrowserStream)
39283:         mBrowserStream->NotifyPending();
39283:     else
39283:         NPP_URLNotify(reason);
39283: 
35926:     return true;
35904: }
35904: 
60021: bool
60021: StreamNotifyChild::RecvRedirectNotify(const nsCString& url, const int32_t& status)
60021: {
60021:     // NPP_URLRedirectNotify requires a non-null closure. Since core logic
60021:     // assumes that all out-of-process notify streams have non-null closure
60021:     // data it will assume that the plugin was notified at this point and
60021:     // expect a response otherwise the redirect will hang indefinitely.
60021:     if (!mClosure) {
60021:         SendRedirectNotifyResponse(false);
60021:     }
60021: 
60021:     PluginInstanceChild* instance = static_cast<PluginInstanceChild*>(Manager());
60021:     if (instance->mPluginIface->urlredirectnotify)
60481:       instance->mPluginIface->urlredirectnotify(instance->GetNPP(), url.get(), status, mClosure);
60021: 
60021:     return true;
60021: }
60021: 
39283: void
39283: StreamNotifyChild::NPP_URLNotify(NPReason reason)
39283: {
39283:     PluginInstanceChild* instance = static_cast<PluginInstanceChild*>(Manager());
39283: 
39283:     if (mClosure)
39283:         instance->mPluginIface->urlnotify(instance->GetNPP(), mURL.get(),
39283:                                           reason, mClosure);
39283: }
39283: 
36110: bool
36138: PluginInstanceChild::DeallocPStreamNotify(PStreamNotifyChild* notifyData)
36110: {
36138:     AssertPluginThread();
39283: 
39283:     if (!static_cast<StreamNotifyChild*>(notifyData)->mBrowserStream)
36110:         delete notifyData;
36110:     return true;
36110: }
36110: 
35925: PluginScriptableObjectChild*
35945: PluginInstanceChild::GetActorForNPObject(NPObject* aObject)
35925: {
35971:     AssertPluginThread();
35925:     NS_ASSERTION(aObject, "Null pointer!");
35925: 
35965:     if (aObject->_class == PluginScriptableObjectChild::GetClass()) {
35965:         // One of ours! It's a browser-provided object.
35965:         ChildNPObject* object = static_cast<ChildNPObject*>(aObject);
35965:         NS_ASSERTION(object->parent, "Null actor!");
35965:         return object->parent;
35965:     }
35945: 
35925:     PluginScriptableObjectChild* actor =
35945:         PluginModuleChild::current()->GetActorForNPObject(aObject);
35945:     if (actor) {
35965:         // Plugin-provided object that we've previously wrapped.
35945:         return actor;
35945:     }
35945: 
37311:     actor = new PluginScriptableObjectChild(LocalObject);
38994:     if (!SendPPluginScriptableObjectConstructor(actor)) {
37311:         NS_ERROR("Failed to send constructor message!");
37311:         return nsnull;
37311:     }
35925: 
37311:     actor->InitializeLocal(aObject);
35925:     return actor;
35925: }
35938: 
35938: NPError
35938: PluginInstanceChild::NPN_NewStream(NPMIMEType aMIMEType, const char* aWindow,
35938:                                    NPStream** aStream)
35938: {
35971:     AssertPluginThread();
35971: 
36138:     PluginStreamChild* ps = new PluginStreamChild();
35938: 
35938:     NPError result;
35938:     CallPPluginStreamConstructor(ps, nsDependentCString(aMIMEType),
35944:                                  NullableString(aWindow), &result);
35938:     if (NPERR_NO_ERROR != result) {
35938:         *aStream = NULL;
36138:         PPluginStreamChild::Call__delete__(ps, NPERR_GENERIC_ERROR, true);
35938:         return result;
35938:     }
35938: 
35938:     *aStream = &ps->mStream;
35938:     return NPERR_NO_ERROR;
35938: }
36082: 
60021: void
60021: PluginInstanceChild::NPN_URLRedirectResponse(void* notifyData, NPBool allow)
60021: {
60021:     if (!notifyData) {
60021:         return;
60021:     }
60021: 
60021:     InfallibleTArray<PStreamNotifyChild*> notifyStreams;
60021:     ManagedPStreamNotifyChild(notifyStreams);
60021:     PRUint32 notifyStreamCount = notifyStreams.Length();
60021:     for (PRUint32 i = 0; i < notifyStreamCount; i++) {
60021:         StreamNotifyChild* sn = static_cast<StreamNotifyChild*>(notifyStreams[i]);
60021:         if (sn->mClosure == notifyData) {
60021:             sn->SendRedirectNotifyResponse(static_cast<bool>(allow));
60021:             return;
60021:         }
60021:     }
60021:     NS_ASSERTION(PR_FALSE, "Couldn't find stream for redirect response!");
60021: }
60021: 
53940: bool
53940: PluginInstanceChild::RecvAsyncSetWindow(const gfxSurfaceType& aSurfaceType,
53940:                                         const NPRemoteWindow& aWindow)
53940: {
53942:     AssertPluginThread();
53942: 
57514:     NS_ASSERTION(!aWindow.window, "Remote window should be null.");
57514: 
58646:     if (mCurrentAsyncSetWindowTask) {
58646:         mCurrentAsyncSetWindowTask->Cancel();
58646:         mCurrentAsyncSetWindowTask = nsnull;
58646:     }
58646: 
58646:     if (mPendingPluginCall) {
58646:         // We shouldn't process this now. Run it later.
58646:         mCurrentAsyncSetWindowTask =
58646:             NewRunnableMethod<PluginInstanceChild,
58646:                               void (PluginInstanceChild::*)(const gfxSurfaceType&, const NPRemoteWindow&, bool),
58646:                               gfxSurfaceType, NPRemoteWindow, bool>
58646:                 (this, &PluginInstanceChild::DoAsyncSetWindow,
58646:                  aSurfaceType, aWindow, true);
58646:         MessageLoop::current()->PostTask(FROM_HERE, mCurrentAsyncSetWindowTask);
58646:     } else {
58646:         DoAsyncSetWindow(aSurfaceType, aWindow, false);
58646:     }
58646: 
58646:     return true;
58646: }
58646: 
58646: void
58646: PluginInstanceChild::DoAsyncSetWindow(const gfxSurfaceType& aSurfaceType,
58646:                                       const NPRemoteWindow& aWindow,
58646:                                       bool aIsAsync)
58646: {
58646:     AssertPluginThread();
58646:     NS_ASSERTION(!aWindow.window, "Remote window should be null.");
58646:     NS_ASSERTION(!mPendingPluginCall, "Can't do SetWindow during plugin call!");
58646: 
58646:     if (aIsAsync) {
58646:         if (!mCurrentAsyncSetWindowTask) {
58646:             return;
58646:         }
58646:         mCurrentAsyncSetWindowTask = nsnull;
58646:     }
58646: 
57514:     mWindow.window = NULL;
53942:     if (mWindow.width != aWindow.width || mWindow.height != aWindow.height) {
61408:         ClearCurrentSurface();
57225:         mAccumulatedInvalidRect = nsIntRect(0, 0, aWindow.width, aWindow.height);
53942:     }
57225:     if (mWindow.clipRect.top != aWindow.clipRect.top ||
57225:         mWindow.clipRect.left != aWindow.clipRect.left ||
57225:         mWindow.clipRect.bottom != aWindow.clipRect.bottom ||
57225:         mWindow.clipRect.right != aWindow.clipRect.right)
57232:         mAccumulatedInvalidRect = nsIntRect(0, 0, aWindow.width, aWindow.height);
57209: 
53942:     mWindow.x = aWindow.x;
53942:     mWindow.y = aWindow.y;
53942:     mWindow.width = aWindow.width;
53942:     mWindow.height = aWindow.height;
53942:     mWindow.clipRect = aWindow.clipRect;
53942:     mWindow.type = aWindow.type;
53942: 
58734:     if (GetQuirks() & PluginModuleChild::QUIRK_SILVERLIGHT_DEFAULT_TRANSPARENT)
57216:         mIsTransparent = true;
57216: 
57202:     mLayersRendering = true;
53942:     mSurfaceType = aSurfaceType;
57202:     UpdateWindowAttributes(true);
54551: 
57220: #ifdef XP_WIN
58734:     if (GetQuirks() & PluginModuleChild::QUIRK_WINLESS_TRACKPOPUP_HOOK)
57220:         CreateWinlessPopupSurrogate();
58734:     if (GetQuirks() & PluginModuleChild::QUIRK_FLASH_THROTTLE_WMUSER_EVENTS)
57220:         SetupFlashMsgThrottle();
57220: #endif
56622: 
57225:     if (!mAccumulatedInvalidRect.IsEmpty()) {
57225:         AsyncShowPluginFrame();
57225:     }
53940: }
53940: 
53942: static inline gfxRect
53942: GfxFromNsRect(const nsIntRect& aRect)
53942: {
53942:     return gfxRect(aRect.x, aRect.y, aRect.width, aRect.height);
53942: }
53942: 
57202: bool
53942: PluginInstanceChild::CreateOptSurface(void)
53942: {
61408:     NS_ASSERTION(!mCurrentSurface, "mCurrentSurfaceActor can get out of sync.");
61408: 
53942:     nsRefPtr<gfxASurface> retsurf;
53942:     gfxASurface::gfxImageFormat format =
53942:         mIsTransparent ? gfxASurface::ImageFormatARGB32 :
53942:                          gfxASurface::ImageFormatRGB24;
53942: 
54931: #if (MOZ_PLATFORM_MAEMO == 5) || (MOZ_PLATFORM_MAEMO == 6)
54551:     // On Maemo 5, we must send the Visibility event to activate the plugin
54551:     if (mMaemoImageRendering) {
54551:         NPEvent pluginEvent;
54551:         XVisibilityEvent& visibilityEvent = pluginEvent.xvisibility;
54551:         visibilityEvent.type = VisibilityNotify;
54551:         visibilityEvent.display = 0;
54551:         visibilityEvent.state = VisibilityUnobscured;
54551:         mPluginIface->event(&mData, reinterpret_cast<void*>(&pluginEvent));
54551:     }
54551: #endif
53942: #ifdef MOZ_X11
53942:     Display* dpy = mWsInfo.display;
53942:     Screen* screen = DefaultScreenOfDisplay(dpy);
53942:     if (format == gfxASurface::ImageFormatRGB24 &&
53942:         DefaultDepth(dpy, DefaultScreen(dpy)) == 16) {
53942:         format = gfxASurface::ImageFormatRGB16_565;
53942:     }
53942: 
53942:     if (mSurfaceType == gfxASurface::SurfaceTypeXlib) {
53942:         XRenderPictFormat* xfmt = gfxXlibSurface::FindRenderFormat(dpy, format);
53942:         if (!xfmt) {
53942:             NS_ERROR("Need X falback surface, but FindRenderFormat failed");
57202:             return false;
53942:         }
53942:         mCurrentSurface =
53942:             gfxXlibSurface::Create(screen, xfmt,
53942:                                    gfxIntSize(mWindow.width,
53942:                                               mWindow.height));
53942:         return mCurrentSurface != nsnull;
53942:     }
53942: #endif
53942: 
57209: #ifdef XP_WIN
57209:     if (mSurfaceType == gfxASurface::SurfaceTypeWin32 ||
57209:         mSurfaceType == gfxASurface::SurfaceTypeD2D) {
57209: 
57209:         SharedDIBSurface* s = new SharedDIBSurface();
57209:         if (!s->Create(reinterpret_cast<HDC>(mWindow.window),
57212:                        mWindow.width, mWindow.height, mIsTransparent))
57209:             return false;
57209: 
57209:         mCurrentSurface = s;
57209:         return true;
57209:     }
57209: 
57209:     NS_RUNTIMEABORT("Shared-memory drawing not expected on Windows.");
57209: #endif
57209: 
53942:     // Make common shmem implementation working for any platform
59847:     mCurrentSurface =
59847:         gfxSharedImageSurface::CreateUnsafe(this, gfxIntSize(mWindow.width, mWindow.height), format);
59847:     return !!mCurrentSurface;
53942: }
53942: 
57202: bool
53942: PluginInstanceChild::MaybeCreatePlatformHelperSurface(void)
53942: {
53942:     if (!mCurrentSurface) {
53942:         NS_ERROR("Cannot create helper surface without mCurrentSurface");
57202:         return false;
53942:     }
53942: 
53942: #ifdef MOZ_PLATFORM_MAEMO
53942:     // On maemo plugins support non-default visual rendering
57202:     bool supportNonDefaultVisual = true;
53942: #else
57202:     bool supportNonDefaultVisual = false;
53942: #endif
53942: #ifdef MOZ_X11
53942:     Screen* screen = DefaultScreenOfDisplay(mWsInfo.display);
53942:     Visual* defaultVisual = DefaultVisualOfScreen(screen);
53942:     Visual* visual = nsnull;
53942:     Colormap colormap = 0;
57202:     mDoAlphaExtraction = false;
57202:     bool createHelperSurface = false;
53942: 
53942:     if (mCurrentSurface->GetType() == gfxASurface::SurfaceTypeXlib) {
53942:         static_cast<gfxXlibSurface*>(mCurrentSurface.get())->
53942:             GetColormapAndVisual(&colormap, &visual);
53942:         // Create helper surface if layer surface visual not same as default
53942:         // and we don't support non-default visual rendering
53942:         if (!visual || (defaultVisual != visual && !supportNonDefaultVisual)) {
57202:             createHelperSurface = true;
53942:             visual = defaultVisual;
53942:             mDoAlphaExtraction = mIsTransparent;
53942:         }
53942:     } else if (mCurrentSurface->GetType() == gfxASurface::SurfaceTypeImage) {
54931: #if (MOZ_PLATFORM_MAEMO == 5) || (MOZ_PLATFORM_MAEMO == 6)
54551:         if (mMaemoImageRendering) {
54551:             // No helper surface needed, when mMaemoImageRendering is TRUE.
54551:             // we can rendering directly into image memory
54551:             // with NPImageExpose Maemo5 NPAPI
54551:             return PR_TRUE;
54551:         }
54551: #endif
53942:         // For image layer surface we should always create helper surface
57202:         createHelperSurface = true;
53942:         // Check if we can create helper surface with non-default visual
53942:         visual = gfxXlibSurface::FindVisual(screen,
53942:             static_cast<gfxImageSurface*>(mCurrentSurface.get())->Format());
53942:         if (visual && defaultVisual != visual && !supportNonDefaultVisual) {
53942:             visual = defaultVisual;
53942:             mDoAlphaExtraction = mIsTransparent;
53942:         }
53942:     }
53942: 
53942:     if (createHelperSurface) {
53942:         if (!visual) {
53942:             NS_ERROR("Need X falback surface, but visual failed");
57202:             return false;
53942:         }
53942:         mHelperSurface =
53942:             gfxXlibSurface::Create(screen, visual,
53942:                                    mCurrentSurface->GetSize());
53942:         if (!mHelperSurface) {
53942:             NS_WARNING("Fail to create create helper surface");
57202:             return false;
53942:         }
53942:     }
53942: #endif
53942: 
57202:     return true;
53942: }
53942: 
57202: bool
53942: PluginInstanceChild::EnsureCurrentBuffer(void)
53942: {
53942:     if (mCurrentSurface) {
57202:        return true;
53942:     }
53942: 
53942:     if (!mWindow.width || !mWindow.height) {
57202:         return false;
53942:     }
53942: 
53942:     if (!CreateOptSurface()) {
53942:         NS_ERROR("Cannot create optimized surface");
57202:         return false;
53942:     }
53942: 
53942:     if (!MaybeCreatePlatformHelperSurface()) {
53942:         NS_ERROR("Cannot create helper surface");
57202:         return false;
53942:     }
53942: 
57202:     return true;
53942: }
53942: 
53942: void
57202: PluginInstanceChild::UpdateWindowAttributes(bool aForceSetWindow)
53942: {
53942:     nsRefPtr<gfxASurface> curSurface = mHelperSurface ? mHelperSurface : mCurrentSurface;
57202:     bool needWindowUpdate = aForceSetWindow;
53942: #ifdef MOZ_X11
53942:     Visual* visual = nsnull;
53942:     Colormap colormap = 0;
53942:     if (curSurface && curSurface->GetType() == gfxASurface::SurfaceTypeXlib) {
53942:         static_cast<gfxXlibSurface*>(curSurface.get())->
53942:             GetColormapAndVisual(&colormap, &visual);
53942:         if (visual != mWsInfo.visual || colormap != mWsInfo.colormap) {
53942:             mWsInfo.visual = visual;
53942:             mWsInfo.colormap = colormap;
57202:             needWindowUpdate = true;
53942:         }
53942:     }
54931: #if (MOZ_PLATFORM_MAEMO == 5) || (MOZ_PLATFORM_MAEMO == 6)
54551:     else if (curSurface && curSurface->GetType() == gfxASurface::SurfaceTypeImage
54551:              && mMaemoImageRendering) {
54551:         // For maemo5 we need to setup window/colormap to 0
54551:         // and specify depth of image surface
54551:         gfxImageSurface* img = static_cast<gfxImageSurface*>(curSurface.get());
54551:         if (mWindow.window ||
54551:             mWsInfo.depth != gfxUtils::ImageFormatToDepth(img->Format()) ||
54551:             mWsInfo.colormap) {
54551:             mWindow.window = nsnull;
54551:             mWsInfo.depth = gfxUtils::ImageFormatToDepth(img->Format());
54551:             mWsInfo.colormap = 0;
54551:             needWindowUpdate = PR_TRUE;
54551:         }
54551:     }
57209: #endif // MAEMO
57209: #endif // MOZ_X11
57209: #ifdef XP_WIN
57209:     HDC dc = NULL;
57209: 
57209:     if (curSurface) {
57209:         NS_ASSERTION(SharedDIBSurface::IsSharedDIBSurface(curSurface),
57209:                      "Expected (SharedDIB) image surface.");
57209: 
57209:         SharedDIBSurface* dibsurf = static_cast<SharedDIBSurface*>(curSurface.get());
57209:         dc = dibsurf->GetHDC();
57209:     }
57209:     if (mWindow.window != dc) {
57209:         mWindow.window = dc;
57209:         needWindowUpdate = true;
57209:     }
57209: #endif // XP_WIN
57209: 
53942:     if (!needWindowUpdate) {
53942:         return;
53942:     }
53942: 
57214: #ifndef XP_WIN
57214:     // On Windows, we translate the device context, in order for the window
57214:     // origin to be correct.
56622:     mWindow.x = mWindow.y = 0;
57214: #endif
57214: 
57225:     if (IsVisible()) {
53942:         // The clip rect is relative to drawable top-left.
53942:         nsIntRect clipRect;
57225: 
57214:         // Don't ask the plugin to draw outside the drawable. The clip rect
57214:         // is in plugin coordinates, not window coordinates.
53942:         // This also ensures that the unsigned clip rectangle offsets won't be -ve.
57214:         clipRect.SetRect(0, 0, mWindow.width, mWindow.height);
57214: 
57214:         mWindow.clipRect.left = 0;
57214:         mWindow.clipRect.top = 0;
57214:         mWindow.clipRect.right = clipRect.XMost();
57214:         mWindow.clipRect.bottom = clipRect.YMost();
57225:     }
54551: 
57209: #ifdef XP_WIN
57209:     // Windowless plugins on Windows need a WM_WINDOWPOSCHANGED event to update
57209:     // their location... or at least Flash does: Silverlight uses the
57209:     // window.x/y passed to NPP_SetWindow
57209: 
57209:     if (mPluginIface->event) {
57209:         WINDOWPOS winpos = {
57209:             0, 0,
57214:             mWindow.x, mWindow.y,
60641:             mWindow.width, mWindow.height,
60641:             0
57209:         };
57209:         NPEvent pluginEvent = {
57209:             WM_WINDOWPOSCHANGED, 0,
57209:             (LPARAM) &winpos
57209:         };
57209:         mPluginIface->event(&mData, &pluginEvent);
57209:     }
57209: #endif
53942: 
53942:     if (mPluginIface->setwindow) {
53942:         mPluginIface->setwindow(&mData, &mWindow);
53942:     }
53942: }
53942: 
53942: void
53942: PluginInstanceChild::PaintRectToPlatformSurface(const nsIntRect& aRect,
53942:                                                 gfxASurface* aSurface)
53942: {
60641:     bool temporarilyMakeVisible = !IsVisible() && !mHasPainted;
60641:     if (temporarilyMakeVisible) {
60641:         mWindow.clipRect.right = mWindow.width;
60641:         mWindow.clipRect.bottom = mWindow.height;
60641:     }
60641: 
53942:     UpdateWindowAttributes();
60641: 
53942: #ifdef MOZ_X11
54931: #if (MOZ_PLATFORM_MAEMO == 5) || (MOZ_PLATFORM_MAEMO == 6)
54551:     // On maemo5 we do support Image rendering NPAPI
54551:     if (mMaemoImageRendering &&
54551:         aSurface->GetType() == gfxASurface::SurfaceTypeImage) {
59130:         aSurface->Flush();
54551:         gfxImageSurface* image = static_cast<gfxImageSurface*>(aSurface);
54551:         NPImageExpose imgExp;
54551:         imgExp.depth = gfxUtils::ImageFormatToDepth(image->Format());
54551:         imgExp.x = aRect.x;
54551:         imgExp.y = aRect.y;
54551:         imgExp.width = aRect.width;
54551:         imgExp.height = aRect.height;
54551:         imgExp.stride = image->Stride();
54551:         imgExp.data = (char *)image->Data();
54551:         imgExp.dataSize.width = image->Width();
54551:         imgExp.dataSize.height = image->Height();
54551:         imgExp.translateX = 0;
54551:         imgExp.translateY = 0;
54551:         imgExp.scaleX = 1;
54551:         imgExp.scaleY = 1;
54551:         NPEvent pluginEvent;
54551:         XGraphicsExposeEvent& exposeEvent = pluginEvent.xgraphicsexpose;
54551:         exposeEvent.type = GraphicsExpose;
54551:         exposeEvent.display = 0;
54551:         // Store imageExpose structure pointer as drawable member
54551:         exposeEvent.drawable = (Drawable)&imgExp;
54551:         exposeEvent.x = imgExp.x;
54551:         exposeEvent.y = imgExp.y;
54551:         exposeEvent.width = imgExp.width;
54551:         exposeEvent.height = imgExp.height;
54551:         exposeEvent.count = 0;
54551:         // information not set:
54551:         exposeEvent.serial = 0;
54551:         exposeEvent.send_event = False;
54551:         exposeEvent.major_code = 0;
54551:         exposeEvent.minor_code = 0;
54551:         mPluginIface->event(&mData, reinterpret_cast<void*>(&exposeEvent));
60641:     } else
54551: #endif
60641:     {
53942:         NS_ASSERTION(aSurface->GetType() == gfxASurface::SurfaceTypeXlib,
53942:                      "Non supported platform surface type");
53942: 
53942:         NPEvent pluginEvent;
53942:         XGraphicsExposeEvent& exposeEvent = pluginEvent.xgraphicsexpose;
53942:         exposeEvent.type = GraphicsExpose;
53942:         exposeEvent.display = mWsInfo.display;
53942:         exposeEvent.drawable = static_cast<gfxXlibSurface*>(aSurface)->XDrawable();
53942:         exposeEvent.x = aRect.x;
53942:         exposeEvent.y = aRect.y;
53942:         exposeEvent.width = aRect.width;
53942:         exposeEvent.height = aRect.height;
53942:         exposeEvent.count = 0;
53942:         // information not set:
53942:         exposeEvent.serial = 0;
53942:         exposeEvent.send_event = False;
53942:         exposeEvent.major_code = 0;
53942:         exposeEvent.minor_code = 0;
53942:         mPluginIface->event(&mData, reinterpret_cast<void*>(&exposeEvent));
60641:     }
60641: #elif defined(XP_WIN)
57209:     NS_ASSERTION(SharedDIBSurface::IsSharedDIBSurface(aSurface),
57209:                  "Expected (SharedDIB) image surface.");
57209: 
57214:     // This rect is in the window coordinate space. aRect is in the plugin
57214:     // coordinate space.
57209:     RECT rect = {
57214:         mWindow.x + aRect.x,
57214:         mWindow.y + aRect.y,
60715:         mWindow.x + aRect.XMost(),
60715:         mWindow.y + aRect.YMost()
57209:     };
57209:     NPEvent paintEvent = {
57209:         WM_PAINT,
57209:         uintptr_t(mWindow.window),
57209:         uintptr_t(&rect)
57209:     };
60715: 
57214:     ::SetViewportOrgEx((HDC) mWindow.window, -mWindow.x, -mWindow.y, NULL);
60715:     ::SelectClipRgn((HDC) mWindow.window, NULL);
60715:     ::IntersectClipRect((HDC) mWindow.window, rect.left, rect.top, rect.right, rect.bottom);
57209:     mPluginIface->event(&mData, reinterpret_cast<void*>(&paintEvent));
60641: #else
60641:     NS_RUNTIMEABORT("Surface type not implemented.");
57209: #endif
57209: 
60641:     if (temporarilyMakeVisible) {
60641:         mWindow.clipRect.right = mWindow.clipRect.bottom = 0;
60641: 
60641:         if (mPluginIface->setwindow) {
60641:             mPluginIface->setwindow(&mData, &mWindow);
60641:         }
60641:     }
53942: }
53942: 
53942: void
53942: PluginInstanceChild::PaintRectToSurface(const nsIntRect& aRect,
53942:                                         gfxASurface* aSurface,
53942:                                         const gfxRGBA& aColor)
53942: {
53942:     // Render using temporary X surface, with copy to image surface
53942:     nsIntRect plPaintRect(aRect);
53942:     nsRefPtr<gfxASurface> renderSurface = aSurface;
53942: #ifdef MOZ_X11
58735:     if (mIsTransparent && (GetQuirks() & PluginModuleChild::QUIRK_FLASH_EXPOSE_COORD_TRANSLATION)) {
53942:         // Work around a bug in Flash up to 10.1 d51 at least, where expose event
53942:         // top left coordinates within the plugin-rect and not at the drawable
53942:         // origin are misinterpreted.  (We can move the top left coordinate
53942:         // provided it is within the clipRect.), see bug 574583
53942:         plPaintRect.SetRect(0, 0, aRect.XMost(), aRect.YMost());
53942:     }
53942:     if (renderSurface->GetType() != gfxASurface::SurfaceTypeXlib) {
53942:         // On X11 we can paint to non Xlib surface only with HelperSurface
54931: #if (MOZ_PLATFORM_MAEMO == 5) || (MOZ_PLATFORM_MAEMO == 6)
54551:         // Don't use mHelperSurface if surface is image and mMaemoImageRendering is TRUE
54551:         if (!mMaemoImageRendering ||
54551:             renderSurface->GetType() != gfxASurface::SurfaceTypeImage)
54551: #endif
53942:         renderSurface = mHelperSurface;
53942:     }
53942: #endif
53942: 
53942:     if (mIsTransparent) {
53942:        // Clear surface content for transparent rendering
53942:        nsRefPtr<gfxContext> ctx = new gfxContext(renderSurface);
53942:        ctx->SetColor(aColor);
53942:        ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
53942:        ctx->Rectangle(GfxFromNsRect(plPaintRect));
53942:        ctx->Fill();
53942:     }
53942: 
53942:     PaintRectToPlatformSurface(plPaintRect, renderSurface);
53942: 
53942:     if (renderSurface != aSurface) {
53942:         // Copy helper surface content to target
53942:         nsRefPtr<gfxContext> ctx = new gfxContext(aSurface);
53942:         ctx->SetSource(renderSurface);
53942:         ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
53942:         ctx->Rectangle(GfxFromNsRect(aRect));
53942:         ctx->Fill();
53942:     }
53942: }
53942: 
53942: void
53942: PluginInstanceChild::PaintRectWithAlphaExtraction(const nsIntRect& aRect,
53942:                                                   gfxASurface* aSurface)
53942: {
53942:     // Paint onto black image
57202:     bool needImageSurface = true;
53942:     nsRefPtr<gfxImageSurface> blackImage;
53942:     gfxIntSize clipSize(aRect.width, aRect.height);
53942:     gfxPoint deviceOffset(-aRect.x, -aRect.y);
53942:     // Try to re-use existing image surface, and avoid one copy
53942:     if (aSurface->GetType() == gfxASurface::SurfaceTypeImage) {
53942:         gfxImageSurface *surface = static_cast<gfxImageSurface*>(aSurface);
53942:         if (surface->Format() == gfxASurface::ImageFormatARGB32) {
57202:             needImageSurface = false;
53942:             blackImage = surface->GetSubimage(GfxFromNsRect(aRect));
53942:         }
53942:     }
53942:     // otherwise create new helper surface
53942:     if (needImageSurface) {
53942:         blackImage = new gfxImageSurface(clipSize, gfxASurface::ImageFormatARGB32);
53942:     }
53942: 
53942:     // Paint to black image
53942:     blackImage->SetDeviceOffset(deviceOffset);
53942:     PaintRectToSurface(aRect, blackImage, gfxRGBA(0.0, 0.0, 0.0));
53942: 
53942:     // Paint onto white image
53942:     nsRefPtr<gfxImageSurface> whiteImage =
53942:         new gfxImageSurface(clipSize, gfxASurface::ImageFormatRGB24);
53942: 
53942:     whiteImage->SetDeviceOffset(deviceOffset);
53942:     PaintRectToSurface(aRect, whiteImage, gfxRGBA(1.0, 1.0, 1.0));
53942: 
53942:     // Extract Alpha from black and white image and store to black Image
53942:     gfxRect rect(aRect.x, aRect.y, aRect.width, aRect.height);
53942:     if (!gfxAlphaRecovery::RecoverAlpha(blackImage, whiteImage, nsnull)) {
53942:         return;
53942:     }
53942: 
53942:     if (needImageSurface) {
53942:         nsRefPtr<gfxContext> ctx = new gfxContext(aSurface);
53942:         ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
53942:         ctx->SetSource(blackImage);
53942:         ctx->Rectangle(GfxFromNsRect(aRect));
53942:         ctx->Fill();
53942:     }
53942: }
53942: 
57202: bool
53942: PluginInstanceChild::ShowPluginFrame()
53942: {
53942:     if (mPendingPluginCall) {
57202:         return false;
53942:     }
53942: 
60503:     AutoRestore<bool> pending(mPendingPluginCall);
60503:     mPendingPluginCall = true;
60503: 
53942:     if (!EnsureCurrentBuffer()) {
57202:         return false;
53942:     }
53942: 
53942:     // Make expose rect not bigger than clip rect
53942:     mAccumulatedInvalidRect.IntersectRect(mAccumulatedInvalidRect,
53942:         nsIntRect(mWindow.clipRect.left, mWindow.clipRect.top,
53942:                   mWindow.clipRect.right - mWindow.clipRect.left,
53942:                   mWindow.clipRect.bottom - mWindow.clipRect.top));
53942: 
57202:     // Clear accRect here to be able to pass
57202:     // test_invalidate_during_plugin_paint  test
53942:     nsIntRect rect = mAccumulatedInvalidRect;
53942:     mAccumulatedInvalidRect.Empty();
53942: 
57213:     if (!ReadbackDifferenceRect(rect)) {
54551:         // Just repaint whole plugin, because we cannot read back from Shmem which is owned by another process
54551:         rect.SetRect(0, 0, mWindow.width, mWindow.height);
54551:     }
54551: 
54551:     if (mDoAlphaExtraction) {
54551:         PaintRectWithAlphaExtraction(rect, mCurrentSurface);
54551:     } else {
54551:         PaintRectToSurface(rect, mCurrentSurface, gfxRGBA(0.0, 0.0, 0.0, 0.0));
54551:     }
60641:     mHasPainted = true;
54551: 
57324:     NPRect r = { (uint16_t)rect.y, (uint16_t)rect.x,
57324:                  (uint16_t)rect.YMost(), (uint16_t)rect.XMost() };
54551:     SurfaceDescriptor currSurf;
53942: #ifdef MOZ_X11
54551:     if (mCurrentSurface->GetType() == gfxASurface::SurfaceTypeXlib) {
54551:         gfxXlibSurface *xsurf = static_cast<gfxXlibSurface*>(mCurrentSurface.get());
54551:         currSurf = SurfaceDescriptorX11(xsurf->XDrawable(), xsurf->XRenderFormat()->id,
54551:                                         mCurrentSurface->GetSize());
54551:         // Need to sync all pending x-paint requests
54551:         // before giving drawable to another process
54551:         XSync(mWsInfo.display, False);
54551:     } else
54551: #endif
57209: #ifdef XP_WIN
57209:     if (SharedDIBSurface::IsSharedDIBSurface(mCurrentSurface)) {
61408:         SharedDIBSurface* s = static_cast<SharedDIBSurface*>(mCurrentSurface.get());
61408:         if (!mCurrentSurfaceActor) {
57209:             base::SharedMemoryHandle handle = NULL;
57209:             s->ShareToProcess(PluginModuleChild::current()->OtherProcess(), &handle);
61408: 
61408:             mCurrentSurfaceActor =
61408:                 SendPPluginSurfaceConstructor(handle,
61408:                                               mCurrentSurface->GetSize(),
61408:                                               mIsTransparent);
61408:         }
61408:         currSurf = mCurrentSurfaceActor;
57209:         s->Flush();
57209:     } else
57209: #endif
54551:     if (gfxSharedImageSurface::IsSharedImage(mCurrentSurface)) {
54551:         currSurf = static_cast<gfxSharedImageSurface*>(mCurrentSurface.get())->GetShmem();
54551:     } else {
54551:         NS_RUNTIMEABORT("Surface type is not remotable");
57202:         return false;
54551:     }
57206: 
57206:     // Unused, except to possibly return a shmem to us
57206:     SurfaceDescriptor returnSurf;
57206: 
57206:     if (!SendShow(r, currSurf, &returnSurf)) {
57202:         return false;
54551:     }
54551: 
61408:     SwapSurfaces();
54551:     mSurfaceDifferenceRect = rect;
57202:     return true;
54551: }
54551: 
57213: bool
57213: PluginInstanceChild::ReadbackDifferenceRect(const nsIntRect& rect)
57213: {
57213:     if (!mBackSurface)
57213:         return false;
57213: 
59759:     // We can read safely from XSurface,SharedDIBSurface and Unsafe SharedMemory,
59759:     // because PluginHost is not able to modify that surface
57213: #if defined(MOZ_X11)
59759:     if (mBackSurface->GetType() != gfxASurface::SurfaceTypeXlib &&
59759:         !gfxSharedImageSurface::IsSharedImage(mBackSurface))
57213:         return false;
57213: #elif defined(XP_WIN)
57213:     if (!SharedDIBSurface::IsSharedDIBSurface(mBackSurface))
57213:         return false;
57213: #else
57213:     return false;
57213: #endif
57213: 
57213:     if (mSurfaceDifferenceRect.IsEmpty())
57213:         return true;
57213: 
53942:     // Read back previous content
53942:     nsRefPtr<gfxContext> ctx = new gfxContext(mCurrentSurface);
53942:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
53942:     ctx->SetSource(mBackSurface);
53942:     // Subtract from mSurfaceDifferenceRect area which is overlapping with rect
53942:     nsIntRegion result;
53942:     result.Sub(mSurfaceDifferenceRect, nsIntRegion(rect));
53942:     nsIntRegionRectIterator iter(result);
53942:     const nsIntRect* r;
53942:     while ((r = iter.Next()) != nsnull) {
53942:         ctx->Rectangle(GfxFromNsRect(*r));
53942:     }
53942:     ctx->Fill();
57218: 
57218:     return true;
53942: }
53942: 
53942: void
53942: PluginInstanceChild::InvalidateRectDelayed(void)
53942: {
57517:     if (!mCurrentInvalidateTask) {
53942:         return;
53942:     }
53942: 
53942:     mCurrentInvalidateTask = nsnull;
60641:     if (mAccumulatedInvalidRect.IsEmpty() || (mHasPainted && !IsVisible())) {
53942:         return;
53942:     }
53942: 
53942:     if (!ShowPluginFrame()) {
53942:         AsyncShowPluginFrame();
53942:     }
53942: }
53942: 
53942: void
53942: PluginInstanceChild::AsyncShowPluginFrame(void)
53942: {
60641:     if (mCurrentInvalidateTask || (mHasPainted && !IsVisible())) {
53942:         return;
53942:     }
53942: 
53942:     mCurrentInvalidateTask =
53942:         NewRunnableMethod(this, &PluginInstanceChild::InvalidateRectDelayed);
53942:     MessageLoop::current()->PostTask(FROM_HERE, mCurrentInvalidateTask);
53942: }
53942: 
36835: void
36835: PluginInstanceChild::InvalidateRect(NPRect* aInvalidRect)
36082: {
36082:     NS_ASSERTION(aInvalidRect, "Null pointer!");
36082: 
36082: #ifdef OS_WIN
36124:     // Invalidate and draw locally for windowed plugins.
36124:     if (mWindow.type == NPWindowTypeWindow) {
36082:       NS_ASSERTION(IsWindow(mPluginWindowHWND), "Bad window?!");
36082:       RECT rect = { aInvalidRect->left, aInvalidRect->top,
36082:                     aInvalidRect->right, aInvalidRect->bottom };
36836:       ::InvalidateRect(mPluginWindowHWND, &rect, FALSE);
36835:       return;
36124:     }
36082: #endif
36083: 
53942:     if (mLayersRendering) {
53942:         nsIntRect r(aInvalidRect->left, aInvalidRect->top,
53942:                     aInvalidRect->right - aInvalidRect->left,
53942:                     aInvalidRect->bottom - aInvalidRect->top);
53942: 
53942:         mAccumulatedInvalidRect.UnionRect(r, mAccumulatedInvalidRect);
53942:         // If we are able to paint and invalidate sent, then reset
53942:         // accumulated rectangle
53942:         AsyncShowPluginFrame();
53942:         return;
53942:     }
36835:     SendNPN_InvalidateRect(*aInvalidRect);
36082: }
37311: 
37348: uint32_t
37348: PluginInstanceChild::ScheduleTimer(uint32_t interval, bool repeat,
37348:                                    TimerFunc func)
37348: {
37348:     ChildTimer* t = new ChildTimer(this, interval, repeat, func);
37348:     if (0 == t->ID()) {
37348:         delete t;
37348:         return 0;
37348:     }
37348: 
37348:     mTimers.AppendElement(t);
37348:     return t->ID();
37348: }
37348: 
37348: void
37348: PluginInstanceChild::UnscheduleTimer(uint32_t id)
37348: {
37348:     if (0 == id)
37348:         return;
37348: 
37884:     mTimers.RemoveElement(id, ChildTimer::IDComparator());
37348: }
37348: 
39979: void
39979: PluginInstanceChild::AsyncCall(PluginThreadCallback aFunc, void* aUserData)
39979: {
39979:     ChildAsyncCall* task = new ChildAsyncCall(this, aFunc, aUserData);
39979: 
39979:     {
39979:         MutexAutoLock lock(mAsyncCallMutex);
39979:         mPendingAsyncCalls.AppendElement(task);
39979:     }
42302:     ProcessChild::message_loop()->PostTask(FROM_HERE, task);
39979: }
39979: 
38669: static PLDHashOperator
38669: InvalidateObject(DeletingObjectEntry* e, void* userArg)
38669: {
38669:     NPObject* o = e->GetKey();
38669:     if (!e->mDeleted && o->_class && o->_class->invalidate)
38669:         o->_class->invalidate(o);
38669: 
38669:     return PL_DHASH_NEXT;
38669: }
38669: 
38669: static PLDHashOperator
38669: DeleteObject(DeletingObjectEntry* e, void* userArg)
38669: {
38669:     NPObject* o = e->GetKey();
38669:     if (!e->mDeleted) {
38669:         e->mDeleted = true;
38669: 
38669: #ifdef NS_BUILD_REFCNT_LOGGING
38669:         {
38669:             int32_t refcnt = o->referenceCount;
38669:             while (refcnt) {
38669:                 --refcnt;
38669:                 NS_LOG_RELEASE(o, refcnt, "NPObject");
38669:             }
38669:         }
38669: #endif
38669: 
38669:         PluginModuleChild::DeallocNPObject(o);
38669:     }
38669: 
38669:     return PL_DHASH_NEXT;
38669: }
38669: 
61408: void
61408: PluginInstanceChild::SwapSurfaces()
37311: {
61408:     nsRefPtr<gfxASurface> tmpsurf = mCurrentSurface;
61408: #ifdef XP_WIN
61408:     PPluginSurfaceChild* tmpactor = mCurrentSurfaceActor;
56343: #endif
56343: 
61408:     mCurrentSurface = mBackSurface;
61408: #ifdef XP_WIN
61408:     mCurrentSurfaceActor = mBackSurfaceActor;
61408: #endif
61408: 
61408:     mBackSurface = tmpsurf;
61408: #ifdef XP_WIN
61408:     mBackSurfaceActor = tmpactor;
61408: #endif
61408: 
61408:     // Outdated back surface... not usable anymore due to changed plugin size.
61408:     // Dropping obsolete surface
61408:     if (mCurrentSurface && mBackSurface &&
61408:         mCurrentSurface->GetSize() != mBackSurface->GetSize()) {
61408:         mCurrentSurface = nsnull;
61408: #ifdef XP_WIN
61408:         if (mCurrentSurfaceActor) {
61408:             PPluginSurfaceChild::Send__delete__(mCurrentSurfaceActor);
61408:             mCurrentSurfaceActor = NULL;
61408:         }
61408: #endif
61408:     }
61408: }
61408: 
61408: void
61408: PluginInstanceChild::ClearCurrentSurface()
61408: {
61408:     mCurrentSurface = nsnull;
61408: #ifdef XP_WIN
61408:     if (mCurrentSurfaceActor) {
61408:         PPluginSurfaceChild::Send__delete__(mCurrentSurfaceActor);
61408:         mCurrentSurfaceActor = NULL;
61408:     }
61408: #endif
61408:     mHelperSurface = nsnull;
61408: }
61408: 
61408: void
61408: PluginInstanceChild::ClearAllSurfaces()
61408: {
53942:     if (mBackSurface) {
53942:         // Get last surface back, and drop it
53942:         SurfaceDescriptor temp = null_t();
53942:         NPRect r = { 0, 0, 1, 1 };
53942:         SendShow(r, temp, &temp);
53942:     }
53942:     if (gfxSharedImageSurface::IsSharedImage(mCurrentSurface))
53942:         DeallocShmem(static_cast<gfxSharedImageSurface*>(mCurrentSurface.get())->GetShmem());
53942:     if (gfxSharedImageSurface::IsSharedImage(mBackSurface))
53942:         DeallocShmem(static_cast<gfxSharedImageSurface*>(mBackSurface.get())->GetShmem());
53942:     mCurrentSurface = nsnull;
53942:     mBackSurface = nsnull;
53942: 
61408: #ifdef XP_WIN
61408:     if (mCurrentSurfaceActor) {
61408:         PPluginSurfaceChild::Send__delete__(mCurrentSurfaceActor);
61408:         mCurrentSurfaceActor = NULL;
61408:     }
61408:     if (mBackSurfaceActor) {
61408:         PPluginSurfaceChild::Send__delete__(mBackSurfaceActor);
61408:         mBackSurfaceActor = NULL;
61408:     }
61408: #endif
61408: }
61408: 
61408: bool
61408: PluginInstanceChild::AnswerNPP_Destroy(NPError* aResult)
61408: {
61408:     PLUGIN_LOG_DEBUG_METHOD;
61408:     AssertPluginThread();
61408: 
61408: #if defined(OS_WIN)
61408:     SetProp(mPluginWindowHWND, kPluginIgnoreSubclassProperty, (HANDLE)1);
61408: #endif
61408: 
57141:     InfallibleTArray<PBrowserStreamChild*> streams;
39283:     ManagedPBrowserStreamChild(streams);
39283: 
39283:     // First make sure none of these streams become deleted
39283:     for (PRUint32 i = 0; i < streams.Length(); ) {
39283:         if (static_cast<BrowserStreamChild*>(streams[i])->InstanceDying())
39283:             ++i;
39283:         else
39283:             streams.RemoveElementAt(i);
39283:     }
39283:     for (PRUint32 i = 0; i < streams.Length(); ++i)
39283:         static_cast<BrowserStreamChild*>(streams[i])->FinishDelivery();
39283: 
37884:     mTimers.Clear();
53942:     if (mCurrentInvalidateTask) {
53942:         mCurrentInvalidateTask->Cancel();
53942:         mCurrentInvalidateTask = nsnull;
53942:     }
58646:     if (mCurrentAsyncSetWindowTask) {
58646:         mCurrentAsyncSetWindowTask->Cancel();
58646:         mCurrentAsyncSetWindowTask = nsnull;
58646:     }
37348: 
58777:     // NPP_Destroy() should be a synchronization point for plugin threads
58777:     // calling NPN_AsyncCall: after this function returns, they are no longer
58777:     // allowed to make async calls on this instance.
38669:     PluginModuleChild::current()->NPP_Destroy(this);
38669:     mData.ndata = 0;
38669: 
61408:     ClearAllSurfaces();
61408: 
38669:     mDeletingHash = new nsTHashtable<DeletingObjectEntry>;
38669:     mDeletingHash->Init();
38669:     PluginModuleChild::current()->FindNPObjectsForInstance(this);
38669: 
38669:     mDeletingHash->EnumerateEntries(InvalidateObject, NULL);
38669:     mDeletingHash->EnumerateEntries(DeleteObject, NULL);
37311: 
38354:     // Null out our cached actors as they should have been killed in the
38354:     // PluginInstanceDestroyed call above.
38354:     mCachedWindowActor = nsnull;
38354:     mCachedElementActor = nsnull;
38354: 
37311: #if defined(OS_WIN)
37311:     SharedSurfaceRelease();
39729:     DestroyWinlessPopupSurrogate();
41997:     UnhookWinlessFlashThrottle();
58972:     DestroyPluginWindow();
37311: #endif
37311: 
58777:     // Pending async calls are discarded, not delivered. This matches the
58777:     // in-process behavior.
58777:     for (PRUint32 i = 0; i < mPendingAsyncCalls.Length(); ++i)
58777:         mPendingAsyncCalls[i]->Cancel();
58777: 
58777:     mPendingAsyncCalls.Clear();
58777: 
38669:     return true;
37311: }
