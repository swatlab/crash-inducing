   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Dave Hyatt <hyatt@mozilla.org> (Original Author)
   1:  *   Ben Goodger <ben@netscape.com>
   1:  *   Joe Hewitt <hewitt@netscape.com>
   1:  *   Jan Varga <varga@ku.sk>
   1:  *   Dean Tessman <dean_tessman@hotmail.com>
   1:  *   Brian Ryner <bryner@brianryner.com>
   1:  *   Blake Ross <blaker@netscape.com>
   1:  *   Pierre Chanial <pierrechanial@netscape.net>
   1:  *   Rene Pronk <r.pronk@its.tudelft.nl>
   1:  *   Nate Nielsen <nielsen@memberwebs.com>
   1:  *   Mark Banner <mark@standard8.demon.co.uk>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsCOMPtr.h"
   1: #include "nsISupportsArray.h"
   1: #include "nsPresContext.h"
   1: #include "nsINameSpaceManager.h"
   1: #include "nsIScrollbarFrame.h"
   1: 
   1: #include "nsTreeBodyFrame.h"
   1: #include "nsTreeSelection.h"
   1: 
   1: #include "nsGkAtoms.h"
   1: #include "nsCSSAnonBoxes.h"
   1: 
   1: #include "nsIContent.h"
   1: #include "nsStyleContext.h"
   1: #include "nsIBoxObject.h"
   1: #include "nsGUIEvent.h"
   1: #include "nsIDOMMouseEvent.h"
   1: #include "nsIDOMElement.h"
   1: #include "nsIDOMNodeList.h"
   1: #include "nsIDOMNSDocument.h"
   1: #include "nsIDOMXULElement.h"
   1: #include "nsIDocument.h"
   1: #include "nsIContent.h"
   1: #include "nsICSSStyleRule.h"
   1: #include "nsCSSRendering.h"
   1: #include "nsIFontMetrics.h"
   1: #include "nsIDeviceContext.h"
   1: #include "nsIXULTemplateBuilder.h"
   1: #include "nsXPIDLString.h"
   1: #include "nsHTMLContainerFrame.h"
   1: #include "nsIView.h"
   1: #include "nsIViewManager.h"
   1: #include "nsWidgetsCID.h"
   1: #include "nsBoxFrame.h"
   1: #include "nsBoxObject.h"
   1: #include "nsIURL.h"
   1: #include "nsNetUtil.h"
   1: #include "nsBoxLayoutState.h"
   1: #include "nsIDragService.h"
   1: #include "nsTreeContentView.h"
   1: #include "nsTreeUtils.h"
   1: #include "nsChildIterator.h"
   1: #include "nsIScrollableView.h"
   1: #include "nsITheme.h"
   1: #include "nsITimelineService.h"
   1: #include "imgIRequest.h"
   1: #include "imgIContainer.h"
   1: #include "imgIContainerObserver.h"
   1: #include "imgILoader.h"
   1: #include "nsINodeInfo.h"
   1: #include "nsContentUtils.h"
   1: #include "nsLayoutUtils.h"
   1: #include "nsIScrollableFrame.h"
   1: #include "nsEventDispatcher.h"
   1: #include "nsDisplayList.h"
   1: 
   1: #ifdef IBMBIDI
   1: #include "nsBidiPresUtils.h"
   1: #endif
   1: 
   1: #define ELLIPSIS "..."
   1: 
   1: static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);
   1: 
   1: // Enumeration function that cancels all the image requests in our cache
   1: PR_STATIC_CALLBACK(PLDHashOperator)
   1: CancelImageRequest(const nsAString& aKey,
   1:                    nsTreeImageCacheEntry aEntry, void* aData)
   1: {
   1:   aEntry.request->Cancel(NS_BINDING_ABORTED);
   1:   return PL_DHASH_NEXT;
   1: }
   1: 
   1: //
   1: // NS_NewTreeFrame
   1: //
   1: // Creates a new tree frame
   1: //
   1: nsIFrame*
   1: NS_NewTreeBodyFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsTreeBodyFrame(aPresShell, aContext);
   1: } // NS_NewTreeFrame
   1: 
   1: 
   1: //
   1: // QueryInterface
   1: //
   1: NS_INTERFACE_MAP_BEGIN(nsTreeBodyFrame)
   1:   NS_INTERFACE_MAP_ENTRY(nsITreeBoxObject)
   1:   NS_INTERFACE_MAP_ENTRY(nsICSSPseudoComparator)
   1:   NS_INTERFACE_MAP_ENTRY(nsIScrollbarMediator)
   1: NS_INTERFACE_MAP_END_INHERITING(nsLeafBoxFrame)
   1: 
   1: 
   1: 
   1: // Constructor
   1: nsTreeBodyFrame::nsTreeBodyFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: :nsLeafBoxFrame(aPresShell, aContext),
   1:  mTopRowIndex(0), 
   1:  mHorzPosition(0),
   1:  mHorzWidth(0),
   1:  mRowHeight(0),
   1:  mIndentation(0),
   1:  mStringWidth(-1),
   1:  mFocused(PR_FALSE),
   1:  mHasFixedRowCount(PR_FALSE),
   1:  mVerticalOverflow(PR_FALSE),
   1:  mHorizontalOverflow(PR_FALSE),
   1:  mReflowCallbackPosted(PR_FALSE),
   1:  mUpdateBatchNest(0),
   1:  mRowCount(0),
   1:  mSlots(nsnull)
   1: {
   1:   mColumns = new nsTreeColumns(nsnull);
   1:   NS_NewISupportsArray(getter_AddRefs(mScratchArray));
   1: }
   1: 
   1: // Destructor
   1: nsTreeBodyFrame::~nsTreeBodyFrame()
   1: {
   1:   mImageCache.EnumerateRead(CancelImageRequest, nsnull);
   1:   delete mSlots;
   1: }
   1: 
   1: NS_IMETHODIMP_(nsrefcnt) 
   1: nsTreeBodyFrame::AddRef(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP_(nsrefcnt)
   1: nsTreeBodyFrame::Release(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: static void
   1: GetBorderPadding(nsStyleContext* aContext, nsMargin& aMargin)
   1: {
   1:   aMargin.SizeTo(0, 0, 0, 0);
   1:   if (!aContext->GetStylePadding()->GetPadding(aMargin)) {
   1:     NS_NOTYETIMPLEMENTED("percentage padding");
   1:   }
   1:   aMargin += aContext->GetStyleBorder()->GetBorder();
   1: }
   1: 
   1: static void
   1: AdjustForBorderPadding(nsStyleContext* aContext, nsRect& aRect)
   1: {
   1:   nsMargin borderPadding(0, 0, 0, 0);
   1:   GetBorderPadding(aContext, borderPadding);
   1:   aRect.Deflate(borderPadding);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::Init(nsIContent*     aContent,
   1:                       nsIFrame*       aParent,
   1:                       nsIFrame*       aPrevInFlow)
   1: {
   1:   nsresult rv = nsLeafBoxFrame::Init(aContent, aParent, aPrevInFlow);
1412:   NS_ENSURE_SUCCESS(rv, rv);
1412: 
1412:   rv = nsBoxFrame::CreateViewForFrame(PresContext(), this, GetStyleContext(), PR_TRUE);
1412:   NS_ENSURE_SUCCESS(rv, rv);
1412: 
1412:   nsIView* view = nsLeafBoxFrame::GetView();
1412:   if (!view->HasWidget()) {
1412:     view->CreateWidget(kWidgetCID);
1412:   }
   1: 
   1:   mIndentation = GetIndentation();
   1:   mRowHeight = GetRowHeight();
   1: 
   1:   NS_ENSURE_TRUE(mImageCache.Init(16), NS_ERROR_OUT_OF_MEMORY);
   1:   return rv;
   1: }
   1: 
   1: nsSize
   1: nsTreeBodyFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
   1: {
   1:   EnsureView();
   1: 
   1:   nsIContent* baseElement = GetBaseElement();
   1: 
   1:   nsSize min(0,0);
   1:   PRInt32 desiredRows;
   1:   if (NS_UNLIKELY(!baseElement)) {
   1:     desiredRows = 0;
   1:   }
   1:   else if (baseElement->Tag() == nsGkAtoms::select &&
   1:            baseElement->IsNodeOfType(nsINode::eHTML)) {
   1:     min.width = CalcMaxRowWidth();
   1:     nsAutoString size;
   1:     baseElement->GetAttr(kNameSpaceID_None, nsGkAtoms::size, size);
   1:     if (!size.IsEmpty()) {
   1:       PRInt32 err;
   1:       desiredRows = size.ToInteger(&err);
   1:       mHasFixedRowCount = PR_TRUE;
   1:       mPageLength = desiredRows;
   1:     }
   1:     else {
   1:       desiredRows = 1;
   1:     }
   1:   }
   1:   else {
   1:     // tree
   1:     nsAutoString rows;
   1:     baseElement->GetAttr(kNameSpaceID_None, nsGkAtoms::rows, rows);
   1:     if (!rows.IsEmpty()) {
   1:       PRInt32 err;
   1:       desiredRows = rows.ToInteger(&err);
   1:       mPageLength = desiredRows;
   1:     }
   1:     else {
   1:       desiredRows = 0;
   1:     }
   1:   }
   1: 
   1:   min.height = mRowHeight * desiredRows;
   1: 
   1:   AddBorderAndPadding(min);
   1:   nsIBox::AddCSSMinSize(aBoxLayoutState, this, min);
   1: 
   1:   return min;
   1: }
   1: 
   1: nscoord
   1: nsTreeBodyFrame::CalcMaxRowWidth()
   1: {
   1:   if (mStringWidth != -1)
   1:     return mStringWidth;
   1: 
   1:   if (!mView)
   1:     return 0;
   1: 
   1:   nsStyleContext* rowContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreerow);
   1:   nsMargin rowMargin(0,0,0,0);
   1:   GetBorderPadding(rowContext, rowMargin);
   1: 
   1:   nscoord rowWidth;
   1:   nsTreeColumn* col;
   1: 
   1:   nsCOMPtr<nsIRenderingContext> rc;
 238:   PresContext()->PresShell()->CreateRenderingContext(this, getter_AddRefs(rc));
   1: 
   1:   for (PRInt32 row = 0; row < mRowCount; ++row) {
   1:     rowWidth = 0;
   1: 
   1:     for (col = mColumns->GetFirstColumn(); col; col = col->GetNext()) {
   1:       nscoord desiredWidth, currentWidth;
   1:       nsresult rv = GetCellWidth(row, col, rc, desiredWidth, currentWidth);
   1:       if (NS_FAILED(rv)) {
   1:         NS_NOTREACHED("invalid column");
   1:         continue;
   1:       }
   1:       rowWidth += desiredWidth;
   1:     }
   1: 
   1:     if (rowWidth > mStringWidth)
   1:       mStringWidth = rowWidth;
   1:   }
   1: 
   1:   mStringWidth += rowMargin.left + rowMargin.right;
   1:   return mStringWidth;
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::Destroy()
   1: {
   1:   // Make sure we cancel any posted callbacks. 
   1:   if (mReflowCallbackPosted) {
 238:     PresContext()->PresShell()->CancelReflowCallback(this);
   1:     mReflowCallbackPosted = PR_FALSE;
   1:   }
   1: 
   1:   if (mColumns)
   1:     mColumns->SetTree(nsnull);
   1: 
   1:   // Save off our info into the box object.
   1:   EnsureBoxObject();
   1:   nsCOMPtr<nsPIBoxObject> box(do_QueryInterface(mTreeBoxObject));
   1:   if (box) {
   1:     if (mTopRowIndex > 0) {
   1:       nsAutoString topRowStr; topRowStr.AssignLiteral("topRow");
   1:       nsAutoString topRow;
   1:       topRow.AppendInt(mTopRowIndex);
   1:       box->SetProperty(topRowStr.get(), topRow.get());
   1:     }
   1: 
   1:     // Always null out the cached tree body frame.
   1:     box->ClearCachedValues();
   1: 
   1:     mTreeBoxObject = nsnull; // Drop our ref here.
   1:   }
   1: 
   1:   if (mView) {
   1:     nsCOMPtr<nsITreeSelection> sel;
   1:     mView->GetSelection(getter_AddRefs(sel));
   1:     if (sel)
   1:       sel->SetTree(nsnull);
   1:     mView->SetTree(nsnull);
   1:     mView = nsnull;
   1:   }
   1: 
   1:   nsLeafBoxFrame::Destroy();
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::EnsureBoxObject()
   1: {
   1:   if (!mTreeBoxObject) {
   1:     nsIContent* parent = GetBaseElement();
   1:     if (parent) {
   1:       nsCOMPtr<nsIDOMNSDocument> nsDoc = do_QueryInterface(parent->GetDocument());
   1:       if (!nsDoc) // there may be no document, if we're called from Destroy()
   1:         return;
   1:       nsCOMPtr<nsIBoxObject> box;
   1:       nsCOMPtr<nsIDOMElement> domElem = do_QueryInterface(parent);
   1:       nsDoc->GetBoxObjectFor(domElem, getter_AddRefs(box));
   1:       // Ensure that we got a native box object.
   1:       nsCOMPtr<nsPIBoxObject> pBox = do_QueryInterface(box);
   1:       if (pBox) {
   1:         mTreeBoxObject = do_QueryInterface(pBox);
   1:         mColumns->SetTree(mTreeBoxObject);
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::EnsureView()
   1: {
   1:   if (!mView) {
   1:     EnsureBoxObject();
   1:     nsCOMPtr<nsIBoxObject> box = do_QueryInterface(mTreeBoxObject);
   1:     if (box) {
   1:       nsCOMPtr<nsITreeView> treeView;
   1:       mTreeBoxObject->GetView(getter_AddRefs(treeView));
   1:       if (treeView) {
   1:         nsXPIDLString rowStr;
   1:         box->GetProperty(NS_LITERAL_STRING("topRow").get(),
   1:                          getter_Copies(rowStr));
   1:         nsAutoString rowStr2(rowStr);
   1:         PRInt32 error;
   1:         PRInt32 rowIndex = rowStr2.ToInteger(&error);
   1: 
   1:         // Set our view.
   1:         SetView(treeView);
   1: 
   1:         // Scroll to the given row.
   1:         // XXX is this optimal if we haven't laid out yet?
   1:         ScrollToRow(rowIndex);
   1: 
   1:         // Clear out the property info for the top row, but we always keep the
   1:         // view current.
   1:         box->RemoveProperty(NS_LITERAL_STRING("topRow").get());
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::SetBounds(nsBoxLayoutState& aBoxLayoutState, const nsRect& aRect,
   1:                            PRBool aRemoveOverflowArea)
   1: {
   1:   nscoord horzWidth = CalcHorzWidth(GetScrollParts());
   1:   if ((aRect != mRect || mHorzWidth != horzWidth) && !mReflowCallbackPosted) {
   1:     mReflowCallbackPosted = PR_TRUE;
 238:     PresContext()->PresShell()->PostReflowCallback(this);
   1:   }
   1: 
   1:   mHorzWidth = horzWidth;
   1: 
   1:   nsLeafBoxFrame::SetBounds(aBoxLayoutState, aRect, aRemoveOverflowArea);
   1: }
   1: 
   1: 
   1: PRBool
   1: nsTreeBodyFrame::ReflowFinished()
   1: {
   1:   if (mView) {
   1:     CalcInnerBox();
   1:     ScrollParts parts = GetScrollParts();
   1:     mHorzWidth = CalcHorzWidth(parts);
   1:     if (!mHasFixedRowCount) {
   1:       mPageLength = mInnerBox.height / mRowHeight;
   1:     }
   1: 
   1:     PRInt32 lastPageTopRow = PR_MAX(0, mRowCount - mPageLength);
   1:     if (mTopRowIndex > lastPageTopRow)
   1:       ScrollToRowInternal(parts, lastPageTopRow);
   1: 
   1:     // make sure that the current selected item is still
   1:     // visible after the tree changes size.
   1:     nsCOMPtr<nsITreeSelection> sel;
   1:     mView->GetSelection(getter_AddRefs(sel));
   1:     if (sel) {
   1:       PRInt32 currentIndex;
   1:       sel->GetCurrentIndex(&currentIndex);
   1:       if (currentIndex != -1)
   1:         EnsureRowIsVisibleInternal(parts, currentIndex);
   1:     }
   1: 
   1:     InvalidateScrollbars(parts);
   1:     CheckOverflow(parts);
   1:   }
   1: 
   1:   mReflowCallbackPosted = PR_FALSE;
   1:   return PR_FALSE;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::GetView(nsITreeView * *aView)
   1: {
   1:   EnsureView();
   1:   NS_IF_ADDREF(*aView = mView);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::SetView(nsITreeView * aView)
   1: {
   1:   // First clear out the old view.
   1:   EnsureBoxObject();
   1:   
   1:   if (mView) {
   1:     nsCOMPtr<nsITreeSelection> sel;
   1:     mView->GetSelection(getter_AddRefs(sel));
   1:     if (sel)
   1:       sel->SetTree(nsnull);
   1:     mView->SetTree(nsnull);
   1: 
   1:     // Only reset the top row index and delete the columns if we had an old non-null view.
   1:     mTopRowIndex = 0;
   1:   }
   1: 
   1:   // Tree, meet the view.
   1:   mView = aView;
   1:  
   1:   // Changing the view causes us to refetch our data.  This will
   1:   // necessarily entail a full invalidation of the tree.
   1:   Invalidate();
   1:  
   1:   nsIContent *treeContent = GetBaseElement();
   1:   if (treeContent) {
   1:     FireDOMEvent(NS_LITERAL_STRING("TreeViewChanged"), treeContent);
   1:   }
   1: 
   1:   if (mView) {
   1:     // Give the view a new empty selection object to play with, but only if it
   1:     // doesn't have one already.
   1:     nsCOMPtr<nsITreeSelection> sel;
   1:     mView->GetSelection(getter_AddRefs(sel));
   1:     if (sel) {
   1:       sel->SetTree(mTreeBoxObject);
   1:     }
   1:     else {
   1:       NS_NewTreeSelection(mTreeBoxObject, getter_AddRefs(sel));
   1:       mView->SetSelection(sel);
   1:     }
   1: 
   1:     // View, meet the tree.
   1:     mView->SetTree(mTreeBoxObject);
   1:     mView->GetRowCount(&mRowCount);
   1:  
   1:     ScrollParts parts = GetScrollParts();
   1:     // The scrollbar will need to be updated.
   1:     InvalidateScrollbars(parts);
   1: 
   1:     // Reset scrollbar position.
   1:     UpdateScrollbars(parts);
   1: 
   1:     CheckOverflow(parts);
   1:   }
   1:  
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsTreeBodyFrame::GetFocused(PRBool* aFocused)
   1: {
   1:   *aFocused = mFocused;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsTreeBodyFrame::SetFocused(PRBool aFocused)
   1: {
   1:   if (mFocused != aFocused) {
   1:     mFocused = aFocused;
   1:     if (mView) {
   1:       nsCOMPtr<nsITreeSelection> sel;
   1:       mView->GetSelection(getter_AddRefs(sel));
   1:       if (sel)
   1:         sel->InvalidateSelection();
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsTreeBodyFrame::GetTreeBody(nsIDOMElement** aElement)
   1: {
   1:   //NS_ASSERTION(mContent, "no content, see bug #104878");
   1:   if (!mContent)
   1:     return NS_ERROR_NULL_POINTER;
   1: 
   1:   return mContent->QueryInterface(NS_GET_IID(nsIDOMElement), (void**)aElement);
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsTreeBodyFrame::GetColumns(nsITreeColumns** aColumns)
   1: {
   1:   EnsureBoxObject();
   1:   NS_IF_ADDREF(*aColumns = mColumns);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::GetRowHeight(PRInt32* _retval)
   1: {
   1:   *_retval = nsPresContext::AppUnitsToIntCSSPixels(mRowHeight);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsTreeBodyFrame::GetRowWidth(PRInt32 *aRowWidth)
   1: {
   1:   *aRowWidth = nsPresContext::AppUnitsToIntCSSPixels(CalcHorzWidth(GetScrollParts()));
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::GetFirstVisibleRow(PRInt32 *_retval)
   1: {
   1:   *_retval = mTopRowIndex;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::GetLastVisibleRow(PRInt32 *_retval)
   1: {
   1:   *_retval = GetLastVisibleRow();
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP 
   1: nsTreeBodyFrame::GetHorizontalPosition(PRInt32 *aHorizontalPosition)
   1: {
   1:   *aHorizontalPosition = nsPresContext::AppUnitsToIntCSSPixels(mHorzPosition); 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::GetPageLength(PRInt32 *_retval)
   1: {
   1:   *_retval = mPageLength;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::Invalidate()
   1: {
   1:   if (mUpdateBatchNest)
   1:     return NS_OK;
   1: 
   1:   nsIFrame::Invalidate(GetOverflowRect(), PR_FALSE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::InvalidateColumn(nsITreeColumn* aCol)
   1: {
   1:   if (mUpdateBatchNest)
   1:     return NS_OK;
   1: 
   1:   nsRefPtr<nsTreeColumn> col = GetColumnImpl(aCol);
   1:   if (!col)
   1:     return NS_ERROR_INVALID_ARG;
   1: 
   1:   nsRect columnRect;
   1:   nsresult rv = col->GetRect(this, mInnerBox.y, mInnerBox.height, &columnRect);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // When false then column is out of view
   1:   if (OffsetForHorzScroll(columnRect, PR_TRUE))
   1:       nsIFrame::Invalidate(columnRect, PR_FALSE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::InvalidateRow(PRInt32 aIndex)
   1: {
   1:   if (mUpdateBatchNest)
   1:     return NS_OK;
   1: 
   1:   aIndex -= mTopRowIndex;
   1:   if (aIndex < 0 || aIndex > mPageLength)
   1:     return NS_OK;
   1: 
   1:   nsRect rowRect(mInnerBox.x, mInnerBox.y+mRowHeight*aIndex, mInnerBox.width, mRowHeight);
   1: #if defined(XP_MAC) || defined(XP_MACOSX)
   1:   // Mac can't process the event loop during a drag, so if we're dragging,
   1:   // invalidate synchronously.
   1:   nsLeafBoxFrame::Invalidate(rowRect, mSlots && mSlots->mDragSession ? PR_TRUE : PR_FALSE);
   1: #else
   1:   nsLeafBoxFrame::Invalidate(rowRect, PR_FALSE);
   1: #endif
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::InvalidateCell(PRInt32 aIndex, nsITreeColumn* aCol)
   1: {
   1:   if (mUpdateBatchNest)
   1:     return NS_OK;
   1: 
   1:   aIndex -= mTopRowIndex;
   1:   if (aIndex < 0 || aIndex > mPageLength)
   1:     return NS_OK;
   1: 
   1:   nsRefPtr<nsTreeColumn> col = GetColumnImpl(aCol);
   1:   if (!col)
   1:     return NS_ERROR_INVALID_ARG;
   1: 
   1:   nsRect cellRect;
   1:   nsresult rv = col->GetRect(this, mInnerBox.y+mRowHeight*aIndex, mRowHeight,
   1:                              &cellRect);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (OffsetForHorzScroll(cellRect, PR_TRUE))
   1:     nsIFrame::Invalidate(cellRect, PR_FALSE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::InvalidateRange(PRInt32 aStart, PRInt32 aEnd)
   1: {
   1:   if (mUpdateBatchNest)
   1:     return NS_OK;
   1: 
   1:   if (aStart == aEnd)
   1:     return InvalidateRow(aStart);
   1: 
   1:   PRInt32 last = GetLastVisibleRow();
   1:   if (aStart > aEnd || aEnd < mTopRowIndex || aStart > last)
   1:     return NS_OK;
   1: 
   1:   if (aStart < mTopRowIndex)
   1:     aStart = mTopRowIndex;
   1: 
   1:   if (aEnd > last)
   1:     aEnd = last;
   1: 
   1:   nsRect rangeRect(mInnerBox.x, mInnerBox.y+mRowHeight*(aStart-mTopRowIndex), mInnerBox.width, mRowHeight*(aEnd-aStart+1));
   1:   nsIFrame::Invalidate(rangeRect, PR_FALSE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::InvalidateColumnRange(PRInt32 aStart, PRInt32 aEnd, nsITreeColumn* aCol)
   1: {
   1:   if (mUpdateBatchNest)
   1:     return NS_OK;
   1: 
   1:   nsRefPtr<nsTreeColumn> col = GetColumnImpl(aCol);
   1:   if (!col)
   1:     return NS_ERROR_INVALID_ARG;
   1: 
   1:   if (aStart == aEnd)
   1:     return InvalidateCell(aStart, col);
   1: 
   1:   PRInt32 last = GetLastVisibleRow();
   1:   if (aStart > aEnd || aEnd < mTopRowIndex || aStart > last)
   1:     return NS_OK;
   1: 
   1:   if (aStart < mTopRowIndex)
   1:     aStart = mTopRowIndex;
   1: 
   1:   if (aEnd > last)
   1:     aEnd = last;
   1: 
   1:   nsRect rangeRect;
   1:   nsresult rv = col->GetRect(this, 
   1:                              mInnerBox.y+mRowHeight*(aStart-mTopRowIndex),
   1:                              mRowHeight*(aEnd-aStart+1),
   1:                              &rangeRect);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsIFrame::Invalidate(rangeRect, PR_FALSE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: static void
   1: FindScrollParts(nsIFrame* aCurrFrame, nsTreeBodyFrame::ScrollParts* aResult)
   1: {
   1:   if (!aResult->mColumnsScrollableView) {
   1:     nsIScrollableFrame* f;
   1:     CallQueryInterface(aCurrFrame, &f);
   1:     if (f) {
   1:       aResult->mColumnsScrollableView = f->GetScrollableView();
   1:     }
   1:   }
   1:   
   1:   nsIScrollbarFrame *sf = nsnull;
   1:   CallQueryInterface(aCurrFrame, &sf);
   1:   if (sf) {
   1:     if (!aCurrFrame->IsHorizontal()) {
   1:       if (!aResult->mVScrollbar) {
   1:         aResult->mVScrollbar = sf;
   1:       }
   1:     } else {
   1:       if (!aResult->mHScrollbar) {
   1:         aResult->mHScrollbar = sf;
   1:       }
   1:     }
   1:     // don't bother searching inside a scrollbar
   1:     return;
   1:   }
   1:   
   1:   nsIFrame* child = aCurrFrame->GetFirstChild(nsnull);
   1:   while (child &&
   1:          (!aResult->mVScrollbar || !aResult->mHScrollbar ||
   1:           !aResult->mColumnsScrollableView)) {
   1:     FindScrollParts(child, aResult);
   1:     child = child->GetNextSibling();
   1:   }
   1: }
   1: 
   1: nsTreeBodyFrame::ScrollParts nsTreeBodyFrame::GetScrollParts()
   1: {
 238:   nsPresContext* presContext = PresContext();
   1:   ScrollParts result = { nsnull, nsnull, nsnull, nsnull, nsnull };
   1:   nsIContent* baseElement = GetBaseElement();
   1:   nsIFrame* treeFrame =
   1:     baseElement ? presContext->PresShell()->GetPrimaryFrameFor(baseElement) : nsnull;
   1:   if (treeFrame) {
   1:     // The way we do this, searching through the entire frame subtree, is pretty
   1:     // dumb! We should know where these frames are.
   1:     FindScrollParts(treeFrame, &result);
   1:     if (result.mHScrollbar) {
   1:       result.mHScrollbar->SetScrollbarMediatorContent(GetContent());
   1:       nsIFrame* f;
   1:       CallQueryInterface(result.mHScrollbar, &f);
   1:       result.mHScrollbarContent = f->GetContent();
   1:     }
   1:     if (result.mVScrollbar) {
   1:       result.mVScrollbar->SetScrollbarMediatorContent(GetContent());
   1:       nsIFrame* f;
   1:       CallQueryInterface(result.mVScrollbar, &f);
   1:       result.mVScrollbarContent = f->GetContent();
   1:     }
   1:   }
   1:   return result;
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::UpdateScrollbars(const ScrollParts& aParts)
   1: {
   1:   nscoord rowHeightAsPixels = nsPresContext::AppUnitsToIntCSSPixels(mRowHeight);
   1: 
   1:   // Keep strong ref.
   1:   nsCOMPtr<nsIContent> hScroll = aParts.mHScrollbarContent;
   1: 
   1:   if (aParts.mVScrollbar) {
   1:     nsAutoString curPos;
   1:     curPos.AppendInt(mTopRowIndex*rowHeightAsPixels);
   1:     aParts.mVScrollbarContent->SetAttr(kNameSpaceID_None, nsGkAtoms::curpos, curPos, PR_TRUE);
   1:   }
   1: 
   1:   if (aParts.mHScrollbar) {
   1:     nsAutoString curPos;
   1:     curPos.AppendInt(mHorzPosition);
   1:     hScroll->SetAttr(kNameSpaceID_None, nsGkAtoms::curpos, curPos, PR_TRUE);
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::CheckOverflow(const ScrollParts& aParts)
   1: {
   1:   PRBool verticalOverflowChanged = PR_FALSE;
   1: 
   1:   if (!mVerticalOverflow && mRowCount > mPageLength) {
   1:     mVerticalOverflow = PR_TRUE;
   1:     verticalOverflowChanged = PR_TRUE;
   1:   }
   1:   else if (mVerticalOverflow && mRowCount <= mPageLength) {
   1:     mVerticalOverflow = PR_FALSE;
   1:     verticalOverflowChanged = PR_TRUE;
   1:   }
   1: 
 238:   nsPresContext* presContext = PresContext();
   1: 
   1:   if (verticalOverflowChanged) {
   1:     nsScrollPortEvent event(PR_TRUE, mVerticalOverflow ? NS_SCROLLPORT_OVERFLOW
   1:                             : NS_SCROLLPORT_UNDERFLOW, nsnull);
   1:     event.orient = nsScrollPortEvent::vertical;
   1: 
   1:     nsEventStatus status = nsEventStatus_eIgnore;
   1:     nsEventDispatcher::Dispatch(mContent, presContext, &event, nsnull, &status);
   1:   }
   1: 
   1:   if (!aParts.mColumnsScrollableView)
   1:     return;
   1: 
   1:   nsRect bounds = aParts.mColumnsScrollableView->View()->GetBounds();
   1:   if (bounds.width == 0)
   1:     return;
   1: 
   1:   /* Ignore overflows that are less than half a pixel. Yes these happen
   1:      all over the place when flex boxes are compressed real small. 
   1:      Probably a result of a rounding errors somewhere in the layout code. */
   1:   bounds.width += nsPresContext::CSSPixelsToAppUnits(0.5f);
   1:   
   1:   PRBool horizontalOverflowChanged = PR_FALSE;
   1:   if (!mHorizontalOverflow && bounds.width < mHorzWidth) {
   1:     mHorizontalOverflow = PR_TRUE;
   1:     horizontalOverflowChanged = PR_TRUE;
   1:   } else if (mHorizontalOverflow && bounds.width >= mHorzWidth) {
   1:     mHorizontalOverflow = PR_FALSE;
   1:     horizontalOverflowChanged = PR_TRUE;
   1:   }
   1: 
   1:   if (horizontalOverflowChanged) {
   1:     nsScrollPortEvent event(PR_TRUE,
   1:                             mHorizontalOverflow ? NS_SCROLLPORT_OVERFLOW
   1:                                                 : NS_SCROLLPORT_UNDERFLOW,
   1:                             nsnull);
   1:     event.orient = nsScrollPortEvent::horizontal;
   1: 
   1:     nsEventStatus status = nsEventStatus_eIgnore;
   1:     nsEventDispatcher::Dispatch(mContent, presContext, &event, nsnull, &status);
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::InvalidateScrollbars(const ScrollParts& aParts)
   1: {
   1:   if (mUpdateBatchNest || !mView)
   1:     return;
   1:   nsWeakFrame weakFrame(this);
   1: 
   1:   nsCOMPtr<nsIContent> vScrollbar = aParts.mVScrollbarContent;
   1:   nsCOMPtr<nsIContent> hScrollbar = aParts.mHScrollbarContent;
   1:   if (aParts.mVScrollbar) {
   1:     // Do Vertical Scrollbar 
   1:     nsAutoString maxposStr;
   1: 
   1:     nscoord rowHeightAsPixels = nsPresContext::AppUnitsToIntCSSPixels(mRowHeight);
   1: 
   1:     PRInt32 size = rowHeightAsPixels * (mRowCount > mPageLength ? mRowCount - mPageLength : 0);
   1:     maxposStr.AppendInt(size);
   1:     vScrollbar->SetAttr(kNameSpaceID_None, nsGkAtoms::maxpos, maxposStr, PR_TRUE);
   1:     ENSURE_TRUE(weakFrame.IsAlive());
   1: 
   1:     // Also set our page increment and decrement.
   1:     nscoord pageincrement = mPageLength*rowHeightAsPixels;
   1:     nsAutoString pageStr;
   1:     pageStr.AppendInt(pageincrement);
   1:     vScrollbar->SetAttr(kNameSpaceID_None, nsGkAtoms::pageincrement, pageStr, PR_TRUE);
   1:     ENSURE_TRUE(weakFrame.IsAlive());
   1:   }
   1: 
   1:   if (aParts.mHScrollbar && aParts.mColumnsScrollableView) {
   1:     // And now Horizontal scrollbar
   1:     nsRect bounds = aParts.mColumnsScrollableView->View()->GetBounds();
   1:     nsAutoString maxposStr;
   1: 
   1:     maxposStr.AppendInt(mHorzWidth > bounds.width ? mHorzWidth - bounds.width : 0);
   1:     hScrollbar->SetAttr(kNameSpaceID_None, nsGkAtoms::maxpos, maxposStr, PR_TRUE);
   1:     ENSURE_TRUE(weakFrame.IsAlive());
   1:   
   1:     nsAutoString pageStr;
   1:     pageStr.AppendInt(bounds.width);
   1:     hScrollbar->SetAttr(kNameSpaceID_None, nsGkAtoms::pageincrement, pageStr, PR_TRUE);
   1:     ENSURE_TRUE(weakFrame.IsAlive());
   1:   
   1:     pageStr.Truncate();
   1:     pageStr.AppendInt(nsPresContext::CSSPixelsToAppUnits(16));
   1:     hScrollbar->SetAttr(kNameSpaceID_None, nsGkAtoms::increment, pageStr, PR_TRUE);
   1:   }
   1: }
   1: 
   1: // Takes client x/y in pixels, converts them to twips, and massages them to be
   1: // in our coordinate system.
   1: void
   1: nsTreeBodyFrame::AdjustClientCoordsToBoxCoordSpace(PRInt32 aX, PRInt32 aY,
   1:                                                    nscoord* aResultX,
   1:                                                    nscoord* aResultY)
   1: {
 238:   nsPresContext* presContext = PresContext();
   1: 
   1:   nsPoint point(nsPresContext::CSSPixelsToAppUnits(aX),
   1:                 nsPresContext::CSSPixelsToAppUnits(aY));
   1: 
   1:   // Now get our client offset, in twips, and subtract if from the
   1:   // point to get it in our coordinates
   1:   nsPoint clientOffset;
   1:   nsIView* closestView = GetClosestView(&clientOffset);
   1:   point -= clientOffset;
   1: 
   1:   nsIView* rootView;
   1:   presContext->GetViewManager()->GetRootView(rootView);
   1:   NS_ASSERTION(closestView && rootView, "No view?");
   1:   point -= closestView->GetOffsetTo(rootView);
   1: 
   1:   // Adjust by the inner box coords, so that we're in the inner box's
   1:   // coordinate space.
   1:   point -= mInnerBox.TopLeft();
   1: 
   1:   *aResultX = point.x;
   1:   *aResultY = point.y;
   1: } // AdjustClientCoordsToBoxCoordSpace
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::GetRowAt(PRInt32 aX, PRInt32 aY, PRInt32* _retval)
   1: {
   1:   if (!mView)
   1:     return NS_OK;
   1: 
   1:   nscoord x;
   1:   nscoord y;
   1:   AdjustClientCoordsToBoxCoordSpace(aX, aY, &x, &y);
   1: 
   1:   // Check if the coordinates are above our visible space.
   1:   if (y < 0) {
   1:     *_retval = -1;
   1:     return NS_OK;
   1:   }
   1: 
   1:   *_retval = GetRowAt(x, y);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::GetCellAt(PRInt32 aX, PRInt32 aY, PRInt32* aRow, nsITreeColumn** aCol,
   1:                            nsACString& aChildElt)
   1: {
   1:   if (!mView)
   1:     return NS_OK;
   1: 
   1:   nscoord x;
   1:   nscoord y;
   1:   AdjustClientCoordsToBoxCoordSpace(aX, aY, &x, &y);
   1: 
   1:   // Check if the coordinates are above our visible space.
   1:   if (y < 0) {
   1:     *aRow = -1;
   1:     return NS_OK;
   1:   }
   1: 
   1:   nsTreeColumn* col;
   1:   nsIAtom* child;
   1:   GetCellAt(x, y, aRow, &col, &child);
   1: 
   1:   if (col) {
   1:     NS_ADDREF(*aCol = col);
   1:     if (child == nsCSSAnonBoxes::moztreecell)
   1:       aChildElt.AssignLiteral("cell");
   1:     else if (child == nsCSSAnonBoxes::moztreetwisty)
   1:       aChildElt.AssignLiteral("twisty");
   1:     else if (child == nsCSSAnonBoxes::moztreeimage)
   1:       aChildElt.AssignLiteral("image");
   1:     else if (child == nsCSSAnonBoxes::moztreecelltext)
   1:       aChildElt.AssignLiteral("text");
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: //
   1: // GetCoordsForCellItem
   1: //
   1: // Find the x/y location and width/height (all in PIXELS) of the given object
   1: // in the given column. 
   1: //
   1: // XXX IMPORTANT XXX:
   1: // Hyatt says in the bug for this, that the following needs to be done:
   1: // (1) You need to deal with overflow when computing cell rects.  See other column 
   1: // iteration examples... if you don't deal with this, you'll mistakenly extend the 
   1: // cell into the scrollbar's rect.
   1: //
   1: // (2) You are adjusting the cell rect by the *row" border padding.  That's 
   1: // wrong.  You need to first adjust a row rect by its border/padding, and then the 
   1: // cell rect fits inside the adjusted row rect.  It also can have border/padding 
   1: // as well as margins.  The vertical direction isn't that important, but you need 
   1: // to get the horizontal direction right.
   1: //
   1: // (3) GetImageSize() does not include margins (but it does include border/padding).  
   1: // You need to make sure to add in the image's margins as well.
   1: //
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::GetCoordsForCellItem(PRInt32 aRow, nsITreeColumn* aCol, const nsACString& aElement, 
   1:                                       PRInt32 *aX, PRInt32 *aY, PRInt32 *aWidth, PRInt32 *aHeight)
   1: {
   1:   *aX = 0;
   1:   *aY = 0;
   1:   *aWidth = 0;
   1:   *aHeight = 0;
   1: 
   1:   nscoord currX = mInnerBox.x;
   1: 
   1:   // The Rect for the requested item. 
   1:   nsRect theRect;
   1: 
 238:   nsPresContext* presContext = PresContext();
   1: 
   1:   for (nsTreeColumn* currCol = mColumns->GetFirstColumn(); currCol && currX < mInnerBox.x + mInnerBox.width;
   1:        currCol = currCol->GetNext()) {
   1: 
   1:     // The Rect for the current cell.
   1:     nscoord colWidth;
   1:     nsresult rv = currCol->GetWidthInTwips(this, &colWidth);
   1:     NS_ASSERTION(NS_SUCCEEDED(rv), "invalid column");
   1: 
   1:     nsRect cellRect(currX, mInnerBox.y + mRowHeight * (aRow - mTopRowIndex),
   1:                     colWidth, mRowHeight);
   1: 
   1:     // Check the ID of the current column to see if it matches. If it doesn't 
   1:     // increment the current X value and continue to the next column.
   1:     if (currCol != aCol) {
   1:       currX += cellRect.width;
   1:       continue;
   1:     }
   1: 
   1:     // Now obtain the properties for our cell.
   1:     PrefillPropertyArray(aRow, currCol);
   1:     mView->GetCellProperties(aRow, currCol, mScratchArray);
   1: 
   1:     nsStyleContext* rowContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreerow);
   1: 
   1:     // We don't want to consider any of the decorations that may be present
   1:     // on the current row, so we have to deflate the rect by the border and 
   1:     // padding and offset its left and top coordinates appropriately. 
   1:     AdjustForBorderPadding(rowContext, cellRect);
   1: 
   1:     nsStyleContext* cellContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecell);
   1: 
   1:     NS_NAMED_LITERAL_CSTRING(cell, "cell");
   1:     if (currCol->IsCycler() || cell.Equals(aElement)) {
   1:       // If the current Column is a Cycler, then the Rect is just the cell - the margins. 
   1:       // Similarly, if we're just being asked for the cell rect, provide it. 
   1: 
   1:       theRect = cellRect;
   1:       nsMargin cellMargin;
   1:       cellContext->GetStyleMargin()->GetMargin(cellMargin);
   1:       theRect.Deflate(cellMargin);
   1:       break;
   1:     }
   1: 
   1:     // Since we're not looking for the cell, and since the cell isn't a cycler,
   1:     // we're looking for some subcomponent, and now we need to subtract the 
   1:     // borders and padding of the cell from cellRect so this does not 
   1:     // interfere with our computations.
   1:     AdjustForBorderPadding(cellContext, cellRect);
   1: 
   1:     nsCOMPtr<nsIRenderingContext> rc;
   1:     presContext->PresShell()->CreateRenderingContext(this, getter_AddRefs(rc));
   1: 
   1:     // Now we'll start making our way across the cell, starting at the edge of 
   1:     // the cell and proceeding until we hit the right edge. |cellX| is the 
   1:     // working X value that we will increment as we crawl from left to right.
   1:     nscoord cellX = cellRect.x;
   1:     nscoord remainWidth = cellRect.width;
   1: 
   1:     if (currCol->IsPrimary()) {
   1:       // If the current Column is a Primary, then we need to take into account the indentation
   1:       // and possibly a twisty. 
   1: 
   1:       // The amount of indentation is the indentation width (|mIndentation|) by the level. 
   1:       PRInt32 level;
   1:       mView->GetLevel(aRow, &level);
   1:       cellX += mIndentation * level;
   1:       remainWidth -= mIndentation * level;
   1: 
   1:       // Find the twisty rect by computing its size. 
   1:       nsRect imageRect;
   1:       nsRect twistyRect(cellRect);
   1:       nsStyleContext* twistyContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreetwisty);
   1:       GetTwistyRect(aRow, currCol, imageRect, twistyRect, presContext,
   1:                     *rc, twistyContext);
   1: 
   1:       if (NS_LITERAL_CSTRING("twisty").Equals(aElement)) {
   1:         // If we're looking for the twisty Rect, just return the size
   1:         theRect = twistyRect;
   1:         break;
   1:       }
   1:       
   1:       // Now we need to add in the margins of the twisty element, so that we 
   1:       // can find the offset of the next element in the cell. 
   1:       nsMargin twistyMargin;
   1:       twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
   1:       twistyRect.Inflate(twistyMargin);
   1: 
   1:       // Adjust our working X value with the twisty width (image size, margins,
   1:       // borders, padding. 
   1:       cellX += twistyRect.width;
   1:     }
   1: 
   1:     // Cell Image
   1:     nsStyleContext* imageContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeimage);
   1: 
   1:     nsRect imageSize = GetImageSize(aRow, currCol, PR_FALSE, imageContext);
   1:     if (NS_LITERAL_CSTRING("image").Equals(aElement)) {
   1:       theRect = imageSize;
   1:       theRect.x = cellX;
   1:       theRect.y = cellRect.y;
   1:       break;
   1:     }
   1: 
   1:     // Add in the margins of the cell image.
   1:     nsMargin imageMargin;
   1:     imageContext->GetStyleMargin()->GetMargin(imageMargin);
   1:     imageSize.Inflate(imageMargin);
   1: 
   1:     // Increment cellX by the image width
   1:     cellX += imageSize.width;
   1:     
   1:     // Cell Text 
   1:     nsAutoString cellText;
   1:     mView->GetCellText(aRow, currCol, cellText);
   1:     // We're going to measure this text so we need to ensure bidi is enabled if
   1:     // necessary
   1:     CheckTextForBidi(cellText);
   1: 
   1:     // Create a scratch rect to represent the text rectangle, with the current 
   1:     // X and Y coords, and a guess at the width and height. The width is the 
   1:     // remaining width we have left to traverse in the cell, which will be the
   1:     // widest possible value for the text rect, and the row height. 
   1:     nsRect textRect(cellX, cellRect.y, remainWidth, cellRect.height);
   1: 
   1:     // Measure the width of the text. If the width of the text is greater than 
   1:     // the remaining width available, then we just assume that the text has 
   1:     // been cropped and use the remaining rect as the text Rect. Otherwise,
   1:     // we add in borders and padding to the text dimension and give that back. 
   1:     nsStyleContext* textContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecelltext);
   1: 
   1:     nsCOMPtr<nsIFontMetrics> fm;
   1:     presContext->DeviceContext()->
   1:       GetMetricsFor(textContext->GetStyleFont()->mFont, *getter_AddRefs(fm));
   1:     nscoord height;
   1:     fm->GetHeight(height);
   1: 
   1:     nsMargin textMargin;
   1:     textContext->GetStyleMargin()->GetMargin(textMargin);
   1:     textRect.Deflate(textMargin);
   1: 
   1:     // Center the text. XXX Obey vertical-align style prop?
   1:     if (height < textRect.height) {
   1:       textRect.y += (textRect.height - height) / 2;
   1:       textRect.height = height;
   1:     }
   1: 
   1:     nsMargin bp(0,0,0,0);
   1:     GetBorderPadding(textContext, bp);
   1:     textRect.height += bp.top + bp.bottom;
   1: 
   1:     rc->SetFont(fm);
   1:     nscoord width =
   1:       nsLayoutUtils::GetStringWidth(this, rc, cellText.get(), cellText.Length());
   1: 
   1:     nscoord totalTextWidth = width + bp.left + bp.right;
   1:     if (totalTextWidth < remainWidth) {
   1:       // If the text is not cropped, the text is smaller than the available 
   1:       // space and we set the text rect to be that width. 
   1:       textRect.width = totalTextWidth;
   1:     }
   1: 
   1:     theRect = textRect;
   1:   }
   1: 
   1:   *aX = nsPresContext::AppUnitsToIntCSSPixels(theRect.x);
   1:   *aY = nsPresContext::AppUnitsToIntCSSPixels(theRect.y);
   1:   *aWidth = nsPresContext::AppUnitsToIntCSSPixels(theRect.width);
   1:   *aHeight = nsPresContext::AppUnitsToIntCSSPixels(theRect.height);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: PRInt32
   1: nsTreeBodyFrame::GetRowAt(PRInt32 aX, PRInt32 aY)
   1: {
   1:   // Now just mod by our total inner box height and add to our top row index.
   1:   PRInt32 row = (aY/mRowHeight)+mTopRowIndex;
   1: 
   1:   // Check if the coordinates are below our visible space (or within our visible
   1:   // space but below any row).
   1:   if (row > mTopRowIndex + mPageLength || row >= mRowCount)
   1:     return -1;
   1: 
   1:   return row;
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::CheckTextForBidi(nsAutoString& aText)
   1: {
   1:   // We could check to see whether the prescontext already has bidi enabled,
   1:   // but usually it won't, so it's probably faster to avoid the call to
   1:   // GetPresContext() when it's not needed.
   1:   const PRUnichar* text = aText.get();
   1:   PRUint32 length = aText.Length();
   1:   PRUint32 i;
   1:   PRBool maybeRTL = PR_FALSE;
   1:   for (i = 0; i < length; ++i) {
   1:     PRUnichar ch = text[i];
   1:     // To simplify things, anything that could be a surrogate or RTL
   1:     // presentation form is covered just by testing >= 0xD800). It's fine to
   1:     // enable bidi in rare cases where it actually isn't needed.
   1:     if (ch >= 0xD800 || IS_IN_BMP_RTL_BLOCK(ch)) {
   1:       maybeRTL = PR_TRUE;
   1:       break;
   1:     }
   1:   }
   1:   if (!maybeRTL)
   1:     return;
   1: 
 238:   PresContext()->SetBidiEnabled(PR_TRUE);
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::AdjustForCellText(nsAutoString& aText,
   1:                                    PRInt32 aRowIndex,  nsTreeColumn* aColumn,
   1:                                    nsIRenderingContext& aRenderingContext,
   1:                                    nsRect& aTextRect)
   1: {
   1:   NS_PRECONDITION(aColumn && aColumn->GetFrame(this), "invalid column passed");
   1: 
   1:   nscoord width =
   1:     nsLayoutUtils::GetStringWidth(this, &aRenderingContext, aText.get(), aText.Length());
   1:   nscoord maxWidth = aTextRect.width;
   1: 
   1:   if (aColumn->Overflow()) {
   1:     nsresult rv;
   1:     nsTreeColumn* nextColumn = aColumn->GetNext();
   1:     while (nextColumn && width > maxWidth) {
   1:       while (nextColumn) {
   1:         nscoord width;
   1:         rv = nextColumn->GetWidthInTwips(this, &width);
   1:         NS_ASSERTION(NS_SUCCEEDED(rv), "nextColumn is invalid");
   1: 
   1:         if (width != 0)
   1:           break;
   1: 
   1:         nextColumn = nextColumn->GetNext();
   1:       }
   1: 
   1:       if (nextColumn) {
   1:         nsAutoString nextText;
   1:         mView->GetCellText(aRowIndex, nextColumn, nextText);
   1:         // We don't measure or draw this text so no need to check it for
   1:         // bidi-ness
   1: 
   1:         if (nextText.Length() == 0) {
   1:           nscoord width;
   1:           rv = nextColumn->GetWidthInTwips(this, &width);
   1:           NS_ASSERTION(NS_SUCCEEDED(rv), "nextColumn is invalid");
   1: 
   1:           maxWidth += width;
   1: 
   1:           nextColumn = nextColumn->GetNext();
   1:         }
   1:         else {
   1:           nextColumn = nsnull;
   1:         }
   1:       }
   1:     }
   1:   }
   1: 
   1:   if (width > maxWidth) {
   1:     // See if the width is even smaller than the ellipsis
   1:     // If so, clear the text completely.
   1:     nscoord ellipsisWidth;
   1:     aRenderingContext.SetTextRunRTL(PR_FALSE);
   1:     aRenderingContext.GetWidth(ELLIPSIS, ellipsisWidth);
   1: 
   1:     width = maxWidth;
   1:     if (ellipsisWidth > width)
   1:       aText.SetLength(0);
   1:     else if (ellipsisWidth == width)
   1:       aText.AssignLiteral(ELLIPSIS);
   1:     else {
   1:       // We will be drawing an ellipsis, thank you very much.
   1:       // Subtract out the required width of the ellipsis.
   1:       // This is the total remaining width we have to play with.
   1:       width -= ellipsisWidth;
   1: 
   1:       // Now we crop.
   1:       switch (aColumn->GetCropStyle()) {
   1:         default:
   1:         case 0: {
   1:           // Crop right.
   1:           nscoord cwidth;
   1:           nscoord twidth = 0;
   1:           int length = aText.Length();
   1:           int i;
   1:           for (i = 0; i < length; ++i) {
   1:             PRUnichar ch = aText[i];
   1:             // XXX this is horrible and doesn't handle clusters
   1:             aRenderingContext.GetWidth(ch,cwidth);
   1:             if (twidth + cwidth > width)
   1:               break;
   1:             twidth += cwidth;
   1:           }
   1:           aText.Truncate(i);
   1:           aText.AppendLiteral(ELLIPSIS);
   1:         }
   1:         break;
   1: 
   1:         case 2: {
   1:           // Crop left.
   1:           nscoord cwidth;
   1:           nscoord twidth = 0;
   1:           int length = aText.Length();
   1:           int i;
   1:           for (i=length-1; i >= 0; --i) {
   1:             PRUnichar ch = aText[i];
   1:             aRenderingContext.GetWidth(ch,cwidth);
   1:             if (twidth + cwidth > width)
   1:               break;
   1:             twidth += cwidth;
   1:           }
   1: 
   1:           nsAutoString copy;
   1:           aText.Right(copy, length-1-i);
   1:           aText.AssignLiteral(ELLIPSIS);
   1:           aText += copy;
   1:         }
   1:         break;
   1: 
   1:         case 1:
   1:         {
   1:           // Crop center.
   1:           nsAutoString leftStr, rightStr;
   1:           nscoord cwidth, twidth = 0;
   1:           int length = aText.Length();
   1:           int rightPos = length - 1;
   1:           for (int leftPos = 0; leftPos < rightPos; ++leftPos) {
   1:             PRUnichar ch = aText[leftPos];
   1:             aRenderingContext.GetWidth(ch, cwidth);
   1:             twidth += cwidth;
   1:             if (twidth > width)
   1:               break;
   1:             leftStr.Append(ch);
   1: 
   1:             ch = aText[rightPos];
   1:             aRenderingContext.GetWidth(ch, cwidth);
   1:             twidth += cwidth;
   1:             if (twidth > width)
   1:               break;
   1:             rightStr.Insert(ch, 0);
   1:             --rightPos;
   1:           }
   1:           aText = leftStr + NS_LITERAL_STRING(ELLIPSIS) + rightStr;
   1:         }
   1:         break;
   1:       }
   1:     }
   1:   }
   1:   else {
   1:     switch (aColumn->GetTextAlignment()) {
   1:       case NS_STYLE_TEXT_ALIGN_RIGHT: {
   1:         aTextRect.x += aTextRect.width - width;
   1:       }
   1:       break;
   1:       case NS_STYLE_TEXT_ALIGN_CENTER: {
   1:         aTextRect.x += (aTextRect.width - width) / 2;
   1:       }
   1:       break;
   1:     }
   1:   }
   1: 
   1:   aTextRect.width =
   1:     nsLayoutUtils::GetStringWidth(this, &aRenderingContext, aText.get(), aText.Length());
   1: }
   1: 
   1: nsIAtom*
   1: nsTreeBodyFrame::GetItemWithinCellAt(nscoord aX, const nsRect& aCellRect, 
   1:                                      PRInt32 aRowIndex,
   1:                                      nsTreeColumn* aColumn)
   1: {
   1:   NS_PRECONDITION(aColumn && aColumn->GetFrame(this), "invalid column passed");
   1: 
   1:   // Obtain the properties for our cell.
   1:   PrefillPropertyArray(aRowIndex, aColumn);
   1:   mView->GetCellProperties(aRowIndex, aColumn, mScratchArray);
   1: 
   1:   // Resolve style for the cell.
   1:   nsStyleContext* cellContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecell);
   1: 
   1:   // Obtain the margins for the cell and then deflate our rect by that 
   1:   // amount.  The cell is assumed to be contained within the deflated rect.
   1:   nsRect cellRect(aCellRect);
   1:   nsMargin cellMargin;
   1:   cellContext->GetStyleMargin()->GetMargin(cellMargin);
   1:   cellRect.Deflate(cellMargin);
   1: 
   1:   // Adjust the rect for its border and padding.
   1:   AdjustForBorderPadding(cellContext, cellRect);
   1: 
   1:   if (aX < cellRect.x || aX >= cellRect.x + cellRect.width) {
   1:     // The user clicked within the cell's margins/borders/padding.  This constitutes a click on the cell.
   1:     return nsCSSAnonBoxes::moztreecell;
   1:   }
   1: 
   1:   nscoord currX = cellRect.x;
   1:   nscoord remainingWidth = cellRect.width;
   1: 
   1:   // XXX Handle right alignment hit testing.
   1: 
   1:   if (aColumn->IsPrimary()) {
   1:     // If we're the primary column, we have indentation and a twisty.
   1:     PRInt32 level;
   1:     mView->GetLevel(aRowIndex, &level);
   1: 
   1:     currX += mIndentation*level;
   1:     remainingWidth -= mIndentation*level;
   1: 
   1:     if (aX < currX) {
   1:       // The user clicked within the indentation.
   1:       return nsCSSAnonBoxes::moztreecell;
   1:     }
   1: 
   1:     // Always leave space for the twisty.
   1:     nsRect twistyRect(currX, cellRect.y, remainingWidth, cellRect.height);
   1:     PRBool hasTwisty = PR_FALSE;
   1:     PRBool isContainer = PR_FALSE;
   1:     mView->IsContainer(aRowIndex, &isContainer);
   1:     if (isContainer) {
   1:       PRBool isContainerEmpty = PR_FALSE;
   1:       mView->IsContainerEmpty(aRowIndex, &isContainerEmpty);
   1:       if (!isContainerEmpty)
   1:         hasTwisty = PR_TRUE;
   1:     }
   1: 
 238:     nsPresContext* presContext = PresContext();
   1:     nsCOMPtr<nsIRenderingContext> rc;
   1:     presContext->PresShell()->CreateRenderingContext(this, getter_AddRefs(rc));
   1: 
   1:     // Resolve style for the twisty.
   1:     nsStyleContext* twistyContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreetwisty);
   1: 
   1:     nsRect imageSize;
   1:     GetTwistyRect(aRowIndex, aColumn, imageSize, twistyRect, presContext,
   1:                   *rc, twistyContext);
   1: 
   1:     // We will treat a click as hitting the twisty if it happens on the margins, borders, padding,
   1:     // or content of the twisty object.  By allowing a "slop" into the margin, we make it a little
   1:     // bit easier for a user to hit the twisty.  (We don't want to be too picky here.)
   1:     nsMargin twistyMargin;
   1:     twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
   1:     twistyRect.Inflate(twistyMargin);
   1: 
   1:     // Now we test to see if aX is actually within the twistyRect.  If it is, and if the item should
   1:     // have a twisty, then we return "twisty".  If it is within the rect but we shouldn't have a twisty,
   1:     // then we return "cell".
   1:     if (aX >= twistyRect.x && aX < twistyRect.x + twistyRect.width) {
   1:       if (hasTwisty)
   1:         return nsCSSAnonBoxes::moztreetwisty;
   1:       else
   1:         return nsCSSAnonBoxes::moztreecell;
   1:     }
   1: 
   1:     currX += twistyRect.width;
   1:     remainingWidth -= twistyRect.width;    
   1:   }
   1:   
   1:   // Now test to see if the user hit the icon for the cell.
   1:   nsRect iconRect(currX, cellRect.y, remainingWidth, cellRect.height);
   1:   
   1:   // Resolve style for the image.
   1:   nsStyleContext* imageContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeimage);
   1: 
   1:   nsRect iconSize = GetImageSize(aRowIndex, aColumn, PR_FALSE, imageContext);
   1:   nsMargin imageMargin;
   1:   imageContext->GetStyleMargin()->GetMargin(imageMargin);
   1:   iconSize.Inflate(imageMargin);
   1:   iconRect.width = iconSize.width;
   1: 
   1:   if (aX >= iconRect.x && aX < iconRect.x + iconRect.width) {
   1:     // The user clicked on the image.
   1:     return nsCSSAnonBoxes::moztreeimage;
   1:   }
   1: 
   1:   currX += iconRect.width;
   1:   remainingWidth -= iconRect.width;    
   1: 
   1:   nsAutoString cellText;
   1:   mView->GetCellText(aRowIndex, aColumn, cellText);
   1:   // We're going to measure this text so we need to ensure bidi is enabled if
   1:   // necessary
   1:   CheckTextForBidi(cellText);
   1: 
   1:   nsRect textRect(currX, cellRect.y, remainingWidth, cellRect.height);
   1: 
   1:   nsStyleContext* textContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecelltext);
   1: 
   1:   nsMargin textMargin;
   1:   textContext->GetStyleMargin()->GetMargin(textMargin);
   1:   textRect.Deflate(textMargin);
   1: 
   1:   AdjustForBorderPadding(textContext, textRect);
   1: 
   1:   nsCOMPtr<nsIRenderingContext> renderingContext;
 238:   PresContext()->PresShell()->CreateRenderingContext(this, getter_AddRefs(renderingContext));
   1: 
   1:   renderingContext->SetFont(textContext->GetStyleFont()->mFont, nsnull);
   1: 
   1:   AdjustForCellText(cellText, aRowIndex, aColumn, *renderingContext, textRect);
   1: 
   1:   if (aX >= textRect.x && aX < textRect.x + textRect.width)
   1:     return nsCSSAnonBoxes::moztreecelltext;
   1:   else
   1:     return nsCSSAnonBoxes::moztreecell;
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::GetCellAt(nscoord aX, nscoord aY, PRInt32* aRow,
   1:                            nsTreeColumn** aCol, nsIAtom** aChildElt)
   1: {
   1:   *aCol = nsnull;
   1:   *aChildElt = nsnull;
   1: 
   1:   *aRow = GetRowAt(aX, aY);
   1:   if (*aRow < 0)
   1:     return;
   1: 
   1:   // Determine the column hit.
   1:   for (nsTreeColumn* currCol = mColumns->GetFirstColumn(); currCol; 
   1:        currCol = currCol->GetNext()) {
   1:     nsRect cellRect;
   1:     nsresult rv = currCol->GetRect(this,
   1:                                    mInnerBox.y +
   1:                                          mRowHeight * (*aRow - mTopRowIndex),
   1:                                    mRowHeight,
   1:                                    &cellRect);
   1:     if (NS_FAILED(rv)) {
   1:       NS_NOTREACHED("column has no frame");
   1:       continue;
   1:     }
   1: 
   1:     if (!OffsetForHorzScroll(cellRect, PR_TRUE))
   1:       continue;
   1: 
   1:     PRInt32 overflow = cellRect.x+cellRect.width-(mInnerBox.x+mInnerBox.width);
   1:     if (overflow > 0)
   1:       cellRect.width -= overflow;
   1: 
   1:     if (aX >= cellRect.x && aX < cellRect.x + cellRect.width) {
   1:       // We know the column hit now.
   1:       if (aCol)
   1:         *aCol = currCol;
   1: 
   1:       if (currCol->IsCycler())
   1:         // Cyclers contain only images.  Fill this in immediately and return.
   1:         *aChildElt = nsCSSAnonBoxes::moztreeimage;
   1:       else
   1:         *aChildElt = GetItemWithinCellAt(aX, cellRect, *aRow, currCol);
   1:       break;
   1:     }
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsTreeBodyFrame::GetCellWidth(PRInt32 aRow, nsTreeColumn* aCol,
   1:                               nsIRenderingContext* aRenderingContext,
   1:                               nscoord& aDesiredSize, nscoord& aCurrentSize)
   1: {
   1:   NS_PRECONDITION(aCol, "aCol must not be null");
   1:   NS_PRECONDITION(aRenderingContext, "aRenderingContext must not be null");
   1: 
   1:   // The rect for the current cell.
   1:   nscoord colWidth;
   1:   nsresult rv = aCol->GetWidthInTwips(this, &colWidth);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsRect cellRect(0, 0, colWidth, mRowHeight);
   1: 
   1:   PRInt32 overflow = cellRect.x+cellRect.width-(mInnerBox.x+mInnerBox.width);
   1:   if (overflow > 0)
   1:     cellRect.width -= overflow;
   1: 
   1:   // Adjust borders and padding for the cell.
   1:   nsStyleContext* cellContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecell);
   1:   nsMargin bp(0,0,0,0);
   1:   GetBorderPadding(cellContext, bp);
   1: 
   1:   aCurrentSize = cellRect.width;
   1:   aDesiredSize = bp.left + bp.right;
   1: 
   1:   if (aCol->IsPrimary()) {
   1:     // If the current Column is a Primary, then we need to take into account 
   1:     // the indentation and possibly a twisty. 
   1: 
   1:     // The amount of indentation is the indentation width (|mIndentation|) by the level.
   1:     PRInt32 level;
   1:     mView->GetLevel(aRow, &level);
   1:     aDesiredSize += mIndentation * level;
   1:     
   1:     // Find the twisty rect by computing its size.
   1:     nsStyleContext* twistyContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreetwisty);
   1: 
   1:     nsRect imageSize;
   1:     nsRect twistyRect(cellRect);
 238:     GetTwistyRect(aRow, aCol, imageSize, twistyRect, PresContext(),
   1:                   *aRenderingContext, twistyContext);
   1: 
   1:     // Add in the margins of the twisty element.
   1:     nsMargin twistyMargin;
   1:     twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
   1:     twistyRect.Inflate(twistyMargin);
   1: 
   1:     aDesiredSize += twistyRect.width;
   1:   }
   1: 
   1:   nsStyleContext* imageContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeimage);
   1: 
   1:   // Account for the width of the cell image.
   1:   nsRect imageSize = GetImageSize(aRow, aCol, PR_FALSE, imageContext);
   1:   // Add in the margins of the cell image.
   1:   nsMargin imageMargin;
   1:   imageContext->GetStyleMargin()->GetMargin(imageMargin);
   1:   imageSize.Inflate(imageMargin);
   1: 
   1:   aDesiredSize += imageSize.width;
   1:   
   1:   // Get the cell text.
   1:   nsAutoString cellText;
   1:   mView->GetCellText(aRow, aCol, cellText);
   1:   // We're going to measure this text so we need to ensure bidi is enabled if
   1:   // necessary
   1:   CheckTextForBidi(cellText);
   1: 
   1:   nsStyleContext* textContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecelltext);
   1: 
   1:   // Get the borders and padding for the text.
   1:   GetBorderPadding(textContext, bp);
   1:   
   1:   // Get the font style for the text and pass it to the rendering context.
   1:   aRenderingContext->SetFont(textContext->GetStyleFont()->mFont, nsnull);
   1: 
   1:   // Get the width of the text itself
   1:   nscoord width =
   1:     nsLayoutUtils::GetStringWidth(this, aRenderingContext, cellText.get(), cellText.Length());
   1:   nscoord totalTextWidth = width + bp.left + bp.right;
   1:   aDesiredSize += totalTextWidth;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::IsCellCropped(PRInt32 aRow, nsITreeColumn* aCol, PRBool *_retval)
   1: {  
   1:   nscoord currentSize, desiredSize;
   1:   nsresult rv;
   1: 
   1:   nsRefPtr<nsTreeColumn> col = GetColumnImpl(aCol);
   1:   if (!col)
   1:     return NS_ERROR_INVALID_ARG;
   1: 
   1:   nsCOMPtr<nsIRenderingContext> rc;
 238:   rv = PresContext()->PresShell()->
   1:     CreateRenderingContext(this, getter_AddRefs(rc));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   rv = GetCellWidth(aRow, col, rc, desiredSize, currentSize);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   *_retval = desiredSize > currentSize;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::MarkDirtyIfSelect()
   1: {
   1:   nsIContent* baseElement = GetBaseElement();
   1: 
   1:   if (baseElement && baseElement->Tag() == nsGkAtoms::select &&
   1:       baseElement->IsNodeOfType(nsINode::eHTML)) {
   1:     // If we are an intrinsically sized select widget, we may need to
   1:     // resize, if the widest item was removed or a new item was added.
   1:     // XXX optimize this more
   1: 
   1:     mStringWidth = -1;
1158:     PresContext()->PresShell()->FrameNeedsReflow(this,
1158:                                                  nsIPresShell::eTreeChange,
1158:                                                  NS_FRAME_IS_DIRTY);
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsTreeBodyFrame::CreateTimer(const nsILookAndFeel::nsMetricID aID,
   1:                              nsTimerCallbackFunc aFunc, PRInt32 aType,
   1:                              nsITimer** aTimer)
   1: {
   1:   // Get the delay from the look and feel service.
   1:   PRInt32 delay = 0;
 238:   PresContext()->LookAndFeel()->GetMetric(aID, delay);
   1: 
   1:   nsCOMPtr<nsITimer> timer;
   1: 
   1:   // Create a new timer only if the delay is greater than zero.
   1:   // Zero value means that this feature is completely disabled.
   1:   if (delay > 0) {
   1:     timer = do_CreateInstance("@mozilla.org/timer;1");
   1:     if (timer)
   1:       timer->InitWithFuncCallback(aFunc, this, delay, aType);
   1:   }
   1: 
   1:   NS_IF_ADDREF(*aTimer = timer);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::RowCountChanged(PRInt32 aIndex, PRInt32 aCount)
   1: {
   1:   if (aCount == 0 || !mView)
   1:     return NS_OK; // Nothing to do.
   1: 
   1:   // Adjust our selection.
   1:   nsCOMPtr<nsITreeSelection> sel;
   1:   mView->GetSelection(getter_AddRefs(sel));
   1:   if (sel)
   1:     sel->AdjustSelection(aIndex, aCount);
   1: 
   1:   if (mUpdateBatchNest)
   1:     return NS_OK;
   1: 
   1:   mRowCount += aCount;
   1: #ifdef DEBUG
   1:   PRInt32 rowCount = mRowCount;
   1:   mView->GetRowCount(&rowCount);
   1:   NS_ASSERTION(rowCount == mRowCount, "row count did not change by the amount suggested, check caller");
   1: #endif
   1: 
   1:   PRInt32 count = PR_ABS(aCount);
   1:   PRInt32 last = GetLastVisibleRow();
   1:   if (aIndex >= mTopRowIndex && aIndex <= last)
   1:     InvalidateRange(aIndex, last);
   1:     
   1:   ScrollParts parts = GetScrollParts();
   1: 
   1:   if (mTopRowIndex == 0) {    
   1:     // Just update the scrollbar and return.
   1:     InvalidateScrollbars(parts);
   1:     CheckOverflow(parts);
   1:     MarkDirtyIfSelect();
   1:     return NS_OK;
   1:   }
   1: 
   1:   // Adjust our top row index.
   1:   if (aCount > 0) {
   1:     if (mTopRowIndex > aIndex) {
   1:       // Rows came in above us.  Augment the top row index.
   1:       mTopRowIndex += aCount;
   1:       UpdateScrollbars(parts);
   1:     }
   1:   }
   1:   else if (aCount < 0) {
   1:     if (mTopRowIndex > aIndex+count-1) {
   1:       // No need to invalidate. The remove happened
   1:       // completely above us (offscreen).
   1:       mTopRowIndex -= count;
   1:       UpdateScrollbars(parts);
   1:     }
   1:     else if (mTopRowIndex >= aIndex) {
   1:       // This is a full-blown invalidate.
   1:       if (mTopRowIndex + mPageLength > mRowCount - 1) {
   1:         mTopRowIndex = PR_MAX(0, mRowCount - 1 - mPageLength);
   1:         UpdateScrollbars(parts);
   1:       }
   1:       Invalidate();
   1:     }
   1:   }
   1: 
   1:   InvalidateScrollbars(parts);
   1:   CheckOverflow(parts);
   1:   MarkDirtyIfSelect();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::BeginUpdateBatch()
   1: {
   1:   ++mUpdateBatchNest;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::EndUpdateBatch()
   1: {
   1:   NS_ASSERTION(mUpdateBatchNest > 0, "badly nested update batch");
   1: 
   1:   if (--mUpdateBatchNest == 0) {
   1:     if (mView) {
   1:       Invalidate();
   1:       PRInt32 countBeforeUpdate = mRowCount;
   1:       mView->GetRowCount(&mRowCount);
   1:       if (countBeforeUpdate != mRowCount) {
   1:         ScrollParts parts = GetScrollParts();
   1:         
   1:         if (mTopRowIndex + mPageLength > mRowCount - 1) {
   1:           mTopRowIndex = PR_MAX(0, mRowCount - 1 - mPageLength);
   1:           UpdateScrollbars(parts);
   1:         }
   1:         InvalidateScrollbars(parts);
   1:         CheckOverflow(parts);
   1:       }
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PrefillPropertyArray(PRInt32 aRowIndex, nsTreeColumn* aCol)
   1: {
   1:   NS_PRECONDITION(!aCol || aCol->GetFrame(this), "invalid column passed");
   1:   mScratchArray->Clear();
   1:   
   1:   // focus
   1:   if (mFocused)
   1:     mScratchArray->AppendElement(nsGkAtoms::focus);
   1: 
   1:   // sort
   1:   PRBool sorted = PR_FALSE;
   1:   mView->IsSorted(&sorted);
   1:   if (sorted)
   1:     mScratchArray->AppendElement(nsGkAtoms::sorted);
   1: 
   1:   // drag session
   1:   if (mSlots && mSlots->mDragSession)
   1:     mScratchArray->AppendElement(nsGkAtoms::dragSession);
   1: 
   1:   if (aRowIndex != -1) {
   1:     nsCOMPtr<nsITreeSelection> selection;
   1:     mView->GetSelection(getter_AddRefs(selection));
   1:   
   1:     if (selection) {
   1:       // selected
   1:       PRBool isSelected;
   1:       selection->IsSelected(aRowIndex, &isSelected);
   1:       if (isSelected)
   1:         mScratchArray->AppendElement(nsGkAtoms::selected);
   1: 
   1:       // current
   1:       PRInt32 currentIndex;
   1:       selection->GetCurrentIndex(&currentIndex);
   1:       if (aRowIndex == currentIndex)
   1:         mScratchArray->AppendElement(nsGkAtoms::current);
   1:   
   1:       // active
   1:       if (aCol) {
   1:         nsCOMPtr<nsITreeColumn> currentColumn;
   1:         selection->GetCurrentColumn(getter_AddRefs(currentColumn));
   1:         if (aCol == currentColumn)
   1:           mScratchArray->AppendElement(nsGkAtoms::active);
   1:       }
   1:     }
   1: 
   1:     // container or leaf
   1:     PRBool isContainer = PR_FALSE;
   1:     mView->IsContainer(aRowIndex, &isContainer);
   1:     if (isContainer) {
   1:       mScratchArray->AppendElement(nsGkAtoms::container);
   1: 
   1:       // open or closed
   1:       PRBool isOpen = PR_FALSE;
   1:       mView->IsContainerOpen(aRowIndex, &isOpen);
   1:       if (isOpen)
   1:         mScratchArray->AppendElement(nsGkAtoms::open);
   1:       else
   1:         mScratchArray->AppendElement(nsGkAtoms::closed);
   1:     }
   1:     else {
   1:       mScratchArray->AppendElement(nsGkAtoms::leaf);
   1:     }
   1: 
   1:     // drop orientation
   1:     if (mSlots && mSlots->mDropAllowed && mSlots->mDropRow == aRowIndex) {
   1:       if (mSlots->mDropOrient == nsITreeView::DROP_BEFORE)
   1:         mScratchArray->AppendElement(nsGkAtoms::dropBefore);
   1:       else if (mSlots->mDropOrient == nsITreeView::DROP_ON)
   1:         mScratchArray->AppendElement(nsGkAtoms::dropOn);
   1:       else if (mSlots->mDropOrient == nsITreeView::DROP_AFTER)
   1:         mScratchArray->AppendElement(nsGkAtoms::dropAfter);
   1:     }
   1: 
   1:     // odd or even
   1:     if (aRowIndex % 2)
   1:       mScratchArray->AppendElement(nsGkAtoms::odd);
   1:     else
   1:       mScratchArray->AppendElement(nsGkAtoms::even);
   1: 
   1:     nsIContent* baseContent = GetBaseElement();
   1:     if (baseContent && baseContent->HasAttr(kNameSpaceID_None, nsGkAtoms::editing))
   1:       mScratchArray->AppendElement(nsGkAtoms::editing);
   1:   }
   1: 
   1:   if (aCol) {
   1:     mScratchArray->AppendElement(aCol->GetAtom());
   1: 
   1:     if (aCol->IsPrimary())
   1:       mScratchArray->AppendElement(nsGkAtoms::primary);
   1: 
   1:     if (aCol->GetType() == nsITreeColumn::TYPE_CHECKBOX) {
   1:       mScratchArray->AppendElement(nsGkAtoms::checkbox);
   1: 
   1:       if (aRowIndex != -1) {
   1:         nsAutoString value;
   1:         mView->GetCellValue(aRowIndex, aCol, value);
   1:         if (value.EqualsLiteral("true"))
   1:           mScratchArray->AppendElement(nsGkAtoms::checked);
   1:       }
   1:     }
   1:     else if (aCol->GetType() == nsITreeColumn::TYPE_PROGRESSMETER) {
   1:       mScratchArray->AppendElement(nsGkAtoms::progressmeter);
   1: 
   1:       if (aRowIndex != -1) {
   1:         PRInt32 state;
   1:         mView->GetProgressMode(aRowIndex, aCol, &state);
   1:         if (state == nsITreeView::PROGRESS_NORMAL)
   1:           mScratchArray->AppendElement(nsGkAtoms::progressNormal);
   1:         else if (state == nsITreeView::PROGRESS_UNDETERMINED)
   1:           mScratchArray->AppendElement(nsGkAtoms::progressUndetermined);
   1:       }
   1:     }
   1: 
   1:     // Read special properties from attributes on the column content node
   1:     if (aCol->mContent->AttrValueIs(kNameSpaceID_None,
   1:                                     nsGkAtoms::insertbefore,
   1:                                     nsGkAtoms::_true, eCaseMatters))
   1:       mScratchArray->AppendElement(nsGkAtoms::insertbefore);
   1:     if (aCol->mContent->AttrValueIs(kNameSpaceID_None,
   1:                                     nsGkAtoms::insertafter,
   1:                                     nsGkAtoms::_true, eCaseMatters))
   1:       mScratchArray->AppendElement(nsGkAtoms::insertafter);
   1:   }
   1: }
   1: 
   1: nsITheme*
   1: nsTreeBodyFrame::GetTwistyRect(PRInt32 aRowIndex,
   1:                                nsTreeColumn* aColumn,
   1:                                nsRect& aImageRect,
   1:                                nsRect& aTwistyRect,
   1:                                nsPresContext* aPresContext,
   1:                                nsIRenderingContext& aRenderingContext,
   1:                                nsStyleContext* aTwistyContext)
   1: {
   1:   // The twisty rect extends all the way to the end of the cell.  This is incorrect.  We need to
   1:   // determine the twisty rect's true width.  This is done by examining the style context for
   1:   // a width first.  If it has one, we use that.  If it doesn't, we use the image's natural width.
   1:   // If the image hasn't loaded and if no width is specified, then we just bail. If there is
   1:   // a -moz-appearance involved, adjust the rect by the minimum widget size provided by
   1:   // the theme implementation.
   1:   aImageRect = GetImageSize(aRowIndex, aColumn, PR_TRUE, aTwistyContext);
   1:   if (aImageRect.height > aTwistyRect.height)
   1:     aImageRect.height = aTwistyRect.height;
   1:   if (aImageRect.width > aTwistyRect.width)
   1:     aImageRect.width = aTwistyRect.width;
   1:   else
   1:     aTwistyRect.width = aImageRect.width;
   1: 
   1:   PRBool useTheme = PR_FALSE;
   1:   nsITheme *theme = nsnull;
   1:   const nsStyleDisplay* twistyDisplayData = aTwistyContext->GetStyleDisplay();
   1:   if (twistyDisplayData->mAppearance) {
   1:     theme = aPresContext->GetTheme();
   1:     if (theme && theme->ThemeSupportsWidget(aPresContext, nsnull, twistyDisplayData->mAppearance))
   1:       useTheme = PR_TRUE;
   1:   }
   1: 
   1:   if (useTheme) {
   1:     nsSize minTwistySize(0,0);
   1:     PRBool canOverride = PR_TRUE;
   1:     theme->GetMinimumWidgetSize(&aRenderingContext, this, twistyDisplayData->mAppearance,
   1:                                 &minTwistySize, &canOverride);
   1: 
   1:     // GMWS() returns size in pixels, we need to convert it back to twips
   1:     minTwistySize.width = aPresContext->DevPixelsToAppUnits(minTwistySize.width);
   1:     minTwistySize.height = aPresContext->DevPixelsToAppUnits(minTwistySize.height);
   1: 
   1:     if (aTwistyRect.width < minTwistySize.width || !canOverride)
   1:       aTwistyRect.width = minTwistySize.width;
   1:   }
   1: 
   1:   return useTheme ? theme : nsnull;
   1: }
   1: 
   1: nsresult
   1: nsTreeBodyFrame::GetImage(PRInt32 aRowIndex, nsTreeColumn* aCol, PRBool aUseContext,
   1:                           nsStyleContext* aStyleContext, PRBool& aAllowImageRegions, imgIContainer** aResult)
   1: {
   1:   *aResult = nsnull;
   1: 
   1:   nsAutoString imageSrc;
   1:   mView->GetImageSrc(aRowIndex, aCol, imageSrc);
   1:   nsCOMPtr<imgIRequest> styleRequest;
   1:   if (!aUseContext && !imageSrc.IsEmpty()) {
   1:     aAllowImageRegions = PR_FALSE;
   1:   }
   1:   else {
   1:     // Obtain the URL from the style context.
   1:     aAllowImageRegions = PR_TRUE;
   1:     styleRequest = aStyleContext->GetStyleList()->mListStyleImage;
   1:     if (!styleRequest)
   1:       return NS_OK;
   1:     nsCOMPtr<nsIURI> uri;
   1:     styleRequest->GetURI(getter_AddRefs(uri));
   1:     nsCAutoString spec;
   1:     uri->GetSpec(spec);
   1:     CopyUTF8toUTF16(spec, imageSrc);
   1:   }
   1: 
   1:   // Look the image up in our cache.
   1:   nsTreeImageCacheEntry entry;
   1:   if (mImageCache.Get(imageSrc, &entry)) {
   1:     // Find out if the image has loaded.
   1:     PRUint32 status;
   1:     imgIRequest *imgReq = entry.request;
   1:     imgReq->GetImageStatus(&status);
   1:     imgReq->GetImage(aResult); // We hand back the image here.  The GetImage call addrefs *aResult.
   1:     PRUint32 numFrames = 1;
   1:     if (*aResult)
   1:       (*aResult)->GetNumFrames(&numFrames);
   1: 
   1:     if ((!(status & imgIRequest::STATUS_LOAD_COMPLETE)) || numFrames > 1) {
   1:       // We either aren't done loading, or we're animating. Add our row as a listener for invalidations.
   1:       nsCOMPtr<imgIDecoderObserver> obs;
   1:       imgReq->GetDecoderObserver(getter_AddRefs(obs));
   1:       nsCOMPtr<nsITreeImageListener> listener(do_QueryInterface(obs));
   1:       if (listener)
   1:         listener->AddCell(aRowIndex, aCol);
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   if (!*aResult) {
   1:     // Create a new nsTreeImageListener object and pass it our row and column
   1:     // information.
   1:     nsTreeImageListener* listener = new nsTreeImageListener(mTreeBoxObject);
   1:     if (!listener)
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:     listener->AddCell(aRowIndex, aCol);
   1:     nsCOMPtr<imgIDecoderObserver> imgDecoderObserver = listener;
   1: 
   1:     nsCOMPtr<imgIRequest> imageRequest;
   1:     if (styleRequest) {
   1:       styleRequest->Clone(imgDecoderObserver, getter_AddRefs(imageRequest));
   1:     } else {
   1:       nsIDocument* doc = mContent->GetDocument();
   1:       if (!doc)
   1:         // The page is currently being torn down.  Why bother.
   1:         return NS_ERROR_FAILURE;
   1: 
   1:       nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
   1: 
   1:       nsCOMPtr<nsIURI> srcURI;
   1:       nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(srcURI),
   1:                                                 imageSrc,
   1:                                                 doc,
   1:                                                 baseURI);
   1:       if (!srcURI)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:       if (nsContentUtils::CanLoadImage(srcURI, mContent, doc)) {
   1:         nsresult rv = nsContentUtils::LoadImage(srcURI,
   1:                                                 doc,
   1:                                                 doc->GetDocumentURI(),
   1:                                                 imgDecoderObserver,
   1:                                                 nsIRequest::LOAD_NORMAL,
   1:                                                 getter_AddRefs(imageRequest));
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:                                   
   1:       }
   1:     }
   1:     listener->UnsuppressInvalidation();
   1: 
   1:     if (!imageRequest)
   1:       return NS_ERROR_FAILURE;
   1: 
   1:     // In a case it was already cached.
   1:     imageRequest->GetImage(aResult);
   1:     nsTreeImageCacheEntry cacheEntry(imageRequest, imgDecoderObserver);
   1:     mImageCache.Put(imageSrc, cacheEntry);
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: nsRect nsTreeBodyFrame::GetImageSize(PRInt32 aRowIndex, nsTreeColumn* aCol, PRBool aUseContext,
   1:                                      nsStyleContext* aStyleContext)
   1: {
   1:   // XXX We should respond to visibility rules for collapsed vs. hidden.
   1: 
   1:   // This method returns the width of the twisty INCLUDING borders and padding.
   1:   // It first checks the style context for a width.  If none is found, it tries to
   1:   // use the default image width for the twisty.  If no image is found, it defaults
   1:   // to border+padding.
   1:   nsRect r(0,0,0,0);
   1:   nsMargin bp(0,0,0,0);
   1:   GetBorderPadding(aStyleContext, bp);
   1:   r.Inflate(bp);
   1: 
   1:   // Now r contains our border+padding info.  We now need to get our width and
   1:   // height.
   1:   PRBool needWidth = PR_FALSE;
   1:   PRBool needHeight = PR_FALSE;
   1: 
   1:   // We have to load image even though we already have a size.
   1:   // Don't change this, otherwise things start to go crazy.
   1:   PRBool useImageRegion = PR_TRUE;
   1:   nsCOMPtr<imgIContainer> image;
   1:   GetImage(aRowIndex, aCol, aUseContext, aStyleContext, useImageRegion, getter_AddRefs(image));
   1: 
   1:   const nsStylePosition* myPosition = aStyleContext->GetStylePosition();
   1:   const nsStyleList* myList = aStyleContext->GetStyleList();
   1: 
   1:   if (useImageRegion) {
   1:     r.x += myList->mImageRegion.x;
   1:     r.y += myList->mImageRegion.y;
   1:   }
   1: 
   1:   if (myPosition->mWidth.GetUnit() == eStyleUnit_Coord)  {
   1:     PRInt32 val = myPosition->mWidth.GetCoordValue();
   1:     r.width += val;
   1:   }
   1:   else if (useImageRegion && myList->mImageRegion.width > 0)
   1:     r.width += myList->mImageRegion.width;
   1:   else 
   1:     needWidth = PR_TRUE;
   1: 
   1:   if (myPosition->mHeight.GetUnit() == eStyleUnit_Coord)  {
   1:     PRInt32 val = myPosition->mHeight.GetCoordValue();
   1:     r.height += val;
   1:   }
   1:   else if (useImageRegion && myList->mImageRegion.height > 0)
   1:     r.height += myList->mImageRegion.height;
   1:   else 
   1:     needHeight = PR_TRUE;
   1: 
   1:   if (image) {
   1:     if (needWidth || needHeight) {
   1:       // Get the natural image size.
   1: 
   1:       if (needWidth) {
   1:         // Get the size from the image.
   1:         nscoord width;
   1:         image->GetWidth(&width);
   1:         r.width += nsPresContext::CSSPixelsToAppUnits(width); 
   1:       }
   1:     
   1:       if (needHeight) {
   1:         nscoord height;
   1:         image->GetHeight(&height);
   1:         r.height += nsPresContext::CSSPixelsToAppUnits(height); 
   1:       }
   1:     }
   1:   }
   1: 
   1:   return r;
   1: }
   1: 
   1: // GetImageDestSize returns the destination size of the image.
   1: // The width and height do not include borders and padding.
   1: // The width and height have not been adjusted to fit in the row height
   1: // or cell width.
   1: // The width and height reflect the destination size specified in CSS,
   1: // or the image region specified in CSS, or the natural size of the
   1: // image.
   1: // If only the destination width has been specified in CSS, the height is
   1: // calculated to maintain the aspect ratio of the image.
   1: // If only the destination height has been specified in CSS, the width is
   1: // calculated to maintain the aspect ratio of the image.
   1: nsSize
   1: nsTreeBodyFrame::GetImageDestSize(nsStyleContext* aStyleContext,
   1:                                   PRBool useImageRegion,
   1:                                   imgIContainer* image)
   1: {
   1:   nsSize size(0,0);
   1: 
   1:   // We need to get the width and height.
   1:   PRBool needWidth = PR_FALSE;
   1:   PRBool needHeight = PR_FALSE;
   1: 
   1:   // Get the style position to see if the CSS has specified the
   1:   // destination width/height.
   1:   const nsStylePosition* myPosition = aStyleContext->GetStylePosition();
   1: 
   1:   if (myPosition->mWidth.GetUnit() == eStyleUnit_Coord) {
   1:     // CSS has specified the destination width.
   1:     size.width = myPosition->mWidth.GetCoordValue();
   1:   }
   1:   else {
   1:     // We'll need to get the width of the image/region.
   1:     needWidth = PR_TRUE;
   1:   }
   1: 
   1:   if (myPosition->mHeight.GetUnit() == eStyleUnit_Coord)  {
   1:     // CSS has specified the destination height.
   1:     size.height = myPosition->mHeight.GetCoordValue();
   1:   }
   1:   else {
   1:     // We'll need to get the height of the image/region.
   1:     needHeight = PR_TRUE;
   1:   }
   1: 
   1:   if (needWidth || needHeight) {
   1:     // We need to get the size of the image/region.
   1:     nsSize imageSize(0,0);
   1: 
   1:     const nsStyleList* myList = aStyleContext->GetStyleList();
   1: 
   1:     if (useImageRegion && myList->mImageRegion.width > 0) {
   1:       // CSS has specified an image region.
   1:       // Use the width of the image region.
   1:       imageSize.width = myList->mImageRegion.width;
   1:     }
   1:     else if (image) {
   1:       nscoord width;
   1:       image->GetWidth(&width);
   1:       imageSize.width = nsPresContext::CSSPixelsToAppUnits(width);
   1:     }
   1: 
   1:     if (useImageRegion && myList->mImageRegion.height > 0) {
   1:       // CSS has specified an image region.
   1:       // Use the height of the image region.
   1:       imageSize.height = myList->mImageRegion.height;
   1:     }
   1:     else if (image) {
   1:       nscoord height;
   1:       image->GetHeight(&height);
   1:       imageSize.height = nsPresContext::CSSPixelsToAppUnits(height);
   1:     }
   1: 
   1:     if (needWidth) {
   1:       if (!needHeight && imageSize.height != 0) {
   1:         // The CSS specified the destination height, but not the destination
   1:         // width. We need to calculate the width so that we maintain the
   1:         // image's aspect ratio.
   1:         size.width = imageSize.width * size.height / imageSize.height;
   1:       }
   1:       else {
   1:         size.width = imageSize.width;
   1:       }
   1:     }
   1: 
   1:     if (needHeight) {
   1:       if (!needWidth && imageSize.width != 0) {
   1:         // The CSS specified the destination width, but not the destination
   1:         // height. We need to calculate the height so that we maintain the
   1:         // image's aspect ratio.
   1:         size.height = imageSize.height * size.width / imageSize.width;
   1:       }
   1:       else {
   1:         size.height = imageSize.height;
   1:       }
   1:     }
   1:   }
   1: 
   1:   return size;
   1: }
   1: 
   1: // GetImageSourceRect returns the source rectangle of the image to be
   1: // displayed.
   1: // The width and height reflect the image region specified in CSS, or
   1: // the natural size of the image.
   1: // The width and height do not include borders and padding.
   1: // The width and height do not reflect the destination size specified
   1: // in CSS.
   1: nsRect
   1: nsTreeBodyFrame::GetImageSourceRect(nsStyleContext* aStyleContext,
   1:                                     PRBool useImageRegion,
   1:                                     imgIContainer* image)
   1: {
   1:   nsRect r(0,0,0,0);
   1: 
   1:   const nsStyleList* myList = aStyleContext->GetStyleList();
   1: 
   1:   if (useImageRegion &&
   1:       (myList->mImageRegion.width > 0 || myList->mImageRegion.height > 0)) {
   1:     // CSS has specified an image region.
   1:     r = myList->mImageRegion;
   1:   }
   1:   else if (image) {
   1:     // Use the actual image size.
   1:     nscoord coord;
   1:     image->GetWidth(&coord);
   1:     r.width = nsPresContext::CSSPixelsToAppUnits(coord);
   1:     image->GetHeight(&coord);
   1:     r.height = nsPresContext::CSSPixelsToAppUnits(coord);
   1:   }
   1: 
   1:   return r;
   1: }
   1: 
   1: PRInt32 nsTreeBodyFrame::GetRowHeight()
   1: {
   1:   // Look up the correct height.  It is equal to the specified height
   1:   // + the specified margins.
   1:   mScratchArray->Clear();
   1:   nsStyleContext* rowContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreerow);
   1:   if (rowContext) {
   1:     const nsStylePosition* myPosition = rowContext->GetStylePosition();
   1: 
   1:     nscoord minHeight = 0;
   1:     if (myPosition->mMinHeight.GetUnit() == eStyleUnit_Coord)
   1:       minHeight = myPosition->mMinHeight.GetCoordValue();
   1: 
   1:     nscoord height = 0;
   1:     if (myPosition->mHeight.GetUnit() == eStyleUnit_Coord)
   1:       height = myPosition->mHeight.GetCoordValue();
   1: 
   1:     if (height < minHeight)
   1:       height = minHeight;
   1: 
   1:     if (height > 0) {
   1:       height = nsPresContext::AppUnitsToIntCSSPixels(height);
   1:       height += height % 2;
   1:       height = nsPresContext::CSSPixelsToAppUnits(height);
   1: 
   1:       // XXX Check box-sizing to determine if border/padding should augment the height
   1:       // Inflate the height by our margins.
   1:       nsRect rowRect(0,0,0,height);
   1:       nsMargin rowMargin;
   1:       rowContext->GetStyleMargin()->GetMargin(rowMargin);
   1:       rowRect.Inflate(rowMargin);
   1:       height = rowRect.height;
   1:       return height;
   1:     }
   1:   }
   1: 
   1:   return nsPresContext::CSSPixelsToAppUnits(18); // As good a default as any.
   1: }
   1: 
   1: PRInt32 nsTreeBodyFrame::GetIndentation()
   1: {
   1:   // Look up the correct indentation.  It is equal to the specified indentation width.
   1:   mScratchArray->Clear();
   1:   nsStyleContext* indentContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeindentation);
   1:   if (indentContext) {
   1:     const nsStylePosition* myPosition = indentContext->GetStylePosition();
   1:     if (myPosition->mWidth.GetUnit() == eStyleUnit_Coord)  {
   1:       nscoord val = myPosition->mWidth.GetCoordValue();
   1:       return val;
   1:     }
   1:   }
   1: 
   1:   return nsPresContext::CSSPixelsToAppUnits(16); // As good a default as any.
   1: }
   1: 
   1: void nsTreeBodyFrame::CalcInnerBox()
   1: {
   1:   mInnerBox.SetRect(0, 0, mRect.width, mRect.height);
   1:   AdjustForBorderPadding(mStyleContext, mInnerBox);
   1: }
   1: 
   1: nscoord
   1: nsTreeBodyFrame::CalcHorzWidth(const ScrollParts& aParts)
   1: {
   1:   nscoord width = 0;
   1:   nscoord height;
   1: 
   1:   // We calculate this from the scrollable view, so that it 
   1:   // properly covers all contingencies of what could be 
   1:   // scrollable (columns, body, etc...)
   1: 
   1:   if (aParts.mColumnsScrollableView) {
   1:     if (NS_FAILED (aParts.mColumnsScrollableView->GetContainerSize(&width, &height)))
   1:       width = 0;
   1:   }
   1: 
   1:   // If no horz scrolling periphery is present, then just
   1:   // return the width of the main box
   1:   if (width == 0) {
   1:     CalcInnerBox();
   1:     width = mInnerBox.width;
   1:   }
   1: 
   1:   return width;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::GetCursor(const nsPoint& aPoint,
   1:                            nsIFrame::Cursor& aCursor)
   1: {
   1:   if (mView) {
   1:     PRInt32 row;
   1:     nsTreeColumn* col;
   1:     nsIAtom* child;
   1:     GetCellAt(aPoint.x, aPoint.y, &row, &col, &child);
   1: 
   1:     if (child) {
   1:       // Our scratch array is already prefilled.
   1:       nsStyleContext* childContext = GetPseudoStyleContext(child);
   1: 
   1:       FillCursorInformationFromStyle(childContext->GetStyleUserInterface(),
   1:                                      aCursor);
   1:       if (aCursor.mCursor == NS_STYLE_CURSOR_AUTO)
   1:         aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
   1: 
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   return nsLeafBoxFrame::GetCursor(aPoint, aCursor);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::HandleEvent(nsPresContext* aPresContext,
   1:                              nsGUIEvent* aEvent,
   1:                              nsEventStatus* aEventStatus)
   1: {
   1:   if (aEvent->message == NS_DRAGDROP_ENTER) {
   1:     if (!mSlots)
   1:       mSlots = new Slots();
   1: 
   1:     // Cache several things we'll need throughout the course of our work. These
   1:     // will all get released on a drag exit.
   1: 
   1:     if (mSlots->mTimer) {
   1:       mSlots->mTimer->Cancel();
   1:       mSlots->mTimer = nsnull;
   1:     }
   1: 
   1:     // Cache the drag session.
   1:     nsCOMPtr<nsIDragService> dragService = 
   1:              do_GetService("@mozilla.org/widget/dragservice;1");
   1:     dragService->GetCurrentSession(getter_AddRefs(mSlots->mDragSession));
   1:     NS_ASSERTION(mSlots->mDragSession, "can't get drag session");
   1: 
   1:     if (mSlots->mDragSession)
   1:       mSlots->mDragSession->GetDragAction(&mSlots->mDragAction);
   1:     else
   1:       mSlots->mDragAction = 0;
   1:   }
   1:   else if (aEvent->message == NS_DRAGDROP_OVER) {
   1:     // The mouse is hovering over this tree. If we determine things are
   1:     // different from the last time, invalidate the drop feedback at the old
   1:     // position, query the view to see if the current location is droppable,
   1:     // and then invalidate the drop feedback at the new location if it is.
   1:     // The mouse may or may not have changed position from the last time
   1:     // we were called, so optimize out a lot of the extra notifications by
   1:     // checking if anything changed first. For drop feedback we use drop,
   1:     // dropBefore and dropAfter property.
   1: 
   1:     if (!mView || !mSlots)
   1:       return NS_OK;
   1: 
   1:     // Save last values, we will need them.
   1:     PRInt32 lastDropRow = mSlots->mDropRow;
   1:     PRInt16 lastDropOrient = mSlots->mDropOrient;
   1:     PRInt16 lastScrollLines = mSlots->mScrollLines;
   1: 
   1:     // Find out the current drag action
   1:     PRUint32 lastDragAction = mSlots->mDragAction;
   1:     if (mSlots->mDragSession)
   1:       mSlots->mDragSession->GetDragAction(&mSlots->mDragAction);
   1: 
   1:     // Compute the row mouse is over and the above/below/on state.
   1:     // Below we'll use this to see if anything changed.
   1:     // Also check if we want to auto-scroll.
   1:     ComputeDropPosition(aEvent, &mSlots->mDropRow, &mSlots->mDropOrient, &mSlots->mScrollLines);
   1: 
   1:     // While we're here, handle tracking of scrolling during a drag.
   1:     if (mSlots->mScrollLines) {
   1:       if (mSlots->mDropAllowed) {
   1:         // Invalidate primary cell at old location.
   1:         mSlots->mDropAllowed = PR_FALSE;
   1:         InvalidateDropFeedback(lastDropRow, lastDropOrient);
   1:       }
   1: #if !defined(XP_MACOSX)
   1:       if (!lastScrollLines) {
   1:         // Cancel any previously initialized timer.
   1:         if (mSlots->mTimer) {
   1:           mSlots->mTimer->Cancel();
   1:           mSlots->mTimer = nsnull;
   1:         }
   1: 
   1:         // Set a timer to trigger the tree scrolling.
   1:         CreateTimer(nsILookAndFeel::eMetric_TreeLazyScrollDelay,
   1:                     LazyScrollCallback, nsITimer::TYPE_ONE_SHOT,
   1:                     getter_AddRefs(mSlots->mTimer));
   1:        }
   1: #else
   1:       ScrollByLines(mSlots->mScrollLines);
   1: #endif
   1:       // Bail out to prevent spring loaded timer and feedback line settings.
   1:       return NS_OK;
   1:     }
   1: 
   1:     // If changed from last time, invalidate primary cell at the old location and if allowed, 
   1:     // invalidate primary cell at the new location. If nothing changed, just bail.
   1:     if (mSlots->mDropRow != lastDropRow ||
   1:         mSlots->mDropOrient != lastDropOrient ||
   1:         mSlots->mDragAction != lastDragAction) {
   1: 
   1:       // Invalidate row at the old location.
   1:       if (mSlots->mDropAllowed) {
   1:         mSlots->mDropAllowed = PR_FALSE;
   1:         InvalidateDropFeedback(lastDropRow, lastDropOrient);
   1:       }
   1: 
   1:       if (mSlots->mTimer) {
   1:         // Timer is active but for a different row than the current one, kill it.
   1:         mSlots->mTimer->Cancel();
   1:         mSlots->mTimer = nsnull;
   1:       }
   1: 
   1:       if (mSlots->mDropRow >= 0) {
   1:         if (!mSlots->mTimer && mSlots->mDropOrient == nsITreeView::DROP_ON) {
   1:           // Either there wasn't a timer running or it was just killed above.
   1:           // If over a folder, start up a timer to open the folder.
   1:           PRBool isContainer = PR_FALSE;
   1:           mView->IsContainer(mSlots->mDropRow, &isContainer);
   1:           if (isContainer) {
   1:             PRBool isOpen = PR_FALSE;
   1:             mView->IsContainerOpen(mSlots->mDropRow, &isOpen);
   1:             if (!isOpen) {
   1:               // This node isn't expanded, set a timer to expand it.
   1:               CreateTimer(nsILookAndFeel::eMetric_TreeOpenDelay,
   1:                           OpenCallback, nsITimer::TYPE_ONE_SHOT,
   1:                           getter_AddRefs(mSlots->mTimer));
   1:             }
   1:           }
   1:         }
   1: 
   1:         PRBool canDropAtNewLocation = PR_FALSE;
   1:         mView->CanDrop(mSlots->mDropRow, mSlots->mDropOrient, &canDropAtNewLocation);
   1:       
   1:         if (canDropAtNewLocation) {
   1:           // Invalidate row at the new location.
   1:           mSlots->mDropAllowed = canDropAtNewLocation;
   1:           InvalidateDropFeedback(mSlots->mDropRow, mSlots->mDropOrient);
   1:         }
   1:       }
   1:     }
   1: 
   1:     // Alert the drag session we accept the drop. We have to do this every time
   1:     // since the |canDrop| attribute is reset before we're called.
   1:     if (mSlots->mDropAllowed && mSlots->mDragSession)
   1:       mSlots->mDragSession->SetCanDrop(PR_TRUE);
   1:   }
   1:   else if (aEvent->message == NS_DRAGDROP_DROP) {
   1:      // this event was meant for another frame, so ignore it
   1:      if (!mSlots)
   1:        return NS_OK;
   1: 
   1:     // Tell the view where the drop happened.
   1: 
   1:     // Remove the drop folder and all its parents from the array.
   1:     PRInt32 parentIndex;
   1:     nsresult rv = mView->GetParentIndex(mSlots->mDropRow, &parentIndex);
   1:     while (NS_SUCCEEDED(rv) && parentIndex >= 0) {
   1:       mSlots->mValueArray.RemoveValue(parentIndex);
   1:       rv = mView->GetParentIndex(parentIndex, &parentIndex);
   1:     }
   1: 
   1:     mView->Drop(mSlots->mDropRow, mSlots->mDropOrient);
   1:   }
   1:   else if (aEvent->message == NS_DRAGDROP_EXIT) {
   1:     // this event was meant for another frame, so ignore it
   1:     if (!mSlots)
   1:       return NS_OK;
   1: 
   1:     // Clear out all our tracking vars.
   1: 
   1:     if (mSlots->mDropAllowed) {
   1:       mSlots->mDropAllowed = PR_FALSE;
   1:       InvalidateDropFeedback(mSlots->mDropRow, mSlots->mDropOrient);
   1:     }
   1:     else
   1:       mSlots->mDropAllowed = PR_FALSE;
   1:     mSlots->mDropRow = -1;
   1:     mSlots->mDropOrient = -1;
   1:     mSlots->mDragSession = nsnull;
   1:     mSlots->mScrollLines = 0;
   1: 
   1:     if (mSlots->mTimer) {
   1:       mSlots->mTimer->Cancel();
   1:       mSlots->mTimer = nsnull;
   1:     }
   1: 
   1:     if (mSlots->mValueArray.Count()) {
   1:       // Close all spring loaded folders except the drop folder.
   1:       CreateTimer(nsILookAndFeel::eMetric_TreeCloseDelay,
   1:                   CloseCallback, nsITimer::TYPE_ONE_SHOT,
   1:                   getter_AddRefs(mSlots->mTimer));
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: nsLineStyle nsTreeBodyFrame::ConvertBorderStyleToLineStyle(PRUint8 aBorderStyle)
   1: {
   1:   switch (aBorderStyle) {
   1:     case NS_STYLE_BORDER_STYLE_DOTTED:
   1:       return nsLineStyle_kDotted;
   1:     case NS_STYLE_BORDER_STYLE_DASHED:
   1:       return nsLineStyle_kDashed;
   1:     default:
   1:       return nsLineStyle_kSolid;
   1:   }
   1: }
   1: 
   1: static void
   1: PaintTreeBody(nsIFrame* aFrame, nsIRenderingContext* aCtx,
   1:               const nsRect& aDirtyRect, nsPoint aPt)
   1: {
   1:   NS_STATIC_CAST(nsTreeBodyFrame*, aFrame)->PaintTreeBody(*aCtx, aDirtyRect, aPt);
   1: }
   1: 
   1: // Painting routines
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                                   const nsRect&           aDirtyRect,
   1:                                   const nsDisplayListSet& aLists)
   1: {
   1:   // REVIEW: why did we paint if we were collapsed? that makes no sense!
   1:   if (!IsVisibleForPainting(aBuilder))
   1:     return NS_OK; // We're invisible.  Don't paint.
   1: 
   1:   // Handles painting our background, border, and outline.
   1:   nsresult rv = nsLeafBoxFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   if (!mView)
   1:     return NS_OK;
   1: 
   1:   return aLists.Content()->AppendNewToTop(new (aBuilder)
   1:       nsDisplayGeneric(this, ::PaintTreeBody, "XULTreeBody"));
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintTreeBody(nsIRenderingContext& aRenderingContext,
   1:                                const nsRect& aDirtyRect, nsPoint aPt)
   1: {
   1:   // Update our available height and our page count.
   1:   CalcInnerBox();
   1:   aRenderingContext.PushState();
   1:   aRenderingContext.SetClipRect(mInnerBox + aPt, nsClipCombine_kIntersect);
   1:   PRInt32 oldPageCount = mPageLength;
   1:   if (!mHasFixedRowCount)
   1:     mPageLength = mInnerBox.height/mRowHeight;
   1: 
   1:   if (oldPageCount != mPageLength || mHorzWidth != CalcHorzWidth(GetScrollParts())) {
   1:     // Schedule a ResizeReflow that will update our info properly.
 238:     PresContext()->PresShell()->
1158:       FrameNeedsReflow(this, nsIPresShell::eResize, NS_FRAME_IS_DIRTY);
   1:   }
   1:   #ifdef DEBUG
   1:   PRInt32 rowCount = mRowCount;
   1:   mView->GetRowCount(&mRowCount);
   1:   NS_ASSERTION(mRowCount == rowCount, "row count changed unexpectedly");
   1:   #endif
   1: 
   1:   // Loop through our columns and paint them (e.g., for sorting).  This is only
   1:   // relevant when painting backgrounds, since columns contain no content.  Content
   1:   // is contained in the rows.
   1:   for (nsTreeColumn* currCol = mColumns->GetFirstColumn(); currCol;
   1:        currCol = currCol->GetNext()) {
   1:     nsRect colRect;
   1:     nsresult rv = currCol->GetRect(this, mInnerBox.y, mInnerBox.height,
   1:                                    &colRect);
   1:     // Don't paint hidden columns.
   1:     if (NS_FAILED(rv) || colRect.width == 0) continue;
   1: 
   1:     if (OffsetForHorzScroll(colRect, PR_FALSE)) {
   1:       nsRect dirtyRect;
   1:       colRect += aPt;
   1:       if (dirtyRect.IntersectRect(aDirtyRect, colRect)) {
 238:         PaintColumn(currCol, colRect, PresContext(), aRenderingContext, aDirtyRect);
   1:       }
   1:     }
   1:   }
   1:   // Loop through our on-screen rows.
   1:   for (PRInt32 i = mTopRowIndex; i < mRowCount && i <= mTopRowIndex+mPageLength; i++) {
   1:     nsRect rowRect(mInnerBox.x, mInnerBox.y+mRowHeight*(i-mTopRowIndex), mInnerBox.width, mRowHeight);
   1:     nsRect dirtyRect;
   1:     if (dirtyRect.IntersectRect(aDirtyRect, rowRect + aPt) &&
   1:         rowRect.y < (mInnerBox.y+mInnerBox.height)) {
 238:       PaintRow(i, rowRect + aPt, PresContext(), aRenderingContext, aDirtyRect, aPt);
   1:     }
   1:   }
   1: 
   1:   if (mSlots && mSlots->mDropAllowed && (mSlots->mDropOrient == nsITreeView::DROP_BEFORE ||
   1:       mSlots->mDropOrient == nsITreeView::DROP_AFTER)) {
   1:     nscoord yPos = mInnerBox.y + mRowHeight * (mSlots->mDropRow - mTopRowIndex) - mRowHeight / 2;
   1:     nsRect feedbackRect(mInnerBox.x, yPos, mInnerBox.width, mRowHeight);
   1:     if (mSlots->mDropOrient == nsITreeView::DROP_AFTER)
   1:       feedbackRect.y += mRowHeight;
   1: 
   1:     nsRect dirtyRect;
   1:     feedbackRect += aPt;
   1:     if (dirtyRect.IntersectRect(aDirtyRect, feedbackRect)) {
 238:       PaintDropFeedback(feedbackRect, PresContext(), aRenderingContext, aDirtyRect);
   1:     }
   1:   }
   1:   aRenderingContext.PopState();
   1: }
   1: 
   1: 
   1: 
   1: void
   1: nsTreeBodyFrame::PaintColumn(nsTreeColumn*        aColumn,
   1:                              const nsRect&        aColumnRect,
   1:                              nsPresContext*      aPresContext,
   1:                              nsIRenderingContext& aRenderingContext,
   1:                              const nsRect&        aDirtyRect)
   1: {
   1:   NS_PRECONDITION(aColumn && aColumn->GetFrame(this), "invalid column passed");
   1: 
   1:   // Now obtain the properties for our cell.
   1:   PrefillPropertyArray(-1, aColumn);
   1:   mView->GetColumnProperties(aColumn, mScratchArray);
   1: 
   1:   // Resolve style for the column.  It contains all the info we need to lay ourselves
   1:   // out and to paint.
   1:   nsStyleContext* colContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecolumn);
   1: 
   1:   // Obtain the margins for the cell and then deflate our rect by that 
   1:   // amount.  The cell is assumed to be contained within the deflated rect.
   1:   nsRect colRect(aColumnRect);
   1:   nsMargin colMargin;
   1:   colContext->GetStyleMargin()->GetMargin(colMargin);
   1:   colRect.Deflate(colMargin);
   1: 
   1:   PaintBackgroundLayer(colContext, aPresContext, aRenderingContext, colRect, aDirtyRect);
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintRow(PRInt32              aRowIndex,
   1:                           const nsRect&        aRowRect,
   1:                           nsPresContext*       aPresContext,
   1:                           nsIRenderingContext& aRenderingContext,
   1:                           const nsRect&        aDirtyRect,
   1:                           nsPoint              aPt)
   1: {
   1:   // We have been given a rect for our row.  We treat this row like a full-blown
   1:   // frame, meaning that it can have borders, margins, padding, and a background.
   1:   
   1:   // Without a view, we have no data. Check for this up front.
   1:   if (!mView)
   1:     return;
   1: 
   1:   nsresult rv;
   1: 
   1:   // Now obtain the properties for our row.
   1:   // XXX Automatically fill in the following props: open, closed, container, leaf, selected, focused
   1:   PrefillPropertyArray(aRowIndex, nsnull);
   1:   mView->GetRowProperties(aRowIndex, mScratchArray);
   1: 
   1:   // Resolve style for the row.  It contains all the info we need to lay ourselves
   1:   // out and to paint.
   1:   nsStyleContext* rowContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreerow);
   1: 
   1:   // Obtain the margins for the row and then deflate our rect by that 
   1:   // amount.  The row is assumed to be contained within the deflated rect.
   1:   nsRect rowRect(aRowRect);
   1:   nsMargin rowMargin;
   1:   rowContext->GetStyleMargin()->GetMargin(rowMargin);
   1:   rowRect.Deflate(rowMargin);
   1: 
   1:   // Paint our borders and background for our row rect.
   1:   // If a -moz-appearance is provided, use theme drawing only if the current row
   1:   // is not selected (since we draw the selection as part of drawing the background).
   1:   PRBool useTheme = PR_FALSE;
   1:   nsITheme *theme = nsnull;
   1:   const nsStyleDisplay* displayData = rowContext->GetStyleDisplay();
   1:   if (displayData->mAppearance) {
   1:     theme = aPresContext->GetTheme();
   1:     if (theme && theme->ThemeSupportsWidget(aPresContext, nsnull, displayData->mAppearance))
   1:       useTheme = PR_TRUE;
   1:   }
   1:   PRBool isSelected = PR_FALSE;
   1:   nsCOMPtr<nsITreeSelection> selection;
   1:   mView->GetSelection(getter_AddRefs(selection));
   1:   if (selection) 
   1:     selection->IsSelected(aRowIndex, &isSelected);
   1:   if (useTheme && !isSelected) {
   1:     nsRect dirty;
   1:     dirty.IntersectRect(rowRect, aDirtyRect);
   1:     theme->DrawWidgetBackground(&aRenderingContext, this, 
   1:                                 displayData->mAppearance, rowRect, dirty);
   1:   } else {
   1:     PaintBackgroundLayer(rowContext, aPresContext, aRenderingContext, rowRect, aDirtyRect);
   1:   }
   1:   
   1:   // Adjust the rect for its border and padding.
   1:   AdjustForBorderPadding(rowContext, rowRect);
   1: 
   1:   PRBool isSeparator = PR_FALSE;
   1:   mView->IsSeparator(aRowIndex, &isSeparator);
   1:   if (isSeparator) {
   1:     // The row is a separator.
   1: 
   1:     nscoord primaryX = rowRect.x;
   1:     nsTreeColumn* primaryCol = mColumns->GetPrimaryColumn();
   1:     if (primaryCol) {
   1:       // Paint the primary cell.
   1:       nsRect cellRect;
   1:       rv = primaryCol->GetRect(this, rowRect.y, rowRect.height, &cellRect);
   1:       if (NS_FAILED(rv)) {
   1:         NS_NOTREACHED("primary column is invalid");
   1:         return;
   1:       }
   1: 
   1:       if (OffsetForHorzScroll(cellRect, PR_FALSE)) {
   1:         cellRect.x += aPt.x;
   1:         nsRect dirtyRect;
   1:         if (dirtyRect.IntersectRect(aDirtyRect, cellRect))
   1:           PaintCell(aRowIndex, primaryCol, cellRect, aPresContext,
   1:                     aRenderingContext, aDirtyRect, primaryX, aPt);
   1:       }
   1: 
   1:       // Paint the left side of the separator.
   1:       nscoord currX;
   1:       nsTreeColumn* previousCol = primaryCol->GetPrevious();
   1:       if (previousCol) {
   1:         nsRect prevColRect;
   1:         rv = previousCol->GetRect(this, 0, 0, &prevColRect);
   1:         if (NS_SUCCEEDED(rv)) {
   1:           currX = (prevColRect.x - mHorzPosition) + prevColRect.width + aPt.x;
   1:         } else {
   1:           NS_NOTREACHED("The column before the primary column is invalid");
   1:           currX = rowRect.x;
   1:         }
   1:       } else {
   1:         currX = rowRect.x;
   1:       }
   1: 
   1:       PRInt32 level;
   1:       mView->GetLevel(aRowIndex, &level);
   1:       if (level == 0)
   1:         currX += mIndentation;
   1: 
   1:       if (currX > rowRect.x) {
   1:         nsRect separatorRect(rowRect);
   1:         separatorRect.width -= rowRect.x + rowRect.width - currX;
   1:         PaintSeparator(aRowIndex, separatorRect, aPresContext, aRenderingContext, aDirtyRect);
   1:       }
   1:     }
   1: 
   1:     // Paint the right side (whole) separator.
   1:     nsRect separatorRect(rowRect);
   1:     if (primaryX > rowRect.x) {
   1:       separatorRect.width -= primaryX - rowRect.x;
   1:       separatorRect.x += primaryX - rowRect.x;
   1:     }
   1:     PaintSeparator(aRowIndex, separatorRect, aPresContext, aRenderingContext, aDirtyRect);
   1:   }
   1:   else {
   1:     // Now loop over our cells. Only paint a cell if it intersects with our dirty rect.
   1:     for (nsTreeColumn* currCol = mColumns->GetFirstColumn(); currCol;
   1:          currCol = currCol->GetNext()) {
   1:       nsRect cellRect;
   1:       rv = currCol->GetRect(this, rowRect.y, rowRect.height, &cellRect);
   1:       // Don't paint cells in hidden columns.
   1:       if (NS_FAILED(rv) || cellRect.width == 0)
   1:         continue;
   1: 
   1:       if (OffsetForHorzScroll(cellRect, PR_FALSE)) {
   1:         cellRect.x += aPt.x;
   1:         
   1:         nsRect dirtyRect;
   1:         nscoord dummy;
   1:         if (dirtyRect.IntersectRect(aDirtyRect, cellRect))
   1:           PaintCell(aRowIndex, currCol, cellRect, aPresContext,
   1:                     aRenderingContext, aDirtyRect, dummy, aPt);
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintSeparator(PRInt32              aRowIndex,
   1:                                 const nsRect&        aSeparatorRect,
   1:                                 nsPresContext*      aPresContext,
   1:                                 nsIRenderingContext& aRenderingContext,
   1:                                 const nsRect&        aDirtyRect)
   1: {
   1:   // Resolve style for the separator.
   1:   nsStyleContext* separatorContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeseparator);
   1:   PRBool useTheme = PR_FALSE;
   1:   nsITheme *theme = nsnull;
   1:   const nsStyleDisplay* displayData = separatorContext->GetStyleDisplay();
   1:   if ( displayData->mAppearance ) {
   1:     theme = aPresContext->GetTheme();
   1:     if (theme && theme->ThemeSupportsWidget(aPresContext, nsnull, displayData->mAppearance))
   1:       useTheme = PR_TRUE;
   1:   }
   1: 
   1:   // use -moz-appearance if provided.
   1:   if (useTheme) {
   1:     nsRect dirty;
   1:     dirty.IntersectRect(aSeparatorRect, aDirtyRect);
   1:     theme->DrawWidgetBackground(&aRenderingContext, this,
   1:                                 displayData->mAppearance, aSeparatorRect, dirty); 
   1:   }
   1:   else {
   1:     const nsStylePosition* stylePosition = separatorContext->GetStylePosition();
   1: 
   1:     // Obtain the height for the separator or use the default value.
   1:     nscoord height;
   1:     if (stylePosition->mHeight.GetUnit() == eStyleUnit_Coord)
   1:       height = stylePosition->mHeight.GetCoordValue();
   1:     else {
   1:       // Use default height 2px.
   1:       height = nsPresContext::CSSPixelsToAppUnits(2);
   1:     }
   1: 
   1:     // Obtain the margins for the separator and then deflate our rect by that 
   1:     // amount. The separator is assumed to be contained within the deflated rect.
   1:     nsRect separatorRect(aSeparatorRect.x, aSeparatorRect.y, aSeparatorRect.width, height);
   1:     nsMargin separatorMargin;
   1:     separatorContext->GetStyleMargin()->GetMargin(separatorMargin);
   1:     separatorRect.Deflate(separatorMargin);
   1: 
   1:     // Center the separator.
   1:     separatorRect.y += (aSeparatorRect.height - height) / 2;
   1: 
   1:     PaintBackgroundLayer(separatorContext, aPresContext, aRenderingContext, separatorRect, aDirtyRect);
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintCell(PRInt32              aRowIndex,
   1:                            nsTreeColumn*        aColumn,
   1:                            const nsRect&        aCellRect,
   1:                            nsPresContext*       aPresContext,
   1:                            nsIRenderingContext& aRenderingContext,
   1:                            const nsRect&        aDirtyRect,
   1:                            nscoord&             aCurrX,
   1:                            nsPoint              aPt)
   1: {
   1:   NS_PRECONDITION(aColumn && aColumn->GetFrame(this), "invalid column passed");
   1: 
   1:   // Now obtain the properties for our cell.
   1:   // XXX Automatically fill in the following props: open, closed, container, leaf, selected, focused, and the col ID.
   1:   PrefillPropertyArray(aRowIndex, aColumn);
   1:   mView->GetCellProperties(aRowIndex, aColumn, mScratchArray);
   1: 
   1:   // Resolve style for the cell.  It contains all the info we need to lay ourselves
   1:   // out and to paint.
   1:   nsStyleContext* cellContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecell);
   1: 
   1:   // Obtain the margins for the cell and then deflate our rect by that 
   1:   // amount.  The cell is assumed to be contained within the deflated rect.
   1:   nsRect cellRect(aCellRect);
   1:   nsMargin cellMargin;
   1:   cellContext->GetStyleMargin()->GetMargin(cellMargin);
   1:   cellRect.Deflate(cellMargin);
   1: 
   1:   // Paint our borders and background for our row rect.
   1:   PaintBackgroundLayer(cellContext, aPresContext, aRenderingContext, cellRect, aDirtyRect);
   1: 
   1:   // Adjust the rect for its border and padding.
   1:   AdjustForBorderPadding(cellContext, cellRect);
   1: 
   1:   nscoord currX = cellRect.x;
   1:   nscoord remainingWidth = cellRect.width;
   1: 
   1:   // Now we paint the contents of the cells.
   1:   // Text alignment determines the order in which we paint.  
   1:   // LEFT means paint from left to right.
   1:   // RIGHT means paint from right to left.
   1:   // XXX Implement RIGHT alignment!
   1: 
   1:   if (aColumn->IsPrimary()) {
   1:     // If we're the primary column, we need to indent and paint the twisty and any connecting lines
   1:     // between siblings.
   1: 
   1:     PRInt32 level;
   1:     mView->GetLevel(aRowIndex, &level);
   1: 
   1:     currX += mIndentation * level;
   1:     remainingWidth -= mIndentation * level;
   1: 
   1:     // Resolve the style to use for the connecting lines.
   1:     nsStyleContext* lineContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeline);
   1:     
   1:     if (mIndentation && level &&
   1:         lineContext->GetStyleVisibility()->IsVisibleOrCollapsed()) {
   1:       // Paint the thread lines.
   1: 
   1:       // Get the size of the twisty. We don't want to paint the twisty
   1:       // before painting of connecting lines since it would paint lines over
   1:       // the twisty. But we need to leave a place for it.
   1:       nsStyleContext* twistyContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreetwisty);
   1: 
   1:       nsRect imageSize;
   1:       nsRect twistyRect(aCellRect);
   1:       GetTwistyRect(aRowIndex, aColumn, imageSize, twistyRect, aPresContext,
   1:                     aRenderingContext, twistyContext);
   1: 
   1:       nsMargin twistyMargin;
   1:       twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
   1:       twistyRect.Inflate(twistyMargin);
   1: 
   1:       aRenderingContext.PushState();
   1: 
   1:       const nsStyleBorder* borderStyle = lineContext->GetStyleBorder();
   1:       nscolor color;
   1:       PRBool transparent; PRBool foreground;
   1:       borderStyle->GetBorderColor(NS_SIDE_LEFT, color, transparent, foreground);
   1: 
   1:       aRenderingContext.SetColor(color);
   1:       PRUint8 style;
   1:       style = borderStyle->GetBorderStyle(NS_SIDE_LEFT);
   1:       aRenderingContext.SetLineStyle(ConvertBorderStyleToLineStyle(style));
   1: 
   1:       nscoord srcX = currX + twistyRect.width - mIndentation / 2;
   1:       nscoord lineY = (aRowIndex - mTopRowIndex) * mRowHeight + aPt.y;
   1: 
   1:       // Don't paint off our cell.
   1:       if (srcX <= cellRect.x + cellRect.width) {
   1:         nscoord destX = currX + twistyRect.width;
   1:         if (destX > cellRect.x + cellRect.width)
   1:           destX = cellRect.x + cellRect.width;
   1:         aRenderingContext.DrawLine(srcX, lineY + mRowHeight / 2, destX, lineY + mRowHeight / 2);
   1:       }
   1: 
   1:       PRInt32 currentParent = aRowIndex;
   1:       for (PRInt32 i = level; i > 0; i--) {
   1:         if (srcX <= cellRect.x + cellRect.width) {
   1:           // Paint full vertical line only if we have next sibling.
   1:           PRBool hasNextSibling;
   1:           mView->HasNextSibling(currentParent, aRowIndex, &hasNextSibling);
   1:           if (hasNextSibling)
   1:             aRenderingContext.DrawLine(srcX, lineY, srcX, lineY + mRowHeight);
   1:           else if (i == level)
   1:             aRenderingContext.DrawLine(srcX, lineY, srcX, lineY + mRowHeight / 2);
   1:         }
   1: 
   1:         PRInt32 parent;
   1:         if (NS_FAILED(mView->GetParentIndex(currentParent, &parent)) || parent < 0)
   1:           break;
   1:         currentParent = parent;
   1:         srcX -= mIndentation;
   1:       }
   1: 
   1:       aRenderingContext.PopState();
   1:     }
   1: 
   1:     // Always leave space for the twisty.
   1:     nsRect twistyRect(currX, cellRect.y, remainingWidth, cellRect.height);
   1:     PaintTwisty(aRowIndex, aColumn, twistyRect, aPresContext, aRenderingContext, aDirtyRect,
   1:                 remainingWidth, currX);
   1:   }
   1:   
   1:   // Now paint the icon for our cell.
   1:   nsRect iconRect(currX, cellRect.y, remainingWidth, cellRect.height);
   1:   nsRect dirtyRect;
   1:   if (dirtyRect.IntersectRect(aDirtyRect, iconRect))
   1:     PaintImage(aRowIndex, aColumn, iconRect, aPresContext, aRenderingContext, aDirtyRect,
   1:                remainingWidth, currX);
   1: 
   1:   // Now paint our element, but only if we aren't a cycler column.
   1:   // XXX until we have the ability to load images, allow the view to 
   1:   // insert text into cycler columns...
   1:   if (!aColumn->IsCycler()) {
   1:     nsRect elementRect(currX, cellRect.y, remainingWidth, cellRect.height);
   1:     nsRect dirtyRect;
   1:     if (dirtyRect.IntersectRect(aDirtyRect, elementRect)) {
   1:       switch (aColumn->GetType()) {
   1:         case nsITreeColumn::TYPE_TEXT:
   1:           PaintText(aRowIndex, aColumn, elementRect, aPresContext, aRenderingContext, aDirtyRect, currX);
   1:           break;
   1:         case nsITreeColumn::TYPE_CHECKBOX:
   1:           PaintCheckbox(aRowIndex, aColumn, elementRect, aPresContext, aRenderingContext, aDirtyRect);
   1:           break;
   1:         case nsITreeColumn::TYPE_PROGRESSMETER:
   1:           PRInt32 state;
   1:           mView->GetProgressMode(aRowIndex, aColumn, &state);
   1:           switch (state) {
   1:             case nsITreeView::PROGRESS_NORMAL:
   1:             case nsITreeView::PROGRESS_UNDETERMINED:
   1:               PaintProgressMeter(aRowIndex, aColumn, elementRect, aPresContext, aRenderingContext, aDirtyRect);
   1:               break;
   1:             case nsITreeView::PROGRESS_NONE:
   1:             default:
   1:               PaintText(aRowIndex, aColumn, elementRect, aPresContext, aRenderingContext, aDirtyRect, currX);
   1:               break;
   1:           }
   1:           break;
   1:       }
   1:     }
   1:   }
   1: 
   1:   aCurrX = currX;
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintTwisty(PRInt32              aRowIndex,
   1:                              nsTreeColumn*        aColumn,
   1:                              const nsRect&        aTwistyRect,
   1:                              nsPresContext*      aPresContext,
   1:                              nsIRenderingContext& aRenderingContext,
   1:                              const nsRect&        aDirtyRect,
   1:                              nscoord&             aRemainingWidth,
   1:                              nscoord&             aCurrX)
   1: {
   1:   NS_PRECONDITION(aColumn && aColumn->GetFrame(this), "invalid column passed");
   1: 
   1:   // Paint the twisty, but only if we are a non-empty container.
   1:   PRBool shouldPaint = PR_FALSE;
   1:   PRBool isContainer = PR_FALSE;
   1:   mView->IsContainer(aRowIndex, &isContainer);
   1:   if (isContainer) {
   1:     PRBool isContainerEmpty = PR_FALSE;
   1:     mView->IsContainerEmpty(aRowIndex, &isContainerEmpty);
   1:     if (!isContainerEmpty)
   1:       shouldPaint = PR_TRUE;
   1:   }
   1: 
   1:   // Resolve style for the twisty.
   1:   nsStyleContext* twistyContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreetwisty);
   1: 
   1:   // Obtain the margins for the twisty and then deflate our rect by that 
   1:   // amount.  The twisty is assumed to be contained within the deflated rect.
   1:   nsRect twistyRect(aTwistyRect);
   1:   nsMargin twistyMargin;
   1:   twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
   1:   twistyRect.Deflate(twistyMargin);
   1: 
   1:   nsRect imageSize;
   1:   nsITheme* theme = GetTwistyRect(aRowIndex, aColumn, imageSize, twistyRect,
   1:                                   aPresContext, aRenderingContext, twistyContext);
   1: 
   1:   // Subtract out the remaining width.  This is done even when we don't actually paint a twisty in 
   1:   // this cell, so that cells in different rows still line up.
   1:   nsRect copyRect(twistyRect);
   1:   copyRect.Inflate(twistyMargin);
   1:   aRemainingWidth -= copyRect.width;
   1:   aCurrX += copyRect.width;
   1: 
   1:   if (shouldPaint) {
   1:     // Paint our borders and background for our image rect.
   1:     PaintBackgroundLayer(twistyContext, aPresContext, aRenderingContext, twistyRect, aDirtyRect);
   1: 
   1:     if (theme) {
   1:       // yeah, I know it says we're drawing a background, but a twisty is really a fg
   1:       // object since it doesn't have anything that gecko would want to draw over it. Besides,
   1:       // we have to prevent imagelib from drawing it.
   1:       nsRect dirty;
   1:       dirty.IntersectRect(twistyRect, aDirtyRect);
   1:       theme->DrawWidgetBackground(&aRenderingContext, this, 
   1:                                   twistyContext->GetStyleDisplay()->mAppearance, twistyRect, dirty);
   1:     }
   1:     else {
   1:       // Time to paint the twisty.
   1:       // Adjust the rect for its border and padding.
   1:       nsMargin bp(0,0,0,0);
   1:       GetBorderPadding(twistyContext, bp);
   1:       twistyRect.Deflate(bp);
   1:       imageSize.Deflate(bp);
   1: 
   1:       // Get the image for drawing.
   1:       nsCOMPtr<imgIContainer> image;
   1:       PRBool useImageRegion = PR_TRUE;
   1:       GetImage(aRowIndex, aColumn, PR_TRUE, twistyContext, useImageRegion, getter_AddRefs(image));
   1:       if (image) {
   1:         nsRect r(twistyRect.x, twistyRect.y, imageSize.width, imageSize.height);
   1: 
   1:         // Center the image. XXX Obey vertical-align style prop?
   1:         if (imageSize.height < twistyRect.height) {
   1:           r.y += (twistyRect.height - imageSize.height)/2;
   1:         }
   1:           
   1:         // Paint the image.
   1:         nsLayoutUtils::DrawImage(&aRenderingContext, image,
   1:                                  r, aDirtyRect, &imageSize);
   1:       }
   1:     }        
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintImage(PRInt32              aRowIndex,
   1:                             nsTreeColumn*        aColumn,
   1:                             const nsRect&        aImageRect,
   1:                             nsPresContext*       aPresContext,
   1:                             nsIRenderingContext& aRenderingContext,
   1:                             const nsRect&        aDirtyRect,
   1:                             nscoord&             aRemainingWidth,
   1:                             nscoord&             aCurrX)
   1: {
   1:   NS_PRECONDITION(aColumn && aColumn->GetFrame(this), "invalid column passed");
   1: 
   1:   // Resolve style for the image.
   1:   nsStyleContext* imageContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeimage);
   1: 
   1:   // Obtain the margins for the image and then deflate our rect by that
   1:   // amount.  The image is assumed to be contained within the deflated rect.
   1:   nsRect imageRect(aImageRect);
   1:   nsMargin imageMargin;
   1:   imageContext->GetStyleMargin()->GetMargin(imageMargin);
   1:   imageRect.Deflate(imageMargin);
   1: 
   1:   // Get the image.
   1:   PRBool useImageRegion = PR_TRUE;
   1:   nsCOMPtr<imgIContainer> image;
   1:   GetImage(aRowIndex, aColumn, PR_FALSE, imageContext, useImageRegion, getter_AddRefs(image));
   1: 
   1:   // Get the image destination size.
   1:   nsSize imageDestSize = GetImageDestSize(imageContext, useImageRegion, image);
   1:   if (!imageDestSize.width || !imageDestSize.height)
   1:     return;
   1: 
   1:   // Get the borders and padding.
   1:   nsMargin bp(0,0,0,0);
   1:   GetBorderPadding(imageContext, bp);
   1: 
   1:   // destRect will be passed as the aDestRect argument in the DrawImage method.
   1:   // Start with the imageDestSize width and height.
   1:   nsRect destRect(0, 0, imageDestSize.width, imageDestSize.height);
   1:   // Inflate destRect for borders and padding so that we can compare/adjust
   1:   // with respect to imageRect.
   1:   destRect.Inflate(bp);
   1: 
   1:   // The destRect width and height have not been adjusted to fit within the
   1:   // cell width and height.
   1:   // We must adjust the width even if image is null, because the width is used
   1:   // to update the aRemainingWidth and aCurrX values.
   1:   // Since the height isn't used unless the image is not null, we will adjust
   1:   // the height inside the if (image) block below.
   1: 
   1:   if (destRect.width > imageRect.width) {
   1:     // The destRect is too wide to fit within the cell width.
   1:     // Adjust destRect width to fit within the cell width.
   1:     destRect.width = imageRect.width;
   1:   }
   1:   else {
   1:     // The cell is wider than the destRect.
   1:     // In a cycler column, the image is centered horizontally.
   1:     if (!aColumn->IsCycler()) {
   1:       // If this column is not a cycler, we won't center the image horizontally.
   1:       // We adjust the imageRect width so that the image is placed at the start
   1:       // of the cell.
   1:       imageRect.width = destRect.width;
   1:     }
   1:   }
   1: 
   1:   if (image) {
   1:     // Paint our borders and background for our image rect
   1:     PaintBackgroundLayer(imageContext, aPresContext, aRenderingContext, imageRect, aDirtyRect);
   1: 
   1:     // The destRect x and y have not been set yet. Let's do that now.
   1:     // Initially, we use the imageRect x and y.
   1:     destRect.x = imageRect.x;
   1:     destRect.y = imageRect.y;
   1: 
   1:     if (destRect.width < imageRect.width) {
   1:       // The destRect width is smaller than the cell width.
   1:       // Center the image horizontally in the cell.
   1:       // Adjust the destRect x accordingly.
   1:       destRect.x += (imageRect.width - destRect.width)/2;
   1:     }
   1: 
   1:     // Now it's time to adjust the destRect height to fit within the cell height.
   1:     if (destRect.height > imageRect.height) {
   1:       // The destRect height is larger than the cell height.
   1:       // Adjust destRect height to fit within the cell height.
   1:       destRect.height = imageRect.height;
   1:     }
   1:     else if (destRect.height < imageRect.height) {
   1:       // The destRect height is smaller than the cell height.
   1:       // Center the image vertically in the cell.
   1:       // Adjust the destRect y accordingly.
   1:       destRect.y += (imageRect.height - destRect.height)/2;
   1:     }
   1: 
   1:     // It's almost time to paint the image.
   1:     // Deflate destRect for the border and padding.
   1:     destRect.Deflate(bp);
   1: 
   1:     // Get the image source rectangle - the rectangle containing the part of
   1:     // the image that we are going to display.
   1:     // sourceRect will be passed as the aSrcRect argument in the DrawImage method.
   1:     nsRect sourceRect = GetImageSourceRect(imageContext, useImageRegion, image);
   1: 
   1:     // If destRect width/height was adjusted to fit within the cell
   1:     // width/height, we need to make corresponding adjustments to the
   1:     // sourceRect width/height.
   1:     // Here's an explanation. Let's say that the image is 100 pixels tall and
   1:     // that the CSS has specified that the destination height should be 50
   1:     // pixels tall. Let's say that the cell height is only 20 pixels. So, in
   1:     // those 20 visible pixels, we want to see the top 20/50ths of the image.
   1:     // So, the sourceRect.height should be 100 * 20 / 50, which is 40 pixels.
   1:     // Essentially, we are scaling the image as dictated by the CSS destination
   1:     // height and width, and we are then clipping the scaled image by the cell
   1:     // width and height.
   1:     nsRect clip;
   1:     clip.IntersectRect(aDirtyRect, destRect);
   1:     nsLayoutUtils::DrawImage(&aRenderingContext, image,
   1:                              nsRect(destRect.TopLeft(), imageDestSize),
   1:                              clip, &sourceRect);
   1:   }
   1: 
   1:   // Update the aRemainingWidth and aCurrX values.
   1:   imageRect.Inflate(imageMargin);
   1:   aRemainingWidth -= imageRect.width;
   1:   aCurrX += imageRect.width;
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintText(PRInt32              aRowIndex,
   1:                            nsTreeColumn*        aColumn,
   1:                            const nsRect&        aTextRect,
   1:                            nsPresContext*      aPresContext,
   1:                            nsIRenderingContext& aRenderingContext,
   1:                            const nsRect&        aDirtyRect,
   1:                            nscoord&             aCurrX)
   1: {
   1:   NS_PRECONDITION(aColumn && aColumn->GetFrame(this), "invalid column passed");
   1: 
   1:   // Now obtain the text for our cell.
   1:   nsAutoString text;
   1:   mView->GetCellText(aRowIndex, aColumn, text);
   1:   // We're going to paint this text so we need to ensure bidi is enabled if
   1:   // necessary
   1:   CheckTextForBidi(text);
   1: 
   1:   if (text.Length() == 0)
   1:     return; // Don't paint an empty string. XXX What about background/borders? Still paint?
   1: 
   1:   // Resolve style for the text.  It contains all the info we need to lay ourselves
   1:   // out and to paint.
   1:   nsStyleContext* textContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecelltext);
   1: 
   1:   // Obtain the margins for the text and then deflate our rect by that 
   1:   // amount.  The text is assumed to be contained within the deflated rect.
   1:   nsRect textRect(aTextRect);
   1:   nsMargin textMargin;
   1:   textContext->GetStyleMargin()->GetMargin(textMargin);
   1:   textRect.Deflate(textMargin);
   1: 
   1:   // Adjust the rect for its border and padding.
   1:   nsMargin bp(0,0,0,0);
   1:   GetBorderPadding(textContext, bp);
   1:   textRect.Deflate(bp);
   1: 
   1:   // Compute our text size.
   1:   nsCOMPtr<nsIFontMetrics> fontMet;
   1:   aPresContext->DeviceContext()->
   1:     GetMetricsFor(textContext->GetStyleFont()->mFont, *getter_AddRefs(fontMet));
   1: 
   1:   nscoord height, baseline;
   1:   fontMet->GetHeight(height);
   1:   fontMet->GetMaxAscent(baseline);
   1: 
   1:   // Center the text. XXX Obey vertical-align style prop?
   1:   if (height < textRect.height) {
   1:     textRect.y += (textRect.height - height)/2;
   1:     textRect.height = height;
   1:   }
   1: 
   1:   // Set our font.
   1:   aRenderingContext.SetFont(fontMet);
   1: 
   1:   AdjustForCellText(text, aRowIndex, aColumn, aRenderingContext, textRect);
   1: 
   1:   // Subtract out the remaining width.
   1:   nsRect copyRect(textRect);
   1:   copyRect.Inflate(textMargin);
   1:   aCurrX += copyRect.width;
   1: 
   1:   textRect.Inflate(bp);
   1:   PaintBackgroundLayer(textContext, aPresContext, aRenderingContext, textRect, aDirtyRect);
   1: 
   1:   // Time to paint our text.
   1:   textRect.Deflate(bp);
   1: 
   1:   // Set our color.
   1:   aRenderingContext.SetColor(textContext->GetStyleColor()->mColor);
   1: 
   1:   // Draw decorations.
   1:   PRUint8 decorations = textContext->GetStyleTextReset()->mTextDecoration;
   1: 
   1:   nscoord offset;
   1:   nscoord size;
   1:   if (decorations & (NS_FONT_DECORATION_OVERLINE | NS_FONT_DECORATION_UNDERLINE)) {
   1:     fontMet->GetUnderline(offset, size);
   1:     if (decorations & NS_FONT_DECORATION_OVERLINE)
   1:       aRenderingContext.FillRect(textRect.x, textRect.y, textRect.width, size);
   1:     if (decorations & NS_FONT_DECORATION_UNDERLINE)
   1:       aRenderingContext.FillRect(textRect.x, textRect.y + baseline - offset, textRect.width, size);
   1:   }
   1:   if (decorations & NS_FONT_DECORATION_LINE_THROUGH) {
   1:     fontMet->GetStrikeout(offset, size);
   1:     aRenderingContext.FillRect(textRect.x, textRect.y + baseline - offset, textRect.width, size);
   1:   }
   1: #ifdef MOZ_TIMELINE
   1:   NS_TIMELINE_START_TIMER("Render Outline Text");
   1: #endif
   1:   nsLayoutUtils::DrawString(this, &aRenderingContext, text.get(), text.Length(),
   1:                             textRect.TopLeft() + nsPoint(0, baseline));
   1: #ifdef MOZ_TIMELINE
   1:   NS_TIMELINE_STOP_TIMER("Render Outline Text");
   1:   NS_TIMELINE_MARK_TIMER("Render Outline Text");
   1: #endif
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintCheckbox(PRInt32              aRowIndex,
   1:                                nsTreeColumn*        aColumn,
   1:                                const nsRect&        aCheckboxRect,
   1:                                nsPresContext*      aPresContext,
   1:                                nsIRenderingContext& aRenderingContext,
   1:                                const nsRect&        aDirtyRect)
   1: {
   1:   NS_PRECONDITION(aColumn && aColumn->GetFrame(this), "invalid column passed");
   1: 
   1:   // Resolve style for the checkbox.
   1:   nsStyleContext* checkboxContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreecheckbox);
   1: 
   1:   // Obtain the margins for the checkbox and then deflate our rect by that 
   1:   // amount.  The checkbox is assumed to be contained within the deflated rect.
   1:   nsRect checkboxRect(aCheckboxRect);
   1:   nsMargin checkboxMargin;
   1:   checkboxContext->GetStyleMargin()->GetMargin(checkboxMargin);
   1:   checkboxRect.Deflate(checkboxMargin);
   1:   
   1:   nsRect imageSize = GetImageSize(aRowIndex, aColumn, PR_TRUE, checkboxContext);
   1: 
   1:   if (imageSize.height > checkboxRect.height)
   1:     imageSize.height = checkboxRect.height;
   1:   if (imageSize.width > checkboxRect.width)
   1:     imageSize.width = checkboxRect.width;
   1: 
   1:   // Paint our borders and background for our image rect.
   1:   PaintBackgroundLayer(checkboxContext, aPresContext, aRenderingContext, checkboxRect, aDirtyRect);
   1: 
   1:   // Time to paint the checkbox.
   1:   // Adjust the rect for its border and padding.
   1:   nsMargin bp(0,0,0,0);
   1:   GetBorderPadding(checkboxContext, bp);
   1:   checkboxRect.Deflate(bp);
   1: 
   1:   // Get the image for drawing.
   1:   nsCOMPtr<imgIContainer> image;
   1:   PRBool useImageRegion = PR_TRUE;
   1:   GetImage(aRowIndex, aColumn, PR_TRUE, checkboxContext, useImageRegion, getter_AddRefs(image));
   1:   if (image) {
   1:     nsRect r(checkboxRect.x, checkboxRect.y, imageSize.width, imageSize.height);
   1:           
   1:     if (imageSize.height < checkboxRect.height) {
   1:       r.y += (checkboxRect.height - imageSize.height)/2;
   1:     }
   1: 
   1:     if (imageSize.width < checkboxRect.width) {
   1:       r.x += (checkboxRect.width - imageSize.width)/2;
   1:     }
   1: 
   1:     // Paint the image.
   1:     nsLayoutUtils::DrawImage(&aRenderingContext, image,
   1:                              r, aDirtyRect, &imageSize);
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintProgressMeter(PRInt32              aRowIndex,
   1:                                     nsTreeColumn*        aColumn,
   1:                                     const nsRect&        aProgressMeterRect,
   1:                                     nsPresContext*      aPresContext,
   1:                                     nsIRenderingContext& aRenderingContext,
   1:                                     const nsRect&        aDirtyRect)
   1: {
   1:   NS_PRECONDITION(aColumn && aColumn->GetFrame(this), "invalid column passed");
   1: 
   1:   // Resolve style for the progress meter.  It contains all the info we need
   1:   // to lay ourselves out and to paint.
   1:   nsStyleContext* meterContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreeprogressmeter);
   1: 
   1:   // Obtain the margins for the progress meter and then deflate our rect by that 
   1:   // amount. The progress meter is assumed to be contained within the deflated
   1:   // rect.
   1:   nsRect meterRect(aProgressMeterRect);
   1:   nsMargin meterMargin;
   1:   meterContext->GetStyleMargin()->GetMargin(meterMargin);
   1:   meterRect.Deflate(meterMargin);
   1: 
   1:   // Paint our borders and background for our progress meter rect.
   1:   PaintBackgroundLayer(meterContext, aPresContext, aRenderingContext, meterRect, aDirtyRect);
   1: 
   1:   // Time to paint our progress. 
   1:   PRInt32 state;
   1:   mView->GetProgressMode(aRowIndex, aColumn, &state);
   1:   if (state == nsITreeView::PROGRESS_NORMAL) {
   1:     // Adjust the rect for its border and padding.
   1:     AdjustForBorderPadding(meterContext, meterRect);
   1: 
   1:     // Set our color.
   1:     aRenderingContext.SetColor(meterContext->GetStyleColor()->mColor);
   1: 
   1:     // Now obtain the value for our cell.
   1:     nsAutoString value;
   1:     mView->GetCellValue(aRowIndex, aColumn, value);
   1: 
   1:     PRInt32 rv;
   1:     PRInt32 intValue = value.ToInteger(&rv);
   1:     if (intValue < 0)
   1:       intValue = 0;
   1:     else if (intValue > 100)
   1:       intValue = 100;
   1: 
   1:     meterRect.width = NSToCoordRound((float)intValue / 100 * meterRect.width);
   1:     PRBool useImageRegion = PR_TRUE;
   1:     nsCOMPtr<imgIContainer> image;
   1:     GetImage(aRowIndex, aColumn, PR_TRUE, meterContext, useImageRegion, getter_AddRefs(image));
   1:     if (image)
   1:       aRenderingContext.DrawTile(image, 0, 0, &meterRect);
   1:     else
   1:       aRenderingContext.FillRect(meterRect);
   1:   }
   1:   else if (state == nsITreeView::PROGRESS_UNDETERMINED) {
   1:     // Adjust the rect for its border and padding.
   1:     AdjustForBorderPadding(meterContext, meterRect);
   1: 
   1:     PRBool useImageRegion = PR_TRUE;
   1:     nsCOMPtr<imgIContainer> image;
   1:     GetImage(aRowIndex, aColumn, PR_TRUE, meterContext, useImageRegion, getter_AddRefs(image));
   1:     if (image)
   1:       aRenderingContext.DrawTile(image, 0, 0, &meterRect);
   1:   }
   1: }
   1: 
   1: 
   1: void
   1: nsTreeBodyFrame::PaintDropFeedback(const nsRect&        aDropFeedbackRect,
   1:                                    nsPresContext*      aPresContext,
   1:                                    nsIRenderingContext& aRenderingContext,
   1:                                    const nsRect&        aDirtyRect)
   1: {
   1:   // Paint the drop feedback in between rows.
   1: 
   1:   nscoord currX;
   1: 
   1:   // Adjust for the primary cell.
   1:   nsTreeColumn* primaryCol = mColumns->GetPrimaryColumn();
   1: 
   1:   if (primaryCol) {
   1:     nsresult rv = primaryCol->GetXInTwips(this, &currX);
   1:     NS_ASSERTION(NS_SUCCEEDED(rv), "primary column is invalid?");
   1: 
   1:     currX -= mHorzPosition;
   1:   } else {
   1:     currX = aDropFeedbackRect.x;
   1:   }
   1: 
   1:   PrefillPropertyArray(mSlots->mDropRow, primaryCol);
   1: 
   1:   // Resolve the style to use for the drop feedback.
   1:   nsStyleContext* feedbackContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreedropfeedback);
   1: 
   1:   // Paint only if it is visible.
   1:   if (feedbackContext->GetStyleVisibility()->IsVisibleOrCollapsed()) {
   1:     PRInt32 level;
   1:     mView->GetLevel(mSlots->mDropRow, &level);
   1: 
   1:     // If our previous or next row has greater level use that for 
   1:     // correct visual indentation.
   1:     if (mSlots->mDropOrient == nsITreeView::DROP_BEFORE) {
   1:       if (mSlots->mDropRow > 0) {
   1:         PRInt32 previousLevel;
   1:         mView->GetLevel(mSlots->mDropRow - 1, &previousLevel);
   1:         if (previousLevel > level)
   1:           level = previousLevel;
   1:       }
   1:     }
   1:     else {
   1:       if (mSlots->mDropRow < mRowCount - 1) {
   1:         PRInt32 nextLevel;
   1:         mView->GetLevel(mSlots->mDropRow + 1, &nextLevel);
   1:         if (nextLevel > level)
   1:           level = nextLevel;
   1:       }
   1:     }
   1: 
   1:     currX += mIndentation * level;
   1: 
   1:     if (primaryCol){
   1:       nsStyleContext* twistyContext = GetPseudoStyleContext(nsCSSAnonBoxes::moztreetwisty);
   1:       nsRect imageSize;
   1:       nsRect twistyRect;
   1:       GetTwistyRect(mSlots->mDropRow, primaryCol, imageSize, twistyRect, aPresContext,
   1:                     aRenderingContext, twistyContext);
   1:       nsMargin twistyMargin;
   1:       twistyContext->GetStyleMargin()->GetMargin(twistyMargin);
   1:       twistyRect.Inflate(twistyMargin);
   1:       currX += twistyRect.width;
   1:     }
   1: 
   1:     const nsStylePosition* stylePosition = feedbackContext->GetStylePosition();
   1: 
   1:     // Obtain the width for the drop feedback or use default value.
   1:     nscoord width;
   1:     if (stylePosition->mWidth.GetUnit() == eStyleUnit_Coord)
   1:       width = stylePosition->mWidth.GetCoordValue();
   1:     else {
   1:       // Use default width 50px.
   1:       width = nsPresContext::CSSPixelsToAppUnits(50);
   1:     }
   1: 
   1:     // Obtain the height for the drop feedback or use default value.
   1:     nscoord height;
   1:     if (stylePosition->mHeight.GetUnit() == eStyleUnit_Coord)
   1:       height = stylePosition->mHeight.GetCoordValue();
   1:     else {
   1:       // Use default height 2px.
   1:       height = nsPresContext::CSSPixelsToAppUnits(2);
   1:     }
   1: 
   1:     // Obtain the margins for the drop feedback and then deflate our rect
   1:     // by that amount.
   1:     nsRect feedbackRect(currX, aDropFeedbackRect.y, width, height);
   1:     nsMargin margin;
   1:     feedbackContext->GetStyleMargin()->GetMargin(margin);
   1:     feedbackRect.Deflate(margin);
   1: 
   1:     feedbackRect.y += (aDropFeedbackRect.height - height) / 2;
   1: 
   1:     // Finally paint the drop feedback.
   1:     PaintBackgroundLayer(feedbackContext, aPresContext, aRenderingContext, feedbackRect, aDirtyRect);
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::PaintBackgroundLayer(nsStyleContext*      aStyleContext,
   1:                                       nsPresContext*      aPresContext,
   1:                                       nsIRenderingContext& aRenderingContext,
   1:                                       const nsRect&        aRect,
   1:                                       const nsRect&        aDirtyRect)
   1: {
   1:   const nsStyleBackground* myColor = aStyleContext->GetStyleBackground();
   1:   const nsStyleBorder* myBorder = aStyleContext->GetStyleBorder();
   1:   const nsStylePadding* myPadding = aStyleContext->GetStylePadding();
   1:   const nsStyleOutline* myOutline = aStyleContext->GetStyleOutline();
   1:   
   1:   nsCSSRendering::PaintBackgroundWithSC(aPresContext, aRenderingContext,
   1:                                         this, aDirtyRect, aRect,
   1:                                         *myColor, *myBorder, *myPadding,
   1:                                         PR_TRUE);
   1: 
   1:   nsCSSRendering::PaintBorder(aPresContext, aRenderingContext, this,
   1:                               aDirtyRect, aRect, *myBorder, mStyleContext, 0);
   1: 
   1:   nsCSSRendering::PaintOutline(aPresContext, aRenderingContext, this,
   1:                                aDirtyRect, aRect, *myBorder, *myOutline,
   1:                                aStyleContext, 0);
   1: }
   1: 
   1: // Scrolling
   1: NS_IMETHODIMP nsTreeBodyFrame::EnsureRowIsVisible(PRInt32 aRow)
   1: {
   1:   return EnsureRowIsVisibleInternal(GetScrollParts(), aRow);
   1: }
   1: 
   1: nsresult nsTreeBodyFrame::EnsureRowIsVisibleInternal(const ScrollParts& aParts, PRInt32 aRow)
   1: {
   1:   if (!mView)
   1:     return NS_OK;
   1: 
   1:   if (mTopRowIndex <= aRow && mTopRowIndex+mPageLength > aRow)
   1:     return NS_OK;
   1: 
   1:   if (aRow < mTopRowIndex)
   1:     ScrollToRowInternal(aParts, aRow);
   1:   else {
   1:     // Bring it just on-screen.
   1:     PRInt32 distance = aRow - (mTopRowIndex+mPageLength)+1;
   1:     ScrollToRowInternal(aParts, mTopRowIndex+distance);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::EnsureCellIsVisible(PRInt32 aRow, nsITreeColumn* aCol)
   1: {
   1:   nsRefPtr<nsTreeColumn> col = GetColumnImpl(aCol);
   1:   if (!col)
   1:     return NS_ERROR_INVALID_ARG;
   1: 
   1:   ScrollParts parts = GetScrollParts();
   1: 
   1:   nscoord result = -1;
   1:   nsresult rv;
   1: 
   1:   nscoord columnPos;
   1:   rv = col->GetXInTwips(this, &columnPos);
   1:   if(NS_FAILED(rv)) return rv;
   1: 
   1:   nscoord columnWidth;
   1:   rv = col->GetWidthInTwips(this, &columnWidth);
   1:   if(NS_FAILED(rv)) return rv;
   1: 
   1:   // If the start of the column is before the
   1:   // start of the horizontal view, then scroll
   1:   if (columnPos < mHorzPosition)
   1:     result = columnPos;
   1:   // If the end of the column is past the end of 
   1:   // the horizontal view, then scroll
   1:   else if ((columnPos + columnWidth) > (mHorzPosition + mInnerBox.width))
   1:     result = ((columnPos + columnWidth) - (mHorzPosition + mInnerBox.width)) + mHorzPosition;
   1: 
   1:   if (result != -1) {
   1:     rv = ScrollHorzInternal(parts, result);
   1:     if(NS_FAILED(rv)) return rv;
   1:   }
   1: 
   1:   return EnsureRowIsVisibleInternal(parts, aRow);
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::ScrollToCell(PRInt32 aRow, nsITreeColumn* aCol)
   1: {
   1:   ScrollParts parts = GetScrollParts();
   1:   nsresult rv = ScrollToRowInternal(parts, aRow);
   1:   if(NS_FAILED(rv)) return rv;
   1: 
   1:   return ScrollToColumnInternal(parts, aCol);
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::ScrollToColumn(nsITreeColumn* aCol)
   1: {
   1:   return ScrollToColumnInternal(GetScrollParts(), aCol);
   1: }
   1: 
   1: nsresult nsTreeBodyFrame::ScrollToColumnInternal(const ScrollParts& aParts,
   1:                                                  nsITreeColumn* aCol)
   1: {
   1:   nsRefPtr<nsTreeColumn> col = GetColumnImpl(aCol);
   1:   if (!col)
   1:     return NS_ERROR_INVALID_ARG;
   1: 
   1:   nscoord x;
   1:   nsresult rv = col->GetXInTwips(this, &x);
   1:   if (NS_FAILED(rv))
   1:     return rv;
   1: 
   1:   return ScrollHorzInternal(aParts, x);
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::ScrollToHorizontalPosition(PRInt32 aHorizontalPosition)
   1: {
   1:   ScrollHorzInternal(GetScrollParts(),
   1:                      nsPresContext::CSSPixelsToAppUnits(aHorizontalPosition));
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::ScrollToRow(PRInt32 aRow)
   1: {
   1:   return ScrollToRowInternal(GetScrollParts(), aRow);
   1: }
   1: 
   1: nsresult nsTreeBodyFrame::ScrollToRowInternal(const ScrollParts& aParts, PRInt32 aRow)
   1: {
   1:   ScrollInternal(aParts, aRow);
   1:   UpdateScrollbars(aParts);
   1: 
   1: #if defined(XP_MAC) || defined(XP_MACOSX)
   1:   // mac can't process the event loop during a drag, so if we're dragging,
   1:   // grab the scroll widget and make it paint synchronously. This is
   1:   // sorta slow (having to paint the entire tree), but it works.
   1:   if (mSlots && mSlots->mDragSession && aParts.mVScrollbar) {
   1:     nsIFrame* frame;
   1:     CallQueryInterface(aParts.mVScrollbar, &frame);
   1:     nsIWidget* scrollWidget = frame->GetWindow();
   1:     if (scrollWidget)
   1:       scrollWidget->Invalidate(PR_TRUE);
   1:   }
   1: #endif
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::ScrollByLines(PRInt32 aNumLines)
   1: {
   1:   if (!mView)
   1:     return NS_OK;
   1: 
   1:   PRInt32 newIndex = mTopRowIndex + aNumLines;
   1:   if (newIndex < 0)
   1:     newIndex = 0;
   1:   else {
   1:     PRInt32 lastPageTopRow = mRowCount - mPageLength;
   1:     if (newIndex > lastPageTopRow)
   1:       newIndex = lastPageTopRow;
   1:   }
   1:   ScrollToRow(newIndex);
   1:   
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsTreeBodyFrame::ScrollByPages(PRInt32 aNumPages)
   1: {
   1:   if (!mView)
   1:     return NS_OK;
   1: 
   1:   PRInt32 newIndex = mTopRowIndex + aNumPages * mPageLength;
   1:   if (newIndex < 0)
   1:     newIndex = 0;
   1:   else {
   1:     PRInt32 lastPageTopRow = mRowCount - mPageLength;
   1:     if (newIndex > lastPageTopRow)
   1:       newIndex = lastPageTopRow;
   1:   }
   1:   ScrollToRow(newIndex);
   1:     
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTreeBodyFrame::ScrollInternal(const ScrollParts& aParts, PRInt32 aRow)
   1: {
   1:   if (!mView)
   1:     return NS_OK;
   1: 
   1:   PRInt32 delta = aRow - mTopRowIndex;
   1: 
   1:   if (delta > 0) {
   1:     if (mTopRowIndex == (mRowCount - mPageLength + 1))
   1:       return NS_OK;
   1:   }
   1:   else {
   1:     if (mTopRowIndex == 0)
   1:       return NS_OK;
   1:   }
   1: 
   1:   mTopRowIndex += delta;
   1: 
 238:   nsPresContext* presContext = PresContext();
   1: 
   1:   // See if we have a transparent background or a background image.  
   1:   // If we do, then we cannot blit.
   1:   const nsStyleBackground* background = GetStyleBackground();
   1:   if (background->mBackgroundImage || background->IsTransparent() || 
   1:       PR_ABS(delta)*mRowHeight >= mRect.height) {
   1:     Invalidate();
   1:   } else {
   1:     nsIWidget* widget = nsLeafBoxFrame::GetView()->GetWidget();
   1:     if (widget) {
   1:       nscoord rowHeightAsPixels = presContext->AppUnitsToDevPixels(mRowHeight);
   1:       widget->Scroll(0, -delta*rowHeightAsPixels, nsnull);
   1:     }
   1:   }
   1: 
   1:   nsScrollbarEvent event(PR_TRUE, NS_SCROLL_EVENT, nsnull);
   1:   // scroll events fired at elements don't bubble (although scroll events
   1:   // fired at documents do, to the window)
   1:   event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
   1: 
   1:   nsEventStatus status = nsEventStatus_eIgnore;
   1:   nsEventDispatcher::Dispatch(mContent, presContext, &event, nsnull, &status);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsTreeBodyFrame::ScrollHorzInternal(const ScrollParts& aParts, PRInt32 aPosition)
   1: {
   1:   if (!mView || !aParts.mColumnsScrollableView || !aParts.mHScrollbar)
   1:     return NS_OK;
   1: 
   1:   if (aPosition == mHorzPosition)
   1:     return NS_OK;
   1: 
   1:   if (aPosition < 0 || aPosition > mHorzWidth)
   1:     return NS_OK;
   1: 
   1:   nsRect bounds = aParts.mColumnsScrollableView->View()->GetBounds();
   1:   if (aPosition > (mHorzWidth - bounds.width)) 
   1:     aPosition = mHorzWidth - bounds.width;
   1: 
   1:   PRInt32 delta = aPosition - mHorzPosition;
   1:   mHorzPosition = aPosition;
   1: 
   1:   // See if we have a background image.  If we do, then we cannot blit.
   1:   const nsStyleBackground* background = GetStyleBackground();
   1:   if (background->mBackgroundImage || background->IsTransparent() || 
   1:       PR_ABS(delta) >= mRect.width) {
   1:     Invalidate();
   1:   } else {
   1:     nsIWidget* widget = nsLeafBoxFrame::GetView()->GetWidget();
   1:     if (widget) {
 238:       widget->Scroll(PresContext()->AppUnitsToDevPixels(-delta), 0, nsnull);
   1:     }
   1:   }
   1: 
   1:   // Reflect the change in the scrollbar 
   1:   nsAutoString curPos;
   1:   curPos.AppendInt(aPosition);
   1:   nsWeakFrame weakFrame(this);
   1:   aParts.mHScrollbarContent->SetAttr(kNameSpaceID_None,
   1:                                      nsGkAtoms::curpos, curPos, PR_TRUE);
   1:   NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
   1:   // Update the column scroll view
   1:   aParts.mColumnsScrollableView->ScrollTo(mHorzPosition, 0, 0);
   1: 
   1:   // And fire off an event about it all
   1:   nsScrollbarEvent event(PR_TRUE, NS_SCROLL_EVENT, nsnull);
   1:   // scroll events fired at elements don't bubble (although scroll events
   1:   // fired at documents do, to the window)
   1:   event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
   1: 
   1:   nsEventStatus status = nsEventStatus_eIgnore;
 238:   nsEventDispatcher::Dispatch(mContent, PresContext(), &event, nsnull,
   1:                               &status);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::ScrollbarButtonPressed(nsISupports* aScrollbar, PRInt32 aOldIndex, PRInt32 aNewIndex)
   1: {
   1:   // Determine which scrollbar we're talking about 
   1:   nsIScrollbarFrame* sf = nsnull;
   1:   CallQueryInterface(aScrollbar, &sf);
   1:   NS_ASSERTION(sf, "scrollbar has no frame");
   1: 
   1:   ScrollParts parts = GetScrollParts();
   1: 
   1:   nsWeakFrame weakFrame(this);
   1:   if (sf == parts.mVScrollbar) {
   1:     if (aNewIndex > aOldIndex)
   1:       ScrollToRowInternal(parts, mTopRowIndex+1);
   1:     else if (aNewIndex < aOldIndex)
   1:       ScrollToRowInternal(parts, mTopRowIndex-1);
   1:   } else {
   1:     ScrollHorzInternal(parts, aNewIndex);
   1:   }
   1: 
   1:   NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
   1:   UpdateScrollbars(parts);
   1: 
   1:   return NS_OK;
   1: }
   1:   
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::PositionChanged(nsISupports* aScrollbar, PRInt32 aOldIndex, PRInt32& aNewIndex)
   1: {
   1:   ScrollParts parts = GetScrollParts();
   1:   
   1:   if (aOldIndex == aNewIndex)
   1:     return NS_OK;
   1: 
   1:   // Determine which scrollbar we're talking about 
   1:   nsIScrollbarFrame* sf = nsnull;
   1:   CallQueryInterface(aScrollbar, &sf);
   1:   NS_ASSERTION(sf, "scrollbar has no frame");
   1: 
   1:   // Vertical Scrollbar 
   1:   if (parts.mVScrollbar == sf) {
   1:     nscoord rh = nsPresContext::AppUnitsToIntCSSPixels(mRowHeight);
   1: 
   1:     nscoord newrow = aNewIndex/rh;
   1:     nsWeakFrame weakFrame(this);
   1:     ScrollInternal(parts, newrow);
   1:     NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
   1: 
   1:     // Go exactly where we're supposed to
   1:     // Update the scrollbar.
   1:     nsAutoString curPos;
   1:     curPos.AppendInt(aNewIndex);
   1:     parts.mVScrollbarContent->SetAttr(kNameSpaceID_None,
   1:                                       nsGkAtoms::curpos, curPos, PR_TRUE);
   1: 
   1:   // Horizontal Scrollbar
   1:   } else if (parts.mHScrollbar == sf) {
   1:     ScrollHorzInternal(parts, aNewIndex);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // The style cache.
   1: nsStyleContext*
   1: nsTreeBodyFrame::GetPseudoStyleContext(nsIAtom* aPseudoElement)
   1: {
 238:   return mStyleCache.GetStyleContext(this, PresContext(), mContent,
   1:                                      mStyleContext, aPseudoElement,
   1:                                      mScratchArray);
   1: }
   1: 
   1: // Our comparator for resolving our complex pseudos
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::PseudoMatches(nsIAtom* aTag, nsCSSSelector* aSelector, PRBool* aResult)
   1: {
   1:   if (aSelector->mTag == aTag) {
   1:     // Iterate the pseudoclass list.  For each item in the list, see if
   1:     // it is contained in our scratch array.  If we have a miss, then
   1:     // we aren't a match.  If all items in the pseudoclass list are
   1:     // present in the scratch array, then we have a match.
   1:     nsAtomStringList* curr = aSelector->mPseudoClassList;
   1:     while (curr) {
   1:       PRInt32 index;
   1:       mScratchArray->GetIndexOf(curr->mAtom, &index);
   1:       if (index == -1) {
   1:         *aResult = PR_FALSE;
   1:         return NS_OK;
   1:       }
   1:       curr = curr->mNext;
   1:     }
   1:     *aResult = PR_TRUE;
   1:   }
   1:   else 
   1:     *aResult = PR_FALSE;
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: nsIContent*
   1: nsTreeBodyFrame::GetBaseElement()
   1: {
 503:   nsIFrame* parent = GetParent();
   1:   while (parent) {
 503:     nsIContent* content = parent->GetContent();
 503:     if (content) {
 503:       nsINodeInfo* ni = content->NodeInfo();
   1: 
   1:       if (ni->Equals(nsGkAtoms::tree, kNameSpaceID_XUL) ||
   1:           (ni->Equals(nsGkAtoms::select) &&
 503:            content->IsNodeOfType(nsINode::eHTML)))
 503:         return content;
   1:     }
   1: 
   1:     parent = parent->GetParent();
   1:   }
   1: 
 503:   return nsnull;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsTreeBodyFrame::ClearStyleAndImageCaches()
   1: {
   1:   mStyleCache.Clear();
   1:   mImageCache.EnumerateRead(CancelImageRequest, nsnull);
   1:   mImageCache.Clear();
   1:   return NS_OK;
   1: }
   1: 
   1: PRBool 
   1: nsTreeBodyFrame::OffsetForHorzScroll(nsRect& rect, PRBool clip)
   1: {
   1:   rect.x -= mHorzPosition;
   1: 
   1:   // Scrolled out before
   1:   if (rect.XMost() <= mInnerBox.x)
   1:     return PR_FALSE;
   1: 
   1:   // Scrolled out after
   1:   if (rect.x > mInnerBox.XMost())
   1:     return PR_FALSE;
   1: 
   1:   if (clip) {
   1:     nscoord leftEdge = PR_MAX(rect.x, mInnerBox.x);
   1:     nscoord rightEdge = PR_MIN(rect.XMost(), mInnerBox.XMost());
   1:     rect.x = leftEdge;
   1:     rect.width = rightEdge - leftEdge;
   1: 
   1:     // Should have returned false above
   1:     NS_ASSERTION(rect.width >= 0, "horz scroll code out of sync");
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: PRBool
   1: nsTreeBodyFrame::CanAutoScroll(PRInt32 aRowIndex)
   1: {
   1:   // Check first for partially visible last row.
   1:   if (aRowIndex == mRowCount - 1) {
   1:     nscoord y = mInnerBox.y + (aRowIndex - mTopRowIndex) * mRowHeight;
   1:     if (y < mInnerBox.height && y + mRowHeight > mInnerBox.height)
   1:       return PR_TRUE;
   1:   }
   1: 
   1:   if (aRowIndex > 0 && aRowIndex < mRowCount - 1)
   1:     return PR_TRUE;
   1: 
   1:   return PR_FALSE;
   1: }
   1: 
   1: // Given a dom event, figure out which row in the tree the mouse is over,
   1: // if we should drop before/after/on that row or we should auto-scroll.
   1: // Doesn't query the content about if the drag is allowable, that's done elsewhere.
   1: //
   1: // For containers, we break up the vertical space of the row as follows: if in
   1: // the topmost 25%, the drop is _before_ the row the mouse is over; if in the
   1: // last 25%, _after_; in the middle 50%, we consider it a drop _on_ the container.
   1: //
   1: // For non-containers, if the mouse is in the top 50% of the row, the drop is
   1: // _before_ and the bottom 50% _after_
   1: void 
   1: nsTreeBodyFrame::ComputeDropPosition(nsGUIEvent* aEvent, PRInt32* aRow, PRInt16* aOrient,
   1:                                      PRInt16* aScrollLines)
   1: {
   1:   *aOrient = -1;
   1:   *aScrollLines = 0;
   1: 
   1:   // Convert the event's point to our coordinates.  We want it in
   1:   // the coordinates of our inner box's coordinates.
   1:   nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
   1:   PRInt32 xTwips = pt.x - mInnerBox.x;
   1:   PRInt32 yTwips = pt.y - mInnerBox.y;
   1: 
   1:   *aRow = GetRowAt(xTwips, yTwips);
   1:   if (*aRow >=0) {
   1:     // Compute the top/bottom of the row in question.
   1:     PRInt32 yOffset = yTwips - mRowHeight * (*aRow - mTopRowIndex);
   1:    
   1:     PRBool isContainer = PR_FALSE;
   1:     mView->IsContainer (*aRow, &isContainer);
   1:     if (isContainer) {
   1:       // for a container, use a 25%/50%/25% breakdown
   1:       if (yOffset < mRowHeight / 4)
   1:         *aOrient = nsITreeView::DROP_BEFORE;
   1:       else if (yOffset > mRowHeight - (mRowHeight / 4))
   1:         *aOrient = nsITreeView::DROP_AFTER;
   1:       else
   1:         *aOrient = nsITreeView::DROP_ON;
   1:     }
   1:     else {
   1:       // for a non-container use a 50%/50% breakdown
   1:       if (yOffset < mRowHeight / 2)
   1:         *aOrient = nsITreeView::DROP_BEFORE;
   1:       else
   1:         *aOrient = nsITreeView::DROP_AFTER;
   1:     }
   1:   }
   1: 
   1:   if (CanAutoScroll(*aRow)) {
   1:     // Get the max value from the look and feel service.
   1:     PRInt32 scrollLinesMax = 0;
 238:     PresContext()->LookAndFeel()->
   1:       GetMetric(nsILookAndFeel::eMetric_TreeScrollLinesMax, scrollLinesMax);
   1:     scrollLinesMax--;
   1:     if (scrollLinesMax < 0)
   1:       scrollLinesMax = 0;
   1: 
   1:     // Determine if we're w/in a margin of the top/bottom of the tree during a drag.
   1:     // This will ultimately cause us to scroll, but that's done elsewhere.
   1:     nscoord height = (3 * mRowHeight) / 4;
   1:     if (yTwips < height) {
   1:       // scroll up
   1:       *aScrollLines = NSToIntRound(-scrollLinesMax * (1 - (float)yTwips / height) - 1);
   1:     }
   1:     else if (yTwips > mRect.height - height) {
   1:       // scroll down
   1:       *aScrollLines = NSToIntRound(scrollLinesMax * (1 - (float)(mRect.height - yTwips) / height) + 1);
   1:     }
   1:   }
   1: } // ComputeDropPosition
   1: 
   1: void
   1: nsTreeBodyFrame::OpenCallback(nsITimer *aTimer, void *aClosure)
   1: {
   1:   nsTreeBodyFrame* self = NS_STATIC_CAST(nsTreeBodyFrame*, aClosure);
   1:   if (self) {
   1:     aTimer->Cancel();
   1:     self->mSlots->mTimer = nsnull;
   1: 
   1:     if (self->mSlots->mDropRow >= 0) {
   1:       self->mSlots->mValueArray.AppendValue(self->mSlots->mDropRow);
   1:       self->mView->ToggleOpenState(self->mSlots->mDropRow);
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::CloseCallback(nsITimer *aTimer, void *aClosure)
   1: {
   1:   nsTreeBodyFrame* self = NS_STATIC_CAST(nsTreeBodyFrame*, aClosure);
   1:   if (self) {
   1:     aTimer->Cancel();
   1:     self->mSlots->mTimer = nsnull;
   1: 
   1:     for (PRInt32 i = self->mSlots->mValueArray.Count() - 1; i >= 0; i--) {
   1:       if (self->mView)
   1:         self->mView->ToggleOpenState(self->mSlots->mValueArray[i]);
   1:       self->mSlots->mValueArray.RemoveValueAt(i);
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::LazyScrollCallback(nsITimer *aTimer, void *aClosure)
   1: {
   1:   nsTreeBodyFrame* self = NS_STATIC_CAST(nsTreeBodyFrame*, aClosure);
   1:   if (self) {
   1:     aTimer->Cancel();
   1:     self->mSlots->mTimer = nsnull;
   1: 
   1:     if (self->mView) {
   1:       self->ScrollByLines(self->mSlots->mScrollLines);
   1:       // Set a new timer to scroll the tree repeatedly.
   1:       self->CreateTimer(nsILookAndFeel::eMetric_TreeScrollDelay,
   1:                         ScrollCallback, nsITimer::TYPE_REPEATING_SLACK,
   1:                         getter_AddRefs(self->mSlots->mTimer));
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsTreeBodyFrame::ScrollCallback(nsITimer *aTimer, void *aClosure)
   1: {
   1:   nsTreeBodyFrame* self = NS_STATIC_CAST(nsTreeBodyFrame*, aClosure);
   1:   if (self) {
   1:     // Don't scroll if we are already at the top or bottom of the view.
   1:     if (self->mView && self->CanAutoScroll(self->mSlots->mDropRow)) {
   1:       self->ScrollByLines(self->mSlots->mScrollLines);
   1:     }
   1:     else {
   1:       aTimer->Cancel();
   1:       self->mSlots->mTimer = nsnull;
   1:     }
   1:   }
   1: }
