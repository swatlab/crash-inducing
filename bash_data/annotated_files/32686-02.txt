29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS atom table.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jshash.h" /* Added by JSIFY */
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsatom.h"
27012: #include "jsbit.h"
    1: #include "jscntxt.h"
    1: #include "jsgc.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
27012: #include "jsparse.h"
    1: #include "jsscan.h"
    1: #include "jsstr.h"
27012: #include "jsversion.h"
32607: #include "jsstrinlines.h"
    1: 
25901: /*
25901:  * ATOM_HASH assumes that JSHashNumber is 32-bit even on 64-bit systems.
25901:  */
25901: JS_STATIC_ASSERT(sizeof(JSHashNumber) == 4);
25901: JS_STATIC_ASSERT(sizeof(JSAtom *) == JS_BYTES_PER_WORD);
25901: 
25901: /*
25901:  * Start and limit offsets for atom pointers in JSAtomState must be aligned
25901:  * on the word boundary.
25901:  */
25901: JS_STATIC_ASSERT(ATOM_OFFSET_START % sizeof(JSAtom *) == 0);
25901: JS_STATIC_ASSERT(ATOM_OFFSET_LIMIT % sizeof(JSAtom *) == 0);
25901: 
25901: /*
25901:  * JS_BOOLEAN_STR and JS_TYPE_STR assume that boolean names starts from the
25901:  * index 1 and type name starts from the index 1+2 atoms in JSAtomState.
25901:  */
25901: JS_STATIC_ASSERT(1 * sizeof(JSAtom *) ==
25901:                  offsetof(JSAtomState, booleanAtoms) - ATOM_OFFSET_START);
25901: JS_STATIC_ASSERT((1 + 2) * sizeof(JSAtom *) ==
25901:                  offsetof(JSAtomState, typeAtoms) - ATOM_OFFSET_START);
25901: 
10444: const char *
    1: js_AtomToPrintableString(JSContext *cx, JSAtom *atom)
    1: {
    1:     return js_ValueToPrintableString(cx, ATOM_KEY(atom));
    1: }
    1: 
    1: #define JS_PROTO(name,code,init) const char js_##name##_str[] = #name;
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: 
 4342: /*
21447:  * String constants for common atoms defined in JSAtomState starting from
 4342:  * JSAtomState.emptyAtom until JSAtomState.lazy.
 4342:  *
 4342:  * The elements of the array after the first empty string define strings
21447:  * corresponding to the two boolean literals, false and true, followed by the
21447:  * JSType enumerators from jspubtd.h starting with "undefined" for JSTYPE_VOID
31521:  * (which is special-value 2) and continuing as initialized below. The static
21447:  * asserts check these relations.
 4342:  */
 4342: JS_STATIC_ASSERT(JSTYPE_LIMIT == 8);
21447: JS_STATIC_ASSERT(JSTYPE_VOID == 0);
21447: 
 4342: const char *const js_common_atom_names[] = {
 4342:     "",                         /* emptyAtom                    */
21447:     js_false_str,               /* booleanAtoms[0]              */
21447:     js_true_str,                /* booleanAtoms[1]              */
 4342:     js_undefined_str,           /* typeAtoms[JSTYPE_VOID]       */
 4342:     js_object_str,              /* typeAtoms[JSTYPE_OBJECT]     */
 4342:     js_function_str,            /* typeAtoms[JSTYPE_FUNCTION]   */
 4342:     "string",                   /* typeAtoms[JSTYPE_STRING]     */
 4342:     "number",                   /* typeAtoms[JSTYPE_NUMBER]     */
 4342:     "boolean",                  /* typeAtoms[JSTYPE_BOOLEAN]    */
 4342:     js_null_str,                /* typeAtoms[JSTYPE_NULL]       */
 4342:     "xml",                      /* typeAtoms[JSTYPE_XML]        */
 4342:     js_null_str,                /* nullAtom                     */
 4342: 
    1: #define JS_PROTO(name,code,init) js_##name##_str,
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
 4342: 
 4342:     js_anonymous_str,           /* anonymousAtom                */
21452:     js_apply_str,               /* applyAtom                    */
 4342:     js_arguments_str,           /* argumentsAtom                */
 4342:     js_arity_str,               /* arityAtom                    */
21473:     js_call_str,                /* callAtom                     */
 4342:     js_callee_str,              /* calleeAtom                   */
 4342:     js_caller_str,              /* callerAtom                   */
 4342:     js_class_prototype_str,     /* classPrototypeAtom           */
 4342:     js_constructor_str,         /* constructorAtom              */
 4342:     js_count_str,               /* countAtom                    */
 4342:     js_each_str,                /* eachAtom                     */
 4342:     js_eval_str,                /* evalAtom                     */
 4342:     js_fileName_str,            /* fileNameAtom                 */
 4342:     js_get_str,                 /* getAtom                      */
 4342:     js_getter_str,              /* getterAtom                   */
 4342:     js_index_str,               /* indexAtom                    */
 4342:     js_input_str,               /* inputAtom                    */
 4342:     js_iterator_str,            /* iteratorAtom                 */
 4342:     js_length_str,              /* lengthAtom                   */
 4342:     js_lineNumber_str,          /* lineNumberAtom               */
 4342:     js_message_str,             /* messageAtom                  */
 4342:     js_name_str,                /* nameAtom                     */
 4342:     js_next_str,                /* nextAtom                     */
 4342:     js_noSuchMethod_str,        /* noSuchMethodAtom             */
 4342:     js_parent_str,              /* parentAtom                   */
 4342:     js_proto_str,               /* protoAtom                    */
 4342:     js_set_str,                 /* setAtom                      */
 4342:     js_setter_str,              /* setterAtom                   */
 4342:     js_stack_str,               /* stackAtom                    */
 4342:     js_toLocaleString_str,      /* toLocaleStringAtom           */
 4342:     js_toSource_str,            /* toSourceAtom                 */
 4342:     js_toString_str,            /* toStringAtom                 */
 4342:     js_valueOf_str,             /* valueOfAtom                  */
20092:     js_toJSON_str,              /* toJSONAtom                   */
 4342:     "(void 0)",                 /* void0Atom                    */
 4342: 
 4342: #if JS_HAS_XML_SUPPORT
 4342:     js_etago_str,               /* etagoAtom                    */
 4342:     js_namespace_str,           /* namespaceAtom                */
 4342:     js_ptagc_str,               /* ptagcAtom                    */
 4342:     js_qualifier_str,           /* qualifierAtom                */
 4342:     js_space_str,               /* spaceAtom                    */
 4342:     js_stago_str,               /* stagoAtom                    */
 4342:     js_star_str,                /* starAtom                     */
 4342:     js_starQualifier_str,       /* starQualifierAtom            */
 4342:     js_tagc_str,                /* tagcAtom                     */
 4342:     js_xml_str,                 /* xmlAtom                      */
 4342: #endif
 4342: 
 4342: #ifdef NARCISSUS
21471:     js___call___str,            /* __call__Atom                 */
21471:     js___construct___str,       /* __construct__Atom            */
21471:     js___hasInstance___str,     /* __hasInstance__Atom          */
 4342:     js_ExecutionContext_str,    /* ExecutionContextAtom         */
 4342:     js_current_str,             /* currentAtom                  */
 4342: #endif
    1: };
21685: 
 4342: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(js_common_atom_names) * sizeof(JSAtom *) ==
 4342:                  LAZY_ATOM_OFFSET_START - ATOM_OFFSET_START);
    1: 
21685: /*
21685:  * Interpreter macros called by the trace recorder assume common atom indexes
21685:  * fit in one byte of immediate operand.
21685:  */
21685: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(js_common_atom_names) < 256);
21685: 
21685: const size_t js_common_atom_count = JS_ARRAY_LENGTH(js_common_atom_names);
21685: 
    1: const char js_anonymous_str[]       = "anonymous";
21452: const char js_apply_str[]           = "apply";
    1: const char js_arguments_str[]       = "arguments";
    1: const char js_arity_str[]           = "arity";
21473: const char js_call_str[]            = "call";
    1: const char js_callee_str[]          = "callee";
    1: const char js_caller_str[]          = "caller";
    1: const char js_class_prototype_str[] = "prototype";
    1: const char js_constructor_str[]     = "constructor";
    1: const char js_count_str[]           = "__count__";
    1: const char js_each_str[]            = "each";
    1: const char js_eval_str[]            = "eval";
    1: const char js_fileName_str[]        = "fileName";
    1: const char js_get_str[]             = "get";
    1: const char js_getter_str[]          = "getter";
    1: const char js_index_str[]           = "index";
    1: const char js_input_str[]           = "input";
    1: const char js_iterator_str[]        = "__iterator__";
    1: const char js_length_str[]          = "length";
    1: const char js_lineNumber_str[]      = "lineNumber";
    1: const char js_message_str[]         = "message";
    1: const char js_name_str[]            = "name";
    1: const char js_next_str[]            = "next";
    1: const char js_noSuchMethod_str[]    = "__noSuchMethod__";
    1: const char js_object_str[]          = "object";
    1: const char js_parent_str[]          = "__parent__";
    1: const char js_proto_str[]           = "__proto__";
    1: const char js_setter_str[]          = "setter";
    1: const char js_set_str[]             = "set";
    1: const char js_stack_str[]           = "stack";
    1: const char js_toSource_str[]        = "toSource";
    1: const char js_toString_str[]        = "toString";
    1: const char js_toLocaleString_str[]  = "toLocaleString";
 4342: const char js_undefined_str[]       = "undefined";
    1: const char js_valueOf_str[]         = "valueOf";
20092: const char js_toJSON_str[]          = "toJSON";
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: const char js_etago_str[]           = "</";
    1: const char js_namespace_str[]       = "namespace";
    1: const char js_ptagc_str[]           = "/>";
    1: const char js_qualifier_str[]       = "::";
    1: const char js_space_str[]           = " ";
    1: const char js_stago_str[]           = "<";
    1: const char js_star_str[]            = "*";
    1: const char js_starQualifier_str[]   = "*::";
    1: const char js_tagc_str[]            = ">";
    1: const char js_xml_str[]             = "xml";
    1: #endif
    1: 
    1: #if JS_HAS_GENERATORS
    1: const char js_close_str[]           = "close";
    1: const char js_send_str[]            = "send";
    1: #endif
    1: 
    1: #ifdef NARCISSUS
21471: const char js___call___str[]         = "__call__";
21471: const char js___construct___str[]    = "__construct__";
21471: const char js___hasInstance___str[]  = "__hasInstance__";
    1: const char js_ExecutionContext_str[] = "ExecutionContext";
    1: const char js_current_str[]          = "current";
    1: #endif
    1: 
 4529: /*
 4529:  * JSAtomState.doubleAtoms and JSAtomState.stringAtoms hashtable entry. To
 4529:  * support pinned and interned string atoms, we use the lowest bits of the
 4529:  * keyAndFlags field to store ATOM_PINNED and ATOM_INTERNED flags.
 4529:  */
 4529: typedef struct JSAtomHashEntry {
 4529:     JSDHashEntryHdr hdr;
 4529:     jsuword         keyAndFlags;
 4529: } JSAtomHashEntry;
    1: 
 4529: #define ATOM_ENTRY_FLAG_MASK            (ATOM_PINNED | ATOM_INTERNED)
 4529: 
 4529: JS_STATIC_ASSERT(ATOM_ENTRY_FLAG_MASK < JSVAL_ALIGN);
 4529: 
 4529: /*
 4529:  * Helper macros to access and modify JSAtomHashEntry.
 4529:  */
 4529: #define TO_ATOM_ENTRY(hdr)              ((JSAtomHashEntry *) hdr)
 4529: #define ATOM_ENTRY_KEY(entry)                                                 \
 4529:     ((void *)((entry)->keyAndFlags & ~ATOM_ENTRY_FLAG_MASK))
 4529: #define ATOM_ENTRY_FLAGS(entry)                                               \
 4529:     ((uintN)((entry)->keyAndFlags & ATOM_ENTRY_FLAG_MASK))
 4529: #define INIT_ATOM_ENTRY(entry, key)                                           \
 4529:     ((void)((entry)->keyAndFlags = (jsuword)(key)))
 4529: #define ADD_ATOM_ENTRY_FLAGS(entry, flags)                                    \
 4529:     ((void)((entry)->keyAndFlags |= (jsuword)(flags)))
 4529: #define CLEAR_ATOM_ENTRY_FLAGS(entry, flags)                                  \
 4529:     ((void)((entry)->keyAndFlags &= ~(jsuword)(flags)))
 4529: 
18907: static JSDHashNumber
 5211: HashDouble(JSDHashTable *table, const void *key);
 5211: 
18907: static JSBool
 5211: MatchDouble(JSDHashTable *table, const JSDHashEntryHdr *hdr, const void *key);
 5211: 
18907: static JSDHashNumber
 5211: HashString(JSDHashTable *table, const void *key);
 5211: 
18907: static JSBool
 5211: MatchString(JSDHashTable *table, const JSDHashEntryHdr *hdr, const void *key);
 5211: 
 5211: static const JSDHashTableOps DoubleHashOps = {
 5211:     JS_DHashAllocTable,
 5211:     JS_DHashFreeTable,
 5211:     HashDouble,
 5211:     MatchDouble,
 5211:     JS_DHashMoveEntryStub,
 5211:     JS_DHashClearEntryStub,
 5211:     JS_DHashFinalizeStub,
 5211:     NULL
 5211: };
 5211: 
 5211: static const JSDHashTableOps StringHashOps = {
 5211:     JS_DHashAllocTable,
 5211:     JS_DHashFreeTable,
 5211:     HashString,
 5211:     MatchString,
 5211:     JS_DHashMoveEntryStub,
 5211:     JS_DHashClearEntryStub,
 5211:     JS_DHashFinalizeStub,
 5211:     NULL
 5211: };
 4529: 
 4529: #define IS_DOUBLE_TABLE(table)      ((table)->ops == &DoubleHashOps)
 4529: #define IS_STRING_TABLE(table)      ((table)->ops == &StringHashOps)
 4529: 
 4529: #define IS_INITIALIZED_STATE(state) IS_DOUBLE_TABLE(&(state)->doubleAtoms)
 4529: 
18907: static JSDHashNumber
 4529: HashDouble(JSDHashTable *table, const void *key)
    1: {
 4529:     JS_ASSERT(IS_DOUBLE_TABLE(table));
32586:     return JS_HASH_DOUBLE(*(jsdouble *)key);
    1: }
    1: 
18907: static JSDHashNumber
 4529: HashString(JSDHashTable *table, const void *key)
    1: {
 4529:     JS_ASSERT(IS_STRING_TABLE(table));
 4529:     return js_HashString((JSString *)key);
 4529: }
    1: 
18907: static JSBool
 4529: MatchDouble(JSDHashTable *table, const JSDHashEntryHdr *hdr, const void *key)
 4529: {
 4529:     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
 4529:     jsdouble d1, d2;
 4529: 
 4529:     JS_ASSERT(IS_DOUBLE_TABLE(table));
 4529:     if (entry->keyAndFlags == 0) {
 4529:         /* See comments in MatchString. */
 4529:         return JS_FALSE;
 4529:     }
 4529: 
 4529:     d1 = *(jsdouble *)ATOM_ENTRY_KEY(entry);
 4529:     d2 = *(jsdouble *)key;
    1:     if (JSDOUBLE_IS_NaN(d1))
    1:         return JSDOUBLE_IS_NaN(d2);
    1: #if defined(XP_WIN)
    1:     /* XXX MSVC miscompiles such that (NaN == 0) */
    1:     if (JSDOUBLE_IS_NaN(d2))
    1:         return JS_FALSE;
    1: #endif
    1:     return d1 == d2;
    1: }
 4529: 
18907: static JSBool
 4529: MatchString(JSDHashTable *table, const JSDHashEntryHdr *hdr, const void *key)
 4529: {
 4529:     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
 4529: 
 4529:     JS_ASSERT(IS_STRING_TABLE(table));
 4529:     if (entry->keyAndFlags == 0) {
 4529:         /*
 4529:          * This happens when js_AtomizeString adds a new hash entry and
 4529:          * releases the lock but before it takes the lock the second time to
 4529:          * initialize keyAndFlags for the entry.
 4529:          *
 4529:          * We always return false for such entries so JS_DHashTableOperate
 4529:          * never finds them. We clean them during GC's sweep phase.
 4529:          *
 4529:          * It means that with a contested lock or when GC is triggered outside
 4529:          * the lock we may end up adding two entries, but this is a price for
 4529:          * simpler code.
 4529:          */
 4529:         return JS_FALSE;
 4529:     }
 4529:     return js_EqualStrings((JSString *)ATOM_ENTRY_KEY(entry), (JSString *)key);
    1: }
    1: 
 4529: /*
 4529:  * For a browser build from 2007-08-09 after the browser starts up there are
 4529:  * just 55 double atoms, but over 15000 string atoms. Not to penalize more
 4529:  * economical embeddings allocating too much memory initially we initialize
 4529:  * atomized strings with just 1K entries.
 4529:  */
 4529: #define JS_STRING_HASH_COUNT   1024
 4529: #define JS_DOUBLE_HASH_COUNT   64
    1: 
    1: JSBool
 4342: js_InitAtomState(JSRuntime *rt)
    1: {
 4342:     JSAtomState *state = &rt->atomState;
 4342: 
 4342:    /*
 4342:     * The caller must zero the state before calling this function.
 4342:     */
 4529:     JS_ASSERT(!state->stringAtoms.ops);
 4529:     JS_ASSERT(!state->doubleAtoms.ops);
 4342: 
 4529:     if (!JS_DHashTableInit(&state->stringAtoms, &StringHashOps,
 4529:                            NULL, sizeof(JSAtomHashEntry),
 4529:                            JS_DHASH_DEFAULT_CAPACITY(JS_STRING_HASH_COUNT))) {
 4529:         state->stringAtoms.ops = NULL;
    1:         return JS_FALSE;
    1:     }
 4529:     JS_ASSERT(IS_STRING_TABLE(&state->stringAtoms));
    1: 
 4529:     if (!JS_DHashTableInit(&state->doubleAtoms, &DoubleHashOps,
 4529:                            NULL, sizeof(JSAtomHashEntry),
 4529:                            JS_DHASH_DEFAULT_CAPACITY(JS_DOUBLE_HASH_COUNT))) {
 4529:         state->doubleAtoms.ops = NULL;
 4529:         JS_DHashTableFinish(&state->stringAtoms);
 4529:         state->stringAtoms.ops = NULL;
 4529:         return JS_FALSE;
 4529:     }
 4529:     JS_ASSERT(IS_DOUBLE_TABLE(&state->doubleAtoms));
    1: 
    1: #ifdef JS_THREADSAFE
    1:     js_InitLock(&state->lock);
    1: #endif
 4529:     JS_ASSERT(IS_INITIALIZED_STATE(state));
    1:     return JS_TRUE;
    1: }
    1: 
18907: static JSDHashOperator
 4529: js_string_uninterner(JSDHashTable *table, JSDHashEntryHdr *hdr,
 4529:                      uint32 number, void *arg)
    1: {
 4529:     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
 4529:     JSRuntime *rt = (JSRuntime *)arg;
 6117:     JSString *str;
    1: 
 4529:     /*
 4529:      * Any string entry that remains at this point must be initialized, as the
 4529:      * last GC should clean any uninitialized ones.
 4529:      */
 4529:     JS_ASSERT(IS_STRING_TABLE(table));
 4529:     JS_ASSERT(entry->keyAndFlags != 0);
 6117:     str = (JSString *)ATOM_ENTRY_KEY(entry);
 6117: 
 6117:     /* Pass null as context. */
 8005:     js_FinalizeStringRT(rt, str, js_GetExternalStringGCType(str), NULL);
 4529:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: void
 4342: js_FinishAtomState(JSRuntime *rt)
    1: {
 4342:     JSAtomState *state = &rt->atomState;
 4342: 
 4529:     if (!IS_INITIALIZED_STATE(state)) {
 4342:         /*
 4529:          * We are called with uninitialized state when JS_NewRuntime fails and
 4529:          * calls JS_DestroyRuntime on a partially initialized runtime.
 4342:          */
    1:         return;
 4342:     }
 4342: 
 4529:     JS_DHashTableEnumerate(&state->stringAtoms, js_string_uninterner, rt);
 4529:     JS_DHashTableFinish(&state->stringAtoms);
 4529:     JS_DHashTableFinish(&state->doubleAtoms);
 4529: 
 4342: #ifdef JS_THREADSAFE
 4342:     js_FinishLock(&state->lock);
 4342: #endif
 4342: #ifdef DEBUG
 4342:     memset(state, JS_FREE_PATTERN, sizeof *state);
 4342: #endif
 4342: }
 4342: 
    1: JSBool
 4342: js_InitCommonAtoms(JSContext *cx)
    1: {
 4342:     JSAtomState *state = &cx->runtime->atomState;
    1:     uintN i;
 4342:     JSAtom **atoms;
    1: 
 4529:     atoms = COMMON_ATOMS_START(state);
 4342:     for (i = 0; i < JS_ARRAY_LENGTH(js_common_atom_names); i++, atoms++) {
 4342:         *atoms = js_Atomize(cx, js_common_atom_names[i],
 4342:                             strlen(js_common_atom_names[i]), ATOM_PINNED);
 4342:         if (!*atoms)
 4342:             return JS_FALSE;
 4342:     }
 4342:     JS_ASSERT((uint8 *)atoms - (uint8 *)state == LAZY_ATOM_OFFSET_START);
 4342:     memset(atoms, 0, ATOM_OFFSET_LIMIT - LAZY_ATOM_OFFSET_START);
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
18907: static JSDHashOperator
 4529: js_atom_unpinner(JSDHashTable *table, JSDHashEntryHdr *hdr,
 4529:                  uint32 number, void *arg)
    1: {
 4529:     JS_ASSERT(IS_STRING_TABLE(table));
 4529:     CLEAR_ATOM_ENTRY_FLAGS(TO_ATOM_ENTRY(hdr), ATOM_PINNED);
 4529:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: void
 4342: js_FinishCommonAtoms(JSContext *cx)
    1: {
 4342:     JSAtomState *state = &cx->runtime->atomState;
 4342: 
 4529:     JS_DHashTableEnumerate(&state->stringAtoms, js_atom_unpinner, NULL);
 4342: #ifdef DEBUG
 4529:     memset(COMMON_ATOMS_START(state), JS_FREE_PATTERN,
 4342:            ATOM_OFFSET_LIMIT - ATOM_OFFSET_START);
 4342: #endif
    1: }
    1: 
18907: static JSDHashOperator
 4529: js_locked_atom_tracer(JSDHashTable *table, JSDHashEntryHdr *hdr,
 4529:                       uint32 number, void *arg)
  583: {
 4529:     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
 4529:     JSTracer *trc = (JSTracer *)arg;
  583: 
 4529:     if (entry->keyAndFlags == 0) {
 4529:         /* Ignore uninitialized entries during tracing. */
 4529:         return JS_DHASH_NEXT;
 4529:     }
 4529:     JS_SET_TRACING_INDEX(trc, "locked_atom", (size_t)number);
 4529:     JS_CallTracer(trc, ATOM_ENTRY_KEY(entry),
 4529:                   IS_STRING_TABLE(table) ? JSTRACE_STRING : JSTRACE_DOUBLE);
 4529:     return JS_DHASH_NEXT;
  583: }
  583: 
18907: static JSDHashOperator
 4529: js_pinned_atom_tracer(JSDHashTable *table, JSDHashEntryHdr *hdr,
 4529:                         uint32 number, void *arg)
 4529: {
 4529:     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
 4529:     JSTracer *trc = (JSTracer *)arg;
 4529:     uintN flags = ATOM_ENTRY_FLAGS(entry);
    1: 
 4529:     JS_ASSERT(IS_STRING_TABLE(table));
 4529:     if (flags & (ATOM_PINNED | ATOM_INTERNED)) {
 4529:         JS_SET_TRACING_INDEX(trc,
 4529:                              flags & ATOM_PINNED
  583:                              ? "pinned_atom"
 4529:                              : "interned_atom",
 4529:                              (size_t)number);
 4529:         JS_CallTracer(trc, ATOM_ENTRY_KEY(entry), JSTRACE_STRING);
    1:     }
 4529:     return JS_DHASH_NEXT;
    1: }
    1: 
  583: void
 4529: js_TraceAtomState(JSTracer *trc, JSBool allAtoms)
  583: {
31932:     JSRuntime *rt = trc->context->runtime;
31932:     JSAtomState *state = &rt->atomState;
  583: 
 4529:     if (allAtoms) {
 4529:         JS_DHashTableEnumerate(&state->doubleAtoms, js_locked_atom_tracer, trc);
 4529:         JS_DHashTableEnumerate(&state->stringAtoms, js_locked_atom_tracer, trc);
 4529:     } else {
 4529:         JS_DHashTableEnumerate(&state->stringAtoms, js_pinned_atom_tracer, trc);
 4529:     }
  583: }
  583: 
18907: static JSDHashOperator
 4529: js_atom_sweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
 4529:                 uint32 number, void *arg)
    1: {
 4529:     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
 4529:     JSContext *cx = (JSContext *)arg;
    1: 
 4529:     /* Remove uninitialized entries.  */
 4529:     if (entry->keyAndFlags == 0)
 4529:         return JS_DHASH_REMOVE;
    1: 
 4529:     if (ATOM_ENTRY_FLAGS(entry) & (ATOM_PINNED | ATOM_INTERNED)) {
 4529:         /* Pinned or interned key cannot be finalized. */
 4529:         JS_ASSERT(!js_IsAboutToBeFinalized(cx, ATOM_ENTRY_KEY(entry)));
 4529:     } else if (js_IsAboutToBeFinalized(cx, ATOM_ENTRY_KEY(entry))) {
 4529:         /* Remove entries with things about to be GC'ed. */
 4529:         return JS_DHASH_REMOVE;
    1:     }
 4529:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: void
 4342: js_SweepAtomState(JSContext *cx)
    1: {
 4342:     JSAtomState *state = &cx->runtime->atomState;
    1: 
 4529:     JS_DHashTableEnumerate(&state->doubleAtoms, js_atom_sweeper, cx);
 4529:     JS_DHashTableEnumerate(&state->stringAtoms, js_atom_sweeper, cx);
 4529: 
 4529:     /*
11238:      * Optimize for simplicity and mutate table generation numbers even if the
11238:      * sweeper has not removed any entries.
 4529:      */
11238:     state->doubleAtoms.generation++;
11238:     state->stringAtoms.generation++;
    1: }
    1: 
    1: JSAtom *
 3328: js_AtomizeDouble(JSContext *cx, jsdouble d)
    1: {
    1:     JSAtomState *state;
 4529:     JSDHashTable *table;
 4529:     JSAtomHashEntry *entry;
 4529:     uint32 gen;
 4529:     jsdouble *key;
 4529:     jsval v;
    1: 
    1:     state = &cx->runtime->atomState;
 4529:     table = &state->doubleAtoms;
 4529: 
15994:     JS_LOCK(cx, &state->lock);
 4529:     entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, &d, JS_DHASH_ADD));
 4529:     if (!entry)
 4529:         goto failed_hash_add;
 4529:     if (entry->keyAndFlags == 0) {
11238:         gen = ++table->generation;
15994:         JS_UNLOCK(cx, &state->lock);
 4529: 
12850:         key = js_NewWeaklyRootedDouble(cx, d);
 4529:         if (!key)
    1:             return NULL;
 4529: 
15994:         JS_LOCK(cx, &state->lock);
11238:         if (table->generation == gen) {
 4529:             JS_ASSERT(entry->keyAndFlags == 0);
 4529:         } else {
 4529:             entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, key,
 4529:                                                        JS_DHASH_ADD));
 4529:             if (!entry)
 4529:                 goto failed_hash_add;
 4529:             if (entry->keyAndFlags != 0)
 4529:                 goto finish;
11238:             ++table->generation;
    1:         }
 4529:         INIT_ATOM_ENTRY(entry, key);
    1:     }
    1: 
 4529:   finish:
 4529:     v = DOUBLE_TO_JSVAL((jsdouble *)ATOM_ENTRY_KEY(entry));
 4529:     cx->weakRoots.lastAtom = v;
15994:     JS_UNLOCK(cx, &state->lock);
 4529: 
 4529:     return (JSAtom *)v;
 4529: 
 4529:   failed_hash_add:
15994:     JS_UNLOCK(cx, &state->lock);
    1:     JS_ReportOutOfMemory(cx);
 4342:     return NULL;
    1: }
    1: 
    1: JSAtom *
    1: js_AtomizeString(JSContext *cx, JSString *str, uintN flags)
    1: {
10444:     jsval v;
    1:     JSAtomState *state;
 4529:     JSDHashTable *table;
 4529:     JSAtomHashEntry *entry;
 4529:     JSString *key;
 4342:     uint32 gen;
    1: 
10444:     JS_ASSERT(!(flags & ~(ATOM_PINNED|ATOM_INTERNED|ATOM_TMPSTR|ATOM_NOCOPY)));
10444:     JS_ASSERT_IF(flags & ATOM_NOCOPY, flags & ATOM_TMPSTR);
10444: 
32686:     if (str->isAtomized())
32686:         return (JSAtom *) STRING_TO_JSVAL(str);
32686: 
32686:     size_t length = str->length();
32686:     if (length == 1) {
31905:         jschar c = str->chars()[0];
32674:         if (c < UNIT_STRING_LIMIT)
32674:             return (JSAtom *) STRING_TO_JSVAL(JSString::unitString(c));
31905:     }
31905: 
32686:     /*
32686:      * Here we know that JSString::intStringTable covers only 256 (or at least
32686:      * not 1000 or more) chars. We rely on order here to resolve the unit vs.
32686:      * int string atom identity issue by giving priority to unit strings for
32686:      * '0' through '9' (see JSString::intString in jsstrinlines.h).
32686:      */
32686:     JS_STATIC_ASSERT(INT_STRING_LIMIT <= 999);
32686:     if (2 <= length && length <= 3) {
32686:         const jschar *chars = str->chars();
32686: 
32686:         if ('0' <= chars[0] && chars[0] <= '9' &&
32686:             '0' <= chars[1] && chars[1] <= '9' &&
32686:             (length == 2 || ('0' <= chars[2] && chars[2] <= '9'))) {
32686:             jsint i = (chars[0] - '0') * 10 + chars[1] - '0';
32686: 
32686:             if (length == 3)
32686:                 i = i * 10 + chars[2] - '0'; 
32686:             if (jsuint(i) < INT_STRING_LIMIT)
32686:                 return (JSAtom *) STRING_TO_JSVAL(JSString::intString(i));
32686:         }
32686:     }
32686: 
    1:     state = &cx->runtime->atomState;
 4529:     table = &state->stringAtoms;
 4342: 
15994:     JS_LOCK(cx, &state->lock);
 4529:     entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, str, JS_DHASH_ADD));
 4529:     if (!entry)
 4529:         goto failed_hash_add;
10444:     if (entry->keyAndFlags != 0) {
10444:         key = (JSString *)ATOM_ENTRY_KEY(entry);
10444:     } else {
10444:         /*
10444:          * We created a new hashtable entry. Unless str is already allocated
10444:          * from the GC heap and flat, we have to release state->lock as
10444:          * string construction is a complex operation. For example, it can
10444:          * trigger GC which may rehash the table and make the entry invalid.
10444:          */
11238:         ++table->generation;
29366:         if (!(flags & ATOM_TMPSTR) && str->isFlat()) {
29366:             str->flatClearMutable();
10444:             key = str;
10444:         } else {
11238:             gen = table->generation;
15994:             JS_UNLOCK(cx, &state->lock);
    1: 
    1:             if (flags & ATOM_TMPSTR) {
 4342:                 if (flags & ATOM_NOCOPY) {
29366:                     key = js_NewString(cx, str->flatChars(), str->flatLength());
 4529:                     if (!key)
    1:                         return NULL;
 4342: 
10444:                     /* Finish handing off chars to the GC'ed key string. */
29366:                     str->mChars = NULL;
    1:                 } else {
29366:                     key = js_NewStringCopyN(cx, str->flatChars(), str->flatLength());
 4529:                     if (!key)
 4342:                         return NULL;
 4342:                 }
 4342:            } else {
29366:                 JS_ASSERT(str->isDependent());
10444:                 if (!js_UndependString(cx, str))
    1:                     return NULL;
 4529:                 key = str;
    1:             }
    1: 
15994:             JS_LOCK(cx, &state->lock);
11238:             if (table->generation == gen) {
 4529:                 JS_ASSERT(entry->keyAndFlags == 0);
 4529:             } else {
 4529:                 entry = TO_ATOM_ENTRY(JS_DHashTableOperate(table, key,
 4529:                                                            JS_DHASH_ADD));
 4529:                 if (!entry)
 4529:                     goto failed_hash_add;
11189:                 if (entry->keyAndFlags != 0) {
11189:                     key = (JSString *)ATOM_ENTRY_KEY(entry);
 4342:                     goto finish;
11189:                 }
11238:                 ++table->generation;
    1:             }
10444:         }
 4529:         INIT_ATOM_ENTRY(entry, key);
29366:         key->flatSetAtomized();
 4529:     }
 4529: 
 4529:   finish:
 4529:     ADD_ATOM_ENTRY_FLAGS(entry, flags & (ATOM_PINNED | ATOM_INTERNED));
29366:     JS_ASSERT(key->isAtomized());
10444:     v = STRING_TO_JSVAL(key);
 4529:     cx->weakRoots.lastAtom = v;
15994:     JS_UNLOCK(cx, &state->lock);
 4529:     return (JSAtom *)v;
 4529: 
 4529:   failed_hash_add:
15994:     JS_UNLOCK(cx, &state->lock);
    1:     JS_ReportOutOfMemory(cx);
    1:     return NULL;
    1: }
    1: 
10444: JSAtom *
    1: js_Atomize(JSContext *cx, const char *bytes, size_t length, uintN flags)
    1: {
    1:     jschar *chars;
 4529:     JSString str;
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * Avoiding the malloc in js_InflateString on shorter strings saves us
    1:      * over 20,000 malloc calls on mozilla browser startup. This compares to
    1:      * only 131 calls where the string is longer than a 31 char (net) buffer.
    1:      * The vast majority of atomized strings are already in the hashtable. So
    1:      * js_AtomizeString rarely has to copy the temp string we make.
    1:      */
    1: #define ATOMIZE_BUF_MAX 32
    1:     jschar inflated[ATOMIZE_BUF_MAX];
    1:     size_t inflatedLength = ATOMIZE_BUF_MAX - 1;
    1: 
    1:     if (length < ATOMIZE_BUF_MAX) {
    1:         js_InflateStringToBuffer(cx, bytes, length, inflated, &inflatedLength);
    1:         inflated[inflatedLength] = 0;
    1:         chars = inflated;
    1:     } else {
    1:         inflatedLength = length;
    1:         chars = js_InflateString(cx, bytes, &inflatedLength);
    1:         if (!chars)
    1:             return NULL;
    1:         flags |= ATOM_NOCOPY;
    1:     }
    1: 
29366:     str.initFlat(chars, inflatedLength);
 4529:     atom = js_AtomizeString(cx, &str, ATOM_TMPSTR | flags);
29366:     if (chars != inflated && str.flatChars())
30851:         cx->free(chars);
    1:     return atom;
    1: }
    1: 
10444: JSAtom *
    1: js_AtomizeChars(JSContext *cx, const jschar *chars, size_t length, uintN flags)
    1: {
 4529:     JSString str;
    1: 
29366:     str.initFlat((jschar *)chars, length);
 4529:     return js_AtomizeString(cx, &str, ATOM_TMPSTR | flags);
    1: }
    1: 
    1: JSAtom *
    1: js_GetExistingStringAtom(JSContext *cx, const jschar *chars, size_t length)
    1: {
 4529:     JSString str, *str2;
    1:     JSAtomState *state;
 4529:     JSDHashEntryHdr *hdr;
    1: 
32606:     if (length == 1) {
32606:         jschar c = *chars;
32674:         if (c < UNIT_STRING_LIMIT)
32674:             return (JSAtom *) STRING_TO_JSVAL(JSString::unitString(c));
32606:     }
32606: 
29366:     str.initFlat((jschar *)chars, length);
    1:     state = &cx->runtime->atomState;
 4529: 
15994:     JS_LOCK(cx, &state->lock);
 4529:     hdr = JS_DHashTableOperate(&state->stringAtoms, &str, JS_DHASH_LOOKUP);
 4529:     str2 = JS_DHASH_ENTRY_IS_BUSY(hdr)
 4529:            ? (JSString *)ATOM_ENTRY_KEY(TO_ATOM_ENTRY(hdr))
 4529:            : NULL;
15994:     JS_UNLOCK(cx, &state->lock);
 4529: 
 4529:     return str2 ? (JSAtom *)STRING_TO_JSVAL(str2) : NULL;
    1: }
    1: 
 4529: JSBool
 4529: js_AtomizePrimitiveValue(JSContext *cx, jsval v, JSAtom **atomp)
    1: {
 4529:     JSAtom *atom;
 4529: 
 4529:     if (JSVAL_IS_STRING(v)) {
 4529:         atom = js_AtomizeString(cx, JSVAL_TO_STRING(v), 0);
 4529:         if (!atom)
 4529:             return JS_FALSE;
 4529:     } else if (JSVAL_IS_DOUBLE(v)) {
 4529:         atom = js_AtomizeDouble(cx, *JSVAL_TO_DOUBLE(v));
 4529:         if (!atom)
 4529:             return JS_FALSE;
 4529:     } else {
15521:         JS_ASSERT(JSVAL_IS_INT(v) || JSVAL_IS_BOOLEAN(v) ||
15521:                   JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v));
 4529:         atom = (JSAtom *)v;
 4529:     }
 4529:     *atomp = atom;
 4529:     return JS_TRUE;
    1: }
    1: 
 4342: #ifdef DEBUG
 4342: 
18907: static JSDHashOperator
 4529: atom_dumper(JSDHashTable *table, JSDHashEntryHdr *hdr,
 4529:             uint32 number, void *arg)
 4342: {
 4529:     JSAtomHashEntry *entry = TO_ATOM_ENTRY(hdr);
 4342:     FILE *fp = (FILE *)arg;
 4529:     void *key;
 4529:     uintN flags;
 4342: 
 4529:     fprintf(fp, "%3u %08x ", number, (uintN)entry->hdr.keyHash);
 4529:     if (entry->keyAndFlags == 0) {
 4529:         fputs("<uninitialized>", fp);
 4529:     } else {
 4529:         key = ATOM_ENTRY_KEY(entry);
 4529:         if (IS_DOUBLE_TABLE(table)) {
 4529:             fprintf(fp, "%.16g", *(jsdouble *)key);
 4529:         } else {
 4529:             JS_ASSERT(IS_STRING_TABLE(table));
 4529:             js_FileEscapedString(fp, (JSString *)key, '"');
 4529:         }
 4529:         flags = ATOM_ENTRY_FLAGS(entry);
 4529:         if (flags != 0) {
 4529:             fputs((flags & (ATOM_PINNED | ATOM_INTERNED))
 4529:                   ? " pinned | interned"
 4529:                   : (flags & ATOM_PINNED) ? " pinned" : " interned",
 4529:                   fp);
 4529:         }
 4529:     }
 4342:     putc('\n', fp);
 4529:     return JS_DHASH_NEXT;
 4342: }
 4342: 
 4342: JS_FRIEND_API(void)
 4342: js_DumpAtoms(JSContext *cx, FILE *fp)
 4342: {
 4342:     JSAtomState *state = &cx->runtime->atomState;
 4342: 
 4529:     fprintf(fp, "stringAtoms table contents:\n");
 4529:     JS_DHashTableEnumerate(&state->stringAtoms, atom_dumper, fp);
 4529: #ifdef JS_DHASHMETER
 4529:     JS_DHashTableDumpMeter(&state->stringAtoms, atom_dumper, fp);
 4342: #endif
 4529:     putc('\n', fp);
 4529: 
 4529:     fprintf(fp, "doubleAtoms table contents:\n");
 4529:     JS_DHashTableEnumerate(&state->doubleAtoms, atom_dumper, fp);
 4529: #ifdef JS_DHASHMETER
 4529:     JS_DHashTableDumpMeter(&state->doubleAtoms, atom_dumper, fp);
 4529: #endif
 4529:     putc('\n', fp);
 4342: }
 4342: 
 4342: #endif
    1: 
18907: static JSHashNumber
    1: js_hash_atom_ptr(const void *key)
    1: {
 3164:     const JSAtom *atom = (const JSAtom *) key;
 3328:     return ATOM_HASH(atom);
    1: }
    1: 
27012: #if JS_BITS_PER_WORD == 32
27012: # define TEMP_SIZE_START_LOG2   5
27012: #else
27012: # define TEMP_SIZE_START_LOG2   6
27012: #endif
27012: #define TEMP_SIZE_LIMIT_LOG2    (TEMP_SIZE_START_LOG2 + NUM_TEMP_FREELISTS)
27012: 
27012: #define TEMP_SIZE_START         JS_BIT(TEMP_SIZE_START_LOG2)
27012: #define TEMP_SIZE_LIMIT         JS_BIT(TEMP_SIZE_LIMIT_LOG2)
27012: 
27012: JS_STATIC_ASSERT(TEMP_SIZE_START >= sizeof(JSHashTable));
27012: 
18907: static void *
    1: js_alloc_temp_space(void *priv, size_t size)
    1: {
27012:     JSCompiler *jsc = (JSCompiler *) priv;
27012: 
26970:     void *space;
27012:     if (size < TEMP_SIZE_LIMIT) {
27012:         int bin = JS_CeilingLog2(size) - TEMP_SIZE_START_LOG2;
27012:         JS_ASSERT(unsigned(bin) < NUM_TEMP_FREELISTS);
26968: 
27012:         space = jsc->tempFreeList[bin];
27012:         if (space) {
27012:             jsc->tempFreeList[bin] = *(void **)space;
27012:             return space;
27012:         }
27012:     }
27012: 
27012:     JS_ARENA_ALLOCATE(space, &jsc->context->tempPool, size);
    1:     if (!space)
27012:         js_ReportOutOfScriptQuota(jsc->context);
    1:     return space;
    1: }
    1: 
18907: static void
27012: js_free_temp_space(void *priv, void *item, size_t size)
    1: {
27012:     if (size >= TEMP_SIZE_LIMIT)
27012:         return;
27012: 
27012:     JSCompiler *jsc = (JSCompiler *) priv;
27012:     int bin = JS_CeilingLog2(size) - TEMP_SIZE_START_LOG2;
27012:     JS_ASSERT(unsigned(bin) < NUM_TEMP_FREELISTS);
27012: 
27012:     *(void **)item = jsc->tempFreeList[bin];
27012:     jsc->tempFreeList[bin] = item;
    1: }
    1: 
18907: static JSHashEntry *
    1: js_alloc_temp_entry(void *priv, const void *key)
    1: {
27012:     JSCompiler *jsc = (JSCompiler *) priv;
    1:     JSAtomListElement *ale;
    1: 
27012:     ale = jsc->aleFreeList;
27012:     if (ale) {
27012:         jsc->aleFreeList = ALE_NEXT(ale);
27012:         return &ale->entry;
27012:     }
27012: 
27012:     JS_ARENA_ALLOCATE_TYPE(ale, JSAtomListElement, &jsc->context->tempPool);
    1:     if (!ale) {
27012:         js_ReportOutOfScriptQuota(jsc->context);
    1:         return NULL;
    1:     }
    1:     return &ale->entry;
    1: }
    1: 
18907: static void
    1: js_free_temp_entry(void *priv, JSHashEntry *he, uintN flag)
    1: {
27012:     JSCompiler *jsc = (JSCompiler *) priv;
27012:     JSAtomListElement *ale = (JSAtomListElement *) he;
27012: 
27012:     ALE_SET_NEXT(ale, jsc->aleFreeList);
27012:     jsc->aleFreeList = ale;
    1: }
    1: 
    1: static JSHashAllocOps temp_alloc_ops = {
    1:     js_alloc_temp_space,    js_free_temp_space,
    1:     js_alloc_temp_entry,    js_free_temp_entry
    1: };
    1: 
    1: JSAtomListElement *
27012: JSAtomList::rawLookup(JSAtom *atom, JSHashEntry **&hep)
    1: {
27012:     JSAtomListElement *ale;
27012: 
27012:     if (table) {
27012:         hep = JS_HashTableRawLookup(table, ATOM_HASH(atom), atom);
27012:         ale = *hep ? (JSAtomListElement *) *hep : NULL;
27012:     } else {
27012:         JSHashEntry **alep = &list;
27012:         hep = NULL;
27012:         while ((ale = (JSAtomListElement *)*alep) != NULL) {
27012:             if (ALE_ATOM(ale) == atom) {
27012:                 /* Hit, move atom's element to the front of the list. */
27012:                 *alep = ale->entry.next;
27012:                 ale->entry.next = list;
27012:                 list = &ale->entry;
27012:                 break;
27012:             }
27012:             alep = &ale->entry.next;
27012:         }
27012:     }
27012:     return ale;
27012: }
27012: 
27012: #define ATOM_LIST_HASH_THRESHOLD        12
27012: 
27012: JSAtomListElement *
27012: JSAtomList::add(JSCompiler *jsc, JSAtom *atom, AddHow how)
27012: {
27012:     JS_ASSERT(!set);
27012: 
    1:     JSAtomListElement *ale, *ale2, *next;
    1:     JSHashEntry **hep;
    1: 
27012:     ale = rawLookup(atom, hep);
27012:     if (!ale || how != UNIQUE) {
27012:         if (count < ATOM_LIST_HASH_THRESHOLD && !table) {
27012:             /* Few enough for linear search and no hash table yet needed. */
27012:             ale = (JSAtomListElement *)js_alloc_temp_entry(jsc, atom);
    1:             if (!ale)
    1:                 return NULL;
    1:             ALE_SET_ATOM(ale, atom);
27012: 
27012:             if (how == HOIST) {
27012:                 ale->entry.next = NULL;
27012:                 hep = (JSHashEntry **) &list;
27012:                 while (*hep)
27012:                     hep = &(*hep)->next;
27012:                 *hep = &ale->entry;
    1:             } else {
27012:                 ale->entry.next = list;
27012:                 list = &ale->entry;
27012:             }
27012:         } else {
27012:             /*
27012:              * We should hash, or else we already are hashing, but count was
27012:              * reduced by JSAtomList::rawRemove below ATOM_LIST_HASH_THRESHOLD.
27012:              * Check whether we should create the table.
27012:              */
27012:             if (!table) {
    1:                 /* No hash table yet, so hep had better be null! */
    1:                 JS_ASSERT(!hep);
27012:                 table = JS_NewHashTable(count + 1, js_hash_atom_ptr,
    1:                                         JS_CompareValues, JS_CompareValues,
27012:                                         &temp_alloc_ops, jsc);
27012:                 if (!table)
    1:                     return NULL;
    1: 
    1:                 /*
    1:                  * Set ht->nentries explicitly, because we are moving entries
27012:                  * from list to ht, not calling JS_HashTable(Raw|)Add.
    1:                  */
27012:                 table->nentries = count;
    1: 
27012:                 /*
27012:                  * Insert each ale on list into the new hash table. Append to
27012:                  * the hash chain rather than inserting at the bucket head, to
27012:                  * preserve order among entries with the same key.
27012:                  */
27012:                 for (ale2 = (JSAtomListElement *)list; ale2; ale2 = next) {
    1:                     next = ALE_NEXT(ale2);
 3328:                     ale2->entry.keyHash = ATOM_HASH(ALE_ATOM(ale2));
27012:                     hep = JS_HashTableRawLookup(table, ale2->entry.keyHash,
    1:                                                 ale2->entry.key);
27012:                     while (*hep)
27012:                         hep = &(*hep)->next;
    1:                     *hep = &ale2->entry;
27012:                     ale2->entry.next = NULL;
    1:                 }
27012:                 list = NULL;
    1: 
    1:                 /* Set hep for insertion of atom's ale, immediately below. */
27012:                 hep = JS_HashTableRawLookup(table, ATOM_HASH(atom), atom);
    1:             }
    1: 
    1:             /* Finally, add an entry for atom into the hash bucket at hep. */
    1:             ale = (JSAtomListElement *)
27012:                   JS_HashTableRawAdd(table, hep, ATOM_HASH(atom), atom, NULL);
    1:             if (!ale)
    1:                 return NULL;
27012: 
27012:             /*
27012:              * If hoisting, move ale to the end of its chain after we called
27012:              * JS_HashTableRawAdd, since RawAdd may have grown the table and
27012:              * then recomputed hep to refer to the pointer to the first entry
27012:              * with the given key.
27012:              */
27012:             if (how == HOIST && ale->entry.next) {
30447:                 JS_ASSERT(*hep == &ale->entry);
27012:                 *hep = ale->entry.next;
27012:                 ale->entry.next = NULL;
27012:                 do {
27012:                     hep = &(*hep)->next;
27012:                 } while (*hep);
27012:                 *hep = &ale->entry;
27012:             }
    1:         }
    1: 
27012:         ALE_SET_INDEX(ale, count++);
    1:     }
    1:     return ale;
    1: }
    1: 
27012: void
27012: JSAtomList::rawRemove(JSCompiler *jsc, JSAtomListElement *ale, JSHashEntry **hep)
27012: {
27012:     JS_ASSERT(!set);
27012:     JS_ASSERT(count != 0);
27012: 
27012:     if (table) {
27012:         JS_ASSERT(hep);
27012:         JS_HashTableRawRemove(table, hep, &ale->entry);
27012:     } else {
27012:         JS_ASSERT(!hep);
27012:         hep = &list;
27012:         while (*hep != &ale->entry) {
27012:             JS_ASSERT(*hep);
27012:             hep = &(*hep)->next;
27012:         }
27012:         *hep = ale->entry.next;
27012:         js_free_temp_entry(jsc, &ale->entry, HT_FREE_ENTRY);
27012:     }
27012: 
27012:     --count;
27012: }
27012: 
27012: JSAtomListElement *
27012: JSAtomListIterator::operator ()()
27012: {
27012:     JSAtomListElement *ale;
27012:     JSHashTable *ht;
27012: 
27012:     if (index == uint32(-1))
27012:         return NULL;
27012: 
27012:     ale = next;
27012:     if (!ale) {
27012:         ht = list->table;
27012:         if (!ht)
27012:             goto done;
27012:         do {
27012:             if (index == JS_BIT(JS_HASH_BITS - ht->shift))
27012:                 goto done;
27012:             next = (JSAtomListElement *) ht->buckets[index++];
27012:         } while (!next);
27012:         ale = next;
27012:     }
27012: 
27012:     next = ALE_NEXT(ale);
27012:     return ale;
27012: 
27012:   done:
27012:     index = uint32(-1);
27012:     return NULL;
27012: }
27012: 
18907: static intN
    1: js_map_atom(JSHashEntry *he, intN i, void *arg)
    1: {
    1:     JSAtomListElement *ale = (JSAtomListElement *)he;
 3164:     JSAtom **vector = (JSAtom **) arg;
    1: 
    1:     vector[ALE_INDEX(ale)] = ALE_ATOM(ale);
    1:     return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: #ifdef DEBUG
    1: static jsrefcount js_atom_map_count;
    1: static jsrefcount js_atom_map_hash_table_count;
    1: #endif
    1: 
10444: void
    1: js_InitAtomMap(JSContext *cx, JSAtomMap *map, JSAtomList *al)
    1: {
    1:     JSAtom **vector;
    1:     JSAtomListElement *ale;
    1:     uint32 count;
    1: 
 3235:     /* Map length must already be initialized. */
 3235:     JS_ASSERT(al->count == map->length);
    1: #ifdef DEBUG
    1:     JS_ATOMIC_INCREMENT(&js_atom_map_count);
    1: #endif
 2284:     ale = (JSAtomListElement *)al->list;
    1:     if (!ale && !al->table) {
 3235:         JS_ASSERT(!map->vector);
 3235:         return;
    1:     }
    1: 
    1:     count = al->count;
 3235:     vector = map->vector;
    1:     if (al->table) {
    1: #ifdef DEBUG
    1:         JS_ATOMIC_INCREMENT(&js_atom_map_hash_table_count);
    1: #endif
    1:         JS_HashTableEnumerateEntries(al->table, js_map_atom, vector);
    1:     } else {
    1:         do {
    1:             vector[ALE_INDEX(ale)] = ALE_ATOM(ale);
    1:         } while ((ale = ALE_NEXT(ale)) != NULL);
    1:     }
27012:     al->clear();
    1: }
