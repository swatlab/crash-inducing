82142: /* ***** BEGIN LICENSE BLOCK *****
82142:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
82142:  *
82142:  * The contents of this file are subject to the Mozilla Public License Version
82142:  * 1.1 (the "License"); you may not use this file except in compliance with
82142:  * the License. You may obtain a copy of the License at
82142:  * http://www.mozilla.org/MPL/
82142:  *
82142:  * Software distributed under the License is distributed on an "AS IS" basis,
82142:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
82142:  * for the specific language governing rights and limitations under the
82142:  * License.
82142:  *
82142:  * The Original Code is Gonk.
82142:  *
82142:  * The Initial Developer of the Original Code is
82142:  * the Mozilla Foundation.
82142:  * Portions created by the Initial Developer are Copyright (C) 2011
82142:  * the Initial Developer. All Rights Reserved.
82142:  *
82142:  * Contributor(s):
82142:  *   Michael Wu <mwu@mozilla.com>
82142:  *
82142:  * Alternatively, the contents of this file may be used under the terms of
82142:  * either the GNU General Public License Version 2 or later (the "GPL"), or
82142:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
82142:  * in which case the provisions of the GPL or the LGPL are applicable instead
82142:  * of those above. If you wish to allow use of your version of this file only
82142:  * under the terms of either the GPL or the LGPL, and not to allow others to
82142:  * use your version of this file under the terms of the MPL, indicate your
82142:  * decision by deleting the provisions above and replace them with the notice
82142:  * and other provisions required by the GPL or the LGPL. If you do not delete
82142:  * the provisions above, a recipient may use your version of this file under
82142:  * the terms of any one of the MPL, the GPL or the LGPL.
82142:  *
82142:  * ***** END LICENSE BLOCK ***** */
82142: 
86159: #include <EGL/egl.h>
86159: #include <EGL/eglext.h>
86159: 
86159: #include "android/log.h"
86159: #include "ui/FramebufferNativeWindow.h"
86159: 
87644: #include "mozilla/Hal.h"
86159: #include "Framebuffer.h"
86159: #include "gfxContext.h"
86159: #include "gfxUtils.h"
86159: #include "GLContextProvider.h"
86159: #include "LayerManagerOGL.h"
82142: #include "nsAutoPtr.h"
82142: #include "nsAppShell.h"
82142: #include "nsTArray.h"
87022: #include "nsIdleService.h"
82142: #include "nsWindow.h"
82142: 
82142: #define LOG(args...)  __android_log_print(ANDROID_LOG_INFO, "Gonk" , ## args)
82142: 
82142: #define IS_TOPLEVEL() (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog)
82142: 
86159: using namespace mozilla;
82142: using namespace mozilla::gl;
82142: using namespace mozilla::layers;
84713: using namespace mozilla::widget;
82142: 
82142: nsIntRect gScreenBounds;
82142: 
82142: static nsRefPtr<GLContext> sGLContext;
82142: static nsTArray<nsWindow *> sTopWindows;
82142: static nsWindow *gWindowToRedraw = nsnull;
82142: static nsWindow *gFocusedWindow = nsnull;
82142: static android::FramebufferNativeWindow *gNativeWindow = nsnull;
86159: static bool sFramebufferOpen;
82142: 
82142: nsWindow::nsWindow()
82142: {
86159:     if (!sGLContext && !sFramebufferOpen) {
86159:         // We (apparently) don't have a way to tell if allocating the
86159:         // fbs succeeded or failed.
82142:         gNativeWindow = new android::FramebufferNativeWindow();
82142:         sGLContext = GLContextProvider::CreateForWindow(this);
82142:         // CreateForWindow sets up gScreenBounds
86159:         if (!sGLContext) {
86361:             LOG("Failed to create GL context for fb, trying /dev/graphics/fb0");
86159: 
86159:             // We can't delete gNativeWindow.
86159: 
86159:             nsIntSize screenSize;
86159:             sFramebufferOpen = Framebuffer::Open(&screenSize);
86159:             gScreenBounds = nsIntRect(nsIntPoint(0, 0), screenSize);
86159:             if (!sFramebufferOpen) {
86159:                 LOG("Failed to mmap fb(?!?), aborting ...");
86361:                 NS_RUNTIMEABORT("Can't open GL context and can't fall back on /dev/graphics/fb0 ...");
86159:             }
86159:         }
82142:     }
82142: }
82142: 
82142: nsWindow::~nsWindow()
82142: {
82142: }
82142: 
82142: void
82142: nsWindow::DoDraw(void)
82142: {
87644:     if (!hal::GetScreenEnabled()) {
87644:         gDrawRequest = true;
87644:         return;
87644:     }
87644: 
86159:     if (!gWindowToRedraw) {
86159:         LOG("  no window to draw, bailing");
82142:         return;
86159:     }
82142: 
82142:     nsPaintEvent event(true, NS_PAINT, gWindowToRedraw);
86364:     event.region = gWindowToRedraw->mDirtyRegion;
86364:     gWindowToRedraw->mDirtyRegion.SetEmpty();
86159: 
86159:     LayerManager* lm = gWindowToRedraw->GetLayerManager();
86159:     if (LayerManager::LAYERS_OPENGL == lm->GetBackendType()) {
86421:         static_cast<LayerManagerOGL*>(lm)->SetClippingRegion(event.region);
82142:         gWindowToRedraw->mEventCallback(&event);
86159:     } else if (LayerManager::LAYERS_BASIC == lm->GetBackendType()) {
86159:         MOZ_ASSERT(sFramebufferOpen);
86159: 
86159:         nsRefPtr<gfxASurface> backBuffer = Framebuffer::BackBuffer();
86159:         {
86159:             nsRefPtr<gfxContext> ctx = new gfxContext(backBuffer);
86159:             gfxUtils::PathFromRegion(ctx, event.region);
86159:             ctx->Clip();
86159: 
86159:             // No double-buffering needed.
86159:             AutoLayerManagerSetup setupLayerManager(
86159:                 gWindowToRedraw, ctx, BasicLayerManager::BUFFER_NONE);
86159:             gWindowToRedraw->mEventCallback(&event);
86159:         }
86159:         backBuffer->Flush();
86159: 
86421:         Framebuffer::Present(event.region);
86159:     } else {
86159:         NS_RUNTIMEABORT("Unexpected layer manager type");
86159:     }
82142: }
82142: 
82142: nsEventStatus
82142: nsWindow::DispatchInputEvent(nsGUIEvent &aEvent)
82142: {
82142:     if (!gFocusedWindow)
82142:         return nsEventStatus_eIgnore;
82142: 
87022:     gFocusedWindow->UserActivity();
82142:     aEvent.widget = gFocusedWindow;
82142:     return gFocusedWindow->mEventCallback(&aEvent);
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::Create(nsIWidget *aParent,
82142:                  void *aNativeParent,
82142:                  const nsIntRect &aRect,
82142:                  EVENT_CALLBACK aHandleEventFunction,
82142:                  nsDeviceContext *aContext,
82142:                  nsWidgetInitData *aInitData)
82142: {
82142:     BaseCreate(aParent, IS_TOPLEVEL() ? gScreenBounds : aRect,
82142:                aHandleEventFunction, aContext, aInitData);
82142: 
82142:     mBounds = aRect;
82142: 
82142:     nsWindow *parent = (nsWindow *)aNativeParent;
82142:     mParent = parent;
82142: 
82142:     if (!aNativeParent) {
82142:         mBounds = gScreenBounds;
82142:     }
82142: 
82142:     if (!IS_TOPLEVEL())
82142:         return NS_OK;
82142: 
82142:     sTopWindows.AppendElement(this);
82142: 
82142:     Resize(0, 0, gScreenBounds.width, gScreenBounds.height, false);
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::Destroy(void)
82142: {
82142:     sTopWindows.RemoveElement(this);
82142:     if (this == gWindowToRedraw)
82142:         gWindowToRedraw = nsnull;
82142:     if (this == gFocusedWindow)
82142:         gFocusedWindow = nsnull;
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::Show(bool aState)
82142: {
82629:     if (mWindowType == eWindowType_invisible)
82629:         return NS_OK;
82629: 
86730:     if (mVisible == aState)
86730:         return NS_OK;
86730: 
82629:     mVisible = aState;
82142:     if (!IS_TOPLEVEL())
82629:         return mParent ? mParent->Show(aState) : NS_OK;
82142: 
86730:     if (aState) {
82142:         BringToTop();
86730:     } else {
86730:         for (unsigned int i = 0; i < sTopWindows.Length(); i++) {
86730:             nsWindow *win = sTopWindows[i];
86730:             if (!win->mVisible)
86730:                 continue;
86730: 
86730:             win->BringToTop();
86730:             break;
86730:         }
86730:     }
82142: 
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::IsVisible(bool & aState)
82142: {
82142:     aState = mVisible;
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::ConstrainPosition(bool aAllowSlop,
82142:                             PRInt32 *aX,
82142:                             PRInt32 *aY)
82142: {
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::Move(PRInt32 aX,
82142:                PRInt32 aY)
82142: {
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::Resize(PRInt32 aWidth,
82142:                  PRInt32 aHeight,
82142:                  bool    aRepaint)
82142: {
82142:     return Resize(0, 0, aWidth, aHeight, aRepaint);
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::Resize(PRInt32 aX,
82142:                  PRInt32 aY,
82142:                  PRInt32 aWidth,
82142:                  PRInt32 aHeight,
82142:                  bool    aRepaint)
82142: {
82142:     nsSizeEvent event(true, NS_SIZE, this);
82142:     event.time = PR_Now() / 1000;
82142: 
82142:     nsIntRect rect(aX, aY, aWidth, aHeight);
82142:     event.windowSize = &rect;
82142:     event.mWinWidth = gScreenBounds.width;
82142:     event.mWinHeight = gScreenBounds.height;
82142: 
82142:     (*mEventCallback)(&event);
82142: 
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::Enable(bool aState)
82142: {
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::IsEnabled(bool *aState)
82142: {
82142:     *aState = true;
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::SetFocus(bool aRaise)
82142: {
82142:     if (aRaise)
82142:         BringToTop();
82142: 
82142:     gFocusedWindow = this;
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::ConfigureChildren(const nsTArray<nsIWidget::Configuration>&)
82142: {
82142:     return NS_OK;
82142: }
82142: 
82142: NS_IMETHODIMP
87643: nsWindow::Invalidate(const nsIntRect &aRect)
82142: {
82629:     nsWindow *parent = mParent;
82629:     while (parent && parent != sTopWindows[0])
82629:         parent = parent->mParent;
86730:     if (parent != sTopWindows[0])
82629:         return NS_OK;
82629: 
86364:     mDirtyRegion.Or(mDirtyRegion, aRect);
82142:     gWindowToRedraw = this;
82142:     gDrawRequest = true;
82142:     mozilla::NotifyEvent();
82142:     return NS_OK;
82142: }
82142: 
82142: nsIntPoint
82142: nsWindow::WidgetToScreenOffset()
82142: {
82142:     nsIntPoint p(0, 0);
82142:     nsWindow *w = this;
82142: 
82142:     while (w && w->mParent) {
82142:         p.x += w->mBounds.x;
82142:         p.y += w->mBounds.y;
82142: 
82142:         w = w->mParent;
82142:     }
82142: 
82142:     return p;
82142: }
82142: 
82142: void*
82142: nsWindow::GetNativeData(PRUint32 aDataType)
82142: {
82142:     switch (aDataType) {
82142:     case NS_NATIVE_WINDOW:
82142:         return gNativeWindow;
82142:     case NS_NATIVE_WIDGET:
82142:         return this;
82142:     }
82142:     return nsnull;
82142: }
82142: 
82142: NS_IMETHODIMP
82142: nsWindow::DispatchEvent(nsGUIEvent *aEvent, nsEventStatus &aStatus)
82142: {
84713:     aStatus = (*mEventCallback)(aEvent);
82142:     return NS_OK;
82142: }
82142: 
84713: NS_IMETHODIMP_(void)
84713: nsWindow::SetInputContext(const InputContext& aContext,
84713:                           const InputContextAction& aAction)
84713: {
84713:     mInputContext = aContext;
84713: }
84713: 
84713: NS_IMETHODIMP_(InputContext)
84713: nsWindow::GetInputContext()
84713: {
84713:     return mInputContext;
84713: }
84713: 
82142: NS_IMETHODIMP
82142: nsWindow::ReparentNativeWidget(nsIWidget* aNewParent)
82142: {
82142:     return NS_OK;
82142: }
82142: 
82142: float
82142: nsWindow::GetDPI()
82142: {
82142:     return gNativeWindow->xdpi;
82142: }
82142: 
82142: LayerManager *
82142: nsWindow::GetLayerManager(PLayersChild* aShadowManager,
82142:                           LayersBackend aBackendHint,
82142:                           LayerManagerPersistence aPersistence,
82142:                           bool* aAllowRetaining)
82142: {
82142:     if (aAllowRetaining)
82142:         *aAllowRetaining = true;
82142:     if (mLayerManager)
82142:         return mLayerManager;
82142: 
82142:     nsWindow *topWindow = sTopWindows[0];
82142: 
82142:     if (!topWindow) {
82142:         LOG(" -- no topwindow\n");
82142:         return nsnull;
82142:     }
82142: 
86159:     if (sGLContext) {
86159:         nsRefPtr<LayerManagerOGL> layerManager = new LayerManagerOGL(this);
82142: 
82142:         if (layerManager->Initialize(sGLContext))
82142:             mLayerManager = layerManager;
82142:         else
86159:             LOG("Could not create OGL LayerManager");
86159:     } else {
86159:         MOZ_ASSERT(sFramebufferOpen);
86159:         mLayerManager = new BasicShadowLayerManager(this);
86159:     }
82142: 
82142:     return mLayerManager;
82142: }
82142: 
82142: gfxASurface *
82142: nsWindow::GetThebesSurface()
82142: {
82142:     /* This is really a dummy surface; this is only used when doing reflow, because
82142:      * we need a RenderingContext to measure text against.
82142:      */
82142: 
82142:     // XXX this really wants to return already_AddRefed, but this only really gets used
82142:     // on direct assignment to a gfxASurface
82142:     return new gfxImageSurface(gfxIntSize(5,5), gfxImageSurface::ImageFormatRGB24);
82142: }
82142: 
82142: void
82142: nsWindow::BringToTop()
82142: {
82142:     if (!sTopWindows.IsEmpty()) {
82142:         nsGUIEvent event(true, NS_DEACTIVATE, sTopWindows[0]);
82142:         (*mEventCallback)(&event);
82142:     }
82142: 
82142:     sTopWindows.RemoveElement(this);
82142:     sTopWindows.InsertElementAt(0, this);
82142: 
82142:     nsGUIEvent event(true, NS_ACTIVATE, this);
82142:     (*mEventCallback)(&event);
87643:     Invalidate(gScreenBounds);
82142: }
82142: 
87022: void
87022: nsWindow::UserActivity()
87022: {
87022:     if (!mIdleService) {
87022:         mIdleService = do_GetService("@mozilla.org/widget/idleservice;1");
87022:     }
87022: 
87022:     if (mIdleService) {
87022:         mIdleService->ResetIdleTimeOut();
87022:     }
87022: }
