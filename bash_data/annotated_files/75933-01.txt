62797: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53422:  * vim: set ts=4 sw=4 et tw=78:
40383:  *
40383:  * ***** BEGIN LICENSE BLOCK *****
40383:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
40383:  *
40383:  * The contents of this file are subject to the Mozilla Public License Version
40383:  * 1.1 (the "License"); you may not use this file except in compliance with
40383:  * the License. You may obtain a copy of the License at
40383:  * http://www.mozilla.org/MPL/
40383:  *
40383:  * Software distributed under the License is distributed on an "AS IS" basis,
40383:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
40383:  * for the specific language governing rights and limitations under the
40383:  * License.
40383:  *
40383:  * The Original Code is SpiderMonkey code.
40383:  *
40383:  * The Initial Developer of the Original Code is
40383:  * Mozilla Corporation.
40383:  * Portions created by the Initial Developer are Copyright (C) 2010
40383:  * the Initial Developer. All Rights Reserved.
40383:  *
40383:  * Contributor(s):
40383:  *   Jeff Walden <jwalden+code@mit.edu> (original author)
40383:  *
40383:  * Alternatively, the contents of this file may be used under the terms of
40383:  * either of the GNU General Public License Version 2 or later (the "GPL"),
40383:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
40383:  * in which case the provisions of the GPL or the LGPL are applicable instead
40383:  * of those above. If you wish to allow use of your version of this file only
40383:  * under the terms of either the GPL or the LGPL, and not to allow others to
40383:  * use your version of this file under the terms of the MPL, indicate your
40383:  * decision by deleting the provisions above and replace them with the notice
40383:  * and other provisions required by the GPL or the LGPL. If you do not delete
40383:  * the provisions above, a recipient may use your version of this file under
40383:  * the terms of any one of the MPL, the GPL or the LGPL.
40383:  *
40383:  * ***** END LICENSE BLOCK ***** */
40383: 
40383: #ifndef jscntxtinlines_h___
40383: #define jscntxtinlines_h___
40383: 
40383: #include "jscntxt.h"
59733: #include "jscompartment.h"
42714: #include "jsparse.h"
47485: #include "jsstaticcheck.h"
40383: #include "jsxml.h"
53858: #include "jsregexp.h"
55606: #include "jsgc.h"
53858: 
62876: namespace js {
62876: 
62876: static inline JSObject *
62876: GetGlobalForScopeChain(JSContext *cx)
62876: {
62876:     /*
62876:      * This is essentially GetScopeChain(cx)->getGlobal(), but without
62876:      * falling off trace.
62876:      *
62876:      * This use of cx->fp, possibly on trace, is deliberate:
62876:      * cx->fp->scopeChain->getGlobal() returns the same object whether we're on
62876:      * trace or not, since we do not trace calls across global objects.
62876:      */
62876:     VOUCH_DOES_NOT_REQUIRE_STACK();
62876: 
62876:     if (cx->hasfp())
62876:         return cx->fp()->scopeChain().getGlobal();
62876: 
62876:     JSObject *scope = cx->globalObject;
62876:     if (!scope) {
62876:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INACTIVE);
62876:         return NULL;
62876:     }
62876:     OBJ_TO_INNER_OBJECT(cx, scope);
62876:     return scope;
62876: }
62876: 
62876: }
62876: 
56773: #ifdef JS_METHODJIT
56773: inline js::mjit::JaegerCompartment *JSContext::jaegerCompartment()
56773: {
56773:     return compartment->jaegerCompartment;
56773: }
56773: #endif
56773: 
42717: inline bool
42717: JSContext::ensureGeneratorStackSpace()
42717: {
42717:     bool ok = genStack.reserve(genStack.length() + 1);
42717:     if (!ok)
42717:         js_ReportOutOfMemory(this);
42717:     return ok;
42717: }
42717: 
56729: inline js::RegExpStatics *
62876: JSContext::regExpStatics()
56729: {
62876:     return js::RegExpStatics::extractFrom(js::GetGlobalForScopeChain(this));
56729: }
56729: 
40383: namespace js {
40383: 
75933: struct PreserveRegsGuard
75933: {
75933:     JSContext *cx;
75933:     const JSFrameRegs &regs;
75933:     JSFrameRegs *prevContextRegs;
75933:     PreserveRegsGuard(JSContext *cx, JSFrameRegs &regs)
75933:         : cx(cx), regs(regs), prevContextRegs(cx->regs) {
75933:         cx->setCurrentRegs(&regs);
75933:     }
75933:     ~PreserveRegsGuard() {
75933:         JS_ASSERT(cx->regs == &regs);
75933:         *prevContextRegs = regs;
75933:         cx->setCurrentRegs(prevContextRegs);
75933:     }
75933: };
75933: 
50467: JS_REQUIRES_STACK JS_ALWAYS_INLINE JSFrameRegs *
50467: StackSegment::getCurrentRegs() const
50467: {
50467:     JS_ASSERT(inContext());
50467:     return isActive() ? cx->regs : getSuspendedRegs();
42714: }
42714: 
51446: JS_REQUIRES_STACK JS_ALWAYS_INLINE JSStackFrame *
51446: StackSegment::getCurrentFrame() const
51446: {
51446:     return getCurrentRegs()->fp;
51446: }
51446: 
48470: JS_REQUIRES_STACK inline Value *
42714: StackSpace::firstUnused() const
42714: {
50466:     StackSegment *seg = currentSegment;
50467:     if (!seg) {
50467:         JS_ASSERT(invokeArgEnd == NULL);
42714:         return base;
50467:     }
50470:     if (seg->inContext()) {
50467:         Value *sp = seg->getCurrentRegs()->sp;
50467:         if (invokeArgEnd > sp) {
50467:             JS_ASSERT(invokeSegment == currentSegment);
75864:             //JS_ASSERT_IF(seg->maybeContext()->hasfp(),  FIXME
75864:             //             invokeFrame == seg->maybeContext()->fp());
50467:             return invokeArgEnd;
42717:         }
50467:         return sp;
50467:     }
50467:     JS_ASSERT(invokeArgEnd);
50467:     JS_ASSERT(invokeSegment == currentSegment);
50467:     return invokeArgEnd;
42714: }
42714: 
50467: 
42714: /* Inline so we don't need the friend API. */
50467: JS_ALWAYS_INLINE bool
50467: StackSpace::isCurrentAndActive(JSContext *cx) const
42714: {
42714: #ifdef DEBUG
50467:     JS_ASSERT_IF(cx->getCurrentSegment(),
50467:                  cx->getCurrentSegment()->maybeContext() == cx);
48531:     cx->assertSegmentsInSync();
42714: #endif
50467:     return currentSegment &&
50467:            currentSegment->isActive() &&
50467:            currentSegment == cx->getCurrentSegment();
42714: }
42714: 
55479: STATIC_POSTCONDITION(!return || ubound(from) >= nvals)
42714: JS_ALWAYS_INLINE bool
48470: StackSpace::ensureSpace(JSContext *maybecx, Value *from, ptrdiff_t nvals) const
42714: {
57717:     JS_ASSERT(from >= firstUnused());
42714: #ifdef XP_WIN
42714:     JS_ASSERT(from <= commitEnd);
57717:     if (commitEnd - from >= nvals)
53840:         goto success;
42714:     if (end - from < nvals) {
42714:         if (maybecx)
42714:             js_ReportOutOfScriptQuota(maybecx);
42714:         return false;
42714:     }
42714:     if (!bumpCommit(from, nvals)) {
42714:         if (maybecx)
42714:             js_ReportOutOfScriptQuota(maybecx);
42714:         return false;
42714:     }
53840:     goto success;
42714: #else
57717:     if (end - from < nvals) {
42714:         if (maybecx)
42714:             js_ReportOutOfScriptQuota(maybecx);
42714:         return false;
42714:     }
53840:     goto success;
53840: #endif
53840:   success:
53840: #ifdef DEBUG
53840:     memset(from, 0xde, nvals * sizeof(js::Value));
53840: #endif
42714:     return true;
42714: }
42714: 
42714: JS_ALWAYS_INLINE bool
42714: StackSpace::ensureEnoughSpaceToEnterTrace()
42714: {
42714: #ifdef XP_WIN
42714:     return ensureSpace(NULL, firstUnused(), MAX_TRACE_SPACE_VALS);
42714: #endif
42714:     return end - firstUnused() > MAX_TRACE_SPACE_VALS;
42714: }
42714: 
53840: JS_ALWAYS_INLINE bool
53840: StackSpace::EnsureSpaceCheck::operator()(const StackSpace &stack, JSContext *cx,
53840:                                          Value *from, uintN nvals)
53840: {
53840:     return stack.ensureSpace(cx, from, nvals);
53840: }
53840: 
53840: JS_ALWAYS_INLINE bool
53840: StackSpace::LimitCheck::operator()(const StackSpace &stack, JSContext *cx,
53840:                                    Value *from, uintN nvals)
53840: {
53840:     JS_ASSERT(from == stack.firstUnused());
53840:     JS_ASSERT(from < *limit);
53840:     if (*limit - from >= ptrdiff_t(nvals))
53840:         return true;
53840:     if (stack.bumpCommitAndLimit(base, from, nvals, limit))
53840:         return true;
53840:     js_ReportOverRecursed(cx);
53840:     return false;
53840: }
53840: 
50467: JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
53840: StackSpace::pushInvokeArgs(JSContext *cx, uintN argc, InvokeArgsGuard *ag)
50467: {
50467:     if (JS_UNLIKELY(!isCurrentAndActive(cx)))
50467:         return pushSegmentForInvoke(cx, argc, ag);
50467: 
50467:     Value *sp = cx->regs->sp;
50467:     Value *start = invokeArgEnd > sp ? invokeArgEnd : sp;
50467:     JS_ASSERT(start == firstUnused());
50467:     uintN nvals = 2 + argc;
50467:     if (!ensureSpace(cx, start, nvals))
50467:         return false;
50467: 
50467:     Value *vp = start;
50467:     Value *vpend = vp + nvals;
62363:     /* Don't need to MakeRangeGCSafe: the VM stack is conservatively marked. */
50467: 
50467:     /* Use invokeArgEnd to root [vp, vpend) until the frame is pushed. */
53840:     ag->prevInvokeArgEnd = invokeArgEnd;
50467:     invokeArgEnd = vpend;
50467: #ifdef DEBUG
53840:     ag->prevInvokeSegment = invokeSegment;
50467:     invokeSegment = currentSegment;
53840:     ag->prevInvokeFrame = invokeFrame;
51446:     invokeFrame = cx->maybefp();
50467: #endif
50467: 
53840:     ag->cx = cx;
53840:     ag->argv_ = vp + 2;
53840:     ag->argc_ = argc;
50467:     return true;
50467: }
50467: 
50467: JS_REQUIRES_STACK JS_ALWAYS_INLINE void
50467: StackSpace::popInvokeArgs(const InvokeArgsGuard &ag)
50467: {
50467:     if (JS_UNLIKELY(ag.seg != NULL)) {
50467:         popSegmentForInvoke(ag);
50467:         return;
50467:     }
50467: 
50467:     JS_ASSERT(isCurrentAndActive(ag.cx));
50467:     JS_ASSERT(invokeSegment == currentSegment);
75864:     // JS_ASSERT(invokeFrame == ag.cx->maybefp()); FIXME
50468:     JS_ASSERT(invokeArgEnd == ag.argv() + ag.argc());
50467: 
50467: #ifdef DEBUG
50467:     invokeSegment = ag.prevInvokeSegment;
50467:     invokeFrame = ag.prevInvokeFrame;
50467: #endif
50467:     invokeArgEnd = ag.prevInvokeArgEnd;
50465: }
50465: 
50465: JS_ALWAYS_INLINE
50465: InvokeArgsGuard::~InvokeArgsGuard()
50465: {
50467:     if (JS_UNLIKELY(!pushed()))
50465:         return;
50467:     cx->stack().popInvokeArgs(*this);
50467: }
50467: 
53840: template <class Check>
53840: JS_REQUIRES_STACK JS_ALWAYS_INLINE JSStackFrame *
53840: StackSpace::getCallFrame(JSContext *cx, Value *firstUnused, uintN nactual,
53840:                          JSFunction *fun, JSScript *script, uint32 *flags,
53840:                          Check check) const
53840: {
53840:     JS_ASSERT(fun->script() == script);
53840: 
75882:     /* Include extra space for inlining by the method-jit. */
75882:     uintN nvals = STACK_EXTRA + script->nslots;
53840:     uintN nformal = fun->nargs;
53840: 
53840:     /* Maintain layout invariant: &formalArgs[0] == ((Value *)fp) - nformal. */
53840: 
53840:     if (nactual == nformal) {
53840:         if (JS_UNLIKELY(!check(*this, cx, firstUnused, nvals)))
53840:             return NULL;
53840:         return reinterpret_cast<JSStackFrame *>(firstUnused);
53840:     }
53840: 
53840:     if (nactual < nformal) {
53840:         *flags |= JSFRAME_UNDERFLOW_ARGS;
53840:         uintN nmissing = nformal - nactual;
53840:         if (JS_UNLIKELY(!check(*this, cx, firstUnused, nmissing + nvals)))
53840:             return NULL;
53840:         SetValueRangeToUndefined(firstUnused, nmissing);
53840:         return reinterpret_cast<JSStackFrame *>(firstUnused + nmissing);
53840:     }
53840: 
53840:     *flags |= JSFRAME_OVERFLOW_ARGS;
53840:     uintN ncopy = 2 + nformal;
53840:     if (JS_UNLIKELY(!check(*this, cx, firstUnused, ncopy + nvals)))
53840:         return NULL;
62579: 
62579:     Value *dst = firstUnused;
62579:     Value *src = firstUnused - (2 + nactual);
62579:     PodCopy(dst, src, ncopy);
62579:     Debug_SetValueRangeToCrashOnTouch(src, ncopy);
53840:     return reinterpret_cast<JSStackFrame *>(firstUnused + ncopy);
53840: }
53840: 
50467: JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
50468: StackSpace::getInvokeFrame(JSContext *cx, const CallArgs &args,
53840:                            JSFunction *fun, JSScript *script,
53840:                            uint32 *flags, InvokeFrameGuard *fg) const
50467: {
50468:     JS_ASSERT(firstUnused() == args.argv() + args.argc());
50467: 
53840:     Value *firstUnused = args.argv() + args.argc();
53840:     fg->regs_.fp = getCallFrame(cx, firstUnused, args.argc(), fun, script, flags,
53840:                                 EnsureSpaceCheck());
53840:     fg->regs_.sp = fg->regs_.fp->slots() + script->nfixed;
53840:     fg->regs_.pc = script->code;
75864:     fg->regs_.inlined = NULL;
53840: 
53840:     return fg->regs_.fp != NULL;
50467: }
50467: 
50467: JS_REQUIRES_STACK JS_ALWAYS_INLINE void
50468: StackSpace::pushInvokeFrame(JSContext *cx, const CallArgs &args,
53840:                             InvokeFrameGuard *fg)
50467: {
50468:     JS_ASSERT(firstUnused() == args.argv() + args.argc());
50467: 
50467:     if (JS_UNLIKELY(!currentSegment->inContext())) {
53840:         cx->pushSegmentAndFrame(currentSegment, fg->regs_);
50467:     } else {
53840:         fg->prevRegs_ = cx->regs;
53840:         cx->setCurrentRegs(&fg->regs_);
50467:     }
50467: 
53840:     fg->cx_ = cx;
50467:     JS_ASSERT(isCurrentAndActive(cx));
50467: }
50467: 
50467: JS_REQUIRES_STACK JS_ALWAYS_INLINE void
50467: StackSpace::popInvokeFrame(const InvokeFrameGuard &fg)
50467: {
53840:     JSContext *cx = fg.cx_;
53840:     JSStackFrame *fp = fg.regs_.fp;
50467: 
64365:     PutActivationObjects(cx, fp);
64365: 
50467:     JS_ASSERT(isCurrentAndActive(cx));
50467:     if (JS_UNLIKELY(currentSegment->getInitialFrame() == fp)) {
50467:         cx->popSegmentAndFrame();
50467:     } else {
53840:         JS_ASSERT(&fg.regs_ == cx->regs);
53840:         JS_ASSERT(fp->prev_ == fg.prevRegs_->fp);
54832:         JS_ASSERT(fp->prevpc() == fg.prevRegs_->pc);
53840:         cx->setCurrentRegs(fg.prevRegs_);
50467:     }
50467: }
50467: 
55565: JS_ALWAYS_INLINE void
55565: InvokeFrameGuard::pop()
50467: {
55565:     JS_ASSERT(pushed());
53840:     cx_->stack().popInvokeFrame(*this);
55565:     cx_ = NULL;
50465: }
50465: 
42714: JS_REQUIRES_STACK JS_ALWAYS_INLINE JSStackFrame *
53840: StackSpace::getInlineFrame(JSContext *cx, Value *sp, uintN nactual,
53840:                            JSFunction *fun, JSScript *script, uint32 *flags) const
42714: {
50467:     JS_ASSERT(isCurrentAndActive(cx));
48531:     JS_ASSERT(cx->hasActiveSegment());
42717:     JS_ASSERT(cx->regs->sp == sp);
42714: 
53840:     return getCallFrame(cx, sp, nactual, fun, script, flags, EnsureSpaceCheck());
53422: }
53422: 
53422: JS_REQUIRES_STACK JS_ALWAYS_INLINE JSStackFrame *
53840: StackSpace::getInlineFrameWithinLimit(JSContext *cx, Value *sp, uintN nactual,
53840:                                       JSFunction *fun, JSScript *script, uint32 *flags,
53840:                                       JSStackFrame *base, Value **limit) const
53422: {
53840:     JS_ASSERT(isCurrentAndActive(cx));
53840:     JS_ASSERT(cx->hasActiveSegment());
53840:     JS_ASSERT(cx->regs->sp == sp);
42714: 
53840:     return getCallFrame(cx, sp, nactual, fun, script, flags, LimitCheck(base, limit));
42714: }
42714: 
42714: JS_REQUIRES_STACK JS_ALWAYS_INLINE void
53840: StackSpace::pushInlineFrame(JSContext *cx, JSScript *script, JSStackFrame *fp,
53840:                             JSFrameRegs *regs)
42714: {
50467:     JS_ASSERT(isCurrentAndActive(cx));
53840:     JS_ASSERT(cx->regs == regs && script == fp->script());
42714: 
53840:     regs->fp = fp;
53840:     regs->pc = script->code;
75864:     regs->inlined = NULL;
53840:     regs->sp = fp->slots() + script->nfixed;
53840: }
53840: 
53840: JS_REQUIRES_STACK JS_ALWAYS_INLINE void
53840: StackSpace::popInlineFrame(JSContext *cx, JSStackFrame *prev, Value *newsp)
53840: {
64365:     JSFrameRegs *regs = cx->regs;
64365:     JSStackFrame *fp = regs->fp;
64365: 
53840:     JS_ASSERT(isCurrentAndActive(cx));
53840:     JS_ASSERT(cx->hasActiveSegment());
64365:     JS_ASSERT(fp->prev_ == prev);
64365:     JS_ASSERT(!fp->hasImacropc());
64365:     JS_ASSERT(prev->base() <= newsp && newsp <= fp->formalArgsEnd());
53840: 
64365:     PutActivationObjects(cx, fp);
64365: 
75901:     regs->pc = prev->pc(cx, fp, &regs->inlined);
53840:     regs->fp = prev;
53840:     regs->sp = newsp;
42714: }
42714: 
53840: JS_ALWAYS_INLINE Value *
53840: StackSpace::getStackLimit(JSContext *cx)
42714: {
53840:     Value *sp = cx->regs->sp;
53840:     JS_ASSERT(sp == firstUnused());
53840:     Value *limit = sp + STACK_QUOTA;
42714: 
53840:     /*
53840:      * Try to reserve the whole STACK_QUOTA. If that fails, though, just
53840:      * reserve the minimum required space: enough for the nslots + an
53840:      * additional stack frame.
53840:      */
53840: #ifdef XP_WIN
53840:     if (JS_LIKELY(limit <= commitEnd))
53840:         return limit;
53840:     if (ensureSpace(NULL /* don't report error */, sp, STACK_QUOTA))
53840:         return limit;
75882:     uintN minimum = cx->fp()->numSlots() + STACK_EXTRA;
53840:     return ensureSpace(cx, sp, minimum) ? sp + minimum : NULL;
53840: #else
53840:     if (JS_LIKELY(limit <= end))
53840:         return limit;
75882:     uintN minimum = cx->fp()->numSlots() + STACK_EXTRA;
53840:     return ensureSpace(cx, sp, minimum) ? sp + minimum : NULL;
42717: #endif
42714: }
42714: 
50467: JS_REQUIRES_STACK inline
50467: FrameRegsIter::FrameRegsIter(JSContext *cx)
54832:   : cx(cx)
50467: {
50467:     curseg = cx->getCurrentSegment();
51441:     if (JS_UNLIKELY(!curseg || !curseg->isActive())) {
50467:         initSlow();
51441:         return;
51441:     }
51446:     JS_ASSERT(cx->regs->fp);
51446:     curfp = cx->regs->fp;
50467:     cursp = cx->regs->sp;
50467:     curpc = cx->regs->pc;
50467:     return;
50467: }
50467: 
50467: inline FrameRegsIter &
50467: FrameRegsIter::operator++()
50467: {
53840:     JSStackFrame *fp = curfp;
53840:     JSStackFrame *prev = curfp = curfp->prev();
53840:     if (!prev)
50467:         return *this;
50467: 
54832:     curpc = curfp->pc(cx, fp);
50467: 
53840:     if (JS_UNLIKELY(fp == curseg->getInitialFrame())) {
53840:         incSlow(fp, prev);
50467:         return *this;
50467:     }
50467: 
53840:     cursp = fp->formalArgsEnd();
50467:     return *this;
50467: }
50467: 
47478: class AutoNamespaceArray : protected AutoGCRooter {
47478:   public:
47478:     AutoNamespaceArray(JSContext *cx) : AutoGCRooter(cx, NAMESPACES) {
47478:         array.init();
40383:     }
40383: 
47478:     ~AutoNamespaceArray() {
47478:         array.finish(context);
47478:     }
47478: 
47478:     uint32 length() const { return array.length; }
47478: 
47478:   public:
40383:     friend void AutoGCRooter::trace(JSTracer *trc);
40383: 
40383:     JSXMLArray array;
40383: };
40383: 
57743: #ifdef DEBUG
47485: class CompartmentChecker
47485: {
47485:   private:
47485:     JSContext *context;
47485:     JSCompartment *compartment;
47485: 
47485:   public:
47485:     explicit CompartmentChecker(JSContext *cx) : context(cx), compartment(cx->compartment) {
62876:         check(cx->hasfp() ? JS_GetGlobalForScopeChain(cx) : cx->globalObject);
47485:         VOUCH_DOES_NOT_REQUIRE_STACK();
47485:     }
47485: 
47485:     /*
47485:      * Set a breakpoint here (break js::CompartmentChecker::fail) to debug
47485:      * compartment mismatches.
47485:      */
47485:     static void fail(JSCompartment *c1, JSCompartment *c2) {
47485:         printf("*** Compartment mismatch %p vs. %p\n", (void *) c1, (void *) c2);
57743:         JS_NOT_REACHED("compartment mismatched");
47485:     }
47485: 
60169:     /* Note: should only be used when neither c1 nor c2 may be the default compartment. */
60169:     static void check(JSCompartment *c1, JSCompartment *c2) {
60584:         JS_ASSERT(c1 != c1->rt->atomsCompartment);
60584:         JS_ASSERT(c2 != c2->rt->atomsCompartment);
60169:         if (c1 != c2)
60169:             fail(c1, c2);
60169:     }
60169: 
47485:     void check(JSCompartment *c) {
60584:         if (c && c != context->runtime->atomsCompartment) {
47485:             if (!compartment)
47485:                 compartment = c;
47485:             else if (c != compartment)
47485:                 fail(compartment, c);
47485:         }
47485:     }
47485: 
47485:     void check(JSPrincipals *) { /* nothing for now */ }
47485: 
47485:     void check(JSObject *obj) {
47485:         if (obj)
61430:             check(obj->compartment());
61430:     }
61430: 
61430:     void check(JSString *str) {
64343:         if (!str->isAtom())
64345:             check(str->compartment());
47485:     }
47485: 
48470:     void check(const js::Value &v) {
48470:         if (v.isObject())
48470:             check(&v.toObject());
61430:         else if (v.isString())
61430:             check(v.toString());
48470:     }
48470: 
47485:     void check(jsval v) {
48470:         check(Valueify(v));
47485:     }
47485: 
47485:     void check(const ValueArray &arr) {
47485:         for (size_t i = 0; i < arr.length; i++)
47485:             check(arr.array[i]);
47485:     }
47485: 
48470:     void check(const JSValueArray &arr) {
48470:         for (size_t i = 0; i < arr.length; i++)
48470:             check(arr.array[i]);
48470:     }
48470: 
48470:     void check(jsid id) {
48470:         if (JSID_IS_OBJECT(id))
48470:             check(JSID_TO_OBJECT(id));
48470:     }
48470:     
47485:     void check(JSIdArray *ida) {
47485:         if (ida) {
48470:             for (jsint i = 0; i < ida->length; i++) {
48470:                 if (JSID_IS_OBJECT(ida->vector[i]))
48470:                     check(ida->vector[i]);
48470:             }
47485:         }
47485:     }
47485: 
47485:     void check(JSScript *script) {
59220:         if (script) {
55633:             check(script->compartment);
55633:             if (script->u.object)
47485:                 check(script->u.object);
47485:         }
55633:     }
47485: 
56704:     void check(JSStackFrame *fp) {
56704:         check(&fp->scopeChain());
56704:     }
47485: };
47485: 
57743: #endif
57743: 
47485: /*
47485:  * Don't perform these checks when called from a finalizer. The checking
47485:  * depends on other objects not having been swept yet.
47485:  */
47485: #define START_ASSERT_SAME_COMPARTMENT()                                       \
47485:     if (cx->runtime->gcRunning)                                               \
47485:         return;                                                               \
47485:     CompartmentChecker c(cx)
47485: 
47485: template <class T1> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
57743: #endif
47485: }
47485: 
47485: template <class T1, class T2> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1, T2 t2)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
47485:     c.check(t2);
57743: #endif
47485: }
47485: 
47485: template <class T1, class T2, class T3> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1, T2 t2, T3 t3)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
47485:     c.check(t2);
47485:     c.check(t3);
57743: #endif
47485: }
47485: 
47485: template <class T1, class T2, class T3, class T4> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1, T2 t2, T3 t3, T4 t4)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
47485:     c.check(t2);
47485:     c.check(t3);
47485:     c.check(t4);
57743: #endif
47485: }
47485: 
47485: template <class T1, class T2, class T3, class T4, class T5> inline void
47485: assertSameCompartment(JSContext *cx, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5)
47485: {
57743: #ifdef DEBUG
47485:     START_ASSERT_SAME_COMPARTMENT();
47485:     c.check(t1);
47485:     c.check(t2);
47485:     c.check(t3);
47485:     c.check(t4);
47485:     c.check(t5);
57743: #endif
47485: }
47485: 
47485: #undef START_ASSERT_SAME_COMPARTMENT
47485: 
55479: STATIC_PRECONDITION_ASSUME(ubound(vp) >= argc + 2)
53557: JS_ALWAYS_INLINE bool
53557: CallJSNative(JSContext *cx, js::Native native, uintN argc, js::Value *vp)
47485: {
53557: #ifdef DEBUG
60211:     JSBool alreadyThrowing = cx->isExceptionPending();
53557: #endif
53557:     assertSameCompartment(cx, ValueArray(vp, argc + 2));
53557:     JSBool ok = native(cx, argc, vp);
53557:     if (ok) {
53557:         assertSameCompartment(cx, vp[0]);
60211:         JS_ASSERT_IF(!alreadyThrowing, !cx->isExceptionPending());
53557:     }
47485:     return ok;
47485: }
47485: 
62402: extern JSBool CallOrConstructBoundFunction(JSContext *, uintN, js::Value *);
62402: 
55479: STATIC_PRECONDITION(ubound(vp) >= argc + 2)
53557: JS_ALWAYS_INLINE bool
53557: CallJSNativeConstructor(JSContext *cx, js::Native native, uintN argc, js::Value *vp)
47485: {
53557: #ifdef DEBUG
53557:     JSObject *callee = &vp[0].toObject();
53557: #endif
53557: 
53557:     JS_ASSERT(vp[1].isMagic());
53557:     if (!CallJSNative(cx, native, argc, vp))
53557:         return false;
53557: 
53557:     /*
53617:      * Native constructors must return non-primitive values on success.
53617:      * Although it is legal, if a constructor returns the callee, there is a
53617:      * 99.9999% chance it is a bug. If any valid code actually wants the
54729:      * constructor to return the callee, the assertion can be removed or
54729:      * (another) conjunct can be added to the antecedent.
53617:      *
53617:      * Proxies are exceptions to both rules: they can return primitives and
53617:      * they allow content to return the callee.
54729:      *
62402:      * CallOrConstructBoundFunction is an exception as well because we
62402:      * might have used bind on a proxy function.
62402:      *
54729:      * (new Object(Object)) returns the callee.
53557:      */
53617:     extern JSBool proxy_Construct(JSContext *, uintN, Value *);
62402:     JS_ASSERT_IF(native != proxy_Construct && native != js::CallOrConstructBoundFunction &&
54731:                  (!callee->isFunction() || callee->getFunctionPrivate()->u.n.clasp != &js_ObjectClass),
53617:                  !vp->isPrimitive() && callee != &vp[0].toObject());
53617: 
53557:     return true;
47485: }
47485: 
53557: JS_ALWAYS_INLINE bool
52503: CallJSPropertyOp(JSContext *cx, js::PropertyOp op, JSObject *obj, jsid id, js::Value *vp)
47485: {
48470:     assertSameCompartment(cx, obj, id, *vp);
48470:     JSBool ok = op(cx, obj, id, vp);
47485:     if (ok)
47485:         assertSameCompartment(cx, obj, *vp);
47485:     return ok;
47485: }
47485: 
53557: JS_ALWAYS_INLINE bool
62395: CallJSPropertyOpSetter(JSContext *cx, js::StrictPropertyOp op, JSObject *obj, jsid id,
62395:                        JSBool strict, js::Value *vp)
47485: {
48470:     assertSameCompartment(cx, obj, id, *vp);
62395:     return op(cx, obj, id, strict, vp);
47485: }
47485: 
56817: inline bool
62395: CallSetter(JSContext *cx, JSObject *obj, jsid id, js::StrictPropertyOp op, uintN attrs,
62395:            uintN shortid, JSBool strict, js::Value *vp)
56817: {
56817:     if (attrs & JSPROP_SETTER)
56817:         return ExternalGetOrSet(cx, obj, id, CastAsObjectJsval(op), JSACC_WRITE, 1, vp, vp);
56817: 
56817:     if (attrs & JSPROP_GETTER)
56817:         return js_ReportGetterOnlyAssignment(cx);
56817: 
56817:     if (attrs & JSPROP_SHORTID)
56817:         id = INT_TO_JSID(shortid);
62395:     return CallJSPropertyOpSetter(cx, op, obj, id, strict, vp);
56817: }
56817: 
59733: #ifdef JS_TRACER
59733: /*
59733:  * Reconstruct the JS stack and clear cx->tracecx. We must be currently in a
59733:  * _FAIL builtin from trace on cx or another context on the same thread. The
59733:  * machine code for the trace remains on the C stack when js_DeepBail returns.
59733:  *
59733:  * Implemented in jstracer.cpp.
59733:  */
59733: JS_FORCES_STACK JS_FRIEND_API(void)
59733: DeepBail(JSContext *cx);
59733: #endif
59733: 
59733: static JS_INLINE void
59733: LeaveTraceIfGlobalObject(JSContext *cx, JSObject *obj)
59733: {
59733:     if (!obj->parent)
59733:         LeaveTrace(cx);
59733: }
59733: 
60160: static JS_INLINE void
60160: LeaveTraceIfArgumentsObject(JSContext *cx, JSObject *obj)
60160: {
60160:     if (obj->isArguments())
60160:         LeaveTrace(cx);
60160: }
60160: 
59733: static JS_INLINE JSBool
59733: CanLeaveTrace(JSContext *cx)
59733: {
59733:     JS_ASSERT(JS_ON_TRACE(cx));
59733: #ifdef JS_TRACER
62033:     return JS_TRACE_MONITOR_ON_TRACE(cx)->bailExit != NULL;
59733: #else
59733:     return JS_FALSE;
59733: #endif
59733: }
59733: 
48470: }  /* namespace js */
40383: 
60211: inline void
60211: JSContext::setPendingException(js::Value v) {
60211:     this->throwing = true;
60211:     this->exception = v;
60211:     assertSameCompartment(this, v);
60211: }
60211: 
40383: #endif /* jscntxtinlines_h___ */
