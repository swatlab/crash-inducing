 1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1: /* ***** BEGIN LICENSE BLOCK *****
 1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1:  *
 1:  * The contents of this file are subject to the Mozilla Public License Version
 1:  * 1.1 (the "License"); you may not use this file except in compliance with
 1:  * the License. You may obtain a copy of the License at
 1:  * http://www.mozilla.org/MPL/
 1:  *
 1:  * Software distributed under the License is distributed on an "AS IS" basis,
 1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1:  * for the specific language governing rights and limitations under the
 1:  * License.
 1:  *
 1:  * The Original Code is Mozilla Communicator client code.
 1:  *
 1:  * The Initial Developer of the Original Code is
 1:  * Netscape Communications Corporation.
 1:  * Portions created by the Initial Developer are Copyright (C) 1998
 1:  * the Initial Developer. All Rights Reserved.
 1:  *
 1:  * Contributor(s):
 1:  *   Pierre Phaneuf <pp@ludusdesign.com>
 1:  *   Mats Palmgren <mats.palmgren@bredband.net>
 1:  *
 1:  * Alternatively, the contents of this file may be used under the terms of
 1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1:  * of those above. If you wish to allow use of your version of this file only
 1:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1:  * use your version of this file under the terms of the MPL, indicate your
 1:  * decision by deleting the provisions above and replace them with the notice
 1:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1:  * the provisions above, a recipient may use your version of this file under
 1:  * the terms of any one of the MPL, the GPL or the LGPL.
 1:  *
 1:  * ***** END LICENSE BLOCK ***** */
 1: 
 1: #include "nscore.h"
 1: #include "nsCOMPtr.h"
 1: #include "nsReadableUtils.h"
 1: #include "nsUnicharUtils.h"
 1: #include "nsListControlFrame.h"
 1: #include "nsFormControlFrame.h" // for COMPARE macro
 1: #include "nsGkAtoms.h"
 1: #include "nsIFormControl.h"
 1: #include "nsIDeviceContext.h" 
 1: #include "nsIDocument.h"
 1: #include "nsIDOMHTMLCollection.h" 
 1: #include "nsIDOMHTMLOptionsCollection.h" 
 1: #include "nsIDOMNSHTMLOptionCollectn.h"
 1: #include "nsIDOMHTMLSelectElement.h" 
 1: #include "nsIDOMNSHTMLSelectElement.h" 
 1: #include "nsIDOMHTMLOptionElement.h" 
 1: #include "nsComboboxControlFrame.h"
 1: #include "nsIViewManager.h"
 1: #include "nsIScrollableView.h"
 1: #include "nsIDOMHTMLOptGroupElement.h"
 1: #include "nsWidgetsCID.h"
 1: #include "nsIPresShell.h"
 1: #include "nsHTMLParts.h"
 1: #include "nsIDOMEventReceiver.h"
 1: #include "nsEventDispatcher.h"
 1: #include "nsIEventStateManager.h"
 1: #include "nsIEventListenerManager.h"
 1: #include "nsIDOMKeyEvent.h"
 1: #include "nsIDOMMouseEvent.h"
 1: #include "nsIPrivateDOMEvent.h"
 1: #include "nsXPCOM.h"
 1: #include "nsISupportsPrimitives.h"
 1: #include "nsIComponentManager.h"
 1: #include "nsILookAndFeel.h"
 1: #include "nsIFontMetrics.h"
 1: #include "nsIScrollableFrame.h"
 1: #include "nsIDOMEventTarget.h"
 1: #include "nsIDOMNSEvent.h"
 1: #include "nsGUIEvent.h"
 1: #include "nsIServiceManager.h"
 1: #include "nsINodeInfo.h"
 1: #ifdef ACCESSIBILITY
 1: #include "nsIAccessibilityService.h"
 1: #endif
 1: #include "nsISelectElement.h"
 1: #include "nsIPrivateDOMEvent.h"
 1: #include "nsCSSRendering.h"
 1: #include "nsITheme.h"
 1: #include "nsIDOMMouseListener.h"
 1: #include "nsIDOMMouseMotionListener.h"
 1: #include "nsIDOMKeyListener.h"
 1: #include "nsLayoutUtils.h"
 1: #include "nsDisplayList.h"
 1: 
 1: // Constants
 1: const nscoord kMaxDropDownRows          = 20; // This matches the setting for 4.x browsers
 1: const PRInt32 kNothingSelected          = -1;
 1: 
 1: 
 1: nsListControlFrame * nsListControlFrame::mFocused = nsnull;
 1: 
 1: // Using for incremental typing navigation
 1: #define INCREMENTAL_SEARCH_KEYPRESS_TIME 1000
 1: // XXX, kyle.yuan@sun.com, there are 4 definitions for the same purpose:
 1: //  nsMenuPopupFrame.h, nsListControlFrame.cpp, listbox.xml, tree.xml
 1: //  need to find a good place to put them together.
 1: //  if someone changes one, please also change the other.
 1: 
 1: DOMTimeStamp nsListControlFrame::gLastKeyTime = 0;
 1: 
 1: /******************************************************************************
 1:  * nsListEventListener
 1:  * This class is responsible for propagating events to the nsListControlFrame.
 1:  * Frames are not refcounted so they can't be used as event listeners.
 1:  *****************************************************************************/
 1: 
 1: class nsListEventListener : public nsIDOMKeyListener,
 1:                             public nsIDOMMouseListener,
 1:                             public nsIDOMMouseMotionListener
 1: {
 1: public:
 1:   nsListEventListener(nsListControlFrame *aFrame)
 1:     : mFrame(aFrame) { }
 1: 
 1:   void SetFrame(nsListControlFrame *aFrame) { mFrame = aFrame; }
 1: 
 1:   NS_DECL_ISUPPORTS
 1: 
 1:   // nsIDOMEventListener
 1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);
 1: 
 1:   // nsIDOMKeyListener
 1:   NS_IMETHOD KeyDown(nsIDOMEvent* aKeyEvent);
 1:   NS_IMETHOD KeyUp(nsIDOMEvent* aKeyEvent);
 1:   NS_IMETHOD KeyPress(nsIDOMEvent* aKeyEvent);
 1: 
 1:   // nsIDOMMouseListener
 1:   NS_IMETHOD MouseDown(nsIDOMEvent* aMouseEvent);
 1:   NS_IMETHOD MouseUp(nsIDOMEvent* aMouseEvent);
 1:   NS_IMETHOD MouseClick(nsIDOMEvent* aMouseEvent);
 1:   NS_IMETHOD MouseDblClick(nsIDOMEvent* aMouseEvent);
 1:   NS_IMETHOD MouseOver(nsIDOMEvent* aMouseEvent);
 1:   NS_IMETHOD MouseOut(nsIDOMEvent* aMouseEvent);
 1: 
 1:   // nsIDOMMouseMotionListener
 1:   NS_IMETHOD MouseMove(nsIDOMEvent* aMouseEvent);
 1:   NS_IMETHOD DragMove(nsIDOMEvent* aMouseEvent);
 1: 
 1: private:
 1:   nsListControlFrame  *mFrame;
 1: };
 1: 
 1: //---------------------------------------------------------
 1: nsIFrame*
 1: NS_NewListControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
 1: {
 1:   nsListControlFrame* it =
 1:     new (aPresShell) nsListControlFrame(aPresShell, aPresShell->GetDocument(), aContext);
 1: 
 1:   if (it) {
 1:     it->AddStateBits(NS_FRAME_INDEPENDENT_SELECTION);
 1:   }
 1: 
 1:   return it;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: nsListControlFrame::nsListControlFrame(
 1:   nsIPresShell* aShell, nsIDocument* aDocument, nsStyleContext* aContext)
 1:   : nsHTMLScrollFrame(aShell, aContext, PR_FALSE),
 1:     mMightNeedSecondPass(PR_FALSE),
 1:     mLastDropdownComputedHeight(NS_UNCONSTRAINEDSIZE)
 1: {
 1:   mComboboxFrame      = nsnull;
 1:   mChangesSinceDragStart = PR_FALSE;
 1:   mButtonDown         = PR_FALSE;
 1: 
 1:   mIsAllContentHere   = PR_FALSE;
 1:   mIsAllFramesHere    = PR_FALSE;
 1:   mHasBeenInitialized = PR_FALSE;
 1:   mNeedToReset        = PR_TRUE;
 1:   mPostChildrenLoadedReset = PR_FALSE;
 1: 
 1:   mControlSelectMode           = PR_FALSE;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: nsListControlFrame::~nsListControlFrame()
 1: {
 1:   mComboboxFrame = nsnull;
 1: }
 1: 
 1: // for Bug 47302 (remove this comment later)
 1: void
 1: nsListControlFrame::Destroy()
 1: {
 1:   // get the receiver interface from the browser button's content node
 1:   nsCOMPtr<nsIDOMEventReceiver> receiver(do_QueryInterface(mContent));
 1: 
 1:   // Clear the frame pointer on our event listener, just in case the
 1:   // event listener can outlive the frame.
 1: 
 1:   mEventListener->SetFrame(nsnull);
 1: 
 1:   receiver->RemoveEventListenerByIID(NS_STATIC_CAST(nsIDOMMouseListener*,
 1:                                                     mEventListener),
 1:                                      NS_GET_IID(nsIDOMMouseListener));
 1: 
 1:   receiver->RemoveEventListenerByIID(NS_STATIC_CAST(nsIDOMMouseMotionListener*,
 1:                                                     mEventListener),
 1:                                      NS_GET_IID(nsIDOMMouseMotionListener));
 1: 
 1:   receiver->RemoveEventListenerByIID(NS_STATIC_CAST(nsIDOMKeyListener*,
 1:                                                     mEventListener),
 1:                                      NS_GET_IID(nsIDOMKeyListener));
 1: 
 1:   nsFormControlFrame::RegUnRegAccessKey(NS_STATIC_CAST(nsIFrame*, this), PR_FALSE);
 1:   nsHTMLScrollFrame::Destroy();
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsListControlFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
 1:                                      const nsRect&           aDirtyRect,
 1:                                      const nsDisplayListSet& aLists)
 1: {
 1:   // We allow visibility:hidden <select>s to contain visible options.
 1:   
 1:   // Don't allow painting of list controls when painting is suppressed.
 1:   // XXX why do we need this here? we should never reach this. Maybe
 1:   // because these can have widgets? Hmm
 1:   if (aBuilder->IsBackgroundOnly())
 1:     return NS_OK;
 1: 
 1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsListControlFrame");
 1: 
 1:   // REVIEW: The selection visibility code that used to be here is what
 1:   // we already do by default.
 1:   // REVIEW: There was code here to paint the theme background. But as far
 1:   // as I can tell, we'd just paint the theme background twice because
 1:   // it was redundant with nsCSSRendering::PaintBackground
 1:   return nsHTMLScrollFrame::BuildDisplayList(aBuilder, aDirtyRect, aLists);
 1: }
 1: 
 1: /**
 1:  * This is called by the SelectsAreaFrame, which is the same
 1:  * as the frame returned by GetOptionsContainer. It's the frame which is
 1:  * scrolled by us.
 1:  * @param aPt the offset of this frame, relative to the rendering reference
 1:  * frame
 1:  */
 1: void nsListControlFrame::PaintFocus(nsIRenderingContext& aRC, nsPoint aPt)
 1: {
 1:   if (mFocused != this) return;
 1: 
 1:   // The mEndSelectionIndex is what is currently being selected
 1:   // use the selected index if this is kNothingSelected
 1:   PRInt32 focusedIndex;
 1:   if (mEndSelectionIndex == kNothingSelected) {
 1:     focusedIndex = GetSelectedIndex();
 1:   } else {
 1:     focusedIndex = mEndSelectionIndex;
 1:   }
 1: 
 1:   nsPresContext* presContext = GetPresContext();
 1:   if (!GetScrollableView()) return;
 1: 
 1:   nsIPresShell *presShell = presContext->GetPresShell();
 1:   if (!presShell) return;
 1: 
 1:   nsIFrame* containerFrame = GetOptionsContainer();
 1:   if (!containerFrame) return;
 1: 
 1:   nsIFrame * childframe = nsnull;
 1:   nsresult result = NS_ERROR_FAILURE;
 1: 
 1:   nsCOMPtr<nsIContent> focusedContent;
 1: 
 1:   nsCOMPtr<nsIDOMNSHTMLSelectElement> selectNSElement(do_QueryInterface(mContent));
 1:   NS_ASSERTION(selectNSElement, "Can't be null");
 1: 
 1:   nsCOMPtr<nsISelectElement> selectElement(do_QueryInterface(mContent));
 1:   NS_ASSERTION(selectElement, "Can't be null");
 1: 
 1:   // If we have a selected index then get that child frame
 1:   if (focusedIndex != kNothingSelected) {
 1:     focusedContent = GetOptionContent(focusedIndex);
 1:     // otherwise we find the focusedContent's frame and scroll to it
 1:     if (focusedContent) {
 1:       childframe = presShell->GetPrimaryFrameFor(focusedContent);
 1:     }
 1:   } else {
 1:     nsCOMPtr<nsIDOMHTMLSelectElement> selectHTMLElement(do_QueryInterface(mContent));
 1:     NS_ASSERTION(selectElement, "Can't be null");
 1: 
 1:     // Since there isn't a selected item we need to show a focus ring around the first
 1:     // non-disabled item and skip all the option group elements (nodes)
 1:     nsCOMPtr<nsIDOMNode> node;
 1: 
 1:     PRUint32 length;
 1:     selectHTMLElement->GetLength(&length);
 1:     if (length) {
 1:       // find the first non-disabled item
 1:       PRBool isDisabled = PR_TRUE;
 1:       for (PRInt32 i=0;i<PRInt32(length) && isDisabled;i++) {
 1:         if (NS_FAILED(selectNSElement->Item(i, getter_AddRefs(node))) || !node) {
 1:           break;
 1:         }
 1:         if (NS_FAILED(selectElement->IsOptionDisabled(i, &isDisabled))) {
 1:           break;
 1:         }
 1:         if (isDisabled) {
 1:           node = nsnull;
 1:         } else {
 1:           break;
 1:         }
 1:       }
 1:       if (!node) {
 1:         return;
 1:       }
 1:     }
 1: 
 1:     // if we found a node use it, if not get the first child (this is for empty selects)
 1:     if (node) {
 1:       focusedContent = do_QueryInterface(node);
 1:       childframe = presShell->GetPrimaryFrameFor(focusedContent);
 1:     }
 1:     if (!childframe) {
 1:       // Failing all else, try the first thing we have, but only if
 1:       // it's an element.  Text frames need not apply.
 1:       childframe = containerFrame->GetFirstChild(nsnull);
 1:       if (childframe &&
 1:           !childframe->GetContent()->IsNodeOfType(nsINode::eELEMENT)) {
 1:         childframe = nsnull;
 1:       }
 1:       result = NS_OK;
 1:     }
 1:   }
 1: 
 1:   nsRect fRect;
 1:   if (childframe) {
 1:     // get the child rect
 1:     fRect = childframe->GetRect();
 1:     // get it into our coordinates
 1:     fRect.MoveBy(childframe->GetParent()->GetOffsetTo(this));
 1:   } else {
 1:     fRect.x = fRect.y = 0;
 1:     fRect.width = GetScrollPortSize().width;
 1:     fRect.height = CalcFallbackRowHeight(0);
 1:     fRect.MoveBy(containerFrame->GetOffsetTo(this));
 1:   }
 1:   fRect += aPt;
 1:   
 1:   PRBool lastItemIsSelected = PR_FALSE;
 1:   if (focusedContent) {
 1:     nsCOMPtr<nsIDOMHTMLOptionElement> domOpt =
 1:       do_QueryInterface(focusedContent);
 1:     if (domOpt) {
 1:       domOpt->GetSelected(&lastItemIsSelected);
 1:     }
 1:   }
 1: 
 1:   // set up back stop colors and then ask L&F service for the real colors
 1:   nscolor color;
 1:   presContext->LookAndFeel()->
 1:     GetColor(lastItemIsSelected ?
 1:              nsILookAndFeel::eColor_WidgetSelectForeground :
 1:              nsILookAndFeel::eColor_WidgetSelectBackground, color);
 1: 
 1:   nscoord onePixelInTwips = nsPresContext::CSSPixelsToAppUnits(1);
 1: 
 1:   nsRect dirty;
 1:   nscolor colors[] = {color, color, color, color};
 1:   PRUint8 borderStyle[] = {NS_STYLE_BORDER_STYLE_DOTTED, NS_STYLE_BORDER_STYLE_DOTTED, NS_STYLE_BORDER_STYLE_DOTTED, NS_STYLE_BORDER_STYLE_DOTTED};
 1:   nsRect innerRect = fRect;
 1:   innerRect.Deflate(nsSize(onePixelInTwips, onePixelInTwips));
 1:   nsCSSRendering::DrawDashedSides(0, aRC, dirty, borderStyle, colors, fRect, innerRect, 0, nsnull);
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // Frames are not refcounted, no need to AddRef
 1: NS_IMETHODIMP
 1: nsListControlFrame::QueryInterface(const nsIID& aIID, void** aInstancePtr)
 1: {
 1:   if (NULL == aInstancePtr) {
 1:     return NS_ERROR_NULL_POINTER;
 1:   }
 1:   if (aIID.Equals(NS_GET_IID(nsIFormControlFrame))) {
 1:     *aInstancePtr = (void*) ((nsIFormControlFrame*) this);
 1:     return NS_OK;
 1:   }
 1:   if (aIID.Equals(NS_GET_IID(nsIListControlFrame))) {
 1:     *aInstancePtr = (void *)((nsIListControlFrame*)this);
 1:     return NS_OK;
 1:   }
 1:   if (aIID.Equals(NS_GET_IID(nsISelectControlFrame))) {
 1:     *aInstancePtr = (void *)((nsISelectControlFrame*)this);
 1:     return NS_OK;
 1:   }
 1:   return nsHTMLScrollFrame::QueryInterface(aIID, aInstancePtr);
 1: }
 1: 
 1: #ifdef ACCESSIBILITY
 1: NS_IMETHODIMP nsListControlFrame::GetAccessible(nsIAccessible** aAccessible)
 1: {
 1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
 1: 
 1:   if (accService) {
 1:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(mContent);
 1:     nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(GetPresContext()->PresShell()));
 1:     return accService->CreateHTMLListboxAccessible(node, weakShell, aAccessible);
 1:   }
 1: 
 1:   return NS_ERROR_FAILURE;
 1: }
 1: #endif
 1: 
 1: static nscoord
 1: GetMaxOptionHeight(nsIFrame* aContainer)
 1: {
 1:   nscoord result = 0;
 1:   for (nsIFrame* option = aContainer->GetFirstChild(nsnull);
 1:        option; option = option->GetNextSibling()) {
 1:     nscoord optionHeight;
 1:     if (nsCOMPtr<nsIDOMHTMLOptGroupElement>
 1:         (do_QueryInterface(option->GetContent()))) {
 1:       // an optgroup
 1:       optionHeight = GetMaxOptionHeight(option);
 1:     } else {
 1:       // an option
 1:       optionHeight = option->GetSize().height;
 1:     }
 1:     if (result < optionHeight)
 1:       result = optionHeight;
 1:   }
 1:   return result;
 1: }
 1: 
 1: static inline PRBool
 1: IsOptGroup(nsIContent *aContent)
 1: {
 1:   return (aContent->NodeInfo()->Equals(nsGkAtoms::optgroup) &&
 1:           aContent->IsNodeOfType(nsINode::eHTML));
 1: }
 1: 
 1: static inline PRBool
 1: IsOption(nsIContent *aContent)
 1: {
 1:   return (aContent->NodeInfo()->Equals(nsGkAtoms::option) &&
 1:           aContent->IsNodeOfType(nsINode::eHTML));
 1: }
 1: 
 1: static PRUint32
 1: GetNumberOfOptionsRecursive(nsIContent* aContent)
 1: {
 1:   PRUint32 optionCount = 0;
 1:   const PRUint32 childCount = aContent ? aContent->GetChildCount() : 0;
 1:   for (PRUint32 index = 0; index < childCount; ++index) {
 1:     nsIContent* child = aContent->GetChildAt(index);
 1:     if (::IsOption(child)) {
 1:       ++optionCount;
 1:     }
 1:     else if (::IsOptGroup(child)) {
 1:       optionCount += ::GetNumberOfOptionsRecursive(child);
 1:     }
 1:   }
 1:   return optionCount;
 1: }
 1: 
 1: static nscoord
 1: GetOptGroupLabelsHeight(nsPresContext* aPresContext,
 1:                         nsIContent*    aContent,
 1:                         nscoord        aRowHeight)
 1: {
 1:   nscoord height = 0;
 1:   const PRUint32 childCount = aContent ? aContent->GetChildCount() : 0;
 1:   for (PRUint32 index = 0; index < childCount; ++index) {
 1:     nsIContent* child = aContent->GetChildAt(index);
 1:     if (::IsOptGroup(child)) {
 1:       PRUint32 numOptions = ::GetNumberOfOptionsRecursive(child);
 1:       nscoord optionsHeight = aRowHeight * numOptions;
 1:       nsIFrame* frame = aPresContext->GetPresShell()->GetPrimaryFrameFor(child);
 1:       nscoord totalHeight = frame ? frame->GetSize().height : 0;
 1:       height += PR_MAX(0, totalHeight - optionsHeight);
 1:     }
 1:   }
 1:   return height;
 1: }
 1: 
 1: //-----------------------------------------------------------------
 1: // Main Reflow for ListBox/Dropdown
 1: //-----------------------------------------------------------------
 1: 
 1: nscoord
 1: nsListControlFrame::CalcHeightOfARow()
 1: {
 1:   // Calculate the height of a single row in the listbox or dropdown list by
 1:   // using the tallest thing in the subtree, since there may be option groups
 1:   // in addition to option elements, either of which may be visible or
 1:   // invisible, may use different fonts, etc.
 1:   PRInt32 heightOfARow = GetMaxOptionHeight(GetOptionsContainer());
 1: 
 1:   // Check to see if we have zero items 
 1:   if (heightOfARow == 0) {
 1:     heightOfARow = CalcFallbackRowHeight(GetNumberOfOptions());
 1:   }
 1: 
 1:   return heightOfARow;
 1: }
 1: 
 1: nscoord
 1: nsListControlFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
 1: {
 1:   // We don't want to have options wrapping unless they absolutely
 1:   // have to, so our min width is our pref width.
 1:   nscoord result;
 1:   DISPLAY_MIN_WIDTH(this, result);
 1: 
 1:   result = GetPrefWidth(aRenderingContext);
 1: 
 1:   return result;
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsListControlFrame::Reflow(nsPresContext*           aPresContext, 
 1:                            nsHTMLReflowMetrics&     aDesiredSize,
 1:                            const nsHTMLReflowState& aReflowState, 
 1:                            nsReflowStatus&          aStatus)
 1: {
 1:   NS_PRECONDITION(aReflowState.ComputedWidth() != NS_UNCONSTRAINEDSIZE,
 1:                   "Must have a computed width");
 1: 
 1:   // If all the content and frames are here 
 1:   // then initialize it before reflow
 1:   if (mIsAllContentHere && !mHasBeenInitialized) {
 1:     if (PR_FALSE == mIsAllFramesHere) {
 1:       CheckIfAllFramesHere();
 1:     }
 1:     if (mIsAllFramesHere && !mHasBeenInitialized) {
 1:       mHasBeenInitialized = PR_TRUE;
 1:     }
 1:   }
 1: 
 1:   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
 1:     nsFormControlFrame::RegUnRegAccessKey(this, PR_TRUE);
 1:   }
 1: 
 1:   if (IsInDropDownMode()) {
 1:     return ReflowAsDropdown(aPresContext, aDesiredSize, aReflowState, aStatus);
 1:   }
 1: 
 1:   /*
 1:    * Due to the fact that our intrinsic height depends on the heights of our
 1:    * kids, we end up having to do two-pass reflow, in general -- the first pass
 1:    * to find the intrinsic height and a second pass to reflow the scrollframe
 1:    * at that height (which will size the scrollbars correctly, etc).
 1:    *
 1:    * Naturaly, we want to avoid doing the second reflow as much as possible.
 1:    * We can skip it in the following cases (in all of which the first reflow is
 1:    * already happening at the right height):
 1:    *
 1:    * - We're reflowing with a constrained computed height -- just use that
 1:    *   height.
 1:    * - We're not dirty and have no dirty kids.  In this case, our cached max
 1:    *   height of a child is not going to change.
 1:    * - We do our first reflow using our cached max height of a child, then
 1:    *   compute the new max height and it's the same as the old one.
 1:    */
 1: 
 1:   PRBool autoHeight = (aReflowState.mComputedHeight == NS_UNCONSTRAINEDSIZE);
 1: 
 1:   mMightNeedSecondPass = autoHeight &&
 1:     (GetStateBits() & (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN));
 1:   
 1:   nsHTMLReflowState state(aReflowState);
 1:   PRInt32 length = GetNumberOfOptions();  
 1: 
 1:   nscoord oldHeightOfARow = HeightOfARow();
 1:   
 1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW) && autoHeight) {
 1:     // When not doing an initial reflow, and when the height is auto, start off
 1:     // with our computed height set to what we'd expect our height to be.
 1:     state.mComputedHeight = CalcIntrinsicHeight(oldHeightOfARow, length);
 1:     state.ApplyMinMaxConstraints(nsnull, &state.mComputedHeight);
 1:   }
 1: 
 1:   nsresult rv = nsHTMLScrollFrame::Reflow(aPresContext, aDesiredSize,
 1:                                           state, aStatus);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (!mMightNeedSecondPass) {
 1:     NS_ASSERTION(!autoHeight || HeightOfARow() == oldHeightOfARow,
 1:                  "How did our height of a row change if nothing was dirty?");
 1:     NS_ASSERTION(!IsScrollbarUpdateSuppressed(),
 1:                  "Shouldn't be suppressing if we don't need a second pass!");
 1:     return rv;
 1:   }
 1: 
 1:   mMightNeedSecondPass = PR_FALSE;
 1: 
 1:   // Now see whether we need a second pass.  If we do, our nsSelectsAreaFrame
 1:   // will have suppressed the scrollbar update.
 1:   if (!IsScrollbarUpdateSuppressed()) {
 1:     // All done.  No need to do more reflow.
 1:     NS_ASSERTION(!IsScrollbarUpdateSuppressed(),
 1:                  "Shouldn't be suppressing if the height of a row has not "
 1:                  "changed!");
 1:     return rv;
 1:   }
 1: 
 1:   SetSuppressScrollbarUpdate(PR_FALSE);
 1: 
 1:   // Gotta reflow again.
 1:   // XXXbz We're just changing the height here; do we need to dirty ourselves
 1:   // or anything like that?  We might need to, per the letter of the reflow
 1:   // protocol, but things seem to work fine without it...  Is that just an
 1:   // implementation detail of nsHTMLScrollFrame that we're depending on?
 1:   nsHTMLScrollFrame::DidReflow(aPresContext, &state, aStatus);
 1: 
 1:   // Now compute the height we want to have
 1:   state.mComputedHeight = CalcIntrinsicHeight(HeightOfARow(), length);
 1:   state.ApplyMinMaxConstraints(nsnull, &state.mComputedHeight);
 1: 
 1:   nsHTMLScrollFrame::WillReflow(aPresContext);
 1: 
 1:   // XXXbz to make the ascent really correct, we should add our
 1:   // mComputedPadding.top to it (and subtract it from descent).  Need that
 1:   // because nsGfxScrollFrame just adds in the border....
 1:   return nsHTMLScrollFrame::Reflow(aPresContext, aDesiredSize, state, aStatus);
 1: }
 1: 
 1: nsresult
 1: nsListControlFrame::ReflowAsDropdown(nsPresContext*           aPresContext, 
 1:                                      nsHTMLReflowMetrics&     aDesiredSize,
 1:                                      const nsHTMLReflowState& aReflowState, 
 1:                                      nsReflowStatus&          aStatus)
 1: {
 1:   NS_PRECONDITION(aReflowState.mComputedHeight == NS_UNCONSTRAINEDSIZE,
 1:                   "We should not have a computed height here!");
 1:   
 1:   mMightNeedSecondPass =
 1:     (GetStateBits() & (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN)) != 0;
 1: 
 1:   nscoord oldHeightOfARow = HeightOfARow();
 1: 
 1:   nsHTMLReflowState state(aReflowState);
 1: 
 1:   nscoord oldVisibleHeight;
 1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 1:     // When not doing an initial reflow, and when the height is auto, start off
 1:     // with our computed height set to what we'd expect our height to be.
 1:     // Note: At this point, mLastDropdownComputedHeight can be
 1:     // NS_UNCONSTRAINEDSIZE in cases when last time we didn't have to constrain
 1:     // the height.  That's fine; just do the same thing as last time.
 1:     state.mComputedHeight = mLastDropdownComputedHeight;
 1:     oldVisibleHeight = GetScrolledFrame()->GetSize().height;
 1:   } else {
 1:     // Set oldVisibleHeight to something that will never test true against a
 1:     // real height.
 1:     oldVisibleHeight = NS_UNCONSTRAINEDSIZE;
 1:   }
 1: 
 1:   nsresult rv = nsHTMLScrollFrame::Reflow(aPresContext, aDesiredSize,
 1:                                           state, aStatus);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (!mMightNeedSecondPass) {
 1:     NS_ASSERTION(oldVisibleHeight == GetScrolledFrame()->GetSize().height,
 1:                  "How did our kid's height change if nothing was dirty?");
 1:     NS_ASSERTION(HeightOfARow() == oldHeightOfARow,
 1:                  "How did our height of a row change if nothing was dirty?");
 1:     NS_ASSERTION(!IsScrollbarUpdateSuppressed(),
 1:                  "Shouldn't be suppressing if we don't need a second pass!");
 1:     NS_ASSERTION(!(GetStateBits() & NS_FRAME_FIRST_REFLOW),
 1:                  "How can we avoid a second pass during first reflow?");
 1:     return rv;
 1:   }
 1: 
 1:   mMightNeedSecondPass = PR_FALSE;
 1: 
 1:   // Now see whether we need a second pass.  If we do, our nsSelectsAreaFrame
 1:   // will have suppressed the scrollbar update.
 1:   if (!IsScrollbarUpdateSuppressed()) {
 1:     // All done.  No need to do more reflow.
 1:     NS_ASSERTION(!(GetStateBits() & NS_FRAME_FIRST_REFLOW),
 1:                  "How can we avoid a second pass during first reflow?");
 1:     return rv;
 1:   }
 1: 
 1:   SetSuppressScrollbarUpdate(PR_FALSE);
 1: 
 1:   nscoord visibleHeight = GetScrolledFrame()->GetSize().height;
 1:   nscoord heightOfARow = HeightOfARow();
 1: 
 1:   // Gotta reflow again.
 1:   // XXXbz We're just changing the height here; do we need to dirty ourselves
 1:   // or anything like that?  We might need to, per the letter of the reflow
 1:   // protocol, but things seem to work fine without it...  Is that just an
 1:   // implementation detail of nsHTMLScrollFrame that we're depending on?
 1:   nsHTMLScrollFrame::DidReflow(aPresContext, &state, aStatus);
 1: 
 1:   // Now compute the height we want to have
 1:   mNumDisplayRows = kMaxDropDownRows;
 1:   if (visibleHeight > mNumDisplayRows * heightOfARow) {
 1:     visibleHeight = mNumDisplayRows * heightOfARow;
 1:     // This is an adaptive algorithm for figuring out how many rows 
 1:     // should be displayed in the drop down. The standard size is 20 rows, 
 1:     // but on 640x480 it is typically too big.
 1:     // This takes the height of the screen divides it by two and then subtracts off 
 1:     // an estimated height of the combobox. I estimate it by taking the max element size
 1:     // of the drop down and multiplying it by 2 (this is arbitrary) then subtract off
 1:     // the border and padding of the drop down (again rather arbitrary)
 1:     // This all breaks down if the font of the combobox is a lot larger then the option items
 1:     // or CSS style has set the height of the combobox to be rather large.
 1:     // We can fix these cases later if they actually happen.
 1:     nscoord screenHeightInPixels = 0;
 1:     if (NS_SUCCEEDED(nsFormControlFrame::GetScreenHeight(aPresContext, screenHeightInPixels))) {
 1:       nscoord screenHeight = aPresContext->DevPixelsToAppUnits(screenHeightInPixels);
 1:       
 1:       nscoord availDropHgt = (screenHeight / 2) - (heightOfARow*2); // approx half screen minus combo size
 1:       availDropHgt -= aReflowState.mComputedBorderPadding.top + aReflowState.mComputedBorderPadding.bottom;
 1:       
 1:       nscoord hgt = visibleHeight + aReflowState.mComputedBorderPadding.top + aReflowState.mComputedBorderPadding.bottom;
 1:       if (heightOfARow > 0) {
 1:         if (hgt > availDropHgt) {
 1:           visibleHeight = (availDropHgt / heightOfARow) * heightOfARow;
 1:         }
 1:         mNumDisplayRows = visibleHeight / heightOfARow;
 1:       } else {
 1:         // Hmmm, not sure what to do here. Punt, and make both of them one
 1:         visibleHeight   = 1;
 1:         mNumDisplayRows = 1;
 1:       }
 1:     }
 1: 
 1:     state.mComputedHeight = mNumDisplayRows * heightOfARow;
 1:     // Note: no need to apply min/max constraints, since we have no such
 1:     // rules applied to the combobox dropdown.
 1:     // XXXbz this is ending up too big!!  Figure out why.
 1:   } else if (visibleHeight == 0) {
 1:     // Looks like we have no options.  Just size us to a single row height.
 1:     state.mComputedHeight = heightOfARow;
 1:   } else {
 1:     // Not too big, not too small.  Just use it!
 1:     state.mComputedHeight = NS_UNCONSTRAINEDSIZE;
 1:   }
 1: 
 1:   // Note: At this point, state.mComputedHeight can be NS_UNCONSTRAINEDSIZE in
 1:   // cases when there were some options, but not too many (so no scrollbar was
 1:   // needed).  That's fine; just store that.
 1:   mLastDropdownComputedHeight = state.mComputedHeight;
 1: 
 1:   nsHTMLScrollFrame::WillReflow(aPresContext);
 1:   return nsHTMLScrollFrame::Reflow(aPresContext, aDesiredSize, state, aStatus);
 1: }
 1: 
 1: nsGfxScrollFrameInner::ScrollbarStyles
 1: nsListControlFrame::GetScrollbarStyles() const
 1: {
 1:   // We can't express this in the style system yet; when we can, this can go away
 1:   // and GetScrollbarStyles can be devirtualized
 1:   PRInt32 verticalStyle = IsInDropDownMode() ? NS_STYLE_OVERFLOW_AUTO
 1:     : NS_STYLE_OVERFLOW_SCROLL;
 1:   return nsGfxScrollFrameInner::ScrollbarStyles(NS_STYLE_OVERFLOW_HIDDEN,
 1:                                                 verticalStyle);
 1: }
 1: 
 1: //---------------------------------------------------------
 1: PRBool 
 1: nsListControlFrame::IsOptionElement(nsIContent* aContent)
 1: {
 1:   PRBool result = PR_FALSE;
 1:  
 1:   nsCOMPtr<nsIDOMHTMLOptionElement> optElem;
 1:   if (NS_SUCCEEDED(aContent->QueryInterface(NS_GET_IID(nsIDOMHTMLOptionElement),(void**) getter_AddRefs(optElem)))) {      
 1:     if (optElem != nsnull) {
 1:       result = PR_TRUE;
 1:     }
 1:   }
 1:  
 1:   return result;
 1: }
 1: 
 1: nsIFrame*
 1: nsListControlFrame::GetContentInsertionFrame() {
 1:   return GetOptionsContainer()->GetContentInsertionFrame();
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // Starts at the passed in content object and walks up the 
 1: // parent heierarchy looking for the nsIDOMHTMLOptionElement
 1: //---------------------------------------------------------
 1: nsIContent *
 1: nsListControlFrame::GetOptionFromContent(nsIContent *aContent) 
 1: {
 1:   for (nsIContent* content = aContent; content; content = content->GetParent()) {
 1:     if (IsOptionElement(content)) {
 1:       return content;
 1:     }
 1:   }
 1: 
 1:   return nsnull;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // Finds the index of the hit frame's content in the list
 1: // of option elements
 1: //---------------------------------------------------------
 1: PRInt32 
 1: nsListControlFrame::GetIndexFromContent(nsIContent *aContent)
 1: {
 1:   nsCOMPtr<nsIDOMHTMLOptionElement> option;
 1:   option = do_QueryInterface(aContent);
 1:   if (option) {
 1:     PRInt32 retval;
 1:     option->GetIndex(&retval);
 1:     if (retval >= 0) {
 1:       return retval;
 1:     }
 1:   }
 1:   return kNothingSelected;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: PRBool
 1: nsListControlFrame::ExtendedSelection(PRInt32 aStartIndex,
 1:                                       PRInt32 aEndIndex,
 1:                                       PRBool aClearAll)
 1: {
 1:   return SetOptionsSelectedFromFrame(aStartIndex, aEndIndex,
 1:                                      PR_TRUE, aClearAll);
 1: }
 1: 
 1: //---------------------------------------------------------
 1: PRBool
 1: nsListControlFrame::SingleSelection(PRInt32 aClickedIndex, PRBool aDoToggle)
 1: {
 1:   if (mComboboxFrame) {
 1:     mComboboxFrame->UpdateRecentIndex(GetSelectedIndex());
 1:   }
 1: 
 1:   PRBool wasChanged = PR_FALSE;
 1:   // Get Current selection
 1:   if (aDoToggle) {
 1:     wasChanged = ToggleOptionSelectedFromFrame(aClickedIndex);
 1:   } else {
 1:     wasChanged = SetOptionsSelectedFromFrame(aClickedIndex, aClickedIndex,
 1:                                 PR_TRUE, PR_TRUE);
 1:   }
 1:   ScrollToIndex(aClickedIndex);
 1:   mStartSelectionIndex = aClickedIndex;
 1:   mEndSelectionIndex = aClickedIndex;
 1:   return wasChanged;
 1: }
 1: 
 1: void
 1: nsListControlFrame::InitSelectionRange(PRInt32 aClickedIndex)
 1: {
 1:   //
 1:   // If nothing is selected, set the start selection depending on where
 1:   // the user clicked and what the initial selection is:
 1:   // - if the user clicked *before* selectedIndex, set the start index to
 1:   //   the end of the first contiguous selection.
 1:   // - if the user clicked *after* the end of the first contiguous
 1:   //   selection, set the start index to selectedIndex.
 1:   // - if the user clicked *within* the first contiguous selection, set the
 1:   //   start index to selectedIndex.
 1:   // The last two rules, of course, boil down to the same thing: if the user
 1:   // clicked >= selectedIndex, return selectedIndex.
 1:   //
 1:   // This makes it so that shift click works properly when you first click
 1:   // in a multiple select.
 1:   //
 1:   PRInt32 selectedIndex = GetSelectedIndex();
 1:   if (selectedIndex >= 0) {
 1:     // Get the end of the contiguous selection
 1:     nsCOMPtr<nsIDOMHTMLOptionsCollection> options = GetOptions(mContent);
 1:     NS_ASSERTION(options, "Collection of options is null!");
 1:     PRUint32 numOptions;
 1:     options->GetLength(&numOptions);
 1:     PRUint32 i;
 1:     // Push i to one past the last selected index in the group
 1:     for (i=selectedIndex+1; i < numOptions; i++) {
 1:       PRBool selected;
 1:       nsCOMPtr<nsIDOMHTMLOptionElement> option = GetOption(options, i);
 1:       option->GetSelected(&selected);
 1:       if (!selected) {
 1:         break;
 1:       }
 1:     }
 1: 
 1:     if (aClickedIndex < selectedIndex) {
 1:       // User clicked before selection, so start selection at end of
 1:       // contiguous selection
 1:       mStartSelectionIndex = i-1;
 1:       mEndSelectionIndex = selectedIndex;
 1:     } else {
 1:       // User clicked after selection, so start selection at start of
 1:       // contiguous selection
 1:       mStartSelectionIndex = selectedIndex;
 1:       mEndSelectionIndex = i-1;
 1:     }
 1:   }
 1: }
 1: 
 1: //---------------------------------------------------------
 1: PRBool
 1: nsListControlFrame::PerformSelection(PRInt32 aClickedIndex,
 1:                                      PRBool aIsShift,
 1:                                      PRBool aIsControl)
 1: {
 1:   PRBool wasChanged = PR_FALSE;
 1: 
 1:   if (aClickedIndex == kNothingSelected) {
 1:   }
 1:   else if (GetMultiple()) {
 1:     if (aIsShift) {
 1:       // Make sure shift+click actually does something expected when
 1:       // the user has never clicked on the select
 1:       if (mStartSelectionIndex == kNothingSelected) {
 1:         InitSelectionRange(aClickedIndex);
 1:       }
 1: 
 1:       // Get the range from beginning (low) to end (high)
 1:       // Shift *always* works, even if the current option is disabled
 1:       PRInt32 startIndex;
 1:       PRInt32 endIndex;
 1:       if (mStartSelectionIndex == kNothingSelected) {
 1:         startIndex = aClickedIndex;
 1:         endIndex   = aClickedIndex;
 1:       } else if (mStartSelectionIndex <= aClickedIndex) {
 1:         startIndex = mStartSelectionIndex;
 1:         endIndex   = aClickedIndex;
 1:       } else {
 1:         startIndex = aClickedIndex;
 1:         endIndex   = mStartSelectionIndex;
 1:       }
 1: 
 1:       // Clear only if control was not pressed
 1:       wasChanged = ExtendedSelection(startIndex, endIndex, !aIsControl);
 1:       ScrollToIndex(aClickedIndex);
 1: 
 1:       if (mStartSelectionIndex == kNothingSelected) {
 1:         mStartSelectionIndex = aClickedIndex;
 1:         mEndSelectionIndex = aClickedIndex;
 1:       } else {
 1:         mEndSelectionIndex = aClickedIndex;
 1:       }
 1:     } else if (aIsControl) {
 1:       wasChanged = SingleSelection(aClickedIndex, PR_TRUE);
 1:     } else {
 1:       wasChanged = SingleSelection(aClickedIndex, PR_FALSE);
 1:     }
 1:   } else {
 1:     wasChanged = SingleSelection(aClickedIndex, PR_FALSE);
 1:   }
 1: 
 1:   return wasChanged;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: PRBool
 1: nsListControlFrame::HandleListSelection(nsIDOMEvent* aEvent,
 1:                                         PRInt32 aClickedIndex)
 1: {
 1:   nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
 1:   PRBool isShift;
 1:   PRBool isControl;
 1: #ifdef XP_MACOSX
 1:   mouseEvent->GetMetaKey(&isControl);
 1: #else
 1:   mouseEvent->GetCtrlKey(&isControl);
 1: #endif
 1:   mouseEvent->GetShiftKey(&isShift);
 1:   return PerformSelection(aClickedIndex, isShift, isControl);
 1: }
 1: 
 1: //---------------------------------------------------------
 1: void
 1: nsListControlFrame::CaptureMouseEvents(PRBool aGrabMouseEvents)
 1: {
 1:   // Currently cocoa widgets use a native popup widget which tracks clicks synchronously,
 1:   // so we never want to do mouse capturing. Note that we only bail if the list
 1:   // is in drop-down mode, and the caller is requesting capture (we let release capture
 1:   // requests go through to ensure that we can release capture requested via other
 1:   // code paths, if any exist).
 1:   if (aGrabMouseEvents && IsInDropDownMode() && nsComboboxControlFrame::ToolkitHasNativePopup())
 1:     return;
 1:   
 1:   nsIView* view = GetScrolledFrame()->GetView();
 1: 
 1:   NS_ASSERTION(view, "no view???");
 1:   if (NS_UNLIKELY(!view))
 1:     return;
 1: 
 1:   nsIViewManager* viewMan = view->GetViewManager();
 1:   if (viewMan) {
 1:     PRBool result;
 1:     // It's not clear why we don't have the widget capture mouse events here.
 1:     if (aGrabMouseEvents) {
 1:       viewMan->GrabMouseEvents(view, result);
 1:     } else {
 1:       nsIView* curGrabber;
 1:       viewMan->GetMouseEventGrabber(curGrabber);
 1:       PRBool dropDownIsHidden = PR_FALSE;
 1:       if (IsInDropDownMode()) {
 1:         dropDownIsHidden = !mComboboxFrame->IsDroppedDown();
 1:       }
 1:       if (curGrabber == view || dropDownIsHidden) {
 1:         // only unset the grabber if *we* are the ones doing the grabbing
 1:         // (or if the dropdown is hidden, in which case NO-ONE should be
 1:         // grabbing anything
 1:         // it could be a scrollbar inside this listbox which is actually grabbing
 1:         // This shouldn't be necessary. We should simply ensure that events targeting
 1:         // scrollbars are never visible to DOM consumers.
 1:         viewMan->GrabMouseEvents(nsnull, result);
 1:       }
 1:     }
 1:   }
 1: }
 1: 
 1: //---------------------------------------------------------
 1: NS_IMETHODIMP 
 1: nsListControlFrame::HandleEvent(nsPresContext* aPresContext, 
 1:                                 nsGUIEvent*    aEvent,
 1:                                 nsEventStatus* aEventStatus)
 1: {
 1:   NS_ENSURE_ARG_POINTER(aEventStatus);
 1: 
 1:   /*const char * desc[] = {"NS_MOUSE_MOVE", 
 1:                           "NS_MOUSE_LEFT_BUTTON_UP",
 1:                           "NS_MOUSE_LEFT_BUTTON_DOWN",
 1:                           "<NA>","<NA>","<NA>","<NA>","<NA>","<NA>","<NA>",
 1:                           "NS_MOUSE_MIDDLE_BUTTON_UP",
 1:                           "NS_MOUSE_MIDDLE_BUTTON_DOWN",
 1:                           "<NA>","<NA>","<NA>","<NA>","<NA>","<NA>","<NA>","<NA>",
 1:                           "NS_MOUSE_RIGHT_BUTTON_UP",
 1:                           "NS_MOUSE_RIGHT_BUTTON_DOWN",
 1:                           "NS_MOUSE_ENTER_SYNTH",
 1:                           "NS_MOUSE_EXIT_SYNTH",
 1:                           "NS_MOUSE_LEFT_DOUBLECLICK",
 1:                           "NS_MOUSE_MIDDLE_DOUBLECLICK",
 1:                           "NS_MOUSE_RIGHT_DOUBLECLICK",
 1:                           "NS_MOUSE_LEFT_CLICK",
 1:                           "NS_MOUSE_MIDDLE_CLICK",
 1:                           "NS_MOUSE_RIGHT_CLICK"};
 1:   int inx = aEvent->message-NS_MOUSE_MESSAGE_START;
 1:   if (inx >= 0 && inx <= (NS_MOUSE_RIGHT_CLICK-NS_MOUSE_MESSAGE_START)) {
 1:     printf("Mouse in ListFrame %s [%d]\n", desc[inx], aEvent->message);
 1:   } else {
 1:     printf("Mouse in ListFrame <UNKNOWN> [%d]\n", aEvent->message);
 1:   }*/
 1: 
 1:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus)
 1:     return NS_OK;
 1: 
 1:   // do we have style that affects how we are selected?
 1:   // do we have user-input style?
 1:   const nsStyleUserInterface* uiStyle = GetStyleUserInterface();
 1:   if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE || uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED)
 1:     return nsFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
 1: 
 1:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled))
 1:     return NS_OK;
 1: 
 1:   return nsHTMLScrollFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
 1: }
 1: 
 1: 
 1: //---------------------------------------------------------
 1: NS_IMETHODIMP
 1: nsListControlFrame::SetInitialChildList(nsIAtom*       aListName,
 1:                                         nsIFrame*      aChildList)
 1: {
 1:   // First check to see if all the content has been added
 1:   mIsAllContentHere = mContent->IsDoneAddingChildren();
 1:   if (!mIsAllContentHere) {
 1:     mIsAllFramesHere    = PR_FALSE;
 1:     mHasBeenInitialized = PR_FALSE;
 1:   }
 1:   nsresult rv = nsHTMLScrollFrame::SetInitialChildList(aListName, aChildList);
 1: 
 1:   // If all the content is here now check
 1:   // to see if all the frames have been created
 1:   /*if (mIsAllContentHere) {
 1:     // If all content and frames are here
 1:     // the reset/initialize
 1:     if (CheckIfAllFramesHere()) {
 1:       ResetList(aPresContext);
 1:       mHasBeenInitialized = PR_TRUE;
 1:     }
 1:   }*/
 1: 
 1:   return rv;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: nsresult
 1: nsListControlFrame::GetSizeAttribute(PRInt32 *aSize) {
 1:   nsresult rv = NS_OK;
 1:   nsIDOMHTMLSelectElement* selectElement;
 1:   rv = mContent->QueryInterface(NS_GET_IID(nsIDOMHTMLSelectElement),(void**) &selectElement);
 1:   if (mContent && NS_SUCCEEDED(rv)) {
 1:     rv = selectElement->GetSize(aSize);
 1:     NS_RELEASE(selectElement);
 1:   }
 1:   return rv;
 1: }
 1: 
 1: 
 1: //---------------------------------------------------------
 1: NS_IMETHODIMP  
 1: nsListControlFrame::Init(nsIContent*     aContent,
 1:                          nsIFrame*       aParent,
 1:                          nsIFrame*       aPrevInFlow)
 1: {
 1:   nsresult result = nsHTMLScrollFrame::Init(aContent, aParent, aPrevInFlow);
 1: 
 1:   // get the receiver interface from the browser button's content node
 1:   nsCOMPtr<nsIDOMEventReceiver> receiver(do_QueryInterface(mContent));
 1: 
 1:   // we shouldn't have to unregister this listener because when
 1:   // our frame goes away all these content node go away as well
 1:   // because our frame is the only one who references them.
 1:   // we need to hook up our listeners before the editor is initialized
 1:   mEventListener = new nsListEventListener(this);
 1:   if (!mEventListener) 
 1:     return NS_ERROR_OUT_OF_MEMORY;
 1: 
 1:   receiver->AddEventListenerByIID(NS_STATIC_CAST(nsIDOMMouseListener*,
 1:                                                  mEventListener),
 1:                                   NS_GET_IID(nsIDOMMouseListener));
 1: 
 1:   receiver->AddEventListenerByIID(NS_STATIC_CAST(nsIDOMMouseMotionListener*,
 1:                                                  mEventListener),
 1:                                   NS_GET_IID(nsIDOMMouseMotionListener));
 1: 
 1:   receiver->AddEventListenerByIID(NS_STATIC_CAST(nsIDOMKeyListener*,
 1:                                                  mEventListener),
 1:                                   NS_GET_IID(nsIDOMKeyListener));
 1: 
 1:   mStartSelectionIndex = kNothingSelected;
 1:   mEndSelectionIndex = kNothingSelected;
 1: 
 1:   return result;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // Returns whether the nsIDOMHTMLSelectElement supports 
 1: // mulitple selection
 1: //---------------------------------------------------------
 1: PRBool
 1: nsListControlFrame::GetMultiple(nsIDOMHTMLSelectElement* aSelect) const
 1: {
 1:   PRBool multiple = PR_FALSE;
 1:   nsresult rv = NS_OK;
 1:   if (aSelect) {
 1:     rv = aSelect->GetMultiple(&multiple);
 1:   } else {
 1:     nsCOMPtr<nsIDOMHTMLSelectElement> selectElement = 
 1:        do_QueryInterface(mContent);
 1:   
 1:     if (selectElement) {
 1:       rv = selectElement->GetMultiple(&multiple);
 1:     }
 1:   }
 1:   if (NS_SUCCEEDED(rv)) {
 1:     return multiple;
 1:   }
 1:   return PR_FALSE;
 1: }
 1: 
 1: 
 1: //---------------------------------------------------------
 1: // Returns the nsIContent object in the collection 
 1: // for a given index (AddRefs)
 1: //---------------------------------------------------------
 1: already_AddRefed<nsIContent> 
 1: nsListControlFrame::GetOptionAsContent(nsIDOMHTMLOptionsCollection* aCollection, PRInt32 aIndex) 
 1: {
 1:   nsIContent * content = nsnull;
 1:   nsCOMPtr<nsIDOMHTMLOptionElement> optionElement = GetOption(aCollection,
 1:                                                               aIndex);
 1: 
 1:   NS_ASSERTION(optionElement != nsnull, "could not get option element by index!");
 1: 
 1:   if (optionElement) {
 1:     CallQueryInterface(optionElement, &content);
 1:   }
 1:  
 1:   return content;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // for a given index it returns the nsIContent object 
 1: // from the select
 1: //---------------------------------------------------------
 1: already_AddRefed<nsIContent> 
 1: nsListControlFrame::GetOptionContent(PRInt32 aIndex) const
 1:   
 1: {
 1:   nsCOMPtr<nsIDOMHTMLOptionsCollection> options = GetOptions(mContent);
 1:   NS_ASSERTION(options.get() != nsnull, "Collection of options is null!");
 1: 
 1:   if (options) {
 1:     return GetOptionAsContent(options, aIndex);
 1:   } 
 1:   return nsnull;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // This returns the options collection for aContent, if any
 1: //---------------------------------------------------------
 1: already_AddRefed<nsIDOMHTMLOptionsCollection>
 1: nsListControlFrame::GetOptions(nsIContent * aContent)
 1: {
 1:   nsIDOMHTMLOptionsCollection* options = nsnull;
 1:   nsCOMPtr<nsIDOMHTMLSelectElement> selectElement = do_QueryInterface(aContent);
 1:   if (selectElement) {
 1:     selectElement->GetOptions(&options);  // AddRefs (1)
 1:   }
 1: 
 1:   return options;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // Returns the nsIDOMHTMLOptionElement for a given index 
 1: // in the select's collection
 1: //---------------------------------------------------------
 1: already_AddRefed<nsIDOMHTMLOptionElement>
 1: nsListControlFrame::GetOption(nsIDOMHTMLOptionsCollection* aCollection,
 1:                               PRInt32 aIndex)
 1: {
 1:   nsCOMPtr<nsIDOMNode> node;
 1:   if (NS_SUCCEEDED(aCollection->Item(aIndex, getter_AddRefs(node)))) {
 1:     NS_ASSERTION(node,
 1:                  "Item was successful, but node from collection was null!");
 1:     if (node) {
 1:       nsIDOMHTMLOptionElement* option = nsnull;
 1:       CallQueryInterface(node, &option);
 1: 
 1:       return option;
 1:     }
 1:   } else {
 1:     NS_ERROR("Couldn't get option by index from collection!");
 1:   }
 1:   return nsnull;
 1: }
 1: 
 1: 
 1: //---------------------------------------------------------
 1: // For a given piece of content, it determines whether the 
 1: // content (an option) is selected or not
 1: // return PR_TRUE if it is, PR_FALSE if it is NOT
 1: //---------------------------------------------------------
 1: PRBool 
 1: nsListControlFrame::IsContentSelected(nsIContent* aContent) const
 1: {
 1:   PRBool isSelected = PR_FALSE;
 1: 
 1:   nsCOMPtr<nsIDOMHTMLOptionElement> optEl = do_QueryInterface(aContent);
 1:   if (optEl)
 1:     optEl->GetSelected(&isSelected);
 1: 
 1:   return isSelected;
 1: }
 1: 
 1: 
 1: //---------------------------------------------------------
 1: // For a given index is return whether the content is selected
 1: //---------------------------------------------------------
 1: PRBool 
 1: nsListControlFrame::IsContentSelectedByIndex(PRInt32 aIndex) const 
 1: {
 1:   nsCOMPtr<nsIContent> content = GetOptionContent(aIndex);
 1:   NS_ASSERTION(content, "Failed to retrieve option content");
 1: 
 1:   return IsContentSelected(content);
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // gets the content (an option) by index and then set it as
 1: // being selected or not selected
 1: //---------------------------------------------------------
 1: NS_IMETHODIMP
 1: nsListControlFrame::OnOptionSelected(nsPresContext* aPresContext,
 1:                                      PRInt32 aIndex,
 1:                                      PRBool aSelected)
 1: {
 1:   if (aSelected) {
 1:     ScrollToIndex(aIndex);
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: PRIntn
 1: nsListControlFrame::GetSkipSides() const
 1: {    
 1:     // Don't skip any sides during border rendering
 1:   return 0;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: void
 1: nsListControlFrame::OnContentReset()
 1: {
 1:   ResetList(PR_TRUE);
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // Resets the select back to it's original default values;
 1: // those values as determined by the original HTML
 1: //---------------------------------------------------------
 1: void 
 1: nsListControlFrame::ResetList(PRBool aAllowScrolling)
 1: {
 1:   // if all the frames aren't here 
 1:   // don't bother reseting
 1:   if (!mIsAllFramesHere) {
 1:     return;
 1:   }
 1: 
 1:   if (aAllowScrolling) {
 1:     mPostChildrenLoadedReset = PR_TRUE;
 1: 
 1:     // Scroll to the selected index
 1:     PRInt32 indexToSelect = kNothingSelected;
 1: 
 1:     nsCOMPtr<nsIDOMHTMLSelectElement> selectElement(do_QueryInterface(mContent));
 1:     NS_ASSERTION(selectElement, "No select element!");
 1:     if (selectElement) {
 1:       selectElement->GetSelectedIndex(&indexToSelect);
 1:       ScrollToIndex(indexToSelect);
 1:     }
 1:   }
 1: 
 1:   mStartSelectionIndex = kNothingSelected;
 1:   mEndSelectionIndex = kNothingSelected;
 1: 
 1:   // Combobox will redisplay itself with the OnOptionSelected event
 1: } 
 1:  
 1: //---------------------------------------------------------
 1: void 
 1: nsListControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)
 1: {
 1:   if (aOn) {
 1:     ComboboxFocusSet();
 1:     mFocused = this;
 1:   } else {
 1:     mFocused = nsnull;
 1:   }
 1: 
 1:   // Make sure the SelectArea frame gets painted
 1:   Invalidate(nsRect(0,0,mRect.width,mRect.height), PR_TRUE);
 1: }
 1: 
 1: void nsListControlFrame::ComboboxFocusSet()
 1: {
 1:   gLastKeyTime = 0;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: void
 1: nsListControlFrame::SetComboboxFrame(nsIFrame* aComboboxFrame)
 1: {
 1:   if (nsnull != aComboboxFrame) {
 1:     aComboboxFrame->QueryInterface(NS_GET_IID(nsIComboboxControlFrame),(void**) &mComboboxFrame); 
 1:   }
 1: }
 1: 
 1: 
 1: //---------------------------------------------------------
 1: // Gets the text of the currently selected item
 1: // if the there are zero items then an empty string is returned
 1: // if there is nothing selected, then the 0th item's text is returned
 1: //---------------------------------------------------------
 1: void
 1: nsListControlFrame::GetOptionText(PRInt32 aIndex, nsAString & aStr)
 1: {
 1:   aStr.SetLength(0);
 1:   nsCOMPtr<nsIDOMHTMLOptionsCollection> options = GetOptions(mContent);
 1: 
 1:   if (options) {
 1:     PRUint32 numOptions;
 1:     options->GetLength(&numOptions);
 1: 
 1:     if (numOptions != 0) {
 1:       nsCOMPtr<nsIDOMHTMLOptionElement> optionElement =
 1:         GetOption(options, aIndex);
 1:       if (optionElement) {
 1: #if 0 // This is for turning off labels Bug 4050
 1:         nsAutoString text;
 1:         optionElement->GetLabel(text);
 1:         // the return value is always NS_OK from DOMElements
 1:         // it is meaningless to check for it
 1:         if (!text.IsEmpty()) { 
 1:           nsAutoString compressText = text;
 1:           compressText.CompressWhitespace(PR_TRUE, PR_TRUE);
 1:           if (!compressText.IsEmpty()) {
 1:             text = compressText;
 1:           }
 1:         }
 1: 
 1:         if (text.IsEmpty()) {
 1:           // the return value is always NS_OK from DOMElements
 1:           // it is meaningless to check for it
 1:           optionElement->GetText(text);
 1:         }          
 1:         aStr = text;
 1: #else
 1:         optionElement->GetText(aStr);
 1: #endif
 1:       }
 1:     }
 1:   }
 1: }
 1: 
 1: //---------------------------------------------------------
 1: PRInt32
 1: nsListControlFrame::GetSelectedIndex()
 1: {
 1:   PRInt32 aIndex;
 1:   
 1:   nsCOMPtr<nsIDOMHTMLSelectElement> selectElement(do_QueryInterface(mContent));
 1:   selectElement->GetSelectedIndex(&aIndex);
 1:   
 1:   return aIndex;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: PRBool 
 1: nsListControlFrame::IsInDropDownMode() const
 1: {
 1:   return (mComboboxFrame != nsnull);
 1: }
 1: 
 1: //---------------------------------------------------------
 1: PRInt32
 1: nsListControlFrame::GetNumberOfOptions()
 1: {
 1:   if (mContent != nsnull) {
 1:     nsCOMPtr<nsIDOMHTMLOptionsCollection> options = GetOptions(mContent);
 1: 
 1:     if (!options) {
 1:       return 0;
 1:     } else {
 1:       PRUint32 length = 0;
 1:       options->GetLength(&length);
 1:       return (PRInt32)length;
 1:     }
 1:   }
 1:   return 0;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsISelectControlFrame
 1: //----------------------------------------------------------------------
 1: PRBool nsListControlFrame::CheckIfAllFramesHere()
 1: {
 1:   // Get the number of optgroups and options
 1:   //PRInt32 numContentItems = 0;
 1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
 1:   if (node) {
 1:     // XXX Need to find a fail proff way to determine that
 1:     // all the frames are there
 1:     mIsAllFramesHere = PR_TRUE;//NS_OK == CountAllChild(node, numContentItems);
 1:   }
 1:   // now make sure we have a frame each piece of content
 1: 
 1:   return mIsAllFramesHere;
 1: }
 1: 
 1: //-------------------------------------------------------------------
 1: NS_IMETHODIMP
 1: nsListControlFrame::DoneAddingChildren(PRBool aIsDone)
 1: {
 1:   mIsAllContentHere = aIsDone;
 1:   if (mIsAllContentHere) {
 1:     // Here we check to see if all the frames have been created 
 1:     // for all the content.
 1:     // If so, then we can initialize;
 1:     if (mIsAllFramesHere == PR_FALSE) {
 1:       // if all the frames are now present we can initialize
 1:       if (CheckIfAllFramesHere()) {
 1:         mHasBeenInitialized = PR_TRUE;
 1:         ResetList(PR_TRUE);
 1:       }
 1:     }
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: //-------------------------------------------------------------------
 1: NS_IMETHODIMP
 1: nsListControlFrame::AddOption(nsPresContext* aPresContext, PRInt32 aIndex)
 1: {
 1: #ifdef DO_REFLOW_DEBUG
 1:   printf("---- Id: %d nsLCF %p Added Option %d\n", mReflowId, this, aIndex);
 1: #endif
 1: 
 1:   if (!mIsAllContentHere) {
 1:     mIsAllContentHere = mContent->IsDoneAddingChildren();
 1:     if (!mIsAllContentHere) {
 1:       mIsAllFramesHere    = PR_FALSE;
 1:       mHasBeenInitialized = PR_FALSE;
 1:     } else {
 1:       mIsAllFramesHere = (aIndex == GetNumberOfOptions()-1);
 1:     }
 1:   }
 1:   
 1:   if (!mHasBeenInitialized) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   // Make sure we scroll to the selected option as needed
 1:   mNeedToReset = PR_TRUE;
 1:   mPostChildrenLoadedReset = mIsAllContentHere;
 1:   return NS_OK;
 1: }
 1: 
 1: //-------------------------------------------------------------------
 1: NS_IMETHODIMP
 1: nsListControlFrame::RemoveOption(nsPresContext* aPresContext, PRInt32 aIndex)
 1: {
 1:   // Need to reset if we're a dropdown
 1:   if (IsInDropDownMode()) {
 1:     mNeedToReset = PR_TRUE;
 1:     mPostChildrenLoadedReset = mIsAllContentHere;
 1:   }
 1: 
 1:   if (mStartSelectionIndex >= aIndex) {
 1:     --mStartSelectionIndex;
 1:     if (mStartSelectionIndex < 0) {
 1:       mStartSelectionIndex = kNothingSelected;
 1:     }    
 1:   }
 1: 
 1:   if (mEndSelectionIndex >= aIndex) {
 1:     --mEndSelectionIndex;
 1:     if (mEndSelectionIndex < 0) {
 1:       mEndSelectionIndex = kNothingSelected;
 1:     }    
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // Set the option selected in the DOM.  This method is named
 1: // as it is because it indicates that the frame is the source
 1: // of this event rather than the receiver.
 1: PRBool
 1: nsListControlFrame::SetOptionsSelectedFromFrame(PRInt32 aStartIndex,
 1:                                                 PRInt32 aEndIndex,
 1:                                                 PRBool aValue,
 1:                                                 PRBool aClearAll)
 1: {
 1:   nsCOMPtr<nsISelectElement> selectElement(do_QueryInterface(mContent));
 1:   PRBool wasChanged = PR_FALSE;
 1:   nsresult rv = selectElement->SetOptionsSelectedByIndex(aStartIndex,
 1:                                                          aEndIndex,
 1:                                                          aValue,
 1:                                                          aClearAll,
 1:                                                          PR_FALSE,
 1:                                                          PR_TRUE,
 1:                                                          &wasChanged);
 1:   NS_ASSERTION(NS_SUCCEEDED(rv), "SetSelected failed");
 1:   return wasChanged;
 1: }
 1: 
 1: PRBool
 1: nsListControlFrame::ToggleOptionSelectedFromFrame(PRInt32 aIndex)
 1: {
 1:   nsCOMPtr<nsIDOMHTMLOptionsCollection> options = GetOptions(mContent);
 1:   NS_ASSERTION(options, "No options");
 1:   if (!options) {
 1:     return PR_FALSE;
 1:   }
 1:   nsCOMPtr<nsIDOMHTMLOptionElement> option = GetOption(options, aIndex);
 1:   NS_ASSERTION(option, "No option");
 1:   if (!option) {
 1:     return PR_FALSE;
 1:   }
 1: 
 1:   PRBool value = PR_FALSE;
 1:   nsresult rv = option->GetSelected(&value);
 1: 
 1:   NS_ASSERTION(NS_SUCCEEDED(rv), "GetSelected failed");
 1:   nsCOMPtr<nsISelectElement> selectElement(do_QueryInterface(mContent));
 1:   PRBool wasChanged = PR_FALSE;
 1:   rv = selectElement->SetOptionsSelectedByIndex(aIndex,
 1:                                                 aIndex,
 1:                                                 !value,
 1:                                                 PR_FALSE,
 1:                                                 PR_FALSE,
 1:                                                 PR_TRUE,
 1:                                                 &wasChanged);
 1: 
 1:   NS_ASSERTION(NS_SUCCEEDED(rv), "SetSelected failed");
 1: 
 1:   return wasChanged;
 1: }
 1: 
 1: 
 1: // Dispatch event and such
 1: PRBool
 1: nsListControlFrame::UpdateSelection()
 1: {
 1:   if (mIsAllFramesHere) {
 1:     // if it's a combobox, display the new text
 1:     if (mComboboxFrame) {
 1:       mComboboxFrame->RedisplaySelectedText();
 1:     }
 1:     // if it's a listbox, fire on change
 1:     else if (mIsAllContentHere) {
 1:       nsWeakFrame weakFrame(this);
 1:       FireOnChange();
 1:       return weakFrame.IsAlive();
 1:     }
 1:   }
 1:   return PR_TRUE;
 1: }
 1: 
 1: void
 1: nsListControlFrame::ComboboxFinish(PRInt32 aIndex)
 1: {
 1:   gLastKeyTime = 0;
 1: 
 1:   if (mComboboxFrame) {
 1:     PerformSelection(aIndex, PR_FALSE, PR_FALSE);
 1: 
 1:     PRInt32 displayIndex = mComboboxFrame->GetIndexOfDisplayArea();
 1: 
 1:     if (displayIndex != aIndex) {
 1:       mComboboxFrame->RedisplaySelectedText();
 1:     }
 1: 
 1:     mComboboxFrame->RollupFromList();
 1:   }
 1: }
 1: 
 1: // Send out an onchange notification.
 1: void
 1: nsListControlFrame::FireOnChange()
 1: {
 1:   if (mComboboxFrame) {
 1:     // Return hit without changing anything
 1:     PRInt32 index = mComboboxFrame->UpdateRecentIndex(NS_SKIP_NOTIFY_INDEX);
 1:     if (index == NS_SKIP_NOTIFY_INDEX)
 1:       return;
 1: 
 1:     // See if the selection actually changed
 1:     if (index == GetSelectedIndex())
 1:       return;
 1:   }
 1: 
 1:   // Dispatch the NS_FORM_CHANGE event
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsEvent event(PR_TRUE, NS_FORM_CHANGE);
 1: 
95:   nsCOMPtr<nsIPresShell> presShell = GetPresContext()->GetPresShell();
 1:   if (presShell) {
 1:     presShell->HandleEventWithTarget(&event, this, nsnull, &status);
 1:   }
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // Determine if the specified item in the listbox is selected.
 1: NS_IMETHODIMP
 1: nsListControlFrame::GetOptionSelected(PRInt32 aIndex, PRBool* aValue)
 1: {
 1:   *aValue = IsContentSelectedByIndex(aIndex);
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsListControlFrame::OnSetSelectedIndex(PRInt32 aOldIndex, PRInt32 aNewIndex)
 1: {
 1:   if (mComboboxFrame) {
 1:     // UpdateRecentIndex with NS_SKIP_NOTIFY_INDEX, so that we won't fire an onchange
 1:     // event for this setting of selectedIndex.
 1:     mComboboxFrame->UpdateRecentIndex(NS_SKIP_NOTIFY_INDEX);
 1:   }
 1: 
 1:   ScrollToIndex(aNewIndex);
 1:   mStartSelectionIndex = aNewIndex;
 1:   mEndSelectionIndex = aNewIndex;
 1: 
 1: #ifdef ACCESSIBILITY
 1:   FireMenuItemActiveEvent();
 1: #endif
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // End nsISelectControlFrame
 1: //----------------------------------------------------------------------
 1: 
 1: //---------------------------------------------------------
 1: nsresult
 1: nsListControlFrame::SetFormProperty(nsIAtom* aName,
 1:                                 const nsAString& aValue)
 1: {
 1:   if (nsGkAtoms::selected == aName) {
 1:     return NS_ERROR_INVALID_ARG; // Selected is readonly according to spec.
 1:   } else if (nsGkAtoms::selectedindex == aName) {
 1:     // You shouldn't be calling me for this!!!
 1:     return NS_ERROR_INVALID_ARG;
 1:   }
 1: 
 1:   // We should be told about selectedIndex by the DOM element through
 1:   // OnOptionSelected
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: nsresult 
 1: nsListControlFrame::GetFormProperty(nsIAtom* aName, nsAString& aValue) const
 1: {
 1:   // Get the selected value of option from local cache (optimization vs. widget)
 1:   if (nsGkAtoms::selected == aName) {
 1:     nsAutoString val(aValue);
 1:     PRInt32 error = 0;
 1:     PRBool selected = PR_FALSE;
 1:     PRInt32 indx = val.ToInteger(&error, 10); // Get index from aValue
 1:     if (error == 0)
 1:        selected = IsContentSelectedByIndex(indx); 
 1:   
 1:     aValue.Assign(selected ? NS_LITERAL_STRING("1") : NS_LITERAL_STRING("0"));
 1:     
 1:   // For selectedIndex, get the value from the widget
 1:   } else if (nsGkAtoms::selectedindex == aName) {
 1:     // You shouldn't be calling me for this!!!
 1:     return NS_ERROR_INVALID_ARG;
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: void
 1: nsListControlFrame::SyncViewWithFrame()
 1: {
 1:     // Resync the view's position with the frame.
 1:     // The problem is the dropdown's view is attached directly under
 1:     // the root view. This means its view needs to have its coordinates calculated
 1:     // as if it were in it's normal position in the view hierarchy.
 1:   mComboboxFrame->AbsolutelyPositionDropDown();
 1: 
 1:   nsContainerFrame::PositionFrameView(this);
 1: }
 1: 
 1: //---------------------------------------------------------
 1: void
 1: nsListControlFrame::AboutToDropDown()
 1: {
 1:   if (mIsAllContentHere && mIsAllFramesHere && mHasBeenInitialized) {
 1:     ScrollToIndex(GetSelectedIndex());
 1: #ifdef ACCESSIBILITY
 1:     FireMenuItemActiveEvent(); // Inform assistive tech what got focus
 1: #endif
 1:   }
 1:   mItemSelectionStarted = PR_FALSE;
 1: }
 1: 
 1: //---------------------------------------------------------
 1: // We are about to be rolledup from the outside (ComboboxFrame)
 1: void
 1: nsListControlFrame::AboutToRollup()
 1: {
 1:   // We've been updating the combobox with the keyboard up until now, but not
 1:   // with the mouse.  The problem is, even with mouse selection, we are
 1:   // updating the <select>.  So if the mouse goes over an option just before
 1:   // he leaves the box and clicks, that's what the <select> will show.
 1:   //
 1:   // To deal with this we say "whatever is in the combobox is canonical."
 1:   // - IF the combobox is different from the current selected index, we
 1:   //   reset the index.
 1: 
 1:   if (IsInDropDownMode()) {
 1:     ComboboxFinish(mComboboxFrame->GetIndexOfDisplayArea());
 1:   }
 1: }
 1: 
 1: //---------------------------------------------------------
 1: NS_IMETHODIMP
 1: nsListControlFrame::DidReflow(nsPresContext*           aPresContext,
 1:                               const nsHTMLReflowState* aReflowState,
 1:                               nsDidReflowStatus        aStatus)
 1: {
 1:   nsresult rv;
 1:   
 1:   if (IsInDropDownMode()) 
 1:   {
 1:     //SyncViewWithFrame();
 1:     rv = nsHTMLScrollFrame::DidReflow(aPresContext, aReflowState, aStatus);
 1:     SyncViewWithFrame();
 1:   } else {
 1:     rv = nsHTMLScrollFrame::DidReflow(aPresContext, aReflowState, aStatus);
 1:   }
 1: 
 1:   if (mNeedToReset) {
 1:     mNeedToReset = PR_FALSE;
 1:     // Suppress scrolling to the selected element if we restored
 1:     // scroll history state AND the list contents have not changed
 1:     // since we loaded all the children AND nothing else forced us
 1:     // to scroll by calling ResetList(PR_TRUE). The latter two conditions
 1:     // are folded into mPostChildrenLoadedReset.
 1:     //
 1:     // The idea is that we want scroll history restoration to trump ResetList
 1:     // scrolling to the selected element, when the ResetList was probably only
 1:     // caused by content loading normally.
 1:     ResetList(!DidHistoryRestore() || mPostChildrenLoadedReset);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: nsIAtom*
 1: nsListControlFrame::GetType() const
 1: {
 1:   return nsGkAtoms::listControlFrame; 
 1: }
 1: 
 1: PRBool
 1: nsListControlFrame::IsContainingBlock() const
 1: {
 1:   // We are in fact the containing block for our options.  They should
 1:   // certainly not use our parent block (or worse yet our parent combobox) for
 1:   // their sizing.
 1:   return PR_TRUE;
 1: }
 1: 
 1: void
 1: nsListControlFrame::InvalidateInternal(const nsRect& aDamageRect,
 1:                                        nscoord aX, nscoord aY, nsIFrame* aForChild,
 1:                                        PRBool aImmediate)
 1: {
 1:   if (!IsInDropDownMode())
 1:     nsHTMLScrollFrame::InvalidateInternal(aDamageRect, aX, aY, aForChild, aImmediate);
 1:   InvalidateRoot(aDamageRect, aX, aY, aImmediate);
 1: }
 1: 
 1: #ifdef DEBUG
 1: NS_IMETHODIMP
 1: nsListControlFrame::GetFrameName(nsAString& aResult) const
 1: {
 1:   return MakeFrameName(NS_LITERAL_STRING("ListControl"), aResult);
 1: }
 1: #endif
 1: 
 1: //---------------------------------------------------------
 1: nscoord
 1: nsListControlFrame::GetHeightOfARow()
 1: {
 1:   return HeightOfARow();
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: nsresult
 1: nsListControlFrame::IsOptionDisabled(PRInt32 anIndex, PRBool &aIsDisabled)
 1: {
 1:   nsCOMPtr<nsISelectElement> sel(do_QueryInterface(mContent));
 1:   if (sel) {
 1:     sel->IsOptionDisabled(anIndex, &aIsDisabled);
 1:     return NS_OK;
 1:   }
 1:   return NS_ERROR_FAILURE;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // helper
 1: //----------------------------------------------------------------------
 1: PRBool
 1: nsListControlFrame::IsLeftButton(nsIDOMEvent* aMouseEvent)
 1: {
 1:   // only allow selection with the left button
 1:   nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aMouseEvent);
 1:   if (mouseEvent) {
 1:     PRUint16 whichButton;
 1:     if (NS_SUCCEEDED(mouseEvent->GetButton(&whichButton))) {
 1:       return whichButton != 0?PR_FALSE:PR_TRUE;
 1:     }
 1:   }
 1:   return PR_FALSE;
 1: }
 1: 
 1: nscoord
 1: nsListControlFrame::CalcFallbackRowHeight(PRInt32 aNumOptions)
 1: {
 1:   const nsStyleFont* styleFont = nsnull;
 1:     
 1:   if (aNumOptions > 0) {
 1:     // Try the first option
 1:     nsCOMPtr<nsIContent> option = GetOptionContent(0);
 1:     if (option) {
 1:       nsIFrame * optFrame = GetPresContext()->PresShell()->
 1:         GetPrimaryFrameFor(option);
 1:       if (optFrame) {
 1:         styleFont = optFrame->GetStyleFont();
 1:       }
 1:     }
 1:   }
 1: 
 1:   if (!styleFont) {
 1:     // Fall back to our own font
 1:     styleFont = GetStyleFont();
 1:   }
 1: 
 1:   NS_ASSERTION(styleFont, "Must have font style by now!");
 1: 
 1:   nscoord rowHeight = 0;
 1:   
 1:   nsCOMPtr<nsIFontMetrics> fontMet;
 1:   nsresult result = GetPresContext()->DeviceContext()->
 1:     GetMetricsFor(styleFont->mFont, *getter_AddRefs(fontMet));
 1:   if (NS_SUCCEEDED(result) && fontMet) {
 1:     if (fontMet) {
 1:       fontMet->GetHeight(rowHeight);
 1:     }
 1:   }
 1: 
 1:   return rowHeight;
 1: }
 1: 
 1: nscoord
 1: nsListControlFrame::CalcIntrinsicHeight(nscoord aHeightOfARow,
 1:                                         PRInt32 aNumberOfOptions)
 1: {
 1:   NS_PRECONDITION(!IsInDropDownMode(),
 1:                   "Shouldn't be in dropdown mode when we call this");
 1:   
 1:   mNumDisplayRows = 1;
 1:   GetSizeAttribute(&mNumDisplayRows);
 1: 
 1:   // Extra height to tack on to aHeightOfARow * mNumDisplayRows
 1:   nscoord extraHeight = 0;
 1:   
 1:   if (mNumDisplayRows < 1) {
 1:     // When SIZE=0 or unspecified we constrain the height to
 1:     // [2..kMaxDropDownRows] rows.  We add in the height of optgroup labels
 1:     // (within the constraint above), bug 300474.
 1:     nscoord labelHeight =
 1:       ::GetOptGroupLabelsHeight(GetPresContext(), mContent, aHeightOfARow);
 1: 
 1:     if (GetMultiple()) {
 1:       if (aNumberOfOptions < 2) {
 1:         // Add in 1 aHeightOfARow also when aNumberOfOptions == 0
 1:         mNumDisplayRows = 1;
 1:         extraHeight = PR_MAX(aHeightOfARow, labelHeight);
 1:       }
 1:       else if (aNumberOfOptions * aHeightOfARow + labelHeight >
 1:                kMaxDropDownRows * aHeightOfARow) {
 1:         mNumDisplayRows = kMaxDropDownRows;
 1:       } else {
 1:         mNumDisplayRows = aNumberOfOptions;
 1:         extraHeight = labelHeight;
 1:       }
 1:     }
 1:     else {
 1:       NS_NOTREACHED("Shouldn't hit this case -- we should a be a combobox if "
 1:                     "we have no size set and no multiple set!");
 1:     }
 1:   }
 1: 
 1:   return mNumDisplayRows * aHeightOfARow + extraHeight;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsIDOMMouseListener
 1: //----------------------------------------------------------------------
 1: nsresult
 1: nsListControlFrame::MouseUp(nsIDOMEvent* aMouseEvent)
 1: {
 1:   NS_ASSERTION(aMouseEvent != nsnull, "aMouseEvent is null.");
 1: 
 1:   UpdateInListState(aMouseEvent);
 1: 
 1:   mButtonDown = PR_FALSE;
 1: 
 1:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   // only allow selection with the left button
 1:   // if a right button click is on the combobox itself
 1:   // or on the select when in listbox mode, then let the click through
 1:   if (!IsLeftButton(aMouseEvent)) {
 1:     if (IsInDropDownMode()) {
 1:       if (!IgnoreMouseEventForSelection(aMouseEvent)) {
 1:         aMouseEvent->PreventDefault();
 1:         aMouseEvent->StopPropagation();
 1:       } else {
 1:         CaptureMouseEvents(PR_FALSE);
 1:         return NS_OK;
 1:       }
 1:       CaptureMouseEvents(PR_FALSE);
 1:       return NS_ERROR_FAILURE; // means consume event
 1:     } else {
 1:       CaptureMouseEvents(PR_FALSE);
 1:       return NS_OK;
 1:     }
 1:   }
 1: 
 1:   const nsStyleVisibility* vis = GetStyleVisibility();
 1:       
 1:   if (!vis->IsVisible()) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   if (IsInDropDownMode()) {
 1:     // XXX This is a bit of a hack, but.....
 1:     // But the idea here is to make sure you get an "onclick" event when you mouse
 1:     // down on the select and the drag over an option and let go
 1:     // And then NOT get an "onclick" event when when you click down on the select
 1:     // and then up outside of the select
 1:     // the EventStateManager tracks the content of the mouse down and the mouse up
 1:     // to make sure they are the same, and the onclick is sent in the PostHandleEvent
 1:     // depeneding on whether the clickCount is non-zero.
 1:     // So we cheat here by either setting or unsetting the clcikCount in the native event
 1:     // so the right thing happens for the onclick event
 1:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aMouseEvent));
 1:     nsMouseEvent * mouseEvent;
 1:     privateEvent->GetInternalNSEvent((nsEvent**)&mouseEvent);
 1: 
 1:     PRInt32 selectedIndex;
 1:     if (NS_SUCCEEDED(GetIndexFromDOMEvent(aMouseEvent, selectedIndex))) {
 1:       // If it's disabled, disallow the click and leave.
 1:       PRBool isDisabled = PR_FALSE;
 1:       IsOptionDisabled(selectedIndex, isDisabled);
 1:       if (isDisabled) {
 1:         aMouseEvent->PreventDefault();
 1:         aMouseEvent->StopPropagation();
 1:         CaptureMouseEvents(PR_FALSE);
 1:         return NS_ERROR_FAILURE;
 1:       }
 1: 
 1:       if (kNothingSelected != selectedIndex) {
 1:         ComboboxFinish(selectedIndex);
 1:         FireOnChange();
 1:       }
 1: 
 1:       mouseEvent->clickCount = 1;
 1:     } else {
 1:       // the click was out side of the select or its dropdown
 1:       mouseEvent->clickCount = IgnoreMouseEventForSelection(aMouseEvent) ? 1 : 0;
 1:     }
 1:   } else {
 1:     CaptureMouseEvents(PR_FALSE);
 1:     // Notify
 1:     if (mChangesSinceDragStart) {
 1:       // reset this so that future MouseUps without a prior MouseDown
 1:       // won't fire onchange
 1:       mChangesSinceDragStart = PR_FALSE;
 1:       FireOnChange();
 1:     }
 1: #if 0 // XXX - this is a partial fix for Bug 29990
 1:     if (mSelectedIndex != mStartExtendedIndex) {
 1:       mEndExtendedIndex = mSelectedIndex;
 1:     }
 1: #endif
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: /**
 1:  * If the dropdown is showing and the mouse has moved below our
 1:  * border-inner-edge, then set mItemSelectionStarted.
 1:  */
 1: void
 1: nsListControlFrame::UpdateInListState(nsIDOMEvent* aEvent)
 1: {
 1:   if (!mComboboxFrame || !mComboboxFrame->IsDroppedDown())
 1:     return;
 1: 
 1:   nsPoint pt = nsLayoutUtils::GetDOMEventCoordinatesRelativeTo(aEvent, this);
 1:   nsRect borderInnerEdge = GetScrollableView()->View()->GetBounds();
 1:   if (pt.y >= borderInnerEdge.y && pt.y < borderInnerEdge.YMost()) {
 1:     mItemSelectionStarted = PR_TRUE;
 1:   }
 1: }
 1: 
 1: /**
 1:  * When the user clicks on the comboboxframe to show the dropdown
 1:  * listbox, they then have to move the mouse into the list. We don't
 1:  * want to process those mouse events as selection events (i.e., to
 1:  * scroll list items into view). So we ignore the events until
 1:  * the mouse moves below our border-inner-edge, when
 1:  * mItemSelectionStarted is set.
 1:  *
 1:  * @param aPoint relative to this frame
 1:  */
 1: PRBool nsListControlFrame::IgnoreMouseEventForSelection(nsIDOMEvent* aEvent)
 1: {
 1:   if (!mComboboxFrame)
 1:     return PR_FALSE;
 1: 
 1:   // Our DOM listener does get called when the dropdown is not
 1:   // showing, because it listens to events on the SELECT element
 1:   if (!mComboboxFrame->IsDroppedDown())
 1:     return PR_TRUE;
 1: 
 1:   return !mItemSelectionStarted;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // Fire a custom DOM event for the change, so that accessibility can
 1: // fire a native focus event for accessibility 
 1: // (Some 3rd party products need to track our focus)
 1: #ifdef ACCESSIBILITY
 1: void
 1: nsListControlFrame::FireMenuItemActiveEvent()
 1: {
 1:   if (mFocused != this && !IsInDropDownMode()) {
 1:     return;
 1:   }
 1: 
 1:   // The mEndSelectionIndex is what is currently being selected
 1:   // use the selected index if this is kNothingSelected
 1:   PRInt32 focusedIndex;
 1:   if (mEndSelectionIndex == kNothingSelected) {
 1:     focusedIndex = GetSelectedIndex();
 1:   } else {
 1:     focusedIndex = mEndSelectionIndex;
 1:   }
 1:   if (focusedIndex == kNothingSelected) {
 1:     return;
 1:   }
 1: 
 1:   nsCOMPtr<nsIContent> optionContent = GetOptionContent(focusedIndex);
 1:   if (!optionContent) {
 1:     return;
 1:   }
 1: 
 1:   FireDOMEvent(NS_LITERAL_STRING("DOMMenuItemActive"), optionContent);
 1: }
 1: #endif
 1: 
 1: //----------------------------------------------------------------------
 1: // Sets the mSelectedIndex and mOldSelectedIndex from figuring out what 
 1: // item was selected using content
 1: // @param aPoint the event point, in listcontrolframe coordinates
 1: // @return NS_OK if it successfully found the selection
 1: //----------------------------------------------------------------------
 1: nsresult
 1: nsListControlFrame::GetIndexFromDOMEvent(nsIDOMEvent* aMouseEvent, 
 1:                                          PRInt32&     aCurIndex)
 1: {
 1:   if (IgnoreMouseEventForSelection(aMouseEvent))
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   nsIView* view = GetScrolledFrame()->GetView();
 1:   nsIViewManager* viewMan = view->GetViewManager();
 1:   nsIView* curGrabber;
 1:   viewMan->GetMouseEventGrabber(curGrabber);
 1:   if (curGrabber != view) {
 1:     // If we're not capturing, then ignore movement in the border
 1:     nsPoint pt = nsLayoutUtils::GetDOMEventCoordinatesRelativeTo(aMouseEvent, this);
 1:     nsRect borderInnerEdge = GetScrollableView()->View()->GetBounds();
 1:     if (!borderInnerEdge.Contains(pt)) {
 1:       return NS_ERROR_FAILURE;
 1:     }
 1:   }
 1: 
 1:   nsCOMPtr<nsIContent> content;
 1:   GetPresContext()->EventStateManager()->
 1:     GetEventTargetContent(nsnull, getter_AddRefs(content));
 1: 
 1:   nsCOMPtr<nsIContent> optionContent = GetOptionFromContent(content);
 1:   if (optionContent) {
 1:     aCurIndex = GetIndexFromContent(optionContent);
 1:     return NS_OK;
 1:   }
 1: 
 1:   nsIPresShell *presShell = GetPresContext()->PresShell();
 1:   PRInt32 numOptions = GetNumberOfOptions();
 1:   if (numOptions < 1)
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   nsPoint pt = nsLayoutUtils::GetDOMEventCoordinatesRelativeTo(aMouseEvent, this);
 1: 
 1:   // If the event coordinate is above the first option frame, then target the
 1:   // first option frame
 1:   nsCOMPtr<nsIContent> firstOption = GetOptionContent(0);
 1:   NS_ASSERTION(firstOption, "Can't find first option that's supposed to be there");
 1:   nsIFrame* optionFrame = presShell->GetPrimaryFrameFor(firstOption);
 1:   if (optionFrame) {
 1:     nsPoint ptInOptionFrame = pt - optionFrame->GetOffsetTo(this);
 1:     if (ptInOptionFrame.y < 0 && ptInOptionFrame.x >= 0 &&
 1:         ptInOptionFrame.x < optionFrame->GetSize().width) {
 1:       aCurIndex = 0;
 1:       return NS_OK;
 1:     }
 1:   }
 1: 
 1:   nsCOMPtr<nsIContent> lastOption = GetOptionContent(numOptions - 1);
 1:   // If the event coordinate is below the last option frame, then target the
 1:   // last option frame
 1:   NS_ASSERTION(lastOption, "Can't find last option that's supposed to be there");
 1:   optionFrame = presShell->GetPrimaryFrameFor(lastOption);
 1:   if (optionFrame) {
 1:     nsPoint ptInOptionFrame = pt - optionFrame->GetOffsetTo(this);
 1:     if (ptInOptionFrame.y >= optionFrame->GetSize().height && ptInOptionFrame.x >= 0 &&
 1:         ptInOptionFrame.x < optionFrame->GetSize().width) {
 1:       aCurIndex = numOptions - 1;
 1:       return NS_OK;
 1:     }
 1:   }
 1: 
 1:   return NS_ERROR_FAILURE;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: nsresult
 1: nsListControlFrame::MouseDown(nsIDOMEvent* aMouseEvent)
 1: {
 1:   NS_ASSERTION(aMouseEvent != nsnull, "aMouseEvent is null.");
 1: 
 1:   UpdateInListState(aMouseEvent);
 1: 
 1:   mButtonDown = PR_TRUE;
 1: 
 1:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   // only allow selection with the left button
 1:   // if a right button click is on the combobox itself
 1:   // or on the select when in listbox mode, then let the click through
 1:   if (!IsLeftButton(aMouseEvent)) {
 1:     if (IsInDropDownMode()) {
 1:       if (!IgnoreMouseEventForSelection(aMouseEvent)) {
 1:         aMouseEvent->PreventDefault();
 1:         aMouseEvent->StopPropagation();
 1:       } else {
 1:         return NS_OK;
 1:       }
 1:       return NS_ERROR_FAILURE; // means consume event
 1:     } else {
 1:       return NS_OK;
 1:     }
 1:   }
 1: 
 1:   PRInt32 selectedIndex;
 1:   if (NS_SUCCEEDED(GetIndexFromDOMEvent(aMouseEvent, selectedIndex))) {
 1:     // Handle Like List
 1:     CaptureMouseEvents(PR_TRUE);
 1:     mChangesSinceDragStart = HandleListSelection(aMouseEvent, selectedIndex);
 1: #ifdef ACCESSIBILITY
 1:     if (mChangesSinceDragStart) {
 1:       FireMenuItemActiveEvent();
 1:     }
 1: #endif
 1:   } else {
 1:     // NOTE: the combo box is responsible for dropping it down
 1:     if (mComboboxFrame) {
 1:       if (!IgnoreMouseEventForSelection(aMouseEvent)) {
 1:         return NS_OK;
 1:       }
 1: 
 1:       if (!nsComboboxControlFrame::ToolkitHasNativePopup())
 1:       {
 1:         PRBool isDroppedDown = mComboboxFrame->IsDroppedDown();
 1:         mComboboxFrame->ShowDropDown(!isDroppedDown);
 1:         if (isDroppedDown) {
 1:           CaptureMouseEvents(PR_FALSE);
 1:         }
 1:       }
 1:     }
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: // nsIDOMMouseMotionListener
 1: //----------------------------------------------------------------------
 1: nsresult
 1: nsListControlFrame::MouseMove(nsIDOMEvent* aMouseEvent)
 1: {
 1:   NS_ASSERTION(aMouseEvent, "aMouseEvent is null.");
 1: 
 1:   UpdateInListState(aMouseEvent);
 1: 
 1:   if (IsInDropDownMode()) { 
 1:     if (mComboboxFrame->IsDroppedDown()) {
 1:       PRInt32 selectedIndex;
 1:       if (NS_SUCCEEDED(GetIndexFromDOMEvent(aMouseEvent, selectedIndex))) {
 1:         PerformSelection(selectedIndex, PR_FALSE, PR_FALSE);
 1:       }
 1: 
 1:       // Make sure the SelectArea frame gets painted
 1:       // XXX this shouldn't be needed, but other places in this code do it
 1:       // and if we don't do this, invalidation doesn't happen when we move out
 1:       // of the top-level window. We should track this down and fix it --- roc
 1:       Invalidate(nsRect(0,0,mRect.width,mRect.height), PR_TRUE);
 1:     }
 1:   } else {// XXX - temporary until we get drag events
 1:     if (mButtonDown) {
 1:       return DragMove(aMouseEvent);
 1:     }
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsListControlFrame::DragMove(nsIDOMEvent* aMouseEvent)
 1: {
 1:   NS_ASSERTION(aMouseEvent, "aMouseEvent is null.");
 1: 
 1:   UpdateInListState(aMouseEvent);
 1: 
 1:   if (!IsInDropDownMode()) { 
 1:     PRInt32 selectedIndex;
 1:     if (NS_SUCCEEDED(GetIndexFromDOMEvent(aMouseEvent, selectedIndex))) {
 1:       // Don't waste cycles if we already dragged over this item
 1:       if (selectedIndex == mEndSelectionIndex) {
 1:         return NS_OK;
 1:       }
 1:       nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aMouseEvent);
 1:       NS_ASSERTION(mouseEvent, "aMouseEvent is not an nsIDOMMouseEvent!");
 1:       PRBool isControl;
 1: #ifdef XP_MACOSX
 1:       mouseEvent->GetMetaKey(&isControl);
 1: #else
 1:       mouseEvent->GetCtrlKey(&isControl);
 1: #endif
 1:       // Turn SHIFT on when you are dragging, unless control is on.
 1:       PRBool wasChanged = PerformSelection(selectedIndex,
 1:                                            !isControl, isControl);
 1:       mChangesSinceDragStart = mChangesSinceDragStart || wasChanged;
 1:     }
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsListControlFrame::ScrollToIndex(PRInt32 aIndex)
 1: {
 1:   if (aIndex < 0) {
 1:     // XXX shouldn't we just do nothing if we're asked to scroll to
 1:     // kNothingSelected?
 1:     return ScrollToFrame(nsnull);
 1:   } else {
 1:     nsCOMPtr<nsIContent> content = GetOptionContent(aIndex);
 1:     if (content) {
 1:       return ScrollToFrame(content);
 1:     }
 1:   }
 1: 
 1:   return NS_ERROR_FAILURE;
 1: }
 1: 
 1: //----------------------------------------------------------------------
 1: nsresult
 1: nsListControlFrame::ScrollToFrame(nsIContent* aOptElement)
 1: {
 1:   nsIScrollableView* scrollableView = GetScrollableView();
 1: 
 1:   if (scrollableView) {
 1:     // if null is passed in we scroll to 0,0
 1:     if (nsnull == aOptElement) {
 1:       scrollableView->ScrollTo(0, 0, PR_TRUE);
 1:       return NS_OK;
 1:     }
 1:   
 1:     // otherwise we find the content's frame and scroll to it
 1:     nsIPresShell *presShell = GetPresContext()->PresShell();
 1:     nsIFrame * childframe;
 1:     if (aOptElement) {
 1:       childframe = presShell->GetPrimaryFrameFor(aOptElement);
 1:     } else {
 1:       return NS_ERROR_FAILURE;
 1:     }
 1: 
 1:     if (childframe) {
 1:       if (scrollableView) {
 1:         nscoord x;
 1:         nscoord y;
 1:         scrollableView->GetScrollPosition(x,y);
 1:         // get the clipped rect
 1:         nsRect rect = scrollableView->View()->GetBounds();
 1:         // now move it by the offset of the scroll position
 1:         rect.x = x;
 1:         rect.y = y;
 1: 
 1:         // get the child
 1:         nsRect fRect = childframe->GetRect();
 1:         nsPoint pnt;
 1:         nsIView * view;
 1:         childframe->GetOffsetFromView(pnt, &view);
 1: 
 1:         // This change for 33421 (remove this comment later)
 1: 
 1:         // options can be a child of an optgroup
 1:         // this checks to see the parent is an optgroup
 1:         // and then adds in the parent's y coord
 1:         // XXX this assume only one level of nesting of optgroups
 1:         //   which is all the spec specifies at the moment.
 1:         nsCOMPtr<nsIContent> parentContent = aOptElement->GetParent();
 1:         nsCOMPtr<nsIDOMHTMLOptGroupElement> optGroup(do_QueryInterface(parentContent));
 1:         nsRect optRect(0,0,0,0);
 1:         if (optGroup) {
 1:           nsIFrame * optFrame = presShell->GetPrimaryFrameFor(parentContent);
 1:           if (optFrame) {
 1:             optRect = optFrame->GetRect();
 1:           }
 1:         }
 1:         fRect.y += optRect.y;
 1: 
 1:         // See if the selected frame (fRect) is inside the scrolled
 1:         // area (rect). Check only the vertical dimension. Don't
 1:         // scroll just because there's horizontal overflow.
 1:         if (!(rect.y <= fRect.y && fRect.YMost() <= rect.YMost())) {
 1:           // figure out which direction we are going
 1:           if (fRect.YMost() > rect.YMost()) {
 1:             y = fRect.y-(rect.height-fRect.height);
 1:           } else {
 1:             y = fRect.y;
 1:           }
 1:           scrollableView->ScrollTo(pnt.x, y, PR_TRUE);
 1:         }
 1: 
 1:       }
 1:     }
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: //---------------------------------------------------------------------
 1: // Ok, the entire idea of this routine is to move to the next item that 
 1: // is suppose to be selected. If the item is disabled then we search in 
 1: // the same direction looking for the next item to select. If we run off 
 1: // the end of the list then we start at the end of the list and search 
 1: // backwards until we get back to the original item or an enabled option
 1: // 
 1: // aStartIndex - the index to start searching from
 1: // aNewIndex - will get set to the new index if it finds one
 1: // aNumOptions - the total number of options in the list
 1: // aDoAdjustInc - the initial increment 1-n
 1: // aDoAdjustIncNext - the increment used to search for the next enabled option
 1: //
 1: // the aDoAdjustInc could be a "1" for a single item or
 1: // any number greater representing a page of items
 1: //
 1: void
 1: nsListControlFrame::AdjustIndexForDisabledOpt(PRInt32 aStartIndex,
 1:                                               PRInt32 &aNewIndex,
 1:                                               PRInt32 aNumOptions,
 1:                                               PRInt32 aDoAdjustInc,
 1:                                               PRInt32 aDoAdjustIncNext)
 1: {
 1:   // Cannot select anything if there is nothing to select
 1:   if (aNumOptions == 0) {
 1:     aNewIndex = kNothingSelected;
 1:     return;
 1:   }
 1: 
 1:   // means we reached the end of the list and now we are searching backwards
 1:   PRBool doingReverse = PR_FALSE;
 1:   // lowest index in the search range
 1:   PRInt32 bottom      = 0;
 1:   // highest index in the search range
 1:   PRInt32 top         = aNumOptions;
 1: 
 1:   // Start off keyboard options at selectedIndex if nothing else is defaulted to
 1:   //
 1:   // XXX Perhaps this should happen for mouse too, to start off shift click
 1:   // automatically in multiple ... to do this, we'd need to override
 1:   // OnOptionSelected and set mStartSelectedIndex if nothing is selected.  Not
 1:   // sure of the effects, though, so I'm not doing it just yet.
 1:   PRInt32 startIndex = aStartIndex;
 1:   if (startIndex < bottom) {
 1:     startIndex = GetSelectedIndex();
 1:   }
 1:   PRInt32 newIndex    = startIndex + aDoAdjustInc;
 1: 
 1:   // make sure we start off in the range
 1:   if (newIndex < bottom) {
 1:     newIndex = 0;
 1:   } else if (newIndex >= top) {
 1:     newIndex = aNumOptions-1;
 1:   }
 1: 
 1:   while (1) {
 1:     // if the newIndex isn't disabled, we are golden, bail out
 1:     PRBool isDisabled = PR_TRUE;
 1:     if (NS_SUCCEEDED(IsOptionDisabled(newIndex, isDisabled)) && !isDisabled) {
 1:       break;
 1:     }
 1: 
 1:     // it WAS disabled, so sart looking ahead for the next enabled option
 1:     newIndex += aDoAdjustIncNext;
 1: 
 1:     // well, if we reach end reverse the search
 1:     if (newIndex < bottom) {
 1:       if (doingReverse) {
 1:         return; // if we are in reverse mode and reach the end bail out
 1:       } else {
 1:         // reset the newIndex to the end of the list we hit
 1:         // reverse the incrementer
 1:         // set the other end of the list to our original starting index
 1:         newIndex         = bottom;
 1:         aDoAdjustIncNext = 1;
 1:         doingReverse     = PR_TRUE;
 1:         top              = startIndex;
 1:       }
 1:     } else  if (newIndex >= top) {
 1:       if (doingReverse) {
 1:         return;        // if we are in reverse mode and reach the end bail out
 1:       } else {
 1:         // reset the newIndex to the end of the list we hit
 1:         // reverse the incrementer
 1:         // set the other end of the list to our original starting index
 1:         newIndex = top - 1;
 1:         aDoAdjustIncNext = -1;
 1:         doingReverse     = PR_TRUE;
 1:         bottom           = startIndex;
 1:       }
 1:     }
 1:   }
 1: 
 1:   // Looks like we found one
 1:   aNewIndex     = newIndex;
 1: }
 1: 
 1: nsAString& 
 1: nsListControlFrame::GetIncrementalString()
 1: { 
 1:   static nsString incrementalString;
 1:   return incrementalString; 
 1: }
 1: 
 1: void
 1: nsListControlFrame::DropDownToggleKey(nsIDOMEvent* aKeyEvent)
 1: {
 1:   // Cocoa widgets do native popups, so don't try to show
 1:   // dropdowns there.
 1:   if (IsInDropDownMode() && !nsComboboxControlFrame::ToolkitHasNativePopup()) {
 1:     mComboboxFrame->ShowDropDown(!mComboboxFrame->IsDroppedDown());
 1:     mComboboxFrame->RedisplaySelectedText();
 1:     aKeyEvent->PreventDefault();
 1:   }
 1: }
 1: 
 1: nsresult
 1: nsListControlFrame::KeyPress(nsIDOMEvent* aKeyEvent)
 1: {
 1:   NS_ASSERTION(aKeyEvent, "keyEvent is null.");
 1: 
 1:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled))
 1:     return NS_OK;
 1: 
 1:   // Start by making sure we can query for a key event
 1:   nsCOMPtr<nsIDOMKeyEvent> keyEvent = do_QueryInterface(aKeyEvent);
 1:   NS_ENSURE_TRUE(keyEvent, NS_ERROR_FAILURE);
 1: 
 1:   PRUint32 keycode = 0;
 1:   PRUint32 charcode = 0;
 1:   keyEvent->GetKeyCode(&keycode);
 1:   keyEvent->GetCharCode(&charcode);
 1: 
 1:   PRBool isAlt = PR_FALSE;
 1: 
 1:   keyEvent->GetAltKey(&isAlt);
 1:   if (isAlt) {
 1:     if (keycode == nsIDOMKeyEvent::DOM_VK_UP || keycode == nsIDOMKeyEvent::DOM_VK_DOWN) {
 1:       DropDownToggleKey(aKeyEvent);
 1:     }
 1:     return NS_OK;
 1:   }
 1: 
 1:   // Get control / shift modifiers
 1:   PRBool isControl = PR_FALSE;
 1:   PRBool isShift   = PR_FALSE;
 1:   keyEvent->GetCtrlKey(&isControl);
 1:   if (!isControl) {
 1:     keyEvent->GetMetaKey(&isControl);
 1:   }
 1:   keyEvent->GetShiftKey(&isShift);
 1: 
 1:   // now make sure there are options or we are wasting our time
 1:   nsCOMPtr<nsIDOMHTMLOptionsCollection> options = GetOptions(mContent);
 1:   NS_ENSURE_TRUE(options, NS_ERROR_FAILURE);
 1: 
 1:   PRUint32 numOptions = 0;
 1:   options->GetLength(&numOptions);
 1: 
 1:   // Whether we did an incremental search or another action
 1:   PRBool didIncrementalSearch = PR_FALSE;
 1:   
 1:   // this is the new index to set
 1:   // DOM_VK_RETURN & DOM_VK_ESCAPE will not set this
 1:   PRInt32 newIndex = kNothingSelected;
 1: 
 1:   // set up the old and new selected index and process it
 1:   // DOM_VK_RETURN selects the item
 1:   // DOM_VK_ESCAPE cancels the selection
 1:   // default processing checks to see if the pressed the first 
 1:   //   letter of an item in the list and advances to it
 1:   
 1:   if (isControl && (keycode == nsIDOMKeyEvent::DOM_VK_UP ||
 1:                     keycode == nsIDOMKeyEvent::DOM_VK_LEFT ||
 1:                     keycode == nsIDOMKeyEvent::DOM_VK_DOWN ||
 1:                     keycode == nsIDOMKeyEvent::DOM_VK_RIGHT)) {
 1:     // Don't go into multiple select mode unless this list can handle it
 1:     isControl = mControlSelectMode = GetMultiple();
 1:   } else if (charcode != ' ') {
 1:     mControlSelectMode = PR_FALSE;
 1:   }
 1:   switch (keycode) {
 1: 
 1:     case nsIDOMKeyEvent::DOM_VK_UP:
 1:     case nsIDOMKeyEvent::DOM_VK_LEFT: {
 1:       AdjustIndexForDisabledOpt(mEndSelectionIndex, newIndex,
 1:                                 (PRInt32)numOptions,
 1:                                 -1, -1);
 1:       } break;
 1:     
 1:     case nsIDOMKeyEvent::DOM_VK_DOWN:
 1:     case nsIDOMKeyEvent::DOM_VK_RIGHT: {
 1:       AdjustIndexForDisabledOpt(mEndSelectionIndex, newIndex,
 1:                                 (PRInt32)numOptions,
 1:                                 1, 1);
 1:       } break;
 1: 
 1:     case nsIDOMKeyEvent::DOM_VK_RETURN: {
 1:       if (mComboboxFrame != nsnull) {
 1:         if (mComboboxFrame->IsDroppedDown()) {
 1:           ComboboxFinish(mEndSelectionIndex);
 1:         }
 1:         FireOnChange();
 1:         return NS_OK;
 1:       } else {
 1:         newIndex = mEndSelectionIndex;
 1:       }
 1:       } break;
 1: 
 1:     case nsIDOMKeyEvent::DOM_VK_ESCAPE: {
 1:       AboutToRollup();
 1:       } break;
 1: 
 1:     case nsIDOMKeyEvent::DOM_VK_PAGE_UP: {
 1:       AdjustIndexForDisabledOpt(mEndSelectionIndex, newIndex,
 1:                                 (PRInt32)numOptions,
 1:                                 -(mNumDisplayRows-1), -1);
 1:       } break;
 1: 
 1:     case nsIDOMKeyEvent::DOM_VK_PAGE_DOWN: {
 1:       AdjustIndexForDisabledOpt(mEndSelectionIndex, newIndex,
 1:                                 (PRInt32)numOptions,
 1:                                 (mNumDisplayRows-1), 1);
 1:       } break;
 1: 
 1:     case nsIDOMKeyEvent::DOM_VK_HOME: {
 1:       AdjustIndexForDisabledOpt(0, newIndex,
 1:                                 (PRInt32)numOptions,
 1:                                 0, 1);
 1:       } break;
 1: 
 1:     case nsIDOMKeyEvent::DOM_VK_END: {
 1:       AdjustIndexForDisabledOpt(numOptions-1, newIndex,
 1:                                 (PRInt32)numOptions,
 1:                                 0, -1);
 1:       } break;
 1: 
 1: #if defined(XP_WIN) || defined(XP_OS2)
 1:     case nsIDOMKeyEvent::DOM_VK_F4: {
 1:       DropDownToggleKey(aKeyEvent);
 1:       return NS_OK;
 1:     } break;
 1: #endif
 1: 
 1:     case nsIDOMKeyEvent::DOM_VK_TAB: {
 1:       return NS_OK;
 1:     }
 1: 
 1:     default: { // Select option with this as the first character
 1:                // XXX Not I18N compliant
 1:       
 1:       if (isControl && charcode != ' ') {
 1:         return NS_OK;
 1:       }
 1: 
 1:       didIncrementalSearch = PR_TRUE;
 1:       if (charcode == 0) {
 1:         // Backspace key will delete the last char in the string
 1:         if (keycode == NS_VK_BACK && !GetIncrementalString().IsEmpty()) {
 1:           GetIncrementalString().Truncate(GetIncrementalString().Length() - 1);
 1:           aKeyEvent->PreventDefault();
 1:         }
 1:         return NS_OK;
 1:       }
 1:       
 1:       DOMTimeStamp keyTime;
 1:       aKeyEvent->GetTimeStamp(&keyTime);
 1: 
 1:       // Incremental Search: if time elapsed is below
 1:       // INCREMENTAL_SEARCH_KEYPRESS_TIME, append this keystroke to the search
 1:       // string we will use to find options and start searching at the current
 1:       // keystroke.  Otherwise, Truncate the string if it's been a long time
 1:       // since our last keypress.
 1:       if (keyTime - gLastKeyTime > INCREMENTAL_SEARCH_KEYPRESS_TIME) {
 1:         // If this is ' ' and we are at the beginning of the string, treat it as
 1:         // "select this option" (bug 191543)
 1:         if (charcode == ' ') {
 1:           newIndex = mEndSelectionIndex;
 1:           break;
 1:         }
 1:         GetIncrementalString().Truncate();
 1:       }
 1:       gLastKeyTime = keyTime;
 1: 
 1:       // Append this keystroke to the search string. 
 1:       PRUnichar uniChar = ToLowerCase(NS_STATIC_CAST(PRUnichar, charcode));
 1:       GetIncrementalString().Append(uniChar);
 1: 
 1:       // See bug 188199, if all letters in incremental string are same, just try to match the first one
 1:       nsAutoString incrementalString(GetIncrementalString());
 1:       PRUint32 charIndex = 1, stringLength = incrementalString.Length();
 1:       while (charIndex < stringLength && incrementalString[charIndex] == incrementalString[charIndex - 1]) {
 1:         charIndex++;
 1:       }
 1:       if (charIndex == stringLength) {
 1:         incrementalString.Truncate(1);
 1:         stringLength = 1;
 1:       }
 1: 
 1:       // Determine where we're going to start reading the string
 1:       // If we have multiple characters to look for, we start looking *at* the
 1:       // current option.  If we have only one character to look for, we start
 1:       // looking *after* the current option.	
 1:       // Exception: if there is no option selected to start at, we always start
 1:       // *at* 0.
 1:       PRInt32 startIndex = GetSelectedIndex();
 1:       if (startIndex == kNothingSelected) {
 1:         startIndex = 0;
 1:       } else if (stringLength == 1) {
 1:         startIndex++;
 1:       }
 1: 
 1:       PRUint32 i;
 1:       for (i = 0; i < numOptions; i++) {
 1:         PRUint32 index = (i + startIndex) % numOptions;
 1:         nsCOMPtr<nsIDOMHTMLOptionElement> optionElement =
 1:           GetOption(options, index);
 1:         if (optionElement) {
 1:           nsAutoString text;
 1:           if (NS_OK == optionElement->GetText(text)) {
 1:             if (StringBeginsWith(text, incrementalString,
 1:                                  nsCaseInsensitiveStringComparator())) {
 1:               PRBool wasChanged = PerformSelection(index, isShift, isControl);
 1:               if (wasChanged) {
 1:                 // dispatch event, update combobox, etc.
 1:                 if (!UpdateSelection()) {
 1:                   return NS_OK;
 1:                 }
 1:               }
 1:               break;
 1:             }
 1:           }
 1:         }
 1:       } // for
 1: 
 1:     } break;//case
 1:   } // switch
 1: 
 1:   // We ate the key if we got this far.
 1:   aKeyEvent->PreventDefault();
 1: 
 1:   // If we didn't do an incremental search, clear the string
 1:   if (!didIncrementalSearch) {
 1:     GetIncrementalString().Truncate();
 1:   }
 1: 
 1:   // Actually process the new index and let the selection code
 1:   // do the scrolling for us
 1:   if (newIndex != kNothingSelected) {
 1:     // If you hold control, no key will actually do anything except space.
 1:     PRBool wasChanged = PR_FALSE;
 1:     if (isControl && charcode != ' ') {
 1:       mStartSelectionIndex = newIndex;
 1:       mEndSelectionIndex = newIndex;
 1:       ScrollToIndex(newIndex);
 1:     } else if (mControlSelectMode && charcode == ' ') {
 1:       wasChanged = SingleSelection(newIndex, PR_TRUE);
 1:     } else {
 1:       wasChanged = PerformSelection(newIndex, isShift, isControl);
 1:     }
 1:     if (wasChanged) {
 1:        // dispatch event, update combobox, etc.
 1:       if (!UpdateSelection()) {
 1:         return NS_OK;
 1:       }
 1:     }
 1: #ifdef ACCESSIBILITY
 1:     if (charcode != ' ') {
 1:       FireMenuItemActiveEvent();
 1:     }
 1: #endif
 1: 
 1:     // XXX - Are we cover up a problem here???
 1:     // Why aren't they getting flushed each time?
 1:     // because this isn't needed for Gfx
 1:     if (IsInDropDownMode()) {
 1:       // Don't flush anything but reflows lest it destroy us
 1:       GetPresContext()->PresShell()->
 1:         GetDocument()->FlushPendingNotifications(Flush_OnlyReflow);
 1:     }
 1: 
 1:     // Make sure the SelectArea frame gets painted
 1:     Invalidate(nsRect(0,0,mRect.width,mRect.height), PR_TRUE);
 1: 
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: 
 1: /******************************************************************************
 1:  * nsListEventListener
 1:  *****************************************************************************/
 1: 
 1: NS_IMPL_ADDREF(nsListEventListener)
 1: NS_IMPL_RELEASE(nsListEventListener)
 1: NS_INTERFACE_MAP_BEGIN(nsListEventListener)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseListener)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseMotionListener)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
 1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMMouseListener)
 1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMMouseListener)
 1: NS_INTERFACE_MAP_END
 1: 
 1: #define FORWARD_EVENT(_event) \
 1: NS_IMETHODIMP \
 1: nsListEventListener::_event(nsIDOMEvent* aEvent) \
 1: { \
 1:   if (mFrame) \
 1:     return mFrame->nsListControlFrame::_event(aEvent); \
 1:   return NS_OK; \
 1: }
 1: 
 1: #define IGNORE_EVENT(_event) \
 1: NS_IMETHODIMP \
 1: nsListEventListener::_event(nsIDOMEvent* aEvent) \
 1: { return NS_OK; }
 1: 
 1: IGNORE_EVENT(HandleEvent)
 1: 
 1: /*================== nsIDOMKeyListener =========================*/
 1: 
 1: IGNORE_EVENT(KeyDown)
 1: IGNORE_EVENT(KeyUp)
 1: FORWARD_EVENT(KeyPress)
 1: 
 1: /*=============== nsIDOMMouseListener ======================*/
 1: 
 1: FORWARD_EVENT(MouseDown)
 1: FORWARD_EVENT(MouseUp)
 1: IGNORE_EVENT(MouseClick)
 1: IGNORE_EVENT(MouseDblClick)
 1: IGNORE_EVENT(MouseOver)
 1: IGNORE_EVENT(MouseOut)
 1: 
 1: /*=============== nsIDOMMouseMotionListener ======================*/
 1: 
 1: FORWARD_EVENT(MouseMove)
 1: // XXXbryner does anyone call this, ever?
 1: IGNORE_EVENT(DragMove)
 1: 
 1: #undef FORWARD_EVENT
 1: #undef IGNORE_EVENT
 1: 
