     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 78068: #include "base/histogram.h"
115644: #include "ImageLogging.h"
     1: #include "nsComponentManagerUtils.h"
     1: #include "imgIContainerObserver.h"
108290: #include "nsError.h"
 51248: #include "Decoder.h"
  7009: #include "imgIDecoderObserver.h"
 50551: #include "RasterImage.h"
     1: #include "nsIInterfaceRequestor.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsAutoPtr.h"
  7009: #include "nsStringStream.h"
  7009: #include "prenv.h"
108747: #include "ImageContainer.h"
108747: #include "Layers.h"
     1: 
 51234: #include "nsPNGDecoder.h"
 51234: #include "nsGIFDecoder2.h"
 51234: #include "nsJPEGDecoder.h"
 51234: #include "nsBMPDecoder.h"
 51234: #include "nsICODecoder.h"
 51234: #include "nsIconDecoder.h"
 51234: 
     1: #include "gfxContext.h"
     1: 
 86980: #include "mozilla/Preferences.h"
 91311: #include "mozilla/StandardInteger.h"
 86980: #include "mozilla/Telemetry.h"
 86980: #include "mozilla/TimeStamp.h"
 89821: #include "mozilla/ClearOnShutdown.h"
115644: #include "mozilla/gfx/Scale.h"
115644: 
115990: #include "sampler.h"
115990: 
 74043: using namespace mozilla;
 87852: using namespace mozilla::image;
 82042: using namespace mozilla::layers;
 50547: 
 60418: // a mask for flags that will affect the decoding
 60418: #define DECODE_FLAGS_MASK (imgIContainer::FLAG_DECODE_NO_PREMULTIPLY_ALPHA | imgIContainer::FLAG_DECODE_NO_COLORSPACE_CONVERSION)
 60418: #define DECODE_FLAGS_DEFAULT 0
 60418: 
  7009: /* Accounting for compressed data */
  7009: #if defined(PR_LOGGING)
  7009: static PRLogModuleInfo *gCompressedImageAccountingLog = PR_NewLogModule ("CompressedImageAccounting");
  7009: #else
  7009: #define gCompressedImageAccountingLog
  7009: #endif
  7009: 
 86525: // Tweakable progressive decoding parameters.  These are initialized to 0 here
 86525: // because otherwise, we have to initialize them in a static initializer, which
 86525: // makes us slower to start up.
108991: static uint32_t gDecodeBytesAtATime = 0;
108991: static uint32_t gMaxMSBeforeYield = 0;
115645: static bool gHQDownscaling = false;
115645: // This is interpreted as a floating-point value / 1000
115645: static uint32_t gHQDownscalingMinFactor = 1000;
 86525: 
 86525: static void
 86525: InitPrefCaches()
 51590: {
 86525:   Preferences::AddUintVarCache(&gDecodeBytesAtATime,
 86525:                                "image.mem.decode_bytes_at_a_time", 200000);
 86525:   Preferences::AddUintVarCache(&gMaxMSBeforeYield,
 86525:                                "image.mem.max_ms_before_yield", 400);
115645:   Preferences::AddBoolVarCache(&gHQDownscaling,
115645:                                "image.high_quality_downscaling.enabled", false);
115645:   Preferences::AddUintVarCache(&gHQDownscalingMinFactor,
115645:                                "image.high_quality_downscaling.min_factor", 1000);
 80141: }
 51590: 
 32424: /* We define our own error checking macros here for 2 reasons:
 32424:  *
 32424:  * 1) Most of the failures we encounter here will (hopefully) be
 32424:  * the result of decoding failures (ie, bad data) and not code
 32424:  * failures. As such, we don't want to clutter up debug consoles
 32424:  * with spurious messages about NS_ENSURE_SUCCESS failures.
 32424:  *
 32424:  * 2) We want to set the internal error flag, shutdown properly,
 32424:  * and end up in an error state.
 32424:  *
 32424:  * So this macro should be called when the desired failure behavior
 32424:  * is to put the container into an error state and return failure.
 32424:  * It goes without saying that macro won't compile outside of a
 50549:  * non-static RasterImage method.
 32424:  */
 32424: #define LOG_CONTAINER_ERROR                      \
 32424:   PR_BEGIN_MACRO                                 \
 32424:   PR_LOG (gImgLog, PR_LOG_ERROR,                 \
 50549:           ("RasterImage: [this=%p] Error "      \
 32424:            "detected at line %u for image of "   \
 32424:            "type %s\n", this, __LINE__,          \
 32424:            mSourceDataMimeType.get()));          \
 32424:   PR_END_MACRO
 32424: 
 32424: #define CONTAINER_ENSURE_SUCCESS(status)      \
 32424:   PR_BEGIN_MACRO                              \
 32424:   nsresult _status = status; /* eval once */  \
108533:   if (NS_FAILED(_status)) {                   \
 32424:     LOG_CONTAINER_ERROR;                      \
 32424:     DoError();                                \
 32424:     return _status;                           \
 32424:   }                                           \
 32424:  PR_END_MACRO
 32424: 
 32424: #define CONTAINER_ENSURE_TRUE(arg, rv)  \
 32424:   PR_BEGIN_MACRO                        \
 32424:   if (!(arg)) {                         \
 32424:     LOG_CONTAINER_ERROR;                \
 32424:     DoError();                          \
 32424:     return rv;                          \
 32424:   }                                     \
 32424:   PR_END_MACRO
 32424: 
 32424: 
 32424: 
 32424: static int num_containers;
 32424: static int num_discardable_containers;
108991: static int64_t total_source_bytes;
108991: static int64_t discardable_source_bytes;
 32424: 
 32424: /* Are we globally disabling image discarding? */
 74143: static bool
 32424: DiscardingEnabled()
 32424: {
 74143:   static bool inited;
 74143:   static bool enabled;
 32424: 
 32424:   if (!inited) {
 80486:     inited = true;
 32424: 
106838:     enabled = (PR_GetEnv("MOZ_DISABLE_IMAGE_DISCARD") == nullptr);
 32424:   }
 32424: 
 32424:   return enabled;
 32424: }
 32424: 
 50549: namespace mozilla {
 87852: namespace image {
 50549: 
106631: /* static */ StaticRefPtr<RasterImage::DecodeWorker> RasterImage::DecodeWorker::sSingleton;
115644: /* static */ nsRefPtr<RasterImage::ScaleWorker> RasterImage::ScaleWorker::sSingleton;
115644: /* static */ nsRefPtr<RasterImage::DrawWorker> RasterImage::DrawWorker::sSingleton;
115644: static nsCOMPtr<nsIThread> sScaleWorkerThread = nullptr;
115644: 
 52150: #ifndef DEBUG
116145: NS_IMPL_ISUPPORTS2(RasterImage, imgIContainer, nsIProperties)
116145: #else
 82104: NS_IMPL_ISUPPORTS3(RasterImage, imgIContainer, nsIProperties,
116145:                    imgIContainerDebug)
 52150: #endif
     1: 
     1: //******************************************************************************
 51296: RasterImage::RasterImage(imgStatusTracker* aStatusTracker) :
 51296:   Image(aStatusTracker), // invoke superclass's constructor
     1:   mSize(0,0),
 60418:   mFrameDecodeFlags(DECODE_FLAGS_DEFAULT),
106838:   mAnim(nullptr),
     1:   mLoopCount(-1),
106838:   mObserver(nullptr),
 42233:   mLockCount(0),
106838:   mDecoder(nullptr),
 89821:   mDecodeRequest(this),
 42233:   mBytesDecoded(0),
 78068:   mDecodeCount(0),
 52150: #ifdef DEBUG
 52150:   mFramesNotified(0),
 52150: #endif
 80486:   mHasSize(false),
 80486:   mDecodeOnDraw(false),
 80486:   mMultipart(false),
 80486:   mDiscardable(false),
 80486:   mHasSourceData(false),
 80486:   mDecoded(false),
 80486:   mHasBeenDecoded(false),
 80486:   mInDecoder(false),
114209:   mAnimationFinished(false),
115336:   mFinishing(false),
119204:   mInUpdateImageContainer(false)
     1: {
 46991:   // Set up the discard tracker node.
 93271:   mDiscardTrackerNode.img = this;
 78068:   Telemetry::GetHistogramById(Telemetry::IMAGE_DECODE_COUNT)->Add(0);
 46991: 
 32424:   // Statistics
 32424:   num_containers++;
     1: }
     1: 
     1: //******************************************************************************
 50549: RasterImage::~RasterImage()
     1: {
 32424:   // Discardable statistics
 32424:   if (mDiscardable) {
 32424:     num_discardable_containers--;
 32424:     discardable_source_bytes -= mSourceData.Length();
  7009: 
  7009:     PR_LOG (gCompressedImageAccountingLog, PR_LOG_DEBUG,
 50549:             ("CompressedImageAccounting: destroying RasterImage %p.  "
 32424:              "Total Containers: %d, Discardable containers: %d, "
 32424:              "Total source bytes: %lld, Source bytes for discardable containers %lld",
  7009:              this,
 32424:              num_containers,
 32424:              num_discardable_containers,
 32424:              total_source_bytes,
 32424:              discardable_source_bytes));
 97995:     DiscardTracker::Remove(&mDiscardTrackerNode);
  7009:   }
  7009: 
 32424:   // If we have a decoder open, shut it down
 32424:   if (mDecoder) {
 32424:     nsresult rv = ShutdownDecoder(eShutdownIntent_Interrupted);
 32424:     if (NS_FAILED(rv))
 32424:       NS_WARNING("Failed to shut down decoder in destructor!");
     1:   }
     1: 
119150:   delete mAnim;
119150: 
119150:   for (unsigned int i = 0; i < mFrames.Length(); ++i)
119150:     delete mFrames[i];
119150: 
 32424:   // Total statistics
 32424:   num_containers--;
 32424:   total_source_bytes -= mSourceData.Length();
 32424: }
 32424: 
115543: void
115543: RasterImage::Initialize()
115543: {
115543:   InitPrefCaches();
115543: 
115543:   // Create our singletons now, so we don't have to worry about what thread
115543:   // they're created on.
115543:   DecodeWorker::Singleton();
115644:   DrawWorker::Singleton();
115644:   ScaleWorker::Singleton();
115543: }
115543: 
 50555: nsresult
 50550: RasterImage::Init(imgIDecoderObserver *aObserver,
 32424:                   const char* aMimeType,
 53660:                   const char* aURIString,
108991:                   uint32_t aFlags)
     1: {
 32424:   // We don't support re-initialization
 32424:   if (mInitialized)
 32424:     return NS_ERROR_ILLEGAL_VALUE;
 32424: 
 32424:   // Not sure an error can happen before init, but be safe
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   NS_ENSURE_ARG_POINTER(aMimeType);
 32424: 
 32424:   // We must be non-discardable and non-decode-on-draw for
 32424:   // multipart channels
 32424:   NS_ABORT_IF_FALSE(!(aFlags & INIT_FLAG_MULTIPART) ||
 32424:                     (!(aFlags & INIT_FLAG_DISCARDABLE) &&
 32424:                      !(aFlags & INIT_FLAG_DECODE_ON_DRAW)),
 32424:                     "Can't be discardable or decode-on-draw for multipart");
 32424: 
 32424:   // Store initialization data
 32424:   mObserver = do_GetWeakReference(aObserver);
 32424:   mSourceDataMimeType.Assign(aMimeType);
 53660:   mURIString.Assign(aURIString);
 42808:   mDiscardable = !!(aFlags & INIT_FLAG_DISCARDABLE);
 42808:   mDecodeOnDraw = !!(aFlags & INIT_FLAG_DECODE_ON_DRAW);
 42808:   mMultipart = !!(aFlags & INIT_FLAG_MULTIPART);
 32424: 
 32424:   // Statistics
 32424:   if (mDiscardable) {
 32424:     num_discardable_containers++;
 32424:     discardable_source_bytes += mSourceData.Length();
 32424:   }
 32424: 
 32424:   // If we're being called from ExtractFrame (used by borderimage),
 32424:   // we don't actually do any decoding. Bail early.
 32424:   // XXX - This should be removed when we fix borderimage
 32424:   if (mSourceDataMimeType.Length() == 0) {
 80486:     mInitialized = true;
 32424:     return NS_OK;
 32424:   }
 32424: 
 32424:   // Instantiate the decoder
 51244:   //
 51244:   // If we're doing decode-on-draw, we want to do a quick first pass to get
 51244:   // the size but nothing else. We instantiate another decoder later to do
 51244:   // the full decoding.
 51244:   nsresult rv = InitDecoder(/* aDoSizeDecode = */ mDecodeOnDraw);
 32424:   CONTAINER_ENSURE_SUCCESS(rv);
 32424: 
 32424:   // Mark us as initialized
 80486:   mInitialized = true;
 32424: 
 32424:   return NS_OK;
 32424: }
 32424: 
 82104: bool
 82104: RasterImage::AdvanceFrame(TimeStamp aTime, nsIntRect* aDirtyRect)
 82104: {
 82104:   NS_ASSERTION(aTime <= TimeStamp::Now(),
 82104:                "Given time appears to be in the future");
 82104: 
106838:   imgFrame* nextFrame = nullptr;
108991:   uint32_t currentFrameIndex = mAnim->currentAnimationFrameIndex;
108991:   uint32_t nextFrameIndex = mAnim->currentAnimationFrameIndex + 1;
108991:   uint32_t timeout = 0;
 82104: 
 82104:   // Figure out if we have the next full frame. This is more complicated than
 82104:   // just checking for mFrames.Length() because decoders append their frames
 82104:   // before they're filled in.
 82104:   NS_ABORT_IF_FALSE(mDecoder || nextFrameIndex <= mFrames.Length(),
 82104:                     "How did we get 2 indices too far by incrementing?");
 82104: 
 82104:   // If we don't have a decoder, we know we've got everything we're going to
 82104:   // get. If we do, we only display fully-downloaded frames; everything else
 82104:   // gets delayed.
 98961:   bool haveFullNextFrame = (mMultipart && mBytesDecoded == 0) || !mDecoder ||
 82104:                            nextFrameIndex < mDecoder->GetCompleteFrameCount();
 82104: 
 82104:   // If we're done decoding the next frame, go ahead and display it now and
 82104:   // reinit with the next frame's delay time.
 82104:   if (haveFullNextFrame) {
 82104:     if (mFrames.Length() == nextFrameIndex) {
 82104:       // End of Animation, unless we are looping forever
 82104: 
 82104:       // If animation mode is "loop once", it's time to stop animating
 82104:       if (mAnimationMode == kLoopOnceAnimMode || mLoopCount == 0) {
 82233:         mAnimationFinished = true;
 82104:         EvaluateAnimation();
 82104:       }
 82104: 
 82104:       // We may have used compositingFrame to build a frame, and then copied
 82104:       // it back into mFrames[..].  If so, delete composite to save memory
 82104:       if (mAnim->compositingFrame && mAnim->lastCompositedFrameIndex == -1) {
106838:         mAnim->compositingFrame = nullptr;
 82104:       }
 82104: 
 82104:       nextFrameIndex = 0;
 82104: 
 82104:       if (mLoopCount > 0) {
 82104:         mLoopCount--;
 82104:       }
 82104: 
 82104:       if (!mAnimating) {
 82104:         // break out early if we are actually done animating
 82104:         return false;
 82104:       }
 82104:     }
 82104: 
 82104:     if (!(nextFrame = mFrames[nextFrameIndex])) {
 82104:       // something wrong with the next frame, skip it
 82104:       mAnim->currentAnimationFrameIndex = nextFrameIndex;
 82104:       return false;
 82104:     }
 82104: 
 82104:     timeout = nextFrame->GetTimeout();
 82104: 
 82104:   } else {
 82104:     // Uh oh, the frame we want to show is currently being decoded (partial)
 82104:     // Wait until the next refresh driver tick and try again
 82104:     return false;
 82104:   }
 82104: 
 82104:   if (!(timeout > 0)) {
 82233:     mAnimationFinished = true;
 82104:     EvaluateAnimation();
 82104:   }
 82104: 
 82104:   if (nextFrameIndex == 0) {
 82104:     *aDirtyRect = mAnim->firstFrameRefreshArea;
 82104:   } else {
 82104:     imgFrame *curFrame = mFrames[currentFrameIndex];
 82104: 
 82104:     if (!curFrame) {
 82104:       return false;
 82104:     }
 82104: 
 82104:     // Change frame
 82104:     if (NS_FAILED(DoComposite(aDirtyRect, curFrame,
 82104:                               nextFrame, nextFrameIndex))) {
 82104:       // something went wrong, move on to next
 82104:       NS_WARNING("RasterImage::AdvanceFrame(): Compositing of frame failed");
 82233:       nextFrame->SetCompositingFailed(true);
 82104:       mAnim->currentAnimationFrameIndex = nextFrameIndex;
 82104:       mAnim->currentAnimationFrameTime = aTime;
 82104:       return false;
 82104:     }
 82104: 
 82233:     nextFrame->SetCompositingFailed(false);
 82104:   }
 82104: 
 82104:   // Set currentAnimationFrameIndex at the last possible moment
 82104:   mAnim->currentAnimationFrameIndex = nextFrameIndex;
 82104:   mAnim->currentAnimationFrameTime = aTime;
 82104: 
 82104:   return true;
 82104: }
 82104: 
 81176: //******************************************************************************
 82104: // [notxpcom] void requestRefresh ([const] in TimeStamp aTime);
 82096: NS_IMETHODIMP_(void)
 82096: RasterImage::RequestRefresh(const mozilla::TimeStamp& aTime)
 82096: {
 82104:   if (!mAnimating || !ShouldAnimate()) {
 82104:     return;
 82104:   }
 82104: 
 82104:   EnsureAnimExists();
 82104: 
 82104:   // only advance the frame if the current time is greater than or
 82104:   // equal to the current frame's end time.
 82104:   TimeStamp currentFrameEndTime = GetCurrentImgFrameEndTime();
 82104:   bool frameAdvanced = false;
 82104: 
 82104:   // The dirtyRect variable will contain an accumulation of the sub-rectangles
 82104:   // that are dirty for each frame we advance in AdvanceFrame().
 82104:   nsIntRect dirtyRect;
 82104: 
 82104:   while (currentFrameEndTime <= aTime) {
 82104:     TimeStamp oldFrameEndTime = currentFrameEndTime;
 82104:     nsIntRect frameDirtyRect;
 82104:     bool didAdvance = AdvanceFrame(aTime, &frameDirtyRect);
 82104:     frameAdvanced = frameAdvanced || didAdvance;
 82104:     currentFrameEndTime = GetCurrentImgFrameEndTime();
 82104: 
 82104:     // Accumulate the dirty area.
 82104:     dirtyRect = dirtyRect.Union(frameDirtyRect);
 82104: 
 82104:     // if we didn't advance a frame, and our frame end time didn't change,
 82104:     // then we need to break out of this loop & wait for the frame(s)
 82104:     // to finish downloading
 82104:     if (!frameAdvanced && (currentFrameEndTime == oldFrameEndTime)) {
 82104:       break;
 82104:     }
 82104:   }
 82104: 
 82104:   if (frameAdvanced) {
 82104:     nsCOMPtr<imgIContainerObserver> observer(do_QueryReferent(mObserver));
 82104: 
 82104:     if (!observer) {
 82104:       NS_ERROR("Refreshing image after its imgRequest is gone");
 82104:       StopAnimation();
 82104:       return;
 82104:     }
 82104: 
 82104:     // Notify listeners that our frame has actually changed, but do this only
 82104:     // once for all frames that we've now passed (if AdvanceFrame() was called
 82104:     // more than once).
 82104:     #ifdef DEBUG
 82104:       mFramesNotified++;
 82104:     #endif
 82104: 
115336:     UpdateImageContainer();
118757:     observer->FrameChanged(&dirtyRect);
 82104:   }
 82096: }
 82096: 
 82096: //******************************************************************************
108991: /* [noscript] imgIContainer extractFrame(uint32_t aWhichFrame,
 32424:  *                                       [const] in nsIntRect aRegion,
108991:  *                                       in uint32_t aFlags); */
 50550: NS_IMETHODIMP
108991: RasterImage::ExtractFrame(uint32_t aWhichFrame,
 32424:                           const nsIntRect &aRegion,
108991:                           uint32_t aFlags,
 32424:                           imgIContainer **_retval)
 32424: {
 32424:   NS_ENSURE_ARG_POINTER(_retval);
 32424: 
 32424:   nsresult rv;
 32424: 
 32424:   if (aWhichFrame > FRAME_MAX_VALUE)
 32424:     return NS_ERROR_INVALID_ARG;
 32424: 
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 48223:   // Disallowed in the API
 48223:   if (mInDecoder && (aFlags & imgIContainer::FLAG_SYNC_DECODE))
 48223:     return NS_ERROR_FAILURE;
 48223: 
 32424:   // Make a new container. This should switch to another class with bug 505959.
 50549:   nsRefPtr<RasterImage> img(new RasterImage());
 32424: 
 32424:   // We don't actually have a mimetype in this case. The empty string tells the
 32424:   // init routine not to try to instantiate a decoder. This should be fixed in
 32424:   // bug 505959.
106838:   img->Init(nullptr, "", "", INIT_FLAG_NONE);
 32424:   img->SetSize(aRegion.width, aRegion.height);
 80486:   img->mDecoded = true; // Also, we need to mark the image as decoded
 80486:   img->mHasBeenDecoded = true;
 60418:   img->mFrameDecodeFlags = aFlags & DECODE_FLAGS_MASK;
 60418: 
108318:   if (!ApplyDecodeFlags(aFlags))
 60418:     return NS_ERROR_NOT_AVAILABLE;
 32424:   
 32424:   // If a synchronous decode was requested, do it
 32424:   if (aFlags & FLAG_SYNC_DECODE) {
 32424:     rv = SyncDecode();
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 32424:   // Get the frame. If it's not there, it's probably the caller's fault for
 32424:   // not waiting for the data to be loaded from the network or not passing
 32424:   // FLAG_SYNC_DECODE
108991:   uint32_t frameIndex = (aWhichFrame == FRAME_FIRST) ?
 32424:                         0 : GetCurrentImgFrameIndex();
 34809:   imgFrame *frame = GetDrawableImgFrame(frameIndex);
 32424:   if (!frame) {
106838:     *_retval = nullptr;
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 30479:   // The frame can be smaller than the image. We want to extract only the part
 30479:   // of the frame that actually exists.
 30479:   nsIntRect framerect = frame->GetRect();
 30479:   framerect.IntersectRect(framerect, aRegion);
 30479: 
 31137:   if (framerect.IsEmpty())
 31137:     return NS_ERROR_NOT_AVAILABLE;
 31137: 
 30479:   nsAutoPtr<imgFrame> subframe;
 32424:   rv = frame->Extract(framerect, getter_Transfers(subframe));
 30479:   if (NS_FAILED(rv))
 30479:     return rv;
 30479: 
 30479:   img->mFrames.AppendElement(subframe.forget());
 30479: 
 51296:   img->mStatusTracker->RecordLoaded();
 51296:   img->mStatusTracker->RecordDecoded();
 48320: 
 30479:   *_retval = img.forget().get();
 30479: 
     1:   return NS_OK;
     1: }
     1: 
     1: //******************************************************************************
108991: /* readonly attribute int32_t width; */
 50550: NS_IMETHODIMP
108991: RasterImage::GetWidth(int32_t *aWidth)
     1: {
 13362:   NS_ENSURE_ARG_POINTER(aWidth);
     1: 
 54975:   if (mError) {
 54975:     *aWidth = 0;
 32424:     return NS_ERROR_FAILURE;
 54975:   }
 32424: 
     1:   *aWidth = mSize.width;
     1:   return NS_OK;
     1: }
     1: 
     1: //******************************************************************************
108991: /* readonly attribute int32_t height; */
 50550: NS_IMETHODIMP
108991: RasterImage::GetHeight(int32_t *aHeight)
     1: {
 13362:   NS_ENSURE_ARG_POINTER(aHeight);
     1: 
 54975:   if (mError) {
 54975:     *aHeight = 0;
 32424:     return NS_ERROR_FAILURE;
 54975:   }
 32424: 
     1:   *aHeight = mSize.height;
     1:   return NS_OK;
     1: }
     1: 
 50552: //******************************************************************************
 50552: /* unsigned short GetType(); */
 50552: NS_IMETHODIMP
108991: RasterImage::GetType(uint16_t *aType)
 50552: {
 50552:   NS_ENSURE_ARG_POINTER(aType);
 50552: 
 58783:   *aType = GetType();
 50552:   return NS_OK;
 50552: }
 50552: 
 58783: //******************************************************************************
108991: /* [noscript, notxpcom] uint16_t GetType(); */
108991: NS_IMETHODIMP_(uint16_t)
 58783: RasterImage::GetType()
 58783: {
 58783:   return imgIContainer::TYPE_RASTER;
 58783: }
 58783: 
 50550: imgFrame*
108991: RasterImage::GetImgFrameNoDecode(uint32_t framenum)
  7009: {
 30479:   if (!mAnim) {
 30479:     NS_ASSERTION(framenum == 0, "Don't ask for a frame > 0 if we're not animated!");
106838:     return mFrames.SafeElementAt(0, nullptr);
 30479:   }
108991:   if (mAnim->lastCompositedFrameIndex == int32_t(framenum))
 13362:     return mAnim->compositingFrame;
106838:   return mFrames.SafeElementAt(framenum, nullptr);
 30479: }
 30479: 
 50550: imgFrame*
108991: RasterImage::GetImgFrame(uint32_t framenum)
 74210: {
 74210:   nsresult rv = WantDecodedFrames();
106838:   CONTAINER_ENSURE_TRUE(NS_SUCCEEDED(rv), nullptr);
 74210:   return GetImgFrameNoDecode(framenum);
 74210: }
 74210: 
 74210: imgFrame*
108991: RasterImage::GetDrawableImgFrame(uint32_t framenum)
 34809: {
 34809:   imgFrame *frame = GetImgFrame(framenum);
 34809: 
 34809:   // We will return a paletted frame if it's not marked as compositing failed
 34809:   // so we can catch crashes for reasons we haven't investigated.
 34809:   if (frame && frame->GetCompositingFailed())
106838:     return nullptr;
 34809:   return frame;
 34809: }
 34809: 
108991: uint32_t
 50550: RasterImage::GetCurrentImgFrameIndex() const
 30479: {
 30479:   if (mAnim)
 30479:     return mAnim->currentAnimationFrameIndex;
 30479: 
 30479:   return 0;
 30479: }
 30479: 
 82104: TimeStamp
 82104: RasterImage::GetCurrentImgFrameEndTime() const
 82104: {
 82104:   imgFrame* currentFrame = mFrames[mAnim->currentAnimationFrameIndex];
 82104:   TimeStamp currentFrameTime = mAnim->currentAnimationFrameTime;
108991:   int64_t timeout = currentFrame->GetTimeout();
 82104: 
 82104:   if (timeout < 0) {
 82104:     // We need to return a sentinel value in this case, because our logic
 82104:     // doesn't work correctly if we have a negative timeout value. The reason
 82104:     // this positive infinity was chosen was because it works with the loop in
 82104:     // RequestRefresh() above.
 86980:     return TimeStamp() + TimeDuration::FromMilliseconds(UINT64_MAX);
 82104:   }
 82104: 
 82104:   TimeDuration durationOfTimeout = TimeDuration::FromMilliseconds(timeout);
 82104:   TimeStamp currentFrameEndTime = currentFrameTime + durationOfTimeout;
 82104: 
 82104:   return currentFrameEndTime;
 82104: }
 82104: 
 50550: imgFrame*
 50550: RasterImage::GetCurrentImgFrame()
 30479: {
 30479:   return GetImgFrame(GetCurrentImgFrameIndex());
  7009: }
  7009: 
 50550: imgFrame*
 50550: RasterImage::GetCurrentDrawableImgFrame()
 34809: {
 34809:   return GetDrawableImgFrame(GetCurrentImgFrameIndex());
 34809: }
 34809: 
     1: //******************************************************************************
 30479: /* readonly attribute boolean currentFrameIsOpaque; */
 50550: NS_IMETHODIMP
 79445: RasterImage::GetCurrentFrameIsOpaque(bool *aIsOpaque)
     1: {
 30479:   NS_ENSURE_ARG_POINTER(aIsOpaque);
  7009: 
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   // See if we can get an image frame
 30479:   imgFrame *curframe = GetCurrentImgFrame();
 32424: 
 32424:   // If we don't get a frame, the safe answer is "not opaque"
 32424:   if (!curframe)
 80486:     *aIsOpaque = false;
 32424: 
 32424:   // Otherwise, we can make a more intelligent decision
 32424:   else {
 30479:     *aIsOpaque = !curframe->GetNeedsBackground();
 30479: 
 30479:     // We are also transparent if the current frame's size doesn't cover our
 30479:     // entire area.
 30479:     nsIntRect framerect = curframe->GetRect();
 68638:     *aIsOpaque = *aIsOpaque && framerect.IsEqualInterior(nsIntRect(0, 0, mSize.width, mSize.height));
 32424:   }
 30479: 
 30479:   return NS_OK;
 30479: }
 30479: 
 51294: void
 50550: RasterImage::GetCurrentFrameRect(nsIntRect& aRect)
 30479: {
 32424:   // Get the current frame
 30479:   imgFrame* curframe = GetCurrentImgFrame();
 32424: 
 32424:   // If we have the frame, use that rectangle
 51294:   if (curframe) {
 30479:     aRect = curframe->GetRect();
 51294:   } else {
 32424:     // If the frame doesn't exist, we pass the empty rectangle. It's not clear
 32424:     // whether this is appropriate in general, but at the moment the only
 51294:     // consumer of this method is imgStatusTracker (when it wants to figure out
 51294:     // dirty rectangles to send out batched observer updates). This should
 51294:     // probably be revisited when we fix bug 503973.
 32424:     aRect.MoveTo(0, 0);
 32424:     aRect.SizeTo(0, 0);
 32424:   }
 30479: }
 30479: 
108991: uint32_t
 51231: RasterImage::GetCurrentFrameIndex()
 30479: {
 51231:   return GetCurrentImgFrameIndex();
     1: }
     1: 
108991: uint32_t
 51231: RasterImage::GetNumFrames()
     1: {
 51231:   return mFrames.Length();
     1: }
     1: 
     1: //******************************************************************************
 30479: /* readonly attribute boolean animated; */
 50550: NS_IMETHODIMP
 79445: RasterImage::GetAnimated(bool *aAnimated)
 30479: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 30479:   NS_ENSURE_ARG_POINTER(aAnimated);
 30479: 
 33531:   // If we have mAnim, we can know for sure
 33531:   if (mAnim) {
 80486:     *aAnimated = true;
 33531:     return NS_OK;
 33531:   }
 33531: 
 33531:   // Otherwise, we need to have been decoded to know for sure, since if we were
 33531:   // decoded at least once mAnim would have been created for animated images
 33531:   if (!mHasBeenDecoded)
 33531:     return NS_ERROR_NOT_AVAILABLE;
 33531: 
 33531:   // We know for sure
 80486:   *aAnimated = false;
 30479: 
 30479:   return NS_OK;
 30479: }
 30479: 
 30479: 
 30479: //******************************************************************************
108991: /* [noscript] gfxImageSurface copyFrame(in uint32_t aWhichFrame,
108991:  *                                      in uint32_t aFlags); */
 50550: NS_IMETHODIMP
108991: RasterImage::CopyFrame(uint32_t aWhichFrame,
108991:                        uint32_t aFlags,
 32424:                        gfxImageSurface **_retval)
     1: {
 32424:   if (aWhichFrame > FRAME_MAX_VALUE)
 32424:     return NS_ERROR_INVALID_ARG;
 32424: 
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 48223:   // Disallowed in the API
 48223:   if (mInDecoder && (aFlags & imgIContainer::FLAG_SYNC_DECODE))
 48223:     return NS_ERROR_FAILURE;
 48223: 
 32424:   nsresult rv;
 32424: 
108318:   if (!ApplyDecodeFlags(aFlags))
 60418:     return NS_ERROR_NOT_AVAILABLE;
 60418: 
 32424:   // If requested, synchronously flush any data we have lying around to the decoder
 32424:   if (aFlags & FLAG_SYNC_DECODE) {
 32424:     rv = SyncDecode();
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 13362:   NS_ENSURE_ARG_POINTER(_retval);
  7009: 
 32424:   // Get the frame. If it's not there, it's probably the caller's fault for
 32424:   // not waiting for the data to be loaded from the network or not passing
 32424:   // FLAG_SYNC_DECODE
108991:   uint32_t frameIndex = (aWhichFrame == FRAME_FIRST) ?
 32424:                         0 : GetCurrentImgFrameIndex();
 34809:   imgFrame *frame = GetDrawableImgFrame(frameIndex);
 32424:   if (!frame) {
106838:     *_retval = nullptr;
 32424:     return NS_ERROR_FAILURE;
 32424:   }
 30479: 
 30479:   nsRefPtr<gfxPattern> pattern;
 30479:   frame->GetPattern(getter_AddRefs(pattern));
 30479:   nsIntRect intframerect = frame->GetRect();
 30479:   gfxRect framerect(intframerect.x, intframerect.y, intframerect.width, intframerect.height);
 30479: 
 30479:   // Create a 32-bit image surface of our size, but draw using the frame's
 30479:   // rect, implicitly padding the frame out to the image's size.
 30479:   nsRefPtr<gfxImageSurface> imgsurface = new gfxImageSurface(gfxIntSize(mSize.width, mSize.height),
 30479:                                                              gfxASurface::ImageFormatARGB32);
 30479:   gfxContext ctx(imgsurface);
 30479:   ctx.SetOperator(gfxContext::OPERATOR_SOURCE);
 98300:   ctx.Rectangle(framerect);
 98300:   ctx.Translate(framerect.TopLeft());
 30479:   ctx.SetPattern(pattern);
 30479:   ctx.Fill();
 30479: 
 30479:   *_retval = imgsurface.forget().get();
  3538:   return NS_OK;
 30479: }
  3538: 
 30479: //******************************************************************************
108991: /* [noscript] gfxASurface getFrame(in uint32_t aWhichFrame,
108991:  *                                 in uint32_t aFlags); */
 50550: NS_IMETHODIMP
108991: RasterImage::GetFrame(uint32_t aWhichFrame,
108991:                       uint32_t aFlags,
 32424:                       gfxASurface **_retval)
 30479: {
 32424:   if (aWhichFrame > FRAME_MAX_VALUE)
 32424:     return NS_ERROR_INVALID_ARG;
 32424: 
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 48223:   // Disallowed in the API
 48223:   if (mInDecoder && (aFlags & imgIContainer::FLAG_SYNC_DECODE))
 48223:     return NS_ERROR_FAILURE;
 48223: 
 32424:   nsresult rv = NS_OK;
 32424: 
108318:   if (!ApplyDecodeFlags(aFlags))
 60418:     return NS_ERROR_NOT_AVAILABLE;
 60418: 
 32424:   // If the caller requested a synchronous decode, do it
 32424:   if (aFlags & FLAG_SYNC_DECODE) {
 32424:     rv = SyncDecode();
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 32424:   // Get the frame. If it's not there, it's probably the caller's fault for
 32424:   // not waiting for the data to be loaded from the network or not passing
 32424:   // FLAG_SYNC_DECODE
108991:   uint32_t frameIndex = (aWhichFrame == FRAME_FIRST) ?
 32424:                           0 : GetCurrentImgFrameIndex();
 34809:   imgFrame *frame = GetDrawableImgFrame(frameIndex);
 32424:   if (!frame) {
106838:     *_retval = nullptr;
 32424:     return NS_ERROR_FAILURE;
 32424:   }
  7009: 
 30479:   nsRefPtr<gfxASurface> framesurf;
  3538: 
 30479:   // If this frame covers the entire image, we can just reuse its existing
 30479:   // surface.
 30479:   nsIntRect framerect = frame->GetRect();
 30479:   if (framerect.x == 0 && framerect.y == 0 &&
 30479:       framerect.width == mSize.width &&
 30479:       framerect.height == mSize.height)
 30479:     rv = frame->GetSurface(getter_AddRefs(framesurf));
     1: 
 30479:   // The image doesn't have a surface because it's been optimized away. Create
 30479:   // one.
 30479:   if (!framesurf) {
 30479:     nsRefPtr<gfxImageSurface> imgsurf;
 32424:     rv = CopyFrame(aWhichFrame, aFlags, getter_AddRefs(imgsurf));
 30479:     framesurf = imgsurf;
 30479:   }
 30479: 
 30479:   *_retval = framesurf.forget().get();
 30479: 
 30479:   return rv;
 30479: }
 30479: 
115336: already_AddRefed<layers::Image>
115336: RasterImage::GetCurrentImage()
115336: {
115336:   nsRefPtr<gfxASurface> imageSurface;
115336:   nsresult rv = GetFrame(FRAME_CURRENT, FLAG_SYNC_DECODE, getter_AddRefs(imageSurface));
115336:   NS_ENSURE_SUCCESS(rv, nullptr);
115336: 
115666:   if (!mImageContainer) {
115666:     mImageContainer = LayerManager::CreateImageContainer();
115666:   }
115666: 
115336:   CairoImage::Data cairoData;
115336:   cairoData.mSurface = imageSurface;
115336:   GetWidth(&cairoData.mSize.width);
115336:   GetHeight(&cairoData.mSize.height);
115336: 
115336:   ImageFormat cairoFormat = CAIRO_SURFACE;
115336:   nsRefPtr<layers::Image> image = mImageContainer->CreateImage(&cairoFormat, 1);
115336:   NS_ASSERTION(image, "Failed to create Image");
115336:   
115336:   NS_ASSERTION(image->GetFormat() == cairoFormat, "Wrong format");
115336:   static_cast<CairoImage*>(image.get())->SetData(cairoData);
115336: 
115336:   return image.forget();
115336: }
115336: 
 82042: 
 82042: NS_IMETHODIMP
 89204: RasterImage::GetImageContainer(ImageContainer **_retval)
 82042: {
 89204:   if (mImageContainer) {
 82042:     *_retval = mImageContainer;
 88529:     NS_ADDREF(*_retval);
 82042:     return NS_OK;
 82042:   }
 82042:   
115336:   nsRefPtr<layers::Image> image = GetCurrentImage();
115336:   if (!image) {
115336:     return NS_ERROR_FAILURE;
115336:   }
106770:   mImageContainer->SetCurrentImageInTransaction(image);
 82042: 
 82042:   *_retval = mImageContainer;
 88529:   NS_ADDREF(*_retval);
 82042:   return NS_OK;
 82042: }
 82042: 
115336: void
115336: RasterImage::UpdateImageContainer()
115336: {
115336:   if (!mImageContainer || IsInUpdateImageContainer()) {
115336:     return;
115336:   }
115336: 
115336:   SetInUpdateImageContainer(true);
115336: 
115336:   nsRefPtr<layers::Image> image = GetCurrentImage();
115336:   if (!image) {
115336:     return;
115336:   }
115336:   mImageContainer->SetCurrentImage(image);
115336:   SetInUpdateImageContainer(false);
115336: }
115336: 
 90638: size_t
 90638: RasterImage::HeapSizeOfSourceWithComputedFallback(nsMallocSizeOfFun aMallocSizeOf) const
 42553: {
 90638:   // n == 0 is possible for two reasons. 
 90638:   // - This is a zero-length image.
 90638:   // - We're on a platform where moz_malloc_size_of always returns 0.
 90638:   // In either case the fallback works appropriately.
 90638:   size_t n = mSourceData.SizeOfExcludingThis(aMallocSizeOf);
 90638:   if (n == 0) {
 90638:     n = mSourceData.Length();
 90638:     NS_ABORT_IF_FALSE(StoringSourceData() || (n == 0),
 90638:                       "Non-zero source data size when we aren't storing it?");
 90638:   }
 90638:   return n;
 90638: }
 90638: 
 90638: static size_t
 90638: SizeOfDecodedWithComputedFallbackIfHeap(
 90638:   const nsTArray<imgFrame*>& aFrames, gfxASurface::MemoryLocation aLocation,
 90638:   nsMallocSizeOfFun aMallocSizeOf)
 90638: {
 90638:   size_t n = 0;
108991:   for (uint32_t i = 0; i < aFrames.Length(); ++i) {
106838:     imgFrame* frame = aFrames.SafeElementAt(i, nullptr);
 32424:     NS_ABORT_IF_FALSE(frame, "Null frame in frame array!");
 90638:     n += frame->SizeOfExcludingThisWithComputedFallbackIfHeap(aLocation, aMallocSizeOf);
     1:   }
     1: 
 90638:   return n;
 42553: }
 42553: 
 90638: size_t
 90638: RasterImage::HeapSizeOfDecodedWithComputedFallback(nsMallocSizeOfFun aMallocSizeOf) const
 74887: {
 90638:   return SizeOfDecodedWithComputedFallbackIfHeap(
 90638:            mFrames, gfxASurface::MEMORY_IN_PROCESS_HEAP, aMallocSizeOf);
 74887: }
 74887: 
 90638: size_t
 90638: RasterImage::NonHeapSizeOfDecoded() const
 74887: {
 90638:   return SizeOfDecodedWithComputedFallbackIfHeap(mFrames, gfxASurface::MEMORY_IN_PROCESS_NONHEAP, NULL);
 74887: }
 74887: 
 90638: size_t
 90638: RasterImage::OutOfProcessSizeOfDecoded() const
 74887: {
 90638:   return SizeOfDecodedWithComputedFallbackIfHeap(mFrames, gfxASurface::MEMORY_OUT_OF_PROCESS, NULL);
 30479: }
 30479: 
 50550: void
108991: RasterImage::DeleteImgFrame(uint32_t framenum)
 39120: {
 39120:   NS_ABORT_IF_FALSE(framenum < mFrames.Length(), "Deleting invalid frame!");
 39120: 
 39120:   delete mFrames[framenum];
106838:   mFrames[framenum] = nullptr;
 39120: }
 39120: 
 50550: nsresult
108991: RasterImage::InternalAddFrameHelper(uint32_t framenum, imgFrame *aFrame,
108991:                                     uint8_t **imageData, uint32_t *imageLength,
108991:                                     uint32_t **paletteData, uint32_t *paletteLength)
 30479: {
 32424:   NS_ABORT_IF_FALSE(framenum <= mFrames.Length(), "Invalid frame index!");
 32424:   if (framenum > mFrames.Length())
 30479:     return NS_ERROR_INVALID_ARG;
 30479: 
 30479:   nsAutoPtr<imgFrame> frame(aFrame);
 30479: 
 38698:   // We are in the middle of decoding. This will be unlocked when we finish the
 38698:   // decoder->Write() call.
 38698:   frame->LockImageData();
 38698: 
115544:   if (paletteData && paletteLength)
115544:     frame->GetPaletteData(paletteData, paletteLength);
115544: 
115544:   frame->GetImageData(imageData, imageLength);
115544: 
 30479:   mFrames.InsertElementAt(framenum, frame.forget());
  7009: 
     1:   return NS_OK;
     1: }
     1:                                   
 50550: nsresult
108991: RasterImage::InternalAddFrame(uint32_t framenum,
108991:                               int32_t aX, int32_t aY,
108991:                               int32_t aWidth, int32_t aHeight,
 30479:                               gfxASurface::gfxImageFormat aFormat,
108991:                               uint8_t aPaletteDepth,
108991:                               uint8_t **imageData,
108991:                               uint32_t *imageLength,
108991:                               uint32_t **paletteData,
108991:                               uint32_t *paletteLength)
 30479: {
 38698:   // We assume that we're in the middle of decoding because we unlock the
 38698:   // previous frame when we create a new frame, and only when decoding do we
 38698:   // lock frames.
 38698:   NS_ABORT_IF_FALSE(mInDecoder, "Only decoders may add frames!");
 38698: 
 32424:   NS_ABORT_IF_FALSE(framenum <= mFrames.Length(), "Invalid frame index!");
 32424:   if (framenum > mFrames.Length())
 30479:     return NS_ERROR_INVALID_ARG;
 30479: 
 30479:   nsAutoPtr<imgFrame> frame(new imgFrame());
 30479: 
 30479:   nsresult rv = frame->Init(aX, aY, aWidth, aHeight, aFormat, aPaletteDepth);
 30479:   NS_ENSURE_SUCCESS(rv, rv);
 30479: 
 38698:   // We know we are in a decoder. Therefore, we must unlock the previous frame
 38698:   // when we move on to decoding into the next frame.
 38698:   if (mFrames.Length() > 0) {
 38698:     imgFrame *prevframe = mFrames.ElementAt(mFrames.Length() - 1);
 38698:     prevframe->UnlockImageData();
 38698:   }
 38698: 
 30479:   if (mFrames.Length() == 0) {
 30479:     return InternalAddFrameHelper(framenum, frame.forget(), imageData, imageLength, 
 30479:                                   paletteData, paletteLength);
 30479:   }
 30479: 
 30479:   if (mFrames.Length() == 1) {
  7089:     // Since we're about to add our second frame, initialize animation stuff
 74720:     EnsureAnimExists();
     1:     
     1:     // If we dispose of the first frame by clearing it, then the
     1:     // First Frame's refresh area is all of itself.
     1:     // RESTORE_PREVIOUS is invalid (assumed to be DISPOSE_CLEAR)
108991:     int32_t frameDisposalMethod = mFrames[0]->GetFrameDisposalMethod();
 50553:     if (frameDisposalMethod == kDisposeClear ||
 50553:         frameDisposalMethod == kDisposeRestorePrevious)
 30479:       mAnim->firstFrameRefreshArea = mFrames[0]->GetRect();
     1:   }
     1: 
     1:   // Calculate firstFrameRefreshArea
     1:   // Some gifs are huge but only have a small area that they animate
     1:   // We only need to refresh that small area when Frame 0 comes around again
 30479:   nsIntRect frameRect = frame->GetRect();
     1:   mAnim->firstFrameRefreshArea.UnionRect(mAnim->firstFrameRefreshArea, 
 30479:                                          frameRect);
     1:   
 30479:   rv = InternalAddFrameHelper(framenum, frame.forget(), imageData, imageLength,
 30479:                               paletteData, paletteLength);
  7009:   
 52149:   // We may be able to start animating, if we now have enough frames
 52149:   EvaluateAnimation();
     1:   
 30479:   return rv;
 30479: }
 30479: 
108318: bool
108991: RasterImage::ApplyDecodeFlags(uint32_t aNewFlags)
108318: {
108318:   if (mFrameDecodeFlags == (aNewFlags & DECODE_FLAGS_MASK))
108318:     return true; // Not asking very much of us here.
108318: 
108318:   if (mDecoded) {
108318:     // if we can't discard, then we're screwed; we have no way
108318:     // to re-decode.  Similarly if we aren't allowed to do a sync
108318:     // decode.
108318:     if (!(aNewFlags & FLAG_SYNC_DECODE))
108318:       return false;
108318:     if (!CanForciblyDiscard() || mDecoder || mAnim)
108318:       return false;
108318:     ForceDiscard();
108318:   }
108318: 
108318:   mFrameDecodeFlags = aNewFlags & DECODE_FLAGS_MASK;
108318:   return true;
108318: }
108318: 
 50553: nsresult
108991: RasterImage::SetSize(int32_t aWidth, int32_t aHeight)
 32424: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   // Ensure that we have positive values
 32424:   // XXX - Why isn't the size unsigned? Should this be changed?
 32424:   if ((aWidth < 0) || (aHeight < 0))
 32424:     return NS_ERROR_INVALID_ARG;
 32424: 
 32424:   // if we already have a size, check the new size against the old one
 98961:   if (!mMultipart && mHasSize &&
 32424:       ((aWidth != mSize.width) || (aHeight != mSize.height))) {
 32424:     NS_WARNING("Image changed size on redecode! This should not happen!");
 32424: 
 69680:     // Make the decoder aware of the error so that it doesn't try to call
 69680:     // FinishInternal during ShutdownDecoder.
 69680:     if (mDecoder)
 69680:       mDecoder->PostResizeError();
 69680: 
 32424:     DoError();
 32424:     return NS_ERROR_UNEXPECTED;
 32424:   }
 32424: 
 32424:   // Set the size and flag that we have it
 32424:   mSize.SizeTo(aWidth, aHeight);
 80486:   mHasSize = true;
 32424: 
 32424:   return NS_OK;
 32424: }
 32424: 
 50553: nsresult
108991: RasterImage::EnsureFrame(uint32_t aFrameNum, int32_t aX, int32_t aY,
108991:                          int32_t aWidth, int32_t aHeight,
 73884:                          gfxASurface::gfxImageFormat aFormat,
108991:                          uint8_t aPaletteDepth,
108991:                          uint8_t **imageData, uint32_t *imageLength,
108991:                          uint32_t **paletteData, uint32_t *paletteLength)
 73884: {
 73884:   if (mError)
 73884:     return NS_ERROR_FAILURE;
 73884: 
 73884:   NS_ENSURE_ARG_POINTER(imageData);
 73884:   NS_ENSURE_ARG_POINTER(imageLength);
 73884:   NS_ABORT_IF_FALSE(aFrameNum <= mFrames.Length(), "Invalid frame index!");
 73884: 
 73884:   if (aPaletteDepth > 0) {
 73884:     NS_ENSURE_ARG_POINTER(paletteData);
 73884:     NS_ENSURE_ARG_POINTER(paletteLength);
 73884:   }
 73884: 
 73884:   if (aFrameNum > mFrames.Length())
 73884:     return NS_ERROR_INVALID_ARG;
 73884: 
 73884:   // Adding a frame that doesn't already exist.
 73884:   if (aFrameNum == mFrames.Length())
 73884:     return InternalAddFrame(aFrameNum, aX, aY, aWidth, aHeight, aFormat, 
 73884:                             aPaletteDepth, imageData, imageLength,
 73884:                             paletteData, paletteLength);
 73884: 
 73884:   imgFrame *frame = GetImgFrame(aFrameNum);
 73884:   if (!frame)
 73884:     return InternalAddFrame(aFrameNum, aX, aY, aWidth, aHeight, aFormat, 
 73884:                             aPaletteDepth, imageData, imageLength,
 73884:                             paletteData, paletteLength);
 73884: 
 73884:   // See if we can re-use the frame that already exists.
 73884:   nsIntRect rect = frame->GetRect();
 73884:   if (rect.x == aX && rect.y == aY && rect.width == aWidth &&
 73884:       rect.height == aHeight && frame->GetFormat() == aFormat &&
 73884:       frame->GetPaletteDepth() == aPaletteDepth) {
 73884:     frame->GetImageData(imageData, imageLength);
 73884:     if (paletteData) {
 73884:       frame->GetPaletteData(paletteData, paletteLength);
 73884:     }
 73884: 
 73884:     // We can re-use the frame if it has image data.
 73884:     if (*imageData && paletteData && *paletteData) {
 73884:       return NS_OK;
 73884:     }
 73884:     if (*imageData && !paletteData) {
 73884:       return NS_OK;
 73884:     }
 73884:   }
 73884: 
 98961:   // Not reusable, so replace the frame directly.
115544: 
115544:   // We know this frame is already locked, because it's the one we're currently
115544:   // writing to.
115544:   frame->UnlockImageData();
115544: 
 73884:   DeleteImgFrame(aFrameNum);
 98961:   mFrames.RemoveElementAt(aFrameNum);
 98961:   nsAutoPtr<imgFrame> newFrame(new imgFrame());
 98961:   nsresult rv = newFrame->Init(aX, aY, aWidth, aHeight, aFormat, aPaletteDepth);
 98961:   NS_ENSURE_SUCCESS(rv, rv);
 98961:   return InternalAddFrameHelper(aFrameNum, newFrame.forget(), imageData,
 98961:                                 imageLength, paletteData, paletteLength);
 73884: }
 73884: 
 73884: nsresult
108991: RasterImage::EnsureFrame(uint32_t aFramenum, int32_t aX, int32_t aY,
108991:                          int32_t aWidth, int32_t aHeight,
 30479:                          gfxASurface::gfxImageFormat aFormat,
108991:                          uint8_t** imageData, uint32_t* imageLength)
 30479: {
 73884:   return EnsureFrame(aFramenum, aX, aY, aWidth, aHeight, aFormat,
 30479:                      /* aPaletteDepth = */ 0, imageData, imageLength,
106838:                      /* aPaletteData = */ nullptr,
106838:                      /* aPaletteLength = */ nullptr);
 30479: }
 30479: 
 51592: void
108991: RasterImage::FrameUpdated(uint32_t aFrameNum, nsIntRect &aUpdatedRect)
 30479: {
 51591:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
 30479: 
 74210:   imgFrame *frame = GetImgFrameNoDecode(aFrameNum);
 32424:   NS_ABORT_IF_FALSE(frame, "Calling FrameUpdated on frame that doesn't exist!");
 30479: 
 30479:   frame->ImageUpdated(aUpdatedRect);
115336:     
115666:   if (aFrameNum == GetCurrentImgFrameIndex() &&
115666:       !IsInUpdateImageContainer()) {
115666:     mImageContainer = nullptr;
115336:   }
 30479: }
 30479: 
 50553: nsresult
108991: RasterImage::SetFrameDisposalMethod(uint32_t aFrameNum,
108991:                                     int32_t aDisposalMethod)
 30479: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
 32424:   if (aFrameNum >= mFrames.Length())
 30479:     return NS_ERROR_INVALID_ARG;
 30479: 
 30479:   imgFrame *frame = GetImgFrame(aFrameNum);
 32424:   NS_ABORT_IF_FALSE(frame,
 32424:                     "Calling SetFrameDisposalMethod on frame that doesn't exist!");
 30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 30479: 
 30479:   frame->SetFrameDisposalMethod(aDisposalMethod);
 30479: 
 30479:   return NS_OK;
 30479: }
 30479: 
 50553: nsresult
108991: RasterImage::SetFrameTimeout(uint32_t aFrameNum, int32_t aTimeout)
 30479: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
 32424:   if (aFrameNum >= mFrames.Length())
 30479:     return NS_ERROR_INVALID_ARG;
 30479: 
 30479:   imgFrame *frame = GetImgFrame(aFrameNum);
 32424:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameTimeout on frame that doesn't exist!");
 30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 30479: 
 30479:   frame->SetTimeout(aTimeout);
 30479: 
 30479:   return NS_OK;
 30479: }
 30479: 
 50553: nsresult
108991: RasterImage::SetFrameBlendMethod(uint32_t aFrameNum, int32_t aBlendMethod)
 30479: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
 32424:   if (aFrameNum >= mFrames.Length())
 30479:     return NS_ERROR_INVALID_ARG;
 30479: 
 30479:   imgFrame *frame = GetImgFrame(aFrameNum);
 32424:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameBlendMethod on frame that doesn't exist!");
 30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 30479: 
 30479:   frame->SetBlendMethod(aBlendMethod);
 30479: 
 30479:   return NS_OK;
 30479: }
 30479: 
 50553: nsresult
108991: RasterImage::SetFrameHasNoAlpha(uint32_t aFrameNum)
 30479: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
 32424:   if (aFrameNum >= mFrames.Length())
 30479:     return NS_ERROR_INVALID_ARG;
 30479: 
 30479:   imgFrame *frame = GetImgFrame(aFrameNum);
 32424:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameHasNoAlpha on frame that doesn't exist!");
 30479:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 30479: 
 30479:   frame->SetHasNoAlpha();
 30479: 
     1:   return NS_OK;
     1: }
     1: 
 50553: nsresult
108991: RasterImage::SetFrameAsNonPremult(uint32_t aFrameNum, bool aIsNonPremult)
 93959: {
 93959:   if (mError)
 93959:     return NS_ERROR_FAILURE;
 93959: 
 93959:   NS_ABORT_IF_FALSE(aFrameNum < mFrames.Length(), "Invalid frame index!");
 93959:   if (aFrameNum >= mFrames.Length())
 93959:     return NS_ERROR_INVALID_ARG;
 93959: 
 93959:   imgFrame* frame = GetImgFrame(aFrameNum);
 93959:   NS_ABORT_IF_FALSE(frame, "Calling SetFrameAsNonPremult on frame that doesn't exist!");
 93959:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 93959: 
 93959:   frame->SetAsNonPremult(aIsNonPremult);
 93959: 
 93959:   return NS_OK;
 93959: }
 93959: 
 93959: nsresult
 50550: RasterImage::DecodingComplete()
     1: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   // Flag that we're done decoding.
 32424:   // XXX - these should probably be combined when we fix animated image
 32424:   // discarding with bug 500402.
 80486:   mDecoded = true;
 80486:   mHasBeenDecoded = true;
 30479: 
 32424:   nsresult rv;
 32424: 
 32424:   // We now have one of the qualifications for discarding. Re-evaluate.
 32424:   if (CanDiscard()) {
 46991:     NS_ABORT_IF_FALSE(!DiscardingActive(),
 32424:                       "We shouldn't have been discardable before this");
 50547:     rv = DiscardTracker::Reset(&mDiscardTrackerNode);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 32424:   // If there's only 1 frame, optimize it. Optimizing animated images
 32424:   // is not supported.
 32424:   //
 32424:   // We don't optimize the frame for multipart images because we reuse
 32424:   // the frame.
 32424:   if ((mFrames.Length() == 1) && !mMultipart) {
 32424:     rv = mFrames[0]->Optimize();
 32424:     NS_ENSURE_SUCCESS(rv, rv);
 32424:   }
 30479: 
     1:   return NS_OK;
     1: }
     1: 
     1: //******************************************************************************
 52149: /* void StartAnimation () */
 52149: nsresult
 50550: RasterImage::StartAnimation()
     1: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 52149:   NS_ABORT_IF_FALSE(ShouldAnimate(), "Should not animate!");
 52149: 
 74720:   EnsureAnimExists();
     1: 
 30479:   imgFrame* currentFrame = GetCurrentImgFrame();
     1:   if (currentFrame) {
 82104:     if (currentFrame->GetTimeout() < 0) { // -1 means display this frame forever
 80486:       mAnimationFinished = true;
 52149:       return NS_ERROR_ABORT;
 52149:     }
 82104: 
 82104:     // We need to set the time that this initial frame was first displayed, as
 82104:     // this is used in AdvanceFrame().
 82104:     mAnim->currentAnimationFrameTime = TimeStamp::Now();
 52149:   }
 52149:   
     1:   return NS_OK;
 13362: }
     1: 
     1: //******************************************************************************
     1: /* void stopAnimation (); */
 52149: nsresult
 50550: RasterImage::StopAnimation()
     1: {
 52149:   NS_ABORT_IF_FALSE(mAnimating, "Should be animating!");
 52149: 
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
     1:   return NS_OK;
     1: }
     1: 
     1: //******************************************************************************
     1: /* void resetAnimation (); */
 50550: NS_IMETHODIMP
 50550: RasterImage::ResetAnimation()
     1: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
     1:   if (mAnimationMode == kDontAnimMode || 
  6617:       !mAnim || mAnim->currentAnimationFrameIndex == 0)
     1:     return NS_OK;
     1: 
 80486:   mAnimationFinished = false;
 64529: 
 52149:   if (mAnimating)
 52149:     StopAnimation();
     1: 
     1:   mAnim->lastCompositedFrameIndex = -1;
     1:   mAnim->currentAnimationFrameIndex = 0;
115336:   UpdateImageContainer();
 32424: 
 32424:   // Note - We probably want to kick off a redecode somewhere around here when
 32424:   // we fix bug 500402.
 32424: 
 32424:   // Update display if we were animating before
     1:   nsCOMPtr<imgIContainerObserver> observer(do_QueryReferent(mObserver));
 52149:   if (mAnimating && observer)
118757:     observer->FrameChanged(&(mAnim->firstFrameRefreshArea));
     1: 
 64529:   if (ShouldAnimate()) {
 52149:     StartAnimation();
 64529:     // The animation may not have been running before, if mAnimationFinished
 64529:     // was false (before we changed it to true in this function). So, mark the
 64529:     // animation as running.
 80486:     mAnimating = true;
 64529:   }
 52149: 
     1:   return NS_OK;
     1: }
     1: 
 50553: void
108991: RasterImage::SetLoopCount(int32_t aLoopCount)
     1: {
 32424:   if (mError)
 50553:     return;
 32424: 
     1:   // -1  infinite
     1:   //  0  no looping, one iteration
     1:   //  1  one loop, two iterations
     1:   //  ...
     1:   mLoopCount = aLoopCount;
     1: }
     1: 
 50553: nsresult
108991: RasterImage::AddSourceData(const char *aBuffer, uint32_t aCount)
  7009: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   NS_ENSURE_ARG_POINTER(aBuffer);
 32424:   nsresult rv = NS_OK;
 32424: 
 32424:   // We should not call this if we're not initialized
 32424:   NS_ABORT_IF_FALSE(mInitialized, "Calling AddSourceData() on uninitialized "
 50549:                                   "RasterImage!");
 32424: 
 32424:   // We should not call this if we're already finished adding source data
 32424:   NS_ABORT_IF_FALSE(!mHasSourceData, "Calling AddSourceData() after calling "
 32424:                                      "sourceDataComplete()!");
 32424: 
 32424:   // This call should come straight from necko - no reentrancy allowed
 32424:   NS_ABORT_IF_FALSE(!mInDecoder, "Re-entrant call to AddSourceData!");
 32424: 
106663:   // Image is already decoded, we shouldn't be getting data, but it could
106663:   // be extra garbage data at the end of a file.
106663:   if (mDecoded) {
106663:     return NS_OK;
106663:   }
106663: 
 98961:   // Starting a new part's frames, let's clean up before we add any
 98961:   // This needs to happen just before we start getting EnsureFrame() call(s),
 98961:   // so that there's no gap for anything to miss us.
106663:   if (mMultipart && mBytesDecoded == 0) {
 98961:     // Our previous state may have been animated, so let's clean up
 98961:     if (mAnimating) {
 98961:       StopAnimation();
 98961:       mAnimating = false;
 98961:     }
 98961:     mAnimationFinished = false;
 98961:     if (mAnim) {
 98961:       delete mAnim;
106838:       mAnim = nullptr;
 98961:     }
 98961:     // If there's only one frame, this could cause flickering
 98961:     int old_frame_count = mFrames.Length();
 98961:     if (old_frame_count > 1) {
 98961:       for (int i = 0; i < old_frame_count; ++i) {
 98961:         DeleteImgFrame(i);
 98961:       }
 98961:       mFrames.Clear();
 98961:     }
 98961:   }
 98961: 
 32424:   // If we're not storing source data, write it directly to the decoder
 32424:   if (!StoringSourceData()) {
 32424:     rv = WriteToDecoder(aBuffer, aCount);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 51593: 
 51593:     // We're not storing source data, so this data is probably coming straight
 51593:     // from the network. In this case, we want to display data as soon as we
 51593:     // get it, so we want to flush invalidations after every write.
 69680:     nsRefPtr<Decoder> kungFuDeathGrip = mDecoder;
 80486:     mInDecoder = true;
 51593:     mDecoder->FlushInvalidations();
 80486:     mInDecoder = false;
  7009:   }
  7009: 
 32424:   // Otherwise, we're storing data in the source buffer
 32424:   else {
 32424: 
 32424:     // Store the data
 32424:     char *newElem = mSourceData.AppendElements(aBuffer, aCount);
 32424:     if (!newElem)
 32424:       return NS_ERROR_OUT_OF_MEMORY;
 32424: 
 32424:     // If there's a decoder open, that means we want to do more decoding.
 89821:     // Wake up the worker.
 89821:     if (mDecoder) {
 89821:       DecodeWorker::Singleton()->RequestDecode(this);
  7009:     }
  7009:   }
  7009: 
 32424:   // Statistics
 32424:   total_source_bytes += aCount;
 32424:   if (mDiscardable)
 32424:     discardable_source_bytes += aCount;
  7009:   PR_LOG (gCompressedImageAccountingLog, PR_LOG_DEBUG,
 50549:           ("CompressedImageAccounting: Added compressed data to RasterImage %p (%s). "
 32424:            "Total Containers: %d, Discardable containers: %d, "
 32424:            "Total source bytes: %lld, Source bytes for discardable containers %lld",
  7009:            this,
 32424:            mSourceDataMimeType.get(),
 32424:            num_containers,
 32424:            num_discardable_containers,
 32424:            total_source_bytes,
 32424:            discardable_source_bytes));
  7009: 
  7009:   return NS_OK;
  7009: }
  7009: 
  7009: /* Note!  buf must be declared as char buf[9]; */
  7009: // just used for logging and hashing the header
  7009: static void
107848: get_header_str (char *buf, char *data, size_t data_len)
  7009: {
  7009:   int i;
  7009:   int n;
  7009:   static char hex[] = "0123456789abcdef";
  7009: 
  7009:   n = data_len < 4 ? data_len : 4;
  7009: 
  7009:   for (i = 0; i < n; i++) {
  7009:     buf[i * 2]     = hex[(data[i] >> 4) & 0x0f];
  7009:     buf[i * 2 + 1] = hex[data[i] & 0x0f];
  7009:   }
  7009: 
  7009:   buf[i * 2] = 0;
  7009: }
  7009: 
 50553: nsresult
 50550: RasterImage::SourceDataComplete()
  7009: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   // If we've been called before, ignore. Otherwise, flag that we have everything
 32424:   if (mHasSourceData)
  7009:     return NS_OK;
 80486:   mHasSourceData = true;
 32424: 
 32424:   // This call should come straight from necko - no reentrancy allowed
 32424:   NS_ABORT_IF_FALSE(!mInDecoder, "Re-entrant call to AddSourceData!");
 32424: 
 32424:   // If we're not storing any source data, then all the data was written
 32424:   // directly to the decoder in the AddSourceData() calls. This means we're
 32424:   // done, so we can shut down the decoder.
 32424:   if (!StoringSourceData()) {
 32424:     nsresult rv = ShutdownDecoder(eShutdownIntent_Done);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 89821:   // If there's a decoder open, synchronously decode the beginning of the image
 89821:   // to check for errors and get the image's size.  (If we already have the
 89821:   // image's size, this does nothing.)  Then kick off an async decode of the
 89821:   // rest of the image.
 89821:   if (mDecoder) {
 89821:     nsresult rv = DecodeWorker::Singleton()->DecodeUntilSizeAvailable(this);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 89821:   // If DecodeUntilSizeAvailable didn't finish the decode, let the decode worker
 89821:   // finish decoding this image.
 89821:   if (mDecoder) {
 89821:     DecodeWorker::Singleton()->RequestDecode(this);
 89821:   }
 89821: 
 32424:   // Free up any extra space in the backing buffer
 32424:   mSourceData.Compact();
 32424: 
 32424:   // Log header information
  7009:   if (PR_LOG_TEST(gCompressedImageAccountingLog, PR_LOG_DEBUG)) {
  7009:     char buf[9];
 32424:     get_header_str(buf, mSourceData.Elements(), mSourceData.Length());
  7009:     PR_LOG (gCompressedImageAccountingLog, PR_LOG_DEBUG,
 50549:             ("CompressedImageAccounting: RasterImage::SourceDataComplete() - data "
 32424:              "is done for container %p (%s) - header %p is 0x%s (length %d)",
  7009:              this,
 32424:              mSourceDataMimeType.get(),
 32424:              mSourceData.Elements(),
  7009:              buf,
 32424:              mSourceData.Length()));
  7009:   }
  7009: 
 32424:   // We now have one of the qualifications for discarding. Re-evaluate.
 32424:   if (CanDiscard()) {
 50547:     nsresult rv = DiscardTracker::Reset(&mDiscardTrackerNode);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424:   return NS_OK;
 32424: }
 32424: 
 50553: nsresult
114642: RasterImage::NewSourceData()
 32424: {
 32424:   nsresult rv;
 32424: 
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   // The source data should be complete before calling this
 32424:   NS_ABORT_IF_FALSE(mHasSourceData,
 32424:                     "Calling NewSourceData before SourceDataComplete!");
 32424:   if (!mHasSourceData)
 32424:     return NS_ERROR_ILLEGAL_VALUE;
 32424: 
 32424:   // Only supported for multipart channels. It wouldn't be too hard to change this,
 32424:   // but it would involve making sure that things worked for decode-on-draw and
 32424:   // discarding. Presently there's no need for this, so we don't.
 32424:   NS_ABORT_IF_FALSE(mMultipart, "NewSourceData not supported for multipart");
 32424:   if (!mMultipart)
 32424:     return NS_ERROR_ILLEGAL_VALUE;
 32424: 
 32424:   // We're multipart, so we shouldn't be storing source data
 32424:   NS_ABORT_IF_FALSE(!StoringSourceData(),
 32424:                     "Shouldn't be storing source data for multipart");
 32424: 
 32424:   // We're not storing the source data and we got SourceDataComplete. We should
 32424:   // have shut down the previous decoder
 32424:   NS_ABORT_IF_FALSE(!mDecoder, "Shouldn't have a decoder in NewSourceData");
 32424: 
 32424:   // The decoder was shut down and we didn't flag an error, so we should be decoded
 32424:   NS_ABORT_IF_FALSE(mDecoded, "Should be decoded in NewSourceData");
 32424: 
 32424:   // Reset some flags
 80486:   mDecoded = false;
 80486:   mHasSourceData = false;
 32424: 
 32424:   // We're decode-on-load here. Open up a new decoder just like what happens when
 32424:   // we call Init() for decode-on-load images.
 51244:   rv = InitDecoder(/* aDoSizeDecode = */ false);
 32424:   CONTAINER_ENSURE_SUCCESS(rv);
 32424: 
 32424:   return NS_OK;
  7009: }
  7009: 
 50553: nsresult
108991: RasterImage::SetSourceSizeHint(uint32_t sizeHint)
 46235: {
 46235:   if (sizeHint && StoringSourceData())
 71472:     return mSourceData.SetCapacity(sizeHint) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 46235:   return NS_OK;
 46235: }
 46235: 
 46235: //******************************************************************************
     1: // DoComposite gets called when the timer for animation get fired and we have to
     1: // update the composited frame of the animation.
 50550: nsresult
 80037: RasterImage::DoComposite(nsIntRect* aDirtyRect,
 30479:                          imgFrame* aPrevFrame,
 30479:                          imgFrame* aNextFrame,
108991:                          int32_t aNextFrameIndex)
     1: {
 13362:   NS_ENSURE_ARG_POINTER(aDirtyRect);
 13362:   NS_ENSURE_ARG_POINTER(aPrevFrame);
 13362:   NS_ENSURE_ARG_POINTER(aNextFrame);
     1: 
108991:   int32_t prevFrameDisposalMethod = aPrevFrame->GetFrameDisposalMethod();
 50553:   if (prevFrameDisposalMethod == kDisposeRestorePrevious &&
     1:       !mAnim->compositingPrevFrame)
 50553:     prevFrameDisposalMethod = kDisposeClear;
 30479: 
 30479:   nsIntRect prevFrameRect = aPrevFrame->GetRect();
 74143:   bool isFullPrevFrame = (prevFrameRect.x == 0 && prevFrameRect.y == 0 &&
     1:                           prevFrameRect.width == mSize.width &&
     1:                           prevFrameRect.height == mSize.height);
     1: 
  7671:   // Optimization: DisposeClearAll if the previous frame is the same size as
     1:   //               container and it's clearing itself
  7671:   if (isFullPrevFrame && 
 50553:       (prevFrameDisposalMethod == kDisposeClear))
 50553:     prevFrameDisposalMethod = kDisposeClearAll;
     1: 
108991:   int32_t nextFrameDisposalMethod = aNextFrame->GetFrameDisposalMethod();
 30479:   nsIntRect nextFrameRect = aNextFrame->GetRect();
 74143:   bool isFullNextFrame = (nextFrameRect.x == 0 && nextFrameRect.y == 0 &&
     1:                           nextFrameRect.width == mSize.width &&
     1:                           nextFrameRect.height == mSize.height);
     1: 
 30479:   if (!aNextFrame->GetIsPaletted()) {
  7671:     // Optimization: Skip compositing if the previous frame wants to clear the
  7671:     //               whole image
 50553:     if (prevFrameDisposalMethod == kDisposeClearAll) {
  7671:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
  7671:       return NS_OK;
  7671:     }
     1:   
     1:     // Optimization: Skip compositing if this frame is the same size as the
     1:     //               container and it's fully drawing over prev frame (no alpha)
     1:     if (isFullNextFrame &&
 50553:         (nextFrameDisposalMethod != kDisposeRestorePrevious) &&
 30479:         !aNextFrame->GetHasAlpha()) {
     1:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
     1:       return NS_OK;
     1:     }
  7671:   }
     1: 
     1:   // Calculate area that needs updating
     1:   switch (prevFrameDisposalMethod) {
     1:     default:
 50553:     case kDisposeNotSpecified:
 50553:     case kDisposeKeep:
     1:       *aDirtyRect = nextFrameRect;
     1:       break;
     1: 
 50553:     case kDisposeClearAll:
  7671:       // Whole image container is cleared
  7671:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
  7671:       break;
  7671: 
 50553:     case kDisposeClear:
     1:       // Calc area that needs to be redrawn (the combination of previous and
     1:       // this frame)
     1:       // XXX - This could be done with multiple framechanged calls
     1:       //       Having prevFrame way at the top of the image, and nextFrame
     1:       //       way at the bottom, and both frames being small, we'd be
     1:       //       telling framechanged to refresh the whole image when only two
     1:       //       small areas are needed.
     1:       aDirtyRect->UnionRect(nextFrameRect, prevFrameRect);
     1:       break;
     1: 
 50553:     case kDisposeRestorePrevious:
     1:       aDirtyRect->SetRect(0, 0, mSize.width, mSize.height);
     1:       break;
     1:   }
     1: 
     1:   // Optimization:
     1:   //   Skip compositing if the last composited frame is this frame
     1:   //   (Only one composited frame was made for this animation.  Example:
     1:   //    Only Frame 3 of a 10 frame image required us to build a composite frame
     1:   //    On the second loop, we do not need to rebuild the frame
     1:   //    since it's still sitting in compositingFrame)
     1:   if (mAnim->lastCompositedFrameIndex == aNextFrameIndex) {
     1:     return NS_OK;
     1:   }
     1: 
 74143:   bool needToBlankComposite = false;
     1: 
     1:   // Create the Compositing Frame
     1:   if (!mAnim->compositingFrame) {
 30479:     mAnim->compositingFrame = new imgFrame();
 30479:     nsresult rv = mAnim->compositingFrame->Init(0, 0, mSize.width, mSize.height,
 30479:                                                 gfxASurface::ImageFormatARGB32);
 35021:     if (NS_FAILED(rv)) {
106838:       mAnim->compositingFrame = nullptr;
 35021:       return rv;
 35021:     }
 74143:     needToBlankComposite = true;
 43684:   } else if (aNextFrameIndex != mAnim->lastCompositedFrameIndex+1) {
 43684: 
 52105:     // If we are not drawing on top of last composited frame, 
 52105:     // then we are building a new composite frame, so let's clear it first.
 74143:     needToBlankComposite = true;
     1:   }
     1: 
  7671:   // More optimizations possible when next frame is not transparent
 52105:   // But if the next frame has kDisposeRestorePrevious,
 52105:   // this "no disposal" optimization is not possible, 
 52105:   // because the frame in "after disposal operation" state 
 52105:   // needs to be stored in compositingFrame, so it can be 
 52105:   // copied into compositingPrevFrame later.
 74143:   bool doDisposal = true;
 52105:   if (!aNextFrame->GetHasAlpha() &&
 52105:       nextFrameDisposalMethod != kDisposeRestorePrevious) {
  7671:     if (isFullNextFrame) {
  7671:       // Optimization: No need to dispose prev.frame when 
  7671:       // next frame is full frame and not transparent.
 74143:       doDisposal = false;
  7671:       // No need to blank the composite frame
 74143:       needToBlankComposite = false;
     1:     } else {
  7671:       if ((prevFrameRect.x >= nextFrameRect.x) &&
  7671:           (prevFrameRect.y >= nextFrameRect.y) &&
  7671:           (prevFrameRect.x + prevFrameRect.width <= nextFrameRect.x + nextFrameRect.width) &&
  7671:           (prevFrameRect.y + prevFrameRect.height <= nextFrameRect.y + nextFrameRect.height)) {
  7671:         // Optimization: No need to dispose prev.frame when 
  7671:         // next frame fully overlaps previous frame.
 74143:         doDisposal = false;
  7671:       }
     1:     }      
     1:   }
     1: 
  7671:   if (doDisposal) {
  7671:     // Dispose of previous: clear, restore, or keep (copy)
     1:     switch (prevFrameDisposalMethod) {
 50553:       case kDisposeClear:
     1:         if (needToBlankComposite) {
     1:           // If we just created the composite, it could have anything in it's
  7671:           // buffer. Clear whole frame
  2200:           ClearFrame(mAnim->compositingFrame);
     1:         } else {
  7671:           // Only blank out previous frame area (both color & Mask/Alpha)
  2200:           ClearFrame(mAnim->compositingFrame, prevFrameRect);
     1:         }
     1:         break;
     1:   
 50553:       case kDisposeClearAll:
  7671:         ClearFrame(mAnim->compositingFrame);
  7671:         break;
  7671:   
 50553:       case kDisposeRestorePrevious:
     1:         // It would be better to copy only the area changed back to
     1:         // compositingFrame.
     1:         if (mAnim->compositingPrevFrame) {
     1:           CopyFrameImage(mAnim->compositingPrevFrame, mAnim->compositingFrame);
     1:   
     1:           // destroy only if we don't need it for this frame's disposal
 50553:           if (nextFrameDisposalMethod != kDisposeRestorePrevious)
106838:             mAnim->compositingPrevFrame = nullptr;
     1:         } else {
  2200:           ClearFrame(mAnim->compositingFrame);
     1:         }
     1:         break;
  7671:       
  7671:       default:
  7671:         // Copy previous frame into compositingFrame before we put the new frame on top
  7671:         // Assumes that the previous frame represents a full frame (it could be
  7671:         // smaller in size than the container, as long as the frame before it erased
  7671:         // itself)
  7671:         // Note: Frame 1 never gets into DoComposite(), so (aNextFrameIndex - 1) will
  7671:         // always be a valid frame number.
  7671:         if (mAnim->lastCompositedFrameIndex != aNextFrameIndex - 1) {
 32163:           if (isFullPrevFrame && !aPrevFrame->GetIsPaletted()) {
  7671:             // Just copy the bits
  7671:             CopyFrameImage(aPrevFrame, mAnim->compositingFrame);
  7671:           } else {
  7671:             if (needToBlankComposite) {
  7671:               // Only blank composite when prev is transparent or not full.
 30479:               if (aPrevFrame->GetHasAlpha() || !isFullPrevFrame) {
  7671:                 ClearFrame(mAnim->compositingFrame);
  7671:               }
  7671:             }
  7671:             DrawFrameTo(aPrevFrame, mAnim->compositingFrame, prevFrameRect);
  7671:           }
  7671:         }
 32163:     }
  7671:   } else if (needToBlankComposite) {
  7671:     // If we just created the composite, it could have anything in it's
  7671:     // buffers. Clear them
  7671:     ClearFrame(mAnim->compositingFrame);
     1:   }
     1: 
     1:   // Check if the frame we are composing wants the previous image restored afer
  7108:   // it is done. Don't store it (again) if last frame wanted its image restored
     1:   // too
 50553:   if ((nextFrameDisposalMethod == kDisposeRestorePrevious) &&
 50553:       (prevFrameDisposalMethod != kDisposeRestorePrevious)) {
     1:     // We are storing the whole image.
     1:     // It would be better if we just stored the area that nextFrame is going to
     1:     // overwrite.
     1:     if (!mAnim->compositingPrevFrame) {
 30479:       mAnim->compositingPrevFrame = new imgFrame();
 30479:       nsresult rv = mAnim->compositingPrevFrame->Init(0, 0, mSize.width, mSize.height,
 30479:                                                       gfxASurface::ImageFormatARGB32);
 35021:       if (NS_FAILED(rv)) {
106838:         mAnim->compositingPrevFrame = nullptr;
 35021:         return rv;
 35021:       }
 30479:     }
 30479: 
     1:     CopyFrameImage(mAnim->compositingFrame, mAnim->compositingPrevFrame);
     1:   }
     1: 
     1:   // blit next frame into it's correct spot
  5275:   DrawFrameTo(aNextFrame, mAnim->compositingFrame, nextFrameRect);
 30479: 
     1:   // Set timeout of CompositeFrame to timeout of frame we just composed
     1:   // Bug 177948
108991:   int32_t timeout = aNextFrame->GetTimeout();
     1:   mAnim->compositingFrame->SetTimeout(timeout);
     1: 
  7671:   // Tell the image that it is fully 'downloaded'.
 30479:   nsresult rv = mAnim->compositingFrame->ImageUpdated(mAnim->compositingFrame->GetRect());
 19117:   if (NS_FAILED(rv)) {
 19117:     return rv;
 19117:   }
  7671: 
 52105:   // We don't want to keep composite images for 8bit frames.
 52105:   // Also this optimization won't work if the next frame has 
 52105:   // kDisposeRestorePrevious, because it would need to be restored 
 52105:   // into "after prev disposal but before next blend" state, 
 52105:   // not into empty frame.
  7671:   if (isFullNextFrame && mAnimationMode == kNormalAnimMode && mLoopCount != 0 &&
 52105:       nextFrameDisposalMethod != kDisposeRestorePrevious &&
 30479:       !aNextFrame->GetIsPaletted()) {
     1:     // We have a composited full frame
     1:     // Store the composited frame into the mFrames[..] so we don't have to
     1:     // continuously re-build it
     1:     // Then set the previous frame's disposal to CLEAR_ALL so we just draw the
     1:     // frame next time around
     1:     if (CopyFrameImage(mAnim->compositingFrame, aNextFrame)) {
 50553:       aPrevFrame->SetFrameDisposalMethod(kDisposeClearAll);
     1:       mAnim->lastCompositedFrameIndex = -1;
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
     1:   mAnim->lastCompositedFrameIndex = aNextFrameIndex;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //******************************************************************************
  2200: // Fill aFrame with black. Does also clears the mask.
 50550: void
 50550: RasterImage::ClearFrame(imgFrame *aFrame)
     1: {
     1:   if (!aFrame)
     1:     return;
     1: 
 35020:   nsresult rv = aFrame->LockImageData();
 35020:   if (NS_FAILED(rv))
 35020:     return;
 30479: 
     1:   nsRefPtr<gfxASurface> surf;
 30479:   aFrame->GetSurface(getter_AddRefs(surf));
     1: 
  2200:   // Erase the surface to transparent
  2200:   gfxContext ctx(surf);
  2200:   ctx.SetOperator(gfxContext::OPERATOR_CLEAR);
  2200:   ctx.Paint();
 30479: 
 30479:   aFrame->UnlockImageData();
     1: }
     1: 
  2200: //******************************************************************************
 50550: void
 50550: RasterImage::ClearFrame(imgFrame *aFrame, nsIntRect &aRect)
  2200: {
 30479:   if (!aFrame || aRect.width <= 0 || aRect.height <= 0)
  2200:     return;
  2200: 
 35020:   nsresult rv = aFrame->LockImageData();
 35020:   if (NS_FAILED(rv))
 35020:     return;
 30479: 
  2200:   nsRefPtr<gfxASurface> surf;
 30479:   aFrame->GetSurface(getter_AddRefs(surf));
  2200: 
  2200:   // Erase the destination rectangle to transparent
  2200:   gfxContext ctx(surf);
  2200:   ctx.SetOperator(gfxContext::OPERATOR_CLEAR);
  2200:   ctx.Rectangle(gfxRect(aRect.x, aRect.y, aRect.width, aRect.height));
  2200:   ctx.Fill();
 30479: 
 30479:   aFrame->UnlockImageData();
  2200: }
  2200: 
     1: 
     1: //******************************************************************************
     1: // Whether we succeed or fail will not cause a crash, and there's not much
     1: // we can do about a failure, so there we don't return a nsresult
 79445: bool
 50550: RasterImage::CopyFrameImage(imgFrame *aSrcFrame,
 30479:                             imgFrame *aDstFrame)
     1: {
108991:   uint8_t* aDataSrc;
108991:   uint8_t* aDataDest;
108991:   uint32_t aDataLengthSrc;
108991:   uint32_t aDataLengthDest;
     1: 
     1:   if (!aSrcFrame || !aDstFrame)
 80486:     return false;
     1: 
115544:   AutoFrameLocker dstLock(aDstFrame);
115544:   AutoFrameLocker srcLock(aSrcFrame);
115544: 
115544:   if (!srcLock.Succeeded() || !dstLock.Succeeded()) {
 80486:     return false;
115544:   }
     1: 
     1:   // Copy Image Over
     1:   aSrcFrame->GetImageData(&aDataSrc, &aDataLengthSrc);
     1:   aDstFrame->GetImageData(&aDataDest, &aDataLengthDest);
     1:   if (!aDataDest || !aDataSrc || aDataLengthDest != aDataLengthSrc) {
 80486:     return false;
     1:   }
115544: 
     1:   memcpy(aDataDest, aDataSrc, aDataLengthSrc);
     1: 
 80486:   return true;
     1: }
  2663: 
  5275: //******************************************************************************
 10521: /* 
 10521:  * aSrc is the current frame being drawn,
 10521:  * aDst is the composition frame where the current frame is drawn into.
 10521:  * aSrcRect is the size of the current frame, and the position of that frame
 10521:  *          in the composition frame.
 10521:  */
 50550: nsresult
 50550: RasterImage::DrawFrameTo(imgFrame *aSrc,
 30479:                          imgFrame *aDst,
 10521:                          nsIntRect& aSrcRect)
  5275: {
 10521:   NS_ENSURE_ARG_POINTER(aSrc);
 10521:   NS_ENSURE_ARG_POINTER(aDst);
  5275: 
115544:   AutoFrameLocker srcLock(aSrc);
115544:   AutoFrameLocker dstLock(aDst);
115544: 
 30479:   nsIntRect dstRect = aDst->GetRect();
  7671: 
 10521:   // According to both AGIF and APNG specs, offsets are unsigned
 10521:   if (aSrcRect.x < 0 || aSrcRect.y < 0) {
 50549:     NS_WARNING("RasterImage::DrawFrameTo: negative offsets not allowed");
 10521:     return NS_ERROR_FAILURE;
 10521:   }
 10521:   // Outside the destination frame, skip it
 10521:   if ((aSrcRect.x > dstRect.width) || (aSrcRect.y > dstRect.height)) {
 10521:     return NS_OK;
 10521:   }
 30479: 
 30479:   if (aSrc->GetIsPaletted()) {
  8118:     // Larger than the destination frame, clip it
108991:     int32_t width = NS_MIN(aSrcRect.width, dstRect.width - aSrcRect.x);
108991:     int32_t height = NS_MIN(aSrcRect.height, dstRect.height - aSrcRect.y);
  8118: 
 10521:     // The clipped image must now fully fit within destination image frame
 10521:     NS_ASSERTION((aSrcRect.x >= 0) && (aSrcRect.y >= 0) &&
 10521:                  (aSrcRect.x + width <= dstRect.width) &&
 10521:                  (aSrcRect.y + height <= dstRect.height),
 50549:                 "RasterImage::DrawFrameTo: Invalid aSrcRect");
 10521: 
 10521:     // clipped image size may be smaller than source, but not larger
 10521:     NS_ASSERTION((width <= aSrcRect.width) && (height <= aSrcRect.height),
 50549:                  "RasterImage::DrawFrameTo: source must be smaller than dest");
  7671: 
115544:     if (!srcLock.Succeeded() || !dstLock.Succeeded())
  7671:       return NS_ERROR_FAILURE;
 30479: 
  7671:     // Get pointers to image data
108991:     uint32_t size;
108991:     uint8_t *srcPixels;
108991:     uint32_t *colormap;
108991:     uint32_t *dstPixels;
  7671: 
  7671:     aSrc->GetImageData(&srcPixels, &size);
 30479:     aSrc->GetPaletteData(&colormap, &size);
108991:     aDst->GetImageData((uint8_t **)&dstPixels, &size);
  7671:     if (!srcPixels || !dstPixels || !colormap) {
  7671:       return NS_ERROR_FAILURE;
  7671:     }
  7671: 
  7671:     // Skip to the right offset
 10521:     dstPixels += aSrcRect.x + (aSrcRect.y * dstRect.width);
 30479:     if (!aSrc->GetHasAlpha()) {
108991:       for (int32_t r = height; r > 0; --r) {
108991:         for (int32_t c = 0; c < width; c++) {
  9592:           dstPixels[c] = colormap[srcPixels[c]];
  7671:         }
  9592:         // Go to the next row in the source resp. destination image
 10521:         srcPixels += aSrcRect.width;
  9592:         dstPixels += dstRect.width;
  7671:       }
  7671:     } else {
108991:       for (int32_t r = height; r > 0; --r) {
108991:         for (int32_t c = 0; c < width; c++) {
108991:           const uint32_t color = colormap[srcPixels[c]];
  7671:           if (color)
  9592:             dstPixels[c] = color;
  7671:         }
  9592:         // Go to the next row in the source resp. destination image
 10521:         srcPixels += aSrcRect.width;
  9592:         dstPixels += dstRect.width;
  7671:       }
  7671:     }
 30479: 
  7671:     return NS_OK;
  7671:   }
  7671: 
 12652:   nsRefPtr<gfxPattern> srcPatt;
 30479:   aSrc->GetPattern(getter_AddRefs(srcPatt));
  5275: 
  5275:   nsRefPtr<gfxASurface> dstSurf;
 30479:   aDst->GetSurface(getter_AddRefs(dstSurf));
  5275: 
  5275:   gfxContext dst(dstSurf);
 10521:   dst.Translate(gfxPoint(aSrcRect.x, aSrcRect.y));
 80486:   dst.Rectangle(gfxRect(0, 0, aSrcRect.width, aSrcRect.height), true);
  7108:   
  7108:   // first clear the surface if the blend flag says so
108991:   int32_t blendMethod = aSrc->GetBlendMethod();
 50553:   if (blendMethod == kBlendSource) {
  7108:     gfxContext::GraphicsOperator defaultOperator = dst.CurrentOperator();
  7108:     dst.SetOperator(gfxContext::OPERATOR_CLEAR);
  7108:     dst.Fill();
 10521:     dst.SetOperator(defaultOperator);
  7108:   }
 12652:   dst.SetPattern(srcPatt);
  5275:   dst.Paint();
  5275: 
  5275:   return NS_OK;
  5275: }
  5275: 
  5275: 
  2663: /********* Methods to implement lazy allocation of nsIProperties object *************/
 50550: NS_IMETHODIMP
 50550: RasterImage::Get(const char *prop, const nsIID & iid, void * *result)
  2663: {
  2663:   if (!mProperties)
  2663:     return NS_ERROR_FAILURE;
  2663:   return mProperties->Get(prop, iid, result);
  2663: }
  2663: 
 50550: NS_IMETHODIMP
 50550: RasterImage::Set(const char *prop, nsISupports *value)
  2663: {
  2663:   if (!mProperties)
  2663:     mProperties = do_CreateInstance("@mozilla.org/properties;1");
  2663:   if (!mProperties)
  2663:     return NS_ERROR_OUT_OF_MEMORY;
  2663:   return mProperties->Set(prop, value);
  2663: }
  2663: 
 50550: NS_IMETHODIMP
 79445: RasterImage::Has(const char *prop, bool *_retval)
  2663: {
  2663:   NS_ENSURE_ARG_POINTER(_retval);
  2663:   if (!mProperties) {
 80486:     *_retval = false;
  2663:     return NS_OK;
  2663:   }
  2663:   return mProperties->Has(prop, _retval);
  2663: }
  2663: 
 50550: NS_IMETHODIMP
 50550: RasterImage::Undefine(const char *prop)
  2663: {
  2663:   if (!mProperties)
  2663:     return NS_ERROR_FAILURE;
  2663:   return mProperties->Undefine(prop);
  2663: }
  2663: 
 50550: NS_IMETHODIMP
108991: RasterImage::GetKeys(uint32_t *count, char ***keys)
  2663: {
  2663:   if (!mProperties) {
  2663:     *count = 0;
106838:     *keys = nullptr;
  2663:     return NS_OK;
  2663:   }
  2663:   return mProperties->GetKeys(count, keys);
  2663: }
  7009: 
 46991: void
 60418: RasterImage::Discard(bool force)
  7009: {
 32424:   // We should be ok for discard
 60418:   NS_ABORT_IF_FALSE(force ? CanForciblyDiscard() : CanDiscard(), "Asked to discard but can't!");
 32424: 
 32424:   // We should never discard when we have an active decoder
 46991:   NS_ABORT_IF_FALSE(!mDecoder, "Asked to discard with open decoder!");
 32424: 
 32424:   // As soon as an image becomes animated, it becomes non-discardable and any
 32424:   // timers are cancelled.
 46991:   NS_ABORT_IF_FALSE(!mAnim, "Asked to discard for animated image!");
 32424: 
 32424:   // For post-operation logging
 46991:   int old_frame_count = mFrames.Length();
  7009: 
 32424:   // Delete all the decoded frames, then clear the array.
 30479:   for (int i = 0; i < old_frame_count; ++i)
 46991:     delete mFrames[i];
 46991:   mFrames.Clear();
  7009: 
 32424:   // Flag that we no longer have decoded frames for this image
 80486:   mDecoded = false;
 32424: 
 32424:   // Notify that we discarded
 46991:   nsCOMPtr<imgIDecoderObserver> observer(do_QueryReferent(mObserver));
 32424:   if (observer)
118757:     observer->OnDiscard();
 32424: 
 91943:   if (force)
 60418:     DiscardTracker::Remove(&mDiscardTrackerNode);
 60418: 
 32424:   // Log
  7009:   PR_LOG(gCompressedImageAccountingLog, PR_LOG_DEBUG,
 32424:          ("CompressedImageAccounting: discarded uncompressed image "
 50549:           "data from RasterImage %p (%s) - %d frames (cached count: %d); "
 32424:           "Total Containers: %d, Discardable containers: %d, "
 32424:           "Total source bytes: %lld, Source bytes for discardable containers %lld",
 46991:           this,
 46991:           mSourceDataMimeType.get(),
  7009:           old_frame_count,
 46991:           mFrames.Length(),
 32424:           num_containers,
 32424:           num_discardable_containers,
 32424:           total_source_bytes,
 32424:           discardable_source_bytes));
  7009: }
  7009: 
 32424: // Helper method to determine if we can discard an image
 74943: bool
 50549: RasterImage::CanDiscard() {
 32424:   return (DiscardingEnabled() && // Globally enabled...
 32424:           mDiscardable &&        // ...Enabled at creation time...
 32424:           (mLockCount == 0) &&   // ...not temporarily disabled...
 32424:           mHasSourceData &&      // ...have the source data...
 32424:           mDecoded);             // ...and have something to discard.
 32424: }
 32424: 
 74943: bool
 60418: RasterImage::CanForciblyDiscard() {
 74211:   return mDiscardable &&         // ...Enabled at creation time...
 74211:          mHasSourceData;         // ...have the source data...
 60418: }
 60418: 
 46991: // Helper method to tell us whether the clock is currently running for
 46991: // discarding this image. Mainly for assertions.
 74943: bool
 50549: RasterImage::DiscardingActive() {
 93271:   return mDiscardTrackerNode.isInList();
 46991: }
 46991: 
 32424: // Helper method to determine if we're storing the source data in a buffer
 32424: // or just writing it directly to the decoder
 74943: bool
 90638: RasterImage::StoringSourceData() const {
 32424:   return (mDecodeOnDraw || mDiscardable);
 32424: }
 32424: 
 32424: 
 32424: // Sets up a decoder for this image. It is an error to call this function
 32424: // when decoding is already in process (ie - when mDecoder is non-null).
  7009: nsresult
 51244: RasterImage::InitDecoder(bool aDoSizeDecode)
  7009: {
 32424:   // Ensure that the decoder is not already initialized
 32424:   NS_ABORT_IF_FALSE(!mDecoder, "Calling InitDecoder() while already decoding!");
 32424:   
 32424:   // We shouldn't be firing up a decoder if we already have the frames decoded
 32424:   NS_ABORT_IF_FALSE(!mDecoded, "Calling InitDecoder() but already decoded!");
 32424: 
 32424:   // Since we're not decoded, we should not have a discard timer active
 46991:   NS_ABORT_IF_FALSE(!DiscardingActive(), "Discard Timer active in InitDecoder()!");
 32424: 
 51234:   // Figure out which decoder we want
 51234:   eDecoderType type = GetDecoderType(mSourceDataMimeType.get());
 51234:   CONTAINER_ENSURE_TRUE(type != eDecoderType_unknown, NS_IMAGELIB_ERROR_NO_DECODER);
 51234: 
 79414:   nsCOMPtr<imgIDecoderObserver> observer(do_QueryReferent(mObserver));
 51234:   // Instantiate the appropriate decoder
 51234:   switch (type) {
 51234:     case eDecoderType_png:
 80695:       mDecoder = new nsPNGDecoder(*this, observer);
 51234:       break;
 51234:     case eDecoderType_gif:
 80695:       mDecoder = new nsGIFDecoder2(*this, observer);
 51234:       break;
 51234:     case eDecoderType_jpeg:
 80695:       mDecoder = new nsJPEGDecoder(*this, observer);
 51234:       break;
 51234:     case eDecoderType_bmp:
 80695:       mDecoder = new nsBMPDecoder(*this, observer);
 51234:       break;
 51234:     case eDecoderType_ico:
 80695:       mDecoder = new nsICODecoder(*this, observer);
 51234:       break;
 51234:     case eDecoderType_icon:
 80695:       mDecoder = new nsIconDecoder(*this, observer);
 51234:       break;
 51234:     default:
 51234:       NS_ABORT_IF_FALSE(0, "Shouldn't get here!");
 51234:   }
 51215: 
 32424:   // Initialize the decoder
 51244:   mDecoder->SetSizeDecode(aDoSizeDecode);
 60418:   mDecoder->SetDecodeFlags(mFrameDecodeFlags);
 79414:   mDecoder->Init();
 53672:   CONTAINER_ENSURE_SUCCESS(mDecoder->GetDecoderError());
 32424: 
 78068:   if (!aDoSizeDecode) {
 78068:     Telemetry::GetHistogramById(Telemetry::IMAGE_DECODE_COUNT)->Subtract(mDecodeCount);
 78068:     mDecodeCount++;
 78068:     Telemetry::GetHistogramById(Telemetry::IMAGE_DECODE_COUNT)->Add(mDecodeCount);
 78068:   }
  7009: 
  7009:   return NS_OK;
  7009: }
  7009: 
 32424: // Flushes, closes, and nulls-out a decoder. Cleans up any related decoding
 32424: // state. It is an error to call this function when there is no initialized
 32424: // decoder.
 32424: // 
 32424: // aIntent specifies the intent of the shutdown. If aIntent is
 32424: // eShutdownIntent_Done, an error is flagged if we didn't get what we should
 32424: // have out of the decode. If aIntent is eShutdownIntent_Interrupted, we don't
 32424: // check this. If aIntent is eShutdownIntent_Error, we shut down in error mode.
 32424: nsresult
 50549: RasterImage::ShutdownDecoder(eShutdownIntent aIntent)
 32424: {
 32424:   // Ensure that our intent is valid
 32424:   NS_ABORT_IF_FALSE((aIntent >= 0) || (aIntent < eShutdownIntent_AllCount),
 32424:                     "Invalid shutdown intent");
 32424: 
 32424:   // Ensure that the decoder is initialized
 32424:   NS_ABORT_IF_FALSE(mDecoder, "Calling ShutdownDecoder() with no active decoder!");
 32424: 
 51244:   // Figure out what kind of decode we were doing before we get rid of our decoder
 51244:   bool wasSizeDecode = mDecoder->IsSizeDecode();
 51244: 
 53671:   // Finalize the decoder
 69680:   // null out mDecoder, _then_ check for errors on the close (otherwise the
 69680:   // error routine might re-invoke ShutdownDecoder)
 69680:   nsRefPtr<Decoder> decoder = mDecoder;
106838:   mDecoder = nullptr;
 69680: 
114209:   mFinishing = true;
 80486:   mInDecoder = true;
 69680:   decoder->Finish();
 80486:   mInDecoder = false;
114209:   mFinishing = false;
 32424: 
 89821:   // Kill off our decode request, if it's pending.  (If not, this call is
 89821:   // harmless.)
 89821:   DecodeWorker::Singleton()->StopDecoding(this);
 89821: 
 69680:   nsresult decoderStatus = decoder->GetDecoderError();
 53671:   if (NS_FAILED(decoderStatus)) {
 32424:     DoError();
 53671:     return decoderStatus;
 32424:   }
 32424: 
 32424:   // We just shut down the decoder. If we didn't get what we want, but expected
 32424:   // to, flag an error
 74143:   bool failed = false;
 51244:   if (wasSizeDecode && !mHasSize)
 74143:     failed = true;
 51244:   if (!wasSizeDecode && !mDecoded)
 74143:     failed = true;
 32424:   if ((aIntent == eShutdownIntent_Done) && failed) {
 32424:     DoError();
 32424:     return NS_ERROR_FAILURE;
 32424:   }
 32424: 
 32424:   // Reset number of decoded bytes
 32424:   mBytesDecoded = 0;
 32424: 
 32424:   return NS_OK;
 32424: }
 32424: 
 33898: // Writes the data to the decoder, updating the total number of bytes written.
 32424: nsresult
108991: RasterImage::WriteToDecoder(const char *aBuffer, uint32_t aCount)
 32424: {
 32424:   // We should have a decoder
 32424:   NS_ABORT_IF_FALSE(mDecoder, "Trying to write to null decoder!");
 32424: 
 38698:   // The decoder will start decoding into the current frame (if we have one).
 38698:   // When it needs to add another frame, we will unlock this frame and lock the
 38698:   // new frame.
 38698:   // Our invariant is that, while in the decoder, the last frame is always
 38698:   // locked, and all others are unlocked.
 38698:   if (mFrames.Length() > 0) {
 38698:     imgFrame *curframe = mFrames.ElementAt(mFrames.Length() - 1);
 38698:     curframe->LockImageData();
 38698:   }
 38698: 
 32424:   // Write
 69680:   nsRefPtr<Decoder> kungFuDeathGrip = mDecoder;
 80486:   mInDecoder = true;
 53672:   mDecoder->Write(aBuffer, aCount);
 80486:   mInDecoder = false;
 38698: 
 38698:   // We unlock the current frame, even if that frame is different from the
 38698:   // frame we entered the decoder with. (See above.)
 38698:   if (mFrames.Length() > 0) {
 38698:     imgFrame *curframe = mFrames.ElementAt(mFrames.Length() - 1);
 38698:     curframe->UnlockImageData();
 38698:   }
 38698: 
 81395:   if (!mDecoder)
 81395:     return NS_ERROR_FAILURE;
 81395:     
 81395:   CONTAINER_ENSURE_SUCCESS(mDecoder->GetDecoderError());
 81395: 
 32424:   // Keep track of the total number of bytes written over the lifetime of the
 32424:   // decoder
 32424:   mBytesDecoded += aCount;
 81395: 
 81395:   return NS_OK;
 32424: }
 32424: 
 32424: // This function is called in situations where it's clear that we want the
 32424: // frames in decoded form (Draw, GetFrame, CopyFrame, ExtractFrame, etc).
 32424: // If we're completely decoded, this method resets the discard timer (if
 32424: // we're discardable), since wanting the frames now is a good indicator of
 32424: // wanting them again soon. If we're not decoded, this method kicks off
 32424: // asynchronous decoding to generate the frames.
 32424: nsresult
 50549: RasterImage::WantDecodedFrames()
 32424: {
 32424:   nsresult rv;
 32424: 
 46991:   // If we can discard, the clock should be running. Reset it.
 32424:   if (CanDiscard()) {
 46991:     NS_ABORT_IF_FALSE(DiscardingActive(),
 46991:                       "Decoded and discardable but discarding not activated!");
 50547:     rv = DiscardTracker::Reset(&mDiscardTrackerNode);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 32424:   // Request a decode (no-op if we're decoded)
116146:   return StartDecoding();
 32424: }
 32424: 
 30479: //******************************************************************************
 32424: /* void requestDecode() */
 32424: NS_IMETHODIMP
 50549: RasterImage::RequestDecode()
 32424: {
116146:   return RequestDecodeCore(ASYNCHRONOUS);
116146: }
116146: 
116146: /* void startDecode() */
116146: NS_IMETHODIMP
116146: RasterImage::StartDecoding()
116146: {
116146:   return RequestDecodeCore(SOMEWHAT_SYNCHRONOUS);
116146: }
116146: 
116146: 
116146: NS_IMETHODIMP
116146: RasterImage::RequestDecodeCore(RequestDecodeType aDecodeType)
116146: {
 32424:   nsresult rv;
 32424: 
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 78659:   // If we're fully decoded, we have nothing to do
 78659:   if (mDecoded)
 78659:     return NS_OK;
 78659: 
 32424:   // If we're not storing source data, we have nothing to do
 32424:   if (!StoringSourceData())
 32424:     return NS_OK;
 32424: 
118794:   // If we've already got a full decoder running, we'll spend a bit of time
118794:   // decoding because the caller want's an image soon.
118794:   if (mDecoder && !mDecoder->IsSizeDecode()) {
118794:     if (!mDecoded && !mInDecoder && mHasSourceData && aDecodeType == SOMEWHAT_SYNCHRONOUS) {
118794:       SAMPLE_LABEL_PRINTF("RasterImage", "DecodeABitOf", "%s", GetURIString());
118794:       DecodeWorker::Singleton()->DecodeABitOf(this);
118794:     }
 32884:     return NS_OK;
118794:   }
 32884: 
114209:   // mFinishing protects against the case when we enter RequestDecode from
114209:   // ShutdownDecoder -- in that case, we're done with the decode, we're just
114209:   // not quite ready to admit it.  See bug 744309.
114209:   if (mFinishing)
114209:     return NS_OK;
114209: 
 51244:   // If our callstack goes through a size decoder, we have a problem.
 51244:   // We need to shutdown the size decode and replace it with  a full
 32884:   // decoder, but can't do that from within the decoder itself. Thus, we post
 32884:   // an asynchronous event to the event loop to do it later. Since
 32884:   // RequestDecode() is an asynchronous function this works fine (though it's
 32884:   // a little slower).
 32424:   if (mInDecoder) {
116145:     nsRefPtr<imgDecodeRequestor> requestor = new imgDecodeRequestor(*this);
 32424:     return NS_DispatchToCurrentThread(requestor);
 32424:   }
 32424: 
 32424: 
 60418:   // If we have a size decode open, interrupt it and shut it down; or if
 60418:   // the decoder has different flags than what we need
 60418:   if (mDecoder &&
 60418:       (mDecoder->IsSizeDecode() || mDecoder->GetDecodeFlags() != mFrameDecodeFlags))
 60418:   {
 32424:     rv = ShutdownDecoder(eShutdownIntent_Interrupted);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 32424:   // If we don't have a decoder, create one 
 32424:   if (!mDecoder) {
 32424:     NS_ABORT_IF_FALSE(mFrames.IsEmpty(), "Trying to decode to non-empty frame-array");
 51244:     rv = InitDecoder(/* aDoSizeDecode = */ false);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 32424:   // If we've read all the data we have, we're done
 32424:   if (mBytesDecoded == mSourceData.Length())
 32424:     return NS_OK;
 32424: 
108319:   // If we can do decoding now, do so.  Small images will decode completely,
108319:   // large images will decode a bit and post themselves to the event loop
108319:   // to finish decoding.
116146:   if (!mDecoded && !mInDecoder && mHasSourceData && aDecodeType == SOMEWHAT_SYNCHRONOUS) {
115990:     SAMPLE_LABEL_PRINTF("RasterImage", "DecodeABitOf", "%s", GetURIString());
108319:     DecodeWorker::Singleton()->DecodeABitOf(this);
108319:     return NS_OK;
108319:   }
 80141: 
 80141:   // If we get this far, dispatch the worker. We do this instead of starting
 80141:   // any immediate decoding to guarantee that all our decode notifications are
 80141:   // dispatched asynchronously, and to ensure we stay responsive.
 89821:   DecodeWorker::Singleton()->RequestDecode(this);
 89821: 
 89821:   return NS_OK;
 32424: }
 32424: 
 32424: // Synchronously decodes as much data as possible
 32424: nsresult
 50549: RasterImage::SyncDecode()
 32424: {
 32424:   nsresult rv;
 32424: 
115990:   SAMPLE_LABEL_PRINTF("RasterImage", "SyncDecode", "%s", GetURIString());;
115990: 
 32424:   // If we're decoded already, no worries
 32424:   if (mDecoded)
 32424:     return NS_OK;
 32424: 
 32424:   // If we're not storing source data, there isn't much to do here
 32424:   if (!StoringSourceData())
 32424:     return NS_OK;
 32424: 
 32424:   // We really have no good way of forcing a synchronous decode if we're being
 32424:   // called in a re-entrant manner (ie, from an event listener fired by a
 48223:   // decoder), because the decoding machinery is already tied up. We thus explicitly
 48223:   // disallow this type of call in the API, and check for it in API methods.
 32424:   NS_ABORT_IF_FALSE(!mInDecoder, "Yikes, forcing sync in reentrant call!");
 32424: 
 60418:   // If we have a size decoder open, or one with different flags than
 60418:   // what we need, shut it down
 60418:   if (mDecoder &&
 60418:       (mDecoder->IsSizeDecode() || mDecoder->GetDecodeFlags() != mFrameDecodeFlags))
 60418:   {
 32424:     rv = ShutdownDecoder(eShutdownIntent_Interrupted);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 32424:   // If we don't have a decoder, create one 
 32424:   if (!mDecoder) {
 32424:     NS_ABORT_IF_FALSE(mFrames.IsEmpty(), "Trying to decode to non-empty frame-array");
 51244:     rv = InitDecoder(/* aDoSizeDecode = */ false);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 32424:   // Write everything we have
 32424:   rv = WriteToDecoder(mSourceData.Elements() + mBytesDecoded,
 32424:                       mSourceData.Length() - mBytesDecoded);
 32424:   CONTAINER_ENSURE_SUCCESS(rv);
 32424: 
 51593:   // When we're doing a sync decode, we want to get as much information from the
 51593:   // image as possible. We've send the decoder all of our data, so now's a good
 51593:   // time  to flush any invalidations (in case we don't have all the data and what
 51593:   // we got left us mid-frame).
 69680:   nsRefPtr<Decoder> kungFuDeathGrip = mDecoder;
 80486:   mInDecoder = true;
 51593:   mDecoder->FlushInvalidations();
 80486:   mInDecoder = false;
 51593: 
 32424:   // If we finished the decode, shutdown the decoder
 69680:   if (mDecoder && IsDecodeFinished()) {
 32424:     rv = ShutdownDecoder(eShutdownIntent_Done);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
 69680:   // All good if no errors!
 69680:   return mError ? NS_ERROR_FAILURE : NS_OK;
 32424: }
 32424: 
115644: /* static */ RasterImage::ScaleWorker*
115644: RasterImage::ScaleWorker::Singleton()
115644: {
115644:   if (!sSingleton) {
115644:     sSingleton = new ScaleWorker();
115644:     ClearOnShutdown(&sSingleton);
115644:   }
115644: 
115644:   return sSingleton;
115644: }
115644: 
115644: nsresult
115644: RasterImage::ScaleWorker::Run()
115644: {
115644:   if (!mInitialized) {
115644:     PR_SetCurrentThreadName("Image Scaler");
115644:     mInitialized = true;
115644:   }
115644: 
115644:   ScaleRequest* request;
115644:   {
115644:     MutexAutoLock lock(ScaleWorker::Singleton()->mRequestsMutex);
115644:     request = mScaleRequests.popFirst();
115644:   }
115644: 
119204:   request->done = mozilla::gfx::Scale(request->srcData, request->srcRect.width, request->srcRect.height, request->srcStride,
119204:                                       request->dstData, request->dstSize.width, request->dstSize.height, request->dstStride,
119204:                                       request->srcFormat);
115644: 
115644:   // OK, we've got a new scaled image. Let's get the main thread to unlock and
115644:   // redraw it.
119204:   DrawWorker::Singleton()->RequestDraw(request);
119204: 
115644:   return NS_OK;
115644: }
115644: 
115644: // Note: you MUST call RequestScale with the ScaleWorker mutex held.
119204: bool
119204: RasterImage::ScaleWorker::RequestScale(ScaleRequest* request,
119204:                                        RasterImage* image,
119204:                                        imgFrame* aSrcFrame)
115644: {
115644:   mRequestsMutex.AssertCurrentThreadOwns();
115644: 
119204:   // Destination is unconditionally ARGB32 because that's what the scaler
119204:   // outputs.
119204:   request->dstFrame = new imgFrame();
119204:   nsresult rv = request->dstFrame->Init(0, 0, request->dstSize.width, request->dstSize.height,
119204:                                         gfxASurface::ImageFormatARGB32);
119204: 
119204:   if (NS_FAILED(rv) || !request->GetSurfaces(aSrcFrame)) {
119204:     return false;
119204:   }
115644: 
115644:   mScaleRequests.insertBack(request);
115644: 
115644:   if (!sScaleWorkerThread) {
115644:     NS_NewThread(getter_AddRefs(sScaleWorkerThread), this, NS_DISPATCH_NORMAL);
115644:     ClearOnShutdown(&sScaleWorkerThread);
115644:   }
115644:   else {
115644:     sScaleWorkerThread->Dispatch(this, NS_DISPATCH_NORMAL);
115644:   }
119204: 
119204:   image->SetResultPending(request);
119204: 
119204:   return true;
115644: }
115644: 
115644: /* static */ RasterImage::DrawWorker*
115644: RasterImage::DrawWorker::Singleton()
115644: {
115644:   if (!sSingleton) {
115644:     sSingleton = new DrawWorker();
115644:     ClearOnShutdown(&sSingleton);
115644:   }
115644: 
115644:   return sSingleton;
115644: }
115644: 
115644: nsresult
115644: RasterImage::DrawWorker::Run()
115644: {
115644:   ScaleRequest* request;
115644:   {
115644:     MutexAutoLock lock(ScaleWorker::Singleton()->mRequestsMutex);
115644:     request = mDrawRequests.popFirst();
115644:   }
119204: 
115644:   // ScaleWorker is finished with this request, so we can unlock the data now.
119204:   request->ReleaseSurfaces();
119204: 
119204:   // Only set the scale result if the request finished successfully.
119204:   if (request->done) {
119204:     RasterImage* image = request->weakImage;
119204:     if (image) {
119204:       nsCOMPtr<imgIContainerObserver> observer(do_QueryReferent(image->mObserver));
119204:       if (observer) {
115644:         imgFrame *scaledFrame = request->dstFrame.get();
115644:         scaledFrame->ImageUpdated(scaledFrame->GetRect());
119204:         observer->FrameChanged(&request->srcRect);
115644:       }
119204: 
119204:       image->SetScaleResult(request);
115644:     }
119204:   }
119204: 
119204:   // Scaling failed. Reset the scale result on our image.
119204:   else {
119204:     RasterImage* image = request->weakImage;
119204:     if (image) {
119204:       image->SetScaleResult(nullptr);
119204:     }
119204:   }
119204: 
119204:   // We're all done with this ScaleRequest; now it dies.
119204:   delete request;
115644: 
115644:   return NS_OK;
115644: }
115644: 
115644: void
119204: RasterImage::DrawWorker::RequestDraw(ScaleRequest* request)
115644: {
119204:   MutexAutoLock lock(ScaleWorker::Singleton()->mRequestsMutex);
115644:   mDrawRequests.insertBack(request);
115644:   NS_DispatchToMainThread(this, NS_DISPATCH_NORMAL);
115644: }
115644: 
115965: static inline bool
115965: IsDownscale(const gfxSize& scale)
115965: {
115965:   if (scale.width > 1.0)
115965:     return false;
115965:   if (scale.height > 1.0)
115965:     return false;
115965:   if (scale.width == 1.0 && scale.height == 1.0)
115965:     return false;
115965: 
115965:   return true;
115965: }
115965: 
115644: bool
115644: RasterImage::CanScale(gfxPattern::GraphicsFilter aFilter,
115644:                       gfxSize aScale)
115644: {
115644: // The high-quality scaler requires Skia.
115644: #ifdef MOZ_ENABLE_SKIA
115645:   if (gHQDownscaling && aFilter == gfxPattern::FILTER_GOOD &&
115965:       !mAnim && mDecoded && IsDownscale(aScale)) {
115645:     gfxFloat factor = gHQDownscalingMinFactor / 1000.0;
115645:     return (aScale.width < factor || aScale.height < factor);
115645:   }
115645: #endif
115645: 
115644:   return false;
115644: }
115644: 
115644: void
119204: RasterImage::SetScaleResult(ScaleRequest* request)
119204: {
119204:   if (request) {
119204:     MOZ_ASSERT(request->done);
119204:     mScaleResult.status = SCALE_DONE;
119204:     mScaleResult.frame = request->dstFrame;
119204:     mScaleResult.scale = request->scale;
119204:   } else {
119204:     mScaleResult.status = SCALE_INVALID;
119204:     mScaleResult.frame = nullptr;
119204:   }
119204: }
119204: 
119204: void
119204: RasterImage::SetResultPending(ScaleRequest* request)
119204: {
119204:   MOZ_ASSERT(request);
119204:   mScaleResult.scale = request->scale;
119204:   mScaleResult.status = SCALE_PENDING;
119204: }
119204: 
119204: void
115644: RasterImage::DrawWithPreDownscaleIfNeeded(imgFrame *aFrame,
115644:                                           gfxContext *aContext,
115644:                                           gfxPattern::GraphicsFilter aFilter,
115644:                                           const gfxMatrix &aUserSpaceToImageSpace,
115644:                                           const gfxRect &aFill,
115644:                                           const nsIntRect &aSubimage)
115644: {
115644:   imgFrame *frame = aFrame;
115644:   nsIntRect framerect = frame->GetRect();
115644:   gfxMatrix userSpaceToImageSpace = aUserSpaceToImageSpace;
115644:   gfxMatrix imageSpaceToUserSpace = aUserSpaceToImageSpace;
115644:   imageSpaceToUserSpace.Invert();
115644:   gfxSize scale = imageSpaceToUserSpace.ScaleFactors(true);
115644:   nsIntRect subimage = aSubimage;
115644: 
115644:   if (CanScale(aFilter, scale)) {
115644:     MutexAutoLock lock(ScaleWorker::Singleton()->mRequestsMutex);
115644:     // If scale factor is still the same that we scaled for and
119204:     // ScaleWorker isn't still working, then we can use pre-downscaled frame.
115644:     // If scale factor has changed, order new request.
119204:     // FIXME: Current implementation doesn't support pre-downscale
119204:     // mechanism for multiple sizes from same src, since we cache
119204:     // pre-downscaled frame only for the latest requested scale.
119204:     // The solution is to cache more than one scaled image frame
119204:     // for each RasterImage.
119204:     if (mScaleResult.status == SCALE_DONE && mScaleResult.scale == scale) {
119204:       frame = mScaleResult.frame;
115644:       userSpaceToImageSpace.Multiply(gfxMatrix().Scale(scale.width, scale.height));
115644: 
115644:       // Since we're switching to a scaled image, we we need to transform the
115644:       // area of the subimage to draw accordingly, since imgFrame::Draw()
115644:       // doesn't know about scaled frames.
115644:       subimage.ScaleRoundOut(scale.width, scale.height);
115644:     }
119204: 
119204:     // If we're not waiting for exactly this result, ask for it.
119204:     else if (!(mScaleResult.status == SCALE_PENDING && mScaleResult.scale == scale)) {
119204:       ScaleRequest* request = new ScaleRequest(this, scale, frame);
119204: 
119204:       if (!ScaleWorker::Singleton()->RequestScale(request, this, frame)) {
119204:         // Requesting a scale failed. Not much we can do.
119204:         delete request;
115644:       }
115644:     }
115644:   }
115644: 
115644:   nsIntMargin padding(framerect.x, framerect.y,
115644:                       mSize.width - framerect.XMost(),
115644:                       mSize.height - framerect.YMost());
115644: 
115644:   frame->Draw(aContext, aFilter, userSpaceToImageSpace, aFill, padding, subimage);
115644: }
115644: 
 32424: //******************************************************************************
 47231: /* [noscript] void draw(in gfxContext aContext,
 47231:  *                      in gfxGraphicsFilter aFilter,
 47231:  *                      [const] in gfxMatrix aUserSpaceToImageSpace,
 47231:  *                      [const] in gfxRect aFill,
 47231:  *                      [const] in nsIntRect aSubimage,
 52215:  *                      [const] in nsIntSize aViewportSize,
108991:  *                      in uint32_t aFlags); */
 50550: NS_IMETHODIMP
 50550: RasterImage::Draw(gfxContext *aContext,
 47231:                   gfxPattern::GraphicsFilter aFilter,
 47231:                   const gfxMatrix &aUserSpaceToImageSpace,
 47231:                   const gfxRect &aFill,
 47231:                   const nsIntRect &aSubimage,
 52215:                   const nsIntSize& /*aViewportSize - ignored*/,
108991:                   uint32_t aFlags)
 30479: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 48223:   // Disallowed in the API
 48223:   if (mInDecoder && (aFlags & imgIContainer::FLAG_SYNC_DECODE))
 48223:     return NS_ERROR_FAILURE;
 48223: 
 60418:   // Illegal -- you can't draw with non-default decode flags.
 60418:   // (Disabling colorspace conversion might make sense to allow, but
 60418:   // we don't currently.)
 60418:   if ((aFlags & DECODE_FLAGS_MASK) != DECODE_FLAGS_DEFAULT)
 60418:     return NS_ERROR_FAILURE;
 60418: 
 30479:   NS_ENSURE_ARG_POINTER(aContext);
 30479: 
 60418:   // We can only draw with the default decode flags
 60418:   if (mFrameDecodeFlags != DECODE_FLAGS_DEFAULT) {
 60418:     if (!CanForciblyDiscard())
 60418:       return NS_ERROR_NOT_AVAILABLE;
 60418:     ForceDiscard();
 60418: 
 60418:     mFrameDecodeFlags = DECODE_FLAGS_DEFAULT;
 60418:   }
 60418: 
 91841:   // If this image is a candidate for discarding, reset its position in the
 91841:   // discard tracker so we're less likely to discard it right away.
 91841:   //
 91841:   // (We don't normally draw unlocked images, so this conditition will usually
 91841:   // be false.  But we will draw unlocked images if image locking is globally
 91841:   // disabled via the content.image.allow_locking pref.)
 91841:   if (DiscardingActive()) {
 91841:     DiscardTracker::Reset(&mDiscardTrackerNode);
 91841:   }
 91841: 
 86634:   // We use !mDecoded && mHasSourceData to mean discarded.
 86634:   if (!mDecoded && mHasSourceData) {
 75292:       mDrawStartTime = TimeStamp::Now();
 89821: 
 89821:       // We're drawing this image, so indicate that we should decode it as soon
 89821:       // as possible.
 89821:       DecodeWorker::Singleton()->MarkAsASAP(this);
 75292:   }
 75292: 
 32424:   // If a synchronous draw is requested, flush anything that might be sitting around
 32424:   if (aFlags & FLAG_SYNC_DECODE) {
 32424:     nsresult rv = SyncDecode();
 32424:     NS_ENSURE_SUCCESS(rv, rv);
 32424:   }
 32424: 
 34809:   imgFrame *frame = GetCurrentDrawableImgFrame();
 32424:   if (!frame) {
 32424:     return NS_OK; // Getting the frame (above) touches the image and kicks off decoding
 32424:   }
 30479: 
115644:   DrawWithPreDownscaleIfNeeded(frame, aContext, aFilter, aUserSpaceToImageSpace, aFill, aSubimage);
 30479: 
 75292:   if (mDecoded && !mDrawStartTime.IsNull()) {
 75292:       TimeDuration drawLatency = TimeStamp::Now() - mDrawStartTime;
108991:       Telemetry::Accumulate(Telemetry::IMAGE_DECODE_ON_DRAW_LATENCY, int32_t(drawLatency.ToMicroseconds()));
 75292:       // clear the value of mDrawStartTime
 75292:       mDrawStartTime = TimeStamp();
 75292:   }
115644: 
 30479:   return NS_OK;
 30479: }
 30479: 
 32424: //******************************************************************************
 52204: /* [notxpcom] nsIFrame GetRootLayoutFrame() */
 52204: nsIFrame*
 52204: RasterImage::GetRootLayoutFrame()
 52204: {
106838:   return nullptr;
 52204: }
 52204: 
 52204: //******************************************************************************
 32424: /* void lockImage() */
 32424: NS_IMETHODIMP
 50549: RasterImage::LockImage()
  7009: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   // Cancel the discard timer if it's there
 50547:   DiscardTracker::Remove(&mDiscardTrackerNode);
  7009: 
 32424:   // Increment the lock count
 32424:   mLockCount++;
 32424: 
  7009:   return NS_OK;
  7009: }
  7009: 
 32424: //******************************************************************************
 32424: /* void unlockImage() */
  7009: NS_IMETHODIMP
 50549: RasterImage::UnlockImage()
  7009: {
 32424:   if (mError)
 32424:     return NS_ERROR_FAILURE;
 32424: 
 32424:   // It's an error to call this function if the lock count is 0
 32424:   NS_ABORT_IF_FALSE(mLockCount > 0,
 32424:                     "Calling UnlockImage with mLockCount == 0!");
 32424:   if (mLockCount == 0)
 32424:     return NS_ERROR_ABORT;
 32424: 
 46991:   // We're locked, so discarding should not be active
 46991:   NS_ABORT_IF_FALSE(!DiscardingActive(), "Locked, but discarding activated");
 32424: 
 32424:   // Decrement our lock count
 32424:   mLockCount--;
 32424: 
 74211:   // If we've decoded this image once before, we're currently decoding again,
 74211:   // and our lock count is now zero (so nothing is forcing us to keep the
 74211:   // decoded data around), try to cancel the decode and throw away whatever
 74211:   // we've decoded.
 74211:   if (mHasBeenDecoded && mDecoder &&
 74211:       mLockCount == 0 && CanForciblyDiscard()) {
 74211:     PR_LOG(gCompressedImageAccountingLog, PR_LOG_DEBUG,
 74211:            ("RasterImage[0x%p] canceling decode because image "
 74211:             "is now unlocked.", this));
 74211:     ShutdownDecoder(eShutdownIntent_Interrupted);
 74211:     ForceDiscard();
 74211:     return NS_OK;
 74211:   }
 74211: 
 74211:   // Otherwise, we might still be a candidate for discarding in the future.  If
 74211:   // we are, add ourselves to the discard tracker.
 32424:   if (CanDiscard()) {
 50547:     nsresult rv = DiscardTracker::Reset(&mDiscardTrackerNode);
 32424:     CONTAINER_ENSURE_SUCCESS(rv);
 32424:   }
 32424: 
  7009:   return NS_OK;
  7009: }
  7009: 
 91981: //******************************************************************************
 91981: /* void requestDiscard() */
 91981: NS_IMETHODIMP
 91981: RasterImage::RequestDiscard()
 91981: {
 91981:   if (CanDiscard()) {
 91981:     ForceDiscard();
 91981:   }
 91981: 
 91981:   return NS_OK;
 91981: }
 91981: 
 32424: // Flushes up to aMaxBytes to the decoder.
 32424: nsresult
108991: RasterImage::DecodeSomeData(uint32_t aMaxBytes)
  7009: {
 32424:   // We should have a decoder if we get here
 32424:   NS_ABORT_IF_FALSE(mDecoder, "trying to decode without decoder!");
 32424: 
 32424:   // If we have nothing to decode, return
 32424:   if (mBytesDecoded == mSourceData.Length())
 32424:     return NS_OK;
 32424: 
 32424: 
 32424:   // write the proper amount of data
108991:   uint32_t bytesToDecode = NS_MIN(aMaxBytes,
 32424:                                   mSourceData.Length() - mBytesDecoded);
 32424:   nsresult rv = WriteToDecoder(mSourceData.Elements() + mBytesDecoded,
 32424:                                bytesToDecode);
 32424: 
 32424:   return rv;
 32424: }
 32424: 
 32424: // There are various indicators that tell us we're finished with the decode
 32424: // task at hand and can shut down the decoder.
 51243: //
 51243: // This method may not be called if there is no decoder.
 79445: bool
 50550: RasterImage::IsDecodeFinished()
 32424: {
 51243:   // Precondition
 51243:   NS_ABORT_IF_FALSE(mDecoder, "Can't call IsDecodeFinished() without decoder!");
 51243: 
 32424:   // Assume it's not finished
 79445:   bool decodeFinished = false;
 32424: 
 32424:   // There shouldn't be any reason to call this if we're not storing
 32424:   // source data
 32424:   NS_ABORT_IF_FALSE(StoringSourceData(),
 32424:                     "just shut down on SourceDataComplete!");
 32424: 
 32424:   // The decode is complete if we got what we wanted...
 51244:   if (mDecoder->IsSizeDecode()) {
 32424:     if (mHasSize)
 80486:       decodeFinished = true;
 32424:   }
 32424:   else {
 32424:     if (mDecoded)
 80486:       decodeFinished = true;
 32424:   }
 32424: 
 32424:   // ...or if we have all the source data and wrote all the source data.
 32424:   //
 32424:   // (NB - This can be distinct from the above case even for non-erroneous
 32424:   // images because the decoder might not call DecodingComplete() until we
 32424:   // call Close() in ShutdownDecoder())
 32424:   if (mHasSourceData && (mBytesDecoded == mSourceData.Length()))
 80486:     decodeFinished = true;
 32424: 
 32424:   return decodeFinished;
 32424: }
 32424: 
 53671: // Indempotent error flagging routine. If a decoder is open, shuts it down.
 50550: void
 50550: RasterImage::DoError()
 32424: {
 32424:   // If we've flagged an error before, we have nothing to do
 32424:   if (mError)
 32424:     return;
 32424: 
 53671:   // If we're mid-decode, shut down the decoder.
 53671:   if (mDecoder)
 53671:     ShutdownDecoder(eShutdownIntent_Error);
 32424: 
 32424:   // Put the container in an error state
 80486:   mError = true;
 32424: 
 32424:   // Log our error
 32424:   LOG_CONTAINER_ERROR;
 32424: }
 32424: 
 32424: // nsIInputStream callback to copy the incoming image data directly to the
 50556: // RasterImage without processing. The RasterImage is passed as the closure.
 32424: // Always reads everything it gets, even if the data is erroneous.
 32424: NS_METHOD
 50556: RasterImage::WriteToRasterImage(nsIInputStream* /* unused */,
 50556:                                 void*          aClosure,
 50556:                                 const char*    aFromRawSegment,
108991:                                 uint32_t       /* unused */,
108991:                                 uint32_t       aCount,
108991:                                 uint32_t*      aWriteCount)
 32424: {
 50549:   // Retrieve the RasterImage
 50556:   RasterImage* image = static_cast<RasterImage*>(aClosure);
 32424: 
 71472:   // Copy the source data. Unless we hit OOM, we squelch the return value
 71472:   // here, because returning an error means that ReadSegments stops
 71472:   // reading data, violating our invariant that we read everything we get.
 71472:   // If we hit OOM then we fail and the load is aborted.
 71472:   nsresult rv = image->AddSourceData(aFromRawSegment, aCount);
 71472:   if (rv == NS_ERROR_OUT_OF_MEMORY) {
 71472:     image->DoError();
 71472:     return rv;
 71472:   }
 32424: 
 32424:   // We wrote everything we got
 50556:   *aWriteCount = aCount;
 32424: 
  7009:   return NS_OK;
  7009: }
 50549: 
 74943: bool
 52149: RasterImage::ShouldAnimate()
 52149: {
 52149:   return Image::ShouldAnimate() && mFrames.Length() >= 2 &&
 57656:          !mAnimationFinished;
 52149: }
 52149: 
108991: /* readonly attribute uint32_t framesNotified; */
 52150: #ifdef DEBUG
 52150: NS_IMETHODIMP
108991: RasterImage::GetFramesNotified(uint32_t *aFramesNotified)
 52150: {
 52150:   NS_ENSURE_ARG_POINTER(aFramesNotified);
 52150: 
 52150:   *aFramesNotified = mFramesNotified;
 52150: 
 52150:   return NS_OK;
 52150: }
 52150: #endif
 52150: 
 89821: /* static */ RasterImage::DecodeWorker*
 89821: RasterImage::DecodeWorker::Singleton()
 89821: {
 89821:   if (!sSingleton) {
 89821:     sSingleton = new DecodeWorker();
 89821:     ClearOnShutdown(&sSingleton);
 89821:   }
 89821: 
 89821:   return sSingleton;
 89821: }
 89821: 
 89821: void
 89821: RasterImage::DecodeWorker::MarkAsASAP(RasterImage* aImg)
 89821: {
 89821:   DecodeRequest* request = &aImg->mDecodeRequest;
 89821: 
 89821:   // If we're already an ASAP request, there's nothing to do here.
 89821:   if (request->mIsASAP) {
 89821:     return;
 89821:   }
 89821: 
 89821:   request->mIsASAP = true;
 89821: 
 89821:   if (request->isInList()) {
 89821:     // If the decode request is in a list, it must be in the normal decode
 89821:     // requests list -- if it had been in the ASAP list, then mIsASAP would
 89821:     // have been true above.  Move the request to the ASAP list.
 89821:     request->remove();
 89821:     mASAPDecodeRequests.insertBack(request);
 89821: 
 89821:     // Since request is in a list, one of the decode worker's lists is
 89821:     // non-empty, so the worker should be pending in the event loop.
 89821:     //
 89821:     // (Note that this invariant only holds while we are not in Run(), because
 89821:     // DecodeSomeOfImage adds requests to the decode worker using
 89821:     // AddDecodeRequest, not RequestDecode, and AddDecodeRequest does not call
 89821:     // EnsurePendingInEventLoop.  Therefore, it is an error to call MarkAsASAP
 89821:     // from within DecodeWorker::Run.)
 89821:     MOZ_ASSERT(mPendingInEventLoop);
 89821:   }
 89821: }
 89821: 
 89821: void
 89821: RasterImage::DecodeWorker::AddDecodeRequest(DecodeRequest* aRequest)
 89821: {
 89821:   if (aRequest->isInList()) {
 89821:     // The image is already in our list of images to decode, so we don't have
 89821:     // to do anything here.
 89821:     return;
 89821:   }
 89821: 
 89821:   if (aRequest->mIsASAP) {
 89821:     mASAPDecodeRequests.insertBack(aRequest);
 89821:   } else {
 89821:     mNormalDecodeRequests.insertBack(aRequest);
 89821:   }
 89821: }
 89821: 
 89821: void
 89821: RasterImage::DecodeWorker::RequestDecode(RasterImage* aImg)
 89821: {
 89821:   AddDecodeRequest(&aImg->mDecodeRequest);
 89821:   EnsurePendingInEventLoop();
 89821: }
 89821: 
 89821: void
108319: RasterImage::DecodeWorker::DecodeABitOf(RasterImage* aImg)
108319: {
108319:   DecodeSomeOfImage(aImg);
108319: 
108319:   // If we aren't yet finished decoding and we have more data in hand, add
108319:   // this request to the back of the priority list.
108319:   if (aImg->mDecoder &&
108319:       !aImg->mError &&
108319:       !aImg->IsDecodeFinished() &&
108319:       aImg->mSourceData.Length() > aImg->mBytesDecoded) {
108319:     RequestDecode(aImg);
108319:   }
108319: }
108319: 
108319: void
 89821: RasterImage::DecodeWorker::EnsurePendingInEventLoop()
 89821: {
 89821:   if (!mPendingInEventLoop) {
 89821:     mPendingInEventLoop = true;
 89821:     NS_DispatchToCurrentThread(this);
 89821:   }
 89821: }
 89821: 
 89821: void
 89821: RasterImage::DecodeWorker::StopDecoding(RasterImage* aImg)
 89821: {
 89821:   DecodeRequest* request = &aImg->mDecodeRequest;
 89821:   if (request->isInList()) {
 89821:     request->remove();
 89821:   }
 89821:   request->mDecodeTime = TimeDuration(0);
 89821:   request->mIsASAP = false;
 89821: }
 89821: 
 89821: NS_IMETHODIMP
 89821: RasterImage::DecodeWorker::Run()
 89821: {
 89821:   // We just got called back by the event loop; therefore, we're no longer
 89821:   // pending.
 89821:   mPendingInEventLoop = false;
 89821: 
 89821:   TimeStamp eventStart = TimeStamp::Now();
 89821: 
 89821:   // Now decode until we either run out of time or run out of images.
 89821:   do {
 89821:     // Try to get an ASAP request to handle.  If there isn't one, try to get a
 89821:     // normal request.  If no normal request is pending either, then we're done
 89821:     // here.
 89821:     DecodeRequest* request = mASAPDecodeRequests.popFirst();
 89821:     if (!request)
 89821:       request = mNormalDecodeRequests.popFirst();
 89821:     if (!request)
 89821:       break;
 89821: 
 89821:     // This has to be a strong pointer, because DecodeSomeOfImage may destroy
 89821:     // image->mDecoder, which may be holding the only other reference to image.
 89821:     nsRefPtr<RasterImage> image = request->mImage;
 89821:     DecodeSomeOfImage(image);
 89821: 
 89821:     // If we aren't yet finished decoding and we have more data in hand, add
 89821:     // this request to the back of the list.
 89821:     if (image->mDecoder &&
 89821:         !image->mError &&
 89821:         !image->IsDecodeFinished() &&
 89821:         image->mSourceData.Length() > image->mBytesDecoded) {
 89821:       AddDecodeRequest(request);
 89821:     }
 89821: 
 89821:   } while ((TimeStamp::Now() - eventStart).ToMilliseconds() <= gMaxMSBeforeYield);
 89821: 
 89821:   // If decode requests are pending, re-post ourself to the event loop.
 89821:   if (!mASAPDecodeRequests.isEmpty() || !mNormalDecodeRequests.isEmpty()) {
 89821:     EnsurePendingInEventLoop();
 89821:   }
 89821: 
 89821:   Telemetry::Accumulate(Telemetry::IMAGE_DECODE_LATENCY,
108991:                         uint32_t((TimeStamp::Now() - eventStart).ToMilliseconds()));
 89821: 
 89821:   return NS_OK;
 89821: }
 89821: 
 89821: nsresult
 89821: RasterImage::DecodeWorker::DecodeUntilSizeAvailable(RasterImage* aImg)
 89821: {
 89821:   return DecodeSomeOfImage(aImg, DECODE_TYPE_UNTIL_SIZE);
 89821: }
 89821: 
 89821: nsresult
 89821: RasterImage::DecodeWorker::DecodeSomeOfImage(
 89821:   RasterImage* aImg,
 89821:   DecodeType aDecodeType /* = DECODE_TYPE_NORMAL */)
 89821: {
 89821:   NS_ABORT_IF_FALSE(aImg->mInitialized,
 89821:                     "Worker active for uninitialized container!");
 89821: 
 89821:   // If an error is flagged, it probably happened while we were waiting
 89821:   // in the event queue.
 89821:   if (aImg->mError)
 89821:     return NS_OK;
 89821: 
 89821:   // If mDecoded or we don't have a decoder, we must have finished already (for
 89821:   // example, a synchronous decode request came while the worker was pending).
 89821:   if (!aImg->mDecoder || aImg->mDecoded)
 89821:     return NS_OK;
 89821: 
 89821:   nsRefPtr<Decoder> decoderKungFuDeathGrip = aImg->mDecoder;
 89821: 
108991:   uint32_t maxBytes;
 89821:   if (aImg->mDecoder->IsSizeDecode()) {
 89821:     // Decode all available data if we're a size decode; they're cheap, and we
 89821:     // want them to be more or less synchronous.
 89821:     maxBytes = aImg->mSourceData.Length();
 89821:   } else {
 89821:     // We're only guaranteed to decode this many bytes, so in particular,
 89821:     // gDecodeBytesAtATime should be set high enough for us to read the size
 89821:     // from most images.
 89821:     maxBytes = gDecodeBytesAtATime;
 89821:   }
 89821: 
108991:   int32_t chunkCount = 0;
 89821:   TimeStamp start = TimeStamp::Now();
 89821:   TimeStamp deadline = start + TimeDuration::FromMilliseconds(gMaxMSBeforeYield);
 89821: 
 94057:   // We keep decoding chunks until:
 94057:   //  * we don't have any data left to decode,
 94057:   //  * the decode completes,
 94057:   //  * we're an UNTIL_SIZE decode and we get the size, or
 94057:   //  * we run out of time.
 94057:   while (aImg->mSourceData.Length() > aImg->mBytesDecoded &&
 94057:          !aImg->IsDecodeFinished() &&
 94057:          !(aDecodeType == DECODE_TYPE_UNTIL_SIZE && aImg->mHasSize)) {
 89821:     chunkCount++;
 89821:     nsresult rv = aImg->DecodeSomeData(maxBytes);
 89821:     if (NS_FAILED(rv)) {
 89821:       aImg->DoError();
 89821:       return rv;
 89821:     }
 89821: 
 94057:     // Yield if we've been decoding for too long. We check this _after_ decoding
 94057:     // a chunk to ensure that we don't yield without doing any decoding.
 94057:     if (TimeStamp::Now() >= deadline)
 89821:       break;
 94057:   }
 89821: 
 89821:   aImg->mDecodeRequest.mDecodeTime += (TimeStamp::Now() - start);
 89821: 
 89821:   if (chunkCount && !aImg->mDecoder->IsSizeDecode()) {
 89821:     Telemetry::Accumulate(Telemetry::IMAGE_DECODE_CHUNKS, chunkCount);
 89821:   }
 89821: 
 90064:   // Flush invalidations (and therefore paint) now that we've decoded all the
 90064:   // chunks we're going to.
 89821:   //
 90064:   // However, don't paint if:
 90064:   //
 90064:   //  * This was an until-size decode.  Until-size decodes are always followed
 90064:   //    by normal decodes, so don't bother painting.
 90064:   //
 90064:   //  * The decoder flagged an error.  The decoder may have written garbage
 90064:   //    into the output buffer; don't paint it to the screen.
 90064:   //
 90064:   //  * We have all the source data.  This disables progressive display of
 90064:   //    previously-decoded images, thus letting us finish decoding faster,
 90064:   //    since we don't waste time painting while we decode.
 90064:   //    Decoder::PostFrameStop() will flush invalidations once the decode is
 90064:   //    done.
 90064: 
 90064:   if (aDecodeType != DECODE_TYPE_UNTIL_SIZE &&
 90064:       !aImg->mDecoder->HasError() &&
 90064:       !aImg->mHasSourceData) {
 89821:     aImg->mInDecoder = true;
 89821:     aImg->mDecoder->FlushInvalidations();
 89821:     aImg->mInDecoder = false;
 89821:   }
 89821: 
 89821:   // If the decode finished, shut down the decoder.
 89821:   if (aImg->mDecoder && aImg->IsDecodeFinished()) {
 89821: 
 89821:     // Do some telemetry if this isn't a size decode.
 89821:     DecodeRequest* request = &aImg->mDecodeRequest;
 89821:     if (!aImg->mDecoder->IsSizeDecode()) {
 89821:       Telemetry::Accumulate(Telemetry::IMAGE_DECODE_TIME,
108991:                             int32_t(request->mDecodeTime.ToMicroseconds()));
 89821: 
 89821:       // We record the speed for only some decoders. The rest have
 89821:       // SpeedHistogram return HistogramCount.
 89821:       Telemetry::ID id = aImg->mDecoder->SpeedHistogram();
 89821:       if (id < Telemetry::HistogramCount) {
108991:           int32_t KBps = int32_t(request->mImage->mBytesDecoded /
 89821:                                  (1024 * request->mDecodeTime.ToSeconds()));
 89821:           Telemetry::Accumulate(id, KBps);
 89821:       }
 89821:     }
 89821: 
 89821:     nsresult rv = aImg->ShutdownDecoder(RasterImage::eShutdownIntent_Done);
 89821:     if (NS_FAILED(rv)) {
 89821:       aImg->DoError();
 89821:       return rv;
 89821:     }
 89821:   }
 89821: 
 89821:   return NS_OK;
 89821: }
 89821: 
 87852: } // namespace image
 50549: } // namespace mozilla
