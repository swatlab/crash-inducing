    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for all element classes; this provides an implementation
    1:  * of DOM Core's nsIDOMElement, implements nsIContent, provides
    1:  * utility methods for subclasses, and so forth.
    1:  */
    1: 
    1: #ifndef nsGenericElement_h___
    1: #define nsGenericElement_h___
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
41930: #include "mozilla/dom/Element.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocumentFragment.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsAttrAndChildArray.h"
    1: #include "mozFlushType.h"
    1: #include "nsDOMAttributeMap.h"
    1: #include "nsIWeakReference.h"
    1: #include "nsCycleCollectionParticipant.h"
13098: #include "nsIDocument.h"
16106: #include "nsIDOMNodeSelector.h"
29215: #include "nsIDOMXPathNSResolver.h"
41910: #include "nsPresContext.h"
70158: #include "nsIDOMDOMStringMap.h"
75263: #include "nsContentList.h"
75263: #include "nsDOMClassInfoID.h" // DOMCI_DATA
77147: #include "nsIDOMTouchEvent.h"
77149: #include "nsIInlineEventHandlers.h"
    1: 
23697: #include "nsISMILAttr.h"
23697: 
    1: class nsIDOMAttr;
    1: class nsIDOMEventListener;
    1: class nsIFrame;
    1: class nsIDOMNamedNodeMap;
47641: class nsICSSDeclaration;
    1: class nsIDOMCSSStyleDeclaration;
    1: class nsIURI;
    1: class nsINodeInfo;
    1: class nsIControllers;
72328: class nsEventListenerManager;
37060: class nsIScrollableFrame;
17074: class nsContentList;
31383: class nsDOMTokenList;
16722: struct nsRect;
    1: 
27256: typedef PRUptrdiff PtrBits;
    1: 
    1: /**
    1:  * Class that implements the nsIDOMNodeList interface (a list of children of
    1:  * the content), by holding a reference to the content and delegating GetLength
    1:  * and Item to its existing child list.
    1:  * @see nsIDOMNodeList
    1:  */
69024: class nsChildContentList : public nsINodeList
    1: {
    1: public:
    1:   nsChildContentList(nsINode* aNode)
    1:     : mNode(aNode)
    1:   {
80067:     SetIsProxy();
    1:   }
20752: 
80074:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
80074:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(nsChildContentList)
    1: 
80067:   // nsWrapperCache
80085:   virtual JSObject* WrapObject(JSContext *cx, XPCWrappedNativeScope *scope,
80085:                                bool *triedToWrap);
80067: 
    1:   // nsIDOMNodeList interface
20752:   NS_DECL_NSIDOMNODELIST
19130: 
19130:   // nsINodeList interface
24403:   virtual PRInt32 IndexOf(nsIContent* aContent);
    1: 
    1:   void DropReference()
    1:   {
    1:     mNode = nsnull;
    1:   }
    1: 
69024:   virtual nsINode* GetParentObject()
21618:   {
21618:     return mNode;
21618:   }
21618: 
    1: private:
    1:   // The node whose children make up the list (weak reference)
    1:   nsINode* mNode;
    1: };
    1: 
    1: /**
    1:  * A tearoff class for nsGenericElement to implement additional interfaces
    1:  */
71768: class nsNode3Tearoff : public nsIDOMXPathNSResolver
    1: {
    1: public:
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
71768:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNode3Tearoff)
    1: 
71768:   NS_DECL_NSIDOMXPATHNSRESOLVER
    1: 
41908:   nsNode3Tearoff(nsINode *aNode) : mNode(aNode)
    1:   {
    1:   }
    1: 
    1: protected:
  731:   virtual ~nsNode3Tearoff() {}
    1: 
    1: private:
41908:   nsCOMPtr<nsINode> mNode;
    1: };
    1: 
    1: /**
    1:  * A class that implements nsIWeakReference
    1:  */
    1: 
    1: class nsNodeWeakReference : public nsIWeakReference
    1: {
    1: public:
    1:   nsNodeWeakReference(nsINode* aNode)
    1:     : mNode(aNode)
    1:   {
    1:   }
    1: 
    1:   ~nsNodeWeakReference();
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIWeakReference
    1:   NS_DECL_NSIWEAKREFERENCE
    1: 
    1:   void NoticeNodeDestruction()
    1:   {
    1:     mNode = nsnull;
    1:   }
    1: 
    1: private:
    1:   nsINode* mNode;
    1: };
    1: 
    1: /**
    1:  * Tearoff to use for nodes to implement nsISupportsWeakReference
    1:  */
    1: class nsNodeSupportsWeakRefTearoff : public nsISupportsWeakReference
    1: {
    1: public:
    1:   nsNodeSupportsWeakRefTearoff(nsINode* aNode)
    1:     : mNode(aNode)
    1:   {
    1:   }
    1: 
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   // nsISupportsWeakReference
    1:   NS_DECL_NSISUPPORTSWEAKREFERENCE
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNodeSupportsWeakRefTearoff)
    1: 
    1: private:
    1:   nsCOMPtr<nsINode> mNode;
    1: };
    1: 
    1: /**
16106:  * A tearoff class for nsGenericElement to implement NodeSelector
16106:  */
16106: class nsNodeSelectorTearoff : public nsIDOMNodeSelector
16106: {
16106: public:
16106:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
16106: 
16106:   NS_DECL_NSIDOMNODESELECTOR
16106: 
16106:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNodeSelectorTearoff)
16106: 
41909:   nsNodeSelectorTearoff(nsINode *aNode) : mNode(aNode)
16106:   {
16106:   }
16106: 
16106: private:
16106:   ~nsNodeSelectorTearoff() {}
16106: 
16106: private:
41909:   nsCOMPtr<nsINode> mNode;
16106: };
16106: 
17074: // Forward declare to allow being a friend
77147: class nsTouchEventReceiverTearoff;
77149: class nsInlineEventHandlersTearoff;
17074: 
    1: /**
    1:  * A generic base class for DOM elements, implementing many nsIContent,
    1:  * nsIDOMNode and nsIDOMElement methods.
    1:  */
41632: class nsGenericElement : public mozilla::dom::Element
    1: {
    1: public:
48124:   nsGenericElement(already_AddRefed<nsINodeInfo> aNodeInfo);
    1:   virtual ~nsGenericElement();
    1: 
77147:   friend class nsTouchEventReceiverTearoff;
77149:   friend class nsInlineEventHandlersTearoff;
16722: 
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
73721:   NS_DECL_DOM_MEMORY_REPORTER_SIZEOF
73721: 
    1:   /**
    1:    * Called during QueryInterface to give the binding manager a chance to
    1:    * get an interface for this element.
    1:    */
    1:   nsresult PostQueryInterface(REFNSIID aIID, void** aInstancePtr);
    1: 
    1:   // nsINode interface methods
    1:   virtual PRUint32 GetChildCount() const;
    1:   virtual nsIContent *GetChildAt(PRUint32 aIndex) const;
22251:   virtual nsIContent * const * GetChildArray(PRUint32* aChildCount) const;
    1:   virtual PRInt32 IndexOf(nsINode* aPossibleChild) const;
    1:   virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
79445:                                  bool aNotify);
79445:   virtual nsresult RemoveChildAt(PRUint32 aIndex, bool aNotify);
75263:   NS_IMETHOD GetTextContent(nsAString &aTextContent);
75263:   NS_IMETHOD SetTextContent(const nsAString& aTextContent);
    1: 
    1:   // nsIContent interface methods
79445:   virtual void UpdateEditableState(bool aNotify);
71121: 
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
79445:                               bool aCompileEventHandlers);
79445:   virtual void UnbindFromTree(bool aDeep = true,
79445:                               bool aNullParent = true);
55877:   virtual already_AddRefed<nsINodeList> GetChildren(PRUint32 aFilter);
    1:   virtual nsIAtom *GetClassAttributeName() const;
    1:   virtual already_AddRefed<nsINodeInfo> GetExistingAttrNameFromQName(const nsAString& aStr) const;
    1:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
79445:                    const nsAString& aValue, bool aNotify)
    1:   {
    1:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
    1:   }
61740:   /**
61740:    * Helper for SetAttr/SetParsedAttr. This method will return true if aNotify
61740:    * is true or there are mutation listeners that must be triggered, the
61740:    * attribute is currently set, and the new value that is about to be set is
61740:    * different to the current value. As a perf optimization the new and old
61740:    * values will not actually be compared if we aren't notifying and we don't
80486:    * have mutation listeners (in which case it's cheap to just return false
61740:    * and let the caller go ahead and set the value).
61740:    * @param aOldValue Set to the old value of the attribute, but only if there
61740:    *   are event listeners
61740:    * @param aModType Set to nsIDOMMutationEvent::MODIFICATION or to
61740:    *   nsIDOMMutationEvent::ADDITION, but only if this helper returns true
61740:    * @param aHasListeners Set to true if there are mutation event listeners
61740:    *   listening for NS_EVENT_BITS_MUTATION_ATTRMODIFIED
61740:    */
79445:   bool MaybeCheckSameAttrVal(PRInt32 aNamespaceID, nsIAtom* aName,
61740:                                nsIAtom* aPrefix, const nsAString& aValue,
79445:                                bool aNotify, nsAutoString* aOldValue,
79445:                                PRUint8* aModType, bool* aHasListeners);
    1:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName, nsIAtom* aPrefix,
79445:                            const nsAString& aValue, bool aNotify);
61740:   virtual nsresult SetParsedAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
61740:                                  nsIAtom* aPrefix, nsAttrValue& aParsedValue,
79445:                                  bool aNotify);
79445:   virtual bool GetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                          nsAString& aResult) const;
79445:   virtual bool HasAttr(PRInt32 aNameSpaceID, nsIAtom* aName) const;
79445:   virtual bool AttrValueIs(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                              const nsAString& aValue,
    1:                              nsCaseTreatment aCaseSensitive) const;
79445:   virtual bool AttrValueIs(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                              nsIAtom* aValue,
    1:                              nsCaseTreatment aCaseSensitive) const;
    1:   virtual PRInt32 FindAttrValueIn(PRInt32 aNameSpaceID,
    1:                                   nsIAtom* aName,
    1:                                   AttrValuesArray* aValues,
    1:                                   nsCaseTreatment aCaseSensitive) const;
    1:   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
79445:                              bool aNotify);
    1:   virtual const nsAttrName* GetAttrNameAt(PRUint32 aIndex) const;
    1:   virtual PRUint32 GetAttrCount() const;
    1:   virtual const nsTextFragment *GetText();
82209:   virtual PRUint32 TextLength();
    1:   virtual nsresult SetText(const PRUnichar* aBuffer, PRUint32 aLength,
79445:                            bool aNotify);
    1:   // Need to implement this here too to avoid hiding.
79445:   nsresult SetText(const nsAString& aStr, bool aNotify)
    1:   {
    1:     return SetText(aStr.BeginReading(), aStr.Length(), aNotify);
    1:   }
    1:   virtual nsresult AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
79445:                               bool aNotify);
82209:   virtual bool TextIsOnlyWhitespace();
    1:   virtual void AppendTextTo(nsAString& aResult);
    1:   virtual nsIContent *GetBindingParent() const;
79445:   virtual bool IsNodeOfType(PRUint32 aFlags) const;
79445:   virtual bool IsLink(nsIURI** aURI) const;
    1: 
    1:   virtual PRUint32 GetScriptTypeID() const;
28073:   NS_IMETHOD SetScriptTypeID(PRUint32 aLang);
    1: 
 8462:   virtual void DestroyContent();
14188:   virtual void SaveSubtreeState();
14188: 
55139:   virtual nsISMILAttr* GetAnimatedAttr(PRInt32 /*aNamespaceID*/, nsIAtom* /*aName*/)
23697:   {
23697:     return nsnull;
23697:   }
64123:   virtual nsIDOMCSSStyleDeclaration* GetSMILOverrideStyle();
63693:   virtual mozilla::css::StyleRule* GetSMILOverrideStyleRule();
63693:   virtual nsresult SetSMILOverrideStyleRule(mozilla::css::StyleRule* aStyleRule,
79445:                                             bool aNotify);
23697: 
    1: #ifdef DEBUG
    1:   virtual void List(FILE* out, PRInt32 aIndent) const
    1:   {
    1:     List(out, aIndent, EmptyCString());
    1:   }
79445:   virtual void DumpContent(FILE* out, PRInt32 aIndent, bool aDumpAll) const;
    1:   void List(FILE* out, PRInt32 aIndent, const nsCString& aPrefix) const;
    1:   void ListAttributes(FILE* out) const;
    1: #endif
    1: 
19132:   virtual const nsAttrValue* DoGetClasses() const;
    1:   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
63693:   virtual mozilla::css::StyleRule* GetInlineStyleRule();
79445:   NS_IMETHOD SetInlineStyleRule(mozilla::css::StyleRule* aStyleRule, bool aNotify);
79445:   NS_IMETHOD_(bool)
    1:     IsAttributeMapped(const nsIAtom* aAttribute) const;
    1:   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                               PRInt32 aModType) const;
    1:   /*
    1:    * Attribute Mapping Helpers
    1:    */
    1:   struct MappedAttributeEntry {
    1:     nsIAtom** attribute;
    1:   };
    1: 
    1:   /**
    1:    * A common method where you can just pass in a list of maps to check
    1:    * for attribute dependence. Most implementations of
    1:    * IsAttributeMapped should use this function as a default
    1:    * handler.
    1:    */
84865:   template<size_t N>
84865:   static bool
84865:   FindAttributeDependence(const nsIAtom* aAttribute,
84865:                           const MappedAttributeEntry* const (&aMaps)[N])
84865:   {
84865:     return FindAttributeDependence(aAttribute, aMaps, N);
84865:   }
84865: 
84865: private:
79445:   static bool
    1:   FindAttributeDependence(const nsIAtom* aAttribute,
    1:                           const MappedAttributeEntry* const aMaps[],
    1:                           PRUint32 aMapCount);
    1: 
84865: public:
    1:   // nsIDOMNode method implementation
    1:   NS_IMETHOD GetNodeName(nsAString& aNodeName);
    1:   NS_IMETHOD GetLocalName(nsAString& aLocalName);
    1:   NS_IMETHOD GetNodeValue(nsAString& aNodeValue);
    1:   NS_IMETHOD SetNodeValue(const nsAString& aNodeValue);
    1:   NS_IMETHOD GetNodeType(PRUint16* aNodeType);
    1:   NS_IMETHOD GetAttributes(nsIDOMNamedNodeMap** aAttributes);
    1:   NS_IMETHOD GetNamespaceURI(nsAString& aNamespaceURI);
    1:   NS_IMETHOD GetPrefix(nsAString& aPrefix);
    1:   NS_IMETHOD IsSupported(const nsAString& aFeature,
79445:                          const nsAString& aVersion, bool* aReturn);
79445:   NS_IMETHOD HasAttributes(bool* aHasAttributes);
79445:   NS_IMETHOD HasChildNodes(bool* aHasChildNodes);
39585:   nsresult InsertBefore(nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,
39585:                         nsIDOMNode** aReturn)
39585:   {
80486:     return ReplaceOrInsertBefore(false, aNewChild, aRefChild, aReturn);
39585:   }
39585:   nsresult ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
39585:                         nsIDOMNode** aReturn)
39585:   {
80486:     return ReplaceOrInsertBefore(true, aNewChild, aOldChild, aReturn);
39585:   }
39585:   nsresult RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
39585:   {
39585:     return nsINode::RemoveChild(aOldChild, aReturn);
39585:   }
39585:   nsresult AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
    1:   {
    1:     return InsertBefore(aNewChild, nsnull, aReturn);
    1:   }
    1: 
    1:   // nsIDOMElement method implementation
89079:   NS_DECL_NSIDOMELEMENT
89079: 
79445:   nsresult CloneNode(bool aDeep, nsIDOMNode **aResult)
    1:   {
80486:     return nsNodeUtils::CloneNodeImpl(this, aDeep, true, aResult);
    1:   }
    1: 
    1:   //----------------------------------------
    1: 
    1:   /**
    1:    * Add a script event listener with the given event handler name
    1:    * (like onclick) and with the value as JS
    1:    * @param aEventName the event listener name
    1:    * @param aValue the JS to attach
    1:    * @param aDefer indicates if deferred execution is allowed
    1:    */
    1:   nsresult AddScriptEventListener(nsIAtom* aEventName,
    1:                                   const nsAString& aValue,
79445:                                   bool aDefer = true);
    1: 
    1:   /**
    1:    * Do whatever needs to be done when the mouse leaves a link
    1:    */
    1:   nsresult LeaveLink(nsPresContext* aPresContext);
    1: 
    1:   /**
    1:    * Check whether a spec feature/version is supported.
    1:    * @param aObject the object, which should support the feature,
    1:    *        for example nsIDOMNode or nsIDOMDOMImplementation
    1:    * @param aFeature the feature ("Views", "Core", "HTML", "Range" ...)
    1:    * @param aVersion the version ("1.0", "2.0", ...)
    1:    * @param aReturn whether the feature is supported or not [OUT]
    1:    */
    1:   static nsresult InternalIsSupported(nsISupports* aObject,
    1:                                       const nsAString& aFeature,
    1:                                       const nsAString& aVersion,
79445:                                       bool* aReturn);
    1: 
79445:   static bool ShouldBlur(nsIContent *aContent);
    1: 
    1:   /**
41627:    * If there are listeners for DOMNodeInserted event, fires the event on all
41627:    * aNodes
41627:    */
41627:   static void FireNodeInserted(nsIDocument* aDoc,
41627:                                nsINode* aParent,
70878:                                nsTArray<nsCOMPtr<nsIContent> >& aNodes);
41627: 
41627:   /**
16106:    * Helper methods for implementing querySelector/querySelectorAll
16106:    */
41909:   static nsIContent* doQuerySelector(nsINode* aRoot, const nsAString& aSelector,
41909:                                      nsresult *aResult NS_OUTPARAM);
16106:   static nsresult doQuerySelectorAll(nsINode* aRoot,
16106:                                      const nsAString& aSelector,
16106:                                      nsIDOMNodeList **aReturn);
16106: 
16106:   /**
    1:    * Method to create and dispatch a left-click event loosely based on
    1:    * aSourceEvent. If aFullDispatch is true, the event will be dispatched
    1:    * through the full dispatching of the presshell of the aPresContext; if it's
    1:    * false the event will be dispatched only as a DOM event.
    1:    * If aPresContext is nsnull, this does nothing.
    1:    */
    1:   static nsresult DispatchClickEvent(nsPresContext* aPresContext,
    1:                                      nsInputEvent* aSourceEvent,
    1:                                      nsIContent* aTarget,
79445:                                      bool aFullDispatch,
74191:                                      PRUint32 aFlags,
    1:                                      nsEventStatus* aStatus);
    1: 
    1:   /**
    1:    * Method to dispatch aEvent to aTarget. If aFullDispatch is true, the event
    1:    * will be dispatched through the full dispatching of the presshell of the
    1:    * aPresContext; if it's false the event will be dispatched only as a DOM
    1:    * event.
    1:    * If aPresContext is nsnull, this does nothing.
    1:    */
72324:   using nsIContent::DispatchEvent;
    1:   static nsresult DispatchEvent(nsPresContext* aPresContext,
    1:                                 nsEvent* aEvent,
    1:                                 nsIContent* aTarget,
79445:                                 bool aFullDispatch,
    1:                                 nsEventStatus* aStatus);
    1: 
    1:   /**
36655:    * Get the primary frame for this content with flushing
    1:    *
    1:    * @param aType the kind of flush to do, typically Flush_Frames or
    1:    *              Flush_Layout
    1:    * @return the primary frame
    1:    */
    1:   nsIFrame* GetPrimaryFrame(mozFlushType aType);
36655:   // Work around silly C++ name hiding stuff
36655:   nsIFrame* GetPrimaryFrame() const { return nsIContent::GetPrimaryFrame(); }
    1: 
    1:   /**
    1:    * Struct that stores info on an attribute.  The name and value must
    1:    * either both be null or both be non-null.
    1:    */
    1:   struct nsAttrInfo {
    1:     nsAttrInfo(const nsAttrName* aName, const nsAttrValue* aValue) :
    1:       mName(aName), mValue(aValue) {}
    1:     nsAttrInfo(const nsAttrInfo& aOther) :
    1:       mName(aOther.mName), mValue(aOther.mValue) {}
    1: 
    1:     const nsAttrName* mName;
    1:     const nsAttrValue* mValue;
    1:   };
    1: 
43573:   // Be careful when using this method. This does *NOT* handle
43573:   // XUL prototypes. You may want to use GetAttrInfo.
31383:   const nsAttrValue* GetParsedAttr(nsIAtom* aAttr) const
31383:   {
31383:     return mAttrsAndChildren.GetAttr(aAttr);
31383:   }
31383: 
    1:   /**
    1:    * Returns the attribute map, if there is one.
    1:    *
    1:    * @return existing attribute map or nsnull.
    1:    */
    1:   nsDOMAttributeMap *GetAttributeMap()
    1:   {
    1:     nsDOMSlots *slots = GetExistingDOMSlots();
    1: 
    1:     return slots ? slots->mAttributeMap.get() : nsnull;
    1:   }
    1: 
    1:   virtual void RecompileScriptEventListeners()
    1:   {
    1:   }
    1: 
41910:   PRInt32 GetScrollTop();
41910:   PRInt32 GetScrollLeft();
41910:   PRInt32 GetScrollHeight();
41910:   PRInt32 GetScrollWidth();
41910:   PRInt32 GetClientTop()
41910:   {
41910:     return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().y);
41910:   }
41910:   PRInt32 GetClientLeft()
41910:   {
41910:     return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().x);
41910:   }
41910:   PRInt32 GetClientHeight()
41910:   {
41910:     return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().height);
41910:   }
41910:   PRInt32 GetClientWidth()
41910:   {
41910:     return nsPresContext::AppUnitsToIntCSSPixels(GetClientAreaRect().width);
41910:   }
41910:   nsIContent* GetFirstElementChild();
41910:   nsIContent* GetLastElementChild();
41910:   nsIContent* GetPreviousElementSibling();
41910:   nsIContent* GetNextElementSibling();
41910:   nsIDOMDOMTokenList* GetClassList(nsresult *aResult);
79445:   bool MozMatchesSelector(const nsAString& aSelector, nsresult* aResult);
41910: 
43572:   /**
43572:    * Get the attr info for the given namespace ID and attribute name.  The
43572:    * namespace ID must not be kNameSpaceID_Unknown and the name must not be
43572:    * null.  Note that this can only return info on attributes that actually
43572:    * live on this element (and is only virtual to handle XUL prototypes).  That
43572:    * is, this should only be called from methods that only care about attrs
43572:    * that effectively live in mAttrsAndChildren.
43572:    */
43572:   virtual nsAttrInfo GetAttrInfo(PRInt32 aNamespaceID, nsIAtom* aName) const;
43572: 
88521:   NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS(nsGenericElement)
    1: 
51858:   virtual void NodeInfoChanged(nsINodeInfo* aOldNodeInfo)
51858:   {
51858:   }
51858: 
69573:   /**
69573:    * Fire a DOMNodeRemoved mutation event for all children of this node
69573:    */
69573:   void FireNodeRemovedForChildren();
69573: 
88521:   virtual bool IsPurple()
88521:   {
88521:     return mRefCnt.IsPurple();
88521:   }
88521: 
88521:   virtual void RemovePurple()
88521:   {
88521:     mRefCnt.RemovePurple();
88521:   }
88521: 
88844:   static bool CanSkip(nsINode* aNode, bool aRemovingAllowed);
88521:   static bool CanSkipInCC(nsINode* aNode);
88521:   static bool CanSkipThis(nsINode* aNode);
88521:   static void InitCCCallbacks();
88521:   static void MarkUserData(void* aObject, nsIAtom* aKey, void* aChild,
88521:                            void *aData);
88521:   static void MarkUserDataHandler(void* aObject, nsIAtom* aKey, void* aChild,
88521:                                   void* aData);
    1: protected:
    1:   /**
    1:    * Set attribute and (if needed) notify documentobservers and fire off
38453:    * mutation events.  This will send the AttributeChanged notification.
38453:    * Callers of this method are responsible for calling AttributeWillChange,
38453:    * since that needs to happen before the new attr value has been set, and
38453:    * in particular before it has been parsed.
    1:    *
    1:    * @param aNamespaceID  namespace of attribute
    1:    * @param aAttribute    local-name of attribute
    1:    * @param aPrefix       aPrefix of attribute
    1:    * @param aOldValue     previous value of attribute. Only needed if
    1:    *                      aFireMutation is true.
    1:    * @param aParsedValue  parsed new value of attribute
38453:    * @param aModType      nsIDOMMutationEvent::MODIFICATION or ADDITION.  Only
    1:    *                      needed if aFireMutation or aNotify is true.
    1:    * @param aFireMutation should mutation-events be fired?
    1:    * @param aNotify       should we notify document-observers?
22222:    * @param aValueForAfterSetAttr If not null, AfterSetAttr will be called
22222:    *                      with the value pointed by this parameter.
    1:    */
    1:   nsresult SetAttrAndNotify(PRInt32 aNamespaceID,
    1:                             nsIAtom* aName,
    1:                             nsIAtom* aPrefix,
    1:                             const nsAString& aOldValue,
    1:                             nsAttrValue& aParsedValue,
38453:                             PRUint8 aModType,
79445:                             bool aFireMutation,
79445:                             bool aNotify,
22222:                             const nsAString* aValueForAfterSetAttr);
    1: 
    1:   /**
    1:    * Convert an attribute string value to attribute type based on the type of
    1:    * attribute.  Called by SetAttr().  Note that at the moment we only do this
    1:    * for attributes in the null namespace (kNameSpaceID_None).
    1:    *
    1:    * @param aNamespaceID the namespace of the attribute to convert
    1:    * @param aAttribute the attribute to convert
    1:    * @param aValue the string value to convert
    1:    * @param aResult the nsAttrValue [OUT]
80486:    * @return true if the parsing was successful, false otherwise
    1:    */
79445:   virtual bool ParseAttribute(PRInt32 aNamespaceID,
    1:                                 nsIAtom* aAttribute,
    1:                                 const nsAString& aValue,
    1:                                 nsAttrValue& aResult);
    1: 
    1:   /**
    1:    * Try to set the attribute as a mapped attribute, if applicable.  This will
    1:    * only be called for attributes that are in the null namespace and only on
    1:    * attributes that returned true when passed to IsAttributeMapped.  The
    1:    * caller will not try to set the attr in any other way if this method
80486:    * returns true (the value of aRetval does not matter for that purpose).
    1:    *
    1:    * @param aDocument the current document of this node (an optimization)
    1:    * @param aName the name of the attribute
    1:    * @param aValue the nsAttrValue to set
    1:    * @param [out] aRetval the nsresult status of the operation, if any.
80486:    * @return true if the setting was attempted, false otherwise.
    1:    */
79445:   virtual bool SetMappedAttribute(nsIDocument* aDocument,
    1:                                     nsIAtom* aName,
    1:                                     nsAttrValue& aValue,
    1:                                     nsresult* aRetval);
    1: 
    1:   /**
    1:    * Hook that is called by nsGenericElement::SetAttr to allow subclasses to
    1:    * deal with attribute sets.  This will only be called after we verify that
38453:    * we're actually doing an attr set and will be called before
38453:    * AttributeWillChange and before ParseAttribute and hence before we've set
38453:    * the new value.
    1:    *
    1:    * @param aNamespaceID the namespace of the attr being set
    1:    * @param aName the localname of the attribute being set
    1:    * @param aValue the value it's being set to.  If null, the attr is being
    1:    *        removed.
    1:    * @param aNotify Whether we plan to notify document observers.
    1:    */
    1:   // Note that this is inlined so that when subclasses call it it gets
    1:   // inlined.  Those calls don't go through a vtable.
    1:   virtual nsresult BeforeSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
79445:                                  const nsAString* aValue, bool aNotify)
    1:   {
    1:     return NS_OK;
    1:   }
    1: 
    1:   /**
    1:    * Hook that is called by nsGenericElement::SetAttr to allow subclasses to
    1:    * deal with attribute sets.  This will only be called after we have called
38453:    * SetAndTakeAttr and AttributeChanged (that is, after we have actually set
71103:    * the attr).  It will always be called under a scriptblocker.
    1:    *
    1:    * @param aNamespaceID the namespace of the attr being set
    1:    * @param aName the localname of the attribute being set
    1:    * @param aValue the value it's being set to.  If null, the attr is being
    1:    *        removed.
    1:    * @param aNotify Whether we plan to notify document observers.
    1:    */
    1:   // Note that this is inlined so that when subclasses call it it gets
    1:   // inlined.  Those calls don't go through a vtable.
    1:   virtual nsresult AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
79445:                                 const nsAString* aValue, bool aNotify)
    1:   {
    1:     return NS_OK;
    1:   }
    1: 
    1:   /**
72328:    * Hook to allow subclasses to produce a different nsEventListenerManager if
    1:    * needed for attachment of attribute-defined handlers
    1:    */
74595:   virtual nsEventListenerManager*
79445:     GetEventListenerManagerForAttr(nsIAtom* aAttrName, bool* aDefer);
    1: 
    1:   /**
    1:    * Copy attributes and state to another element
    1:    * @param aDest the object to copy to
    1:    */
    1:   nsresult CopyInnerTo(nsGenericElement* aDest) const;
    1: 
    1:   /**
    1:    * Internal hook for converting an attribute name-string to an atomized name
    1:    */
    1:   virtual const nsAttrName* InternalGetExistingAttrNameFromQName(const nsAString& aStr) const;
    1: 
16722:   /**
16722:    * Retrieve the rectangle for the offsetX properties, which
16722:    * are coordinates relative to the returned aOffsetParent.
16722:    *
16722:    * @param aRect offset rectangle
16722:    * @param aOffsetParent offset parent
16722:    */
16722:   virtual void GetOffsetRect(nsRect& aRect, nsIContent** aOffsetParent);
16722: 
16722:   nsIFrame* GetStyledFrame();
16722: 
41904:   virtual mozilla::dom::Element* GetNameSpaceElement()
41904:   {
41904:     return this;
41904:   }
41904: 
    1: public:
    1:   // Because of a bug in MS C++ compiler nsDOMSlots must be declared public,
    1:   // otherwise nsXULElement::nsXULSlots doesn't compile.
    1:   /**
    1:    * There are a set of DOM- and scripting-specific instance variables
    1:    * that may only be instantiated when a content object is accessed
    1:    * through the DOM. Rather than burn actual slots in the content
    1:    * objects for each of these instance variables, we put them off
    1:    * in a side structure that's only allocated when the content is
    1:    * accessed through the DOM.
    1:    */
    1:   class nsDOMSlots : public nsINode::nsSlots
    1:   {
    1:   public:
67604:     nsDOMSlots();
    1:     virtual ~nsDOMSlots();
    1: 
77323:     void Traverse(nsCycleCollectionTraversalCallback &cb, bool aIsXUL);
77323:     void Unlink(bool aIsXUL);
77323: 
    1:     /**
    1:      * The .style attribute (an interface that forwards to the actual
    1:      * style rules)
70158:      * @see nsGenericHTMLElement::GetStyle
70158:      */
47641:     nsCOMPtr<nsICSSDeclaration> mStyle;
    1: 
    1:     /**
70158:      * The .dataset attribute.
70158:      * @see nsGenericHTMLElement::GetDataset
70158:      */
70158:     nsIDOMDOMStringMap* mDataset; // [Weak]
70158: 
70158:     /**
32193:      * SMIL Overridde style rules (for SMIL animation of CSS properties)
32193:      * @see nsIContent::GetSMILOverrideStyle
32193:      */
47641:     nsCOMPtr<nsICSSDeclaration> mSMILOverrideStyle;
32193: 
32193:     /**
32193:      * Holds any SMIL override style rules for this element.
32193:      */
63693:     nsRefPtr<mozilla::css::StyleRule> mSMILOverrideStyleRule;
32193: 
32193:     /**
    1:      * An object implementing nsIDOMNamedNodeMap for this content (attributes)
    1:      * @see nsGenericElement::GetAttributes
    1:      */
    1:     nsRefPtr<nsDOMAttributeMap> mAttributeMap;
    1: 
    1:     union {
    1:       /**
    1:       * The nearest enclosing content node with a binding that created us.
    1:       * @see nsGenericElement::GetBindingParent
    1:       */
    1:       nsIContent* mBindingParent;  // [Weak]
    1: 
    1:       /**
    1:       * The controllers of the XUL Element.
    1:       */
    1:       nsIControllers* mControllers; // [OWNER]
    1:     };
    1: 
    1:     /**
17074:      * An object implementing the .children property for this element.
17074:      */
17074:     nsRefPtr<nsContentList> mChildrenList;
31383: 
31383:     /**
31383:      * An object implementing the .classList property for this element.
31383:      */
31383:     nsRefPtr<nsDOMTokenList> mClassList;
    1:   };
    1: 
    1: protected:
    1:   // Override from nsINode
    1:   virtual nsINode::nsSlots* CreateSlots();
    1: 
59659:   nsDOMSlots *DOMSlots()
    1:   {
 3233:     return static_cast<nsDOMSlots*>(GetSlots());
    1:   }
    1: 
    1:   nsDOMSlots *GetExistingDOMSlots() const
    1:   {
 3233:     return static_cast<nsDOMSlots*>(GetExistingSlots());
    1:   }
    1: 
28108:   void RegisterFreezableElement() {
80527:     OwnerDoc()->RegisterFreezableElement(this);
28108:   }
28108:   void UnregisterFreezableElement() {
80527:     OwnerDoc()->UnregisterFreezableElement(this);
28108:   }
28108: 
    1:   /**
43079:    * Add/remove this element to the documents id cache
    1:    */
43079:   void AddToIdTable(nsIAtom* aId) {
67607:     NS_ASSERTION(HasID(), "Node doesn't have an ID?");
43079:     nsIDocument* doc = GetCurrentDoc();
43079:     if (doc && (!IsInAnonymousSubtree() || doc->IsXUL())) {
43079:       doc->AddToIdTable(this, aId);
43079:     }
43079:   }
43079:   void RemoveFromIdTable() {
67607:     if (HasID()) {
43079:       nsIDocument* doc = GetCurrentDoc();
43079:       if (doc) {
43079:         nsIAtom* id = DoGetID();
43079:         // id can be null during mutation events evilness. Also, XUL elements
43079:         // loose their proto attributes during cc-unlink, so this can happen
43079:         // during cc-unlink too.
43079:         if (id) {
43079:           doc->RemoveFromIdTable(this, DoGetID());
43079:         }
43079:       }
43079:     }
43079:   }
    1: 
    1:   /**
  723:    * Functions to carry out event default actions for links of all types
    1:    * (HTML links, XLinks, SVG "XLinks", etc.)
    1:    */
  723: 
  723:   /**
  723:    * Check that we meet the conditions to handle a link event
  723:    * and that we are actually on a link.
  723:    *
  723:    * @param aVisitor event visitor
80486:    * @param aURI the uri of the link, set only if the return value is true [OUT]
80486:    * @return true if we can handle the link event, false otherwise
  723:    */
79445:   bool CheckHandleEventForLinksPrecondition(nsEventChainVisitor& aVisitor,
  723:                                               nsIURI** aURI) const;
  723: 
  723:   /**
  723:    * Handle status bar updates before they can be cancelled.
  723:    */
  723:   nsresult PreHandleEventForLinks(nsEventChainPreVisitor& aVisitor);
  723: 
  723:   /**
  723:    * Handle default actions for link event if the event isn't consumed yet.
  723:    */
    1:   nsresult PostHandleEventForLinks(nsEventChainPostVisitor& aVisitor);
    1: 
    1:   /**
    1:    * Get the target of this link element. Consumers should established that
    1:    * this element is a link (probably using IsLink) before calling this
    1:    * function (or else why call it?)
    1:    *
    1:    * Note: for HTML this gets the value of the 'target' attribute; for XLink
    1:    * this gets the value of the xlink:_moz_target attribute, or failing that,
    1:    * the value of xlink:show, converted to a suitably equivalent named target
    1:    * (e.g. _blank).
    1:    */
    1:   virtual void GetLinkTarget(nsAString& aTarget);
    1: 
    1:   /**
    1:    * Array containing all attributes and children for this element
    1:    */
    1:   nsAttrAndChildArray mAttrsAndChildren;
41910: 
41910: private:
41910:   /**
41910:    * Get this element's client area rect in app units.
41910:    * @return the frame's client area
41910:    */
41910:   nsRect GetClientAreaRect();
41910: 
41910:   nsIScrollableFrame* GetScrollFrame(nsIFrame **aStyledFrame = nsnull);
41910: 
41910:   nsContentList* GetChildrenList();
    1: };
    1: 
    1: /**
    1:  * Macros to implement Clone(). _elementName is the class for which to implement
    1:  * Clone.
    1:  */
    1: #define NS_IMPL_ELEMENT_CLONE(_elementName)                                 \
    1: nsresult                                                                    \
    1: _elementName::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const        \
    1: {                                                                           \
    1:   *aResult = nsnull;                                                        \
48124:   nsCOMPtr<nsINodeInfo> ni = aNodeInfo;                                     \
48124:   _elementName *it = new _elementName(ni.forget());                         \
    1:   if (!it) {                                                                \
    1:     return NS_ERROR_OUT_OF_MEMORY;                                          \
    1:   }                                                                         \
    1:                                                                             \
    1:   nsCOMPtr<nsINode> kungFuDeathGrip = it;                                   \
    1:   nsresult rv = CopyInnerTo(it);                                            \
    1:   if (NS_SUCCEEDED(rv)) {                                                   \
    1:     kungFuDeathGrip.swap(*aResult);                                         \
    1:   }                                                                         \
    1:                                                                             \
    1:   return rv;                                                                \
    1: }
    1: 
    1: #define NS_IMPL_ELEMENT_CLONE_WITH_INIT(_elementName)                       \
    1: nsresult                                                                    \
    1: _elementName::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const        \
    1: {                                                                           \
    1:   *aResult = nsnull;                                                        \
48124:   nsCOMPtr<nsINodeInfo> ni = aNodeInfo;                                     \
48124:   _elementName *it = new _elementName(ni.forget());                         \
    1:   if (!it) {                                                                \
    1:     return NS_ERROR_OUT_OF_MEMORY;                                          \
    1:   }                                                                         \
    1:                                                                             \
    1:   nsCOMPtr<nsINode> kungFuDeathGrip = it;                                   \
    1:   nsresult rv = it->Init();                                                 \
    1:   rv |= CopyInnerTo(it);                                                    \
    1:   if (NS_SUCCEEDED(rv)) {                                                   \
    1:     kungFuDeathGrip.swap(*aResult);                                         \
    1:   }                                                                         \
    1:                                                                             \
    1:   return rv;                                                                \
    1: }
    1: 
48124: #define DOMCI_NODE_DATA(_interface, _class)                             \
48124:   DOMCI_DATA(_interface, _class)                                        \
48124:   nsXPCClassInfo* _class::GetClassInfo()                                \
48124:   {                                                                     \
48124:     return static_cast<nsXPCClassInfo*>(                                \
48124:       NS_GetDOMClassInfoInstance(eDOMClassInfo_##_interface##_id));     \
48124:   }
48124: 
 2014: /**
77147:  * Tearoff class to implement nsITouchEventReceiver
77147:  */
77147: class nsTouchEventReceiverTearoff : public nsITouchEventReceiver
77147: {
77147: public:
77147:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
77147: 
77149:   NS_FORWARD_NSITOUCHEVENTRECEIVER(mElement->)
77147: 
77147:   NS_DECL_CYCLE_COLLECTION_CLASS(nsTouchEventReceiverTearoff)
77147: 
77147:   nsTouchEventReceiverTearoff(nsGenericElement *aElement) : mElement(aElement)
77147:   {
77147:   }
77147: 
77147: private:
77147:   nsRefPtr<nsGenericElement> mElement;
77147: };
77147: 
77149: /**
77149:  * Tearoff class to implement nsIInlineEventHandlers
77149:  */
77149: class nsInlineEventHandlersTearoff : public nsIInlineEventHandlers
77149: {
77149: public:
77149:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
77149: 
77149:   NS_FORWARD_NSIINLINEEVENTHANDLERS(mElement->)
77149: 
77149:   NS_DECL_CYCLE_COLLECTION_CLASS(nsInlineEventHandlersTearoff)
77149: 
77149:   nsInlineEventHandlersTearoff(nsGenericElement *aElement) : mElement(aElement)
77149:   {
77149:   }
77149: 
77149: private:
77149:   nsRefPtr<nsGenericElement> mElement;
77149: };
77149: 
21218: #define NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE                               \
21218:     rv = nsGenericElement::QueryInterface(aIID, aInstancePtr);                \
21218:     if (NS_SUCCEEDED(rv))                                                     \
21218:       return rv;                                                              \
21218:                                                                               \
21218:     NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: #define NS_ELEMENT_INTERFACE_MAP_END                                          \
21218:     {                                                                         \
21218:       return PostQueryInterface(aIID, aInstancePtr);                          \
21218:     }                                                                         \
21218:                                                                               \
21218:     NS_ADDREF(foundInterface);                                                \
21218:                                                                               \
21218:     *aInstancePtr = foundInterface;                                           \
21218:                                                                               \
21218:     return NS_OK;                                                             \
21218:   }
21218: 
    1: #endif /* nsGenericElement_h___ */
