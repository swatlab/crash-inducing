     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 27664: /* vim: set ts=2 sw=2 et tw=79: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * Base class for all element classes; this provides an implementation
     1:  * of DOM Core's nsIDOMElement, implements nsIContent, provides
     1:  * utility methods for subclasses, and so forth.
     1:  */
     1: 
 80467: #include "mozilla/Util.h"
 80467: 
     1: #include "nsGenericElement.h"
     1: 
     1: #include "nsDOMAttribute.h"
     1: #include "nsDOMAttributeMap.h"
     1: #include "nsIAtom.h"
 94340: #include "nsINodeInfo.h"
     1: #include "nsIDocument.h"
     1: #include "nsIDOMNodeList.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIContentIterator.h"
 72328: #include "nsEventListenerManager.h"
 29018: #include "nsFocusManager.h"
     1: #include "nsILinkHandler.h"
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsIURL.h"
     1: #include "nsNetUtil.h"
     1: #include "nsIFrame.h"
 38069: #include "nsIAnonymousContentCreator.h"
     1: #include "nsIPresShell.h"
     1: #include "nsPresContext.h"
     1: #include "nsStyleConsts.h"
     1: #include "nsString.h"
     1: #include "nsUnicharUtils.h"
 68780: #include "nsEventStateManager.h"
     1: #include "nsIDOMEvent.h"
     1: #include "nsDOMCID.h"
     1: #include "nsIServiceManager.h"
     1: #include "nsIDOMCSSStyleDeclaration.h"
 32193: #include "nsDOMCSSAttrDeclaration.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsContentList.h"
 31383: #include "nsDOMTokenList.h"
 62344: #include "nsXBLPrototypeBinding.h"
     1: #include "nsDOMError.h"
     1: #include "nsDOMString.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsIDOMMutationEvent.h"
     1: #include "nsMutationEvent.h"
     1: #include "nsNodeUtils.h"
     1: #include "nsDocument.h"
 90059: #include "nsAttrValueOrString.h"
  3244: #ifdef MOZ_XUL
  1498: #include "nsXULElement.h"
  3244: #endif /* MOZ_XUL */
  6186: #include "nsFrameManager.h"
 11914: #include "nsFrameSelection.h"
 85101: #ifdef DEBUG
 86939: #include "nsRange.h"
 85101: #endif
     1: 
     1: #include "nsBindingManager.h"
     1: #include "nsXBLBinding.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsPIBoxObject.h"
 12913: #include "nsClientRect.h"
  2014: #include "nsSVGUtils.h"
  2014: #include "nsLayoutUtils.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsContentUtils.h"
     1: #include "nsIJSContextStack.h"
     1: 
     1: #include "nsIDOMEventListener.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIBaseWindow.h"
 82843: #include "nsIWidget.h"
     1: 
     1: #include "jsapi.h"
     1: 
     1: #include "nsNodeInfoManager.h"
     1: #include "nsICategoryManager.h"
     1: #include "nsIDOMDocumentType.h"
     1: #include "nsIDOMUserDataHandler.h"
 24836: #include "nsGenericHTMLElement.h"
 11914: #include "nsIEditor.h"
 41886: #include "nsIEditorIMESupport.h"
 11914: #include "nsIEditorDocShell.h"
     1: #include "nsEventDispatcher.h"
     1: #include "nsContentCreatorFunctions.h"
     1: #include "nsIControllers.h"
 16722: #include "nsIView.h"
 16722: #include "nsIViewManager.h"
 16722: #include "nsIScrollableFrame.h"
  1685: #include "nsXBLInsertionPoint.h"
 63693: #include "mozilla/css/StyleRule.h" /* For nsCSSSelectorList */
 16106: #include "nsCSSRuleProcessor.h"
 30988: #include "nsRuleProcessorData.h"
 84833: #include "nsAsyncDOMEvent.h"
 76359: #include "nsTextNode.h"
 80067: #include "dombindings.h"
 16106: 
  3244: #ifdef MOZ_XUL
  1839: #include "nsIXULDocument.h"
  3244: #endif /* MOZ_XUL */
     1: 
     1: #include "nsCycleCollectionParticipant.h"
  1353: #include "nsCCUncollectableMarker.h"
     1: 
 14228: #include "mozAutoDocUpdate.h"
 14228: 
 38849: #include "nsCSSParser.h"
 53873: #include "prprf.h"
 94465: #include "nsDOMMutationObserver.h"
 28081: #include "nsSVGFeatures.h"
 80074: #include "nsWrapperCacheInlines.h"
 88521: #include "nsCycleCollector.h"
 77149: #include "xpcpublic.h"
 98838: #include "nsIScriptError.h"
 91256: #include "nsLayoutStatics.h"
 91256: #include "mozilla/Telemetry.h"
 77149: 
 91989: #include "mozilla/CORSMode.h"
 91989: 
 93755: #include "nsStyledElement.h"
 93755: 
 80467: using namespace mozilla;
 41634: using namespace mozilla::dom;
     1: 
 21218: NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
 21218: 
     1: PRInt32 nsIContent::sTabFocusModel = eTabFocus_any;
 79445: bool nsIContent::sTabFocusModelAppliesToXUL = false;
 27150: PRUint32 nsMutationGuard::sMutationCount = 0;
 27150: 
     1: //----------------------------------------------------------------------
     1: 
     1: nsINode::nsSlots::~nsSlots()
     1: {
     1:   if (mChildNodes) {
     1:     mChildNodes->DropReference();
     1:     NS_RELEASE(mChildNodes);
     1:   }
     1: 
     1:   if (mWeakReference) {
     1:     mWeakReference->NoticeNodeDestruction();
     1:   }
     1: }
     1: 
 77323: void
 77323: nsINode::nsSlots::Traverse(nsCycleCollectionTraversalCallback &cb)
 77323: {
 77323:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mSlots->mChildNodes");
 77323:   cb.NoteXPCOMChild(mChildNodes);
 77323: }
 77323: 
 77323: void
 77323: nsINode::nsSlots::Unlink()
 77323: {
 77323:   if (mChildNodes) {
 77323:     mChildNodes->DropReference();
 77323:     NS_RELEASE(mChildNodes);
 77323:   }
 77323: }
 77323: 
     1: //----------------------------------------------------------------------
     1: 
     1: nsINode::~nsINode()
     1: {
     1:   NS_ASSERTION(!HasSlots(), "nsNodeUtils::LastRelease was not called?");
 93101:   NS_ASSERTION(mSubtreeRoot == this, "Didn't restore state properly?");
     1: }
     1: 
     1: void*
     1: nsINode::GetProperty(PRUint16 aCategory, nsIAtom *aPropertyName,
     1:                      nsresult *aStatus) const
     1: {
 80527:   return OwnerDoc()->PropertyTable(aCategory)->GetProperty(this, aPropertyName,
     1:                                                            aStatus);
     1: }
     1: 
     1: nsresult
     1: nsINode::SetProperty(PRUint16 aCategory, nsIAtom *aPropertyName, void *aValue,
 79445:                      NSPropertyDtorFunc aDtor, bool aTransfer,
     1:                      void **aOldValue)
     1: {
 80527:   nsresult rv = OwnerDoc()->PropertyTable(aCategory)->SetProperty(this,
 80527:                                                                   aPropertyName,
 80527:                                                                   aValue, aDtor,
 80527:                                                                   nsnull,
 80527:                                                                   aTransfer,
 80527:                                                                   aOldValue);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     SetFlags(NODE_HAS_PROPERTIES);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
 43457: void
     1: nsINode::DeleteProperty(PRUint16 aCategory, nsIAtom *aPropertyName)
     1: {
 80527:   OwnerDoc()->PropertyTable(aCategory)->DeleteProperty(this, aPropertyName);
     1: }
     1: 
     1: void*
     1: nsINode::UnsetProperty(PRUint16 aCategory, nsIAtom *aPropertyName,
     1:                        nsresult *aStatus)
     1: {
 80527:   return OwnerDoc()->PropertyTable(aCategory)->UnsetProperty(this,
 80527:                                                              aPropertyName,
     1:                                                              aStatus);
     1: }
     1: 
     1: nsINode::nsSlots*
     1: nsINode::CreateSlots()
     1: {
 67604:   return new nsSlots();
     1: }
     1: 
 79445: bool
  3333: nsINode::IsEditableInternal() const
  3333: {
  3333:   if (HasFlag(NODE_IS_EDITABLE)) {
  3333:     // The node is in an editable contentEditable subtree.
 80486:     return true;
  3333:   }
  3333: 
  3333:   nsIDocument *doc = GetCurrentDoc();
  3333: 
  3333:   // Check if the node is in a document and the document is in designMode.
  3333:   return doc && doc->HasFlag(NODE_IS_EDITABLE);
  3333: }
  3333: 
 11914: static nsIContent* GetEditorRootContent(nsIEditor* aEditor)
 11914: {
 11914:   nsCOMPtr<nsIDOMElement> rootElement;
 11914:   aEditor->GetRootElement(getter_AddRefs(rootElement));
 11914:   nsCOMPtr<nsIContent> rootContent(do_QueryInterface(rootElement));
 11914:   return rootContent;
 11914: }
 11914: 
 11914: nsIContent*
 11914: nsINode::GetTextEditorRootContent(nsIEditor** aEditor)
 11914: {
 11914:   if (aEditor)
 11914:     *aEditor = nsnull;
 11914:   for (nsINode* node = this; node; node = node->GetNodeParent()) {
 41636:     if (!node->IsElement() ||
 41636:         !node->AsElement()->IsHTML())
 11914:       continue;
 11914: 
 11914:     nsCOMPtr<nsIEditor> editor;
 24836:     static_cast<nsGenericHTMLElement*>(node)->
 24836:         GetEditorInternal(getter_AddRefs(editor));
 24836:     if (!editor)
 24836:       continue;
 24836: 
 11914:     nsIContent* rootContent = GetEditorRootContent(editor);
 11914:     if (aEditor)
 11914:       editor.swap(*aEditor);
 11914:     return rootContent;
 11914:   }
 11914:   return nsnull;
 11914: }
 11914: 
 11914: static nsIEditor* GetHTMLEditor(nsPresContext* aPresContext)
 11914: {
 11914:   nsCOMPtr<nsISupports> container = aPresContext->GetContainer();
 11914:   nsCOMPtr<nsIEditorDocShell> editorDocShell(do_QueryInterface(container));
 79445:   bool isEditable;
 11914:   if (!editorDocShell ||
 11914:       NS_FAILED(editorDocShell->GetEditable(&isEditable)) || !isEditable)
 11914:     return nsnull;
 11914: 
 11914:   nsCOMPtr<nsIEditor> editor;
 11914:   editorDocShell->GetEditor(getter_AddRefs(editor));
 11914:   return editor;
 11914: }
 11914: 
 35608: static nsIContent* GetRootForContentSubtree(nsIContent* aContent)
 35608: {
 35608:   NS_ENSURE_TRUE(aContent, nsnull);
 35608:   nsIContent* stop = aContent->GetBindingParent();
 35608:   while (aContent) {
 35608:     nsIContent* parent = aContent->GetParent();
 35608:     if (parent == stop) {
 35608:       break;
 35608:     }
 35608:     aContent = parent;
 35608:   }
 35608:   return aContent;
 35608: }
 35608: 
 11914: nsIContent*
 11914: nsINode::GetSelectionRootContent(nsIPresShell* aPresShell)
 11914: {
 11914:   NS_ENSURE_TRUE(aPresShell, nsnull);
 11914: 
 11914:   if (IsNodeOfType(eDOCUMENT))
 41634:     return static_cast<nsIDocument*>(this)->GetRootElement();
 11914:   if (!IsNodeOfType(eCONTENT))
 11914:     return nsnull;
 11914: 
 37336:   if (GetCurrentDoc() != aPresShell->GetDocument()) {
 37336:     return nsnull;
 37336:   }
 36945: 
 48083:   if (static_cast<nsIContent*>(this)->HasIndependentSelection()) {
 11914:     // This node should be a descendant of input/textarea editor.
 11914:     nsIContent* content = GetTextEditorRootContent();
 11914:     if (content)
 11914:       return content;
 11914:   }
 11914: 
 11914:   nsPresContext* presContext = aPresShell->GetPresContext();
 11914:   if (presContext) {
 11914:     nsIEditor* editor = GetHTMLEditor(presContext);
 11914:     if (editor) {
 11914:       // This node is in HTML editor.
 11914:       nsIDocument* doc = GetCurrentDoc();
 35608:       if (!doc || doc->HasFlag(NODE_IS_EDITABLE) ||
 35608:           !HasFlag(NODE_IS_EDITABLE)) {
 35608:         nsIContent* editorRoot = GetEditorRootContent(editor);
 36323:         NS_ENSURE_TRUE(editorRoot, nsnull);
 35608:         return nsContentUtils::IsInSameAnonymousTree(this, editorRoot) ?
 35608:                  editorRoot :
 35608:                  GetRootForContentSubtree(static_cast<nsIContent*>(this));
 35608:       }
 48083:       // If the document isn't editable but this is editable, this is in
 48083:       // contenteditable.  Use the editing host element for selection root.
 48083:       return static_cast<nsIContent*>(this)->GetEditingHost();
 11914:     }
 11914:   }
 11914: 
 70097:   nsRefPtr<nsFrameSelection> fs = aPresShell->FrameSelection();
 11914:   nsIContent* content = fs->GetLimiter();
 35608:   if (!content) {
 11914:     content = fs->GetAncestorLimiter();
 35608:     if (!content) {
 11914:       nsIDocument* doc = aPresShell->GetDocument();
 11914:       NS_ENSURE_TRUE(doc, nsnull);
 41634:       content = doc->GetRootElement();
 35608:       if (!content)
 35608:         return nsnull;
 35608:     }
 35608:   }
 35608: 
 35608:   // This node might be in another subtree, if so, we should find this subtree's
 35608:   // root.  Otherwise, we can return the content simply.
 36323:   NS_ENSURE_TRUE(content, nsnull);
 35608:   return nsContentUtils::IsInSameAnonymousTree(this, content) ?
 35608:            content : GetRootForContentSubtree(static_cast<nsIContent*>(this));
 11914: }
 11914: 
 24403: nsINodeList*
 23258: nsINode::GetChildNodesList()
 23258: {
 23258:   nsSlots *slots = GetSlots();
 23258:   if (!slots) {
 23258:     return nsnull;
 23258:   }
 23258: 
 23258:   if (!slots->mChildNodes) {
 23258:     slots->mChildNodes = new nsChildContentList(this);
 23258:     if (slots->mChildNodes) {
 23258:       NS_ADDREF(slots->mChildNodes);
 23258:     }
 23258:   }
 23258: 
 23258:   return slots->mChildNodes;
 23258: }
 23258: 
 27664: #ifdef DEBUG
 27664: void
 27664: nsINode::CheckNotNativeAnonymous() const
 27664: {
 27664:   if (!IsNodeOfType(eCONTENT))
 27664:     return;
 27664:   nsIContent* content = static_cast<const nsIContent *>(this)->GetBindingParent();
 27664:   while (content) {
 27664:     if (content->IsRootOfNativeAnonymousSubtree()) {
 27664:       NS_ERROR("Element not marked to be in native anonymous subtree!");
 27664:       break;
 27664:     }
 27664:     content = content->GetBindingParent();
 27664:   }
 27664: }
 27664: #endif
 27664: 
 23258: nsresult
 23258: nsINode::GetParentNode(nsIDOMNode** aParentNode)
 23258: {
 23258:   *aParentNode = nsnull;
 23258: 
 23258:   nsINode *parent = GetNodeParent();
 23258: 
 23258:   return parent ? CallQueryInterface(parent, aParentNode) : NS_OK;
 23258: }
 23258: 
 23258: nsresult
 78189: nsINode::GetParentElement(nsIDOMElement** aParentElement)
 78189: {
 78189:   *aParentElement = nsnull;
 78189:   nsINode* parent = GetElementParent();
 78189:   return parent ? CallQueryInterface(parent, aParentElement) : NS_OK;
 78189: }
 78189: 
 78189: nsresult
 23258: nsINode::GetChildNodes(nsIDOMNodeList** aChildNodes)
 23258: {
 23258:   *aChildNodes = GetChildNodesList();
 23258:   if (!*aChildNodes) {
 23258:     return NS_ERROR_OUT_OF_MEMORY;
 23258:   }
 23258: 
 23258:   NS_ADDREF(*aChildNodes);
 23258: 
 23258:   return NS_OK;
 23258: }
 23258: 
 23258: nsresult
 23258: nsINode::GetFirstChild(nsIDOMNode** aNode)
 23258: {
 78992:   nsIContent* child = GetFirstChild();
 23258:   if (child) {
 23258:     return CallQueryInterface(child, aNode);
 23258:   }
 23258: 
 23258:   *aNode = nsnull;
 23258: 
 23258:   return NS_OK;
 23258: }
 23258: 
 23258: nsresult
 23258: nsINode::GetLastChild(nsIDOMNode** aNode)
 23258: {
 23258:   nsIContent* child = GetLastChild();
 23258:   if (child) {
 23258:     return CallQueryInterface(child, aNode);
 23258:   }
 23258: 
 23258:   *aNode = nsnull;
 23258: 
 23258:   return NS_OK;
 23258: }
 23258: 
 23258: nsresult
 23258: nsINode::GetPreviousSibling(nsIDOMNode** aPrevSibling)
 23258: {
 23258:   *aPrevSibling = nsnull;
 23258: 
 42872:   nsIContent *sibling = GetPreviousSibling();
 23258: 
 23258:   return sibling ? CallQueryInterface(sibling, aPrevSibling) : NS_OK;
 23258: }
 23258: 
 23258: nsresult
 23258: nsINode::GetNextSibling(nsIDOMNode** aNextSibling)
 23258: {
 23258:   *aNextSibling = nsnull;
 23258: 
 42872:   nsIContent *sibling = GetNextSibling();
 23258: 
 23258:   return sibling ? CallQueryInterface(sibling, aNextSibling) : NS_OK;
 23258: }
 23258: 
 23258: nsresult
 23258: nsINode::GetOwnerDocument(nsIDOMDocument** aOwnerDocument)
 23258: {
 23258:   *aOwnerDocument = nsnull;
 23258: 
 23258:   nsIDocument *ownerDoc = GetOwnerDocument();
 23258: 
 23258:   return ownerDoc ? CallQueryInterface(ownerDoc, aOwnerDocument) : NS_OK;
 23258: }
 23258: 
 39585: nsresult
 69573: nsINode::RemoveChild(nsINode *aOldChild)
 69573: {
 69573:   if (!aOldChild) {
 69573:     return NS_ERROR_NULL_POINTER;
 69573:   }
 69573: 
 69573:   if (IsNodeOfType(eDATA_NODE)) {
 69573:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
 69573:   }
 69573: 
 69573:   if (aOldChild && aOldChild->GetNodeParent() == this) {
 80526:     nsContentUtils::MaybeFireNodeRemoved(aOldChild, this, OwnerDoc());
 69573:   }
 69573: 
 69573:   PRInt32 index = IndexOf(aOldChild);
 69573:   if (index == -1) {
 69573:     // aOldChild isn't one of our children.
 69573:     return NS_ERROR_DOM_NOT_FOUND_ERR;
 69573:   }
 69573: 
 94359:   RemoveChildAt(index, true);
 94359:   return NS_OK;
 69573: }
 69573: 
 69573: nsresult
 79445: nsINode::ReplaceOrInsertBefore(bool aReplace, nsIDOMNode* aNewChild,
 39585:                                nsIDOMNode* aRefChild, nsIDOMNode** aReturn)
 39585: {
 39585:   nsCOMPtr<nsINode> newChild = do_QueryInterface(aNewChild);
 39585: 
 39585:   nsresult rv;
 39585:   nsCOMPtr<nsINode> refChild;
 39585:   if (aRefChild) {
 39585:       refChild = do_QueryInterface(aRefChild, &rv);
 39585:       NS_ENSURE_SUCCESS(rv, rv);
 39585:   }
 39585: 
 39585:   rv = ReplaceOrInsertBefore(aReplace, newChild, refChild);
 39585:   if (NS_SUCCEEDED(rv)) {
 39585:     NS_ADDREF(*aReturn = aReplace ? aRefChild : aNewChild);
 39585:   }
 39585: 
 39585:   return rv;
 39585: }
 39585: 
 39585: nsresult
 39585: nsINode::RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
 39585: {
 39585:   nsCOMPtr<nsIContent> oldChild = do_QueryInterface(aOldChild);
 39585:   nsresult rv = RemoveChild(oldChild);
 39585:   if (NS_SUCCEEDED(rv)) {
 39585:     NS_ADDREF(*aReturn = aOldChild);
 39585:   }
 39585:   return rv;
 39585: }
 39585: 
 71768: nsresult
 72437: nsINode::Normalize()
 72437: {
 72437:   // First collect list of nodes to be removed
 72437:   nsAutoTArray<nsCOMPtr<nsIContent>, 50> nodes;
 72437: 
 79445:   bool canMerge = false;
 72437:   for (nsIContent* node = this->GetFirstChild();
 72437:        node;
 72437:        node = node->GetNextNode(this)) {
 72437:     if (node->NodeType() != nsIDOMNode::TEXT_NODE) {
 80486:       canMerge = false;
 72437:       continue;
 72437:     }
 72437: 
 72437:     if (canMerge || node->TextLength() == 0) {
 72437:       // No need to touch canMerge. That way we can merge across empty
 72437:       // textnodes if and only if the node before is a textnode
 72437:       nodes.AppendElement(node);
 72437:     }
 72437:     else {
 80486:       canMerge = true;
 72437:     }
 72437: 
 72437:     // If there's no following sibling, then we need to ensure that we don't
 72437:     // collect following siblings of our (grand)parent as to-be-removed
 72437:     canMerge = canMerge && !!node->GetNextSibling();
 72437:   }
 72437: 
 72437:   if (nodes.IsEmpty()) {
 72437:     return NS_OK;
 72437:   }
 72437: 
 72437:   // We're relying on mozAutoSubtreeModified to keep the doc alive here.
 80526:   nsIDocument* doc = OwnerDoc();
 72437: 
 72437:   // Batch possible DOMSubtreeModified events.
 72437:   mozAutoSubtreeModified subtree(doc, nsnull);
 72437: 
 72437:   // Fire all DOMNodeRemoved events. Optimize the common case of there being
 72437:   // no listeners
 79445:   bool hasRemoveListeners = nsContentUtils::
 72437:       HasMutationListeners(doc, NS_EVENT_BITS_MUTATION_NODEREMOVED);
 72437:   if (hasRemoveListeners) {
 72437:     for (PRUint32 i = 0; i < nodes.Length(); ++i) {
 72437:       nsContentUtils::MaybeFireNodeRemoved(nodes[i], nodes[i]->GetNodeParent(),
 72437:                                            doc);
 72437:     }
 72437:   }
 72437: 
 80486:   mozAutoDocUpdate batch(doc, UPDATE_CONTENT_MODEL, true);
 72437: 
 72437:   // Merge and remove all nodes
 72437:   nsAutoString tmpStr;
 72437:   for (PRUint32 i = 0; i < nodes.Length(); ++i) {
 72437:     nsIContent* node = nodes[i];
 72437:     // Merge with previous node unless empty
 72437:     const nsTextFragment* text = node->GetText();
 72437:     if (text->GetLength()) {
 72437:       nsIContent* target = node->GetPreviousSibling();
 72437:       NS_ASSERTION((target && target->NodeType() == nsIDOMNode::TEXT_NODE) ||
 72437:                    hasRemoveListeners,
 72437:                    "Should always have a previous text sibling unless "
 72437:                    "mutation events messed us up");
 72437:       if (!hasRemoveListeners ||
 72437:           (target && target->NodeType() == nsIDOMNode::TEXT_NODE)) {
 76359:         nsTextNode* t = static_cast<nsTextNode*>(target);
 72437:         if (text->Is2b()) {
 80486:           t->AppendTextForNormalize(text->Get2b(), text->GetLength(), true, node);
 72437:         }
 72437:         else {
 72437:           tmpStr.Truncate();
 72437:           text->AppendTo(tmpStr);
 80486:           t->AppendTextForNormalize(tmpStr.get(), tmpStr.Length(), true, node);
 72437:         }
 72437:       }
 72437:     }
 72437: 
 72437:     // Remove node
 77014:     nsCOMPtr<nsINode> parent = node->GetNodeParent();
 72437:     NS_ASSERTION(parent || hasRemoveListeners,
 72437:                  "Should always have a parent unless "
 72437:                  "mutation events messed us up");
 72437:     if (parent) {
 80486:       parent->RemoveChildAt(parent->IndexOf(node), true);
 72437:     }
 72437:   }
 72437: 
 72437:   return NS_OK;
 72437: }
 72437: 
 72437: nsresult
 71768: nsINode::GetDOMBaseURI(nsAString &aURI) const
 41900: {
 41900:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
 41900: 
 41900:   nsCAutoString spec;
 41900:   if (baseURI) {
 41900:     baseURI->GetSpec(spec);
 41900:   }
 41900: 
 41900:   CopyUTF8toUTF16(spec, aURI);
 71768: 
 71768:   return NS_OK;
 71768: }
 71768: 
 71768: nsresult
 41904: nsINode::LookupPrefix(const nsAString& aNamespaceURI, nsAString& aPrefix)
 41904: {
 41904:   Element *element = GetNameSpaceElement();
 71768:   if (element) {
 71768:     // XXX Waiting for DOM spec to list error codes.
 71768:   
 71768:     // Trace up the content parent chain looking for the namespace
 71768:     // declaration that defines the aNamespaceURI namespace. Once found,
 71768:     // return the prefix (i.e. the attribute localName).
 71768:     for (nsIContent* content = element; content;
 71768:          content = content->GetParent()) {
 71768:       PRUint32 attrCount = content->GetAttrCount();
 71768:   
 71768:       for (PRUint32 i = 0; i < attrCount; ++i) {
 71768:         const nsAttrName* name = content->GetAttrNameAt(i);
 71768:   
 71768:         if (name->NamespaceEquals(kNameSpaceID_XMLNS) &&
 71768:             content->AttrValueIs(kNameSpaceID_XMLNS, name->LocalName(),
 71768:                                  aNamespaceURI, eCaseMatters)) {
 71768:           // If the localName is "xmlns", the prefix we output should be
 71768:           // null.
 71768:           nsIAtom *localName = name->LocalName();
 71768:   
 71768:           if (localName != nsGkAtoms::xmlns) {
 71768:             localName->ToString(aPrefix);
 41904:           }
 41904:           else {
 41904:             SetDOMStringToNull(aPrefix);
 41904:           }
 71768:           return NS_OK;
 71768:         }
 71768:       }
 71768:     }
 71768:   }
 71768: 
 71768:   SetDOMStringToNull(aPrefix);
 71768: 
 71768:   return NS_OK;
 41904: }
 41904: 
 41901: static nsresult
 41901: SetUserDataProperty(PRUint16 aCategory, nsINode *aNode, nsIAtom *aKey,
 41901:                     nsISupports* aValue, void** aOldValue)
 41901: {
 41901:   nsresult rv = aNode->SetProperty(aCategory, aKey, aValue,
 80486:                                    nsPropertyTable::SupportsDtorFunc, true,
 41901:                                    aOldValue);
 41901:   NS_ENSURE_SUCCESS(rv, rv);
 41901: 
 41901:   // Property table owns it now.
 41901:   NS_ADDREF(aValue);
 41901: 
 41901:   return NS_OK;
 41901: }
 41901: 
 41901: nsresult
 41902: nsINode::SetUserData(const nsAString &aKey, nsIVariant *aData,
 41902:                      nsIDOMUserDataHandler *aHandler, nsIVariant **aResult)
 41901: {
 41901:   *aResult = nsnull;
 41901: 
 41901:   nsCOMPtr<nsIAtom> key = do_GetAtom(aKey);
 41901:   if (!key) {
 41901:     return NS_ERROR_OUT_OF_MEMORY;
 41901:   }
 41901: 
 41901:   nsresult rv;
 41901:   void *data;
 41901:   if (aData) {
 41902:     rv = SetUserDataProperty(DOM_USER_DATA, this, key, aData, &data);
 41901:     NS_ENSURE_SUCCESS(rv, rv);
 41901:   }
 41901:   else {
 41902:     data = UnsetProperty(DOM_USER_DATA, key);
 41901:   }
 41901: 
 41901:   // Take over ownership of the old data from the property table.
 41901:   nsCOMPtr<nsIVariant> oldData = dont_AddRef(static_cast<nsIVariant*>(data));
 41901: 
 41901:   if (aData && aHandler) {
 41901:     nsCOMPtr<nsIDOMUserDataHandler> oldHandler;
 41902:     rv = SetUserDataProperty(DOM_USER_DATA_HANDLER, this, key, aHandler,
 41901:                              getter_AddRefs(oldHandler));
 41901:     if (NS_FAILED(rv)) {
 41901:       // We failed to set the handler, remove the data.
 41902:       DeleteProperty(DOM_USER_DATA, key);
 41901: 
 41901:       return rv;
 41901:     }
 41901:   }
 41901:   else {
 41902:     DeleteProperty(DOM_USER_DATA_HANDLER, key);
 41901:   }
 41901: 
 41901:   oldData.swap(*aResult);
 41901: 
 41901:   return NS_OK;
 41901: }
 41901: 
 41901: PRUint16
 71768: nsINode::CompareDocPosition(nsINode* aOtherNode)
 41906: {
 41906:   NS_PRECONDITION(aOtherNode, "don't pass null");
 41906: 
 41906:   if (this == aOtherNode) {
 41901:     return 0;
 41901:   }
 41901: 
 75183:   nsAutoTArray<nsINode*, 32> parents1, parents2;
 41901: 
 41906:   nsINode *node1 = aOtherNode, *node2 = this;
 41906: 
 41901:   // Check if either node is an attribute
 41901:   nsIAttribute* attr1 = nsnull;
 41906:   if (node1->IsNodeOfType(nsINode::eATTRIBUTE)) {
 41906:     attr1 = static_cast<nsIAttribute*>(node1);
 41901:     nsIContent* elem = attr1->GetContent();
 41901:     // If there is an owner element add the attribute
 41901:     // to the chain and walk up to the element
 41901:     if (elem) {
 41906:       node1 = elem;
 41901:       parents1.AppendElement(static_cast<nsINode*>(attr1));
 41901:     }
 41901:   }
 41906:   if (node2->IsNodeOfType(nsINode::eATTRIBUTE)) {
 41906:     nsIAttribute* attr2 = static_cast<nsIAttribute*>(node2);
 41901:     nsIContent* elem = attr2->GetContent();
 41906:     if (elem == node1 && attr1) {
 41901:       // Both nodes are attributes on the same element.
 41901:       // Compare position between the attributes.
 41901: 
 41901:       PRUint32 i;
 41901:       const nsAttrName* attrName;
 41901:       for (i = 0; (attrName = elem->GetAttrNameAt(i)); ++i) {
 41901:         if (attrName->Equals(attr1->NodeInfo())) {
 41901:           NS_ASSERTION(!attrName->Equals(attr2->NodeInfo()),
 41901:                        "Different attrs at same position");
 71768:           return nsIDOMNode::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
 71768:             nsIDOMNode::DOCUMENT_POSITION_PRECEDING;
 41901:         }
 41901:         if (attrName->Equals(attr2->NodeInfo())) {
 71768:           return nsIDOMNode::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
 71768:             nsIDOMNode::DOCUMENT_POSITION_FOLLOWING;
 41901:         }
 41901:       }
 41901:       NS_NOTREACHED("neither attribute in the element");
 71768:       return nsIDOMNode::DOCUMENT_POSITION_DISCONNECTED;
 41901:     }
 41901: 
 41901:     if (elem) {
 41906:       node2 = elem;
 41901:       parents2.AppendElement(static_cast<nsINode*>(attr2));
 41901:     }
 41901:   }
 41901: 
 41901:   // We now know that both nodes are either nsIContents or nsIDocuments.
 41901:   // If either node started out as an attribute, that attribute will have
 41901:   // the same relative position as its ownerElement, except if the
 41901:   // ownerElement ends up being the container for the other node
 41901: 
 41901:   // Build the chain of parents
 41901:   do {
 41906:     parents1.AppendElement(node1);
 41906:     node1 = node1->GetNodeParent();
 41906:   } while (node1);
 41901:   do {
 41906:     parents2.AppendElement(node2);
 41906:     node2 = node2->GetNodeParent();
 41906:   } while (node2);
 41901: 
 41901:   // Check if the nodes are disconnected.
 41901:   PRUint32 pos1 = parents1.Length();
 41901:   PRUint32 pos2 = parents2.Length();
 41901:   nsINode* top1 = parents1.ElementAt(--pos1);
 41901:   nsINode* top2 = parents2.ElementAt(--pos2);
 41901:   if (top1 != top2) {
 41901:     return top1 < top2 ?
 71768:       (nsIDOMNode::DOCUMENT_POSITION_PRECEDING |
 71768:        nsIDOMNode::DOCUMENT_POSITION_DISCONNECTED |
 71768:        nsIDOMNode::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) :
 71768:       (nsIDOMNode::DOCUMENT_POSITION_FOLLOWING |
 71768:        nsIDOMNode::DOCUMENT_POSITION_DISCONNECTED |
 71768:        nsIDOMNode::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);
 41901:   }
 41901: 
 41901:   // Find where the parent chain differs and check indices in the parent.
 41901:   nsINode* parent = top1;
 41901:   PRUint32 len;
 41901:   for (len = NS_MIN(pos1, pos2); len > 0; --len) {
 41901:     nsINode* child1 = parents1.ElementAt(--pos1);
 41901:     nsINode* child2 = parents2.ElementAt(--pos2);
 41901:     if (child1 != child2) {
 41901:       // child1 or child2 can be an attribute here. This will work fine since
 41901:       // IndexOf will return -1 for the attribute making the attribute be
 41901:       // considered before any child.
 41901:       return parent->IndexOf(child1) < parent->IndexOf(child2) ?
 71768:         static_cast<PRUint16>(nsIDOMNode::DOCUMENT_POSITION_PRECEDING) :
 71768:         static_cast<PRUint16>(nsIDOMNode::DOCUMENT_POSITION_FOLLOWING);
 41901:     }
 41901:     parent = child1;
 41901:   }
 41901: 
 41901:   // We hit the end of one of the parent chains without finding a difference
 41901:   // between the chains. That must mean that one node is an ancestor of the
 41901:   // other. The one with the shortest chain must be the ancestor.
 41901:   return pos1 < pos2 ?
 71768:     (nsIDOMNode::DOCUMENT_POSITION_PRECEDING |
 71768:      nsIDOMNode::DOCUMENT_POSITION_CONTAINS) :
 71768:     (nsIDOMNode::DOCUMENT_POSITION_FOLLOWING |
 71768:      nsIDOMNode::DOCUMENT_POSITION_CONTAINED_BY);    
 71768: }
 71768: 
 79445: bool
 71769: nsINode::IsEqualTo(nsINode* aOther)
 71769: {
 71769:   if (!aOther) {
 80486:     return false;
 71769:   }
 71769: 
 71769:   nsAutoString string1, string2;
 71769: 
 71769:   nsINode* node1 = this;
 71769:   nsINode* node2 = aOther;
 71769:   do {
 71769:     PRUint16 nodeType = node1->NodeType();
 71769:     if (nodeType != node2->NodeType()) {
 80486:       return false;
 71769:     }
 71769: 
 94340:     nsINodeInfo* nodeInfo1 = node1->mNodeInfo;
 94340:     nsINodeInfo* nodeInfo2 = node2->mNodeInfo;
 71772:     if (!nodeInfo1->Equals(nodeInfo2) ||
 71772:         nodeInfo1->GetExtraName() != nodeInfo2->GetExtraName()) {
 80486:       return false;
 71769:     }
 71769: 
 71769:     switch(nodeType) {
 71769:       case nsIDOMNode::ELEMENT_NODE:
 71769:       {
 71769:         // Both are elements (we checked that their nodeinfos are equal). Do the
 71769:         // check on attributes.
 71769:         Element* element1 = node1->AsElement();
 71769:         Element* element2 = node2->AsElement();
 71769:         PRUint32 attrCount = element1->GetAttrCount();
 71769:         if (attrCount != element2->GetAttrCount()) {
 80486:           return false;
 71769:         }
 71769: 
 71769:         // Iterate over attributes.
 71769:         for (PRUint32 i = 0; i < attrCount; ++i) {
 71769:           const nsAttrName* attrName = element1->GetAttrNameAt(i);
 71769: #ifdef DEBUG
 79445:           bool hasAttr =
 71769: #endif
 71769:           element1->GetAttr(attrName->NamespaceID(), attrName->LocalName(),
 71769:                             string1);
 71769:           NS_ASSERTION(hasAttr, "Why don't we have an attr?");
 71769:     
 71769:           if (!element2->AttrValueIs(attrName->NamespaceID(),
 71769:                                      attrName->LocalName(),
 71769:                                      string1,
 71769:                                      eCaseMatters)) {
 80486:             return false;
 71769:           }
 71769:         }
 71769:         break;
 71769:       }
 71769:       case nsIDOMNode::TEXT_NODE:
 71769:       case nsIDOMNode::COMMENT_NODE:
 71769:       case nsIDOMNode::CDATA_SECTION_NODE:
 71769:       case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
 71769:       {
 71769:         string1.Truncate();
 71769:         static_cast<nsIContent*>(node1)->AppendTextTo(string1);
 71769:         string2.Truncate();
 71769:         static_cast<nsIContent*>(node2)->AppendTextTo(string2);
 71769: 
 71769:         if (!string1.Equals(string2)) {
 80486:           return false;
 71769:         }
 71769: 
 71769:         break;
 71769:       }
 71769:       case nsIDOMNode::DOCUMENT_NODE:
 71769:       case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
 71769:         break;
 71769:       case nsIDOMNode::ATTRIBUTE_NODE:
 71769:       {
 71769:         NS_ASSERTION(node1 == this && node2 == aOther,
 71769:                      "Did we come upon an attribute node while walking a "
 71769:                      "subtree?");
 71769:         nsCOMPtr<nsIDOMNode> domNode1 = do_QueryInterface(node1);
 71769:         nsCOMPtr<nsIDOMNode> domNode2 = do_QueryInterface(node2);
 71769:         domNode1->GetNodeValue(string1);
 71769:         domNode2->GetNodeValue(string2);
 71769:         
 71769:         // Returning here as to not bother walking subtree. And there is no
 71769:         // risk that we're half way through walking some other subtree since
 71769:         // attribute nodes doesn't appear in subtrees.
 71769:         return string1.Equals(string2);
 71769:       }
 71769:       case nsIDOMNode::DOCUMENT_TYPE_NODE:
 71769:       {
 71769:         nsCOMPtr<nsIDOMDocumentType> docType1 = do_QueryInterface(node1);
 71769:         nsCOMPtr<nsIDOMDocumentType> docType2 = do_QueryInterface(node2);
 71769:     
 71769:         NS_ASSERTION(docType1 && docType2, "Why don't we have a document type node?");
 71769: 
 71769:         // Public ID
 71769:         docType1->GetPublicId(string1);
 71769:         docType2->GetPublicId(string2);
 71769:         if (!string1.Equals(string2)) {
 80486:           return false;
 71769:         }
 71769:     
 71769:         // System ID
 71769:         docType1->GetSystemId(string1);
 71769:         docType2->GetSystemId(string2);
 71769:         if (!string1.Equals(string2)) {
 80486:           return false;
 71769:         }
 71769:     
 71769:         // Internal subset
 71769:         docType1->GetInternalSubset(string1);
 71769:         docType2->GetInternalSubset(string2);
 71769:         if (!string1.Equals(string2)) {
 80486:           return false;
 71769:         }
 71769: 
 71769:         break;
 71769:       }
 71769:       default:
 80486:         NS_ABORT_IF_FALSE(false, "Unknown node type");
 71769:     }
 71769: 
 71769:     nsINode* nextNode = node1->GetFirstChild();
 71769:     if (nextNode) {
 71769:       node1 = nextNode;
 71769:       node2 = node2->GetFirstChild();
 71769:     }
 71769:     else {
 71769:       if (node2->GetFirstChild()) {
 71769:         // node2 has a firstChild, but node1 doesn't
 80486:         return false;
 71769:       }
 71769: 
 71769:       // Find next sibling, possibly walking parent chain.
 71769:       while (1) {
 71769:         if (node1 == this) {
 71769:           NS_ASSERTION(node2 == aOther, "Should have reached the start node "
 71769:                                         "for both trees at the same time");
 80486:           return true;
 71769:         }
 71769: 
 71769:         nextNode = node1->GetNextSibling();
 71769:         if (nextNode) {
 71769:           node1 = nextNode;
 71769:           node2 = node2->GetNextSibling();
 71769:           break;
 71769:         }
 71769: 
 71769:         if (node2->GetNextSibling()) {
 71769:           // node2 has a nextSibling, but node1 doesn't
 80486:           return false;
 71769:         }
 71769:         
 71769:         node1 = node1->GetNodeParent();
 71769:         node2 = node2->GetNodeParent();
 71769:         NS_ASSERTION(node1 && node2, "no parent while walking subtree");
 71769:       }
 71769:     }
 71769:   } while(node2);
 71769: 
 80486:   return false;
 71769: }
 71769: 
 71768: nsresult
 41904: nsINode::LookupNamespaceURI(const nsAString& aNamespacePrefix,
 41904:                             nsAString& aNamespaceURI)
 41904: {
 41904:   Element *element = GetNameSpaceElement();
 85097:   if (!element ||
 85097:       NS_FAILED(element->LookupNamespaceURIInternal(aNamespacePrefix,
 41904:                                                     aNamespaceURI))) {
 41904:     SetDOMStringToNull(aNamespaceURI);
 41904:   }
 71768: 
 71768:   return NS_OK;
 41904: }
 41904: 
 72324: NS_IMPL_DOMTARGET_DEFAULTS(nsINode)
 72324: 
 72322: NS_IMETHODIMP
 72322: nsINode::AddEventListener(const nsAString& aType,
 72322:                           nsIDOMEventListener *aListener,
 79445:                           bool aUseCapture,
 79445:                           bool aWantsUntrusted,
 72324:                           PRUint8 aOptionalArgc)
 72324: {
 72324:   NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
 72322:                "Won't check if this is chrome, you want to set "
 80486:                "aWantsUntrusted to false or make the aWantsUntrusted "
 72324:                "explicit by making aOptionalArgc non-zero.");
 72322: 
 72329:   if (!aWantsUntrusted &&
 72329:       (aOptionalArgc < 2 &&
 80526:        !nsContentUtils::IsChromeDoc(OwnerDoc()))) {
 80486:     aWantsUntrusted = true;
 80486:   }
 80486: 
 80486:   nsEventListenerManager* listener_manager = GetListenerManager(true);
 72322:   NS_ENSURE_STATE(listener_manager);
 76793:   listener_manager->AddEventListener(aType, aListener, aUseCapture,
 72329:                                      aWantsUntrusted);
 76793:   return NS_OK;
 72322: }
 72322: 
 72324: NS_IMETHODIMP
 82743: nsINode::AddSystemEventListener(const nsAString& aType,
 82743:                                 nsIDOMEventListener *aListener,
 82743:                                 bool aUseCapture,
 82743:                                 bool aWantsUntrusted,
 82743:                                 PRUint8 aOptionalArgc)
 82743: {
 82743:   NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
 82743:                "Won't check if this is chrome, you want to set "
 82743:                "aWantsUntrusted to false or make the aWantsUntrusted "
 82743:                "explicit by making aOptionalArgc non-zero.");
 82743: 
 82743:   if (!aWantsUntrusted &&
 82743:       (aOptionalArgc < 2 &&
 82743:        !nsContentUtils::IsChromeDoc(OwnerDoc()))) {
 82743:     aWantsUntrusted = true;
 82743:   }
 82743: 
 82743:   return NS_AddSystemEventListener(this, aType, aListener, aUseCapture,
 82743:                                    aWantsUntrusted);
 82743: }
 82743: 
 82743: NS_IMETHODIMP
 72324: nsINode::RemoveEventListener(const nsAString& aType,
 72324:                              nsIDOMEventListener* aListener,
 79445:                              bool aUseCapture)
 72324: {
 80486:   nsEventListenerManager* elm = GetListenerManager(false);
 72329:   if (elm) {
 72329:     elm->RemoveEventListener(aType, aListener, aUseCapture);
 72329:   }
 72329:   return NS_OK;
 72324: }
 72324: 
 82743: NS_IMPL_REMOVE_SYSTEM_EVENT_LISTENER(nsINode)
 82743: 
 72324: nsresult
 72324: nsINode::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
 72324: {
 72324:   // This is only here so that we can use the NS_DECL_NSIDOMTARGET macro
 72324:   NS_ABORT();
 72324:   return NS_ERROR_NOT_IMPLEMENTED;
 72324: }
 72324: 
 72324: nsresult
 79445: nsINode::DispatchEvent(nsIDOMEvent *aEvent, bool* aRetVal)
 72324: {
 72329:   // XXX sXBL/XBL2 issue -- do we really want the owner here?  What
 72329:   // if that's the XBL document?  Would we want its presshell?  Or what?
 80526:   nsCOMPtr<nsIDocument> document = OwnerDoc();
 72329: 
 72329:   // Do nothing if the element does not belong to a document
 72329:   if (!document) {
 80486:     *aRetVal = true;
 72329:     return NS_OK;
 72329:   }
 72329: 
 72329:   // Obtain a presentation shell
 72329:   nsIPresShell *shell = document->GetShell();
 72329:   nsRefPtr<nsPresContext> context;
 72329:   if (shell) {
 72329:     context = shell->GetPresContext();
 72329:   }
 72329: 
 72329:   nsEventStatus status = nsEventStatus_eIgnore;
 72329:   nsresult rv =
 72329:     nsEventDispatcher::DispatchDOMEvent(this, nsnull, aEvent, context,
 72329:                                         &status);
 72329:   *aRetVal = (status != nsEventStatus_eConsumeNoDefault);
 72329:   return rv;
 72324: }
 72324: 
 72324: nsresult
 72324: nsINode::PostHandleEvent(nsEventChainPostVisitor& /*aVisitor*/)
 72324: {
 72324:   return NS_OK;
 72324: }
 72324: 
 72324: nsresult
 72324: nsINode::DispatchDOMEvent(nsEvent* aEvent,
 72324:                           nsIDOMEvent* aDOMEvent,
 72324:                           nsPresContext* aPresContext,
 72324:                           nsEventStatus* aEventStatus)
 72324: {
 72324:   return nsEventDispatcher::DispatchDOMEvent(this, aEvent, aDOMEvent,
 72324:                                              aPresContext, aEventStatus);
 72324: }
 72324: 
 72328: nsEventListenerManager*
 79445: nsINode::GetListenerManager(bool aCreateIfNotFound)
 72324: {
 72324:   return nsContentUtils::GetListenerManager(this, aCreateIfNotFound);
 72324: }
 72324: 
 72324: nsIScriptContext*
 72324: nsINode::GetContextForEventHandlers(nsresult* aRv)
 72324: {
 72324:   return nsContentUtils::GetContextForEventHandlers(this, aRv);
 72324: }
 72324: 
 77323: /* static */
 77323: void
 77323: nsINode::Trace(nsINode *tmp, TraceCallback cb, void *closure)
 77323: {
 77323:   nsContentUtils::TraceWrapper(tmp, cb, closure);
 77323: }
 77323: 
 88521: 
 88521: static
 88521: bool UnoptimizableCCNode(nsINode* aNode)
 88521: {
 88521:   const PtrBits problematicFlags = (NODE_IS_ANONYMOUS |
 88521:                                     NODE_IS_IN_ANONYMOUS_SUBTREE |
 88521:                                     NODE_IS_NATIVE_ANONYMOUS_ROOT |
 88521:                                     NODE_MAY_BE_IN_BINDING_MNGR |
 88521:                                     NODE_IS_INSERTION_PARENT);
 88521:   return aNode->HasFlag(problematicFlags) ||
 88521:          aNode->NodeType() == nsIDOMNode::ATTRIBUTE_NODE ||
 88521:          // For strange cases like xbl:content/xbl:children
 88521:          (aNode->IsElement() &&
 88521:           aNode->AsElement()->IsInNamespace(kNameSpaceID_XBL));
 86063: }
 86063: 
 77323: /* static */
 77323: bool
 77323: nsINode::Traverse(nsINode *tmp, nsCycleCollectionTraversalCallback &cb)
 77323: {
 93789:   if (NS_LIKELY(!cb.WantAllTraces())) {
 77323:     nsIDocument *currentDoc = tmp->GetCurrentDoc();
 77323:     if (currentDoc &&
 93789:         nsCCUncollectableMarker::InGeneration(currentDoc->GetMarkedCCGeneration())) {
 77323:       return false;
 77323:     }
 77323: 
 86063:     if (nsCCUncollectableMarker::sGeneration) {
 86063:       // If we're black no need to traverse.
 88521:       if (tmp->IsBlack() || tmp->InCCBlackTree()) {
 86063:         return false;
 86063:       }
 86063: 
 88521:       if (!UnoptimizableCCNode(tmp)) {
 86063:         // If we're in a black document, return early.
 86319:         if ((currentDoc && currentDoc->IsBlack())) {
 86063:           return false;
 86063:         }
 86063:         // If we're not in anonymous content and we have a black parent,
 86063:         // return early.
 86063:         nsIContent* parent = tmp->GetParent();
 88521:         if (parent && !UnoptimizableCCNode(parent) && parent->IsBlack()) {
 86063:           NS_ABORT_IF_FALSE(parent->IndexOf(tmp) >= 0, "Parent doesn't own us?");
 86063:           return false;
 86063:         }
 86063:       }
 86063:     }
 93789:   }
 86063: 
 94340:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
 77323:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(GetParent())
 77323: 
 77323:   nsSlots *slots = tmp->GetExistingSlots();
 77323:   if (slots) {
 77323:     slots->Traverse(cb);
 77323:   }
 77323: 
 77323:   if (tmp->HasProperties()) {
 77323:     nsNodeUtils::TraverseUserData(tmp, cb);
 94465:     nsCOMArray<nsISupports>* objects =
 94465:       static_cast<nsCOMArray<nsISupports>*>(tmp->GetProperty(nsGkAtoms::keepobjectsalive));
 94465:     if (objects) {
 94465:       for (PRInt32 i = 0; i < objects->Count(); ++i) {
 94465:          cb.NoteXPCOMChild(objects->ObjectAt(i));
 94465:       }
 94465:     }
 77323:   }
 77323: 
 91087:   if (tmp->NodeType() != nsIDOMNode::DOCUMENT_NODE &&
 91087:       tmp->HasFlag(NODE_HAS_LISTENERMANAGER)) {
 77323:     nsContentUtils::TraverseListenerManager(tmp, cb);
 77323:   }
 77323: 
 77323:   return true;
 77323: }
 77323: 
 77323: /* static */
 77323: void
 77323: nsINode::Unlink(nsINode *tmp)
 77323: {
 77323:   nsContentUtils::ReleaseWrapper(tmp, tmp);
 77323: 
 77323:   nsSlots *slots = tmp->GetExistingSlots();
 77323:   if (slots) {
 77323:     slots->Unlink();
 77323:   }
 77323: 
 91087:   if (tmp->NodeType() != nsIDOMNode::DOCUMENT_NODE &&
 91087:       tmp->HasFlag(NODE_HAS_LISTENERMANAGER)) {
 77323:     nsContentUtils::RemoveListenerManager(tmp);
 77323:     tmp->UnsetFlags(NODE_HAS_LISTENERMANAGER);
 77323:   }
 77323: 
 77323:   if (tmp->HasProperties()) {
 77323:     nsNodeUtils::UnlinkUserData(tmp);
 94465:     tmp->DeleteProperty(nsGkAtoms::keepobjectsalive);
 77323:   }
 77323: }
 77323: 
     1: //----------------------------------------------------------------------
     1: 
 56168: nsEventStates
 71110: Element::IntrinsicState() const
  2896: {
  3333:   return IsEditable() ? NS_EVENT_STATE_MOZ_READWRITE :
  3333:                         NS_EVENT_STATE_MOZ_READONLY;
  2896: }
  2896: 
  2896: void
 71111: Element::NotifyStateChange(nsEventStates aStates)
 71111: {
 71111:   nsIDocument* doc = GetCurrentDoc();
 71111:   if (doc) {
 71111:     nsAutoScriptBlocker scriptBlocker;
 71111:     doc->ContentStateChanged(this, aStates);
 71111:   }
 71111: }
 71111: 
 71111: void
 71117: Element::UpdateLinkState(nsEventStates aState)
 71117: {
 71117:   NS_ABORT_IF_FALSE(!aState.HasAtLeastOneOfStates(~(NS_EVENT_STATE_VISITED |
 71117:                                                     NS_EVENT_STATE_UNVISITED)),
 71117:                     "Unexpected link state bits");
 71117:   mState =
 71117:     (mState & ~(NS_EVENT_STATE_VISITED | NS_EVENT_STATE_UNVISITED)) |
 71117:     aState;
 71117: }
 71117: 
 71117: void
 71121: Element::UpdateState(bool aNotify)
 71121: {
 71121:   nsEventStates oldState = mState;
 71121:   mState = IntrinsicState() | (oldState & ESM_MANAGED_STATES);
 71121:   if (aNotify) {
 71121:     nsEventStates changedStates = oldState ^ mState;
 71121:     if (!changedStates.IsEmpty()) {
 71121:       nsIDocument* doc = GetCurrentDoc();
 71121:       if (doc) {
 71121:         nsAutoScriptBlocker scriptBlocker;
 71121:         doc->ContentStateChanged(this, changedStates);
 71121:       }
 71121:     }
 71121:   }
 71121: }
 71121: 
 71121: void
 79445: nsIContent::UpdateEditableState(bool aNotify)
 71121: {
 71121:   // Guaranteed to be non-element content
 71121:   NS_ASSERTION(!IsElement(), "What happened here?");
  2896:   nsIContent *parent = GetParent();
  2896: 
  2896:   SetEditableFlag(parent && parent->HasFlag(NODE_IS_EDITABLE));
  2896: }
  2896: 
 71121: void
 79445: nsGenericElement::UpdateEditableState(bool aNotify)
 71121: {
 71121:   nsIContent *parent = GetParent();
 71121: 
 71121:   SetEditableFlag(parent && parent->HasFlag(NODE_IS_EDITABLE));
 71121:   if (aNotify) {
 71121:     UpdateState(aNotify);
 71121:   } else {
 71121:     // Avoid calling UpdateState in this very common case, because
 71121:     // this gets called for pretty much every single element on
 71121:     // insertion into the document and UpdateState can be slow for
 71121:     // some kinds of elements even when not notifying.
 74146:     if (IsEditable()) {
 74146:       RemoveStatesSilently(NS_EVENT_STATE_MOZ_READONLY);
 74146:       AddStatesSilently(NS_EVENT_STATE_MOZ_READWRITE);
 74146:     } else {
 71121:       RemoveStatesSilently(NS_EVENT_STATE_MOZ_READWRITE);
 71121:       AddStatesSilently(NS_EVENT_STATE_MOZ_READONLY);
 71121:     }
 71121:   }
 71121: }
 71121: 
 89714: nsEventStates
 89714: Element::StyleStateFromLocks() const
 89714: {
 89714:   nsEventStates locks = LockedStyleStates();
 89714:   nsEventStates state = mState | locks;
 89714: 
 89714:   if (locks.HasState(NS_EVENT_STATE_VISITED)) {
 89714:     return state & ~NS_EVENT_STATE_UNVISITED;
 89714:   }
 89714:   if (locks.HasState(NS_EVENT_STATE_UNVISITED)) {
 89714:     return state & ~NS_EVENT_STATE_VISITED;
 89714:   }
 89714:   return state;
 89714: }
 89714: 
 89714: nsEventStates
 89714: Element::LockedStyleStates() const
 89714: {
 89714:   nsEventStates *locks =
 89714:     static_cast<nsEventStates*> (GetProperty(nsGkAtoms::lockedStyleStates));
 89714:   if (locks) {
 89714:     return *locks;
 89714:   }
 89714:   return nsEventStates();
 89714: }
 89714: 
 89714: static void
 89714: nsEventStatesPropertyDtor(void *aObject, nsIAtom *aProperty,
 89714:                           void *aPropertyValue, void *aData)
 89714: {
 89714:   nsEventStates *states = static_cast<nsEventStates*>(aPropertyValue);
 89714:   delete states;
 89714: }
 89714: 
 89714: void
 89714: Element::NotifyStyleStateChange(nsEventStates aStates)
 89714: {
 89714:   nsIDocument* doc = GetCurrentDoc();
 89714:   if (doc) {
 89714:     nsIPresShell *presShell = doc->GetShell();
 89714:     if (presShell) {
 89714:       nsAutoScriptBlocker scriptBlocker;
 89714:       presShell->ContentStateChanged(doc, this, aStates);
 89714:     }
 89714:   }
 89714: }
 89714: 
 89714: void
 89714: Element::LockStyleStates(nsEventStates aStates)
 89714: {
 89714:   nsEventStates *locks = new nsEventStates(LockedStyleStates());
 89714: 
 89714:   *locks |= aStates;
 89714: 
 89714:   if (aStates.HasState(NS_EVENT_STATE_VISITED)) {
 89714:     *locks &= ~NS_EVENT_STATE_UNVISITED;
 89714:   }
 89714:   if (aStates.HasState(NS_EVENT_STATE_UNVISITED)) {
 89714:     *locks &= ~NS_EVENT_STATE_VISITED;
 89714:   }
 89714: 
 89714:   SetProperty(nsGkAtoms::lockedStyleStates, locks, nsEventStatesPropertyDtor);
 89714:   SetHasLockedStyleStates();
 89714: 
 89714:   NotifyStyleStateChange(aStates);
 89714: }
 89714: 
 89714: void
 89714: Element::UnlockStyleStates(nsEventStates aStates)
 89714: {
 89714:   nsEventStates *locks = new nsEventStates(LockedStyleStates());
 89714: 
 89714:   *locks &= ~aStates;
 89714: 
 89714:   if (locks->IsEmpty()) {
 89714:     DeleteProperty(nsGkAtoms::lockedStyleStates);
 89714:     ClearHasLockedStyleStates();
 89714:     delete locks;
 89714:   }
 89714:   else {
 89714:     SetProperty(nsGkAtoms::lockedStyleStates, locks, nsEventStatesPropertyDtor);
 89714:   }
 89714: 
 89714:   NotifyStyleStateChange(aStates);
 89714: }
 89714: 
 89714: void
 89714: Element::ClearStyleStateLocks()
 89714: {
 89714:   nsEventStates locks = LockedStyleStates();
 89714: 
 89714:   DeleteProperty(nsGkAtoms::lockedStyleStates);
 89714:   ClearHasLockedStyleStates();
 89714: 
 89714:   NotifyStyleStateChange(locks);
 89714: }
 89714: 
 12250: nsIContent*
 12250: nsIContent::FindFirstNonNativeAnonymous() const
 12250: {
 12250:   // This handles also nested native anonymous content.
 16126:   for (const nsIContent *content = this; content;
 16126:        content = content->GetBindingParent()) {
 16126:     if (!content->IsInNativeAnonymousSubtree()) {
 16126:       // Oops, this function signature allows casting const to
 16126:       // non-const.  (Then again, so does GetChildAt(0)->GetParent().)
 16126:       return const_cast<nsIContent*>(content);
 16126:     }
 16126:   }
 16126:   return nsnull;
 12250: }
 12250: 
 40937: nsIContent*
 40937: nsIContent::GetFlattenedTreeParent() const
 40937: {
 40937:   nsIContent *parent = GetParent();
 40937:   if (parent && parent->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
 80526:     nsIDocument *doc = parent->OwnerDoc();
 40937:     nsIContent* insertionElement =
 40937:       doc->BindingManager()->GetNestedInsertionPoint(parent, this);
 40937:     if (insertionElement) {
 40937:       parent = insertionElement;
 40937:     }
 40937:   }
 40937:   return parent;
 40937: }
 40937: 
 82843: nsIContent::IMEState
 41886: nsIContent::GetDesiredIMEState()
 41886: {
 41886:   if (!IsEditableInternal()) {
 99409:     // Check for the special case where we're dealing with elements which don't
 99409:     // have the editable flag set, but are readwrite (such as text controls).
 99409:     if (!IsElement() ||
 99409:         !AsElement()->State().HasState(NS_EVENT_STATE_MOZ_READWRITE)) {
 82843:       return IMEState(IMEState::DISABLED);
 41886:     }
 99409:   }
 48083:   // NOTE: The content for independent editors (e.g., input[type=text],
 48083:   // textarea) must override this method, so, we don't need to worry about
 48083:   // that here.
 48083:   nsIContent *editableAncestor = GetEditingHost();
 48083: 
 41886:   // This is in another editable content, use the result of it.
 48083:   if (editableAncestor && editableAncestor != this) {
 41886:     return editableAncestor->GetDesiredIMEState();
 41886:   }
 41886:   nsIDocument* doc = GetCurrentDoc();
 41886:   if (!doc) {
 82843:     return IMEState(IMEState::DISABLED);
 41886:   }
 46225:   nsIPresShell* ps = doc->GetShell();
 41886:   if (!ps) {
 82843:     return IMEState(IMEState::DISABLED);
 41886:   }
 41886:   nsPresContext* pc = ps->GetPresContext();
 41886:   if (!pc) {
 82843:     return IMEState(IMEState::DISABLED);
 41886:   }
 41886:   nsIEditor* editor = GetHTMLEditor(pc);
 41886:   nsCOMPtr<nsIEditorIMESupport> imeEditor = do_QueryInterface(editor);
 41886:   if (!imeEditor) {
 82843:     return IMEState(IMEState::DISABLED);
 82843:   }
 82843:   IMEState state;
 82843:   imeEditor->GetPreferredIMEState(&state);
 41886:   return state;
 41886: }
 41886: 
 79445: bool
 48083: nsIContent::HasIndependentSelection()
 48083: {
 48083:   nsIFrame* frame = GetPrimaryFrame();
 48083:   return (frame && frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION);
 48083: }
 48083: 
 97987: dom::Element*
 48083: nsIContent::GetEditingHost()
 48083: {
 48083:   // If this isn't editable, return NULL.
 73913:   NS_ENSURE_TRUE(IsEditableInternal(), nsnull);
 48083: 
 48083:   nsIDocument* doc = GetCurrentDoc();
 48083:   NS_ENSURE_TRUE(doc, nsnull);
 48083:   // If this is in designMode, we should return <body>
 48083:   if (doc->HasFlag(NODE_IS_EDITABLE)) {
 48083:     return doc->GetBodyElement();
 48083:   }
 48083: 
 48083:   nsIContent* content = this;
 97987:   for (dom::Element* parent = GetElementParent();
 48083:        parent && parent->HasFlag(NODE_IS_EDITABLE);
 97987:        parent = content->GetElementParent()) {
 48083:     content = parent;
 48083:   }
 97987:   return content->AsElement();
 48083: }
 48083: 
 41901: nsresult
 85097: nsIContent::LookupNamespaceURIInternal(const nsAString& aNamespacePrefix,
 41904:                                        nsAString& aNamespaceURI) const
 41901: {
 41901:   if (aNamespacePrefix.EqualsLiteral("xml")) {
 41901:     // Special-case for xml prefix
 41901:     aNamespaceURI.AssignLiteral("http://www.w3.org/XML/1998/namespace");
 41901:     return NS_OK;
 41901:   }
 41901: 
 41901:   if (aNamespacePrefix.EqualsLiteral("xmlns")) {
 41901:     // Special-case for xmlns prefix
 41901:     aNamespaceURI.AssignLiteral("http://www.w3.org/2000/xmlns/");
 41901:     return NS_OK;
 41901:   }
 41901: 
 41901:   nsCOMPtr<nsIAtom> name;
 41901:   if (!aNamespacePrefix.IsEmpty()) {
 41901:     name = do_GetAtom(aNamespacePrefix);
 41901:     NS_ENSURE_TRUE(name, NS_ERROR_OUT_OF_MEMORY);
 41901:   }
 41901:   else {
 41901:     name = nsGkAtoms::xmlns;
 41901:   }
 41901:   // Trace up the content parent chain looking for the namespace
 41901:   // declaration that declares aNamespacePrefix.
 41904:   const nsIContent* content = this;
 41904:   do {
 41901:     if (content->GetAttr(kNameSpaceID_XMLNS, name, aNamespaceURI))
 41901:       return NS_OK;
 41904:   } while ((content = content->GetParent()));
 41901:   return NS_ERROR_FAILURE;
 41901: }
 41901: 
 62344: already_AddRefed<nsIURI>
 62344: nsIContent::GetBaseURI() const
 62344: {
 80526:   nsIDocument* doc = OwnerDoc();
 62344:   // Start with document base
 62344:   nsCOMPtr<nsIURI> base = doc->GetDocBaseURI();
 62344: 
 62344:   // Collect array of xml:base attribute values up the parent chain. This
 62344:   // is slightly slower for the case when there are xml:base attributes, but
 62344:   // faster for the far more common case of there not being any such
 62344:   // attributes.
 62344:   // Also check for SVG elements which require special handling
 62344:   nsAutoTArray<nsString, 5> baseAttrs;
 62344:   nsString attr;
 62344:   const nsIContent *elem = this;
 62344:   do {
 62344:     // First check for SVG specialness (why is this SVG specific?)
 62344:     if (elem->IsSVG()) {
 62344:       nsIContent* bindingParent = elem->GetBindingParent();
 62344:       if (bindingParent) {
 62344:         nsXBLBinding* binding =
 80527:           bindingParent->OwnerDoc()->BindingManager()->GetBinding(bindingParent);
 62344:         if (binding) {
 62344:           // XXX sXBL/XBL2 issue
 62344:           // If this is an anonymous XBL element use the binding
 62344:           // document for the base URI. 
 62344:           // XXX Will fail with xml:base
 62344:           base = binding->PrototypeBinding()->DocURI();
 62344:           break;
 62344:         }
 62344:       }
 62344:     }
 62344: 
 89350:     nsIURI* explicitBaseURI = elem->GetExplicitBaseURI();
 89350:     if (explicitBaseURI) {
 89350:       base = explicitBaseURI;
 89350:       break;
 89350:     }
 89350:     
 62344:     // Otherwise check for xml:base attribute
 62344:     elem->GetAttr(kNameSpaceID_XML, nsGkAtoms::base, attr);
 62344:     if (!attr.IsEmpty()) {
 62344:       baseAttrs.AppendElement(attr);
 62344:     }
 62344:     elem = elem->GetParent();
 62344:   } while(elem);
 62344:   
 62344:   // Now resolve against all xml:base attrs
 62344:   for (PRUint32 i = baseAttrs.Length() - 1; i != PRUint32(-1); --i) {
 62344:     nsCOMPtr<nsIURI> newBase;
 62344:     nsresult rv = NS_NewURI(getter_AddRefs(newBase), baseAttrs[i],
 62344:                             doc->GetDocumentCharacterSet().get(), base);
 62344:     // Do a security check, almost the same as nsDocument::SetBaseURL()
 62344:     // Only need to do this on the final uri
 62344:     if (NS_SUCCEEDED(rv) && i == 0) {
 62344:       rv = nsContentUtils::GetSecurityManager()->
 62344:         CheckLoadURIWithPrincipal(NodePrincipal(), newBase,
 62344:                                   nsIScriptSecurityManager::STANDARD);
 62344:     }
 62344:     if (NS_SUCCEEDED(rv)) {
 62344:       base.swap(newBase);
 62344:     }
 62344:   }
 62344: 
 62344:   return base.forget();
 62344: }
 62344: 
 89350: static void
 89350: ReleaseURI(void*, /* aObject*/
 89350:            nsIAtom*, /* aPropertyName */
 89350:            void* aPropertyValue,
 89350:            void* /* aData */)
 89350: {
 89350:   nsIURI* uri = static_cast<nsIURI*>(aPropertyValue);
 89350:   NS_RELEASE(uri);
 89350: }
 89350: 
 89350: nsresult
 89350: nsINode::SetExplicitBaseURI(nsIURI* aURI)
 89350: {
 89350:   nsresult rv = SetProperty(nsGkAtoms::baseURIProperty, aURI, ReleaseURI);
 89350:   if (NS_SUCCEEDED(rv)) {
 89350:     SetHasExplicitBaseURI();
 89350:     NS_ADDREF(aURI);
 89350:   }
 89350:   return rv;
 89350: }
 89350: 
     1: //----------------------------------------------------------------------
     1: 
 93345: static inline JSObject*
 90297: GetJSObjectChild(nsWrapperCache* aCache)
 90297: {
 93345:   return aCache->PreservingWrapper() ? aCache->GetWrapperPreserveColor() : NULL;
 90297: }
 90297: 
 90297: static bool
 90297: NeedsScriptTraverse(nsWrapperCache* aCache)
 90297: {
 90297:   JSObject* o = GetJSObjectChild(aCache);
 90297:   return o && xpc_IsGrayGCThing(o);
 90297: }
 90297: 
 90297: //----------------------------------------------------------------------
 90297: 
 80074: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsChildContentList)
 80074: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsChildContentList)
 80074: 
 90297: // If nsChildContentList is changed so that any additional fields are
 98387: // traversed by the cycle collector, then CAN_SKIP must be updated to
 98387: // check that the additional fields are null.
 98387: NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_0(nsChildContentList)
 20752: 
 90297: // nsChildContentList only ever has a single child, its wrapper, so if
 90297: // the wrapper is black, the list can't be part of a garbage cycle.
 90297: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsChildContentList)
 90297:   return !NeedsScriptTraverse(tmp);
 90297: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
 90297: 
 90297: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsChildContentList)
 90297:   return !NeedsScriptTraverse(tmp);
 90297: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
 90297: 
 90297: // CanSkipThis returns false to avoid problems with incomplete unlinking.
 90297: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsChildContentList)
 90297: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
 90297: 
 21218: NS_INTERFACE_TABLE_HEAD(nsChildContentList)
 21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
 21218:   NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsChildContentList)
 21218:     NS_INTERFACE_TABLE_ENTRY(nsChildContentList, nsINodeList)
 21218:     NS_INTERFACE_TABLE_ENTRY(nsChildContentList, nsIDOMNodeList)
 21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
 21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
 80074:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsChildContentList)
 39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(NodeList)
 20752: NS_INTERFACE_MAP_END
     1: 
 80067: JSObject*
 93129: nsChildContentList::WrapObject(JSContext *cx, JSObject *scope,
 80085:                                bool *triedToWrap)
 80085: {
 80093:   return mozilla::dom::binding::NodeList::create(cx, scope, this, triedToWrap);
 80067: }
 80067: 
     1: NS_IMETHODIMP
     1: nsChildContentList::GetLength(PRUint32* aLength)
     1: {
     1:   *aLength = mNode ? mNode->GetChildCount() : 0;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 20752: NS_IMETHODIMP
 20752: nsChildContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
 20752: {
 20752:   nsINode* node = GetNodeAt(aIndex);
 20752:   if (!node) {
 20752:     *aReturn = nsnull;
 20752: 
 20752:     return NS_OK;
 20752:   }
 20752: 
 20752:   return CallQueryInterface(node, aReturn);
 20752: }
 20752: 
 24403: nsIContent*
 19130: nsChildContentList::GetNodeAt(PRUint32 aIndex)
     1: {
     1:   if (mNode) {
 19130:     return mNode->GetChildAt(aIndex);
 19130:   }
 19130: 
 19130:   return nsnull;
     1: }
     1: 
 24403: PRInt32
 24403: nsChildContentList::IndexOf(nsIContent* aContent)
 24403: {
 24403:   if (mNode) {
 24403:     return mNode->IndexOf(aContent);
 24403:   }
 24403: 
 24403:   return -1;
 24403: }
 24403: 
     1: //----------------------------------------------------------------------
     1: 
 41908: NS_IMPL_CYCLE_COLLECTION_1(nsNode3Tearoff, mNode)
     1: 
   791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNode3Tearoff)
 29215:   NS_INTERFACE_MAP_ENTRY(nsIDOMXPathNSResolver)
 41908: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
     1: 
     1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNode3Tearoff)
     1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNode3Tearoff)
     1: 
 71759: NS_IMETHODIMP
     1: nsNode3Tearoff::LookupNamespaceURI(const nsAString& aNamespacePrefix,
     1:                                    nsAString& aNamespaceURI)
     1: {
 71768:   return mNode->LookupNamespaceURI(aNamespacePrefix, aNamespaceURI);
     1: }
     1: 
 41910: nsIContent*
 41910: nsGenericElement::GetFirstElementChild()
 41910: {
 41910:   nsAttrAndChildArray& children = mAttrsAndChildren;
 17074:   PRUint32 i, count = children.ChildCount();
 17074:   for (i = 0; i < count; ++i) {
 17074:     nsIContent* child = children.ChildAt(i);
 41636:     if (child->IsElement()) {
 41910:       return child;
 41910:     }
 41910:   }
 41910:   
 41910:   return nsnull;
 41910: }
 41910: 
 41910: nsIContent*
 41910: nsGenericElement::GetLastElementChild()
 41910: {
 41910:   nsAttrAndChildArray& children = mAttrsAndChildren;
 17074:   PRUint32 i = children.ChildCount();
 17074:   while (i > 0) {
 17074:     nsIContent* child = children.ChildAt(--i);
 41636:     if (child->IsElement()) {
 41910:       return child;
 41910:     }
 41910:   }
 41910:   
 41910:   return nsnull;
 41910: }
 41910: 
 41910: nsIContent*
 41910: nsGenericElement::GetPreviousElementSibling()
 41910: {
 41910:   nsIContent* parent = GetParent();
 17074:   if (!parent) {
 41910:     return nsnull;
 17074:   }
 17074: 
 41636:   NS_ASSERTION(parent->IsElement() ||
 17074:                parent->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT),
 17074:                "Parent content must be an element or a doc fragment");
 17074: 
 17074:   nsAttrAndChildArray& children =
 17074:     static_cast<nsGenericElement*>(parent)->mAttrsAndChildren;
 41910:   PRInt32 index = children.IndexOfChild(this);
 17074:   if (index < 0) {
 41910:     return nsnull;
 17074:   }
 17074: 
 17074:   PRUint32 i = index;
 17074:   while (i > 0) {
 17074:     nsIContent* child = children.ChildAt((PRUint32)--i);
 41636:     if (child->IsElement()) {
 41910:       return child;
 41910:     }
 41910:   }
 41910:   
 41910:   return nsnull;
 41910: }
 41910: 
 41910: nsIContent*
 41910: nsGenericElement::GetNextElementSibling()
 41910: {
 41910:   nsIContent* parent = GetParent();
 17074:   if (!parent) {
 41910:     return nsnull;
 17074:   }
 17074: 
 41636:   NS_ASSERTION(parent->IsElement() ||
 17074:                parent->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT),
 17074:                "Parent content must be an element or a doc fragment");
 17074: 
 17074:   nsAttrAndChildArray& children =
 17074:     static_cast<nsGenericElement*>(parent)->mAttrsAndChildren;
 41910:   PRInt32 index = children.IndexOfChild(this);
 17074:   if (index < 0) {
 41910:     return nsnull;
 17074:   }
 17074: 
 17074:   PRUint32 i, count = children.ChildCount();
 17074:   for (i = (PRUint32)index + 1; i < count; ++i) {
 17074:     nsIContent* child = children.ChildAt(i);
 41636:     if (child->IsElement()) {
 41910:       return child;
 41910:     }
 41910:   }
 41910:   
 41910:   return nsnull;
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetChildElementCount(PRUint32* aResult)
 84859: {
 84859:   *aResult = GetChildrenList()->Length(true);
 84859:   return NS_OK;
 84859: }
 84859: 
 84859: // readonly attribute nsIDOMNodeList children
 84859: NS_IMETHODIMP
 84859: nsGenericElement::GetChildElements(nsIDOMNodeList** aResult)
 84859: {
 84859:   NS_ADDREF(*aResult = GetChildrenList());
 84859:   return NS_OK;
 84859: }
 84859: 
 84859: NS_IMETHODIMP
 84859: nsGenericElement::GetFirstElementChild(nsIDOMElement** aResult)
 41910: {
 41910:   *aResult = nsnull;
 41910: 
 84859:   nsIContent *result = GetFirstElementChild();
 41910: 
 41910:   return result ? CallQueryInterface(result, aResult) : NS_OK;
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetLastElementChild(nsIDOMElement** aResult)
 41910: {
 41910:   *aResult = nsnull;
 41910: 
 84859:   nsIContent *result = GetLastElementChild();
 41910: 
 41910:   return result ? CallQueryInterface(result, aResult) : NS_OK;
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetPreviousElementSibling(nsIDOMElement** aResult)
 41910: {
 41910:   *aResult = nsnull;
 41910: 
 84859:   nsIContent *result = GetPreviousElementSibling();
 41910: 
 41910:   return result ? CallQueryInterface(result, aResult) : NS_OK;
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetNextElementSibling(nsIDOMElement** aResult)
 41910: {
 41910:   *aResult = nsnull;
 41910: 
 84859:   nsIContent *result = GetNextElementSibling();
 41910: 
 41910:   return result ? CallQueryInterface(result, aResult) : NS_OK;
 17074: }
 17074: 
 17074: nsContentList*
 41910: nsGenericElement::GetChildrenList()
 41910: {
 59659:   nsGenericElement::nsDOMSlots *slots = DOMSlots();
 17074: 
 17074:   if (!slots->mChildrenList) {
 53966:     slots->mChildrenList = new nsContentList(this, kNameSpaceID_Wildcard, 
 53966:                                              nsGkAtoms::_asterix, nsGkAtoms::_asterix,
 80486:                                              false);
 17074:   }
 17074: 
 17074:   return slots->mChildrenList;
 17074: }
 17074: 
 91418: nsDOMTokenList*
 41910: nsGenericElement::GetClassList(nsresult *aResult)
 41910: {
 41910:   *aResult = NS_ERROR_OUT_OF_MEMORY;
 41910: 
 59659:   nsGenericElement::nsDOMSlots *slots = DOMSlots();
 41910: 
 41910:   if (!slots->mClassList) {
 41910:     nsCOMPtr<nsIAtom> classAttr = GetClassAttributeName();
 41910:     if (!classAttr) {
 41910:       *aResult = NS_OK;
 41910: 
 41910:       return nsnull;
 41910:     }
 41910: 
 41910:     slots->mClassList = new nsDOMTokenList(this, classAttr);
 41910:   }
 41910: 
 41910:   *aResult = NS_OK;
 41910: 
 41910:   return slots->mClassList;
 17074: }
 17074: 
 31383: NS_IMETHODIMP
 84859: nsGenericElement::GetClassList(nsIDOMDOMTokenList** aResult)
 31383: {
 41910:   *aResult = nsnull;
 41910: 
 41910:   nsresult rv;
 84859:   nsIDOMDOMTokenList* list = GetClassList(&rv);
 41910:   NS_ENSURE_TRUE(list, rv);
 41910: 
 41910:   NS_ADDREF(*aResult = list);
 31383: 
 31383:   return NS_OK;
 31383: }
 31383: 
 84859: NS_IMETHODIMP
 79445: nsGenericElement::SetCapture(bool aRetargetToElement)
 32435: {
 32435:   // If there is already an active capture, ignore this request. This would
 32435:   // occur if a splitter, frame resizer, etc had already captured and we don't
 32435:   // want to override those.
 46968:   if (nsIPresShell::GetCapturingContent())
 84859:     return NS_OK;
 46968: 
 46968:   nsIPresShell::SetCapturingContent(this, CAPTURE_PREVENTDRAG |
 46968:     (aRetargetToElement ? CAPTURE_RETARGETTOELEMENT : 0));
 84859: 
 84859:   return NS_OK;
 46968: }
 46968: 
 46968: NS_IMETHODIMP
 46968: nsGenericElement::ReleaseCapture()
 46968: {
 46968:   if (nsIPresShell::GetCapturingContent() == this) {
 46968:     nsIPresShell::SetCapturingContent(nsnull, 0);
 46968:   }
 46968: 
 32435:   return NS_OK;
 32435: }
 32435: 
 16722: nsIFrame*
 16722: nsGenericElement::GetStyledFrame()
 16722: {
 16722:   nsIFrame *frame = GetPrimaryFrame(Flush_Layout);
 35300:   return frame ? nsLayoutUtils::GetStyleFrame(frame) : nsnull;
 16722: }
 16722: 
 16722: void
 16722: nsGenericElement::GetOffsetRect(nsRect& aRect, nsIContent** aOffsetParent)
 16722: {
 16722:   *aOffsetParent = nsnull;
 16722:   aRect = nsRect();
 16722: 
 16722:   nsIFrame* frame = GetStyledFrame();
 16722:   if (!frame) {
 16722:     return;
 16722:   }
 16722: 
 16722:   nsPoint origin = frame->GetPosition();
 16722:   aRect.x = nsPresContext::AppUnitsToIntCSSPixels(origin.x);
 16722:   aRect.y = nsPresContext::AppUnitsToIntCSSPixels(origin.y);
 16722: 
 16722:   // Get the union of all rectangles in this and continuation frames.
 16722:   // It doesn't really matter what we use as aRelativeTo here, since
 16722:   // we only care about the size. Using 'parent' might make things
 16722:   // a bit faster by speeding up the internal GetOffsetTo operations.
 18884:   nsIFrame* parent = frame->GetParent() ? frame->GetParent() : frame;
 18884:   nsRect rcFrame = nsLayoutUtils::GetAllInFlowRectsUnion(frame, parent);
 16722:   aRect.width = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.width);
 16722:   aRect.height = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.height);
 16722: }
 16722: 
 37060: nsIScrollableFrame*
 41910: nsGenericElement::GetScrollFrame(nsIFrame **aStyledFrame)
 37060: {
 16722:   // it isn't clear what to return for SVG nodes, so just return nothing
 41910:   if (IsSVG()) {
 37060:     if (aStyledFrame) {
 37060:       *aStyledFrame = nsnull;
 37060:     }
 37060:     return nsnull;
 16722:   }
 16722: 
 41910:   nsIFrame* frame = GetStyledFrame();
 16722: 
 37060:   if (aStyledFrame) {
 37060:     *aStyledFrame = frame;
 16722:   }
 16722:   if (!frame) {
 37060:     return nsnull;
 37060:   }
 37060: 
 37060:   // menu frames implement GetScrollTargetFrame but we don't want
 80565:   // to use it here.  Similar for comboboxes.
 80565:   if (frame->GetType() != nsGkAtoms::menuFrame &&
 80565:       frame->GetType() != nsGkAtoms::comboboxControlFrame) {
 37060:     nsIScrollableFrame *scrollFrame = frame->GetScrollTargetFrame();
 37060:     if (scrollFrame)
 37060:       return scrollFrame;
 37060:   }
 37060: 
 80526:   nsIDocument* doc = OwnerDoc();
 79445:   bool quirksMode = doc->GetCompatibilityMode() == eCompatibility_NavQuirks;
 41634:   Element* elementWithRootScrollInfo =
 41634:     quirksMode ? doc->GetBodyElement() : doc->GetRootElement();
 41910:   if (this == elementWithRootScrollInfo) {
 16722:     // In quirks mode, the scroll info for the body element should map to the
 37060:     // root scrollable frame.
 37060:     // In strict mode, the scroll info for the root element should map to the
 16722:     // the root scrollable frame.
 37060:     return frame->PresContext()->PresShell()->GetRootScrollFrameAsScrollable();
 37060:   }
 37060: 
 37060:   return nsnull;
 16722: }
 16722: 
 41910: PRInt32
 41910: nsGenericElement::GetScrollTop()
 41910: {
 41910:   nsIScrollableFrame* sf = GetScrollFrame();
 41910: 
 41910:   return sf ?
 41910:          nsPresContext::AppUnitsToIntCSSPixels(sf->GetScrollPosition().y) :
 41910:          0;
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetScrollTop(PRInt32* aScrollTop)
 84859: {
 84859:   *aScrollTop = GetScrollTop();
 37060: 
 37060:   return NS_OK;
 16722: }
 16722: 
 84859: NS_IMETHODIMP
 41910: nsGenericElement::SetScrollTop(PRInt32 aScrollTop)
 16722: {
 37060:   nsIScrollableFrame* sf = GetScrollFrame();
 37060:   if (sf) {
 37060:     nsPoint pt = sf->GetScrollPosition();
 98475:     sf->ScrollToCSSPixels(nsIntPoint(nsPresContext::AppUnitsToIntCSSPixels(pt.x),
 98475:                                      aScrollTop));
 37060:   }
 37060:   return NS_OK;
 16722: }
 16722: 
 41910: PRInt32
 41910: nsGenericElement::GetScrollLeft()
 41910: {
 41910:   nsIScrollableFrame* sf = GetScrollFrame();
 41910: 
 41910:   return sf ?
 41910:          nsPresContext::AppUnitsToIntCSSPixels(sf->GetScrollPosition().x) :
 41910:          0;
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetScrollLeft(PRInt32* aScrollLeft)
 84859: {
 84859:   *aScrollLeft = GetScrollLeft();
 37060: 
 37060:   return NS_OK;
 16722: }
 16722: 
 84859: NS_IMETHODIMP
 41910: nsGenericElement::SetScrollLeft(PRInt32 aScrollLeft)
 16722: {
 37060:   nsIScrollableFrame* sf = GetScrollFrame();
 37060:   if (sf) {
 37060:     nsPoint pt = sf->GetScrollPosition();
 98475:     sf->ScrollToCSSPixels(nsIntPoint(aScrollLeft,
 98475:                                      nsPresContext::AppUnitsToIntCSSPixels(pt.y)));
 37060:   }
 37060:   return NS_OK;
 16722: }
 16722: 
 41910: PRInt32
 41910: nsGenericElement::GetScrollHeight()
 41910: {
 41910:   if (IsSVG())
 41910:     return 0;
 16722: 
 37060:   nsIScrollableFrame* sf = GetScrollFrame();
 37060:   if (!sf) {
 16722:     nsRect rcFrame;
 16722:     nsCOMPtr<nsIContent> parent;
 41910:     GetOffsetRect(rcFrame, getter_AddRefs(parent));
 41910:     return rcFrame.height;
 41910:   }
 41910: 
 41910:   nscoord height = sf->GetScrollRange().height + sf->GetScrollPortRect().height;
 41910:   return nsPresContext::AppUnitsToIntCSSPixels(height);
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetScrollHeight(PRInt32* aScrollHeight)
 84859: {
 84859:   *aScrollHeight = GetScrollHeight();
 41910: 
 16722:   return NS_OK;
 16722: }
 16722: 
 41910: PRInt32
 41910: nsGenericElement::GetScrollWidth()
 41910: {
 41910:   if (IsSVG())
 41910:     return 0;
 16722: 
 37060:   nsIScrollableFrame* sf = GetScrollFrame();
 37060:   if (!sf) {
 16722:     nsRect rcFrame;
 16722:     nsCOMPtr<nsIContent> parent;
 41910:     GetOffsetRect(rcFrame, getter_AddRefs(parent));
 41910:     return rcFrame.width;
 41910:   }
 41910: 
 41910:   nscoord width = sf->GetScrollRange().width + sf->GetScrollPortRect().width;
 41910:   return nsPresContext::AppUnitsToIntCSSPixels(width);
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetScrollWidth(PRInt32 *aScrollWidth)
 84859: {
 84859:   *aScrollWidth = GetScrollWidth();
 41910: 
 16722:   return NS_OK;
 16722: }
 16722: 
 16722: nsRect
 41910: nsGenericElement::GetClientAreaRect()
 16722: {
 37060:   nsIFrame* styledFrame;
 37060:   nsIScrollableFrame* sf = GetScrollFrame(&styledFrame);
 37060: 
 37060:   if (sf) {
 37060:     return sf->GetScrollPortRect();
 37060:   }
 37060: 
 37060:   if (styledFrame &&
 37060:       (styledFrame->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_INLINE ||
 37060:        styledFrame->IsFrameOfType(nsIFrame::eReplaced))) {
 16722:     // Special case code to make client area work even when there isn't
 16722:     // a scroll view, see bug 180552, bug 227567.
 37060:     return styledFrame->GetPaddingRect() - styledFrame->GetPositionIgnoringScrolling();
 37060:   }
 37060: 
 37060:   // SVG nodes reach here and just return 0
 16722:   return nsRect(0, 0, 0, 0);
 16722: }
 16722: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetClientTop(PRInt32 *aClientTop)
 84859: {
 84859:   *aClientTop = GetClientTop();
 41910:   return NS_OK;
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetClientLeft(PRInt32 *aClientLeft)
 84859: {
 84859:   *aClientLeft = GetClientLeft();
 41910:   return NS_OK;
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetClientHeight(PRInt32 *aClientHeight)
 84859: {
 84859:   *aClientHeight = GetClientHeight();
 41910:   return NS_OK;
 41910: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::GetClientWidth(PRInt32 *aClientWidth)
 84859: {
 84859:   *aClientWidth = GetClientWidth();
 41910:   return NS_OK;
 41910: }
 41910: 
 84859: NS_IMETHODIMP
 41910: nsGenericElement::GetBoundingClientRect(nsIDOMClientRect** aResult)
  2014: {
  2014:   // Weak ref, since we addref it below
 12913:   nsClientRect* rect = new nsClientRect();
  2014:   NS_ADDREF(*aResult = rect);
  2014:   
 41910:   nsIFrame* frame = GetPrimaryFrame(Flush_Layout);
  2014:   if (!frame) {
  2014:     // display:none, perhaps? Return the empty rect
  2014:     return NS_OK;
  2014:   }
 12349: 
 12349:   nsRect r = nsLayoutUtils::GetAllInFlowRectsUnion(frame,
 86355:           nsLayoutUtils::GetContainingBlockForClientRect(frame),
 86355:           nsLayoutUtils::RECTS_ACCOUNT_FOR_TRANSFORMS);
 32894:   rect->SetLayoutRect(r);
  2014:   return NS_OK;
  2014: }
  2014: 
 10833: NS_IMETHODIMP
 75263: nsGenericElement::GetElementsByClassName(const nsAString& aClasses,
 75263:                                          nsIDOMNodeList** aReturn)
 75263: {
 75263:   return nsContentUtils::GetElementsByClassName(this, aClasses, aReturn);
 75263: }
 75263: 
 84859: NS_IMETHODIMP
 41910: nsGenericElement::GetClientRects(nsIDOMClientRectList** aResult)
 10833: {
 10833:   *aResult = nsnull;
 10833: 
 92064:   nsRefPtr<nsClientRectList> rectList = new nsClientRectList(this);
 10833: 
 41910:   nsIFrame* frame = GetPrimaryFrame(Flush_Layout);
 10833:   if (!frame) {
 10833:     // display:none, perhaps? Return an empty list
 10833:     *aResult = rectList.forget().get();
 10833:     return NS_OK;
 10833:   }
 10833: 
 33027:   nsLayoutUtils::RectListBuilder builder(rectList);
 12349:   nsLayoutUtils::GetAllInFlowRects(frame,
 86355:           nsLayoutUtils::GetContainingBlockForClientRect(frame), &builder,
 86355:           nsLayoutUtils::RECTS_ACCOUNT_FOR_TRANSFORMS);
 12349:   if (NS_FAILED(builder.mRV))
 12349:     return builder.mRV;
 10833:   *aResult = rectList.forget().get();
  2014:   return NS_OK;
  2014: }
  2014: 
 41910: 
     1: //----------------------------------------------------------------------
     1: 
     1: 
     1: NS_IMPL_ISUPPORTS1(nsNodeWeakReference,
     1:                    nsIWeakReference)
     1: 
     1: nsNodeWeakReference::~nsNodeWeakReference()
     1: {
     1:   if (mNode) {
     1:     NS_ASSERTION(mNode->GetSlots() &&
     1:                  mNode->GetSlots()->mWeakReference == this,
     1:                  "Weak reference has wrong value");
     1:     mNode->GetSlots()->mWeakReference = nsnull;
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsNodeWeakReference::QueryReferent(const nsIID& aIID, void** aInstancePtr)
     1: {
     1:   return mNode ? mNode->QueryInterface(aIID, aInstancePtr) :
     1:                  NS_ERROR_NULL_POINTER;
     1: }
     1: 
     1: 
     1: NS_IMPL_CYCLE_COLLECTION_1(nsNodeSupportsWeakRefTearoff, mNode)
     1: 
   791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeSupportsWeakRefTearoff)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
     1: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
     1: 
     1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeSupportsWeakRefTearoff)
     1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeSupportsWeakRefTearoff)
     1: 
     1: NS_IMETHODIMP
     1: nsNodeSupportsWeakRefTearoff::GetWeakReference(nsIWeakReference** aInstancePtr)
     1: {
     1:   nsINode::nsSlots* slots = mNode->GetSlots();
     1:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:   if (!slots->mWeakReference) {
     1:     slots->mWeakReference = new nsNodeWeakReference(mNode);
     1:     NS_ENSURE_TRUE(slots->mWeakReference, NS_ERROR_OUT_OF_MEMORY);
     1:   }
     1: 
     1:   NS_ADDREF(*aInstancePtr = slots->mWeakReference);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
 41909: NS_IMPL_CYCLE_COLLECTION_1(nsNodeSelectorTearoff, mNode)
 16106: 
 16106: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeSelectorTearoff)
 16106:   NS_INTERFACE_MAP_ENTRY(nsIDOMNodeSelector)
 41909: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
 16106: 
 16106: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeSelectorTearoff)
 16106: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeSelectorTearoff)
 16106: 
 16106: NS_IMETHODIMP
 16106: nsNodeSelectorTearoff::QuerySelector(const nsAString& aSelector,
 16106:                                      nsIDOMElement **aReturn)
 16106: {
 41909:   nsresult rv;
 41909:   nsIContent* result = nsGenericElement::doQuerySelector(mNode, aSelector, &rv);
 41909:   return result ? CallQueryInterface(result, aReturn) : rv;
 16106: }
 16106: 
 16106: NS_IMETHODIMP
 16106: nsNodeSelectorTearoff::QuerySelectorAll(const nsAString& aSelector,
 16106:                                         nsIDOMNodeList **aReturn)
 16106: {
 41909:   return nsGenericElement::doQuerySelectorAll(mNode, aSelector, aReturn);
 16106: }
 16106: 
 16106: //----------------------------------------------------------------------
 77147: 
 77147: NS_IMPL_CYCLE_COLLECTION_1(nsTouchEventReceiverTearoff, mElement)
 77147: 
 77147: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsTouchEventReceiverTearoff)
 77147:   NS_INTERFACE_MAP_ENTRY(nsITouchEventReceiver)
 77147: NS_INTERFACE_MAP_END_AGGREGATED(mElement)
 77147: 
 77147: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsTouchEventReceiverTearoff)
 77147: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsTouchEventReceiverTearoff)
 77147: 
 77147: //----------------------------------------------------------------------
 77149: 
 77149: NS_IMPL_CYCLE_COLLECTION_1(nsInlineEventHandlersTearoff, mElement)
 77149: 
 77149: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsInlineEventHandlersTearoff)
 77149:   NS_INTERFACE_MAP_ENTRY(nsIInlineEventHandlers)
 77149: NS_INTERFACE_MAP_END_AGGREGATED(mElement)
 77149: 
 77149: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsInlineEventHandlersTearoff)
 77149: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsInlineEventHandlersTearoff)
 77149: 
 77149: //----------------------------------------------------------------------
 67604: nsGenericElement::nsDOMSlots::nsDOMSlots()
 67604:   : nsINode::nsSlots(),
 70158:     mDataset(nsnull),
     1:     mBindingParent(nsnull)
     1: {
     1: }
     1: 
     1: nsGenericElement::nsDOMSlots::~nsDOMSlots()
     1: {
     1:   if (mAttributeMap) {
     1:     mAttributeMap->DropReference();
     1:   }
 31383: 
 31383:   if (mClassList) {
 31383:     mClassList->DropReference();
 31383:   }
     1: }
     1: 
 77323: void
 77323: nsGenericElement::nsDOMSlots::Traverse(nsCycleCollectionTraversalCallback &cb, bool aIsXUL)
 77323: {
 77323:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mSlots->mStyle");
 77323:   cb.NoteXPCOMChild(mStyle.get());
 77323: 
 77323:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mSlots->mSMILOverrideStyle");
 77323:   cb.NoteXPCOMChild(mSMILOverrideStyle.get());
 77323: 
 77323:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mSlots->mAttributeMap");
 77323:   cb.NoteXPCOMChild(mAttributeMap.get());
 77323: 
 77323:   if (aIsXUL) {
 77323:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mSlots->mControllers");
 77323:     cb.NoteXPCOMChild(mControllers);
 77323:   }
 77323: 
 77323:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mSlots->mChildrenList");
 77323:   cb.NoteXPCOMChild(NS_ISUPPORTS_CAST(nsIDOMNodeList*, mChildrenList));
 91418: 
 91418:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mSlots->mClassList");
 91418:   cb.NoteXPCOMChild(mClassList.get());
 77323: }
 77323: 
 77323: void
 77323: nsGenericElement::nsDOMSlots::Unlink(bool aIsXUL)
 77323: {
 77323:   mStyle = nsnull;
 77323:   mSMILOverrideStyle = nsnull;
 77323:   if (mAttributeMap) {
 77323:     mAttributeMap->DropReference();
 77323:     mAttributeMap = nsnull;
 77323:   }
 77323:   if (aIsXUL)
 77323:     NS_IF_RELEASE(mControllers);
 77323:   mChildrenList = nsnull;
 91418:   if (mClassList) {
 91418:     mClassList->DropReference();
 91418:     mClassList = nsnull;
 91418:   }
 77323: }
 77323: 
 94340: nsGenericElement::nsGenericElement(already_AddRefed<nsINodeInfo> aNodeInfo)
 41632:   : Element(aNodeInfo)
     1: {
 71770:   NS_ABORT_IF_FALSE(mNodeInfo->NodeType() == nsIDOMNode::ELEMENT_NODE ||
 71770:                     (mNodeInfo->NodeType() ==
 71770:                        nsIDOMNode::DOCUMENT_FRAGMENT_NODE &&
 71770:                      mNodeInfo->Equals(nsGkAtoms::documentFragmentNodeName,
 71770:                                        kNameSpaceID_None)),
 71770:                     "Bad NodeType in aNodeInfo");
 71770: 
 67606:   SetIsElement();
     1: }
     1: 
     1: nsGenericElement::~nsGenericElement()
     1: {
     1:   NS_PRECONDITION(!IsInDoc(),
     1:                   "Please remove this from the document properly");
 74344:   if (GetParent()) {
 74344:     NS_RELEASE(mParent);
 74344:   }
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::GetNodeName(nsAString& aNodeName)
     1: {
 71771:   aNodeName = NodeName();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::GetLocalName(nsAString& aLocalName)
     1: {
 71771:   aLocalName = LocalName();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::GetNodeValue(nsAString& aNodeValue)
     1: {
     1:   SetDOMStringToNull(aNodeValue);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::SetNodeValue(const nsAString& aNodeValue)
     1: {
     1:   // The DOM spec says that when nodeValue is defined to be null "setting it
     1:   // has no effect", so we don't throw an exception.
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::GetNodeType(PRUint16* aNodeType)
     1: {
 71768:   *aNodeType = NodeType();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::GetNamespaceURI(nsAString& aNamespaceURI)
     1: {
     1:   return mNodeInfo->GetNamespaceURI(aNamespaceURI);
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::GetPrefix(nsAString& aPrefix)
     1: {
     1:   mNodeInfo->GetPrefix(aPrefix);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::InternalIsSupported(nsISupports* aObject,
     1:                                       const nsAString& aFeature,
     1:                                       const nsAString& aVersion,
 79445:                                       bool* aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
 80486:   *aReturn = false;
     1: 
     1:   // Convert the incoming UTF16 strings to raw char*'s to save us some
     1:   // code when doing all those string compares.
     1:   NS_ConvertUTF16toUTF8 feature(aFeature);
     1:   NS_ConvertUTF16toUTF8 version(aVersion);
     1: 
     1:   const char *f = feature.get();
     1:   const char *v = version.get();
     1: 
     1:   if (PL_strcasecmp(f, "XML") == 0 ||
     1:       PL_strcasecmp(f, "HTML") == 0) {
     1:     if (aVersion.IsEmpty() ||
     1:         PL_strcmp(v, "1.0") == 0 ||
     1:         PL_strcmp(v, "2.0") == 0) {
 80486:       *aReturn = true;
     1:     }
     1:   } else if (PL_strcasecmp(f, "Views") == 0 ||
     1:              PL_strcasecmp(f, "StyleSheets") == 0 ||
     1:              PL_strcasecmp(f, "Core") == 0 ||
     1:              PL_strcasecmp(f, "CSS") == 0 ||
     1:              PL_strcasecmp(f, "CSS2") == 0 ||
     1:              PL_strcasecmp(f, "Events") == 0 ||
     1:              PL_strcasecmp(f, "UIEvents") == 0 ||
     1:              PL_strcasecmp(f, "MouseEvents") == 0 ||
     1:              // Non-standard!
     1:              PL_strcasecmp(f, "MouseScrollEvents") == 0 ||
     1:              PL_strcasecmp(f, "HTMLEvents") == 0 ||
     1:              PL_strcasecmp(f, "Range") == 0 ||
     1:              PL_strcasecmp(f, "XHTML") == 0) {
     1:     if (aVersion.IsEmpty() ||
     1:         PL_strcmp(v, "2.0") == 0) {
 80486:       *aReturn = true;
     1:     }
     1:   } else if (PL_strcasecmp(f, "XPath") == 0) {
     1:     if (aVersion.IsEmpty() ||
     1:         PL_strcmp(v, "3.0") == 0) {
 80486:       *aReturn = true;
     1:     }
 69167:   } else if (PL_strcasecmp(f, "SVGEvents") == 0 ||
     1:              PL_strcasecmp(f, "SVGZoomEvents") == 0 ||
 86429:              nsSVGFeatures::HasFeature(aObject, aFeature)) {
     1:     if (aVersion.IsEmpty() ||
     1:         PL_strcmp(v, "1.0") == 0 ||
     1:         PL_strcmp(v, "1.1") == 0) {
 80486:       *aReturn = true;
     1:     }
     1:   }
 25961:   else if (NS_SMILEnabled() && PL_strcasecmp(f, "TimeControl") == 0) {
 23697:     if (aVersion.IsEmpty() || PL_strcmp(v, "1.0") == 0) {
 80486:       *aReturn = true;
 23697:     }
 23697:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::IsSupported(const nsAString& aFeature,
     1:                               const nsAString& aVersion,
 79445:                               bool* aReturn)
     1: {
     1:   return InternalIsSupported(this, aFeature, aVersion, aReturn);
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsGenericElement::HasAttributes(bool* aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1: 
     1:   *aReturn = GetAttrCount() > 0;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::GetAttributes(nsIDOMNamedNodeMap** aAttributes)
     1: {
 71771:   if (!IsElement()) {
 71771:     *aAttributes = nsnull;
 71771:     return NS_OK;
 71771:   }
 71771: 
 59659:   nsDOMSlots *slots = DOMSlots();
     1: 
     1:   if (!slots->mAttributeMap) {
     1:     slots->mAttributeMap = new nsDOMAttributeMap(this);
     1:   }
     1: 
     1:   NS_ADDREF(*aAttributes = slots->mAttributeMap);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 79445: nsGenericElement::HasChildNodes(bool* aReturn)
     1: {
     1:   *aReturn = mAttrsAndChildren.ChildCount() > 0;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::GetTagName(nsAString& aTagName)
     1: {
 71772:   aTagName = NodeName();
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::GetAttribute(const nsAString& aName,
     1:                                nsAString& aReturn)
     1: {
     1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
     1: 
     1:   if (!name) {
     1:     if (mNodeInfo->NamespaceID() == kNameSpaceID_XUL) {
     1:       // XXX should be SetDOMStringToNull(aReturn);
     1:       // See bug 232598
     1:       aReturn.Truncate();
     1:     }
     1:     else {
     1:       SetDOMStringToNull(aReturn);
     1:     }
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   GetAttr(name->NamespaceID(), name->LocalName(), aReturn);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::SetAttribute(const nsAString& aName,
     1:                                const nsAString& aValue)
     1: {
     1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
     1: 
     1:   if (!name) {
 80486:     nsresult rv = nsContentUtils::CheckQName(aName, false);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aName);
     1:     NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
     1: 
 80486:     return SetAttr(kNameSpaceID_None, nameAtom, aValue, true);
     1:   }
     1: 
     1:   return SetAttr(name->NamespaceID(), name->LocalName(), name->GetPrefix(),
 80486:                  aValue, true);
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::RemoveAttribute(const nsAString& aName)
     1: {
     1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
     1: 
     1:   if (!name) {
 91863:     // If there is no canonical nsAttrName for this attribute name, then the
 91863:     // attribute does not exist and we can't get its namespace ID and
 91863:     // local name below, so we return early.
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Hold a strong reference here so that the atom or nodeinfo doesn't go
     1:   // away during UnsetAttr. If it did UnsetAttr would be left with a
     1:   // dangling pointer as argument without knowing it.
     1:   nsAttrName tmp(*name);
     1: 
 80486:   return UnsetAttr(name->NamespaceID(), name->LocalName(), true);
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::GetAttributeNode(const nsAString& aName,
     1:                                    nsIDOMAttr** aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1:   *aReturn = nsnull;
     1: 
 80526:   nsIDocument* document = OwnerDoc();
 72272:   if (document) {
 72272:     document->WarnOnceAbout(nsIDocument::eGetAttributeNode);
 72272:   }
 72272: 
     1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
     1:   nsresult rv = GetAttributes(getter_AddRefs(map));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   rv = map->GetNamedItem(aName, getter_AddRefs(node));
     1: 
     1:   if (NS_SUCCEEDED(rv) && node) {
     1:     rv = CallQueryInterface(node, aReturn);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::SetAttributeNode(nsIDOMAttr* aAttribute,
     1:                                    nsIDOMAttr** aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1:   NS_ENSURE_ARG_POINTER(aAttribute);
     1: 
     1:   *aReturn = nsnull;
     1: 
 80527:   OwnerDoc()->WarnOnceAbout(nsIDocument::eSetAttributeNode);
 72272: 
     1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
     1:   nsresult rv = GetAttributes(getter_AddRefs(map));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsIDOMNode> returnNode;
     1:   rv = map->SetNamedItem(aAttribute, getter_AddRefs(returnNode));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (returnNode) {
     1:     rv = CallQueryInterface(returnNode, aReturn);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::RemoveAttributeNode(nsIDOMAttr* aAttribute,
     1:                                       nsIDOMAttr** aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1:   NS_ENSURE_ARG_POINTER(aAttribute);
     1: 
     1:   *aReturn = nsnull;
     1: 
 80527:   OwnerDoc()->WarnOnceAbout(nsIDocument::eRemoveAttributeNode);
 72272: 
     1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
     1:   nsresult rv = GetAttributes(getter_AddRefs(map));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsAutoString name;
     1: 
     1:   rv = aAttribute->GetName(name);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     nsCOMPtr<nsIDOMNode> node;
     1:     rv = map->RemoveNamedItem(name, getter_AddRefs(node));
     1: 
     1:     if (NS_SUCCEEDED(rv) && node) {
     1:       rv = CallQueryInterface(node, aReturn);
     1:     }
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::GetElementsByTagName(const nsAString& aTagname,
     1:                                        nsIDOMNodeList** aReturn)
     1: {
 53966:   nsContentList *list = NS_GetContentList(this, kNameSpaceID_Unknown, 
 63637:                                           aTagname).get();
     1: 
     1:   // transfer ref to aReturn
     1:   *aReturn = list;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::GetAttributeNS(const nsAString& aNamespaceURI,
     1:                                  const nsAString& aLocalName,
     1:                                  nsAString& aReturn)
     1: {
     1:   PRInt32 nsid =
     1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
     1: 
     1:   if (nsid == kNameSpaceID_Unknown) {
 91966:     // Unknown namespace means no attribute.
 91966:     SetDOMStringToNull(aReturn);
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
 91966:   bool hasAttr = GetAttr(nsid, name, aReturn);
 91966:   if (!hasAttr) {
 91966:     SetDOMStringToNull(aReturn);
 91966:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::SetAttributeNS(const nsAString& aNamespaceURI,
     1:                                  const nsAString& aQualifiedName,
     1:                                  const nsAString& aValue)
     1: {
 94340:   nsCOMPtr<nsINodeInfo> ni;
     1:   nsresult rv =
     1:     nsContentUtils::GetNodeInfoFromQName(aNamespaceURI, aQualifiedName,
     1:                                          mNodeInfo->NodeInfoManager(),
 71770:                                          nsIDOMNode::ATTRIBUTE_NODE,
     1:                                          getter_AddRefs(ni));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   return SetAttr(ni->NamespaceID(), ni->NameAtom(), ni->GetPrefixAtom(),
 80486:                  aValue, true);
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::RemoveAttributeNS(const nsAString& aNamespaceURI,
     1:                                     const nsAString& aLocalName)
     1: {
     1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
     1:   PRInt32 nsid =
     1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
     1: 
     1:   if (nsid == kNameSpaceID_Unknown) {
 91863:     // If the namespace ID is unknown, it means there can't possibly be an
 91863:     // existing attribute. We would need a known namespace ID to pass into
 91863:     // UnsetAttr, so we return early if we don't have one.
     1:     return NS_OK;
     1:   }
     1: 
 80486:   UnsetAttr(nsid, name, true);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::GetAttributeNodeNS(const nsAString& aNamespaceURI,
     1:                                      const nsAString& aLocalName,
     1:                                      nsIDOMAttr** aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1:   *aReturn = nsnull;
     1: 
 80527:   OwnerDoc()->WarnOnceAbout(nsIDocument::eGetAttributeNodeNS);
 72272: 
 91151:   return GetAttributeNodeNSInternal(aNamespaceURI, aLocalName, aReturn);
 91151: }
 91151: 
 91151: nsresult
 91151: nsGenericElement::GetAttributeNodeNSInternal(const nsAString& aNamespaceURI,
 91151:                                              const nsAString& aLocalName,
 91151:                                              nsIDOMAttr** aReturn)
 91151: {
     1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
     1:   nsresult rv = GetAttributes(getter_AddRefs(map));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsIDOMNode> node;
     1:   rv = map->GetNamedItemNS(aNamespaceURI, aLocalName, getter_AddRefs(node));
     1: 
     1:   if (NS_SUCCEEDED(rv) && node) {
     1:     rv = CallQueryInterface(node, aReturn);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::SetAttributeNodeNS(nsIDOMAttr* aNewAttr,
     1:                                      nsIDOMAttr** aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1:   NS_ENSURE_ARG_POINTER(aNewAttr);
     1:   *aReturn = nsnull;
     1: 
 80527:   OwnerDoc()->WarnOnceAbout(nsIDocument::eSetAttributeNodeNS);
 72272: 
     1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
     1:   nsresult rv = GetAttributes(getter_AddRefs(map));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   nsCOMPtr<nsIDOMNode> returnNode;
     1:   rv = map->SetNamedItemNS(aNewAttr, getter_AddRefs(returnNode));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (returnNode) {
     1:     rv = CallQueryInterface(returnNode, aReturn);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
     1:                                          const nsAString& aLocalName,
     1:                                          nsIDOMNodeList** aReturn)
     1: {
     1:   PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
     1: 
     1:   if (!aNamespaceURI.EqualsLiteral("*")) {
     1:     nsresult rv =
     1:       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
     1:                                                             nameSpaceId);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
 63637:   NS_ASSERTION(nameSpaceId != kNameSpaceID_Unknown, "Unexpected namespace ID!");
 63637: 
 63637:   nsContentList *list = NS_GetContentList(this, nameSpaceId, aLocalName).get();
     1: 
     1:   // transfer ref to aReturn
     1:   *aReturn = list;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 79445: nsGenericElement::HasAttribute(const nsAString& aName, bool* aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1: 
     1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
     1:   *aReturn = (name != nsnull);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::HasAttributeNS(const nsAString& aNamespaceURI,
     1:                                  const nsAString& aLocalName,
 79445:                                  bool* aReturn)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aReturn);
     1: 
     1:   PRInt32 nsid =
     1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
     1: 
     1:   if (nsid == kNameSpaceID_Unknown) {
     1:     // Unknown namespace means no attr...
     1: 
 80486:     *aReturn = false;
     1: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
     1:   *aReturn = HasAttr(nsid, name);
     1: 
     1:   return NS_OK;
     1: }
     1: 
  1685: static nsXBLBinding*
  1685: GetFirstBindingWithContent(nsBindingManager* aBmgr, nsIContent* aBoundElem)
  1685: {
  1685:   nsXBLBinding* binding = aBmgr->GetBinding(aBoundElem);
  1685:   while (binding) {
  1685:     if (binding->GetAnonymousContent()) {
  1685:       return binding;
  1685:     }
  1685:     binding = binding->GetBaseBinding();
  1685:   }
  1685:   
  1685:   return nsnull;
  1685: }
  1685: 
  1728: static nsresult
  1728: BindNodesInInsertPoints(nsXBLBinding* aBinding, nsIContent* aInsertParent,
  1728:                         nsIDocument* aDocument)
  1728: {
  1728:   NS_PRECONDITION(aBinding && aInsertParent, "Missing arguments");
  1728: 
  1728:   nsresult rv;
  1728:   // These should be refcounted or otherwise protectable.
  1728:   nsInsertionPointList* inserts =
  1728:     aBinding->GetExistingInsertionPointsFor(aInsertParent);
  1728:   if (inserts) {
 79445:     bool allowScripts = aBinding->AllowScripts();
  3244: #ifdef MOZ_XUL
  1839:     nsCOMPtr<nsIXULDocument> xulDoc = do_QueryInterface(aDocument);
  3244: #endif
  1728:     PRUint32 i;
  1728:     for (i = 0; i < inserts->Length(); ++i) {
  1728:       nsCOMPtr<nsIContent> insertRoot =
  1728:         inserts->ElementAt(i)->GetDefaultContent();
  1728:       if (insertRoot) {
 78992:         for (nsCOMPtr<nsIContent> child = insertRoot->GetFirstChild();
 78992:              child;
 78992:              child = child->GetNextSibling()) {
  1728:           rv = child->BindToTree(aDocument, aInsertParent,
  1728:                                  aBinding->GetBoundElement(), allowScripts);
  1728:           NS_ENSURE_SUCCESS(rv, rv);
  1839: 
  3244: #ifdef MOZ_XUL
  1839:           if (xulDoc) {
  1839:             xulDoc->AddSubtreeToDocument(child);
  1839:           }
  3244: #endif
  1728:         }
  1728:       }
  1728:     }
  1728:   }
  1728: 
  1728:   return NS_OK;
  1728: }
  1728: 
     1: nsresult
     1: nsGenericElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
     1:                              nsIContent* aBindingParent,
 79445:                              bool aCompileEventHandlers)
     1: {
     1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
     1:   NS_PRECONDITION(HasSameOwnerDoc(NODE_FROM(aParent, aDocument)),
     1:                   "Must have the same owner document");
  1498:   NS_PRECONDITION(!aParent || aDocument == aParent->GetCurrentDoc(),
     1:                   "aDocument must be current doc of aParent");
     1:   NS_PRECONDITION(!GetCurrentDoc(), "Already have a document.  Unbind first!");
     1:   // Note that as we recurse into the kids, they'll have a non-null parent.  So
     1:   // only assert if our parent is _changing_ while we have a parent.
     1:   NS_PRECONDITION(!GetParent() || aParent == GetParent(),
     1:                   "Already have a parent.  Unbind first!");
     1:   NS_PRECONDITION(!GetBindingParent() ||
     1:                   aBindingParent == GetBindingParent() ||
     1:                   (!aBindingParent && aParent &&
     1:                    aParent->GetBindingParent() == GetBindingParent()),
     1:                   "Already have a binding parent.  Unbind first!");
  1685:   NS_PRECONDITION(!aParent || !aDocument ||
  1685:                   !aParent->HasFlag(NODE_FORCE_XBL_BINDINGS),
  1685:                   "Parent in document but flagged as forcing XBL");
 16126:   NS_PRECONDITION(aBindingParent != this,
 16126:                   "Content must not be its own binding parent");
 16126:   NS_PRECONDITION(!IsRootOfNativeAnonymousSubtree() ||
 16126:                   aBindingParent == aParent,
 16126:                   "Native anonymous content must have its parent as its "
 12250:                   "own binding parent");
 93758:   NS_PRECONDITION(aBindingParent || !aParent ||
 93758:                   aBindingParent == aParent->GetBindingParent(),
 93758:                   "We should be passed the right binding parent");
     1: 
  3244: #ifdef MOZ_XUL
     1:   // First set the binding parent
  1498:   nsXULElement* xulElem = nsXULElement::FromContent(this);
  1498:   if (xulElem) {
  1498:     xulElem->SetXULBindingParent(aBindingParent);
  1498:   }
  3244:   else 
  3244: #endif
  3244:   {
     1:     if (aBindingParent) {
 59659:       nsDOMSlots *slots = DOMSlots();
     1: 
     1:       slots->mBindingParent = aBindingParent; // Weak, so no addref happens.
     1:     }
  1498:   }
 16126:   NS_ASSERTION(!aBindingParent || IsRootOfNativeAnonymousSubtree() ||
 14239:                !HasFlag(NODE_IS_IN_ANONYMOUS_SUBTREE) ||
 22217:                (aParent && aParent->IsInNativeAnonymousSubtree()),
 14239:                "Trying to re-bind content from native anonymous subtree to "
 14239:                "non-native anonymous parent!");
 25511:   if (aParent && aParent->IsInNativeAnonymousSubtree()) {
 14239:     SetFlags(NODE_IS_IN_ANONYMOUS_SUBTREE);
 14239:   }
  1498: 
 79445:   bool hadForceXBL = HasFlag(NODE_FORCE_XBL_BINDINGS);
  1685: 
  1498:   // Now set the parent and set the "Force attach xbl" flag if needed.
     1:   if (aParent) {
 74344:     if (!GetParent()) {
 74344:       NS_ADDREF(aParent);
 74344:     }
 67605:     mParent = aParent;
  1498: 
  1498:     if (aParent->HasFlag(NODE_FORCE_XBL_BINDINGS)) {
  1498:       SetFlags(NODE_FORCE_XBL_BINDINGS);
  1498:     }
     1:   }
     1:   else {
 67605:     mParent = aDocument;
 67605:   }
 67605:   SetParentIsContent(aParent);
     1: 
     1:   // XXXbz sXBL/XBL2 issue!
     1: 
     1:   // Finally, set the document
     1:   if (aDocument) {
     1:     // Notify XBL- & nsIAnonymousContentCreator-generated
     1:     // anonymous content that the document is changing.
     1:     // XXXbz ordering issues here?  Probably not, since ChangeDocumentFor is
     1:     // just pretty broken anyway....  Need to get it working.
     1:     // XXXbz XBL doesn't handle this (asserts), and we don't really want
     1:     // to be doing this during parsing anyway... sort this out.    
     1:     //    aDocument->BindingManager()->ChangeDocumentFor(this, nsnull,
     1:     //                                                   aDocument);
     1: 
 93101:     // We no longer need to track the subtree pointer (and in fact we'll assert
 93101:     // if we do this any later).
 93101:     ClearSubtreeRootPointer();
 93101: 
     1:     // Being added to a document.
 67605:     SetInDocument();
  1498: 
  1498:     // Unset this flag since we now really are in a document.
 40938:     UnsetFlags(NODE_FORCE_XBL_BINDINGS |
 40938:                // And clear the lazy frame construction bits.
 43787:                NODE_NEEDS_FRAME | NODE_DESCENDANTS_NEED_FRAMES |
 43787:                // And the restyle bits
 43787:                ELEMENT_ALL_RESTYLE_FLAGS);
 93101:   } else {
 93101:     // If we're not in the doc, update our subtree pointer.
 93101:     SetSubtreeRootPointer(aParent->SubtreeRoot());
     1:   }
     1: 
  1685:   // If NODE_FORCE_XBL_BINDINGS was set we might have anonymous children
  1685:   // that also need to be told that they are moving.
  1685:   nsresult rv;
  1685:   if (hadForceXBL) {
 80527:     nsBindingManager* bmgr = OwnerDoc()->BindingManager();
  1685: 
  1685:     // First check if we have a binding...
  1685:     nsXBLBinding* contBinding =
  1685:       GetFirstBindingWithContent(bmgr, this);
  1685:     if (contBinding) {
  1685:       nsCOMPtr<nsIContent> anonRoot = contBinding->GetAnonymousContent();
 79445:       bool allowScripts = contBinding->AllowScripts();
 78992:       for (nsCOMPtr<nsIContent> child = anonRoot->GetFirstChild();
 78992:            child;
 78992:            child = child->GetNextSibling()) {
  1685:         rv = child->BindToTree(aDocument, this, this, allowScripts);
  1685:         NS_ENSURE_SUCCESS(rv, rv);
  1685:       }
  1728: 
  1728:       // ...then check if we have content in insertion points that are
  1728:       // direct children of the <content>
  1728:       rv = BindNodesInInsertPoints(contBinding, this, aDocument);
  1728:       NS_ENSURE_SUCCESS(rv, rv);
  1728:     }
  1728: 
  1728:     // ...and finally check if we're in a binding where we have content in
  1728:     // insertion points.
  1685:     if (aBindingParent) {
  1685:       nsXBLBinding* binding = bmgr->GetBinding(aBindingParent);
  1685:       if (binding) {
  1728:         rv = BindNodesInInsertPoints(binding, this, aDocument);
  1685:         NS_ENSURE_SUCCESS(rv, rv);
  1685:       }
  1685:     }
  1685:   }
  1685: 
 80486:   UpdateEditableState(false);
  2896: 
     1:   // Now recurse into our kids
 48267:   for (nsIContent* child = GetFirstChild(); child;
 48267:        child = child->GetNextSibling()) {
     1:     rv = child->BindToTree(aDocument, this, aBindingParent,
     1:                            aCompileEventHandlers);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   nsNodeUtils::ParentChainChanged(this);
     1: 
 93755:   if (aDocument && HasID() && !aBindingParent) {
 93755:     aDocument->AddToIdTable(this, DoGetID());
 93755:   }
 93755: 
 93755:   if (MayHaveStyle() && !IsXUL()) {
 93755:     // XXXbz if we already have a style attr parsed, this won't do
 93755:     // anything... need to fix that.
 93755:     // If MayHaveStyle() is true, we must be an nsStyledElement
 93755:     static_cast<nsStyledElement*>(this)->ReparseStyleAttribute(false);
 93755:   }
 93755: 
 93755:   if (aDocument) {
 93755:     // If we're in a document now, let our mapped attrs know what their new
 93755:     // sheet is.  This is safe to run for non-mapped-attribute elements too;
 93755:     // it'll just do a small bit of unnecessary work.  But most elements in
 93755:     // practice are mapped-attribute elements.
 93755:     nsHTMLStyleSheet* sheet = aDocument->GetAttributeStyleSheet();
 93755:     if (sheet) {
 93755:       mAttrsAndChildren.SetMappedAttrStyleSheet(sheet);
 93755:     }
 93755:   }
 93755: 
     1:   // XXXbz script execution during binding can trigger some of these
     1:   // postcondition asserts....  But we do want that, since things will
     1:   // generally be quite broken when that happens.
     1:   NS_POSTCONDITION(aDocument == GetCurrentDoc(), "Bound to wrong document");
     1:   NS_POSTCONDITION(aParent == GetParent(), "Bound to wrong parent");
     1:   NS_POSTCONDITION(aBindingParent == GetBindingParent(),
     1:                    "Bound to wrong binding parent");
     1: 
     1:   return NS_OK;
     1: }
     1: 
101722: class RemoveFromBindingManagerRunnable : public nsRunnable {
101722: public:
101722:   RemoveFromBindingManagerRunnable(nsBindingManager* aManager,
101722:                                    Element* aElement,
101722:                                    nsIDocument* aDoc,
101722:                                    nsIContent* aBindingParent):
101722:     mManager(aManager), mElement(aElement), mDoc(aDoc),
101722:     mBindingParent(aBindingParent)
101722:   {}
101722: 
101722:   NS_IMETHOD Run()
101722:   {
101722:     mManager->RemovedFromDocumentInternal(mElement, mDoc, mBindingParent);
101722:     return NS_OK;
101722:   }
101722: 
101722: private:
101722:   nsRefPtr<nsBindingManager> mManager;
101722:   nsRefPtr<Element> mElement;
101722:   nsCOMPtr<nsIDocument> mDoc;
101722:   nsCOMPtr<nsIContent> mBindingParent;
101722: };
101722: 
     1: void
 79445: nsGenericElement::UnbindFromTree(bool aDeep, bool aNullParent)
     1: {
     1:   NS_PRECONDITION(aDeep || (!GetCurrentDoc() && !GetBindingParent()),
     1:                   "Shallow unbind won't clear document and binding parent on "
     1:                   "kids!");
 93755: 
 93755:   RemoveFromIdTable();
 93755: 
     1:   // Make sure to unbind this node before doing the kids
  6167:   nsIDocument *document =
 80526:     HasFlag(NODE_FORCE_XBL_BINDINGS) ? OwnerDoc() : GetCurrentDoc();
 24671: 
 67605:   if (aNullParent) {
 84109:     if (IsFullScreenAncestor()) {
 81144:       // The element being removed is an ancestor of the full-screen element,
 81144:       // exit full-screen state.
 84636:       nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 84636:                                       "DOM", OwnerDoc(),
 84636:                                       nsContentUtils::eDOM_PROPERTIES,
 84636:                                       "RemovedFullScreenElement");
 84109:       // Fully exit full-screen.
 84109:       nsIDocument::ExitFullScreen(false);
 81144:     }
 95203:     if (HasPointerLock()) {
 95203:       nsIDocument::UnlockPointer();
 95203:     }
 74344:     if (GetParent()) {
 74344:       NS_RELEASE(mParent);
 74344:     } else {
 67605:       mParent = nsnull;
 74344:     }
 67605:     SetParentIsContent(false);
 67605:   }
 67605:   ClearInDocument();
 24671: 
 93101:   // Begin keeping track of our subtree root.
 93101:   SetSubtreeRootPointer(aNullParent ? this : mParent->SubtreeRoot());
 93101: 
     1:   if (document) {
     1:     // Notify XBL- & nsIAnonymousContentCreator-generated
     1:     // anonymous content that the document is changing.
101722:     if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
101722:       nsContentUtils::AddScriptRunner(
101722:         new RemoveFromBindingManagerRunnable(document->BindingManager(), this,
101722:                                              document, GetBindingParent()));
101722:     }
     1: 
 11838:     document->ClearBoxObjectFor(this);
     1:   }
     1: 
 33649:   // Ensure that CSS transitions don't continue on an element at a
 33649:   // different place in the tree (even if reinserted before next
 33649:   // animation refresh).
 33896:   // FIXME (Bug 522599): Need a test for this.
 33649:   if (HasFlag(NODE_HAS_PROPERTIES)) {
 33649:     DeleteProperty(nsGkAtoms::transitionsOfBeforeProperty);
 33649:     DeleteProperty(nsGkAtoms::transitionsOfAfterProperty);
 33649:     DeleteProperty(nsGkAtoms::transitionsProperty);
 67985:     DeleteProperty(nsGkAtoms::animationsOfBeforeProperty);
 67985:     DeleteProperty(nsGkAtoms::animationsOfAfterProperty);
 67985:     DeleteProperty(nsGkAtoms::animationsProperty);
 33649:   }
 33649: 
  1498:   // Unset this since that's what the old code effectively did.
  1498:   UnsetFlags(NODE_FORCE_XBL_BINDINGS);
  1498:   
  3244: #ifdef MOZ_XUL
  1498:   nsXULElement* xulElem = nsXULElement::FromContent(this);
  1498:   if (xulElem) {
  1498:     xulElem->SetXULBindingParent(nsnull);
  1498:   }
  3244:   else
  3244: #endif
  3244:   {
     1:     nsDOMSlots *slots = GetExistingDOMSlots();
     1:     if (slots) {
     1:       slots->mBindingParent = nsnull;
     1:     }
  1498:   }
     1: 
     1:   if (aDeep) {
  1498:     // Do the kids. Don't call GetChildCount() here since that'll force
  1498:     // XUL to generate template children, which there is no need for since
  1498:     // all we're going to do is unbind them anyway.
  1498:     PRUint32 i, n = mAttrsAndChildren.ChildCount();
     1: 
     1:     for (i = 0; i < n; ++i) {
 80486:       // Note that we pass false for aNullParent here, since we don't want
     1:       // the kids to forget us.  We _do_ want them to forget their binding
     1:       // parent, though, since this only walks non-anonymous kids.
 80486:       mAttrsAndChildren.ChildAt(i)->UnbindFromTree(true, false);
     1:     }
     1:   }
     1: 
     1:   nsNodeUtils::ParentChainChanged(this);
     1: }
     1: 
 38069: already_AddRefed<nsINodeList>
 55877: nsGenericElement::GetChildren(PRUint32 aFilter)
 38069: {
 69024:   nsRefPtr<nsSimpleContentList> list = new nsSimpleContentList(this);
 38069:   if (!list) {
 38069:     return nsnull;
 38069:   }
 38069: 
 38069:   nsIFrame *frame = GetPrimaryFrame();
 38069: 
 38069:   // Append :before generated content.
 38069:   if (frame) {
 38069:     nsIFrame *beforeFrame = nsLayoutUtils::GetBeforeFrame(frame);
 38069:     if (beforeFrame) {
 38357:       list->AppendElement(beforeFrame->GetContent());
 38069:     }
 38069:   }
 38069: 
 38069:   // If XBL is bound to this node then append XBL anonymous content including
 38069:   // explict content altered by insertion point if we were requested for XBL
 38069:   // anonymous content, otherwise append explicit content with respect to
 38069:   // insertion point if any.
 38069:   nsINodeList *childList = nsnull;
 38069: 
 80526:   nsIDocument* document = OwnerDoc();
 55877:   if (!(aFilter & eAllButXBL)) {
 38069:     childList = document->BindingManager()->GetXBLChildNodesFor(this);
 38069:     if (!childList) {
 38069:       childList = GetChildNodesList();
 38069:     }
 38069: 
 38069:   } else {
 38069:     childList = document->BindingManager()->GetContentListFor(this);
 38069:   }
 38069: 
 38069:   if (childList) {
 38069:     PRUint32 length = 0;
 38069:     childList->GetLength(&length);
 38069:     for (PRUint32 idx = 0; idx < length; idx++) {
 38069:       nsIContent* child = childList->GetNodeAt(idx);
 38069:       list->AppendElement(child);
 38069:     }
 38069:   }
 38069: 
 38069:   if (frame) {
 38069:     // Append native anonymous content to the end.
 38069:     nsIAnonymousContentCreator* creator = do_QueryFrame(frame);
 38069:     if (creator) {
 55877:       creator->AppendAnonymousContentTo(*list, aFilter);
 38069:     }
 38069: 
 38069:     // Append :after generated content.
 38069:     nsIFrame *afterFrame = nsLayoutUtils::GetAfterFrame(frame);
 38069:     if (afterFrame) {
 38357:       list->AppendElement(afterFrame->GetContent());
 38069:     }
 38069:   }
 38069: 
 38069:   nsINodeList* returnList = nsnull;
 38069:   list.forget(&returnList);
 38069:   return returnList;
 38069: }
 38069: 
 12925: static nsIContent*
 15478: FindNativeAnonymousSubtreeOwner(nsIContent* aContent)
 12925: {
 15478:   if (aContent->IsInNativeAnonymousSubtree()) {
 79445:     bool isNativeAnon = false;
 15478:     while (aContent && !isNativeAnon) {
 16126:       isNativeAnon = aContent->IsRootOfNativeAnonymousSubtree();
 12925:       aContent = aContent->GetParent();
 12925:     }
 15478:   }
 12925:   return aContent;
 12925: }
 12925: 
     1: nsresult
 72324: nsIContent::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
     1: {
     1:   //FIXME! Document how this event retargeting works, Bug 329124.
 80486:   aVisitor.mCanHandle = true;
 91087:   aVisitor.mMayHaveListenerManager = HasListenerManager();
  1401: 
  1401:   // Don't propagate mouseover and mouseout events when mouse is moving
  1401:   // inside native anonymous content.
 79445:   bool isAnonForEvents = IsRootOfNativeAnonymousSubtree();
 15478:   if ((aVisitor.mEvent->message == NS_MOUSE_ENTER_SYNTH ||
 15478:        aVisitor.mEvent->message == NS_MOUSE_EXIT_SYNTH) &&
 18444:       // Check if we should stop event propagation when event has just been
 18444:       // dispatched or when we're about to propagate from
 18444:       // native anonymous subtree.
 72324:       ((this == aVisitor.mEvent->originalTarget &&
 72324:         !IsInNativeAnonymousSubtree()) || isAnonForEvents)) {
  1401:      nsCOMPtr<nsIContent> relatedTarget =
  3233:        do_QueryInterface(static_cast<nsMouseEvent*>
  3233:                                     (aVisitor.mEvent)->relatedTarget);
  1401:     if (relatedTarget &&
 80526:         relatedTarget->OwnerDoc() == OwnerDoc()) {
  1401: 
  1401:       // If current target is anonymous for events or we know that related
  1401:       // target is descendant of an element which is anonymous for events,
  1401:       // we may want to stop event propagation.
 72324:       // If this is the original target, aVisitor.mRelatedTargetIsInAnon
  1401:       // must be updated.
  1401:       if (isAnonForEvents || aVisitor.mRelatedTargetIsInAnon ||
 72324:           (aVisitor.mEvent->originalTarget == this &&
 12250:            (aVisitor.mRelatedTargetIsInAnon =
 12250:             relatedTarget->IsInNativeAnonymousSubtree()))) {
 72324:         nsIContent* anonOwner = FindNativeAnonymousSubtreeOwner(this);
 15478:         if (anonOwner) {
 15478:           nsIContent* anonOwnerRelated =
 15478:             FindNativeAnonymousSubtreeOwner(relatedTarget);
 15478:           if (anonOwnerRelated) {
 15478:             // Note, anonOwnerRelated may still be inside some other
 15478:             // native anonymous subtree. The case where anonOwner is still
 15478:             // inside native anonymous subtree will be handled when event
 15478:             // propagates up in the DOM tree.
 15478:             while (anonOwner != anonOwnerRelated &&
 15478:                    anonOwnerRelated->IsInNativeAnonymousSubtree()) {
 15478:               anonOwnerRelated = FindNativeAnonymousSubtreeOwner(anonOwnerRelated);
 15478:             }
 15478:             if (anonOwner == anonOwnerRelated) {
 18444: #ifdef DEBUG_smaug
 18444:               nsCOMPtr<nsIContent> originalTarget =
 15478:                 do_QueryInterface(aVisitor.mEvent->originalTarget);
 18444:               nsAutoString ot, ct, rt;
 18444:               if (originalTarget) {
 18444:                 originalTarget->Tag()->ToString(ot);
 18444:               }
 72324:               Tag()->ToString(ct);
 18444:               relatedTarget->Tag()->ToString(rt);
 18444:               printf("Stopping %s propagation:"
 18444:                      "\n\toriginalTarget=%s \n\tcurrentTarget=%s %s"
 18444:                      "\n\trelatedTarget=%s %s \n%s",
 18444:                      (aVisitor.mEvent->message == NS_MOUSE_ENTER_SYNTH)
 18444:                        ? "mouseover" : "mouseout",
 18444:                      NS_ConvertUTF16toUTF8(ot).get(),
 18444:                      NS_ConvertUTF16toUTF8(ct).get(),
 18444:                      isAnonForEvents
 18444:                        ? "(is native anonymous)"
 72324:                        : (IsInNativeAnonymousSubtree()
 18444:                            ? "(is in native anonymous subtree)" : ""),
 18444:                      NS_ConvertUTF16toUTF8(rt).get(),
 18444:                      relatedTarget->IsInNativeAnonymousSubtree()
 18444:                        ? "(is in native anonymous subtree)" : "",
 18444:                      (originalTarget && relatedTarget->FindFirstNonNativeAnonymous() ==
 18444:                        originalTarget->FindFirstNonNativeAnonymous())
 18444:                        ? "" : "Wrong event propagation!?!\n");
 18444: #endif
  1401:               aVisitor.mParentTarget = nsnull;
  1401:               // Event should not propagate to non-anon content.
  1401:               aVisitor.mCanHandle = isAnonForEvents;
  1401:               return NS_OK;
  1401:             }
  1401:           }
  1401:         }
  1401:       }
  1593:     }
  1593:   }
  1401: 
 72324:   nsIContent* parent = GetParent();
 72324:   // Event may need to be retargeted if this is the root of a native
 22211:   // anonymous content subtree or event is dispatched somewhere inside XBL.
  1401:   if (isAnonForEvents) {
 14239:     // If a DOM event is explicitly dispatched using node.dispatchEvent(), then
 14239:     // all the events are allowed even in the native anonymous content..
 14239:     NS_ASSERTION(aVisitor.mEvent->eventStructType != NS_MUTATION_EVENT ||
 14239:                  aVisitor.mDOMEvent,
 14239:                  "Mutation event dispatched in native anonymous content!?!");
     1:     aVisitor.mEventTargetAtParent = parent;
 22211:   } else if (parent && aVisitor.mOriginalTargetIsInAnon) {
     1:     nsCOMPtr<nsIContent> content(do_QueryInterface(aVisitor.mEvent->target));
     1:     if (content && content->GetBindingParent() == parent) {
     1:       aVisitor.mEventTargetAtParent = parent;
     1:     }
     1:   }
     1: 
     1:   // check for an anonymous parent
     1:   // XXX XBL2/sXBL issue
 72324:   if (HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
 80527:     nsIContent* insertionParent = OwnerDoc()->BindingManager()->
 72324:       GetInsertionParent(this);
     1:     NS_ASSERTION(!(aVisitor.mEventTargetAtParent && insertionParent &&
     1:                    aVisitor.mEventTargetAtParent != insertionParent),
     1:                  "Retargeting and having insertion parent!");
     1:     if (insertionParent) {
     1:       parent = insertionParent;
     1:     }
     1:   }
     1: 
     1:   if (parent) {
     1:     aVisitor.mParentTarget = parent;
     1:   } else {
 72324:     aVisitor.mParentTarget = GetCurrentDoc();
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: const nsAttrValue*
 19132: nsGenericElement::DoGetClasses() const
 19132: {
 19132:   NS_NOTREACHED("Shouldn't ever be called");
     1:   return nsnull;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsGenericElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
     1: {
     1:   return NS_OK;
     1: }
     1: 
101616: nsICSSDeclaration*
 64123: nsGenericElement::GetSMILOverrideStyle()
 32193: {
 59659:   nsGenericElement::nsDOMSlots *slots = DOMSlots();
 32193: 
 32193:   if (!slots->mSMILOverrideStyle) {
 80486:     slots->mSMILOverrideStyle = new nsDOMCSSAttributeDeclaration(this, true);
 64123:   }
 64123: 
 64123:   return slots->mSMILOverrideStyle;
 32193: }
 32193: 
 63693: css::StyleRule*
 32193: nsGenericElement::GetSMILOverrideStyleRule()
 32193: {
 32193:   nsGenericElement::nsDOMSlots *slots = GetExistingDOMSlots();
 33018:   return slots ? slots->mSMILOverrideStyleRule.get() : nsnull;
 32193: }
 32193: 
 32193: nsresult
 63693: nsGenericElement::SetSMILOverrideStyleRule(css::StyleRule* aStyleRule,
 79445:                                            bool aNotify)
 32193: {
 59659:   nsGenericElement::nsDOMSlots *slots = DOMSlots();
 32193: 
 32193:   slots->mSMILOverrideStyleRule = aStyleRule;
 32193: 
 32193:   if (aNotify) {
 32193:     nsIDocument* doc = GetCurrentDoc();
 39316:     // Only need to request a restyle if we're in a document.  (We might not
 34033:     // be in a document, if we're clearing animation effects on a target node
 34033:     // that's been detached since the previous animation sample.)
 34033:     if (doc) {
 46225:       nsCOMPtr<nsIPresShell> shell = doc->GetShell();
 36917:       if (shell) {
 46468:         shell->RestyleForAnimation(this, eRestyle_Self);
 32193:       }
 32193:     }
 34033:   }
 32193: 
 32193:   return NS_OK;
 32193: }
 32193: 
101616: bool
101616: nsGenericElement::IsLabelable() const
101616: {
101616:   return false;
101616: }
101616: 
 63693: css::StyleRule*
     1: nsGenericElement::GetInlineStyleRule()
     1: {
     1:   return nsnull;
     1: }
     1: 
 95454: nsresult
 63693: nsGenericElement::SetInlineStyleRule(css::StyleRule* aStyleRule,
 94833:                                      const nsAString* aSerialized,
 79445:                                      bool aNotify)
     1: {
     1:   NS_NOTYETIMPLEMENTED("nsGenericElement::SetInlineStyleRule");
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
 79445: NS_IMETHODIMP_(bool)
     1: nsGenericElement::IsAttributeMapped(const nsIAtom* aAttribute) const
     1: {
 80486:   return false;
     1: }
     1: 
     1: nsChangeHint
     1: nsGenericElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
     1:                                          PRInt32 aModType) const
     1: {
     1:   return nsChangeHint(0);
     1: }
     1: 
     1: nsIAtom *
     1: nsGenericElement::GetClassAttributeName() const
     1: {
     1:   return nsnull;
     1: }
     1: 
 79445: bool
     1: nsGenericElement::FindAttributeDependence(const nsIAtom* aAttribute,
     1:                                           const MappedAttributeEntry* const aMaps[],
     1:                                           PRUint32 aMapCount)
     1: {
     1:   for (PRUint32 mapindex = 0; mapindex < aMapCount; ++mapindex) {
     1:     for (const MappedAttributeEntry* map = aMaps[mapindex];
     1:          map->attribute; ++map) {
     1:       if (aAttribute == *map->attribute) {
 80486:         return true;
 80486:       }
 80486:     }
 80486:   }
 80486: 
 80486:   return false;
     1: }
     1: 
 94340: already_AddRefed<nsINodeInfo>
     1: nsGenericElement::GetExistingAttrNameFromQName(const nsAString& aStr) const
     1: {
     1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aStr);
     1:   if (!name) {
     1:     return nsnull;
     1:   }
     1: 
 94340:   nsINodeInfo* nodeInfo;
     1:   if (name->IsAtom()) {
 71770:     nodeInfo = mNodeInfo->NodeInfoManager()->
 71770:       GetNodeInfo(name->Atom(), nsnull, kNameSpaceID_None,
 71770:                   nsIDOMNode::ATTRIBUTE_NODE).get();
     1:   }
     1:   else {
     1:     NS_ADDREF(nodeInfo = name->NodeInfo());
     1:   }
     1: 
     1:   return nodeInfo;
     1: }
     1: 
 79445: bool
     1: nsGenericElement::IsLink(nsIURI** aURI) const
     1: {
     1:   *aURI = nsnull;
 80486:   return false;
     1: }
     1: 
     1: // static
 79445: bool
     1: nsGenericElement::ShouldBlur(nsIContent *aContent)
     1: {
     1:   // Determine if the current element is focused, if it is not focused
     1:   // then we should not try to blur
     1:   nsIDocument *document = aContent->GetDocument();
 29018:   if (!document)
 80486:     return false;
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(document->GetWindow());
 29018:   if (!window)
 80486:     return false;
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> focusedFrame;
 29018:   nsIContent* contentToBlur =
 80486:     nsFocusManager::GetFocusedDescendant(window, false, getter_AddRefs(focusedFrame));
 29018:   if (contentToBlur == aContent)
 80486:     return true;
 29018: 
 29018:   // if focus on this element would get redirected, then check the redirected
 29018:   // content as well when blurring.
 29018:   return (contentToBlur && nsFocusManager::GetRedirectedFocus(aContent) == contentToBlur);
     1: }
     1: 
     1: nsIContent*
     1: nsGenericElement::GetBindingParent() const
     1: {
     1:   nsDOMSlots *slots = GetExistingDOMSlots();
     1: 
     1:   if (slots) {
     1:     return slots->mBindingParent;
     1:   }
     1:   return nsnull;
     1: }
     1: 
 79445: bool
     1: nsGenericElement::IsNodeOfType(PRUint32 aFlags) const
     1: {
 41646:   return !(aFlags & ~eCONTENT);
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::InsertChildAt(nsIContent* aKid,
     1:                                 PRUint32 aIndex,
 79445:                                 bool aNotify)
     1: {
     1:   NS_PRECONDITION(aKid, "null ptr");
     1: 
 42105:   return doInsertChildAt(aKid, aIndex, aNotify, mAttrsAndChildren);
 42105: }
 42105: 
 64563: static nsresult
 64563: AdoptNodeIntoOwnerDoc(nsINode *aParent, nsINode *aNode)
 64563: {
 69573:   NS_ASSERTION(!aNode->GetNodeParent(),
 69573:                "Should have removed from parent already");
 69573: 
 80526:   nsIDocument *doc = aParent->OwnerDoc();
 64563: 
 64563:   nsresult rv;
 64563:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(doc, &rv);
 64563:   NS_ENSURE_SUCCESS(rv, rv);
 64563: 
 64563:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(aNode, &rv);
 64563:   NS_ENSURE_SUCCESS(rv, rv);
 64563: 
 64563:   nsCOMPtr<nsIDOMNode> adoptedNode;
 64563:   rv = domDoc->AdoptNode(node, getter_AddRefs(adoptedNode));
 64563:   NS_ENSURE_SUCCESS(rv, rv);
 64563: 
 80526:   NS_ASSERTION(aParent->OwnerDoc() == doc,
 69574:                "ownerDoc chainged while adopting");
 64563:   NS_ASSERTION(adoptedNode == node, "Uh, adopt node changed nodes?");
 64563:   NS_ASSERTION(aParent->HasSameOwnerDoc(aNode),
 64563:                "ownerDocument changed again after adopting!");
 64563: 
 64563:   return NS_OK;
 64563: }
 42105: 
     1: nsresult
 42105: nsINode::doInsertChildAt(nsIContent* aKid, PRUint32 aIndex,
 79445:                          bool aNotify, nsAttrAndChildArray& aChildArray)
 42105: {
 69573:   NS_PRECONDITION(!aKid->GetNodeParent(),
 69573:                   "Inserting node that already has parent");
     1:   nsresult rv;
 42105: 
 69574:   // The id-handling code, and in the future possibly other code, need to
 69574:   // react to unexpected attribute changes.
 69574:   nsMutationGuard::DidMutate();
 69574: 
 69574:   // Do this before checking the child-count since this could cause mutations
 69574:   nsIDocument* doc = GetCurrentDoc();
 69574:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, aNotify);
 69574: 
 42105:   if (!HasSameOwnerDoc(aKid)) {
 64563:     rv = AdoptNodeIntoOwnerDoc(this, aKid);
 12068:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
 56613:   PRUint32 childCount = aChildArray.ChildCount();
 56613:   NS_ENSURE_TRUE(aIndex <= childCount, NS_ERROR_ILLEGAL_VALUE);
 79445:   bool isAppend = (aIndex == childCount);
 56613: 
     1:   rv = aChildArray.InsertChildAt(aKid, aIndex);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 42105:   if (aIndex == 0) {
 42105:     mFirstChild = aKid;
 42105:   }
 42105: 
 42105:   nsIContent* parent =
 42105:     IsNodeOfType(eDOCUMENT) ? nsnull : static_cast<nsIContent*>(this);
 42105: 
 93758:   rv = aKid->BindToTree(doc, parent,
 93758:                         parent ? parent->GetBindingParent() : nsnull,
 93758:                         true);
     1:   if (NS_FAILED(rv)) {
 42105:     if (GetFirstChild() == aKid) {
 42105:       mFirstChild = aKid->GetNextSibling();
 42105:     }
     1:     aChildArray.RemoveChildAt(aIndex);
     1:     aKid->UnbindFromTree();
     1:     return rv;
     1:   }
     1: 
 42105:   NS_ASSERTION(aKid->GetNodeParent() == this,
 30896:                "Did we run script inappropriately?");
 30896: 
 30896:   if (aNotify) {
     1:     // Note that we always want to call ContentInserted when things are added
     1:     // as kids to documents
 42105:     if (parent && isAppend) {
 42107:       nsNodeUtils::ContentAppended(parent, aKid, aIndex);
     1:     } else {
 42105:       nsNodeUtils::ContentInserted(this, aKid, aIndex);
     1:     }
     1: 
     1:     if (nsContentUtils::HasMutationListeners(aKid,
 42105:           NS_EVENT_BITS_MUTATION_NODEINSERTED, this)) {
 80486:       nsMutationEvent mutation(true, NS_MUTATION_NODEINSERTED);
 42105:       mutation.mRelatedNode = do_QueryInterface(this);
 42105: 
 80526:       mozAutoSubtreeModified subtree(OwnerDoc(), this);
 84833:       (new nsAsyncDOMEvent(aKid, mutation))->RunDOMEventWhenSafe();
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 94359: void
 79445: nsGenericElement::RemoveChildAt(PRUint32 aIndex, bool aNotify)
     1: {
     1:   nsCOMPtr<nsIContent> oldKid = mAttrsAndChildren.GetSafeChildAt(aIndex);
     1:   NS_ASSERTION(oldKid == GetChildAt(aIndex), "Unexpected child in RemoveChildAt");
     1: 
     1:   if (oldKid) {
 94358:     doRemoveChildAt(aIndex, aNotify, oldKid, mAttrsAndChildren);
     1:   }
     1: }
     1: 
 94358: void
 79445: nsINode::doRemoveChildAt(PRUint32 aIndex, bool aNotify,
 70878:                          nsIContent* aKid, nsAttrAndChildArray& aChildArray)
     1: {
 42105:   NS_PRECONDITION(aKid && aKid->GetNodeParent() == this &&
 42105:                   aKid == GetChildAt(aIndex) &&
 42105:                   IndexOf(aKid) == (PRInt32)aIndex, "Bogus aKid");
 42105: 
 69573:   nsMutationGuard::DidMutate();
 69573: 
 69573:   nsIDocument* doc = GetCurrentDoc();
 69573: 
 42105:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, aNotify);
     1: 
 48038:   nsIContent* previousSibling = aKid->GetPreviousSibling();
 48038: 
 42105:   if (GetFirstChild() == aKid) {
 42105:     mFirstChild = aKid->GetNextSibling();
 42105:   }
 42105: 
     1:   aChildArray.RemoveChildAt(aIndex);
     1: 
     1:   if (aNotify) {
 48038:     nsNodeUtils::ContentRemoved(this, aKid, aIndex, previousSibling);
     1:   }
     1: 
     1:   aKid->UnbindFromTree();
     1: }
     1: 
 75263: NS_IMETHODIMP
 75263: nsGenericElement::GetTextContent(nsAString &aTextContent)
 75263: {
 80486:   nsContentUtils::GetNodeTextContent(this, true, aTextContent);
 75263:   return NS_OK;
 75263: }
 75263: 
 75263: NS_IMETHODIMP
 75263: nsGenericElement::SetTextContent(const nsAString& aTextContent)
 75263: {
 80486:   return nsContentUtils::SetNodeTextContent(this, aTextContent, false);
 75263: }
 75263: 
 90468: /* static */
     1: nsresult
     1: nsGenericElement::DispatchEvent(nsPresContext* aPresContext,
     1:                                 nsEvent* aEvent,
     1:                                 nsIContent* aTarget,
 79445:                                 bool aFullDispatch,
     1:                                 nsEventStatus* aStatus)
     1: {
     1:   NS_PRECONDITION(aTarget, "Must have target");
     1:   NS_PRECONDITION(aEvent, "Must have source event");
     1:   NS_PRECONDITION(aStatus, "Null out param?");
     1: 
     1:   if (!aPresContext) {
     1:     return NS_OK;
     1:   }
     1: 
    95:   nsCOMPtr<nsIPresShell> shell = aPresContext->GetPresShell();
     1:   if (!shell) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (aFullDispatch) {
     1:     return shell->HandleEventWithTarget(aEvent, nsnull, aTarget, aStatus);
     1:   }
     1: 
     1:   return shell->HandleDOMEventWithTarget(aTarget, aEvent, aStatus);
     1: }
     1: 
     1: /* static */
     1: nsresult
     1: nsGenericElement::DispatchClickEvent(nsPresContext* aPresContext,
     1:                                      nsInputEvent* aSourceEvent,
     1:                                      nsIContent* aTarget,
 79445:                                      bool aFullDispatch,
 74191:                                      PRUint32 aFlags,
     1:                                      nsEventStatus* aStatus)
     1: {
     1:   NS_PRECONDITION(aTarget, "Must have target");
     1:   NS_PRECONDITION(aSourceEvent, "Must have source event");
     1:   NS_PRECONDITION(aStatus, "Null out param?");
     1: 
     1:   nsMouseEvent event(NS_IS_TRUSTED_EVENT(aSourceEvent), NS_MOUSE_CLICK,
     1:                      aSourceEvent->widget, nsMouseEvent::eReal);
     1:   event.refPoint = aSourceEvent->refPoint;
     1:   PRUint32 clickCount = 1;
 22684:   float pressure = 0;
 40485:   PRUint16 inputSource = 0;
     1:   if (aSourceEvent->eventStructType == NS_MOUSE_EVENT) {
  3233:     clickCount = static_cast<nsMouseEvent*>(aSourceEvent)->clickCount;
 22684:     pressure = static_cast<nsMouseEvent*>(aSourceEvent)->pressure;
 40485:     inputSource = static_cast<nsMouseEvent*>(aSourceEvent)->inputSource;
 40485:   } else if (aSourceEvent->eventStructType == NS_KEY_EVENT) {
 77227:     inputSource = nsIDOMMouseEvent::MOZ_SOURCE_KEYBOARD;
 22684:   }
 22684:   event.pressure = pressure;
     1:   event.clickCount = clickCount;
 40485:   event.inputSource = inputSource;
 96893:   event.modifiers = aSourceEvent->modifiers;
 74313:   event.flags |= aFlags; // Be careful not to overwrite existing flags!
     1: 
     1:   return DispatchEvent(aPresContext, &event, aTarget, aFullDispatch, aStatus);
     1: }
     1: 
     1: nsIFrame*
 36655: nsGenericElement::GetPrimaryFrame(mozFlushType aType)
     1: {
     1:   nsIDocument* doc = GetCurrentDoc();
     1:   if (!doc) {
     1:     return nsnull;
     1:   }
     1: 
     1:   // Cause a flush, so we get up-to-date frame
     1:   // information
     1:   doc->FlushPendingNotifications(aType);
     1: 
 36655:   return GetPrimaryFrame();
     1: }
     1: 
  8462: void
  8462: nsGenericElement::DestroyContent()
  8462: {
 80526:   nsIDocument *document = OwnerDoc();
 43087:   document->BindingManager()->RemovedFromDocument(this, document);
 11838:   document->ClearBoxObjectFor(this);
  8462: 
 21618:   // XXX We really should let cycle collection do this, but that currently still
 21618:   //     leaks (see https://bugzilla.mozilla.org/show_bug.cgi?id=406684).
 30001:   nsContentUtils::ReleaseWrapper(this, this);
 21618: 
  8462:   PRUint32 i, count = mAttrsAndChildren.ChildCount();
  8462:   for (i = 0; i < count; ++i) {
  8462:     // The child can remove itself from the parent in BindToTree.
  8462:     mAttrsAndChildren.ChildAt(i)->DestroyContent();
  8462:   }
  8462: }
  8462: 
 14188: void
 14188: nsGenericElement::SaveSubtreeState()
 14188: {
 14188:   PRUint32 i, count = mAttrsAndChildren.ChildCount();
 14188:   for (i = 0; i < count; ++i) {
 14188:     mAttrsAndChildren.ChildAt(i)->SaveSubtreeState();
 14188:   }
 14188: }
 14188: 
     1: //----------------------------------------------------------------------
     1: 
     1: // Generic DOMNode implementations
     1: 
 72780: // When replacing, aRefChild is the content being replaced; when
     1: // inserting it's the content before which we're inserting.  In the
     1: // latter case it may be null.
     1: static
 79445: bool IsAllowedAsChild(nsIContent* aNewChild, nsINode* aParent,
 79445:                       bool aIsReplace, nsINode* aRefChild)
     1: {
101145:   MOZ_ASSERT(aNewChild, "Must have new child");
101145:   MOZ_ASSERT_IF(aIsReplace, aRefChild);
101145:   MOZ_ASSERT(aParent);
101145:   MOZ_ASSERT(aParent->IsNodeOfType(nsINode::eDOCUMENT) ||
 39585:              aParent->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT) ||
 41636:              aParent->IsElement(),
101145:              "Nodes that are not documents, document fragments or elements "
101145:              "can't be parents!");
     1: 
 93757:   // A common case is that aNewChild has no kids, in which case
 93757:   // aParent can't be a descendant of aNewChild unless they're
 93757:   // actually equal to each other.  Fast-path that case, since aParent
 93757:   // could be pretty deep in the DOM tree.
101145:   if (aNewChild == aParent ||
 93757:       (aNewChild->GetFirstChild() &&
101145:        nsContentUtils::ContentIsDescendantOf(aParent, aNewChild))) {
 80486:     return false;
     1:   }
     1: 
     1:   // The allowed child nodes differ for documents and elements
 71773:   switch (aNewChild->NodeType()) {
     1:   case nsIDOMNode::COMMENT_NODE :
     1:   case nsIDOMNode::PROCESSING_INSTRUCTION_NODE :
     1:     // OK in both cases
 80486:     return true;
     1:   case nsIDOMNode::TEXT_NODE :
     1:   case nsIDOMNode::CDATA_SECTION_NODE :
     1:   case nsIDOMNode::ENTITY_REFERENCE_NODE :
101145:     // Allowed under Elements and DocumentFragments
101145:     return aParent->NodeType() != nsIDOMNode::DOCUMENT_NODE;
     1:   case nsIDOMNode::ELEMENT_NODE :
     1:     {
 39585:       if (!aParent->IsNodeOfType(nsINode::eDOCUMENT)) {
 39585:         // Always ok to have elements under other elements or document fragments
 80486:         return true;
     1:       }
     1: 
101136:       nsIDocument* parentDocument = static_cast<nsIDocument*>(aParent);
101136:       Element* rootElement = parentDocument->GetRootElement();
 41634:       if (rootElement) {
     1:         // Already have a documentElement, so this is only OK if we're
     1:         // replacing it.
 72780:         return aIsReplace && rootElement == aRefChild;
     1:       }
     1: 
     1:       // We don't have a documentElement yet.  Our one remaining constraint is
     1:       // that the documentElement must come after the doctype.
 72780:       if (!aRefChild) {
     1:         // Appending is just fine.
 80486:         return true;
     1:       }
     1: 
101136:       nsIContent* docTypeContent = parentDocument->GetDocumentType();
     1:       if (!docTypeContent) {
     1:         // It's all good.
 80486:         return true;
     1:       }
     1: 
 39585:       PRInt32 doctypeIndex = aParent->IndexOf(docTypeContent);
 72780:       PRInt32 insertIndex = aParent->IndexOf(aRefChild);
     1: 
     1:       // Now we're OK in the following two cases only:
     1:       // 1) We're replacing something that's not before the doctype
     1:       // 2) We're inserting before something that comes after the doctype 
     1:       return aIsReplace ? (insertIndex >= doctypeIndex) :
     1:         insertIndex > doctypeIndex;
     1:     }
     1:   case nsIDOMNode::DOCUMENT_TYPE_NODE :
     1:     {
 39585:       if (!aParent->IsNodeOfType(nsINode::eDOCUMENT)) {
 39585:         // doctypes only allowed under documents
 80486:         return false;
     1:       }
     1: 
101136:       nsIDocument* parentDocument = static_cast<nsIDocument*>(aParent);
101136:       nsIContent* docTypeContent = parentDocument->GetDocumentType();
     1:       if (docTypeContent) {
     1:         // Already have a doctype, so this is only OK if we're replacing it
 72780:         return aIsReplace && docTypeContent == aRefChild;
     1:       }
     1: 
     1:       // We don't have a doctype yet.  Our one remaining constraint is
     1:       // that the doctype must come before the documentElement.
101136:       Element* rootElement = parentDocument->GetRootElement();
 41634:       if (!rootElement) {
     1:         // It's all good
 80486:         return true;
     1:       }
     1: 
 72780:       if (!aRefChild) {
     1:         // Trying to append a doctype, but have a documentElement
 80486:         return false;
     1:       }
     1: 
 41634:       PRInt32 rootIndex = aParent->IndexOf(rootElement);
 72780:       PRInt32 insertIndex = aParent->IndexOf(aRefChild);
     1: 
     1:       // Now we're OK if and only if insertIndex <= rootIndex.  Indeed, either
 72780:       // we end up replacing aRefChild or we end up before it.  Either one is
 72780:       // ok as long as aRefChild is not after rootElement.
     1:       return insertIndex <= rootIndex;
     1:     }
     1:   case nsIDOMNode::DOCUMENT_FRAGMENT_NODE :
     1:     {
     1:       // Note that for now we only allow nodes inside document fragments if
     1:       // they're allowed inside elements.  If we ever change this to allow
     1:       // doctype nodes in document fragments, we'll need to update this code
 39585:       if (!aParent->IsNodeOfType(nsINode::eDOCUMENT)) {
     1:         // All good here
 80486:         return true;
     1:       }
     1: 
 79445:       bool sawElement = false;
 78992:       for (nsIContent* child = aNewChild->GetFirstChild();
 78992:            child;
 78992:            child = child->GetNextSibling()) {
 78992:         if (child->IsElement()) {
     1:           if (sawElement) {
     1:             // Can't put two elements into a document
 80486:             return false;
 80486:           }
 80486:           sawElement = true;
     1:         }
     1:         // If we can put this content at the the right place, we might be ok;
     1:         // if not, we bail out.
 78992:         if (!IsAllowedAsChild(child, aParent, aIsReplace, aRefChild)) {
 80486:           return false;
     1:         }
     1:       }
     1: 
     1:       // Everything in the fragment checked out ok, so we can stick it in here
 80486:       return true;
     1:     }
     1:   default:
     1:     /*
     1:      * aNewChild is of invalid type.
     1:      */
     1:     break;
     1:   }
     1: 
 80486:   return false;
     1: }
     1: 
 41627: void
 41627: nsGenericElement::FireNodeInserted(nsIDocument* aDoc,
 41627:                                    nsINode* aParent,
 70878:                                    nsTArray<nsCOMPtr<nsIContent> >& aNodes)
 70878: {
 70878:   PRUint32 count = aNodes.Length();
 70878:   for (PRUint32 i = 0; i < count; ++i) {
 41627:     nsIContent* childContent = aNodes[i];
 41627: 
 41627:     if (nsContentUtils::HasMutationListeners(childContent,
 41627:           NS_EVENT_BITS_MUTATION_NODEINSERTED, aParent)) {
 80486:       nsMutationEvent mutation(true, NS_MUTATION_NODEINSERTED);
 41627:       mutation.mRelatedNode = do_QueryInterface(aParent);
 41627: 
 41627:       mozAutoSubtreeModified subtree(aDoc, aParent);
 84833:       (new nsAsyncDOMEvent(childContent, mutation))->RunDOMEventWhenSafe();
 41627:     }
 41627:   }
 41627: }
 41627: 
     1: nsresult
 79445: nsINode::ReplaceOrInsertBefore(bool aReplace, nsINode* aNewChild,
 39585:                                nsINode* aRefChild)
 39585: {
     1:   if (!aNewChild || (aReplace && !aRefChild)) {
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1: 
 69573:   if ((!IsNodeOfType(eDOCUMENT) &&
 58598:        !IsNodeOfType(eDOCUMENT_FRAGMENT) &&
 69573:        !IsElement()) ||
 69573:       !aNewChild->IsNodeOfType(eCONTENT)){
 41527:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
 41527:   }
 41527: 
 71768:   PRUint16 nodeType = aNewChild->NodeType();
 69573: 
 69573:   // Before we do anything else, fire all DOMNodeRemoved mutation events
 69573:   // We do this up front as to avoid having to deal with script running
 69573:   // at random places further down.
 69573:   // Scope firing mutation events so that we don't carry any state that
 69573:   // might be stale
 69573:   {
 69573:     // This check happens again further down (though then using IndexOf).
 69573:     // We're only checking this here to avoid firing mutation events when
 69573:     // none should be fired.
 69573:     // It's ok that we do the check twice in the case when firing mutation
 69573:     // events as we need to recheck after running script anyway.
 69573:     if (aRefChild && aRefChild->GetNodeParent() != this) {
 69573:       return NS_ERROR_DOM_NOT_FOUND_ERR;
 69573:     }
 69573: 
 72780:     // If we're replacing, fire for node-to-be-replaced.
 72780:     // If aRefChild == aNewChild then we'll fire for it in check below
 72780:     if (aReplace && aRefChild != aNewChild) {
 80526:       nsContentUtils::MaybeFireNodeRemoved(aRefChild, this, OwnerDoc());
 69573:     }
 69573: 
 69573:     // If the new node already has a parent, fire for removing from old
 69573:     // parent
 69573:     nsINode* oldParent = aNewChild->GetNodeParent();
 69573:     if (oldParent) {
 69573:       nsContentUtils::MaybeFireNodeRemoved(aNewChild, oldParent,
 80526:                                            aNewChild->OwnerDoc());
 69573:     }
 69573: 
 69573:     // If we're inserting a fragment, fire for all the children of the
 69573:     // fragment
 69573:     if (nodeType == nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {
 69573:       static_cast<nsGenericElement*>(aNewChild)->FireNodeRemovedForChildren();
 69573:     }
 69573:   }
 69573: 
 80526:   nsIDocument* doc = OwnerDoc();
 69573:   nsIContent* newContent = static_cast<nsIContent*>(aNewChild);
 69573:   if (newContent->IsRootOfAnonymousSubtree()) {
 69573:     // This is anonymous content.  Don't allow its insertion
 69573:     // anywhere, since it might have UnbindFromTree calls coming
 69573:     // its way.
 69573:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 69573:   }
 69573: 
101720:   // Make sure that the inserted node is allowed as a child of its new parent.
101720:   if (!IsAllowedAsChild(newContent, this, aReplace, aRefChild)) {
101720:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
101720:   }
101720: 
101720:   // Record the node to insert before, if any
101720:   nsINode* nodeToInsertBefore;
101720:   if (aReplace) {
101720:     nodeToInsertBefore = aRefChild->GetNextSibling();
101720:   } else {
101720:     nodeToInsertBefore = aRefChild;
101720:   }
101720:   if (nodeToInsertBefore == aNewChild) {
101720:     // We're going to remove aNewChild from its parent, so use its next sibling
101720:     // as the node to insert before.
101720:     nodeToInsertBefore = nodeToInsertBefore->GetNextSibling();
101720:   }
101720: 
 69573:   // Remove the new child from the old parent if one exists
 77014:   nsCOMPtr<nsINode> oldParent = newContent->GetNodeParent();
 69573:   if (oldParent) {
 69573:     PRInt32 removeIndex = oldParent->IndexOf(newContent);
 69573:     if (removeIndex < 0) {
 69573:       // newContent is anonymous.  We can't deal with this, so just bail
 69573:       NS_ERROR("How come our flags didn't catch this?");
 69573:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 69573:     }
 69573: 
101721:     // Hold a strong ref to nodeToInsertBefore across the removal of newContent
101721:     nsCOMPtr<nsINode> kungFuDeathGrip = nodeToInsertBefore;
101721: 
101721:     // Removing a child can run script, via XBL destructors.
101721:     nsMutationGuard guard;
101721: 
101721:     // Scope for the mutation batch and scriptblocker, so they go away
101721:     // while kungFuDeathGrip is still alive.
101721:     {
101721:       mozAutoDocUpdate batch(GetCurrentDoc(), UPDATE_CONTENT_MODEL, true);
 94465:       nsAutoMutationBatch mb(oldParent, true, true);
 94359:       oldParent->RemoveChildAt(removeIndex, true);
 94465:       if (nsAutoMutationBatch::GetCurrentBatch() == &mb) {
 94465:         mb.RemovalDone();
 94465:         mb.SetPrevSibling(oldParent->GetChildAt(removeIndex - 1));
 94465:         mb.SetNextSibling(oldParent->GetChildAt(removeIndex));
 94465:       }
101720:     }
101720: 
101721:     // We expect one mutation (the removal) to have happened.
101721:     if (guard.Mutated(1)) {
101721:       // XBL destructors, yuck.
101721:       
101721:       // Verify that nodeToInsertBefore, if non-null, is still our child.  If
101721:       // it's not, there's no way we can do this insert sanely; just bail out.
101721:       if (nodeToInsertBefore && nodeToInsertBefore->GetParent() != this) {
101721:         return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
101721:       }
101721: 
101721:       // Verify that newContent has no parent.
101721:       if (newContent->GetParent()) {
101721:         return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
101721:       }
101721: 
101721:       // And verify that newContent is still allowed as our child.
101721:       if (aNewChild == aRefChild) {
101721:         // We've already removed aRefChild.  So even if we were doing a replace,
101721:         // now we're doing a simple insert before nodeToInsertBefore.
101721:         if (!IsAllowedAsChild(newContent, this, false, nodeToInsertBefore)) {
101721:           return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
101721:         }
101721:       } else {
101721:         if ((aRefChild && aRefChild->GetParent() != this) ||
101721:             !IsAllowedAsChild(newContent, this, aReplace, aRefChild)) {
101721:           return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
101721:         }
101721:         // And recompute nodeToInsertBefore, just in case.
101721:         if (aReplace) {
101721:           nodeToInsertBefore = aRefChild->GetNextSibling();
101721:         } else {
101721:           nodeToInsertBefore = aRefChild;
101721:         }
101721:       }
101721:     }
101721:   }
101721: 
101721:   mozAutoDocUpdate batch(GetCurrentDoc(), UPDATE_CONTENT_MODEL, true);
101721:   nsAutoMutationBatch mb;
101721: 
101720:   // Figure out which index we want to insert at.  Note that we use
101720:   // nodeToInsertBefore to determine this, because it's possible that
101720:   // aRefChild == aNewChild, in which case we just removed it from the
101720:   // parent list.
101720:   PRInt32 insPos;
101720:   if (nodeToInsertBefore) {
101720:     insPos = IndexOf(nodeToInsertBefore);
101720:     if (insPos < 0) {
101720:       // XXXbz How the heck would _that_ happen, exactly?
101720:       return NS_ERROR_DOM_NOT_FOUND_ERR;
101720:     }
101720:   }
101720:   else {
101720:     insPos = GetChildCount();
101720:   }
101720: 
101720:   // If we're replacing and we haven't removed aRefChild yet, do so now
101720:   if (aReplace && aRefChild != aNewChild) {
101720:     mb.Init(this, true, true);
101720: 
101720:     // Since aRefChild is never null in the aReplace case, we know that at
101720:     // this point nodeToInsertBefore is the next sibling of aRefChild.
101720:     NS_ASSERTION(aRefChild->GetNextSibling() == nodeToInsertBefore,
101720:                  "Unexpected nodeToInsertBefore");
101720: 
101720:     // An since nodeToInsertBefore is at index insPos, we want to remove
101720:     // at the previous index.
101720:     NS_ASSERTION(insPos >= 1, "insPos too small");
101720:     RemoveChildAt(insPos-1, true);
 69573:     --insPos;
 69573:   }
 69573: 
 94359:   nsresult res = NS_OK;
 69573:   // Move new child over to our document if needed. Do this after removing
 69573:   // it from its parent so that AdoptNode doesn't fire DOMNodeRemoved
 12068:   // DocumentType nodes are the only nodes that can have a null
 12068:   // ownerDocument according to the DOM spec, and we need to allow
 12068:   // inserting them w/o calling AdoptNode().
 78421:   if (!HasSameOwnerDoc(newContent)) {
 64563:     res = AdoptNodeIntoOwnerDoc(this, aNewChild);
 64563:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
     1:   /*
     1:    * Check if we're inserting a document fragment. If we are, we need
     1:    * to remove the children of the document fragment and add them
     1:    * individually (i.e. we don't add the actual document fragment).
     1:    */
     1:   if (nodeType == nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {
     1:     PRUint32 count = newContent->GetChildCount();
     1: 
 30896:     if (!count) {
 30896:       return NS_OK;
 30896:     }
 30896: 
     1:     // Copy the children into a separate array to avoid having to deal with
     1:     // mutations to the fragment while we're inserting.
 70878:     nsAutoTArray<nsCOMPtr<nsIContent>, 50> fragChildren;
 70878:     fragChildren.SetCapacity(count);
 78992:     for (nsIContent* child = newContent->GetFirstChild();
 78992:          child;
 78992:          child = child->GetNextSibling()) {
     1:       NS_ASSERTION(child->GetCurrentDoc() == nsnull,
     1:                    "How did we get a child with a current doc?");
 70878:       fragChildren.AppendElement(child);
 70878:     }
 70878: 
 70878:     // Remove the children from the fragment.
 94465:     {
 94465:       nsAutoMutationBatch mb(newContent, false, true);
 70878:       for (PRUint32 i = count; i > 0;) {
 80486:         newContent->RemoveChildAt(--i, true);
 30896:       }
 94465:     }
 94465: 
 94465:     if (!aReplace) {
 94465:       mb.Init(this, true, true);
 94465:     }
 94465:     nsAutoMutationBatch* mutationBatch = nsAutoMutationBatch::GetCurrentBatch();
 94465:     if (mutationBatch) {
 94465:       mutationBatch->RemovalDone();
 94465:       mutationBatch->SetPrevSibling(GetChildAt(insPos - 1));
 94465:       mutationBatch->SetNextSibling(GetChildAt(insPos));
 94465:     }
 30896: 
 79445:     bool appending =
 41636:       !IsNodeOfType(eDOCUMENT) && PRUint32(insPos) == GetChildCount();
 74431:     PRInt32 firstInsPos = insPos;
 42107:     nsIContent* firstInsertedContent = fragChildren[0];
 30896: 
 30896:     // Iterate through the fragment's children, and insert them in the new
 30896:     // parent
 70878:     for (PRUint32 i = 0; i < count; ++i, ++insPos) {
     1:       // XXXbz how come no reparenting here?  That seems odd...
     1:       // Insert the child.
 70878:       res = InsertChildAt(fragChildren[i], insPos, !appending);
 30896:       if (NS_FAILED(res)) {
 30896:         // Make sure to notify on any children that we did succeed to insert
 30896:         if (appending && i != 0) {
 39585:           nsNodeUtils::ContentAppended(static_cast<nsIContent*>(this),
 42107:                                        firstInsertedContent,
 39585:                                        firstInsPos);
 30896:         }
 30896:         return res;
 30896:       }
 70878:     }
 70878: 
 94465:     if (mutationBatch && !appending) {
 94465:       mutationBatch->NodesAdded();
 94465:     }
 94465: 
 70878:     // Notify and fire mutation events when appending
 30896:     if (appending) {
 42107:       nsNodeUtils::ContentAppended(static_cast<nsIContent*>(this),
 42107:                                    firstInsertedContent, firstInsPos);
 94465:       if (mutationBatch) {
 94465:         mutationBatch->NodesAdded();
 94465:       }
 70878:       // Optimize for the case when there are no listeners
 69573:       if (nsContentUtils::
 69573:             HasMutationListeners(doc, NS_EVENT_BITS_MUTATION_NODEINSERTED)) {
 41627:         nsGenericElement::FireNodeInserted(doc, this, fragChildren);
     1:       }
     1:     }
 70878:   }
     1:   else {
     1:     // Not inserting a fragment but rather a single node.
     1: 
 37946:     // FIXME https://bugzilla.mozilla.org/show_bug.cgi?id=544654
 37946:     //       We need to reparent here for nodes for which the parent of their
 37946:     //       wrapper is not the wrapper for their ownerDocument (XUL elements,
 69573:     //       form controls, ...). Also applies in the fragment code above.
     1: 
 94465:     if (nsAutoMutationBatch::GetCurrentBatch() == &mb) {
 94465:       mb.RemovalDone();
 94465:       mb.SetPrevSibling(GetChildAt(insPos - 1));
 94465:       mb.SetNextSibling(GetChildAt(insPos));
 94465:     }
 80486:     res = InsertChildAt(newContent, insPos, true);
     1:     NS_ENSURE_SUCCESS(res, res);
     1:   }
     1: 
 71768:   return NS_OK;
 71768: }
 71768: 
 71768: nsresult
 71768: nsINode::CompareDocumentPosition(nsIDOMNode* aOther, PRUint16* aReturn)
 71768: {
 71768:   nsCOMPtr<nsINode> other = do_QueryInterface(aOther);
 71768:   if (!other) {
 71768:     return NS_ERROR_NULL_POINTER;
 71768:   }
 71768:   *aReturn = CompareDocPosition(other);
 71768:   return NS_OK;
 71768: }
 71768: 
 71768: nsresult
 79445: nsINode::IsEqualNode(nsIDOMNode* aOther, bool* aReturn)
 71769: {
 71769:   nsCOMPtr<nsINode> other = do_QueryInterface(aOther);
 71769:   *aReturn = IsEqualTo(other);
 71769:   return NS_OK;
 71769: }
 71769: 
     1: //----------------------------------------------------------------------
     1: 
     1: // nsISupports implementation
     1: 
     1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGenericElement)
     1: 
 91256: #define SUBTREE_UNBINDINGS_PER_RUNNABLE 500
 91256: 
 91256: class ContentUnbinder : public nsRunnable
 91256: {
 91256: public:
 91256:   ContentUnbinder()
 91256:   {
 91256:     nsLayoutStatics::AddRef();
 91256:     mLast = this;
 91256:   }
 91256: 
 91256:   ~ContentUnbinder()
 91256:   {
 91256:     Run();
 91256:     nsLayoutStatics::Release();
 91256:   }
 91256: 
 91256:   void UnbindSubtree(nsIContent* aNode)
 91256:   {
 91256:     if (aNode->NodeType() != nsIDOMNode::ELEMENT_NODE &&
 91256:         aNode->NodeType() != nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {
 91256:       return;  
 91256:     }
 91256:     nsGenericElement* container = static_cast<nsGenericElement*>(aNode);
 91256:     PRUint32 childCount = container->mAttrsAndChildren.ChildCount();
 91256:     if (childCount) {
 91256:       while (childCount-- > 0) {
 91256:         // Hold a strong ref to the node when we remove it, because we may be
 91256:         // the last reference to it.  We need to call TakeChildAt() and
 91256:         // update mFirstChild before calling UnbindFromTree, since this last
 91256:         // can notify various observers and they should really see consistent
 91256:         // tree state.
 91256:         nsCOMPtr<nsIContent> child =
 91256:           container->mAttrsAndChildren.TakeChildAt(childCount);
 91256:         if (childCount == 0) {
 91256:           container->mFirstChild = nsnull;
 91256:         }
 91256:         UnbindSubtree(child);
 91256:         child->UnbindFromTree();
 91256:       }
 91256:     }
 91256:   }
 91256: 
 91256:   NS_IMETHOD Run()
 91256:   {
 91256:     nsAutoScriptBlocker scriptBlocker;
 91256:     PRUint32 len = mSubtreeRoots.Length();
 91256:     if (len) {
 91256:       PRTime start = PR_Now();
 91256:       for (PRUint32 i = 0; i < len; ++i) {
 91256:         UnbindSubtree(mSubtreeRoots[i]);
 91256:       }
 91256:       mSubtreeRoots.Clear();
 91256:       Telemetry::Accumulate(Telemetry::CYCLE_COLLECTOR_CONTENT_UNBIND,
 91256:                             PRUint32(PR_Now() - start) / PR_USEC_PER_MSEC);
 91256:     }
 91256:     if (this == sContentUnbinder) {
 91256:       sContentUnbinder = nsnull;
 91256:       if (mNext) {
 91256:         nsRefPtr<ContentUnbinder> next;
 91256:         next.swap(mNext);
 91256:         sContentUnbinder = next;
 91256:         next->mLast = mLast;
 91256:         mLast = nsnull;
 91256:         NS_DispatchToMainThread(next);
 91256:       }
 91256:     }
 91256:     return NS_OK;
 91256:   }
 91256: 
 91256:   static void Append(nsIContent* aSubtreeRoot)
 91256:   {
 91256:     if (!sContentUnbinder) {
 91256:       sContentUnbinder = new ContentUnbinder();
 91256:       nsCOMPtr<nsIRunnable> e = sContentUnbinder;
 91256:       NS_DispatchToMainThread(e);
 91256:     }
 91256: 
 91256:     if (sContentUnbinder->mLast->mSubtreeRoots.Length() >=
 91256:         SUBTREE_UNBINDINGS_PER_RUNNABLE) {
 91256:       sContentUnbinder->mLast->mNext = new ContentUnbinder();
 91256:       sContentUnbinder->mLast = sContentUnbinder->mLast->mNext;
 91256:     }
 91256:     sContentUnbinder->mLast->mSubtreeRoots.AppendElement(aSubtreeRoot);
 91256:   }
 91256: 
 91256: private:
 91256:   nsAutoTArray<nsCOMPtr<nsIContent>,
 91256:                SUBTREE_UNBINDINGS_PER_RUNNABLE> mSubtreeRoots;
 91256:   nsRefPtr<ContentUnbinder>                     mNext;
 91256:   ContentUnbinder*                              mLast;
 91256:   static ContentUnbinder*                       sContentUnbinder;
 91256: };
 91256: 
 91256: ContentUnbinder* ContentUnbinder::sContentUnbinder = nsnull;
 91256: 
 67680: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGenericElement)
 77323:   nsINode::Unlink(tmp);
     1: 
101092:   if (tmp->HasProperties()) {
101092:     if (tmp->IsHTML()) {
101092:       tmp->DeleteProperty(nsGkAtoms::microdataProperties);
101092:       tmp->DeleteProperty(nsGkAtoms::itemtype);
101092:       tmp->DeleteProperty(nsGkAtoms::itemref);
101092:       tmp->DeleteProperty(nsGkAtoms::itemprop);
101092:     } else if (tmp->IsXUL()) {
  9153:       tmp->DeleteProperty(nsGkAtoms::contextmenulistener);
  9153:       tmp->DeleteProperty(nsGkAtoms::popuplistener);
  9153:     }
101092:   }
  9153: 
     1:   // Unlink child content (and unbind our subtree).
 91256:   if (UnoptimizableCCNode(tmp) || !nsCCUncollectableMarker::sGeneration) {
 14228:     PRUint32 childCount = tmp->mAttrsAndChildren.ChildCount();
 14228:     if (childCount) {
 14228:       // Don't allow script to run while we're unbinding everything.
 14228:       nsAutoScriptBlocker scriptBlocker;
 14228:       while (childCount-- > 0) {
 81297:         // Hold a strong ref to the node when we remove it, because we may be
 81297:         // the last reference to it.  We need to call TakeChildAt() and
 81297:         // update mFirstChild before calling UnbindFromTree, since this last
 81297:         // can notify various observers and they should really see consistent
 81297:         // tree state.
 81297:         nsCOMPtr<nsIContent> child = tmp->mAttrsAndChildren.TakeChildAt(childCount);
 81297:         if (childCount == 0) {
 42105:           tmp->mFirstChild = nsnull;
     1:         }
 81297:         child->UnbindFromTree();
 81297:       }
 81297:     }
 91256:   } else if (!tmp->GetParent() && tmp->mAttrsAndChildren.ChildCount()) {
 91256:     ContentUnbinder::Append(tmp);
 91256:   } /* else {
 91256:     The subtree root will end up to a ContentUnbinder, and that will
 91256:     unbind the child nodes.
 91256:   } */
     1: 
     1:   // Unlink any DOM slots of interest.
     1:   {
     1:     nsDOMSlots *slots = tmp->GetExistingDOMSlots();
  8462:     if (slots) {
 77323:       slots->Unlink(tmp->IsXUL());
  8462:     }
     1:   }
 30000: 
 30000:   {
 30000:     nsIDocument *doc;
 80526:     if (!tmp->GetNodeParent() && (doc = tmp->OwnerDoc())) {
 43087:       doc->BindingManager()->RemovedFromDocument(tmp, doc);
 30000:     }
 30000:   }
     1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
     1: 
 30001: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsGenericElement)
 77323:   nsINode::Trace(tmp, aCallback, aClosure);
 30001: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 30001: 
 88521: void
 88521: nsGenericElement::MarkUserData(void* aObject, nsIAtom* aKey, void* aChild,
 88521:                                void* aData)
 88521: {
 88521:   PRUint32* gen = static_cast<PRUint32*>(aData);
 88521:   xpc_MarkInCCGeneration(static_cast<nsISupports*>(aChild), *gen);
 88521: }
 88521: 
 88521: void
 88521: nsGenericElement::MarkUserDataHandler(void* aObject, nsIAtom* aKey,
 88521:                                       void* aChild, void* aData)
 88521: {
 94338:   xpc_TryUnmarkWrappedGrayObject(static_cast<nsISupports*>(aChild));
 88521: }
 88521: 
 89872: void
 89872: nsGenericElement::MarkNodeChildren(nsINode* aNode)
 88521: {
 88521:   JSObject* o = GetJSObjectChild(aNode);
 88521:   xpc_UnmarkGrayObject(o);
 88521: 
 88521:   nsEventListenerManager* elm = aNode->GetListenerManager(false);
 88521:   if (elm) {
 88521:     elm->UnmarkGrayJSListeners();
 88521:   }
 88521: 
 88521:   if (aNode->HasProperties()) {
 88521:     nsIDocument* ownerDoc = aNode->OwnerDoc();
 88521:     ownerDoc->PropertyTable(DOM_USER_DATA)->
 88521:       Enumerate(aNode, nsGenericElement::MarkUserData,
 88521:                 &nsCCUncollectableMarker::sGeneration);
 88521:     ownerDoc->PropertyTable(DOM_USER_DATA_HANDLER)->
 88521:       Enumerate(aNode, nsGenericElement::MarkUserDataHandler,
 88521:                 &nsCCUncollectableMarker::sGeneration);
 88521:   }
 88521: }
 88521: 
 88521: nsINode*
 88521: FindOptimizableSubtreeRoot(nsINode* aNode)
 88521: {
 88521:   nsINode* p;
 88521:   while ((p = aNode->GetNodeParent())) {
 88521:     if (UnoptimizableCCNode(aNode)) {
 88521:       return nsnull;
 88521:     }
 88521:     aNode = p;
 88521:   }
 88521:   
 88521:   if (UnoptimizableCCNode(aNode)) {
 88521:     return nsnull;
 88521:   }
 88521:   return aNode;
 88521: }
 88521: 
 88521: nsAutoTArray<nsINode*, 1020>* gCCBlackMarkedNodes = nsnull;
 88521: 
 88521: void
 88521: ClearBlackMarkedNodes()
 88521: {
 88521:   if (!gCCBlackMarkedNodes) {
 88521:     return;
 88521:   }
 88521:   PRUint32 len = gCCBlackMarkedNodes->Length();
 88521:   for (PRUint32 i = 0; i < len; ++i) {
 88521:     nsINode* n = gCCBlackMarkedNodes->ElementAt(i);
 88521:     n->SetCCMarkedRoot(false);
 88521:     n->SetInCCBlackTree(false);
 88521:   }
 88521:   delete gCCBlackMarkedNodes;
 88521:   gCCBlackMarkedNodes = nsnull;
 88521: }
 88521: 
 88521: // static
 88521: bool
 88521: nsGenericElement::CanSkipInCC(nsINode* aNode)
 88521: {
 88521:   // Don't try to optimize anything during shutdown.
 88521:   if (nsCCUncollectableMarker::sGeneration == 0) {
 88521:     return false;
 88521:   }
 88521: 
 93428:   nsIDocument* currentDoc = aNode->GetCurrentDoc();
 93428:   if (currentDoc &&
 93428:       nsCCUncollectableMarker::InGeneration(currentDoc->GetMarkedCCGeneration())) {
 93428:     return !NeedsScriptTraverse(aNode);
 93428:   }
 93428: 
 88521:   // Bail out early if aNode is somewhere in anonymous content,
 88521:   // or otherwise unusual.
 88521:   if (UnoptimizableCCNode(aNode)) {
 88521:     return false;
 88521:   }
 88521: 
 88521:   nsINode* root =
 88521:     currentDoc ? static_cast<nsINode*>(currentDoc) :
 88521:                  FindOptimizableSubtreeRoot(aNode);
 88521:   if (!root) {
 88521:     return false;
 88521:   }
 88521:   
 88521:   // Subtree has been traversed already.
 88521:   if (root->CCMarkedRoot()) {
 88521:     return root->InCCBlackTree() && !NeedsScriptTraverse(aNode);
 88521:   }
 88521: 
 88521:   if (!gCCBlackMarkedNodes) {
 88521:     gCCBlackMarkedNodes = new nsAutoTArray<nsINode*, 1020>;
 88521:   }
 88521: 
 88521:   // nodesToUnpurple contains nodes which will be removed
 88521:   // from the purple buffer if the DOM tree is black.
 88521:   nsAutoTArray<nsIContent*, 1020> nodesToUnpurple;
 88521:   // grayNodes need script traverse, so they aren't removed from
 88521:   // the purple buffer, but are marked to be in black subtree so that
 88521:   // traverse is faster.
 88521:   nsAutoTArray<nsINode*, 1020> grayNodes;
 88521: 
 88521:   bool foundBlack = root->IsBlack();
 88521:   if (root != currentDoc) {
 88521:     currentDoc = nsnull;
 88521:     if (NeedsScriptTraverse(root)) {
 88521:       grayNodes.AppendElement(root);
 88521:     } else if (static_cast<nsIContent*>(root)->IsPurple()) {
 88521:       nodesToUnpurple.AppendElement(static_cast<nsIContent*>(root));
 88521:     }
 88521:   }
 88521: 
 88521:   // Traverse the subtree and check if we could know without CC
 88521:   // that it is black.
 88521:   // Note, this traverse is non-virtual and inline, so it should be a lot faster
 88521:   // than CC's generic traverse.
 88521:   for (nsIContent* node = root->GetFirstChild(); node;
 88521:        node = node->GetNextNode(root)) {
 88521:     foundBlack = foundBlack || node->IsBlack();
 88521:     if (foundBlack && currentDoc) {
 88521:       // If we can mark the whole document black, no need to optimize
 88521:       // so much, since when the next purple node in the document will be
 88521:       // handled, it is fast to check that currentDoc is in CCGeneration.
 88521:       break;
 88521:     }
 88521:     if (NeedsScriptTraverse(node)) {
 88521:       // Gray nodes need real CC traverse.
 88521:       grayNodes.AppendElement(node);
 88521:     } else if (node->IsPurple()) {
 88521:       nodesToUnpurple.AppendElement(node);
 88521:     }
 88521:   }
 88521: 
 88521:   root->SetCCMarkedRoot(true);
 88521:   root->SetInCCBlackTree(foundBlack);
 88521:   gCCBlackMarkedNodes->AppendElement(root);
 88521: 
 88521:   if (!foundBlack) {
 88521:     return false;
 88521:   }
 88521: 
 88521:   if (currentDoc) {
 88521:     // Special case documents. If we know the document is black,
 88521:     // we can mark the document to be in CCGeneration.
 88521:     currentDoc->
 88521:       MarkUncollectableForCCGeneration(nsCCUncollectableMarker::sGeneration);
 88521:   } else {
 88521:     for (PRUint32 i = 0; i < grayNodes.Length(); ++i) {
 88521:       nsINode* node = grayNodes[i];
 88521:       node->SetInCCBlackTree(true);
 88521:     }
 88521:     gCCBlackMarkedNodes->AppendElements(grayNodes);
 88521:   }
 88521: 
 88521:   // Subtree is black, we can remove non-gray purple nodes from
 88521:   // purple buffer.
 88521:   for (PRUint32 i = 0; i < nodesToUnpurple.Length(); ++i) {
 88521:     nsIContent* purple = nodesToUnpurple[i];
 88521:     // Can't remove currently handled purple node.
 88521:     if (purple != aNode) {
 88521:       purple->RemovePurple();
 88521:     }
 88521:   }
 88521:   return !NeedsScriptTraverse(aNode);
 88521: }
 88521: 
 88521: nsAutoTArray<nsINode*, 1020>* gPurpleRoots = nsnull;
 88521: 
 88521: void ClearPurpleRoots()
 88521: {
 88521:   if (!gPurpleRoots) {
 88521:     return;
 88521:   }
 88521:   PRUint32 len = gPurpleRoots->Length();
 88521:   for (PRUint32 i = 0; i < len; ++i) {
 88521:     nsINode* n = gPurpleRoots->ElementAt(i);
 88521:     n->SetIsPurpleRoot(false);
 88521:   }
 88521:   delete gPurpleRoots;
 88521:   gPurpleRoots = nsnull;
 88521: }
 88521: 
 88521: static bool
 88521: ShouldClearPurple(nsIContent* aContent)
 88521: {
 88521:   if (aContent && aContent->IsPurple()) {
 88521:     return true;
 88521:   }
 88521: 
 88521:   JSObject* o = GetJSObjectChild(aContent);
 88521:   if (o && xpc_IsGrayGCThing(o)) {
 88521:     return true;
 88521:   }
 88521: 
 91087:   if (aContent->HasListenerManager()) {
 88521:     return true;
 88521:   }
 88521: 
 88521:   return aContent->HasProperties();
 88521: }
 88521: 
 89870: // If aNode is not optimizable, but is an element
 89870: // with a frame in a document which has currently active presshell,
 89870: // we can act as if it was optimizable. When the primary frame dies, aNode
 89870: // will end up to the purple buffer because of the refcount change.
 89870: bool
 89870: NodeHasActiveFrame(nsIDocument* aCurrentDoc, nsINode* aNode)
 89870: {
 89870:   return aCurrentDoc->GetShell() && aNode->IsElement() &&
 89870:          aNode->AsElement()->GetPrimaryFrame();
 89870: }
 89870: 
 93428: bool
 93428: OwnedByBindingManager(nsIDocument* aCurrentDoc, nsINode* aNode)
 93428: {
 93428:   return aNode->IsElement() &&
 93428:     aCurrentDoc->BindingManager()->GetBinding(aNode->AsElement());
 93428: }
 93428: 
 88521: // CanSkip checks if aNode is black, and if it is, returns
 88521: // true. If aNode is in a black DOM tree, CanSkip may also remove other objects
 88521: // from purple buffer and unmark event listeners and user data.
 88521: // If the root of the DOM tree is a document, less optimizations are done
 88521: // since checking the blackness of the current document is usually fast and we
 88521: // don't want slow down such common cases.
 88521: bool
 89979: nsGenericElement::CanSkip(nsINode* aNode, bool aRemovingAllowed)
 88521: {
 88521:   // Don't try to optimize anything during shutdown.
 88521:   if (nsCCUncollectableMarker::sGeneration == 0) {
 88521:     return false;
 88521:   }
 88521: 
 89870:   bool unoptimizable = UnoptimizableCCNode(aNode);
 88521:   nsIDocument* currentDoc = aNode->GetCurrentDoc();
 88521:   if (currentDoc &&
 89870:       nsCCUncollectableMarker::InGeneration(currentDoc->GetMarkedCCGeneration()) &&
 93428:       (!unoptimizable || NodeHasActiveFrame(currentDoc, aNode) ||
 93428:        OwnedByBindingManager(currentDoc, aNode))) {
 88521:     MarkNodeChildren(aNode);
 88521:     return true;
 88521:   }
 93428: 
 89870:   if (unoptimizable) {
 89870:     return false;
 89870:   }
 88521: 
 88521:   nsINode* root = currentDoc ? static_cast<nsINode*>(currentDoc) :
 88521:                                FindOptimizableSubtreeRoot(aNode);
 88521:   if (!root) {
 88521:     return false;
 88521:   }
 88521:  
 88521:   // Subtree has been traversed already, and aNode
 88521:   // wasn't removed from purple buffer. No need to do more here.
 88521:   if (root->IsPurpleRoot()) {
 88521:     return false;
 88521:   }
 88521: 
 88521:   // nodesToClear contains nodes which are either purple or
 88521:   // gray.
 88521:   nsAutoTArray<nsIContent*, 1020> nodesToClear;
 88521: 
 88521:   bool foundBlack = root->IsBlack();
 88521:   if (root != currentDoc) {
 88521:     currentDoc = nsnull;
 88521:     if (ShouldClearPurple(static_cast<nsIContent*>(root))) {
 88521:       nodesToClear.AppendElement(static_cast<nsIContent*>(root));
 88521:     }
 88521:   }
 88521: 
 88521:   // Traverse the subtree and check if we could know without CC
 88521:   // that it is black.
 88521:   // Note, this traverse is non-virtual and inline, so it should be a lot faster
 88521:   // than CC's generic traverse.
 88521:   for (nsIContent* node = root->GetFirstChild(); node;
 88521:        node = node->GetNextNode(root)) {
 88521:     foundBlack = foundBlack || node->IsBlack();
 88521:     if (foundBlack) {
 88521:       if (currentDoc) {
 88521:         // If we can mark the whole document black, no need to optimize
 88521:         // so much, since when the next purple node in the document will be
 88521:         // handled, it is fast to check that the currentDoc is in CCGeneration.
 88521:         break;
 88521:       }
 88521:       // No need to put stuff to the nodesToClear array, if we can clear it
 88521:       // already here.
 89979:       if (node->IsPurple() && (node != aNode || aRemovingAllowed)) {
 88521:         node->RemovePurple();
 88521:       }
 88521:       MarkNodeChildren(node);
 88521:     } else if (ShouldClearPurple(node)) {
 88521:       // Collect interesting nodes which we can clear if we find that
 88521:       // they are kept alive in a black tree.
 88521:       nodesToClear.AppendElement(node);
 88521:     }
 88521:   }
 88521: 
 89875:   if (!currentDoc || !foundBlack) { 
 88521:     if (!gPurpleRoots) {
 88521:       gPurpleRoots = new nsAutoTArray<nsINode*, 1020>();
 88521:     }
 88521:     root->SetIsPurpleRoot(true);
 88521:     gPurpleRoots->AppendElement(root);
 89875:   }
 89875: 
 89875:   if (!foundBlack) {
 88521:     return false;
 88521:   }
 88521: 
 88521:   if (currentDoc) {
 88521:     // Special case documents. If we know the document is black,
 88521:     // we can mark the document to be in CCGeneration.
 88521:     currentDoc->
 88521:       MarkUncollectableForCCGeneration(nsCCUncollectableMarker::sGeneration);
 88521:     MarkNodeChildren(currentDoc);
 88521:   }
 88521: 
 88521:   // Subtree is black, so we can remove purple nodes from
 88521:   // purple buffer and mark stuff that to be certainly alive.
 88521:   for (PRUint32 i = 0; i < nodesToClear.Length(); ++i) {
 88521:     nsIContent* n = nodesToClear[i];
 88521:     MarkNodeChildren(n);
 89979:     // Can't remove currently handled purple node,
 89979:     // unless aRemovingAllowed is true. 
 89979:     if ((n != aNode || aRemovingAllowed) && n->IsPurple()) {
 88521:       n->RemovePurple();
 88521:     }
 88521:   }
 88521:   return true;
 88521: }
 88521: 
 88521: bool
 88521: nsGenericElement::CanSkipThis(nsINode* aNode)
 88521: {
 88521:   if (nsCCUncollectableMarker::sGeneration == 0) {
 88521:     return false;
 88521:   }
 88521:   if (aNode->IsBlack()) {
 88521:     return true;
 88521:   }
 88521:   nsIDocument* c = aNode->GetCurrentDoc();
 88521:   return 
 88521:     ((c && nsCCUncollectableMarker::InGeneration(c->GetMarkedCCGeneration())) ||
 88521:      aNode->InCCBlackTree()) && !NeedsScriptTraverse(aNode);
 88521: }
 88521: 
 88521: void
 88521: nsGenericElement::InitCCCallbacks()
 88521: {
 88521:   nsCycleCollector_setForgetSkippableCallback(ClearPurpleRoots);
 88521:   nsCycleCollector_setBeforeUnlinkCallback(ClearBlackMarkedNodes);
 88521: }
 88521: 
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsGenericElement)
 89979:   return nsGenericElement::CanSkip(tmp, aRemovingAllowed);
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
 88521: 
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsGenericElement)
 88521:   return nsGenericElement::CanSkipInCC(tmp);
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
 88521: 
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsGenericElement)
 88521:   return nsGenericElement::CanSkipThis(tmp);
 88521: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
 88521: 
 53870: static const char* kNSURIs[] = {
 53870:   " ([none])",
 53870:   " (xmlns)",
 53870:   " (xml)",
 53870:   " (xhtml)",
 53870:   " (XLink)",
 53870:   " (XSLT)",
 53870:   " (XBL)",
 53870:   " (MathML)",
 53870:   " (RDF)",
 53870:   " (XUL)",
 53870:   " (SVG)",
 53870:   " (XML Events)"
 53870: };
 53870: 
 53870: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL(nsGenericElement)
 53870:   if (NS_UNLIKELY(cb.WantDebugInfo())) {
 87376:     char name[512];
 53870:     PRUint32 nsid = tmp->GetNameSpaceID();
 53870:     nsAtomCString localName(tmp->NodeInfo()->NameAtom());
 87376:     nsCAutoString uri;
 87376:     if (tmp->OwnerDoc()->GetDocumentURI()) {
 87376:       tmp->OwnerDoc()->GetDocumentURI()->GetSpec(uri);
 87376:     }
 87376: 
 89912:     nsAutoString id;
 89912:     nsIAtom* idAtom = tmp->GetID();
 89912:     if (idAtom) {
 89912:       id.AppendLiteral(" id='");
 89912:       id.Append(nsDependentAtomString(idAtom));
 89912:       id.AppendLiteral("'");
 89912:     }
 89912: 
 89912:     nsAutoString classes;
 89912:     const nsAttrValue* classAttrValue = tmp->GetClasses();
 89912:     if (classAttrValue) {
 89912:       classes.AppendLiteral(" class='");
 89912:       nsAutoString classString;
 89912:       classAttrValue->ToString(classString);
 94459:       classString.ReplaceChar(PRUnichar('\n'), PRUnichar(' '));
 89912:       classes.Append(classString);
 89912:       classes.AppendLiteral("'");
 89912:     }
 89912: 
 89912:     const char* nsuri = nsid < ArrayLength(kNSURIs) ? kNSURIs[nsid] : "";
 89912:     PR_snprintf(name, sizeof(name), "nsGenericElement%s %s%s%s %s",
 89912:                 nsuri,
 89912:                 localName.get(),
 89912:                 NS_ConvertUTF16toUTF8(id).get(),
 89912:                 NS_ConvertUTF16toUTF8(classes).get(),
 89912:                 uri.get());
 72420:     cb.DescribeRefCountedNode(tmp->mRefCnt.get(), sizeof(nsGenericElement),
 53870:                               name);
 53870:   }
 53870:   else {
 72420:     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(nsGenericElement, tmp->mRefCnt.get())
 53870:   }
 53870: 
 30001:   // Always need to traverse script objects, so do that before we check
 30001:   // if we're uncollectable.
 30001:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 30001: 
 77323:   if (!nsINode::Traverse(tmp, cb)) {
 25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
  1353:   }
  1353: 
 80527:   tmp->OwnerDoc()->BindingManager()->Traverse(tmp, cb);
     1: 
101092:   if (tmp->HasProperties()) {
101092:     if (tmp->IsHTML()) {
101092:       nsISupports* property = static_cast<nsISupports*>
101092:                                          (tmp->GetProperty(nsGkAtoms::microdataProperties));
101092:       cb.NoteXPCOMChild(property);
101092:       property = static_cast<nsISupports*>(tmp->GetProperty(nsGkAtoms::itemref));
101092:       cb.NoteXPCOMChild(property);
101092:       property = static_cast<nsISupports*>(tmp->GetProperty(nsGkAtoms::itemprop));
101092:       cb.NoteXPCOMChild(property);
101092:       property = static_cast<nsISupports*>(tmp->GetProperty(nsGkAtoms::itemtype));
101092:       cb.NoteXPCOMChild(property);
101092:     } else if (tmp->IsXUL()) {
101092:       nsISupports* property = static_cast<nsISupports*>
  3233:                                          (tmp->GetProperty(nsGkAtoms::contextmenulistener));
     1:       cb.NoteXPCOMChild(property);
  3233:       property = static_cast<nsISupports*>
  3233:                             (tmp->GetProperty(nsGkAtoms::popuplistener));
     1:       cb.NoteXPCOMChild(property);
     1:     }
101092:   }
     1: 
 13669:   // Traverse attribute names and child content.
     1:   {
     1:     PRUint32 i;
 13669:     PRUint32 attrs = tmp->mAttrsAndChildren.AttrCount();
 13669:     for (i = 0; i < attrs; i++) {
 13669:       const nsAttrName* name = tmp->mAttrsAndChildren.AttrNameAt(i);
 22064:       if (!name->IsAtom()) {
 22064:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
 22064:                                            "mAttrsAndChildren[i]->NodeInfo()");
 94340:         cb.NoteXPCOMChild(name->NodeInfo());
 13669:       }
 22064:     }
 13669: 
     1:     PRUint32 kids = tmp->mAttrsAndChildren.ChildCount();
 13202:     for (i = 0; i < kids; i++) {
 13202:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mAttrsAndChildren[i]");
     1:       cb.NoteXPCOMChild(tmp->mAttrsAndChildren.GetSafeChildAt(i));
     1:     }
 13202:   }
     1: 
     1:   // Traverse any DOM slots of interest.
     1:   {
     1:     nsDOMSlots *slots = tmp->GetExistingDOMSlots();
     1:     if (slots) {
 77323:       slots->Traverse(cb, tmp->IsXUL());
 77323:     }
 77323:   }
     1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
     1: 
 12033: 
 21618: NS_INTERFACE_MAP_BEGIN(nsGenericElement)
 21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
 21618:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsGenericElement)
 82562:   NS_INTERFACE_MAP_ENTRY(Element)
 12033:   NS_INTERFACE_MAP_ENTRY(nsIContent)
 12033:   NS_INTERFACE_MAP_ENTRY(nsINode)
 72322:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)
 12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsISupportsWeakReference,
 12033:                                  new nsNodeSupportsWeakRefTearoff(this))
 16106:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNodeSelector,
 16106:                                  new nsNodeSelectorTearoff(this))
 29215:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMXPathNSResolver,
 29215:                                  new nsNode3Tearoff(this))
 77147:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsITouchEventReceiver,
 77147:                                  new nsTouchEventReceiverTearoff(this))
 77149:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIInlineEventHandlers,
 77149:                                  new nsInlineEventHandlersTearoff(this))
 12033:   // nsNodeSH::PreCreate() depends on the identity pointer being the
 12033:   // same as nsINode (which nsIContent inherits), so if you change the
 12033:   // below line, make sure nsNodeSH::PreCreate() still does the right
 12033:   // thing!
 12033:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContent)
 12033: NS_INTERFACE_MAP_END
 12033: 
 67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsGenericElement)
 67682: NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_DESTROY(nsGenericElement,
  1391:                                               nsNodeUtils::LastRelease(this))
     1: 
     1: nsresult
     1: nsGenericElement::PostQueryInterface(REFNSIID aIID, void** aInstancePtr)
     1: {
 80527:   return OwnerDoc()->BindingManager()->GetBindingImplementation(this, aIID,
     1:                                                                 aInstancePtr);
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: nsresult
     1: nsGenericElement::LeaveLink(nsPresContext* aPresContext)
     1: {
     1:   nsILinkHandler *handler = aPresContext->GetLinkHandler();
     1:   if (!handler) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   return handler->OnLeaveLink();
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::AddScriptEventListener(nsIAtom* aEventName,
     1:                                          const nsAString& aValue,
 79445:                                          bool aDefer)
     1: {
 80526:   nsIDocument *ownerDoc = OwnerDoc();
 80527:   if (ownerDoc->IsLoadedAsData()) {
  4064:     // Make this a no-op rather than throwing an error to avoid
  4064:     // the error causing problems setting the attribute.
  4064:     return NS_OK;
  4064:   }
  4064: 
     1:   NS_PRECONDITION(aEventName, "Must have event name!");
 79445:   bool defer = true;
 79415:   nsEventListenerManager* manager = GetEventListenerManagerForAttr(aEventName,
 79415:                                                                    &defer);
 32526:   if (!manager) {
 32526:     return NS_OK;
 32526:   }
 29474: 
     1:   defer = defer && aDefer; // only defer if everyone agrees...
 94563:   manager->AddScriptEventListener(aEventName, aValue, nsIProgrammingLanguage::JAVASCRIPT,
 94563:                                   defer, !nsContentUtils::IsChromeDoc(ownerDoc));
 72329:   return NS_OK;
     1: }
     1: 
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: const nsAttrName*
     1: nsGenericElement::InternalGetExistingAttrNameFromQName(const nsAString& aStr) const
     1: {
 39101:   return mAttrsAndChildren.GetExistingAttrNameFromQName(aStr);
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::CopyInnerTo(nsGenericElement* aDst) const
     1: {
     1:   PRUint32 i, count = mAttrsAndChildren.AttrCount();
     1:   for (i = 0; i < count; ++i) {
     1:     const nsAttrName* name = mAttrsAndChildren.AttrNameAt(i);
     1:     const nsAttrValue* value = mAttrsAndChildren.AttrAt(i);
     1:     nsAutoString valStr;
     1:     value->ToString(valStr);
     1:     nsresult rv = aDst->SetAttr(name->NamespaceID(), name->LocalName(),
 80486:                                 name->GetPrefix(), valStr, false);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
 90059: nsGenericElement::MaybeCheckSameAttrVal(PRInt32 aNamespaceID,
 90059:                                         nsIAtom* aName,
 90059:                                         nsIAtom* aPrefix,
 90059:                                         const nsAttrValueOrString& aValue,
 90059:                                         bool aNotify,
 90059:                                         nsAttrValue& aOldValue,
 90059:                                         PRUint8* aModType,
 90059:                                         bool* aHasListeners)
 79445: {
 79445:   bool modification = false;
 61740:   *aHasListeners = aNotify &&
     1:     nsContentUtils::HasMutationListeners(this,
  3137:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
  3137:                                          this);
     1: 
     1:   // If we have no listeners and aNotify is false, we are almost certainly
     1:   // coming from the content sink and will almost certainly have no previous
     1:   // value.  Even if we do, setting the value is cheap when we have no
     1:   // listeners and don't plan to notify.  The check for aNotify here is an
 61740:   // optimization, the check for *aHasListeners is a correctness issue.
 61740:   if (*aHasListeners || aNotify) {
     1:     nsAttrInfo info(GetAttrInfo(aNamespaceID, aName));
     1:     if (info.mValue) {
     1:       // Check whether the old value is the same as the new one.  Note that we
     1:       // only need to actually _get_ the old value if we have listeners.
 61740:       if (*aHasListeners) {
 90059:         // Need to store the old value.
 90059:         //
 90059:         // If the current attribute value contains a pointer to some other data
 90059:         // structure that gets updated in the process of setting the attribute
 90059:         // we'll no longer have the old value of the attribute. Therefore, we
 90059:         // should serialize the attribute value now to keep a snapshot.
 90059:         //
 90059:         // We have to serialize the value anyway in order to create the
 90059:         // mutation event so there's no cost in doing it now.
 90059:         aOldValue.SetToSerialized(*info.mValue);
 90059:       }
 90059:       bool valueMatches = aValue.EqualsAsStrings(*info.mValue);
     1:       if (valueMatches && aPrefix == info.mName->GetPrefix()) {
 99190:         if (OwnerDoc()->MayHaveDOMMutationObservers()) {
 99190:           // For backward compatibility, don't fire mutation events
 99190:           // when setting an attribute to its old value.
 99190:           *aHasListeners = false;
 99190:         } else {
 99190:           return true;
 99190:         }
 80486:       }
 80486:       modification = true;
 61740:     }
 61740:   }
 61740:   *aModType = modification ?
 61740:     static_cast<PRUint8>(nsIDOMMutationEvent::MODIFICATION) :
 61740:     static_cast<PRUint8>(nsIDOMMutationEvent::ADDITION);
 80486:   return false;
 61740: }
 61740: 
 61740: nsresult
 61740: nsGenericElement::SetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
 61740:                           nsIAtom* aPrefix, const nsAString& aValue,
 79445:                           bool aNotify)
 61740: {
 61740:   // Keep this in sync with SetParsedAttr below
 61740: 
 61740:   NS_ENSURE_ARG_POINTER(aName);
 61740:   NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
 61740:                "Don't call SetAttr with unknown namespace");
 61740: 
 61740:   if (!mAttrsAndChildren.CanFitMoreAttrs()) {
 61740:     return NS_ERROR_FAILURE;
 61740:   }
 61740: 
 61740:   PRUint8 modType;
 79445:   bool hasListeners;
 90059:   nsAttrValueOrString value(aValue);
 90059:   nsAttrValue oldValue;
 90059: 
 90059:   if (MaybeCheckSameAttrVal(aNamespaceID, aName, aPrefix, value, aNotify,
 90059:                             oldValue, &modType, &hasListeners)) {
     1:     return NS_OK;
     1:   }
 38453: 
 90060:   nsresult rv = BeforeSetAttr(aNamespaceID, aName, &value, aNotify);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 38453:   if (aNotify) {
 38453:     nsNodeUtils::AttributeWillChange(this, aNamespaceID, aName, modType);
 38453:   }
 38453: 
 63249:   // Hold a script blocker while calling ParseAttribute since that can call
 63249:   // out to id-observers
 70878:   nsAutoScriptBlocker scriptBlocker;
 63249: 
     1:   nsAttrValue attrValue;
     1:   if (!ParseAttribute(aNamespaceID, aName, aValue, attrValue)) {
     1:     attrValue.SetTo(aValue);
     1:   }
     1: 
 63259:   return SetAttrAndNotify(aNamespaceID, aName, aPrefix, oldValue,
 38453:                           attrValue, modType, hasListeners, aNotify,
 90062:                           kCallAfterSetAttr);
     1: }
     1: 
     1: nsresult
 61740: nsGenericElement::SetParsedAttr(PRInt32 aNamespaceID, nsIAtom* aName,
 61740:                                 nsIAtom* aPrefix, nsAttrValue& aParsedValue,
 79445:                                 bool aNotify)
 61740: {
 61740:   // Keep this in sync with SetAttr above
 61740: 
 61740:   NS_ENSURE_ARG_POINTER(aName);
 61740:   NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
 61740:                "Don't call SetAttr with unknown namespace");
 61740: 
 61740:   if (!mAttrsAndChildren.CanFitMoreAttrs()) {
 61740:     return NS_ERROR_FAILURE;
 61740:   }
 61740: 
 89606: 
 61740:   PRUint8 modType;
 79445:   bool hasListeners;
 90059:   nsAttrValueOrString value(aParsedValue);
 90059:   nsAttrValue oldValue;
 89606: 
 89606:   if (MaybeCheckSameAttrVal(aNamespaceID, aName, aPrefix, value, aNotify,
 90059:                             oldValue, &modType, &hasListeners)) {
 61740:     return NS_OK;
 61740:   }
 61740: 
 89606:   nsresult rv = BeforeSetAttr(aNamespaceID, aName, &value, aNotify);
 61740:   NS_ENSURE_SUCCESS(rv, rv);
 61740: 
 61740:   if (aNotify) {
 61740:     nsNodeUtils::AttributeWillChange(this, aNamespaceID, aName, modType);
 61740:   }
 61740: 
 61740:   return SetAttrAndNotify(aNamespaceID, aName, aPrefix, oldValue,
 61740:                           aParsedValue, modType, hasListeners, aNotify,
 90062:                           kCallAfterSetAttr);
 61740: }
 61740: 
 61740: nsresult
     1: nsGenericElement::SetAttrAndNotify(PRInt32 aNamespaceID,
     1:                                    nsIAtom* aName,
     1:                                    nsIAtom* aPrefix,
 90059:                                    const nsAttrValue& aOldValue,
     1:                                    nsAttrValue& aParsedValue,
 38453:                                    PRUint8 aModType,
 79445:                                    bool aFireMutation,
 79445:                                    bool aNotify,
 90061:                                    bool aCallAfterSetAttr)
     1: {
     1:   nsresult rv;
     1: 
     1:   nsIDocument* document = GetCurrentDoc();
     1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
  3410: 
 51858:   nsMutationGuard::DidMutate();
 51858: 
 90061:   // Copy aParsedValue for later use since it will be lost when we call
 90061:   // SetAndTakeMappedAttr below
 90061:   nsAttrValue aValueForAfterSetAttr;
 90061:   if (aCallAfterSetAttr) {
 90061:     aValueForAfterSetAttr.SetTo(aParsedValue);
 90061:   }
 90061: 
     1:   if (aNamespaceID == kNameSpaceID_None) {
     1:     // XXXbz Perhaps we should push up the attribute mapping function
     1:     // stuff to nsGenericElement?
     1:     if (!IsAttributeMapped(aName) ||
     1:         !SetMappedAttribute(document, aName, aParsedValue, &rv)) {
     1:       rv = mAttrsAndChildren.SetAndTakeAttr(aName, aParsedValue);
     1:     }
     1:   }
     1:   else {
 94340:     nsCOMPtr<nsINodeInfo> ni;
 19197:     ni = mNodeInfo->NodeInfoManager()->GetNodeInfo(aName, aPrefix,
 71770:                                                    aNamespaceID,
 71770:                                                    nsIDOMNode::ATTRIBUTE_NODE);
 19747:     NS_ENSURE_TRUE(ni, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:     rv = mAttrsAndChildren.SetAndTakeAttr(ni, aParsedValue);
     1:   }
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 12522:   if (document || HasFlag(NODE_FORCE_XBL_BINDINGS)) {
  2528:     nsRefPtr<nsXBLBinding> binding =
 80527:       OwnerDoc()->BindingManager()->GetBinding(this);
     1:     if (binding) {
 80486:       binding->AttributeChanged(aName, aNamespaceID, false, aNotify);
     1:     }
     1:   }
     1: 
 71121:   UpdateState(aNotify);
 71121: 
  3311:   if (aNotify) {
 38453:     nsNodeUtils::AttributeChanged(this, aNamespaceID, aName, aModType);
  3311:   }
  3311: 
 22222:   if (aNamespaceID == kNameSpaceID_XMLEvents && 
 22222:       aName == nsGkAtoms::event && mNodeInfo->GetDocument()) {
 22222:     mNodeInfo->GetDocument()->AddXMLEventsContent(this);
 22222:   }
 90061:   if (aCallAfterSetAttr) {
 90061:     rv = AfterSetAttr(aNamespaceID, aName, &aValueForAfterSetAttr, aNotify);
 22222:     NS_ENSURE_SUCCESS(rv, rv);
 22222:   }
 22222: 
     1:   if (aFireMutation) {
 80486:     nsMutationEvent mutation(true, NS_MUTATION_ATTRMODIFIED);
     1: 
     1:     nsCOMPtr<nsIDOMAttr> attrNode;
     1:     nsAutoString ns;
     1:     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNamespaceID, ns);
 91151:     GetAttributeNodeNSInternal(ns, nsDependentAtomString(aName),
 39101:                                getter_AddRefs(attrNode));
     1:     mutation.mRelatedNode = attrNode;
     1: 
     1:     mutation.mAttrName = aName;
     1:     nsAutoString newValue;
     1:     GetAttr(aNamespaceID, aName, newValue);
     1:     if (!newValue.IsEmpty()) {
     1:       mutation.mNewAttrValue = do_GetAtom(newValue);
     1:     }
 90059:     if (!aOldValue.IsEmptyString()) {
 90059:       mutation.mPrevAttrValue = aOldValue.GetAsAtom();
     1:     }
 38453:     mutation.mAttrChange = aModType;
 13098: 
 80526:     mozAutoSubtreeModified subtree(OwnerDoc(), this);
 84833:     (new nsAsyncDOMEvent(this, mutation))->RunDOMEventWhenSafe();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
     1: nsGenericElement::ParseAttribute(PRInt32 aNamespaceID,
     1:                                  nsIAtom* aAttribute,
     1:                                  const nsAString& aValue,
     1:                                  nsAttrValue& aResult)
     1: {
 80486:   return false;
     1: }
     1: 
 79445: bool
     1: nsGenericElement::SetMappedAttribute(nsIDocument* aDocument,
     1:                                      nsIAtom* aName,
     1:                                      nsAttrValue& aValue,
     1:                                      nsresult* aRetval)
     1: {
     1:   *aRetval = NS_OK;
 80486:   return false;
     1: }
     1: 
 74595: nsEventListenerManager*
 79415: nsGenericElement::GetEventListenerManagerForAttr(nsIAtom* aAttrName,
 79445:                                                  bool* aDefer)
 74595: {
 80486:   *aDefer = true;
 80486:   return GetListenerManager(true);
     1: }
     1: 
     1: nsGenericElement::nsAttrInfo
     1: nsGenericElement::GetAttrInfo(PRInt32 aNamespaceID, nsIAtom* aName) const
     1: {
     1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
     1:   NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
     1:                "must have a real namespace ID!");
     1: 
     1:   PRInt32 index = mAttrsAndChildren.IndexOfAttr(aName, aNamespaceID);
     1:   if (index >= 0) {
     1:     return nsAttrInfo(mAttrsAndChildren.AttrNameAt(index),
     1:                       mAttrsAndChildren.AttrAt(index));
     1:   }
     1: 
     1:   return nsAttrInfo(nsnull, nsnull);
     1: }
     1:   
     1: 
 79445: bool
     1: nsGenericElement::GetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
     1:                           nsAString& aResult) const
     1: {
     1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
     1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
     1:                "must have a real namespace ID!");
     1: 
     1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
     1:   if (!val) {
     1:     // Since we are returning a success code we'd better do
     1:     // something about the out parameters (someone may have
     1:     // given us a non-empty string).
     1:     aResult.Truncate();
     1:     
 80486:     return false;
     1:   }
     1: 
     1:   val->ToString(aResult);
     1: 
 80486:   return true;
     1: }
     1: 
 79445: bool
     1: nsGenericElement::HasAttr(PRInt32 aNameSpaceID, nsIAtom* aName) const
     1: {
     1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
     1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
     1:                "must have a real namespace ID!");
     1: 
     1:   return mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID) >= 0;
     1: }
     1: 
 79445: bool
     1: nsGenericElement::AttrValueIs(PRInt32 aNameSpaceID,
     1:                               nsIAtom* aName,
     1:                               const nsAString& aValue,
     1:                               nsCaseTreatment aCaseSensitive) const
     1: {
     1:   NS_ASSERTION(aName, "Must have attr name");
     1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
     1: 
     1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
     1:   return val && val->Equals(aValue, aCaseSensitive);
     1: }
     1: 
 79445: bool
     1: nsGenericElement::AttrValueIs(PRInt32 aNameSpaceID,
     1:                               nsIAtom* aName,
     1:                               nsIAtom* aValue,
     1:                               nsCaseTreatment aCaseSensitive) const
     1: {
     1:   NS_ASSERTION(aName, "Must have attr name");
     1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
     1:   NS_ASSERTION(aValue, "Null value atom");
     1: 
     1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
     1:   return val && val->Equals(aValue, aCaseSensitive);
     1: }
     1: 
     1: PRInt32
     1: nsGenericElement::FindAttrValueIn(PRInt32 aNameSpaceID,
     1:                                   nsIAtom* aName,
     1:                                   AttrValuesArray* aValues,
     1:                                   nsCaseTreatment aCaseSensitive) const
     1: {
     1:   NS_ASSERTION(aName, "Must have attr name");
     1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
     1:   NS_ASSERTION(aValues, "Null value array");
     1:   
     1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
     1:   if (val) {
     1:     for (PRInt32 i = 0; aValues[i]; ++i) {
     1:       if (val->Equals(*aValues[i], aCaseSensitive)) {
     1:         return i;
     1:       }
     1:     }
     1:     return ATTR_VALUE_NO_MATCH;
     1:   }
     1:   return ATTR_MISSING;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 79445:                             bool aNotify)
     1: {
     1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
     1: 
     1:   PRInt32 index = mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID);
     1:   if (index < 0) {
     1:     return NS_OK;
     1:   }
     1: 
  8668:   nsresult rv = BeforeSetAttr(aNameSpaceID, aName, nsnull, aNotify);
  8668:   NS_ENSURE_SUCCESS(rv, rv);
  8668: 
     1:   nsIDocument *document = GetCurrentDoc();
     1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
 29833: 
 29833:   if (aNotify) {
 29833:     nsNodeUtils::AttributeWillChange(this, aNameSpaceID, aName,
 29833:                                      nsIDOMMutationEvent::REMOVAL);
 29833:   }
 29833: 
 79445:   bool hasMutationListeners = aNotify &&
     1:     nsContentUtils::HasMutationListeners(this,
  3137:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
  3137:                                          this);
     1: 
     1:   // Grab the attr node if needed before we remove it from the attr map
     1:   nsCOMPtr<nsIDOMAttr> attrNode;
     1:   if (hasMutationListeners) {
     1:     nsAutoString ns;
     1:     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNameSpaceID, ns);
 91151:     GetAttributeNodeNSInternal(ns, nsDependentAtomString(aName),
 39101:                                getter_AddRefs(attrNode));
     1:   }
     1: 
     1:   // Clear binding to nsIDOMNamedNodeMap
     1:   nsDOMSlots *slots = GetExistingDOMSlots();
     1:   if (slots && slots->mAttributeMap) {
     1:     slots->mAttributeMap->DropAttribute(aNameSpaceID, aName);
     1:   }
     1: 
 51858:   // The id-handling code, and in the future possibly other code, need to
 51858:   // react to unexpected attribute changes.
 51858:   nsMutationGuard::DidMutate();
 51858: 
     1:   nsAttrValue oldValue;
  8668:   rv = mAttrsAndChildren.RemoveAttrAt(index, oldValue);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 12522:   if (document || HasFlag(NODE_FORCE_XBL_BINDINGS)) {
  6674:     nsRefPtr<nsXBLBinding> binding =
 80527:       OwnerDoc()->BindingManager()->GetBinding(this);
 12522:     if (binding) {
 80486:       binding->AttributeChanged(aName, aNameSpaceID, true, aNotify);
     1:     }
 12522:   }
     1: 
 71121:   UpdateState(aNotify);
 71121: 
     1:   if (aNotify) {
     1:     nsNodeUtils::AttributeChanged(this, aNameSpaceID, aName,
 35535:                                   nsIDOMMutationEvent::REMOVAL);
     1:   }
     1: 
 22222:   rv = AfterSetAttr(aNameSpaceID, aName, nsnull, aNotify);
 22222:   NS_ENSURE_SUCCESS(rv, rv);
 22222: 
     1:   if (hasMutationListeners) {
 77547:     nsCOMPtr<nsIDOMEventTarget> node = do_QueryObject(this);
 80486:     nsMutationEvent mutation(true, NS_MUTATION_ATTRMODIFIED);
     1: 
     1:     mutation.mRelatedNode = attrNode;
     1:     mutation.mAttrName = aName;
     1: 
     1:     nsAutoString value;
     1:     oldValue.ToString(value);
     1:     if (!value.IsEmpty())
     1:       mutation.mPrevAttrValue = do_GetAtom(value);
     1:     mutation.mAttrChange = nsIDOMMutationEvent::REMOVAL;
     1: 
 80526:     mozAutoSubtreeModified subtree(OwnerDoc(), this);
 84833:     (new nsAsyncDOMEvent(this, mutation))->RunDOMEventWhenSafe();
     1:   }
     1: 
 22222:   return NS_OK;
     1: }
     1: 
     1: const nsAttrName*
     1: nsGenericElement::GetAttrNameAt(PRUint32 aIndex) const
     1: {
     1:   return mAttrsAndChildren.GetSafeAttrNameAt(aIndex);
     1: }
     1: 
     1: PRUint32
     1: nsGenericElement::GetAttrCount() const
     1: {
     1:   return mAttrsAndChildren.AttrCount();
     1: }
     1: 
     1: const nsTextFragment*
     1: nsGenericElement::GetText()
     1: {
     1:   return nsnull;
     1: }
     1: 
     1: PRUint32
 94357: nsGenericElement::TextLength() const
     1: {
     1:   // We can remove this assertion if it turns out to be useful to be able
     1:   // to depend on this returning 0
     1:   NS_NOTREACHED("called nsGenericElement::TextLength");
     1: 
     1:   return 0;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::SetText(const PRUnichar* aBuffer, PRUint32 aLength,
 79445:                           bool aNotify)
     1: {
     1:   NS_ERROR("called nsGenericElement::SetText");
     1: 
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: nsresult
     1: nsGenericElement::AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
 79445:                              bool aNotify)
     1: {
     1:   NS_ERROR("called nsGenericElement::AppendText");
     1: 
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
 79445: bool
 82209: nsGenericElement::TextIsOnlyWhitespace()
     1: {
 80486:   return false;
     1: }
     1: 
     1: void
     1: nsGenericElement::AppendTextTo(nsAString& aResult)
     1: {
     1:   // We can remove this assertion if it turns out to be useful to be able
     1:   // to depend on this appending nothing.
     1:   NS_NOTREACHED("called nsGenericElement::TextLength");
     1: }
     1: 
     1: #ifdef DEBUG
     1: void
     1: nsGenericElement::ListAttributes(FILE* out) const
     1: {
     1:   PRUint32 index, count = mAttrsAndChildren.AttrCount();
     1:   for (index = 0; index < count; index++) {
     1:     nsAutoString buffer;
     1: 
     1:     // name
     1:     mAttrsAndChildren.AttrNameAt(index)->GetQualifiedName(buffer);
     1: 
     1:     // value
     1:     buffer.AppendLiteral("=\"");
     1:     nsAutoString value;
     1:     mAttrsAndChildren.AttrAt(index)->ToString(value);
     1:     for (int i = value.Length(); i >= 0; --i) {
     1:       if (value[i] == PRUnichar('"'))
     1:         value.Insert(PRUnichar('\\'), PRUint32(i));
     1:     }
     1:     buffer.Append(value);
     1:     buffer.AppendLiteral("\"");
     1: 
     1:     fputs(" ", out);
     1:     fputs(NS_LossyConvertUTF16toASCII(buffer).get(), out);
     1:   }
     1: }
     1: 
     1: void
     1: nsGenericElement::List(FILE* out, PRInt32 aIndent,
     1:                        const nsCString& aPrefix) const
     1: {
     1:   PRInt32 indent;
     1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
     1: 
     1:   fputs(aPrefix.get(), out);
     1: 
 69361:   fputs(NS_LossyConvertUTF16toASCII(mNodeInfo->QualifiedName()).get(), out);
     1: 
     1:   fprintf(out, "@%p", (void *)this);
     1: 
     1:   ListAttributes(out);
     1: 
 71121:   fprintf(out, " state=[%llx]", State().GetInternalValue());
 42285:   fprintf(out, " flags=[%08x]", static_cast<unsigned int>(GetFlags()));
 85101:   if (IsCommonAncestorForRangeInSelection()) {
 86939:     nsRange::RangeHashTable* ranges =
 86939:       static_cast<nsRange::RangeHashTable*>(GetProperty(nsGkAtoms::range));
 85101:     fprintf(out, " ranges:%d", ranges ? ranges->Count() : 0);
 85101:   }
 41676:   fprintf(out, " primaryframe=%p", static_cast<void*>(GetPrimaryFrame()));
     1:   fprintf(out, " refcount=%d<", mRefCnt.get());
     1: 
 78992:   nsIContent* child = GetFirstChild();
 78992:   if (child) {
     1:     fputs("\n", out);
     1:     
 78992:     for (; child; child = child->GetNextSibling()) {
 78992:       child->List(out, aIndent + 1);
     1:     }
     1: 
     1:     for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
     1:   }
     1: 
     1:   fputs(">\n", out);
     1:   
  3233:   nsGenericElement* nonConstThis = const_cast<nsGenericElement*>(this);
     1: 
     1:   // XXX sXBL/XBL2 issue! Owner or current document?
 80526:   nsIDocument *document = OwnerDoc();
 80527: 
     1:   // Note: not listing nsIAnonymousContentCreator-created content...
     1: 
     1:   nsBindingManager* bindingManager = document->BindingManager();
     1:   nsCOMPtr<nsIDOMNodeList> anonymousChildren;
     1:   bindingManager->GetAnonymousNodesFor(nonConstThis,
     1:                                        getter_AddRefs(anonymousChildren));
     1: 
     1:   if (anonymousChildren) {
 78992:     PRUint32 length;
     1:     anonymousChildren->GetLength(&length);
     1:     if (length > 0) {
     1:       for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
     1:       fputs("anonymous-children<\n", out);
     1: 
 78992:       for (PRUint32 i = 0; i < length; ++i) {
     1:         nsCOMPtr<nsIDOMNode> node;
     1:         anonymousChildren->Item(i, getter_AddRefs(node));
     1:         nsCOMPtr<nsIContent> child = do_QueryInterface(node);
     1:         child->List(out, aIndent + 1);
     1:       }
     1: 
     1:       for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
     1:       fputs(">\n", out);
     1:     }
     1:   }
     1: 
     1:   if (bindingManager->HasContentListFor(nonConstThis)) {
     1:     nsCOMPtr<nsIDOMNodeList> contentList;
     1:     bindingManager->GetContentListFor(nonConstThis,
     1:                                       getter_AddRefs(contentList));
     1: 
     1:     NS_ASSERTION(contentList != nsnull, "oops, binding manager lied");
     1:     
 78992:     PRUint32 length;
     1:     contentList->GetLength(&length);
     1:     if (length > 0) {
     1:       for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
     1:       fputs("content-list<\n", out);
     1: 
 78992:       for (PRUint32 i = 0; i < length; ++i) {
     1:         nsCOMPtr<nsIDOMNode> node;
     1:         contentList->Item(i, getter_AddRefs(node));
     1:         nsCOMPtr<nsIContent> child = do_QueryInterface(node);
     1:         child->List(out, aIndent + 1);
     1:       }
     1: 
     1:       for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
     1:       fputs(">\n", out);
     1:     }
     1:   }
     1: }
     1: 
     1: void
     1: nsGenericElement::DumpContent(FILE* out, PRInt32 aIndent,
 79445:                               bool aDumpAll) const
     1: {
     1:   PRInt32 indent;
     1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
     1: 
 69361:   const nsString& buf = mNodeInfo->QualifiedName();
     1:   fputs("<", out);
     1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
     1: 
     1:   if(aDumpAll) ListAttributes(out);
     1: 
     1:   fputs(">", out);
     1: 
     1:   if(aIndent) fputs("\n", out);
     1: 
 78992:   for (nsIContent* child = GetFirstChild();
 78992:        child;
 78992:        child = child->GetNextSibling()) {
     1:     PRInt32 indent = aIndent ? aIndent + 1 : 0;
 78992:     child->DumpContent(out, indent, aDumpAll);
     1:   }
     1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
     1:   fputs("</", out);
     1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
     1:   fputs(">", out);
     1: 
     1:   if(aIndent) fputs("\n", out);
     1: }
     1: #endif
     1: 
     1: PRUint32
     1: nsGenericElement::GetChildCount() const
     1: {
     1:   return mAttrsAndChildren.ChildCount();
     1: }
     1: 
     1: nsIContent *
     1: nsGenericElement::GetChildAt(PRUint32 aIndex) const
     1: {
     1:   return mAttrsAndChildren.GetSafeChildAt(aIndex);
     1: }
     1: 
 15810: nsIContent * const *
 22251: nsGenericElement::GetChildArray(PRUint32* aChildCount) const
 22251: {
 22251:   return mAttrsAndChildren.GetChildArray(aChildCount);
 15810: }
 15810: 
     1: PRInt32
     1: nsGenericElement::IndexOf(nsINode* aPossibleChild) const
     1: {
     1:   return mAttrsAndChildren.IndexOfChild(aPossibleChild);
     1: }
     1: 
     1: nsINode::nsSlots*
     1: nsGenericElement::CreateSlots()
     1: {
 67604:   return new nsDOMSlots();
     1: }
     1: 
 79445: bool
   723: nsGenericElement::CheckHandleEventForLinksPrecondition(nsEventChainVisitor& aVisitor,
   723:                                                        nsIURI** aURI) const
   723: {
   723:   if (aVisitor.mEventStatus == nsEventStatus_eConsumeNoDefault ||
 72783:       (!NS_IS_TRUSTED_EVENT(aVisitor.mEvent) &&
 72783:        (aVisitor.mEvent->message != NS_MOUSE_CLICK) &&
 72783:        (aVisitor.mEvent->message != NS_KEY_PRESS) &&
 72783:        (aVisitor.mEvent->message != NS_UI_ACTIVATE)) ||
 59693:       !aVisitor.mPresContext ||
 74191:       (aVisitor.mEvent->flags & NS_EVENT_FLAG_PREVENT_MULTIPLE_ACTIONS)) {
 80486:     return false;
   723:   }
   723: 
   723:   // Make sure we actually are a link
   723:   return IsLink(aURI);
   723: }
   723: 
   723: nsresult
   723: nsGenericElement::PreHandleEventForLinks(nsEventChainPreVisitor& aVisitor)
   723: {
   723:   // Optimisation: return early if this event doesn't interest us.
   723:   // IMPORTANT: this switch and the switch below it must be kept in sync!
   723:   switch (aVisitor.mEvent->message) {
   723:   case NS_MOUSE_ENTER_SYNTH:
   723:   case NS_FOCUS_CONTENT:
   723:   case NS_MOUSE_EXIT_SYNTH:
   723:   case NS_BLUR_CONTENT:
   723:     break;
   723:   default:
   723:     return NS_OK;
   723:   }
   723: 
   723:   // Make sure we meet the preconditions before continuing
   723:   nsCOMPtr<nsIURI> absURI;
   723:   if (!CheckHandleEventForLinksPrecondition(aVisitor, getter_AddRefs(absURI))) {
   723:     return NS_OK;
   723:   }
   723: 
   723:   nsresult rv = NS_OK;
   723: 
   723:   // We do the status bar updates in PreHandleEvent so that the status bar gets
   723:   // updated even if the event is consumed before we have a chance to set it.
   723:   switch (aVisitor.mEvent->message) {
 56051:   // Set the status bar similarly for mouseover and focus
   723:   case NS_MOUSE_ENTER_SYNTH:
   723:     aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
   723:     // FALL THROUGH
   723:   case NS_FOCUS_CONTENT:
 56051:     if (aVisitor.mEvent->eventStructType != NS_FOCUS_EVENT ||
 56051:         !static_cast<nsFocusEvent*>(aVisitor.mEvent)->isRefocus) {
   723:       nsAutoString target;
   723:       GetLinkTarget(target);
  3333:       nsContentUtils::TriggerLink(this, aVisitor.mPresContext, absURI, target,
 80486:                                   false, true, true);
 59693:       // Make sure any ancestor links don't also TriggerLink
 74191:       aVisitor.mEvent->flags |= NS_EVENT_FLAG_PREVENT_MULTIPLE_ACTIONS;
   723:     }
   723:     break;
   723: 
   723:   case NS_MOUSE_EXIT_SYNTH:
   723:     aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
   723:     // FALL THROUGH
   723:   case NS_BLUR_CONTENT:
   723:     rv = LeaveLink(aVisitor.mPresContext);
 59693:     if (NS_SUCCEEDED(rv)) {
 74191:       aVisitor.mEvent->flags |= NS_EVENT_FLAG_PREVENT_MULTIPLE_ACTIONS;
 59693:     }
   723:     break;
   723: 
   723:   default:
   723:     // switch not in sync with the optimization switch earlier in this function
   723:     NS_NOTREACHED("switch statements not in sync");
   723:     return NS_ERROR_UNEXPECTED;
   723:   }
   723: 
   723:   return rv;
   723: }
   723: 
     1: nsresult
     1: nsGenericElement::PostHandleEventForLinks(nsEventChainPostVisitor& aVisitor)
     1: {
     1:   // Optimisation: return early if this event doesn't interest us.
     1:   // IMPORTANT: this switch and the switch below it must be kept in sync!
     1:   switch (aVisitor.mEvent->message) {
     1:   case NS_MOUSE_BUTTON_DOWN:
     1:   case NS_MOUSE_CLICK:
     1:   case NS_UI_ACTIVATE:
     1:   case NS_KEY_PRESS:
     1:     break;
     1:   default:
     1:     return NS_OK;
     1:   }
     1: 
   723:   // Make sure we meet the preconditions before continuing
     1:   nsCOMPtr<nsIURI> absURI;
   723:   if (!CheckHandleEventForLinksPrecondition(aVisitor, getter_AddRefs(absURI))) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   switch (aVisitor.mEvent->message) {
     1:   case NS_MOUSE_BUTTON_DOWN:
     1:     {
     1:       if (aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
  3233:           static_cast<nsMouseEvent*>(aVisitor.mEvent)->button ==
     1:           nsMouseEvent::eLeftButton) {
     1:         // don't make the link grab the focus if there is no link handler
     1:         nsILinkHandler *handler = aVisitor.mPresContext->GetLinkHandler();
     1:         nsIDocument *document = GetCurrentDoc();
 29018:         if (handler && document) {
 29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:           if (fm) {
 74191:             aVisitor.mEvent->flags |= NS_EVENT_FLAG_PREVENT_MULTIPLE_ACTIONS;
 29018:             nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(this);
 32919:             fm->SetFocus(elem, nsIFocusManager::FLAG_BYMOUSE |
 32919:                                nsIFocusManager::FLAG_NOSCROLL);
     1:           }
     1: 
 56644:           nsEventStateManager::SetActiveManager(
 68780:             aVisitor.mPresContext->EventStateManager(), this);
     1:         }
     1:       }
     1:     }
     1:     break;
     1: 
     1:   case NS_MOUSE_CLICK:
     1:     if (NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent)) {
 33800:       nsInputEvent* inputEvent = static_cast<nsInputEvent*>(aVisitor.mEvent);
 96893:       if (inputEvent->IsControl() || inputEvent->IsMeta() ||
 96893:           inputEvent->IsAlt() ||inputEvent->IsShift()) {
 33800:         break;
 33800:       }
 33800: 
     1:       // The default action is simply to dispatch DOMActivate
    95:       nsCOMPtr<nsIPresShell> shell = aVisitor.mPresContext->GetPresShell();
     1:       if (shell) {
     1:         // single-click
     1:         nsEventStatus status = nsEventStatus_eIgnore;
     1:         nsUIEvent actEvent(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
     1:                            NS_UI_ACTIVATE, 1);
     1: 
     1:         rv = shell->HandleDOMEventWithTarget(this, &actEvent, &status);
 59693:         if (NS_SUCCEEDED(rv)) {
 59693:           aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
 59693:         }
     1:       }
     1:     }
     1:     break;
     1: 
     1:   case NS_UI_ACTIVATE:
     1:     {
 59815:       if (aVisitor.mEvent->originalTarget == this) {
     1:         nsAutoString target;
     1:         GetLinkTarget(target);
  3333:         nsContentUtils::TriggerLink(this, aVisitor.mPresContext, absURI, target,
 80486:                                     true, true, NS_IS_TRUSTED_EVENT(aVisitor.mEvent));
 59693:         aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
 59693:       }
     1:     }
     1:     break;
     1: 
     1:   case NS_KEY_PRESS:
     1:     {
     1:       if (aVisitor.mEvent->eventStructType == NS_KEY_EVENT) {
  3233:         nsKeyEvent* keyEvent = static_cast<nsKeyEvent*>(aVisitor.mEvent);
     1:         if (keyEvent->keyCode == NS_VK_RETURN) {
     1:           nsEventStatus status = nsEventStatus_eIgnore;
     1:           rv = DispatchClickEvent(aVisitor.mPresContext, keyEvent, this,
 80486:                                   false, 0, &status);
     1:           if (NS_SUCCEEDED(rv)) {
     1:             aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
     1:           }
     1:         }
     1:       }
     1:     }
     1:     break;
     1: 
     1:   default:
     1:     // switch not in sync with the optimization switch earlier in this function
     1:     NS_NOTREACHED("switch statements not in sync");
     1:     return NS_ERROR_UNEXPECTED;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: void
 69573: nsGenericElement::FireNodeRemovedForChildren()
 69573: {
 80526:   nsIDocument* doc = OwnerDoc();
 69573:   // Optimize the common case
 69573:   if (!nsContentUtils::
 69573:         HasMutationListeners(doc, NS_EVENT_BITS_MUTATION_NODEREMOVED)) {
 69573:     return;
 69573:   }
 69573: 
 69573:   nsCOMPtr<nsIDocument> owningDoc = doc;
 69573: 
 69573:   nsCOMPtr<nsINode> child;
 69573:   for (child = GetFirstChild();
 69573:        child && child->GetNodeParent() == this;
 69573:        child = child->GetNextSibling()) {
 69573:     nsContentUtils::MaybeFireNodeRemoved(child, this, doc);
 69573:   }
 69573: }
 69573: 
 69573: void
     1: nsGenericElement::GetLinkTarget(nsAString& aTarget)
     1: {
     1:   aTarget.Truncate();
     1: }
     1: 
 94465: static void
 94465: nsCOMArrayDeleter(void* aObject, nsIAtom* aPropertyName,
 94465:                   void* aPropertyValue, void* aData)
 94465: {
 94465:   nsCOMArray<nsISupports>* objects =
 94465:     static_cast<nsCOMArray<nsISupports>*>(aPropertyValue);
 94465:   delete objects;
 94465: }
 94465: 
 94465: void
 94465: nsINode::BindObject(nsISupports* aObject)
 94465: {
 94465:   nsCOMArray<nsISupports>* objects =
 94465:     static_cast<nsCOMArray<nsISupports>*>(GetProperty(nsGkAtoms::keepobjectsalive));
 94465:   if (!objects) {
 94465:     objects = new nsCOMArray<nsISupports>();
 94465:     SetProperty(nsGkAtoms::keepobjectsalive, objects, nsCOMArrayDeleter, true);
 94465:   }
 94465:   objects->AppendObject(aObject);
 94465: }
 94465: 
 94465: void
 94465: nsINode::UnbindObject(nsISupports* aObject)
 94465: {
 94465:   nsCOMArray<nsISupports>* objects =
 94465:     static_cast<nsCOMArray<nsISupports>*>(GetProperty(nsGkAtoms::keepobjectsalive));
 94465:   if (objects) {
 94465:     objects->RemoveObject(aObject);
 94465:   }
 94465: }
 94465: 
 16106: // NOTE: The aPresContext pointer is NOT addrefed.
 35560: // *aSelectorList might be null even if NS_OK is returned; this
 35560: // happens when all the selectors were pseudo-element selectors.
 16106: static nsresult
 16106: ParseSelectorList(nsINode* aNode,
 16106:                   const nsAString& aSelectorString,
 64155:                   nsCSSSelectorList** aSelectorList)
 16106: {
 16106:   NS_ENSURE_ARG(aNode);
 16106: 
 80526:   nsIDocument* doc = aNode->OwnerDoc();
 38849:   nsCSSParser parser(doc->CSSLoader());
 16106: 
 35560:   nsCSSSelectorList* selectorList;
 38849:   nsresult rv = parser.ParseSelectorString(aSelectorString,
 16106:                                            doc->GetDocumentURI(),
 38849:                                            0, // XXXbz get the line number!
 35560:                                            &selectorList);
 16106:   NS_ENSURE_SUCCESS(rv, rv);
 16106: 
 35560:   // Filter out pseudo-element selectors from selectorList
 35560:   nsCSSSelectorList** slot = &selectorList;
 35560:   do {
 35560:     nsCSSSelectorList* cur = *slot;
 35560:     if (cur->mSelectors->IsPseudoElement()) {
 35560:       *slot = cur->mNext;
 35560:       cur->mNext = nsnull;
 35560:       delete cur;
 35560:     } else {
 35560:       slot = &cur->mNext;
 35560:     }
 35560:   } while (*slot);
 35560:   *aSelectorList = selectorList;
 35560: 
 16106:   return NS_OK;
 16106: }
 16106: 
 81140: // Actually find elements matching aSelectorList (which must not be
 93774: // null) and which are descendants of aRoot and put them in aList.  If
 81140: // onlyFirstMatch, then stop once the first one is found.
 81139: template<bool onlyFirstMatch, class T>
 81139: inline static nsresult FindMatchingElements(nsINode* aRoot,
 81139:                                             const nsAString& aSelector,
 81139:                                             T &aList)
 81139: {
 41909:   nsAutoPtr<nsCSSSelectorList> selectorList;
 81139:   nsresult rv = ParseSelectorList(aRoot, aSelector,
 64155:                                   getter_Transfers(selectorList));
 81139:   NS_ENSURE_SUCCESS(rv, rv);
 81140:   NS_ENSURE_TRUE(selectorList, NS_OK);
 81140: 
 81140:   NS_ASSERTION(selectorList->mSelectors,
 81140:                "How can we not have any selectors?");
 81140: 
 81140:   nsIDocument* doc = aRoot->OwnerDoc();  
 81140:   TreeMatchContext matchingContext(false, nsRuleWalker::eRelevantLinkUnvisited,
101616:                                    doc, TreeMatchContext::eNeverMatchVisited);
 82192:   doc->FlushPendingLinkUpdates();
 81140: 
 81140:   // Fast-path selectors involving IDs.  We can only do this if aRoot
 81140:   // is in the document and the document is not in quirks mode, since
 81140:   // ID selectors are case-insensitive in quirks mode.  Also, only do
 81140:   // this if selectorList only has one selector, because otherwise
 81140:   // ordering the elements correctly is a pain.
 81392:   NS_ASSERTION(aRoot->IsElement() || aRoot->IsNodeOfType(nsINode::eDOCUMENT) ||
 81392:                !aRoot->IsInDoc(),
 81392:                "The optimization below to check ContentIsDescendantOf only for "
 81392:                "elements depends on aRoot being either an element or a "
 81392:                "document if it's in the document.");
 81140:   if (aRoot->IsInDoc() &&
 81140:       doc->GetCompatibilityMode() != eCompatibility_NavQuirks &&
 81140:       !selectorList->mNext &&
 81140:       selectorList->mSelectors->mIDList) {
 81140:     nsIAtom* id = selectorList->mSelectors->mIDList->mAtom;
 81140:     const nsSmallVoidArray* elements =
 81140:       doc->GetAllElementsForId(nsDependentAtomString(id));
 81140: 
 81140:     // XXXbz: Should we fall back to the tree walk if aRoot is not the
 81140:     // document and |elements| is long, for some value of "long"?
 81140:     if (elements) {
 81392:       for (PRInt32 i = 0; i < elements->Count(); ++i) {
 81140:         Element *element = static_cast<Element*>(elements->ElementAt(i));
 81140:         if (!aRoot->IsElement() ||
 93774:             (element != aRoot &&
 93774:              nsContentUtils::ContentIsDescendantOf(element, aRoot))) {
 93774:           // We have an element with the right id and it's a strict descendant
 81140:           // of aRoot.  Make sure it really matches the selector.
 81140:           if (nsCSSRuleProcessor::SelectorListMatches(element, matchingContext,
 81140:                                                       selectorList)) {
 81140:             aList.AppendElement(element);
 81140:             if (onlyFirstMatch) {
 81140:               return NS_OK;
 81140:             }
 81140:           }
 81140:         }
 81140:       }
 81140:     }
 81140: 
 81140:     // No elements with this id, or none of them are our descendants,
 81140:     // or none of them match.  We're done here.
 81140:     return NS_OK;
 81140:   }
 81140: 
 64159:   for (nsIContent* cur = aRoot->GetFirstChild();
 64159:        cur;
 64159:        cur = cur->GetNextNode(aRoot)) {
 64159:     if (cur->IsElement() &&
 64159:         nsCSSRuleProcessor::SelectorListMatches(cur->AsElement(),
 64159:                                                 matchingContext,
 64159:                                                 selectorList)) {
 81139:       aList.AppendElement(cur->AsElement());
 81139:       if (onlyFirstMatch) {
 81139:         return NS_OK;
 81139:       }
 81139:     }
 81139:   }
 81139: 
 81139:   return NS_OK;
 81139: }
 81139: 
 81139: struct ElementHolder {
 81139:   ElementHolder() : mElement(nsnull) {}
 81139:   void AppendElement(Element* aElement) {
 81139:     NS_ABORT_IF_FALSE(!mElement, "Should only get one element");
 81139:     mElement = aElement;
 81139:   }
 81139:   Element* mElement;
 81139: };
 81139: 
 81139: /* static */
 81139: nsIContent*
 81139: nsGenericElement::doQuerySelector(nsINode* aRoot, const nsAString& aSelector,
 81139:                                   nsresult *aResult)
 81139: {
 81139:   NS_PRECONDITION(aResult, "Null out param?");
 81139: 
 81139:   ElementHolder holder;
 81139:   *aResult = FindMatchingElements<true>(aRoot, aSelector, holder);
 81139: 
 81139:   return holder.mElement;
 41909: }
 41909: 
 41909: /* static */
 16106: nsresult
 41909: nsGenericElement::doQuerySelectorAll(nsINode* aRoot,
 41909:                                      const nsAString& aSelector,
 41909:                                      nsIDOMNodeList **aReturn)
 16106: {
 16106:   NS_PRECONDITION(aReturn, "Null out param?");
 16106: 
 69024:   nsSimpleContentList* contentList = new nsSimpleContentList(aRoot);
 41909:   NS_ENSURE_TRUE(contentList, NS_ERROR_OUT_OF_MEMORY);
 41909:   NS_ADDREF(*aReturn = contentList);
 41909:   
 81139:   return FindMatchingElements<false>(aRoot, aSelector, *contentList);
 16106: }
 33351: 
 41910: 
 79445: bool
 56306: nsGenericElement::MozMatchesSelector(const nsAString& aSelector, nsresult* aResult)
 33351: {
 33351:   nsAutoPtr<nsCSSSelectorList> selectorList;
 79445:   bool matches = false;
 33351: 
 64155:   *aResult = ParseSelectorList(this, aSelector, getter_Transfers(selectorList));
 56306: 
 56306:   if (NS_SUCCEEDED(*aResult)) {
 82192:     OwnerDoc()->FlushPendingLinkUpdates();
 80486:     TreeMatchContext matchingContext(false,
 64155:                                      nsRuleWalker::eRelevantLinkUnvisited,
101616:                                      OwnerDoc(),
101616:                                      TreeMatchContext::eNeverMatchVisited);
 64155:     matches = nsCSSRuleProcessor::SelectorListMatches(this, matchingContext,
 64155:                                                       selectorList);
 33351:   }
 33351: 
 33351:   return matches;
 33351: }
 41910: 
 41910: NS_IMETHODIMP
 84859: nsGenericElement::MozMatchesSelector(const nsAString& aSelector, bool* aReturn)
 41910: {
 41910:   NS_PRECONDITION(aReturn, "Null out param?");
 56306: 
 56306:   nsresult rv;
 84859:   *aReturn = MozMatchesSelector(aSelector, &rv);
 56306: 
 56306:   return rv;
 56306: }
 73721: 
 91403: size_t
 91403: nsINode::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const
 91403: {
 91403:   size_t n = 0;
 77262:   nsEventListenerManager* elm =
 80486:     const_cast<nsINode*>(this)->GetListenerManager(false);
 77262:   if (elm) {
 91403:     n += elm->SizeOfIncludingThis(aMallocSizeOf);
 91403:   }
 91403: 
 91403:   // Measurement of the following members may be added later if DMD finds it is
 91403:   // worthwhile:
 91403:   // - mNodeInfo (Nb: allocated in nsNodeInfo.cpp with a nsFixedSizeAllocator)
 91403:   // - mSlots
 91403:   //
 91403:   // The following members are not measured:
 91403:   // - mParent, mNextSibling, mPreviousSibling, mFirstChild: because they're
 91403:   //   non-owning
 91403:   return n;
 91403: }
 91403: 
 91403: size_t
 91403: nsGenericElement::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const
 91403: {
 91403:   return Element::SizeOfExcludingThis(aMallocSizeOf) +
 91403:          mAttrsAndChildren.SizeOfExcludingThis(aMallocSizeOf);
 73721: }
 73721: 
 91989: static const nsAttrValue::EnumTable kCORSAttributeTable[] = {
 91989:   // Order matters here
 91989:   // See ParseCORSValue
 91989:   { "anonymous",       CORS_ANONYMOUS       },
 91989:   { "use-credentials", CORS_USE_CREDENTIALS },
 91989:   { 0 }
 91989: };
 91989: 
 91989: /* static */ void
 91989: nsGenericElement::ParseCORSValue(const nsAString& aValue,
 91989:                                  nsAttrValue& aResult)
 91989: {
 91989:   DebugOnly<bool> success =
 91989:     aResult.ParseEnumValue(aValue, kCORSAttributeTable, false,
 91989:                            // default value is anonymous if aValue is
 91989:                            // not a value we understand
 91989:                            &kCORSAttributeTable[0]);
 91989:   MOZ_ASSERT(success);
 91989: }
 91989: 
 91990: /* static */ CORSMode
 91990: nsGenericElement::StringToCORSMode(const nsAString& aValue)
 91990: {
 91990:   if (aValue.IsVoid()) {
 91990:     return CORS_NONE;
 91990:   }
 91990: 
 91990:   nsAttrValue val;
 91990:   nsGenericElement::ParseCORSValue(aValue, val);
 91990:   return CORSMode(val.GetEnumValue());
 91990: }
 91990: 
 91991: /* static */ CORSMode
 91991: nsGenericElement::AttrValueToCORSMode(const nsAttrValue* aValue)
 91991: {
 91991:   if (!aValue) {
 91991:     return CORS_NONE;
 91991:   }
 91991: 
 91991:   return CORSMode(aValue->GetEnumValue());
 91991: }
 91991: 
 77149: #define EVENT(name_, id_, type_, struct_)                                    \
 77149:   NS_IMETHODIMP nsINode::GetOn##name_(JSContext *cx, jsval *vp) {            \
 80486:     nsEventListenerManager *elm = GetListenerManager(false);              \
 77149:     if (elm) {                                                               \
 77149:       elm->GetJSEventListener(nsGkAtoms::on##name_, vp);                     \
 77149:     } else {                                                                 \
 77149:       *vp = JSVAL_NULL;                                                      \
 77149:     }                                                                        \
 77149:     return NS_OK;                                                            \
 77149:   }                                                                          \
 77149:   NS_IMETHODIMP nsINode::SetOn##name_(JSContext *cx, const jsval &v) {       \
 80486:     nsEventListenerManager *elm = GetListenerManager(true);               \
 77149:     if (!elm) {                                                              \
 77149:       return NS_ERROR_OUT_OF_MEMORY;                                         \
 77149:     }                                                                        \
 77149:                                                                              \
 77149:     JSObject *obj = GetWrapper();                                            \
 77149:     if (!obj) {                                                              \
 77149:       /* Just silently do nothing */                                         \
 77149:       return NS_OK;                                                          \
 77149:     }                                                                        \
 77149:     return elm->SetJSEventListenerToJsval(nsGkAtoms::on##name_, cx, obj, v); \
 77149: }
 77149: #define TOUCH_EVENT EVENT
 78484: #define DOCUMENT_ONLY_EVENT EVENT
 77149: #include "nsEventNameList.h"
 78484: #undef DOCUMENT_ONLY_EVENT
 77149: #undef TOUCH_EVENT
 77149: #undef EVENT
 77764: 
 84859: NS_IMETHODIMP
 84859: nsGenericElement::GetOnmouseenter(JSContext* cx, JS::Value* vp)
 84859: {
 84859:   return nsINode::GetOnmouseenter(cx, vp);
 84859: }
 84859: 
 84859: NS_IMETHODIMP
 84859: nsGenericElement::SetOnmouseenter(JSContext* cx, const JS::Value& v)
 84859: {
 84859:   return nsINode::SetOnmouseenter(cx, v);
 84859: }
 84859: 
 84859: NS_IMETHODIMP
 84859: nsGenericElement::GetOnmouseleave(JSContext* cx, JS::Value* vp)
 84859: {
 84859:   return nsINode::GetOnmouseleave(cx, vp);
 84859: }
 84859: 
 84859: NS_IMETHODIMP
 84859: nsGenericElement::SetOnmouseleave(JSContext* cx, const JS::Value& v)
 84859: {
 84859:   return nsINode::SetOnmouseleave(cx, v);
 84859: }
 84859: 
 79445: bool
 77764: nsINode::Contains(const nsINode* aOther) const
 77764: {
 77958:   if (aOther == this) {
 80486:     return true;
 77958:   }
 77764:   if (!aOther ||
 80526:       OwnerDoc() != aOther->OwnerDoc() ||
 77764:       IsInDoc() != aOther->IsInDoc() ||
 77764:       !(aOther->IsElement() ||
 77764:         aOther->IsNodeOfType(nsINode::eCONTENT)) ||
 77764:       !GetFirstChild()) {
 80486:     return false;
 77764:   }
 77764: 
 77764:   const nsIContent* other = static_cast<const nsIContent*>(aOther);
 80526:   if (this == OwnerDoc()) {
 77764:     // document.contains(aOther) returns true if aOther is in the document,
 77764:     // but is not in any anonymous subtree.
 77764:     // IsInDoc() check is done already before this.
 77764:     return !other->IsInAnonymousSubtree();
 77764:   }
 77764: 
 77764:   if (!IsElement() && !IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT)) {
 80486:     return false;
 77764:   }
 77764: 
 77764:   const nsIContent* thisContent = static_cast<const nsIContent*>(this);
 77764:   if (thisContent->GetBindingParent() != other->GetBindingParent()) {
 80486:     return false;
 77764:   }
 77764: 
 77764:   return nsContentUtils::ContentIsDescendantOf(other, this);
 77764: }
 77764: 
 77764: nsresult
 79445: nsINode::Contains(nsIDOMNode* aOther, bool* aReturn)
 77764: {
 77764:   nsCOMPtr<nsINode> node = do_QueryInterface(aOther);
 77764:   *aReturn = Contains(node);
 77764:   return NS_OK;
 77764: }
 93984: 
 95203: NS_IMETHODIMP
 95203: nsGenericElement::MozRequestPointerLock()
 95203: {
 95203:   OwnerDoc()->RequestPointerLock(this);
 95203:   return NS_OK;
 95203: }
 95203: 
 94357: PRUint32
 94357: nsINode::Length() const
 94357: {
 94357:   switch (NodeType()) {
 94357:   case nsIDOMNode::DOCUMENT_TYPE_NODE:
 94357:     return 0;
 94357: 
 94357:   case nsIDOMNode::TEXT_NODE:
 94357:   case nsIDOMNode::CDATA_SECTION_NODE:
 94357:   case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
 94357:   case nsIDOMNode::COMMENT_NODE:
 94357:     MOZ_ASSERT(IsNodeOfType(eCONTENT));
 94357:     return static_cast<const nsIContent*>(this)->TextLength();
 94357: 
 94357:   default:
 94357:     return GetChildCount();
 94357:   }
 94357: }
 94357: 
 98045: static const char*
 98045: GetFullScreenError(nsIDocument* aDoc)
 98045: {
 98045:   if (!nsContentUtils::IsRequestFullScreenAllowed()) {
 98045:     return "FullScreenDeniedNotInputDriven";
 98045:   }
 98045:   
 98045:   if (nsContentUtils::IsSitePermDeny(aDoc->NodePrincipal(), "fullscreen")) {
 98045:     return "FullScreenDeniedBlocked";
 98045:   }
 98045: 
 98045:   return nsnull;
 98045: }
 98045: 
 94339: nsresult nsGenericElement::MozRequestFullScreen()
 93984: {
 93984:   // Only grant full-screen requests if this is called from inside a trusted
 93984:   // event handler (i.e. inside an event handler for a user initiated event).
 93984:   // This stops the full-screen from being abused similar to the popups of old,
 93984:   // and it also makes it harder for bad guys' script to go full-screen and
 93984:   // spoof the browser chrome/window and phish logins etc.
 98045:   const char* error = GetFullScreenError(OwnerDoc());
 98045:   if (error) {
 93984:     nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 93984:                                     "DOM", OwnerDoc(),
 93984:                                     nsContentUtils::eDOM_PROPERTIES,
 98045:                                     error);
 93984:     nsRefPtr<nsAsyncDOMEvent> e =
 93984:       new nsAsyncDOMEvent(OwnerDoc(),
 93984:                           NS_LITERAL_STRING("mozfullscreenerror"),
 93984:                           true,
 93984:                           false);
 93984:     e->PostDOMEvent();
 93984:     return NS_OK;
 93984:   }
 93984: 
 93984:   OwnerDoc()->AsyncRequestFullScreen(this);
 93984: 
 93984:   return NS_OK;
 93984: }
