 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 18830:  * vim: set ts=8 sw=4 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 93250: #include "jsgc.h"
 93250: #include "jsinfer.h"
 93250: #include "jsinterp.h"
 80468: 
 93250: #include "vm/GlobalObject.h"
 93250: #include "vm/MethodGuard.h"
 93250: #include "vm/Stack.h"
 94006: #include "vm/Xdr.h"
 80468: 
 93250: #include "jsobjinlines.h"
 80506: 
 93250: #include "gc/Barrier-inl.h"
 93250: #include "vm/ArgumentsObject-inl.h"
     1: 
 37741: using namespace js;
 54707: using namespace js::gc;
 37741: 
101075: ArgumentsObject *
101075: ArgumentsObject::create(JSContext *cx, StackFrame *fp)
100006: {
101075:     JSFunction &callee = fp->callee();
101075:     RootedObject proto(cx, callee.global().getOrCreateObjectPrototype(cx));
 93249:     if (!proto)
 93249:         return NULL;
 93249: 
 99421:     RootedTypeObject type(cx);
 93249:     type = proto->getNewType(cx);
 93249:     if (!type)
 93249:         return NULL;
 93249: 
101075:     bool strict = callee.inStrictMode();
 93249:     Class *clasp = strict ? &StrictArgumentsObjectClass : &NormalArgumentsObjectClass;
 93249: 
 99421:     RootedShape emptyArgumentsShape(cx);
 93249:     emptyArgumentsShape =
 93249:         EmptyShape::getInitialShape(cx, clasp, proto,
 93249:                                     proto->getParent(), FINALIZE_KIND,
 93249:                                     BaseShape::INDEXED);
 93249:     if (!emptyArgumentsShape)
 93249:         return NULL;
 93249: 
101075:     unsigned numActuals = fp->numActualArgs();
101075:     unsigned numFormals = fp->numFormalArgs();
101075:     unsigned numDeletedWords = NumWordsForBitArrayOfLength(numActuals);
101075:     unsigned numArgs = Max(numActuals, numFormals);
101075:     unsigned numBytes = offsetof(ArgumentsData, args) +
 93646:                         numDeletedWords * sizeof(size_t) +
101075:                         numArgs * sizeof(Value);
 93646: 
 93646:     ArgumentsData *data = (ArgumentsData *)cx->malloc_(numBytes);
 93249:     if (!data)
 93249:         return NULL;
 93249: 
101075:     data->numArgs = numArgs;
101075:     data->callee.init(ObjectValue(callee));
101075:     data->script = fp->script();
101075: 
101075:     /* Copy [0, numArgs) into data->slots. */
101075:     HeapValue *dst = data->args, *dstEnd = data->args + numArgs;
101075:     for (Value *src = fp->formals(), *end = src + numFormals; src != end; ++src, ++dst)
101075:         dst->init(*src);
101075:     if (numActuals > numFormals) {
101075:         for (Value *src = fp->actuals() + numFormals; dst != dstEnd; ++src, ++dst)
101075:             dst->init(*src);
101075:     } else if (numActuals < numFormals) {
101075:         for (; dst != dstEnd; ++dst)
101075:             dst->init(UndefinedValue());
101075:     }
101075: 
101075:     data->deletedBits = reinterpret_cast<size_t *>(dstEnd);
 93646:     ClearAllBitArrayElements(data->deletedBits, numDeletedWords);
 93249: 
 93249:     JSObject *obj = JSObject::create(cx, FINALIZE_KIND, emptyArgumentsShape, type, NULL);
 93249:     if (!obj)
 93249:         return NULL;
 93249: 
101075:     obj->initFixedSlot(INITIAL_LENGTH_SLOT, Int32Value(numActuals << PACKED_BITS_COUNT));
101075:     obj->initFixedSlot(DATA_SLOT, PrivateValue(data));
101075: 
101075:     /*
101075:      * If it exists and the arguments object aliases formals, the call object
101075:      * is the canonical location for formals.
101075:      */
101075:     JSScript *script = fp->script();
101075:     if (fp->fun()->isHeavyweight() && script->argsObjAliasesFormals()) {
101075:         obj->initFixedSlot(MAYBE_CALL_SLOT, ObjectValue(fp->callObj()));
101075: 
101075:         /* Flag each slot that canonically lives in the callObj. */
101075:         if (script->bindingsAccessedDynamically) {
101075:             for (unsigned i = 0; i < numFormals; ++i)
101075:                 data->args[i] = MagicValue(JS_FORWARD_TO_CALL_OBJECT);
101075:         } else {
101075:             for (unsigned i = 0; i < script->numClosedArgs(); ++i)
101075:                 data->args[script->getClosedArg(i)] = MagicValue(JS_FORWARD_TO_CALL_OBJECT);
101075:         }
101075:     }
101075: 
100006:     ArgumentsObject &argsobj = obj->asArguments();
101075:     JS_ASSERT(argsobj.initialLength() == numActuals);
101075:     JS_ASSERT(!argsobj.hasOverriddenLength());
 93249:     return &argsobj;
 93249: }
 93249: 
 95100: ArgumentsObject *
101075: ArgumentsObject::createExpected(JSContext *cx, StackFrame *fp)
 93249: {
 93250:     JS_ASSERT(fp->script()->needsArgsObj());
101075:     ArgumentsObject *argsobj = create(cx, fp);
 93249:     if (!argsobj)
 93250:         return NULL;
 93249: 
 93250:     fp->initArgsObj(*argsobj);
 93249:     return argsobj;
 93249: }
 93249: 
 93250: ArgumentsObject *
 93250: ArgumentsObject::createUnexpected(JSContext *cx, StackFrame *fp)
 93249: {
101075:     return create(cx, fp);
 93249: }
 93249: 
 93249: static JSBool
 98960: args_delProperty(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
 93249: {
 93249:     ArgumentsObject &argsobj = obj->asArguments();
 93249:     if (JSID_IS_INT(id)) {
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
101075:         if (arg < argsobj.initialLength() && !argsobj.isElementDeleted(arg))
 93646:             argsobj.markElementDeleted(arg);
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
 93249:         argsobj.markLengthOverridden();
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom)) {
 93249:         argsobj.asNormalArguments().clearCallee();
 93249:     }
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: ArgGetter(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
 93249: {
 93249:     if (!obj->isNormalArguments())
 93249:         return true;
 93249: 
 93249:     NormalArgumentsObject &argsobj = obj->asNormalArguments();
 93249:     if (JSID_IS_INT(id)) {
 93249:         /*
 93249:          * arg can exceed the number of arguments if a script changed the
 93249:          * prototype to point to another Arguments object with a bigger argc.
 93249:          */
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
101075:         if (arg < argsobj.initialLength() && !argsobj.isElementDeleted(arg))
 93249:             *vp = argsobj.element(arg);
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
 93249:         if (!argsobj.hasOverriddenLength())
101075:             *vp = Int32Value(argsobj.initialLength());
 93249:     } else {
 93249:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
101075:         if (!argsobj.callee().isMagic(JS_OVERWRITTEN_CALLEE))
101075:             *vp = argsobj.callee();
 93249:     }
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: ArgSetter(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp)
 93249: {
 93249:     if (!obj->isNormalArguments())
 93249:         return true;
 93249: 
 93249:     NormalArgumentsObject &argsobj = obj->asNormalArguments();
101075:     JSScript *script = argsobj.containingScript();
 93249: 
 93249:     if (JSID_IS_INT(id)) {
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
101075:         if (arg < argsobj.initialLength() && !argsobj.isElementDeleted(arg)) {
101075:             argsobj.setElement(arg, *vp);
101457:             if (arg < script->function()->nargs) {
101457:                 if (!script->ensureHasTypes(cx))
101457:                     return false;
 93250:                 types::TypeScript::SetArgument(cx, script, arg, *vp);
101457:             }
 93249:             return true;
 93249:         }
 93249:     } else {
 93249:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom) ||
 93249:                   JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
 93249:     }
 93249: 
 93249:     /*
 93249:      * For simplicity we use delete/define to replace the property with one
 93249:      * backed by the default Object getter and setter. Note that we rely on
 93249:      * args_delProperty to clear the corresponding reserved slot so the GC can
 93249:      * collect its value. Note also that we must define the property instead
 93249:      * of setting it in case the user has changed the prototype to an object
 93249:      * that has a setter for this id.
 93249:      */
 99421:     RootedValue value(cx);
 98960:     return baseops::DeleteGeneric(cx, obj, id, value.address(), false) &&
 98960:            baseops::DefineProperty(cx, obj, id, vp, NULL, NULL, JSPROP_ENUMERATE);
 93249: }
 93249: 
 93249: static JSBool
 98960: args_resolve(JSContext *cx, HandleObject obj, HandleId id, unsigned flags,
 93249:              JSObject **objp)
 93249: {
 93249:     *objp = NULL;
 93249: 
 99421:     Rooted<NormalArgumentsObject*> argsobj(cx, &obj->asNormalArguments());
 93249: 
 93249:     unsigned attrs = JSPROP_SHARED | JSPROP_SHADOWABLE;
 93249:     if (JSID_IS_INT(id)) {
 93249:         uint32_t arg = uint32_t(JSID_TO_INT(id));
 95355:         if (arg >= argsobj->initialLength() || argsobj->isElementDeleted(arg))
 93249:             return true;
 93249: 
 93249:         attrs |= JSPROP_ENUMERATE;
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
 95355:         if (argsobj->hasOverriddenLength())
 93249:             return true;
 93249:     } else {
 93249:         if (!JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom))
 93249:             return true;
 93249: 
 95355:         if (argsobj->callee().isMagic(JS_OVERWRITTEN_CALLEE))
 93249:             return true;
 93249:     }
 93249: 
 93249:     Value undef = UndefinedValue();
 98960:     if (!baseops::DefineProperty(cx, argsobj, id, &undef, ArgGetter, ArgSetter, attrs))
 93249:         return JS_FALSE;
 93249: 
 95355:     *objp = argsobj;
 93249:     return true;
 93249: }
 93249: 
 93250: bool
 93250: NormalArgumentsObject::optimizedGetElem(JSContext *cx, StackFrame *fp, const Value &elem, Value *vp)
 93250: {
101075:     JS_ASSERT(!fp->script()->needsArgsObj());
 93250: 
 93645:     /* Fast path: no need to convert to id when elem is already an int in range. */
 93250:     if (elem.isInt32()) {
 93250:         int32_t i = elem.toInt32();
 93250:         if (i >= 0 && uint32_t(i) < fp->numActualArgs()) {
101075:             *vp = fp->unaliasedActual(i);
 93250:             return true;
 93250:         }
 93250:     }
 93250: 
 93645:     /* Slow path: create and canonicalize an id, then emulate args_resolve. */
 93645: 
 93250:     jsid id;
 93250:     if (!ValueToId(cx, elem, &id))
 93250:         return false;
 93645: 
 93645:     if (JSID_IS_INT(id)) {
 93645:         int32_t i = JSID_TO_INT(id);
 93645:         if (i >= 0 && uint32_t(i) < fp->numActualArgs()) {
101075:             *vp = fp->unaliasedActual(i);
 93645:             return true;
 93645:         }
 93645:     }
 93250: 
 97828:     if (id == NameToId(cx->runtime->atomState.lengthAtom)) {
 93250:         *vp = Int32Value(fp->numActualArgs());
 93250:         return true;
 93250:     }
 93250: 
 97828:     if (id == NameToId(cx->runtime->atomState.calleeAtom)) {
 93250:         *vp = ObjectValue(fp->callee());
 93250:         return true;
 93250:     }
 93250: 
 96793:     JSObject *proto = fp->global().getOrCreateObjectPrototype(cx);
 93250:     if (!proto)
 93250:         return false;
 93250: 
 99421:     return proto->getGeneric(cx, RootedId(cx, id), vp);
 93250: }
 93250: 
 93249: static JSBool
 98960: args_enumerate(JSContext *cx, HandleObject obj)
 93249: {
 99421:     Rooted<NormalArgumentsObject*> argsobj(cx, &obj->asNormalArguments());
 99421:     RootedId id(cx);
 93249: 
 93249:     /*
 93249:      * Trigger reflection in args_resolve using a series of js_LookupProperty
 93249:      * calls.
 93249:      */
 97353:     int argc = int(argsobj->initialLength());
 93249:     for (int i = -2; i != argc; i++) {
 98960:         id = (i == -2)
 97828:              ? NameToId(cx->runtime->atomState.lengthAtom)
 93249:              : (i == -1)
 97828:              ? NameToId(cx->runtime->atomState.calleeAtom)
 93249:              : INT_TO_JSID(i);
 93249: 
 93249:         JSObject *pobj;
 93249:         JSProperty *prop;
 98960:         if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:             return false;
 93249:     }
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: StrictArgGetter(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
 93249: {
 93249:     if (!obj->isStrictArguments())
 93249:         return true;
 93249: 
 93249:     StrictArgumentsObject &argsobj = obj->asStrictArguments();
 93249: 
 93249:     if (JSID_IS_INT(id)) {
 93249:         /*
 93249:          * arg can exceed the number of arguments if a script changed the
 93249:          * prototype to point to another Arguments object with a bigger argc.
 93249:          */
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
 93646:         if (arg < argsobj.initialLength() && !argsobj.isElementDeleted(arg))
 93646:             *vp = argsobj.element(arg);
 93249:     } else {
 93249:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
 93249:         if (!argsobj.hasOverriddenLength())
 93249:             vp->setInt32(argsobj.initialLength());
 93249:     }
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: StrictArgSetter(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp)
 93249: {
 93249:     if (!obj->isStrictArguments())
 93249:         return true;
 93249: 
 99421:     Rooted<StrictArgumentsObject*> argsobj(cx, &obj->asStrictArguments());
 93249: 
 93249:     if (JSID_IS_INT(id)) {
 93249:         unsigned arg = unsigned(JSID_TO_INT(id));
 95355:         if (arg < argsobj->initialLength()) {
 95355:             argsobj->setElement(arg, *vp);
 93249:             return true;
 93249:         }
 93249:     } else {
 93249:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
 93249:     }
 93249: 
 93249:     /*
 93249:      * For simplicity we use delete/set to replace the property with one
 93249:      * backed by the default Object getter and setter. Note that we rely on
 93249:      * args_delProperty to clear the corresponding reserved slot so the GC can
 93249:      * collect its value.
 93249:      */
 99421:     RootedValue value(cx);
 98960:     return baseops::DeleteGeneric(cx, argsobj, id, value.address(), strict) &&
 98960:            baseops::SetPropertyHelper(cx, argsobj, id, 0, vp, strict);
 93249: }
 93249: 
 93249: static JSBool
 98960: strictargs_resolve(JSContext *cx, HandleObject obj, HandleId id, unsigned flags, JSObject **objp)
 93249: {
 93249:     *objp = NULL;
 93249: 
 99421:     Rooted<StrictArgumentsObject*> argsobj(cx, &obj->asStrictArguments());
 93249: 
 93249:     unsigned attrs = JSPROP_SHARED | JSPROP_SHADOWABLE;
 93249:     PropertyOp getter = StrictArgGetter;
 93249:     StrictPropertyOp setter = StrictArgSetter;
 93249: 
 93249:     if (JSID_IS_INT(id)) {
 93249:         uint32_t arg = uint32_t(JSID_TO_INT(id));
 97353:         if (arg >= argsobj->initialLength() || argsobj->isElementDeleted(arg))
 93249:             return true;
 93249: 
 93249:         attrs |= JSPROP_ENUMERATE;
 93249:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
 97353:         if (argsobj->hasOverriddenLength())
 93249:             return true;
 93249:     } else {
 93249:         if (!JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom) &&
 93249:             !JSID_IS_ATOM(id, cx->runtime->atomState.callerAtom)) {
 93249:             return true;
 93249:         }
 93249: 
 93249:         attrs = JSPROP_PERMANENT | JSPROP_GETTER | JSPROP_SETTER | JSPROP_SHARED;
 97353:         getter = CastAsPropertyOp(argsobj->global().getThrowTypeError());
 97353:         setter = CastAsStrictPropertyOp(argsobj->global().getThrowTypeError());
 93249:     }
 93249: 
 93249:     Value undef = UndefinedValue();
 98960:     if (!baseops::DefineProperty(cx, argsobj, id, &undef, getter, setter, attrs))
 93249:         return false;
 93249: 
 97353:     *objp = argsobj;
 93249:     return true;
 93249: }
 93249: 
 93249: static JSBool
 98960: strictargs_enumerate(JSContext *cx, HandleObject obj)
 93249: {
 99421:     Rooted<StrictArgumentsObject*> argsobj(cx, &obj->asStrictArguments());
 93249: 
 93249:     /*
 93249:      * Trigger reflection in strictargs_resolve using a series of
 93249:      * js_LookupProperty calls.
 93249:      */
 93249:     JSObject *pobj;
 93249:     JSProperty *prop;
 99421:     RootedId id(cx);
 93249: 
 93249:     // length
 98960:     id = NameToId(cx->runtime->atomState.lengthAtom);
 98960:     if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:         return false;
 93249: 
 93249:     // callee
 98960:     id = NameToId(cx->runtime->atomState.calleeAtom);
 98960:     if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:         return false;
 93249: 
 93249:     // caller
 98960:     id = NameToId(cx->runtime->atomState.callerAtom);
 98960:     if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:         return false;
 93249: 
 93249:     for (uint32_t i = 0, argc = argsobj->initialLength(); i < argc; i++) {
 98960:         id = INT_TO_JSID(i);
 98960:         if (!baseops::LookupProperty(cx, argsobj, id, &pobj, &prop))
 93249:             return false;
 93249:     }
 93249: 
 93249:     return true;
 93249: }
 93249: 
101075: void
101075: ArgumentsObject::finalize(FreeOp *fop, JSObject *obj)
 93249: {
 94738:     fop->free_(reinterpret_cast<void *>(obj->asArguments().data()));
 93249: }
 93249: 
101075: void
101075: ArgumentsObject::trace(JSTracer *trc, JSObject *obj)
 93249: {
 93249:     ArgumentsObject &argsobj = obj->asArguments();
 93249:     ArgumentsData *data = argsobj.data();
 93249:     MarkValue(trc, &data->callee, js_callee_str);
101075:     MarkValueRange(trc, data->numArgs, data->args, js_arguments_str);
101075:     MarkScriptUnbarriered(trc, &data->script, "script");
 93249: }
 93249: 
 93249: /*
 93249:  * The classes below collaborate to lazily reflect and synchronize actual
 93249:  * argument values, argument count, and callee function object stored in a
 93249:  * StackFrame with their corresponding property values in the frame's
 93249:  * arguments object.
 93249:  */
 93249: Class js::NormalArgumentsObjectClass = {
 93249:     "Arguments",
 93249:     JSCLASS_NEW_RESOLVE | JSCLASS_IMPLEMENTS_BARRIERS |
 93249:     JSCLASS_HAS_RESERVED_SLOTS(NormalArgumentsObject::RESERVED_SLOTS) |
 93249:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object) |
 93249:     JSCLASS_FOR_OF_ITERATION,
 93249:     JS_PropertyStub,         /* addProperty */
 93249:     args_delProperty,
 93249:     JS_PropertyStub,         /* getProperty */
 93249:     JS_StrictPropertyStub,   /* setProperty */
 93249:     args_enumerate,
 93249:     reinterpret_cast<JSResolveOp>(args_resolve),
 93249:     JS_ConvertStub,
101075:     ArgumentsObject::finalize,
 93249:     NULL,                    /* checkAccess */
 93249:     NULL,                    /* call        */
 93249:     NULL,                    /* construct   */
 93249:     NULL,                    /* hasInstance */
101075:     ArgumentsObject::trace,
 93249:     {
 93249:         NULL,       /* equality    */
 93249:         NULL,       /* outerObject */
 93249:         NULL,       /* innerObject */
 93249:         JS_ElementIteratorStub,
 93249:         NULL,       /* unused      */
 93249:         false,      /* isWrappedNative */
 93249:     }
 93249: };
 93249: 
 93249: /*
 93249:  * Strict mode arguments is significantly less magical than non-strict mode
 93249:  * arguments, so it is represented by a different class while sharing some
 93249:  * functionality.
 93249:  */
 93249: Class js::StrictArgumentsObjectClass = {
 93249:     "Arguments",
 93249:     JSCLASS_NEW_RESOLVE | JSCLASS_IMPLEMENTS_BARRIERS |
 93249:     JSCLASS_HAS_RESERVED_SLOTS(StrictArgumentsObject::RESERVED_SLOTS) |
 93249:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object) |
 93249:     JSCLASS_FOR_OF_ITERATION,
 93249:     JS_PropertyStub,         /* addProperty */
 93249:     args_delProperty,
 93249:     JS_PropertyStub,         /* getProperty */
 93249:     JS_StrictPropertyStub,   /* setProperty */
 93249:     strictargs_enumerate,
 93249:     reinterpret_cast<JSResolveOp>(strictargs_resolve),
 93249:     JS_ConvertStub,
101075:     ArgumentsObject::finalize,
 93249:     NULL,                    /* checkAccess */
 93249:     NULL,                    /* call        */
 93249:     NULL,                    /* construct   */
 93249:     NULL,                    /* hasInstance */
101075:     ArgumentsObject::trace,
 93249:     {
 93249:         NULL,       /* equality    */
 93249:         NULL,       /* outerObject */
 93249:         NULL,       /* innerObject */
 93249:         JS_ElementIteratorStub,
 93249:         NULL,       /* unused      */
 93249:         false,      /* isWrappedNative */
 93249:     }
 93249: };
