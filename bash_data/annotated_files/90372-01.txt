72025: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
72025:  *
72025:  * ***** BEGIN LICENSE BLOCK *****
72025:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
72025:  *
72025:  * The contents of this file are subject to the Mozilla Public License Version
72025:  * 1.1 (the "License"); you may not use this file except in compliance with
72025:  * the License. You may obtain a copy of the License at
72025:  * http://www.mozilla.org/MPL/
72025:  *
72025:  * Software distributed under the License is distributed on an "AS IS" basis,
72025:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
72025:  * for the specific language governing rights and limitations under the
72025:  * License.
72025:  *
72025:  * The Original Code is mozilla.org code.
72025:  *
72025:  * The Initial Developer of the Original Code is
72025:  *   Kyle Huey <me@kylehuey.com>
72025:  * Portions created by the Initial Developer are Copyright (C) 2010
72025:  * the Initial Developer. All Rights Reserved.
72025:  *
72025:  * Contributor(s):
72025:  *
72025:  * Alternatively, the contents of this file may be used under the terms of
72025:  * either the GNU General Public License Version 2 or later (the "GPL"), or
72025:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
72025:  * in which case the provisions of the GPL or the LGPL are applicable instead
72025:  * of those above. If you wish to allow use of your version of this file only
72025:  * under the terms of either the GPL or the LGPL, and not to allow others to
72025:  * use your version of this file under the terms of the MPL, indicate your
72025:  * decision by deleting the provisions above and replace them with the notice
72025:  * and other provisions required by the GPL or the LGPL. If you do not delete
72025:  * the provisions above, a recipient may use your version of this file under
72025:  * the terms of any one of the MPL, the GPL or the LGPL.
72025:  *
72025:  * ***** END LICENSE BLOCK ***** */
72025: 
72025: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_LONGHORN
72025: 
72025: #include <windows.h>
72025: #include <audiopolicy.h>
73784: #include <mmdeviceapi.h>
72025: 
72025: #include "nsIStringBundle.h"
72025: #include "nsIUUIDGenerator.h"
72025: #include "nsIXULAppInfo.h"
72025: 
72025: //#include "AudioSession.h"
72025: #include "nsCOMPtr.h"
72025: #include "nsAutoPtr.h"
72025: #include "nsServiceManagerUtils.h"
72025: #include "nsString.h"
86334: #include "nsThreadUtils.h"
73784: #include "nsXULAppAPI.h"
72025: 
72025: #include <objbase.h>
72025: 
72025: namespace mozilla {
72025: namespace widget {
72025: 
72025: /* 
72025:  * To take advantage of what Vista+ have to offer with respect to audio,
72025:  * we need to maintain an audio session.  This class wraps IAudioSessionControl
72025:  * and implements IAudioSessionEvents (for callbacks from Windows)
72025:  */
72025: class AudioSession: public IAudioSessionEvents {
72025: private:
72025:   AudioSession();
72025:   ~AudioSession();
72025: public:
72025:   static AudioSession* GetSingleton();
72025: 
72025:   // COM IUnknown
72025:   STDMETHODIMP_(ULONG) AddRef();
72025:   STDMETHODIMP QueryInterface(REFIID, void**);
72025:   STDMETHODIMP_(ULONG) Release();
72025: 
72025:   // IAudioSessionEvents
72025:   STDMETHODIMP OnChannelVolumeChanged(DWORD aChannelCount,
72025:                                       float aChannelVolumeArray[],
72025:                                       DWORD aChangedChannel,
72025:                                       LPCGUID aContext);
72025:   STDMETHODIMP OnDisplayNameChanged(LPCWSTR aDisplayName, LPCGUID aContext);
72025:   STDMETHODIMP OnGroupingParamChanged(LPCGUID aGroupingParam, LPCGUID aContext);
72025:   STDMETHODIMP OnIconPathChanged(LPCWSTR aIconPath, LPCGUID aContext);
72025:   STDMETHODIMP OnSessionDisconnected(AudioSessionDisconnectReason aReason);
86334: private:
86334:   nsresult OnSessionDisconnectedInternal();
86334: public:
72025:   STDMETHODIMP OnSimpleVolumeChanged(float aVolume,
72025:                                      BOOL aMute,
72025:                                      LPCGUID aContext);
72025:   STDMETHODIMP OnStateChanged(AudioSessionState aState);
72025: 
72025:   nsresult Start();
72025:   nsresult Stop();
72369:   void StopInternal();
72025: 
72369:   nsresult GetSessionData(nsID& aID,
72369:                           nsString& aSessionName,
72369:                           nsString& aIconPath);
72369: 
72369:   nsresult SetSessionData(const nsID& aID,
72369:                           const nsString& aSessionName,
72369:                           const nsString& aIconPath);
72369: 
72369:   enum SessionState {
72369:     UNINITIALIZED, // Has not been initialized yet
72369:     STARTED, // Started
72369:     CLONED, // SetSessionInfoCalled, Start not called
72369:     FAILED, // The autdio session failed to start
90372:     STOPPED, // Stop called
90372:     AUDIO_SESSION_DISCONNECTED // Audio session disconnected
72369:   };
72025: protected:
72025:   nsRefPtr<IAudioSessionControl> mAudioSessionControl;
72025:   nsString mDisplayName;
72025:   nsString mIconPath;
72025:   nsID mSessionGroupingParameter;
72369:   SessionState mState;
72025: 
72025:   nsAutoRefCnt mRefCnt;
72025:   NS_DECL_OWNINGTHREAD
72025: 
72025:   static AudioSession* sService;
72025: };
72025: 
72025: nsresult
72025: StartAudioSession()
72025: {
72025:   return AudioSession::GetSingleton()->Start();
72025: }
72025: 
72025: nsresult
72025: StopAudioSession()
72025: {
72025:   return AudioSession::GetSingleton()->Stop();
72025: }
72025: 
72369: nsresult
72369: GetAudioSessionData(nsID& aID,
72369:                     nsString& aSessionName,
72369:                     nsString& aIconPath)
72369: {
72369:   return AudioSession::GetSingleton()->GetSessionData(aID,
72369:                                                       aSessionName,
72369:                                                       aIconPath);
72369: }
72369: 
72369: nsresult
72369: RecvAudioSessionData(const nsID& aID,
72369:                      const nsString& aSessionName,
72369:                      const nsString& aIconPath)
72369: {
72369:   return AudioSession::GetSingleton()->SetSessionData(aID,
72369:                                                       aSessionName,
72369:                                                       aIconPath);
72369: }
72369: 
72025: AudioSession* AudioSession::sService = NULL;
72025: 
72025: AudioSession::AudioSession()
72025: {
72369:   mState = UNINITIALIZED;
72025: }
72025: 
72025: AudioSession::~AudioSession()
72025: {
72025: 
72025: }
72025: 
72025: AudioSession*
72025: AudioSession::GetSingleton()
72025: {
72025:   if (!(AudioSession::sService)) {
72025:     nsRefPtr<AudioSession> service = new AudioSession();
72025:     service.forget(&AudioSession::sService);
72025:   }
72025: 
72025:   // We don't refcount AudioSession on the Gecko side, we hold one single ref
72025:   // as long as the appshell is running.
72025:   return AudioSession::sService;
72025: }
72025: 
72025: // It appears Windows will use us on a background thread ...
72025: NS_IMPL_THREADSAFE_ADDREF(AudioSession)
72025: NS_IMPL_THREADSAFE_RELEASE(AudioSession)
72025: 
72025: STDMETHODIMP
72025: AudioSession::QueryInterface(REFIID iid, void **ppv)
72025: {
72025:   const IID IID_IAudioSessionEvents = __uuidof(IAudioSessionEvents);
72025:   if ((IID_IUnknown == iid) ||
72025:       (IID_IAudioSessionEvents == iid)) {
72025:     *ppv = static_cast<IAudioSessionEvents*>(this);
72025:     AddRef();
72025:     return S_OK;
72025:   }
72025: 
72025:   return E_NOINTERFACE;
72025: }
72025: 
72025: // Once we are started Windows will hold a reference to us through our
72025: // IAudioSessionEvents interface that will keep us alive until the appshell
72025: // calls Stop.
72025: nsresult
72025: AudioSession::Start()
72025: {
90372:   NS_ABORT_IF_FALSE(mState == UNINITIALIZED || 
90372:                     mState == CLONED ||
90372:                     mState == AUDIO_SESSION_DISCONNECTED,
72369:                     "State invariants violated");
72369: 
72025:   const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
72025:   const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
72025:   const IID IID_IAudioSessionManager = __uuidof(IAudioSessionManager);
72025: 
72025:   HRESULT hr;
72025: 
72025:   if (FAILED(::CoInitialize(NULL)))
72025:     return NS_ERROR_FAILURE;
72025: 
72369:   if (mState == UNINITIALIZED) {
72369:     mState = FAILED;
72369: 
72369:     // XXXkhuey implement this for content processes
72369:     if (XRE_GetProcessType() == GeckoProcessType_Content)
72369:       return NS_ERROR_FAILURE;
72369: 
72369:     NS_ABORT_IF_FALSE(XRE_GetProcessType() == GeckoProcessType_Default,
72369:                       "Should only get here in a chrome process!");
72369: 
72025:     nsCOMPtr<nsIStringBundleService> bundleService = 
72025:       do_GetService(NS_STRINGBUNDLE_CONTRACTID);
72025:     NS_ENSURE_TRUE(bundleService, NS_ERROR_FAILURE);
72025: 
72025:     nsCOMPtr<nsIStringBundle> bundle;
72025:     bundleService->CreateBundle("chrome://branding/locale/brand.properties",
72025:                                 getter_AddRefs(bundle));
72025:     NS_ENSURE_TRUE(bundle, NS_ERROR_FAILURE);
72025: 
72025:     bundle->GetStringFromName(NS_LITERAL_STRING("brandFullName").get(),
72025:                               getter_Copies(mDisplayName));
72025: 
72025:     PRUnichar *buffer;
72025:     mIconPath.GetMutableData(&buffer, MAX_PATH);
72025: 
72025:     // XXXkhuey we should provide a way for a xulrunner app to specify an icon
72025:     // that's not in the product binary.
72025:     ::GetModuleFileNameW(NULL, buffer, MAX_PATH);
72025: 
72025:     nsCOMPtr<nsIUUIDGenerator> uuidgen =
72025:       do_GetService("@mozilla.org/uuid-generator;1");
72025:     NS_ASSERTION(uuidgen, "No UUID-Generator?!?");
72025: 
72025:     uuidgen->GenerateUUIDInPlace(&mSessionGroupingParameter);
72369:   }
72369: 
72369:   mState = FAILED;
72369: 
72369:   NS_ABORT_IF_FALSE(!mDisplayName.IsEmpty() || !mIconPath.IsEmpty(),
72369:                     "Should never happen ...");
72025: 
72025:   nsRefPtr<IMMDeviceEnumerator> enumerator;
72025:   hr = ::CoCreateInstance(CLSID_MMDeviceEnumerator,
72025:                           NULL,
72025:                           CLSCTX_ALL,
72025:                           IID_IMMDeviceEnumerator,
72025:                           getter_AddRefs(enumerator));
72025:   if (FAILED(hr))
72025:     return NS_ERROR_NOT_AVAILABLE;
72025: 
72025:   nsRefPtr<IMMDevice> device;
72025:   hr = enumerator->GetDefaultAudioEndpoint(EDataFlow::eRender,
72025:                                            ERole::eMultimedia,
72025:                                            getter_AddRefs(device));
72025:   if (FAILED(hr)) {
72025:     if (hr == E_NOTFOUND)
72025:       return NS_ERROR_NOT_AVAILABLE;
72025:     return NS_ERROR_FAILURE;
72025:   }
72025: 
72025:   nsRefPtr<IAudioSessionManager> manager;
72025:   hr = device->Activate(IID_IAudioSessionManager,
72025:                         CLSCTX_ALL,
72025:                         NULL,
72025:                         getter_AddRefs(manager));
72025:   if (FAILED(hr))
72025:     return NS_ERROR_FAILURE;
72025: 
72025:   hr = manager->GetAudioSessionControl(NULL,
72025:                                        FALSE,
72025:                                        getter_AddRefs(mAudioSessionControl));
72025:   if (FAILED(hr))
72025:     return NS_ERROR_FAILURE;
72025: 
72025:   hr = mAudioSessionControl->SetGroupingParam((LPCGUID)&mSessionGroupingParameter,
72025:                                               NULL);
72025:   if (FAILED(hr)) {
72025:     StopInternal();
72025:     return NS_ERROR_FAILURE;
72025:   }
72025: 
72025:   hr = mAudioSessionControl->SetDisplayName(mDisplayName.get(), NULL);
72025:   if (FAILED(hr)) {
72025:     StopInternal();
72025:     return NS_ERROR_FAILURE;
72025:   }
72025: 
72025:   hr = mAudioSessionControl->SetIconPath(mIconPath.get(), NULL);
72025:   if (FAILED(hr)) {
72025:     StopInternal();
72025:     return NS_ERROR_FAILURE;
72025:   }
72025: 
72025:   hr = mAudioSessionControl->RegisterAudioSessionNotification(this);
72025:   if (FAILED(hr)) {
72025:     StopInternal();
72025:     return NS_ERROR_FAILURE;
72025:   }
72025: 
72369:   mState = STARTED;
72369: 
72025:   return NS_OK;
72025: }
72025: 
72025: void
72025: AudioSession::StopInternal()
72025: {
72369:   static const nsID blankId = {0, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0} };
72369: 
72025:   if (mAudioSessionControl) {
72025:     mAudioSessionControl->SetGroupingParam((LPCGUID)&blankId, NULL);
72025:     mAudioSessionControl->UnregisterAudioSessionNotification(this);
72025:     mAudioSessionControl = nsnull;
72025:   }
72025: }
72025: 
72025: nsresult
72025: AudioSession::Stop()
72025: {
72369:   NS_ABORT_IF_FALSE(mState == STARTED ||
72369:                     mState == UNINITIALIZED || // XXXremove this
72369:                     mState == FAILED,
72369:                     "State invariants violated");
72369:   mState = STOPPED;
72369: 
72025:   nsRefPtr<AudioSession> kungFuDeathGrip;
72025:   kungFuDeathGrip.swap(sService);
72025: 
72369:   if (XRE_GetProcessType() != GeckoProcessType_Content)
72025:     StopInternal();
72025: 
72025:   // At this point kungFuDeathGrip should be the only reference to AudioSession
72025: 
72025:   ::CoUninitialize();
72025: 
72025:   return NS_OK;
72025: }
72025: 
72369: void CopynsID(nsID& lhs, const nsID& rhs)
72369: {
72369:   lhs.m0 = rhs.m0;
72369:   lhs.m1 = rhs.m1;
72369:   lhs.m2 = rhs.m2;
72369:   for (int i = 0; i < 8; i++ ) {
72369:     lhs.m3[i] = rhs.m3[i];
72369:   }
72369: }
72369: 
72369: nsresult
72369: AudioSession::GetSessionData(nsID& aID,
72369:                              nsString& aSessionName,
72369:                              nsString& aIconPath)
72369: {
72369:   NS_ABORT_IF_FALSE(mState == FAILED ||
72369:                     mState == STARTED ||
72369:                     mState == CLONED,
72369:                     "State invariants violated");
72369: 
72369:   CopynsID(aID, mSessionGroupingParameter);
72369:   aSessionName = mDisplayName;
72369:   aIconPath = mIconPath;
72369: 
72369:   if (mState == FAILED)
72369:     return NS_ERROR_FAILURE;
72369: 
72369:   return NS_OK;
72369: }
72369: 
72369: nsresult
72369: AudioSession::SetSessionData(const nsID& aID,
72369:                              const nsString& aSessionName,
72369:                              const nsString& aIconPath)
72369: {
72369:   NS_ABORT_IF_FALSE(mState == UNINITIALIZED,
72369:                     "State invariants violated");
72369:   NS_ABORT_IF_FALSE(XRE_GetProcessType() != GeckoProcessType_Default,
72369:                     "Should never get here in a chrome process!");
72369:   mState = CLONED;
72369: 
72369:   CopynsID(mSessionGroupingParameter, aID);
72369:   mDisplayName = aSessionName;
72369:   mIconPath = aIconPath;
72369:   return NS_OK;
72369: }
72369: 
72025: STDMETHODIMP
72025: AudioSession::OnChannelVolumeChanged(DWORD aChannelCount,
72025:                                      float aChannelVolumeArray[],
72025:                                      DWORD aChangedChannel,
72025:                                      LPCGUID aContext)
72025: {
72025:   return S_OK; // NOOP
72025: }
72025: 
72025: STDMETHODIMP
72025: AudioSession::OnDisplayNameChanged(LPCWSTR aDisplayName,
72025:                                    LPCGUID aContext)
72025: {
72025:   return S_OK; // NOOP
72025: }
72025: 
72025: STDMETHODIMP
72025: AudioSession::OnGroupingParamChanged(LPCGUID aGroupingParam,
72025:                                      LPCGUID aContext)
72025: {
72025:   return S_OK; // NOOP
72025: }
72025: 
72025: STDMETHODIMP
72025: AudioSession::OnIconPathChanged(LPCWSTR aIconPath,
72025:                                 LPCGUID aContext)
72025: {
72025:   return S_OK; // NOOP
72025: }
72025: 
72025: STDMETHODIMP
72025: AudioSession::OnSessionDisconnected(AudioSessionDisconnectReason aReason)
72025: {
86334:   // Run our code asynchronously.  Per MSDN we can't do anything interesting
86334:   // in this callback.
86334:   nsCOMPtr<nsIRunnable> runnable =
86334:     NS_NewRunnableMethod(this, &AudioSession::OnSessionDisconnectedInternal);
86334:   NS_DispatchToMainThread(runnable);
86334:   return S_OK;
86334: }
86334: 
86334: nsresult
86334: AudioSession::OnSessionDisconnectedInternal()
86334: {
72025:   if (!mAudioSessionControl)
86334:     return NS_OK;
72025: 
72025:   mAudioSessionControl->UnregisterAudioSessionNotification(this);
72025:   mAudioSessionControl = nsnull;
86334: 
90372:   mState = AUDIO_SESSION_DISCONNECTED;
90372:   CoUninitialize();
86334:   Start(); // If it fails there's not much we can do.
86334:   return NS_OK;
72025: }
72025: 
72025: STDMETHODIMP
72025: AudioSession::OnSimpleVolumeChanged(float aVolume,
72025:                                     BOOL aMute,
72025:                                     LPCGUID aContext)
72025: {
72025:   return S_OK; // NOOP
72025: }
72025: 
72025: STDMETHODIMP
72025: AudioSession::OnStateChanged(AudioSessionState aState)
72025: {
72025:   return S_OK; // NOOP
72025: }
72025: 
72025: } // namespace widget
72025: } // namespace mozilla
72025: 
72025: #endif // MOZ_NTDDI_LONGHORN
