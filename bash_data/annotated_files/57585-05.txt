    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * PR assertion checker.
    1:  */
    1: 
    1: #ifndef jsutil_h___
    1: #define jsutil_h___
    1: 
41099: #include "jstypes.h"
30851: #include <stdlib.h>
30851: 
    1: JS_BEGIN_EXTERN_C
    1: 
25934: /*
25934:  * JS_Assert is present even in release builds, for the benefit of applications
25934:  * that build DEBUG and link against a non-DEBUG SpiderMonkey library.
25934:  */
    1: extern JS_PUBLIC_API(void)
    1: JS_Assert(const char *s, const char *file, JSIntn ln);
    1: 
57585: #define JS_CRASH_UNLESS(__cond)                                                 \
57585:     JS_BEGIN_MACRO                                                              \
57585:         if (!(__cond)) {                                                        \
57585:             *(int *)(uintptr_t)0xccadbeef = 0;                                  \
57585:             ((void(*)())0)(); /* More reliable, but doesn't say CCADBEEF */     \
57585:         }                                                                       \
57585:     JS_END_MACRO
57585: 
25934: #ifdef DEBUG
25934: 
10217: #define JS_ASSERT(expr)                                                       \
10217:     ((expr) ? (void)0 : JS_Assert(#expr, __FILE__, __LINE__))
    1: 
10217: #define JS_ASSERT_IF(cond, expr)                                              \
10217:     ((!(cond) || (expr)) ? (void)0 : JS_Assert(#expr, __FILE__, __LINE__))
10217: 
10217: #define JS_NOT_REACHED(reason)                                                \
10217:     JS_Assert(reason, __FILE__, __LINE__)
    1: 
40801: #define JS_ALWAYS_TRUE(expr) JS_ASSERT(expr)
40801: 
55464: # ifdef JS_THREADSAFE
55464: # define JS_THREADSAFE_ASSERT(expr) JS_ASSERT(expr) 
55464: # else
55464: # define JS_THREADSAFE_ASSERT(expr) ((void) 0)
55464: # endif
55464: 
    1: #else
    1: 
    1: #define JS_ASSERT(expr)         ((void) 0)
    1: #define JS_ASSERT_IF(cond,expr) ((void) 0)
10217: #define JS_NOT_REACHED(reason)
40801: #define JS_ALWAYS_TRUE(expr)    ((void) (expr))
55464: #define JS_THREADSAFE_ASSERT(expr) ((void) 0)
    1: 
    1: #endif /* defined(DEBUG) */
    1: 
    1: /*
25254:  * Compile-time assert. "cond" must be a constant expression.
 1824:  * The macro can be used only in places where an "extern" declaration is
 1824:  * allowed.
    1:  */
18563: 
55709: #ifdef __SUNPRO_CC
18563: /*
18563:  * Sun Studio C++ compiler has a bug
18563:  * "sizeof expression not accepted as size of array parameter"
55709:  * It happens when js_static_assert() function is declared inside functions.
18563:  * The bug number is 6688515. It is not public yet.
55709:  * Therefore, for Sun Studio, declare js_static_assert as an array instead.
18563:  */
55709: #define JS_STATIC_ASSERT(cond) extern char js_static_assert[(cond) ? 1 : -1]
18563: #else
25252: #ifdef __COUNTER__
25252:     #define JS_STATIC_ASSERT_GLUE1(x,y) x##y
25252:     #define JS_STATIC_ASSERT_GLUE(x,y) JS_STATIC_ASSERT_GLUE1(x,y)
25252:     #define JS_STATIC_ASSERT(cond)                                            \
25252:         typedef int JS_STATIC_ASSERT_GLUE(js_static_assert, __COUNTER__)[(cond) ? 1 : -1]
25252: #else
25254:     #define JS_STATIC_ASSERT(cond) extern void js_static_assert(int arg[(cond) ? 1 : -1])
25252: #endif
18563: #endif
    1: 
25901: #define JS_STATIC_ASSERT_IF(cond, expr) JS_STATIC_ASSERT(!(cond) || (expr))
25901: 
    1: /*
10217:  * Abort the process in a non-graceful manner. This will cause a core file,
10217:  * call to the debugger or other moral equivalent as well as causing the
10217:  * entire process to stop.
    1:  */
    1: extern JS_PUBLIC_API(void) JS_Abort(void);
    1: 
36418: #ifdef DEBUG
10217: # define JS_BASIC_STATS 1
10217: #endif
10217: 
36446: #ifdef DEBUG_brendan
36446: # define JS_SCOPE_DEPTH_METER 1
10217: #endif
10217: 
10217: #ifdef JS_BASIC_STATS
10217: 
10217: #include <stdio.h>
10217: 
10217: typedef struct JSBasicStats {
10217:     uint32      num;
10217:     uint32      max;
10217:     double      sum;
10217:     double      sqsum;
10217:     uint32      logscale;           /* logarithmic scale: 0 (linear), 2, 10 */
10217:     uint32      hist[11];
10217: } JSBasicStats;
10217: 
10217: #define JS_INIT_STATIC_BASIC_STATS  {0,0,0,0,0,{0,0,0,0,0,0,0,0,0,0,0}}
10217: #define JS_BASIC_STATS_INIT(bs)     memset((bs), 0, sizeof(JSBasicStats))
10217: 
10217: #define JS_BASIC_STATS_ACCUM(bs,val)                                          \
10217:     JS_BasicStatsAccum(bs, val)
10217: 
10217: #define JS_MeanAndStdDevBS(bs,sigma)                                          \
10217:     JS_MeanAndStdDev((bs)->num, (bs)->sum, (bs)->sqsum, sigma)
10217: 
10217: extern void
10217: JS_BasicStatsAccum(JSBasicStats *bs, uint32 val);
10217: 
10217: extern double
10217: JS_MeanAndStdDev(uint32 num, double sum, double sqsum, double *sigma);
10217: 
10217: extern void
10217: JS_DumpBasicStats(JSBasicStats *bs, const char *title, FILE *fp);
10217: 
10217: extern void
10217: JS_DumpHistogram(JSBasicStats *bs, FILE *fp);
10217: 
10217: #else
10217: 
10217: #define JS_BASIC_STATS_ACCUM(bs,val) /* nothing */
10217: 
10217: #endif /* JS_BASIC_STATS */
10217: 
10217: 
24876: #if defined(DEBUG_notme) && defined(XP_UNIX)
    1: 
    1: typedef struct JSCallsite JSCallsite;
    1: 
    1: struct JSCallsite {
    1:     uint32      pc;
    1:     char        *name;
    1:     const char  *library;
    1:     int         offset;
    1:     JSCallsite  *parent;
    1:     JSCallsite  *siblings;
    1:     JSCallsite  *kids;
    1:     void        *handy;
    1: };
    1: 
24876: extern JS_FRIEND_API(JSCallsite *)
24876: JS_Backtrace(int skip);
24876: 
24876: extern JS_FRIEND_API(void)
24876: JS_DumpBacktrace(JSCallsite *trace);
30851: #endif
    1: 
41099: #if defined JS_USE_CUSTOM_ALLOCATOR
41099: 
41099: #include "jscustomallocator.h"
41099: 
41099: #else
41099: 
30851: static JS_INLINE void* js_malloc(size_t bytes) {
30851:     return malloc(bytes);
30851: }
30851: 
30851: static JS_INLINE void* js_calloc(size_t bytes) {
30851:     return calloc(bytes, 1);
30851: }
30851: 
30851: static JS_INLINE void* js_realloc(void* p, size_t bytes) {
30851:     return realloc(p, bytes);
30851: }
30851: 
30851: static JS_INLINE void js_free(void* p) {
30851:     free(p);
30851: }
41099: #endif/* JS_USE_CUSTOM_ALLOCATOR */
    1: 
    1: JS_END_EXTERN_C
    1: 
33538: #ifdef __cplusplus
33538: 
33538: /**
33538:  * The following classes are designed to cause assertions to detect
33538:  * inadvertent use of guard objects as temporaries.  In other words,
33538:  * when we have a guard object whose only purpose is its constructor and
33538:  * destructor (and is never otherwise referenced), the intended use
33538:  * might be:
40378:  *     JSAutoTempValueRooter tvr(cx, 1, &val);
33538:  * but is is easy to accidentally write:
40378:  *     JSAutoTempValueRooter(cx, 1, &val);
33538:  * which compiles just fine, but runs the destructor well before the
33538:  * intended time.
33538:  *
33538:  * They work by adding (#ifdef DEBUG) an additional parameter to the
33538:  * guard object's constructor, with a default value, so that users of
33538:  * the guard object's API do not need to do anything.  The default value
33538:  * of this parameter is a temporary object.  C++ (ISO/IEC 14882:1998),
33538:  * section 12.2 [class.temporary], clauses 4 and 5 seem to assume a
33538:  * guarantee that temporaries are destroyed in the reverse of their
33538:  * construction order, but I actually can't find a statement that that
33538:  * is true in the general case (beyond the two specific cases mentioned
33538:  * there).  However, it seems to be true.
33538:  *
33538:  * These classes are intended to be used only via the macros immediately
33538:  * below them:
33538:  *   JS_DECL_USE_GUARD_OBJECT_NOTIFIER declares (ifdef DEBUG) a member
33538:  *     variable, and should be put where a declaration of a private
33538:  *     member variable would be placed.
33538:  *   JS_GUARD_OBJECT_NOTIFIER_PARAM should be placed at the end of the
33538:  *     parameters to each constructor of the guard object; it declares
33538:  *     (ifdef DEBUG) an additional parameter.
33538:  *   JS_GUARD_OBJECT_NOTIFIER_INIT is a statement that belongs in each
33538:  *     constructor.  It uses the parameter declared by
33538:  *     JS_GUARD_OBJECT_NOTIFIER_PARAM.
33538:  */
33538: #ifdef DEBUG
33538: class JSGuardObjectNotifier
33538: {
33538: private:
33538:     bool* mStatementDone;
33538: public:
33538:     JSGuardObjectNotifier() : mStatementDone(NULL) {}
33538: 
33538:     ~JSGuardObjectNotifier() {
33538:         *mStatementDone = true;
33538:     }
33538: 
52503:     void setStatementDone(bool *aStatementDone) {
33538:         mStatementDone = aStatementDone;
33538:     }
33538: };
33538: 
33538: class JSGuardObjectNotificationReceiver
33538: {
33538: private:
33538:     bool mStatementDone;
33538: public:
33538:     JSGuardObjectNotificationReceiver() : mStatementDone(false) {}
33538: 
33538:     ~JSGuardObjectNotificationReceiver() {
34320:         /*
34320:          * Assert that the guard object was not used as a temporary.
34320:          * (Note that this assert might also fire if Init is not called
34320:          * because the guard object's implementation is not using the
34320:          * above macros correctly.)
34320:          */
33538:         JS_ASSERT(mStatementDone);
33538:     }
33538: 
33538:     void Init(const JSGuardObjectNotifier &aNotifier) {
34320:         /*
34320:          * aNotifier is passed as a const reference so that we can pass a
34320:          * temporary, but we really intend it as non-const
34320:          */
33538:         const_cast<JSGuardObjectNotifier&>(aNotifier).
52503:             setStatementDone(&mStatementDone);
33538:     }
33538: };
33538: 
33538: #define JS_DECL_USE_GUARD_OBJECT_NOTIFIER \
33538:     JSGuardObjectNotificationReceiver _mCheckNotUsedAsTemporary;
33538: #define JS_GUARD_OBJECT_NOTIFIER_PARAM \
33538:     , const JSGuardObjectNotifier& _notifier = JSGuardObjectNotifier()
33538: #define JS_GUARD_OBJECT_NOTIFIER_INIT \
33538:     JS_BEGIN_MACRO _mCheckNotUsedAsTemporary.Init(_notifier); JS_END_MACRO
33538: 
33538: #else /* defined(DEBUG) */
33538: 
33538: #define JS_DECL_USE_GUARD_OBJECT_NOTIFIER
33538: #define JS_GUARD_OBJECT_NOTIFIER_PARAM
33538: #define JS_GUARD_OBJECT_NOTIFIER_INIT JS_BEGIN_MACRO JS_END_MACRO
33538: 
33538: #endif /* !defined(DEBUG) */
33538: 
50456: namespace js {
50456: 
50456: template <class T>
50456: JS_ALWAYS_INLINE static void
50456: PodZero(T *t)
50456: {
50456:     memset(t, 0, sizeof(T));
50456: }
50456: 
50456: template <class T>
50456: JS_ALWAYS_INLINE static void
50456: PodZero(T *t, size_t nelem)
50456: {
50456:     memset(t, 0, nelem * sizeof(T));
50456: }
50456: 
50456: /*
50456:  * Arrays implicitly convert to pointers to their first element, which is
50456:  * dangerous when combined with the above PodZero definitions. Adding an
50456:  * overload for arrays is ambiguous, so we need another identifier. The
50456:  * ambiguous overload is left to catch mistaken uses of PodZero; if you get a
50456:  * compile error involving PodZero and array types, use PodArrayZero instead.
50456:  */
50456: template <class T, size_t N> static void PodZero(T (&)[N]);          /* undefined */
50456: template <class T, size_t N> static void PodZero(T (&)[N], size_t);  /* undefined */
50456: 
50456: template <class T, size_t N>
50456: JS_ALWAYS_INLINE static void
50456: PodArrayZero(T (&t)[N])
50456: {
50456:     memset(t, 0, N * sizeof(T));
50456: }
50456: 
50456: } /* namespace js */
50456: 
33538: #endif /* defined(__cplusplus) */
33538: 
    1: #endif /* jsutil_h___ */
