    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Places code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brett Wilson <brettw@gmail.com> (original author)
12395:  *   Edward Lee <edward.lee@engineering.uiuc.edu>
20637:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
33704:  *   Marco Bonardo <mak77@bonardo.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsNavHistory_h_
    1: #define nsNavHistory_h_
    1: 
    1: #include "nsINavHistoryService.h"
16749: #include "nsPIPlacesDatabase.h"
25698: #include "nsPIPlacesHistoryListenersNotifier.h"
    1: #include "nsIBrowserHistory.h"
    1: #include "nsIGlobalHistory.h"
    1: #include "nsIGlobalHistory3.h"
 9621: #include "nsIDownloadHistory.h"
34766: 
    1: #include "nsIPrefService.h"
    1: #include "nsIObserverService.h"
34766: #include "nsICollation.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsITimer.h"
    1: #include "nsMaybeWeakPtr.h"
30050: #include "nsCategoryCache.h"
34766: #include "nsICharsetResolver.h"
34766: #include "nsNetCID.h"
35298: #include "nsToolkitCompsCID.h"
34766: 
34766: #include "nsINavBookmarksService.h"
34766: #include "nsIPrivateBrowsingService.h"
    1: 
    1: #include "nsNavHistoryExpire.h"
    1: #include "nsNavHistoryResult.h"
    1: #include "nsNavHistoryQuery.h"
    1: 
34766: #include "mozilla/storage.h"
20637: 
    1: // define to enable lazy link adding
    1: #define LAZY_ADD
    1: 
    1: #define QUERYUPDATE_TIME 0
    1: #define QUERYUPDATE_SIMPLE 1
    1: #define QUERYUPDATE_COMPLEX 2
    1: #define QUERYUPDATE_COMPLEX_WITH_BOOKMARKS 3
12328: #define QUERYUPDATE_HOST 4
    1: 
20637: // This magic number specified an uninitialized value for the
20637: // mInPrivateBrowsing member
20637: #define PRIVATEBROWSING_NOTINITED (PRBool(0xffffffff))
20637: 
32454: #define PLACES_INIT_COMPLETE_TOPIC "places-init-complete"
32454: #define PLACES_DB_LOCKED_TOPIC "places-database-locked"
32454: #define PLACES_AUTOCOMPLETE_FEEDBACK_UPDATED_TOPIC "places-autocomplete-feedback-updated"
32454: #define PLACES_VACUUM_STARTING_TOPIC "places-vacuum-starting"
21600: 
    1: class mozIAnnotationService;
    1: class nsNavHistory;
    1: class nsNavBookmarks;
    1: class QueryKeyValuePair;
11302: class nsIEffectiveTLDService;
11302: class nsIIDNService;
12328: class PlacesSQLQueryBuilder;
30902: class nsIAutoCompleteController;
    1: 
    1: // nsNavHistory
    1: 
25698: class nsNavHistory : public nsSupportsWeakReference
25698:                    , public nsINavHistoryService
25698:                    , public nsIObserver
25698:                    , public nsIBrowserHistory
25698:                    , public nsIGlobalHistory3
25698:                    , public nsIDownloadHistory
25698:                    , public nsICharsetResolver
16749:                    , public nsPIPlacesDatabase
25698:                    , public nsPIPlacesHistoryListenersNotifier
    1: {
12328:   friend class PlacesSQLQueryBuilder;
12328: 
    1: public:
    1:   nsNavHistory();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_DECL_NSINAVHISTORYSERVICE
    1:   NS_DECL_NSIGLOBALHISTORY2
    1:   NS_DECL_NSIGLOBALHISTORY3
 9621:   NS_DECL_NSIDOWNLOADHISTORY
    1:   NS_DECL_NSIBROWSERHISTORY
    1:   NS_DECL_NSIOBSERVER
16749:   NS_DECL_NSPIPLACESDATABASE
25698:   NS_DECL_NSPIPLACESHISTORYLISTENERSNOTIFIER
    1: 
11818: 
11818:   /**
11818:    * Obtains the nsNavHistory object.
11818:    */
11818:   static nsNavHistory *GetSingleton();
11818: 
11818:   /**
11818:    * Initializes the nsNavHistory object.  This should only be called once.
11818:    */
    1:   nsresult Init();
    1: 
    1:   /**
    1:    * Used by other components in the places directory such as the annotation
    1:    * service to get a reference to this history object. Returns a pointer to
    1:    * the service if it exists. Otherwise creates one. Returns NULL on error.
    1:    */
    1:   static nsNavHistory *GetHistoryService()
    1:   {
35298:     if (!gHistoryService) {
11818:       nsCOMPtr<nsINavHistoryService> serv =
35298:         do_GetService(NS_NAVHISTORYSERVICE_CONTRACTID);
11818:       NS_ENSURE_TRUE(serv, nsnull);
35298:       NS_ASSERTION(gHistoryService, "Should have static instance pointer now");
35298:     }
    1:     return gHistoryService;
    1:   }
    1: 
    1: #ifdef LAZY_ADD
    1:   /**
    1:    * Adds a lazy message for adding a favicon. Used by the favicon service so
    1:    * that favicons are handled lazily just like page adds.
    1:    */
    1:   nsresult AddLazyLoadFaviconMessage(nsIURI* aPage, nsIURI* aFavicon,
    1:                                      PRBool aForceReload);
    1: #endif
    1: 
    1:   /**
    1:    * Returns the database ID for the given URI, or 0 if not found and autoCreate
    1:    * is false.
    1:    */
    1:   nsresult GetUrlIdFor(nsIURI* aURI, PRInt64* aEntryID,
    1:                        PRBool aAutoCreate);
    1: 
13613:   nsresult CalculateFullVisitCount(PRInt64 aPlaceId, PRInt32 *aVisitCount);
10669: 
27692:   nsresult UpdateFrecency(PRInt64 aPlaceId, PRBool aIsBookmark);
27692:   nsresult UpdateFrecencyInternal(PRInt64 aPlaceId, PRInt32 aTyped,
27692:                                   PRInt32 aHidden, PRInt32 aOldFrecency,
27692:                                   PRBool aIsBookmark);
10669: 
27190:   /**
27190:    * Calculate frecencies for places that don't have a valid value yet
27190:    */
27190:   nsresult FixInvalidFrecencies();
27190: 
27190:   /**
27190:    * Set the frecencies of excluded places so they don't show up in queries
27190:    */
10669:   nsresult FixInvalidFrecenciesForExcludedPlaces();
10669: 
    1:   /**
    1:    * Returns a pointer to the storage connection used by history. This
    1:    * connection object is also used by the annotation service and bookmarks, so
    1:    * that things can be grouped into transactions across these components.
    1:    *
    1:    * NOT ADDREFed.
    1:    *
    1:    * This connection can only be used in the thread that created it the
    1:    * history service!
    1:    */
    1:   mozIStorageConnection* GetStorageConnection()
    1:   {
    1:     return mDBConn;
    1:   }
    1: 
    1:   /**
    1:    * These functions return non-owning references to the locale-specific
20875:    * objects for places components.
    1:    */
20877:   nsIStringBundle* GetBundle();
26467:   nsIStringBundle* GetDateFormatBundle();
20875:   nsICollation* GetCollation();
12328:   void GetStringFromName(const PRUnichar* aName, nsACString& aResult);
20877:   void GetAgeInDaysString(PRInt32 aInt, const PRUnichar *aName,
20877:                           nsACString& aResult);
26467:   void GetMonthName(PRInt32 aIndex, nsACString& aResult);
    1: 
    1:   // returns true if history has been disabled
20637:   PRBool IsHistoryDisabled() { return mExpireDaysMax == 0 || InPrivateBrowsingMode(); }
    1: 
    1:   // Constants for the columns returned by the above statement.
    1:   static const PRInt32 kGetInfoIndex_PageID;
    1:   static const PRInt32 kGetInfoIndex_URL;
    1:   static const PRInt32 kGetInfoIndex_Title;
    1:   static const PRInt32 kGetInfoIndex_RevHost;
    1:   static const PRInt32 kGetInfoIndex_VisitCount;
 1337:   static const PRInt32 kGetInfoIndex_ItemId;
 1604:   static const PRInt32 kGetInfoIndex_ItemDateAdded;
 1604:   static const PRInt32 kGetInfoIndex_ItemLastModified;
33458:   static const PRInt32 kGetInfoIndex_ItemTags;
33458:   static const PRInt32 kGetInfoIndex_ItemParentId;
    1: 
    1:   // select a history row by id
    1:   mozIStorageStatement *DBGetIdPageInfo() { return mDBGetIdPageInfo; }
    1: 
21343:   mozIStorageStatement *DBGetTags() { return mDBGetTags; }
21343:   PRInt64 GetTagsFolder();
21343: 
    1:   // Constants for the columns returned by the above statement
    1:   // (in addition to the ones above).
    1:   static const PRInt32 kGetInfoIndex_VisitDate;
    1:   static const PRInt32 kGetInfoIndex_FaviconURL;
    1: 
    1:   // used in execute queries to get session ID info (only for visits)
    1:   static const PRInt32 kGetInfoIndex_SessionId;
    1: 
    1:   // this actually executes a query and gives you results, it is used by
    1:   // nsNavHistoryQueryResultNode
 2597:   nsresult GetQueryResults(nsNavHistoryQueryResultNode *aResultNode,
 2597:                            const nsCOMArray<nsNavHistoryQuery>& aQueries,
    1:                            nsNavHistoryQueryOptions *aOptions,
    1:                            nsCOMArray<nsNavHistoryResultNode>* aResults);
    1: 
    1:   // Take a row of kGetInfoIndex_* columns and construct a ResultNode.
    1:   // The row must contain the full set of columns.
    1:   nsresult RowToResult(mozIStorageValueArray* aRow,
    1:                        nsNavHistoryQueryOptions* aOptions,
    1:                        nsNavHistoryResultNode** aResult);
 5542:   nsresult QueryRowToResult(PRInt64 aItemId, const nsACString& aURI,
 5542:                             const nsACString& aTitle,
    1:                             PRUint32 aAccessCount, PRTime aTime,
    1:                             const nsACString& aFavicon,
    1:                             nsNavHistoryResultNode** aNode);
    1: 
    1:   nsresult VisitIdToResultNode(PRInt64 visitId,
    1:                                nsNavHistoryQueryOptions* aOptions,
    1:                                nsNavHistoryResultNode** aResult);
 9855: 
  809:   nsresult BookmarkIdToResultNode(PRInt64 aBookmarkId,
  809:                                   nsNavHistoryQueryOptions* aOptions,
  809:                                   nsNavHistoryResultNode** aResult);
    1: 
    1:   // used by other places components to send history notifications (for example,
    1:   // when the favicon has changed)
    1:   void SendPageChangedNotification(nsIURI* aURI, PRUint32 aWhat,
30050:                                    const nsAString& aValue);
    1: 
    1:   // current time optimization
    1:   PRTime GetNow();
    1: 
    1:   // well-known annotations used by the history and bookmarks systems
    1:   static const char kAnnotationPreviousEncoding[];
    1: 
    1:   // used by query result nodes to update: see comment on body of CanLiveUpdateQuery
    1:   static PRUint32 GetUpdateRequirements(const nsCOMArray<nsNavHistoryQuery>& aQueries,
    1:                                         nsNavHistoryQueryOptions* aOptions,
    1:                                         PRBool* aHasSearchTerms);
    1:   PRBool EvaluateQueryForNode(const nsCOMArray<nsNavHistoryQuery>& aQueries,
    1:                               nsNavHistoryQueryOptions* aOptions,
    1:                               nsNavHistoryResultNode* aNode);
    1: 
    1:   static nsresult AsciiHostNameFromHostString(const nsACString& aHostName,
    1:                                               nsACString& aAscii);
11302:   void DomainNameFromURI(nsIURI* aURI,
    1:                          nsACString& aDomainName);
    1:   static PRTime NormalizeTime(PRUint32 aRelative, PRTime aOffset);
    1: 
 2051:   // Don't use these directly, inside nsNavHistory use UpdateBatchScoper,
 2051:   // else use nsINavHistoryService::RunInBatchMode
 2051:   nsresult BeginUpdateBatch();
 2051:   nsresult EndUpdateBatch();
 2051: 
 4623:   // the level of nesting of batches, 0 when no batches are open
 4623:   PRInt32 mBatchLevel;
 4623: 
 4623:   // true if the outermost batch has an associated transaction that should
 4623:   // be committed when our batch level reaches 0 again.
 4623:   PRBool mBatchHasTransaction;
 4623: 
    1:   // better alternative to QueryStringToQueries (in nsNavHistoryQuery.cpp)
    1:   nsresult QueryStringToQueryArray(const nsACString& aQueryString,
    1:                                    nsCOMArray<nsNavHistoryQuery>* aQueries,
    1:                                    nsNavHistoryQueryOptions** aOptions);
    1: 
12984:   // Import-friendly version of AddVisit.
    1:   // This method adds a page to history along with a single last visit.
    1:   // aLastVisitDate can be -1 if there is no last visit date to record.
 8225:   //
23588:   // This is only for use by the import of history.dat on first-run of Places,
23588:   // which currently occurs if no places.sqlite file previously exists.
23588:   nsresult AddPageWithVisits(nsIURI *aURI,
    1:                              const nsString &aTitle,
    1:                              PRInt32 aVisitCount,
23588:                              PRInt32 aTransitionType,
23588:                              PRTime aFirstVisitDate,
    1:                              PRTime aLastVisitDate);
    1: 
    1:   // Checks the database for any duplicate URLs.  If any are found,
    1:   // all but the first are removed.  This must be called after using
23588:   // AddPageWithVisits, to ensure that the database is in a consistent state.
    1:   nsresult RemoveDuplicateURIs();
    1: 
 1014:   // sets the schema version in the database to match SCHEMA_VERSION
 1014:   nsresult UpdateSchemaVersion();
 1014: 
20637:   // Returns true if we are currently in private browsing mode
20637:   PRBool InPrivateBrowsingMode()
20637:   {
20637:     if (mInPrivateBrowsing == PRIVATEBROWSING_NOTINITED) {
20637:       mInPrivateBrowsing = PR_FALSE;
20637:       nsCOMPtr<nsIPrivateBrowsingService> pbs =
20637:         do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
20637:       if (pbs) {
20637:         pbs->GetPrivateBrowsingEnabled(&mInPrivateBrowsing);
20637:       }
20637:     }
20637: 
20637:     return mInPrivateBrowsing;
20637:   }
20637: 
13310:   typedef nsDataHashtable<nsCStringHashKey, nsCString> StringHash;
13310: 
21642:   /**
21642:    * Helper method to finalize a statement
21642:    */
21642:   static nsresult
21642:   FinalizeStatement(mozIStorageStatement *aStatement) {
21642:     nsresult rv;
21642:     if (aStatement) {
21642:       rv = aStatement->Finalize();
21642:       NS_ENSURE_SUCCESS(rv, rv);
21642:     }
21642:     return NS_OK;
21642:   }
21642: 
30050:   /**
30050:    * Indicates if it is OK to notify history observers or not.
30050:    *
30050:    * @returns true if it is OK to notify, false otherwise.
30050:    */
30050:   bool canNotify() { return mCanNotify; }
    1:  private:
    1:   ~nsNavHistory();
    1: 
    1:   // used by GetHistoryService
    1:   static nsNavHistory *gHistoryService;
    1: 
    1: protected:
    1: 
    1:   //
    1:   // Constants
    1:   //
    1:   nsCOMPtr<nsIPrefBranch> mPrefBranch; // MAY BE NULL when we are shutting down
    1:   nsDataHashtable<nsStringHashKey, int> gExpandedItems;
    1: 
    1:   //
    1:   // Database stuff
    1:   //
    1:   nsCOMPtr<mozIStorageService> mDBService;
    1:   nsCOMPtr<mozIStorageConnection> mDBConn;
 2874:   nsCOMPtr<nsIFile> mDBFile;
    1: 
    1:   nsCOMPtr<mozIStorageStatement> mDBGetURLPageInfo;   // kGetInfoIndex_* results
    1:   nsCOMPtr<mozIStorageStatement> mDBGetIdPageInfo;     // kGetInfoIndex_* results
    1: 
    1:   nsCOMPtr<mozIStorageStatement> mDBRecentVisitOfURL; // converts URL into most recent visit ID/session ID
16751:   nsCOMPtr<mozIStorageStatement> mDBRecentVisitOfPlace; // converts placeID into most recent visit ID/session ID
    1:   nsCOMPtr<mozIStorageStatement> mDBInsertVisit; // used by AddVisit
    1:   nsCOMPtr<mozIStorageStatement> mDBGetPageVisitStats; // used by AddVisit
13698:   nsCOMPtr<mozIStorageStatement> mDBIsPageVisited; // used by IsURIStringVisited
    1:   nsCOMPtr<mozIStorageStatement> mDBUpdatePageVisitStats; // used by AddVisit
    1:   nsCOMPtr<mozIStorageStatement> mDBAddNewPage; // used by InternalAddNewPage
33458:   nsCOMPtr<mozIStorageStatement> mDBGetTags; // used by GetTags
33458:   nsCOMPtr<mozIStorageStatement> mDBGetItemsWithAnno; // used by AutoComplete::StartSearch and FilterResultSet
20871:   nsCOMPtr<mozIStorageStatement> mDBSetPlaceTitle; // used by SetPageTitleInternal
    1: 
    1:   // these are used by VisitIdToResultNode for making new result nodes from IDs
20879:   // Consumers need to use the getters since these statements are lazily created
20879:   mozIStorageStatement *GetDBVisitToURLResult();
    1:   nsCOMPtr<mozIStorageStatement> mDBVisitToURLResult; // kGetInfoIndex_* results
20879:   mozIStorageStatement *GetDBVisitToVisitResult();
    1:   nsCOMPtr<mozIStorageStatement> mDBVisitToVisitResult; // kGetInfoIndex_* results
20880:   mozIStorageStatement *GetDBBookmarkToUrlResult();
  809:   nsCOMPtr<mozIStorageStatement> mDBBookmarkToUrlResult; // kGetInfoIndex_* results
    1: 
21642:   /**
21642:    * Finalize all internal statements.
21642:    */
33829:   NS_HIDDEN_(nsresult) FinalizeStatements();
21642: 
32454:   /**
32454:    * Analyzes the database and VACUUM it, if needed.
32454:    */
32454:   NS_HIDDEN_(nsresult) DecayFrecency();
32454:   /**
32454:    * Decays frecency and inputhistory values.
32454:    */
32454:   NS_HIDDEN_(nsresult) VacuumDatabase();
32454: 
33829:   /**
33829:    * Finalizes all Places internal statements, allowing to safely close the
33829:    * database connection.
33829:    */
33829:   NS_HIDDEN_(nsresult) FinalizeInternalStatements();
33829: 
14062:   // nsICharsetResolver
14062:   NS_DECL_NSICHARSETRESOLVER
14062: 
10669:   nsresult CalculateFrecency(PRInt64 aPageID, PRInt32 aTyped, PRInt32 aVisitCount, nsCAutoString &aURL, PRInt32 *aFrecency);
10669:   nsresult CalculateFrecencyInternal(PRInt64 aPageID, PRInt32 aTyped, PRInt32 aVisitCount, PRBool aIsBookmarked, PRInt32 *aFrecency);
10669:   nsCOMPtr<mozIStorageStatement> mDBVisitsForFrecency;
10669:   nsCOMPtr<mozIStorageStatement> mDBUpdateFrecencyAndHidden;
10669:   nsCOMPtr<mozIStorageStatement> mDBGetPlaceVisitStats;
13613:   nsCOMPtr<mozIStorageStatement> mDBFullVisitCount;
10669: 
11253:   /**
11253:    * Initializes the database file.  If the database does not exist, was
11253:    * corrupted, or aForceInit is true, we recreate the database.  We also backup
11253:    * the database if it was corrupted or aForceInit is true.
11253:    *
11253:    * @param aForceInit
11253:    *        Indicates if we should close an open database connection or not.
11470:    *        Note: A valid database connection must be opened if this is true.
11253:    */
 2874:   nsresult InitDBFile(PRBool aForceInit);
11253: 
11253:   /**
11253:    * Initializes the database.  This performs any necessary migrations for the
11253:    * database.  All migration is done inside a transaction that is rolled back
11253:    * if any error occurs.  Upon initialization, history is imported, and some
11253:    * preferences that are used are set.
11253:    */
23197:   nsresult InitDB();
28515: 
28515:   /**
28515:    * Initializes additional database items like: views, temp tables, functions
28515:    * and statements.
28515:    */
28515:   nsresult InitAdditionalDBItems();
20867:   nsresult InitTempTables();
20867:   nsresult InitViews();
12328:   nsresult InitFunctions();
    1:   nsresult InitStatements();
  338:   nsresult ForceMigrateBookmarksDB(mozIStorageConnection *aDBConn);
  711:   nsresult MigrateV3Up(mozIStorageConnection *aDBConn);
 4037:   nsresult MigrateV6Up(mozIStorageConnection *aDBConn);
16356:   nsresult MigrateV7Up(mozIStorageConnection *aDBConn);
20868:   nsresult MigrateV8Up(mozIStorageConnection *aDBConn);
28350:   nsresult MigrateV9Up(mozIStorageConnection *aDBConn);
29518:   nsresult MigrateV10Up(mozIStorageConnection *aDBConn);
    1: 
11424:   nsresult RemovePagesInternal(const nsCString& aPlaceIdsQueryString);
28485:   nsresult PreparePlacesForVisitsDelete(const nsCString& aPlaceIdsQueryString);
28485:   nsresult CleanupPlacesOnVisitsDelete(const nsCString& aPlaceIdsQueryString);
11424: 
    1:   nsresult AddURIInternal(nsIURI* aURI, PRTime aTime, PRBool aRedirect,
    1:                           PRBool aToplevel, nsIURI* aReferrer);
    1: 
    1:   nsresult AddVisitChain(nsIURI* aURI, PRTime aTime,
    1:                          PRBool aToplevel, PRBool aRedirect,
    1:                          nsIURI* aReferrer, PRInt64* aVisitID,
    1:                          PRInt64* aSessionID, PRInt64* aRedirectBookmark);
    1:   nsresult InternalAddNewPage(nsIURI* aURI, const nsAString& aTitle,
    1:                               PRBool aHidden, PRBool aTyped,
10669:                               PRInt32 aVisitCount, PRBool aCalculateFrecency,
10669:                               PRInt64* aPageID);
    1:   nsresult InternalAddVisit(PRInt64 aPageID, PRInt64 aReferringVisit,
    1:                             PRInt64 aSessionID, PRTime aTime,
    1:                             PRInt32 aTransitionType, PRInt64* aVisitID);
    1:   PRBool FindLastVisit(nsIURI* aURI, PRInt64* aVisitID,
    1:                        PRInt64* aSessionID);
    1:   PRBool IsURIStringVisited(const nsACString& url);
11253: 
11253:   /**
11253:    * This loads all of the preferences that we use into member variables.
11253:    * NOTE:  If mPrefBranch is NULL, this does nothing.
11253:    *
11253:    * @param aInitializing
11253:    *        Indicates if the autocomplete queries should be regenerated or not.
11253:    */
10669:   nsresult LoadPrefs(PRBool aInitializing);
    1: 
    1:   // Current time optimization
    1:   PRTime mLastNow;
    1:   PRBool mNowValid;
    1:   nsCOMPtr<nsITimer> mExpireNowTimer;
    1:   static void expireNowTimerCallback(nsITimer* aTimer, void* aClosure);
    1: 
    1:   // expiration
    1:   friend class nsNavHistoryExpire;
33704:   nsNavHistoryExpire *mExpire;
    1: 
    1: #ifdef LAZY_ADD
    1:   // lazy add committing
    1:   struct LazyMessage {
    1:     enum MessageType { Type_Invalid, Type_AddURI, Type_Title, Type_Favicon };
    1:     LazyMessage()
    1:     {
    1:       type = Type_Invalid;
    1:       isRedirect = PR_FALSE;
    1:       isToplevel = PR_FALSE;
    1:       time = 0;
    1:       alwaysLoadFavicon = PR_FALSE;
    1:     }
    1: 
    1:     // call this with common parms to initialize. Caller is responsible for
    1:     // setting other elements manually depending on type.
    1:     nsresult Init(MessageType aType, nsIURI* aURI)
    1:     {
 8268:       NS_ENSURE_ARG_POINTER(aURI);
    1:       type = aType;
    1:       nsresult rv = aURI->Clone(getter_AddRefs(uri));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:       return uri->GetSpec(uriSpec);
    1:     }
    1: 
    1:     // common elements
    1:     MessageType type;
    1:     nsCOMPtr<nsIURI> uri;
    1:     nsCString uriSpec; // stringified version of URI, for quick isVisited
    1: 
    1:     // valid when type == Type_AddURI
    1:     nsCOMPtr<nsIURI> referrer;
    1:     PRBool isRedirect;
    1:     PRBool isToplevel;
    1:     PRTime time;
    1: 
    1:     // valid when type == Type_Title
    1:     nsString title;
    1: 
    1:     // valid when type == LAZY_FAVICON
    1:     nsCOMPtr<nsIURI> favicon;
    1:     PRBool alwaysLoadFavicon;
    1:   };
    1:   nsTArray<LazyMessage> mLazyMessages;
    1:   nsCOMPtr<nsITimer> mLazyTimer;
    1:   PRBool mLazyTimerSet;
    1:   PRUint32 mLazyTimerDeferments; // see StartLazyTimer
    1:   nsresult StartLazyTimer();
    1:   nsresult AddLazyMessage(const LazyMessage& aMessage);
    1:   static void LazyTimerCallback(nsITimer* aTimer, void* aClosure);
33829:   NS_HIDDEN_(void) CommitLazyMessages(PRBool aIsShutdown = PR_FALSE);
    1: #endif
    1: 
 4049:   nsresult ConstructQueryString(const nsCOMArray<nsNavHistoryQuery>& aQueries, 
 4049:                                 nsNavHistoryQueryOptions* aOptions,
12328:                                 nsCString& queryString,
13310:                                 PRBool& aParamsPresent,
13310:                                 StringHash& aAddParams);
 4049: 
    1:   nsresult QueryToSelectClause(nsNavHistoryQuery* aQuery,
  809:                                nsNavHistoryQueryOptions* aOptions,
13310:                                PRInt32 aQueryIndex,
13310:                                nsCString* aClause);
    1:   nsresult BindQueryClauseParameters(mozIStorageStatement* statement,
13310:                                      PRInt32 aQueryIndex,
    1:                                      nsNavHistoryQuery* aQuery,
13310:                                      nsNavHistoryQueryOptions* aOptions);
    1: 
    1:   nsresult ResultsAsList(mozIStorageStatement* statement,
    1:                          nsNavHistoryQueryOptions* aOptions,
    1:                          nsCOMArray<nsNavHistoryResultNode>* aResults);
    1: 
    1:   void TitleForDomain(const nsCString& domain, nsACString& aTitle);
    1: 
 4037:   nsresult SetPageTitleInternal(nsIURI* aURI, const nsAString& aTitle);
    1: 
 5542:   nsresult FilterResultSet(nsNavHistoryQueryResultNode *aParentNode,
 5542:                            const nsCOMArray<nsNavHistoryResultNode>& aSet,
    1:                            nsCOMArray<nsNavHistoryResultNode>* aFiltered,
 6483:                            const nsCOMArray<nsNavHistoryQuery>& aQueries,
 6483:                            nsNavHistoryQueryOptions* aOptions);
    1: 
    1:   // observers
    1:   nsMaybeWeakPtrArray<nsINavHistoryObserver> mObservers;
    1: 
11302:   // effective tld service
11302:   nsCOMPtr<nsIEffectiveTLDService> mTLDService;
11302:   nsCOMPtr<nsIIDNService>          mIDNService;
11302: 
    1:   // localization
    1:   nsCOMPtr<nsIStringBundle> mBundle;
26467:   nsCOMPtr<nsIStringBundle> mDateFormatBundle;
    1:   nsCOMPtr<nsICollation> mCollation;
    1: 
    1:   // annotation service : MAY BE NULL!
    1:   //nsCOMPtr<mozIAnnotationService> mAnnotationService;
    1: 
    1:   // recent events
    1:   typedef nsDataHashtable<nsCStringHashKey, PRInt64> RecentEventHash;
    1:   RecentEventHash mRecentTyped;
    1:   RecentEventHash mRecentBookmark;
    1: 
    1:   PRBool CheckIsRecentEvent(RecentEventHash* hashTable,
    1:                             const nsACString& url);
    1:   void ExpireNonrecentEvents(RecentEventHash* hashTable);
    1: 
    1:   // redirect tracking. See GetRedirectFor for a description of how this works.
    1:   struct RedirectInfo {
    1:     nsCString mSourceURI;
    1:     PRTime mTimeCreated;
    1:     PRUint32 mType; // one of TRANSITION_REDIRECT_[TEMPORARY,PERMANENT]
    1:   };
    1:   typedef nsDataHashtable<nsCStringHashKey, RedirectInfo> RedirectHash;
    1:   RedirectHash mRecentRedirects;
20261:   static PLDHashOperator ExpireNonrecentRedirects(
    1:       nsCStringHashKey::KeyType aKey, RedirectInfo& aData, void* aUserArg);
    1:   PRBool GetRedirectFor(const nsACString& aDestination, nsACString& aSource,
    1:                         PRTime* aTime, PRUint32* aRedirectType);
    1: 
    1:   // session tracking
    1:   PRInt64 mLastSessionID;
    1:   PRInt64 GetNewSessionID() { mLastSessionID ++; return mLastSessionID; }
    1: 
30902: #ifdef MOZ_XUL
    1:   // AutoComplete stuff
20882:   mozIStorageStatement *GetDBFeedbackIncrease();
12214:   nsCOMPtr<mozIStorageStatement> mDBFeedbackIncrease;
 5804: 
12214:   nsresult AutoCompleteFeedback(PRInt32 aIndex,
12214:                                 nsIAutoCompleteController *aController);
10432: #endif
10669: 
 8761:   PRInt32 mExpireDaysMin;
 8761:   PRInt32 mExpireDaysMax;
 8761:   PRInt32 mExpireSites;
    1: 
10669:   // frecency prefs
10669:   PRInt32 mNumVisitsForFrecency;
10669:   PRInt32 mFirstBucketCutoffInDays;
10669:   PRInt32 mSecondBucketCutoffInDays;
10669:   PRInt32 mThirdBucketCutoffInDays;
10669:   PRInt32 mFourthBucketCutoffInDays;
10669:   PRInt32 mFirstBucketWeight;
10669:   PRInt32 mSecondBucketWeight;
10669:   PRInt32 mThirdBucketWeight;
10669:   PRInt32 mFourthBucketWeight;
10669:   PRInt32 mDefaultWeight;
10669:   PRInt32 mEmbedVisitBonus;
10669:   PRInt32 mLinkVisitBonus;
10669:   PRInt32 mTypedVisitBonus;
10669:   PRInt32 mBookmarkVisitBonus;
10669:   PRInt32 mDownloadVisitBonus;
10669:   PRInt32 mPermRedirectVisitBonus;
10669:   PRInt32 mTempRedirectVisitBonus;
10669:   PRInt32 mDefaultVisitBonus;
10669:   PRInt32 mUnvisitedBookmarkBonus;
10669:   PRInt32 mUnvisitedTypedBonus;
10669: 
    1:   // in nsNavHistoryQuery.cpp
    1:   nsresult TokensToQueries(const nsTArray<QueryKeyValuePair>& aTokens,
    1:                            nsCOMArray<nsNavHistoryQuery>* aQueries,
    1:                            nsNavHistoryQueryOptions* aOptions);
    1: 
 8193:   PRInt64 mTagsFolder;
20637: 
20637:   PRBool mInPrivateBrowsing;
21600: 
22759:   PRUint16 mDatabaseStatus;
30050: 
30050:   // Used to enable and disable the observer notifications
30050:   bool mCanNotify;
30050:   nsCategoryCache<nsINavHistoryObserver> mCacheObservers;
    1: };
    1: 
    1: /**
    1:  * Shared between the places components, this function binds the given URI as
    1:  * UTF8 to the given parameter for the statement.
    1:  */
    1: nsresult BindStatementURI(mozIStorageStatement* statement, PRInt32 index,
    1:                           nsIURI* aURI);
    1: 
    1: #define PLACES_URI_PREFIX "place:"
    1: 
    1: /* Returns true if the given URI represents a history query. */
    1: inline PRBool IsQueryURI(const nsCString &uri)
    1: {
    1:   return StringBeginsWith(uri, NS_LITERAL_CSTRING(PLACES_URI_PREFIX));
    1: }
    1: 
    1: /* Extracts the query string from a query URI. */
    1: inline const nsDependentCSubstring QueryURIToQuery(const nsCString &uri)
    1: {
    1:   NS_ASSERTION(IsQueryURI(uri), "should only be called for query URIs");
    1:   return Substring(uri, NS_LITERAL_CSTRING(PLACES_URI_PREFIX).Length());
    1: }
    1: 
    1: #endif // nsNavHistory_h_
