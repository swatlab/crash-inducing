    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* vim:expandtab:shiftwidth=4:tabstop=4:
    1:  */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Christopher Blizzard <blizzard@mozilla.org>.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Christopher Blizzard <blizzard@mozilla.org>
    1:  *   Markus G. Kuhn <mkuhn@acm.org>
    1:  *   Richard Verhoeven <river@win.tue.nl>
    1:  *   Frank Tang <ftang@netscape.com> adopt into mozilla
32484:  *   Ginn Chen <ginn.chen@sun.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsDragService.h"
    1: #include "nsIObserverService.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsWindow.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
22432: #include "nsIIOService.h"
22432: #include "nsIFileURL.h"
22432: #include "nsNetUtil.h"
    1: #include "prlog.h"
25381: #include "nsTArray.h"
    1: #include "nsPrimitiveHelpers.h"
    1: #include "prtime.h"
    1: #include "prthread.h"
23281: #include <gtk/gtk.h>
    1: #include <gdk/gdkx.h>
    1: #include "nsCRT.h"
    1: 
    1: #include "gfxASurface.h"
15409: #include "gfxXlibSurface.h"
15409: #include "gfxContext.h"
    1: #include "nsImageToPixbuf.h"
10025: #include "nsIPresShell.h"
10025: #include "nsPresContext.h"
10025: #include "nsIDocument.h"
13254: #include "nsISelection.h"
    1: 
15409: // This sets how opaque the drag image is
15409: #define DRAG_IMAGE_ALPHA_LEVEL 0.5
15409: 
29409: // These values are copied from GtkDragResult (rather than using GtkDragResult
29409: // directly) so that this code can be compiled against versions of GTK+ that
29409: // do not have GtkDragResult.
29409: // GtkDragResult is available from GTK+ version 2.12.
29409: enum {
29409:   MOZ_GTK_DRAG_RESULT_SUCCESS,
29409:   MOZ_GTK_DRAG_RESULT_NO_TARGET
29409: };
29409: 
    1: static PRLogModuleInfo *sDragLm = NULL;
    1: 
    1: static const char gMimeListType[] = "application/x-moz-internal-item-list";
    1: static const char gMozUrlType[] = "_NETSCAPE_URL";
    1: static const char gTextUriListType[] = "text/uri-list";
32484: static const char gTextPlainUTF8Type[] = "text/plain;charset=utf-8";
    1: 
    1: static void
    1: invisibleSourceDragEnd(GtkWidget        *aWidget,
    1:                        GdkDragContext   *aContext,
    1:                        gpointer          aData);
    1: 
29409: static gboolean
29409: invisibleSourceDragFailed(GtkWidget        *aWidget,
29409:                           GdkDragContext   *aContext,
29409:                           gint              aResult,
29409:                           gpointer          aData);
29409: 
    1: static void
    1: invisibleSourceDragDataGet(GtkWidget        *aWidget,
    1:                            GdkDragContext   *aContext,
    1:                            GtkSelectionData *aSelectionData,
    1:                            guint             aInfo,
    1:                            guint32           aTime,
    1:                            gpointer          aData);
    1: 
    1: nsDragService::nsDragService()
    1: {
    1:     // We have to destroy the hidden widget before the event loop stops
    1:     // running.
    1:     nsCOMPtr<nsIObserverService> obsServ =
    1:         do_GetService("@mozilla.org/observer-service;1");
    1:     obsServ->AddObserver(this, "quit-application", PR_FALSE);
    1: 
    1:     // our hidden source widget
    1:     mHiddenWidget = gtk_invisible_new();
    1:     // make sure that the widget is realized so that
    1:     // we can use it as a drag source.
    1:     gtk_widget_realize(mHiddenWidget);
    1:     // hook up our internal signals so that we can get some feedback
    1:     // from our drag source
24530:     g_signal_connect(GTK_OBJECT(mHiddenWidget), "drag_data_get",
24530:                      G_CALLBACK(invisibleSourceDragDataGet), this);
24530:     g_signal_connect(GTK_OBJECT(mHiddenWidget), "drag_end",
24530:                      G_CALLBACK(invisibleSourceDragEnd), this);
29409:     // drag-failed is available from GTK+ version 2.12
29409:     guint dragFailedID = g_signal_lookup("drag-failed",
29409:                                          G_TYPE_FROM_INSTANCE(mHiddenWidget));
29409:     if (dragFailedID) {
29409:         g_signal_connect_closure_by_id(mHiddenWidget, dragFailedID, 0,
29409:                                        g_cclosure_new(G_CALLBACK(invisibleSourceDragFailed),
29409:                                                       this, NULL),
29409:                                        FALSE);
29409:     }
    1: 
    1:     // set up our logging module
    1:     if (!sDragLm)
    1:         sDragLm = PR_NewLogModule("nsDragService");
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::nsDragService"));
    1:     mTargetWidget = 0;
    1:     mTargetDragContext = 0;
    1:     mTargetTime = 0;
    1:     mCanDrop = PR_FALSE;
    1:     mTargetDragDataReceived = PR_FALSE;
    1:     mTargetDragData = 0;
    1:     mTargetDragDataLen = 0;
    1: }
    1: 
    1: nsDragService::~nsDragService()
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::~nsDragService"));
    1: }
    1: 
 4345: NS_IMPL_ISUPPORTS_INHERITED2(nsDragService, nsBaseDragService,
 4345:                              nsIDragSessionGTK, nsIObserver)
 4345: 
    1: // nsIObserver
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::Observe(nsISupports *aSubject, const char *aTopic,
    1:                        const PRUnichar *aData)
    1: {
    1:   if (!nsCRT::strcmp(aTopic, "quit-application")) {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:            ("nsDragService::Observe(\"quit-application\")"));
    1:     if (mHiddenWidget) {
    1:       gtk_widget_destroy(mHiddenWidget);
    1:       mHiddenWidget = 0;
    1:     }
    1:     TargetResetData();
    1:   } else {
    1:     NS_NOTREACHED("unexpected topic");
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIDragService
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::InvokeDragSession(nsIDOMNode *aDOMNode,
    1:                                  nsISupportsArray * aArrayTransferables,
    1:                                  nsIScriptableRegion * aRegion,
    1:                                  PRUint32 aActionType)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::InvokeDragSession"));
13306:     nsresult rv = nsBaseDragService::InvokeDragSession(aDOMNode,
13306:                                                        aArrayTransferables,
    1:                                                        aRegion, aActionType);
13306:     NS_ENSURE_SUCCESS(rv, rv);
13306: 
    1:     // make sure that we have an array of transferables to use
    1:     if (!aArrayTransferables)
    1:         return NS_ERROR_INVALID_ARG;
    1:     // set our reference to the transferables.  this will also addref
    1:     // the transferables since we're going to hang onto this beyond the
    1:     // length of this call
    1:     mSourceDataItems = aArrayTransferables;
    1:     // get the list of items we offer for drags
25274:     GtkTargetList *sourceList = GetSourceList();
    1: 
25274:     if (!sourceList)
25274:         return NS_OK;
    1: 
    1:     // save our action type
    1:     GdkDragAction action = GDK_ACTION_DEFAULT;
    1: 
    1:     if (aActionType & DRAGDROP_ACTION_COPY)
    1:         action = (GdkDragAction)(action | GDK_ACTION_COPY);
    1:     if (aActionType & DRAGDROP_ACTION_MOVE)
    1:         action = (GdkDragAction)(action | GDK_ACTION_MOVE);
    1:     if (aActionType & DRAGDROP_ACTION_LINK)
    1:         action = (GdkDragAction)(action | GDK_ACTION_LINK);
    1: 
    1:     // Create a fake event for the drag so we can pass the time
    1:     // (so to speak.)  If we don't do this the drag can end as a
    1:     // result of a button release that is actually _earlier_ than
    1:     // CurrentTime.  So we use the time on the last button press
    1:     // event, as that will always be older than the button release
    1:     // that ends any drag.
    1:     GdkEvent event;
    1:     memset(&event, 0, sizeof(GdkEvent));
    1:     event.type = GDK_BUTTON_PRESS;
    1:     event.button.window = mHiddenWidget->window;
    1:     event.button.time = nsWindow::mLastButtonPressTime;
    1: 
    1:     // start our drag.
    1:     GdkDragContext *context = gtk_drag_begin(mHiddenWidget,
    1:                                              sourceList,
    1:                                              action,
    1:                                              1,
    1:                                              &event);
    1: 
25274:     if (!context) {
25274:         rv = NS_ERROR_FAILURE;
25274:     } else {
15409:         PRBool needsFallbackIcon = PR_FALSE;
23738:         nsIntRect dragRect;
10025:         nsPresContext* pc;
15409:         nsRefPtr<gfxASurface> surface;
15390:         if (mHasImage || mSelection) {
    1:           DrawDrag(aDOMNode, aRegion, mScreenX, mScreenY,
10025:                    &dragRect, getter_AddRefs(surface), &pc);
    1:         }
    1: 
15409:         if (surface) {
10025:           PRInt32 sx = mScreenX, sy = mScreenY;
10025:           ConvertToUnscaledDevPixels(pc, &sx, &sy);
15409: 
23738:           PRInt32 offsetX = sx - dragRect.x;
23738:           PRInt32 offsetY = sy - dragRect.y;
15409:           if (!SetAlphaPixmap(surface, context, offsetX, offsetY, dragRect)) {
15409:             GdkPixbuf* dragPixbuf =
15409:               nsImageToPixbuf::SurfaceToPixbuf(surface, dragRect.width, dragRect.height);
15409:             if (dragPixbuf)
15409:               gtk_drag_set_icon_pixbuf(context, dragPixbuf, offsetX, offsetY);
15409:             else
15409:               needsFallbackIcon = PR_TRUE;
15390:           }
15409:         } else {
15409:           needsFallbackIcon = PR_TRUE;
15409:         }
15409: 
15409:         if (needsFallbackIcon)
    1:           gtk_drag_set_icon_default(context);
25274:     }
 2467: 
    1:     gtk_target_list_unref(sourceList);
    1: 
29217:     StartDragSession();
29217: 
25274:     return rv;
    1: }
    1: 
15409: PRBool
15409: nsDragService::SetAlphaPixmap(gfxASurface *aSurface,
15409:                                  GdkDragContext *aContext,
15409:                                  PRInt32 aXOffset,
15409:                                  PRInt32 aYOffset,
23738:                                  const nsIntRect& dragRect)
15409: {
15409:     GdkScreen* screen = gtk_widget_get_screen(mHiddenWidget);
15409: 
15409:     // Transparent drag icons need, like a lot of transparency-related things,
15409:     // a compositing X window manager
15409:     if (!gdk_screen_is_composited(screen))
15409:       return PR_FALSE;
15409: 
15409:     GdkColormap* alphaColormap = gdk_screen_get_rgba_colormap(screen);
15409:     if (!alphaColormap)
15409:       return PR_FALSE;
15409: 
15409:     GdkPixmap* pixmap = gdk_pixmap_new(NULL, dragRect.width, dragRect.height,
15409:                                        gdk_colormap_get_visual(alphaColormap)->depth);
15409:     if (!pixmap)
15409:       return PR_FALSE;
15409: 
15409:     gdk_drawable_set_colormap(GDK_DRAWABLE(pixmap), alphaColormap);
15409: 
15409:     // Make a gfxXlibSurface wrapped around the pixmap to render on
15409:     nsRefPtr<gfxASurface> xPixmapSurface =
15409:          nsWindow::GetSurfaceForGdkDrawable(GDK_DRAWABLE(pixmap),
15409:                                             dragRect.Size());
15409:     if (!xPixmapSurface)
15409:       return PR_FALSE;
15409: 
15409:     nsRefPtr<gfxContext> xPixmapCtx = new gfxContext(xPixmapSurface);
15409: 
15409:     // Clear it...
15409:     xPixmapCtx->SetOperator(gfxContext::OPERATOR_CLEAR);
15409:     xPixmapCtx->Paint();
15409: 
15409:     // ...and paint the drag image with translucency
15409:     xPixmapCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
15409:     xPixmapCtx->SetSource(aSurface);
15409:     xPixmapCtx->Paint(DRAG_IMAGE_ALPHA_LEVEL);
15409: 
15409:     // The drag transaction addrefs the pixmap, so we can just unref it from us here
15409:     gtk_drag_set_icon_pixmap(aContext, alphaColormap, pixmap, NULL,
15409:                              aXOffset, aYOffset);
24530:     g_object_unref(pixmap);
15409:     return PR_TRUE;
15409: }
15409: 
    1: NS_IMETHODIMP
    1: nsDragService::StartDragSession()
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::StartDragSession"));
    1:     return nsBaseDragService::StartDragSession();
    1: }
    1:  
    1: NS_IMETHODIMP
  482: nsDragService::EndDragSession(PRBool aDoneDrag)
    1: {
29217:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::EndDragSession %d",
29217:                                    aDoneDrag));
    1:     // unset our drag action
    1:     SetDragAction(DRAGDROP_ACTION_NONE);
  482:     return nsBaseDragService::EndDragSession(aDoneDrag);
    1: }
    1: 
    1: // nsIDragSession
    1: NS_IMETHODIMP
    1: nsDragService::SetCanDrop(PRBool aCanDrop)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::SetCanDrop %d",
    1:                                    aCanDrop));
    1:     mCanDrop = aCanDrop;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::GetCanDrop(PRBool *aCanDrop)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::GetCanDrop"));
    1:     *aCanDrop = mCanDrop;
    1:     return NS_OK;
    1: }
    1: 
    1: // count the number of URIs in some text/uri-list format data.
    1: static PRUint32
    1: CountTextUriListItems(const char *data,
    1:                       PRUint32 datalen)
    1: {
    1:     const char *p = data;
    1:     const char *endPtr = p + datalen;
    1:     PRUint32 count = 0;
    1: 
    1:     while (p < endPtr) {
    1:         // skip whitespace (if any)
    1:         while (p < endPtr && *p != '\0' && isspace(*p))
    1:             p++;
    1:         // if we aren't at the end of the line ...
    1:         if (p != endPtr && *p != '\0' && *p != '\n' && *p != '\r')
    1:             count++;
    1:         // skip to the end of the line
    1:         while (p < endPtr && *p != '\0' && *p != '\n')
    1:             p++;
    1:         p++; // skip the actual newline as well.
    1:     }
    1:     return count;
    1: }
    1: 
    1: // extract an item from text/uri-list formatted data and convert it to
    1: // unicode.
    1: static void
    1: GetTextUriListItem(const char *data,
    1:                    PRUint32 datalen,
    1:                    PRUint32 aItemIndex,
    1:                    PRUnichar **convertedText,
    1:                    PRInt32 *convertedTextLen)
    1: {
    1:     const char *p = data;
    1:     const char *endPtr = p + datalen;
    1:     unsigned int count = 0;
    1: 
    1:     *convertedText = nsnull;
    1:     while (p < endPtr) {
    1:         // skip whitespace (if any)
    1:         while (p < endPtr && *p != '\0' && isspace(*p))
    1:             p++;
    1:         // if we aren't at the end of the line, we have a url
    1:         if (p != endPtr && *p != '\0' && *p != '\n' && *p != '\r')
    1:             count++;
    1:         // this is the item we are after ...
    1:         if (aItemIndex + 1 == count) {
    1:             const char *q = p;
    1:             while (q < endPtr && *q != '\0' && *q != '\n' && *q != '\r')
    1:               q++;
    1:             nsPrimitiveHelpers::ConvertPlatformPlainTextToUnicode(
    1:                                 p, q - p, convertedText, convertedTextLen);
    1:             break;
    1:         }
    1:         // skip to the end of the line
    1:         while (p < endPtr && *p != '\0' && *p != '\n')
    1:             p++;
    1:         p++; // skip the actual newline as well.
    1:     }
    1: 
    1:     // didn't find the desired item, so just pass the whole lot
    1:     if (!*convertedText) {
    1:         nsPrimitiveHelpers::ConvertPlatformPlainTextToUnicode(
    1:                             data, datalen, convertedText, convertedTextLen);
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::GetNumDropItems(PRUint32 * aNumItems)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::GetNumDropItems"));
    1:     PRBool isList = IsTargetContextList();
    1:     if (isList)
    1:         mSourceDataItems->Count(aNumItems);
    1:     else {
    1:         GdkAtom gdkFlavor = gdk_atom_intern(gTextUriListType, FALSE);
    1:         GetTargetDragData(gdkFlavor);
    1:         if (mTargetDragData) {
 3233:             const char *data = reinterpret_cast<char*>(mTargetDragData);
    1:             *aNumItems = CountTextUriListItems(data, mTargetDragDataLen);
    1:         } else
    1:             *aNumItems = 1;
    1:     }
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("%d items", *aNumItems));
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::GetData(nsITransferable * aTransferable,
    1:                        PRUint32 aItemIndex)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::GetData %d", aItemIndex));
    1: 
    1:     // make sure that we have a transferable
    1:     if (!aTransferable)
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // get flavor list that includes all acceptable flavors (including
    1:     // ones obtained through conversion). Flavors are nsISupportsStrings
    1:     // so that they can be seen from JS.
    1:     nsresult rv = NS_ERROR_FAILURE;
    1:     nsCOMPtr<nsISupportsArray> flavorList;
    1:     rv = aTransferable->FlavorsTransferableCanImport(
    1:                         getter_AddRefs(flavorList));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // count the number of flavors
    1:     PRUint32 cnt;
    1:     flavorList->Count(&cnt);
    1:     unsigned int i;
    1: 
    1:     // check to see if this is an internal list
    1:     PRBool isList = IsTargetContextList();
    1: 
    1:     if (isList) {
    1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("it's a list..."));
 3400:         // find a matching flavor
 3400:         for (i = 0; i < cnt; ++i) {
    1:             nsCOMPtr<nsISupports> genericWrapper;
 3400:             flavorList->GetElementAt(i, getter_AddRefs(genericWrapper));
    1:             nsCOMPtr<nsISupportsCString> currentFlavor;
    1:             currentFlavor = do_QueryInterface(genericWrapper);
 3400:             if (!currentFlavor)
 3400:                 continue;
 3400: 
    1:             nsXPIDLCString flavorStr;
    1:             currentFlavor->ToString(getter_Copies(flavorStr));
    1:             PR_LOG(sDragLm,
    1:                    PR_LOG_DEBUG,
    1:                    ("flavor is %s\n", (const char *)flavorStr));
    1:             // get the item with the right index
    1:             nsCOMPtr<nsISupports> genericItem;
    1:             mSourceDataItems->GetElementAt(aItemIndex,
    1:                                            getter_AddRefs(genericItem));
    1:             nsCOMPtr<nsITransferable> item(do_QueryInterface(genericItem));
 3400:             if (!item)
 3400:                 continue;
 3400: 
    1:             nsCOMPtr<nsISupports> data;
    1:             PRUint32 tmpDataLen = 0;
    1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                    ("trying to get transfer data for %s\n",
    1:                    (const char *)flavorStr));
    1:             rv = item->GetTransferData(flavorStr,
    1:                                        getter_AddRefs(data),
    1:                                        &tmpDataLen);
    1:             if (NS_FAILED(rv)) {
    1:                 PR_LOG(sDragLm, PR_LOG_DEBUG, ("failed.\n"));
 3400:                 continue;
    1:             }
    1:             PR_LOG(sDragLm, PR_LOG_DEBUG, ("succeeded.\n"));
    1:             rv = aTransferable->SetTransferData(flavorStr,data,tmpDataLen);
    1:             if (NS_FAILED(rv)) {
    1:                 PR_LOG(sDragLm,
    1:                        PR_LOG_DEBUG,
    1:                        ("fail to set transfer data into transferable!\n"));
 3400:                 continue;
    1:             }
    1:             // ok, we got the data
    1:             return NS_OK;
    1:         }
    1:         // if we got this far, we failed
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Now walk down the list of flavors. When we find one that is
    1:     // actually present, copy out the data into the transferable in that
    1:     // format. SetTransferData() implicitly handles conversions.
    1:     for ( i = 0; i < cnt; ++i ) {
    1:         nsCOMPtr<nsISupports> genericWrapper;
    1:         flavorList->GetElementAt(i,getter_AddRefs(genericWrapper));
    1:         nsCOMPtr<nsISupportsCString> currentFlavor;
    1:         currentFlavor = do_QueryInterface(genericWrapper);
    1:         if (currentFlavor) {
    1:             // find our gtk flavor
    1:             nsXPIDLCString flavorStr;
    1:             currentFlavor->ToString(getter_Copies(flavorStr));
    1:             GdkAtom gdkFlavor = gdk_atom_intern(flavorStr, FALSE);
    1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                    ("looking for data in type %s, gdk flavor %ld\n",
 3233:                    static_cast<const char*>(flavorStr), gdkFlavor));
    1:             PRBool dataFound = PR_FALSE;
    1:             if (gdkFlavor) {
    1:                 GetTargetDragData(gdkFlavor);
    1:             }
    1:             if (mTargetDragData) {
    1:                 PR_LOG(sDragLm, PR_LOG_DEBUG, ("dataFound = PR_TRUE\n"));
    1:                 dataFound = PR_TRUE;
    1:             }
    1:             else {
    1:                 PR_LOG(sDragLm, PR_LOG_DEBUG, ("dataFound = PR_FALSE\n"));
12780: 
22432:                 // Dragging and dropping from the file manager would cause us 
22432:                 // to parse the source text as a nsILocalFile URL.
12780:                 if ( strcmp(flavorStr, kFileMime) == 0 ) {
12780:                     gdkFlavor = gdk_atom_intern(kTextMime, FALSE);
12780:                     GetTargetDragData(gdkFlavor);
12780:                     if (mTargetDragData) {
12780:                         const char* text = static_cast<char*>(mTargetDragData);
14400:                         PRUnichar* convertedText = nsnull;
14400:                         PRInt32 convertedTextLen = 0;
14400: 
14400:                         GetTextUriListItem(text, mTargetDragDataLen, aItemIndex,
14400:                                            &convertedText, &convertedTextLen);
14400: 
14400:                         if (convertedText) {
22432:                             nsCOMPtr<nsIIOService> ioService = do_GetIOService(&rv);
22432:                             nsCOMPtr<nsIURI> fileURI;
22432:                             nsresult rv = ioService->NewURI(NS_ConvertUTF16toUTF8(convertedText),
22432:                                                             nsnull, nsnull, getter_AddRefs(fileURI));
12780:                             if (NS_SUCCEEDED(rv)) {
22432:                                 nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(fileURI, &rv);
22432:                                 if (NS_SUCCEEDED(rv)) {
22432:                                     nsCOMPtr<nsIFile> file;
22432:                                     rv = fileURL->GetFile(getter_AddRefs(file));
22432:                                     if (NS_SUCCEEDED(rv)) {
22432:                                         // The common wrapping code at the end of 
22432:                                         // this function assumes the data is text
12780:                                         // and calls text-specific operations.
22432:                                         // Make a secret hideout here for nsILocalFile
22432:                                         // objects and return early.
12780:                                         aTransferable->SetTransferData(flavorStr, file,
22432:                                                                        convertedTextLen);
14400:                                         g_free(convertedText);
12780:                                         return NS_OK;
12780:                                     }
22432:                                 }
22432:                             }
14400:                             g_free(convertedText);
14400:                         }
12780:                         continue;
12780:                     }
12780:                 }
12780: 
    1:                 // if we are looking for text/unicode and we fail to find it
    1:                 // on the clipboard first, try again with text/plain. If that
    1:                 // is present, convert it to unicode.
    1:                 if ( strcmp(flavorStr, kUnicodeMime) == 0 ) {
    1:                     PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                            ("we were looking for text/unicode... \
32484:                            trying with text/plain;charset=utf-8\n"));
32484:                     gdkFlavor = gdk_atom_intern(gTextPlainUTF8Type, FALSE);
32484:                     GetTargetDragData(gdkFlavor);
32484:                     if (mTargetDragData) {
32484:                         PR_LOG(sDragLm, PR_LOG_DEBUG, ("Got textplain data\n"));
32484:                         const char* castedText =
32484:                                     reinterpret_cast<char*>(mTargetDragData);
32484:                         PRUnichar* convertedText = nsnull;
32484:                         NS_ConvertUTF8toUTF16 ucs2string(castedText,
32484:                                                          mTargetDragDataLen);
32484:                         convertedText = ToNewUnicode(ucs2string);
32484:                         if ( convertedText ) {
32484:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
32484:                                    ("successfully converted plain text \
32484:                                    to unicode.\n"));
32484:                             // out with the old, in with the new
32484:                             g_free(mTargetDragData);
32484:                             mTargetDragData = convertedText;
32484:                             mTargetDragDataLen = ucs2string.Length() * 2;
32484:                             dataFound = PR_TRUE;
32484:                         } // if plain text data on clipboard
32484:                     } else {
32484:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
32484:                                ("we were looking for text/unicode... \
    1:                                trying again with text/plain\n"));
    1:                         gdkFlavor = gdk_atom_intern(kTextMime, FALSE);
    1:                         GetTargetDragData(gdkFlavor);
    1:                         if (mTargetDragData) {
    1:                             PR_LOG(sDragLm, PR_LOG_DEBUG, ("Got textplain data\n"));
    1:                             const char* castedText =
 3233:                                         reinterpret_cast<char*>(mTargetDragData);
    1:                             PRUnichar* convertedText = nsnull;
    1:                             PRInt32 convertedTextLen = 0;
    1:                             nsPrimitiveHelpers::ConvertPlatformPlainTextToUnicode(
    1:                                                 castedText, mTargetDragDataLen,
    1:                                                 &convertedText, &convertedTextLen);
    1:                             if ( convertedText ) {
    1:                                 PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                        ("successfully converted plain text \
    1:                                        to unicode.\n"));
    1:                                 // out with the old, in with the new
    1:                                 g_free(mTargetDragData);
    1:                                 mTargetDragData = convertedText;
    1:                                 mTargetDragDataLen = convertedTextLen * 2;
    1:                                 dataFound = PR_TRUE;
    1:                             } // if plain text data on clipboard
    1:                         } // if plain text flavor present
32484:                     } // if plain text charset=utf-8 flavor present
    1:                 } // if looking for text/unicode
    1: 
    1:                 // if we are looking for text/x-moz-url and we failed to find
    1:                 // it on the clipboard, try again with text/uri-list, and then
    1:                 // _NETSCAPE_URL
    1:                 if (strcmp(flavorStr, kURLMime) == 0) {
    1:                     PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                            ("we were looking for text/x-moz-url...\
    1:                            trying again with text/uri-list\n"));
    1:                     gdkFlavor = gdk_atom_intern(gTextUriListType, FALSE);
    1:                     GetTargetDragData(gdkFlavor);
    1:                     if (mTargetDragData) {
    1:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                ("Got text/uri-list data\n"));
    1:                         const char *data =
 3233:                                    reinterpret_cast<char*>(mTargetDragData);
    1:                         PRUnichar* convertedText = nsnull;
    1:                         PRInt32 convertedTextLen = 0;
    1: 
    1:                         GetTextUriListItem(data, mTargetDragDataLen, aItemIndex,
    1:                                            &convertedText, &convertedTextLen);
    1: 
    1:                         if ( convertedText ) {
    1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                    ("successfully converted \
    1:                                    _NETSCAPE_URL to unicode.\n"));
    1:                             // out with the old, in with the new
    1:                             g_free(mTargetDragData);
    1:                             mTargetDragData = convertedText;
    1:                             mTargetDragDataLen = convertedTextLen * 2;
    1:                             dataFound = PR_TRUE;
    1:                         }
    1:                     }
    1:                     else {
    1:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                ("failed to get text/uri-list data\n"));
    1:                     }
    1:                     if (!dataFound) {
    1:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                ("we were looking for text/x-moz-url...\
    1:                                trying again with _NETSCAP_URL\n"));
    1:                         gdkFlavor = gdk_atom_intern(gMozUrlType, FALSE);
    1:                         GetTargetDragData(gdkFlavor);
    1:                         if (mTargetDragData) {
    1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                    ("Got _NETSCAPE_URL data\n"));
    1:                             const char* castedText =
 3233:                                   reinterpret_cast<char*>(mTargetDragData);
    1:                             PRUnichar* convertedText = nsnull;
    1:                             PRInt32 convertedTextLen = 0;
    1:                             nsPrimitiveHelpers::ConvertPlatformPlainTextToUnicode(castedText, mTargetDragDataLen, &convertedText, &convertedTextLen);
    1:                             if ( convertedText ) {
    1:                                 PR_LOG(sDragLm,
    1:                                        PR_LOG_DEBUG,
    1:                                        ("successfully converted _NETSCAPE_URL \
    1:                                        to unicode.\n"));
    1:                                 // out with the old, in with the new
    1:                                 g_free(mTargetDragData);
    1:                                 mTargetDragData = convertedText;
    1:                                 mTargetDragDataLen = convertedTextLen * 2;
    1:                                 dataFound = PR_TRUE;
    1:                             }
    1:                         }
    1:                         else {
    1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                    ("failed to get _NETSCAPE_URL data\n"));
    1:                         }
    1:                     }
    1:                 }
    1: 
    1:             } // else we try one last ditch effort to find our data
    1: 
    1:             if (dataFound) {
    1:                 // the DOM only wants LF, so convert from MacOS line endings
    1:                 // to DOM line endings.
    1:                 nsLinebreakHelpers::ConvertPlatformToDOMLinebreaks(
    1:                              flavorStr,
    1:                              &mTargetDragData,
 3233:                              reinterpret_cast<int*>(&mTargetDragDataLen));
    1:         
    1:                 // put it into the transferable.
    1:                 nsCOMPtr<nsISupports> genericDataWrapper;
    1:                 nsPrimitiveHelpers::CreatePrimitiveForData(flavorStr,
    1:                                     mTargetDragData, mTargetDragDataLen,
    1:                                     getter_AddRefs(genericDataWrapper));
    1:                 aTransferable->SetTransferData(flavorStr,
    1:                                                genericDataWrapper,
    1:                                                mTargetDragDataLen);
    1:                 // we found one, get out of this loop!
    1:                 PR_LOG(sDragLm, PR_LOG_DEBUG, ("dataFound and converted!\n"));
    1:                 break;
    1:             }
    1:         } // if (currentFlavor)
    1:     } // foreach flavor
    1: 
    1:     return NS_OK;
    1:   
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::IsDataFlavorSupported(const char *aDataFlavor,
    1:                                      PRBool *_retval)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::IsDataFlavorSupported %s",
    1:                                    aDataFlavor));
    1:     if (!_retval)
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // set this to no by default
    1:     *_retval = PR_FALSE;
    1: 
    1:     // check to make sure that we have a drag object set, here
    1:     if (!mTargetDragContext) {
    1:         PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                ("*** warning: IsDataFlavorSupported \
    1:                called without a valid drag context!\n"));
    1:         return NS_OK;
    1:     }
    1: 
    1:     // check to see if the target context is a list.
    1:     PRBool isList = IsTargetContextList();
    1:     // if it is, just look in the internal data since we are the source
    1:     // for it.
    1:     if (isList) {
    1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("It's a list.."));
    1:         PRUint32 numDragItems = 0;
    1:         // if we don't have mDataItems we didn't start this drag so it's
    1:         // an external client trying to fool us.
    1:         if (!mSourceDataItems)
    1:             return NS_OK;
    1:         mSourceDataItems->Count(&numDragItems);
    1:         for (PRUint32 itemIndex = 0; itemIndex < numDragItems; ++itemIndex) {
    1:             nsCOMPtr<nsISupports> genericItem;
    1:             mSourceDataItems->GetElementAt(itemIndex,
    1:                                            getter_AddRefs(genericItem));
    1:             nsCOMPtr<nsITransferable> currItem(do_QueryInterface(genericItem));
    1:             if (currItem) {
    1:                 nsCOMPtr <nsISupportsArray> flavorList;
    1:                 currItem->FlavorsTransferableCanExport(
    1:                           getter_AddRefs(flavorList));
    1:                 if (flavorList) {
    1:                     PRUint32 numFlavors;
    1:                     flavorList->Count( &numFlavors );
    1:                     for ( PRUint32 flavorIndex = 0;
    1:                           flavorIndex < numFlavors ;
    1:                           ++flavorIndex ) {
    1:                         nsCOMPtr<nsISupports> genericWrapper;
    1:                         flavorList->GetElementAt(flavorIndex,
    1:                                                 getter_AddRefs(genericWrapper));
    1:                         nsCOMPtr<nsISupportsCString> currentFlavor;
    1:                         currentFlavor = do_QueryInterface(genericWrapper);
    1:                         if (currentFlavor) {
    1:                             nsXPIDLCString flavorStr;
    1:                             currentFlavor->ToString(getter_Copies(flavorStr));
    1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                    ("checking %s against %s\n",
    1:                                    (const char *)flavorStr, aDataFlavor));
    1:                             if (strcmp(flavorStr, aDataFlavor) == 0) {
    1:                                 PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                        ("boioioioiooioioioing!\n"));
    1:                                 *_retval = PR_TRUE;
    1:                             }
    1:                         }
    1:                     }
    1:                 }
    1:             }
    1:         }
    1:         return NS_OK;
    1:     }
    1: 
    1:     // check the target context vs. this flavor, one at a time
    1:     GList *tmp;
    1:     for (tmp = mTargetDragContext->targets; tmp; tmp = tmp->next) {
 9859:         /* Bug 331198 */
 9859:         GdkAtom atom = GDK_POINTER_TO_ATOM(tmp->data);
    1:         gchar *name = NULL;
    1:         name = gdk_atom_name(atom);
    1:         PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                ("checking %s against %s\n", name, aDataFlavor));
35220:         if (g_strcmp0(name, aDataFlavor) == 0) {
    1:             PR_LOG(sDragLm, PR_LOG_DEBUG, ("good!\n"));
    1:             *_retval = PR_TRUE;
    1:         }
    1:         // check for automatic text/uri-list -> text/x-moz-url mapping
    1:         if (*_retval == PR_FALSE && 
35220:             (g_strcmp0(name, gTextUriListType) == 0) &&
35220:             (g_strcmp0(aDataFlavor, kURLMime) == 0)) {
    1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                    ("good! ( it's text/uri-list and \
    1:                    we're checking against text/x-moz-url )\n"));
    1:             *_retval = PR_TRUE;
    1:         }
    1:         // check for automatic _NETSCAPE_URL -> text/x-moz-url mapping
    1:         if (*_retval == PR_FALSE && 
35220:             (g_strcmp0(name, gMozUrlType) == 0) &&
35220:             (g_strcmp0(aDataFlavor, kURLMime) == 0)) {
    1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                    ("good! ( it's _NETSCAPE_URL and \
    1:                    we're checking against text/x-moz-url )\n"));
    1:             *_retval = PR_TRUE;
    1:         }
    1:         // check for auto text/plain -> text/unicode mapping
    1:         if (*_retval == PR_FALSE && 
35220:             (g_strcmp0(name, kTextMime) == 0) &&
35220:             ((g_strcmp0(aDataFlavor, kUnicodeMime) == 0) ||
35220:              (g_strcmp0(aDataFlavor, kFileMime) == 0))) {
    1:             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                    ("good! ( it's text plain and we're checking \
12780:                    against text/unicode or application/x-moz-file)\n"));
    1:             *_retval = PR_TRUE;
    1:         }
    1:         g_free(name);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: // nsIDragSessionGTK
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::TargetSetLastContext(GtkWidget      *aWidget,
    1:                                     GdkDragContext *aContext,
    1:                                     guint           aTime)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::TargetSetLastContext"));
    1:     mTargetWidget = aWidget;
    1:     mTargetDragContext = aContext;
    1:     mTargetTime = aTime;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::TargetStartDragMotion(void)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::TargetStartDragMotion"));
    1:     mCanDrop = PR_FALSE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::TargetEndDragMotion(GtkWidget      *aWidget,
    1:                                    GdkDragContext *aContext,
    1:                                    guint           aTime)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:            ("nsDragService::TargetEndDragMotion %d", mCanDrop));
    1: 
    1:     if (mCanDrop) {
    1:         GdkDragAction action;
    1:         // notify the dragger if we can drop
    1:         switch (mDragAction) {
    1:         case DRAGDROP_ACTION_COPY:
    1:           action = GDK_ACTION_COPY;
    1:           break;
    1:         case DRAGDROP_ACTION_LINK:
    1:           action = GDK_ACTION_LINK;
    1:           break;
    1:         default:
    1:           action = GDK_ACTION_MOVE;
    1:           break;
    1:         }
    1:         gdk_drag_status(aContext, action, aTime);
    1:     }
    1:     else {
    1:         gdk_drag_status(aContext, (GdkDragAction)0, aTime);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::TargetDataReceived(GtkWidget         *aWidget,
    1:                                   GdkDragContext    *aContext,
    1:                                   gint               aX,
    1:                                   gint               aY,
    1:                                   GtkSelectionData  *aSelectionData,
    1:                                   guint              aInfo,
    1:                                   guint32            aTime)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::TargetDataReceived"));
    1:     TargetResetData();
    1:     mTargetDragDataReceived = PR_TRUE;
    1:     if (aSelectionData->length > 0) {
    1:         mTargetDragDataLen = aSelectionData->length;
    1:         mTargetDragData = g_malloc(mTargetDragDataLen);
    1:         memcpy(mTargetDragData, aSelectionData->data, mTargetDragDataLen);
    1:     }
    1:     else {
    1:         PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                ("Failed to get data.  selection data len was %d\n",
    1:                 aSelectionData->length));
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDragService::TargetSetTimeCallback(nsIDragSessionGTKTimeCB aCallback)
    1: {
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsDragService::IsTargetContextList(void)
    1: {
    1:     PRBool retval = PR_FALSE;
    1: 
    1:     if (!mTargetDragContext)
    1:         return retval;
    1: 
    1:     // gMimeListType drags only work for drags within a single process.
    1:     // The gtk_drag_get_source_widget() function will return NULL if the
    1:     // source of the drag is another app, so we use it to check if a
    1:     // gMimeListType drop will work or not.
    1:     if (gtk_drag_get_source_widget(mTargetDragContext) == NULL)
    1:         return retval;
    1: 
    1:     GList *tmp;
    1: 
    1:     // walk the list of context targets and see if one of them is a list
    1:     // of items.
    1:     for (tmp = mTargetDragContext->targets; tmp; tmp = tmp->next) {
 9859:         /* Bug 331198 */
 9859:         GdkAtom atom = GDK_POINTER_TO_ATOM(tmp->data);
    1:         gchar *name = NULL;
    1:         name = gdk_atom_name(atom);
35220:         if (g_strcmp0(name, gMimeListType) == 0)
    1:             retval = PR_TRUE;
    1:         g_free(name);
    1:         if (retval)
    1:             break;
    1:     }
    1:     return retval;
    1: }
    1: 
    1: // Maximum time to wait for a "drag_received" arrived, in microseconds
    1: #define NS_DND_TIMEOUT 500000
    1: 
    1: void
    1: nsDragService::GetTargetDragData(GdkAtom aFlavor)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("getting data flavor %d\n", aFlavor));
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("mLastWidget is %p and mLastContext is %p\n",
    1:                                    mTargetWidget, mTargetDragContext));
    1:     // reset our target data areas
    1:     TargetResetData();
    1:     gtk_drag_get_data(mTargetWidget, mTargetDragContext, aFlavor, mTargetTime);
    1:     
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("about to start inner iteration."));
    1:     PRTime entryTime = PR_Now();
    1:     while (!mTargetDragDataReceived && mDoingDrag) {
    1:         // check the number of iterations
    1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("doing iteration...\n"));
    1:         PR_Sleep(20*PR_TicksPerSecond()/1000);  /* sleep for 20 ms/iteration */
    1:         if (PR_Now()-entryTime > NS_DND_TIMEOUT) break;
    1:         gtk_main_iteration();
    1:     }
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("finished inner iteration\n"));
    1: }
    1: 
    1: void
    1: nsDragService::TargetResetData(void)
    1: {
    1:     mTargetDragDataReceived = PR_FALSE;
    1:     // make sure to free old data if we have to
    1:     if (mTargetDragData)
    1:       g_free(mTargetDragData);
    1:     mTargetDragData = 0;
    1:     mTargetDragDataLen = 0;
    1: }
    1: 
    1: GtkTargetList *
    1: nsDragService::GetSourceList(void)
    1: {
    1:     if (!mSourceDataItems)
    1:         return NULL;
25381:     nsTArray<GtkTargetEntry*> targetArray;
    1:     GtkTargetEntry *targets;
    1:     GtkTargetList  *targetList = 0;
    1:     PRUint32 targetCount = 0;
    1:     unsigned int numDragItems = 0;
    1: 
    1:     mSourceDataItems->Count(&numDragItems);
    1: 
    1:     // Check to see if we're dragging > 1 item.
    1:     if (numDragItems > 1) {
    1:         // as the Xdnd protocol only supports a single item (or is it just
    1:         // gtk's implementation?), we don't advertise all flavours listed
    1:         // in the nsITransferable.
    1: 
    1:         // the application/x-moz-internal-item-list format, which preserves
    1:         // all information for drags within the same mozilla instance.
    1:         GdkAtom listAtom = gdk_atom_intern(gMimeListType, FALSE);
    1:         GtkTargetEntry *listTarget =
    1:             (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
    1:         listTarget->target = g_strdup(gMimeListType);
    1:         listTarget->flags = 0;
 9859:         /* Bug 331198 */
 9859:         listTarget->info = NS_PTR_TO_UINT32(listAtom);
    1:         PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                ("automatically adding target %s with id %ld\n",
    1:                listTarget->target, listAtom));
    1:         targetArray.AppendElement(listTarget);
    1: 
    1:         // check what flavours are supported so we can decide what other
    1:         // targets to advertise.
    1:         nsCOMPtr<nsISupports> genericItem;
    1:         mSourceDataItems->GetElementAt(0, getter_AddRefs(genericItem));
    1:         nsCOMPtr<nsITransferable> currItem(do_QueryInterface(genericItem));
    1: 
    1:         if (currItem) {
    1:             nsCOMPtr <nsISupportsArray> flavorList;
    1:             currItem->FlavorsTransferableCanExport(getter_AddRefs(flavorList));
    1:             if (flavorList) {
    1:                 PRUint32 numFlavors;
    1:                 flavorList->Count( &numFlavors );
    1:                 for (PRUint32 flavorIndex = 0;
    1:                      flavorIndex < numFlavors ;
    1:                      ++flavorIndex ) {
    1:                     nsCOMPtr<nsISupports> genericWrapper;
    1:                     flavorList->GetElementAt(flavorIndex,
    1:                                            getter_AddRefs(genericWrapper));
    1:                     nsCOMPtr<nsISupportsCString> currentFlavor;
    1:                     currentFlavor = do_QueryInterface(genericWrapper);
    1:                     if (currentFlavor) {
    1:                         nsXPIDLCString flavorStr;
    1:                         currentFlavor->ToString(getter_Copies(flavorStr));
    1: 
    1:                         // check if text/x-moz-url is supported.
    1:                         // If so, advertise
    1:                         // text/uri-list.
    1:                         if (strcmp(flavorStr, kURLMime) == 0) {
    1:                             listAtom = gdk_atom_intern(gTextUriListType, FALSE);
    1:                             listTarget =
    1:                              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
    1:                             listTarget->target = g_strdup(gTextUriListType);
    1:                             listTarget->flags = 0;
 9859:                             /* Bug 331198 */
 9859:                             listTarget->info = NS_PTR_TO_UINT32(listAtom);
    1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                    ("automatically adding target %s with \
    1:                                    id %ld\n", listTarget->target, listAtom));
    1:                             targetArray.AppendElement(listTarget);
    1:                         }
    1:                     }
    1:                 } // foreach flavor in item
    1:             } // if valid flavor list
    1:         } // if item is a transferable
    1:     } else if (numDragItems == 1) {
    1:         nsCOMPtr<nsISupports> genericItem;
    1:         mSourceDataItems->GetElementAt(0, getter_AddRefs(genericItem));
    1:         nsCOMPtr<nsITransferable> currItem(do_QueryInterface(genericItem));
    1:         if (currItem) {
    1:             nsCOMPtr <nsISupportsArray> flavorList;
    1:             currItem->FlavorsTransferableCanExport(getter_AddRefs(flavorList));
    1:             if (flavorList) {
    1:                 PRUint32 numFlavors;
    1:                 flavorList->Count( &numFlavors );
    1:                 for (PRUint32 flavorIndex = 0;
    1:                      flavorIndex < numFlavors ;
    1:                      ++flavorIndex ) {
    1:                     nsCOMPtr<nsISupports> genericWrapper;
    1:                     flavorList->GetElementAt(flavorIndex,
    1:                                              getter_AddRefs(genericWrapper));
    1:                     nsCOMPtr<nsISupportsCString> currentFlavor;
    1:                     currentFlavor = do_QueryInterface(genericWrapper);
    1:                     if (currentFlavor) {
    1:                         nsXPIDLCString flavorStr;
    1:                         currentFlavor->ToString(getter_Copies(flavorStr));
    1:                         // get the atom
    1:                         GdkAtom atom = gdk_atom_intern(flavorStr, FALSE);
    1:                         GtkTargetEntry *target =
    1:                           (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
    1:                         target->target = g_strdup(flavorStr);
    1:                         target->flags = 0;
 9859:                         /* Bug 331198 */
 9859:                         target->info = NS_PTR_TO_UINT32(atom);
    1:                         PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                ("adding target %s with id %ld\n",
    1:                                target->target, atom));
    1:                         targetArray.AppendElement(target);
    1:                         // Check to see if this is text/unicode.
    1:                         // If it is, add text/plain
    1:                         // since we automatically support text/plain
    1:                         // if we support text/unicode.
    1:                         if (strcmp(flavorStr, kUnicodeMime) == 0) {
    1:                             // get the atom for the unicode string
32484:                             GdkAtom plainUTF8Atom =
32484:                               gdk_atom_intern(gTextPlainUTF8Type, FALSE);
32484:                             GtkTargetEntry *plainUTF8Target =
32484:                              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
32484:                             plainUTF8Target->target = g_strdup(gTextPlainUTF8Type);
32484:                             plainUTF8Target->flags = 0;
32484:                             /* Bug 331198 */
32484:                             plainUTF8Target->info = NS_PTR_TO_UINT32(plainUTF8Atom);
32484:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
32484:                                    ("automatically adding target %s with \
32484:                                    id %ld\n", plainUTF8Target->target, plainUTF8Atom));
32484:                             targetArray.AppendElement(plainUTF8Target);
32484: 
32484:                             // get the atom for the ASCII string
    1:                             GdkAtom plainAtom =
    1:                               gdk_atom_intern(kTextMime, FALSE);
    1:                             GtkTargetEntry *plainTarget =
    1:                              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
    1:                             plainTarget->target = g_strdup(kTextMime);
    1:                             plainTarget->flags = 0;
 9859:                             /* Bug 331198 */
 9859:                             plainTarget->info = NS_PTR_TO_UINT32(plainAtom);
    1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                    ("automatically adding target %s with \
    1:                                    id %ld\n", plainTarget->target, plainAtom));
    1:                             targetArray.AppendElement(plainTarget);
    1:                         }
    1:                         // Check to see if this is the x-moz-url type.
    1:                         // If it is, add _NETSCAPE_URL
    1:                         // this is a type used by everybody.
    1:                         if (strcmp(flavorStr, kURLMime) == 0) {
    1:                             // get the atom name for it
    1:                             GdkAtom urlAtom =
    1:                              gdk_atom_intern(gMozUrlType, FALSE);
    1:                             GtkTargetEntry *urlTarget =
    1:                              (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry));
    1:                             urlTarget->target = g_strdup(gMozUrlType);
    1:                             urlTarget->flags = 0;
 9859:                             /* Bug 331198 */
 9859:                             urlTarget->info = NS_PTR_TO_UINT32(urlAtom);
    1:                             PR_LOG(sDragLm, PR_LOG_DEBUG,
    1:                                    ("automatically adding target %s with \
    1:                                    id %ld\n", urlTarget->target, urlAtom));
    1:                             targetArray.AppendElement(urlTarget);
    1:                         }
    1:                     }
    1:                 } // foreach flavor in item
    1:             } // if valid flavor list
    1:         } // if item is a transferable
    1:     } // if it is a single item drag
    1: 
    1:     // get all the elements that we created.
25381:     targetCount = targetArray.Length();
    1:     if (targetCount) {
    1:         // allocate space to create the list of valid targets
    1:         targets =
    1:           (GtkTargetEntry *)g_malloc(sizeof(GtkTargetEntry) * targetCount);
    1:         PRUint32 targetIndex;
    1:         for ( targetIndex = 0; targetIndex < targetCount; ++targetIndex) {
25381:             GtkTargetEntry *disEntry = targetArray.ElementAt(targetIndex);
    1:             // this is a string reference but it will be freed later.
    1:             targets[targetIndex].target = disEntry->target;
    1:             targets[targetIndex].flags = disEntry->flags;
    1:             targets[targetIndex].info = disEntry->info;
    1:         }
    1:         targetList = gtk_target_list_new(targets, targetCount);
    1:         // clean up the target list
    1:         for (PRUint32 cleanIndex = 0; cleanIndex < targetCount; ++cleanIndex) {
25381:             GtkTargetEntry *thisTarget = targetArray.ElementAt(cleanIndex);
    1:             g_free(thisTarget->target);
    1:             g_free(thisTarget);
    1:         }
    1:         g_free(targets);
    1:     }
    1:     return targetList;
    1: }
    1: 
    1: void
29409: nsDragService::SourceEndDragSession(GdkDragContext *aContext,
29409:                                     gint            aResult)
    1: {
    1:     // this just releases the list of data items that we provide
29217:     mSourceDataItems = nsnull;
29217: 
29217:     if (!mDoingDrag)
29409:         return; // EndDragSession() was already called on drop or drag-failed
29409: 
29409:     gint x, y;
29409:     GdkDisplay* display = gdk_display_get_default();
29409:     if (display) {
29409:       gdk_display_get_pointer(display, NULL, &x, &y, NULL);
29409:       SetDragEndPoint(nsIntPoint(x, y));
29409:     }
29217: 
29217:     // Either the drag was aborted or the drop occurred outside the app.
29217:     // The dropEffect of mDataTransfer is not updated for motion outside the
29217:     // app, but is needed for the dragend event, so set it now.
29217: 
29409:     PRUint32 dropEffect;
29409: 
29409:     if (aResult == MOZ_GTK_DRAG_RESULT_SUCCESS) {
29409: 
29409:         // With GTK+ versions 2.10.x and prior the drag may have been
29409:         // cancelled (but no drag-failed signal would have been sent).
29409:         // aContext->dest_window will be non-NULL only if the drop was sent.
29217:         GdkDragAction action =
29217:             aContext->dest_window ? aContext->action : (GdkDragAction)0;
29217: 
29409:         // Only one bit of action should be set, but, just in case someone
29409:         // does something funny, erring away from MOVE, and not recording
29409:         // unusual action combinations as NONE.
29217:         if (!action)
29217:             dropEffect = DRAGDROP_ACTION_NONE;
29217:         else if (action & GDK_ACTION_COPY)
29217:             dropEffect = DRAGDROP_ACTION_COPY;
29217:         else if (action & GDK_ACTION_LINK)
29217:             dropEffect = DRAGDROP_ACTION_LINK;
29217:         else if (action & GDK_ACTION_MOVE)
29217:             dropEffect = DRAGDROP_ACTION_MOVE;
29217:         else
29217:             dropEffect = DRAGDROP_ACTION_COPY;
29217: 
29409:     } else {
29409: 
29409:         dropEffect = DRAGDROP_ACTION_NONE;
29409: 
29409:         if (aResult != MOZ_GTK_DRAG_RESULT_NO_TARGET) {
29409:             mUserCancelled = PR_TRUE;
29409:         }
29409:     }
29409: 
29217:     nsCOMPtr<nsIDOMNSDataTransfer> dataTransfer =
29217:         do_QueryInterface(mDataTransfer);
29217: 
29217:     if (dataTransfer) {
29217:         dataTransfer->SetDropEffectInt(dropEffect);
29217:     }
    1: 
    1:     // Inform the drag session that we're ending the drag.
  482:     EndDragSession(PR_TRUE);
    1: }
    1: 
    1: static void
    1: CreateUriList(nsISupportsArray *items, gchar **text, gint *length)
    1: {
    1:     PRUint32 i, count;
    1:     GString *uriList = g_string_new(NULL);
    1: 
    1:     items->Count(&count);
    1:     for (i = 0; i < count; i++) {
    1:         nsCOMPtr<nsISupports> genericItem;
    1:         items->GetElementAt(i, getter_AddRefs(genericItem));
    1:         nsCOMPtr<nsITransferable> item;
    1:         item = do_QueryInterface(genericItem);
    1: 
    1:         if (item) {
    1:             PRUint32 tmpDataLen = 0;
    1:             void    *tmpData = NULL;
    1:             nsresult rv = 0;
    1:             nsCOMPtr<nsISupports> data;
    1:             rv = item->GetTransferData(kURLMime,
    1:                                        getter_AddRefs(data),
    1:                                        &tmpDataLen);
    1: 
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 nsPrimitiveHelpers::CreateDataFromPrimitive(kURLMime,
    1:                                                             data,
    1:                                                             &tmpData,
    1:                                                             tmpDataLen);
    1:                 char* plainTextData = nsnull;
 3233:                 PRUnichar* castedUnicode = reinterpret_cast<PRUnichar*>
 3233:                                                            (tmpData);
    1:                 PRInt32 plainTextLen = 0;
    1:                 nsPrimitiveHelpers::ConvertUnicodeToPlatformPlainText(
    1:                                     castedUnicode,
    1:                                     tmpDataLen / 2,
    1:                                     &plainTextData,
    1:                                     &plainTextLen);
    1:                 if (plainTextData) {
    1:                     PRInt32 j;
    1: 
    1:                     // text/x-moz-url is of form url + "\n" + title.
    1:                     // We just want the url.
    1:                     for (j = 0; j < plainTextLen; j++)
    1:                         if (plainTextData[j] == '\n' ||
    1:                             plainTextData[j] == '\r') {
    1:                             plainTextData[j] = '\0';
    1:                             break;
    1:                         }
    1:                     g_string_append(uriList, plainTextData);
    1:                     g_string_append(uriList, "\r\n");
    1:                     // this wasn't allocated with glib
    1:                     free(plainTextData);
    1:                 }
    1:                 if (tmpData) {
    1:                     // this wasn't allocated with glib
    1:                     free(tmpData);
    1:                 }
    1:             }
    1:         }
    1:     }
    1:     *text = uriList->str;
    1:     *length = uriList->len + 1;
    1:     g_string_free(uriList, FALSE); // don't free the data
    1: }
    1: 
    1: 
    1: void
    1: nsDragService::SourceDataGet(GtkWidget        *aWidget,
    1:                              GdkDragContext   *aContext,
    1:                              GtkSelectionData *aSelectionData,
    1:                              guint             aInfo,
    1:                              guint32           aTime)
    1: {
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("nsDragService::SourceDataGet"));
    1:     GdkAtom atom = (GdkAtom)aInfo;
    1:     nsXPIDLCString mimeFlavor;
    1:     gchar *typeName = 0;
    1:     typeName = gdk_atom_name(atom);
    1:     if (!typeName) {
    1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("failed to get atom name.\n"));
    1:         return;
    1:     }
    1: 
    1:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("Type is %s\n", typeName));
    1:     // make a copy since |nsXPIDLCString| won't use |g_free|...
    1:     mimeFlavor.Adopt(nsCRT::strdup(typeName));
    1:     g_free(typeName);
    1:     // check to make sure that we have data items to return.
    1:     if (!mSourceDataItems) {
    1:         PR_LOG(sDragLm, PR_LOG_DEBUG, ("Failed to get our data items\n"));
    1:         return;
    1:     }
    1: 
    1:     nsCOMPtr<nsISupports> genericItem;
    1:     mSourceDataItems->GetElementAt(0, getter_AddRefs(genericItem));
    1:     nsCOMPtr<nsITransferable> item;
    1:     item = do_QueryInterface(genericItem);
    1:     if (item) {
    1:         // if someone was asking for text/plain, lookup unicode instead so
    1:         // we can convert it.
    1:         PRBool needToDoConversionToPlainText = PR_FALSE;
    1:         const char* actualFlavor = mimeFlavor;
32484:         if (strcmp(mimeFlavor, kTextMime) == 0 ||
32484:             strcmp(mimeFlavor, gTextPlainUTF8Type) == 0) {
    1:             actualFlavor = kUnicodeMime;
    1:             needToDoConversionToPlainText = PR_TRUE;
    1:         }
    1:         // if someone was asking for _NETSCAPE_URL we need to convert to
    1:         // plain text but we also need to look for x-moz-url
    1:         else if (strcmp(mimeFlavor, gMozUrlType) == 0) {
    1:             actualFlavor = kURLMime;
    1:             needToDoConversionToPlainText = PR_TRUE;
    1:         }
  468:         // if someone was asking for text/uri-list we need to convert to
  468:         // plain text.
  468:         else if (strcmp(mimeFlavor, gTextUriListType) == 0) {
  468:             actualFlavor = gTextUriListType;
  468:             needToDoConversionToPlainText = PR_TRUE;
  468:         }
    1:         else
    1:             actualFlavor = mimeFlavor;
    1: 
    1:         PRUint32 tmpDataLen = 0;
    1:         void    *tmpData = NULL;
    1:         nsresult rv;
    1:         nsCOMPtr<nsISupports> data;
    1:         rv = item->GetTransferData(actualFlavor,
    1:                                    getter_AddRefs(data),
    1:                                    &tmpDataLen);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             nsPrimitiveHelpers::CreateDataFromPrimitive (actualFlavor, data,
    1:                                                          &tmpData, tmpDataLen);
    1:             // if required, do the extra work to convert unicode to plain
    1:             // text and replace the output values with the plain text.
    1:             if (needToDoConversionToPlainText) {
    1:                 char* plainTextData = nsnull;
 3233:                 PRUnichar* castedUnicode = reinterpret_cast<PRUnichar*>
 3233:                                                            (tmpData);
    1:                 PRInt32 plainTextLen = 0;
32484:                 if (strcmp(mimeFlavor, gTextPlainUTF8Type) == 0) {
32484:                     plainTextData =
32484:                         ToNewUTF8String(
32484:                             nsDependentString(castedUnicode, tmpDataLen / 2),
32484:                             (PRUint32*)&plainTextLen);
32484:                 } else {
    1:                     nsPrimitiveHelpers::ConvertUnicodeToPlatformPlainText(
    1:                                         castedUnicode,
    1:                                         tmpDataLen / 2,
    1:                                         &plainTextData,
    1:                                         &plainTextLen);
32484:                 }
    1:                 if (tmpData) {
    1:                     // this was not allocated using glib
    1:                     free(tmpData);
    1:                     tmpData = plainTextData;
    1:                     tmpDataLen = plainTextLen;
    1:                 }
    1:             }
    1:             if (tmpData) {
    1:                 // this copies the data
    1:                 gtk_selection_data_set(aSelectionData,
    1:                                        aSelectionData->target,
    1:                                        8,
    1:                                        (guchar *)tmpData, tmpDataLen);
    1:                 // this wasn't allocated with glib
    1:                 free(tmpData);
    1:             }
  468:         } else {
  468:             if (strcmp(mimeFlavor, gTextUriListType) == 0) {
  468:                 // fall back for text/uri-list
  468:                 gchar *uriList;
  468:                 gint length;
  468:                 CreateUriList(mSourceDataItems, &uriList, &length);
  468:                 gtk_selection_data_set(aSelectionData,
  468:                                        aSelectionData->target,
  468:                                        8, (guchar *)uriList, length);
  468:                 g_free(uriList);
  468:                 return;
  468:             }
    1:         }
    1:     }
    1: }
    1: 
    1: /* static */
    1: void
    1: invisibleSourceDragDataGet(GtkWidget        *aWidget,
    1:                            GdkDragContext   *aContext,
    1:                            GtkSelectionData *aSelectionData,
    1:                            guint             aInfo,
    1:                            guint32           aTime,
    1:                            gpointer          aData)
    1: {
29217:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("invisibleSourceDragDataGet"));
    1:     nsDragService *dragService = (nsDragService *)aData;
    1:     dragService->SourceDataGet(aWidget, aContext,
    1:                                aSelectionData, aInfo, aTime);
    1: }
    1: 
    1: /* static */
29409: gboolean
29409: invisibleSourceDragFailed(GtkWidget        *aWidget,
29409:                           GdkDragContext   *aContext,
29409:                           gint              aResult,
29409:                           gpointer          aData)
29409: {
29409:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("invisibleSourceDragFailed %i", aResult));
29409:     nsDragService *dragService = (nsDragService *)aData;
29409:     // End the drag session now (rather than waiting for the drag-end signal)
29409:     // so that operations performed on dropEffect == none can start immediately
29409:     // rather than waiting for the drag-failed animation to finish.
29409:     dragService->SourceEndDragSession(aContext, aResult);
29409: 
29409:     // We should return TRUE to disable the drag-failed animation iff the
29409:     // source performed an operation when dropEffect was none, but the handler
29409:     // of the dragend DOM event doesn't provide this information.
29409:     return FALSE;
29409: }
29409: 
29409: /* static */
    1: void
    1: invisibleSourceDragEnd(GtkWidget        *aWidget,
    1:                        GdkDragContext   *aContext,
    1:                        gpointer          aData)
    1: {
29217:     PR_LOG(sDragLm, PR_LOG_DEBUG, ("invisibleSourceDragEnd"));
    1:     nsDragService *dragService = (nsDragService *)aData;
27401: 
29409:     // The drag has ended.  Release the hostages!
29409:     dragService->SourceEndDragSession(aContext, MOZ_GTK_DRAG_RESULT_SUCCESS);
27401: }
27401: 
