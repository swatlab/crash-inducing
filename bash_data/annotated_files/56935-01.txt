    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim:set tw=80 expandtab softtabstop=2 ts=2 sw=2: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nscore.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIAtom.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsICSSStyleRule.h"
    1: #include "nsCSSStruct.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDocumentEncoder.h"
    1: #include "nsIDOMHTMLBodyElement.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMDocumentFragment.h"
    1: #include "nsIDOMNSHTMLDocument.h"
    1: #include "nsIDOMNSHTMLElement.h"
    1: #include "nsIDOMElementCSSInlineStyle.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsMappedAttributes.h"
    1: #include "nsHTMLStyleSheet.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsILink.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIStyleRule.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsEscape.h"
    1: #include "nsIFrame.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsRange.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIDocShell.h"
29018: #include "nsIDocShellTreeItem.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsDOMError.h"
    1: #include "nsScriptLoader.h"
    1: #include "nsRuleData.h"
    1: 
    1: #include "nsPresState.h"
    1: #include "nsILayoutHistoryState.h"
    1: 
    1: #include "nsHTMLParts.h"
    1: #include "nsContentUtils.h"
    1: #include "nsString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsDOMCSSDeclaration.h"
    1: #include "nsITextControlFrame.h"
    1: #include "nsIForm.h"
    1: #include "nsIFormControl.h"
    1: #include "nsIDOMHTMLFormElement.h"
34395: #include "nsHTMLFormElement.h"
29018: #include "nsFocusManager.h"
    1: 
    1: #include "nsMutationEvent.h"
    1: 
    1: #include "nsContentCID.h"
    1: 
    1: #include "nsIDOMText.h"
    1: 
    1: #include "nsIEditor.h"
    1: #include "nsIEditorIMESupport.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsContentCreatorFunctions.h"
14228: #include "mozAutoDocUpdate.h"
41754: #include "nsHtml5Module.h"
43129: #include "nsITextControlElement.h"
47801: #include "mozilla/dom/Element.h"
54346: #include "nsHTMLFieldSetElement.h"
47801: 
47801: using namespace mozilla::dom;
    1: 
42460: #include "nsThreadUtils.h"
42460: 
    1: class nsINodeInfo;
    1: class nsIDOMNodeList;
    1: class nsRuleWalker;
    1: 
    1: // XXX todo: add in missing out-of-memory checks
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: #ifdef GATHER_ELEMENT_USEAGE_STATISTICS
    1: 
    1: // static objects that have constructors are kinda bad, but we don't
    1: // care here, this is only debugging code!
    1: 
    1: static nsHashtable sGEUS_ElementCounts;
    1: 
    1: void GEUS_ElementCreated(nsINodeInfo *aNodeInfo)
    1: {
    1:   nsAutoString name;
    1:   aNodeInfo->GetLocalName(name);
    1: 
    1:   nsStringKey key(name);
    1: 
    1:   PRInt32 count = (PRInt32)sGEUS_ElementCounts.Get(&key);
    1: 
    1:   count++;
    1: 
    1:   sGEUS_ElementCounts.Put(&key, (void *)count);
    1: }
    1: 
    1: PRBool GEUS_enum_func(nsHashKey *aKey, void *aData, void *aClosure)
    1: {
    1:   const PRUnichar *name_chars = ((nsStringKey *)aKey)->GetString();
    1:   NS_ConvertUTF16toUTF8 name(name_chars);
    1: 
    1:   printf ("%s %d\n", name.get(), aData);
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void GEUS_DumpElementCounts()
    1: {
    1:   printf ("Element count statistics:\n");
    1: 
    1:   sGEUS_ElementCounts.Enumerate(GEUS_enum_func, nsnull);
    1: 
    1:   printf ("End of element count statistics:\n");
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::Init(nsINodeInfo *aNodeInfo)
    1: {
    1:   GEUS_ElementCreated(aNodeInfo);
    1: 
 4306:   return nsGenericHTMLElementBase::Init(aNodeInfo);
    1: }
    1: 
    1: #endif
    1: 
42460: /**
42460:  * nsAutoFocusEvent is used to dispatch a focus event when a
42460:  * nsGenericHTMLFormElement is binded to the tree with the autofocus attribute
42460:  * enabled.
42460:  */
42460: class nsAutoFocusEvent : public nsRunnable
42460: {
42460: public:
42460:   nsAutoFocusEvent(nsGenericHTMLFormElement* aElement) : mElement(aElement) {}
42460: 
42460:   NS_IMETHOD Run() {
42460:     nsFocusManager* fm = nsFocusManager::GetFocusManager();
42460:     if (!fm) {
42460:       return NS_ERROR_NULL_POINTER;
42460:     }
42460: 
42460:     nsIDocument* document = mElement->GetOwnerDoc();
42460:     if (!document) {
42460:       return NS_OK;
42460:     }
42460: 
42460:     // Do not autofocus if an sub-window is focused.
42460:     nsPIDOMWindow* window = document->GetWindow();
42460:     if (window && window->GetFocusedNode()) {
42460:       return NS_OK;
42460:     }
42460: 
42460:     // If something is focused in the same document, ignore autofocus.
42460:     if (!fm->GetFocusedContent() ||
42460:         fm->GetFocusedContent()->GetOwnerDoc() != document) {
42460:       return mElement->Focus();
42460:     }
42460: 
42460:     return NS_OK;
42460:   }
42460: private:
42460:   // NOTE: nsGenericHTMLFormElement is saved as a nsGenericHTMLElement
42460:   // because AddRef/Release are ambiguous with nsGenericHTMLFormElement
42460:   // and Focus() is declared (and defined) in nsGenericHTMLElement class.
42460:   nsRefPtr<nsGenericHTMLElement> mElement;
42460: };
    1: 
12033: class nsGenericHTMLElementTearoff : public nsIDOMNSHTMLElement,
12033:                                     public nsIDOMElementCSSInlineStyle
12033: {
12033:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
12033: 
12033:   nsGenericHTMLElementTearoff(nsGenericHTMLElement *aElement)
12033:     : mElement(aElement)
12033:   {
12033:   }
12033: 
12033:   virtual ~nsGenericHTMLElementTearoff()
12033:   {
12033:   }
12033: 
12033:   NS_FORWARD_NSIDOMNSHTMLELEMENT(mElement->)
48944:   NS_IMETHOD GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
48944:   {
48944:     nsresult rv;
48944:     *aStyle = mElement->GetStyle(&rv);
48944:     NS_ENSURE_SUCCESS(rv, rv);
48944:     NS_ADDREF(*aStyle);
48944:     return NS_OK;
48944:   }
12033: 
12033:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsGenericHTMLElementTearoff,
12033:                                            nsIDOMNSHTMLElement)
12033: 
12033: private:
48449:   nsRefPtr<nsGenericHTMLElement> mElement;
12033: };
12033: 
    1: NS_IMPL_CYCLE_COLLECTION_1(nsGenericHTMLElementTearoff, mElement)
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsGenericHTMLElementTearoff,
    1:                                           nsIDOMNSHTMLElement)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsGenericHTMLElementTearoff,
    1:                                            nsIDOMNSHTMLElement)
    1: 
 4838: NS_INTERFACE_TABLE_HEAD(nsGenericHTMLElementTearoff)
 4838:   NS_INTERFACE_TABLE_INHERITED2(nsGenericHTMLElementTearoff,
 4838:                                 nsIDOMNSHTMLElement,
 4838:                                 nsIDOMElementCSSInlineStyle)
 4838:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsGenericHTMLElementTearoff)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mElement)
    1: 
    1: 
56074: NS_IMPL_INT_ATTR_DEFAULT_VALUE(nsGenericHTMLElement, TabIndex, tabindex, -1)
48696: NS_IMPL_BOOL_ATTR(nsGenericHTMLElement, Hidden, hidden)
    1: 
    1: nsresult
    1: nsGenericHTMLElement::DOMQueryInterface(nsIDOMHTMLElement *aElement,
    1:                                         REFNSIID aIID, void **aInstancePtr)
    1: {
 3114:   NS_PRECONDITION(aInstancePtr, "null out param");
 3114: 
 4838:   nsresult rv = NS_ERROR_FAILURE;
 4838: 
 4838:   NS_INTERFACE_TABLE_BEGIN
 4838:     NS_INTERFACE_TABLE_ENTRY(nsIDOMHTMLElement, nsIDOMNode)
 4838:     NS_INTERFACE_TABLE_ENTRY(nsIDOMHTMLElement, nsIDOMElement)
 4838:     NS_INTERFACE_TABLE_ENTRY(nsIDOMHTMLElement, nsIDOMHTMLElement)
 4838:   NS_INTERFACE_TABLE_END_WITH_PTR(aElement)
 4838: 
 4838:   NS_INTERFACE_TABLE_TO_MAP_SEGUE
 4838:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNSHTMLElement,
 4838:                                  new nsGenericHTMLElementTearoff(this))
 4838:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMElementCSSInlineStyle,
 4838:                                  new nsGenericHTMLElementTearoff(this))
 4838:   NS_INTERFACE_MAP_END
 4838: 
48696: // No closing bracket, because NS_INTERFACE_MAP_END does that for us.
    1:     
    1: nsresult
    1: nsGenericHTMLElement::CopyInnerTo(nsGenericElement* aDst) const
    1: {
    1:   nsresult rv;
    1:   PRInt32 i, count = GetAttrCount();
    1:   for (i = 0; i < count; ++i) {
    1:     const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
    1:     const nsAttrValue *value = mAttrsAndChildren.AttrAt(i);
    1:     if (name->Equals(nsGkAtoms::style, kNameSpaceID_None) &&
    1:         value->Type() == nsAttrValue::eCSSStyleRule) {
    1:       // We can't just set this as a string, because that will fail
    1:       // to reparse the string into style data until the node is
50636:       // inserted into the document.  Clone the nsICSSRule instead.
50636:       nsCOMPtr<nsICSSRule> ruleClone = value->GetCSSStyleRuleValue()->Clone();
    1:       nsCOMPtr<nsICSSStyleRule> styleRule = do_QueryInterface(ruleClone);
    1:       NS_ENSURE_TRUE(styleRule, NS_ERROR_UNEXPECTED);
    1: 
    1:       rv = aDst->SetInlineStyleRule(styleRule, PR_FALSE);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       continue;
    1:     }
    1: 
    1:     nsAutoString valStr;
    1:     value->ToString(valStr);
    1:     rv = aDst->SetAttr(name->NamespaceID(), name->LocalName(),
    1:                        name->GetPrefix(), valStr, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetTagName(nsAString& aTagName)
    1: {
    1:   return GetNodeName(aTagName);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericHTMLElement::SetAttribute(const nsAString& aName,
    1:                                    const nsAString& aValue)
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1: 
    1:   if (!name) {
    1:     nsresult rv = nsContentUtils::CheckQName(aName, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIAtom> nameAtom;
29004:     if (IsInHTMLDocument()) {
    1:       nsAutoString lower;
38422:       nsContentUtils::ASCIIToLower(aName, lower);
    1:       nameAtom = do_GetAtom(lower);
    1:     }
    1:     else {
    1:       nameAtom = do_GetAtom(aName);
    1:     }
    1:     NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     return SetAttr(kNameSpaceID_None, nameAtom, aValue, PR_TRUE);
    1:   }
    1: 
    1:   return SetAttr(name->NamespaceID(), name->LocalName(), name->GetPrefix(),
    1:                  aValue, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetNodeName(nsAString& aNodeName)
    1: {
    1:   mNodeInfo->GetQualifiedName(aNodeName);
    1: 
29004:   if (IsInHTMLDocument())
38422:     nsContentUtils::ASCIIToUpper(aNodeName);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetElementsByTagName(const nsAString& aTagname,
    1:                                            nsIDOMNodeList** aReturn)
    1: {
29004:   // Only lowercase the name if this is an HTML document.
38422:   if (IsInHTMLDocument()) {
38422:     nsAutoString lower;
38422:     nsContentUtils::ASCIIToLower(aTagname, lower);
38422:     return nsGenericHTMLElementBase::GetElementsByTagName(lower, aReturn);
38422:   }
38422: 
38422:   return nsGenericHTMLElementBase::GetElementsByTagName(aTagname, aReturn);
    1: }
    1: 
    1: // Implementation for nsIDOMHTMLElement
    1: nsresult
    1: nsGenericHTMLElement::GetId(nsAString& aId)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::id, aId);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetId(const nsAString& aId)
    1: {
    1:   SetAttr(kNameSpaceID_None, nsGkAtoms::id, aId, PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetTitle(nsAString& aTitle)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::title, aTitle);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetTitle(const nsAString& aTitle)
    1: {
    1:   SetAttr(kNameSpaceID_None, nsGkAtoms::title, aTitle, PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetLang(nsAString& aLang)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::lang, aLang);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetLang(const nsAString& aLang)
    1: {
    1:   SetAttr(kNameSpaceID_None, nsGkAtoms::lang, aLang, PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: static const nsAttrValue::EnumTable kDirTable[] = {
    1:   { "ltr", NS_STYLE_DIRECTION_LTR },
    1:   { "rtl", NS_STYLE_DIRECTION_RTL },
    1:   { 0 }
    1: };
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetDir(nsAString& aDir)
    1: {
    1:   const nsAttrValue* attr = mAttrsAndChildren.GetAttr(nsGkAtoms::dir);
    1: 
    1:   if (attr && attr->Type() == nsAttrValue::eEnum) {
    1:     attr->ToString(aDir);
    1:   }
    1:   else {
    1:     aDir.Truncate();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetDir(const nsAString& aDir)
    1: {
    1:   SetAttr(kNameSpaceID_None, nsGkAtoms::dir, aDir, PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetClassName(nsAString& aClassName)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::_class, aClassName);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetClassName(const nsAString& aClassName)
    1: {
    1:   SetAttr(kNameSpaceID_None, nsGkAtoms::_class, aClassName, PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: static PRBool
    1: IsBody(nsIContent *aContent)
    1: {
33329:   return aContent->NodeInfo()->Equals(nsGkAtoms::body) &&
33329:          aContent->IsHTML();
    1: }
    1: 
 2370: static PRBool IS_TABLE_CELL(nsIAtom* frameType) {
 2370:   return nsGkAtoms::tableCellFrame == frameType ||
 2370:     nsGkAtoms::bcTableCellFrame == frameType;
 2370: }
 2370: 
    1: static PRBool
 2370: IsOffsetParent(nsIFrame* aFrame)
    1: {
 2370:   nsIAtom* frameType = aFrame->GetType();
 2370:   return (IS_TABLE_CELL(frameType) ||
 2370:           frameType == nsGkAtoms::tableFrame);
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::GetOffsetRect(nsRect& aRect, nsIContent** aOffsetParent)
    1: {
    1:   *aOffsetParent = nsnull;
16722:   aRect = nsRect();
16722: 
16722:   nsIFrame* frame = GetStyledFrame();
    1:   if (!frame) {
    1:     return;
    1:   }
    1: 
    1:   nsIFrame* parent = frame->GetParent();
    1:   nsPoint origin(0, 0);
    1: 
    1:   if (parent && parent->GetType() == nsGkAtoms::tableOuterFrame) {
    1:     origin = parent->GetPositionIgnoringScrolling();
    1:     parent = parent->GetParent();
    1:   }
    1: 
41634:   Element* docElement = GetCurrentDoc()->GetRootElement();
    1:   nsIContent* content = frame->GetContent();
    1: 
    1:   if (content && (IsBody(content) || content == docElement)) {
    1:     parent = frame;
    1:   }
    1:   else {
    1:     const PRBool isPositioned = frame->GetStyleDisplay()->IsPositioned();
    1:     const PRBool isAbsolutelyPositioned =
    1:       frame->GetStyleDisplay()->IsAbsolutelyPositioned();
    1:     origin += frame->GetPositionIgnoringScrolling();
    1: 
    1:     for ( ; parent ; parent = parent->GetParent()) {
    1:       content = parent->GetContent();
    1: 
    1:       // Stop at the first ancestor that is positioned.
    1:       if (parent->GetStyleDisplay()->IsPositioned()) {
    1:         *aOffsetParent = content;
    1:         NS_IF_ADDREF(*aOffsetParent);
    1:         break;
    1:       }
    1: 
    1:       // Add the parent's origin to our own to get to the
    1:       // right coordinate system.
 2705:       const PRBool isOffsetParent = !isPositioned && IsOffsetParent(parent);
 2370:       if (!isAbsolutelyPositioned && !isOffsetParent) {
    1:         origin += parent->GetPositionIgnoringScrolling();
    1:       }
    1: 
    1:       if (content) {
    1:         // If we've hit the document element, break here.
    1:         if (content == docElement) {
    1:           break;
    1:         }
    1: 
 2705:         // Break if the ancestor frame type makes it suitable as offset parent
 2705:         // and this element is *not* positioned or if we found the body element.
 2705:         if (isOffsetParent || IsBody(content)) {
    1:           *aOffsetParent = content;
    1:           NS_ADDREF(*aOffsetParent);
    1:           break;
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (isAbsolutelyPositioned && !*aOffsetParent) {
    1:       // If this element is absolutely positioned, but we don't have
    1:       // an offset parent it means this element is an absolutely
    1:       // positioned child that's not nested inside another positioned
    1:       // element, in this case the element's frame's parent is the
    1:       // frame for the HTML element so we fail to find the body in the
    1:       // parent chain. We want the offset parent in this case to be
    1:       // the body, so we just get the body element from the document.
    1: 
    1:       nsCOMPtr<nsIDOMHTMLDocument> html_doc(do_QueryInterface(GetCurrentDoc()));
    1: 
    1:       if (html_doc) {
    1:         nsCOMPtr<nsIDOMHTMLElement> html_element;
    1:         html_doc->GetBody(getter_AddRefs(html_element));
    1:         if (html_element) {
    1:           CallQueryInterface(html_element, aOffsetParent);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Subtract the parent border unless it uses border-box sizing.
    1:   if (parent &&
    1:       parent->GetStylePosition()->mBoxSizing != NS_STYLE_BOX_SIZING_BORDER) {
    1:     const nsStyleBorder* border = parent->GetStyleBorder();
15992:     origin.x -= border->GetActualBorderWidth(NS_SIDE_LEFT);
15992:     origin.y -= border->GetActualBorderWidth(NS_SIDE_TOP);
    1:   }
    1: 
    1:   // XXX We should really consider subtracting out padding for
    1:   // content-box sizing, but we should see what IE does....
    1: 
    1:   // Convert to pixels.
    1:   aRect.x = nsPresContext::AppUnitsToIntCSSPixels(origin.x);
    1:   aRect.y = nsPresContext::AppUnitsToIntCSSPixels(origin.y);
12349: 
12349:   // Get the union of all rectangles in this and continuation frames.
12349:   // It doesn't really matter what we use as aRelativeTo here, since
14186:   // we only care about the size. We just have to use something non-null.
14186:   nsRect rcFrame = nsLayoutUtils::GetAllInFlowRectsUnion(frame, frame);
    1:   aRect.width = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.width);
    1:   aRect.height = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.height);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetTop(PRInt32* aOffsetTop)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   *aOffsetTop = rcFrame.y;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetLeft(PRInt32* aOffsetLeft)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   *aOffsetLeft = rcFrame.x;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetWidth(PRInt32* aOffsetWidth)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   *aOffsetWidth = rcFrame.width;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetHeight(PRInt32* aOffsetHeight)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   *aOffsetHeight = rcFrame.height;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetOffsetParent(nsIDOMElement** aOffsetParent)
    1: {
    1:   nsRect rcFrame;
    1:   nsCOMPtr<nsIContent> parent;
    1:   GetOffsetRect(rcFrame, getter_AddRefs(parent));
    1: 
    1:   if (parent) {
    1:     CallQueryInterface(parent, aOffsetParent);
    1:   } else {
    1:     *aOffsetParent = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetInnerHTML(nsAString& aInnerHTML)
    1: {
    1:   aInnerHTML.Truncate();
    1: 
46309:   nsIDocument* doc = GetOwnerDoc();
    1:   if (!doc) {
    1:     return NS_OK; // We rely on the document for doing HTML conversion
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsAutoString contentType;
29004:   if (IsInHTMLDocument()) {
    1:     contentType.AssignLiteral("text/html");
    1:   } else {
    1:     doc->GetContentType(contentType);
    1:   }
    1: 
46309:   nsCOMPtr<nsIDocumentEncoder> docEncoder = doc->GetCachedEncoder();
46309:   if (!docEncoder) {
    1:     docEncoder =
    1:       do_CreateInstance(PromiseFlatCString(
    1:         nsDependentCString(NS_DOC_ENCODER_CONTRACTID_BASE) +
    1:         NS_ConvertUTF16toUTF8(contentType)
    1:       ).get());
46309:   }
31946:   if (!(docEncoder || doc->IsHTML())) {
    1:     // This could be some type for which we create a synthetic document.  Try
    1:     // again as XML
    1:     contentType.AssignLiteral("application/xml");
    1:     docEncoder = do_CreateInstance(NS_DOC_ENCODER_CONTRACTID_BASE "application/xml");
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(docEncoder, NS_ERROR_FAILURE);
    1: 
46309:   rv = docEncoder->NativeInit(doc, contentType,
    1:                               nsIDocumentEncoder::OutputEncodeBasicEntities |
    1:                               // Output DOM-standard newlines
    1:                               nsIDocumentEncoder::OutputLFLineBreak |
46309:                               // Don't do linebreaking that's not present in
46309:                               // the source
    1:                               nsIDocumentEncoder::OutputRaw);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
46309:   docEncoder->SetNativeContainerNode(this);
46309:   rv = docEncoder->EncodeToString(aInnerHTML);
47922:   doc->SetCachedEncoder(docEncoder.forget());
46309:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetInnerHTML(const nsAString& aInnerHTML)
    1: {
41754:   nsIDocument* doc = GetOwnerDoc();
41754:   NS_ENSURE_STATE(doc);
41754: 
41754:   nsresult rv = NS_OK;
41754: 
    1:   // This BeginUpdate/EndUpdate pair is important to make us reenable the
    1:   // scriptloader before the last EndUpdate call.
41754:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, PR_TRUE);
    1: 
   62:   // Batch possible DOMSubtreeModified events.
41754:   mozAutoSubtreeModified subtree(doc, nsnull);
   62: 
    1:   // Remove childnodes
    1:   nsContentUtils::SetNodeTextContent(this, EmptyString(), PR_FALSE);
    1: 
    1:   nsCOMPtr<nsIDOMDocumentFragment> df;
    1: 
    1:   // Strong ref since appendChild can fire events
41754:   nsRefPtr<nsScriptLoader> loader = doc->ScriptLoader();
41754:   PRBool scripts_enabled = loader->GetEnabled();
    1:   loader->SetEnabled(PR_FALSE);
41754: 
41754:   if (doc->IsHTML() && nsHtml5Module::sEnabled) {
41754:     nsCOMPtr<nsIParser> parser = doc->GetFragmentParser();
41754:     if (parser) {
41754:       parser->Reset();
41754:     } else {
41754:       parser = nsHtml5Module::NewHtml5Parser();
41754:       NS_ENSURE_TRUE(parser, NS_ERROR_OUT_OF_MEMORY);
41754:     }
41754: 
41754:     PRInt32 oldChildCount = GetChildCount();
41754:     parser->ParseFragment(aInnerHTML, this, Tag(), GetNameSpaceID(),
41754:                           doc->GetCompatibilityMode() == eCompatibility_NavQuirks);
41754:     doc->SetFragmentParser(parser);
41754: 
41754:     // HTML5 parser has notified, but not fired mutation events.
41754:     // Fire mutation events. Optimize for the case when there are no listeners
41754:     nsPIDOMWindow* window = nsnull;
41754:     PRInt32 newChildCount = GetChildCount();
41754:     if (newChildCount &&
41754:         (((window = doc->GetInnerWindow()) &&
41754:           window->HasMutationListeners(NS_EVENT_BITS_MUTATION_NODEINSERTED)) ||
41754:          !window)) {
41754:       nsCOMArray<nsIContent> childNodes;
41754:       NS_ASSERTION(newChildCount - oldChildCount >= 0,
41754:                    "What, some unexpected dom mutation has happened?");
41754:       childNodes.SetCapacity(newChildCount - oldChildCount);
41754:       for (nsINode::ChildIterator iter(this); !iter.IsDone(); iter.Next()) {
41754:         childNodes.AppendObject(iter);
41754:       }
41754:       nsGenericElement::FireNodeInserted(doc, this, childNodes);
41754:     }
41754:   } else {
41754:     rv = nsContentUtils::CreateContextualFragment(this, aInnerHTML, PR_FALSE,
    1:                                                   getter_AddRefs(df));
41240:     nsCOMPtr<nsINode> fragment = do_QueryInterface(df);
    1:     if (NS_SUCCEEDED(rv)) {
41240:       static_cast<nsINode*>(this)->AppendChild(fragment, &rv);
    1:     }
41754:   }
    1: 
    1:   if (scripts_enabled) {
    1:     // If we disabled scripts, re-enable them now that we're
    1:     // done. Don't fire JS timeouts when enabling the context here.
    1: 
    1:     loader->SetEnabled(PR_TRUE);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
34226: nsGenericHTMLElement::ScrollIntoView(PRBool aTop, PRUint8 optional_argc)
    1: {
    1:   nsIDocument *document = GetCurrentDoc();
    1: 
    1:   if (!document) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Get the presentation shell
46225:   nsCOMPtr<nsIPresShell> presShell = document->GetShell();
    1:   if (!presShell) {
    1:     return NS_OK;
    1:   }
    1: 
34226:   if (!optional_argc) {
34226:     aTop = PR_TRUE;
34226:   }
34226: 
    1:   PRIntn vpercent = aTop ? NS_PRESSHELL_SCROLL_TOP :
 9984:     NS_PRESSHELL_SCROLL_BOTTOM;
    1: 
    1:   presShell->ScrollContentIntoView(this, vpercent,
56647:                                    NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                    nsIPresShell::SCROLL_OVERFLOW_HIDDEN);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericHTMLElement::GetSpellcheck(PRBool* aSpellcheck)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSpellcheck);
    1:   *aSpellcheck = PR_FALSE;              // Default answer is to not spellcheck
    1: 
    1:   // Has the state has been explicitly set?
33329:   nsIContent* node;
33329:   for (node = this; node; node = node->GetParent()) {
33329:     if (node->IsHTML()) {
    1:       static nsIContent::AttrValuesArray strings[] =
    1:         {&nsGkAtoms::_true, &nsGkAtoms::_false, nsnull};
33329:       switch (node->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::spellcheck,
    1:                                     strings, eCaseMatters)) {
    1:         case 0:                         // spellcheck = "true"
    1:           *aSpellcheck = PR_TRUE;
    1:           // Fall through
    1:         case 1:                         // spellcheck = "false"
    1:           return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Is this a chrome element?
    1:   if (nsContentUtils::IsChromeDoc(GetOwnerDoc())) {
    1:     return NS_OK;                       // Not spellchecked by default
    1:   }
    1: 
    1:   if (IsCurrentBodyElement()) {
 2896:     nsCOMPtr<nsIHTMLDocument> doc = do_QueryInterface(GetCurrentDoc());
 2896:     if (doc) {
 2896:       *aSpellcheck = doc->IsEditingOn();
 2896:     }
 2896: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Is this element editable?
    1:   nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(this);
    1:   if (!formControl) {
    1:     return NS_OK;                       // Not spellchecked by default
    1:   }
    1: 
    1:   // Is this a multiline plaintext input?
    1:   PRInt32 controlType = formControl->GetType();
    1:   if (controlType == NS_FORM_TEXTAREA) {
    1:     *aSpellcheck = PR_TRUE;             // Spellchecked by default
    1:     return NS_OK;
    1:   }
    1: 
42192:   // Is this anything other than an input text?
42192:   // Other inputs are not spellchecked.
    1:   if (controlType != NS_FORM_INPUT_TEXT) {
    1:     return NS_OK;                       // Not spellchecked by default
    1:   }
    1: 
42192:   // Does the user want input text spellchecked by default?
    1:   // NOTE: Do not reflect a pref value of 0 back to the DOM getter.
    1:   // The web page should not know if the user has disabled spellchecking.
    1:   // We'll catch this in the editor itself.
    1:   PRInt32 spellcheckLevel =
    1:     nsContentUtils::GetIntPref("layout.spellcheckDefault", 1);
    1:   if (spellcheckLevel == 2) {           // "Spellcheck multi- and single-line"
    1:     *aSpellcheck = PR_TRUE;             // Spellchecked by default
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericHTMLElement::SetSpellcheck(PRBool aSpellcheck)
    1: {
    1:   if (aSpellcheck) {
    1:     return SetAttrHelper(nsGkAtoms::spellcheck, NS_LITERAL_STRING("true"));
    1:   }
    1: 
    1:   return SetAttrHelper(nsGkAtoms::spellcheck, NS_LITERAL_STRING("false"));
    1: }
    1: 
18445: NS_IMETHODIMP
18445: nsGenericHTMLElement::GetDraggable(PRBool* aDraggable)
18445: {
18445:   *aDraggable = AttrValueIs(kNameSpaceID_None, nsGkAtoms::draggable,
18445:                              nsGkAtoms::_true, eIgnoreCase);
18445:   return NS_OK;
18445: }
18445: 
18445: NS_IMETHODIMP
18445: nsGenericHTMLElement::SetDraggable(PRBool aDraggable)
18445: {
18445:   return SetAttrHelper(nsGkAtoms::draggable,
18445:                        aDraggable ? NS_LITERAL_STRING("true") :
18445:                                     NS_LITERAL_STRING("false"));
18445: }
18445: 
    1: PRBool
    1: nsGenericHTMLElement::InNavQuirksMode(nsIDocument* aDoc)
    1: {
    1:   return aDoc && aDoc->GetCompatibilityMode() == eCompatibility_NavQuirks;
    1: }
    1: 
 2896: void
 2896: nsGenericHTMLElement::UpdateEditableState()
 2896: {
 2896:   // XXX Should we do this only when in a document?
 2896:   ContentEditableTristate value = GetContentEditableValue();
 2896:   if (value != eInherit) {
11494:     SetEditableFlag(!!value);
 2896: 
 2896:     return;
 2896:   }
 2896: 
43079:   nsStyledElement::UpdateEditableState();
 2896: }
 2896: 
    1: nsresult
    1: nsGenericHTMLElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                                  nsIContent* aBindingParent,
    1:                                  PRBool aCompileEventHandlers)
    1: {
 4306:   nsresult rv = nsGenericHTMLElementBase::BindToTree(aDocument, aParent,
    1:                                                      aBindingParent,
    1:                                                      aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 4306:   if (aDocument) {
43079:     if (HasFlag(NODE_HAS_NAME)) {
43079:       aDocument->
43079:         AddToNameTable(this, GetParsedAttr(nsGkAtoms::name)->GetAtomValue());
43079:     }
 4306:     if (HasFlag(NODE_IS_EDITABLE) && GetContentEditableValue() == eTrue) {
 2896:       nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(aDocument);
 2896:       if (htmlDocument) {
 2896:         htmlDocument->ChangeContentEditableCount(this, +1);
 2896:       }
 2896:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
 2896: void
 2896: nsGenericHTMLElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
 2896: {
48037:   RemoveFromNameTable();
48037: 
 2896:   if (GetContentEditableValue() == eTrue) {
 2896:     nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(GetCurrentDoc());
 2896:     if (htmlDocument) {
 2896:       htmlDocument->ChangeContentEditableCount(this, -1);
 2896:     }
 2896:   }
 2896: 
43079:   nsStyledElement::UnbindFromTree(aDeep, aNullParent);
 2896: }
 2896: 
34395: nsHTMLFormElement*
51301: nsGenericHTMLElement::FindAncestorForm(nsHTMLFormElement* aCurrentForm)
    1: {
51301:   NS_ASSERTION(!HasAttr(kNameSpaceID_None, nsGkAtoms::form),
51301:                "FindAncestorForm should not be called if @form is set!");
51301: 
 3597:   // Make sure we don't end up finding a form that's anonymous from
 3597:   // our point of view.
 3597:   nsIContent* bindingParent = GetBindingParent();
 3597: 
    1:   nsIContent* content = this;
 3597:   while (content != bindingParent && content) {
    1:     // If the current ancestor is a form, return it as our form
    1:     if (content->Tag() == nsGkAtoms::form &&
33329:         content->IsHTML()) {
 4206: #ifdef DEBUG
 4206:       if (!nsContentUtils::IsInSameAnonymousTree(this, content)) {
 4206:         // It's possible that we started unbinding at |content| or
 4206:         // some ancestor of it, and |content| and |this| used to all be
 4206:         // anonymous.  Check for this the hard way.
 4206:         for (nsIContent* child = this; child != content;
 4206:              child = child->GetParent()) {
 4206:           NS_ASSERTION(child->GetParent()->IndexOf(child) != -1,
 3597:                        "Walked too far?");
 4206:         }
 4206:       }
 4206: #endif
34395:       return static_cast<nsHTMLFormElement*>(content);
    1:     }
    1: 
    1:     nsIContent *prevContent = content;
    1:     content = prevContent->GetParent();
    1: 
    1:     if (!content && aCurrentForm) {
    1:       // We got to the root of the subtree we're in, and we're being removed
    1:       // from the DOM (the only time we get into this method with a non-null
    1:       // aCurrentForm).  Check whether aCurrentForm is in the same subtree.  If
    1:       // it is, we want to return aCurrentForm, since this case means that
    1:       // we're one of those inputs-in-a-table that have a hacked mForm pointer
    1:       // and a subtree containing both us and the form got removed from the
    1:       // DOM.
34395:       if (nsContentUtils::ContentIsDescendantOf(aCurrentForm, prevContent)) {
34395:         return aCurrentForm;
34395:       }
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: static PRBool
    1: IsArea(nsIContent *aContent)
    1: {
    1:   return (aContent->Tag() == nsGkAtoms::area &&
33329:           aContent->IsHTML());
    1: }
    1: 
  723: PRBool
  723: nsGenericHTMLElement::CheckHandleEventForAnchorsPreconditions(nsEventChainVisitor& aVisitor)
    1: {
    1:   NS_PRECONDITION(nsCOMPtr<nsILink>(do_QueryInterface(this)),
    1:                   "should be called only when |this| implements |nsILink|");
    1: 
    1:   if (!aVisitor.mPresContext) {
    1:     // We need a pres context to do link stuff. Some events (e.g. mutation
    1:     // events) don't have one.
    1:     // XXX: ideally, shouldn't we be able to do what we need without one?
  723:     return PR_FALSE; 
    1:   }
    1: 
    1:   //Need to check if we hit an imagemap area and if so see if we're handling
    1:   //the event on that map or on a link farther up the tree.  If we're on a
    1:   //link farther up, do nothing.
    1:   nsCOMPtr<nsIContent> target;
    1:   aVisitor.mPresContext->EventStateManager()->
    1:     GetEventTargetContent(aVisitor.mEvent, getter_AddRefs(target));
    1: 
  723:   return !target || !IsArea(target) || IsArea(this);
  723: }
  723: 
  723: nsresult
  723: nsGenericHTMLElement::PreHandleEventForAnchors(nsEventChainPreVisitor& aVisitor)
  723: {
 4306:   nsresult rv = nsGenericHTMLElementBase::PreHandleEvent(aVisitor);
  723:   NS_ENSURE_SUCCESS(rv, rv);
  723: 
  723:   if (!CheckHandleEventForAnchorsPreconditions(aVisitor)) {
  723:     return NS_OK;
  723:   }
  723: 
  723:   return PreHandleEventForLinks(aVisitor);
  723: }
  723: 
  723: nsresult
  723: nsGenericHTMLElement::PostHandleEventForAnchors(nsEventChainPostVisitor& aVisitor)
  723: {
  723:   if (!CheckHandleEventForAnchorsPreconditions(aVisitor)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return PostHandleEventForLinks(aVisitor);
    1: }
    1: 
    1: PRBool
    1: nsGenericHTMLElement::IsHTMLLink(nsIURI** aURI) const
    1: {
    1:   NS_PRECONDITION(aURI, "Must provide aURI out param");
    1: 
30307:   *aURI = GetHrefURIForAnchors().get();
    1:   // We promise out param is non-null if we return true, so base rv on it
    1:   return *aURI != nsnull;
    1: }
    1: 
30307: already_AddRefed<nsIURI>
30307: nsGenericHTMLElement::GetHrefURIForAnchors() const
    1: {
    1:   // This is used by the three nsILink implementations and
    1:   // nsHTMLStyleElement.
    1: 
    1:   // Get href= attribute (relative URI).
    1: 
    1:   // We use the nsAttrValue's copy of the URI string to avoid copying.
30307:   nsCOMPtr<nsIURI> uri;
30307:   GetURIAttr(nsGkAtoms::href, nsnull, PR_FALSE, getter_AddRefs(uri));
30307: 
30307:   return uri.forget();
    1: }
    1: 
26909: void
26909: nsGenericHTMLElement::GetHrefURIToMutate(nsIURI** aURI)
26909: {
26909:   GetURIAttr(nsGkAtoms::href, nsnull, PR_TRUE, aURI);
26909: }
26909: 
    1: nsresult
    1: nsGenericHTMLElement::AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                                    const nsAString* aValue, PRBool aNotify)
    1: {
    1:   if (aNamespaceID == kNameSpaceID_None) {
  265:     if (nsContentUtils::IsEventAttributeName(aName, EventNameType_HTML) && aValue) {
    1:       nsresult rv = AddScriptEventListener(aName, *aValue);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else if (aNotify && aName == nsGkAtoms::spellcheck) {
    1:       SyncEditorsOnSubtree(this);
    1:     }
    1:   }
    1: 
 4306:   return nsGenericHTMLElementBase::AfterSetAttr(aNamespaceID, aName,
    1:                                                 aValue, aNotify);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetEventListenerManagerForAttr(nsIEventListenerManager** aManager,
    1:                                                      nsISupports** aTarget,
    1:                                                      PRBool* aDefer)
    1: {
    1:   // Attributes on the body and frameset tags get set on the global object
    1:   if (mNodeInfo->Equals(nsGkAtoms::body) ||
    1:       mNodeInfo->Equals(nsGkAtoms::frameset)) {
    1:     nsPIDOMWindow *win;
    1: 
    1:     // If we have a document, and it has a window, add the event
    1:     // listener on the window (the inner window). If not, proceed as
    1:     // normal.
    1:     // XXXbz sXBL/XBL2 issue: should we instead use GetCurrentDoc() here,
    1:     // override BindToTree for those classes and munge event listeners there?
    1:     nsIDocument *document = GetOwnerDoc();
    1:     nsresult rv = NS_OK;
14919: 
14919:     // FIXME (https://bugzilla.mozilla.org/show_bug.cgi?id=431767)
14919:     // nsDocument::GetInnerWindow can return an outer window in some cases,
14919:     // we don't want to stick an event listener on an outer window, so
14919:     // bail if it does.
14919:     if (document &&
14919:         (win = document->GetInnerWindow()) && win->IsInnerWindow()) {
 1418:       nsCOMPtr<nsPIDOMEventTarget> piTarget(do_QueryInterface(win));
 1418:       NS_ENSURE_TRUE(piTarget, NS_ERROR_FAILURE);
 1418: 
29474:       *aManager = piTarget->GetListenerManager(PR_TRUE);
29474: 
29474:       if (*aManager) {
    1:         NS_ADDREF(*aTarget = win);
29474:         NS_ADDREF(*aManager);
    1:       }
    1:       *aDefer = PR_FALSE;
    1:     } else {
    1:       *aManager = nsnull;
    1:       *aTarget = nsnull;
    1:       *aDefer = PR_FALSE;
    1:     }
    1: 
    1:     return rv;
    1:   }
    1: 
 4306:   return nsGenericHTMLElementBase::GetEventListenerManagerForAttr(aManager,
 4306:                                                                   aTarget,
    1:                                                                   aDefer);
    1: }
    1: 
    1: nsresult
 2896: nsGenericHTMLElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 2896:                               nsIAtom* aPrefix, const nsAString& aValue,
 2896:                               PRBool aNotify)
 2896: {
 2896:   PRBool contentEditable = aNameSpaceID == kNameSpaceID_None &&
 2896:                            aName == nsGkAtoms::contenteditable;
 2896:   PRInt32 change;
 2896:   if (contentEditable) {
 2896:     change = GetContentEditableValue() == eTrue ? -1 : 0;
29482:     SetFlags(NODE_MAY_HAVE_CONTENT_EDITABLE_ATTR);
 2896:   }
 2896: 
43079:   nsresult rv = nsStyledElement::SetAttr(aNameSpaceID, aName, aPrefix, aValue,
 2896:                                          aNotify);
 2896:   NS_ENSURE_SUCCESS(rv, rv);
 2896: 
 2896:   if (contentEditable) {
 2896:     if (aValue.IsEmpty() || aValue.LowerCaseEqualsLiteral("true")) {
 2896:       change += 1;
 2896:     }
 2896: 
 2896:     ChangeEditableState(change);
 2896:   }
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
 2896: nsresult
    1: nsGenericHTMLElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
    1:                                 PRBool aNotify)
    1: {
20827:   PRBool contentEditable = PR_FALSE;
20827:   PRInt32 contentEditableChange;
20827: 
30099:   // Check for event handlers
20827:   if (aNameSpaceID == kNameSpaceID_None) {
43079:     if (aAttribute == nsGkAtoms::name) {
43079:       // Have to do this before clearing flag. See RemoveFromNameTable
43079:       RemoveFromNameTable();
43079:       UnsetFlags(NODE_HAS_NAME);
43079:     }
43079:     else if (aAttribute == nsGkAtoms::contenteditable) {
20827:       contentEditable = PR_TRUE;
20827:       contentEditableChange = GetContentEditableValue() == eTrue ? -1 : 0;
20827:     }
30099:     else if (nsContentUtils::IsEventAttributeName(aAttribute,
30099:                                                   EventNameType_HTML)) {
29474:       nsIEventListenerManager* manager = GetListenerManager(PR_FALSE);
    1:       if (manager) {
    1:         manager->RemoveScriptEventListener(aAttribute);
    1:       }
    1:     }
 2896:   }
    1: 
20827:   nsresult rv = nsGenericHTMLElementBase::UnsetAttr(aNameSpaceID, aAttribute,
 4306:                                                     aNotify);
20827:   NS_ENSURE_SUCCESS(rv, rv);
20827: 
20827:   if (contentEditable) {
20827:     ChangeEditableState(contentEditableChange);
20827:   }
20827: 
20827:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::GetBaseTarget(nsAString& aBaseTarget) const
    1: {
    1:   nsIDocument* ownerDoc = GetOwnerDoc();
    1:   if (ownerDoc) {
    1:     ownerDoc->GetBaseTarget(aBaseTarget);
    1:   } else {
    1:     aBaseTarget.Truncate();
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
43079: static PRBool
43079: CanHaveName(nsIAtom* aTag)
43079: {
43079:   return aTag == nsGkAtoms::img ||
43079:          aTag == nsGkAtoms::form ||
43079:          aTag == nsGkAtoms::applet ||
43079:          aTag == nsGkAtoms::embed ||
43079:          aTag == nsGkAtoms::object;
43079: }
    1: 
    1: PRBool
    1: nsGenericHTMLElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                                      nsIAtom* aAttribute,
    1:                                      const nsAString& aValue,
    1:                                      nsAttrValue& aResult)
    1: {
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     if (aAttribute == nsGkAtoms::dir) {
41437:       return aResult.ParseEnumValue(aValue, kDirTable, PR_FALSE);
    1:     }
    1:   
    1:     if (aAttribute == nsGkAtoms::tabindex) {
    1:       return aResult.ParseIntWithBounds(aValue, -32768, 32767);
    1:     }
    1: 
43079:     if (aAttribute == nsGkAtoms::name) {
    1:       // Store name as an atom.  name="" means that the element has no name,
    1:       // not that it has an emptystring as the name.
43079:       RemoveFromNameTable();
43079:       if (aValue.IsEmpty()) {
43079:         UnsetFlags(NODE_HAS_NAME);
43079:         return PR_FALSE;
43079:       }
43079: 
    1:       aResult.ParseAtom(aValue);
43079: 
43079:       if (CanHaveName(Tag())) {
43079:         SetFlags(NODE_HAS_NAME);
43079:         AddToNameTable(aResult.GetAtomValue());
43079:       }
43079:       
    1:       return PR_TRUE;
    1:     }
 2896: 
 2896:     if (aAttribute == nsGkAtoms::contenteditable) {
 2896:       aResult.ParseAtom(aValue);
 2896:       return PR_TRUE;
 2896:     }
    1:   }
    1: 
 4306:   return nsGenericHTMLElementBase::ParseAttribute(aNamespaceID, aAttribute,
 4306:                                                   aValue, aResult);
    1: }
    1: 
    1: PRBool
    1: nsGenericHTMLElement::IsAttributeMapped(const nsIAtom* aAttribute) const
    1: {
    1:   static const MappedAttributeEntry* const map[] = {
    1:     sCommonAttributeMap
    1:   };
    1:   
    1:   return FindAttributeDependence(aAttribute, map, NS_ARRAY_LENGTH(map));
    1: }
    1: 
    1: nsMapRuleToAttributesFunc
    1: nsGenericHTMLElement::GetAttributeMappingFunction() const
    1: {
    1:   return &MapCommonAttributesInto;
    1: }
    1: 
    1: nsIFormControlFrame*
36655: nsGenericHTMLElement::GetFormControlFrame(PRBool aFlushFrames)
    1: {
36655:   if (aFlushFrames && IsInDoc()) {
27993:     // Cause a flush of the frames, so we get up-to-date frame information
36655:     GetCurrentDoc()->FlushPendingNotifications(Flush_Frames);
36655:   }
36655:   nsIFrame* frame = GetPrimaryFrame();
    1:   if (frame) {
23554:     nsIFormControlFrame* form_frame = do_QueryFrame(frame);
    1:     if (form_frame) {
    1:       return form_frame;
    1:     }
    1: 
    1:     // If we have generated content, the primary frame will be a
    1:     // wrapper frame..  out real frame will be in its child list.
    1:     for (frame = frame->GetFirstChild(nsnull);
    1:          frame;
    1:          frame = frame->GetNextSibling()) {
23554:       form_frame = do_QueryFrame(frame);
    1:       if (form_frame) {
    1:         return form_frame;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: /* static */ nsresult
    1: nsGenericHTMLElement::GetPrimaryPresState(nsGenericHTMLElement* aContent,
    1:                                           nsPresState** aPresState)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPresState);
    1:   *aPresState = nsnull;
    1: 
    1:   nsresult result = NS_OK;
    1: 
    1:   nsCOMPtr<nsILayoutHistoryState> history;
    1:   nsCAutoString key;
 3727:   GetLayoutHistoryAndKey(aContent, PR_FALSE, getter_AddRefs(history), key);
    1: 
    1:   if (history) {
    1:     // Get the pres state for this key, if it doesn't exist, create one
    1:     result = history->GetState(key, aPresState);
    1:     if (!*aPresState) {
22740:       *aPresState = new nsPresState();
22740:       if (!*aPresState) {
22740:         return NS_ERROR_OUT_OF_MEMORY;
22740:       }
22740:         
    1:       result = history->AddState(key, *aPresState);
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetLayoutHistoryAndKey(nsGenericHTMLElement* aContent,
 3727:                                              PRBool aRead,
    1:                                              nsILayoutHistoryState** aHistory,
    1:                                              nsACString& aKey)
    1: {
    1:   //
    1:   // Get the pres shell
    1:   //
    1:   nsCOMPtr<nsIDocument> doc = aContent->GetDocument();
    1:   if (!doc) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   //
    1:   // Get the history (don't bother with the key if the history is not there)
    1:   //
    1:   *aHistory = doc->GetLayoutHistoryState().get();
    1:   if (!*aHistory) {
    1:     return NS_OK;
    1:   }
    1: 
 3727:   if (aRead && !(*aHistory)->HasStates()) {
 3727:     NS_RELEASE(*aHistory);
 3727:     return NS_OK;
 3727:   }
 3727: 
    1:   //
    1:   // Get the state key
    1:   //
    1:   nsresult rv = nsContentUtils::GenerateStateKey(aContent, doc,
    1:                                                  nsIStatefulFrame::eNoID,
    1:                                                  aKey);
    1:   if (NS_FAILED(rv)) {
    1:     NS_RELEASE(*aHistory);
    1:     return rv;
    1:   }
    1: 
    1:   // If the state key is blank, this is anonymous content or for
    1:   // whatever reason we are not supposed to save/restore state.
    1:   if (aKey.IsEmpty()) {
    1:     NS_RELEASE(*aHistory);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Add something unique to content so layout doesn't muck us up
    1:   aKey += "-C";
    1: 
    1:   return rv;
    1: }
    1: 
    1: PRBool
    1: nsGenericHTMLElement::RestoreFormControlState(nsGenericHTMLElement* aContent,
    1:                                               nsIFormControl* aControl)
    1: {
    1:   nsCOMPtr<nsILayoutHistoryState> history;
    1:   nsCAutoString key;
 3727:   nsresult rv = GetLayoutHistoryAndKey(aContent, PR_TRUE,
 3727:                                        getter_AddRefs(history), key);
    1:   if (!history) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsPresState *state;
    1:   // Get the pres state for this key
    1:   rv = history->GetState(key, &state);
    1:   if (state) {
    1:     PRBool result = aControl->RestoreState(state);
    1:     history->RemoveState(key);
    1:     return result;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: // XXX This creates a dependency between content and frames
    1: nsPresContext*
    1: nsGenericHTMLElement::GetPresContext()
    1: {
    1:   // Get the document
    1:   nsIDocument* doc = GetDocument();
    1:   if (doc) {
    1:     // Get presentation shell 0
46225:     nsIPresShell *presShell = doc->GetShell();
    1:     if (presShell) {
    1:       return presShell->GetPresContext();
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: static const nsAttrValue::EnumTable kAlignTable[] = {
    1:   { "left",      NS_STYLE_TEXT_ALIGN_LEFT },
    1:   { "right",     NS_STYLE_TEXT_ALIGN_RIGHT },
    1: 
    1:   { "top",       NS_STYLE_VERTICAL_ALIGN_TOP },
    1:   { "middle",    NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE },
    1:   { "bottom",    NS_STYLE_VERTICAL_ALIGN_BASELINE },
    1: 
    1:   { "center",    NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE },
    1:   { "baseline",  NS_STYLE_VERTICAL_ALIGN_BASELINE },
    1: 
    1:   { "texttop",   NS_STYLE_VERTICAL_ALIGN_TEXT_TOP },
    1:   { "absmiddle", NS_STYLE_VERTICAL_ALIGN_MIDDLE },
    1:   { "abscenter", NS_STYLE_VERTICAL_ALIGN_MIDDLE },
    1:   { "absbottom", NS_STYLE_VERTICAL_ALIGN_BOTTOM },
    1:   { 0 }
    1: };
    1: 
    1: static const nsAttrValue::EnumTable kDivAlignTable[] = {
    1:   { "left", NS_STYLE_TEXT_ALIGN_MOZ_LEFT },
    1:   { "right", NS_STYLE_TEXT_ALIGN_MOZ_RIGHT },
    1:   { "center", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
    1:   { "middle", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
    1:   { "justify", NS_STYLE_TEXT_ALIGN_JUSTIFY },
    1:   { 0 }
    1: };
    1: 
    1: static const nsAttrValue::EnumTable kFrameborderTable[] = {
    1:   { "yes", NS_STYLE_FRAME_YES },
    1:   { "no", NS_STYLE_FRAME_NO },
    1:   { "1", NS_STYLE_FRAME_1 },
    1:   { "0", NS_STYLE_FRAME_0 },
    1:   { 0 }
    1: };
    1: 
    1: static const nsAttrValue::EnumTable kScrollingTable[] = {
    1:   { "yes", NS_STYLE_FRAME_YES },
    1:   { "no", NS_STYLE_FRAME_NO },
    1:   { "on", NS_STYLE_FRAME_ON },
    1:   { "off", NS_STYLE_FRAME_OFF },
    1:   { "scroll", NS_STYLE_FRAME_SCROLL },
    1:   { "noscroll", NS_STYLE_FRAME_NOSCROLL },
    1:   { "auto", NS_STYLE_FRAME_AUTO },
    1:   { 0 }
    1: };
    1: 
    1: static const nsAttrValue::EnumTable kTableVAlignTable[] = {
    1:   { "top",     NS_STYLE_VERTICAL_ALIGN_TOP },
    1:   { "middle",  NS_STYLE_VERTICAL_ALIGN_MIDDLE },
    1:   { "bottom",  NS_STYLE_VERTICAL_ALIGN_BOTTOM },
    1:   { "baseline",NS_STYLE_VERTICAL_ALIGN_BASELINE },
    1:   { 0 }
    1: };
    1: 
    1: PRBool
    1: nsGenericHTMLElement::ParseAlignValue(const nsAString& aString,
    1:                                       nsAttrValue& aResult)
    1: {
41437:   return aResult.ParseEnumValue(aString, kAlignTable, PR_FALSE);
    1: }
    1: 
    1: //----------------------------------------
    1: 
    1: static const nsAttrValue::EnumTable kTableHAlignTable[] = {
    1:   { "left",   NS_STYLE_TEXT_ALIGN_LEFT },
    1:   { "right",  NS_STYLE_TEXT_ALIGN_RIGHT },
    1:   { "center", NS_STYLE_TEXT_ALIGN_CENTER },
    1:   { "char",   NS_STYLE_TEXT_ALIGN_CHAR },
    1:   { "justify",NS_STYLE_TEXT_ALIGN_JUSTIFY },
    1:   { 0 }
    1: };
    1: 
    1: PRBool
    1: nsGenericHTMLElement::ParseTableHAlignValue(const nsAString& aString,
43545:                                             nsAttrValue& aResult)
    1: {
41437:   return aResult.ParseEnumValue(aString, kTableHAlignTable, PR_FALSE);
    1: }
    1: 
    1: //----------------------------------------
    1: 
48442: // This table is used for td, th, tr, col, thead, tbody and tfoot.
    1: static const nsAttrValue::EnumTable kTableCellHAlignTable[] = {
    1:   { "left",   NS_STYLE_TEXT_ALIGN_MOZ_LEFT },
    1:   { "right",  NS_STYLE_TEXT_ALIGN_MOZ_RIGHT },
    1:   { "center", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
    1:   { "char",   NS_STYLE_TEXT_ALIGN_CHAR },
    1:   { "justify",NS_STYLE_TEXT_ALIGN_JUSTIFY },
    1:   { "middle", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
    1:   { "absmiddle", NS_STYLE_TEXT_ALIGN_CENTER },
    1:   { 0 }
    1: };
    1: 
    1: PRBool
    1: nsGenericHTMLElement::ParseTableCellHAlignValue(const nsAString& aString,
48442:                                                 nsAttrValue& aResult)
    1: {
41437:   return aResult.ParseEnumValue(aString, kTableCellHAlignTable, PR_FALSE);
    1: }
    1: 
    1: //----------------------------------------
    1: 
    1: PRBool
    1: nsGenericHTMLElement::ParseTableVAlignValue(const nsAString& aString,
    1:                                             nsAttrValue& aResult)
    1: {
41437:   return aResult.ParseEnumValue(aString, kTableVAlignTable, PR_FALSE);
    1: }
    1: 
    1: PRBool
    1: nsGenericHTMLElement::ParseDivAlignValue(const nsAString& aString,
47237:                                          nsAttrValue& aResult)
    1: {
41437:   return aResult.ParseEnumValue(aString, kDivAlignTable, PR_FALSE);
    1: }
    1: 
    1: PRBool
    1: nsGenericHTMLElement::ParseImageAttribute(nsIAtom* aAttribute,
    1:                                           const nsAString& aString,
    1:                                           nsAttrValue& aResult)
    1: {
    1:   if ((aAttribute == nsGkAtoms::width) ||
    1:       (aAttribute == nsGkAtoms::height)) {
11790:     return aResult.ParseSpecialIntValue(aString, PR_TRUE);
    1:   }
    1:   else if ((aAttribute == nsGkAtoms::hspace) ||
    1:            (aAttribute == nsGkAtoms::vspace) ||
    1:            (aAttribute == nsGkAtoms::border)) {
    1:     return aResult.ParseIntWithBounds(aString, 0);
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsGenericHTMLElement::ParseFrameborderValue(const nsAString& aString,
    1:                                             nsAttrValue& aResult)
    1: {
41437:   return aResult.ParseEnumValue(aString, kFrameborderTable, PR_FALSE);
    1: }
    1: 
    1: PRBool
    1: nsGenericHTMLElement::ParseScrollingValue(const nsAString& aString,
    1:                                           nsAttrValue& aResult)
    1: {
41437:   return aResult.ParseEnumValue(aString, kScrollingTable, PR_FALSE);
    1: }
    1: 
    1: /**
    1:  * Handle attributes common to all html elements
    1:  */
    1: void
    1: nsGenericHTMLElement::MapCommonAttributesInto(const nsMappedAttributes* aAttributes,
    1:                                               nsRuleData* aData)
    1: {
 6732:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(UserInterface)) {
 2896:     nsRuleDataUserInterface *ui = aData->mUserInterfaceData;
 2896:     if (ui->mUserModify.GetUnit() == eCSSUnit_Null) {
 2896:       const nsAttrValue* value =
 2896:         aAttributes->GetAttr(nsGkAtoms::contenteditable);
 2896:       if (value) {
 2896:         if (value->Equals(nsGkAtoms::_empty, eCaseMatters) ||
 2896:             value->Equals(nsGkAtoms::_true, eIgnoreCase)) {
 2896:           ui->mUserModify.SetIntValue(NS_STYLE_USER_MODIFY_READ_WRITE,
 2896:                                       eCSSUnit_Enumerated);
 2896:         }
20264:         else if (value->Equals(nsGkAtoms::_false, eIgnoreCase)) {
 2896:             ui->mUserModify.SetIntValue(NS_STYLE_USER_MODIFY_READ_ONLY,
 2896:                                         eCSSUnit_Enumerated);
 2896:         }
 2896:       }
 2896:     }
 2896:   }
48696: 
 6732:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Visibility)) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::lang);
    1:     if (value && value->Type() == nsAttrValue::eString) {
    1:       aData->mDisplayData->mLang.SetStringValue(value->GetStringValue(),
25796:                                                 eCSSUnit_Ident);
    1:     }
    1:   }
48696: 
48696:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
48696:     nsRuleDataDisplay* disp = aData->mDisplayData;
48696:     if (disp->mDisplay.GetUnit() == eCSSUnit_Null) {
48696:       if (aAttributes->IndexOfAttr(nsGkAtoms::hidden, kNameSpaceID_None) >= 0) {
48696:         disp->mDisplay.SetIntValue(NS_STYLE_DISPLAY_NONE, eCSSUnit_Enumerated);
48696:       }
48696:     }
48696:   }
    1: }
    1: 
 2896: void
 2896: nsGenericHTMLFormElement::UpdateEditableFormControlState()
 2896: {
41675:   // nsCSSFrameConstructor::MaybeConstructLazily is based on the logic of this
41675:   // function, so should be kept in sync with that.
41675: 
 2896:   ContentEditableTristate value = GetContentEditableValue();
 2896:   if (value != eInherit) {
11494:     SetEditableFlag(!!value);
 2896: 
 2896:     return;
 2896:   }
 2896: 
 2896:   nsIContent *parent = GetParent();
14215: 
14215:   if (parent && parent->HasFlag(NODE_IS_EDITABLE)) {
14215:     SetEditableFlag(PR_TRUE);
14215:     return;
14215:   }
14215: 
42192:   if (!IsTextControl(PR_FALSE)) {
14215:     SetEditableFlag(PR_FALSE);
14215:     return;
14215:   }
14215: 
 2896:   // If not contentEditable we still need to check the readonly attribute.
 2896:   PRBool roState;
 2896:   GetBoolAttr(nsGkAtoms::readonly, &roState);
 2896: 
14215:   SetEditableFlag(!roState);
 2896: }
    1: 
    1: 
    1: /* static */ const nsGenericHTMLElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sCommonAttributeMap[] = {
 2896:   { &nsGkAtoms::contenteditable },
    1:   { &nsGkAtoms::lang },
48696:   { &nsGkAtoms::hidden },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sImageMarginSizeAttributeMap[] = {
    1:   { &nsGkAtoms::width },
    1:   { &nsGkAtoms::height },
    1:   { &nsGkAtoms::hspace },
    1:   { &nsGkAtoms::vspace },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sImageAlignAttributeMap[] = {
    1:   { &nsGkAtoms::align },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sDivAlignAttributeMap[] = {
    1:   { &nsGkAtoms::align },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sImageBorderAttributeMap[] = {
    1:   { &nsGkAtoms::border },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sBackgroundAttributeMap[] = {
    1:   { &nsGkAtoms::background },
    1:   { &nsGkAtoms::bgcolor },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sBackgroundColorAttributeMap[] = {
    1:   { &nsGkAtoms::bgcolor },
    1:   { nsnull }
    1: };
    1: 
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsGenericHTMLElement::sScrollingAttributeMap[] = {
    1:   { &nsGkAtoms::scrolling },
    1:   { nsnull }
    1: };
    1: 
    1: void
    1: nsGenericHTMLElement::MapImageAlignAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                  nsRuleData* aRuleData)
    1: {
 6732:   if (aRuleData->mSIDs & (NS_STYLE_INHERIT_BIT(Display) |
 6732:                           NS_STYLE_INHERIT_BIT(TextReset))) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
    1:     if (value && value->Type() == nsAttrValue::eEnum) {
    1:       PRInt32 align = value->GetEnumValue();
 6732:       if ((aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) &&
 6732:           aRuleData->mDisplayData->mFloat.GetUnit() == eCSSUnit_Null) {
    1:         if (align == NS_STYLE_TEXT_ALIGN_LEFT)
    1:           aRuleData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_LEFT, eCSSUnit_Enumerated);
    1:         else if (align == NS_STYLE_TEXT_ALIGN_RIGHT)
    1:           aRuleData->mDisplayData->mFloat.SetIntValue(NS_STYLE_FLOAT_RIGHT, eCSSUnit_Enumerated);
    1:       }
 6732:       if ((aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) &&
 6732:           aRuleData->mTextData->mVerticalAlign.GetUnit() == eCSSUnit_Null) {
    1:         switch (align) {
    1:         case NS_STYLE_TEXT_ALIGN_LEFT:
    1:         case NS_STYLE_TEXT_ALIGN_RIGHT:
    1:           break;
    1:         default:
    1:           aRuleData->mTextData->mVerticalAlign.SetIntValue(align, eCSSUnit_Enumerated);
    1:           break;
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapDivAlignAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                nsRuleData* aRuleData)
    1: {
 6732:   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
    1:     if (aRuleData->mTextData->mTextAlign.GetUnit() == eCSSUnit_Null) {
    1:       // align: enum
    1:       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
    1:       if (value && value->Type() == nsAttrValue::eEnum)
    1:         aRuleData->mTextData->mTextAlign.SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: void
    1: nsGenericHTMLElement::MapImageMarginAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                   nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)))
    1:     return;
    1: 
    1:   const nsAttrValue* value;
    1: 
    1:   // hspace: value
    1:   value = aAttributes->GetAttr(nsGkAtoms::hspace);
    1:   if (value) {
    1:     nsCSSValue hval;
    1:     if (value->Type() == nsAttrValue::eInteger)
    1:       hval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
    1:     else if (value->Type() == nsAttrValue::ePercent)
    1:       hval.SetPercentValue(value->GetPercentValue());
    1: 
    1:     if (hval.GetUnit() != eCSSUnit_Null) {
    1:       nsCSSRect& margin = aData->mMarginData->mMargin;
    1:       if (margin.mLeft.GetUnit() == eCSSUnit_Null)
    1:         margin.mLeft = hval;
    1:       if (margin.mRight.GetUnit() == eCSSUnit_Null)
    1:         margin.mRight = hval;
    1:     }
    1:   }
    1: 
    1:   // vspace: value
    1:   value = aAttributes->GetAttr(nsGkAtoms::vspace);
    1:   if (value) {
    1:     nsCSSValue vval;
    1:     if (value->Type() == nsAttrValue::eInteger)
    1:       vval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
    1:     else if (value->Type() == nsAttrValue::ePercent)
    1:       vval.SetPercentValue(value->GetPercentValue());
    1:   
    1:     if (vval.GetUnit() != eCSSUnit_Null) {
    1:       nsCSSRect& margin = aData->mMarginData->mMargin;
    1:       if (margin.mTop.GetUnit() == eCSSUnit_Null)
    1:         margin.mTop = vval;
    1:       if (margin.mBottom.GetUnit() == eCSSUnit_Null)
    1:         margin.mBottom = vval;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapImageSizeAttributesInto(const nsMappedAttributes* aAttributes,
    1:                                                  nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)))
    1:     return;
    1: 
    1:   // width: value
    1:   if (aData->mPositionData->mWidth.GetUnit() == eCSSUnit_Null) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
    1:     if (value && value->Type() == nsAttrValue::eInteger)
    1:       aData->mPositionData->mWidth.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
    1:     else if (value && value->Type() == nsAttrValue::ePercent)
    1:       aData->mPositionData->mWidth.SetPercentValue(value->GetPercentValue());
    1:   }
    1: 
    1:   // height: value
    1:   if (aData->mPositionData->mHeight.GetUnit() == eCSSUnit_Null) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
    1:     if (value && value->Type() == nsAttrValue::eInteger)
    1:       aData->mPositionData->mHeight.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
    1:     else if (value && value->Type() == nsAttrValue::ePercent)
    1:       aData->mPositionData->mHeight.SetPercentValue(value->GetPercentValue());    
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapImageBorderAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                   nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)))
    1:     return;
    1: 
    1:   // border: pixels
    1:   const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::border);
    1:   if (!value)
    1:     return;
    1:   
    1:   nscoord val = 0;
    1:   if (value->Type() == nsAttrValue::eInteger)
    1:     val = value->GetIntegerValue();
    1: 
    1:   nsCSSRect& borderWidth = aData->mMarginData->mBorderWidth;
    1:   if (borderWidth.mLeft.GetUnit() == eCSSUnit_Null)
    1:     borderWidth.mLeft.SetFloatValue((float)val, eCSSUnit_Pixel);
    1:   if (borderWidth.mTop.GetUnit() == eCSSUnit_Null)
    1:     borderWidth.mTop.SetFloatValue((float)val, eCSSUnit_Pixel);
    1:   if (borderWidth.mRight.GetUnit() == eCSSUnit_Null)
    1:     borderWidth.mRight.SetFloatValue((float)val, eCSSUnit_Pixel);
    1:   if (borderWidth.mBottom.GetUnit() == eCSSUnit_Null)
    1:     borderWidth.mBottom.SetFloatValue((float)val, eCSSUnit_Pixel);
    1: 
    1:   nsCSSRect& borderStyle = aData->mMarginData->mBorderStyle;
    1:   if (borderStyle.mLeft.GetUnit() == eCSSUnit_Null)
    1:     borderStyle.mLeft.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
    1:   if (borderStyle.mTop.GetUnit() == eCSSUnit_Null)
    1:     borderStyle.mTop.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
    1:   if (borderStyle.mRight.GetUnit() == eCSSUnit_Null)
    1:     borderStyle.mRight.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
    1:   if (borderStyle.mBottom.GetUnit() == eCSSUnit_Null)
    1:     borderStyle.mBottom.SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
    1: 
    1:   nsCSSRect& borderColor = aData->mMarginData->mBorderColor;
    1:   if (borderColor.mLeft.GetUnit() == eCSSUnit_Null)
    1:     borderColor.mLeft.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
    1:   if (borderColor.mTop.GetUnit() == eCSSUnit_Null)
    1:     borderColor.mTop.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
    1:   if (borderColor.mRight.GetUnit() == eCSSUnit_Null)
    1:     borderColor.mRight.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
    1:   if (borderColor.mBottom.GetUnit() == eCSSUnit_Null)
    1:     borderColor.mBottom.SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapBackgroundInto(const nsMappedAttributes* aAttributes,
    1:                                         nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
    1:     return;
    1: 
 8088:   nsPresContext* presContext = aData->mPresContext;
50931:   if (aData->mColorData->mBackImage.GetUnit() == eCSSUnit_Null &&
50931:       presContext->UseDocumentColors()) {
    1:     // background
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::background);
    1:     if (value && value->Type() == nsAttrValue::eString) {
    1:       const nsString& spec = value->GetStringValue();
    1:       if (!spec.IsEmpty()) {
    1:         // Resolve url to an absolute url
    1:         // XXX this breaks if the HTML element has an xml:base
    1:         // attribute (the xml:base will not be taken into account)
    1:         // as well as elements with _baseHref set. We need to be able
    1:         // to get to the element somehow, or store the base URI in the
    1:         // attributes.
 8088:         nsIDocument* doc = presContext->Document();
    1:         nsCOMPtr<nsIURI> uri;
    1:         nsresult rv = nsContentUtils::NewURIWithDocumentCharset(
41900:             getter_AddRefs(uri), spec, doc, doc->GetDocBaseURI());
    1:         if (NS_SUCCEEDED(rv)) {
    1:           // Note that this should generally succeed here, due to the way
    1:           // |spec| is created.  Maybe we should just add an nsStringBuffer
    1:           // accessor on nsAttrValue?
    1:           nsStringBuffer* buffer = nsCSSValue::BufferFromString(spec);
    1:           if (NS_LIKELY(buffer != 0)) {
 1036:             // XXXbz it would be nice to assert that doc->NodePrincipal() is
 1036:             // the same as the principal of the node (which we'd need to store
 1036:             // in the mapped attrs or something?)
    1:             nsCSSValue::Image *img =
    1:               new nsCSSValue::Image(uri, buffer, doc->GetDocumentURI(),
 3076:                                     doc->NodePrincipal(), doc);
    1:             buffer->Release();
    1:             if (NS_LIKELY(img != 0)) {
50931:               nsCSSValueList* list =
50931:                 aData->mColorData->mBackImage.SetListValue();
50931:               list->mValue.SetImageValue(img);
    1:             }
    1:           }
    1:         }
    1:       }
 8088:       else if (presContext->CompatibilityMode() == eCompatibility_NavQuirks) {
    1:         // in NavQuirks mode, allow the empty string to set the
    1:         // background to empty
50931:         nsCSSValueList* list = aData->mColorData->mBackImage.SetListValue();
50931:         list->mValue.SetNoneValue();
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapBGColorInto(const nsMappedAttributes* aAttributes,
    1:                                      nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
    1:     return;
    1: 
29266:   if (aData->mColorData->mBackColor.GetUnit() == eCSSUnit_Null &&
 8088:       aData->mPresContext->UseDocumentColors()) {
    1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bgcolor);
    1:     nscolor color;
    1:     if (value && value->GetColorValue(color)) {
29266:       aData->mColorData->mBackColor.SetColorValue(color);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapBackgroundAttributesInto(const nsMappedAttributes* aAttributes,
    1:                                                   nsRuleData* aData)
    1: {
    1:   MapBackgroundInto(aAttributes, aData);
    1:   MapBGColorInto(aAttributes, aData);
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::MapScrollingAttributeInto(const nsMappedAttributes* aAttributes,
    1:                                                 nsRuleData* aData)
    1: {
 6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)))
    1:     return;
    1: 
    1:   // scrolling
    1:   nsCSSValue* overflowValues[2] = {
    1:     &aData->mDisplayData->mOverflowX,
    1:     &aData->mDisplayData->mOverflowY,
    1:   };
    1:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(overflowValues); ++i) {
    1:     if (overflowValues[i]->GetUnit() == eCSSUnit_Null) {
    1:       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::scrolling);
    1:       if (value && value->Type() == nsAttrValue::eEnum) {
    1:         PRInt32 mappedValue;
    1:         switch (value->GetEnumValue()) {
    1:           case NS_STYLE_FRAME_ON:
    1:           case NS_STYLE_FRAME_SCROLL:
    1:           case NS_STYLE_FRAME_YES:
    1:             mappedValue = NS_STYLE_OVERFLOW_SCROLL;
    1:             break;
    1: 
    1:           case NS_STYLE_FRAME_OFF:
    1:           case NS_STYLE_FRAME_NOSCROLL:
    1:           case NS_STYLE_FRAME_NO:
    1:             mappedValue = NS_STYLE_OVERFLOW_HIDDEN;
    1:             break;
    1:         
    1:           case NS_STYLE_FRAME_AUTO:
    1:             mappedValue = NS_STYLE_OVERFLOW_AUTO;
    1:             break;
    1: 
    1:           default:
    1:             NS_NOTREACHED("unexpected value");
    1:             mappedValue = NS_STYLE_OVERFLOW_AUTO;
    1:             break;
    1:         }
    1:         overflowValues[i]->SetIntValue(mappedValue, eCSSUnit_Enumerated);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetAttrHelper(nsIAtom* aAttr, nsAString& aValue)
    1: {
    1:   GetAttr(kNameSpaceID_None, aAttr, aValue);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetAttrHelper(nsIAtom* aAttr, const nsAString& aValue)
    1: {
    1:   return SetAttr(kNameSpaceID_None, aAttr, aValue, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetStringAttrWithDefault(nsIAtom* aAttr,
    1:                                                const char* aDefault,
    1:                                                nsAString& aResult)
    1: {
    1:   if (!GetAttr(kNameSpaceID_None, aAttr, aResult)) {
    1:     CopyASCIItoUTF16(aDefault, aResult);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetBoolAttr(nsIAtom* aAttr, PRBool aValue)
    1: {
    1:   if (aValue) {
    1:     return SetAttr(kNameSpaceID_None, aAttr, EmptyString(), PR_TRUE);
    1:   }
    1: 
    1:   return UnsetAttr(kNameSpaceID_None, aAttr, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetBoolAttr(nsIAtom* aAttr, PRBool* aValue) const
    1: {
    1:   *aValue = HasAttr(kNameSpaceID_None, aAttr);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetIntAttr(nsIAtom* aAttr, PRInt32 aDefault, PRInt32* aResult)
    1: {
    1:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
    1:   if (attrVal && attrVal->Type() == nsAttrValue::eInteger) {
    1:     *aResult = attrVal->GetIntegerValue();
    1:   }
    1:   else {
    1:     *aResult = aDefault;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::SetIntAttr(nsIAtom* aAttr, PRInt32 aValue)
    1: {
    1:   nsAutoString value;
    1:   value.AppendInt(aValue);
    1: 
    1:   return SetAttr(kNameSpaceID_None, aAttr, value, PR_TRUE);
    1: }
    1: 
    1: nsresult
15751: nsGenericHTMLElement::GetFloatAttr(nsIAtom* aAttr, float aDefault, float* aResult)
15751: {
15751:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
15751:   if (attrVal && attrVal->Type() == nsAttrValue::eFloatValue) {
15751:     *aResult = attrVal->GetFloatValue();
15751:   }
15751:   else {
15751:     *aResult = aDefault;
15751:   }
15751:   return NS_OK;
15751: }
15751: 
15751: nsresult
15751: nsGenericHTMLElement::SetFloatAttr(nsIAtom* aAttr, float aValue)
15751: {
15751:   nsAutoString value;
15751:   value.AppendFloat(aValue);
15751: 
15751:   return SetAttr(kNameSpaceID_None, aAttr, value, PR_TRUE);
15751: }
15751: 
15751: nsresult
    1: nsGenericHTMLElement::GetURIAttr(nsIAtom* aAttr, nsIAtom* aBaseAttr, nsAString& aResult)
    1: {
25979:   nsCOMPtr<nsIURI> uri;
26909:   PRBool hadAttr = GetURIAttr(aAttr, aBaseAttr, PR_FALSE, getter_AddRefs(uri));
56659:   if (!hadAttr) {
    1:     aResult.Truncate();
    1:     return NS_OK;
    1:   }
    1: 
56659:   if (!uri) {
56659:     // Just return the attr value
56659:     GetAttr(kNameSpaceID_None, aAttr, aResult);
56659:     return NS_OK;
56659:   }
56659: 
25979:   nsCAutoString spec;
25979:   uri->GetSpec(spec);
25979:   CopyUTF8toUTF16(spec, aResult);
25979:   return NS_OK;
25979: }
25979: 
25979: PRBool
25979: nsGenericHTMLElement::GetURIAttr(nsIAtom* aAttr, nsIAtom* aBaseAttr,
26909:                                  PRBool aCloneIfCached, nsIURI** aURI) const
25979: {
25979:   *aURI = nsnull;
25979: 
25979:   const nsAttrValue* attr = mAttrsAndChildren.GetAttr(aAttr);
25979:   if (!attr) {
25979:     return PR_FALSE;
25979:   }
25979: 
    1:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
    1: 
    1:   if (aBaseAttr) {
    1:     nsAutoString baseAttrValue;
    1:     if (GetAttr(kNameSpaceID_None, aBaseAttr, baseAttrValue)) {
    1:       nsCOMPtr<nsIURI> baseAttrURI;
25979:       nsresult rv =
25979:         nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(baseAttrURI),
    1:                                                   baseAttrValue, GetOwnerDoc(),
    1:                                                   baseURI);
    1:       if (NS_FAILED(rv)) {
25979:         return PR_TRUE;
    1:       }
    1:       baseURI.swap(baseAttrURI);
    1:     }
    1:   }
    1: 
25979:   // Don't care about return value.  If it fails, we still want to
25979:   // return PR_TRUE, and *aURI will be null.
25979:   nsContentUtils::NewURIWithDocumentCharset(aURI,
25979:                                             attr->GetStringValue(),
25979:                                             GetOwnerDoc(), baseURI);
25979:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetURIListAttr(nsIAtom* aAttr, nsAString& aResult)
    1: {
    1:   aResult.Truncate();
    1: 
    1:   nsAutoString value;
    1:   if (!GetAttr(kNameSpaceID_None, aAttr, value))
    1:     return NS_OK;
    1: 
    1:   nsIDocument* doc = GetOwnerDoc(); 
    1:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
    1: 
    1:   // Value contains relative URIs split on spaces (U+0020)
    1:   const PRUnichar *start = value.BeginReading();
    1:   const PRUnichar *end   = value.EndReading();
    1:   const PRUnichar *iter  = start;
    1:   for (;;) {
    1:     if (iter < end && *iter != ' ') {
    1:       ++iter;
    1:     } else {  // iter is pointing at either end or a space
    1:       while (*start == ' ' && start < iter)
    1:         ++start;
    1:       if (iter != start) {
    1:         if (!aResult.IsEmpty())
    1:           aResult.Append(PRUnichar(' '));
    1:         const nsSubstring& uriPart = Substring(start, iter);
    1:         nsCOMPtr<nsIURI> attrURI;
    1:         nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(attrURI),
    1:                                                   uriPart, doc, baseURI);
    1:         if (attrURI) {
    1:           nsCAutoString spec;
    1:           attrURI->GetSpec(spec);
    1:           AppendUTF8toUTF16(spec, aResult);
    1:         } else {
    1:           aResult.Append(uriPart);
    1:         }
    1:       }
    1:       start = iter = iter + 1;
    1:       if (iter >= end)
    1:         break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 2896: nsresult
41437: nsGenericHTMLElement::GetEnumAttr(nsIAtom* aAttr,
41437:                                   const char* aDefault,
41437:                                   nsAString& aResult)
41437: {
41437:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
41437: 
41437:   aResult.Truncate();
41437: 
41437:   if (attrVal && attrVal->Type() == nsAttrValue::eEnum) {
41437:     attrVal->GetEnumString(aResult, PR_TRUE);
41437:   } else {
41437:     AppendASCIItoUTF16(nsDependentCString(aDefault), aResult);
41437:   }
41437: 
41437:   return NS_OK;
41437: }
41437: 
41437: nsresult
 2896: nsGenericHTMLElement::GetContentEditable(nsAString& aContentEditable)
 2896: {
 2896:   ContentEditableTristate value = GetContentEditableValue();
 2896: 
 2896:   if (value == eTrue) {
 2896:     aContentEditable.AssignLiteral("true");
 2896:   }
 2896:   else if (value == eFalse) {
 2896:     aContentEditable.AssignLiteral("false");
 2896:   }
 2896:   else {
 2896:     aContentEditable.AssignLiteral("inherit");
 2896:   }
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
 2896: nsresult
 2896: nsGenericHTMLElement::SetContentEditable(const nsAString& aContentEditable)
 2896: {
 2896:   nsString contentEditable;
 2896:   ToLowerCase(aContentEditable, contentEditable);
 2896: 
 2896:   if (contentEditable.EqualsLiteral("inherit")) {
 2896:     UnsetAttr(kNameSpaceID_None, nsGkAtoms::contenteditable, PR_TRUE);
 2896: 
 2896:     return NS_OK;
 2896:   }
 2896: 
 2896:   if (!contentEditable.EqualsLiteral("true") &&
 2896:       !contentEditable.EqualsLiteral("false")) {
 2896:     return NS_ERROR_DOM_SYNTAX_ERR;
 2896:   }
 2896: 
 2896:   SetAttr(kNameSpaceID_None, nsGkAtoms::contenteditable, contentEditable,
 2896:           PR_TRUE);
 2896: 
 2896:   return NS_OK;
 2896: }
 2896: 
39457: nsresult
39457: nsGenericHTMLElement::GetIsContentEditable(PRBool* aContentEditable)
39457: {
39457:   NS_ENSURE_ARG_POINTER(aContentEditable);
39457: 
39457:   for (nsIContent* node = this; node; node = node->GetParent()) {
39457:     nsGenericHTMLElement* element = FromContent(node);
39457:     if (element) {
39457:       ContentEditableTristate value = element->GetContentEditableValue();
39457:       if (value != eInherit) {
39457:         *aContentEditable = value == eTrue;
39457:         return NS_OK;
39457:       }
39457:     }
39457:   }
39457: 
39457:   *aContentEditable = PR_FALSE;
39457:   return NS_OK;
39457: }
39457: 
    1: //----------------------------------------------------------------------
    1: 
56074: NS_IMPL_INT_ATTR(nsGenericHTMLFrameElement, TabIndex, tabindex)
    1: 
48124: nsGenericHTMLFormElement::nsGenericHTMLFormElement(already_AddRefed<nsINodeInfo> aNodeInfo)
54342:   : nsGenericHTMLElement(aNodeInfo)
54342:   , mForm(nsnull)
54342:   , mFieldSet(nsnull)
    1: {
    1: }
    1: 
    1: nsGenericHTMLFormElement::~nsGenericHTMLFormElement()
    1: {
56935:   if (mFieldSet) {
56935:     static_cast<nsHTMLFieldSetElement*>(mFieldSet)->RemoveElement(this);
56935:   }
56935: 
33311:   // Check that this element doesn't know anything about its form at this point.
54342:   NS_ASSERTION(!mForm, "mForm should be null at this point!");
    1: }
    1: 
 4838: NS_IMPL_QUERY_INTERFACE_INHERITED1(nsGenericHTMLFormElement,
 4838:                                    nsGenericHTMLElement,
 4838:                                    nsIFormControl)
    1: 
    1: PRBool
    1: nsGenericHTMLFormElement::IsNodeOfType(PRUint32 aFlags) const
    1: {
41646:   return !(aFlags & ~(eCONTENT | eHTML_FORM_CONTROL));
    1: }
    1: 
 8462: void
14188: nsGenericHTMLFormElement::SaveSubtreeState()
 8462: {
 8462:   SaveState();
 8462: 
14188:   nsGenericHTMLElement::SaveSubtreeState();
 8462: }
 8462: 
19131: void
19131: nsGenericHTMLFormElement::SetForm(nsIDOMHTMLFormElement* aForm)
19131: {
19131:   NS_PRECONDITION(aForm, "Don't pass null here");
19131:   NS_ASSERTION(!mForm,
19131:                "We don't support switching from one non-null form to another.");
19131: 
19131:   // keep a *weak* ref to the form here
34395:   mForm = static_cast<nsHTMLFormElement*>(aForm);
19131: }
19131: 
19131: void
19131: nsGenericHTMLFormElement::ClearForm(PRBool aRemoveFromForm,
    1:                                     PRBool aNotify)
    1: {
19131:   NS_ASSERTION((mForm != nsnull) == HasFlag(ADDED_TO_FORM),
19131:                "Form control should have had flag set correctly");
19131: 
19131:   if (!mForm) {
19131:     return;
19131:   }
19131:   
18976:   if (aRemoveFromForm) {
    1:     nsAutoString nameVal, idVal;
    1:     GetAttr(kNameSpaceID_None, nsGkAtoms::name, nameVal);
    1:     GetAttr(kNameSpaceID_None, nsGkAtoms::id, idVal);
 4014: 
55187:     mForm->RemoveElement(this, true, aNotify);
    1: 
    1:     if (!nameVal.IsEmpty()) {
    1:       mForm->RemoveElementFromTable(this, nameVal);
    1:     }
    1: 
    1:     if (!idVal.IsEmpty()) {
    1:       mForm->RemoveElementFromTable(this, idVal);
    1:     }
18976:   }
 4014: 
 4014:   UnsetFlags(ADDED_TO_FORM);
18976:   mForm = nsnull;
    1: }
    1: 
47801: Element*
47801: nsGenericHTMLFormElement::GetFormElement()
47801: {
47801:   return mForm;
47801: }
47801: 
47801: nsresult
    1: nsGenericHTMLFormElement::GetForm(nsIDOMHTMLFormElement** aForm)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aForm);
34395:   NS_IF_ADDREF(*aForm = mForm);
    1:   return NS_OK;
    1: }
    1: 
    1: PRUint32
    1: nsGenericHTMLFormElement::GetDesiredIMEState()
    1: {
    1:   nsCOMPtr<nsIEditor> editor = nsnull;
    1:   nsresult rv = GetEditorInternal(getter_AddRefs(editor));
    1:   if (NS_FAILED(rv) || !editor)
    1:     return nsGenericHTMLElement::GetDesiredIMEState();
    1:   nsCOMPtr<nsIEditorIMESupport> imeEditor = do_QueryInterface(editor);
    1:   if (!imeEditor)
    1:     return nsGenericHTMLElement::GetDesiredIMEState();
    1:   PRUint32 state;
    1:   rv = imeEditor->GetPreferredIMEState(&state);
    1:   if (NS_FAILED(rv))
    1:     return nsGenericHTMLElement::GetDesiredIMEState();
    1:   return state;
    1: }
    1: 
    1: PRBool
43884: nsGenericHTMLFrameElement::IsHTMLFocusable(PRBool aWithMouse,
43884:                                            PRBool *aIsFocusable,
14348:                                            PRInt32 *aTabIndex)
    1: {
43884:   if (nsGenericHTMLElement::IsHTMLFocusable(aWithMouse, aIsFocusable, aTabIndex)) {
14348:     return PR_TRUE;
    1:   }
    1: 
55189:   *aIsFocusable = nsContentUtils::IsSubDocumentTabbable(this);
55189: 
55189:   if (!*aIsFocusable && aTabIndex) {
    1:     *aTabIndex = -1;
    1:   }
    1: 
14348:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFormElement::BindToTree(nsIDocument* aDocument,
    1:                                      nsIContent* aParent,
    1:                                      nsIContent* aBindingParent,
    1:                                      PRBool aCompileEventHandlers)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
    1:                                                  aBindingParent,
    1:                                                  aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
42460: 
42460:   // An autofocus event has to be launched if the autofocus attribute is
42460:   // specified and the element accept the autofocus attribute. In addition,
42460:   // the document should not be already loaded and the "browser.autofocus"
42460:   // preference should be 'true'.
42460:   if (AcceptAutofocus() && HasAttr(kNameSpaceID_None, nsGkAtoms::autofocus) &&
42460:       aDocument &&
42460:       aDocument->GetReadyStateEnum() != nsIDocument::READYSTATE_COMPLETE &&
42460:       nsContentUtils::GetBoolPref("browser.autofocus", PR_TRUE)) {
42460:     nsCOMPtr<nsIRunnable> event = new nsAutoFocusEvent(this);
42460:     rv = NS_DispatchToCurrentThread(event);
42460:     NS_ENSURE_SUCCESS(rv, rv);
42460:   }
42460: 
51492:   // If @form is set, the element *has* to be in a document, otherwise it
51492:   // wouldn't be possible to find an element with the corresponding id.
51492:   // If @form isn't set, the element *has* to have a parent, otherwise it
51492:   // wouldn't be possible to find a form ancestor.
51496:   // We should not call UpdateFormOwner if none of these conditions are
51492:   // fulfilled.
51492:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::form) ? !!GetCurrentDoc()
51492:                                                   : !!aParent) {
51301:     UpdateFormOwner(true, nsnull);
 4014:   }
 4014: 
54342:   // Set parent fieldset which should be used for the disabled state.
54342:   UpdateFieldSet();
54342: 
 4014:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGenericHTMLFormElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
    1: {
    1:   // Save state before doing anything
    1:   SaveState();
    1:   
    1:   if (mForm) {
    1:     // Might need to unset mForm
    1:     if (aNullParent) {
    1:       // No more parent means no more form
19131:       ClearForm(PR_TRUE, PR_TRUE);
    1:     } else {
    1:       // Recheck whether we should still have an mForm.
51301:       if (HasAttr(kNameSpaceID_None, nsGkAtoms::form) ||
51301:           !FindAncestorForm(mForm)) {
19131:         ClearForm(PR_TRUE, PR_TRUE);
 7654:       } else {
 7654:         UnsetFlags(MAYBE_ORPHAN_FORM_ELEMENT);
    1:       }
    1:     }
    1:   }
    1: 
51301:   // We have to remove the form id observer if there was one.
51301:   // We will re-add one later if needed (during bind to tree).
51301:   if (nsContentUtils::HasNonEmptyAttr(this, kNameSpaceID_None,
51301:                                       nsGkAtoms::form)) {
51301:     RemoveFormIdObserver();
51301:   }
51301: 
    1:   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
54342: 
54342:   // The element might not have a fieldset anymore.
54342:   UpdateFieldSet();
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFormElement::BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                                         const nsAString* aValue, PRBool aNotify)
    1: {
    1:   if (aNameSpaceID == kNameSpaceID_None) {
    1:     nsAutoString tmp;
    1: 
    1:     // remove the control from the hashtable as needed
    1: 
    1:     if (mForm && (aName == nsGkAtoms::name || aName == nsGkAtoms::id)) {
    1:       GetAttr(kNameSpaceID_None, aName, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->RemoveElementFromTable(this, tmp);
    1:       }
    1:     }
    1: 
    1:     if (mForm && aName == nsGkAtoms::type) {
 3410:       nsIDocument* doc = GetCurrentDoc();
 3410: 
    1:       GetAttr(kNameSpaceID_None, nsGkAtoms::name, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->RemoveElementFromTable(this, tmp);
    1:       }
    1: 
    1:       GetAttr(kNameSpaceID_None, nsGkAtoms::id, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->RemoveElementFromTable(this, tmp);
    1:       }
    1: 
55187:       mForm->RemoveElement(this, false, aNotify);
 3410: 
 3410:       // Removing the element from the form can make it not be the default
 3410:       // control anymore.  Go ahead and notify on that change, though we might
 3410:       // end up readding and becoming the default control again in
 3410:       // AfterSetAttr.
 3410:       if (doc && aNotify) {
52197:         MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, PR_TRUE);
 3410:         doc->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_DEFAULT);
 3410:       }
    1:     }
51301: 
51301:     if (aName == nsGkAtoms::form) {
51301:       // If @form isn't set or set to the empty string, there were no observer
51301:       // so we don't have to remove it.
51301:       if (nsContentUtils::HasNonEmptyAttr(this, kNameSpaceID_None,
51301:                                           nsGkAtoms::form)) {
51301:         // The current form id observer is no longer needed.
51301:         // A new one may be added in AfterSetAttr.
51301:         RemoveFormIdObserver();
51301:       }
51301:     }
    1:   }
    1: 
    1:   return nsGenericHTMLElement::BeforeSetAttr(aNameSpaceID, aName,
    1:                                              aValue, aNotify);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFormElement::AfterSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                                        const nsAString* aValue, PRBool aNotify)
    1: {
    1:   if (aNameSpaceID == kNameSpaceID_None) {
    1:     // add the control to the hashtable as needed
    1: 
    1:     if (mForm && (aName == nsGkAtoms::name || aName == nsGkAtoms::id) &&
    1:         aValue) {
    1:       if (!aValue->IsEmpty()) {
    1:         mForm->AddElementToTable(this, *aValue);
    1:       }
    1:     }
    1: 
    1:     if (mForm && aName == nsGkAtoms::type) {
    1:       nsIDocument* doc = GetDocument();
    1:       nsAutoString tmp;
    1: 
    1:       GetAttr(kNameSpaceID_None, nsGkAtoms::name, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->AddElementToTable(this, tmp);
    1:       }
    1: 
    1:       GetAttr(kNameSpaceID_None, nsGkAtoms::id, tmp);
    1: 
    1:       if (!tmp.IsEmpty()) {
    1:         mForm->AddElementToTable(this, tmp);
    1:       }
    1: 
55187:       mForm->AddElement(this, false, aNotify);
    1: 
 3410:       // Adding the element to the form can make it be the default control .
 3410:       // Go ahead and notify on that change.
    1:       // Note: no need to notify on CanBeDisabled(), since type attr
    1:       // changes can't affect that.
    1:       if (doc && aNotify) {
52197:         MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, PR_TRUE);
    1:         doc->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_DEFAULT);
    1:       }
    1:     }
51301: 
51301:     if (aName == nsGkAtoms::form) {
51301:       // We need a new form id observer.
51301:       nsIDocument* doc = GetCurrentDoc();
51301:       if (doc) {
51301:         Element* formIdElement = nsnull;
51301:         if (aValue && !aValue->IsEmpty()) {
51301:           formIdElement = AddFormIdObserver();
51301:         }
51301: 
51301:         // Because we have a new @form value (or no more @form), we have to
51301:         // update our form owner.
51301:         UpdateFormOwner(false, formIdElement);
51301:       }
51301:     }
    1:   }
    1: 
    1:   return nsGenericHTMLElement::AfterSetAttr(aNameSpaceID, aName,
    1:                                             aValue, aNotify);
    1: }
    1: 
29018: nsresult
29018: nsGenericHTMLFormElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
29018: {
29018:   if (NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
29018:     switch (aVisitor.mEvent->message) {
29018:       case NS_FOCUS_CONTENT:
29018:       {
29018:         // Check to see if focus has bubbled up from a form control's
29018:         // child textfield or button.  If that's the case, don't focus
29018:         // this parent file control -- leave focus on the child.
29018:         nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
29018:         if (formControlFrame &&
29018:             aVisitor.mEvent->originalTarget == static_cast<nsINode*>(this))
29018:           formControlFrame->SetFocus(PR_TRUE, PR_TRUE);
29018:         break;
29018:       }
29018:       case NS_BLUR_CONTENT:
29018:       {
29018:         nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
29018:         if (formControlFrame)
29018:           formControlFrame->SetFocus(PR_FALSE, PR_FALSE);
29018:         break;
29018:       }
29018:     }
29018:   }
29018: 
29018:   return nsGenericHTMLElement::PreHandleEvent(aVisitor);
29018: }
29018: 
    1: PRBool
    1: nsGenericHTMLFormElement::CanBeDisabled() const
    1: {
    1:   PRInt32 type = GetType();
    1:   // It's easier to test the types that _cannot_ be disabled
    1:   return
    1:     type != NS_FORM_LABEL &&
41438:     type != NS_FORM_OBJECT &&
41438:     type != NS_FORM_OUTPUT;
    1: }
    1: 
    1: PRBool
    1: nsGenericHTMLFormElement::IsSubmitControl() const
    1: {
    1:   PRInt32 type = GetType();
    1:   return type == NS_FORM_INPUT_SUBMIT ||
    1:          type == NS_FORM_BUTTON_SUBMIT ||
    1:          type == NS_FORM_INPUT_IMAGE;
    1: }
    1: 
42192: PRBool
42192: nsGenericHTMLFormElement::IsTextControl(PRBool aExcludePassword) const
42192: {
42192:   PRInt32 type = GetType();
42192:   return nsGenericHTMLFormElement::IsSingleLineTextControl(aExcludePassword) ||
42192:          type == NS_FORM_TEXTAREA;
42192: }
42192: 
42192: PRBool
43129: nsGenericHTMLFormElement::IsSingleLineTextControlInternal(PRBool aExcludePassword,
43129:                                                           PRInt32 aType) const
43129: {
43129:   return aType == NS_FORM_INPUT_TEXT ||
50907:          aType == NS_FORM_INPUT_EMAIL ||
43129:          aType == NS_FORM_INPUT_SEARCH ||
43129:          aType == NS_FORM_INPUT_TEL ||
50909:          aType == NS_FORM_INPUT_URL ||
43129:          (!aExcludePassword && aType == NS_FORM_INPUT_PASSWORD);
43129: }
43129: 
43129: PRBool
42192: nsGenericHTMLFormElement::IsSingleLineTextControl(PRBool aExcludePassword) const
42192: {
43129:   return IsSingleLineTextControlInternal(aExcludePassword, GetType());
42192: }
42192: 
42487: PRBool
42487: nsGenericHTMLFormElement::IsLabelableControl() const
42487: {
42487:   // Check for non-labelable form controls as they are not numerous.
42487:   // TODO: datalist should be added to this list.
42487:   PRInt32 type = GetType();
42487:   return type != NS_FORM_FIELDSET &&
42487:          type != NS_FORM_LABEL &&
43117:          type != NS_FORM_OBJECT;
42487: }
42487: 
51181: PRBool
51181: nsGenericHTMLFormElement::IsSubmittableControl() const
51181: {
51181:   // TODO: keygen should be in that list, see bug 101019.
51181:   PRInt32 type = GetType();
51181:   return type == NS_FORM_OBJECT ||
51181:          type == NS_FORM_TEXTAREA ||
51181:          type == NS_FORM_SELECT ||
51181:          type & NS_FORM_BUTTON_ELEMENT ||
51181:          type & NS_FORM_INPUT_ELEMENT;
51181: }
51181: 
56168: nsEventStates
    1: nsGenericHTMLFormElement::IntrinsicState() const
    1: {
    1:   // If you add attribute-dependent states here, you need to add them them to
    1:   // AfterSetAttr too.  And add them to AfterSetAttr for all subclasses that
    1:   // implement IntrinsicState() and are affected by that attribute.
56168:   nsEventStates state = nsGenericHTMLElement::IntrinsicState();
    1: 
    1:   if (CanBeDisabled()) {
    1:     // :enabled/:disabled
54342:     if (IsDisabled()) {
    1:       state |= NS_EVENT_STATE_DISABLED;
    1:       state &= ~NS_EVENT_STATE_ENABLED;
    1:     } else {
    1:       state &= ~NS_EVENT_STATE_DISABLED;
    1:       state |= NS_EVENT_STATE_ENABLED;
    1:     }
    1:   }
    1:   
32864:   if (mForm && mForm->IsDefaultSubmitElement(this)) {
    1:       NS_ASSERTION(IsSubmitControl(),
    1:                    "Default submit element that isn't a submit control.");
    1:       // We are the default submit element (:default)
    1:       state |= NS_EVENT_STATE_DEFAULT;
    1:   }
    1: 
    1:   return state;
    1: }
    1: 
20109: nsGenericHTMLFormElement::FocusTristate
20109: nsGenericHTMLFormElement::FocusState()
20109: {
20109:   // We can't be focused if we aren't in a document
20109:   nsIDocument* doc = GetCurrentDoc();
20109:   if (!doc)
20109:     return eUnfocusable;
20109: 
20109:   // first see if we are disabled or not. If disabled then do nothing.
54342:   if (IsDisabled()) {
20109:     return eUnfocusable;
20109:   }
20109: 
20109:   // If the window is not active, do not allow the focus to bring the
20109:   // window to the front.  We update the focus controller, but do
20109:   // nothing else.
30219:   nsPIDOMWindow* win = doc->GetWindow();
30219:   if (win) {
30219:     nsCOMPtr<nsIDOMWindow> rootWindow = do_QueryInterface(win->GetPrivateRoot());
29018: 
29018:     nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:     if (fm && rootWindow) {
29018:       nsCOMPtr<nsIDOMWindow> activeWindow;
29018:       fm->GetActiveWindow(getter_AddRefs(activeWindow));
29018:       if (activeWindow == rootWindow) {
29018:         return eActiveWindow;
29018:       }
29018:     }
29018:   }
20109: 
20109:   return eInactiveWindow;
20109: }
20109: 
51301: Element*
51301: nsGenericHTMLFormElement::AddFormIdObserver()
51301: {
51301:   NS_ASSERTION(GetCurrentDoc(), "When adding a form id observer, "
51301:                                 "we should be in a document!");
51301: 
51301:   nsAutoString formId;
51301:   nsIDocument* doc = GetOwnerDoc();
51301:   GetAttr(kNameSpaceID_None, nsGkAtoms::form, formId);
51301:   NS_ASSERTION(!formId.IsEmpty(),
51301:                "@form value should not be the empty string!");
51301:   nsCOMPtr<nsIAtom> atom = do_GetAtom(formId);
51301: 
51301:   return doc->AddIDTargetObserver(atom, FormIdUpdated, this, PR_FALSE);
51301: }
51301: 
51301: void
51301: nsGenericHTMLFormElement::RemoveFormIdObserver()
51301: {
51301:   /**
51301:    * We are using GetOwnerDoc() because we don't really care about having the
51301:    * element actually being in the tree. If it is not and @form value changes,
51301:    * this method will be called for nothing but removing an observer which does
51301:    * not exist doesn't cost so much (no entry in the hash table) so having a
51301:    * boolean for GetCurrentDoc()/GetOwnerDoc() would make everything look more
51301:    * complex for nothing.
51301:    */
51301: 
51301:   nsIDocument* doc = GetOwnerDoc();
51301: 
51301:   // At this point, we may not have a document anymore. In that case, we can't
51301:   // remove the observer. The document did that for us.
51301:   if (!doc) {
51301:     return;
51301:   }
51301: 
51301:   nsAutoString formId;
51301:   GetAttr(kNameSpaceID_None, nsGkAtoms::form, formId);
51301:   NS_ASSERTION(!formId.IsEmpty(),
51301:                "@form value should not be the empty string!");
51301:   nsCOMPtr<nsIAtom> atom = do_GetAtom(formId);
51301: 
51301:   doc->RemoveIDTargetObserver(atom, FormIdUpdated, this, PR_FALSE);
51301: }
51301: 
51301: 
51301: /* static */
51301: PRBool
51301: nsGenericHTMLFormElement::FormIdUpdated(Element* aOldElement,
51301:                                         Element* aNewElement,
51301:                                         void* aData)
51301: {
51301:   nsGenericHTMLFormElement* element =
51301:     static_cast<nsGenericHTMLFormElement*>(aData);
51301: 
51301:   NS_ASSERTION(element->IsHTML(), "aData should be an HTML element");
51301: 
51301:   element->UpdateFormOwner(false, aNewElement);
51301: 
51301:   return PR_TRUE;
51301: }
51301: 
51301: void
51301: nsGenericHTMLFormElement::UpdateFormOwner(bool aBindToTree,
51301:                                           Element* aFormIdElement)
51301: {
51301:   NS_PRECONDITION(!aBindToTree || !aFormIdElement,
51301:                   "aFormIdElement shouldn't be set if aBindToTree is true!");
51301: 
51301:   bool hadForm = mForm;
51301: 
51301:   if (!aBindToTree) {
51301:     // TODO: we should get ride of this aNotify parameter, bug 589977.
51301:     ClearForm(PR_TRUE, PR_TRUE);
51301:   }
51301: 
51301:   if (!mForm) {
51301:     // If @form is set, we have to use that to find the form.
51301:     nsAutoString formId;
51301:     if (GetAttr(kNameSpaceID_None, nsGkAtoms::form, formId)) {
51301:       if (!formId.IsEmpty()) {
51301:         Element* element = nsnull;
51301: 
51301:         if (aBindToTree) {
51301:           element = AddFormIdObserver();
51301:         } else {
51301:           element = aFormIdElement;
51301:         }
51301: 
51301:         NS_ASSERTION(GetCurrentDoc(), "The element should be in a document "
51301:                                       "when UpdateFormOwner is called!");
51492:         NS_ASSERTION(!GetCurrentDoc() ||
51492:                      element == GetCurrentDoc()->GetElementById(formId),
51301:                      "element should be equals to the current element "
51301:                      "associated with the id in @form!");
51301: 
51301:         if (element && element->Tag() == nsGkAtoms::form &&
51301:             element->IsHTML()) {
51301:           mForm = static_cast<nsHTMLFormElement*>(element);
51301:         }
51301:       }
51301:      } else {
51301:       // We now have a parent, so we may have picked up an ancestor form.  Search
51301:       // for it.  Note that if mForm is already set we don't want to do this,
51301:       // because that means someone (probably the content sink) has already set
51301:       // it to the right value.  Also note that even if being bound here didn't
51301:       // change our parent, we still need to search, since our parent chain
51301:       // probably changed _somewhere_.
51301:       mForm = FindAncestorForm();
51301:     }
51301:   }
51301: 
51301:   if (mForm && !HasFlag(ADDED_TO_FORM)) {
51301:     // Now we need to add ourselves to the form
51301:     nsAutoString nameVal, idVal;
51301:     GetAttr(kNameSpaceID_None, nsGkAtoms::name, nameVal);
51301:     GetAttr(kNameSpaceID_None, nsGkAtoms::id, idVal);
51301: 
51301:     SetFlags(ADDED_TO_FORM);
51301: 
51301:     // Notify only if we just found this mForm.
55187:     mForm->AddElement(this, true, !hadForm);
51301: 
51301:     if (!nameVal.IsEmpty()) {
51301:       mForm->AddElementToTable(this, nameVal);
51301:     }
51301: 
51301:     if (!idVal.IsEmpty()) {
51301:       mForm->AddElementToTable(this, idVal);
51301:     }
51301:   }
51301: }
51301: 
54342: void
54342: nsGenericHTMLFormElement::UpdateFieldSet()
54342: {
54346:   nsIContent* parent = nsnull;
54346:   nsIContent* prev = nsnull;
54346: 
54346:   for (parent = GetParent(); parent;
54346:        prev = parent, parent = parent->GetParent()) {
54342:     if (parent->IsHTML(nsGkAtoms::fieldset)) {
54346:       nsHTMLFieldSetElement* fieldset =
54346:         static_cast<nsHTMLFieldSetElement*>(parent);
54346: 
54346:       if (!prev || fieldset->GetFirstLegend() != prev) {
56935:         if (mFieldSet) {
56935:           static_cast<nsHTMLFieldSetElement*>(mFieldSet)->RemoveElement(this);
56935:         }
54346:         mFieldSet = fieldset;
56935:         fieldset->AddElement(this);
54342:         return;
54342:       }
54342:     }
54346:   }
54342: 
54342:   // No fieldset found.
56935:   if (mFieldSet) {
56935:     static_cast<nsHTMLFieldSetElement*>(mFieldSet)->RemoveElement(this);
56935:   }
54342:   mFieldSet = nsnull;
54342: }
54342: 
54342: void
56168: nsGenericHTMLFormElement::FieldSetDisabledChanged(nsEventStates aStates, PRBool aNotify)
54342: {
55188:   if (!aNotify) {
55188:     return;
55188:   }
55188: 
54342:   aStates |= NS_EVENT_STATE_DISABLED | NS_EVENT_STATE_ENABLED;
54342: 
54342:   nsIDocument* doc = GetCurrentDoc();
54342:   if (doc) {
54342:     MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, PR_TRUE);
54342:     doc->ContentStatesChanged(this, nsnull, aStates);
54342:   }
54342: }
54342: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsGenericHTMLFrameElement::~nsGenericHTMLFrameElement()
    1: {
    1:   if (mFrameLoader) {
    1:     mFrameLoader->Destroy();
    1:   }
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGenericHTMLFrameElement)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsGenericHTMLFrameElement,
    1:                                                   nsGenericHTMLElement)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFrameLoader)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
12033: NS_INTERFACE_TABLE_HEAD(nsGenericHTMLFrameElement)
12033:   NS_INTERFACE_TABLE_INHERITED2(nsGenericHTMLFrameElement,
12033:                                 nsIDOMNSHTMLFrameElement,
12033:                                 nsIFrameLoaderOwner)
12033:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsGenericHTMLFrameElement)
12033: NS_INTERFACE_MAP_END_INHERITING(nsGenericHTMLElement)
12033: 
    1: nsresult
    1: nsGenericHTMLFrameElement::GetContentDocument(nsIDOMDocument** aContentDocument)
    1: {
    1:   NS_PRECONDITION(aContentDocument, "Null out param");
    1:   *aContentDocument = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMWindow> win;
    1:   GetContentWindow(getter_AddRefs(win));
    1: 
    1:   if (!win) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return win->GetDocument(aContentDocument);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericHTMLFrameElement::GetContentWindow(nsIDOMWindow** aContentWindow)
    1: {
    1:   NS_PRECONDITION(aContentWindow, "Null out param");
    1:   *aContentWindow = nsnull;
    1: 
    1:   nsresult rv = EnsureFrameLoader();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!mFrameLoader) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRBool depthTooGreat = PR_FALSE;
    1:   mFrameLoader->GetDepthTooGreat(&depthTooGreat);
    1:   if (depthTooGreat) {
    1:     // Claim to have no contentWindow
    1:     return NS_OK;
    1:   }
    1:   
    1:   nsCOMPtr<nsIDocShell> doc_shell;
    1:   mFrameLoader->GetDocShell(getter_AddRefs(doc_shell));
    1: 
    1:   nsCOMPtr<nsPIDOMWindow> win(do_GetInterface(doc_shell));
    1: 
    1:   if (!win) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ASSERTION(win->IsOuterWindow(),
    1:                "Uh, this window should always be an outer window!");
    1: 
    1:   return CallQueryInterface(win, aContentWindow);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFrameElement::EnsureFrameLoader()
    1: {
    1:   if (!GetParent() || !IsInDoc() || mFrameLoader) {
    1:     // If frame loader is there, we just keep it around, cached
    1:     return NS_OK;
    1:   }
    1: 
50721:   mFrameLoader = nsFrameLoader::Create(this, mNetworkCreated);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericHTMLFrameElement::GetFrameLoader(nsIFrameLoader **aFrameLoader)
    1: {
    1:   NS_IF_ADDREF(*aFrameLoader = mFrameLoader);
    1:   return NS_OK;
    1: }
    1: 
34076: NS_IMETHODIMP_(already_AddRefed<nsFrameLoader>)
34076: nsGenericHTMLFrameElement::GetFrameLoader()
34076: {
34076:   nsFrameLoader* loader = mFrameLoader;
34076:   NS_IF_ADDREF(loader);
34076:   return loader;
34076: }
34076: 
16549: NS_IMETHODIMP
16549: nsGenericHTMLFrameElement::SwapFrameLoaders(nsIFrameLoaderOwner* aOtherOwner)
16549: {
16549:   // We don't support this yet
16549:   return NS_ERROR_NOT_IMPLEMENTED;
16549: }
16549: 
    1: nsresult
    1: nsGenericHTMLFrameElement::LoadSrc()
    1: {
    1:   nsresult rv = EnsureFrameLoader();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!mFrameLoader) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   rv = mFrameLoader->LoadFrame();
    1: #ifdef DEBUG
    1:   if (NS_FAILED(rv)) {
    1:     NS_WARNING("failed to load URL");
    1:   }
    1: #endif
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFrameElement::BindToTree(nsIDocument* aDocument,
    1:                                       nsIContent* aParent,
    1:                                       nsIContent* aBindingParent,
    1:                                       PRBool aCompileEventHandlers)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
    1:                                                  aBindingParent,
    1:                                                  aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aDocument) {
23256:     NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
23256:                  "Missing a script blocker!");
    1:     // We're in a document now.  Kick off the frame load.
    1:     LoadSrc();
    1:   }
    1: 
50721:   // We're now in document and scripts may move us, so clear
50721:   // the mNetworkCreated flag.
50721:   mNetworkCreated = PR_FALSE;
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsGenericHTMLFrameElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
    1: {
    1:   if (mFrameLoader) {
    1:     // This iframe is being taken out of the document, destroy the
    1:     // iframe's frame loader (doing that will tear down the window in
    1:     // this iframe).
    1:     // XXXbz we really want to only partially destroy the frame
    1:     // loader... we don't want to tear down the docshell.  Food for
    1:     // later bug.
    1:     mFrameLoader->Destroy();
    1:     mFrameLoader = nsnull;
    1:   }
    1: 
    1:   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLFrameElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                                    nsIAtom* aPrefix, const nsAString& aValue,
    1:                                    PRBool aNotify)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::SetAttr(aNameSpaceID, aName, aPrefix,
    1:                                               aValue, aNotify);
38663:   NS_ENSURE_SUCCESS(rv, rv);
38663:   
38663:   if (aNameSpaceID == kNameSpaceID_None &&
    1:       aName == nsGkAtoms::src) {
38663:     // Don't propagate error here. The attribute was successfully set, that's
38663:     // what we should reflect.
38663:     LoadSrc();
38663:   }
38663: 
38663:   return NS_OK;
    1: }
    1: 
 8462: void
 8462: nsGenericHTMLFrameElement::DestroyContent()
 8462: {
 8462:   if (mFrameLoader) {
 8462:     mFrameLoader->Destroy();
 8462:     mFrameLoader = nsnull;
 8462:   }
 8462: 
 8462:   nsGenericHTMLElement::DestroyContent();
 8462: }
 8462: 
35581: nsresult
35581: nsGenericHTMLFrameElement::CopyInnerTo(nsGenericElement* aDest) const
35581: {
35581:   nsresult rv = nsGenericHTMLElement::CopyInnerTo(aDest);
35581:   NS_ENSURE_SUCCESS(rv, rv);
35581: 
35581:   nsIDocument* doc = aDest->GetOwnerDoc();
35581:   if (doc->IsStaticDocument() && mFrameLoader) {
35581:     nsGenericHTMLFrameElement* dest =
35581:       static_cast<nsGenericHTMLFrameElement*>(aDest);
50721:     nsFrameLoader* fl = nsFrameLoader::Create(dest, PR_FALSE);
35581:     NS_ENSURE_STATE(fl);
35581:     dest->mFrameLoader = fl;
35581:     static_cast<nsFrameLoader*>(mFrameLoader.get())->CreateStaticClone(fl);
35581:   }
35581: 
35581:   return rv;
35581: }
35581: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsGenericHTMLElement::Blur()
    1: {
29018:   if (!ShouldBlur(this))
29018:     return NS_OK;
29018: 
29018:   nsIDocument* doc = GetCurrentDoc();
29018:   if (!doc)
29018:     return NS_OK;
29018: 
29018:   nsIDOMWindow* win = doc->GetWindow();
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   return (win && fm) ? fm->ClearFocus(win) : NS_OK;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::Focus()
    1: {
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(this);
29018:   return fm ? fm->SetFocus(elem, 0) : NS_OK;
    1: }
    1: 
    1: PRBool
43884: nsGenericHTMLElement::IsHTMLFocusable(PRBool aWithMouse,
43884:                                       PRBool *aIsFocusable,
43884:                                       PRInt32 *aTabIndex)
    1: {
12253:   nsIDocument *doc = GetCurrentDoc();
12253:   if (!doc || doc->HasFlag(NODE_IS_EDITABLE)) {
12253:     // In designMode documents we only allow focusing the document.
12253:     if (aTabIndex) {
12253:       *aTabIndex = -1;
12253:     }
12253: 
14348:     *aIsFocusable = PR_FALSE;
14348: 
14348:     return PR_TRUE;
12253:   }
12253: 
    1:   PRInt32 tabIndex = 0;   // Default value for non HTML elements with -moz-user-focus
    1:   GetTabIndex(&tabIndex);
    1: 
29018:   PRBool override, disabled = PR_FALSE;
 2896:   if (IsEditableRoot()) {
14348:     // Editable roots should always be focusable.
14348:     override = PR_TRUE;
14348: 
 3444:     // Ignore the disabled attribute in editable contentEditable/designMode
 3444:     // roots.
 2896:     if (!HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
 3444:       // The default value for tabindex should be 0 for editable
 3444:       // contentEditable roots.
 2896:       tabIndex = 0;
 2896:     }
 2896:   }
 2896:   else {
14348:     override = PR_FALSE;
14348: 
29018:     // Just check for disabled attribute on form controls
54342:     disabled = IsDisabled();
    1:     if (disabled) {
    1:       tabIndex = -1;
    1:     }
 2896:   }
    1: 
    1:   if (aTabIndex) {
    1:     *aTabIndex = tabIndex;
    1:   }
    1: 
    1:   // If a tabindex is specified at all, or the default tabindex is 0, we're focusable
43884:   *aIsFocusable = 
43884: #ifdef XP_MACOSX
43884:     // can only focus with the mouse on Mac if editable
43884:     (!aWithMouse || override) &&
43884: #endif
43884:     (tabIndex >= 0 || (!disabled && HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)));
14348: 
14348:   return override;
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::RegUnRegAccessKey(PRBool aDoReg)
    1: {
    1:   // first check to see if we have an access key
    1:   nsAutoString accessKey;
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);
    1:   if (accessKey.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // We have an access key, so get the ESM from the pres context.
    1:   nsPresContext *presContext = GetPresContext();
    1: 
    1:   if (presContext) {
    1:     nsIEventStateManager *esm = presContext->EventStateManager();
    1: 
    1:     // Register or unregister as appropriate.
    1:     if (aDoReg) {
    1:       esm->RegisterAccessKey(this, (PRUint32)accessKey.First());
    1:     } else {
    1:       esm->UnregisterAccessKey(this, (PRUint32)accessKey.First());
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::PerformAccesskey(PRBool aKeyCausesActivation,
    1:                                        PRBool aIsTrustedEvent)
    1: {
    1:   nsPresContext *presContext = GetPresContext();
    1:   if (!presContext)
    1:     return;
    1: 
    1:   // It's hard to say what HTML4 wants us to do in all cases.
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm) {
29018:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(this);
29018:     fm->SetFocus(elem, nsIFocusManager::FLAG_BYKEY);
29018:   }
    1: 
    1:   if (aKeyCausesActivation) {
    1:     // Click on it if the users prefs indicate to do so.
    1:     nsMouseEvent event(aIsTrustedEvent, NS_MOUSE_CLICK,
    1:                        nsnull, nsMouseEvent::eReal);
40485:     event.inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_KEYBOARD;
    1: 
    1:     nsAutoPopupStatePusher popupStatePusher(aIsTrustedEvent ?
    1:                                             openAllowed : openAbused);
    1: 
    1:     nsEventDispatcher::Dispatch(this, presContext, &event);
    1:   }
    1: }
    1: 
    1: const nsAttrName*
    1: nsGenericHTMLElement::InternalGetExistingAttrNameFromQName(const nsAString& aStr) const
    1: {
29004:   if (IsInHTMLDocument()) {
    1:     nsAutoString lower;
38422:     nsContentUtils::ASCIIToLower(aStr, lower);
39101:     return mAttrsAndChildren.GetExistingAttrNameFromQName(lower);
39101:   }
39101: 
39101:   return mAttrsAndChildren.GetExistingAttrNameFromQName(aStr);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetEditor(nsIEditor** aEditor)
    1: {
    1:   *aEditor = nsnull;
    1: 
    1:   if (!nsContentUtils::IsCallerTrustedForWrite())
    1:     return NS_ERROR_DOM_SECURITY_ERR;
    1: 
    1:   return GetEditorInternal(aEditor);
    1: }
    1: 
    1: nsresult
    1: nsGenericHTMLElement::GetEditorInternal(nsIEditor** aEditor)
    1: {
    1:   *aEditor = nsnull;
    1: 
43129:   nsCOMPtr<nsITextControlElement> textCtrl = do_QueryInterface(this);
43129:   if (textCtrl) {
43129:     *aEditor = textCtrl->GetTextEditor();
43129:     NS_IF_ADDREF(*aEditor);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: already_AddRefed<nsIEditor>
    1: nsGenericHTMLElement::GetAssociatedEditor()
    1: {
    1:   // If contenteditable is ever implemented, it might need to do something different here?
    1: 
    1:   nsIEditor* editor = nsnull;
    1:   GetEditorInternal(&editor);
    1:   return editor;
    1: }
    1: 
    1: PRBool
    1: nsGenericHTMLElement::IsCurrentBodyElement()
    1: {
    1:   nsCOMPtr<nsIDOMHTMLBodyElement> bodyElement = do_QueryInterface(this);
    1:   if (!bodyElement) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDocument =
    1:     do_QueryInterface(GetCurrentDoc());
    1:   if (!htmlDocument) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMHTMLElement> htmlElement;
    1:   htmlDocument->GetBody(getter_AddRefs(htmlElement));
    1:   return htmlElement == bodyElement;
    1: }
    1: 
    1: // static
    1: void
    1: nsGenericHTMLElement::SyncEditorsOnSubtree(nsIContent* content)
    1: {
    1:   /* Sync this node */
    1:   nsGenericHTMLElement* element = FromContent(content);
    1:   if (element) {
    1:     nsCOMPtr<nsIEditor> editor = element->GetAssociatedEditor();
    1:     if (editor) {
    1:       editor->SyncRealTimeSpell();
    1:     }
    1:   }
    1: 
    1:   /* Sync all children */
    1:   PRUint32 childCount = content->GetChildCount();
    1:   for (PRUint32 i = 0; i < childCount; ++i) {
    1:     nsIContent* childContent = content->GetChildAt(i);
    1:     NS_ASSERTION(childContent,
    1:                  "DOM mutated unexpectedly while syncing editors!");
    1:     if (childContent) {
    1:       SyncEditorsOnSubtree(childContent);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericHTMLElement::RecompileScriptEventListeners()
    1: {
    1:     PRInt32 i, count = mAttrsAndChildren.AttrCount();
    1:     for (i = 0; i < count; ++i) {
    1:         const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
    1: 
    1:         // Eventlistenener-attributes are always in the null namespace
    1:         if (!name->IsAtom()) {
    1:             continue;
    1:         }
    1: 
    1:         nsIAtom *attr = name->Atom();
  265:         if (!nsContentUtils::IsEventAttributeName(attr, EventNameType_HTML)) {
    1:             continue;
    1:         }
    1: 
    1:         nsAutoString value;
    1:         GetAttr(kNameSpaceID_None, attr, value);
    1:         AddScriptEventListener(attr, value, PR_TRUE);
    1:     }
    1: }
 2896: 
 2896: PRBool
 2896: nsGenericHTMLElement::IsEditableRoot() const
 2896: {
 2896:   nsIDocument *document = GetCurrentDoc();
 2896:   if (!document) {
 2896:     return PR_FALSE;
 2896:   }
 2896: 
 2896:   if (document->HasFlag(NODE_IS_EDITABLE)) {
10469:     return PR_FALSE;
 2896:   }
 2896: 
 3444:   if (GetContentEditableValue() != eTrue) {
 2896:     return PR_FALSE;
 2896:   }
 2896: 
 2896:   nsIContent *parent = GetParent();
 2896: 
 2896:   return !parent || !parent->HasFlag(NODE_IS_EDITABLE);
 2896: }
 2896: 
 2896: static void
 2896: MakeContentDescendantsEditable(nsIContent *aContent, nsIDocument *aDocument)
 2896: {
56168:   nsEventStates stateBefore = aContent->IntrinsicState();
 2896: 
 2896:   aContent->UpdateEditableState();
 2896: 
 2896:   if (aDocument && stateBefore != aContent->IntrinsicState()) {
 2896:     aDocument->ContentStatesChanged(aContent, nsnull,
 2896:                                     NS_EVENT_STATE_MOZ_READONLY |
 2896:                                     NS_EVENT_STATE_MOZ_READWRITE);
 2896:   }
 2896: 
 2896:   PRUint32 i, n = aContent->GetChildCount();
 2896:   for (i = 0; i < n; ++i) {
 2896:     nsIContent *child = aContent->GetChildAt(i);
 2896:     if (!child->HasAttr(kNameSpaceID_None, nsGkAtoms::contenteditable)) {
 2896:       MakeContentDescendantsEditable(child, aDocument);
 2896:     }
 2896:   }
 2896: }
 2896: 
 2896: void
 2896: nsGenericHTMLElement::ChangeEditableState(PRInt32 aChange)
 2896: {
 2896:   nsIDocument* document = GetCurrentDoc();
 2896:   if (!document) {
 2896:     return;
 2896:   }
 2896: 
 2896:   if (aChange != 0) {
 2896:     nsCOMPtr<nsIHTMLDocument> htmlDocument =
 2896:       do_QueryInterface(document);
 2896:     if (htmlDocument) {
 2896:       htmlDocument->ChangeContentEditableCount(this, aChange);
 2896:     }
 2896:   }
 2896: 
 2896:   if (document->HasFlag(NODE_IS_EDITABLE)) {
 2896:     document = nsnull;
 2896:   }
 2896: 
52197:   // MakeContentDescendantsEditable is going to call ContentStatesChanged for
52197:   // this element and all descendants if editable state has changed.
52197:   // We have to create a document update batch now so it's created once.
52197:   MOZ_AUTO_DOC_UPDATE(document, UPDATE_CONTENT_STATE, PR_TRUE);
 2896:   MakeContentDescendantsEditable(this, document);
 2896: }
