    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
42553: #include "nsIMemoryReporter.h"
42553: #include "nsMemory.h"
68851: #include "CheckedInt.h"
42553: 
    1: #include "gfxASurface.h"
63368: #include "gfxContext.h"
63368: #include "gfxImageSurface.h"
    1: 
63368: #include "nsRect.h"
    1: 
    1: #include "cairo.h"
    1: 
    1: #ifdef CAIRO_HAS_WIN32_SURFACE
    1: #include "gfxWindowsSurface.h"
    1: #endif
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727: #include "gfxD2DSurface.h"
38727: #endif
    1: 
29462: #ifdef MOZ_X11
    1: #include "gfxXlibSurface.h"
    1: #endif
    1: 
  314: #ifdef CAIRO_HAS_QUARTZ_SURFACE
    1: #include "gfxQuartzSurface.h"
11244: #include "gfxQuartzImageSurface.h"
    1: #endif
    1: 
29462: #ifdef MOZ_DFB
16526: #include "gfxDirectFBSurface.h"
16526: #endif
16526: 
54377: #if defined(CAIRO_HAS_QT_SURFACE) && defined(MOZ_WIDGET_QT)
16763: #include "gfxQPainterSurface.h"
16763: #endif
16763: 
    1: #include <stdio.h>
 7123: #include <limits.h>
    1: 
63844: #include "imgIEncoder.h"
63844: #include "nsComponentManagerUtils.h"
63844: #include "gfxContext.h"
63844: #include "prmem.h"
63844: #include "nsISupportsUtils.h"
63844: #include "plbase64.h"
63844: #include "nsCOMPtr.h"
63844: #include "nsIConsoleService.h"
63844: #include "nsServiceManagerUtils.h"
63844: 
68851: using mozilla::CheckedInt;
68851: 
    1: static cairo_user_data_key_t gfxasurface_pointer_key;
    1: 
    1: // Surfaces use refcounting that's tied to the cairo surface refcnt, to avoid
    1: // refcount mismatch issues.
    1: nsrefcnt
    1: gfxASurface::AddRef(void)
    1: {
 1349:     if (mSurfaceValid) {
 1349:         if (mFloatingRefs) {
 1349:             // eat a floating ref
 1349:             mFloatingRefs--;
    1:         } else {
    1:             cairo_surface_reference(mSurface);
    1:         }
    1: 
    1:         return (nsrefcnt) cairo_surface_get_reference_count(mSurface);
 1349:     } else {
 1349:         // the surface isn't valid, but we still need to refcount
 1349:         // the gfxASurface
 1349:         return ++mFloatingRefs;
 1349:     }
    1: }
    1: 
    1: nsrefcnt
    1: gfxASurface::Release(void)
    1: {
 1349:     if (mSurfaceValid) {
 1349:         NS_ASSERTION(mFloatingRefs == 0, "gfxASurface::Release with floating refs still hanging around!");
 1349: 
    1:         // Note that there is a destructor set on user data for mSurface,
    1:         // which will delete this gfxASurface wrapper when the surface's refcount goes
    1:         // out of scope.
    1:         nsrefcnt refcnt = (nsrefcnt) cairo_surface_get_reference_count(mSurface);
    1:         cairo_surface_destroy(mSurface);
    1: 
    1:         // |this| may not be valid any more, don't use it!
    1: 
    1:         return --refcnt;
 1349:     } else {
 1349:         if (--mFloatingRefs == 0) {
 1349:             delete this;
 1349:             return 0;
 1349:         }
 1349: 
 1349:         return mFloatingRefs;
 1349:     }
    1: }
    1: 
    1: void
    1: gfxASurface::SurfaceDestroyFunc(void *data) {
    1:     gfxASurface *surf = (gfxASurface*) data;
    1:     // fprintf (stderr, "Deleting wrapper for %p (wrapper: %p)\n", surf->mSurface, data);
    1:     delete surf;
    1: }
    1: 
    1: gfxASurface*
    1: gfxASurface::GetSurfaceWrapper(cairo_surface_t *csurf)
    1: {
74333:     if (!csurf)
74333:         return NULL;
    1:     return (gfxASurface*) cairo_surface_get_user_data(csurf, &gfxasurface_pointer_key);
    1: }
    1: 
    1: void
    1: gfxASurface::SetSurfaceWrapper(cairo_surface_t *csurf, gfxASurface *asurf)
    1: {
74333:     if (!csurf)
74333:         return;
    1:     cairo_surface_set_user_data(csurf, &gfxasurface_pointer_key, asurf, SurfaceDestroyFunc);
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: gfxASurface::Wrap (cairo_surface_t *csurf)
    1: {
    1:     gfxASurface *result;
    1: 
    1:     /* Do we already have a wrapper for this surface? */
    1:     result = GetSurfaceWrapper(csurf);
    1:     if (result) {
    1:         // fprintf(stderr, "Existing wrapper for %p -> %p\n", csurf, result);
    1:         NS_ADDREF(result);
    1:         return result;
    1:     }
    1: 
    1:     /* No wrapper; figure out the surface type and create it */
    1:     cairo_surface_type_t stype = cairo_surface_get_type(csurf);
    1: 
    1:     if (stype == CAIRO_SURFACE_TYPE_IMAGE) {
    1:         result = new gfxImageSurface(csurf);
    1:     }
    1: #ifdef CAIRO_HAS_WIN32_SURFACE
 6274:     else if (stype == CAIRO_SURFACE_TYPE_WIN32 ||
 6274:              stype == CAIRO_SURFACE_TYPE_WIN32_PRINTING) {
    1:         result = new gfxWindowsSurface(csurf);
    1:     }
    1: #endif
38727: #ifdef CAIRO_HAS_D2D_SURFACE
38727:     else if (stype == CAIRO_SURFACE_TYPE_D2D) {
38727:         result = new gfxD2DSurface(csurf);
38727:     }
38727: #endif
29462: #ifdef MOZ_X11
    1:     else if (stype == CAIRO_SURFACE_TYPE_XLIB) {
    1:         result = new gfxXlibSurface(csurf);
    1:     }
    1: #endif
  314: #ifdef CAIRO_HAS_QUARTZ_SURFACE
  314:     else if (stype == CAIRO_SURFACE_TYPE_QUARTZ) {
    1:         result = new gfxQuartzSurface(csurf);
    1:     }
11244:     else if (stype == CAIRO_SURFACE_TYPE_QUARTZ_IMAGE) {
11244:         result = new gfxQuartzImageSurface(csurf);
11244:     }
    1: #endif
29462: #ifdef MOZ_DFB
16526:     else if (stype == CAIRO_SURFACE_TYPE_DIRECTFB) {
16526:         result = new gfxDirectFBSurface(csurf);
16526:     }
16526: #endif
54377: #if defined(CAIRO_HAS_QT_SURFACE) && defined(MOZ_WIDGET_QT)
33200:     else if (stype == CAIRO_SURFACE_TYPE_QT) {
16763:         result = new gfxQPainterSurface(csurf);
16763:     }
16763: #endif
    1:     else {
    1:         result = new gfxUnknownSurface(csurf);
    1:     }
    1: 
    1:     // fprintf(stderr, "New wrapper for %p -> %p\n", csurf, result);
    1: 
    1:     NS_ADDREF(result);
    1:     return result;
    1: }
    1: 
    1: void
    1: gfxASurface::Init(cairo_surface_t* surface, PRBool existingSurface)
    1: {
 1349:     if (cairo_surface_status(surface)) {
 1349:         // the surface has an error on it
 1349:         mSurfaceValid = PR_FALSE;
 1349:         cairo_surface_destroy(surface);
 1349:         return;
 1349:     }
 1349: 
    1:     SetSurfaceWrapper(surface, this);
    1: 
    1:     mSurface = surface;
 1349:     mSurfaceValid = PR_TRUE;
    1: 
    1:     if (existingSurface) {
 1349:         mFloatingRefs = 0;
    1:     } else {
 1349:         mFloatingRefs = 1;
62100: #ifdef MOZ_TREE_CAIRO
59762:         if (cairo_surface_get_content(surface) != CAIRO_CONTENT_COLOR) {
59762:             cairo_surface_set_subpixel_antialiasing(surface, CAIRO_SUBPIXEL_ANTIALIASING_DISABLED);
59762:         }
62100: #endif
    1:     }
    1: }
    1: 
    1: gfxASurface::gfxSurfaceType
    1: gfxASurface::GetType() const
    1: {
 4414:     if (!mSurfaceValid)
 4414:         return (gfxSurfaceType)-1;
 4414: 
    1:     return (gfxSurfaceType)cairo_surface_get_type(mSurface);
    1: }
    1: 
    1: gfxASurface::gfxContentType
    1: gfxASurface::GetContentType() const
    1: {
 4414:     if (!mSurfaceValid)
 4414:         return (gfxContentType)-1;
 4414: 
    1:     return (gfxContentType)cairo_surface_get_content(mSurface);
    1: }
    1: 
    1: void
    1: gfxASurface::SetDeviceOffset(const gfxPoint& offset)
    1: {
74333:     if (!mSurfaceValid)
74333:         return;
    1:     cairo_surface_set_device_offset(mSurface,
    1:                                     offset.x, offset.y);
    1: }
    1: 
    1: gfxPoint
    1: gfxASurface::GetDeviceOffset() const
    1: {
74333:     if (!mSurfaceValid)
74333:         return gfxPoint(0.0, 0.0);
    1:     gfxPoint pt;
    1:     cairo_surface_get_device_offset(mSurface, &pt.x, &pt.y);
    1:     return pt;
    1: }
    1: 
    1: void
49179: gfxASurface::Flush() const
    1: {
74333:     if (!mSurfaceValid)
74333:         return;
    1:     cairo_surface_flush(mSurface);
    1: }
    1: 
    1: void
    1: gfxASurface::MarkDirty()
    1: {
74333:     if (!mSurfaceValid)
74333:         return;
    1:     cairo_surface_mark_dirty(mSurface);
    1: }
    1: 
    1: void
    1: gfxASurface::MarkDirty(const gfxRect& r)
    1: {
74333:     if (!mSurfaceValid)
74333:         return;
    1:     cairo_surface_mark_dirty_rectangle(mSurface,
68632:                                        (int) r.X(), (int) r.Y(),
68632:                                        (int) r.Width(), (int) r.Height());
    1: }
    1: 
    1: void
    1: gfxASurface::SetData(const cairo_user_data_key_t *key,
    1:                      void *user_data,
    1:                      thebes_destroy_func_t destroy)
    1: {
74333:     if (!mSurfaceValid)
74333:         return;
    1:     cairo_surface_set_user_data(mSurface, key, user_data, destroy);
    1: }
    1: 
    1: void *
    1: gfxASurface::GetData(const cairo_user_data_key_t *key)
    1: {
74333:     if (!mSurfaceValid)
74333:         return NULL;
    1:     return cairo_surface_get_user_data(mSurface, key);
    1: }
    1: 
    1: void
    1: gfxASurface::Finish()
    1: {
74333:     // null surfaces are allowed here
    1:     cairo_surface_finish(mSurface);
    1: }
 1349: 
42960: already_AddRefed<gfxASurface>
42960: gfxASurface::CreateSimilarSurface(gfxContentType aContent,
42960:                                   const gfxIntSize& aSize)
42960: {
59394:     if (!mSurface || !mSurfaceValid) {
59394:       return nsnull;
59394:     }
59394:     
42960:     cairo_surface_t *surface =
42960:         cairo_surface_create_similar(mSurface, cairo_content_t(aContent),
42960:                                      aSize.width, aSize.height);
42960:     if (cairo_surface_status(surface)) {
42960:         cairo_surface_destroy(surface);
42960:         return nsnull;
42960:     }
42960: 
43774:     nsRefPtr<gfxASurface> result = Wrap(surface);
43774:     cairo_surface_destroy(surface);
43774:     return result.forget();
42960: }
42960: 
 1349: int
 1355: gfxASurface::CairoStatus()
 1349: {
 1349:     if (!mSurfaceValid)
 1349:         return -1;
 1349: 
 1349:     return cairo_surface_status(mSurface);
 1349: }
 1349: 
 1349: /* static */
 1349: PRBool
 1349: gfxASurface::CheckSurfaceSize(const gfxIntSize& sz, PRInt32 limit)
 1349: {
 1486:     if (sz.width < 0 || sz.height < 0) {
 3068:         NS_WARNING("Surface width or height < 0!");
 1349:         return PR_FALSE;
 1486:     }
 1349: 
68851:     // reject images with sides bigger than limit
68851:     if (limit && (sz.width > limit || sz.height > limit)) {
68851:         NS_WARNING("Surface size too large (exceeds caller's limit)!");
68851:         return PR_FALSE;
68851:     }
68851: 
 7123: #if defined(XP_MACOSX)
68851:     // CoreGraphics is limited to images < 32K in *height*,
68851:     // so clamp all surfaces on the Mac to that height
 7123:     if (sz.height > SHRT_MAX) {
68851:         NS_WARNING("Surface size too large (exceeds CoreGraphics limit)!");
 7123:         return PR_FALSE;
 7123:     }
 7123: #endif
 7123: 
68851:     // make sure the surface area doesn't overflow a PRInt32
68851:     CheckedInt<PRInt32> tmp = sz.width;
68851:     tmp *= sz.height;
68851:     if (!tmp.valid()) {
 3068:         NS_WARNING("Surface size too large (would overflow)!");
 1349:         return PR_FALSE;
 1486:     }
 1349: 
68851:     // assuming 4-byte stride, make sure the allocation size
68851:     // doesn't overflow a PRInt32 either
68851:     tmp *= 4;
68851:     if (!tmp.valid()) {
68851:         NS_WARNING("Allocation too large (would overflow)!");
 1349:         return PR_FALSE;
 1486:     }
 1349: 
 1349:     return PR_TRUE;
 1349: }
 6313: 
63416: /* static */
63416: PRInt32
63416: gfxASurface::FormatStrideForWidth(gfxImageFormat format, PRInt32 width)
63416: {
63416:     return cairo_format_stride_for_width((cairo_format_t)format, (int)width);
63416: }
63416: 
 6313: nsresult
 6313: gfxASurface::BeginPrinting(const nsAString& aTitle, const nsAString& aPrintToFileName)
 6313: {
13658:     return NS_OK;
 6313: }
 6313: 
 6313: nsresult
 6313: gfxASurface::EndPrinting()
 6313: {
13658:     return NS_OK;
 6313: }
 6313: 
 6313: nsresult
 6313: gfxASurface::AbortPrinting()
 6313: {
13658:     return NS_OK;
 6313: }
 6313: 
 6313: nsresult
 6313: gfxASurface::BeginPage()
 6313: {
13658:     return NS_OK;
 6313: }
 6313: 
 6313: nsresult
 6313: gfxASurface::EndPage()
 6313: {
13658:     return NS_OK;
 6313: }
16930: 
16930: gfxASurface::gfxContentType
16930: gfxASurface::ContentFromFormat(gfxImageFormat format)
16930: {
16930:     switch (format) {
16930:         case ImageFormatARGB32:
16930:             return CONTENT_COLOR_ALPHA;
16930:         case ImageFormatRGB24:
43558:         case ImageFormatRGB16_565:
16930:             return CONTENT_COLOR;
16930:         case ImageFormatA8:
16930:         case ImageFormatA1:
16930:             return CONTENT_ALPHA;
16930: 
16930:         case ImageFormatUnknown:
16930:         default:
16930:             return CONTENT_COLOR;
16930:     }
16930: }
42553: 
54253: gfxASurface::gfxImageFormat
54253: gfxASurface::FormatFromContent(gfxASurface::gfxContentType type)
54253: {
54253:     switch (type) {
54253:         case CONTENT_COLOR_ALPHA:
54253:             return ImageFormatARGB32;
54253:         case CONTENT_ALPHA:
54253:             return ImageFormatA8;
54253:         case CONTENT_COLOR:
54253:         default:
54253:             return ImageFormatRGB24;
54253:     }
54253: }
54253: 
59763: void
59763: gfxASurface::SetSubpixelAntialiasingEnabled(PRBool aEnabled)
59763: {
62100: #ifdef MOZ_TREE_CAIRO
59763:     if (!mSurfaceValid)
59763:         return;
59763:     cairo_surface_set_subpixel_antialiasing(mSurface,
59763:         aEnabled ? CAIRO_SUBPIXEL_ANTIALIASING_ENABLED : CAIRO_SUBPIXEL_ANTIALIASING_DISABLED);
62100: #endif
59763: }
59763: 
59763: PRBool
59763: gfxASurface::GetSubpixelAntialiasingEnabled()
59763: {
59763:     if (!mSurfaceValid)
59763:       return PR_FALSE;
62100: #ifdef MOZ_TREE_CAIRO
59763:     return cairo_surface_get_subpixel_antialiasing(mSurface) == CAIRO_SUBPIXEL_ANTIALIASING_ENABLED;
62100: #else
62100:     return PR_TRUE;
62100: #endif
59763: }
59763: 
43558: PRInt32
43558: gfxASurface::BytePerPixelFromFormat(gfxImageFormat format)
43558: {
43558:     switch (format) {
43558:         case ImageFormatARGB32:
43558:         case ImageFormatRGB24:
43558:             return 4;
43558:         case ImageFormatRGB16_565:
43558:             return 2;
43558:         case ImageFormatA8:
43558:             return 1;
43558:         default:
43558:             NS_WARNING("Unknown byte per pixel value for Image format");
43558:     }
43558:     return 0;
43558: }
43558: 
63368: void
69453: gfxASurface::FastMovePixels(const nsIntRect& aSourceRect,
63368:                             const nsIntPoint& aDestTopLeft)
63368: {
69453:     // Used when the backend can internally handle self copies.
63368:     gfxIntSize size = GetSize();
63368:     nsIntRect dest(aDestTopLeft, aSourceRect.Size());
69453:     
63368:     nsRefPtr<gfxContext> ctx = new gfxContext(this);
63368:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
63368:     nsIntPoint srcOrigin = dest.TopLeft() - aSourceRect.TopLeft();
63368:     ctx->SetSource(this, gfxPoint(srcOrigin.x, srcOrigin.y));
63368:     ctx->Rectangle(gfxRect(dest.x, dest.y, dest.width, dest.height));
63368:     ctx->Fill();
63368: }
63368: 
69453: void
69453: gfxASurface::MovePixels(const nsIntRect& aSourceRect,
69453:                         const nsIntPoint& aDestTopLeft)
69453: {
69453:     // Assume the backend can't handle self copying well and allocate
69453:     // a temporary surface instead.
69453:     nsRefPtr<gfxASurface> tmp = 
69453:       CreateSimilarSurface(GetContentType(), 
69453:                            gfxIntSize(aSourceRect.width, aSourceRect.height));
69453:     nsRefPtr<gfxContext> ctx = new gfxContext(tmp);
69453:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
69453:     ctx->SetSource(this, gfxPoint(-aSourceRect.x, -aSourceRect.y));
69453:     ctx->Paint();
69453: 
69453:     ctx = new gfxContext(this);
69453:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
69453:     ctx->SetSource(tmp, gfxPoint(aDestTopLeft.x, aDestTopLeft.y));
69453:     ctx->Rectangle(gfxRect(aDestTopLeft.x, 
69453:                            aDestTopLeft.y, 
69453:                            aSourceRect.width, 
69453:                            aSourceRect.height));
69453:     ctx->Fill();
69453: }
69453: 
42553: /** Memory reporting **/
42553: 
74071: static const char *sSurfaceNamesForSurfaceType[] = {
74071:     "gfx-surface-image",
74071:     "gfx-surface-pdf",
74071:     "gfx-surface-ps",
74071:     "gfx-surface-xlib",
74071:     "gfx-surface-xcb",
74071:     "gfx-surface-glitz",
74071:     "gfx-surface-quartz",
74071:     "gfx-surface-win32",
74071:     "gfx-surface-beos",
74071:     "gfx-surface-directfb",
74071:     "gfx-surface-svg",
74071:     "gfx-surface-os2",
74071:     "gfx-surface-win32printing",
74071:     "gfx-surface-quartzimage",
74071:     "gfx-surface-script",
74071:     "gfx-surface-qpainter",
74071:     "gfx-surface-recording",
74071:     "gfx-surface-vg",
74071:     "gfx-surface-gl",
74071:     "gfx-surface-drm",
74071:     "gfx-surface-tee",
74071:     "gfx-surface-xml",
74071:     "gfx-surface-skia",
74071:     "gfx-surface-subsurface",
74071:     "gfx-surface-d2d"
42553: };
42553: 
74071: PR_STATIC_ASSERT(NS_ARRAY_LENGTH(sSurfaceNamesForSurfaceType) == gfxASurface::SurfaceTypeMax);
52263: #ifdef CAIRO_HAS_D2D_SURFACE
74071: PR_STATIC_ASSERT(PRUint32(CAIRO_SURFACE_TYPE_D2D) == PRUint32(gfxASurface::SurfaceTypeD2D));
52263: #endif
74071: PR_STATIC_ASSERT(PRUint32(CAIRO_SURFACE_TYPE_SKIA) == PRUint32(gfxASurface::SurfaceTypeSkia));
42553: 
42553: static const char *
42553: SurfaceMemoryReporterPathForType(gfxASurface::gfxSurfaceType aType)
42553: {
42553:     if (aType < 0 ||
42553:         aType >= gfxASurface::SurfaceTypeMax)
71379:         return "gfx-surface-unknown";
42553: 
74071:     return sSurfaceNamesForSurfaceType[aType];
42553: }
42553: 
42553: /* Surface size memory reporting */
42553: static nsIMemoryReporter *gSurfaceMemoryReporters[gfxASurface::SurfaceTypeMax] = { 0 };
42553: static PRInt64 gSurfaceMemoryUsed[gfxASurface::SurfaceTypeMax] = { 0 };
42553: 
42553: class SurfaceMemoryReporter :
42553:     public nsIMemoryReporter
42553: {
42553: public:
42553:     SurfaceMemoryReporter(gfxASurface::gfxSurfaceType aType)
42553:         : mType(aType)
42553:     { }
42553: 
42553:     NS_DECL_ISUPPORTS
42553: 
73566:     NS_IMETHOD GetProcess(nsACString &process) {
73566:         process.Truncate();
71287:         return NS_OK;
71287:     }
71287: 
73566:     NS_IMETHOD GetPath(nsACString &path) {
73566:         path.Assign(SurfaceMemoryReporterPathForType(mType));
42553:         return NS_OK;
42553:     }
42553: 
70251:     NS_IMETHOD GetKind(PRInt32 *kind) {
72640:         *kind = KIND_OTHER;
72640:         return NS_OK;
72640:     }
72640:     
72640:     NS_IMETHOD GetUnits(PRInt32 *units) {
72640:         *units = UNITS_BYTES;
72640:         return NS_OK;
72640:     }
72640: 
72640:     NS_IMETHOD GetAmount(PRInt64 *amount) {
72640:         *amount = gSurfaceMemoryUsed[mType];
70251:         return NS_OK;
70251:     }
70251: 
73566:     NS_IMETHOD GetDescription(nsACString &desc) {
74071:         desc.AssignLiteral("Memory used by gfx surface of the given type.");
42553:         return NS_OK;
42553:     }
42553: 
42553:     gfxASurface::gfxSurfaceType mType;
42553: };
42553: 
42553: NS_IMPL_ISUPPORTS1(SurfaceMemoryReporter, nsIMemoryReporter)
42553: 
42553: void
42553: gfxASurface::RecordMemoryUsedForSurfaceType(gfxASurface::gfxSurfaceType aType,
42553:                                             PRInt32 aBytes)
42553: {
42553:     if (aType < 0 || aType >= SurfaceTypeMax) {
42553:         NS_WARNING("Invalid type to RecordMemoryUsedForSurfaceType!");
42553:         return;
42553:     }
42553: 
42553:     if (gSurfaceMemoryReporters[aType] == 0) {
42553:         gSurfaceMemoryReporters[aType] = new SurfaceMemoryReporter(aType);
42553:         NS_RegisterMemoryReporter(gSurfaceMemoryReporters[aType]);
42553:     }
42553: 
42553:     gSurfaceMemoryUsed[aType] += aBytes;
42553: }
42553: 
42553: void
42553: gfxASurface::RecordMemoryUsed(PRInt32 aBytes)
42553: {
42553:     RecordMemoryUsedForSurfaceType(GetType(), aBytes);
42553:     mBytesRecorded += aBytes;
42553: }
42553: 
42553: void
42553: gfxASurface::RecordMemoryFreed()
42553: {
42553:     if (mBytesRecorded) {
42553:         RecordMemoryUsedForSurfaceType(GetType(), -mBytesRecorded);
42553:         mBytesRecorded = 0;
42553:     }
42553: }
63844: 
63844: void
63844: gfxASurface::DumpAsDataURL()
63844: {
63844:   gfxIntSize size = GetSize();
63844:   if (size.width == -1 && size.height == -1) {
63844:     printf("Could not determine surface size\n");
63844:     return;
63844:   }
63844: 
63844:   nsAutoArrayPtr<PRUint8> imageBuffer(new (std::nothrow) PRUint8[size.width * 
63844:                                                                  size.height * 
63844:                                                                  4]);
63844:   if (!imageBuffer) {
63844:     printf("Could not allocate image buffer\n");
63844:     return;
63844:   }
63844:  
63844:   nsRefPtr<gfxImageSurface> imgsurf = 
63844:     new gfxImageSurface(imageBuffer.get(),
63844:                         gfxIntSize(size.width, size.height),
63844:                         size.width * 4,
63844:                         gfxASurface::ImageFormatARGB32);
63844: 
63844:   if (!imgsurf || imgsurf->CairoStatus()) {
63844:     printf("Could not allocate image surface\n");
63844:     return;
63844:   }
63844: 
63844:   nsRefPtr<gfxContext> ctx = new gfxContext(imgsurf);
63844:   if (!ctx || ctx->HasError()) {
63844:     printf("Could not allocate image context\n");
63844:     return;
63844:   }
63844: 
63844:   ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
63844:   ctx->SetSource(this, gfxPoint(0, 0));
63844:   ctx->Paint();
63844: 
63844:   nsCOMPtr<imgIEncoder> encoder =
63844:     do_CreateInstance("@mozilla.org/image/encoder;2?type=image/png");
63844:   if (!encoder) {
63844:     PRInt32 w = NS_MIN(size.width, 8);
63844:     PRInt32 h = NS_MIN(size.height, 8);
63844:     printf("Could not create encoder. Printing %dx%d pixels.\n", w, h);
63844:     for (PRInt32 y = 0; y < h; ++y) {
63844:       for (PRInt32 x = 0; x < w; ++x) {
63844:         printf("%x ", reinterpret_cast<PRUint32*>(imageBuffer.get())[y*size.width + x]);
63844:       }
63844:       printf("\n");
63844:     }
63844:     return;
63844:   }
63844: 
63844:   nsresult rv = encoder->InitFromData(imageBuffer.get(),
63844:                                       size.width * size.height * 4, 
63844:                                       size.width, 
63844:                                       size.height, 
63844:                                       size.width * 4,
63844:                                       imgIEncoder::INPUT_FORMAT_HOSTARGB,
63844:                                       NS_LITERAL_STRING(""));
63844:   if (NS_FAILED(rv))
63844:     return;
63844: 
63844:   nsCOMPtr<nsIInputStream> imgStream;
63844:   CallQueryInterface(encoder.get(), getter_AddRefs(imgStream));
63844:   if (!imgStream)
63844:     return;
63844: 
63844:   PRUint32 bufSize;
63844:   rv = imgStream->Available(&bufSize);
63844:   if (NS_FAILED(rv))
63844:     return;
63844: 
63844:   // ...leave a little extra room so we can call read again and make sure we
63844:   // got everything. 16 bytes for better padding (maybe)
63844:   bufSize += 16;
63844:   PRUint32 imgSize = 0;
63844:   char* imgData = (char*)PR_Malloc(bufSize);
63844:   if (!imgData)
63844:     return;
63844:   PRUint32 numReadThisTime = 0;
63844:   while ((rv = imgStream->Read(&imgData[imgSize], 
63844:                                bufSize - imgSize,
63844:                                &numReadThisTime)) == NS_OK && numReadThisTime > 0) 
63844:   {
63844:     imgSize += numReadThisTime;
63844:     if (imgSize == bufSize) {
63844:       // need a bigger buffer, just double
63844:       bufSize *= 2;
63844:       char* newImgData = (char*)PR_Realloc(imgData, bufSize);
63844:       if (!newImgData) {
63844:         PR_Free(imgData);
63844:         return;
63844:       }
63844:       imgData = newImgData;
63844:     }
63844:   }
63844:   
63844:   // base 64, result will be NULL terminated
63844:   char* encodedImg = PL_Base64Encode(imgData, imgSize, nsnull);
63844:   PR_Free(imgData);
63844:   if (!encodedImg) // not sure why this would fail
63844:     return;
63844:  
63844:   printf("data:image/png;base64,");
63844:   printf("%s", encodedImg);
63844:   printf("\n");
63844:   PR_Free(encodedImg);
63844: 
63844:   return;
63844: }
63844: 
