29018: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
29018: /* ***** BEGIN LICENSE BLOCK *****
29018:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
29018:  *
29018:  * The contents of this file are subject to the Mozilla Public License Version
29018:  * 1.1 (the "License"); you may not use this file except in compliance with
29018:  * the License. You may obtain a copy of the License at
29018:  * http://www.mozilla.org/MPL/
29018:  *
29018:  * Software distributed under the License is distributed on an "AS IS" basis,
29018:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
29018:  * for the specific language governing rights and limitations under the
29018:  * License.
29018:  *
29018:  * The Original Code is mozila.org code.
29018:  *
36532:  * The Initial Developer of the Original Code is Mozilla Foundation
29018:  * Portions created by the Initial Developer are Copyright (C) 2008
29018:  * the Initial Developer. All Rights Reserved.
29018:  *
29018:  * Contributor(s):
29018:  *
29018:  * Alternatively, the contents of this file may be used under the terms of
29018:  * either the GNU General Public License Version 2 or later (the "GPL"), or
29018:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
29018:  * in which case the provisions of the GPL or the LGPL are applicable instead
29018:  * of those above. If you wish to allow use of your version of this file only
29018:  * under the terms of either the GPL or the LGPL, and not to allow others to
29018:  * use your version of this file under the terms of the MPL, indicate your
29018:  * decision by deleting the provisions above and replace them with the notice
29018:  * and other provisions required by the GPL or the LGPL. If you do not delete
29018:  * the provisions above, a recipient may use your version of this file under
29018:  * the terms of any one of the MPL, the GPL or the LGPL.
29018:  *
29018:  * ***** END LICENSE BLOCK ***** */
29018: 
29018: #include "nsFocusManager.h"
29018: 
29018: #include "nsIInterfaceRequestor.h"
29018: #include "nsIInterfaceRequestorUtils.h"
29018: #include "nsIServiceManager.h"
29018: #include "nsIEnumerator.h"
29018: #include "nsTPtrArray.h"
29018: #include "nsGkAtoms.h"
29018: #include "nsIPrefBranch2.h"
29018: #include "nsContentUtils.h"
29018: #include "nsIDocument.h"
29018: #include "nsIDOMWindow.h"
29018: #include "nsPIDOMWindow.h"
29018: #include "nsIDOMElement.h"
29018: #include "nsIDOMXULElement.h"
29018: #include "nsIDOMNSHTMLFrameElement.h"
29018: #include "nsIDOMHTMLInputElement.h"
29018: #include "nsIDOMHTMLMapElement.h"
29018: #include "nsIDOMHTMLLegendElement.h"
29018: #include "nsIDOMDocumentRange.h"
29018: #include "nsIDOMRange.h"
29018: #include "nsIHTMLDocument.h"
29018: #include "nsIFormControlFrame.h"
29018: #include "nsGenericHTMLElement.h"
29018: #include "nsIDocShell.h"
29018: #include "nsIEditorDocShell.h"
29018: #include "nsIDocShellTreeItem.h"
29018: #include "nsIDocShellTreeOwner.h"
29018: #include "nsLayoutUtils.h"
29018: #include "nsIPresShell.h"
29018: #include "nsIContentViewer.h"
29018: #include "nsFrameTraversal.h"
29018: #include "nsObjectFrame.h"
29018: #include "nsEventDispatcher.h"
29018: #include "nsIEventStateManager.h"
29018: #include "nsIMEStateManager.h"
29018: #include "nsIWebNavigation.h"
29018: #include "nsCaret.h"
29018: #include "nsWidgetsCID.h"
29018: #include "nsILookAndFeel.h"
29018: #include "nsIWidget.h"
29018: #include "nsIBaseWindow.h"
29018: #include "nsIViewManager.h"
29018: #include "nsFrameSelection.h"
29018: #include "nsXULPopupManager.h"
29018: #include "nsImageMapUtils.h"
35170: #include "nsTreeWalker.h"
35170: #include "nsIDOMNodeFilter.h"
41239: #include "nsIScriptObjectPrincipal.h"
41239: #include "nsIPrincipal.h"
41930: #include "mozilla/dom/Element.h"
64121: #include "mozAutoDocUpdate.h"
29018: 
29018: #ifdef MOZ_XUL
29018: #include "nsIDOMXULTextboxElement.h"
29018: #include "nsIDOMXULMenuListElement.h"
29018: #endif
29018: 
41634: using namespace mozilla::dom;
41634: 
29018: //#define DEBUG_FOCUS 1
29018: //#define DEBUG_FOCUS_NAVIGATION 1
29018: #define PRINTTAGF(format, content)                     \
29018:   {                                                    \
29018:     nsAutoString tag(NS_LITERAL_STRING("(none)"));     \
29018:     if (content)                                       \
29018:       content->Tag()->ToString(tag);                   \
29018:     printf(format, NS_ConvertUTF16toUTF8(tag).get());  \
29018:   }
29018: 
29018: struct nsDelayedBlurOrFocusEvent
29018: {
29018:   nsDelayedBlurOrFocusEvent(PRUint32 aType,
29018:                             nsIPresShell* aPresShell,
29018:                             nsIDocument* aDocument,
29018:                             nsPIDOMEventTarget* aTarget)
29018:    : mType(aType),
29018:      mPresShell(aPresShell),
29018:      mDocument(aDocument),
29018:      mTarget(aTarget) { }
29018: 
29018:   nsDelayedBlurOrFocusEvent(const nsDelayedBlurOrFocusEvent& aOther)
29018:    : mType(aOther.mType),
29018:      mPresShell(aOther.mPresShell),
29018:      mDocument(aOther.mDocument),
29018:      mTarget(aOther.mTarget) { }
29018: 
29018:   PRUint32 mType;
29018:   nsCOMPtr<nsIPresShell> mPresShell;
29018:   nsCOMPtr<nsIDocument> mDocument;
29018:   nsCOMPtr<nsPIDOMEventTarget> mTarget;
29018: };
29018: 
29018: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsFocusManager)
29018:   NS_INTERFACE_MAP_ENTRY(nsIFocusManager)
29018:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
29018:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
29018:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIFocusManager)
29018: NS_INTERFACE_MAP_END
29018: 
29018: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsFocusManager)
29018: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsFocusManager)
29018: 
29018: NS_IMPL_CYCLE_COLLECTION_CLASS(nsFocusManager)
29018: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsFocusManager)
29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mActiveWindow)
29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFocusedWindow)
29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFocusedContent)
29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFirstBlurEvent)
29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFirstFocusEvent)
29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mWindowBeingLowered)
29018: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
29018: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsFocusManager)
29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mActiveWindow)
29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFocusedWindow)
29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFocusedContent)
29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstBlurEvent)
29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstFocusEvent)
29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mWindowBeingLowered)
29018: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
29018: 
29018: static NS_DEFINE_CID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
29018: 
31541: nsFocusManager* nsFocusManager::sInstance = nsnull;
49216: PRBool nsFocusManager::sMouseFocusesFormControl = PR_FALSE;
29018: 
29018: nsFocusManager::nsFocusManager()
29018: { }
29018: 
29018: nsFocusManager::~nsFocusManager()
29018: {
37975:   nsIPrefBranch2* prefBranch = nsContentUtils::GetPrefBranch();
29018: 
29018:   if (prefBranch) {
29018:     prefBranch->RemoveObserver("accessibility.browsewithcaret", this);
29018:     prefBranch->RemoveObserver("accessibility.tabfocus_applies_to_xul", this);
49216:     prefBranch->RemoveObserver("accessibility.mouse_focuses_formcontrol", this);
29018:   }
59509:   
59509:   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
59509:   if (obs) {
59509:     obs->RemoveObserver(this, "xpcom-shutdown");
59509:   }
29018: }
29018: 
29018: // static
29018: nsresult
29018: nsFocusManager::Init()
29018: {
29018:   nsFocusManager* fm = new nsFocusManager();
29018:   NS_ENSURE_TRUE(fm, NS_ERROR_OUT_OF_MEMORY);
29018:   NS_ADDREF(fm);
29018:   sInstance = fm;
29018: 
29018:   nsIContent::sTabFocusModelAppliesToXUL =
29018:     nsContentUtils::GetBoolPref("accessibility.tabfocus_applies_to_xul",
29018:                                 nsIContent::sTabFocusModelAppliesToXUL);
29018: 
49216:   sMouseFocusesFormControl =
49216:     nsContentUtils::GetBoolPref("accessibility.mouse_focuses_formcontrol", PR_FALSE);
49216: 
37975:   nsIPrefBranch2* prefBranch = nsContentUtils::GetPrefBranch();
68552:   if (prefBranch) {
29018:     prefBranch->AddObserver("accessibility.browsewithcaret", fm, PR_TRUE);
29018:     prefBranch->AddObserver("accessibility.tabfocus_applies_to_xul", fm, PR_TRUE);
49216:     prefBranch->AddObserver("accessibility.mouse_focuses_formcontrol", fm, PR_TRUE);
68552:   }
29018: 
59509:   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
59509:   if (obs) {
59509:     obs->AddObserver(fm, "xpcom-shutdown", PR_TRUE);
59509:   }
59509: 
29018:   return NS_OK;
29018: }
29018: 
29018: // static
29018: void
29018: nsFocusManager::Shutdown()
29018: {
29018:   NS_IF_RELEASE(sInstance);
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::Observe(nsISupports *aSubject,
29018:                         const char *aTopic,
29018:                         const PRUnichar *aData)
29018: {
59509:   if (!nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
29018:     nsDependentString data(aData);
29018:     if (data.EqualsLiteral("accessibility.browsewithcaret")) {
29018:       UpdateCaret(PR_FALSE, PR_TRUE, mFocusedContent);
29018:     }
29018:     else if (data.EqualsLiteral("accessibility.tabfocus_applies_to_xul")) {
29018:       nsIContent::sTabFocusModelAppliesToXUL =
29018:         nsContentUtils::GetBoolPref("accessibility.tabfocus_applies_to_xul",
29018:                                     nsIContent::sTabFocusModelAppliesToXUL);
29018:     }
49216:     else if (data.EqualsLiteral("accessibility.mouse_focuses_formcontrol")) {
49216:       sMouseFocusesFormControl =
49216:         nsContentUtils::GetBoolPref("accessibility.mouse_focuses_formcontrol", PR_FALSE);
49216:     }
59509:   } else if (!nsCRT::strcmp(aTopic, "xpcom-shutdown")) {
59509:     mActiveWindow = nsnull;
59509:     mFocusedWindow = nsnull;
59509:     mFocusedContent = nsnull;
59509:     mFirstBlurEvent = nsnull;
59509:     mFirstFocusEvent = nsnull;
59509:     mWindowBeingLowered = nsnull;
59509:     mMouseDownEventHandlingDocument = nsnull;
29018:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: // given a frame content node, retrieve the nsIDOMWindow displayed in it 
29018: static nsPIDOMWindow*
29018: GetContentWindow(nsIContent* aContent)
29018: {
29018:   nsIDocument* doc = aContent->GetCurrentDoc();
29018:   if (doc) {
29018:     nsIDocument* subdoc = doc->GetSubDocumentFor(aContent);
29018:     if (subdoc)
29018:       return subdoc->GetWindow();
29018:   }
29018: 
29018:   return nsnull;
29018: }
29018: 
29018: // get the current window for the given content node 
29018: static nsPIDOMWindow*
29018: GetCurrentWindow(nsIContent* aContent)
29018: {
29018:   nsIDocument *doc = aContent->GetCurrentDoc();
29018:   return doc ? doc->GetWindow() : nsnull;
29018: }
29018: 
29018: // static
29018: nsIContent*
29018: nsFocusManager::GetFocusedDescendant(nsPIDOMWindow* aWindow, PRBool aDeep,
29018:                                      nsPIDOMWindow** aFocusedWindow)
29018: {
29018:   NS_ENSURE_TRUE(aWindow, nsnull);
29018: 
29018:   *aFocusedWindow = nsnull;
29018: 
29018:   nsIContent* currentContent = nsnull;
29018:   nsPIDOMWindow* window = aWindow->GetOuterWindow();
29018:   while (window) {
29018:     *aFocusedWindow = window;
29018:     currentContent = window->GetFocusedNode();
29018:     if (!currentContent || !aDeep)
29018:       break;
29018: 
29018:     window = GetContentWindow(currentContent);
29018:   }
29018: 
29018:   NS_IF_ADDREF(*aFocusedWindow);
29018: 
29018:   return currentContent;
29018: }
29018: 
29018: // static
29018: nsIContent*
29018: nsFocusManager::GetRedirectedFocus(nsIContent* aContent)
29018: {
29018: #ifdef MOZ_XUL
33329:   if (aContent->IsXUL()) {
29018:     nsCOMPtr<nsIDOMNode> inputField;
29018: 
29018:     nsCOMPtr<nsIDOMXULTextBoxElement> textbox = do_QueryInterface(aContent);
29018:     if (textbox) {
29018:       textbox->GetInputField(getter_AddRefs(inputField));
29018:     }
29018:     else {
29018:       nsCOMPtr<nsIDOMXULMenuListElement> menulist = do_QueryInterface(aContent);
29018:       if (menulist) {
29018:         menulist->GetInputField(getter_AddRefs(inputField));
29018:       }
29018:       else if (aContent->Tag() == nsGkAtoms::scale) {
29018:         nsCOMPtr<nsIDocument> doc = aContent->GetCurrentDoc();
29018:         if (!doc)
29018:           return nsnull;
29018: 
29018:         nsINodeList* children = doc->BindingManager()->GetXBLChildNodesFor(aContent);
29018:         if (children) {
29018:           nsIContent* child = children->GetNodeAt(0);
29018:           if (child && child->Tag() == nsGkAtoms::slider)
29018:             return child;
29018:         }
29018:       }
29018:     }
29018: 
29018:     if (inputField) {
29018:       nsCOMPtr<nsIContent> retval = do_QueryInterface(inputField);
29018:       return retval;
29018:     }
29018:   }
29018: #endif
29018: 
29018:   return nsnull;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::GetActiveWindow(nsIDOMWindow** aWindow)
29018: {
29018:   NS_IF_ADDREF(*aWindow = mActiveWindow);
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::SetActiveWindow(nsIDOMWindow* aWindow)
29018: {
29018:   // only top-level windows can be made active
29018:   nsCOMPtr<nsPIDOMWindow> piWindow = do_QueryInterface(aWindow);
55579:   if (piWindow)
55579:       piWindow = piWindow->GetOuterWindow();
29018: 
29018:   NS_ENSURE_TRUE(piWindow && (piWindow == piWindow->GetPrivateRoot()),
29018:                  NS_ERROR_INVALID_ARG);
29018: 
29018:   RaiseWindow(piWindow);
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::GetFocusedWindow(nsIDOMWindow** aFocusedWindow)
29018: {
29018:   NS_IF_ADDREF(*aFocusedWindow = mFocusedWindow);
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP nsFocusManager::SetFocusedWindow(nsIDOMWindow* aWindowToFocus)
29018: {
29018: #ifdef DEBUG_FOCUS
29018:   printf("<<SetFocusedWindow begin>>\n");
29018: #endif
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> windowToFocus(do_QueryInterface(aWindowToFocus));
29018:   NS_ENSURE_TRUE(windowToFocus, NS_ERROR_FAILURE);
29018: 
29018:   windowToFocus = windowToFocus->GetOuterWindow();
29018: 
29018:   nsCOMPtr<nsIContent> frameContent =
29018:     do_QueryInterface(windowToFocus->GetFrameElementInternal());
29018:   if (frameContent) {
57526:     // pass false for aFocusChanged so that the caret does not get updated
57526:     // and scrolling does not occur.
57526:     SetFocusInner(frameContent, 0, PR_FALSE, PR_TRUE);
29018:   }
29018:   else {
29018:     // this is a top-level window. If the window has a child frame focused,
29018:     // clear the focus. Otherwise, focus should already be in this frame, or
29018:     // already cleared. This ensures that focus will be in this frame and not
29018:     // in a child.
29018:     nsIContent* content = windowToFocus->GetFocusedNode();
29018:     if (content) {
29018:       nsCOMPtr<nsIDOMWindow> childWindow = GetContentWindow(content);
29018:       if (childWindow)
41071:         ClearFocus(windowToFocus);
29018:     }
29018:   }
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> rootWindow = windowToFocus->GetPrivateRoot();
29018:   if (rootWindow)
29018:     RaiseWindow(rootWindow);
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   printf("<<SetFocusedWindow end>>\n");
29018: #endif
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::GetFocusedElement(nsIDOMElement** aFocusedElement)
29018: {
29018:   if (mFocusedContent)
29018:     CallQueryInterface(mFocusedContent, aFocusedElement);
29018:   else
29018:     *aFocusedElement = nsnull;
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::GetLastFocusMethod(nsIDOMWindow* aWindow, PRUint32* aLastFocusMethod)
29018: {
29018:   // the focus method is stored on the inner window
29018:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
29018:   if (window)
29018:     window = window->GetCurrentInnerWindow();
29018:   if (!window)
29018:     window = mFocusedWindow;
29018: 
29018:   *aLastFocusMethod = window ? window->GetFocusMethod() : 0;
29018: 
29018:   NS_ASSERTION((*aLastFocusMethod & FOCUSMETHOD_MASK) == *aLastFocusMethod,
29018:                "invalid focus method");
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::SetFocus(nsIDOMElement* aElement, PRUint32 aFlags)
29018: {
29018: #ifdef DEBUG_FOCUS
29018:   printf("<<SetFocus>>\n");
29018: #endif
29018: 
29018:   nsCOMPtr<nsIContent> newFocus = do_QueryInterface(aElement);
29018:   NS_ENSURE_ARG(newFocus);
29018: 
57526:   SetFocusInner(newFocus, aFlags, PR_TRUE, PR_TRUE);
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::MoveFocus(nsIDOMWindow* aWindow, nsIDOMElement* aStartElement,
29018:                           PRUint32 aType, PRUint32 aFlags, nsIDOMElement** aElement)
29018: {
29018:   *aElement = nsnull;
29018: 
29018: #ifdef DEBUG_FOCUS
41071:   printf("<<MoveFocus Type: %d Flags: %x>>\n<<", aType, aFlags);
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> focusedWindow = mFocusedWindow;
29018:   if (focusedWindow) {
29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(focusedWindow->GetExtantDocument());
29018:     if (doc) {
29018:       nsCAutoString spec;
29018:       doc->GetDocumentURI()->GetSpec(spec);
29018:       printf(" [%p] Focused Window: %s", mFocusedWindow.get(), spec.get());
29018:     }
29018:   }
29018:   PRINTTAGF(">> $[[%s]]\n", mFocusedContent);
29018: #endif
29018: 
31988:   // use FLAG_BYMOVEFOCUS when switching focus with MoveFocus unless one of
31988:   // the other focus methods is already set, or we're just moving to the root
31988:   // or caret position.
31988:   if (aType != MOVEFOCUS_ROOT && aType != MOVEFOCUS_CARET &&
31988:       (aFlags & FOCUSMETHOD_MASK) == 0) {
31988:     aFlags |= FLAG_BYMOVEFOCUS;
31988:   }
31988: 
29018:   nsCOMPtr<nsPIDOMWindow> window;
29018:   nsCOMPtr<nsIContent> startContent;
29018:   if (aStartElement) {
29018:     startContent = do_QueryInterface(aStartElement);
29018:     NS_ENSURE_TRUE(startContent, NS_ERROR_INVALID_ARG);
29018: 
29018:     window = GetCurrentWindow(startContent);
29018:   }
29018:   else {
29018:     window = aWindow ? do_QueryInterface(aWindow) : mFocusedWindow;
29018:     NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
29018:     window = window->GetOuterWindow();
29018:   }
29018: 
29018:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
29018: 
29018:   nsCOMPtr<nsIContent> newFocus;
29018:   nsresult rv = DetermineElementToMoveFocus(window, startContent, aType,
29018:                                             getter_AddRefs(newFocus));
29018:   NS_ENSURE_SUCCESS(rv, rv);
29018: 
29018: #ifdef DEBUG_FOCUS_NAVIGATION
29018:   PRINTTAGF("-> Element to be focused: %s\n", newFocus);
29018: #endif
29018: 
29018:   if (newFocus) {
29018:     // for caret movement, pass false for the aFocusChanged argument,
29018:     // otherwise the caret will end up moving to the focus position. This
29018:     // would be a problem because the caret would move to the beginning of the
29018:     // focused link making it impossible to navigate the caret over a link.
57526:     SetFocusInner(newFocus, aFlags, aType != MOVEFOCUS_CARET, PR_TRUE);
29018:     CallQueryInterface(newFocus, aElement);
29018:   }
29018:   else if (aType == MOVEFOCUS_ROOT || aType == MOVEFOCUS_CARET) {
29018:     // no content was found, so clear the focus for these two types.
29018:     ClearFocus(window);
29018:   }
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   printf("<<MoveFocus end>>\n");
29018: #endif
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::ClearFocus(nsIDOMWindow* aWindow)
29018: {
29018: #ifdef DEBUG_FOCUS
29018:   printf("<<ClearFocus begin>>\n");
29018: #endif
29018: 
29018:   // if the window to clear is the focused window or an ancestor of the
29018:   // focused window, then blur the existing focused content. Otherwise, the
29018:   // focus is somewhere else so just update the current node.
29018:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
29018: 
29018:   window = window->GetOuterWindow();
29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
29018: 
29018:   if (IsSameOrAncestor(window, mFocusedWindow)) {
29018:     PRBool isAncestor = (window != mFocusedWindow);
57526:     if (Blur(window, nsnull, isAncestor, PR_TRUE)) {
29018:       // if we are clearing the focus on an ancestor of the focused window,
29018:       // the ancestor will become the new focused window, so focus it
29018:       if (isAncestor)
57526:         Focus(window, nsnull, 0, PR_TRUE, PR_FALSE, PR_FALSE, PR_TRUE);
29018:     }
29018:   }
29018:   else {
29018:     window->SetFocusedNode(nsnull);
29018:   }
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   printf("<<ClearFocus end>>\n");
29018: #endif
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::GetFocusedElementForWindow(nsIDOMWindow* aWindow,
29018:                                            PRBool aDeep,
29018:                                            nsIDOMWindow** aFocusedWindow,
29018:                                            nsIDOMElement** aElement)
29018: {
29018:   *aElement = nsnull;
29018:   if (aFocusedWindow)
29018:     *aFocusedWindow = nsnull;
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
29018: 
29018:   window = window->GetOuterWindow();
29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> focusedWindow;
29018:   nsCOMPtr<nsIContent> focusedContent =
29018:     GetFocusedDescendant(window, aDeep, getter_AddRefs(focusedWindow));
29018:   if (focusedContent)
29018:     CallQueryInterface(focusedContent, aElement);
29018: 
29018:   if (aFocusedWindow)
29018:     NS_IF_ADDREF(*aFocusedWindow = focusedWindow);
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::MoveCaretToFocus(nsIDOMWindow* aWindow)
29018: {
29018:   PRInt32 itemType = nsIDocShellTreeItem::typeChrome;
29018: 
29018:   nsCOMPtr<nsIWebNavigation> webnav = do_GetInterface(aWindow);
29018:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(webnav);
29018:   if (dsti) {
29018:     dsti->GetItemType(&itemType);
29018:     if (itemType != nsIDocShellTreeItem::typeChrome) {
29018:       // don't move the caret for editable documents
29018:       nsCOMPtr<nsIEditorDocShell> editorDocShell(do_QueryInterface(dsti));
29018:       if (editorDocShell) {
29018:         PRBool isEditable;
29018:         editorDocShell->GetEditable(&isEditable);
29018:         if (isEditable)
29018:           return NS_OK;
29018:       }
29018: 
29018:       nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(dsti);
29018:       NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
29018: 
29018:       nsCOMPtr<nsIPresShell> presShell;
29018:       docShell->GetPresShell(getter_AddRefs(presShell));
29018:       NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
29018: 
29018:       nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
29018:       nsCOMPtr<nsIContent> content = window->GetFocusedNode();
29018:       if (content)
29018:         MoveCaretToFocus(presShell, content);
29018:     }
29018:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::WindowRaised(nsIDOMWindow* aWindow)
29018: {
29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
29018:   NS_ENSURE_TRUE(window && window->IsOuterWindow(), NS_ERROR_INVALID_ARG);
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   printf("Window %p Raised [Currently: %p %p] <<", aWindow, mActiveWindow.get(), mFocusedWindow.get());
29018:   nsCAutoString spec;
29018:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
29018:   if (doc) {
29018:     doc->GetDocumentURI()->GetSpec(spec);
29018:     printf("[%p] Raised Window: %s", aWindow, spec.get());
29018:   }
29018:   if (mActiveWindow) {
29018:     doc = do_QueryInterface(mActiveWindow->GetExtantDocument());
29018:     if (doc) {
29018:       doc->GetDocumentURI()->GetSpec(spec);
29018:       printf(" [%p] Active Window: %s", mActiveWindow.get(), spec.get());
29018:     }
29018:   }
29018:   printf(">>\n");
29018: #endif
29018: 
29018:   if (mActiveWindow == window) {
29018:     // The window is already active, so there is no need to focus anything,
29018:     // but make sure that the right widget is focused. This is a special case
29018:     // for Windows because when restoring a minimized window, a second
29018:     // activation will occur and the top-level widget could be focused instead
29018:     // of the child we want. We solve this by calling SetFocus to ensure that
29018:     // what the focus manager thinks should be the current widget is actually
29018:     // focused.
29018:     EnsureCurrentWidgetFocused();
29018:     return NS_OK;
29018:   }
29018: 
29018:   // lower the existing window, if any. This shouldn't happen usually.
29018:   if (mActiveWindow)
29018:     WindowLowered(mActiveWindow);
29018: 
29018:   nsCOMPtr<nsIWebNavigation> webnav(do_GetInterface(aWindow));
29018:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(webnav));
29018:   // If there's no docShellAsItem, this window must have been closed,
29018:   // in that case there is no tree owner.
29018:   NS_ENSURE_TRUE(docShellAsItem, NS_OK);
29018: 
29018:   // set this as the active window
29018:   mActiveWindow = window;
29018: 
29018:   // ensure that the window is enabled and visible
29018:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
29018:   docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
29018:   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(treeOwner);
29018:   if (baseWindow) {
29018:     PRBool isEnabled = PR_TRUE;
29018:     if (NS_SUCCEEDED(baseWindow->GetEnabled(&isEnabled)) && !isEnabled) {
29018:       return NS_ERROR_FAILURE;
29018:     }
29018: 
29018:     baseWindow->SetVisibility(PR_TRUE);
29018:   }
29018: 
29018:   // inform the DOM window that it has activated, so that the active attribute
29018:   // is updated on the window
29018:   window->ActivateOrDeactivate(PR_TRUE);
29018: 
34280:   // send activate event
34280:   nsCOMPtr<nsIDocument> document = do_QueryInterface(window->GetExtantDocument());
34280:   nsContentUtils::DispatchTrustedEvent(document,
34280:                                        window,
34280:                                        NS_LITERAL_STRING("activate"),
34280:                                        PR_TRUE, PR_TRUE, nsnull);
34280: 
29018:   // retrieve the last focused element within the window that was raised
29018:   nsCOMPtr<nsPIDOMWindow> currentWindow;
29018:   nsCOMPtr<nsIContent> currentFocus =
29018:     GetFocusedDescendant(window, PR_TRUE, getter_AddRefs(currentWindow));
29018: 
29018:   NS_ASSERTION(currentWindow, "window raised with no window current");
29018:   if (!currentWindow)
29018:     return NS_OK;
29018: 
29018:   nsCOMPtr<nsIDocShell> currentDocShell = currentWindow->GetDocShell();
29018: 
29018:   nsCOMPtr<nsIPresShell> presShell;
29018:   currentDocShell->GetPresShell(getter_AddRefs(presShell));
29018:   if (presShell) {
29018:     // disable selection mousedown state on activation
29018:     // XXXndeakin P3 not sure if this is necessary, but it doesn't hurt
29018:     nsCOMPtr<nsFrameSelection> frameSelection = presShell->FrameSelection();
29018:     frameSelection->SetMouseDownState(PR_FALSE);
29018:   }
29018: 
57526:   Focus(currentWindow, currentFocus, 0, PR_TRUE, PR_FALSE, PR_TRUE, PR_TRUE);
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::WindowLowered(nsIDOMWindow* aWindow)
29018: {
29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
29018:   NS_ENSURE_TRUE(window && window->IsOuterWindow(), NS_ERROR_INVALID_ARG);
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   printf("Window %p Lowered [Currently: %p %p] <<", aWindow, mActiveWindow.get(), mFocusedWindow.get());
29018:   nsCAutoString spec;
29018:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
29018:   if (doc) {
29018:     doc->GetDocumentURI()->GetSpec(spec);
29018:     printf("[%p] Lowered Window: %s", aWindow, spec.get());
29018:   }
29018:   if (mActiveWindow) {
29018:     doc = do_QueryInterface(mActiveWindow->GetExtantDocument());
29018:     if (doc) {
29018:       doc->GetDocumentURI()->GetSpec(spec);
29018:       printf(" [%p] Active Window: %s", mActiveWindow.get(), spec.get());
29018:     }
29018:   }
29018:   printf(">>\n");
29018: #endif
29018: 
29018:   if (mActiveWindow != window)
29018:     return NS_OK;
29018: 
38335:   // clear the mouse capture as the active window has changed
38335:   nsIPresShell::SetCapturingContent(nsnull, 0);
38335: 
29018:   // inform the DOM window that it has deactivated, so that the active
29018:   // attribute is updated on the window
29018:   window->ActivateOrDeactivate(PR_FALSE);
29018: 
34280:   // send deactivate event
34280:   nsCOMPtr<nsIDocument> document = do_QueryInterface(window->GetExtantDocument());
34280:   nsContentUtils::DispatchTrustedEvent(document,
34280:                                        window,
34280:                                        NS_LITERAL_STRING("deactivate"),
34280:                                        PR_TRUE, PR_TRUE, nsnull);
34280: 
29018:   // keep track of the window being lowered, so that attempts to raise the
29018:   // window can be prevented until we return. Otherwise, focus can get into
29018:   // an unusual state.
29018:   mWindowBeingLowered = mActiveWindow;
29018:   mActiveWindow = nsnull;
29018: 
29018:   if (mFocusedWindow)
57526:     Blur(nsnull, nsnull, PR_TRUE, PR_TRUE);
29018: 
29018:   mWindowBeingLowered = nsnull;
29018: 
29018:   return NS_OK;
29018: }
29018: 
41409: nsresult
29018: nsFocusManager::ContentRemoved(nsIDocument* aDocument, nsIContent* aContent)
29018: {
29018:   NS_ENSURE_ARG(aDocument);
29018:   NS_ENSURE_ARG(aContent);
29018: 
29018:   nsPIDOMWindow *window = aDocument->GetWindow();
29018:   if (!window)
29018:     return NS_OK;
29018: 
29018:   // if the content is currently focused in the window, or is an ancestor
29018:   // of the currently focused element, reset the focus within that window.
41409:   nsIContent* content = window->GetFocusedNode();
29018:   if (content && nsContentUtils::ContentIsDescendantOf(content, aContent)) {
29018:     window->SetFocusedNode(nsnull);
29018: 
29018:     nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
29018:     if (docShell) {
29018:       nsCOMPtr<nsIPresShell> presShell;
29018:       docShell->GetPresShell(getter_AddRefs(presShell));
29018:       nsIMEStateManager::OnRemoveContent(presShell->GetPresContext(), content);
29018:     }
29018: 
29018:     // if this window is currently focused, clear the global focused
29018:     // element as well, but don't fire any events.
30830:     if (window == mFocusedWindow) {
29018:       mFocusedContent = nsnull;
29018:     }
30830:     else {
30830:       // Check if the node that was focused is an iframe or similar by looking
30830:       // if it has a subdocument. This would indicate that this focused iframe
30830:       // and its descendants will be going away. We will need to move the
30830:       // focus somewhere else, so just clear the focus in the toplevel window
30830:       // so that no element is focused.
30830:       nsIDocument* subdoc = aDocument->GetSubDocumentFor(content);
30830:       if (subdoc) {
30830:         nsCOMPtr<nsISupports> container = subdoc->GetContainer();
30830:         nsCOMPtr<nsPIDOMWindow> childWindow = do_GetInterface(container);
30830:         if (childWindow && IsSameOrAncestor(childWindow, mFocusedWindow)) {
30830:           ClearFocus(mActiveWindow);
30830:         }
30830:       }
30830:     }
30830:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
33917: nsFocusManager::WindowShown(nsIDOMWindow* aWindow, PRBool aNeedsFocus)
29018: {
29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
29018: 
29018:   window = window->GetOuterWindow();
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   printf("Window %p Shown [Currently: %p %p] <<", window.get(), mActiveWindow.get(), mFocusedWindow.get());
29018:   nsCAutoString spec;
29018:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
29018:   if (doc) {
29018:     doc->GetDocumentURI()->GetSpec(spec);
29018:     printf("Shown Window: %s", spec.get());
29018:   }
29018: 
29018:   if (mFocusedWindow) {
29018:     doc = do_QueryInterface(mFocusedWindow->GetExtantDocument());
29018:     if (doc) {
29018:       doc->GetDocumentURI()->GetSpec(spec);
29018:       printf(" Focused Window: %s", spec.get());
29018:     }
29018:   }
29018:   printf(">>\n");
29018: #endif
29018: 
29018:   if (mFocusedWindow != window)
29018:     return NS_OK;
29018: 
33917:   if (aNeedsFocus) {
29018:     nsCOMPtr<nsPIDOMWindow> currentWindow;
29018:     nsCOMPtr<nsIContent> currentFocus =
29018:       GetFocusedDescendant(window, PR_TRUE, getter_AddRefs(currentWindow));
29018:     if (currentWindow)
57526:       Focus(currentWindow, currentFocus, 0, PR_TRUE, PR_FALSE, PR_FALSE, PR_TRUE);
33917:   }
33917:   else {
33917:     // Sometimes, an element in a window can be focused before the window is
33917:     // visible, which would mean that the widget may not be properly focused.
33917:     // When the window becomes visible, make sure the right widget is focused.
33917:     EnsureCurrentWidgetFocused();
33917:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
64121: static void
64121: NotifyFocusStateChange(nsIContent* aContent, nsPIDOMWindow* aWindow)
64121: {
64121:   nsIDocument *doc = aContent->GetCurrentDoc();
64121:   MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, PR_TRUE);
64121:   nsEventStates eventState = NS_EVENT_STATE_FOCUS;
64121:   if (aWindow->ShouldShowFocusRing()) {
64121:     eventState |= NS_EVENT_STATE_FOCUSRING;
64121:   }
64121:   doc->ContentStateChanged(aContent, eventState);
64121: }
64121: 
29018: NS_IMETHODIMP
29018: nsFocusManager::WindowHidden(nsIDOMWindow* aWindow)
29018: {
29018:   // if there is no window or it is not the same or an ancestor of the
29018:   // currently focused window, just return, as the current focus will not
29018:   // be affected.
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
29018: 
29018:   window = window->GetOuterWindow();
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   printf("Window %p Hidden [Currently: %p %p] <<", window.get(), mActiveWindow.get(), mFocusedWindow.get());
29018:   nsCAutoString spec;
29018:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
29018:   if (doc) {
29018:     doc->GetDocumentURI()->GetSpec(spec);
29018:     printf("Hide Window: %s", spec.get());
29018:   }
29018: 
29018:   if (mFocusedWindow) {
29018:     doc = do_QueryInterface(mFocusedWindow->GetExtantDocument());
29018:     if (doc) {
29018:       doc->GetDocumentURI()->GetSpec(spec);
29018:       printf(" Focused Window: %s", spec.get());
29018:     }
29018:   }
29018: 
29018:   if (mActiveWindow) {
29018:     doc = do_QueryInterface(mActiveWindow->GetExtantDocument());
29018:     if (doc) {
29018:       doc->GetDocumentURI()->GetSpec(spec);
29018:       printf(" Active Window: %s", spec.get());
29018:     }
29018:   }
29018:   printf(">>\n");
29018: #endif
29018: 
29018:   if (!IsSameOrAncestor(window, mFocusedWindow))
29018:     return NS_OK;
29018: 
29018:   // at this point, we know that the window being hidden is either the focused
29018:   // window, or an ancestor of the focused window. Either way, the focus is no
29018:   // longer valid, so it needs to be updated.
29018: 
64121:   nsIContent* oldFocusedContent = mFocusedContent;
64121:   mFocusedContent = nsnull;
64121: 
64121:   if (oldFocusedContent && oldFocusedContent->IsInDoc()) {
64121:     NotifyFocusStateChange(oldFocusedContent, mFocusedWindow);
64121:   }
64121: 
29018:   nsCOMPtr<nsIDocShell> focusedDocShell = mFocusedWindow->GetDocShell();
29018:   nsCOMPtr<nsIPresShell> presShell;
29018:   focusedDocShell->GetPresShell(getter_AddRefs(presShell));
29018: 
29018:   nsIMEStateManager::OnTextStateBlur(nsnull, nsnull);
29018:   if (presShell) {
29018:     nsIMEStateManager::OnChangeFocus(presShell->GetPresContext(), nsnull);
29018:     SetCaretVisible(presShell, PR_FALSE, nsnull);
29018:   }
29018: 
29018:   // if the docshell being hidden is being destroyed, then we want to move
29018:   // focus somewhere else. Call ClearFocus on the toplevel window, which
29018:   // will have the effect of clearing the focus and moving the focused window
29018:   // to the toplevel window. But if the window isn't being destroyed, we are
29018:   // likely just loading a new document in it, so we want to maintain the
29018:   // focused window so that the new document gets properly focused.
29018:   PRBool beingDestroyed;
29018:   nsCOMPtr<nsIDocShell> docShellBeingHidden = window->GetDocShell();
29018:   docShellBeingHidden->IsBeingDestroyed(&beingDestroyed);
29018:   if (beingDestroyed) {
29018:     // There is usually no need to do anything if a toplevel window is going
29018:     // away, as we assume that WindowLowered will be called. However, this may
29018:     // not happen if nsIAppStartup::eForceQuit is used to quit, and can cause
29018:     // a leak. So if the active window is being destroyed, call WindowLowered
29018:     // directly.
29018:     NS_ASSERTION(mFocusedWindow->IsOuterWindow(), "outer window expected");
29018:     if (mActiveWindow == mFocusedWindow || mActiveWindow == window)
29018:       WindowLowered(mActiveWindow);
29018:     else
29018:       ClearFocus(mActiveWindow);
29018:     return NS_OK;
29018:   }
29018: 
29018:   // if the window being hidden is an ancestor of the focused window, adjust
29018:   // the focused window so that it points to the one being hidden. This
29018:   // ensures that the focused window isn't in a chain of frames that doesn't
29018:   // exist any more.
29018:   if (window != mFocusedWindow) {
32922:     nsCOMPtr<nsIWebNavigation> webnav(do_GetInterface(mFocusedWindow));
29018:     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(webnav);
29018:     if (dsti) {
29461:       nsCOMPtr<nsIDocShellTreeItem> parentDsti;
29461:       dsti->GetParent(getter_AddRefs(parentDsti));
29461:       nsCOMPtr<nsPIDOMWindow> parentWindow = do_GetInterface(parentDsti);
29018:       if (parentWindow)
29018:         parentWindow->SetFocusedNode(nsnull);
29018:     }
29018: 
29018:     mFocusedWindow = window;
29018:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
29018: nsFocusManager::FireDelayedEvents(nsIDocument* aDocument)
29018: {
29018:   NS_ENSURE_ARG(aDocument);
29018: 
29018:   // fire any delayed focus and blur events in the same order that they were added
29018:   for (PRUint32 i = 0; i < mDelayedBlurFocusEvents.Length(); i++)
29018:   {
29018:     if (mDelayedBlurFocusEvents[i].mDocument == aDocument &&
29018:         !aDocument->EventHandlingSuppressed()) {
29018:       PRUint32 type = mDelayedBlurFocusEvents[i].mType;
29018:       nsCOMPtr<nsPIDOMEventTarget> target = mDelayedBlurFocusEvents[i].mTarget;
29018:       nsCOMPtr<nsIPresShell> presShell = mDelayedBlurFocusEvents[i].mPresShell;
29018:       mDelayedBlurFocusEvents.RemoveElementAt(i);
33344:       SendFocusOrBlurEvent(type, presShell, aDocument, target, 0, PR_FALSE);
29018:       --i;
29018:     }
29018:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
57526: NS_IMETHODIMP
57526: nsFocusManager::FocusPlugin(nsIContent* aContent)
57526: {
57526:   NS_ENSURE_ARG(aContent);
57526:   SetFocusInner(aContent, 0, PR_TRUE, PR_FALSE);
57526:   return NS_OK;
57526: }
57526: 
29018: // static
29018: void
29018: nsFocusManager::EnsureCurrentWidgetFocused()
29018: {
29018:   if (!mFocusedWindow)
29018:     return;
29018: 
29018:   // get the main child widget for the focused window and ensure that the
29018:   // platform knows that this widget is focused.
29018:   nsCOMPtr<nsIDocShell> docShell = mFocusedWindow->GetDocShell();
29018:   if (docShell) {
29018:     nsCOMPtr<nsIPresShell> presShell;
29018:     docShell->GetPresShell(getter_AddRefs(presShell));
29018:     if (presShell) {
29018:       nsIViewManager* vm = presShell->GetViewManager();
29018:       if (vm) {
29018:         nsCOMPtr<nsIWidget> widget;
30530:         vm->GetRootWidget(getter_AddRefs(widget));
29018:         if (widget)
33213:           widget->SetFocus(PR_FALSE);
29018:       }
29018:     }
29018:   }
29018: }
29018: 
29018: void
29018: nsFocusManager::SetFocusInner(nsIContent* aNewContent, PRInt32 aFlags,
57526:                               PRBool aFocusChanged, PRBool aAdjustWidget)
29018: {
29018:   // if the element is not focusable, just return and leave the focus as is
29018:   nsCOMPtr<nsIContent> contentToFocus = CheckIfFocusable(aNewContent, aFlags);
29018:   if (!contentToFocus)
29018:     return;
29018: 
29018:   // check if the element to focus is a frame (iframe) containing a child
29018:   // document. Frames are never directly focused; instead focusing a frame
29018:   // means focus what is inside the frame. To do this, the descendant content
29018:   // within the frame is retrieved and that will be focused instead.
29018:   nsCOMPtr<nsPIDOMWindow> newWindow;
29018:   nsCOMPtr<nsPIDOMWindow> subWindow = GetContentWindow(contentToFocus);
29018:   if (subWindow) {
29018:     contentToFocus = GetFocusedDescendant(subWindow, PR_TRUE, getter_AddRefs(newWindow));
29018:     // since a window is being refocused, clear aFocusChanged so that the
29018:     // caret position isn't updated.
29018:     aFocusChanged = PR_FALSE;
29018:   }
29018: 
29018:   // unless it was set above, retrieve the window for the element to focus
29018:   if (!newWindow)
29018:     newWindow = GetCurrentWindow(contentToFocus);
29018: 
29018:   // if the element is already focused, just return. Note that this happens
29018:   // after the frame check above so that we compare the element that will be
29018:   // focused rather than the frame it is in.
39425:   if (!newWindow || (newWindow == mFocusedWindow && contentToFocus == mFocusedContent))
29018:     return;
29018: 
29018:   // don't allow focus to be placed in docshells or descendants of docshells
30218:   // that are being destroyed. Also, ensure that the page hasn't been
30218:   // unloaded. The prevents content from being refocused during an unload event.
29018:   nsCOMPtr<nsIDocShell> newDocShell = newWindow->GetDocShell();
29018:   nsCOMPtr<nsIDocShell> docShell = newDocShell;
29018:   while (docShell) {
30218:     PRBool inUnload;
30218:     docShell->GetIsInUnload(&inUnload);
30218:     if (inUnload)
30218:       return;
30218: 
29018:     PRBool beingDestroyed;
29018:     docShell->IsBeingDestroyed(&beingDestroyed);
29018:     if (beingDestroyed)
29018:       return;
29018: 
29018:     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(docShell);
29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti;
29461:     dsti->GetParent(getter_AddRefs(parentDsti));
29461:     docShell = do_QueryInterface(parentDsti);
29018:   }
29018: 
29018:   // if the new element is in the same window as the currently focused element 
29018:   PRBool isElementInFocusedWindow = (mFocusedWindow == newWindow);
29018: 
41239:   if (!isElementInFocusedWindow && mFocusedWindow && newWindow &&
41239:       nsContentUtils::IsHandlingKeyBoardEvent()) {
41239:     nsCOMPtr<nsIScriptObjectPrincipal> focused =
41239:       do_QueryInterface(mFocusedWindow);
41239:     nsCOMPtr<nsIScriptObjectPrincipal> newFocus =
41239:       do_QueryInterface(newWindow);
41239:     nsIPrincipal* focusedPrincipal = focused->GetPrincipal();
41239:     nsIPrincipal* newPrincipal = newFocus->GetPrincipal();
41239:     if (!focusedPrincipal || !newPrincipal) {
41239:       return;
41239:     }
41239:     PRBool subsumes = PR_FALSE;
41239:     focusedPrincipal->Subsumes(newPrincipal, &subsumes);
41239:     if (!subsumes && !nsContentUtils::IsCallerTrustedForWrite()) {
41239:       NS_WARNING("Not allowed to focus the new window!");
41239:       return;
41239:     }
41239:   }
41239: 
29018:   // to check if the new element is in the active window, compare the
29018:   // new root docshell for the new element with the active window's docshell.
29018:   PRBool isElementInActiveWindow = PR_FALSE;
29018: 
29018:   nsCOMPtr<nsIWebNavigation> webnav = do_GetInterface(newWindow);
29018:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(webnav);
29018:   nsCOMPtr<nsPIDOMWindow> newRootWindow;
29018:   if (dsti) {
29018:     nsCOMPtr<nsIDocShellTreeItem> root;
29018:     dsti->GetRootTreeItem(getter_AddRefs(root));
29018:     newRootWindow = do_GetInterface(root);
29018: 
29018:     isElementInActiveWindow = (mActiveWindow && newRootWindow == mActiveWindow);
29018:   }
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   PRINTTAGF("Shift Focus: %s", contentToFocus);
41071:   printf(" Flags: %x Current Window: %p New Window: %p Current Element: %p",
29018:          aFlags, mFocusedWindow.get(), newWindow.get(), mFocusedContent.get());
29018:   printf(" In Active Window: %d In Focused Window: %d\n",
29018:          isElementInActiveWindow, isElementInFocusedWindow);
29018: #endif
29018: 
29018:   // if the FLAG_NOSWITCHFRAME flag is used, only allow the focus to be
29018:   // shifted away from the current element if the new shell to focus is
29018:   // the same or an ancestor shell of the currently focused shell.
29018:   PRBool allowFrameSwitch = !(aFlags & FLAG_NOSWITCHFRAME) ||
29018:                             IsSameOrAncestor(newWindow, mFocusedWindow);
29018: 
29018:   // if the element is in the active window, frame switching is allowed and
29018:   // the content is in a visible window, fire blur and focus events.
35609:   PRBool sendFocusEvent =
35609:     isElementInActiveWindow && allowFrameSwitch && IsWindowVisible(newWindow);
35609: 
35609:   // When the following conditions are true:
35609:   //  * an element has focus
35609:   //  * isn't called by trusted event (i.e., called by untrusted event or by js)
35609:   //  * the focus is moved to another document's element
35609:   // we need to check the permission.
35609:   if (sendFocusEvent && mFocusedContent &&
35609:       mFocusedContent->GetOwnerDoc() != aNewContent->GetOwnerDoc()) {
35609:     // If the caller cannot access the current focused node, the caller should
35609:     // not be able to steal focus from it. E.g., When the current focused node
35609:     // is in chrome, any web contents should not be able to steal the focus.
35609:     nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(mFocusedContent));
35609:     sendFocusEvent = nsContentUtils::CanCallerAccess(domNode);
56988:     if (!sendFocusEvent && mMouseDownEventHandlingDocument) {
56988:       // However, while mouse down event is handling, the handling document's
56988:       // script should be able to steal focus.
56988:       domNode = do_QueryInterface(mMouseDownEventHandlingDocument);
56988:       sendFocusEvent = nsContentUtils::CanCallerAccess(domNode);
56988:     }
35609:   }
35609: 
35609:   if (sendFocusEvent) {
29018:     // return if blurring fails or the focus changes during the blur
29018:     if (mFocusedWindow) {
29018:       // if the focus is being moved to another element in the same document,
29018:       // or to a descendant, pass the existing window to Blur so that the
29018:       // current node in the existing window is cleared. If moving to a
29018:       // window elsewhere, we want to maintain the current node in the
29018:       // window but still blur it.
29018:       PRBool currentIsSameOrAncestor = IsSameOrAncestor(mFocusedWindow, newWindow);
29018:       // find the common ancestor of the currently focused window and the new
29018:       // window. The ancestor will need to have its currently focused node
29018:       // cleared once the document has been blurred. Otherwise, we'll be in a
29018:       // state where a document is blurred yet the chain of windows above it
29018:       // still points to that document.
29018:       // For instance, in the following frame tree:
29018:       //   A
29018:       //  B C
29018:       //  D
29018:       // D is focused and we want to focus C. Once D has been blurred, we need
29018:       // to clear out the focus in A, otherwise A would still maintain that B
29018:       // was focused, and B that D was focused.
29018:       nsCOMPtr<nsPIDOMWindow> commonAncestor;
29018:       if (!isElementInFocusedWindow)
29018:         commonAncestor = GetCommonAncestor(newWindow, mFocusedWindow);
29018: 
29040:       if (!Blur(currentIsSameOrAncestor ? mFocusedWindow.get() : nsnull,
57526:                 commonAncestor, !isElementInFocusedWindow, aAdjustWidget))
29018:         return;
29018:     }
29018: 
29018:     Focus(newWindow, contentToFocus, aFlags, !isElementInFocusedWindow,
57526:           aFocusChanged, PR_FALSE, aAdjustWidget);
29018:   }
29018:   else {
35609:     // otherwise, for inactive windows and when the caller cannot steal the
35609:     // focus, update the node in the window, and  raise the window if desired.
29018:     if (allowFrameSwitch)
35609:       AdjustWindowFocus(newWindow, PR_TRUE);
29018: 
29018:     // set the focus node and method as needed
41071:     PRUint32 focusMethod = aFocusChanged ? aFlags & FOCUSMETHODANDRING_MASK :
41071:                            newWindow->GetFocusMethod() | (aFlags & FLAG_SHOWRING);
29018:     newWindow->SetFocusedNode(contentToFocus, focusMethod);
29018:     if (aFocusChanged) {
29018:       nsCOMPtr<nsIDocShell> docShell = newWindow->GetDocShell();
29018: 
29018:       nsCOMPtr<nsIPresShell> presShell;
29018:       docShell->GetPresShell(getter_AddRefs(presShell));
29018:       if (presShell)
29018:         ScrollIntoView(presShell, contentToFocus, aFlags);
29018:     }
29018: 
29018:     // update the commands even when inactive so that the attributes for that
29018:     // window are up to date.
29018:     if (allowFrameSwitch)
29018:       newWindow->UpdateCommands(NS_LITERAL_STRING("focus"));
29018: 
29018:     if (aFlags & FLAG_RAISE)
29018:       RaiseWindow(newRootWindow);
29018:   }
29018: }
29018: 
29018: PRBool
29018: nsFocusManager::IsSameOrAncestor(nsPIDOMWindow* aPossibleAncestor,
29018:                                  nsPIDOMWindow* aWindow)
29018: {
29018:   nsCOMPtr<nsIWebNavigation> awebnav(do_GetInterface(aPossibleAncestor));
29018:   nsCOMPtr<nsIDocShellTreeItem> ancestordsti = do_QueryInterface(awebnav);
29018: 
29018:   nsCOMPtr<nsIWebNavigation> fwebnav(do_GetInterface(aWindow));
29018:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(fwebnav);
29018:   while (dsti) {
29018:     if (dsti == ancestordsti)
29018:       return PR_TRUE;
29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti;
29461:     dsti->GetParent(getter_AddRefs(parentDsti));
29461:     dsti.swap(parentDsti);
29018:   }
29018: 
29018:   return PR_FALSE;
29018: }
29018: 
29018: already_AddRefed<nsPIDOMWindow>
29018: nsFocusManager::GetCommonAncestor(nsPIDOMWindow* aWindow1,
29018:                                   nsPIDOMWindow* aWindow2)
29018: {
29018:   nsCOMPtr<nsIWebNavigation> webnav(do_GetInterface(aWindow1));
29018:   nsCOMPtr<nsIDocShellTreeItem> dsti1 = do_QueryInterface(webnav);
30830:   NS_ENSURE_TRUE(dsti1, nsnull);
29018: 
29018:   webnav = do_GetInterface(aWindow2);
29018:   nsCOMPtr<nsIDocShellTreeItem> dsti2 = do_QueryInterface(webnav);
30830:   NS_ENSURE_TRUE(dsti2, nsnull);
29018: 
29018:   nsAutoTPtrArray<nsIDocShellTreeItem, 30> parents1, parents2;
29018:   do {
29018:     parents1.AppendElement(dsti1);
29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti1;
29461:     dsti1->GetParent(getter_AddRefs(parentDsti1));
29461:     dsti1.swap(parentDsti1);
29018:   } while (dsti1);
29018:   do {
29018:     parents2.AppendElement(dsti2);
29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti2;
29461:     dsti2->GetParent(getter_AddRefs(parentDsti2));
29461:     dsti2.swap(parentDsti2);
29018:   } while (dsti2);
29018: 
29018:   PRUint32 pos1 = parents1.Length();
29018:   PRUint32 pos2 = parents2.Length();
29018:   nsIDocShellTreeItem* parent = nsnull;
29018:   PRUint32 len;
38330:   for (len = NS_MIN(pos1, pos2); len > 0; --len) {
29018:     nsIDocShellTreeItem* child1 = parents1.ElementAt(--pos1);
29018:     nsIDocShellTreeItem* child2 = parents2.ElementAt(--pos2);
29018:     if (child1 != child2) {
29018:       break;
29018:     }
29018:     parent = child1;
29018:   }
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(parent);
29018:   return window.forget();
29018: }
29018: 
29018: void
35609: nsFocusManager::AdjustWindowFocus(nsPIDOMWindow* aWindow,
35609:                                   PRBool aCheckPermission)
29018: {
29018:   PRBool isVisible = IsWindowVisible(aWindow);
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> window(aWindow);
29018:   while (window) {
29018:     // get the containing <iframe> or equivalent element so that it can be
29018:     // focused below.
29018:     nsCOMPtr<nsIContent> frameContent =
29018:       do_QueryInterface(window->GetFrameElementInternal());
29018: 
29018:     nsCOMPtr<nsIWebNavigation> webnav(do_GetInterface(window));
29018:     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(webnav);
29461:     if (!dsti) 
29461:       return;
29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti;
29461:     dsti->GetParent(getter_AddRefs(parentDsti));
29461: 
29461:     window = do_GetInterface(parentDsti);
29018:     if (window) {
29018:       // if the parent window is visible but aWindow was not, then we have
29018:       // likely moved up and out from a hidden tab to the browser window, or a
29018:       // similar such arrangement. Stop adjusting the current nodes.
29018:       if (IsWindowVisible(window) != isVisible)
29018:         break;
29018: 
35609:       // When aCheckPermission is true, we should check whether the caller can
35609:       // access the window or not.  If it cannot access, we should stop the
35609:       // adjusting.
35609:       if (aCheckPermission && !nsContentUtils::CanCallerAccess(window))
35609:         break;
35609: 
29018:       window->SetFocusedNode(frameContent);
29018:     }
29018:   }
29018: }
29018: 
29018: PRBool
29018: nsFocusManager::IsWindowVisible(nsPIDOMWindow* aWindow)
29018: {
29018:   if (!aWindow)
29018:     return PR_FALSE;
29018: 
29018:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
29018:   nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(docShell));
29018:   if (!baseWin)
29018:     return PR_FALSE;
29018: 
29018:   PRBool visible = PR_FALSE;
29018:   baseWin->GetVisibility(&visible);
29018:   return visible;
29018: }
29018: 
41068: PRBool
41068: nsFocusManager::IsNonFocusableRoot(nsIContent* aContent)
41068: {
41068:   NS_PRECONDITION(aContent, "aContent must not be NULL");
41068:   NS_PRECONDITION(aContent->IsInDoc(), "aContent must be in a document");
41068: 
41068:   // If aContent is in designMode, the root element is not focusable.
41068:   // NOTE: in designMode, most elements are not focusable, just the document is
41068:   //       focusable.
41068:   // Also, if aContent is not editable but it isn't in designMode, it's not
41068:   // focusable.
41068:   nsIDocument* doc = aContent->GetCurrentDoc();
41068:   NS_ASSERTION(doc, "aContent must have current document");
41634:   return aContent == doc->GetRootElement() &&
41068:            (doc->HasFlag(NODE_IS_EDITABLE) || !aContent->IsEditable());
41068: }
41068: 
29018: nsIContent*
29018: nsFocusManager::CheckIfFocusable(nsIContent* aContent, PRUint32 aFlags)
29018: {
29018:   if (!aContent)
29018:     return nsnull;
29018: 
29018:   // this is a special case for some XUL elements where an anonymous child is
29018:   // actually focusable and not the element itself.
29018:   nsIContent* redirectedFocus = GetRedirectedFocus(aContent);
29018:   if (redirectedFocus)
29018:     return CheckIfFocusable(redirectedFocus, aFlags);
29018: 
29018:   nsCOMPtr<nsIDocument> doc = aContent->GetCurrentDoc();
29018:   // can't focus elements that are not in documents
29018:   if (!doc)
29018:     return nsnull;
29018: 
29018:   // Make sure that our frames are up to date
57591:   doc->FlushPendingNotifications(Flush_Layout);
29018: 
46225:   nsIPresShell *shell = doc->GetShell();
29018:   if (!shell)
29018:     return nsnull;
29018: 
29018:   // the root content can always be focused
41634:   if (aContent == doc->GetRootElement())
29018:     return aContent;
29018: 
29018:   // cannot focus content in print preview mode. Only the root can be focused.
29018:   nsPresContext* presContext = shell->GetPresContext();
29018:   if (presContext && presContext->Type() == nsPresContext::eContext_PrintPreview)
29018:     return nsnull;
29018: 
36657:   nsIFrame* frame = aContent->GetPrimaryFrame();
29018:   if (!frame)
29018:     return nsnull;
29018: 
33329:   if (aContent->Tag() == nsGkAtoms::area && aContent->IsHTML()) {
29018:     // HTML areas do not have their own frame, and the img frame we get from
36657:     // GetPrimaryFrame() is not relevant as to whether it is focusable or
29018:     // not, so we have to do all the relevant checks manually for them.
29018:     return frame->AreAncestorViewsVisible() &&
29018:            frame->GetStyleVisibility()->IsVisible() &&
29018:            aContent->IsFocusable() ? aContent : nsnull;
29018:   }
29018: 
29018:   // if this is a child frame content node, check if it is visible and
29018:   // call the content node's IsFocusable method instead of the frame's
29018:   // IsFocusable method. This skips checking the style system and ensures that
29018:   // offscreen browsers can still be focused.
29018:   nsIDocument* subdoc = doc->GetSubDocumentFor(aContent);
29018:   if (subdoc && IsWindowVisible(subdoc->GetWindow())) {
29018:     const nsStyleUserInterface* ui = frame->GetStyleUserInterface();
29018:     PRInt32 tabIndex = (ui->mUserFocus == NS_STYLE_USER_FOCUS_IGNORE ||
29018:                         ui->mUserFocus == NS_STYLE_USER_FOCUS_NONE) ? -1 : 0;
41071:     return aContent->IsFocusable(&tabIndex, aFlags & FLAG_BYMOUSE) ? aContent : nsnull;
29018:   }
29018:   
29018:   return frame->IsFocusable(nsnull, aFlags & FLAG_BYMOUSE) ? aContent : nsnull;
29018: }
29018: 
29018: PRBool
29018: nsFocusManager::Blur(nsPIDOMWindow* aWindowToClear,
29018:                      nsPIDOMWindow* aAncestorWindowToFocus,
57526:                      PRBool aIsLeavingDocument,
57526:                      PRBool aAdjustWidgets)
29018: {
29417:   // hold a reference to the focused content, which may be null
29417:   nsCOMPtr<nsIContent> content = mFocusedContent;
29417:   if (content) {
29417:     if (!content->IsInDoc()) {
29417:       mFocusedContent = nsnull;
29417:       return PR_TRUE;
29417:     }
29417:     if (content == mFirstBlurEvent)
29417:       return PR_TRUE;
29417:   }
29417: 
29018:   // hold a reference to the focused window
29018:   nsCOMPtr<nsPIDOMWindow> window = mFocusedWindow;
29417:   if (!window) {
29417:     mFocusedContent = nsnull;
29018:     return PR_TRUE;
29417:   }
29417: 
29417:   nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
29417:   if (!docShell) {
29417:     mFocusedContent = nsnull;
29018:     return PR_TRUE;
29417:   }
29018: 
29018:   // Keep a ref to presShell since dispatching the DOM event may cause
29018:   // the document to be destroyed.
29018:   nsCOMPtr<nsIPresShell> presShell;
29018:   docShell->GetPresShell(getter_AddRefs(presShell));
29417:   if (!presShell) {
29417:     mFocusedContent = nsnull;
29018:     return PR_TRUE;
29417:   }
29018: 
29018:   PRBool clearFirstBlurEvent = PR_FALSE;
29018:   if (!mFirstBlurEvent) {
29018:     mFirstBlurEvent = content;
29018:     clearFirstBlurEvent = PR_TRUE;
29018:   }
29018: 
29018:   // if there is still an active window, adjust the IME state.
29018:   // This has to happen before the focus is cleared below, otherwise, the IME
29018:   // compositionend event won't get fired at the element being blurred.
29018:   nsIMEStateManager::OnTextStateBlur(nsnull, nsnull);
32008:   if (mActiveWindow)
29018:     nsIMEStateManager::OnChangeFocus(presShell->GetPresContext(), nsnull);
29018: 
29018:   // now adjust the actual focus, by clearing the fields in the focus manager
29018:   // and in the window.
29018:   mFocusedContent = nsnull;
29018:   if (aWindowToClear)
29018:     aWindowToClear->SetFocusedNode(nsnull);
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   PRINTTAGF("**Element %s has been blurred\n", content);
29018: #endif
29018: 
41068:   // Don't fire blur event on the root content which isn't editable.
41068:   PRBool sendBlurEvent =
41068:     content && content->IsInDoc() && !IsNonFocusableRoot(content);
29018:   if (content) {
41068:     if (sendBlurEvent) {
64121:       NotifyFocusStateChange(content, window);
29018:     }
29018: 
29018:     // if an object/plug-in is being blurred, move the system focus to the
29018:     // parent window, otherwise events will still get fired at the plugin.
29274:     // But don't do this if we are blurring due to the window being lowered,
29274:     // otherwise, the parent window can get raised again.
57526:     if (mActiveWindow && aAdjustWidgets) {
36657:       nsIFrame* contentFrame = content->GetPrimaryFrame();
29018:       nsIObjectFrame* objectFrame = do_QueryFrame(contentFrame);
29018:       if (objectFrame) {
29018:         // note that the presshell's widget is being retrieved here, not the one
29018:         // for the object frame.
29018:         nsIViewManager* vm = presShell->GetViewManager();
29018:         if (vm) {
29018:           nsCOMPtr<nsIWidget> widget;
30530:           vm->GetRootWidget(getter_AddRefs(widget));
29018:           if (widget)
33213:             widget->SetFocus(PR_FALSE);
29018:         }
29018:       }
29018:     }
29274:   }
29018: 
29018:   PRBool result = PR_TRUE;
41068:   if (sendBlurEvent) {
29018:     // if there is an active window, update commands. If there isn't an active
29018:     // window, then this was a blur caused by the active window being lowered,
29018:     // so there is no need to update the commands
29018:     if (mActiveWindow)
29018:       window->UpdateCommands(NS_LITERAL_STRING("focus"));
29018: 
29018:     SendFocusOrBlurEvent(NS_BLUR_CONTENT, presShell,
33344:                          content->GetCurrentDoc(), content, 1, PR_FALSE);
29018:   }
29018: 
29018:   // if we are leaving the document or the window was lowered, make the caret
29018:   // invisible.
29018:   if (aIsLeavingDocument || !mActiveWindow)
29018:     SetCaretVisible(presShell, PR_FALSE, nsnull);
29018: 
29018:   // at this point, it is expected that this window will be still be
29018:   // focused, but the focused content will be null, as it was cleared before
29018:   // the event. If this isn't the case, then something else was focused during
29018:   // the blur event above and we should just return. However, if
29018:   // aIsLeavingDocument is set, a new document is desired, so make sure to
29018:   // blur the document and window.
29018:   if (mFocusedWindow != window ||
29018:       (mFocusedContent != nsnull && !aIsLeavingDocument)) {
29018:     result = PR_FALSE;
29018:   }
29018:   else if (aIsLeavingDocument) {
29018:     window->TakeFocus(PR_FALSE, 0);
29018: 
29018:     // clear the focus so that the ancestor frame hierarchy is in the correct
29018:     // state. Pass true because aAncestorWindowToFocus is thought to be
29018:     // focused at this point.
29018:     if (aAncestorWindowToFocus)
29018:       aAncestorWindowToFocus->SetFocusedNode(nsnull, 0, PR_TRUE);
29018: 
29018:     mFocusedWindow = nsnull;
29018:     mFocusedContent = nsnull;
29018: 
29018:     // pass 1 for the focus method when calling SendFocusOrBlurEvent just so
29452:     // that the check is made for suppressed documents. Check to ensure that
29452:     // the document isn't null in case someone closed it during the blur above
29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
29452:     if (doc)
33344:       SendFocusOrBlurEvent(NS_BLUR_CONTENT, presShell, doc, doc, 1, PR_FALSE);
29018:     if (mFocusedWindow == nsnull)
33344:       SendFocusOrBlurEvent(NS_BLUR_CONTENT, presShell, doc, window, 1, PR_FALSE);
29018: 
29018:     // check if a different window was focused
29018:     result = (mFocusedWindow == nsnull && mActiveWindow);
29018:   }
29018:   else if (mActiveWindow) {
29018:     // Otherwise, the blur of the element without blurring the document
42263:     // occurred normally. Call UpdateCaret to redisplay the caret at the right
29018:     // location within the document. This is needed to ensure that the caret
29018:     // used for caret browsing is made visible again when an input field is
29018:     // blurred.
29018:     UpdateCaret(PR_FALSE, PR_TRUE, nsnull);
29018:   }
29018: 
29018:   if (clearFirstBlurEvent)
29018:     mFirstBlurEvent = nsnull;
29018: 
29018:   return result;
29018: }
29018: 
29018: void
29018: nsFocusManager::Focus(nsPIDOMWindow* aWindow,
29018:                       nsIContent* aContent,
29018:                       PRUint32 aFlags,
29018:                       PRBool aIsNewDocument,
29018:                       PRBool aFocusChanged,
57526:                       PRBool aWindowRaised,
57526:                       PRBool aAdjustWidgets)
29018: {
29018:   if (!aWindow)
29018:     return;
29018: 
33241:   if (aContent && (aContent == mFirstFocusEvent || aContent == mFirstBlurEvent))
29018:     return;
29018: 
29018:   // Keep a reference to the presShell since dispatching the DOM event may
29018:   // cause the document to be destroyed.
29018:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
29452:   if (!docShell)
29452:     return;
29018: 
29018:   nsCOMPtr<nsIPresShell> presShell;
29018:   docShell->GetPresShell(getter_AddRefs(presShell));
29018:   if (!presShell)
29018:     return;
29018: 
29018:   // If the focus actually changed, set the focus method (mouse, keyboard, etc).
29018:   // Otherwise, just get the current focus method and use that. This ensures
29018:   // that the method is set during the document and window focus events.
41071:   PRUint32 focusMethod = aFocusChanged ? aFlags & FOCUSMETHODANDRING_MASK :
41071:                          aWindow->GetFocusMethod() | (aFlags & FLAG_SHOWRING);
29018: 
29018:   if (!IsWindowVisible(aWindow)) {
29018:     // if the window isn't visible, for instance because it is a hidden tab,
29018:     // update the current focus and scroll it into view but don't do anything else
29018:     if (CheckIfFocusable(aContent, aFlags)) {
29018:       aWindow->SetFocusedNode(aContent, focusMethod);
29018:       if (aFocusChanged)
29018:         ScrollIntoView(presShell, aContent, aFlags);
29018:     }
29018:     return;
29018:   }
29018: 
29018:   PRBool clearFirstFocusEvent = PR_FALSE;
29018:   if (!mFirstFocusEvent) {
29018:     mFirstFocusEvent = aContent;
29018:     clearFirstFocusEvent = PR_TRUE;
29018:   }
29018: 
29018: #ifdef DEBUG_FOCUS
29018:   PRINTTAGF("**Element %s has been focused", aContent);
29018:   nsCOMPtr<nsIDocument> docm = do_QueryInterface(aWindow->GetExtantDocument());
29018:   if (docm)
41634:     PRINTTAGF(" from %s", docm->GetRootElement());
41071:   printf(" [Newdoc: %d FocusChanged: %d Raised: %d Flags: %x]\n",
29018:          aIsNewDocument, aFocusChanged, aWindowRaised, aFlags);
29018: #endif
29018: 
48711:   if (aIsNewDocument) {
29018:     // if this is a new document, update the parent chain of frames so that
29018:     // focus can be traversed from the top level down to the newly focused
29018:     // window.
35609:     AdjustWindowFocus(aWindow, PR_FALSE);
29018: 
48711:     // Update the window touch registration to reflect the state of
48711:     // the new document that got focus
48711:     aWindow->UpdateTouchState();
48711:   }
48711: 
29018:   // indicate that the window has taken focus.
29018:   if (aWindow->TakeFocus(PR_TRUE, focusMethod))
29018:     aIsNewDocument = PR_TRUE;
29018: 
29018:   mFocusedWindow = aWindow;
29018: 
57526:   // Update the system focus by focusing the root widget.  But avoid this
57526:   // if 1) aAdjustWidgets is false or 2) aContent is a plugin that has its
57526:   // own widget and is either already focused or is about to be focused.
57526:   nsCOMPtr<nsIWidget> objectFrameWidget;
57526:   if (aContent) {
57526:     nsIFrame* contentFrame = aContent->GetPrimaryFrame();
57526:     nsIObjectFrame* objectFrame = do_QueryFrame(contentFrame);
57526:     if (objectFrame)
57526:       objectFrameWidget = objectFrame->GetWidget();
57526:   }
57526:   if (aAdjustWidgets && !objectFrameWidget) {
29018:     nsIViewManager* vm = presShell->GetViewManager();
29018:     if (vm) {
29018:       nsCOMPtr<nsIWidget> widget;
30530:       vm->GetRootWidget(getter_AddRefs(widget));
29018:       if (widget)
33213:         widget->SetFocus(PR_FALSE);
29018:     }
57526:   }
29018: 
29018:   // if switching to a new document, first fire the focus event on the
29018:   // document and then the window.
29018:   if (aIsNewDocument) {
29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(aWindow->GetExtantDocument());
29452:     if (doc)
29018:       SendFocusOrBlurEvent(NS_FOCUS_CONTENT, presShell, doc,
33344:                            doc, aFlags & FOCUSMETHOD_MASK, aWindowRaised);
29018:     if (mFocusedWindow == aWindow && mFocusedContent == nsnull)
29018:       SendFocusOrBlurEvent(NS_FOCUS_CONTENT, presShell, doc,
33344:                            aWindow, aFlags & FOCUSMETHOD_MASK, aWindowRaised);
29018:   }
29018: 
29018:   // check to ensure that the element is still focusable, and that nothing
29018:   // else was focused during the events above.
29018:   if (CheckIfFocusable(aContent, aFlags) &&
29018:       mFocusedWindow == aWindow && mFocusedContent == nsnull) {
29018:     mFocusedContent = aContent;
56051: 
56051:     nsIContent* focusedNode = aWindow->GetFocusedNode();
56051:     PRBool isRefocus = focusedNode && focusedNode->IsEqual(aContent);
56051: 
29018:     aWindow->SetFocusedNode(aContent, focusMethod);
29018: 
41068:     PRBool sendFocusEvent =
41068:       aContent && aContent->IsInDoc() && !IsNonFocusableRoot(aContent);
64121:     nsPresContext* presContext = presShell->GetPresContext();
41068:     if (sendFocusEvent) {
29018:       // if the focused element changed, scroll it into view
29018:       if (aFocusChanged)
29018:         ScrollIntoView(presShell, aContent, aFlags);
29018: 
64121:       NotifyFocusStateChange(aContent, aWindow);
29018: 
36657:       // if this is an object/plug-in, focus the plugin's widget.  Note that we might
36657:       // no longer be in the same document, due to the events we fired above when
36657:       // aIsNewDocument.
57526:       if (aAdjustWidgets && presShell->GetDocument() == aContent->GetDocument()) {
57526:         if (objectFrameWidget)
57526:           objectFrameWidget->SetFocus(PR_FALSE);
36657:       }
29018: 
29018:       nsIMEStateManager::OnChangeFocus(presContext, aContent);
29018: 
29018:       // as long as this focus wasn't because a window was raised, update the
29018:       // commands
29018:       // XXXndeakin P2 someone could adjust the focus during the update
29018:       if (!aWindowRaised)
29018:         aWindow->UpdateCommands(NS_LITERAL_STRING("focus"));
29018: 
56051:       SendFocusOrBlurEvent(NS_FOCUS_CONTENT, presShell,
56051:                            aContent->GetCurrentDoc(),
56051:                            aContent, aFlags & FOCUSMETHOD_MASK,
56051:                            aWindowRaised, isRefocus);
29018: 
29018:       nsIMEStateManager::OnTextStateFocus(presContext, aContent);
41068:     } else {
41068:       nsIMEStateManager::OnTextStateBlur(presContext, nsnull);
41068:       nsIMEStateManager::OnChangeFocus(presContext, nsnull);
41068:       if (!aWindowRaised) {
41068:         aWindow->UpdateCommands(NS_LITERAL_STRING("focus"));
41068:       }
29018:     }
29018:   }
29018:   else {
57526:     // If the window focus event (fired above when aIsNewDocument) caused
57526:     // the plugin not to be focusable, update the system focus by focusing
57526:     // the root widget.
57526:     if (aAdjustWidgets && objectFrameWidget &&
57526:         mFocusedWindow == aWindow && mFocusedContent == nsnull) {
57526:       nsIViewManager* vm = presShell->GetViewManager();
57526:       if (vm) {
57526:         nsCOMPtr<nsIWidget> widget;
57526:         vm->GetRootWidget(getter_AddRefs(widget));
57526:         if (widget)
57526:           widget->SetFocus(PR_FALSE);
57526:       }
57526:     }
57526: 
29018:     nsPresContext* presContext = presShell->GetPresContext();
29018:     nsIMEStateManager::OnTextStateBlur(presContext, nsnull);
29018:     nsIMEStateManager::OnChangeFocus(presContext, nsnull);
29018: 
29018:     if (!aWindowRaised)
29018:       aWindow->UpdateCommands(NS_LITERAL_STRING("focus"));
29018:   }
29018: 
29018:   // update the caret visibility and position to match the newly focused
29018:   // element. However, don't update the position if this was a focus due to a
29018:   // mouse click as the selection code would already have moved the caret as
29018:   // needed. If this is a different document than was focused before, also
29018:   // update the caret's visibility. If this is the same document, the caret
29018:   // visibility should be the same as before so there is no need to update it.
29018:   if (mFocusedContent == aContent)
29018:     UpdateCaret(aFocusChanged && !(aFlags & FLAG_BYMOUSE), aIsNewDocument,
29018:                 mFocusedContent);
29018: 
29018:   if (clearFirstFocusEvent)
29018:     mFirstFocusEvent = nsnull;
29018: }
29018: 
36462: class FocusBlurEvent : public nsRunnable
36462: {
36462: public:
36462:   FocusBlurEvent(nsISupports* aTarget, PRUint32 aType,
56051:                  nsPresContext* aContext, PRBool aWindowRaised,
56051:                  PRBool aIsRefocus)
36462:   : mTarget(aTarget), mType(aType), mContext(aContext),
56051:     mWindowRaised(aWindowRaised), mIsRefocus(aIsRefocus) {}
36462: 
36462:   NS_IMETHOD Run()
36462:   {
36462:     nsFocusEvent event(PR_TRUE, mType);
36462:     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
36462:     event.fromRaise = mWindowRaised;
56051:     event.isRefocus = mIsRefocus;
36462:     return nsEventDispatcher::Dispatch(mTarget, mContext, &event);
36462:   }
36462: 
36462:   nsCOMPtr<nsISupports>   mTarget;
36462:   PRUint32                mType;
39823:   nsRefPtr<nsPresContext> mContext;
36462:   PRBool                  mWindowRaised;
56051:   PRBool                  mIsRefocus;
36462: };
36462: 
29018: void
29018: nsFocusManager::SendFocusOrBlurEvent(PRUint32 aType,
29018:                                      nsIPresShell* aPresShell,
29018:                                      nsIDocument* aDocument,
29018:                                      nsISupports* aTarget,
33344:                                      PRUint32 aFocusMethod,
56051:                                      PRBool aWindowRaised,
56051:                                      PRBool aIsRefocus)
29018: {
29018:   NS_ASSERTION(aType == NS_FOCUS_CONTENT || aType == NS_BLUR_CONTENT,
29018:                "Wrong event type for SendFocusOrBlurEvent");
29018: 
29018:   nsCOMPtr<nsPIDOMEventTarget> eventTarget = do_QueryInterface(aTarget);
29018: 
29018:   // for focus events, if this event was from a mouse or key and event
29018:   // handling on the document is suppressed, queue the event and fire it
29018:   // later. For blur events, a non-zero value would be set for aFocusMethod.
29452:   if (aFocusMethod && aDocument && aDocument->EventHandlingSuppressed()) {
33344:     // aFlags is always 0 when aWindowRaised is true so this won't be called
33344:     // on a window raise.
33344:     NS_ASSERTION(!aWindowRaised, "aWindowRaised should not be set");
33344: 
29018:     for (PRUint32 i = mDelayedBlurFocusEvents.Length(); i > 0; --i) {
29018:       // if this event was already queued, remove it and append it to the end
29018:       if (mDelayedBlurFocusEvents[i - 1].mType == aType &&
29018:           mDelayedBlurFocusEvents[i - 1].mPresShell == aPresShell &&
29018:           mDelayedBlurFocusEvents[i - 1].mDocument == aDocument &&
29018:           mDelayedBlurFocusEvents[i - 1].mTarget == eventTarget) {
29018:         mDelayedBlurFocusEvents.RemoveElementAt(i - 1);
29018:       }
29018:     }
29018: 
29018:     mDelayedBlurFocusEvents.AppendElement(
29018:       nsDelayedBlurOrFocusEvent(aType, aPresShell, aDocument, eventTarget));
29018:     return;
29018:   }
29018: 
36462:   nsContentUtils::AddScriptRunner(
36462:     new FocusBlurEvent(aTarget, aType, aPresShell->GetPresContext(),
56051:                        aWindowRaised, aIsRefocus));
29018: }
29018: 
29018: void
29018: nsFocusManager::ScrollIntoView(nsIPresShell* aPresShell,
29018:                                nsIContent* aContent,
29018:                                PRUint32 aFlags)
29018: {
29018:   // if the noscroll flag isn't set, scroll the newly focused element into view
29018:   if (!(aFlags & FLAG_NOSCROLL))
29018:     aPresShell->ScrollContentIntoView(aContent,
29018:                                       NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
56647:                                       NS_PRESSHELL_SCROLL_IF_NOT_VISIBLE,
56647:                                       nsIPresShell::SCROLL_OVERFLOW_HIDDEN);
29018: }
29018: 
29018: 
29018: void
29018: nsFocusManager::RaiseWindow(nsPIDOMWindow* aWindow)
29018: {
29018:   // don't raise windows that are already raised or are in the process of
29018:   // being lowered
30217:   if (!aWindow || aWindow == mActiveWindow || aWindow == mWindowBeingLowered)
29018:     return;
29018: 
33769: #if defined(XP_WIN) || defined(XP_OS2)
30217:   // Windows would rather we focus the child widget, otherwise, the toplevel
30217:   // widget will always end up being focused. Fortunately, focusing the child
30217:   // widget will also have the effect of raising the window this widget is in.
30217:   // But on other platforms, we can just focus the toplevel widget to raise
30217:   // the window.
30217:   nsCOMPtr<nsPIDOMWindow> childWindow;
30217:   GetFocusedDescendant(aWindow, PR_TRUE, getter_AddRefs(childWindow));
30217:   if (!childWindow)
30217:     childWindow = aWindow;
30217: 
30217:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
30217:   if (!docShell)
30217:     return;
30217: 
30217:   nsCOMPtr<nsIPresShell> presShell;
30217:   docShell->GetPresShell(getter_AddRefs(presShell));
30217:   if (!presShell)
30217:     return;
30217: 
30217:   nsIViewManager* vm = presShell->GetViewManager();
30217:   if (vm) {
30217:     nsCOMPtr<nsIWidget> widget;
30530:     vm->GetRootWidget(getter_AddRefs(widget));
30217:     if (widget)
30217:       widget->SetFocus(PR_TRUE);
30217:   }
30217: #else
29018:   nsCOMPtr<nsIWebNavigation> webnav = do_GetInterface(aWindow);
29018:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin = do_QueryInterface(webnav);
29018:   if (treeOwnerAsWin) {
29018:     nsCOMPtr<nsIWidget> widget;
29018:     treeOwnerAsWin->GetMainWidget(getter_AddRefs(widget));
29018:     if (widget)
29018:       widget->SetFocus(PR_TRUE);
29018:   }
30217: #endif
29018: }
29018: 
29018: void
29018: nsFocusManager::UpdateCaret(PRBool aMoveCaretToFocus,
29018:                             PRBool aUpdateVisibility,
29018:                             nsIContent* aContent)
29018: {
29018: #ifdef DEBUG_FOCUS
29018:   printf("Update Caret: %d %d\n", aMoveCaretToFocus, aUpdateVisibility);
29018: #endif
29018: 
29018:   if (!mFocusedWindow)
29018:     return;
29018: 
29018:   // this is called when a document is focused or when the caretbrowsing
29018:   // preference is changed
29018:   nsCOMPtr<nsIDocShell> focusedDocShell = mFocusedWindow->GetDocShell();
29018:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(focusedDocShell);
29018:   if (!dsti)
29018:     return;
29018: 
29018:   PRInt32 itemType;
29018:   dsti->GetItemType(&itemType);
29018:   if (itemType == nsIDocShellTreeItem::typeChrome)
29018:     return;  // Never browse with caret in chrome
29018: 
29018:   PRPackedBool browseWithCaret =
29018:     nsContentUtils::GetBoolPref("accessibility.browsewithcaret");
29018: 
29018:   nsCOMPtr<nsIPresShell> presShell;
29018:   focusedDocShell->GetPresShell(getter_AddRefs(presShell));
29018:   if (!presShell)
29018:     return;
29018: 
29018:   // If this is an editable document which isn't contentEditable, or a
29018:   // contentEditable document and the node to focus is contentEditable,
29018:   // return, so that we don't mess with caret visibility.
29018:   PRBool isEditable = PR_FALSE;
29018:   nsCOMPtr<nsIEditorDocShell> editorDocShell(do_QueryInterface(dsti));
29018:   if (editorDocShell) {
29018:     editorDocShell->GetEditable(&isEditable);
29018: 
29018:     if (isEditable) {
29018:       nsCOMPtr<nsIHTMLDocument> doc =
29018:         do_QueryInterface(presShell->GetDocument());
29018: 
29018:       PRBool isContentEditableDoc =
29018:         doc && doc->GetEditingState() == nsIHTMLDocument::eContentEditable;
29018: 
29018:       PRBool isFocusEditable =
29018:         aContent && aContent->HasFlag(NODE_IS_EDITABLE);
29018:       if (!isContentEditableDoc || isFocusEditable)
29018:         return;
29018:     }
29018:   }
29018: 
29018:   if (!isEditable && aMoveCaretToFocus)
29018:     MoveCaretToFocus(presShell, aContent);
29018: 
29018:   if (!aUpdateVisibility)
29018:     return;
29018: 
29018:   // XXXndeakin this doesn't seem right. It should be checking for this only
29018:   // on the nearest ancestor frame which is a chrome frame. But this is
29018:   // what the existing code does, so just leave it for now.
29018:   if (!browseWithCaret) {
29018:     nsCOMPtr<nsIContent> docContent =
29018:       do_QueryInterface(mFocusedWindow->GetFrameElementInternal());
29018:     if (docContent)
29018:       browseWithCaret = docContent->AttrValueIs(kNameSpaceID_None,
29018:                                                 nsGkAtoms::showcaret,
29018:                                                 NS_LITERAL_STRING("true"),
29018:                                                 eCaseMatters);
29018:   }
29018: 
29018:   SetCaretVisible(presShell, browseWithCaret, aContent);
29018: }
29018: 
29018: void
29018: nsFocusManager::MoveCaretToFocus(nsIPresShell* aPresShell, nsIContent* aContent)
29018: {
29018:   // rangeDoc is a document interface we can create a range with
29018:   nsCOMPtr<nsIDOMDocumentRange> rangeDoc(do_QueryInterface(aPresShell->GetDocument()));
29018:   if (rangeDoc) {
29018:     nsCOMPtr<nsFrameSelection> frameSelection = aPresShell->FrameSelection();
29018:     nsCOMPtr<nsISelection> domSelection = frameSelection->
29018:       GetSelection(nsISelectionController::SELECTION_NORMAL);
29018:     if (domSelection) {
29018:       nsCOMPtr<nsIDOMNode> currentFocusNode(do_QueryInterface(aContent));
29018:       // First clear the selection. This way, if there is no currently focused
29018:       // content, the selection will just be cleared.
29018:       domSelection->RemoveAllRanges();
29018:       if (currentFocusNode) {
29018:         nsCOMPtr<nsIDOMRange> newRange;
29018:         nsresult rv = rangeDoc->CreateRange(getter_AddRefs(newRange));
29018:         if (NS_SUCCEEDED(rv)) {
29018:           // Set the range to the start of the currently focused node
29018:           // Make sure it's collapsed
29018:           newRange->SelectNodeContents(currentFocusNode);
29018:           nsCOMPtr<nsIDOMNode> firstChild;
29018:           currentFocusNode->GetFirstChild(getter_AddRefs(firstChild));
29018:           if (!firstChild ||
29018:               aContent->IsNodeOfType(nsINode::eHTML_FORM_CONTROL)) {
29018:             // If current focus node is a leaf, set range to before the
29018:             // node by using the parent as a container.
29018:             // This prevents it from appearing as selected.
29018:             newRange->SetStartBefore(currentFocusNode);
29018:             newRange->SetEndBefore(currentFocusNode);
29018:           }
29018:           domSelection->AddRange(newRange);
29018:           domSelection->CollapseToStart();
29018:         }
29018:       }
29018:     }
29018:   }
29018: }
29018: 
29018: nsresult
29018: nsFocusManager::SetCaretVisible(nsIPresShell* aPresShell,
29018:                                 PRBool aVisible,
29018:                                 nsIContent* aContent)
29018: {
29018:   // When browsing with caret, make sure caret is visible after new focus
29018:   // Return early if there is no caret. This can happen for the testcase
29018:   // for bug 308025 where a window is closed in a blur handler.
40045:   nsRefPtr<nsCaret> caret = aPresShell->GetCaret();
29018:   if (!caret)
29018:     return NS_OK;
29018: 
29018:   PRBool caretVisible = PR_FALSE;
29018:   caret->GetCaretVisible(&caretVisible);
29018:   if (!aVisible && !caretVisible)
29018:     return NS_OK;
29018: 
29018:   nsCOMPtr<nsFrameSelection> frameSelection;
29018:   if (aContent) {
36657:     NS_ASSERTION(aContent->GetDocument() == aPresShell->GetDocument(),
36657:                  "Wrong document?");
36657:     nsIFrame *focusFrame = aContent->GetPrimaryFrame();
29018:     if (focusFrame)
29018:       frameSelection = focusFrame->GetFrameSelection();
29018:   }
29018: 
29018:   nsCOMPtr<nsFrameSelection> docFrameSelection = aPresShell->FrameSelection();
29018: 
29018:   if (docFrameSelection && caret &&
29018:      (frameSelection == docFrameSelection || !aContent)) {
29018:     nsISelection* domSelection = docFrameSelection->
29018:       GetSelection(nsISelectionController::SELECTION_NORMAL);
29018:     if (domSelection) {
58616:       // First, hide the caret to prevent attempting to show it in SetCaretDOMSelection
58616:       caret->SetCaretVisible(PR_FALSE);
58616: 
58616:       // Tell the caret which selection to use
29018:       caret->SetCaretDOMSelection(domSelection);
29018: 
29018:       // In content, we need to set the caret. The only special case is edit
29018:       // fields, which have a different frame selection from the document.
29018:       // They will take care of making the caret visible themselves.
29018: 
29018:       nsCOMPtr<nsISelectionController> selCon(do_QueryInterface(aPresShell));
29018:       if (!selCon)
29018:         return NS_ERROR_FAILURE;
29018: 
29018:       selCon->SetCaretEnabled(aVisible);
29018:       caret->SetCaretVisible(aVisible);
29018:     }
29018:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: nsresult
29018: nsFocusManager::GetSelectionLocation(nsIDocument* aDocument,
29018:                                      nsIPresShell* aPresShell,
29018:                                      nsIContent **aStartContent,
29018:                                      nsIContent **aEndContent)
29018: {
29018:   *aStartContent = *aEndContent = nsnull;
29018:   nsresult rv = NS_ERROR_FAILURE;
29018: 
29018:   nsPresContext* presContext = aPresShell->GetPresContext();
29018:   NS_ASSERTION(presContext, "mPresContent is null!!");
29018: 
29018:   nsCOMPtr<nsFrameSelection> frameSelection;
29018:   frameSelection = aPresShell->FrameSelection();
29018: 
29018:   nsCOMPtr<nsISelection> domSelection;
29018:   if (frameSelection) {
29018:     domSelection = frameSelection->
29018:       GetSelection(nsISelectionController::SELECTION_NORMAL);
29018:   }
29018: 
29018:   nsCOMPtr<nsIDOMNode> startNode, endNode;
29018:   PRBool isCollapsed = PR_FALSE;
29018:   nsCOMPtr<nsIContent> startContent, endContent;
29018:   PRInt32 startOffset = 0;
29018:   if (domSelection) {
29018:     domSelection->GetIsCollapsed(&isCollapsed);
29018:     nsCOMPtr<nsIDOMRange> domRange;
29018:     rv = domSelection->GetRangeAt(0, getter_AddRefs(domRange));
29018:     if (domRange) {
29018:       domRange->GetStartContainer(getter_AddRefs(startNode));
29018:       domRange->GetEndContainer(getter_AddRefs(endNode));
29018:       domRange->GetStartOffset(&startOffset);
29018: 
29018:       nsIContent *childContent = nsnull;
29018: 
29018:       startContent = do_QueryInterface(startNode);
41639:       if (startContent && startContent->IsElement()) {
29018:         NS_ASSERTION(startOffset >= 0, "Start offset cannot be negative");  
29018:         childContent = startContent->GetChildAt(startOffset);
29018:         if (childContent) {
29018:           startContent = childContent;
29018:         }
29018:       }
29018: 
29018:       endContent = do_QueryInterface(endNode);
41639:       if (endContent && endContent->IsElement()) {
29018:         PRInt32 endOffset = 0;
29018:         domRange->GetEndOffset(&endOffset);
29018:         NS_ASSERTION(endOffset >= 0, "End offset cannot be negative");
29018:         childContent = endContent->GetChildAt(endOffset);
29018:         if (childContent) {
29018:           endContent = childContent;
29018:         }
29018:       }
29018:     }
29018:   }
29018:   else {
29018:     rv = NS_ERROR_INVALID_ARG;
29018:   }
29018: 
29018:   nsIFrame *startFrame = nsnull;
29018:   if (startContent) {
36657:     startFrame = startContent->GetPrimaryFrame();
29018:     if (isCollapsed) {
29018:       // Next check to see if our caret is at the very end of a node
29018:       // If so, the caret is actually sitting in front of the next
29018:       // logical frame's primary node - so for this case we need to
29018:       // change caretContent to that node.
29018: 
29018:       nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(startContent));
29018:       PRUint16 nodeType;
29018:       domNode->GetNodeType(&nodeType);
29018: 
29018:       if (nodeType == nsIDOMNode::TEXT_NODE) {
29018:         nsAutoString nodeValue;
29018:         domNode->GetNodeValue(nodeValue);
29018: 
29018:         PRBool isFormControl =
29018:           startContent->IsNodeOfType(nsINode::eHTML_FORM_CONTROL);
29018: 
29018:         if (nodeValue.Length() == (PRUint32)startOffset && !isFormControl &&
41634:             startContent != aDocument->GetRootElement()) {
29018:           // Yes, indeed we were at the end of the last node
29018:           nsCOMPtr<nsIFrameEnumerator> frameTraversal;
29018:           nsresult rv = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
29018:                                              presContext, startFrame,
29018:                                              eLeaf,
29018:                                              PR_FALSE, // aVisual
29018:                                              PR_FALSE, // aLockInScrollView
29018:                                              PR_TRUE   // aFollowOOFs
29018:                                              );
29018:           NS_ENSURE_SUCCESS(rv, rv);
29018: 
29018:           nsIFrame *newCaretFrame = nsnull;
29018:           nsCOMPtr<nsIContent> newCaretContent = startContent;
29018:           PRBool endOfSelectionInStartNode(startContent == endContent);
29018:           do {
29018:             // Continue getting the next frame until the primary content for the frame
29018:             // we are on changes - we don't want to be stuck in the same place
29018:             frameTraversal->Next();
31380:             newCaretFrame = static_cast<nsIFrame*>(frameTraversal->CurrentItem());
29018:             if (nsnull == newCaretFrame)
29018:               break;
29018:             newCaretContent = newCaretFrame->GetContent();            
29018:           } while (!newCaretContent || newCaretContent == startContent);
29018: 
29018:           if (newCaretFrame && newCaretContent) {
29018:             // If the caret is exactly at the same position of the new frame,
29018:             // then we can use the newCaretFrame and newCaretContent for our position
40045:             nsRefPtr<nsCaret> caret = aPresShell->GetCaret();
29018:             nsRect caretRect;
39425:             nsIFrame *frame = caret->GetGeometry(domSelection, &caretRect);
39425:             if (frame) {
47148:               nsPoint caretWidgetOffset;
47148:               nsIWidget *widget = frame->GetNearestWidget(caretWidgetOffset);
47148:               caretRect.MoveBy(caretWidgetOffset);
39425:               nsPoint newCaretOffset;
47148:               nsIWidget *newCaretWidget = newCaretFrame->GetNearestWidget(newCaretOffset);
47148:               if (widget == newCaretWidget && caretRect.y == newCaretOffset.y &&
39425:                   caretRect.x == newCaretOffset.x) {
29018:                 // The caret is at the start of the new element.
29018:                 startFrame = newCaretFrame;
29018:                 startContent = newCaretContent;
29018:                 if (endOfSelectionInStartNode) {
29018:                   endContent = newCaretContent; // Ensure end of selection is not before start
29018:                 }
29018:               }
29018:             }
29018:           }
29018:         }
29018:       }
29018:     }
39425:   }
29018: 
29018:   *aStartContent = startContent;
29018:   *aEndContent = endContent;
29018:   NS_IF_ADDREF(*aStartContent);
29018:   NS_IF_ADDREF(*aEndContent);
29018: 
29018:   return rv;
29018: }
29018: 
29018: nsresult
29018: nsFocusManager::DetermineElementToMoveFocus(nsPIDOMWindow* aWindow,
29018:                                             nsIContent* aStartContent,
29018:                                             PRInt32 aType,
29018:                                             nsIContent** aNextContent)
29018: {
29018:   *aNextContent = nsnull;
29018: 
29018:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
29018:   if (!docShell)
29018:     return NS_OK;
29018: 
29018:   nsCOMPtr<nsIContent> startContent = aStartContent;
29018:   if (!startContent && aType != MOVEFOCUS_CARET)
29018:     startContent = aWindow->GetFocusedNode();
29018: 
29018:   nsCOMPtr<nsIDocument> doc;
29018:   if (startContent)
29018:     doc = startContent->GetCurrentDoc();
29018:   else
29018:     doc = do_QueryInterface(aWindow->GetExtantDocument());
29018:   if (!doc)
29018:     return NS_OK;
29018: 
29018:   nsCOMPtr<nsILookAndFeel> lookNFeel(do_GetService(kLookAndFeelCID));
29018:   lookNFeel->GetMetric(nsILookAndFeel::eMetric_TabFocusModel,
29018:                        nsIContent::sTabFocusModel);
29018: 
29018:   if (aType == MOVEFOCUS_ROOT) {
29018:     NS_IF_ADDREF(*aNextContent = GetRootForFocus(aWindow, doc, PR_FALSE, PR_FALSE));
29018:     return NS_OK;
29018:   }
29018:   if (aType == MOVEFOCUS_FORWARDDOC) {
29018:     NS_IF_ADDREF(*aNextContent = GetNextTabbableDocument(PR_TRUE));
29018:     return NS_OK;
29018:   }
29018:   if (aType == MOVEFOCUS_BACKWARDDOC) {
29018:     NS_IF_ADDREF(*aNextContent = GetNextTabbableDocument(PR_FALSE));
29018:     return NS_OK;
29018:   }
29018:   
41634:   nsIContent* rootContent = doc->GetRootElement();
29018:   NS_ENSURE_TRUE(rootContent, NS_OK);
29018: 
46225:   nsIPresShell *presShell = doc->GetShell();
29018:   NS_ENSURE_TRUE(presShell, NS_OK);
29018: 
29018:   if (aType == MOVEFOCUS_FIRST) {
29018:     if (!aStartContent)
29018:       startContent = rootContent;
29018:     return GetNextTabbableContent(presShell, startContent,
29018:                                   nsnull, startContent,
29018:                                   PR_TRUE, 1, PR_FALSE, aNextContent);
29018:   }
29018:   if (aType == MOVEFOCUS_LAST) {
29018:     if (!aStartContent)
29018:       startContent = rootContent;
29018:     return GetNextTabbableContent(presShell, startContent,
29018:                                   nsnull, startContent,
29018:                                   PR_FALSE, 0, PR_FALSE, aNextContent);
29018:   }
29018: 
38430:   PRBool forward = (aType == MOVEFOCUS_FORWARD || aType == MOVEFOCUS_CARET);
29018:   PRBool doNavigation = PR_TRUE;
29018:   PRBool ignoreTabIndex = PR_FALSE;
29018:   // when a popup is open, we want to ensure that tab navigation occurs only
29018:   // within the most recently opened panel. If a popup is open, its frame will
29018:   // be stored in popupFrame.
29018:   nsIFrame* popupFrame = nsnull;
29018: 
29018:   PRInt32 tabIndex = forward ? 1 : 0;
29018:   if (startContent) {
36657:     nsIFrame* frame = startContent->GetPrimaryFrame();
29018:     if (startContent->Tag() == nsGkAtoms::area &&
33329:         startContent->IsHTML())
29018:       startContent->IsFocusable(&tabIndex);
29018:     else if (frame)
29018:       frame->IsFocusable(&tabIndex, 0);
35170:     else
35170:       startContent->IsFocusable(&tabIndex);
29018: 
29018:     // if the current element isn't tabbable, ignore the tabindex and just
29018:     // look for the next element. The root content won't have a tabindex
29018:     // so just treat this as the beginning of the tab order.
29018:     if (tabIndex < 0) {
29018:       tabIndex = 1;
29018:       if (startContent != rootContent)
29018:         ignoreTabIndex = PR_TRUE;
29018:     }
29018: 
29018:     // check if the focus is currently inside a popup. Elements such as the
29018:     // autocomplete widget use the noautofocus attribute to allow the focus to
29018:     // remain outside the popup when it is opened.
29018:     if (frame) {
29018:       popupFrame = nsLayoutUtils::GetClosestFrameOfType(frame,
29018:                                                         nsGkAtoms::menuPopupFrame);
29018:     }
29018: 
29018:     if (popupFrame) {
29018:       // Don't navigate outside of a popup, so pretend that the
29018:       // root content is the popup itself
29018:       rootContent = popupFrame->GetContent();
29018:       NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
29018:     }
41068:     else if (!forward) {
41068:       // If focus moves backward and when current focused node is root
41068:       // content or <body> element which is editable by contenteditable
41068:       // attribute, focus should move to its parent document.
41068:       if (startContent == rootContent) {
29018:         doNavigation = PR_FALSE;
41068:       } else {
41068:         nsIDocument* doc = startContent->GetCurrentDoc();
41068:         if (startContent ==
41068:               nsLayoutUtils::GetEditableRootContentByContentEditable(doc)) {
41068:           doNavigation = PR_FALSE;
41068:         }
41068:       }
29018:     }
29018:   }
29018:   else {
29018: #ifdef MOZ_XUL
29018:     // if there is no focus, yet a panel is open, focus the first item in
29018:     // the panel
29018:     nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
29018:     if (pm)
29018:       popupFrame = pm->GetTopPopup(ePopupTypePanel);
29018: #endif
29018:     if (popupFrame) {
29018:       rootContent = popupFrame->GetContent();
29018:       NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
29018:       startContent = rootContent;
29018:     }
29018:     else {
29018:       // Otherwise, for content shells, start from the location of the caret.
29018:       PRInt32 itemType;
29018:       nsCOMPtr<nsIDocShellTreeItem> shellItem = do_QueryInterface(docShell);
29018:       shellItem->GetItemType(&itemType);
29018:       if (itemType != nsIDocShellTreeItem::typeChrome) {
29018:         nsCOMPtr<nsIContent> endSelectionContent;
29018:         GetSelectionLocation(doc, presShell,
29018:                              getter_AddRefs(startContent),
29018:                              getter_AddRefs(endSelectionContent));
29018:         // If the selection is on the rootContent, then there is no selection
29018:         if (startContent == rootContent) {
29018:           startContent = nsnull;
29018:         }
29018:         else if (startContent && startContent->HasFlag(NODE_IS_EDITABLE)) {
29018:           // Don't start from the selection if the selection is in a
29018:           // contentEditable region.
29018:           nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(doc);
29018:           if (htmlDoc &&
29018:               htmlDoc->GetEditingState() == nsIHTMLDocument::eContentEditable)
29018:             startContent = nsnull;
29018:         }
29018: 
38430:         if (aType == MOVEFOCUS_CARET) {
38430:           // GetFocusInSelection finds a focusable link near the caret.
38430:           // If there is no start content though, don't do this to avoid
38430:           // focusing something unexpected.
29018:           if (startContent) {
29018:             GetFocusInSelection(aWindow, startContent,
29018:                                 endSelectionContent, aNextContent);
38430:           }
29018:           return NS_OK;
29018:         }
29018: 
38430:         if (startContent) {
29018:           // when starting from a selection, we always want to find the next or
29018:           // previous element in the document. So the tabindex on elements
29018:           // should be ignored.
29018:           ignoreTabIndex = PR_TRUE;
29018:         }
29018:       }
29018: 
29018:       if (!startContent) {
29018:         // otherwise, just use the root content as the starting point
29018:         startContent = rootContent;
29018:         NS_ENSURE_TRUE(startContent, NS_OK);
29018:       }
29018:     }
29018:   }
29018: 
29018:   NS_ASSERTION(startContent, "starting content not set");
29018: 
29018:   // keep a reference to the starting content. If we find that again, it means
29018:   // we've iterated around completely and we don't want to adjust the focus.
29018:   // The skipOriginalContentCheck will be set to true only for the first time
29018:   // GetNextTabbableContent is called. This ensures that we don't break out
29018:   // when nothing is focused to start with. Specifically,
29018:   // GetNextTabbableContent first checks the root content -- which happens to
29018:   // be the same as the start content -- when nothing is focused and tabbing
29018:   // forward. Without skipOriginalContentCheck set to true, we'd end up
29018:   // returning right away and focusing nothing. Luckily, GetNextTabbableContent
29018:   // will never wrap around on its own, and can only return the original
29018:   // content when it is called a second time or later.
29018:   PRBool skipOriginalContentCheck = PR_TRUE;
29018:   nsIContent* originalStartContent = startContent;
29018: 
29018: #ifdef DEBUG_FOCUS_NAVIGATION
29018:   PRINTTAGF("Focus Navigation Start Content %s\n", startContent);
29018:   printf("[Tabindex: %d Ignore: %d]", tabIndex, ignoreTabIndex);
29018: #endif
29018: 
29018:   while (doc) {
29018:     if (doNavigation) {
29018:       nsCOMPtr<nsIContent> nextFocus;
29018:       nsresult rv = GetNextTabbableContent(presShell, rootContent,
29018:                                            skipOriginalContentCheck ? nsnull : originalStartContent,
29018:                                            startContent, forward,
29018:                                            tabIndex, ignoreTabIndex,
29018:                                            getter_AddRefs(nextFocus));
29018:       NS_ENSURE_SUCCESS(rv, rv);
29018: 
29018:       // found a content node to focus.
29018:       if (nextFocus) {
29018: #ifdef DEBUG_FOCUS_NAVIGATION
29018:         PRINTTAGF("Next Content: %s\n", nextFocus);
29018: #endif
29018:         // as long as the found node was not the same as the starting node,
29018:         // set it as the return value.
29018:         if (nextFocus != originalStartContent)
29018:           NS_ADDREF(*aNextContent = nextFocus);
29018:         return NS_OK;
29018:       }
29018: 
29018:       if (popupFrame) {
29018:         // in a popup, so start again from the beginning of the popup. However,
29018:         // if we already started at the beginning, then there isn't anything to
29018:         // focus, so just return
29018:         if (startContent != rootContent) {
29018:           startContent = rootContent;
29018:           tabIndex = forward ? 1 : 0;
29018:           continue;
29018:         }
29018:         return NS_OK;
29018:       }
29018:     }
29018: 
29018:     doNavigation = PR_TRUE;
29018:     skipOriginalContentCheck = PR_FALSE;
29018:     ignoreTabIndex = PR_FALSE;
29018: 
29018:     // reached the beginning or end of the document. Traverse up to the parent
29018:     // document and try again.
29018:     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(docShell);
29018: 
29018:     nsCOMPtr<nsIDocShellTreeItem> docShellParent;
29018:     dsti->GetParent(getter_AddRefs(docShellParent));
29018:     if (docShellParent) {
29018:       // move up to the parent shell and try again from there.
29018: 
29018:       // first, get the frame element this window is inside.
29018:       nsCOMPtr<nsPIDOMWindow> piWindow = do_GetInterface(docShell);
29018:       NS_ENSURE_TRUE(piWindow, NS_ERROR_FAILURE);
29018: 
29018:       // Next, retrieve the parent docshell, document and presshell.
29018:       docShell = do_QueryInterface(docShellParent);
29018:       NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
29018: 
29018:       nsCOMPtr<nsPIDOMWindow> piParentWindow = do_GetInterface(docShellParent);
29018:       NS_ENSURE_TRUE(piParentWindow, NS_ERROR_FAILURE);
29018:       doc = do_QueryInterface(piParentWindow->GetExtantDocument());
29018:       NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
29018: 
46225:       presShell = doc->GetShell();
29018: 
41634:       rootContent = doc->GetRootElement();
29018:       startContent = do_QueryInterface(piWindow->GetFrameElementInternal());
29018:       if (startContent) {
36657:         nsIFrame* frame = startContent->GetPrimaryFrame();
29018:         if (!frame)
29018:           return NS_OK;
29018: 
29018:         frame->IsFocusable(&tabIndex, 0);
29018:         if (tabIndex < 0) {
29018:           tabIndex = 1;
29018:           ignoreTabIndex = PR_TRUE;
29018:         }
29018: 
29018:         // if the frame is inside a popup, make sure to scan only within the
29018:         // popup. This handles the situation of tabbing amongst elements
29018:         // inside an iframe which is itself inside a popup. Otherwise,
29018:         // navigation would move outside the popup when tabbing outside the
29018:         // iframe.
29018:         popupFrame = nsLayoutUtils::GetClosestFrameOfType(frame,
29018:                                                           nsGkAtoms::menuPopupFrame);
29018:         if (popupFrame) {
29018:           rootContent = popupFrame->GetContent();
29018:           NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
29018:         }
29018:       }
29018:       else {
29018:         startContent = rootContent;
29018:         tabIndex = forward ? 1 : 0;
29018:       }
29018:     }
29018:     else {
29018:       // no parent, so call the tree owner. This will tell the embedder that
29018:       // it should take the focus.
29018:       PRBool tookFocus;
29018:       docShell->TabToTreeOwner(forward, &tookFocus);
29018:       // if the tree owner, took the focus, blur the current content
29018:       if (tookFocus) {
29018:         nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(docShell);
29018:         if (window->GetFocusedNode() == mFocusedContent)
57526:           Blur(mFocusedWindow, nsnull, PR_TRUE, PR_TRUE);
29018:         else
29018:           window->SetFocusedNode(nsnull);
29018:         return NS_OK;
29018:       }
29018: 
29018:       // reset the tab index and start again from the beginning or end
29018:       startContent = rootContent;
29018:       tabIndex = forward ? 1 : 0;
29018:     }
29018: 
29018:     // wrapped all the way around and didn't find anything to move the focus
29018:     // to, so just break out
29018:     if (startContent == originalStartContent)
29018:       break;
29018:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: nsresult
29018: nsFocusManager::GetNextTabbableContent(nsIPresShell* aPresShell,
29018:                                        nsIContent* aRootContent,
29018:                                        nsIContent* aOriginalStartContent,
29018:                                        nsIContent* aStartContent,
29018:                                        PRBool aForward,
29018:                                        PRInt32 aCurrentTabIndex,
29018:                                        PRBool aIgnoreTabIndex,
29018:                                        nsIContent** aResultContent)
29018: {
29018:   *aResultContent = nsnull;
29018: 
35170:   nsCOMPtr<nsIContent> startContent = aStartContent;
35170:   if (!startContent)
29018:     return NS_OK;
29018: 
29018: #ifdef DEBUG_FOCUS_NAVIGATION
29018:   PRINTTAGF("GetNextTabbable: %s", aStartContent);
29018:   printf(" tabindex: %d\n", aCurrentTabIndex);
29018: #endif
29018: 
29018:   nsPresContext* presContext = aPresShell->GetPresContext();
29018: 
35170:   PRBool getNextFrame = PR_TRUE;
35170:   nsCOMPtr<nsIContent> iterStartContent = aStartContent;
29018:   while (1) {
36657:     nsIFrame* startFrame = iterStartContent->GetPrimaryFrame();
35170:     // if there is no frame, look for another content node that has a frame
35170:     if (!startFrame) {
35170:       // if the root content doesn't have a frame, just return
35170:       if (iterStartContent == aRootContent)
29018:         return NS_OK;
35170: 
35170:       // look for the next or previous content node in tree order
35170:       nsTreeWalker walker(aRootContent, nsIDOMNodeFilter::SHOW_ALL, nsnull, PR_TRUE);
35170:       nsCOMPtr<nsIDOMNode> nextNode = do_QueryInterface(iterStartContent);
35170:       walker.SetCurrentNode(nextNode);
35170:       if (NS_SUCCEEDED(aForward ? walker.NextNode(getter_AddRefs(nextNode)) :
35170:                                   walker.PreviousNode(getter_AddRefs(nextNode)))) {
35170:         iterStartContent = do_QueryInterface(nextNode);
35170:         // we've already skipped over the initial focused content, so we
35170:         // don't want to traverse frames.
35170:         getNextFrame = PR_FALSE;
35170:         if (iterStartContent)
35170:           continue;
35170:       }
35170: 
35170:       // otherwise, as a last attempt, just look at the root content
35170:       iterStartContent = aRootContent;
35170:       continue;
29018:     }
29018: 
29018:     nsCOMPtr<nsIFrameEnumerator> frameTraversal;
29018:     nsresult rv = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
35170:                                        presContext, startFrame,
29018:                                        ePreOrder,
29018:                                        PR_FALSE, // aVisual
29018:                                        PR_FALSE, // aLockInScrollView
29018:                                        PR_TRUE   // aFollowOOFs
29018:                                        );
29018:     NS_ENSURE_SUCCESS(rv, rv);
29018: 
35170:     if (iterStartContent == aRootContent) {
41068:       if (!aForward) {
29018:         frameTraversal->Last();
41068:       } else if (aRootContent->IsFocusable()) {
41068:         frameTraversal->Next();
41068:       }
29018:     }
35170:     else if (getNextFrame &&
35170:              (!iterStartContent || iterStartContent->Tag() != nsGkAtoms::area ||
35170:               !iterStartContent->IsHTML())) {
29018:       // Need to do special check in case we're in an imagemap which has multiple
29018:       // content nodes per frame, so don't skip over the starting frame.
29018:       if (aForward)
29018:         frameTraversal->Next();
29018:       else
29018:         frameTraversal->Prev();
29018:     }
29018: 
29018:     // Walk frames to find something tabbable matching mCurrentTabIndex
29018:     nsIFrame* frame = static_cast<nsIFrame*>(frameTraversal->CurrentItem());
29018:     while (frame) {
29018:       // TabIndex not set defaults to 0 for form elements, anchors and other
29018:       // elements that are normally focusable. Tabindex defaults to -1
29018:       // for elements that are not normally focusable.
29018:       // The returned computed tabindex from IsFocusable() is as follows:
29018:       //          < 0 not tabbable at all
29018:       //          == 0 in normal tab order (last after positive tabindexed items)
29018:       //          > 0 can be tabbed to in the order specified by this value
29018: 
29018:       PRInt32 tabIndex;
29018:       frame->IsFocusable(&tabIndex, 0);
29018: 
29018: #ifdef DEBUG_FOCUS_NAVIGATION
29018:       if (frame->GetContent()) {
29018:         PRINTTAGF("Next Tabbable %s:", frame->GetContent());
29018:         printf(" with tabindex: %d expected: %d\n", tabIndex, aCurrentTabIndex);
29018:       }
29018: #endif
29018: 
29018:       nsIContent* currentContent = frame->GetContent();
29018:       if (tabIndex >= 0) {
29018:         NS_ASSERTION(currentContent, "IsFocusable set a tabindex for a frame with no content");
29018:         if (currentContent->Tag() == nsGkAtoms::img &&
29018:             currentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::usemap)) {
29018:           // This is an image with a map. Image map areas are not traversed by
29018:           // nsIFrameTraversal so look for the next or previous area element.
29018:           nsIContent *areaContent =
29018:             GetNextTabbableMapArea(aForward, aCurrentTabIndex,
35170:                                    currentContent, iterStartContent);
29018:           if (areaContent) {
29018:             NS_ADDREF(*aResultContent = areaContent);
29018:             return NS_OK;
29018:           }
29018:         }
29018:         else if (aIgnoreTabIndex || aCurrentTabIndex == tabIndex) {
29018:           // break out if we've wrapped around to the start again.
29018:           if (aOriginalStartContent && currentContent == aOriginalStartContent) {
29018:             NS_ADDREF(*aResultContent = currentContent);
29018:             return NS_OK;
29018:           }
29018: 
29018:           // found a node with a matching tab index. Check if it is a child
29018:           // frame. If so, navigate into the child frame instead.
29018:           nsIDocument* doc = currentContent->GetCurrentDoc();
29018:           NS_ASSERTION(doc, "content not in document");
29018:           nsIDocument* subdoc = doc->GetSubDocumentFor(currentContent);
29018:           if (subdoc) {
29018:             if (!subdoc->EventHandlingSuppressed()) {
29018:               if (aForward) {
29018:                 // when tabbing forward into a frame, return the root
29018:                 // frame so that the canvas becomes focused.
29018:                 nsCOMPtr<nsPIDOMWindow> subframe = subdoc->GetWindow();
29018:                 if (subframe) {
41068:                   // If the subframe body is editable by contenteditable,
41068:                   // we should set the editor's root element rather than the
41068:                   // actual root element.  Otherwise, we should set the focus
41068:                   // to the root content.
41068:                   *aResultContent =
41068:                     nsLayoutUtils::GetEditableRootContentByContentEditable(subdoc);
41068:                   if (!*aResultContent ||
41068:                       !((*aResultContent)->GetPrimaryFrame())) {
41068:                     *aResultContent =
41068:                       GetRootForFocus(subframe, subdoc, PR_FALSE, PR_TRUE);
41068:                   }
29018:                   if (*aResultContent) {
29018:                     NS_ADDREF(*aResultContent);
29018:                     return NS_OK;
29018:                   }
29018:                 }
29018:               }
41634:               Element* rootElement = subdoc->GetRootElement();
46225:               nsIPresShell* subShell = subdoc->GetShell();
41634:               if (rootElement && subShell) {
41634:                 rv = GetNextTabbableContent(subShell, rootElement,
41634:                                             aOriginalStartContent, rootElement,
29018:                                             aForward, (aForward ? 1 : 0),
29018:                                             PR_FALSE, aResultContent);
29018:                 NS_ENSURE_SUCCESS(rv, rv);
29018:                 if (*aResultContent)
29018:                   return NS_OK;
29018:               }
29018:             }
29018:           }
29018:           // otherwise, use this as the next content node to tab to, unless
29018:           // this was the element we started on. This would happen for
29018:           // instance on an element with child frames, where frame navigation
29018:           // could return the original element again. In that case, just skip
29018:           // it. Also, if the next content node is the root content, then
29018:           // return it. This latter case would happen only if someone made a
29018:           // popup focusable.
31115:           // Also, when going backwards, check to ensure that the focus
31115:           // wouldn't be redirected. Otherwise, for example, when an input in
31115:           // a textbox is focused, the enclosing textbox would be found and
31115:           // the same inner input would be returned again.
31115:           else if (currentContent == aRootContent ||
35170:                    (currentContent != startContent &&
31115:                     (aForward || !GetRedirectedFocus(currentContent)))) {
29018:             NS_ADDREF(*aResultContent = currentContent);
29018:             return NS_OK;
29018:           }
29018:         }
29018:       }
29018:       else if (aOriginalStartContent && currentContent == aOriginalStartContent) {
29018:         // not focusable, so return if we have wrapped around to the original
29018:         // content. This is necessary in case the original starting content was
29018:         // not focusable.
29018:         NS_ADDREF(*aResultContent = currentContent);
29018:         return NS_OK;
29018:       }
29018: 
29018:       // Move to the next or previous frame, but ignore continuation frames
29018:       // since only the first frame should be involved in focusability.
29018:       // Otherwise, a loop will occur in the following example:
29018:       //   <span tabindex="1">...<a/><a/>...</span>
29018:       // where the text wraps onto multiple lines. Tabbing from the second
29018:       // link can find one of the span's continuation frames between the link
29018:       // and the end of the span, and the span would end up getting focused
29018:       // again.
29018:       do {
29018:         if (aForward)
29018:           frameTraversal->Next();
29018:         else
29018:           frameTraversal->Prev();
29018:         frame = static_cast<nsIFrame*>(frameTraversal->CurrentItem());
29018:       } while (frame && frame->GetPrevContinuation());
29018:     }
29018: 
29018:     // If already at lowest priority tab (0), end search completely.
29018:     // A bit counterintuitive but true, tabindex order goes 1, 2, ... 32767, 0
29018:     if (aCurrentTabIndex == (aForward ? 0 : 1)) {
29018:       // if going backwards, the canvas should be focused once the beginning
29018:       // has been reached.
29018:       if (!aForward) {
29018:         nsCOMPtr<nsPIDOMWindow> window = GetCurrentWindow(aRootContent);
29018:         NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
29018:         NS_IF_ADDREF(*aResultContent =
29018:                      GetRootForFocus(window, aRootContent->GetCurrentDoc(), PR_FALSE, PR_TRUE));
29018:       }
29018:       break;
29018:     }
29018: 
29018:     // continue looking for next highest priority tabindex
29018:     aCurrentTabIndex = GetNextTabIndex(aRootContent, aCurrentTabIndex, aForward);
35170:     startContent = iterStartContent = aRootContent;
29018:   }
29018: 
29018:   return NS_OK;
29018: }
29018: 
29018: nsIContent*
29018: nsFocusManager::GetNextTabbableMapArea(PRBool aForward,
29018:                                        PRInt32 aCurrentTabIndex,
29018:                                        nsIContent* aImageContent,
29018:                                        nsIContent* aStartContent)
29018: {
29018:   nsAutoString useMap;
29018:   aImageContent->GetAttr(kNameSpaceID_None, nsGkAtoms::usemap, useMap);
29018: 
29018:   nsCOMPtr<nsIDocument> doc = aImageContent->GetDocument();
29018:   if (doc) {
29018:     nsCOMPtr<nsIDOMHTMLMapElement> imageMap = nsImageMapUtils::FindImageMap(doc, useMap);
29018:     if (!imageMap)
29018:       return nsnull;
29018:     nsCOMPtr<nsIContent> mapContent = do_QueryInterface(imageMap);
29018:     PRUint32 count = mapContent->GetChildCount();
29018:     // First see if the the start content is in this map
29018: 
29018:     PRInt32 index = mapContent->IndexOf(aStartContent);
29018:     PRInt32 tabIndex;
29018:     if (index < 0 || (aStartContent->IsFocusable(&tabIndex) &&
29018:                       tabIndex != aCurrentTabIndex)) {
29018:       // If aStartContent is in this map we must start iterating past it.
29018:       // We skip the case where aStartContent has tabindex == aStartContent
29018:       // since the next tab ordered element might be before it
29018:       // (or after for backwards) in the child list.
29018:       index = aForward ? -1 : (PRInt32)count;
29018:     }
29018: 
29018:     // GetChildAt will return nsnull if our index < 0 or index >= count
29018:     nsCOMPtr<nsIContent> areaContent;
29018:     while ((areaContent = mapContent->GetChildAt(aForward ? ++index : --index)) != nsnull) {
29018:       if (areaContent->IsFocusable(&tabIndex) && tabIndex == aCurrentTabIndex) {
29018:         return areaContent;
29018:       }
29018:     }
29018:   }
29018: 
29018:   return nsnull;
29018: }
29018: 
29018: PRInt32
29018: nsFocusManager::GetNextTabIndex(nsIContent* aParent,
29018:                                 PRInt32 aCurrentTabIndex,
29018:                                 PRBool aForward)
29018: {
29018:   PRInt32 tabIndex, childTabIndex;
29018:   nsIContent *child;
29018: 
29018:   PRUint32 count = aParent->GetChildCount();
29018: 
29018:   if (aForward) {
29018:     tabIndex = 0;
29018:     for (PRUint32 index = 0; index < count; index++) {
29018:       child = aParent->GetChildAt(index);
29018:       childTabIndex = GetNextTabIndex(child, aCurrentTabIndex, aForward);
29018:       if (childTabIndex > aCurrentTabIndex && childTabIndex != tabIndex) {
29018:         tabIndex = (tabIndex == 0 || childTabIndex < tabIndex) ? childTabIndex : tabIndex;
29018:       }
29018: 
29018:       nsAutoString tabIndexStr;
29018:       child->GetAttr(kNameSpaceID_None, nsGkAtoms::tabindex, tabIndexStr);
29018:       PRInt32 ec, val = tabIndexStr.ToInteger(&ec);
29018:       if (NS_SUCCEEDED (ec) && val > aCurrentTabIndex && val != tabIndex) {
29018:         tabIndex = (tabIndex == 0 || val < tabIndex) ? val : tabIndex;
29018:       }
29018:     }
29018:   }
29018:   else { /* !aForward */
29018:     tabIndex = 1;
29018:     for (PRUint32 index = 0; index < count; index++) {
29018:       child = aParent->GetChildAt(index);
29018:       childTabIndex = GetNextTabIndex(child, aCurrentTabIndex, aForward);
29018:       if ((aCurrentTabIndex == 0 && childTabIndex > tabIndex) ||
29018:           (childTabIndex < aCurrentTabIndex && childTabIndex > tabIndex)) {
29018:         tabIndex = childTabIndex;
29018:       }
29018: 
29018:       nsAutoString tabIndexStr;
29018:       child->GetAttr(kNameSpaceID_None, nsGkAtoms::tabindex, tabIndexStr);
29018:       PRInt32 ec, val = tabIndexStr.ToInteger(&ec);
29018:       if (NS_SUCCEEDED (ec)) {
29018:         if ((aCurrentTabIndex == 0 && val > tabIndex) ||
29018:             (val < aCurrentTabIndex && val > tabIndex) ) {
29018:           tabIndex = val;
29018:         }
29018:       }
29018:     }
29018:   }
29018: 
29018:   return tabIndex;
29018: }
29018: 
29018: nsIContent*
29018: nsFocusManager::GetRootForFocus(nsPIDOMWindow* aWindow,
29018:                                 nsIDocument* aDocument,
29018:                                 PRBool aIsForDocNavigation,
29018:                                 PRBool aCheckVisibility)
29018: {
29018:   // the root element's canvas may be focused as long as the document is in a
29018:   // a non-chrome shell and does not contain a frameset.
29018:   if (aIsForDocNavigation) {
29018:     nsCOMPtr<nsIContent> docContent =
29018:       do_QueryInterface(aWindow->GetFrameElementInternal());
60230:     // document navigation skips iframes and frames that are specifically non-focusable
60230:     if (docContent) {
60230:       if (docContent->Tag() == nsGkAtoms::iframe)
29018:         return nsnull;
60230: 
60230:       nsIFrame* frame = docContent->GetPrimaryFrame();
60230:       if (!frame || !frame->IsFocusable(nsnull, 0))
60230:         return nsnull;
60230:     }
29018:   }
29018:   else  {
29018:     PRInt32 itemType;
29018:     nsCOMPtr<nsIDocShellTreeItem> shellItem = do_QueryInterface(aWindow->GetDocShell());
29018:     shellItem->GetItemType(&itemType);
29018: 
29018:     if (itemType == nsIDocShellTreeItem::typeChrome)
29018:       return nsnull;
29018:   }
29018: 
29018:   if (aCheckVisibility && !IsWindowVisible(aWindow))
29018:     return nsnull;
29018: 
41634:   Element *rootElement = aDocument->GetRootElement();
41634:   if (rootElement) {
41634:     if (aCheckVisibility && !rootElement->GetPrimaryFrame()) {
29018:       return nsnull;
29018:     }
29018: 
29018:     // Finally, check if this is a frameset
29018:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(aDocument);
29018:     if (htmlDoc) {
41634:       PRUint32 childCount = rootElement->GetChildCount();
29018:       for (PRUint32 i = 0; i < childCount; ++i) {
41634:         nsIContent *childContent = rootElement->GetChildAt(i);
29018:         nsINodeInfo *ni = childContent->NodeInfo();
33329:         if (childContent->IsHTML() &&
29018:             ni->Equals(nsGkAtoms::frameset))
29018:           return nsnull;
29018:       }
29018:     }
29018:   }
29018: 
41634:   return rootElement;
29018: }
29018: 
29018: void
29018: nsFocusManager::GetLastDocShell(nsIDocShellTreeItem* aItem,
29018:                                 nsIDocShellTreeItem** aResult)
29018: {
29018:   *aResult = nsnull;
29018: 
29018:   nsCOMPtr<nsIDocShellTreeItem> curItem = aItem;
29018:   while (curItem) {
29018:     PRInt32 childCount = 0;
29018:     curItem->GetChildCount(&childCount);
29018:     if (!childCount) {
29018:       *aResult = curItem;
29018:       NS_ADDREF(*aResult);
29018:       return;
29018:     }
29018: 
29018:     
29018:     curItem->GetChildAt(childCount - 1, getter_AddRefs(curItem));
29018:   }
29018: }
29018: 
29018: void
29018: nsFocusManager::GetNextDocShell(nsIDocShellTreeItem* aItem,
29018:                                 nsIDocShellTreeItem** aResult)
29018: {
29018:   *aResult = nsnull;
29018: 
29018:   PRInt32 childCount = 0;
29018:   aItem->GetChildCount(&childCount);
29018:   if (childCount) {
29018:     aItem->GetChildAt(0, aResult);
29018:     if (*aResult)
29018:       return;
29018:   }
29018: 
29018:   nsCOMPtr<nsIDocShellTreeItem> curItem = aItem;
29018:   while (curItem) {
29018:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
29018:     curItem->GetParent(getter_AddRefs(parentItem));
29018:     if (!parentItem)
29018:       return;
29018: 
29018:     // Note that we avoid using GetChildOffset() here because docshell
29018:     // child offsets can't be trusted to be correct. bug 162283.
29018:     nsCOMPtr<nsIDocShellTreeItem> iterItem;
29018:     childCount = 0;
29018:     parentItem->GetChildCount(&childCount);
29018:     for (PRInt32 index = 0; index < childCount; ++index) {
29018:       parentItem->GetChildAt(index, getter_AddRefs(iterItem));
29018:       if (iterItem == curItem) {
29018:         ++index;
29018:         if (index < childCount) {
29018:           parentItem->GetChildAt(index, aResult);
29018:           if (*aResult)
29018:             return;
29018:         }
29018:         break;
29018:       }
29018:     }
29018: 
29018:     curItem = parentItem;
29018:   }
29018: }
29018: 
29018: void
29018: nsFocusManager::GetPreviousDocShell(nsIDocShellTreeItem* aItem,
29018:                                     nsIDocShellTreeItem** aResult)
29018: {
29018:   *aResult = nsnull;
29018: 
29018:   nsCOMPtr<nsIDocShellTreeItem> parentItem;
29018:   aItem->GetParent(getter_AddRefs(parentItem));
29018:   if (!parentItem)
29018:     return;
29018: 
29018:   // Note that we avoid using GetChildOffset() here because docshell
29018:   // child offsets can't be trusted to be correct. bug 162283.
29018:   PRInt32 childCount = 0;
29018:   parentItem->GetChildCount(&childCount);
29018:   nsCOMPtr<nsIDocShellTreeItem> prevItem, iterItem;
29018:   for (PRInt32 index = 0; index < childCount; ++index) {
29018:     parentItem->GetChildAt(index, getter_AddRefs(iterItem));
29018:     if (iterItem == aItem)
29018:       break;
29018:     prevItem = iterItem;
29018:   }
29018: 
29018:   if (prevItem)
29018:     GetLastDocShell(prevItem, aResult);
29018:   else
29018:     NS_ADDREF(*aResult = parentItem);
29018: }
29018: 
29018: nsIContent*
29018: nsFocusManager::GetNextTabbableDocument(PRBool aForward)
29018: {
29018:   nsCOMPtr<nsIDocShellTreeItem> startItem;
29018:   if (mFocusedWindow) {
29018:     startItem = do_QueryInterface(mFocusedWindow->GetDocShell());
29018:   }
29018:   else {
29018:     nsCOMPtr<nsIWebNavigation> webnav = do_GetInterface(mActiveWindow);
29018:     startItem = do_QueryInterface(webnav);
29018:   }
29018:   if (!startItem)
29018:     return nsnull;
29018: 
29018:   // perform a depth first search (preorder) of the docshell tree
29018:   // looking for an HTML Frame or a chrome document
29018:   nsIContent* content = nsnull;
29018:   nsCOMPtr<nsIDocShellTreeItem> curItem = startItem;
29018:   nsCOMPtr<nsIDocShellTreeItem> nextItem;
29018:   do {
29018:     if (aForward) {
29018:       GetNextDocShell(curItem, getter_AddRefs(nextItem));
29018:       if (!nextItem) {
29018:         // wrap around to the beginning, which is the top of the tree
29018:         startItem->GetRootTreeItem(getter_AddRefs(nextItem));
29018:       }
29018:     }
29018:     else {
29018:       GetPreviousDocShell(curItem, getter_AddRefs(nextItem));
29018:       if (!nextItem) {
29018:         // wrap around to the end, which is the last item in the tree
29018:         nsCOMPtr<nsIDocShellTreeItem> rootItem;
29018:         startItem->GetRootTreeItem(getter_AddRefs(rootItem));
29018:         GetLastDocShell(rootItem, getter_AddRefs(nextItem));
29018:       }
29018:     }
29018: 
29018:     curItem = nextItem;
29018:     nsCOMPtr<nsPIDOMWindow> nextFrame = do_GetInterface(nextItem);
29018:     if (!nextFrame)
29018:       return nsnull;
29018: 
29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(nextFrame->GetExtantDocument());
29018:     if (doc && !doc->EventHandlingSuppressed()) {
29018:       content = GetRootForFocus(nextFrame, doc, PR_TRUE, PR_TRUE);
29018:       if (content && !GetRootForFocus(nextFrame, doc, PR_FALSE, PR_FALSE)) {
29018:         // if the found content is in a chrome shell or a frameset, navigate
29018:         // forward one tabbable item so that the first item is focused. Note
29018:         // that we always go forward and not back here.
29018:         nsCOMPtr<nsIContent> nextFocus;
41634:         Element* rootElement = doc->GetRootElement();
46225:         nsIPresShell* presShell = doc->GetShell();
29018:         if (presShell) {
41634:           nsresult rv = GetNextTabbableContent(presShell, rootElement,
41634:                                                nsnull, rootElement,
29018:                                                PR_TRUE, 1, PR_FALSE,
29018:                                                getter_AddRefs(nextFocus));
29018:           return NS_SUCCEEDED(rv) ? nextFocus.get() : nsnull;
29018:         }
29018:       }
29018:     }
29018:   } while (!content);
29018: 
29018:   return content;
29018: }
29018: 
29018: void
29018: nsFocusManager::GetFocusInSelection(nsPIDOMWindow* aWindow,
29018:                                     nsIContent* aStartSelection,
29018:                                     nsIContent* aEndSelection,
29018:                                     nsIContent** aFocusedContent)
29018: {
29018:   *aFocusedContent = nsnull;
29018: 
29018:   nsCOMPtr<nsIContent> testContent = aStartSelection;
29018:   nsCOMPtr<nsIContent> nextTestContent = aEndSelection;
29018: 
29018:   nsCOMPtr<nsIContent> currentFocus = aWindow->GetFocusedNode();
29018: 
29018:   // We now have the correct start node in selectionContent!
29018:   // Search for focusable elements, starting with selectionContent
29018: 
29018:   // Method #1: Keep going up while we look - an ancestor might be focusable
29018:   // We could end the loop earlier, such as when we're no longer
36657:   // in the same frame, by comparing selectionContent->GetPrimaryFrame()
29018:   // with a variable holding the starting selectionContent
29018:   while (testContent) {
29018:     // Keep testing while selectionContent is equal to something,
29018:     // eventually we'll run out of ancestors
29018: 
29018:     nsCOMPtr<nsIURI> uri;
29018:     if (testContent == currentFocus ||
29018:         testContent->IsLink(getter_AddRefs(uri))) {
29018:       NS_ADDREF(*aFocusedContent = testContent);
29018:       return;
29018:     }
29018: 
29018:     // Get the parent
29018:     testContent = testContent->GetParent();
29018: 
29018:     if (!testContent) {
29018:       // We run this loop again, checking the ancestor chain of the selection's end point
29018:       testContent = nextTestContent;
29018:       nextTestContent = nsnull;
29018:     }
29018:   }
29018: 
29018:   // We couldn't find an anchor that was an ancestor of the selection start
29018:   // Method #2: look for anchor in selection's primary range (depth first search)
29018: 
29018:   // Turn into nodes so that we can use GetNextSibling() and GetFirstChild()
29018:   nsCOMPtr<nsIDOMNode> selectionNode(do_QueryInterface(aStartSelection));
29018:   nsCOMPtr<nsIDOMNode> endSelectionNode(do_QueryInterface(aEndSelection));
29018:   nsCOMPtr<nsIDOMNode> testNode;
29018: 
29018:   do {
29018:     testContent = do_QueryInterface(selectionNode);
29018: 
29018:     // We're looking for any focusable link that could be part of the
29018:     // main document's selection.
29018:     nsCOMPtr<nsIURI> uri;
29018:     if (testContent == currentFocus ||
29018:         testContent->IsLink(getter_AddRefs(uri))) {
29018:       NS_ADDREF(*aFocusedContent = testContent);
29018:       return;
29018:     }
29018: 
29018:     selectionNode->GetFirstChild(getter_AddRefs(testNode));
29018:     if (testNode) {
29018:       selectionNode = testNode;
29018:       continue;
29018:     }
29018: 
29018:     if (selectionNode == endSelectionNode)
29018:       break;
29018:     selectionNode->GetNextSibling(getter_AddRefs(testNode));
29018:     if (testNode) {
29018:       selectionNode = testNode;
29018:       continue;
29018:     }
29018: 
29018:     do {
29018:       selectionNode->GetParentNode(getter_AddRefs(testNode));
29018:       if (!testNode || testNode == endSelectionNode) {
29018:         selectionNode = nsnull;
29018:         break;
29018:       }
29018:       testNode->GetNextSibling(getter_AddRefs(selectionNode));
29018:       if (selectionNode)
29018:         break;
29018:       selectionNode = testNode;
29018:     } while (PR_TRUE);
29018:   }
29018:   while (selectionNode && selectionNode != endSelectionNode);
29018: }
29018: 
29018: nsresult
29018: NS_NewFocusManager(nsIFocusManager** aResult)
29018: {
29018:   NS_IF_ADDREF(*aResult = nsFocusManager::GetFocusManager());
29018:   return NS_OK;
29018: }
