     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 94037: // Main header first:
     1: #include "nsSVGContainerFrame.h"
 94037: 
 94037: // Keep others in (case-insensitive) order:
 98711: #include "nsSVGEffects.h"
 93425: #include "nsSVGElement.h"
     1: #include "nsSVGUtils.h"
 98711: #include "SVGAnimatedTransformList.h"
 98711: 
 98711: using namespace mozilla;
     1: 
 27899: NS_QUERYFRAME_HEAD(nsSVGContainerFrame)
 27899:   NS_QUERYFRAME_ENTRY(nsSVGContainerFrame)
 27899: NS_QUERYFRAME_TAIL_INHERITING(nsSVGContainerFrameBase)
 27899: 
 23554: NS_QUERYFRAME_HEAD(nsSVGDisplayContainerFrame)
 27845:   NS_QUERYFRAME_ENTRY(nsSVGDisplayContainerFrame)
 23554:   NS_QUERYFRAME_ENTRY(nsISVGChildFrame)
 23554: NS_QUERYFRAME_TAIL_INHERITING(nsSVGContainerFrame)
     1: 
     1: nsIFrame*
     1: NS_NewSVGContainerFrame(nsIPresShell* aPresShell,
     1:                         nsStyleContext* aContext)
     1: {
 92000:   nsIFrame *frame = new (aPresShell) nsSVGContainerFrame(aContext);
 92000:   // If we were called directly, then the frame is for a <defs> or
 92000:   // an unknown element type. In both cases we prevent the content
 92000:   // from displaying directly.
 92000:   frame->AddStateBits(NS_STATE_SVG_NONDISPLAY_CHILD);
 92000:   return frame;
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsSVGContainerFrame)
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsSVGDisplayContainerFrame)
 32423: 
     1: NS_IMETHODIMP
 77154: nsSVGContainerFrame::AppendFrames(ChildListID  aListID,
 30941:                                   nsFrameList& aFrameList)
     1: {
 77154:   return InsertFrames(aListID, mFrames.LastChild(), aFrameList);  
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsSVGContainerFrame::InsertFrames(ChildListID aListID,
     1:                                   nsIFrame* aPrevFrame,
 30941:                                   nsFrameList& aFrameList)
     1: {
 77154:   NS_ASSERTION(aListID == kPrincipalList, "unexpected child list");
     1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
     1:                "inserting after sibling frame with different parent");
     1: 
     1:   mFrames.InsertFrames(this, aPrevFrame, aFrameList);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsSVGContainerFrame::RemoveFrame(ChildListID aListID,
     1:                                  nsIFrame* aOldFrame)
     1: {
 77154:   NS_ASSERTION(aListID == kPrincipalList, "unexpected child list");
     1: 
 32844:   mFrames.DestroyFrame(aOldFrame);
 32844:   return NS_OK;
     1: }
     1: 
 98711: bool
 98711: nsSVGContainerFrame::UpdateOverflow()
 98711: {
 98711:   if (mState & NS_STATE_SVG_NONDISPLAY_CHILD) {
 98711:     // We don't maintain overflow rects.
 98711:     // XXX It would have be better if the restyle request hadn't even happened.
 98711:     return false;
 98711:   }
 98711:   return nsSVGContainerFrameBase::UpdateOverflow();
 98711: }
 98711: 
     1: NS_IMETHODIMP
  5468: nsSVGDisplayContainerFrame::Init(nsIContent* aContent,
  5468:                                  nsIFrame* aParent,
  5468:                                  nsIFrame* aPrevInFlow)
     1: {
 15471:   if (!(GetStateBits() & NS_STATE_IS_OUTER_SVG)) {
 58894:     AddStateBits(aParent->GetStateBits() &
 93573:       (NS_STATE_SVG_NONDISPLAY_CHILD | NS_STATE_SVG_CLIPPATH_CHILD));
 15471:   }
 92000:   nsresult rv = nsSVGContainerFrame::Init(aContent, aParent, aPrevInFlow);
  5468:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
105956: nsSVGDisplayContainerFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
105956:                                              const nsRect&           aDirtyRect,
105956:                                              const nsDisplayListSet& aLists)
105956: {
118197:   if (mContent->IsSVG() &&
118197:       !static_cast<const nsSVGElement*>(mContent)->HasValidDimensions()) {
105956:     return NS_OK;
105956:   }
105956:   return BuildDisplayListForNonBlockChildren(aBuilder, aDirtyRect, aLists);
105956: }
105956: 
105956: NS_IMETHODIMP
 77154: nsSVGDisplayContainerFrame::InsertFrames(ChildListID aListID,
     1:                                          nsIFrame* aPrevFrame,
 30941:                                          nsFrameList& aFrameList)
     1: {
 30941:   // memorize first old frame after insertion point
 30941:   // XXXbz once again, this would work a lot better if the nsIFrame
 30941:   // methods returned framelist iterators....
 30941:   nsIFrame* firstOldFrame = aPrevFrame ?
 77154:     aPrevFrame->GetNextSibling() : GetChildList(aListID).FirstChild();
 30941:   nsIFrame* firstNewFrame = aFrameList.FirstChild();
     1:   
     1:   // Insert the new frames
 77154:   nsSVGContainerFrame::InsertFrames(aListID, aPrevFrame, aFrameList);
     1: 
 93574:   // If we are not a non-display SVG frame and we do not have a bounds update
 93574:   // pending, then we need to schedule one for our new children:
 93574:   if (!(GetStateBits() &
 93574:         (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN |
 93574:          NS_STATE_SVG_NONDISPLAY_CHILD))) {
 30941:     for (nsIFrame* kid = firstNewFrame; kid != firstOldFrame;
     1:          kid = kid->GetNextSibling()) {
 23554:       nsISVGChildFrame* SVGFrame = do_QueryFrame(kid);
     1:       if (SVGFrame) {
 93574:         NS_ABORT_IF_FALSE(!(kid->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD),
 93574:                           "Check for this explicitly in the |if|, then");
104687:         bool isFirstReflow = (kid->GetStateBits() & NS_FRAME_FIRST_REFLOW);
 93574:         // Remove bits so that ScheduleBoundsUpdate will work:
 93574:         kid->RemoveStateBits(NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY |
 93574:                              NS_FRAME_HAS_DIRTY_CHILDREN);
 93574:         // No need to invalidate the new kid's old bounds, so we just use
 93574:         // nsSVGUtils::ScheduleBoundsUpdate.
106052:         nsSVGUtils::ScheduleReflowSVG(kid);
104687:         if (isFirstReflow) {
104687:           // Add back the NS_FRAME_FIRST_REFLOW bit:
104687:           kid->AddStateBits(NS_FRAME_FIRST_REFLOW);
104687:         }
     1:       }
     1:     }
  7035:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 77154: nsSVGDisplayContainerFrame::RemoveFrame(ChildListID aListID,
     1:                                         nsIFrame* aOldFrame)
     1: {
 93574:   nsSVGUtils::InvalidateBounds(aOldFrame);
     1: 
 77154:   nsresult rv = nsSVGContainerFrame::RemoveFrame(aListID, aOldFrame);
     1: 
 89454:   if (!(GetStateBits() & (NS_STATE_SVG_NONDISPLAY_CHILD | NS_STATE_IS_OUTER_SVG))) {
 13316:     nsSVGUtils::NotifyAncestorsOfFilterRegionChange(this);
 13316:   }
     1: 
     1:   return rv;
     1: }
     1: 
 98711: bool
 98711: nsSVGDisplayContainerFrame::IsSVGTransformed(gfxMatrix *aOwnTransform,
 98711:                                              gfxMatrix *aFromParentTransform) const
 98711: {
 98711:   bool foundTransform = false;
 98711: 
 98711:   // Check if our parent has children-only transforms:
 98711:   nsIFrame *parent = GetParent();
 98711:   if (parent &&
 98711:       parent->IsFrameOfType(nsIFrame::eSVG | nsIFrame::eSVGContainer)) {
 98711:     foundTransform = static_cast<nsSVGContainerFrame*>(parent)->
 98711:                        HasChildrenOnlyTransform(aFromParentTransform);
 98711:   }
 98711: 
118197:   if (mContent->IsSVG()) {
 98711:     nsSVGElement *content = static_cast<nsSVGElement*>(mContent);
105956:     if (content->GetAnimatedTransformList() ||
104018:         content->GetAnimateMotionTransform()) {
 98711:       if (aOwnTransform) {
 98711:         *aOwnTransform = content->PrependLocalTransformsTo(gfxMatrix(),
 98711:                                     nsSVGElement::eUserSpaceToParent);
 98711:       }
 98711:       foundTransform = true;
 98711:     }
118197:   }
 98711:   return foundTransform;
 98711: }
 98711: 
     1: //----------------------------------------------------------------------
     1: // nsISVGChildFrame methods
     1: 
     1: NS_IMETHODIMP
 91412: nsSVGDisplayContainerFrame::PaintSVG(nsRenderingContext* aContext,
 20652:                                      const nsIntRect *aDirtyRect)
     1: {
105956:   NS_ASSERTION(!NS_SVGDisplayListPaintingEnabled() ||
105956:                (mState & NS_STATE_SVG_NONDISPLAY_CHILD),
105956:                "If display lists are enabled, only painting of non-display "
105956:                "SVG should take this code path");
105956: 
     1:   const nsStyleDisplay *display = mStyleContext->GetStyleDisplay();
     1:   if (display->mOpacity == 0.0)
     1:     return NS_OK;
     1: 
     1:   for (nsIFrame* kid = mFrames.FirstChild(); kid;
     1:        kid = kid->GetNextSibling()) {
 20652:     nsSVGUtils::PaintFrameWithEffects(aContext, aDirtyRect, kid);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 18367: NS_IMETHODIMP_(nsIFrame*)
 18367: nsSVGDisplayContainerFrame::GetFrameForPoint(const nsPoint &aPoint)
     1: {
105956:   NS_ASSERTION(!NS_SVGDisplayListHitTestingEnabled() ||
105956:                (mState & NS_STATE_SVG_NONDISPLAY_CHILD),
105956:                "If display lists are enabled, only hit-testing of a "
105956:                "clipPath's contents should take this code path");
 18367:   return nsSVGUtils::HitTestChildren(this, aPoint);
     1: }
     1: 
     1: NS_IMETHODIMP_(nsRect)
     1: nsSVGDisplayContainerFrame::GetCoveredRegion()
     1: {
     1:   return nsSVGUtils::GetCoveredRegion(mFrames);
     1: }
     1: 
 93574: void
106052: nsSVGDisplayContainerFrame::ReflowSVG()
     1: {
106052:   NS_ASSERTION(nsSVGUtils::OuterSVGIsCallingReflowSVG(this),
106052:                "This call is probably a wasteful mistake");
 93574: 
 93574:   NS_ABORT_IF_FALSE(!(GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD),
106052:                     "ReflowSVG mechanism not designed for this");
 93574: 
 98711:   NS_ABORT_IF_FALSE(GetType() != nsGkAtoms::svgOuterSVGFrame,
 98711:                     "Do not call on outer-<svg>");
 98711: 
106052:   if (!nsSVGUtils::NeedsReflowSVG(this)) {
 93574:     return;
     1:   }
  7035: 
 93573:   // If the NS_FRAME_FIRST_REFLOW bit has been removed from our parent frame,
 93573:   // then our outer-<svg> has previously had its initial reflow. In that case
 93573:   // we need to make sure that that bit has been removed from ourself _before_
 93573:   // recursing over our children to ensure that they know too. Otherwise, we
 93573:   // need to remove it _after_ recursing over our children so that they know
 93573:   // the initial reflow is currently underway.
 93573: 
 93573:   bool outerSVGHasHadFirstReflow =
 93573:     (GetParent()->GetStateBits() & NS_FRAME_FIRST_REFLOW) == 0;
 93573: 
 93573:   if (outerSVGHasHadFirstReflow) {
 93573:     mState &= ~NS_FRAME_FIRST_REFLOW; // tell our children
 93573:   }
 93573: 
 98711:   nsOverflowAreas overflowRects;
 98711: 
     1:   for (nsIFrame* kid = mFrames.FirstChild(); kid;
     1:        kid = kid->GetNextSibling()) {
 23554:     nsISVGChildFrame* SVGFrame = do_QueryFrame(kid);
     1:     if (SVGFrame) {
 93574:       NS_ABORT_IF_FALSE(!(kid->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD),
 93574:                         "Check for this explicitly in the |if|, then");
106052:       SVGFrame->ReflowSVG();
 98711: 
 98711:       // We build up our child frame overflows here instead of using
 98711:       // nsLayoutUtils::UnionChildOverflow since SVG frame's all use the same
 98711:       // frame list, and we're iterating over that list now anyway.
 98711:       ConsiderChildOverflow(overflowRects, kid);
     1:     }
     1:   }
     1: 
 98711:   // <svg> can create an SVG viewport with an offset due to its
 98711:   // x/y/width/height attributes, and <use> can introduce an offset with an
 98711:   // empty mRect (any width/height is copied to an anonymous <svg> child).
 98711:   // Other than that containers should not set mRect since all other offsets
 98711:   // come from transforms, which are accounted for by nsDisplayTransform.
 98711:   // Note that we rely on |overflow:visible| to allow display list items to be
 98711:   // created for our children.
 98711:   NS_ABORT_IF_FALSE(mContent->Tag() == nsGkAtoms::svg ||
 98711:                     (mContent->Tag() == nsGkAtoms::use &&
 98711:                      mRect.Size() == nsSize(0,0)) ||
 98711:                     mRect.IsEqualEdges(nsRect()),
 98711:                     "Only inner-<svg>/<use> is expected to have mRect set");
 98711: 
 98711:   if (mState & NS_FRAME_FIRST_REFLOW) {
 98711:     // Make sure we have our filter property (if any) before calling
 98711:     // FinishAndStoreOverflow (subsequent filter changes are handled off
 98711:     // nsChangeHint_UpdateEffects):
 98711:     nsSVGEffects::UpdateEffects(this);
 98711:   }
 98711: 
103922:   // We only invalidate if we are dirty, if our outer-<svg> has already had its
103922:   // initial reflow (since if it hasn't, its entire area will be invalidated
103922:   // when it gets that initial reflow), and if our parent is not dirty (since
103922:   // if it is, then it will invalidate its entire new area, which will include
103922:   // our new area).
103922:   bool invalidate = (mState & NS_FRAME_IS_DIRTY) &&
103922:     !(GetParent()->GetStateBits() &
103922:        (NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY));
103922: 
 98711:   FinishAndStoreOverflow(overflowRects, mRect.Size());
 98711: 
 98711:   // Remove state bits after FinishAndStoreOverflow so that it doesn't
 98711:   // invalidate on first reflow:
     1:   mState &= ~(NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY |
     1:               NS_FRAME_HAS_DIRTY_CHILDREN);
     1: 
103922:   if (invalidate) {
102793:     // XXXSDL Let FinishAndStoreOverflow do this.
102793:     nsSVGUtils::InvalidateBounds(this, true);
102793:   }
     1: }  
     1: 
 10661: void
108991: nsSVGDisplayContainerFrame::NotifySVGChanged(uint32_t aFlags)
     1: {
 92020:   NS_ABORT_IF_FALSE(aFlags & (TRANSFORM_CHANGED | COORD_CONTEXT_CHANGED),
 10661:                     "Invalidation logic may need adjusting");
 10661: 
 10661:   nsSVGUtils::NotifyChildrenOfSVGChange(this, aFlags);
     1: }
     1: 
 95489: SVGBBox
 79556: nsSVGDisplayContainerFrame::GetBBoxContribution(
 79556:   const gfxMatrix &aToBBoxUserspace,
108991:   uint32_t aFlags)
     1: {
 95489:   SVGBBox bboxUnion;
 27899: 
 27899:   nsIFrame* kid = mFrames.FirstChild();
 27899:   while (kid) {
 27899:     nsISVGChildFrame* svgKid = do_QueryFrame(kid);
 27899:     if (svgKid) {
 27899:       gfxMatrix transform = aToBBoxUserspace;
 29311:       nsIContent *content = kid->GetContent();
 93228:       if (content->IsSVG()) {
 29311:         transform = static_cast<nsSVGElement*>(content)->
 90360:                       PrependLocalTransformsTo(aToBBoxUserspace);
 27899:       }
 87942:       // We need to include zero width/height vertical/horizontal lines, so we have
 95489:       // to use UnionEdges.
 95489:       bboxUnion.UnionEdges(svgKid->GetBBoxContribution(transform, aFlags));
 27899:     }
 27899:     kid = kid->GetNextSibling();
 27899:   }
 27899: 
 27899:   return bboxUnion;
     1: }
