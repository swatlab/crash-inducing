35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
36124:  *   Jim Mathies <jmathies@mozilla.com>
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #include "PluginInstanceParent.h"
35895: #include "BrowserStreamParent.h"
62706: #include "PluginBackgroundDestroyer.h"
35945: #include "PluginModuleParent.h"
35938: #include "PluginStreamParent.h"
35904: #include "StreamNotifyParent.h"
35945: #include "npfunctions.h"
35945: #include "nsAutoPtr.h"
41382: #include "mozilla/unused.h"
53942: #include "gfxASurface.h"
53942: #include "gfxContext.h"
53942: #include "gfxPlatform.h"
53942: #include "gfxSharedImageSurface.h"
53942: #ifdef MOZ_X11
53942: #include "gfxXlibSurface.h"
53942: #endif
53942: #include "gfxContext.h"
53942: #include "gfxColor.h"
53942: #include "gfxUtils.h"
61864: #include "nsNPAPIPluginInstance.h"
35945: 
36271: #if defined(OS_WIN)
36271: #include <windowsx.h>
61408: #include "mozilla/plugins/PluginSurfaceParent.h"
37550: 
37550: // Plugin focus event for widget.
37550: extern const PRUnichar* kOOPPPluginFocusEventId;
37550: UINT gOOPPPluginFocusEvent =
37550:     RegisterWindowMessage(kOOPPPluginFocusEventId);
42416: extern const PRUnichar* kFlashFullscreenClass;
39760: #elif defined(MOZ_WIDGET_GTK2)
39760: #include <gdk/gdk.h>
39883: #elif defined(XP_MACOSX)
39883: #include <ApplicationServices/ApplicationServices.h>
39883: #endif // defined(XP_MACOSX)
36271: 
35945: using namespace mozilla::plugins;
35945: 
60021: bool
60021: StreamNotifyParent::RecvRedirectNotifyResponse(const bool& allow)
60021: {
60021:   PluginInstanceParent* instance = static_cast<PluginInstanceParent*>(Manager());
60021:   instance->mNPNIface->urlredirectresponse(instance->mNPP, this, static_cast<NPBool>(allow));
60021:   return true;
60021: }
60021: 
35945: PluginInstanceParent::PluginInstanceParent(PluginModuleParent* parent,
35945:                                            NPP npp,
41029:                                            const nsCString& aMimeType,
35945:                                            const NPNetscapeFuncs* npniface)
37550:   : mParent(parent)
37550:     , mNPP(npp)
37550:     , mNPNIface(npniface)
37550:     , mWindowType(NPWindowTypeWindow)
37550: #if defined(OS_WIN)
37550:     , mPluginHWND(NULL)
37550:     , mPluginWndProc(NULL)
39795:     , mNestedEventState(false)
37550: #endif // defined(XP_WIN)
39883: #if defined(XP_MACOSX)
39883:     , mShWidth(0)
39883:     , mShHeight(0)
41029:     , mShColorSpace(nsnull)
41029:     , mDrawingModel(NPDrawingModelCoreGraphics)
39883: #endif
35945: {
35945: }
35945: 
35945: PluginInstanceParent::~PluginInstanceParent()
35945: {
36144:     if (mNPP)
36144:         mNPP->pdata = NULL;
37594: 
37594: #if defined(OS_WIN)
37594:     NS_ASSERTION(!(mPluginHWND || mPluginWndProc),
37594:         "Subclass was not reset correctly before the dtor was reached!");
37594: #endif
72514: #if defined(MOZ_WIDGET_COCOA)
42505:     if (mShWidth != 0 && mShHeight != 0) {
42505:         DeallocShmem(mShSurface);
42505:     }
41029:     if (mShColorSpace)
40120:         ::CGColorSpaceRelease(mShColorSpace);
40120: #endif
35945: }
35890: 
37311: bool
37311: PluginInstanceParent::Init()
37311: {
37311:     return !!mScriptableObjects.Init();
37311: }
37311: 
37311: namespace {
37311: 
37311: PLDHashOperator
37311: ActorCollect(const void* aKey,
37311:              PluginScriptableObjectParent* aData,
37311:              void* aUserData)
37311: {
37311:     nsTArray<PluginScriptableObjectParent*>* objects =
37311:         reinterpret_cast<nsTArray<PluginScriptableObjectParent*>*>(aUserData);
37311:     return objects->AppendElement(aData) ? PL_DHASH_NEXT : PL_DHASH_STOP;
37311: }
37311: 
37311: } // anonymous namespace
37311: 
37594: void
37594: PluginInstanceParent::ActorDestroy(ActorDestroyReason why)
37594: {
37594: #if defined(OS_WIN)
37594:     if (why == AbnormalShutdown) {
37594:         // If the plugin process crashes, this is the only
37594:         // chance we get to destroy resources.
37594:         SharedSurfaceRelease();
37594:         UnsubclassPluginWindow();
37594:     }
37594: #endif
57516:     // After this method, the data backing the remote surface may no
57516:     // longer be calid. The X surface may be destroyed, or the shared
57516:     // memory backing this surface may no longer be valid. The right
57516:     // way to inform the nsObjectFrame that the surface is no longer
57516:     // valid is with an invalidate call.
57516:     if (mFrontSurface) {
57516:         mFrontSurface = NULL;
57516:         const NPRect rect = {0, 0, 0, 0};
57516:         RecvNPN_InvalidateRect(rect);
57516: #ifdef MOZ_X11
57516:         XSync(DefaultXDisplay(), False);
57516: #endif
57516:     }
37594: }
37594: 
37311: NPError
37307: PluginInstanceParent::Destroy()
37302: {
37311:     NPError retval;
38645:     if (!CallNPP_Destroy(&retval))
38645:         retval = NPERR_GENERIC_ERROR;
36124: 
36124: #if defined(OS_WIN)
36124:     SharedSurfaceRelease();
37550:     UnsubclassPluginWindow();
36124: #endif
37311: 
37311:     return retval;
35965: }
35965: 
35898: PBrowserStreamParent*
35943: PluginInstanceParent::AllocPBrowserStream(const nsCString& url,
35893:                                           const uint32_t& length,
35890:                                           const uint32_t& lastmodified,
35990:                                           PStreamNotifyParent* notifyData,
35890:                                           const nsCString& headers,
35890:                                           const nsCString& mimeType,
35890:                                           const bool& seekable,
35893:                                           NPError* rv,
35893:                                           uint16_t *stype)
35890: {
35890:     NS_RUNTIMEABORT("Not reachable");
35890:     return NULL;
35890: }
35890: 
35926: bool
36138: PluginInstanceParent::DeallocPBrowserStream(PBrowserStreamParent* stream)
35890: {
35890:     delete stream;
35926:     return true;
35890: }
35740: 
35938: PPluginStreamParent*
35943: PluginInstanceParent::AllocPPluginStream(const nsCString& mimeType,
35938:                                          const nsCString& target,
35938:                                          NPError* result)
35938: {
35938:     return new PluginStreamParent(this, mimeType, target, result);
35938: }
35938: 
35938: bool
36138: PluginInstanceParent::DeallocPPluginStream(PPluginStreamParent* stream)
35938: {
35938:     delete stream;
35938:     return true;
35938: }
35938: 
35926: bool
35923: PluginInstanceParent::AnswerNPN_GetValue_NPNVjavascriptEnabledBool(
35923:                                                        bool* value,
35923:                                                        NPError* result)
35923: {
35923:     NPBool v;
35923:     *result = mNPNIface->getvalue(mNPP, NPNVjavascriptEnabledBool, &v);
35923:     *value = v;
35926:     return true;
35923: }
35923: 
35926: bool
35923: PluginInstanceParent::AnswerNPN_GetValue_NPNVisOfflineBool(bool* value,
35923:                                                            NPError* result)
35923: {
35923:     NPBool v;
35923:     *result = mNPNIface->getvalue(mNPP, NPNVisOfflineBool, &v);
35923:     *value = v;
35926:     return true;
35923: }
35923: 
35926: bool
37308: PluginInstanceParent::AnswerNPN_GetValue_NPNVnetscapeWindow(NativeWindowHandle* value,
37168:                                                             NPError* result)
37168: {
37168: #ifdef XP_WIN
37308:     HWND id;
37308: #elif defined(MOZ_X11)
37308:     XID id;
39534: #elif defined(XP_MACOSX)
39534:     intptr_t id;
46922: #elif defined(ANDROID)
46922: #warning Need Android impl
46922:     int id;
77137: #elif defined(MOZ_WIDGET_QT)
77137: #  warning Need Qt non X impl
77137:     int id;
37308: #else
39534: #warning Implement me
37308: #endif
37308: 
37308:     *result = mNPNIface->getvalue(mNPP, NPNVnetscapeWindow, &id);
37308:     *value = id;
37168:     return true;
37168: }
37168: 
37168: bool
35965: PluginInstanceParent::InternalGetValueForNPObject(
35965:                                          NPNVariable aVariable,
35965:                                          PPluginScriptableObjectParent** aValue,
35965:                                          NPError* aResult)
35923: {
35965:     NPObject* npobject;
35965:     NPError result = mNPNIface->getvalue(mNPP, aVariable, (void*)&npobject);
36078:     if (result == NPERR_NO_ERROR) {
36078:         NS_ASSERTION(npobject, "Shouldn't return null and NPERR_NO_ERROR!");
36078: 
36078:         PluginScriptableObjectParent* actor = GetActorForNPObject(npobject);
36078:         mNPNIface->releaseobject(npobject);
36078:         if (actor) {
36078:             *aValue = actor;
36078:             *aResult = NPERR_NO_ERROR;
35965:             return true;
35965:         }
35965: 
36078:         NS_ERROR("Failed to get actor!");
36078:         result = NPERR_GENERIC_ERROR;
35965:     }
35965: 
35965:     *aValue = nsnull;
36078:     *aResult = result;
35926:     return true;
35923: }
35923: 
35926: bool
35965: PluginInstanceParent::AnswerNPN_GetValue_NPNVWindowNPObject(
35965:                                          PPluginScriptableObjectParent** aValue,
35965:                                          NPError* aResult)
35965: {
35965:     return InternalGetValueForNPObject(NPNVWindowNPObject, aValue, aResult);
35965: }
35965: 
35965: bool
35923: PluginInstanceParent::AnswerNPN_GetValue_NPNVPluginElementNPObject(
35965:                                          PPluginScriptableObjectParent** aValue,
35965:                                          NPError* aResult)
35923: {
35965:     return InternalGetValueForNPObject(NPNVPluginElementNPObject, aValue,
35965:                                        aResult);
35923: }
35923: 
35926: bool
35923: PluginInstanceParent::AnswerNPN_GetValue_NPNVprivateModeBool(bool* value,
35923:                                                              NPError* result)
35923: {
35923:     NPBool v;
35923:     *result = mNPNIface->getvalue(mNPP, NPNVprivateModeBool, &v);
35923:     *value = v;
35926:     return true;
35923: }
35923: 
35951: bool
78254: PluginInstanceParent::AnswerNPN_GetValue_NPNVdocumentOrigin(nsCString* value,
78254:                                                             NPError* result)
78254: {
78254:     void *v = nsnull;
78254:     *result = mNPNIface->getvalue(mNPP, NPNVdocumentOrigin, &v);
78254:     if (*result == NPERR_NO_ERROR && v) {
78254:         value->Adopt(static_cast<char*>(v));
78254:     }
78254:     return true;
78254: }
78254: 
78254: bool
35951: PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginWindow(
35951:     const bool& windowed, NPError* result)
35951: {
35951:     NPBool isWindowed = windowed;
35951:     *result = mNPNIface->setvalue(mNPP, NPPVpluginWindowBool,
35951:                                   (void*)isWindowed);
35951:     return true;
35951: }
35951: 
35951: bool
35951: PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginTransparent(
35951:     const bool& transparent, NPError* result)
35951: {
35951:     NPBool isTransparent = transparent;
35951:     *result = mNPNIface->setvalue(mNPP, NPPVpluginTransparentBool,
35951:                                   (void*)isTransparent);
35951:     return true;
35951: }
35951: 
39883: bool
67677: PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginUsesDOMForCursor(
67677:     const bool& useDOMForCursor, NPError* result)
67677: {
67677:     *result = mNPNIface->setvalue(mNPP, NPPVpluginUsesDOMForCursorBool,
67677:                                   (void*)(NPBool)useDOMForCursor);
67677:     return true;
67677: }
67677: 
67677: bool
39883: PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginDrawingModel(
39883:     const int& drawingModel, NPError* result)
39883: {
39883: #ifdef XP_MACOSX
43370:     if (drawingModel == NPDrawingModelCoreAnimation ||
43370:         drawingModel == NPDrawingModelInvalidatingCoreAnimation) {
41029:         // We need to request CoreGraphics otherwise
41029:         // the nsObjectFrame will try to draw a CALayer
41029:         // that can not be shared across process.
43370:         mDrawingModel = drawingModel;
41029:         *result = mNPNIface->setvalue(mNPP, NPPVpluginDrawingModel,
41029:                                   (void*)NPDrawingModelCoreGraphics);
41029:     } else {
41029:         mDrawingModel = drawingModel;
39883:         *result = mNPNIface->setvalue(mNPP, NPPVpluginDrawingModel,
39883:                                   (void*)drawingModel);
41029:     }
39883:     return true;
39883: #else
39883:     *result = NPERR_GENERIC_ERROR;
39883:     return true;
39883: #endif
39883: }
39883: 
39883: bool
39883: PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginEventModel(
39883:     const int& eventModel, NPError* result)
39883: {
39883: #ifdef XP_MACOSX
39883:     *result = mNPNIface->setvalue(mNPP, NPPVpluginEventModel,
39883:                                   (void*)eventModel);
39883:     return true;
39883: #else
39883:     *result = NPERR_GENERIC_ERROR;
39883:     return true;
39883: #endif
39883: }
35951: 
35926: bool
35904: PluginInstanceParent::AnswerNPN_GetURL(const nsCString& url,
35904:                                        const nsCString& target,
35904:                                        NPError* result)
35904: {
35940:     *result = mNPNIface->geturl(mNPP,
35940:                                 NullableStringGet(url),
35940:                                 NullableStringGet(target));
35926:     return true;
35904: }
35904: 
35926: bool
35904: PluginInstanceParent::AnswerNPN_PostURL(const nsCString& url,
35904:                                         const nsCString& target,
35904:                                         const nsCString& buffer,
35904:                                         const bool& file,
35904:                                         NPError* result)
35904: {
35944:     *result = mNPNIface->posturl(mNPP, url.get(), NullableStringGet(target),
35904:                                  buffer.Length(), buffer.get(), file);
35926:     return true;
35904: }
35904: 
35904: PStreamNotifyParent*
35943: PluginInstanceParent::AllocPStreamNotify(const nsCString& url,
35904:                                          const nsCString& target,
35904:                                          const bool& post,
35904:                                          const nsCString& buffer,
35904:                                          const bool& file,
35904:                                          NPError* result)
35904: {
36110:     return new StreamNotifyParent();
36110: }
35904: 
36110: bool
36110: PluginInstanceParent::AnswerPStreamNotifyConstructor(PStreamNotifyParent* actor,
36110:                                                      const nsCString& url,
36110:                                                      const nsCString& target,
36110:                                                      const bool& post,
36110:                                                      const nsCString& buffer,
36110:                                                      const bool& file,
36110:                                                      NPError* result)
36110: {
37094:     bool streamDestroyed = false;
37094:     static_cast<StreamNotifyParent*>(actor)->
37094:         SetDestructionFlag(&streamDestroyed);
37094: 
35904:     if (!post) {
35940:         *result = mNPNIface->geturlnotify(mNPP,
35940:                                           NullableStringGet(url),
35940:                                           NullableStringGet(target),
36110:                                           actor);
35904:     }
35904:     else {
35940:         *result = mNPNIface->posturlnotify(mNPP,
35940:                                            NullableStringGet(url),
35940:                                            NullableStringGet(target),
36110:                                            buffer.Length(),
36110:                                            NullableStringGet(buffer),
36110:                                            file, actor);
35904:     }
36110: 
37094:     if (!streamDestroyed) {
37094:         static_cast<StreamNotifyParent*>(actor)->ClearDestructionFlag();
36110:         if (*result != NPERR_NO_ERROR)
41382:             return PStreamNotifyParent::Send__delete__(actor,
41382:                                                        NPERR_GENERIC_ERROR);
37094:     }
36110: 
36110:     return true;
35904: }
35904: 
35926: bool
36138: PluginInstanceParent::DeallocPStreamNotify(PStreamNotifyParent* notifyData)
35904: {
35904:     delete notifyData;
35926:     return true;
35904: }
35904: 
35958: bool
35958: PluginInstanceParent::RecvNPN_InvalidateRect(const NPRect& rect)
35958: {
35958:     mNPNIface->invalidaterect(mNPP, const_cast<NPRect*>(&rect));
35958:     return true;
35958: }
35958: 
53940: bool
53940: PluginInstanceParent::RecvShow(const NPRect& updatedRect,
53940:                                const SurfaceDescriptor& newSurface,
53940:                                SurfaceDescriptor* prevSurface)
53940: {
62706:     PLUGIN_LOG_DEBUG(
62706:         ("[InstanceParent][%p] RecvShow for <x=%d,y=%d, w=%d,h=%d>",
62706:          this, updatedRect.left, updatedRect.top,
62706:          updatedRect.right - updatedRect.left,
62706:          updatedRect.bottom - updatedRect.top));
62706: 
53942:     nsRefPtr<gfxASurface> surface;
53942:     if (newSurface.type() == SurfaceDescriptor::TShmem) {
53942:         if (!newSurface.get_Shmem().IsReadable()) {
53942:             NS_WARNING("back surface not readable");
53942:             return false;
53942:         }
59847:         surface = gfxSharedImageSurface::Open(newSurface.get_Shmem());
53942:     }
71284: #ifdef XP_MACOSX
71284:     else if (newSurface.type() == SurfaceDescriptor::TIOSurfaceDescriptor) {
71284:         IOSurfaceDescriptor iodesc = newSurface.get_IOSurfaceDescriptor();
71284:     
73761:         nsRefPtr<nsIOSurface> newIOSurface = nsIOSurface::LookupSurface(iodesc.surfaceId());
71284: 
71284:         if (!newIOSurface) {
71284:             NS_WARNING("Got bad IOSurfaceDescriptor in RecvShow");
71284:             return false;
71284:         }
71284:       
73761:         if (mFrontIOSurface)
73761:             *prevSurface = IOSurfaceDescriptor(mFrontIOSurface->GetIOSurfaceID());
73761:         else
73761:             *prevSurface = null_t();
73761: 
72865:         mFrontIOSurface = newIOSurface;
71284: 
71284:         RecvNPN_InvalidateRect(updatedRect);
71284: 
71284:         PLUGIN_LOG_DEBUG(("   (RecvShow invalidated for surface %p)",
71284:                           mFrontSurface.get()));
71284: 
71284:         return true;
71284:     }
71284: #endif
53942: #ifdef MOZ_X11
53942:     else if (newSurface.type() == SurfaceDescriptor::TSurfaceDescriptorX11) {
87046:         surface = newSurface.get_SurfaceDescriptorX11().OpenForeign();
53942:     }
53942: #endif
57209: #ifdef XP_WIN
61408:     else if (newSurface.type() == SurfaceDescriptor::TPPluginSurfaceParent) {
61408:         PluginSurfaceParent* s =
61408:             static_cast<PluginSurfaceParent*>(newSurface.get_PPluginSurfaceParent());
61408:         surface = s->Surface();
57209:     }
57209: #endif
53942: 
53942: #ifdef MOZ_X11
57207:     if (mFrontSurface &&
57207:         mFrontSurface->GetType() == gfxASurface::SurfaceTypeXlib)
62706:         // This is the "old front buffer" we're about to hand back to
62706:         // the plugin.  We might still have drawing operations
62706:         // referencing it, so we XSync here to let them finish before
62706:         // the plugin starts scribbling on it again, or worse,
62706:         // destroys it.
57207:         XSync(DefaultXDisplay(), False);
53942: #endif
57207: 
57206:     if (mFrontSurface && gfxSharedImageSurface::IsSharedImage(mFrontSurface))
53942:         *prevSurface = static_cast<gfxSharedImageSurface*>(mFrontSurface.get())->GetShmem();
57206:     else
53940:         *prevSurface = null_t();
57206: 
62861:     if (surface) {
62861:         // Notify the cairo backend that this surface has changed behind
62861:         // its back.
62861:         gfxRect ur(updatedRect.left, updatedRect.top,
62861:                    updatedRect.right - updatedRect.left,
62861:                    updatedRect.bottom - updatedRect.top);
62861:         surface->MarkDirty(ur);
62861:         surface->Flush();
62861:     }
62861: 
53942:     mFrontSurface = surface;
53942:     RecvNPN_InvalidateRect(updatedRect);
53942: 
62706:     PLUGIN_LOG_DEBUG(("   (RecvShow invalidated for surface %p)",
62706:                       mFrontSurface.get()));
62706: 
53942:     return true;
53940: }
53940: 
52409: nsresult
52409: PluginInstanceParent::AsyncSetWindow(NPWindow* aWindow)
52409: {
53942:     NPRemoteWindow window;
53942:     mWindowType = aWindow->type;
77904:     window.window = reinterpret_cast<uint64_t>(aWindow->window);
53942:     window.x = aWindow->x;
53942:     window.y = aWindow->y;
53942:     window.width = aWindow->width;
53942:     window.height = aWindow->height;
53942:     window.clipRect = aWindow->clipRect;
53942:     window.type = aWindow->type;
53942:     if (!SendAsyncSetWindow(gfxPlatform::GetPlatform()->ScreenReferenceSurface()->GetType(),
53942:                             window))
53942:         return NS_ERROR_FAILURE;
53942: 
53942:     return NS_OK;
52409: }
52409: 
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
77498: nsresult
77498: PluginInstanceParent::HandleGUIEvent(const nsGUIEvent& anEvent, bool* handled)
77498: {
77498:     switch (anEvent.eventStructType) {
77498:     case NS_KEY_EVENT:
77498:         if (!CallHandleKeyEvent(static_cast<const nsKeyEvent&>(anEvent),
77498:                                 handled)) {
77498:             return NS_ERROR_FAILURE;
77498:         }
77498:         break;
77498:     case NS_TEXT_EVENT:
77498:         if (!CallHandleTextEvent(static_cast<const nsTextEvent&>(anEvent),
77498:                                  handled)) {
77498:             return NS_ERROR_FAILURE;
77498:         }
77498:         break;
77498:     default:
77498:         NS_ERROR("Not implemented for this event type");
77498:         return NS_ERROR_FAILURE;
77498:     }
77498:     return NS_OK;
77498: }
77498: #endif
77498: 
52409: nsresult
62473: PluginInstanceParent::GetImage(ImageContainer* aContainer, Image** aImage)
62473: {
62474: #ifdef XP_MACOSX
72866:     nsIOSurface* ioSurface = NULL;
72866:   
72866:     if (mFrontIOSurface) {
72866:       ioSurface = mFrontIOSurface;
72866:     } else if (mIOSurface) {
72866:       ioSurface = mIOSurface;
72866:     }
72866: 
72866:     if (!mFrontSurface && !ioSurface)
62474: #else
62473:     if (!mFrontSurface)
62474: #endif
62473:         return NS_ERROR_NOT_AVAILABLE;
62473: 
62473:     Image::Format format = Image::CAIRO_SURFACE;
62474: #ifdef XP_MACOSX
72866:     if (ioSurface) {
62474:         format = Image::MAC_IO_SURFACE;
71260:         if (!aContainer->Manager()) {
71260:             return NS_ERROR_FAILURE;
71260:         }
71260:     }
62474: #endif
62473: 
62473:     nsRefPtr<Image> image;
62473:     image = aContainer->CreateImage(&format, 1);
62473:     if (!image) {
62473:         return NS_ERROR_FAILURE;
62473:     }
62473: 
62474: #ifdef XP_MACOSX
72866:     if (ioSurface) {
62474:         NS_ASSERTION(image->GetFormat() == Image::MAC_IO_SURFACE, "Wrong format?");
62474:         MacIOSurfaceImage* ioImage = static_cast<MacIOSurfaceImage*>(image.get());
62474:         MacIOSurfaceImage::Data ioData;
72866:         ioData.mIOSurface = ioSurface;
62474:         ioImage->SetData(ioData);
62474:         *aImage = image.forget().get();
62474:         return NS_OK;
62474:     }
62474: #endif
62474: 
62473:     NS_ASSERTION(image->GetFormat() == Image::CAIRO_SURFACE, "Wrong format?");
62473:     CairoImage* pluginImage = static_cast<CairoImage*>(image.get());
62473:     CairoImage::Data cairoData;
62473:     cairoData.mSurface = mFrontSurface;
62473:     cairoData.mSize = mFrontSurface->GetSize();
62473:     pluginImage->SetData(cairoData);
62473: 
62473:     *aImage = image.forget().get();
62473:     return NS_OK;
62473: }
62473: 
62981: nsresult
62981: PluginInstanceParent::GetImageSize(nsIntSize* aSize)
62981: {
62981:     if (mFrontSurface) {
62981:         gfxIntSize size = mFrontSurface->GetSize();
62981:         *aSize = nsIntSize(size.width, size.height);
62981:         return NS_OK;
62981:     }
62981: 
62981: #ifdef XP_MACOSX
72865:     if (mFrontIOSurface) {
72865:         *aSize = nsIntSize(mFrontIOSurface->GetWidth(), mFrontIOSurface->GetHeight());
62981:         return NS_OK;
72866:     } else if (mIOSurface) {
72866:         *aSize = nsIntSize(mIOSurface->GetWidth(), mIOSurface->GetHeight());
72866:         return NS_OK;
62981:     }
62981: #endif
62981: 
62981:     return NS_ERROR_NOT_AVAILABLE;
62981: }
62981: 
72866: #ifdef XP_MACOSX
72866: nsresult
79445: PluginInstanceParent::IsRemoteDrawingCoreAnimation(bool *aDrawing)
72866: {
72866:     *aDrawing = (NPDrawingModelCoreAnimation == (NPDrawingModel)mDrawingModel ||
72866:                  NPDrawingModelInvalidatingCoreAnimation == (NPDrawingModel)mDrawingModel);
72866:     return NS_OK;
72866: }
72866: #endif
72866: 
62706: nsresult
62706: PluginInstanceParent::SetBackgroundUnknown()
62706: {
62706:     PLUGIN_LOG_DEBUG(("[InstanceParent][%p] SetBackgroundUnknown", this));
62706: 
62706:     if (mBackground) {
62706:         DestroyBackground();
62706:         NS_ABORT_IF_FALSE(!mBackground, "Background not destroyed");
62706:     }
62706: 
62706:     return NS_OK;
62706: }
62706: 
62706: nsresult
62706: PluginInstanceParent::BeginUpdateBackground(const nsIntRect& aRect,
62706:                                             gfxContext** aCtx)
62706: {
62706:     PLUGIN_LOG_DEBUG(
62706:         ("[InstanceParent][%p] BeginUpdateBackground for <x=%d,y=%d, w=%d,h=%d>",
62706:          this, aRect.x, aRect.y, aRect.width, aRect.height));
62706: 
62706:     if (!mBackground) {
62706:         // XXX if we failed to create a background surface on one
62706:         // update, there's no guarantee that later updates will be for
62706:         // the entire background area until successful.  We might want
62706:         // to fix that eventually.
62706:         NS_ABORT_IF_FALSE(aRect.TopLeft() == nsIntPoint(0, 0),
62706:                           "Expecting rect for whole frame");
62706:         if (!CreateBackground(aRect.Size())) {
62706:             *aCtx = nsnull;
62706:             return NS_OK;
62706:         }
62706:     }
62706: 
62706: #ifdef DEBUG
62706:     gfxIntSize sz = mBackground->GetSize();
62706:     NS_ABORT_IF_FALSE(nsIntRect(0, 0, sz.width, sz.height).Contains(aRect),
62706:                       "Update outside of background area");
62706: #endif
62706: 
62706:     nsRefPtr<gfxContext> ctx = new gfxContext(mBackground);
62706:     *aCtx = ctx.forget().get();
62706: 
62706:     return NS_OK;
62706: }
62706: 
62706: nsresult
62706: PluginInstanceParent::EndUpdateBackground(gfxContext* aCtx,
62706:                                           const nsIntRect& aRect)
62706: {
62706:     PLUGIN_LOG_DEBUG(
62706:         ("[InstanceParent][%p] EndUpdateBackground for <x=%d,y=%d, w=%d,h=%d>",
62706:          this, aRect.x, aRect.y, aRect.width, aRect.height));
62706: 
62706: #ifdef MOZ_X11
62706:     // Have to XSync here to avoid the plugin trying to draw with this
62706:     // surface racing with its creation in the X server.  We also want
62706:     // to avoid the plugin drawing onto stale pixels, then handing us
62706:     // back a front surface from those pixels that we might
62706:     // recomposite for "a while" until the next update.  This XSync
62706:     // still doesn't guarantee that the plugin draws onto a consistent
62706:     // view of its background, but it does mean that the plugin is
62706:     // drawing onto pixels no older than those in the latest
62706:     // EndUpdateBackground().
62706:     XSync(DefaultXDisplay(), False);
62706: #endif
62706: 
62706:     unused << SendUpdateBackground(BackgroundDescriptor(), aRect);
62706: 
62706:     return NS_OK;
62706: }
62706: 
62706: bool
62706: PluginInstanceParent::CreateBackground(const nsIntSize& aSize)
62706: {
62706:     NS_ABORT_IF_FALSE(!mBackground, "Already have a background");
62706: 
62706:     // XXX refactor me
62706: 
62706: #if defined(MOZ_X11)
62706:     Screen* screen = DefaultScreenOfDisplay(DefaultXDisplay());
62706:     Visual* visual = DefaultVisualOfScreen(screen);
62706:     mBackground = gfxXlibSurface::Create(screen, visual,
62706:                                          gfxIntSize(aSize.width, aSize.height));
62706:     return !!mBackground;
62706: 
62706: #elif defined(XP_WIN)
62706:     // We have chosen to create an unsafe surface in which the plugin
62706:     // can read from the region while we're writing to it.
62706:     mBackground =
62706:         gfxSharedImageSurface::CreateUnsafe(
62706:             this,
62706:             gfxIntSize(aSize.width, aSize.height),
62706:             gfxASurface::ImageFormatRGB24);
62706:     return !!mBackground;
62706: #else
62706:     return nsnull;
62706: #endif
62706: }
62706: 
62706: void
62706: PluginInstanceParent::DestroyBackground()
62706: {
62706:     if (!mBackground) {
62706:         return;
62706:     }
62706: 
62706:     // Relinquish ownership of |mBackground| to its destroyer
62706:     PPluginBackgroundDestroyerParent* pbd =
62706:         new PluginBackgroundDestroyerParent(mBackground);
62706:     mBackground = nsnull;
62706: 
62706:     // If this fails, there's no problem: |bd| will be destroyed along
62706:     // with the old background surface.
62706:     unused << SendPPluginBackgroundDestroyerConstructor(pbd);
62706: }
62706: 
62706: SurfaceDescriptor
62706: PluginInstanceParent::BackgroundDescriptor()
62706: {
62706:     NS_ABORT_IF_FALSE(mBackground, "Need a background here");
62706: 
62706:     // XXX refactor me
62706: 
62706: #ifdef MOZ_X11
62706:     gfxXlibSurface* xsurf = static_cast<gfxXlibSurface*>(mBackground.get());
62706:     return SurfaceDescriptorX11(xsurf->XDrawable(), xsurf->XRenderFormat()->id,
62706:                                 xsurf->GetSize());
62706: #endif
62706: 
62706: #ifdef XP_WIN
62706:     NS_ABORT_IF_FALSE(gfxSharedImageSurface::IsSharedImage(mBackground),
62706:                       "Expected shared image surface");
62706:     gfxSharedImageSurface* shmem =
62706:         static_cast<gfxSharedImageSurface*>(mBackground.get());
62706:     return shmem->GetShmem();
62706: #endif
62706: 
62706:     // If this is ever used, which it shouldn't be, it will trigger a
62706:     // hard assertion in IPDL-generated code.
62706:     return SurfaceDescriptor();
62706: }
62706: 
62706: PPluginBackgroundDestroyerParent*
62706: PluginInstanceParent::AllocPPluginBackgroundDestroyer()
62706: {
62706:     NS_RUNTIMEABORT("'Power-user' ctor is used exclusively");
62706:     return nsnull;
62706: }
62706: 
62706: bool
62706: PluginInstanceParent::DeallocPPluginBackgroundDestroyer(
62706:     PPluginBackgroundDestroyerParent* aActor)
62706: {
62706:     delete aActor;
62706:     return true;
62706: }
62706: 
35740: NPError
35957: PluginInstanceParent::NPP_SetWindow(const NPWindow* aWindow)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aWindow=%p)", FULLFUNCTION, (void*) aWindow));
37099: 
35746:     NS_ENSURE_TRUE(aWindow, NPERR_GENERIC_ERROR);
35740: 
35957:     NPRemoteWindow window;
36124:     mWindowType = aWindow->type;
36124: 
36124: #if defined(OS_WIN)
36124:     // On windowless controls, reset the shared memory surface as needed.
36124:     if (mWindowType == NPWindowTypeDrawable) {
36124:         // SharedSurfaceSetWindow will take care of NPRemoteWindow.
36124:         if (!SharedSurfaceSetWindow(aWindow, window)) {
36124:           return NPERR_OUT_OF_MEMORY_ERROR;
36124:         }
36124:     }
36124:     else {
37550:         SubclassPluginWindow(reinterpret_cast<HWND>(aWindow->window));
37550: 
77904:         window.window = reinterpret_cast<uint64_t>(aWindow->window);
35957:         window.x = aWindow->x;
35957:         window.y = aWindow->y;
35957:         window.width = aWindow->width;
35957:         window.height = aWindow->height;
35957:         window.type = aWindow->type;
36124:     }
36124: #else
77904:     window.window = reinterpret_cast<uint64_t>(aWindow->window);
36124:     window.x = aWindow->x;
36124:     window.y = aWindow->y;
36124:     window.width = aWindow->width;
36124:     window.height = aWindow->height;
36124:     window.clipRect = aWindow->clipRect; // MacOS specific
36124:     window.type = aWindow->type;
36124: #endif
36124: 
39883: #if defined(XP_MACOSX)
41029:     if (mShWidth != window.width || mShHeight != window.height) {
43370:         if (mDrawingModel == NPDrawingModelCoreAnimation || 
43370:             mDrawingModel == NPDrawingModelInvalidatingCoreAnimation) {
41029:             mIOSurface = nsIOSurface::CreateIOSurface(window.width, window.height);
41029:         } else if (mShWidth * mShHeight != window.width * window.height) {
42505:             if (mShWidth != 0 && mShHeight != 0) {
42505:                 DeallocShmem(mShSurface);
42505:                 mShWidth = 0;
42505:                 mShHeight = 0;
42505:             }
42505: 
41029:             if (window.width != 0 && window.height != 0) {
41029:                 if (!AllocShmem(window.width * window.height*4, 
41029:                                 SharedMemory::TYPE_BASIC, &mShSurface)) {
39883:                     PLUGIN_LOG_DEBUG(("Shared memory could not be allocated."));
39883:                     return NPERR_GENERIC_ERROR;
39883:                 } 
41029:             }
41029:         }
39883:         mShWidth = window.width;
39883:         mShHeight = window.height;
39883:     }
39883: #endif
39883: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:     const NPSetWindowCallbackStruct* ws_info =
35957:       static_cast<NPSetWindowCallbackStruct*>(aWindow->ws_info);
35957:     window.visualID = ws_info->visual ? ws_info->visual->visualid : None;
35957:     window.colormap = ws_info->colormap;
35957: #endif
35957: 
39279:     if (!CallNPP_SetWindow(window))
35746:         return NPERR_GENERIC_ERROR;
39279: 
39279:     return NPERR_NO_ERROR;
35740: }
35740: 
35740: NPError
35945: PluginInstanceParent::NPP_GetValue(NPPVariable aVariable,
35945:                                    void* _retval)
35740: {
35945:     switch (aVariable) {
35945: 
71445:     case NPPVpluginWantsAllNetworkStreams: {
71445:         bool wantsAllStreams;
71445:         NPError rv;
71445: 
71445:         if (!CallNPP_GetValue_NPPVpluginWantsAllNetworkStreams(&wantsAllStreams, &rv)) {
71445:             return NPERR_GENERIC_ERROR;
71445:         }
71445: 
71445:         if (NPERR_NO_ERROR != rv) {
71445:             return rv;
71445:         }
71445: 
71445:         (*(NPBool*)_retval) = wantsAllStreams;
71445:         return NPERR_NO_ERROR;
71445:     }
71445: 
38126: #ifdef MOZ_X11
35951:     case NPPVpluginNeedsXEmbed: {
35951:         bool needsXEmbed;
35951:         NPError rv;
35951: 
35951:         if (!CallNPP_GetValue_NPPVpluginNeedsXEmbed(&needsXEmbed, &rv)) {
35951:             return NPERR_GENERIC_ERROR;
35951:         }
35951: 
35951:         if (NPERR_NO_ERROR != rv) {
35951:             return rv;
35951:         }
35951: 
35951:         (*(NPBool*)_retval) = needsXEmbed;
35740:         return NPERR_NO_ERROR;
35951:     }
35746: #endif
35925: 
35934:     case NPPVpluginScriptableNPObject: {
35925:         PPluginScriptableObjectParent* actor;
35925:         NPError rv;
35934:         if (!CallNPP_GetValue_NPPVpluginScriptableNPObject(&actor, &rv)) {
35740:             return NPERR_GENERIC_ERROR;
35740:         }
35945: 
35945:         if (NPERR_NO_ERROR != rv) {
35934:             return rv;
35934:         }
35945: 
36075:         if (!actor) {
36075:             NS_ERROR("NPPVpluginScriptableNPObject succeeded but null.");
36075:             return NPERR_GENERIC_ERROR;
36075:         }
36073: 
35945:         const NPNetscapeFuncs* npn = mParent->GetNetscapeFuncs();
35945:         if (!npn) {
35945:             NS_WARNING("No netscape functions?!");
35945:             return NPERR_GENERIC_ERROR;
35945:         }
35945: 
35945:         NPObject* object =
37311:             static_cast<PluginScriptableObjectParent*>(actor)->GetObject(true);
35945:         NS_ASSERTION(object, "This shouldn't ever be null!");
35945: 
35945:         (*(NPObject**)_retval) = npn->retainobject(object);
35945:         return NPERR_NO_ERROR;
35945:     }
35945: 
69027: #ifdef MOZ_ACCESSIBILITY_ATK
69027:     case NPPVpluginNativeAccessibleAtkPlugId: {
69027:         nsCString plugId;
69027:         NPError rv;
69027:         if (!CallNPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId(&plugId, &rv)) {
69027:             return NPERR_GENERIC_ERROR;
69027:         }
69027: 
69027:         if (NPERR_NO_ERROR != rv) {
69027:             return rv;
69027:         }
69027: 
69027:         (*(nsCString*)_retval) = plugId;
69027:         return NPERR_NO_ERROR;
69027:     }
69027: #endif
69027: 
35937:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceParent::NPP_GetValue: Unhandled NPPVariable %i (%s)",
37099:                 (int) aVariable, NPPVariableToString(aVariable)));
35937:         return NPERR_GENERIC_ERROR;
35934:     }
35740: }
35740: 
37350: NPError
37350: PluginInstanceParent::NPP_SetValue(NPNVariable variable, void* value)
37350: {
37350:     switch (variable) {
37350:     case NPNVprivateModeBool:
37350:         NPError result;
37350:         if (!CallNPP_SetValue_NPNVprivateModeBool(*static_cast<NPBool*>(value),
37350:                                                   &result))
37350:             return NPERR_GENERIC_ERROR;
37350: 
37350:         return result;
37350: 
37350:     default:
37350:         NS_ERROR("Unhandled NPNVariable in NPP_SetValue");
37350:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37350:                ("In PluginInstanceParent::NPP_SetValue: Unhandled NPNVariable %i (%s)",
37350:                 (int) variable, NPNVariableToString(variable)));
37350:         return NPERR_GENERIC_ERROR;
37350:     }
37350: }
37350: 
60021: void
60021: PluginInstanceParent::NPP_URLRedirectNotify(const char* url, int32_t status,
60021:                                             void* notifyData)
60021: {
60021:   if (!notifyData)
60021:     return;
60021: 
60021:   PStreamNotifyParent* streamNotify = static_cast<PStreamNotifyParent*>(notifyData);
60021:   unused << streamNotify->SendRedirectNotify(NullableString(url), status);
60021: }
60021: 
35933: int16_t
35933: PluginInstanceParent::NPP_HandleEvent(void* event)
35933: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35933: 
39534: #if defined(XP_MACOSX)
39534:     NPCocoaEvent* npevent = reinterpret_cast<NPCocoaEvent*>(event);
39534: #else
35951:     NPEvent* npevent = reinterpret_cast<NPEvent*>(event);
39534: #endif
36011:     NPRemoteEvent npremoteevent;
36011:     npremoteevent.event = *npevent;
38280:     int16_t handled = 0;
35951: 
36124: #if defined(OS_WIN)
36271:     if (mWindowType == NPWindowTypeDrawable) {
50668:         if (DoublePassRenderingEvent() == npevent->event) {
50668:             CallPaint(npremoteevent, &handled);
50668:             return handled;
50668:         }
50668: 
36271:         switch (npevent->event) {
36271:             case WM_PAINT:
36271:             {
36271:                 RECT rect;
36270:                 SharedSurfaceBeforePaint(rect, npremoteevent);
39265:                 CallPaint(npremoteevent, &handled);
36271:                 SharedSurfaceAfterPaint(npevent);
38401:                 return handled;
36271:             }
36271:             break;
38280: 
38280:             case WM_KILLFOCUS:
38280:             {
38280:               // When the user selects fullscreen mode in Flash video players,
38280:               // WM_KILLFOCUS will be delayed by deferred event processing:
38280:               // WM_LBUTTONUP results in a call to CreateWindow within Flash,
38280:               // which fires WM_KILLFOCUS. Delayed delivery causes Flash to
38280:               // misinterpret the event, dropping back out of fullscreen. Trap
38280:               // this event and drop it.
38280:               PRUnichar szClass[26];
38280:               HWND hwnd = GetForegroundWindow();
38280:               if (hwnd && hwnd != mPluginHWND &&
38280:                   GetClassNameW(hwnd, szClass,
38280:                                 sizeof(szClass)/sizeof(PRUnichar)) &&
42416:                   !wcscmp(szClass, kFlashFullscreenClass)) {
38280:                   return 0;
38280:               }
38280:             }
38401:             break;
39720: 
39720:             case WM_WINDOWPOSCHANGED:
39720:             {
39720:                 // We send this in nsObjectFrame just before painting
39720:                 SendWindowPosChanged(npremoteevent);
39720:                 // nsObjectFrame doesn't care whether we handle this
39720:                 // or not, just returning 1 for good hygiene
39720:                 return 1;
39720:             }
39720:             break;
38401:         }
36124:     }
36124: #endif
36124: 
35980: #if defined(MOZ_X11)
39760:     switch (npevent->type) {
39760:     case GraphicsExpose:
38112:         PLUGIN_LOG_DEBUG(("  schlepping drawable 0x%lx across the pipe\n",
38112:                           npevent->xgraphicsexpose.drawable));
35980:         // Make sure the X server has created the Drawable and completes any
35980:         // drawing before the plugin draws on top.
35980:         //
35980:         // XSync() waits for the X server to complete.  Really this parent
35980:         // process does not need to wait; the child is the process that needs
35980:         // to wait.  A possibly-slightly-better alternative would be to send
35980:         // an X event to the child that the child would wait for.
43912:         XSync(DefaultXDisplay(), False);
41051: 
41051:         return CallPaint(npremoteevent, &handled) ? handled : 0;
41051: 
39760:     case ButtonPress:
39760:         // Release any active pointer grab so that the plugin X client can
39760:         // grab the pointer if it wishes.
43912:         Display *dpy = DefaultXDisplay();
35980: #  ifdef MOZ_WIDGET_GTK2
39760:         // GDK attempts to (asynchronously) track whether there is an active
39760:         // grab so ungrab through GDK.
39760:         gdk_pointer_ungrab(npevent->xbutton.time);
39760: #  else
39760:         XUngrabPointer(dpy, npevent->xbutton.time);
35980: #  endif
39760:         // Wait for the ungrab to complete.
39760:         XSync(dpy, False);
39760:         break;
35951:     }
39265: #endif
35951: 
39883: #ifdef XP_MACOSX
39883:     if (npevent->type == NPCocoaEventDrawRect) {
43370:         if (mDrawingModel == NPDrawingModelCoreAnimation ||
43370:             mDrawingModel == NPDrawingModelInvalidatingCoreAnimation) {
41029:             if (!mIOSurface) {
41029:                 NS_ERROR("No IOSurface allocated.");
41029:                 return false;
41029:             }
41029:             if (!CallNPP_HandleEvent_IOSurface(npremoteevent, 
41029:                                                mIOSurface->GetIOSurfaceID(), 
41029:                                                &handled)) 
41029:                 return false; // no good way to handle errors here...
41029: 
41029:             CGContextRef cgContext = npevent->data.draw.context;
41029:             if (!mShColorSpace) {
41029:                 mShColorSpace = CreateSystemColorSpace();
41029:             }
41029:             if (!mShColorSpace) {
41029:                 PLUGIN_LOG_DEBUG(("Could not allocate ColorSpace."));
41029:                 return false;
41029:             }
62474:             if (cgContext) {
41029:                 nsCARenderer::DrawSurfaceToCGContext(cgContext, mIOSurface, 
41029:                                                      mShColorSpace,
41029:                                                      npevent->data.draw.x,
41029:                                                      npevent->data.draw.y,
41029:                                                      npevent->data.draw.width,
41029:                                                      npevent->data.draw.height);
62474:             }
72865:             return true;
72865:         } else if (mFrontIOSurface) {
72865:             CGContextRef cgContext = npevent->data.draw.context;
72865:             if (!mShColorSpace) {
72865:                 mShColorSpace = CreateSystemColorSpace();
72865:             }
72865:             if (!mShColorSpace) {
72865:                 PLUGIN_LOG_DEBUG(("Could not allocate ColorSpace."));
41029:                 return false;
72865:             }
72865:             if (cgContext) {
72865:                 nsCARenderer::DrawSurfaceToCGContext(cgContext, mFrontIOSurface, 
72865:                                                      mShColorSpace,
72865:                                                      npevent->data.draw.x,
72865:                                                      npevent->data.draw.y,
72865:                                                      npevent->data.draw.width,
72865:                                                      npevent->data.draw.height);
72865:             }
72865:             return true;
41029:         } else {
39883:             if (mShWidth == 0 && mShHeight == 0) {
39883:                 PLUGIN_LOG_DEBUG(("NPCocoaEventDrawRect on window of size 0."));
39883:                 return false;
39883:             }
39883:             if (!mShSurface.IsReadable()) {
39883:                 PLUGIN_LOG_DEBUG(("Shmem is not readable."));
39883:                 return false;
39883:             }
39883: 
41029:             if (!CallNPP_HandleEvent_Shmem(npremoteevent, mShSurface, 
41029:                                            &handled, &mShSurface)) 
39883:                 return false; // no good way to handle errors here...
39883: 
39883:             if (!mShSurface.IsReadable()) {
41029:                 PLUGIN_LOG_DEBUG(("Shmem not returned. Either the plugin crashed "
41029:                                   "or we have a bug."));
39883:                 return false;
39883:             }
39883: 
39883:             char* shContextByte = mShSurface.get<char>();
39883: 
40120:             if (!mShColorSpace) {
40120:                 mShColorSpace = CreateSystemColorSpace();
40120:             }
40120:             if (!mShColorSpace) {
39883:                 PLUGIN_LOG_DEBUG(("Could not allocate ColorSpace."));
41029:                 return false;
39883:             } 
39883:             CGContextRef shContext = ::CGBitmapContextCreate(shContextByte, 
41029:                                     mShWidth, mShHeight, 8, 
41029:                                     mShWidth*4, mShColorSpace, 
41029:                                     kCGImageAlphaPremultipliedFirst | 
41029:                                     kCGBitmapByteOrder32Host);
39883:             if (!shContext) {
39883:                 PLUGIN_LOG_DEBUG(("Could not allocate CGBitmapContext."));
41029:                 return false;
39883:             }
39883: 
39883:             CGImageRef shImage = ::CGBitmapContextCreateImage(shContext);
39883:             if (shImage) {
39883:                 CGContextRef cgContext = npevent->data.draw.context;
41029:      
41029:                 ::CGContextDrawImage(cgContext, 
41029:                                      CGRectMake(0,0,mShWidth,mShHeight), 
41029:                                      shImage);
39883:                 ::CGImageRelease(shImage);
41029:             } else {
41029:                 ::CGContextRelease(shContext);
41029:                 return false;
39883:             }
39883:             ::CGContextRelease(shContext);
41029:             return true;
41029:         }
39883:     }
39883: #endif
39883: 
36271:     if (!CallNPP_HandleEvent(npremoteevent, &handled))
35933:         return 0; // no good way to handle errors here...
36124: 
35933:     return handled;
35933: }
35933: 
35890: NPError
35893: PluginInstanceParent::NPP_NewStream(NPMIMEType type, NPStream* stream,
35890:                                     NPBool seekable, uint16_t* stype)
35890: {
37099:     PLUGIN_LOG_DEBUG(("%s (type=%s, stream=%p, seekable=%i)",
37099:                       FULLFUNCTION, (char*) type, (void*) stream, (int) seekable));
35890: 
35938:     BrowserStreamParent* bs = new BrowserStreamParent(this, stream);
35938: 
35890:     NPError err;
35938:     if (!CallPBrowserStreamConstructor(bs,
36111:                                        NullableString(stream->url),
35890:                                        stream->end,
35890:                                        stream->lastmodified,
35904:                                        static_cast<PStreamNotifyParent*>(stream->notifyData),
36111:                                        NullableString(stream->headers),
36111:                                        NullableString(type), seekable,
36111:                                        &err, stype))
35934:         return NPERR_GENERIC_ERROR;
35938: 
35938:     if (NPERR_NO_ERROR != err)
41382:         unused << PBrowserStreamParent::Send__delete__(bs);
35938: 
35890:     return err;
35890: }
35890: 
35890: NPError
35893: PluginInstanceParent::NPP_DestroyStream(NPStream* stream, NPReason reason)
35890: {
37099:     PLUGIN_LOG_DEBUG(("%s (stream=%p, reason=%i)",
37099:                       FULLFUNCTION, (void*) stream, (int) reason));
35944: 
35938:     AStream* s = static_cast<AStream*>(stream->pdata);
35938:     if (s->IsBrowserStream()) {
35895:         BrowserStreamParent* sp =
35938:             static_cast<BrowserStreamParent*>(s);
35938:         if (sp->mNPP != this)
35890:             NS_RUNTIMEABORT("Mismatched plugin data");
35938: 
39281:         sp->NPP_DestroyStream(reason);
39280:         return NPERR_NO_ERROR;
35934:     }
35938:     else {
35938:         PluginStreamParent* sp =
35938:             static_cast<PluginStreamParent*>(s);
35938:         if (sp->mInstance != this)
35938:             NS_RUNTIMEABORT("Mismatched plugin data");
35890: 
41382:         return PPluginStreamParent::Call__delete__(sp, reason, false) ?
41382:             NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
35934:     }
35890: }
35890: 
37350: void
37350: PluginInstanceParent::NPP_Print(NPPrint* platformPrint)
37350: {
37350:     // TODO: implement me
37350:     NS_ERROR("Not implemented");
37350: }
37350: 
35898: PPluginScriptableObjectParent*
35943: PluginInstanceParent::AllocPPluginScriptableObject()
35835: {
37311:     return new PluginScriptableObjectParent(Proxy);
37311: }
37307: 
37311: #ifdef DEBUG
37311: namespace {
37307: 
37311: struct ActorSearchData
37311: {
37311:     PluginScriptableObjectParent* actor;
37311:     bool found;
37311: };
37311: 
37311: PLDHashOperator
37311: ActorSearch(const void* aKey,
37311:             PluginScriptableObjectParent* aData,
37311:             void* aUserData)
37311: {
37311:     ActorSearchData* asd = reinterpret_cast<ActorSearchData*>(aUserData);
37311:     if (asd->actor == aData) {
37311:         asd->found = true;
37311:         return PL_DHASH_STOP;
37302:     }
37311:     return PL_DHASH_NEXT;
37311: }
37311: 
37311: } // anonymous namespace
37311: #endif // DEBUG
35945: 
35926: bool
35945: PluginInstanceParent::DeallocPPluginScriptableObject(
35945:                                          PPluginScriptableObjectParent* aObject)
35835: {
37311:     PluginScriptableObjectParent* actor =
37311:         static_cast<PluginScriptableObjectParent*>(aObject);
35945: 
37311:     NPObject* object = actor->GetObject(false);
37311:     if (object) {
37311:         NS_ASSERTION(mScriptableObjects.Get(object, nsnull),
37311:                      "NPObject not in the hash!");
37311:         mScriptableObjects.Remove(object);
37311:     }
37311: #ifdef DEBUG
37311:     else {
37311:         ActorSearchData asd = { actor, false };
37311:         mScriptableObjects.EnumerateRead(ActorSearch, &asd);
37311:         NS_ASSERTION(!asd.found, "Actor in the hash with a null NPObject!");
37311:     }
37311: #endif
37311: 
37311:     delete actor;
37307:     return true;
37302: }
35945: 
35945: bool
38994: PluginInstanceParent::RecvPPluginScriptableObjectConstructor(
35945:                                           PPluginScriptableObjectParent* aActor)
35945: {
35965:     // This is only called in response to the child process requesting the
35965:     // creation of an actor. This actor will represent an NPObject that is
35965:     // created by the plugin and returned to the browser.
37311:     PluginScriptableObjectParent* actor =
37311:         static_cast<PluginScriptableObjectParent*>(aActor);
37311:     NS_ASSERTION(!actor->GetObject(false), "Actor already has an object?!");
35945: 
37311:     actor->InitializeProxy();
37311:     NS_ASSERTION(actor->GetObject(false), "Actor should have an object!");
35965: 
35926:     return true;
35835: }
35890: 
35944: void
35944: PluginInstanceParent::NPP_URLNotify(const char* url, NPReason reason,
35944:                                     void* notifyData)
35944: {
37099:     PLUGIN_LOG_DEBUG(("%s (%s, %i, %p)",
37099:                       FULLFUNCTION, url, (int) reason, notifyData));
35944: 
35944:     PStreamNotifyParent* streamNotify =
35944:         static_cast<PStreamNotifyParent*>(notifyData);
41382:     unused << PStreamNotifyParent::Send__delete__(streamNotify, reason);
35944: }
35965: 
37311: bool
37311: PluginInstanceParent::RegisterNPObjectForActor(
37311:                                            NPObject* aObject,
37311:                                            PluginScriptableObjectParent* aActor)
37311: {
37311:     NS_ASSERTION(aObject && aActor, "Null pointers!");
37311:     NS_ASSERTION(mScriptableObjects.IsInitialized(), "Hash not initialized!");
37311:     NS_ASSERTION(!mScriptableObjects.Get(aObject, nsnull), "Duplicate entry!");
37311:     return !!mScriptableObjects.Put(aObject, aActor);
37311: }
37311: 
37311: void
37311: PluginInstanceParent::UnregisterNPObject(NPObject* aObject)
37311: {
37311:     NS_ASSERTION(aObject, "Null pointer!");
37311:     NS_ASSERTION(mScriptableObjects.IsInitialized(), "Hash not initialized!");
37311:     NS_ASSERTION(mScriptableObjects.Get(aObject, nsnull), "Unknown entry!");
37311:     mScriptableObjects.Remove(aObject);
37311: }
37311: 
35965: PluginScriptableObjectParent*
35965: PluginInstanceParent::GetActorForNPObject(NPObject* aObject)
35965: {
35965:     NS_ASSERTION(aObject, "Null pointer!");
35965: 
35965:     if (aObject->_class == PluginScriptableObjectParent::GetClass()) {
35965:         // One of ours!
35965:         ParentNPObject* object = static_cast<ParentNPObject*>(aObject);
35965:         NS_ASSERTION(object->parent, "Null actor!");
35965:         return object->parent;
35965:     }
35965: 
37311:     PluginScriptableObjectParent* actor;
37311:     if (mScriptableObjects.Get(aObject, &actor)) {
35965:         return actor;
35965:     }
37311: 
37311:     actor = new PluginScriptableObjectParent(LocalObject);
37311:     if (!actor) {
37311:         NS_ERROR("Out of memory!");
37311:         return nsnull;
35965:     }
35965: 
38994:     if (!SendPPluginScriptableObjectConstructor(actor)) {
37311:         NS_WARNING("Failed to send constructor message!");
37311:         return nsnull;
37311:     }
35965: 
37311:     actor->InitializeLocal(aObject);
35965:     return actor;
35965: }
35983: 
61408: PPluginSurfaceParent*
61408: PluginInstanceParent::AllocPPluginSurface(const WindowsSharedMemoryHandle& handle,
61408:                                           const gfxIntSize& size,
61408:                                           const bool& transparent)
61408: {
61408: #ifdef XP_WIN
61408:     return new PluginSurfaceParent(handle, size, transparent);
61408: #else
61408:     NS_ERROR("This shouldn't be called!");
61408:     return NULL;
61408: #endif
61408: }
61408: 
61408: bool
61408: PluginInstanceParent::DeallocPPluginSurface(PPluginSurfaceParent* s)
61408: {
61408: #ifdef XP_WIN
61408:     delete s;
61408:     return true;
61408: #else
61408:     return false;
61408: #endif
61408: }
61408: 
35983: bool
39850: PluginInstanceParent::AnswerNPN_PushPopupsEnabledState(const bool& aState)
35983: {
39850:     mNPNIface->pushpopupsenabledstate(mNPP, aState ? 1 : 0);
35983:     return true;
35983: }
35983: 
35983: bool
39850: PluginInstanceParent::AnswerNPN_PopPopupsEnabledState()
35983: {
39850:     mNPNIface->poppopupsenabledstate(mNPP);
35983:     return true;
35983: }
36124: 
37332: bool
37332: PluginInstanceParent::AnswerNPN_GetValueForURL(const NPNURLVariable& variable,
37332:                                                const nsCString& url,
37332:                                                nsCString* value,
37332:                                                NPError* result)
37332: {
37332:     char* v;
37332:     uint32_t len;
37332: 
37332:     *result = mNPNIface->getvalueforurl(mNPP, (NPNURLVariable) variable,
37332:                                         url.get(), &v, &len);
37332:     if (NPERR_NO_ERROR == *result)
37332:         value->Adopt(v, len);
37332: 
37332:     return true;
37332: }
37332: 
37332: bool
37332: PluginInstanceParent::AnswerNPN_SetValueForURL(const NPNURLVariable& variable,
37332:                                                const nsCString& url,
37332:                                                const nsCString& value,
37332:                                                NPError* result)
37332: {
37332:     *result = mNPNIface->setvalueforurl(mNPP, (NPNURLVariable) variable,
37332:                                         url.get(), value.get(),
37332:                                         value.Length());
37332:     return true;
37332: }
37332: 
37332: bool
37332: PluginInstanceParent::AnswerNPN_GetAuthenticationInfo(const nsCString& protocol,
37332:                                                       const nsCString& host,
37332:                                                       const int32_t& port,
37332:                                                       const nsCString& scheme,
37332:                                                       const nsCString& realm,
37332:                                                       nsCString* username,
37332:                                                       nsCString* password,
37332:                                                       NPError* result)
37332: {
37332:     char* u;
37332:     uint32_t ulen;
37332:     char* p;
37332:     uint32_t plen;
37332: 
37332:     *result = mNPNIface->getauthenticationinfo(mNPP, protocol.get(),
37332:                                                host.get(), port,
37332:                                                scheme.get(), realm.get(),
37332:                                                &u, &ulen, &p, &plen);
37390:     if (NPERR_NO_ERROR == *result) {
37332:         username->Adopt(u, ulen);
37332:         password->Adopt(p, plen);
37332:     }
37332:     return true;
37332: }
37332: 
39885: bool
39885: PluginInstanceParent::AnswerNPN_ConvertPoint(const double& sourceX,
42507:                                              const bool&   ignoreDestX,
39885:                                              const double& sourceY,
42507:                                              const bool&   ignoreDestY,
39885:                                              const NPCoordinateSpace& sourceSpace,
39885:                                              const NPCoordinateSpace& destSpace,
39885:                                              double *destX,
39885:                                              double *destY,
39885:                                              bool *result)
39885: {
39885:     *result = mNPNIface->convertpoint(mNPP, sourceX, sourceY, sourceSpace,
39885:                                       ignoreDestX ? nsnull : destX,
39885:                                       ignoreDestY ? nsnull : destY,
39885:                                       destSpace);
39885: 
39885:     return true;
39885: }
39885: 
61864: bool
61864: PluginInstanceParent::RecvNegotiatedCarbon()
61864: {
61864:   nsNPAPIPluginInstance *inst = static_cast<nsNPAPIPluginInstance*>(mNPP->ndata);
61864:   if (!inst) {
61864:     return false;
61864:   }
61864:   inst->CarbonNPAPIFailure();
61864:   return true;
61864: }
61864: 
36124: #if defined(OS_WIN)
36124: 
37550: /*
37550:   plugin focus changes between processes
37550: 
37550:   focus from dom -> child:
39885:     Focus manager calls on widget to set the focus on the window.
37550:     We pick up the resulting wm_setfocus event here, and forward
37550:     that over ipc to the child which calls set focus on itself. 
37550: 
37550:   focus from child -> focus manager:
37550:     Child picks up the local wm_setfocus and sends it via ipc over
86545:     here. We then post a custom event to widget/windows/nswindow
37550:     which fires off a gui event letting the browser know.
37550: */
37550: 
37550: static const PRUnichar kPluginInstanceParentProperty[] =
37550:                          L"PluginInstanceParentProperty";
37550: 
37550: // static
37550: LRESULT CALLBACK
37550: PluginInstanceParent::PluginWindowHookProc(HWND hWnd,
37550:                                            UINT message,
37550:                                            WPARAM wParam,
37550:                                            LPARAM lParam)
37550: {
37550:     PluginInstanceParent* self = reinterpret_cast<PluginInstanceParent*>(
37550:         ::GetPropW(hWnd, kPluginInstanceParentProperty));
37550:     if (!self) {
37550:         NS_NOTREACHED("PluginInstanceParent::PluginWindowHookProc null this ptr!");
37550:         return DefWindowProc(hWnd, message, wParam, lParam);
37550:     }
37550: 
37550:     NS_ASSERTION(self->mPluginHWND == hWnd, "Wrong window!");
37550: 
37550:     switch (message) {
37550:         case WM_SETFOCUS:
38400:         // Let the child plugin window know it should take focus.
37550:         self->CallSetPluginFocus();
37550:         break;
37550: 
37550:         case WM_CLOSE:
37550:         self->UnsubclassPluginWindow();
37550:         break;
37550:     }
37550: 
72354:     if (self->mPluginWndProc == PluginWindowHookProc) {
72354:       NS_NOTREACHED(
72354:         "PluginWindowHookProc invoking mPluginWndProc w/"
72354:         "mPluginWndProc == PluginWindowHookProc????");
72354:         return DefWindowProc(hWnd, message, wParam, lParam);
72354:     }
37550:     return ::CallWindowProc(self->mPluginWndProc, hWnd, message, wParam,
37550:                             lParam);
37550: }
37550: 
37550: void
37550: PluginInstanceParent::SubclassPluginWindow(HWND aWnd)
37550: {
37550:     NS_ASSERTION(!(mPluginHWND && aWnd != mPluginHWND),
37550:       "PluginInstanceParent::SubclassPluginWindow hwnd is not our window!");
37550: 
37550:     if (!mPluginHWND) {
37550:         mPluginHWND = aWnd;
37550:         mPluginWndProc = 
37550:             (WNDPROC)::SetWindowLongPtrA(mPluginHWND, GWLP_WNDPROC,
47318:                          reinterpret_cast<LONG_PTR>(PluginWindowHookProc));
37550:         bool bRes = ::SetPropW(mPluginHWND, kPluginInstanceParentProperty, this);
37550:         NS_ASSERTION(mPluginWndProc,
37550:           "PluginInstanceParent::SubclassPluginWindow failed to set subclass!");
37550:         NS_ASSERTION(bRes,
37550:           "PluginInstanceParent::SubclassPluginWindow failed to set prop!");
37550:    }
37550: }
37550: 
37550: void
37550: PluginInstanceParent::UnsubclassPluginWindow()
37550: {
37550:     if (mPluginHWND && mPluginWndProc) {
37550:         ::SetWindowLongPtrA(mPluginHWND, GWLP_WNDPROC,
47318:                             reinterpret_cast<LONG_PTR>(mPluginWndProc));
37550: 
37550:         ::RemovePropW(mPluginHWND, kPluginInstanceParentProperty);
37550: 
37550:         mPluginWndProc = NULL;
37550:         mPluginHWND = NULL;
37550:     }
37550: }
37550: 
36124: /* windowless drawing helpers */
36124: 
36271: /*
36271:  * Origin info:
36271:  *
36271:  * windowless, offscreen:
36271:  *
36271:  * WM_WINDOWPOSCHANGED: origin is relative to container 
36271:  * setwindow: origin is 0,0
36271:  * WM_PAINT: origin is 0,0
36271:  *
36271:  * windowless, native:
36271:  *
36271:  * WM_WINDOWPOSCHANGED: origin is relative to container 
36271:  * setwindow: origin is relative to container
36271:  * WM_PAINT: origin is relative to container
36271:  *
36271:  * PluginInstanceParent:
36271:  *
36271:  * painting: mPluginPort (nsIntRect, saved in SetWindow)
36271:  */
36271: 
36271: void
36124: PluginInstanceParent::SharedSurfaceRelease()
36124: {
36124:     mSharedSurfaceDib.Close();
36124: }
36124: 
36124: bool
36124: PluginInstanceParent::SharedSurfaceSetWindow(const NPWindow* aWindow,
36124:                                              NPRemoteWindow& aRemoteWindow)
36124: {
36124:     aRemoteWindow.window = nsnull;
57214:     aRemoteWindow.x      = aWindow->x;
57214:     aRemoteWindow.y      = aWindow->y;
36124:     aRemoteWindow.width  = aWindow->width;
36124:     aRemoteWindow.height = aWindow->height;
36124:     aRemoteWindow.type   = aWindow->type;
36124: 
36124:     nsIntRect newPort(aWindow->x, aWindow->y, aWindow->width, aWindow->height);
36124: 
36124:     // save the the rect location within the browser window.
36124:     mPluginPort = newPort;
36124: 
36124:     // move the port to our shared surface origin
36124:     newPort.MoveTo(0,0);
36124: 
36124:     // check to see if we have the room in shared surface
36124:     if (mSharedSurfaceDib.IsValid() && mSharedSize.Contains(newPort)) {
36124:       // ok to paint
36124:       aRemoteWindow.surfaceHandle = 0;
36124:       return true;
36124:     }
36124: 
36124:     // allocate a new shared surface
36124:     SharedSurfaceRelease();
36124:     if (NS_FAILED(mSharedSurfaceDib.Create(reinterpret_cast<HDC>(aWindow->window),
57212:                                            newPort.width, newPort.height, false)))
36124:       return false;
36124: 
36124:     // save the new shared surface size we just allocated
36124:     mSharedSize = newPort;
36124: 
36124:     base::SharedMemoryHandle handle;
36124:     if (NS_FAILED(mSharedSurfaceDib.ShareToProcess(mParent->ChildProcessHandle(), &handle)))
36124:       return false;
36124: 
36124:     aRemoteWindow.surfaceHandle = handle;
36124: 
36124:     return true;
36124: }
36124: 
36270: void
36124: PluginInstanceParent::SharedSurfaceBeforePaint(RECT& rect,
36124:                                                NPRemoteEvent& npremoteevent)
36124: {
36124:     RECT* dr = (RECT*)npremoteevent.event.lParam;
36124:     HDC parentHdc = (HDC)npremoteevent.event.wParam;
36124: 
36124:     nsIntRect dirtyRect(dr->left, dr->top, dr->right-dr->left, dr->bottom-dr->top);
36124:     dirtyRect.MoveBy(-mPluginPort.x, -mPluginPort.y); // should always be smaller than dirtyRect
36124: 
36124:     ::BitBlt(mSharedSurfaceDib.GetHDC(),
36124:              dirtyRect.x,
36124:              dirtyRect.y,
36124:              dirtyRect.width,
36124:              dirtyRect.height,
36124:              parentHdc,
36124:              dr->left,
36124:              dr->top,
36124:              SRCCOPY);
36124: 
36124:     // setup the translated dirty rect we'll send to the child
36124:     rect.left   = dirtyRect.x;
36124:     rect.top    = dirtyRect.y;
36270:     rect.right  = dirtyRect.x + dirtyRect.width;
36270:     rect.bottom = dirtyRect.y + dirtyRect.height;
36124: 
36124:     npremoteevent.event.wParam = WPARAM(0);
36124:     npremoteevent.event.lParam = LPARAM(&rect);
36124: }
36124: 
36124: void
36124: PluginInstanceParent::SharedSurfaceAfterPaint(NPEvent* npevent)
36124: {
36124:     RECT* dr = (RECT*)npevent->lParam;
36124:     HDC parentHdc = (HDC)npevent->wParam;
36124: 
36124:     nsIntRect dirtyRect(dr->left, dr->top, dr->right-dr->left, dr->bottom-dr->top);
36124:     dirtyRect.MoveBy(-mPluginPort.x, -mPluginPort.y);
36124: 
36124:     // src copy the shared dib into the parent surface we are handed.
36124:     ::BitBlt(parentHdc,
36124:              dr->left,
36124:              dr->top,
36124:              dirtyRect.width,
36124:              dirtyRect.height,
36124:              mSharedSurfaceDib.GetHDC(),
36124:              dirtyRect.x,
36124:              dirtyRect.y,
36124:              SRCCOPY);
36124: }
36124: 
36124: #endif // defined(OS_WIN)
37550: 
37550: bool
44190: PluginInstanceParent::AnswerPluginFocusChange(const bool& gotFocus)
37550: {
37550:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
37550: 
37550:     // Currently only in use on windows - an rpc event we receive from the
37550:     // child when it's plugin window (or one of it's children) receives keyboard
37550:     // focus. We forward the event down to widget so the dom/focus manager can
37550:     // be updated.
37550: #if defined(OS_WIN)
44190:     ::SendMessage(mPluginHWND, gOOPPPluginFocusEvent, gotFocus ? 1 : 0, 0);
37550:     return true;
37550: #else
44190:     NS_NOTREACHED("PluginInstanceParent::AnswerPluginFocusChange not implemented!");
37550:     return false;
37550: #endif
37550: }
