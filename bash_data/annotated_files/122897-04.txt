 48383: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 48383: // vim:set ts=2 sts=2 sw=2 et cin:
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 48383: 
 73761: #ifndef dom_plugins_PluginUtilsOSX_h
 73761: #define dom_plugins_PluginUtilsOSX_h 1
 73761: 
 48383: #include "npapi.h"
 71284: #include "nsRect.h"
106985: #include "mozilla/gfx/QuartzSupport.h"
 48383: 
 48383: namespace mozilla {
 48383: namespace plugins {
 48383: namespace PluginUtilsOSX {
 48383: 
 71284: // Need to call back into the browser's message loop to process event.
 48383: typedef void (*RemoteProcessEvents) (void*);
 48383: 
 48383: NPError ShowCocoaContextMenu(void* aMenu, int aX, int aY, void* pluginModule, RemoteProcessEvents remoteEvent);
 48383: 
 48383: void InvokeNativeEventLoop();
 48383: 
 71284: // Need to call back and send a cocoa draw event to the plugin.
 71284: typedef void (*DrawPluginFunc) (CGContextRef, void*, nsIntRect aUpdateRect);
 71284: 
122897: void* GetCGLayer(DrawPluginFunc aFunc, void* aPluginInstance, bool aAvoidCGCrashes);
 71284: void ReleaseCGLayer(void* cgLayer);
 71284: void Repaint(void* cgLayer, nsIntRect aRect);
 71284: 
 72639: bool SetProcessName(const char* aProcessName);
 71284: 
 73761: /*
 73761:  * Provides a wrapper around nsCARenderer to manage double buffering
 73761:  * without having to unbind nsCARenderer on every surface swaps.
 73761:  *
 73761:  * The double buffer renderer begins with no initialize surfaces.
 73761:  * The buffers can be initialized and cleared individually.
 73761:  * Swapping still occurs regardless if the buffers are initialized.
 73761:  */
 73761: class THEBES_API nsDoubleBufferCARenderer {
 73761: public:
115799:   nsDoubleBufferCARenderer() : mCALayer(nullptr), mContentsScaleFactor(1.0) {}
115799:   // Returns width in "display pixels".  A "display pixel" is the smallest
115799:   // fully addressable part of a display.  But in HiDPI modes each "display
115799:   // pixel" corresponds to more than one device pixel.  Multiply display pixels
115799:   // by mContentsScaleFactor to get device pixels.
 73761:   size_t GetFrontSurfaceWidth();
115799:   // Returns height in "display pixels".  Multiply by
115799:   // mContentsScaleFactor to get device pixels.
 73761:   size_t GetFrontSurfaceHeight();
119106:   double GetFrontSurfaceContentsScaleFactor();
115799:   // Returns width in "display pixels".  Multiply by
115799:   // mContentsScaleFactor to get device pixels.
 73761:   size_t GetBackSurfaceWidth();
115799:   // Returns height in "display pixels".  Multiply by
115799:   // mContentsScaleFactor to get device pixels.
 73761:   size_t GetBackSurfaceHeight();
119106:   double GetBackSurfaceContentsScaleFactor();
 73761:   IOSurfaceID GetFrontSurfaceID();
 73761: 
 73761:   bool HasBackSurface();
 73761:   bool HasFrontSurface();
 73761:   bool HasCALayer();
 73761: 
 73761:   void SetCALayer(void *aCALayer);
115799:   // aWidth and aHeight are in "display pixels".  Multiply by
115799:   // aContentsScaleFactor to get device pixels.
115799:   bool InitFrontSurface(size_t aWidth, size_t aHeight,
115799:                         double aContentsScaleFactor,
115799:                         AllowOfflineRendererEnum aAllowOfflineRenderer);
 73761:   void Render();
 73761:   void SwapSurfaces();
 73761:   void ClearFrontSurface();
 73761:   void ClearBackSurface();
 73761: 
115799:   double GetContentsScaleFactor() { return mContentsScaleFactor; }
115799: 
 73761: private:
 73761:   void *mCALayer;
106985:   RefPtr<nsCARenderer> mCARenderer;
106985:   RefPtr<MacIOSurface> mFrontSurface;
106985:   RefPtr<MacIOSurface> mBackSurface;
115799:   double mContentsScaleFactor;
 73761: };
 73761: 
 48383: } // namespace PluginUtilsOSX
 48383: } // namespace plugins
 48383: } // namespace mozilla
 73761: 
 73761: #endif //dom_plugins_PluginUtilsOSX_h
