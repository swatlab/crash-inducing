42402: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
39498:  * ***** BEGIN LICENSE BLOCK *****
39498:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
39498:  *
39498:  * The contents of this file are subject to the Mozilla Public License Version
39498:  * 1.1 (the "License"); you may not use this file except in compliance with
39498:  * the License. You may obtain a copy of the License at
39498:  * http://www.mozilla.org/MPL/
39498:  *
39498:  * Software distributed under the License is distributed on an "AS IS" basis,
39498:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
39498:  * for the specific language governing rights and limitations under the
39498:  * License.
39498:  *
39498:  * The Original Code is Mozilla Corporation code.
39498:  *
39498:  * The Initial Developer of the Original Code is Mozilla Foundation.
39498:  * Portions created by the Initial Developer are Copyright (C) 2009
39498:  * the Initial Developer. All Rights Reserved.
39498:  *
39498:  * Contributor(s):
39498:  *   Robert O'Callahan <robert@ocallahan.org>
39498:  *
39498:  * Alternatively, the contents of this file may be used under the terms of
39498:  * either the GNU General Public License Version 2 or later (the "GPL"), or
39498:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
39498:  * in which case the provisions of the GPL or the LGPL are applicable instead
39498:  * of those above. If you wish to allow use of your version of this file only
39498:  * under the terms of either the GPL or the LGPL, and not to allow others to
39498:  * use your version of this file under the terms of the MPL, indicate your
39498:  * decision by deleting the provisions above and replace them with the notice
39498:  * and other provisions required by the GPL or the LGPL. If you do not delete
39498:  * the provisions above, a recipient may use your version of this file under
39498:  * the terms of any one of the MPL, the GPL or the LGPL.
39498:  *
39498:  * ***** END LICENSE BLOCK ***** */
39498: 
39498: #ifndef GFX_IMAGELAYER_H
39498: #define GFX_IMAGELAYER_H
39498: 
39498: #include "Layers.h"
39498: 
39498: #include "gfxPattern.h"
39498: #include "nsThreadUtils.h"
62472: #include "nsCoreAnimationSupport.h"
39498: 
39498: namespace mozilla {
39498: namespace layers {
39498: 
59431: enum StereoMode {
59431:   STEREO_MODE_MONO,
59431:   STEREO_MODE_LEFT_RIGHT,
59431:   STEREO_MODE_RIGHT_LEFT,
59431:   STEREO_MODE_BOTTOM_TOP,
59431:   STEREO_MODE_TOP_BOTTOM
59431: };
59431: 
39498: /**
39498:  * A class representing a buffer of pixel data. The data can be in one
39498:  * of various formats including YCbCr.
39498:  * 
39498:  * Create an image using an ImageContainer. Fill the image with data, and
39498:  * then call ImageContainer::SetImage to display it. An image must not be
39498:  * modified after calling SetImage. Image implementations do not need to
39498:  * perform locking; when filling an Image, the Image client is responsible
39498:  * for ensuring only one thread accesses the Image at a time, and after
39498:  * SetImage the image is immutable.
39498:  * 
39498:  * When resampling an Image, only pixels within the buffer should be
39498:  * sampled. For example, cairo images should be sampled in EXTEND_PAD mode.
39498:  */
39498: class THEBES_API Image {
39498:   THEBES_INLINE_DECL_THREADSAFE_REFCOUNTING(Image)
39498: 
39498: public:
39498:   virtual ~Image() {}
39498: 
39498:   enum Format {
39498:     /**
39498:      * The PLANAR_YCBCR format creates a PlanarYCbCrImage. All backends should
39498:      * support this format, because the Ogg video decoder depends on it.
39498:      * The maximum image width and height is 16384.
39498:      */
39498:     PLANAR_YCBCR,
39498: 
39498:     /**
39498:      * The CAIRO_SURFACE format creates a CairoImage. All backends should
39498:      * support this format, because video rendering sometimes requires it.
39498:      * 
39498:      * This format is useful even though a ThebesLayer could be used.
39498:      * It makes it easy to render a cairo surface when another Image format
39498:      * could be used. It can also avoid copying the surface data in some
39498:      * cases.
39498:      * 
39498:      * Images in CAIRO_SURFACE format should only be created and
39498:      * manipulated on the main thread, since the underlying cairo surface
39498:      * is main-thread-only.
39498:      */
62472:     CAIRO_SURFACE,
62472: 
62472:     /**
62472:      * The MAC_IO_SURFACE format creates a MacIOSurfaceImage. This
62472:      * is only supported on Mac with OpenGL layers.
62472:      *
62472:      * It wraps an IOSurface object and binds it directly to a GL texture.
62472:      */
62472:     MAC_IO_SURFACE
39498:   };
39498: 
39498:   Format GetFormat() { return mFormat; }
39498:   void* GetImplData() { return mImplData; }
39498: 
39498: protected:
39498:   Image(void* aImplData, Format aFormat) :
39498:     mImplData(aImplData),
39498:     mFormat(aFormat)
39498:   {}
39498: 
39498:   void* mImplData;
39498:   Format mFormat;
39498: };
39498: 
39498: /**
39498:  * A class that manages Images for an ImageLayer. The only reason
39498:  * we need a separate class here is that ImageLayers aren't threadsafe
39498:  * (because layers can only be used on the main thread) and we want to
39498:  * be able to set the current Image from any thread, to facilitate
39498:  * video playback without involving the main thread, for example.
39498:  */
39498: class THEBES_API ImageContainer {
39498:   THEBES_INLINE_DECL_THREADSAFE_REFCOUNTING(ImageContainer)
39498: 
39498: public:
57389:   ImageContainer() {}
39498:   virtual ~ImageContainer() {}
39498: 
39498:   /**
39498:    * Create an Image in one of the given formats.
39498:    * Picks the "best" format from the list and creates an Image of that
39498:    * format.
39498:    * Returns null if this backend does not support any of the formats.
39498:    */
39498:   virtual already_AddRefed<Image> CreateImage(const Image::Format* aFormats,
39498:                                               PRUint32 aNumFormats) = 0;
39498: 
39498:   /**
39498:    * Set an Image as the current image to display. The Image must have
39498:    * been created by this ImageContainer.
39498:    * 
39498:    * The Image data must not be modified after this method is called!
39498:    */
39498:   virtual void SetCurrentImage(Image* aImage) = 0;
39498: 
39498:   /**
39498:    * Get the current Image.
39498:    * This has to add a reference since otherwise there are race conditions
39498:    * where the current image is destroyed before the caller can add
39498:    * a reference.
39498:    */
39498:   virtual already_AddRefed<Image> GetCurrentImage() = 0;
39498: 
39498:   /**
39498:    * Get the current image as a gfxASurface. This is useful for fallback
39498:    * rendering.
39498:    * This can only be called from the main thread, since cairo objects
39498:    * can only be used from the main thread.
39498:    * This is defined here and not on Image because it's possible (likely)
39498:    * that some backends will make an Image "ready to draw" only when it
39498:    * becomes the current image for an image container.
39498:    * Returns null if there is no current image.
39498:    * Returns the size in aSize.
39498:    * The returned surface will never be modified. The caller must not
39498:    * modify it.
39498:    */
39498:   virtual already_AddRefed<gfxASurface> GetCurrentAsSurface(gfxIntSize* aSizeResult) = 0;
39498: 
39498:   /**
39498:    * Returns the layer manager for this container. This can only
39498:    * be used on the main thread, since layer managers should only be
39498:    * accessed on the main thread.
39498:    */
39498:   LayerManager* Manager()
39498:   {
39498:     NS_PRECONDITION(NS_IsMainThread(), "Must be called on main thread");
39498:     return mManager;
39498:   }
39498: 
41389:   /**
41389:    * Returns the size of the image in pixels.
41389:    */
41389:   virtual gfxIntSize GetCurrentSize() = 0;
41389: 
49070:   /**
49070:    * Set a new layer manager for this image container.  It must be
49070:    * either of the same type as the container's current layer manager,
49070:    * or null.  TRUE is returned on success.
49070:    */
49070:   virtual PRBool SetLayerManager(LayerManager *aManager) = 0;
49070: 
57389:   /**
57389:    * Sets a size that the image is expected to be rendered at.
57389:    * This is a hint for image backends to optimize scaling.
57389:    * Default implementation in this class is to ignore the hint.
57389:    */
57389:   virtual void SetScaleHint(const gfxIntSize& /* aScaleHint */) { }
57389: 
59714:   /**
59714:    * Get the layer manager type this image container was created with,
59714:    * presumably its users might want to do something special if types do not
59714:    * match.
59714:    */
59714:   virtual LayerManager::LayersBackend GetBackendType() = 0;
59714: 
39498: protected:
39498:   LayerManager* mManager;
39498: 
39498:   ImageContainer(LayerManager* aManager) : mManager(aManager) {}
39498: };
39498: 
39498: /**
39498:  * A Layer which renders an Image.
39498:  */
39498: class THEBES_API ImageLayer : public Layer {
39498: public:
39498:   /**
39498:    * CONSTRUCTION PHASE ONLY
39498:    * Set the ImageContainer. aContainer must have the same layer manager
39498:    * as this layer.
39498:    */
60712:   void SetContainer(ImageContainer* aContainer) 
60712:   {
60716:     NS_ASSERTION(!aContainer->Manager() || aContainer->Manager() == Manager(), 
60712:                  "ImageContainer must have the same manager as the ImageLayer");
60712:     mContainer = aContainer;  
60712:   }
39498:   /**
39498:    * CONSTRUCTION PHASE ONLY
39498:    * Set the filter used to resample this image if necessary.
39498:    */
39498:   void SetFilter(gfxPattern::GraphicsFilter aFilter) { mFilter = aFilter; }
39498: 
39498:   ImageContainer* GetContainer() { return mContainer; }
39498:   gfxPattern::GraphicsFilter GetFilter() { return mFilter; }
39498: 
48024:   MOZ_LAYER_DECL_NAME("ImageLayer", TYPE_IMAGE)
47104: 
57097:   virtual void ComputeEffectiveTransforms(const gfx3DMatrix& aTransformToSurface)
57097:   {
57097:     // Snap image edges to pixel boundaries
57097:     gfxRect snap(0, 0, 0, 0);
57097:     if (mContainer) {
57097:       gfxIntSize size = mContainer->GetCurrentSize();
57097:       snap.size = gfxSize(size.width, size.height);
57097:     }
57097:     // Snap our local transform first, and snap the inherited transform as well.
57097:     // This makes our snapping equivalent to what would happen if our content
57097:     // was drawn into a ThebesLayer (gfxContext would snap using the local
57097:     // transform, then we'd snap again when compositing the ThebesLayer).
57097:     mEffectiveTransform =
57097:         SnapTransform(GetLocalTransform(), snap, nsnull)*
57097:         SnapTransform(aTransformToSurface, gfxRect(0, 0, 0, 0), nsnull);
57097:   }
57097: 
39498: protected:
39498:   ImageLayer(LayerManager* aManager, void* aImplData)
39498:     : Layer(aManager, aImplData), mFilter(gfxPattern::FILTER_GOOD) {}
39498: 
48025:   virtual nsACString& PrintInfo(nsACString& aTo, const char* aPrefix);
48025: 
39498:   nsRefPtr<ImageContainer> mContainer;
39498:   gfxPattern::GraphicsFilter mFilter;
39498: };
39498: 
39498: /****** Image subtypes for the different formats ******/
39498: 
39498: /**
39498:  * We assume that the image data is in the REC 470M color space (see
39498:  * Theora specification, section 4.3.1).
41188:  *
41188:  * The YCbCr format can be:
41188:  *
41188:  * 4:4:4 - CbCr width/height are the same as Y.
41188:  * 4:2:2 - CbCr width is half that of Y. Height is the same.
41188:  * 4:2:0 - CbCr width and height is half that of Y.
41188:  *
41188:  * The color format is detected based on the height/width ratios
41188:  * defined above.
41188:  * 
41188:  * The Image that is rendered is the picture region defined by
41188:  * mPicX, mPicY and mPicSize. The size of the rendered image is
41188:  * mPicSize, not mYSize or mCbCrSize.
39498:  */
39498: class THEBES_API PlanarYCbCrImage : public Image {
39498: public:
39498:   struct Data {
39498:     // Luminance buffer
39498:     PRUint8* mYChannel;
39498:     PRInt32 mYStride;
39498:     gfxIntSize mYSize;
39498:     // Chroma buffers
39498:     PRUint8* mCbChannel;
39498:     PRUint8* mCrChannel;
39498:     PRInt32 mCbCrStride;
39498:     gfxIntSize mCbCrSize;
41188:     // Picture region
41188:     PRUint32 mPicX;
41188:     PRUint32 mPicY;
41188:     gfxIntSize mPicSize;
59431:     StereoMode mStereoMode;
39498:   };
39498: 
42438:   enum {
42438:     MAX_DIMENSION = 16384
42438:   };
42438: 
39498:   /**
39498:    * This makes a copy of the data buffers.
39498:    * XXX Eventually we will change this to not make a copy of the data,
41392:    * Right now it doesn't matter because the BasicLayer implementation
41392:    * does YCbCr conversion here anyway.
39498:    */
39498:   virtual void SetData(const Data& aData) = 0;
39498: 
39498: protected:
39498:   PlanarYCbCrImage(void* aImplData) : Image(aImplData, PLANAR_YCBCR) {}
39498: };
39498: 
39498: /**
39498:  * Currently, the data in a CairoImage surface is treated as being in the
39498:  * device output color space.
39498:  */
39498: class THEBES_API CairoImage : public Image {
39498: public:
39498:   struct Data {
39498:     gfxASurface* mSurface;
39498:     gfxIntSize mSize;
39498:   };
39498: 
39498:   /**
39498:    * This can only be called on the main thread. It may add a reference
39498:    * to the surface (which will eventually be released on the main thread).
39498:    * The surface must not be modified after this call!!!
39498:    */
39498:   virtual void SetData(const Data& aData) = 0;
39498: 
39498: protected:
39498:   CairoImage(void* aImplData) : Image(aImplData, CAIRO_SURFACE) {}
39498: };
39498: 
62472: #ifdef XP_MACOSX
62472: class THEBES_API MacIOSurfaceImage : public Image {
62472: public:
62472:   struct Data {
62472:     nsIOSurface* mIOSurface;
62472:   };
62472: 
62472:  /**
62472:   * This can only be called on the main thread. It may add a reference
62472:   * to the surface (which will eventually be released on the main thread).
62472:   * The surface must not be modified after this call!!!
62472:   */
62472:   virtual void SetData(const Data& aData) = 0;
62472: 
62724:   /**
62724:    * Temporary hacks to force plugin drawing during an empty transaction.
62724:    * This should not be used for anything else, and will be removed
62724:    * when async plugin rendering is complete.
62724:    */
62724:   typedef void (*UpdateSurfaceCallback)(ImageContainer* aContainer, void* aInstanceOwner);
68239:   virtual void SetUpdateCallback(UpdateSurfaceCallback aCallback, void* aInstanceOwner) = 0;
68239:   typedef void (*DestroyCallback)(void* aInstanceOwner);
68239:   virtual void SetDestroyCallback(DestroyCallback aCallback) = 0;
62724: 
62472: protected:
62472:   MacIOSurfaceImage(void* aImplData) : Image(aImplData, MAC_IO_SURFACE) {}
62472: };
62472: #endif
62472: 
39498: }
39498: }
39498: 
39498: #endif /* GFX_IMAGELAYER_H */
