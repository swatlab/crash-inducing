    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIDOMNSHTMLImageElement.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsImageLoadingContent.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsMappedAttributes.h"
    1: #include "nsIJSNativeInitializer.h"
    1: #include "nsSize.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIURL.h"
    1: #include "nsIIOService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsNetUtil.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIFrame.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsIDOMWindow.h"
    1: 
    1: #include "imgIContainer.h"
    1: #include "imgILoader.h"
    1: #include "imgIRequest.h"
    1: #include "imgIDecoderObserver.h"
    1: 
    1: #include "nsILoadGroup.h"
    1: 
    1: #include "nsRuleData.h"
    1: 
    1: #include "nsIJSContextStack.h"
    1: #include "nsImageMapUtils.h"
    1: #include "nsIDOMHTMLMapElement.h"
    1: #include "nsEventDispatcher.h"
    1: 
    1: #include "nsLayoutUtils.h"
    1: 
    1: // XXX nav attrs: suppress
    1: 
    1: class nsHTMLImageElement : public nsGenericHTMLElement,
    1:                            public nsImageLoadingContent,
    1:                            public nsIDOMHTMLImageElement,
    1:                            public nsIDOMNSHTMLImageElement,
    1:                            public nsIJSNativeInitializer
    1: {
    1: public:
    1:   nsHTMLImageElement(nsINodeInfo *aNodeInfo);
    1:   virtual ~nsHTMLImageElement();
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   // nsIDOMNode
    1:   NS_FORWARD_NSIDOMNODE(nsGenericHTMLElement::)
    1: 
    1:   // nsIDOMElement
    1:   NS_FORWARD_NSIDOMELEMENT(nsGenericHTMLElement::)
    1: 
    1:   // nsIDOMHTMLElement
    1:   NS_FORWARD_NSIDOMHTMLELEMENT(nsGenericHTMLElement::)
    1: 
    1:   // nsIDOMHTMLImageElement
    1:   NS_DECL_NSIDOMHTMLIMAGEELEMENT
    1: 
    1:   // nsIDOMNSHTMLImageElement
    1:   NS_DECL_NSIDOMNSHTMLIMAGEELEMENT
    1: 
18445:   // override from nsGenericHTMLElement
18445:   NS_IMETHOD GetDraggable(PRBool* aDraggable);
18445: 
    1:   // nsIJSNativeInitializer
 8947:   NS_IMETHOD Initialize(nsISupports* aOwner, JSContext* aContext,
 8947:                         JSObject* aObj, PRUint32 argc, jsval* argv);
    1: 
    1:   // nsIContent
    1:   virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
    1:                                 nsIAtom* aAttribute,
    1:                                 const nsAString& aValue,
    1:                                 nsAttrValue& aResult);
    1:   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                               PRInt32 aModType) const;
    1:   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
    1:   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
    1: 
    1:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
    1: 
14348:   PRBool IsHTMLFocusable(PRBool *aIsFocusable, PRInt32 *aTabIndex);
    1: 
    1:   // SetAttr override.  C++ is stupid, so have to override both
    1:   // overloaded methods.
    1:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                    const nsAString& aValue, PRBool aNotify)
    1:   {
    1:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
    1:   }
    1:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                            nsIAtom* aPrefix, const nsAString& aValue,
    1:                            PRBool aNotify);
22743:   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
22743:                              PRBool aNotify);
    1: 
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers);
    1: 
    1:   virtual PRInt32 IntrinsicState() const;
    1:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
    1: 
28627:   void MaybeLoadImage();
    1: protected:
    1:   nsPoint GetXY();
    1:   nsSize GetWidthHeight();
    1: };
    1: 
    1: nsGenericHTMLElement*
    1: NS_NewHTMLImageElement(nsINodeInfo *aNodeInfo, PRBool aFromParser)
    1: {
    1:   /*
    1:    * nsHTMLImageElement's will be created without a nsINodeInfo passed in
    1:    * if someone says "var img = new Image();" in JavaScript, in a case like
    1:    * that we request the nsINodeInfo from the document's nodeinfo list.
    1:    */
    1:   nsCOMPtr<nsINodeInfo> nodeInfo(aNodeInfo);
    1:   if (!nodeInfo) {
    1:     nsCOMPtr<nsIDocument> doc =
    1:       do_QueryInterface(nsContentUtils::GetDocumentFromCaller());
    1:     NS_ENSURE_TRUE(doc, nsnull);
    1: 
19197:     nodeInfo = doc->NodeInfoManager()->GetNodeInfo(nsGkAtoms::img, nsnull,
33339:                                                    kNameSpaceID_XHTML);
19197:     NS_ENSURE_TRUE(nodeInfo, nsnull);
    1:   }
    1: 
11169:   return new nsHTMLImageElement(nodeInfo);
    1: }
    1: 
    1: nsHTMLImageElement::nsHTMLImageElement(nsINodeInfo *aNodeInfo)
    1:   : nsGenericHTMLElement(aNodeInfo)
    1: {
    1: }
    1: 
    1: nsHTMLImageElement::~nsHTMLImageElement()
    1: {
    1:   DestroyImageLoadingContent();
    1: }
    1: 
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsHTMLImageElement, nsGenericElement)
    1: NS_IMPL_RELEASE_INHERITED(nsHTMLImageElement, nsGenericElement)
    1: 
    1: 
    1: // QueryInterface implementation for nsHTMLImageElement
21218: NS_INTERFACE_TABLE_HEAD(nsHTMLImageElement)
21218:   NS_HTML_CONTENT_INTERFACE_TABLE6(nsHTMLImageElement,
 4838:                                    nsIDOMHTMLImageElement,
 4838:                                    nsIDOMNSHTMLImageElement,
 4838:                                    nsIJSNativeInitializer,
 4838:                                    imgIDecoderObserver,
13964:                                    nsIImageLoadingContent,
13964:                                    imgIContainerObserver)
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLImageElement,
21218:                                                nsGenericHTMLElement)
 4838: NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLImageElement)
    1: 
    1: 
    1: NS_IMPL_ELEMENT_CLONE(nsHTMLImageElement)
    1: 
    1: 
    1: NS_IMPL_STRING_ATTR(nsHTMLImageElement, Name, name)
    1: NS_IMPL_STRING_ATTR(nsHTMLImageElement, Align, align)
    1: NS_IMPL_STRING_ATTR(nsHTMLImageElement, Alt, alt)
    1: NS_IMPL_STRING_ATTR(nsHTMLImageElement, Border, border)
    1: NS_IMPL_INT_ATTR(nsHTMLImageElement, Hspace, hspace)
    1: NS_IMPL_BOOL_ATTR(nsHTMLImageElement, IsMap, ismap)
    1: NS_IMPL_URI_ATTR(nsHTMLImageElement, LongDesc, longdesc)
    1: NS_IMPL_STRING_ATTR(nsHTMLImageElement, Lowsrc, lowsrc)
    1: NS_IMPL_URI_ATTR(nsHTMLImageElement, Src, src)
    1: NS_IMPL_STRING_ATTR(nsHTMLImageElement, UseMap, usemap)
    1: NS_IMPL_INT_ATTR(nsHTMLImageElement, Vspace, vspace)
    1: 
    1: NS_IMETHODIMP
18445: nsHTMLImageElement::GetDraggable(PRBool* aDraggable)
18445: {
18445:   // images may be dragged unless the draggable attribute is false
18445:   *aDraggable = !AttrValueIs(kNameSpaceID_None, nsGkAtoms::draggable,
18445:                              nsGkAtoms::_false, eIgnoreCase);
18445:   return NS_OK;
18445: }
18445: 
18445: NS_IMETHODIMP
    1: nsHTMLImageElement::GetComplete(PRBool* aComplete)
    1: {
    1:   NS_PRECONDITION(aComplete, "Null out param!");
    1:   *aComplete = PR_TRUE;
    1: 
    1:   if (!mCurrentRequest) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRUint32 status;
    1:   mCurrentRequest->GetImageStatus(&status);
    1:   *aComplete =
    1:     (status &
    1:      (imgIRequest::STATUS_LOAD_COMPLETE | imgIRequest::STATUS_ERROR)) != 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsPoint
    1: nsHTMLImageElement::GetXY()
    1: {
    1:   nsPoint point(0, 0);
    1: 
    1:   nsIFrame* frame = GetPrimaryFrame(Flush_Layout);
    1: 
    1:   if (!frame) {
    1:     return point;
    1:   }
    1: 
    1:   nsIFrame* layer = nsLayoutUtils::GetClosestLayer(frame->GetParent());
    1:   nsPoint origin(frame->GetOffsetTo(layer));
    1:   // Convert to pixels using that scale
    1:   point.x = nsPresContext::AppUnitsToIntCSSPixels(origin.x);
    1:   point.y = nsPresContext::AppUnitsToIntCSSPixels(origin.y);
    1: 
    1:   return point;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLImageElement::GetX(PRInt32* aX)
    1: {
    1:   *aX = GetXY().x;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLImageElement::GetY(PRInt32* aY)
    1: {
    1:   *aY = GetXY().y;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsSize
    1: nsHTMLImageElement::GetWidthHeight()
    1: {
    1:   nsSize size(0,0);
    1: 
    1:   nsIFrame* frame = GetPrimaryFrame(Flush_Layout);
    1: 
    1:   if (frame) {
    1:     size = frame->GetContentRect().Size();
    1: 
    1:     size.width = nsPresContext::AppUnitsToIntCSSPixels(size.width);
    1:     size.height = nsPresContext::AppUnitsToIntCSSPixels(size.height);
    1:   } else {
    1:     const nsAttrValue* value;
    1:     nsCOMPtr<imgIContainer> image;
    1:     if (mCurrentRequest) {
    1:       mCurrentRequest->GetImage(getter_AddRefs(image));
    1:     }
    1: 
    1:     if ((value = GetParsedAttr(nsGkAtoms::width)) &&
    1:         value->Type() == nsAttrValue::eInteger) {
    1:       size.width = value->GetIntegerValue();
    1:     } else if (image) {
    1:       image->GetWidth(&size.width);
    1:     }
    1: 
    1:     if ((value = GetParsedAttr(nsGkAtoms::height)) &&
    1:         value->Type() == nsAttrValue::eInteger) {
    1:       size.height = value->GetIntegerValue();
    1:     } else if (image) {
    1:       image->GetHeight(&size.height);
    1:     }
    1:   }
    1: 
    1:   return size;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLImageElement::GetHeight(PRInt32* aHeight)
    1: {
    1:   *aHeight = GetWidthHeight().height;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLImageElement::SetHeight(PRInt32 aHeight)
    1: {
    1:   nsAutoString val;
    1:   val.AppendInt(aHeight);
    1: 
    1:   return nsGenericHTMLElement::SetAttr(kNameSpaceID_None, nsGkAtoms::height,
    1:                                        val, PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLImageElement::GetWidth(PRInt32* aWidth)
    1: {
    1:   *aWidth = GetWidthHeight().width;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLImageElement::SetWidth(PRInt32 aWidth)
    1: {
    1:   nsAutoString val;
    1:   val.AppendInt(aWidth);
    1: 
    1:   return nsGenericHTMLElement::SetAttr(kNameSpaceID_None, nsGkAtoms::width,
    1:                                        val, PR_TRUE);
    1: }
    1: 
    1: PRBool
    1: nsHTMLImageElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                                    nsIAtom* aAttribute,
    1:                                    const nsAString& aValue,
    1:                                    nsAttrValue& aResult)
    1: {
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     if (aAttribute == nsGkAtoms::align) {
    1:       return ParseAlignValue(aValue, aResult);
    1:     }
    1:     if (aAttribute == nsGkAtoms::src) {
    1:       static const char* kWhitespace = " \n\r\t\b";
    1:       aResult.SetTo(nsContentUtils::TrimCharsInSet(kWhitespace, aValue));
    1:       return PR_TRUE;
    1:     }
    1:     if (ParseImageAttribute(aAttribute, aValue, aResult)) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
    1:                                               aResult);
    1: }
    1: 
    1: static void
    1: MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
    1:                       nsRuleData* aData)
    1: {
    1:   nsGenericHTMLElement::MapImageAlignAttributeInto(aAttributes, aData);
    1:   nsGenericHTMLElement::MapImageBorderAttributeInto(aAttributes, aData);
    1:   nsGenericHTMLElement::MapImageMarginAttributeInto(aAttributes, aData);
    1:   nsGenericHTMLElement::MapImageSizeAttributesInto(aAttributes, aData);
    1:   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
    1: }
    1: 
    1: nsChangeHint
    1: nsHTMLImageElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                            PRInt32 aModType) const
    1: {
    1:   nsChangeHint retval =
    1:     nsGenericHTMLElement::GetAttributeChangeHint(aAttribute, aModType);
    1:   if (aAttribute == nsGkAtoms::usemap ||
    1:       aAttribute == nsGkAtoms::ismap) {
    1:     NS_UpdateHint(retval, NS_STYLE_HINT_FRAMECHANGE);
    1:   }
    1:   return retval;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsHTMLImageElement::IsAttributeMapped(const nsIAtom* aAttribute) const
    1: {
    1:   static const MappedAttributeEntry* const map[] = {
    1:     sCommonAttributeMap,
    1:     sImageMarginSizeAttributeMap,
    1:     sImageBorderAttributeMap,
    1:     sImageAlignAttributeMap
    1:   };
    1: 
    1:   return FindAttributeDependence(aAttribute, map, NS_ARRAY_LENGTH(map));
    1: }
    1: 
    1: 
    1: nsMapRuleToAttributesFunc
    1: nsHTMLImageElement::GetAttributeMappingFunction() const
    1: {
    1:   return &MapAttributesIntoRule;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLImageElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
    1:   // If we are a map and get a mouse click, don't let it be handled by
    1:   // the Generic Element as this could cause a click event to fire
    1:   // twice, once by the image frame for the map and once by the Anchor
    1:   // element. (bug 39723)
    1:   if (aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
    1:       aVisitor.mEvent->message == NS_MOUSE_CLICK &&
 3233:       static_cast<nsMouseEvent*>(aVisitor.mEvent)->button ==
    1:         nsMouseEvent::eLeftButton) {
    1:     PRBool isMap = PR_FALSE;
    1:     GetIsMap(&isMap);
    1:     if (isMap) {
    1:       aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
    1:     }
    1:   }
    1:   return nsGenericHTMLElement::PreHandleEvent(aVisitor);
    1: }
    1: 
    1: PRBool
14348: nsHTMLImageElement::IsHTMLFocusable(PRBool *aIsFocusable, PRInt32 *aTabIndex)
    1: {
    1:   PRInt32 tabIndex;
    1:   GetTabIndex(&tabIndex);
    1: 
    1:   if (IsInDoc()) {
    1:     nsAutoString usemap;
    1:     GetUseMap(usemap);
    1:     // XXXbz which document should this be using?  sXBL/XBL2 issue!  I
    1:     // think that GetOwnerDoc() is right, since we don't want to
    1:     // assume stuff about the document we're bound to.
    1:     nsCOMPtr<nsIDOMHTMLMapElement> imageMap =
    1:       nsImageMapUtils::FindImageMap(GetOwnerDoc(), usemap);
    1:     if (imageMap) {
    1:       if (aTabIndex) {
    1:         // Use tab index on individual map areas
    1:         *aTabIndex = (sTabFocusModel & eTabFocus_linksMask)? 0 : -1;
    1:       }
    1:       // Image map is not focusable itself, but flag as tabbable
    1:       // so that image map areas get walked into.
14348:       *aIsFocusable = PR_FALSE;
14792: 
14792:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   if (aTabIndex) {
    1:     // Can be in tab order if tabindex >=0 and form controls are tabbable.
    1:     *aTabIndex = (sTabFocusModel & eTabFocus_formElementsMask)? tabIndex : -1;
    1:   }
    1: 
14348:   *aIsFocusable = tabIndex >= 0 ||
14348:                   HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex);
14348: 
14348:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsHTMLImageElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                             nsIAtom* aPrefix, const nsAString& aValue,
    1:                             PRBool aNotify)
    1: {
    1:   // If we plan to call LoadImage, we want to do it first so that the
    1:   // image load kicks off _before_ the reflow triggered by the SetAttr.  But if
    1:   // aNotify is false, we are coming from the parser or some such place; we'll
    1:   // get bound after all the attributes have been set, so we'll do the
    1:   // image load from BindToTree.  Skip the LoadImage call in that case.
    1:   if (aNotify &&
    1:       aNameSpaceID == kNameSpaceID_None && aName == nsGkAtoms::src) {
    1: 
    1:     // If caller is not chrome and dom.disable_image_src_set is true,
    1:     // prevent setting image.src by exiting early
    1:     if (nsContentUtils::GetBoolPref("dom.disable_image_src_set") &&
    1:         !nsContentUtils::IsCallerChrome()) {
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsCOMPtr<imgIRequest> oldCurrentRequest = mCurrentRequest;
    1: 
    1:     // Force image loading here, so that we'll try to load the image from
 3410:     // network if it's set to be not cacheable...  If we change things so that
 3410:     // the state gets in nsGenericElement's attr-setting happen around this
 3410:     // LoadImage call, we could start passing PR_FALSE instead of aNotify
 3410:     // here.
    1:     LoadImage(aValue, PR_TRUE, aNotify);
    1: 
    1:     if (mCurrentRequest && !mPendingRequest &&
    1:         oldCurrentRequest != mCurrentRequest) {
    1:       // We have a current request, and it's not the same one as we used
    1:       // to have, and we have no pending request.  So imglib already had
    1:       // that image.  Reset the animation on it -- see bug 210001
    1:       nsCOMPtr<imgIContainer> container;
    1:       mCurrentRequest->GetImage(getter_AddRefs(container));
    1:       if (container) {
    1:         container->ResetAnimation();
    1:       }
    1:     }
    1:   }
    1:     
    1:   return nsGenericHTMLElement::SetAttr(aNameSpaceID, aName, aPrefix, aValue,
    1:                                        aNotify);
    1: }
    1: 
    1: nsresult
22743: nsHTMLImageElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
22743:                               PRBool aNotify)
22743: {
22743:   if (aNameSpaceID == kNameSpaceID_None && aAttribute == nsGkAtoms::src) {
22743:     CancelImageRequests(aNotify);
22743:   }
22743: 
22743:   return nsGenericHTMLElement::UnsetAttr(aNameSpaceID, aAttribute, aNotify);
22743: }
22743: 
22743: nsresult
    1: nsHTMLImageElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                                nsIContent* aBindingParent,
    1:                                PRBool aCompileEventHandlers)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
    1:                                                  aBindingParent,
    1:                                                  aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
28627:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::src)) {
28627:     ClearBrokenState();
35156:     // If loading is temporarily disabled, don't even launch MaybeLoadImage.
35156:     // Otherwise MaybeLoadImage may run later when someone has reenabled
35156:     // loading.
35156:     if (LoadingEnabled()) {
28627:       nsContentUtils::AddScriptRunner(
28627:         new nsRunnableMethod<nsHTMLImageElement>(this,
28627:                                                  &nsHTMLImageElement::MaybeLoadImage));
    1:     }
35156:   }
    1: 
    1:   return rv;
    1: }
    1: 
28627: void
28627: nsHTMLImageElement::MaybeLoadImage()
28627: {
28627:   // Our base URI may have changed; claim that our URI changed, and the
28627:   // nsImageLoadingContent will decide whether a new image load is warranted.
28627:   // Note, check LoadingEnabled() after LoadImage call.
28627:   nsAutoString uri;
28627:   if (GetAttr(kNameSpaceID_None, nsGkAtoms::src, uri) &&
28627:       (NS_FAILED(LoadImage(uri, PR_FALSE, PR_TRUE)) ||
28627:        !LoadingEnabled())) {
28627:     CancelImageRequests(PR_TRUE);
28627:   }
28627: }
28627: 
    1: PRInt32
    1: nsHTMLImageElement::IntrinsicState() const
    1: {
    1:   return nsGenericHTMLElement::IntrinsicState() |
    1:     nsImageLoadingContent::ImageState();
    1: }
    1: 
    1: NS_IMETHODIMP
 8947: nsHTMLImageElement::Initialize(nsISupports* aOwner, JSContext* aContext,
 8947:                                JSObject *aObj, PRUint32 argc, jsval *argv)
    1: {
    1:   if (argc <= 0) {
    1:     // Nothing to do here if we don't get any arguments.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // The first (optional) argument is the width of the image
    1:   int32 width;
    1:   JSBool ret = JS_ValueToInt32(aContext, argv[0], &width);
    1:   NS_ENSURE_TRUE(ret, NS_ERROR_INVALID_ARG);
    1: 
 3233:   nsresult rv = SetIntAttr(nsGkAtoms::width, static_cast<PRInt32>(width));
    1: 
    1:   if (NS_SUCCEEDED(rv) && (argc > 1)) {
    1:     // The second (optional) argument is the height of the image
    1:     int32 height;
    1:     ret = JS_ValueToInt32(aContext, argv[1], &height);
    1:     NS_ENSURE_TRUE(ret, NS_ERROR_INVALID_ARG);
    1: 
 3233:     rv = SetIntAttr(nsGkAtoms::height, static_cast<PRInt32>(height));
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLImageElement::GetNaturalHeight(PRInt32* aNaturalHeight)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNaturalHeight);
    1: 
    1:   *aNaturalHeight = 0;
    1: 
    1:   if (!mCurrentRequest) {
    1:     return NS_OK;
    1:   }
    1:   
    1:   nsCOMPtr<imgIContainer> image;
    1:   mCurrentRequest->GetImage(getter_AddRefs(image));
    1:   if (!image) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   image->GetHeight(aNaturalHeight);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLImageElement::GetNaturalWidth(PRInt32* aNaturalWidth)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNaturalWidth);
    1: 
    1:   *aNaturalWidth = 0;
    1: 
    1:   if (!mCurrentRequest) {
    1:     return NS_OK;
    1:   }
    1:   
    1:   nsCOMPtr<imgIContainer> image;
    1:   mCurrentRequest->GetImage(getter_AddRefs(image));
    1:   if (!image) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   image->GetWidth(aNaturalWidth);
    1:   return NS_OK;
    1: }
    1: 
    1: 
