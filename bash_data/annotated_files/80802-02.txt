    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
77154:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsCOMPtr.h"
    1: #include "nsTableRowGroupFrame.h"
    1: #include "nsTableRowFrame.h"
    1: #include "nsTableFrame.h"
    1: #include "nsTableCellFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsStyleContext.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsIContent.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIPresShell.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsDisplayList.h"
    1: 
    1: #include "nsCellMap.h"//table cell navigation
    1: 
39965: using namespace mozilla;
39965: 
    1: nsTableRowGroupFrame::nsTableRowGroupFrame(nsStyleContext* aContext):
    1:   nsHTMLContainerFrame(aContext)
    1: {
80486:   SetRepeatable(false);
    1: }
    1: 
    1: nsTableRowGroupFrame::~nsTableRowGroupFrame()
    1: {
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsTableRowGroupFrame)
23554:   NS_QUERYFRAME_ENTRY(nsTableRowGroupFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsHTMLContainerFrame)
    1: 
    1: PRInt32
    1: nsTableRowGroupFrame::GetRowCount()
    1: {
32866: #ifdef DEBUG
32866:   for (nsFrameList::Enumerator e(mFrames); !e.AtEnd(); e.Next()) {
32866:     NS_ASSERTION(e.get()->GetStyleDisplay()->mDisplay ==
32866:                    NS_STYLE_DISPLAY_TABLE_ROW,
32866:                  "Unexpected display");
32866:     NS_ASSERTION(e.get()->GetType() == nsGkAtoms::tableRowFrame,
32866:                  "Unexpected frame type");
32866:   }
32866: #endif
    1:   
32866:   return mFrames.GetLength();
    1: }
    1: 
    1: PRInt32 nsTableRowGroupFrame::GetStartRowIndex()
    1: {
    1:   PRInt32 result = -1;
32866:   if (mFrames.NotEmpty()) {
32866:     NS_ASSERTION(mFrames.FirstChild()->GetType() == nsGkAtoms::tableRowFrame,
32866:                  "Unexpected frame type");
32866:     result = static_cast<nsTableRowFrame*>(mFrames.FirstChild())->GetRowIndex();
    1:   }
    1:   // if the row group doesn't have any children, get it the hard way
    1:   if (-1 == result) {
    1:     nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
    1:     if (tableFrame) {
37262:       return tableFrame->GetStartRowIndex(this);
    1:     }
    1:   }
    1:       
    1:   return result;
    1: }
    1: 
    1: void  nsTableRowGroupFrame::AdjustRowIndices(PRInt32 aRowIndex,
    1:                                              PRInt32 anAdjustment)
    1: {
77154:   nsIFrame* rowFrame = GetFirstPrincipalChild();
    1:   for ( ; rowFrame; rowFrame = rowFrame->GetNextSibling()) {
    1:     if (NS_STYLE_DISPLAY_TABLE_ROW==rowFrame->GetStyleDisplay()->mDisplay) {
    1:       PRInt32 index = ((nsTableRowFrame*)rowFrame)->GetRowIndex();
    1:       if (index >= aRowIndex)
    1:         ((nsTableRowFrame *)rowFrame)->SetRowIndex(index+anAdjustment);
    1:     }
    1:   }
    1: }
    1: nsresult
    1: nsTableRowGroupFrame::InitRepeatedFrame(nsPresContext*        aPresContext,
    1:                                         nsTableRowGroupFrame* aHeaderFooterFrame)
    1: {
    1:   nsTableRowFrame* copyRowFrame = GetFirstRow();
    1:   nsTableRowFrame* originalRowFrame = aHeaderFooterFrame->GetFirstRow();
    1:   AddStateBits(NS_REPEATED_ROW_OR_ROWGROUP);
    1:   while (copyRowFrame && originalRowFrame) {
    1:     copyRowFrame->AddStateBits(NS_REPEATED_ROW_OR_ROWGROUP);
    1:     int rowIndex = originalRowFrame->GetRowIndex();
    1:     copyRowFrame->SetRowIndex(rowIndex);
    1: 
    1:     // For each table cell frame set its column index
    1:     nsTableCellFrame* originalCellFrame = originalRowFrame->GetFirstCell();
    1:     nsTableCellFrame* copyCellFrame     = copyRowFrame->GetFirstCell();
    1:     while (copyCellFrame && originalCellFrame) {
    1:       NS_ASSERTION(originalCellFrame->GetContent() == copyCellFrame->GetContent(),
    1:                    "cell frames have different content");
    1:       PRInt32 colIndex;
    1:       originalCellFrame->GetColIndex(colIndex);
    1:       copyCellFrame->SetColIndex(colIndex);
    1:         
    1:       // Move to the next cell frame
    1:       copyCellFrame     = copyCellFrame->GetNextCell();
    1:       originalCellFrame = originalCellFrame->GetNextCell();
    1:     }
    1:     
    1:     // Move to the next row frame
    1:     originalRowFrame = originalRowFrame->GetNextRow();
    1:     copyRowFrame = copyRowFrame->GetNextRow();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
13961: /**
13961:  * We need a custom display item for table row backgrounds. This is only used
13961:  * when the table row is the root of a stacking context (e.g., has 'opacity').
13961:  * Table row backgrounds can extend beyond the row frame bounds, when
13961:  * the row contains row-spanning cells.
13961:  */
13961: class nsDisplayTableRowGroupBackground : public nsDisplayTableItem {
13961: public:
51260:   nsDisplayTableRowGroupBackground(nsDisplayListBuilder* aBuilder,
51260:                                    nsTableRowGroupFrame* aFrame) :
51260:     nsDisplayTableItem(aBuilder, aFrame) {
13961:     MOZ_COUNT_CTOR(nsDisplayTableRowGroupBackground);
13961:   }
13961: #ifdef NS_BUILD_REFCNT_LOGGING
13961:   virtual ~nsDisplayTableRowGroupBackground() {
13961:     MOZ_COUNT_DTOR(nsDisplayTableRowGroupBackground);
13961:   }
13961: #endif
    1: 
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
68481:                      nsRenderingContext* aCtx);
13961: 
47732:   NS_DISPLAY_DECL_NAME("TableRowGroupBackground", TYPE_TABLE_ROW_GROUP_BACKGROUND)
13961: };
13961: 
13961: void
13961: nsDisplayTableRowGroupBackground::Paint(nsDisplayListBuilder* aBuilder,
68481:                                         nsRenderingContext* aCtx) {
13961:   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(mFrame);
13961: 
    1:   TableBackgroundPainter painter(tableFrame,
    1:                                  TableBackgroundPainter::eOrigin_TableRowGroup,
13961:                                  mFrame->PresContext(), *aCtx,
51261:                                  mVisibleRect, ToReferenceFrame(),
32425:                                  aBuilder->GetBackgroundPaintFlags());
13961:   painter.PaintRowGroup(static_cast<nsTableRowGroupFrame*>(mFrame));
    1: }
    1: 
    1: // Handle the child-traversal part of DisplayGenericTablePart
    1: static nsresult
    1: DisplayRows(nsDisplayListBuilder* aBuilder, nsFrame* aFrame,
    1:             const nsRect& aDirtyRect, const nsDisplayListSet& aLists)
    1: {
    1:   nscoord overflowAbove;
 3233:   nsTableRowGroupFrame* f = static_cast<nsTableRowGroupFrame*>(aFrame);
    1:   // Don't try to use the row cursor if we have to descend into placeholders;
    1:   // we might have rows containing placeholders, where the row's overflow
    1:   // area doesn't intersect the dirty rect but we need to descend into the row
58774:   // to see out of flows.
58774:   // Note that we really want to check ShouldDescendIntoFrame for all
58774:   // the rows in |f|, but that's exactly what we're trying to avoid, so we
58774:   // approximate it by checking it for |f|: if it's true for any row
58774:   // in |f| then it's true for |f| itself.
58774:   nsIFrame* kid = aBuilder->ShouldDescendIntoFrame(f) ?
58774:     nsnull : f->GetFirstRowContaining(aDirtyRect.y, &overflowAbove);
    1:   
    1:   if (kid) {
    1:     // have a cursor, use it
    1:     while (kid) {
    1:       if (kid->GetRect().y - overflowAbove >= aDirtyRect.YMost())
    1:         break;
    1:       nsresult rv = f->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:       kid = kid->GetNextSibling();
    1:     }
    1:     return NS_OK;
    1:   }
    1:   
    1:   // No cursor. Traverse children the hard way and build a cursor while we're at it
    1:   nsTableRowGroupFrame::FrameCursorData* cursor = f->SetupRowCursor();
77154:   kid = f->GetFirstPrincipalChild();
    1:   while (kid) {
    1:     nsresult rv = f->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
    1:     if (NS_FAILED(rv)) {
    1:       f->ClearRowCursor();
    1:       return rv;
    1:     }
    1:     
    1:     if (cursor) {
    1:       if (!cursor->AppendFrame(kid)) {
    1:         f->ClearRowCursor();
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:     }
    1:   
    1:     kid = kid->GetNextSibling();
    1:   }
    1:   if (cursor) {
    1:     cursor->FinishBuildingCursor();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTableRowGroupFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                        const nsRect&           aDirtyRect,
    1:                                        const nsDisplayListSet& aLists)
    1: {
    1:   if (!IsVisibleInSelection(aBuilder))
    1:     return NS_OK;
    1: 
79445:   bool isRoot = aBuilder->IsAtRootOfPseudoStackingContext();
13961:   nsDisplayTableItem* item = nsnull;
    1:   if (isRoot) {
    1:     // This background is created regardless of whether this frame is
    1:     // visible or not. Visibility decisions are delegated to the
    1:     // table background painter.
51260:     item = new (aBuilder) nsDisplayTableRowGroupBackground(aBuilder, this);
13961:     nsresult rv = aLists.BorderBackground()->AppendNewToTop(item);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   
    1:   return nsTableFrame::DisplayGenericTablePart(aBuilder, this, aDirtyRect,
13961:                                                aLists, item, DisplayRows);
    1: }
    1: 
    1: PRIntn
    1: nsTableRowGroupFrame::GetSkipSides() const
    1: {
    1:   PRIntn skip = 0;
    1:   if (nsnull != GetPrevInFlow()) {
    1:     skip |= 1 << NS_SIDE_TOP;
    1:   }
    1:   if (nsnull != GetNextInFlow()) {
    1:     skip |= 1 << NS_SIDE_BOTTOM;
    1:   }
    1:   return skip;
    1: }
    1: 
    1: // Position and size aKidFrame and update our reflow state. The origin of
    1: // aKidRect is relative to the upper-left origin of our frame
    1: void 
    1: nsTableRowGroupFrame::PlaceChild(nsPresContext*         aPresContext,
    1:                                  nsRowGroupReflowState& aReflowState,
    1:                                  nsIFrame*              aKidFrame,
11384:                                  nsHTMLReflowMetrics&   aDesiredSize,
13144:                                  const nsRect&          aOriginalKidRect,
55037:                                  const nsRect&          aOriginalKidVisualOverflow)
    1: {
79445:   bool isFirstReflow =
11384:     (aKidFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) != 0;
11384: 
    1:   // Place and size the child
11384:   FinishReflowChild(aKidFrame, aPresContext, nsnull, aDesiredSize, 0,
11384:                     aReflowState.y, 0);
11384: 
13144:   nsTableFrame::InvalidateFrame(aKidFrame, aOriginalKidRect,
55037:                                 aOriginalKidVisualOverflow, isFirstReflow);
    1: 
    1:   // Adjust the running y-offset
    1:   aReflowState.y += aDesiredSize.height;
    1: 
    1:   // If our height is constrained then update the available height
    1:   if (NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height) {
    1:     aReflowState.availSize.height -= aDesiredSize.height;
    1:   }
    1: }
    1: 
    1: void
    1: nsTableRowGroupFrame::InitChildReflowState(nsPresContext&     aPresContext, 
79445:                                            bool               aBorderCollapse,
    1:                                            nsHTMLReflowState& aReflowState)                                    
    1: {
    1:   nsMargin collapseBorder;
    1:   nsMargin padding(0,0,0,0);
    1:   nsMargin* pCollapseBorder = nsnull;
    1:   if (aBorderCollapse) {
26583:     nsTableRowFrame *rowFrame = do_QueryFrame(aReflowState.frame);
26583:     if (rowFrame) {
    1:       pCollapseBorder = rowFrame->GetBCBorderWidth(collapseBorder);
    1:     }
    1:   }
    1:   aReflowState.Init(&aPresContext, -1, -1, pCollapseBorder, &padding);
    1: }
    1: 
    1: static void
    1: CacheRowHeightsForPrinting(nsPresContext*   aPresContext,
    1:                            nsTableRowFrame* aFirstRow)
    1: {
    1:   for (nsTableRowFrame* row = aFirstRow; row; row = row->GetNextRow()) {
    1:     if (!row->GetPrevInFlow()) {
80486:       row->SetHasUnpaginatedHeight(true);
    1:       row->SetUnpaginatedHeight(aPresContext, row->GetSize().height);
    1:     }
    1:   }
    1: }
    1: 
55038: nsresult
    1: nsTableRowGroupFrame::ReflowChildren(nsPresContext*         aPresContext,
    1:                                      nsHTMLReflowMetrics&   aDesiredSize,
    1:                                      nsRowGroupReflowState& aReflowState,
    1:                                      nsReflowStatus&        aStatus,
79445:                                      bool*                aPageBreakBeforeEnd)
    1: {
    1:   if (aPageBreakBeforeEnd) 
80486:     *aPageBreakBeforeEnd = false;
    1: 
    1:   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
    1:   if (!tableFrame)
    1:     ABORT1(NS_ERROR_NULL_POINTER);
    1: 
    1:   nsresult rv = NS_OK;
    1: 
79445:   bool borderCollapse = tableFrame->IsBorderCollapse();
    1: 
    1:   nscoord cellSpacingY = tableFrame->GetCellSpacingY();
    1: 
    1:   // XXXldb Should we really be checking this rather than available height?
    1:   // (Think about multi-column layout!)
79445:   bool isPaginated = aPresContext->IsPaginated() && 
42270:                        NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height;
    1: 
79445:   bool haveRow = false;
79445:   bool reflowAllKids = aReflowState.reflowState.ShouldReflowAllKids() ||
    1:                          tableFrame->IsGeometryDirty();
79445:   bool needToCalcRowHeights = reflowAllKids;
    1: 
14430:   nsIFrame *prevKidFrame = nsnull;
32842:   for (nsIFrame* kidFrame = mFrames.FirstChild(); kidFrame;
14430:        prevKidFrame = kidFrame, kidFrame = kidFrame->GetNextSibling()) {
26583:     nsTableRowFrame *rowFrame = do_QueryFrame(kidFrame);
26583:     if (!rowFrame) {
    1:       // XXXldb nsCSSFrameConstructor needs to enforce this!
    1:       NS_NOTREACHED("yikes, a non-row child");
    1:       continue;
    1:     }
    1: 
80486:     haveRow = true;
    1: 
    1:     // Reflow the row frame
    1:     if (reflowAllKids ||
 1158:         NS_SUBTREE_DIRTY(kidFrame) ||
    1:         (aReflowState.reflowState.mFlags.mSpecialHeightReflow &&
    1:          (isPaginated || (kidFrame->GetStateBits() &
    1:                           NS_FRAME_CONTAINS_RELATIVE_HEIGHT)))) {
11384:       nsRect oldKidRect = kidFrame->GetRect();
55037:       nsRect oldKidVisualOverflow = kidFrame->GetVisualOverflowRect();
    1: 
    1:       // XXXldb We used to only pass aDesiredSize.mFlags through for the
    1:       // incremental reflow codepath.
    1:       nsHTMLReflowMetrics desiredSize(aDesiredSize.mFlags);
    1:       desiredSize.width = desiredSize.height = 0;
    1:   
    1:       // Reflow the child into the available space, giving it as much height as
    1:       // it wants. We'll deal with splitting later after we've computed the row
    1:       // heights, taking into account cells with row spans...
    1:       nsSize kidAvailSize(aReflowState.availSize.width, NS_UNCONSTRAINEDSIZE);
    1:       nsHTMLReflowState kidReflowState(aPresContext, aReflowState.reflowState,
    1:                                        kidFrame, kidAvailSize,
80486:                                        -1, -1, false);
    1:       InitChildReflowState(*aPresContext, borderCollapse, kidReflowState);
    1: 
    1:       // This can indicate that columns were resized.
    1:       if (aReflowState.reflowState.mFlags.mHResize)
80486:         kidReflowState.mFlags.mHResize = true;
    1:      
32842:       NS_ASSERTION(kidFrame == mFrames.FirstChild() || prevKidFrame, 
14430:                    "If we're not on the first frame, we should have a "
14430:                    "previous sibling...");
14430:       // If prev row has nonzero YMost, then we can't be at the top of the page
14430:       if (prevKidFrame && prevKidFrame->GetRect().YMost() > 0) {
80486:         kidReflowState.mFlags.mIsTopOfPage = false;
    1:       }
    1: 
    1:       rv = ReflowChild(kidFrame, aPresContext, desiredSize, kidReflowState,
11384:                        0, aReflowState.y, NS_FRAME_INVALIDATE_ON_MOVE,
11384:                        aStatus);
    1: 
    1:       // Place the child
11384:       PlaceChild(aPresContext, aReflowState, kidFrame, desiredSize,
55037:                  oldKidRect, oldKidVisualOverflow);
    1:       aReflowState.y += cellSpacingY;
    1: 
    1:       if (!reflowAllKids) {
    1:         if (IsSimpleRowFrame(aReflowState.tableFrame, kidFrame)) {
    1:           // Inform the row of its new height.
26583:           rowFrame->DidResize();
    1:           // the overflow area may have changed inflate the overflow area
19446:           const nsStylePosition *stylePos = GetStylePosition();
19446:           nsStyleUnit unit = stylePos->mHeight.GetUnit();
19446:           if (aReflowState.tableFrame->IsAutoHeight() &&
19446:               unit != eStyleUnit_Coord) {
    1:             // Because other cells in the row may need to be aligned
    1:             // differently, repaint the entire row
    1:             nsRect kidRect(0, aReflowState.y,
    1:                            desiredSize.width, desiredSize.height);
    1:             Invalidate(kidRect);
    1:             
    1:             // Invalidate the area we're offseting. Note that we only
    1:             // repaint within our existing frame bounds.
    1:             if (kidRect.YMost() < mRect.height) {
    1:               nsRect  dirtyRect(0, kidRect.YMost(),
    1:                                 mRect.width, mRect.height - kidRect.YMost());
    1:               Invalidate(dirtyRect);
    1:             }
    1:           }
11384:           else if (oldKidRect.height != desiredSize.height)
80486:             needToCalcRowHeights = true;
    1:         } else {
80486:           needToCalcRowHeights = true;
    1:         }
    1:       }
    1: 
    1:       if (isPaginated && aPageBreakBeforeEnd && !*aPageBreakBeforeEnd) {
26583:         nsTableRowFrame* nextRow = rowFrame->GetNextRow();
    1:         if (nextRow) {
42270:           *aPageBreakBeforeEnd = nsTableFrame::PageBreakAfter(kidFrame, nextRow);
    1:         }
    1:       }
    1:     } else {
    1:       SlideChild(aReflowState, kidFrame);
    1: 
    1:       // Adjust the running y-offset so we know where the next row should be placed
    1:       nscoord height = kidFrame->GetSize().height + cellSpacingY;
    1:       aReflowState.y += height;
    1: 
    1:       if (NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height) {
    1:         aReflowState.availSize.height -= height;
    1:       }
    1:     }
55039:     ConsiderChildOverflow(aDesiredSize.mOverflowAreas, kidFrame);
    1:   }
    1: 
    1:   if (haveRow)
    1:     aReflowState.y -= cellSpacingY;
    1: 
    1:   // Return our desired rect
    1:   aDesiredSize.width = aReflowState.reflowState.availableWidth;
    1:   aDesiredSize.height = aReflowState.y;
    1: 
    1:   if (aReflowState.reflowState.mFlags.mSpecialHeightReflow) {
    1:     DidResizeRows(aDesiredSize);
    1:     if (isPaginated) {
    1:       CacheRowHeightsForPrinting(aPresContext, GetFirstRow());
    1:     }
    1:   }
    1:   else if (needToCalcRowHeights) {
    1:     CalculateRowHeights(aPresContext, aDesiredSize, aReflowState.reflowState);
    1:     if (!reflowAllKids) {
    1:       // Because we don't know what changed repaint everything.
    1:       // XXX We should change CalculateRowHeights() to return the bounding
    1:       // rect of what changed. Or whether anything moved or changed size...
    1:       nsRect  dirtyRect(0, 0, mRect.width, mRect.height);
    1:       Invalidate(dirtyRect);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsTableRowFrame*  
    1: nsTableRowGroupFrame::GetFirstRow() 
    1: {
32842:   for (nsIFrame* childFrame = mFrames.FirstChild(); childFrame;
    1:        childFrame = childFrame->GetNextSibling()) {
26583:     nsTableRowFrame *rowFrame = do_QueryFrame(childFrame);
26583:     if (rowFrame) {
26583:       return rowFrame;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: 
    1: struct RowInfo {
    1:   RowInfo() { height = pctHeight = hasStyleHeight = hasPctHeight = isSpecial = 0; }
    1:   unsigned height;       // content height or fixed height, excluding pct height
    1:   unsigned pctHeight:29; // pct height
    1:   unsigned hasStyleHeight:1; 
    1:   unsigned hasPctHeight:1; 
    1:   unsigned isSpecial:1; // there is no cell originating in the row with rowspan=1 and there are at
    1:                         // least 2 cells spanning the row and there is no style height on the row
    1: };
    1: 
    1: static void
    1: UpdateHeights(RowInfo& aRowInfo,
    1:               nscoord  aAdditionalHeight,
    1:               nscoord& aTotal,
    1:               nscoord& aUnconstrainedTotal)
    1: {
    1:   aRowInfo.height += aAdditionalHeight;
    1:   aTotal          += aAdditionalHeight;
    1:   if (!aRowInfo.hasStyleHeight) {
    1:     aUnconstrainedTotal += aAdditionalHeight;
    1:   }
    1: }
    1: 
    1: void 
    1: nsTableRowGroupFrame::DidResizeRows(nsHTMLReflowMetrics& aDesiredSize)
    1: {
    1:   // update the cells spanning rows with their new heights
    1:   // this is the place where all of the cells in the row get set to the height of the row
    1:   // Reset the overflow area
55039:   aDesiredSize.mOverflowAreas.Clear();
    1:   for (nsTableRowFrame* rowFrame = GetFirstRow();
    1:        rowFrame; rowFrame = rowFrame->GetNextRow()) {
    1:     rowFrame->DidResize();
55039:     ConsiderChildOverflow(aDesiredSize.mOverflowAreas, rowFrame);
    1:   }
    1: }
    1: 
    1: // This calculates the height of all the rows and takes into account 
    1: // style height on the row group, style heights on rows and cells, style heights on rowspans. 
    1: // Actual row heights will be adjusted later if the table has a style height.
    1: // Even if rows don't change height, this method must be called to set the heights of each
    1: // cell in the row to the height of its row.
    1: void 
    1: nsTableRowGroupFrame::CalculateRowHeights(nsPresContext*           aPresContext, 
    1:                                           nsHTMLReflowMetrics&     aDesiredSize,
    1:                                           const nsHTMLReflowState& aReflowState)
    1: {
    1:   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
    1:   if (!tableFrame) return;
    1: 
79445:   bool isPaginated = aPresContext->IsPaginated();
    1: 
    1:   // all table cells have the same top and bottom margins, namely cellSpacingY
    1:   nscoord cellSpacingY = tableFrame->GetCellSpacingY();
    1: 
    1:   PRInt32 numEffCols = tableFrame->GetEffectiveColCount();
    1: 
    1:   PRInt32 startRowIndex = GetStartRowIndex();
    1:   // find the row corresponding to the row index we just found
    1:   nsTableRowFrame* startRowFrame = GetFirstRow();
    1: 
    1:   if (!startRowFrame) return;
    1: 
    1:   // the current row group height is the y origin of the 1st row we are about to calculated a height for
    1:   nscoord startRowGroupHeight = startRowFrame->GetPosition().y;
    1: 
    1:   PRInt32 numRows = GetRowCount() - (startRowFrame->GetRowIndex() - GetStartRowIndex());
    1:   // collect the current height of each row.  nscoord* rowHeights = nsnull;
    1:   if (numRows <= 0)
    1:     return;
    1: 
    1:   nsTArray<RowInfo> rowInfo;
    1:   if (!rowInfo.AppendElements(numRows)) {
    1:     return;
    1:   }
    1: 
79445:   bool    hasRowSpanningCell = false;
    1:   nscoord heightOfRows = 0;
    1:   nscoord heightOfUnStyledRows = 0;
    1:   // Get the height of each row without considering rowspans. This will be the max of 
    1:   // the largest desired height of each cell, the largest style height of each cell, 
    1:   // the style height of the row.
    1:   nscoord pctHeightBasis = GetHeightBasis(aReflowState);
    1:   PRInt32 rowIndex; // the index in rowInfo, not among the rows in the row group
    1:   nsTableRowFrame* rowFrame;
    1:   for (rowFrame = startRowFrame, rowIndex = 0; rowFrame; rowFrame = rowFrame->GetNextRow(), rowIndex++) {
    1:     nscoord nonPctHeight = rowFrame->GetContentHeight();
    1:     if (isPaginated) {
32531:       nonPctHeight = NS_MAX(nonPctHeight, rowFrame->GetSize().height);
    1:     }
    1:     if (!rowFrame->GetPrevInFlow()) {
    1:       if (rowFrame->HasPctHeight()) {
80486:         rowInfo[rowIndex].hasPctHeight = true;
    1:         rowInfo[rowIndex].pctHeight = rowFrame->GetHeight(pctHeightBasis);
    1:       }
    1:       rowInfo[rowIndex].hasStyleHeight = rowFrame->HasStyleHeight();
32531:       nonPctHeight = NS_MAX(nonPctHeight, rowFrame->GetFixedHeight());
    1:     }
    1:     UpdateHeights(rowInfo[rowIndex], nonPctHeight, heightOfRows, heightOfUnStyledRows);
    1: 
    1:     if (!rowInfo[rowIndex].hasStyleHeight) {
    1:       if (isPaginated || tableFrame->HasMoreThanOneCell(rowIndex + startRowIndex)) {
80486:         rowInfo[rowIndex].isSpecial = true;
    1:         // iteratate the row's cell frames to see if any do not have rowspan > 1
    1:         nsTableCellFrame* cellFrame = rowFrame->GetFirstCell();
    1:         while (cellFrame) {
    1:           PRInt32 rowSpan = tableFrame->GetEffectiveRowSpan(rowIndex + startRowIndex, *cellFrame);
    1:           if (1 == rowSpan) { 
80486:             rowInfo[rowIndex].isSpecial = false;
    1:             break;
    1:           }
    1:           cellFrame = cellFrame->GetNextCell(); 
    1:         }
    1:       }
    1:     }
    1:     // See if a cell spans into the row. If so we'll have to do the next step
    1:     if (!hasRowSpanningCell) {
    1:       if (tableFrame->RowIsSpannedInto(rowIndex + startRowIndex, numEffCols)) {
80486:         hasRowSpanningCell = true;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (hasRowSpanningCell) {
    1:     // Get the height of cells with rowspans and allocate any extra space to the rows they span 
    1:     // iteratate the child frames and process the row frames among them
    1:     for (rowFrame = startRowFrame, rowIndex = 0; rowFrame; rowFrame = rowFrame->GetNextRow(), rowIndex++) {
    1:       // See if the row has an originating cell with rowspan > 1. We cannot determine this for a row in a 
    1:       // continued row group by calling RowHasSpanningCells, because the row's fif may not have any originating
    1:       // cells yet the row may have a continued cell which originates in it.
    1:       if (GetPrevInFlow() || tableFrame->RowHasSpanningCells(startRowIndex + rowIndex, numEffCols)) {
    1:         nsTableCellFrame* cellFrame = rowFrame->GetFirstCell();
    1:         // iteratate the row's cell frames 
    1:         while (cellFrame) {
    1:           PRInt32 rowSpan = tableFrame->GetEffectiveRowSpan(rowIndex + startRowIndex, *cellFrame);
    1:           if ((rowIndex + rowSpan) > numRows) {
    1:             // there might be rows pushed already to the nextInFlow
    1:             rowSpan = numRows - rowIndex;
    1:           }
    1:           if (rowSpan > 1) { // a cell with rowspan > 1, determine the height of the rows it spans
    1:             nscoord heightOfRowsSpanned = 0;
    1:             nscoord heightOfUnStyledRowsSpanned = 0;
    1:             nscoord numSpecialRowsSpanned = 0; 
    1:             nscoord cellSpacingTotal = 0;
    1:             PRInt32 spanX;
    1:             for (spanX = 0; spanX < rowSpan; spanX++) {
    1:               heightOfRowsSpanned += rowInfo[rowIndex + spanX].height;
    1:               if (!rowInfo[rowIndex + spanX].hasStyleHeight) {
    1:                 heightOfUnStyledRowsSpanned += rowInfo[rowIndex + spanX].height;
    1:               }
    1:               if (0 != spanX) {
    1:                 cellSpacingTotal += cellSpacingY;
    1:               }
    1:               if (rowInfo[rowIndex + spanX].isSpecial) {
    1:                 numSpecialRowsSpanned++;
    1:               }
    1:             } 
    1:             nscoord heightOfAreaSpanned = heightOfRowsSpanned + cellSpacingTotal;
    1:             // get the height of the cell 
    1:             nsSize cellFrameSize = cellFrame->GetSize();
    1:             nsSize cellDesSize = cellFrame->GetDesiredSize();
39018:             rowFrame->CalculateCellActualHeight(cellFrame, cellDesSize.height);
    1:             cellFrameSize.height = cellDesSize.height;
    1:             if (cellFrame->HasVerticalAlignBaseline()) {
    1:               // to ensure that a spanning cell with a long descender doesn't
    1:               // collide with the next row, we need to take into account the shift
    1:               // that will be done to align the cell on the baseline of the row.
    1:               cellFrameSize.height += rowFrame->GetMaxCellAscent() -
    1:                                       cellFrame->GetCellBaseline();
    1:             }
    1:   
    1:             if (heightOfAreaSpanned < cellFrameSize.height) {
    1:               // the cell's height is larger than the available space of the rows it
    1:               // spans so distribute the excess height to the rows affected
    1:               nscoord extra     = cellFrameSize.height - heightOfAreaSpanned;
    1:               nscoord extraUsed = 0;
    1:               if (0 == numSpecialRowsSpanned) {
    1:                 //NS_ASSERTION(heightOfRowsSpanned > 0, "invalid row span situation");
79445:                 bool haveUnStyledRowsSpanned = (heightOfUnStyledRowsSpanned > 0);
    1:                 nscoord divisor = (haveUnStyledRowsSpanned) 
    1:                                   ? heightOfUnStyledRowsSpanned : heightOfRowsSpanned;
    1:                 if (divisor > 0) {
    1:                   for (spanX = rowSpan - 1; spanX >= 0; spanX--) {
    1:                     if (!haveUnStyledRowsSpanned || !rowInfo[rowIndex + spanX].hasStyleHeight) {
    1:                       // The amount of additional space each row gets is proportional to its height
    1:                       float percent = ((float)rowInfo[rowIndex + spanX].height) / ((float)divisor);
    1:                     
    1:                       // give rows their percentage, except for the first row which gets the remainder
    1:                       nscoord extraForRow = (0 == spanX) ? extra - extraUsed  
    1:                                                          : NSToCoordRound(((float)(extra)) * percent);
32531:                       extraForRow = NS_MIN(extraForRow, extra - extraUsed);
    1:                       // update the row height
    1:                       UpdateHeights(rowInfo[rowIndex + spanX], extraForRow, heightOfRows, heightOfUnStyledRows);
    1:                       extraUsed += extraForRow;
    1:                       if (extraUsed >= extra) {
    1:                         NS_ASSERTION((extraUsed == extra), "invalid row height calculation");
    1:                         break;
    1:                       }
    1:                     }
    1:                   }
    1:                 }
    1:                 else {
    1:                   // put everything in the last row
    1:                   UpdateHeights(rowInfo[rowIndex + rowSpan - 1], extra, heightOfRows, heightOfUnStyledRows);
    1:                 }
    1:               }
    1:               else {
    1:                 // give the extra to the special rows
    1:                 nscoord numSpecialRowsAllocated = 0;
    1:                 for (spanX = rowSpan - 1; spanX >= 0; spanX--) {
    1:                   if (rowInfo[rowIndex + spanX].isSpecial) {
    1:                     // The amount of additional space each degenerate row gets is proportional to the number of them
    1:                     float percent = 1.0f / ((float)numSpecialRowsSpanned);
    1:                     
    1:                     // give rows their percentage, except for the first row which gets the remainder
    1:                     nscoord extraForRow = (numSpecialRowsSpanned - 1 == numSpecialRowsAllocated) 
    1:                                           ? extra - extraUsed  
    1:                                           : NSToCoordRound(((float)(extra)) * percent);
32531:                     extraForRow = NS_MIN(extraForRow, extra - extraUsed);
    1:                     // update the row height
    1:                     UpdateHeights(rowInfo[rowIndex + spanX], extraForRow, heightOfRows, heightOfUnStyledRows);
    1:                     extraUsed += extraForRow;
    1:                     if (extraUsed >= extra) {
    1:                       NS_ASSERTION((extraUsed == extra), "invalid row height calculation");
    1:                       break;
    1:                     }
    1:                   }
    1:                 }
    1:               }
    1:             } 
    1:           } // if (rowSpan > 1)
    1:           cellFrame = cellFrame->GetNextCell(); 
    1:         } // while (cellFrame)
    1:       } // if (tableFrame->RowHasSpanningCells(startRowIndex + rowIndex) {
    1:     } // while (rowFrame)
    1:   }
    1: 
    1:   // pct height rows have already got their content heights. Give them their pct heights up to pctHeightBasis
    1:   nscoord extra = pctHeightBasis - heightOfRows;
    1:   for (rowFrame = startRowFrame, rowIndex = 0; rowFrame && (extra > 0); rowFrame = rowFrame->GetNextRow(), rowIndex++) {
    1:     RowInfo& rInfo = rowInfo[rowIndex];
    1:     if (rInfo.hasPctHeight) {
    1:       nscoord rowExtra = (rInfo.pctHeight > rInfo.height)  
    1:                          ? rInfo.pctHeight - rInfo.height: 0;
32531:       rowExtra = NS_MIN(rowExtra, extra);
    1:       UpdateHeights(rInfo, rowExtra, heightOfRows, heightOfUnStyledRows);
    1:       extra -= rowExtra;
    1:     }
    1:   }
    1: 
79445:   bool styleHeightAllocation = false;
    1:   nscoord rowGroupHeight = startRowGroupHeight + heightOfRows + ((numRows - 1) * cellSpacingY);
    1:   // if we have a style height, allocate the extra height to unconstrained rows
 4166:   if ((aReflowState.ComputedHeight() > rowGroupHeight) && 
 4166:       (NS_UNCONSTRAINEDSIZE != aReflowState.ComputedHeight())) {
 4166:     nscoord extraComputedHeight = aReflowState.ComputedHeight() - rowGroupHeight;
    1:     nscoord extraUsed = 0;
79445:     bool haveUnStyledRows = (heightOfUnStyledRows > 0);
    1:     nscoord divisor = (haveUnStyledRows) 
    1:                       ? heightOfUnStyledRows : heightOfRows;
    1:     if (divisor > 0) {
80486:       styleHeightAllocation = true;
    1:       for (rowIndex = 0; rowIndex < numRows; rowIndex++) {
    1:         if (!haveUnStyledRows || !rowInfo[rowIndex].hasStyleHeight) {
    1:           // The amount of additional space each row gets is based on the
    1:           // percentage of space it occupies
    1:           float percent = ((float)rowInfo[rowIndex].height) / ((float)divisor);
    1:           // give rows their percentage, except for the last row which gets the remainder
    1:           nscoord extraForRow = (numRows - 1 == rowIndex) 
    1:                                 ? extraComputedHeight - extraUsed  
    1:                                 : NSToCoordRound(((float)extraComputedHeight) * percent);
32531:           extraForRow = NS_MIN(extraForRow, extraComputedHeight - extraUsed);
    1:           // update the row height
    1:           UpdateHeights(rowInfo[rowIndex], extraForRow, heightOfRows, heightOfUnStyledRows);
    1:           extraUsed += extraForRow;
    1:           if (extraUsed >= extraComputedHeight) {
    1:             NS_ASSERTION((extraUsed == extraComputedHeight), "invalid row height calculation");
    1:             break;
    1:           }
    1:         }
    1:       }
    1:     }
 4166:     rowGroupHeight = aReflowState.ComputedHeight();
    1:   }
    1: 
    1:   nscoord yOrigin = startRowGroupHeight;
    1:   // update the rows with their (potentially) new heights
    1:   for (rowFrame = startRowFrame, rowIndex = 0; rowFrame; rowFrame = rowFrame->GetNextRow(), rowIndex++) {
    1:     nsRect rowBounds = rowFrame->GetRect();
55037:     nsRect rowVisualOverflow = rowFrame->GetVisualOverflowRect();
    1: 
79445:     bool movedFrame = (rowBounds.y != yOrigin);  
    1:     nscoord rowHeight = (rowInfo[rowIndex].height > 0) ? rowInfo[rowIndex].height : 0;
    1:     
    1:     if (movedFrame || (rowHeight != rowBounds.height)) {
11384:       // Resize/move the row to its final size and position
11384:       if (movedFrame) {
51756:         rowFrame->InvalidateFrameSubtree();
11384:       }
11384:       
11384:       rowFrame->SetRect(nsRect(rowBounds.x, yOrigin, rowBounds.width,
11384:                                rowHeight));
11384: 
55037:       nsTableFrame::InvalidateFrame(rowFrame, rowBounds, rowVisualOverflow,
80486:                                     false);
    1:     }
    1:     if (movedFrame) {
    1:       nsTableFrame::RePositionViews(rowFrame);
11384:       // XXXbz we don't need to update our overflow area?
    1:     }
    1:     yOrigin += rowHeight + cellSpacingY;
    1:   }
    1: 
    1:   if (isPaginated && styleHeightAllocation) {
    1:     // since the row group has a style height, cache the row heights, so next in flows can honor them 
    1:     CacheRowHeightsForPrinting(aPresContext, GetFirstRow());
    1:   }
    1: 
    1:   DidResizeRows(aDesiredSize);
    1: 
    1:   aDesiredSize.height = rowGroupHeight; // Adjust our desired size
    1: }
    1: 
    1: nscoord
    1: nsTableRowGroupFrame::CollapseRowGroupIfNecessary(nscoord aYTotalOffset,
    1:                                                   nscoord aWidth)
    1: {
    1:   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
    1: 
    1:   const nsStyleVisibility* groupVis = GetStyleVisibility();
79445:   bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE == groupVis->mVisible);
    1:   if (collapseGroup) {
80486:     tableFrame->SetNeedToCollapse(true);
    1:   }
    1: 
55024:   nsOverflowAreas overflow;
    1: 
    1:   nsTableRowFrame* rowFrame= GetFirstRow();
79445:   bool didCollapse = false;
    1:   nscoord yGroupOffset = 0;
    1:   while (rowFrame) {
    1:     yGroupOffset += rowFrame->CollapseRowIfNecessary(yGroupOffset,
    1:                                                      aWidth, collapseGroup,
    1:                                                      didCollapse);
55024:     ConsiderChildOverflow(overflow, rowFrame);
    1:     rowFrame = rowFrame->GetNextRow();
    1:   }
    1: 
    1:   nsRect groupRect = GetRect();
11384:   nsRect oldGroupRect = groupRect;
55037:   nsRect oldGroupVisualOverflow = GetVisualOverflowRect();
11384:   
    1:   groupRect.height -= yGroupOffset;
    1:   if (didCollapse) {
    1:     // add back the cellspacing between rowgroups
    1:     groupRect.height += tableFrame->GetCellSpacingY();
    1:   }
    1: 
    1:   groupRect.y -= aYTotalOffset;
    1:   groupRect.width = aWidth;
11384: 
11384:   if (aYTotalOffset != 0) {
51756:     InvalidateFrameSubtree();
11384:   }
11384:   
    1:   SetRect(groupRect);
55024:   overflow.UnionAllWith(nsRect(0, 0, groupRect.width, groupRect.height));
55024:   FinishAndStoreOverflow(overflow, nsSize(groupRect.width, groupRect.height));
    1:   nsTableFrame::RePositionViews(this);
55037:   nsTableFrame::InvalidateFrame(this, oldGroupRect, oldGroupVisualOverflow,
80486:                                 false);
11384: 
    1:   return yGroupOffset;
    1: }
    1: 
18339: // Move a child that was skipped during a reflow.
    1: void
    1: nsTableRowGroupFrame::SlideChild(nsRowGroupReflowState& aReflowState,
    1:                                  nsIFrame*              aKidFrame)
    1: {
    1:   // Move the frame if we need to
    1:   nsPoint oldPosition = aKidFrame->GetPosition();
    1:   nsPoint newPosition = oldPosition;
    1:   newPosition.y = aReflowState.y;
    1:   if (oldPosition.y != newPosition.y) {
51756:     aKidFrame->InvalidateFrameSubtree();
    1:     aKidFrame->SetPosition(newPosition);
    1:     nsTableFrame::RePositionViews(aKidFrame);
51756:     aKidFrame->InvalidateFrameSubtree();
    1:   }
    1: }
    1: 
    1: // Create a continuing frame, add it to the child list, and then push it
    1: // and the frames that follow
    1: void 
    1: nsTableRowGroupFrame::CreateContinuingRowFrame(nsPresContext& aPresContext,
    1:                                                nsIFrame&      aRowFrame,
    1:                                                nsIFrame**     aContRowFrame)
    1: {
    1:   // XXX what is the row index?
80486:   if (!aContRowFrame) {NS_ASSERTION(false, "bad call"); return;}
    1:   // create the continuing frame which will create continuing cell frames
    1:   nsresult rv = aPresContext.PresShell()->FrameConstructor()->
    1:     CreateContinuingFrame(&aPresContext, &aRowFrame, this, aContRowFrame);
    1:   if (NS_FAILED(rv)) {
    1:     *aContRowFrame = nsnull;
    1:     return;
    1:   }
    1: 
    1:   // Add the continuing row frame to the child list
32841:   mFrames.InsertFrame(nsnull, &aRowFrame, *aContRowFrame);
    1: 
    1:   // Push the continuing row frame and the frames that follow
    1:   PushChildren(&aPresContext, *aContRowFrame, &aRowFrame);
    1: }
    1: 
    1: // Reflow the cells with rowspan > 1 which originate between aFirstRow
    1: // and end on or after aLastRow. aFirstTruncatedRow is the highest row on the
    1: // page that contains a cell which cannot split on this page 
    1: void
    1: nsTableRowGroupFrame::SplitSpanningCells(nsPresContext&           aPresContext,
    1:                                          const nsHTMLReflowState& aReflowState,
    1:                                          nsTableFrame&            aTable,
    1:                                          nsTableRowFrame&         aFirstRow, 
    1:                                          nsTableRowFrame&         aLastRow,  
79445:                                          bool                     aFirstRowIsTopOfPage,
 8536:                                          nscoord                  aSpanningRowBottom,
    1:                                          nsTableRowFrame*&        aContRow,
    1:                                          nsTableRowFrame*&        aFirstTruncatedRow,
    1:                                          nscoord&                 aDesiredHeight)
    1: {
 8536:   NS_ASSERTION(aSpanningRowBottom >= 0, "Can't split negative heights");
    1:   aFirstTruncatedRow = nsnull;
    1:   aDesiredHeight     = 0;
    1: 
    1:   PRInt32 lastRowIndex = aLastRow.GetRowIndex();
79445:   bool wasLast = false;
    1:   // Iterate the rows between aFirstRow and aLastRow
    1:   for (nsTableRowFrame* row = &aFirstRow; !wasLast; row = row->GetNextRow()) {
    1:     wasLast = (row == &aLastRow);
    1:     PRInt32 rowIndex = row->GetRowIndex();
    1:     nsPoint rowPos = row->GetPosition();
    1:     // Iterate the cells looking for those that have rowspan > 1
    1:     for (nsTableCellFrame* cell = row->GetFirstCell(); cell; cell = cell->GetNextCell()) {
    1:       PRInt32 rowSpan = aTable.GetEffectiveRowSpan(rowIndex, *cell);
    1:       // Only reflow rowspan > 1 cells which span aLastRow. Those which don't span aLastRow
    1:       // were reflowed correctly during the unconstrained height reflow. 
    1:       if ((rowSpan > 1) && (rowIndex + rowSpan > lastRowIndex)) {
    1:         nsReflowStatus status;
    1:         // Ask the row to reflow the cell to the height of all the rows it spans up through aLastRow
    1:         // aAvailHeight is the space between the row group start and the end of the page
 8536:         nscoord cellAvailHeight = aSpanningRowBottom - rowPos.y;
 8536:         NS_ASSERTION(cellAvailHeight >= 0, "No space for cell?");
79445:         bool isTopOfPage = (row == &aFirstRow) && aFirstRowIsTopOfPage;
    1:         nscoord cellHeight = row->ReflowCellFrame(&aPresContext, aReflowState,
    1:                                                   isTopOfPage, cell,
    1:                                                   cellAvailHeight, status);
32531:         aDesiredHeight = NS_MAX(aDesiredHeight, rowPos.y + cellHeight);
    1:         if (NS_FRAME_IS_COMPLETE(status)) {
    1:           if (cellHeight > cellAvailHeight) {
    1:             aFirstTruncatedRow = row;
    1:             if ((row != &aFirstRow) || !aFirstRowIsTopOfPage) {
    1:               // return now, since we will be getting another reflow after either (1) row is 
    1:               // moved to the next page or (2) the row group is moved to the next page
    1:               return;
    1:             }
    1:           }
    1:         }
    1:         else {
    1:           if (!aContRow) {
    1:             CreateContinuingRowFrame(aPresContext, aLastRow, (nsIFrame**)&aContRow);
    1:           }
    1:           if (aContRow) {
    1:             if (row != &aLastRow) {
    1:               // aContRow needs a continuation for cell, since cell spanned into aLastRow 
    1:               // but does not originate there
    1:               nsTableCellFrame* contCell = nsnull;
    1:               aPresContext.PresShell()->FrameConstructor()->
    1:                 CreateContinuingFrame(&aPresContext, cell, &aLastRow,
    1:                                       (nsIFrame**)&contCell);
    1:               PRInt32 colIndex;
    1:               cell->GetColIndex(colIndex);
    1:               aContRow->InsertCellFrame(contCell, colIndex);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: // Remove the next-in-flow of the row, its cells and their cell blocks. This 
    1: // is necessary in case the row doesn't need a continuation later on or needs 
    1: // a continuation which doesn't have the same number of cells that now exist. 
    1: void
    1: nsTableRowGroupFrame::UndoContinuedRow(nsPresContext*   aPresContext,
    1:                                        nsTableRowFrame* aRow)
    1: {
    1:   if (!aRow) return; // allow null aRow to avoid callers doing null checks
    1: 
    1:   // rowBefore was the prev-sibling of aRow's next-sibling before aRow was created
    1:   nsTableRowFrame* rowBefore = (nsTableRowFrame*)aRow->GetPrevInFlow();
30781:   NS_PRECONDITION(mFrames.ContainsFrame(rowBefore),
30781:                   "rowBefore not in our frame list?");
    1: 
30781:   nsAutoPtr<nsFrameList> overflows(StealOverflowFrames());
30781:   if (!rowBefore || !overflows || overflows->IsEmpty() ||
30781:       overflows->FirstChild() != aRow) {
30781:     NS_ERROR("invalid continued row");
    1:     return;
    1:   }
    1: 
30781:   // Destroy aRow, its cells, and their cell blocks. Cell blocks that have split
30781:   // will not have reflowed yet to pick up content from any overflow lines.
30781:   overflows->DestroyFrame(aRow);
    1: 
80802:   if (overflows->IsEmpty())
80802:     return;
30781:   // Put the overflow rows into our child list
30781:   mFrames.InsertFrames(nsnull, rowBefore, *overflows);
    1: }
    1: 
    1: static nsTableRowFrame* 
    1: GetRowBefore(nsTableRowFrame& aStartRow,
    1:              nsTableRowFrame& aRow)
    1: {
    1:   nsTableRowFrame* rowBefore = nsnull;
    1:   for (nsTableRowFrame* sib = &aStartRow; sib && (sib != &aRow); sib = sib->GetNextRow()) {
    1:     rowBefore = sib;
    1:   }
    1:   return rowBefore;
    1: }
    1: 
    1: nsresult
    1: nsTableRowGroupFrame::SplitRowGroup(nsPresContext*           aPresContext,
    1:                                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                                     const nsHTMLReflowState& aReflowState,
    1:                                     nsTableFrame*            aTableFrame,
    1:                                     nsReflowStatus&          aStatus)
    1: {
    1:   NS_PRECONDITION(aPresContext->IsPaginated(), "SplitRowGroup currently supports only paged media"); 
    1: 
    1:   nsresult rv = NS_OK;
    1:   nsTableRowFrame* prevRowFrame = nsnull;
    1:   aDesiredSize.height = 0;
    1: 
    1:   nscoord availWidth  = aReflowState.availableWidth;
    1:   nscoord availHeight = aReflowState.availableHeight;
    1:   
79445:   bool    borderCollapse = ((nsTableFrame*)aTableFrame->GetFirstInFlow())->IsBorderCollapse();
    1:   nscoord cellSpacingY   = aTableFrame->GetCellSpacingY();
    1:   
    1:   // get the page height
    1:   nscoord pageHeight = aPresContext->GetPageSize().height;
    1:   NS_ASSERTION(pageHeight != NS_UNCONSTRAINEDSIZE, 
    1:                "The table shouldn't be split when there should be space");
    1: 
79445:   bool isTopOfPage = aReflowState.mFlags.mIsTopOfPage;
    1:   nsTableRowFrame* firstRowThisPage = GetFirstRow();
    1: 
10735:   // Need to dirty the table's geometry, or else the row might skip
10735:   // reflowing its cell as an optimization.
10735:   aTableFrame->SetGeometryDirty();
10735: 
    1:   // Walk each of the row frames looking for the first row frame that doesn't fit 
    1:   // in the available space
    1:   for (nsTableRowFrame* rowFrame = firstRowThisPage; rowFrame; rowFrame = rowFrame->GetNextRow()) {
79445:     bool rowIsOnPage = true;
    1:     nsRect rowRect = rowFrame->GetRect();
    1:     // See if the row fits on this page
    1:     if (rowRect.YMost() > availHeight) {
    1:       nsTableRowFrame* contRow = nsnull;
    1:       // Reflow the row in the availabe space and have it split if it is the 1st
    1:       // row (on the page) or there is at least 5% of the current page available 
    1:       // XXX this 5% should be made a preference 
    1:       if (!prevRowFrame || (availHeight - aDesiredSize.height > pageHeight / 20)) { 
32531:         nsSize availSize(availWidth, NS_MAX(availHeight - rowRect.y, 0));
    1:         // don't let the available height exceed what CalculateRowHeights set for it
32531:         availSize.height = NS_MIN(availSize.height, rowRect.height);
    1: 
    1:         nsHTMLReflowState rowReflowState(aPresContext, aReflowState,
    1:                                          rowFrame, availSize,
80486:                                          -1, -1, false);
    1:                                          
    1:         InitChildReflowState(*aPresContext, borderCollapse, rowReflowState);
    1:         rowReflowState.mFlags.mIsTopOfPage = isTopOfPage; // set top of page
    1:         nsHTMLReflowMetrics rowMetrics;
    1: 
11384:         // Get the old size before we reflow.
11384:         nsRect oldRowRect = rowFrame->GetRect();
55037:         nsRect oldRowVisualOverflow = rowFrame->GetVisualOverflowRect();
11384: 
    1:         // Reflow the cell with the constrained height. A cell with rowspan >1 will get this
    1:         // reflow later during SplitSpanningCells.
    1:         rv = ReflowChild(rowFrame, aPresContext, rowMetrics, rowReflowState,
    1:                          0, 0, NS_FRAME_NO_MOVE_FRAME, aStatus);
    1:         if (NS_FAILED(rv)) return rv;
    1:         rowFrame->SetSize(nsSize(rowMetrics.width, rowMetrics.height));
    1:         rowFrame->DidReflow(aPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
    1:         rowFrame->DidResize();
    1: 
55037:         nsTableFrame::InvalidateFrame(rowFrame, oldRowRect,
55037:                                       oldRowVisualOverflow,
80486:                                       false);
11384: 
    1:         if (NS_FRAME_IS_NOT_COMPLETE(aStatus)) {
    1:           // The row frame is incomplete and all of the rowspan 1 cells' block frames split
    1:           if ((rowMetrics.height <= rowReflowState.availableHeight) || isTopOfPage) {
    1:             // The row stays on this page because either it split ok or we're on the top of page.
    1:             // If top of page and the height exceeded the avail height, then there will be data loss
    1:             NS_ASSERTION(rowMetrics.height <= rowReflowState.availableHeight, 
    1:                          "data loss - incomplete row needed more height than available, on top of page");
    1:             CreateContinuingRowFrame(*aPresContext, *rowFrame, (nsIFrame**)&contRow);
    1:             if (contRow) {
    1:               aDesiredSize.height += rowMetrics.height;
    1:               if (prevRowFrame) 
    1:                 aDesiredSize.height += cellSpacingY;
    1:             }
    1:             else return NS_ERROR_NULL_POINTER;
    1:           }
    1:           else {
    1:             // Put the row on the next page to give it more height 
80486:             rowIsOnPage = false;
    1:           }
    1:         } 
    1:         else {
    1:           // The row frame is complete because either (1) its minimum height is greater than the 
    1:           // available height we gave it, or (2) it may have been given a larger height through 
    1:           // style than its content, or (3) it contains a rowspan >1 cell which hasn't been
    1:           // reflowed with a constrained height yet (we will find out when SplitSpanningCells is
    1:           // called below)
 8536:           if (rowMetrics.height > availSize.height) {
    1:             // cases (1) and (2)
    1:             if (isTopOfPage) { 
    1:               // We're on top of the page, so keep the row on this page. There will be data loss.
    1:               // Push the row frame that follows
    1:               nsTableRowFrame* nextRowFrame = rowFrame->GetNextRow();
    1:               if (nextRowFrame) {
    1:                 aStatus = NS_FRAME_NOT_COMPLETE;
    1:               }
    1:               aDesiredSize.height += rowMetrics.height;
    1:               if (prevRowFrame) 
    1:                 aDesiredSize.height += cellSpacingY;
    1:               NS_WARNING("data loss - complete row needed more height than available, on top of page");
    1:             }
    1:             else {
    1:               // We're not on top of the page, so put the row on the next page to give it more height 
80486:               rowIsOnPage = false;
    1:             }
    1:           }
    1:         }
    1:       } //if (!prevRowFrame || (availHeight - aDesiredSize.height > pageHeight / 20))
    1:       else { 
    1:         // put the row on the next page to give it more height
80486:         rowIsOnPage = false;
    1:       }
    1: 
    1:       nsTableRowFrame* lastRowThisPage = rowFrame;
 8536:       nscoord spanningRowBottom = availHeight;
    1:       if (!rowIsOnPage) {
 7831:         NS_ASSERTION(!contRow, "We should not have created a continuation if none of this row fits");
    1:         if (prevRowFrame) {
 8536:           spanningRowBottom = prevRowFrame->GetRect().YMost();
    1:           lastRowThisPage = prevRowFrame;
    1:           isTopOfPage = (lastRowThisPage == firstRowThisPage) && aReflowState.mFlags.mIsTopOfPage;
    1:           aStatus = NS_FRAME_NOT_COMPLETE;
    1:         }
    1:         else {
    1:           // We can't push children, so let our parent reflow us again with more space
    1:           aDesiredSize.height = rowRect.YMost();
 7831:           aStatus = NS_FRAME_COMPLETE;
    1:           break;
    1:         }
    1:       }
    1:       // reflow the cells with rowspan >1 that occur on the page
    1: 
    1:       nsTableRowFrame* firstTruncatedRow;
    1:       nscoord yMost;
    1:       SplitSpanningCells(*aPresContext, aReflowState, *aTableFrame, *firstRowThisPage,
 8536:                          *lastRowThisPage, aReflowState.mFlags.mIsTopOfPage, spanningRowBottom, contRow, 
    1:                          firstTruncatedRow, yMost);
    1:       if (firstTruncatedRow) {
    1:         // A rowspan >1 cell did not fit (and could not split) in the space we gave it
    1:         if (firstTruncatedRow == firstRowThisPage) {
    1:           if (aReflowState.mFlags.mIsTopOfPage) {
    1:             NS_WARNING("data loss in a row spanned cell");
    1:           }
    1:           else {
    1:             // We can't push children, so let our parent reflow us again with more space
    1:             aDesiredSize.height = rowRect.YMost();
    1:             aStatus = NS_FRAME_COMPLETE;
    1:             UndoContinuedRow(aPresContext, contRow);
    1:             contRow = nsnull;
    1:           }
    1:         }
    1:         else { // (firstTruncatedRow != firstRowThisPage)
    1:           // Try to put firstTruncateRow on the next page 
    1:           nsTableRowFrame* rowBefore = ::GetRowBefore(*firstRowThisPage, *firstTruncatedRow);
 8536:           nscoord oldSpanningRowBottom = spanningRowBottom;
 8536:           spanningRowBottom = rowBefore->GetRect().YMost();
    1: 
    1:           UndoContinuedRow(aPresContext, contRow);
    1:           contRow = nsnull;
    1:           nsTableRowFrame* oldLastRowThisPage = lastRowThisPage;
    1:           lastRowThisPage = firstTruncatedRow;
    1:           aStatus = NS_FRAME_NOT_COMPLETE;
    1: 
    1:           // Call SplitSpanningCells again with rowBefore as the last row on the page
    1:           SplitSpanningCells(*aPresContext, aReflowState, *aTableFrame, 
    1:                              *firstRowThisPage, *rowBefore, aReflowState.mFlags.mIsTopOfPage, 
 8536:                              spanningRowBottom, contRow, firstTruncatedRow, aDesiredSize.height);
    1:           if (firstTruncatedRow) {
    1:             if (aReflowState.mFlags.mIsTopOfPage) {
    1:               // We were better off with the 1st call to SplitSpanningCells, do it again
    1:               UndoContinuedRow(aPresContext, contRow);
    1:               contRow = nsnull;
    1:               lastRowThisPage = oldLastRowThisPage;
 8536:               spanningRowBottom = oldSpanningRowBottom;
    1:               SplitSpanningCells(*aPresContext, aReflowState, *aTableFrame, *firstRowThisPage,
 8536:                                  *lastRowThisPage, aReflowState.mFlags.mIsTopOfPage, spanningRowBottom, contRow, 
    1:                                  firstTruncatedRow, aDesiredSize.height);
    1:               NS_WARNING("data loss in a row spanned cell");
    1:             }
    1:             else {
    1:               // Let our parent reflow us again with more space
    1:               aDesiredSize.height = rowRect.YMost();
    1:               aStatus = NS_FRAME_COMPLETE;
    1:               UndoContinuedRow(aPresContext, contRow);
    1:               contRow = nsnull;
    1:             }
    1:           }
    1:         } // if (firstTruncatedRow == firstRowThisPage)
    1:       } // if (firstTruncatedRow)
    1:       else {
32531:         aDesiredSize.height = NS_MAX(aDesiredSize.height, yMost);
    1:         if (contRow) {
    1:           aStatus = NS_FRAME_NOT_COMPLETE;
    1:         }
    1:       }
    1:       if (NS_FRAME_IS_NOT_COMPLETE(aStatus) && !contRow) {
    1:         nsTableRowFrame* nextRow = lastRowThisPage->GetNextRow();
    1:         if (nextRow) {
    1:           PushChildren(aPresContext, nextRow, lastRowThisPage);
    1:         }
    1:       }
    1:       break;
    1:     } // if (rowRect.YMost() > availHeight)
    1:     else { 
    1:       aDesiredSize.height = rowRect.YMost();
    1:       prevRowFrame = rowFrame;
    1:       // see if there is a page break after the row
    1:       nsTableRowFrame* nextRow = rowFrame->GetNextRow();
42270:       if (nextRow && nsTableFrame::PageBreakAfter(rowFrame, nextRow)) {
    1:         PushChildren(aPresContext, nextRow, rowFrame);
    1:         aStatus = NS_FRAME_NOT_COMPLETE;
    1:         break;
    1:       }
    1:     }
14430:     // after the 1st row that has a height, we can't be on top
14430:     // of the page anymore.
14430:     isTopOfPage = isTopOfPage && rowRect.YMost() == 0;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /** Layout the entire row group.
    1:   * This method stacks rows vertically according to HTML 4.0 rules.
    1:   * Rows are responsible for layout of their children.
    1:   */
    1: NS_METHOD
    1: nsTableRowGroupFrame::Reflow(nsPresContext*           aPresContext,
    1:                              nsHTMLReflowMetrics&     aDesiredSize,
    1:                              const nsHTMLReflowState& aReflowState,
    1:                              nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsTableRowGroupFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
    1:   nsresult rv = NS_OK;
    1:   aStatus     = NS_FRAME_COMPLETE;
    1:         
    1:   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
    1:   if (!tableFrame) return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Row geometry may be going to change so we need to invalidate any row cursor.
    1:   ClearRowCursor();
    1: 
    1:   // see if a special height reflow needs to occur due to having a pct height
    1:   nsTableFrame::CheckRequestSpecialHeightReflow(aReflowState);
    1: 
    1:   nsRowGroupReflowState state(aReflowState, tableFrame);
    1:   const nsStyleVisibility* groupVis = GetStyleVisibility();
79445:   bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE == groupVis->mVisible);
    1:   if (collapseGroup) {
80486:     tableFrame->SetNeedToCollapse(true);
    1:   }
    1: 
    1:   // Check for an overflow list
    1:   MoveOverflowToChildList(aPresContext);
    1: 
    1:   // Reflow the existing frames. 
79445:   bool splitDueToPageBreak = false;
    1:   rv = ReflowChildren(aPresContext, aDesiredSize, state, aStatus,
    1:                       &splitDueToPageBreak);
    1: 
    1:   // See if all the frames fit. Do not try to split anything if we're
    1:   // not paginated ... we can't split across columns yet.
    1:   if (aReflowState.mFlags.mTableIsSplittable &&
42269:       NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight &&
    1:       (NS_FRAME_NOT_COMPLETE == aStatus || splitDueToPageBreak || 
42269:        aDesiredSize.height > aReflowState.availableHeight)) {
    1:     // Nope, find a place to split the row group 
79445:     bool specialReflow = (bool)aReflowState.mFlags.mSpecialHeightReflow;
80486:     ((nsHTMLReflowState::ReflowStateFlags&)aReflowState.mFlags).mSpecialHeightReflow = false;
    1: 
    1:     SplitRowGroup(aPresContext, aDesiredSize, aReflowState, tableFrame, aStatus);
    1: 
    1:     ((nsHTMLReflowState::ReflowStateFlags&)aReflowState.mFlags).mSpecialHeightReflow = specialReflow;
    1:   }
    1: 
    1:   // If we have a next-in-flow, then we're not complete
    1:   // XXXldb This used to be done only for the incremental reflow codepath.
    1:   if (GetNextInFlow()) {
    1:     aStatus = NS_FRAME_NOT_COMPLETE;
    1:   }
    1: 
 4166:   SetHasStyleHeight((NS_UNCONSTRAINEDSIZE != aReflowState.ComputedHeight()) &&
 4166:                     (aReflowState.ComputedHeight() > 0)); 
    1:   
    1:   // just set our width to what was available. The table will calculate the width and not use our value.
    1:   aDesiredSize.width = aReflowState.availableWidth;
    1: 
55039:   aDesiredSize.UnionOverflowAreasWithDesiredBounds();
13144: 
13144:   // If our parent is in initial reflow, it'll handle invalidating our
13144:   // entire overflow rect.
13804:   if (!(GetParent()->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
17140:     CheckInvalidateSizeChange(aDesiredSize);
13144:   }
13144:   
    1:   FinishAndStoreOverflow(&aDesiredSize);
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1:   return rv;
    1: }
    1: 
20836: /* virtual */ void
20836: nsTableRowGroupFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
20836: {
20836:   if (!aOldStyleContext) //avoid this on init
20836:     return;
20836:      
20836:   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
20836:     
20836:   if (tableFrame->IsBorderCollapse() &&
20836:       tableFrame->BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
20836:     nsRect damageArea(0, GetStartRowIndex(), tableFrame->GetColCount(),
20836:                       GetRowCount());
20836:     tableFrame->SetBCDamageArea(damageArea);
20836:   }
20836:   return;
20836: }
20836: 
    1: NS_IMETHODIMP
77154: nsTableRowGroupFrame::AppendFrames(ChildListID     aListID,
30941:                                    nsFrameList&    aFrameList)
    1: {
77154:   NS_ASSERTION(aListID == kPrincipalList, "unexpected child list");
    1: 
    1:   ClearRowCursor();
    1: 
    1:   // collect the new row frames in an array
30941:   // XXXbz why are we doing the QI stuff?  There shouldn't be any non-rows here.
24724:   nsAutoTArray<nsTableRowFrame*, 8> rows;
30941:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
30941:     nsTableRowFrame *rowFrame = do_QueryFrame(e.get());
30941:     NS_ASSERTION(rowFrame, "Unexpected frame; frame constructor screwed up");
26583:     if (rowFrame) {
16638:       NS_ASSERTION(NS_STYLE_DISPLAY_TABLE_ROW ==
30941:                      e.get()->GetStyleDisplay()->mDisplay,
16638:                    "wrong display type on rowframe");      
26583:       rows.AppendElement(rowFrame);
    1:     }
    1:   }
    1: 
    1:   PRInt32 rowIndex = GetRowCount();
    1:   // Append the frames to the sibling chain
    1:   mFrames.AppendFrames(nsnull, aFrameList);
    1: 
24724:   if (rows.Length() > 0) {
    1:     nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
    1:     if (tableFrame) {
37262:       tableFrame->AppendRows(this, rowIndex, rows);
 1158:       PresContext()->PresShell()->
 1158:         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                          NS_FRAME_HAS_DIRTY_CHILDREN);
    1:       tableFrame->SetGeometryDirty();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsTableRowGroupFrame::InsertFrames(ChildListID     aListID,
    1:                                    nsIFrame*       aPrevFrame,
30941:                                    nsFrameList&    aFrameList)
    1: {
77154:   NS_ASSERTION(aListID == kPrincipalList, "unexpected child list");
    1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
    1:                "inserting after sibling frame with different parent");
    1: 
    1:   ClearRowCursor();
    1: 
    1:   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
    1:   if (!tableFrame)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // collect the new row frames in an array
30941:   // XXXbz why are we doing the QI stuff?  There shouldn't be any non-rows here.
24724:   nsTArray<nsTableRowFrame*> rows;
79445:   bool gotFirstRow = false;
30941:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
30941:     nsTableRowFrame *rowFrame = do_QueryFrame(e.get());
30941:     NS_ASSERTION(rowFrame, "Unexpected frame; frame constructor screwed up");
26583:     if (rowFrame) {
16638:       NS_ASSERTION(NS_STYLE_DISPLAY_TABLE_ROW ==
30941:                      e.get()->GetStyleDisplay()->mDisplay,
16638:                    "wrong display type on rowframe");      
26583:       rows.AppendElement(rowFrame);
    1:       if (!gotFirstRow) {
80486:         rowFrame->SetFirstInserted(true);
80486:         gotFirstRow = true;
80486:         tableFrame->SetRowInserted(true);
    1:       }
    1:     }
    1:   }
    1: 
    1:   PRInt32 startRowIndex = GetStartRowIndex();
    1:   // Insert the frames in the sibling chain
    1:   mFrames.InsertFrames(nsnull, aPrevFrame, aFrameList);
    1: 
24724:   PRInt32 numRows = rows.Length();
    1:   if (numRows > 0) {
    1:     nsTableRowFrame* prevRow = (nsTableRowFrame *)nsTableFrame::GetFrameAtOrBefore(this, aPrevFrame, nsGkAtoms::tableRowFrame);
    1:     PRInt32 rowIndex = (prevRow) ? prevRow->GetRowIndex() + 1 : startRowIndex;
80486:     tableFrame->InsertRows(this, rows, rowIndex, true);
    1: 
 1158:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                        NS_FRAME_HAS_DIRTY_CHILDREN);
    1:     tableFrame->SetGeometryDirty();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsTableRowGroupFrame::RemoveFrame(ChildListID     aListID,
    1:                                   nsIFrame*       aOldFrame)
    1: {
77154:   NS_ASSERTION(aListID == kPrincipalList, "unexpected child list");
    1: 
    1:   ClearRowCursor();
    1: 
    1:   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
    1:   if (tableFrame) {
26583:     nsTableRowFrame *rowFrame = do_QueryFrame(aOldFrame);
26583:     if (rowFrame) {
    1:       // remove the rows from the table (and flag a rebalance)
80486:       tableFrame->RemoveRows(*rowFrame, 1, true);
    1: 
 1158:       PresContext()->PresShell()->
 1158:         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                          NS_FRAME_HAS_DIRTY_CHILDREN);
    1:       tableFrame->SetGeometryDirty();
    1:     }
    1:   }
    1:   mFrames.DestroyFrame(aOldFrame);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsTableRowGroupFrame::GetUsedMargin() const
    1: {
    1:   return nsMargin(0,0,0,0);
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsTableRowGroupFrame::GetUsedBorder() const
    1: {
    1:   return nsMargin(0,0,0,0);
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsTableRowGroupFrame::GetUsedPadding() const
    1: {
    1:   return nsMargin(0,0,0,0);
    1: }
    1: 
    1: nscoord 
    1: nsTableRowGroupFrame::GetHeightBasis(const nsHTMLReflowState& aReflowState)
    1: {
    1:   nscoord result = 0;
    1:   nsTableFrame* tableFrame = nsTableFrame::GetTableFrame(this);
    1:   if (tableFrame) {
 4166:     if ((aReflowState.ComputedHeight() > 0) && (aReflowState.ComputedHeight() < NS_UNCONSTRAINEDSIZE)) {
32531:       nscoord cellSpacing = NS_MAX(0, GetRowCount() - 1) * tableFrame->GetCellSpacingY();
 4166:       result = aReflowState.ComputedHeight() - cellSpacing;
    1:     }
    1:     else {
    1:       const nsHTMLReflowState* parentRS = aReflowState.parentReflowState;
    1:       if (parentRS && (tableFrame != parentRS->frame)) {
    1:         parentRS = parentRS->parentReflowState;
    1:       }
    1:       if (parentRS && (tableFrame == parentRS->frame) && 
 4166:           (parentRS->ComputedHeight() > 0) && (parentRS->ComputedHeight() < NS_UNCONSTRAINEDSIZE)) {
32531:         nscoord cellSpacing = NS_MAX(0, tableFrame->GetRowCount() + 1) * tableFrame->GetCellSpacingY();
 4166:         result = parentRS->ComputedHeight() - cellSpacing;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
79445: bool
    1: nsTableRowGroupFrame::IsSimpleRowFrame(nsTableFrame* aTableFrame,
    1:                                        nsIFrame*     aFrame)
    1: {
    1:   // Make sure it's a row frame and not a row group frame
26583:   nsTableRowFrame *rowFrame = do_QueryFrame(aFrame);
26583:   if (rowFrame) {
26583:     PRInt32 rowIndex = rowFrame->GetRowIndex();
    1:     
    1:     // It's a simple row frame if there are no cells that span into or
    1:     // across the row
    1:     PRInt32 numEffCols = aTableFrame->GetEffectiveColCount();
    1:     if (!aTableFrame->RowIsSpannedInto(rowIndex, numEffCols) &&
    1:         !aTableFrame->RowHasSpanningCells(rowIndex, numEffCols)) {
80486:       return true;
    1:     }
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: nsIAtom*
    1: nsTableRowGroupFrame::GetType() const
    1: {
    1:   return nsGkAtoms::tableRowGroupFrame;
    1: }
    1: 
42270: /** find page break before the first row **/
79445: bool 
42270: nsTableRowGroupFrame::HasInternalBreakBefore() const
42270: {
42270:  nsIFrame* firstChild = mFrames.FirstChild(); 
42270:   if (!firstChild)
80486:     return false;
42270:   return firstChild->GetStyleDisplay()->mBreakBefore;
42270: }
    1: 
42270: /** find page break after the last row **/
79445: bool 
42270: nsTableRowGroupFrame::HasInternalBreakAfter() const
42270: {
42270:   nsIFrame* lastChild = mFrames.LastChild(); 
42270:   if (!lastChild)
80486:     return false;
42270:   return lastChild->GetStyleDisplay()->mBreakAfter;
42270: }
    1: /* ----- global methods ----- */
    1: 
    1: nsIFrame*
    1: NS_NewTableRowGroupFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsTableRowGroupFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsTableRowGroupFrame)
32423: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsTableRowGroupFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("TableRowGroup"), aResult);
    1: }
    1: #endif
    1: 
    1: nsMargin* 
    1: nsTableRowGroupFrame::GetBCBorderWidth(nsMargin& aBorder)
    1: {
13962:   aBorder.left = aBorder.right = aBorder.top = aBorder.bottom = 0;
    1: 
    1:   nsTableRowFrame* firstRowFrame = nsnull;
    1:   nsTableRowFrame* lastRowFrame = nsnull;
    1:   for (nsTableRowFrame* rowFrame = GetFirstRow(); rowFrame; rowFrame = rowFrame->GetNextRow()) {
    1:     if (!firstRowFrame) {
    1:       firstRowFrame = rowFrame;
    1:     }
    1:     lastRowFrame = rowFrame;
    1:   }
    1:   if (firstRowFrame) {
    1:     aBorder.top    = nsPresContext::CSSPixelsToAppUnits(firstRowFrame->GetTopBCBorderWidth());
    1:     aBorder.bottom = nsPresContext::CSSPixelsToAppUnits(lastRowFrame->GetBottomBCBorderWidth());
    1:   }
    1: 
    1:   return &aBorder;
    1: }
    1: 
    1: void nsTableRowGroupFrame::SetContinuousBCBorderWidth(PRUint8     aForSide,
    1:                                                       BCPixelSize aPixelValue)
    1: {
    1:   switch (aForSide) {
    1:     case NS_SIDE_RIGHT:
    1:       mRightContBorderWidth = aPixelValue;
    1:       return;
    1:     case NS_SIDE_BOTTOM:
    1:       mBottomContBorderWidth = aPixelValue;
    1:       return;
    1:     case NS_SIDE_LEFT:
    1:       mLeftContBorderWidth = aPixelValue;
    1:       return;
    1:     default:
    1:       NS_ERROR("invalid NS_SIDE argument");
    1:   }
    1: }
    1: 
11963: //nsILineIterator methods
21112: PRInt32
21112: nsTableRowGroupFrame::GetNumLines()
    1: {
21112:   return GetRowCount();
    1: }
    1: 
79445: bool
21112: nsTableRowGroupFrame::GetDirection()
    1: {
11963:   nsTableFrame* table = nsTableFrame::GetTableFrame(this);
21112:   return (NS_STYLE_DIRECTION_RTL ==
11963:           table->GetStyleVisibility()->mDirection);
    1: }
    1:   
    1: NS_IMETHODIMP
    1: nsTableRowGroupFrame::GetLine(PRInt32    aLineNumber, 
    1:                               nsIFrame** aFirstFrameOnLine, 
    1:                               PRInt32*   aNumFramesOnLine,
    1:                               nsRect&    aLineBounds, 
    1:                               PRUint32*  aLineFlags)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aFirstFrameOnLine);
    1:   NS_ENSURE_ARG_POINTER(aNumFramesOnLine);
    1:   NS_ENSURE_ARG_POINTER(aLineFlags);
    1: 
11963:   nsTableFrame* table = nsTableFrame::GetTableFrame(this);
11963:   nsTableCellMap* cellMap = table->GetCellMap();
    1: 
11963:   *aLineFlags = 0;
11963:   *aFirstFrameOnLine = nsnull;
11963:   *aNumFramesOnLine = 0;
11963:   aLineBounds.SetRect(0, 0, 0, 0);
    1:   
11963:   if ((aLineNumber < 0) || (aLineNumber >=  GetRowCount())) {
11963:     return NS_OK;
11963:   }
11963:   aLineNumber += GetStartRowIndex(); 
    1: 
    1:   *aNumFramesOnLine = cellMap->GetNumCellsOriginatingInRow(aLineNumber);
11963:   if (*aNumFramesOnLine == 0) {
11963:     return NS_OK;
    1:   }
13620:   PRInt32 colCount = table->GetColCount();
13620:   for (PRInt32 i = 0; i < colCount; i++) {
11963:     CellData* data = cellMap->GetDataAt(aLineNumber, i);
11963:     if (data && data->IsOrig()) {
11963:       *aFirstFrameOnLine = (nsIFrame*)data->GetCellFrame();
11963:       nsIFrame* parent = (*aFirstFrameOnLine)->GetParent();
11963:       aLineBounds = parent->GetRect();
11963:       return NS_OK;
    1:     }
    1:   }
11963:   NS_ERROR("cellmap is lying");
11963:   return NS_ERROR_FAILURE;
    1: }
    1:   
21112: PRInt32
77978: nsTableRowGroupFrame::FindLineContaining(nsIFrame* aFrame, PRInt32 aStartLine)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aFrame);
    1:   
26583:   nsTableRowFrame *rowFrame = do_QueryFrame(aFrame);
26583:   NS_ASSERTION(rowFrame, "RowGroup contains a frame that is not a row");
    1: 
77978:   PRInt32 rowIndexInGroup = rowFrame->GetRowIndex() - GetStartRowIndex();
77978: 
77978:   return rowIndexInGroup >= aStartLine ? rowIndexInGroup : -1;
    1: }
    1: 
    1: #ifdef IBMBIDI
    1: NS_IMETHODIMP
    1: nsTableRowGroupFrame::CheckLineOrder(PRInt32                  aLine,
79445:                                      bool                     *aIsReordered,
    1:                                      nsIFrame                 **aFirstVisual,
    1:                                      nsIFrame                 **aLastVisual)
    1: {
80486:   *aIsReordered = false;
    1:   *aFirstVisual = nsnull;
    1:   *aLastVisual = nsnull;
    1:   return NS_OK;
    1: }
    1: #endif // IBMBIDI
    1:   
    1: NS_IMETHODIMP
    1: nsTableRowGroupFrame::FindFrameAt(PRInt32    aLineNumber, 
    1:                                   nscoord    aX, 
    1:                                   nsIFrame** aFrameFound,
79445:                                   bool*    aXIsBeforeFirstFrame, 
79445:                                   bool*    aXIsAfterLastFrame)
    1: {
11963:    nsTableFrame* table = nsTableFrame::GetTableFrame(this);
11963:    nsTableCellMap* cellMap = table->GetCellMap();
    1:    
11963:    *aFrameFound = nsnull;
80486:    *aXIsBeforeFirstFrame = true;
80486:    *aXIsAfterLastFrame = false;
    1: 
11963:    aLineNumber += GetStartRowIndex();
11963:    PRInt32 numCells = cellMap->GetNumCellsOriginatingInRow(aLineNumber);
11963:    if (numCells == 0) {
11963:      return NS_OK;
    1:    }
    1:   
11963:    nsIFrame* frame = nsnull;
13963:    PRInt32 colCount = table->GetColCount();
13963:    for (PRInt32 i = 0; i < colCount; i++) {
11963:      CellData* data = cellMap->GetDataAt(aLineNumber, i);
11963:      if (data && data->IsOrig()) {
11963:        frame = (nsIFrame*)data->GetCellFrame();
11963:        break;
    1:      }
    1:    }
11963:    NS_ASSERTION(frame, "cellmap is lying");
79445:    bool isRTL = (NS_STYLE_DIRECTION_RTL ==
11963:                    table->GetStyleVisibility()->mDirection);
11963:    
11963:    nsIFrame* closestFromLeft = nsnull;
11963:    nsIFrame* closestFromRight = nsnull;
11963:    PRInt32 n = numCells;
11963:    nsIFrame* firstFrame = frame;
11963:    while (n--) {
11963:      nsRect rect = frame->GetRect();
11963:      if (rect.width > 0) {
11963:        // If aX is inside this frame - this is it
11963:        if (rect.x <= aX && rect.XMost() > aX) {
11963:          closestFromLeft = closestFromRight = frame;
11963:          break;
    1:        }
11963:        if (rect.x < aX) {
11963:          if (!closestFromLeft ||
11963:              rect.XMost() > closestFromLeft->GetRect().XMost())
11963:            closestFromLeft = frame;
    1:        }
11963:        else {
11963:          if (!closestFromRight ||
11963:              rect.x < closestFromRight->GetRect().x)
11963:            closestFromRight = frame;
11963:        }
11963:      }
11963:      frame = frame->GetNextSibling();
11963:    }
11963:    if (!closestFromLeft && !closestFromRight) {
11963:      // All frames were zero-width. Just take the first one.
11963:      closestFromLeft = closestFromRight = firstFrame;
11963:    }
11963:    *aXIsBeforeFirstFrame = isRTL ? !closestFromRight : !closestFromLeft;
11963:    *aXIsAfterLastFrame =   isRTL ? !closestFromLeft : !closestFromRight;
11963:    if (closestFromLeft == closestFromRight) {
11963:      *aFrameFound = closestFromLeft;
11963:    }
11963:    else if (!closestFromLeft) {
11963:      *aFrameFound = closestFromRight;
11963:    }
11963:    else if (!closestFromRight) {
11963:      *aFrameFound = closestFromLeft;
11963:    }
11963:    else { // we're between two frames
11963:      nscoord delta = closestFromRight->GetRect().x -
11963:                      closestFromLeft->GetRect().XMost();
11963:      if (aX < closestFromLeft->GetRect().XMost() + delta/2)
11963:        *aFrameFound = closestFromLeft;
11963:      else
11963:        *aFrameFound = closestFromRight;
11963:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTableRowGroupFrame::GetNextSiblingOnLine(nsIFrame*& aFrame, 
    1:                                            PRInt32    aLineNumber)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aFrame);
11464:   aFrame = aFrame->GetNextSibling();
    1:   return NS_OK;
    1: }
    1: 
    1: //end nsLineIterator methods
    1: 
    1: static void
39965: DestroyFrameCursorData(void* aPropertyValue)
    1: {
 3233:   delete static_cast<nsTableRowGroupFrame::FrameCursorData*>(aPropertyValue);
    1: }
    1: 
39965: NS_DECLARE_FRAME_PROPERTY(RowCursorProperty, DestroyFrameCursorData)
39965: 
    1: void
    1: nsTableRowGroupFrame::ClearRowCursor()
    1: {
    1:   if (!(GetStateBits() & NS_ROWGROUP_HAS_ROW_CURSOR))
    1:     return;
    1: 
    1:   RemoveStateBits(NS_ROWGROUP_HAS_ROW_CURSOR);
39965:   Properties().Delete(RowCursorProperty());
    1: }
    1: 
    1: nsTableRowGroupFrame::FrameCursorData*
    1: nsTableRowGroupFrame::SetupRowCursor()
    1: {
    1:   if (GetStateBits() & NS_ROWGROUP_HAS_ROW_CURSOR) {
    1:     // We already have a valid row cursor. Don't waste time rebuilding it.
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIFrame* f = mFrames.FirstChild();
    1:   PRInt32 count;
    1:   for (count = 0; f && count < MIN_ROWS_NEEDING_CURSOR; ++count) {
    1:     f = f->GetNextSibling();
    1:   }
    1:   if (!f) {
    1:     // Less than MIN_ROWS_NEEDING_CURSOR rows, so just don't bother
    1:     return nsnull;
    1:   }
    1: 
    1:   FrameCursorData* data = new FrameCursorData();
    1:   if (!data)
    1:     return nsnull;
39965:   Properties().Set(RowCursorProperty(), data);
    1:   AddStateBits(NS_ROWGROUP_HAS_ROW_CURSOR);
    1:   return data;
    1: }
    1: 
    1: nsIFrame*
    1: nsTableRowGroupFrame::GetFirstRowContaining(nscoord aY, nscoord* aOverflowAbove)
    1: {
    1:   if (!(GetStateBits() & NS_ROWGROUP_HAS_ROW_CURSOR))
    1:     return nsnull;
    1: 
 3233:   FrameCursorData* property = static_cast<FrameCursorData*>
39965:     (Properties().Get(RowCursorProperty()));
    1:   PRUint32 cursorIndex = property->mCursorIndex;
    1:   PRUint32 frameCount = property->mFrames.Length();
    1:   if (cursorIndex >= frameCount)
    1:     return nsnull;
    1:   nsIFrame* cursorFrame = property->mFrames[cursorIndex];
    1: 
    1:   // The cursor's frame list excludes frames with empty overflow-area, so
    1:   // we don't need to check that here.
    1:   
    1:   // We use property->mOverflowBelow here instead of computing the frame's
    1:   // true overflowArea.YMost(), because it is essential for the thresholds
    1:   // to form a monotonically increasing sequence. Otherwise we would break
    1:   // encountering a row whose overflowArea.YMost() is <= aY but which has
    1:   // a row above it containing cell(s) that span to include aY.
    1:   while (cursorIndex > 0 &&
    1:          cursorFrame->GetRect().YMost() + property->mOverflowBelow > aY) {
    1:     --cursorIndex;
    1:     cursorFrame = property->mFrames[cursorIndex];
    1:   }
    1:   while (cursorIndex + 1 < frameCount &&
    1:          cursorFrame->GetRect().YMost() + property->mOverflowBelow <= aY) {
    1:     ++cursorIndex;
    1:     cursorFrame = property->mFrames[cursorIndex];
    1:   }
    1: 
    1:   property->mCursorIndex = cursorIndex;
    1:   *aOverflowAbove = property->mOverflowAbove;
    1:   return cursorFrame;
    1: }
    1: 
79445: bool
    1: nsTableRowGroupFrame::FrameCursorData::AppendFrame(nsIFrame* aFrame)
    1: {
55040:   nsRect overflowRect = aFrame->GetVisualOverflowRect();
    1:   if (overflowRect.IsEmpty())
80486:     return true;
    1:   nscoord overflowAbove = -overflowRect.y;
    1:   nscoord overflowBelow = overflowRect.YMost() - aFrame->GetSize().height;
32531:   mOverflowAbove = NS_MAX(mOverflowAbove, overflowAbove);
32531:   mOverflowBelow = NS_MAX(mOverflowBelow, overflowBelow);
    1:   return mFrames.AppendElement(aFrame) != nsnull;
    1: }
