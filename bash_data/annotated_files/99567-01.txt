    1: /* -*- Mode: Objective-C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
    1:  
    1: #import "mozAccessible.h"
    1: 
88363: #import "MacUtils.h"
    1: #import "mozView.h"
    1: 
95352: #include "Accessible-inl.h"
95352: #include "nsIAccessibleRelation.h"
95352: #include "nsIAccessibleText.h"
95352: #include "nsIAccessibleEditableText.h"
95352: #include "Relation.h"
95352: #include "Role.h"
97643: #include "RootAccessible.h"
95352: 
95352: #include "mozilla/Services.h"
    1: #include "nsRect.h"
87093: #include "nsCocoaUtils.h"
    1: #include "nsCoord.h"
12110: #include "nsObjCExceptions.h"
    1: 
87093: using namespace mozilla;
74618: using namespace mozilla::a11y;
74618: 
    1: // converts a screen-global point in the cocoa coordinate system (with origo in the bottom-left corner
    1: // of the screen), into a top-left screen point, that gecko can use.
    1: static inline void
    1: ConvertCocoaToGeckoPoint(NSPoint &aInPoint, nsPoint &aOutPoint)
    1: {
    1:   float mainScreenHeight = [(NSView*)[[NSScreen screens] objectAtIndex:0] frame].size.height;
    1:   aOutPoint.MoveTo ((nscoord)aInPoint.x, (nscoord)(mainScreenHeight - aInPoint.y));
    1: }
    1: 
    1: // returns the passed in object if it is not ignored. if it's ignored, will return
    1: // the first unignored ancestor.
    1: static inline id
    1: GetClosestInterestingAccessible(id anObject)
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   // this object is not ignored, so let's return it.
    1:   if (![anObject accessibilityIsIgnored])
    1:     return GetObjectOrRepresentedView(anObject);
    1:   
    1:   // find the closest ancestor that is not ignored.
    1:   id unignoredObject = anObject;
    1:   while ((unignoredObject = [unignoredObject accessibilityAttributeValue:NSAccessibilityParentAttribute])) {
    1:     if (![unignoredObject accessibilityIsIgnored])
    1:       // object is not ignored, so let's stop the search.
    1:       break;
    1:   }
    1:   
    1:   // if it's a mozAccessible, we need to take care to maybe return the view we
    1:   // represent, to the AT.
    1:   if ([unignoredObject respondsToSelector:@selector(hasRepresentedView)])
    1:     return GetObjectOrRepresentedView(unignoredObject);
    1:   
    1:   return unignoredObject;
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: static inline mozAccessible* 
    1: GetNativeFromGeckoAccessible(nsIAccessible *anAccessible)
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSNULL;
12110: 
    1:   mozAccessible *native = nil;
    1:   anAccessible->GetNativeInterface ((void**)&native);
    1:   return native;
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NSNULL;
    1: }
    1: 
    1: #pragma mark -
    1: 
    1: @implementation mozAccessible
    1:  
    1: - (id)initWithAccessible:(nsAccessibleWrap*)geckoAccessible
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   if ((self = [super init])) {
    1:     mGeckoAccessible = geckoAccessible;
    1:     mIsExpired = NO;
52053:     mRole = geckoAccessible->Role();
    1:   }
    1:    
    1:   return self;
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (void)dealloc
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1:   [mChildren release];
    1:   [super dealloc];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1:  
    1: #pragma mark -
    1: 
    1: - (BOOL)accessibilityIsIgnored
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
12110: 
    1:   // unknown (either unimplemented, or irrelevant) elements are marked as ignored
    1:   // as well as expired elements.
    1:   return mIsExpired || [[self role] isEqualToString:NSAccessibilityUnknownRole];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
    1: }
    1: 
    1: - (NSArray*)accessibilityAttributeNames
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   // if we're expired, we don't support any attributes.
    1:   if (mIsExpired)
    1:     return [NSArray array];
    1:   
    1:   static NSArray *generalAttributes = nil;
    1:   
    1:   if (!generalAttributes) {
    1:     // standard attributes that are shared and supported by all generic elements.
    1:     generalAttributes = [[NSArray alloc] initWithObjects:  NSAccessibilityChildrenAttribute, 
    1:                                                            NSAccessibilityParentAttribute,
    1:                                                            NSAccessibilityRoleAttribute,
    1:                                                            NSAccessibilityTitleAttribute,
    1:                                                            NSAccessibilityValueAttribute,
    1:                                                            NSAccessibilitySubroleAttribute,
    1:                                                            NSAccessibilityRoleDescriptionAttribute,
    1:                                                            NSAccessibilityPositionAttribute,
    1:                                                            NSAccessibilityEnabledAttribute,
    1:                                                            NSAccessibilitySizeAttribute,
    1:                                                            NSAccessibilityWindowAttribute,
    1:                                                            NSAccessibilityFocusedAttribute,
    1:                                                            NSAccessibilityHelpAttribute,
    1:                                                            NSAccessibilityTitleUIElementAttribute,
84355:                                                            NSAccessibilityTopLevelUIElementAttribute,
84355:                                                            NSAccessibilityDescriptionAttribute,
88363: #if DEBUG
88363:                                                            @"AXMozDescription",
88363: #endif
    1:                                                            nil];
    1:   }
    1: 
    1:   return generalAttributes;
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (id)accessibilityAttributeValue:(NSString*)attribute
    1: {  
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   if (mIsExpired)
    1:     return nil;
    1: 
88363: #if DEBUG
88363:   if ([attribute isEqualToString:@"AXMozDescription"])
88415:     return [NSString stringWithFormat:@"role = %u native = %@", mRole, [self class]];
88363: #endif
88363:   
    1:   if ([attribute isEqualToString:NSAccessibilityChildrenAttribute])
    1:     return [self children];
    1:   if ([attribute isEqualToString:NSAccessibilityParentAttribute]) 
    1:     return [self parent];
    1:   
    1: #ifdef DEBUG_hakan
    1:   NSLog (@"(%@ responding to attr %@)", self, attribute);
    1: #endif
    1: 
    1:   if ([attribute isEqualToString:NSAccessibilityRoleAttribute])
    1:     return [self role];
    1:   if ([attribute isEqualToString:NSAccessibilityPositionAttribute]) 
    1:     return [self position];
    1:   if ([attribute isEqualToString:NSAccessibilitySubroleAttribute])
    1:     return [self subrole];
    1:   if ([attribute isEqualToString:NSAccessibilityEnabledAttribute])
    1:     return [NSNumber numberWithBool:[self isEnabled]];
    1:   if ([attribute isEqualToString:NSAccessibilityValueAttribute])
    1:     return [self value];
95643:   if ([attribute isEqualToString:NSAccessibilityRoleDescriptionAttribute]) 
95643:     return [self roleDescription];  
84355:   if ([attribute isEqualToString:NSAccessibilityDescriptionAttribute])
    1:     return [self customDescription];
    1:   if ([attribute isEqualToString:NSAccessibilityFocusedAttribute])
    1:     return [NSNumber numberWithBool:[self isFocused]];
    1:   if ([attribute isEqualToString:NSAccessibilitySizeAttribute])
    1:     return [self size];
    1:   if ([attribute isEqualToString:NSAccessibilityWindowAttribute])
    1:     return [self window];
84355:   if ([attribute isEqualToString:NSAccessibilityTopLevelUIElementAttribute])
    1:     return [self window];
84308:   if ([attribute isEqualToString:NSAccessibilityTitleAttribute])
    1:     return [self title];
84308:   if ([attribute isEqualToString:NSAccessibilityTitleUIElementAttribute]) {
84308:     Relation rel = mGeckoAccessible->RelationByType(nsIAccessibleRelation::RELATION_LABELLED_BY);
84308:     nsAccessible* tempAcc = rel.Next();
84308:     return tempAcc ? GetNativeFromGeckoAccessible(tempAcc) : nil;
84308:   }
    1:   if ([attribute isEqualToString:NSAccessibilityHelpAttribute])
    1:     return [self help];
    1:     
    1: #ifdef DEBUG
    1:  NSLog (@"!!! %@ can't respond to attribute %@", self, attribute);
    1: #endif
84308:   return nil;
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (BOOL)accessibilityIsAttributeSettable:(NSString*)attribute
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
12110: 
    1:   if ([attribute isEqualToString:NSAccessibilityFocusedAttribute])
    1:     return [self canBeFocused];
    1:   
    1:   return NO;
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
    1: }
    1: 
    1: - (void)accessibilitySetValue:(id)value forAttribute:(NSString*)attribute
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1: #ifdef DEBUG_hakan
    1:   NSLog (@"[%@] %@='%@'", self, attribute, value);
    1: #endif
    1:   
    1:   // we only support focusing elements so far.
    1:   if ([attribute isEqualToString:NSAccessibilityFocusedAttribute] && [value boolValue])
    1:     [self focus];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (id)accessibilityHitTest:(NSPoint)point
    1: {
    1:   if (mIsExpired)
    1:     return nil;
    1: 
    1:   // Convert from cocoa's coordinate system to gecko's. According to the docs
    1:   // the point we're given is guaranteed to be bottom-left screen coordinates.
    1:   nsPoint geckoPoint;
    1:   ConvertCocoaToGeckoPoint (point, geckoPoint);
    1: 
19323:   nsCOMPtr<nsIAccessible> deepestFoundChild;
19323:   mGeckoAccessible->GetDeepestChildAtPoint((PRInt32)geckoPoint.x,
19323:                                            (PRInt32)geckoPoint.y,
19323:                                            getter_AddRefs(deepestFoundChild));
    1:   
    1:   // if we found something, return its native accessible.
    1:   if (deepestFoundChild) {
    1:     mozAccessible *nativeChild = GetNativeFromGeckoAccessible(deepestFoundChild);
    1:     if (nativeChild)
    1:       return GetClosestInterestingAccessible(nativeChild);
    1:   }
    1:   
    1:   // if we didn't find anything, return ourself (or the first unignored ancestor).
    1:   return GetClosestInterestingAccessible(self); 
    1: }
    1: 
    1: - (NSArray*)accessibilityActionNames 
    1: {
    1:   return nil;
    1: }
    1: 
    1: - (NSString*)accessibilityActionDescription:(NSString*)action 
    1: {
88415:   // by default we return whatever the MacOS API know about.
88415:   // if you have custom actions, override.
88415:   return NSAccessibilityActionDescription(action);
    1: }
    1: 
    1: - (void)accessibilityPerformAction:(NSString*)action 
    1: {
    1: }
    1: 
    1: - (id)accessibilityFocusedUIElement
    1: {
    1:   if (mIsExpired)
    1:     return nil;
    1:   
74619:   nsAccessible* focusedGeckoChild = mGeckoAccessible->FocusedChild();
    1:   if (focusedGeckoChild) {
    1:     mozAccessible *focusedChild = GetNativeFromGeckoAccessible(focusedGeckoChild);
    1:     if (focusedChild)
    1:       return GetClosestInterestingAccessible(focusedChild);
    1:   }
    1:   
    1:   // return ourself if we can't get a native focused child.
    1:   return GetClosestInterestingAccessible(self);
    1: }
    1: 
    1: #pragma mark -
    1: 
    1: - (id <mozAccessible>)parent
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
94578:   nsAccessible* accessibleParent = mGeckoAccessible->GetUnignoredParent();
    1:   if (accessibleParent) {
    1:     id nativeParent = GetNativeFromGeckoAccessible(accessibleParent);
84357:     if (nativeParent)
94859:       return GetClosestInterestingAccessible(nativeParent);
84309:   }
    1:   
    1:   // GetUnignoredParent() returns null when there is no unignored accessible all the way up to
    1:   // the root accessible. so we'll have to return whatever native accessible is above our root accessible 
    1:   // (which might be the owning NSWindow in the application, for example).
    1:   //
    1:   // get the native root accessible, and tell it to return its first parent unignored accessible.
97643:   RootAccessible* root = mGeckoAccessible->RootAccessible();
 3233:   id nativeParent = GetNativeFromGeckoAccessible(static_cast<nsIAccessible*>(root));
    1:   NSAssert1 (nativeParent, @"!!! we can't find a parent for %@", self);
    1:   
94859:   return GetClosestInterestingAccessible(nativeParent);
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (BOOL)hasRepresentedView
    1: {
    1:   return NO;
    1: }
    1: 
    1: - (id)representedView
    1: {
    1:   return nil;
    1: }
    1: 
    1: - (BOOL)isRoot
    1: {
    1:   return NO;
    1: }
    1: 
    1: // gets our native children lazily.
    1: // returns nil when there are no children.
    1: - (NSArray*)children
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
83480:   if (mChildren || !mGeckoAccessible->AreChildrenCached())
    1:     return mChildren;
    1: 
    1:   mChildren = [[NSMutableArray alloc] init];
    1: 
    1:   // get the array of children.
94645:   nsAutoTArray<nsAccessible*, 10> childrenArray;
94645:   mGeckoAccessible->GetUnignoredChildren(&childrenArray);
    1: 
    1:   // now iterate through the children array, and get each native accessible.
94645:   PRUint32 totalCount = childrenArray.Length();
94645:   for (PRUint32 idx = 0; idx < totalCount; idx++) {
94645:     nsAccessible* curAccessible = childrenArray.ElementAt(idx);
    1:     if (curAccessible) {
    1:       mozAccessible *curNative = GetNativeFromGeckoAccessible(curAccessible);
    1:       if (curNative)
    1:         [mChildren addObject:GetObjectOrRepresentedView(curNative)];
    1:     }
    1:   }
    1:   
    1: #ifdef DEBUG_hakan
    1:   // make sure we're not returning any ignored accessibles.
    1:   NSEnumerator *e = [mChildren objectEnumerator];
    1:   mozAccessible *m = nil;
    1:   while ((m = [e nextObject])) {
    1:     NSAssert1(![m accessibilityIsIgnored], @"we should never return an ignored accessible! (%@)", m);
    1:   }
    1: #endif
    1:   
    1:   return mChildren;
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (NSValue*)position
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   PRInt32 x, y, width, height;
    1:   mGeckoAccessible->GetBounds (&x, &y, &width, &height);
    1:   NSPoint p = NSMakePoint (x, y);
    1:   
    1:   // The coords we get from Gecko are top-left screen coordinates.
    1:   // Cocoa wants us to return bottom-left screen coordinates.
    1:   // This involves two steps:
    1:   // 1. Put the rect in the bottom-left coord space
    1:   // 2. Subtract the height of the rect's Y-coordinate, to make the
    1:   //    the rect's origin (0, 0) be in the bottom-left corner.
    1:   
    1:   float mainScreenHeight = [[[NSScreen screens] objectAtIndex:0] frame].size.height;
    1:   p.y = mainScreenHeight - p.y - height;
    1:   
    1:   return [NSValue valueWithPoint:p];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (NSValue*)size
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   PRInt32 x, y, width, height;
    1:   mGeckoAccessible->GetBounds (&x, &y, &width, &height);  
    1:   return [NSValue valueWithSize:NSMakeSize (width, height)];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (NSString*)role
    1: {
99425:   if (mIsExpired)
99425:     return nil;
99425: 
97936: #ifdef DEBUG
20566:   NS_ASSERTION(nsAccUtils::IsTextInterfaceSupportCorrect(mGeckoAccessible),
20566:                "Does not support nsIAccessibleText when it should");
    1: #endif
97224: 
97224: #define ROLE(geckoRole, stringRole, atkRole, macRole, msaaRole, ia2Role) \
97224:   case roles::geckoRole: \
97224:     return macRole;
97224: 
97224:   switch (mRole) {
97224: #include "RoleMap.h"
97224:     default:
97224:       NS_NOTREACHED("Unknown role.");
97224:       return NSAccessibilityUnknownRole;
97224:   }
97224: 
97224: #undef ROLE
    1: }
    1: 
    1: - (NSString*)subrole
    1: {
95372:   switch (mRole) {
95372:     case roles::LIST:
98252:       return @"AXContentList"; // 10.6+ NSAccessibilityContentListSubrole;
95372: 
96810:     case roles::DEFINITION_LIST:
98252:       return @"AXDefinitionList"; // 10.6+ NSAccessibilityDefinitionListSubrole;
95372: 
96810:     case roles::TERM:
95372:       return @"AXTerm";
95372: 
96810:     case roles::DEFINITION:
95372:       return @"AXDefinition";
95372: 
95372:     default:
95372:       break;
95372:   }
95372: 
    1:   return nil;
    1: }
    1: 
95643: - (NSString*)roleDescription
95643: {
95643:   if (mRole == roles::DOCUMENT)
95643:     return utils::LocalizedString(NS_LITERAL_STRING("htmlContent"));
95643:   
95643:   NSString* subrole = [self subrole];
95643:   
95643:   if ((mRole == roles::LISTITEM) && [subrole isEqualToString:@"AXTerm"])
95643:     return utils::LocalizedString(NS_LITERAL_STRING("term"));
95643:   if ((mRole == roles::PARAGRAPH) && [subrole isEqualToString:@"AXDefinition"])
95643:     return utils::LocalizedString(NS_LITERAL_STRING("definition"));
95643:   
95643:   return NSAccessibilityRoleDescription([self role], subrole);
95643: }
95643: 
    1: - (NSString*)title
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   nsAutoString title;
97369:   mGeckoAccessible->Name(title);
    1:   return title.IsEmpty() ? nil : [NSString stringWithCharacters:title.BeginReading() length:title.Length()];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (id)value
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   nsAutoString value;
    1:   mGeckoAccessible->GetValue (value);
    1:   return value.IsEmpty() ? nil : [NSString stringWithCharacters:value.BeginReading() length:value.Length()];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (void)valueDidChange
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1: #ifdef DEBUG_hakan
    1:   NSLog(@"%@'s value changed!", self);
    1: #endif
    1:   // sending out a notification is expensive, so we don't do it other than for really important objects,
    1:   // like mozTextAccessible.
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
94588: - (void)selectedTextDidChange
94588: {
94588:   // Do nothing. mozTextAccessible will.
94588: }
94588: 
    1: - (NSString*)customDescription
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
69342:   if (mGeckoAccessible->IsDefunct())
69342:     return nil;
69342: 
    1:   nsAutoString desc;
69342:   mGeckoAccessible->Description(desc);
    1:   return desc.IsEmpty() ? nil : [NSString stringWithCharacters:desc.BeginReading() length:desc.Length()];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (NSString*)help
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   nsAutoString helpText;
    1:   mGeckoAccessible->GetHelp (helpText);
    1:   return helpText.IsEmpty() ? nil : [NSString stringWithCharacters:helpText.BeginReading() length:helpText.Length()];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: // objc-style description (from NSObject); not to be confused with the accessible description above.
    1: - (NSString*)description
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
    1:   return [NSString stringWithFormat:@"(%p) %@", self, [self role]];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (BOOL)isFocused
    1: {
67790:   return (mGeckoAccessible->State() & states::FOCUSED) != 0;
    1: }
    1: 
    1: - (BOOL)canBeFocused
    1: {
67790:   return mGeckoAccessible->State() & states::FOCUSABLE;
    1: }
    1: 
    1: - (BOOL)focus
    1: {
    1:   nsresult rv = mGeckoAccessible->TakeFocus();
    1:   return NS_SUCCEEDED(rv);
    1: }
    1: 
    1: - (BOOL)isEnabled
    1: {
67790:   return (mGeckoAccessible->State() & states::UNAVAILABLE) == 0;
    1: }
    1: 
    1: // The root accessible calls this when the focused node was
    1: // changed to us.
    1: - (void)didReceiveFocus
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1: #ifdef DEBUG_hakan
    1:   NSLog (@"%@ received focus!", self);
    1: #endif
    1:   NSAssert1(![self accessibilityIsIgnored], @"trying to set focus to ignored element! (%@)", self);
    1:   NSAccessibilityPostNotification(GetObjectOrRepresentedView(self),
    1:                                   NSAccessibilityFocusedUIElementChangedNotification);
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (NSWindow*)window
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
12110: 
 3233:   nsAccessibleWrap *accWrap = static_cast<nsAccessibleWrap*>(mGeckoAccessible);
54220: 
54220:   // Get a pointer to the native window (NSWindow) we reside in.
    1:   NSWindow *nativeWindow = nil;
89800:   nsDocAccessible* docAcc = accWrap->Document();
54220:   if (docAcc)
54220:     nativeWindow = static_cast<NSWindow*>(docAcc->GetNativeWindow());
    1: 
    1:   NSAssert1(nativeWindow, @"Could not get native window for %@", self);
    1:   return nativeWindow;
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (void)invalidateChildren
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1:   // make room for new children
    1:   [mChildren release];
    1:   mChildren = nil;
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
86113: - (void)appendChild:(nsAccessible*)aAccessible
86113: {
86113:   // if mChildren is nil, then we don't even need to bother
86113:   if (!mChildren)
86113:     return;
86113:     
86113:   mozAccessible *curNative = GetNativeFromGeckoAccessible(aAccessible);
86113:   if (curNative)
86113:     [mChildren addObject:GetObjectOrRepresentedView(curNative)];
86113: }
86113: 
    1: - (void)expire
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1:   [self invalidateChildren];
99425: 
    1:   mIsExpired = YES;
99425:   mGeckoAccessible = nsnull;
12110:   
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (BOOL)isExpired
    1: {
    1:   return mIsExpired;
    1: }
    1: 
    1: #pragma mark -
    1: #pragma mark Debug methods
    1: #pragma mark -
    1: 
    1: #ifdef DEBUG
    1: 
    1: // will check that our children actually reference us as their
    1: // parent.
    1: - (void)sanityCheckChildren:(NSArray *)children
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1:   NSAssert(![self accessibilityIsIgnored], @"can't sanity check children of an ignored accessible!");
    1:   NSEnumerator *iter = [children objectEnumerator];
    1:   mozAccessible *curObj = nil;
    1:   
    1:   NSLog(@"sanity checking %@", self);
    1:   
    1:   while ((curObj = [iter nextObject])) {
    1:     id realSelf = GetObjectOrRepresentedView(self);
    1:     NSLog(@"checking %@", realSelf);
    1:     NSAssert2([curObj parent] == realSelf, 
    1:               @"!!! %@ not returning %@ as AXParent, even though it is a AXChild of it!", curObj, realSelf);
    1:   }
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)sanityCheckChildren
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1:   [self sanityCheckChildren:[self children]];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)printHierarchy
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1:   [self printHierarchyWithLevel:0];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: - (void)printHierarchyWithLevel:(unsigned)level
    1: {
12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
12110: 
    1:   NSAssert(![self isExpired], @"!!! trying to print hierarchy of expired object!");
    1:   
    1:   // print this node
    1:   NSMutableString *indent = [NSMutableString stringWithCapacity:level];
    1:   unsigned i=0;
    1:   for (;i<level;i++)
    1:     [indent appendString:@" "];
    1:   
    1:   NSLog (@"%@(#%i) %@", indent, level, self);
    1:   
    1:   // use |children| method to make sure our children are lazily fetched first.
    1:   NSArray *children = [self children];
    1:   if (!children)
    1:     return;
    1:     
    1:   if (![self accessibilityIsIgnored])
    1:     [self sanityCheckChildren];
    1:     
    1:   NSEnumerator *iter = [children objectEnumerator];
    1:   mozAccessible *object = nil;
    1:   
    1:   while (iter && (object = [iter nextObject]))
    1:     // print every child node's subtree, increasing the indenting
    1:     // by two for every level.
    1:     [object printHierarchyWithLevel:(level+1)];
12110: 
12110:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: #endif /* DEBUG */
    1: 
    1: @end
