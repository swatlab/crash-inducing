     1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef nsNavBookmarks_h_
     1: #define nsNavBookmarks_h_
     1: 
     1: #include "nsINavBookmarksService.h"
  1337: #include "nsIAnnotationService.h"
     1: #include "nsITransaction.h"
     1: #include "nsNavHistory.h"
     1: #include "nsToolkitCompsCID.h"
 30050: #include "nsCategoryCache.h"
 69986: #include "nsTHashtable.h"
 80946: #include "nsWeakReference.h"
104136: #include "mozilla/Attributes.h"
 80946: 
 80946: class nsNavBookmarks;
 80946: class nsIOutputStream;
     1: 
 39811: namespace mozilla {
 39811: namespace places {
 39811: 
 39811:   enum BookmarkStatementId {
 39811:     DB_FIND_REDIRECTED_BOOKMARK = 0
 60944:   , DB_GET_BOOKMARKS_FOR_URI
 39811:   };
 39811: 
 69981:   struct BookmarkData {
108991:     int64_t id;
 69981:     nsCString url;
 69981:     nsCString title;
108991:     int32_t position;
108991:     int64_t placeId;
108991:     int64_t parentId;
108991:     int64_t grandParentId;
108991:     int32_t type;
 69981:     nsCString serviceCID;
 69981:     PRTime dateAdded;
 69981:     PRTime lastModified;
 69981:     nsCString guid;
 69981:     nsCString parentGuid;
 69981:   };
 69981: 
 60944:   struct ItemVisitData {
 69981:     BookmarkData bookmark;
108991:     int64_t visitId;
108991:     uint32_t transitionType;
 60944:     PRTime time;
 60944:   };
 60944: 
 60944:   struct ItemChangeData {
 69981:     BookmarkData bookmark;
 60944:     nsCString property;
 79445:     bool isAnnotation;
 60944:     nsCString newValue;
 60944:   };
 60944: 
 61984:   typedef void (nsNavBookmarks::*ItemVisitMethod)(const ItemVisitData&);
 61984:   typedef void (nsNavBookmarks::*ItemChangeMethod)(const ItemChangeData&);
 60944: 
 69986:   class BookmarkKeyClass : public nsTrimInt64HashKey
 69986:   {
 69986:     public:
108991:     BookmarkKeyClass(const int64_t* aItemId)
 69986:     : nsTrimInt64HashKey(aItemId)
 69986:     , creationTime(PR_Now())
 69986:     {
 69986:     }
 69986:     BookmarkKeyClass(const BookmarkKeyClass& aOther)
 69986:     : nsTrimInt64HashKey(aOther)
 69986:     , creationTime(PR_Now())
 69986:     {
 69986:       NS_NOTREACHED("Do not call me!");
 69986:     }
 69986:     BookmarkData bookmark;
 69986:     PRTime creationTime;
 69986:   };
 69986: 
 80946:   enum BookmarkDate {
 80946:     DATE_ADDED = 0
 80946:   , LAST_MODIFIED
 80946:   };
 80946: 
 39811: } // namespace places
 39811: } // namespace mozilla
 39811: 
104136: class nsNavBookmarks MOZ_FINAL : public nsINavBookmarksService
 80946:                                , public nsINavHistoryObserver
 80946:                                , public nsIAnnotationObserver
 80946:                                , public nsIObserver
 80946:                                , public nsSupportsWeakReference
     1: {
     1: public:
     1:   NS_DECL_ISUPPORTS
     1:   NS_DECL_NSINAVBOOKMARKSSERVICE
     1:   NS_DECL_NSINAVHISTORYOBSERVER
  1337:   NS_DECL_NSIANNOTATIONOBSERVER
 69986:   NS_DECL_NSIOBSERVER
     1: 
     1:   nsNavBookmarks();
 35298: 
 35298:   /**
 35298:    * Obtains the service's object.
 35298:    */
 35298:   static nsNavBookmarks* GetSingleton();
 35298: 
 35298:   /**
 35298:    * Initializes the service's object.  This should only be called once.
 35298:    */
     1:   nsresult Init();
     1: 
 78601:   static nsNavBookmarks* GetBookmarksServiceIfAvailable() {
 78601:     return gBookmarksService;
 78601:   }
 78601: 
     1:   static nsNavBookmarks* GetBookmarksService() {
 35298:     if (!gBookmarksService) {
 35298:       nsCOMPtr<nsINavBookmarksService> serv =
 35298:         do_GetService(NS_NAVBOOKMARKSSERVICE_CONTRACTID);
106838:       NS_ENSURE_TRUE(serv, nullptr);
 35298:       NS_ASSERTION(gBookmarksService,
 35298:                    "Should have static instance pointer now");
     1:     }
 35298:     return gBookmarksService;
     1:   }
     1: 
 69986:   typedef mozilla::places::BookmarkData BookmarkData;
 69986:   typedef mozilla::places::BookmarkKeyClass BookmarkKeyClass;
 69986:   typedef mozilla::places::ItemVisitData ItemVisitData;
 69986:   typedef mozilla::places::ItemChangeData ItemChangeData;
 69986:   typedef mozilla::places::BookmarkStatementId BookmarkStatementId;
 69986: 
108991:   nsresult ResultNodeForContainer(int64_t aID,
 37340:                                   nsNavHistoryQueryOptions* aOptions,
     1:                                   nsNavHistoryResultNode** aNode);
     1: 
     1:   // Find all the children of a folder, using the given query and options.
     1:   // For each child, a ResultNode is created and added to |children|.
     1:   // The results are ordered by folder position.
108991:   nsresult QueryFolderChildren(int64_t aFolderId,
     1:                                nsNavHistoryQueryOptions* aOptions,
     1:                                nsCOMArray<nsNavHistoryResultNode>* children);
     1: 
 40626:   /**
 40626:    * Turns aRow into a node and appends it to aChildren if it is appropriate to
 40626:    * do so.
 40626:    *
 40626:    * @param aRow
 40626:    *        A Storage statement (in the case of synchronous execution) or row of
 40626:    *        a result set (in the case of asynchronous execution).
 40626:    * @param aOptions
 40626:    *        The options of the parent folder node.
 40626:    * @param aChildren
 40626:    *        The children of the parent folder node.
 40626:    * @param aCurrentIndex
 40626:    *        The index of aRow within the results.  When called on the first row,
 40626:    *        this should be set to -1.
 40626:    */
 40626:   nsresult ProcessFolderNodeRow(mozIStorageValueArray* aRow,
 40626:                                 nsNavHistoryQueryOptions* aOptions,
 40626:                                 nsCOMArray<nsNavHistoryResultNode>* aChildren,
108991:                                 int32_t& aCurrentIndex);
 40626: 
 40626:   /**
 40626:    * The async version of QueryFolderChildren.
 40626:    *
 40626:    * @param aNode
 40626:    *        The folder node that will receive the children.
 40626:    * @param _pendingStmt
 40626:    *        The Storage pending statement that will be used to control async
 40626:    *        execution.
 40626:    */
 40626:   nsresult QueryFolderChildrenAsync(nsNavHistoryFolderResultNode* aNode,
108991:                                     int64_t aFolderId,
 40626:                                     mozIStoragePendingStatement** _pendingStmt);
 40626: 
 81038:   /**
 81038:    * @return index of the new folder in aIndex, whether it was passed in or
 81038:    *         generated by autoincrement.
 81038:    *
 81038:    * @note If aFolder is -1, uses the autoincrement id for folder index.
 81038:    * @note aTitle will be truncated to TITLE_LENGTH_MAX
 81038:    */
108991:   nsresult CreateContainerWithID(int64_t aId, int64_t aParent,
 69981:                                  const nsACString& aTitle,
 79445:                                  bool aIsBookmarkFolder,
108991:                                  int32_t* aIndex,
108991:                                  int64_t* aNewFolder);
     1: 
 24324:   /**
 69981:    * Fetches information about the specified id from the database.
 69981:    *
 69981:    * @param aItemId
 69981:    *        Id of the item to fetch information for.
 69981:    * @param aBookmark
 69981:    *        BookmarkData to store the information.
 69981:    */
108991:   nsresult FetchItemInfo(int64_t aItemId,
 76962:                          BookmarkData& _bookmark);
  2780: 
 21642:   /**
 60944:    * Notifies that a bookmark has been visited.
 60944:    *
 60944:    * @param aItemId
 60944:    *        The visited item id.
 60944:    * @param aData
 60944:    *        Details about the new visit.
 60944:    */
 69986:   void NotifyItemVisited(const ItemVisitData& aData);
 60944: 
 60944:   /**
 60944:    * Notifies that a bookmark has changed.
 60944:    *
 60944:    * @param aItemId
 60944:    *        The changed item id.
 60944:    * @param aData
 60944:    *        Details about the change.
 60944:    */
 69986:   void NotifyItemChanged(const ItemChangeData& aData);
 60944: 
 90949:   /**
 90949:    * Recursively builds an array of descendant folders inside a given folder.
 90949:    *
 90949:    * @param aFolderId
 90949:    *        The folder to fetch descendants from.
 90949:    * @param aDescendantFoldersArray
 90949:    *        Output array to put descendant folders id.
 90949:    */
108991:   nsresult GetDescendantFolders(int64_t aFolderId,
108991:                                 nsTArray<int64_t>& aDescendantFoldersArray);
 90949: 
     1: private:
 35298:   static nsNavBookmarks* gBookmarksService;
     1: 
     1:   ~nsNavBookmarks();
     1: 
 59312:   /**
 59312:    * Locates the root items in the bookmarks folder hierarchy assigning folder
 59312:    * ids to the root properties that are exposed through the service interface.
 59312:    */
 84844:   nsresult ReadRoots();
     1: 
108991:   nsresult AdjustIndices(int64_t aFolder,
108991:                          int32_t aStartIndex,
108991:                          int32_t aEndIndex,
108991:                          int32_t aDelta);
 31729: 
 31729:   /**
 69981:    * Fetches properties of a folder.
 31729:    *
 69981:    * @param aFolderId
 69981:    *        Folder to count children for.
 69981:    * @param _folderCount
 69981:    *        Number of children in the folder.
 69981:    * @param _guid
 69981:    *        Unique id of the folder.
 69981:    * @param _parentId
 69981:    *        Id of the parent of the folder.
 31729:    *
 31729:    * @throws If folder does not exist.
 31729:    */
108991:   nsresult FetchFolderInfo(int64_t aFolderId,
108991:                            int32_t* _folderCount,
 69981:                            nsACString& _guid,
108991:                            int64_t* _parentId);
 31729: 
108991:   nsresult GetLastChildId(int64_t aFolder, int64_t* aItemId);
 11268: 
 59362:   /**
 80946:    * This is an handle to the Places database.
 59362:    */
 80946:   nsRefPtr<mozilla::places::Database> mDB;
     1: 
108991:   int32_t mItemCount;
  4004: 
     1:   nsMaybeWeakPtrArray<nsINavBookmarkObserver> mObservers;
 59312: 
108991:   int64_t mRoot;
108991:   int64_t mMenuRoot;
108991:   int64_t mTagsRoot;
108991:   int64_t mUnfiledRoot;
108991:   int64_t mToolbarRoot;
     1: 
126144:   inline bool IsRoot(int64_t aFolderId) {
126144:     return aFolderId == mRoot || aFolderId == mMenuRoot ||
126144:            aFolderId == mTagsRoot || aFolderId == mUnfiledRoot ||
126144:            aFolderId == mToolbarRoot;
126144:   }
126144: 
108991:   nsresult IsBookmarkedInDatabase(int64_t aBookmarkID, bool* aIsBookmarked);
     1: 
 80946:   nsresult SetItemDateInternal(enum mozilla::places::BookmarkDate aDateType,
108991:                                int64_t aItemId,
 37340:                                PRTime aValue);
 13203: 
 21350:   // Recursive method to build an array of folder's children
108991:   nsresult GetDescendantChildren(int64_t aFolderId,
 69981:                                  const nsACString& aFolderGuid,
108991:                                  int64_t aGrandParentId,
 69986:                                  nsTArray<BookmarkData>& aFolderChildrenArray);
 21350: 
 29518:   enum ItemType {
 29518:     BOOKMARK = TYPE_BOOKMARK,
 29518:     FOLDER = TYPE_FOLDER,
 29518:     SEPARATOR = TYPE_SEPARATOR,
 29518:   };
 29518: 
 29518:   /**
 29518:    * Helper to insert a bookmark in the database.
 29518:    *
 29518:    *  @param aItemId
 29518:    *         The itemId to insert, pass -1 to generate a new one.
 29518:    *  @param aPlaceId
106838:    *         The placeId to which this bookmark refers to, pass nullptr for
 29518:    *         items that don't refer to an URI (eg. folders, separators, ...).
 29518:    *  @param aItemType
 29518:    *         The type of the new bookmark, see TYPE_* constants.
 29518:    *  @param aParentId
 29518:    *         The itemId of the parent folder.
 29518:    *  @param aIndex
 29518:    *         The position inside the parent folder.
 29518:    *  @param aTitle
 29518:    *         The title for the new bookmark.
 29518:    *         Pass a void string to set a NULL title.
 29518:    *  @param aDateAdded
 29518:    *         The date for the insertion.
 29518:    *  @param [optional] aLastModified
 29518:    *         The last modified date for the insertion.
 29518:    *         It defaults to aDateAdded.
 29518:    *
 29518:    *  @return The new item id that has been inserted.
 29518:    *
 29518:    *  @note This will also update last modified date of the parent folder.
 29518:    */
108991:   nsresult InsertBookmarkInDB(int64_t aPlaceId,
 29518:                               enum ItemType aItemType,
108991:                               int64_t aParentId,
108991:                               int32_t aIndex,
 29518:                               const nsACString& aTitle,
 29518:                               PRTime aDateAdded,
 29518:                               PRTime aLastModified,
 84189:                               const nsACString& aParentGuid,
108991:                               int64_t aGrandParentId,
 84189:                               nsIURI* aURI,
108991:                               int64_t* _itemId,
 69981:                               nsACString& _guid);
 29518: 
 34260:   /**
 34260:    * TArray version of getBookmarksIdForURI for ease of use in C++ code.
 34260:    * Pass in a reference to a TArray; it will get filled with the
 34260:    * resulting list of bookmark IDs.
 69683:    *
 69683:    * @param aURI
 69683:    *        URI to get bookmarks for.
 69683:    * @param aResult
 69683:    *        Array of bookmark ids.
 69683:    * @param aSkipTags
 69683:    *        If true ids of tags-as-bookmarks entries will be excluded.
 34260:    */
 34260:   nsresult GetBookmarkIdsForURITArray(nsIURI* aURI,
108991:                                       nsTArray<int64_t>& aResult,
 69683:                                       bool aSkipTags);
 34260: 
 69981:   nsresult GetBookmarksForURI(nsIURI* aURI,
 69986:                               nsTArray<BookmarkData>& _bookmarks);
 69981: 
108991:   int64_t RecursiveFindRedirectedBookmark(int64_t aPlaceId);
 37341: 
108991:   static const int32_t kGetChildrenIndex_Position;
108991:   static const int32_t kGetChildrenIndex_Type;
108991:   static const int32_t kGetChildrenIndex_PlaceID;
108991:   static const int32_t kGetChildrenIndex_FolderTitle;
108991:   static const int32_t kGetChildrenIndex_Guid;
     1: 
104136:   class RemoveFolderTransaction MOZ_FINAL : public nsITransaction {
     1:   public:
108991:     RemoveFolderTransaction(int64_t aID) : mID(aID) {}
     1: 
     1:     NS_DECL_ISUPPORTS
     1: 
     1:     NS_IMETHOD DoTransaction() {
     1:       nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
 35298:       NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
 69986:       BookmarkData folder;
 76962:       nsresult rv = bookmarks->FetchItemInfo(mID, folder);
 69981:       // TODO (Bug 656935): store the BookmarkData struct instead.
 69981:       mParent = folder.parentId;
 69981:       mIndex = folder.position;
 19158: 
 19158:       rv = bookmarks->GetItemTitle(mID, mTitle);
 19158:       NS_ENSURE_SUCCESS(rv, rv);
 19158: 
 69981:       return bookmarks->RemoveItem(mID);
     1:     }
     1: 
     1:     NS_IMETHOD UndoTransaction() {
     1:       nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
 35298:       NS_ENSURE_TRUE(bookmarks, NS_ERROR_OUT_OF_MEMORY);
108991:       int64_t newFolder;
 82903:       return bookmarks->CreateContainerWithID(mID, mParent, mTitle, true,
  4179:                                               &mIndex, &newFolder); 
     1:     }
     1: 
     1:     NS_IMETHOD RedoTransaction() {
     1:       return DoTransaction();
     1:     }
     1: 
 79445:     NS_IMETHOD GetIsTransient(bool* aResult) {
 80486:       *aResult = false;
     1:       return NS_OK;
     1:     }
     1:     
 79445:     NS_IMETHOD Merge(nsITransaction* aTransaction, bool* aResult) {
 80486:       *aResult = false;
     1:       return NS_OK;
     1:     }
     1: 
     1:   private:
108991:     int64_t mID;
108991:     int64_t mParent;
 10046:     nsCString mTitle;
108991:     int32_t mIndex;
     1:   };
 30050: 
 30050:   // Used to enable and disable the observer notifications.
 30050:   bool mCanNotify;
 30050:   nsCategoryCache<nsINavBookmarkObserver> mCacheObservers;
 37340: 
 59379:   // Tracks whether we are in batch mode.
 59379:   // Note: this is only tracking bookmarks batches, not history ones.
 59379:   bool mBatching;
 59379: 
 50437:   /**
 50437:    * Always call EnsureKeywordsHash() and check it for errors before actually
 50437:    * using the hash.  Internal keyword methods are already doing that.
 50437:    */
 50437:   nsresult EnsureKeywordsHash();
 50437:   nsDataHashtable<nsTrimInt64HashKey, nsString> mBookmarkToKeywordHash;
 50437: 
 50437:   /**
 50437:    * This function must be called every time a bookmark is removed.
 50437:    *
 50437:    * @param aURI
 50437:    *        Uri to test.
 50437:    */
108991:   nsresult UpdateKeywordsHashForRemovedBookmark(int64_t aItemId);
 69986: 
 69986:   /**
 69986:    * Cache for the last fetched BookmarkData entries.
 69986:    * This is used to speed up repeated requests to the same item id.
 69986:    */
 69986:   nsTHashtable<BookmarkKeyClass> mRecentBookmarksCache;
 87168: 
 87168:   /**
 87168:    * Tracks bookmarks in the cache critical path.  Items should not be
 87168:    * added to the cache till they are removed from this hash.
 87168:    */
 87168:   nsTHashtable<nsTrimInt64HashKey> mUncachableBookmarks;
     1: };
     1: 
     1: #endif // nsNavBookmarks_h_
