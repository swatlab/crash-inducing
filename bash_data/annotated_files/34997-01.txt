    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * IBM Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Brian Ryner <bryner@brianryner.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* implementation of interface for managing user and user-agent style sheets */
    1: 
10144: #include "prlog.h"
    1: #include "nsStyleSheetService.h"
    1: #include "nsIStyleSheet.h"
    1: #include "nsICSSLoader.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsIURI.h"
    1: #include "nsContentCID.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIObserverService.h"
    1: 
    1: static NS_DEFINE_CID(kCSSLoaderCID, NS_CSS_LOADER_CID);
    1: 
    1: nsStyleSheetService *nsStyleSheetService::gInstance = nsnull;
    1: 
    1: nsStyleSheetService::nsStyleSheetService()
    1: {
10144:   PR_STATIC_ASSERT(0 == AGENT_SHEET && 1 == USER_SHEET);
    1:   NS_ASSERTION(!gInstance, "Someone is using CreateInstance instead of GetService");
    1:   gInstance = this;
34997:   nsLayoutStatics::AddRef();
    1: }
    1: 
    1: nsStyleSheetService::~nsStyleSheetService()
    1: {
    1:   gInstance = nsnull;
34997:   nsLayoutStatics::Release();
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsStyleSheetService, nsIStyleSheetService)
    1: 
    1: void
    1: nsStyleSheetService::RegisterFromEnumerator(nsICategoryManager  *aManager,
    1:                                             const char          *aCategory,
    1:                                             nsISimpleEnumerator *aEnumerator,
    1:                                             PRUint32             aSheetType)
    1: {
    1:   if (!aEnumerator)
    1:     return;
    1: 
    1:   PRBool hasMore;
    1:   while (NS_SUCCEEDED(aEnumerator->HasMoreElements(&hasMore)) && hasMore) {
    1:     nsCOMPtr<nsISupports> element;
    1:     if (NS_FAILED(aEnumerator->GetNext(getter_AddRefs(element))))
    1:       break;
    1: 
    1:     nsCOMPtr<nsISupportsCString> icStr = do_QueryInterface(element);
    1:     NS_ASSERTION(icStr,
    1:                  "category manager entries must be nsISupportsCStrings");
    1: 
    1:     nsCAutoString name;
    1:     icStr->GetData(name);
    1: 
    1:     nsXPIDLCString spec;
    1:     aManager->GetCategoryEntry(aCategory, name.get(), getter_Copies(spec));
    1: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     NS_NewURI(getter_AddRefs(uri), spec);
    1:     if (uri)
    1:       LoadAndRegisterSheetInternal(uri, aSheetType);
    1:   }
    1: }
    1: 
    1: PRInt32
    1: nsStyleSheetService::FindSheetByURI(const nsCOMArray<nsIStyleSheet> &sheets,
    1:                                     nsIURI *sheetURI)
    1: {
    1:   for (PRInt32 i = sheets.Count() - 1; i >= 0; i-- ) {
    1:     PRBool bEqual;
    1:     nsCOMPtr<nsIURI> uri;
    1:     if (NS_SUCCEEDED(sheets[i]->GetSheetURI(getter_AddRefs(uri)))
    1:         && uri
    1:         && NS_SUCCEEDED(uri->Equals(sheetURI, &bEqual))
    1:         && bEqual) {
    1:       return i;
    1:     }
    1:   }
    1: 
    1:   return -1;
    1: }
    1: 
    1: nsresult
    1: nsStyleSheetService::Init()
    1: {
    1:   // Enumerate all of the style sheet URIs registered in the category
    1:   // manager and load them.
    1: 
    1:   nsCOMPtr<nsICategoryManager> catMan =
    1:     do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
    1: 
    1:   NS_ENSURE_TRUE(catMan, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsCOMPtr<nsISimpleEnumerator> sheets;
    1:   catMan->EnumerateCategory("agent-style-sheets", getter_AddRefs(sheets));
    1:   RegisterFromEnumerator(catMan, "agent-style-sheets", sheets, AGENT_SHEET);
    1: 
    1:   catMan->EnumerateCategory("user-style-sheets", getter_AddRefs(sheets));
    1:   RegisterFromEnumerator(catMan, "user-style-sheets", sheets, USER_SHEET);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsStyleSheetService::LoadAndRegisterSheet(nsIURI *aSheetURI,
    1:                                           PRUint32 aSheetType)
    1: {
    1:   nsresult rv = LoadAndRegisterSheetInternal(aSheetURI, aSheetType);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     const char* message = (aSheetType == AGENT_SHEET) ?
    1:       "agent-sheet-added" : "user-sheet-added";
    1:     nsCOMPtr<nsIObserverService> serv =
    1:       do_GetService("@mozilla.org/observer-service;1");
    1:     if (serv) {
    1:       // We're guaranteed that the new sheet is the last sheet in
    1:       // mSheets[aSheetType]
    1:       const nsCOMArray<nsIStyleSheet> & sheets = mSheets[aSheetType];
    1:       serv->NotifyObservers(sheets[sheets.Count() - 1], message, nsnull);
    1:     }
    1:   }
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsStyleSheetService::LoadAndRegisterSheetInternal(nsIURI *aSheetURI,
    1:                                                   PRUint32 aSheetType)
    1: {
    1:   NS_ENSURE_ARG(aSheetType == AGENT_SHEET || aSheetType == USER_SHEET);
    1:   NS_ENSURE_ARG_POINTER(aSheetURI);
    1: 
    1:   nsCOMPtr<nsICSSLoader> loader = do_CreateInstance(kCSSLoaderCID);
    1:   nsCOMPtr<nsICSSStyleSheet> sheet;
    1:   // Allow UA sheets, but not user sheets, to use unsafe rules
    1:   nsresult rv = loader->LoadSheetSync(aSheetURI, aSheetType == AGENT_SHEET,
26242:                                       PR_TRUE, getter_AddRefs(sheet));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!mSheets[aSheetType].AppendObject(sheet)) {
    1:     rv = NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsStyleSheetService::SheetRegistered(nsIURI *sheetURI,
    1:                                      PRUint32 aSheetType, PRBool *_retval)
    1: {
    1:   NS_ENSURE_ARG(aSheetType == AGENT_SHEET || aSheetType == USER_SHEET);
    1:   NS_ENSURE_ARG_POINTER(sheetURI);
    1:   NS_PRECONDITION(_retval, "Null out param");
    1: 
    1:   *_retval = (FindSheetByURI(mSheets[aSheetType], sheetURI) >= 0);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsStyleSheetService::UnregisterSheet(nsIURI *sheetURI, PRUint32 aSheetType)
    1: {
    1:   NS_ENSURE_ARG(aSheetType == AGENT_SHEET || aSheetType == USER_SHEET);
    1:   NS_ENSURE_ARG_POINTER(sheetURI);
    1: 
    1:   PRInt32 foundIndex = FindSheetByURI(mSheets[aSheetType], sheetURI);
    1:   NS_ENSURE_TRUE(foundIndex >= 0, NS_ERROR_INVALID_ARG);
    1:   nsCOMPtr<nsIStyleSheet> sheet = mSheets[aSheetType][foundIndex];
    1:   mSheets[aSheetType].RemoveObjectAt(foundIndex);
    1:   
    1:   const char* message = (aSheetType == AGENT_SHEET) ?
    1:       "agent-sheet-removed" : "user-sheet-removed";
    1:   nsCOMPtr<nsIObserverService> serv =
    1:     do_GetService("@mozilla.org/observer-service;1");
    1:   if (serv) {
    1:     serv->NotifyObservers(sheet, message, nsnull);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
