35734: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35734:  * vim: sw=4 ts=4 et :
35734:  * ***** BEGIN LICENSE BLOCK *****
35734:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35734:  *
35734:  * The contents of this file are subject to the Mozilla Public License Version
35734:  * 1.1 (the "License"); you may not use this file except in compliance with
35734:  * the License. You may obtain a copy of the License at
35734:  * http://www.mozilla.org/MPL/
35734:  *
35734:  * Software distributed under the License is distributed on an "AS IS" basis,
35734:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35734:  * for the specific language governing rights and limitations under the
35734:  * License.
35734:  *
35734:  * The Original Code is Mozilla Plugin App.
35734:  *
35734:  * The Initial Developer of the Original Code is
35734:  *   Chris Jones <jones.chris.g@gmail.com>
35734:  * Portions created by the Initial Developer are Copyright (C) 2009
35734:  * the Initial Developer. All Rights Reserved.
35734:  *
35734:  * Contributor(s):
35734:  *
35734:  * Alternatively, the contents of this file may be used under the terms of
35734:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35734:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35734:  * in which case the provisions of the GPL or the LGPL are applicable instead
35734:  * of those above. If you wish to allow use of your version of this file only
35734:  * under the terms of either the GPL or the LGPL, and not to allow others to
35734:  * use your version of this file under the terms of the MPL, indicate your
35734:  * decision by deleting the provisions above and replace them with the notice
35734:  * and other provisions required by the GPL or the LGPL. If you do not delete
35734:  * the provisions above, a recipient may use your version of this file under
35734:  * the terms of any one of the MPL, the GPL or the LGPL.
35734:  *
35734:  * ***** END LICENSE BLOCK ***** */
35734: 
35734: #ifndef ipc_glue_RPCChannel_h
35734: #define ipc_glue_RPCChannel_h 1
35734: 
39614: #include <stdio.h>
39614: 
35902: // FIXME/cjones probably shouldn't depend on STL
35902: #include <queue>
35734: #include <stack>
39614: #include <vector>
35734: 
39300: #include "base/basictypes.h"
39300: 
39300: #include "pratom.h"
39300: 
35778: #include "mozilla/ipc/SyncChannel.h"
39255: #include "nsAutoPtr.h"
35734: 
35734: namespace mozilla {
35734: namespace ipc {
35734: //-----------------------------------------------------------------------------
35734: 
35778: class RPCChannel : public SyncChannel
35734: {
38681:     friend class CxxStackFrame;
38681: 
35734: public:
39264:     // What happens if RPC calls race?
39264:     enum RacyRPCPolicy {
39264:         RRPError,
39264:         RRPChildWins,
39264:         RRPParentWins
39264:     };
39264: 
35788:     class /*NS_INTERFACE_CLASS*/ RPCListener :
35788:         public SyncChannel::SyncListener
35778:     {
35778:     public:
35787:         virtual ~RPCListener() { }
36140: 
36140:         virtual void OnChannelClose() = 0;
36140:         virtual void OnChannelError() = 0;
35778:         virtual Result OnMessageReceived(const Message& aMessage) = 0;
54001:         virtual void OnProcessingError(Result aError) = 0;
38107:         virtual bool OnReplyTimeout() = 0;
35778:         virtual Result OnMessageReceived(const Message& aMessage,
35778:                                          Message*& aReply) = 0;
35734:         virtual Result OnCallReceived(const Message& aMessage,
35744:                                       Message*& aReply) = 0;
57663:         virtual void OnChannelConnected(int32 peer_pid) {};
38682: 
38682:         virtual void OnEnteredCxxStack()
38682:         {
38682:             NS_RUNTIMEABORT("default impl shouldn't be invoked");
38682:         }
38682: 
38682:         virtual void OnExitedCxxStack()
38682:         {
38682:             NS_RUNTIMEABORT("default impl shouldn't be invoked");
38682:         }
39264: 
41650:         virtual void OnEnteredCall()
41650:         {
41650:             NS_RUNTIMEABORT("default impl shouldn't be invoked");
41650:         }
41650: 
41650:         virtual void OnExitedCall()
41650:         {
41650:             NS_RUNTIMEABORT("default impl shouldn't be invoked");
41650:         }
41650: 
39264:         virtual RacyRPCPolicy MediateRPCRace(const Message& parent,
39264:                                              const Message& child)
39264:         {
39264:             return RRPChildWins;
39264:         }
35734:     };
35734: 
39264:     RPCChannel(RPCListener* aListener);
35734: 
36078:     virtual ~RPCChannel();
35734: 
39255:     NS_OVERRIDE
39255:     void Clear();
39255: 
35778:     // Make an RPC to the other side of the channel
35778:     bool Call(Message* msg, Message* reply);
35734: 
38681:     // RPCChannel overrides these so that the async and sync messages
38681:     // can be counted against mStackFrames
38681:     NS_OVERRIDE
38681:     virtual bool Send(Message* msg);
38681:     NS_OVERRIDE
38681:     virtual bool Send(Message* msg, Message* reply);
38681: 
38100:     // Asynchronously, send the child a message that puts it in such a
38100:     // state that it can't send messages to the parent unless the
38100:     // parent sends a message to it first.  The child stays in this
38100:     // state until the parent calls |UnblockChild()|.
38100:     //
38100:     // It is an error to
38100:     //  - call this on the child side of the channel.
38100:     //  - nest |BlockChild()| calls
38100:     //  - call this when the child is already blocked on a sync or RPC
38100:     //    in-/out- message/call
38100:     //
38100:     // Return true iff successful.
38100:     bool BlockChild();
38100: 
38100:     // Asynchronously undo |BlockChild()|.
38100:     //
38100:     // It is an error to
38100:     //  - call this on the child side of the channel
38100:     //  - call this without a matching |BlockChild()|
38100:     //
38100:     // Return true iff successful.
38100:     bool UnblockChild();
38100: 
39312:     // Return true iff this has code on the C++ stack.
39312:     bool IsOnCxxStack() const {
39614:         return !mCxxStackFrames.empty();
39312:     }
39312: 
38100:     NS_OVERRIDE
38100:     virtual bool OnSpecialMessage(uint16 id, const Message& msg);
38100: 
35977:     // Override the SyncChannel handler so we can dispatch RPC
35977:     // messages.  Called on the IO thread only.
38100:     NS_OVERRIDE
38100:     virtual void OnMessageReceived(const Message& msg);
38100:     NS_OVERRIDE
38100:     virtual void OnChannelError();
35734: 
42538:     /**
42538:      * If there is a pending RPC message, process all pending messages.
42538:      *
42538:      * @note This method is used on Windows when we detect that an outbound
42538:      * OLE RPC call is being made to unblock the parent.
42538:      */
42538:     void FlushPendingRPCQueue();
42538: 
38103: #ifdef OS_WIN
41474:     void ProcessNativeEventsInRPCCall();
41474: 
38103: protected:
38125:     bool WaitForNotify();
39845:     void SpinInternalEventLoop();
38103: #endif
38103: 
35977:   private:
35977:     // Called on worker thread only
35902: 
39264:     RPCListener* Listener() const {
39264:         return static_cast<RPCListener*>(mListener);
39264:     }
39264: 
39311:     NS_OVERRIDE
41379:     virtual bool ShouldDeferNotifyMaybeError() const {
39614:         return IsOnCxxStack();
39311:     }
39311: 
41379:     bool EventOccurred() const;
38106: 
60363:     void MaybeUndeferIncall();
35977:     void EnqueuePendingMessages();
35977: 
42538:     /**
42538:      * Process one deferred or pending message.
42538:      * @return true if a message was processed
42538:      */
42538:     bool OnMaybeDequeueOne();
42538: 
35977:     void Incall(const Message& call, size_t stackDepth);
35977:     void DispatchIncall(const Message& call);
35734: 
38100:     void BlockOnParent();
38100:     void UnblockFromParent();
38100: 
38681:     // This helper class managed RPCChannel.mCxxStackDepth on behalf
38681:     // of RPCChannel.  When the stack depth is incremented from zero
38681:     // to non-zero, it invokes an RPCChannel callback, and similarly
38681:     // for when the depth goes from non-zero to zero;
38681:     void EnteredCxxStack()
38681:     {
39264:         Listener()->OnEnteredCxxStack();
38681:     }
38681: 
39615:     void ExitedCxxStack();
38681: 
41650:     void EnteredCall()
41650:     {
41650:         Listener()->OnEnteredCall();
41650:     }
41650: 
41650:     void ExitedCall()
41650:     {
41650:         Listener()->OnExitedCall();
41650:     }
41650: 
39614:     enum Direction { IN_MESSAGE, OUT_MESSAGE };
39614:     struct RPCFrame {
39614:         RPCFrame(Direction direction, const Message* msg) :
39614:             mDirection(direction), mMsg(msg)
39614:         { }
39614: 
41650:         bool IsRPCIncall() const
41650:         {
41650:             return mMsg->is_rpc() && IN_MESSAGE == mDirection;
41650:         }
41650: 
41650:         bool IsRPCOutcall() const
41650:         {
41650:             return mMsg->is_rpc() && OUT_MESSAGE == mDirection;
41650:         }
41650: 
39614:         void Describe(int32* id, const char** dir, const char** sems,
41379:                       const char** name) const
39614:         {
39614:             *id = mMsg->routing_id();
39614:             *dir = (IN_MESSAGE == mDirection) ? "in" : "out";
39614:             *sems = mMsg->is_rpc() ? "rpc" : mMsg->is_sync() ? "sync" : "async";
39614:             *name = mMsg->name();
39614:         }
39614: 
39614:         Direction mDirection;
39614:         const Message* mMsg;
39614:     };
39614: 
38681:     class NS_STACK_CLASS CxxStackFrame
38681:     {
38681:     public:
39614: 
39614:         CxxStackFrame(RPCChannel& that, Direction direction,
39614:                       const Message* msg) : mThat(that) {
38681:             mThat.AssertWorkerThread();
38681: 
39614:             if (mThat.mCxxStackFrames.empty())
38681:                 mThat.EnteredCxxStack();
39768: 
39614:             mThat.mCxxStackFrames.push_back(RPCFrame(direction, msg));
41650:             const RPCFrame& frame = mThat.mCxxStackFrames.back();
41650: 
41650:             if (frame.IsRPCIncall())
41650:                 mThat.EnteredCall();
41650: 
41650:             mThat.mSawRPCOutMsg |= frame.IsRPCOutcall();
38681:         }
38681: 
38681:         ~CxxStackFrame() {
41650:             bool exitingCall = mThat.mCxxStackFrames.back().IsRPCIncall();
39614:             mThat.mCxxStackFrames.pop_back();
39614:             bool exitingStack = mThat.mCxxStackFrames.empty();
38681: 
38681:             // mListener could have gone away if Close() was called while
38681:             // RPCChannel code was still on the stack
38681:             if (!mThat.mListener)
38681:                 return;
38681: 
38681:             mThat.AssertWorkerThread();
41650:             if (exitingCall)
41650:                 mThat.ExitedCall();
41650: 
38681:             if (exitingStack)
38681:                 mThat.ExitedCxxStack();
38681:         }
38681:     private:
38681:         RPCChannel& mThat;
38681: 
38681:         // disable harmful methods
38681:         CxxStackFrame();
38681:         CxxStackFrame(const CxxStackFrame&);
38681:         CxxStackFrame& operator=(const CxxStackFrame&);
38681:     };
38681: 
35902:     // Called from both threads
41379:     size_t StackDepth() const {
35858:         mMutex.AssertCurrentThreadOwns();
35902:         return mStack.size();
35858:     }
35858: 
35975:     void DebugAbort(const char* file, int line, const char* cond,
35974:                     const char* why,
41379:                     const char* type="rpc", bool reply=false) const;
35974: 
39614:     // This method is only safe to call on the worker thread, or in a
39614:     // debugger with all threads paused.  |outfile| defaults to stdout.
41379:     void DumpRPCStack(FILE* outfile=NULL, const char* const pfx="") const;
39614: 
35977:     // 
35977:     // Queue of all incoming messages, except for replies to sync
35977:     // messages, which are delivered directly to the SyncChannel
35977:     // through its mRecvd member.
35977:     //
35977:     // If both this side and the other side are functioning correctly,
35977:     // the queue can only be in certain configurations.  Let
35977:     // 
35977:     //   |A<| be an async in-message,
35977:     //   |S<| be a sync in-message,
35977:     //   |C<| be an RPC in-call,
35977:     //   |R<| be an RPC reply.
35977:     // 
35977:     // The queue can only match this configuration
35977:     // 
35977:     //  A<* (S< | C< | R< (?{mStack.size() == 1} A<* (S< | C<)))
35977:     //
35977:     // The other side can send as many async messages |A<*| as it
35977:     // wants before sending us a blocking message.
35977:     //
35977:     // The first case is |S<|, a sync in-msg.  The other side must be
35977:     // blocked, and thus can't send us any more messages until we
35977:     // process the sync in-msg.
35977:     //
35977:     // The second case is |C<|, an RPC in-call; the other side must be
35977:     // blocked.  (There's a subtlety here: this in-call might have
35977:     // raced with an out-call, but we detect that with the mechanism
35977:     // below, |mRemoteStackDepth|, and races don't matter to the
35977:     // queue.)
35977:     //
35977:     // Final case, the other side replied to our most recent out-call
35977:     // |R<|.  If that was the *only* out-call on our stack,
35977:     // |?{mStack.size() == 1}|, then other side "finished with us,"
35977:     // and went back to its own business.  That business might have
35977:     // included sending any number of async message |A<*| until
35977:     // sending a blocking message |(S< | C<)|.  If we had more than
35977:     // one RPC call on our stack, the other side *better* not have
35977:     // sent us another blocking message, because it's blocked on a
35977:     // reply from us.
35977:     //
41379:     typedef std::queue<Message> MessageQueue;
41379:     MessageQueue mPending;
35974: 
35858:     // 
35902:     // Stack of all the RPC out-calls on which this RPCChannel is
35902:     // awaiting a response.
35858:     //
35902:     std::stack<Message> mStack;
35902: 
35858:     //
38103:     // Map of replies received "out of turn", because of RPC
37474:     // in-calls racing with replies to outstanding in-calls.  See
37474:     // https://bugzilla.mozilla.org/show_bug.cgi?id=521929.
37474:     //
38103:     typedef std::map<size_t, Message> MessageMap;
38103:     MessageMap mOutOfTurnReplies;
37474: 
37474:     //
35977:     // Stack of RPC in-calls that were deferred because of race
35977:     // conditions.
35858:     //
35977:     std::stack<Message> mDeferred;
35858: 
35858:     //
35858:     // This is what we think the RPC stack depth is on the "other
35858:     // side" of this RPC channel.  We maintain this variable so that
35858:     // we can detect racy RPC calls.  With each RPC out-call sent, we
35858:     // send along what *we* think the stack depth of the remote side
35858:     // is *before* it will receive the RPC call.
35858:     //
35858:     // After sending the out-call, our stack depth is "incremented"
35858:     // by pushing that pending message onto mPending.
35858:     //
35858:     // Then when processing an in-call |c|, it must be true that
35858:     //
35977:     //   mStack.size() == c.remoteDepth
35858:     //
35858:     // i.e., my depth is actually the same as what the other side
35858:     // thought it was when it sent in-call |c|.  If this fails to
35858:     // hold, we have detected racy RPC calls.
35858:     //
35858:     // We then increment mRemoteStackDepth *just before* processing
35858:     // the in-call, since we know the other side is waiting on it, and
35858:     // decrement it *just after* finishing processing that in-call,
35858:     // since our response will pop the top of the other side's
35858:     // |mPending|.
35858:     //
35858:     // One nice aspect of this race detection is that it is symmetric;
35858:     // if one side detects a race, then the other side must also 
35858:     // detect the same race.
35858:     //
35974:     size_t mRemoteStackDepthGuess;
38100: 
38100:     // True iff the parent has put us in a |BlockChild()| state.
38100:     bool mBlockedOnParent;
38681: 
39614:     // Approximation of Sync/RPCChannel-code frames on the C++ stack.
39614:     // It can only be interpreted as the implication
38681:     //
39614:     //  !mCxxStackFrames.empty() => RPCChannel code on C++ stack
38681:     //
38681:     // This member is only accessed on the worker thread, and so is
38681:     // not protected by mMutex.  It is managed exclusively by the
38681:     // helper |class CxxStackFrame|.
39614:     std::vector<RPCFrame> mCxxStackFrames;
39255: 
39768:     // Did we process an RPC out-call during this stack?  Only
39768:     // meaningful in ExitedCxxStack(), from which this variable is
39768:     // reset.
39768:     bool mSawRPCOutMsg;
39768: 
39255: private:
39255: 
39255:     //
39255:     // All dequeuing tasks require a single point of cancellation,
39255:     // which is handled via a reference-counted task.
39255:     //
39255:     class RefCountedTask
39255:     {
39255:       public:
39255:         RefCountedTask(CancelableTask* aTask)
39255:         : mTask(aTask)
39255:         , mRefCnt(0) {}
39255:         ~RefCountedTask() { delete mTask; }
39255:         void Run() { mTask->Run(); }
39255:         void Cancel() { mTask->Cancel(); }
39300:         void AddRef() {
39300:             PR_AtomicIncrement(reinterpret_cast<PRInt32*>(&mRefCnt));
39300:         }
39255:         void Release() {
39300:             nsrefcnt count =
39300:                 PR_AtomicDecrement(reinterpret_cast<PRInt32*>(&mRefCnt));
39300:             if (0 == count)
39255:                 delete this;
39255:         }
39255: 
39255:       private:
39255:         CancelableTask* mTask;
39255:         nsrefcnt mRefCnt;
39255:     };
39255: 
39255:     //
39255:     // Wrap an existing task which can be cancelled at any time
39255:     // without the wrapper's knowledge.
39255:     //
39255:     class DequeueTask : public Task
39255:     {
39255:       public:
39255:         DequeueTask(RefCountedTask* aTask) : mTask(aTask) {}
39255:         void Run() { mTask->Run(); }
39255:         
39255:       private:
39255:         nsRefPtr<RefCountedTask> mTask;
39255:     };
39255: 
39255:     // A task encapsulating dequeuing one pending task
39255:     nsRefPtr<RefCountedTask> mDequeueOneTask;
35734: };
35734: 
35734: 
35734: } // namespace ipc
35734: } // namespace mozilla
35734: #endif  // ifndef ipc_glue_RPCChannel_h
