    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Uri Bernstein <uriber@gmail.com>
    1:  *   Eli Friedman <sharparrow1@yahoo.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* base class of all rendering objects */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsFrame.h"
    1: #include "nsFrameList.h"
32107: #include "nsPlaceholderFrame.h"
    1: #include "nsLineLayout.h"
    1: #include "nsIContent.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIAtom.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
32435: #include "nsIScrollableView.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsCRT.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsPLDOMEvent.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsIPresShell.h"
    1: #include "prlog.h"
    1: #include "prprf.h"
    1: #include <stdarg.h>
    1: #include "nsFrameManager.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsLayoutUtils.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessible.h"
    1: #endif
    1: 
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIDOMHTMLHRElement.h"
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIEditorDocShell.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsIHTMLContentSink.h" 
    1: #include "nsCSSFrameConstructor.h"
    1: 
    1: #include "nsFrameTraversal.h"
    1: #include "nsStyleChangeList.h"
    1: #include "nsIDOMRange.h"
23533: #include "nsITableLayout.h"    //selection necessity
    1: #include "nsITableCellLayout.h"//  "
    1: #include "nsITextControlFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIPercentHeightObserver.h"
23015: #include "nsStyleStructInlines.h"
    1: 
    1: #ifdef IBMBIDI
    1: #include "nsBidiPresUtils.h"
    1: #endif
    1: 
    1: // For triple-click pref
    1: #include "nsIServiceManager.h"
    1: #include "imgIContainer.h"
    1: #include "imgIRequest.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsWidgetsCID.h"     // for NS_LOOKANDFEEL_CID
    1: #include "nsUnicharUtils.h"
    1: #include "nsLayoutErrors.h"
  549: #include "nsContentErrors.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsDisplayList.h"
    1: 
19125: #ifdef MOZ_SVG
19125: #include "nsSVGIntegrationUtils.h"
19948: #include "nsSVGEffects.h"
19125: #endif
19125: 
    1: #include "gfxContext.h"
 5235: 
    1: static NS_DEFINE_CID(kLookAndFeelCID,  NS_LOOKANDFEEL_CID);
    1: static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);
    1: 
    1: // Struct containing cached metrics for box-wrapped frames.
    1: struct nsBoxLayoutMetrics
    1: {
    1:   nsSize mPrefSize;
    1:   nsSize mMinSize;
    1:   nsSize mMaxSize;
    1: 
    1:   nsSize mBlockMinSize;
    1:   nsSize mBlockPrefSize;
    1:   nscoord mBlockAscent;
    1: 
    1:   nscoord mFlex;
    1:   nscoord mAscent;
    1: 
    1:   nsSize mLastSize;
    1: };
    1: 
    1: struct nsContentAndOffset
    1: {
    1:   nsIContent* mContent;
    1:   PRInt32 mOffset;
    1: };
    1: 
    1: // Some Misc #defines
    1: #define SELECTION_DEBUG        0
    1: #define FORCE_SELECTION_UPDATE 1
    1: #define CALC_DEBUG             0
    1: 
    1: 
    1: #include "nsILineIterator.h"
    1: 
    1: //non Hack prototypes
    1: #if 0
    1: static void RefreshContentFrames(nsPresContext* aPresContext, nsIContent * aStartContent, nsIContent * aEndContent);
    1: #endif
    1: 
    1: #include "prenv.h"
    1: 
31709: // Formerly the nsIFrameDebug interface
    1: 
    1: #ifdef NS_DEBUG
    1: static PRBool gShowFrameBorders = PR_FALSE;
    1: 
31709: void nsFrame::ShowFrameBorders(PRBool aEnable)
    1: {
    1:   gShowFrameBorders = aEnable;
    1: }
    1: 
31709: PRBool nsFrame::GetShowFrameBorders()
    1: {
    1:   return gShowFrameBorders;
    1: }
    1: 
    1: static PRBool gShowEventTargetFrameBorder = PR_FALSE;
    1: 
31709: void nsFrame::ShowEventTargetFrameBorder(PRBool aEnable)
    1: {
    1:   gShowEventTargetFrameBorder = aEnable;
    1: }
    1: 
31709: PRBool nsFrame::GetShowEventTargetFrameBorder()
    1: {
    1:   return gShowEventTargetFrameBorder;
    1: }
    1: 
    1: /**
    1:  * Note: the log module is created during library initialization which
    1:  * means that you cannot perform logging before then.
    1:  */
    1: static PRLogModuleInfo* gLogModule;
    1: 
    1: static PRLogModuleInfo* gStyleVerifyTreeLogModuleInfo;
    1: 
    1: static PRBool gStyleVerifyTreeEnable = PRBool(0x55);
    1: 
    1: PRBool
31709: nsFrame::GetVerifyStyleTreeEnable()
    1: {
    1:   if (gStyleVerifyTreeEnable == PRBool(0x55)) {
    1:     if (nsnull == gStyleVerifyTreeLogModuleInfo) {
    1:       gStyleVerifyTreeLogModuleInfo = PR_NewLogModule("styleverifytree");
    1:       gStyleVerifyTreeEnable = 0 != gStyleVerifyTreeLogModuleInfo->level;
    1:     }
    1:   }
    1:   return gStyleVerifyTreeEnable;
    1: }
    1: 
    1: void
31709: nsFrame::SetVerifyStyleTreeEnable(PRBool aEnabled)
    1: {
    1:   gStyleVerifyTreeEnable = aEnabled;
    1: }
    1: 
    1: PRLogModuleInfo*
31709: nsFrame::GetLogModuleInfo()
    1: {
    1:   if (nsnull == gLogModule) {
    1:     gLogModule = PR_NewLogModule("frame");
    1:   }
    1:   return gLogModule;
    1: }
    1: 
    1: void
31709: nsFrame::DumpFrameTree(nsIFrame* aFrame)
    1: {
  238:     RootFrameList(aFrame->PresContext(), stdout, 0);
    1: }
    1: 
    1: void
31709: nsFrame::RootFrameList(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent)
31709: {
31709:   if (!aPresContext || !out)
    1:     return;
    1: 
    1:   nsIPresShell *shell = aPresContext->GetPresShell();
31709:   if (shell) {
    1:     nsIFrame* frame = shell->FrameManager()->GetRootFrame();
31709:     if(frame) {
31709:       frame->List(out, aIndent);
    1:     }
    1:   }
    1: }
    1: #endif
    1: 
    1: void
15183: NS_MergeReflowStatusInto(nsReflowStatus* aPrimary, nsReflowStatus aSecondary)
15183: {
15183:   *aPrimary |= aSecondary &
15183:     (NS_FRAME_NOT_COMPLETE | NS_FRAME_OVERFLOW_INCOMPLETE |
15183:      NS_FRAME_TRUNCATED | NS_FRAME_REFLOW_NEXTINFLOW);
15183:   if (*aPrimary & NS_FRAME_NOT_COMPLETE) {
15183:     *aPrimary &= ~NS_FRAME_OVERFLOW_INCOMPLETE;
15183:   }
15183: }
15183: 
15183: void
34904: nsWeakFrame::InitInternal(nsIFrame* aFrame)
    1: {
  238:   Clear(mFrame ? mFrame->PresContext()->GetPresShell() : nsnull);
    1:   mFrame = aFrame;
    1:   if (mFrame) {
  238:     nsIPresShell* shell = mFrame->PresContext()->GetPresShell();
    1:     NS_WARN_IF_FALSE(shell, "Null PresShell in nsWeakFrame!");
    1:     if (shell) {
    1:       shell->AddWeakFrame(this);
    1:     } else {
    1:       mFrame = nsnull;
    1:     }
    1:   }
    1: }
    1: 
    1: nsIFrame*
    1: NS_NewEmptyFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsFrame(aContext);
    1: }
    1: 
    1: nsFrame::nsFrame(nsStyleContext* aContext)
    1: {
    1:   MOZ_COUNT_CTOR(nsFrame);
    1: 
    1:   mState = NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY;
    1:   mStyleContext = aContext;
    1:   mStyleContext->AddRef();
    1: }
    1: 
    1: nsFrame::~nsFrame()
    1: {
    1:   MOZ_COUNT_DTOR(nsFrame);
    1: 
    1:   NS_IF_RELEASE(mContent);
    1:   if (mStyleContext)
    1:     mStyleContext->Release();
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsFrame)
32423: 
32423: // Dummy operator delete.  Will never be called, but must be defined
32423: // to satisfy some C++ ABIs.
32423: void
32423: nsFrame::operator delete(void *, size_t)
32423: {
32423:   NS_RUNTIMEABORT("nsFrame::operator delete should never be called");
32423: }
32423: 
23554: NS_QUERYFRAME_HEAD(nsFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIFrame)
32423: NS_QUERYFRAME_TAIL_INHERITANCE_ROOT
    1: 
    1: /////////////////////////////////////////////////////////////////////////////
    1: // nsIFrame
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::Init(nsIContent*      aContent,
    1:               nsIFrame*        aParent,
    1:               nsIFrame*        aPrevInFlow)
    1: {
 6219:   NS_PRECONDITION(!mContent, "Double-initing a frame?");
    1:   NS_ASSERTION(IsFrameOfType(eDEBUGAllFrames) &&
    1:                !IsFrameOfType(eDEBUGNoFrames),
    1:                "IsFrameOfType implementation that doesn't call base class");
    1: 
    1:   mContent = aContent;
    1:   mParent = aParent;
    1: 
    1:   if (aContent) {
    1:     NS_ADDREF(aContent);
    1:     aContent->SetMayHaveFrame(PR_TRUE);
    1:     NS_ASSERTION(mContent->MayHaveFrame(), "SetMayHaveFrame failed?");
    1:   }
    1: 
    1:   if (aPrevInFlow) {
    1:     // Make sure the general flags bits are the same
    1:     nsFrameState state = aPrevInFlow->GetStateBits();
    1: 
    1:     // Make bits that are currently off (see constructor) the same:
    1:     mState |= state & (NS_FRAME_SELECTED_CONTENT |
    1:                        NS_FRAME_INDEPENDENT_SELECTION |
19948:                        NS_FRAME_IS_SPECIAL |
19948:                        NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS);
    1:   }
    1:   if (mParent) {
    1:     nsFrameState state = mParent->GetStateBits();
    1: 
    1:     // Make bits that are currently off (see constructor) the same:
    1:     mState |= state & (NS_FRAME_INDEPENDENT_SELECTION |
    1:                        NS_FRAME_GENERATED_CONTENT);
    1:   }
19214:   if (GetStyleDisplay()->HasTransform()) {
19214:     // The frame gets reconstructed if we toggle the -moz-transform
19214:     // property, so we can set this bit here and then ignore it.
19948:     mState |= NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS;
19214:   }
19214:   
20836:   DidSetStyleContext(nsnull);
    1: 
    1:   if (IsBoxWrapped())
    1:     InitBoxMetrics(PR_FALSE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                            nsFrameList&    aChildList)
    1: {
    1:   // XXX This shouldn't be getting called at all, but currently is for backwards
    1:   // compatility reasons...
    1: #if 0
    1:   NS_ERROR("not a container");
    1:   return NS_ERROR_UNEXPECTED;
    1: #else
30790:   NS_ASSERTION(aChildList.IsEmpty(), "not a container");
    1:   return NS_OK;
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::AppendFrames(nsIAtom*        aListName,
30941:                       nsFrameList&    aFrameList)
    1: {
    1:   NS_PRECONDITION(PR_FALSE, "not a container");
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::InsertFrames(nsIAtom*        aListName,
    1:                       nsIFrame*       aPrevFrame,
30941:                       nsFrameList&    aFrameList)
    1: {
    1:   NS_PRECONDITION(PR_FALSE, "not a container");
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::RemoveFrame(nsIAtom*        aListName,
    1:                      nsIFrame*       aOldFrame)
    1: {
    1:   NS_PRECONDITION(PR_FALSE, "not a container");
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: void
    1: nsFrame::Destroy()
    1: {
28371:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
28371:     "destroy called on frame while scripts not blocked");
28371: 
19948: #ifdef MOZ_SVG
19948:   nsSVGEffects::InvalidateDirectRenderingObservers(this);
19948: #endif
19948: 
    1:   // Get the view pointer now before the frame properties disappear
    1:   // when we call NotifyDestroyingFrame()
    1:   nsIView* view = GetView();
  238:   nsPresContext* presContext = PresContext();
    1: 
    1:   nsIPresShell *shell = presContext->GetPresShell();
28300:   if (mState & NS_FRAME_OUT_OF_FLOW) {
28300:     nsPlaceholderFrame* placeholder =
28300:       shell->FrameManager()->GetPlaceholderFrameFor(this);
28300:     if (placeholder) {
28300:       shell->FrameManager()->UnregisterPlaceholderFrame(placeholder);
28300:       placeholder->SetOutOfFlowFrame(nsnull);
28300:     }
28300:   }
    1: 
    1:   shell->NotifyDestroyingFrame(this);
    1: 
    1:   if ((mState & NS_FRAME_EXTERNAL_REFERENCE) ||
    1:       (mState & NS_FRAME_SELECTED_CONTENT)) {
    1:     shell->ClearFrameRefs(this);
    1:   }
    1: 
    1:   //XXX Why is this done in nsFrame instead of some frame class
    1:   // that actually loads images?
    1:   presContext->StopImagesFor(this);
    1: 
    1:   if (view) {
    1:     // Break association between view and frame
    1:     view->SetClientData(nsnull);
    1: 
    1:     // Destroy the view
    1:     view->Destroy();
    1:   }
    1: 
32511:   // Must retrieve the object ID before calling destructors, so the
32423:   // vtable is still valid.
32423:   //
32423:   // Note to future tweakers: having the method that returns the
32423:   // object size call the destructor will not avoid an indirect call;
32423:   // the compiler cannot devirtualize the call to the destructor even
32423:   // if it's from a method defined in the same class.
32423: 
32511:   nsQueryFrame::FrameIID id = GetFrameId();
32423:   this->~nsFrame();
32423: 
32423:   // Now that we're totally cleaned out, we need to add ourselves to
32423:   // the presshell's recycler.
32511:   shell->FreeFrame(id, this);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetOffsets(PRInt32 &aStart, PRInt32 &aEnd) const
    1: {
    1:   aStart = 0;
    1:   aEnd = 0;
    1:   return NS_OK;
    1: }
    1: 
25231: static PRBool
25231: EqualImages(imgIRequest *aOldImage, imgIRequest *aNewImage)
25231: {
25231:   if (aOldImage == aNewImage)
25231:     return PR_TRUE;
25231: 
25231:   if (!aOldImage || !aNewImage)
25231:     return PR_FALSE;
25231: 
25231:   nsCOMPtr<nsIURI> oldURI, newURI;
25231:   aOldImage->GetURI(getter_AddRefs(oldURI));
25231:   aNewImage->GetURI(getter_AddRefs(newURI));
25231:   PRBool equal;
25231:   return NS_SUCCEEDED(oldURI->Equals(newURI, &equal)) && equal;
25231: }
25231: 
    1: // Subclass hook for style post processing
20441: /* virtual */ void
20836: nsFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
20324: {
25231:   if (aOldStyleContext) {
25231:     // If the old context had a background image image and new context
25231:     // does not have the same image, clear the image load notifier
25231:     // (which keeps the image loading, if it still is) for the frame.
25231:     // We want to do this conservatively because some frames paint their
25231:     // backgrounds from some other frame's style data, and we don't want
25231:     // to clear those notifiers unless we have to.  (They'll be reset
25231:     // when we paint, although we could miss a notification in that
25231:     // interval.)
25276:     const nsStyleBackground *oldBG = aOldStyleContext->GetStyleBackground();
25276:     const nsStyleBackground *newBG = GetStyleBackground();
25276:     NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, oldBG) {
30993:       if (i >= newBG->mImageCount ||
30993:           oldBG->mLayers[i].mImage != newBG->mLayers[i].mImage) {
25231:         // stop the image loading for the frame, the image has changed
25231:         PresContext()->SetImageLoaders(this,
25231:           nsPresContext::BACKGROUND_IMAGE, nsnull);
25276:         break;
25276:       }
25231:     }
25231:   }
25231: 
25231:   imgIRequest *oldBorderImage = aOldStyleContext
25231:     ? aOldStyleContext->GetStyleBorder()->GetBorderImage()
25231:     : nsnull;
25231:   // For border-images, we can't be as conservative (we need to set the
25231:   // new loaders if there has been any change) since the CalcDifference
25231:   // call depended on the result of GetActualBorder() and that result
25231:   // depends on whether the image has loaded, start the image load now
25231:   // so that we'll get notified when it completes loading and can do a
25231:   // restyle.  Otherwise, the image might finish loading from the
25231:   // network before we start listening to its notifications, and then
25231:   // we'll never know that it's finished loading.  Likewise, we want to
25231:   // do this for freshly-created frames to prevent a similar race if the
25231:   // image loads between reflow (which can depend on whether the image
25231:   // is loaded) and paint.  We also don't really care about any callers
25231:   // who try to paint borders with a different style context, because
25231:   // they won't have the correct size for the border either.
25231:   if (!EqualImages(oldBorderImage, GetStyleBorder()->GetBorderImage())) {
25231:     // stop and restart the image loading/notification
25231:     PresContext()->SetupBorderImageLoaders(this, GetStyleBorder());
23015:   }
27659: 
27659:   // If the page contains markup that overrides text direction, and
27659:   // does not contain any characters that would activate the Unicode
27659:   // bidi algorithm, we need to call |SetBidiEnabled| on the pres
27659:   // context before reflow starts.  See bug 115921.
27659:   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
27659:     PresContext()->SetBidiEnabled();
27659:   }
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsIFrame::GetUsedMargin() const
    1: {
11016:   NS_ASSERTION(nsLayoutUtils::sDisableGetUsedXAssertions ||
11016:                !NS_SUBTREE_DIRTY(this) ||
    1:                (GetStateBits() & NS_FRAME_IN_REFLOW),
11016:                "cannot call GetUsedMargin on a dirty frame not currently "
11016:                "being reflowed");
    1: 
    1:   nsMargin margin(0, 0, 0, 0);
    1:   if (!GetStyleMargin()->GetMargin(margin)) {
 3233:     nsMargin *m = static_cast<nsMargin*>
 3233:                              (GetProperty(nsGkAtoms::usedMarginProperty));
    1:     NS_ASSERTION(m, "used margin property missing (out of memory?)");
    1:     if (m) {
    1:       margin = *m;
    1:     }
    1:   }
    1:   return margin;
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsIFrame::GetUsedBorder() const
    1: {
11016:   NS_ASSERTION(nsLayoutUtils::sDisableGetUsedXAssertions ||
11016:                !NS_SUBTREE_DIRTY(this) ||
    1:                (GetStateBits() & NS_FRAME_IN_REFLOW),
11016:                "cannot call GetUsedBorder on a dirty frame not currently "
11016:                "being reflowed");
    1: 
    1:   // Theme methods don't use const-ness.
 3233:   nsIFrame *mutable_this = const_cast<nsIFrame*>(this);
    1: 
    1:   const nsStyleDisplay *disp = GetStyleDisplay();
    1:   if (mutable_this->IsThemed(disp)) {
23738:     nsIntMargin result;
  238:     nsPresContext *presContext = PresContext();
    1:     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
    1:                                              mutable_this, disp->mAppearance,
    1:                                              &result);
23738:     return nsMargin(presContext->DevPixelsToAppUnits(result.left),
23738:                     presContext->DevPixelsToAppUnits(result.top),
23738:                     presContext->DevPixelsToAppUnits(result.right),
23738:                     presContext->DevPixelsToAppUnits(result.bottom));
    1:   }
    1: 
15992:   return GetStyleBorder()->GetActualBorder();
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsIFrame::GetUsedPadding() const
    1: {
11016:   NS_ASSERTION(nsLayoutUtils::sDisableGetUsedXAssertions ||
11016:                !NS_SUBTREE_DIRTY(this) ||
    1:                (GetStateBits() & NS_FRAME_IN_REFLOW),
11016:                "cannot call GetUsedPadding on a dirty frame not currently "
11016:                "being reflowed");
    1: 
    1:   nsMargin padding(0, 0, 0, 0);
    1: 
    1:   // Theme methods don't use const-ness.
 3233:   nsIFrame *mutable_this = const_cast<nsIFrame*>(this);
    1: 
    1:   const nsStyleDisplay *disp = GetStyleDisplay();
    1:   if (mutable_this->IsThemed(disp)) {
  238:     nsPresContext *presContext = PresContext();
23738:     nsIntMargin widget;
    1:     if (presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
    1:                                                   mutable_this,
    1:                                                   disp->mAppearance,
23738:                                                   &widget)) {
23738:       padding.top = presContext->DevPixelsToAppUnits(widget.top);
23738:       padding.right = presContext->DevPixelsToAppUnits(widget.right);
23738:       padding.bottom = presContext->DevPixelsToAppUnits(widget.bottom);
23738:       padding.left = presContext->DevPixelsToAppUnits(widget.left);
    1:       return padding;
    1:     }
    1:   }
    1:   if (!GetStylePadding()->GetPadding(padding)) {
 3233:     nsMargin *p = static_cast<nsMargin*>
 3233:                              (GetProperty(nsGkAtoms::usedPaddingProperty));
    1:     NS_ASSERTION(p, "used padding property missing (out of memory?)");
    1:     if (p) {
    1:       padding = *p;
    1:     }
    1:   }
    1:   return padding;
    1: }
    1: 
    1: void
    1: nsIFrame::ApplySkipSides(nsMargin& aMargin) const
    1: {
    1:   PRIntn skipSides = GetSkipSides();
    1:   if (skipSides & (1 << NS_SIDE_TOP))
    1:     aMargin.top = 0;
    1:   if (skipSides & (1 << NS_SIDE_RIGHT))
    1:     aMargin.right = 0;
    1:   if (skipSides & (1 << NS_SIDE_BOTTOM))
    1:     aMargin.bottom = 0;
    1:   if (skipSides & (1 << NS_SIDE_LEFT))
    1:     aMargin.left = 0;
    1: }
    1: 
    1: nsRect
    1: nsIFrame::GetMarginRect() const
    1: {
    1:   nsMargin m(GetUsedMargin());
    1:   ApplySkipSides(m);
    1:   nsRect r(mRect);
    1:   r.Inflate(m);
    1:   return r;
    1: }
    1: 
    1: nsRect
    1: nsIFrame::GetPaddingRect() const
    1: {
    1:   nsMargin b(GetUsedBorder());
    1:   ApplySkipSides(b);
    1:   nsRect r(mRect);
    1:   r.Deflate(b);
    1:   return r;
    1: }
    1: 
19214: PRBool
19214: nsIFrame::IsTransformed() const
19214: {
19948:   return (mState & NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS) &&
19214:     GetStyleDisplay()->HasTransform();
19214: }
19214: 
    1: nsRect
    1: nsIFrame::GetContentRect() const
    1: {
    1:   nsMargin bp(GetUsedBorderAndPadding());
    1:   ApplySkipSides(bp);
    1:   nsRect r(mRect);
    1:   r.Deflate(bp);
    1:   return r;
    1: }
    1: 
    1: nsStyleContext*
    1: nsFrame::GetAdditionalStyleContext(PRInt32 aIndex) const
    1: {
    1:   NS_PRECONDITION(aIndex >= 0, "invalid index number");
    1:   return nsnull;
    1: }
    1: 
    1: void
    1: nsFrame::SetAdditionalStyleContext(PRInt32 aIndex, 
    1:                                    nsStyleContext* aStyleContext)
    1: {
    1:   NS_PRECONDITION(aIndex >= 0, "invalid index number");
    1: }
    1: 
26940: nsCSSShadowArray*
26940: nsIFrame::GetEffectiveBoxShadows()
26940: {
26940:   nsCSSShadowArray* shadows = GetStyleBorder()->mBoxShadow;
26940:   if (!shadows ||
26940:       (IsThemed() && GetContent() &&
26940:        !nsContentUtils::IsChromeDoc(GetContent()->GetCurrentDoc())))
26940:     return nsnull;
26940:   return shadows;
26940: }
26940: 
    1: nscoord
    1: nsFrame::GetBaseline() const
    1: {
 1158:   NS_ASSERTION(!NS_SUBTREE_DIRTY(this),
    1:                "frame must not be dirty");
    1:   // Default to the bottom margin edge, per CSS2.1's definition of the
    1:   // 'baseline' value of 'vertical-align'.
    1:   return mRect.height + GetUsedMargin().bottom;
    1: }
    1: 
    1: // Child frame enumeration
    1: 
    1: nsIAtom*
    1: nsFrame::GetAdditionalChildListName(PRInt32 aIndex) const
    1: {
    1:   NS_PRECONDITION(aIndex >= 0, "invalid index number");
    1:   return nsnull;
    1: }
    1: 
30783: nsFrameList
30783: nsFrame::GetChildList(nsIAtom* aListName) const
30783: {
30783:   return nsFrameList::EmptyList();
    1: }
    1: 
    1: static nsIFrame*
32435: GetActiveSelectionFrame(nsPresContext* aPresContext, nsIFrame* aFrame)
32435: {
32435:   nsIPresShell* shell = aPresContext->GetPresShell(); 
32435:   if (shell) {
32435:     nsIContent* capturingContent = nsIPresShell::GetCapturingContent();
32435:     if (capturingContent) {
32435:       nsIFrame* activeFrame = shell->GetPrimaryFrameFor(capturingContent);
32435:       return activeFrame ? activeFrame : aFrame;
    1:     }
    1:   }
    1: 
    1:   return aFrame;
    1: }
    1: 
    1: PRInt16
    1: nsFrame::DisplaySelection(nsPresContext* aPresContext, PRBool isOkToTurnOn)
    1: {
    1:   PRInt16 selType = nsISelectionController::SELECTION_OFF;
    1: 
    1:   nsCOMPtr<nsISelectionController> selCon;
    1:   nsresult result = GetSelectionController(aPresContext, getter_AddRefs(selCon));
    1:   if (NS_SUCCEEDED(result) && selCon) {
    1:     result = selCon->GetDisplaySelection(&selType);
    1:     if (NS_SUCCEEDED(result) && (selType != nsISelectionController::SELECTION_OFF)) {
    1:       // Check whether style allows selection.
    1:       PRBool selectable;
    1:       IsSelectable(&selectable, nsnull);
    1:       if (!selectable) {
    1:         selType = nsISelectionController::SELECTION_OFF;
    1:         isOkToTurnOn = PR_FALSE;
    1:       }
    1:     }
    1:     if (isOkToTurnOn && (selType == nsISelectionController::SELECTION_OFF)) {
    1:       selCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
    1:       selType = nsISelectionController::SELECTION_ON;
    1:     }
    1:   }
    1:   return selType;
    1: }
    1: 
    1: class nsDisplaySelectionOverlay : public nsDisplayItem {
    1: public:
    1:   nsDisplaySelectionOverlay(nsFrame* aFrame, PRInt16 aSelectionValue)
    1:     : nsDisplayItem(aFrame), mSelectionValue(aSelectionValue) {
    1:     MOZ_COUNT_CTOR(nsDisplaySelectionOverlay);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplaySelectionOverlay() {
    1:     MOZ_COUNT_DTOR(nsDisplaySelectionOverlay);
    1:   }
    1: #endif
    1: 
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
33368:                      nsIRenderingContext* aCtx);
    1:   NS_DISPLAY_DECL_NAME("SelectionOverlay")
    1: private:
    1:   PRInt16 mSelectionValue;
    1: };
    1: 
    1: void nsDisplaySelectionOverlay::Paint(nsDisplayListBuilder* aBuilder,
33368:                                       nsIRenderingContext* aCtx)
    1: {
    1:   nscolor color = NS_RGB(255, 255, 255);
    1:   
    1:   nsILookAndFeel::nsColorID colorID;
    1:   nsresult result;
    1:   if (mSelectionValue == nsISelectionController::SELECTION_ON) {
    1:     colorID = nsILookAndFeel::eColor_TextSelectBackground;
    1:   } else if (mSelectionValue == nsISelectionController::SELECTION_ATTENTION) {
    1:     colorID = nsILookAndFeel::eColor_TextSelectBackgroundAttention;
    1:   } else {
    1:     colorID = nsILookAndFeel::eColor_TextSelectBackgroundDisabled;
    1:   }
    1: 
    1:   nsCOMPtr<nsILookAndFeel> look;
    1:   look = do_GetService(kLookAndFeelCID, &result);
    1:   if (NS_SUCCEEDED(result) && look)
    1:     look->GetColor(colorID, color);
    1: 
    1:   gfxRGBA c(color);
    1:   c.a = .5;
    1: 
15229:   gfxContext *ctx = aCtx->ThebesContext();
    1:   ctx->SetColor(c);
    1: 
33368:   nsIntRect pxRect =
33368:     mVisibleRect.ToOutsidePixels(mFrame->PresContext()->AppUnitsPerDevPixel());
   54:   ctx->NewPath();
23738:   ctx->Rectangle(gfxRect(pxRect.x, pxRect.y, pxRect.width, pxRect.height), PR_TRUE);
    1:   ctx->Fill();
    1: }
    1: 
    1: /********************************************************
    1: * Refreshes each content's frame
    1: *********************************************************/
    1: 
    1: nsresult
    1: nsFrame::DisplaySelectionOverlay(nsDisplayListBuilder*   aBuilder,
    1:                                  const nsDisplayListSet& aLists,
    1:                                  PRUint16                aContentType)
    1: {
    1: //check frame selection state
    1:   if ((GetStateBits() & NS_FRAME_SELECTED_CONTENT) != NS_FRAME_SELECTED_CONTENT)
    1:     return NS_OK;
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1:     
  238:   nsPresContext* presContext = PresContext();
    1:   nsIPresShell *shell = presContext->PresShell();
    1:   if (!shell)
    1:     return NS_OK;
    1: 
    1:   PRInt16 displaySelection;
    1:   nsresult rv = shell->GetSelectionFlags(&displaySelection);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   if (!(displaySelection & aContentType))
    1:     return NS_OK;
    1: 
 8295:   const nsFrameSelection* frameSelection = GetConstFrameSelection();
    1:   PRInt16 selectionValue = frameSelection->GetDisplaySelection();
    1: 
    1:   if (selectionValue <= nsISelectionController::SELECTION_HIDDEN)
    1:     return NS_OK; // selection is hidden or off
    1: 
    1:   nsIContent *newContent = mContent->GetParent();
    1: 
    1:   //check to see if we are anonymous content
    1:   PRInt32 offset = 0;
    1:   if (newContent) {
    1:     // XXXbz there has GOT to be a better way of determining this!
    1:     offset = newContent->IndexOf(mContent);
    1:   }
    1: 
    1:   SelectionDetails *details;
    1:   //look up to see what selection(s) are on this frame
    1:   details = frameSelection->LookUpSelection(newContent, offset, 1, PR_FALSE);
    1:   // XXX is the above really necessary? We don't actually DO anything
    1:   // with the details other than test that they're non-null
    1:   if (!details)
    1:     return NS_OK;
    1:   
    1:   while (details) {
    1:     SelectionDetails *next = details->mNext;
    1:     delete details;
    1:     details = next;
    1:   }
    1: 
    1:   return aLists.Content()->AppendNewToTop(new (aBuilder)
    1:       nsDisplaySelectionOverlay(this, selectionValue));
    1: }
    1: 
    1: nsresult
    1: nsFrame::DisplayOutlineUnconditional(nsDisplayListBuilder*   aBuilder,
    1:                                      const nsDisplayListSet& aLists)
    1: {
    1:   if (GetStyleOutline()->GetOutlineStyle() == NS_STYLE_BORDER_STYLE_NONE)
    1:     return NS_OK;
    1:     
    1:   return aLists.Outlines()->AppendNewToTop(new (aBuilder) nsDisplayOutline(this));
    1: }
    1: 
    1: nsresult
    1: nsFrame::DisplayOutline(nsDisplayListBuilder*   aBuilder,
    1:                         const nsDisplayListSet& aLists)
    1: {
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   return DisplayOutlineUnconditional(aBuilder, aLists);
    1: }
    1: 
    1: nsresult
    1: nsIFrame::DisplayCaret(nsDisplayListBuilder* aBuilder,
    1:                        const nsRect& aDirtyRect, const nsDisplayListSet& aLists)
    1: {
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   return aLists.Content()->AppendNewToTop(
    1:       new (aBuilder) nsDisplayCaret(this, aBuilder->GetCaret()));
    1: }
    1: 
    1: PRBool
 6862: nsFrame::HasBorder() const
 6862: {
25273:   // Border images contribute to the background of the content area
25273:   // even if there's no border proper.
25273:   return (GetUsedBorder() != nsMargin(0,0,0,0) ||
25273:           GetStyleBorder()->IsBorderImageLoaded());
    1: }
    1: 
    1: nsresult
30510: nsFrame::DisplayBackgroundUnconditional(nsDisplayListBuilder*   aBuilder,
30510:                                         const nsDisplayListSet& aLists,
30510:                                         PRBool                  aForceBackground)
30510: {
30510:   // Here we don't try to detect background propagation. Frames that might
30510:   // receive a propagated background should just set aForceBackground to
30510:   // PR_TRUE.
30510:   if (aBuilder->IsForEventDelivery() || aForceBackground ||
30510:       !GetStyleBackground()->IsTransparent() || GetStyleDisplay()->mAppearance) {
30510:     return aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
30510:         nsDisplayBackground(this));
30510:   }
30510:   return NS_OK;
30510: }
30510: 
30510: nsresult
    1: nsFrame::DisplayBorderBackgroundOutline(nsDisplayListBuilder*   aBuilder,
    1:                                         const nsDisplayListSet& aLists,
    1:                                         PRBool                  aForceBackground)
    1: {
    1:   // The visibility check belongs here since child elements have the
    1:   // opportunity to override the visibility property and display even if
    1:   // their parent is hidden.
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
26940:   PRBool hasBoxShadow = GetEffectiveBoxShadows() != nsnull;
24818:   if (hasBoxShadow) {
15700:     nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
24818:         nsDisplayBoxShadowOuter(this));
15700:     NS_ENSURE_SUCCESS(rv, rv);
15700:   }
15700: 
30510:   nsresult rv =
30510:     DisplayBackgroundUnconditional(aBuilder, aLists, aForceBackground);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
24818:   if (hasBoxShadow) {
30510:     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
24818:         nsDisplayBoxShadowInner(this));
24818:     NS_ENSURE_SUCCESS(rv, rv);
24818:   }
24818:   
    1:   if (HasBorder()) {
30510:     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayBorder(this));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return DisplayOutlineUnconditional(aBuilder, aLists);
    1: }
    1: 
    1: PRBool
  462: nsIFrame::GetAbsPosClipRect(const nsStyleDisplay* aDisp, nsRect* aRect,
  462:                             const nsSize& aSize)
    1: {
    1:   NS_PRECONDITION(aRect, "Must have aRect out parameter");
    1: 
    1:   if (!aDisp->IsAbsolutelyPositioned() ||
    1:       !(aDisp->mClipFlags & NS_STYLE_CLIP_RECT))
    1:     return PR_FALSE;
    1: 
  204:   *aRect = aDisp->mClip;
  204:   if (NS_STYLE_CLIP_RIGHT_AUTO & aDisp->mClipFlags) {
  462:     aRect->width = aSize.width - aRect->x;
  204:   }
  204:   if (NS_STYLE_CLIP_BOTTOM_AUTO & aDisp->mClipFlags) {
  462:     aRect->height = aSize.height - aRect->y;
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: static PRBool ApplyAbsPosClipping(nsDisplayListBuilder* aBuilder,
    1:                                   const nsStyleDisplay* aDisp, nsIFrame* aFrame,
    1:                                   nsRect* aRect) {
  462:   if (!aFrame->GetAbsPosClipRect(aDisp, aRect, aFrame->GetSize()))
    1:     return PR_FALSE;
    1: 
    1:   // A moving frame should not be allowed to clip a non-moving frame.
    1:   // Abs-pos clipping always clips frames below it in the frame tree, except
    1:   // for when an abs-pos frame clips a fixed-pos frame. So when fixed-pos
    1:   // elements are present we do not allow a moving abs-pos frame with
    1:   // an out-of-flow descendant (which could be a fixed frame) child to clip
    1:   // anything. It's OK to not clip anything, even the moving children ...
    1:   // all that could happen is that we get unnecessarily conservative results
    1:   // for nsLayoutUtils::ComputeRepaintRegionForCopy ... but this is a rare
    1:   // situation.
    1:   if (aBuilder->HasMovingFrames() &&
  238:       aFrame->PresContext()->FrameManager()->GetRootFrame()->
    1:           GetFirstChild(nsGkAtoms::fixedList) &&
    1:       aBuilder->IsMovingFrame(aFrame))
    1:     return PR_FALSE;
    1: 
    1:   *aRect += aBuilder->ToReferenceFrame(aFrame);
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: /**
    1:  * Returns PR_TRUE if aFrame is overflow:hidden and we should interpret
    1:  * that as -moz-hidden-unscrollable.
    1:  */
    1: static PRBool ApplyOverflowHiddenClipping(nsIFrame* aFrame,
    1:                                           const nsStyleDisplay* aDisp)
    1: {
    1:   if (aDisp->mOverflowX != NS_STYLE_OVERFLOW_HIDDEN)
    1:     return PR_FALSE;
    1:     
    1:   nsIAtom* type = aFrame->GetType();
    1:   // REVIEW: these are the frame types that call IsTableClip and set up
    1:   // clipping. Actually there were also table rows and the inner table frame
    1:   // doing this, but 'overflow' isn't applicable to them according to
    1:   // CSS 2.1 so I removed them. Also, we used to clip at tableOuterFrame
    1:   // but we should actually clip at tableFrame (as per discussion with Hixie and
    1:   // bz).
    1:   return type == nsGkAtoms::tableFrame ||
    1:        type == nsGkAtoms::tableCellFrame ||
    1:        type == nsGkAtoms::bcTableCellFrame;
    1: }
    1: 
    1: static PRBool ApplyOverflowClipping(nsDisplayListBuilder* aBuilder,
    1:                                     nsIFrame* aFrame,
    1:                                     const nsStyleDisplay* aDisp, nsRect* aRect) {
    1:   // REVIEW: from nsContainerFrame.cpp SyncFrameViewGeometryDependentProperties,
    1:   // except that that function used the border-edge for
    1:   // -moz-hidden-unscrollable which I don't think is correct... Also I've
    1:   // changed -moz-hidden-unscrollable to apply to any kind of frame.
    1: 
    1:   // Only -moz-hidden-unscrollable is handled here (and 'hidden' for table
    1:   // frames). Other overflow clipping is applied by nsHTML/XULScrollFrame.
    1:   if (!ApplyOverflowHiddenClipping(aFrame, aDisp)) {
    1:     PRBool clip = aDisp->mOverflowX == NS_STYLE_OVERFLOW_CLIP;
    1:     if (!clip)
    1:       return PR_FALSE;
    1:     // We allow -moz-hidden-unscrollable to apply to any kind of frame. This
    1:     // is required by comboboxes which make their display text (an inline frame)
    1:     // have clipping.
    1:   }
    1:   
 6276:   *aRect = aFrame->GetPaddingRect() - aFrame->GetPosition() +
 6276:     aBuilder->ToReferenceFrame(aFrame);
    1:   return PR_TRUE;
    1: }
    1: 
    1: class nsOverflowClipWrapper : public nsDisplayWrapper
    1: {
    1: public:
    1:   /**
    1:    * Create a wrapper to apply overflow clipping for aContainer.
    1:    * @param aClipBorderBackground set to PR_TRUE to clip the BorderBackground()
    1:    * list, otherwise it will not be clipped
    1:    * @param aClipAll set to PR_TRUE to clip all descendants, even those for
    1:    * which we aren't the containing block
    1:    */
    1:   nsOverflowClipWrapper(nsIFrame* aContainer, const nsRect& aRect,
    1:                         PRBool aClipBorderBackground, PRBool aClipAll)
    1:     : mContainer(aContainer), mRect(aRect),
    1:       mClipBorderBackground(aClipBorderBackground), mClipAll(aClipAll) {}
    1:   virtual PRBool WrapBorderBackground() { return mClipBorderBackground; }
    1:   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
    1:                                   nsIFrame* aFrame, nsDisplayList* aList) {
    1:     // We are not a stacking context root. There is no valid underlying
    1:     // frame for the whole list. These items are all in-flow descendants so
    1:     // we can safely just clip them.
14466:     return new (aBuilder) nsDisplayClip(nsnull, mContainer, aList, mRect);
    1:   }
    1:   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
    1:                                   nsDisplayItem* aItem) {
    1:     nsIFrame* f = aItem->GetUnderlyingFrame();
    1:     if (mClipAll || nsLayoutUtils::IsProperAncestorFrame(mContainer, f, nsnull))
14466:       return new (aBuilder) nsDisplayClip(f, mContainer, aItem, mRect);
    1:     return aItem;
    1:   }
    1: protected:
    1:   nsIFrame*    mContainer;
    1:   nsRect       mRect;
    1:   PRPackedBool mClipBorderBackground;
    1:   PRPackedBool mClipAll;
    1: };
    1: 
    1: class nsAbsPosClipWrapper : public nsDisplayWrapper
    1: {
    1: public:
14466:   nsAbsPosClipWrapper(nsIFrame* aContainer, const nsRect& aRect)
14466:     : mContainer(aContainer), mRect(aRect) {}
    1:   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
    1:                                   nsIFrame* aFrame, nsDisplayList* aList) {
    1:     // We are not a stacking context root. There is no valid underlying
    1:     // frame for the whole list.
14466:     return new (aBuilder) nsDisplayClip(nsnull, mContainer, aList, mRect);
    1:   }
    1:   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
    1:                                   nsDisplayItem* aItem) {
14466:     return new (aBuilder) nsDisplayClip(aItem->GetUnderlyingFrame(),
14466:             mContainer, aItem, mRect);
    1:   }
    1: protected:
14466:   nsIFrame* mContainer;
    1:   nsRect    mRect;
    1: };
    1: 
    1: nsresult
    1: nsIFrame::OverflowClip(nsDisplayListBuilder*   aBuilder,
    1:                        const nsDisplayListSet& aFromSet,
    1:                        const nsDisplayListSet& aToSet,
    1:                        const nsRect&           aClipRect,
    1:                        PRBool                  aClipBorderBackground,
    1:                        PRBool                  aClipAll)
    1: {
    1:   nsOverflowClipWrapper wrapper(this, aClipRect, aClipBorderBackground, aClipAll);
    1:   return wrapper.WrapLists(aBuilder, this, aFromSet, aToSet);
    1: }
    1: 
    1: nsresult
    1: nsIFrame::Clip(nsDisplayListBuilder*   aBuilder,
    1:                const nsDisplayListSet& aFromSet,
    1:                const nsDisplayListSet& aToSet,
    1:                const nsRect&           aClipRect)
    1: {
14466:   nsAbsPosClipWrapper wrapper(this, aClipRect);
    1:   return wrapper.WrapLists(aBuilder, this, aFromSet, aToSet);
    1: }
    1: 
    1: static nsresult
    1: BuildDisplayListWithOverflowClip(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
    1:     const nsRect& aDirtyRect, const nsDisplayListSet& aSet,
    1:     const nsRect& aClipRect)
    1: {
    1:   nsDisplayListCollection set;
    1:   nsresult rv = aFrame->BuildDisplayList(aBuilder, aDirtyRect, set);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = aBuilder->DisplayCaret(aFrame, aDirtyRect, aSet);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   return aFrame->OverflowClip(aBuilder, set, aSet, aClipRect);
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: static void PaintDebugBorder(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect, nsPoint aPt) {
    1:   nsRect r(aPt, aFrame->GetSize());
    1:   if (aFrame->HasView()) {
    1:     aCtx->SetColor(NS_RGB(0,0,255));
    1:   } else {
    1:     aCtx->SetColor(NS_RGB(255,0,0));
    1:   }
    1:   aCtx->DrawRect(r);
    1: }
    1: 
    1: static void PaintEventTargetBorder(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect, nsPoint aPt) {
    1:   nsRect r(aPt, aFrame->GetSize());
    1:   aCtx->SetColor(NS_RGB(128,0,128));
    1:   aCtx->DrawRect(r);
    1: }
    1: 
    1: static void
    1: DisplayDebugBorders(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
    1:                     const nsDisplayListSet& aLists) {
    1:   // Draw a border around the child
    1:   // REVIEW: From nsContainerFrame::PaintChild
31709:   if (nsFrame::GetShowFrameBorders() && !aFrame->GetRect().IsEmpty()) {
    1:     aLists.Outlines()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayGeneric(aFrame, PaintDebugBorder, "DebugBorder"));
    1:   }
    1:   // Draw a border around the current event target
31709:   if (nsFrame::GetShowEventTargetFrameBorder() &&
  238:       aFrame->PresContext()->PresShell()->GetDrawEventTargetFrame() == aFrame) {
    1:     aLists.Outlines()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayGeneric(aFrame, PaintEventTargetBorder, "EventTargetBorder"));
    1:   }
    1: }
    1: #endif
    1: 
    1: nsresult
    1: nsIFrame::BuildDisplayListForStackingContext(nsDisplayListBuilder* aBuilder,
    1:                                              const nsRect&         aDirtyRect,
    1:                                              nsDisplayList*        aList) {
 3724:   if (GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE)
    1:     return NS_OK;
    1: 
    1:   // Replaced elements have their visibility handled here, because
    1:   // they're visually atomic
    1:   if (IsFrameOfType(eReplaced) && !IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   nsRect absPosClip;
    1:   const nsStyleDisplay* disp = GetStyleDisplay();
34209:   // We can stop right away if this is a zero-opacity stacking context and
34209:   // we're not checking for event handling.
34209:   if (disp->mOpacity == 0.0 && !aBuilder->IsForEventDelivery())
34209:     return NS_OK;
34209: 
    1:   PRBool applyAbsPosClipping =
    1:       ApplyAbsPosClipping(aBuilder, disp, this, &absPosClip);
    1:   nsRect dirtyRect = aDirtyRect;
19214: 
30541:   PRBool inTransform = aBuilder->IsInTransform();
19214:   /* If we're being transformed, we need to invert the matrix transform so that we don't 
19214:    * grab points in the wrong coordinate system!
19214:    */
19948:   if ((mState & NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS) &&
30541:       disp->HasTransform()) {
19214:     dirtyRect = nsDisplayTransform::UntransformRect(dirtyRect, this, nsPoint(0, 0));
30541:     inTransform = PR_TRUE;
30541:   }
19214: 
    1:   if (applyAbsPosClipping) {
    1:     dirtyRect.IntersectRect(dirtyRect,
    1:                             absPosClip - aBuilder->ToReferenceFrame(this));
    1:   }
    1: 
19125: #ifdef MOZ_SVG
19125:   PRBool usingSVGEffects = nsSVGIntegrationUtils::UsingEffectsForFrame(this);
19125:   if (usingSVGEffects) {
19125:     dirtyRect =
19125:       nsSVGIntegrationUtils::GetRequiredSourceForInvalidArea(this, dirtyRect);
19125:   }
19125: #endif
19125: 
    1:   nsDisplayListCollection set;
    1:   nsresult rv;
    1:   {    
    1:     nsDisplayListBuilder::AutoIsRootSetter rootSetter(aBuilder, PR_TRUE);
30541:     nsDisplayListBuilder::AutoInTransformSetter
30541:       inTransformSetter(aBuilder, inTransform);
    1:     rv = BuildDisplayList(aBuilder, dirtyRect, set);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:   if (aBuilder->IsBackgroundOnly()) {
    1:     set.BlockBorderBackgrounds()->DeleteAll();
    1:     set.Floats()->DeleteAll();
    1:     set.Content()->DeleteAll();
    1:     set.PositionedDescendants()->DeleteAll();
    1:     set.Outlines()->DeleteAll();
    1:   }
    1:   
    1:   // This z-order sort also sorts secondarily by content order. We need to do
    1:   // this so that boxes produced by the same element are placed together
    1:   // in the sort. Consider a position:relative inline element that breaks
    1:   // across lines and has absolutely positioned children; all the abs-pos
    1:   // children should be z-ordered after all the boxes for the position:relative
    1:   // element itself.
    1:   set.PositionedDescendants()->SortByZOrder(aBuilder, GetContent());
    1:   
    1:   nsRect overflowClip;
    1:   if (ApplyOverflowClipping(aBuilder, this, disp, &overflowClip)) {
    1:     nsOverflowClipWrapper wrapper(this, overflowClip, PR_FALSE, PR_FALSE);
    1:     rv = wrapper.WrapListsInPlace(aBuilder, this, set);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   // We didn't use overflowClip to restrict the dirty rect, since some of the
    1:   // descendants may not be clipped by it. Even if we end up with unnecessary
33368:   // display items, they'll be pruned during ComputeVisibility.  
    1: 
    1:   nsDisplayList resultList;
    1:   // Now follow the rules of http://www.w3.org/TR/CSS21/zindex.html
    1:   // 1,2: backgrounds and borders
    1:   resultList.AppendToTop(set.BorderBackground());
    1:   // 3: negative z-index children.
    1:   for (;;) {
    1:     nsDisplayItem* item = set.PositionedDescendants()->GetBottom();
    1:     if (item) {
    1:       nsIFrame* f = item->GetUnderlyingFrame();
    1:       NS_ASSERTION(f, "After sorting, every item in the list should have an underlying frame");
    1:       if (nsLayoutUtils::GetZIndex(f) < 0) {
    1:         set.PositionedDescendants()->RemoveBottom();
    1:         resultList.AppendToTop(item);
    1:         continue;
    1:       }
    1:     }
    1:     break;
    1:   }
    1:   // 4: block backgrounds
    1:   resultList.AppendToTop(set.BlockBorderBackgrounds());
    1:   // 5: floats
    1:   resultList.AppendToTop(set.Floats());
 3660:   // 7: general content
    1:   resultList.AppendToTop(set.Content());
 3660:   // 7.5: outlines, in content tree order. We need to sort by content order
    1:   // because an element with outline that breaks and has children with outline
    1:   // might have placed child outline items between its own outline items.
    1:   // The element's outline items need to all come before any child outline
    1:   // items.
    1:   set.Outlines()->SortByContentOrder(aBuilder, GetContent());
    1: #ifdef NS_DEBUG
    1:   DisplayDebugBorders(aBuilder, this, set);
    1: #endif
   67:   resultList.AppendToTop(set.Outlines());
 3660:   // 8, 9: non-negative z-index children
 3660:   resultList.AppendToTop(set.PositionedDescendants());
    1: 
    1:   if (applyAbsPosClipping) {
14466:     nsAbsPosClipWrapper wrapper(this, absPosClip);
    1:     nsDisplayItem* item = wrapper.WrapList(aBuilder, this, &resultList);
    1:     if (!item)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     // resultList was emptied
    1:     resultList.AppendToTop(item);
    1:   }
    1:  
19125: #ifdef MOZ_SVG
19214:   /* If there are any SVG effects, wrap up the list in an effects list. */
19125:   if (usingSVGEffects) {
19214:     nsDisplaySVGEffects* svgList = new (aBuilder) nsDisplaySVGEffects(this, &resultList);
19214:     if (!svgList)
19214:       return NS_ERROR_OUT_OF_MEMORY;
19214: 
19214:     /* List now emptied, so add the new list to the top. */
19214:     resultList.AppendToTop(svgList);
19125:   } else
19125: #endif
19214: 
19214:   /* If there is any opacity, wrap it up in an opacity list. */
19125:   if (disp->mOpacity < 1.0f) {
19214:     nsDisplayOpacity* opacityList = new (aBuilder) nsDisplayOpacity(this, &resultList);
19214:     if (!opacityList)
19214:       return NS_ERROR_OUT_OF_MEMORY;
19214: 
19214:     resultList.AppendToTop(opacityList);
19214:   }
19214: 
19214:   /* If we're going to apply a transformation, wrap everything in an
19214:    * nsDisplayTransform.
19214:    */
19948:   if ((mState & NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS) &&
19948:       disp->HasTransform()) {
19214:     nsDisplayTransform* transform = new (aBuilder) nsDisplayTransform(this, &resultList);
19214:     if (!transform)  
19214:       return NS_ERROR_OUT_OF_MEMORY;
19214: 
19214:     resultList.AppendToTop(transform);
19214:   }
19214: 
    1:   aList->AppendToTop(&resultList);
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsIFrame::BuildDisplayListForChild(nsDisplayListBuilder*   aBuilder,
    1:                                    nsIFrame*               aChild,
    1:                                    const nsRect&           aDirtyRect,
    1:                                    const nsDisplayListSet& aLists,
    1:                                    PRUint32                aFlags) {
    1:   // If painting is restricted to just the background of the top level frame,
    1:   // then we have nothing to do here.
    1:   if (aBuilder->IsBackgroundOnly())
    1:     return NS_OK;
    1: 
 3724:   if (aChild->GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE)
    1:     return NS_OK;
    1:   
    1:   const nsStyleDisplay* disp = aChild->GetStyleDisplay();
    1:   // PR_TRUE if this is a real or pseudo stacking context
    1:   PRBool pseudoStackingContext =
    1:     (aFlags & DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT) != 0;
    1:   // XXX we REALLY need a "are you an inline-block sort of thing?" here!!!
    1:   if ((aFlags & DISPLAY_CHILD_INLINE) &&
    1:       (disp->mDisplay != NS_STYLE_DISPLAY_INLINE ||
    1:        aChild->IsContainingBlock() ||
    1:        (aChild->IsFrameOfType(eReplaced)))) {
    1:     // child is a non-inline frame in an inline context, i.e.,
    1:     // it acts like inline-block or inline-table. Therefore it is a
    1:     // pseudo-stacking-context.
    1:     pseudoStackingContext = PR_TRUE;
    1:   }
    1: 
    1:   // dirty rect in child-relative coordinates
    1:   nsRect dirty = aDirtyRect - aChild->GetOffsetTo(this);
    1: 
    1:   nsIAtom* childType = aChild->GetType();
    1:   if (childType == nsGkAtoms::placeholderFrame) {
 3233:     nsPlaceholderFrame* placeholder = static_cast<nsPlaceholderFrame*>(aChild);
    1:     aChild = placeholder->GetOutOfFlowFrame();
    1:     NS_ASSERTION(aChild, "No out of flow frame?");
32291:     if (!aChild || aChild->GetType() == nsGkAtoms::menuPopupFrame)
    1:       return NS_OK;
    1:     // update for the new child
    1:     disp = aChild->GetStyleDisplay();
    1:     // Make sure that any attempt to use childType below is disappointed. We
    1:     // could call GetType again but since we don't currently need it, let's
    1:     // avoid the virtual call.
    1:     childType = nsnull;
 3724:     // Recheck NS_FRAME_TOO_DEEP_IN_FRAME_TREE
 3724:     if (aChild->GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE)
    1:       return NS_OK;
 3233:     nsRect* savedDirty = static_cast<nsRect*>
 3233:                                     (aChild->GetProperty(nsGkAtoms::outOfFlowDirtyRectProperty));
    1:     if (savedDirty) {
    1:       dirty = *savedDirty;
    1:     } else {
    1:       // The out-of-flow frame did not intersect the dirty area. We may still
    1:       // need to traverse into it, since it may contain placeholders we need
    1:       // to enter to reach other out-of-flow frames that are visible.
    1:       dirty.Empty();
    1:     }
    1:     pseudoStackingContext = PR_TRUE;
    1:   }
    1: 
    1:   if (aBuilder->GetPaintAllFrames()) {
    1:     dirty = aChild->GetOverflowRect();
    1:   } else if (!(aChild->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO)) {
    1:     // No need to descend into aChild to catch placeholders for visible
    1:     // positioned stuff. So see if we can short-circuit frame traversal here.
    1: 
26699:     // We can stop if aChild's frame subtree's intersection with the
26699:     // dirty area is empty.
    1:     // If the child is a scrollframe that we want to ignore, then we need
    1:     // to descend into it because its scrolled child may intersect the dirty
    1:     // area even if the scrollframe itself doesn't.
26699:     if (aChild != aBuilder->GetIgnoreScrollFrame()) {
26699:       nsRect childDirty;
26699:       if (!childDirty.IntersectRect(dirty, aChild->GetOverflowRect()))
    1:         return NS_OK;
26699:       // Usually we could set dirty to childDirty now but there's no
26699:       // benefit, and it can be confusing. It can especially confuse
26699:       // situations where we're going to ignore a scrollframe's clipping;
26699:       // we wouldn't want to clip the dirty area to the scrollframe's
26699:       // bounds in that case.
26699:     }
    1:   }
    1: 
    1:   // XXX need to have inline-block and inline-table set pseudoStackingContext
    1:   
    1:   const nsStyleDisplay* ourDisp = GetStyleDisplay();
    1:   // REVIEW: Taken from nsBoxFrame::Paint
    1:   // Don't paint our children if the theme object is a leaf.
    1:   if (IsThemed(ourDisp) &&
  238:       !PresContext()->GetTheme()->WidgetIsContainer(ourDisp->mAppearance))
    1:     return NS_OK;
    1: 
19214:   // Child is composited if it's transformed, partially transparent, or has
19214:   // SVG effects.
19214:   PRBool isComposited = disp->mOpacity != 1.0f ||
19948:     ((aChild->mState & NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS) && 
19214:      aChild->GetStyleDisplay()->HasTransform())
19125: #ifdef MOZ_SVG
19125:     || nsSVGIntegrationUtils::UsingEffectsForFrame(aChild)
19125: #endif
19125:     ;
    1:   PRBool isPositioned = disp->IsPositioned();
32107:   if (isComposited || isPositioned || disp->IsFloating() ||
32107:       (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
    1:     // If you change this, also change IsPseudoStackingContextFromStyle()
    1:     pseudoStackingContext = PR_TRUE;
    1:   }
    1:   
    1:   nsRect overflowClip;
    1:   PRBool applyOverflowClip =
    1:     ApplyOverflowClipping(aBuilder, aChild, disp, &overflowClip);
    1:   // Don't use overflowClip to restrict the dirty rect, since some of the
    1:   // descendants may not be clipped by it. Even if we end up with unnecessary
33368:   // display items, they'll be pruned during ComputeVisibility. Note that
    1:   // this overflow-clipping here only applies to overflow:-moz-hidden-unscrollable;
    1:   // overflow:hidden etc creates an nsHTML/XULScrollFrame which does its own
    1:   // clipping.
    1: 
    1:   nsDisplayListBuilder::AutoIsRootSetter rootSetter(aBuilder, pseudoStackingContext);
    1:   nsresult rv;
    1:   if (!pseudoStackingContext) {
    1:     // THIS IS THE COMMON CASE.
    1:     // Not a pseudo or real stacking context. Do the simple thing and
    1:     // return early.
    1:     if (applyOverflowClip) {
    1:       rv = BuildDisplayListWithOverflowClip(aBuilder, aChild, dirty, aLists,
    1:                                             overflowClip);
    1:     } else {
    1:       rv = aChild->BuildDisplayList(aBuilder, dirty, aLists);
    1:       if (NS_SUCCEEDED(rv)) {
    1:         rv = aBuilder->DisplayCaret(aChild, dirty, aLists);
    1:       }
    1:     }
    1: #ifdef NS_DEBUG
    1:     DisplayDebugBorders(aBuilder, aChild, aLists);
    1: #endif
    1:     return rv;
    1:   }
    1:   
    1:   nsDisplayList list;
    1:   nsDisplayList extraPositionedDescendants;
    1:   const nsStylePosition* pos = aChild->GetStylePosition();
    1:   if ((isPositioned && pos->mZIndex.GetUnit() == eStyleUnit_Integer) ||
    1:       isComposited || (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
    1:     // True stacking context
    1:     rv = aChild->BuildDisplayListForStackingContext(aBuilder, dirty, &list);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       rv = aBuilder->DisplayCaret(aChild, dirty, aLists);
    1:     }
    1:   } else {
    1:     nsRect clipRect;
    1:     PRBool applyAbsPosClipping =
    1:         ApplyAbsPosClipping(aBuilder, disp, aChild, &clipRect);
 7046:     // A pseudo-stacking context (e.g., a positioned element with z-index auto).
    1:     // we allow positioned descendants of this element to escape to our
    1:     // container's positioned descendant list, because they might be
    1:     // z-index:non-auto
    1:     nsDisplayListCollection pseudoStack;
    1:     nsRect clippedDirtyRect = dirty;
    1:     if (applyAbsPosClipping) {
    1:       // clipRect is in builder-reference-frame coordinates,
    1:       // dirty/clippedDirtyRect are in aChild coordinates
    1:       clippedDirtyRect.IntersectRect(clippedDirtyRect,
    1:                                      clipRect - aBuilder->ToReferenceFrame(aChild));
    1:     }
    1:     
    1:     if (applyOverflowClip) {
    1:       rv = BuildDisplayListWithOverflowClip(aBuilder, aChild, clippedDirtyRect,
    1:                                             pseudoStack, overflowClip);
    1:     } else {
    1:       rv = aChild->BuildDisplayList(aBuilder, clippedDirtyRect, pseudoStack);
    1:       if (NS_SUCCEEDED(rv)) {
    1:         rv = aBuilder->DisplayCaret(aChild, dirty, aLists);
    1:       }
    1:     }
    1:     
    1:     if (NS_SUCCEEDED(rv)) {
    1:       if (isPositioned && applyAbsPosClipping) {
14466:         nsAbsPosClipWrapper wrapper(aChild, clipRect);
    1:         rv = wrapper.WrapListsInPlace(aBuilder, aChild, pseudoStack);
    1:       }
    1:     }
    1:     list.AppendToTop(pseudoStack.BorderBackground());
    1:     list.AppendToTop(pseudoStack.BlockBorderBackgrounds());
    1:     list.AppendToTop(pseudoStack.Floats());
    1:     list.AppendToTop(pseudoStack.Content());
 3660:     list.AppendToTop(pseudoStack.Outlines());
    1:     extraPositionedDescendants.AppendToTop(pseudoStack.PositionedDescendants());
    1: #ifdef NS_DEBUG
    1:     DisplayDebugBorders(aBuilder, aChild, aLists);
    1: #endif
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:   if (isPositioned || isComposited ||
    1:       (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
    1:     // Genuine stacking contexts, and positioned pseudo-stacking-contexts,
    1:     // go in this level.
    1:     rv = aLists.PositionedDescendants()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayWrapList(aChild, &list));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } else if (disp->IsFloating()) {
    1:     rv = aLists.Floats()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayWrapList(aChild, &list));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } else {
    1:     aLists.Content()->AppendToTop(&list);
    1:   }
    1:   // We delay placing the positioned descendants of positioned frames to here,
    1:   // because in the absence of z-index this is the correct order for them.
    1:   // This doesn't affect correctness because the positioned descendants list
    1:   // is sorted by z-order and content in BuildDisplayListForStackingContext,
    1:   // but it means that sort routine needs to do less work.
    1:   aLists.PositionedDescendants()->AppendToTop(&extraPositionedDescendants);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP  
    1: nsFrame::GetContentForEvent(nsPresContext* aPresContext,
    1:                             nsEvent* aEvent,
    1:                             nsIContent** aContent)
    1: {
32180:   nsIFrame* f = nsLayoutUtils::GetNonGeneratedAncestor(this);
32180:   *aContent = f->GetContent();
    1:   NS_IF_ADDREF(*aContent);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrame::FireDOMEvent(const nsAString& aDOMEventName, nsIContent *aContent)
    1: {
25812:   nsIContent* target = aContent ? aContent : mContent;
25812: 
25812:   if (target) {
25812:     nsRefPtr<nsPLDOMEvent> event =
25812:       new nsPLDOMEvent(target, aDOMEventName, PR_FALSE);
    1:     if (!event || NS_FAILED(event->PostDOMEvent()))
    1:       NS_WARNING("Failed to dispatch nsPLDOMEvent");
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::HandleEvent(nsPresContext* aPresContext, 
    1:                      nsGUIEvent*     aEvent,
    1:                      nsEventStatus*  aEventStatus)
    1: {
    1: 
    1:   if (aEvent->message == NS_MOUSE_MOVE) {
    1:     return HandleDrag(aPresContext, aEvent, aEventStatus);
    1:   }
    1: 
    1:   if (aEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:       static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton) {
    1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
    1:       HandlePress(aPresContext, aEvent, aEventStatus);
    1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
    1:       HandleRelease(aPresContext, aEvent, aEventStatus);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 8295: nsFrame::GetDataForTableSelection(const nsFrameSelection *aFrameSelection,
    1:                                   nsIPresShell *aPresShell, nsMouseEvent *aMouseEvent, 
    1:                                   nsIContent **aParentContent, PRInt32 *aContentOffset, PRInt32 *aTarget)
    1: {
    1:   if (!aFrameSelection || !aPresShell || !aMouseEvent || !aParentContent || !aContentOffset || !aTarget)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aParentContent = nsnull;
    1:   *aContentOffset = 0;
    1:   *aTarget = 0;
    1: 
    1:   PRInt16 displaySelection;
    1:   nsresult result = aPresShell->GetSelectionFlags(&displaySelection);
    1:   if (NS_FAILED(result))
    1:     return result;
    1: 
    1:   PRBool selectingTableCells = aFrameSelection->GetTableCellSelection();
    1: 
    1:   // DISPLAY_ALL means we're in an editor.
    1:   // If already in cell selection mode, 
    1:   //  continue selecting with mouse drag or end on mouse up,
    1:   //  or when using shift key to extend block of cells
    1:   //  (Mouse down does normal selection unless Ctrl/Cmd is pressed)
    1:   PRBool doTableSelection =
    1:      displaySelection == nsISelectionDisplay::DISPLAY_ALL && selectingTableCells &&
    1:      (aMouseEvent->message == NS_MOUSE_MOVE ||
    1:       (aMouseEvent->message == NS_MOUSE_BUTTON_UP &&
    1:        aMouseEvent->button == nsMouseEvent::eLeftButton) ||
    1:       aMouseEvent->isShift);
    1: 
    1:   if (!doTableSelection)
    1:   {  
    1:     // In Browser, special 'table selection' key must be pressed for table selection
    1:     // or when just Shift is pressed and we're already in table/cell selection mode
 6499: #ifdef XP_MACOSX
    1:     doTableSelection = aMouseEvent->isMeta || (aMouseEvent->isShift && selectingTableCells);
    1: #else
    1:     doTableSelection = aMouseEvent->isControl || (aMouseEvent->isShift && selectingTableCells);
    1: #endif
    1:   }
    1:   if (!doTableSelection) 
    1:     return NS_OK;
    1: 
    1:   // Get the cell frame or table frame (or parent) of the current content node
    1:   nsIFrame *frame = this;
    1:   PRBool foundCell = PR_FALSE;
    1:   PRBool foundTable = PR_FALSE;
    1: 
    1:   // Get the limiting node to stop parent frame search
    1:   nsIContent* limiter = aFrameSelection->GetLimiter();
    1: 
    1:   //We don't initiate row/col selection from here now,
    1:   //  but we may in future
    1:   //PRBool selectColumn = PR_FALSE;
    1:   //PRBool selectRow = PR_FALSE;
    1:   
    1:   result = NS_OK;
    1: 
    1:   while (frame && NS_SUCCEEDED(result))
    1:   {
    1:     // Check for a table cell by querying to a known CellFrame interface
23554:     nsITableCellLayout *cellElement = do_QueryFrame(frame);
23554:     if (cellElement)
    1:     {
    1:       foundCell = PR_TRUE;
    1:       //TODO: If we want to use proximity to top or left border
    1:       //      for row and column selection, this is the place to do it
    1:       break;
    1:     }
    1:     else
    1:     {
    1:       // If not a cell, check for table
    1:       // This will happen when starting frame is the table or child of a table,
    1:       //  such as a row (we were inbetween cells or in table border)
23554:       nsITableLayout *tableElement = do_QueryFrame(frame);
23554:       if (tableElement)
    1:       {
    1:         foundTable = PR_TRUE;
    1:         //TODO: How can we select row when along left table edge
    1:         //  or select column when along top edge?
    1:         break;
    1:       } else {
    1:         frame = frame->GetParent();
    1:         result = NS_OK;
    1:         // Stop if we have hit the selection's limiting content node
    1:         if (frame && frame->GetContent() == limiter)
    1:           break;
    1:       }
    1:     }
    1:   }
    1:   // We aren't in a cell or table
    1:   if (!foundCell && !foundTable) return NS_OK;
    1: 
    1:   nsIContent* tableOrCellContent = frame->GetContent();
    1:   if (!tableOrCellContent) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIContent> parentContent = tableOrCellContent->GetParent();
    1:   if (!parentContent) return NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 offset = parentContent->IndexOf(tableOrCellContent);
    1:   // Not likely?
    1:   if (offset < 0) return NS_ERROR_FAILURE;
    1: 
    1:   // Everything is OK -- set the return values
    1:   *aParentContent = parentContent;
    1:   NS_ADDREF(*aParentContent);
    1: 
    1:   *aContentOffset = offset;
    1: 
    1: #if 0
    1:   if (selectRow)
    1:     *aTarget = nsISelectionPrivate::TABLESELECTION_ROW;
    1:   else if (selectColumn)
    1:     *aTarget = nsISelectionPrivate::TABLESELECTION_COLUMN;
    1:   else 
    1: #endif
    1:   if (foundCell)
    1:     *aTarget = nsISelectionPrivate::TABLESELECTION_CELL;
    1:   else if (foundTable)
    1:     *aTarget = nsISelectionPrivate::TABLESELECTION_TABLE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::IsSelectable(PRBool* aSelectable, PRUint8* aSelectStyle) const
    1: {
    1:   if (!aSelectable) //it's ok if aSelectStyle is null
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Like 'visibility', we must check all the parents: if a parent
    1:   // is not selectable, none of its children is selectable.
    1:   //
    1:   // The -moz-all value acts similarly: if a frame has 'user-select:-moz-all',
    1:   // all its children are selectable, even those with 'user-select:none'.
    1:   //
    1:   // As a result, if 'none' and '-moz-all' are not present in the frame hierarchy,
    1:   // aSelectStyle returns the first style that is not AUTO. If these values
    1:   // are present in the frame hierarchy, aSelectStyle returns the style of the
    1:   // topmost parent that has either 'none' or '-moz-all'.
    1:   //
    1:   // For instance, if the frame hierarchy is:
    1:   //    AUTO     -> _MOZ_ALL -> NONE -> TEXT,     the returned value is _MOZ_ALL
    1:   //    TEXT     -> NONE     -> AUTO -> _MOZ_ALL, the returned value is NONE
    1:   //    _MOZ_ALL -> TEXT     -> AUTO -> AUTO,     the returned value is _MOZ_ALL
    1:   //    AUTO     -> CELL     -> TEXT -> AUTO,     the returned value is TEXT
    1:   //
    1:   PRUint8 selectStyle  = NS_STYLE_USER_SELECT_AUTO;
    1:   nsIFrame* frame      = (nsIFrame*)this;
    1: 
    1:   while (frame) {
    1:     const nsStyleUIReset* userinterface = frame->GetStyleUIReset();
    1:     switch (userinterface->mUserSelect) {
    1:       case NS_STYLE_USER_SELECT_ALL:
    1:       case NS_STYLE_USER_SELECT_NONE:
    1:       case NS_STYLE_USER_SELECT_MOZ_ALL:
    1:         // override the previous values
    1:         selectStyle = userinterface->mUserSelect;
    1:         break;
    1:       default:
    1:         // otherwise return the first value which is not 'auto'
    1:         if (selectStyle == NS_STYLE_USER_SELECT_AUTO) {
    1:           selectStyle = userinterface->mUserSelect;
    1:         }
    1:         break;
    1:     }
    1:     frame = frame->GetParent();
    1:   }
    1: 
    1:   // convert internal values to standard values
    1:   if (selectStyle == NS_STYLE_USER_SELECT_AUTO)
    1:     selectStyle = NS_STYLE_USER_SELECT_TEXT;
    1:   else
    1:   if (selectStyle == NS_STYLE_USER_SELECT_MOZ_ALL)
    1:     selectStyle = NS_STYLE_USER_SELECT_ALL;
    1:   else
    1:   if (selectStyle == NS_STYLE_USER_SELECT_MOZ_NONE)
    1:     selectStyle = NS_STYLE_USER_SELECT_NONE;
    1: 
    1:   // return stuff
    1:   if (aSelectable)
    1:     *aSelectable = (selectStyle != NS_STYLE_USER_SELECT_NONE);
    1:   if (aSelectStyle)
    1:     *aSelectStyle = selectStyle;
    1:   if (mState & NS_FRAME_GENERATED_CONTENT)
    1:     *aSelectable = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * Handles the Mouse Press Event for the frame
    1:  */
    1: NS_IMETHODIMP
    1: nsFrame::HandlePress(nsPresContext* aPresContext, 
    1:                      nsGUIEvent*     aEvent,
    1:                      nsEventStatus*  aEventStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
    1:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   //We often get out of sync state issues with mousedown events that
    1:   //get interrupted by alerts/dialogs.
    1:   //Check with the ESM to see if we should process this one
    1:   PRBool eventOK;
    1:   aPresContext->EventStateManager()->EventStatusOK(aEvent, &eventOK);
    1:   if (!eventOK) 
    1:     return NS_OK;
    1: 
    1:   nsresult rv;
    1:   nsIPresShell *shell = aPresContext->GetPresShell();
    1:   if (!shell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // if we are in Navigator and the click is in a draggable node, we don't want
    1:   // to start selection because we don't want to interfere with a potential
    1:   // drag of said node and steal all its glory.
    1:   PRInt16 isEditor = 0;
    1:   shell->GetSelectionFlags ( &isEditor );
    1:   //weaaak. only the editor can display frame selction not just text and images
    1:   isEditor = isEditor == nsISelectionDisplay::DISPLAY_ALL;
    1: 
    1:   nsInputEvent* keyEvent = (nsInputEvent*)aEvent;
14472:   if (!keyEvent->isAlt) {
    1:     
    1:     for (nsIContent* content = mContent; content;
    1:          content = content->GetParent()) {
14472:       if (nsContentUtils::ContentIsDraggable(content) &&
14472:           !content->IsEditable()) {
    1:         // coordinate stuff is the fix for bug #55921
    1:         if ((mRect - GetPosition()).Contains(
    1:                nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this)))
    1:           return NS_OK;
    1:       }
    1:     }
14472:   }
    1: 
    1:   // check whether style allows selection
    1:   // if not, don't tell selection the mouse event even occurred.  
    1:   PRBool  selectable;
    1:   PRUint8 selectStyle;
    1:   rv = IsSelectable(&selectable, &selectStyle);
    1:   if (NS_FAILED(rv)) return rv;
    1:   
    1:   // check for select: none
    1:   if (!selectable)
    1:     return NS_OK;
    1: 
    1:   // When implementing NS_STYLE_USER_SELECT_ELEMENT, NS_STYLE_USER_SELECT_ELEMENTS and
    1:   // NS_STYLE_USER_SELECT_TOGGLE, need to change this logic
    1:   PRBool useFrameSelection = (selectStyle == NS_STYLE_USER_SELECT_TEXT);
    1: 
32435:   // If the mouse is dragged outside the nearest enclosing scrollable area
32435:   // while making a selection, the area will be scrolled. To do this, capture
32435:   // the mouse on the nearest scrollable frame. If there isn't a scrollable
32435:   // frame, or something else is already capturing the mouse, there's no
32435:   // reason to capture.
32435:   if (!nsIPresShell::GetCapturingContent()) {
32435:     nsIFrame* checkFrame = this;
32435:     nsIScrollableFrame *scrollFrame = nsnull;
32435:     while (checkFrame) {
32435:       scrollFrame = do_QueryFrame(checkFrame);
32435:       if (scrollFrame) {
32435:         nsIPresShell::SetCapturingContent(checkFrame->GetContent(), CAPTURE_IGNOREALLOWED);
32435:         break;
32435:       }
32435:       checkFrame = checkFrame->GetParent();
32435:     }
32435:   }
26712: 
    1:   // XXX This is screwy; it really should use the selection frame, not the
    1:   // event frame
 8295:   const nsFrameSelection* frameselection = nsnull;
    1:   if (useFrameSelection)
 8295:     frameselection = GetConstFrameSelection();
    1:   else
 8295:     frameselection = shell->ConstFrameSelection();
    1: 
    1:   if (frameselection->GetDisplaySelection() == nsISelectionController::SELECTION_OFF)
    1:     return NS_OK;//nothing to do we cannot affect selection from here
    1: 
    1:   nsMouseEvent *me = (nsMouseEvent *)aEvent;
    1: 
 6499: #ifdef XP_MACOSX
    1:   if (me->isControl)
    1:     return NS_OK;//short ciruit. hard coded for mac due to time restraints.
20590:   PRBool control = me->isMeta;
20590: #else
20590:   PRBool control = me->isControl;
    1: #endif
20590: 
 8295:   nsCOMPtr<nsFrameSelection> fc = const_cast<nsFrameSelection*>(frameselection);
    1:   if (me->clickCount >1 )
    1:   {
 8295:     // These methods aren't const but can't actually delete anything,
 8295:     // so no need for nsWeakFrame.
 8295:     fc->SetMouseDownState(PR_TRUE);
 8295:     fc->SetMouseDoubleDown(PR_TRUE);
20590:     return HandleMultiplePress(aPresContext, aEvent, aEventStatus, control);
    1:   }
    1: 
26712:   nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
26712:   ContentOffsets offsets = GetContentOffsetsFromPoint(pt);
26712: 
    1:   if (!offsets.content)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Let Ctrl/Cmd+mouse down do table selection instead of drag initiation
    1:   nsCOMPtr<nsIContent>parentContent;
    1:   PRInt32  contentOffset;
    1:   PRInt32 target;
    1:   rv = GetDataForTableSelection(frameselection, shell, me, getter_AddRefs(parentContent), &contentOffset, &target);
    1:   if (NS_SUCCEEDED(rv) && parentContent)
    1:   {
 8295:     fc->SetMouseDownState(PR_TRUE);
 8295:     return fc->HandleTableSelection(parentContent, contentOffset, target, me);
 8295:   }
 8295: 
 8295:   fc->SetDelayedCaretData(0);
    1: 
    1:   // Check if any part of this frame is selected, and if the
    1:   // user clicked inside the selected region. If so, we delay
    1:   // starting a new selection since the user may be trying to
    1:   // drag the selected region to some other app.
    1: 
    1:   SelectionDetails *details = 0;
    1:   PRBool isSelected = ((GetStateBits() & NS_FRAME_SELECTED_CONTENT) == NS_FRAME_SELECTED_CONTENT);
    1: 
    1:   if (isSelected)
    1:   {
20685:     PRBool inSelection = PR_FALSE;
    1:     details = frameselection->LookUpSelection(offsets.content, 0,
    1:         offsets.EndOffset(), PR_FALSE);
    1: 
    1:     //
    1:     // If there are any details, check to see if the user clicked
    1:     // within any selected region of the frame.
    1:     //
    1: 
    1:     SelectionDetails *curDetail = details;
    1: 
    1:     while (curDetail)
    1:     {
    1:       //
    1:       // If the user clicked inside a selection, then just
    1:       // return without doing anything. We will handle placing
    1:       // the caret later on when the mouse is released. We ignore
18761:       // the spellcheck and find selections.
    1:       //
    1:       if (curDetail->mType != nsISelectionController::SELECTION_SPELLCHECK &&
18761:           curDetail->mType != nsISelectionController::SELECTION_FIND &&
    1:           curDetail->mStart <= offsets.StartOffset() &&
    1:           offsets.EndOffset() <= curDetail->mEnd)
    1:       {
20685:         inSelection = PR_TRUE;
20685:       }
20685: 
20685:       SelectionDetails *nextDetail = curDetail->mNext;
20685:       delete curDetail;
20685:       curDetail = nextDetail;
20685:     }
20685: 
20685:     if (inSelection) {
 8295:       fc->SetMouseDownState(PR_FALSE);
 8295:       fc->SetDelayedCaretData(me);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
 8295:   fc->SetMouseDownState(PR_TRUE);
    1: 
 8295:   // Do not touch any nsFrame members after this point without adding
 8295:   // weakFrame checks.
 8295:   rv = fc->HandleClick(offsets.content, offsets.StartOffset(),
    1:                        offsets.EndOffset(), me->isShift, control,
    1:                        offsets.associateWithNext);
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   if (offsets.offset != offsets.secondaryOffset)
 8295:     fc->MaintainSelection();
    1: 
    1:   if (isEditor && !me->isShift &&
    1:       (offsets.EndOffset() - offsets.StartOffset()) == 1)
    1:   {
    1:     // A single node is selected and we aren't extending an existing
    1:     // selection, which means the user clicked directly on an object (either
    1:     // -moz-user-select: all or a non-text node without children).
    1:     // Therefore, disable selection extension during mouse moves.
    1:     // XXX This is a bit hacky; shouldn't editor be able to deal with this?
 8295:     fc->SetMouseDownState(PR_FALSE);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /**
    1:   * Multiple Mouse Press -- line or paragraph selection -- for the frame.
    1:   * Wouldn't it be nice if this didn't have to be hardwired into Frame code?
    1:  */
    1: NS_IMETHODIMP
    1: nsFrame::HandleMultiplePress(nsPresContext* aPresContext, 
    1:                              nsGUIEvent*    aEvent,
20590:                              nsEventStatus* aEventStatus,
20590:                              PRBool         aControlHeld)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
    1:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Find out whether we're doing line or paragraph selection.
    1:   // If browser.triple_click_selects_paragraph is true, triple-click selects paragraph.
    1:   // Otherwise, triple-click selects line, and quadruple-click selects paragraph
    1:   // (on platforms that support quadruple-click).
    1:   nsSelectionAmount beginAmount, endAmount;
    1:   nsMouseEvent *me = (nsMouseEvent *)aEvent;
    1:   if (!me) return NS_OK;
    1: 
    1:   if (me->clickCount == 4) {
    1:     beginAmount = endAmount = eSelectParagraph;
    1:   } else if (me->clickCount == 3) {
    1:     if (nsContentUtils::GetBoolPref("browser.triple_click_selects_paragraph")) {
    1:       beginAmount = endAmount = eSelectParagraph;
    1:     } else {
    1:       beginAmount = eSelectBeginLine;
    1:       endAmount = eSelectEndLine;
    1:     }
    1:   } else if (me->clickCount == 2) {
    1:     // We only want inline frames; PeekBackwardAndForward dislikes blocks
    1:     beginAmount = endAmount = eSelectWord;
    1:   } else {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
    1:   ContentOffsets offsets = GetContentOffsetsFromPoint(pt);
    1:   if (!offsets.content) return NS_ERROR_FAILURE;
    1: 
    1:   nsIFrame* theFrame;
    1:   PRInt32 offset;
    1:   // Maybe make this a static helper?
 8295:   const nsFrameSelection* frameSelection =
 8295:     PresContext()->GetPresShell()->ConstFrameSelection();
 8295:   theFrame = frameSelection->
    1:     GetFrameForNodeOffset(offsets.content, offsets.offset,
    1:                           nsFrameSelection::HINT(offsets.associateWithNext),
    1:                           &offset);
    1:   if (!theFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
 3233:   nsFrame* frame = static_cast<nsFrame*>(theFrame);
    1: 
    1:   return frame->PeekBackwardAndForward(beginAmount, endAmount,
    1:                                        offsets.offset, aPresContext,
20590:                                        beginAmount != eSelectWord,
20590:                                        aControlHeld);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::PeekBackwardAndForward(nsSelectionAmount aAmountBack,
    1:                                 nsSelectionAmount aAmountForward,
    1:                                 PRInt32 aStartPos,
    1:                                 nsPresContext* aPresContext,
20590:                                 PRBool aJumpLines,
20590:                                 PRBool aMultipleSelection)
20590: {
    1:   nsIFrame* baseFrame = this;
    1:   PRInt32 baseOffset = aStartPos;
20590:   nsresult rv;
20590: 
    1:   if (aAmountBack == eSelectWord) {
    1:     // To avoid selecting the previous word when at start of word,
    1:     // first move one character forward.
    1:     nsPeekOffsetStruct pos;
    1:     pos.SetData(eSelectCharacter,
    1:                 eDirNext,
    1:                 aStartPos,
    1:                 0,
    1:                 aJumpLines,
    1:                 PR_TRUE,  //limit on scrolled views
    1:                 PR_FALSE,
    1:                 PR_FALSE);
    1:     rv = PeekOffset(&pos);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       baseFrame = pos.mResultFrame;
    1:       baseOffset = pos.mContentOffset;
    1:     }
    1:   }
20590: 
20590:   // Use peek offset one way then the other:  
    1:   nsPeekOffsetStruct startpos;
    1:   startpos.SetData(aAmountBack,
    1:                    eDirPrevious,
    1:                    baseOffset, 
    1:                    0,
    1:                    aJumpLines,
    1:                    PR_TRUE,  //limit on scrolled views
    1:                    PR_FALSE,
    1:                    PR_FALSE);
    1:   rv = baseFrame->PeekOffset(&startpos);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   nsPeekOffsetStruct endpos;
    1:   endpos.SetData(aAmountForward,
    1:                  eDirNext,
    1:                  aStartPos, 
    1:                  0,
    1:                  aJumpLines,
    1:                  PR_TRUE,  //limit on scrolled views
    1:                  PR_FALSE,
    1:                  PR_FALSE);
    1:   rv = PeekOffset(&endpos);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
20590:   // Keep frameSelection alive.
20590:   nsRefPtr<nsFrameSelection> frameSelection = GetFrameSelection();
20590: 
20590:   rv = frameSelection->HandleClick(startpos.mResultContent,
20590:                                    startpos.mContentOffset, startpos.mContentOffset,
20590:                                    PR_FALSE, aMultipleSelection,
20590:                                    nsFrameSelection::HINTRIGHT);
    1:   if (NS_FAILED(rv))
    1:     return rv;
20590: 
20590:   rv = frameSelection->HandleClick(endpos.mResultContent,
20590:                                    endpos.mContentOffset, endpos.mContentOffset,
20590:                                    PR_TRUE, PR_FALSE,
20590:                                    nsFrameSelection::HINTLEFT);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // maintain selection
 5907:   return frameSelection->MaintainSelection(aAmountBack);
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::HandleDrag(nsPresContext* aPresContext, 
    1:                                   nsGUIEvent*     aEvent,
    1:                                   nsEventStatus*  aEventStatus)
    1: {
    1:   PRBool  selectable;
    1:   PRUint8 selectStyle;
    1:   IsSelectable(&selectable, &selectStyle);
    1:   // XXX Do we really need to exclude non-selectable content here?
18884:   // GetContentOffsetsFromPoint can handle it just fine, although some
    1:   // other stuff might not like it.
    1:   if (!selectable)
    1:     return NS_OK;
    1:   if (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF) {
    1:     return NS_OK;
    1:   }
    1:   nsIPresShell *presShell = aPresContext->PresShell();
    1: 
    1:   nsCOMPtr<nsFrameSelection> frameselection = GetFrameSelection();
    1:   PRBool mouseDown = frameselection->GetMouseDownState();
    1:   if (!mouseDown)
    1:     return NS_OK;
    1: 
    1:   frameselection->StopAutoScrollTimer();
    1: 
    1:   // Check if we are dragging in a table cell
    1:   nsCOMPtr<nsIContent> parentContent;
    1:   PRInt32 contentOffset;
    1:   PRInt32 target;
    1:   nsMouseEvent *me = (nsMouseEvent *)aEvent;
    1:   nsresult result;
    1:   result = GetDataForTableSelection(frameselection, presShell, me,
    1:                                     getter_AddRefs(parentContent),
    1:                                     &contentOffset, &target);      
    1: 
35219:   nsWeakFrame weakThis = this;
    1:   if (NS_SUCCEEDED(result) && parentContent) {
    1:     frameselection->HandleTableSelection(parentContent, contentOffset, target, me);
    1:   } else {
    1:     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
    1:     frameselection->HandleDrag(this, pt);
    1:   }
    1: 
35219:   // The frameselection object notifies selection listeners synchronously above
35219:   // which might have killed us.
35219:   if (!weakThis.IsAlive()) {
35219:     return NS_OK;
35219:   }
35219: 
32435:   // get the nearest scrollframe
32435:   nsIFrame* checkFrame = this;
32435:   nsIScrollableFrame *scrollFrame = nsnull;
32435:   while (checkFrame) {
32435:     scrollFrame = do_QueryFrame(checkFrame);
32435:     if (scrollFrame) {
32435:       break;
32435:     }
32435:     checkFrame = checkFrame->GetParent();
32435:   }
32435: 
32435:   if (scrollFrame) {
32435:     nsIView* capturingView = scrollFrame->GetScrollableView()->View();
32435:     if (capturingView) {
    1:       // Get the view that aEvent->point is relative to. This is disgusting.
    1:       nsIView* eventView = nsnull;
    1:       nsPoint pt = nsLayoutUtils::GetEventCoordinatesForNearestView(aEvent, this,
    1:                                                                     &eventView);
32435:       nsPoint capturePt = pt + eventView->GetOffsetTo(capturingView);
32435:       frameselection->StartAutoScrollTimer(capturingView, capturePt, 30);
32435:     }
32435:   }
32435: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * This static method handles part of the nsFrame::HandleRelease in a way
    1:  * which doesn't rely on the nsFrame object to stay alive.
    1:  */
    1: static nsresult
    1: HandleFrameSelection(nsFrameSelection*         aFrameSelection,
    1:                      nsIFrame::ContentOffsets& aOffsets,
    1:                      PRBool                    aHandleTableSel,
    1:                      PRInt32                   aContentOffsetForTableSel,
    1:                      PRInt32                   aTargetForTableSel,
    1:                      nsIContent*               aParentContentForTableSel,
    1:                      nsGUIEvent*               aEvent,
    1:                      nsEventStatus*            aEventStatus)
    1: {
    1:   if (!aFrameSelection) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (nsEventStatus_eConsumeNoDefault != *aEventStatus) {
    1:     if (!aHandleTableSel) {
    1:       nsMouseEvent *me = aFrameSelection->GetDelayedCaretData();
    1:       if (!aOffsets.content || !me) {
    1:         return NS_ERROR_FAILURE;
    1:       }
    1: 
    1:       // We are doing this to simulate what we would have done on HandlePress.
    1:       // We didn't do it there to give the user an opportunity to drag
    1:       // the text, but since they didn't drag, we want to place the
    1:       // caret.
    1:       // However, we'll use the mouse position from the release, since:
    1:       //  * it's easier
    1:       //  * that's the normal click position to use (although really, in
    1:       //    the normal case, small movements that don't count as a drag
    1:       //    can do selection)
    1:       aFrameSelection->SetMouseDownState(PR_TRUE);
    1: 
    1:       rv = aFrameSelection->HandleClick(aOffsets.content,
    1:                                         aOffsets.StartOffset(),
    1:                                         aOffsets.EndOffset(),
    1:                                         me->isShift, PR_FALSE,
    1:                                         aOffsets.associateWithNext);
    1:       if (NS_FAILED(rv)) {
    1:         return rv;
    1:       }
    1:     } else if (aParentContentForTableSel) {
    1:       aFrameSelection->SetMouseDownState(PR_FALSE);
    1:       rv = aFrameSelection->HandleTableSelection(aParentContentForTableSel,
    1:                                                  aContentOffsetForTableSel,
    1:                                                  aTargetForTableSel,
    1:                                                  (nsMouseEvent *)aEvent);
    1:       if (NS_FAILED(rv)) {
    1:         return rv;
    1:       }
    1:     }
    1:     aFrameSelection->SetDelayedCaretData(0);
    1:   }
    1: 
    1:   aFrameSelection->SetMouseDownState(PR_FALSE);
    1:   aFrameSelection->StopAutoScrollTimer();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::HandleRelease(nsPresContext* aPresContext,
    1:                                      nsGUIEvent*    aEvent,
    1:                                      nsEventStatus* aEventStatus)
    1: {
32435:   nsIFrame* activeFrame = GetActiveSelectionFrame(aPresContext, this);
    1: 
    1:   // We can unconditionally stop capturing because
    1:   // we should never be capturing when the mouse button is up
32435:   nsIPresShell::SetCapturingContent(nsnull, 0);
    1: 
    1:   PRBool selectionOff =
    1:     (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF);
    1: 
    1:   nsRefPtr<nsFrameSelection> frameselection;
    1:   ContentOffsets offsets;
    1:   nsCOMPtr<nsIContent> parentContent;
    1:   PRInt32 contentOffsetForTableSel = 0;
    1:   PRInt32 targetForTableSel = 0;
    1:   PRBool handleTableSelection = PR_TRUE;
    1: 
    1:   if (!selectionOff) {
    1:     frameselection = GetFrameSelection();
    1:     if (nsEventStatus_eConsumeNoDefault != *aEventStatus && frameselection) {
    1:       // Check if the frameselection recorded the mouse going down.
    1:       // If not, the user must have clicked in a part of the selection.
    1:       // Place the caret before continuing!
    1: 
    1:       PRBool mouseDown = frameselection->GetMouseDownState();
    1:       nsMouseEvent *me = frameselection->GetDelayedCaretData();
    1: 
    1:       if (!mouseDown && me && me->clickCount < 2) {
    1:         nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
    1:         offsets = GetContentOffsetsFromPoint(pt);
    1:         handleTableSelection = PR_FALSE;
    1:       } else {
  238:         GetDataForTableSelection(frameselection, PresContext()->PresShell(),
    1:                                  (nsMouseEvent *)aEvent,
    1:                                  getter_AddRefs(parentContent),
    1:                                  &contentOffsetForTableSel,
    1:                                  &targetForTableSel);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // We might be capturing in some other document and the event just happened to
    1:   // trickle down here. Make sure that document's frame selection is notified.
    1:   // Note, this may cause the current nsFrame object to be deleted, bug 336592.
    1:   if (activeFrame != this &&
 3233:       static_cast<nsFrame*>(activeFrame)->DisplaySelection(activeFrame->PresContext())
    1:         != nsISelectionController::SELECTION_OFF) {
    1:     nsRefPtr<nsFrameSelection> frameSelection =
    1:       activeFrame->GetFrameSelection();
    1:     frameSelection->SetMouseDownState(PR_FALSE);
    1:     frameSelection->StopAutoScrollTimer();
    1:   }
    1: 
    1:   // Do not call any methods of the current object after this point!!!
    1:   // The object is perhaps dead!
    1: 
    1:   return selectionOff
    1:     ? NS_OK
    1:     : HandleFrameSelection(frameselection, offsets, handleTableSelection,
    1:                            contentOffsetForTableSel, targetForTableSel,
    1:                            parentContent, aEvent, aEventStatus);
    1: }
    1: 
15599: struct NS_STACK_CLASS FrameContentRange {
    1:   FrameContentRange(nsIContent* aContent, PRInt32 aStart, PRInt32 aEnd) :
    1:     content(aContent), start(aStart), end(aEnd) { }
    1:   nsCOMPtr<nsIContent> content;
    1:   PRInt32 start;
    1:   PRInt32 end;
    1: };
    1: 
    1: // Retrieve the content offsets of a frame
    1: static FrameContentRange GetRangeForFrame(nsIFrame* aFrame) {
    1:   nsCOMPtr<nsIContent> content, parent;
    1:   content = aFrame->GetContent();
    1:   if (!content) {
    1:     NS_WARNING("Frame has no content");
    1:     return FrameContentRange(nsnull, -1, -1);
    1:   }
    1:   nsIAtom* type = aFrame->GetType();
    1:   if (type == nsGkAtoms::textFrame) {
    1:     PRInt32 offset, offsetEnd;
    1:     aFrame->GetOffsets(offset, offsetEnd);
    1:     return FrameContentRange(content, offset, offsetEnd);
    1:   }
    1:   if (type == nsGkAtoms::brFrame) {
    1:     parent = content->GetParent();
    1:     PRInt32 beginOffset = parent->IndexOf(content);
    1:     return FrameContentRange(parent, beginOffset, beginOffset);
    1:   }
    1:   // Loop to deal with anonymous content, which has no index; this loop
    1:   // probably won't run more than twice under normal conditions
    1:   do {
    1:     parent  = content->GetParent();
    1:     if (parent) {
    1:       PRInt32 beginOffset = parent->IndexOf(content);
    1:       if (beginOffset >= 0)
    1:         return FrameContentRange(parent, beginOffset, beginOffset + 1);
    1:       content = parent;
    1:     }
    1:   } while (parent);
    1: 
    1:   // The root content node must act differently
    1:   return FrameContentRange(content, 0, content->GetChildCount());
    1: }
    1: 
    1: // The FrameTarget represents the closest frame to a point that can be selected
    1: // The frame is the frame represented, frameEdge says whether one end of the
    1: // frame is the result (in which case different handling is needed), and
    1: // afterFrame says which end is repersented if frameEdge is true
    1: struct FrameTarget {
    1:   FrameTarget(nsIFrame* aFrame, PRBool aFrameEdge, PRBool aAfterFrame) :
    1:     frame(aFrame), frameEdge(aFrameEdge), afterFrame(aAfterFrame) { }
    1:   static FrameTarget Null() {
    1:     return FrameTarget(nsnull, PR_FALSE, PR_FALSE);
    1:   }
    1:   PRBool IsNull() {
    1:     return !frame;
    1:   }
    1:   nsIFrame* frame;
    1:   PRPackedBool frameEdge;
    1:   PRPackedBool afterFrame;
    1: };
    1: 
    1: // See function implementation for information
    1: static FrameTarget GetSelectionClosestFrame(nsIFrame* aFrame, nsPoint aPoint);
    1: 
    1: static PRBool SelfIsSelectable(nsIFrame* aFrame)
    1: {
    1:   return !(aFrame->IsGeneratedContentFrame() ||
    1:            aFrame->GetStyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_NONE);
    1: }
    1: 
    1: static PRBool SelectionDescendToKids(nsIFrame* aFrame) {
    1:   PRUint8 style = aFrame->GetStyleUIReset()->mUserSelect;
    1:   nsIFrame* parent = aFrame->GetParent();
    1:   // If we are only near (not directly over) then don't traverse
    1:   // frames with independent selection (e.g. text and list controls)
    1:   // unless we're already inside such a frame (see bug 268497).  Note that this
    1:   // prevents any of the users of this method from entering form controls.
    1:   // XXX We might want some way to allow using the up-arrow to go into a form
    1:   // control, but the focus didn't work right anyway; it'd probably be enough
    1:   // if the left and right arrows could enter textboxes (which I don't believe
    1:   // they can at the moment)
    1:   return !aFrame->IsGeneratedContentFrame() &&
    1:          style != NS_STYLE_USER_SELECT_ALL  &&
    1:          style != NS_STYLE_USER_SELECT_NONE &&
    1:          ((parent->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION) ||
    1:           !(aFrame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION));
    1: }
    1: 
    1: static FrameTarget GetSelectionClosestFrameForChild(nsIFrame* aChild,
    1:                                                     nsPoint aPoint)
    1: {
    1:   nsIFrame* parent = aChild->GetParent();
    1:   if (SelectionDescendToKids(aChild)) {
    1:     nsPoint pt = aPoint - aChild->GetOffsetTo(parent);
    1:     return GetSelectionClosestFrame(aChild, pt);
    1:   }
    1:   return FrameTarget(aChild, PR_FALSE, PR_FALSE);
    1: }
    1: 
    1: // When the cursor needs to be at the beginning of a block, it shouldn't be
    1: // before the first child.  A click on a block whose first child is a block
    1: // should put the cursor in the child.  The cursor shouldn't be between the
    1: // blocks, because that's not where it's expected.
    1: // Note that this method is guaranteed to succeed.
    1: static FrameTarget DrillDownToSelectionFrame(nsIFrame* aFrame,
    1:                                              PRBool aEndFrame) {
    1:   if (SelectionDescendToKids(aFrame)) {
    1:     nsIFrame* result = nsnull;
    1:     nsIFrame *frame = aFrame->GetFirstChild(nsnull);
    1:     if (!aEndFrame) {
    1:       while (frame && (!SelfIsSelectable(frame) ||
    1:                         frame->IsEmpty()))
    1:         frame = frame->GetNextSibling();
    1:       if (frame)
    1:         result = frame;
    1:     } else {
    1:       // Because the frame tree is singly linked, to find the last frame,
    1:       // we have to iterate through all the frames
    1:       // XXX I have a feeling this could be slow for long blocks, although
    1:       //     I can't find any slowdowns
    1:       while (frame) {
    1:         if (!frame->IsEmpty() && SelfIsSelectable(frame))
    1:           result = frame;
    1:         frame = frame->GetNextSibling();
    1:       }
    1:     }
    1:     if (result)
    1:       return DrillDownToSelectionFrame(result, aEndFrame);
    1:   }
    1:   // If the current frame has no targetable children, target the current frame
    1:   return FrameTarget(aFrame, PR_TRUE, aEndFrame);
    1: }
    1: 
    1: // This method finds the closest valid FrameTarget on a given line; if there is
    1: // no valid FrameTarget on the line, it returns a null FrameTarget
    1: static FrameTarget GetSelectionClosestFrameForLine(
    1:                       nsBlockFrame* aParent,
    1:                       nsBlockFrame::line_iterator aLine,
    1:                       nsPoint aPoint)
    1: {
    1:   nsIFrame *frame = aLine->mFirstChild;
    1:   // Account for end of lines (any iterator from the block is valid)
    1:   if (aLine == aParent->end_lines())
    1:     return DrillDownToSelectionFrame(aParent, PR_TRUE);
    1:   nsIFrame *closestFromLeft = nsnull, *closestFromRight = nsnull;
    1:   nsRect rect = aLine->mBounds;
    1:   nscoord closestLeft = rect.x, closestRight = rect.XMost();
    1:   for (PRInt32 n = aLine->GetChildCount(); n;
    1:        --n, frame = frame->GetNextSibling()) {
    1:     if (!SelfIsSelectable(frame) || frame->IsEmpty())
    1:       continue;
    1:     nsRect frameRect = frame->GetRect();
    1:     if (aPoint.x >= frameRect.x) {
    1:       if (aPoint.x < frameRect.XMost()) {
    1:         return GetSelectionClosestFrameForChild(frame, aPoint);
    1:       }
    1:       if (frameRect.XMost() >= closestLeft) {
    1:         closestFromLeft = frame;
    1:         closestLeft = frameRect.XMost();
    1:       }
    1:     } else {
    1:       if (frameRect.x <= closestRight) {
    1:         closestFromRight = frame;
    1:         closestRight = frameRect.x;
    1:       }
    1:     }
    1:   }
    1:   if (!closestFromLeft && !closestFromRight) {
    1:     // We should only get here if there are no selectable frames on a line
    1:     // XXX Do we need more elaborate handling here?
    1:     return FrameTarget::Null();
    1:   }
    1:   if (closestFromLeft &&
    1:       (!closestFromRight ||
    1:        (abs(aPoint.x - closestLeft) <= abs(aPoint.x - closestRight)))) {
    1:     return GetSelectionClosestFrameForChild(closestFromLeft, aPoint);
    1:   }
    1:   return GetSelectionClosestFrameForChild(closestFromRight, aPoint);
    1: }
    1: 
    1: // This method is for the special handling we do for block frames; they're
    1: // special because they represent paragraphs and because they are organized
    1: // into lines, which have bounds that are not stored elsewhere in the
    1: // frame tree.  Returns a null FrameTarget for frames which are not
    1: // blocks or blocks with no lines.
    1: static FrameTarget GetSelectionClosestFrameForBlock(nsIFrame* aFrame,
    1:                                                     nsPoint aPoint)
    1: {
15909:   nsBlockFrame* bf = nsLayoutUtils::GetAsBlock(aFrame); // used only for QI
15909:   if (!bf)
    1:     return FrameTarget::Null();
    1: 
    1:   // This code searches for the correct line
    1:   nsBlockFrame::line_iterator firstLine = bf->begin_lines();
    1:   nsBlockFrame::line_iterator end = bf->end_lines();
    1:   if (firstLine == end)
    1:     return FrameTarget::Null();
    1:   nsBlockFrame::line_iterator curLine = firstLine;
    1:   nsBlockFrame::line_iterator closestLine = end;
    1:   while (curLine != end) {
    1:     // Check to see if our point lies with the line's Y bounds
    1:     nscoord y = aPoint.y - curLine->mBounds.y;
    1:     nscoord height = curLine->mBounds.height;
    1:     if (y >= 0 && y < height) {
    1:       closestLine = curLine;
    1:       break; // We found the line; stop looking
    1:     }
    1:     if (y < 0)
    1:       break;
    1:     ++curLine;
    1:   }
    1: 
    1:   if (closestLine == end) {
    1:     nsBlockFrame::line_iterator prevLine = curLine.prev();
    1:     nsBlockFrame::line_iterator nextLine = curLine;
    1:     // Avoid empty lines
    1:     while (nextLine != end && nextLine->IsEmpty())
    1:       ++nextLine;
    1:     while (prevLine != end && prevLine->IsEmpty())
    1:       --prevLine;
    1: 
    1:     // This hidden pref dictates whether a point above or below all lines comes
    1:     // up with a line or the beginning or end of the frame; 0 on Windows,
    1:     // 1 on other platforms by default at the writing of this code
    1:     PRInt32 dragOutOfFrame =
    1:             nsContentUtils::GetIntPref("browser.drag_out_of_frame_style");
    1: 
    1:     if (prevLine == end) {
    1:       if (dragOutOfFrame == 1 || nextLine == end)
    1:         return DrillDownToSelectionFrame(aFrame, PR_FALSE);
    1:       closestLine = nextLine;
    1:     } else if (nextLine == end) {
    1:       if (dragOutOfFrame == 1)
    1:         return DrillDownToSelectionFrame(aFrame, PR_TRUE);
    1:       closestLine = prevLine;
    1:     } else { // Figure out which line is closer
    1:       if (aPoint.y - prevLine->mBounds.YMost() < nextLine->mBounds.y - aPoint.y)
    1:         closestLine = prevLine;
    1:       else
    1:         closestLine = nextLine;
    1:     }
    1:   }
    1: 
    1:   do {
    1:     FrameTarget target = GetSelectionClosestFrameForLine(bf, closestLine,
    1:                                                          aPoint);
    1:     if (!target.IsNull())
    1:       return target;
    1:     ++closestLine;
    1:   } while (closestLine != end);
    1:   // Fall back to just targeting the last targetable place
    1:   return DrillDownToSelectionFrame(aFrame, PR_TRUE);
    1: }
    1: 
    1: // GetSelectionClosestFrame is the helper function that calculates the closest
    1: // frame to the given point.
    1: // It doesn't completely account for offset styles, so needs to be used in
    1: // restricted environments.
    1: // Cannot handle overlapping frames correctly, so it should receive the output
    1: // of GetFrameForPoint
    1: // Guaranteed to return a valid FrameTarget
    1: static FrameTarget GetSelectionClosestFrame(nsIFrame* aFrame, nsPoint aPoint)
    1: {
    1:   {
    1:     // Handle blocks; if the frame isn't a block, the method fails
    1:     FrameTarget target = GetSelectionClosestFrameForBlock(aFrame, aPoint);
    1:     if (!target.IsNull())
    1:       return target;
    1:   }
    1: 
    1:   nsIFrame *kid = aFrame->GetFirstChild(nsnull);
    1: 
    1:   if (kid) {
    1:     // Go through all the child frames to find the closest one
    1: 
    1:     // Large number to force the comparison to succeed
    1:     const nscoord HUGE_DISTANCE = nscoord_MAX;
    1:     nscoord closestXDistance = HUGE_DISTANCE;
    1:     nscoord closestYDistance = HUGE_DISTANCE;
    1:     nsIFrame *closestFrame = nsnull;
    1: 
    1:     for (; kid; kid = kid->GetNextSibling()) {
    1:       if (!SelfIsSelectable(kid) || kid->IsEmpty())
    1:         continue;
    1: 
    1:       nsRect rect = kid->GetRect();
    1: 
    1:       nscoord fromLeft = aPoint.x - rect.x;
    1:       nscoord fromRight = aPoint.x - rect.XMost();
    1: 
    1:       nscoord xDistance;
    1:       if (fromLeft >= 0 && fromRight <= 0) {
    1:         xDistance = 0;
    1:       } else {
32531:         xDistance = NS_MIN(abs(fromLeft), abs(fromRight));
    1:       }
    1: 
    1:       if (xDistance <= closestXDistance)
    1:       {
    1:         if (xDistance < closestXDistance)
    1:           closestYDistance = HUGE_DISTANCE;
    1: 
    1:         nscoord fromTop = aPoint.y - rect.y;
    1:         nscoord fromBottom = aPoint.y - rect.YMost();
    1: 
    1:         nscoord yDistance;
    1:         if (fromTop >= 0 && fromBottom <= 0)
    1:           yDistance = 0;
    1:         else
32531:           yDistance = NS_MIN(abs(fromTop), abs(fromBottom));
    1: 
    1:         if (yDistance < closestYDistance)
    1:         {
    1:           closestXDistance = xDistance;
    1:           closestYDistance = yDistance;
    1:           closestFrame = kid;
    1:         }
    1:       }
    1:     }
    1:     if (closestFrame)
    1:       return GetSelectionClosestFrameForChild(closestFrame, aPoint);
    1:   }
    1:   return FrameTarget(aFrame, PR_FALSE, PR_FALSE);
    1: }
    1: 
    1: nsIFrame::ContentOffsets OffsetsForSingleFrame(nsIFrame* aFrame, nsPoint aPoint)
    1: {
    1:   nsIFrame::ContentOffsets offsets;
    1:   FrameContentRange range = GetRangeForFrame(aFrame);
    1:   offsets.content = range.content;
    1:   // If there are continuations (meaning it's not one rectangle), this is the
    1:   // best this function can do
    1:   if (aFrame->GetNextContinuation() || aFrame->GetPrevContinuation()) {
    1:     offsets.offset = range.start;
    1:     offsets.secondaryOffset = range.end;
    1:     offsets.associateWithNext = PR_TRUE;
    1:     return offsets;
    1:   }
    1: 
    1:   // Figure out whether the offsets should be over, after, or before the frame
    1:   nsRect rect(nsPoint(0, 0), aFrame->GetSize());
    1: 
    1:   PRBool isBlock = (aFrame->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_INLINE);
    1:   PRBool isRtl = (aFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL);
    1:   if ((isBlock && rect.y < aPoint.y) ||
    1:       (!isBlock && ((isRtl  && rect.x + rect.width / 2 > aPoint.x) || 
    1:                     (!isRtl && rect.x + rect.width / 2 < aPoint.x)))) {
    1:     offsets.offset = range.end;
    1:     if (rect.Contains(aPoint))
    1:       offsets.secondaryOffset = range.start;
    1:     else
    1:       offsets.secondaryOffset = range.end;
    1:   } else {
    1:     offsets.offset = range.start;
    1:     if (rect.Contains(aPoint))
    1:       offsets.secondaryOffset = range.end;
    1:     else
    1:       offsets.secondaryOffset = range.start;
    1:   }
    1:   offsets.associateWithNext = (offsets.offset == range.start);
    1:   return offsets;
    1: }
    1: 
    1: static nsIFrame* AdjustFrameForSelectionStyles(nsIFrame* aFrame) {
    1:   nsIFrame* adjustedFrame = aFrame;
    1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent())
    1:   {
    1:     // These are the conditions that make all children not able to handle
    1:     // a cursor.
    1:     if (frame->GetStyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_NONE || 
    1:         frame->GetStyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_ALL || 
    1:         frame->IsGeneratedContentFrame()) {
    1:       adjustedFrame = frame;
    1:     }
    1:   }
    1:   return adjustedFrame;
    1: }
    1:   
    1: 
    1: nsIFrame::ContentOffsets nsIFrame::GetContentOffsetsFromPoint(nsPoint aPoint,
    1:                                                               PRBool aIgnoreSelectionStyle)
    1: {
    1:   nsIFrame *adjustedFrame;
    1:   if (aIgnoreSelectionStyle) {
    1:     adjustedFrame = this;
    1:   }
    1:   else {
    1:     // This section of code deals with special selection styles.  Note that
    1:     // -moz-none and -moz-all exist, even though they don't need to be explicitly
    1:     // handled.
    1:     // The offset is forced not to end up in generated content; content offsets
    1:     // cannot represent content outside of the document's content tree.
    1: 
    1:     adjustedFrame = AdjustFrameForSelectionStyles(this);
    1: 
    1:     // -moz-user-select: all needs special handling, because clicking on it
    1:     // should lead to the whole frame being selected
    1:     if (adjustedFrame && adjustedFrame->GetStyleUIReset()->mUserSelect ==
    1:         NS_STYLE_USER_SELECT_ALL) {
    1:       return OffsetsForSingleFrame(adjustedFrame, aPoint +
    1:                                    this->GetOffsetTo(adjustedFrame));
    1:     }
    1: 
    1:     // For other cases, try to find a closest frame starting from the parent of
    1:     // the unselectable frame
    1:     if (adjustedFrame != this)
    1:       adjustedFrame = adjustedFrame->GetParent();
    1:   }
    1: 
    1:   nsPoint adjustedPoint = aPoint + this->GetOffsetTo(adjustedFrame);
    1: 
    1:   FrameTarget closest = GetSelectionClosestFrame(adjustedFrame, adjustedPoint);
    1: 
    1:   // If the correct offset is at one end of a frame, use offset-based
    1:   // calculation method
    1:   if (closest.frameEdge) {
    1:     ContentOffsets offsets;
    1:     FrameContentRange range = GetRangeForFrame(closest.frame);
    1:     offsets.content = range.content;
    1:     if (closest.afterFrame)
    1:       offsets.offset = range.end;
    1:     else
    1:       offsets.offset = range.start;
    1:     offsets.secondaryOffset = offsets.offset;
    1:     offsets.associateWithNext = (offsets.offset == range.start);
    1:     return offsets;
    1:   }
    1:   nsPoint pt = aPoint - closest.frame->GetOffsetTo(this);
 3233:   return static_cast<nsFrame*>(closest.frame)->CalcContentOffsetsFromFramePoint(pt);
    1: 
    1:   // XXX should I add some kind of offset standardization?
    1:   // consider <b>xxxxx</b><i>zzzzz</i>; should any click between the last
    1:   // x and first z put the cursor in the same logical position in addition
    1:   // to the same visual position?
    1: }
    1: 
    1: nsIFrame::ContentOffsets nsFrame::CalcContentOffsetsFromFramePoint(nsPoint aPoint)
    1: {
    1:   return OffsetsForSingleFrame(this, aPoint);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetCursor(const nsPoint& aPoint,
    1:                    nsIFrame::Cursor& aCursor)
    1: {
    1:   FillCursorInformationFromStyle(GetStyleUserInterface(), aCursor);
    1:   if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
    1:     aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
    1:   }
    1: 
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Resize and incremental reflow
    1: 
    1: /* virtual */ void
    1: nsFrame::MarkIntrinsicWidthsDirty()
    1: {
    1:   // This version is meant only for what used to be box-to-block adaptors.
    1:   // It should not be called by other derived classes.
    1:   if (IsBoxWrapped()) {
    1:     nsBoxLayoutMetrics *metrics = BoxMetrics();
    1: 
    1:     SizeNeedsRecalc(metrics->mPrefSize);
    1:     SizeNeedsRecalc(metrics->mMinSize);
    1:     SizeNeedsRecalc(metrics->mMaxSize);
    1:     SizeNeedsRecalc(metrics->mBlockPrefSize);
    1:     SizeNeedsRecalc(metrics->mBlockMinSize);
    1:     CoordNeedsRecalc(metrics->mFlex);
    1:     CoordNeedsRecalc(metrics->mAscent);
    1:   }
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1:   DISPLAY_MIN_WIDTH(this, result);
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1:   DISPLAY_PREF_WIDTH(this, result);
    1:   return result;
    1: }
    1: 
    1: /* virtual */ void
    1: nsFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                            nsIFrame::InlineMinWidthData *aData)
    1: {
    1:   NS_ASSERTION(GetParent(), "Must have a parent if we get here!");
    1:   PRBool canBreak = !CanContinueTextRun() &&
    1:     GetParent()->GetStyleText()->WhiteSpaceCanWrap();
    1:   
    1:   if (canBreak)
 2668:     aData->OptionallyBreak(aRenderingContext);
    1:   aData->trailingWhitespace = 0;
    1:   aData->skipWhitespace = PR_FALSE;
    1:   aData->trailingTextFrame = nsnull;
    1:   aData->currentLine += nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
    1:                             this, nsLayoutUtils::MIN_WIDTH);
 2668:   aData->atStartOfLine = PR_FALSE;
    1:   if (canBreak)
 2668:     aData->OptionallyBreak(aRenderingContext);
    1: }
    1: 
    1: /* virtual */ void
    1: nsFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                             nsIFrame::InlinePrefWidthData *aData)
    1: {
    1:   aData->trailingWhitespace = 0;
    1:   aData->skipWhitespace = PR_FALSE;
 6254:   nscoord myPref = nsLayoutUtils::IntrinsicForContainer(aRenderingContext, 
    1:                        this, nsLayoutUtils::PREF_WIDTH);
 6254:   aData->currentLine = NSCoordSaturatingAdd(aData->currentLine, myPref);
    1: }
    1: 
    1: void
 2668: nsIFrame::InlineMinWidthData::ForceBreak(nsIRenderingContext *aRenderingContext)
    1: {
    1:   currentLine -= trailingWhitespace;
32531:   prevLines = NS_MAX(prevLines, currentLine);
    1:   currentLine = trailingWhitespace = 0;
    1: 
24551:   for (PRUint32 i = 0, i_end = floats.Length(); i != i_end; ++i) {
24551:     nsIFrame *floatFrame = floats[i];
    1:     nscoord float_min =
    1:       nsLayoutUtils::IntrinsicForContainer(aRenderingContext, floatFrame,
    1:                                            nsLayoutUtils::MIN_WIDTH);
    1:     if (float_min > prevLines)
    1:       prevLines = float_min;
    1:   }
    1:   floats.Clear();
    1:   trailingTextFrame = nsnull;
 8930:   skipWhitespace = PR_TRUE;
    1: }
    1: 
    1: void
 2668: nsIFrame::InlineMinWidthData::OptionallyBreak(nsIRenderingContext *aRenderingContext)
 2668: {
 2668:   trailingTextFrame = nsnull;
 2668: 
 2668:   // If we can fit more content into a smaller width by staying on this
 2668:   // line (because we're still at a negative offset due to negative
 2668:   // text-indent or negative margin), don't break.  Otherwise, do the
 2668:   // same as ForceBreak.  it doesn't really matter when we accumulate
 2668:   // floats.
 2668:   if (currentLine < 0 || atStartOfLine)
 2668:     return;
 2668:   ForceBreak(aRenderingContext);
 2668: }
 2668: 
 2668: void
 2668: nsIFrame::InlinePrefWidthData::ForceBreak(nsIRenderingContext *aRenderingContext)
    1: {
24551:   if (floats.Length() != 0) {
    1:             // preferred widths accumulated for floats that have already
    1:             // been cleared past
    1:     nscoord floats_done = 0,
    1:             // preferred widths accumulated for floats that have not yet
    1:             // been cleared past
    1:             floats_cur_left = 0,
    1:             floats_cur_right = 0;
    1: 
24551:     for (PRUint32 i = 0, i_end = floats.Length(); i != i_end; ++i) {
24551:       nsIFrame *floatFrame = floats[i];
    1:       const nsStyleDisplay *floatDisp = floatFrame->GetStyleDisplay();
    1:       if (floatDisp->mBreakType == NS_STYLE_CLEAR_LEFT ||
    1:           floatDisp->mBreakType == NS_STYLE_CLEAR_RIGHT ||
    1:           floatDisp->mBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT) {
12743:         nscoord floats_cur = NSCoordSaturatingAdd(floats_cur_left,
12743:                                                   floats_cur_right);
    1:         if (floats_cur > floats_done)
    1:           floats_done = floats_cur;
    1:         if (floatDisp->mBreakType != NS_STYLE_CLEAR_RIGHT)
    1:           floats_cur_left = 0;
    1:         if (floatDisp->mBreakType != NS_STYLE_CLEAR_LEFT)
    1:           floats_cur_right = 0;
    1:       }
    1: 
    1:       nscoord &floats_cur = floatDisp->mFloats == NS_STYLE_FLOAT_LEFT
    1:                               ? floats_cur_left : floats_cur_right;
13553:       nscoord floatWidth =
    1:           nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
12743:                                                floatFrame,
13553:                                                nsLayoutUtils::PREF_WIDTH);
13553:       // Negative-width floats don't change the available space so they
13553:       // shouldn't change our intrinsic line width either.
13553:       floats_cur =
32531:         NSCoordSaturatingAdd(floats_cur, NS_MAX(0, floatWidth));
12743:     }
12743: 
12743:     nscoord floats_cur =
12743:       NSCoordSaturatingAdd(floats_cur_left, floats_cur_right);
    1:     if (floats_cur > floats_done)
    1:       floats_done = floats_cur;
    1: 
 7750:     currentLine = NSCoordSaturatingAdd(currentLine, floats_done);
    1: 
    1:     floats.Clear();
    1:   }
    1: 
12743:   currentLine =
12743:     NSCoordSaturatingSubtract(currentLine, trailingWhitespace, nscoord_MAX);
32531:   prevLines = NS_MAX(prevLines, currentLine);
    1:   currentLine = trailingWhitespace = 0;
 8930:   skipWhitespace = PR_TRUE;
    1: }
    1: 
    1: static void
    1: AddCoord(const nsStyleCoord& aStyle,
    1:          nsIRenderingContext* aRenderingContext,
    1:          nsIFrame* aFrame,
    1:          nscoord* aCoord, float* aPercent)
    1: {
    1:   switch (aStyle.GetUnit()) {
    1:     case eStyleUnit_Coord:
    1:       *aCoord += aStyle.GetCoordValue();
    1:       break;
    1:     case eStyleUnit_Percent:
    1:       *aPercent += aStyle.GetPercentValue();
    1:       break;
    1:     default:
    1:       break;
    1:   }
    1: }
    1: 
    1: /* virtual */ nsIFrame::IntrinsicWidthOffsetData
    1: nsFrame::IntrinsicWidthOffsets(nsIRenderingContext* aRenderingContext)
    1: {
    1:   IntrinsicWidthOffsetData result;
    1: 
    1:   const nsStyleMargin *styleMargin = GetStyleMargin();
12630:   AddCoord(styleMargin->mMargin.GetLeft(), aRenderingContext, this,
    1:            &result.hMargin, &result.hPctMargin);
12630:   AddCoord(styleMargin->mMargin.GetRight(), aRenderingContext, this,
    1:            &result.hMargin, &result.hPctMargin);
    1: 
    1:   const nsStylePadding *stylePadding = GetStylePadding();
12630:   AddCoord(stylePadding->mPadding.GetLeft(), aRenderingContext, this,
    1:            &result.hPadding, &result.hPctPadding);
12630:   AddCoord(stylePadding->mPadding.GetRight(), aRenderingContext, this,
    1:            &result.hPadding, &result.hPctPadding);
    1: 
    1:   const nsStyleBorder *styleBorder = GetStyleBorder();
15992:   result.hBorder += styleBorder->GetActualBorderWidth(NS_SIDE_LEFT);
15992:   result.hBorder += styleBorder->GetActualBorderWidth(NS_SIDE_RIGHT);
    1: 
    1:   const nsStyleDisplay *disp = GetStyleDisplay();
    1:   if (IsThemed(disp)) {
  238:     nsPresContext *presContext = PresContext();
    1: 
23738:     nsIntMargin border;
    1:     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
    1:                                              this, disp->mAppearance,
    1:                                              &border);
    1:     result.hBorder = presContext->DevPixelsToAppUnits(border.LeftRight());
    1: 
23738:     nsIntMargin padding;
    1:     if (presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
    1:                                                   this, disp->mAppearance,
    1:                                                   &padding)) {
    1:       result.hPadding = presContext->DevPixelsToAppUnits(padding.LeftRight());
    1:       result.hPctPadding = 0;
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
 8142: /* virtual */ nsIFrame::IntrinsicSize
 8142: nsFrame::GetIntrinsicSize()
 8142: {
 8142:   return IntrinsicSize(); // default is width/height set to eStyleUnit_None
 8142: }
 8142: 
 2301: /* virtual */ nsSize
 2301: nsFrame::GetIntrinsicRatio()
 2301: {
 2301:   return nsSize(0, 0);
 2301: }
 2301: 
    1: inline PRBool
    1: IsAutoHeight(const nsStyleCoord &aCoord, nscoord aCBHeight)
    1: {
    1:   nsStyleUnit unit = aCoord.GetUnit();
    1:   return unit == eStyleUnit_Auto ||  // only for 'height'
 1363:          unit == eStyleUnit_None ||  // only for 'max-height'
    1:          (unit == eStyleUnit_Percent && 
    1:           aCBHeight == NS_AUTOHEIGHT);
    1: }
    1: 
    1: /* virtual */ nsSize
    1: nsFrame::ComputeSize(nsIRenderingContext *aRenderingContext,
    1:                      nsSize aCBSize, nscoord aAvailableWidth,
    1:                      nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                      PRBool aShrinkWrap)
    1: {
    1:   nsSize result = ComputeAutoSize(aRenderingContext, aCBSize, aAvailableWidth,
    1:                                   aMargin, aBorder, aPadding, aShrinkWrap);
    1:   nsSize boxSizingAdjust(0,0);
    1:   const nsStylePosition *stylePos = GetStylePosition();
    1: 
    1:   switch (stylePos->mBoxSizing) {
    1:     case NS_STYLE_BOX_SIZING_BORDER:
    1:       boxSizingAdjust += aBorder;
    1:       // fall through
    1:     case NS_STYLE_BOX_SIZING_PADDING:
    1:       boxSizingAdjust += aPadding;
    1:   }
 1068:   nscoord boxSizingToMarginEdgeWidth =
 1068:     aMargin.width + aBorder.width + aPadding.width - boxSizingAdjust.width;
    1: 
    1:   // Compute width
    1: 
    1:   if (stylePos->mWidth.GetUnit() != eStyleUnit_Auto) {
    1:     result.width =
 1068:       nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
 1068:         aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
 1068:         stylePos->mWidth);
    1:   }
    1: 
 1363:   if (stylePos->mMaxWidth.GetUnit() != eStyleUnit_None) {
    1:     nscoord maxWidth =
 1068:       nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
 1068:         aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
 1068:         stylePos->mMaxWidth);
    1:     if (maxWidth < result.width)
    1:       result.width = maxWidth;
    1:   }
    1: 
    1:   nscoord minWidth =
 1068:     nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
 1068:       aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
 1068:       stylePos->mMinWidth);
    1:   if (minWidth > result.width)
    1:     result.width = minWidth;
    1: 
    1:   // Compute height
    1: 
    1:   if (!IsAutoHeight(stylePos->mHeight, aCBSize.height)) {
    1:     result.height =
16031:       nsLayoutUtils::ComputeHeightDependentValue(aCBSize.height,
16031:                                                  stylePos->mHeight) -
    1:       boxSizingAdjust.height;
    1:   }
    1: 
    1:   if (result.height != NS_UNCONSTRAINEDSIZE) {
    1:     if (!IsAutoHeight(stylePos->mMaxHeight, aCBSize.height)) {
    1:       nscoord maxHeight =
16031:         nsLayoutUtils::ComputeHeightDependentValue(aCBSize.height,
16031:                                                    stylePos->mMaxHeight) -
    1:         boxSizingAdjust.height;
    1:       if (maxHeight < result.height)
    1:         result.height = maxHeight;
    1:     }
    1: 
    1:     if (!IsAutoHeight(stylePos->mMinHeight, aCBSize.height)) {
    1:       nscoord minHeight =
16031:         nsLayoutUtils::ComputeHeightDependentValue(aCBSize.height,
16031:                                                    stylePos->mMinHeight) -
    1:         boxSizingAdjust.height;
    1:       if (minHeight > result.height)
    1:         result.height = minHeight;
    1:     }
    1:   }
    1: 
    1:   const nsStyleDisplay *disp = GetStyleDisplay();
    1:   if (IsThemed(disp)) {
23738:     nsIntSize widget(0, 0);
    1:     PRBool canOverride = PR_TRUE;
  238:     nsPresContext *presContext = PresContext();
    1:     presContext->GetTheme()->
    1:       GetMinimumWidgetSize(aRenderingContext, this, disp->mAppearance,
23738:                            &widget, &canOverride);
23738: 
23738:     nsSize size;
23738:     size.width = presContext->DevPixelsToAppUnits(widget.width);
23738:     size.height = presContext->DevPixelsToAppUnits(widget.height);
    1: 
    1:     // GMWS() returns border-box; we need content-box
    1:     size.width -= aBorder.width + aPadding.width;
    1:     size.height -= aBorder.height + aPadding.height;
    1: 
    1:     if (size.height > result.height || !canOverride)
    1:       result.height = size.height;
    1:     if (size.width > result.width || !canOverride)
    1:       result.width = size.width;
    1:   }
    1: 
    1:   if (result.width < 0)
    1:     result.width = 0;
    1: 
    1:   if (result.height < 0)
    1:     result.height = 0;
    1: 
    1:   return result;
    1: }
    1: 
 6862: nsRect
 6862: nsIFrame::ComputeTightBounds(gfxContext* aContext) const
 6862: {
 6862:   return GetOverflowRect();
 6862: }
 6862: 
 6862: nsRect
 6862: nsFrame::ComputeSimpleTightBounds(gfxContext* aContext) const
 6862: {
 6862:   if (GetStyleOutline()->GetOutlineStyle() != NS_STYLE_BORDER_STYLE_NONE ||
 6862:       HasBorder() || !GetStyleBackground()->IsTransparent() ||
 6862:       GetStyleDisplay()->mAppearance) {
 6862:     // Not necessarily tight, due to clipping, negative
 6862:     // outline-offset, and lots of other issues, but that's OK
 6862:     return GetOverflowRect();
 6862:   }
 6862: 
 6862:   nsRect r(0, 0, 0, 0);
 6862:   PRInt32 listIndex = 0;
 6862:   nsIAtom* childList = nsnull;
 6862:   do {
 6862:     nsIFrame* child = GetFirstChild(childList);
 6862:     while (child) {
 6862:        r.UnionRect(r, child->ComputeTightBounds(aContext) + child->GetPosition());
 6862:        child = child->GetNextSibling();
 6862:     }
 6862:     childList = GetAdditionalChildListName(listIndex++);
 6862:   } while (childList);
 6862:   return r;
 6862: }
 6862: 
    1: /* virtual */ nsSize
    1: nsFrame::ComputeAutoSize(nsIRenderingContext *aRenderingContext,
    1:                          nsSize aCBSize, nscoord aAvailableWidth,
    1:                          nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                          PRBool aShrinkWrap)
    1: {
    1:   // Use basic shrink-wrapping as a default implementation.
    1:   nsSize result(0xdeadbeef, NS_UNCONSTRAINEDSIZE);
    1: 
    1:   // don't bother setting it if the result won't be used
    1:   if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
    1:     nscoord availBased = aAvailableWidth - aMargin.width - aBorder.width -
    1:                          aPadding.width;
    1:     result.width = ShrinkWidthToFit(aRenderingContext, availBased);
    1:   }
    1:   return result;
    1: }
    1: 
    1: nscoord
    1: nsFrame::ShrinkWidthToFit(nsIRenderingContext *aRenderingContext,
    1:                           nscoord aWidthInCB)
    1: {
    1:   nscoord result;
    1:   nscoord minWidth = GetMinWidth(aRenderingContext);
    1:   if (minWidth > aWidthInCB) {
    1:     result = minWidth;
    1:   } else {
    1:     nscoord prefWidth = GetPrefWidth(aRenderingContext);
    1:     if (prefWidth > aWidthInCB) {
    1:       result = aWidthInCB;
    1:     } else {
    1:       result = prefWidth;
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::WillReflow(nsPresContext* aPresContext)
    1: {
    1: #ifdef DEBUG_dbaron_off
    1:   // bug 81268
    1:   NS_ASSERTION(!(mState & NS_FRAME_IN_REFLOW),
    1:                "nsFrame::WillReflow: frame is already in reflow");
    1: #endif
    1: 
    1:   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
    1:                      ("WillReflow: oldState=%x", mState));
    1:   mState |= NS_FRAME_IN_REFLOW;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::DidReflow(nsPresContext*           aPresContext,
    1:                    const nsHTMLReflowState*  aReflowState,
    1:                    nsDidReflowStatus         aStatus)
    1: {
    1:   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
    1:                      ("nsFrame::DidReflow: aStatus=%d", aStatus));
    1:   if (NS_FRAME_REFLOW_FINISHED == aStatus) {
    1:     mState &= ~(NS_FRAME_IN_REFLOW | NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY |
    1:                 NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   }
    1: 
 7370:   // Notify the percent height observer if there is a percent height.
 7370:   // The observer may be able to initiate another reflow with a computed
 7370:   // height. This happens in the case where a table cell has no computed
 7370:   // height but can fabricate one when the cell height is known.
    1:   if (aReflowState && aReflowState->mPercentHeightObserver &&
    1:       (eStyleUnit_Percent == aReflowState->mStylePosition->mHeight.GetUnit())) {
    1: 
    1:     nsIFrame* prevInFlow = GetPrevInFlow();
    1:     if (!prevInFlow) { // 1st in flow
    1:       aReflowState->mPercentHeightObserver->NotifyPercentHeight(*aReflowState);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsFrame::CanContinueTextRun() const
    1: {
    1:   // By default, a frame will *not* allow a text run to be continued
    1:   // through it.
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::Reflow(nsPresContext*          aPresContext,
    1:                 nsHTMLReflowMetrics&     aDesiredSize,
    1:                 const nsHTMLReflowState& aReflowState,
    1:                 nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsFrame");
    1:   aDesiredSize.width = 0;
    1:   aDesiredSize.height = 0;
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
31131: nsFrame::CharacterDataChanged(CharacterDataChangeInfo* aInfo)
    1: {
    1:   NS_NOTREACHED("should only be called for text frames");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::AttributeChanged(PRInt32         aNameSpaceID,
    1:                           nsIAtom*        aAttribute,
    1:                           PRInt32         aModType)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // Flow member functions
    1: 
    1: nsSplittableType
    1: nsFrame::GetSplittableType() const
    1: {
    1:   return NS_FRAME_NOT_SPLITTABLE;
    1: }
    1: 
    1: nsIFrame* nsFrame::GetPrevContinuation() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::SetPrevContinuation(nsIFrame* aPrevContinuation)
    1: {
    1:   // Ignore harmless requests to set it to NULL
    1:   if (aPrevContinuation) {
    1:     NS_ERROR("not splittable");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsIFrame* nsFrame::GetNextContinuation() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::SetNextContinuation(nsIFrame*)
    1: {
    1:   NS_ERROR("not splittable");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: nsIFrame* nsFrame::GetPrevInFlowVirtual() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::SetPrevInFlow(nsIFrame* aPrevInFlow)
    1: {
    1:   // Ignore harmless requests to set it to NULL
    1:   if (aPrevInFlow) {
    1:     NS_ERROR("not splittable");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIFrame* nsFrame::GetNextInFlowVirtual() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::SetNextInFlow(nsIFrame*)
    1: {
    1:   NS_ERROR("not splittable");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
10780: nsIFrame* nsIFrame::GetTailContinuation()
10780: {
10780:   nsIFrame* frame = this;
10780:   while (frame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
10780:     frame = frame->GetPrevContinuation();
10780:     NS_ASSERTION(frame, "first continuation can't be overflow container");
10780:   }
10780:   for (nsIFrame* next = frame->GetNextContinuation();
10780:        next && !(next->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER);
10780:        next = frame->GetNextContinuation())  {
10780:     frame = next;
10780:   }
10780:   NS_POSTCONDITION(frame, "illegal state in continuation chain.");
10780:   return frame;
10780: }
10780: 
    1: nsIView*
    1: nsIFrame::GetParentViewForChildFrame(nsIFrame* aFrame) const
    1: {
    1:   return GetClosestView();
    1: }
    1: 
    1: // Associated view object
    1: nsIView*
    1: nsIFrame::GetView() const
    1: {
    1:   // Check the frame state bit and see if the frame has a view
    1:   if (!(GetStateBits() & NS_FRAME_HAS_VIEW))
    1:     return nsnull;
    1: 
    1:   // Check for a property on the frame
    1:   nsresult rv;
    1:   void *value = GetProperty(nsGkAtoms::viewProperty, &rv);
    1: 
    1:   NS_ENSURE_SUCCESS(rv, nsnull);
    1:   NS_ASSERTION(value, "frame state bit was set but frame has no view");
 3233:   return static_cast<nsIView*>(value);
    1: }
    1: 
    1: /* virtual */ nsIView*
    1: nsIFrame::GetViewExternal() const
    1: {
    1:   return GetView();
    1: }
    1: 
    1: nsresult
    1: nsIFrame::SetView(nsIView* aView)
    1: {
    1:   if (aView) {
    1:     aView->SetClientData(this);
    1: 
    1:     // Set a property on the frame
    1:     nsresult rv = SetProperty(nsGkAtoms::viewProperty, aView, nsnull);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Set the frame state bit that says the frame has a view
    1:     AddStateBits(NS_FRAME_HAS_VIEW);
    1: 
    1:     // Let all of the ancestors know they have a descendant with a view.
    1:     for (nsIFrame* f = GetParent();
    1:          f && !(f->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW);
    1:          f = f->GetParent())
    1:       f->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIFrame* nsIFrame::GetAncestorWithViewExternal() const
    1: {
    1:   return GetAncestorWithView();
    1: }
    1: 
    1: // Find the first geometric parent that has a view
    1: nsIFrame* nsIFrame::GetAncestorWithView() const
    1: {
    1:   for (nsIFrame* f = mParent; nsnull != f; f = f->GetParent()) {
    1:     if (f->HasView()) {
    1:       return f;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: // virtual
    1: nsPoint nsIFrame::GetOffsetToExternal(const nsIFrame* aOther) const
    1: {
    1:   return GetOffsetTo(aOther);
    1: }
    1: 
    1: nsPoint nsIFrame::GetOffsetTo(const nsIFrame* aOther) const
    1: {
    1:   NS_PRECONDITION(aOther,
    1:                   "Must have frame for destination coordinate system!");
    1:   nsPoint offset(0, 0);
    1:   const nsIFrame* f;
18884:   for (f = this; f != aOther && f;
18884:        f = nsLayoutUtils::GetCrossDocParentFrame(f, &offset)) {
    1:     offset += f->GetPosition();
    1:   }
    1: 
    1:   if (f != aOther) {
18884:     // Looks like aOther wasn't an ancestor of |this|.  So now we have
18884:     // the root-document-relative position of |this| in |offset|.  Convert back
18884:     // to the coordinates of aOther
18884:     nsPoint negativeOffset(0,0);
18884:     while (aOther) {
18884:       offset -= aOther->GetPosition();
18884:       aOther = nsLayoutUtils::GetCrossDocParentFrame(aOther, &negativeOffset);
18884:     }
18884:     offset -= negativeOffset;
    1:   }
    1: 
    1:   return offset;
    1: }
    1: 
    1: // virtual
    1: nsIntRect nsIFrame::GetScreenRectExternal() const
    1: {
    1:   return GetScreenRect();
    1: }
    1: 
    1: nsIntRect nsIFrame::GetScreenRect() const
    1: {
34969:   return GetScreenRectInAppUnits().ToNearestPixels(PresContext()->AppUnitsPerCSSPixel());
15364: }
15364: 
15364: // virtual
15364: nsRect nsIFrame::GetScreenRectInAppUnitsExternal() const
15364: {
15364:   return GetScreenRectInAppUnits();
15364: }
15364: 
15364: nsRect nsIFrame::GetScreenRectInAppUnits() const
15364: {
30531:   nsPresContext* presContext = PresContext();
30531:   nsIFrame* rootFrame =
30531:     presContext->PresShell()->FrameManager()->GetRootFrame();
30531:   nsPoint rootScreenPos(0, 0);
30531:   nsPoint rootFrameOffsetInParent(0, 0);
30531:   nsIFrame* rootFrameParent =
30531:     nsLayoutUtils::GetCrossDocParentFrame(rootFrame, &rootFrameOffsetInParent);
30531:   if (rootFrameParent) {
30531:     nsRect parentScreenRectAppUnits = rootFrameParent->GetScreenRectInAppUnits();
30531:     nsPresContext* parentPresContext = rootFrameParent->PresContext();
30531:     double parentScale = double(presContext->AppUnitsPerDevPixel())/
30531:         parentPresContext->AppUnitsPerDevPixel();
30531:     nsPoint rootPt = parentScreenRectAppUnits.TopLeft() + rootFrameOffsetInParent;
30531:     rootScreenPos.x = NS_round(parentScale*rootPt.x);
30531:     rootScreenPos.y = NS_round(parentScale*rootPt.y);
30531:   } else {
30531:     nsCOMPtr<nsIWidget> rootWidget;
30531:     presContext->PresShell()->GetViewManager()->GetRootWidget(getter_AddRefs(rootWidget));
30531:     if (rootWidget) {
30531:       nsIntPoint rootDevPx = rootWidget->WidgetToScreenOffset();
30531:       rootScreenPos.x = presContext->DevPixelsToAppUnits(rootDevPx.x);
30531:       rootScreenPos.y = presContext->DevPixelsToAppUnits(rootDevPx.y);
30531:     }
30531:   }
30531: 
30531:   return nsRect(rootScreenPos + GetOffsetTo(rootFrame), GetSize());
    1: }
    1: 
    1: // Returns the offset from this frame to the closest geometric parent that
    1: // has a view. Also returns the containing view or null in case of error
    1: NS_IMETHODIMP nsFrame::GetOffsetFromView(nsPoint&  aOffset,
    1:                                          nsIView** aView) const
    1: {
    1:   NS_PRECONDITION(nsnull != aView, "null OUT parameter pointer");
    1:   nsIFrame* frame = (nsIFrame*)this;
    1: 
    1:   *aView = nsnull;
    1:   aOffset.MoveTo(0, 0);
    1:   do {
    1:     aOffset += frame->GetPosition();
    1:     frame = frame->GetParent();
    1:   } while (frame && !frame->HasView());
    1:   if (frame)
    1:     *aView = frame->GetView();
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsIFrame::AreAncestorViewsVisible() const
    1: {
    1:   for (nsIView* view = GetClosestView(); view; view = view->GetParent()) {
    1:     if (view->GetVisibility() == nsViewVisibility_kHide) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsIWidget*
    1: nsIFrame::GetWindow() const
    1: {
    1:   return GetClosestView()->GetNearestWidget(nsnull);
    1: }
    1: 
    1: nsIAtom*
    1: nsFrame::GetType() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsIFrame::IsLeaf() const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
19380: nsIFrame::InvalidateWithFlags(const nsRect& aDamageRect, PRUint32 aFlags)
    1: {
    1:   if (aDamageRect.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // Don't allow invalidates to do anything when
    1:   // painting is suppressed.
  238:   nsIPresShell *shell = PresContext()->GetPresShell();
    1:   if (shell) {
    1:     PRBool suppressed = PR_FALSE;
    1:     shell->IsPaintingSuppressed(&suppressed);
    1:     if (suppressed)
    1:       return;
    1:   }
    1:   
19380:   InvalidateInternal(aDamageRect, 0, 0, nsnull, aFlags);
    1: }
    1: 
19214: /**
19214:  * Helper function that funnels an InvalidateInternal request up to the
19214:  * parent.  This function is used so that if MOZ_SVG is not defined, we still
19214:  * have unified control paths in the InvalidateInternal chain.
19214:  *
19214:  * @param aDamageRect The rect to invalidate.
19214:  * @param aX The x offset from the origin of this frame to the rectangle.
19214:  * @param aY The y offset from the origin of this frame to the rectangle.
19214:  * @param aImmediate Whether to redraw immediately.
19214:  * @return None, though this funnels the request up to the parent frame.
19214:  */
19214: void
19214: nsIFrame::InvalidateInternalAfterResize(const nsRect& aDamageRect, nscoord aX,
19380:                                         nscoord aY, PRUint32 aFlags)
19214: {
19214:   /* If we're a transformed frame, then we need to apply our transform to the
19214:    * damage rectangle so that the redraw correctly redraws the transformed
19214:    * region.  We're moved over aX and aY from our origin, but since this aX
19214:    * and aY is contained within our border, we need to scoot back by -aX and
19214:    * -aY to get back to the origin of the transform.
19214:    *
19214:    * There's one more problem, though, and that's that we don't know what
19214:    * coordinate space this rectangle is in.  Sometimes it's in the local
19214:    * coordinate space for the frame, and sometimes its in the transformed
19214:    * coordinate space.  If we get it wrong, we'll display incorrectly.  Until I
19214:    * find a better fix for this problem, we'll invalidate the union of the two
19214:    * rectangles (original rectangle and transformed rectangle).  At least one of
19214:    * these will be correct.
19214:    *
19214:    * See bug #452496 for more details.
19214:    */
19948:   if ((mState & NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS) &&
19214:       GetStyleDisplay()->HasTransform()) {
19214:     nsRect newDamageRect;
19214:     newDamageRect.UnionRect(nsDisplayTransform::TransformRect
19214:                             (aDamageRect, this, nsPoint(-aX, -aY)), aDamageRect);
19214:     GetParent()->
19214:       InvalidateInternal(newDamageRect, aX + mRect.x, aY + mRect.y, this,
19380:                          aFlags);
19214:   }
19214:   else 
19214:     GetParent()->
19380:       InvalidateInternal(aDamageRect, aX + mRect.x, aY + mRect.y, this, aFlags);
19214: }
19214: 
    1: void
    1: nsIFrame::InvalidateInternal(const nsRect& aDamageRect, nscoord aX, nscoord aY,
19380:                              nsIFrame* aForChild, PRUint32 aFlags)
    1: {
19125: #ifdef MOZ_SVG
19125:   if (nsSVGIntegrationUtils::UsingEffectsForFrame(this)) {
19125:     nsRect r = nsSVGIntegrationUtils::GetInvalidAreaForChangedSource(this,
19125:             aDamageRect + nsPoint(aX, aY));
19214:     /* Rectangle is now in our own local space, so aX and aY are effectively
19214:      * zero.  Thus we'll pretend that the entire time this was in our own
19214:      * local coordinate space and do any remaining processing.
19214:      */
19380:     InvalidateInternalAfterResize(r, 0, 0, aFlags);
19125:     return;
19125:   }
19125: #endif
19125:   
19380:   InvalidateInternalAfterResize(aDamageRect, aX, aY, aFlags);
19214: }
19214: 
19214: gfxMatrix
19214: nsIFrame::GetTransformMatrix(nsIFrame **aOutAncestor)
19214: {
19214:   NS_PRECONDITION(aOutAncestor, "Need a place to put the ancestor!");
19214: 
19214:   /* Whether or not we're transformed, the matrix will be relative to our
19214:    * cross-doc parent frame.
19214:    */
19214:   *aOutAncestor = nsLayoutUtils::GetCrossDocParentFrame(this);
19214: 
19214:   /* If we're transformed, we want to hand back the combination
19214:    * transform/translate matrix that will apply our current transform, then
19214:    * shift us to our parent.
19214:    */
19214:   if (IsTransformed()) {
19214:     /* Compute the delta to the parent, which we need because we are converting
19214:      * coordinates to our parent.
19214:      */
19214:     NS_ASSERTION(*aOutAncestor, "Cannot transform the viewport frame!");
19214:     nsPoint delta = GetOffsetTo(*aOutAncestor);
19214:     PRInt32 scaleFactor = PresContext()->AppUnitsPerDevPixel();
19214: 
19214:     gfxMatrix result =
19214:       nsDisplayTransform::GetResultingTransformMatrix(this, nsPoint(0, 0),
19214:                                                       scaleFactor);
19214:     /* Combine the raw transform with a translation to our parent. */
19214:     result *= gfxMatrix().Translate
19214:       (gfxPoint(NSAppUnitsToFloatPixels(delta.x, scaleFactor),
19214:                 NSAppUnitsToFloatPixels(delta.y, scaleFactor)));
19214:     return result;
19214:   }
19214:   
19214:   /* Otherwise, we're not transformed.  In that case, we'll walk up the frame
19214:    * tree until we either hit the root frame or something that may be
19214:    * transformed.  We'll then change coordinates into that frame, since we're
19214:    * guaranteed that nothing in-between can be transformed.  First, however,
19214:    * we have to check to see if we have a parent.  If not, we'll set the
19214:    * outparam to null (indicating that there's nothing left) and will hand back
19214:    * the identity matrix.
19214:    */
19214:   if (!*aOutAncestor)
19214:     return gfxMatrix();
19214:   
19214:   /* Keep iterating while the frame can't possibly be transformed. */
19948:   while (!(*aOutAncestor)->IsTransformed()) {
19214:     /* If no parent, stop iterating.  Otherwise, update the ancestor. */
19214:     nsIFrame* parent = nsLayoutUtils::GetCrossDocParentFrame(*aOutAncestor);
19214:     if (!parent)
19214:       break;
19214: 
19214:     *aOutAncestor = parent;
19214:   }
19214: 
19214:   NS_ASSERTION(*aOutAncestor, "Somehow ended up with a null ancestor...?");
19214: 
19214:   /* Translate from this frame to our ancestor, if it exists.  That's the
19214:    * entire transform, so we're done.
19214:    */
19214:   nsPoint delta = GetOffsetTo(*aOutAncestor);
19214:   PRInt32 scaleFactor = PresContext()->AppUnitsPerDevPixel();
19214:   return gfxMatrix().Translate
19214:     (gfxPoint(NSAppUnitsToFloatPixels(delta.x, scaleFactor),
19214:               NSAppUnitsToFloatPixels(delta.y, scaleFactor)));
    1: }
    1: 
    1: void
11384: nsIFrame::InvalidateRectDifference(const nsRect& aR1, const nsRect& aR2)
11384: {
11384:   nsRect sizeHStrip, sizeVStrip;
11384:   nsLayoutUtils::GetRectDifferenceStrips(aR1, aR2, &sizeHStrip, &sizeVStrip);
11384:   Invalidate(sizeVStrip);
11384:   Invalidate(sizeHStrip);
11384: }
11384: 
11384: void
11384: nsIFrame::InvalidateOverflowRect()
11384: {
11384:   Invalidate(GetOverflowRect());
11384: }
11384: 
11384: void
19380: nsIFrame::InvalidateRoot(const nsRect& aDamageRect, PRUint32 aFlags)
19380: {
19380:   PRUint32 flags =
19380:     (aFlags & INVALIDATE_IMMEDIATE) ? NS_VMREFRESH_IMMEDIATE : NS_VMREFRESH_NO_SYNC;
    1:   nsIView* view = GetView();
    1:   NS_ASSERTION(view, "This can only be called on frames with views");
19380:   view->GetViewManager()->UpdateView(view, aDamageRect, flags);
    1: }
    1: 
19125: static void
19125: DestroyRectFunc(void*    aFrame,
19125:                 nsIAtom* aPropertyName,
19125:                 void*    aPropertyValue,
19125:                 void*    aDtorData)
19125: {
19125:   delete static_cast<nsRect*>(aPropertyValue);
19125: }
19125: 
19125: static void
19125: SetRectProperty(nsIFrame* aFrame, nsIAtom* aProp, const nsRect& aRect)
19125: {
19125:   nsRect* r = new nsRect(aRect);
19125:   if (!r)
19125:     return;
19125:   aFrame->SetProperty(aProp, r, DestroyRectFunc);
19125: }
19125: 
20711: /**
20711:  * @param aAnyOutlineOrEffects set to true if this frame has any
20711:  * outline, SVG effects or box shadows that mean we need to invalidate
20711:  * the whole overflow area if the frame's size changes.
20711:  */
19125: static nsRect
19125: ComputeOutlineAndEffectsRect(nsIFrame* aFrame, PRBool* aAnyOutlineOrEffects,
19125:                              const nsRect& aOverflowRect,
19125:                              PRBool aStoreRectProperties) {
19125:   nsRect r = aOverflowRect;
19125:   *aAnyOutlineOrEffects = PR_FALSE;
19125: 
19125:   // box-shadow
26940:   nsCSSShadowArray* boxShadows = aFrame->GetEffectiveBoxShadows();
26940:   if (boxShadows) {
19125:     nsRect shadows;
19125:     for (PRUint32 i = 0; i < boxShadows->Length(); ++i) {
19125:       nsRect tmpRect = r;
19125:       nsCSSShadowItem* shadow = boxShadows->ShadowAt(i);
24818: 
24818:       // inset shadows are never painted outside the frame
24818:       if (shadow->mInset)
24818:         continue;
19207:       nscoord outsetRadius = shadow->mRadius + shadow->mSpread;
19207: 
19207:       tmpRect.MoveBy(nsPoint(shadow->mXOffset, shadow->mYOffset));
19125:       tmpRect.Inflate(outsetRadius, outsetRadius);
19125: 
19125:       shadows.UnionRect(shadows, tmpRect);
19125:     }
19125:     r.UnionRect(r, shadows);
20711:     *aAnyOutlineOrEffects = PR_TRUE;
19125:   }
19125: 
    1:   const nsStyleOutline* outline = aFrame->GetStyleOutline();
    1:   PRUint8 outlineStyle = outline->GetOutlineStyle();
    1:   if (outlineStyle != NS_STYLE_BORDER_STYLE_NONE) {
    1:     nscoord width;
    1: #ifdef DEBUG
    1:     PRBool result = 
    1: #endif
    1:       outline->GetOutlineWidth(width);
    1:     NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
    1:     if (width > 0) {
19125:       if (aStoreRectProperties) {
19125:         SetRectProperty(aFrame, nsGkAtoms::outlineInnerRectProperty, r);
19125:       }
19125: 
19205:       nscoord offset = outline->mOutlineOffset;
32531:       nscoord inflateBy = NS_MAX(width + offset, 0);
    1:       r.Inflate(inflateBy, inflateBy);
19125:       *aAnyOutlineOrEffects = PR_TRUE;
19125:     }
19125:   }
19125:   
19125:   // Note that we don't remove the outlineInnerRect if a frame loses outline
19125:   // style. That would require an extra property lookup for every frame,
19125:   // or a new frame state bit to track whether a property had been stored,
19125:   // or something like that. It's not worth doing that here. At most it's
19125:   // only one heap-allocated rect per frame and it will be cleaned up when
19125:   // the frame dies.
19125: 
19125: #ifdef MOZ_SVG
19125:   if (nsSVGIntegrationUtils::UsingEffectsForFrame(aFrame)) {
19125:     *aAnyOutlineOrEffects = PR_TRUE;
19125:     if (aStoreRectProperties) {
19125:       SetRectProperty(aFrame, nsGkAtoms::preEffectsBBoxProperty, r);
19125:     }
19125:     r = nsSVGIntegrationUtils::ComputeFrameEffectsRect(aFrame, r);
19125:   }
19125: #endif
19125: 
    1:   return r;
    1: }
    1: 
14460: nsPoint
14460: nsIFrame::GetRelativeOffset(const nsStyleDisplay* aDisplay) const
14460: {
14460:   if (!aDisplay || NS_STYLE_POSITION_RELATIVE == aDisplay->mPosition) {
14460:     nsPoint *offsets = static_cast<nsPoint*>
14460:                          (GetProperty(nsGkAtoms::computedOffsetProperty));
14460:     if (offsets) {
14460:       return *offsets;
14460:     }
14460:   }
14460:   return nsPoint(0,0);
14460: }
14460: 
    1: nsRect
    1: nsIFrame::GetOverflowRect() const
    1: {
    1:   // Note that in some cases the overflow area might not have been
    1:   // updated (yet) to reflect any outline set on the frame or the area
    1:   // of child frames. That's OK because any reflow that updates these
    1:   // areas will invalidate the appropriate area, so any (mis)uses of
    1:   // this method will be fixed up.
11909: 
26950:   if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
26950:     // there is an overflow rect, and it's not stored as deltas but as
26950:     // a separately-allocated rect
11909:     return *const_cast<nsIFrame*>(this)->GetOverflowAreaProperty(PR_FALSE);
26950:   }
26950: 
26950:   // Calculate the rect using deltas from the frame's border rect.
26950:   // Note that the mOverflow.mDeltas fields are unsigned, but we will often
26950:   // need to return negative values for the left and top, so take care
26950:   // to cast away the unsigned-ness.
26950:   return nsRect(-(PRInt32)mOverflow.mDeltas.mLeft,
26950:                 -(PRInt32)mOverflow.mDeltas.mTop,
26950:                 mRect.width + mOverflow.mDeltas.mRight +
26950:                               mOverflow.mDeltas.mLeft,
26950:                 mRect.height + mOverflow.mDeltas.mBottom +
26950:                                mOverflow.mDeltas.mTop);
    1: }
    1: 
19284: nsRect
19284: nsIFrame::GetOverflowRectRelativeToParent() const
19284: {
19284:   return GetOverflowRect() + mRect.TopLeft();
19284: }
19284:   
19284: nsRect
19284: nsIFrame::GetOverflowRectRelativeToSelf() const
19284: {
19948:   if (!(mState & NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS) ||
19284:       !GetStyleDisplay()->HasTransform())
19284:     return GetOverflowRect();
30876:   nsRect* preEffectsBBox = static_cast<nsRect*>
19284:     (GetProperty(nsGkAtoms::preEffectsBBoxProperty));
30876:   if (!preEffectsBBox)
30876:     return GetOverflowRect();
30876:   return *preEffectsBBox;
19284: }
19284: 
    1: void
17140: nsFrame::CheckInvalidateSizeChange(nsHTMLReflowMetrics& aNewDesiredSize)
17140: {
20711:   nsIFrame::CheckInvalidateSizeChange(mRect, GetOverflowRect(),
20711:       nsSize(aNewDesiredSize.width, aNewDesiredSize.height));
17140: }
17140: 
34422: static void
34422: InvalidateRectForFrameSizeChange(nsIFrame* aFrame, const nsRect& aRect)
34422: {
34422:   const nsStyleBackground* bg;
34422:   if (!nsCSSRendering::FindBackground(aFrame->PresContext(), aFrame, &bg)) {
34422:     nsIFrame* rootFrame =
34422:       aFrame->PresContext()->PresShell()->FrameManager()->GetRootFrame();
34422:     rootFrame->Invalidate(nsRect(nsPoint(0, 0), rootFrame->GetSize()));
34422:   }
34422: 
34422:   aFrame->Invalidate(aRect);
34422: }
34422: 
17140: void
17140: nsIFrame::CheckInvalidateSizeChange(const nsRect& aOldRect,
17140:                                     const nsRect& aOldOverflowRect,
20711:                                     const nsSize& aNewDesiredSize)
17140: {
33360:   if (aNewDesiredSize == aOldRect.Size())
    1:     return;
    1: 
    1:   // Below, we invalidate the old frame area (or, in the case of
    1:   // outline, combined area) if the outline, border or background
    1:   // settings indicate that something other than the difference
    1:   // between the old and new areas needs to be painted. We are
    1:   // assuming that the difference between the old and new areas will
    1:   // be invalidated by some other means. That also means invalidating
    1:   // the old frame area is the same as invalidating the new frame area
    1:   // (since in either case the UNION of old and new areas will be
    1:   // invalidated)
    1: 
34422:   // We use InvalidateRectForFrameSizeChange throughout this method, even
34422:   // though root-invalidation is technically only needed in the case where
34422:   // layer.RenderingMightDependOnFrameSize().  This allows us to simplify the
34422:   // code somewhat and return immediately after invalidation in the earlier
34422:   // cases.
34422: 
    1:   // Invalidate the entire old frame+outline if the frame has an outline
19125:   PRBool anyOutlineOrEffects;
19125:   nsRect r = ComputeOutlineAndEffectsRect(this, &anyOutlineOrEffects,
19125:                                           aOldOverflowRect, PR_FALSE);
19125:   if (anyOutlineOrEffects) {
17140:     r.UnionRect(aOldOverflowRect, r);
34422:     InvalidateRectForFrameSizeChange(this, r);
    1:     return;
    1:   }
    1: 
28109:   // Invalidate the old frame border box if the frame has borders. Those
28109:   // borders may be moving.
    1:   const nsStyleBorder* border = GetStyleBorder();
    1:   NS_FOR_CSS_SIDES(side) {
15992:     if (border->GetActualBorderWidth(side) != 0) {
28109:       if ((side == NS_SIDE_LEFT || side == NS_SIDE_TOP) &&
28109:           !nsLayoutUtils::HasNonZeroCornerOnSide(border->mBorderRadius, side) &&
28109:           !border->GetBorderImage() &&
28109:           border->GetBorderStyle(side) == NS_STYLE_BORDER_STYLE_SOLID) {
28109:         // We also need to be sure that the bottom-left or top-right
28109:         // corner is simple. For example, if the bottom or right border
28109:         // has a different color, we would need to invalidate the corner
28109:         // area. But that's OK because if there is a right or bottom border,
28109:         // we'll invalidate the entire border-box here anyway.
28109:         continue;
28109:       }
34422:       InvalidateRectForFrameSizeChange(this, nsRect(0, 0, aOldRect.width, aOldRect.height));
    1:       return;
    1:     }
    1:   }
    1: 
33360:   const nsStyleBackground *bg = GetStyleBackground();
33360:   if (!bg->IsTransparent()) {
    1:     // Invalidate the old frame background if the frame has a background
    1:     // whose position depends on the size of the frame
25276:     NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, bg) {
25276:       const nsStyleBackground::Layer &layer = bg->mLayers[i];
34422:       if (layer.RenderingMightDependOnFrameSize()) {
34422:         InvalidateRectForFrameSizeChange(this, nsRect(0, 0, aOldRect.width, aOldRect.height));
    1:         return;
    1:       }
    1:     }
33360: 
33360:     // Invalidate the old frame background if the frame has a background
33360:     // that is being clipped by border-radius, since the old or new area
33360:     // clipped off by the radius is not necessarily in the area that has
33360:     // already been invalidated (even if only the top-left corner has a
33360:     // border radius).
33360:     if (nsLayoutUtils::HasNonZeroCorner(border->mBorderRadius)) {
34422:       InvalidateRectForFrameSizeChange(this, nsRect(0, 0, aOldRect.width, aOldRect.height));
33360:       return;
33360:     }
33360:   }
25276: }
    1: 
    1: // Define the MAX_FRAME_DEPTH to be the ContentSink's MAX_REFLOW_DEPTH plus
    1: // 4 for the frames above the document's frames: 
    1: //  the Viewport, GFXScroll, ScrollPort, and Canvas
    1: #define MAX_FRAME_DEPTH (MAX_REFLOW_DEPTH+4)
    1: 
    1: PRBool
    1: nsFrame::IsFrameTreeTooDeep(const nsHTMLReflowState& aReflowState,
    1:                             nsHTMLReflowMetrics& aMetrics)
    1: {
    1:   if (aReflowState.mReflowDepth >  MAX_FRAME_DEPTH) {
 3724:     mState |= NS_FRAME_TOO_DEEP_IN_FRAME_TREE;
26950:     ClearOverflowRect();
    1:     aMetrics.width = 0;
    1:     aMetrics.height = 0;
    1:     aMetrics.ascent = 0;
    1:     aMetrics.mCarriedOutBottomMargin.Zero();
    1:     aMetrics.mOverflowArea.x = 0;
    1:     aMetrics.mOverflowArea.y = 0;
    1:     aMetrics.mOverflowArea.width = 0;
    1:     aMetrics.mOverflowArea.height = 0;
    1:     return PR_TRUE;
    1:   }
 3724:   mState &= ~NS_FRAME_TOO_DEEP_IN_FRAME_TREE;
    1:   return PR_FALSE;
    1: }
    1: 
    1: /* virtual */ PRBool nsFrame::IsContainingBlock() const
    1: {
    1:   const nsStyleDisplay* display = GetStyleDisplay();
    1: 
    1:   // Absolute positioning causes |display->mDisplay| to be set to block,
    1:   // if needed.
    1:   return display->mDisplay == NS_STYLE_DISPLAY_BLOCK || 
    1:          display->mDisplay == NS_STYLE_DISPLAY_INLINE_BLOCK || 
    1:          display->mDisplay == NS_STYLE_DISPLAY_LIST_ITEM ||
    1:          display->mDisplay == NS_STYLE_DISPLAY_TABLE_CELL;
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: 
    1: PRInt32 nsFrame::ContentIndexInContainer(const nsIFrame* aFrame)
    1: {
    1:   PRInt32 result = -1;
    1: 
    1:   nsIContent* content = aFrame->GetContent();
    1:   if (content) {
    1:     nsIContent* parentContent = content->GetParent();
    1:     if (parentContent) {
    1:       result = parentContent->IndexOf(content);
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: /**
    1:  * List a frame tree to stdout. Meant to be called from gdb.
    1:  */
    1: void
    1: DebugListFrameTree(nsIFrame* aFrame)
    1: {
    1:   ((nsFrame*)aFrame)->List(stdout, 0);
    1: }
    1: 
    1: 
    1: // Debugging
    1: NS_IMETHODIMP
    1: nsFrame::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   IndentBy(out, aIndent);
    1:   ListTag(out);
    1: #ifdef DEBUG_waterson
 3233:   fprintf(out, " [parent=%p]", static_cast<void*>(mParent));
    1: #endif
    1:   if (HasView()) {
 3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
    1:   }
    1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
    1:   if (0 != mState) {
    1:     fprintf(out, " [state=%08x]", mState);
    1:   }
    1:   nsIFrame* prevInFlow = GetPrevInFlow();
    1:   nsIFrame* nextInFlow = GetNextInFlow();
    1:   if (nsnull != prevInFlow) {
 3233:     fprintf(out, " prev-in-flow=%p", static_cast<void*>(prevInFlow));
    1:   }
    1:   if (nsnull != nextInFlow) {
 3233:     fprintf(out, " next-in-flow=%p", static_cast<void*>(nextInFlow));
 3233:   }
 3233:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
 3233:   nsFrame* f = const_cast<nsFrame*>(this);
26950:   if (f->HasOverflowRect()) {
11909:     nsRect overflowArea = f->GetOverflowRect();
11909:     fprintf(out, " [overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
11909:             overflowArea.width, overflowArea.height);
    1:   }
    1:   fputs("\n", out);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Frame"), aResult);
    1: }
    1: 
    1: NS_IMETHODIMP_(nsFrameState)
    1: nsFrame::GetDebugStateBits() const
    1: {
    1:   // We'll ignore these flags for the purposes of comparing frame state:
    1:   //
    1:   //   NS_FRAME_EXTERNAL_REFERENCE
    1:   //     because this is set by the event state manager or the
    1:   //     caret code when a frame is focused. Depending on whether
    1:   //     or not the regression tests are run as the focused window
    1:   //     will make this value vary randomly.
    1: #define IRRELEVANT_FRAME_STATE_FLAGS NS_FRAME_EXTERNAL_REFERENCE
    1: 
    1: #define FRAME_STATE_MASK (~(IRRELEVANT_FRAME_STATE_FLAGS))
    1: 
    1:   return GetStateBits() & FRAME_STATE_MASK;
    1: }
    1: 
    1: nsresult
    1: nsFrame::MakeFrameName(const nsAString& aType, nsAString& aResult) const
    1: {
    1:   aResult = aType;
    1:   if (mContent && !mContent->IsNodeOfType(nsINode::eTEXT)) {
    1:     nsAutoString buf;
    1:     mContent->Tag()->ToString(buf);
    1:     aResult.Append(NS_LITERAL_STRING("(") + buf + NS_LITERAL_STRING(")"));
    1:   }
    1:   char buf[40];
    1:   PR_snprintf(buf, sizeof(buf), "(%d)", ContentIndexInContainer(this));
    1:   AppendASCIItoUTF16(buf, aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrame::XMLQuote(nsString& aString)
    1: {
    1:   PRInt32 i, len = aString.Length();
    1:   for (i = 0; i < len; i++) {
    1:     PRUnichar ch = aString.CharAt(i);
    1:     if (ch == '<') {
    1:       nsAutoString tmp(NS_LITERAL_STRING("&lt;"));
    1:       aString.Cut(i, 1);
    1:       aString.Insert(tmp, i);
    1:       len += 3;
    1:       i += 3;
    1:     }
    1:     else if (ch == '>') {
    1:       nsAutoString tmp(NS_LITERAL_STRING("&gt;"));
    1:       aString.Cut(i, 1);
    1:       aString.Insert(tmp, i);
    1:       len += 3;
    1:       i += 3;
    1:     }
    1:     else if (ch == '\"') {
    1:       nsAutoString tmp(NS_LITERAL_STRING("&quot;"));
    1:       aString.Cut(i, 1);
    1:       aString.Insert(tmp, i);
    1:       len += 5;
    1:       i += 5;
    1:     }
    1:   }
    1: }
    1: #endif
    1: 
    1: PRBool
    1: nsIFrame::IsVisibleForPainting(nsDisplayListBuilder* aBuilder) {
    1:   if (!GetStyleVisibility()->IsVisible())
    1:     return PR_FALSE;
    1:   nsISelection* sel = aBuilder->GetBoundingSelection();
    1:   return !sel || IsVisibleInSelection(sel);
    1: }
    1: 
    1: PRBool
    1: nsIFrame::IsVisibleForPainting() {
    1:   if (!GetStyleVisibility()->IsVisible())
    1:     return PR_FALSE;
    1: 
  238:   nsPresContext* pc = PresContext();
    1:   if (!pc->IsRenderingOnlySelection())
    1:     return PR_TRUE;
    1: 
    1:   nsCOMPtr<nsISelectionController> selcon(do_QueryInterface(pc->PresShell()));
    1:   if (selcon) {
    1:     nsCOMPtr<nsISelection> sel;
    1:     selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:                          getter_AddRefs(sel));
    1:     if (sel)
    1:       return IsVisibleInSelection(sel);
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsIFrame::IsVisibleInSelection(nsDisplayListBuilder* aBuilder) {
    1:   nsISelection* sel = aBuilder->GetBoundingSelection();
    1:   return !sel || IsVisibleInSelection(sel);
    1: }
    1: 
    1: PRBool
    1: nsIFrame::IsVisibleOrCollapsedForPainting(nsDisplayListBuilder* aBuilder) {
    1:   if (!GetStyleVisibility()->IsVisibleOrCollapsed())
    1:     return PR_FALSE;
    1:   nsISelection* sel = aBuilder->GetBoundingSelection();
    1:   return !sel || IsVisibleInSelection(sel);
    1: }
    1: 
    1: PRBool
    1: nsIFrame::IsVisibleInSelection(nsISelection* aSelection)
    1: {
    1:   if ((mState & NS_FRAME_SELECTED_CONTENT) == NS_FRAME_SELECTED_CONTENT)
    1:     return PR_TRUE;
    1:   
    1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
    1:   PRBool vis;
    1:   nsresult rv = aSelection->ContainsNode(node, PR_TRUE, &vis);
    1:   return NS_FAILED(rv) || vis;
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsFrame::IsEmpty()
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsIFrame::CachedIsEmpty()
    1: {
    1:   NS_PRECONDITION(!(GetStateBits() & NS_FRAME_IS_DIRTY),
    1:                   "Must only be called on reflowed lines");
    1:   return IsEmpty();
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsFrame::IsSelfEmpty()
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetSelectionController(nsPresContext *aPresContext, nsISelectionController **aSelCon)
    1: {
    1:   if (!aPresContext || !aSelCon)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   nsIFrame *frame = this;
    1:   while (frame && (frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION)) {
23554:     nsITextControlFrame *tcf = do_QueryFrame(frame);
23554:     if (tcf) {
    1:       NS_IF_ADDREF(*aSelCon = tcf->GetOwnedSelectionController());
    1:       return NS_OK;
    1:     }
    1:     frame = frame->GetParent();
    1:   }
    1: 
    1:   return CallQueryInterface(aPresContext->GetPresShell(), aSelCon);
    1: }
    1: 
 8295: already_AddRefed<nsFrameSelection>
 8295: nsIFrame::GetFrameSelection()
 8295: {
 8295:   nsFrameSelection* fs =
 8295:     const_cast<nsFrameSelection*>(GetConstFrameSelection());
 8295:   NS_IF_ADDREF(fs);
 8295:   return fs;
 8295: }
 8295: 
 8295: const nsFrameSelection*
 8295: nsIFrame::GetConstFrameSelection()
    1: {
    1:   nsIFrame *frame = this;
    1:   while (frame && (frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION)) {
23554:     nsITextControlFrame *tcf = do_QueryFrame(frame);
23554:     if (tcf) {
    1:       return tcf->GetOwnedFrameSelection();
    1:     }
    1:     frame = frame->GetParent();
    1:   }
    1: 
 8295:   return PresContext()->PresShell()->ConstFrameSelection();
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
24806: nsFrame::DumpRegressionData(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent)
    1: {
    1:   IndentBy(out, aIndent);
    1:   fprintf(out, "<frame va=\"%ld\" type=\"", PRUptrdiff(this));
    1:   nsAutoString name;
    1:   GetFrameName(name);
    1:   XMLQuote(name);
    1:   fputs(NS_LossyConvertUTF16toASCII(name).get(), out);
    1:   fprintf(out, "\" state=\"%d\" parent=\"%ld\">\n",
    1:           GetDebugStateBits(), PRUptrdiff(mParent));
    1: 
    1:   aIndent++;
24806:   DumpBaseRegressionData(aPresContext, out, aIndent);
    1:   aIndent--;
    1: 
    1:   IndentBy(out, aIndent);
    1:   fprintf(out, "</frame>\n");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
24806: nsFrame::DumpBaseRegressionData(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent)
    1: {
32845:   if (GetNextSibling()) {
    1:     IndentBy(out, aIndent);
32845:     fprintf(out, "<next-sibling va=\"%ld\"/>\n", PRUptrdiff(GetNextSibling()));
    1:   }
    1: 
    1:   if (HasView()) {
    1:     IndentBy(out, aIndent);
    1:     fprintf(out, "<view va=\"%ld\">\n", PRUptrdiff(GetView()));
    1:     aIndent++;
    1:     // XXX add in code to dump out view state too...
    1:     aIndent--;
    1:     IndentBy(out, aIndent);
    1:     fprintf(out, "</view>\n");
    1:   }
    1: 
    1:   IndentBy(out, aIndent);
    1:   fprintf(out, "<bbox x=\"%d\" y=\"%d\" w=\"%d\" h=\"%d\"/>\n",
    1:           mRect.x, mRect.y, mRect.width, mRect.height);
    1: 
    1:   // Now dump all of the children on all of the child lists
    1:   nsIFrame* kid;
    1:   nsIAtom* list = nsnull;
    1:   PRInt32 listIndex = 0;
    1:   do {
    1:     kid = GetFirstChild(list);
    1:     if (kid) {
    1:       IndentBy(out, aIndent);
    1:       if (nsnull != list) {
    1:         nsAutoString listName;
    1:         list->ToString(listName);
    1:         fprintf(out, "<child-list name=\"");
    1:         XMLQuote(listName);
    1:         fputs(NS_LossyConvertUTF16toASCII(listName).get(), out);
    1:         fprintf(out, "\">\n");
    1:       }
    1:       else {
    1:         fprintf(out, "<child-list>\n");
    1:       }
    1:       aIndent++;
    1:       while (kid) {
31709:         kid->DumpRegressionData(aPresContext, out, aIndent);
    1:         kid = kid->GetNextSibling();
    1:       }
    1:       aIndent--;
    1:       IndentBy(out, aIndent);
    1:       fprintf(out, "</child-list>\n");
    1:     }
    1:     list = GetAdditionalChildListName(listIndex++);
    1:   } while (nsnull != list);
    1: }
    1: #endif
    1: 
30695: void
30695: nsIFrame::SetSelected(PRBool aSelected, SelectionType aType)
30695: {
30695:   NS_ASSERTION(!GetPrevContinuation(),
30695:                "Should only be called on first in flow");
30695:   if (aType != nsISelectionController::SELECTION_NORMAL)
30695:     return;
30695: 
    1:   // check whether style allows selection
    1:   PRBool selectable;
    1:   IsSelectable(&selectable, nsnull);
    1:   if (!selectable)
30695:     return;
30695: 
30695:   for (nsIFrame* f = this; f; f = f->GetNextContinuation()) {
    1:     if (aSelected) {
    1:       AddStateBits(NS_FRAME_SELECTED_CONTENT);
30695:     } else {
    1:       RemoveStateBits(NS_FRAME_SELECTED_CONTENT);
30695:     }
    1: 
    1:     // Repaint this frame subtree's entire area
19380:     InvalidateOverflowRect();
30695:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetSelected(PRBool *aSelected) const
    1: {
    1:   if (!aSelected )
    1:     return NS_ERROR_NULL_POINTER;
 6770:   *aSelected = !!(mState & NS_FRAME_SELECTED_CONTENT);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 4741: nsFrame::GetPointFromOffset(PRInt32 inOffset, nsPoint* outPoint)
    1: {
    1:   NS_PRECONDITION(outPoint != nsnull, "Null parameter");
    1:   nsPoint bottomLeft(0, 0);
    1:   if (mContent)
    1:   {
    1:     nsIContent* newContent = mContent->GetParent();
    1:     if (newContent){
    1:       PRInt32 newOffset = newContent->IndexOf(mContent);
    1: 
    1:       PRBool isRTL = (NS_GET_EMBEDDING_LEVEL(this) & 1) == 1;
19264:       if ((!isRTL && inOffset > newOffset) ||
19264:           (isRTL && inOffset <= newOffset))
    1:         bottomLeft.x = GetRect().width;
    1:     }
    1:   }
    1:   *outPoint = bottomLeft;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetChildFrameContainingOffset(PRInt32 inContentOffset, PRBool inHint, PRInt32* outFrameContentOffset, nsIFrame **outChildFrame)
    1: {
    1:   NS_PRECONDITION(outChildFrame && outFrameContentOffset, "Null parameter");
    1:   *outFrameContentOffset = (PRInt32)inHint;
    1:   //the best frame to reflect any given offset would be a visible frame if possible
    1:   //i.e. we are looking for a valid frame to place the blinking caret 
    1:   nsRect rect = GetRect();
    1:   if (!rect.width || !rect.height)
    1:   {
    1:     //if we have a 0 width or height then lets look for another frame that possibly has
    1:     //the same content.  If we have no frames in flow then just let us return 'this' frame
    1:     nsIFrame* nextFlow = GetNextInFlow();
    1:     if (nextFlow)
    1:       return nextFlow->GetChildFrameContainingOffset(inContentOffset, inHint, outFrameContentOffset, outChildFrame);
    1:   }
    1:   *outChildFrame = this;
    1:   return NS_OK;
    1: }
    1: 
    1: //
    1: // What I've pieced together about this routine:
    1: // Starting with a block frame (from which a line frame can be gotten)
    1: // and a line number, drill down and get the first/last selectable
    1: // frame on that line, depending on aPos->mDirection.
    1: // aOutSideLimit != 0 means ignore aLineStart, instead work from
    1: // the end (if > 0) or beginning (if < 0).
    1: //
    1: nsresult
    1: nsFrame::GetNextPrevLineFromeBlockFrame(nsPresContext* aPresContext,
    1:                                         nsPeekOffsetStruct *aPos,
    1:                                         nsIFrame *aBlockFrame, 
    1:                                         PRInt32 aLineStart, 
    1:                                         PRInt8 aOutSideLimit
    1:                                         )
    1: {
    1:   //magic numbers aLineStart will be -1 for end of block 0 will be start of block
    1:   if (!aBlockFrame || !aPos)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   aPos->mResultFrame = nsnull;
    1:   aPos->mResultContent = nsnull;
    1:   aPos->mAttachForward = (aPos->mDirection == eDirNext);
    1: 
21112:   nsAutoLineIterator it = aBlockFrame->GetLineIterator();
21112:   if (!it)
21112:     return NS_ERROR_FAILURE;
    1:   PRInt32 searchingLine = aLineStart;
21112:   PRInt32 countLines = it->GetNumLines();
    1:   if (aOutSideLimit > 0) //start at end
    1:     searchingLine = countLines;
    1:   else if (aOutSideLimit <0)//start at beginning
    1:     searchingLine = -1;//"next" will be 0  
    1:   else 
    1:     if ((aPos->mDirection == eDirPrevious && searchingLine == 0) || 
    1:        (aPos->mDirection == eDirNext && searchingLine >= (countLines -1) )){
    1:       //we need to jump to new block frame.
    1:            return NS_ERROR_FAILURE;
    1:     }
    1:   PRInt32 lineFrameCount;
    1:   nsIFrame *resultFrame = nsnull;
    1:   nsIFrame *farStoppingFrame = nsnull; //we keep searching until we find a "this" frame then we go to next line
    1:   nsIFrame *nearStoppingFrame = nsnull; //if we are backing up from edge, stop here
    1:   nsIFrame *firstFrame;
    1:   nsIFrame *lastFrame;
    1:   nsRect  rect;
    1:   PRBool isBeforeFirstFrame, isAfterLastFrame;
    1:   PRBool found = PR_FALSE;
21112: 
21112:   nsresult result = NS_OK;
    1:   while (!found)
    1:   {
    1:     if (aPos->mDirection == eDirPrevious)
    1:       searchingLine --;
    1:     else
    1:       searchingLine ++;
    1:     if ((aPos->mDirection == eDirPrevious && searchingLine < 0) || 
    1:        (aPos->mDirection == eDirNext && searchingLine >= countLines ))
    1:     {
    1:       //we need to jump to new block frame.
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     PRUint32 lineFlags;
    1:     result = it->GetLine(searchingLine, &firstFrame, &lineFrameCount,
    1:                          rect, &lineFlags);
    1:     if (!lineFrameCount) 
    1:       continue;
    1:     if (NS_SUCCEEDED(result)){
    1:       lastFrame = firstFrame;
    1:       for (;lineFrameCount > 1;lineFrameCount --){
    1:         //result = lastFrame->GetNextSibling(&lastFrame, searchingLine);
    1:         result = it->GetNextSiblingOnLine(lastFrame, searchingLine);
    1:         if (NS_FAILED(result) || !lastFrame){
    1:           NS_ERROR("GetLine promised more frames than could be found");
    1:           return NS_ERROR_FAILURE;
    1:         }
    1:       }
    1:       GetLastLeaf(aPresContext, &lastFrame);
    1: 
    1:       if (aPos->mDirection == eDirNext){
    1:         nearStoppingFrame = firstFrame;
    1:         farStoppingFrame = lastFrame;
    1:       }
    1:       else{
    1:         nearStoppingFrame = lastFrame;
    1:         farStoppingFrame = firstFrame;
    1:       }
    1:       nsPoint offset;
    1:       nsIView * view; //used for call of get offset from view
    1:       aBlockFrame->GetOffsetFromView(offset,&view);
    1:       nscoord newDesiredX  = aPos->mDesiredX - offset.x;//get desired x into blockframe coordinates!
    1:       result = it->FindFrameAt(searchingLine, newDesiredX, &resultFrame, &isBeforeFirstFrame, &isAfterLastFrame);
    1:       if(NS_FAILED(result))
    1:         continue;
    1:     }
    1: 
    1:     if (NS_SUCCEEDED(result) && resultFrame)
    1:     {
    1:       //check to see if this is ANOTHER blockframe inside the other one if so then call into its lines
21112:       nsAutoLineIterator newIt = resultFrame->GetLineIterator();
21112:       if (newIt)
    1:       {
    1:         aPos->mResultFrame = resultFrame;
    1:         return NS_OK;
    1:       }
    1:       //resultFrame is not a block frame
21112:       result = NS_ERROR_FAILURE;
    1: 
21105:       nsCOMPtr<nsIFrameEnumerator> frameTraversal;
    1:       result = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
    1:                                     aPresContext, resultFrame,
    1:                                     ePostOrder,
    1:                                     PR_FALSE, // aVisual
    1:                                     aPos->mScrollViewStop,
    1:                                     PR_FALSE  // aFollowOOFs
    1:                                     );
    1:       if (NS_FAILED(result))
    1:         return result;
    1:       nsIFrame *storeOldResultFrame = resultFrame;
    1:       while ( !found ){
    1:         nsPoint point;
    1:         point.x = aPos->mDesiredX;
    1: 
    1:         nsRect tempRect = resultFrame->GetRect();
    1:         nsPoint offset;
    1:         nsIView * view; //used for call of get offset from view
    1:         result = resultFrame->GetOffsetFromView(offset, &view);
    1:         if (NS_FAILED(result))
    1:           return result;
    1:         point.y = tempRect.height + offset.y;
    1: 
    1:         //special check. if we allow non-text selection then we can allow a hit location to fall before a table. 
    1:         //otherwise there is no way to get and click signal to fall before a table (it being a line iterator itself)
    1:         PRInt16 isEditor = 0;
    1:         nsIPresShell *shell = aPresContext->GetPresShell();
    1:         if (!shell)
    1:           return NS_ERROR_FAILURE;
    1:         shell->GetSelectionFlags ( &isEditor );
    1:         isEditor = isEditor == nsISelectionDisplay::DISPLAY_ALL;
    1:         if ( isEditor ) 
    1:         {
    1:           if (resultFrame->GetType() == nsGkAtoms::tableOuterFrame)
    1:           {
    1:             if (((point.x - offset.x + tempRect.x)<0) ||  ((point.x - offset.x+ tempRect.x)>tempRect.width))//off left/right side
    1:             {
    1:               nsIContent* content = resultFrame->GetContent();
    1:               if (content)
    1:               {
    1:                 nsIContent* parent = content->GetParent();
    1:                 if (parent)
    1:                 {
    1:                   aPos->mResultContent = parent;
    1:                   aPos->mContentOffset = parent->IndexOf(content);
    1:                   aPos->mAttachForward = PR_FALSE;
    1:                   if ((point.x - offset.x+ tempRect.x)>tempRect.width)
    1:                   {
    1:                     aPos->mContentOffset++;//go to end of this frame
    1:                     aPos->mAttachForward = PR_TRUE;
    1:                   }
    1:                   //result frame is the result frames parent.
    1:                   aPos->mResultFrame = resultFrame->GetParent();
    1:                   return NS_POSITION_BEFORE_TABLE;
    1:                 }
    1:               }
    1:             }
    1:           }
    1:         }
    1: 
    1:         if (!resultFrame->HasView())
    1:         {
    1:           nsIView* view;
    1:           nsPoint offset;
    1:           resultFrame->GetOffsetFromView(offset, &view);
    1:           ContentOffsets offsets =
    1:               resultFrame->GetContentOffsetsFromPoint(point - offset);
    1:           aPos->mResultContent = offsets.content;
    1:           aPos->mContentOffset = offsets.offset;
    1:           aPos->mAttachForward = offsets.associateWithNext;
    1:           if (offsets.content)
    1:           {
    1:             PRBool selectable;
    1:             resultFrame->IsSelectable(&selectable, nsnull);
    1:             if (selectable)
    1:             {
    1:               found = PR_TRUE;
    1:               break;
    1:             }
    1:           }
    1:         }
    1: 
    1:         if (aPos->mDirection == eDirPrevious && (resultFrame == farStoppingFrame))
    1:           break;
    1:         if (aPos->mDirection == eDirNext && (resultFrame == nearStoppingFrame))
    1:           break;
    1:         //always try previous on THAT line if that fails go the other way
21105:         frameTraversal->Prev();
21105:         resultFrame = frameTraversal->CurrentItem();
21105:         if (!resultFrame)
21105:           return NS_ERROR_FAILURE;
    1:       }
    1: 
    1:       if (!found){
    1:         resultFrame = storeOldResultFrame;
    1:         result = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
    1:                                       aPresContext, resultFrame,
    1:                                       eLeaf,
    1:                                       PR_FALSE, // aVisual
    1:                                       aPos->mScrollViewStop,
    1:                                       PR_FALSE  // aFollowOOFs
    1:                                       );
    1:       }
    1:       while ( !found ){
    1:         nsPoint point(aPos->mDesiredX, 0);
    1:         nsIView* view;
    1:         nsPoint offset;
    1:         resultFrame->GetOffsetFromView(offset, &view);
    1:         ContentOffsets offsets =
    1:             resultFrame->GetContentOffsetsFromPoint(point - offset);
    1:         aPos->mResultContent = offsets.content;
    1:         aPos->mContentOffset = offsets.offset;
    1:         aPos->mAttachForward = offsets.associateWithNext;
    1:         if (offsets.content)
    1:         {
    1:           PRBool selectable;
    1:           resultFrame->IsSelectable(&selectable, nsnull);
    1:           if (selectable)
    1:           {
    1:             found = PR_TRUE;
    1:             if (resultFrame == farStoppingFrame)
    1:               aPos->mAttachForward = PR_FALSE;
    1:             else
    1:               aPos->mAttachForward = PR_TRUE;
    1:             break;
    1:           }
    1:         }
    1:         if (aPos->mDirection == eDirPrevious && (resultFrame == nearStoppingFrame))
    1:           break;
    1:         if (aPos->mDirection == eDirNext && (resultFrame == farStoppingFrame))
    1:           break;
    1:         //previous didnt work now we try "next"
21105:         frameTraversal->Next();
21105:         nsIFrame *tempFrame = frameTraversal->CurrentItem();
21105:         if (!tempFrame)
    1:           break;
21105:         resultFrame = tempFrame;
    1:       }
    1:       aPos->mResultFrame = resultFrame;
    1:     }
    1:     else {
    1:         //we need to jump to new block frame.
    1:       aPos->mAmount = eSelectLine;
    1:       aPos->mStartOffset = 0;
    1:       aPos->mAttachForward = !(aPos->mDirection == eDirNext);
    1:       if (aPos->mDirection == eDirPrevious)
    1:         aPos->mStartOffset = -1;//start from end
    1:      return aBlockFrame->PeekOffset(aPos);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsPeekOffsetStruct nsIFrame::GetExtremeCaretPosition(PRBool aStart)
    1: {
    1:   nsPeekOffsetStruct result;
    1: 
    1:   FrameTarget targetFrame = DrillDownToSelectionFrame(this, !aStart);
    1:   FrameContentRange range = GetRangeForFrame(targetFrame.frame);
    1:   result.mResultContent = range.content;
    1:   result.mContentOffset = aStart ? range.start : range.end;
    1:   result.mAttachForward = (result.mContentOffset == range.start);
    1:   return result;
    1: }
    1: 
    1: // Find the first (or last) descendant of the given frame
    1: // which is either a block frame or a BRFrame.
    1: static nsContentAndOffset
    1: FindBlockFrameOrBR(nsIFrame* aFrame, nsDirection aDirection)
    1: {
    1:   nsContentAndOffset result;
    1:   result.mContent =  nsnull;
12151:   result.mOffset = 0;
    1: 
    1:   if (aFrame->IsGeneratedContentFrame())
    1:     return result;
    1: 
    1:   // Treat form controls as inline leaves
    1:   // XXX we really need a way to determine whether a frame is inline-level
23554:   nsIFormControlFrame* fcf = do_QueryFrame(aFrame);
23554:   if (fcf)
    1:     return result;
    1:   
    1:   // Check the frame itself
    1:   // Fall through "special" block frames because their mContent is the content
    1:   // of the inline frames they were created from. The first/last child of
    1:   // such frames is the real block frame we're looking for.
19264:   if ((nsLayoutUtils::GetAsBlock(aFrame) && !(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) ||
    1:       aFrame->GetType() == nsGkAtoms::brFrame) {
    1:     nsIContent* content = aFrame->GetContent();
    1:     result.mContent = content->GetParent();
12151:     // In some cases (bug 310589, bug 370174) we end up here with a null content.
12151:     // This probably shouldn't ever happen, but since it sometimes does, we want
12151:     // to avoid crashing here.
12151:     NS_ASSERTION(result.mContent, "Unexpected orphan content");
12118:     if (result.mContent)
    1:       result.mOffset = result.mContent->IndexOf(content) + 
    1:         (aDirection == eDirPrevious ? 1 : 0);
    1:     return result;
    1:   }
    1: 
    1:   // If this is a preformatted text frame, see if it ends with a newline
    1:   if (aFrame->HasTerminalNewline() &&
16575:       aFrame->GetStyleContext()->GetStyleText()->NewlineIsSignificant()) {
    1:     PRInt32 startOffset, endOffset;
    1:     aFrame->GetOffsets(startOffset, endOffset);
    1:     result.mContent = aFrame->GetContent();
    1:     result.mOffset = endOffset - (aDirection == eDirPrevious ? 0 : 1);
    1:     return result;
    1:   }
    1: 
    1:   // Iterate over children and call ourselves recursively
    1:   if (aDirection == eDirPrevious) {
33388:     nsIFrame* child = aFrame->GetChildList(nsnull).LastChild();
    1:     while(child && !result.mContent) {
    1:       result = FindBlockFrameOrBR(child, aDirection);
33388:       child = child->GetPrevSibling();
    1:     }
    1:   } else { // eDirNext
    1:     nsIFrame* child = aFrame->GetFirstChild(nsnull);
    1:     while(child && !result.mContent) {
    1:       result = FindBlockFrameOrBR(child, aDirection);
    1:       child = child->GetNextSibling();
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsIFrame::PeekOffsetParagraph(nsPeekOffsetStruct *aPos)
    1: {
    1:   nsIFrame* frame = this;
    1:   nsContentAndOffset blockFrameOrBR;
    1:   blockFrameOrBR.mContent = nsnull;
    1:   PRBool reachedBlockAncestor = PR_FALSE;
    1: 
    1:   // Go through containing frames until reaching a block frame.
    1:   // In each step, search the previous (or next) siblings for the closest
    1:   // "stop frame" (a block frame or a BRFrame).
    1:   // If found, set it to be the selection boundray and abort.
    1:   
    1:   if (aPos->mDirection == eDirPrevious) {
    1:     while (!reachedBlockAncestor) {
    1:       nsIFrame* parent = frame->GetParent();
  532:       // Treat a frame associated with the root content as if it were a block frame.
  532:       if (!frame->mContent || !frame->mContent->GetParent()) {
    1:         reachedBlockAncestor = PR_TRUE;
    1:         break;
    1:       }
33388:       nsIFrame* sibling = frame->GetPrevSibling();
    1:       while (sibling && !blockFrameOrBR.mContent) {
    1:         blockFrameOrBR = FindBlockFrameOrBR(sibling, eDirPrevious);
33388:         sibling = sibling->GetPrevSibling();
    1:       }
    1:       if (blockFrameOrBR.mContent) {
    1:         aPos->mResultContent = blockFrameOrBR.mContent;
    1:         aPos->mContentOffset = blockFrameOrBR.mOffset;
    1:         break;
    1:       }
    1:       frame = parent;
15909:       reachedBlockAncestor = (nsLayoutUtils::GetAsBlock(frame) != nsnull);
    1:     }
    1:     if (reachedBlockAncestor) { // no "stop frame" found
    1:       aPos->mResultContent = frame->GetContent();
    1:       aPos->mContentOffset = 0;
    1:     }
    1:   } else { // eDirNext
    1:     while (!reachedBlockAncestor) {
    1:       nsIFrame* parent = frame->GetParent();
  532:       // Treat a frame associated with the root content as if it were a block frame.
  532:       if (!frame->mContent || !frame->mContent->GetParent()) {
    1:         reachedBlockAncestor = PR_TRUE;
    1:         break;
    1:       }
    1:       nsIFrame* sibling = frame;
    1:       while (sibling && !blockFrameOrBR.mContent) {
    1:         blockFrameOrBR = FindBlockFrameOrBR(sibling, eDirNext);
    1:         sibling = sibling->GetNextSibling();
    1:       }
    1:       if (blockFrameOrBR.mContent) {
    1:         aPos->mResultContent = blockFrameOrBR.mContent;
    1:         aPos->mContentOffset = blockFrameOrBR.mOffset;
    1:         break;
    1:       }
    1:       frame = parent;
15909:       reachedBlockAncestor = (nsLayoutUtils::GetAsBlock(frame) != nsnull);
    1:     }
    1:     if (reachedBlockAncestor) { // no "stop frame" found
    1:       aPos->mResultContent = frame->GetContent();
    1:       if (aPos->mResultContent)
    1:         aPos->mContentOffset = aPos->mResultContent->GetChildCount();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Determine movement direction relative to frame
    1: static PRBool IsMovingInFrameDirection(nsIFrame* frame, nsDirection aDirection, PRBool aVisual)
    1: {
    1:   PRBool isReverseDirection = aVisual ?
    1:     (NS_GET_EMBEDDING_LEVEL(frame) & 1) != (NS_GET_BASE_LEVEL(frame) & 1) : PR_FALSE;
    1:   return aDirection == (isReverseDirection ? eDirPrevious : eDirNext);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIFrame::PeekOffset(nsPeekOffsetStruct* aPos)
    1: {
    1:   if (!aPos)
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsresult result = NS_ERROR_FAILURE;
    1: 
    1:   if (mState & NS_FRAME_IS_DIRTY)
    1:     return NS_ERROR_UNEXPECTED;
    1: 
    1:   // Translate content offset to be relative to frame
    1:   FrameContentRange range = GetRangeForFrame(this);
    1:   PRInt32 offset = aPos->mStartOffset - range.start;
    1:   nsIFrame* current = this;
    1:   
    1:   switch (aPos->mAmount) {
    1:     case eSelectCharacter:
    1:     {
    1:       PRBool eatingNonRenderableWS = PR_FALSE;
    1:       PRBool done = PR_FALSE;
    1:       
    1:       while (!done) {
    1:         PRBool movingInFrameDirection =
    1:           IsMovingInFrameDirection(current, aPos->mDirection, aPos->mVisual);
    1: 
    1:         if (eatingNonRenderableWS)
    1:           done = current->PeekOffsetNoAmount(movingInFrameDirection, &offset); 
    1:         else
    1:           done = current->PeekOffsetCharacter(movingInFrameDirection, &offset); 
    1: 
    1:         if (!done) {
    1:           PRBool jumpedLine;
    1:           result =
    1:             current->GetFrameFromDirection(aPos->mDirection, aPos->mVisual,
    1:                                            aPos->mJumpLines, aPos->mScrollViewStop,
    1:                                            &current, &offset, &jumpedLine);
    1:           if (NS_FAILED(result))
    1:             return result;
    1: 
    1:           // If we jumped lines, it's as if we found a character, but we still need
    1:           // to eat non-renderable content on the new line.
    1:           if (jumpedLine)
    1:             eatingNonRenderableWS = PR_TRUE;
    1:         }
    1:       }
    1: 
    1:       // Set outputs
    1:       range = GetRangeForFrame(current);
    1:       aPos->mResultFrame = current;
    1:       aPos->mResultContent = range.content;
    1:       // Output offset is relative to content, not frame
    1:       aPos->mContentOffset = offset < 0 ? range.end : range.start + offset;
    1:       
    1:       break;
    1:     }
    1:     case eSelectWord:
    1:     {
    1:       // wordSelectEatSpace means "are we looking for a boundary between whitespace
    1:       // and non-whitespace (in the direction we're moving in)".
    1:       // It is true when moving forward and looking for a beginning of a word, or
    1:       // when moving backwards and looking for an end of a word.
    1:       PRBool wordSelectEatSpace;
    1:       if (aPos->mWordMovementType != eDefaultBehavior) {
    1:         // aPos->mWordMovementType possible values:
    1:         //       eEndWord: eat the space if we're moving backwards
    1:         //       eStartWord: eat the space if we're moving forwards
    1:         wordSelectEatSpace = ((aPos->mWordMovementType == eEndWord) == (aPos->mDirection == eDirPrevious));
    1:       }
    1:       else {
    1:         // Use the hidden preference which is based on operating system behavior.
    1:         // This pref only affects whether moving forward by word should go to the end of this word or start of the next word.
    1:         // When going backwards, the start of the word is always used, on every operating system.
 3049:         wordSelectEatSpace = aPos->mDirection == eDirNext &&
 3049:           nsContentUtils::GetBoolPref("layout.word_select.eat_space_to_next_word");
    1:       }
    1:       
 5453:       // mSawBeforeType means "we already saw characters of the type
    1:       // before the boundary we're looking for". Examples:
    1:       // 1. If we're moving forward, looking for a word beginning (i.e. a boundary
    1:       //    between whitespace and non-whitespace), then eatingWS==PR_TRUE means
    1:       //    "we already saw some whitespace".
    1:       // 2. If we're moving backward, looking for a word beginning (i.e. a boundary
    1:       //    between non-whitespace and whitespace), then eatingWS==PR_TRUE means
    1:       //    "we already saw some non-whitespace".
 5453:       PeekWordState state;
    1:       PRBool done = PR_FALSE;
    1:       while (!done) {
    1:         PRBool movingInFrameDirection =
    1:           IsMovingInFrameDirection(current, aPos->mDirection, aPos->mVisual);
    1:         
 5453:         done = current->PeekOffsetWord(movingInFrameDirection, wordSelectEatSpace,
 5453:                                        aPos->mIsKeyboardSelect, &offset, &state);
    1:         
    1:         if (!done) {
    1:           nsIFrame* nextFrame;
    1:           PRInt32 nextFrameOffset;
    1:           PRBool jumpedLine;
    1:           result =
    1:             current->GetFrameFromDirection(aPos->mDirection, aPos->mVisual,
    1:                                            aPos->mJumpLines, aPos->mScrollViewStop,
    1:                                            &nextFrame, &nextFrameOffset, &jumpedLine);
    1:           // We can't jump lines if we're looking for whitespace following
    1:           // non-whitespace, and we already encountered non-whitespace.
    1:           if (NS_FAILED(result) ||
19264:               (jumpedLine && !wordSelectEatSpace && state.mSawBeforeType)) {
    1:             done = PR_TRUE;
    1:           } else {
 7679:             if (jumpedLine) {
 7679:               state.mContext.Truncate();
 7679:             }
    1:             current = nextFrame;
    1:             offset = nextFrameOffset;
    1:             // Jumping a line is equivalent to encountering whitespace
    1:             if (wordSelectEatSpace && jumpedLine)
 5453:               state.SetSawBeforeType();
    1:           }
    1:         }
    1:       }
    1:       
    1:       // Set outputs
    1:       range = GetRangeForFrame(current);
    1:       aPos->mResultFrame = current;
    1:       aPos->mResultContent = range.content;
    1:       // Output offset is relative to content, not frame
    1:       aPos->mContentOffset = offset < 0 ? range.end : range.start + offset;
    1:       break;
    1:     }
    1:     case eSelectLine :
    1:     {
21112:       nsAutoLineIterator iter;
    1:       nsIFrame *blockFrame = this;
    1: 
    1:       while (NS_FAILED(result)){
20200:         PRInt32 thisLine = nsFrame::GetLineNumber(blockFrame, aPos->mScrollViewStop, &blockFrame);
    1:         if (thisLine < 0) 
    1:           return  NS_ERROR_FAILURE;
21112:         iter = blockFrame->GetLineIterator();
21112:         NS_ASSERTION(iter, "GetLineNumber() succeeded but no block frame?");
21112:         result = NS_OK;
    1: 
    1:         int edgeCase = 0;//no edge case. this should look at thisLine
    1:         
    1:         PRBool doneLooping = PR_FALSE;//tells us when no more block frames hit.
    1:         //this part will find a frame or a block frame. if it's a block frame
    1:         //it will "drill down" to find a viable frame or it will return an error.
    1:         nsIFrame *lastFrame = this;
    1:         do {
  238:           result = nsFrame::GetNextPrevLineFromeBlockFrame(PresContext(),
    1:                                                            aPos, 
    1:                                                            blockFrame, 
    1:                                                            thisLine, 
    1:                                                            edgeCase //start from thisLine
    1:             );
    1:           if (NS_SUCCEEDED(result) && (!aPos->mResultFrame || aPos->mResultFrame == lastFrame))//we came back to same spot! keep going
    1:           {
    1:             aPos->mResultFrame = nsnull;
    1:             if (aPos->mDirection == eDirPrevious)
    1:               thisLine--;
    1:             else
    1:               thisLine++;
    1:           }
    1:           else //if failure or success with different frame.
    1:             doneLooping = PR_TRUE; //do not continue with while loop
    1: 
    1:           lastFrame = aPos->mResultFrame; //set last frame 
    1: 
    1:           if (NS_SUCCEEDED(result) && aPos->mResultFrame 
    1:             && blockFrame != aPos->mResultFrame)// make sure block element is not the same as the one we had before
    1:           {
    1: /* SPECIAL CHECK FOR TABLE NAVIGATION
    1:   tables need to navigate also and the frame that supports it is nsTableRowGroupFrame which is INSIDE
    1:   nsTableOuterFrame.  if we have stumbled onto an nsTableOuter we need to drill into nsTableRowGroup
    1:   if we hit a header or footer that's ok just go into them,
    1: */
    1:             PRBool searchTableBool = PR_FALSE;
    1:             if (aPos->mResultFrame->GetType() == nsGkAtoms::tableOuterFrame ||
    1:                 aPos->mResultFrame->GetType() == nsGkAtoms::tableCellFrame)
    1:             {
    1:               nsIFrame *frame = aPos->mResultFrame->GetFirstChild(nsnull);
    1:               //got the table frame now
    1:               while(frame) //ok time to drill down to find iterator
    1:               {
21112:                 iter = frame->GetLineIterator();
21112:                 if (iter)
    1:                 {
    1:                   aPos->mResultFrame = frame;
    1:                   searchTableBool = PR_TRUE;
21112:                   result = NS_OK;
    1:                   break; //while(frame)
    1:                 }
21112:                 result = NS_ERROR_FAILURE;
    1:                 frame = frame->GetFirstChild(nsnull);
    1:               }
    1:             }
21112: 
21112:             if (!searchTableBool) {
21112:               iter = aPos->mResultFrame->GetLineIterator();
21112:               result = iter ? NS_OK : NS_ERROR_FAILURE;
21112:             }
    1:             if (NS_SUCCEEDED(result) && iter)//we've struck another block element!
    1:             {
    1:               doneLooping = PR_FALSE;
    1:               if (aPos->mDirection == eDirPrevious)
    1:                 edgeCase = 1;//far edge, search from end backwards
    1:               else
    1:                 edgeCase = -1;//near edge search from beginning onwards
    1:               thisLine=0;//this line means nothing now.
    1:               //everything else means something so keep looking "inside" the block
    1:               blockFrame = aPos->mResultFrame;
    1: 
    1:             }
    1:             else
    1:             {
    1:               result = NS_OK;//THIS is to mean that everything is ok to the containing while loop
    1:               break;
    1:             }
    1:           }
    1:         } while (!doneLooping);
    1:       }
    1:       return result;
    1:     }
    1: 
    1:     case eSelectParagraph:
    1:       return PeekOffsetParagraph(aPos);
    1: 
    1:     case eSelectBeginLine:
    1:     case eSelectEndLine:
    1:     {
    1:       // Adjusted so that the caret can't get confused when content changes
    1:       nsIFrame* blockFrame = AdjustFrameForSelectionStyles(this);
20200:       PRInt32 thisLine = nsFrame::GetLineNumber(blockFrame, aPos->mScrollViewStop, &blockFrame);
    1:       if (thisLine < 0)
    1:         return NS_ERROR_FAILURE;
21112:       nsAutoLineIterator it = blockFrame->GetLineIterator();
21112:       NS_ASSERTION(it, "GetLineNumber() succeeded but no block frame?");
    1: 
    1:       PRInt32 lineFrameCount;
    1:       nsIFrame *firstFrame;
    1:       nsRect usedRect;
    1:       PRUint32 lineFlags;
    1:       nsIFrame* baseFrame = nsnull;
    1:       PRBool endOfLine = (eSelectEndLine == aPos->mAmount);
    1:       
    1: #ifdef IBMBIDI
  238:       if (aPos->mVisual && PresContext()->BidiEnabled()) {
21112:         PRBool lineIsRTL = it->GetDirection();
    1:         PRBool isReordered;
    1:         nsIFrame *lastFrame;
    1:         result = it->CheckLineOrder(thisLine, &isReordered, &firstFrame, &lastFrame);
    1:         baseFrame = endOfLine ? lastFrame : firstFrame;
 5419:         if (baseFrame) {
    1:           nsBidiLevel embeddingLevel = nsBidiPresUtils::GetFrameEmbeddingLevel(baseFrame);
    1:           // If the direction of the frame on the edge is opposite to that of the line,
    1:           // we'll need to drill down to its opposite end, so reverse endOfLine.
    1:           if ((embeddingLevel & 1) == !lineIsRTL)
    1:             endOfLine = !endOfLine;
 5419:         }
    1:       } else
    1: #endif
    1:       {
    1:         it->GetLine(thisLine, &firstFrame, &lineFrameCount, usedRect, &lineFlags);
    1: 
    1:         nsIFrame* frame = firstFrame;
    1:         for (PRInt32 count = lineFrameCount; count;
    1:              --count, frame = frame->GetNextSibling()) {
    1:           if (!frame->IsGeneratedContentFrame()) {
    1:             baseFrame = frame;
    1:             if (!endOfLine)
    1:               break;
    1:           }
    1:         }
    1:       }
    1:       if (!baseFrame)
    1:         return NS_ERROR_FAILURE;
    1:       FrameTarget targetFrame = DrillDownToSelectionFrame(baseFrame,
    1:                                                           endOfLine);
    1:       FrameContentRange range = GetRangeForFrame(targetFrame.frame);
    1:       aPos->mResultContent = range.content;
    1:       aPos->mContentOffset = endOfLine ? range.end : range.start;
    1:       aPos->mResultFrame = targetFrame.frame;
    1:       aPos->mAttachForward = (aPos->mContentOffset == range.start);
    1:       if (!range.content)
    1:         return NS_ERROR_FAILURE;
    1:       return NS_OK;
    1:     }
    1: 
    1:     default: 
    1:     {
    1:       NS_ASSERTION(PR_FALSE, "Invalid amount");
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsFrame::PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset)
    1: {
    1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
    1:   // Sure, we can stop right here.
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsFrame::PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset)
    1: {
    1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
    1:   PRInt32 startOffset = *aOffset;
    1:   // A negative offset means "end of frame", which in our case means offset 1.
    1:   if (startOffset < 0)
    1:     startOffset = 1;
    1:   if (aForward == (startOffset == 0)) {
    1:     // We're before the frame and moving forward, or after it and moving backwards:
    1:     // skip to the other side and we're done.
    1:     *aOffset = 1 - startOffset;
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsFrame::PeekOffsetWord(PRBool aForward, PRBool aWordSelectEatSpace, PRBool aIsKeyboardSelect,
 5453:                         PRInt32* aOffset, PeekWordState* aState)
    1: {
    1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
    1:   PRInt32 startOffset = *aOffset;
 7679:   // This isn't text, so truncate the context
 7679:   aState->mContext.Truncate();
    1:   if (startOffset < 0)
    1:     startOffset = 1;
    1:   if (aForward == (startOffset == 0)) {
    1:     // We're before the frame and moving forward, or after it and moving backwards.
    1:     // If we're looking for non-whitespace, we found it (without skipping this frame).
 5453:     if (!aState->mAtStart) {
 5453:       if (aState->mLastCharWasPunctuation) {
 5453:         // We're not punctuation, so this is a punctuation boundary.
12505:         if (BreakWordBetweenPunctuation(aState, aForward, PR_FALSE, PR_FALSE, aIsKeyboardSelect))
    1:           return PR_TRUE;
 5453:       } else {
 5453:         // This is not a punctuation boundary.
 5453:         if (aWordSelectEatSpace && aState->mSawBeforeType)
 5453:           return PR_TRUE;
 5453:       }
 5453:     }
    1:     // Otherwise skip to the other side and note that we encountered non-whitespace.
    1:     *aOffset = 1 - startOffset;
12505:     aState->Update(PR_FALSE, // not punctuation
12505:                    PR_FALSE  // not whitespace
12505:                    );
    1:     if (!aWordSelectEatSpace)
 5453:       aState->SetSawBeforeType();
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
 5453: PRBool
12505: nsFrame::BreakWordBetweenPunctuation(const PeekWordState* aState,
12505:                                      PRBool aForward,
12505:                                      PRBool aPunctAfter, PRBool aWhitespaceAfter,
12505:                                      PRBool aIsKeyboardSelect)
12505: {
12505:   NS_ASSERTION(aPunctAfter != aState->mLastCharWasPunctuation,
12505:                "Call this only at punctuation boundaries");
12505:   if (aState->mLastCharWasWhitespace) {
12505:     // We always stop between whitespace and punctuation
12505:     return PR_TRUE;
12505:   }
 5453:   if (!nsContentUtils::GetBoolPref("layout.word_select.stop_at_punctuation")) {
12505:     // When this pref is false, we never stop at a punctuation boundary unless
12505:     // it's after whitespace
 5453:     return PR_FALSE;
 5453:   }
 5453:   if (!aIsKeyboardSelect) {
 5453:     // mouse caret movement (e.g. word selection) always stops at every punctuation boundary
 5453:     return PR_TRUE;
 5453:   }
12505:   PRBool afterPunct = aForward ? aState->mLastCharWasPunctuation : aPunctAfter;
12505:   if (!afterPunct) {
12505:     // keyboard caret movement only stops after punctuation (in content order)
12505:     return PR_FALSE;
12505:   }
12505:   // Stop only if we've seen some non-punctuation since the last whitespace;
12505:   // don't stop after punctuation that follows whitespace.
12505:   return aState->mSeenNonPunctuationSinceWhitespace;
 5453: }
 5453: 
    1: NS_IMETHODIMP
    1: nsFrame::CheckVisibility(nsPresContext* , PRInt32 , PRInt32 , PRBool , PRBool *, PRBool *)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: PRInt32
20200: nsFrame::GetLineNumber(nsIFrame *aFrame, PRBool aLockScroll, nsIFrame** aContainingBlock)
    1: {
    1:   NS_ASSERTION(aFrame, "null aFrame");
  238:   nsFrameManager* frameManager = aFrame->PresContext()->FrameManager();
    1:   nsIFrame *blockFrame = aFrame;
    1:   nsIFrame *thisBlock;
21112:   nsAutoLineIterator it;
    1:   nsresult result = NS_ERROR_FAILURE;
    1:   while (NS_FAILED(result) && blockFrame)
    1:   {
    1:     thisBlock = blockFrame;
    1:     if (thisBlock->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
    1:       //if we are searching for a frame that is not in flow we will not find it. 
    1:       //we must instead look for its placeholder
 6521:       if (thisBlock->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
 6521:         // abspos continuations don't have placeholders, get the fif
 6521:         thisBlock = thisBlock->GetFirstInFlow();
 6521:       }
    1:       thisBlock = frameManager->GetPlaceholderFrameFor(thisBlock);
    1:       if (!thisBlock)
    1:         return -1;
    1:     }  
    1:     blockFrame = thisBlock->GetParent();
    1:     result = NS_OK;
    1:     if (blockFrame) {
20200:       if (aLockScroll && blockFrame->GetType() == nsGkAtoms::scrollFrame)
20200:         return -1;
21112:       it = blockFrame->GetLineIterator();
21112:       if (!it)
21112:         result = NS_ERROR_FAILURE;
    1:     }
    1:   }
    1:   if (!blockFrame || !it)
    1:     return -1;
    1: 
    1:   if (aContainingBlock)
    1:     *aContainingBlock = blockFrame;
21112:   return it->FindLineContaining(thisBlock);
    1: }
    1: 
    1: nsresult
    1: nsIFrame::GetFrameFromDirection(nsDirection aDirection, PRBool aVisual,
    1:                                 PRBool aJumpLines, PRBool aScrollViewStop, 
    1:                                 nsIFrame** aOutFrame, PRInt32* aOutOffset, PRBool* aOutJumpedLine)
    1: {
21112:   nsresult result;
21112: 
    1:   if (!aOutFrame || !aOutOffset || !aOutJumpedLine)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
  238:   nsPresContext* presContext = PresContext();
    1:   *aOutFrame = nsnull;
    1:   *aOutOffset = 0;
    1:   *aOutJumpedLine = PR_FALSE;
    1: 
    1:   // Find the prev/next selectable frame
    1:   PRBool selectable = PR_FALSE;
    1:   nsIFrame *traversedFrame = this;
    1:   while (!selectable) {
    1:     nsIFrame *blockFrame;
    1:     
20200:     PRInt32 thisLine = nsFrame::GetLineNumber(traversedFrame, aScrollViewStop, &blockFrame);
    1:     if (thisLine < 0)
    1:       return NS_ERROR_FAILURE;
21112: 
21112:     nsAutoLineIterator it = blockFrame->GetLineIterator();
21112:     NS_ASSERTION(it, "GetLineNumber() succeeded but no block frame?");
    1: 
    1:     PRBool atLineEdge;
    1:     nsIFrame *firstFrame;
    1:     nsIFrame *lastFrame;
    1: #ifdef IBMBIDI
    1:     if (aVisual && presContext->BidiEnabled()) {
21112:       PRBool lineIsRTL = it->GetDirection();
    1:       PRBool isReordered;
    1:       result = it->CheckLineOrder(thisLine, &isReordered, &firstFrame, &lastFrame);
    1:       nsIFrame** framePtr = aDirection == eDirPrevious ? &firstFrame : &lastFrame;
    1:       if (*framePtr) {
    1:         nsBidiLevel embeddingLevel = nsBidiPresUtils::GetFrameEmbeddingLevel(*framePtr);
19264:         if ((((embeddingLevel & 1) && lineIsRTL) || (!(embeddingLevel & 1) && !lineIsRTL)) ==
    1:             (aDirection == eDirPrevious)) {
    1:           nsFrame::GetFirstLeaf(presContext, framePtr);
    1:         } else {
    1:           nsFrame::GetLastLeaf(presContext, framePtr);
    1:         }
    1:         atLineEdge = *framePtr == traversedFrame;
    1:       } else {
    1:         atLineEdge = PR_TRUE;
    1:       }
    1:     } else
    1: #endif
    1:     {
    1:       nsRect  nonUsedRect;
    1:       PRInt32 lineFrameCount;
    1:       PRUint32 lineFlags;
    1:       result = it->GetLine(thisLine, &firstFrame, &lineFrameCount,nonUsedRect,
    1:                            &lineFlags);
    1:       if (NS_FAILED(result))
    1:         return result;
    1: 
    1:       if (aDirection == eDirPrevious) {
    1:         nsFrame::GetFirstLeaf(presContext, &firstFrame);
    1:         atLineEdge = firstFrame == traversedFrame;
    1:       } else { // eDirNext
    1:         lastFrame = firstFrame;
    1:         for (;lineFrameCount > 1;lineFrameCount --){
    1:           result = it->GetNextSiblingOnLine(lastFrame, thisLine);
    1:           if (NS_FAILED(result) || !lastFrame){
31561:             NS_ERROR("should not be reached nsFrame\n");
    1:             return NS_ERROR_FAILURE;
    1:           }
    1:         }
    1:         nsFrame::GetLastLeaf(presContext, &lastFrame);
    1:         atLineEdge = lastFrame == traversedFrame;
    1:       }
    1:     }
    1: 
    1:     if (atLineEdge) {
    1:       *aOutJumpedLine = PR_TRUE;
    1:       if (!aJumpLines)
    1:         return NS_ERROR_FAILURE; //we are done. cannot jump lines
    1:     }
    1: 
21105:     nsCOMPtr<nsIFrameEnumerator> frameTraversal;
    1:     result = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
    1:                                   presContext, traversedFrame,
    1:                                   eLeaf,
    1:                                   aVisual && presContext->BidiEnabled(),
    1:                                   aScrollViewStop,
    1:                                   PR_TRUE  // aFollowOOFs
    1:                                   );
    1:     if (NS_FAILED(result))
    1:       return result;
    1: 
    1:     if (aDirection == eDirNext)
21105:       frameTraversal->Next();
    1:     else
21105:       frameTraversal->Prev();
21105: 
21105:     traversedFrame = frameTraversal->CurrentItem();
21105:     if (!traversedFrame)
21105:       return NS_ERROR_FAILURE;
    1:     traversedFrame->IsSelectable(&selectable, nsnull);
    1:   } // while (!selectable)
    1: 
    1:   *aOutOffset = (aDirection == eDirNext) ? 0 : -1;
    1: 
    1: #ifdef IBMBIDI
    1:   if (aVisual) {
    1:     PRUint8 newLevel = NS_GET_EMBEDDING_LEVEL(traversedFrame);
    1:     PRUint8 newBaseLevel = NS_GET_BASE_LEVEL(traversedFrame);
    1:     if ((newLevel & 1) != (newBaseLevel & 1)) // The new frame is reverse-direction, go to the other end
    1:       *aOutOffset = -1 - *aOutOffset;
    1:   }
    1: #endif
    1:   *aOutFrame = traversedFrame;
    1:   return NS_OK;
    1: }
    1: 
    1: nsIView* nsIFrame::GetClosestView(nsPoint* aOffset) const
    1: {
    1:   nsPoint offset(0,0);
    1:   for (const nsIFrame *f = this; f; f = f->GetParent()) {
    1:     if (f->HasView()) {
    1:       if (aOffset)
    1:         *aOffset = offset;
    1:       return f->GetView();
    1:     }
    1:     offset += f->GetPosition();
    1:   }
    1: 
    1:   NS_NOTREACHED("No view on any parent?  How did that happen?");
    1:   return nsnull;
    1: }
    1: 
    1: 
    1: /* virtual */ void
    1: nsFrame::ChildIsDirty(nsIFrame* aChild)
    1: {
    1:   NS_NOTREACHED("should never be called on a frame that doesn't inherit from "
    1:                 "nsContainerFrame");
    1: }
    1: 
    1: 
    1: #ifdef ACCESSIBILITY
    1: NS_IMETHODIMP
    1: nsFrame::GetAccessible(nsIAccessible** aAccessible)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: #endif
    1: 
11909: /** Create or retrieve the previously stored overflow area, if the frame does 
11909:  * not overflow and no creation is required return nsnull.
11909:  * @param aCreateIfNecessary  create a new nsRect for the overflow area
11909:  * @return pointer to the overflow area rectangle 
11909:  */
    1: nsRect*
    1: nsIFrame::GetOverflowAreaProperty(PRBool aCreateIfNecessary) 
    1: {
26950:   if (!((mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) ||
26950:         aCreateIfNecessary)) {
    1:     return nsnull;
    1:   }
    1: 
  238:   nsPropertyTable *propTable = PresContext()->PropertyTable();
    1:   void *value = propTable->GetProperty(this,
    1:                                        nsGkAtoms::overflowAreaProperty);
    1: 
    1:   if (value) {
    1:     return (nsRect*)value;  // the property already exists
    1:   } else if (aCreateIfNecessary) {
    1:     // The property isn't set yet, so allocate a new rect, set the property,
    1:     // and return the newly allocated rect
    1:     nsRect*  overflow = new nsRect(0, 0, 0, 0);
    1:     propTable->SetProperty(this, nsGkAtoms::overflowAreaProperty,
    1:                            overflow, DestroyRectFunc, nsnull);
    1:     return overflow;
    1:   }
    1: 
26950:   NS_NOTREACHED("Frame abuses GetOverflowAreaProperty()");
    1:   return nsnull;
    1: }
    1: 
26950: /** Set the overflowArea rect, storing it as deltas or a separate rect
26950:  * depending on its size in relation to the primary frame rect.
26950:  */
26950: void
26950: nsIFrame::SetOverflowRect(const nsRect& aRect)
26950: {
26950:   PRUint32 l = -aRect.x, // left edge: positive delta is leftwards
26950:            t = -aRect.y, // top: positive is upwards
26950:            r = aRect.XMost() - mRect.width, // right: positive is rightwards
26950:            b = aRect.YMost() - mRect.height; // bottom: positive is downwards
26950:   if (l <= NS_FRAME_OVERFLOW_DELTA_MAX &&
26950:       t <= NS_FRAME_OVERFLOW_DELTA_MAX &&
26950:       r <= NS_FRAME_OVERFLOW_DELTA_MAX &&
26950:       b <= NS_FRAME_OVERFLOW_DELTA_MAX &&
26950:       (l | t | r | b) != 0) {
26950:     // It's a "small" overflow area so we store the deltas for each edge
26950:     // directly in the frame, rather than allocating a separate rect.
26950:     // Note that we do NOT store in this way if *all* the deltas are zero,
26950:     // as that would be indistinguishable from the complete absence of
26950:     // an overflow rect.
26950:     DeleteProperty(nsGkAtoms::overflowAreaProperty);
26950:     mOverflow.mDeltas.mLeft   = l;
26950:     mOverflow.mDeltas.mTop    = t;
26950:     mOverflow.mDeltas.mRight  = r;
26950:     mOverflow.mDeltas.mBottom = b;
26950:   } else {
26950:     // it's a large overflow area that we need to store as a property
26950:     mOverflow.mType = NS_FRAME_OVERFLOW_LARGE;
26950:     nsRect* overflowArea = GetOverflowAreaProperty(PR_TRUE); 
26950:     NS_ASSERTION(overflowArea, "should have created rect");
26950:     *overflowArea = aRect;
26950:   }
26950: }
26950: 
13951: inline PRBool
13951: IsInlineFrame(nsIFrame *aFrame)
13951: {
13951:   nsIAtom *type = aFrame->GetType();
13951:   return type == nsGkAtoms::inlineFrame ||
13951:          type == nsGkAtoms::positionedInlineFrame;
13951: }
13951: 
15700: nsRect
15700: nsIFrame::GetAdditionalOverflow(const nsRect& aOverflowArea,
20711:                                 const nsSize& aNewSize,
20711:                                 PRBool* aHasOutlineOrEffects)
20711: {
19125:   nsRect overflowRect =
20711:     ComputeOutlineAndEffectsRect(this, aHasOutlineOrEffects,
19125:                                  aOverflowArea, PR_TRUE);
15700: 
15700:   // Absolute position clipping
15700:   PRBool hasAbsPosClip;
15700:   nsRect absPosClipRect;
15700:   hasAbsPosClip = GetAbsPosClipRect(GetStyleDisplay(), &absPosClipRect, aNewSize);
15700:   if (hasAbsPosClip) {
15700:     overflowRect.IntersectRect(overflowRect, absPosClipRect);
15700:   }
15700: 
15700:   return overflowRect;
15700: }
15700: 
    1: void 
    1: nsIFrame::FinishAndStoreOverflow(nsRect* aOverflowArea, nsSize aNewSize)
    1: {
    1:   // This is now called FinishAndStoreOverflow() instead of 
    1:   // StoreOverflow() because frame-generic ways of adding overflow
    1:   // can happen here, e.g. CSS2 outline and native theme.
    1:   NS_ASSERTION(aNewSize.width == 0 || aNewSize.height == 0 ||
    1:                aOverflowArea->Contains(nsRect(nsPoint(0, 0), aNewSize)),
    1:                "Computed overflow area must contain frame bounds");
    1: 
    1:   const nsStyleDisplay *disp = GetStyleDisplay();
 5894:   if (!IsBoxWrapped() && IsThemed(disp)) {
13812:     nsRect r(nsPoint(0, 0), aNewSize);
  238:     nsPresContext *presContext = PresContext();
    1:     if (presContext->GetTheme()->
    1:           GetWidgetOverflow(presContext->DeviceContext(), this,
    1:                             disp->mAppearance, &r)) {
    1:       aOverflowArea->UnionRect(*aOverflowArea, r);
    1:     }
    1:   }
    1:   
12354:   // Overflow area must always include the frame's top-left and bottom-right,
12354:   // even if the frame rect is empty.
13951:   // Pending a real fix for bug 426879, don't do this for inline frames
13951:   // with zero width.
13951:   if (aNewSize.width != 0 || !IsInlineFrame(this))
12354:     aOverflowArea->UnionRectIncludeEmpty(*aOverflowArea,
12354:                                          nsRect(nsPoint(0, 0), aNewSize));
12354: 
    1:   PRBool geometricOverflow =
    1:     aOverflowArea->x < 0 || aOverflowArea->y < 0 ||
    1:     aOverflowArea->XMost() > aNewSize.width || aOverflowArea->YMost() > aNewSize.height;
    1:   // Clear geometric overflow area if we clip our children
  134:   NS_ASSERTION((disp->mOverflowY == NS_STYLE_OVERFLOW_CLIP) ==
  134:                (disp->mOverflowX == NS_STYLE_OVERFLOW_CLIP),
    1:                "If one overflow is clip, the other should be too");
    1:   if (geometricOverflow &&
  134:       disp->mOverflowX == NS_STYLE_OVERFLOW_CLIP) {
    1:     *aOverflowArea = nsRect(nsPoint(0, 0), aNewSize);
    1:     geometricOverflow = PR_FALSE;
    1:   }
    1: 
20711:   PRBool hasOutlineOrEffects;
20711:   *aOverflowArea = GetAdditionalOverflow(*aOverflowArea, aNewSize,
20711:       &hasOutlineOrEffects);
19284: 
19284:   /* If we're transformed, transform the overflow rect by the current transformation. */
19948:   if ((mState & NS_FRAME_MAY_BE_TRANSFORMED_OR_HAVE_RENDERING_OBSERVERS) && 
19284:       GetStyleDisplay()->HasTransform()) {
19284:     // Save overflow area before the transform
19284:     SetRectProperty(this, nsGkAtoms::preTransformBBoxProperty, *aOverflowArea);
19284: 
19284:     /* Since our size might not actually have been computed yet, we need to make sure that we use the
19284:      * correct dimensions by overriding the stored bounding rectangle with the value the caller has
19284:      * ensured us we'll use.
19284:      */
19284:     nsRect newBounds(nsPoint(0, 0), aNewSize);
19284:     *aOverflowArea = nsDisplayTransform::TransformRect(*aOverflowArea, this, nsPoint(0, 0), &newBounds);
19284:   }
19284: 
20711:   PRBool overflowChanged;
19284:   if (*aOverflowArea != nsRect(nsPoint(0, 0), aNewSize)) {
26950:     overflowChanged = *aOverflowArea != GetOverflowRect();
26950:     SetOverflowRect(*aOverflowArea);
    1:   }
    1:   else {
26950:     if (HasOverflowRect()) {
    1:       // remove the previously stored overflow area 
26950:       ClearOverflowRect();
20711:       overflowChanged = PR_TRUE;
20711:     } else {
20711:       overflowChanged = PR_FALSE;
20711:     }
20711:   }
20711: 
20711:   if (overflowChanged && hasOutlineOrEffects) {
20711:     // When there's an outline or box-shadow or SVG effects, changes to
20711:     // those styles might require repainting of the old and new overflow
20711:     // areas. Repainting of the old overflow area is handled in
20711:     // nsCSSFrameConstructor::DoApplyRenderingChangeToTree in response
20711:     // to nsChangeHint_RepaintFrame. Since the new overflow area is not
20711:     // known at that time, we have to handle it here.
20711:     // If the overflow area hasn't changed, then we don't have to do
20711:     // anything here since repainting the old overflow area was enough.
20711:     // If there is no outline or other effects now, then we don't have
20711:     // to do anything here since removing those styles can't require
20711:     // repainting of areas that weren't in the old overflow area.
20711:     Invalidate(*aOverflowArea);
    1:   }
    1: }
    1: 
    1: void
    1: nsFrame::ConsiderChildOverflow(nsRect&   aOverflowArea,
    1:                                nsIFrame* aChildFrame)
    1: {
    1:   const nsStyleDisplay* disp = GetStyleDisplay();
    1:   // check here also for hidden as table frames (table, tr and td) currently 
    1:   // don't wrap their content into a scrollable frame if overflow is specified
    1:   if (!disp->IsTableClip()) {
11909:     nsRect childOverflow = aChildFrame->GetOverflowRect();
    1:     childOverflow.MoveBy(aChildFrame->GetPosition());
    1:     aOverflowArea.UnionRect(aOverflowArea, childOverflow);
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsFrame::GetParentStyleContextFrame(nsPresContext* aPresContext,
    1:                                     nsIFrame**      aProviderFrame,
    1:                                     PRBool*         aIsChild)
    1: {
    1:   return DoGetParentStyleContextFrame(aPresContext, aProviderFrame, aIsChild);
    1: }
    1: 
    1: 
    1: /**
34459:  * This function takes a "special" frame and _if_ that frame is an anonymous
34459:  * block created by an ib split it returns the block's preceding inline.  This
34459:  * is needed because the split inline's style context is the parent of the
34459:  * anonymous block's style context.
    1:  *
34459:  * If aFrame is not ananonymous block, null is returned.
    1:  */
34459: static nsIFrame*
34459: GetIBSpecialSiblingForAnonymousBlock(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "Must have a non-null frame!");
    1:   NS_ASSERTION(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL,
    1:                "GetIBSpecialSibling should not be called on a non-special frame");
    1: 
34387:   nsIAtom* type = aFrame->GetStyleContext()->GetPseudo();
19125:   if (type != nsCSSAnonBoxes::mozAnonymousBlock &&
19125:       type != nsCSSAnonBoxes::mozAnonymousPositionedBlock) {
34459:     // it's not an anonymous block
34459:     return nsnull;
34459:   }
34459: 
34459:   // Find the first continuation of the frame.  (Ugh.  This ends up
    1:   // being O(N^2) when it is called O(N) times.)
34459:   aFrame = aFrame->GetFirstContinuation();
    1: 
    1:   /*
    1:    * Now look up the nsGkAtoms::IBSplitSpecialPrevSibling
34459:    * property.
    1:    */
34459:   nsIFrame *specialSibling =
34459:     static_cast<nsIFrame*>(aFrame->GetProperty(nsGkAtoms::IBSplitSpecialPrevSibling));
34459:   NS_ASSERTION(specialSibling, "Broken frame tree?");
34459:   return specialSibling;
    1: }
    1: 
    1: /**
    1:  * Get the parent, corrected for the mangled frame tree resulting from
    1:  * having a block within an inline.  The result only differs from the
    1:  * result of |GetParent| when |GetParent| returns an anonymous block
    1:  * that was created for an element that was 'display: inline' because
    1:  * that element contained a block.
    1:  *
    1:  * Also skip anonymous scrolled-content parents; inherit directly from the
    1:  * outer scroll frame.
    1:  */
    1: static nsresult
    1: GetCorrectedParent(nsPresContext* aPresContext, nsIFrame* aFrame,
    1:                    nsIFrame** aSpecialParent)
    1: {
    1:   nsIFrame *parent = aFrame->GetParent();
  549:   if (!parent) {
  549:     *aSpecialParent = nsnull;
  549:   } else {
34387:     nsIAtom* pseudo = aFrame->GetStyleContext()->GetPseudo();
  553:     // Outer tables are always anon boxes; if we're in here for an outer
  553:     // table, that actually means its the _inner_ table that wants to
  553:     // know its parent.  So get the pseudo of the inner in that case.
  553:     if (pseudo == nsCSSAnonBoxes::tableOuter) {
  553:       pseudo =
34387:         aFrame->GetFirstChild(nsnull)->GetStyleContext()->GetPseudo();
  553:     }
  553:     *aSpecialParent = nsFrame::CorrectStyleParentFrame(parent, pseudo);
  549:   }
  549: 
  549:   return NS_OK;
  549: }
  549: 
  549: /* static */
  549: nsIFrame*
  549: nsFrame::CorrectStyleParentFrame(nsIFrame* aProspectiveParent,
  549:                                  nsIAtom* aChildPseudo)
  549: {
  549:   NS_PRECONDITION(aProspectiveParent, "Must have a prospective parent");
  549: 
  549:   // Anon boxes are parented to their actual parent already, except
  549:   // for non-elements.  Those should not be treated as an anon box.
  549:   if (aChildPseudo && aChildPseudo != nsCSSAnonBoxes::mozNonElement &&
  549:       nsCSSAnonBoxes::IsAnonBox(aChildPseudo)) {
  549:     NS_ASSERTION(aChildPseudo != nsCSSAnonBoxes::mozAnonymousBlock &&
  549:                  aChildPseudo != nsCSSAnonBoxes::mozAnonymousPositionedBlock,
  549:                  "Should have dealt with kids that have NS_FRAME_IS_SPECIAL "
  549:                  "elsewhere");
  549:     return aProspectiveParent;
  549:   }
  549: 
 7046:   // Otherwise, walk up out of all anon boxes.  For placeholder frames, walk out
 7046:   // of all pseudo-elements as well.  Otherwise ReParentStyleContext could cause
 3599:   // style data to be out of sync with the frame tree.
  549:   nsIFrame* parent = aProspectiveParent;
  549:   do {
  549:     if (parent->GetStateBits() & NS_FRAME_IS_SPECIAL) {
34459:       nsIFrame* sibling = GetIBSpecialSiblingForAnonymousBlock(parent);
  549: 
  549:       if (sibling) {
34459:         // |parent| was a block in an {ib} split; use the inline as
  549:         // |the style parent.
  549:         parent = sibling;
  549:       }
  549:     }
  549:       
34387:     nsIAtom* parentPseudo = parent->GetStyleContext()->GetPseudo();
 3599:     if (!parentPseudo ||
 3599:         (!nsCSSAnonBoxes::IsAnonBox(parentPseudo) &&
 3599:          // nsPlaceholderFrame pases in nsGkAtoms::placeholderFrame for
 3599:          // aChildPseudo (even though that's not a valid pseudo-type) just to
 3599:          // trigger this behavior of walking up to the nearest non-pseudo
 3599:          // ancestor.
 3599:          aChildPseudo != nsGkAtoms::placeholderFrame)) {
  549:       return parent;
  549:     }
  549: 
    1:     parent = parent->GetParent();
  549:   } while (parent);
  549: 
34387:   if (aProspectiveParent->GetStyleContext()->GetPseudo() ==
18953:       nsCSSAnonBoxes::viewportScroll) {
18953:     // aProspectiveParent is the scrollframe for a viewport
18953:     // and the kids are the anonymous scrollbars
18953:     return aProspectiveParent;
18953:   }
18953: 
18953:   // We can get here if the root element is absolutely positioned.
18953:   // We can't test for this very accurately, but it can only happen
18953:   // when the prospective parent is a canvas frame.
18953:   NS_ASSERTION(aProspectiveParent->GetType() == nsGkAtoms::canvasFrame,
18888:                "Should have found a parent before this");
18953:   return nsnull;
18885: }
18885: 
    1: nsresult
    1: nsFrame::DoGetParentStyleContextFrame(nsPresContext* aPresContext,
    1:                                       nsIFrame**      aProviderFrame,
    1:                                       PRBool*         aIsChild)
    1: {
    1:   *aIsChild = PR_FALSE;
    1:   *aProviderFrame = nsnull;
    1:   if (mContent && !mContent->GetParent() &&
34387:       !GetStyleContext()->GetPseudo()) {
    1:     // we're a frame for the root.  We have no style context parent.
    1:     return NS_OK;
    1:   }
    1:   
    1:   if (!(mState & NS_FRAME_OUT_OF_FLOW)) {
    1:     /*
34459:      * If this frame is an anonymous block created when an inline with a block
34459:      * inside it got split, then the parent style context is on its preceding
34459:      * inline. We can get to it using GetIBSpecialSiblingForAnonymousBlock.
    1:      */
    1:     if (mState & NS_FRAME_IS_SPECIAL) {
34459:       *aProviderFrame = GetIBSpecialSiblingForAnonymousBlock(this);
  549: 
  549:       if (*aProviderFrame) {
    1:         return NS_OK;
    1:       }
  549:     }
    1: 
    1:     // If this frame is one of the blocks that split an inline, we must
    1:     // return the "special" inline parent, i.e., the parent that this
    1:     // frame would have if we didn't mangle the frame structure.
    1:     return GetCorrectedParent(aPresContext, this, aProviderFrame);
    1:   }
    1: 
    1:   // For out-of-flow frames, we must resolve underneath the
    1:   // placeholder's parent.
 6521:   nsIFrame* oofFrame = this;
32108:   if ((oofFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
32108:       GetPrevInFlow()) {
32108:     // Out of flows that are continuations do not
 6521:     // have placeholders. Use their first-in-flow's placeholder.
 6521:     oofFrame = oofFrame->GetFirstInFlow();
 6521:   }
    1:   nsIFrame *placeholder =
 6521:     aPresContext->FrameManager()->GetPlaceholderFrameFor(oofFrame);
    1:   if (!placeholder) {
    1:     NS_NOTREACHED("no placeholder frame for out-of-flow frame");
    1:     GetCorrectedParent(aPresContext, this, aProviderFrame);
    1:     return NS_ERROR_FAILURE;
    1:   }
 3233:   return static_cast<nsFrame*>(placeholder)->
    1:     GetParentStyleContextFrame(aPresContext, aProviderFrame, aIsChild);
    1: }
    1: 
    1: //-----------------------------------------------------------------------------------
    1: 
    1: 
    1: 
    1: 
    1: void
    1: nsFrame::GetLastLeaf(nsPresContext* aPresContext, nsIFrame **aFrame)
    1: {
    1:   if (!aFrame || !*aFrame)
    1:     return;
    1:   nsIFrame *child = *aFrame;
    1:   //if we are a block frame then go for the last line of 'this'
    1:   while (1){
    1:     child = child->GetFirstChild(nsnull);
    1:     if (!child)
    1:       return;//nothing to do
    1:     nsIFrame* siblingFrame;
    1:     nsIContent* content;
    1:     //ignore anonymous elements, e.g. mozTableAdd* mozTableRemove*
    1:     //see bug 278197 comment #12 #13 for details
    1:     while ((siblingFrame = child->GetNextSibling()) &&
    1:            (content = siblingFrame->GetContent()) &&
16126:            !content->IsRootOfNativeAnonymousSubtree())
    1:       child = siblingFrame;
    1:     *aFrame = child;
    1:   }
    1: }
    1: 
    1: void
    1: nsFrame::GetFirstLeaf(nsPresContext* aPresContext, nsIFrame **aFrame)
    1: {
    1:   if (!aFrame || !*aFrame)
    1:     return;
    1:   nsIFrame *child = *aFrame;
    1:   while (1){
    1:     child = child->GetFirstChild(nsnull);
    1:     if (!child)
    1:       return;//nothing to do
    1:     *aFrame = child;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsIFrame::SetProperty(nsIAtom*           aPropName,
    1:                       void*              aPropValue,
    1:                       NSPropertyDtorFunc aPropDtorFunc,
    1:                       void*              aDtorData)
    1: {
  238:   return PresContext()->PropertyTable()->
    1:     SetProperty(this, aPropName, aPropValue, aPropDtorFunc, aDtorData);
    1: }
    1: 
    1: void* 
    1: nsIFrame::GetProperty(nsIAtom* aPropName, nsresult* aStatus) const
    1: {
  238:   return PresContext()->PropertyTable()->GetProperty(this, aPropName,
    1:                                                         aStatus);
    1: }
    1: 
    1: /* virtual */ void* 
    1: nsIFrame::GetPropertyExternal(nsIAtom* aPropName, nsresult* aStatus) const
    1: {
    1:   return GetProperty(aPropName, aStatus);
    1: }
    1: 
    1: nsresult
    1: nsIFrame::DeleteProperty(nsIAtom* aPropName) const
    1: {
  238:   return PresContext()->PropertyTable()->DeleteProperty(this, aPropName);
    1: }
    1: 
    1: void*
    1: nsIFrame::UnsetProperty(nsIAtom* aPropName, nsresult* aStatus) const
    1: {
  238:   return PresContext()->PropertyTable()->UnsetProperty(this, aPropName,
    1:                                                           aStatus);
    1: }
    1: 
10152: /* virtual */ const void*
    1: nsFrame::GetStyleDataExternal(nsStyleStructID aSID) const
    1: {
    1:   NS_ASSERTION(mStyleContext, "unexpected null pointer");
    1:   return mStyleContext->GetStyleData(aSID);
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsIFrame::IsFocusable(PRInt32 *aTabIndex, PRBool aWithMouse)
    1: {
    1:   PRInt32 tabIndex = -1;
    1:   if (aTabIndex) {
    1:     *aTabIndex = -1; // Default for early return is not focusable
    1:   }
    1:   PRBool isFocusable = PR_FALSE;
    1: 
    1:   if (mContent && mContent->IsNodeOfType(nsINode::eELEMENT) &&
    1:       AreAncestorViewsVisible()) {
    1:     const nsStyleVisibility* vis = GetStyleVisibility();
    1:     if (vis->mVisible != NS_STYLE_VISIBILITY_COLLAPSE &&
    1:         vis->mVisible != NS_STYLE_VISIBILITY_HIDDEN) {
    1:       const nsStyleUserInterface* ui = GetStyleUserInterface();
    1:       if (ui->mUserFocus != NS_STYLE_USER_FOCUS_IGNORE &&
    1:           ui->mUserFocus != NS_STYLE_USER_FOCUS_NONE) {
    1:         // Pass in default tabindex of -1 for nonfocusable and 0 for focusable
    1:         tabIndex = 0;
    1:       }
    1:       isFocusable = mContent->IsFocusable(&tabIndex);
    1:       if (!isFocusable && !aWithMouse &&
    1:           GetType() == nsGkAtoms::scrollFrame &&
33329:           mContent->IsHTML() &&
16126:           !mContent->IsRootOfNativeAnonymousSubtree() &&
16126:           mContent->GetParent() &&
    1:           !mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
    1:         // Elements with scrollable view are focusable with script & tabbable
    1:         // Otherwise you couldn't scroll them with keyboard, which is
    1:         // an accessibility issue (e.g. Section 508 rules)
    1:         // However, we don't make them to be focusable with the mouse,
    1:         // because the extra focus outlines are considered unnecessarily ugly.
    1:         // When clicked on, the selection position within the element 
    1:         // will be enough to make them keyboard scrollable.
23554:         nsIScrollableFrame *scrollFrame = do_QueryFrame(this);
    1:         if (scrollFrame) {
 5628:           nsMargin margin = scrollFrame->GetActualScrollbarSizes();
 5628:           if (margin.top || margin.right || margin.bottom || margin.left) {
    1:             // Scroll bars will be used for overflow
    1:             isFocusable = PR_TRUE;
    1:             tabIndex = 0;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aTabIndex) {
    1:     *aTabIndex = tabIndex;
    1:   }
    1:   return isFocusable;
    1: }
    1: 
    1: /**
    1:  * @return PR_TRUE if this text frame ends with a newline character.  It
    1:  * should return PR_FALSE if this is not a text frame.
    1:  */
    1: PRBool
    1: nsIFrame::HasTerminalNewline() const
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: /* static */
    1: void nsFrame::FillCursorInformationFromStyle(const nsStyleUserInterface* ui,
    1:                                              nsIFrame::Cursor& aCursor)
    1: {
    1:   aCursor.mCursor = ui->mCursor;
    1:   aCursor.mHaveHotspot = PR_FALSE;
    1:   aCursor.mHotspotX = aCursor.mHotspotY = 0.0f;
    1: 
    1:   for (nsCursorImage *item = ui->mCursorArray,
    1:                  *item_end = ui->mCursorArray + ui->mCursorArrayLength;
    1:        item < item_end; ++item) {
    1:     PRUint32 status;
    1:     nsresult rv = item->mImage->GetImageStatus(&status);
32424:     if (NS_SUCCEEDED(rv) && (status & imgIRequest::STATUS_LOAD_COMPLETE)) {
    1:       // This is the one we want
    1:       item->mImage->GetImage(getter_AddRefs(aCursor.mContainer));
    1:       aCursor.mHaveHotspot = item->mHaveHotspot;
    1:       aCursor.mHotspotX = item->mHotspotX;
    1:       aCursor.mHotspotY = item->mHotspotY;
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::RefreshSizeCache(nsBoxLayoutState& aState)
    1: {
  256:   // XXXbz this comment needs some rewriting to make sense in the
  256:   // post-reflow-branch world.
    1:   
    1:   // Ok we need to compute our minimum, preferred, and maximum sizes.
    1:   // 1) Maximum size. This is easy. Its infinite unless it is overloaded by CSS.
    1:   // 2) Preferred size. This is a little harder. This is the size the block would be 
    1:   //      if it were laid out on an infinite canvas. So we can get this by reflowing
    1:   //      the block with and INTRINSIC width and height. We can also do a nice optimization
    1:   //      for incremental reflow. If the reflow is incremental then we can pass a flag to 
    1:   //      have the block compute the preferred width for us! Preferred height can just be
    1:   //      the minimum height;
    1:   // 3) Minimum size. This is a toughy. We can pass the block a flag asking for the max element
    1:   //    size. That would give us the width. Unfortunately you can only ask for a maxElementSize
    1:   //    during an incremental reflow. So on other reflows we will just have to use 0.
    1:   //    The min height on the other hand is fairly easy we need to get the largest
    1:   //    line height. This can be done with the line iterator.
    1: 
    1:   // if we do have a rendering context
    1:   nsresult rv = NS_OK;
    1:   nsIRenderingContext* rendContext = aState.GetRenderingContext();
    1:   if (rendContext) {
    1:     nsPresContext* presContext = aState.PresContext();
    1: 
    1:     // If we don't have any HTML constraints and it's a resize, then nothing in the block
    1:     // could have changed, so no refresh is necessary.
    1:     nsBoxLayoutMetrics* metrics = BoxMetrics();
    1:     if (!DoesNeedRecalc(metrics->mBlockPrefSize))
    1:       return NS_OK;
    1: 
    1:     // get the old rect.
    1:     nsRect oldRect = GetRect();
    1: 
    1:     // the rect we plan to size to.
    1:     nsRect rect(oldRect);
    1: 
    1:     nsMargin bp(0,0,0,0);
    1:     GetBorderAndPadding(bp);
    1: 
    1:     metrics->mBlockPrefSize.width = GetPrefWidth(rendContext) + bp.LeftRight();
    1:     metrics->mBlockMinSize.width = GetMinWidth(rendContext) + bp.LeftRight();
    1: 
    1:     // do the nasty.
    1:     nsHTMLReflowMetrics desiredSize;
    1:     rv = BoxReflow(aState, presContext, desiredSize, rendContext,
    1:                    rect.x, rect.y,
    1:                    metrics->mBlockPrefSize.width, NS_UNCONSTRAINEDSIZE);
    1: 
    1:     nsRect newRect = GetRect();
    1: 
    1:     // make sure we draw any size change
    1:     if (oldRect.width != newRect.width || oldRect.height != newRect.height) {
    1:       newRect.x = 0;
    1:       newRect.y = 0;
    1:       Redraw(aState, &newRect);
    1:     }
    1: 
13001:     metrics->mBlockMinSize.height = 0;
13001:     // ok we need the max ascent of the items on the line. So to do this
13001:     // ask the block for its line iterator. Get the max ascent.
21112:     nsAutoLineIterator lines = GetLineIterator();
13001:     if (lines) 
13001:     {
13001:       metrics->mBlockMinSize.height = 0;
13001:       int count = 0;
13001:       nsIFrame* firstFrame = nsnull;
13001:       PRInt32 framesOnLine;
13001:       nsRect lineBounds;
13001:       PRUint32 lineFlags;
13001: 
13001:       do {
13001:          lines->GetLine(count, &firstFrame, &framesOnLine, lineBounds, &lineFlags);
13001: 
13001:          if (lineBounds.height > metrics->mBlockMinSize.height)
13001:            metrics->mBlockMinSize.height = lineBounds.height;
13001: 
13001:          count++;
13001:       } while(firstFrame);
13001:     } else {
13001:       metrics->mBlockMinSize.height = desiredSize.height;
13001:     }
13001: 
13001:     metrics->mBlockPrefSize.height = metrics->mBlockMinSize.height;
    1: 
    1:     if (desiredSize.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE) {
    1:       if (!nsLayoutUtils::GetFirstLineBaseline(this, &metrics->mBlockAscent))
    1:         metrics->mBlockAscent = GetBaseline();
    1:     } else {
    1:       metrics->mBlockAscent = desiredSize.ascent;
    1:     }
    1: 
    1: #ifdef DEBUG_adaptor
    1:     printf("min=(%d,%d), pref=(%d,%d), ascent=%d\n", metrics->mBlockMinSize.width,
    1:                                                      metrics->mBlockMinSize.height,
    1:                                                      metrics->mBlockPrefSize.width,
    1:                                                      metrics->mBlockPrefSize.height,
    1:                                                      metrics->mBlockAscent);
    1: #endif
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
21112: /* virtual */ nsILineIterator*
21112: nsFrame::GetLineIterator()
21112: {
21112:   return nsnull;
21112: }
21112: 
    1: nsSize
    1: nsFrame::GetPrefSize(nsBoxLayoutState& aState)
    1: {
    1:   nsSize size(0,0);
    1:   DISPLAY_PREF_SIZE(this, size);
    1:   // If the size is cached, and there are no HTML constraints that we might
    1:   // be depending on, then we just return the cached size.
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mPrefSize)) {
    1:     size = metrics->mPrefSize;
    1:     return size;
    1:   }
    1: 
    1:   if (IsCollapsed(aState))
    1:     return size;
    1: 
    1:   // get our size in CSS.
    1:   PRBool completelyRedefined = nsIBox::AddCSSPrefSize(aState, this, size);
    1: 
    1:   // Refresh our caches with new sizes.
    1:   if (!completelyRedefined) {
    1:     RefreshSizeCache(aState);
    1:     size = metrics->mBlockPrefSize;
    1: 
    1:     // notice we don't need to add our borders or padding
    1:     // in. That's because the block did it for us.
    1:     nsIBox::AddCSSPrefSize(aState, this, size);
    1:   }
    1: 
    1:   metrics->mPrefSize = size;
    1:   return size;
    1: }
    1: 
    1: nsSize
    1: nsFrame::GetMinSize(nsBoxLayoutState& aState)
    1: {
    1:   nsSize size(0,0);
    1:   DISPLAY_MIN_SIZE(this, size);
    1:   // Don't use the cache if we have HTMLReflowState constraints --- they might have changed
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mMinSize)) {
    1:     size = metrics->mMinSize;
    1:     return size;
    1:   }
    1: 
    1:   if (IsCollapsed(aState))
    1:     return size;
    1: 
    1:   // get our size in CSS.
    1:   PRBool completelyRedefined = nsIBox::AddCSSMinSize(aState, this, size);
    1: 
    1:   // Refresh our caches with new sizes.
    1:   if (!completelyRedefined) {
    1:     RefreshSizeCache(aState);
    1:     size = metrics->mBlockMinSize;
    1:     nsIBox::AddCSSMinSize(aState, this, size);
    1:   }
    1: 
    1:   metrics->mMinSize = size;
    1:   return size;
    1: }
    1: 
    1: nsSize
    1: nsFrame::GetMaxSize(nsBoxLayoutState& aState)
    1: {
    1:   nsSize size(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
    1:   DISPLAY_MAX_SIZE(this, size);
    1:   // Don't use the cache if we have HTMLReflowState constraints --- they might have changed
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mMaxSize)) {
    1:     size = metrics->mMaxSize;
    1:     return size;
    1:   }
    1: 
    1:   if (IsCollapsed(aState))
    1:     return size;
    1: 
    1:   size = nsBox::GetMaxSize(aState);
    1:   metrics->mMaxSize = size;
    1: 
    1:   return size;
    1: }
    1: 
    1: nscoord
    1: nsFrame::GetFlex(nsBoxLayoutState& aState)
    1: {
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mFlex))
    1:      return metrics->mFlex;
    1: 
    1:   metrics->mFlex = nsBox::GetFlex(aState);
    1: 
    1:   return metrics->mFlex;
    1: }
    1: 
    1: nscoord
    1: nsFrame::GetBoxAscent(nsBoxLayoutState& aState)
    1: {
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mAscent))
    1:     return metrics->mAscent;
    1: 
    1:   if (IsCollapsed(aState)) {
    1:     metrics->mAscent = 0;
    1:   } else {
    1:     // Refresh our caches with new sizes.
    1:     RefreshSizeCache(aState);
    1:     metrics->mAscent = metrics->mBlockAscent;
    1:   }
    1: 
    1:   return metrics->mAscent;
    1: }
    1: 
    1: nsresult
    1: nsFrame::DoLayout(nsBoxLayoutState& aState)
    1: {
    1:   nsRect ourRect(mRect);
    1: 
    1:   nsIRenderingContext* rendContext = aState.GetRenderingContext();
    1:   nsPresContext* presContext = aState.PresContext();
    1:   nsHTMLReflowMetrics desiredSize;
    1:   nsresult rv = NS_OK;
    1:  
    1:   if (rendContext) {
    1: 
    1:     rv = BoxReflow(aState, presContext, desiredSize, rendContext,
    1:                    ourRect.x, ourRect.y, ourRect.width, ourRect.height);
    1: 
    1:     if (IsCollapsed(aState)) {
    1:       SetSize(nsSize(0, 0));
    1:     } else {
    1: 
    1:       // if our child needs to be bigger. This might happend with
    1:       // wrapping text. There is no way to predict its height until we
    1:       // reflow it. Now that we know the height reshuffle upward.
    1:       if (desiredSize.width > ourRect.width ||
    1:           desiredSize.height > ourRect.height) {
    1: 
    1: #ifdef DEBUG_GROW
    1:         DumpBox(stdout);
    1:         printf(" GREW from (%d,%d) -> (%d,%d)\n",
    1:                ourRect.width, ourRect.height,
    1:                desiredSize.width, desiredSize.height);
    1: #endif
    1: 
    1:         if (desiredSize.width > ourRect.width)
    1:           ourRect.width = desiredSize.width;
    1: 
    1:         if (desiredSize.height > ourRect.height)
    1:           ourRect.height = desiredSize.height;
    1:       }
    1: 
    1:       // ensure our size is what we think is should be. Someone could have
    1:       // reset the frame to be smaller or something dumb like that. 
    1:       SetSize(nsSize(ourRect.width, ourRect.height));
    1:     }
    1:   }
    1: 
    1:   SyncLayout(aState);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsFrame::BoxReflow(nsBoxLayoutState&        aState,
    1:                    nsPresContext*           aPresContext,
    1:                    nsHTMLReflowMetrics&     aDesiredSize,
    1:                    nsIRenderingContext*     aRenderingContext,
    1:                    nscoord                  aX,
    1:                    nscoord                  aY,
    1:                    nscoord                  aWidth,
    1:                    nscoord                  aHeight,
    1:                    PRBool                   aMoveFrame)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsBoxToBlockAdaptor");
    1: 
    1: #ifdef DEBUG_REFLOW
    1:   nsAdaptorAddIndents();
    1:   printf("Reflowing: ");
    1:   nsFrame::ListTag(stdout, mFrame);
    1:   printf("\n");
    1:   gIndent2++;
    1: #endif
    1: 
    1:   //printf("width=%d, height=%d\n", aWidth, aHeight);
    1:   /*
    1:   nsIBox* parent;
    1:   GetParentBox(&parent);
    1: 
    1:  // if (parent->GetStateBits() & NS_STATE_CURRENTLY_IN_DEBUG)
    1:   //   printf("In debug\n");
    1:   */
    1: 
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   nsReflowStatus status = NS_FRAME_COMPLETE;
    1: 
    1:   PRBool redrawAfterReflow = PR_FALSE;
    1:   PRBool redrawNow = PR_FALSE;
    1: 
 1158:   PRBool needsReflow = NS_SUBTREE_DIRTY(this);
    1: 
    1:   if (redrawNow)
    1:      Redraw(aState);
    1: 
    1:   // if we don't need a reflow then 
    1:   // lets see if we are already that size. Yes? then don't even reflow. We are done.
    1:   if (!needsReflow) {
    1:       
    1:       if (aWidth != NS_INTRINSICSIZE && aHeight != NS_INTRINSICSIZE) {
    1:       
    1:           // if the new calculated size has a 0 width or a 0 height
    1:           if ((metrics->mLastSize.width == 0 || metrics->mLastSize.height == 0) && (aWidth == 0 || aHeight == 0)) {
    1:                needsReflow = PR_FALSE;
    1:                aDesiredSize.width = aWidth; 
    1:                aDesiredSize.height = aHeight; 
    1:                SetSize(nsSize(aDesiredSize.width, aDesiredSize.height));
    1:           } else {
    1:             aDesiredSize.width = metrics->mLastSize.width;
    1:             aDesiredSize.height = metrics->mLastSize.height;
    1: 
    1:             // remove the margin. The rect of our child does not include it but our calculated size does.
    1:             // don't reflow if we are already the right size
    1:             if (metrics->mLastSize.width == aWidth && metrics->mLastSize.height == aHeight)
    1:                   needsReflow = PR_FALSE;
    1:             else
    1:                   needsReflow = PR_TRUE;
    1:    
    1:           }
    1:       } else {
    1:           // if the width or height are intrinsic alway reflow because
    1:           // we don't know what it should be.
    1:          needsReflow = PR_TRUE;
    1:       }
    1:   }
    1:                              
    1:   // ok now reflow the child into the spacers calculated space
    1:   if (needsReflow) {
    1: 
    1:     aDesiredSize.width = 0;
    1:     aDesiredSize.height = 0;
    1: 
    1:     // create a reflow state to tell our child to flow at the given size.
    1: 
    1:     // Construct a bogus parent reflow state so that there's a usable
    1:     // containing block reflow state.
    1:     nsMargin margin(0,0,0,0);
    1:     GetMargin(margin);
    1: 
    1:     nsSize parentSize(aWidth, aHeight);
    1:     if (parentSize.height != NS_INTRINSICSIZE)
    1:       parentSize.height += margin.TopBottom();
    1:     if (parentSize.width != NS_INTRINSICSIZE)
    1:       parentSize.width += margin.LeftRight();
    1: 
    1:     nsIFrame *parentFrame = GetParent();
    1:     nsFrameState savedState = parentFrame->GetStateBits();
    1:     nsHTMLReflowState parentReflowState(aPresContext, parentFrame,
    1:                                         aRenderingContext,
    1:                                         parentSize);
    1:     parentFrame->RemoveStateBits(0xffffffff);
    1:     parentFrame->AddStateBits(savedState);
    1: 
    1:     // This may not do very much useful, but it's probably worth trying.
    1:     if (parentSize.width != NS_INTRINSICSIZE)
    1:       parentReflowState.SetComputedWidth(parentSize.width);
    1:     if (parentSize.height != NS_INTRINSICSIZE)
 4166:       parentReflowState.SetComputedHeight(parentSize.height);
    1:     parentReflowState.mComputedMargin.SizeTo(0, 0, 0, 0);
    1:     // XXX use box methods
    1:     parentFrame->GetPadding(parentReflowState.mComputedPadding);
    1:     parentFrame->GetBorder(parentReflowState.mComputedBorderPadding);
    1:     parentReflowState.mComputedBorderPadding +=
    1:       parentReflowState.mComputedPadding;
    1: 
    1:     // XXX Is it OK that this reflow state has no parent reflow state?
    1:     // (It used to have a bogus parent, skipping all the boxes).
  256:     nsSize availSize(aWidth, NS_INTRINSICSIZE);
    1:     nsHTMLReflowState reflowState(aPresContext, this, aRenderingContext,
  256:                                   availSize);
    1: 
    1:     // Construct the parent chain manually since constructing it normally
    1:     // messes up dimensions.
    1:     reflowState.parentReflowState = &parentReflowState;
    1:     reflowState.mCBReflowState = &parentReflowState;
14159:     reflowState.mReflowDepth = aState.GetReflowDepth();
    1: 
    1:     // mComputedWidth and mComputedHeight are content-box, not
    1:     // border-box
    1:     if (aWidth != NS_INTRINSICSIZE) {
    1:       nscoord computedWidth =
    1:         aWidth - reflowState.mComputedBorderPadding.LeftRight();
32531:       computedWidth = NS_MAX(computedWidth, 0);
    1:       reflowState.SetComputedWidth(computedWidth);
    1:     }
29122: 
29122:     // Most child frames of box frames (e.g. subdocument or scroll frames)
29122:     // need to be constrained to the provided size and overflow as necessary.
29122:     // The one exception are block frames, because we need to know their
29122:     // natural height excluding any overflow area which may be caused by
29122:     // various CSS effects such as shadow or outline.
29122:     if (!IsFrameOfType(eBlockFrame)) {
    1:       if (aHeight != NS_INTRINSICSIZE) {
 4166:         nscoord computedHeight =
    1:           aHeight - reflowState.mComputedBorderPadding.TopBottom();
32531:         computedHeight = NS_MAX(computedHeight, 0);
 4166:         reflowState.SetComputedHeight(computedHeight);
  256:       } else {
 4166:         reflowState.SetComputedHeight(
  256:           ComputeSize(aRenderingContext, availSize, availSize.width,
  256:                       nsSize(reflowState.mComputedMargin.LeftRight(),
  256:                              reflowState.mComputedMargin.TopBottom()),
  256:                       nsSize(reflowState.mComputedBorderPadding.LeftRight() -
  256:                                reflowState.mComputedPadding.LeftRight(),
  256:                              reflowState.mComputedBorderPadding.TopBottom() -
  256:                                reflowState.mComputedPadding.TopBottom()),
  256:                       nsSize(reflowState.mComputedPadding.LeftRight(),
  256:                                reflowState.mComputedPadding.TopBottom()),
 4166:                       PR_FALSE).height
 4166:           );
    1:       }
29122:     }
    1: 
    1:     // Box layout calls SetRect before Layout, whereas non-box layout
    1:     // calls SetRect after Reflow.
    1:     // XXX Perhaps we should be doing this by twiddling the rect back to
    1:     // mLastSize before calling Reflow and then switching it back, but
    1:     // However, mLastSize can also be the size passed to BoxReflow by
    1:     // RefreshSizeCache, so that doesn't really make sense.
    1:     if (metrics->mLastSize.width != aWidth)
    1:       reflowState.mFlags.mHResize = PR_TRUE;
    1:     if (metrics->mLastSize.height != aHeight)
    1:       reflowState.mFlags.mVResize = PR_TRUE;
    1: 
    1:     #ifdef DEBUG_REFLOW
    1:       nsAdaptorAddIndents();
 4166:       printf("Size=(%d,%d)\n",reflowState.ComputedWidth(),
 4166:              reflowState.ComputedHeight());
    1:       nsAdaptorAddIndents();
    1:       nsAdaptorPrintReason(reflowState);
    1:       printf("\n");
    1:     #endif
    1: 
    1:        // place the child and reflow
    1:     WillReflow(aPresContext);
    1: 
    1:     Reflow(aPresContext, aDesiredSize, reflowState, status);
    1: 
    1:     NS_ASSERTION(NS_FRAME_IS_COMPLETE(status), "bad status");
    1: 
    1:     if (redrawAfterReflow) {
    1:        nsRect r = GetRect();
    1:        r.width = aDesiredSize.width;
    1:        r.height = aDesiredSize.height;
    1:        Redraw(aState, &r);
    1:     }
    1: 
    1:     PRUint32 layoutFlags = aState.LayoutFlags();
    1:     nsContainerFrame::FinishReflowChild(this, aPresContext, &reflowState,
    1:                                         aDesiredSize, aX, aY, layoutFlags | NS_FRAME_NO_MOVE_FRAME);
    1: 
    1:     // Save the ascent.  (bug 103925)
    1:     if (IsCollapsed(aState)) {
    1:       metrics->mAscent = 0;
    1:     } else {
    1:       if (aDesiredSize.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE) {
    1:         if (!nsLayoutUtils::GetFirstLineBaseline(this, &metrics->mAscent))
    1:           metrics->mAscent = GetBaseline();
    1:       } else
    1:         metrics->mAscent = aDesiredSize.ascent;
    1:     }
    1: 
    1:   } else {
    1:     aDesiredSize.ascent = metrics->mBlockAscent;
    1:   }
    1: 
    1: #ifdef DEBUG_REFLOW
    1:   if (aHeight != NS_INTRINSICSIZE && aDesiredSize.height != aHeight)
    1:   {
    1:           nsAdaptorAddIndents();
    1:           printf("*****got taller!*****\n");
    1:          
    1:   }
    1:   if (aWidth != NS_INTRINSICSIZE && aDesiredSize.width != aWidth)
    1:   {
    1:           nsAdaptorAddIndents();
    1:           printf("*****got wider!******\n");
    1:          
    1:   }
    1: #endif
    1: 
    1:   if (aWidth == NS_INTRINSICSIZE)
    1:      aWidth = aDesiredSize.width;
    1: 
    1:   if (aHeight == NS_INTRINSICSIZE)
    1:      aHeight = aDesiredSize.height;
    1: 
    1:   metrics->mLastSize.width = aDesiredSize.width;
    1:   metrics->mLastSize.height = aDesiredSize.height;
    1: 
    1: #ifdef DEBUG_REFLOW
    1:   gIndent2--;
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsBoxLayoutMetrics*
    1: nsFrame::BoxMetrics() const
    1: {
    1:   nsBoxLayoutMetrics* metrics =
 3233:     static_cast<nsBoxLayoutMetrics*>(GetProperty(nsGkAtoms::boxMetricsProperty));
    1:   NS_ASSERTION(metrics, "A box layout method was called but InitBoxMetrics was never called");
    1:   return metrics;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::SetParent(const nsIFrame* aParent)
    1: {
    1:   PRBool wasBoxWrapped = IsBoxWrapped();
    1:   nsIFrame::SetParent(aParent);
    1:   if (!wasBoxWrapped && IsBoxWrapped())
    1:     InitBoxMetrics(PR_TRUE);
    1:   else if (wasBoxWrapped && !IsBoxWrapped())
    1:     DeleteProperty(nsGkAtoms::boxMetricsProperty);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: DeleteBoxMetrics(void    *aObject,
    1:                  nsIAtom *aPropertyName,
    1:                  void    *aPropertyValue,
    1:                  void    *aData)
    1: {
 3233:   delete static_cast<nsBoxLayoutMetrics*>(aPropertyValue);
    1: }
    1: 
    1: void
    1: nsFrame::InitBoxMetrics(PRBool aClear)
    1: {
    1:   if (aClear)
    1:     DeleteProperty(nsGkAtoms::boxMetricsProperty);
    1: 
    1:   nsBoxLayoutMetrics *metrics = new nsBoxLayoutMetrics();
    1:   SetProperty(nsGkAtoms::boxMetricsProperty, metrics, DeleteBoxMetrics);
    1: 
    1:   nsFrame::MarkIntrinsicWidthsDirty();
    1:   metrics->mBlockAscent = 0;
    1:   metrics->mLastSize.SizeTo(0, 0);
    1: }
    1: 
    1: // Box layout debugging
    1: #ifdef DEBUG_REFLOW
    1: PRInt32 gIndent2 = 0;
    1: 
    1: void
    1: nsAdaptorAddIndents()
    1: {
    1:     for(PRInt32 i=0; i < gIndent2; i++)
    1:     {
    1:         printf(" ");
    1:     }
    1: }
    1: 
    1: void
    1: nsAdaptorPrintReason(nsHTMLReflowState& aReflowState)
    1: {
    1:     char* reflowReasonString;
    1: 
    1:     switch(aReflowState.reason) 
    1:     {
    1:         case eReflowReason_Initial:
    1:           reflowReasonString = "initial";
    1:           break;
    1: 
    1:         case eReflowReason_Resize:
    1:           reflowReasonString = "resize";
    1:           break;
    1:         case eReflowReason_Dirty:
    1:           reflowReasonString = "dirty";
    1:           break;
    1:         case eReflowReason_StyleChange:
    1:           reflowReasonString = "stylechange";
    1:           break;
    1:         case eReflowReason_Incremental: 
    1:         {
    1:             switch (aReflowState.reflowCommand->Type()) {
    1:               case eReflowType_StyleChanged:
    1:                  reflowReasonString = "incremental (StyleChanged)";
    1:               break;
    1:               case eReflowType_ReflowDirty:
    1:                  reflowReasonString = "incremental (ReflowDirty)";
    1:               break;
    1:               default:
    1:                  reflowReasonString = "incremental (Unknown)";
    1:             }
    1:         }                             
    1:         break;
    1:         default:
    1:           reflowReasonString = "unknown";
    1:           break;
    1:     }
    1: 
    1:     printf("%s",reflowReasonString);
    1: }
    1: 
    1: #endif
    1: #ifdef DEBUG_LAYOUT
    1: void
    1: nsFrame::GetBoxName(nsAutoString& aName)
    1: {
31709:   GetFrameName(aName);
    1: }
    1: #endif
    1: 
    1: #ifdef NS_DEBUG
    1: static void
    1: GetTagName(nsFrame* aFrame, nsIContent* aContent, PRIntn aResultSize,
    1:            char* aResult)
    1: {
    1:   const char *nameStr = "";
    1:   if (aContent) {
    1:     aContent->Tag()->GetUTF8String(&nameStr);
    1:   }
    1:   PR_snprintf(aResult, aResultSize, "%s@%p", nameStr, aFrame);
    1: }
    1: 
    1: void
    1: nsFrame::Trace(const char* aMethod, PRBool aEnter)
    1: {
    1:   if (NS_FRAME_LOG_TEST(gLogModule, NS_FRAME_TRACE_CALLS)) {
    1:     char tagbuf[40];
    1:     GetTagName(this, mContent, sizeof(tagbuf), tagbuf);
    1:     PR_LogPrint("%s: %s %s", tagbuf, aEnter ? "enter" : "exit", aMethod);
    1:   }
    1: }
    1: 
    1: void
    1: nsFrame::Trace(const char* aMethod, PRBool aEnter, nsReflowStatus aStatus)
    1: {
    1:   if (NS_FRAME_LOG_TEST(gLogModule, NS_FRAME_TRACE_CALLS)) {
    1:     char tagbuf[40];
    1:     GetTagName(this, mContent, sizeof(tagbuf), tagbuf);
    1:     PR_LogPrint("%s: %s %s, status=%scomplete%s",
    1:                 tagbuf, aEnter ? "enter" : "exit", aMethod,
    1:                 NS_FRAME_IS_NOT_COMPLETE(aStatus) ? "not" : "",
    1:                 (NS_FRAME_REFLOW_NEXTINFLOW & aStatus) ? "+reflow" : "");
    1:   }
    1: }
    1: 
    1: void
    1: nsFrame::TraceMsg(const char* aFormatString, ...)
    1: {
    1:   if (NS_FRAME_LOG_TEST(gLogModule, NS_FRAME_TRACE_CALLS)) {
    1:     // Format arguments into a buffer
    1:     char argbuf[200];
    1:     va_list ap;
    1:     va_start(ap, aFormatString);
    1:     PR_vsnprintf(argbuf, sizeof(argbuf), aFormatString, ap);
    1:     va_end(ap);
    1: 
    1:     char tagbuf[40];
    1:     GetTagName(this, mContent, sizeof(tagbuf), tagbuf);
    1:     PR_LogPrint("%s: %s", tagbuf, argbuf);
    1:   }
    1: }
    1: 
    1: void
30790: nsFrame::VerifyDirtyBitSet(const nsFrameList& aFrameList)
30790: {
30790:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
30790:     NS_ASSERTION(e.get()->GetStateBits() & NS_FRAME_IS_DIRTY,
30790:                  "dirty bit not set");
    1:   }
    1: }
    1: 
    1: // Start Display Reflow
    1: #ifdef DEBUG
    1: 
    1: DR_cookie::DR_cookie(nsPresContext*          aPresContext,
    1:                      nsIFrame*                aFrame, 
    1:                      const nsHTMLReflowState& aReflowState,
    1:                      nsHTMLReflowMetrics&     aMetrics,
    1:                      nsReflowStatus&          aStatus)
    1:   :mPresContext(aPresContext), mFrame(aFrame), mReflowState(aReflowState), mMetrics(aMetrics), mStatus(aStatus)
    1: {
    1:   MOZ_COUNT_CTOR(DR_cookie);
    1:   mValue = nsFrame::DisplayReflowEnter(aPresContext, mFrame, mReflowState);
    1: }
    1: 
    1: DR_cookie::~DR_cookie()
    1: {
    1:   MOZ_COUNT_DTOR(DR_cookie);
    1:   nsFrame::DisplayReflowExit(mPresContext, mFrame, mMetrics, mStatus, mValue);
    1: }
    1: 
    1: DR_layout_cookie::DR_layout_cookie(nsIFrame* aFrame)
    1:   : mFrame(aFrame)
    1: {
    1:   MOZ_COUNT_CTOR(DR_layout_cookie);
    1:   mValue = nsFrame::DisplayLayoutEnter(mFrame);
    1: }
    1: 
    1: DR_layout_cookie::~DR_layout_cookie()
    1: {
    1:   MOZ_COUNT_DTOR(DR_layout_cookie);
    1:   nsFrame::DisplayLayoutExit(mFrame, mValue);
    1: }
    1: 
    1: DR_intrinsic_width_cookie::DR_intrinsic_width_cookie(
    1:                      nsIFrame*                aFrame, 
    1:                      const char*              aType,
    1:                      nscoord&                 aResult)
    1:   : mFrame(aFrame)
    1:   , mType(aType)
    1:   , mResult(aResult)
    1: {
    1:   MOZ_COUNT_CTOR(DR_intrinsic_width_cookie);
    1:   mValue = nsFrame::DisplayIntrinsicWidthEnter(mFrame, mType);
    1: }
    1: 
    1: DR_intrinsic_width_cookie::~DR_intrinsic_width_cookie()
    1: {
    1:   MOZ_COUNT_DTOR(DR_intrinsic_width_cookie);
    1:   nsFrame::DisplayIntrinsicWidthExit(mFrame, mType, mResult, mValue);
    1: }
    1: 
    1: DR_intrinsic_size_cookie::DR_intrinsic_size_cookie(
    1:                      nsIFrame*                aFrame, 
    1:                      const char*              aType,
    1:                      nsSize&                  aResult)
    1:   : mFrame(aFrame)
    1:   , mType(aType)
    1:   , mResult(aResult)
    1: {
    1:   MOZ_COUNT_CTOR(DR_intrinsic_size_cookie);
    1:   mValue = nsFrame::DisplayIntrinsicSizeEnter(mFrame, mType);
    1: }
    1: 
    1: DR_intrinsic_size_cookie::~DR_intrinsic_size_cookie()
    1: {
    1:   MOZ_COUNT_DTOR(DR_intrinsic_size_cookie);
    1:   nsFrame::DisplayIntrinsicSizeExit(mFrame, mType, mResult, mValue);
    1: }
    1: 
    1: struct DR_FrameTypeInfo;
    1: struct DR_FrameTreeNode;
    1: struct DR_Rule;
    1: 
    1: struct DR_State
    1: {
    1:   DR_State();
    1:   ~DR_State();
    1:   void Init();
    1:   void AddFrameTypeInfo(nsIAtom* aFrameType,
    1:                         const char* aFrameNameAbbrev,
    1:                         const char* aFrameName);
    1:   DR_FrameTypeInfo* GetFrameTypeInfo(nsIAtom* aFrameType);
    1:   DR_FrameTypeInfo* GetFrameTypeInfo(char* aFrameName);
    1:   void InitFrameTypeTable();
    1:   DR_FrameTreeNode* CreateTreeNode(nsIFrame*                aFrame,
    1:                                    const nsHTMLReflowState* aReflowState);
    1:   void FindMatchingRule(DR_FrameTreeNode& aNode);
    1:   PRBool RuleMatches(DR_Rule&          aRule,
    1:                      DR_FrameTreeNode& aNode);
    1:   PRBool GetToken(FILE* aFile,
    1:                   char* aBuf);
    1:   DR_Rule* ParseRule(FILE* aFile);
    1:   void ParseRulesFile();
24551:   void AddRule(nsTArray<DR_Rule*>& aRules,
    1:                DR_Rule&            aRule);
    1:   PRBool IsWhiteSpace(int c);
    1:   PRBool GetNumber(char*    aBuf, 
    1:                  PRInt32&  aNumber);
    1:   void PrettyUC(nscoord aSize,
    1:                 char*   aBuf);
    1:   void DisplayFrameTypeInfo(nsIFrame* aFrame,
    1:                             PRInt32   aIndent);
    1:   void DeleteTreeNode(DR_FrameTreeNode& aNode);
    1: 
    1:   PRBool      mInited;
    1:   PRBool      mActive;
    1:   PRInt32     mCount;
    1:   PRInt32     mAssert;
    1:   PRInt32     mIndent;
    1:   PRBool      mIndentUndisplayedFrames;
    1:   PRBool      mDisplayPixelErrors;
24551:   nsTArray<DR_Rule*>          mWildRules;
26081:   nsTArray<DR_FrameTypeInfo>  mFrameTypeTable;
    1:   // reflow specific state
24551:   nsTArray<DR_FrameTreeNode*> mFrameTreeLeaves;
    1: };
    1: 
    1: static DR_State *DR_state; // the one and only DR_State
    1: 
    1: struct DR_RulePart 
    1: {
    1:   DR_RulePart(nsIAtom* aFrameType) : mFrameType(aFrameType), mNext(0) {}
    1:   void Destroy();
    1: 
    1:   nsIAtom*     mFrameType;
    1:   DR_RulePart* mNext;
    1: };
    1: 
    1: void DR_RulePart::Destroy()
    1: {
    1:   if (mNext) {
    1:     mNext->Destroy();
    1:   }
    1:   delete this;
    1: }
    1: 
    1: struct DR_Rule 
    1: {
    1:   DR_Rule() : mLength(0), mTarget(nsnull), mDisplay(PR_FALSE) {
    1:     MOZ_COUNT_CTOR(DR_Rule);
    1:   }
    1:   ~DR_Rule() {
    1:     if (mTarget) mTarget->Destroy();
    1:     MOZ_COUNT_DTOR(DR_Rule);
    1:   }
    1:   void AddPart(nsIAtom* aFrameType);
    1: 
    1:   PRUint32      mLength;
    1:   DR_RulePart*  mTarget;
    1:   PRBool        mDisplay;
    1: };
    1: 
    1: void DR_Rule::AddPart(nsIAtom* aFrameType)
    1: {
    1:   DR_RulePart* newPart = new DR_RulePart(aFrameType);
    1:   newPart->mNext = mTarget;
    1:   mTarget = newPart;
    1:   mLength++;
    1: }
    1: 
    1: struct DR_FrameTypeInfo
    1: {
    1:   DR_FrameTypeInfo(nsIAtom* aFrmeType, const char* aFrameNameAbbrev, const char* aFrameName);
    1:   ~DR_FrameTypeInfo() { 
    1:       PRInt32 numElements;
24551:       numElements = mRules.Length();
    1:       for (PRInt32 i = numElements - 1; i >= 0; i--) {
24551:         delete mRules.ElementAt(i);
    1:       }
    1:    }
    1: 
    1:   nsIAtom*    mType;
    1:   char        mNameAbbrev[16];
    1:   char        mName[32];
24551:   nsTArray<DR_Rule*> mRules;
26081: private:
26081:   DR_FrameTypeInfo& operator=(const DR_FrameTypeInfo&); // NOT USED
    1: };
    1: 
    1: DR_FrameTypeInfo::DR_FrameTypeInfo(nsIAtom* aFrameType, 
    1:                                    const char* aFrameNameAbbrev, 
    1:                                    const char* aFrameName)
    1: {
    1:   mType = aFrameType;
    1:   strcpy(mNameAbbrev, aFrameNameAbbrev);
    1:   strcpy(mName, aFrameName);
    1: }
    1: 
    1: struct DR_FrameTreeNode
    1: {
    1:   DR_FrameTreeNode(nsIFrame* aFrame, DR_FrameTreeNode* aParent) : mFrame(aFrame), mParent(aParent), mDisplay(0), mIndent(0)
    1:   {
    1:     MOZ_COUNT_CTOR(DR_FrameTreeNode);
    1:   }
    1: 
    1:   ~DR_FrameTreeNode()
    1:   {
    1:     MOZ_COUNT_DTOR(DR_FrameTreeNode);
    1:   }
    1: 
    1:   nsIFrame*         mFrame;
    1:   DR_FrameTreeNode* mParent;
    1:   PRBool            mDisplay;
    1:   PRUint32          mIndent;
    1: };
    1: 
    1: // DR_State implementation
    1: 
    1: DR_State::DR_State() 
    1: : mInited(PR_FALSE), mActive(PR_FALSE), mCount(0), mAssert(-1), mIndent(0), 
    1:   mIndentUndisplayedFrames(PR_FALSE), mDisplayPixelErrors(PR_FALSE)
    1: {
    1:   MOZ_COUNT_CTOR(DR_State);
    1: }
    1: 
    1: void DR_State::Init() 
    1: {
    1:   char* env = PR_GetEnv("GECKO_DISPLAY_REFLOW_ASSERT");
    1:   PRInt32 num;
    1:   if (env) {
    1:     if (GetNumber(env, num)) 
    1:       mAssert = num;
    1:     else 
    1:       printf("GECKO_DISPLAY_REFLOW_ASSERT - invalid value = %s", env);
    1:   }
    1: 
    1:   env = PR_GetEnv("GECKO_DISPLAY_REFLOW_INDENT_START");
    1:   if (env) {
    1:     if (GetNumber(env, num)) 
    1:       mIndent = num;
    1:     else 
    1:       printf("GECKO_DISPLAY_REFLOW_INDENT_START - invalid value = %s", env);
    1:   }
    1: 
    1:   env = PR_GetEnv("GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES");
    1:   if (env) {
    1:     if (GetNumber(env, num)) 
    1:       mIndentUndisplayedFrames = num;
    1:     else 
    1:       printf("GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES - invalid value = %s", env);
    1:   }
    1: 
    1:   env = PR_GetEnv("GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS");
    1:   if (env) {
    1:     if (GetNumber(env, num)) 
    1:       mDisplayPixelErrors = num;
    1:     else 
    1:       printf("GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS - invalid value = %s", env);
    1:   }
    1: 
    1:   InitFrameTypeTable();
    1:   ParseRulesFile();
    1:   mInited = PR_TRUE;
    1: }
    1: 
    1: DR_State::~DR_State()
    1: {
    1:   MOZ_COUNT_DTOR(DR_State);
    1:   PRInt32 numElements, i;
24551:   numElements = mWildRules.Length();
    1:   for (i = numElements - 1; i >= 0; i--) {
24551:     delete mWildRules.ElementAt(i);
24551:   }
24551:   numElements = mFrameTreeLeaves.Length();
    1:   for (i = numElements - 1; i >= 0; i--) {
24551:     delete mFrameTreeLeaves.ElementAt(i);
24551:   }
    1: }
    1: 
    1: PRBool DR_State::GetNumber(char*     aBuf, 
    1:                            PRInt32&  aNumber)
    1: {
    1:   if (sscanf(aBuf, "%d", &aNumber) > 0) 
    1:     return PR_TRUE;
    1:   else 
    1:     return PR_FALSE;
    1: }
    1: 
    1: PRBool DR_State::IsWhiteSpace(int c) {
    1:   return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r');
    1: }
    1: 
    1: PRBool DR_State::GetToken(FILE* aFile,
    1:                           char* aBuf)
    1: {
    1:   PRBool haveToken = PR_FALSE;
    1:   aBuf[0] = 0;
    1:   // get the 1st non whitespace char
    1:   int c = -1;
    1:   for (c = getc(aFile); (c > 0) && IsWhiteSpace(c); c = getc(aFile)) {
    1:   }
    1: 
    1:   if (c > 0) {
    1:     haveToken = PR_TRUE;
    1:     aBuf[0] = c;
    1:     // get everything up to the next whitespace char
    1:     PRInt32 cX;
    1:     for (cX = 1, c = getc(aFile); ; cX++, c = getc(aFile)) {
    1:       if (c < 0) { // EOF
    1:         ungetc(' ', aFile); 
    1:         break;
    1:       }
    1:       else {
    1:         if (IsWhiteSpace(c)) {
    1:           break;
    1:         }
    1:         else {
    1:           aBuf[cX] = c;
    1:         }
    1:       }
    1:     }
    1:     aBuf[cX] = 0;
    1:   }
    1:   return haveToken;
    1: }
    1: 
    1: DR_Rule* DR_State::ParseRule(FILE* aFile)
    1: {
    1:   char buf[128];
    1:   PRInt32 doDisplay;
    1:   DR_Rule* rule = nsnull;
    1:   while (GetToken(aFile, buf)) {
    1:     if (GetNumber(buf, doDisplay)) {
    1:       if (rule) { 
 6770:         rule->mDisplay = !!doDisplay;
    1:         break;
    1:       }
    1:       else {
    1:         printf("unexpected token - %s \n", buf);
    1:       }
    1:     }
    1:     else {
    1:       if (!rule) {
    1:         rule = new DR_Rule;
    1:       }
    1:       if (strcmp(buf, "*") == 0) {
    1:         rule->AddPart(nsnull);
    1:       }
    1:       else {
    1:         DR_FrameTypeInfo* info = GetFrameTypeInfo(buf);
    1:         if (info) {
    1:           rule->AddPart(info->mType);
    1:         }
    1:         else {
    1:           printf("invalid frame type - %s \n", buf);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return rule;
    1: }
    1: 
24551: void DR_State::AddRule(nsTArray<DR_Rule*>& aRules,
    1:                        DR_Rule&            aRule)
    1: {
24551:   PRInt32 numRules = aRules.Length();
    1:   for (PRInt32 ruleX = 0; ruleX < numRules; ruleX++) {
24551:     DR_Rule* rule = aRules.ElementAt(ruleX);
    1:     NS_ASSERTION(rule, "program error");
    1:     if (aRule.mLength > rule->mLength) {
24551:       aRules.InsertElementAt(ruleX, &aRule);
    1:       return;
    1:     }
    1:   }
    1:   aRules.AppendElement(&aRule);
    1: }
    1: 
    1: void DR_State::ParseRulesFile()
    1: {
    1:   char* path = PR_GetEnv("GECKO_DISPLAY_REFLOW_RULES_FILE");
    1:   if (path) {
    1:     FILE* inFile = fopen(path, "r");
    1:     if (inFile) {
    1:       for (DR_Rule* rule = ParseRule(inFile); rule; rule = ParseRule(inFile)) {
    1:         if (rule->mTarget) {
    1:           nsIAtom* fType = rule->mTarget->mFrameType;
    1:           if (fType) {
    1:             DR_FrameTypeInfo* info = GetFrameTypeInfo(fType);
    1:             if (info) {
    1:               AddRule(info->mRules, *rule);
    1:             }
    1:           }
    1:           else {
    1:             AddRule(mWildRules, *rule);
    1:           }
    1:           mActive = PR_TRUE;
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: void DR_State::AddFrameTypeInfo(nsIAtom* aFrameType,
    1:                                 const char* aFrameNameAbbrev,
    1:                                 const char* aFrameName)
    1: {
26081:   mFrameTypeTable.AppendElement(DR_FrameTypeInfo(aFrameType, aFrameNameAbbrev, aFrameName));
    1: }
    1: 
    1: DR_FrameTypeInfo* DR_State::GetFrameTypeInfo(nsIAtom* aFrameType)
    1: {
24551:   PRInt32 numEntries = mFrameTypeTable.Length();
    1:   NS_ASSERTION(numEntries != 0, "empty FrameTypeTable");
    1:   for (PRInt32 i = 0; i < numEntries; i++) {
26081:     DR_FrameTypeInfo& info = mFrameTypeTable.ElementAt(i);
26081:     if (info.mType == aFrameType) {
26081:       return &info;
26081:     }
26081:   }
26081:   return &mFrameTypeTable.ElementAt(numEntries - 1); // return unknown frame type
    1: }
    1: 
    1: DR_FrameTypeInfo* DR_State::GetFrameTypeInfo(char* aFrameName)
    1: {
24551:   PRInt32 numEntries = mFrameTypeTable.Length();
    1:   NS_ASSERTION(numEntries != 0, "empty FrameTypeTable");
    1:   for (PRInt32 i = 0; i < numEntries; i++) {
26081:     DR_FrameTypeInfo& info = mFrameTypeTable.ElementAt(i);
26081:     if ((strcmp(aFrameName, info.mName) == 0) || (strcmp(aFrameName, info.mNameAbbrev) == 0)) {
26081:       return &info;
26081:     }
26081:   }
26081:   return &mFrameTypeTable.ElementAt(numEntries - 1); // return unknown frame type
    1: }
    1: 
    1: void DR_State::InitFrameTypeTable()
    1: {  
    1:   AddFrameTypeInfo(nsGkAtoms::blockFrame,            "block",     "block");
    1:   AddFrameTypeInfo(nsGkAtoms::brFrame,               "br",        "br");
    1:   AddFrameTypeInfo(nsGkAtoms::bulletFrame,           "bullet",    "bullet");
    1:   AddFrameTypeInfo(nsGkAtoms::gfxButtonControlFrame, "button",    "gfxButtonControl");
    1:   AddFrameTypeInfo(nsGkAtoms::HTMLButtonControlFrame, "HTMLbutton",    "HTMLButtonControl");
    1:   AddFrameTypeInfo(nsGkAtoms::HTMLCanvasFrame,       "HTMLCanvas","HTMLCanvas");
    1:   AddFrameTypeInfo(nsGkAtoms::subDocumentFrame,      "subdoc",    "subDocument");
    1:   AddFrameTypeInfo(nsGkAtoms::imageFrame,            "img",       "image");
    1:   AddFrameTypeInfo(nsGkAtoms::inlineFrame,           "inline",    "inline");
    1:   AddFrameTypeInfo(nsGkAtoms::letterFrame,           "letter",    "letter");
    1:   AddFrameTypeInfo(nsGkAtoms::lineFrame,             "line",      "line");
    1:   AddFrameTypeInfo(nsGkAtoms::listControlFrame,      "select",    "select");
    1:   AddFrameTypeInfo(nsGkAtoms::objectFrame,           "obj",       "object");
    1:   AddFrameTypeInfo(nsGkAtoms::pageFrame,             "page",      "page");
    1:   AddFrameTypeInfo(nsGkAtoms::placeholderFrame,      "place",     "placeholder");
    1:   AddFrameTypeInfo(nsGkAtoms::positionedInlineFrame, "posInline", "positionedInline");
    1:   AddFrameTypeInfo(nsGkAtoms::canvasFrame,           "canvas",    "canvas");
    1:   AddFrameTypeInfo(nsGkAtoms::rootFrame,             "root",      "root");
    1:   AddFrameTypeInfo(nsGkAtoms::scrollFrame,           "scroll",    "scroll");
    1:   AddFrameTypeInfo(nsGkAtoms::tableCaptionFrame,     "caption",   "tableCaption");
    1:   AddFrameTypeInfo(nsGkAtoms::tableCellFrame,        "cell",      "tableCell");
    1:   AddFrameTypeInfo(nsGkAtoms::bcTableCellFrame,      "bcCell",    "bcTableCell");
    1:   AddFrameTypeInfo(nsGkAtoms::tableColFrame,         "col",       "tableCol");
    1:   AddFrameTypeInfo(nsGkAtoms::tableColGroupFrame,    "colG",      "tableColGroup");
    1:   AddFrameTypeInfo(nsGkAtoms::tableFrame,            "tbl",       "table");
    1:   AddFrameTypeInfo(nsGkAtoms::tableOuterFrame,       "tblO",      "tableOuter");
    1:   AddFrameTypeInfo(nsGkAtoms::tableRowGroupFrame,    "rowG",      "tableRowGroup");
    1:   AddFrameTypeInfo(nsGkAtoms::tableRowFrame,         "row",       "tableRow");
    1:   AddFrameTypeInfo(nsGkAtoms::textInputFrame,        "textCtl",   "textInput");
    1:   AddFrameTypeInfo(nsGkAtoms::textFrame,             "text",      "text");
    1:   AddFrameTypeInfo(nsGkAtoms::viewportFrame,         "VP",        "viewport");
23176: #ifdef MOZ_XUL
23176:   AddFrameTypeInfo(nsGkAtoms::XULLabelFrame,         "XULLabel",  "XULLabel");
23176: #endif
    1:   AddFrameTypeInfo(nsnull,                               "unknown",   "unknown");
    1: }
    1: 
    1: 
    1: void DR_State::DisplayFrameTypeInfo(nsIFrame* aFrame,
    1:                                     PRInt32   aIndent)
    1: { 
    1:   DR_FrameTypeInfo* frameTypeInfo = GetFrameTypeInfo(aFrame->GetType());
    1:   if (frameTypeInfo) {
    1:     for (PRInt32 i = 0; i < aIndent; i++) {
    1:       printf(" ");
    1:     }
    1:     if(!strcmp(frameTypeInfo->mNameAbbrev, "unknown")) {
31709:       if (aFrame) {
    1:        nsAutoString  name;
31709:        aFrame->GetFrameName(name);
    1:        printf("%s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)aFrame);
    1:       }
    1:       else {
    1:         printf("%s %p ", frameTypeInfo->mNameAbbrev, (void*)aFrame);
    1:       }
    1:     }
    1:     else {
    1:       printf("%s %p ", frameTypeInfo->mNameAbbrev, (void*)aFrame);
    1:     }
    1:   }
    1: }
    1: 
    1: PRBool DR_State::RuleMatches(DR_Rule&          aRule,
    1:                              DR_FrameTreeNode& aNode)
    1: {
    1:   NS_ASSERTION(aRule.mTarget, "program error");
    1: 
    1:   DR_RulePart* rulePart;
    1:   DR_FrameTreeNode* parentNode;
    1:   for (rulePart = aRule.mTarget->mNext, parentNode = aNode.mParent;
    1:        rulePart && parentNode;
    1:        rulePart = rulePart->mNext, parentNode = parentNode->mParent) {
    1:     if (rulePart->mFrameType) {
    1:       if (parentNode->mFrame) {
    1:         if (rulePart->mFrameType != parentNode->mFrame->GetType()) {
    1:           return PR_FALSE;
    1:         }
    1:       }
    1:       else NS_ASSERTION(PR_FALSE, "program error");
    1:     }
    1:     // else wild card match
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: void DR_State::FindMatchingRule(DR_FrameTreeNode& aNode)
    1: {
    1:   if (!aNode.mFrame) {
    1:     NS_ASSERTION(PR_FALSE, "invalid DR_FrameTreeNode \n");
    1:     return;
    1:   }
    1: 
    1:   PRBool matchingRule = PR_FALSE;
    1: 
    1:   DR_FrameTypeInfo* info = GetFrameTypeInfo(aNode.mFrame->GetType());
    1:   NS_ASSERTION(info, "program error");
24551:   PRInt32 numRules = info->mRules.Length();
    1:   for (PRInt32 ruleX = 0; ruleX < numRules; ruleX++) {
24551:     DR_Rule* rule = info->mRules.ElementAt(ruleX);
    1:     if (rule && RuleMatches(*rule, aNode)) {
    1:       aNode.mDisplay = rule->mDisplay;
    1:       matchingRule = PR_TRUE;
    1:       break;
    1:     }
    1:   }
    1:   if (!matchingRule) {
24551:     PRInt32 numWildRules = mWildRules.Length();
    1:     for (PRInt32 ruleX = 0; ruleX < numWildRules; ruleX++) {
24551:       DR_Rule* rule = mWildRules.ElementAt(ruleX);
    1:       if (rule && RuleMatches(*rule, aNode)) {
    1:         aNode.mDisplay = rule->mDisplay;
    1:         break;
    1:       }
    1:     }
    1:   }
    1: }
    1:     
    1: DR_FrameTreeNode* DR_State::CreateTreeNode(nsIFrame*                aFrame,
    1:                                            const nsHTMLReflowState* aReflowState)
    1: {
    1:   // find the frame of the parent reflow state (usually just the parent of aFrame)
    1:   nsIFrame* parentFrame;
    1:   if (aReflowState) {
    1:     const nsHTMLReflowState* parentRS = aReflowState->parentReflowState;
    1:     parentFrame = (parentRS) ? parentRS->frame : nsnull;
    1:   } else {
    1:     parentFrame = aFrame->GetParent();
    1:   }
    1: 
    1:   // find the parent tree node leaf
    1:   DR_FrameTreeNode* parentNode = nsnull;
    1:   
    1:   DR_FrameTreeNode* lastLeaf = nsnull;
24551:   if(mFrameTreeLeaves.Length())
26081:     lastLeaf = mFrameTreeLeaves.ElementAt(mFrameTreeLeaves.Length() - 1);
    1:   if (lastLeaf) {
    1:     for (parentNode = lastLeaf; parentNode && (parentNode->mFrame != parentFrame); parentNode = parentNode->mParent) {
    1:     }
    1:   }
    1:   DR_FrameTreeNode* newNode = new DR_FrameTreeNode(aFrame, parentNode);
    1:   FindMatchingRule(*newNode);
    1: 
    1:   newNode->mIndent = mIndent;
    1:   if (newNode->mDisplay || mIndentUndisplayedFrames) {
    1:     ++mIndent;
    1:   }
    1: 
    1:   if (lastLeaf && (lastLeaf == parentNode)) {
24551:     mFrameTreeLeaves.RemoveElementAt(mFrameTreeLeaves.Length() - 1);
    1:   }
    1:   mFrameTreeLeaves.AppendElement(newNode);
    1:   mCount++;
    1: 
    1:   return newNode;
    1: }
    1: 
    1: void DR_State::PrettyUC(nscoord aSize,
    1:                         char*   aBuf)
    1: {
    1:   if (NS_UNCONSTRAINEDSIZE == aSize) {
    1:     strcpy(aBuf, "UC");
    1:   }
    1:   else {
    1:     if ((nscoord)0xdeadbeefU == aSize)
    1:     {
    1:       strcpy(aBuf, "deadbeef");
    1:     }
    1:     else {
    1:       sprintf(aBuf, "%d", aSize);
    1:     }
    1:   }
    1: }
    1: 
    1: void DR_State::DeleteTreeNode(DR_FrameTreeNode& aNode)
    1: {
    1:   mFrameTreeLeaves.RemoveElement(&aNode);
24551:   PRInt32 numLeaves = mFrameTreeLeaves.Length();
24551:   if ((0 == numLeaves) || (aNode.mParent != mFrameTreeLeaves.ElementAt(numLeaves - 1))) {
    1:     mFrameTreeLeaves.AppendElement(aNode.mParent);
    1:   }
    1: 
    1:   if (aNode.mDisplay || mIndentUndisplayedFrames) {
    1:     --mIndent;
    1:   }
    1:   // delete the tree node 
    1:   delete &aNode;
    1: }
    1: 
    1: static void
    1: CheckPixelError(nscoord aSize,
    1:                 PRInt32 aPixelToTwips)
    1: {
    1:   if (NS_UNCONSTRAINEDSIZE != aSize) {
    1:     if ((aSize % aPixelToTwips) > 0) {
    1:       printf("VALUE %d is not a whole pixel \n", aSize);
    1:     }
    1:   }
    1: }
    1: 
    1: static void DisplayReflowEnterPrint(nsPresContext*          aPresContext,
    1:                                     nsIFrame*                aFrame,
    1:                                     const nsHTMLReflowState& aReflowState,
    1:                                     DR_FrameTreeNode&        aTreeNode,
    1:                                     PRBool                   aChanged)
    1: {
    1:   if (aTreeNode.mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, aTreeNode.mIndent);
    1: 
    1:     char width[16];
    1:     char height[16];
    1: 
    1:     DR_state->PrettyUC(aReflowState.availableWidth, width);
    1:     DR_state->PrettyUC(aReflowState.availableHeight, height);
    1:     printf("Reflow a=%s,%s ", width, height);
    1: 
    1:     DR_state->PrettyUC(aReflowState.ComputedWidth(), width);
 4166:     DR_state->PrettyUC(aReflowState.ComputedHeight(), height);
    1:     printf("c=%s,%s ", width, height);
    1: 
    1:     if (aFrame->GetStateBits() & NS_FRAME_IS_DIRTY)
    1:       printf("dirty ");
    1: 
    1:     if (aFrame->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN)
    1:       printf("dirty-children ");
    1: 
    1:     if (aReflowState.mFlags.mSpecialHeightReflow)
    1:       printf("special-height ");
    1: 
    1:     if (aReflowState.mFlags.mHResize)
    1:       printf("h-resize ");
    1: 
    1:     if (aReflowState.mFlags.mVResize)
    1:       printf("v-resize ");
    1: 
    1:     nsIFrame* inFlow = aFrame->GetPrevInFlow();
    1:     if (inFlow) {
    1:       printf("pif=%p ", (void*)inFlow);
    1:     }
    1:     inFlow = aFrame->GetNextInFlow();
    1:     if (inFlow) {
    1:       printf("nif=%p ", (void*)inFlow);
    1:     }
    1:     if (aChanged) 
    1:       printf("CHANGED \n");
    1:     else 
    1:       printf("cnt=%d \n", DR_state->mCount);
    1:     if (DR_state->mDisplayPixelErrors) {
    1:       PRInt32 p2t = aPresContext->AppUnitsPerDevPixel();
    1:       CheckPixelError(aReflowState.availableWidth, p2t);
    1:       CheckPixelError(aReflowState.availableHeight, p2t);
    1:       CheckPixelError(aReflowState.ComputedWidth(), p2t);
 4166:       CheckPixelError(aReflowState.ComputedHeight(), p2t);
    1:     }
    1:   }
    1: }
    1: 
    1: void* nsFrame::DisplayReflowEnter(nsPresContext*          aPresContext,
    1:                                   nsIFrame*                aFrame,
    1:                                   const nsHTMLReflowState& aReflowState)
    1: {
    1:   if (!DR_state->mInited) DR_state->Init();
    1:   if (!DR_state->mActive) return nsnull;
    1: 
    1:   NS_ASSERTION(aFrame, "invalid call");
    1: 
    1:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, &aReflowState);
    1:   if (treeNode) {
    1:     DisplayReflowEnterPrint(aPresContext, aFrame, aReflowState, *treeNode, PR_FALSE);
    1:   }
    1:   return treeNode;
    1: }
    1: 
    1: void* nsFrame::DisplayLayoutEnter(nsIFrame* aFrame)
    1: {
    1:   if (!DR_state->mInited) DR_state->Init();
    1:   if (!DR_state->mActive) return nsnull;
    1: 
    1:   NS_ASSERTION(aFrame, "invalid call");
    1: 
    1:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nsnull);
    1:   if (treeNode && treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1:     printf("Layout\n");
    1:   }
    1:   return treeNode;
    1: }
    1: 
    1: void* nsFrame::DisplayIntrinsicWidthEnter(nsIFrame* aFrame,
    1:                                           const char* aType)
    1: {
    1:   if (!DR_state->mInited) DR_state->Init();
    1:   if (!DR_state->mActive) return nsnull;
    1: 
    1:   NS_ASSERTION(aFrame, "invalid call");
    1: 
    1:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nsnull);
    1:   if (treeNode && treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1:     printf("Get%sWidth\n", aType);
    1:   }
    1:   return treeNode;
    1: }
    1: 
    1: void* nsFrame::DisplayIntrinsicSizeEnter(nsIFrame* aFrame,
    1:                                          const char* aType)
    1: {
    1:   if (!DR_state->mInited) DR_state->Init();
    1:   if (!DR_state->mActive) return nsnull;
    1: 
    1:   NS_ASSERTION(aFrame, "invalid call");
    1: 
    1:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nsnull);
    1:   if (treeNode && treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1:     printf("Get%sSize\n", aType);
    1:   }
    1:   return treeNode;
    1: }
    1: 
    1: void nsFrame::DisplayReflowExit(nsPresContext*      aPresContext,
    1:                                 nsIFrame*            aFrame,
    1:                                 nsHTMLReflowMetrics& aMetrics,
    1:                                 nsReflowStatus       aStatus,
    1:                                 void*                aFrameTreeNode)
    1: {
    1:   if (!DR_state->mActive) return;
    1: 
    1:   NS_ASSERTION(aFrame, "DisplayReflowExit - invalid call");
    1:   if (!aFrameTreeNode) return;
    1: 
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
    1:   if (treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1: 
    1:     char width[16];
    1:     char height[16];
    1:     char x[16];
    1:     char y[16];
    1:     DR_state->PrettyUC(aMetrics.width, width);
    1:     DR_state->PrettyUC(aMetrics.height, height);
    1:     printf("Reflow d=%s,%s", width, height);
    1: 
 4006:     if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
    1:       printf(" status=0x%x", aStatus);
    1:     }
26950:     if (aFrame->HasOverflowRect()) {
    1:       DR_state->PrettyUC(aMetrics.mOverflowArea.x, x);
    1:       DR_state->PrettyUC(aMetrics.mOverflowArea.y, y);
    1:       DR_state->PrettyUC(aMetrics.mOverflowArea.width, width);
    1:       DR_state->PrettyUC(aMetrics.mOverflowArea.height, height);
    1:       printf(" o=(%s,%s) %s x %s", x, y, width, height);
26950:       if (aFrame->HasOverflowRect()) {
11909:         nsRect storedOverflow = aFrame->GetOverflowRect();
11909:         DR_state->PrettyUC(storedOverflow.x, x);
11909:         DR_state->PrettyUC(storedOverflow.y, y);
11909:         DR_state->PrettyUC(storedOverflow.width, width);
11909:         DR_state->PrettyUC(storedOverflow.height, height);
    1:         printf(" sto=(%s,%s) %s x %s", x, y, width, height);
    1:       }
    1:     }
    1:     printf("\n");
    1:     if (DR_state->mDisplayPixelErrors) {
    1:       PRInt32 p2t = aPresContext->AppUnitsPerDevPixel();
    1:       CheckPixelError(aMetrics.width, p2t);
    1:       CheckPixelError(aMetrics.height, p2t);
    1:     }
    1:   }
    1:   DR_state->DeleteTreeNode(*treeNode);
    1: }
    1: 
    1: void nsFrame::DisplayLayoutExit(nsIFrame*            aFrame,
    1:                                 void*                aFrameTreeNode)
    1: {
    1:   if (!DR_state->mActive) return;
    1: 
    1:   NS_ASSERTION(aFrame, "non-null frame required");
    1:   if (!aFrameTreeNode) return;
    1: 
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
    1:   if (treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1:     nsRect rect = aFrame->GetRect();
    1:     printf("Layout=%d,%d,%d,%d\n", rect.x, rect.y, rect.width, rect.height);
    1:   }
    1:   DR_state->DeleteTreeNode(*treeNode);
    1: }
    1: 
    1: void nsFrame::DisplayIntrinsicWidthExit(nsIFrame*            aFrame,
    1:                                         const char*          aType,
    1:                                         nscoord              aResult,
    1:                                         void*                aFrameTreeNode)
    1: {
    1:   if (!DR_state->mActive) return;
    1: 
    1:   NS_ASSERTION(aFrame, "non-null frame required");
    1:   if (!aFrameTreeNode) return;
    1: 
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
    1:   if (treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1:     printf("Get%sWidth=%d\n", aType, aResult);
    1:   }
    1:   DR_state->DeleteTreeNode(*treeNode);
    1: }
    1: 
    1: void nsFrame::DisplayIntrinsicSizeExit(nsIFrame*            aFrame,
    1:                                        const char*          aType,
    1:                                        nsSize               aResult,
    1:                                        void*                aFrameTreeNode)
    1: {
    1:   if (!DR_state->mActive) return;
    1: 
    1:   NS_ASSERTION(aFrame, "non-null frame required");
    1:   if (!aFrameTreeNode) return;
    1: 
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
    1:   if (treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1: 
    1:     char width[16];
    1:     char height[16];
    1:     DR_state->PrettyUC(aResult.width, width);
    1:     DR_state->PrettyUC(aResult.height, height);
    1:     printf("Get%sSize=%s,%s\n", aType, width, height);
    1:   }
    1:   DR_state->DeleteTreeNode(*treeNode);
    1: }
    1: 
    1: /* static */ void
    1: nsFrame::DisplayReflowStartup()
    1: {
    1:   DR_state = new DR_State();
    1: }
    1: 
    1: /* static */ void
    1: nsFrame::DisplayReflowShutdown()
    1: {
    1:   delete DR_state;
    1:   DR_state = nsnull;
    1: }
    1: 
    1: void DR_cookie::Change() const
    1: {
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)mValue;
    1:   if (treeNode && treeNode->mDisplay) {
    1:     DisplayReflowEnterPrint(mPresContext, mFrame, mReflowState, *treeNode, PR_TRUE);
    1:   }
    1: }
    1: 
    1: #endif
    1: // End Display Reflow
    1: 
    1: #endif
