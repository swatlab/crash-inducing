 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS script operations.
     1:  */
 88221: 
     1: #include <string.h>
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
 75365: #include "jscrashreport.h"
     1: #include "jsprf.h"
     1: #include "jsapi.h"
     1: #include "jsatom.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsdbgapi.h"
     1: #include "jsfun.h"
 68933: #include "jsgc.h"
     1: #include "jsinterp.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
     1: #include "jsopcode.h"
 18955: #include "jsscope.h"
     1: #include "jsscript.h"
 80506: 
 97569: #include "gc/Marking.h"
 80964: #include "frontend/BytecodeEmitter.h"
 80506: #include "frontend/Parser.h"
 86104: #include "js/MemoryMetrics.h"
 52559: #include "methodjit/MethodJIT.h"
 77169: #include "methodjit/Retcon.h"
 76244: #include "vm/Debugger.h"
 94006: #include "vm/Xdr.h"
     1: 
 77343: #include "jsinferinlines.h"
 79734: #include "jsinterpinlines.h"
 42733: #include "jsobjinlines.h"
 32737: #include "jsscriptinlines.h"
 32737: 
 98180: #include "frontend/TreeContext-inl.h"
 97298: #include "vm/RegExpObject-inl.h"
 97298: 
 98445: #include "frontend/TreeContext-inl.h"
 98445: 
 37741: using namespace js;
 54707: using namespace js::gc;
 80632: using namespace js::frontend;
 37741: 
 59968: namespace js {
 59968: 
 59968: BindingKind
 91237: Bindings::lookup(JSContext *cx, JSAtom *name, unsigned *indexp) const
 59968: {
 77343:     if (!lastBinding)
 77343:         return NONE;
 59968: 
 86437:     Shape **spp;
 97828:     Shape *shape = Shape::search(cx, lastBinding, AtomToId(name), &spp);
 59968:     if (!shape)
 59968:         return NONE;
 59968: 
 59968:     if (indexp)
 83221:         *indexp = shape->shortid();
 59968: 
100006:     if (shape->getter() == CallObject::getArgOp)
 59968:         return ARGUMENT;
 59968: 
 59968:     return shape->writable() ? VARIABLE : CONSTANT;
 59968: }
 59968: 
 59968: bool
 95355: Bindings::add(JSContext *cx, HandleAtom name, BindingKind kind)
 59968: {
 77343:     if (!ensureShape(cx))
 77343:         return false;
 59968: 
 95101:     if (nargs + nvars == BINDING_COUNT_LIMIT) {
 95101:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 95101:                              (kind == ARGUMENT)
 95101:                              ? JSMSG_TOO_MANY_FUN_ARGS
 95101:                              : JSMSG_TOO_MANY_LOCALS);
 95101:         return false;
 95101:     }
 95101: 
 59968:     /*
 59968:      * We still follow 10.2.3 of ES3 and make argument and variable properties
 59968:      * of the Call objects enumerable. ES5 reformulated all of its Clause 10 to
 59968:      * avoid objects as activations, something we should do too.
 59968:      */
 91237:     unsigned attrs = JSPROP_ENUMERATE | JSPROP_PERMANENT;
 59968: 
 84755:     uint16_t *indexp;
 62395:     PropertyOp getter;
 62395:     StrictPropertyOp setter;
 84755:     uint32_t slot = CallObject::RESERVED_SLOTS;
 59968: 
 59968:     if (kind == ARGUMENT) {
 59968:         JS_ASSERT(nvars == 0);
 59968:         indexp = &nargs;
100006:         getter = CallObject::getArgOp;
 91175:         setter = CallObject::setArgOp;
 59968:         slot += nargs;
 59968:     } else {
 59968:         JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
 59968: 
 59968:         indexp = &nvars;
100006:         getter = CallObject::getVarOp;
 91175:         setter = CallObject::setVarOp;
 59968:         if (kind == CONSTANT)
 59968:             attrs |= JSPROP_READONLY;
 59968:         slot += nargs + nvars;
 59968:     }
 59968: 
 99421:     RootedId id(cx);
 59968:     if (!name) {
 59968:         JS_ASSERT(kind == ARGUMENT); /* destructuring */
 59968:         id = INT_TO_JSID(nargs);
 59968:     } else {
 97828:         id = AtomToId(name);
 59968:     }
 59968: 
 86437:     StackBaseShape base(&CallClass, NULL, BaseShape::VAROBJ);
 86437:     base.updateGetterSetter(attrs, getter, setter);
 86437: 
 84345:     UnownedBaseShape *nbase = BaseShape::getUnowned(cx, base);
 83221:     if (!nbase)
 83221:         return NULL;
 59968: 
 86437:     StackShape child(nbase, id, slot, 0, attrs, Shape::HAS_SHORTID, *indexp);
 83221: 
 83221:     /* Shapes in bindings cannot be dictionaries. */
 86437:     Shape *shape = lastBinding->getChildBinding(cx, child);
 59968:     if (!shape)
 59968:         return false;
 59968: 
 86437:     lastBinding = shape;
 59968:     ++*indexp;
 59968:     return true;
 59968: }
 59968: 
 89745: Shape *
 89745: Bindings::callObjectShape(JSContext *cx) const
 89745: {
 89745:     if (!hasDup())
 89745:         return lastShape();
 89745: 
 89745:     /*
 89745:      * Build a vector of non-duplicate properties in order from last added
 89745:      * to first (i.e., the order we normally have iterate over Shapes). Choose
 89745:      * the last added property in each set of dups.
 89745:      */
 89745:     Vector<const Shape *> shapes(cx);
 89745:     HashSet<jsid> seen(cx);
 89745:     if (!seen.init())
 89820:         return NULL;
 89745: 
 89745:     for (Shape::Range r = lastShape()->all(); !r.empty(); r.popFront()) {
 89745:         const Shape &s = r.front();
 89745:         HashSet<jsid>::AddPtr p = seen.lookupForAdd(s.propid());
 89745:         if (!p) {
 89745:             if (!seen.add(p, s.propid()))
 89745:                 return NULL;
 89745:             if (!shapes.append(&s))
 89745:                 return NULL;
 89745:         }
 89745:     }
 89745: 
 89745:     /*
 89745:      * Now build the Shape without duplicate properties.
 89745:      */
 99421:     RootedShape shape(cx);
 89745:     shape = initialShape(cx);
 89745:     for (int i = shapes.length() - 1; i >= 0; --i) {
 89745:         shape = shape->getChildBinding(cx, shapes[i]);
 89745:         if (!shape)
 89745:             return NULL;
 89745:     }
 89745: 
 89745:     return shape;
 89745: }
 89745: 
 73058: bool
 97297: Bindings::getLocalNameArray(JSContext *cx, BindingNames *namesp)
 59968: {
 59968:     JS_ASSERT(lastBinding);
 97298:     if (count() == 0)
 97298:         return true;
 59968: 
 97297:     BindingNames &names = *namesp;
 73058:     JS_ASSERT(names.empty());
 73058: 
 95100:     unsigned n = count();
 73058:     if (!names.growByUninitialized(n))
 73058:         return false;
 59968: 
 59968: #ifdef DEBUG
 73058:     JSAtom * const POISON = reinterpret_cast<JSAtom *>(0xdeadbeef);
 91237:     for (unsigned i = 0; i < n; i++)
 97297:         names[i].maybeAtom = POISON;
 59968: #endif
 59968: 
 82129:     for (Shape::Range r = lastBinding->all(); !r.empty(); r.popFront()) {
 59968:         const Shape &shape = r.front();
 91237:         unsigned index = uint16_t(shape.shortid());
 59968: 
100006:         if (shape.getter() == CallObject::getArgOp) {
 59968:             JS_ASSERT(index < nargs);
 97297:             names[index].kind = ARGUMENT;
 59968:         } else {
 59968:             JS_ASSERT(index < nvars);
 59968:             index += nargs;
 97297:             names[index].kind = shape.writable() ? VARIABLE : CONSTANT;
 59968:         }
 59968: 
 83221:         if (JSID_IS_ATOM(shape.propid())) {
 97297:             names[index].maybeAtom = JSID_TO_ATOM(shape.propid());
 59968:         } else {
 83221:             JS_ASSERT(JSID_IS_INT(shape.propid()));
100006:             JS_ASSERT(shape.getter() == CallObject::getArgOp);
 97297:             names[index].maybeAtom = NULL;
 59968:         }
 59968:     }
 59968: 
 59968: #ifdef DEBUG
 91237:     for (unsigned i = 0; i < n; i++)
 97297:         JS_ASSERT(names[i].maybeAtom != POISON);
 59968: #endif
 73058: 
 73058:     return true;
 59968: }
 59968: 
 59968: const Shape *
 59968: Bindings::lastArgument() const
 59968: {
 59968:     JS_ASSERT(lastBinding);
 59968: 
 59968:     const js::Shape *shape = lastVariable();
 59968:     if (nvars > 0) {
100006:         while (shape->previous() && shape->getter() != CallObject::getArgOp)
 59968:             shape = shape->previous();
 59968:     }
 59968:     return shape;
 59968: }
 59968: 
 59968: const Shape *
 59968: Bindings::lastVariable() const
 59968: {
 59968:     JS_ASSERT(lastBinding);
 59968:     return lastBinding;
 59968: }
 59968: 
 59968: void
 59968: Bindings::makeImmutable()
 59968: {
 59968:     JS_ASSERT(lastBinding);
 83221:     JS_ASSERT(!lastBinding->inDictionary());
 59968: }
 59968: 
 59968: void
 59968: Bindings::trace(JSTracer *trc)
 59968: {
 64360:     if (lastBinding)
 90409:         MarkShape(trc, &lastBinding, "shape");
 59968: }
 59968: 
 94006: } /* namespace js */
     1: 
 94006: template<XDRMode mode>
 90546: static bool
 94006: XDRScriptConst(XDRState<mode> *xdr, HeapValue *vp)
 90546: {
 90546:     /*
 90546:      * A script constant can be an arbitrary primitive value as they are used
 90546:      * to implement JSOP_LOOKUPSWITCH. But they cannot be objects, see
 90546:      * bug 407186.
 90546:      */
 90546:     enum ConstTag {
 90546:         SCRIPT_INT     = 0,
 90546:         SCRIPT_DOUBLE  = 1,
 97296:         SCRIPT_ATOM    = 2,
 90546:         SCRIPT_TRUE    = 3,
 90546:         SCRIPT_FALSE   = 4,
 90546:         SCRIPT_NULL    = 5,
 90546:         SCRIPT_VOID    = 6
 90546:     };
 90546: 
 90546:     uint32_t tag;
 94006:     if (mode == XDR_ENCODE) {
 90546:         if (vp->isInt32()) {
 90546:             tag = SCRIPT_INT;
 90546:         } else if (vp->isDouble()) {
 90546:             tag = SCRIPT_DOUBLE;
 90546:         } else if (vp->isString()) {
 97296:             tag = SCRIPT_ATOM;
 90546:         } else if (vp->isTrue()) {
 90546:             tag = SCRIPT_TRUE;
 90546:         } else if (vp->isFalse()) {
 90546:             tag = SCRIPT_FALSE;
 90546:         } else if (vp->isNull()) {
 90546:             tag = SCRIPT_NULL;
 90546:         } else {
 90546:             JS_ASSERT(vp->isUndefined());
 90546:             tag = SCRIPT_VOID;
 90546:         }
 90546:     }
 90546: 
 94006:     if (!xdr->codeUint32(&tag))
 90546:         return false;
 90546: 
 90546:     switch (tag) {
 90546:       case SCRIPT_INT: {
 90546:         uint32_t i;
 94006:         if (mode == XDR_ENCODE)
 90546:             i = uint32_t(vp->toInt32());
 94006:         if (!xdr->codeUint32(&i))
 90546:             return JS_FALSE;
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(Int32Value(int32_t(i)));
 90546:         break;
 90546:       }
 90546:       case SCRIPT_DOUBLE: {
 90546:         double d;
 94006:         if (mode == XDR_ENCODE)
 90546:             d = vp->toDouble();
 94006:         if (!xdr->codeDouble(&d))
 90546:             return false;
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(DoubleValue(d));
 90546:         break;
 90546:       }
 97296:       case SCRIPT_ATOM: {
 97296:         JSAtom *atom;
 94006:         if (mode == XDR_ENCODE)
 97296:             atom = &vp->toString()->asAtom();
 97296:         if (!XDRAtom(xdr, &atom))
 90546:             return false;
 94006:         if (mode == XDR_DECODE)
 97296:             vp->init(StringValue(atom));
 90546:         break;
 90546:       }
 90546:       case SCRIPT_TRUE:
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(BooleanValue(true));
 90546:         break;
 90546:       case SCRIPT_FALSE:
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(BooleanValue(false));
 90546:         break;
 90546:       case SCRIPT_NULL:
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(NullValue());
 90546:         break;
 90546:       case SCRIPT_VOID:
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(UndefinedValue());
 90546:         break;
 90546:     }
 90546:     return true;
 90546: }
 90546: 
 94006: template<XDRMode mode>
 94006: bool
 94006: js::XDRScript(XDRState<mode> *xdr, JSScript **scriptp, JSScript *parentScript)
 90546: {
 97298:     /* NB: Keep this in sync with CloneScript. */
 97298: 
 54840:     enum ScriptBits {
 54840:         NoScriptRval,
 54840:         SavedCallerFun,
 54840:         StrictModeCode,
 95099:         ContainsDynamicNameAccess,
 95100:         ArgumentsHasLocalBinding,
 93250:         NeedsArgsObj,
 90856:         OwnFilename,
 95100:         ParentFilename,
 95100:         IsGenerator
 54840:     };
 54840: 
 84755:     uint32_t length, lineno, nslots;
 94572:     uint32_t natoms, nsrcnotes, ntrynotes, nobjects, nregexps, nconsts, nClosedArgs, nClosedVars, i;
 94572:     uint32_t prologLength, version;
 84755:     uint32_t nTypeSets = 0;
 84755:     uint32_t scriptBits = 0;
     1: 
 94006:     JSContext *cx = xdr->cx();
 90546:     JSScript *script;
 94572:     nsrcnotes = ntrynotes = natoms = nobjects = nregexps = nconsts = nClosedArgs = nClosedVars = 0;
 59968:     jssrcnote *notes = NULL;
     1: 
 59968:     /* XDR arguments, local vars, and upvars. */
 93245:     uint16_t nargs, nvars;
 59974: #if defined(DEBUG) || defined(__GNUC__) /* quell GCC overwarning */
 90546:     script = NULL;
 93245:     nargs = nvars = Bindings::BINDING_COUNT_LIMIT;
 59974: #endif
 93245:     uint32_t argsVars;
 94006:     if (mode == XDR_ENCODE) {
 90546:         script = *scriptp;
 94006:         JS_ASSERT_IF(parentScript, parentScript->compartment() == script->compartment());
 90546: 
 95100:         nargs = script->bindings.numArgs();
 95100:         nvars = script->bindings.numVars();
 59968:         argsVars = (nargs << 16) | nvars;
 59968:     }
 94006:     if (!xdr->codeUint32(&argsVars))
 59968:         return false;
 94006:     if (mode == XDR_DECODE) {
 59968:         nargs = argsVars >> 16;
 59968:         nvars = argsVars & 0xFFFF;
 59968:     }
 59974:     JS_ASSERT(nargs != Bindings::BINDING_COUNT_LIMIT);
 59974:     JS_ASSERT(nvars != Bindings::BINDING_COUNT_LIMIT);
 59968: 
 77343:     Bindings bindings(cx);
 99364:     Bindings::AutoRooter bindingsRoot(cx, &bindings);
 97353: 
 93245:     uint32_t nameCount = nargs + nvars;
 59968:     if (nameCount > 0) {
 79410:         LifoAllocScope las(&cx->tempLifoAlloc());
 59968: 
 59968:         /*
 59968:          * To xdr the names we prefix the names with a bitmap descriptor and
 59968:          * then xdr the names as strings. For argument names (indexes below
 59968:          * nargs) the corresponding bit in the bitmap is unset when the name
 59968:          * is null. Such null names are not encoded or decoded. For variable
 59968:          * names (indexes starting from nargs) bitmap's bit is set when the
 59968:          * name is declared as const, not as ordinary var.
 59968:          * */
 91237:         unsigned bitmapLength = JS_HOWMANY(nameCount, JS_BITS_PER_UINT32);
 84755:         uint32_t *bitmap = cx->tempLifoAlloc().newArray<uint32_t>(bitmapLength);
 59968:         if (!bitmap) {
 71371:             js_ReportOutOfMemory(cx);
 59968:             return false;
 59968:         }
 59968: 
 97297:         BindingNames names(cx);
 94006:         if (mode == XDR_ENCODE) {
 73058:             if (!script->bindings.getLocalNameArray(cx, &names))
 59968:                 return false;
 59968:             PodZero(bitmap, bitmapLength);
 91237:             for (unsigned i = 0; i < nameCount; i++) {
 97297:                 if (i < nargs && names[i].maybeAtom)
 59968:                     bitmap[i >> JS_BITS_PER_UINT32_LOG2] |= JS_BIT(i & (JS_BITS_PER_UINT32 - 1));
 59968:             }
 59968:         }
 91237:         for (unsigned i = 0; i < bitmapLength; ++i) {
 94006:             if (!xdr->codeUint32(&bitmap[i]))
 59968:                 return false;
 59968:         }
 59968: 
 91237:         for (unsigned i = 0; i < nameCount; i++) {
 59968:             if (i < nargs &&
 59968:                 !(bitmap[i >> JS_BITS_PER_UINT32_LOG2] & JS_BIT(i & (JS_BITS_PER_UINT32 - 1))))
 59968:             {
 94006:                 if (mode == XDR_DECODE) {
 84755:                     uint16_t dummy;
 59968:                     if (!bindings.addDestructuring(cx, &dummy))
 59968:                         return false;
 59968:                 } else {
 97297:                     JS_ASSERT(!names[i].maybeAtom);
 59968:                 }
 59968:                 continue;
 59968:             }
 59968: 
 99421:             RootedAtom name(cx);
 94006:             if (mode == XDR_ENCODE)
 97297:                 name = names[i].maybeAtom;
 95355:             if (!XDRAtom(xdr, name.address()))
 59968:                 return false;
 94006:             if (mode == XDR_DECODE) {
 59968:                 BindingKind kind = (i < nargs)
 59968:                                    ? ARGUMENT
 93245:                                    : (bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
 59968:                                       JS_BIT(i & (JS_BITS_PER_UINT32 - 1))
 59968:                                      ? CONSTANT
 93245:                                      : VARIABLE);
 59968:                 if (!bindings.add(cx, name, kind))
 59968:                     return false;
 59968:             }
 59968:         }
 77343:     }
 59968: 
 94006:     if (mode == XDR_DECODE) {
 77343:         if (!bindings.ensureShape(cx))
 77343:             return false;
 59968:         bindings.makeImmutable();
 59968:     }
 59968: 
 94006:     if (mode == XDR_ENCODE)
 59220:         length = script->length;
 94006:     if (!xdr->codeUint32(&length))
 34290:         return JS_FALSE;
 34290: 
 94006:     if (mode == XDR_ENCODE) {
 77659:         prologLength = script->mainOffset;
 53848:         JS_ASSERT(script->getVersion() != JSVERSION_UNKNOWN);
 84755:         version = (uint32_t)script->getVersion() | (script->nfixed << 16);
 93548:         lineno = script->lineno;
 84755:         nslots = (uint32_t)script->nslots;
 84755:         nslots = (uint32_t)((script->staticLevel << 16) | script->nslots);
 77659:         natoms = script->natoms;
     1: 
 32723:         notes = script->notes();
 72071:         nsrcnotes = script->numNotes();
     1: 
 97361:         if (script->hasConsts())
 94572:             nconsts = script->consts()->length;
 97361:         if (script->hasObjects())
 32723:             nobjects = script->objects()->length;
 97361:         if (script->hasRegexps())
 32723:             nregexps = script->regexps()->length;
 97361:         if (script->hasTrynotes())
 32723:             ntrynotes = script->trynotes()->length;
 95023:         nClosedArgs = script->numClosedArgs();
 95023:         nClosedVars = script->numClosedVars();
 54840: 
 77343:         nTypeSets = script->nTypeSets;
 77343: 
 54840:         if (script->noScriptRval)
 54840:             scriptBits |= (1 << NoScriptRval);
 54840:         if (script->savedCallerFun)
 54840:             scriptBits |= (1 << SavedCallerFun);
 54840:         if (script->strictModeCode)
 54840:             scriptBits |= (1 << StrictModeCode);
 95099:         if (script->bindingsAccessedDynamically)
 95099:             scriptBits |= (1 << ContainsDynamicNameAccess);
 95100:         if (script->argumentsHasLocalBinding())
 95100:             scriptBits |= (1 << ArgumentsHasLocalBinding);
 93250:         if (script->analyzedArgsUsage() && script->needsArgsObj())
 93250:             scriptBits |= (1 << NeedsArgsObj);
 90856:         if (script->filename) {
 94006:             scriptBits |= (parentScript && parentScript->filename == script->filename)
 94006:                           ? (1 << ParentFilename)
 94006:                           : (1 << OwnFilename);
 90856:         }
 95100:         if (script->isGenerator)
 95100:             scriptBits |= (1 << IsGenerator);
 90856: 
 59962:         JS_ASSERT(!script->compileAndGo);
 59962:         JS_ASSERT(!script->hasSingletons);
     1:     }
     1: 
 94006:     if (!xdr->codeUint32(&prologLength))
     1:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&version))
     1:         return JS_FALSE;
     1: 
  3235:     /*
 59968:      * To fuse allocations, we need srcnote, atom, objects, regexp, and trynote
 59968:      * counts early.
  3235:      */
 94006:     if (!xdr->codeUint32(&natoms))
  3235:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nsrcnotes))
     1:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&ntrynotes))
     1:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nobjects))
  3235:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nregexps))
  3235:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nconsts))
 48470:         return JS_FALSE;
 94572:     if (!xdr->codeUint32(&nClosedArgs))
 94572:         return JS_FALSE;
 94572:     if (!xdr->codeUint32(&nClosedVars))
 54840:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nTypeSets))
 77343:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&scriptBits))
 54840:         return JS_FALSE;
     1: 
 94006:     if (mode == XDR_DECODE) {
 61450:         /* Note: version is packed into the 32b space with another 16b value. */
 61450:         JSVersion version_ = JSVersion(version & JS_BITMASK(16));
 91237:         JS_ASSERT((version_ & VersionFlags::FULL_MASK) == unsigned(version_));
 93245:         script = JSScript::NewScript(cx, length, nsrcnotes, natoms, nobjects,
 98173:                                      nregexps, ntrynotes, nconsts, nClosedArgs,
 77343:                                      nClosedVars, nTypeSets, version_);
     1:         if (!script)
     1:             return JS_FALSE;
  3235: 
 59968:         script->bindings.transfer(cx, &bindings);
 77659:         JS_ASSERT(!script->mainOffset);
 77659:         script->mainOffset = prologLength;
 84755:         script->nfixed = uint16_t(version >> 16);
     1: 
     1:         /* If we know nsrcnotes, we allocated space for notes in script. */
 32723:         notes = script->notes();
     1:         *scriptp = script;
 54840: 
 54840:         if (scriptBits & (1 << NoScriptRval))
 54840:             script->noScriptRval = true;
 54840:         if (scriptBits & (1 << SavedCallerFun))
 54840:             script->savedCallerFun = true;
 54840:         if (scriptBits & (1 << StrictModeCode))
 54840:             script->strictModeCode = true;
 95099:         if (scriptBits & (1 << ContainsDynamicNameAccess))
 95099:             script->bindingsAccessedDynamically = true;
 95100:         if (scriptBits & (1 << ArgumentsHasLocalBinding)) {
 95100:             PropertyName *arguments = cx->runtime->atomState.argumentsAtom;
100006:             unsigned slot;
100006:             DebugOnly<BindingKind> kind = script->bindings.lookup(cx, arguments, &slot);
 95100:             JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
100006:             script->setArgumentsHasLocalBinding(slot);
 95100:         }
 93250:         if (scriptBits & (1 << NeedsArgsObj))
 93250:             script->setNeedsArgsObj(true);
 95100:         if (scriptBits & (1 << IsGenerator))
 95100:             script->isGenerator = true;
     1:     }
     1: 
 94006:     JS_STATIC_ASSERT(sizeof(jsbytecode) == 1);
 94006:     JS_STATIC_ASSERT(sizeof(jssrcnote) == 1);
 94006:     if (!xdr->codeBytes(script->code, length) ||
 94006:         !xdr->codeBytes(notes, nsrcnotes) ||
 94006:         !xdr->codeUint32(&lineno) ||
 94006:         !xdr->codeUint32(&nslots)) {
 90546:         return false;
     1:     }
     1: 
 90856:     if (scriptBits & (1 << OwnFilename)) {
 94006:         const char *filename;
 94006:         if (mode == XDR_ENCODE)
 94006:             filename = script->filename;
 94006:         if (!xdr->codeCString(&filename))
 90546:             return false;
 94006:         if (mode == XDR_DECODE) {
 94006:             script->filename = SaveScriptFilename(cx, filename);
 90856:             if (!script->filename)
 90856:                 return false;
 93548:         }
 94006:     } else if (scriptBits & (1 << ParentFilename)) {
 94006:         JS_ASSERT(parentScript);
 94006:         if (mode == XDR_DECODE)
 94006:             script->filename = parentScript->filename;
 64372:     }
 64301: 
 94006:     if (mode == XDR_DECODE) {
 93548:         script->lineno = lineno;
 93548:         script->nslots = uint16_t(nslots);
 93548:         script->staticLevel = uint16_t(nslots >> 16);
 94006:         xdr->initScriptPrincipals(script);
     1:     }
     1: 
  3235:     for (i = 0; i != natoms; ++i) {
 94934:         if (mode == XDR_DECODE) {
 94934:             JSAtom *tmp = NULL;
 94934:             if (!XDRAtom(xdr, &tmp))
 90546:                 return false;
 94934:             script->atoms[i].init(tmp);
 94934:         } else {
 94934:             JSAtom *tmp = script->atoms[i];
 94934:             if (!XDRAtom(xdr, &tmp))
 94934:                 return false;
 94934:         }
  3235:     }
  1825: 
     1:     /*
  3235:      * Here looping from 0-to-length to xdr objects is essential. It ensures
 18308:      * that block objects from the script->objects array will be written and
 28093:      * restored in the outer-to-inner order. js_XDRBlockObject relies on this
 28093:      * to restore the parent chain.
     1:      */
  3235:     for (i = 0; i != nobjects; ++i) {
 82129:         HeapPtr<JSObject> *objp = &script->objects()->vector[i];
 84755:         uint32_t isBlock;
 94006:         if (mode == XDR_ENCODE) {
 86483:             JSObject *obj = *objp;
 86483:             JS_ASSERT(obj->isFunction() || obj->isStaticBlock());
 86483:             isBlock = obj->isBlock() ? 1 : 0;
 28093:         }
 94006:         if (!xdr->codeUint32(&isBlock))
 90546:             return false;
 86483:         if (isBlock == 0) {
 82129:             JSObject *tmp = *objp;
 94006:             if (!XDRInterpretedFunction(xdr, &tmp, parentScript))
 90546:                 return false;
 86483:             *objp = tmp;
 28093:         } else {
 28093:             JS_ASSERT(isBlock == 1);
 86483:             StaticBlockObject *tmp = static_cast<StaticBlockObject *>(objp->get());
 90546:             if (!XDRStaticBlockObject(xdr, script, &tmp))
 90546:                 return false;
 86483:             *objp = tmp;
 28093:         }
     1:     }
  3235:     for (i = 0; i != nregexps; ++i) {
 90546:         if (!XDRScriptRegExpObject(xdr, &script->regexps()->vector[i]))
 90546:             return false;
     1:     }
 54840:     for (i = 0; i != nClosedArgs; ++i) {
 94572:         if (!xdr->codeUint32(&script->closedArgs()->vector[i]))
 90546:             return false;
 54840:     }
 54840:     for (i = 0; i != nClosedVars; ++i) {
 94572:         if (!xdr->codeUint32(&script->closedVars()->vector[i]))
 90546:             return false;
 54840:     }
     1: 
  3235:     if (ntrynotes != 0) {
  1825:         /*
  3235:          * We combine tn->kind and tn->stackDepth when serializing as XDR is not
  1825:          * efficient when serializing small integer types.
  1825:          */
  3235:         JSTryNote *tn, *tnfirst;
 84755:         uint32_t kindAndDepth;
 84755:         JS_STATIC_ASSERT(sizeof(tn->kind) == sizeof(uint8_t));
 84755:         JS_STATIC_ASSERT(sizeof(tn->stackDepth) == sizeof(uint16_t));
     1: 
 32723:         tnfirst = script->trynotes()->vector;
 32723:         JS_ASSERT(script->trynotes()->length == ntrynotes);
  3235:         tn = tnfirst + ntrynotes;
  3235:         do {
  3235:             --tn;
 94006:             if (mode == XDR_ENCODE) {
 84755:                 kindAndDepth = (uint32_t(tn->kind) << 16)
 84755:                                | uint32_t(tn->stackDepth);
  3235:             }
 94006:             if (!xdr->codeUint32(&kindAndDepth) ||
 94006:                 !xdr->codeUint32(&tn->start) ||
 94006:                 !xdr->codeUint32(&tn->length)) {
 90546:                 return false;
     1:             }
 94006:             if (mode == XDR_DECODE) {
 84755:                 tn->kind = uint8_t(kindAndDepth >> 16);
 84755:                 tn->stackDepth = uint16_t(kindAndDepth);
     1:             }
  3235:         } while (tn != tnfirst);
  3235:     }
     1: 
 90546:     if (nconsts) {
 90546:         HeapValue *vector = script->consts()->vector;
 48470:         for (i = 0; i != nconsts; ++i) {
 90546:             if (!XDRScriptConst(xdr, &vector[i]))
 90546:                 return false;
 90546:         }
 48470:     }
 48470: 
 94006:     if (mode == XDR_DECODE) {
 90546:         if (cx->hasRunOption(JSOPTION_PCCOUNT))
 94574:             (void) script->initScriptCounts(cx);
 90546:         *scriptp = script;
 90546:     }
 82134: 
 90546:     return true;
     1: }
     1: 
 94006: template bool
 94006: js::XDRScript(XDRState<XDR_ENCODE> *xdr, JSScript **scriptp, JSScript *parentScript);
     1: 
 94006: template bool
 94006: js::XDRScript(XDRState<XDR_DECODE> *xdr, JSScript **scriptp, JSScript *parentScript);
 90546: 
 71699: bool
 94574: JSScript::initScriptCounts(JSContext *cx)
 71699: {
 95113:     JS_ASSERT(!hasScriptCounts);
 82134: 
 94574:     size_t n = 0;
 82134: 
 82134:     jsbytecode *pc, *next;
 82134:     for (pc = code; pc < code + length; pc = next) {
 94574:         n += PCCounts::numCounts(JSOp(*pc));
 84195:         next = pc + GetBytecodeLength(pc);
 82134:     }
 82134: 
 94574:     size_t bytes = (length * sizeof(PCCounts)) + (n * sizeof(double));
 82134:     char *cursor = (char *) cx->calloc_(bytes);
 82134:     if (!cursor)
 71699:         return false;
 82134: 
 95113:     /* Create compartment's scriptCountsMap if necessary. */
 95113:     ScriptCountsMap *map = compartment()->scriptCountsMap;
 95113:     if (!map) {
 95113:         map = cx->new_<ScriptCountsMap>();
 95113:         if (!map || !map->init()) {
 95113:             cx->free_(cursor);
 95113:             cx->delete_(map);
 95113:             return false;
 95113:         }
 95113:         compartment()->scriptCountsMap = map;
 95113:     }
 95113: 
 82134:     DebugOnly<char *> base = cursor;
 82134: 
 95113:     ScriptCounts scriptCounts;
 94574:     scriptCounts.pcCountsVector = (PCCounts *) cursor;
 94574:     cursor += length * sizeof(PCCounts);
 82134: 
 82134:     for (pc = code; pc < code + length; pc = next) {
 94574:         scriptCounts.pcCountsVector[pc - code].counts = (double *) cursor;
 94574:         size_t capacity = PCCounts::numCounts(JSOp(*pc));
 82134: #ifdef DEBUG
 94574:         scriptCounts.pcCountsVector[pc - code].capacity = capacity;
 82134: #endif
 82134:         cursor += capacity * sizeof(double);
 84195:         next = pc + GetBytecodeLength(pc);
 82134:     }
 82134: 
 95113:     if (!map->putNew(this, scriptCounts)) {
 95113:         cx->free_(cursor);
 95113:         cx->delete_(map);
 95113:         return false;
 95113:     }
 95113:     hasScriptCounts = true; // safe to set this;  we can't fail after this point
 95113: 
 82134:     JS_ASSERT(size_t(cursor - base) == bytes);
 82134: 
 84803:     /* Enable interrupts in any interpreter frames running on this script. */
 84803:     InterpreterFrames *frames;
 88135:     for (frames = cx->runtime->interpreterFrames; frames; frames = frames->older)
 84803:         frames->enableInterruptsIfRunning(this);
 84803: 
 71699:     return true;
 71699: }
 71699: 
 95113: js::PCCounts
 95113: JSScript::getPCCounts(jsbytecode *pc) {
 95113:     JS_ASSERT(hasScriptCounts);
 95113:     JS_ASSERT(size_t(pc - code) < length);
 95113:     ScriptCountsMap *map = compartment()->scriptCountsMap;
 95113:     JS_ASSERT(map);
 95113:     ScriptCountsMap::Ptr p = map->lookup(this);
 95113:     JS_ASSERT(p);
 95113:     return p->value.pcCountsVector[pc - code];
 95113: }
 95113: 
 95113: ScriptCounts
 95113: JSScript::releaseScriptCounts()
 95113: {
 95113:     JS_ASSERT(hasScriptCounts);
 95113:     ScriptCountsMap *map = compartment()->scriptCountsMap;
 95113:     JS_ASSERT(map);
 95113:     ScriptCountsMap::Ptr p = map->lookup(this);
 95113:     JS_ASSERT(p);
 95113:     ScriptCounts counts = p->value;
 95113:     map->remove(p);
 95113:     hasScriptCounts = false;
 95113:     return counts;
 95113: }
 95113: 
 71702: void
 94740: JSScript::destroyScriptCounts(FreeOp *fop)
 71702: {
 95113:     if (hasScriptCounts) {
 95113:         ScriptCounts scriptCounts = releaseScriptCounts();
 94740:         fop->free_(scriptCounts.pcCountsVector);
 71702:     }
 71702: }
 71702: 
 95139: bool
 95139: JSScript::setSourceMap(JSContext *cx, jschar *sourceMap)
 95139: {
 95139:     JS_ASSERT(!hasSourceMap);
 95139: 
 95139:     /* Create compartment's sourceMapMap if necessary. */
 95139:     SourceMapMap *map = compartment()->sourceMapMap;
 95139:     if (!map) {
 95139:         map = cx->new_<SourceMapMap>();
 95139:         if (!map || !map->init()) {
 95139:             cx->delete_(map);
 95139:             return false;
 95139:         }
 95139:         compartment()->sourceMapMap = map;
 95139:     }
 95139: 
 95139:     if (!map->putNew(this, sourceMap)) {
 95139:         cx->delete_(map);
 95139:         return false;
 95139:     }
 95139:     hasSourceMap = true; // safe to set this;  we can't fail after this point
 95139: 
 95139:     return true;
 95139: }
 95139: 
 95139: jschar *
 95139: JSScript::getSourceMap() {
 95139:     JS_ASSERT(hasSourceMap);
 95139:     SourceMapMap *map = compartment()->sourceMapMap;
 95139:     JS_ASSERT(map);
 95139:     SourceMapMap::Ptr p = map->lookup(this);
 95139:     JS_ASSERT(p);
 95139:     return p->value;
 95139: }
 95139: 
 95139: jschar *
 95139: JSScript::releaseSourceMap()
 95139: {
 95139:     JS_ASSERT(hasSourceMap);
 95139:     SourceMapMap *map = compartment()->sourceMapMap;
 95139:     JS_ASSERT(map);
 95139:     SourceMapMap::Ptr p = map->lookup(this);
 95139:     JS_ASSERT(p);
 95139:     jschar *sourceMap = p->value;
 95139:     map->remove(p);
 95139:     hasSourceMap = false;
 95139:     return sourceMap;
 95139: }
 95139: 
 95139: void
 95139: JSScript::destroySourceMap(FreeOp *fop)
 95139: {
 95139:     if (hasSourceMap)
 95139:         fop->free_(releaseSourceMap());
 95139: }
 95139: 
     1: /*
     1:  * Shared script filename management.
     1:  */
     1: 
 94202: const char *
 94202: js::SaveScriptFilename(JSContext *cx, const char *filename)
 67927: {
 95295:     if (!filename)
 95295:         return NULL;
 95295: 
 97463:     JSRuntime *rt = cx->runtime;
     1: 
 97463:     ScriptFilenameTable::AddPtr p = rt->scriptFilenameTable.lookupForAdd(filename);
 73899:     if (!p) {
 73899:         size_t size = offsetof(ScriptFilenameEntry, filename) + strlen(filename) + 1;
 73899:         ScriptFilenameEntry *entry = (ScriptFilenameEntry *) cx->malloc_(size);
 73899:         if (!entry)
 73899:             return NULL;
 73899:         entry->marked = false;
 73899:         strcpy(entry->filename, filename);
     1: 
 97463:         if (!rt->scriptFilenameTable.add(p, entry)) {
 73899:             Foreground::free_(entry);
 67927:             JS_ReportOutOfMemory(cx);
     1:             return NULL;
 67927:         }
     1:     }
     1: 
 90843:     ScriptFilenameEntry *sfe = *p;
 90843: #ifdef JSGC_INCREMENTAL
 90843:     /*
 90843:      * During the IGC we need to ensure that filename is marked whenever it is
 90843:      * accessed even if the name was already in the table. At this point old
 90843:      * scripts or exceptions pointing to the filename may no longer be
 90843:      * reachable.
 90843:      */
 97851:     if (rt->gcIncrementalState == MARK && rt->gcIsFull)
 90843:         sfe->marked = true;
 90843: #endif
 90843: 
 90843:     return sfe->filename;
     1: }
     1: 
     1: void
 97463: js::SweepScriptFilenames(JSRuntime *rt)
     1: {
 97463:     JS_ASSERT(rt->gcIsFull);
 97463:     ScriptFilenameTable &table = rt->scriptFilenameTable;
 73899:     for (ScriptFilenameTable::Enum e(table); !e.empty(); e.popFront()) {
 73899:         ScriptFilenameEntry *entry = e.front();
 73899:         if (entry->marked) {
 73899:             entry->marked = false;
 97463:         } else if (!rt->gcKeepAtoms) {
 73899:             Foreground::free_(entry);
 73899:             e.removeFront();
     1:         }
     1:     }
     1: }
     1: 
 93970: void
 97463: js::FreeScriptFilenames(JSRuntime *rt)
 93970: {
 97463:     ScriptFilenameTable &table = rt->scriptFilenameTable;
 93970:     for (ScriptFilenameTable::Enum e(table); !e.empty(); e.popFront())
 93970:         Foreground::free_(e.front());
 93970: 
 93970:     table.clear();
 93970: }
 93970: 
  3235: /*
 94572:  * JSScript::data has a complex, manually-controlled, memory layout.
  3235:  *
 94572:  * First are some optional array headers.  They are optional because they
 94572:  * often aren't needed, i.e. the corresponding arrays often have zero elements.
 97839:  * Each header has a bit in JSScript::hasArrayBits that indicates if it's
 97839:  * present within |data|;  from this the offset of each present array header
 97839:  * can be computed.  Each header has an accessor function in JSScript that
 97839:  * encapsulates this offset computation.
  3235:  *
 97839:  * Array type       Array elements  Accessor
 97839:  * ----------       --------------  --------
 97839:  * ConstArray       Consts          consts()
 97839:  * ObjectArray      Objects         objects()
 97839:  * ObjectArray      Regexps         regexps()
 97839:  * TryNoteArray     Try notes       trynotes()
 97839:  * ClosedSlotArray  ClosedArgs      closedArgs()
 97839:  * ClosedSlotArray  ClosedVars      closedVars()
  3235:  *
 94572:  * Then are the elements of several arrays.
 94572:  * - Most of these arrays have headers listed above (if present).  For each of
 94572:  *   these, the array pointer and the array length is stored in the header.
 94572:  * - The remaining arrays have pointers and lengths that are stored directly in
 94572:  *   JSScript.  This is because, unlike the others, they are nearly always
 94572:  *   non-zero length and so the optional-header space optimization isn't
 94572:  *   worthwhile.
 94572:  *
 94572:  * Array elements   Pointed to by         Length
 94572:  * --------------   -------------         ------
 94572:  * Consts           consts()->vector      consts()->length
 94572:  * Atoms            atoms                 natoms
 94572:  * Objects          objects()->vector     objects()->length
 94572:  * Regexps          regexps()->vector     regexps()->length
 94572:  * Try notes        trynotes()->vector    trynotes()->length
 94572:  * Closed args      closedArgs()->vector  closedArgs()->length
 94572:  * Closed vars      closedVars()->vector  closedVars()->length
 94572:  * Bytecodes        code                  length
 94572:  * Source notes     notes()               numNotes() * sizeof(jssrcnote)
 94572:  *
 94572:  * IMPORTANT: This layout has two key properties.
 94572:  * - It ensures that everything has sufficient alignment;  in particular, the
 94572:  *   consts() elements need jsval alignment.
 94572:  * - It ensures there are no gaps between elements, which saves space and makes
 94572:  *   manual layout easy.  In particular, in the second part, arrays with larger
 94572:  *   elements precede arrays with smaller elements.
 94572:  *
 94572:  * The following static assertions check these properties.
  3235:  */
 94572: 
 94572: #define KEEPS_JSVAL_ALIGNMENT(T) \
 94572:     (JS_ALIGNMENT_OF(jsval) % JS_ALIGNMENT_OF(T) == 0 && \
 94572:      sizeof(T) % sizeof(jsval) == 0)
 94572: 
 94572: #define HAS_JSVAL_ALIGNMENT(T) \
 94572:     (JS_ALIGNMENT_OF(jsval) == JS_ALIGNMENT_OF(T) && \
 94572:      sizeof(T) == sizeof(jsval))
 94572: 
 94572: #define NO_PADDING_BETWEEN_ENTRIES(T1, T2) \
 94572:     (JS_ALIGNMENT_OF(T1) % JS_ALIGNMENT_OF(T2) == 0)
 94572: 
 94572: /*
 94572:  * These assertions ensure that there is no padding between the array headers,
 94572:  * and also that the consts() elements (which follow immediately afterward) are
 94572:  * jsval-aligned.  (There is an assumption that |data| itself is jsval-aligned;
 94572:  * we check this below).
 94572:  */
 97362: JS_STATIC_ASSERT(KEEPS_JSVAL_ALIGNMENT(ConstArray));
 97362: JS_STATIC_ASSERT(KEEPS_JSVAL_ALIGNMENT(ObjectArray));       /* there are two of these */
 97362: JS_STATIC_ASSERT(KEEPS_JSVAL_ALIGNMENT(TryNoteArray));
 94572: JS_STATIC_ASSERT(KEEPS_JSVAL_ALIGNMENT(ClosedSlotArray));   /* there are two of these */
 94572: 
 94572: /* These assertions ensure there is no padding required between array elements. */
 94572: JS_STATIC_ASSERT(HAS_JSVAL_ALIGNMENT(HeapValue));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(HeapValue, JSAtom *));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(JSAtom *, HeapPtrObject));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(HeapPtrObject, HeapPtrObject));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(HeapPtrObject, JSTryNote));
 98173: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(JSTryNote, uint32_t));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(uint32_t, uint32_t));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(uint32_t, jsbytecode));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(jsbytecode, jssrcnote));
  3235: 
 97298: static inline size_t
 97298: ScriptDataSize(JSContext *cx, uint32_t length, uint32_t nsrcnotes, uint32_t natoms,
 97298:                uint32_t nobjects, uint32_t nregexps, uint32_t ntrynotes, uint32_t nconsts,
 98173:                uint16_t nClosedArgs, uint16_t nClosedVars)
     1: {
 94572:     size_t size = 0;
 94572: 
 94572:     if (nconsts != 0)
 97362:         size += sizeof(ConstArray) + nconsts * sizeof(Value);
 94572:     size += sizeof(JSAtom *) * natoms;
  3235:     if (nobjects != 0)
 97362:         size += sizeof(ObjectArray) + nobjects * sizeof(JSObject *);
  3235:     if (nregexps != 0)
 97362:         size += sizeof(ObjectArray) + nregexps * sizeof(JSObject *);
  3235:     if (ntrynotes != 0)
 97362:         size += sizeof(TryNoteArray) + ntrynotes * sizeof(JSTryNote);
 94572:     if (nClosedArgs != 0)
 94572:         size += sizeof(ClosedSlotArray) + nClosedArgs * sizeof(uint32_t);
 94572:     if (nClosedVars != 0)
 94572:         size += sizeof(ClosedSlotArray) + nClosedVars * sizeof(uint32_t);
  3235: 
 94572:     size += length * sizeof(jsbytecode);
 94572:     size += nsrcnotes * sizeof(jssrcnote);
 97298:     return size;
 97298: }
 77659: 
 97298: static inline uint8_t *
 97298: AllocScriptData(JSContext *cx, size_t size)
 97298: {
 93833:     uint8_t *data = static_cast<uint8_t *>(cx->calloc_(JS_ROUNDUP(size, sizeof(Value))));
 77659:     if (!data)
 77659:         return NULL;
 48470: 
 97298:     JS_ASSERT(size_t(data) % sizeof(Value) == 0);
 97298:     return data;
 97298: }
 97298: 
 97298: JSScript *
 97298: JSScript::NewScript(JSContext *cx, uint32_t length, uint32_t nsrcnotes, uint32_t natoms,
 98173:                     uint32_t nobjects, uint32_t nregexps, uint32_t ntrynotes, uint32_t nconsts,
 97298:                     uint16_t nClosedArgs, uint16_t nClosedVars, uint32_t nTypeSets, JSVersion version)
 97298: {
 97298:     size_t size = ScriptDataSize(cx, length, nsrcnotes, natoms, nobjects, nregexps,
 98173:                                  ntrynotes, nconsts, nClosedArgs, nClosedVars);
 97298: 
 97298:     uint8_t *data = AllocScriptData(cx, size);
 97298:     if (!data)
 97298:         return NULL;
 97298: 
 77659:     JSScript *script = js_NewGCScript(cx);
 77659:     if (!script) {
 77659:         Foreground::free_(data);
     1:         return NULL;
 77659:     }
 53391: 
 40229:     PodZero(script);
 77659:     script->data  = data;
     1:     script->length = length;
 61450:     script->version = version;
 77343:     new (&script->bindings) Bindings(cx);
  3235: 
 84755:     uint8_t *cursor = data;
 94572:     if (nconsts != 0) {
 97839:         script->setHasArray(CONSTS);
 97362:         cursor += sizeof(ConstArray);
 94572:     }
  3235:     if (nobjects != 0) {
 97839:         script->setHasArray(OBJECTS);
 97362:         cursor += sizeof(ObjectArray);
  3235:     }
  3235:     if (nregexps != 0) {
 97839:         script->setHasArray(REGEXPS);
 97362:         cursor += sizeof(ObjectArray);
  3235:     }
  3235:     if (ntrynotes != 0) {
 97839:         script->setHasArray(TRYNOTES);
 97362:         cursor += sizeof(TryNoteArray);
  3235:     }
 94572:     if (nClosedArgs != 0) {
 97839:         script->setHasArray(CLOSED_ARGS);
 94572:         cursor += sizeof(ClosedSlotArray);
 94572:     }
 94572:     if (nClosedVars != 0) {
 97839:         script->setHasArray(CLOSED_VARS);
 94572:         cursor += sizeof(ClosedSlotArray);
 48470:     }
  3235: 
 77659:     if (nconsts != 0) {
 86976:         JS_ASSERT(reinterpret_cast<uintptr_t>(cursor) % sizeof(jsval) == 0);
 77659:         script->consts()->length = nconsts;
 82129:         script->consts()->vector = (HeapValue *)cursor;
 77659:         cursor += nconsts * sizeof(script->consts()->vector[0]);
 77659:     }
 77659: 
  3235:     if (natoms != 0) {
 77659:         script->natoms = natoms;
 94934:         script->atoms = reinterpret_cast<HeapPtrAtom *>(cursor);
 77659:         cursor += natoms * sizeof(script->atoms[0]);
  3235:     }
 17218: 
  3235:     if (nobjects != 0) {
 32723:         script->objects()->length = nobjects;
 82129:         script->objects()->vector = (HeapPtr<JSObject> *)cursor;
 77659:         cursor += nobjects * sizeof(script->objects()->vector[0]);
  3235:     }
 18308: 
  3235:     if (nregexps != 0) {
 32723:         script->regexps()->length = nregexps;
 82129:         script->regexps()->vector = (HeapPtr<JSObject> *)cursor;
 77659:         cursor += nregexps * sizeof(script->regexps()->vector[0]);
  3235:     }
 18308: 
  3235:     if (ntrynotes != 0) {
 32723:         script->trynotes()->length = ntrynotes;
 77659:         script->trynotes()->vector = reinterpret_cast<JSTryNote *>(cursor);
 77659:         size_t vectorSize = ntrynotes * sizeof(script->trynotes()->vector[0]);
  3235: #ifdef DEBUG
  3235:         memset(cursor, 0, vectorSize);
  3235: #endif
  3235:         cursor += vectorSize;
  3235:     }
  3235: 
 94572:     if (nClosedArgs != 0) {
 94572:         script->closedArgs()->length = nClosedArgs;
 94572:         script->closedArgs()->vector = reinterpret_cast<uint32_t *>(cursor);
 94572:         cursor += nClosedArgs * sizeof(script->closedArgs()->vector[0]);
 94572:     }
 94572: 
 94572:     if (nClosedVars != 0) {
 94572:         script->closedVars()->length = nClosedVars;
 94572:         script->closedVars()->vector = reinterpret_cast<uint32_t *>(cursor);
 94572:         cursor += nClosedVars * sizeof(script->closedVars()->vector[0]);
 54840:     }
 54840: 
 77343:     JS_ASSERT(nTypeSets <= UINT16_MAX);
 84755:     script->nTypeSets = uint16_t(nTypeSets);
 77343: 
 77659:     script->code = (jsbytecode *)cursor;
 77659:     JS_ASSERT(cursor + length * sizeof(jsbytecode) + nsrcnotes * sizeof(jssrcnote) == data + size);
 53391: 
 77343: #ifdef DEBUG
 80026:     script->id_ = 0;
 77343: #endif
 77343: 
 61450:     JS_ASSERT(script->getVersion() == version);
     1:     return script;
     1: }
     1: 
  8444: JSScript *
 80966: JSScript::NewScriptFromEmitter(JSContext *cx, BytecodeEmitter *bce)
     1: {
 84755:     uint32_t mainLength, prologLength, nfixed;
 99421:     Rooted<JSScript*> script(cx);
     1:     const char *filename;
 13702:     JSFunction *fun;
     1: 
  3235:     /* The counts of indexed things must be checked during code generation. */
 80964:     JS_ASSERT(bce->atomIndices->count() <= INDEX_LIMIT);
 80964:     JS_ASSERT(bce->objectList.length <= INDEX_LIMIT);
 80964:     JS_ASSERT(bce->regexpList.length <= INDEX_LIMIT);
  3235: 
 80965:     mainLength = bce->offset();
 80965:     prologLength = bce->prologOffset();
 34290: 
 98445:     if (!bce->sc->bindings.ensureShape(cx))
 77343:         return NULL;
 77343: 
 84755:     uint32_t nsrcnotes = uint32_t(bce->countFinalSourceNotes());
 84755:     uint16_t nClosedArgs = uint16_t(bce->closedArgs.length());
 80964:     JS_ASSERT(nClosedArgs == bce->closedArgs.length());
 84755:     uint16_t nClosedVars = uint16_t(bce->closedVars.length());
 80964:     JS_ASSERT(nClosedVars == bce->closedVars.length());
 54840:     script = NewScript(cx, prologLength + mainLength, nsrcnotes,
 80964:                        bce->atomIndices->count(), bce->objectList.length,
 93245:                        bce->regexpList.length, bce->ntrynotes, bce->constList.length(),
 98173:                        nClosedArgs, nClosedVars, bce->typesetCount, bce->version());
     1:     if (!script)
     1:         return NULL;
     1: 
 98445:     bce->sc->bindings.makeImmutable();
 71359: 
 77659:     JS_ASSERT(script->mainOffset == 0);
 77659:     script->mainOffset = prologLength;
 87623:     PodCopy<jsbytecode>(script->code, bce->prologBase(), prologLength);
 87623:     PodCopy<jsbytecode>(script->main(), bce->base(), mainLength);
 98476:     nfixed = bce->sc->inFunction ? bce->sc->bindings.numVars() : 0;
 16072:     JS_ASSERT(nfixed < SLOTNO_LIMIT);
 84755:     script->nfixed = uint16_t(nfixed);
 94934:     InitAtomMap(cx, bce->atomIndices.getMap(), script->atoms);
     1: 
 80964:     filename = bce->parser->tokenStream.getFilename();
     1:     if (filename) {
 67927:         script->filename = SaveScriptFilename(cx, filename);
     1:         if (!script->filename)
 77659:             return NULL;
     1:     }
 80964:     script->lineno = bce->firstLine;
 80964:     if (script->nfixed + bce->maxStackDepth >= JS_BIT(16)) {
 80965:         ReportCompileErrorNumber(cx, bce->tokenStream(), NULL, JSREPORT_ERROR, JSMSG_NEED_DIET,
 80965:                                  "script");
 77659:         return NULL;
 18308:     }
 80964:     script->nslots = script->nfixed + bce->maxStackDepth;
 98445:     script->staticLevel = uint16_t(bce->sc->staticLevel);
 80964:     script->principals = bce->parser->principals;
 84691: 
  6561:     if (script->principals)
 91900:         JS_HoldPrincipals(script->principals);
     1: 
 84691:     /* Establish invariant: principals implies originPrincipals. */
 84691:     script->originPrincipals = bce->parser->originPrincipals;
 84691:     if (!script->originPrincipals)
 84691:         script->originPrincipals = script->principals;
 84691:     if (script->originPrincipals)
 91900:         JS_HoldPrincipals(script->originPrincipals);
 84691: 
 95139:     jschar *sourceMap = (jschar *) bce->parser->tokenStream.releaseSourceMap();
 95139:     if (sourceMap) {
 95139:         if (!script->setSourceMap(cx, sourceMap)) {
 95139:             cx->free_(sourceMap);
 95139:             return NULL;
 95139:         }
 95139:     }
 74581: 
 80964:     if (!FinishTakingSrcNotes(cx, bce, script->notes()))
 77659:         return NULL;
 80964:     if (bce->ntrynotes != 0)
 80964:         FinishTakingTryNotes(bce, script->trynotes());
 80964:     if (bce->objectList.length != 0)
 80964:         bce->objectList.finish(script->objects());
 80964:     if (bce->regexpList.length != 0)
 80964:         bce->regexpList.finish(script->regexps());
 80964:     if (bce->constList.length() != 0)
 80964:         bce->constList.finish(script->consts());
 98687:     script->strictModeCode = bce->sc->inStrictMode();
 98464:     if (bce->parser->compileAndGo) {
 52825:         script->compileAndGo = true;
 80964:         const StackFrame *fp = bce->parser->callerFrame;
 75521:         if (fp && fp->isFunctionFrame())
 75521:             script->savedCallerFun = true;
 75521:     }
 98687:     script->bindingsAccessedDynamically = bce->sc->bindingsAccessedDynamically();
 98479:     script->hasSingletons = bce->hasSingletons;
 98921: #ifdef JS_METHODJIT
 98921:     if (cx->compartment->debugMode())
 98921:         script->debugMode = true;
 98921: #endif
     1: 
100006:     if (bce->sc->inFunction) {
 98687:         if (bce->sc->funArgumentsHasLocalBinding()) {
100006:             // This must precede the script->bindings.transfer() call below.
100006:             script->setArgumentsHasLocalBinding(bce->sc->argumentsLocalSlot());
 98687:             if (bce->sc->funDefinitelyNeedsArgsObj())
 93250:                 script->setNeedsArgsObj(true);
 98687:         } else {
 98687:             JS_ASSERT(!bce->sc->funDefinitelyNeedsArgsObj());
 98687:         }
100006:     } else {
100006:         JS_ASSERT(!bce->sc->funArgumentsHasLocalBinding());
100006:         JS_ASSERT(!bce->sc->funDefinitelyNeedsArgsObj());
100006:     }
 93250: 
 94572:     if (nClosedArgs)
 94572:         PodCopy<uint32_t>(script->closedArgs()->vector, &bce->closedArgs[0], nClosedArgs);
 94572:     if (nClosedVars)
 94572:         PodCopy<uint32_t>(script->closedVars()->vector, &bce->closedVars[0], nClosedVars);
 54840: 
 98445:     script->bindings.transfer(cx, &bce->sc->bindings);
 59968: 
 75518:     fun = NULL;
 98476:     if (bce->sc->inFunction) {
 98463:         JS_ASSERT(!bce->noScriptRval);
 98463:         JS_ASSERT(!bce->needScriptGlobal);
 98687: 
 98687:         script->isGenerator = bce->sc->funIsGenerator();
 98687: 
     1:         /*
 79820:          * We initialize fun->script() to be the script constructed above
 76812:          * so that the debugger has a valid fun->script().
     1:          */
 98445:         fun = bce->sc->fun();
 59968:         JS_ASSERT(fun->isInterpreted());
 59968:         JS_ASSERT(!fun->script());
 98687:         if (bce->sc->funIsHeavyweight())
     1:             fun->flags |= JSFUN_HEAVYWEIGHT;
 77343: 
 83258:         /*
 83258:          * Mark functions which will only be executed once as singletons.
 83258:          */
 77353:         bool singleton =
 83258:             cx->typeInferenceEnabled() &&
 83273:             bce->parent &&
 98445:             bce->parent->checkSingletonContext();
 77353: 
 77353:         if (!script->typeSetFunction(cx, fun, singleton))
 77659:             return NULL;
 77343: 
 79820:         fun->setScript(script);
 86483:         script->globalObject = fun->getParent() ? &fun->getParent()->global() : NULL;
 98687: 
 75518:     } else {
 98687:         // It'd be nice to JS_ASSERT(!bce->sc->funIsHeavyweight()) here, but
 98687:         // Parser.cpp is sloppy and sometimes applies it to non-functions.
 98687:         JS_ASSERT(!bce->sc->funIsGenerator());
 98687: 
 75518:         /*
 75518:          * Initialize script->object, if necessary, so that the debugger has a
 75518:          * valid holder object.
 75518:          */
 98463:         if (bce->needScriptGlobal)
 82129:             script->globalObject = GetCurrentGlobal(cx);
 98463: 
 98463:         script->noScriptRval = bce->noScriptRval;
     1:     }
     1: 
     1:     /* Tell the debugger about this compiled script. */
     1:     js_CallNewScriptHook(cx, script, fun);
 80964:     if (!bce->parent) {
 79905:         GlobalObject *compileAndGoGlobal = NULL;
 80803:         if (script->compileAndGo) {
 82129:             compileAndGoGlobal = script->globalObject;
 80803:             if (!compileAndGoGlobal)
 98445:                 compileAndGoGlobal = &bce->sc->scopeChain()->global();
 80803:         }
 80803:         Debugger::onNewScript(cx, script, compileAndGoGlobal);
 75518:     }
 58980: 
 97298:     /*
 97298:      * initScriptCounts updates scriptCountsMap if necessary. The other script
 97298:      * maps in JSCompartment are populated lazily.
 97298:      */
 82134:     if (cx->hasRunOption(JSOPTION_PCCOUNT))
 94574:         (void) script->initScriptCounts(cx);
 82134: 
     1:     return script;
     1: }
     1: 
 72071: size_t
 88145: JSScript::computedSizeOfData()
 72071: {
 84755:     uint8_t *dataEnd = code + length * sizeof(jsbytecode) + numNotes() * sizeof(jssrcnote);
 77659:     JS_ASSERT(dataEnd >= data);
 77659:     return dataEnd - data;
 72071: }
 72071: 
 78016: size_t
 88145: JSScript::sizeOfData(JSMallocSizeOfFun mallocSizeOf)
 78016: {
 88300:     return mallocSizeOf(data);
 78016: }
 78016: 
 72071: /*
 72071:  * Nb: srcnotes are variable-length.  This function computes the number of
 72071:  * srcnote *slots*, which may be greater than the number of srcnotes.
 72071:  */
 84755: uint32_t
 72071: JSScript::numNotes()
 72071: {
 72071:     jssrcnote *sn;
 72071:     jssrcnote *notes_ = notes();
 72071:     for (sn = notes_; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
 72071:         continue;
 72071:     return sn - notes_ + 1;    /* +1 for the terminator */
 72071: }
 72071: 
     1: JS_FRIEND_API(void)
     1: js_CallNewScriptHook(JSContext *cx, JSScript *script, JSFunction *fun)
     1: {
 77659:     JS_ASSERT(!script->callDestroyHook);
 98566:     JS_ASSERT(!script->isActiveEval);
 91178:     if (JSNewScriptHook hook = cx->runtime->debugHooks.newScriptHook) {
 40840:         AutoKeepAtoms keep(cx->runtime);
     1:         hook(cx, script->filename, script->lineno, script, fun,
 91178:              cx->runtime->debugHooks.newScriptHookData);
     1:     }
 77659:     script->callDestroyHook = true;
     1: }
     1: 
 62571: void
 94740: js::CallDestroyScriptHook(FreeOp *fop, JSScript *script)
     1: {
 77659:     if (!script->callDestroyHook)
 77659:         return;
     1: 
 94740:     if (JSDestroyScriptHook hook = fop->runtime()->debugHooks.destroyScriptHook)
 94740:         hook(fop, script, fop->runtime()->debugHooks.destroyScriptHookData);
 77659:     script->callDestroyHook = false;
 94740:     script->clearTraps(fop);
     1: }
     1: 
 77659: void
 94738: JSScript::finalize(FreeOp *fop)
     1: {
 94740:     CallDestroyScriptHook(fop, this);
 11377: 
 84691:     JS_ASSERT_IF(principals, originPrincipals);
 77659:     if (principals)
 94738:         JS_DropPrincipals(fop->runtime(), principals);
 84691:     if (originPrincipals)
 94738:         JS_DropPrincipals(fop->runtime(), originPrincipals);
 76766: 
 77659:     if (types)
 77659:         types->destroy();
 76766: 
 77659: #ifdef JS_METHODJIT
 94740:     mjit::ReleaseScriptCode(fop, this);
 24879: #endif
 11377: 
 94740:     destroyScriptCounts(fop);
 95139:     destroySourceMap(fop);
 95151:     destroyDebugScript(fop);
 84195: 
 88145:     JS_POISON(data, 0xdb, computedSizeOfData());
 94738:     fop->free_(data);
 76766: }
     1: 
 67915: namespace js {
     1: 
 84755: static const uint32_t GSN_CACHE_THRESHOLD = 100;
 84755: static const uint32_t GSN_CACHE_MAP_INIT_SIZE = 20;
 67915: 
 26569: void
 67915: GSNCache::purge()
 26569: {
 67915:     code = NULL;
 67915:     if (map.initialized())
 67915:         map.finish();
 26569: }
 67915: 
 67915: } /* namespace js */
 26569: 
     1: jssrcnote *
     1: js_GetSrcNoteCached(JSContext *cx, JSScript *script, jsbytecode *pc)
     1: {
 67915:     size_t target = pc - script->code;
 67915:     if (target >= size_t(script->length))
     1:         return NULL;
     1: 
 67915:     GSNCache *cache = GetGSNCache(cx);
 67915:     if (cache->code == script->code) {
 67915:         JS_ASSERT(cache->map.initialized());
 67915:         GSNCache::Map::Ptr p = cache->map.lookup(pc);
 67915:         return p ? p->value : NULL;
     1:     }
     1: 
 67915:     size_t offset = 0;
 67915:     jssrcnote *result;
 67915:     for (jssrcnote *sn = script->notes(); ; sn = SN_NEXT(sn)) {
     1:         if (SN_IS_TERMINATOR(sn)) {
     1:             result = NULL;
     1:             break;
     1:         }
     1:         offset += SN_DELTA(sn);
     1:         if (offset == target && SN_IS_GETTABLE(sn)) {
     1:             result = sn;
     1:             break;
     1:         }
     1:     }
     1: 
 67915:     if (cache->code != script->code && script->length >= GSN_CACHE_THRESHOLD) {
 91237:         unsigned nsrcnotes = 0;
 67915:         for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn);
     1:              sn = SN_NEXT(sn)) {
     1:             if (SN_IS_GETTABLE(sn))
     1:                 ++nsrcnotes;
     1:         }
 67915:         if (cache->code) {
 67915:             JS_ASSERT(cache->map.initialized());
 67915:             cache->map.finish();
 67915:             cache->code = NULL;
 67915:         }
 67915:         if (cache->map.init(nsrcnotes)) {
     1:             pc = script->code;
 67915:             for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn);
     1:                  sn = SN_NEXT(sn)) {
     1:                 pc += SN_DELTA(sn);
 67915:                 if (SN_IS_GETTABLE(sn))
 67915:                     JS_ALWAYS_TRUE(cache->map.put(pc, sn));
     1:             }
 67915:             cache->code = script->code;
     1:         }
     1:     }
     1: 
     1:     return result;
     1: }
     1: 
 91237: unsigned
 91316: js::PCToLineNumber(unsigned startLine, jssrcnote *notes, jsbytecode *code, jsbytecode *pc)
     1: {
 91316:     unsigned lineno = startLine;
     1: 
     1:     /*
 91316:      * Walk through source notes accumulating their deltas, keeping track of
 91316:      * line-number notes, until we pass the note for pc's offset within
 91316:      * script->code.
     1:      */
 80631:     ptrdiff_t offset = 0;
 91316:     ptrdiff_t target = pc - code;
 91316:     for (jssrcnote *sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
     1:         offset += SN_DELTA(sn);
 80631:         SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
     1:         if (type == SRC_SETLINE) {
     1:             if (offset <= target)
 91237:                 lineno = (unsigned) js_GetSrcNoteOffset(sn, 0);
     1:         } else if (type == SRC_NEWLINE) {
     1:             if (offset <= target)
     1:                 lineno++;
     1:         }
     1:         if (offset > target)
     1:             break;
     1:     }
 91316: 
     1:     return lineno;
     1: }
     1: 
 91316: unsigned
 91316: js::PCToLineNumber(JSScript *script, jsbytecode *pc)
 91316: {
 91316:     /* Cope with StackFrame.pc value prior to entering js_Interpret. */
 91316:     if (!pc)
 91316:         return 0;
 91316: 
 91316:     return PCToLineNumber(script->lineno, script->notes(), script->code, pc);
 91316: }
 91316: 
     1: /* The line number limit is the same as the jssrcnote offset limit. */
     1: #define SN_LINE_LIMIT   (SN_3BYTE_OFFSET_FLAG << 16)
     1: 
     1: jsbytecode *
 91237: js_LineNumberToPC(JSScript *script, unsigned target)
     1: {
 80631:     ptrdiff_t offset = 0;
 80631:     ptrdiff_t best = -1;
 91237:     unsigned lineno = script->lineno;
 91237:     unsigned bestdiff = SN_LINE_LIMIT;
 80631:     for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
   267:         /*
   267:          * Exact-match only if offset is not in the prolog; otherwise use
   267:          * nearest greater-or-equal line number match.
   267:          */
 77659:         if (lineno == target && offset >= ptrdiff_t(script->mainOffset))
     1:             goto out;
   267:         if (lineno >= target) {
 91237:             unsigned diff = lineno - target;
     1:             if (diff < bestdiff) {
     1:                 bestdiff = diff;
     1:                 best = offset;
     1:             }
     1:         }
     1:         offset += SN_DELTA(sn);
 80631:         SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
     1:         if (type == SRC_SETLINE) {
 91237:             lineno = (unsigned) js_GetSrcNoteOffset(sn, 0);
     1:         } else if (type == SRC_NEWLINE) {
     1:             lineno++;
     1:         }
     1:     }
     1:     if (best >= 0)
     1:         offset = best;
     1: out:
     1:     return script->code + offset;
     1: }
     1: 
 91237: JS_FRIEND_API(unsigned)
     1: js_GetScriptLineExtent(JSScript *script)
     1: {
 91237:     unsigned lineno = script->lineno;
 91237:     unsigned maxLineNo = 0;
 80631:     bool counting = true;
 80631:     for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
 80631:         SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
     1:         if (type == SRC_SETLINE) {
 73768:             if (maxLineNo < lineno)
 73768:                 maxLineNo = lineno;
 91237:             lineno = (unsigned) js_GetSrcNoteOffset(sn, 0);
 73768:             counting = true;
 73768:             if (maxLineNo < lineno)
 73768:                 maxLineNo = lineno;
 73768:             else
 73768:                 counting = false;
     1:         } else if (type == SRC_NEWLINE) {
 73768:             if (counting)
     1:                 lineno++;
     1:         }
     1:     }
 73768: 
 73768:     if (maxLineNo > lineno)
 73768:         lineno = maxLineNo;
 73768: 
     1:     return 1 + lineno - script->lineno;
     1: }
 53498: 
 71363: namespace js {
 71363: 
 91237: unsigned
 71363: CurrentLine(JSContext *cx)
 71363: {
 91316:     return PCToLineNumber(cx->fp()->script(), cx->regs().pc);
 71363: }
 71363: 
 84691: void
 91237: CurrentScriptFileLineOriginSlow(JSContext *cx, const char **file, unsigned *linenop,
 84691:                                 JSPrincipals **origin)
 68894: {
 97161:     ScriptFrameIter iter(cx);
 71363: 
 71363:     if (iter.done()) {
 84691:         *file = NULL;
 68894:         *linenop = 0;
 84691:         *origin = NULL;
 84691:         return;
 68894:     }
 68894: 
 97161:     JSScript *script = iter.script();
 84691:     *file = script->filename;
 97161:     *linenop = PCToLineNumber(iter.script(), iter.pc());
 84691:     *origin = script->originPrincipals;
 68894: }
 68894: 
 94006: }  /* namespace js */
 64372: 
 97298: template <class T>
 97298: static inline T *
 97298: Rebase(JSScript *dst, JSScript *src, T *srcp)
 97298: {
 97298:     size_t off = reinterpret_cast<uint8_t *>(srcp) - src->data;
 97298:     return reinterpret_cast<T *>(dst->data + off);
 97298: }
 97298: 
 55633: JSScript *
 97298: js::CloneScript(JSContext *cx, JSScript *src)
 55633: {
 97298:     /* NB: Keep this in sync with XDRScript. */
 55633: 
 97839:     uint32_t nconsts   = src->hasConsts()   ? src->consts()->length   : 0;
 97839:     uint32_t nobjects  = src->hasObjects()  ? src->objects()->length  : 0;
 97839:     uint32_t nregexps  = src->hasRegexps()  ? src->regexps()->length  : 0;
 97839:     uint32_t ntrynotes = src->hasTrynotes() ? src->trynotes()->length : 0;
 97298:     uint32_t nClosedArgs = src->numClosedArgs();
 97298:     uint32_t nClosedVars = src->numClosedVars();
 55633: 
 97298:     /* Script data */
 97298: 
 97298:     size_t size = ScriptDataSize(cx, src->length, src->numNotes(), src->natoms,
 98173:                                  nobjects, nregexps, ntrynotes, nconsts, nClosedArgs, nClosedVars);
 97298: 
 97298:     uint8_t *data = AllocScriptData(cx, size);
 97298:     if (!data)
 55633:         return NULL;
 55633: 
 97298:     /* Bindings */
 55633: 
 97298:     Bindings bindings(cx);
 97298:     BindingNames names(cx);
 97298:     if (!src->bindings.getLocalNameArray(cx, &names))
 97545:         return NULL;
 55633: 
 97298:     for (unsigned i = 0; i < names.length(); ++i) {
 97298:         if (JSAtom *atom = names[i].maybeAtom) {
 99421:             if (!bindings.add(cx, RootedAtom(cx, atom), names[i].kind))
 97545:                 return NULL;
 97298:         } else {
 97298:             uint16_t _;
 97298:             if (!bindings.addDestructuring(cx, &_))
 97545:                 return NULL;
 97298:         }
 97298:     }
 97298: 
 97298:     if (!bindings.ensureShape(cx))
 97545:         return NULL;
 97298:     bindings.makeImmutable();
 97298: 
 97298:     /* Objects */
 97298: 
 97298:     AutoObjectVector objects(cx);
 97298:     if (nobjects != 0) {
 97298:         HeapPtrObject *vector = src->objects()->vector;
 97298:         for (unsigned i = 0; i < nobjects; i++) {
 97298:             JSObject *clone = vector[i]->isStaticBlock()
 97298:                               ? CloneStaticBlockObject(cx, vector[i]->asStaticBlock(), objects, src)
 97298:                               : CloneInterpretedFunction(cx, vector[i]->toFunction());
 97298:             if (!clone || !objects.append(clone))
 97545:                 return NULL;
 97298:         }
 97298:     }
 97298: 
 97298:     /* RegExps */
 97298: 
 97298:     AutoObjectVector regexps(cx);
 97298:     for (unsigned i = 0; i < nregexps; i++) {
 97298:         HeapPtrObject *vector = src->regexps()->vector;
 97298:         for (unsigned i = 0; i < nregexps; i++) {
 97298:             JSObject *clone = CloneScriptRegExpObject(cx, vector[i]->asRegExp());
 97298:             if (!clone || !regexps.append(clone))
 97545:                 return NULL;
 97298:         }
 97298:     }
 97298: 
 97298:     /* Now that all fallible allocation is complete, create the GC thing. */
 97298: 
 97298:     JSScript *dst = js_NewGCScript(cx);
 97298:     if (!dst) {
 97298:         Foreground::free_(data);
 55633:         return NULL;
 97298:     }
 55633: 
 97298:     PodZero(dst);
 97298: 
 97298:     new (&dst->bindings) Bindings(cx);
 97298:     dst->bindings.transfer(cx, &bindings);
 97298: 
 97298:     /* This assignment must occur before all the Rebase calls. */
 97298:     dst->data = data;
 97298:     memcpy(data, src->data, size);
 97298: 
 97298:     dst->code = Rebase<jsbytecode>(dst, src, src->code);
 97298: 
 97298:     /* Script filenames are runtime-wide. */
 97298:     dst->filename = src->filename;
 97298: 
 97298:     /* Atoms are runtime-wide. */
 97298:     if (src->natoms != 0)
 97298:         dst->atoms = Rebase<HeapPtrAtom>(dst, src, src->atoms);
 97298: 
 97298:     dst->principals = cx->compartment->principals;
 97298:     if (dst->principals)
 97298:         JS_HoldPrincipals(dst->principals);
 97298: 
 97298:     /* Establish invariant: principals implies originPrincipals. */
 97298:     dst->originPrincipals = src->originPrincipals;
 97298:     if (!dst->originPrincipals)
 97298:         dst->originPrincipals = dst->principals;
 97298:     if (dst->originPrincipals)
 97298:         JS_HoldPrincipals(dst->originPrincipals);
 97298: 
 97298:     dst->length = src->length;
 97298:     dst->lineno = src->lineno;
 97298:     dst->mainOffset = src->mainOffset;
 97298:     dst->natoms = src->natoms;
 97298:     dst->setVersion(src->getVersion());
 97298:     dst->nfixed = src->nfixed;
 97298:     dst->nTypeSets = src->nTypeSets;
 97298:     dst->nslots = src->nslots;
 97298:     dst->staticLevel = src->staticLevel;
 97298:     if (src->argumentsHasLocalBinding()) {
100006:         dst->setArgumentsHasLocalBinding(src->argumentsLocalSlot());
 97298:         if (src->analyzedArgsUsage())
 97298:             dst->setNeedsArgsObj(src->needsArgsObj());
 97298:     }
 97839:     dst->cloneHasArray(src);
 97298:     dst->noScriptRval = src->noScriptRval;
 97298:     dst->savedCallerFun = src->savedCallerFun;
 97298:     dst->strictModeCode = src->strictModeCode;
 97298:     dst->compileAndGo = src->compileAndGo;
 97298:     dst->bindingsAccessedDynamically = src->bindingsAccessedDynamically;
 97298:     dst->hasSingletons = src->hasSingletons;
 97298:     dst->isGenerator = src->isGenerator;
 97298: 
 97298:     /*
 97298:      * initScriptCounts updates scriptCountsMap if necessary. The other script
 97298:      * maps in JSCompartment are populated lazily.
 97298:      */
 97298:     if (cx->hasRunOption(JSOPTION_PCCOUNT))
 97298:         (void) dst->initScriptCounts(cx);
 97298: 
 97298:     if (nconsts != 0) {
 97298:         HeapValue *vector = Rebase<HeapValue>(dst, src, src->consts()->vector);
 97298:         dst->consts()->vector = vector;
 97298:         for (unsigned i = 0; i < nconsts; ++i)
 97298:             JS_ASSERT_IF(vector[i].isMarkable(), vector[i].toString()->isAtom());
 97298:     }
 97298:     if (nobjects != 0) {
 97298:         HeapPtrObject *vector = Rebase<HeapPtr<JSObject> >(dst, src, src->objects()->vector);
 97298:         dst->objects()->vector = vector;
 97298:         for (unsigned i = 0; i < nobjects; ++i)
 97298:             vector[i].init(objects[i]);
 97298:     }
 97298:     if (nregexps != 0) {
 97298:         HeapPtrObject *vector = Rebase<HeapPtr<JSObject> >(dst, src, src->regexps()->vector);
 97298:         dst->regexps()->vector = vector;
 97298:         for (unsigned i = 0; i < nregexps; ++i)
 97298:             vector[i].init(regexps[i]);
 97298:     }
 97298:     if (ntrynotes != 0)
 97298:         dst->trynotes()->vector = Rebase<JSTryNote>(dst, src, src->trynotes()->vector);
 97298:     if (nClosedArgs != 0)
 97298:         dst->closedArgs()->vector = Rebase<uint32_t>(dst, src, src->closedArgs()->vector);
 97298:     if (nClosedVars != 0)
 97298:         dst->closedVars()->vector = Rebase<uint32_t>(dst, src, src->closedVars()->vector);
 97298: 
 97298:     return dst;
 55633: }
 55633: 
 95151: DebugScript *
 95151: JSScript::debugScript()
 95151: {
 95151:     JS_ASSERT(hasDebugScript);
 95151:     DebugScriptMap *map = compartment()->debugScriptMap;
 95151:     JS_ASSERT(map);
 95151:     DebugScriptMap::Ptr p = map->lookup(this);
 95151:     JS_ASSERT(p);
 95151:     return p->value;
 95151: }
 95151: 
 95151: DebugScript *
 95151: JSScript::releaseDebugScript()
 95151: {
 95151:     JS_ASSERT(hasDebugScript);
 95151:     DebugScriptMap *map = compartment()->debugScriptMap;
 95151:     JS_ASSERT(map);
 95151:     DebugScriptMap::Ptr p = map->lookup(this);
 95151:     JS_ASSERT(p);
 95151:     DebugScript *debug = p->value;
 95151:     map->remove(p);
 95151:     hasDebugScript = false;
 95151:     return debug;
 95151: }
 95151: 
 95151: void
 95151: JSScript::destroyDebugScript(FreeOp *fop)
 95151: {
 95151:     if (hasDebugScript) {
 95151:         jsbytecode *end = code + length;
 95151:         for (jsbytecode *pc = code; pc < end; pc++) {
 95151:             if (BreakpointSite *site = getBreakpointSite(pc)) {
 95151:                 /* Breakpoints are swept before finalization. */
 95151:                 JS_ASSERT(site->firstBreakpoint() == NULL);
 95151:                 site->clearTrap(fop, NULL, NULL);
 95151:                 JS_ASSERT(getBreakpointSite(pc) == NULL);
 95151:             }
 95151:         }
 95151:         fop->free_(releaseDebugScript());
 95151:     }
 95151: }
 95151: 
 77169: bool
 95151: JSScript::ensureHasDebugScript(JSContext *cx)
 84195: {
 95151:     if (hasDebugScript)
 84195:         return true;
 84195: 
 84195:     size_t nbytes = offsetof(DebugScript, breakpoints) + length * sizeof(BreakpointSite*);
 95151:     DebugScript *debug = (DebugScript *) cx->calloc_(nbytes);
 84195:     if (!debug)
 84195:         return false;
 84195: 
 95151:     /* Create compartment's debugScriptMap if necessary. */
 95151:     DebugScriptMap *map = compartment()->debugScriptMap;
 95151:     if (!map) {
 95151:         map = cx->new_<DebugScriptMap>();
 95151:         if (!map || !map->init()) {
 95151:             cx->free_(debug);
 95151:             cx->delete_(map);
 95151:             return false;
 95151:         }
 95151:         compartment()->debugScriptMap = map;
 95151:     }
 95151: 
 95151:     if (!map->putNew(this, debug)) {
 95151:         cx->free_(debug);
 95151:         cx->delete_(map);
 95151:         return false;
 95151:     }
 95151:     hasDebugScript = true; // safe to set this;  we can't fail after this point
 95151: 
 84195:     /*
 84195:      * Ensure that any Interpret() instances running on this script have
 84195:      * interrupts enabled. The interrupts must stay enabled until the
 84195:      * debug state is destroyed.
 84195:      */
 84195:     InterpreterFrames *frames;
 88135:     for (frames = cx->runtime->interpreterFrames; frames; frames = frames->older)
 84195:         frames->enableInterruptsIfRunning(this);
 84195: 
 84195:     return true;
 84195: }
 84195: 
 94740: void
 94740: JSScript::recompileForStepMode(FreeOp *fop)
 77169: {
 77169: #ifdef JS_METHODJIT
 99476:     if (hasJITInfo()) {
 94740:         mjit::Recompiler::clearStackReferences(fop, this);
 94740:         mjit::ReleaseScriptCode(fop, this);
 77169:     }
 77169: #endif
 77169: }
 77169: 
 77169: bool
 84755: JSScript::tryNewStepMode(JSContext *cx, uint32_t newValue)
 77169: {
 95151:     JS_ASSERT(hasDebugScript);
 84195: 
 95151:     DebugScript *debug = debugScript();
 84755:     uint32_t prior = debug->stepMode;
 84195:     debug->stepMode = newValue;
 77169: 
 77169:     if (!prior != !newValue) {
 77169:         /* Step mode has been enabled or disabled. Alert the methodjit. */
 94740:         recompileForStepMode(cx->runtime->defaultFreeOp());
 77169: 
 95151:         if (!stepModeEnabled() && !debug->numSites)
 95151:             cx->free_(releaseDebugScript());
 77169:     }
 84195: 
 77169:     return true;
 77169: }
 77169: 
 77169: bool
 77169: JSScript::setStepModeFlag(JSContext *cx, bool step)
 77169: {
 95151:     if (!ensureHasDebugScript(cx))
 84195:         return false;
 84195: 
 95151:     return tryNewStepMode(cx, (debugScript()->stepMode & stepCountMask) |
 95151:                                (step ? stepFlagMask : 0));
 77169: }
 77169: 
 77169: bool
 77169: JSScript::changeStepModeCount(JSContext *cx, int delta)
 77169: {
 95151:     if (!ensureHasDebugScript(cx))
 84195:         return false;
 84195: 
 77169:     assertSameCompartment(cx, this);
 77169:     JS_ASSERT_IF(delta > 0, cx->compartment->debugMode());
 77169: 
 95151:     DebugScript *debug = debugScript();
 84755:     uint32_t count = debug->stepMode & stepCountMask;
 77169:     JS_ASSERT(((count + delta) & stepCountMask) == count + delta);
 77169:     return tryNewStepMode(cx,
 84195:                           (debug->stepMode & stepFlagMask) |
 77169:                           ((count + delta) & stepCountMask));
 77169: }
 84195: 
 84195: BreakpointSite *
 84195: JSScript::getOrCreateBreakpointSite(JSContext *cx, jsbytecode *pc,
 84195:                                     GlobalObject *scriptGlobal)
 84195: {
 84195:     JS_ASSERT(size_t(pc - code) < length);
 84195: 
 95151:     if (!ensureHasDebugScript(cx))
 84195:         return NULL;
 84195: 
 95151:     DebugScript *debug = debugScript();
 84195:     BreakpointSite *&site = debug->breakpoints[pc - code];
 84195: 
 84195:     if (!site) {
 84195:         site = cx->runtime->new_<BreakpointSite>(this, pc);
 84195:         if (!site) {
 84195:             js_ReportOutOfMemory(cx);
 84195:             return NULL;
 84195:         }
 84195:         debug->numSites++;
 84195:     }
 84195: 
 84195:     if (site->scriptGlobal)
 84195:         JS_ASSERT_IF(scriptGlobal, site->scriptGlobal == scriptGlobal);
 84195:     else
 84195:         site->scriptGlobal = scriptGlobal;
 84195: 
 84195:     return site;
 84195: }
 84195: 
 84195: void
 94740: JSScript::destroyBreakpointSite(FreeOp *fop, jsbytecode *pc)
 84195: {
 84195:     JS_ASSERT(unsigned(pc - code) < length);
 84195: 
 95151:     DebugScript *debug = debugScript();
 84195:     BreakpointSite *&site = debug->breakpoints[pc - code];
 84195:     JS_ASSERT(site);
 84195: 
 94740:     fop->delete_(site);
 84195:     site = NULL;
 84195: 
 95151:     if (--debug->numSites == 0 && !stepModeEnabled())
 95151:         fop->free_(releaseDebugScript());
 84195: }
 84195: 
 84195: void
 94959: JSScript::clearBreakpointsIn(FreeOp *fop, js::Debugger *dbg, JSObject *handler)
 84195: {
 84195:     if (!hasAnyBreakpointsOrStepMode())
 84195:         return;
 84195: 
 84195:     jsbytecode *end = code + length;
 84195:     for (jsbytecode *pc = code; pc < end; pc++) {
 84195:         BreakpointSite *site = getBreakpointSite(pc);
 84195:         if (site) {
 84195:             Breakpoint *nextbp;
 84195:             for (Breakpoint *bp = site->firstBreakpoint(); bp; bp = nextbp) {
 84195:                 nextbp = bp->nextInSite();
 84195:                 if ((!dbg || bp->debugger == dbg) && (!handler || bp->getHandler() == handler))
 94959:                     bp->destroy(fop);
 84195:             }
 84195:         }
 84195:     }
 84195: }
 84195: 
 84195: void
 94740: JSScript::clearTraps(FreeOp *fop)
 84195: {
 84195:     if (!hasAnyBreakpointsOrStepMode())
 84195:         return;
 84195: 
 84195:     jsbytecode *end = code + length;
 84195:     for (jsbytecode *pc = code; pc < end; pc++) {
 84195:         BreakpointSite *site = getBreakpointSite(pc);
 84195:         if (site)
 94740:             site->clearTrap(fop);
 84195:     }
 84195: }
 84195: 
 84195: void
 91557: JSScript::markChildren(JSTracer *trc)
 84195: {
 94620:     JS_ASSERT_IF(trc->runtime->gcStrictCompartmentChecking, compartment()->isCollecting());
 91557: 
 91557:     for (uint32_t i = 0; i < natoms; ++i) {
 91557:         if (atoms[i])
 94934:             MarkString(trc, &atoms[i], "atom");
 91557:     }
 91557: 
 97361:     if (hasObjects()) {
 97362:         ObjectArray *objarray = objects();
 91557:         MarkObjectRange(trc, objarray->length, objarray->vector, "objects");
 91557:     }
 91557: 
 97361:     if (hasRegexps()) {
 97362:         ObjectArray *objarray = regexps();
 91557:         MarkObjectRange(trc, objarray->length, objarray->vector, "objects");
 91557:     }
 91557: 
 97361:     if (hasConsts()) {
 97362:         ConstArray *constarray = consts();
 91557:         MarkValueRange(trc, constarray->length, constarray->vector, "consts");
 91557:     }
 91557: 
 91557:     if (function())
 91557:         MarkObject(trc, &function_, "function");
 91557: 
 91557:     if (!isCachedEval && globalObject)
 91557:         MarkObject(trc, &globalObject, "object");
 91557: 
 91557:     if (IS_GC_MARKING_TRACER(trc) && filename)
 97463:         MarkScriptFilename(trc->runtime, filename);
 91557: 
 91557:     bindings.trace(trc);
 91557: 
 91557:     if (types)
 91557:         types->trace(trc);
 91557: 
 98147: #ifdef JS_METHODJIT
 98147:     for (int constructing = 0; constructing <= 1; constructing++) {
 98147:         for (int barriers = 0; barriers <= 1; barriers++) {
 98147:             mjit::JITScript *jit = getJIT((bool) constructing, (bool) barriers);
 98147:             if (jit)
 98147:                 jit->trace(trc);
 98147:         }
 98147:     }
 98147: #endif
 98147: 
 91557:     if (hasAnyBreakpointsOrStepMode()) {
 84195:         for (unsigned i = 0; i < length; i++) {
 95151:             BreakpointSite *site = debugScript()->breakpoints[i];
 84195:             if (site && site->trapHandler)
 90302:                 MarkValue(trc, &site->trapClosure, "trap closure");
 84195:         }
 84195:     }
 91557: }
 93250: 
 93250: void
100006: JSScript::setArgumentsHasLocalBinding(uint16_t slot)
 95100: {
 95100:     argsHasLocalBinding_ = true;
100006:     argsSlot_ = slot;
 95100:     needsArgsAnalysis_ = true;
 95100: }
 95100: 
 95100: void
 93250: JSScript::setNeedsArgsObj(bool needsArgsObj)
 93250: {
 95100:     JS_ASSERT(!analyzedArgsUsage());
 95100:     JS_ASSERT_IF(needsArgsObj, argumentsHasLocalBinding());
 95100:     needsArgsAnalysis_ = false;
 93250:     needsArgsObj_ = needsArgsObj;
 93250: }
 93251: 
 97353: /* static */ bool
 97353: JSScript::applySpeculationFailed(JSContext *cx, JSScript *script_)
 93251: {
 99421:     Rooted<JSScript*> script(cx, script_);
 97353: 
 97353:     JS_ASSERT(script->analyzedArgsUsage());
 97353:     JS_ASSERT(script->argumentsHasLocalBinding());
 95684: 
 95684:     /*
 95684:      * It is possible that the apply speculation has already failed, everything
 95684:      * has been fixed up, but there was an outstanding magic value on the
 95684:      * stack that has just now flowed into an apply. In this case, there is
 95684:      * nothing to do; GuardFunApplySpeculation will patch in the real argsobj.
 95684:      */
 97353:     if (script->needsArgsObj())
 95684:         return true;
 95684: 
 97353:     script->needsArgsObj_ = true;
 93251: 
100006:     const unsigned slot = script->argumentsLocalSlot();
 95100: 
 93251:     /*
 93251:      * By design, the apply-arguments optimization is only made when there
 93251:      * are no outstanding cases of MagicValue(JS_OPTIMIZED_ARGUMENTS) other
 93251:      * than this particular invocation of 'f.apply(x, arguments)'. Thus, there
 93251:      * are no outstanding values of MagicValue(JS_OPTIMIZED_ARGUMENTS) on the
 93251:      * stack. However, there are three things that need fixup:
 93251:      *  - there may be any number of activations of this script that don't have
 93251:      *    an argsObj that now need one.
 93251:      *  - jit code compiled (and possible active on the stack) with the static
 93251:      *    assumption of !script->needsArgsObj();
 93251:      *  - type inference data for the script assuming script->needsArgsObj; and
 93251:      */
 93251:     for (AllFramesIter i(cx->stack.space()); !i.done(); ++i) {
 93251:         StackFrame *fp = i.fp();
 97353:         if (fp->isFunctionFrame() && fp->script() == script) {
100006:             if (!fp->hasArgsObj()) {
100006:                 ArgumentsObject *obj = ArgumentsObject::create(cx, fp);
100006:                 if (!obj) {
 93251:                     /*
100006:                      * We can't leave stack frames where script->needsArgsObj
100006:                      * and !fp->hasArgsObj. It is, however, safe to leave frames
100006:                      * where fp->hasArgsObj and !fp->script->needsArgsObj.
 93251:                      */
 97353:                     script->needsArgsObj_ = false;
 93251:                     return false;
 93251:                 }
 95685: 
 95685:                 /* Note: 'arguments' may have already been overwritten. */
100006:                 if (fp->localSlot(slot).isMagic(JS_OPTIMIZED_ARGUMENTS))
100006:                     fp->localSlot(slot) = ObjectValue(*obj);
100006:             }
 93251:         }
 93251:     }
 93251: 
 93251: #ifdef JS_METHODJIT
 99476:     if (script->hasJITInfo()) {
 97353:         mjit::Recompiler::clearStackReferences(cx->runtime->defaultFreeOp(), script);
 97353:         mjit::ReleaseScriptCode(cx->runtime->defaultFreeOp(), script);
 93251:     }
 93251: #endif
 93251: 
 97353:     if (script->hasAnalysis() && script->analysis()->ranInference()) {
 93251:         types::AutoEnterTypeInference enter(cx);
 97353:         types::TypeScript::MonitorUnknown(cx, script, script->argumentsBytecode());
 93251:     }
 93251: 
 93251:     return true;
 93251: }
 95099: 
100006: #ifdef DEBUG
 95099: bool
 95099: JSScript::varIsAliased(unsigned varSlot)
 95099: {
 95099:     if (bindingsAccessedDynamically)
 95099:         return true;
 95099: 
 95099:     for (uint32_t i = 0; i < numClosedVars(); ++i) {
 95099:         if (closedVars()->vector[i] == varSlot) {
 95099:             JS_ASSERT(function()->isHeavyweight());
 95099:             return true;
 95099:         }
 95099:     }
 95099: 
 95099:     return false;
 95099: }
 95099: 
 95099: bool
 98892: JSScript::formalIsAliased(unsigned argSlot)
 95099: {
 98892:     return formalLivesInCallObject(argSlot) || argsObjAliasesFormals();
 95101: }
 95101: 
 95101: bool
 98892: JSScript::formalLivesInArgumentsObject(unsigned argSlot)
 95101: {
 98892:     return argsObjAliasesFormals() && !formalLivesInCallObject(argSlot);
 95101: }
 95101: 
 95101: bool
 98892: JSScript::formalLivesInCallObject(unsigned argSlot)
 95101: {
 95099:     if (bindingsAccessedDynamically)
 95099:         return true;
 95099: 
 95099:     for (uint32_t i = 0; i < numClosedArgs(); ++i) {
 95099:         if (closedArgs()->vector[i] == argSlot) {
 95099:             JS_ASSERT(function()->isHeavyweight());
 95099:             return true;
 95099:         }
 95099:     }
 95099: 
 95099:     return false;
 95099: }
100006: #endif
