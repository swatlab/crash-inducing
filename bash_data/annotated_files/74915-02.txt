29366: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
32658:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript bytecode interpreter.
    1:  */
    1: #include <stdio.h>
    1: #include <string.h>
    1: #include <math.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsarena.h"
55477: #include "jsutil.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
    1: #include "jscntxt.h"
25087: #include "jsdate.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
70310: #include "jsgcmark.h"
    1: #include "jsinterp.h"
    1: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
40359: #include "jspropertycache.h"
54855: #include "jsemit.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
18989: #include "jsstaticcheck.h"
17584: #include "jstracer.h"
30268: #include "jslibmath.h"
32581: #include "jsvector.h"
68931: #ifdef JS_METHODJIT
52558: #include "methodjit/MethodJIT.h"
62574: #include "methodjit/MethodJIT-inl.h"
52558: #include "methodjit/Logging.h"
68931: #endif
34349: #include "jsatominlines.h"
53840: #include "jsinterpinlines.h"
42714: #include "jsobjinlines.h"
56556: #include "jsprobes.h"
40359: #include "jspropertycacheinlines.h"
34349: #include "jsscopeinlines.h"
34349: #include "jsscriptinlines.h"
54855: #include "jsopcodeinlines.h"
74875: #include "jstypedarrayinlines.h"
 7058: 
69223: #include "vm/Stack-inl.h"
72107: #include "vm/String-inl.h"
69223: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
15453: #include "jsautooplen.h"
15453: 
54832: #if defined(JS_METHODJIT) && defined(JS_MONOIC)
54832: #include "methodjit/MonoIC.h"
54832: #endif
54832: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
15996: /* jsinvoke_cpp___ indicates inclusion from jsinvoke.cpp. */
15996: #if !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___
12551: 
62953: JSObject *
62953: js::GetScopeChain(JSContext *cx)
62953: {
69223:     StackFrame *fp = js_GetTopStackFrame(cx);
62953:     if (!fp) {
62953:         /*
62953:          * There is no code active on this context. In place of an actual
62953:          * scope chain, use the context's global object, which is set in
62953:          * js_InitFunctionAndObjectClasses, and which represents the default
62953:          * scope chain for the embedding. See also js_FindClassObject.
62953:          *
62953:          * For embeddings that use the inner and outer object hooks, the inner
62953:          * object represents the ultimate global object, with the outer object
62953:          * acting as a stand-in.
62953:          */
62953:         JSObject *obj = cx->globalObject;
62953:         if (!obj) {
62953:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INACTIVE);
62953:             return NULL;
62953:         }
62953: 
62953:         OBJ_TO_INNER_OBJECT(cx, obj);
62953:         return obj;
62953:     }
62953:     return GetScopeChain(cx, fp);
62953: }
62953: 
53840: /*
54855:  * This computes the blockChain by iterating through the bytecode
54855:  * of the current script until it reaches the PC. Each time it sees
54855:  * an ENTERBLOCK or LEAVEBLOCK instruction, it records the new
54855:  * blockChain. A faster variant of this function that doesn't
54855:  * require bytecode scanning appears below.
54855:  */
54855: JSObject *
69223: js::GetBlockChain(JSContext *cx, StackFrame *fp)
54855: {
54855:     if (!fp->isScriptFrame())
54855:         return NULL;
54855: 
57755:     /* Assume that imacros don't affect blockChain */
71363:     jsbytecode *target = fp->hasImacropc() ? fp->imacropc() : fp->pcQuadratic(cx);
57755: 
54855:     JSScript *script = fp->script();
55467:     jsbytecode *start = script->code;
57755:     JS_ASSERT(target >= start && target < start + script->length);
54855: 
55526:     JSObject *blockChain = NULL;
57755:     uintN indexBase = 0;
54855:     ptrdiff_t oplen;
57755:     for (jsbytecode *pc = start; pc < target; pc += oplen) {
57755:         JSOp op = js_GetOpcode(cx, script, pc);
54855:         const JSCodeSpec *cs = &js_CodeSpec[op];
54855:         oplen = cs->length;
54855:         if (oplen < 0)
57755:             oplen = js_GetVariableBytecodeLength(pc);
57755: 
57755:         if (op == JSOP_INDEXBASE)
57755:             indexBase = GET_INDEXBASE(pc);
57755:         else if (op == JSOP_INDEXBASE1 || op == JSOP_INDEXBASE2 || op == JSOP_INDEXBASE3)
57755:             indexBase = (op - JSOP_INDEXBASE1 + 1) << 16;
57755:         else if (op == JSOP_RESETBASE || op == JSOP_RESETBASE0)
57755:             indexBase = 0;
57755:         else if (op == JSOP_ENTERBLOCK)
57755:             blockChain = script->getObject(indexBase + GET_INDEX(pc));
55526:         else if (op == JSOP_LEAVEBLOCK || op == JSOP_LEAVEBLOCKEXPR)
54855:             blockChain = blockChain->getParent();
55526:         else if (op == JSOP_BLOCKCHAIN)
57755:             blockChain = script->getObject(indexBase + GET_INDEX(pc));
55526:         else if (op == JSOP_NULLBLOCKCHAIN)
55526:             blockChain = NULL;
54855:     }
54855: 
54855:     return blockChain;
54855: }
54855: 
54855: /*
54855:  * This function computes the current blockChain, but only in
54855:  * the special case where a BLOCKCHAIN or NULLBLOCKCHAIN
54855:  * instruction appears immediately after the current PC.
54855:  * We ensure this happens for a few important ops like DEFFUN.
54855:  * |oplen| is the length of opcode at the current PC.
54855:  */
54855: JSObject *
69223: js::GetBlockChainFast(JSContext *cx, StackFrame *fp, JSOp op, size_t oplen)
54855: {
54855:     /* Assume that we're in a script frame. */
71363:     jsbytecode *pc = fp->pcQuadratic(cx);
54855:     JS_ASSERT(js_GetOpcode(cx, fp->script(), pc) == op);
57755: 
57755:     pc += oplen;
57755:     op = JSOp(*pc);
70289: 
70289:     /* The fast paths assume no JSOP_RESETBASE/INDEXBASE or JSOP_TRAP noise. */
57755:     if (op == JSOP_NULLBLOCKCHAIN)
54855:         return NULL;
57755:     if (op == JSOP_BLOCKCHAIN)
57755:         return fp->script()->getObject(GET_INDEX(pc));
57755: 
57755:     return GetBlockChain(cx, fp);
54855: }
54855: 
54855: /*
53840:  * We can't determine in advance which local variables can live on the stack and
53840:  * be freed when their dynamic scope ends, and which will be closed over and
53840:  * need to live in the heap.  So we place variables on the stack initially, note
53840:  * when they are closed over, and copy those that are out to the heap when we
53840:  * leave their dynamic scope.
53840:  *
53840:  * The bytecode compiler produces a tree of block objects accompanying each
53840:  * JSScript representing those lexical blocks in the script that have let-bound
53840:  * variables associated with them.  These block objects are never modified, and
53840:  * never become part of any function's scope chain.  Their parent slots point to
53840:  * the innermost block that encloses them, or are NULL in the outermost blocks
53840:  * within a function or in eval or global code.
53840:  *
53840:  * When we are in the static scope of such a block, blockChain points to its
53840:  * compiler-allocated block object; otherwise, it is NULL.
53840:  *
53840:  * scopeChain is the current scope chain, including 'call' and 'block' objects
53840:  * for those function calls and lexical blocks whose static scope we are
53840:  * currently executing in, and 'with' objects for with statements; the chain is
53840:  * typically terminated by a global object.  However, as an optimization, the
53840:  * young end of the chain omits block objects we have not yet cloned.  To create
53840:  * a closure, we clone the missing blocks from blockChain (which is always
53840:  * current), place them at the head of scopeChain, and use that for the
53840:  * closure's scope chain.  If we never close over a lexical block, we never
53840:  * place a mutable clone of it on scopeChain.
53840:  *
56729:  * This lazy cloning is implemented in GetScopeChain, which is also used in
53840:  * some other cases --- entering 'with' blocks, for example.
53840:  */
54855: static JSObject *
69223: GetScopeChainFull(JSContext *cx, StackFrame *fp, JSObject *blockChain)
54855: {
54855:     JSObject *sharedBlock = blockChain;
26238: 
26238:     if (!sharedBlock) {
    1:         /*
    1:          * Don't force a call object for a lightweight function call, but do
    1:          * insist that there is a call object for a heavyweight function call.
    1:          */
64364:         JS_ASSERT_IF(fp->isNonEvalFunctionFrame() && fp->fun()->isHeavyweight(),
50510:                      fp->hasCallObj());
53840:         return &fp->scopeChain();
    1:     }
    1: 
26238:     /* We don't handle cloning blocks on trace.  */
37741:     LeaveTrace(cx);
26238: 
    1:     /*
    1:      * We have one or more lexical scopes to reflect into fp->scopeChain, so
    1:      * make sure there's a call object at the current head of the scope chain,
    1:      * if this frame is a call frame.
26238:      *
26238:      * Also, identify the innermost compiler-allocated block we needn't clone.
26238:      */
26238:     JSObject *limitBlock, *limitClone;
64364:     if (fp->isNonEvalFunctionFrame() && !fp->hasCallObj()) {
64364:         JS_ASSERT_IF(fp->scopeChain().isClonedBlock(), fp->scopeChain().getPrivate() != fp);
64364:         if (!CreateFunCallObject(cx, fp))
    1:             return NULL;
26238: 
26238:         /* We know we must clone everything on blockChain. */
26238:         limitBlock = limitClone = NULL;
26238:     } else {
26238:         /*
26238:          * scopeChain includes all blocks whose static scope we're within that
26238:          * have already been cloned.  Find the innermost such block.  Its
26238:          * prototype should appear on blockChain; we'll clone blockChain up
26238:          * to, but not including, that prototype.
26238:          */
53840:         limitClone = &fp->scopeChain();
40826:         while (limitClone->getClass() == &js_WithClass)
39930:             limitClone = limitClone->getParent();
26238:         JS_ASSERT(limitClone);
26238: 
26238:         /*
26238:          * It may seem like we don't know enough about limitClone to be able
26238:          * to just grab its prototype as we do here, but it's actually okay.
26238:          *
26238:          * If limitClone is a block object belonging to this frame, then its
26238:          * prototype is the innermost entry in blockChain that we have already
26238:          * cloned, and is thus the place to stop when we clone below.
26238:          *
26238:          * Otherwise, there are no blocks for this frame on scopeChain, and we
26238:          * need to clone the whole blockChain.  In this case, limitBlock can
26238:          * point to any object known not to be on blockChain, since we simply
26238:          * loop until we hit limitBlock or NULL.  If limitClone is a block, it
26238:          * isn't a block from this function, since blocks can't be nested
26238:          * within themselves on scopeChain (recursion is dynamic nesting, not
26238:          * static nesting).  If limitClone isn't a block, its prototype won't
26238:          * be a block either.  So we can just grab limitClone's prototype here
26238:          * regardless of its type or which frame it belongs to.
26238:          */
39928:         limitBlock = limitClone->getProto();
26238: 
26238:         /* If the innermost block has already been cloned, we are done. */
26238:         if (limitBlock == sharedBlock)
53840:             return &fp->scopeChain();
26238:     }
26238: 
26238:     /*
26238:      * Special-case cloning the innermost block; this doesn't have enough in
26238:      * common with subsequent steps to include in the loop.
26238:      *
30645:      * js_CloneBlockObject leaves the clone's parent slot uninitialized. We
30645:      * populate it below.
30645:      */
30645:     JSObject *innermostNewChild = js_CloneBlockObject(cx, sharedBlock, fp);
26238:     if (!innermostNewChild)
26238:         return NULL;
48470:     AutoObjectRooter tvr(cx, innermostNewChild);
26238: 
26238:     /*
26238:      * Clone our way towards outer scopes until we reach the innermost
26238:      * enclosing function, or the innermost block we've already cloned.
26238:      */
26238:     JSObject *newChild = innermostNewChild;
26186:     for (;;) {
39928:         JS_ASSERT(newChild->getProto() == sharedBlock);
39930:         sharedBlock = sharedBlock->getParent();
26238: 
26238:         /* Sometimes limitBlock will be NULL, so check that first.  */
26238:         if (sharedBlock == limitBlock || !sharedBlock)
26238:             break;
26238: 
26238:         /* As in the call above, we don't know the real parent yet.  */
48470:         JSObject *clone = js_CloneBlockObject(cx, sharedBlock, fp);
26238:         if (!clone)
26186:             return NULL;
26238: 
39930:         newChild->setParent(clone);
26238:         newChild = clone;
26238:     }
53840:     newChild->setParent(&fp->scopeChain());
30645: 
26238: 
26238:     /*
26238:      * If we found a limit block belonging to this frame, then we should have
26238:      * found it in blockChain.
26238:      */
26238:     JS_ASSERT_IF(limitBlock &&
53650:                  limitBlock->isBlock() &&
42714:                  limitClone->getPrivate() == js_FloatingFrameIfGenerator(cx, fp),
26238:                  sharedBlock);
26238: 
26238:     /* Place our newly cloned blocks at the head of the scope chain.  */
53840:     fp->setScopeChainNoCallObj(*innermostNewChild);
48470:     return innermostNewChild;
    1: }
    1: 
54855: JSObject *
69223: js::GetScopeChain(JSContext *cx, StackFrame *fp)
56729: {
56729:     return GetScopeChainFull(cx, fp, GetBlockChain(cx, fp));
54855: }
54855: 
54855: JSObject *
69223: js::GetScopeChainFast(JSContext *cx, StackFrame *fp, JSOp op, size_t oplen)
56729: {
56729:     return GetScopeChainFull(cx, fp, GetBlockChainFast(cx, fp, op, oplen));
54855: }
54855: 
47405: /* Some objects (e.g., With) delegate 'this' to another object. */
47405: static inline JSObject *
48470: CallThisObjectHook(JSContext *cx, JSObject *obj, Value *argv)
47405: {
47405:     JSObject *thisp = obj->thisObject(cx);
47405:     if (!thisp)
47405:         return NULL;
48470:     argv[-1].setObject(*thisp);
47405:     return thisp;
47405: }
47405: 
48470: namespace js {
48470: 
55750: void
55711: ReportIncompatibleMethod(JSContext *cx, Value *vp, Class *clasp)
55711: {
55711:     Value &thisv = vp[1];
55711: 
55711: #ifdef DEBUG
55711:     if (thisv.isObject()) {
55711:         JS_ASSERT(thisv.toObject().getClass() != clasp);
55711:     } else if (thisv.isString()) {
55711:         JS_ASSERT(clasp != &js_StringClass);
55711:     } else if (thisv.isNumber()) {
55711:         JS_ASSERT(clasp != &js_NumberClass);
55711:     } else if (thisv.isBoolean()) {
55711:         JS_ASSERT(clasp != &js_BooleanClass);
55711:     } else {
55711:         JS_ASSERT(thisv.isUndefined() || thisv.isNull());
55711:     }
55711: #endif
55711: 
55711:     if (JSFunction *fun = js_ValueToFunction(cx, &vp[0], 0)) {
55711:         const char *name = thisv.isObject()
55711:                            ? thisv.toObject().getClass()->name
55711:                            : thisv.isString()
55711:                            ? "string"
55711:                            : thisv.isNumber()
55711:                            ? "number"
55711:                            : thisv.isBoolean()
55711:                            ? "boolean"
55711:                            : thisv.isNull()
55711:                            ? js_null_str
55711:                            : thisv.isUndefined()
55711:                            ? js_undefined_str
55711:                            : "value";
57812:         JSAutoByteString funNameBytes;
57812:         if (const char *funName = GetFunctionNameBytes(cx, fun, &funNameBytes)) {
57812:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INCOMPATIBLE_PROTO,
57812:                                  clasp->name, funName, name);
57812:         }
55711:     }
55711: }
55711: 
68904: /*
68904:  * ECMA requires "the global object", but in embeddings such as the browser,
68904:  * which have multiple top-level objects (windows, frames, etc. in the DOM),
68904:  * we prefer fun's parent.  An example that causes this code to run:
68904:  *
68904:  *   // in window w1
68904:  *   function f() { return this }
68904:  *   function g() { return f }
68904:  *
68904:  *   // in window w2
68904:  *   var h = w1.g()
68904:  *   alert(h() == w1)
68904:  *
68904:  * The alert should display "true".
68904:  */
55711: bool
68904: BoxNonStrictThis(JSContext *cx, const CallReceiver &call)
48470: {
50489:     /*
50489:      * Check for SynthesizeFrame poisoning and fast constructors which
68904:      * didn't check their callee properly.
50489:      */
68904:     Value &thisv = call.thisv();
68904:     JS_ASSERT(!thisv.isMagic());
68904: 
61734: #ifdef DEBUG
68904:     JSFunction *fun = call.callee().isFunction() ? call.callee().getFunctionPrivate() : NULL;
61734:     JS_ASSERT_IF(fun && fun->isInterpreted(), !fun->inStrictMode());
61734: #endif
61734: 
68904:     if (thisv.isNullOrUndefined()) {
68904:         JSObject *thisp = call.callee().getGlobal()->thisObject(cx);
68904:         if (!thisp)
68904:             return false;
68904:         call.thisv().setObject(*thisp);
68904:         return true;
68904:     }
68904: 
68904:     if (!thisv.isObject())
68904:         return !!js_PrimitiveToObject(cx, &thisv);
61734: 
53004:     return true;
47405: }
47405: 
48470: }
48470: 
    1: #if JS_HAS_NO_SUCH_METHOD
    1: 
55746: const uint32 JSSLOT_FOUND_FUNCTION  = 0;
55746: const uint32 JSSLOT_SAVED_ID        = 1;
14789: 
70310: static void
70310: no_such_method_trace(JSTracer *trc, JSObject *obj)
70310: {
70310:     gc::MarkValue(trc, obj->getSlot(JSSLOT_FOUND_FUNCTION), "found function");
70310:     gc::MarkValue(trc, obj->getSlot(JSSLOT_SAVED_ID), "saved id");
70310: }
70310: 
48470: Class js_NoSuchMethodClass = {
12579:     "NoSuchMethod",
28093:     JSCLASS_HAS_RESERVED_SLOTS(2) | JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
70310:     NULL,                 /* finalize */
70310:     NULL,                 /* reserved0 */
70310:     NULL,                 /* checkAccess */
70310:     NULL,                 /* call */
70310:     NULL,                 /* construct */
70310:     NULL,                 /* XDR */
70310:     NULL,                 /* hasInstance */
70310:     no_such_method_trace  /* trace */
12579: };
12579: 
12579: /*
12579:  * When JSOP_CALLPROP or JSOP_CALLELEM does not find the method property of
12579:  * the base object, we search for the __noSuchMethod__ method in the base.
12579:  * If it exists, we store the method and the property's id into an object of
12579:  * NoSuchMethod class and store this object into the callee's stack slot.
12579:  * Later, js_Invoke will recognise such an object and transfer control to
12579:  * NoSuchMethod that invokes the method like:
12579:  *
12579:  *   this.__noSuchMethod__(id, args)
12579:  *
12579:  * where id is the name of the method that this invocation attempted to
12579:  * call by name, and args is an Array containing this invocation's actual
12579:  * parameters.
12579:  */
53114: JSBool
48470: js_OnUnknownMethod(JSContext *cx, Value *vp)
48470: {
48470:     JS_ASSERT(!vp[1].isPrimitive());
48470: 
48470:     JSObject *obj = &vp[1].toObject();
33178:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.noSuchMethodAtom);
48470:     AutoValueRooter tvr(cx);
33178:     if (!js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, tvr.addr()))
33178:         return false;
48470:     if (tvr.value().isPrimitive()) {
33178:         vp[0] = tvr.value();
12579:     } else {
    1: #if JS_HAS_XML_SUPPORT
12610:         /* Extract the function name from function::name qname. */
48470:         if (vp[0].isObject()) {
48470:             obj = &vp[0].toObject();
33178:             if (!js_IsFunctionQName(cx, obj, &id))
33178:                 return false;
48470:             if (!JSID_IS_VOID(id))
48470:                 vp[0] = IdToValue(id);
12610:         }
    1: #endif
55746:         obj = js_NewGCObject(cx, FINALIZE_OBJECT2);
33178:         if (!obj)
33178:             return false;
47497: 
55746:         obj->init(cx, &js_NoSuchMethodClass, NULL, NULL, NULL, false);
70310:         obj->setSharedNonNativeMap();
55746:         obj->setSlot(JSSLOT_FOUND_FUNCTION, tvr.value());
55746:         obj->setSlot(JSSLOT_SAVED_ID, vp[0]);
48470:         vp[0].setObject(*obj);
12579:     }
33178:     return true;
12579: }
12579: 
24499: static JS_REQUIRES_STACK JSBool
69223: NoSuchMethod(JSContext *cx, uintN argc, Value *vp)
    1: {
42714:     InvokeArgsGuard args;
69223:     if (!cx->stack.pushInvokeArgs(cx, 2, &args))
14789:         return JS_FALSE;
12579: 
48470:     JS_ASSERT(vp[0].isObject());
48470:     JS_ASSERT(vp[1].isObject());
48470:     JSObject *obj = &vp[0].toObject();
40410:     JS_ASSERT(obj->getClass() == &js_NoSuchMethodClass);
14789: 
68893:     args.calleev() = obj->getSlot(JSSLOT_FOUND_FUNCTION);
50468:     args.thisv() = vp[1];
55746:     args[0] = obj->getSlot(JSSLOT_SAVED_ID);
59234:     JSObject *argsobj = NewDenseCopiedArray(cx, argc, vp + 2);
42714:     if (!argsobj)
42714:         return JS_FALSE;
50468:     args[1].setObject(*argsobj);
69223:     JSBool ok = Invoke(cx, args);
50468:     vp[0] = args.rval();
  348:     return ok;
    1: }
    1: 
    1: #endif /* JS_HAS_NO_SUCH_METHOD */
    1: 
48470: namespace js {
    1: 
52558: JS_REQUIRES_STACK bool
69223: RunScript(JSContext *cx, JSScript *script, StackFrame *fp)
52558: {
52558:     JS_ASSERT(script);
63047:     JS_ASSERT(fp == cx->fp());
63047:     JS_ASSERT(fp->script() == script);
63047: #ifdef JS_METHODJIT_SPEW
63047:     JMCheckLogging();
63047: #endif
63047: 
62584:     /* FIXME: Once bug 470510 is fixed, make this an assert. */
62954:     if (script->compileAndGo) {
68955:         if (fp->scopeChain().getGlobal()->isCleared()) {
62584:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CLEARED_SCOPE);
64365:             return false;
63047:         }
63047:     }
63047: 
63047: #ifdef JS_METHODJIT
63047:     mjit::CompileStatus status;
63047:     status = mjit::CanMethodJIT(cx, script, fp, mjit::CompileRequest_Interpreter);
63047:     if (status == mjit::Compile_Error)
64365:         return false;
64365: 
64365:     if (status == mjit::Compile_Okay)
64365:         return mjit::JaegerShot(cx);
63047: #endif
63047: 
64365:     return Interpret(cx, fp);
62584: }
52558: 
53557: /*
53557:  * Find a function reference and its 'this' value implicit first parameter
53557:  * under argc arguments on cx's stack, and call the function.  Push missing
53557:  * required arguments, allocate declared local variables, and pop everything
53557:  * when done.  Then push the return value.
53557:  */
53557: JS_REQUIRES_STACK bool
71695: Invoke(JSContext *cx, const CallArgs &argsRef, MaybeConstruct construct)
53557: {
55565:     /* N.B. Must be kept in sync with InvokeSessionGuard::start/invoke */
55565: 
53557:     CallArgs args = argsRef;
73495:     JS_ASSERT(args.argc() <= StackSpace::ARGS_LENGTH_MAX);
53557: 
68893:     if (args.calleev().isPrimitive()) {
71695:         js_ReportIsNotFunction(cx, &args.calleev(), ToReportFlags(construct));
53557:         return false;
53557:     }
53557: 
68893:     JSObject &callee = args.callee();
53840:     Class *clasp = callee.getClass();
53557: 
53557:     /* Invoke non-functions. */
53557:     if (JS_UNLIKELY(clasp != &js_FunctionClass)) {
53557: #if JS_HAS_NO_SUCH_METHOD
53557:         if (JS_UNLIKELY(clasp == &js_NoSuchMethodClass))
69223:             return NoSuchMethod(cx, args.argc(), args.base());
53557: #endif
71695:         JS_ASSERT_IF(construct, !clasp->construct);
53557:         if (!clasp->call) {
71695:             js_ReportIsNotFunction(cx, &args.calleev(), ToReportFlags(construct));
53557:             return false;
53557:         }
71695:         return CallJSNative(cx, clasp->call, args);
53557:     }
53557: 
53557:     /* Invoke native functions. */
53840:     JSFunction *fun = callee.getFunctionPrivate();
71695:     JS_ASSERT_IF(construct, !fun->isConstructor());
55713:     if (fun->isNative())
71695:         return CallJSNative(cx, fun->u.n.native, args);
53557: 
53557:     /* Handle the empty-script special case. */
55565:     JSScript *script = fun->script();
53557:     if (JS_UNLIKELY(script->isEmpty())) {
71695:         if (construct) {
55503:             JSObject *obj = js_CreateThisForFunction(cx, &callee);
55503:             if (!obj)
55503:                 return false;
55503:             args.rval().setObject(*obj);
53557:         } else {
53557:             args.rval().setUndefined();
53557:         }
47495:         return true;
47495:     }
53557: 
53840:     /* Get pointer to new frame/slots, prepare arguments. */
71695:     InvokeFrameGuard ifg;
71697:     if (!cx->stack.pushInvokeFrame(cx, args, construct, &ifg))
42714:         return false;
53840: 
53840:     /* Now that the new frame is rooted, maybe create a call object. */
71695:     StackFrame *fp = ifg.fp();
64364:     if (fun->isHeavyweight() && !CreateFunCallObject(cx, fp))
42714:         return false;
26728: 
53840:     /* Run function until JSOP_STOP, JSOP_RETURN or error. */
53557:     JSBool ok;
53557:     {
53557:         AutoPreserveEnumerators preserve(cx);
55503:         ok = RunScript(cx, script, fp);
56201:     }
53840: 
53840:     args.rval() = fp->returnValue();
71695:     JS_ASSERT_IF(ok && construct, !args.rval().isPrimitive());
    1:     return ok;
    1: }
    1: 
53557: bool
55565: InvokeSessionGuard::start(JSContext *cx, const Value &calleev, const Value &thisv, uintN argc)
55565: {
55565: #ifdef JS_TRACER
55565:     if (TRACE_RECORDER(cx))
55565:         AbortRecording(cx, "attempt to reenter VM while recording");
55565:     LeaveTrace(cx);
55565: #endif
55565: 
55565:     /* Always push arguments, regardless of optimized/normal invoke. */
69223:     ContextStack &stack = cx->stack;
55565:     if (!stack.pushInvokeArgs(cx, argc, &args_))
55565:         return false;
55565: 
56749:     /* Callees may clobber 'this' or 'callee'. */
68893:     savedCallee_ = args_.calleev() = calleev;
56749:     savedThis_ = args_.thisv() = thisv;
56749: 
74721:     /* If anyone (through jsdbgapi) finds this frame, make it safe. */
74721:     MakeRangeGCSafe(args_.argv(), args_.argc());
74721: 
55565:     do {
55565:         /* Hoist dynamic checks from scripted Invoke. */
55565:         if (!calleev.isObject())
55565:             break;
55565:         JSObject &callee = calleev.toObject();
55565:         if (callee.getClass() != &js_FunctionClass)
55565:             break;
55565:         JSFunction *fun = callee.getFunctionPrivate();
55565:         if (fun->isNative())
55565:             break;
55565:         script_ = fun->script();
63110:         if (fun->isHeavyweight() || script_->isEmpty())
63110:             break;
63110: 
63110:         /*
63110:          * The frame will remain pushed even when the callee isn't active which
63110:          * will affect the observable current global, so avoid any change.
63110:          */
63110:         if (callee.getGlobal() != GetGlobalForScopeChain(cx))
55565:             break;
55565: 
55565:         /* Push the stack frame once for the session. */
71697:         if (!stack.pushInvokeFrame(cx, args_, NO_CONSTRUCT, &ifg_))
55565:             return false;
71695: 
71695:         StackFrame *fp = ifg_.fp();
55565: #ifdef JS_METHODJIT
55565:         /* Hoist dynamic checks from RunScript. */
62574:         mjit::CompileStatus status = mjit::CanMethodJIT(cx, script_, fp, mjit::CompileRequest_JIT);
55565:         if (status == mjit::Compile_Error)
55565:             return false;
55565:         if (status != mjit::Compile_Okay)
55565:             break;
59983:         /* Cannot also cache the raw code pointer; it can change. */
55565: 
55565:         /* Hoist dynamic checks from CheckStackAndEnterMethodJIT. */
64246:         JS_CHECK_RECURSION(cx, return false);
73495:         stackLimit_ = stack.space().getStackLimit(cx, REPORT_ERROR);
55565:         if (!stackLimit_)
55565:             return false;
55565: 
55565:         stop_ = script_->code + script_->length - 1;
55565:         JS_ASSERT(*stop_ == JSOP_STOP);
55565: #endif
55565: 
55565:         /* Cached to avoid canonicalActualArg in InvokeSessionGuard::operator[]. */
55565:         nformals_ = fp->numFormalArgs();
55565:         formals_ = fp->formalArgs();
55565:         actuals_ = args_.argv();
55565:         JS_ASSERT(actuals_ == fp->actualArgs());
55565:         return true;
55565:     } while (0);
55565: 
55565:     /*
55565:      * Use the normal invoke path.
55565:      *
55565:      * The callee slot gets overwritten during an unoptimized Invoke, so we
55565:      * cache it here and restore it before every Invoke call. The 'this' value
55565:      * does not get overwritten, so we can fill it here once.
55565:      */
71695:     if (ifg_.pushed())
71695:         ifg_.pop();
55565:     formals_ = actuals_ = args_.argv();
55565:     nformals_ = (unsigned)-1;
55565:     return true;
55565: }
55565: 
55565: bool
53557: ExternalInvoke(JSContext *cx, const Value &thisv, const Value &fval,
48470:                uintN argc, Value *argv, Value *rval)
    1: {
42714:     LeaveTrace(cx);
    1: 
42714:     InvokeArgsGuard args;
69223:     if (!cx->stack.pushInvokeArgs(cx, argc, &args))
57687:         return false;
 6040: 
68893:     args.calleev() = fval;
50468:     args.thisv() = thisv;
50468:     memcpy(args.argv(), argv, argc * sizeof(Value));
48470: 
57761:     if (args.thisv().isObject()) {
57761:         /*
57761:          * We must call the thisObject hook in case we are not called from the
57761:          * interpreter, where a prior bytecode has computed an appropriate
57761:          * |this| already.
57761:          */
57761:         JSObject *thisp = args.thisv().toObject().thisObject(cx);
57761:         if (!thisp)
57761:              return false;
57761:         args.thisv().setObject(*thisp);
57761:     }
57761: 
69223:     if (!Invoke(cx, args))
57687:         return false;
42714: 
50468:     *rval = args.rval();
57687:     return true;
57687: }
57687: 
57687: bool
57687: ExternalInvokeConstructor(JSContext *cx, const Value &fval, uintN argc, Value *argv,
57687:                           Value *rval)
57687: {
57687:     LeaveTrace(cx);
57687: 
57687:     InvokeArgsGuard args;
69223:     if (!cx->stack.pushInvokeArgs(cx, argc, &args))
57687:         return false;
57687: 
68893:     args.calleev() = fval;
57687:     args.thisv().setMagic(JS_THIS_POISON);
57687:     memcpy(args.argv(), argv, argc * sizeof(Value));
57687: 
57687:     if (!InvokeConstructor(cx, args))
57687:         return false;
57687: 
57687:     *rval = args.rval();
57687:     return true;
    1: }
    1: 
48470: bool
53557: ExternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, const Value &fval,
48470:                  JSAccessMode mode, uintN argc, Value *argv, Value *rval)
    1: {
37741:     LeaveTrace(cx);
24499: 
    1:     /*
53557:      * ExternalInvoke could result in another try to get or set the same id
    1:      * again, see bug 355497.
    1:      */
64246:     JS_CHECK_RECURSION(cx, return false);
    1: 
61734:     return ExternalInvoke(cx, ObjectValue(*obj), fval, argc, argv, rval);
48470: }
48470: 
42714: #if JS_HAS_SHARP_VARS
42714: JS_STATIC_ASSERT(SHARP_NSLOTS == 2);
64364: 
64364: static JS_NEVER_INLINE bool
69223: InitSharpSlots(JSContext *cx, StackFrame *fp)
69223: {
69223:     StackFrame *prev = fp->prev();
64364:     JSScript *script = fp->script();
42714:     JS_ASSERT(script->nfixed >= SHARP_NSLOTS);
64364: 
64364:     Value *sharps = &fp->slots()[script->nfixed - SHARP_NSLOTS];
69704:     if (!fp->isGlobalFrame() && prev->script()->hasSharps) {
53840:         JS_ASSERT(prev->numFixed() >= SHARP_NSLOTS);
71697:         int base = prev->isNonEvalFunctionFrame()
59968:                    ? prev->fun()->script()->bindings.sharpSlotBase(cx)
53840:                    : prev->numFixed() - SHARP_NSLOTS;
42714:         if (base < 0)
42714:             return false;
53840:         sharps[0] = prev->slots()[base];
53840:         sharps[1] = prev->slots()[base + 1];
42714:     } else {
48470:         sharps[0].setUndefined();
48470:         sharps[1].setUndefined();
42714:     }
64364:     return true;
42714: }
42714: #endif
42714: 
64364: bool
71695: Execute(JSContext *cx, JSScript *script, JSObject &scopeChain, const Value &thisv,
71695:         ExecuteType type, StackFrame *evalInFrame, Value *result)
71695: {
71695:     JS_ASSERT_IF(evalInFrame, type == EXECUTE_DEBUG);
64364: 
64364:     if (script->isEmpty()) {
64364:         if (result)
64364:             result->setUndefined();
64364:         return true;
64364:     }
64364: 
64364:     LeaveTrace(cx);
64364:     AutoScriptRooter root(cx, script);
64364: 
71695:     ExecuteFrameGuard efg;
71695:     if (!cx->stack.pushExecuteFrame(cx, script, thisv, scopeChain, type, evalInFrame, &efg))
64364:         return false;
64364: 
71695:     /* Give strict mode eval its own fresh lexical environment. */
71695:     StackFrame *fp = efg.fp();
71695:     if (fp->isStrictEvalFrame() && !CreateEvalCallObject(cx, fp))
64364:         return false;
64364: 
64364: #if JS_HAS_SHARP_VARS
71695:     if (script->hasSharps && !InitSharpSlots(cx, fp))
64364:         return false;
64364: #endif
21685: 
53555:     Probes::startExecution(cx, script);
53555: 
43281:     AutoPreserveEnumerators preserve(cx);
71695:     JSBool ok = RunScript(cx, script, fp);
73070:     if (result && ok)
71695:         *result = fp->returnValue();
    1: 
53555:     Probes::stopExecution(cx, script);
53555: 
48470:     return !!ok;
48470: }
48470: 
48470: bool
71695: ExternalExecute(JSContext *cx, JSScript *script, JSObject &scopeChainArg, Value *rval)
71695: {
71695:     /* The scope chain could be anything, so innerize just in case. */
71695:     JSObject *scopeChain = &scopeChainArg;
71695:     OBJ_TO_INNER_OBJECT(cx, scopeChain);
71695:     if (!scopeChain)
71695:         return false;
71695: 
71695:     /* If we were handed a non-native object, complain bitterly. */
71695:     if (!scopeChain->isNative()) {
71695:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NON_NATIVE_SCOPE);
71695:         return false;
71695:     }
71695:     JS_ASSERT(!scopeChain->getOps()->defineProperty);
71695: 
71695:     /* The VAROBJFIX option makes varObj == globalObj in global code. */
71695:     if (!cx->hasRunOption(JSOPTION_VAROBJFIX))
71695:         scopeChain->makeVarObj();
71695: 
71695:     /* Use the scope chain as 'this', modulo outerization. */
71695:     JSObject *thisObj = scopeChain->thisObject(cx);
71695:     if (!thisObj)
71695:         return false;
71695:     Value thisv = ObjectValue(*thisObj);
71695: 
71695:     return Execute(cx, script, *scopeChain, thisv, EXECUTE_GLOBAL,
71695:                    NULL /* evalInFrame */, rval);
71695: }
71695: 
71695: bool
62411: CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs)
    1: {
    1:     JSObject *obj2;
    1:     JSProperty *prop;
62411:     uintN oldAttrs;
30258:     bool isFunction;
    1:     const char *type, *name;
    1: 
31501:     if (!obj->lookupProperty(cx, id, &obj2, &prop))
43290:         return false;
    1:     if (!prop)
43290:         return true;
43290:     if (obj2->isNative()) {
52503:         oldAttrs = ((Shape *) prop)->attributes();
43290:     } else {
43290:         if (!obj2->getAttributes(cx, id, &oldAttrs))
43290:             return false;
    1:     }
    1: 
    1:     /* We allow redeclaring some non-readonly properties. */
    1:     if (((oldAttrs | attrs) & JSPROP_READONLY) == 0) {
24592:         /* Allow redeclaration of variables and functions. */
    1:         if (!(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
62411:             return true;
24592: 
24592:         /*
24592:          * Allow adding a getter only if a property already has a setter
24592:          * but no getter and similarly for adding a setter. That is, we
24592:          * allow only the following transitions:
24592:          *
24592:          *   no-property --> getter --> getter + setter
24592:          *   no-property --> setter --> getter + setter
24592:          */
    1:         if ((~(oldAttrs ^ attrs) & (JSPROP_GETTER | JSPROP_SETTER)) == 0)
62411:             return true;
24592: 
24592:         /*
24592:          * Allow redeclaration of an impermanent property (in which case
24592:          * anyone could delete it and redefine it, willy-nilly).
24592:          */
    1:         if (!(oldAttrs & JSPROP_PERMANENT))
62411:             return true;
62411:     }
62411: 
    1:     isFunction = (oldAttrs & (JSPROP_GETTER | JSPROP_SETTER)) != 0;
    1:     if (!isFunction) {
48470:         Value value;
31501:         if (!obj->getProperty(cx, id, &value))
24592:             return JS_FALSE;
48470:         isFunction = IsFunctionObject(value);
    1:     }
62411: 
62411:     type = (oldAttrs & attrs & JSPROP_GETTER)
    1:            ? js_getter_str
    1:            : (oldAttrs & attrs & JSPROP_SETTER)
    1:            ? js_setter_str
    1:            : (oldAttrs & JSPROP_READONLY)
    1:            ? js_const_str
    1:            : isFunction
    1:            ? js_function_str
    1:            : js_var_str;
57812:     JSAutoByteString bytes;
57812:     name = js_ValueToPrintable(cx, IdToValue(id), &bytes);
    1:     if (!name)
62411:         return false;
62411:     JS_ALWAYS_FALSE(JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
62411:                                                  JSMSG_REDECLARED_VAR, type, name));
62411:     return false;
    1: }
    1: 
48529: JSBool
48547: HasInstance(JSContext *cx, JSObject *obj, const Value *v, JSBool *bp)
48529: {
48529:     Class *clasp = obj->getClass();
48529:     if (clasp->hasInstance)
48529:         return clasp->hasInstance(cx, obj, v, bp);
48529:     js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
48529:                         JSDVG_SEARCH_STACK, ObjectValue(*obj), NULL);
48529:     return JS_FALSE;
48529: }
48529: 
48470: bool
64551: LooselyEqual(JSContext *cx, const Value &lval, const Value &rval, JSBool *result)
64551: {
64551: #if JS_HAS_XML_SUPPORT
64551:     if (JS_UNLIKELY(lval.isObject() && lval.toObject().isXML()) ||
64551:                     (rval.isObject() && rval.toObject().isXML())) {
64551:         return js_TestXMLEquality(cx, lval, rval, result);
64551:     }
64551: #endif
64551: 
64551:     if (SameType(lval, rval)) {
64551:         if (lval.isString()) {
64551:             JSString *l = lval.toString();
64551:             JSString *r = rval.toString();
64551:             return EqualStrings(cx, l, r, result);
64551:         }
64551: 
64551:         if (lval.isDouble()) {
64551:             double l = lval.toDouble(), r = rval.toDouble();
64551:             *result = JSDOUBLE_COMPARE(l, ==, r, false);
64551:             return true;
64551:         }
64551: 
64551:         if (lval.isObject()) {
64551:             JSObject *l = &lval.toObject();
64551:             JSObject *r = &rval.toObject();
64551:             l->assertSpecialEqualitySynced();
64551: 
64551:             if (EqualityOp eq = l->getClass()->ext.equality) {
64551:                 return eq(cx, l, &rval, result);
64551:             }
64551: 
64551:             *result = l == r;
64551:             return true;
64551:         }
64551: 
64551:         *result = lval.payloadAsRawUint32() == rval.payloadAsRawUint32();
64551:         return true;
64551:     }
64551: 
64551:     if (lval.isNullOrUndefined()) {
64551:         *result = rval.isNullOrUndefined();
64551:         return true;
64551:     }
64551: 
64551:     if (rval.isNullOrUndefined()) {
64551:         *result = false;
64551:         return true;
64551:     }
64551: 
64551:     Value lvalue = lval;
64551:     Value rvalue = rval;
64551: 
72054:     if (!ToPrimitive(cx, &lvalue))
64551:         return false;
72054:     if (!ToPrimitive(cx, &rvalue))
64551:         return false;
64551: 
64551:     if (lvalue.isString() && rvalue.isString()) {
64551:         JSString *l = lvalue.toString();
64551:         JSString *r = rvalue.toString();
64551:         return EqualStrings(cx, l, r, result);
64551:     }
64551: 
64551:     double l, r;
73894:     if (!ToNumber(cx, lvalue, &l) || !ToNumber(cx, rvalue, &r))
64551:         return false;
64551:     *result = JSDOUBLE_COMPARE(l, ==, r, false);
64551:     return true;
64551: }
64551: 
64551: bool
59890: StrictlyEqual(JSContext *cx, const Value &lref, const Value &rref, JSBool *equal)
48470: {
48470:     Value lval = lref, rval = rref;
48470:     if (SameType(lval, rval)) {
48470:         if (lval.isString())
59890:             return EqualStrings(cx, lval.toString(), rval.toString(), equal);
59890:         if (lval.isDouble()) {
59890:             *equal = JSDOUBLE_COMPARE(lval.toDouble(), ==, rval.toDouble(), JS_FALSE);
53418:             return true;
59890:         }
59890:         if (lval.isObject()) {
68893:             *equal = lval.toObject() == rval.toObject();
59890:             return true;
59890:         }
59890:         if (lval.isUndefined()) {
59890:             *equal = true;
59890:             return true;
59890:         }
59890:         *equal = lval.payloadAsRawUint32() == rval.payloadAsRawUint32();
59890:         return true;
48470:     }
48470: 
48470:     if (lval.isDouble() && rval.isInt32()) {
48470:         double ld = lval.toDouble();
48470:         double rd = rval.toInt32();
59890:         *equal = JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
59890:         return true;
    1:     }
48470:     if (lval.isInt32() && rval.isDouble()) {
48470:         double ld = lval.toInt32();
48470:         double rd = rval.toDouble();
59890:         *equal = JSDOUBLE_COMPARE(ld, ==, rd, JS_FALSE);
59890:         return true;
59890:     }
59890: 
59890:     *equal = false;
59890:     return true;
    1: }
    1: 
32760: static inline bool
48470: IsNegativeZero(const Value &v)
48470: {
48470:     return v.isDouble() && JSDOUBLE_IS_NEGZERO(v.toDouble());
32760: }
32760: 
32760: static inline bool
48470: IsNaN(const Value &v)
48470: {
48470:     return v.isDouble() && JSDOUBLE_IS_NaN(v.toDouble());
48470: }
48470: 
48470: bool
59890: SameValue(JSContext *cx, const Value &v1, const Value &v2, JSBool *same)
59890: {
59890:     if (IsNegativeZero(v1)) {
59890:         *same = IsNegativeZero(v2);
48470:         return true;
59890:     }
59890:     if (IsNegativeZero(v2)) {
59890:         *same = false;
59890:         return true;
59890:     }
59890:     if (IsNaN(v1) && IsNaN(v2)) {
59890:         *same = true;
59890:         return true;
59890:     }
59890:     return StrictlyEqual(cx, v1, v2, same);
48470: }
48470: 
48470: JSType
48470: TypeOfValue(JSContext *cx, const Value &vref)
48470: {
48470:     Value v = vref;
48470:     if (v.isNumber())
48470:         return JSTYPE_NUMBER;
48470:     if (v.isString())
48470:         return JSTYPE_STRING;
48470:     if (v.isNull())
48470:         return JSTYPE_OBJECT;
48470:     if (v.isUndefined())
48470:         return JSTYPE_VOID;
48470:     if (v.isObject())
48622:         return v.toObject().typeOf(cx);
48470:     JS_ASSERT(v.isBoolean());
48470:     return JSTYPE_BOOLEAN;
48470: }
48470: 
48470: JS_REQUIRES_STACK bool
50468: InvokeConstructor(JSContext *cx, const CallArgs &argsRef)
    1: {
48529:     JS_ASSERT(!js_FunctionClass.construct);
50468:     CallArgs args = argsRef;
50468: 
68964:     if (args.calleev().isObject()) {
68964:         JSObject *callee = &args.callee();
68939:         Class *clasp = callee->getClass();
68939:         if (clasp == &js_FunctionClass) {
68964:             JSFunction *fun = callee->getFunctionPrivate();
68964: 
53557:             if (fun->isConstructor()) {
53557:                 args.thisv().setMagicWithObjectOrNullPayload(NULL);
73746:             Probes::calloutBegin(cx, fun);
73746:             bool ok = CallJSNativeConstructor(cx, fun->u.n.native, args);
73746:             Probes::calloutEnd(cx, fun);
73746:             return ok;
53557:             }
68964: 
68964:             if (!fun->isInterpretedConstructor())
68964:                 goto error;
68964: 
71695:             if (!Invoke(cx, args, CONSTRUCT))
68964:                 return false;
68964: 
68964:             JS_ASSERT(args.rval().isObject());
68964:             return true;
68964:         }
68964:         if (clasp->construct) {
68939:             args.thisv().setMagicWithObjectOrNullPayload(NULL);
71695:             return CallJSNativeConstructor(cx, clasp->construct, args);
68939:         }
68964:     }
68964: 
68964: error:
68964:     js_ReportIsNotFunction(cx, &args.calleev(), JSV2F_CONSTRUCT);
68939:     return false;
68936: }
68936: 
53557: bool
53557: InvokeConstructorWithGivenThis(JSContext *cx, JSObject *thisobj, const Value &fval,
53557:                                uintN argc, Value *argv, Value *rval)
53557: {
53557:     LeaveTrace(cx);
53557: 
53557:     InvokeArgsGuard args;
69223:     if (!cx->stack.pushInvokeArgs(cx, argc, &args))
    1:         return JS_FALSE;
53557: 
68893:     args.calleev() = fval;
53557:     /* Initialize args.thisv on all paths below. */
53557:     memcpy(args.argv(), argv, argc * sizeof(Value));
53557: 
53557:     /* Handle the fast-constructor cases before calling the general case. */
53557:     JSObject &callee = fval.toObject();
53557:     Class *clasp = callee.getClass();
53557:     JSFunction *fun;
53557:     bool ok;
53557:     if (clasp == &js_FunctionClass && (fun = callee.getFunctionPrivate())->isConstructor()) {
53557:         args.thisv().setMagicWithObjectOrNullPayload(thisobj);
73746:         Probes::calloutBegin(cx, fun);
71695:         ok = CallJSNativeConstructor(cx, fun->u.n.native, args);
73746:         Probes::calloutEnd(cx, fun);
53557:     } else if (clasp->construct) {
53557:         args.thisv().setMagicWithObjectOrNullPayload(thisobj);
71695:         ok = CallJSNativeConstructor(cx, clasp->construct, args);
53557:     } else {
53557:         args.thisv().setObjectOrNull(thisobj);
71695:         ok = Invoke(cx, args, CONSTRUCT);
53557:     }
53557: 
53557:     *rval = args.rval();
53557:     return ok;
    1: }
    1: 
48470: bool
48470: ValueToId(JSContext *cx, const Value &v, jsid *idp)
48470: {
48470:     int32_t i;
48470:     if (ValueFitsInInt32(v, &i) && INT_FITS_IN_JSID(i)) {
48470:         *idp = INT_TO_JSID(i);
48470:         return true;
48470:     }
    1: 
    1: #if JS_HAS_XML_SUPPORT
48470:     if (v.isObject()) {
48470:         JSObject *obj = &v.toObject();
48591:         if (obj->isXMLId()) {
48470:             *idp = OBJECT_TO_JSID(obj);
    1:             return JS_TRUE;
    1:         }
    1:     }
    1: #endif
    1: 
48470:     return js_ValueToStringId(cx, v, idp);
48470: }
48470: 
48470: } /* namespace js */
    1: 
    1: /*
11672:  * Enter the new with scope using an object at sp[-1] and associate the depth
11672:  * of the with block with sp + stackIndex.
11672:  */
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK JSBool
55527: js_EnterWith(JSContext *cx, jsint stackIndex, JSOp op, size_t oplen)
11672: {
69223:     StackFrame *fp = cx->fp();
69223:     Value *sp = cx->regs().sp;
11672:     JS_ASSERT(stackIndex < 0);
48470:     JS_ASSERT(fp->base() <= sp + stackIndex);
48470: 
48470:     JSObject *obj;
48470:     if (sp[-1].isObject()) {
48470:         obj = &sp[-1].toObject();
11672:     } else {
11672:         obj = js_ValueToNonNullObject(cx, sp[-1]);
11672:         if (!obj)
    1:             return JS_FALSE;
48470:         sp[-1].setObject(*obj);
48470:     }
48470: 
56729:     JSObject *parent = GetScopeChainFast(cx, fp, op, oplen);
11672:     if (!parent)
11672:         return JS_FALSE;
11672: 
11672:     OBJ_TO_INNER_OBJECT(cx, obj);
11672:     if (!obj)
11672:         return JS_FALSE;
11672: 
48470:     JSObject *withobj = js_NewWithObject(cx, obj, parent,
48470:                                          sp + stackIndex - fp->base());
11672:     if (!withobj)
11672:         return JS_FALSE;
11672: 
53840:     fp->setScopeChainNoCallObj(*withobj);
    1:     return JS_TRUE;
    1: }
    1: 
22652: JS_STATIC_INTERPRET JS_REQUIRES_STACK void
12551: js_LeaveWith(JSContext *cx)
11672: {
11672:     JSObject *withobj;
11672: 
53840:     withobj = &cx->fp()->scopeChain();
40826:     JS_ASSERT(withobj->getClass() == &js_WithClass);
51446:     JS_ASSERT(withobj->getPrivate() == js_FloatingFrameIfGenerator(cx, cx->fp()));
11758:     JS_ASSERT(OBJ_BLOCK_DEPTH(cx, withobj) >= 0);
31452:     withobj->setPrivate(NULL);
53840:     cx->fp()->setScopeChainNoCallObj(*withobj->getParent());
11672: }
11672: 
48470: JS_REQUIRES_STACK Class *
12551: js_IsActiveWithOrBlock(JSContext *cx, JSObject *obj, int stackDepth)
11758: {
48470:     Class *clasp;
11758: 
40826:     clasp = obj->getClass();
11758:     if ((clasp == &js_WithClass || clasp == &js_BlockClass) &&
51446:         obj->getPrivate() == js_FloatingFrameIfGenerator(cx, cx->fp()) &&
11758:         OBJ_BLOCK_DEPTH(cx, obj) >= stackDepth) {
11758:         return clasp;
11758:     }
11758:     return NULL;
11758: }
11758: 
11758: /*
11758:  * Unwind block and scope chains to match the given depth. The function sets
11758:  * fp->sp on return to stackDepth.
11758:  */
53114: JS_REQUIRES_STACK JSBool
42717: js_UnwindScope(JSContext *cx, jsint stackDepth, JSBool normalUnwind)
11758: {
48470:     Class *clasp;
11758: 
11758:     JS_ASSERT(stackDepth >= 0);
69223:     JS_ASSERT(cx->fp()->base() + stackDepth <= cx->regs().sp);
69223: 
69223:     StackFrame *fp = cx->fp();
11758:     for (;;) {
53840:         clasp = js_IsActiveWithOrBlock(cx, &fp->scopeChain(), stackDepth);
11758:         if (!clasp)
11758:             break;
11758:         if (clasp == &js_BlockClass) {
11758:             /* Don't fail until after we've updated all stacks. */
11859:             normalUnwind &= js_PutBlockObject(cx, normalUnwind);
11758:         } else {
12551:             js_LeaveWith(cx);
11758:         }
11758:     }
11758: 
69223:     cx->regs().sp = fp->base() + stackDepth;
11758:     return normalUnwind;
11758: }
11758: 
15996: JS_STATIC_INTERPRET JSBool
48470: js_DoIncDec(JSContext *cx, const JSCodeSpec *cs, Value *vp, Value *vp2)
12611: {
40828:     if (cs->format & JOF_POST) {
40828:         double d;
73894:         if (!ToNumber(cx, *vp, &d))
12611:             return JS_FALSE;
48470:         vp->setNumber(d);
40828:         (cs->format & JOF_INC) ? ++d : --d;
48470:         vp2->setNumber(d);
48470:         return JS_TRUE;
40828:     }
40828: 
40828:     double d;
73894:     if (!ToNumber(cx, *vp, &d))
12611:         return JS_FALSE;
40828:     (cs->format & JOF_INC) ? ++d : --d;
48470:     vp->setNumber(d);
48470:     *vp2 = *vp;
12611:     return JS_TRUE;
12611: }
12611: 
48470: const Value &
48582: js::GetUpvar(JSContext *cx, uintN closureLevel, UpvarCookie cookie)
48582: {
48582:     JS_ASSERT(closureLevel >= cookie.level() && cookie.level() > 0);
48582:     const uintN targetLevel = closureLevel - cookie.level();
48582:     JS_ASSERT(targetLevel < UpvarCookie::UPVAR_LEVEL_LIMIT);
48582: 
71697:     StackFrame *fp = FindUpvarFrame(cx, targetLevel);
47573:     uintN slot = cookie.slot();
71695:     const Value *vp;
27168: 
53840:     if (!fp->isFunctionFrame() || fp->isEvalFrame()) {
53840:         vp = fp->slots() + fp->numFixed();
51120:     } else if (slot < fp->numFormalArgs()) {
53840:         vp = fp->formalArgs();
47573:     } else if (slot == UpvarCookie::CALLEE_SLOT) {
68893:         vp = &fp->calleev();
27168:         slot = 0;
27168:     } else {
51120:         slot -= fp->numFormalArgs();
53840:         JS_ASSERT(slot < fp->numSlots());
42714:         vp = fp->slots();
27168:     }
27168: 
27168:     return vp[slot];
27168: }
27168: 
71697: extern StackFrame *
71697: js::FindUpvarFrame(JSContext *cx, uintN targetLevel)
71697: {
71697:     StackFrame *fp = cx->fp();
71697:     while (true) {
71697:         JS_ASSERT(fp && fp->isScriptFrame());
71697:         if (fp->script()->staticLevel == targetLevel)
71697:             break;
71697:         fp = fp->prev();
71697:     }
71697:     return fp;
71697: }
71697: 
15996: #endif /* !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___ */
15996: 
15996: #ifndef  jsinvoke_cpp___
12551: 
55638: #define PUSH_COPY(v)             do { *regs.sp++ = v; assertSameCompartment(cx, regs.sp[-1]); } while (0)
48470: #define PUSH_NULL()              regs.sp++->setNull()
48470: #define PUSH_UNDEFINED()         regs.sp++->setUndefined()
48470: #define PUSH_BOOLEAN(b)          regs.sp++->setBoolean(b)
48470: #define PUSH_DOUBLE(d)           regs.sp++->setDouble(d)
48470: #define PUSH_INT32(i)            regs.sp++->setInt32(i)
55638: #define PUSH_STRING(s)           do { regs.sp++->setString(s); assertSameCompartment(cx, regs.sp[-1]); } while (0)
55638: #define PUSH_OBJECT(obj)         do { regs.sp++->setObject(obj); assertSameCompartment(cx, regs.sp[-1]); } while (0)
55638: #define PUSH_OBJECT_OR_NULL(obj) do { regs.sp++->setObjectOrNull(obj); assertSameCompartment(cx, regs.sp[-1]); } while (0)
48470: #define PUSH_HOLE()              regs.sp++->setMagic(JS_ARRAY_HOLE)
48470: #define POP_COPY_TO(v)           v = *--regs.sp
69223: #define POP_RETURN_VALUE()       regs.fp()->setReturnValue(*--regs.sp)
48470: 
48470: #define POP_BOOLEAN(cx, vp, b)                                                \
12551:     JS_BEGIN_MACRO                                                            \
48470:         vp = &regs.sp[-1];                                                    \
48470:         if (vp->isNull()) {                                                   \
48470:             b = false;                                                        \
48470:         } else if (vp->isBoolean()) {                                         \
48470:             b = vp->toBoolean();                                              \
12551:         } else {                                                              \
48470:             b = !!js_ValueToBoolean(*vp);                                     \
12551:         }                                                                     \
13168:         regs.sp--;                                                            \
12551:     JS_END_MACRO
12551: 
48470: #define VALUE_TO_OBJECT(cx, vp, obj)                                          \
12551:     JS_BEGIN_MACRO                                                            \
48470:         if ((vp)->isObject()) {                                               \
48470:             obj = &(vp)->toObject();                                          \
12551:         } else {                                                              \
48470:             obj = js_ValueToNonNullObject(cx, *(vp));                         \
12551:             if (!obj)                                                         \
12551:                 goto error;                                                   \
48470:             (vp)->setObject(*obj);                                            \
12551:         }                                                                     \
12551:     JS_END_MACRO
12551: 
48470: #define FETCH_OBJECT(cx, n, obj)                                              \
12551:     JS_BEGIN_MACRO                                                            \
48470:         Value *vp_ = &regs.sp[n];                                             \
48470:         VALUE_TO_OBJECT(cx, vp_, obj);                                        \
12551:     JS_END_MACRO
12551: 
48470: /* Test whether v is an int in the range [-2^31 + 1, 2^31 - 2] */
48470: static JS_ALWAYS_INLINE bool
48470: CanIncDecWithoutOverflow(int32_t i)
48470: {
48470:     return (i > JSVAL_INT_MIN) && (i < JSVAL_INT_MAX);
48470: }
12611: 
12611: /*
    1:  * Threaded interpretation via computed goto appears to be well-supported by
    1:  * GCC 3 and higher.  IBM's C compiler when run with the right options (e.g.,
    1:  * -qlanglvl=extended) also supports threading.  Ditto the SunPro C compiler.
    1:  * Currently it's broken for JS_VERSION < 160, though this isn't worth fixing.
    1:  * Add your compiler support macros here.
    1:  */
    1: #ifndef JS_THREADED_INTERP
    1: # if JS_VERSION >= 160 && (                                                   \
    1:     __GNUC__ >= 3 ||                                                          \
    1:     (__IBMC__ >= 700 && defined __IBM_COMPUTED_GOTO) ||                       \
    1:     __SUNPRO_C >= 0x570)
    1: #  define JS_THREADED_INTERP 1
    1: # else
    1: #  define JS_THREADED_INTERP 0
    1: # endif
    1: #endif
    1: 
15453: /*
27164:  * Deadlocks or else bad races are likely if JS_THREADSAFE, so we must rely on
27164:  * single-thread DEBUG js shell testing to verify property cache hits.
27164:  */
27164: #if defined DEBUG && !defined JS_THREADSAFE
27164: 
27164: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry)                \
27164:     JS_BEGIN_MACRO                                                            \
27164:         if (!AssertValidPropertyCacheHit(cx, script, regs, pcoff, obj, pobj,  \
27164:                                          entry)) {                            \
27164:             goto error;                                                       \
27164:         }                                                                     \
27164:     JS_END_MACRO
27164: 
27164: static bool
69223: AssertValidPropertyCacheHit(JSContext *cx, JSScript *script, FrameRegs& regs,
27164:                             ptrdiff_t pcoff, JSObject *start, JSObject *found,
40362:                             PropertyCacheEntry *entry)
27164: {
27164:     uint32 sample = cx->runtime->gcNumber;
64357:     PropertyCacheEntry savedEntry = *entry;
27164: 
27164:     JSAtom *atom;
27164:     if (pcoff >= 0)
27164:         GET_ATOM_FROM_BYTECODE(script, regs.pc, pcoff, atom);
27164:     else
27164:         atom = cx->runtime->atomState.lengthAtom;
27164: 
27164:     JSObject *obj, *pobj;
27164:     JSProperty *prop;
33166:     JSBool ok;
27164: 
27164:     if (JOF_OPMODE(*regs.pc) == JOF_NAME) {
27164:         ok = js_FindProperty(cx, ATOM_TO_JSID(atom), &obj, &pobj, &prop);
27164:     } else {
27164:         obj = start;
27164:         ok = js_LookupProperty(cx, obj, ATOM_TO_JSID(atom), &pobj, &prop);
27164:     }
27164:     if (!ok)
27164:         return false;
64296:     if (cx->runtime->gcNumber != sample)
64357:         JS_PROPERTY_CACHE(cx).restore(&savedEntry);
27164:     JS_ASSERT(prop);
27164:     JS_ASSERT(pobj == found);
27164: 
52503:     const Shape *shape = (Shape *) prop;
40374:     if (entry->vword.isSlot()) {
52503:         JS_ASSERT(entry->vword.toSlot() == shape->slot);
52503:         JS_ASSERT(!shape->isMethod());
52503:     } else if (entry->vword.isShape()) {
52503:         JS_ASSERT(entry->vword.toShape() == shape);
52503:         JS_ASSERT_IF(shape->isMethod(),
68893:                      shape->methodObject() == pobj->nativeGetSlot(shape->slot).toObject());
27164:     } else {
48470:         Value v;
48470:         JS_ASSERT(entry->vword.isFunObj());
40374:         JS_ASSERT(!entry->vword.isNull());
52503:         JS_ASSERT(pobj->brandedOrHasMethodBarrier());
52503:         JS_ASSERT(shape->hasDefaultGetterOrIsMethod());
52503:         JS_ASSERT(pobj->containsSlot(shape->slot));
56567:         v = pobj->nativeGetSlot(shape->slot);
68893:         JS_ASSERT(entry->vword.toFunObj() == v.toObject());
32658: 
52503:         if (shape->isMethod()) {
32658:             JS_ASSERT(js_CodeSpec[*regs.pc].format & JOF_CALLOP);
68893:             JS_ASSERT(shape->methodObject() == v.toObject());
32658:         }
27164:     }
27164: 
27164:     return true;
27164: }
27164: 
27164: #else
27164: # define ASSERT_VALID_PROPERTY_CACHE_HIT(pcoff,obj,pobj,entry) ((void) 0)
27164: #endif
27164: 
27164: /*
    1:  * Ensure that the intrepreter switch can close call-bytecode cases in the
    1:  * same way as non-call bytecodes.
    1:  */
    1: JS_STATIC_ASSERT(JSOP_NAME_LENGTH == JSOP_CALLNAME_LENGTH);
52503: JS_STATIC_ASSERT(JSOP_GETFCSLOT_LENGTH == JSOP_CALLFCSLOT_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETARG_LENGTH == JSOP_CALLARG_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_GETLOCAL_LENGTH == JSOP_CALLLOCAL_LENGTH);
    1: JS_STATIC_ASSERT(JSOP_XMLNAME_LENGTH == JSOP_CALLXMLNAME_LENGTH);
    1: 
11377: /*
11377:  * Same for JSOP_SETNAME and JSOP_SETPROP, which differ only slightly but
32658:  * remain distinct for the decompiler. Likewise for JSOP_INIT{PROP,METHOD}.
11377:  */
11377: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETPROP_LENGTH);
32658: JS_STATIC_ASSERT(JSOP_SETNAME_LENGTH == JSOP_SETMETHOD_LENGTH);
32658: JS_STATIC_ASSERT(JSOP_INITPROP_LENGTH == JSOP_INITMETHOD_LENGTH);
11377: 
15464: /* See TRY_BRANCH_AFTER_COND. */
15464: JS_STATIC_ASSERT(JSOP_IFNE_LENGTH == JSOP_IFEQ_LENGTH);
15464: JS_STATIC_ASSERT(JSOP_IFNE == JSOP_IFEQ + 1);
15464: 
16051: /* For the fastest case inder JSOP_INCNAME, etc. */
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_DECNAME_LENGTH);
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEINC_LENGTH);
16051: JS_STATIC_ASSERT(JSOP_INCNAME_LENGTH == JSOP_NAMEDEC_LENGTH);
16051: 
27479: #ifdef JS_TRACER
27479: # define ABORT_RECORDING(cx, reason)                                          \
27479:     JS_BEGIN_MACRO                                                            \
27479:         if (TRACE_RECORDER(cx))                                               \
37741:             AbortRecording(cx, reason);                                       \
27479:     JS_END_MACRO
27479: #else
27464: # define ABORT_RECORDING(cx, reason)    ((void) 0)
27479: #endif
27479: 
42641: /*
42641:  * Inline fast paths for iteration. js_IteratorMore and js_IteratorNext handle
42641:  * all cases, but we inline the most frequently taken paths here.
42641:  */
42641: static inline bool
48470: IteratorMore(JSContext *cx, JSObject *iterobj, bool *cond, Value *rval)
42641: {
48622:     if (iterobj->getClass() == &js_IteratorClass) {
72108:         NativeIterator *ni = iterobj->getNativeIterator();
61055:         if (ni->isKeyIter()) {
42641:             *cond = (ni->props_cursor < ni->props_end);
61055:             return true;
61055:         }
61055:     }
42641:     if (!js_IteratorMore(cx, iterobj, rval))
42641:         return false;
48470:     *cond = rval->isTrue();
42641:     return true;
42641: }
42641: 
42641: static inline bool
48470: IteratorNext(JSContext *cx, JSObject *iterobj, Value *rval)
42641: {
48622:     if (iterobj->getClass() == &js_IteratorClass) {
72108:         NativeIterator *ni = iterobj->getNativeIterator();
61055:         if (ni->isKeyIter()) {
60785:             JS_ASSERT(ni->props_cursor < ni->props_end);
61055:             jsid id = *ni->current();
48470:             if (JSID_IS_ATOM(id)) {
48470:                 rval->setString(JSID_TO_STRING(id));
61055:                 ni->incCursor();
42641:                 return true;
42641:             }
42641:             /* Take the slow path if we have to stringify a numeric property name. */
48470:         }
42641:     }
42641:     return js_IteratorNext(cx, iterobj, rval);
42641: }
42641: 
48470: namespace js {
48470: 
54407: JS_REQUIRES_STACK JS_NEVER_INLINE bool
71363: Interpret(JSContext *cx, StackFrame *entryFrame, InterpMode interpMode)
    1: {
29368: #ifdef MOZ_TRACEVIS
31063:     TraceVisStateObj tvso(cx, S_INTERP);
29368: #endif
69855:     JSAutoResolveFlags rf(cx, RESOLVE_INFER);
    1: 
71699: #define COUNT_OP()         JS_BEGIN_MACRO                                     \
71699:                                if (pcCounts && !regs.fp()->hasImacropc())     \
71699:                                    ++pcCounts[regs.pc - script->code];        \
71699:                            JS_END_MACRO
71699: 
48470:     /*
48470:      * Macros for threaded interpreter loop
48470:      */
    1: #if JS_THREADED_INTERP
15510:     static void *const normalJumpTable[] = {
    1: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
    1:         JS_EXTENSION &&L_##op,
    1: # include "jsopcode.tbl"
    1: # undef OPDEF
    1:     };
    1: 
23111:     static void *const interruptJumpTable[] = {
17408: # define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format)              \
23111:         JS_EXTENSION &&interrupt,
17408: # include "jsopcode.tbl"
17408: # undef OPDEF
17408:     };
23111: 
23111:     register void * const *jumpTable = normalJumpTable;
    1: 
23111: # define ENABLE_INTERRUPTS() ((void) (jumpTable = interruptJumpTable))
23111: 
18171: # ifdef JS_TRACER
23111: #  define CHECK_RECORDER()                                                    \
23111:     JS_ASSERT_IF(TRACE_RECORDER(cx), jumpTable == interruptJumpTable)
18171: # else
18171: #  define CHECK_RECORDER()  ((void)0)
18171: # endif
18171: 
18171: # define DO_OP()            JS_BEGIN_MACRO                                    \
18171:                                 CHECK_RECORDER();                             \
71699:                                 COUNT_OP();                                   \
18161:                                 JS_EXTENSION_(goto *jumpTable[op]);           \
18161:                             JS_END_MACRO
15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
13168:                                 op = (JSOp) *(regs.pc += (n));                \
15453:                                 DO_OP();                                      \
15453:                             JS_END_MACRO
15453: 
72559: # define BEGIN_CASE(OP)     L_##OP: CHECK_RECORDER();
    1: # define END_CASE(OP)       DO_NEXT_OP(OP##_LENGTH);
    1: # define END_VARLEN_CASE    DO_NEXT_OP(len);
15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)                                    \
15453:                                 JS_ASSERT(js_CodeSpec[OP].length == 1);       \
15453:                                 op = (JSOp) *++regs.pc;                       \
15453:                                 DO_OP();
15453: 
15453: # define END_EMPTY_CASES
15453: 
15453: #else /* !JS_THREADED_INTERP */
15453: 
23111:     register intN switchMask = 0;
23111:     intN switchOp;
23111: 
23111: # define ENABLE_INTERRUPTS() ((void) (switchMask = -1))
23111: 
23111: # ifdef JS_TRACER
23111: #  define CHECK_RECORDER()                                                    \
23111:     JS_ASSERT_IF(TRACE_RECORDER(cx), switchMask == -1)
23111: # else
23111: #  define CHECK_RECORDER()  ((void)0)
23111: # endif
23111: 
    1: # define DO_OP()            goto do_op
15453: # define DO_NEXT_OP(n)      JS_BEGIN_MACRO                                    \
15453:                                 JS_ASSERT((n) == len);                        \
15453:                                 goto advance_pc;                              \
15453:                             JS_END_MACRO
15453: 
23111: # define BEGIN_CASE(OP)     case OP: CHECK_RECORDER();
15453: # define END_CASE(OP)       END_CASE_LEN(OP##_LENGTH)
15453: # define END_CASE_LEN(n)    END_CASE_LENX(n)
15453: # define END_CASE_LENX(n)   END_CASE_LEN##n
15453: 
15453: /*
15453:  * To share the code for all len == 1 cases we use the specialized label with
15453:  * code that falls through to advance_pc: .
15453:  */
15453: # define END_CASE_LEN1      goto advance_pc_by_one;
15453: # define END_CASE_LEN2      len = 2; goto advance_pc;
15453: # define END_CASE_LEN3      len = 3; goto advance_pc;
15453: # define END_CASE_LEN4      len = 4; goto advance_pc;
15453: # define END_CASE_LEN5      len = 5; goto advance_pc;
15453: # define END_VARLEN_CASE    goto advance_pc;
15453: # define ADD_EMPTY_CASE(OP) BEGIN_CASE(OP)
15453: # define END_EMPTY_CASES    goto advance_pc_by_one;
15453: 
18617: #endif /* !JS_THREADED_INTERP */
18617: 
48470: #define LOAD_ATOM(PCOFF, atom)                                                \
 3235:     JS_BEGIN_MACRO                                                            \
69223:         JS_ASSERT(regs.fp()->hasImacropc()                                    \
70270:                   ? atoms == rt->atomState.commonAtomsStart() &&              \
21685:                     GET_INDEX(regs.pc + PCOFF) < js_common_atom_count         \
21685:                   : (size_t)(atoms - script->atomMap.vector) <                \
13168:                     (size_t)(script->atomMap.length -                         \
13168:                              GET_INDEX(regs.pc + PCOFF)));                    \
13168:         atom = atoms[GET_INDEX(regs.pc + PCOFF)];                             \
 3235:     JS_END_MACRO
 3235: 
 3235: #define GET_FULL_INDEX(PCOFF)                                                 \
54855:     (atoms - script->atomMap.vector + GET_INDEX(regs.pc + (PCOFF)))
 3235: 
48470: #define LOAD_OBJECT(PCOFF, obj)                                               \
32723:     (obj = script->getObject(GET_FULL_INDEX(PCOFF)))
 3235: 
 3235: #define LOAD_FUNCTION(PCOFF)                                                  \
32723:     (fun = script->getFunction(GET_FULL_INDEX(PCOFF)))
    1: 
48470: #define LOAD_DOUBLE(PCOFF, dbl)                                               \
48470:     (dbl = script->getConst(GET_FULL_INDEX(PCOFF)).toDouble())
48470: 
70312: #if defined(JS_TRACER) || defined(JS_METHODJIT)
63095:     bool useMethodJIT = false;
70312: #endif
63095: 
62777: #ifdef JS_METHODJIT
63095: 
63095: #define RESET_USE_METHODJIT()                                                 \
63095:     JS_BEGIN_MACRO                                                            \
63095:         useMethodJIT = cx->methodJitEnabled &&                                \
63095:             interpMode == JSINTERP_NORMAL &&                                  \
69223:             script->getJITStatus(regs.fp()->isConstructing()) != JITScript_Invalid; \
63095:     JS_END_MACRO
62574: 
62574: #define MONITOR_BRANCH_METHODJIT()                                            \
62574:     JS_BEGIN_MACRO                                                            \
62574:         mjit::CompileStatus status =                                          \
69223:             mjit::CanMethodJITAtBranch(cx, script, regs.fp(), regs.pc);       \
62574:         if (status == mjit::Compile_Error)                                    \
62574:             goto error;                                                       \
62574:         if (status == mjit::Compile_Okay) {                                   \
62574:             void *ncode =                                                     \
69223:                 script->nativeCodeForPC(regs.fp()->isConstructing(), regs.pc);\
62574:             interpReturnOK = mjit::JaegerShotAtSafePoint(cx, ncode);          \
71363:             if (entryFrame != regs.fp())                                      \
62574:                 goto jit_return;                                              \
69223:             regs.fp()->setFinishedInInterpreter();                            \
62574:             goto leave_on_safe_point;                                         \
62574:         }                                                                     \
62602:         if (status == mjit::Compile_Abort) {                                  \
62777:             useMethodJIT = false;                                             \
62602:         }                                                                     \
62574:     JS_END_MACRO
62574: 
62574: #else
62574: 
63095: #define RESET_USE_METHODJIT() ((void) 0)
63095: 
62574: #define MONITOR_BRANCH_METHODJIT() ((void) 0)
62574: 
62574: #endif
62574: 
17598: #ifdef JS_TRACER
17598: 
29368: #ifdef MOZ_TRACEVIS
31063: #if JS_THREADED_INTERP
29368: #define MONITOR_BRANCH_TRACEVIS                                               \
29368:     JS_BEGIN_MACRO                                                            \
29368:         if (jumpTable != interruptJumpTable)                                  \
38585:             EnterTraceVisState(cx, S_RECORD, R_NONE);                         \
29368:     JS_END_MACRO
31063: #else /* !JS_THREADED_INTERP */
31063: #define MONITOR_BRANCH_TRACEVIS                                               \
31063:     JS_BEGIN_MACRO                                                            \
38585:         EnterTraceVisState(cx, S_RECORD, R_NONE);                             \
31063:     JS_END_MACRO
31063: #endif
29368: #else
29368: #define MONITOR_BRANCH_TRACEVIS
29368: #endif
29368: 
33564: #define RESTORE_INTERP_VARS()                                                 \
17410:     JS_BEGIN_MACRO                                                            \
69223:         script = regs.fp()->script();                                         \
69223:         argv = regs.fp()->maybeFormalArgs();                                  \
69223:         atoms = FrameAtomBase(cx, regs.fp());                                 \
69223:         JS_ASSERT(&cx->regs() == &regs);                                      \
60211:         if (cx->isExceptionPending())                                         \
48470:             goto error;                                                       \
33564:     JS_END_MACRO
33564: 
53524: #define MONITOR_BRANCH()                                                      \
33564:     JS_BEGIN_MACRO                                                            \
33564:         if (TRACING_ENABLED(cx)) {                                            \
62777:             if (!TRACE_RECORDER(cx) && !TRACE_PROFILER(cx) && useMethodJIT) { \
62574:                 MONITOR_BRANCH_METHODJIT();                                   \
62574:             } else {                                                          \
71363:                 MonitorResult r = MonitorLoopEdge(cx, interpMode);            \
41777:                 if (r == MONITOR_RECORDING) {                                 \
33564:                     JS_ASSERT(TRACE_RECORDER(cx));                            \
59946:                     JS_ASSERT(!TRACE_PROFILER(cx));                           \
33564:                     MONITOR_BRANCH_TRACEVIS;                                  \
33564:                     ENABLE_INTERRUPTS();                                      \
53589:                     CLEAR_LEAVE_ON_TRACE_POINT();                             \
33564:                 }                                                             \
33564:                 RESTORE_INTERP_VARS();                                        \
60211:                 JS_ASSERT_IF(cx->isExceptionPending(), r == MONITOR_ERROR);   \
41777:                 if (r == MONITOR_ERROR)                                       \
41777:                     goto error;                                               \
17923:             }                                                                 \
62602:         } else {                                                              \
62602:             MONITOR_BRANCH_METHODJIT();                                       \
62574:         }                                                                     \
17410:     JS_END_MACRO
17410: 
17598: #else /* !JS_TRACER */
17598: 
62602: #define MONITOR_BRANCH()                                                      \
62602:     JS_BEGIN_MACRO                                                            \
62602:         MONITOR_BRANCH_METHODJIT();                                           \
62602:     JS_END_MACRO
17598: 
17598: #endif /* !JS_TRACER */
17598: 
    1:     /*
11758:      * Prepare to call a user-supplied branch handler, and abort the script
11758:      * if it returns false.
11758:      */
17410: #define CHECK_BRANCH()                                                        \
 3235:     JS_BEGIN_MACRO                                                            \
53161:         if (JS_THREAD_DATA(cx)->interruptFlags && !js_HandleExecutionInterrupt(cx)) \
11859:             goto error;                                                       \
 3235:     JS_END_MACRO
23442: 
54560: #if defined(JS_TRACER) && defined(JS_METHODJIT)
53626: # define LEAVE_ON_SAFE_POINT()                                                \
53133:     do {                                                                      \
53626:         JS_ASSERT_IF(leaveOnSafePoint, !TRACE_RECORDER(cx));                  \
60157:         JS_ASSERT_IF(leaveOnSafePoint, !TRACE_PROFILER(cx));                  \
60157:         JS_ASSERT_IF(leaveOnSafePoint, interpMode != JSINTERP_NORMAL);        \
69223:         if (leaveOnSafePoint && !regs.fp()->hasImacropc() &&                  \
69223:             script->maybeNativeCodeForPC(regs.fp()->isConstructing(), regs.pc)) { \
53626:             JS_ASSERT(!TRACE_RECORDER(cx));                                   \
53133:             interpReturnOK = true;                                            \
56201:             goto leave_on_safe_point;                                         \
53133:         }                                                                     \
53133:     } while (0)
53145: #else
53626: # define LEAVE_ON_SAFE_POINT() /* nop */
53145: #endif
53133: 
17410: #define BRANCH(n)                                                             \
17410:     JS_BEGIN_MACRO                                                            \
25627:         regs.pc += (n);                                                       \
25627:         op = (JSOp) *regs.pc;                                                 \
26375:         if ((n) <= 0) {                                                       \
26375:             CHECK_BRANCH();                                                   \
56217:             if (op == JSOP_NOTRACE) {                                         \
56551:                 if (TRACE_RECORDER(cx) || TRACE_PROFILER(cx)) {               \
53524:                     MONITOR_BRANCH();                                         \
27038:                     op = (JSOp) *regs.pc;                                     \
27038:                 }                                                             \
32776:             } else if (op == JSOP_TRACE) {                                    \
53524:                 MONITOR_BRANCH();                                             \
25627:                 op = (JSOp) *regs.pc;                                         \
17410:             }                                                                 \
26375:         }                                                                     \
53626:         LEAVE_ON_SAFE_POINT();                                                \
17611:         DO_OP();                                                              \
17410:     JS_END_MACRO
16072: 
53840: #define CHECK_INTERRUPT_HANDLER()                                             \
53840:     JS_BEGIN_MACRO                                                            \
53840:         if (cx->debugHooks->interruptHook)                                    \
53840:             ENABLE_INTERRUPTS();                                              \
53840:     JS_END_MACRO
53840: 
69223:     FrameRegs regs = cx->regs();
56201: 
56201:     /* Repoint cx->regs to a local variable for faster access. */
56201:     struct InterpExitGuard {
56201:         JSContext *cx;
69223:         const FrameRegs &regs;
69223:         FrameRegs *prevContextRegs;
69223:         InterpExitGuard(JSContext *cx, FrameRegs &regs)
69223:           : cx(cx), regs(regs), prevContextRegs(&cx->regs()) {
69223:             cx->stack.repointRegs(&regs);
56201:         }
56201:         ~InterpExitGuard() {
69223:             JS_ASSERT(&cx->regs() == &regs);
56201:             *prevContextRegs = regs;
69223:             cx->stack.repointRegs(prevContextRegs);
56201:         }
56201:     } interpGuard(cx, regs);
53840: 
53840:     /* Copy in hot values that change infrequently. */
53840:     JSRuntime *const rt = cx->runtime;
69223:     JSScript *script = regs.fp()->script();
71699:     int *pcCounts = script->pcCounters.get(JSRUNMODE_INTERP);
69223:     Value *argv = regs.fp()->maybeFormalArgs();
53840:     CHECK_INTERRUPT_HANDLER();
53840: 
53626: #if defined(JS_TRACER) && defined(JS_METHODJIT)
56201:     bool leaveOnSafePoint = (interpMode == JSINTERP_SAFEPOINT);
53840: # define CLEAR_LEAVE_ON_TRACE_POINT() ((void) (leaveOnSafePoint = false))
53840: #else
53840: # define CLEAR_LEAVE_ON_TRACE_POINT() ((void) 0)
53840: #endif
53840: 
53840:     if (!entryFrame)
69223:         entryFrame = regs.fp();
18308: 
53631:     /*
53840:      * Initialize the index segment register used by LOAD_ATOM and
53840:      * GET_FULL_INDEX macros below. As a register we use a pointer based on
53840:      * the atom map to turn frequently executed LOAD_ATOM into simple array
53840:      * access. For less frequent object and regexp loads we have to recover
53840:      * the segment from atoms pointer first.
    1:      */
53840:     JSAtom **atoms = script->atomMap.vector;
42717: 
20908: #if JS_HAS_GENERATORS
69223:     if (JS_UNLIKELY(regs.fp()->isGeneratorFrame())) {
13168:         JS_ASSERT((size_t) (regs.pc - script->code) <= script->length);
69223:         JS_ASSERT((size_t) (regs.sp - regs.fp()->base()) <= StackDepth(script));
    1: 
    1:         /*
11758:          * To support generator_throw and to catch ignored exceptions,
60211:          * fail if cx->isExceptionPending() is true.
    1:          */
60211:         if (cx->isExceptionPending())
53557:             goto error;
    1:     }
42717: #endif
    1: 
33546: #ifdef JS_TRACER
53133:     /*
53133:      * The method JIT may have already initiated a recording, in which case
53133:      * there should already be a valid recorder. Otherwise...
53133:      * we cannot reenter the interpreter while recording.
53133:      */
56201:     if (interpMode == JSINTERP_RECORD) {
53133:         JS_ASSERT(TRACE_RECORDER(cx));
60157:         JS_ASSERT(!TRACE_PROFILER(cx));
53133:         ENABLE_INTERRUPTS();
56551:     } else if (interpMode == JSINTERP_PROFILE) {
56551:         ENABLE_INTERRUPTS();
53133:     } else if (TRACE_RECORDER(cx)) {
37741:         AbortRecording(cx, "attempt to reenter interpreter while recording");
53133:     }
53133: 
69223:     if (regs.fp()->hasImacropc())
70270:         atoms = rt->atomState.commonAtomsStart();
33546: #endif
33546: 
56201:     /* Don't call the script prologue if executing between Method and Trace JIT. */
56201:     if (interpMode == JSINTERP_NORMAL) {
69223:         JS_ASSERT_IF(!regs.fp()->isGeneratorFrame(), regs.pc == script->code);
69223:         if (!ScriptPrologueOrGeneratorResume(cx, regs.fp()))
56201:             goto error;
56201:     }
56201: 
56201:     CHECK_INTERRUPT_HANDLER();
56201: 
63095:     RESET_USE_METHODJIT();
63095: 
48470:     /* State communicated between non-local jumps: */
48470:     JSBool interpReturnOK;
48470:     JSAtom *atomNotDefined;
48470: 
15453:     /*
15453:      * It is important that "op" be initialized before calling DO_OP because
15453:      * it is possible for "op" to be specially assigned during the normal
15453:      * processing of an opcode while looping. We rely on DO_NEXT_OP to manage
15453:      * "op" correctly in all other cases.
15453:      */
48470:     JSOp op;
48470:     jsint len;
15453:     len = 0;
60214: 
60214:     /* Check for too deep of a native thread stack. */
60214: #ifdef JS_TRACER
60214: #ifdef JS_METHODJIT
60214:     JS_CHECK_RECURSION(cx, do {
60214:             if (TRACE_RECORDER(cx))
60214:                 AbortRecording(cx, "too much recursion");
60214:             if (TRACE_PROFILER(cx))
60214:                 AbortProfiling(cx);
60214:             goto error;
60214:         } while (0););
60214: #else
60214:     JS_CHECK_RECURSION(cx, do {
60214:             if (TRACE_RECORDER(cx))
60214:                 AbortRecording(cx, "too much recursion");
60214:             goto error;
60214:         } while (0););
60214: #endif
60214: #else
64246:     JS_CHECK_RECURSION(cx, goto error);
60214: #endif
60214: 
48470: #if JS_THREADED_INTERP
15453:     DO_NEXT_OP(len);
48470: #else
48470:     DO_NEXT_OP(len);
48470: #endif
15453: 
    1: #if JS_THREADED_INTERP
    1:     /*
    1:      * This is a loop, but it does not look like a loop. The loop-closing
15453:      * jump is distributed throughout goto *jumpTable[op] inside of DO_OP.
15453:      * When interrupts are enabled, jumpTable is set to interruptJumpTable
23111:      * where all jumps point to the interrupt label. The latter, after
15453:      * calling the interrupt handler, dispatches through normalJumpTable to
15453:      * continue the normal bytecode processing.
15453:      */
31481: 
23111: #else /* !JS_THREADED_INTERP */
15453:     for (;;) {
15453:       advance_pc_by_one:
15453:         JS_ASSERT(js_CodeSpec[op].length == 1);
15453:         len = 1;
15453:       advance_pc:
15453:         regs.pc += len;
13168:         op = (JSOp) *regs.pc;
15453: 
15453:       do_op:
23111:         CHECK_RECORDER();
23111:         switchOp = intN(op) | switchMask;
15453:       do_switch:
15453:         switch (switchOp) {
27490: #endif
31481: 
48470: #if JS_THREADED_INTERP
48470:   interrupt:
48470: #else /* !JS_THREADED_INTERP */
48470:   case -1:
48470:     JS_ASSERT(switchMask == -1);
48470: #endif /* !JS_THREADED_INTERP */
48470:     {
48470:         bool moreInterrupts = false;
48470:         JSInterruptHook hook = cx->debugHooks->interruptHook;
48470:         if (hook) {
48470: #ifdef JS_TRACER
48470:             if (TRACE_RECORDER(cx))
48470:                 AbortRecording(cx, "interrupt hook");
59946: #ifdef JS_METHODJIT
59946:             if (TRACE_PROFILER(cx))
59946:                 AbortProfiling(cx);
59946: #endif
48470: #endif
48470:             Value rval;
48470:             switch (hook(cx, script, regs.pc, Jsvalify(&rval),
48470:                          cx->debugHooks->interruptHookData)) {
48470:               case JSTRAP_ERROR:
48470:                 goto error;
48470:               case JSTRAP_CONTINUE:
48470:                 break;
48470:               case JSTRAP_RETURN:
69223:                 regs.fp()->setReturnValue(rval);
48470:                 interpReturnOK = JS_TRUE;
48470:                 goto forced_return;
48470:               case JSTRAP_THROW:
60211:                 cx->setPendingException(rval);
48470:                 goto error;
48470:               default:;
48470:             }
48470:             moreInterrupts = true;
48470:         }
48470: 
48470: #ifdef JS_TRACER
56551: #ifdef JS_METHODJIT
62596:         if (TRACE_PROFILER(cx) && interpMode == JSINTERP_PROFILE) {
62596:             LoopProfile *prof = TRACE_PROFILER(cx);
60157:             JS_ASSERT(!TRACE_RECORDER(cx));
56551:             LoopProfile::ProfileAction act = prof->profileOperation(cx, op);
56551:             switch (act) {
56551:                 case LoopProfile::ProfComplete:
60157:                     if (interpMode != JSINTERP_NORMAL) {
56551:                         leaveOnSafePoint = true;
56551:                         LEAVE_ON_SAFE_POINT();
60157:                     }
56551:                     break;
56551:                 default:
56551:                     moreInterrupts = true;
56551:                     break;
56551:             }
56551:         }
56551: #endif
48470:         if (TraceRecorder* tr = TRACE_RECORDER(cx)) {
60157:             JS_ASSERT(!TRACE_PROFILER(cx));
48470:             AbortableRecordingStatus status = tr->monitorRecording(op);
60211:             JS_ASSERT_IF(cx->isExceptionPending(), status == ARECORD_ERROR);
53626: 
56201:             if (interpMode != JSINTERP_NORMAL) {
56201:                 JS_ASSERT(interpMode == JSINTERP_RECORD || JSINTERP_SAFEPOINT);
53626:                 switch (status) {
53626:                   case ARECORD_IMACRO_ABORTED:
53626:                   case ARECORD_ABORTED:
53626:                   case ARECORD_COMPLETED:
53626:                   case ARECORD_STOP:
54560: #ifdef JS_METHODJIT
53626:                     leaveOnSafePoint = true;
53626:                     LEAVE_ON_SAFE_POINT();
54560: #endif
53626:                     break;
53626:                   default:
53626:                     break;
53626:                 }
53626:             }
53626: 
48470:             switch (status) {
48470:               case ARECORD_CONTINUE:
48470:                 moreInterrupts = true;
48470:                 break;
48470:               case ARECORD_IMACRO:
48470:               case ARECORD_IMACRO_ABORTED:
70270:                 atoms = rt->atomState.commonAtomsStart();
48470:                 op = JSOp(*regs.pc);
53589:                 CLEAR_LEAVE_ON_TRACE_POINT();
48470:                 if (status == ARECORD_IMACRO)
48470:                     DO_OP();    /* keep interrupting for op. */
48470:                 break;
48470:               case ARECORD_ERROR:
48470:                 // The code at 'error:' aborts the recording.
48470:                 goto error;
48470:               case ARECORD_ABORTED:
48470:               case ARECORD_COMPLETED:
48470:                 break;
48470:               case ARECORD_STOP:
48470:                 /* A 'stop' error should have already aborted recording. */
48470:               default:
48470:                 JS_NOT_REACHED("Bad recording status");
48470:             }
48470:         }
48470: #endif /* !JS_TRACER */
48470: 
48470: #if JS_THREADED_INTERP
48470: #ifdef MOZ_TRACEVIS
48470:         if (!moreInterrupts)
48470:             ExitTraceVisState(cx, R_ABORT);
48470: #endif
48470:         jumpTable = moreInterrupts ? interruptJumpTable : normalJumpTable;
48470:         JS_EXTENSION_(goto *normalJumpTable[op]);
48470: #else
48470:         switchMask = moreInterrupts ? -1 : 0;
48470:         switchOp = intN(op);
48470:         goto do_switch;
48470: #endif
48470:     }
48470: 
48470: /* No-ops for ease of decompilation. */
48470: ADD_EMPTY_CASE(JSOP_NOP)
48470: ADD_EMPTY_CASE(JSOP_CONDSWITCH)
48470: ADD_EMPTY_CASE(JSOP_TRY)
48470: #if JS_HAS_XML_SUPPORT
48470: ADD_EMPTY_CASE(JSOP_STARTXML)
48470: ADD_EMPTY_CASE(JSOP_STARTXMLEXPR)
48470: #endif
54855: ADD_EMPTY_CASE(JSOP_NULLBLOCKCHAIN)
48470: END_EMPTY_CASES
48470: 
53133: BEGIN_CASE(JSOP_TRACE)
56217: BEGIN_CASE(JSOP_NOTRACE)
53626:     LEAVE_ON_SAFE_POINT();
53133: END_CASE(JSOP_TRACE)
53133: 
48470: /* ADD_EMPTY_CASE is not used here as JSOP_LINENO_LENGTH == 3. */
48470: BEGIN_CASE(JSOP_LINENO)
54840: END_CASE(JSOP_LINENO)
48470: 
54855: BEGIN_CASE(JSOP_BLOCKCHAIN)
54855: END_CASE(JSOP_BLOCKCHAIN)
54855: 
48470: BEGIN_CASE(JSOP_PUSH)
48470:     PUSH_UNDEFINED();
48470: END_CASE(JSOP_PUSH)
48470: 
48470: BEGIN_CASE(JSOP_POP)
48470:     regs.sp--;
48470: END_CASE(JSOP_POP)
48470: 
48470: BEGIN_CASE(JSOP_POPN)
48470: {
48470:     regs.sp -= GET_UINT16(regs.pc);
48470: #ifdef DEBUG
69223:     JS_ASSERT(regs.fp()->base() <= regs.sp);
69223:     JSObject *obj = GetBlockChain(cx, regs.fp());
48470:     JS_ASSERT_IF(obj,
48470:                  OBJ_BLOCK_DEPTH(cx, obj) + OBJ_BLOCK_COUNT(cx, obj)
69223:                  <= (size_t) (regs.sp - regs.fp()->base()));
69223:     for (obj = &regs.fp()->scopeChain(); obj; obj = obj->getParent()) {
48470:         Class *clasp = obj->getClass();
48470:         if (clasp != &js_BlockClass && clasp != &js_WithClass)
48470:             continue;
69223:         if (obj->getPrivate() != js_FloatingFrameIfGenerator(cx, regs.fp()))
48470:             break;
69223:         JS_ASSERT(regs.fp()->base() + OBJ_BLOCK_DEPTH(cx, obj)
48470:                              + ((clasp == &js_BlockClass)
48470:                                 ? OBJ_BLOCK_COUNT(cx, obj)
48470:                                 : 1)
48470:                   <= regs.sp);
48470:     }
48470: #endif
48470: }
48470: END_CASE(JSOP_POPN)
48470: 
48470: BEGIN_CASE(JSOP_SETRVAL)
48470: BEGIN_CASE(JSOP_POPV)
51056:     POP_RETURN_VALUE();
48470: END_CASE(JSOP_POPV)
48470: 
48470: BEGIN_CASE(JSOP_ENTERWITH)
55527:     if (!js_EnterWith(cx, -1, JSOP_ENTERWITH, JSOP_ENTERWITH_LENGTH))
48470:         goto error;
48470: 
48470:     /*
48470:      * We must ensure that different "with" blocks have different stack depth
48470:      * associated with them. This allows the try handler search to properly
48470:      * recover the scope chain. Thus we must keep the stack at least at the
48470:      * current level.
48470:      *
48470:      * We set sp[-1] to the current "with" object to help asserting the
48470:      * enter/leave balance in [leavewith].
48470:      */
69223:     regs.sp[-1].setObject(regs.fp()->scopeChain());
48470: END_CASE(JSOP_ENTERWITH)
48470: 
48470: BEGIN_CASE(JSOP_LEAVEWITH)
69223:     JS_ASSERT(regs.sp[-1].toObject() == regs.fp()->scopeChain());
48470:     regs.sp--;
48470:     js_LeaveWith(cx);
48470: END_CASE(JSOP_LEAVEWITH)
48470: 
48470: BEGIN_CASE(JSOP_RETURN)
51056:     POP_RETURN_VALUE();
48470:     /* FALL THROUGH */
48470: 
51056: BEGIN_CASE(JSOP_RETRVAL)    /* fp return value already set */
48470: BEGIN_CASE(JSOP_STOP)
48470: {
48470:     /*
48470:      * When the inlined frame exits with an exception or an error, ok will be
48470:      * false after the inline_return label.
48470:      */
48470:     CHECK_BRANCH();
48470: 
53133: #ifdef JS_TRACER
69223:     if (regs.fp()->hasImacropc()) {
48470:         /*
48470:          * If we are at the end of an imacro, return to its caller in the
48470:          * current frame.
48470:          */
48470:         JS_ASSERT(op == JSOP_STOP);
69223:         JS_ASSERT((uintN)(regs.sp - regs.fp()->slots()) <= script->nslots);
69223:         jsbytecode *imacpc = regs.fp()->imacropc();
51055:         regs.pc = imacpc + js_CodeSpec[*imacpc].length;
69223:         regs.fp()->clearImacropc();
53626:         LEAVE_ON_SAFE_POINT();
48470:         atoms = script->atomMap.vector;
48470:         op = JSOp(*regs.pc);
48470:         DO_OP();
48470:     }
53133: #endif
48470: 
48470:     interpReturnOK = true;
69223:     if (entryFrame != regs.fp())
48470:   inline_return:
48470:     {
69223:         JS_ASSERT(!regs.fp()->hasImacropc());
69223:         JS_ASSERT(!js_IsActiveWithOrBlock(cx, &regs.fp()->scopeChain(), 0));
69223:         interpReturnOK = ScriptEpilogue(cx, regs.fp(), interpReturnOK);
48470:         CHECK_INTERRUPT_HANDLER();
56201: 
56201:         /* The JIT inlines ScriptEpilogue. */
64330: #ifdef JS_METHODJIT
56201:   jit_return:
64330: #endif
71697:         cx->stack.popInlineFrame(regs);
69223: 
69223:         /* Sync interpreter locals. */
69223:         script = regs.fp()->script();
71699:         pcCounts = script->pcCounters.get(JSRUNMODE_INTERP);
69223:         argv = regs.fp()->maybeFormalArgs();
69223:         atoms = FrameAtomBase(cx, regs.fp());
48470: 
74915:         JS_ASSERT(*regs.pc == JSOP_TRAP || *regs.pc == JSOP_NEW || *regs.pc == JSOP_CALL ||
74915:                   *regs.pc == JSOP_FUNCALL || *regs.pc == JSOP_FUNAPPLY);
74915: 
48470:         /* Resume execution in the calling frame. */
63095:         RESET_USE_METHODJIT();
48470:         if (JS_LIKELY(interpReturnOK)) {
48470:             TRACE_0(LeaveFrame);
51682:             len = JSOP_CALL_LENGTH;
51682:             DO_NEXT_OP(len);
51682:         }
74915: 
74915:         /* Increment pc so that |sp - fp->slots == ReconstructStackDepth(pc)|. */
74915:         regs.pc += JSOP_CALL_LENGTH;
51682:         goto error;
48470:     } else {
69223:         JS_ASSERT(regs.sp == regs.fp()->base());
48470:     }
48470:     interpReturnOK = true;
48470:     goto exit;
48470: }
48470: 
48470: BEGIN_CASE(JSOP_DEFAULT)
48470:     regs.sp--;
48470:     /* FALL THROUGH */
48470: BEGIN_CASE(JSOP_GOTO)
48470: {
48470:     len = GET_JUMP_OFFSET(regs.pc);
48470:     BRANCH(len);
48470: }
48470: END_CASE(JSOP_GOTO)
48470: 
48470: BEGIN_CASE(JSOP_IFEQ)
48470: {
48470:     bool cond;
48470:     Value *_;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     if (cond == false) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_IFEQ)
48470: 
48470: BEGIN_CASE(JSOP_IFNE)
48470: {
48470:     bool cond;
48470:     Value *_;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     if (cond != false) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_IFNE)
48470: 
48470: BEGIN_CASE(JSOP_OR)
48470: {
48470:     bool cond;
48470:     Value *vp;
48470:     POP_BOOLEAN(cx, vp, cond);
48470:     if (cond == true) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         PUSH_COPY(*vp);
48470:         DO_NEXT_OP(len);
48470:     }
48470: }
48470: END_CASE(JSOP_OR)
48470: 
48470: BEGIN_CASE(JSOP_AND)
48470: {
48470:     bool cond;
48470:     Value *vp;
48470:     POP_BOOLEAN(cx, vp, cond);
48470:     if (cond == false) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         PUSH_COPY(*vp);
48470:         DO_NEXT_OP(len);
48470:     }
48470: }
48470: END_CASE(JSOP_AND)
48470: 
48470: BEGIN_CASE(JSOP_DEFAULTX)
48470:     regs.sp--;
48470:     /* FALL THROUGH */
48470: BEGIN_CASE(JSOP_GOTOX)
48470: {
48470:     len = GET_JUMPX_OFFSET(regs.pc);
48470:     BRANCH(len);
48470: }
48470: END_CASE(JSOP_GOTOX);
48470: 
48470: BEGIN_CASE(JSOP_IFEQX)
48470: {
48470:     bool cond;
48470:     Value *_;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     if (cond == false) {
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_IFEQX)
48470: 
48470: BEGIN_CASE(JSOP_IFNEX)
48470: {
48470:     bool cond;
48470:     Value *_;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     if (cond != false) {
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_IFNEX)
48470: 
48470: BEGIN_CASE(JSOP_ORX)
48470: {
48470:     bool cond;
48470:     Value *vp;
48470:     POP_BOOLEAN(cx, vp, cond);
48470:     if (cond == true) {
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         PUSH_COPY(*vp);
48470:         DO_NEXT_OP(len);
48470:     }
48470: }
48470: END_CASE(JSOP_ORX)
48470: 
48470: BEGIN_CASE(JSOP_ANDX)
48470: {
48470:     bool cond;
48470:     Value *vp;
48470:     POP_BOOLEAN(cx, vp, cond);
48470:     if (cond == JS_FALSE) {
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         PUSH_COPY(*vp);
48470:         DO_NEXT_OP(len);
48470:     }
48470: }
48470: END_CASE(JSOP_ANDX)
48470: 
48470: /*
48470:  * If the index value at sp[n] is not an int that fits in a jsval, it could
48470:  * be an object (an XML QName, AttributeName, or AnyName), but only if we are
48470:  * compiling with JS_HAS_XML_SUPPORT.  Otherwise convert the index value to a
48470:  * string atom id.
48470:  */
48470: #define FETCH_ELEMENT_ID(obj, n, id)                                          \
48470:     JS_BEGIN_MACRO                                                            \
48470:         const Value &idval_ = regs.sp[n];                                     \
48470:         int32_t i_;                                                           \
48470:         if (ValueFitsInInt32(idval_, &i_) && INT_FITS_IN_JSID(i_)) {          \
48470:             id = INT_TO_JSID(i_);                                             \
48470:         } else {                                                              \
48470:             if (!js_InternNonIntElementId(cx, obj, idval_, &id, &regs.sp[n])) \
48470:                 goto error;                                                   \
48470:         }                                                                     \
48470:     JS_END_MACRO
48470: 
48470: #define TRY_BRANCH_AFTER_COND(cond,spdec)                                     \
48470:     JS_BEGIN_MACRO                                                            \
48470:         JS_ASSERT(js_CodeSpec[op].length == 1);                               \
48470:         uintN diff_ = (uintN) regs.pc[1] - (uintN) JSOP_IFEQ;                 \
48470:         if (diff_ <= 1) {                                                     \
48470:             regs.sp -= spdec;                                                 \
48470:             if (cond == (diff_ != 0)) {                                       \
48470:                 ++regs.pc;                                                    \
48470:                 len = GET_JUMP_OFFSET(regs.pc);                               \
48470:                 BRANCH(len);                                                  \
48470:             }                                                                 \
48470:             len = 1 + JSOP_IFEQ_LENGTH;                                       \
48470:             DO_NEXT_OP(len);                                                  \
48470:         }                                                                     \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_IN)
48470: {
48470:     const Value &rref = regs.sp[-1];
48470:     if (!rref.isObject()) {
48470:         js_ReportValueError(cx, JSMSG_IN_NOT_OBJECT, -1, rref, NULL);
48470:         goto error;
48470:     }
48470:     JSObject *obj = &rref.toObject();
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -2, id);
48470:     JSObject *obj2;
48470:     JSProperty *prop;
48470:     if (!obj->lookupProperty(cx, id, &obj2, &prop))
48470:         goto error;
48470:     bool cond = prop != NULL;
48470:     TRY_BRANCH_AFTER_COND(cond, 2);
48470:     regs.sp--;
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_IN)
48470: 
48470: BEGIN_CASE(JSOP_ITER)
48470: {
69223:     JS_ASSERT(regs.sp > regs.fp()->base());
48470:     uintN flags = regs.pc[1];
48470:     if (!js_ValueToIterator(cx, flags, &regs.sp[-1]))
48470:         goto error;
48470:     CHECK_INTERRUPT_HANDLER();
48470:     JS_ASSERT(!regs.sp[-1].isPrimitive());
48470: }
48470: END_CASE(JSOP_ITER)
48470: 
48470: BEGIN_CASE(JSOP_MOREITER)
48470: {
69223:     JS_ASSERT(regs.sp - 1 >= regs.fp()->base());
48470:     JS_ASSERT(regs.sp[-1].isObject());
48470:     PUSH_NULL();
48470:     bool cond;
48470:     if (!IteratorMore(cx, &regs.sp[-2].toObject(), &cond, &regs.sp[-1]))
48470:         goto error;
48470:     CHECK_INTERRUPT_HANDLER();
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_MOREITER)
48470: 
74052: BEGIN_CASE(JSOP_ITERNEXT)
74052: {
74052:     Value *itervp = regs.sp - GET_INT8(regs.pc);
74052:     JS_ASSERT(itervp >= regs.fp()->base());
74052:     JS_ASSERT(itervp->isObject());
74052:     PUSH_NULL();
74052:     if (!IteratorNext(cx, &itervp->toObject(), &regs.sp[-1]))
74052:         goto error;
74052: }
74052: END_CASE(JSOP_ITERNEXT)
74052: 
48470: BEGIN_CASE(JSOP_ENDITER)
48470: {
69223:     JS_ASSERT(regs.sp - 1 >= regs.fp()->base());
48470:     bool ok = !!js_CloseIterator(cx, &regs.sp[-1].toObject());
48470:     regs.sp--;
48470:     if (!ok)
48470:         goto error;
48470: }
48470: END_CASE(JSOP_ENDITER)
48470: 
48470: BEGIN_CASE(JSOP_DUP)
48470: {
69223:     JS_ASSERT(regs.sp > regs.fp()->base());
48470:     const Value &rref = regs.sp[-1];
48470:     PUSH_COPY(rref);
48470: }
48470: END_CASE(JSOP_DUP)
48470: 
48470: BEGIN_CASE(JSOP_DUP2)
48470: {
69223:     JS_ASSERT(regs.sp - 2 >= regs.fp()->base());
48470:     const Value &lref = regs.sp[-2];
48470:     const Value &rref = regs.sp[-1];
48470:     PUSH_COPY(lref);
48470:     PUSH_COPY(rref);
48470: }
48470: END_CASE(JSOP_DUP2)
48470: 
48470: BEGIN_CASE(JSOP_SWAP)
48470: {
69223:     JS_ASSERT(regs.sp - 2 >= regs.fp()->base());
48470:     Value &lref = regs.sp[-2];
48470:     Value &rref = regs.sp[-1];
48470:     lref.swap(rref);
48470: }
48470: END_CASE(JSOP_SWAP)
48470: 
48470: BEGIN_CASE(JSOP_PICK)
48470: {
48470:     jsint i = regs.pc[1];
69223:     JS_ASSERT(regs.sp - (i+1) >= regs.fp()->base());
48470:     Value lval = regs.sp[-(i+1)];
48470:     memmove(regs.sp - (i+1), regs.sp - i, sizeof(Value)*i);
48470:     regs.sp[-1] = lval;
48470: }
48470: END_CASE(JSOP_PICK)
48470: 
52503: #define NATIVE_GET(cx,obj,pobj,shape,getHow,vp)                               \
48470:     JS_BEGIN_MACRO                                                            \
54861:         if (shape->isDataDescriptor() && shape->hasDefaultGetter()) {         \
48470:             /* Fast path for Object instance properties. */                   \
52503:             JS_ASSERT((shape)->slot != SHAPE_INVALID_SLOT ||                  \
52503:                       !shape->hasDefaultSetter());                            \
52503:             if (((shape)->slot != SHAPE_INVALID_SLOT))                        \
56567:                 *(vp) = (pobj)->nativeGetSlot((shape)->slot);                 \
48470:             else                                                              \
48470:                 (vp)->setUndefined();                                         \
48470:         } else {                                                              \
52503:             if (!js_NativeGet(cx, obj, pobj, shape, getHow, vp))              \
48470:                 goto error;                                                   \
48470:         }                                                                     \
48470:     JS_END_MACRO
48470: 
62395: #define NATIVE_SET(cx,obj,shape,entry,strict,vp)                              \
48470:     JS_BEGIN_MACRO                                                            \
52503:         if (shape->hasDefaultSetter() &&                                      \
52503:             (shape)->slot != SHAPE_INVALID_SLOT &&                            \
52503:             !(obj)->brandedOrHasMethodBarrier()) {                            \
48470:             /* Fast path for, e.g., plain Object instance properties. */      \
56567:             (obj)->nativeSetSlot((shape)->slot, *vp);                         \
48470:         } else {                                                              \
62395:             if (!js_NativeSet(cx, obj, shape, false, strict, vp))             \
48470:                 goto error;                                                   \
48470:         }                                                                     \
48470:     JS_END_MACRO
48470: 
48470: /*
48470:  * Skip the JSOP_POP typically found after a JSOP_SET* opcode, where oplen is
48470:  * the constant length of the SET opcode sequence, and spdec is the constant
48470:  * by which to decrease the stack pointer to pop all of the SET op's operands.
48470:  *
48470:  * NB: unlike macros that could conceivably be replaced by functions (ignoring
48470:  * goto error), where a call should not have to be braced in order to expand
48470:  * correctly (e.g., in if (cond) FOO(); else BAR()), these three macros lack
48470:  * JS_{BEGIN,END}_MACRO brackets. They are also indented so as to align with
48470:  * nearby opcode code.
48470:  */
48470: #define SKIP_POP_AFTER_SET(oplen,spdec)                                       \
48470:             if (regs.pc[oplen] == JSOP_POP) {                                 \
48470:                 regs.sp -= spdec;                                             \
48470:                 regs.pc += oplen + JSOP_POP_LENGTH;                           \
48470:                 op = (JSOp) *regs.pc;                                         \
48470:                 DO_OP();                                                      \
48470:             }
48470: 
48470: #define END_SET_CASE(OP)                                                      \
48470:             SKIP_POP_AFTER_SET(OP##_LENGTH, 1);                               \
48470:           END_CASE(OP)
48470: 
48470: #define END_SET_CASE_STORE_RVAL(OP,spdec)                                     \
48470:             SKIP_POP_AFTER_SET(OP##_LENGTH, spdec);                           \
48470:             {                                                                 \
48470:                 Value *newsp = regs.sp - ((spdec) - 1);                       \
48470:                 newsp[-1] = regs.sp[-1];                                      \
48470:                 regs.sp = newsp;                                              \
48470:             }                                                                 \
48470:           END_CASE(OP)
48470: 
48470: BEGIN_CASE(JSOP_SETCONST)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
71694:     JSObject &obj = regs.fp()->varObj();
48470:     const Value &ref = regs.sp[-1];
53840:     if (!obj.defineProperty(cx, ATOM_TO_JSID(atom), ref,
62395:                             PropertyStub, StrictPropertyStub,
48470:                             JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
48470:         goto error;
48470:     }
48470: }
48470: END_SET_CASE(JSOP_SETCONST);
48470: 
48470: #if JS_HAS_DESTRUCTURING
48470: BEGIN_CASE(JSOP_ENUMCONSTELEM)
48470: {
48470:     const Value &ref = regs.sp[-3];
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -2, obj);
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -1, id);
48470:     if (!obj->defineProperty(cx, id, ref,
62395:                              PropertyStub, StrictPropertyStub,
48470:                              JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
48470:         goto error;
48470:     }
48470:     regs.sp -= 3;
48470: }
48470: END_CASE(JSOP_ENUMCONSTELEM)
48470: #endif
48470: 
53092: BEGIN_CASE(JSOP_BINDGNAME)
69223:     PUSH_OBJECT(*regs.fp()->scopeChain().getGlobal());
53092: END_CASE(JSOP_BINDGNAME)
53092: 
48470: BEGIN_CASE(JSOP_BINDNAME)
48470: {
48470:     JSObject *obj;
48470:     do {
48470:         /*
48470:          * We can skip the property lookup for the global object. If the
48470:          * property does not exist anywhere on the scope chain, JSOP_SETNAME
48470:          * adds the property to the global.
48470:          *
48470:          * As a consequence of this optimization for the global object we run
48470:          * its JSRESOLVE_ASSIGNING-tolerant resolve hooks only in JSOP_SETNAME,
48470:          * after the interpreter evaluates the right- hand-side of the
48470:          * assignment, and not here.
48470:          *
48470:          * This should be transparent to the hooks because the script, instead
48470:          * of name = rhs, could have used global.name = rhs given a global
48470:          * object reference, which also calls the hooks only after evaluating
48470:          * the rhs. We desire such resolve hook equivalence between the two
48470:          * forms.
48470:          */
69223:         obj = &regs.fp()->scopeChain();
48470:         if (!obj->getParent())
48470:             break;
48470: 
48470:         PropertyCacheEntry *entry;
48470:         JSObject *obj2;
48470:         JSAtom *atom;
48470:         JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
48470:         if (!atom) {
48470:             ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
48470:             break;
48470:         }
48470: 
48470:         jsid id = ATOM_TO_JSID(atom);
69223:         obj = js_FindIdentifierBase(cx, &regs.fp()->scopeChain(), id);
48470:         if (!obj)
48470:             goto error;
48470:     } while (0);
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_BINDNAME)
48470: 
48470: BEGIN_CASE(JSOP_IMACOP)
69223:     JS_ASSERT(JS_UPTRDIFF(regs.fp()->imacropc(), script->code) < script->length);
69223:     op = JSOp(*regs.fp()->imacropc());
48470:     DO_OP();
48470: 
48470: #define BITWISE_OP(OP)                                                        \
48470:     JS_BEGIN_MACRO                                                            \
48470:         int32_t i, j;                                                         \
48470:         if (!ValueToECMAInt32(cx, regs.sp[-2], &i))                           \
48470:             goto error;                                                       \
48470:         if (!ValueToECMAInt32(cx, regs.sp[-1], &j))                           \
48470:             goto error;                                                       \
48470:         i = i OP j;                                                           \
48470:         regs.sp--;                                                            \
48470:         regs.sp[-1].setInt32(i);                                              \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_BITOR)
48470:     BITWISE_OP(|);
48470: END_CASE(JSOP_BITOR)
48470: 
48470: BEGIN_CASE(JSOP_BITXOR)
48470:     BITWISE_OP(^);
48470: END_CASE(JSOP_BITXOR)
48470: 
48470: BEGIN_CASE(JSOP_BITAND)
48470:     BITWISE_OP(&);
48470: END_CASE(JSOP_BITAND)
48470: 
48470: #undef BITWISE_OP
48470: 
64551: #define EQUALITY_OP(OP)                                                       \
64551:     JS_BEGIN_MACRO                                                            \
64551:         Value rval = regs.sp[-1];                                             \
64551:         Value lval = regs.sp[-2];                                             \
64551:         JSBool cond;                                                          \
64551:         if (!LooselyEqual(cx, lval, rval, &cond))                             \
64319:             goto error;                                                       \
64319:         cond = cond OP JS_TRUE;                                               \
48470:         TRY_BRANCH_AFTER_COND(cond, 2);                                       \
48470:         regs.sp--;                                                            \
48470:         regs.sp[-1].setBoolean(cond);                                         \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_EQ)
64551:     EQUALITY_OP(==);
48470: END_CASE(JSOP_EQ)
48470: 
48470: BEGIN_CASE(JSOP_NE)
64551:     EQUALITY_OP(!=);
48470: END_CASE(JSOP_NE)
48470: 
48470: #undef EQUALITY_OP
48470: 
48470: #define STRICT_EQUALITY_OP(OP, COND)                                          \
48470:     JS_BEGIN_MACRO                                                            \
48470:         const Value &rref = regs.sp[-1];                                      \
48470:         const Value &lref = regs.sp[-2];                                      \
59890:         JSBool equal;                                                         \
59890:         if (!StrictlyEqual(cx, lref, rref, &equal))                           \
59890:             goto error;                                                       \
59908:         COND = equal OP JS_TRUE;                                              \
48470:         regs.sp--;                                                            \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_STRICTEQ)
48470: {
48470:     bool cond;
48470:     STRICT_EQUALITY_OP(==, cond);
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_STRICTEQ)
48470: 
48470: BEGIN_CASE(JSOP_STRICTNE)
48470: {
48470:     bool cond;
48470:     STRICT_EQUALITY_OP(!=, cond);
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_STRICTNE)
48470: 
48470: BEGIN_CASE(JSOP_CASE)
48470: {
48470:     bool cond;
48470:     STRICT_EQUALITY_OP(==, cond);
48470:     if (cond) {
48470:         regs.sp--;
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_CASE)
48470: 
48470: BEGIN_CASE(JSOP_CASEX)
48470: {
48470:     bool cond;
48470:     STRICT_EQUALITY_OP(==, cond);
48470:     if (cond) {
48470:         regs.sp--;
48470:         len = GET_JUMPX_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
48470: }
48470: END_CASE(JSOP_CASEX)
48470: 
48470: #undef STRICT_EQUALITY_OP
48470: 
48470: #define RELATIONAL_OP(OP)                                                     \
48470:     JS_BEGIN_MACRO                                                            \
72054:         Value &rval = regs.sp[-1];                                            \
72054:         Value &lval = regs.sp[-2];                                            \
48470:         bool cond;                                                            \
48470:         /* Optimize for two int-tagged operands (typical loop control). */    \
48470:         if (lval.isInt32() && rval.isInt32()) {                               \
48470:             cond = lval.toInt32() OP rval.toInt32();                          \
48470:         } else {                                                              \
72054:             if (!ToPrimitive(cx, JSTYPE_NUMBER, &lval))                       \
72054:                 goto error;                                                   \
72054:             if (!ToPrimitive(cx, JSTYPE_NUMBER, &rval))                       \
72054:                 goto error;                                                   \
48470:             if (lval.isString() && rval.isString()) {                         \
48470:                 JSString *l = lval.toString(), *r = rval.toString();          \
59890:                 int32 result;                                                 \
59890:                 if (!CompareStrings(cx, l, r, &result))                       \
59890:                     goto error;                                               \
59890:                 cond = result OP 0;                                           \
48470:             } else {                                                          \
48470:                 double l, r;                                                  \
73894:                 if (!ToNumber(cx, lval, &l) || !ToNumber(cx, rval, &r))       \
48470:                     goto error;                                               \
48470:                 cond = JSDOUBLE_COMPARE(l, OP, r, false);                     \
48470:             }                                                                 \
48470:         }                                                                     \
48470:         TRY_BRANCH_AFTER_COND(cond, 2);                                       \
72054:         regs.sp[-2].setBoolean(cond);                                         \
48470:         regs.sp--;                                                            \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_LT)
48470:     RELATIONAL_OP(<);
48470: END_CASE(JSOP_LT)
48470: 
48470: BEGIN_CASE(JSOP_LE)
48470:     RELATIONAL_OP(<=);
48470: END_CASE(JSOP_LE)
48470: 
48470: BEGIN_CASE(JSOP_GT)
48470:     RELATIONAL_OP(>);
48470: END_CASE(JSOP_GT)
48470: 
48470: BEGIN_CASE(JSOP_GE)
48470:     RELATIONAL_OP(>=);
48470: END_CASE(JSOP_GE)
48470: 
48470: #undef RELATIONAL_OP
48470: 
48470: #define SIGNED_SHIFT_OP(OP)                                                   \
48470:     JS_BEGIN_MACRO                                                            \
48470:         int32_t i, j;                                                         \
48470:         if (!ValueToECMAInt32(cx, regs.sp[-2], &i))                           \
48470:             goto error;                                                       \
48470:         if (!ValueToECMAInt32(cx, regs.sp[-1], &j))                           \
48470:             goto error;                                                       \
48470:         i = i OP (j & 31);                                                    \
48470:         regs.sp--;                                                            \
48470:         regs.sp[-1].setInt32(i);                                              \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_LSH)
48470:     SIGNED_SHIFT_OP(<<);
48470: END_CASE(JSOP_LSH)
48470: 
48470: BEGIN_CASE(JSOP_RSH)
48470:     SIGNED_SHIFT_OP(>>);
48470: END_CASE(JSOP_RSH)
48470: 
48470: #undef SIGNED_SHIFT_OP
48470: 
48470: BEGIN_CASE(JSOP_URSH)
48470: {
48470:     uint32_t u;
48470:     if (!ValueToECMAUint32(cx, regs.sp[-2], &u))
48470:         goto error;
48470:     int32_t j;
48470:     if (!ValueToECMAInt32(cx, regs.sp[-1], &j))
48470:         goto error;
48470: 
48470:     u >>= (j & 31);
48470: 
48470:     regs.sp--;
48470:     regs.sp[-1].setNumber(uint32(u));
48470: }
48470: END_CASE(JSOP_URSH)
48470: 
48470: BEGIN_CASE(JSOP_ADD)
48470: {
72054:     Value &rval = regs.sp[-1];
72054:     Value &lval = regs.sp[-2];
48470: 
48470:     if (lval.isInt32() && rval.isInt32()) {
48470:         int32_t l = lval.toInt32(), r = rval.toInt32();
48470:         int32_t sum = l + r;
72054:         if (JS_UNLIKELY(bool((l ^ sum) & (r ^ sum) & 0x80000000)))
72054:             regs.sp[-2].setDouble(double(l) + double(r));
72054:         else
72054:             regs.sp[-2].setInt32(sum);
48470:         regs.sp--;
48470:     } else
48470: #if JS_HAS_XML_SUPPORT
48470:     if (IsXML(lval) && IsXML(rval)) {
48470:         if (!js_ConcatenateXML(cx, &lval.toObject(), &rval.toObject(), &rval))
48470:             goto error;
72054:         regs.sp[-2] = rval;
48470:         regs.sp--;
48470:     } else
48470: #endif
48470:     {
72054:         if (!ToPrimitive(cx, &lval))
72054:             goto error;
72054:         if (!ToPrimitive(cx, &rval))
72054:             goto error;
48470:         bool lIsString, rIsString;
48470:         if ((lIsString = lval.isString()) | (rIsString = rval.isString())) {
48470:             JSString *lstr, *rstr;
48470:             if (lIsString) {
48470:                 lstr = lval.toString();
48470:             } else {
48470:                 lstr = js_ValueToString(cx, lval);
48470:                 if (!lstr)
48470:                     goto error;
48470:                 regs.sp[-2].setString(lstr);
48470:             }
48470:             if (rIsString) {
48470:                 rstr = rval.toString();
48470:             } else {
48470:                 rstr = js_ValueToString(cx, rval);
48470:                 if (!rstr)
48470:                     goto error;
48470:                 regs.sp[-1].setString(rstr);
48470:             }
48470:             JSString *str = js_ConcatStrings(cx, lstr, rstr);
48470:             if (!str)
48470:                 goto error;
72054:             regs.sp[-2].setString(str);
48470:             regs.sp--;
48470:         } else {
48470:             double l, r;
73894:             if (!ToNumber(cx, lval, &l) || !ToNumber(cx, rval, &r))
48470:                 goto error;
48470:             l += r;
72054:             regs.sp[-2].setNumber(l);
48470:             regs.sp--;
48470:         }
48470:     }
48470: }
48470: END_CASE(JSOP_ADD)
48470: 
48470: #define BINARY_OP(OP)                                                         \
48470:     JS_BEGIN_MACRO                                                            \
48470:         double d1, d2;                                                        \
73894:         if (!ToNumber(cx, regs.sp[-2], &d1) ||                                \
73894:             !ToNumber(cx, regs.sp[-1], &d2)) {                                \
48470:             goto error;                                                       \
48470:         }                                                                     \
48470:         double d = d1 OP d2;                                                  \
48470:         regs.sp--;                                                            \
48470:         regs.sp[-1].setNumber(d);                                             \
48470:     JS_END_MACRO
48470: 
48470: BEGIN_CASE(JSOP_SUB)
48470:     BINARY_OP(-);
48470: END_CASE(JSOP_SUB)
48470: 
48470: BEGIN_CASE(JSOP_MUL)
48470:     BINARY_OP(*);
48470: END_CASE(JSOP_MUL)
48470: 
48470: #undef BINARY_OP
48470: 
48470: BEGIN_CASE(JSOP_DIV)
48470: {
48470:     double d1, d2;
73894:     if (!ToNumber(cx, regs.sp[-2], &d1) || !ToNumber(cx, regs.sp[-1], &d2))
73894:         goto error;
48470:     regs.sp--;
48470:     if (d2 == 0) {
48470:         const Value *vp;
48470: #ifdef XP_WIN
48470:         /* XXX MSVC miscompiles such that (NaN == 0) */
48470:         if (JSDOUBLE_IS_NaN(d2))
48470:             vp = &rt->NaNValue;
48470:         else
48470: #endif
48470:         if (d1 == 0 || JSDOUBLE_IS_NaN(d1))
48470:             vp = &rt->NaNValue;
48470:         else if (JSDOUBLE_IS_NEG(d1) != JSDOUBLE_IS_NEG(d2))
48470:             vp = &rt->negativeInfinityValue;
48470:         else
48470:             vp = &rt->positiveInfinityValue;
48470:         regs.sp[-1] = *vp;
48470:     } else {
48470:         d1 /= d2;
48470:         regs.sp[-1].setNumber(d1);
48470:     }
48470: }
48470: END_CASE(JSOP_DIV)
48470: 
48470: BEGIN_CASE(JSOP_MOD)
48470: {
48470:     Value &lref = regs.sp[-2];
48470:     Value &rref = regs.sp[-1];
48470:     int32_t l, r;
48470:     if (lref.isInt32() && rref.isInt32() &&
48470:         (l = lref.toInt32()) >= 0 && (r = rref.toInt32()) > 0) {
48470:         int32_t mod = l % r;
48470:         regs.sp--;
48470:         regs.sp[-1].setInt32(mod);
48470:     } else {
48470:         double d1, d2;
73894:         if (!ToNumber(cx, regs.sp[-2], &d1) || !ToNumber(cx, regs.sp[-1], &d2))
73894:             goto error;
48470:         regs.sp--;
48470:         if (d2 == 0) {
48470:             regs.sp[-1].setDouble(js_NaN);
48470:         } else {
48470:             d1 = js_fmod(d1, d2);
48470:             regs.sp[-1].setDouble(d1);
48470:         }
48470:     }
48470: }
48470: END_CASE(JSOP_MOD)
48470: 
48470: BEGIN_CASE(JSOP_NOT)
48470: {
48470:     Value *_;
48470:     bool cond;
48470:     POP_BOOLEAN(cx, _, cond);
48470:     PUSH_BOOLEAN(!cond);
48470: }
48470: END_CASE(JSOP_NOT)
48470: 
48470: BEGIN_CASE(JSOP_BITNOT)
48470: {
48470:     int32_t i;
48470:     if (!ValueToECMAInt32(cx, regs.sp[-1], &i))
48470:         goto error;
48470:     i = ~i;
48470:     regs.sp[-1].setInt32(i);
48470: }
48470: END_CASE(JSOP_BITNOT)
48470: 
48470: BEGIN_CASE(JSOP_NEG)
48470: {
48470:     /*
48470:      * When the operand is int jsval, INT32_FITS_IN_JSVAL(i) implies
48470:      * INT32_FITS_IN_JSVAL(-i) unless i is 0 or INT32_MIN when the
48470:      * results, -0.0 or INT32_MAX + 1, are jsdouble values.
48470:      */
48470:     const Value &ref = regs.sp[-1];
48470:     int32_t i;
48470:     if (ref.isInt32() && (i = ref.toInt32()) != 0 && i != INT32_MIN) {
48470:         i = -i;
48470:         regs.sp[-1].setInt32(i);
48470:     } else {
48470:         double d;
73894:         if (!ToNumber(cx, regs.sp[-1], &d))
48470:             goto error;
48470:         d = -d;
48470:         regs.sp[-1].setDouble(d);
48470:     }
48470: }
48470: END_CASE(JSOP_NEG)
48470: 
48470: BEGIN_CASE(JSOP_POS)
73894:     if (!ToNumber(cx, &regs.sp[-1]))
48470:         goto error;
48470: END_CASE(JSOP_POS)
48470: 
48470: BEGIN_CASE(JSOP_DELNAME)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     jsid id = ATOM_TO_JSID(atom);
48470:     JSObject *obj, *obj2;
48470:     JSProperty *prop;
48470:     if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
48470:         goto error;
48470: 
54169:     /* Strict mode code should never contain JSOP_DELNAME opcodes. */
54169:     JS_ASSERT(!script->strictModeCode);
54169: 
48470:     /* ECMA says to return true if name is undefined or inherited. */
48470:     PUSH_BOOLEAN(true);
48470:     if (prop) {
54169:         if (!obj->deleteProperty(cx, id, &regs.sp[-1], false))
48470:             goto error;
48470:     }
48470: }
48470: END_CASE(JSOP_DELNAME)
48470: 
48470: BEGIN_CASE(JSOP_DELPROP)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
48470:     jsid id = ATOM_TO_JSID(atom);
48470: 
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -1, obj);
48470: 
48470:     Value rval;
54169:     if (!obj->deleteProperty(cx, id, &rval, script->strictModeCode))
48470:         goto error;
48470: 
48470:     regs.sp[-1] = rval;
48470: }
48470: END_CASE(JSOP_DELPROP)
48470: 
48470: BEGIN_CASE(JSOP_DELELEM)
48470: {
48470:     /* Fetch the left part and resolve it to a non-null object. */
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -2, obj);
48470: 
48470:     /* Fetch index and convert it to id suitable for use with obj. */
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -1, id);
48470: 
48470:     /* Get or set the element. */
54169:     if (!obj->deleteProperty(cx, id, &regs.sp[-2], script->strictModeCode))
48470:         goto error;
48470: 
48470:     regs.sp--;
48470: }
48470: END_CASE(JSOP_DELELEM)
48470: 
48470: BEGIN_CASE(JSOP_TYPEOFEXPR)
48470: BEGIN_CASE(JSOP_TYPEOF)
48470: {
48470:     const Value &ref = regs.sp[-1];
48470:     JSType type = JS_TypeOfValue(cx, Jsvalify(ref));
48470:     JSAtom *atom = rt->atomState.typeAtoms[type];
64345:     regs.sp[-1].setString(atom);
48470: }
48470: END_CASE(JSOP_TYPEOF)
48470: 
48470: BEGIN_CASE(JSOP_VOID)
48470:     regs.sp[-1].setUndefined();
48470: END_CASE(JSOP_VOID)
48470: 
48470: {
48470:     JSObject *obj;
48470:     JSAtom *atom;
48470:     jsid id;
48470:     jsint i;
48470: 
48470: BEGIN_CASE(JSOP_INCELEM)
48470: BEGIN_CASE(JSOP_DECELEM)
48470: BEGIN_CASE(JSOP_ELEMINC)
48470: BEGIN_CASE(JSOP_ELEMDEC)
48470: 
48470:     /*
48470:      * Delay fetching of id until we have the object to ensure the proper
48470:      * evaluation order. See bug 372331.
48470:      */
48470:     id = JSID_VOID;
48470:     i = -2;
48470:     goto fetch_incop_obj;
48470: 
48470: BEGIN_CASE(JSOP_INCPROP)
48470: BEGIN_CASE(JSOP_DECPROP)
48470: BEGIN_CASE(JSOP_PROPINC)
48470: BEGIN_CASE(JSOP_PROPDEC)
48470:     LOAD_ATOM(0, atom);
48470:     id = ATOM_TO_JSID(atom);
48470:     i = -1;
48470: 
48470:   fetch_incop_obj:
48470:     FETCH_OBJECT(cx, i, obj);
48470:     if (JSID_IS_VOID(id))
48470:         FETCH_ELEMENT_ID(obj, -1, id);
48470:     goto do_incop;
48470: 
48470: BEGIN_CASE(JSOP_INCNAME)
48470: BEGIN_CASE(JSOP_DECNAME)
48470: BEGIN_CASE(JSOP_NAMEINC)
48470: BEGIN_CASE(JSOP_NAMEDEC)
53092: BEGIN_CASE(JSOP_INCGNAME)
53092: BEGIN_CASE(JSOP_DECGNAME)
53092: BEGIN_CASE(JSOP_GNAMEINC)
53092: BEGIN_CASE(JSOP_GNAMEDEC)
48470: {
69223:     obj = &regs.fp()->scopeChain();
53092:     if (js_CodeSpec[op].format & JOF_GNAME)
53092:         obj = obj->getGlobal();
48470: 
48470:     JSObject *obj2;
48470:     PropertyCacheEntry *entry;
48470:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
48470:     if (!atom) {
48470:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
48470:         if (obj == obj2 && entry->vword.isSlot()) {
48470:             uint32 slot = entry->vword.toSlot();
74457:             const Value &rref = obj->nativeGetSlot(slot);
48470:             int32_t tmp;
48470:             if (JS_LIKELY(rref.isInt32() && CanIncDecWithoutOverflow(tmp = rref.toInt32()))) {
48470:                 int32_t inc = tmp + ((js_CodeSpec[op].format & JOF_INC) ? 1 : -1);
48470:                 if (!(js_CodeSpec[op].format & JOF_POST))
48470:                     tmp = inc;
74457:                 obj->nativeSetSlot(slot, Int32Value(inc));
48470:                 PUSH_INT32(tmp);
48470:                 len = JSOP_INCNAME_LENGTH;
48470:                 DO_NEXT_OP(len);
48470:             }
48470:         }
48470:         LOAD_ATOM(0, atom);
48470:     }
48470: 
48470:     id = ATOM_TO_JSID(atom);
48470:     JSProperty *prop;
48470:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
48470:         goto error;
48470:     if (!prop) {
48470:         atomNotDefined = atom;
48470:         goto atom_not_defined;
48470:     }
48470: }
48470: 
48470: do_incop:
48470: {
48470:     /*
48470:      * We need a root to store the value to leave on the stack until
48470:      * we have done with obj->setProperty.
48470:      */
48470:     PUSH_NULL();
48470:     if (!obj->getProperty(cx, id, &regs.sp[-1]))
48470:         goto error;
48470: 
48470:     const JSCodeSpec *cs = &js_CodeSpec[op];
48470:     JS_ASSERT(cs->ndefs == 1);
53092:     JS_ASSERT((cs->format & JOF_TMPSLOT_MASK) >= JOF_TMPSLOT2);
68898: 
68898:     uint32 format = cs->format;
68898:     uint32 setPropFlags = (JOF_MODE(format) == JOF_NAME)
68898:                           ? JSRESOLVE_ASSIGNING
68898:                           : JSRESOLVE_ASSIGNING | JSRESOLVE_QUALIFIED;
68898: 
48470:     Value &ref = regs.sp[-1];
48470:     int32_t tmp;
48470:     if (JS_LIKELY(ref.isInt32() && CanIncDecWithoutOverflow(tmp = ref.toInt32()))) {
68898:         int incr = (format & JOF_INC) ? 1 : -1;
68898:         if (format & JOF_POST)
48470:             ref.getInt32Ref() = tmp + incr;
48470:         else
48470:             ref.getInt32Ref() = tmp += incr;
68898: 
68898:         {
68898:             JSAutoResolveFlags rf(cx, setPropFlags);
68898:             if (!obj->setProperty(cx, id, &ref, script->strictModeCode))
68898:                 goto error;
68898:         }
48470: 
48470:         /*
48470:          * We must set regs.sp[-1] to tmp for both post and pre increments
48470:          * as the setter overwrites regs.sp[-1].
48470:          */
48470:         ref.setInt32(tmp);
48470:     } else {
48470:         /* We need an extra root for the result. */
48470:         PUSH_NULL();
48470:         if (!js_DoIncDec(cx, cs, &regs.sp[-2], &regs.sp[-1]))
48470:             goto error;
68898: 
68898:         {
68898:             JSAutoResolveFlags rf(cx, setPropFlags);
68898:             if (!obj->setProperty(cx, id, &regs.sp[-1], script->strictModeCode))
68898:                 goto error;
68898:         }
68898: 
48470:         regs.sp--;
48470:     }
48470: 
48470:     if (cs->nuses == 0) {
48470:         /* regs.sp[-1] already contains the result of name increment. */
48470:     } else {
48470:         regs.sp[-1 - cs->nuses] = regs.sp[-1];
48470:         regs.sp -= cs->nuses;
48470:     }
48470:     len = cs->length;
48470:     DO_NEXT_OP(len);
48470: }
48470: }
48470: 
48470: {
48470:     int incr, incr2;
60526:     uint32 slot;
48470:     Value *vp;
48470: 
48470:     /* Position cases so the most frequent i++ does not need a jump. */
48470: BEGIN_CASE(JSOP_DECARG)
48470:     incr = -1; incr2 = -1; goto do_arg_incop;
48470: BEGIN_CASE(JSOP_ARGDEC)
48470:     incr = -1; incr2 =  0; goto do_arg_incop;
48470: BEGIN_CASE(JSOP_INCARG)
48470:     incr =  1; incr2 =  1; goto do_arg_incop;
48470: BEGIN_CASE(JSOP_ARGINC)
48470:     incr =  1; incr2 =  0;
48470: 
48470:   do_arg_incop:
48470:     slot = GET_ARGNO(regs.pc);
69223:     JS_ASSERT(slot < regs.fp()->numFormalArgs());
53840:     vp = argv + slot;
48470:     goto do_int_fast_incop;
48470: 
48470: BEGIN_CASE(JSOP_DECLOCAL)
48470:     incr = -1; incr2 = -1; goto do_local_incop;
48470: BEGIN_CASE(JSOP_LOCALDEC)
48470:     incr = -1; incr2 =  0; goto do_local_incop;
48470: BEGIN_CASE(JSOP_INCLOCAL)
48470:     incr =  1; incr2 =  1; goto do_local_incop;
48470: BEGIN_CASE(JSOP_LOCALINC)
48470:     incr =  1; incr2 =  0;
48470: 
48470:   /*
48470:    * do_local_incop comes right before do_int_fast_incop as we want to
48470:    * avoid an extra jump for variable cases as local++ is more frequent
48470:    * than arg++.
48470:    */
48470:   do_local_incop:
48470:     slot = GET_SLOTNO(regs.pc);
69223:     JS_ASSERT(slot < regs.fp()->numSlots());
69223:     vp = regs.fp()->slots() + slot;
48470: 
48470:   do_int_fast_incop:
48470:     int32_t tmp;
48470:     if (JS_LIKELY(vp->isInt32() && CanIncDecWithoutOverflow(tmp = vp->toInt32()))) {
48470:         vp->getInt32Ref() = tmp + incr;
48470:         JS_ASSERT(JSOP_INCARG_LENGTH == js_CodeSpec[op].length);
48470:         SKIP_POP_AFTER_SET(JSOP_INCARG_LENGTH, 0);
48470:         PUSH_INT32(tmp + incr2);
48470:     } else {
48470:         PUSH_COPY(*vp);
48470:         if (!js_DoIncDec(cx, &js_CodeSpec[op], &regs.sp[-1], vp))
48470:             goto error;
48470:     }
48470:     len = JSOP_INCARG_LENGTH;
48470:     JS_ASSERT(len == js_CodeSpec[op].length);
48470:     DO_NEXT_OP(len);
48470: }
48470: 
48470: BEGIN_CASE(JSOP_THIS)
69223:     if (!ComputeThis(cx, regs.fp()))
69223:         goto error;
69223:     PUSH_COPY(regs.fp()->thisValue());
48470: END_CASE(JSOP_THIS)
48470: 
48470: BEGIN_CASE(JSOP_UNBRANDTHIS)
48470: {
69223:     if (!ComputeThis(cx, regs.fp()))
69223:         goto error;
69223:     Value &thisv = regs.fp()->thisValue();
55713:     if (thisv.isObject()) {
55713:         JSObject *obj = &thisv.toObject();
59227:         if (obj->isNative())
59227:             obj->unbrand(cx);
48470:     }
55713: }
48470: END_CASE(JSOP_UNBRANDTHIS)
48470: 
69659: {
69659:     JSObject *obj;
69659:     Value *vp;
69659:     jsint i;
69659: 
69659: BEGIN_CASE(JSOP_GETTHISPROP)
69659:     if (!ComputeThis(cx, regs.fp()))
69659:         goto error;
69659:     i = 0;
69659:     PUSH_COPY(regs.fp()->thisValue());
69659:     goto do_getprop_body;
69659: 
69659: BEGIN_CASE(JSOP_GETARGPROP)
69659: {
69659:     i = ARGNO_LEN;
69659:     uint32 slot = GET_ARGNO(regs.pc);
69659:     JS_ASSERT(slot < regs.fp()->numFormalArgs());
69659:     PUSH_COPY(argv[slot]);
69659:     goto do_getprop_body;
69659: }
69659: 
69659: BEGIN_CASE(JSOP_GETLOCALPROP)
69659: {
69659:     i = SLOTNO_LEN;
69659:     uint32 slot = GET_SLOTNO(regs.pc);
69659:     JS_ASSERT(slot < script->nslots);
69659:     PUSH_COPY(regs.fp()->slots()[slot]);
69659:     goto do_getprop_body;
69659: }
69659: 
48470: BEGIN_CASE(JSOP_GETPROP)
48470: BEGIN_CASE(JSOP_GETXPROP)
69659:     i = 0;
69659: 
69659:   do_getprop_body:
69659:     vp = &regs.sp[-1];
69659: 
69659:   do_getprop_with_lval:
69659:     VALUE_TO_OBJECT(cx, vp, obj);
69659: 
48470:     {
48470:         Value rval;
48470:         do {
48470:             /*
48470:              * We do not impose the method read barrier if in an imacro,
48470:              * assuming any property gets it does (e.g., for 'toString'
48470:              * from JSOP_NEW) will not be leaked to the calling script.
48470:              */
48470:             JSObject *aobj = js_GetProtoIfDenseArray(obj);
48470: 
48470:             PropertyCacheEntry *entry;
48470:             JSObject *obj2;
48470:             JSAtom *atom;
48470:             JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
48470:             if (!atom) {
69659:                 ASSERT_VALID_PROPERTY_CACHE_HIT(i, aobj, obj2, entry);
48470:                 if (entry->vword.isFunObj()) {
48470:                     rval.setObject(entry->vword.toFunObj());
48470:                 } else if (entry->vword.isSlot()) {
48470:                     uint32 slot = entry->vword.toSlot();
56567:                     rval = obj2->nativeGetSlot(slot);
48470:                 } else {
52503:                     JS_ASSERT(entry->vword.isShape());
52503:                     const Shape *shape = entry->vword.toShape();
52503:                     NATIVE_GET(cx, obj, obj2, shape,
69223:                                regs.fp()->hasImacropc() ? JSGET_NO_METHOD_BARRIER : JSGET_METHOD_BARRIER,
48470:                                &rval);
48470:                 }
48470:                 break;
48470:             }
48470: 
48470:             jsid id = ATOM_TO_JSID(atom);
48622:             if (JS_LIKELY(!aobj->getOps()->getProperty)
48470:                 ? !js_GetPropertyHelper(cx, obj, id,
69223:                                         (regs.fp()->hasImacropc() ||
69659:                                          regs.pc[JSOP_GETPROP_LENGTH + i] == JSOP_IFEQ)
48470:                                         ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
48470:                                         : JSGET_CACHE_RESULT | JSGET_METHOD_BARRIER,
48470:                                         &rval)
48470:                 : !obj->getProperty(cx, id, &rval)) {
48470:                 goto error;
48470:             }
48470:         } while (0);
48470: 
48470:         regs.sp[-1] = rval;
55638:         assertSameCompartment(cx, regs.sp[-1]);
69659:         JS_ASSERT(JSOP_GETPROP_LENGTH + i == js_CodeSpec[op].length);
69659:         len = JSOP_GETPROP_LENGTH + i;
69659:     }
69659: END_VARLEN_CASE
69659: 
69659: BEGIN_CASE(JSOP_LENGTH)
69659:     vp = &regs.sp[-1];
69659:     if (vp->isString()) {
69659:         vp->setInt32(vp->toString()->length());
69827:     } else {
69827:         if (vp->isObject()) {
69659:             JSObject *obj = &vp->toObject();
69659:             if (obj->isArray()) {
69659:                 jsuint length = obj->getArrayLength();
69659:                 regs.sp[-1].setNumber(length);
69834:                 len = JSOP_LENGTH_LENGTH;
69834:                 DO_NEXT_OP(len);
69827:             }
69827: 
69827:             if (obj->isArguments()) {
69827:                 ArgumentsObject *argsobj = obj->asArguments();
69827:                 if (!argsobj->hasOverriddenLength()) {
69827:                     uint32 length = argsobj->initialLength();
69659:                     JS_ASSERT(length < INT32_MAX);
69659:                     regs.sp[-1].setInt32(int32_t(length));
69834:                     len = JSOP_LENGTH_LENGTH;
69834:                     DO_NEXT_OP(len);
69827:                 }
69827:             }
72061: 
72061:             if (js_IsTypedArray(obj)) {
74875:                 JSObject *tarray = TypedArray::getTypedArray(obj);
74875:                 regs.sp[-1].setInt32(TypedArray::getLength(tarray));
72061:                 len = JSOP_LENGTH_LENGTH;
72061:                 DO_NEXT_OP(len);
72061:             }
69827:         }
69827: 
69659:         i = -2;
69659:         goto do_getprop_with_lval;
69659:     }
69659: END_CASE(JSOP_LENGTH)
69659: 
69659: }
48470: 
48470: BEGIN_CASE(JSOP_CALLPROP)
48470: {
48470:     Value lval = regs.sp[-1];
48470: 
48470:     Value objv;
48470:     if (lval.isObject()) {
48470:         objv = lval;
48470:     } else {
48470:         JSProtoKey protoKey;
48470:         if (lval.isString()) {
48470:             protoKey = JSProto_String;
48470:         } else if (lval.isNumber()) {
48470:             protoKey = JSProto_Number;
48470:         } else if (lval.isBoolean()) {
48470:             protoKey = JSProto_Boolean;
48470:         } else {
48470:             JS_ASSERT(lval.isNull() || lval.isUndefined());
48470:             js_ReportIsNullOrUndefined(cx, -1, lval, NULL);
48470:             goto error;
48470:         }
48470:         JSObject *pobj;
48470:         if (!js_GetClassPrototype(cx, NULL, protoKey, &pobj))
48470:             goto error;
48470:         objv.setObject(*pobj);
48470:     }
48470: 
48470:     JSObject *aobj = js_GetProtoIfDenseArray(&objv.toObject());
48470:     Value rval;
48470: 
48470:     PropertyCacheEntry *entry;
48470:     JSObject *obj2;
48470:     JSAtom *atom;
48470:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
48470:     if (!atom) {
48470:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, aobj, obj2, entry);
48470:         if (entry->vword.isFunObj()) {
48470:             rval.setObject(entry->vword.toFunObj());
48470:         } else if (entry->vword.isSlot()) {
48470:             uint32 slot = entry->vword.toSlot();
56567:             rval = obj2->nativeGetSlot(slot);
48470:         } else {
52503:             JS_ASSERT(entry->vword.isShape());
52503:             const Shape *shape = entry->vword.toShape();
52503:             NATIVE_GET(cx, &objv.toObject(), obj2, shape, JSGET_NO_METHOD_BARRIER, &rval);
48470:         }
48470:         regs.sp[-1] = rval;
55638:         assertSameCompartment(cx, regs.sp[-1]);
48470:         PUSH_COPY(lval);
55713:     } else {
48470:         /*
48470:          * Cache miss: use the immediate atom that was loaded for us under
48470:          * PropertyCache::test.
48470:          */
48470:         jsid id;
48470:         id = ATOM_TO_JSID(atom);
48470: 
48470:         PUSH_NULL();
48470:         if (lval.isObject()) {
48470:             if (!js_GetMethod(cx, &objv.toObject(), id,
48622:                               JS_LIKELY(!aobj->getOps()->getProperty)
48470:                               ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
48470:                               : JSGET_NO_METHOD_BARRIER,
48470:                               &rval)) {
48470:                 goto error;
48470:             }
48470:             regs.sp[-1] = objv;
48470:             regs.sp[-2] = rval;
55638:             assertSameCompartment(cx, regs.sp[-1], regs.sp[-2]);
48470:         } else {
48622:             JS_ASSERT(!objv.toObject().getOps()->getProperty);
48470:             if (!js_GetPropertyHelper(cx, &objv.toObject(), id,
48470:                                       JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER,
48470:                                       &rval)) {
48470:                 goto error;
48470:             }
48470:             regs.sp[-1] = lval;
48470:             regs.sp[-2] = rval;
55638:             assertSameCompartment(cx, regs.sp[-1], regs.sp[-2]);
48470:         }
48470:     }
48470: #if JS_HAS_NO_SUCH_METHOD
69231:     if (JS_UNLIKELY(rval.isPrimitive()) && regs.sp[-1].isObject()) {
48470:         LOAD_ATOM(0, atom);
64345:         regs.sp[-2].setString(atom);
48470:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
48470:             goto error;
48470:     }
48470: #endif
48470: }
48470: END_CASE(JSOP_CALLPROP)
48470: 
48470: BEGIN_CASE(JSOP_UNBRAND)
69223:     JS_ASSERT(regs.sp - regs.fp()->slots() >= 1);
59227:     regs.sp[-1].toObject().unbrand(cx);
48470: END_CASE(JSOP_UNBRAND)
48470: 
53092: BEGIN_CASE(JSOP_SETGNAME)
48470: BEGIN_CASE(JSOP_SETNAME)
48470: BEGIN_CASE(JSOP_SETPROP)
48470: BEGIN_CASE(JSOP_SETMETHOD)
48470: {
48600:     Value rval = regs.sp[-1];
48600:     JS_ASSERT_IF(op == JSOP_SETMETHOD, IsFunctionObject(rval));
48470:     Value &lref = regs.sp[-2];
48470:     JS_ASSERT_IF(op == JSOP_SETNAME, lref.isObject());
48470:     JSObject *obj;
48470:     VALUE_TO_OBJECT(cx, &lref, obj);
48470: 
69223:     JS_ASSERT_IF(op == JSOP_SETGNAME, obj == regs.fp()->scopeChain().getGlobal());
53092: 
48470:     do {
48470:         PropertyCache *cache = &JS_PROPERTY_CACHE(cx);
48470: 
48470:         /*
48470:          * Probe the property cache, specializing for two important
48470:          * set-property cases. First:
48470:          *
48470:          *   function f(a, b, c) {
48470:          *     var o = {p:a, q:b, r:c};
48470:          *     return o;
48470:          *   }
48470:          *
48470:          * or similar real-world cases, which evolve a newborn native
48470:          * object predicatably through some bounded number of property
48470:          * additions. And second:
48470:          *
48470:          *   o.p = x;
48470:          *
48470:          * in a frequently executed method or loop body, where p will
48470:          * (possibly after the first iteration) always exist in native
48470:          * object o.
48470:          */
48470:         PropertyCacheEntry *entry;
48470:         JSObject *obj2;
48470:         JSAtom *atom;
48470:         if (cache->testForSet(cx, regs.pc, obj, &entry, &obj2, &atom)) {
48470:             /*
56605:              * Property cache hit, only partially confirmed by testForSet. We
56605:              * know that the entry applies to regs.pc and that obj's shape
56605:              * matches.
48470:              *
56605:              * The entry predicts either a new property to be added directly to
56605:              * obj by this set, or on an existing "own" property, or on a
56605:              * prototype property that has a setter.
48470:              */
52503:             const Shape *shape = entry->vword.toShape();
52503:             JS_ASSERT_IF(shape->isDataDescriptor(), shape->writable());
52503:             JS_ASSERT_IF(shape->hasSlot(), entry->vcapTag() == 0);
48470: 
48470:             /*
52503:              * Fastest path: check whether obj already has the cached shape and
52503:              * call NATIVE_SET and break to get out of the do-while(0). But we
52503:              * can call NATIVE_SET only for a direct or proto-setter hit.
48470:              */
52503:             if (!entry->adding()) {
48470:                 if (entry->vcapTag() == 0 ||
52506:                     ((obj2 = obj->getProto()) && obj2->shape() == entry->vshape()))
52503:                 {
52503: #ifdef DEBUG
52503:                     if (entry->directHit()) {
52503:                         JS_ASSERT(obj->nativeContains(*shape));
52503:                     } else {
52503:                         JS_ASSERT(obj2->nativeContains(*shape));
52503:                         JS_ASSERT(entry->vcapTag() == 1);
52503:                         JS_ASSERT(entry->kshape != entry->vshape());
52503:                         JS_ASSERT(!shape->hasSlot());
52503:                     }
52503: #endif
52503: 
48470:                     PCMETER(cache->pchits++);
48470:                     PCMETER(cache->setpchits++);
62395:                     NATIVE_SET(cx, obj, shape, entry, script->strictModeCode, &rval);
48470:                     break;
48470:                 }
48470:             } else {
56008:                 JS_ASSERT(obj->isExtensible());
56008: 
52503:                 if (obj->nativeEmpty()) {
56567:                     if (!obj->ensureClassReservedSlotsForEmptyObject(cx))
52503:                         goto error;
48470:                 }
48470: 
48470:                 uint32 slot;
52503:                 if (shape->previous() == obj->lastProperty() &&
48470:                     entry->vshape() == rt->protoHazardShape &&
52503:                     shape->hasDefaultSetter()) {
52503:                     slot = shape->slot;
53652:                     JS_ASSERT(slot == obj->slotSpan());
52503: 
48470:                     /*
52503:                      * Fast path: adding a plain old property that was once at
52503:                      * the frontier of the property tree, whose slot is next to
52503:                      * claim among the already-allocated slots in obj, where
52503:                      * shape->table has not been created yet.
48470:                      */
48470:                     PCMETER(cache->pchits++);
48470:                     PCMETER(cache->addpchits++);
48470: 
48470:                     if (slot < obj->numSlots()) {
52503:                         JS_ASSERT(obj->getSlot(slot).isUndefined());
48470:                     } else {
52503:                         if (!obj->allocSlot(cx, &slot))
52503:                             goto error;
52503:                         JS_ASSERT(slot == shape->slot);
52503:                     }
52503: 
52503:                     /* Simply extend obj's property tree path with shape! */
52503:                     obj->extend(cx, shape);
48470: 
48470:                     /*
52503:                      * No method change check here because here we are adding a
52503:                      * new property, not updating an existing slot's value that
52503:                      * might contain a method of a branded shape.
48470:                      */
60780:                     TRACE_1(AddProperty, obj);
56567:                     obj->nativeSetSlot(slot, rval);
48470: 
48470:                     /*
48470:                      * Purge the property cache of the id we may have just
52503:                      * shadowed in obj's scope and proto chains.
48470:                      */
69637:                     js_PurgeScopeChain(cx, obj, shape->propid);
48470:                     break;
48470:                 }
52503:             }
48470:             PCMETER(cache->setpcmisses++);
56605: 
48470:             LOAD_ATOM(0, atom);
56605:         } else {
56605:             JS_ASSERT(atom);
56605:         }
56605: 
48470:         jsid id = ATOM_TO_JSID(atom);
48622:         if (entry && JS_LIKELY(!obj->getOps()->setProperty)) {
48470:             uintN defineHow;
48470:             if (op == JSOP_SETMETHOD)
69855:                 defineHow = DNP_CACHE_RESULT | DNP_SET_METHOD;
48470:             else if (op == JSOP_SETNAME)
69855:                 defineHow = DNP_CACHE_RESULT | DNP_UNQUALIFIED;
48470:             else
69855:                 defineHow = DNP_CACHE_RESULT;
56760:             if (!js_SetPropertyHelper(cx, obj, id, defineHow, &rval, script->strictModeCode))
48470:                 goto error;
48470:         } else {
54169:             if (!obj->setProperty(cx, id, &rval, script->strictModeCode))
48470:                 goto error;
48470:             ABORT_RECORDING(cx, "Non-native set");
48470:         }
48470:     } while (0);
48470: }
48470: END_SET_CASE_STORE_RVAL(JSOP_SETPROP, 2);
48470: 
48470: BEGIN_CASE(JSOP_GETELEM)
48470: {
48470:     Value &lref = regs.sp[-2];
48470:     Value &rref = regs.sp[-1];
48470:     if (lref.isString() && rref.isInt32()) {
48470:         JSString *str = lref.toString();
48470:         int32_t i = rref.toInt32();
48470:         if (size_t(i) < str->length()) {
64345:             str = JSAtom::getUnitStringForElement(cx, str, size_t(i));
48470:             if (!str)
48470:                 goto error;
48470:             regs.sp--;
48470:             regs.sp[-1].setString(str);
48470:             len = JSOP_GETELEM_LENGTH;
48470:             DO_NEXT_OP(len);
48470:         }
48470:     }
48470: 
48470:     JSObject *obj;
48470:     VALUE_TO_OBJECT(cx, &lref, obj);
48470: 
48470:     const Value *copyFrom;
48470:     Value rval;
48470:     jsid id;
48470:     if (rref.isInt32()) {
48470:         int32_t i = rref.toInt32();
48470:         if (obj->isDenseArray()) {
48470:             jsuint idx = jsuint(i);
48470: 
48537:             if (idx < obj->getDenseArrayCapacity()) {
74457:                 copyFrom = &obj->getDenseArrayElement(idx);
48470:                 if (!copyFrom->isMagic())
48470:                     goto end_getelem;
48470:             }
49124:         } else if (obj->isArguments()) {
48470:             uint32 arg = uint32(i);
69827:             ArgumentsObject *argsobj = obj->asArguments();
69827: 
69827:             if (arg < argsobj->initialLength()) {
74457:                 copyFrom = &argsobj->element(arg);
55525:                 if (!copyFrom->isMagic(JS_ARGS_HOLE)) {
69827:                     if (StackFrame *afp = reinterpret_cast<StackFrame *>(argsobj->getPrivate()))
53840:                         copyFrom = &afp->canonicalActualArg(arg);
48470:                     goto end_getelem;
48470:                 }
48470:             }
48470:         }
48470:         if (JS_LIKELY(INT_FITS_IN_JSID(i)))
48470:             id = INT_TO_JSID(i);
48470:         else
48470:             goto intern_big_int;
48470:     } else {
58066:         int32_t i;
58066:         if (ValueFitsInInt32(rref, &i) && INT_FITS_IN_JSID(i)) {
58066:             id = INT_TO_JSID(i);
58066:         } else {
48470:           intern_big_int:
48470:             if (!js_InternNonIntElementId(cx, obj, rref, &id))
48470:                 goto error;
48470:         }
58066:     }
48470: 
48470:     if (!obj->getProperty(cx, id, &rval))
48470:         goto error;
48470:     copyFrom = &rval;
48470: 
48470:   end_getelem:
48470:     regs.sp--;
48470:     regs.sp[-1] = *copyFrom;
55638:     assertSameCompartment(cx, regs.sp[-1]);
48470: }
48470: END_CASE(JSOP_GETELEM)
48470: 
48470: BEGIN_CASE(JSOP_CALLELEM)
48470: {
55713:     /* Find the object on which to look for |this|'s properties. */
55713:     Value thisv = regs.sp[-2];
55713:     JSObject *thisObj = ValuePropertyBearer(cx, thisv, -2);
55713:     if (!thisObj)
55713:         goto error;
48470: 
48470:     /* Fetch index and convert it to id suitable for use with obj. */
48470:     jsid id;
55713:     FETCH_ELEMENT_ID(thisObj, -1, id);
55713: 
55713:     /* Get the method. */
55713:     if (!js_GetMethod(cx, thisObj, id, JSGET_NO_METHOD_BARRIER, &regs.sp[-2]))
48470:         goto error;
48470: 
48470: #if JS_HAS_NO_SUCH_METHOD
69231:     if (JS_UNLIKELY(regs.sp[-2].isPrimitive()) && thisv.isObject()) {
55713:         /* For js_OnUnknownMethod, sp[-2] is the index, and sp[-1] is the object missing it. */
48470:         regs.sp[-2] = regs.sp[-1];
55713:         regs.sp[-1].setObject(*thisObj);
48470:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
48470:             goto error;
48470:     } else
48470: #endif
48470:     {
55713:         regs.sp[-1] = thisv;
48470:     }
48470: }
48470: END_CASE(JSOP_CALLELEM)
48470: 
48470: BEGIN_CASE(JSOP_SETELEM)
48470: {
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -3, obj);
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -2, id);
48600:     Value rval;
48470:     do {
48470:         if (obj->isDenseArray() && JSID_IS_INT(id)) {
48470:             jsuint length = obj->getDenseArrayCapacity();
48470:             jsint i = JSID_TO_INT(id);
48470:             if ((jsuint)i < length) {
48470:                 if (obj->getDenseArrayElement(i).isMagic(JS_ARRAY_HOLE)) {
48470:                     if (js_PrototypeHasIndexedProperties(cx, obj))
48470:                         break;
48470:                     if ((jsuint)i >= obj->getArrayLength())
48537:                         obj->setArrayLength(i + 1);
48470:                 }
48470:                 obj->setDenseArrayElement(i, regs.sp[-1]);
48470:                 goto end_setelem;
48470:             }
48470:         }
48470:     } while (0);
48600:     rval = regs.sp[-1];
54169:     if (!obj->setProperty(cx, id, &rval, script->strictModeCode))
48470:         goto error;
48470:   end_setelem:;
48470: }
48470: END_SET_CASE_STORE_RVAL(JSOP_SETELEM, 3)
48470: 
48470: BEGIN_CASE(JSOP_ENUMELEM)
48470: {
48470:     /* Funky: the value to set is under the [obj, id] pair. */
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -2, obj);
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -1, id);
48600:     Value rval = regs.sp[-3];
54169:     if (!obj->setProperty(cx, id, &rval, script->strictModeCode))
48470:         goto error;
48470:     regs.sp -= 3;
48470: }
48470: END_CASE(JSOP_ENUMELEM)
48470: 
71851: BEGIN_CASE(JSOP_EVAL)
71851: {
71851:     CallArgs args = CallArgsFromSp(GET_ARGC(regs.pc), regs.sp);
71851:     if (IsBuiltinEvalForScope(&regs.fp()->scopeChain(), args.calleev())) {
71851:         if (!DirectEval(cx, args))
71851:             goto error;
71851:     } else {
71851:         if (!Invoke(cx, args))
71851:             goto error;
71851:     }
71851:     CHECK_INTERRUPT_HANDLER();
71851:     regs.sp = args.spAfterCall();
71851: }
71851: END_CASE(JSOP_EVAL)
71851: 
71851: BEGIN_CASE(JSOP_NEW)
71851: BEGIN_CASE(JSOP_CALL)
71851: BEGIN_CASE(JSOP_FUNCALL)
71851: BEGIN_CASE(JSOP_FUNAPPLY)
71851: {
71851:     CallArgs args = CallArgsFromSp(GET_ARGC(regs.pc), regs.sp);
71851:     JS_ASSERT(args.base() >= regs.fp()->base());
71851: 
71851:     MaybeConstruct construct = *regs.pc == JSOP_NEW ? CONSTRUCT : NO_CONSTRUCT;
71851: 
53840:     JSObject *callee;
71851:     JSFunction *fun;
73069: 
73069:     /* Don't bother trying to fast-path calls to scripted non-constructors. */
71851:     if (!IsFunctionObject(args.calleev(), &callee, &fun) || !fun->isInterpretedConstructor()) {
71851:         if (construct) {
71695:             if (!InvokeConstructor(cx, args))
71695:                 goto error;
71851:         } else {
71851:             if (!Invoke(cx, args))
71851:                 goto error;
71851:         }
71695:         regs.sp = args.spAfterCall();
48470:         CHECK_INTERRUPT_HANDLER();
48470:         TRACE_0(NativeCallComplete);
71851:         len = JSOP_CALL_LENGTH;
71851:         DO_NEXT_OP(len);
71851:     }
71851: 
72552:     JSScript *newScript = fun->script();
73495:     if (!cx->stack.pushInlineFrame(cx, regs, args, *callee, fun, newScript, construct))
71851:         goto error;
71851: 
71851:     /* Refresh local js::Interpret state. */
72552:     script = newScript;
71699:     pcCounts = script->pcCounters.get(JSRUNMODE_INTERP);
71851:     argv = regs.fp()->formalArgsEnd() - fun->nargs;
48470:     atoms = script->atomMap.vector;
48470: 
71851:     /* Only create call object after frame is rooted. */
71851:     if (fun->isHeavyweight() && !CreateFunCallObject(cx, regs.fp()))
48470:         goto error;
48470: 
63095:     RESET_USE_METHODJIT();
53524:     TRACE_0(EnterFrame);
48482: 
56201: #ifdef JS_METHODJIT
71851:     {
56201:         /* Try to ensure methods are method JIT'd.  */
62574:         mjit::CompileRequest request = (interpMode == JSINTERP_NORMAL)
62574:                                        ? mjit::CompileRequest_Interpreter
62574:                                        : mjit::CompileRequest_JIT;
69223:         mjit::CompileStatus status = mjit::CanMethodJIT(cx, script, regs.fp(), request);
56201:         if (status == mjit::Compile_Error)
56201:             goto error;
56551:         if (!TRACE_RECORDER(cx) && !TRACE_PROFILER(cx) && status == mjit::Compile_Okay) {
56201:             interpReturnOK = mjit::JaegerShot(cx);
56201:             CHECK_INTERRUPT_HANDLER();
56201:             goto jit_return;
56201:         }
71851:     }
56201: #endif
56201: 
69223:     if (!ScriptPrologue(cx, regs.fp()))
56201:         goto error;
56201: 
56201:     CHECK_INTERRUPT_HANDLER();
56201: 
48470:     /* Load first op and dispatch it (safe since JSOP_STOP). */
48470:     op = (JSOp) *regs.pc;
48470:     DO_OP();
48470: }
48470: 
48470: BEGIN_CASE(JSOP_SETCALL)
48470: {
48470:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_LEFTSIDE_OF_ASS);
48470:     goto error;
48470: }
48470: END_CASE(JSOP_SETCALL)
48470: 
63096: #define PUSH_IMPLICIT_THIS(cx, obj, funval)                                   \
53092:     JS_BEGIN_MACRO                                                            \
63085:         Value v;                                                              \
63096:         if (!ComputeImplicitThis(cx, obj, funval, &v))                        \
53092:             goto error;                                                       \
63085:         PUSH_COPY(v);                                                         \
63085:     JS_END_MACRO                                                              \
53100: 
53092: BEGIN_CASE(JSOP_GETGNAME)
53092: BEGIN_CASE(JSOP_CALLGNAME)
48470: BEGIN_CASE(JSOP_NAME)
48470: BEGIN_CASE(JSOP_CALLNAME)
48470: {
69223:     JSObject *obj = &regs.fp()->scopeChain();
48470: 
52503:     const Shape *shape;
48470:     Value rval;
48470: 
48470:     PropertyCacheEntry *entry;
48470:     JSObject *obj2;
48470:     JSAtom *atom;
48470:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
48470:     if (!atom) {
48470:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
48470:         if (entry->vword.isFunObj()) {
48470:             PUSH_OBJECT(entry->vword.toFunObj());
53092:         } else if (entry->vword.isSlot()) {
48470:             uintN slot = entry->vword.toSlot();
56567:             PUSH_COPY(obj2->nativeGetSlot(slot));
53092:         } else {
52503:             JS_ASSERT(entry->vword.isShape());
52503:             shape = entry->vword.toShape();
53531:             NATIVE_GET(cx, obj, obj2, shape, JSGET_METHOD_BARRIER, &rval);
53092:             PUSH_COPY(rval);
53092:         }
53092: 
63085:         JS_ASSERT(obj->isGlobal() || IsCacheableNonGlobalScope(obj));
62968:         if (op == JSOP_CALLNAME || op == JSOP_CALLGNAME)
63096:             PUSH_IMPLICIT_THIS(cx, obj, regs.sp[-1]);
53092:         len = JSOP_NAME_LENGTH;
53092:         DO_NEXT_OP(len);
48470:     }
48470: 
48470:     jsid id;
48470:     id = ATOM_TO_JSID(atom);
48470:     JSProperty *prop;
48470:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
48470:         goto error;
48470:     if (!prop) {
48470:         /* Kludge to allow (typeof foo == "undefined") tests. */
48470:         JSOp op2 = js_GetOpcode(cx, script, regs.pc + JSOP_NAME_LENGTH);
48470:         if (op2 == JSOP_TYPEOF) {
48470:             PUSH_UNDEFINED();
48470:             len = JSOP_NAME_LENGTH;
48470:             DO_NEXT_OP(len);
48470:         }
48470:         atomNotDefined = atom;
48470:         goto atom_not_defined;
48470:     }
48470: 
48470:     /* Take the slow path if prop was not found in a native object. */
48470:     if (!obj->isNative() || !obj2->isNative()) {
48470:         if (!obj->getProperty(cx, id, &rval))
48470:             goto error;
48470:     } else {
52503:         shape = (Shape *)prop;
53343:         JSObject *normalized = obj;
53531:         if (normalized->getClass() == &js_WithClass && !shape->hasDefaultGetter())
53343:             normalized = js_UnwrapWithObject(cx, normalized);
53531:         NATIVE_GET(cx, normalized, obj2, shape, JSGET_METHOD_BARRIER, &rval);
48470:     }
48470: 
48470:     PUSH_COPY(rval);
48470: 
48470:     /* obj must be on the scope chain, thus not a function. */
53092:     if (op == JSOP_CALLNAME || op == JSOP_CALLGNAME)
63096:         PUSH_IMPLICIT_THIS(cx, obj, rval);
48470: }
48470: END_CASE(JSOP_NAME)
48470: 
48470: BEGIN_CASE(JSOP_UINT16)
48470:     PUSH_INT32((int32_t) GET_UINT16(regs.pc));
48470: END_CASE(JSOP_UINT16)
48470: 
48470: BEGIN_CASE(JSOP_UINT24)
48470:     PUSH_INT32((int32_t) GET_UINT24(regs.pc));
48470: END_CASE(JSOP_UINT24)
48470: 
48470: BEGIN_CASE(JSOP_INT8)
48470:     PUSH_INT32(GET_INT8(regs.pc));
48470: END_CASE(JSOP_INT8)
48470: 
48470: BEGIN_CASE(JSOP_INT32)
48470:     PUSH_INT32(GET_INT32(regs.pc));
48470: END_CASE(JSOP_INT32)
48470: 
48470: BEGIN_CASE(JSOP_INDEXBASE)
48470:     /*
48470:      * Here atoms can exceed script->atomMap.length as we use atoms as a
48470:      * segment register for object literals as well.
48470:      */
48470:     atoms += GET_INDEXBASE(regs.pc);
48470: END_CASE(JSOP_INDEXBASE)
48470: 
48470: BEGIN_CASE(JSOP_INDEXBASE1)
48470: BEGIN_CASE(JSOP_INDEXBASE2)
48470: BEGIN_CASE(JSOP_INDEXBASE3)
48470:     atoms += (op - JSOP_INDEXBASE1 + 1) << 16;
48470: END_CASE(JSOP_INDEXBASE3)
48470: 
48470: BEGIN_CASE(JSOP_RESETBASE0)
48470: BEGIN_CASE(JSOP_RESETBASE)
48470:     atoms = script->atomMap.vector;
48470: END_CASE(JSOP_RESETBASE)
48470: 
48470: BEGIN_CASE(JSOP_DOUBLE)
48470: {
69223:     JS_ASSERT(!regs.fp()->hasImacropc());
48470:     double dbl;
48470:     LOAD_DOUBLE(0, dbl);
48470:     PUSH_DOUBLE(dbl);
48470: }
48470: END_CASE(JSOP_DOUBLE)
48470: 
48470: BEGIN_CASE(JSOP_STRING)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
64345:     PUSH_STRING(atom);
48470: }
48470: END_CASE(JSOP_STRING)
48470: 
48470: BEGIN_CASE(JSOP_OBJECT)
48470: {
48470:     JSObject *obj;
48470:     LOAD_OBJECT(0, obj);
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_OBJECT)
48470: 
48470: BEGIN_CASE(JSOP_REGEXP)
48470: {
48470:     /*
48470:      * Push a regexp object cloned from the regexp literal object mapped by the
48470:      * bytecode at pc. ES5 finally fixed this bad old ES3 design flaw which was
48470:      * flouted by many browser-based implementations.
48470:      *
56729:      * We avoid the GetScopeChain call here and pass fp->scopeChain as
48470:      * js_GetClassPrototype uses the latter only to locate the global.
48470:      */
48470:     jsatomid index = GET_FULL_INDEX(0);
48470:     JSObject *proto;
69223:     if (!js_GetClassPrototype(cx, &regs.fp()->scopeChain(), JSProto_RegExp, &proto))
48470:         goto error;
48470:     JS_ASSERT(proto);
48470:     JSObject *obj = js_CloneRegExpObject(cx, script->getRegExp(index), proto);
48470:     if (!obj)
48470:         goto error;
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_REGEXP)
48470: 
48470: BEGIN_CASE(JSOP_ZERO)
48470:     PUSH_INT32(0);
48470: END_CASE(JSOP_ZERO)
48470: 
48470: BEGIN_CASE(JSOP_ONE)
48470:     PUSH_INT32(1);
48470: END_CASE(JSOP_ONE)
48470: 
48470: BEGIN_CASE(JSOP_NULL)
48470:     PUSH_NULL();
48470: END_CASE(JSOP_NULL)
48470: 
48470: BEGIN_CASE(JSOP_FALSE)
48470:     PUSH_BOOLEAN(false);
48470: END_CASE(JSOP_FALSE)
48470: 
48470: BEGIN_CASE(JSOP_TRUE)
48470:     PUSH_BOOLEAN(true);
48470: END_CASE(JSOP_TRUE)
48470: 
48470: {
48470: BEGIN_CASE(JSOP_TABLESWITCH)
48470: {
48470:     jsbytecode *pc2 = regs.pc;
48470:     len = GET_JUMP_OFFSET(pc2);
48470: 
48470:     /*
48470:      * ECMAv2+ forbids conversion of discriminant, so we will skip to the
48470:      * default case if the discriminant isn't already an int jsval.  (This
48470:      * opcode is emitted only for dense jsint-domain switches.)
48470:      */
48470:     const Value &rref = *--regs.sp;
48470:     int32_t i;
48470:     if (rref.isInt32()) {
48470:         i = rref.toInt32();
48470:     } else {
48518:         double d;
48518:         /* Don't use JSDOUBLE_IS_INT32; treat -0 (double) as 0. */
48518:         if (!rref.isDouble() || (d = rref.toDouble()) != (i = int32_t(rref.toDouble())))
48470:             DO_NEXT_OP(len);
48470:     }
48470: 
48470:     pc2 += JUMP_OFFSET_LEN;
48470:     jsint low = GET_JUMP_OFFSET(pc2);
48470:     pc2 += JUMP_OFFSET_LEN;
48470:     jsint high = GET_JUMP_OFFSET(pc2);
48470: 
48470:     i -= low;
48470:     if ((jsuint)i < (jsuint)(high - low + 1)) {
48470:         pc2 += JUMP_OFFSET_LEN + JUMP_OFFSET_LEN * i;
48470:         jsint off = (jsint) GET_JUMP_OFFSET(pc2);
48470:         if (off)
48470:             len = off;
48470:     }
48470: }
48470: END_VARLEN_CASE
48470: }
48470: 
48470: {
48470: BEGIN_CASE(JSOP_TABLESWITCHX)
48470: {
48470:     jsbytecode *pc2 = regs.pc;
48470:     len = GET_JUMPX_OFFSET(pc2);
48470: 
48470:     /*
48470:      * ECMAv2+ forbids conversion of discriminant, so we will skip to the
48470:      * default case if the discriminant isn't already an int jsval.  (This
48470:      * opcode is emitted only for dense jsint-domain switches.)
48470:      */
48470:     const Value &rref = *--regs.sp;
48470:     int32_t i;
48470:     if (rref.isInt32()) {
48470:         i = rref.toInt32();
48470:     } else if (rref.isDouble() && rref.toDouble() == 0) {
48470:         /* Treat -0 (double) as 0. */
48470:         i = 0;
48470:     } else {
48470:         DO_NEXT_OP(len);
48470:     }
48470: 
48470:     pc2 += JUMPX_OFFSET_LEN;
48470:     jsint low = GET_JUMP_OFFSET(pc2);
48470:     pc2 += JUMP_OFFSET_LEN;
48470:     jsint high = GET_JUMP_OFFSET(pc2);
48470: 
48470:     i -= low;
48470:     if ((jsuint)i < (jsuint)(high - low + 1)) {
48470:         pc2 += JUMP_OFFSET_LEN + JUMPX_OFFSET_LEN * i;
48470:         jsint off = (jsint) GET_JUMPX_OFFSET(pc2);
48470:         if (off)
48470:             len = off;
48470:     }
48470: }
48470: END_VARLEN_CASE
48470: }
48470: 
48470: {
48470: BEGIN_CASE(JSOP_LOOKUPSWITCHX)
48470: {
48470:     jsint off;
48470:     off = JUMPX_OFFSET_LEN;
48470:     goto do_lookup_switch;
48470: 
48470: BEGIN_CASE(JSOP_LOOKUPSWITCH)
48470:     off = JUMP_OFFSET_LEN;
48470: 
48470:   do_lookup_switch:
48470:     /*
48470:      * JSOP_LOOKUPSWITCH and JSOP_LOOKUPSWITCHX are never used if any atom
48470:      * index in it would exceed 64K limit.
48470:      */
69223:     JS_ASSERT(!regs.fp()->hasImacropc());
48470:     JS_ASSERT(atoms == script->atomMap.vector);
48470:     jsbytecode *pc2 = regs.pc;
48470: 
48470:     Value lval = regs.sp[-1];
48470:     regs.sp--;
48470: 
48470:     if (!lval.isPrimitive())
48470:         goto end_lookup_switch;
48470: 
48470:     pc2 += off;
48470:     jsint npairs;
48470:     npairs = (jsint) GET_UINT16(pc2);
48470:     pc2 += UINT16_LEN;
48470:     JS_ASSERT(npairs);  /* empty switch uses JSOP_TABLESWITCH */
48470: 
48470:     bool match;
48470: #define SEARCH_PAIRS(MATCH_CODE)                                              \
48470:     for (;;) {                                                                \
48470:         Value rval = script->getConst(GET_INDEX(pc2));                        \
48470:         MATCH_CODE                                                            \
48470:         pc2 += INDEX_LEN;                                                     \
48470:         if (match)                                                            \
48470:             break;                                                            \
48470:         pc2 += off;                                                           \
48470:         if (--npairs == 0) {                                                  \
48470:             pc2 = regs.pc;                                                    \
48470:             break;                                                            \
48470:         }                                                                     \
48470:     }
48470: 
48470:     if (lval.isString()) {
59890:         JSLinearString *str = lval.toString()->ensureLinear(cx);
59890:         if (!str)
59890:             goto error;
59890:         JSLinearString *str2;
48470:         SEARCH_PAIRS(
48470:             match = (rval.isString() &&
64345:                      ((str2 = &rval.toString()->asLinear()) == str ||
59890:                       EqualStrings(str2, str)));
48470:         )
48470:     } else if (lval.isNumber()) {
48470:         double ldbl = lval.toNumber();
48470:         SEARCH_PAIRS(
48470:             match = rval.isNumber() && ldbl == rval.toNumber();
48470:         )
48470:     } else {
48470:         SEARCH_PAIRS(
48470:             match = (lval == rval);
48470:         )
48470:     }
48470: #undef SEARCH_PAIRS
48470: 
48470:   end_lookup_switch:
48470:     len = (op == JSOP_LOOKUPSWITCH)
48470:           ? GET_JUMP_OFFSET(pc2)
48470:           : GET_JUMPX_OFFSET(pc2);
48470: }
48470: END_VARLEN_CASE
48470: }
48470: 
48470: BEGIN_CASE(JSOP_TRAP)
48470: {
48470:     Value rval;
48470:     JSTrapStatus status = JS_HandleTrap(cx, script, regs.pc, Jsvalify(&rval));
48470:     switch (status) {
48470:       case JSTRAP_ERROR:
48470:         goto error;
48470:       case JSTRAP_RETURN:
69223:         regs.fp()->setReturnValue(rval);
48470:         interpReturnOK = JS_TRUE;
48470:         goto forced_return;
48470:       case JSTRAP_THROW:
60211:         cx->setPendingException(rval);
48470:         goto error;
48470:       default:
48470:         break;
48470:     }
48470:     JS_ASSERT(status == JSTRAP_CONTINUE);
48470:     CHECK_INTERRUPT_HANDLER();
48470:     JS_ASSERT(rval.isInt32());
48470:     op = (JSOp) rval.toInt32();
48470:     JS_ASSERT((uintN)op < (uintN)JSOP_LIMIT);
48470:     DO_OP();
48470: }
48470: 
48470: BEGIN_CASE(JSOP_ARGUMENTS)
48470: {
48470:     Value rval;
69223:     if (!js_GetArgsValue(cx, regs.fp(), &rval))
48470:         goto error;
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_ARGUMENTS)
48470: 
48470: BEGIN_CASE(JSOP_ARGSUB)
48470: {
48470:     jsid id = INT_TO_JSID(GET_ARGNO(regs.pc));
48470:     Value rval;
69223:     if (!js_GetArgsProperty(cx, regs.fp(), id, &rval))
48470:         goto error;
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_ARGSUB)
48470: 
48470: BEGIN_CASE(JSOP_ARGCNT)
48470: {
48470:     jsid id = ATOM_TO_JSID(rt->atomState.lengthAtom);
48470:     Value rval;
69223:     if (!js_GetArgsProperty(cx, regs.fp(), id, &rval))
48470:         goto error;
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_ARGCNT)
48470: 
48470: BEGIN_CASE(JSOP_GETARG)
48470: BEGIN_CASE(JSOP_CALLARG)
48470: {
48470:     uint32 slot = GET_ARGNO(regs.pc);
69223:     JS_ASSERT(slot < regs.fp()->numFormalArgs());
53840:     PUSH_COPY(argv[slot]);
48470:     if (op == JSOP_CALLARG)
55712:         PUSH_UNDEFINED();
48470: }
48470: END_CASE(JSOP_GETARG)
48470: 
48470: BEGIN_CASE(JSOP_SETARG)
48470: {
48470:     uint32 slot = GET_ARGNO(regs.pc);
69223:     JS_ASSERT(slot < regs.fp()->numFormalArgs());
53840:     argv[slot] = regs.sp[-1];
48470: }
48470: END_SET_CASE(JSOP_SETARG)
48470: 
48470: BEGIN_CASE(JSOP_GETLOCAL)
48470: {
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     JS_ASSERT(slot < script->nslots);
69223:     PUSH_COPY(regs.fp()->slots()[slot]);
48470: }
48470: END_CASE(JSOP_GETLOCAL)
48470: 
48470: BEGIN_CASE(JSOP_CALLLOCAL)
48470: {
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     JS_ASSERT(slot < script->nslots);
69223:     PUSH_COPY(regs.fp()->slots()[slot]);
55712:     PUSH_UNDEFINED();
48470: }
48470: END_CASE(JSOP_CALLLOCAL)
48470: 
48470: BEGIN_CASE(JSOP_SETLOCAL)
48470: {
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     JS_ASSERT(slot < script->nslots);
69223:     regs.fp()->slots()[slot] = regs.sp[-1];
48470: }
48470: END_SET_CASE(JSOP_SETLOCAL)
48470: 
52503: BEGIN_CASE(JSOP_GETFCSLOT)
52503: BEGIN_CASE(JSOP_CALLFCSLOT)
48470: {
69223:     JS_ASSERT(regs.fp()->isNonEvalFunctionFrame());
52503:     uintN index = GET_UINT16(regs.pc);
53840:     JSObject *obj = &argv[-2].toObject();
52503: 
59968:     JS_ASSERT(index < obj->getFunctionPrivate()->script()->bindings.countUpvars());
52503:     PUSH_COPY(obj->getFlatClosureUpvar(index));
52503:     if (op == JSOP_CALLFCSLOT)
55712:         PUSH_UNDEFINED();
48470: }
52503: END_CASE(JSOP_GETFCSLOT)
48470: 
53092: BEGIN_CASE(JSOP_GETGLOBAL)
53092: BEGIN_CASE(JSOP_CALLGLOBAL)
48470: {
48470:     uint32 slot = GET_SLOTNO(regs.pc);
53092:     slot = script->getGlobalSlot(slot);
69223:     JSObject *obj = regs.fp()->scopeChain().getGlobal();
53650:     JS_ASSERT(obj->containsSlot(slot));
53092:     PUSH_COPY(obj->getSlot(slot));
53092:     if (op == JSOP_CALLGLOBAL)
55712:         PUSH_UNDEFINED();
48470: }
53092: END_CASE(JSOP_GETGLOBAL)
53092: 
48470: BEGIN_CASE(JSOP_DEFCONST)
48470: BEGIN_CASE(JSOP_DEFVAR)
48470: {
48470:     uint32 index = GET_INDEX(regs.pc);
48470:     JSAtom *atom = atoms[index];
48470: 
71694:     JSObject *obj = &regs.fp()->varObj();
48622:     JS_ASSERT(!obj->getOps()->defineProperty);
48470:     uintN attrs = JSPROP_ENUMERATE;
69223:     if (!regs.fp()->isEvalFrame())
48470:         attrs |= JSPROP_PERMANENT;
48470: 
48470:     /* Lookup id in order to check for redeclaration problems. */
48470:     jsid id = ATOM_TO_JSID(atom);
62411:     bool shouldDefine;
48470:     if (op == JSOP_DEFVAR) {
48470:         /*
48470:          * Redundant declaration of a |var|, even one for a non-writable
48470:          * property like |undefined| in ES5, does nothing.
48470:          */
62411:         JSProperty *prop;
62411:         JSObject *obj2;
48470:         if (!obj->lookupProperty(cx, id, &obj2, &prop))
48470:             goto error;
62411:         shouldDefine = (!prop || obj2 != obj);
48470:     } else {
62411:         JS_ASSERT(op == JSOP_DEFCONST);
62411:         attrs |= JSPROP_READONLY;
62411:         if (!CheckRedeclaration(cx, obj, id, attrs))
62411:             goto error;
62411: 
62411:         /*
62411:          * As attrs includes readonly, CheckRedeclaration can succeed only
62411:          * if prop does not exist.
62411:          */
62411:         shouldDefine = true;
48470:     }
48470: 
48470:     /* Bind a variable only if it's not yet defined. */
62411:     if (shouldDefine &&
69855:         !DefineNativeProperty(cx, obj, id, UndefinedValue(), PropertyStub, StrictPropertyStub,
69855:                               attrs, 0, 0)) {
62411:         goto error;
48470:     }
48470: }
48470: END_CASE(JSOP_DEFVAR)
48470: 
48470: BEGIN_CASE(JSOP_DEFFUN)
48470: {
48470:     /*
48470:      * A top-level function defined in Global or Eval code (see ECMA-262
48470:      * Ed. 3), or else a SpiderMonkey extension: a named function statement in
48470:      * a compound statement (not at the top statement level of global code, or
48470:      * at the top level of a function body).
48470:      */
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(0);
48470:     JSObject *obj = FUN_OBJECT(fun);
48470: 
48470:     JSObject *obj2;
48470:     if (FUN_NULL_CLOSURE(fun)) {
48470:         /*
48470:          * Even a null closure needs a parent for principals finding.
48470:          * FIXME: bug 476950, although debugger users may also demand some kind
48470:          * of scope link for debugger-assisted eval-in-frame.
48470:          */
69223:         obj2 = &regs.fp()->scopeChain();
48470:     } else {
61216:         JS_ASSERT(!fun->isFlatClosure());
48470: 
69223:         obj2 = GetScopeChainFast(cx, regs.fp(), JSOP_DEFFUN, JSOP_DEFFUN_LENGTH);
48470:         if (!obj2)
48470:             goto error;
48470:     }
48470: 
48470:     /*
48470:      * If static link is not current scope, clone fun's object to link to the
48470:      * current scope via parent. We do this to enable sharing of compiled
48470:      * functions among multiple equivalent scopes, amortizing the cost of
48470:      * compilation over a number of executions.  Examples include XUL scripts
48470:      * and event handlers shared among Firefox or other Mozilla app chrome
48470:      * windows, and user-defined JS functions precompiled and then shared among
48470:      * requests in server-side JS.
48470:      */
48470:     if (obj->getParent() != obj2) {
48470:         obj = CloneFunctionObject(cx, fun, obj2);
48470:         if (!obj)
48470:             goto error;
48470:     }
48470: 
48470:     /*
48470:      * ECMA requires functions defined when entering Eval code to be
48470:      * impermanent.
48470:      */
69223:     uintN attrs = regs.fp()->isEvalFrame()
48470:                   ? JSPROP_ENUMERATE
48470:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
48470: 
48470:     /*
48470:      * We define the function as a property of the variable object and not the
48470:      * current scope chain even for the case of function expression statements
48470:      * and functions defined by eval inside let or with blocks.
48470:      */
71694:     JSObject *parent = &regs.fp()->varObj();
48605: 
61216:     /* ES5 10.5 (NB: with subsequent errata). */
48470:     jsid id = ATOM_TO_JSID(fun->atom);
48605:     JSProperty *prop = NULL;
48605:     JSObject *pobj;
61216:     if (!parent->lookupProperty(cx, id, &pobj, &prop))
61216:         goto error;
61216: 
61216:     Value rval = ObjectValue(*obj);
61216: 
61216:     do {
61216:         /* Steps 5d, 5f. */
61216:         if (!prop || pobj != parent) {
62395:             if (!parent->defineProperty(cx, id, rval, PropertyStub, StrictPropertyStub, attrs))
61216:                 goto error;
61216:             break;
61216:         }
61216: 
61216:         /* Step 5e. */
61216:         JS_ASSERT(parent->isNative());
61216:         Shape *shape = reinterpret_cast<Shape *>(prop);
61216:         if (parent->isGlobal()) {
61216:             if (shape->configurable()) {
62395:                 if (!parent->defineProperty(cx, id, rval, PropertyStub, StrictPropertyStub, attrs))
61216:                     goto error;
61216:                 break;
61216:             }
61216: 
61216:             if (shape->isAccessorDescriptor() || !shape->writable() || !shape->enumerable()) {
61216:                 JSAutoByteString bytes;
61216:                 if (const char *name = js_ValueToPrintable(cx, IdToValue(id), &bytes)) {
61216:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
61216:                                          JSMSG_CANT_REDEFINE_PROP, name);
61216:                 }
61216:                 goto error;
61216:             }
61216:         }
48470: 
48470:         /*
61216:          * Non-global properties, and global properties which we aren't simply
61216:          * redefining, must be set.  First, this preserves their attributes.
61216:          * Second, this will produce warnings and/or errors as necessary if the
61216:          * specified Call object property is not writable (const).
48470:          */
61216: 
61216:         /* Step 5f. */
61216:         if (!parent->setProperty(cx, id, &rval, script->strictModeCode))
61216:             goto error;
61216:     } while (false);
48470: }
48470: END_CASE(JSOP_DEFFUN)
48470: 
48470: BEGIN_CASE(JSOP_DEFFUN_FC)
48470: {
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(0);
48470: 
73779:     JSObject *obj = js_NewFlatClosure(cx, fun, JSOP_DEFFUN_FC, JSOP_DEFFUN_FC_LENGTH);
48470:     if (!obj)
48470:         goto error;
48470: 
48470:     Value rval = ObjectValue(*obj);
48470: 
69223:     uintN attrs = regs.fp()->isEvalFrame()
48470:                   ? JSPROP_ENUMERATE
48470:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
48470: 
71694:     JSObject &parent = regs.fp()->varObj();
48470: 
48470:     jsid id = ATOM_TO_JSID(fun->atom);
62411:     if (!CheckRedeclaration(cx, &parent, id, attrs))
48605:         goto error;
48605: 
48605:     if ((attrs == JSPROP_ENUMERATE)
54169:         ? !parent.setProperty(cx, id, &rval, script->strictModeCode)
62395:         : !parent.defineProperty(cx, id, rval, PropertyStub, StrictPropertyStub, attrs)) {
48605:         goto error;
48605:     }
48470: }
48470: END_CASE(JSOP_DEFFUN_FC)
48470: 
48470: BEGIN_CASE(JSOP_DEFLOCALFUN)
48470: {
48470:     /*
48470:      * Define a local function (i.e., one nested at the top level of another
48470:      * function), parented by the current scope chain, stored in a local
48470:      * variable slot that the compiler allocated.  This is an optimization over
48470:      * JSOP_DEFFUN that avoids requiring a call object for the outer function's
48470:      * activation.
48470:      */
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(SLOTNO_LEN);
48470:     JS_ASSERT(fun->isInterpreted());
48470:     JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
48470:     JSObject *obj = FUN_OBJECT(fun);
48470: 
48470:     if (FUN_NULL_CLOSURE(fun)) {
69223:         obj = CloneFunctionObject(cx, fun, &regs.fp()->scopeChain());
48470:         if (!obj)
48470:             goto error;
48470:     } else {
69223:         JSObject *parent = GetScopeChainFast(cx, regs.fp(), JSOP_DEFLOCALFUN,
54855:                                              JSOP_DEFLOCALFUN_LENGTH);
48470:         if (!parent)
48470:             goto error;
48470: 
48470:         if (obj->getParent() != parent) {
48470: #ifdef JS_TRACER
48470:             if (TRACE_RECORDER(cx))
48470:                 AbortRecording(cx, "DEFLOCALFUN for closure");
48470: #endif
48470:             obj = CloneFunctionObject(cx, fun, parent);
48470:             if (!obj)
48470:                 goto error;
48470:         }
48470:     }
48470: 
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     TRACE_2(DefLocalFunSetSlot, slot, obj);
48470: 
69223:     regs.fp()->slots()[slot].setObject(*obj);
48470: }
48470: END_CASE(JSOP_DEFLOCALFUN)
48470: 
48470: BEGIN_CASE(JSOP_DEFLOCALFUN_FC)
48470: {
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(SLOTNO_LEN);
48470: 
55527:     JSObject *obj = js_NewFlatClosure(cx, fun, JSOP_DEFLOCALFUN_FC, JSOP_DEFLOCALFUN_FC_LENGTH);
48470:     if (!obj)
48470:         goto error;
48470: 
48470:     uint32 slot = GET_SLOTNO(regs.pc);
48470:     TRACE_2(DefLocalFunSetSlot, slot, obj);
48470: 
69223:     regs.fp()->slots()[slot].setObject(*obj);
48470: }
48470: END_CASE(JSOP_DEFLOCALFUN_FC)
48470: 
48470: BEGIN_CASE(JSOP_LAMBDA)
48470: {
48470:     /* Load the specified function object literal. */
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(0);
48470:     JSObject *obj = FUN_OBJECT(fun);
48470: 
48470:     /* do-while(0) so we can break instead of using a goto. */
48470:     do {
48470:         JSObject *parent;
64291:         if (FUN_NULL_CLOSURE(fun)) {
69223:             parent = &regs.fp()->scopeChain();
48470: 
64291:             if (obj->getParent() == parent) {
57755:                 jsbytecode *pc2 = AdvanceOverBlockchainOp(regs.pc + JSOP_LAMBDA_LENGTH);
48676:                 JSOp op2 = JSOp(*pc2);
48470: 
48470:                 /*
48676:                  * Optimize var obj = {method: function () { ... }, ...},
48676:                  * this.method = function () { ... }; and other significant
48676:                  * single-use-of-null-closure bytecode sequences.
48676:                  *
48676:                  * WARNING: code in TraceRecorder::record_JSOP_LAMBDA must
48676:                  * match the optimization cases in the following code that
48676:                  * break from the outer do-while(0).
48470:                  */
48676:                 if (op2 == JSOP_INITMETHOD) {
55527: #ifdef DEBUG
55527:                     const Value &lref = regs.sp[-1];
55527:                     JS_ASSERT(lref.isObject());
55527:                     JSObject *obj2 = &lref.toObject();
55527:                     JS_ASSERT(obj2->getClass() == &js_ObjectClass);
55527: #endif
55527: 
54855:                     fun->setMethodAtom(script->getAtom(GET_FULL_INDEX(pc2 - regs.pc)));
48470:                     break;
48470:                 }
48676: 
48676:                 if (op2 == JSOP_SETMETHOD) {
55527: #ifdef DEBUG
70290:                     op2 = js_GetOpcode(cx, script, pc2 + JSOP_SETMETHOD_LENGTH);
55527:                     JS_ASSERT(op2 == JSOP_POP || op2 == JSOP_POPV);
55527: #endif
48676:                     const Value &lref = regs.sp[-1];
48676:                     if (lref.isObject() && lref.toObject().canHaveMethodBarrier()) {
54855:                         fun->setMethodAtom(script->getAtom(GET_FULL_INDEX(pc2 - regs.pc)));
48676:                         break;
48676:                     }
48676:                 } else if (fun->joinable()) {
48676:                     if (op2 == JSOP_CALL) {
48676:                         /*
48676:                          * Array.prototype.sort and String.prototype.replace are
48676:                          * optimized as if they are special form. We know that they
48676:                          * won't leak the joined function object in obj, therefore
48676:                          * we don't need to clone that compiler- created function
48676:                          * object for identity/mutation reasons.
48676:                          */
48676:                         int iargc = GET_ARGC(pc2);
48676: 
48676:                         /*
48676:                          * Note that we have not yet pushed obj as the final argument,
48676:                          * so regs.sp[1 - (iargc + 2)], and not regs.sp[-(iargc + 2)],
48676:                          * is the callee for this JSOP_CALL.
48676:                          */
48676:                         const Value &cref = regs.sp[1 - (iargc + 2)];
48676:                         JSObject *callee;
48676: 
48676:                         if (IsFunctionObject(cref, &callee)) {
48676:                             JSFunction *calleeFun = GET_FUNCTION_PRIVATE(cx, callee);
53557:                             if (Native native = calleeFun->maybeNative()) {
72559:                                 if ((iargc == 1 && native == array_sort) ||
72559:                                     (iargc == 2 && native == str_replace)) {
48676:                                     break;
48676:                                 }
48676:                             }
48676:                         }
48676:                     } else if (op2 == JSOP_NULL) {
48676:                         pc2 += JSOP_NULL_LENGTH;
48676:                         op2 = JSOp(*pc2);
48676: 
72559:                         if (op2 == JSOP_CALL && GET_ARGC(pc2) == 0)
48676:                             break;
48676:                     }
48676:                 }
48676:             }
48470:         } else {
69223:             parent = GetScopeChainFast(cx, regs.fp(), JSOP_LAMBDA, JSOP_LAMBDA_LENGTH);
48470:             if (!parent)
48470:                 goto error;
48470:         }
48470: 
48470:         obj = CloneFunctionObject(cx, fun, parent);
48470:         if (!obj)
48470:             goto error;
48470:     } while (0);
48470: 
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_LAMBDA)
48470: 
48470: BEGIN_CASE(JSOP_LAMBDA_FC)
48470: {
48470:     JSFunction *fun;
48470:     LOAD_FUNCTION(0);
48470: 
55527:     JSObject *obj = js_NewFlatClosure(cx, fun, JSOP_LAMBDA_FC, JSOP_LAMBDA_FC_LENGTH);
48470:     if (!obj)
48470:         goto error;
48470: 
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_LAMBDA_FC)
48470: 
48470: BEGIN_CASE(JSOP_CALLEE)
69223:     JS_ASSERT(regs.fp()->isNonEvalFunctionFrame());
53840:     PUSH_COPY(argv[-2]);
48470: END_CASE(JSOP_CALLEE)
48470: 
48470: BEGIN_CASE(JSOP_GETTER)
48470: BEGIN_CASE(JSOP_SETTER)
48470: {
48470:   do_getter_setter:
48470:     JSOp op2 = (JSOp) *++regs.pc;
48470:     jsid id;
48470:     Value rval;
48470:     jsint i;
48470:     JSObject *obj;
48470:     switch (op2) {
48470:       case JSOP_INDEXBASE:
48470:         atoms += GET_INDEXBASE(regs.pc);
48470:         regs.pc += JSOP_INDEXBASE_LENGTH - 1;
48470:         goto do_getter_setter;
48470:       case JSOP_INDEXBASE1:
48470:       case JSOP_INDEXBASE2:
48470:       case JSOP_INDEXBASE3:
48470:         atoms += (op2 - JSOP_INDEXBASE1 + 1) << 16;
48470:         goto do_getter_setter;
48470: 
48470:       case JSOP_SETNAME:
48470:       case JSOP_SETPROP:
48470:       {
48470:         JSAtom *atom;
48470:         LOAD_ATOM(0, atom);
48470:         id = ATOM_TO_JSID(atom);
48470:         rval = regs.sp[-1];
48470:         i = -1;
48470:         goto gs_pop_lval;
48470:       }
48470:       case JSOP_SETELEM:
48470:         rval = regs.sp[-1];
48470:         id = JSID_VOID;
48470:         i = -2;
48470:       gs_pop_lval:
48470:         FETCH_OBJECT(cx, i - 1, obj);
48470:         break;
48470: 
48470:       case JSOP_INITPROP:
48470:       {
69223:         JS_ASSERT(regs.sp - regs.fp()->base() >= 2);
48470:         rval = regs.sp[-1];
48470:         i = -1;
48470:         JSAtom *atom;
48470:         LOAD_ATOM(0, atom);
48470:         id = ATOM_TO_JSID(atom);
48470:         goto gs_get_lval;
48470:       }
48470:       default:
48470:         JS_ASSERT(op2 == JSOP_INITELEM);
48470: 
69223:         JS_ASSERT(regs.sp - regs.fp()->base() >= 3);
48470:         rval = regs.sp[-1];
48470:         id = JSID_VOID;
48470:         i = -2;
48470:       gs_get_lval:
48470:       {
48470:         const Value &lref = regs.sp[i-1];
48470:         JS_ASSERT(lref.isObject());
48470:         obj = &lref.toObject();
48470:         break;
48470:       }
48470:     }
48470: 
48470:     /* Ensure that id has a type suitable for use with obj. */
48470:     if (JSID_IS_VOID(id))
48470:         FETCH_ELEMENT_ID(obj, i, id);
48470: 
48470:     if (!js_IsCallable(rval)) {
48470:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
48470:                              JSMSG_BAD_GETTER_OR_SETTER,
48470:                              (op == JSOP_GETTER)
48470:                              ? js_getter_str
48470:                              : js_setter_str);
48470:         goto error;
48470:     }
48470: 
50518:     /*
50518:      * Getters and setters are just like watchpoints from an access control
50518:      * point of view.
50518:      */
48470:     Value rtmp;
48470:     uintN attrs;
50518:     if (!CheckAccess(cx, obj, id, JSACC_WATCH, &rtmp, &attrs))
50518:         goto error;
48470: 
62395:     PropertyOp getter;
62395:     StrictPropertyOp setter;
48470:     if (op == JSOP_GETTER) {
48470:         getter = CastAsPropertyOp(&rval.toObject());
62395:         setter = StrictPropertyStub;
48470:         attrs = JSPROP_GETTER;
48470:     } else {
48470:         getter = PropertyStub;
62395:         setter = CastAsStrictPropertyOp(&rval.toObject());
48470:         attrs = JSPROP_SETTER;
48470:     }
48470:     attrs |= JSPROP_ENUMERATE | JSPROP_SHARED;
48470: 
48470:     /* Check for a readonly or permanent property of the same name. */
62411:     if (!CheckRedeclaration(cx, obj, id, attrs))
48470:         goto error;
48470: 
48470:     if (!obj->defineProperty(cx, id, UndefinedValue(), getter, setter, attrs))
48470:         goto error;
48470: 
48470:     regs.sp += i;
48470:     if (js_CodeSpec[op2].ndefs > js_CodeSpec[op2].nuses) {
48470:         JS_ASSERT(js_CodeSpec[op2].ndefs == js_CodeSpec[op2].nuses + 1);
48470:         regs.sp[-1] = rval;
55638:         assertSameCompartment(cx, regs.sp[-1]);
48470:     }
48470:     len = js_CodeSpec[op2].length;
48470:     DO_NEXT_OP(len);
48470: }
48470: 
48470: BEGIN_CASE(JSOP_HOLE)
48470:     PUSH_HOLE();
48470: END_CASE(JSOP_HOLE)
48470: 
48470: BEGIN_CASE(JSOP_NEWINIT)
48470: {
58056:     jsint i = regs.pc[1];
55746: 
48470:     JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
48470:     JSObject *obj;
55746: 
48470:     if (i == JSProto_Array) {
59234:         obj = NewDenseEmptyArray(cx);
58056:     } else {
58056:         gc::FinalizeKind kind = GuessObjectGCKind(0, false);
58056:         obj = NewBuiltinClassInstance(cx, &js_ObjectClass, kind);
58056:     }
58056: 
48470:     if (!obj)
48470:         goto error;
48470: 
48470:     PUSH_OBJECT(*obj);
48470:     CHECK_INTERRUPT_HANDLER();
48470: }
48470: END_CASE(JSOP_NEWINIT)
48470: 
58056: BEGIN_CASE(JSOP_NEWARRAY)
58056: {
58056:     unsigned count = GET_UINT24(regs.pc);
59234:     JSObject *obj = NewDenseAllocatedArray(cx, count);
59234:     if (!obj)
58056:         goto error;
58056: 
58056:     PUSH_OBJECT(*obj);
58056:     CHECK_INTERRUPT_HANDLER();
58056: }
58056: END_CASE(JSOP_NEWARRAY)
58056: 
58056: BEGIN_CASE(JSOP_NEWOBJECT)
58056: {
58056:     JSObject *baseobj;
58056:     LOAD_OBJECT(0, baseobj);
58056: 
58056:     JSObject *obj = CopyInitializerObject(cx, baseobj);
58056: 
58056:     if (!obj)
58056:         goto error;
58056: 
58056:     PUSH_OBJECT(*obj);
58056:     CHECK_INTERRUPT_HANDLER();
58056: }
58056: END_CASE(JSOP_NEWOBJECT)
58056: 
48470: BEGIN_CASE(JSOP_ENDINIT)
48470: {
51109:     /* FIXME remove JSOP_ENDINIT bug 588522 */
69223:     JS_ASSERT(regs.sp - regs.fp()->base() >= 1);
51109:     JS_ASSERT(regs.sp[-1].isObject());
48470: }
48470: END_CASE(JSOP_ENDINIT)
48470: 
48470: BEGIN_CASE(JSOP_INITPROP)
48470: BEGIN_CASE(JSOP_INITMETHOD)
48470: {
48470:     /* Load the property's initial value into rval. */
69223:     JS_ASSERT(regs.sp - regs.fp()->base() >= 2);
48470:     Value rval = regs.sp[-1];
48470: 
48470:     /* Load the object being initialized into lval/obj. */
48470:     JSObject *obj = &regs.sp[-2].toObject();
60780:     JS_ASSERT(obj->isObject());
48470: 
48470:     /*
48470:      * Probe the property cache.
48470:      *
52503:      * On a hit, if the cached shape has a non-default setter, it must be
52503:      * __proto__. If shape->previous() != obj->lastProperty(), there must be a
48470:      * repeated property name. The fast path does not handle these two cases.
48470:      */
48470:     PropertyCacheEntry *entry;
52503:     const Shape *shape;
56567:     if (JS_PROPERTY_CACHE(cx).testForInit(rt, regs.pc, obj, &shape, &entry) &&
52503:         shape->hasDefaultSetter() &&
52503:         shape->previous() == obj->lastProperty())
48470:     {
48470:         /* Fast path. Property cache hit. */
52503:         uint32 slot = shape->slot;
52503: 
53652:         JS_ASSERT(slot == obj->slotSpan());
52503:         JS_ASSERT(slot >= JSSLOT_FREE(obj->getClass()));
48470:         if (slot < obj->numSlots()) {
52503:             JS_ASSERT(obj->getSlot(slot).isUndefined());
48470:         } else {
52503:             if (!obj->allocSlot(cx, &slot))
52503:                 goto error;
52503:             JS_ASSERT(slot == shape->slot);
52503:         }
52503: 
52503:         /* A new object, or one we just extended in a recent initprop op. */
52503:         JS_ASSERT(!obj->lastProperty() ||
69637:                   obj->shape() == obj->lastProperty()->shapeid);
52503:         obj->extend(cx, shape);
48470: 
48470:         /*
48470:          * No method change check here because here we are adding a new
48470:          * property, not updating an existing slot's value that might
52503:          * contain a method of a branded shape.
48470:          */
60780:         TRACE_1(AddProperty, obj);
56567:         obj->nativeSetSlot(slot, rval);
48470:     } else {
48470:         PCMETER(JS_PROPERTY_CACHE(cx).inipcmisses++);
48470: 
48470:         /* Get the immediate property name into id. */
48470:         JSAtom *atom;
48470:         LOAD_ATOM(0, atom);
48470:         jsid id = ATOM_TO_JSID(atom);
48470: 
48470:         uintN defineHow = (op == JSOP_INITMETHOD)
69855:                           ? DNP_CACHE_RESULT | DNP_SET_METHOD
69855:                           : DNP_CACHE_RESULT;
69855:         if (JS_UNLIKELY(atom == cx->runtime->atomState.protoAtom)
69855:             ? !js_SetPropertyHelper(cx, obj, id, defineHow, &rval, script->strictModeCode)
69855:             : !DefineNativeProperty(cx, obj, id, rval, NULL, NULL,
69855:                                     JSPROP_ENUMERATE, 0, 0, defineHow)) {
48470:             goto error;
48470:         }
48470:     }
48470: 
48470:     /* Common tail for property cache hit and miss cases. */
48470:     regs.sp--;
48470: }
48470: END_CASE(JSOP_INITPROP);
48470: 
48470: BEGIN_CASE(JSOP_INITELEM)
48470: {
48470:     /* Pop the element's value into rval. */
69223:     JS_ASSERT(regs.sp - regs.fp()->base() >= 3);
48470:     const Value &rref = regs.sp[-1];
48470: 
48470:     /* Find the object being initialized at top of stack. */
48470:     const Value &lref = regs.sp[-3];
48470:     JS_ASSERT(lref.isObject());
48470:     JSObject *obj = &lref.toObject();
48470: 
48470:     /* Fetch id now that we have obj. */
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -2, id);
48470: 
48470:     /*
48470:      * If rref is a hole, do not call JSObject::defineProperty. In this case,
48470:      * obj must be an array, so if the current op is the last element
48470:      * initialiser, set the array length to one greater than id.
48470:      */
48470:     if (rref.isMagic(JS_ARRAY_HOLE)) {
48470:         JS_ASSERT(obj->isArray());
48470:         JS_ASSERT(JSID_IS_INT(id));
73495:         JS_ASSERT(jsuint(JSID_TO_INT(id)) < StackSpace::ARGS_LENGTH_MAX);
48470:         if (js_GetOpcode(cx, script, regs.pc + JSOP_INITELEM_LENGTH) == JSOP_ENDINIT &&
48470:             !js_SetLengthProperty(cx, obj, (jsuint) (JSID_TO_INT(id) + 1))) {
48470:             goto error;
48470:         }
48470:     } else {
48470:         if (!obj->defineProperty(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
48470:             goto error;
48470:     }
48470:     regs.sp -= 2;
48470: }
48470: END_CASE(JSOP_INITELEM)
48470: 
48470: #if JS_HAS_SHARP_VARS
48470: 
48470: BEGIN_CASE(JSOP_DEFSHARP)
48470: {
48470:     uint32 slot = GET_UINT16(regs.pc);
69223:     JS_ASSERT(slot + 1 < regs.fp()->numFixed());
69223:     const Value &lref = regs.fp()->slots()[slot];
48470:     JSObject *obj;
48470:     if (lref.isObject()) {
48470:         obj = &lref.toObject();
48470:     } else {
48470:         JS_ASSERT(lref.isUndefined());
59234:         obj = NewDenseEmptyArray(cx);
48470:         if (!obj)
48470:             goto error;
69223:         regs.fp()->slots()[slot].setObject(*obj);
48470:     }
48470:     jsint i = (jsint) GET_UINT16(regs.pc + UINT16_LEN);
48470:     jsid id = INT_TO_JSID(i);
48470:     const Value &rref = regs.sp[-1];
48470:     if (rref.isPrimitive()) {
48470:         char numBuf[12];
48470:         JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
48470:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
48470:                              JSMSG_BAD_SHARP_DEF, numBuf);
48470:         goto error;
48470:     }
48470:     if (!obj->defineProperty(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
48470:         goto error;
48470: }
48470: END_CASE(JSOP_DEFSHARP)
48470: 
48470: BEGIN_CASE(JSOP_USESHARP)
48470: {
48470:     uint32 slot = GET_UINT16(regs.pc);
69223:     JS_ASSERT(slot + 1 < regs.fp()->numFixed());
69223:     const Value &lref = regs.fp()->slots()[slot];
48470:     jsint i = (jsint) GET_UINT16(regs.pc + UINT16_LEN);
48470:     Value rval;
48470:     if (lref.isUndefined()) {
48470:         rval.setUndefined();
48470:     } else {
69223:         JSObject *obj = &regs.fp()->slots()[slot].toObject();
48470:         jsid id = INT_TO_JSID(i);
48470:         if (!obj->getProperty(cx, id, &rval))
48470:             goto error;
48470:     }
48470:     if (!rval.isObjectOrNull()) {
48470:         char numBuf[12];
48470: 
48470:         JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
48470:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
48470:                              JSMSG_BAD_SHARP_USE, numBuf);
48470:         goto error;
48470:     }
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_USESHARP)
48470: 
48470: BEGIN_CASE(JSOP_SHARPINIT)
48470: {
48470:     uint32 slot = GET_UINT16(regs.pc);
69223:     JS_ASSERT(slot + 1 < regs.fp()->numFixed());
69223:     Value *vp = &regs.fp()->slots()[slot];
48470:     Value rval = vp[1];
48470: 
48470:     /*
48470:      * We peek ahead safely here because empty initialisers get zero
48470:      * JSOP_SHARPINIT ops, and non-empty ones get two: the first comes
48470:      * immediately after JSOP_NEWINIT followed by one or more property
48470:      * initialisers; and the second comes directly before JSOP_ENDINIT.
48470:      */
48470:     if (regs.pc[JSOP_SHARPINIT_LENGTH] != JSOP_ENDINIT) {
48470:         rval.setInt32(rval.isUndefined() ? 1 : rval.toInt32() + 1);
48470:     } else {
48470:         JS_ASSERT(rval.isInt32());
48470:         rval.getInt32Ref() -= 1;
48470:         if (rval.toInt32() == 0)
48470:             vp[0].setUndefined();
48470:     }
48470:     vp[1] = rval;
48470: }
48470: END_CASE(JSOP_SHARPINIT)
48470: 
48470: #endif /* JS_HAS_SHARP_VARS */
48470: 
48470: {
48470: BEGIN_CASE(JSOP_GOSUB)
48470:     PUSH_BOOLEAN(false);
48470:     jsint i = (regs.pc - script->main) + JSOP_GOSUB_LENGTH;
48470:     PUSH_INT32(i);
48470:     len = GET_JUMP_OFFSET(regs.pc);
48470: END_VARLEN_CASE
48470: }
48470: 
48470: {
48470: BEGIN_CASE(JSOP_GOSUBX)
48470:     PUSH_BOOLEAN(false);
48470:     jsint i = (regs.pc - script->main) + JSOP_GOSUBX_LENGTH;
48470:     len = GET_JUMPX_OFFSET(regs.pc);
48470:     PUSH_INT32(i);
48470: END_VARLEN_CASE
48470: }
48470: 
48470: {
48470: BEGIN_CASE(JSOP_RETSUB)
48470:     /* Pop [exception or hole, retsub pc-index]. */
48470:     Value rval, lval;
48470:     POP_COPY_TO(rval);
48470:     POP_COPY_TO(lval);
48470:     JS_ASSERT(lval.isBoolean());
48470:     if (lval.toBoolean()) {
48470:         /*
48470:          * Exception was pending during finally, throw it *before* we adjust
48470:          * pc, because pc indexes into script->trynotes.  This turns out not to
48470:          * be necessary, but it seems clearer.  And it points out a FIXME:
48470:          * 350509, due to Igor Bukanov.
48470:          */
60211:         cx->setPendingException(rval);
48470:         goto error;
48470:     }
48470:     JS_ASSERT(rval.isInt32());
48470:     len = rval.toInt32();
48470:     regs.pc = script->main;
48470: END_VARLEN_CASE
48470: }
48470: 
48470: BEGIN_CASE(JSOP_EXCEPTION)
60211:     PUSH_COPY(cx->getPendingException());
60211:     cx->clearPendingException();
56551: #if defined(JS_TRACER) && defined(JS_METHODJIT)
56551:     if (interpMode == JSINTERP_PROFILE) {
56551:         leaveOnSafePoint = true;
56551:         LEAVE_ON_SAFE_POINT();
56551:     }
56551: #endif
48470:     CHECK_BRANCH();
48470: END_CASE(JSOP_EXCEPTION)
48470: 
48470: BEGIN_CASE(JSOP_FINALLY)
48470:     CHECK_BRANCH();
48470: END_CASE(JSOP_FINALLY)
48470: 
48470: BEGIN_CASE(JSOP_THROWING)
60211: {
60211:     JS_ASSERT(!cx->isExceptionPending());
60211:     Value v;
60211:     POP_COPY_TO(v);
60211:     cx->setPendingException(v);
60211: }
48470: END_CASE(JSOP_THROWING)
48470: 
48470: BEGIN_CASE(JSOP_THROW)
60211: {
60211:     JS_ASSERT(!cx->isExceptionPending());
48470:     CHECK_BRANCH();
60211:     Value v;
60211:     POP_COPY_TO(v);
60211:     cx->setPendingException(v);
48470:     /* let the code at error try to catch the exception. */
48470:     goto error;
60211: }
48470: BEGIN_CASE(JSOP_SETLOCALPOP)
48470: {
48470:     /*
48470:      * The stack must have a block with at least one local slot below the
48470:      * exception object.
48470:      */
69223:     JS_ASSERT((size_t) (regs.sp - regs.fp()->base()) >= 2);
48470:     uint32 slot = GET_UINT16(regs.pc);
48470:     JS_ASSERT(slot + 1 < script->nslots);
69223:     POP_COPY_TO(regs.fp()->slots()[slot]);
48470: }
48470: END_CASE(JSOP_SETLOCALPOP)
48470: 
72055: BEGIN_CASE(JSOP_IFCANTCALLTOP)
48470:     /*
48470:      * If the top of stack is of primitive type, jump to our target. Otherwise
48470:      * advance to the next opcode.
48470:      */
69223:     JS_ASSERT(regs.sp > regs.fp()->base());
72055:     if (!js_IsCallable(regs.sp[-1])) {
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         BRANCH(len);
48470:     }
72055: END_CASE(JSOP_IFCANTCALLTOP)
48470: 
48470: BEGIN_CASE(JSOP_PRIMTOP)
69223:     JS_ASSERT(regs.sp > regs.fp()->base());
48470:     if (regs.sp[-1].isObject()) {
48470:         jsint i = GET_INT8(regs.pc);
48470:         js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO, -2, regs.sp[-2], NULL,
48470:                              (i == JSTYPE_VOID) ? "primitive type" : JS_TYPE_STR(i));
48470:         goto error;
48470:     }
48470: END_CASE(JSOP_PRIMTOP)
48470: 
48470: BEGIN_CASE(JSOP_OBJTOP)
48470:     if (regs.sp[-1].isPrimitive()) {
48470:         js_ReportValueError(cx, GET_UINT16(regs.pc), -1, regs.sp[-1], NULL);
48470:         goto error;
48470:     }
48470: END_CASE(JSOP_OBJTOP)
48470: 
48470: BEGIN_CASE(JSOP_INSTANCEOF)
48470: {
48470:     const Value &rref = regs.sp[-1];
48529:     if (rref.isPrimitive()) {
48529:         js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS, -1, rref, NULL);
48529:         goto error;
48529:     }
48529:     JSObject *obj = &rref.toObject();
48470:     const Value &lref = regs.sp[-2];
48470:     JSBool cond = JS_FALSE;
48547:     if (!HasInstance(cx, obj, &lref, &cond))
48470:         goto error;
48470:     regs.sp--;
48470:     regs.sp[-1].setBoolean(cond);
48470: }
48470: END_CASE(JSOP_INSTANCEOF)
48470: 
48470: BEGIN_CASE(JSOP_DEBUGGER)
48470: {
48470:     JSDebuggerHandler handler = cx->debugHooks->debuggerHandler;
48470:     if (handler) {
48470:         Value rval;
48470:         switch (handler(cx, script, regs.pc, Jsvalify(&rval), cx->debugHooks->debuggerHandlerData)) {
48470:         case JSTRAP_ERROR:
48470:             goto error;
48470:         case JSTRAP_CONTINUE:
48470:             break;
48470:         case JSTRAP_RETURN:
69223:             regs.fp()->setReturnValue(rval);
48470:             interpReturnOK = JS_TRUE;
48470:             goto forced_return;
48470:         case JSTRAP_THROW:
60211:             cx->setPendingException(rval);
48470:             goto error;
48470:         default:;
48470:         }
48470:         CHECK_INTERRUPT_HANDLER();
48470:     }
48470: }
48470: END_CASE(JSOP_DEBUGGER)
48470: 
48470: #if JS_HAS_XML_SUPPORT
48470: BEGIN_CASE(JSOP_DEFXMLNS)
48470: {
53568:     if (!js_SetDefaultXMLNamespace(cx, regs.sp[-1]))
53568:         goto error;
53568:     regs.sp--;
48470: }
48470: END_CASE(JSOP_DEFXMLNS)
48470: 
48470: BEGIN_CASE(JSOP_ANYNAME)
48470: {
48470:     jsid id;
48470:     if (!js_GetAnyName(cx, &id))
48470:         goto error;
48470:     PUSH_COPY(IdToValue(id));
48470: }
48470: END_CASE(JSOP_ANYNAME)
48470: 
48470: BEGIN_CASE(JSOP_QNAMEPART)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
64345:     PUSH_STRING(atom);
48470: }
48470: END_CASE(JSOP_QNAMEPART)
48470: 
48470: BEGIN_CASE(JSOP_QNAMECONST)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
64345:     Value rval = StringValue(atom);
48470:     Value lval = regs.sp[-1];
48470:     JSObject *obj = js_ConstructXMLQNameObject(cx, lval, rval);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_QNAMECONST)
48470: 
48470: BEGIN_CASE(JSOP_QNAME)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     Value lval = regs.sp[-2];
48470:     JSObject *obj = js_ConstructXMLQNameObject(cx, lval, rval);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp--;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_QNAME)
48470: 
48470: BEGIN_CASE(JSOP_TOATTRNAME)
48470: {
48470:     Value rval;
48470:     rval = regs.sp[-1];
48470:     if (!js_ToAttributeName(cx, &rval))
48470:         goto error;
48470:     regs.sp[-1] = rval;
48470: }
48470: END_CASE(JSOP_TOATTRNAME)
48470: 
48470: BEGIN_CASE(JSOP_TOATTRVAL)
48470: {
48470:     Value rval;
48470:     rval = regs.sp[-1];
48470:     JS_ASSERT(rval.isString());
48470:     JSString *str = js_EscapeAttributeValue(cx, rval.toString(), JS_FALSE);
48470:     if (!str)
48470:         goto error;
48470:     regs.sp[-1].setString(str);
48470: }
48470: END_CASE(JSOP_TOATTRVAL)
48470: 
48470: BEGIN_CASE(JSOP_ADDATTRNAME)
48470: BEGIN_CASE(JSOP_ADDATTRVAL)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     Value lval = regs.sp[-2];
48470:     JSString *str = lval.toString();
48470:     JSString *str2 = rval.toString();
48470:     str = js_AddAttributePart(cx, op == JSOP_ADDATTRNAME, str, str2);
48470:     if (!str)
48470:         goto error;
48470:     regs.sp--;
48470:     regs.sp[-1].setString(str);
48470: }
48470: END_CASE(JSOP_ADDATTRNAME)
48470: 
48470: BEGIN_CASE(JSOP_BINDXMLNAME)
48470: {
48470:     Value lval;
48470:     lval = regs.sp[-1];
48470:     JSObject *obj;
48470:     jsid id;
48470:     if (!js_FindXMLProperty(cx, lval, &obj, &id))
48470:         goto error;
48470:     regs.sp[-1].setObjectOrNull(obj);
48470:     PUSH_COPY(IdToValue(id));
48470: }
48470: END_CASE(JSOP_BINDXMLNAME)
48470: 
48470: BEGIN_CASE(JSOP_SETXMLNAME)
48470: {
48470:     JSObject *obj = &regs.sp[-3].toObject();
48470:     Value rval = regs.sp[-1];
48470:     jsid id;
48470:     FETCH_ELEMENT_ID(obj, -2, id);
54169:     if (!obj->setProperty(cx, id, &rval, script->strictModeCode))
48470:         goto error;
48470:     rval = regs.sp[-1];
48470:     regs.sp -= 2;
48470:     regs.sp[-1] = rval;
48470: }
48470: END_CASE(JSOP_SETXMLNAME)
48470: 
48470: BEGIN_CASE(JSOP_CALLXMLNAME)
48470: BEGIN_CASE(JSOP_XMLNAME)
48470: {
48470:     Value lval = regs.sp[-1];
48470:     JSObject *obj;
48470:     jsid id;
48470:     if (!js_FindXMLProperty(cx, lval, &obj, &id))
48470:         goto error;
48470:     Value rval;
48470:     if (!obj->getProperty(cx, id, &rval))
48470:         goto error;
48470:     regs.sp[-1] = rval;
48470:     if (op == JSOP_CALLXMLNAME)
63096:         PUSH_IMPLICIT_THIS(cx, obj, rval);
48470: }
48470: END_CASE(JSOP_XMLNAME)
48470: 
48470: BEGIN_CASE(JSOP_DESCENDANTS)
48470: BEGIN_CASE(JSOP_DELDESC)
48470: {
48470:     JSObject *obj;
48470:     FETCH_OBJECT(cx, -2, obj);
48470:     jsval rval = Jsvalify(regs.sp[-1]);
48470:     if (!js_GetXMLDescendants(cx, obj, rval, &rval))
48470:         goto error;
48470: 
48470:     if (op == JSOP_DELDESC) {
48470:         regs.sp[-1] = Valueify(rval);   /* set local root */
48470:         if (!js_DeleteXMLListElements(cx, JSVAL_TO_OBJECT(rval)))
48470:             goto error;
48470:         rval = JSVAL_TRUE;                  /* always succeed */
48470:     }
48470: 
48470:     regs.sp--;
48470:     regs.sp[-1] = Valueify(rval);
48470: }
48470: END_CASE(JSOP_DESCENDANTS)
48470: 
48470: {
48470: BEGIN_CASE(JSOP_FILTER)
48470:     /*
48470:      * We push the hole value before jumping to [enditer] so we can detect the
48470:      * first iteration and direct js_StepXMLListFilter to initialize filter's
48470:      * state.
48470:      */
48470:     PUSH_HOLE();
48470:     len = GET_JUMP_OFFSET(regs.pc);
48470:     JS_ASSERT(len > 0);
48470: END_VARLEN_CASE
48470: }
48470: 
48470: BEGIN_CASE(JSOP_ENDFILTER)
48470: {
48470:     bool cond = !regs.sp[-1].isMagic();
48470:     if (cond) {
48470:         /* Exit the "with" block left from the previous iteration. */
48470:         js_LeaveWith(cx);
48470:     }
48470:     if (!js_StepXMLListFilter(cx, cond))
48470:         goto error;
48470:     if (!regs.sp[-1].isNull()) {
48470:         /*
48470:          * Decrease sp after EnterWith returns as we use sp[-1] there to root
48470:          * temporaries.
48470:          */
48470:         JS_ASSERT(IsXML(regs.sp[-1]));
55527:         if (!js_EnterWith(cx, -2, JSOP_ENDFILTER, JSOP_ENDFILTER_LENGTH))
48470:             goto error;
48470:         regs.sp--;
48470:         len = GET_JUMP_OFFSET(regs.pc);
48470:         JS_ASSERT(len < 0);
48470:         BRANCH(len);
48470:     }
48470:     regs.sp--;
48470: }
48470: END_CASE(JSOP_ENDFILTER);
48470: 
48470: BEGIN_CASE(JSOP_TOXML)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     JSObject *obj = js_ValueToXMLObject(cx, rval);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_TOXML)
48470: 
48470: BEGIN_CASE(JSOP_TOXMLLIST)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     JSObject *obj = js_ValueToXMLListObject(cx, rval);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_TOXMLLIST)
48470: 
48470: BEGIN_CASE(JSOP_XMLTAGEXPR)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     JSString *str = js_ValueToString(cx, rval);
48470:     if (!str)
48470:         goto error;
48470:     regs.sp[-1].setString(str);
48470: }
48470: END_CASE(JSOP_XMLTAGEXPR)
48470: 
48470: BEGIN_CASE(JSOP_XMLELTEXPR)
48470: {
48470:     Value rval = regs.sp[-1];
48470:     JSString *str;
48470:     if (IsXML(rval)) {
48470:         str = js_ValueToXMLString(cx, rval);
48470:     } else {
48470:         str = js_ValueToString(cx, rval);
48470:         if (str)
48470:             str = js_EscapeElementValue(cx, str);
48470:     }
48470:     if (!str)
48470:         goto error;
48470:     regs.sp[-1].setString(str);
48470: }
48470: END_CASE(JSOP_XMLELTEXPR)
48470: 
48470: BEGIN_CASE(JSOP_XMLCDATA)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
64345:     JSString *str = atom;
48470:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_TEXT, NULL, str);
48470:     if (!obj)
48470:         goto error;
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_XMLCDATA)
48470: 
48470: BEGIN_CASE(JSOP_XMLCOMMENT)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
64345:     JSString *str = atom;
48470:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_COMMENT, NULL, str);
48470:     if (!obj)
48470:         goto error;
48470:     PUSH_OBJECT(*obj);
48470: }
48470: END_CASE(JSOP_XMLCOMMENT)
48470: 
48470: BEGIN_CASE(JSOP_XMLPI)
48470: {
48470:     JSAtom *atom;
48470:     LOAD_ATOM(0, atom);
64345:     JSString *str = atom;
48470:     Value rval = regs.sp[-1];
48470:     JSString *str2 = rval.toString();
48470:     JSObject *obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_PROCESSING_INSTRUCTION, str, str2);
48470:     if (!obj)
48470:         goto error;
48470:     regs.sp[-1].setObject(*obj);
48470: }
48470: END_CASE(JSOP_XMLPI)
48470: 
48470: BEGIN_CASE(JSOP_GETFUNNS)
48470: {
48470:     Value rval;
68955:     if (!cx->fp()->scopeChain().getGlobal()->getFunctionNamespace(cx, &rval))
48470:         goto error;
48470:     PUSH_COPY(rval);
48470: }
48470: END_CASE(JSOP_GETFUNNS)
48470: #endif /* JS_HAS_XML_SUPPORT */
48470: 
48470: BEGIN_CASE(JSOP_ENTERBLOCK)
48470: {
48470:     JSObject *obj;
48470:     LOAD_OBJECT(0, obj);
53650:     JS_ASSERT(obj->isStaticBlock());
69223:     JS_ASSERT(regs.fp()->base() + OBJ_BLOCK_DEPTH(cx, obj) == regs.sp);
48470:     Value *vp = regs.sp + OBJ_BLOCK_COUNT(cx, obj);
48470:     JS_ASSERT(regs.sp < vp);
69223:     JS_ASSERT(vp <= regs.fp()->slots() + script->nslots);
48470:     SetValueRangeToUndefined(regs.sp, vp);
48470:     regs.sp = vp;
48470: 
48470: #ifdef DEBUG
48470:     /*
48470:      * The young end of fp->scopeChain may omit blocks if we haven't closed
48470:      * over them, but if there are any closure blocks on fp->scopeChain, they'd
48470:      * better be (clones of) ancestors of the block we're entering now;
48470:      * anything else we should have popped off fp->scopeChain when we left its
48470:      * static scope.
48470:      */
69223:     JSObject *obj2 = &regs.fp()->scopeChain();
48470:     Class *clasp;
48470:     while ((clasp = obj2->getClass()) == &js_WithClass)
48470:         obj2 = obj2->getParent();
48470:     if (clasp == &js_BlockClass &&
69223:         obj2->getPrivate() == js_FloatingFrameIfGenerator(cx, regs.fp())) {
48470:         JSObject *youngestProto = obj2->getProto();
53650:         JS_ASSERT(youngestProto->isStaticBlock());
48470:         JSObject *parent = obj;
48470:         while ((parent = parent->getParent()) != youngestProto)
48470:             JS_ASSERT(parent);
48470:     }
48470: #endif
48470: }
48470: END_CASE(JSOP_ENTERBLOCK)
48470: 
48470: BEGIN_CASE(JSOP_LEAVEBLOCKEXPR)
48470: BEGIN_CASE(JSOP_LEAVEBLOCK)
48470: {
54855:     JSObject *blockChain;
54855:     LOAD_OBJECT(UINT16_LEN, blockChain);
48470: #ifdef DEBUG
54855:     JS_ASSERT(blockChain->isStaticBlock());
54855:     uintN blockDepth = OBJ_BLOCK_DEPTH(cx, blockChain);
48470:     JS_ASSERT(blockDepth <= StackDepth(script));
48470: #endif
48470:     /*
48470:      * If we're about to leave the dynamic scope of a block that has been
48470:      * cloned onto fp->scopeChain, clear its private data, move its locals from
48470:      * the stack into the clone, and pop it off the chain.
48470:      */
69223:     JSObject &obj = regs.fp()->scopeChain();
54855:     if (obj.getProto() == blockChain) {
53840:         JS_ASSERT(obj.isClonedBlock());
48470:         if (!js_PutBlockObject(cx, JS_TRUE))
48470:             goto error;
48470:     }
48470: 
48470:     /* Move the result of the expression to the new topmost stack slot. */
48470:     Value *vp = NULL;  /* silence GCC warnings */
48470:     if (op == JSOP_LEAVEBLOCKEXPR)
48470:         vp = &regs.sp[-1];
48470:     regs.sp -= GET_UINT16(regs.pc);
48470:     if (op == JSOP_LEAVEBLOCKEXPR) {
69223:         JS_ASSERT(regs.fp()->base() + blockDepth == regs.sp - 1);
48470:         regs.sp[-1] = *vp;
48470:     } else {
69223:         JS_ASSERT(regs.fp()->base() + blockDepth == regs.sp);
48470:     }
48470: }
48470: END_CASE(JSOP_LEAVEBLOCK)
48470: 
48470: #if JS_HAS_GENERATORS
48470: BEGIN_CASE(JSOP_GENERATOR)
48470: {
60211:     JS_ASSERT(!cx->isExceptionPending());
48470:     regs.pc += JSOP_GENERATOR_LENGTH;
48470:     JSObject *obj = js_NewGenerator(cx);
48470:     if (!obj)
48470:         goto error;
69223:     JS_ASSERT(!regs.fp()->hasCallObj() && !regs.fp()->hasArgsObj());
69223:     regs.fp()->setReturnValue(ObjectValue(*obj));
48470:     interpReturnOK = true;
69223:     if (entryFrame != regs.fp())
48470:         goto inline_return;
48470:     goto exit;
48470: }
48470: 
48470: BEGIN_CASE(JSOP_YIELD)
60211:     JS_ASSERT(!cx->isExceptionPending());
69223:     JS_ASSERT(regs.fp()->isNonEvalFunctionFrame());
69223:     if (cx->generatorFor(regs.fp())->state == JSGEN_CLOSING) {
48470:         js_ReportValueError(cx, JSMSG_BAD_GENERATOR_YIELD,
53840:                             JSDVG_SEARCH_STACK, argv[-2], NULL);
53840:         goto error;
53840:     }
69223:     regs.fp()->setReturnValue(regs.sp[-1]);
69223:     regs.fp()->setYielding();
48470:     regs.pc += JSOP_YIELD_LENGTH;
48470:     interpReturnOK = JS_TRUE;
48470:     goto exit;
48470: 
48470: BEGIN_CASE(JSOP_ARRAYPUSH)
48470: {
48470:     uint32 slot = GET_UINT16(regs.pc);
48470:     JS_ASSERT(script->nfixed <= slot);
48470:     JS_ASSERT(slot < script->nslots);
69223:     JSObject *obj = &regs.fp()->slots()[slot].toObject();
73079:     if (!js_NewbornArrayPush(cx, obj, regs.sp[-1]))
48470:         goto error;
48470:     regs.sp--;
48470: }
48470: END_CASE(JSOP_ARRAYPUSH)
48470: #endif /* JS_HAS_GENERATORS */
48470: 
48470: #if JS_THREADED_INTERP
48470:   L_JSOP_BACKPATCH:
48470:   L_JSOP_BACKPATCH_POP:
48470: 
48470: # if !JS_HAS_GENERATORS
48470:   L_JSOP_GENERATOR:
48470:   L_JSOP_YIELD:
48470:   L_JSOP_ARRAYPUSH:
48470: # endif
48470: 
48470: # if !JS_HAS_SHARP_VARS
48470:   L_JSOP_DEFSHARP:
48470:   L_JSOP_USESHARP:
48470:   L_JSOP_SHARPINIT:
48470: # endif
48470: 
48470: # if !JS_HAS_DESTRUCTURING
48470:   L_JSOP_ENUMCONSTELEM:
48470: # endif
48470: 
48470: # if !JS_HAS_XML_SUPPORT
48470:   L_JSOP_CALLXMLNAME:
48470:   L_JSOP_STARTXMLEXPR:
48470:   L_JSOP_STARTXML:
48470:   L_JSOP_DELDESC:
48470:   L_JSOP_GETFUNNS:
48470:   L_JSOP_XMLPI:
48470:   L_JSOP_XMLCOMMENT:
48470:   L_JSOP_XMLCDATA:
48470:   L_JSOP_XMLELTEXPR:
48470:   L_JSOP_XMLTAGEXPR:
48470:   L_JSOP_TOXMLLIST:
48470:   L_JSOP_TOXML:
48470:   L_JSOP_ENDFILTER:
48470:   L_JSOP_FILTER:
48470:   L_JSOP_DESCENDANTS:
48470:   L_JSOP_XMLNAME:
48470:   L_JSOP_SETXMLNAME:
48470:   L_JSOP_BINDXMLNAME:
48470:   L_JSOP_ADDATTRVAL:
48470:   L_JSOP_ADDATTRNAME:
48470:   L_JSOP_TOATTRVAL:
48470:   L_JSOP_TOATTRNAME:
48470:   L_JSOP_QNAME:
48470:   L_JSOP_QNAMECONST:
48470:   L_JSOP_QNAMEPART:
48470:   L_JSOP_ANYNAME:
48470:   L_JSOP_DEFXMLNS:
48470: # endif
48470: 
48470: #endif /* !JS_THREADED_INTERP */
31481: #if !JS_THREADED_INTERP
    1:           default:
    1: #endif
    1:           {
    1:             char numBuf[12];
    1:             JS_snprintf(numBuf, sizeof numBuf, "%d", op);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_BYTECODE, numBuf);
11859:             goto error;
    1:           }
    1: 
    1: #if !JS_THREADED_INTERP
    1:         } /* switch (op) */
23111:     } /* for (;;) */
    1: #endif /* !JS_THREADED_INTERP */
    1: 
11859:   error:
69223:     JS_ASSERT(&cx->regs() == &regs);
39895: #ifdef JS_TRACER
69223:     if (regs.fp()->hasImacropc() && cx->isExceptionPending()) {
54736:         // Handle exceptions as if they came from the imacro-calling pc.
69223:         regs.pc = regs.fp()->imacropc();
69223:         regs.fp()->clearImacropc();
21685:     }
39895: #endif
21685: 
69223:     JS_ASSERT(size_t((regs.fp()->hasImacropc() ? regs.fp()->imacropc() : regs.pc) - script->code) <
51055:               script->length);
24245: 
27490: #ifdef JS_TRACER
24245:     /*
24245:      * This abort could be weakened to permit tracing through exceptions that
24245:      * are thrown and caught within a loop, with the co-operation of the tracer.
24245:      * For now just bail on any sign of trouble.
24245:      */
27490:     if (TRACE_RECORDER(cx))
37741:         AbortRecording(cx, "error or exception while recording");
56551: # ifdef JS_METHODJIT
56551:     if (TRACE_PROFILER(cx))
56551:         AbortProfiling(cx);
56551: # endif
27490: #endif
24245: 
60211:     if (!cx->isExceptionPending()) {
11859:         /* This is an error, not a catchable exception, quit the frame ASAP. */
48470:         interpReturnOK = JS_FALSE;
11859:     } else {
41863:         JSThrowHook handler;
 1825:         JSTryNote *tn, *tnlimit;
 1825:         uint32 offset;
 1825: 
59996:         /* Restore atoms local in case we will resume. */
59996:         atoms = script->atomMap.vector;
59996: 
11758:         /* Call debugger throw hook if set. */
 2433:         handler = cx->debugHooks->throwHook;
    1:         if (handler) {
48470:             Value rval;
48470:             switch (handler(cx, script, regs.pc, Jsvalify(&rval),
 2433:                             cx->debugHooks->throwHookData)) {
    1:               case JSTRAP_ERROR:
60211:                 cx->clearPendingException();
11859:                 goto error;
    1:               case JSTRAP_RETURN:
60211:                 cx->clearPendingException();
69223:                 regs.fp()->setReturnValue(rval);
48470:                 interpReturnOK = JS_TRUE;
11758:                 goto forced_return;
    1:               case JSTRAP_THROW:
60211:                 cx->setPendingException(rval);
    1:               case JSTRAP_CONTINUE:
    1:               default:;
    1:             }
23111:             CHECK_INTERRUPT_HANDLER();
    1:         }
    1: 
    1:         /*
    1:          * Look for a try block in script that can catch this exception.
    1:          */
59221:         if (!JSScript::isValidOffset(script->trynotesOffset))
 1825:             goto no_catch;
 1825: 
13168:         offset = (uint32)(regs.pc - script->main);
32723:         tn = script->trynotes()->vector;
32723:         tnlimit = tn + script->trynotes()->length;
 3025:         do {
 3025:             if (offset - tn->start >= tn->length)
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * We have a note that covers the exception pc but we must check
 3025:              * whether the interpreter has already executed the corresponding
 3025:              * handler. This is possible when the executed bytecode
 3025:              * implements break or return from inside a for-in loop.
 3025:              *
 3025:              * In this case the emitter generates additional [enditer] and
 3025:              * [gosub] opcodes to close all outstanding iterators and execute
 3025:              * the finally blocks. If such an [enditer] throws an exception,
 3025:              * its pc can still be inside several nested for-in loops and
 3025:              * try-finally statements even if we have already closed the
 3025:              * corresponding iterators and invoked the finally blocks.
 3025:              *
 3025:              * To address this, we make [enditer] always decrease the stack
 3025:              * even when its implementation throws an exception. Thus already
 3025:              * executed [enditer] and [gosub] opcodes will have try notes
 3025:              * with the stack depth exceeding the current one and this
 3025:              * condition is what we use to filter them out.
 3025:              */
69223:             if (tn->stackDepth > regs.sp - regs.fp()->base())
 3025:                 continue;
 3025: 
 3025:             /*
 3025:              * Set pc to the first bytecode after the the try note to point
 3025:              * to the beginning of catch or finally or to [enditer] closing
 3025:              * the for-in loop.
 1825:              */
13168:             regs.pc = (script)->main + tn->start + tn->length;
13168: 
48470:             JSBool ok = js_UnwindScope(cx, tn->stackDepth, JS_TRUE);
69223:             JS_ASSERT(regs.sp == regs.fp()->base() + tn->stackDepth);
11758:             if (!ok) {
11758:                 /*
11758:                  * Restart the handler search with updated pc and stack depth
11758:                  * to properly notify the debugger.
11758:                  */
11859:                 goto error;
11758:             }
 1825: 
 3025:             switch (tn->kind) {
20420:               case JSTRY_CATCH:
 3025: #if JS_HAS_GENERATORS
 3025:                 /* Catch cannot intercept the closing of a generator. */
60211:                   if (JS_UNLIKELY(cx->getPendingException().isMagic(JS_GENERATOR_CLOSING)))
 3025:                     break;
 3025: #endif
 3025: 
 1825:                 /*
60211:                  * Don't clear exceptions to save cx->exception from GC
 3025:                  * until it is pushed to the stack via [exception] in the
 3025:                  * catch block.
 3025:                  */
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
20420:               case JSTRY_FINALLY:
 3025:                 /*
 3025:                  * Push (true, exception) pair for finally to indicate that
 1825:                  * [retsub] should rethrow the exception.
 1825:                  */
48470:                 PUSH_BOOLEAN(true);
60211:                 PUSH_COPY(cx->getPendingException());
60211:                 cx->clearPendingException();
 3025:                 len = 0;
 3025:                 DO_NEXT_OP(len);
 3025: 
42641:               case JSTRY_ITER: {
42641:                 /* This is similar to JSOP_ENDITER in the interpreter loop. */
69223:                 JS_ASSERT(js_GetOpcode(cx, regs.fp()->script(), regs.pc) == JSOP_ENDITER);
60211:                 Value v = cx->getPendingException();
60211:                 cx->clearPendingException();
48470:                 ok = js_CloseIterator(cx, &regs.sp[-1].toObject());
42641:                 regs.sp -= 1;
11859:                 if (!ok)
11859:                     goto error;
60211:                 cx->setPendingException(v);
42641:               }
11859:            }
11859:         } while (++tn != tnlimit);
11859: 
11859:       no_catch:
 3025:         /*
11859:          * Propagate the exception or error to the caller unless the exception
11859:          * is an asynchronous return from a generator.
 3025:          */
48470:         interpReturnOK = JS_FALSE;
 1969: #if JS_HAS_GENERATORS
60211:         if (JS_UNLIKELY(cx->isExceptionPending() &&
60211:                         cx->getPendingException().isMagic(JS_GENERATOR_CLOSING))) {
60211:             cx->clearPendingException();
48470:             interpReturnOK = JS_TRUE;
69223:             regs.fp()->clearReturnValue();
 1969:         }
 1969: #endif
    1:     }
    1: 
11758:   forced_return:
    1:     /*
48470:      * Unwind the scope making sure that interpReturnOK stays false even when
48470:      * js_UnwindScope returns true.
11859:      *
48470:      * When a trap handler returns JSTRAP_RETURN, we jump here with
48470:      * interpReturnOK set to true bypassing any finally blocks.
    1:      */
60211:     interpReturnOK &= js_UnwindScope(cx, 0, interpReturnOK || cx->isExceptionPending());
69223:     JS_ASSERT(regs.sp == regs.fp()->base());
11758: 
69223:     if (entryFrame != regs.fp())
    1:         goto inline_return;
    1: 
11758:   exit:
69223:     interpReturnOK = ScriptEpilogueOrGeneratorYield(cx, regs.fp(), interpReturnOK);
69223:     regs.fp()->setFinishedInInterpreter();
56201: 
    1:     /*
11377:      * At this point we are inevitably leaving an interpreted function or a
11377:      * top-level script, and returning to one of:
11758:      * (a) an "out of line" call made through js_Invoke;
11758:      * (b) a js_Execute activation;
11758:      * (c) a generator (SendToGenerator, jsiter.c).
11758:      *
11859:      * We must not be in an inline frame. The check above ensures that for the
11859:      * error case and for a normal return, the code jumps directly to parent's
11859:      * frame pc.
    1:      */
69223:     JS_ASSERT(entryFrame == regs.fp());
42717: 
18181: #ifdef JS_TRACER
56201:     JS_ASSERT_IF(interpReturnOK && interpMode == JSINTERP_RECORD, !TRACE_RECORDER(cx));
19093:     if (TRACE_RECORDER(cx))
48470:         AbortRecording(cx, "recording out of Interpret");
56551: # ifdef JS_METHODJIT
56551:     if (TRACE_PROFILER(cx))
56551:         AbortProfiling(cx);
56551: # endif
18181: #endif
13168: 
73087:     JS_ASSERT_IF(!regs.fp()->isGeneratorFrame(),
73087:                  !js_IsActiveWithOrBlock(cx, &regs.fp()->scopeChain(), 0));
73087: 
73087: #ifdef JS_METHODJIT
56201:     /*
56201:      * This path is used when it's guaranteed the method can be finished
56201:      * inside the JIT.
56201:      */
56201:   leave_on_safe_point:
53145: #endif
73087: 
53133:     return interpReturnOK;
73087: 
73087:   atom_not_defined:
73087:     {
73087:         JSAutoByteString printable;
73087:         if (js_AtomToPrintableString(cx, atomNotDefined, &printable))
73087:             js_ReportIsNotDefined(cx, printable.ptr());
73087:     }
73087:     goto error;
11859: }
12551: 
48470: } /* namespace js */
48470: 
15996: #endif /* !defined jsinvoke_cpp___ */
