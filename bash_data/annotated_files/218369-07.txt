162892: // Stuff to link the old imp to the new api - will go away!
162892: 
165585: #include "CacheLog.h"
162892: #include "OldWrappers.h"
162892: #include "CacheStorage.h"
162892: #include "CacheStorageService.h"
162892: #include "LoadContextInfo.h"
201508: #include "nsCacheService.h"
162892: 
162892: #include "nsIURI.h"
162892: #include "nsICacheSession.h"
162892: #include "nsIApplicationCache.h"
162892: #include "nsIApplicationCacheService.h"
162892: #include "nsIStreamTransportService.h"
162892: #include "nsIFile.h"
162892: #include "nsICacheEntryDoomCallback.h"
162892: #include "nsICacheListener.h"
162892: #include "nsICacheStorageVisitor.h"
162892: 
162892: #include "nsServiceManagerUtils.h"
162892: #include "nsNetCID.h"
201508: #include "nsNetUtil.h"
162892: #include "nsProxyRelease.h"
163612: #include "mozilla/Telemetry.h"
162892: 
162892: static NS_DEFINE_CID(kStreamTransportServiceCID,
162892:                      NS_STREAMTRANSPORTSERVICE_CID);
162892: 
172237: static uint32_t const CHECK_MULTITHREADED = nsICacheStorage::CHECK_MULTITHREADED;
172237: 
162892: namespace mozilla {
162892: namespace net {
162892: 
162892: namespace { // anon
162892: 
162892: // Fires the doom callback back on the main thread
162892: // after the cache I/O thread is looped.
162892: 
162892: class DoomCallbackSynchronizer : public nsRunnable
162892: {
162892: public:
162892:   DoomCallbackSynchronizer(nsICacheEntryDoomCallback* cb) : mCB(cb)
162892:   {
162892:     MOZ_COUNT_CTOR(DoomCallbackSynchronizer);
162892:   }
162892:   nsresult Dispatch();
162892: 
162892: private:
162892:   virtual ~DoomCallbackSynchronizer()
162892:   {
162892:     MOZ_COUNT_DTOR(DoomCallbackSynchronizer);
162892:   }
162892: 
162892:   NS_DECL_NSIRUNNABLE
162892:   nsCOMPtr<nsICacheEntryDoomCallback> mCB;
162892: };
162892: 
162892: nsresult DoomCallbackSynchronizer::Dispatch()
162892: {
162892:   nsresult rv;
162892: 
162892:   nsCOMPtr<nsICacheService> serv =
162892:       do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   nsCOMPtr<nsIEventTarget> eventTarget;
162892:   rv = serv->GetCacheIOTarget(getter_AddRefs(eventTarget));
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   rv = eventTarget->Dispatch(this, NS_DISPATCH_NORMAL);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   return NS_OK;
162892: }
162892: 
162892: NS_IMETHODIMP DoomCallbackSynchronizer::Run()
162892: {
162892:   if (!NS_IsMainThread()) {
162892:     NS_DispatchToMainThread(this);
162892:   }
162892:   else {
162892:     if (mCB)
162892:       mCB->OnCacheEntryDoomed(NS_OK);
162892:   }
162892:   return NS_OK;
162892: }
162892: 
162892: // Receives doom callback from the old API and forwards to the new API
162892: 
162892: class DoomCallbackWrapper : public nsICacheListener
162892: {
162892:   NS_DECL_THREADSAFE_ISUPPORTS
162892:   NS_DECL_NSICACHELISTENER
162892: 
162892:   DoomCallbackWrapper(nsICacheEntryDoomCallback* cb) : mCB(cb)
162892:   {
162892:     MOZ_COUNT_CTOR(DoomCallbackWrapper);
162892:   }
162892: 
162892: private:
162892:   virtual ~DoomCallbackWrapper()
162892:   {
162892:     MOZ_COUNT_DTOR(DoomCallbackWrapper);
162892:   }
162892: 
162892:   nsCOMPtr<nsICacheEntryDoomCallback> mCB;
162892: };
162892: 
200047: NS_IMPL_ISUPPORTS(DoomCallbackWrapper, nsICacheListener);
162892: 
162892: NS_IMETHODIMP DoomCallbackWrapper::OnCacheEntryAvailable(nsICacheEntryDescriptor *descriptor,
162892:                                                          nsCacheAccessMode accessGranted,
162892:                                                          nsresult status)
162892: {
162892:   return NS_OK;
162892: }
162892: 
162892: NS_IMETHODIMP DoomCallbackWrapper::OnCacheEntryDoomed(nsresult status)
162892: {
162892:   if (!mCB)
162892:     return NS_ERROR_NULL_POINTER;
162892: 
162892:   mCB->OnCacheEntryDoomed(status);
162892:   mCB = nullptr;
162892:   return NS_OK;
162892: }
162892: 
201508: } // anon
201508: 
201508: // _OldVisitCallbackWrapper
162892: // Receives visit callbacks from the old API and forwards it to the new API
162892: 
201508: NS_IMPL_ISUPPORTS(_OldVisitCallbackWrapper, nsICacheVisitor)
201508: 
201508: _OldVisitCallbackWrapper::~_OldVisitCallbackWrapper()
201362: {
201508:   if (!mHit) {
201508:     // The device has not been found, to not break the chain, simulate
201508:     // storage info callback.
201508:     mCB->OnCacheStorageInfo(0, 0, 0, nullptr);
162892:   }
162892: 
201508:   if (mVisitEntries) {
162892:     mCB->OnCacheEntryVisitCompleted();
162892:   }
162892: 
201508:   MOZ_COUNT_DTOR(_OldVisitCallbackWrapper);
201508: }
201508: 
201508: NS_IMETHODIMP _OldVisitCallbackWrapper::VisitDevice(const char * deviceID,
162892:                                                     nsICacheDeviceInfo *deviceInfo,
162892:                                                     bool *_retval)
162892: {
162892:   if (!mCB)
162892:     return NS_ERROR_NULL_POINTER;
162892: 
162892:   *_retval = false;
162892:   if (strcmp(deviceID, mDeviceID)) {
162892:     // Not the device we want to visit
162892:     return NS_OK;
162892:   }
162892: 
201508:   mHit = true;
201508: 
162892:   nsresult rv;
162892: 
201508:   uint32_t capacity;
201508:   rv = deviceInfo->GetMaximumSize(&capacity);
201508:   NS_ENSURE_SUCCESS(rv, rv);
201508: 
201508:   nsCOMPtr<nsIFile> dir;
201508:   if (!strcmp(mDeviceID, "disk")) {
201508:     nsCacheService::GetDiskCacheDirectory(getter_AddRefs(dir));
201508:   } else if (!strcmp(mDeviceID, "offline")) {
201508:     nsCacheService::GetAppCacheDirectory(getter_AddRefs(dir));
201508:   }
201508: 
201508:   if (mLoadInfo->IsAnonymous()) {
201508:     // Anonymous visiting reports 0, 0 since we cannot count that
201508:     // early the number of anon entries.
201508:     mCB->OnCacheStorageInfo(0, 0, capacity, dir);
201508:   } else {
201508:     // Non-anon visitor counts all non-anon + ALL ANON entries,
201508:     // there is no way to determine the number of entries when
201508:     // using the old cache APIs - there is no concept of anonymous
201508:     // storage.
162892:     uint32_t entryCount;
162892:     rv = deviceInfo->GetEntryCount(&entryCount);
162892:     NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:     uint32_t totalSize;
162892:     rv = deviceInfo->GetTotalSize(&totalSize);
162892:     NS_ENSURE_SUCCESS(rv, rv);
162892: 
201508:     mCB->OnCacheStorageInfo(entryCount, totalSize, capacity, dir);
201508:   }
201508: 
201362:   *_retval = mVisitEntries;
162892:   return NS_OK;
162892: }
162892: 
201508: NS_IMETHODIMP _OldVisitCallbackWrapper::VisitEntry(const char * deviceID,
162892:                                                    nsICacheEntryInfo *entryInfo,
162892:                                                    bool *_retval)
162892: {
162892:   MOZ_ASSERT(!strcmp(deviceID, mDeviceID));
162892: 
201508:   nsresult rv;
162892: 
201508:   *_retval = true;
201508: 
201508:   // Read all informative properties from the entry.
201508:   nsXPIDLCString clientId;
201508:   rv = entryInfo->GetClientID(getter_Copies(clientId));
201508:   if (NS_FAILED(rv))
201508:     return NS_OK;
201508: 
201508:   if (mLoadInfo->IsPrivate() !=
201508:       StringBeginsWith(clientId, NS_LITERAL_CSTRING("HTTP-memory-only-PB"))) {
162892:     return NS_OK;
162892:   }
162892: 
201508:   nsAutoCString cacheKey, enhanceId;
201508:   rv = entryInfo->GetKey(cacheKey);
201508:   if (NS_FAILED(rv))
201508:     return NS_OK;
162892: 
201508:   if (StringBeginsWith(cacheKey, NS_LITERAL_CSTRING("anon&"))) {
201508:     if (!mLoadInfo->IsAnonymous())
201508:       return NS_OK;
201508: 
201508:     cacheKey = Substring(cacheKey, 5, cacheKey.Length());
201508:   } else if (mLoadInfo->IsAnonymous()) {
201508:     return NS_OK;
201508:   }
201508: 
201508:   if (StringBeginsWith(cacheKey, NS_LITERAL_CSTRING("id="))) {
201508:     int32_t uriSpecEnd = cacheKey.Find("&uri=");
201508:     if (uriSpecEnd == kNotFound) // Corrupted, ignore
201508:       return NS_OK;
201508: 
201508:     enhanceId = Substring(cacheKey, 3, uriSpecEnd - 3);
201508:     cacheKey = Substring(cacheKey, uriSpecEnd + 1, cacheKey.Length());
201508:   }
201508: 
201508:   if (StringBeginsWith(cacheKey, NS_LITERAL_CSTRING("uri="))) {
201508:     cacheKey = Substring(cacheKey, 4, cacheKey.Length());
201508:   }
201508: 
201508:   nsCOMPtr<nsIURI> uri;
201508:   // cacheKey is strip of any prefixes
201508:   rv = NS_NewURI(getter_AddRefs(uri), cacheKey);
201508:   if (NS_FAILED(rv))
201508:     return NS_OK;
201508: 
201508:   uint32_t dataSize;
201508:   if (NS_FAILED(entryInfo->GetDataSize(&dataSize)))
201508:     dataSize = 0;
201508:   int32_t fetchCount;
201508:   if (NS_FAILED(entryInfo->GetFetchCount(&fetchCount)))
201508:     fetchCount = 0;
201508:   uint32_t expirationTime;
201508:   if (NS_FAILED(entryInfo->GetExpirationTime(&expirationTime)))
201508:     expirationTime = 0;
201508:   uint32_t lastModified;
201508:   if (NS_FAILED(entryInfo->GetLastModified(&lastModified)))
201508:     lastModified = 0;
201508: 
201508:   // Send them to the consumer.
201508:   rv = mCB->OnCacheEntryInfo(
201508:     uri, enhanceId, (int64_t)dataSize, fetchCount, lastModified, expirationTime);
201508: 
201508:   *_retval = NS_SUCCEEDED(rv);
201508:   return NS_OK;
201508: }
162892: 
199617: // _OldGetDiskConsumption
199617: 
199617: //static
199617: nsresult _OldGetDiskConsumption::Get(nsICacheStorageConsumptionObserver* aCallback)
199617: {
199617:   nsresult rv;
199617: 
199617:   nsCOMPtr<nsICacheService> serv =
199617:       do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
199617:   NS_ENSURE_SUCCESS(rv, rv);
199617: 
199617:   nsRefPtr<_OldGetDiskConsumption> cb = new _OldGetDiskConsumption(aCallback);
199617: 
199617:   // _OldGetDiskConsumption stores the found size value, but until dispatched
199617:   // to the main thread it doesn't call on the consupmtion observer. See bellow.
199617:   rv = serv->VisitEntries(cb);
199617:   NS_ENSURE_SUCCESS(rv, rv);
199617: 
199617:   // We are called from CacheStorageService::AsyncGetDiskConsumption whose IDL
199617:   // documentation claims the callback is always delievered asynchronously
199617:   // back to the main thread.  Despite we know the result synchronosusly when
199617:   // querying the old cache, we need to stand the word and dispatch the result
199617:   // to the main thread asynchronously.  Hence the dispatch here.
199617:   return NS_DispatchToMainThread(cb);
199617: }
199617: 
200047: NS_IMPL_ISUPPORTS_INHERITED(_OldGetDiskConsumption,
199617:                             nsRunnable,
199617:                             nsICacheVisitor)
199617: 
199617: _OldGetDiskConsumption::_OldGetDiskConsumption(
199617:   nsICacheStorageConsumptionObserver* aCallback)
199617:   : mCallback(aCallback)
199617:   , mSize(0)
199617: {
199617: }
199617: 
199617: NS_IMETHODIMP
199617: _OldGetDiskConsumption::Run()
199617: {
199617:   mCallback->OnNetworkCacheDiskConsumption(mSize);
199617:   return NS_OK;
199617: }
199617: 
199617: NS_IMETHODIMP
199617: _OldGetDiskConsumption::VisitDevice(const char * deviceID,
199617:                                     nsICacheDeviceInfo *deviceInfo,
199617:                                     bool *_retval)
199617: {
199617:   if (!strcmp(deviceID, "disk")) {
199617:     uint32_t size;
199617:     nsresult rv = deviceInfo->GetTotalSize(&size);
199617:     if (NS_SUCCEEDED(rv))
199617:       mSize = (int64_t)size;
199617:   }
199617: 
199617:   *_retval = false;
199617:   return NS_OK;
199617: }
199617: 
199617: NS_IMETHODIMP
199617: _OldGetDiskConsumption::VisitEntry(const char * deviceID,
199617:                                    nsICacheEntryInfo *entryInfo,
199617:                                    bool *_retval)
199617: {
199617:   MOZ_CRASH("Unexpected");
199617:   return NS_OK;
199617: }
199617: 
199617: 
162892: // _OldCacheEntryWrapper
162892: 
162892: _OldCacheEntryWrapper::_OldCacheEntryWrapper(nsICacheEntryDescriptor* desc)
162892: : mOldDesc(desc), mOldInfo(desc)
162892: {
162892:   MOZ_COUNT_CTOR(_OldCacheEntryWrapper);
162892:   LOG(("Creating _OldCacheEntryWrapper %p for descriptor %p", this, desc));
162892: }
162892: 
162892: _OldCacheEntryWrapper::_OldCacheEntryWrapper(nsICacheEntryInfo* info)
164796: : mOldDesc(nullptr), mOldInfo(info)
162892: {
162892:   MOZ_COUNT_CTOR(_OldCacheEntryWrapper);
162892:   LOG(("Creating _OldCacheEntryWrapper %p for info %p", this, info));
162892: }
162892: 
162892: _OldCacheEntryWrapper::~_OldCacheEntryWrapper()
162892: {
162892:   MOZ_COUNT_DTOR(_OldCacheEntryWrapper);
162892:   LOG(("Destroying _OldCacheEntryWrapper %p for descriptor %p", this, mOldInfo.get()));
162892: }
162892: 
200047: NS_IMPL_ISUPPORTS(_OldCacheEntryWrapper, nsICacheEntry)
162892: 
162892: NS_IMETHODIMP _OldCacheEntryWrapper::AsyncDoom(nsICacheEntryDoomCallback* listener)
162892: {
162892:   nsRefPtr<DoomCallbackWrapper> cb = listener
162892:     ? new DoomCallbackWrapper(listener)
162892:     : nullptr;
162892:   return AsyncDoom(cb);
162892: }
162892: 
162892: NS_IMETHODIMP _OldCacheEntryWrapper::GetDataSize(int64_t *aSize)
162892: {
162892:   uint32_t size;
162892:   nsresult rv = GetDataSize(&size);
162892:   if (NS_FAILED(rv))
162892:     return rv;
162892: 
162892:   *aSize = size;
162892:   return NS_OK;
162892: }
162892: 
184910: NS_IMETHODIMP _OldCacheEntryWrapper::GetPersistent(bool *aPersistToDisk)
162892: {
162892:   if (!mOldDesc) {
162892:     return NS_ERROR_NULL_POINTER;
162892:   }
162892: 
162892:   nsresult rv;
162892: 
162892:   nsCacheStoragePolicy policy;
162892:   rv = mOldDesc->GetStoragePolicy(&policy);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   *aPersistToDisk = policy != nsICache::STORE_IN_MEMORY;
162892: 
162892:   return NS_OK;
162892: }
162892: 
184910: NS_IMETHODIMP _OldCacheEntryWrapper::Recreate(bool aMemoryOnly,
184910:                                               nsICacheEntry** aResult)
162892: {
162892:   NS_ENSURE_TRUE(mOldDesc, NS_ERROR_NOT_AVAILABLE);
162892: 
162892:   nsCacheAccessMode mode;
162892:   nsresult rv = mOldDesc->GetAccessGranted(&mode);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   if (!(mode & nsICache::ACCESS_WRITE))
162892:     return NS_ERROR_NOT_AVAILABLE;
162892: 
162892:   LOG(("_OldCacheEntryWrapper::Recreate [this=%p]", this));
162892: 
184910:   if (aMemoryOnly)
184910:     mOldDesc->SetStoragePolicy(nsICache::STORE_IN_MEMORY);
184910: 
162892:   nsCOMPtr<nsICacheEntry> self(this);
162892:   self.forget(aResult);
162892:   return NS_OK;
162892: }
162892: 
162892: NS_IMETHODIMP _OldCacheEntryWrapper::OpenInputStream(int64_t offset,
162892:                                                      nsIInputStream * *_retval)
162892: {
162892:   if (offset > PR_UINT32_MAX)
162892:     return NS_ERROR_INVALID_ARG;
162892: 
162892:   return OpenInputStream(uint32_t(offset), _retval);
162892: }
162892: NS_IMETHODIMP _OldCacheEntryWrapper::OpenOutputStream(int64_t offset,
162892:                                                       nsIOutputStream * *_retval)
162892: {
162892:   if (offset > PR_UINT32_MAX)
162892:     return NS_ERROR_INVALID_ARG;
162892: 
162892:   return OpenOutputStream(uint32_t(offset), _retval);
162892: }
162892: 
162892: NS_IMETHODIMP _OldCacheEntryWrapper::MaybeMarkValid()
162892: {
162892:   LOG(("_OldCacheEntryWrapper::MaybeMarkValid [this=%p]", this));
162892: 
162892:   NS_ENSURE_TRUE(mOldDesc, NS_ERROR_NULL_POINTER);
162892: 
162892:   nsCacheAccessMode mode;
162892:   nsresult rv = mOldDesc->GetAccessGranted(&mode);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   if (mode & nsICache::ACCESS_WRITE) {
162892:     LOG(("Marking cache entry valid [entry=%p, descr=%p]", this, mOldDesc));
162892:     return mOldDesc->MarkValid();
162892:   }
162892: 
162892:   LOG(("Not marking read-only cache entry valid [entry=%p, descr=%p]", this, mOldDesc));
162892:   return NS_OK;
162892: }
162892: 
162892: NS_IMETHODIMP _OldCacheEntryWrapper::HasWriteAccess(bool aWriteAllowed_unused, bool *aWriteAccess)
162892: {
162892:   NS_ENSURE_TRUE(mOldDesc, NS_ERROR_NULL_POINTER);
162892:   NS_ENSURE_ARG(aWriteAccess);
162892: 
162892:   nsCacheAccessMode mode;
162892:   nsresult rv = mOldDesc->GetAccessGranted(&mode);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   *aWriteAccess = !!(mode & nsICache::ACCESS_WRITE);
162892: 
162892:   LOG(("_OldCacheEntryWrapper::HasWriteAccess [this=%p, write-access=%d]", this, *aWriteAccess));
162892: 
162892:   return NS_OK;
162892: }
162892: 
201508: namespace { // anon
201508: 
201508: class MetaDataVisitorWrapper : public nsICacheMetaDataVisitor
201508: {
212458:   virtual ~MetaDataVisitorWrapper() {}
212458: 
201508:   NS_DECL_ISUPPORTS
201508:   NS_DECL_NSICACHEMETADATAVISITOR
201508:   MetaDataVisitorWrapper(nsICacheEntryMetaDataVisitor* cb) : mCB(cb) {}
201508:   nsCOMPtr<nsICacheEntryMetaDataVisitor> mCB;
201508: };
201508: 
201508: NS_IMPL_ISUPPORTS(MetaDataVisitorWrapper, nsICacheMetaDataVisitor)
201508: 
201508: NS_IMETHODIMP
201508: MetaDataVisitorWrapper::VisitMetaDataElement(char const * key,
201508:                                              char const * value,
201508:                                              bool *goon)
201508: {
201508:   *goon = true;
201508:   return mCB->OnMetaDataElement(key, value);
201508: }
201508: 
201508: } // anon
201508: 
201508: NS_IMETHODIMP _OldCacheEntryWrapper::VisitMetaData(nsICacheEntryMetaDataVisitor* cb)
201508: {
201508:   nsRefPtr<MetaDataVisitorWrapper> w = new MetaDataVisitorWrapper(cb);
201508:   return mOldDesc->VisitMetaData(w);
201508: }
162892: 
162892: namespace { // anon
162892: 
172236: nsresult
162892: GetCacheSessionNameForStoragePolicy(
172236:         nsCSubstring const &scheme,
162892:         nsCacheStoragePolicy storagePolicy,
162892:         bool isPrivate,
162892:         uint32_t appId,
162892:         bool inBrowser,
162892:         nsACString& sessionName)
162892: {
162892:   MOZ_ASSERT(!isPrivate || storagePolicy == nsICache::STORE_IN_MEMORY);
162892: 
172236:   // HTTP
204656:   if (scheme.EqualsLiteral("http") ||
204656:       scheme.EqualsLiteral("https")) {
162892:     switch (storagePolicy) {
162892:     case nsICache::STORE_IN_MEMORY:
172236:       if (isPrivate)
204661:         sessionName.AssignLiteral("HTTP-memory-only-PB");
172236:       else
204661:         sessionName.AssignLiteral("HTTP-memory-only");
162892:       break;
162892:     case nsICache::STORE_OFFLINE:
172236:       // XXX This is actually never used, only added to prevent
172236:       // any compatibility damage.
204661:       sessionName.AssignLiteral("HTTP-offline");
162892:       break;
162892:     default:
204661:       sessionName.AssignLiteral("HTTP");
162892:       break;
162892:     }
172236:   }
172236:   // WYCIWYG
204656:   else if (scheme.EqualsLiteral("wyciwyg")) {
172236:     if (isPrivate)
204661:       sessionName.AssignLiteral("wyciwyg-private");
172236:     else
204661:       sessionName.AssignLiteral("wyciwyg");
172236:   }
172236:   // FTP
204656:   else if (scheme.EqualsLiteral("ftp")) {
172236:     if (isPrivate)
204661:       sessionName.AssignLiteral("FTP-private");
172236:     else
204661:       sessionName.AssignLiteral("FTP");
172236:   }
172236:   // all remaining URL scheme
172236:   else {
172236:     // Since with the new API a consumer cannot specify its own session name
172236:     // and partitioning of the cache is handled stricly only by the cache
172236:     // back-end internally, we will use a separate session name to pretend
172236:     // functionality of the new API wrapping the Darin's cache for all other
172236:     // URL schemes.
172236:     // Deliberately omitting |anonymous| since other session types don't
172236:     // recognize it too.
204661:     sessionName.AssignLiteral("other");
172236:     if (isPrivate)
204654:       sessionName.AppendLiteral("-private");
172236:   }
172236: 
162892:   if (appId != nsILoadContextInfo::NO_APP_ID || inBrowser) {
162892:     sessionName.Append('~');
162892:     sessionName.AppendInt(appId);
162892:     sessionName.Append('~');
162892:     sessionName.AppendInt(inBrowser);
162892:   }
172236: 
172236:   return NS_OK;
162892: }
162892: 
162892: nsresult
172236: GetCacheSession(nsCSubstring const &aScheme,
172236:                 bool aWriteToDisk,
162892:                 nsILoadContextInfo* aLoadInfo,
162892:                 nsIApplicationCache* aAppCache,
162892:                 nsICacheSession** _result)
162892: {
162892:   nsresult rv;
162892: 
162892:   nsCacheStoragePolicy storagePolicy;
162892:   if (aAppCache)
162892:     storagePolicy = nsICache::STORE_OFFLINE;
162892:   else if (!aWriteToDisk || aLoadInfo->IsPrivate())
162892:     storagePolicy = nsICache::STORE_IN_MEMORY;
162892:   else
162892:     storagePolicy = nsICache::STORE_ANYWHERE;
162892: 
162892:   nsAutoCString clientId;
162892:   if (aAppCache) {
162892:     aAppCache->GetClientID(clientId);
162892:   }
162892:   else {
172236:     rv = GetCacheSessionNameForStoragePolicy(
172236:       aScheme,
162892:       storagePolicy,
162892:       aLoadInfo->IsPrivate(),
162892:       aLoadInfo->AppId(),
162892:       aLoadInfo->IsInBrowserElement(),
162892:       clientId);
172236:     NS_ENSURE_SUCCESS(rv, rv);
162892:   }
162892: 
162892:   LOG(("  GetCacheSession for client=%s, policy=%d", clientId.get(), storagePolicy));
162892: 
162892:   nsCOMPtr<nsICacheService> serv =
162892:       do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   nsCOMPtr<nsICacheSession> session;
207178:   rv = nsCacheService::GlobalInstance()->CreateSessionInternal(clientId.get(),
162892:                                                                storagePolicy,
162892:                                                                nsICache::STREAM_BASED,
162892:                                                                getter_AddRefs(session));
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   rv = session->SetIsPrivate(aLoadInfo->IsPrivate());
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   rv = session->SetDoomEntriesIfExpired(false);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   if (aAppCache) {
162892:     nsCOMPtr<nsIFile> profileDirectory;
162892:     aAppCache->GetProfileDirectory(getter_AddRefs(profileDirectory));
162892:     if (profileDirectory)
162892:       rv = session->SetProfileDirectory(profileDirectory);
162892:     NS_ENSURE_SUCCESS(rv, rv);
162892:   }
162892: 
162892:   session.forget(_result);
162892:   return NS_OK;
162892: }
162892: 
162892: } // anon
162892: 
162892: 
200047: NS_IMPL_ISUPPORTS_INHERITED(_OldCacheLoad, nsRunnable, nsICacheListener)
162892: 
172236: _OldCacheLoad::_OldCacheLoad(nsCSubstring const& aScheme,
172236:                              nsCSubstring const& aCacheKey,
162892:                              nsICacheEntryOpenCallback* aCallback,
162892:                              nsIApplicationCache* aAppCache,
162892:                              nsILoadContextInfo* aLoadInfo,
162892:                              bool aWriteToDisk,
162892:                              uint32_t aFlags)
172236:   : mScheme(aScheme)
172236:   , mCacheKey(aCacheKey)
162892:   , mCallback(aCallback)
162892:   , mLoadInfo(GetLoadContextInfo(aLoadInfo))
162892:   , mFlags(aFlags)
162892:   , mWriteToDisk(aWriteToDisk)
162892:   , mNew(true)
172237:   , mOpening(true)
172237:   , mSync(false)
162892:   , mStatus(NS_ERROR_UNEXPECTED)
162892:   , mRunCount(0)
162892:   , mAppCache(aAppCache)
162892: {
162892:   MOZ_COUNT_CTOR(_OldCacheLoad);
162892: }
162892: 
162892: _OldCacheLoad::~_OldCacheLoad()
162892: {
162892:   ProxyReleaseMainThread(mAppCache);
162892:   MOZ_COUNT_DTOR(_OldCacheLoad);
162892: }
162892: 
162892: nsresult _OldCacheLoad::Start()
162892: {
162892:   LOG(("_OldCacheLoad::Start [this=%p, key=%s]", this, mCacheKey.get()));
162892: 
163612:   mLoadStart = mozilla::TimeStamp::Now();
163612: 
172237:   nsresult rv;
162892: 
172237:   // Consumers that can invoke this code as first and off the main thread
172237:   // are responsible for initiating these two services on the main thread.
172237:   // Currently this is only nsWyciwygChannel.
162892: 
162892:   // XXX: Start the cache service; otherwise DispatchToCacheIOThread will
162892:   // fail.
162892:   nsCOMPtr<nsICacheService> service =
162892:     do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
162892: 
162892:   // Ensure the stream transport service gets initialized on the main thread
172237:   if (NS_SUCCEEDED(rv) && NS_IsMainThread()) {
162892:     nsCOMPtr<nsIStreamTransportService> sts =
162892:       do_GetService(kStreamTransportServiceCID, &rv);
162892:   }
162892: 
162892:   if (NS_SUCCEEDED(rv)) {
162892:     rv = service->GetCacheIOTarget(getter_AddRefs(mCacheThread));
162892:   }
162892: 
162892:   if (NS_SUCCEEDED(rv)) {
172237:     bool onCacheTarget;
172237:     rv = mCacheThread->IsOnCurrentThread(&onCacheTarget);
172237:     if (NS_SUCCEEDED(rv) && onCacheTarget) {
172237:       mSync = true;
172237:     }
172237:   }
172237: 
172237:   if (NS_SUCCEEDED(rv)) {
172237:     if (mSync) {
172237:       rv = Run();
172237:     }
172237:     else {
162892:       rv = mCacheThread->Dispatch(this, NS_DISPATCH_NORMAL);
162892:     }
172237:   }
162892: 
162892:   return rv;
162892: }
162892: 
162892: NS_IMETHODIMP
162892: _OldCacheLoad::Run()
162892: {
162892:   LOG(("_OldCacheLoad::Run [this=%p, key=%s, cb=%p]", this, mCacheKey.get(), mCallback.get()));
162892: 
162892:   nsresult rv;
162892: 
172237:   if (mOpening) {
172237:     mOpening = false;
162892:     nsCOMPtr<nsICacheSession> session;
172236:     rv = GetCacheSession(mScheme, mWriteToDisk, mLoadInfo, mAppCache,
172236:                          getter_AddRefs(session));
162892:     if (NS_SUCCEEDED(rv)) {
162892:       // AsyncOpenCacheEntry isn't really async when its called on the
162892:       // cache service thread.
162892: 
162892:       nsCacheAccessMode cacheAccess;
162892:       if (mFlags & nsICacheStorage::OPEN_TRUNCATE)
162892:         cacheAccess = nsICache::ACCESS_WRITE;
162892:       else if ((mFlags & nsICacheStorage::OPEN_READONLY) || mAppCache)
162892:         cacheAccess = nsICache::ACCESS_READ;
162892:       else
162892:         cacheAccess = nsICache::ACCESS_READ_WRITE;
162892: 
162892:       LOG(("  session->AsyncOpenCacheEntry with access=%d", cacheAccess));
162892: 
162892:       bool bypassBusy = mFlags & nsICacheStorage::OPEN_BYPASS_IF_BUSY;
172237: 
172237:       if (mSync && cacheAccess == nsICache::ACCESS_WRITE) {
172237:         nsCOMPtr<nsICacheEntryDescriptor> entry;
172237:         rv = session->OpenCacheEntry(mCacheKey, cacheAccess, bypassBusy,
172237:           getter_AddRefs(entry));
172237: 
172237:         nsCacheAccessMode grantedAccess = 0;
172237:         if (NS_SUCCEEDED(rv)) {
172237:           entry->GetAccessGranted(&grantedAccess);
172237:         }
172237: 
172237:         return OnCacheEntryAvailable(entry, grantedAccess, rv);
172237:       }
172237: 
162892:       rv = session->AsyncOpenCacheEntry(mCacheKey, cacheAccess, this, bypassBusy);
162892:       if (NS_SUCCEEDED(rv))
162892:         return NS_OK;
162892:     }
162892: 
162892:     // Opening failed, propagate the error to the consumer
162892:     LOG(("  Opening cache entry failed with rv=0x%08x", rv));
162892:     mStatus = rv;
162892:     mNew = false;
162892:     NS_DispatchToMainThread(this);
162892:   } else {
162892:     if (!mCallback) {
162892:       LOG(("  duplicate call, bypassed"));
162892:       return NS_OK;
162892:     }
162892: 
163612:     if (NS_SUCCEEDED(mStatus)) {
163612:       if (mFlags & nsICacheStorage::OPEN_TRUNCATE) {
163612:         mozilla::Telemetry::AccumulateTimeDelta(
163612:           mozilla::Telemetry::NETWORK_CACHE_V1_TRUNCATE_TIME_MS,
163612:           mLoadStart);
163612:       }
163612:       else if (mNew) {
163612:         mozilla::Telemetry::AccumulateTimeDelta(
163612:           mozilla::Telemetry::NETWORK_CACHE_V1_MISS_TIME_MS,
163612:           mLoadStart);
163612:       }
163612:       else {
163612:         mozilla::Telemetry::AccumulateTimeDelta(
163612:           mozilla::Telemetry::NETWORK_CACHE_V1_HIT_TIME_MS,
163612:           mLoadStart);
163612:       }
163612:     }
163612: 
172237:     if (!(mFlags & CHECK_MULTITHREADED))
162892:       Check();
162892: 
162892:     // break cycles
162892:     nsCOMPtr<nsICacheEntryOpenCallback> cb = mCallback.forget();
162892:     mCacheThread = nullptr;
162892:     nsCOMPtr<nsICacheEntry> entry = mCacheEntry.forget();
162892: 
162892:     rv = cb->OnCacheEntryAvailable(entry, mNew, mAppCache, mStatus);
162892: 
162892:     if (NS_FAILED(rv) && entry) {
162892:       LOG(("  cb->OnCacheEntryAvailable failed with rv=0x%08x", rv));
162892:       if (mNew)
162892:         entry->AsyncDoom(nullptr);
162892:       else
162892:         entry->Close();
162892:     }
162892:   }
162892: 
162892:   return rv;
162892: }
162892: 
162892: NS_IMETHODIMP
162892: _OldCacheLoad::OnCacheEntryAvailable(nsICacheEntryDescriptor *entry,
162892:                                      nsCacheAccessMode access,
162892:                                      nsresult status)
162892: {
162892:   LOG(("_OldCacheLoad::OnCacheEntryAvailable [this=%p, ent=%p, cb=%p, appcache=%p, access=%x]",
162892:     this, entry, mCallback.get(), mAppCache.get(), access));
162892: 
162892:   // XXX Bug 759805: Sometimes we will call this method directly from
162892:   // HttpCacheQuery::Run when AsyncOpenCacheEntry fails, but
162892:   // AsyncOpenCacheEntry will also call this method. As a workaround, we just
162892:   // ensure we only execute this code once.
162892:   NS_ENSURE_TRUE(mRunCount == 0, NS_ERROR_UNEXPECTED);
162892:   ++mRunCount;
162892: 
162892:   mCacheEntry = entry ? new _OldCacheEntryWrapper(entry) : nullptr;
162892:   mStatus = status;
162892:   mNew = access == nsICache::ACCESS_WRITE;
162892: 
172237:   if (mFlags & CHECK_MULTITHREADED)
162892:     Check();
162892: 
172237:   if (mSync)
172237:     return Run();
172237: 
162892:   return NS_DispatchToMainThread(this);
162892: }
162892: 
162892: void
162892: _OldCacheLoad::Check()
162892: {
162892:   if (!mCacheEntry)
162892:     return;
162892: 
162892:   if (mNew)
162892:     return;
162892: 
162892:   uint32_t result;
162892:   nsresult rv = mCallback->OnCacheEntryCheck(mCacheEntry, mAppCache, &result);
162892:   LOG(("  OnCacheEntryCheck result ent=%p, cb=%p, appcache=%p, rv=0x%08x, result=%d",
162892:     mCacheEntry.get(), mCallback.get(), mAppCache.get(), rv, result));
162892: 
162892:   if (NS_FAILED(rv)) {
162892:     NS_WARNING("cache check failed");
162892:   }
162892: 
193514:   if (NS_FAILED(rv) || result == nsICacheEntryOpenCallback::ENTRY_NOT_WANTED) {
162892:     mCacheEntry->Close();
162892:     mCacheEntry = nullptr;
162892:     mStatus = NS_ERROR_CACHE_KEY_NOT_FOUND;
162892:   }
162892: }
162892: 
162892: NS_IMETHODIMP
162892: _OldCacheLoad::OnCacheEntryDoomed(nsresult)
162892: {
162892:   return NS_ERROR_NOT_IMPLEMENTED;
162892: }
162892: 
162892: // nsICacheStorage old cache wrapper
162892: 
200047: NS_IMPL_ISUPPORTS(_OldStorage, nsICacheStorage)
162892: 
162892: _OldStorage::_OldStorage(nsILoadContextInfo* aInfo,
162892:                          bool aAllowDisk,
162892:                          bool aLookupAppCache,
162892:                          bool aOfflineStorage,
162892:                          nsIApplicationCache* aAppCache)
162892: : mLoadInfo(GetLoadContextInfo(aInfo))
162892: , mAppCache(aAppCache)
162892: , mWriteToDisk(aAllowDisk)
162892: , mLookupAppCache(aLookupAppCache)
162892: , mOfflineStorage(aOfflineStorage)
162892: {
162892:   MOZ_COUNT_CTOR(_OldStorage);
162892: }
162892: 
162892: _OldStorage::~_OldStorage()
162892: {
162892:   MOZ_COUNT_DTOR(_OldStorage);
162892: }
162892: 
162892: NS_IMETHODIMP _OldStorage::AsyncOpenURI(nsIURI *aURI,
162892:                                         const nsACString & aIdExtension,
162892:                                         uint32_t aFlags,
162892:                                         nsICacheEntryOpenCallback *aCallback)
162892: {
162892:   NS_ENSURE_ARG(aURI);
162892:   NS_ENSURE_ARG(aCallback);
162892: 
162892: #ifdef MOZ_LOGGING
162892:   nsAutoCString uriSpec;
162892:   aURI->GetAsciiSpec(uriSpec);
162892:   LOG(("_OldStorage::AsyncOpenURI [this=%p, uri=%s, ide=%s, flags=%x]",
162892:     this, uriSpec.get(), aIdExtension.BeginReading(), aFlags));
162892: #endif
162892: 
162892:   nsresult rv;
162892: 
172236:   nsAutoCString cacheKey, scheme;
172236:   rv = AssembleCacheKey(aURI, aIdExtension, cacheKey, scheme);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   if (!mAppCache && (mLookupAppCache || mOfflineStorage)) {
162892:     rv = ChooseApplicationCache(cacheKey, getter_AddRefs(mAppCache));
162892:     NS_ENSURE_SUCCESS(rv, rv);
165035: 
165035:     if (mAppCache) {
165035:       // From a chosen appcache open only as readonly
165035:       aFlags &= ~nsICacheStorage::OPEN_TRUNCATE;
165035:     }
162892:   }
162892: 
162892:   nsRefPtr<_OldCacheLoad> cacheLoad =
172236:     new _OldCacheLoad(scheme, cacheKey, aCallback, mAppCache,
162892:                       mLoadInfo, mWriteToDisk, aFlags);
162892: 
162892:   rv = cacheLoad->Start();
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   return NS_OK;
162892: }
162892: 
216317: NS_IMETHODIMP _OldStorage::OpenTruncate(nsIURI *aURI, const nsACString & aIdExtension,
216317:                                         nsICacheEntry **aCacheEntry)
216317: {
216317:   return NS_ERROR_NOT_IMPLEMENTED;
216317: }
216317: 
212449: NS_IMETHODIMP _OldStorage::Exists(nsIURI *aURI, const nsACString & aIdExtension,
212449:                                    bool *aResult)
212449: {
212449:   return NS_ERROR_NOT_AVAILABLE;
212449: }
212449: 
162892: NS_IMETHODIMP _OldStorage::AsyncDoomURI(nsIURI *aURI, const nsACString & aIdExtension,
162892:                                         nsICacheEntryDoomCallback* aCallback)
162892: {
162892:   LOG(("_OldStorage::AsyncDoomURI"));
162892: 
162892:   nsresult rv;
162892: 
172236:   nsAutoCString cacheKey, scheme;
172236:   rv = AssembleCacheKey(aURI, aIdExtension, cacheKey, scheme);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   nsCOMPtr<nsICacheSession> session;
172236:   rv = GetCacheSession(scheme, mWriteToDisk, mLoadInfo, mAppCache,
172236:                        getter_AddRefs(session));
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   nsRefPtr<DoomCallbackWrapper> cb = aCallback
162892:     ? new DoomCallbackWrapper(aCallback)
162892:     : nullptr;
162892:   rv = session->DoomEntry(cacheKey, cb);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   return NS_OK;
162892: }
162892: 
162892: NS_IMETHODIMP _OldStorage::AsyncEvictStorage(nsICacheEntryDoomCallback* aCallback)
162892: {
162892:   LOG(("_OldStorage::AsyncEvictStorage"));
162892: 
162892:   nsresult rv;
162892: 
162892:   if (!mAppCache && mOfflineStorage) {
162892:     // Special casing for pure offline storage
162892:     if (mLoadInfo->AppId() == nsILoadContextInfo::NO_APP_ID &&
162892:         !mLoadInfo->IsInBrowserElement()) {
162892: 
162892:       // Clear everything.
162892:       nsCOMPtr<nsICacheService> serv =
162892:           do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
162892:       NS_ENSURE_SUCCESS(rv, rv);
162892: 
207178:       rv = nsCacheService::GlobalInstance()->EvictEntriesInternal(nsICache::STORE_OFFLINE);
162892:       NS_ENSURE_SUCCESS(rv, rv);
162892:     }
162892:     else {
162892:       // Clear app or inbrowser staff.
162892:       nsCOMPtr<nsIApplicationCacheService> appCacheService =
162892:         do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID, &rv);
162892:       NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:       rv = appCacheService->DiscardByAppId(mLoadInfo->AppId(),
162892:                                            mLoadInfo->IsInBrowserElement());
162892:       NS_ENSURE_SUCCESS(rv, rv);
162892:     }
162892:   }
162892:   else {
172236:     if (mAppCache) {
162892:       nsCOMPtr<nsICacheSession> session;
172236:       rv = GetCacheSession(EmptyCString(),
172236:                            mWriteToDisk, mLoadInfo, mAppCache,
172236:                            getter_AddRefs(session));
162892:       NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:       rv = session->EvictEntries();
162892:       NS_ENSURE_SUCCESS(rv, rv);
162892:     }
172236:     else {
172236:       // Oh, I'll be so happy when session names are gone...
172236:       nsCOMPtr<nsICacheSession> session;
172236:       rv = GetCacheSession(NS_LITERAL_CSTRING("http"),
172236:                            mWriteToDisk, mLoadInfo, mAppCache,
172236:                            getter_AddRefs(session));
172236:       NS_ENSURE_SUCCESS(rv, rv);
172236: 
172236:       rv = session->EvictEntries();
172236:       NS_ENSURE_SUCCESS(rv, rv);
172236: 
172236:       rv = GetCacheSession(NS_LITERAL_CSTRING("wyciwyg"),
172236:                            mWriteToDisk, mLoadInfo, mAppCache,
172236:                            getter_AddRefs(session));
172236:       NS_ENSURE_SUCCESS(rv, rv);
172236: 
172236:       rv = session->EvictEntries();
172236:       NS_ENSURE_SUCCESS(rv, rv);
172236: 
172236:       // This clears any data from scheme other then http, wyciwyg or ftp
172236:       rv = GetCacheSession(EmptyCString(),
172236:                            mWriteToDisk, mLoadInfo, mAppCache,
172236:                            getter_AddRefs(session));
172236:       NS_ENSURE_SUCCESS(rv, rv);
172236: 
172236:       rv = session->EvictEntries();
172236:       NS_ENSURE_SUCCESS(rv, rv);
172236:     }
172236:   }
162892: 
162892:   if (aCallback) {
162892:     nsRefPtr<DoomCallbackSynchronizer> sync =
162892:       new DoomCallbackSynchronizer(aCallback);
162892:     rv = sync->Dispatch();
162892:     NS_ENSURE_SUCCESS(rv, rv);
162892:   }
162892: 
162892:   return NS_OK;
162892: }
162892: 
162892: NS_IMETHODIMP _OldStorage::AsyncVisitStorage(nsICacheStorageVisitor* aVisitor,
162892:                                              bool aVisitEntries)
162892: {
162892:   LOG(("_OldStorage::AsyncVisitStorage"));
162892: 
162892:   NS_ENSURE_ARG(aVisitor);
162892: 
162892:   nsresult rv;
162892: 
162892:   nsCOMPtr<nsICacheService> serv =
162892:     do_GetService(NS_CACHESERVICE_CONTRACTID, &rv);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   char* deviceID;
162892:   if (mAppCache || mOfflineStorage) {
162892:     deviceID = const_cast<char*>("offline");
162892:   } else if (!mWriteToDisk || mLoadInfo->IsPrivate()) {
162892:     deviceID = const_cast<char*>("memory");
162892:   } else {
162892:     deviceID = const_cast<char*>("disk");
162892:   }
162892: 
201508:   nsRefPtr<_OldVisitCallbackWrapper> cb = new _OldVisitCallbackWrapper(
201508:     deviceID, aVisitor, aVisitEntries, mLoadInfo);
207178:   rv = nsCacheService::GlobalInstance()->VisitEntriesInternal(cb);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   return NS_OK;
162892: }
162892: 
162892: // Internal
162892: 
162892: nsresult _OldStorage::AssembleCacheKey(nsIURI *aURI,
162892:                                        nsACString const & aIdExtension,
172236:                                        nsACString & aCacheKey,
172236:                                        nsACString & aScheme)
162892: {
162892:   // Copied from nsHttpChannel::AssembleCacheKey
162892: 
162892:   aCacheKey.Truncate();
162892: 
172236:   nsresult rv;
172236: 
172236:   rv = aURI->GetScheme(aScheme);
172236:   NS_ENSURE_SUCCESS(rv, rv);
172236: 
172236:   nsAutoCString uriSpec;
204656:   if (aScheme.EqualsLiteral("http") ||
204656:       aScheme.EqualsLiteral("https")) {
162892:     if (mLoadInfo->IsAnonymous()) {
162892:       aCacheKey.AssignLiteral("anon&");
162892:     }
162892: 
162892:     if (!aIdExtension.IsEmpty()) {
162892:       aCacheKey.AppendPrintf("id=%s&", aIdExtension.BeginReading());
162892:     }
162892: 
162892:     nsCOMPtr<nsIURI> noRefURI;
162892:     rv = aURI->CloneIgnoringRef(getter_AddRefs(noRefURI));
162892:     NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:     rv = noRefURI->GetAsciiSpec(uriSpec);
162892:     NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:     if (!aCacheKey.IsEmpty()) {
162892:       aCacheKey.AppendLiteral("uri=");
162892:     }
172236:   }
204656:   else if (aScheme.EqualsLiteral("wyciwyg")) {
172236:     rv = aURI->GetSpec(uriSpec);
172236:     NS_ENSURE_SUCCESS(rv, rv);
172236:   }
172236:   else {
172236:     rv = aURI->GetAsciiSpec(uriSpec);
172236:     NS_ENSURE_SUCCESS(rv, rv);
172236:   }
172236: 
162892:   aCacheKey.Append(uriSpec);
162892: 
162892:   return NS_OK;
162892: }
162892: 
162892: nsresult _OldStorage::ChooseApplicationCache(nsCSubstring const &cacheKey,
162892:                                              nsIApplicationCache** aCache)
162892: {
162892:   nsresult rv;
162892: 
162892:   nsCOMPtr<nsIApplicationCacheService> appCacheService =
162892:     do_GetService(NS_APPLICATIONCACHESERVICE_CONTRACTID, &rv);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   rv = appCacheService->ChooseApplicationCache(cacheKey, mLoadInfo, aCache);
162892:   NS_ENSURE_SUCCESS(rv, rv);
162892: 
162892:   return NS_OK;
162892: }
162892: 
162892: } // net
162892: } // mozilla
