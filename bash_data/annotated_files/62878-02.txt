    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Kathleen Brade <brade@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsHTMLEditor_h__
    1: #define nsHTMLEditor_h__
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsCOMArray.h"
    1: #include "nsPlaintextEditor.h"
    1: #include "nsIEditor.h"
    1: #include "nsIHTMLEditor.h"
57277: #include "nsIHTMLEditor_MOZILLA_2_0_BRANCH.h"
    1: #include "nsITableEditor.h"
    1: #include "nsIEditorMailSupport.h"
    1: #include "nsIEditorStyleSheets.h"
    1: #include "nsITextServicesDocument.h"
    1: 
    1: #include "nsEditor.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMEventListener.h"
    1: #include "nsICSSLoaderObserver.h"
    1: #include "nsITableLayout.h"
    1: 
    1: #include "nsEditRules.h"
    1: 
    1: #include "nsEditProperty.h"
    1: #include "nsHTMLCSSUtils.h"
    1: 
    1: #include "nsHTMLObjectResizer.h"
    1: #include "nsIHTMLAbsPosEditor.h"
    1: #include "nsIHTMLInlineTableEditor.h"
    1: #include "nsIHTMLObjectResizeListener.h"
    1: 
    1: #include "nsIDocumentObserver.h"
    1: 
    1: #include "nsPoint.h"
 7883: #include "nsTArray.h"
42163: #include "nsAutoPtr.h"
    1: 
    1: class nsIDOMKeyEvent;
    1: class nsITransferable;
    1: class nsIDOMNSRange;
    1: class nsIDocumentEncoder;
    1: class nsIClipboard;
    1: class TypeInState;
    1: class nsIContentFilter;
    1: class nsIURL;
    1: class nsIRangeUtils;
    1: class nsILinkHandler;
27986: struct PropItem;
    1: 
    1: /**
    1:  * The HTML editor implementation.<br>
    1:  * Use to edit HTML document represented as a DOM tree. 
    1:  */
    1: class nsHTMLEditor : public nsPlaintextEditor,
    1:                      public nsIHTMLEditor,
57277:                      public nsIHTMLEditor_MOZILLA_2_0_BRANCH,
    1:                      public nsIHTMLObjectResizer,
    1:                      public nsIHTMLAbsPosEditor,
    1:                      public nsITableEditor,
    1:                      public nsIHTMLInlineTableEditor,
    1:                      public nsIEditorStyleSheets,
43716:                      public nsICSSLoaderObserver,
43716:                      public nsStubMutationObserver
    1: {
    1:   typedef enum {eNoOp, eReplaceParent=1, eInsertParent=2} BlockTransformationType;
    1: 
    1: public:
    1: 
    1:   enum OperationID
    1:   {
    1:     kOpInsertBreak         = 3000,
    1:     kOpMakeList            = 3001,
    1:     kOpIndent              = 3002,
    1:     kOpOutdent             = 3003,
    1:     kOpAlign               = 3004,
    1:     kOpMakeBasicBlock      = 3005,
    1:     kOpRemoveList          = 3006,
    1:     kOpMakeDefListItem     = 3007,
    1:     kOpInsertElement       = 3008,
    1:     kOpInsertQuotation     = 3009,
    1:     kOpSetTextProperty     = 3010,
    1:     kOpRemoveTextProperty  = 3011,
    1:     kOpHTMLPaste           = 3012,
    1:     kOpLoadHTML            = 3013,
    1:     kOpResetTextProperties = 3014,
    1:     kOpSetAbsolutePosition = 3015,
    1:     kOpRemoveAbsolutePosition = 3016,
    1:     kOpDecreaseZIndex      = 3017,
    1:     kOpIncreaseZIndex      = 3018
    1:   };
    1: 
    1:   enum ResizingRequestID
    1:   {
    1:     kX      = 0,
    1:     kY      = 1,
    1:     kWidth  = 2,
    1:     kHeight = 3
    1:   };
    1: 
    1:   // see nsIHTMLEditor for documentation
    1: 
    1: //Interfaces for addref and release and queryinterface
    1: //NOTE macro used is for classes that inherit from 
    1: // another class. Only the base class should use NS_DECL_ISUPPORTS
    1:   NS_DECL_ISUPPORTS_INHERITED
62825:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsHTMLEditor, nsPlaintextEditor)
    1: 
    1: 
    1:            nsHTMLEditor();
    1:   virtual  ~nsHTMLEditor();
    1: 
    1:   /* ------------ nsPlaintextEditor overrides -------------- */
    1:   NS_IMETHOD GetIsDocumentEditable(PRBool *aIsDocumentEditable);
57480:   NS_IMETHOD BeginningOfDocument();
43438:   virtual nsresult HandleKeyPressEvent(nsIDOMKeyEvent* aKeyEvent);
56870:   virtual already_AddRefed<nsIContent> GetFocusedContent();
48083:   virtual PRBool IsActiveInDOMWindow();
43714:   virtual already_AddRefed<nsPIDOMEventTarget> GetPIDOMEventTarget();
43843:   virtual already_AddRefed<nsIContent> FindSelectionRoot(nsINode *aNode);
48083:   virtual PRBool IsAcceptableInputEvent(nsIDOMEvent* aEvent);
41886: 
43716:   /* ------------ nsStubMutationObserver overrides --------- */
43716:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
43716:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
43716:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
43716: 
41886:   /* ------------ nsIEditorIMESupport overrides ------------ */
41886:   NS_IMETHOD GetPreferredIMEState(PRUint32 *aState);
    1: 
    1:   /* ------------ nsIHTMLEditor methods -------------- */
    1: 
    1:   NS_DECL_NSIHTMLEDITOR
    1: 
57277:   /* ------------ nsIHTMLEditor_MOZILLA_2_0_BRANCH methods -------------- */
57277: 
57277:   NS_DECL_NSIHTMLEDITOR_MOZILLA_2_0_BRANCH
57277: 
    1:   /* ------------ nsIHTMLObjectResizer methods -------------- */
    1:   /* -------- Implemented in nsHTMLObjectResizer.cpp -------- */
    1:   NS_DECL_NSIHTMLOBJECTRESIZER
    1: 
    1:   /* ------------ nsIHTMLAbsPosEditor methods -------------- */
    1:   /* -------- Implemented in nsHTMLAbsPosition.cpp --------- */
    1:   NS_DECL_NSIHTMLABSPOSEDITOR
    1: 
    1:   /* ------------ nsIHTMLInlineTableEditor methods -------------- */
    1:   /* ------- Implemented in nsHTMLInlineTableEditor.cpp --------- */
    1:   NS_DECL_NSIHTMLINLINETABLEEDITOR
    1: 
    1:   /* ------------ nsIHTMLEditor methods -------------- */
    1:   NS_IMETHOD CopyLastEditableChildStyles(nsIDOMNode *aPreviousBlock, nsIDOMNode *aNewBlock,
    1:                                          nsIDOMNode **aOutBrNode);
    1: 
    1:   NS_IMETHOD LoadHTML(const nsAString &aInputString);
    1: 
    1:   nsresult GetCSSBackgroundColorState(PRBool *aMixed, nsAString &aOutColor,
    1:                                       PRBool aBlockLevel);
    1:   NS_IMETHOD GetHTMLBackgroundColorState(PRBool *aMixed, nsAString &outColor);
    1: 
    1:   /* ------------ nsIEditorStyleSheets methods -------------- */
    1: 
    1:   NS_IMETHOD AddStyleSheet(const nsAString & aURL);
    1:   NS_IMETHOD ReplaceStyleSheet(const nsAString& aURL);
    1:   NS_IMETHOD RemoveStyleSheet(const nsAString &aURL);
    1: 
    1:   NS_IMETHOD AddOverrideStyleSheet(const nsAString & aURL);
    1:   NS_IMETHOD ReplaceOverrideStyleSheet(const nsAString& aURL);
    1:   NS_IMETHOD RemoveOverrideStyleSheet(const nsAString &aURL);
    1: 
    1:   NS_IMETHOD EnableStyleSheet(const nsAString& aURL, PRBool aEnable);
    1: 
    1:   /* ------------ nsIEditorMailSupport methods -------------- */
    1: 
    1:   NS_DECL_NSIEDITORMAILSUPPORT
    1: 
    1:   /* ------------ nsITableEditor methods -------------- */
    1: 
    1:   NS_IMETHOD InsertTableCell(PRInt32 aNumber, PRBool aAfter);
    1:   NS_IMETHOD InsertTableColumn(PRInt32 aNumber, PRBool aAfter);
    1:   NS_IMETHOD InsertTableRow(PRInt32 aNumber, PRBool aAfter);
    1:   NS_IMETHOD DeleteTable();
    1:   NS_IMETHOD DeleteTableCell(PRInt32 aNumber);
    1:   NS_IMETHOD DeleteTableCellContents();
    1:   NS_IMETHOD DeleteTableColumn(PRInt32 aNumber);
    1:   NS_IMETHOD DeleteTableRow(PRInt32 aNumber);
    1:   NS_IMETHOD SelectTableCell();
    1:   NS_IMETHOD SelectBlockOfCells(nsIDOMElement *aStartCell, nsIDOMElement *aEndCell);
    1:   NS_IMETHOD SelectTableRow();
    1:   NS_IMETHOD SelectTableColumn();
    1:   NS_IMETHOD SelectTable();
    1:   NS_IMETHOD SelectAllTableCells();
    1:   NS_IMETHOD SwitchTableCellHeaderType(nsIDOMElement *aSourceCell, nsIDOMElement **aNewCell);
    1:   NS_IMETHOD JoinTableCells(PRBool aMergeNonContiguousContents);
    1:   NS_IMETHOD SplitTableCell();
    1:   NS_IMETHOD NormalizeTable(nsIDOMElement *aTable);
    1:   NS_IMETHOD GetCellIndexes(nsIDOMElement *aCell,
    1:                             PRInt32* aRowIndex, PRInt32* aColIndex);
    1:   NS_IMETHOD GetTableSize(nsIDOMElement *aTable,
    1:                           PRInt32* aRowCount, PRInt32* aColCount);
    1:   NS_IMETHOD GetCellAt(nsIDOMElement* aTable, PRInt32 aRowIndex, PRInt32 aColIndex, nsIDOMElement **aCell);
    1:   NS_IMETHOD GetCellDataAt(nsIDOMElement* aTable,
    1:                            PRInt32 aRowIndex, PRInt32 aColIndex,
    1:                            nsIDOMElement **aCell,
    1:                            PRInt32* aStartRowIndex, PRInt32* aStartColIndex,
    1:                            PRInt32* aRowSpan, PRInt32* aColSpan, 
    1:                            PRInt32* aActualRowSpan, PRInt32* aActualColSpan, 
    1:                            PRBool* aIsSelected);
    1:   NS_IMETHOD GetFirstRow(nsIDOMElement* aTableElement, nsIDOMNode** aRowNode);
    1:   NS_IMETHOD GetNextRow(nsIDOMNode* aCurrentRowNode, nsIDOMNode** aRowNode);
    1:   NS_IMETHOD GetLastCellInRow(nsIDOMNode* aRowNode, nsIDOMNode** aCellNode);
    1: 
    1:   NS_IMETHOD SetSelectionAfterTableEdit(nsIDOMElement* aTable, PRInt32 aRow, PRInt32 aCol, 
    1:                                         PRInt32 aDirection, PRBool aSelected);
    1:   NS_IMETHOD GetSelectedOrParentTableElement(nsAString& aTagName,
    1:                                              PRInt32 *aSelectedCount,
    1:                                              nsIDOMElement** aTableElement);
    1:   NS_IMETHOD GetSelectedCellsType(nsIDOMElement *aElement, PRUint32 *aSelectionType);
    1: 
    1:   nsresult GetCellFromRange(nsIDOMRange *aRange, nsIDOMElement **aCell);
    1: 
    1:   // Finds the first selected cell in first range of selection
    1:   // This is in the *order of selection*, not order in the table
    1:   // (i.e., each cell added to selection is added in another range 
    1:   //  in the selection's rangelist, independent of location in table)
    1:   // aRange is optional: returns the range around the cell
    1:   NS_IMETHOD GetFirstSelectedCell(nsIDOMRange **aRange, nsIDOMElement **aCell);
    1:   // Get next cell until no more are found. Always use GetFirstSelected cell first
    1:   // aRange is optional: returns the range around the cell
    1:   NS_IMETHOD GetNextSelectedCell(nsIDOMRange **aRange, nsIDOMElement **aCell);
    1: 
    1:   // Upper-left-most selected cell in table
    1:   NS_IMETHOD GetFirstSelectedCellInTable(PRInt32 *aRowIndex, PRInt32 *aColIndex, nsIDOMElement **aCell);
    1:     
    1:   /* miscellaneous */
    1:   // This sets background on the appropriate container element (table, cell,)
    1:   //   or calls into nsTextEditor to set the page background
    1:   NS_IMETHOD SetCSSBackgroundColor(const nsAString& aColor);
    1:   NS_IMETHOD SetHTMLBackgroundColor(const nsAString& aColor);
    1: 
    1:   /* ------------ Block methods moved from nsEditor -------------- */
    1:   static nsCOMPtr<nsIDOMNode> GetBlockNodeParent(nsIDOMNode *aNode);
    1:   /** Determines the bounding nodes for the block section containing aNode.
    1:     * The calculation is based on some nodes intrinsically being block elements
    1:     * acording to HTML.  Style sheets are not considered in this calculation.
    1:     * <BR> tags separate block content sections.  So the HTML markup:
    1:     * <PRE>
    1:     *      <P>text1<BR>text2<B>text3</B></P>
    1:     * </PRE>
    1:     * contains two block content sections.  The first has the text node "text1"
    1:     * for both endpoints.  The second has "text2" as the left endpoint and
    1:     * "text3" as the right endpoint.
    1:     * Notice that offsets aren't required, only leaf nodes.  Offsets are implicit.
    1:     *
    1:     * @param aNode      the block content returned includes aNode
    1:     * @param aLeftNode  [OUT] the left endpoint of the block content containing aNode
    1:     * @param aRightNode [OUT] the right endpoint of the block content containing aNode
    1:     *
    1:     */
    1:   static nsresult GetBlockSection(nsIDOMNode  *aNode,
    1:                                   nsIDOMNode **aLeftNode, 
    1:                                   nsIDOMNode **aRightNode);
    1: 
    1:   /** Compute the set of block sections in a given range.
    1:     * A block section is the set of (leftNode, rightNode) pairs given
    1:     * by GetBlockSection.  The set is computed by computing the 
    1:     * block section for every leaf node in the range and throwing 
    1:     * out duplicates.
    1:     *
    1:     * @param aRange     The range to compute block sections for.
    1:     * @param aSections  Allocated storage for the resulting set, stored as nsIDOMRanges.
    1:     */
    1:   static nsresult GetBlockSectionsForRange(nsIDOMRange      *aRange, 
    1:                                            nsCOMArray<nsIDOMRange>& aSections);
    1: 
    1:   static nsCOMPtr<nsIDOMNode> NextNodeInBlock(nsIDOMNode *aNode, IterDirection aDir);
    1:   nsresult IsNextCharWhitespace(nsIDOMNode *aParentNode, 
    1:                                 PRInt32 aOffset, 
    1:                                 PRBool *outIsSpace, 
    1:                                 PRBool *outIsNBSP,
    1:                                 nsCOMPtr<nsIDOMNode> *outNode = 0,
    1:                                 PRInt32 *outOffset = 0);
    1:   nsresult IsPrevCharWhitespace(nsIDOMNode *aParentNode, 
    1:                                 PRInt32 aOffset, 
    1:                                 PRBool *outIsSpace, 
    1:                                 PRBool *outIsNBSP,
    1:                                 nsCOMPtr<nsIDOMNode> *outNode = 0,
    1:                                 PRInt32 *outOffset = 0);
    1: 
    1:   /* ------------ Overrides of nsEditor interface methods -------------- */
    1: 
    1:   nsresult EndUpdateViewBatch();
    1: 
    1:   /** prepare the editor for use */
    1:   NS_IMETHOD Init(nsIDOMDocument *aDoc, nsIPresShell *aPresShell,  nsIContent *aRoot, nsISelectionController *aSelCon, PRUint32 aFlags);
43716:   NS_IMETHOD PreDestroy(PRBool aDestroyingFrames);
    1: 
    1:   /** Internal, static version */
    1:   static nsresult NodeIsBlockStatic(nsIDOMNode *aNode, PRBool *aIsBlock);
    1: 
    1:   NS_IMETHOD SetFlags(PRUint32 aFlags);
    1: 
    1:   NS_IMETHOD Paste(PRInt32 aSelectionType);
    1:   NS_IMETHOD CanPaste(PRInt32 aSelectionType, PRBool *aCanPaste);
    1: 
36983:   NS_IMETHOD PasteTransferable(nsITransferable *aTransferable);
36983:   NS_IMETHOD CanPasteTransferable(nsITransferable *aTransferable, PRBool *aCanPaste);
36983: 
    1:   NS_IMETHOD DebugUnitTests(PRInt32 *outNumTests, PRInt32 *outNumTestsFailed);
    1: 
    1:   /** All editor operations which alter the doc should be prefaced
    1:    *  with a call to StartOperation, naming the action and direction */
    1:   NS_IMETHOD StartOperation(PRInt32 opID, nsIEditor::EDirection aDirection);
    1: 
    1:   /** All editor operations which alter the doc should be followed
    1:    *  with a call to EndOperation */
    1:   NS_IMETHOD EndOperation();
    1: 
    1:   /** returns PR_TRUE if aParentTag can contain a child of type aChildTag */
    1:   virtual PRBool TagCanContainTag(const nsAString& aParentTag, const nsAString& aChildTag);
    1:   
    1:   /** returns PR_TRUE if aNode is a container */
    1:   virtual PRBool IsContainer(nsIDOMNode *aNode);
    1: 
    1:   /** make the given selection span the entire document */
    1:   NS_IMETHOD SelectEntireDocument(nsISelection *aSelection);
    1: 
    1:   NS_IMETHOD SetAttributeOrEquivalent(nsIDOMElement * aElement,
    1:                                       const nsAString & aAttribute,
    1:                                       const nsAString & aValue,
    1:                                       PRBool aSuppressTransaction);
    1:   NS_IMETHOD RemoveAttributeOrEquivalent(nsIDOMElement * aElement,
    1:                                          const nsAString & aAttribute,
    1:                                          PRBool aSuppressTransaction);
    1: 
    1:   /** join together any afjacent editable text nodes in the range */
    1:   NS_IMETHOD CollapseAdjacentTextNodes(nsIDOMRange *aInRange);
    1: 
    1:   virtual PRBool NodesSameType(nsIDOMNode *aNode1, nsIDOMNode *aNode2);
    1: 
    1:   NS_IMETHODIMP DeleteNode(nsIDOMNode * aNode);
    1:   NS_IMETHODIMP DeleteText(nsIDOMCharacterData *aTextNode,
    1:                            PRUint32             aOffset,
    1:                            PRUint32             aLength);
 2896:   NS_IMETHOD InsertTextImpl(const nsAString& aStringToInsert, 
 2896:                             nsCOMPtr<nsIDOMNode> *aInOutNode, 
 2896:                             PRInt32 *aInOutOffset,
 2896:                             nsIDOMDocument *aDoc);
 2896:   NS_IMETHOD_(PRBool) IsModifiableNode(nsIDOMNode *aNode);
 2896: 
 2896:   NS_IMETHOD SelectAll();
    1: 
43713:   NS_IMETHOD GetRootElement(nsIDOMElement **aRootElement);
43713: 
    1:   /* ------------ nsICSSLoaderObserver -------------- */
42163:   NS_IMETHOD StyleSheetLoaded(nsCSSStyleSheet*aSheet, PRBool aWasAlternate,
    1:                               nsresult aStatus);
    1: 
    1:   /* ------------ Utility Routines, not part of public API -------------- */
    1:   NS_IMETHOD TypedText(const nsAString& aString, PRInt32 aAction);
    1:   nsresult InsertNodeAtPoint( nsIDOMNode *aNode, 
    1:                               nsCOMPtr<nsIDOMNode> *ioParent, 
    1:                               PRInt32 *ioOffset, 
    1:                               PRBool aNoEmptyNodes);
    1:   nsCOMPtr<nsIDOMNode> FindUserSelectAllNode(nsIDOMNode *aNode);
    1:                                 
    1: 
    1:   /** returns the absolute position of the end points of aSelection
    1:     * in the document as a text stream.
    1:     */
    1:   nsresult GetTextSelectionOffsets(nsISelection *aSelection,
    1:                                    PRInt32 &aStartOffset, 
    1:                                    PRInt32 &aEndOffset);
    1: 
    1:   // Use this to assure that selection is set after attribute nodes when 
    1:   //  trying to collapse selection at begining of a block node
    1:   //  e.g., when setting at beginning of a table cell
    1:   // This will stop at a table, however, since we don't want to
    1:   //  "drill down" into nested tables.
    1:   // aSelection is optional -- if null, we get current seletion
    1:   nsresult CollapseSelectionToDeepestNonTableFirstChild(nsISelection *aSelection, nsIDOMNode *aNode);
    1: 
    1:   virtual PRBool IsTextInDirtyFrameVisible(nsIDOMNode *aNode);
    1: 
    1:   nsresult IsVisTextNode( nsIDOMNode *aNode, 
    1:                           PRBool *outIsEmptyNode, 
    1:                           PRBool aSafeToAskFrames);
    1:   nsresult IsEmptyNode(nsIDOMNode *aNode, PRBool *outIsEmptyBlock, 
    1:                        PRBool aMozBRDoesntCount = PR_FALSE,
    1:                        PRBool aListOrCellNotEmpty = PR_FALSE,
    1:                        PRBool aSafeToAskFrames = PR_FALSE);
    1:   nsresult IsEmptyNodeImpl(nsIDOMNode *aNode,
    1:                            PRBool *outIsEmptyBlock, 
    1:                            PRBool aMozBRDoesntCount,
    1:                            PRBool aListOrCellNotEmpty,
    1:                            PRBool aSafeToAskFrames,
    1:                            PRBool *aSeenBR);
    1: 
    1:   // Returns TRUE if sheet was loaded, false if it wasn't
    1:   PRBool   EnableExistingStyleSheet(const nsAString& aURL);
    1: 
    1:   // Dealing with the internal style sheet lists:
    1:   NS_IMETHOD GetStyleSheetForURL(const nsAString &aURL,
42163:                                  nsCSSStyleSheet **_retval);
42163:   NS_IMETHOD GetURLForStyleSheet(nsCSSStyleSheet *aStyleSheet, nsAString &aURL);
    1: 
    1:   // Add a url + known style sheet to the internal lists:
    1:   nsresult AddNewStyleSheetToList(const nsAString &aURL,
42163:                                   nsCSSStyleSheet *aStyleSheet);
    1: 
    1:   nsresult RemoveStyleSheetFromList(const nsAString &aURL);
    1:                        
    1: protected:
    1: 
    1:   NS_IMETHOD  InitRules();
    1: 
    1:   // Create the event listeners for the editor to install
    1:   virtual nsresult CreateEventListeners();
    1: 
40987:   virtual nsresult InstallEventListeners();
    1:   virtual void RemoveEventListeners();
    1: 
43717:   PRBool ShouldReplaceRootElement();
43717:   void ResetRootElementAndEventTarget();
43713:   nsresult GetBodyElement(nsIDOMHTMLElement** aBody);
48083:   // Get the focused node of this editor.
48083:   // @return    If the editor has focus, this returns the focused node.
48083:   //            Otherwise, returns null.
43717:   already_AddRefed<nsINode> GetFocusedNode();
43713: 
    1:   // Return TRUE if aElement is a table-related elemet and caret was set
    1:   PRBool SetCaretInTableCell(nsIDOMElement* aElement);
    1:   PRBool IsElementInBody(nsIDOMElement* aElement);
    1: 
    1:   // key event helpers
    1:   NS_IMETHOD TabInTable(PRBool inIsShift, PRBool *outHandled);
    1:   NS_IMETHOD CreateBR(nsIDOMNode *aNode, PRInt32 aOffset, 
    1:                       nsCOMPtr<nsIDOMNode> *outBRNode, nsIEditor::EDirection aSelect = nsIEditor::eNone);
    1:   NS_IMETHOD CreateBRImpl(nsCOMPtr<nsIDOMNode> *aInOutParent, 
    1:                          PRInt32 *aInOutOffset, 
    1:                          nsCOMPtr<nsIDOMNode> *outBRNode, 
    1:                          nsIEditor::EDirection aSelect);
    1:   NS_IMETHOD InsertBR(nsCOMPtr<nsIDOMNode> *outBRNode);
    1: 
    1: // Table Editing (implemented in nsTableEditor.cpp)
    1: 
    1:   // Table utilities
    1: 
    1:   // Insert a new cell after or before supplied aCell. 
    1:   //  Optional: If aNewCell supplied, returns the newly-created cell (addref'd, of course)
    1:   // This doesn't change or use the current selection
    1:   NS_IMETHOD InsertCell(nsIDOMElement *aCell, PRInt32 aRowSpan, PRInt32 aColSpan,
    1:                         PRBool aAfter, PRBool aIsHeader, nsIDOMElement **aNewCell);
    1: 
    1:   // Helpers that don't touch the selection or do batch transactions
    1:   NS_IMETHOD DeleteRow(nsIDOMElement *aTable, PRInt32 aRowIndex);
    1:   NS_IMETHOD DeleteColumn(nsIDOMElement *aTable, PRInt32 aColIndex);
    1:   NS_IMETHOD DeleteCellContents(nsIDOMElement *aCell);
    1: 
    1:   // Move all contents from aCellToMerge into aTargetCell (append at end)
    1:   NS_IMETHOD MergeCells(nsCOMPtr<nsIDOMElement> aTargetCell, nsCOMPtr<nsIDOMElement> aCellToMerge, PRBool aDeleteCellToMerge);
    1: 
    1:   NS_IMETHOD DeleteTable2(nsIDOMElement *aTable, nsISelection *aSelection);
    1:   NS_IMETHOD SetColSpan(nsIDOMElement *aCell, PRInt32 aColSpan);
    1:   NS_IMETHOD SetRowSpan(nsIDOMElement *aCell, PRInt32 aRowSpan);
    1: 
    1:   // Helper used to get nsITableLayout interface for methods implemented in nsTableFrame
    1:   NS_IMETHOD GetTableLayoutObject(nsIDOMElement* aTable, nsITableLayout **tableLayoutObject);
    1:   // Needed to do appropriate deleting when last cell or row is about to be deleted
    1:   // This doesn't count cells that don't start in the given row (are spanning from row above)
    1:   PRInt32  GetNumberOfCellsInRow(nsIDOMElement* aTable, PRInt32 rowIndex);
    1:   // Test if all cells in row or column at given index are selected
    1:   PRBool AllCellsInRowSelected(nsIDOMElement *aTable, PRInt32 aRowIndex, PRInt32 aNumberOfColumns);
    1:   PRBool AllCellsInColumnSelected(nsIDOMElement *aTable, PRInt32 aColIndex, PRInt32 aNumberOfRows);
    1: 
    1:   PRBool   IsEmptyCell(nsIDOMElement *aCell);
    1: 
    1:   // Most insert methods need to get the same basic context data
    1:   // Any of the pointers may be null if you don't need that datum (for more efficiency)
    1:   // Input: *aCell is a known cell,
    1:   //        if null, cell is obtained from the anchor node of the selection
    1:   // Returns NS_EDITOR_ELEMENT_NOT_FOUND if cell is not found even if aCell is null
    1:   NS_IMETHOD GetCellContext(nsISelection **aSelection,
    1:                             nsIDOMElement   **aTable,
    1:                             nsIDOMElement   **aCell,
    1:                             nsIDOMNode      **aCellParent, PRInt32 *aCellOffset,
    1:                             PRInt32 *aRowIndex, PRInt32 *aColIndex);
    1: 
    1:   NS_IMETHOD GetCellSpansAt(nsIDOMElement* aTable, PRInt32 aRowIndex, PRInt32 aColIndex, 
    1:                             PRInt32& aActualRowSpan, PRInt32& aActualColSpan);
    1: 
    1:   NS_IMETHOD SplitCellIntoColumns(nsIDOMElement *aTable, PRInt32 aRowIndex, PRInt32 aColIndex,
    1:                                   PRInt32 aColSpanLeft, PRInt32 aColSpanRight, nsIDOMElement **aNewCell);
    1: 
    1:   NS_IMETHOD SplitCellIntoRows(nsIDOMElement *aTable, PRInt32 aRowIndex, PRInt32 aColIndex,
    1:                                PRInt32 aRowSpanAbove, PRInt32 aRowSpanBelow, nsIDOMElement **aNewCell);
    1: 
    1:   nsresult CopyCellBackgroundColor(nsIDOMElement *destCell, nsIDOMElement *sourceCell);
    1: 
42587:   // Reduce rowspan/colspan when cells span into nonexistent rows/columns
    1:   NS_IMETHOD FixBadRowSpan(nsIDOMElement *aTable, PRInt32 aRowIndex, PRInt32& aNewRowCount);
    1:   NS_IMETHOD FixBadColSpan(nsIDOMElement *aTable, PRInt32 aColIndex, PRInt32& aNewColCount);
    1: 
    1:   // Fallback method: Call this after using ClearSelection() and you
    1:   //  failed to set selection to some other content in the document
    1:   NS_IMETHOD SetSelectionAtDocumentStart(nsISelection *aSelection);
    1: 
    1: // End of Table Editing utilities
    1:   
    1:   NS_IMETHOD IsRootTag(nsString &aTag, PRBool &aIsTag);
    1: 
    1:   virtual PRBool IsBlockNode(nsIDOMNode *aNode);
    1:   
    1:   static nsCOMPtr<nsIDOMNode> GetEnclosingTable(nsIDOMNode *aNode);
    1: 
    1:   /** content-based query returns PR_TRUE if <aProperty aAttribute=aValue> effects aNode
    1:     * If <aProperty aAttribute=aValue> contains aNode, 
    1:     * but <aProperty aAttribute=SomeOtherValue> also contains aNode and the second is
    1:     * more deeply nested than the first, then the first does not effect aNode.
    1:     *
    1:     * @param aNode      The target of the query
    1:     * @param aProperty  The property that we are querying for
    1:     * @param aAttribute The attribute of aProperty, example: color in <FONT color="blue">
    1:     *                   May be null.
    1:     * @param aValue     The value of aAttribute, example: blue in <FONT color="blue">
    1:     *                   May be null.  Ignored if aAttribute is null.
    1:     * @param aIsSet     [OUT] PR_TRUE if <aProperty aAttribute=aValue> effects aNode.
    1:     * @param aStyleNode [OUT] set to the node representing <aProperty aAttribute=aValue>, if found.
    1:     *                   null if aIsSet is returned as PR_FALSE;
    1:     */
    1:   virtual void IsTextPropertySetByContent(nsIDOMNode        *aNode,
    1:                                           nsIAtom           *aProperty, 
    1:                                           const nsAString   *aAttribute,
    1:                                           const nsAString   *aValue,
    1:                                           PRBool            &aIsSet,
    1:                                           nsIDOMNode       **aStyleNode,
    1:                                           nsAString *outValue = nsnull);
    1: 
    1:   // Methods for handling plaintext quotations
    1:   NS_IMETHOD PasteAsPlaintextQuotation(PRInt32 aSelectionType);
    1: 
    1:   /** Insert a string as quoted text,
    1:     * replacing the selected text (if any).
    1:     * @param aQuotedText     The string to insert.
    1:     * @param aAddCites       Whether to prepend extra ">" to each line
    1:     *                        (usually true, unless those characters
    1:     *                        have already been added.)
    1:     * @return aNodeInserted  The node spanning the insertion, if applicable.
    1:     *                        If aAddCites is false, this will be null.
    1:     */
    1:   NS_IMETHOD InsertAsPlaintextQuotation(const nsAString & aQuotedText,
    1:                                         PRBool aAddCites,
    1:                                         nsIDOMNode **aNodeInserted);
    1: 
    1:   // factored methods for handling insertion of data from transferables (drag&drop or clipboard)
    1:   NS_IMETHOD PrepareTransferable(nsITransferable **transferable);
    1:   NS_IMETHOD PrepareHTMLTransferable(nsITransferable **transferable, PRBool havePrivFlavor);
    1:   nsresult   PutDragDataInTransferable(nsITransferable **aTransferable);
    1:   NS_IMETHOD InsertFromTransferable(nsITransferable *transferable, 
    1:                                     nsIDOMDocument *aSourceDoc,
    1:                                     const nsAString & aContextStr,
    1:                                     const nsAString & aInfoStr,
    1:                                     nsIDOMNode *aDestinationNode,
    1:                                     PRInt32 aDestinationOffset,
    1:                                     PRBool aDoDeleteSelection);
    1:   PRBool HavePrivateHTMLFlavor( nsIClipboard *clipboard );
    1:   nsresult   ParseCFHTML(nsCString & aCfhtml, PRUnichar **aStuffToPaste, PRUnichar **aCfcontext);
    1:   nsresult   DoContentFilterCallback(const nsAString &aFlavor,
    1:                                      nsIDOMDocument *aSourceDoc,
    1:                                      PRBool aWillDeleteSelection,
    1:                                      nsIDOMNode **aFragmentAsNode,      
    1:                                      nsIDOMNode **aFragStartNode,
    1:                                      PRInt32 *aFragStartOffset,
    1:                                      nsIDOMNode **aFragEndNode,
    1:                                      PRInt32 *aFragEndOffset,
    1:                                      nsIDOMNode **aTargetNode,       
    1:                                      PRInt32 *aTargetOffset,   
    1:                                      PRBool *aDoContinue);
 9979:   nsresult   RelativizeURIInFragmentList(const nsCOMArray<nsIDOMNode> &aNodeList,
    1:                                         const nsAString &aFlavor,
    1:                                         nsIDOMDocument *aSourceDoc,
    1:                                         nsIDOMNode *aTargetNode);
    1:   nsresult   RelativizeURIForNode(nsIDOMNode *aNode, nsIURL *aDestURL);
    1:   nsresult   GetAttributeToModifyOnNode(nsIDOMNode *aNode, nsAString &aAttrib);
    1: 
    1:   PRBool     IsInLink(nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *outLink = nsnull);
    1:   nsresult   StripFormattingNodes(nsIDOMNode *aNode, PRBool aOnlyList = PR_FALSE);
    1:   nsresult   CreateDOMFragmentFromPaste(const nsAString & aInputString,
    1:                                         const nsAString & aContextStr,
    1:                                         const nsAString & aInfoStr,
    1:                                         nsCOMPtr<nsIDOMNode> *outFragNode,
    1:                                         nsCOMPtr<nsIDOMNode> *outStartNode,
    1:                                         nsCOMPtr<nsIDOMNode> *outEndNode,
    1:                                         PRInt32 *outStartOffset,
54661:                                         PRInt32 *outEndOffset,
54661:                                         PRBool aTrustedInput);
30162:   nsresult   ParseFragment(const nsAString & aStr, nsTArray<nsString> &aTagStack,
30162:                            nsIDocument* aTargetDoc,
54661:                            nsCOMPtr<nsIDOMNode> *outNode,
54661:                            PRBool aTrustedInput);
    1:   nsresult   CreateListOfNodesToPaste(nsIDOMNode  *aFragmentAsNode,
    1:                                       nsCOMArray<nsIDOMNode>& outNodeList,
    1:                                       nsIDOMNode *aStartNode,
    1:                                       PRInt32 aStartOffset,
    1:                                       nsIDOMNode *aEndNode,
    1:                                       PRInt32 aEndOffset);
30162:   nsresult CreateTagStack(nsTArray<nsString> &aTagStack,
30162:                           nsIDOMNode *aNode);
    1:   nsresult GetListAndTableParents( PRBool aEnd, 
    1:                                    nsCOMArray<nsIDOMNode>& aListOfNodes,
    1:                                    nsCOMArray<nsIDOMNode>& outArray);
    1:   nsresult DiscoverPartialListsAndTables(nsCOMArray<nsIDOMNode>& aPasteNodes,
    1:                                          nsCOMArray<nsIDOMNode>& aListsAndTables,
    1:                                          PRInt32 *outHighWaterMark);
    1:   nsresult ScanForListAndTableStructure(PRBool aEnd,
    1:                                         nsCOMArray<nsIDOMNode>& aNodes,
    1:                                         nsIDOMNode *aListOrTable,
    1:                                         nsCOMPtr<nsIDOMNode> *outReplaceNode);
    1:   nsresult ReplaceOrphanedStructure( PRBool aEnd,
    1:                                      nsCOMArray<nsIDOMNode>& aNodeArray,
    1:                                      nsCOMArray<nsIDOMNode>& aListAndTableArray,
    1:                                      PRInt32 aHighWaterMark);
    1:   nsIDOMNode* GetArrayEndpoint(PRBool aEnd, nsCOMArray<nsIDOMNode>& aNodeArray);
    1: 
    1:   /* small utility routine to test if a break node is visible to user */
    1:   PRBool   IsVisBreak(nsIDOMNode *aNode);
    1: 
    1:   /* utility routine to possibly adjust the insertion position when 
    1:      inserting a block level element */
    1:   void NormalizeEOLInsertPosition(nsIDOMNode *firstNodeToInsert,
    1:                                   nsCOMPtr<nsIDOMNode> *insertParentNode,
    1:                                   PRInt32 *insertOffset);
    1: 
    1:   /* small utility routine to test the eEditorReadonly bit */
    1:   PRBool IsModifiable();
    1: 
    1:   /* helpers for block transformations */
    1:   nsresult MakeDefinitionItem(const nsAString & aItemType);
    1:   nsresult InsertBasicBlock(const nsAString & aBlockType);
    1:   
    1:   /* increase/decrease the font size of selection */
    1:   nsresult RelativeFontChange( PRInt32 aSizeChange);
    1:   
    1:   /* helper routines for font size changing */
    1:   nsresult RelativeFontChangeOnTextNode( PRInt32 aSizeChange, 
    1:                                          nsIDOMCharacterData *aTextNode, 
    1:                                          PRInt32 aStartOffset,
    1:                                          PRInt32 aEndOffset);
    1:   nsresult RelativeFontChangeOnNode( PRInt32 aSizeChange, 
    1:                                      nsIDOMNode *aNode);
    1:   nsresult RelativeFontChangeHelper( PRInt32 aSizeChange, 
    1:                                      nsIDOMNode *aNode);
    1: 
    1:   /* helper routines for inline style */
    1:   nsresult SetInlinePropertyOnTextNode( nsIDOMCharacterData *aTextNode, 
    1:                                         PRInt32 aStartOffset,
    1:                                         PRInt32 aEndOffset,
    1:                                         nsIAtom *aProperty, 
    1:                                         const nsAString *aAttribute,
    1:                                         const nsAString *aValue);
    1:   nsresult SetInlinePropertyOnNode( nsIDOMNode *aNode,
    1:                                     nsIAtom *aProperty, 
    1:                                     const nsAString *aAttribute,
    1:                                     const nsAString *aValue);
    1: 
    1:   nsresult PromoteInlineRange(nsIDOMRange *inRange);
    1:   nsresult PromoteRangeIfStartsOrEndsInNamedAnchor(nsIDOMRange *inRange);
    1:   nsresult SplitStyleAboveRange(nsIDOMRange *aRange, 
    1:                                 nsIAtom *aProperty, 
    1:                                 const nsAString *aAttribute);
    1:   nsresult SplitStyleAbovePoint(nsCOMPtr<nsIDOMNode> *aNode,
    1:                                 PRInt32 *aOffset,
    1:                                 nsIAtom *aProperty, 
    1:                                 const nsAString *aAttribute,
    1:                                 nsCOMPtr<nsIDOMNode> *outLeftNode = nsnull,
    1:                                 nsCOMPtr<nsIDOMNode> *outRightNode = nsnull);
    1:   nsresult ApplyDefaultProperties();
    1:   nsresult RemoveStyleInside(nsIDOMNode *aNode, 
    1:                              nsIAtom *aProperty, 
    1:                              const nsAString *aAttribute, 
    1:                              PRBool aChildrenOnly = PR_FALSE);
    1:   nsresult RemoveInlinePropertyImpl(nsIAtom *aProperty, const nsAString *aAttribute);
    1: 
    1:   PRBool NodeIsProperty(nsIDOMNode *aNode);
    1:   PRBool HasAttr(nsIDOMNode *aNode, const nsAString *aAttribute);
    1:   PRBool HasAttrVal(nsIDOMNode *aNode, const nsAString *aAttribute, const nsAString *aValue);
    1:   PRBool IsAtFrontOfNode(nsIDOMNode *aNode, PRInt32 aOffset);
    1:   PRBool IsAtEndOfNode(nsIDOMNode *aNode, PRInt32 aOffset);
    1:   PRBool IsOnlyAttribute(nsIDOMNode *aElement, const nsAString *aAttribute);
    1: 
    1:   nsresult RemoveBlockContainer(nsIDOMNode *inNode);
    1:   nsresult GetPriorHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode);
    1:   nsresult GetPriorHTMLSibling(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode);
    1:   nsresult GetNextHTMLSibling(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode);
    1:   nsresult GetNextHTMLSibling(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode);
    1:   nsresult GetPriorHTMLNode(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode, PRBool bNoBlockCrossing = PR_FALSE);
    1:   nsresult GetPriorHTMLNode(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode, PRBool bNoBlockCrossing = PR_FALSE);
    1:   nsresult GetNextHTMLNode(nsIDOMNode *inNode, nsCOMPtr<nsIDOMNode> *outNode, PRBool bNoBlockCrossing = PR_FALSE);
    1:   nsresult GetNextHTMLNode(nsIDOMNode *inParent, PRInt32 inOffset, nsCOMPtr<nsIDOMNode> *outNode, PRBool bNoBlockCrossing = PR_FALSE);
    1: 
    1:   nsresult IsFirstEditableChild( nsIDOMNode *aNode, PRBool *aOutIsFirst);
    1:   nsresult IsLastEditableChild( nsIDOMNode *aNode, PRBool *aOutIsLast);
    1:   nsresult GetFirstEditableChild( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutFirstChild);
    1:   nsresult GetLastEditableChild( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutLastChild);
    1: 
    1:   nsresult GetFirstEditableLeaf( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutFirstLeaf);
    1:   nsresult GetLastEditableLeaf( nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutLastLeaf);
    1: 
    1:   //XXX Kludge: Used to suppress spurious drag/drop events (bug 50703)
    1:   PRBool   mIgnoreSpuriousDragEvent;
    1: 
    1:   nsresult GetInlinePropertyBase(nsIAtom *aProperty, 
    1:                              const nsAString *aAttribute,
    1:                              const nsAString *aValue,
    1:                              PRBool *aFirst, 
    1:                              PRBool *aAny, 
    1:                              PRBool *aAll,
    1:                              nsAString *outValue,
    1:                              PRBool aCheckDefaults = PR_TRUE);
    1:   nsresult HasStyleOrIdOrClass(nsIDOMElement * aElement, PRBool *aHasStyleOrIdOrClass);
    1:   nsresult RemoveElementIfNoStyleOrIdOrClass(nsIDOMElement * aElement, nsIAtom * aTag);
    1: 
41886:   // Whether the outer window of the DOM event target has focus or not.
41886:   PRBool   OurWindowHasFocus();
41886: 
54661:   // This function is used to insert a string of HTML input optionally with some
54661:   // context information into the editable field.  The HTML input either comes
54661:   // from a transferable object created as part of a drop/paste operation, or from
54661:   // the InsertHTML method.  We may want the HTML input to be sanitized (for example,
54661:   // if it's coming from a transferable object), in which case aTrustedInput should
54661:   // be set to false, otherwise, the caller should set it to true, which means that
54661:   // the HTML will be inserted in the DOM verbatim.
54661:   nsresult DoInsertHTMLWithContext(const nsAString& aInputString,
54661:                                    const nsAString& aContextStr,
54661:                                    const nsAString& aInfoStr,
54661:                                    const nsAString& aFlavor,
54661:                                    nsIDOMDocument* aSourceDoc,
54661:                                    nsIDOMNode* aDestNode,
54661:                                    PRInt32 aDestOffset,
54661:                                    PRBool aDeleteSelection,
54661:                                    PRBool aTrustedInput);
54661: 
    1: // Data members
    1: protected:
    1: 
    1:   nsCOMArray<nsIContentFilter> mContentFilters;
    1: 
57958:   nsRefPtr<TypeInState>        mTypeInState;
    1: 
    1:   PRPackedBool mCRInParagraphCreatesParagraph;
    1: 
    1:   PRPackedBool mCSSAware;
57958:   nsAutoPtr<nsHTMLCSSUtils> mHTMLCSSUtils;
    1: 
    1:   // Used by GetFirstSelectedCell and GetNextSelectedCell
    1:   PRInt32  mSelectedCellIndex;
    1: 
    1:   nsString mLastStyleSheetURL;
    1:   nsString mLastOverrideStyleSheetURL;
    1: 
    1:   // Maintain a list of associated style sheets and their urls.
23904:   nsTArray<nsString> mStyleSheetURLs;
42163:   nsTArray<nsRefPtr<nsCSSStyleSheet> > mStyleSheets;
    1:   
    1:   // an array for holding default style settings
27986:   nsTArray<PropItem*> mDefaultStyles;
    1: 
    1:    // for real-time spelling
    1:    nsCOMPtr<nsITextServicesDocument> mTextServices;
    1: 
    1:   // And a static range utils service
    1:   static nsIRangeUtils* sRangeHelper;
    1: 
    1: public:
    1:   // ... which means that we need to listen to shutdown
    1:   static void Shutdown();
    1: 
    1: protected:
    1: 
    1:   /* ANONYMOUS UTILS */
    1:   void     RemoveListenerAndDeleteRef(const nsAString& aEvent,
    1:                                       nsIDOMEventListener* aListener,
    1:                                       PRBool aUseCapture,
    1:                                       nsIDOMElement* aElement,
    1:                                       nsIContent* aParentContent,
    1:                                       nsIPresShell* aShell);
    1:   void     DeleteRefToAnonymousNode(nsIDOMElement* aElement,
    1:                                     nsIContent * aParentContent,
    1:                                     nsIPresShell* aShell);
10522: 
27288:   nsresult ShowResizersInner(nsIDOMElement *aResizedElement);
27288: 
10522:   // Returns the offset of an element's frame to its absolute containing block.
    1:   nsresult GetElementOrigin(nsIDOMElement * aElement, PRInt32 & aX, PRInt32 & aY);
    1:   nsresult GetPositionAndDimensions(nsIDOMElement * aElement,
    1:                                     PRInt32 & aX, PRInt32 & aY,
    1:                                     PRInt32 & aW, PRInt32 & aH,
    1:                                     PRInt32 & aBorderLeft,
    1:                                     PRInt32 & aBorderTop,
    1:                                     PRInt32 & aMarginLeft,
    1:                                     PRInt32 & aMarginTop);
    1: 
    1:   /* PACKED BOOLEANS FOR RESIZING, ABSOLUTE POSITIONING AND */
    1:   /* INLINE TABLE EDITING */
    1: 
    1:   // resizing
    1:   PRPackedBool mIsObjectResizingEnabled;
    1:   PRPackedBool mIsResizing;
    1:   PRPackedBool mPreserveRatio;
    1:   PRPackedBool mResizedObjectIsAnImage;
    1: 
    1:   // absolute positioning
    1:   PRPackedBool mIsAbsolutelyPositioningEnabled;
    1:   PRPackedBool mResizedObjectIsAbsolutelyPositioned;
    1: 
    1:   PRPackedBool mGrabberClicked;
    1:   PRPackedBool mIsMoving;
    1: 
    1:   PRPackedBool mSnapToGridEnabled;
    1: 
    1:   // inline table editing
    1:   PRPackedBool mIsInlineTableEditingEnabled;
    1: 
    1:   /* RESIZING */
    1: 
    1:   nsCOMPtr<nsIDOMElement> mTopLeftHandle;
    1:   nsCOMPtr<nsIDOMElement> mTopHandle;
    1:   nsCOMPtr<nsIDOMElement> mTopRightHandle;
    1:   nsCOMPtr<nsIDOMElement> mLeftHandle;
    1:   nsCOMPtr<nsIDOMElement> mRightHandle;
    1:   nsCOMPtr<nsIDOMElement> mBottomLeftHandle;
    1:   nsCOMPtr<nsIDOMElement> mBottomHandle;
    1:   nsCOMPtr<nsIDOMElement> mBottomRightHandle;
    1: 
    1:   nsCOMPtr<nsIDOMElement> mActivatedHandle;
    1: 
    1:   nsCOMPtr<nsIDOMElement> mResizingShadow;
    1:   nsCOMPtr<nsIDOMElement> mResizingInfo;
    1: 
    1:   nsCOMPtr<nsIDOMElement> mResizedObject;
    1: 
    1:   nsCOMPtr<nsIDOMEventListener>  mMouseMotionListenerP;
    1:   nsCOMPtr<nsISelectionListener> mSelectionListenerP;
    1:   nsCOMPtr<nsIDOMEventListener>  mResizeEventListenerP;
    1: 
    1:   nsCOMArray<nsIHTMLObjectResizeListener> objectResizeEventListeners;
    1: 
    1:   PRInt32 mOriginalX;
    1:   PRInt32 mOriginalY;
    1: 
    1:   PRInt32 mResizedObjectX;
    1:   PRInt32 mResizedObjectY;
    1:   PRInt32 mResizedObjectWidth;
    1:   PRInt32 mResizedObjectHeight;
    1: 
    1:   PRInt32 mResizedObjectMarginLeft;
    1:   PRInt32 mResizedObjectMarginTop;
    1:   PRInt32 mResizedObjectBorderLeft;
    1:   PRInt32 mResizedObjectBorderTop;
    1: 
    1:   PRInt32 mXIncrementFactor;
    1:   PRInt32 mYIncrementFactor;
    1:   PRInt32 mWidthIncrementFactor;
    1:   PRInt32 mHeightIncrementFactor;
    1: 
    1:   PRInt8  mInfoXIncrement;
    1:   PRInt8  mInfoYIncrement;
    1: 
    1:   nsresult SetAllResizersPosition();
    1: 
    1:   nsresult CreateResizer(nsIDOMElement ** aReturn, PRInt16 aLocation, nsIDOMNode * aParentNode);
    1:   void     SetAnonymousElementPosition(PRInt32 aX, PRInt32 aY, nsIDOMElement *aResizer);
    1: 
    1:   nsresult CreateShadow(nsIDOMElement ** aReturn, nsIDOMNode * aParentNode,
    1:                         nsIDOMElement * aOriginalObject);
    1:   nsresult SetShadowPosition(nsIDOMElement * aShadow,
    1:                              nsIDOMElement * aOriginalObject,
    1:                              PRInt32 aOriginalObjectX,
    1:                              PRInt32 aOriginalObjectY);
    1: 
    1:   nsresult CreateResizingInfo(nsIDOMElement ** aReturn, nsIDOMNode * aParentNode);
    1:   nsresult SetResizingInfoPosition(PRInt32 aX, PRInt32 aY,
    1:                                    PRInt32 aW, PRInt32 aH);
    1: 
    1:   PRInt32  GetNewResizingIncrement(PRInt32 aX, PRInt32 aY, PRInt32 aID);
    1:   nsresult StartResizing(nsIDOMElement * aHandle);
    1:   PRInt32  GetNewResizingX(PRInt32 aX, PRInt32 aY);
    1:   PRInt32  GetNewResizingY(PRInt32 aX, PRInt32 aY);
    1:   PRInt32  GetNewResizingWidth(PRInt32 aX, PRInt32 aY);
    1:   PRInt32  GetNewResizingHeight(PRInt32 aX, PRInt32 aY);
    1:   void     HideShadowAndInfo();
    1:   void     SetFinalSize(PRInt32 aX, PRInt32 aY);
    1:   void     DeleteRefToAnonymousNode(nsIDOMNode * aNode);
    1:   void     SetResizeIncrements(PRInt32 aX, PRInt32 aY, PRInt32 aW, PRInt32 aH, PRBool aPreserveRatio);
62878:   void     HideAnonymousEditingUIs();
    1: 
    1:   /* ABSOLUTE POSITIONING */
    1: 
    1:   PRInt32 mPositionedObjectX;
    1:   PRInt32 mPositionedObjectY;
    1:   PRInt32 mPositionedObjectWidth;
    1:   PRInt32 mPositionedObjectHeight;
    1: 
    1:   PRInt32 mPositionedObjectMarginLeft;
    1:   PRInt32 mPositionedObjectMarginTop;
    1:   PRInt32 mPositionedObjectBorderLeft;
    1:   PRInt32 mPositionedObjectBorderTop;
    1: 
    1:   nsCOMPtr<nsIDOMElement> mAbsolutelyPositionedObject;
    1:   nsCOMPtr<nsIDOMElement> mGrabber;
    1:   nsCOMPtr<nsIDOMElement> mPositioningShadow;
    1: 
    1:   PRInt32      mGridSize;
    1: 
    1:   nsresult CreateGrabber(nsIDOMNode * aParentNode, nsIDOMElement ** aReturn);
    1:   nsresult StartMoving(nsIDOMElement * aHandle);
    1:   nsresult SetFinalPosition(PRInt32 aX, PRInt32 aY);
42606:   void     AddPositioningOffset(PRInt32 & aX, PRInt32 & aY);
    1:   void     SnapToGrid(PRInt32 & newX, PRInt32 & newY);
    1:   nsresult GrabberClicked();
    1:   nsresult EndMoving();
    1:   nsresult CheckPositionedElementBGandFG(nsIDOMElement * aElement,
    1:                                          nsAString & aReturn);
    1: 
    1:   /* INLINE TABLE EDITING */
    1: 
    1:   nsCOMPtr<nsIDOMElement> mInlineEditedCell;
    1: 
    1:   nsCOMPtr<nsIDOMElement> mAddColumnBeforeButton;
    1:   nsCOMPtr<nsIDOMElement> mRemoveColumnButton;
    1:   nsCOMPtr<nsIDOMElement> mAddColumnAfterButton;
    1: 
    1:   nsCOMPtr<nsIDOMElement> mAddRowBeforeButton;
    1:   nsCOMPtr<nsIDOMElement> mRemoveRowButton;
    1:   nsCOMPtr<nsIDOMElement> mAddRowAfterButton;
    1: 
    1:   void     AddMouseClickListener(nsIDOMElement * aElement);
    1:   void     RemoveMouseClickListener(nsIDOMElement * aElement);
    1: 
    1:   nsCOMPtr<nsILinkHandler> mLinkHandler;
    1: 
    1: public:
    1: 
    1: // friends
    1: friend class nsHTMLEditRules;
    1: friend class nsTextEditRules;
    1: friend class nsWSRunObject;
    1: 
    1: };
    1: #endif //nsHTMLEditor_h__
    1: 
