53178: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
53178:  * vim: set ts=4 sw=4 et tw=99:
53178:  *
53178:  * ***** BEGIN LICENSE BLOCK *****
53168:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
53168:  *
53168:  * The contents of this file are subject to the Mozilla Public License Version
53168:  * 1.1 (the "License"); you may not use this file except in compliance with
53168:  * the License. You may obtain a copy of the License at
53168:  * http://www.mozilla.org/MPL/
53168:  *
53168:  * Software distributed under the License is distributed on an "AS IS" basis,
53168:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
53168:  * for the specific language governing rights and limitations under the
53168:  * License.
53168:  *
53168:  * The Original Code is Mozilla Jaegermonkey.
53168:  *
53168:  * The Initial Developer of the Original Code is the Mozilla Foundation.
53168:  *
53168:  * Portions created by the Initial Developer are Copyright (C) 2010
53168:  * the Initial Developer. All Rights Reserved.
53168:  *
53168:  * Contributor(s):
53168:  *   Andrew Drake <drakedevel@gmail.com>
53168:  *
53168:  * Alternatively, the contents of this file may be used under the terms of
53168:  * either the GNU General Public License Version 2 or later (the "GPL"), or
53168:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
53168:  * in which case the provisions of the GPL or the LGPL are applicable instead
53168:  * of those above. If you wish to allow use of your version of this file only
53168:  * under the terms of either the GPL or the LGPL, and not to allow others to
53168:  * use your version of this file under the terms of the MPL, indicate your
53168:  * decision by deleting the provisions above and replace them with the notice
53168:  * and other provisions required by the GPL or the LGPL. If you do not delete
53168:  * the provisions above, a recipient may use your version of this file under
53168:  * the terms of any one of the MPL, the GPL or the LGPL.
53168:  *
53168:  * ***** END LICENSE BLOCK ***** */
53168: 
53168: #ifdef JS_METHODJIT
53178: 
53168: #include "Retcon.h"
53168: #include "MethodJIT.h"
53168: #include "Compiler.h"
76185: #include "StubCalls.h"
53168: #include "jsdbgapi.h"
53168: #include "jsnum.h"
76185: #include "assembler/assembler/LinkBuffer.h"
76185: #include "assembler/assembler/RepatchBuffer.h"
53168: 
53168: #include "jscntxtinlines.h"
76185: #include "jsinterpinlines.h"
76185: 
53168: using namespace js;
53168: using namespace js::mjit;
53168: 
53168: namespace js {
53168: namespace mjit {
53168: 
76185: static inline void
76185: SetRejoinState(StackFrame *fp, const CallSite &site, void **location)
76185: {
76185:     if (site.rejoin == REJOIN_SCRIPTED) {
76185:         fp->setRejoin(ScriptedRejoin(site.pcOffset));
76185:         *location = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted);
76185:     } else {
76185:         fp->setRejoin(StubRejoin(site.rejoin));
76185:         *location = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline);
76185:     }
76185: }
76185: 
78455: static inline bool
84755: CallsiteMatches(uint8_t *codeStart, const CallSite &site, void *location)
78455: {
78455:     if (codeStart + site.codeOffset == location)
78455:         return true;
78455: 
78455: #ifdef JS_CPU_ARM
78455:     if (codeStart + site.codeOffset + 4 == location)
78455:         return true;
78455: #endif
78455: 
78455:     return false;
78455: }
78455: 
76185: void
87654: Recompiler::patchCall(JITChunk *chunk, StackFrame *fp, void **location)
76020: {
87654:     uint8_t* codeStart = (uint8_t *)chunk->code.m_code.executableAddress();
76185: 
87654:     CallSite *callSites_ = chunk->callSites();
87654:     for (uint32_t i = 0; i < chunk->nCallSites; i++) {
78455:         if (CallsiteMatches(codeStart, callSites_[i], *location)) {
76185:             JS_ASSERT(callSites_[i].inlineIndex == analyze::CrossScriptSSA::OUTER_FRAME);
76185:             SetRejoinState(fp, callSites_[i], location);
76185:             return;
76206:         }
76020:     }
76020: 
76206:     JS_NOT_REACHED("failed to find call site");
76020: }
76020: 
76020: void
87654: Recompiler::patchNative(JSCompartment *compartment, JITChunk *chunk, StackFrame *fp,
78454:                         jsbytecode *pc, RejoinState rejoin)
53168: {
76185:     /*
78454:      * There is a native call or getter IC at pc which triggered recompilation.
78454:      * The recompilation could have been triggered either by the native call
78454:      * itself, or by a SplatApplyArgs preparing for the native call. Either
78454:      * way, we don't want to patch up the call, but will instead steal the pool
87654:      * for the IC so it doesn't get freed with the JITChunk, and patch up the
78454:      * jump at the end to go to the interpoline.
78454:      *
87654:      * When doing this, we do not reset the the IC itself; the JITChunk must
78454:      * be dead and about to be released due to the recompilation (or a GC).
76185:      */
76185:     fp->setRejoin(StubRejoin(rejoin));
76185: 
76185:     /* :XXX: We might crash later if this fails. */
77353:     compartment->jaegerCompartment()->orphanedNativeFrames.append(fp);
76185: 
78454:     DebugOnly<bool> found = false;
78454: 
78413:     /*
78454:      * Find and patch all native call stubs attached to the given PC. There may
78454:      * be multiple ones for getter stubs attached to e.g. a GETELEM.
78413:      */
87654:     for (unsigned i = 0; i < chunk->nativeCallStubs.length(); i++) {
87654:         NativeCallStub &stub = chunk->nativeCallStubs[i];
78454:         if (stub.pc != pc)
78454:             continue;
78360: 
78454:         found = true;
76185: 
78454:         /* Check for pools that were already patched. */
78454:         if (!stub.pool)
78454:             continue;
76185: 
76185:         /* Patch the native fallthrough to go to the interpoline. */
76185:         {
77389: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
76185:             /* Win64 needs stack adjustment */
76185:             void *interpoline = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolinePatched);
76185: #else
76185:             void *interpoline = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline);
76185: #endif
84755:             uint8_t *start = (uint8_t *)stub.jump.executableAddress();
76185:             JSC::RepatchBuffer repatch(JSC::JITCode(start - 32, 64));
76185: #ifdef JS_CPU_X64
78454:             repatch.repatch(stub.jump, interpoline);
76185: #else
78454:             repatch.relink(stub.jump, JSC::CodeLocationLabel(interpoline));
76185: #endif
76185:         }
76185: 
76185:         /* :XXX: We leak the pool if this fails. Oh well. */
78454:         compartment->jaegerCompartment()->orphanedNativePools.append(stub.pool);
76185: 
76185:         /* Mark as stolen in case there are multiple calls on the stack. */
78454:         stub.pool = NULL;
78454:     }
78454: 
78454:     JS_ASSERT(found);
76185: }
76185: 
77353: void
77353: Recompiler::patchFrame(JSCompartment *compartment, VMFrame *f, JSScript *script)
77353: {
77353:     /*
77353:      * Check if the VMFrame returns directly into the script's jitcode. This
77353:      * depends on the invariant that f->fp() reflects the frame at the point
77353:      * where the call occurred, irregardless of any frames which were pushed
77353:      * inside the call.
77353:      */
77353:     StackFrame *fp = f->fp();
77353:     void **addr = f->returnAddressLocation();
77353:     RejoinState rejoin = (RejoinState) f->stubRejoin;
77353:     if (rejoin == REJOIN_NATIVE ||
78454:         rejoin == REJOIN_NATIVE_LOWERED ||
78454:         rejoin == REJOIN_NATIVE_GETTER) {
77353:         /* Native call. */
77353:         if (fp->script() == script) {
87654:             patchNative(compartment, fp->jit()->chunk(f->regs.pc), fp, f->regs.pc, rejoin);
77353:             f->stubRejoin = REJOIN_NATIVE_PATCHED;
77353:         }
77353:     } else if (rejoin == REJOIN_NATIVE_PATCHED) {
77353:         /* Already patched, don't do anything. */
77353:     } else if (rejoin) {
77353:         /* Recompilation triggered by CompileFunction. */
77353:         if (fp->script() == script) {
77353:             fp->setRejoin(StubRejoin(rejoin));
77353:             *addr = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline);
77353:             f->stubRejoin = 0;
77353:         }
87654:     } else {
94809:         if (script->jitHandleCtor.isValid()) {
94809:             JITChunk *chunk = script->jitHandleCtor.getValid()->findCodeChunk(*addr);
87654:             if (chunk)
87654:                 patchCall(chunk, fp, addr);
87654:         }
94809:         if (script->jitHandleNormal.isValid()) {
94809:             JITChunk *chunk = script->jitHandleNormal.getValid()->findCodeChunk(*addr);
87654:             if (chunk)
87654:                 patchCall(chunk, fp, addr);
87654:         }
77353:     }
77353: }
77353: 
76185: StackFrame *
77353: Recompiler::expandInlineFrameChain(StackFrame *outer, InlineFrame *inner)
76185: {
76185:     StackFrame *parent;
76185:     if (inner->parent)
77353:         parent = expandInlineFrameChain(outer, inner->parent);
76185:     else
76185:         parent = outer;
76185: 
76185:     JaegerSpew(JSpew_Recompile, "Expanding inline frame\n");
76185: 
84755:     StackFrame *fp = (StackFrame *) ((uint8_t *)outer + sizeof(Value) * inner->depth);
76185:     fp->initInlineFrame(inner->fun, parent, inner->parentpc);
84755:     uint32_t pcOffset = inner->parentpc - parent->script()->code;
76185: 
76185:     void **location = fp->addressOfNativeReturnAddress();
76185:     *location = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted);
76185:     parent->setRejoin(ScriptedRejoin(pcOffset));
76185: 
76185:     return fp;
76185: }
76185: 
76185: /*
76185:  * Whether a given return address for a frame indicates it returns directly
76185:  * into JIT code.
76185:  */
76185: static inline bool
76185: JITCodeReturnAddress(void *data)
76185: {
76185:     return data != NULL  /* frame is interpreted */
76185:         && data != JS_FUNC_TO_DATA_PTR(void *, JaegerTrampolineReturn)
76185:         && data != JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline)
77389: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
76185:         && data != JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolinePatched)
76185: #endif
76185:         && data != JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted);
76185: }
76185: 
76185: /*
76185:  * Expand all inlined frames within fp per 'inlined' and update next and regs
76185:  * to refer to the new innermost frame.
76185:  */
76185: void
77353: Recompiler::expandInlineFrames(JSCompartment *compartment,
77353:                                StackFrame *fp, mjit::CallSite *inlined,
76185:                                StackFrame *next, VMFrame *f)
76185: {
76185:     JS_ASSERT_IF(next, next->prev() == fp && next->prevInline() == inlined);
76185: 
76185:     /*
76185:      * Treat any frame expansion as a recompilation event, so that f.jit() is
76185:      * stable if no recompilations have occurred.
76185:      */
77353:     compartment->types.frameExpansions++;
76185: 
87654:     jsbytecode *pc = next ? next->prevpc(NULL) : f->regs.pc;
87654:     JITChunk *chunk = fp->jit()->chunk(pc);
87654: 
76185:     /*
76185:      * Patch the VMFrame's return address if it is returning at the given inline site.
76185:      * Note there is no worry about handling a native or CompileFunction call here,
76185:      * as such IC stubs are not generated within inline frames.
76185:      */
76185:     void **frameAddr = f->returnAddressLocation();
87654:     uint8_t* codeStart = (uint8_t *)chunk->code.m_code.executableAddress();
76185: 
87654:     InlineFrame *inner = &chunk->inlineFrames()[inlined->inlineIndex];
76185:     jsbytecode *innerpc = inner->fun->script()->code + inlined->pcOffset;
76185: 
77353:     StackFrame *innerfp = expandInlineFrameChain(fp, inner);
76185: 
76185:     /* Check if the VMFrame returns into the inlined frame. */
76185:     if (f->stubRejoin && f->fp() == fp) {
76185:         /* The VMFrame is calling CompileFunction. */
78413:         JS_ASSERT(f->stubRejoin != REJOIN_NATIVE &&
78413:                   f->stubRejoin != REJOIN_NATIVE_LOWERED &&
78454:                   f->stubRejoin != REJOIN_NATIVE_GETTER &&
78413:                   f->stubRejoin != REJOIN_NATIVE_PATCHED);
78413:         innerfp->setRejoin(StubRejoin((RejoinState) f->stubRejoin));
76185:         *frameAddr = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpoline);
76185:         f->stubRejoin = 0;
76185:     }
78455:     if (CallsiteMatches(codeStart, *inlined, *frameAddr)) {
76185:         /* The VMFrame returns directly into the expanded frame. */
76185:         SetRejoinState(innerfp, *inlined, frameAddr);
76185:     }
76185: 
76185:     if (f->fp() == fp) {
76185:         JS_ASSERT(f->regs.inlined() == inlined);
76185:         f->regs.expandInline(innerfp, innerpc);
76185:     }
76185: 
76185:     /*
76185:      * Note: unlike the case for recompilation, during frame expansion we don't
76185:      * need to worry about the next VMFrame holding a reference to the inlined
76185:      * frame in its entryncode. entryncode is non-NULL only if the next frame's
76185:      * code was discarded and has executed via the Interpoline, which can only
76185:      * happen after all inline frames have been expanded.
76185:      */
76185: 
76185:     if (next) {
76185:         next->resetInlinePrev(innerfp, innerpc);
76185:         void **addr = next->addressOfNativeReturnAddress();
76185:         if (JITCodeReturnAddress(*addr)) {
76185:             innerfp->setRejoin(ScriptedRejoin(inlined->pcOffset));
76185:             *addr = JS_FUNC_TO_DATA_PTR(void *, JaegerInterpolineScripted);
76185:         }
76185:     }
76185: }
76185: 
76185: void
77398: ExpandInlineFrames(JSCompartment *compartment)
76185: {
77353:     if (!compartment || !compartment->hasJaegerCompartment())
76185:         return;
76185: 
77353:     for (VMFrame *f = compartment->jaegerCompartment()->activeFrame();
76185:          f != NULL;
76185:          f = f->previous) {
76185: 
77353:         if (f->regs.inlined())
77353:             mjit::Recompiler::expandInlineFrames(compartment, f->fp(), f->regs.inlined(), NULL, f);
76185: 
76185:         StackFrame *end = f->entryfp->prev();
76185:         StackFrame *next = NULL;
76185:         for (StackFrame *fp = f->fp(); fp != end; fp = fp->prev()) {
77353:             if (!next) {
77353:                 next = fp;
77353:                 continue;
77353:             }
76185:             mjit::CallSite *inlined;
77353:             next->prevpc(&inlined);
77353:             if (inlined) {
77353:                 mjit::Recompiler::expandInlineFrames(compartment, fp, inlined, next, f);
76185:                 fp = next;
76185:                 next = NULL;
76185:             } else {
76185:                 if (fp->downFramesExpanded())
76185:                     break;
76185:                 next = fp;
76185:             }
76185:             fp->setDownFramesExpanded();
76185:         }
76185:     }
76206: }
76206: 
77353: void
77353: ClearAllFrames(JSCompartment *compartment)
77353: {
77353:     if (!compartment || !compartment->hasJaegerCompartment())
77353:         return;
77353: 
77398:     ExpandInlineFrames(compartment);
77353: 
95080:     compartment->types.recompilations++;
95080: 
77353:     for (VMFrame *f = compartment->jaegerCompartment()->activeFrame();
77353:          f != NULL;
77353:          f = f->previous) {
77353: 
77382:         Recompiler::patchFrame(compartment, f, f->fp()->script());
77353: 
77382:         // Clear ncode values from all frames associated with the VMFrame.
77382:         // Patching the VMFrame's return address will cause all its frames to
77382:         // finish in the interpreter, unless the interpreter enters one of the
77382:         // intermediate frames at a loop boundary (where EnterMethodJIT will
77382:         // overwrite ncode). However, leaving stale values for ncode in stack
77382:         // frames can confuse the recompiler, which may see the VMFrame before
77382:         // it has resumed execution.
77382: 
77382:         for (StackFrame *fp = f->fp(); fp != f->entryfp; fp = fp->prev())
77382:             fp->setNativeReturnAddress(NULL);
77353:     }
53168: }
53168: 
53168: /*
76185:  * Recompilation can be triggered either by the debugger (turning debug mode on for
76185:  * a script or setting/clearing a trap), or by dynamic changes in type information
76185:  * from type inference. When recompiling we don't immediately recompile the JIT
76185:  * code, but destroy the old code and remove all references to the code, including
76185:  * those from active stack frames. Things to do:
76185:  *
76185:  * - Purge scripted call inline caches calling into the script.
76185:  *
76185:  * - For frames with an ncode return address in the original script, redirect
76185:  *   to the interpoline.
76185:  *
76185:  * - For VMFrames with a stub call return address in the original script,
76185:  *   redirect to the interpoline.
76185:  *
76185:  * - For VMFrames whose entryncode address (the value of entryfp->ncode before
76185:  *   being clobbered with JaegerTrampolineReturn) is in the original script,
76185:  *   redirect that entryncode to the interpoline.
76185:  */
76185: void
94740: Recompiler::clearStackReferences(FreeOp *fop, JSScript *script)
76185: {
76185:     JS_ASSERT(script->hasJITCode());
76185: 
76185:     JaegerSpew(JSpew_Recompile, "recompiling script (file \"%s\") (line \"%d\") (length \"%d\")\n",
76185:                script->filename, script->lineno, script->length);
76185: 
94740:     JSCompartment *comp = script->compartment();
94740:     types::AutoEnterTypeInference enter(fop, comp);
76185: 
76185:     /*
53168:      * The strategy for this goes as follows:
53168:      * 
53168:      * 1) Scan the stack, looking at all return addresses that could go into JIT
53168:      *    code.
53168:      * 2) If an address corresponds to a call site registered by |callSite| during
76185:      *    the last compilation, patch it to go to the interpoline.
76185:      * 3) Purge the old compiled state.
53168:      */
56854: 
56854:     // Find all JIT'd stack frames to account for return addresses that will
56854:     // need to be patched after recompilation.
94740:     for (VMFrame *f = comp->jaegerCompartment()->activeFrame();
56854:          f != NULL;
56854:          f = f->previous) {
56854: 
56854:         // Scan all frames owned by this VMFrame.
69223:         StackFrame *end = f->entryfp->prev();
76185:         StackFrame *next = NULL;
69223:         for (StackFrame *fp = f->fp(); fp != end; fp = fp->prev()) {
76185:             if (fp->script() != script) {
76185:                 next = fp;
76185:                 continue;
53168:             }
53168: 
76185:             if (next) {
76185:                 // check for a scripted call returning into the recompiled script.
76185:                 // this misses scanning the entry fp, which cannot return directly
76185:                 // into JIT code.
76185:                 void **addr = next->addressOfNativeReturnAddress();
76185: 
76185:                 if (JITCodeReturnAddress(*addr)) {
87654:                     JITChunk *chunk = fp->jit()->findCodeChunk(*addr);
87654:                     patchCall(chunk, fp, addr);
53168:                 }
53391:             }
53168: 
76185:             next = fp;
57766:         }
55503: 
94740:         patchFrame(comp, f, script);
57766:     }
55503: 
94740:     comp->types.recompilations++;
76185: }
76185: 
87983: void
94740: Recompiler::clearStackReferencesAndChunk(FreeOp *fop, JSScript *script,
87983:                                          JITScript *jit, size_t chunkIndex,
87983:                                          bool resetUses)
87983: {
94740:     Recompiler::clearStackReferences(fop, script);
87983: 
87983:     bool releaseChunk = true;
87983:     if (jit->nchunks > 1) {
87983:         // If we are in the middle of a native call from a native or getter IC,
87983:         // we need to make sure all JIT code for the script is purged, as
87983:         // otherwise we will have orphaned the native stub but pointers to it
87983:         // still exist in the containing chunk.
94740:         for (VMFrame *f = script->compartment()->jaegerCompartment()->activeFrame();
87983:              f != NULL;
87983:              f = f->previous) {
87983:             if (f->fp()->script() == script) {
87983:                 JS_ASSERT(f->stubRejoin != REJOIN_NATIVE &&
87983:                           f->stubRejoin != REJOIN_NATIVE_LOWERED &&
87983:                           f->stubRejoin != REJOIN_NATIVE_GETTER);
87983:                 if (f->stubRejoin == REJOIN_NATIVE_PATCHED) {
94740:                     mjit::ReleaseScriptCode(fop, script);
87983:                     releaseChunk = false;
87983:                     break;
87983:                 }
87983:             }
87983:         }
87983:     }
87983: 
87983:     if (releaseChunk)
94740:         jit->destroyChunk(fop, chunkIndex, resetUses);
87983: }
87983: 
53170: } /* namespace mjit */
53170: } /* namespace js */
53168: 
53178: #endif /* JS_METHODJIT */
53178: 
