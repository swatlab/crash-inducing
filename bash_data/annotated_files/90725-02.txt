80946: /* ***** BEGIN LICENSE BLOCK *****
80946:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
80946:  *
80946:  * The contents of this file are subject to the Mozilla Public License Version
80946:  * 1.1 (the "License"); you may not use this file except in compliance with
80946:  * the License. You may obtain a copy of the License at
80946:  * http://www.mozilla.org/MPL/
80946:  *
80946:  * Software distributed under the License is distributed on an "AS IS" basis,
80946:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
80946:  * for the specific language governing rights and limitations under the
80946:  * License.
80946:  *
80946:  * The Original Code is Places code.
80946:  *
80946:  * The Initial Developer of the Original Code is
80946:  * the Mozilla Foundation.
80946:  * Portions created by the Initial Developer are Copyright (C) 2011
80946:  * the Initial Developer. All Rights Reserved.
80946:  *
80946:  * Contributor(s):
80946:  *   Marco Bonardo <mak77@bonardo.net>
80946:  *
80946:  * Original contributor(s) of code moved from nsNavHistory.cpp:
80946:  *   Brett Wilson <brettw@gmail.com> (original author)
80946:  *   Dietrich Ayala <dietrich@mozilla.com>
80946:  *   Seth Spitzer <sspitzer@mozilla.com>
80946:  *   Asaf Romano <mano@mozilla.com>
80946:  *   Marco Bonardo <mak77@bonardo.net>
80946:  *   Edward Lee <edward.lee@engineering.uiuc.edu>
80946:  *   Michael Ventnor <m.ventnor@gmail.com>
80946:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
80946:  *   Drew Willcoxon <adw@mozilla.com>
80946:  *   Philipp von Weitershausen <philipp@weitershausen.de>
80946:  *   Paolo Amadini <http://www.amadzone.org/>
83109:  *   Richard Newman <rnewman@mozilla.com>
80946:  *
80946:  * Alternatively, the contents of this file may be used under the terms of
80946:  * either the GNU General Public License Version 2 or later (the "GPL"), or
80946:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
80946:  * in which case the provisions of the GPL or the LGPL are applicable instead
80946:  * of those above. If you wish to allow use of your version of this file only
80946:  * under the terms of either the GPL or the LGPL, and not to allow others to
80946:  * use your version of this file under the terms of the MPL, indicate your
80946:  * decision by deleting the provisions above and replace them with the notice
80946:  * and other provisions required by the GPL or the LGPL. If you do not delete
80946:  * the provisions above, a recipient may use your version of this file under
80946:  * the terms of any one of the MPL, the GPL or the LGPL.
80946:  *
80946:  * ***** END LICENSE BLOCK ***** */
80946: 
80946: #include "Database.h"
80946: 
80946: #include "nsINavBookmarksService.h"
80946: #include "nsIInterfaceRequestorUtils.h"
80946: #include "nsILocalFile.h"
80946: 
80946: #include "nsNavHistory.h"
80946: #include "nsPlacesTables.h"
80946: #include "nsPlacesIndexes.h"
80946: #include "nsPlacesTriggers.h"
80946: #include "nsPlacesMacros.h"
80946: #include "SQLFunctions.h"
80946: #include "Helpers.h"
80946: 
80946: #include "nsAppDirectoryServiceDefs.h"
80946: #include "nsDirectoryServiceUtils.h"
80946: #include "prsystem.h"
80946: #include "nsPrintfCString.h"
80946: #include "mozilla/Util.h"
80946: #include "mozilla/Preferences.h"
80946: #include "mozilla/Services.h"
80946: 
80946: // Time between corrupt database backups.
80946: #define RECENT_BACKUP_TIME_MICROSEC (PRInt64)86400 * PR_USEC_PER_SEC // 24H
80946: 
80946: // Filename of the database.
80946: #define DATABASE_FILENAME NS_LITERAL_STRING("places.sqlite")
80946: // Filename used to backup corrupt databases.
80946: #define DATABASE_CORRUPT_FILENAME NS_LITERAL_STRING("places.sqlite.corrupt")
80946: 
80946: // Set when the database file was found corrupt by a previous maintenance.
80946: #define PREF_FORCE_DATABASE_REPLACEMENT "places.database.replaceOnStartup"
80946: 
80946: // Maximum size for the WAL file.  It should be small enough since in case of
80946: // crashes we could lose all the transactions in the file.  But a too small
80946: // file could hurt performance.
80946: #define DATABASE_MAX_WAL_SIZE_IN_KIBIBYTES 512
80946: 
80946: #define BYTES_PER_MEBIBYTE 1048576
80946: 
80946: // Old Sync GUID annotation.
80946: #define SYNCGUID_ANNO NS_LITERAL_CSTRING("sync/guid")
80946: 
84844: // Places string bundle, contains internationalized bookmark root names.
84844: #define PLACES_BUNDLE "chrome://places/locale/places.properties"
84844: 
80946: using namespace mozilla;
80946: 
80946: namespace mozilla {
80946: namespace places {
80946: 
80946: namespace {
80946: 
80946: ////////////////////////////////////////////////////////////////////////////////
80946: //// Helpers
80946: 
80946: /**
80946:  * Checks whether exists a database backup created not longer than
80946:  * RECENT_BACKUP_TIME_MICROSEC ago.
80946:  */
80946: bool
80946: hasRecentCorruptDB()
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946: 
80946:   nsCOMPtr<nsIFile> profDir;
80946:   NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR, getter_AddRefs(profDir));
80946:   NS_ENSURE_TRUE(profDir, false);
80946:   nsCOMPtr<nsISimpleEnumerator> entries;
80946:   profDir->GetDirectoryEntries(getter_AddRefs(entries));
80946:   NS_ENSURE_TRUE(entries, false);
80946:   bool hasMore;
80946:   while (NS_SUCCEEDED(entries->HasMoreElements(&hasMore)) && hasMore) {
80946:     nsCOMPtr<nsISupports> next;
80946:     entries->GetNext(getter_AddRefs(next));
80946:     NS_ENSURE_TRUE(next, false);
80946:     nsCOMPtr<nsIFile> currFile = do_QueryInterface(next);
80946:     NS_ENSURE_TRUE(currFile, false);
80946: 
80946:     nsAutoString leafName;
80946:     if (NS_SUCCEEDED(currFile->GetLeafName(leafName)) &&
80946:         leafName.Length() >= DATABASE_CORRUPT_FILENAME.Length() &&
80946:         leafName.Find(".corrupt", DATABASE_FILENAME.Length()) != -1) {
80946:       PRInt64 lastMod = 0;
80946:       currFile->GetLastModifiedTime(&lastMod);
80946:       NS_ENSURE_TRUE(lastMod > 0, false);
80946:       return (PR_Now() - lastMod) > RECENT_BACKUP_TIME_MICROSEC;
80946:     }
80946:   }
80946:   return false;
80946: }
80946: 
80946: /**
80946:  * Updates sqlite_stat1 table through ANALYZE.
80946:  * Since also nsPlacesExpiration.js executes ANALYZE, the analyzed tables
80946:  * must be the same in both components.  So ensure they are in sync.
80946:  *
80946:  * @param aDBConn
80946:  *        The database connection.
80946:  */
80946: nsresult
80946: updateSQLiteStatistics(mozIStorageConnection* aDBConn)
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   nsCOMPtr<mozIStorageAsyncStatement> analyzePlacesStmt;
80946:   aDBConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
80946:     "ANALYZE moz_places"
80946:   ), getter_AddRefs(analyzePlacesStmt));
80946:   NS_ENSURE_STATE(analyzePlacesStmt);
80946:   nsCOMPtr<mozIStorageAsyncStatement> analyzeBookmarksStmt;
80946:   aDBConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
80946:     "ANALYZE moz_bookmarks"
80946:   ), getter_AddRefs(analyzeBookmarksStmt));
80946:   NS_ENSURE_STATE(analyzeBookmarksStmt);
80946:   nsCOMPtr<mozIStorageAsyncStatement> analyzeVisitsStmt;
80946:   aDBConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
80946:     "ANALYZE moz_historyvisits"
80946:   ), getter_AddRefs(analyzeVisitsStmt));
80946:   NS_ENSURE_STATE(analyzeVisitsStmt);
80946:   nsCOMPtr<mozIStorageAsyncStatement> analyzeInputStmt;
80946:   aDBConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
80946:     "ANALYZE moz_inputhistory"
80946:   ), getter_AddRefs(analyzeInputStmt));
80946:   NS_ENSURE_STATE(analyzeInputStmt);
80946: 
80946:   mozIStorageBaseStatement *stmts[] = {
80946:     analyzePlacesStmt,
80946:     analyzeBookmarksStmt,
80946:     analyzeVisitsStmt,
80946:     analyzeInputStmt
80946:   };
80946: 
80946:   nsCOMPtr<mozIStoragePendingStatement> ps;
80946:   (void)aDBConn->ExecuteAsync(stmts, ArrayLength(stmts), nsnull,
80946:                               getter_AddRefs(ps));
80946:   return NS_OK;
80946: }
80946: 
80946: /**
80946:  * Sets the connection journal mode to one of the JOURNAL_* types.
80946:  *
80946:  * @param aDBConn
80946:  *        The database connection.
80946:  * @param aJournalMode
80946:  *        One of the JOURNAL_* types.
80946:  * @returns the current journal mode.
80946:  * @note this may return a different journal mode than the required one, since
80946:  *       setting it may fail.
80946:  */
80946: enum JournalMode
80946: SetJournalMode(nsCOMPtr<mozIStorageConnection>& aDBConn,
80946:                              enum JournalMode aJournalMode)
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   nsCAutoString journalMode;
80946:   switch (aJournalMode) {
80946:     default:
80946:       MOZ_ASSERT("Trying to set an unknown journal mode.");
80946:       // Fall through to the default DELETE journal.
80946:     case JOURNAL_DELETE:
80946:       journalMode.AssignLiteral("delete");
80946:       break;
80946:     case JOURNAL_TRUNCATE:
80946:       journalMode.AssignLiteral("truncate");
80946:       break;
80946:     case JOURNAL_MEMORY:
80946:       journalMode.AssignLiteral("memory");
80946:       break;
80946:     case JOURNAL_WAL:
80946:       journalMode.AssignLiteral("wal");
80946:       break;
80946:   }
80946: 
80946:   nsCOMPtr<mozIStorageStatement> statement;
86727:   nsCAutoString query(MOZ_STORAGE_UNIQUIFY_QUERY_STR
86727: 		      "PRAGMA journal_mode = ");
80946:   query.Append(journalMode);
80946:   aDBConn->CreateStatement(query, getter_AddRefs(statement));
80946:   NS_ENSURE_TRUE(statement, JOURNAL_DELETE);
80946: 
80946:   bool hasResult = false;
80946:   if (NS_SUCCEEDED(statement->ExecuteStep(&hasResult)) && hasResult &&
80946:       NS_SUCCEEDED(statement->GetUTF8String(0, journalMode))) {
80946:     if (journalMode.EqualsLiteral("delete")) {
80946:       return JOURNAL_DELETE;
80946:     }
80946:     if (journalMode.EqualsLiteral("truncate")) {
80946:       return JOURNAL_TRUNCATE;
80946:     }
80946:     if (journalMode.EqualsLiteral("memory")) {
80946:       return JOURNAL_MEMORY;
80946:     }
80946:     if (journalMode.EqualsLiteral("wal")) {
80946:       return JOURNAL_WAL;
80946:     }
80946:     // This is an unknown journal.
80946:     MOZ_ASSERT(true);
80946:   }
80946: 
80946:   return JOURNAL_DELETE;
80946: }
80946: 
90280: class BlockingConnectionCloseCallback : public mozIStorageCompletionCallback {
90280:   bool mDone;
90280: 
90280: public:
90280:   NS_DECL_ISUPPORTS
90280:   NS_DECL_MOZISTORAGECOMPLETIONCALLBACK
90280:   BlockingConnectionCloseCallback();
90280:   void Spin();
90280: };
90280: 
90280: NS_IMETHODIMP
90280: BlockingConnectionCloseCallback::Complete()
90280: {
90280:   mDone = true;
90280:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
90280:   MOZ_ASSERT(os);
90280:   if (!os)
90280:     return NS_OK;
90280:   DebugOnly<nsresult> rv = os->NotifyObservers(nsnull,
90280:                                                TOPIC_PLACES_CONNECTION_CLOSED,
90280:                                                nsnull);
90280:   MOZ_ASSERT(NS_SUCCEEDED(rv));
90280:   return NS_OK;
90280: }
90280: 
90280: BlockingConnectionCloseCallback::BlockingConnectionCloseCallback()
90280:   : mDone(false)
90280: {
90280:   MOZ_ASSERT(NS_IsMainThread());
90280: }
90280: 
90280: void BlockingConnectionCloseCallback::Spin() {
90280:   nsCOMPtr<nsIThread> thread = do_GetCurrentThread();
90280:   while (!mDone) {
90280:     NS_ProcessNextEvent(thread);
90280:   }
90280: }
90280: 
90280: NS_IMPL_THREADSAFE_ISUPPORTS1(
90280:   BlockingConnectionCloseCallback
90280: , mozIStorageCompletionCallback
90280: )
90280: 
84844: nsresult
84844: CreateRoot(nsCOMPtr<mozIStorageConnection>& aDBConn,
84844:            const nsCString& aRootName,
84844:            const nsXPIDLString& titleString)
84844: {
84844:   MOZ_ASSERT(NS_IsMainThread());
84844: 
84844:   // The position of the new item in its folder.
84844:   static PRInt32 itemPosition = 0;
84844: 
84844:   // A single creation timestamp for all roots so that the root folder's
84844:   // last modification time isn't earlier than its childrens' creation time.
84844:   static PRTime timestamp = 0;
84844:   if (!timestamp)
84844:     timestamp = PR_Now();
84844: 
84844:   // Create a new bookmark folder for the root.
84844:   nsCOMPtr<mozIStorageStatement> stmt;
84844:   nsresult rv = aDBConn->CreateStatement(NS_LITERAL_CSTRING(
84844:     "INSERT INTO moz_bookmarks "
84844:       "(type, position, title, dateAdded, lastModified, guid, parent) "
84844:     "VALUES (:item_type, :item_position, :item_title,"
84844:             ":date_added, :last_modified, GENERATE_GUID(),"
84844:             "IFNULL((SELECT id FROM moz_bookmarks WHERE parent = 0), 0))"
84844:   ), getter_AddRefs(stmt));
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_type"),
84844:                              nsINavBookmarksService::TYPE_FOLDER);
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_position"), itemPosition);
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("item_title"),
84844:                                   NS_ConvertUTF16toUTF8(titleString));
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("date_added"), timestamp);
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("last_modified"), timestamp);
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = stmt->Execute();
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   // Create an entry in moz_bookmarks_roots to link the folder to the root.
84844:   nsCOMPtr<mozIStorageStatement> newRootStmt;
84844:   rv = aDBConn->CreateStatement(NS_LITERAL_CSTRING(
84844:     "INSERT INTO moz_bookmarks_roots (root_name, folder_id) "
84844:     "VALUES (:root_name, "
84844:               "(SELECT id from moz_bookmarks WHERE "
84844:               " position = :item_position AND "
84844:               " parent = IFNULL((SELECT MIN(folder_id) FROM moz_bookmarks_roots), 0)))"
84844:   ), getter_AddRefs(newRootStmt));
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   rv = newRootStmt->BindUTF8StringByName(NS_LITERAL_CSTRING("root_name"),
84844:                                          aRootName);
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = newRootStmt->BindInt32ByName(NS_LITERAL_CSTRING("item_position"),
84844:                                     itemPosition);
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = newRootStmt->Execute();
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   // The 'places' root is a folder containing the other roots.
84844:   // The first bookmark in a folder has position 0.
84844:   if (!aRootName.Equals("places"))
84844:     ++itemPosition;
84844: 
84844:   return NS_OK;
84844: }
84844: 
84844: 
80946: } // Anonymous namespace
80946: 
80946: ////////////////////////////////////////////////////////////////////////////////
80946: //// Database
80946: 
80946: PLACES_FACTORY_SINGLETON_IMPLEMENTATION(Database, gDatabase)
80946: 
80946: NS_IMPL_THREADSAFE_ISUPPORTS2(Database
80946: , nsIObserver
80946: , nsISupportsWeakReference
80946: )
80946: 
80946: Database::Database()
80946:   : mMainThreadStatements(mMainConn)
80946:   , mMainThreadAsyncStatements(mMainConn)
80946:   , mAsyncThreadStatements(mMainConn)
80946:   , mDBPageSize(0)
80946:   , mCurrentJournalMode(JOURNAL_DELETE)
80946:   , mDatabaseStatus(nsINavHistoryService::DATABASE_STATUS_OK)
80946:   , mShuttingDown(false)
80946: {
80946:   // Attempting to create two instances of the service?
80946:   MOZ_ASSERT(!gDatabase);
80946:   gDatabase = this;
80946: }
80946: 
80946: Database::~Database()
80946: {
80946:   // Check to make sure it's us, in case somebody wrongly creates an extra
80946:   // instance of this singleton class.
80946:   MOZ_ASSERT(gDatabase == this);
80946: 
80946:   // Remove the static reference to the service.
80946:   if (gDatabase == this) {
80946:     gDatabase = nsnull;
80946:   }
80946: }
80946: 
80946: nsresult
80946: Database::Init()
80946: {
82443: #ifdef MOZ_ANDROID_HISTORY
82443:   // Currently places has deeply weaved it way throughout the gecko codebase.
82443:   // Here we disable all database creation and loading of places.
82443:   return NS_ERROR_NOT_IMPLEMENTED;
82443: #endif
82443: 
80946:   MOZ_ASSERT(NS_IsMainThread());
80946: 
80946:   nsCOMPtr<mozIStorageService> storage =
80946:     do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
80946:   NS_ENSURE_STATE(storage);
80946: 
80946:   // Init the database file and connect to it.
80946:   bool databaseCreated = false;
80946:   nsresult rv = InitDatabaseFile(storage, &databaseCreated);
80946:   if (NS_SUCCEEDED(rv) && databaseCreated) {
80946:     mDatabaseStatus = nsINavHistoryService::DATABASE_STATUS_CREATE;
80946:   }
80946:   else if (rv == NS_ERROR_FILE_CORRUPTED) {
80946:     // The database is corrupt, backup and replace it with a new one.
80946:     mDatabaseStatus = nsINavHistoryService::DATABASE_STATUS_CORRUPT;
80946:     rv = BackupAndReplaceDatabaseFile(storage);
80946:     // Fallback to catch-all handler, that notifies a database locked failure.
80946:   }
80946: 
80946:   // If the database connection still cannot be opened, it may just be locked
80946:   // by third parties.  Send out a notification and interrupt initialization.
80946:   if (NS_FAILED(rv)) {
80946:     nsRefPtr<PlacesEvent> lockedEvent = new PlacesEvent(TOPIC_DATABASE_LOCKED);
80946:     (void)NS_DispatchToMainThread(lockedEvent);
80946:     return rv;
80946:   }
80946: 
80946:   // Initialize the database schema.  In case of failure the existing schema is
80946:   // is corrupt or incoherent, thus the database should be replaced.
80946:   bool databaseMigrated = false;
80946:   rv = InitSchema(&databaseMigrated);
80946:   if (NS_FAILED(rv)) {
80946:     mDatabaseStatus = nsINavHistoryService::DATABASE_STATUS_CORRUPT;
80946:     rv = BackupAndReplaceDatabaseFile(storage);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     // Try to initialize the schema again on the new database.
80946:     rv = InitSchema(&databaseMigrated);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   if (databaseMigrated) {
80946:     mDatabaseStatus = nsINavHistoryService::DATABASE_STATUS_UPGRADED;
80946:   }
80946: 
80946:   if (mDatabaseStatus != nsINavHistoryService::DATABASE_STATUS_OK) {
80946:     rv = updateSQLiteStatistics(MainConn());
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   // Initialize here all the items that are not part of the on-disk database,
80946:   // like views, temp triggers or temp tables.  The database should not be
80946:   // considered corrupt if any of the following fails.
80946: 
80946:   rv = InitTempTriggers();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Notify we have finished database initialization.
80946:   // Enqueue the notification, so if we init another service that requires
80946:   // nsNavHistoryService we don't recursive try to get it.
80946:   nsRefPtr<PlacesEvent> completeEvent =
80946:     new PlacesEvent(TOPIC_PLACES_INIT_COMPLETE);
80946:   rv = NS_DispatchToMainThread(completeEvent);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Finally observe profile shutdown notifications.
80946:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
80946:   if (os) {
80946:     (void)os->AddObserver(this, TOPIC_PROFILE_CHANGE_TEARDOWN, true);
80946:     (void)os->AddObserver(this, TOPIC_PROFILE_BEFORE_CHANGE, true);
80946:   }
80946: 
80946:   return NS_OK;
80946: }
80946: 
80946: nsresult
80946: Database::InitDatabaseFile(nsCOMPtr<mozIStorageService>& aStorage,
80946:                            bool* aNewDatabaseCreated)
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   *aNewDatabaseCreated = false;
80946: 
80946:   nsCOMPtr<nsIFile> databaseFile;
80946:   nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
80946:                                        getter_AddRefs(databaseFile));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = databaseFile->Append(DATABASE_FILENAME);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   bool databaseFileExists = false;
80946:   rv = databaseFile->Exists(&databaseFileExists);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   if (databaseFileExists &&
80946:       Preferences::GetBool(PREF_FORCE_DATABASE_REPLACEMENT, false)) {
80946:     // If this pref is set, Maintenance required a database replacement, due to
80946:     // integrity corruption.
80946:     // Be sure to clear the pref to avoid handling it more than once.
80946:     (void)Preferences::ClearUser(PREF_FORCE_DATABASE_REPLACEMENT);
80946: 
80946:     return NS_ERROR_FILE_CORRUPTED;
80946:   }
80946: 
80946:   // Open the database file.  If it does not exist a new one will be created.
80946:   // Use an unshared connection, it will consume more memory but avoid shared
80946:   // cache contentions across threads.
80946:   rv = aStorage->OpenUnsharedDatabase(databaseFile, getter_AddRefs(mMainConn));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   *aNewDatabaseCreated = !databaseFileExists;
80946:   return NS_OK;
80946: }
80946: 
80946: nsresult
80946: Database::BackupAndReplaceDatabaseFile(nsCOMPtr<mozIStorageService>& aStorage)
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   nsCOMPtr<nsIFile> profDir;
80946:   nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
80946:                                        getter_AddRefs(profDir));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   nsCOMPtr<nsIFile> databaseFile;
80946:   rv = profDir->Clone(getter_AddRefs(databaseFile));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = databaseFile->Append(DATABASE_FILENAME);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // If we have
80946:   // already failed in the last 24 hours avoid to create another corrupt file,
80946:   // since doing so, in some situation, could cause us to create a new corrupt
80946:   // file at every try to access any Places service.  That is bad because it
80946:   // would quickly fill the user's disk space without any notice.
80946:   if (!hasRecentCorruptDB()) {
80946:     nsCOMPtr<nsIFile> backup;
80946:     (void)aStorage->BackupDatabaseFile(databaseFile, DATABASE_CORRUPT_FILENAME,
80946:                                        profDir, getter_AddRefs(backup));
80946:   }
80946: 
80946:   // Close database connection if open.
80946:   if (mMainConn) {
80946:     // If there's any not finalized statement or this fails for any reason
80946:     // we won't be able to remove the database.
80946:     rv = mMainConn->Close();
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   // Remove the broken database.
80946:   rv = databaseFile->Remove(false);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Create a new database file.
80946:   // Use an unshared connection, it will consume more memory but avoid shared
80946:   // cache contentions across threads.
80946:   rv = aStorage->OpenUnsharedDatabase(databaseFile, getter_AddRefs(mMainConn));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   return NS_OK;
80946: }
80946: 
80946: nsresult
80946: Database::InitSchema(bool* aDatabaseMigrated)
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   *aDatabaseMigrated = false;
80946: 
80946:   // WARNING: any statement executed before setting the journal mode must be
80946:   // finalized, since SQLite doesn't allow changing the journal mode if there
80946:   // is any outstanding statement.
80946: 
80946:   {
80946:     // Get the page size.  This may be different than the default if the
80946:     // database file already existed with a different page size.
80946:     nsCOMPtr<mozIStorageStatement> statement;
80946:     nsresult rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
86727:       MOZ_STORAGE_UNIQUIFY_QUERY_STR "PRAGMA page_size"
80946:     ), getter_AddRefs(statement));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     bool hasResult = false;
80946:     rv = statement->ExecuteStep(&hasResult);
80946:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && hasResult, NS_ERROR_FAILURE);
80946:     rv = statement->GetInt32(0, &mDBPageSize);
80946:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && mDBPageSize > 0, NS_ERROR_UNEXPECTED);
80946:   }
80946: 
80946:   // Ensure that temp tables are held in memory, not on disk.
80946:   nsresult rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
86727:       MOZ_STORAGE_UNIQUIFY_QUERY_STR "PRAGMA temp_store = MEMORY"));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Be sure to set journal mode after page_size.  WAL would prevent the change
80946:   // otherwise.
80946:   if (NS_SUCCEEDED(SetJournalMode(mMainConn, JOURNAL_WAL))) {
80946:     // Set the WAL journal size limit.  We want it to be small, since in
80946:     // synchronous = NORMAL mode a crash could cause loss of all the
80946:     // transactions in the journal.  For added safety we will also force
80946:     // checkpointing at strategic moments.
80946:     PRInt32 checkpointPages =
80946:       static_cast<PRInt32>(DATABASE_MAX_WAL_SIZE_IN_KIBIBYTES * 1024 / mDBPageSize);
80946:     nsCAutoString checkpointPragma("PRAGMA wal_autocheckpoint = ");
80946:     checkpointPragma.AppendInt(checkpointPages);
80946:     rv = mMainConn->ExecuteSimpleSQL(checkpointPragma);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946:   else {
80946:     // Ignore errors, if we fail here the database could be considered corrupt
80946:     // and we won't be able to go on, even if it's just matter of a bogus file
80946:     // system.  The default mode (DELETE) will be fine in such a case.
80946:     (void)SetJournalMode(mMainConn, JOURNAL_TRUNCATE);
80946: 
80946:     // Set synchronous to FULL to ensure maximum data integrity, even in
80946:     // case of crashes or unclean shutdowns.
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:         "PRAGMA synchronous = FULL"));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
81030:   // The journal is usually free to grow for performance reasons, but it never
81030:   // shrinks back.  Since the space taken may be problematic, especially on
81030:   // mobile devices, limit its size.
81030:   // Since exceeding the limit will cause a truncate, allow a slightly
81030:   // larger limit than DATABASE_MAX_WAL_SIZE_IN_KIBIBYTES to reduce the number
81030:   // of times it is needed.
81030:   nsCAutoString journalSizePragma("PRAGMA journal_size_limit = ");
81030:   journalSizePragma.AppendInt(DATABASE_MAX_WAL_SIZE_IN_KIBIBYTES * 3);
81030:   (void)mMainConn->ExecuteSimpleSQL(journalSizePragma);
81030: 
81030:   // Grow places in 10MiB increments to limit fragmentation on disk.
80946:   (void)mMainConn->SetGrowthIncrement(10 * BYTES_PER_MEBIBYTE, EmptyCString());
80946: 
80946:   // We use our functions during migration, so initialize them now.
80946:   rv = InitFunctions();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Get the database schema version.
80946:   PRInt32 currentSchemaVersion;
80946:   rv = mMainConn->GetSchemaVersion(&currentSchemaVersion);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   bool databaseInitialized = currentSchemaVersion > 0;
80946: 
80946:   if (databaseInitialized && currentSchemaVersion == DATABASE_SCHEMA_VERSION) {
80946:     // The database is up to date and ready to go.
80946:     return NS_OK;
80946:   }
80946: 
80946:   // We are going to update the database, so everything from now on should be in
80946:   // a transaction for performances.
80946:   mozStorageTransaction transaction(mMainConn, false);
80946: 
80946:   if (databaseInitialized) {
80946:     // Migration How-to:
80946:     //
80946:     // 1. increment PLACES_SCHEMA_VERSION.
80946:     // 2. implement a method that performs upgrade to your version from the
80946:     //    previous one.
80946:     //
80946:     // NOTE: The downgrade process is pretty much complicated by the fact old
80946:     //       versions cannot know what a new version is going to implement.
80946:     //       The only thing we will do for downgrades is setting back the schema
80946:     //       version, so that next upgrades will run again the migration step.
80946: 
80946:     if (currentSchemaVersion < DATABASE_SCHEMA_VERSION) {
80946:       *aDatabaseMigrated = true;
80946: 
82939:       if (currentSchemaVersion < 6) {
82939:         // These are early Firefox 3.0 alpha versions that are not supported
82939:         // anymore.  In this case it's safer to just replace the database.
82939:         return NS_ERROR_FILE_CORRUPTED;
82939:       }
82939: 
80946:       // Firefox 3.0 uses schema version 6.
80946: 
80946:       if (currentSchemaVersion < 7) {
80946:         rv = MigrateV7Up();
80946:         NS_ENSURE_SUCCESS(rv, rv);
80946:       }
80946: 
80946:       if (currentSchemaVersion < 8) {
80946:         rv = MigrateV8Up();
80946:         NS_ENSURE_SUCCESS(rv, rv);
80946:       }
80946: 
80946:       // Firefox 3.5 uses schema version 8.
80946: 
80946:       if (currentSchemaVersion < 9) {
80946:         rv = MigrateV9Up();
80946:         NS_ENSURE_SUCCESS(rv, rv);
80946:       }
80946: 
80946:       if (currentSchemaVersion < 10) {
80946:         rv = MigrateV10Up();
80946:         NS_ENSURE_SUCCESS(rv, rv);
80946:       }
80946: 
80946:       // Firefox 3.6 uses schema version 10.
80946: 
80946:       if (currentSchemaVersion < 11) {
80946:         rv = MigrateV11Up();
80946:         NS_ENSURE_SUCCESS(rv, rv);
80946:       }
80946: 
80946:       // Firefox 4 uses schema version 11.
80946: 
80946:       // Firefox 8 uses schema version 12.
80946: 
82903:       if (currentSchemaVersion < 13) {
82903:         rv = MigrateV13Up();
82903:         NS_ENSURE_SUCCESS(rv, rv);
82903:       }
83109: 
83109:       if (currentSchemaVersion < 14) {
83109:         rv = MigrateV14Up();
83109:         NS_ENSURE_SUCCESS(rv, rv);
83109:       }
83109: 
84191:       if (currentSchemaVersion < 15) {
84191:         rv = MigrateV15Up();
84191:         NS_ENSURE_SUCCESS(rv, rv);
84191:       }
84191: 
86678:       if (currentSchemaVersion < 16) {
86678:         rv = MigrateV16Up();
86678:         NS_ENSURE_SUCCESS(rv, rv);
86678:       }
86678: 
86678:       // Firefox 11 uses schema version 16.
82903: 
87706:       if (currentSchemaVersion < 17) {
87706:         rv = MigrateV17Up();
87706:         NS_ENSURE_SUCCESS(rv, rv);
87706:       }
87706: 
87706:       // Firefox 12 uses schema version 17.
87706: 
90371:       if (currentSchemaVersion < 18) {
90371:         rv = MigrateV18Up();
90371:         NS_ENSURE_SUCCESS(rv, rv);
90371:       }
90371: 
90371:       // Firefox 13 uses schema version 18.
90371: 
80946:       // Schema Upgrades must add migration code here.
84844: 
84844:       rv = UpdateBookmarkRootTitles();
84844:       // We don't want a broken localization to cause us to think
84844:       // the database is corrupt and needs to be replaced.
84844:       MOZ_ASSERT(NS_SUCCEEDED(rv));
80946:     }
80946:   }
80946:   else {
80946:     // This is a new database, so we have to create all the tables and indices.
80946: 
80946:     // moz_places.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_PLACES);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_URL);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_FAVICON);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_REVHOST);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_VISITCOUNT);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_FRECENCY);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_LASTVISITDATE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_GUID);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // moz_historyvisits.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_HISTORYVISITS);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_PLACEDATE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_FROMVISIT);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_VISITDATE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // moz_inputhistory.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_INPUTHISTORY);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
87706:     // moz_hosts.
87706:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_HOSTS);
87706:     NS_ENSURE_SUCCESS(rv, rv);
87706: 
80946:     // moz_bookmarks.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_BOOKMARKS);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PLACETYPE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PARENTPOSITION);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PLACELASTMODIFIED);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_GUID);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // moz_bookmarks_roots.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_BOOKMARKS_ROOTS);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // moz_keywords.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_KEYWORDS);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // moz_favicons.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_FAVICONS);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // moz_anno_attributes.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_ANNO_ATTRIBUTES);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // moz_annos.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_ANNOS);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_ANNOS_PLACEATTRIBUTE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // moz_items_annos.
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_ITEMS_ANNOS);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_ITEMSANNOS_PLACEATTRIBUTE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
84844: 
84844:     // Initialize the bookmark roots in the new DB.
84844:     rv = CreateBookmarkRoots();
84844:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   // Set the schema version to the current one.
80946:   rv = mMainConn->SetSchemaVersion(DATABASE_SCHEMA_VERSION);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   rv = transaction.Commit();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   ForceWALCheckpoint();
80946: 
80946:   // ANY FAILURE IN THIS METHOD WILL CAUSE US TO MARK THE DATABASE AS CORRUPT
80946:   // AND TRY TO REPLACE IT.
80946:   // DO NOT PUT HERE ANYTHING THAT IS NOT RELATED TO INITIALIZATION OR MODIFYING
80946:   // THE DISK DATABASE.
80946: 
80946:   return NS_OK;
80946: }
80946: 
80946: nsresult
84844: Database::CreateBookmarkRoots()
84844: {
84844:   MOZ_ASSERT(NS_IsMainThread());
84844: 
84844:   nsCOMPtr<nsIStringBundleService> bundleService =
84844:     services::GetStringBundleService();
84844:   NS_ENSURE_STATE(bundleService);
84844:   nsCOMPtr<nsIStringBundle> bundle;
84844:   nsresult rv = bundleService->CreateBundle(PLACES_BUNDLE, getter_AddRefs(bundle));
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   nsXPIDLString rootTitle;
84844:   // The first root's title is an empty string.
84844:   rv = CreateRoot(mMainConn, NS_LITERAL_CSTRING("places"), rootTitle);
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   // Fetch the internationalized folder name from the string bundle.
84844:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("BookmarksMenuFolderTitle").get(),
84844:                                  getter_Copies(rootTitle));
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = CreateRoot(mMainConn, NS_LITERAL_CSTRING("menu"), rootTitle);
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("BookmarksToolbarFolderTitle").get(),
84844:                                  getter_Copies(rootTitle));
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = CreateRoot(mMainConn, NS_LITERAL_CSTRING("toolbar"), rootTitle);
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("TagsFolderTitle").get(),
84844:                                  getter_Copies(rootTitle));
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = CreateRoot(mMainConn, NS_LITERAL_CSTRING("tags"), rootTitle);
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("UnsortedBookmarksFolderTitle").get(),
84844:                                  getter_Copies(rootTitle));
84844:   if (NS_FAILED(rv)) return rv;
84844:   rv = CreateRoot(mMainConn, NS_LITERAL_CSTRING("unfiled"), rootTitle);
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844: #if DEBUG
84844:   nsCOMPtr<mozIStorageStatement> stmt;
84844:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
84844:     "SELECT "
84844:       "(SELECT COUNT(*) FROM moz_bookmarks), "
84844:       "(SELECT COUNT(*) FROM moz_bookmarks_roots), "
84844:       "(SELECT SUM(position) FROM moz_bookmarks WHERE "
84844:         "id IN (SELECT folder_id FROM moz_bookmarks_roots))"
84844:   ), getter_AddRefs(stmt));
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   bool hasResult;
84844:   rv = stmt->ExecuteStep(&hasResult);
84844:   if (NS_FAILED(rv)) return rv;
84844:   MOZ_ASSERT(hasResult);
84844:   PRInt32 bookmarkCount = 0;
84844:   rv = stmt->GetInt32(0, &bookmarkCount);
84844:   if (NS_FAILED(rv)) return rv;
84844:   PRInt32 rootCount = 0;
84844:   rv = stmt->GetInt32(1, &rootCount);
84844:   if (NS_FAILED(rv)) return rv;
84844:   PRInt32 positionSum = 0;
84844:   rv = stmt->GetInt32(2, &positionSum);
84844:   if (NS_FAILED(rv)) return rv;
84844:   MOZ_ASSERT(bookmarkCount == 5 && rootCount == 5 && positionSum == 6);
84844: #endif
84844: 
84844:   return NS_OK;
84844: }
84844: 
84844: nsresult
80946: Database::InitFunctions()
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946: 
80946:   nsresult rv = GetUnreversedHostFunction::create(mMainConn);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = MatchAutoCompleteFunction::create(mMainConn);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = CalculateFrecencyFunction::create(mMainConn);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = GenerateGUIDFunction::create(mMainConn);
80946:   NS_ENSURE_SUCCESS(rv, rv);
87706:   rv = FixupURLFunction::create(mMainConn);
87706:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   return NS_OK;
80946: }
80946: 
80946: nsresult
80946: Database::InitTempTriggers()
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946: 
80946:   nsresult rv = mMainConn->ExecuteSimpleSQL(CREATE_HISTORYVISITS_AFTERINSERT_TRIGGER);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = mMainConn->ExecuteSimpleSQL(CREATE_HISTORYVISITS_AFTERDELETE_TRIGGER);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
87706:   // Add the triggers that update the moz_hosts table as necessary.
87706:   rv = mMainConn->ExecuteSimpleSQL(CREATE_PLACES_AFTERINSERT_TRIGGER);
87706:   NS_ENSURE_SUCCESS(rv, rv);
87706:   rv = mMainConn->ExecuteSimpleSQL(CREATE_PLACES_AFTERDELETE_TRIGGER);
87706:   NS_ENSURE_SUCCESS(rv, rv);
90371:   rv = mMainConn->ExecuteSimpleSQL(CREATE_PLACES_AFTERUPDATE_FRECENCY_TRIGGER);
90371:   NS_ENSURE_SUCCESS(rv, rv);
90371:   rv = mMainConn->ExecuteSimpleSQL(CREATE_PLACES_AFTERUPDATE_TYPED_TRIGGER);
87706:   NS_ENSURE_SUCCESS(rv, rv);
87706: 
80946:   return NS_OK;
80946: }
80946: 
80946: nsresult
84844: Database::UpdateBookmarkRootTitles()
84844: {
84844:   MOZ_ASSERT(NS_IsMainThread());
84844: 
84844:   nsCOMPtr<nsIStringBundleService> bundleService =
84844:     services::GetStringBundleService();
84844:   NS_ENSURE_STATE(bundleService);
84844: 
84844:   nsCOMPtr<nsIStringBundle> bundle;
84844:   nsresult rv = bundleService->CreateBundle(PLACES_BUNDLE, getter_AddRefs(bundle));
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   nsCOMPtr<mozIStorageAsyncStatement> stmt;
84844:   rv = mMainConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
84844:     "UPDATE moz_bookmarks SET title = :new_title WHERE id = "
84844:       "(SELECT folder_id FROM moz_bookmarks_roots WHERE root_name = :root_name)"
84844:   ), getter_AddRefs(stmt));
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   nsCOMPtr<mozIStorageBindingParamsArray> paramsArray;
84844:   rv = stmt->NewBindingParamsArray(getter_AddRefs(paramsArray));
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   const char *rootNames[] = { "menu", "toolbar", "tags", "unfiled" };
84844:   const char *titleStringIDs[] = {
84844:     "BookmarksMenuFolderTitle", "BookmarksToolbarFolderTitle",
84844:     "TagsFolderTitle", "UnsortedBookmarksFolderTitle"
84844:   };
84844: 
84844:   for (PRUint32 i = 0; i < ArrayLength(rootNames); ++i) {
84844:     nsXPIDLString title;
84844:     rv = bundle->GetStringFromName(NS_ConvertASCIItoUTF16(titleStringIDs[i]).get(),
84844:                                    getter_Copies(title));
84844:     if (NS_FAILED(rv)) return rv;
84844: 
84844:     nsCOMPtr<mozIStorageBindingParams> params;
84844:     rv = paramsArray->NewBindingParams(getter_AddRefs(params));
84844:     if (NS_FAILED(rv)) return rv;
84844:     rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("root_name"),
84844:                                       nsDependentCString(rootNames[i]));
84844:     if (NS_FAILED(rv)) return rv;
84844:     rv = params->BindUTF8StringByName(NS_LITERAL_CSTRING("new_title"),
84844:                                       NS_ConvertUTF16toUTF8(title));
84844:     if (NS_FAILED(rv)) return rv;
84844:     rv = paramsArray->AddParams(params);
84844:     if (NS_FAILED(rv)) return rv;
84844:   }
84844: 
84844:   rv = stmt->BindParameters(paramsArray);
84844:   if (NS_FAILED(rv)) return rv;
84844:   nsCOMPtr<mozIStoragePendingStatement> pendingStmt;
84844:   rv = stmt->ExecuteAsync(nsnull, getter_AddRefs(pendingStmt));
84844:   if (NS_FAILED(rv)) return rv;
84844: 
84844:   return NS_OK;
84844: }
84844: 
84844: nsresult
80946: Database::CheckAndUpdateGUIDs()
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946: 
80946:   // First, import any bookmark guids already set by Sync.
80946:   nsCOMPtr<mozIStorageStatement> updateStmt;
80946:   nsresult rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:     "UPDATE moz_bookmarks "
80946:     "SET guid = :guid "
80946:     "WHERE id = :item_id "
80946:   ), getter_AddRefs(updateStmt));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   nsCOMPtr<mozIStorageStatement> stmt;
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:     "SELECT item_id, content "
80946:     "FROM moz_items_annos "
80946:     "JOIN moz_anno_attributes "
80946:     "WHERE name = :anno_name "
80946:   ), getter_AddRefs(stmt));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("anno_name"),
80946:                                   SYNCGUID_ANNO);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   bool hasResult;
80946:   while (NS_SUCCEEDED(stmt->ExecuteStep(&hasResult)) && hasResult) {
80946:     PRInt64 itemId;
80946:     rv = stmt->GetInt64(0, &itemId);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     nsCAutoString guid;
80946:     rv = stmt->GetUTF8String(1, guid);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // If we have an invalid guid, we don't need to do any more work.
80946:     if (!IsValidGUID(guid)) {
80946:       continue;
80946:     }
80946: 
80946:     mozStorageStatementScoper updateScoper(updateStmt);
80946:     rv = updateStmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), itemId);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = updateStmt->BindUTF8StringByName(NS_LITERAL_CSTRING("guid"), guid);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = updateStmt->Execute();
80946:     if (rv == NS_ERROR_STORAGE_CONSTRAINT) {
80946:       // We just tried to insert a duplicate guid.  Ignore this error, and we
80946:       // will generate a new one next.
80946:       continue;
80946:     }
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   // Now, remove all the bookmark guid annotations that we just imported.
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:     "DELETE FROM moz_items_annos "
80946:     "WHERE anno_attribute_id = ( "
80946:       "SELECT id "
80946:       "FROM moz_anno_attributes "
80946:       "WHERE name = :anno_name "
80946:     ") "
80946:   ), getter_AddRefs(stmt));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("anno_name"),
80946:                                   SYNCGUID_ANNO);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   rv = stmt->Execute();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Next, generate guids for any bookmark that does not already have one.
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:     "UPDATE moz_bookmarks "
80946:     "SET guid = GENERATE_GUID() "
80946:     "WHERE guid IS NULL "
80946:   ), getter_AddRefs(stmt));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   rv = stmt->Execute();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Now, import any history guids already set by Sync.
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:     "UPDATE moz_places "
80946:     "SET guid = :guid "
80946:     "WHERE id = :place_id "
80946:   ), getter_AddRefs(updateStmt));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:     "SELECT place_id, content "
80946:     "FROM moz_annos "
80946:     "JOIN moz_anno_attributes "
80946:     "WHERE name = :anno_name "
80946:   ), getter_AddRefs(stmt));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("anno_name"),
80946:                                   SYNCGUID_ANNO);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   while (NS_SUCCEEDED(stmt->ExecuteStep(&hasResult)) && hasResult) {
80946:     PRInt64 placeId;
80946:     rv = stmt->GetInt64(0, &placeId);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     nsCAutoString guid;
80946:     rv = stmt->GetUTF8String(1, guid);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // If we have an invalid guid, we don't need to do any more work.
80946:     if (!IsValidGUID(guid)) {
80946:       continue;
80946:     }
80946: 
80946:     mozStorageStatementScoper updateScoper(updateStmt);
80946:     rv = updateStmt->BindInt64ByName(NS_LITERAL_CSTRING("place_id"), placeId);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = updateStmt->BindUTF8StringByName(NS_LITERAL_CSTRING("guid"), guid);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:     rv = updateStmt->Execute();
80946:     if (rv == NS_ERROR_STORAGE_CONSTRAINT) {
80946:       // We just tried to insert a duplicate guid.  Ignore this error, and we
80946:       // will generate a new one next.
80946:       continue;
80946:     }
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   // Now, remove all the place guid annotations that we just imported.
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:     "DELETE FROM moz_annos "
80946:     "WHERE anno_attribute_id = ( "
80946:       "SELECT id "
80946:       "FROM moz_anno_attributes "
80946:       "WHERE name = :anno_name "
80946:     ") "
80946:   ), getter_AddRefs(stmt));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("anno_name"),
80946:                                   SYNCGUID_ANNO);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   rv = stmt->Execute();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Finally, generate guids for any places that do not already have one.
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:     "UPDATE moz_places "
80946:     "SET guid = GENERATE_GUID() "
80946:     "WHERE guid IS NULL "
80946:   ), getter_AddRefs(stmt));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   rv = stmt->Execute();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   return NS_OK;
80946: }
80946: 
80946: nsresult
80946: Database::MigrateV7Up() 
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
82939: 
82939:   // Some old v6 databases come from alpha versions that missed indices.
82939:   // Just bail out and replace the database in such a case.
82939:   bool URLUniqueIndexExists = false;
82939:   nsresult rv = mMainConn->IndexExists(NS_LITERAL_CSTRING(
82939:     "moz_places_url_uniqueindex"
82939:   ), &URLUniqueIndexExists);
82939:   NS_ENSURE_SUCCESS(rv, rv);
82939:   if (!URLUniqueIndexExists) {
82939:     return NS_ERROR_FILE_CORRUPTED;
82939:   }
82939: 
80946:   mozStorageTransaction transaction(mMainConn, false);
80946: 
80946:   // We need an index on lastModified to catch quickly last modified bookmark
83109:   // title for tag container's children. This will be useful for Sync, too.
80946:   bool lastModIndexExists = false;
82939:   rv = mMainConn->IndexExists(
80946:     NS_LITERAL_CSTRING("moz_bookmarks_itemlastmodifiedindex"),
80946:     &lastModIndexExists);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   if (!lastModIndexExists) {
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PLACELASTMODIFIED);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   // We need to do a one-time change of the moz_historyvisits.pageindex
80946:   // to speed up finding last visit date when joinin with moz_places.
80946:   // See bug 392399 for more details.
80946:   bool pageIndexExists = false;
80946:   rv = mMainConn->IndexExists(
80946:     NS_LITERAL_CSTRING("moz_historyvisits_pageindex"), &pageIndexExists);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   if (pageIndexExists) {
80946:     // drop old index
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:         "DROP INDEX IF EXISTS moz_historyvisits_pageindex"));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // create the new multi-column index
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_HISTORYVISITS_PLACEDATE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   // for existing profiles, we may not have a frecency column
80946:   nsCOMPtr<mozIStorageStatement> hasFrecencyStatement;
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:       "SELECT frecency FROM moz_places"),
80946:     getter_AddRefs(hasFrecencyStatement));
80946: 
80946:   if (NS_FAILED(rv)) {
80946:     // Add frecency column to moz_places, default to -1 so that all the
80946:     // frecencies are invalid
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:         "ALTER TABLE moz_places ADD frecency INTEGER DEFAULT -1 NOT NULL"));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // create index for the frecency column
80946:     // XXX multi column index with typed, and visit_count?
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_FRECENCY);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // Invalidate all frecencies, since they need recalculation.
82939:     nsCOMPtr<mozIStorageAsyncStatement> stmt = GetAsyncStatement(
82939:       "UPDATE moz_places SET frecency = ( "
82939:         "CASE "
82939:         "WHEN url BETWEEN 'place:' AND 'place;' "
82939:         "THEN 0 "
82939:         "ELSE -1 "
82939:         "END "
82939:       ") "
82939:     );
82939:     NS_ENSURE_STATE(stmt);
82939:     nsCOMPtr<mozIStoragePendingStatement> ps;
82939:     (void)stmt->ExecuteAsync(nsnull, getter_AddRefs(ps));
80946:   }
80946: 
80946:   // Temporary migration code for bug 396300
80946:   nsCOMPtr<mozIStorageStatement> moveUnfiledBookmarks;
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:       "UPDATE moz_bookmarks "
80946:       "SET parent = ("
80946:         "SELECT folder_id "
80946:         "FROM moz_bookmarks_roots "
80946:         "WHERE root_name = :root_name "
80946:       ") "
80946:       "WHERE type = :item_type "
80946:       "AND parent = ("
80946:         "SELECT folder_id "
80946:         "FROM moz_bookmarks_roots "
80946:         "WHERE root_name = :parent_name "
80946:       ")"),
80946:     getter_AddRefs(moveUnfiledBookmarks));
80946:   rv = moveUnfiledBookmarks->BindUTF8StringByName(
80946:     NS_LITERAL_CSTRING("root_name"), NS_LITERAL_CSTRING("unfiled")
80946:   );
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = moveUnfiledBookmarks->BindInt32ByName(
80946:     NS_LITERAL_CSTRING("item_type"), nsINavBookmarksService::TYPE_BOOKMARK
80946:   );
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = moveUnfiledBookmarks->BindUTF8StringByName(
80946:     NS_LITERAL_CSTRING("parent_name"), NS_LITERAL_CSTRING("places")
80946:   );
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = moveUnfiledBookmarks->Execute();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Create a statement to test for trigger creation
80946:   nsCOMPtr<mozIStorageStatement> triggerDetection;
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:       "SELECT name "
80946:       "FROM sqlite_master "
80946:       "WHERE type = 'trigger' "
80946:       "AND name = :trigger_name"),
80946:     getter_AddRefs(triggerDetection));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Check for existence
80946:   bool triggerExists;
80946:   rv = triggerDetection->BindUTF8StringByName(
80946:     NS_LITERAL_CSTRING("trigger_name"),
80946:     NS_LITERAL_CSTRING("moz_historyvisits_afterinsert_v1_trigger")
80946:   );
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = triggerDetection->ExecuteStep(&triggerExists);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = triggerDetection->Reset();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // We need to create two triggers on moz_historyvists to maintain the
80946:   // accuracy of moz_places.visit_count.  For this to work, we must ensure that
80946:   // all moz_places.visit_count values are correct.
80946:   // See bug 416313 for details.
80946:   if (!triggerExists) {
80946:     // First, we do a one-time reset of all the moz_places.visit_count values.
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:         "UPDATE moz_places SET visit_count = "
80946:           "(SELECT count(*) FROM moz_historyvisits "
80946:            "WHERE place_id = moz_places.id "
80946:             "AND visit_type NOT IN ") +
80946:               nsPrintfCString("(0,%d,%d,%d) ",
80946:                               nsINavHistoryService::TRANSITION_EMBED,
80946:                               nsINavHistoryService::TRANSITION_FRAMED_LINK,
80946:                               nsINavHistoryService::TRANSITION_DOWNLOAD) +
80946:           NS_LITERAL_CSTRING(")"));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // We used to create two triggers here, but we no longer need that with
80946:     // schema version eight and greater.  We've removed their creation here as
80946:     // a result.
80946:   }
80946: 
80946:   // Check for existence
80946:   rv = triggerDetection->BindUTF8StringByName(
80946:     NS_LITERAL_CSTRING("trigger_name"),
80946:     NS_LITERAL_CSTRING("moz_bookmarks_beforedelete_v1_trigger")
80946:   );
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = triggerDetection->ExecuteStep(&triggerExists);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = triggerDetection->Reset();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // We need to create one trigger on moz_bookmarks to remove unused keywords.
80946:   // See bug 421180 for details.
80946:   if (!triggerExists) {
80946:     // First, remove any existing dangling keywords
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:         "DELETE FROM moz_keywords "
80946:         "WHERE id IN ("
80946:           "SELECT k.id "
80946:           "FROM moz_keywords k "
80946:           "LEFT OUTER JOIN moz_bookmarks b "
80946:           "ON b.keyword_id = k.id "
80946:           "WHERE b.id IS NULL"
80946:         ")"));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
82939:   // Add the moz_inputhistory table, if missing.
82939:   bool tableExists = false;
82939:   rv = mMainConn->TableExists(NS_LITERAL_CSTRING("moz_inputhistory"),
82939:                               &tableExists);
82939:   NS_ENSURE_SUCCESS(rv, rv);
82939:   if (!tableExists) {
82939:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_INPUTHISTORY);
82939:     NS_ENSURE_SUCCESS(rv, rv);
82939:   }
82939: 
80946:   return transaction.Commit();
80946: }
80946: 
80946: 
80946: nsresult
80946: Database::MigrateV8Up()
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   mozStorageTransaction transaction(mMainConn, false);
80946: 
80946:   nsresult rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:       "DROP TRIGGER IF EXISTS moz_historyvisits_afterinsert_v1_trigger"));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:       "DROP TRIGGER IF EXISTS moz_historyvisits_afterdelete_v1_trigger"));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946: 
80946:   // bug #381795 - remove unused indexes
80946:   rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:       "DROP INDEX IF EXISTS moz_places_titleindex"));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:       "DROP INDEX IF EXISTS moz_annos_item_idindex"));
80946:   NS_ENSURE_SUCCESS(rv, rv);
82939:   rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
82939:       "DROP INDEX IF EXISTS moz_annos_place_idindex"));
82939:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // Do a one-time re-creation of the moz_annos indexes (bug 415201)
80946:   bool oldIndexExists = false;
80946:   rv = mMainConn->IndexExists(NS_LITERAL_CSTRING("moz_annos_attributesindex"), &oldIndexExists);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946:   if (oldIndexExists) {
80946:     // drop old uri annos index
80946:     rv = mMainConn->ExecuteSimpleSQL(
80946:         NS_LITERAL_CSTRING("DROP INDEX moz_annos_attributesindex"));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // create new uri annos index
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_ANNOS_PLACEATTRIBUTE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // drop old item annos index
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:         "DROP INDEX IF EXISTS moz_items_annos_attributesindex"));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // create new item annos index
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_ITEMSANNOS_PLACEATTRIBUTE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   return transaction.Commit();
80946: }
80946: 
80946: 
80946: nsresult
80946: Database::MigrateV9Up()
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   mozStorageTransaction transaction(mMainConn, false);
80946:   // Added in Bug 488966.  The last_visit_date column caches the last
80946:   // visit date, this enhances SELECT performances when we
80946:   // need to sort visits by visit date.
80946:   // The cached value is synced by triggers on every added or removed visit.
80946:   // See nsPlacesTriggers.h for details on the triggers.
80946:   bool oldIndexExists = false;
80946:   nsresult rv = mMainConn->IndexExists(
80946:     NS_LITERAL_CSTRING("moz_places_lastvisitdateindex"), &oldIndexExists);
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   if (!oldIndexExists) {
80946:     // Add last_visit_date column to moz_places.
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:         "ALTER TABLE moz_places ADD last_visit_date INTEGER"));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_LASTVISITDATE);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     // Now let's sync the column contents with real visit dates.
80946:     // This query can be really slow due to disk access, since it will basically
80946:     // dupe the table contents in the journal file, and then write them down
80946:     // in the database.
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:         "UPDATE moz_places SET last_visit_date = "
80946:           "(SELECT MAX(visit_date) "
80946:            "FROM moz_historyvisits "
80946:            "WHERE place_id = moz_places.id)"));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   return transaction.Commit();
80946: }
80946: 
80946: 
80946: nsresult
80946: Database::MigrateV10Up()
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   // LastModified is set to the same value as dateAdded on item creation.
80946:   // This way we can use lastModified index to sort.
80946:   nsresult rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:       "UPDATE moz_bookmarks SET lastModified = dateAdded "
80946:       "WHERE lastModified IS NULL"));
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   return NS_OK;
80946: }
80946: 
80946: 
80946: nsresult
80946: Database::MigrateV11Up()
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   // Temp tables are going away.
80946:   // For triggers correctness, every time we pass through this migration
80946:   // step, we must ensure correctness of visit_count values.
80946:   nsresult rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:     "UPDATE moz_places SET visit_count = "
80946:       "(SELECT count(*) FROM moz_historyvisits "
80946:        "WHERE place_id = moz_places.id "
80946:         "AND visit_type NOT IN ") +
80946:           nsPrintfCString("(0,%d,%d,%d) ",
80946:                           nsINavHistoryService::TRANSITION_EMBED,
80946:                           nsINavHistoryService::TRANSITION_FRAMED_LINK,
80946:                           nsINavHistoryService::TRANSITION_DOWNLOAD) +
80946:       NS_LITERAL_CSTRING(")")
80946:   );
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   // For existing profiles, we may not have a moz_bookmarks.guid column
80946:   nsCOMPtr<mozIStorageStatement> hasGuidStatement;
80946:   rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:       "SELECT guid FROM moz_bookmarks"),
80946:     getter_AddRefs(hasGuidStatement));
80946: 
80946:   if (NS_FAILED(rv)) {
80946:     // moz_bookmarks grew a guid column.  Add the column, but do not populate it
80946:     // with anything just yet.  We will do that soon.
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:       "ALTER TABLE moz_bookmarks "
80946:       "ADD COLUMN guid TEXT"
80946:     ));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_GUID);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
83109:     // moz_places grew a guid column. Add the column, but do not populate it
80946:     // with anything just yet. We will do that soon.
80946:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
80946:       "ALTER TABLE moz_places "
80946:       "ADD COLUMN guid TEXT"
80946:     ));
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_PLACES_GUID);
80946:     NS_ENSURE_SUCCESS(rv, rv);
80946:   }
80946: 
80946:   // We need to update our guids before we do any real database work.
80946:   rv = CheckAndUpdateGUIDs();
80946:   NS_ENSURE_SUCCESS(rv, rv);
80946: 
80946:   return NS_OK;
80946: }
80946: 
82903: nsresult
82903: Database::MigrateV13Up()
82903: {
82903:   MOZ_ASSERT(NS_IsMainThread());
82903: 
83109:   // Dynamic containers are no longer supported.
82903:   nsCOMPtr<mozIStorageAsyncStatement> deleteDynContainersStmt;
82903:   nsresult rv = mMainConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
82903:       "DELETE FROM moz_bookmarks WHERE type = :item_type"),
82903:     getter_AddRefs(deleteDynContainersStmt));
82903:   rv = deleteDynContainersStmt->BindInt32ByName(
82903:     NS_LITERAL_CSTRING("item_type"),
82903:     nsINavBookmarksService::TYPE_DYNAMIC_CONTAINER
82903:   );
82903:   NS_ENSURE_SUCCESS(rv, rv);
82903:   nsCOMPtr<mozIStoragePendingStatement> ps;
82903:   rv = deleteDynContainersStmt->ExecuteAsync(nsnull, getter_AddRefs(ps));
82903:   NS_ENSURE_SUCCESS(rv, rv);
82903: 
82903:   return NS_OK;
82903: }
82903: 
83109: nsresult
83109: Database::MigrateV14Up()
83109: {
86678:   MOZ_ASSERT(NS_IsMainThread());
86678: 
83109:   // For existing profiles, we may not have a moz_favicons.guid column.
83109:   // Add it here. We want it to be unique, but ALTER TABLE doesn't allow
83109:   // a uniqueness constraint, so the index must be created separately.
83109:   nsCOMPtr<mozIStorageStatement> hasGuidStatement;
83109:   nsresult rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
83109:       "SELECT guid FROM moz_favicons"),
83109:     getter_AddRefs(hasGuidStatement));
83109: 
83109:   if (NS_FAILED(rv)) {
83109:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
83109:       "ALTER TABLE moz_favicons "
83109:       "ADD COLUMN guid TEXT"
83109:     ));
83109:     NS_ENSURE_SUCCESS(rv, rv);
83109: 
86678:     rv = mMainConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_FAVICONS_GUID);
86678:     NS_ENSURE_SUCCESS(rv, rv);
86678:   }
86678: 
86678:   // Generate GUID for any favicon missing it.
83109:   rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
83109:     "UPDATE moz_favicons "
83109:     "SET guid = GENERATE_GUID() "
86678:     "WHERE guid ISNULL "
83109:   ));
83109:   NS_ENSURE_SUCCESS(rv, rv);
83109: 
83109:   return NS_OK;
83109: }
83109: 
84191: nsresult
84191: Database::MigrateV15Up()
84191: {
84191:   MOZ_ASSERT(NS_IsMainThread());
84191: 
84191:   // Drop moz_bookmarks_beforedelete_v1_trigger, since it's more expensive than
84191:   // useful.
84191:   nsresult rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
84191:     "DROP TRIGGER IF EXISTS moz_bookmarks_beforedelete_v1_trigger"
84191:   ));
84191:   NS_ENSURE_SUCCESS(rv, rv);
84191: 
84191:   // Remove any orphan keywords.
84191:   rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
84191:     "DELETE FROM moz_keywords "
84191:     "WHERE NOT EXISTS ( "
84191:       "SELECT id "
84191:       "FROM moz_bookmarks "
84191:       "WHERE keyword_id = moz_keywords.id "
84191:     ")"
84191:   ));
84191:   NS_ENSURE_SUCCESS(rv, rv);
84191: 
84191:   return NS_OK;
84191: }
84191: 
86678: nsresult
86678: Database::MigrateV16Up()
86678: {
86678:   MOZ_ASSERT(NS_IsMainThread());
86678: 
86678:   // Due to Bug 715268 downgraded and then upgraded profiles may lack favicons
86678:   // guids, so fillup any missing ones.
86678:   nsresult rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
86678:     "UPDATE moz_favicons "
86678:     "SET guid = GENERATE_GUID() "
86678:     "WHERE guid ISNULL "
86678:   ));
86678:   NS_ENSURE_SUCCESS(rv, rv);
86678: 
86678:   return NS_OK;
86678: }
86678: 
87706: nsresult
87706: Database::MigrateV17Up()
87706: {
87706:   MOZ_ASSERT(NS_IsMainThread());
87706: 
87706:   bool tableExists = false;
87706: 
87706:   nsresult rv = mMainConn->TableExists(NS_LITERAL_CSTRING("moz_hosts"), &tableExists);
87706:   NS_ENSURE_SUCCESS(rv, rv);
87706: 
87706:   if (!tableExists) {
87706:     // For anyone who used in-development versions of this autocomplete,
87706:     // drop the old tables and its indexes.
87706:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
87706:       "DROP INDEX IF EXISTS moz_hostnames_frecencyindex"
87706:     ));
87706:     NS_ENSURE_SUCCESS(rv, rv);
87706:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
87706:       "DROP TABLE IF EXISTS moz_hostnames"
87706:     ));
87706:     NS_ENSURE_SUCCESS(rv, rv);
87706: 
87706:     // Add the moz_hosts table so we can get hostnames for URL autocomplete.
87706:     rv = mMainConn->ExecuteSimpleSQL(CREATE_MOZ_HOSTS);
87706:     NS_ENSURE_SUCCESS(rv, rv);
87706:   }
87706: 
87706:   // Fill the moz_hosts table with all the domains in moz_places.
87706:   nsCOMPtr<mozIStorageAsyncStatement> fillHostsStmt;
87706:   rv = mMainConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
87706:     "INSERT OR IGNORE INTO moz_hosts (host, frecency) "
87706:         "SELECT fixup_url(get_unreversed_host(h.rev_host)) AS host, "
87706:                "(SELECT MAX(frecency) FROM moz_places "
90704:                 "WHERE rev_host = get_unreversed_host(host || '.') || '.' "
90704:                    "OR rev_host = get_unreversed_host(host || '.') || '.www.') "
87706:                ") AS frecency "
87706:         "FROM moz_places h "
87706:         "WHERE LENGTH(h.rev_host) > 1 "
87706:         "GROUP BY h.rev_host"
87706:   ), getter_AddRefs(fillHostsStmt));
87706:   NS_ENSURE_SUCCESS(rv, rv);
87706: 
87706:   nsCOMPtr<mozIStoragePendingStatement> ps;
87706:   rv = fillHostsStmt->ExecuteAsync(nsnull, getter_AddRefs(ps));
87706:   NS_ENSURE_SUCCESS(rv, rv);
87706: 
87706:   return NS_OK;
87706: }
87706: 
90371: nsresult
90371: Database::MigrateV18Up()
90371: {
90371:   MOZ_ASSERT(NS_IsMainThread());
90371: 
90371:   // moz_hosts should distinguish on typed entries.
90371: 
90371:   // Check if the profile already has a typed column.
90371:   nsCOMPtr<mozIStorageStatement> stmt;
90371:   nsresult rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
90371:     "SELECT typed FROM moz_hosts"
90371:   ), getter_AddRefs(stmt));
90371:   if (NS_FAILED(rv)) {
90371:     rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
90371:       "ALTER TABLE moz_hosts ADD COLUMN typed NOT NULL DEFAULT 0"
90371:     ));
90371:     NS_ENSURE_SUCCESS(rv, rv);
90371:   }
90371: 
90371:   // With the addition of the typed column the covering index loses its
90371:   // advantages.  On the other side querying on host and (optionally) typed
90371:   // largely restricts the number of results, making scans decently fast.
90371:   rv = mMainConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
90371:     "DROP INDEX IF EXISTS moz_hosts_frecencyhostindex"
90371:   ));
90371:   NS_ENSURE_SUCCESS(rv, rv);
90371: 
90371:   // Update typed data.
90371:   nsCOMPtr<mozIStorageAsyncStatement> updateTypedStmt;
90371:   rv = mMainConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
90371:     "UPDATE moz_hosts SET typed = 1 WHERE host IN ( "
90371:       "SELECT fixup_url(get_unreversed_host(rev_host)) "
90371:       "FROM moz_places WHERE typed = 1 "
90371:     ") "
90371:   ), getter_AddRefs(updateTypedStmt));
90371:   NS_ENSURE_SUCCESS(rv, rv);
90371: 
90371:   nsCOMPtr<mozIStoragePendingStatement> ps;
90371:   rv = updateTypedStmt->ExecuteAsync(nsnull, getter_AddRefs(ps));
90371:   NS_ENSURE_SUCCESS(rv, rv);
90371: 
90371:   return NS_OK;
90371: }
90371: 
80946: void
80946: Database::Shutdown()
80946: {
80946:   MOZ_ASSERT(NS_IsMainThread());
80946:   MOZ_ASSERT(!mShuttingDown);
80946: 
80946:   mMainThreadStatements.FinalizeStatements();
80946:   mMainThreadAsyncStatements.FinalizeStatements();
80946: 
80946:   nsRefPtr< FinalizeStatementCacheProxy<mozIStorageStatement> > event =
80946:     new FinalizeStatementCacheProxy<mozIStorageStatement>(
80946:           mAsyncThreadStatements, NS_ISUPPORTS_CAST(nsIObserver*, this)
80946:         );
80946:   DispatchToAsyncThread(event);
80946: 
90280:   nsRefPtr<BlockingConnectionCloseCallback> closeListener =
90280:     new BlockingConnectionCloseCallback();
80946:   (void)mMainConn->AsyncClose(closeListener);
90725:   // The spinning is temporarily disabled. See bug 728653.
90725:   //closeListener->Spin();
80946: 
80946:   // Don't set this earlier, otherwise some internal helper used on shutdown
80946:   // may bail out.
80946:   mShuttingDown = true;
80946: }
80946: 
80946: ////////////////////////////////////////////////////////////////////////////////
80946: //// nsIObserver
80946: 
80946: NS_IMETHODIMP
80946: Database::Observe(nsISupports *aSubject,
80946:                   const char *aTopic,
80946:                   const PRUnichar *aData)
80946: {
86678:   MOZ_ASSERT(NS_IsMainThread());
80946:  
80946:   if (strcmp(aTopic, TOPIC_PROFILE_CHANGE_TEARDOWN) == 0) {
80946:     // Tests simulating shutdown may cause multiple notifications.
80946:     if (mShuttingDown) {
80946:       return NS_OK;
80946:     }
80946: 
80946:     nsCOMPtr<nsIObserverService> os = services::GetObserverService();
80946:     NS_ENSURE_STATE(os);
80946: 
80946:     // If shutdown happens in the same mainthread loop as init, observers could
80946:     // handle the places-init-complete notification after xpcom-shutdown, when
80946:     // the connection does not exist anymore.  Removing those observers would
80946:     // be less expensive but may cause their RemoveObserver calls to throw.
80946:     // Thus notify the topic now, so they stop listening for it.
80946:     nsCOMPtr<nsISimpleEnumerator> e;
80946:     if (NS_SUCCEEDED(os->EnumerateObservers(TOPIC_PLACES_INIT_COMPLETE,
80946:                      getter_AddRefs(e))) && e) {
80946:       bool hasMore = false;
80946:       while (NS_SUCCEEDED(e->HasMoreElements(&hasMore)) && hasMore) {
80946:         nsCOMPtr<nsIObserver> observer;
80946:         if (NS_SUCCEEDED(e->GetNext(getter_AddRefs(observer)))) {
80946:           (void)observer->Observe(observer, TOPIC_PLACES_INIT_COMPLETE, nsnull);
80946:         }
80946:       }
80946:     }
80946: 
80946:     // Notify all Places users that we are about to shutdown.
80946:     (void)os->NotifyObservers(nsnull, TOPIC_PLACES_SHUTDOWN, nsnull);
80946:   }
80946: 
80946:   else if (strcmp(aTopic, TOPIC_PROFILE_BEFORE_CHANGE) == 0) {
80946:     // Tests simulating shutdown may cause re-entrance.
80946:     if (mShuttingDown) {
80946:       return NS_OK;
80946:     }
80946: 
80946:     // Fire internal shutdown notifications.
80946:     nsCOMPtr<nsIObserverService> os = services::GetObserverService();
80946:     if (os) {
80946:       (void)os->NotifyObservers(nsnull, TOPIC_PLACES_WILL_CLOSE_CONNECTION, nsnull);
80946:     }
80946: 
80946: #ifdef DEBUG
80946:     { // Sanity check for missing guids.
86678:       bool haveNullGuids = false;
80946:       nsCOMPtr<mozIStorageStatement> stmt;
86678: 
80946:       nsresult rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:         "SELECT 1 "
80946:         "FROM moz_places "
80946:         "WHERE guid IS NULL "
86678:       ), getter_AddRefs(stmt));
86678:       NS_ENSURE_SUCCESS(rv, rv);
86678:       rv = stmt->ExecuteStep(&haveNullGuids);
86678:       NS_ENSURE_SUCCESS(rv, rv);
86678:       MOZ_ASSERT(!haveNullGuids && "Found a page without a GUID!");
86678: 
86678:       rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
80946:         "SELECT 1 "
80946:         "FROM moz_bookmarks "
80946:         "WHERE guid IS NULL "
86678:       ), getter_AddRefs(stmt));
86678:       NS_ENSURE_SUCCESS(rv, rv);
86678:       rv = stmt->ExecuteStep(&haveNullGuids);
86678:       NS_ENSURE_SUCCESS(rv, rv);
86678:       MOZ_ASSERT(!haveNullGuids && "Found a bookmark without a GUID!");
86678: 
86678:       rv = mMainConn->CreateStatement(NS_LITERAL_CSTRING(
83109:         "SELECT 1 "
83109:         "FROM moz_favicons "
83109:         "WHERE guid IS NULL "
80946:       ), getter_AddRefs(stmt));
80946:       NS_ENSURE_SUCCESS(rv, rv);
80946:       rv = stmt->ExecuteStep(&haveNullGuids);
80946:       NS_ENSURE_SUCCESS(rv, rv);
86678:       MOZ_ASSERT(!haveNullGuids && "Found a favicon without a GUID!");
80946:     }
80946: #endif
80946: 
80946:     // As the last step in the shutdown path, finalize the database handle.
80946:     Shutdown();
80946:   }
80946: 
80946:   return NS_OK;
80946: }
80946: 
80946: } // namespace places
80946: } // namespace mozilla
