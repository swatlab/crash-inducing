    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object for replaced elements with bitmap image data */
    1: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nsHTMLParts.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsImageFrame.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsString.h"
    1: #include "nsPrintfCString.h"
    1: #include "nsPresContext.h"
68481: #include "nsRenderingContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIDocument.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsContentUtils.h"
 8578: #include "nsCSSAnonBoxes.h"
    1: #include "nsStyleContext.h"
    1: #include "nsStyleConsts.h"
52205: #include "nsStyleCoord.h"
52206: #include "nsTransform2D.h"
    1: #include "nsImageMap.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIURL.h"
    1: #include "nsIIOService.h"
    1: #include "nsIURL.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsISupportsPriority.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsNetUtil.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "prprf.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsILink.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsTextFragment.h"
    1: #include "nsIDOMHTMLMapElement.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #ifdef ACCESSIBILITY
61464: #include "nsAccessibilityService.h"
    1: #endif
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsDisplayList.h"
    1: 
    1: #include "imgIContainer.h"
    1: #include "imgILoader.h"
    1: 
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsIDOMRange.h"
    1: 
    1: #include "nsIContentPolicy.h"
    1: #include "nsContentPolicyUtils.h"
68780: #include "nsEventStates.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsBidiUtils.h"
    1: #include "nsBidiPresUtils.h"
    1: 
60712: #include "gfxRect.h"
69186: #include "ImageLayers.h"
60712: 
70840: #include "mozilla/Preferences.h"
72149: #include "mozilla/Util.h" // for DebugOnly
70840: 
70840: using namespace mozilla;
70840: 
    1: // sizes (pixels) for image icon, padding and border frame
    1: #define ICON_SIZE        (16)
    1: #define ICON_PADDING     (3)
    1: #define ALT_BORDER_WIDTH (1)
    1: 
    1: 
    1: //we must add hooks soon
    1: #define IMAGE_EDITOR_CHECK 1
    1: 
    1: // Default alignment value (so we can tell an unset value from a set value)
    1: #define ALIGN_UNSET PRUint8(-1)
    1: 
60712: using namespace mozilla::layers;
71110: using namespace mozilla::dom;
60712: 
    1: // static icon information
    1: nsImageFrame::IconLoad* nsImageFrame::gIconLoad = nsnull;
    1: 
    1: // cached IO service for loading icons
    1: nsIIOService* nsImageFrame::sIOService;
    1: 
    1: // test if the width and height are fixed, looking at the style data
79445: static bool HaveFixedSize(const nsStylePosition* aStylePosition)
    1: {
    1:   // check the width and height values in the reflow state's style struct
    1:   // - if width and height are specified as either coord or percentage, then
    1:   //   the size of the image frame is constrained
49566:   return aStylePosition->mWidth.IsCoordPercentCalcUnit() &&
49566:          aStylePosition->mHeight.IsCoordPercentCalcUnit();
    1: }
    1: // use the data in the reflow state to decide if the image has a constrained size
    1: // (i.e. width and height that are based on the containing block size and not the image size) 
    1: // so we can avoid animated GIF related reflows
79445: inline bool HaveFixedSize(const nsHTMLReflowState& aReflowState)
    1: { 
    1:   NS_ASSERTION(aReflowState.mStylePosition, "crappy reflowState - null stylePosition");
 4166:   // when an image has percent css style height or width, but ComputedHeight() 
    1:   // or ComputedWidth() of reflow state is  NS_UNCONSTRAINEDSIZE  
80486:   // it needs to return false to cause an incremental reflow later
    1:   // if an image is inside table like bug 156731 simple testcase III, 
    1:   // during pass 1 reflow, ComputedWidth() is NS_UNCONSTRAINEDSIZE
80486:   // in pass 2 reflow, ComputedWidth() is 0, it also needs to return false
    1:   // see bug 156731
49566:   const nsStyleCoord &height = aReflowState.mStylePosition->mHeight;
49566:   const nsStyleCoord &width = aReflowState.mStylePosition->mWidth;
51404:   return ((height.HasPercent() &&
49566:            NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight()) ||
51404:           (width.HasPercent() &&
49566:            (NS_UNCONSTRAINEDSIZE == aReflowState.ComputedWidth() ||
    1:             0 == aReflowState.ComputedWidth())))
80486:           ? false
    1:           : HaveFixedSize(aReflowState.mStylePosition); 
    1: }
    1: 
    1: nsIFrame*
    1: NS_NewImageFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsImageFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsImageFrame)
32423: 
    1: 
    1: nsImageFrame::nsImageFrame(nsStyleContext* aContext) :
    1:   ImageFrameSuper(aContext),
    1:   mComputedSize(0, 0),
52205:   mIntrinsicRatio(0, 0),
80486:   mDisplayingIcon(false)
    1: {
    1:   // We assume our size is not constrained and we haven't gotten an
    1:   // initial reflow yet, so don't touch those flags.
52205:   mIntrinsicSize.width.SetCoordValue(0);
52205:   mIntrinsicSize.height.SetCoordValue(0);
    1: }
    1: 
    1: nsImageFrame::~nsImageFrame()
    1: {
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsImageFrame)
69187:   NS_QUERYFRAME_ENTRY(nsImageFrame)
23554: NS_QUERYFRAME_TAIL_INHERITING(ImageFrameSuper)
    1: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsImageFrame::CreateAccessible()
    1: {
61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
    1:   if (accService) {
46338:     return accService->CreateHTMLImageAccessible(mContent,
46338:                                                  PresContext()->PresShell());
    1:   }
    1: 
46338:   return nsnull;
    1: }
    1: #endif
    1: 
    1: void
81039: nsImageFrame::DisconnectMap()
81039: {
81039:   if (mImageMap) {
81039:     mImageMap->Destroy();
81039:     NS_RELEASE(mImageMap);
81039:   }
81039: }
81039: 
81039: void
36647: nsImageFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:   // Tell our image map, if there is one, to clean up
    1:   // This causes the nsImageMap to unregister itself as
    1:   // a DOM listener.
81039:   DisconnectMap();
    1: 
    1:   // set the frame to null so we don't send messages to a dead object.
    1:   if (mListener) {
    1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:     if (imageLoader) {
61720:       // Push a null JSContext on the stack so that code that runs
61720:       // within the below code doesn't think it's being called by
61720:       // JS. See bug 604262.
61720:       nsCxPusher pusher;
61720:       pusher.PushNull();
61720: 
    1:       imageLoader->RemoveObserver(mListener);
    1:     }
    1:     
 3233:     reinterpret_cast<nsImageListener*>(mListener.get())->SetFrame(nsnull);
    1:   }
    1:   
    1:   mListener = nsnull;
    1: 
31389:   // If we were displaying an icon, take ourselves off the list
31389:   if (mDisplayingIcon)
31389:     gIconLoad->RemoveIconObserver(this);
31389: 
36647:   nsSplittableFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::Init(nsIContent*      aContent,
    1:                    nsIFrame*        aParent,
    1:                    nsIFrame*        aPrevInFlow)
    1: {
    1:   nsresult rv = nsSplittableFrame::Init(aContent, aParent, aPrevInFlow);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mListener = new nsImageListener(this);
    1: 
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(aContent);
    1:   NS_ENSURE_TRUE(imageLoader, NS_ERROR_UNEXPECTED);
61720: 
61720:   {
61720:     // Push a null JSContext on the stack so that code that runs
61720:     // within the below code doesn't think it's being called by
61720:     // JS. See bug 604262.
61720:     nsCxPusher pusher;
61720:     pusher.PushNull();
61720: 
    1:     imageLoader->AddObserver(mListener);
61720:   }
    1: 
  238:   nsPresContext *aPresContext = PresContext();
    1:   
    1:   if (!gIconLoad)
    1:     LoadIcons(aPresContext);
    1: 
    1:   // Give image loads associated with an image frame a small priority boost!
    1:   nsCOMPtr<imgIRequest> currentRequest;
    1:   imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                           getter_AddRefs(currentRequest));
    1:   nsCOMPtr<nsISupportsPriority> p = do_QueryInterface(currentRequest);
    1:   if (p)
    1:     p->AdjustPriority(-1);
    1: 
    1:   // If we already have an image container, OnStartContainer won't be called
    1:   // Set the animation mode here
    1:   if (currentRequest) {
    1:     nsCOMPtr<imgIContainer> image;
    1:     currentRequest->GetImage(getter_AddRefs(image));
    1:     if (image) {
    1:       image->SetAnimationMode(aPresContext->ImageAnimationMode());
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
79445: bool
    1: nsImageFrame::UpdateIntrinsicSize(imgIContainer* aImage)
    1: {
    1:   NS_PRECONDITION(aImage, "null image");
52205:   if (!aImage)
80486:     return false;
    1: 
52205:   nsIFrame::IntrinsicSize oldIntrinsicSize = mIntrinsicSize;
    1: 
52205:   nsIFrame* rootFrame = aImage->GetRootLayoutFrame();
52205:   if (rootFrame) {
52205:     // Set intrinsic size to match that of aImage's rootFrame.
52205:     mIntrinsicSize = rootFrame->GetIntrinsicSize();
52205:   } else {
52205:     // Set intrinsic size to match aImage's reported width & height.
23738:     nsIntSize imageSizeInPx;
37457:     if (NS_FAILED(aImage->GetWidth(&imageSizeInPx.width)) ||
37457:         NS_FAILED(aImage->GetHeight(&imageSizeInPx.height))) {
37457:       imageSizeInPx.SizeTo(0, 0);
37457:     }
52205:     mIntrinsicSize.width.SetCoordValue(
52205:       nsPresContext::CSSPixelsToAppUnits(imageSizeInPx.width));
52205:     mIntrinsicSize.height.SetCoordValue(
    1:       nsPresContext::CSSPixelsToAppUnits(imageSizeInPx.height));
    1:   }
    1: 
52205:   return mIntrinsicSize != oldIntrinsicSize;
52205: }
52205: 
79445: bool
52205: nsImageFrame::UpdateIntrinsicRatio(imgIContainer* aImage)
52205: {
52205:   NS_PRECONDITION(aImage, "null image");
52205: 
52205:   if (!aImage)
80486:     return false;
52205: 
52205:   nsSize oldIntrinsicRatio = mIntrinsicRatio;
52205: 
52205:   nsIFrame* rootFrame = aImage->GetRootLayoutFrame();
52205:   if (rootFrame) {
52205:     // Set intrinsic ratio to match that of aImage's rootFrame.
52205:     mIntrinsicRatio = rootFrame->GetIntrinsicRatio();
52205:   } else {
52205:     NS_ABORT_IF_FALSE(mIntrinsicSize.width.GetUnit() == eStyleUnit_Coord &&
52205:                       mIntrinsicSize.height.GetUnit() == eStyleUnit_Coord,
52205:                       "since aImage doesn't have a rootFrame, our intrinsic "
52205:                       "dimensions must have coord units (not percent units)");
52205:     mIntrinsicRatio.width = mIntrinsicSize.width.GetCoordValue();
52205:     mIntrinsicRatio.height = mIntrinsicSize.height.GetCoordValue();
52205:   }
52205: 
52205:   return mIntrinsicRatio != oldIntrinsicRatio;
    1: }
    1: 
79445: bool
52206: nsImageFrame::GetSourceToDestTransform(nsTransform2D& aTransform)
    1: {
52206:   // Set the translation components.
    1:   // XXXbz does this introduce rounding errors because of the cast to
    1:   // float?  Should we just manually add that stuff in every time
    1:   // instead?
    1:   nsRect innerArea = GetInnerArea();
52206:   aTransform.SetToTranslate(float(innerArea.x),
    1:                             float(innerArea.y - GetContinuationOffset()));
    1: 
52206:   // Set the scale factors.
52205:   if (mIntrinsicSize.width.GetUnit() == eStyleUnit_Coord &&
52205:       mIntrinsicSize.width.GetCoordValue() != 0 &&
52205:       mIntrinsicSize.height.GetUnit() == eStyleUnit_Coord &&
52205:       mIntrinsicSize.height.GetCoordValue() != 0 &&
52205:       mIntrinsicSize.width.GetCoordValue() != mComputedSize.width &&
52205:       mIntrinsicSize.height.GetCoordValue() != mComputedSize.height) {
52206: 
52206:     aTransform.SetScale(float(mComputedSize.width)  /
52205:                         float(mIntrinsicSize.width.GetCoordValue()),
52205:                         float(mComputedSize.height) /
52205:                         float(mIntrinsicSize.height.GetCoordValue()));
80486:     return true;
    1:   }
52206: 
80486:   return false;
    1: }
    1: 
    1: /*
    1:  * These two functions basically do the same check.  The first one
    1:  * checks that the given request is the current request for our
    1:  * mContent.  The second checks that the given image container the
    1:  * same as the image container on the current request for our
    1:  * mContent.
    1:  */
79445: bool
    1: nsImageFrame::IsPendingLoad(imgIRequest* aRequest) const
    1: {
    1:   // Default to pending load in case of errors
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader(do_QueryInterface(mContent));
    1:   NS_ASSERTION(imageLoader, "No image loading content?");
    1: 
    1:   PRInt32 requestType = nsIImageLoadingContent::UNKNOWN_REQUEST;
    1:   imageLoader->GetRequestType(aRequest, &requestType);
    1: 
    1:   return requestType != nsIImageLoadingContent::CURRENT_REQUEST;
    1: }
    1: 
79445: bool
    1: nsImageFrame::IsPendingLoad(imgIContainer* aContainer) const
    1: {
    1:   //  default to pending load in case of errors
    1:   if (!aContainer) {
    1:     NS_ERROR("No image container!");
80486:     return true;
    1:   }
    1: 
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader(do_QueryInterface(mContent));
    1:   NS_ASSERTION(imageLoader, "No image loading content?");
    1:   
    1:   nsCOMPtr<imgIRequest> currentRequest;
    1:   imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                           getter_AddRefs(currentRequest));
    1:   if (!currentRequest) {
    1:     NS_ERROR("No current request");
80486:     return true;
    1:   }
    1: 
    1:   nsCOMPtr<imgIContainer> currentContainer;
    1:   currentRequest->GetImage(getter_AddRefs(currentContainer));
    1: 
    1:   return currentContainer != aContainer;
    1:   
    1: }
    1: 
    1: nsRect
23738: nsImageFrame::SourceRectToDest(const nsIntRect& aRect)
    1: {
    1:   // When scaling the image, row N of the source image may (depending on
    1:   // the scaling function) be used to draw any row in the destination image
    1:   // between floor(F * (N-1)) and ceil(F * (N+1)), where F is the
    1:   // floating-point scaling factor.  The same holds true for columns.
    1:   // So, we start by computing that bound without the floor and ceiling.
    1: 
    1:   nsRect r(nsPresContext::CSSPixelsToAppUnits(aRect.x - 1),
    1:            nsPresContext::CSSPixelsToAppUnits(aRect.y - 1),
    1:            nsPresContext::CSSPixelsToAppUnits(aRect.width + 2),
    1:            nsPresContext::CSSPixelsToAppUnits(aRect.height + 2));
    1: 
52206:   nsTransform2D sourceToDest;
52206:   if (!GetSourceToDestTransform(sourceToDest)) {
52206:     // Failed to generate transform matrix. Return our whole inner area,
52206:     // to be on the safe side (since this method is used for generating
52206:     // invalidation rects).
52206:     return GetInnerArea();
52206:   }
52206: 
52206:   sourceToDest.TransformCoord(&r.x, &r.y, &r.width, &r.height);
    1: 
    1:   // Now, round the edges out to the pixel boundary.
52206:   nscoord scale = nsPresContext::CSSPixelsToAppUnits(1);
    1:   nscoord right = r.x + r.width;
    1:   nscoord bottom = r.y + r.height;
    1: 
    1:   r.x -= (scale + (r.x % scale)) % scale;
    1:   r.y -= (scale + (r.y % scale)) % scale;
    1:   r.width = right + ((scale - (right % scale)) % scale) - r.x;
    1:   r.height = bottom + ((scale - (bottom % scale)) % scale) - r.y;
    1: 
    1:   return r;
    1: }
    1: 
    1: // Note that we treat NS_EVENT_STATE_SUPPRESSED images as "OK".  This means
    1: // that we'll construct image frames for them as needed if their display is
    1: // toggled from "none" (though we won't paint them, unless their visibility
    1: // is changed too).
    1: #define BAD_STATES (NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED | \
    1:                     NS_EVENT_STATE_LOADING)
    1: 
    1: // This is a macro so that we don't evaluate the boolean last arg
    1: // unless we have to; it can be expensive
    1: #define IMAGE_OK(_state, _loadingOK)                                           \
56168:    (!(_state).HasAtLeastOneOfStates(BAD_STATES) ||                                    \
56168:     (!(_state).HasAtLeastOneOfStates(NS_EVENT_STATE_BROKEN | NS_EVENT_STATE_USERDISABLED) && \
56168:      (_state).HasState(NS_EVENT_STATE_LOADING) && (_loadingOK)))
    1: 
    1: /* static */
79445: bool
71110: nsImageFrame::ShouldCreateImageFrameFor(Element* aElement,
    1:                                         nsStyleContext* aStyleContext)
    1: {
71116:   nsEventStates state = aElement->State();
    1:   if (IMAGE_OK(state,
    1:                HaveFixedSize(aStyleContext->GetStylePosition()))) {
    1:     // Image is fine; do the image frame thing
80486:     return true;
    1:   }
    1: 
    1:   // Check if we want to use a placeholder box with an icon or just
    1:   // let the presShell make us into inline text.  Decide as follows:
    1:   //
    1:   //  - if our special "force icons" style is set, show an icon
    1:   //  - else if our "do not show placeholders" pref is set, skip the icon
    1:   //  - else:
    1:   //  - if QuirksMode, and there is no alt attribute, and this is not an
    1:   //    <object> (which could not possibly have such an attribute), show an
    1:   //    icon.
    1:   //  - if QuirksMode, and the IMG has a size show an icon.
    1:   //  - otherwise, skip the icon
79445:   bool useSizedBox;
    1:   
    1:   if (aStyleContext->GetStyleUIReset()->mForceBrokenImageIcon) {
80486:     useSizedBox = true;
    1:   }
    1:   else if (gIconLoad && gIconLoad->mPrefForceInlineAltText) {
80486:     useSizedBox = false;
    1:   }
    1:   else {
    1:     if (aStyleContext->PresContext()->CompatibilityMode() !=
    1:         eCompatibility_NavQuirks) {
80486:       useSizedBox = false;
    1:     }
    1:     else {
    1:       // We are in quirks mode, so we can just check the tag name; no need to
    1:       // check the namespace.
71110:       nsIAtom *localName = aElement->Tag();
    1: 
    1:       // Use a sized box if we have no alt text.  This means no alt attribute
    1:       // and the node is not an object or an input (since those always have alt
    1:       // text).
71110:       if (!aElement->HasAttr(kNameSpaceID_None, nsGkAtoms::alt) &&
    1:           localName != nsGkAtoms::object &&
    1:           localName != nsGkAtoms::input) {
80486:         useSizedBox = true;
    1:       }
    1:       else {
    1:         // check whether we have fixed size
    1:         useSizedBox = HaveFixedSize(aStyleContext->GetStylePosition());
    1:       }
    1:     }
    1:   }
    1:   
    1:   return useSizedBox;
    1: }
    1: 
    1: nsresult
    1: nsImageFrame::OnStartContainer(imgIRequest *aRequest, imgIContainer *aImage)
    1: {
    1:   if (!aImage) return NS_ERROR_INVALID_ARG;
    1: 
    1:   /* Get requested animation policy from the pres context:
    1:    *   normal = 0
    1:    *   one frame = 1
    1:    *   one loop = 2
    1:    */
  238:   nsPresContext *presContext = PresContext();
    1:   aImage->SetAnimationMode(presContext->ImageAnimationMode());
80876:   mImageContainer = nsnull;
    1: 
    1:   if (IsPendingLoad(aRequest)) {
    1:     // We don't care
    1:     return NS_OK;
    1:   }
    1:   
79445:   bool intrinsicSizeChanged = UpdateIntrinsicSize(aImage);
77090:   intrinsicSizeChanged = UpdateIntrinsicRatio(aImage) || intrinsicSizeChanged;
    1: 
77090:   if (intrinsicSizeChanged && (mState & IMAGE_GOTINITIALREFLOW)) {
    1:     // Now we need to reflow if we have an unconstrained size and have
    1:     // already gotten the initial reflow
24704:     if (!(mState & IMAGE_SIZECONSTRAINED)) { 
    1:       nsIPresShell *presShell = presContext->GetPresShell();
    1:       NS_ASSERTION(presShell, "No PresShell.");
 1158:       if (presShell) { 
 1158:         presShell->FrameNeedsReflow(this, nsIPresShell::eStyleChange,
 1158:                                     NS_FRAME_IS_DIRTY);
    1:       }
    1:     }
24704:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageFrame::OnDataAvailable(imgIRequest *aRequest,
79445:                               bool aCurrentFrame,
23738:                               const nsIntRect *aRect)
    1: {
    1:   // XXX do we need to make sure that the reflow from the
    1:   // OnStartContainer has been processed before we start calling
    1:   // invalidate?
    1: 
    1:   NS_ENSURE_ARG_POINTER(aRect);
    1: 
    1:   if (!(mState & IMAGE_GOTINITIALREFLOW)) {
    1:     // Don't bother to do anything; we have a reflow coming up!
    1:     return NS_OK;
    1:   }
    1:   
    1:   if (IsPendingLoad(aRequest)) {
    1:     // We don't care
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Don't invalidate if the current visible frame isn't the one the data is
    1:   // from
30479:   if (!aCurrentFrame)
    1:     return NS_OK;
    1: 
52213:   // XXX We really need to round this out, now that we're doing better
52213:   // image scaling!
68638:   nsRect r = aRect->IsEqualInterior(nsIntRect::GetMaxSizedIntRect()) ?
52213:     GetInnerArea() :
52213:     SourceRectToDest(*aRect);
52213: 
    1: #ifdef DEBUG_decode
    1:   printf("Source rect (%d,%d,%d,%d) -> invalidate dest rect (%d,%d,%d,%d)\n",
    1:          aRect->x, aRect->y, aRect->width, aRect->height,
    1:          r.x, r.y, r.width, r.height);
    1: #endif
    1: 
60712:   mImageContainer = nsnull;
19380:   Invalidate(r);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsImageFrame::OnStopDecode(imgIRequest *aRequest,
    1:                            nsresult aStatus,
    1:                            const PRUnichar *aStatusArg)
    1: {
  238:   nsPresContext *presContext = PresContext();
    1:   nsIPresShell *presShell = presContext->GetPresShell();
    1:   NS_ASSERTION(presShell, "No PresShell.");
80876:   mImageContainer = nsnull;
    1: 
    1:   // Check what request type we're dealing with
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:   NS_ASSERTION(imageLoader, "Who's notifying us??");
    1:   PRInt32 loadType = nsIImageLoadingContent::UNKNOWN_REQUEST;
    1:   imageLoader->GetRequestType(aRequest, &loadType);
    1:   if (loadType != nsIImageLoadingContent::CURRENT_REQUEST &&
    1:       loadType != nsIImageLoadingContent::PENDING_REQUEST) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (loadType == nsIImageLoadingContent::PENDING_REQUEST) {
    1:     // May have to switch sizes here!
79445:     bool intrinsicSizeChanged = true;
    1:     if (NS_SUCCEEDED(aStatus)) {
    1:       nsCOMPtr<imgIContainer> imageContainer;
    1:       aRequest->GetImage(getter_AddRefs(imageContainer));
    1:       NS_ASSERTION(imageContainer, "Successful load with no container?");
    1:       intrinsicSizeChanged = UpdateIntrinsicSize(imageContainer);
52205:       intrinsicSizeChanged = UpdateIntrinsicRatio(imageContainer) ||
52205:         intrinsicSizeChanged;
    1:     }
    1:     else {
    1:       // Have to size to 0,0 so that GetDesiredSize recalculates the size
52205:       mIntrinsicSize.width.SetCoordValue(0);
52205:       mIntrinsicSize.height.SetCoordValue(0);
52205:       mIntrinsicRatio.SizeTo(0, 0);
    1:     }
    1: 
    1:     if (mState & IMAGE_GOTINITIALREFLOW) { // do nothing if we haven't gotten the initial reflow yet
    1:       if (!(mState & IMAGE_SIZECONSTRAINED) && intrinsicSizeChanged) {
 1158:         if (presShell) { 
 1158:           presShell->FrameNeedsReflow(this, nsIPresShell::eStyleChange,
 1158:                                       NS_FRAME_IS_DIRTY);
    1:         }
    1:       } else {
    1:         nsSize s = GetSize();
    1:         nsRect r(0, 0, s.width, s.height);
    1:         // Update border+content to account for image change
19380:         Invalidate(r);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
50544: nsImageFrame::FrameChanged(imgIContainer *aContainer,
50544:                            const nsIntRect *aDirtyRect)
    1: {
    1:   if (!GetStyleVisibility()->IsVisible()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (IsPendingLoad(aContainer)) {
    1:     // We don't care about it
    1:     return NS_OK;
    1:   }
    1: 
68638:   nsRect r = aDirtyRect->IsEqualInterior(nsIntRect::GetMaxSizedIntRect()) ?
52214:     GetInnerArea() :
52214:     SourceRectToDest(*aDirtyRect);
    1: 
    1:   // Update border+content to account for image change
19380:   Invalidate(r);
60712:   mImageContainer = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: void
52205: nsImageFrame::EnsureIntrinsicSizeAndRatio(nsPresContext* aPresContext)
    1: {
    1:   // if mIntrinsicSize.width and height are 0, then we should
    1:   // check to see if the size is already known by the image container.
52205:   if (mIntrinsicSize.width.GetUnit() == eStyleUnit_Coord &&
52205:       mIntrinsicSize.width.GetCoordValue() == 0 &&
52205:       mIntrinsicSize.height.GetUnit() == eStyleUnit_Coord &&
52205:       mIntrinsicSize.height.GetCoordValue() == 0) {
31389: 
31389:     // Jump through all the hoops to get the status of the request
    1:     nsCOMPtr<imgIRequest> currentRequest;
    1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
31389:     if (imageLoader)
    1:       imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                               getter_AddRefs(currentRequest));
31389:     PRUint32 status = 0;
31389:     if (currentRequest)
31389:       currentRequest->GetImageStatus(&status);
    1: 
31389:     // If we know the size, we can grab it and use it for an update
31389:     if (status & imgIRequest::STATUS_SIZE_AVAILABLE) {
31389:       nsCOMPtr<imgIContainer> imgCon;
31389:       currentRequest->GetImage(getter_AddRefs(imgCon));
31389:       NS_ABORT_IF_FALSE(imgCon, "SIZE_AVAILABLE, but no imgContainer?");
31389:       UpdateIntrinsicSize(imgCon);
52205:       UpdateIntrinsicRatio(imgCon);
    1:     } else {
    1:       // image request is null or image size not known, probably an
    1:       // invalid image specified
    1:       // - make the image big enough for the icon (it may not be
    1:       // used if inline alt expansion is used instead)
    1:       // XXX: we need this in composer, but it is also good for
    1:       // XXX: general quirks mode to always have room for the icon
    1:       if (aPresContext->CompatibilityMode() == eCompatibility_NavQuirks) {
52205:         nscoord edgeLengthToUse =
52205:           nsPresContext::CSSPixelsToAppUnits(
52205:             ICON_SIZE + (2 * (ICON_PADDING + ALT_BORDER_WIDTH)));
52205:         mIntrinsicSize.width.SetCoordValue(edgeLengthToUse);
52205:         mIntrinsicSize.height.SetCoordValue(edgeLengthToUse);
52205:         mIntrinsicRatio.SizeTo(1, 1);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: /* virtual */ nsSize
68481: nsImageFrame::ComputeSize(nsRenderingContext *aRenderingContext,
    1:                           nsSize aCBSize, nscoord aAvailableWidth,
    1:                           nsSize aMargin, nsSize aBorder, nsSize aPadding,
79445:                           bool aShrinkWrap)
    1: {
  238:   nsPresContext *presContext = PresContext();
52205:   EnsureIntrinsicSizeAndRatio(presContext);
 8142: 
    1:   return nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
    1:                             aRenderingContext, this,
52205:                             mIntrinsicSize, mIntrinsicRatio, aCBSize,
 8142:                             aMargin, aBorder, aPadding);
    1: }
    1: 
    1: nsRect 
    1: nsImageFrame::GetInnerArea() const
    1: {
    1:   return GetContentRect() - GetPosition();
    1: }
    1: 
    1: // get the offset into the content area of the image where aImg starts if it is a continuation.
    1: nscoord 
    1: nsImageFrame::GetContinuationOffset() const
    1: {
    1:   nscoord offset = 0;
    1:   for (nsIFrame *f = GetPrevInFlow(); f; f = f->GetPrevInFlow()) {
    1:     offset += f->GetContentRect().height;
    1:   }
    1:   NS_ASSERTION(offset >= 0, "bogus GetContentRect");
    1:   return offset;
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsImageFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   // XXX The caller doesn't account for constraints of the height,
    1:   // min-height, and max-height properties.
72149:   DebugOnly<nscoord> result;
    1:   DISPLAY_MIN_WIDTH(this, result);
  238:   nsPresContext *presContext = PresContext();
52205:   EnsureIntrinsicSizeAndRatio(presContext);
52205:   return mIntrinsicSize.width.GetUnit() == eStyleUnit_Coord ?
52205:     mIntrinsicSize.width.GetCoordValue() : 0;
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsImageFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   // XXX The caller doesn't account for constraints of the height,
    1:   // min-height, and max-height properties.
72149:   DebugOnly<nscoord> result;
    1:   DISPLAY_PREF_WIDTH(this, result);
  238:   nsPresContext *presContext = PresContext();
52205:   EnsureIntrinsicSizeAndRatio(presContext);
    1:   // convert from normal twips to scaled twips (printing...)
52205:   return mIntrinsicSize.width.GetUnit() == eStyleUnit_Coord ?
52205:     mIntrinsicSize.width.GetCoordValue() : 0;
    1: }
    1: 
53819: /* virtual */ nsIFrame::IntrinsicSize
53819: nsImageFrame::GetIntrinsicSize()
53819: {
53819:   return mIntrinsicSize;
53819: }
53819: 
 2301: /* virtual */ nsSize
 2301: nsImageFrame::GetIntrinsicRatio()
 2301: {
52205:   return mIntrinsicRatio;
 2301: }
 2301: 
    1: NS_IMETHODIMP
    1: nsImageFrame::Reflow(nsPresContext*          aPresContext,
    1:                      nsHTMLReflowMetrics&     aMetrics,
    1:                      const nsHTMLReflowState& aReflowState,
    1:                      nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsImageFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
    1:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
    1:                   ("enter nsImageFrame::Reflow: availSize=%d,%d",
    1:                   aReflowState.availableWidth, aReflowState.availableHeight));
    1: 
    1:   NS_PRECONDITION(mState & NS_FRAME_IN_REFLOW, "frame is not in reflow");
    1: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
    1:   // see if we have a frozen size (i.e. a fixed width and height)
    1:   if (HaveFixedSize(aReflowState)) {
    1:     mState |= IMAGE_SIZECONSTRAINED;
    1:   } else {
    1:     mState &= ~IMAGE_SIZECONSTRAINED;
    1:   }
    1: 
    1:   // XXXldb These two bits are almost exact opposites (except in the
    1:   // middle of the initial reflow); remove IMAGE_GOTINITIALREFLOW.
    1:   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
    1:     mState |= IMAGE_GOTINITIALREFLOW;
    1:   }
    1: 
    1:   mComputedSize = 
 4166:     nsSize(aReflowState.ComputedWidth(), aReflowState.ComputedHeight());
    1: 
    1:   aMetrics.width = mComputedSize.width;
    1:   aMetrics.height = mComputedSize.height;
    1: 
    1:   // add borders and padding
    1:   aMetrics.width  += aReflowState.mComputedBorderPadding.LeftRight();
    1:   aMetrics.height += aReflowState.mComputedBorderPadding.TopBottom();
    1:   
    1:   if (GetPrevInFlow()) {
    1:     aMetrics.width = GetPrevInFlow()->GetSize().width;
    1:     nscoord y = GetContinuationOffset();
    1:     aMetrics.height -= y + aReflowState.mComputedBorderPadding.top;
32531:     aMetrics.height = NS_MAX(0, aMetrics.height);
    1:   }
    1: 
    1: 
    1:   // we have to split images if we are:
    1:   //  in Paginated mode, we need to have a constrained height, and have a height larger than our available height
    1:   PRUint32 loadStatus = imgIRequest::STATUS_NONE;
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:   NS_ASSERTION(imageLoader, "No content node??");
    1:   if (imageLoader) {
    1:     nsCOMPtr<imgIRequest> currentRequest;
    1:     imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                             getter_AddRefs(currentRequest));
    1:     if (currentRequest) {
    1:       currentRequest->GetImageStatus(&loadStatus);
    1:     }
    1:   }
    1:   if (aPresContext->IsPaginated() &&
    1:       ((loadStatus & imgIRequest::STATUS_SIZE_AVAILABLE) || (mState & IMAGE_SIZECONSTRAINED)) &&
    1:       NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight && 
    1:       aMetrics.height > aReflowState.availableHeight) { 
 9869:     // our desired height was greater than 0, so to avoid infinite
 9869:     // splitting, use 1 pixel as the min
32531:     aMetrics.height = NS_MAX(nsPresContext::CSSPixelsToAppUnits(1), aReflowState.availableHeight);
    1:     aStatus = NS_FRAME_NOT_COMPLETE;
    1:   }
    1: 
55039:   aMetrics.SetOverflowAreasToDesiredBounds();
    1:   FinishAndStoreOverflow(&aMetrics);
    1: 
    1:   // Now that that's all done, check whether we're resizing... if we are,
    1:   // invalidate our rect.
    1:   // XXXbz we really only want to do this when reflow is completely done, but
    1:   // we have no way to detect when mRect changes (since SetRect is non-virtual,
    1:   // so this is the best we can do).
    1:   if (mRect.width != aMetrics.width || mRect.height != aMetrics.height) {
19380:     Invalidate(nsRect(0, 0, mRect.width, mRect.height));
    1:   }
    1: 
    1:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
    1:                   ("exit nsImageFrame::Reflow: size=%d,%d",
    1:                   aMetrics.width, aMetrics.height));
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
    1:   return NS_OK;
    1: }
    1: 
    1: // Computes the width of the specified string. aMaxWidth specifies the maximum
    1: // width available. Once this limit is reached no more characters are measured.
    1: // The number of characters that fit within the maximum width are returned in
    1: // aMaxFit. NOTE: it is assumed that the fontmetrics have already been selected
    1: // into the rendering context before this is called (for performance). MMP
    1: nscoord
    1: nsImageFrame::MeasureString(const PRUnichar*     aString,
    1:                             PRInt32              aLength,
    1:                             nscoord              aMaxWidth,
    1:                             PRUint32&            aMaxFit,
68481:                             nsRenderingContext& aContext)
    1: {
    1:   nscoord totalWidth = 0;
80486:   aContext.SetTextRunRTL(false);
68484:   nscoord spaceWidth = aContext.GetWidth(' ');
    1: 
    1:   aMaxFit = 0;
    1:   while (aLength > 0) {
    1:     // Find the next place we can line break
    1:     PRUint32  len = aLength;
79445:     bool      trailingSpace = false;
    1:     for (PRInt32 i = 0; i < aLength; i++) {
    1:       if (XP_IS_SPACE(aString[i]) && (i > 0)) {
    1:         len = i;  // don't include the space when measuring
80486:         trailingSpace = true;
    1:         break;
    1:       }
    1:     }
    1:   
    1:     // Measure this chunk of text, and see if it fits
    1:     nscoord width =
    1:       nsLayoutUtils::GetStringWidth(this, &aContext, aString, len);
79445:     bool    fits = (totalWidth + width) <= aMaxWidth;
    1: 
    1:     // If it fits on the line, or it's the first word we've processed then
    1:     // include it
    1:     if (fits || (0 == totalWidth)) {
    1:       // New piece fits
    1:       totalWidth += width;
    1: 
    1:       // If there's a trailing space then see if it fits as well
    1:       if (trailingSpace) {
    1:         if ((totalWidth + spaceWidth) <= aMaxWidth) {
    1:           totalWidth += spaceWidth;
    1:         } else {
    1:           // Space won't fit. Leave it at the end but don't include it in
    1:           // the width
80486:           fits = false;
    1:         }
    1: 
    1:         len++;
    1:       }
    1: 
    1:       aMaxFit += len;
    1:       aString += len;
    1:       aLength -= len;
    1:     }
    1: 
    1:     if (!fits) {
    1:       break;
    1:     }
    1:   }
    1:   return totalWidth;
    1: }
    1: 
    1: // Formats the alt-text to fit within the specified rectangle. Breaks lines
    1: // between words if a word would extend past the edge of the rectangle
    1: void
    1: nsImageFrame::DisplayAltText(nsPresContext*      aPresContext,
68481:                              nsRenderingContext& aRenderingContext,
    1:                              const nsString&      aAltText,
    1:                              const nsRect&        aRect)
    1: {
    1:   // Set font and color
    1:   aRenderingContext.SetColor(GetStyleColor()->mColor);
76295:   nsRefPtr<nsFontMetrics> fm;
76295:   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
76295:   aRenderingContext.SetFont(fm);
    1: 
    1:   // Format the text to display within the formatting rect
    1: 
68495:   nscoord maxAscent = fm->MaxAscent();
68495:   nscoord maxDescent = fm->MaxDescent();
68495:   nscoord height = fm->MaxHeight();
    1: 
    1:   // XXX It would be nice if there was a way to have the font metrics tell
    1:   // use where to break the text given a maximum width. At a minimum we need
    1:   // to be able to get the break character...
    1:   const PRUnichar* str = aAltText.get();
    1:   PRInt32          strLen = aAltText.Length();
    1:   nscoord          y = aRect.y;
30204: 
30204:   if (!aPresContext->BidiEnabled() && HasRTLChars(aAltText)) {
30204:     aPresContext->SetBidiEnabled();
30204:   }
30204: 
    1:   // Always show the first line, even if we have to clip it below
79445:   bool firstLine = true;
    1:   while ((strLen > 0) && (firstLine || (y + maxDescent) < aRect.YMost())) {
    1:     // Determine how much of the text to display on this line
    1:     PRUint32  maxFit;  // number of characters that fit
    1:     nscoord strWidth = MeasureString(str, strLen, aRect.width, maxFit,
    1:                                      aRenderingContext);
    1:     
    1:     // Display the text
    1:     nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:     if (aPresContext->BidiEnabled()) {
    1:       const nsStyleVisibility* vis = GetStyleVisibility();
    1:       if (vis->mDirection == NS_STYLE_DIRECTION_RTL)
73724:         rv = nsBidiPresUtils::RenderText(str, maxFit, NSBIDI_RTL,
    1:                                          aPresContext, aRenderingContext,
60677:                                          aRenderingContext,
    1:                                          aRect.XMost() - strWidth, y + maxAscent);
    1:       else
73724:         rv = nsBidiPresUtils::RenderText(str, maxFit, NSBIDI_LTR,
    1:                                          aPresContext, aRenderingContext,
60677:                                          aRenderingContext,
    1:                                          aRect.x, y + maxAscent);
    1:     }
    1:     if (NS_FAILED(rv))
    1:       aRenderingContext.DrawString(str, maxFit, aRect.x, y + maxAscent);
    1: 
    1:     // Move to the next line
    1:     str += maxFit;
    1:     strLen -= maxFit;
    1:     y += height;
80486:     firstLine = false;
    1:   }
    1: }
    1: 
    1: struct nsRecessedBorder : public nsStyleBorder {
    1:   nsRecessedBorder(nscoord aBorderWidth, nsPresContext* aPresContext)
    1:     : nsStyleBorder(aPresContext)
    1:   {
    1:     NS_FOR_CSS_SIDES(side) {
    1:       // Note: use SetBorderColor here because we want to make sure
    1:       // the "special" flags are unset.
    1:       SetBorderColor(side, NS_RGB(0, 0, 0));
68637:       mBorder.Side(side) = aBorderWidth;
    1:       // Note: use SetBorderStyle here because we want to affect
    1:       // mComputedBorder
    1:       SetBorderStyle(side, NS_STYLE_BORDER_STYLE_INSET);
    1:     }
    1:   }
    1: };
    1: 
    1: void
68481: nsImageFrame::DisplayAltFeedback(nsRenderingContext& aRenderingContext,
    1:                                  const nsRect&        aDirtyRect,
    1:                                  imgIRequest*         aRequest,
    1:                                  nsPoint              aPt)
    1: {
31389:   // We should definitely have a gIconLoad here.
31389:   NS_ABORT_IF_FALSE(gIconLoad, "How did we succeed in Init then?");
31389: 
    1:   // Calculate the inner area
    1:   nsRect  inner = GetInnerArea() + aPt;
    1: 
    1:   // Display a recessed one pixel border
    1:   nscoord borderEdgeWidth = nsPresContext::CSSPixelsToAppUnits(ALT_BORDER_WIDTH);
    1: 
    1:   // if inner area is empty, then make it big enough for at least the icon
    1:   if (inner.IsEmpty()){
    1:     inner.SizeTo(2*(nsPresContext::CSSPixelsToAppUnits(ICON_SIZE+ICON_PADDING+ALT_BORDER_WIDTH)),
    1:                  2*(nsPresContext::CSSPixelsToAppUnits(ICON_SIZE+ICON_PADDING+ALT_BORDER_WIDTH)));
    1:   }
    1: 
    1:   // Make sure we have enough room to actually render the border within
    1:   // our frame bounds
    1:   if ((inner.width < 2 * borderEdgeWidth) || (inner.height < 2 * borderEdgeWidth)) {
    1:     return;
    1:   }
    1: 
    1:   // Paint the border
  238:   nsRecessedBorder recessedBorder(borderEdgeWidth, PresContext());
40180:   nsCSSRendering::PaintBorderWithStyleBorder(PresContext(), aRenderingContext,
40180:                                              this, inner, inner,
40180:                                              recessedBorder, mStyleContext);
    1: 
    1:   // Adjust the inner rect to account for the one pixel recessed border,
    1:   // and a six pixel padding on each edge
    1:   inner.Deflate(nsPresContext::CSSPixelsToAppUnits(ICON_PADDING+ALT_BORDER_WIDTH), 
    1:                 nsPresContext::CSSPixelsToAppUnits(ICON_PADDING+ALT_BORDER_WIDTH));
    1:   if (inner.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // Clip so we don't render outside the inner rect
    1:   aRenderingContext.PushState();
68485:   aRenderingContext.IntersectClip(inner);
    1: 
    1:   // Check if we should display image placeholders
31389:   if (gIconLoad->mPrefShowPlaceholders) {
    1:     const nsStyleVisibility* vis = GetStyleVisibility();
    1:     nscoord size = nsPresContext::CSSPixelsToAppUnits(ICON_SIZE);
    1: 
79445:     bool iconUsed = false;
    1: 
31389:     // If we weren't previously displaying an icon, register ourselves
31389:     // as an observer for load and animation updates and flag that we're
31389:     // doing so now.
32090:     if (aRequest && !mDisplayingIcon) {
31389:       gIconLoad->AddIconObserver(this);
80486:       mDisplayingIcon = true;
31389:     }
31389: 
31389: 
31389:     // If the image in question is loaded and decoded, draw it
32090:     PRUint32 imageStatus = 0;
32090:     if (aRequest)
31389:       aRequest->GetImageStatus(&imageStatus);
31389:     if (imageStatus & imgIRequest::STATUS_FRAME_COMPLETE) {
    1:       nsCOMPtr<imgIContainer> imgCon;
    1:       aRequest->GetImage(getter_AddRefs(imgCon));
31389:       NS_ABORT_IF_FALSE(imgCon, "Frame Complete, but no image container?");
    1:       nsRect dest((vis->mDirection == NS_STYLE_DIRECTION_RTL) ?
    1:                   inner.XMost() - size : inner.x,
    1:                   inner.y, size, size);
26926:       nsLayoutUtils::DrawSingleImage(&aRenderingContext, imgCon,
32424:         nsLayoutUtils::GetGraphicsFilterForFrame(this), dest, aDirtyRect,
32424:         imgIContainer::FLAG_NONE);
80486:       iconUsed = true;
    1:     }
    1: 
31389:     // if we could not draw the icon, flag that we're waiting for it and
31389:     // just draw some graffiti in the mean time
    1:     if (!iconUsed) {
    1:       nscoord iconXPos = (vis->mDirection ==   NS_STYLE_DIRECTION_RTL) ?
    1:                          inner.XMost() - size : inner.x;
    1:       nscoord twoPX = nsPresContext::CSSPixelsToAppUnits(2);
    1:       aRenderingContext.DrawRect(iconXPos, inner.y,size,size);
68482:       aRenderingContext.PushState();
    1:       aRenderingContext.SetColor(NS_RGB(0xFF,0,0));
    1:       aRenderingContext.FillEllipse(size/2 + iconXPos, size/2 + inner.y,
    1:                                     size/2 - twoPX, size/2 - twoPX);
68482:       aRenderingContext.PopState();
    1:     }
    1: 
    1:     // Reduce the inner rect by the width of the icon, and leave an
    1:     // additional ICON_PADDING pixels for padding
    1:     PRInt32 iconWidth = nsPresContext::CSSPixelsToAppUnits(ICON_SIZE + ICON_PADDING);
    1:     if (vis->mDirection != NS_STYLE_DIRECTION_RTL)
    1:       inner.x += iconWidth;
    1:     inner.width -= iconWidth;
    1:   }
    1: 
    1:   // If there's still room, display the alt-text
    1:   if (!inner.IsEmpty()) {
    1:     nsIContent* content = GetContent();
    1:     if (content) {
    1:       nsXPIDLString altText;
    1:       nsCSSFrameConstructor::GetAlternateTextFor(content, content->Tag(),
    1:                                                  altText);
  238:       DisplayAltText(PresContext(), aRenderingContext, altText, inner);
    1:     }
    1:   }
    1: 
    1:   aRenderingContext.PopState();
    1: }
    1: 
68481: static void PaintAltFeedback(nsIFrame* aFrame, nsRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect, nsPoint aPt)
    1: {
 3233:   nsImageFrame* f = static_cast<nsImageFrame*>(aFrame);
71116:   nsEventStates state = f->GetContent()->AsElement()->State();
    1:   f->DisplayAltFeedback(*aCtx,
    1:                         aDirtyRect,
80486:                         IMAGE_OK(state, true)
    1:                            ? nsImageFrame::gIconLoad->mLoadingImage
    1:                            : nsImageFrame::gIconLoad->mBrokenImage,
    1:                         aPt);
    1: }
    1: 
    1: #ifdef NS_DEBUG
68481: static void PaintDebugImageMap(nsIFrame* aFrame, nsRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect, nsPoint aPt) {
 3233:   nsImageFrame* f = static_cast<nsImageFrame*>(aFrame);
    1:   nsRect inner = f->GetInnerArea() + aPt;
    1: 
    1:   aCtx->SetColor(NS_RGB(0, 0, 0));
    1:   aCtx->PushState();
68479:   aCtx->Translate(inner.TopLeft());
79435:   f->GetImageMap()->Draw(aFrame, *aCtx);
    1:   aCtx->PopState();
    1: }
    1: #endif
    1: 
    1: void
    1: nsDisplayImage::Paint(nsDisplayListBuilder* aBuilder,
68481:                       nsRenderingContext* aCtx) {
 3233:   static_cast<nsImageFrame*>(mFrame)->
51261:     PaintImage(*aCtx, ToReferenceFrame(), mVisibleRect, mImage,
32424:                aBuilder->ShouldSyncDecodeImages()
32424:                  ? (PRUint32) imgIContainer::FLAG_SYNC_DECODE
32424:                  : (PRUint32) imgIContainer::FLAG_NONE);
    1: }
    1: 
60712: nsCOMPtr<imgIContainer>
60712: nsDisplayImage::GetImage()
60712: {
60712:   return mImage;
60712: }
60712: 
60712: nsRefPtr<ImageContainer>
60712: nsDisplayImage::GetContainer(LayerManager* aManager)
60712: {
60712:   return static_cast<nsImageFrame*>(mFrame)->GetContainer(aManager, mImage);
60712: }
60712: 
60712: void
60712: nsDisplayImage::ConfigureLayer(ImageLayer* aLayer)
60712: {
60712:   aLayer->SetFilter(nsLayoutUtils::GetGraphicsFilterForFrame(mFrame));
60712:   
81632:   PRInt32 factor = mFrame->PresContext()->AppUnitsPerDevPixel();
60712:   nsImageFrame* imageFrame = static_cast<nsImageFrame*>(mFrame);
60712: 
60712:   nsRect dest = imageFrame->GetInnerArea() + ToReferenceFrame();
60712:   gfxRect destRect(dest.x, dest.y, dest.width, dest.height);
60712:   destRect.ScaleInverse(factor); 
60712: 
60712:   PRInt32 imageWidth;
60712:   PRInt32 imageHeight;
60712:   mImage->GetWidth(&imageWidth);
60712:   mImage->GetHeight(&imageHeight);
60712: 
60712:   gfxMatrix transform;
68632:   transform.Translate(destRect.TopLeft());
68632:   transform.Scale(destRect.Width()/imageWidth,
68632:                   destRect.Height()/imageHeight);
60712:   aLayer->SetTransform(gfx3DMatrix::From2D(transform));
60712: 
60712:   aLayer->SetVisibleRegion(nsIntRect(0, 0, imageWidth, imageHeight));
60712: }
60712: 
60712: nsRefPtr<ImageContainer>
60712: nsImageFrame::GetContainer(LayerManager* aManager, imgIContainer* aImage)
60712: {
80876:   if (mImageContainer && 
80876:       (mImageContainer->Manager() == aManager || 
80876:        (!mImageContainer->Manager() && 
80876:         (mImageContainer->GetBackendType() == aManager->GetBackendType())))) {
60712:     return mImageContainer;
60712:   }
60712: 
60712:   if (aImage->GetType() != imgIContainer::TYPE_RASTER) {
60712:     return nsnull;
60712:   }
60712:   
60712:   CairoImage::Data cairoData;
60712:   nsRefPtr<gfxASurface> imageSurface;
81898:   nsresult rv = aImage->GetFrame(imgIContainer::FRAME_CURRENT,
60712:                                  imgIContainer::FLAG_SYNC_DECODE,
60712:                                  getter_AddRefs(imageSurface));
81898:   NS_ENSURE_SUCCESS(rv, nsnull);
81898: 
60712:   cairoData.mSurface = imageSurface;
60712:   aImage->GetWidth(&cairoData.mSize.width);
60712:   aImage->GetHeight(&cairoData.mSize.height);
60712: 
60712:   mImageContainer = aManager->CreateImageContainer();
60712:   NS_ASSERTION(mImageContainer, "Failed to create ImageContainer!");
60712:   
60712:   // Now create a CairoImage to display the surface.
60712:   Image::Format cairoFormat = Image::CAIRO_SURFACE;
60712:   nsRefPtr<Image> image = mImageContainer->CreateImage(&cairoFormat, 1);
60712:   NS_ASSERTION(image, "Failed to create Image");
60712: 
60712:   NS_ASSERTION(image->GetFormat() == cairoFormat, "Wrong format");
60712:   static_cast<CairoImage*>(image.get())->SetData(cairoData);
60712:   mImageContainer->SetCurrentImage(image);
60712: 
60712:   return mImageContainer;
60712: }
60712: 
    1: void
68481: nsImageFrame::PaintImage(nsRenderingContext& aRenderingContext, nsPoint aPt,
32424:                          const nsRect& aDirtyRect, imgIContainer* aImage,
32424:                          PRUint32 aFlags)
    1: {
    1:   // Render the image into our content area (the area inside
    1:   // the borders and padding)
    1:   NS_ASSERTION(GetInnerArea().width == mComputedSize.width, "bad width");
    1:   nsRect inner = GetInnerArea() + aPt;
    1:   nsRect dest(inner.TopLeft(), mComputedSize);
    1:   dest.y -= GetContinuationOffset();
    1: 
26926:   nsLayoutUtils::DrawSingleImage(&aRenderingContext, aImage,
32424:     nsLayoutUtils::GetGraphicsFilterForFrame(this), dest, aDirtyRect,
32424:     aFlags);
    1: 
79435:   nsImageMap* map = GetImageMap();
    1:   if (nsnull != map) {
    1:     aRenderingContext.PushState();
    1:     aRenderingContext.SetColor(NS_RGB(0, 0, 0));
    1:     aRenderingContext.SetLineStyle(nsLineStyle_kDotted);
68479:     aRenderingContext.Translate(inner.TopLeft());
16486:     map->Draw(this, aRenderingContext);
    1:     aRenderingContext.PopState();
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                const nsRect&           aDirtyRect,
    1:                                const nsDisplayListSet& aLists)
    1: {
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   // REVIEW: We don't need any special logic here for deciding which layer
    1:   // to put the background in ... it goes in aLists.BorderBackground() and
    1:   // then if we have a block parent, it will put our background in the right
    1:   // place.
    1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   // REVIEW: Checking mRect.IsEmpty() makes no sense to me, so I removed it.
    1:   // It can't have been protecting us against bad situations with zero-size
    1:   // images since adding a border would make the rect non-empty.
    1: 
52294:   nsDisplayList replacedContent;
    1:   if (mComputedSize.width != 0 && mComputedSize.height != 0) {
    1:     nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:     NS_ASSERTION(imageLoader, "Not an image loading content?");
    1: 
    1:     nsCOMPtr<imgIRequest> currentRequest;
    1:     if (imageLoader) {
    1:       imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                               getter_AddRefs(currentRequest));
    1:     }
    1: 
71116:     nsEventStates contentState = mContent->AsElement()->State();
79445:     bool imageOK = IMAGE_OK(contentState, true);
    1: 
    1:     nsCOMPtr<imgIContainer> imgCon;
    1:     if (currentRequest) {
    1:       currentRequest->GetImage(getter_AddRefs(imgCon));
    1:     }
    1: 
31389:     // Determine if the size is available
79445:     bool haveSize = false;
31389:     PRUint32 imageStatus = 0;
31389:     if (currentRequest)
31389:       currentRequest->GetImageStatus(&imageStatus);
31389:     if (imageStatus & imgIRequest::STATUS_SIZE_AVAILABLE)
80486:       haveSize = true;
31389: 
31389:     // We should never have the size and not have an image container
31389:     NS_ABORT_IF_FALSE(!haveSize || imgCon, "Have size but not container?");
31389: 
31389:     if (!imageOK || !haveSize) {
    1:       // No image yet, or image load failed. Draw the alt-text and an icon
    1:       // indicating the status
52294:       rv = replacedContent.AppendNewToTop(new (aBuilder)
51260:           nsDisplayGeneric(aBuilder, this, PaintAltFeedback, "AltFeedback",
47732:                            nsDisplayItem::TYPE_ALT_FEEDBACK));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else {
52294:       rv = replacedContent.AppendNewToTop(new (aBuilder)
51260:           nsDisplayImage(aBuilder, this, imgCon));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
31389:       // If we were previously displaying an icon, we're not anymore
31389:       if (mDisplayingIcon) {
31389:         gIconLoad->RemoveIconObserver(this);
80486:         mDisplayingIcon = false;
31389:       }
31389: 
31389:         
    1: #ifdef DEBUG
79435:       if (GetShowFrameBorders() && GetImageMap()) {
    1:         rv = aLists.Outlines()->AppendNewToTop(new (aBuilder)
51260:             nsDisplayGeneric(aBuilder, this, PaintDebugImageMap, "DebugImageMap",
47732:                              nsDisplayItem::TYPE_DEBUG_IMAGE_MAP));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1: #endif
    1:     }
    1:   }
    1: 
55050:   if (ShouldDisplaySelection()) {
55050:     rv = DisplaySelectionOverlay(aBuilder, &replacedContent,
55050:                                  nsISelectionDisplay::DISPLAY_IMAGES);
55050:     NS_ENSURE_SUCCESS(rv, rv);
55050:   }
55050: 
55050:   WrapReplacedContentForBorderRadius(aBuilder, &replacedContent, aLists);
55050: 
55050:   return NS_OK;
55050: }
55050: 
55050: bool
55050: nsImageFrame::ShouldDisplaySelection()
55050: {
    1:   // XXX what on EARTH is this code for?
    1:   nsresult result;
  238:   nsPresContext* presContext = PresContext();
39668:   PRInt16 displaySelection = presContext->PresShell()->GetSelectionFlags();
    1:   if (!(displaySelection & nsISelectionDisplay::DISPLAY_IMAGES))
55050:     return false;//no need to check the blue border, we cannot be drawn selected
    1: //insert hook here for image selection drawing
    1: #if IMAGE_EDITOR_CHECK
    1:   //check to see if this frame is in an editor context
    1:   //isEditor check. this needs to be changed to have better way to check
    1:   if (displaySelection == nsISelectionDisplay::DISPLAY_ALL) 
    1:   {
    1:     nsCOMPtr<nsISelectionController> selCon;
    1:     result = GetSelectionController(presContext, getter_AddRefs(selCon));
    1:     if (NS_SUCCEEDED(result) && selCon)
    1:     {
    1:       nsCOMPtr<nsISelection> selection;
    1:       result = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
    1:       if (NS_SUCCEEDED(result) && selection)
    1:       {
    1:         PRInt32 rangeCount;
    1:         selection->GetRangeCount(&rangeCount);
    1:         if (rangeCount == 1) //if not one then let code drop to nsFrame::Paint
    1:         {
    1:           nsCOMPtr<nsIContent> parentContent = mContent->GetParent();
    1:           if (parentContent)
    1:           {
    1:             PRInt32 thisOffset = parentContent->IndexOf(mContent);
    1:             nsCOMPtr<nsIDOMNode> parentNode = do_QueryInterface(parentContent);
    1:             nsCOMPtr<nsIDOMNode> rangeNode;
    1:             PRInt32 rangeOffset;
    1:             nsCOMPtr<nsIDOMRange> range;
    1:             selection->GetRangeAt(0,getter_AddRefs(range));
    1:             if (range)
    1:             {
    1:               range->GetStartContainer(getter_AddRefs(rangeNode));
    1:               range->GetStartOffset(&rangeOffset);
    1: 
    1:               if (parentNode && rangeNode && (rangeNode == parentNode) && rangeOffset == thisOffset)
    1:               {
    1:                 range->GetEndContainer(getter_AddRefs(rangeNode));
    1:                 range->GetEndOffset(&rangeOffset);
    1:                 if ((rangeNode == parentNode) && (rangeOffset == (thisOffset +1))) //+1 since that would mean this whole content is selected only
55050:                   return false; //do not allow nsFrame do draw any further selection
    1:               }
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: #endif
55050:   return true;
    1: }
    1: 
    1: nsImageMap*
79435: nsImageFrame::GetImageMap()
    1: {
    1:   if (!mImageMap) {
    1:     nsIDocument* doc = mContent->GetDocument();
    1:     if (!doc) {
    1:       return nsnull;
    1:     }
    1: 
    1:     nsAutoString usemap;
    1:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::usemap, usemap);
    1: 
71032:     nsCOMPtr<nsIContent> map = doc->FindImageMap(usemap);
    1:     if (map) {
    1:       mImageMap = new nsImageMap();
    1:       NS_ADDREF(mImageMap);
79435:       mImageMap->Init(this, map);
    1:     }
    1:   }
    1: 
    1:   return mImageMap;
    1: }
    1: 
79445: bool
    1: nsImageFrame::IsServerImageMap()
    1: {
    1:   return mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::ismap);
    1: }
    1: 
    1: // Translate an point that is relative to our frame
    1: // into a localized pixel coordinate that is relative to the
    1: // content area of this frame (inside the border+padding).
    1: void
    1: nsImageFrame::TranslateEventCoords(const nsPoint& aPoint,
    1:                                    nsIntPoint&     aResult)
    1: {
    1:   nscoord x = aPoint.x;
    1:   nscoord y = aPoint.y;
    1: 
    1:   // Subtract out border and padding here so that the coordinates are
    1:   // now relative to the content area of this frame.
    1:   nsRect inner = GetInnerArea();
    1:   x -= inner.x;
    1:   y -= inner.y;
    1: 
    1:   aResult.x = nsPresContext::AppUnitsToIntCSSPixels(x);
    1:   aResult.y = nsPresContext::AppUnitsToIntCSSPixels(y);
    1: }
    1: 
79445: bool
    1: nsImageFrame::GetAnchorHREFTargetAndNode(nsIURI** aHref, nsString& aTarget,
 3333:                                          nsIContent** aNode)
    1: {
79445:   bool status = false;
    1:   aTarget.Truncate();
    1:   *aHref = nsnull;
    1:   *aNode = nsnull;
    1: 
    1:   // Walk up the content tree, looking for an nsIDOMAnchorElement
    1:   for (nsIContent* content = mContent->GetParent();
    1:        content; content = content->GetParent()) {
    1:     nsCOMPtr<nsILink> link(do_QueryInterface(content));
    1:     if (link) {
32993:       nsCOMPtr<nsIURI> href = content->GetHrefURI();
32993:       if (href) {
32993:         href->Clone(aHref);
32993:       }
    1:       status = (*aHref != nsnull);
    1: 
    1:       nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(content));
    1:       if (anchor) {
    1:         anchor->GetTarget(aTarget);
    1:       }
    1:       NS_ADDREF(*aNode = content);
    1:       break;
    1:     }
    1:   }
    1:   return status;
    1: }
    1: 
    1: NS_IMETHODIMP  
79435: nsImageFrame::GetContentForEvent(nsEvent* aEvent,
    1:                                  nsIContent** aContent)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aContent);
32180: 
32180:   nsIFrame* f = nsLayoutUtils::GetNonGeneratedAncestor(this);
32180:   if (f != this) {
79435:     return f->GetContentForEvent(aEvent, aContent);
32180:   }
32180: 
37877:   // XXX We need to make this special check for area element's capturing the
37877:   // mouse due to bug 135040. Remove it once that's fixed.
37877:   nsIContent* capturingContent =
37877:     NS_IS_MOUSE_EVENT(aEvent) ? nsIPresShell::GetCapturingContent() : nsnull;
37877:   if (capturingContent && capturingContent->GetPrimaryFrame() == this) {
37877:     *aContent = capturingContent;
37877:     NS_IF_ADDREF(*aContent);
37877:     return NS_OK;
37877:   }
37877: 
79435:   nsImageMap* map = GetImageMap();
    1: 
    1:   if (nsnull != map) {
    1:     nsIntPoint p;
    1:     TranslateEventCoords(
    1:       nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this), p);
79445:     bool inside = false;
81081:     nsCOMPtr<nsIContent> area = map->GetArea(p.x, p.y);
81081:     if (area) {
81081:       area.swap(*aContent);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   *aContent = GetContent();
    1:   NS_IF_ADDREF(*aContent);
    1:   return NS_OK;
    1: }
    1: 
    1: // XXX what should clicks on transparent pixels do?
    1: NS_IMETHODIMP
    1: nsImageFrame::HandleEvent(nsPresContext* aPresContext,
    1:                           nsGUIEvent* aEvent,
    1:                           nsEventStatus* aEventStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
    1: 
19264:   if ((aEvent->eventStructType == NS_MOUSE_EVENT &&
19264:        aEvent->message == NS_MOUSE_BUTTON_UP && 
 3233:        static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton) ||
    1:       aEvent->message == NS_MOUSE_MOVE) {
79435:     nsImageMap* map = GetImageMap();
79445:     bool isServerMap = IsServerImageMap();
    1:     if ((nsnull != map) || isServerMap) {
    1:       nsIntPoint p;
    1:       TranslateEventCoords(
    1:         nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this), p);
79445:       bool inside = false;
    1:       // Even though client-side image map triggering happens
    1:       // through content, we need to make sure we're not inside
    1:       // (in case we deal with a case of both client-side and
    1:       // sever-side on the same image - it happens!)
    1:       if (nsnull != map) {
81081:         inside = !!map->GetArea(p.x, p.y);
    1:       }
    1: 
    1:       if (!inside && isServerMap) {
    1: 
    1:         // Server side image maps use the href in a containing anchor
    1:         // element to provide the basis for the destination url.
    1:         nsCOMPtr<nsIURI> uri;
    1:         nsAutoString target;
 3333:         nsCOMPtr<nsIContent> anchorNode;
    1:         if (GetAnchorHREFTargetAndNode(getter_AddRefs(uri), target,
    1:                                        getter_AddRefs(anchorNode))) {
    1:           // XXX if the mouse is over/clicked in the border/padding area
    1:           // we should probably just pretend nothing happened. Nav4
    1:           // keeps the x,y coordinates positive as we do; IE doesn't
    1:           // bother. Both of them send the click through even when the
    1:           // mouse is over the border.
    1:           if (p.x < 0) p.x = 0;
    1:           if (p.y < 0) p.y = 0;
    1:           nsCAutoString spec;
    1:           uri->GetSpec(spec);
    1:           spec += nsPrintfCString("?%d,%d", p.x, p.y);
    1:           uri->SetSpec(spec);                
    1:           
79445:           bool clicked = false;
    1:           if (aEvent->message == NS_MOUSE_BUTTON_UP) {
    1:             *aEventStatus = nsEventStatus_eConsumeDoDefault; 
80486:             clicked = true;
    1:           }
 3333:           nsContentUtils::TriggerLink(anchorNode, aPresContext, uri, target,
80486:                                       clicked, true, true);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return nsSplittableFrame::HandleEvent(aPresContext, aEvent, aEventStatus);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::GetCursor(const nsPoint& aPoint,
    1:                         nsIFrame::Cursor& aCursor)
    1: {
79435:   nsImageMap* map = GetImageMap();
    1:   if (nsnull != map) {
    1:     nsIntPoint p;
    1:     TranslateEventCoords(aPoint, p);
81081:     nsCOMPtr<nsIContent> area = map->GetArea(p.x, p.y);
81081:     if (area) {
    1:       // Use the cursor from the style of the *area* element.
    1:       // XXX Using the image as the parent style context isn't
    1:       // technically correct, but it's probably the right thing to do
    1:       // here, since it means that areas on which the cursor isn't
    1:       // specified will inherit the style from the image.
    1:       nsRefPtr<nsStyleContext> areaStyle = 
  238:         PresContext()->PresShell()->StyleSet()->
41641:           ResolveStyleFor(area->AsElement(), GetStyleContext());
    1:       if (areaStyle) {
    1:         FillCursorInformationFromStyle(areaStyle->GetStyleUserInterface(),
    1:                                        aCursor);
    1:         if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
    1:           aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
    1:         }
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1:   return nsFrame::GetCursor(aPoint, aCursor);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::AttributeChanged(PRInt32 aNameSpaceID,
    1:                                nsIAtom* aAttribute,
    1:                                PRInt32 aModType)
    1: {
    1:   nsresult rv = nsSplittableFrame::AttributeChanged(aNameSpaceID,
    1:                                                     aAttribute, aModType);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1:   if (nsGkAtoms::alt == aAttribute)
    1:   {
 1158:     PresContext()->PresShell()->FrameNeedsReflow(this,
 1158:                                                  nsIPresShell::eStyleChange,
 1158:                                                  NS_FRAME_IS_DIRTY);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIAtom*
    1: nsImageFrame::GetType() const
    1: {
    1:   return nsGkAtoms::imageFrame;
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsImageFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("ImageFrame"), aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   IndentBy(out, aIndent);
    1:   ListTag(out);
    1: #ifdef DEBUG_waterson
    1:   fprintf(out, " [parent=%p]", mParent);
    1: #endif
    1:   if (HasView()) {
    1:     fprintf(out, " [view=%p]", (void*)GetView());
    1:   }
46249:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
    1:   if (0 != mState) {
43479:     fprintf(out, " [state=%016llx]", mState);
    1:   }
    1:   fprintf(out, " [content=%p]", (void*)mContent);
46249:   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
    1: 
    1:   // output the img src url
    1:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(mContent);
    1:   if (imageLoader) {
    1:     nsCOMPtr<imgIRequest> currentRequest;
    1:     imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
    1:                             getter_AddRefs(currentRequest));
    1:     if (currentRequest) {
    1:       nsCOMPtr<nsIURI> uri;
    1:       currentRequest->GetURI(getter_AddRefs(uri));
    1:       nsCAutoString uristr;
    1:       uri->GetAsciiSpec(uristr);
    1:       fprintf(out, " [src=%s]", uristr.get());
    1:     }
    1:   }
    1:   fputs("\n", out);
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: PRIntn
    1: nsImageFrame::GetSkipSides() const
    1: {
    1:   PRIntn skip = 0;
    1:   if (nsnull != GetPrevInFlow()) {
    1:     skip |= 1 << NS_SIDE_TOP;
    1:   }
    1:   if (nsnull != GetNextInFlow()) {
    1:     skip |= 1 << NS_SIDE_BOTTOM;
    1:   }
    1:   return skip;
    1: }
    1: 
69187: nsresult
    1: nsImageFrame::GetIntrinsicImageSize(nsSize& aSize)
    1: {
52205:   if (mIntrinsicSize.width.GetUnit() == eStyleUnit_Coord &&
52205:       mIntrinsicSize.height.GetUnit() == eStyleUnit_Coord) {
52205:     aSize.SizeTo(mIntrinsicSize.width.GetCoordValue(),
52205:                  mIntrinsicSize.height.GetCoordValue());
    1:     return NS_OK;
    1:   }
    1: 
52205:   return NS_ERROR_FAILURE;
52205: }
52205: 
    1: nsresult
    1: nsImageFrame::LoadIcon(const nsAString& aSpec,
    1:                        nsPresContext *aPresContext,
    1:                        imgIRequest** aRequest)
    1: {
    1:   nsresult rv = NS_OK;
    1:   NS_PRECONDITION(!aSpec.IsEmpty(), "What happened??");
    1: 
    1:   if (!sIOService) {
    1:     rv = CallGetService(NS_IOSERVICE_CONTRACTID, &sIOService);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> realURI;
    1:   SpecToURI(aSpec, sIOService, getter_AddRefs(realURI));
    1:  
    1:   nsCOMPtr<imgILoader> il(do_GetService("@mozilla.org/image/loader;1", &rv));
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   nsCOMPtr<nsILoadGroup> loadGroup;
    1:   GetLoadGroup(aPresContext, getter_AddRefs(loadGroup));
    1: 
    1:   // For icon loads, we don't need to merge with the loadgroup flags
    1:   nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
    1: 
    1:   return il->LoadImage(realURI,     /* icon URI */
    1:                        nsnull,      /* initial document URI; this is only
    1:                                        relevant for cookies, so does not
    1:                                        apply to icons. */
    1:                        nsnull,      /* referrer (not relevant for icons) */
73878:                        nsnull,      /* principal (not relevant for icons) */
    1:                        loadGroup,
31389:                        gIconLoad,
    1:                        nsnull,      /* Not associated with any particular document */
    1:                        loadFlags,
    1:                        nsnull,
    1:                        nsnull,
42509:                        nsnull,      /* channel policy not needed */
    1:                        aRequest);
    1: }
    1: 
    1: void
    1: nsImageFrame::GetDocumentCharacterSet(nsACString& aCharset) const
    1: {
    1:   if (mContent) {
    1:     NS_ASSERTION(mContent->GetDocument(),
    1:                  "Frame still alive after content removed from document!");
    1:     aCharset = mContent->GetDocument()->GetDocumentCharacterSet();
    1:   }
    1: }
    1: 
    1: void
    1: nsImageFrame::SpecToURI(const nsAString& aSpec, nsIIOService *aIOService,
    1:                          nsIURI **aURI)
    1: {
    1:   nsCOMPtr<nsIURI> baseURI;
    1:   if (mContent) {
    1:     baseURI = mContent->GetBaseURI();
    1:   }
    1:   nsCAutoString charset;
    1:   GetDocumentCharacterSet(charset);
    1:   NS_NewURI(aURI, aSpec, 
    1:             charset.IsEmpty() ? nsnull : charset.get(), 
    1:             baseURI, aIOService);
    1: }
    1: 
    1: void
    1: nsImageFrame::GetLoadGroup(nsPresContext *aPresContext, nsILoadGroup **aLoadGroup)
    1: {
    1:   if (!aPresContext)
    1:     return;
    1: 
    1:   NS_PRECONDITION(nsnull != aLoadGroup, "null OUT parameter pointer");
    1: 
    1:   nsIPresShell *shell = aPresContext->GetPresShell();
    1: 
    1:   if (!shell)
    1:     return;
    1: 
    1:   nsIDocument *doc = shell->GetDocument();
    1:   if (!doc)
    1:     return;
    1: 
    1:   *aLoadGroup = doc->GetDocumentLoadGroup().get();  // already_AddRefed
    1: }
    1: 
    1: nsresult nsImageFrame::LoadIcons(nsPresContext *aPresContext)
    1: {
    1:   NS_ASSERTION(!gIconLoad, "called LoadIcons twice");
    1: 
33777:   NS_NAMED_LITERAL_STRING(loadingSrc,"resource://gre-resources/loading-image.png");
33777:   NS_NAMED_LITERAL_STRING(brokenSrc,"resource://gre-resources/broken-image.png");
    1: 
31389:   gIconLoad = new IconLoad();
    1:   NS_ADDREF(gIconLoad);
    1: 
    1:   nsresult rv;
    1:   // create a loader and load the images
    1:   rv = LoadIcon(loadingSrc,
    1:                 aPresContext,
    1:                 getter_AddRefs(gIconLoad->mLoadingImage));
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   rv = LoadIcon(brokenSrc,
    1:                 aPresContext,
    1:                 getter_AddRefs(gIconLoad->mBrokenImage));
    1:   return rv;
    1: }
    1: 
31389: NS_IMPL_ISUPPORTS2(nsImageFrame::IconLoad, nsIObserver,
31389:                    imgIDecoderObserver)
    1: 
71000: static const char* kIconLoadPrefs[] = {
    1:   "browser.display.force_inline_alttext",
71000:   "browser.display.show_image_placeholders",
71000:   nsnull
    1: };
    1: 
31389: nsImageFrame::IconLoad::IconLoad()
    1: {
    1:   // register observers
71000:   Preferences::AddStrongObservers(this, kIconLoadPrefs);
    1:   GetPrefs();
    1: }
    1: 
71202: void
71202: nsImageFrame::IconLoad::Shutdown()
71202: {
71202:   Preferences::RemoveObservers(this, kIconLoadPrefs);
71202:   // in case the pref service releases us later
71202:   if (mLoadingImage) {
71202:     mLoadingImage->CancelAndForgetObserver(NS_ERROR_FAILURE);
71202:     mLoadingImage = nsnull;
71202:   }
71202:   if (mBrokenImage) {
71202:     mBrokenImage->CancelAndForgetObserver(NS_ERROR_FAILURE);
71202:     mBrokenImage = nsnull;
71202:   }
71202: }
    1: 
    1: NS_IMETHODIMP
    1: nsImageFrame::IconLoad::Observe(nsISupports *aSubject, const char* aTopic,
    1:                                 const PRUnichar* aData)
    1: {
    1:   NS_ASSERTION(!nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID),
    1:                "wrong topic");
    1: #ifdef DEBUG
    1:   // assert |aData| is one of our prefs.
80467:   for (PRUint32 i = 0; i < ArrayLength(kIconLoadPrefs) ||
80486:                        (NS_NOTREACHED("wrong pref"), false); ++i)
    1:     if (NS_ConvertASCIItoUTF16(kIconLoadPrefs[i]) == nsDependentString(aData))
    1:       break;
    1: #endif
    1: 
    1:   GetPrefs();
    1:   return NS_OK;
    1: }
    1: 
    1: void nsImageFrame::IconLoad::GetPrefs()
    1: {
    1:   mPrefForceInlineAltText =
70840:     Preferences::GetBool("browser.display.force_inline_alttext");
    1: 
    1:   mPrefShowPlaceholders =
79445:     Preferences::GetBool("browser.display.show_image_placeholders", true);
    1: }
    1: 
31389: 
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStartRequest(imgIRequest *aRequest)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStartDecode(imgIRequest *aRequest)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStartContainer(imgIRequest *aRequest,
31389:                                          imgIContainer *aContainer)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStartFrame(imgIRequest *aRequest,
31389:                                      PRUint32 aFrame)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnDataAvailable(imgIRequest *aRequest,
79445:                                         bool aCurrentFrame,
31389:                                         const nsIntRect * aRect)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStopFrame(imgIRequest *aRequest,
31389:                                     PRUint32 aFrame)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStopContainer(imgIRequest *aRequest,
31389:                                         imgIContainer *aContainer)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStopDecode(imgIRequest *aRequest,
31389:                                      nsresult status,
31389:                                      const PRUnichar *statusArg)
31389: {
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::OnStopRequest(imgIRequest *aRequest,
79445:                                       bool aIsLastPart)
31389: {
31389:   nsTObserverArray<nsImageFrame*>::ForwardIterator iter(mIconObservers);
31389:   nsImageFrame *frame;
31389:   while (iter.HasMore()) {
31389:     frame = iter.GetNext();
31389:     frame->Invalidate(frame->GetRect());
31389:   }
31389: 
31389:   return NS_OK;
31389: }
31389: 
31389: NS_IMETHODIMP
32424: nsImageFrame::IconLoad::OnDiscard(imgIRequest *aRequest)
32424: {
32424:   return NS_OK;
32424: }
32424: 
32424: NS_IMETHODIMP
31389: nsImageFrame::IconLoad::FrameChanged(imgIContainer *aContainer,
50544:                                      const nsIntRect *aDirtyRect)
31389: {
31389:   nsTObserverArray<nsImageFrame*>::ForwardIterator iter(mIconObservers);
31389:   nsImageFrame *frame;
31389:   while (iter.HasMore()) {
31389:     frame = iter.GetNext();
31389:     frame->Invalidate(frame->GetRect());
31389:   }
31389: 
31389:   return NS_OK;
31389: }
31389: 
31389: 
31389: 
    1: NS_IMPL_ISUPPORTS2(nsImageListener, imgIDecoderObserver, imgIContainerObserver)
    1: 
    1: nsImageListener::nsImageListener(nsImageFrame *aFrame) :
    1:   mFrame(aFrame)
    1: {
    1: }
    1: 
    1: nsImageListener::~nsImageListener()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP nsImageListener::OnStartContainer(imgIRequest *aRequest,
    1:                                                 imgIContainer *aImage)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrame->OnStartContainer(aRequest, aImage);
    1: }
    1: 
    1: NS_IMETHODIMP nsImageListener::OnDataAvailable(imgIRequest *aRequest,
79445:                                                bool aCurrentFrame,
23738:                                                const nsIntRect *aRect)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
30479:   return mFrame->OnDataAvailable(aRequest, aCurrentFrame, aRect);
    1: }
    1: 
    1: NS_IMETHODIMP nsImageListener::OnStopDecode(imgIRequest *aRequest,
    1:                                             nsresult status,
    1:                                             const PRUnichar *statusArg)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrame->OnStopDecode(aRequest, status, statusArg);
    1: }
    1: 
    1: NS_IMETHODIMP nsImageListener::FrameChanged(imgIContainer *aContainer,
50544:                                             const nsIntRect *aDirtyRect)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
50544:   return mFrame->FrameChanged(aContainer, aDirtyRect);
    1: }
    1: 
79445: static bool
 8578: IsInAutoWidthTableCellForQuirk(nsIFrame *aFrame)
 8578: {
 8578:   if (eCompatibility_NavQuirks != aFrame->PresContext()->CompatibilityMode())
80486:     return false;
 8578:   // Check if the parent of the closest nsBlockFrame has auto width.
 8578:   nsBlockFrame *ancestor = nsLayoutUtils::FindNearestBlockAncestor(aFrame);
34387:   if (ancestor->GetStyleContext()->GetPseudo() == nsCSSAnonBoxes::cellContent) {
 8578:     // Assume direct parent is a table cell frame.
 8578:     nsFrame *grandAncestor = static_cast<nsFrame*>(ancestor->GetParent());
 8578:     return grandAncestor &&
 8578:       grandAncestor->GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto;
 8578:   }
80486:   return false;
 8578: }
 8578: 
 8578: /* virtual */ void
68481: nsImageFrame::AddInlineMinWidth(nsRenderingContext *aRenderingContext,
 8578:                                 nsIFrame::InlineMinWidthData *aData)
 8578: {
 8578: 
 8578:   NS_ASSERTION(GetParent(), "Must have a parent if we get here!");
 8578:   
79445:   bool canBreak =
 8578:     !CanContinueTextRun() &&
 8578:     GetParent()->GetStyleText()->WhiteSpaceCanWrap() &&
 8578:     !IsInAutoWidthTableCellForQuirk(this);
 8578: 
 8578:   if (canBreak)
 8578:     aData->OptionallyBreak(aRenderingContext);
 8578:  
 8578:   aData->trailingWhitespace = 0;
80486:   aData->skipWhitespace = false;
 8578:   aData->trailingTextFrame = nsnull;
 8578:   aData->currentLine += nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
 8578:                             this, nsLayoutUtils::MIN_WIDTH);
80486:   aData->atStartOfLine = false;
 8578: 
 8578:   if (canBreak)
 8578:     aData->OptionallyBreak(aRenderingContext);
 8578: 
 8578: }
