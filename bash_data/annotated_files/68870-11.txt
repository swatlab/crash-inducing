    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark (buster@netscape.com)
    1:  *   Ilya Konstantinov (mozilla-code@future.shiny.co.il)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsDOMKeyboardEvent.h"
    1: #include "nsContentUtils.h"
    1: 
    1: nsDOMKeyboardEvent::nsDOMKeyboardEvent(nsPresContext* aPresContext,
    1:                                        nsKeyEvent* aEvent)
    1:   : nsDOMUIEvent(aPresContext, aEvent ? aEvent :
    1:                  new nsKeyEvent(PR_FALSE, 0, nsnull))
    1: {
    1:   NS_ASSERTION(mEvent->eventStructType == NS_KEY_EVENT, "event type mismatch");
    1: 
    1:   if (aEvent) {
    1:     mEventIsInternal = PR_FALSE;
    1:   }
    1:   else {
    1:     mEventIsInternal = PR_TRUE;
    1:     mEvent->time = PR_Now();
    1:   }
    1: }
    1: 
14438: nsDOMKeyboardEvent::~nsDOMKeyboardEvent()
14438: {
14438:   if (mEventIsInternal) {
14438:     delete static_cast<nsKeyEvent*>(mEvent);
14438:     mEvent = nsnull;
14438:   }
14438: }
14438: 
    1: NS_IMPL_ADDREF_INHERITED(nsDOMKeyboardEvent, nsDOMUIEvent)
    1: NS_IMPL_RELEASE_INHERITED(nsDOMKeyboardEvent, nsDOMUIEvent)
    1: 
40490: DOMCI_DATA(KeyboardEvent, nsDOMKeyboardEvent)
40490: 
    1: NS_INTERFACE_MAP_BEGIN(nsDOMKeyboardEvent)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyEvent)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(KeyboardEvent)
    1: NS_INTERFACE_MAP_END_INHERITING(nsDOMUIEvent)
    1: 
    1: NS_IMETHODIMP
    1: nsDOMKeyboardEvent::GetAltKey(PRBool* aIsDown)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDown);
    1:   *aIsDown = ((nsInputEvent*)mEvent)->isAlt;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMKeyboardEvent::GetCtrlKey(PRBool* aIsDown)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDown);
    1:   *aIsDown = ((nsInputEvent*)mEvent)->isControl;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMKeyboardEvent::GetShiftKey(PRBool* aIsDown)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDown);
    1:   *aIsDown = ((nsInputEvent*)mEvent)->isShift;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMKeyboardEvent::GetMetaKey(PRBool* aIsDown)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDown);
    1:   *aIsDown = ((nsInputEvent*)mEvent)->isMeta;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMKeyboardEvent::GetCharCode(PRUint32* aCharCode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aCharCode);
    1: 
    1:   switch (mEvent->message) {
    1:   case NS_KEY_UP:
    1:   case NS_KEY_DOWN:
    1:     *aCharCode = 0;
    1:     break;
    1:   case NS_KEY_PRESS:
    1:     *aCharCode = ((nsKeyEvent*)mEvent)->charCode;
    1:     break;
    1:   default:
    1:     break;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMKeyboardEvent::GetKeyCode(PRUint32* aKeyCode)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aKeyCode);
    1: 
    1:   switch (mEvent->message) {
    1:   case NS_KEY_UP:
    1:   case NS_KEY_PRESS:
    1:   case NS_KEY_DOWN:
    1:     *aKeyCode = ((nsKeyEvent*)mEvent)->keyCode;
    1:     break;
    1:   default:
    1:     *aKeyCode = 0;
    1:     break;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMKeyboardEvent::GetWhich(PRUint32* aWhich)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aWhich);
    1: 
    1:   switch (mEvent->message) {
    1:     case NS_KEY_UP:
    1:     case NS_KEY_DOWN:
    1:       return GetKeyCode(aWhich);
    1:     case NS_KEY_PRESS:
    1:       //Special case for 4xp bug 62878.  Try to make value of which
    1:       //more closely mirror the values that 4.x gave for RETURN and BACKSPACE
    1:       {
    1:         PRUint32 keyCode = ((nsKeyEvent*)mEvent)->keyCode;
    1:         if (keyCode == NS_VK_RETURN || keyCode == NS_VK_BACK) {
    1:           *aWhich = keyCode;
    1:           return NS_OK;
    1:         }
    1:         return GetCharCode(aWhich);
    1:       }
    1:       break;
    1:     default:
    1:       *aWhich = 0;
    1:       break;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMKeyboardEvent::InitKeyEvent(const nsAString& aType, PRBool aCanBubble, PRBool aCancelable,
68870:                                  nsIDOMAbstractView* aView, PRBool aCtrlKey, PRBool aAltKey,
    1:                                  PRBool aShiftKey, PRBool aMetaKey,
    1:                                  PRUint32 aKeyCode, PRUint32 aCharCode)
    1: {
    1:   nsresult rv = nsDOMUIEvent::InitUIEvent(aType, aCanBubble, aCancelable, aView, 0);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3233:   nsKeyEvent* keyEvent = static_cast<nsKeyEvent*>(mEvent);
    1:   keyEvent->isControl = aCtrlKey;
    1:   keyEvent->isAlt = aAltKey;
    1:   keyEvent->isShift = aShiftKey;
    1:   keyEvent->isMeta = aMetaKey;
    1:   keyEvent->keyCode = aKeyCode;
    1:   keyEvent->charCode = aCharCode;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult NS_NewDOMKeyboardEvent(nsIDOMEvent** aInstancePtrResult,
    1:                                 nsPresContext* aPresContext,
    1:                                 nsKeyEvent *aEvent)
    1: {
    1:   nsDOMKeyboardEvent* it = new nsDOMKeyboardEvent(aPresContext, aEvent);
68870:   if (nsnull == it) {
68870:     return NS_ERROR_OUT_OF_MEMORY;
68870:   }
68870: 
    1:   return CallQueryInterface(it, aInstancePtrResult);
    1: }
