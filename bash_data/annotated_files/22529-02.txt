16300: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
16300: /* vim:set ts=2 sw=2 sts=2 et cindent: */
16300: /* ***** BEGIN LICENSE BLOCK *****
16300:  * Version: ML 1.1/GPL 2.0/LGPL 2.1
16300:  *
16300:  * The contents of this file are subject to the Mozilla Public License Version
16300:  * 1.1 (the "License"); you may not use this file except in compliance with
16300:  * the License. You may obtain a copy of the License at
16300:  * http://www.mozilla.org/MPL/
16300:  *
16300:  * Software distributed under the License is distributed on an "AS IS" basis,
16300:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
16300:  * for the specific language governing rights and limitations under the
16300:  * License.
16300:  *
16300:  * The Original Code is Mozilla code.
16300:  *
16300:  * The Initial Developer of the Original Code is the Mozilla Corporation.
16300:  * Portions created by the Initial Developer are Copyright (C) 2007
16300:  * the Initial Developer. All Rights Reserved.
16300:  *
16300:  * Contributor(s):
16300:  *  Chris Double <chris.double@double.co.nz>
16300:  *
16300:  * Alternatively, the contents of this file may be used under the terms of
16300:  * either the GNU General Public License Version 2 or later (the "GPL"), or
16300:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
16300:  * in which case the provisions of the GPL or the LGPL are applicable instead
16300:  * of those above. If you wish to allow use of your version of this file only
16300:  * under the terms of either the GPL or the LGPL, and not to allow others to
16300:  * use your version of this file under the terms of the MPL, indicate your
16300:  * decision by deleting the provisions above and replace them with the notice
16300:  * and other provisions required by the GPL or the LGPL. If you do not delete
16300:  * the provisions above, a recipient may use your version of this file under
16300:  * the terms of any one of the MPL, the GPL or the LGPL.
16300:  *
16300:  * ***** END LICENSE BLOCK ***** */
16300: /*
20627: Each video element has one thread. This thread, called the Decode thread,
20627: owns the resources for downloading and reading the video file. It goes through the
20627: file, decoding the theora and vorbis data. It uses Oggplay to do the decoding.
20627: It indirectly uses an nsMediaStream to do the file reading and seeking via Oggplay.
20627: All file reads and seeks must occur on this thread only. It handles the sending
20627: of the audio data to the sound device and the presentation of the video data
20627: at the correct frame rate.
16300:     
20627: When the decode thread is created an event is dispatched to it. The event
20627: runs for the lifetime of the playback of the resource. The decode thread
20627: synchronises with the main thread via a single monitor held by the 
20627: nsOggDecoder object.
16300: 
20627: The event contains a Run method which consists of an infinite loop
20627: that checks the state that the state machine is in and processes
20627: operations on that state.
16300: 
20627: The nsOggDecodeStateMachine class is the event that gets dispatched to
20627: the decode thread. It has the following states:
16300: 
20627: DECODING_METADATA
20627:   The Ogg headers are being loaded, and things like framerate, etc are
20627:   being decoded.  
20627: DECODING_FIRSTFRAME
20627:   The first frame of audio/video data is being decoded.
20627: DECODING
20627:   Video/Audio frames are being decoded.
20627: SEEKING
20627:   A seek operation is in progress.
20627: BUFFERING
20627:   Decoding is paused while data is buffered for smooth playback.
20627: COMPLETED
20627:   The resource has completed decoding. 
20627: SHUTDOWN
20627:   The decoder object is about to be destroyed.
20627: 
20627: The following result in state transitions.
20627: 
20627: Shutdown()
20627:   Clean up any resources the nsOggDecodeStateMachine owns.
20627: Decode()
20627:   Start decoding video frames.
20627: Buffer
20627:   This is not user initiated. It occurs when the
20627:   available data in the stream drops below a certain point.
20627: Complete
20627:   This is not user initiated. It occurs when the
20627:   stream is completely decoded.
20627: Seek(float)
20627:   Seek to the time position given in the resource.
20627: 
20627: A state transition diagram:
20627: 
20627: DECODING_METADATA
20627: |        | Shutdown()
20627:   v      -->-------------------->--------------------------|
20627:   |                                                        |
20627: DECODING_FIRSTFRAME                                        v
20627:   |        | Shutdown()                                    |
20627:   v        >-------------------->--------------------------|
20627:   |  |------------->----->------------------------|        v
20627: DECODING             |          |  |              |        |
20627:   ^                  v Seek(t)  |  |              |        |
20627:   |         Decode() |          v  |              |        |
20627:   ^-----------<----SEEKING      |  v Complete     v        v
20627:   |                  |          |  |              |        |
20627:   |                  |          |  COMPLETED    SHUTDOWN-<-|
20627:   ^                  ^          |  |Shutdown()    |
20627:   |                  |          |  >-------->-----^
20627:   |         Decode() |Seek(t)   |Buffer()         |
20627:   -----------<--------<-------BUFFERING           |
20627:                                 |                 ^
20627:                                 v Shutdown()      |
20627:                                 |                 |
20627:                                 ------------>-----|
20627: 
20627: The Main thread controls the decode state machine by setting the value
20627: of a mPlayState variable and notifying on the monitor
20627: based on the high level player actions required (Seek, Pause, Play, etc).
20627: 
20627: The player states are the states requested by the client through the
20627: DOM API.  They represent the desired state of the player, while the
20627: decoder's state represents the actual state of the decoder.
20627: 
20627: The high level state of the player is maintained via a PlayState value. 
20627: It can have the following states:
20627: 
20627: START
20627:   The decoder has been initialized but has no resource loaded.
20627: PAUSED
20627:   A request via the API has been received to pause playback.
20627: LOADING
20627:   A request via the API has been received to load a resource.
20627: PLAYING
20627:   A request via the API has been received to start playback.
20627: SEEKING
20627:   A request via the API has been received to start seeking.
20627: COMPLETED
20627:   Playback has completed.
20627: SHUTDOWN
20627:   The decoder is about to be destroyed.
20627: 
20627: State transition occurs when the Media Element calls the Play, Seek,
20627: etc methods on the nsOggDecoder object. When the transition occurs
20627: nsOggDecoder then calls the methods on the decoder state machine
20627: object to cause it to behave appropriate to the play state.
20627: 
20627: The following represents the states that the player can be in, and the
20627: valid states the decode thread can be in at that time:
20627: 
20627: player LOADING   decoder DECODING_METADATA, DECODING_FIRSTFRAME
20627: player PLAYING   decoder DECODING, BUFFERING, SEEKING, COMPLETED
20627: player PAUSED    decoder DECODING, BUFFERING, SEEKING, COMPLETED
20627: player SEEKING   decoder SEEKING
20627: player COMPLETED decoder SHUTDOWN
20627: player SHUTDOWN  decoder SHUTDOWN
20627: 
20627: The general sequence of events with these objects is:
20627: 
20627: 1) The video element calls Load on nsMediaDecoder. This creates the
20627:    decode thread and starts the channel for downloading the file. It
20627:    instantiates and starts the Decode state machine. The high level
20627:    LOADING state is entered, which results in the decode state machine
20627:    to start decoding metadata. These are the headers that give the
20627:    video size, framerate, etc.  It returns immediately to the calling
20627:    video element.
16300: 
16300: 2) When the Ogg metadata has been loaded by the decode thread it will
20627:    call a method on the video element object to inform it that this
20627:    step is done, so it can do the things required by the video
20627:    specification at this stage. The decoder then continues to decode
20627:    the first frame of data.
16300: 
16300: 3) When the first frame of Ogg data has been successfully decoded it
16300:    calls a method on the video element object to inform it that this
16300:    step has been done, once again so it can do the required things by
16300:    the video specification at this stage.
16300: 
20627:    This results in the high level state changing to PLAYING or PAUSED
20627:    depending on any user action that may have occurred.
16300: 
20627:    The decode thread, while in the DECODING state, plays audio and
20627:    video, if the correct frame time comes around and the decoder
20627:    play state is PLAYING.
16300:    
20627: a/v synchronisation is done by a combination of liboggplay and the
20627: Decoder state machine. liboggplay ensures that a decoded frame of data
20627: has both the audio samples and the YUV data for that period of time.
16300: 
20627: When a frame is decoded by the decode state machine it converts the
20627: YUV encoded video to RGB and copies the sound data to an internal
20627: FrameData object. This is stored in a queue of available decoded frames.
20627: Included in the FrameData object is the time that that frame should
20627: be displayed.
16300: 
20627: The display state machine keeps track of the time since the last frame it
20627: played. After decoding a frame it checks if it is time to display the next
20627: item in the decoded frame queue. If so, it pops the item off the queue
20627: and displays it.
20627: 
20627: Ideally a/v sync would take into account the actual audio clock of the
20627: audio hardware for the sync rather than using the system clock.
20627: Unfortunately getting valid time data out of the audio hardware has proven
20627: to be unreliable across platforms (and even distributions in Linux) depending
20627: on audio hardware, audio backend etc. The current approach works fine in practice
20627: and is a compromise until this issue can be sorted. The plan is to eventually
20627: move to synchronising using the audio hardware.
20627: 
20627: To prevent audio skipping and framerate dropping it is very important to
20627: make sure no blocking occurs during the decoding process and minimise
20627: expensive time operations at the time a frame is to be displayed. This is
20627: managed by immediately converting video data to RGB on decode (an expensive
20627: operation to do at frame display time) and checking if the sound device will
20627: not block before writing sound data to it.
20627: 
20627: Shutdown needs to ensure that the event posted to the decode
20627: thread is completed. The decode thread can potentially block internally
20627: inside liboggplay when reading, seeking, or its internal buffers containing
20627: decoded data are full. When blocked in this manner a call from the main thread
20627: to Shutdown() will hang.  
20627: 
20627: This is fixed with a protocol to ensure that the decode event cleanly
20627: completes. The nsMediaStream that the nsChannelReader uses has a
20627: Cancel() method. Calling this before Shutdown() will close any
20627: internal streams or listeners resulting in blocked i/o completing with
20627: an error, and all future i/o on the stream having an error.
20627: 
20627: This causes the decode thread to exit and Shutdown() can occur.
20627: 
20627: If the decode thread is seeking then the same Cancel() operation
20627: causes an error to be returned from the seek call to liboggplay which
20627: exits out of the seek operation, and stops the seek state running on the
20627: decode thread.
20627: 
20627: If the decode thread is blocked due to internal decode buffers being
20627: full, it is unblocked during the shutdown process by calling
20627: oggplay_prepare_for_close.
20627: 
20627: In practice the OggPlay internal buffer should never fill as we retrieve and
20627: process the frame immediately on decoding.
20627: 
20627: The Shutdown method on nsOggDecoder can spin the event loop as it waits
20627: for threads to complete. Spinning the event loop is a bad thing to happen
20627: during certain times like destruction of the media element. To work around
20627: this the Shutdown method does nothing by queue an event to the main thread
20627: to perform the actual Shutdown. This way the shutdown can occur at a safe
20627: time. 
20627: 
20627: This means the owning object of a nsOggDecoder object *MUST* call Shutdown
20627: when destroying the nsOggDecoder object.
16300: */
20627: #if !defined(nsOggDecoder_h_)
20627: #define nsOggDecoder_h_
16300: 
16300: #include "nsISupports.h"
16300: #include "nsCOMPtr.h"
16300: #include "nsIThread.h"
16300: #include "nsIChannel.h"
16300: #include "nsChannelReader.h"
16300: #include "nsIObserver.h"
16300: #include "nsIFrame.h"
16300: #include "nsAutoPtr.h"
16300: #include "nsSize.h"
16300: #include "prlog.h"
20627: #include "prmon.h"
16300: #include "gfxContext.h"
16300: #include "gfxRect.h"
16300: #include "oggplay/oggplay.h"
20627: #include "nsMediaDecoder.h"
16300: 
16300: class nsAudioStream;
20627: class nsOggDecodeStateMachine;
16300: 
20627: class nsOggDecoder : public nsMediaDecoder
16300: {
20627:   friend class nsOggDecodeStateMachine;
16300: 
16300:   // ISupports
16300:   NS_DECL_ISUPPORTS
16300: 
16300:   // nsIObserver
16300:   NS_DECL_NSIOBSERVER
16300: 
16300:  public:
20627:   // Enumeration for the valid play states (see mPlayState)
20627:   enum PlayState {
20627:     PLAY_STATE_START,
20627:     PLAY_STATE_LOADING,
20627:     PLAY_STATE_PAUSED,
20627:     PLAY_STATE_PLAYING,
20627:     PLAY_STATE_SEEKING,
20627:     PLAY_STATE_ENDED,
20627:     PLAY_STATE_SHUTDOWN
20627:   };
20627: 
16300:   nsOggDecoder();
20627:   ~nsOggDecoder();
16300:   PRBool Init();
20627: 
20627:   // This method must be called by the owning object before that
20627:   // object disposes of this decoder object.
21079:   virtual void Shutdown();
16300:   
21079:   virtual float GetCurrentTime();
16300: 
21079:   virtual nsresult Load(nsIURI* aURI,
21079:                         nsIChannel* aChannel,
21079:                         nsIStreamListener **aListener);
16300: 
16300:   // Start playback of a video. 'Load' must have previously been
16300:   // called.
21079:   virtual nsresult Play();
16300: 
16300:   // Stop playback of a video, and stop download of video stream.
16300:   virtual void Stop();
16300: 
16300:   // Seek to the time position in (seconds) from the start of the video.
21079:   virtual nsresult Seek(float time);
16300: 
21079:   virtual nsresult PlaybackRateChanged();
16300: 
21079:   virtual void Pause();
21079:   virtual float GetVolume();
21079:   virtual void SetVolume(float volume);
21079:   virtual float GetDuration();
16300: 
21079:   virtual void GetCurrentURI(nsIURI** aURI);
21079:   virtual nsIPrincipal* GetCurrentPrincipal();
16300: 
20714:   virtual void UpdateBytesDownloaded(PRUint64 aBytes);
16300: 
20627:   // Called when the video file has completed downloading.
20627:   // Call on the main thread only.
20627:   void ResourceLoaded();
20627: 
21394:   // Called if the media file encounters a network error.
21394:   // Call on the main thread only.
21756:   virtual void NetworkError();
21394: 
20627:   // Call from any thread safely. Return PR_TRUE if we are currently
20627:   // seeking in the media resource.
20627:   virtual PRBool IsSeeking() const;
20627: 
20627:   // Get the size of the media file in bytes. Called on the main thread only.
20627:   virtual void SetTotalBytes(PRInt64 aBytes);
20627: 
21542:   // Set a flag indicating whether seeking is supported
21542:   virtual void SetSeekable(PRBool aSeekable);
21542: 
21542:   // Return PR_TRUE if seeking is supported.
21542:   virtual PRBool GetSeekable();
21542: 
21756:   // Returns the channel reader.
21756:   nsChannelReader* GetReader() { return mReader; }
21756: 
19690: protected:
19675: 
20627:   // Returns the monitor for other threads to synchronise access to
21756:   // state.
20627:   PRMonitor* GetMonitor() 
20627:   { 
20627:     return mMonitor; 
20627:   }
19675: 
21756:   // Return the current state. Can be called on any thread. If called from
21756:   // a non-main thread, the decoder monitor must be held.
20627:   PlayState GetState()
20627:   {
20627:     return mPlayState;
20627:   }
16300: 
16300:   /****** 
16300:    * The following methods must only be called on the main
16300:    * thread.
16300:    ******/
16300: 
21756:   // Change to a new play state. This updates the mState variable and
21756:   // notifies any thread blocking on this object's monitor of the
21756:   // change. Call on the main thread only.
21756:   void ChangeState(PlayState aState);
21756: 
16300:   // Called when the metadata from the Ogg file has been read.
16300:   // Call on the main thread only.
16300:   void MetadataLoaded();
16300: 
16300:   // Called when the first frame has been loaded.
16300:   // Call on the main thread only.
16300:   void FirstFrameLoaded();
16300: 
16300:   // Called when the video has completed playing.
16300:   // Call on the main thread only.
20627:   void PlaybackEnded();
16300: 
16300:   // Return the current number of bytes loaded from the video file.
16300:   // This is used for progress events.
20714:   virtual PRUint64 GetBytesLoaded();
16300: 
16300:   // Return the size of the video file in bytes.
16300:   // This is used for progress events.
20627:   virtual PRInt64 GetTotalBytes();
16300: 
16300:   // Buffering of data has stopped. Inform the element on the main
16300:   // thread.
16300:   void BufferingStopped();
16300: 
16300:   // Buffering of data has started. Inform the element on the main
16300:   // thread.
16300:   void BufferingStarted();
16300: 
20627:   // Seeking has stopped. Inform the element on the main
20627:   // thread.
20627:   void SeekingStopped();
20627: 
20627:   // Seeking has started. Inform the element on the main
20627:   // thread.
20627:   void SeekingStarted();
20627: 
20776:   // Called when the backend has changed the current playback
20776:   // position. It dispatches a timeupdate event and invalidates the frame.
20776:   // This must be called on the main thread only.
20776:   void PlaybackPositionChanged();
20776: 
19690: private:
20627:   // Register/Unregister with Shutdown Observer. 
20627:   // Call on main thread only.
20627:   void RegisterShutdownObserver();
20627:   void UnregisterShutdownObserver();
19675: 
16300:   /******
16300:    * The following members should be accessed on the main thread only
16300:    ******/
20627:   // Total number of bytes downloaded so far. 
20714:   PRUint64 mBytesDownloaded;
16300: 
16300:   // The URI of the current resource
16300:   nsCOMPtr<nsIURI> mURI;
16300: 
20627:   // Thread to handle decoding of Ogg data.
20627:   nsCOMPtr<nsIThread> mDecodeThread;
16300: 
20776:   // The current playback position of the media resource in units of
20776:   // seconds. This is updated approximately at the framerate of the
20776:   // video (if it is a video) or the callback period of the audio.
20776:   // It is read and written from the main thread only.
20776:   float mCurrentTime;
20776: 
20627:   // Volume that playback should start at.  0.0 = muted. 1.0 = full
20627:   // volume.  Readable/Writeable from the main thread. Read from the
20627:   // audio thread when it is first started to get the initial volume
20627:   // level.
20627:   float mInitialVolume;
16300: 
20627:   // Position to seek to when the seek notification is received by the
20627:   // decoding thread. Written by the main thread and read via the
20627:   // decoding thread. Synchronised using mPlayStateMonitor. If the
20627:   // value is negative then no seek has been requested. When a seek is
20627:   // started this is reset to negative.
20627:   float mRequestedSeekTime;
19690: 
20627:   // Size of the media file in bytes. Set on the first non-byte range
20627:   // HTTP request from nsChannelToPipe Listener. Accessed on the
20627:   // main thread only.
20627:   PRInt64 mContentLength;
16300: 
21542:   // Duration of the media resource. Set to -1 if unknown.
21542:   // Set when the Ogg metadata is loaded. Accessed on the main thread
21542:   // only.
21542:   PRInt64 mDuration;
21542: 
16339:   // True if we are registered with the observer service for shutdown.
16339:   PRPackedBool mNotifyOnShutdown;
16339: 
21542:   // True if the media resource is seekable (server supports byte range
21542:   // requests).
21542:   PRPackedBool mSeekable;
21542: 
16300:   /******
16300:    * The following member variables can be accessed from any thread.
16300:    ******/
16300: 
20627:   // The state machine object for handling the decoding via
20627:   // oggplay. It is safe to call methods of this object from other
20627:   // threads. Its internal data is synchronised on a monitor. The
20627:   // lifetime of this object is after mPlayState is LOADING and before
20627:   // mPlayState is SHUTDOWN. It is safe to access it during this
20627:   // period.
20627:   nsCOMPtr<nsOggDecodeStateMachine> mDecodeStateMachine;
16300: 
16300:   // OggPlay object used to read data from a channel. Created on main
16300:   // thread. Passed to liboggplay and the locking for multithreaded
20627:   // access is handled by that library. Some methods are called from
20627:   // the decoder thread, and the state machine for that thread keeps
20627:   // a pointer to this reader. This is safe as the only methods called
20627:   // are threadsafe (via the threadsafe nsMediaStream).
21756:   nsAutoPtr<nsChannelReader> mReader;
16300: 
20627:   // Monitor for detecting when the video play state changes. A call
20627:   // to Wait on this monitor will block the thread until the next
20627:   // state change.
20627:   PRMonitor* mMonitor;
16300: 
20627:   // Set to one of the valid play states. It is protected by the
20627:   // monitor mMonitor. This monitor must be acquired when reading or
20627:   // writing the state. Any change to the state on the main thread
20627:   // must call NotifyAll on the monitor so the decode thread can wake up.
20627:   PlayState mPlayState;
16300: 
21756:   // The state to change to after a seek or load operation. It must only
21756:   // be changed from the main thread. The decoder monitor must be acquired
21756:   // when writing to the state, or when reading from a non-main thread.
21756:   // Any change to the state must call NotifyAll on the monitor.
20627:   PlayState mNextState;	
16300: };
16300: 
16300: #endif
