    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim: set ts=2 sw=2 et tw=78:
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Novell code.
    1:  *
    1:  * The Initial Developer of the Original Code is Novell Corporation.
 6697:  * Portions created by the Initial Developer are Copyright (C) 2006
 6697:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *     robert@ocallahan.org
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  */
    1: 
    1: /*
    1:  * structures that represent things to be painted (ordered in z-order),
    1:  * used during painting and hit testing
    1:  */
    1: 
    1: #ifndef NSDISPLAYLIST_H_
    1: #define NSDISPLAYLIST_H_
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIFrame.h"
    1: #include "nsPoint.h"
    1: #include "nsRect.h"
    1: #include "nsISelection.h"
15969: #include "nsCaret.h"
    1: #include "plarena.h"
38803: #include "Layers.h"
42593: #include "nsRegion.h"
42593: #include "FrameLayerBuilder.h"
56101: #include "nsThemeConstants.h"
    1: 
    1: #include <stdlib.h>
    1: 
    1: class nsIPresShell;
    1: class nsIContent;
68481: class nsRenderingContext;
68668: class nsDeviceContext;
13961: class nsDisplayTableItem;
31544: class nsDisplayItem;
    1: 
    1: /*
    1:  * An nsIFrame can have many different visual parts. For example an image frame
    1:  * can have a background, border, and outline, the image itself, and a
    1:  * translucent selection overlay. In general these parts can be drawn at
    1:  * discontiguous z-levels; see CSS2.1 appendix E:
    1:  * http://www.w3.org/TR/CSS21/zindex.html
    1:  * 
    1:  * We construct a display list for a frame tree that contains one item
    1:  * for each visual part. The display list is itself a tree since some items
    1:  * are containers for other items; however, its structure does not match
    1:  * the structure of its source frame tree. The display list items are sorted
    1:  * by z-order. A display list can be used to paint the frames, to determine
    1:  * which frame is the target of a mouse event, and to determine what areas
    1:  * need to be repainted when scrolling. The display lists built for each task
    1:  * may be different for efficiency; in particular some frames need special
    1:  * display list items only for event handling, and do not create these items
    1:  * when the display list will be used for painting (the common case). For
    1:  * example, when painting we avoid creating nsDisplayBackground items for
    1:  * frames that don't display a visible background, but for event handling
    1:  * we need those backgrounds because they are not transparent to events.
    1:  * 
    1:  * We could avoid constructing an explicit display list by traversing the
    1:  * frame tree multiple times in clever ways. However, reifying the display list
    1:  * reduces code complexity and reduces the number of times each frame must be
    1:  * traversed to one, which seems to be good for performance. It also means
    1:  * we can share code for painting, event handling and scroll analysis.
    1:  * 
    1:  * Display lists are short-lived; content and frame trees cannot change
    1:  * between a display list being created and destroyed. Display lists should
    1:  * not be created during reflow because the frame tree may be in an
    1:  * inconsistent state (e.g., a frame's stored overflow-area may not include
    1:  * the bounds of all its children). However, it should be fine to create
    1:  * a display list while a reflow is pending, before it starts.
    1:  * 
    1:  * A display list covers the "extended" frame tree; the display list for a frame
    1:  * tree containing FRAME/IFRAME elements can include frames from the subdocuments.
    1:  */
    1: 
47732: // All types are defined in nsDisplayItemTypes.h
    1: #ifdef NS_DEBUG
47732: #define NS_DISPLAY_DECL_NAME(n, e) \
47732:   virtual const char* Name() { return n; } \
47732:   virtual Type GetType() { return e; }
    1: #else
47732: #define NS_DISPLAY_DECL_NAME(n, e) \
47732:   virtual Type GetType() { return e; }
    1: #endif
    1: 
    1: /**
    1:  * This manages a display list and is passed as a parameter to
    1:  * nsIFrame::BuildDisplayList.
    1:  * It contains the parameters that don't change from frame to frame and manages
    1:  * the display list memory using a PLArena. It also establishes the reference
    1:  * coordinate system for all display list items. Some of the parameters are
    1:  * available from the prescontext/presshell, but we copy them into the builder
    1:  * for faster/more convenient access.
    1:  */
43900: class nsDisplayListBuilder {
    1: public:
39965:   typedef mozilla::FramePropertyDescriptor FramePropertyDescriptor;
42593:   typedef mozilla::FrameLayerBuilder FrameLayerBuilder;
60289:   typedef nsIWidget::ThemeGeometry ThemeGeometry;
39965: 
    1:   /**
    1:    * @param aReferenceFrame the frame at the root of the subtree; its origin
    1:    * is the origin of the reference coordinate system for this display list
    1:    * @param aIsForEvents PR_TRUE if we're creating this list in order to
    1:    * determine which frame is under the mouse position
    1:    * @param aBuildCaret whether or not we should include the caret in any
    1:    * display lists that we make.
    1:    */
57094:   enum Mode {
57094: 	PAINTING,
57094: 	EVENT_DELIVERY,
57094: 	PLUGIN_GEOMETRY,
57094: 	OTHER
57094:   };
57094:   nsDisplayListBuilder(nsIFrame* aReferenceFrame, Mode aMode, PRBool aBuildCaret);
    1:   ~nsDisplayListBuilder();
    1: 
    1:   /**
    1:    * @return PR_TRUE if the display is being built in order to determine which
    1:    * frame is under the mouse position.
    1:    */
57094:   PRBool IsForEventDelivery() { return mMode == EVENT_DELIVERY; }
57094:   /**
59757:    * @return PR_TRUE if the display list is being built to compute geometry
57094:    * for plugins.
57094:    */
57094:   PRBool IsForPluginGeometry() { return mMode == PLUGIN_GEOMETRY; }
    1:   /**
59757:    * @return PR_TRUE if the display list is being built for painting.
59757:    */
59757:   PRBool IsForPainting() { return mMode == PAINTING; }
59757:   /**
    1:    * @return PR_TRUE if "painting is suppressed" during page load and we
    1:    * should paint only the background of the document.
    1:    */
51851:   PRBool IsBackgroundOnly() {
51851:     NS_ASSERTION(mPresShellStates.Length() > 0,
51851:                  "don't call this if we're not in a presshell");
51851:     return CurrentPresShellState()->mIsBackgroundOnly;
51851:   }
17008:   /**
    1:    * @return PR_TRUE if the currently active BuildDisplayList call is being
 7046:    * applied to a frame at the root of a pseudo stacking context. A pseudo
    1:    * stacking context is either a real stacking context or basically what
    1:    * CSS2.1 appendix E refers to with "treat the element as if it created
    1:    * a new stacking context
    1:    */
    1:   PRBool IsAtRootOfPseudoStackingContext() { return mIsAtRootOfPseudoStackingContext; }
14202: 
14202:   /**
    1:    * @return the selection that painting should be restricted to (or nsnull
    1:    * in the normal unrestricted case)
    1:    */
    1:   nsISelection* GetBoundingSelection() { return mBoundingSelection; }
    1:   /**
    1:    * @return the root of the display list's frame (sub)tree, whose origin
    1:    * establishes the coordinate system for the display list
    1:    */
72260:   nsIFrame* ReferenceFrame() const { return mReferenceFrame; }
    1:   /**
    1:    * @return a point pt such that adding pt to a coordinate relative to aFrame
    1:    * makes it relative to ReferenceFrame(), i.e., returns 
47895:    * aFrame->GetOffsetToCrossDoc(ReferenceFrame()). The returned point is in
47895:    * the appunits of aFrame. It may be optimized to be faster than
47895:    * aFrame->GetOffsetToCrossDoc(ReferenceFrame()) (but currently isn't).
    1:    */
72260:   nsPoint ToReferenceFrame(const nsIFrame* aFrame) const {
47895:     return aFrame->GetOffsetToCrossDoc(ReferenceFrame());
    1:   }
    1:   /**
    1:    * When building the display list, the scrollframe aFrame will be "ignored"
    1:    * for the purposes of clipping, and its scrollbars will be hidden. We use
    1:    * this to allow RenderOffscreen to render a whole document without beign
    1:    * clipped by the viewport or drawing the viewport scrollbars.
    1:    */
    1:   void SetIgnoreScrollFrame(nsIFrame* aFrame) { mIgnoreScrollFrame = aFrame; }
    1:   /**
    1:    * Get the scrollframe to ignore, if any.
    1:    */
    1:   nsIFrame* GetIgnoreScrollFrame() { return mIgnoreScrollFrame; }
    1:   /**
58774:    * Calling this setter makes us include all out-of-flow descendant
58774:    * frames in the display list, wherever they may be positioned (even
58774:    * outside the dirty rects).
58774:    */
58774:   void SetIncludeAllOutOfFlows() { mIncludeAllOutOfFlows = PR_TRUE; }
58774:   PRBool GetIncludeAllOutOfFlows() const { return mIncludeAllOutOfFlows; }
58774:   /**
58774:    * Calling this setter makes us exclude all leaf frames that does
58774:    * not have the NS_FRAME_SELECTED_CONTENT bit.
    1:    */
47337:   void SetSelectedFramesOnly() { mSelectedFramesOnly = PR_TRUE; }
47337:   PRBool GetSelectedFramesOnly() { return mSelectedFramesOnly; }
    1:   /**
30517:    * Calling this setter makes us compute accurate visible regions at the cost
30517:    * of performance if regions get very complex.
30517:    */
30517:   void SetAccurateVisibleRegions() { mAccurateVisibleRegions = PR_TRUE; }
30517:   PRBool GetAccurateVisibleRegions() { return mAccurateVisibleRegions; }
30517:   /**
 5440:    * Allows callers to selectively override the regular paint suppression checks,
 5440:    * so that methods like GetFrameForPoint work when painting is suppressed.
 5440:    */
51851:   void IgnorePaintSuppression() { mIgnoreSuppression = PR_TRUE; }
51851:   /**
52485:    * @return Returns if this builder will ignore paint suppression.
52485:    */
52485:   PRBool IsIgnoringPaintSuppression() { return mIgnoreSuppression; }
52485:   /**
51851:    * @return Returns if this builder had to ignore painting suppression on some
51851:    * document when building the display list.
51851:    */
51851:   PRBool GetHadToIgnorePaintSuppression() { return mHadToIgnoreSuppression; }
 5440:   /**
42240:    * Call this if we're doing normal painting to the window.
42240:    */
42240:   void SetPaintingToWindow(PRBool aToWindow) { mIsPaintingToWindow = aToWindow; }
55826:   PRBool IsPaintingToWindow() const { return mIsPaintingToWindow; }
42240:   /**
    1:    * Display the caret if needed.
    1:    */
    1:   nsresult DisplayCaret(nsIFrame* aFrame, const nsRect& aDirtyRect,
39949:       nsDisplayList* aList) {
    1:     nsIFrame* frame = GetCaretFrame();
    1:     if (aFrame != frame) {
    1:       return NS_OK;
    1:     }
39949:     return frame->DisplayCaret(this, aDirtyRect, aList);
    1:   }
    1:   /**
    1:    * Get the frame that the caret is supposed to draw in.
    1:    * If the caret is currently invisible, this will be null.
    1:    */
    1:   nsIFrame* GetCaretFrame() {
 9798:     return CurrentPresShellState()->mCaretFrame;
    1:   }
    1:   /**
    1:    * Get the caret associated with the current presshell.
    1:    */
15969:   nsCaret* GetCaret();
    1:   /**
    1:    * Notify the display list builder that we're entering a presshell.
    1:    * aReferenceFrame should be a frame in the new presshell and aDirtyRect
    1:    * should be the current dirty rect in aReferenceFrame's coordinate space.
    1:    */
    1:   void EnterPresShell(nsIFrame* aReferenceFrame, const nsRect& aDirtyRect);
    1:   /**
    1:    * Notify the display list builder that we're leaving a presshell.
    1:    */
    1:   void LeavePresShell(nsIFrame* aReferenceFrame, const nsRect& aDirtyRect);
    1: 
    1:   /**
30541:    * Returns true if we're currently building a display list that's
30541:    * directly or indirectly under an nsDisplayTransform or SVG
30541:    * foreignObject.
30541:    */
30541:   PRBool IsInTransform() { return mInTransform; }
30541:   /**
30541:    * Indicate whether or not we're directly or indirectly under and
30541:    * nsDisplayTransform or SVG foreignObject.
30541:    */
30541:   void SetInTransform(PRBool aInTransform) { mInTransform = aInTransform; }
30541: 
30541:   /**
67670:    * Call this if using display port for scrolling.
67670:    */
69909:   void SetDisplayPort(const nsRect& aDisplayPort);
69752:   const nsRect* GetDisplayPort() { return mHasDisplayPort ? &mDisplayPort : nsnull; }
67670: 
67670:   /**
67670:    * Call this if ReferenceFrame() is a viewport frame with fixed-position
67670:    * children, or when we construct an item which will return true from
67670:    * ShouldFixToViewport()
67670:    */
67670:   void SetHasFixedItems() { mHasFixedItems = PR_TRUE; }
67670:   PRBool GetHasFixedItems() { return mHasFixedItems; }
67670: 
67670:   /**
60027:    * Returns true if snapping is enabled for the final drawing context.
60027:    * The default is true.
60027:    */
60027:   PRBool IsSnappingEnabled() { return mSnappingEnabled; }
60027:   /**
60027:    * Set if snapping is enabled for the final drawing context.
60027:    */
60027:   void SetSnappingEnabled(PRBool aSnappingEnabled) { mSnappingEnabled = aSnappingEnabled; }
60027: 
60027:   /**
32424:    * @return PR_TRUE if images have been set to decode synchronously.
32424:    */
32424:   PRBool ShouldSyncDecodeImages() { return mSyncDecodeImages; }
32424: 
32424:   /**
32424:    * Indicates whether we should synchronously decode images. If true, we decode
32424:    * and draw whatever image data has been loaded. If false, we just draw
32424:    * whatever has already been decoded.
32424:    */
32424:   void SetSyncDecodeImages(PRBool aSyncDecodeImages) {
32424:     mSyncDecodeImages = aSyncDecodeImages;
32424:   }
32424: 
32424:   /**
32425:    * Helper method to generate background painting flags based on the
32425:    * information available in the display list builder. Currently only
32425:    * accounts for mSyncDecodeImages.
32425:    */
32425:   PRUint32 GetBackgroundPaintFlags();
32425: 
32425:   /**
31544:    * Subtracts aRegion from *aVisibleRegion. We avoid letting
31544:    * aVisibleRegion become overcomplex by simplifying it if necessary ---
31544:    * unless mAccurateVisibleRegions is set, in which case we let it
69802:    * get arbitrarily complex.
31544:    */
31544:   void SubtractFromVisibleRegion(nsRegion* aVisibleRegion,
69802:                                  const nsRegion& aRegion);
31544: 
31544:   /**
30782:    * Mark the frames in aFrames to be displayed if they intersect aDirtyRect
30782:    * (which is relative to aDirtyFrame). If the frames have placeholders
30782:    * that might not be displayed, we mark the placeholders and their ancestors
30782:    * to ensure that display list construction descends into them
30782:    * anyway. nsDisplayListBuilder will take care of unmarking them when it is
30782:    * destroyed.
    1:    */
30782:   void MarkFramesForDisplayList(nsIFrame* aDirtyFrame,
30782:                                 const nsFrameList& aFrames,
    1:                                 const nsRect& aDirtyRect);
    1: 
    1:   /**
42593:    * Return the FrameLayerBuilder.
42593:    */
42593:   FrameLayerBuilder* LayerBuilder() { return &mLayerBuilder; }
42593: 
42593:   /**
59778:    * Get the area of the final transparent region.
59778:    */
59778:   const nsRegion* GetFinalTransparentRegion() { return mFinalTransparentRegion; }
59778:   /**
59778:    * Record the area of the final transparent region after all visibility
59778:    * calculations were performed.
59778:    */
59778:   void SetFinalTransparentRegion(const nsRegion& aFinalTransparentRegion)
59778:   {
59778:     mFinalTransparentRegion = &aFinalTransparentRegion;
59778:   }
59778: 
60643:   const nsTArray<ThemeGeometry>& GetThemeGeometries() { return mThemeGeometries; }
60643: 
59778:   /**
58774:    * Returns true if we need to descend into this frame when building
58774:    * the display list, even though it doesn't intersect the dirty
58774:    * rect, because it may have out-of-flows that do so.
58774:    */
58774:   bool ShouldDescendIntoFrame(nsIFrame* aFrame) const {
58774:     return
58774:       (aFrame->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO) ||
58774:       GetIncludeAllOutOfFlows();
58774:   }
58774: 
58774:   /**
60289:    * Notifies the builder that a particular themed widget exists
60289:    * at the given rectangle within the currently built display list.
60289:    * For certain appearance values (currently only
60289:    * NS_THEME_MOZ_MAC_UNIFIED_TOOLBAR and NS_THEME_TOOLBAR) this gets
60289:    * called during every display list construction, for every themed widget of
60289:    * the right type within the display list, except for themed widgets which
60289:    * are transformed or have effects applied to them (e.g. CSS opacity or
60289:    * filters).
60289:    *
60289:    * @param aWidgetType the -moz-appearance value for the themed widget
60289:    * @param aRect the device-pixel rect relative to the widget's displayRoot
60289:    * for the themed widget
60289:    */
60289:   void RegisterThemeGeometry(PRUint8 aWidgetType,
60289:                              const nsIntRect& aRect) {
60643:     if (mIsPaintingToWindow && mPresShellStates.Length() == 1) {
60289:       ThemeGeometry geometry(aWidgetType, aRect);
60643:       mThemeGeometries.AppendElement(geometry);
60289:     }
60289:   }
60289: 
60289:   /**
    1:    * Allocate memory in our arena. It will only be freed when this display list
    1:    * builder is destroyed. This memory holds nsDisplayItems. nsDisplayItem
    1:    * destructors are called as soon as the item is no longer used.
    1:    */
    1:   void* Allocate(size_t aSize);
    1:   
    1:   /**
    1:    * A helper class to temporarily set the value of
    1:    * mIsAtRootOfPseudoStackingContext.
    1:    */
    1:   class AutoIsRootSetter;
    1:   friend class AutoIsRootSetter;
    1:   class AutoIsRootSetter {
    1:   public:
    1:     AutoIsRootSetter(nsDisplayListBuilder* aBuilder, PRBool aIsRoot)
    1:       : mBuilder(aBuilder), mOldValue(aBuilder->mIsAtRootOfPseudoStackingContext) { 
    1:       aBuilder->mIsAtRootOfPseudoStackingContext = aIsRoot;
    1:     }
    1:     ~AutoIsRootSetter() {
    1:       mBuilder->mIsAtRootOfPseudoStackingContext = mOldValue;
    1:     }
    1:   private:
    1:     nsDisplayListBuilder* mBuilder;
    1:     PRPackedBool          mOldValue;
    1:   };
    1: 
30541:   /**
30541:    * A helper class to temporarily set the value of mInTransform.
30541:    */
30541:   class AutoInTransformSetter;
30541:   friend class AutoInTransformSetter;
30541:   class AutoInTransformSetter {
30541:   public:
30541:     AutoInTransformSetter(nsDisplayListBuilder* aBuilder, PRBool aInTransform)
30541:       : mBuilder(aBuilder), mOldValue(aBuilder->mInTransform) { 
30541:       aBuilder->mInTransform = aInTransform;
30541:     }
30541:     ~AutoInTransformSetter() {
30541:       mBuilder->mInTransform = mOldValue;
30541:     }
30541:   private:
30541:     nsDisplayListBuilder* mBuilder;
30541:     PRPackedBool          mOldValue;
30541:   };  
30541:   
13961:   // Helpers for tables
13961:   nsDisplayTableItem* GetCurrentTableItem() { return mCurrentTableItem; }
13961:   void SetCurrentTableItem(nsDisplayTableItem* aTableItem) { mCurrentTableItem = aTableItem; }
13961: 
39965:   NS_DECLARE_FRAME_PROPERTY(OutOfFlowDirtyRectProperty, nsIFrame::DestroyRect)
39965: 
60027:   nsPresContext* CurrentPresContext() {
60027:     return CurrentPresShellState()->mPresShell->GetPresContext();
60027:   }
60027: 
69805:   /**
69805:    * Accumulates the bounds of box frames that have moz-appearance
69805:    * -moz-win-exclude-glass style. Used in setting glass margins on
69805:    * Windows.
69805:    */  
69805:   void AddExcludedGlassRegion(nsRect &bounds) {
69805:     mExcludedGlassRegion.Or(mExcludedGlassRegion, bounds);
69805:   }
69805:   const nsRegion& GetExcludedGlassRegion() {
69805:     return mExcludedGlassRegion;
69805:   }
69805: 
    1: private:
67670:   void MarkOutOfFlowFrameForDisplay(nsIFrame* aDirtyFrame, nsIFrame* aFrame,
67670:                                     const nsRect& aDirtyRect);
67670: 
 9798:   struct PresShellState {
 9798:     nsIPresShell* mPresShell;
 9798:     nsIFrame*     mCaretFrame;
 9798:     PRUint32      mFirstFrameMarkedForDisplay;
51851:     PRPackedBool  mIsBackgroundOnly;
 9798:   };
 9798:   PresShellState* CurrentPresShellState() {
 9798:     NS_ASSERTION(mPresShellStates.Length() > 0,
 9798:                  "Someone forgot to enter a presshell");
 9798:     return &mPresShellStates[mPresShellStates.Length() - 1];
 9798:   }
 9798: 
42593:   FrameLayerBuilder              mLayerBuilder;
    1:   nsIFrame*                      mReferenceFrame;
    1:   nsIFrame*                      mIgnoreScrollFrame;
    1:   PLArenaPool                    mPool;
    1:   nsCOMPtr<nsISelection>         mBoundingSelection;
 9798:   nsAutoTArray<PresShellState,8> mPresShellStates;
 9798:   nsAutoTArray<nsIFrame*,100>    mFramesMarkedForDisplay;
60643:   nsAutoTArray<ThemeGeometry,2>  mThemeGeometries;
13961:   nsDisplayTableItem*            mCurrentTableItem;
59778:   const nsRegion*                mFinalTransparentRegion;
71398:   nsRect                         mDisplayPort;
69805:   nsRegion                       mExcludedGlassRegion;
57094:   Mode                           mMode;
    1:   PRPackedBool                   mBuildCaret;
51851:   PRPackedBool                   mIgnoreSuppression;
51851:   PRPackedBool                   mHadToIgnoreSuppression;
    1:   PRPackedBool                   mIsAtRootOfPseudoStackingContext;
58774:   PRPackedBool                   mIncludeAllOutOfFlows;
47337:   PRPackedBool                   mSelectedFramesOnly;
30517:   PRPackedBool                   mAccurateVisibleRegions;
30541:   // True when we're building a display list that's directly or indirectly
30541:   // under an nsDisplayTransform
30541:   PRPackedBool                   mInTransform;
32424:   PRPackedBool                   mSyncDecodeImages;
42240:   PRPackedBool                   mIsPaintingToWindow;
60027:   PRPackedBool                   mSnappingEnabled;
67670:   PRPackedBool                   mHasDisplayPort;
67670:   PRPackedBool                   mHasFixedItems;
    1: };
    1: 
    1: class nsDisplayItem;
    1: class nsDisplayList;
    1: /**
    1:  * nsDisplayItems are put in singly-linked lists rooted in an nsDisplayList.
    1:  * nsDisplayItemLink holds the link. The lists are linked from lowest to
    1:  * highest in z-order.
    1:  */
    1: class nsDisplayItemLink {
    1:   // This is never instantiated directly, so no need to count constructors and
    1:   // destructors.
    1: protected:
    1:   nsDisplayItemLink() : mAbove(nsnull) {}
    1:   nsDisplayItem* mAbove;  
    1:   
    1:   friend class nsDisplayList;
    1: };
    1: 
    1: /**
    1:  * This is the unit of rendering and event testing. Each instance of this
    1:  * class represents an entity that can be drawn on the screen, e.g., a
    1:  * frame's CSS background, or a frame's text string.
    1:  * 
    1:  * nsDisplayListItems can be containers --- i.e., they can perform hit testing
    1:  * and painting by recursively traversing a list of child items.
    1:  * 
    1:  * These are arena-allocated during display list construction. A typical
    1:  * subclass would just have a frame pointer, so its object would be just three
    1:  * pointers (vtable, next-item, frame).
    1:  * 
    1:  * Display items belong to a list at all times (except temporarily as they
    1:  * move from one list to another).
    1:  */
    1: class nsDisplayItem : public nsDisplayItemLink {
    1: public:
60444:   typedef mozilla::layers::FrameMetrics::ViewID ViewID;
38803:   typedef mozilla::layers::Layer Layer;
38803:   typedef mozilla::layers::LayerManager LayerManager;
47751:   typedef mozilla::LayerState LayerState;
38803: 
    1:   // This is never instantiated directly (it has pure virtual methods), so no
    1:   // need to count constructors and destructors.
51260:   nsDisplayItem(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame) :
51260:     mFrame(aFrame) {
51260:     if (aFrame) {
51260:       mToReferenceFrame = aBuilder->ToReferenceFrame(aFrame);
51260:     }
51260:   }
    1:   virtual ~nsDisplayItem() {}
    1:   
    1:   void* operator new(size_t aSize,
    1:                      nsDisplayListBuilder* aBuilder) CPP_THROW_NEW {
    1:     return aBuilder->Allocate(aSize);
    1:   }
    1: 
47732: // Contains all the type integers for each display list item type
47732: #include "nsDisplayItemTypes.h"
    1: 
 9799:   struct HitTestState {
60444:     typedef nsTArray<ViewID> ShadowArray;
60444: 
60444:     HitTestState(ShadowArray* aShadows = NULL)
60444:       : mShadows(aShadows) {
60444:     }
60444: 
 9799:     ~HitTestState() {
 9799:       NS_ASSERTION(mItemBuffer.Length() == 0,
 9799:                    "mItemBuffer should have been cleared");
 9799:     }
60444: 
 9799:     nsAutoTArray<nsDisplayItem*, 100> mItemBuffer;
60444: 
60444:     // It is sometimes useful to hit test for frames that are not in this
60444:     // process. Display items may append IDs into this array if it is
60444:     // non-null.
60444:     ShadowArray* mShadows;
 9799:   };
 9799: 
    1:   /**
    1:    * Some consecutive items should be rendered together as a unit, e.g.,
    1:    * outlines for the same element. For this, we need a way for items to
47733:    * identify their type. We use the type for other purposes too.
    1:    */
47732:   virtual Type GetType() = 0;
    1:   /**
47733:    * If this returns a non-zero value, then pairing this with the
47733:    * GetUnderlyingFrame() pointer gives a key that uniquely identifies
47733:    * this display item in the display item tree.
47733:    * This will only return a zero value for items which wrap display lists
47733:    * and do not create a CSS stacking context, therefore requiring
47733:    * display items to be individually wrapped --- currently nsDisplayClip
52292:    * and nsDisplayClipRoundedRect only.
47733:    */
47733:   virtual PRUint32 GetPerFrameKey() { return PRUint32(GetType()); }
47733:   /**
    1:    * This is called after we've constructed a display list for event handling.
43138:    * When this is called, we've already ensured that aRect intersects the
43138:    * item's bounds.
    1:    * 
 9799:    * @param aState must point to a HitTestState. If you don't have one,
 9799:    * just create one with the default constructor and pass it in.
43138:    * @param aOutFrames each item appends the frame(s) in this display item that
43138:    * the rect is considered over (if any) to aOutFrames.
    1:    */
40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames) {}
    1:   /**
    1:    * @return the frame that this display item is based on. This is used to sort
    1:    * items by z-index and content order and for some other uses. For some items
    1:    * that wrap item lists, this could return nsnull because there is no single
    1:    * underlying frame; for leaf items it will never return nsnull.
    1:    */
72260:   inline nsIFrame* GetUnderlyingFrame() const { return mFrame; }
    1:   /**
    1:    * The default bounds is the frame border rect.
    1:    * @return a rectangle relative to aBuilder->ReferenceFrame() that
    1:    * contains the area drawn by this display item
    1:    */
    1:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
51261:     return nsRect(ToReferenceFrame(), GetUnderlyingFrame()->GetSize());
    1:   }
    1:   /**
59779:    * @return a region of the item that is opaque --- every pixel painted
71888:    * with an opaque color. This is useful for determining when one piece
71888:    * of content completely obscures another so that we can do occlusion
71888:    * culling.
    1:    */
59779:   virtual nsRegion GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
56101:                                    PRBool* aForceTransparentSurface = nsnull)
56101:   {
56101:     if (aForceTransparentSurface) {
56101:       *aForceTransparentSurface = PR_FALSE;
56101:     }
59779:     return nsRegion();
56101:   }
    1:   /**
42436:    * If this returns true, then aColor is set to the uniform color
    1:    * @return PR_TRUE if the item is guaranteed to paint every pixel in its
    1:    * bounds with the same (possibly translucent) color
    1:    */
42436:   virtual PRBool IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor) { return PR_FALSE; }
    1:   /**
    1:    * @return PR_FALSE if the painting performed by the item is invariant
50392:    * when the item's underlying frame is moved relative to aFrame.
47777:    * In other words, if you render the item at locations P and P', the rendering
47777:    * only differs by the translation.
14202:    * It return PR_TRUE for all wrapped lists.
    1:    */
50392:   virtual PRBool IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
50392:                                                 nsIFrame* aFrame)
14202:   { return PR_FALSE; }
47754:   /**
47754:    * @return PR_TRUE if the contents of this item are rendered fixed relative
47777:    * to the nearest viewport *and* they cover the viewport's scrollport.
47777:    * Only return true if the contents actually vary when scrolling in the viewport.
47754:    */
67668:   virtual PRBool ShouldFixToViewport(nsDisplayListBuilder* aBuilder)
47754:   { return PR_FALSE; }
47751: 
47751:   /**
47751:    * @return LAYER_NONE if BuildLayer will return null. In this case
47751:    * there is no layer for the item, and Paint should be called instead
47751:    * to paint the content using Thebes.
47751:    * Return LAYER_INACTIVE if there is a layer --- BuildLayer will
47751:    * not return null (unless there's an error) --- but the layer contents
47751:    * are not changing frequently. In this case it makes sense to composite
47751:    * the layer into a ThebesLayer with other content, so we don't have to
47751:    * recomposite it every time we paint.
47751:    * Note: GetLayerState is only allowed to return LAYER_INACTIVE if all
47751:    * descendant display items returned LAYER_INACTIVE or LAYER_NONE. Also,
47751:    * all descendant display item frames must have an active scrolled root
47751:    * that's either the same as this item's frame's active scrolled root, or
47751:    * a descendant of this item's frame. This ensures that the entire
47751:    * set of display items can be collapsed onto a single ThebesLayer.
47751:    * Return LAYER_ACTIVE if the layer is active, that is, its contents are
47751:    * changing frequently. In this case it makes sense to keep the layer
47751:    * as a separate buffer in VRAM and composite it into the destination
47751:    * every time we paint.
47751:    */
47751:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
47751:                                    LayerManager* aManager)
47751:   { return mozilla::LAYER_NONE; }
    1:   /**
    1:    * Actually paint this item to some rendering context.
33368:    * Content outside mVisibleRect need not be painted.
38805:    * aCtx must be set up as for nsDisplayList::Paint.
    1:    */
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx) {}
38803:   /**
47751:    * Get the layer drawn by this display item. Call this only if
47751:    * GetLayerState() returns something other than LAYER_NONE.
47751:    * If GetLayerState returned LAYER_NONE then Paint will be called
47751:    * instead.
38803:    * This is called while aManager is in the construction phase.
38803:    * 
38803:    * The caller (nsDisplayList) is responsible for setting the visible
38803:    * region of the layer.
72230:    *
72230:    * @param aContainerParameters should be passed to
72230:    * FrameLayerBuilder::BuildContainerLayerFor if a ContainerLayer is
72230:    * constructed.
38803:    */
72230:   typedef mozilla::FrameLayerBuilder::ContainerParameters ContainerParameters;
38803:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                                              LayerManager* aManager,
72230:                                              const ContainerParameters& aContainerParameters)
38803:   { return nsnull; }
    1: 
    1:   /**
    1:    * On entry, aVisibleRegion contains the region (relative to ReferenceFrame())
    1:    * which may be visible. If the display item opaquely covers an area, it
    1:    * can remove that area from aVisibleRegion before returning.
59779:    * nsDisplayList::ComputeVisibility automatically subtracts the region
59779:    * returned by GetOpaqueRegion, and automatically removes items whose bounds
59779:    * do not intersect the visible area, so implementations of
59779:    * nsDisplayItem::ComputeVisibility do not need to do these things.
33368:    * nsDisplayList::ComputeVisibility will already have set mVisibleRect on
59751:    * this item to the intersection of *aVisibleRegion and this item's bounds.
51633:    * We rely on that, so this should only be called by
51633:    * nsDisplayList::ComputeVisibility or nsDisplayItem::RecomputeVisibility.
62700:    * aAllowVisibleRegionExpansion is a rect where we are allowed to
62700:    * expand the visible region and is only used for making sure the
62700:    * background behind a plugin is visible.
33368:    *
    1:    * @return PR_TRUE if the item is visible, PR_FALSE if no part of the item
69802:    * is visible.
    1:    */
33368:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion)
47763:   { return !mVisibleRect.IsEmpty(); }
34210: 
    1:   /**
    1:    * Try to merge with the other item (which is below us in the display
    1:    * list). This gets used by nsDisplayClip to coalesce clipping operations
    1:    * (optimization), by nsDisplayOpacity to merge rendering for the same
    1:    * content element into a single opacity group (correctness), and will be
    1:    * used by nsDisplayOutline to merge multiple outlines for the same element
    1:    * (also for correctness).
    1:    * @return PR_TRUE if the merge was successful and the other item should be deleted
    1:    */
    1:   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   /**
69189:    * During the visibility computation and after TryMerge, display lists may
69189:    * return PR_TRUE here to flatten themselves away, removing them. This
69189:    * flattening is distinctly different from FlattenTo, which occurs before
69189:    * items are merged together.
69189:    */
69189:   virtual PRBool ShouldFlattenAway(nsDisplayListBuilder* aBuilder) {
69189:     return PR_FALSE;
69189:   }
69189: 
69189:   /**
    1:    * If this is a leaf item we return null, otherwise we return the wrapped
    1:    * list.
    1:    */
    1:   virtual nsDisplayList* GetList() { return nsnull; }
    1: 
42593:   /**
42593:    * Returns the visible rect. Should only be called after ComputeVisibility
42593:    * has happened.
42593:    */
42436:   const nsRect& GetVisibleRect() { return mVisibleRect; }
42436:   
    1: #ifdef NS_DEBUG
    1:   /**
    1:    * For debugging and stuff
    1:    */
    1:   virtual const char* Name() = 0;
    1: #endif
    1: 
    1:   nsDisplayItem* GetAbove() { return mAbove; }
    1: 
47736:   /**
47736:    * Like ComputeVisibility, but does the work that nsDisplayList
47736:    * does per-item:
47736:    * -- Intersects GetBounds with aVisibleRegion and puts the result
47736:    * in mVisibleRect
47736:    * -- Subtracts bounds from aVisibleRegion if the item is opaque
47736:    */
47736:   PRBool RecomputeVisibility(nsDisplayListBuilder* aBuilder,
47736:                              nsRegion* aVisibleRegion);
47736: 
51261:   /**
51261:    * Returns the result of aBuilder->ToReferenceFrame(GetUnderlyingFrame())
51261:    */
72260:   const nsPoint& ToReferenceFrame() const {
51260:     NS_ASSERTION(mFrame, "No frame?");
51260:     return mToReferenceFrame;
51260:   }
51260: 
55291:   /**
59781:    * Checks if this display item (or any children) contains content that might
59781:    * be rendered with component alpha (e.g. subpixel antialiasing). Returns the
59781:    * bounds of the area that needs component alpha, or an empty rect if nothing
59781:    * in the item does.
55291:    */
59781:   virtual nsRect GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder) { return nsRect(); }
55291: 
59778:   /**
59778:    * Disable usage of component alpha. Currently only relevant for items that have text.
59778:    */
59778:   virtual void DisableComponentAlpha() {}
59778: 
    1: protected:
    1:   friend class nsDisplayList;
    1:   
    1:   nsDisplayItem() {
    1:     mAbove = nsnull;
    1:   }
    1:   
    1:   nsIFrame* mFrame;
51260:   // Result of ToReferenceFrame(mFrame), if mFrame is non-null
51260:   nsPoint   mToReferenceFrame;
33368:   // This is the rectangle that needs to be painted.
33368:   // nsDisplayList::ComputeVisibility sets this to the visible region
33368:   // of the item by intersecting the current visible region with the bounds
33368:   // of the item. Paint implementations can use this to limit their drawing.
33368:   // Guaranteed to be contained in GetBounds().
33368:   nsRect    mVisibleRect;
    1: };
    1: 
    1: /**
    1:  * Manages a singly-linked list of display list items.
    1:  * 
    1:  * mSentinel is the sentinel list value, the first value in the null-terminated
    1:  * linked list of items. mTop is the last item in the list (whose 'above'
    1:  * pointer is null). This class has no virtual methods. So list objects are just
    1:  * two pointers.
    1:  * 
    1:  * Stepping upward through this list is very fast. Stepping downward is very
    1:  * slow so we don't support it. The methods that need to step downward
33368:  * (HitTest(), ComputeVisibility()) internally build a temporary array of all
    1:  * the items while they do the downward traversal, so overall they're still
    1:  * linear time. We have optimized for efficient AppendToTop() of both
    1:  * items and lists, with minimal codesize. AppendToBottom() is efficient too.
    1:  */
    1: class nsDisplayList {
    1: public:
38803:   typedef mozilla::layers::Layer Layer;
38803:   typedef mozilla::layers::LayerManager LayerManager;
38803:   typedef mozilla::layers::ThebesLayer ThebesLayer;
38803: 
    1:   /**
    1:    * Create an empty list.
    1:    */
38803:   nsDisplayList() :
38803:     mIsOpaque(PR_FALSE)
38803:   {
33368:     mTop = &mSentinel;
33368:     mSentinel.mAbove = nsnull;
33368: #ifdef DEBUG
33368:     mDidComputeVisibility = PR_FALSE;
33368: #endif
33368:   }
    1:   ~nsDisplayList() {
    1:     if (mSentinel.mAbove) {
    1:       NS_WARNING("Nonempty list left over?");
    1:     }
    1:     DeleteAll();
    1:   }
    1: 
    1:   /**
    1:    * Append an item to the top of the list. The item must not currently
    1:    * be in a list and cannot be null.
    1:    */
    1:   void AppendToTop(nsDisplayItem* aItem) {
    1:     NS_ASSERTION(aItem, "No item to append!");
    1:     NS_ASSERTION(!aItem->mAbove, "Already in a list!");
    1:     mTop->mAbove = aItem;
    1:     mTop = aItem;
    1:   }
    1:   
    1:   /**
    1:    * Append a new item to the top of the list. If the item is null we return
    1:    * NS_ERROR_OUT_OF_MEMORY. The intended usage is AppendNewToTop(new ...);
    1:    */
    1:   nsresult AppendNewToTop(nsDisplayItem* aItem) {
    1:     if (!aItem)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     AppendToTop(aItem);
    1:     return NS_OK;
    1:   }
    1:   
    1:   /**
    1:    * Append a new item to the bottom of the list. If the item is null we return
    1:    * NS_ERROR_OUT_OF_MEMORY. The intended usage is AppendNewToBottom(new ...);
    1:    */
    1:   nsresult AppendNewToBottom(nsDisplayItem* aItem) {
    1:     if (!aItem)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     AppendToBottom(aItem);
    1:     return NS_OK;
    1:   }
    1:   
    1:   /**
    1:    * Append a new item to the bottom of the list. The item must be non-null
    1:    * and not already in a list.
    1:    */
    1:   void AppendToBottom(nsDisplayItem* aItem) {
    1:     NS_ASSERTION(aItem, "No item to append!");
    1:     NS_ASSERTION(!aItem->mAbove, "Already in a list!");
    1:     aItem->mAbove = mSentinel.mAbove;
    1:     mSentinel.mAbove = aItem;
    1:     if (mTop == &mSentinel) {
    1:       mTop = aItem;
    1:     }
    1:   }
    1:   
    1:   /**
    1:    * Removes all items from aList and appends them to the top of this list
    1:    */
    1:   void AppendToTop(nsDisplayList* aList) {
    1:     if (aList->mSentinel.mAbove) {
    1:       mTop->mAbove = aList->mSentinel.mAbove;
    1:       mTop = aList->mTop;
    1:       aList->mTop = &aList->mSentinel;
    1:       aList->mSentinel.mAbove = nsnull;
    1:     }
    1:   }
    1:   
    1:   /**
    1:    * Removes all items from aList and prepends them to the bottom of this list
    1:    */
    1:   void AppendToBottom(nsDisplayList* aList) {
    1:     if (aList->mSentinel.mAbove) {
    1:       aList->mTop->mAbove = mSentinel.mAbove;
    1:       mTop = aList->mTop;
    1:       mSentinel.mAbove = aList->mSentinel.mAbove;
    1:            
    1:       aList->mTop = &aList->mSentinel;
    1:       aList->mSentinel.mAbove = nsnull;
    1:     }
    1:   }
    1:   
    1:   /**
    1:    * Remove an item from the bottom of the list and return it.
    1:    */
    1:   nsDisplayItem* RemoveBottom();
    1:   
    1:   /**
    1:    * Remove all items from the list and call their destructors.
    1:    */
    1:   void DeleteAll();
    1:   
    1:   /**
    1:    * @return the item at the top of the list, or null if the list is empty
    1:    */
    1:   nsDisplayItem* GetTop() const {
 3233:     return mTop != &mSentinel ? static_cast<nsDisplayItem*>(mTop) : nsnull;
    1:   }
    1:   /**
    1:    * @return the item at the bottom of the list, or null if the list is empty
    1:    */
    1:   nsDisplayItem* GetBottom() const { return mSentinel.mAbove; }
    1:   PRBool IsEmpty() const { return mTop == &mSentinel; }
    1:   
    1:   /**
    1:    * This is *linear time*!
    1:    * @return the number of items in the list
    1:    */
    1:   PRUint32 Count() const;
    1:   /**
    1:    * Stable sort the list by the z-order of GetUnderlyingFrame() on
    1:    * each item. 'auto' is counted as zero. Content order is used as the
    1:    * secondary order.
    1:    * @param aCommonAncestor a common ancestor of all the content elements
    1:    * associated with the display items, for speeding up tree order
    1:    * checks, or nsnull if not known; it's only a hint, if it is not an
    1:    * ancestor of some elements, then we lose performance but not correctness
    1:    */
    1:   void SortByZOrder(nsDisplayListBuilder* aBuilder, nsIContent* aCommonAncestor);
    1:   /**
    1:    * Stable sort the list by the tree order of the content of
    1:    * GetUnderlyingFrame() on each item. z-index is ignored.
    1:    * @param aCommonAncestor a common ancestor of all the content elements
    1:    * associated with the display items, for speeding up tree order
    1:    * checks, or nsnull if not known; it's only a hint, if it is not an
    1:    * ancestor of some elements, then we lose performance but not correctness
    1:    */
    1:   void SortByContentOrder(nsDisplayListBuilder* aBuilder, nsIContent* aCommonAncestor);
    1: 
77286:   void SortByZPosition(nsDisplayListBuilder* aBuilder, nsIContent* aCommonAncestor);
77286: 
    1:   /**
    1:    * Generic stable sort. Take care, because some of the items might be nsDisplayLists
    1:    * themselves.
    1:    * aCmp(item1, item2) should return true if item1 <= item2. We sort the items
    1:    * into increasing order.
    1:    */
    1:   typedef PRBool (* SortLEQ)(nsDisplayItem* aItem1, nsDisplayItem* aItem2,
    1:                              void* aClosure);
    1:   void Sort(nsDisplayListBuilder* aBuilder, SortLEQ aCmp, void* aClosure);
    1: 
    1:   /**
47763:    * Compute visiblity for the items in the list.
47763:    * We put this logic here so it can be shared by top-level
    1:    * painting and also display items that maintain child lists.
33368:    * This is also a good place to put ComputeVisibility-related logic
33368:    * that must be applied to every display item. In particular, this
33368:    * sets mVisibleRect on each display item.
51633:    * This sets mIsOpaque if the entire visible area of this list has
51633:    * been removed from aVisibleRegion when we return.
47763:    * This does not remove any items from the list, so we can recompute
47763:    * visiblity with different regions later (see
47763:    * FrameLayerBuilder::DrawThebesLayer).
    1:    * 
    1:    * @param aVisibleRegion the area that is visible, relative to the
51633:    * reference frame; on return, this contains the area visible under the list.
51633:    * I.e., opaque contents of this list are subtracted from aVisibleRegion.
51633:    * @param aListVisibleBounds must be equal to the bounds of the intersection
51633:    * of aVisibleRegion and GetBounds() for this list.
69802:    * @return true if any item in the list is visible.
    1:    */
51633:   PRBool ComputeVisibilityForSublist(nsDisplayListBuilder* aBuilder,
51633:                                      nsRegion* aVisibleRegion,
61411:                                      const nsRect& aListVisibleBounds,
69802:                                      const nsRect& aAllowVisibleRegionExpansion);
51633: 
51633:   /**
51633:    * As ComputeVisibilityForSublist, but computes visibility for a root
51633:    * list (a list that does not belong to an nsDisplayItem).
51633:    *
51633:    * @param aVisibleRegion the area that is visible
51633:    */
51633:   PRBool ComputeVisibilityForRoot(nsDisplayListBuilder* aBuilder,
50393:                                   nsRegion* aVisibleRegion);
51633: 
    1:   /**
38803:    * Returns true if the visible region output from ComputeVisiblity was
38803:    * empty, i.e. everything visible in this list is opaque.
38803:    */
38803:   PRBool IsOpaque() const {
38803:     NS_ASSERTION(mDidComputeVisibility, "Need to have called ComputeVisibility");
38803:     return mIsOpaque;
38803:   }
56101: 
56101:   /**
56101:    * Returns true if during ComputeVisibility any display item
56101:    * set the surface to be transparent.
56101:    */
56101:   PRBool NeedsTransparentSurface() const {
56101:     NS_ASSERTION(mDidComputeVisibility, "Need to have called ComputeVisibility");
56101:     return mForceTransparentSurface;
56101:   }
38803:   /**
    1:    * Paint the list to the rendering context. We assume that (0,0) in aCtx
12189:    * corresponds to the origin of the reference frame. For best results,
12189:    * aCtx's current transform should make (0,0) pixel-aligned. The
12189:    * rectangle in aDirtyRect is painted, which *must* be contained in the
12189:    * dirty rect used to construct the display list.
33368:    * 
38805:    * If aFlags contains PAINT_USE_WIDGET_LAYERS and
38805:    * ShouldUseWidgetLayerManager() is set, then we will paint using
38805:    * the reference frame's widget's layer manager (and ctx may be null),
38805:    * otherwise we will use a temporary BasicLayerManager and ctx must
38805:    * not be null.
38805:    * 
47739:    * If PAINT_FLUSH_LAYERS is set, we'll force a completely new layer
47739:    * tree to be created for this paint *and* the next paint.
47739:    * 
60857:    * If PAINT_EXISTING_TRANSACTION is set, the reference frame's widget's
60857:    * layer manager has already had BeginTransaction() called on it and
60857:    * we should not call it again.
60857:    *
33368:    * ComputeVisibility must be called before Paint.
42246:    * 
42246:    * This must only be called on the root display list of the display list
42246:    * tree.
    1:    */
38805:   enum {
38805:     PAINT_DEFAULT = 0,
47739:     PAINT_USE_WIDGET_LAYERS = 0x01,
60857:     PAINT_FLUSH_LAYERS = 0x02,
60857:     PAINT_EXISTING_TRANSACTION = 0x04
38805:   };
68481:   void PaintRoot(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx,
38805:                  PRUint32 aFlags) const;
    1:   /**
42246:    * Like PaintRoot, but used for internal display sublists.
42246:    * aForFrame is the frame that the list is associated with.
42246:    */
68481:   void PaintForFrame(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx,
42246:                      nsIFrame* aForFrame, PRUint32 aFlags) const;
42246:   /**
19125:    * Get the bounds. Takes the union of the bounds of all children.
19125:    */
19125:   nsRect GetBounds(nsDisplayListBuilder* aBuilder) const;
19125:   /**
    1:    * Find the topmost display item that returns a non-null frame, and return
    1:    * the frame.
    1:    */
40570:   void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                nsDisplayItem::HitTestState* aState,
40570:                nsTArray<nsIFrame*> *aOutFrames) const;
    1: 
47763: #ifdef DEBUG
47763:   PRBool DidComputeVisibility() const { return mDidComputeVisibility; }
47763: #endif
47763: 
    1: private:
    1:   // This class is only used on stack, so we don't have to worry about leaking
    1:   // it.  Don't let us be heap-allocated!
    1:   void* operator new(size_t sz) CPP_THROW_NEW;
    1:   
33368:   // Utility function used to massage the list during ComputeVisibility.
 7819:   void FlattenTo(nsTArray<nsDisplayItem*>* aElements);
    1:   // Utility function used to massage the list during sorting, to rewrite
    1:   // any wrapper items with null GetUnderlyingFrame
    1:   void ExplodeAnonymousChildLists(nsDisplayListBuilder* aBuilder);
    1:   
    1:   nsDisplayItemLink  mSentinel;
    1:   nsDisplayItemLink* mTop;
33368: 
42246:   // This is set by ComputeVisibility
42246:   nsRect mVisibleRect;
38803:   // This is set to true by ComputeVisibility if the final visible region
38803:   // is empty (i.e. everything that was visible is covered by some
38803:   // opaque content in this list).
38803:   PRPackedBool mIsOpaque;
56101:   // This is set to true by ComputeVisibility if any display item in this
56101:   // list needs to force the surface to be transparent (e.g. if the
56101:   // item "punch holes" on the surface by clearing part of its area).
56101:   PRPackedBool mForceTransparentSurface;
33368: #ifdef DEBUG
33368:   PRPackedBool mDidComputeVisibility;
33368: #endif
    1: };
    1: 
    1: /**
    1:  * This is passed as a parameter to nsIFrame::BuildDisplayList. That method
    1:  * will put any generated items onto the appropriate list given here. It's
    1:  * basically just a collection with one list for each separate stacking layer.
    1:  * The lists themselves are external to this object and thus can be shared
    1:  * with others. Some of the list pointers may even refer to the same list.
    1:  */
    1: class nsDisplayListSet {
    1: public:
    1:   /**
    1:    * @return a list where one should place the border and/or background for
    1:    * this frame (everything from steps 1 and 2 of CSS 2.1 appendix E)
    1:    */
    1:   nsDisplayList* BorderBackground() const { return mBorderBackground; }
    1:   /**
    1:    * @return a list where one should place the borders and/or backgrounds for
    1:    * block-level in-flow descendants (step 4 of CSS 2.1 appendix E)
    1:    */
    1:   nsDisplayList* BlockBorderBackgrounds() const { return mBlockBorderBackgrounds; }
    1:   /**
    1:    * @return a list where one should place descendant floats (step 5 of
    1:    * CSS 2.1 appendix E)
    1:    */
    1:   nsDisplayList* Floats() const { return mFloats; }
    1:   /**
    1:    * @return a list where one should place the (pseudo) stacking contexts 
    1:    * for descendants of this frame (everything from steps 3, 7 and 8
    1:    * of CSS 2.1 appendix E)
    1:    */
    1:   nsDisplayList* PositionedDescendants() const { return mPositioned; }
    1:   /**
    1:    * @return a list where one should place the outlines
    1:    * for this frame and its descendants (step 9 of CSS 2.1 appendix E)
    1:    */
    1:   nsDisplayList* Outlines() const { return mOutlines; }
    1:   /**
    1:    * @return a list where one should place all other content
    1:    */
    1:   nsDisplayList* Content() const { return mContent; }
    1:   
    1:   nsDisplayListSet(nsDisplayList* aBorderBackground,
    1:                    nsDisplayList* aBlockBorderBackgrounds,
    1:                    nsDisplayList* aFloats,
    1:                    nsDisplayList* aContent,
    1:                    nsDisplayList* aPositionedDescendants,
    1:                    nsDisplayList* aOutlines) :
    1:      mBorderBackground(aBorderBackground),
    1:      mBlockBorderBackgrounds(aBlockBorderBackgrounds),
    1:      mFloats(aFloats),
    1:      mContent(aContent),
    1:      mPositioned(aPositionedDescendants),
    1:      mOutlines(aOutlines) {
    1:   }
    1: 
    1:   /**
    1:    * A copy constructor that lets the caller override the BorderBackground
    1:    * list.
    1:    */  
    1:   nsDisplayListSet(const nsDisplayListSet& aLists,
    1:                    nsDisplayList* aBorderBackground) :
    1:      mBorderBackground(aBorderBackground),
    1:      mBlockBorderBackgrounds(aLists.BlockBorderBackgrounds()),
    1:      mFloats(aLists.Floats()),
    1:      mContent(aLists.Content()),
    1:      mPositioned(aLists.PositionedDescendants()),
    1:      mOutlines(aLists.Outlines()) {
    1:   }
    1:   
    1:   /**
    1:    * Move all display items in our lists to top of the corresponding lists in the
    1:    * destination.
    1:    */
    1:   void MoveTo(const nsDisplayListSet& aDestination) const;
    1: 
    1: private:
    1:   // This class is only used on stack, so we don't have to worry about leaking
    1:   // it.  Don't let us be heap-allocated!
    1:   void* operator new(size_t sz) CPP_THROW_NEW;
    1: 
    1: protected:
    1:   nsDisplayList* mBorderBackground;
    1:   nsDisplayList* mBlockBorderBackgrounds;
    1:   nsDisplayList* mFloats;
    1:   nsDisplayList* mContent;
    1:   nsDisplayList* mPositioned;
    1:   nsDisplayList* mOutlines;
    1: };
    1: 
    1: /**
    1:  * A specialization of nsDisplayListSet where the lists are actually internal
    1:  * to the object, and all distinct.
    1:  */
    1: struct nsDisplayListCollection : public nsDisplayListSet {
    1:   nsDisplayListCollection() :
    1:     nsDisplayListSet(&mLists[0], &mLists[1], &mLists[2], &mLists[3], &mLists[4],
    1:                      &mLists[5]) {}
    1:   nsDisplayListCollection(nsDisplayList* aBorderBackground) :
    1:     nsDisplayListSet(aBorderBackground, &mLists[1], &mLists[2], &mLists[3], &mLists[4],
    1:                      &mLists[5]) {}
    1: 
    1:   /**
    1:    * Sort all lists by content order.
    1:    */                     
    1:   void SortAllByContentOrder(nsDisplayListBuilder* aBuilder, nsIContent* aCommonAncestor) {
    1:     for (PRInt32 i = 0; i < 6; ++i) {
    1:       mLists[i].SortByContentOrder(aBuilder, aCommonAncestor);
    1:     }
    1:   }
    1: 
    1: private:
    1:   // This class is only used on stack, so we don't have to worry about leaking
    1:   // it.  Don't let us be heap-allocated!
    1:   void* operator new(size_t sz) CPP_THROW_NEW;
    1: 
    1:   nsDisplayList mLists[6];
    1: };
    1: 
    1: /**
    1:  * Use this class to implement not-very-frequently-used display items
    1:  * that are not opaque, do not receive events, and are bounded by a frame's
    1:  * border-rect.
    1:  * 
    1:  * This should not be used for display items which are created frequently,
    1:  * because each item is one or two pointers bigger than an item from a
    1:  * custom display item class could be, and fractionally slower. However it does
    1:  * save code size. We use this for infrequently-used item types.
    1:  */
    1: class nsDisplayGeneric : public nsDisplayItem {
    1: public:
68481:   typedef void (* PaintCallback)(nsIFrame* aFrame, nsRenderingContext* aCtx,
    1:                                  const nsRect& aDirtyRect, nsPoint aFramePt);
    1: 
51260:   nsDisplayGeneric(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
51260:                    PaintCallback aPaint, const char* aName, Type aType)
51260:     : nsDisplayItem(aBuilder, aFrame), mPaint(aPaint)
    1: #ifdef DEBUG
    1:       , mName(aName)
    1: #endif
47732:       , mType(aType)
    1:   {
    1:     MOZ_COUNT_CTOR(nsDisplayGeneric);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayGeneric() {
    1:     MOZ_COUNT_DTOR(nsDisplayGeneric);
    1:   }
    1: #endif
    1:   
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx) {
51261:     mPaint(mFrame, aCtx, mVisibleRect, ToReferenceFrame());
    1:   }
47732:   NS_DISPLAY_DECL_NAME(mName, mType)
55291: 
59781:   virtual nsRect GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder) {
59781:     if (mType == nsDisplayItem::TYPE_HEADER_FOOTER)
59781:       return GetBounds(aBuilder);
59781:     return nsRect();
55291:   }
59781: 
    1: protected:
    1:   PaintCallback mPaint;
    1: #ifdef DEBUG
    1:   const char*   mName;
    1: #endif
47732:   Type mType;
    1: };
    1: 
    1: #if defined(MOZ_REFLOW_PERF_DSP) && defined(MOZ_REFLOW_PERF)
    1: /**
    1:  * This class implements painting of reflow counts.  Ideally, we would simply
31709:  * make all the frame names be those returned by nsFrame::GetFrameName
    1:  * (except that tosses in the content tag name!)  and support only one color
    1:  * and eliminate this class altogether in favor of nsDisplayGeneric, but for
    1:  * the time being we can't pass args to a PaintCallback, so just have a
    1:  * separate class to do the right thing.  Sadly, this alsmo means we need to
    1:  * hack all leaf frame classes to handle this.
    1:  *
    1:  * XXXbz the color thing is a bit of a mess, but 0 basically means "not set"
    1:  * here...  I could switch it all to nscolor, but why bother?
    1:  */
    1: class nsDisplayReflowCount : public nsDisplayItem {
    1: public:
51260:   nsDisplayReflowCount(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
51260:                        const char* aFrameName,
    1:                        PRUint32 aColor = 0)
51260:     : nsDisplayItem(aBuilder, aFrame),
    1:       mFrameName(aFrameName),
    1:       mColor(aColor)
    1:   {
    1:     MOZ_COUNT_CTOR(nsDisplayReflowCount);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayReflowCount() {
    1:     MOZ_COUNT_DTOR(nsDisplayReflowCount);
    1:   }
    1: #endif
    1: 
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx) {
  238:     mFrame->PresContext()->PresShell()->PaintCount(mFrameName, aCtx,
  238:                                                    mFrame->PresContext(),
68487:                                                    mFrame, ToReferenceFrame(),
68487:                                                    mColor);
    1:   }
47732:   NS_DISPLAY_DECL_NAME("nsDisplayReflowCount", TYPE_REFLOW_COUNT)
    1: protected:
    1:   const char* mFrameName;
    1:   nscolor mColor;
    1: };
    1: 
    1: #define DO_GLOBAL_REFLOW_COUNT_DSP(_name)                                     \
    1:   PR_BEGIN_MACRO                                                              \
30512:     if (!aBuilder->IsBackgroundOnly() && !aBuilder->IsForEventDelivery() &&   \
30512:         PresContext()->PresShell()->IsPaintingFrameCounts()) {                \
    1:       nsresult _rv =                                                          \
51260:         aLists.Outlines()->AppendNewToTop(                                    \
51260:             new (aBuilder) nsDisplayReflowCount(aBuilder, this, _name));      \
    1:       NS_ENSURE_SUCCESS(_rv, _rv);                                            \
    1:     }                                                                         \
    1:   PR_END_MACRO
    1: 
    1: #define DO_GLOBAL_REFLOW_COUNT_DSP_COLOR(_name, _color)                       \
    1:   PR_BEGIN_MACRO                                                              \
30512:     if (!aBuilder->IsBackgroundOnly() && !aBuilder->IsForEventDelivery() &&   \
30512:         PresContext()->PresShell()->IsPaintingFrameCounts()) {                \
    1:       nsresult _rv =                                                          \
51260:         aLists.Outlines()->AppendNewToTop(                                    \
51260:              new (aBuilder) nsDisplayReflowCount(aBuilder, this, _name, _color)); \
    1:       NS_ENSURE_SUCCESS(_rv, _rv);                                            \
    1:     }                                                                         \
    1:   PR_END_MACRO
    1: 
    1: /*
    1:   Macro to be used for classes that don't actually implement BuildDisplayList
    1:  */
    1: #define DECL_DO_GLOBAL_REFLOW_COUNT_DSP(_class, _super)                   \
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,           \
    1:                               const nsRect&           aDirtyRect,         \
    1:                               const nsDisplayListSet& aLists) {           \
    1:     DO_GLOBAL_REFLOW_COUNT_DSP(#_class);                                  \
    1:     return _super::BuildDisplayList(aBuilder, aDirtyRect, aLists);        \
    1:   }
    1: 
    1: #else // MOZ_REFLOW_PERF_DSP && MOZ_REFLOW_PERF
    1: 
    1: #define DO_GLOBAL_REFLOW_COUNT_DSP(_name)
    1: #define DO_GLOBAL_REFLOW_COUNT_DSP_COLOR(_name, _color)
    1: #define DECL_DO_GLOBAL_REFLOW_COUNT_DSP(_class, _super)
    1: 
    1: #endif // MOZ_REFLOW_PERF_DSP && MOZ_REFLOW_PERF
    1: 
    1: class nsDisplayCaret : public nsDisplayItem {
    1: public:
51260:   nsDisplayCaret(nsDisplayListBuilder* aBuilder, nsIFrame* aCaretFrame,
51260:                  nsCaret *aCaret)
51260:     : nsDisplayItem(aBuilder, aCaretFrame), mCaret(aCaret) {
    1:     MOZ_COUNT_CTOR(nsDisplayCaret);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayCaret() {
    1:     MOZ_COUNT_DTOR(nsDisplayCaret);
    1:   }
    1: #endif
    1: 
    1:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
    1:     // The caret returns a rect in the coordinates of mFrame.
51261:     return mCaret->GetCaretRect() + ToReferenceFrame();
    1:   }
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
47732:   NS_DISPLAY_DECL_NAME("Caret", TYPE_CARET)
    1: protected:
15969:   nsRefPtr<nsCaret> mCaret;
    1: };
    1: 
    1: /**
    1:  * The standard display item to paint the CSS borders of a frame.
    1:  */
    1: class nsDisplayBorder : public nsDisplayItem {
    1: public:
51260:   nsDisplayBorder(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame) :
60027:     nsDisplayItem(aBuilder, aFrame),
60027:     mSnappingEnabled(aBuilder->IsSnappingEnabled() && !aBuilder->IsInTransform()) {
    1:     MOZ_COUNT_CTOR(nsDisplayBorder);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayBorder() {
    1:     MOZ_COUNT_DTOR(nsDisplayBorder);
    1:   }
    1: #endif
    1: 
60027:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
34210:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
47732:   NS_DISPLAY_DECL_NAME("Border", TYPE_BORDER)
60027: 
60027: protected:
60027:   PRPackedBool mSnappingEnabled;
    1: };
    1: 
    1: /**
27910:  * A simple display item that just renders a solid color across the
29987:  * specified bounds. For canvas frames (in the CSS sense) we split off the
29987:  * drawing of the background color into this class (from nsDisplayBackground
29987:  * via nsDisplayCanvasBackground). This is done so that we can always draw a
29987:  * background color to avoid ugly flashes of white when we can't draw a full
29987:  * frame tree (ie when a page is loading). The bounds can differ from the
29987:  * frame's bounds -- this is needed when a frame/iframe is loading and there
29987:  * is not yet a frame tree to go in the frame/iframe so we use the subdoc
29987:  * frame of the parent document as a standin.
27834:  */
27834: class nsDisplaySolidColor : public nsDisplayItem {
27834: public:
51260:   nsDisplaySolidColor(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
69802:                       const nsRect& aBounds, nscolor aColor)
61411:     : nsDisplayItem(aBuilder, aFrame), mBounds(aBounds), mColor(aColor),
69786:       mSnappingEnabled(aBuilder->IsSnappingEnabled() && !aBuilder->IsInTransform()) {
60674:     NS_ASSERTION(NS_GET_A(aColor) > 0, "Don't create invisible nsDisplaySolidColors!");
27834:     MOZ_COUNT_CTOR(nsDisplaySolidColor);
27834:   }
27834: #ifdef NS_BUILD_REFCNT_LOGGING
27834:   virtual ~nsDisplaySolidColor() {
27834:     MOZ_COUNT_DTOR(nsDisplaySolidColor);
27834:   }
27834: #endif
27834: 
69786:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
27834: 
59779:   virtual nsRegion GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
56101:                                    PRBool* aOutTransparentBackground = nsnull) {
56101:     if (aOutTransparentBackground) {
56101:       *aOutTransparentBackground = PR_FALSE;
56101:     }
59779:     nsRegion result;
59779:     if (NS_GET_A(mColor) == 255) {
59779:       result = GetBounds(aBuilder);
59779:     }
59779:     return result;
27834:   }
27834: 
42436:   virtual PRBool IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor)
42436:   {
42436:     *aColor = mColor;
42436:     return PR_TRUE;
42436:   }
27834: 
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
27834: 
47732:   NS_DISPLAY_DECL_NAME("SolidColor", TYPE_SOLID_COLOR)
47732: 
27834: private:
27834:   nsRect  mBounds;
27834:   nscolor mColor;
69786:   PRPackedBool mSnappingEnabled;
27834: };
27834: 
27834: /**
    1:  * The standard display item to paint the CSS background of a frame.
    1:  */
    1: class nsDisplayBackground : public nsDisplayItem {
    1: public:
51260:   nsDisplayBackground(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame);
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayBackground() {
    1:     MOZ_COUNT_DTOR(nsDisplayBackground);
    1:   }
    1: #endif
    1: 
40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
55316:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
47754:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
59779:   virtual nsRegion GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
56101:                                    PRBool* aForceTransparentSurface = nsnull);
50392:   virtual PRBool IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
50392:                                                 nsIFrame* aFrame);
42436:   virtual PRBool IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor);
67668:   virtual PRBool ShouldFixToViewport(nsDisplayListBuilder* aBuilder);
 9369:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
47732:   NS_DISPLAY_DECL_NAME("Background", TYPE_BACKGROUND)
47754: protected:
60027:   nsRegion GetInsideClipRegion(nsPresContext* aPresContext, PRUint8 aClip,
60027:                                const nsRect& aRect);
59780: 
 9369:   /* Used to cache mFrame->IsThemed() since it isn't a cheap call */
 9369:   PRPackedBool mIsThemed;
60027:   PRPackedBool mSnappingEnabled;
43487:   nsITheme::Transparency mThemeTransparency;
    1: };
    1: 
    1: /**
24818:  * The standard display item to paint the outer CSS box-shadows of a frame.
15700:  */
24818: class nsDisplayBoxShadowOuter : public nsDisplayItem {
15700: public:
51260:   nsDisplayBoxShadowOuter(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
51260:     : nsDisplayItem(aBuilder, aFrame) {
24818:     MOZ_COUNT_CTOR(nsDisplayBoxShadowOuter);
15700:   }
15700: #ifdef NS_BUILD_REFCNT_LOGGING
24818:   virtual ~nsDisplayBoxShadowOuter() {
24818:     MOZ_COUNT_DTOR(nsDisplayBoxShadowOuter);
15700:   }
15700: #endif
15700: 
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
15700:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
34210:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
47732:   NS_DISPLAY_DECL_NAME("BoxShadowOuter", TYPE_BOX_SHADOW_OUTER)
35288: 
35288: private:
35288:   nsRegion mVisibleRegion;
24818: };
24818: 
24818: /**
24818:  * The standard display item to paint the inner CSS box-shadows of a frame.
24818:  */
24818: class nsDisplayBoxShadowInner : public nsDisplayItem {
24818: public:
51260:   nsDisplayBoxShadowInner(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
51260:     : nsDisplayItem(aBuilder, aFrame) {
24818:     MOZ_COUNT_CTOR(nsDisplayBoxShadowInner);
24818:   }
24818: #ifdef NS_BUILD_REFCNT_LOGGING
24818:   virtual ~nsDisplayBoxShadowInner() {
24818:     MOZ_COUNT_DTOR(nsDisplayBoxShadowInner);
24818:   }
24818: #endif
24818: 
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
35288:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
47732:   NS_DISPLAY_DECL_NAME("BoxShadowInner", TYPE_BOX_SHADOW_INNER)
35288: 
35288: private:
35288:   nsRegion mVisibleRegion;
15700: };
15700: 
15700: /**
    1:  * The standard display item to paint the CSS outline of a frame.
    1:  */
    1: class nsDisplayOutline : public nsDisplayItem {
    1: public:
51260:   nsDisplayOutline(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame) :
51260:     nsDisplayItem(aBuilder, aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayOutline);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayOutline() {
    1:     MOZ_COUNT_DTOR(nsDisplayOutline);
    1:   }
    1: #endif
    1: 
    1:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
34210:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
47732:   NS_DISPLAY_DECL_NAME("Outline", TYPE_OUTLINE)
    1: };
    1: 
    1: /**
    1:  * A class that lets you receive events within the frame bounds but never paints.
    1:  */
    1: class nsDisplayEventReceiver : public nsDisplayItem {
    1: public:
51260:   nsDisplayEventReceiver(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
51260:     : nsDisplayItem(aBuilder, aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayEventReceiver);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayEventReceiver() {
    1:     MOZ_COUNT_DTOR(nsDisplayEventReceiver);
    1:   }
    1: #endif
    1: 
40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
55316:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
47732:   NS_DISPLAY_DECL_NAME("EventReceiver", TYPE_EVENT_RECEIVER)
    1: };
    1: 
    1: /**
    1:  * A class that lets you wrap a display list as a display item.
    1:  * 
    1:  * GetUnderlyingFrame() is troublesome for wrapped lists because if the wrapped
    1:  * list has many items, it's not clear which one has the 'underlying frame'.
    1:  * Thus we force the creator to specify what the underlying frame is. The
    1:  * underlying frame should be the root of a stacking context, because sorting
    1:  * a list containing this item will not get at the children.
    1:  * 
    1:  * In some cases (e.g., clipping) we want to wrap a list but we don't have a
    1:  * particular underlying frame that is a stacking context root. In that case
    1:  * we allow the frame to be nsnull. Callers to GetUnderlyingFrame must
    1:  * detect and handle this case.
    1:  */
    1: class nsDisplayWrapList : public nsDisplayItem {
    1:   // This is never instantiated directly, so no need to count constructors and
    1:   // destructors.
    1: 
    1: public:
    1:   /**
    1:    * Takes all the items from aList and puts them in our list.
    1:    */
51260:   nsDisplayWrapList(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
51260:                     nsDisplayList* aList);
51260:   nsDisplayWrapList(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
51260:                     nsDisplayItem* aItem);
69189:   nsDisplayWrapList(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame);
    1:   virtual ~nsDisplayWrapList();
40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
    1:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
59779:   virtual nsRegion GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
56101:                                    PRBool* aForceTransparentSurface = nsnull);
42436:   virtual PRBool IsUniform(nsDisplayListBuilder* aBuilder, nscolor* aColor);
50392:   virtual PRBool IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
50392:                                                 nsIFrame* aFrame);
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
33368:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
    1:   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem) {
    1:     NS_WARNING("This list should already have been flattened!!!");
    1:     return PR_FALSE;
    1:   }
47732:   NS_DISPLAY_DECL_NAME("WrapList", TYPE_WRAP_LIST)
    1: 
59781:   virtual nsRect GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder);
55291:                                     
    1:   virtual nsDisplayList* GetList() { return &mList; }
    1:   
    1:   /**
    1:    * This creates a copy of this item, but wrapping aItem instead of
    1:    * our existing list. Only gets called if this item returned nsnull
    1:    * for GetUnderlyingFrame(). aItem is guaranteed to return non-null from
    1:    * GetUnderlyingFrame().
    1:    */
    1:   virtual nsDisplayWrapList* WrapWithClone(nsDisplayListBuilder* aBuilder,
    1:                                            nsDisplayItem* aItem) {
    1:     NS_NOTREACHED("We never returned nsnull for GetUnderlyingFrame!");
    1:     return nsnull;
    1:   }
    1: 
47751:   /**
47751:    * Returns true if all descendant display items can be placed in the same
47751:    * ThebesLayer --- GetLayerState returns LAYER_INACTIVE or LAYER_NONE,
47751:    * and they all have the given aActiveScrolledRoot.
47751:    */
47751:   static PRBool ChildrenCanBeInactive(nsDisplayListBuilder* aBuilder,
47751:                                       LayerManager* aManager,
47751:                                       const nsDisplayList& aList,
47751:                                       nsIFrame* aActiveScrolledRoot);
47751: 
    1: protected:
    1:   nsDisplayWrapList() {}
    1:   
    1:   nsDisplayList mList;
    1: };
    1: 
    1: /**
    1:  * We call WrapDisplayList on the in-flow lists: BorderBackground(),
    1:  * BlockBorderBackgrounds() and Content().
    1:  * We call WrapDisplayItem on each item of Outlines(), PositionedDescendants(),
    1:  * and Floats(). This is done to support special wrapping processing for frames
    1:  * that may not be in-flow descendants of the current frame.
    1:  */
    1: class nsDisplayWrapper {
    1: public:
    1:   // This is never instantiated directly (it has pure virtual methods), so no
    1:   // need to count constructors and destructors.
    1: 
    1:   virtual PRBool WrapBorderBackground() { return PR_TRUE; }
    1:   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
    1:                                   nsIFrame* aFrame, nsDisplayList* aList) = 0;
    1:   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
    1:                                   nsDisplayItem* aItem) = 0;
    1: 
    1:   nsresult WrapLists(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
    1:                      const nsDisplayListSet& aIn, const nsDisplayListSet& aOut);
    1:   nsresult WrapListsInPlace(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
    1:                             const nsDisplayListSet& aLists);
    1: protected:
    1:   nsDisplayWrapper() {}
    1: };
    1:                               
    1: /**
    1:  * The standard display item to paint a stacking context with translucency
    1:  * set by the stacking context root frame's 'opacity' style.
    1:  */
    1: class nsDisplayOpacity : public nsDisplayWrapList {
    1: public:
51260:   nsDisplayOpacity(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
51260:                    nsDisplayList* aList);
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayOpacity();
    1: #endif
    1:   
59779:   virtual nsRegion GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
56101:                                    PRBool* aForceTransparentSurface = nsnull);
38803:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                                              LayerManager* aManager,
72230:                                              const ContainerParameters& aContainerParameters);
47751:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
47751:                                    LayerManager* aManager);
33368:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);  
    1:   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
47732:   NS_DISPLAY_DECL_NAME("Opacity", TYPE_OPACITY)
    1: };
    1: 
    1: /**
47744:  * A display item that has no purpose but to ensure its contents get
47744:  * their own layer.
47744:  */
47744: class nsDisplayOwnLayer : public nsDisplayWrapList {
47744: public:
51260:   nsDisplayOwnLayer(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
51260:                     nsDisplayList* aList);
47744: #ifdef NS_BUILD_REFCNT_LOGGING
47744:   virtual ~nsDisplayOwnLayer();
47744: #endif
47744:   
47744:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                                              LayerManager* aManager,
72230:                                              const ContainerParameters& aContainerParameters);
47751:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
47751:                                    LayerManager* aManager)
47751:   {
47751:     return mozilla::LAYER_ACTIVE;
47751:   }
47744:   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem)
47744:   {
47744:     // Don't allow merging, each sublist must have its own layer
47744:     return PR_FALSE;
47744:   }
47744:   NS_DISPLAY_DECL_NAME("OwnLayer", TYPE_OWN_LAYER)
47744: };
47744: 
60447: /**
69189:  * This potentially creates a layer for the given list of items, whose
69189:  * visibility is determined by the displayport for the given frame instead of
69189:  * what is passed in to ComputeVisibility.
60447:  *
60447:  * Here in content, we can use this to render more content than is actually
60447:  * visible. Then, the compositing process can manipulate the generated layer
60447:  * through transformations so that asynchronous scrolling can be implemented.
60447:  *
60447:  * Note that setting the displayport will not change any hit testing! The
60447:  * content process will know nothing about what the user is actually seeing,
60447:  * so it can only do hit testing for what is supposed to be the visible region.
69189:  *
69189:  * It is possible for scroll boxes to have content that can be both above and
69189:  * below content outside of the scroll box. We cannot create layers for these
69189:  * cases. This is accomplished by wrapping display items with
69189:  * nsDisplayScrollLayers. nsDisplayScrollLayers with the same scroll frame will
69189:  * be merged together. If more than one nsDisplayScrollLayer exists after
69189:  * merging, all nsDisplayScrollLayers will be flattened out so that no new
69189:  * layer is created at all.
60447:  */
69189: class nsDisplayScrollLayer : public nsDisplayWrapList
60447: {
60447: public:
60447:   /**
69189:    * @param aScrolledFrame This will determine what the displayport is. It should be
69189:    *                       the root content frame of the scrolled area. Note
69189:    *                       that nsDisplayScrollLayer will expect for
69189:    *                       ScrollLayerCount to be defined on aScrolledFrame.
69189:    * @param aScrollFrame The viewport frame you see this content through.
60447:    */
60447:   nsDisplayScrollLayer(nsDisplayListBuilder* aBuilder, nsDisplayList* aList,
69189:                        nsIFrame* aForFrame, nsIFrame* aScrolledFrame,
69189:                        nsIFrame* aScrollFrame);
69189:   nsDisplayScrollLayer(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem,
69189:                        nsIFrame* aForFrame, nsIFrame* aScrolledFrame,
69189:                        nsIFrame* aScrollFrame);
69189:   nsDisplayScrollLayer(nsDisplayListBuilder* aBuilder,
69189:                        nsIFrame* aForFrame, nsIFrame* aScrolledFrame,
69189:                        nsIFrame* aScrollFrame);
60447:   NS_DISPLAY_DECL_NAME("ScrollLayer", TYPE_SCROLL_LAYER)
60447: 
60447: #ifdef NS_BUILD_REFCNT_LOGGING
60447:   virtual ~nsDisplayScrollLayer();
60447: #endif
60447: 
60447:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                                              LayerManager* aManager,
72230:                                              const ContainerParameters& aContainerParameters);
60447: 
60447:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
60447: 
63413:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
69189:                                    LayerManager* aManager);
69189: 
69189:   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder,
69189:                           nsDisplayItem* aItem);
69189: 
69189:   virtual PRBool ShouldFlattenAway(nsDisplayListBuilder* aBuilder);
69189: 
69189:   // Get the number of nsDisplayScrollLayers for a scroll frame. Note that this
69189:   // number does not include nsDisplayScrollInfoLayers. If this number is not 1
69189:   // after merging, all the nsDisplayScrollLayers should flatten away.
69189:   PRWord GetScrollLayerCount();
69189:   PRWord RemoveScrollLayerCount();
69189: 
60447: private:
69189:   nsIFrame* mScrollFrame;
69189:   nsIFrame* mScrolledFrame;
60447: };
60447: 
47744: /**
67860:  * Like nsDisplayScrollLayer, but only has metadata on the scroll frame. This
67860:  * creates a layer that has no Thebes child layer, but still allows the
67860:  * compositor process to know of the scroll frame's existence.
69189:  *
69189:  * After visibility computation, nsDisplayScrollInfoLayers should only exist if
69189:  * nsDisplayScrollLayers were all flattened away.
69189:  *
69189:  * Important!! Add info layers to the bottom of the list so they are only
69189:  * considered after the others have flattened out!
67860:  */
67860: class nsDisplayScrollInfoLayer : public nsDisplayScrollLayer
67860: {
67860: public:
69189:   nsDisplayScrollInfoLayer(nsDisplayListBuilder* aBuilder,
69189:                            nsIFrame* aScrolledFrame, nsIFrame* aScrollFrame);
67860:   NS_DISPLAY_DECL_NAME("ScrollInfoLayer", TYPE_SCROLL_INFO_LAYER)
67860: 
67860: #ifdef NS_BUILD_REFCNT_LOGGING
67860:   virtual ~nsDisplayScrollInfoLayer();
67860: #endif
67860: 
67860:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
69189:                                    LayerManager* aManager);
67860: 
69189:   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder,
69189:                           nsDisplayItem* aItem);
69189: 
69189:   virtual PRBool ShouldFlattenAway(nsDisplayListBuilder* aBuilder);
67860: };
67860: 
67860: /**
    1:  * nsDisplayClip can clip a list of items, but we take a single item
    1:  * initially and then later merge other items into it when we merge
    1:  * adjacent matching nsDisplayClips
    1:  */
    1: class nsDisplayClip : public nsDisplayWrapList {
    1: public:
14466:   /**
14466:    * @param aFrame the frame that should be considered the underlying
52289:    * frame for this content, e.g. the frame whose z-index we have.  This
52289:    * is *not* the frame that is inducing the clipping.
14466:    */
51260:   nsDisplayClip(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
14466:                 nsDisplayItem* aItem, const nsRect& aRect);
51260:   nsDisplayClip(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
14466:                 nsDisplayList* aList, const nsRect& aRect);
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayClip();
    1: #endif
    1:   
    1:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
33368:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
    1:   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
47732:   NS_DISPLAY_DECL_NAME("Clip", TYPE_CLIP)
47733:   virtual PRUint32 GetPerFrameKey() { return 0; }
    1:   
47734:   const nsRect& GetClipRect() { return mClip; }
14043:   void SetClipRect(const nsRect& aRect) { mClip = aRect; }
    1: 
    1:   virtual nsDisplayWrapList* WrapWithClone(nsDisplayListBuilder* aBuilder,
    1:                                            nsDisplayItem* aItem);
    1: 
52292: protected:
52292:   nsRect    mClip;
52292: };
52292: 
52292: /**
52292:  * A display item to clip a list of items to the border-radius of a
52292:  * frame.
52292:  */
52292: class nsDisplayClipRoundedRect : public nsDisplayClip {
52292: public:
52292:   /**
52292:    * @param aFrame the frame that should be considered the underlying
52292:    * frame for this content, e.g. the frame whose z-index we have.  This
52292:    * is *not* the frame that is inducing the clipping.
52292:    */
52292:   nsDisplayClipRoundedRect(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
52292:                            nsDisplayItem* aItem,
52292:                            const nsRect& aRect, nscoord aRadii[8]);
52292:   nsDisplayClipRoundedRect(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
52292:                            nsDisplayList* aList,
52292:                            const nsRect& aRect, nscoord aRadii[8]);
52292: #ifdef NS_BUILD_REFCNT_LOGGING
52292:   virtual ~nsDisplayClipRoundedRect();
52292: #endif
52292: 
59779:   virtual nsRegion GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
56101:                                    PRBool* aForceTransparentSurface = nsnull);
52292:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
52292:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
52292:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
52292:   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
52292:   NS_DISPLAY_DECL_NAME("ClipRoundedRect", TYPE_CLIP_ROUNDED_RECT)
52292: 
52292:   virtual nsDisplayWrapList* WrapWithClone(nsDisplayListBuilder* aBuilder,
52292:                                            nsDisplayItem* aItem);
52292: 
52292:   void GetRadii(nscoord aRadii[8]) {
52292:     memcpy(aRadii, mRadii, sizeof(mRadii));
52292:   }
52292: 
    1: private:
52292:   nscoord mRadii[8];
    1: };
    1: 
47900: /**
47900:  * nsDisplayZoom is used for subdocuments that have a different full zoom than
49160:  * their parent documents. This item creates a container layer.
47900:  */
49160: class nsDisplayZoom : public nsDisplayOwnLayer {
47900: public:
47900:   /**
47900:    * @param aFrame is the root frame of the subdocument.
47900:    * @param aList contains the display items for the subdocument.
47900:    * @param aAPD is the app units per dev pixel ratio of the subdocument.
47900:    * @param aParentAPD is the app units per dev pixel ratio of the parent
47900:    * document.
47900:    */
51260:   nsDisplayZoom(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
51260:                 nsDisplayList* aList,
47900:                 PRInt32 aAPD, PRInt32 aParentAPD);
47900: #ifdef NS_BUILD_REFCNT_LOGGING
47900:   virtual ~nsDisplayZoom();
47900: #endif
47900:   
47900:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder);
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
47900:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
47900:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
47900:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
47900:   NS_DISPLAY_DECL_NAME("Zoom", TYPE_ZOOM)
47900: 
49157:   // Get the app units per dev pixel ratio of the child document.
49157:   PRInt32 GetChildAppUnitsPerDevPixel() { return mAPD; }
49157:   // Get the app units per dev pixel ratio of the parent document.
49157:   PRInt32 GetParentAppUnitsPerDevPixel() { return mParentAPD; }
49157: 
47900: private:
47900:   PRInt32 mAPD, mParentAPD;
47900: };
47900: 
19125: /**
19125:  * A display item to paint a stacking context with effects
19125:  * set by the stacking context root frame's style.
19125:  */
19125: class nsDisplaySVGEffects : public nsDisplayWrapList {
19125: public:
51260:   nsDisplaySVGEffects(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
51260:                       nsDisplayList* aList);
19125: #ifdef NS_BUILD_REFCNT_LOGGING
19125:   virtual ~nsDisplaySVGEffects();
19125: #endif
19125:   
59779:   virtual nsRegion GetOpaqueRegion(nsDisplayListBuilder* aBuilder,
56101:                                    PRBool* aForceTransparentSurface = nsnull);
40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
19125:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
19125:     return mBounds + aBuilder->ToReferenceFrame(mEffectsFrame);
19125:   }
68481:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsRenderingContext* aCtx);
33368:   virtual PRBool ComputeVisibility(nsDisplayListBuilder* aBuilder,
61411:                                    nsRegion* aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);  
19125:   virtual PRBool TryMerge(nsDisplayListBuilder* aBuilder, nsDisplayItem* aItem);
47732:   NS_DISPLAY_DECL_NAME("SVGEffects", TYPE_SVG_EFFECTS)
19125: 
19125:   nsIFrame* GetEffectsFrame() { return mEffectsFrame; }
19125: 
19125: private:
19125:   nsIFrame* mEffectsFrame;
19125:   // relative to mEffectsFrame
19125:   nsRect    mBounds;
19125: };
19125: 
70849: /* A display item that applies a transformation to all of its descendant
19214:  * elements.  This wrapper should only be used if there is a transform applied
19214:  * to the root element.
70849:  *
70849:  * The reason that a "bounds" rect is involved in transform calculations is
70849:  * because CSS-transforms allow percentage values for the x and y components
70849:  * of <translation-value>s, where percentages are percentages of the element's
70849:  * content box.
70849:  *
19214:  * INVARIANT: The wrapped frame is transformed.
19214:  * INVARIANT: The wrapped frame is non-null.
19214:  */ 
19214: class nsDisplayTransform: public nsDisplayItem
19214: {
19214: public:
19214:   /* Constructor accepts a display list, empties it, and wraps it up.  It also
19214:    * ferries the underlying frame to the nsDisplayItem constructor.
19214:    */
51260:   nsDisplayTransform(nsDisplayListBuilder* aBuilder, nsIFrame *aFrame,
51260:                      nsDisplayList *aList) :
51260:     nsDisplayItem(aBuilder, aFrame), mStoredList(aBuilder, aFrame, aList)
19214:   {
19214:     MOZ_COUNT_CTOR(nsDisplayTransform);
77850:     NS_ABORT_IF_FALSE(aFrame, "Must have a frame!");
19214:   }
19214: 
77286:   nsDisplayTransform(nsDisplayListBuilder* aBuilder, nsIFrame *aFrame,
77286:                      nsDisplayItem *aItem) :
77286:   nsDisplayItem(aBuilder, aFrame), mStoredList(aBuilder, aFrame, aItem)
77286:   {
77286:     MOZ_COUNT_CTOR(nsDisplayTransform);
77850:     NS_ABORT_IF_FALSE(aFrame, "Must have a frame!");
77286:   }
77286: 
19214: #ifdef NS_BUILD_REFCNT_LOGGING
19214:   virtual ~nsDisplayTransform()
19214:   {
19214:     MOZ_COUNT_DTOR(nsDisplayTransform);
19214:   }
19214: #endif
19214: 
47732:   NS_DISPLAY_DECL_NAME("nsDisplayTransform", TYPE_TRANSFORM);
19214: 
59781:   virtual nsRect GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder)
59781:   {
59781:     if (mStoredList.GetComponentAlphaBounds(aBuilder).IsEmpty())
59781:       return nsRect();
59781:     return GetBounds(aBuilder);
59781:   }
55291: 
26952:   nsDisplayWrapList* GetStoredList() { return &mStoredList; }
26952: 
40570:   virtual void HitTest(nsDisplayListBuilder *aBuilder, const nsRect& aRect,
40570:                        HitTestState *aState, nsTArray<nsIFrame*> *aOutFrames);
19214:   virtual nsRect GetBounds(nsDisplayListBuilder *aBuilder);
59779:   virtual nsRegion GetOpaqueRegion(nsDisplayListBuilder *aBuilder,
56101:                                    PRBool* aForceTransparentSurface = nsnull);
42436:   virtual PRBool IsUniform(nsDisplayListBuilder *aBuilder, nscolor* aColor);
48693:   virtual LayerState GetLayerState(nsDisplayListBuilder* aBuilder,
48693:                                    LayerManager* aManager);
48693:   virtual already_AddRefed<Layer> BuildLayer(nsDisplayListBuilder* aBuilder,
72230:                                              LayerManager* aManager,
72230:                                              const ContainerParameters& aContainerParameters);
33368:   virtual PRBool ComputeVisibility(nsDisplayListBuilder *aBuilder,
61411:                                    nsRegion *aVisibleRegion,
69802:                                    const nsRect& aAllowVisibleRegionExpansion);
19214:   virtual PRBool TryMerge(nsDisplayListBuilder *aBuilder, nsDisplayItem *aItem);
19214: 
74283:   const gfx3DMatrix& GetTransform(float aFactor);
74281: 
19214:   /**
19214:    * TransformRect takes in as parameters a rectangle (in aFrame's coordinate
19214:    * space) and returns the smallest rectangle (in aFrame's coordinate space)
19214:    * containing the transformed image of that rectangle.  That is, it takes
19214:    * the four corners of the rectangle, transforms them according to the
19214:    * matrix associated with the specified frame, then returns the smallest
19214:    * rectangle containing the four transformed points.
19214:    *
19214:    * @param untransformedBounds The rectangle (in app units) to transform.
19214:    * @param aFrame The frame whose transformation should be applied.  This
19214:    *        function raises an assertion if aFrame is null or doesn't have a
19214:    *        transform applied to it.
19214:    * @param aOrigin The origin of the transform relative to aFrame's local
19214:    *        coordinate space.
19214:    * @param aBoundsOverride (optional) Rather than using the frame's computed
19214:    *        bounding rect as frame bounds, use this rectangle instead.  Pass
19214:    *        nsnull (or nothing at all) to use the default.
19214:    */
19214:   static nsRect TransformRect(const nsRect &aUntransformedBounds, 
19214:                               const nsIFrame* aFrame,
19214:                               const nsPoint &aOrigin,
19214:                               const nsRect* aBoundsOverride = nsnull);
19214: 
63072:   static nsRect TransformRectOut(const nsRect &aUntransformedBounds, 
63072:                                  const nsIFrame* aFrame,
63072:                                  const nsPoint &aOrigin,
63072:                                  const nsRect* aBoundsOverride = nsnull);
63072: 
19214:   /* UntransformRect is like TransformRect, except that it inverts the
19214:    * transform.
19214:    */
74283:   static PRBool UntransformRect(const nsRect &aUntransformedBounds, 
19214:                                 const nsIFrame* aFrame,
74283:                                 const nsPoint &aOrigin,
74283:                                 nsRect* aOutRect);
19214: 
19214:   /**
71889:    * Returns the bounds of a frame as defined for resolving percentage
71889:    * <translation-value>s in CSS transforms.  If
19214:    * UNIFIED_CONTINUATIONS is not defined, this is simply the frame's bounding
19214:    * rectangle, translated to the origin.  Otherwise, returns the smallest
19214:    * rectangle containing a frame and all of its continuations.  For example,
19214:    * if there is a <span> element with several continuations split over
19214:    * several lines, this function will return the rectangle containing all of
19214:    * those continuations.  This rectangle is relative to the origin of the
19214:    * frame's local coordinate space.
19214:    *
19214:    * @param aFrame The frame to get the bounding rect for.
19214:    * @return The frame's bounding rect, as described above.
19214:    */
19214:   static nsRect GetFrameBoundsForTransform(const nsIFrame* aFrame);
19214: 
19214:   /**
19214:    * Given a frame with the -moz-transform property, returns the
19214:    * transformation matrix for that frame.
19214:    *
19214:    * @param aFrame The frame to get the matrix from.
19214:    * @param aOrigin Relative to which point this transform should be applied.
19214:    * @param aScaleFactor The number of app units per graphics unit.
19214:    * @param aBoundsOverride [optional] If this is nsnull (the default), the
19214:    *        computation will use the value of GetFrameBoundsForTransform(aFrame)
19214:    *        for the frame's bounding rectangle. Otherwise, it will use the
19214:    *        value of aBoundsOverride.  This is mostly for internal use and in
19214:    *        most cases you will not need to specify a value.
19214:    */
74283:   static gfx3DMatrix GetResultingTransformMatrix(const nsIFrame* aFrame,
19214:                                                  const nsPoint& aOrigin,
19214:                                                  float aFactor,
77286:                                                  const nsRect* aBoundsOverride = nsnull,
77286:                                                  nsIFrame** aOutAncestor = nsnull);
19214: 
19214: private:
19214:   nsDisplayWrapList mStoredList;
74283:   gfx3DMatrix mTransform;
74281:   float mCachedFactor;
19214: };
19214: 
72260: /**
72260:  * This class adds basic support for limiting the rendering to the part inside
72260:  * the specified edges.  It's a base class for the display item classes that
72260:  * does the actual work.  The two members, mLeftEdge and mRightEdge, are
72260:  * relative to the edges of the frame's scrollable overflow rectangle and is
72260:  * the amount to suppress on each side.
72260:  *
72260:  * Setting none, both or only one edge is allowed.
72260:  * The values must be non-negative.
72260:  * The default value for both edges is zero, which means everything is painted.
72260:  */
72260: class nsCharClipDisplayItem : public nsDisplayItem {
72260: public:
72260:   nsCharClipDisplayItem(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame)
72260:     : nsDisplayItem(aBuilder, aFrame), mLeftEdge(0), mRightEdge(0) {}
72260: 
72260:   struct ClipEdges {
72260:     ClipEdges(const nsDisplayItem& aItem,
72260:               nscoord aLeftEdge, nscoord aRightEdge) {
72260:       nsRect r = aItem.GetUnderlyingFrame()->GetScrollableOverflowRect() +
72260:                  aItem.ToReferenceFrame();
72260:       mX = aLeftEdge > 0 ? r.x + aLeftEdge : nscoord_MIN;
72260:       mXMost = aRightEdge > 0 ? NS_MAX(r.XMost() - aRightEdge, mX) : nscoord_MAX;
72260:     }
72260:     void Intersect(nscoord* aX, nscoord* aWidth) const {
72260:       nscoord xmost1 = *aX + *aWidth;
72260:       *aX = NS_MAX(*aX, mX);
72260:       *aWidth = NS_MAX(NS_MIN(xmost1, mXMost) - *aX, 0);
72260:     }
72260:     nscoord mX;
72260:     nscoord mXMost;
72260:   };
72260: 
72260:   ClipEdges Edges() const { return ClipEdges(*this, mLeftEdge, mRightEdge); }
72260: 
72260:   static nsCharClipDisplayItem* CheckCast(nsDisplayItem* aItem) {
72260:     nsDisplayItem::Type t = aItem->GetType();
72260:     return (t == nsDisplayItem::TYPE_TEXT ||
72260:             t == nsDisplayItem::TYPE_TEXT_DECORATION ||
72260:             t == nsDisplayItem::TYPE_TEXT_SHADOW)
72260:       ? static_cast<nsCharClipDisplayItem*>(aItem) : nsnull;
72260:   }
72260: 
72260:   nscoord mLeftEdge;  // length from the left side
72260:   nscoord mRightEdge; // length from the right side
72260: };
72260: 
72260: 
72260: /**
72260:  * This is a dummy item that reports true for IsVaryingRelativeToMovingFrame.
72260:  * It forces the bounds of its frame to be repainted every time it is scrolled.
72260:  * It is transparent to events and does not paint anything.
72260:  */
72260: class nsDisplayForcePaintOnScroll : public nsDisplayItem
72260: {
72260: public:
72260:   nsDisplayForcePaintOnScroll(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame);
72260: #ifdef NS_BUILD_REFCNT_LOGGING
72260:   virtual ~nsDisplayForcePaintOnScroll();
72260: #endif
72260:   NS_DISPLAY_DECL_NAME("ForcePaintOnScroll", TYPE_FORCEPAINTONSCROLL)
72260:   virtual PRBool IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
72260:                                                 nsIFrame* aFrame);
72260: };
72260: 
    1: #endif /*NSDISPLAYLIST_H_*/
