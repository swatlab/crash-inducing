35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
36124:  *   Jim Mathies <jmathies@mozilla.com>
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #include "PluginInstanceChild.h"
35925: #include "PluginModuleChild.h"
35895: #include "BrowserStreamChild.h"
35938: #include "PluginStreamChild.h"
35904: #include "StreamNotifyChild.h"
35746: 
36056: #include "mozilla/ipc/SyncChannel.h"
36056: 
35925: using namespace mozilla::plugins;
35925: 
35957: #ifdef MOZ_WIDGET_GTK2
35747: 
35740: #include <gtk/gtk.h>
35740: #include <gdk/gdkx.h>
35740: #include <gdk/gdk.h>
35740: #include "gtk2xtbin.h"
35747: 
35747: #elif defined(OS_WIN)
36130: using mozilla::gfx::SharedDIB;
35747: 
35747: #include <windows.h>
35747: 
36270: #define NS_OOPP_DOUBLEPASS_MSGID TEXT("MozDoublePassMsg")
35746: #endif
35740: 
35980: PluginInstanceChild::PluginInstanceChild(const NPPluginFuncs* aPluginIface) :
35980:     mPluginIface(aPluginIface)
35980: #if defined(OS_WIN)
35980:     , mPluginWindowHWND(0)
35980:     , mPluginWndProc(0)
35980:     , mPluginParentHWND(0)
37311: #endif // OS_WIN
35980: {
35980:     memset(&mWindow, 0, sizeof(mWindow));
35980:     mData.ndata = (void*) this;
35980: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35980:     mWindow.ws_info = &mWsInfo;
35980:     memset(&mWsInfo, 0, sizeof(mWsInfo));
35980: #ifdef MOZ_WIDGET_GTK2
35980:     mWsInfo.display = GDK_DISPLAY();
37311: #endif // MOZ_WIDGET_GTK2
37311: #endif // MOZ_X11 && XP_UNIX && !XP_MACOSX
36270: #if defined(OS_WIN)
36270:     memset(&mAlphaExtract, 0, sizeof(mAlphaExtract));
36270:     mAlphaExtract.doublePassEvent = ::RegisterWindowMessage(NS_OOPP_DOUBLEPASS_MSGID);
37311: #endif // OS_WIN
35980: }
35980: 
35893: PluginInstanceChild::~PluginInstanceChild()
35747: {
35747: #if defined(OS_WIN)
35747:   DestroyPluginWindow();
35747: #endif
35747: }
35747: 
35740: NPError
35893: PluginInstanceChild::NPN_GetValue(NPNVariable aVar,
35893:                                   void* aValue)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aVar=%i)", FULLFUNCTION, (int) aVar));
35971:     AssertPluginThread();
35740: 
35746:     switch(aVar) {
35740: 
35746:     case NPNVSupportsWindowless:
36011: #if defined(OS_LINUX) || defined(OS_WIN)
35951:         *((NPBool*)aValue) = true;
35951: #else
35747:         *((NPBool*)aValue) = false;
35951: #endif
35746:         return NPERR_NO_ERROR;
35746: 
35746: #if defined(OS_LINUX)
35740:     case NPNVSupportsXEmbedBool:
35747:         *((NPBool*)aValue) = true;
35740:         return NPERR_NO_ERROR;
35740: 
35740:     case NPNVToolkit:
35740:         *((NPNToolkitType*)aValue) = NPNVGtk2;
35740:         return NPERR_NO_ERROR;
35740: 
35746: #elif defined(OS_WIN)
35746:     case NPNVToolkit:
35746:         return NPERR_GENERIC_ERROR;
35746: #endif
35923:     case NPNVjavascriptEnabledBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVjavascriptEnabledBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
35923:     case NPNVisOfflineBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVisOfflineBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
35923:     case NPNVprivateModeBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVprivateModeBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
35965:     case NPNVWindowNPObject: {
35965:         PPluginScriptableObjectChild* actor;
35965:         NPError result;
35965:         if (!CallNPN_GetValue_NPNVWindowNPObject(&actor, &result)) {
35965:             NS_WARNING("Failed to send message!");
35965:             return NPERR_GENERIC_ERROR;
35965:         }
35965: 
35965:         if (result != NPERR_NO_ERROR) {
35965:             return result;
35965:         }
35965: 
36073:         NS_ASSERTION(actor, "Null actor!");
36073: 
35965:         NPObject* object =
37311:             static_cast<PluginScriptableObjectChild*>(actor)->GetObject(true);
35965:         NS_ASSERTION(object, "Null object?!");
35965: 
35965:         PluginModuleChild::sBrowserFuncs.retainobject(object);
35965:         *((NPObject**)aValue) = object;
35965:         return NPERR_NO_ERROR;
35965:     }
35965: 
35965:     case NPNVPluginElementNPObject: {
35965:         PPluginScriptableObjectChild* actor;
35965:         NPError result;
35965:         if (!CallNPN_GetValue_NPNVPluginElementNPObject(&actor, &result)) {
35965:             NS_WARNING("Failed to send message!");
35965:             return NPERR_GENERIC_ERROR;
35965:         }
35965: 
35965:         if (result != NPERR_NO_ERROR) {
35965:             return result;
35965:         }
35965: 
36073:         NS_ASSERTION(actor, "Null actor!");
36073: 
35965:         NPObject* object =
37311:             static_cast<PluginScriptableObjectChild*>(actor)->GetObject(true);
35965:         NS_ASSERTION(object, "Null object?!");
35965: 
35965:         PluginModuleChild::sBrowserFuncs.retainobject(object);
35965:         *((NPObject**)aValue) = object;
35965:         return NPERR_NO_ERROR;
35965:     }
35965: 
37168:     case NPNVnetscapeWindow: {
37168: #ifdef XP_WIN
37168:         if (mWindow.type == NPWindowTypeDrawable) {
37168:             HWND hwnd = NULL;
37168:             NPError result;
37308:             if (!CallNPN_GetValue_NPNVnetscapeWindow(&hwnd, &result)) {
37168:                 return NPERR_GENERIC_ERROR;
37168:             }
37168:             *static_cast<HWND*>(aValue) = hwnd;
37168:             return result;
37168:         }
37168:         else {
37168:             *static_cast<HWND*>(aValue) = mPluginWindowHWND;
37168:             return NPERR_NO_ERROR;
37168:         }
37308: #elif defined(MOZ_X11)
37308:         NPError result;
37308:         CallNPN_GetValue_NPNVnetscapeWindow(static_cast<XID*>(aValue), &result);
37308:         return result;
37168: #else
37168:         return NPERR_GENERIC_ERROR;
37168: #endif
37168:     }
37168: 
35740:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceChild::NPN_GetValue: Unhandled NPNVariable %i (%s)",
37099:                 (int) aVar, NPNVariableToString(aVar)));
35740:         return NPERR_GENERIC_ERROR;
35740:     }
35740: 
35740: }
35740: 
35951: 
35951: NPError
35951: PluginInstanceChild::NPN_SetValue(NPPVariable aVar, void* aValue)
35951: {
37099:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s (aVar=%i, aValue=%p)",
37099:                                       FULLFUNCTION, (int) aVar, aValue));
37099: 
35971:     AssertPluginThread();
35951: 
35951:     switch (aVar) {
35951:     case NPPVpluginWindowBool: {
35951:         NPError rv;
35951:         bool windowed = (NPBool) (intptr_t) aValue;
35951: 
35951:         if (!CallNPN_SetValue_NPPVpluginWindow(windowed, &rv))
35951:             return NPERR_GENERIC_ERROR;
35951: 
35951:         return rv;
35951:     }
35951: 
35951:     case NPPVpluginTransparentBool: {
35951:         NPError rv;
35951:         bool transparent = (NPBool) (intptr_t) aValue;
35951: 
35951:         if (!CallNPN_SetValue_NPPVpluginTransparent(transparent, &rv))
35951:             return NPERR_GENERIC_ERROR;
35951: 
35951:         return rv;
35951:     }
35951: 
35951:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceChild::NPN_SetValue: Unhandled NPPVariable %i (%s)",
37099:                 (int) aVar, NPPVariableToString(aVar)));
35951:         return NPERR_GENERIC_ERROR;
35951:     }
35951: }
35951: 
35951: 
35951: bool
35951: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginWindow(
35951:     bool* windowed, NPError* rv)
35951: {
35971:     AssertPluginThread();
35971: 
35951:     NPBool isWindowed;
35951:     *rv = mPluginIface->getvalue(GetNPP(), NPPVpluginWindowBool,
35951:                                  reinterpret_cast<void*>(&isWindowed));
35951:     *windowed = isWindowed;
35951:     return true;
35951: }
35951: 
35951: bool
35951: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginTransparent(
35951:     bool* transparent, NPError* rv)
35951: {
35971:     AssertPluginThread();
35971: 
35951:     NPBool isTransparent;
35951:     *rv = mPluginIface->getvalue(GetNPP(), NPPVpluginTransparentBool,
35951:                                  reinterpret_cast<void*>(&isTransparent));
35951:     *transparent = isTransparent;
35951:     return true;
35951: }
35951: 
35951: bool
35951: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginNeedsXEmbed(
35951:     bool* needs, NPError* rv)
35951: {
35971:     AssertPluginThread();
35971: 
35951: #ifdef OS_LINUX
35951: 
36324:     // on x86/32-bit, flash stores to this using |movl 0x1,&needsXEmbed|.
36324:     // thus we can't NPBool for needsXEmbed, or the three bytes above
36324:     // it on the stack would get clobbered. so protect with unsigned
36324:     // long.
36324:     unsigned long needsXEmbed = 0;
35951:     *rv = mPluginIface->getvalue(GetNPP(), NPPVpluginNeedsXEmbed,
35951:                                  reinterpret_cast<void*>(&needsXEmbed));
35951:     *needs = needsXEmbed;
35951:     return true;
35951: 
35951: #else
35951: 
35951:     NS_RUNTIMEABORT("shouldn't be called on non-linux platforms");
35952:     return false;               // not reached
35951: 
35951: #endif
35951: }
35951: 
35926: bool
35925: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginScriptableNPObject(
36078:                                           PPluginScriptableObjectChild** aValue,
36078:                                           NPError* aResult)
35746: {
35971:     AssertPluginThread();
35925: 
35925:     NPObject* object;
36078:     NPError result = mPluginIface->getvalue(GetNPP(),
36078:                                             NPPVpluginScriptableNPObject,
35925:                                             &object);
36078:     if (result == NPERR_NO_ERROR && object) {
36078:         PluginScriptableObjectChild* actor = GetActorForNPObject(object);
36078: 
36078:         // If we get an actor then it has retained. Otherwise we don't need it
36078:         // any longer.
36078:         PluginModuleChild::sBrowserFuncs.releaseobject(object);
36078:         if (actor) {
36078:             *aValue = actor;
36078:             *aResult = NPERR_NO_ERROR;
35926:             return true;
35925:         }
35925: 
36078:         NS_ERROR("Failed to get actor!");
36078:         result = NPERR_GENERIC_ERROR;
35925:     }
35925: 
36078:     *aValue = nsnull;
36078:     *aResult = result;
35926:     return true;
35746: }
35746: 
35926: bool
37350: PluginInstanceChild::AnswerNPP_SetValue_NPNVprivateModeBool(const bool& value,
37350:                                                             NPError* result)
37350: {
37885:     if (!mPluginIface->setvalue) {
37885:         *result = NPERR_GENERIC_ERROR;
37885:         return true;
37885:     }
37885: 
37350:     // Use `long` instead of NPBool because Flash and other plugins read
37350:     // this as a word-size value instead of the 1-byte NPBool that it is.
37350:     long v = value;
37350:     *result = mPluginIface->setvalue(GetNPP(), NPNVprivateModeBool, &v);
37350:     return true;
37350: }
37350: 
37350: bool
36011: PluginInstanceChild::AnswerNPP_HandleEvent(const NPRemoteEvent& event,
35933:                                            int16_t* handled)
35933: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35951: 
36014: #if defined(OS_LINUX) && defined(DEBUG)
36014:     if (GraphicsExpose == event.event.type)
35951:         printf("  received drawable 0x%lx\n",
36014:                event.event.xgraphicsexpose.drawable);
35951: #endif
35951: 
36124:     // Make a copy since we may modify values.
36011:     NPEvent evcopy = event.event;
36124: 
36124: #ifdef OS_WIN
36270:     // Painting for win32. SharedSurfacePaint handles everything.
36270:     if (mWindow.type == NPWindowTypeDrawable) {
36270:        if (evcopy.event == WM_PAINT) {
36270:           *handled = SharedSurfacePaint(evcopy);
36270:           return true;
36270:        }
36270:        else if (evcopy.event == mAlphaExtract.doublePassEvent) {
36270:             // We'll render to mSharedSurfaceDib first, then render to a cached bitmap
36270:             // we store locally. The two passes are for alpha extraction, so the second
36270:             // pass must be to a flat white surface in order for things to work.
36270:             mAlphaExtract.doublePass = RENDER_BACK_ONE;
36270:             *handled = true;
36270:             return true;
36270:        }
36270:     }
36124: #endif
36124: 
35933:     *handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
35980: 
35980: #ifdef MOZ_X11
36013:     if (GraphicsExpose == event.event.type) {
35980:         // Make sure the X server completes the drawing before the parent
35980:         // draws on top and destroys the Drawable.
35980:         //
35980:         // XSync() waits for the X server to complete.  Really this child
35980:         // process does not need to wait; the parent is the process that needs
35980:         // to wait.  A possibly-slightly-better alternative would be to send
35980:         // an X event to the parent that the parent would wait for.
35980:         XSync(mWsInfo.display, False);
35980:     }
35980: #endif
35980: 
35933:     return true;
35933: }
35933: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957: static bool
35957: XVisualIDToInfo(Display* aDisplay, VisualID aVisualID,
35957:                 Visual** aVisual, unsigned int* aDepth)
35957: {
35957:     if (aVisualID == None) {
35957:         *aVisual = NULL;
35957:         *aDepth = 0;
35957:         return true;
35957:     }
35957: 
35957:     const Screen* screen = DefaultScreenOfDisplay(aDisplay);
35957: 
35957:     for (int d = 0; d < screen->ndepths; d++) {
35957:         Depth *d_info = &screen->depths[d];
35957:         for (int v = 0; v < d_info->nvisuals; v++) {
35957:             Visual* visual = &d_info->visuals[v];
35957:             if (visual->visualid == aVisualID) {
35957:                 *aVisual = visual;
35957:                 *aDepth = d_info->depth;
35957:                 return true;
35957:             }
35957:         }
35957:     }
35957: 
35957:     NS_ERROR("VisualID not on Screen.");
35957:     return false;
35957: }
35957: #endif
35957: 
35933: bool
35957: PluginInstanceChild::AnswerNPP_SetWindow(const NPRemoteWindow& aWindow,
35893:                                          NPError* rv)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aWindow=<window: 0x%lx, x: %d, y: %d, width: %d, height: %d>)",
37099:                       FULLFUNCTION,
35957:                       aWindow.window,
35954:                       aWindow.x, aWindow.y,
37099:                       aWindow.width, aWindow.height));
35971:     AssertPluginThread();
35740: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:     // The minimum info is sent over IPC to allow this
35957:     // code to determine the rest.
35740: 
35957:     mWindow.window = reinterpret_cast<void*>(aWindow.window);
35957:     mWindow.x = aWindow.x;
35957:     mWindow.y = aWindow.y;
35957:     mWindow.width = aWindow.width;
35957:     mWindow.height = aWindow.height;
35957:     mWindow.clipRect = aWindow.clipRect;
35957:     mWindow.type = aWindow.type;
35740: 
35957:     mWsInfo.colormap = aWindow.colormap;
35957:     if (!XVisualIDToInfo(mWsInfo.display, aWindow.visualID,
35957:                          &mWsInfo.visual, &mWsInfo.depth))
35957:         return false;
35740: 
37347:     if (aWindow.type == NPWindowTypeWindow) {
37621: #ifdef MOZ_WIDGET_GTK2
37347:         if (GdkWindow* socket_window = gdk_window_lookup(aWindow.window)) {
37347:             // A GdkWindow for the socket already exists.  Need to
37347:             // workaround https://bugzilla.gnome.org/show_bug.cgi?id=607061
37347:             // See wrap_gtk_plug_embedded in PluginModuleChild.cpp.
37347:             g_object_set_data(G_OBJECT(socket_window),
37347:                               "moz-existed-before-set-window",
37347:                               GUINT_TO_POINTER(1));
37347:         }
37621: #endif
37347:     }
37347: 
35747:     *rv = mPluginIface->setwindow(&mData, &mWindow);
35747: 
35746: #elif defined(OS_WIN)
36124:     switch (aWindow.type) {
36124:       case NPWindowTypeWindow:
36124:       {
36124:           if (!CreatePluginWindow())
36124:               return false;
36124: 
35747:           ReparentPluginWindow((HWND)aWindow.window);
35747:           SizePluginWindow(aWindow.width, aWindow.height);
35747: 
35747:           mWindow.window = (void*)mPluginWindowHWND;
35954:           mWindow.x = aWindow.x;
35954:           mWindow.y = aWindow.y;
35746:           mWindow.width = aWindow.width;
35746:           mWindow.height = aWindow.height;
36011:           mWindow.type = aWindow.type;
35740: 
35747:           *rv = mPluginIface->setwindow(&mData, &mWindow);
35747:           if (*rv == NPERR_NO_ERROR) {
35747:               WNDPROC wndProc = reinterpret_cast<WNDPROC>(
35747:                   GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
35747:               if (wndProc != PluginWindowProc) {
35747:                   mPluginWndProc = reinterpret_cast<WNDPROC>(
35747:                       SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
35747:                                        reinterpret_cast<LONG>(PluginWindowProc)));
35747:               }
35747:           }
36124:       }
36124:       break;
36124: 
36124:       case NPWindowTypeDrawable:
36124:           return SharedSurfaceSetWindow(aWindow, rv);
36124:       break;
36124: 
36124:       default:
36124:           NS_NOTREACHED("Bad plugin window type.");
36124:           return false;
36124:       break;
36124:     }
35747: 
36069: #elif defined(OS_MACOSX)
36069: #  warning This is only a stub implementation IMPLEMENT ME
36069: 
35740: #else
35740: #  error Implement me for your OS
35740: #endif
35746: 
35926:     return true;
35740: }
35740: 
35747: bool
35893: PluginInstanceChild::Initialize()
35747: {
35747:     return true;
35747: }
35747: 
35747: #if defined(OS_WIN)
35747: 
35747: static const TCHAR kWindowClassName[] = TEXT("GeckoPluginWindow");
35893: static const TCHAR kPluginInstanceChildProperty[] = TEXT("PluginInstanceChildProperty");
35747: 
35747: // static
35747: bool
35893: PluginInstanceChild::RegisterWindowClass()
35747: {
35747:     static bool alreadyRegistered = false;
35747:     if (alreadyRegistered)
35747:         return true;
35747: 
35747:     alreadyRegistered = true;
35747: 
35747:     WNDCLASSEX wcex;
35747:     wcex.cbSize         = sizeof(WNDCLASSEX);
35747:     wcex.style          = CS_DBLCLKS;
35747:     wcex.lpfnWndProc    = DummyWindowProc;
35747:     wcex.cbClsExtra     = 0;
35747:     wcex.cbWndExtra     = 0;
35747:     wcex.hInstance      = GetModuleHandle(NULL);
35747:     wcex.hIcon          = 0;
35747:     wcex.hCursor        = 0;
35748:     wcex.hbrBackground  = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
35747:     wcex.lpszMenuName   = 0;
35747:     wcex.lpszClassName  = kWindowClassName;
35747:     wcex.hIconSm        = 0;
35747: 
35747:     return RegisterClassEx(&wcex) ? true : false;
35747: }
35747: 
35747: bool
35893: PluginInstanceChild::CreatePluginWindow()
35747: {
36124:     // already initialized
36124:     if (mPluginWindowHWND)
36124:         return true;
36124:         
35747:     if (!RegisterWindowClass())
35747:         return false;
35747: 
35747:     mPluginWindowHWND =
35747:         CreateWindowEx(WS_EX_LEFT | WS_EX_LTRREADING |
35747:                        WS_EX_NOPARENTNOTIFY | // XXXbent Get rid of this!
35747:                        WS_EX_RIGHTSCROLLBAR,
35747:                        kWindowClassName, 0,
35747:                        WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0, 0,
35747:                        0, 0, NULL, 0, GetModuleHandle(NULL), 0);
35747:     if (!mPluginWindowHWND)
35747:         return false;
35893:     if (!SetProp(mPluginWindowHWND, kPluginInstanceChildProperty, this))
35747:         return false;
35747: 
35747:     // Apparently some plugins require an ASCII WndProc.
35747:     SetWindowLongPtrA(mPluginWindowHWND, GWLP_WNDPROC,
35747:                       reinterpret_cast<LONG>(DefWindowProcA));
35747: 
35747:     return true;
35747: }
35747: 
35747: void
35893: PluginInstanceChild::DestroyPluginWindow()
35747: {
35747:     if (mPluginWindowHWND) {
35747:         // Unsubclass the window.
35747:         WNDPROC wndProc = reinterpret_cast<WNDPROC>(
35747:             GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
35747:         if (wndProc == PluginWindowProc) {
35747:             NS_ASSERTION(mPluginWndProc, "Should have old proc here!");
35747:             SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
35747:                              reinterpret_cast<LONG>(mPluginWndProc));
35747:             mPluginWndProc = 0;
35747:         }
35747: 
35893:         RemoveProp(mPluginWindowHWND, kPluginInstanceChildProperty);
35747:         DestroyWindow(mPluginWindowHWND);
35747:         mPluginWindowHWND = 0;
35747:     }
35747: }
35747: 
35747: void
35893: PluginInstanceChild::ReparentPluginWindow(HWND hWndParent)
35747: {
35747:     if (hWndParent != mPluginParentHWND && IsWindow(hWndParent)) {
36082:         // Fix the child window's style to be a child window.
35747:         LONG style = GetWindowLongPtr(mPluginWindowHWND, GWL_STYLE);
35747:         style |= WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
36082:         style &= ~WS_POPUP;
35747:         SetWindowLongPtr(mPluginWindowHWND, GWL_STYLE, style);
36082: 
36082:         // Do the reparenting.
35747:         SetParent(mPluginWindowHWND, hWndParent);
36082: 
36082:         // Make sure we're visible.
35747:         ShowWindow(mPluginWindowHWND, SW_SHOWNA);
35747:     }
35747:     mPluginParentHWND = hWndParent;
35747: }
35747: 
35747: void
35893: PluginInstanceChild::SizePluginWindow(int width,
35747:                                       int height)
35747: {
35747:     if (mPluginWindowHWND) {
35747:         SetWindowPos(mPluginWindowHWND, NULL, 0, 0, width, height,
35747:                      SWP_NOZORDER | SWP_NOREPOSITION);
35747:     }
35747: }
35747: 
35747: // See chromium's webplugin_delegate_impl.cc for explanation of this function.
35747: // static
35747: LRESULT CALLBACK
35893: PluginInstanceChild::DummyWindowProc(HWND hWnd,
35747:                                      UINT message,
35747:                                      WPARAM wParam,
35747:                                      LPARAM lParam)
35747: {
35747:     return CallWindowProc(DefWindowProc, hWnd, message, wParam, lParam);
35747: }
35747: 
35747: // static
35747: LRESULT CALLBACK
35893: PluginInstanceChild::PluginWindowProc(HWND hWnd,
35747:                                       UINT message,
35747:                                       WPARAM wParam,
35747:                                       LPARAM lParam)
35747: {
36056:     NS_ASSERTION(!mozilla::ipc::SyncChannel::IsPumpingMessages(),
36056:                  "Failed to prevent a nonqueued message from running!");
36056: 
35893:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
35893:         GetProp(hWnd, kPluginInstanceChildProperty));
35747:     if (!self) {
35747:         NS_NOTREACHED("Badness!");
35747:         return 0;
35747:     }
35747: 
35747:     NS_ASSERTION(self->mPluginWindowHWND == hWnd, "Wrong window!");
35747: 
37550:     // The plugin received keyboard focus, let the parent know so the dom is up to date.
37550:     if (message == WM_MOUSEACTIVATE)
37550:         self->CallPluginGotFocus();
37550: 
37551:     // Prevent lockups due to plugins making rpc calls when the parent
37551:     // is making a synchronous SetFocus api call. (bug 541362) Add more
37551:     // windowing events as needed for other api.
37551:     if (message == WM_KILLFOCUS && 
37551:         ((InSendMessageEx(NULL) & (ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND)) {
37551:         ReplyMessage(0); // Unblock the caller
37551:     }
37551: 
35747:     LRESULT res = CallWindowProc(self->mPluginWndProc, hWnd, message, wParam,
35747:                                  lParam);
35747: 
35747:     if (message == WM_CLOSE)
35747:         self->DestroyPluginWindow();
35747: 
35747:     if (message == WM_NCDESTROY)
35893:         RemoveProp(hWnd, kPluginInstanceChildProperty);
35747: 
35747:     return res;
35747: }
35747: 
36124: /* windowless drawing helpers */
36124: 
36124: bool
36124: PluginInstanceChild::SharedSurfaceSetWindow(const NPRemoteWindow& aWindow,
36124:                                             NPError* rv)
36124: {
36124:     // If the surfaceHandle is empty, parent is telling us we can reuse our cached
36124:     // memory surface and hdc. Otherwise, we need to reset, usually due to a
36124:     // expanding plugin port size.
36124:     if (!aWindow.surfaceHandle) {
36124:         if (!mSharedSurfaceDib.IsValid()) {
36124:             return false;
36124:         }
36124:     }
36124:     else {
36124:         // Attach to the new shared surface parent handed us.
36124:         if (NS_FAILED(mSharedSurfaceDib.Attach((SharedDIB::Handle)aWindow.surfaceHandle,
36124:                                                aWindow.width, aWindow.height, 32)))
36124:           return false;
36270:         // Free any alpha extraction resources if needed. This will be reset
36270:         // the next time it's used.
36270:         AlphaExtractCacheRelease();
36124:     }
36124:       
36124:     // NPRemoteWindow's origin is the origin of our shared dib.
36124:     mWindow.x      = 0;
36124:     mWindow.y      = 0;
36124:     mWindow.width  = aWindow.width;
36124:     mWindow.height = aWindow.height;
36124:     mWindow.type   = aWindow.type;
36124: 
36124:     mWindow.window = reinterpret_cast<void*>(mSharedSurfaceDib.GetHDC());
36124:     *rv = mPluginIface->setwindow(&mData, &mWindow);
36124: 
36124:     return true;
36124: }
36124: 
36124: void
36124: PluginInstanceChild::SharedSurfaceRelease()
36124: {
36124:     mSharedSurfaceDib.Close();
36270:     AlphaExtractCacheRelease();
36270: }
36270: 
36270: /* double pass cache buffer - (rarely) used in cases where alpha extraction
36270:  * occurs for windowless plugins. */
36270:  
36270: bool
36270: PluginInstanceChild::AlphaExtractCacheSetup()
36270: {
36270:     AlphaExtractCacheRelease();
36270: 
36270:     mAlphaExtract.hdc = ::CreateCompatibleDC(NULL);
36270: 
36270:     if (!mAlphaExtract.hdc)
36270:         return false;
36270: 
36270:     BITMAPINFOHEADER bmih;
36270:     memset((void*)&bmih, 0, sizeof(BITMAPINFOHEADER));
36270:     bmih.biSize        = sizeof(BITMAPINFOHEADER);
36270:     bmih.biWidth       = mWindow.width;
36270:     bmih.biHeight      = mWindow.height;
36270:     bmih.biPlanes      = 1;
36270:     bmih.biBitCount    = 32;
36270:     bmih.biCompression = BI_RGB;
36270: 
36270:     void* ppvBits = nsnull;
36270:     mAlphaExtract.bmp = ::CreateDIBSection(mAlphaExtract.hdc,
36270:                                            (BITMAPINFO*)&bmih,
36270:                                            DIB_RGB_COLORS,
36270:                                            (void**)&ppvBits,
36270:                                            NULL,
36270:                                            (unsigned long)sizeof(BITMAPINFOHEADER));
36270:     if (!mAlphaExtract.bmp)
36270:       return false;
36270: 
36270:     DeleteObject(::SelectObject(mAlphaExtract.hdc, mAlphaExtract.bmp));
36270:     return true;
36124: }
36124: 
36124: void
36270: PluginInstanceChild::AlphaExtractCacheRelease()
36124: {
36270:     if (mAlphaExtract.bmp)
36270:         ::DeleteObject(mAlphaExtract.bmp);
36270: 
36270:     if (mAlphaExtract.hdc)
36270:         ::DeleteObject(mAlphaExtract.hdc);
36270: 
36270:     mAlphaExtract.bmp = NULL;
36270:     mAlphaExtract.hdc = NULL;
36270: }
36270: 
36270: void
36270: PluginInstanceChild::UpdatePaintClipRect(RECT* aRect)
36270: {
36270:     if (aRect) {
36124:         // Update the clip rect on our internal hdc
36270:         HRGN clip = ::CreateRectRgnIndirect(aRect);
36124:         ::SelectClipRgn(mSharedSurfaceDib.GetHDC(), clip);
36124:         ::DeleteObject(clip);
36124:     }
36270: }
36270: 
36270: int16_t
36270: PluginInstanceChild::SharedSurfacePaint(NPEvent& evcopy)
36270: {
36270:     RECT* pRect = reinterpret_cast<RECT*>(evcopy.lParam);
36270: 
36270:     switch(mAlphaExtract.doublePass) {
36270:         case RENDER_NATIVE:
36124:             // pass the internal hdc to the plugin
36270:             UpdatePaintClipRect(pRect);
36124:             evcopy.wParam = WPARAM(mSharedSurfaceDib.GetHDC());
36270:             return mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
36270:         break;
36270:         case RENDER_BACK_ONE:
36270:               // Handle a double pass render used in alpha extraction for transparent
36270:               // plugins. (See nsObjectFrame and gfxWindowsNativeDrawing for details.)
36270:               // We render twice, once to the shared dib, and once to a cache which
36270:               // we copy back on a second paint. These paints can't be spread across
36270:               // multiple rpc messages as delays cause animation frame changes.
36270:               if (!mAlphaExtract.bmp && !AlphaExtractCacheSetup()) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270: 
36270:               // See gfxWindowsNativeDrawing, color order doesn't have to match.
36270:               ::FillRect(mSharedSurfaceDib.GetHDC(), pRect, (HBRUSH)GetStockObject(WHITE_BRUSH));
36270:               UpdatePaintClipRect(pRect);
36270:               evcopy.wParam = WPARAM(mSharedSurfaceDib.GetHDC());
36270:               if (!mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy))) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270: 
36270:               // Copy to cache. We render to shared dib so we don't have to call
36270:               // setwindow between calls (flash issue).  
36270:               ::BitBlt(mAlphaExtract.hdc,
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        pRect->right - pRect->left,
36270:                        pRect->bottom - pRect->top,
36270:                        mSharedSurfaceDib.GetHDC(),
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        SRCCOPY);
36270: 
36270:               ::FillRect(mSharedSurfaceDib.GetHDC(), pRect, (HBRUSH)GetStockObject(BLACK_BRUSH));
36270:               if (!mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy))) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270:               mAlphaExtract.doublePass = RENDER_BACK_TWO;
36270:               return true;
36270:         break;
36270:         case RENDER_BACK_TWO:
36270:               // copy our cached surface back
36270:               ::BitBlt(mSharedSurfaceDib.GetHDC(),
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        pRect->right - pRect->left,
36270:                        pRect->bottom - pRect->top,
36270:                        mAlphaExtract.hdc,
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        SRCCOPY);
36270:               mAlphaExtract.doublePass = RENDER_NATIVE;
36270:               return true;
36270:         break;
36270:     }
36270:     return false;
36124: }
36124: 
35747: #endif // OS_WIN
35747: 
37550: bool
37550: PluginInstanceChild::AnswerSetPluginFocus()
37550: {
37550:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s", FULLFUNCTION));
37550: 
37550: #if defined(OS_WIN)
37550:     // Parent is letting us know something set focus to the plugin.
37550:     if (::GetFocus() == mPluginWindowHWND)
37550:         return true;
37550:     ::SetFocus(mPluginWindowHWND);
37550:     return true;
37550: #else
37550:     NS_NOTREACHED("PluginInstanceChild::AnswerSetPluginFocus not implemented!");
37550:     return false;
37550: #endif
37550: }
37550: 
37554: bool
37554: PluginInstanceChild::AnswerUpdateWindow()
37554: {
37554:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s", FULLFUNCTION));
37554: 
37554: #if defined(OS_WIN)
37554:     if (mPluginWindowHWND)
37554:       UpdateWindow(mPluginWindowHWND);
37554:     return true;
37554: #else
37554:     NS_NOTREACHED("PluginInstanceChild::AnswerUpdateWindow not implemented!");
37554:     return false;
37554: #endif
37554: }
37554: 
35898: PPluginScriptableObjectChild*
35943: PluginInstanceChild::AllocPPluginScriptableObject()
35835: {
35971:     AssertPluginThread();
37311:     return new PluginScriptableObjectChild(Proxy);
35835: }
35835: 
35926: bool
35965: PluginInstanceChild::DeallocPPluginScriptableObject(
35965:     PPluginScriptableObjectChild* aObject)
35835: {
35971:     AssertPluginThread();
37477:     delete aObject;
35945:     return true;
35925: }
35890: 
35965: bool
35965: PluginInstanceChild::AnswerPPluginScriptableObjectConstructor(
35965:                                            PPluginScriptableObjectChild* aActor)
35965: {
35971:     AssertPluginThread();
35971: 
35965:     // This is only called in response to the parent process requesting the
35965:     // creation of an actor. This actor will represent an NPObject that is
35965:     // created by the browser and returned to the plugin.
35965:     PluginScriptableObjectChild* actor =
35965:         static_cast<PluginScriptableObjectChild*>(aActor);
37311:     NS_ASSERTION(!actor->GetObject(false), "Actor already has an object?!");
37311: 
37311:     actor->InitializeProxy();
37311:     NS_ASSERTION(actor->GetObject(false), "Actor should have an object!");
35965: 
35965:     return true;
35965: }
35965: 
37126: bool
37126: PluginInstanceChild::AnswerPBrowserStreamConstructor(
37126:     PBrowserStreamChild* aActor,
37126:     const nsCString& url,
37126:     const uint32_t& length,
37126:     const uint32_t& lastmodified,
37126:     PStreamNotifyChild* notifyData,
37126:     const nsCString& headers,
37126:     const nsCString& mimeType,
37126:     const bool& seekable,
37126:     NPError* rv,
37126:     uint16_t* stype)
37126: {
37126:     AssertPluginThread();
37126:     *rv = static_cast<BrowserStreamChild*>(aActor)
37126:           ->StreamConstructed(url, length, lastmodified,
37126:                               notifyData, headers, mimeType, seekable,
37126:                               stype);
37126:     return true;
37126: }
37126: 
35898: PBrowserStreamChild*
35943: PluginInstanceChild::AllocPBrowserStream(const nsCString& url,
35893:                                          const uint32_t& length,
35890:                                          const uint32_t& lastmodified,
35990:                                          PStreamNotifyChild* notifyData,
35890:                                          const nsCString& headers,
35890:                                          const nsCString& mimeType,
35890:                                          const bool& seekable,
35893:                                          NPError* rv,
35893:                                          uint16_t *stype)
35890: {
35971:     AssertPluginThread();
35949:     return new BrowserStreamChild(this, url, length, lastmodified, notifyData,
35949:                                   headers, mimeType, seekable, rv, stype);
35890: }
35890: 
35926: bool
36138: PluginInstanceChild::DeallocPBrowserStream(PBrowserStreamChild* stream)
35890: {
35971:     AssertPluginThread();
35890:     delete stream;
35926:     return true;
35890: }
35890: 
35938: PPluginStreamChild*
35943: PluginInstanceChild::AllocPPluginStream(const nsCString& mimeType,
35938:                                         const nsCString& target,
35938:                                         NPError* result)
35938: {
35938:     NS_RUNTIMEABORT("not callable");
35938:     return NULL;
35938: }
35938: 
35938: bool
36138: PluginInstanceChild::DeallocPPluginStream(PPluginStreamChild* stream)
35938: {
35971:     AssertPluginThread();
35938:     delete stream;
35938:     return true;
35938: }
35938: 
35904: PStreamNotifyChild*
35943: PluginInstanceChild::AllocPStreamNotify(const nsCString& url,
35904:                                         const nsCString& target,
35904:                                         const bool& post,
35904:                                         const nsCString& buffer,
35904:                                         const bool& file,
35904:                                         NPError* result)
35904: {
35971:     AssertPluginThread();
35904:     NS_RUNTIMEABORT("not reached");
35904:     return NULL;
35904: }
35904: 
35926: bool
36138: StreamNotifyChild::Answer__delete__(const NPReason& reason)
35904: {
35971:     AssertPluginThread();
36138:     return static_cast<PluginInstanceChild*>(Manager())
36138:         ->NotifyStream(this, reason);
36138: }
35971: 
36138: bool
36138: PluginInstanceChild::NotifyStream(StreamNotifyChild* notifyData,
36138:                                   NPReason reason)
36138: {
36138:     if (notifyData->mClosure)
36138:         mPluginIface->urlnotify(&mData, notifyData->mURL.get(), reason,
36138:                                 notifyData->mClosure);
35926:     return true;
35904: }
35904: 
36110: bool
36138: PluginInstanceChild::DeallocPStreamNotify(PStreamNotifyChild* notifyData)
36110: {
36138:     AssertPluginThread();
36110:     delete notifyData;
36110:     return true;
36110: }
36110: 
35925: PluginScriptableObjectChild*
35945: PluginInstanceChild::GetActorForNPObject(NPObject* aObject)
35925: {
35971:     AssertPluginThread();
35925:     NS_ASSERTION(aObject, "Null pointer!");
35925: 
35965:     if (aObject->_class == PluginScriptableObjectChild::GetClass()) {
35965:         // One of ours! It's a browser-provided object.
35965:         ChildNPObject* object = static_cast<ChildNPObject*>(aObject);
35965:         NS_ASSERTION(object->parent, "Null actor!");
35965:         return object->parent;
35965:     }
35945: 
35925:     PluginScriptableObjectChild* actor =
35945:         PluginModuleChild::current()->GetActorForNPObject(aObject);
35945:     if (actor) {
35965:         // Plugin-provided object that we've previously wrapped.
35945:         return actor;
35945:     }
35945: 
37311:     actor = new PluginScriptableObjectChild(LocalObject);
37311:     if (!CallPPluginScriptableObjectConstructor(actor)) {
37311:         NS_ERROR("Failed to send constructor message!");
37311:         return nsnull;
37311:     }
35925: 
37311:     actor->InitializeLocal(aObject);
35925:     return actor;
35925: }
35938: 
35938: NPError
35938: PluginInstanceChild::NPN_NewStream(NPMIMEType aMIMEType, const char* aWindow,
35938:                                    NPStream** aStream)
35938: {
35971:     AssertPluginThread();
35971: 
36138:     PluginStreamChild* ps = new PluginStreamChild();
35938: 
35938:     NPError result;
35938:     CallPPluginStreamConstructor(ps, nsDependentCString(aMIMEType),
35944:                                  NullableString(aWindow), &result);
35938:     if (NPERR_NO_ERROR != result) {
35938:         *aStream = NULL;
36138:         PPluginStreamChild::Call__delete__(ps, NPERR_GENERIC_ERROR, true);
35938:         return result;
35938:     }
35938: 
35938:     *aStream = &ps->mStream;
35938:     return NPERR_NO_ERROR;
35938: }
36082: 
36835: void
36835: PluginInstanceChild::InvalidateRect(NPRect* aInvalidRect)
36082: {
36082:     NS_ASSERTION(aInvalidRect, "Null pointer!");
36082: 
36082: #ifdef OS_WIN
36124:     // Invalidate and draw locally for windowed plugins.
36124:     if (mWindow.type == NPWindowTypeWindow) {
36082:       NS_ASSERTION(IsWindow(mPluginWindowHWND), "Bad window?!");
36082:       RECT rect = { aInvalidRect->left, aInvalidRect->top,
36082:                     aInvalidRect->right, aInvalidRect->bottom };
36836:       ::InvalidateRect(mPluginWindowHWND, &rect, FALSE);
36835:       return;
36124:     }
36082: #endif
36083: 
36835:     SendNPN_InvalidateRect(*aInvalidRect);
36082: }
37311: 
37348: uint32_t
37348: PluginInstanceChild::ScheduleTimer(uint32_t interval, bool repeat,
37348:                                    TimerFunc func)
37348: {
37348:     ChildTimer* t = new ChildTimer(this, interval, repeat, func);
37348:     if (0 == t->ID()) {
37348:         delete t;
37348:         return 0;
37348:     }
37348: 
37348:     mTimers.AppendElement(t);
37348:     return t->ID();
37348: }
37348: 
37348: void
37348: PluginInstanceChild::UnscheduleTimer(uint32_t id)
37348: {
37348:     if (0 == id)
37348:         return;
37348: 
37884:     mTimers.RemoveElement(id, ChildTimer::IDComparator());
37348: }
37348: 
37311: bool
37311: PluginInstanceChild::AnswerNPP_Destroy(NPError* aResult)
37311: {
37348:     for (PRUint32 i = 0; i < mPendingAsyncCalls.Length(); ++i)
37348:         mPendingAsyncCalls[i]->Cancel();
37348:     mPendingAsyncCalls.TruncateLength(0);
37348: 
37884:     mTimers.Clear();
37348: 
37311:     PluginModuleChild* module = PluginModuleChild::current();
37311:     bool retval = module->PluginInstanceDestroyed(this, aResult);
37311: 
37311: #if defined(OS_WIN)
37311:     SharedSurfaceRelease();
37311: #endif
37311: 
37311:     return retval;
37311: }
