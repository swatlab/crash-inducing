 47525: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 47525:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
 47525:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 47525: 
 47574: #include "CrossOriginWrapper.h"
 47574: #include "FilteringWrapper.h"
 47574: #include "XrayWrapper.h"
 47525: #include "AccessCheck.h"
 55628: #include "XPCWrapper.h"
 47525: 
 47574: #include "xpcprivate.h"
 80072: #include "dombindings.h"
 80384: #include "XPCMaps.h"
 97422: #include "mozilla/dom/BindingUtils.h"
 87284: #include "jsfriendapi.h"
 99716: #include "mozilla/Likely.h"
 86985: 
 79386: using namespace js;
 79386: 
 47525: namespace xpc {
 47525: 
 47574: // When chrome pulls a naked property across the membrane using
 47574: // .wrappedJSObject, we want it to cross the membrane into the
 47574: // chrome compartment without automatically being wrapped into an
 47574: // X-ray wrapper. We achieve this by wrapping it into a special
 47574: // transparent wrapper in the origin (non-chrome) compartment. When
 47574: // an object with that special wrapper applied crosses into chrome,
 47574: // we know to not apply an X-ray wrapper.
103121: DirectWrapper WaiveXrayWrapperWrapper(WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG);
 47574: 
 47574: // When objects for which we waived the X-ray wrapper cross into
 47574: // chrome, we wrap them into a special cross-compartment wrapper
 47574: // that transitively extends the waiver to all properties we get
 47574: // off it.
 55691: CrossOriginWrapper CrossOriginWrapper::singleton(0);
 55691: 
 55691: static JSObject *
 56105: GetCurrentOuter(JSContext *cx, JSObject *obj)
 56105: {
 79734:     obj = JS_ObjectToOuterObject(cx, obj);
 94341:     if (!obj)
 94341:         return nsnull;
 94341: 
 79734:     if (IsWrapper(obj) && !js::GetObjectClass(obj)->ext.innerObject) {
 79734:         obj = UnwrapObject(obj);
 79734:         NS_ASSERTION(js::GetObjectClass(obj)->ext.innerObject,
 56105:                      "weird object, expecting an outer window proxy");
 56105:     }
 56105: 
 56105:     return obj;
 56105: }
 56105: 
 47574: JSObject *
104795: WrapperFactory::GetXrayWaiver(JSObject *obj)
104795: {
104795:     // Object should come fully unwrapped but outerized.
104795:     MOZ_ASSERT(obj == UnwrapObject(obj));
104795:     MOZ_ASSERT(!js::GetObjectClass(obj)->ext.outerObject);
104795:     CompartmentPrivate *priv = GetCompartmentPrivate(obj);
104795:     MOZ_ASSERT(priv);
104795: 
104795:     if (!priv->waiverWrapperMap)
104795:         return NULL;
104795:     return xpc_UnmarkGrayObject(priv->waiverWrapperMap->Find(obj));
104795: }
104795: 
104795: JSObject *
104795: WrapperFactory::CreateXrayWaiver(JSContext *cx, JSObject *obj)
104795: {
104795:     // The caller is required to have already done a lookup.
104795:     // NB: This implictly performs the assertions of GetXrayWaiver.
104795:     MOZ_ASSERT(!GetXrayWaiver(obj));
104795:     CompartmentPrivate *priv = GetCompartmentPrivate(obj);
104795: 
104795:     // Get a waiver for the proto.
104795:     JSObject *proto = js::GetObjectProto(obj);
104795:     if (proto && !(proto = WaiveXray(cx, proto)))
104795:         return nsnull;
104795: 
104795:     // Create the waiver.
104795:     JSAutoEnterCompartment ac;
104795:     if (!ac.enter(cx, obj) || !JS_WrapObject(cx, &proto))
104795:         return nsnull;
104795:     JSObject *waiver = Wrapper::New(cx, obj, proto,
104795:                                     JS_GetGlobalForObject(cx, obj),
104795:                                     &WaiveXrayWrapperWrapper);
104795:     if (!waiver)
104795:         return nsnull;
104795: 
104795:     // Add the new waiver to the map. It's important that we only ever have
104795:     // one waiver for the lifetime of the target object.
104795:     if (!priv->waiverWrapperMap) {
104795:         priv->waiverWrapperMap = JSObject2JSObjectMap::
104795:                                    newMap(XPC_WRAPPER_MAP_SIZE);
104795:         MOZ_ASSERT(priv->waiverWrapperMap);
104795:     }
104795:     if (!priv->waiverWrapperMap->Add(obj, waiver))
104795:         return nsnull;
104795:     return waiver;
104795: }
104795: 
104795: JSObject *
 60580: WrapperFactory::WaiveXray(JSContext *cx, JSObject *obj)
 60580: {
 79734:     obj = UnwrapObject(obj);
 61061: 
 60580:     // We have to make sure that if we're wrapping an outer window, that
 60580:     // the .wrappedJSObject also wraps the outer window.
 60580:     obj = GetCurrentOuter(cx, obj);
 60580: 
104795:     JSObject *waiver = GetXrayWaiver(obj);
104795:     if (waiver)
104795:         return waiver;
104795:     return CreateXrayWaiver(cx, obj);
 60580: }
 60580: 
 71303: // DoubleWrap is called from PrepareForWrapping to maintain the state that
 71303: // we're supposed to waive Xray wrappers for the given on. On entrance, it
 71303: // expects |cx->compartment != obj->compartment()|. The returned object will
 71303: // be in the same compartment as |obj|.
 60580: JSObject *
 91237: WrapperFactory::DoubleWrap(JSContext *cx, JSObject *obj, unsigned flags)
 60580: {
 60580:     if (flags & WrapperFactory::WAIVE_XRAY_WRAPPER_FLAG) {
 61061:         JSAutoEnterCompartment ac;
 61061:         if (!ac.enter(cx, obj))
 61061:             return nsnull;
 61061: 
 60580:         return WaiveXray(cx, obj);
 60580:     }
 60580:     return obj;
 60580: }
 60580: 
 60580: JSObject *
 91237: WrapperFactory::PrepareForWrapping(JSContext *cx, JSObject *scope, JSObject *obj, unsigned flags)
 55628: {
 55691:     // Don't unwrap an outer window, just double wrap it if needed.
 79734:     if (js::GetObjectClass(obj)->ext.innerObject)
 55691:         return DoubleWrap(cx, obj, flags);
 55691: 
 55628:     // Here are the rules for wrapping:
 55628:     // We should never get a proxy here (the JS engine unwraps those for us).
 79734:     JS_ASSERT(!IsWrapper(obj));
 55628: 
 55628:     // As soon as an object is wrapped in a security wrapper, it morphs to be
 55628:     // a fat wrapper. (see also: bug XXX).
 55628:     if (IS_SLIM_WRAPPER(obj) && !MorphSlimWrapper(cx, obj))
 55628:         return nsnull;
 55628: 
 55628:     // We only hand out outer objects to script.
 56106:     obj = GetCurrentOuter(cx, obj);
 94341:     if (!obj)
 94341:         return nsnull;
 94341: 
 79734:     if (js::GetObjectClass(obj)->ext.innerObject)
 56105:         return DoubleWrap(cx, obj, flags);
 55628: 
 55628:     // Now, our object is ready to be wrapped, but several objects (notably
 55628:     // nsJSIIDs) have a wrapper per scope. If we are about to wrap one of
 55628:     // those objects in a security wrapper, then we need to hand back the
 55689:     // wrapper for the new scope instead. Also, global objects don't move
 55689:     // between scopes so for those we also want to return the wrapper. So...
 79734:     if (!IS_WN_WRAPPER(obj) || !js::GetObjectParent(obj))
 55691:         return DoubleWrap(cx, obj, flags);
 55628: 
 55628:     XPCWrappedNative *wn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
 55628: 
 62405:     JSAutoEnterCompartment ac;
 62405:     if (!ac.enter(cx, obj))
 62405:         return nsnull;
 55628:     XPCCallContext ccx(JS_CALLER, cx, obj);
 62582: 
 62582:     {
 55628:         if (NATIVE_HAS_FLAG(&ccx, WantPreCreate)) {
 55628:             // We have a precreate hook. This object might enforce that we only
 55628:             // ever create JS object for it.
 99716: 
 99716:             // Note: this penalizes objects that only have one wrapper, but are
 99716:             // being accessed across compartments. We would really prefer to
 99716:             // replace the above code with a test that says "do you only have one
 99716:             // wrapper?"
 55628:             JSObject *originalScope = scope;
 55628:             nsresult rv = wn->GetScriptableInfo()->GetCallback()->
 55628:                 PreCreate(wn->Native(), cx, scope, &scope);
 55691:             NS_ENSURE_SUCCESS(rv, DoubleWrap(cx, obj, flags));
 55628: 
 55628:             // If the handed back scope differs from the passed-in scope and is in
 55628:             // a separate compartment, then this object is explicitly requesting
 55628:             // that we don't create a second JS object for it: create a security
 55628:             // wrapper.
 79734:             if (js::GetObjectCompartment(originalScope) != js::GetObjectCompartment(scope))
 55691:                 return DoubleWrap(cx, obj, flags);
 55628: 
 99716:             JSObject *currentScope = JS_GetGlobalForObject(cx, obj);
 99716:             if (MOZ_UNLIKELY(scope != currentScope)) {
 99716:                 // The wrapper claims it wants to be in the new scope, but
 99716:                 // currently has a reflection that lives in the old scope. This
 99716:                 // can mean one of two things, both of which are rare:
 99716:                 //
 99716:                 // 1 - The object has a PreCreate hook (we checked for it above),
 99716:                 // but is deciding to request one-wrapper-per-scope (rather than
 99716:                 // one-wrapper-per-native) for some reason. Usually, a PreCreate
 99716:                 // hook indicates one-wrapper-per-native. In this case we want to
 99716:                 // make a new wrapper in the new scope.
 99716:                 //
 99716:                 // 2 - We're midway through wrapper reparenting. The document has
 99716:                 // moved to a new scope, but |wn| hasn't been moved yet, and
 99716:                 // we ended up calling JS_WrapObject() on its JS object. In this
 99716:                 // case, we want to return the existing wrapper.
 99716:                 //
 99716:                 // So we do a trick: call PreCreate _again_, but say that we're
 99716:                 // wrapping for the old scope, rather than the new one. If (1) is
 99716:                 // the case, then PreCreate will return the scope we pass to it
 99716:                 // (the old scope). If (2) is the case, PreCreate will return the
 99716:                 // scope of the document (the new scope).
 99716:                 JSObject *probe;
 99716:                 rv = wn->GetScriptableInfo()->GetCallback()->
 99716:                     PreCreate(wn->Native(), cx, currentScope, &probe);
 99716: 
 99716:                 // Check for case (2).
 99716:                 if (probe != currentScope) {
 99716:                     MOZ_ASSERT(probe == scope);
 99716:                     return DoubleWrap(cx, obj, flags);
 99716:                 }
 99716: 
 99716:                 // Ok, must be case (1). Fall through and create a new wrapper.
 99716:             }
 55628:         }
 62405:     }
 55628: 
 56818:     // NB: Passing a holder here inhibits slim wrappers under
 56818:     // WrapNativeToJSVal.
 56818:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
 62582: 
 62582:     // This public WrapNativeToJSVal API enters the compartment of 'scope'
 62582:     // so we don't have to.
 55628:     jsval v;
 55628:     nsresult rv =
 55628:         nsXPConnect::FastGetXPConnect()->WrapNativeToJSVal(cx, scope, wn->Native(), nsnull,
 80486:                                                            &NS_GET_IID(nsISupports), false,
 56818:                                                            &v, getter_AddRefs(holder));
 56818:     if (NS_SUCCEEDED(rv)) {
 55691:         obj = JSVAL_TO_OBJECT(v);
 56818:         NS_ASSERTION(IS_WN_WRAPPER(obj), "bad object");
 56818: 
 93361:         // Because the underlying native didn't have a PreCreate hook, we had
 93361:         // to a new (or possibly pre-existing) XPCWN in our compartment.
 93361:         // This could be a problem for chrome code that passes XPCOM objects
 93361:         // across compartments, because the effects of QI would disappear across
 93361:         // compartments.
 93361:         //
 93361:         // So whenever we pull an XPCWN across compartments in this manner, we
 93361:         // give the destination object the union of the two native sets. We try
 93361:         // to do this cleverly in the common case to avoid too much overhead.
 56818:         XPCWrappedNative *newwn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
 93361:         XPCNativeSet *unionSet = XPCNativeSet::GetNewOrUsed(ccx, newwn->GetSet(),
 93361:                                                             wn->GetSet(), false);
 93361:         if (!unionSet)
 93361:             return nsnull;
 93361:         newwn->SetSet(unionSet);
 56818:     }
 56818: 
 55691:     return DoubleWrap(cx, obj, flags);
 55628: }
 55628: 
 70911: static XPCWrappedNative *
 70911: GetWrappedNative(JSContext *cx, JSObject *obj)
 70911: {
 79734:     obj = JS_ObjectToInnerObject(cx, obj);
 70911:     return IS_WN_WRAPPER(obj)
 79734:            ? static_cast<XPCWrappedNative *>(js::GetObjectPrivate(obj))
 70911:            : nsnull;
 70911: }
 70911: 
 94512: enum XrayType {
 94512:     XrayForDOMObject,
 94512:     XrayForDOMProxyObject,
 94512:     XrayForWrappedNative,
 94512:     NotXray
 94512: };
 94512: 
 94512: static XrayType
 94512: GetXrayType(JSObject *obj)
 80072: {
 94512:     js::Class* clasp = js::GetObjectClass(obj);
 97422:     if (mozilla::dom::IsDOMClass(Jsvalify(clasp))) {
 94512:         return XrayForDOMObject;
 80072:     }
 94512:     if (mozilla::dom::binding::instanceIsProxy(obj)) {
 94512:         return XrayForDOMProxyObject;
 94512:     }
 94512:     if (IS_WRAPPER_CLASS(clasp) || clasp->ext.innerObject) {
 94512:         NS_ASSERTION(clasp->ext.innerObject || IS_WN_WRAPPER_OBJECT(obj),
 94512:                      "We forgot to Morph a slim wrapper!");
 94512:         return XrayForWrappedNative;
 94512:     }
 94512:     return NotXray;
 80072: }
 80072: 
 55628: JSObject *
 55580: WrapperFactory::Rewrap(JSContext *cx, JSObject *obj, JSObject *wrappedProto, JSObject *parent,
 91237:                        unsigned flags)
 47525: {
 79734:     NS_ASSERTION(!IsWrapper(obj) ||
 79734:                  GetProxyHandler(obj) == &WaiveXrayWrapperWrapper ||
 79734:                  js::GetObjectClass(obj)->ext.innerObject,
 54404:                  "wrapped object passed to rewrap");
 89430:     NS_ASSERTION(JS_GetClass(obj) != &XrayUtils::HolderClass, "trying to wrap a holder");
 47574: 
 79734:     JSCompartment *origin = js::GetObjectCompartment(obj);
 87284:     JSCompartment *target = js::GetContextCompartment(cx);
 93950:     bool usingXray = false;
 47574: 
 79386:     Wrapper *wrapper;
 99328:     CompartmentPrivate *targetdata = GetCompartmentPrivate(target);
 47574:     if (AccessCheck::isChrome(target)) {
 68955:         if (AccessCheck::isChrome(origin)) {
 79386:             wrapper = &CrossCompartmentWrapper::singleton;
 68955:         } else {
 68955:             bool isSystem;
 68955:             {
 68955:                 JSAutoEnterCompartment ac;
 68955:                 if (!ac.enter(cx, obj))
 68955:                     return nsnull;
 68955:                 JSObject *globalObj = JS_GetGlobalForObject(cx, obj);
 68955:                 JS_ASSERT(globalObj);
 68955:                 isSystem = JS_IsSystemObject(cx, globalObj);
 68955:             }
 68955: 
 68955:             if (isSystem) {
 79386:                 wrapper = &CrossCompartmentWrapper::singleton;
 55591:             } else if (flags & WAIVE_XRAY_WRAPPER_FLAG) {
 47574:                 // If we waived the X-ray wrapper for this object, wrap it into a
 47574:                 // special wrapper to transitively maintain the X-ray waiver.
 55691:                 wrapper = &CrossOriginWrapper::singleton;
 47574:             } else {
 47574:                 // Native objects must be wrapped into an X-ray wrapper.
 94512:                 XrayType type = GetXrayType(obj);
 94512:                 if (type == XrayForDOMObject) {
 94512:                     wrapper = &XrayDOM::singleton;
 94512:                 } else if (type == XrayForDOMProxyObject) {
 80072:                     wrapper = &XrayProxy::singleton;
 94512:                 } else if (type == XrayForWrappedNative) {
 93954:                     typedef XrayWrapper<CrossCompartmentWrapper> Xray;
 93950:                     usingXray = true;
 55582:                     wrapper = &Xray::singleton;
 55582:                 } else {
103187:                     wrapper = &CrossCompartmentWrapper::singleton;
 55582:                 }
 47525:             }
 68955:         }
 47574:     } else if (AccessCheck::isChrome(origin)) {
 79734:         JSFunction *fun = JS_GetObjectFunction(obj);
 79734:         if (fun) {
 64210:             if (JS_IsBuiltinEvalFunction(fun) || JS_IsBuiltinFunctionConstructor(fun)) {
 61448:                 JS_ReportError(cx, "Not allowed to access chrome eval or Function from content");
 61448:                 return nsnull;
 61448:             }
 61448:         }
 69850: 
 69850:         XPCWrappedNative *wn;
 70911:         if (targetdata &&
 70911:             (wn = GetWrappedNative(cx, obj)) &&
 70911:             wn->HasProto() && wn->GetProto()->ClassIsDOMObject()) {
 80203:             typedef XrayWrapper<CrossCompartmentSecurityWrapper> Xray;
 93950:             usingXray = true;
 93952:             if (IsLocationObject(obj))
 93952:                 wrapper = &FilteringWrapper<Xray, LocationPolicy>::singleton;
 93952:             else
 93952:                 wrapper = &FilteringWrapper<Xray, CrossOriginAccessiblePropertiesOnly>::singleton;
 94512:         } else if (mozilla::dom::binding::instanceIsProxy(obj)) {
 94512:             wrapper = &FilteringWrapper<XrayProxy, CrossOriginAccessiblePropertiesOnly>::singleton;
 97422:         } else if (mozilla::dom::IsDOMClass(JS_GetClass(obj))) {
 94512:             wrapper = &FilteringWrapper<XrayDOM, CrossOriginAccessiblePropertiesOnly>::singleton;
 97171:         } else if (IsComponentsObject(obj)) {
 97171:             wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper,
 97171:                                         ComponentsObjectPolicy>::singleton;
 69850:         } else {
 80203:             wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper,
 55700:                                         ExposedPropertiesOnly>::singleton;
 69850:         }
104341:     } else if (AccessCheck::subsumes(target, origin)) {
 93953:         // For the same-origin case we use a transparent wrapper, unless one
 93953:         // of the following is true:
 94843:         // * The object is flagged as needing a SOW.
101170:         // * The object is a Location object.
101170:         // * The object is a Components object.
 93953:         // * The context compartment specifically requested Xray vision into
 93953:         //   same-origin compartments.
 93953:         //
 93953:         // The first two cases always require a security wrapper for non-chrome
 93953:         // access, regardless of the origin of the object.
 94512:         XrayType type;
 47574:         if (AccessCheck::needsSystemOnlyWrapper(obj)) {
 80203:             wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper,
 47574:                                         OnlyIfSubjectIsSystem>::singleton;
101170:         } else if (IsLocationObject(obj)) {
101170:             typedef XrayWrapper<CrossCompartmentSecurityWrapper> Xray;
101170:             usingXray = true;
101170:             wrapper = &FilteringWrapper<Xray, LocationPolicy>::singleton;
 97171:         } else if (IsComponentsObject(obj)) {
 97171:             wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper,
 97171:                                         ComponentsObjectPolicy>::singleton;
 94512:         } else if (!targetdata || !targetdata->wantXrays ||
 94512:                    (type = GetXrayType(obj)) == NotXray) {
 94512:             wrapper = &CrossCompartmentWrapper::singleton;
 94512:         } else if (type == XrayForDOMObject) {
 94512:             wrapper = &XrayDOM::singleton;
 94512:         } else if (type == XrayForDOMProxyObject) {
 80072:             wrapper = &XrayProxy::singleton;
 80072:         } else {
 79386:             typedef XrayWrapper<CrossCompartmentWrapper> Xray;
 93950:             usingXray = true;
 55675:             wrapper = &Xray::singleton;
 80072:         }
 55675:     } else {
 55700:         NS_ASSERTION(!AccessCheck::needsSystemOnlyWrapper(obj),
 55700:                      "bad object exposed across origins");
 55700: 
 47574:         // Cross origin we want to disallow scripting and limit access to
 47574:         // a predefined set of properties. XrayWrapper adds a property
 47574:         // (.wrappedJSObject) which allows bypassing the XrayWrapper, but
 47574:         // we filter out access to that property.
 94512:         XrayType type = GetXrayType(obj);
 94512:         if (type == NotXray) {
 80203:             wrapper = &FilteringWrapper<CrossCompartmentSecurityWrapper,
 55582:                                         CrossOriginAccessiblePropertiesOnly>::singleton;
 94512:         } else if (type == XrayForDOMObject) {
 94512:             wrapper = &FilteringWrapper<XrayDOM,
 94512:                                         CrossOriginAccessiblePropertiesOnly>::singleton;
 94512:         } else if (type == XrayForDOMProxyObject) {
 80091:             wrapper = &FilteringWrapper<XrayProxy,
 80091:                                         CrossOriginAccessiblePropertiesOnly>::singleton;
 80072:         } else {
 80203:             typedef XrayWrapper<CrossCompartmentSecurityWrapper> Xray;
 93950:             usingXray = true;
 55617: 
 55617:             // Location objects can become same origin after navigation, so we might
 55617:             // have to grant transparent access later on.
 55617:             if (IsLocationObject(obj)) {
 93951:                 wrapper = &FilteringWrapper<Xray, LocationPolicy>::singleton;
 55617:             } else {
 55598:                 wrapper = &FilteringWrapper<Xray,
 47574:                     CrossOriginAccessiblePropertiesOnly>::singleton;
 55617:             }
 55582:         }
 47574:     }
 55599: 
 79386:     JSObject *wrapperObj = Wrapper::New(cx, obj, wrappedProto, parent, wrapper);
 93950:     if (!wrapperObj || !usingXray)
 55599:         return wrapperObj;
 55622: 
 93950:     JSObject *xrayHolder = XrayUtils::createHolder(cx, obj, parent);
 93950:     if (!xrayHolder)
 93950:         return nsnull;
 80061:     js::SetProxyExtra(wrapperObj, 0, js::ObjectValue(*xrayHolder));
 55599:     return wrapperObj;
 47525: }
 47525: 
 98431: JSObject *
 98431: WrapperFactory::WrapForSameCompartment(JSContext *cx, JSObject *obj)
 98431: {
 98431:     // Only WNs have same-compartment wrappers.
 98431:     //
 98431:     // NB: The contract of WrapForSameCompartment says that |obj| may or may not
 98431:     // be a security wrapper. This check implicitly handles the security wrapper
 98431:     // case.
 98431:     if (!IS_WN_WRAPPER(obj))
 98431:         return obj;
 98431: 
 98431:     // Extract the WN. It should exist.
 98431:     XPCWrappedNative *wn = static_cast<XPCWrappedNative *>(xpc_GetJSPrivate(obj));
 98431:     MOZ_ASSERT(wn, "Trying to wrap a dead WN!");
 98431: 
 98431:     // The WN knows what to do.
 98431:     return wn->GetSameCompartmentSecurityWrapper(cx);
 98431: }
 98431: 
 93951: typedef FilteringWrapper<XrayWrapper<SameCompartmentSecurityWrapper>, LocationPolicy> LW;
 55617: 
 55617: bool
 55617: WrapperFactory::IsLocationObject(JSObject *obj)
 55617: {
 79734:     const char *name = js::GetObjectClass(obj)->name;
 55617:     return name[0] == 'L' && !strcmp(name, "Location");
 47525: }
 55617: 
 55617: JSObject *
 55617: WrapperFactory::WrapLocationObject(JSContext *cx, JSObject *obj)
 55617: {
 93950:     JSObject *xrayHolder = XrayUtils::createHolder(cx, obj, js::GetObjectParent(obj));
 55617:     if (!xrayHolder)
 60580:         return nsnull;
 79734:     JSObject *wrapperObj = Wrapper::New(cx, obj, js::GetObjectProto(obj), js::GetObjectParent(obj),
 56820:                                         &LW::singleton);
 55617:     if (!wrapperObj)
 60580:         return nsnull;
 80061:     js::SetProxyExtra(wrapperObj, 0, js::ObjectValue(*xrayHolder));
 55617:     return wrapperObj;
 55617: }
 55617: 
 71303: // Call WaiveXrayAndWrap when you have a JS object that you don't want to be
 71303: // wrapped in an Xray wrapper. cx->compartment is the compartment that will be
 71303: // using the returned object. If the object to be wrapped is already in the
 71303: // correct compartment, then this returns the unwrapped object.
 55696: bool
 55696: WrapperFactory::WaiveXrayAndWrap(JSContext *cx, jsval *vp)
 55696: {
 55815:     if (JSVAL_IS_PRIMITIVE(*vp))
 55815:         return JS_WrapValue(cx, vp);
 55696: 
 79734:     JSObject *obj = js::UnwrapObject(JSVAL_TO_OBJECT(*vp));
 71303:     obj = GetCurrentOuter(cx, obj);
 86111:     if (js::IsObjectInContextCompartment(obj, cx)) {
 71303:         *vp = OBJECT_TO_JSVAL(obj);
 71303:         return true;
 71303:     }
 55696: 
 60580:     obj = WaiveXray(cx, obj);
 60580:     if (!obj)
 55696:         return false;
 58722: 
 55696:     *vp = OBJECT_TO_JSVAL(obj);
 55696:     return JS_WrapValue(cx, vp);
 55696: }
 55696: 
 55700: JSObject *
 55700: WrapperFactory::WrapSOWObject(JSContext *cx, JSObject *obj)
 55700: {
 55700:     JSObject *wrapperObj =
 89826:         Wrapper::New(cx, obj, JS_GetPrototype(obj), JS_GetGlobalForObject(cx, obj),
 80203:                      &FilteringWrapper<SameCompartmentSecurityWrapper,
 55700:                      OnlyIfSubjectIsSystem>::singleton);
 55700:     return wrapperObj;
 55696: }
 55700: 
 97171: bool
 97171: WrapperFactory::IsComponentsObject(JSObject *obj)
 97171: {
 97171:     const char *name = js::GetObjectClass(obj)->name;
 97171:     return name[0] == 'n' && !strcmp(name, "nsXPCComponents");
 55700: }
 97171: 
 97171: JSObject *
 97171: WrapperFactory::WrapComponentsObject(JSContext *cx, JSObject *obj)
 97171: {
 97171:     JSObject *wrapperObj =
 97171:         Wrapper::New(cx, obj, JS_GetPrototype(obj), JS_GetGlobalForObject(cx, obj),
 97171:                      &FilteringWrapper<SameCompartmentSecurityWrapper, ComponentsObjectPolicy>::singleton);
 97171: 
 97171:     return wrapperObj;
 97171: }
 97171: 
 97171: }
