    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsDocShell.h"
    1: #include "nsDSURIContentListener.h"
    1: #include "nsIChannel.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsDocShellCID.h"
    1: #include "nsIWebNavigationInfo.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsAutoPtr.h"
55818: #include "nsIHttpChannel.h"
55818: #include "nsIScriptSecurityManager.h"
55818: #include "nsNetError.h"
    1: 
    1: //*****************************************************************************
    1: //***    nsDSURIContentListener: Object Management
    1: //*****************************************************************************
    1: 
    1: nsDSURIContentListener::nsDSURIContentListener(nsDocShell* aDocShell)
    1:     : mDocShell(aDocShell), 
    1:       mParentContentListener(nsnull)
    1: {
    1: }
    1: 
    1: nsDSURIContentListener::~nsDSURIContentListener()
    1: {
    1: }
    1: 
    1: nsresult
    1: nsDSURIContentListener::Init() 
    1: {
    1:     nsresult rv;
    1:     mNavInfo = do_GetService(NS_WEBNAVIGATION_INFO_CONTRACTID, &rv);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to get webnav info");
    1:     return rv;
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsDSURIContentListener::nsISupports
    1: //*****************************************************************************   
    1: 
    1: NS_IMPL_THREADSAFE_ADDREF(nsDSURIContentListener)
    1: NS_IMPL_THREADSAFE_RELEASE(nsDSURIContentListener)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsDSURIContentListener)
    1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIURIContentListener)
    1:     NS_INTERFACE_MAP_ENTRY(nsIURIContentListener)
    1:     NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1: NS_INTERFACE_MAP_END
    1: 
    1: //*****************************************************************************
    1: // nsDSURIContentListener::nsIURIContentListener
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDSURIContentListener::OnStartURIOpen(nsIURI* aURI, PRBool* aAbortOpen)
    1: {
    1:     // If mDocShell is null here, that means someone's starting a load
    1:     // in our docshell after it's already been destroyed.  Don't let
    1:     // that happen.
    1:     if (!mDocShell) {
    1:         *aAbortOpen = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1:     
    1:     nsCOMPtr<nsIURIContentListener> parentListener;
    1:     GetParentContentListener(getter_AddRefs(parentListener));
    1:     if (parentListener)
    1:         return parentListener->OnStartURIOpen(aURI, aAbortOpen);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsDSURIContentListener::DoContent(const char* aContentType, 
    1:                                   PRBool aIsContentPreferred,
    1:                                   nsIRequest* request,
    1:                                   nsIStreamListener** aContentHandler,
    1:                                   PRBool* aAbortProcess)
    1: {
    1:     nsresult rv;
    1:     NS_ENSURE_ARG_POINTER(aContentHandler);
    1:     NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
55818: 
55818:     // Check whether X-Frame-Options permits us to load this content in an
55818:     // iframe
55818:     if (!CheckFrameOptions(request)) {
55818:         *aAbortProcess = PR_TRUE;
55818:         return NS_OK;
55818:     }
55818: 
    1:     *aAbortProcess = PR_FALSE;
    1: 
    1:     // determine if the channel has just been retargeted to us...
    1:     nsLoadFlags loadFlags = 0;
    1:     nsCOMPtr<nsIChannel> aOpenedChannel = do_QueryInterface(request);
    1: 
    1:     if (aOpenedChannel)
    1:       aOpenedChannel->GetLoadFlags(&loadFlags);
    1: 
    1:     if(loadFlags & nsIChannel::LOAD_RETARGETED_DOCUMENT_URI)
    1:     {
    1:         // XXX: Why does this not stop the content too?
    1:         mDocShell->Stop(nsIWebNavigation::STOP_NETWORK);
    1: 
    1:         mDocShell->SetLoadType(aIsContentPreferred ? LOAD_LINK : LOAD_NORMAL);
    1:     }
    1: 
    1:     rv = mDocShell->CreateContentViewer(aContentType, request, aContentHandler);
    1:     if (NS_FAILED(rv)) {
    1:        // it's okay if we don't know how to handle the content   
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (loadFlags & nsIChannel::LOAD_RETARGETED_DOCUMENT_URI) {
 3233:         nsCOMPtr<nsIDOMWindowInternal> domWindow = do_GetInterface(static_cast<nsIDocShell*>(mDocShell));
    1:         NS_ENSURE_TRUE(domWindow, NS_ERROR_FAILURE);
    1:         domWindow->Focus();
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDSURIContentListener::IsPreferred(const char* aContentType,
    1:                                     char ** aDesiredContentType,
    1:                                     PRBool* aCanHandle)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCanHandle);
    1:     NS_ENSURE_ARG_POINTER(aDesiredContentType);
    1: 
    1:     // the docshell has no idea if it is the preferred content provider or not.
24692:     // It needs to ask its parent if it is the preferred content handler or not...
    1: 
    1:     nsCOMPtr<nsIURIContentListener> parentListener;
    1:     GetParentContentListener(getter_AddRefs(parentListener));
    1:     if (parentListener) {
    1:         return parentListener->IsPreferred(aContentType,
    1:                                                    aDesiredContentType,
    1:                                                    aCanHandle);
    1:     }
    1:     // we used to return false here if we didn't have a parent properly
    1:     // registered at the top of the docshell hierarchy to dictate what
    1:     // content types this docshell should be a preferred handler for.  But
    1:     // this really makes it hard for developers using iframe or browser tags
    1:     // because then they need to make sure they implement
    1:     // nsIURIContentListener otherwise all link clicks would get sent to
    1:     // another window because we said we weren't the preferred handler type.
    1:     // I'm going to change the default now...if we can handle the content,
    1:     // and someone didn't EXPLICITLY set a nsIURIContentListener at the top
    1:     // of our docshell chain, then we'll now always attempt to process the
    1:     // content ourselves...
    1:     return CanHandleContent(aContentType,
    1:                             PR_TRUE,
    1:                             aDesiredContentType,
    1:                             aCanHandle);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDSURIContentListener::CanHandleContent(const char* aContentType,
    1:                                          PRBool aIsContentPreferred,
    1:                                          char ** aDesiredContentType,
    1:                                          PRBool* aCanHandleContent)
    1: {
    1:     NS_PRECONDITION(aCanHandleContent, "Null out param?");
    1:     NS_ENSURE_ARG_POINTER(aDesiredContentType);
    1: 
    1:     *aCanHandleContent = PR_FALSE;
    1:     *aDesiredContentType = nsnull;
    1: 
    1:     nsresult rv = NS_OK;
    1:     if (aContentType) {
    1:         PRUint32 canHandle = nsIWebNavigationInfo::UNSUPPORTED;
    1:         rv = mNavInfo->IsTypeSupported(nsDependentCString(aContentType),
    1:                                        mDocShell,
    1:                                        &canHandle);
    1:         *aCanHandleContent = (canHandle != nsIWebNavigationInfo::UNSUPPORTED);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDSURIContentListener::GetLoadCookie(nsISupports ** aLoadCookie)
    1: {
    1:     NS_IF_ADDREF(*aLoadCookie = nsDocShell::GetAsSupports(mDocShell));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDSURIContentListener::SetLoadCookie(nsISupports * aLoadCookie)
    1: {
    1: #ifdef DEBUG
    1:     nsRefPtr<nsDocLoader> cookieAsDocLoader =
    1:         nsDocLoader::GetAsDocLoader(aLoadCookie);
    1:     NS_ASSERTION(cookieAsDocLoader && cookieAsDocLoader == mDocShell,
    1:                  "Invalid load cookie being set!");
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsDSURIContentListener::GetParentContentListener(nsIURIContentListener**
    1:                                                  aParentListener)
    1: {
    1:     if (mWeakParentContentListener)
    1:     {
    1:         nsCOMPtr<nsIURIContentListener> tempListener =
    1:             do_QueryReferent(mWeakParentContentListener);
    1:         *aParentListener = tempListener;
    1:         NS_IF_ADDREF(*aParentListener);
    1:     }
    1:     else {
    1:         *aParentListener = mParentContentListener;
    1:         NS_IF_ADDREF(*aParentListener);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDSURIContentListener::SetParentContentListener(nsIURIContentListener* 
    1:                                                  aParentListener)
    1: {
    1:     if (aParentListener)
    1:     {
    1:         // Store the parent listener as a weak ref. Parents not supporting
    1:         // nsISupportsWeakReference assert but may still be used.
    1:         mParentContentListener = nsnull;
    1:         mWeakParentContentListener = do_GetWeakReference(aParentListener);
    1:         if (!mWeakParentContentListener)
    1:         {
    1:             mParentContentListener = aParentListener;
    1:         }
    1:     }
    1:     else
    1:     {
    1:         mWeakParentContentListener = nsnull;
    1:         mParentContentListener = nsnull;
    1:     }
    1:     return NS_OK;
    1: }
55818: 
55818: // Check if X-Frame-Options permits this document to be loaded as a subdocument.
55818: bool nsDSURIContentListener::CheckFrameOptions(nsIRequest* request)
55818: {
55818:     nsCAutoString xfoHeaderValue;
55818: 
55818:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(request);
55818:     if (!httpChannel) {
55818:         return true;
55818:     }
55818: 
55818:     httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("X-Frame-Options"),
55818:                                    xfoHeaderValue);
55818: 
55818:     // return early if header does not have one of the two values with meaning
55818:     if (!xfoHeaderValue.LowerCaseEqualsLiteral("deny") &&
55818:         !xfoHeaderValue.LowerCaseEqualsLiteral("sameorigin"))
55818:         return true;
55818: 
55818:     if (mDocShell) {
55818:         // We need to check the location of this window and the location of the top
55818:         // window, if we're not the top.  X-F-O: SAMEORIGIN requires that the
55818:         // document must be same-origin with top window.  X-F-O: DENY requires that
55818:         // the document must never be framed.
55818:         nsCOMPtr<nsIDOMWindow> thisWindow = do_GetInterface(static_cast<nsIDocShell*>(mDocShell));
56931:         // If we don't have DOMWindow there is no risk of clickjacking
56931:         if (!thisWindow)
56931:             return true;
56931: 
55818:         nsCOMPtr<nsIDOMWindow> topWindow;
55818:         thisWindow->GetTop(getter_AddRefs(topWindow));
55818: 
55818:         // if the document is in the top window, it's not in a frame.
55818:         if (thisWindow == topWindow)
55818:             return true;
55818: 
55818:         // Find the top docshell in our parent chain that doesn't have the system
55818:         // principal and use it for the principal comparison.  Finding the top
55818:         // content-type docshell doesn't work because some chrome documents are
55818:         // loaded in content docshells (see bug 593387).
55818:         nsCOMPtr<nsIDocShellTreeItem> thisDocShellItem(do_QueryInterface(
55818:                                                        static_cast<nsIDocShell*> (mDocShell)));
55818:         nsCOMPtr<nsIDocShellTreeItem> parentDocShellItem,
55818:                                       curDocShellItem = thisDocShellItem;
55818:         nsCOMPtr<nsIDocument> topDoc;
55818:         nsresult rv;
55818:         nsCOMPtr<nsIScriptSecurityManager> ssm =
55818:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
55818:         if (!ssm)
55818:             return false;
55818: 
55818:         // Traverse up the parent chain to the top docshell that doesn't have
55818:         // a system principal
56267:         while (NS_SUCCEEDED(curDocShellItem->GetParent(getter_AddRefs(parentDocShellItem))) &&
56267:                parentDocShellItem) {
55818:             PRBool system = PR_FALSE;
55818:             topDoc = do_GetInterface(parentDocShellItem);
55818:             if (topDoc) {
55818:                 if (NS_SUCCEEDED(ssm->IsSystemPrincipal(topDoc->NodePrincipal(),
55818:                                                         &system)) && system) {
55818:                     break;
55818:                 }
55818:             }
55818:             else {
55818:                 return false;
55818:             }
55818:             curDocShellItem = parentDocShellItem;
55818:         }
55818: 
55818:         // If this document has the top non-SystemPrincipal docshell it is not being
55818:         // framed or it is being framed by a chrome document, which we allow.
55818:         if (curDocShellItem == thisDocShellItem)
55818:             return true;
55818: 
55818:         // If the X-Frame-Options value is SAMEORIGIN, then the top frame in the
55818:         // parent chain must be from the same origin as this document.
55818:         if (xfoHeaderValue.LowerCaseEqualsLiteral("sameorigin")) {
55818:             nsCOMPtr<nsIURI> uri;
55818:             httpChannel->GetURI(getter_AddRefs(uri));
55818:             topDoc = do_GetInterface(curDocShellItem);
55818:             nsCOMPtr<nsIURI> topUri;
55818:             topDoc->NodePrincipal()->GetURI(getter_AddRefs(topUri));
55818:             rv = ssm->CheckSameOriginURI(uri, topUri, PR_TRUE);
55818:             if (NS_SUCCEEDED(rv))
55818:                 return true;
55818:         }
55818: 
55818:         else {
55818:             // If the value of the header is DENY, then the document
55818:             // should never be permitted to load as a subdocument.
55818:             NS_ASSERTION(xfoHeaderValue.LowerCaseEqualsLiteral("deny"),
55818:                          "How did we get here with some random header value?");
55818:         }
55818: 
55818:         // cancel the load and display about:blank
55818:         httpChannel->Cancel(NS_BINDING_ABORTED);
55818:         nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(static_cast<nsIDocShell*>(mDocShell)));
55818:         if (webNav) {
55818:             webNav->LoadURI(NS_LITERAL_STRING("about:blank").get(),
55818:                             0, nsnull, nsnull, nsnull);
55818:         }
55818:         return false;
55818:     }
55818: 
55818:     return true;
55818: }
