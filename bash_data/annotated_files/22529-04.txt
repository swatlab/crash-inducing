16300: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
16300: /* vim:set ts=2 sw=2 sts=2 et cindent: */
16300: /* ***** BEGIN LICENSE BLOCK *****
16300:  * Version: ML 1.1/GPL 2.0/LGPL 2.1
16300:  *
16300:  * The contents of this file are subject to the Mozilla Public License Version
16300:  * 1.1 (the "License"); you may not use this file except in compliance with
16300:  * the License. You may obtain a copy of the License at
16300:  * http://www.mozilla.org/MPL/
16300:  *
16300:  * Software distributed under the License is distributed on an "AS IS" basis,
16300:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
16300:  * for the specific language governing rights and limitations under the
16300:  * License.
16300:  *
16300:  * The Original Code is Mozilla code.
16300:  *
16300:  * The Initial Developer of the Original Code is the Mozilla Corporation.
16300:  * Portions created by the Initial Developer are Copyright (C) 2007
16300:  * the Initial Developer. All Rights Reserved.
16300:  *
16300:  * Contributor(s):
16300:  *  Chris Double <chris.double@double.co.nz>
16300:  *
16300:  * Alternatively, the contents of this file may be used under the terms of
16300:  * either the GNU General Public License Version 2 or later (the "GPL"), or
16300:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
16300:  * in which case the provisions of the GPL or the LGPL are applicable instead
16300:  * of those above. If you wish to allow use of your version of this file only
16300:  * under the terms of either the GPL or the LGPL, and not to allow others to
16300:  * use your version of this file under the terms of the MPL, indicate your
16300:  * decision by deleting the provisions above and replace them with the notice
16300:  * and other provisions required by the GPL or the LGPL. If you do not delete
16300:  * the provisions above, a recipient may use your version of this file under
16300:  * the terms of any one of the MPL, the GPL or the LGPL.
16300:  *
16300:  * ***** END LICENSE BLOCK ***** */
21542: #include <limits>
16300: #include "prlog.h"
16300: #include "prmem.h"
16300: #include "nsIFrame.h"
16300: #include "nsIDocument.h"
16300: #include "nsThreadUtils.h"
16300: #include "nsIDOMHTMLMediaElement.h"
16300: #include "nsNetUtil.h"
16300: #include "nsAudioStream.h"
16300: #include "nsChannelReader.h"
16300: #include "nsHTMLVideoElement.h"
16300: #include "nsIObserver.h"
16300: #include "nsIObserverService.h"
16300: #include "nsAutoLock.h"
20627: #include "nsTArray.h"
21079: #include "nsNetUtil.h"
16300: #include "nsOggDecoder.h"
16300: 
16300: /* 
16300:    The maximum height and width of the video. Used for
16300:    sanitizing the memory allocation of the RGB buffer
16300: */
16300: #define MAX_VIDEO_WIDTH  2000
16300: #define MAX_VIDEO_HEIGHT 2000
16300: 
16300: // The number of entries in oggplay buffer list. This value
16300: // is the one used by the oggplay examples.
16300: #define OGGPLAY_BUFFER_SIZE 20
16300: 
16300: // The number of frames to read before audio callback is called.
16300: // This value is the one used by the oggplay examples.
16300: #define OGGPLAY_FRAMES_PER_CALLBACK 2048
16300: 
16300: // Offset into Ogg buffer containing audio information. This value
16300: // is the one used by the oggplay examples.
16300: #define OGGPLAY_AUDIO_OFFSET 250L
16300: 
20627: // Wait this number of seconds when buffering, then leave and play
20627: // as best as we can if the required amount of data hasn't been
20627: // retrieved.
20627: #define BUFFERING_WAIT 15
16300: 
20627: // The amount of data to retrieve during buffering is computed based
20627: // on the download rate. BUFFERING_MIN_RATE is the minimum download
20627: // rate to be used in that calculation to help avoid constant buffering
20627: // attempts at a time when the average download rate has not stabilised.
20627: #define BUFFERING_MIN_RATE 50000
20627: #define BUFFERING_RATE(x) ((x)< BUFFERING_MIN_RATE ? BUFFERING_MIN_RATE : (x))
20627: 
20627: // The number of seconds of buffer data before buffering happens
20627: // based on current playback rate.
20627: #define BUFFERING_SECONDS_LOW_WATER_MARK 1
20627: 
20627: /* 
20627:   All reading (including seeks) from the nsMediaStream are done on the
20627:   decoding thread. The decoder thread is informed before closing that
20627:   the stream is about to close via the Shutdown
20627:   event. oggplay_prepare_for_close is called before sending the
20627:   shutdown event to tell liboggplay to shutdown.
20627: 
20627:   This call results in oggplay internally not calling any
20627:   read/write/seek/tell methods, and returns a value that results in
20627:   stopping the decoder thread.
20627: 
20627:   oggplay_close is called in the destructor which results in the media
20627:   stream being closed. This is how the nsMediaStream contract that no
20627:   read/seeking must occur during or after Close is called is enforced.
20627: 
20627:   This object keeps pointers to the nsOggDecoder and nsChannelReader
20627:   objects.  Since the lifetime of nsOggDecodeStateMachine is
20627:   controlled by nsOggDecoder it will never have a stale reference to
20627:   these objects. The reader is destroyed by the call to oggplay_close
20627:   which is done in the destructor so again this will never be a stale
20627:   reference.
20627: 
20627:   All internal state is synchronised via the decoder monitor. NotifyAll
20627:   on the monitor is called when the state of the state machine is changed
20627:   by the main thread. The following changes to state cause a notify:
20627: 
20627:     mState and data related to that state changed (mSeekTime, etc)
20627:     Ogg Metadata Loaded
20627:     First Frame Loaded  
20627:     Frame decoded    
20627:     
20627:   See nsOggDecoder.h for more details.
20627: */
20627: class nsOggDecodeStateMachine : public nsRunnable
20627: {
19690: public:
20627:   // Object to hold the decoded data from a frame
20627:   class FrameData {
20627:   public:
20627:     FrameData() :
20627:       mVideoWidth(0),
20627:       mVideoHeight(0),
20627:       mDecodedFrameTime(0.0),
20627:       mTime(0.0)
20627:     {
20627:       MOZ_COUNT_CTOR(FrameData);
20627:     }
20627: 
20627:     ~FrameData()
20627:     {
20627:       MOZ_COUNT_DTOR(FrameData);
20627:     }
20627: 
20627: 
20627:     nsAutoArrayPtr<unsigned char> mVideoData;
20627:     nsTArray<float> mAudioData;
20627:     int mVideoWidth;
20627:     int mVideoHeight;
20627:     float mDecodedFrameTime;
20627:     float mTime;
20627:     OggPlayStreamInfo mState;
20627:   };
20627: 
20627:   // A queue of decoded video frames. 
20627:   class FrameQueue
20627:   {
20627:   public:
20627:     FrameQueue() :
20627:       mHead(0),
20627:       mTail(0),
20627:       mEmpty(PR_TRUE)
19690:     {
19690:     }
19675: 
20627:     void Push(FrameData* frame)
19690:     {
20627:       NS_ASSERTION(!IsFull(), "FrameQueue is full");
20627:       mQueue[mTail] = frame;
20627:       mTail = (mTail+1) % OGGPLAY_BUFFER_SIZE;
20627:       mEmpty = PR_FALSE;
19690:     }
19675: 
20627:     FrameData* Peek()
19690:     {
20627:       NS_ASSERTION(!mEmpty, "FrameQueue is empty");
20627: 
20627:       return mQueue[mHead];
19690:     }
19675: 
20627:     FrameData* Pop()
19690:     {
20627:       NS_ASSERTION(!mEmpty, "FrameQueue is empty");
20627: 
20627:       FrameData* result = mQueue[mHead];
20627:       mHead = (mHead + 1) % OGGPLAY_BUFFER_SIZE;
20627:       mEmpty = mHead == mTail;
20627:       return result;
19690:     }
19675: 
20627:     PRBool IsEmpty()
19690:     {
20627:       return mEmpty;
19690:     }
19675: 
20627:     PRBool IsFull()
19690:     {
20627:       return !mEmpty && mHead == mTail;
19690:     }
19690: 
20627:   private:
20627:     FrameData* mQueue[OGGPLAY_BUFFER_SIZE];
20627:     PRInt32 mHead;
20627:     PRInt32 mTail;
20627:     PRPackedBool mEmpty;
20627:   };
20627: 
20627:   // Enumeration for the valid states
20627:   enum State {
20627:     DECODER_STATE_DECODING_METADATA,
20627:     DECODER_STATE_DECODING_FIRSTFRAME,
20627:     DECODER_STATE_DECODING,
20627:     DECODER_STATE_SEEKING,
20627:     DECODER_STATE_BUFFERING,
20627:     DECODER_STATE_COMPLETED,
20627:     DECODER_STATE_SHUTDOWN
20627:   };
20627: 
21756:   nsOggDecodeStateMachine(nsOggDecoder* aDecoder);
20627:   ~nsOggDecodeStateMachine();
20627: 
20627:   // Cause state transitions. These methods obtain the decoder monitor
20627:   // to synchronise the change of state, and to notify other threads
20627:   // that the state has changed.
20627:   void Shutdown();
20627:   void Decode();
20627:   void Seek(float aTime);
20627: 
20627:   NS_IMETHOD Run();
20627: 
20627:   PRBool HasAudio()
20627:   {
20627:     NS_ASSERTION(mState > DECODER_STATE_DECODING_METADATA, "HasAudio() called during invalid state");
20627:     //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "HasAudio() called without acquiring decoder monitor");
20627:     return mAudioTrack != -1;
19690:   }
19690: 
20627:   // Decode one frame of data, returning the OggPlay error code. Must
20627:   // be called only when the current state > DECODING_METADATA. The decode 
20627:   // monitor MUST NOT be locked during this call since it can take a long
20627:   // time. liboggplay internally handles locking.
20627:   // Any return value apart from those below is mean decoding cannot continue.
20627:   // E_OGGPLAY_CONTINUE       = One frame decoded and put in buffer list
20627:   // E_OGGPLAY_USER_INTERRUPT = One frame decoded, buffer list is now full
20627:   // E_OGGPLAY_TIMEOUT        = No frames decoded, timed out
20627:   OggPlayErrorCode DecodeFrame();
20627: 
20627:   // Returns the next decoded frame of data. The caller is responsible
20627:   // for freeing the memory returned. This function must be called
20627:   // only when the current state > DECODING_METADATA. The decode
20627:   // monitor lock does not need to be locked during this call since
20627:   // liboggplay internally handles locking.
20627:   FrameData* NextFrame();
20627: 
20627:   // Play a frame of decoded video. The decode monitor is obtained
20627:   // internally by this method for synchronisation.
20627:   void PlayFrame();
20627: 
20627:   // Play the video data from the given frame. The decode monitor
20627:   // must be locked when calling this method.
20627:   void PlayVideo(FrameData* aFrame);
20627: 
20627:   // Play the audio data from the given frame. The decode monitor must
20627:   // be locked when calling this method. Returns PR_FALSE if unable to
20627:   // write to the audio device without blocking.
20627:   PRBool PlayAudio(FrameData* aFrame);
20627: 
20627:   // Called from the main thread to get the current frame time. The decoder
20627:   // monitor must be obtained before calling this.
20627:   float GetCurrentTime();
20627: 
21542:   // Called from the main thread to get the duration. The decoder monitor
21542:   // must be obtained before calling this. It is in units of milliseconds.
21542:   PRInt64 GetDuration();
21542: 
21542:   // Called from the main thread to set the content length of the media
21542:   // resource. The decoder monitor must be obtained before calling this.
21542:   void SetContentLength(PRInt64 aLength);
21542: 
21542:   // Called from the main thread to set whether the media resource can
21542:   // be seeked. The decoder monitor must be obtained before calling this.
21542:   void SetSeekable(PRBool aSeekable);
21542: 
20627:   // Get and set the audio volume. The decoder monitor must be
20627:   // obtained before calling this.
20627:   float GetVolume();
20627:   void SetVolume(float aVolume);
20627: 
20776:   // Clear the flag indicating that a playback position change event
20776:   // is currently queued. This is called from the main thread and must
20776:   // be called with the decode monitor held.
20776:   void ClearPositionChangeFlag();
20776: 
19690: protected:
20627:   // Convert the OggPlay frame information into a format used by Gecko
20627:   // (RGB for video, float for sound, etc).The decoder monitor must be
20627:   // acquired in the scope of calls to these functions. They must be
20627:   // called only when the current state > DECODING_METADATA.
20627:   void HandleVideoData(FrameData* aFrame, int aTrackNum, OggPlayVideoData* aVideoData);
20627:   void HandleAudioData(FrameData* aFrame, OggPlayAudioData* aAudioData, int aSize);
19690: 
20627:   // These methods can only be called on the decoding thread.
20627:   void LoadOggHeaders();
20627: 
20627:   // Initializes and opens the audio stream. Called from the decode
20627:   // thread only. Must be called with the decode monitor held.
20627:   void OpenAudioStream();
20627: 
20627:   // Closes and releases resources used by the audio stream. Called
20627:   // from the decode thread only. Must be called with the decode
20627:   // monitor held.
20627:   void CloseAudioStream();
20627: 
20627:   // Start playback of audio, either by opening or resuming the audio
20627:   // stream. Must be called with the decode monitor held.
20627:   void StartAudio();
20627: 
20627:   // Stop playback of audio, either by closing or pausing the audio
20627:   // stream. Must be called with the decode monitor held.
20627:   void StopAudio();
20627: 
20627:   // Start playback of media. Must be called with the decode monitor held.
20627:   void StartPlayback();
20627: 
20627:   // Stop playback of media. Must be called with the decode monitor held.
20627:   void StopPlayback();
20627: 
20776:   // Update the playback position. This can result in a timeupdate event
20776:   // and an invalidate of the frame being dispatched asynchronously if
20776:   // there is no such event currently queued.
20776:   // Only called on the decoder thread. Must be called with
20776:   // the decode monitor held.
20776:   void UpdatePlaybackPosition(float aTime);
20776: 
20627: private:
20627:   // *****
20627:   // The follow fields are only accessed by the decoder thread
20627:   // *****
20627: 
20627:   // The decoder object that created this state machine. The decoder
20627:   // always outlives us since it controls our lifetime.
19690:   nsOggDecoder* mDecoder;
20627: 
20627:   // The OggPlay handle. Synchronisation of calls to oggplay functions
20627:   // are handled by liboggplay. We control the lifetime of this
20627:   // object, destroying it in our destructor.
20627:   OggPlay* mPlayer;
20627: 
20627:   // Frame data containing decoded video/audio for the frame the
20627:   // current frame and the previous frame. Accessed only via the
20627:   // decoder thread.
20627:   FrameQueue mDecodedFrames;
20627: 
20627:   // The time that playback started from the system clock. This is used
20627:   // for synchronising frames.  It is reset after a seek as the mTime member
20627:   // of FrameData is reset to start at 0 from the first frame after a seek.
20627:   // Accessed only via the decoder thread.
20627:   PRIntervalTime mPlayStartTime;
20627: 
20627:   // The time that playback was most recently paused, either via
20627:   // buffering or pause. This is used to compute mPauseDuration for
20627:   // a/v sync adjustments.  Accessed only via the decoder thread.
20627:   PRIntervalTime mPauseStartTime;
20627: 
20627:   // The total time that has been spent in completed pauses (via
20627:   // 'pause' or buffering). This is used to adjust for these
20627:   // pauses when computing a/v synchronisation. Accessed only via the
20627:   // decoder thread.
20627:   PRIntervalTime mPauseDuration;
20627: 
20627:   // PR_TRUE if the media is playing and the decoder has started
20627:   // the sound and adjusted the sync time for pauses. PR_FALSE
20627:   // if the media is paused and the decoder has stopped the sound
20627:   // and adjusted the sync time for pauses. Accessed only via the
20627:   // decoder thread.
20627:   PRPackedBool mPlaying;
20627: 
20627:   // Number of seconds of data video/audio data held in a frame.
20627:   // Accessed only via the decoder thread.
20627:   float mCallbackPeriod;
20627: 
20627:   // Video data. These are initially set when the metadata is loaded.
20627:   // They are only accessed from the decoder thread.
20627:   PRInt32 mVideoTrack;
20627:   float   mFramerate;
20627: 
20627:   // Audio data. These are initially set when the metadata is loaded.
20627:   // They are only accessed from the decoder thread.
20627:   PRInt32 mAudioRate;
20627:   PRInt32 mAudioChannels;
20627:   PRInt32 mAudioTrack;
20627: 
20627:   // Time that buffering started. Used for buffering timeout and only
20627:   // accessed in the decoder thread.
20627:   PRIntervalTime mBufferingStart;
20627: 
20627:   // Number of bytes to buffer when buffering. Only accessed in the
20627:   // decoder thread.
20627:   PRUint32 mBufferingBytes;
20627: 
20627:   // The time value of the last decoded video frame. Used for
20627:   // computing the sleep period between frames for a/v sync.
20627:   // Read/Write from the decode thread only.
20627:   float mLastFrameTime;
20627: 
20627:   // *****
20627:   // The follow fields are accessed by the decoder thread or
20627:   // the main thread.
20627:   // *****
20627: 
20627:   // The decoder monitor must be obtained before modifying this state.
20627:   // NotifyAll on the monitor must be called when the state is changed by
20627:   // the main thread so the decoder thread can wake up.
20627:   State mState;
20627: 
20627:   // Position to seek to when the seek state transition occurs. The
20627:   // decoder monitor lock must be obtained before reading or writing
20627:   // this value.
20627:   float mSeekTime;
20627: 
20627:   // The audio stream resource. Used on the decode thread and the
20627:   // main thread (Via the Get/SetVolume calls). Synchronisation via
20627:   // mDecoder monitor.
20627:   nsAutoPtr<nsAudioStream> mAudioStream;
20627: 
20627:   // The time of the current frame in seconds. This is referenced from
20627:   // 0.0 which is the initial start of the stream. Set by the decode
20627:   // thread, and read-only from the main thread to get the current
20627:   // time value. Synchronised via decoder monitor.
20627:   float mCurrentFrameTime;
20627: 
20627:   // Volume of playback. 0.0 = muted. 1.0 = full volume. Read/Written
20627:   // from the decode and main threads. Synchronised via decoder
20627:   // monitor.
20627:   float mVolume;
20776: 
21542:   // Duration of the media resource. It is accessed from the decoder and main
21542:   // threads. Synchronised via decoder monitor. It is in units of
21542:   // milliseconds.
21542:   PRInt64 mDuration;
21542: 
21542:   // Content Length of the media resource if known. If it is -1 then the
21542:   // size is unknown. Accessed from the decoder and main threads. Synchronised
21542:   // via decoder monitor.
21542:   PRInt64 mContentLength;
21542: 
21542:   // PR_TRUE if the media resource can be seeked. Accessed from the decoder
21542:   // and main threads. Synchronised via decoder monitor.
21542:   PRPackedBool mSeekable;
21542: 
20776:   // PR_TRUE if an event to notify about a change in the playback
20776:   // position has been queued, but not yet run. It is set to PR_FALSE when
20776:   // the event is run. This allows coalescing of these events as they can be
20776:   // produced many times per second. Synchronised via decoder monitor.
20776:   PRPackedBool mPositionChangeQueued;
19690: };
19690: 
21756: nsOggDecodeStateMachine::nsOggDecodeStateMachine(nsOggDecoder* aDecoder) :
20627:   mDecoder(aDecoder),
20627:   mPlayer(0),
20627:   mPlayStartTime(0),
20627:   mPauseStartTime(0),
20627:   mPauseDuration(0),
20627:   mPlaying(PR_FALSE),
20627:   mCallbackPeriod(1.0),
20627:   mVideoTrack(-1),
20627:   mFramerate(0.0),
20627:   mAudioRate(0),
20627:   mAudioChannels(0),
20627:   mAudioTrack(-1),
20627:   mBufferingStart(0),
20627:   mBufferingBytes(0),
20627:   mLastFrameTime(0),
20627:   mState(DECODER_STATE_DECODING_METADATA),
20627:   mSeekTime(0.0),
20627:   mCurrentFrameTime(0.0),
20776:   mVolume(1.0),
21542:   mDuration(-1),
21542:   mContentLength(-1),
21542:   mSeekable(PR_TRUE),
20776:   mPositionChangeQueued(PR_FALSE)
19690: {
19690: }
19675: 
20627: nsOggDecodeStateMachine::~nsOggDecodeStateMachine()
19690: {
20627:   while (!mDecodedFrames.IsEmpty()) {
20627:     delete mDecodedFrames.Pop();
20627:   }
20627:   oggplay_close(mPlayer);
20627: }
20627: 
20627: OggPlayErrorCode nsOggDecodeStateMachine::DecodeFrame()
20627: {
20627:   NS_ASSERTION(mState > DECODER_STATE_DECODING_METADATA, "DecodeFrame() called during invalid state");
20627:   return oggplay_step_decoding(mPlayer);
20627: }
20627: 
20627: nsOggDecodeStateMachine::FrameData* nsOggDecodeStateMachine::NextFrame()
20627: {
20627:   NS_ASSERTION(mState > DECODER_STATE_DECODING_METADATA, "NextFrame() called during invalid state");
20627:   OggPlayCallbackInfo** info = oggplay_buffer_retrieve_next(mPlayer);
20627:   if (!info)
20627:     return nsnull;
20627: 
20627:   FrameData* frame = new FrameData();
20627:   if (!frame) {
20627:     return nsnull;
20627:   }
20627: 
20627:   frame->mTime = mLastFrameTime;
20627:   mLastFrameTime += mCallbackPeriod;
20627:   int num_tracks = oggplay_get_num_tracks(mPlayer);
20627:   float audioTime = 0.0;
20627:   float videoTime = 0.0;
20627: 
20627:   if (mVideoTrack != -1 &&
20627:       num_tracks > mVideoTrack &&
20627:       oggplay_callback_info_get_type(info[mVideoTrack]) == OGGPLAY_YUV_VIDEO) {
20627:     OggPlayDataHeader** headers = oggplay_callback_info_get_headers(info[mVideoTrack]);
20627:     videoTime = ((float)oggplay_callback_info_get_presentation_time(headers[0]))/1000.0;
20627:     HandleVideoData(frame, mVideoTrack, oggplay_callback_info_get_video_data(headers[0]));
20627:   }
20627: 
20627:   if (mAudioTrack != -1 &&
20627:       num_tracks > mAudioTrack &&
20627:       oggplay_callback_info_get_type(info[mAudioTrack]) == OGGPLAY_FLOATS_AUDIO) {
20627:     OggPlayDataHeader** headers = oggplay_callback_info_get_headers(info[mAudioTrack]);
20627:     audioTime = ((float)oggplay_callback_info_get_presentation_time(headers[0]))/1000.0;
20627:     int required = oggplay_callback_info_get_required(info[mAudioTrack]);
20627:     for (int j = 0; j < required; ++j) {
20627:       int size = oggplay_callback_info_get_record_size(headers[j]);
20627:       OggPlayAudioData* audio_data = oggplay_callback_info_get_audio_data(headers[j]);
20627:       HandleAudioData(frame, audio_data, size);
20627:     }
20627:   }
20627: 
20627:   // Pick one stream to act as the reference track to indicate if the
20627:   // stream has ended, seeked, etc.
20627:   if (mVideoTrack >= 0 )
20627:     frame->mState = oggplay_callback_info_get_stream_info(info[mVideoTrack]);
20627:   else if (mAudioTrack >= 0)
20627:     frame->mState = oggplay_callback_info_get_stream_info(info[mAudioTrack]);
20627:   else
20627:     frame->mState = OGGPLAY_STREAM_UNINITIALISED;
20627: 
20627:   frame->mDecodedFrameTime = mVideoTrack == -1 ? audioTime : videoTime;
20627: 
20627:   oggplay_buffer_release(mPlayer, info);
20627:   return frame;
20627: }
20627: 
20627: void nsOggDecodeStateMachine::HandleVideoData(FrameData* aFrame, int aTrackNum, OggPlayVideoData* aVideoData) {
20627:   if (!aVideoData)
20627:     return;
20627: 
20627:   int y_width;
20627:   int y_height;
20627:   oggplay_get_video_y_size(mPlayer, aTrackNum, &y_width, &y_height);
20627:   int uv_width;
20627:   int uv_height;
20627:   oggplay_get_video_uv_size(mPlayer, aTrackNum, &uv_width, &uv_height);
20627: 
20627:   if (y_width >= MAX_VIDEO_WIDTH || y_height >= MAX_VIDEO_HEIGHT) {
20627:     return;
20627:   }
20627: 
20627:   aFrame->mVideoWidth = y_width;
20627:   aFrame->mVideoHeight = y_height;
20627:   aFrame->mVideoData = new unsigned char[y_width * y_height * 4];
20627:   if (!aFrame->mVideoData) {
20627:     return;
20627:   }
20627: 
20627:   OggPlayYUVChannels yuv;
20627:   OggPlayRGBChannels rgb;
20627:       
20627:   yuv.ptry = aVideoData->y;
20627:   yuv.ptru = aVideoData->u;
20627:   yuv.ptrv = aVideoData->v;
20627:   yuv.uv_width = uv_width;
20627:   yuv.uv_height = uv_height;
20627:   yuv.y_width = y_width;
20627:   yuv.y_height = y_height;
20627:       
20627:   rgb.ptro = aFrame->mVideoData;
20627:   rgb.rgb_width = aFrame->mVideoWidth;
20627:   rgb.rgb_height = aFrame->mVideoHeight;
20627: 
20627:   oggplay_yuv2bgr(&yuv, &rgb);
20627: }
20627: 
20627: void nsOggDecodeStateMachine::HandleAudioData(FrameData* aFrame, OggPlayAudioData* aAudioData, int aSize) {
20627:   // 'aSize' is number of samples. Multiply by number of channels to
20627:   // get the actual number of floats being sent.
20627:   int size = aSize * mAudioChannels;
20627: 
20627:   aFrame->mAudioData.AppendElements(reinterpret_cast<float*>(aAudioData), size);
20627: }
20627: 
20627: void nsOggDecodeStateMachine::PlayFrame() {
20627:   // Play a frame of video and/or audio data.
20627:   // If we are playing we open the audio stream if needed
20627:   // If there are decoded frames in the queue a single frame
20627:   // is popped off and played if it is time for that frame
20627:   // to display. 
20627:   // If it is not time yet to display the frame, we either
20627:   // continue decoding frames, or wait until it is time for
20627:   // the frame to display if the queue is full.
20627:   //
20627:   // If the decode state is not PLAYING then we just exit
20627:   // so we can continue decoding frames. If the queue is
20627:   // full we wait for a state change.
20627:   nsAutoMonitor mon(mDecoder->GetMonitor());
20627: 
20627:   if (mDecoder->GetState() == nsOggDecoder::PLAY_STATE_PLAYING) {
20627:     if (!mPlaying) {
20627:       StartPlayback();
20627:     }
20627: 
20627:     if (!mDecodedFrames.IsEmpty()) {
20627:       FrameData* frame = mDecodedFrames.Peek();
20627:       if (frame->mState == OGGPLAY_STREAM_JUST_SEEKED) {
20627:         // After returning from a seek all mTime members of
20627:         // FrameData start again from a time position of 0.
20627:         // Reset the play start time.
20627:         mPlayStartTime = PR_IntervalNow();
20627:         mPauseDuration = 0;
20627:       }
20627: 
20627:       double time = (PR_IntervalToMilliseconds(PR_IntervalNow()-mPlayStartTime-mPauseDuration)/1000.0);
20627:       if (time >= frame->mTime) {
20627:         mDecodedFrames.Pop();
20627:         // Audio for the current frame is played, but video for the next frame
20627:         // is displayed, to account for lag from the time the audio is written
20627:         // to when it is played. This will go away when we move to a/v sync
20627:         // using the audio hardware clock.
20627:         PlayVideo(mDecodedFrames.IsEmpty() ? frame : mDecodedFrames.Peek());
20627:         PlayAudio(frame);
20776:         UpdatePlaybackPosition(frame->mDecodedFrameTime);
20627:         delete frame;
19690:       }
19690:       else {
20627:         // If the queue of decoded frame is full then we wait for the
20627:         // approximate time until the next frame. 
20627:         if (mDecodedFrames.IsFull()) {
20627:           mon.Wait(PR_MillisecondsToInterval(PRInt64((frame->mTime - time)*1000)));
20627:           if (mState == DECODER_STATE_SHUTDOWN) {
20627:             return;
19690:           }
20627:         }
20627:       }
20627:     }
20627:   }
20627:   else {
20627:     if (mPlaying) {
20627:       StopPlayback();
20627:     }
20627: 
20627:     if (mDecodedFrames.IsFull() && mState == DECODER_STATE_DECODING) {
20627:       mon.Wait();
20627:       if (mState == DECODER_STATE_SHUTDOWN) {
20627:         return;
20627:       }
20627:     }
20627:   }
20627: }
20627: 
20627: void nsOggDecodeStateMachine::PlayVideo(FrameData* aFrame)
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "PlayVideo() called without acquiring decoder monitor");
20627:   if (aFrame) {
20627:     if (aFrame->mVideoData) {
20627:       nsAutoLock lock(mDecoder->mVideoUpdateLock);
20627: 
20627:       mDecoder->SetRGBData(aFrame->mVideoWidth, aFrame->mVideoHeight, mFramerate, aFrame->mVideoData);
20627:     }
20627:   }
20627: }
20627: 
20627: PRBool nsOggDecodeStateMachine::PlayAudio(FrameData* aFrame)
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "PlayAudio() called without acquiring decoder monitor");
20627:   if (mAudioStream && aFrame && !aFrame->mAudioData.IsEmpty()) {
20627:     if (PRUint32(mAudioStream->Available()) < aFrame->mAudioData.Length())
20627:       return PR_FALSE;
20627: 
20627:     mAudioStream->Write(aFrame->mAudioData.Elements(), aFrame->mAudioData.Length());
20627:   }
20627: 
20627:   return PR_TRUE;
20627: }
20627: 
20627: void nsOggDecodeStateMachine::OpenAudioStream()
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "OpenAudioStream() called without acquiring decoder monitor");
20627:   mAudioStream = new nsAudioStream();
20627:   if (!mAudioStream) {
20627:     LOG(PR_LOG_ERROR, ("Could not create audio stream"));
20627:   }
20627:   else {
21554:     mAudioStream->Init(mAudioChannels, mAudioRate, nsAudioStream::FORMAT_FLOAT32_LE);
20627:     mAudioStream->SetVolume(mVolume);
20627:   }
20627: }
20627: 
20627: void nsOggDecodeStateMachine::CloseAudioStream()
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "CloseAudioStream() called without acquiring decoder monitor");
20627:   if (mAudioStream) {
20627:     mAudioStream->Shutdown();
20627:     mAudioStream = nsnull;
20627:   }
20627: }
20627: 
20627: void nsOggDecodeStateMachine::StartAudio()
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "StartAudio() called without acquiring decoder monitor");
20627:   if (HasAudio()) {
20627:     OpenAudioStream();
20627:   }
20627: }
20627: 
20627: void nsOggDecodeStateMachine::StopAudio()
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "StopAudio() called without acquiring decoder monitor");
20627:   if (HasAudio()) {
20627:     CloseAudioStream();
20627:   }
20627: }
20627: 
20627: void nsOggDecodeStateMachine::StartPlayback()
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "StartPlayback() called without acquiring decoder monitor");
20627:   StartAudio();
20627:   mPlaying = PR_TRUE;
20627: 
20627:   // If this is the very first play, then set the initial start time
20627:   if (mPlayStartTime == 0) {
20627:     mPlayStartTime = PR_IntervalNow();
20627:   }
20627: 
20627:   // If we have been paused previously, then compute duration spent paused
20627:   if (mPauseStartTime != 0) {
20627:     mPauseDuration += PR_IntervalNow() - mPauseStartTime;
20627:   }
20627: }
20627: 
20627: void nsOggDecodeStateMachine::StopPlayback()
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "StopPlayback() called without acquiring decoder monitor");
20627:   StopAudio();
20627:   mPlaying = PR_FALSE;
20627:   mPauseStartTime = PR_IntervalNow();
20627: }
20627: 
20776: void nsOggDecodeStateMachine::UpdatePlaybackPosition(float aTime)
20776: {
20776:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "UpdatePlaybackPosition() called without acquiring decoder monitor");
20776:   mCurrentFrameTime = aTime;
20776:   if (!mPositionChangeQueued) {
20776:     mPositionChangeQueued = PR_TRUE;
20776:     nsCOMPtr<nsIRunnable> event =
20776:       NS_NEW_RUNNABLE_METHOD(nsOggDecoder, mDecoder, PlaybackPositionChanged);
20776:     NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
20776:   }
20776: }
20776: 
20776: void nsOggDecodeStateMachine::ClearPositionChangeFlag()
20776: {
20776:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "ClearPositionChangeFlag() called without acquiring decoder monitor");
20776:   mPositionChangeQueued = PR_FALSE;
20776: }
20776: 
20627: float nsOggDecodeStateMachine::GetVolume()
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "GetVolume() called without acquiring decoder monitor");
20627:   return mVolume;
20627: }
20627: 
20627: void nsOggDecodeStateMachine::SetVolume(float volume)
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "SetVolume() called without acquiring decoder monitor");
20627:   if (mAudioStream) {
20627:     mAudioStream->SetVolume(volume);
20627:   }
20627: 
20627:   mVolume = volume;
20627: }
20627: 
20627: float nsOggDecodeStateMachine::GetCurrentTime()
20627: {
20627:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "GetCurrentTime() called without acquiring decoder monitor");
20627:   return mCurrentFrameTime;
20627: }
20627: 
21542: PRInt64 nsOggDecodeStateMachine::GetDuration()
21542: {
21542:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "GetDuration() called without acquiring decoder monitor");
21542:   return mDuration;
21542: }
21542: 
21542: void nsOggDecodeStateMachine::SetContentLength(PRInt64 aLength)
21542: {
21542:   //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "SetContentLength() called without acquiring decoder monitor");
21542:   mContentLength = aLength;
21542: }
21542: 
21542: void nsOggDecodeStateMachine::SetSeekable(PRBool aSeekable)
21542: {
21542:    //  NS_ASSERTION(PR_InMonitor(mDecoder->GetMonitor()), "SetSeekable() called without acquiring decoder monitor");
21542:   mSeekable = aSeekable;
21542: }
20627: 
20627: void nsOggDecodeStateMachine::Shutdown()
20627: {
20627:   // oggplay_prepare_for_close cannot be undone. Once called, the
20627:   // mPlayer object cannot decode any more frames. Once we've entered
20627:   // the shutdown state here there's no going back.
20627:   nsAutoMonitor mon(mDecoder->GetMonitor());
20627:   if (mPlayer) {
20627:     oggplay_prepare_for_close(mPlayer);
20627:   }
20627:   mState = DECODER_STATE_SHUTDOWN;
20627:   mon.NotifyAll();
20627: }
20627: 
20627: void nsOggDecodeStateMachine::Decode()
20627: {
20627:   // When asked to decode, switch to decoding only if
20627:   // we are currently buffering.
20627:   nsAutoMonitor mon(mDecoder->GetMonitor());
20627:   if (mState == DECODER_STATE_BUFFERING) {
20627:     mState = DECODER_STATE_DECODING;
20627:   }
20627: }
20627: 
20627: void nsOggDecodeStateMachine::Seek(float aTime)
20627: {
20627:   nsAutoMonitor mon(mDecoder->GetMonitor());
20627:   mSeekTime = aTime;
20627:   mState = DECODER_STATE_SEEKING;
20627: }
20627: 
20627: nsresult nsOggDecodeStateMachine::Run()
20627: {
21756:   nsChannelReader* reader = mDecoder->GetReader();
21756:   NS_ENSURE_TRUE(reader, NS_ERROR_NULL_POINTER);
20627:   while (PR_TRUE) {
20627:    nsAutoMonitor mon(mDecoder->GetMonitor());
20627:    switch(mState) {
20627:     case DECODER_STATE_SHUTDOWN:
20627:       return NS_OK;
20627: 
20627:     case DECODER_STATE_DECODING_METADATA:
20627:       mon.Exit();
20627:       LoadOggHeaders();
20627:       mon.Enter();
20627:       
20627:       if (mState == DECODER_STATE_DECODING_METADATA) {
20627:         mState = DECODER_STATE_DECODING_FIRSTFRAME;
20627:       }
20627:       break;
20627: 
20627:     case DECODER_STATE_DECODING_FIRSTFRAME:
20627:       {
20627:         OggPlayErrorCode r;
20627:         do {
20627:           mon.Exit();
20627:           r = DecodeFrame();
20627:           mon.Enter();
20627:         } while (mState != DECODER_STATE_SHUTDOWN && r == E_OGGPLAY_TIMEOUT);
20627: 
20627:         if (mState == DECODER_STATE_SHUTDOWN)
20627:           continue;
20627: 
20627:         mLastFrameTime = 0;
20627:         FrameData* frame = NextFrame();
20627:         if (frame) {
20627:           mDecodedFrames.Push(frame);
20776:           UpdatePlaybackPosition(frame->mDecodedFrameTime);
20627:           PlayVideo(frame);
20627:         }
20627: 
20627:         nsCOMPtr<nsIRunnable> event =
20627:           NS_NEW_RUNNABLE_METHOD(nsOggDecoder, mDecoder, FirstFrameLoaded);
20627:         NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
20627: 
20627:         if (mState == DECODER_STATE_DECODING_FIRSTFRAME) {
20627:           mState = DECODER_STATE_DECODING;
20627:         }
20627:       }
20627:       break;
20627: 
20627:     case DECODER_STATE_DECODING:
20627:       {
20627:         // Before decoding check if we should buffer more data
21756:         if (reader->DownloadRate() >= 0 &&
21756:             reader->Available() < reader->PlaybackRate() * BUFFERING_SECONDS_LOW_WATER_MARK) {
20627:           if (mDecoder->GetState() == nsOggDecoder::PLAY_STATE_PLAYING) {
20627:             if (mPlaying) {
20627:               StopPlayback();
20627:             }
20627:           }
20627: 
20627:           mBufferingStart = PR_IntervalNow();
21756:           mBufferingBytes = PRUint32(BUFFERING_RATE(reader->PlaybackRate()) * BUFFERING_WAIT);
20627:           mState = DECODER_STATE_BUFFERING;
20627: 
20627:           nsCOMPtr<nsIRunnable> event =
20627:             NS_NEW_RUNNABLE_METHOD(nsOggDecoder, mDecoder, BufferingStarted);
20627:           NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
20627:         }
20627:         else {
20627:           if (!mDecodedFrames.IsFull()) {
20627:             mon.Exit();
20627:             OggPlayErrorCode r = DecodeFrame();
20627:             mon.Enter();
20627: 
20627:             if (mState == DECODER_STATE_SHUTDOWN)
20627:               continue;
20627: 
20627:             // Get the decoded frame and store it in our queue of decoded frames
20627:             FrameData* frame = NextFrame();
20627:             if (frame) {
20627:               mDecodedFrames.Push(frame);
20627:             }
20627: 
20627:             if (r != E_OGGPLAY_CONTINUE &&
20627:                 r != E_OGGPLAY_USER_INTERRUPT &&
20627:                 r != E_OGGPLAY_TIMEOUT)  {
20627:               mState = DECODER_STATE_COMPLETED;
20627:             }
20627:           }
20627: 
20627:           // Show at least the first frame if we're not playing
20627:           // so we have a poster frame on initial load and after seek.
20627:           if (!mPlaying && !mDecodedFrames.IsEmpty()) {
20627:             PlayVideo(mDecodedFrames.Peek());
20627:           }
20627: 
20627:           PlayFrame();
20627:         }
20627:       }
20627:       break;
20627: 
20627:     case DECODER_STATE_SEEKING:
20627:       {
20627:         // During the seek, don't have a lock on the decoder state,
20627:         // otherwise long seek operations can block the main thread.
20627:         // The events dispatched to the main thread are SYNC calls.
20627:         // These calls are made outside of the decode monitor lock so
20627:         // it is safe for the main thread to makes calls that acquire
20627:         // the lock since it won't deadlock. We check the state when
20627:         // acquiring the lock again in case shutdown has occurred
20627:         // during the time when we didn't have the lock.
20627:         float seekTime = mSeekTime;
20627:         mon.Exit();
20627:         nsCOMPtr<nsIRunnable> startEvent = 
20627:           NS_NEW_RUNNABLE_METHOD(nsOggDecoder, mDecoder, SeekingStarted);
20627:         NS_DispatchToMainThread(startEvent, NS_DISPATCH_SYNC);
20627:         
20627:         oggplay_seek(mPlayer, ogg_int64_t(seekTime * 1000));
20627: 
20627:         mon.Enter();
20627:         if (mState == DECODER_STATE_SHUTDOWN)
20627:           continue;
20627: 
20627:         // Remove all frames decoded prior to seek from the queue
20627:         while (!mDecodedFrames.IsEmpty()) {
20627:           delete mDecodedFrames.Pop();
20627:         }
20627: 
20627:         OggPlayErrorCode r;
20627:         do {
20627:           mon.Exit();
20627:           r = DecodeFrame();
20627:           mon.Enter();
20627:         } while (mState != DECODER_STATE_SHUTDOWN && r == E_OGGPLAY_TIMEOUT);
20627: 
20627:         if (mState == DECODER_STATE_SHUTDOWN)
20627:           continue;
20627: 
20627:         mLastFrameTime = 0;
20627:         FrameData* frame = NextFrame();
20627:         if (frame) {
20627:           mDecodedFrames.Push(frame);
20776:           UpdatePlaybackPosition(frame->mDecodedFrameTime);
20627:           PlayVideo(frame);
20627:         }
20627:         mon.Exit();
20627:         nsCOMPtr<nsIRunnable> stopEvent = 
20627:           NS_NEW_RUNNABLE_METHOD(nsOggDecoder, mDecoder, SeekingStopped);
20627:         NS_DispatchToMainThread(stopEvent, NS_DISPATCH_SYNC);        
20627:         mon.Enter();
20627: 
20627:         if (mState == DECODER_STATE_SEEKING && mSeekTime == seekTime) {
20627:           mState = DECODER_STATE_DECODING;
20627:         }
20627:       }
20627:       break;
20627: 
20627:     case DECODER_STATE_BUFFERING:
20627:       if ((PR_IntervalToMilliseconds(PR_IntervalNow() - mBufferingStart) < BUFFERING_WAIT*1000) &&
21756:           reader->DownloadRate() >= 0 &&            
21756:           reader->Available() < mBufferingBytes) {
20627:         LOG(PR_LOG_DEBUG, 
20627:             ("Buffering data until %d bytes available or %d milliseconds", 
21756:              mBufferingBytes - reader->Available(),
20627:              BUFFERING_WAIT*1000 - (PR_IntervalToMilliseconds(PR_IntervalNow() - mBufferingStart))));
20627:         mon.Wait(PR_MillisecondsToInterval(1000));
20627:         if (mState == DECODER_STATE_SHUTDOWN)
20627:           continue;
20627:       }
20627:       else {
20627:         mState = DECODER_STATE_DECODING;
20627:       }
20627: 
20627:       if (mState != DECODER_STATE_BUFFERING) {
20627:         nsCOMPtr<nsIRunnable> event = 
20627:           NS_NEW_RUNNABLE_METHOD(nsOggDecoder, mDecoder, BufferingStopped);
20627:         NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
20627:         if (mDecoder->GetState() == nsOggDecoder::PLAY_STATE_PLAYING) {
20627:           if (!mPlaying) {
20627:             StartPlayback();
20627:           }
20627:         }
20627:       }
20627: 
20627:       break;
20627: 
20627:     case DECODER_STATE_COMPLETED:
20627:       {
20627:         while (mState != DECODER_STATE_SHUTDOWN &&
20627:                !mDecodedFrames.IsEmpty()) {
20627:           PlayFrame();
20776:           if (mState != DECODER_STATE_SHUTDOWN) {
20776:             // Wait for the time of one frame so we don't tight loop
20776:             // and we need to release the monitor so timeupdate and
20776:             // invalidate's on the main thread can occur.
20776:             mon.Wait(PR_MillisecondsToInterval(PRInt64(mCallbackPeriod*1000)));
20627:           }
20627:         }
20627: 
20627:         if (mState == DECODER_STATE_SHUTDOWN)
20627:           continue;
20627: 
20627:         nsCOMPtr<nsIRunnable> event =
20627:           NS_NEW_RUNNABLE_METHOD(nsOggDecoder, mDecoder, PlaybackEnded);
20627:         NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
20627:         do {
20627:           mon.Wait();
20627:         } while (mState != DECODER_STATE_SHUTDOWN);
20627:       }
20627:       break;
20627:     }
20627:   }
20627: 
19690:   return NS_OK;
19690: }
19675: 
20627: void nsOggDecodeStateMachine::LoadOggHeaders() 
20627: {
20627:   LOG(PR_LOG_DEBUG, ("Loading Ogg Headers"));
21756:   mPlayer = oggplay_open_with_reader(mDecoder->GetReader());
20627:   if (mPlayer) {
20627:     LOG(PR_LOG_DEBUG, ("There are %d tracks", oggplay_get_num_tracks(mPlayer)));
19675: 
20627:     for (int i = 0; i < oggplay_get_num_tracks(mPlayer); ++i) {
20627:       LOG(PR_LOG_DEBUG, ("Tracks %d: %s", i, oggplay_get_track_typename(mPlayer, i)));
20627:       if (mVideoTrack == -1 && oggplay_get_track_type(mPlayer, i) == OGGZ_CONTENT_THEORA) {
20627:         oggplay_set_callback_num_frames(mPlayer, i, 1);
20627:         mVideoTrack = i;
20627:         int fpsd, fpsn;
20627:         oggplay_get_video_fps(mPlayer, i, &fpsd, &fpsn);
20627:         mFramerate = fpsd == 0 ? 0.0 : float(fpsn)/float(fpsd);
20627:         mCallbackPeriod = 1.0 / mFramerate;
20627:         LOG(PR_LOG_DEBUG, ("Frame rate: %f", mFramerate));
20627:       }
20627:       else if (mAudioTrack == -1 && oggplay_get_track_type(mPlayer, i) == OGGZ_CONTENT_VORBIS) {
20627:         mAudioTrack = i;
20627:         oggplay_set_offset(mPlayer, i, OGGPLAY_AUDIO_OFFSET);
20627:         oggplay_get_audio_samplerate(mPlayer, i, &mAudioRate);
20627:         oggplay_get_audio_channels(mPlayer, i, &mAudioChannels);
20627:         LOG(PR_LOG_DEBUG, ("samplerate: %d, channels: %d", mAudioRate, mAudioChannels));
19690:       }
19690:  
20627:       if (oggplay_set_track_active(mPlayer, i) < 0)  {
20627:         LOG(PR_LOG_ERROR, ("Could not set track %d active", i));
19690:       }
19690:     }
19690: 
20627:     if (mVideoTrack == -1) {
20627:       oggplay_set_callback_num_frames(mPlayer, mAudioTrack, OGGPLAY_FRAMES_PER_CALLBACK);
20627:       mCallbackPeriod = 1.0 / (float(mAudioRate) / OGGPLAY_FRAMES_PER_CALLBACK);
19690:     }
20627:     LOG(PR_LOG_DEBUG, ("Callback Period: %f", mCallbackPeriod));
20627: 
20627:     oggplay_use_buffer(mPlayer, OGGPLAY_BUFFER_SIZE);
20627: 
21542:     // Get the duration from the Ogg file. We only do this if the
21542:     // content length of the resource is known as we need to seek
21542:     // to the end of the file to get the last time field. We also
21542:     // only do this if the resource is seekable.
21542:     {
21542:       nsAutoMonitor mon(mDecoder->GetMonitor());
21542:       if (mState != DECODER_STATE_SHUTDOWN &&
21542:           mContentLength >= 0 && 
21542:           mSeekable) {
21542:         // Don't hold the monitor during the duration
21542:         // call as it can issue seek requests
21542:         // and blocks until these are completed.
21542:         mon.Exit();
21542:         PRInt64 d = oggplay_get_duration(mPlayer);
21542:         mon.Enter();
21542:         mDuration = d;
21542:       }
21542:       if (mState == DECODER_STATE_SHUTDOWN)
21542:         return;
21542:     }
21542: 
20627:     // Inform the element that we've loaded the Ogg metadata
20627:     nsCOMPtr<nsIRunnable> metadataLoadedEvent = 
20627:       NS_NEW_RUNNABLE_METHOD(nsOggDecoder, mDecoder, MetadataLoaded); 
20627:     
20627:     NS_DispatchToMainThread(metadataLoadedEvent, NS_DISPATCH_NORMAL);
19690:   }
19690: }
19675: 
19690: NS_IMPL_THREADSAFE_ISUPPORTS1(nsOggDecoder, nsIObserver)
19675: 
19690: void nsOggDecoder::Pause() 
19690: {
20627:   nsAutoMonitor mon(mMonitor);
20627:   if (mPlayState == PLAY_STATE_SEEKING) {
20627:     mNextState = PLAY_STATE_PAUSED;
19690:     return;
19675:   }
19675: 
20627:   ChangeState(PLAY_STATE_PAUSED);
19690: }
19690: 
19690: float nsOggDecoder::GetVolume()
19690: {
20627:   nsAutoMonitor mon(mMonitor);
20627:   return mDecodeStateMachine ? mDecodeStateMachine->GetVolume() : mInitialVolume;
19690: }
19690: 
19690: void nsOggDecoder::SetVolume(float volume)
19690: {
20627:   nsAutoMonitor mon(mMonitor);
19690:   mInitialVolume = volume;
20627: 
20627:   if (mDecodeStateMachine) {
20627:     mDecodeStateMachine->SetVolume(volume);
19690:   }
19690: }
19690: 
19690: float nsOggDecoder::GetDuration()
19690: {
21542:   if (mDuration >= 0) {
21542:      return static_cast<float>(mDuration) / 1000.0;
21542:   }
21542: 
21542:   return std::numeric_limits<float>::quiet_NaN();
19690: }
19690: 
19690: nsOggDecoder::nsOggDecoder() :
20627:   nsMediaDecoder(),
19690:   mBytesDownloaded(0),
20776:   mCurrentTime(0.0),
20627:   mInitialVolume(0.0),
20627:   mRequestedSeekTime(-1.0),
21542:   mContentLength(-1),
19690:   mNotifyOnShutdown(PR_FALSE),
21542:   mSeekable(PR_TRUE),
19690:   mReader(0),
20627:   mMonitor(0),
20627:   mPlayState(PLAY_STATE_PAUSED),
22529:   mNextState(PLAY_STATE_PAUSED)
19690: {
20627:   MOZ_COUNT_CTOR(nsOggDecoder);
19690: }
19690: 
19690: PRBool nsOggDecoder::Init() 
19690: {
20627:   mMonitor = nsAutoMonitor::NewMonitor("media.decoder");
20627:   return mMonitor && nsMediaDecoder::Init();
20627: }
19690: 
20627: // An event that gets posted to the main thread, when the media
20627: // element is being destroyed, to destroy the decoder. Since the
20627: // decoder shutdown can block and post events this cannot be done
20627: // inside destructor calls. So this event is posted asynchronously to
20627: // the main thread to perform the shutdown. It keeps a strong
20627: // reference to the decoder to ensure it does not get deleted when the
20627: // element is deleted.
20627: class nsOggDecoderShutdown : public nsRunnable
20627: {
20627: public:
20627:   nsOggDecoderShutdown(nsOggDecoder* aDecoder) :
20627:     mDecoder(aDecoder)
20627:   {
20627:   }
19690: 
20627:   NS_IMETHOD Run()
20627:   {
20627:     mDecoder->Stop();
20627:     return NS_OK;
19690:   }
19690: 
20627: private:
20627:   nsRefPtr<nsOggDecoder> mDecoder;
20627: };
20627: 
21819: 
19690: void nsOggDecoder::Shutdown() 
19690: {
22529:   mShuttingDown = PR_TRUE;
22529: 
20627:   ChangeState(PLAY_STATE_SHUTDOWN);
20627:   nsMediaDecoder::Shutdown();
19690: 
20627:   nsCOMPtr<nsIRunnable> event = new nsOggDecoderShutdown(this);
20627:   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
19690: }
19690: 
19690: nsOggDecoder::~nsOggDecoder()
19690: {
20627:   MOZ_COUNT_DTOR(nsOggDecoder);
20627:   nsAutoMonitor::DestroyMonitor(mMonitor);
19675: }
19675: 
21079: nsresult nsOggDecoder::Load(nsIURI* aURI, nsIChannel* aChannel,
21079:                             nsIStreamListener** aStreamListener)
19675: {
21756:   // Reset Stop guard flag flag, else shutdown won't occur properly when
21756:   // reusing decoder.
22529:   mStopping = PR_FALSE;
21756: 
21079:   if (aStreamListener) {
21079:     *aStreamListener = nsnull;
21079:   }
21079: 
21079:   if (aURI) {
21079:     NS_ASSERTION(!aStreamListener, "No listener should be requested here");
19690:     mURI = aURI;
21079:   } else {
21079:     NS_ASSERTION(aChannel, "Either a URI or a channel is required");
21079:     NS_ASSERTION(aStreamListener, "A listener should be requested here");
21079: 
21079:     // If the channel was redirected, we want the post-redirect URI;
21079:     // but if the URI scheme was expanded, say from chrome: to jar:file:,
21079:     // we want the original URI.
21079:     nsresult rv = NS_GetFinalChannelURI(aChannel, getter_AddRefs(mURI));
21079:     NS_ENSURE_SUCCESS(rv, rv);
21079:   }
19690: 
22408:   StartProgress();
22408: 
20627:   RegisterShutdownObserver();
20627: 
19690:   mReader = new nsChannelReader();
19690:   NS_ENSURE_TRUE(mReader, NS_ERROR_OUT_OF_MEMORY);
19690: 
21079:   nsresult rv = mReader->Init(this, mURI, aChannel, aStreamListener);
19690:   NS_ENSURE_SUCCESS(rv, rv);
19690: 
19690:   rv = NS_NewThread(getter_AddRefs(mDecodeThread));
19690:   NS_ENSURE_SUCCESS(rv, rv);
19690: 
21756:   mDecodeStateMachine = new nsOggDecodeStateMachine(this);
21542:   {
21542:     nsAutoMonitor mon(mMonitor);
21542:     mDecodeStateMachine->SetContentLength(mContentLength);
21542:     mDecodeStateMachine->SetSeekable(mSeekable);
21542:   }
19690: 
20627:   ChangeState(PLAY_STATE_LOADING);
19690: 
20627:   return mDecodeThread->Dispatch(mDecodeStateMachine, NS_DISPATCH_NORMAL);
20627: }
20627: 
20627: nsresult nsOggDecoder::Play()
20627: {
20627:   nsAutoMonitor mon(mMonitor);
20627:   if (mPlayState == PLAY_STATE_SEEKING) {
20627:     mNextState = PLAY_STATE_PLAYING;
20627:     return NS_OK;
20627:   }
20627: 
20627:   ChangeState(PLAY_STATE_PLAYING);
19690: 
19690:   return NS_OK;
19675: }
19675: 
20627: nsresult nsOggDecoder::Seek(float aTime)
19690: {
20627:   nsAutoMonitor mon(mMonitor);
20627: 
20627:   if (aTime < 0.0)
20627:     return NS_ERROR_FAILURE;
20627: 
20627:   if (mPlayState == PLAY_STATE_LOADING && aTime == 0.0) {
19690:     return NS_OK;
19690:   }
19675: 
20627:   mRequestedSeekTime = aTime;
20627: 
20627:   // If we are already in the seeking state, then setting mRequestedSeekTime
20627:   // above will result in the new seek occurring when the current seek
20627:   // completes.
20627:   if (mPlayState != PLAY_STATE_SEEKING) {
20627:     mNextState = mPlayState;
20627:     ChangeState(PLAY_STATE_SEEKING);
19675:   }
19675: 
19690:   return NS_OK;
19690: }
19690: 
19690: nsresult nsOggDecoder::PlaybackRateChanged()
19690: {
19690:   return NS_ERROR_NOT_IMPLEMENTED;
19690: }
19690: 
19690: void nsOggDecoder::Stop()
19690: {
21756:   NS_ASSERTION(NS_IsMainThread(), 
21756:                "nsOggDecoder::Stop called on non-main thread");  
21756:   
22529:   if (mStopping)
21756:     return;
22529: 
22529:   mStopping = PR_TRUE;
21756: 
20627:   ChangeState(PLAY_STATE_ENDED);
20627: 
19690:   StopProgress();
20627: 
20627:   // Force any outstanding seek and byterange requests to complete
20627:   // to prevent shutdown from deadlocking.
20627:   if (mReader) {
20627:     mReader->Cancel();
20627:   }
20627: 
20627:   // Shutdown must be on called the mDecodeStateMachine before deleting.
20627:   // This is required to ensure that the state machine isn't running
20627:   // in the thread and using internal objects when it is deleted.
20627:   if (mDecodeStateMachine) {
20627:     mDecodeStateMachine->Shutdown();
20627:   }
20627: 
20627:   // The state machines must be Shutdown() before the thread is
20627:   // Shutdown. The Shutdown() on the state machine unblocks any
20627:   // blocking calls preventing the thread Shutdown from deadlocking.
19690:   if (mDecodeThread) {
19690:     mDecodeThread->Shutdown();
19690:     mDecodeThread = nsnull;
19690:   }
20627: 
20627:   mDecodeStateMachine = nsnull;
21756:   mReader = nsnull;
20627:   UnregisterShutdownObserver();
19690: }
19690: 
16300: float nsOggDecoder::GetCurrentTime()
16300: {
20776:   return mCurrentTime;
16300: }
16300: 
16300: void nsOggDecoder::GetCurrentURI(nsIURI** aURI)
16300: {
16300:   NS_IF_ADDREF(*aURI = mURI);
16300: }
16300: 
18910: nsIPrincipal* nsOggDecoder::GetCurrentPrincipal()
18910: {
20627:   if (!mReader) {
18910:     return nsnull;
20627:   }
18910: 
18910:   return mReader->GetCurrentPrincipal();
18910: }
16300: 
16300: void nsOggDecoder::MetadataLoaded()
16300: {
22529:   if (mShuttingDown)
22529:     return;
22529: 
21542:   {
21542:     nsAutoMonitor mon(mMonitor);
21542:     mDuration = mDecodeStateMachine ? mDecodeStateMachine->GetDuration() : -1;
21542:   }
21542: 
16300:   if (mElement) {
16300:     mElement->MetadataLoaded();
16300:   }
16300: }
16300: 
16300: void nsOggDecoder::FirstFrameLoaded()
16300: {
22529:   if (mShuttingDown)
22529:     return;
22529: 
16300:   if (mElement) {
16300:     mElement->FirstFrameLoaded();
16300:   }
20627: 
20627:   // The element can run javascript via events
20627:   // before reaching here, so only change the 
20627:   // state if we're still set to the original
20627:   // loading state.
20627:   nsAutoMonitor mon(mMonitor);
20627:   if (mPlayState == PLAY_STATE_LOADING) {
20627:     if (mRequestedSeekTime >= 0.0) {
20627:       ChangeState(PLAY_STATE_SEEKING);
20627:     }
20627:     else {
20627:       ChangeState(mNextState);
20627:     }
20627:   }
16300: }
16300: 
16300: void nsOggDecoder::ResourceLoaded()
16300: {
22529:   if (mShuttingDown)
22529:     return;
22529: 
16300:   if (mElement) {
16300:     mElement->ResourceLoaded();
16300:   }
22408:   StopProgress();
16300: }
16300: 
21394: void nsOggDecoder::NetworkError()
21394: {
22529:   if (mShuttingDown)
22529:     return;
22529: 
21394:   if (mElement)
21394:     mElement->NetworkError();
21394:   Stop();
21394: }
21394: 
20627: PRBool nsOggDecoder::IsSeeking() const
16300: {
20627:   return mPlayState == PLAY_STATE_SEEKING;
20627: }
20627: 
20627: void nsOggDecoder::PlaybackEnded()
20627: {
22529:   if (mShuttingDown)
22529:     return;
22529: 
20627:   Stop();
16300:   if (mElement)  {
20627:     mElement->PlaybackEnded();
16300:   }
16300: }
16300: 
16300: NS_IMETHODIMP nsOggDecoder::Observe(nsISupports *aSubjet,
16300:                                       const char *aTopic,
16300:                                       const PRUnichar *someData)
16300: {
16300:   if (strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
16300:     Shutdown();
16300:   }
16300: 
16300:   return NS_OK;
16300: }
16300: 
20714: PRUint64 nsOggDecoder::GetBytesLoaded()
16300: {
16300:   return mBytesDownloaded;
16300: }
16300: 
20627: PRInt64 nsOggDecoder::GetTotalBytes()
16300: {
20627:   return mContentLength;
20627: }
20627: 
20627: void nsOggDecoder::SetTotalBytes(PRInt64 aBytes)
20627: {
20627:   mContentLength = aBytes;
21542:   if (mDecodeStateMachine) {
21542:     nsAutoMonitor mon(mMonitor);
21542:     mDecodeStateMachine->SetContentLength(aBytes);
21542:   } 
16300: }
16300: 
20714: void nsOggDecoder::UpdateBytesDownloaded(PRUint64 aBytes)
16300: {
16300:   mBytesDownloaded = aBytes;
16300: }
16300: 
16300: void nsOggDecoder::BufferingStopped()
16300: {
22529:   if (mShuttingDown)
22529:     return;
22529: 
16300:   if (mElement) {
16300:     mElement->ChangeReadyState(nsIDOMHTMLMediaElement::CAN_SHOW_CURRENT_FRAME);
16300:   }
16300: }
16300: 
16300: void nsOggDecoder::BufferingStarted()
16300: {
22529:   if (mShuttingDown)
22529:     return;
22529: 
16300:   if (mElement) {
16300:     mElement->ChangeReadyState(nsIDOMHTMLMediaElement::DATA_UNAVAILABLE);
16300:   }
16300: }
20627: 
20627: void nsOggDecoder::SeekingStopped()
20627: {
22529:   if (mShuttingDown)
22529:     return;
22529: 
20627:   {
20627:     nsAutoMonitor mon(mMonitor);
20627: 
20627:     // An additional seek was requested while the current seek was
20627:     // in operation.
20627:     if (mRequestedSeekTime >= 0.0)
20627:       ChangeState(PLAY_STATE_SEEKING);
20627:     else
20627:       ChangeState(mNextState);
20627:   }
20627: 
20627:   if (mElement) {
20627:     mElement->SeekCompleted();
20627:   }
20627: }
20627: 
20627: void nsOggDecoder::SeekingStarted()
20627: {
22529:   if (mShuttingDown)
20627:     return;
20627: 
20627:   if (mElement) {
20627:     mElement->SeekStarted();
20627:   }
20627: }
20627: 
20627: void nsOggDecoder::RegisterShutdownObserver()
20627: {
20627:   if (!mNotifyOnShutdown) {
20627:     nsCOMPtr<nsIObserverService> observerService =
20627:       do_GetService("@mozilla.org/observer-service;1");
20627:     if (observerService) {
20627:       mNotifyOnShutdown = 
20627:         NS_SUCCEEDED(observerService->AddObserver(this, 
20627:                                                   NS_XPCOM_SHUTDOWN_OBSERVER_ID, 
20627:                                                   PR_FALSE));
20627:     }
20627:     else {
20627:       NS_WARNING("Could not get an observer service. Video decoding events may not shutdown cleanly.");
20627:     }
20627:   }
20627: }
20627: 
20627: void nsOggDecoder::UnregisterShutdownObserver()
20627: {
20627:   if (mNotifyOnShutdown) {
20627:     nsCOMPtr<nsIObserverService> observerService =
20627:       do_GetService("@mozilla.org/observer-service;1");
20627:     if (observerService) {
20627:       mNotifyOnShutdown = PR_FALSE;
20627:       observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
20627:     }
20627:   }
20627: }
20627: 
20627: void nsOggDecoder::ChangeState(PlayState aState)
20627: {
21756:   NS_ASSERTION(NS_IsMainThread(), 
21756:                "nsOggDecoder::ChangeState called on non-main thread");   
20627:   nsAutoMonitor mon(mMonitor);
20627: 
20627:   if (mNextState == aState) {
20627:     mNextState = PLAY_STATE_PAUSED;
20627:   }
20627: 
20627:   if (mPlayState == PLAY_STATE_SHUTDOWN) {
20627:     mon.NotifyAll();
20627:     return;
20627:   }
20627: 
20627:   if (mPlayState == PLAY_STATE_ENDED &&
20627:       aState != PLAY_STATE_SHUTDOWN) {
20627:     // If we've completed playback then the decode and display threads
20627:     // have been shutdown. To honor the state change request we need
20627:     // to reload the resource and restart the threads.
21079:     // Like seeking, this will require opening a new channel, which means
21079:     // we may not actually get the same resource --- a server may send
21079:     // us something different.
20627:     mNextState = aState;
20627:     mPlayState = PLAY_STATE_LOADING;
21079:     Load(mURI, nsnull, nsnull);
20627:     return;
20627:   }
20627: 
20627:   mPlayState = aState;
20627:   switch (aState) {
20627:   case PLAY_STATE_PAUSED:
20627:     /* No action needed */
20627:     break;
20627:   case PLAY_STATE_PLAYING:
20627:     mDecodeStateMachine->Decode();
20627:     break;
20627:   case PLAY_STATE_SEEKING:
20627:     mDecodeStateMachine->Seek(mRequestedSeekTime);
20627:     mRequestedSeekTime = -1.0;
20627:     break;
20627:   case PLAY_STATE_LOADING:
20627:     /* No action needed */
20627:     break;
20627:   case PLAY_STATE_START:
20627:     /* No action needed */
20627:     break;
20627:   case PLAY_STATE_ENDED:
20627:     /* No action needed */
20627:     break;
20627:   case PLAY_STATE_SHUTDOWN:
20627:     /* No action needed */
20627:     break;
20627:   }
20627:   mon.NotifyAll();
20627: }
20776: 
20776: void nsOggDecoder::PlaybackPositionChanged()
20776: {
22529:   if (mShuttingDown)
22529:     return;
22529: 
20776:   float lastTime = mCurrentTime;
20776: 
20776:   // Control the scope of the monitor so it is not
20776:   // held while the timeupdate and the invalidate is run.
20776:   {
20776:     nsAutoMonitor mon(mMonitor);
20776: 
20776:     if (mDecodeStateMachine) {
20776:       mCurrentTime = mDecodeStateMachine->GetCurrentTime();
20776:       mDecodeStateMachine->ClearPositionChangeFlag();
20776:     }
20776:   }
20776: 
20776:   // Invalidate the frame so any video data is displayed.
20776:   // Do this before the timeupdate event so that if that
20776:   // event runs JavaScript that queries the media size, the
20776:   // frame has reflowed and the size updated beforehand.
20776:   Invalidate();
20776: 
20776:   if (mElement && lastTime != mCurrentTime) {
20776:     mElement->DispatchSimpleEvent(NS_LITERAL_STRING("timeupdate"));
20776:   }
20776: }
21542: 
21542: void nsOggDecoder::SetSeekable(PRBool aSeekable)
21542: {
21542:   mSeekable = aSeekable;
21542:   if (mDecodeStateMachine) {
21542:     nsAutoMonitor mon(mMonitor);
21542:     mDecodeStateMachine->SetSeekable(aSeekable);
21542:   }
21542: }
21542: 
21542: PRBool nsOggDecoder::GetSeekable()
21542: {
21542:   return mSeekable;
21542: }
21542: 
