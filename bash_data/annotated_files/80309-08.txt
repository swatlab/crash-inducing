58636: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
60001: /* vim: set ts=4 sw=4 tw=80 et: */
58636: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla browser.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications, Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Peter Annema <disttsc@bart.nl>
    1:  *   Dan Rosen <dr@netscape.com>
 1585:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifdef MOZ_LOGGING
    1: // so we can get logging even in release builds (but only for some things)
    1: #define FORCE_PR_LOG 1
    1: #endif
    1: 
    1: #include "nsIBrowserDOMWindow.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsIContent.h"
41930: #include "mozilla/dom/Element.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
28676: #include "nsIDOMStorage.h"
    1: #include "nsPIDOMStorage.h"
    1: #include "nsIDocumentViewer.h"
    1: #include "nsIDocumentLoaderFactory.h"
    1: #include "nsCURILoader.h"
 5528: #include "nsURILoader.h"
    1: #include "nsDocShellCID.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsDOMCID.h"
    1: #include "nsIDOMScriptObjectFactory.h"
    1: #include "nsNetUtil.h"
    1: #include "nsRect.h"
    1: #include "prprf.h"
74872: #include "prenv.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIDOMChromeWindow.h"
73870: #include "nsIDOMWindow.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsPoint.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIPrompt.h"
    1: #include "nsIAuthPrompt.h"
    1: #include "nsIAuthPrompt2.h"
    1: #include "nsTextFormatter.h"
    1: #include "nsIChannelEventSink.h"
48889: #include "nsIAsyncVerifyRedirectCallback.h"
    1: #include "nsIUploadChannel.h"
    1: #include "nsISecurityEventSink.h"
41653: #include "mozilla/FunctionTimer.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsDocumentCharsetInfoCID.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsContentPolicyUtils.h" // NS_CheckContentLoadPolicy(...)
    1: #include "nsICategoryManager.h"
    1: #include "nsXPCOMCID.h"
    1: #include "nsISeekableStream.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsIWritablePropertyBag2.h"
    1: #include "nsIAppShell.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsDOMJSUtils.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIScriptChannel.h"
20651: #include "nsIOfflineCacheUpdate.h"
72924: #include "nsITimedChannel.h"
20651: #include "nsCPrefetchService.h"
37802: #include "nsJSON.h"
47715: #include "IHistory.h"
47715: #include "mozilla/Services.h"
72449: #include "mozilla/Preferences.h"
72924: #include "mozilla/Telemetry.h"
74021: #include "mozilla/AutoRestore.h"
    1: 
    1: // we want to explore making the document own the load group
    1: // so we can associate the document URI with the load group.
    1: // until this point, we have an evil hack:
    1: #include "nsIHttpChannelInternal.h"  
    1: 
    1: 
    1: // Local Includes
    1: #include "nsDocShell.h"
    1: #include "nsDocShellLoadInfo.h"
    1: #include "nsCDefaultURIFixup.h"
    1: #include "nsDocShellEnumerator.h"
    1: #include "nsSHistory.h"
14631: #include "nsDocShellEditorData.h"
    1: 
    1: // Helper Classes
    1: #include "nsDOMError.h"
    1: #include "nsEscape.h"
    1: 
    1: // Interfaces Needed
    1: #include "nsIUploadChannel.h"
    1: #include "nsIProgressEventSink.h"
    1: #include "nsIWebProgress.h"
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsITimer.h"
    1: #include "nsISHistoryInternal.h"
    1: #include "nsIPrincipal.h"
13414: #include "nsIFileURL.h"
    1: #include "nsIHistoryEntry.h"
    1: #include "nsISHistoryListener.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsIPromptFactory.h"
    1: #include "nsIObserver.h"
    1: #include "nsINestedURI.h"
    1: #include "nsITransportSecurityInfo.h"
    1: #include "nsINSSErrorsService.h"
18430: #include "nsIApplicationCache.h"
21311: #include "nsIApplicationCacheChannel.h"
18430: #include "nsIApplicationCacheContainer.h"
18430: #include "nsIPermissionManager.h"
28078: #include "nsStreamUtils.h"
28078: #include "nsIController.h"
28078: #include "nsPICommandUpdater.h"
28078: #include "nsIDOMHTMLAnchorElement.h"
56685: #include "nsIWebBrowserChrome3.h"
46908: #include "nsITabChild.h"
51363: #include "nsIStrictTransportSecurityService.h"
69563: #include "nsStructuredCloneContainer.h"
69563: #include "nsIStructuredCloneContainer.h"
70109: #include "nsIFaviconService.h"
70109: #include "mozIAsyncFavicons.h"
    1: 
    1: // Editor-related
    1: #include "nsIEditingSession.h"
    1: 
    1: #include "nsPIDOMWindow.h"
38336: #include "nsPIWindowRoot.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsICachingChannel.h"
    1: #include "nsICacheVisitor.h"
10966: #include "nsICacheEntryDescriptor.h"
    1: #include "nsIMultiPartChannel.h"
    1: #include "nsIWyciwygChannel.h"
    1: 
    1: // For reporting errors with the console service.
    1: // These can go away if error reporting is propagated up past nsDocShell.
    1: #include "nsIConsoleService.h"
    1: #include "nsIScriptError.h"
    1: 
    1: // used to dispatch urls to default protocol handlers
    1: #include "nsCExternalHandlerService.h"
    1: #include "nsIExternalProtocolService.h"
    1: 
29018: #include "nsFocusManager.h"
    1: 
    1: #include "nsITextToSubURI.h"
    1: 
 8363: #include "nsIJARChannel.h"
 8363: 
    1: #include "prlog.h"
    1: #include "prmem.h"
    1: 
    1: #include "nsISelectionDisplay.h"
    1: 
    1: #include "nsIGlobalHistory2.h"
    1: 
    1: #ifdef DEBUG_DOCSHELL_FOCUS
68780: #include "nsEventStateManager.h"
    1: #endif
    1: 
    1: #include "nsIFrame.h"
    1: 
    1: // for embedding
    1: #include "nsIWebBrowserChromeFocus.h"
    1: 
35581: #if NS_PRINT_PREVIEW
35581: #include "nsIDocumentViewerPrint.h"
35581: #include "nsIWebBrowserPrint.h"
35581: #endif
35581: 
    1: #include "nsPluginError.h"
68728: #include "nsContentUtils.h"
76293: #include "nsContentErrors.h"
76293: #include "nsIChannelPolicy.h"
76293: #include "nsIContentSecurityPolicy.h"
76293: 
76293: #include "nsXULAppAPI.h"
76293: 
76293: #include "nsDOMNavigationTiming.h"
76293: #include "nsITimedChannel.h"
    1: 
    1: static NS_DEFINE_CID(kDOMScriptObjectFactoryCID,
    1:                      NS_DOM_SCRIPT_OBJECT_FACTORY_CID);
    1: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
    1: 
    1: #if defined(DEBUG_bryner) || defined(DEBUG_chb)
    1: //#define DEBUG_DOCSHELL_FOCUS
    1: #define DEBUG_PAGE_CACHE
    1: #endif
    1: 
41930: using namespace mozilla;
41634: 
    1: // Number of documents currently loading
    1: static PRInt32 gNumberOfDocumentsLoading = 0;
    1: 
    1: // Global count of existing docshells.
    1: static PRInt32 gDocShellCount = 0;
    1: 
    1: // Global reference to the URI fixup service.
    1: nsIURIFixup *nsDocShell::sURIFixup = 0;
    1: 
    1: // True means we validate window targets to prevent frameset
    1: // spoofing. Initialize this to a non-bolean value so we know to check
    1: // the pref on the creation of the first docshell.
74431: static PRUint32 gValidateOrigin = 0xffffffff;
    1: 
    1: // Hint for native dispatch of events on how long to delay after 
    1: // all documents have loaded in milliseconds before favoring normal
    1: // native event dispatch priorites over performance
    1: #define NS_EVENT_STARVATION_DELAY_HINT 2000
    1: 
    1: // This is needed for displaying an error message 
    1: // when navigation is attempted on a document when printing
    1: // The value arbitrary as long as it doesn't conflict with
    1: // any of the other values in the errors in DisplayLoadError
    1: #define NS_ERROR_DOCUMENT_IS_PRINTMODE  NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_GENERAL,2001)
    1: 
    1: #ifdef PR_LOGGING
    1: #ifdef DEBUG
    1: static PRLogModuleInfo* gDocShellLog;
    1: #endif
    1: static PRLogModuleInfo* gDocShellLeakLog;
    1: #endif
    1: 
    1: const char kBrandBundleURL[]      = "chrome://branding/locale/brand.properties";
    1: const char kAppstringsBundleURL[] = "chrome://global/locale/appstrings.properties";
    1: 
    1: static void
79445: FavorPerformanceHint(bool perfOverStarvation, PRUint32 starvationDelay)
    1: {
    1:     nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
    1:     if (appShell)
    1:         appShell->FavorPerformanceHint(perfOverStarvation, starvationDelay);
    1: }
    1: 
    1: //*****************************************************************************
28078: // <a ping> support
28078: //*****************************************************************************
28078: 
28078: #define PREF_PINGS_ENABLED           "browser.send_pings"
28078: #define PREF_PINGS_MAX_PER_LINK      "browser.send_pings.max_per_link"
28078: #define PREF_PINGS_REQUIRE_SAME_HOST "browser.send_pings.require_same_host"
28078: 
28078: // Check prefs to see if pings are enabled and if so what restrictions might
28078: // be applied.
28078: //
28078: // @param maxPerLink
28078: //   This parameter returns the number of pings that are allowed per link click
28078: //
28078: // @param requireSameHost
28078: //   This parameter returns PR_TRUE if pings are restricted to the same host as
28078: //   the document in which the click occurs.  If the same host restriction is
28078: //   imposed, then we still allow for pings to cross over to different
28078: //   protocols and ports for flexibility and because it is not possible to send
28078: //   a ping via FTP.
28078: //
28078: // @returns
28078: //   PR_TRUE if pings are enabled and PR_FALSE otherwise.
28078: //
79445: static bool
79445: PingsEnabled(PRInt32 *maxPerLink, bool *requireSameHost)
79445: {
79445:   bool allow = Preferences::GetBool(PREF_PINGS_ENABLED, false);
28078: 
28078:   *maxPerLink = 1;
28078:   *requireSameHost = PR_TRUE;
28078: 
28078:   if (allow) {
72449:     Preferences::GetInt(PREF_PINGS_MAX_PER_LINK, maxPerLink);
72449:     Preferences::GetBool(PREF_PINGS_REQUIRE_SAME_HOST, requireSameHost);
28078:   }
28078: 
28078:   return allow;
28078: }
28078: 
79445: static bool
28078: CheckPingURI(nsIURI* uri, nsIContent* content)
28078: {
28078:   if (!uri)
28078:     return PR_FALSE;
28078: 
28078:   // Check with nsIScriptSecurityManager
28078:   nsCOMPtr<nsIScriptSecurityManager> ssmgr =
28078:     do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
28078:   NS_ENSURE_TRUE(ssmgr, PR_FALSE);
28078: 
28078:   nsresult rv =
28078:     ssmgr->CheckLoadURIWithPrincipal(content->NodePrincipal(), uri,
28078:                                      nsIScriptSecurityManager::STANDARD);
28078:   if (NS_FAILED(rv)) {
28078:     return PR_FALSE;
28078:   }
28078: 
28078:   // Ignore non-HTTP(S)
79445:   bool match;
28078:   if ((NS_FAILED(uri->SchemeIs("http", &match)) || !match) &&
28078:       (NS_FAILED(uri->SchemeIs("https", &match)) || !match)) {
28078:     return PR_FALSE;
28078:   }
28078: 
28078:   // Check with contentpolicy
28078:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
28078:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_PING,
28078:                                  uri,
28078:                                  content->NodePrincipal(),
28078:                                  content,
28078:                                  EmptyCString(), // mime hint
28078:                                  nsnull, //extra
28078:                                  &shouldLoad);
28078:   return NS_SUCCEEDED(rv) && NS_CP_ACCEPTED(shouldLoad);
28078: }
28078: 
28078: typedef void (* ForEachPingCallback)(void *closure, nsIContent *content,
28078:                                      nsIURI *uri, nsIIOService *ios);
28078: 
28078: static void
28078: ForEachPing(nsIContent *content, ForEachPingCallback callback, void *closure)
28078: {
48890:   // NOTE: Using nsIDOMHTMLAnchorElement::GetPing isn't really worth it here
28078:   //       since we'd still need to parse the resulting string.  Instead, we
28078:   //       just parse the raw attribute.  It might be nice if the content node
28078:   //       implemented an interface that exposed an enumeration of nsIURIs.
28078: 
28078:   // Make sure we are dealing with either an <A> or <AREA> element in the HTML
28078:   // or XHTML namespace.
33329:   if (!content->IsHTML())
28078:     return;
28078:   nsIAtom *nameAtom = content->Tag();
43337:   if (!nameAtom->Equals(NS_LITERAL_STRING("a")) &&
43337:       !nameAtom->Equals(NS_LITERAL_STRING("area")))
28078:     return;
28078: 
28078:   nsCOMPtr<nsIAtom> pingAtom = do_GetAtom("ping");
28078:   if (!pingAtom)
28078:     return;
28078: 
28078:   nsAutoString value;
28078:   content->GetAttr(kNameSpaceID_None, pingAtom, value);
28078:   if (value.IsEmpty())
28078:     return;
28078: 
28078:   nsCOMPtr<nsIIOService> ios = do_GetIOService();
28078:   if (!ios)
28078:     return;
28078: 
28078:   nsIDocument *doc = content->GetOwnerDoc();
28078:   if (!doc)
28078:     return;
28078: 
28078:   // value contains relative URIs split on spaces (U+0020)
28078:   const PRUnichar *start = value.BeginReading();
28078:   const PRUnichar *end   = value.EndReading();
28078:   const PRUnichar *iter  = start;
28078:   for (;;) {
28078:     if (iter < end && *iter != ' ') {
28078:       ++iter;
28078:     } else {  // iter is pointing at either end or a space
28078:       while (*start == ' ' && start < iter)
28078:         ++start;
28078:       if (iter != start) {
28078:         nsCOMPtr<nsIURI> uri, baseURI = content->GetBaseURI();
28078:         ios->NewURI(NS_ConvertUTF16toUTF8(Substring(start, iter)),
28078:                     doc->GetDocumentCharacterSet().get(),
28078:                     baseURI, getter_AddRefs(uri));
28078:         if (CheckPingURI(uri, content)) {
28078:           callback(closure, content, uri, ios);
28078:         }
28078:       }
28078:       start = iter = iter + 1;
28078:       if (iter >= end)
28078:         break;
28078:     }
28078:   }
28078: }
28078: 
28078: //----------------------------------------------------------------------
28078: 
28078: // We wait this many milliseconds before killing the ping channel...
28078: #define PING_TIMEOUT 10000
28078: 
28078: static void
28078: OnPingTimeout(nsITimer *timer, void *closure)
28078: {
28078:   nsILoadGroup *loadGroup = static_cast<nsILoadGroup *>(closure);
28078:   loadGroup->Cancel(NS_ERROR_ABORT);
28078:   loadGroup->Release();
28078: }
28078: 
28078: // Check to see if two URIs have the same host or not
79445: static bool
28078: IsSameHost(nsIURI *uri1, nsIURI *uri2)
28078: {
28078:   nsCAutoString host1, host2;
28078:   uri1->GetAsciiHost(host1);
28078:   uri2->GetAsciiHost(host2);
28078:   return host1.Equals(host2);
28078: }
28078: 
28078: class nsPingListener : public nsIStreamListener
28078:                      , public nsIInterfaceRequestor
28078:                      , public nsIChannelEventSink
28078: {
28078: public:
28078:   NS_DECL_ISUPPORTS
28078:   NS_DECL_NSIREQUESTOBSERVER
28078:   NS_DECL_NSISTREAMLISTENER
28078:   NS_DECL_NSIINTERFACEREQUESTOR
28078:   NS_DECL_NSICHANNELEVENTSINK
28078: 
79445:   nsPingListener(bool requireSameHost, nsIContent* content)
28078:     : mRequireSameHost(requireSameHost),
28078:       mContent(content)
28078:   {}
28078: 
28078: private:
79445:   bool mRequireSameHost;
28078:   nsCOMPtr<nsIContent> mContent;
28078: };
28078: 
28078: NS_IMPL_ISUPPORTS4(nsPingListener, nsIStreamListener, nsIRequestObserver,
28078:                    nsIInterfaceRequestor, nsIChannelEventSink)
28078: 
28078: NS_IMETHODIMP
28078: nsPingListener::OnStartRequest(nsIRequest *request, nsISupports *context)
28078: {
28078:   return NS_OK;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsPingListener::OnDataAvailable(nsIRequest *request, nsISupports *context,
28078:                                 nsIInputStream *stream, PRUint32 offset,
28078:                                 PRUint32 count)
28078: {
28078:   PRUint32 result;
28078:   return stream->ReadSegments(NS_DiscardSegment, nsnull, count, &result);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsPingListener::OnStopRequest(nsIRequest *request, nsISupports *context,
28078:                               nsresult status)
28078: {
28078:   return NS_OK;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsPingListener::GetInterface(const nsIID &iid, void **result)
28078: {
28078:   if (iid.Equals(NS_GET_IID(nsIChannelEventSink))) {
28078:     NS_ADDREF_THIS();
28078:     *result = (nsIChannelEventSink *) this;
28078:     return NS_OK;
28078:   }
28078: 
28078:   return NS_ERROR_NO_INTERFACE;
28078: }
28078: 
28078: NS_IMETHODIMP
48889: nsPingListener::AsyncOnChannelRedirect(nsIChannel *oldChan, nsIChannel *newChan,
48889:                                        PRUint32 flags,
48889:                                        nsIAsyncVerifyRedirectCallback *callback)
28078: {
28078:   nsCOMPtr<nsIURI> newURI;
28078:   newChan->GetURI(getter_AddRefs(newURI));
28078: 
28078:   if (!CheckPingURI(newURI, mContent))
28078:     return NS_ERROR_ABORT;
28078: 
48889:   if (!mRequireSameHost) {
48889:     callback->OnRedirectVerifyCallback(NS_OK);
48889:     return NS_OK;
48889:   }
28078: 
28078:   // XXXbz should this be using something more like the nsContentUtils
28078:   // same-origin checker?
28078:   nsCOMPtr<nsIURI> oldURI;
28078:   oldChan->GetURI(getter_AddRefs(oldURI));
28078:   NS_ENSURE_STATE(oldURI && newURI);
28078: 
28078:   if (!IsSameHost(oldURI, newURI))
28078:     return NS_ERROR_ABORT;
28078: 
48889:   callback->OnRedirectVerifyCallback(NS_OK);
28078:   return NS_OK;
28078: }
28078: 
28078: struct SendPingInfo {
28078:   PRInt32 numPings;
28078:   PRInt32 maxPings;
79445:   bool    requireSameHost;
28078:   nsIURI *referrer;
28078: };
28078: 
28078: static void
28078: SendPing(void *closure, nsIContent *content, nsIURI *uri, nsIIOService *ios)
28078: {
28078:   SendPingInfo *info = static_cast<SendPingInfo *>(closure);
28078:   if (info->numPings >= info->maxPings)
28078:     return;
28078: 
28078:   if (info->requireSameHost) {
28078:     // Make sure the referrer and the given uri share the same origin.  We
28078:     // only require the same hostname.  The scheme and port may differ.
28078:     if (!IsSameHost(uri, info->referrer))
28078:       return;
28078:   }
28078: 
28078:   nsIDocument *doc = content->GetOwnerDoc();
28078:   if (!doc)
28078:     return;
28078: 
28078:   nsCOMPtr<nsIChannel> chan;
28078:   ios->NewChannelFromURI(uri, getter_AddRefs(chan));
28078:   if (!chan)
28078:     return;
28078: 
28078:   // Don't bother caching the result of this URI load.
28078:   chan->SetLoadFlags(nsIRequest::INHIBIT_CACHING);
28078: 
28078:   nsCOMPtr<nsIHttpChannel> httpChan = do_QueryInterface(chan);
28078:   if (!httpChan)
28078:     return;
28078: 
28078:   // This is needed in order for 3rd-party cookie blocking to work.
28078:   nsCOMPtr<nsIHttpChannelInternal> httpInternal = do_QueryInterface(httpChan);
28078:   if (httpInternal)
28078:     httpInternal->SetDocumentURI(doc->GetDocumentURI());
28078: 
28078:   if (info->referrer)
28078:     httpChan->SetReferrer(info->referrer);
28078: 
28078:   httpChan->SetRequestMethod(NS_LITERAL_CSTRING("POST"));
28078: 
28078:   // Remove extraneous request headers (to reduce request size)
28078:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept"),
28078:                              EmptyCString(), PR_FALSE);
28078:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept-language"),
28078:                              EmptyCString(), PR_FALSE);
28078:   httpChan->SetRequestHeader(NS_LITERAL_CSTRING("accept-encoding"),
28078:                              EmptyCString(), PR_FALSE);
28078: 
28078:   nsCOMPtr<nsIUploadChannel> uploadChan = do_QueryInterface(httpChan);
28078:   if (!uploadChan)
28078:     return;
28078: 
28078:   // To avoid sending an unnecessary Content-Type header, we encode the
28078:   // closing portion of the headers in the POST body.
28078:   NS_NAMED_LITERAL_CSTRING(uploadData, "Content-Length: 0\r\n\r\n");
28078: 
28078:   nsCOMPtr<nsIInputStream> uploadStream;
28078:   NS_NewPostDataStream(getter_AddRefs(uploadStream), PR_FALSE,
28078:                        uploadData, 0);
28078:   if (!uploadStream)
28078:     return;
28078: 
28078:   uploadChan->SetUploadStream(uploadStream, EmptyCString(), -1);
28078: 
28078:   // The channel needs to have a loadgroup associated with it, so that we can
28078:   // cancel the channel and any redirected channels it may create.
28078:   nsCOMPtr<nsILoadGroup> loadGroup =
28078:       do_CreateInstance(NS_LOADGROUP_CONTRACTID);
28078:   if (!loadGroup)
28078:     return;
28078:   chan->SetLoadGroup(loadGroup);
28078: 
28078:   // Construct a listener that merely discards any response.  If successful at
28078:   // opening the channel, then it is not necessary to hold a reference to the
28078:   // channel.  The networking subsystem will take care of that for us.
28078:   nsCOMPtr<nsIStreamListener> listener =
28078:       new nsPingListener(info->requireSameHost, content);
28078:   if (!listener)
28078:     return;
28078: 
28078:   // Observe redirects as well:
28078:   nsCOMPtr<nsIInterfaceRequestor> callbacks = do_QueryInterface(listener);
28078:   NS_ASSERTION(callbacks, "oops");
28078:   loadGroup->SetNotificationCallbacks(callbacks);
28078: 
28078:   chan->AsyncOpen(listener, nsnull);
28078: 
28078:   // Even if AsyncOpen failed, we still count this as a successful ping.  It's
28078:   // possible that AsyncOpen may have failed after triggering some background
28078:   // process that may have written something to the network.
28078:   info->numPings++;
28078: 
28078:   // Prevent ping requests from stalling and never being garbage collected...
28078:   nsCOMPtr<nsITimer> timer =
28078:       do_CreateInstance(NS_TIMER_CONTRACTID);
28078:   if (timer) {
28078:     nsresult rv = timer->InitWithFuncCallback(OnPingTimeout, loadGroup,
28078:                                               PING_TIMEOUT,
28078:                                               nsITimer::TYPE_ONE_SHOT);
28078:     if (NS_SUCCEEDED(rv)) {
28078:       // When the timer expires, the callback function will release this
28078:       // reference to the loadgroup.
28078:       static_cast<nsILoadGroup *>(loadGroup.get())->AddRef();
28078:       loadGroup = 0;
28078:     }
28078:   }
28078:   
28078:   // If we failed to setup the timer, then we should just cancel the channel
28078:   // because we won't be able to ensure that it goes away in a timely manner.
28078:   if (loadGroup)
28078:     chan->Cancel(NS_ERROR_ABORT);
28078: }
28078: 
28078: // Spec: http://whatwg.org/specs/web-apps/current-work/#ping
28078: static void
28078: DispatchPings(nsIContent *content, nsIURI *referrer)
28078: {
28078:   SendPingInfo info;
28078: 
28078:   if (!PingsEnabled(&info.maxPings, &info.requireSameHost))
28078:     return;
28078:   if (info.maxPings == 0)
28078:     return;
28078: 
28078:   info.numPings = 0;
28078:   info.referrer = referrer;
28078: 
28078:   ForEachPing(content, SendPing, &info);
28078: }
28078: 
72298: static nsDOMPerformanceNavigationType
72298: ConvertLoadTypeToNavigationType(PRUint32 aLoadType)
72298: {
72298:   nsDOMPerformanceNavigationType result = nsIDOMPerformanceNavigation::TYPE_RESERVED;
72298:   switch (aLoadType) {
72298:     case LOAD_NORMAL:
72298:     case LOAD_NORMAL_EXTERNAL:
72298:     case LOAD_NORMAL_BYPASS_CACHE:
72298:     case LOAD_NORMAL_BYPASS_PROXY:
72298:     case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
72962:     case LOAD_NORMAL_REPLACE:
72298:     case LOAD_LINK:
72962:     case LOAD_STOP_CONTENT:
72298:         result = nsIDOMPerformanceNavigation::TYPE_NAVIGATE;
72298:         break;
72298:     case LOAD_HISTORY:
72298:         result = nsIDOMPerformanceNavigation::TYPE_BACK_FORWARD;
72298:         break;
72298:     case LOAD_RELOAD_NORMAL:
72298:     case LOAD_RELOAD_CHARSET_CHANGE:
72298:     case LOAD_RELOAD_BYPASS_CACHE:
72298:     case LOAD_RELOAD_BYPASS_PROXY:
72298:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
72298:         result = nsIDOMPerformanceNavigation::TYPE_RELOAD;
72298:         break;
72298:     case LOAD_STOP_CONTENT_AND_REPLACE:
72298:     case LOAD_REFRESH:
72298:     case LOAD_BYPASS_HISTORY:
72298:     case LOAD_ERROR_PAGE:
72298:     case LOAD_PUSHSTATE:
72298:         result = nsIDOMPerformanceNavigation::TYPE_RESERVED;
72298:         break;
72298:     default:
72298:         // NS_NOTREACHED("Unexpected load type value");
72298:         result = nsIDOMPerformanceNavigation::TYPE_RESERVED;
72298:         break;
72298:   }
72298: 
72298:   return result;
72298: }
72298: 
37802: static nsISHEntry* GetRootSHEntry(nsISHEntry *entry);
37802: 
28078: //*****************************************************************************
    1: //***    nsDocShell: Object Management
    1: //*****************************************************************************
    1: 
50721: static PRUint64 gDocshellIDCounter = 0;
50721: 
28078: // Note: operator new zeros our memory
    1: nsDocShell::nsDocShell():
    1:     nsDocLoader(),
28564:     mDefaultScrollbarPref(Scrollbar_Auto, Scrollbar_Auto),
28564:     mTreeOwner(nsnull),
28564:     mChromeEventHandler(nsnull),
28564:     mCharsetReloadState(eCharsetReloadInit),
28564:     mChildOffset(0),
28564:     mBusyFlags(BUSY_FLAGS_NONE),
28564:     mAppType(nsIDocShell::APP_TYPE_UNKNOWN),
77094:     mLoadType(0),
28564:     mMarginWidth(-1),
28564:     mMarginHeight(-1),
28564:     mItemType(typeContent),
28564:     mPreviousTransIndex(-1),
28564:     mLoadedTransIndex(-1),
72449:     mCreated(PR_FALSE),
    1:     mAllowSubframes(PR_TRUE),
    1:     mAllowPlugins(PR_TRUE),
    1:     mAllowJavascript(PR_TRUE),
    1:     mAllowMetaRedirects(PR_TRUE),
    1:     mAllowImages(PR_TRUE),
28460:     mAllowDNSPrefetch(PR_TRUE),
72453:     mAllowWindowControl(PR_TRUE),
    1:     mCreatingDocument(PR_FALSE),
    1:     mUseErrorPages(PR_FALSE),
    1:     mObserveErrorPages(PR_TRUE),
    1:     mAllowAuth(PR_TRUE),
    1:     mAllowKeywordFixup(PR_FALSE),
21191:     mIsOffScreenBrowser(PR_FALSE),
48937:     mIsActive(PR_TRUE),
56685:     mIsAppTab(PR_FALSE),
61540:     mUseGlobalHistory(PR_FALSE),
    1:     mFiredUnloadEvent(PR_FALSE),
    1:     mEODForCurrentDocument(PR_FALSE),
    1:     mURIResultedInDocument(PR_FALSE),
    1:     mIsBeingDestroyed(PR_FALSE),
    1:     mIsExecutingOnLoadHandler(PR_FALSE),
    1:     mIsPrintingOrPP(PR_FALSE),
28564:     mSavingOldViewer(PR_FALSE)
 7837: #ifdef DEBUG
 7837:     , mInEnsureScriptEnv(PR_FALSE)
 7837: #endif
    1: {
50721:     mHistoryID = ++gDocshellIDCounter;
    1:     if (gDocShellCount++ == 0) {
    1:         NS_ASSERTION(sURIFixup == nsnull,
    1:                      "Huh, sURIFixup not null in first nsDocShell ctor!");
    1: 
    1:         CallGetService(NS_URIFIXUP_CONTRACTID, &sURIFixup);
    1:     }
    1: 
    1: #ifdef PR_LOGGING
    1: #ifdef DEBUG
    1:     if (! gDocShellLog)
    1:         gDocShellLog = PR_NewLogModule("nsDocShell");
    1: #endif
    1:     if (nsnull == gDocShellLeakLog)
    1:         gDocShellLeakLog = PR_NewLogModule("nsDocShellLeak");
    1:     if (gDocShellLeakLog)
    1:         PR_LOG(gDocShellLeakLog, PR_LOG_DEBUG, ("DOCSHELL %p created\n", this));
    1: #endif
28078: 
28078: #ifdef DEBUG
28078:   // We're counting the number of |nsDocShells| to help find leaks
28078:   ++gNumberOfDocShells;
74872:   if (!PR_GetEnv("MOZ_QUIET")) {
28078:       printf("++DOCSHELL %p == %ld\n", (void*) this, gNumberOfDocShells);
74872:   }
28078: #endif
    1: }
    1: 
    1: nsDocShell::~nsDocShell()
    1: {
    1:     Destroy();
    1: 
57894:     nsCOMPtr<nsISHistoryInternal>
57894:         shPrivate(do_QueryInterface(mSessionHistory));
57894:     if (shPrivate) {
57894:         shPrivate->SetRootDocShell(nsnull);
57894:     }
57894: 
    1:     if (--gDocShellCount == 0) {
    1:         NS_IF_RELEASE(sURIFixup);
    1:     }
    1: 
    1: #ifdef PR_LOGGING
    1:     if (gDocShellLeakLog)
    1:         PR_LOG(gDocShellLeakLog, PR_LOG_DEBUG, ("DOCSHELL %p destroyed\n", this));
    1: #endif
28078: 
28078: #ifdef DEBUG
28078:     // We're counting the number of |nsDocShells| to help find leaks
28078:     --gNumberOfDocShells;
74872:     if (!PR_GetEnv("MOZ_QUIET")) {
28078:         printf("--DOCSHELL %p == %ld\n", (void*) this, gNumberOfDocShells);
74872:     }
28078: #endif
    1: }
    1: 
    1: nsresult
    1: nsDocShell::Init()
    1: {
    1:     nsresult rv = nsDocLoader::Init();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     NS_ASSERTION(mLoadGroup, "Something went wrong!");
    1: 
    1:     mContentListener = new nsDSURIContentListener(this);
    1:     NS_ENSURE_TRUE(mContentListener, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     rv = mContentListener->Init();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (!mStorages.Init())
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // We want to hold a strong ref to the loadgroup, so it better hold a weak
    1:     // ref to us...  use an InterfaceRequestorProxy to do this.
    1:     nsCOMPtr<InterfaceRequestorProxy> proxy =
 3233:         new InterfaceRequestorProxy(static_cast<nsIInterfaceRequestor*>
 3233:                                                (this));
    1:     NS_ENSURE_TRUE(proxy, NS_ERROR_OUT_OF_MEMORY);
    1:     mLoadGroup->SetNotificationCallbacks(proxy);
    1: 
    1:     rv = nsDocLoader::AddDocLoaderAsChildOfRoot(this);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     // Add as |this| a progress listener to itself.  A little weird, but
    1:     // simpler than reproducing all the listener-notification logic in
    1:     // overrides of the various methods via which nsDocLoader can be
    1:     // notified.   Note that this holds an nsWeakPtr to ourselves, so it's ok.
    1:     return AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_DOCUMENT |
    1:                                      nsIWebProgress::NOTIFY_STATE_NETWORK);
    1:     
    1: }
    1: 
    1: void
    1: nsDocShell::DestroyChildren()
    1: {
    1:     nsCOMPtr<nsIDocShellTreeItem> shell;
29263:     PRInt32 n = mChildList.Count();
29263:     for (PRInt32 i = 0; i < n; i++) {
29263:         shell = do_QueryInterface(ChildAt(i));
    1:         NS_ASSERTION(shell, "docshell has null child");
    1: 
    1:         if (shell) {
    1:             shell->SetTreeOwner(nsnull);
    1:         }
    1:     }
    1: 
    1:     nsDocLoader::DestroyChildren();
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsISupports
    1: //*****************************************************************************   
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsDocShell, nsDocLoader)
    1: NS_IMPL_RELEASE_INHERITED(nsDocShell, nsDocLoader)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsDocShell)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocShell)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellTreeItem)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellTreeNode)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellHistory)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebNavigation)
    1:     NS_INTERFACE_MAP_ENTRY(nsIBaseWindow)
    1:     NS_INTERFACE_MAP_ENTRY(nsIScrollable)
    1:     NS_INTERFACE_MAP_ENTRY(nsITextScroll)
    1:     NS_INTERFACE_MAP_ENTRY(nsIDocCharset)
    1:     NS_INTERFACE_MAP_ENTRY(nsIScriptGlobalObjectOwner)
    1:     NS_INTERFACE_MAP_ENTRY(nsIRefreshURI)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
    1:     NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewerContainer)
    1:     NS_INTERFACE_MAP_ENTRY(nsIEditorDocShell)
    1:     NS_INTERFACE_MAP_ENTRY(nsIWebPageDescriptor)
    1:     NS_INTERFACE_MAP_ENTRY(nsIAuthPromptProvider)
    1:     NS_INTERFACE_MAP_ENTRY(nsIObserver)
21877:     NS_INTERFACE_MAP_ENTRY(nsILoadContext)
28078:     NS_INTERFACE_MAP_ENTRY(nsIWebShellServices)
28078:     NS_INTERFACE_MAP_ENTRY(nsILinkHandler)
28078:     NS_INTERFACE_MAP_ENTRY(nsIClipboardCommands)
    1: NS_INTERFACE_MAP_END_INHERITING(nsDocLoader)
    1: 
    1: ///*****************************************************************************
    1: // nsDocShell::nsIInterfaceRequestor
    1: //*****************************************************************************   
    1: NS_IMETHODIMP nsDocShell::GetInterface(const nsIID & aIID, void **aSink)
    1: {
    1:     NS_PRECONDITION(aSink, "null out param");
    1: 
    1:     *aSink = nsnull;
    1: 
28078:     if (aIID.Equals(NS_GET_IID(nsICommandManager))) {
28078:         NS_ENSURE_SUCCESS(EnsureCommandHandler(), NS_ERROR_FAILURE);
28078:         *aSink = mCommandManager;
28078:     }
28078:     else if (aIID.Equals(NS_GET_IID(nsIURIContentListener))) {
    1:         *aSink = mContentListener;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIScriptGlobalObject)) &&
    1:              NS_SUCCEEDED(EnsureScriptEnvironment())) {
    1:         *aSink = mScriptGlobal;
    1:     }
73870:     else if ((aIID.Equals(NS_GET_IID(nsPIDOMWindow)) ||
76293:               aIID.Equals(NS_GET_IID(nsIDOMWindow)) ||
76293:               aIID.Equals(NS_GET_IID(nsIDOMWindowInternal))) &&
    1:              NS_SUCCEEDED(EnsureScriptEnvironment())) {
    1:         return mScriptGlobal->QueryInterface(aIID, aSink);
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIDOMDocument)) &&
    1:              NS_SUCCEEDED(EnsureContentViewer())) {
    1:         mContentViewer->GetDOMDocument((nsIDOMDocument **) aSink);
    1:         return *aSink ? NS_OK : NS_NOINTERFACE;
    1:     }
37802:     else if (aIID.Equals(NS_GET_IID(nsIDocument)) &&
37802:              NS_SUCCEEDED(EnsureContentViewer())) {
37802:         nsCOMPtr<nsIDOMDocument> domDoc;
37802:         mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
37802:         if (!domDoc)
37802:             return NS_NOINTERFACE;
37802:         return domDoc->QueryInterface(aIID, aSink);
37802:     }
19860:     else if (aIID.Equals(NS_GET_IID(nsIApplicationCacheContainer))) {
18430:         *aSink = nsnull;
18430: 
21366:         // Return application cache associated with this docshell, if any
19860: 
19860:         nsCOMPtr<nsIContentViewer> contentViewer;
21366:         GetContentViewer(getter_AddRefs(contentViewer));
19860:         if (!contentViewer)
19860:             return NS_ERROR_NO_INTERFACE;
19860: 
19860:         nsCOMPtr<nsIDOMDocument> domDoc;
19860:         contentViewer->GetDOMDocument(getter_AddRefs(domDoc));
18430:         NS_ASSERTION(domDoc, "Should have a document.");
18430:         if (!domDoc)
18430:             return NS_ERROR_NO_INTERFACE;
18430: 
21366: #if defined(PR_LOGGING) && defined(DEBUG)
21366:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
21366:                ("nsDocShell[%p]: returning app cache container %p",
21366:                 this, domDoc.get()));
21366: #endif
18430:         return domDoc->QueryInterface(aIID, aSink);
18430:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIPrompt)) &&
    1:              NS_SUCCEEDED(EnsureScriptEnvironment())) {
    1:         nsresult rv;
    1:         nsCOMPtr<nsIWindowWatcher> wwatch =
    1:             do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         nsCOMPtr<nsIDOMWindow> window(do_QueryInterface(mScriptGlobal));
    1: 
    1:         // Get the an auth prompter for our window so that the parenting
    1:         // of the dialogs works as it should when using tabs.
    1: 
    1:         nsIPrompt *prompt;
    1:         rv = wwatch->GetNewPrompter(window, &prompt);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         *aSink = prompt;
    1:         return NS_OK;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
    1:              aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
    1:         return NS_SUCCEEDED(
    1:                 GetAuthPrompt(PROMPT_NORMAL, aIID, aSink)) ?
    1:                 NS_OK : NS_NOINTERFACE;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsISHistory))) {
    1:         nsCOMPtr<nsISHistory> shistory;
    1:         nsresult
    1:             rv =
    1:             GetSessionHistory(getter_AddRefs(shistory));
    1:         if (NS_SUCCEEDED(rv) && shistory) {
    1:             *aSink = shistory;
    1:             NS_ADDREF((nsISupports *) * aSink);
    1:             return NS_OK;
    1:         }
    1:         return NS_NOINTERFACE;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIWebBrowserFind))) {
    1:         nsresult rv = EnsureFind();
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         *aSink = mFind;
    1:         NS_ADDREF((nsISupports*)*aSink);
    1:         return NS_OK;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIEditingSession)) && NS_SUCCEEDED(EnsureEditorData())) {
    1:       nsCOMPtr<nsIEditingSession> editingSession;
    1:       mEditorData->GetEditingSession(getter_AddRefs(editingSession));
    1:       if (editingSession)
    1:       {
    1:         *aSink = editingSession;
    1:         NS_ADDREF((nsISupports *)*aSink);
    1:         return NS_OK;
    1:       }  
    1: 
    1:       return NS_NOINTERFACE;   
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIClipboardDragDropHookList)) 
    1:             && NS_SUCCEEDED(EnsureTransferableHookData())) {
    1:         *aSink = mTransferableHookData;
    1:         NS_ADDREF((nsISupports *)*aSink);
    1:         return NS_OK;
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsISelectionDisplay))) {
    1:       nsCOMPtr<nsIPresShell> shell;
    1:       nsresult rv = GetPresShell(getter_AddRefs(shell));
    1:       if (NS_SUCCEEDED(rv) && shell)
    1:         return shell->QueryInterface(aIID,aSink);    
    1:     }
    1:     else if (aIID.Equals(NS_GET_IID(nsIDocShellTreeOwner))) {
    1:       nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:       nsresult rv = GetTreeOwner(getter_AddRefs(treeOwner));
    1:       if (NS_SUCCEEDED(rv) && treeOwner)
    1:         return treeOwner->QueryInterface(aIID, aSink);
    1:     }
46908:     else if (aIID.Equals(NS_GET_IID(nsITabChild))) {
46908:       nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
46908:       nsresult rv = GetTreeOwner(getter_AddRefs(treeOwner));
46908:       if (NS_SUCCEEDED(rv) && treeOwner) {
46908:         nsCOMPtr<nsIInterfaceRequestor> ir = do_QueryInterface(treeOwner);
46908:         if (ir)
46908:           return ir->GetInterface(aIID, aSink);
46908:       }
46908:     }
    1:     else {
    1:       return nsDocLoader::GetInterface(aIID, aSink);
    1:     }
    1: 
    1:     NS_IF_ADDREF(((nsISupports *) * aSink));
    1:     return *aSink ? NS_OK : NS_NOINTERFACE;
    1: }
    1: 
    1: PRUint32
    1: nsDocShell::
    1: ConvertDocShellLoadInfoToLoadType(nsDocShellInfoLoadType aDocShellLoadType)
    1: {
    1:     PRUint32 loadType = LOAD_NORMAL;
    1: 
    1:     switch (aDocShellLoadType) {
    1:     case nsIDocShellLoadInfo::loadNormal:
    1:         loadType = LOAD_NORMAL;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalReplace:
    1:         loadType = LOAD_NORMAL_REPLACE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalExternal:
    1:         loadType = LOAD_NORMAL_EXTERNAL;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadHistory:
    1:         loadType = LOAD_HISTORY;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalBypassCache:
    1:         loadType = LOAD_NORMAL_BYPASS_CACHE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalBypassProxy:
    1:         loadType = LOAD_NORMAL_BYPASS_PROXY;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadNormalBypassProxyAndCache:
    1:         loadType = LOAD_NORMAL_BYPASS_PROXY_AND_CACHE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadNormal:
    1:         loadType = LOAD_RELOAD_NORMAL;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadCharsetChange:
    1:         loadType = LOAD_RELOAD_CHARSET_CHANGE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadBypassCache:
    1:         loadType = LOAD_RELOAD_BYPASS_CACHE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadBypassProxy:
    1:         loadType = LOAD_RELOAD_BYPASS_PROXY;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadReloadBypassProxyAndCache:
    1:         loadType = LOAD_RELOAD_BYPASS_PROXY_AND_CACHE;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadLink:
    1:         loadType = LOAD_LINK;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadRefresh:
    1:         loadType = LOAD_REFRESH;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadBypassHistory:
    1:         loadType = LOAD_BYPASS_HISTORY;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadStopContent:
    1:         loadType = LOAD_STOP_CONTENT;
    1:         break;
    1:     case nsIDocShellLoadInfo::loadStopContentAndReplace:
    1:         loadType = LOAD_STOP_CONTENT_AND_REPLACE;
    1:         break;
41712:     case nsIDocShellLoadInfo::loadPushState:
41712:         loadType = LOAD_PUSHSTATE;
41712:         break;
    1:     default:
    1:         NS_NOTREACHED("Unexpected nsDocShellInfoLoadType value");
    1:     }
    1: 
    1:     return loadType;
    1: }
    1: 
    1: 
    1: nsDocShellInfoLoadType
    1: nsDocShell::ConvertLoadTypeToDocShellLoadInfo(PRUint32 aLoadType)
    1: {
    1:     nsDocShellInfoLoadType docShellLoadType = nsIDocShellLoadInfo::loadNormal;
    1:     switch (aLoadType) {
    1:     case LOAD_NORMAL:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormal;
    1:         break;
    1:     case LOAD_NORMAL_REPLACE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalReplace;
    1:         break;
    1:     case LOAD_NORMAL_EXTERNAL:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalExternal;
    1:         break;
    1:     case LOAD_NORMAL_BYPASS_CACHE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalBypassCache;
    1:         break;
    1:     case LOAD_NORMAL_BYPASS_PROXY:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalBypassProxy;
    1:         break;
    1:     case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalBypassProxyAndCache;
    1:         break;
    1:     case LOAD_HISTORY:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadHistory;
    1:         break;
    1:     case LOAD_RELOAD_NORMAL:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadNormal;
    1:         break;
    1:     case LOAD_RELOAD_CHARSET_CHANGE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadCharsetChange;
    1:         break;
    1:     case LOAD_RELOAD_BYPASS_CACHE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadBypassCache;
    1:         break;
    1:     case LOAD_RELOAD_BYPASS_PROXY:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadBypassProxy;
    1:         break;
    1:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadBypassProxyAndCache;
    1:         break;
    1:     case LOAD_LINK:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadLink;
    1:         break;
    1:     case LOAD_REFRESH:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadRefresh;
    1:         break;
    1:     case LOAD_BYPASS_HISTORY:
    1:     case LOAD_ERROR_PAGE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadBypassHistory;
    1:         break;
    1:     case LOAD_STOP_CONTENT:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadStopContent;
    1:         break;
    1:     case LOAD_STOP_CONTENT_AND_REPLACE:
    1:         docShellLoadType = nsIDocShellLoadInfo::loadStopContentAndReplace;
    1:         break;
41712:     case LOAD_PUSHSTATE:
41712:         docShellLoadType = nsIDocShellLoadInfo::loadPushState;
41712:         break;
    1:     default:
    1:         NS_NOTREACHED("Unexpected load type value");
    1:     }
    1: 
    1:     return docShellLoadType;
    1: }                                                                               
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIDocShell
    1: //*****************************************************************************   
    1: NS_IMETHODIMP
    1: nsDocShell::LoadURI(nsIURI * aURI,
    1:                     nsIDocShellLoadInfo * aLoadInfo,
    1:                     PRUint32 aLoadFlags,
79445:                     bool aFirstParty)
    1: {
21935:     NS_PRECONDITION(aLoadInfo || (aLoadFlags & EXTRA_LOAD_FLAGS) == 0,
21935:                     "Unexpected flags");
21959:     NS_PRECONDITION((aLoadFlags & 0xf) == 0, "Should not have these flags set");
21935:     
10676:     // Note: we allow loads to get through here even if mFiredUnloadEvent is
10676:     // true; that case will get handled in LoadInternal or LoadHistoryEntry.
10676:     if (IsPrintingOrPP()) {
 2400:       return NS_OK; // JS may not handle returning of an error code
 2400:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsIURI> referrer;
    1:     nsCOMPtr<nsIInputStream> postStream;
    1:     nsCOMPtr<nsIInputStream> headersStream;
    1:     nsCOMPtr<nsISupports> owner;
79445:     bool inheritOwner = false;
79445:     bool ownerIsExplicit = false;
79445:     bool sendReferrer = true;
    1:     nsCOMPtr<nsISHEntry> shEntry;
    1:     nsXPIDLString target;
    1:     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_NORMAL, aLoadFlags);    
    1: 
    1:     NS_ENSURE_ARG(aURI);
    1: 
    1:     // Extract the info from the DocShellLoadInfo struct...
    1:     if (aLoadInfo) {
    1:         aLoadInfo->GetReferrer(getter_AddRefs(referrer));
    1: 
    1:         nsDocShellInfoLoadType lt = nsIDocShellLoadInfo::loadNormal;
    1:         aLoadInfo->GetLoadType(&lt);
    1:         // Get the appropriate loadType from nsIDocShellLoadInfo type
    1:         loadType = ConvertDocShellLoadInfoToLoadType(lt);
    1: 
    1:         aLoadInfo->GetOwner(getter_AddRefs(owner));
    1:         aLoadInfo->GetInheritOwner(&inheritOwner);
25969:         aLoadInfo->GetOwnerIsExplicit(&ownerIsExplicit);
    1:         aLoadInfo->GetSHEntry(getter_AddRefs(shEntry));
    1:         aLoadInfo->GetTarget(getter_Copies(target));
    1:         aLoadInfo->GetPostDataStream(getter_AddRefs(postStream));
    1:         aLoadInfo->GetHeadersStream(getter_AddRefs(headersStream));
    1:         aLoadInfo->GetSendReferrer(&sendReferrer);
    1:     }
    1: 
    1: #if defined(PR_LOGGING) && defined(DEBUG)
    1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString uristr;
    1:         aURI->GetAsciiSpec(uristr);
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:                ("nsDocShell[%p]: loading %s with flags 0x%08x",
    1:                 this, uristr.get(), aLoadFlags));
    1:     }
    1: #endif
    1: 
    1:     if (!shEntry &&
    1:         !LOAD_TYPE_HAS_FLAGS(loadType, LOAD_FLAGS_REPLACE_HISTORY)) {
    1:         // First verify if this is a subframe.
    1:         nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
    1:         GetSameTypeParent(getter_AddRefs(parentAsItem));
    1:         nsCOMPtr<nsIDocShell> parentDS(do_QueryInterface(parentAsItem));
    1:         PRUint32 parentLoadType;
    1: 
 3233:         if (parentDS && parentDS != static_cast<nsIDocShell *>(this)) {
    1:             /* OK. It is a subframe. Checkout the 
    1:              * parent's loadtype. If the parent was loaded thro' a history
    1:              * mechanism, then get the SH entry for the child from the parent.
    1:              * This is done to restore frameset navigation while going back/forward.
    1:              * If the parent was loaded through any other loadType, set the
    1:              * child's loadType too accordingly, so that session history does not
    1:              * get confused. 
    1:              */
    1:             
    1:             // Get the parent's load type
    1:             parentDS->GetLoadType(&parentLoadType);            
    1: 
    1:             nsCOMPtr<nsIDocShellHistory> parent(do_QueryInterface(parentAsItem));
    1:             if (parent) {
    1:                 // Get the ShEntry for the child from the parent
50721:                 nsCOMPtr<nsISHEntry> currentSH;
79445:                 bool oshe = false;
50721:                 parent->GetCurrentSHEntry(getter_AddRefs(currentSH), &oshe);
79445:                 bool dynamicallyAddedChild = mDynamicallyCreated;
50721:                 if (!dynamicallyAddedChild && !oshe && currentSH) {
50721:                     currentSH->HasDynamicallyAddedChild(&dynamicallyAddedChild);
50721:                 }
50721:                 if (!dynamicallyAddedChild) {
50721:                     // Only use the old SHEntry, if we're sure enough that
50721:                     // it wasn't originally for some other frame.
    1:                     parent->GetChildSHEntry(mChildOffset, getter_AddRefs(shEntry));
50721:                 }
50721: 
    1:                 // Make some decisions on the child frame's loadType based on the 
    1:                 // parent's loadType. 
    1:                 if (mCurrentURI == nsnull) {
    1:                     // This is a newly created frame. Check for exception cases first. 
    1:                     // By default the subframe will inherit the parent's loadType.
    1:                     if (shEntry && (parentLoadType == LOAD_NORMAL ||
    1:                                     parentLoadType == LOAD_LINK   ||
    1:                                     parentLoadType == LOAD_NORMAL_EXTERNAL)) {
    1:                         // The parent was loaded normally. In this case, this *brand new* child really shouldn't
    1:                         // have a SHEntry. If it does, it could be because the parent is replacing an
    1:                         // existing frame with a new frame, in the onLoadHandler. We don't want this
37802:                         // url to get into session history. Clear off shEntry, and set load type to
    1:                         // LOAD_BYPASS_HISTORY. 
79445:                         bool inOnLoadHandler=false;
    1:                         parentDS->GetIsExecutingOnLoadHandler(&inOnLoadHandler);
    1:                         if (inOnLoadHandler) {
    1:                             loadType = LOAD_NORMAL_REPLACE;
    1:                             shEntry = nsnull;
    1:                         }
    1:                     }   
    1:                     else if (parentLoadType == LOAD_REFRESH) {
    1:                         // Clear shEntry. For refresh loads, we have to load
    1:                         // what comes thro' the pipe, not what's in history.
    1:                         shEntry = nsnull;
    1:                     }
    1:                     else if ((parentLoadType == LOAD_BYPASS_HISTORY) ||
    1:                              (parentLoadType == LOAD_ERROR_PAGE) ||
    1:                               (shEntry && 
    1:                                ((parentLoadType & LOAD_CMD_HISTORY) || 
    1:                                 (parentLoadType == LOAD_RELOAD_NORMAL) || 
    1:                                 (parentLoadType == LOAD_RELOAD_CHARSET_CHANGE)))) {
    1:                         // If the parent url, bypassed history or was loaded from
    1:                         // history, pass on the parent's loadType to the new child 
    1:                         // frame too, so that the child frame will also
    1:                         // avoid getting into history. 
    1:                         loadType = parentLoadType;
    1:                     }
    1:                 }
    1:                 else {
    1:                     // This is a pre-existing subframe. If the load was not originally initiated
    1:                     // by session history, (if (!shEntry) condition succeeded) and mCurrentURI is not null,
    1:                     // it is possible that a parent's onLoadHandler or even self's onLoadHandler is loading 
    1:                     // a new page in this child. Check parent's and self's busy flag  and if it is set,
    1:                     // we don't want this onLoadHandler load to get in to session history.
    1:                     PRUint32 parentBusy = BUSY_FLAGS_NONE;
    1:                     PRUint32 selfBusy = BUSY_FLAGS_NONE;
    1:                     parentDS->GetBusyFlags(&parentBusy);                    
    1:                     GetBusyFlags(&selfBusy);
74787:                     if (parentBusy & BUSY_FLAGS_BUSY ||
74787:                         selfBusy & BUSY_FLAGS_BUSY) {
    1:                         loadType = LOAD_NORMAL_REPLACE;
    1:                         shEntry = nsnull; 
    1:                     }
    1:                 }
    1:             } // parent
    1:         } //parentDS
    1:         else {  
    1:             // This is the root docshell. If we got here while  
    1:             // executing an onLoad Handler,this load will not go 
    1:             // into session history.
79445:             bool inOnLoadHandler=false;
    1:             GetIsExecutingOnLoadHandler(&inOnLoadHandler);
    1:             if (inOnLoadHandler) {
    1:                 loadType = LOAD_NORMAL_REPLACE;
    1:             }
    1:         } 
    1:     } // !shEntry
    1: 
    1:     if (shEntry) {
    1: #ifdef DEBUG
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:               ("nsDocShell[%p]: loading from session history", this));
    1: #endif
    1: 
25969:         return LoadHistoryEntry(shEntry, loadType);
25969:     }
25969: 
    1:     // Perform the load...
25969: 
25969:     // We need an owner (a referring principal).
25969:     //
25969:     // If ownerIsExplicit is not set there are 4 possibilities:
 3596:     // (1) If the system principal was passed in and we're a typeContent
 3596:     //     docshell, inherit the principal from the current document
 3596:     //     instead.
 3596:     // (2) In all other cases when the principal passed in is not null,
 3596:     //     use that principal.
 3596:     // (3) If the caller has allowed inheriting from the current document,
    1:     //     or if we're being called from system code (eg chrome JS or pure
    1:     //     C++) then inheritOwner should be true and InternalLoad will get
    1:     //     an owner from the current document. If none of these things are
    1:     //     true, then
 3596:     // (4) we pass a null owner into the channel, and an owner will be
 3596:     //     created later from the channel's internal data.
    1:     //
25969:     // If ownerIsExplicit *is* set, there are 4 possibilities
25969:     // (1) If the system principal was passed in and we're a typeContent
25969:     //     docshell, return an error.
25969:     // (2) In all other cases when the principal passed in is not null,
25969:     //     use that principal.
25969:     // (3) If the caller has allowed inheriting from the current document,
25969:     //     then inheritOwner should be true and InternalLoad will get an owner
25969:     //     from the current document. If none of these things are true, then
25969:     // (4) we pass a null owner into the channel, and an owner will be
25969:     //     created later from the channel's internal data.
25969:     //
    1:     // NOTE: This all only works because the only thing the owner is used  
 3596:     //       for in InternalLoad is data:, javascript:, and about:blank
 3596:     //       URIs.  For other URIs this would all be dead wrong!
25969: 
 3596:     nsCOMPtr<nsIScriptSecurityManager> secMan =
 3596:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
 3596:     NS_ENSURE_SUCCESS(rv, rv);
 3596: 
 3596:     if (owner && mItemType != typeChrome) {
 3596:         nsCOMPtr<nsIPrincipal> ownerPrincipal = do_QueryInterface(owner);
79445:         bool isSystem;
 3596:         rv = secMan->IsSystemPrincipal(ownerPrincipal, &isSystem);
 3596:         NS_ENSURE_SUCCESS(rv, rv);
 3596: 
 3596:         if (isSystem) {
25969:             if (ownerIsExplicit) {
25969:                 return NS_ERROR_DOM_SECURITY_ERR;
25969:             }
 3596:             owner = nsnull;
 3596:             inheritOwner = PR_TRUE;
 3596:         }
 3596:     }
25969:     if (!owner && !inheritOwner && !ownerIsExplicit) {
    1:         // See if there's system or chrome JS code running
    1:         rv = secMan->SubjectPrincipalIsSystem(&inheritOwner);
    1:         if (NS_FAILED(rv)) {
    1:             // Set it back to false
    1:             inheritOwner = PR_FALSE;
    1:         }
    1:     }
    1: 
69941:     if (aLoadFlags & LOAD_FLAGS_DISALLOW_INHERIT_OWNER) {
69941:         inheritOwner = PR_FALSE;
69941:         owner = do_CreateInstance("@mozilla.org/nullprincipal;1");
69941:     }
69941: 
    1:     PRUint32 flags = 0;
    1: 
69941:     if (inheritOwner)
    1:         flags |= INTERNAL_LOAD_FLAGS_INHERIT_OWNER;
    1: 
    1:     if (!sendReferrer)
    1:         flags |= INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER;
    1:             
    1:     if (aLoadFlags & LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP)
    1:         flags |= INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
    1: 
    1:     if (aLoadFlags & LOAD_FLAGS_FIRST_LOAD)
    1:         flags |= INTERNAL_LOAD_FLAGS_FIRST_LOAD;
    1: 
10966:     if (aLoadFlags & LOAD_FLAGS_BYPASS_CLASSIFIER)
10966:         flags |= INTERNAL_LOAD_FLAGS_BYPASS_CLASSIFIER;
10966: 
29288:     if (aLoadFlags & LOAD_FLAGS_FORCE_ALLOW_COOKIES)
29288:         flags |= INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES;
29288: 
25969:     return InternalLoad(aURI,
    1:                         referrer,
    1:                         owner,
    1:                         flags,
    1:                         target.get(),
    1:                         nsnull,         // No type hint
    1:                         postStream,
    1:                         headersStream,
    1:                         loadType,
    1:                         nsnull,         // No SHEntry
    1:                         aFirstParty,
    1:                         nsnull,         // No nsIDocShell
54823:                         nsnull);        // No nsIRequest
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::LoadStream(nsIInputStream *aStream, nsIURI * aURI,
    1:                        const nsACString &aContentType,
    1:                        const nsACString &aContentCharset,
    1:                        nsIDocShellLoadInfo * aLoadInfo)
    1: {
    1:     NS_ENSURE_ARG(aStream);
    1: 
    1:     mAllowKeywordFixup = PR_FALSE;
    1: 
    1:     // if the caller doesn't pass in a URI we need to create a dummy URI. necko
    1:     // currently requires a URI in various places during the load. Some consumers
    1:     // do as well.
    1:     nsCOMPtr<nsIURI> uri = aURI;
    1:     if (!uri) {
    1:         // HACK ALERT
    1:         nsresult rv = NS_OK;
    1:         uri = do_CreateInstance(NS_SIMPLEURI_CONTRACTID, &rv);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:         // Make sure that the URI spec "looks" like a protocol and path...
    1:         // For now, just use a bogus protocol called "internal"
    1:         rv = uri->SetSpec(NS_LITERAL_CSTRING("internal:load-stream"));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     PRUint32 loadType = LOAD_NORMAL;
    1:     if (aLoadInfo) {
    1:         nsDocShellInfoLoadType lt = nsIDocShellLoadInfo::loadNormal;
    1:         (void) aLoadInfo->GetLoadType(&lt);
    1:         // Get the appropriate LoadType from nsIDocShellLoadInfo type
    1:         loadType = ConvertDocShellLoadInfoToLoadType(lt);
    1:     }
    1: 
    1:     NS_ENSURE_SUCCESS(Stop(nsIWebNavigation::STOP_NETWORK), NS_ERROR_FAILURE);
    1: 
    1:     mLoadType = loadType;
    1: 
    1:     // build up a channel for this stream.
    1:     nsCOMPtr<nsIChannel> channel;
    1:     NS_ENSURE_SUCCESS(NS_NewInputStreamChannel
    1:                       (getter_AddRefs(channel), uri, aStream,
    1:                        aContentType, aContentCharset),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsIURILoader>
    1:         uriLoader(do_GetService(NS_URI_LOADER_CONTRACTID));
    1:     NS_ENSURE_TRUE(uriLoader, NS_ERROR_FAILURE);
    1: 
10966:     NS_ENSURE_SUCCESS(DoChannelLoad(channel, uriLoader, PR_FALSE),
10966:                       NS_ERROR_FAILURE);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::CreateLoadInfo(nsIDocShellLoadInfo ** aLoadInfo)
    1: {
    1:     nsDocShellLoadInfo *loadInfo = new nsDocShellLoadInfo();
    1:     NS_ENSURE_TRUE(loadInfo, NS_ERROR_OUT_OF_MEMORY);
    1:     nsCOMPtr<nsIDocShellLoadInfo> localRef(loadInfo);
    1: 
    1:     *aLoadInfo = localRef;
    1:     NS_ADDREF(*aLoadInfo);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: /*
    1:  * Reset state to a new content model within the current document and the document
    1:  * viewer.  Called by the document before initiating an out of band document.write().
    1:  */
    1: NS_IMETHODIMP
    1: nsDocShell::PrepareForNewContentModel()
    1: {
    1:   mEODForCurrentDocument = PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::FirePageHideNotification(bool aIsUnload)
    1: {
    1:     if (mContentViewer && !mFiredUnloadEvent) {
    1:         // Keep an explicit reference since calling PageHide could release
    1:         // mContentViewer
    1:         nsCOMPtr<nsIContentViewer> kungFuDeathGrip(mContentViewer);
    1:         mFiredUnloadEvent = PR_TRUE;
    1: 
72298:         if (mTiming) {
72298:             mTiming->NotifyUnloadEventStart();
72298:         }
72298: 
    1:         mContentViewer->PageHide(aIsUnload);
    1: 
72298:         if (mTiming) {
72298:             mTiming->NotifyUnloadEventEnd();
72298:         }
72298: 
 8259:         nsAutoTArray<nsCOMPtr<nsIDocShell>, 8> kids;
29263:         PRInt32 i, n = mChildList.Count();
 8259:         kids.SetCapacity(n);
    1:         for (i = 0; i < n; i++) {
29263:             kids.AppendElement(do_QueryInterface(ChildAt(i)));
 8259:         }
 8259: 
 8259:         n = kids.Length();
 8259:         for (i = 0; i < n; ++i) {
 8259:             if (kids[i]) {
 8259:                 kids[i]->FirePageHideNotification(aIsUnload);
    1:             }
    1:         }
14631:         // Now make sure our editor, if any, is detached before we go
 8553:         // any farther.
14631:         DetachEditorFromWindow();
 8553:     }
 8553: 
    1:     return NS_OK;
    1: }
    1: 
72298: nsresult
72298: nsDocShell::MaybeInitTiming()
72298: {
72298:     if (mTiming) {
72298:         return NS_OK;
72298:     }
72298: 
79445:     if (Preferences::GetBool("dom.enable_performance", false)) {
72298:         mTiming = new nsDOMNavigationTiming();
72298:         mTiming->NotifyNavigationStart();
72298:     }
72298:     return NS_OK;
72298: }
72298: 
72298: 
    1: //
    1: // Bug 13871: Prevent frameset spoofing
    1: //
    1: // This routine answers: 'Is origin's document from same domain as
    1: // target's document?'
    1: //
13337: // file: uris are considered the same domain for the purpose of
13337: // frame navigation regardless of script accessibility (bug 420425)
13337: //
    1: /* static */
79445: bool
    1: nsDocShell::ValidateOrigin(nsIDocShellTreeItem* aOriginTreeItem,
    1:                            nsIDocShellTreeItem* aTargetTreeItem)
    1: {
    1:     nsCOMPtr<nsIScriptSecurityManager> securityManager =
    1:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
    1:     NS_ENSURE_TRUE(securityManager, PR_FALSE);
    1: 
    1:     nsCOMPtr<nsIPrincipal> subjectPrincipal;
    1:     nsresult rv =
    1:         securityManager->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
    1:     NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:     if (subjectPrincipal) {
    1:         // We're called from JS, check if UniversalBrowserWrite is
    1:         // enabled.
79445:         bool ubwEnabled = false;
    1:         rv = securityManager->IsCapabilityEnabled("UniversalBrowserWrite",
    1:                                                   &ubwEnabled);
    1:         NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1: 
    1:         if (ubwEnabled) {
    1:             return PR_TRUE;
    1:         }
    1:     }
    1: 
    1:     // Get origin document principal
48097:     nsCOMPtr<nsIDocument> originDocument(do_GetInterface(aOriginTreeItem));
    1:     NS_ENSURE_TRUE(originDocument, PR_FALSE);
    1: 
    1:     // Get target principal
48097:     nsCOMPtr<nsIDocument> targetDocument(do_GetInterface(aTargetTreeItem));
    1:     NS_ENSURE_TRUE(targetDocument, PR_FALSE);
    1: 
79445:     bool equal;
13337:     rv = originDocument->NodePrincipal()->
13337:             Equals(targetDocument->NodePrincipal(), &equal);
13337:     if (NS_SUCCEEDED(rv) && equal) {
13337:         return PR_TRUE;
13337:     }
13337: 
13337:     // Not strictly equal, special case if both are file: uris
79445:     bool originIsFile = false;
79445:     bool targetIsFile = false;
13337:     nsCOMPtr<nsIURI> originURI;
13337:     nsCOMPtr<nsIURI> targetURI;
13337:     nsCOMPtr<nsIURI> innerOriginURI;
13337:     nsCOMPtr<nsIURI> innerTargetURI;
13337: 
13337:     rv = originDocument->NodePrincipal()->GetURI(getter_AddRefs(originURI));
14261:     if (NS_SUCCEEDED(rv) && originURI)
13337:         innerOriginURI = NS_GetInnermostURI(originURI);
13337: 
13337:     rv = targetDocument->NodePrincipal()->GetURI(getter_AddRefs(targetURI));
14261:     if (NS_SUCCEEDED(rv) && targetURI)
13337:         innerTargetURI = NS_GetInnermostURI(targetURI);
13337: 
13337:     return innerOriginURI && innerTargetURI &&
13338:         NS_SUCCEEDED(innerOriginURI->SchemeIs("file", &originIsFile)) &&
13338:         NS_SUCCEEDED(innerTargetURI->SchemeIs("file", &targetIsFile)) &&
13337:         originIsFile && targetIsFile;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetEldestPresContext(nsPresContext** aPresContext)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     NS_ENSURE_ARG_POINTER(aPresContext);
    1:     *aPresContext = nsnull;
    1: 
    1:     nsCOMPtr<nsIContentViewer> viewer = mContentViewer;
    1:     while (viewer) {
    1:         nsCOMPtr<nsIContentViewer> prevViewer;
    1:         viewer->GetPreviousViewer(getter_AddRefs(prevViewer));
    1:         if (prevViewer)
    1:             viewer = prevViewer;
    1:         else {
    1:             nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(viewer));
    1:             if (docv)
    1:                 rv = docv->GetPresContext(aPresContext);
    1:             break;
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPresContext(nsPresContext ** aPresContext)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aPresContext);
    1:     *aPresContext = nsnull;
    1: 
    1:     if (!mContentViewer)
    1:       return NS_OK;
    1: 
    1:     nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(mContentViewer));
    1:     NS_ENSURE_TRUE(docv, NS_ERROR_NO_INTERFACE);
    1: 
    1:     return docv->GetPresContext(aPresContext);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPresShell(nsIPresShell ** aPresShell)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     NS_ENSURE_ARG_POINTER(aPresShell);
    1:     *aPresShell = nsnull;
    1: 
39823:     nsRefPtr<nsPresContext> presContext;
    1:     (void) GetPresContext(getter_AddRefs(presContext));
    1: 
    1:     if (presContext) {
    1:         NS_IF_ADDREF(*aPresShell = presContext->GetPresShell());
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetEldestPresShell(nsIPresShell** aPresShell)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     NS_ENSURE_ARG_POINTER(aPresShell);
    1:     *aPresShell = nsnull;
    1: 
39823:     nsRefPtr<nsPresContext> presContext;
    1:     (void) GetEldestPresContext(getter_AddRefs(presContext));
    1: 
    1:     if (presContext) {
    1:         NS_IF_ADDREF(*aPresShell = presContext->GetPresShell());
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetContentViewer(nsIContentViewer ** aContentViewer)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aContentViewer);
    1: 
    1:     *aContentViewer = mContentViewer;
    1:     NS_IF_ADDREF(*aContentViewer);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetChromeEventHandler(nsIDOMEventTarget* aChromeEventHandler)
    1: {
    1:     // Weak reference. Don't addref.
72327:     mChromeEventHandler = aChromeEventHandler;
    1: 
16549:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
16549:     if (win) {
72327:         win->SetChromeEventHandler(aChromeEventHandler);
16549:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetChromeEventHandler(nsIDOMEventTarget** aChromeEventHandler)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChromeEventHandler);
    1:     nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(mChromeEventHandler);
    1:     target.swap(*aChromeEventHandler);
    1:     return NS_OK;
    1: }
    1: 
71723: /* [noscript] void setCurrentURI (in nsIURI uri); */
    1: NS_IMETHODIMP
    1: nsDocShell::SetCurrentURI(nsIURI *aURI)
    1: {
71723:     SetCurrentURI(aURI, nsnull, PR_TRUE);
    1:     return NS_OK;
    1: }
    1: 
79445: bool
    1: nsDocShell::SetCurrentURI(nsIURI *aURI, nsIRequest *aRequest,
79445:                           bool aFireOnLocationChange)
    1: {
    1: #ifdef PR_LOGGING
    1:     if (gDocShellLeakLog && PR_LOG_TEST(gDocShellLeakLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         if (aURI)
    1:             aURI->GetSpec(spec);
    1:         PR_LogPrint("DOCSHELL %p SetCurrentURI %s\n", this, spec.get());
    1:     }
    1: #endif
    1: 
    1:     // We don't want to send a location change when we're displaying an error
    1:     // page, and we don't want to change our idea of "current URI" either
    1:     if (mLoadType == LOAD_ERROR_PAGE) {
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     mCurrentURI = NS_TryToMakeImmutable(aURI);
    1:     
79445:     bool isRoot = false;   // Is this the root docshell
79445:     bool isSubFrame = false;  // Is this a subframe navigation?
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1: 
    1:     GetSameTypeRootTreeItem(getter_AddRefs(root));
 3233:     if (root.get() == static_cast<nsIDocShellTreeItem *>(this)) 
    1:     {
    1:         // This is the root docshell
    1:         isRoot = PR_TRUE;
    1:     }
    1:     if (mLSHE) {
    1:         mLSHE->GetIsSubFrame(&isSubFrame);
    1:     }
    1: 
    1:     if (!isSubFrame && !isRoot) {
    1:       /* 
    1:        * We don't want to send OnLocationChange notifications when
    1:        * a subframe is being loaded for the first time, while
    1:        * visiting a frameset page
    1:        */
    1:       return PR_FALSE; 
    1:     }
    1: 
    1:     if (aFireOnLocationChange) {
71723:         FireOnLocationChange(this, aRequest, aURI);
    1:     }
    1:     return !aFireOnLocationChange;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCharset(char** aCharset)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aCharset);
    1:     *aCharset = nsnull; 
    1: 
    1:     nsCOMPtr<nsIPresShell> presShell;
    1:     GetPresShell(getter_AddRefs(presShell));
    1:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1:     nsIDocument *doc = presShell->GetDocument();
    1:     NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
    1:     *aCharset = ToNewCString(doc->GetDocumentCharacterSet());
    1:     if (!*aCharset) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetCharset(const char* aCharset)
    1: {
    1:     // set the default charset
    1:     nsCOMPtr<nsIContentViewer> viewer;
    1:     GetContentViewer(getter_AddRefs(viewer));
    1:     if (viewer) {
    1:       nsCOMPtr<nsIMarkupDocumentViewer> muDV(do_QueryInterface(viewer));
    1:       if (muDV) {
38791:         nsCString charset(aCharset);
38791:         NS_ENSURE_SUCCESS(muDV->SetDefaultCharacterSet(charset),
    1:                           NS_ERROR_FAILURE);
    1:       }
    1:     }
    1: 
    1:     // set the charset override
    1:     nsCOMPtr<nsIDocumentCharsetInfo> dcInfo;
    1:     GetDocumentCharsetInfo(getter_AddRefs(dcInfo));
    1:     if (dcInfo) {
    1:       nsCOMPtr<nsIAtom> csAtom;
    1:       csAtom = do_GetAtom(aCharset);
    1:       dcInfo->SetForcedCharset(csAtom);
    1:     }
    1: 
    1:     return NS_OK;
    1: } 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetDocumentCharsetInfo(nsIDocumentCharsetInfo **
    1:                                    aDocumentCharsetInfo)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aDocumentCharsetInfo);
    1: 
    1:     // if the mDocumentCharsetInfo does not exist already, we create it now
    1:     if (!mDocumentCharsetInfo) {
    1:         mDocumentCharsetInfo = do_CreateInstance(NS_DOCUMENTCHARSETINFO_CONTRACTID);
    1:         if (!mDocumentCharsetInfo)
    1:             return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     *aDocumentCharsetInfo = mDocumentCharsetInfo;
    1:     NS_IF_ADDREF(*aDocumentCharsetInfo);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetDocumentCharsetInfo(nsIDocumentCharsetInfo *
    1:                                    aDocumentCharsetInfo)
    1: {
    1:     mDocumentCharsetInfo = aDocumentCharsetInfo;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetChannelIsUnsafe(bool *aUnsafe)
 8363: {
 8363:     *aUnsafe = PR_FALSE;
 8363: 
37433:     nsIChannel* channel = GetCurrentDocChannel();
 8363:     if (!channel) {
 8363:         return NS_OK;
 8363:     }
 8363: 
 8363:     nsCOMPtr<nsIJARChannel> jarChannel = do_QueryInterface(channel);
 8363:     if (!jarChannel) {
 8363:         return NS_OK;
 8363:     }
 8363: 
 8363:     return jarChannel->GetIsUnsafe(aUnsafe);
 8363: }
 8363: 
 8363: NS_IMETHODIMP
79445: nsDocShell::GetAllowPlugins(bool * aAllowPlugins)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aAllowPlugins);
    1: 
    1:     *aAllowPlugins = mAllowPlugins;
 8363:     if (!mAllowPlugins) {
 8363:         return NS_OK;
 8363:     }
 8363: 
79445:     bool unsafe;
 8363:     *aAllowPlugins = NS_SUCCEEDED(GetChannelIsUnsafe(&unsafe)) && !unsafe;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::SetAllowPlugins(bool aAllowPlugins)
    1: {
    1:     mAllowPlugins = aAllowPlugins;
    1:     //XXX should enable or disable a plugin host
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetAllowJavascript(bool * aAllowJavascript)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aAllowJavascript);
    1: 
    1:     *aAllowJavascript = mAllowJavascript;
 8363:     if (!mAllowJavascript) {
 8363:         return NS_OK;
 8363:     }
 8363: 
79445:     bool unsafe;
 8363:     *aAllowJavascript = NS_SUCCEEDED(GetChannelIsUnsafe(&unsafe)) && !unsafe;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::SetAllowJavascript(bool aAllowJavascript)
    1: {
    1:     mAllowJavascript = aAllowJavascript;
    1:     return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDocShell::GetAllowMetaRedirects(bool * aReturn)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:     *aReturn = mAllowMetaRedirects;
 8363:     if (!mAllowMetaRedirects) {
 8363:         return NS_OK;
 8363:     }
 8363: 
79445:     bool unsafe;
 8363:     *aReturn = NS_SUCCEEDED(GetChannelIsUnsafe(&unsafe)) && !unsafe;
    1:     return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDocShell::SetAllowMetaRedirects(bool aValue)
    1: {
    1:     mAllowMetaRedirects = aValue;
    1:     return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDocShell::GetAllowSubframes(bool * aAllowSubframes)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aAllowSubframes);
    1: 
    1:     *aAllowSubframes = mAllowSubframes;
    1:     return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDocShell::SetAllowSubframes(bool aAllowSubframes)
    1: {
    1:     mAllowSubframes = aAllowSubframes;
    1:     return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDocShell::GetAllowImages(bool * aAllowImages)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aAllowImages);
    1: 
    1:     *aAllowImages = mAllowImages;
    1:     return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDocShell::SetAllowImages(bool aAllowImages)
    1: {
    1:     mAllowImages = aAllowImages;
    1:     return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDocShell::GetAllowDNSPrefetch(bool * aAllowDNSPrefetch)
28460: {
28460:     *aAllowDNSPrefetch = mAllowDNSPrefetch;
28460:     return NS_OK;
28460: }
28460: 
79445: NS_IMETHODIMP nsDocShell::SetAllowDNSPrefetch(bool aAllowDNSPrefetch)
28460: {
28460:     mAllowDNSPrefetch = aAllowDNSPrefetch;
28460:     return NS_OK;
28460: }
28460: 
79445: NS_IMETHODIMP nsDocShell::GetAllowWindowControl(bool * aAllowWindowControl)
72453: {
72453:     *aAllowWindowControl = mAllowWindowControl;
72453:     return NS_OK;
72453: }
72453: 
79445: NS_IMETHODIMP nsDocShell::SetAllowWindowControl(bool aAllowWindowControl)
72453: {
72453:     mAllowWindowControl = aAllowWindowControl;
72453:     return NS_OK;
72453: }
72453: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetDocShellEnumerator(PRInt32 aItemType, PRInt32 aDirection, nsISimpleEnumerator **outEnum)
    1: {
    1:     NS_ENSURE_ARG_POINTER(outEnum);
    1:     *outEnum = nsnull;
    1:     
    1:     nsRefPtr<nsDocShellEnumerator> docShellEnum;
    1:     if (aDirection == ENUMERATE_FORWARDS)
    1:         docShellEnum = new nsDocShellForwardsEnumerator;
    1:     else
    1:         docShellEnum = new nsDocShellBackwardsEnumerator;
    1:     
    1:     if (!docShellEnum) return NS_ERROR_OUT_OF_MEMORY;
    1:     
    1:     nsresult rv = docShellEnum->SetEnumDocShellType(aItemType);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = docShellEnum->SetEnumerationRootItem((nsIDocShellTreeItem *)this);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = docShellEnum->First();
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     rv = docShellEnum->QueryInterface(NS_GET_IID(nsISimpleEnumerator), (void **)outEnum);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetAppType(PRUint32 * aAppType)
    1: {
    1:     *aAppType = mAppType;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetAppType(PRUint32 aAppType)
    1: {
    1:     mAppType = aAppType;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetAllowAuth(bool * aAllowAuth)
    1: {
    1:     *aAllowAuth = mAllowAuth;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::SetAllowAuth(bool aAllowAuth)
    1: {
    1:     mAllowAuth = aAllowAuth;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetZoom(float *zoom)
    1: {
    1:     NS_ENSURE_ARG_POINTER(zoom);
    1:     *zoom = 1.0f;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetZoom(float zoom)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetMarginWidth(PRInt32 * aWidth)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aWidth);
    1: 
    1:     *aWidth = mMarginWidth;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetMarginWidth(PRInt32 aWidth)
    1: {
    1:     mMarginWidth = aWidth;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetMarginHeight(PRInt32 * aHeight)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aHeight);
    1: 
    1:     *aHeight = mMarginHeight;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetMarginHeight(PRInt32 aHeight)
    1: {
    1:     mMarginHeight = aHeight;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetBusyFlags(PRUint32 * aBusyFlags)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aBusyFlags);
    1: 
    1:     *aBusyFlags = mBusyFlags;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::TabToTreeOwner(bool aForward, bool* aTookFocus)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aTookFocus);
    1:     
    1:     nsCOMPtr<nsIWebBrowserChromeFocus> chromeFocus = do_GetInterface(mTreeOwner);
    1:     if (chromeFocus) {
    1:         if (aForward)
    1:             *aTookFocus = NS_SUCCEEDED(chromeFocus->FocusNextElement());
    1:         else
    1:             *aTookFocus = NS_SUCCEEDED(chromeFocus->FocusPrevElement());
    1:     } else
    1:         *aTookFocus = PR_FALSE;
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSecurityUI(nsISecureBrowserUI **aSecurityUI)
    1: {
    1:     NS_IF_ADDREF(*aSecurityUI = mSecurityUI);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetSecurityUI(nsISecureBrowserUI *aSecurityUI)
    1: {
    1:     mSecurityUI = aSecurityUI;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetUseErrorPages(bool *aUseErrorPages)
    1: {
    1:     *aUseErrorPages = mUseErrorPages;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::SetUseErrorPages(bool aUseErrorPages)
    1: {
    1:     // If mUseErrorPages is set explicitly, stop observing the pref.
    1:     if (mObserveErrorPages) {
72449:         Preferences::RemoveObserver(this, "browser.xul.error_pages.enabled");
    1:         mObserveErrorPages = PR_FALSE;
    1:     }
    1:     mUseErrorPages = aUseErrorPages;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
19870: nsDocShell::GetPreviousTransIndex(PRInt32 *aPreviousTransIndex)
19870: {
19870:     *aPreviousTransIndex = mPreviousTransIndex;
19870:     return NS_OK;
19870: }
19870: 
19870: NS_IMETHODIMP
19870: nsDocShell::GetLoadedTransIndex(PRInt32 *aLoadedTransIndex)
19870: {
19870:     *aLoadedTransIndex = mLoadedTransIndex;
19870:     return NS_OK;
19870: }
19870: 
19870: NS_IMETHODIMP
19870: nsDocShell::HistoryPurged(PRInt32 aNumEntries)
19870: {
19870:     // These indices are used for fastback cache eviction, to determine
19870:     // which session history entries are candidates for content viewer
19870:     // eviction.  We need to adjust by the number of entries that we
19870:     // just purged from history, so that we look at the right session history
19870:     // entries during eviction.
38012:     mPreviousTransIndex = NS_MAX(-1, mPreviousTransIndex - aNumEntries);
38012:     mLoadedTransIndex = NS_MAX(0, mLoadedTransIndex - aNumEntries);
19870: 
29263:     PRInt32 count = mChildList.Count();
29263:     for (PRInt32 i = 0; i < count; ++i) {
29263:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
19870:         if (shell) {
19870:             shell->HistoryPurged(aNumEntries);
19870:         }
19870:     }
19870: 
19870:     return NS_OK;
19870: }
19870: 
52044: nsresult
52044: nsDocShell::HistoryTransactionRemoved(PRInt32 aIndex)
52044: {
52044:     // These indices are used for fastback cache eviction, to determine
52044:     // which session history entries are candidates for content viewer
52044:     // eviction.  We need to adjust by the number of entries that we
52044:     // just purged from history, so that we look at the right session history
52044:     // entries during eviction.
52044:     if (aIndex == mPreviousTransIndex) {
52044:         mPreviousTransIndex = -1;
52044:     } else if (aIndex < mPreviousTransIndex) {
52044:         --mPreviousTransIndex;
52044:     }
52044:     if (mLoadedTransIndex == aIndex) {
52044:         mLoadedTransIndex = 0;
52044:     } else if (aIndex < mLoadedTransIndex) {
52044:         --mLoadedTransIndex;
52044:     }
52044:                             
52044:     PRInt32 count = mChildList.Count();
52044:     for (PRInt32 i = 0; i < count; ++i) {
52044:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
52044:         if (shell) {
52044:             static_cast<nsDocShell*>(shell.get())->
52044:                 HistoryTransactionRemoved(aIndex);
52044:         }
52044:     }
52044: 
52044:     return NS_OK;
52044: }
52044: 
28820: static
28820: nsresult
28820: GetPrincipalDomain(nsIPrincipal* aPrincipal, nsACString& aDomain)
28820: {
28820:   aDomain.Truncate();
28820: 
28820:   nsCOMPtr<nsIURI> codebaseURI;
28820:   nsresult rv = aPrincipal->GetDomain(getter_AddRefs(codebaseURI));
28820:   NS_ENSURE_SUCCESS(rv, rv);
28820:   if (!codebaseURI) {
28820:      rv = aPrincipal->GetURI(getter_AddRefs(codebaseURI));
28820:      NS_ENSURE_SUCCESS(rv, rv);
28820:   }
28820: 
28820:   if (!codebaseURI)
28820:      return NS_OK;
28820: 
28820:   nsCOMPtr<nsIURI> innerURI = NS_GetInnermostURI(codebaseURI);
28820:   NS_ASSERTION(innerURI, "Failed to get innermost URI");
28820:   NS_ENSURE_SUCCESS(rv, rv);
28820: 
28820:   rv = innerURI->GetAsciiHost(aDomain);
28820:   if (NS_FAILED(rv))
28820:       return rv;
28820: 
28820:   return NS_OK;
28820: }
28820: 
19870: NS_IMETHODIMP
23579: nsDocShell::GetSessionStorageForPrincipal(nsIPrincipal* aPrincipal,
37608:                                           const nsAString& aDocumentURI,
79445:                                           bool aCreate,
28676:                                           nsIDOMStorage** aStorage)
23579: {
23579:     NS_ENSURE_ARG_POINTER(aStorage);
23579:     *aStorage = nsnull;
23579: 
23579:     if (!aPrincipal)
23579:         return NS_OK;
23579: 
28676:     nsresult rv;
28676: 
28676:     nsCOMPtr<nsIDocShellTreeItem> topItem;
28676:     rv = GetSameTypeRootTreeItem(getter_AddRefs(topItem));
28676:     if (NS_FAILED(rv))
28676:         return rv;
28676: 
28676:     if (!topItem)
28676:         return NS_ERROR_FAILURE;
28676: 
28676:     nsDocShell* topDocShell = static_cast<nsDocShell*>(topItem.get());
28676:     if (topDocShell != this)
37608:         return topDocShell->GetSessionStorageForPrincipal(aPrincipal,
37608:                                                           aDocumentURI,
37608:                                                           aCreate,
28676:                                                           aStorage);
28676: 
28820:     nsCAutoString currentDomain;
28820:     rv = GetPrincipalDomain(aPrincipal, currentDomain);
28676:     if (NS_FAILED(rv))
28676:         return rv;
28676: 
28820:     if (currentDomain.IsEmpty())
28820:         return NS_OK;
28820: 
28820:     if (!mStorages.Get(currentDomain, aStorage) && aCreate) {
28676:         nsCOMPtr<nsIDOMStorage> newstorage =
28676:             do_CreateInstance("@mozilla.org/dom/storage;2");
28676:         if (!newstorage)
28676:             return NS_ERROR_OUT_OF_MEMORY;
28676: 
28676:         nsCOMPtr<nsPIDOMStorage> pistorage = do_QueryInterface(newstorage);
28676:         if (!pistorage)
28676:             return NS_ERROR_FAILURE;
37608:         rv = pistorage->InitAsSessionStorage(aPrincipal, aDocumentURI);
28820:         if (NS_FAILED(rv))
28820:             return rv;
28820: 
28820:         if (!mStorages.Put(currentDomain, newstorage))
28676:             return NS_ERROR_OUT_OF_MEMORY;
28676: 
28676:         newstorage.swap(*aStorage);
37608: #if defined(PR_LOGGING) && defined(DEBUG)
37608:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
37608:                ("nsDocShell[%p]: created a new sessionStorage %p",
37608:                 this, *aStorage));
37608: #endif
37608:     }
37608:     else if (*aStorage) {
23579:       nsCOMPtr<nsPIDOMStorage> piStorage = do_QueryInterface(*aStorage);
23579:       if (piStorage) {
79445:           bool canAccess = piStorage->CanAccess(aPrincipal);
23579:           NS_ASSERTION(canAccess,
23579:                        "GetSessionStorageForPrincipal got a storage "
23579:                        "that could not be accessed!");
23579:           if (!canAccess) {
23579:               NS_RELEASE(*aStorage);
23579:               return NS_ERROR_DOM_SECURITY_ERR;
23579:           }
23579:       }
23579: 
37608: #if defined(PR_LOGGING) && defined(DEBUG)
37608:       PR_LOG(gDocShellLog, PR_LOG_DEBUG,
37608:              ("nsDocShell[%p]: returns existing sessionStorage %p",
37608:               this, *aStorage));
37608: #endif
37608:     }
37608: 
37608:     if (aCreate) {
37608:         // We are asked to create a new storage object. This indicates
37608:         // that a new windows wants it. At this moment we "fork" the existing
37608:         // storage object (what it means is described in the paragraph bellow).
37608:         // We must create a single object per a single window to distinguish
37608:         // a window originating oparations on the storage object to succesfully
37608:         // prevent dispatch of a storage event to this same window that ivoked
37608:         // a change in its storage. We also do this to correctly fill
37608:         // documentURI property in the storage event.
37608:         //
37608:         // The difference between clone and fork is that clone creates
37608:         // a completelly new and independent storage, but fork only creates
37608:         // a new object wrapping the storage implementation and data and
37608:         // the forked storage then behaves completelly the same way as
37608:         // the storage it has been forked of, all such forked storage objects
37608:         // shares their state and data and change on one such object affects
37608:         // all others the same way.
37608:         nsCOMPtr<nsPIDOMStorage> piStorage = do_QueryInterface(*aStorage);
37608:         nsCOMPtr<nsIDOMStorage> fork = piStorage->Fork(aDocumentURI);
37608: #if defined(PR_LOGGING) && defined(DEBUG)
37608:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
37608:                ("nsDocShell[%p]: forked sessionStorage %p to %p",
37608:                 this, *aStorage, fork.get()));
37608: #endif
37608:         fork.swap(*aStorage);
37608:     }
37608: 
23579:     return NS_OK;
23579: }
23579: 
23579: NS_IMETHODIMP
    1: nsDocShell::GetSessionStorageForURI(nsIURI* aURI,
37608:                                     const nsAString& aDocumentURI,
28676:                                     nsIDOMStorage** aStorage)
    1: {
37608:     return GetSessionStorageForURI(aURI, aDocumentURI, PR_TRUE, aStorage);
23579: }
23579: 
23579: nsresult
23579: nsDocShell::GetSessionStorageForURI(nsIURI* aURI,
37608:                                     const nsSubstring& aDocumentURI,
79445:                                     bool aCreate,
28676:                                     nsIDOMStorage** aStorage)
23579: {
23579:     NS_ENSURE_ARG(aURI);
    1:     NS_ENSURE_ARG_POINTER(aStorage);
    1: 
    1:     *aStorage = nsnull;
    1: 
28676:     nsresult rv;
28676: 
28676:     nsCOMPtr<nsIScriptSecurityManager> securityManager =
28676:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
28676:     NS_ENSURE_SUCCESS(rv, rv);
28676: 
28676:     // This is terrible hack and should go away along with this whole method.
28676:     nsCOMPtr<nsIPrincipal> principal;
28676:     rv = securityManager->GetCodebasePrincipal(aURI, getter_AddRefs(principal));
28676:     if (NS_FAILED(rv))
28676:         return rv;
28676: 
37608:     return GetSessionStorageForPrincipal(principal, aDocumentURI, aCreate, aStorage);
28676: }
28676: 
28676: nsresult
28676: nsDocShell::AddSessionStorage(nsIPrincipal* aPrincipal,
28676:                               nsIDOMStorage* aStorage)
28676: {
28676:     NS_ENSURE_ARG_POINTER(aStorage);
28676: 
28676:     if (!aPrincipal)
28676:         return NS_OK;
23579: 
    1:     nsCOMPtr<nsIDocShellTreeItem> topItem;
    1:     nsresult rv = GetSameTypeRootTreeItem(getter_AddRefs(topItem));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (topItem) {
    1:         nsCOMPtr<nsIDocShell> topDocShell = do_QueryInterface(topItem);
    1:         if (topDocShell == this) {
28820:             nsCAutoString currentDomain;
28820:             rv = GetPrincipalDomain(aPrincipal, currentDomain);
28676:             if (NS_FAILED(rv))
28676:                 return rv;
28676: 
28820:             if (currentDomain.IsEmpty())
28676:                 return NS_ERROR_FAILURE;
28676: 
23579:             // Do not replace an existing session storage.
28820:             if (mStorages.GetWeak(currentDomain))
23579:                 return NS_ERROR_NOT_AVAILABLE;
23579: 
37608: #if defined(PR_LOGGING) && defined(DEBUG)
37608:             PR_LOG(gDocShellLog, PR_LOG_DEBUG,
37608:                    ("nsDocShell[%p]: was added a sessionStorage %p",
37608:                     this, aStorage));
37608: #endif
28820:             if (!mStorages.Put(currentDomain, aStorage))
    1:                 return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:         else {
28676:             return topDocShell->AddSessionStorage(aPrincipal, aStorage);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCurrentDocumentChannel(nsIChannel** aResult)
    1: {
37433:     NS_IF_ADDREF(*aResult = GetCurrentDocChannel()); 
37433:     return NS_OK;
37433: }
37433: 
37433: nsIChannel*
37433: nsDocShell::GetCurrentDocChannel()
37433: {
37433:     if (mContentViewer) {
37433:         nsIDocument* doc = mContentViewer->GetDocument();
    1:         if (doc) {
37433:             return doc->GetChannel();
37433:         }
37433:     }
37433:     return nsnull;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIDocShellTreeItem
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetName(PRUnichar ** aName)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aName);
    1:     *aName = ToNewUnicode(mName);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetName(const PRUnichar * aName)
    1: {
    1:     mName = aName;              // this does a copy of aName
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::NameEquals(const PRUnichar *aName, bool *_retval)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aName);
    1:     NS_ENSURE_ARG_POINTER(_retval);
    1:     *_retval = mName.Equals(aName);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetItemType(PRInt32 * aItemType)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aItemType);
    1: 
    1:     *aItemType = mItemType;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetItemType(PRInt32 aItemType)
    1: {
    1:     NS_ENSURE_ARG((aItemType == typeChrome) || (typeContent == aItemType));
    1: 
    1:     // Only allow setting the type on root docshells.  Those would be the ones
    1:     // that have the docloader service as mParent or have no mParent at all.
    1:     nsCOMPtr<nsIDocumentLoader> docLoaderService =
    1:         do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
    1:     NS_ENSURE_TRUE(docLoaderService, NS_ERROR_UNEXPECTED);
    1:     
    1:     NS_ENSURE_STATE(!mParent || mParent == docLoaderService);
    1: 
    1:     mItemType = aItemType;
    1: 
    1:     // disable auth prompting for anything but content
    1:     mAllowAuth = mItemType == typeContent; 
    1: 
40739:     nsRefPtr<nsPresContext> presContext = nsnull;
40739:     GetPresContext(getter_AddRefs(presContext));
40739:     if (presContext) {
40739:         presContext->InvalidateIsChromeCache();
40739:     }
40739: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetParent(nsIDocShellTreeItem ** aParent)
    1: {
    1:     if (!mParent) {
    1:         *aParent = nsnull;
    1:     } else {
    1:         CallQueryInterface(mParent, aParent);
    1:     }
    1:     // Note that in the case when the parent is not an nsIDocShellTreeItem we
    1:     // don't want to throw; we just want to return null.
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::SetDocLoaderParent(nsDocLoader * aParent)
    1: {
    1:     nsDocLoader::SetDocLoaderParent(aParent);
    1: 
    1:     // Curse ambiguous nsISupports inheritance!
    1:     nsISupports* parent = GetAsSupports(aParent);
    1: 
    1:     // If parent is another docshell, we inherit all their flags for
    1:     // allowing plugins, scripting etc.
    1:     nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(parent));
    1:     if (parentAsDocShell)
    1:     {
79445:         bool value;
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowPlugins(&value)))
    1:         {
    1:             SetAllowPlugins(value);
    1:         }
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowJavascript(&value)))
    1:         {
    1:             SetAllowJavascript(value);
    1:         }
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowMetaRedirects(&value)))
    1:         {
    1:             SetAllowMetaRedirects(value);
    1:         }
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowSubframes(&value)))
    1:         {
    1:             SetAllowSubframes(value);
    1:         }
    1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowImages(&value)))
    1:         {
    1:             SetAllowImages(value);
    1:         }
72453:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowWindowControl(&value)))
72453:         {
72453:             SetAllowWindowControl(value);
72453:         }
48937:         if (NS_SUCCEEDED(parentAsDocShell->GetIsActive(&value)))
48937:         {
48937:             SetIsActive(value);
48937:         }
28460:         if (NS_FAILED(parentAsDocShell->GetAllowDNSPrefetch(&value))) {
28460:             value = PR_FALSE;
28460:         }
28460:         SetAllowDNSPrefetch(value);
    1:     }
    1: 
    1:     nsCOMPtr<nsIURIContentListener> parentURIListener(do_GetInterface(parent));
    1:     if (parentURIListener)
    1:         mContentListener->SetParentContentListener(parentURIListener);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSameTypeParent(nsIDocShellTreeItem ** aParent)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aParent);
    1:     *aParent = nsnull;
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parent =
    1:         do_QueryInterface(GetAsSupports(mParent));
    1:     if (!parent)
    1:         return NS_OK;
    1: 
    1:     PRInt32 parentType;
    1:     NS_ENSURE_SUCCESS(parent->GetItemType(&parentType), NS_ERROR_FAILURE);
    1: 
    1:     if (parentType == mItemType) {
    1:         parent.swap(*aParent);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetRootTreeItem(nsIDocShellTreeItem ** aRootTreeItem)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aRootTreeItem);
 3233:     *aRootTreeItem = static_cast<nsIDocShellTreeItem *>(this);
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parent;
    1:     NS_ENSURE_SUCCESS(GetParent(getter_AddRefs(parent)), NS_ERROR_FAILURE);
    1:     while (parent) {
    1:         *aRootTreeItem = parent;
    1:         NS_ENSURE_SUCCESS((*aRootTreeItem)->GetParent(getter_AddRefs(parent)),
    1:                           NS_ERROR_FAILURE);
    1:     }
    1:     NS_ADDREF(*aRootTreeItem);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSameTypeRootTreeItem(nsIDocShellTreeItem ** aRootTreeItem)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aRootTreeItem);
 3233:     *aRootTreeItem = static_cast<nsIDocShellTreeItem *>(this);
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parent;
    1:     NS_ENSURE_SUCCESS(GetSameTypeParent(getter_AddRefs(parent)),
    1:                       NS_ERROR_FAILURE);
    1:     while (parent) {
    1:         *aRootTreeItem = parent;
    1:         NS_ENSURE_SUCCESS((*aRootTreeItem)->
    1:                           GetSameTypeParent(getter_AddRefs(parent)),
    1:                           NS_ERROR_FAILURE);
    1:     }
    1:     NS_ADDREF(*aRootTreeItem);
    1:     return NS_OK;
    1: }
    1: 
    1: /* static */
79445: bool
    1: nsDocShell::CanAccessItem(nsIDocShellTreeItem* aTargetItem,
    1:                           nsIDocShellTreeItem* aAccessingItem,
79445:                           bool aConsiderOpener)
    1: {
    1:     NS_PRECONDITION(aTargetItem, "Must have target item!");
    1: 
    1:     if (!gValidateOrigin || !aAccessingItem) {
    1:         // Good to go
    1:         return PR_TRUE;
    1:     }
    1: 
    1:     // XXXbz should we care if aAccessingItem or the document therein is
    1:     // chrome?  Should those get extra privileges?
    1: 
10790:     // For historical context, see:
10790:     // 
10790:     // Bug 13871:  Prevent frameset spoofing
10790:     // Bug 103638: Targets with same name in different windows open in wrong
10790:     //             window with javascript
13337:     // Bug 408052: Adopt "ancestor" frame navigation policy
10790: 
    1:     // Now do a security check
10790:     //
10790:     // Allow navigation if
10790:     //  1) aAccessingItem can script aTargetItem or one of its ancestors in
10790:     //     the frame hierarchy or
10790:     //  2) aTargetItem is a top-level frame and aAccessingItem is its descendant
10790:     //  3) aTargetItem is a top-level frame and aAccessingItem can target
10790:     //     its opener per rule (1) or (2).
10790: 
10790:     if (aTargetItem == aAccessingItem) {
10790:         // A frame is allowed to navigate itself.
10790:         return PR_TRUE;  
10790:     }
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> accessingRoot;
    1:     aAccessingItem->GetSameTypeRootTreeItem(getter_AddRefs(accessingRoot));
    1: 
10790:     if (aTargetItem == accessingRoot) {
10790:         // A frame can navigate its root.
    1:         return PR_TRUE;
    1:     }
    1: 
10790:     // Check if aAccessingItem can navigate one of aTargetItem's ancestors.
    1:     nsCOMPtr<nsIDocShellTreeItem> target = aTargetItem;
    1:     do {
    1:         if (ValidateOrigin(aAccessingItem, target)) {
    1:             return PR_TRUE;
    1:         }
    1:             
    1:         nsCOMPtr<nsIDocShellTreeItem> parent;
    1:         target->GetSameTypeParent(getter_AddRefs(parent));
    1:         parent.swap(target);
    1:     } while (target);
    1: 
10790:     nsCOMPtr<nsIDocShellTreeItem> targetRoot;
10790:     aTargetItem->GetSameTypeRootTreeItem(getter_AddRefs(targetRoot));
10790: 
    1:     if (aTargetItem != targetRoot) {
    1:         // target is a subframe, not in accessor's frame hierarchy, and all its
    1:         // ancestors have origins different from that of the accessor. Don't
    1:         // allow access.
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     if (!aConsiderOpener) {
    1:         // All done here
    1:         return PR_FALSE;
    1:     }
    1: 
73870:     nsCOMPtr<nsIDOMWindow> targetWindow = do_GetInterface(aTargetItem);
73870:     if (!targetWindow) {
    1:         NS_ERROR("This should not happen, really");
    1:         return PR_FALSE;
    1:     }
    1: 
73870:     nsCOMPtr<nsIDOMWindow> targetOpener;
73870:     targetWindow->GetOpener(getter_AddRefs(targetOpener));
    1:     nsCOMPtr<nsIWebNavigation> openerWebNav(do_GetInterface(targetOpener));
    1:     nsCOMPtr<nsIDocShellTreeItem> openerItem(do_QueryInterface(openerWebNav));
    1: 
    1:     if (!openerItem) {
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     return CanAccessItem(openerItem, aAccessingItem, PR_FALSE);    
    1: }
    1: 
79445: static bool
    1: ItemIsActive(nsIDocShellTreeItem *aItem)
    1: {
73870:     nsCOMPtr<nsIDOMWindow> window(do_GetInterface(aItem));
    1: 
    1:     if (window) {
79445:         bool isClosed;
    1: 
    1:         if (NS_SUCCEEDED(window->GetClosed(&isClosed)) && !isClosed) {
    1:             return PR_TRUE;
    1:         }
    1:     }
    1: 
    1:     return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::FindItemWithName(const PRUnichar * aName,
    1:                              nsISupports * aRequestor,
    1:                              nsIDocShellTreeItem * aOriginalRequestor,
    1:                              nsIDocShellTreeItem ** _retval)
    1: {
    1:     NS_ENSURE_ARG(aName);
    1:     NS_ENSURE_ARG_POINTER(_retval);
    1: 
    1:     // If we don't find one, we return NS_OK and a null result
    1:     *_retval = nsnull;
    1: 
    1:     if (!*aName)
    1:         return NS_OK;
    1: 
    1:     if (!aRequestor)
    1:     {
    1:         nsCOMPtr<nsIDocShellTreeItem> foundItem;
    1: 
    1:         // This is the entry point into the target-finding algorithm.  Check
    1:         // for special names.  This should only be done once, hence the check
    1:         // for a null aRequestor.
    1: 
    1:         nsDependentString name(aName);
    1:         if (name.LowerCaseEqualsLiteral("_self")) {
    1:             foundItem = this;
    1:         }
11699:         else if (name.LowerCaseEqualsLiteral("_blank"))
    1:         {
    1:             // Just return null.  Caller must handle creating a new window with
    1:             // a blank name himself.
    1:             return NS_OK;
    1:         }
    1:         else if (name.LowerCaseEqualsLiteral("_parent"))
    1:         {
    1:             GetSameTypeParent(getter_AddRefs(foundItem));
    1:             if(!foundItem)
    1:                 foundItem = this;
    1:         }
    1:         else if (name.LowerCaseEqualsLiteral("_top"))
    1:         {
    1:             GetSameTypeRootTreeItem(getter_AddRefs(foundItem));
    1:             NS_ASSERTION(foundItem, "Must have this; worst case it's us!");
    1:         }
    1:         // _main is an IE target which should be case-insensitive but isn't
    1:         // see bug 217886 for details
    1:         else if (name.LowerCaseEqualsLiteral("_content") ||
    1:                  name.EqualsLiteral("_main"))
    1:         {
    1:             // Must pass our same type root as requestor to the
    1:             // treeowner to make sure things work right.
    1:             nsCOMPtr<nsIDocShellTreeItem> root;
    1:             GetSameTypeRootTreeItem(getter_AddRefs(root));
    1:             if (mTreeOwner) {
    1:                 NS_ASSERTION(root, "Must have this; worst case it's us!");
    1:                 mTreeOwner->FindItemWithName(aName, root, aOriginalRequestor,
    1:                                              getter_AddRefs(foundItem));
    1:             }
    1: #ifdef DEBUG
    1:             else {
    1:                 NS_ERROR("Someone isn't setting up the tree owner.  "
    1:                          "You might like to try that.  "
    1:                          "Things will.....you know, work.");
    1:                 // Note: _content should always exist.  If we don't have one
    1:                 // hanging off the treeowner, just create a named window....
    1:                 // so don't return here, in case we did that and can now find
    1:                 // it.                
    1:                 // XXXbz should we be using |root| instead of creating
    1:                 // a new window?
    1:             }
    1: #endif
    1:         }
    1: 
    1:         if (foundItem && !CanAccessItem(foundItem, aOriginalRequestor)) {
    1:             foundItem = nsnull;
    1:         }
    1: 
    1:         if (foundItem) {
    1:             // We return foundItem here even if it's not an active
    1:             // item since all the names we've dealt with so far are
    1:             // special cases that we won't bother looking for further.
    1: 
    1:             foundItem.swap(*_retval);
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     // Keep looking
    1:         
    1:     // First we check our name.
    1:     if (mName.Equals(aName) && ItemIsActive(this) &&
    1:         CanAccessItem(this, aOriginalRequestor)) {
    1:         NS_ADDREF(*_retval = this);
    1:         return NS_OK;
    1:     }
    1: 
    1:     // This QI may fail, but the places where we want to compare, comparing
    1:     // against nsnull serves the same purpose.
    1:     nsCOMPtr<nsIDocShellTreeItem> reqAsTreeItem(do_QueryInterface(aRequestor));
    1: 
    1:     // Second we check our children making sure not to ask a child if
    1:     // it is the aRequestor.
    1: #ifdef DEBUG
    1:     nsresult rv =
    1: #endif
    1:     FindChildWithName(aName, PR_TRUE, PR_TRUE, reqAsTreeItem,
    1:                       aOriginalRequestor, _retval);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv),
    1:                  "FindChildWithName should not be failing here.");
    1:     if (*_retval)
    1:         return NS_OK;
    1:         
    1:     // Third if we have a parent and it isn't the requestor then we
    1:     // should ask it to do the search.  If it is the requestor we
    1:     // should just stop here and let the parent do the rest.  If we
    1:     // don't have a parent, then we should ask the
    1:     // docShellTreeOwner to do the search.
    1:     nsCOMPtr<nsIDocShellTreeItem> parentAsTreeItem =
    1:         do_QueryInterface(GetAsSupports(mParent));
    1:     if (parentAsTreeItem) {
    1:         if (parentAsTreeItem == reqAsTreeItem)
    1:             return NS_OK;
    1: 
    1:         PRInt32 parentType;
    1:         parentAsTreeItem->GetItemType(&parentType);
    1:         if (parentType == mItemType) {
    1:             return parentAsTreeItem->
    1:                 FindItemWithName(aName,
 3233:                                  static_cast<nsIDocShellTreeItem*>
 3233:                                             (this),
    1:                                  aOriginalRequestor,
    1:                                  _retval);
    1:         }
    1:     }
    1: 
    1:     // If the parent is null or not of the same type fall through and ask tree
    1:     // owner.
    1: 
    1:     // This may fail, but comparing against null serves the same purpose
    1:     nsCOMPtr<nsIDocShellTreeOwner>
    1:         reqAsTreeOwner(do_QueryInterface(aRequestor));
    1: 
    1:     if (mTreeOwner && mTreeOwner != reqAsTreeOwner) {
    1:         return mTreeOwner->
    1:             FindItemWithName(aName, this, aOriginalRequestor, _retval);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetTreeOwner(nsIDocShellTreeOwner ** aTreeOwner)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aTreeOwner);
    1: 
    1:     *aTreeOwner = mTreeOwner;
    1:     NS_IF_ADDREF(*aTreeOwner);
    1:     return NS_OK;
    1: }
    1: 
    1: #ifdef DEBUG_DOCSHELL_FOCUS
    1: static void 
 1160: PrintDocTree(nsIDocShellTreeItem * aParentNode, int aLevel)
    1: {
    1:   for (PRInt32 i=0;i<aLevel;i++) printf("  ");
    1: 
    1:   PRInt32 childWebshellCount;
    1:   aParentNode->GetChildCount(&childWebshellCount);
    1:   nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(aParentNode));
    1:   PRInt32 type;
 1160:   aParentNode->GetItemType(&type);
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   parentAsDocShell->GetPresShell(getter_AddRefs(presShell));
39823:   nsRefPtr<nsPresContext> presContext;
    1:   parentAsDocShell->GetPresContext(getter_AddRefs(presContext));
    1:   nsIDocument *doc = presShell->GetDocument();
    1: 
73870:   nsCOMPtr<nsIDOMWindow> domwin(doc->GetWindow());
    1: 
    1:   nsCOMPtr<nsIWidget> widget;
    1:   nsIViewManager* vm = presShell->GetViewManager();
    1:   if (vm) {
    1:     vm->GetWidget(getter_AddRefs(widget));
    1:   }
41930:   dom::Element* rootElement = doc->GetRootElement();
    1: 
    1:   printf("DS %p  Ty %s  Doc %p DW %p EM %p CN %p\n",  
   58:     (void*)parentAsDocShell.get(), 
    1:     type==nsIDocShellTreeItem::typeChrome?"Chr":"Con", 
   58:      (void*)doc, (void*)domwin.get(),
41634:      (void*)presContext->EventStateManager(), (void*)rootElement);
    1: 
    1:   if (childWebshellCount > 0) {
    1:     for (PRInt32 i=0;i<childWebshellCount;i++) {
    1:       nsCOMPtr<nsIDocShellTreeItem> child;
    1:       aParentNode->GetChildAt(i, getter_AddRefs(child));
 1160:       PrintDocTree(child, aLevel+1);
    1:     }
    1:   }
    1: }
    1: 
    1: static void 
 1160: PrintDocTree(nsIDocShellTreeItem * aParentNode)
    1: {
    1:   NS_ASSERTION(aParentNode, "Pointer is null!");
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> parentItem;
 1160:   aParentNode->GetParent(getter_AddRefs(parentItem));
    1:   while (parentItem) {
    1:     nsCOMPtr<nsIDocShellTreeItem>tmp;
    1:     parentItem->GetParent(getter_AddRefs(tmp));
    1:     if (!tmp) {
    1:       break;
    1:     }
    1:     parentItem = tmp;
    1:   }
    1: 
    1:   if (!parentItem) {
 1160:     parentItem = aParentNode;
 1160:   }
 1160: 
 1160:   PrintDocTree(parentItem, 0);
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetTreeOwner(nsIDocShellTreeOwner * aTreeOwner)
    1: {
    1: #ifdef DEBUG_DOCSHELL_FOCUS
 1160:     nsCOMPtr<nsIDocShellTreeItem> item(do_QueryInterface(aTreeOwner));
 1160:     if (item) {
 1160:       PrintDocTree(item);
    1:     }
    1: #endif
    1: 
    1:     // Don't automatically set the progress based on the tree owner for frames
    1:     if (!IsFrame()) {
    1:         nsCOMPtr<nsIWebProgress> webProgress =
    1:             do_QueryInterface(GetAsSupports(this));
    1: 
    1:         if (webProgress) {
    1:             nsCOMPtr<nsIWebProgressListener>
    1:                 oldListener(do_QueryInterface(mTreeOwner));
    1:             nsCOMPtr<nsIWebProgressListener>
    1:                 newListener(do_QueryInterface(aTreeOwner));
    1: 
    1:             if (oldListener) {
    1:                 webProgress->RemoveProgressListener(oldListener);
    1:             }
    1: 
    1:             if (newListener) {
    1:                 webProgress->AddProgressListener(newListener,
    1:                                                  nsIWebProgress::NOTIFY_ALL);
    1:             }
    1:         }
    1:     }
    1: 
    1:     mTreeOwner = aTreeOwner;    // Weak reference per API
    1: 
29263:     PRInt32 i, n = mChildList.Count();
    1:     for (i = 0; i < n; i++) {
29263:         nsCOMPtr<nsIDocShellTreeItem> child = do_QueryInterface(ChildAt(i));
    1:         NS_ENSURE_TRUE(child, NS_ERROR_FAILURE);
    1:         PRInt32 childType = ~mItemType; // Set it to not us in case the get fails
    1:         child->GetItemType(&childType); // We don't care if this fails, if it does we won't set the owner
    1:         if (childType == mItemType)
    1:             child->SetTreeOwner(aTreeOwner);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 1585: nsDocShell::SetChildOffset(PRUint32 aChildOffset)
    1: {
    1:     mChildOffset = aChildOffset;
    1:     return NS_OK;
    1: }
    1: 
 2400: NS_IMETHODIMP
50721: nsDocShell::GetHistoryID(PRUint64* aID)
50721: {
50721:   *aID = mHistoryID;
50721:   return NS_OK;
50721: }
50721: 
50721: NS_IMETHODIMP
79445: nsDocShell::GetIsInUnload(bool* aIsInUnload)
 2400: {
 2400:     *aIsInUnload = mFiredUnloadEvent;
 2400:     return NS_OK;
 2400: }
 2400: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIDocShellTreeNode
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetChildCount(PRInt32 * aChildCount)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChildCount);
29263:     *aChildCount = mChildList.Count();
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::AddChild(nsIDocShellTreeItem * aChild)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChild);
    1: 
    1:     nsRefPtr<nsDocLoader> childAsDocLoader = GetAsDocLoader(aChild);
    1:     NS_ENSURE_TRUE(childAsDocLoader, NS_ERROR_UNEXPECTED);
    1: 
    1:     // Make sure we're not creating a loop in the docshell tree
    1:     nsDocLoader* ancestor = this;
    1:     do {
    1:         if (childAsDocLoader == ancestor) {
    1:             return NS_ERROR_ILLEGAL_VALUE;
    1:         }
    1:         ancestor = ancestor->GetParent();
    1:     } while (ancestor);
    1:     
    1:     // Make sure to remove the child from its current parent.
    1:     nsDocLoader* childsParent = childAsDocLoader->GetParent();
    1:     if (childsParent) {
    1:         childsParent->RemoveChildLoader(childAsDocLoader);
    1:     }
    1: 
    1:     // Make sure to clear the treeowner in case this child is a different type
    1:     // from us.
    1:     aChild->SetTreeOwner(nsnull);
    1:     
    1:     nsresult res = AddChildLoader(childAsDocLoader);
    1:     NS_ENSURE_SUCCESS(res, res);
29263:     NS_ASSERTION(mChildList.Count() > 0,
 1585:                  "child list must not be empty after a successful add");
    1: 
50721:     nsCOMPtr<nsIDocShellHistory> docshellhistory = do_QueryInterface(aChild);
79445:     bool dynamic = false;
50721:     docshellhistory->GetCreatedDynamically(&dynamic);
50721:     if (!dynamic) {
50721:         nsCOMPtr<nsISHEntry> currentSH;
79445:         bool oshe = false;
50721:         GetCurrentSHEntry(getter_AddRefs(currentSH), &oshe);
50721:         if (currentSH) {
50721:             currentSH->HasDynamicallyAddedChild(&dynamic);
50721:         }
50721:     }
 1585:     nsCOMPtr<nsIDocShell> childDocShell = do_QueryInterface(aChild);
50721:     childDocShell->SetChildOffset(dynamic ? -1 : mChildList.Count() - 1);
    1: 
    1:     /* Set the child's global history if the parent has one */
61540:     if (mUseGlobalHistory) {
    1:         nsCOMPtr<nsIDocShellHistory>
    1:             dsHistoryChild(do_QueryInterface(aChild));
    1:         if (dsHistoryChild)
    1:             dsHistoryChild->SetUseGlobalHistory(PR_TRUE);
    1:     }
    1: 
    1: 
    1:     PRInt32 childType = ~mItemType;     // Set it to not us in case the get fails
    1:     aChild->GetItemType(&childType);
    1:     if (childType != mItemType)
    1:         return NS_OK;
    1:     // Everything below here is only done when the child is the same type.
    1: 
    1: 
    1:     aChild->SetTreeOwner(mTreeOwner);
    1: 
    1:     nsCOMPtr<nsIDocShell> childAsDocShell(do_QueryInterface(aChild));
    1:     if (!childAsDocShell)
    1:         return NS_OK;
    1: 
    1:     // charset, style-disabling, and zoom will be inherited in SetupNewViewer()
    1: 
    1:     // Now take this document's charset and set the parentCharset field of the 
    1:     // child's DocumentCharsetInfo to it. We'll later use that field, in the 
    1:     // loading process, for the charset choosing algorithm.
    1:     // If we fail, at any point, we just return NS_OK.
    1:     // This code has some performance impact. But this will be reduced when 
    1:     // the current charset will finally be stored as an Atom, avoiding the
    1:     // alias resolution extra look-up.
    1: 
    1:     // we are NOT going to propagate the charset is this Chrome's docshell
    1:     if (mItemType == nsIDocShellTreeItem::typeChrome)
    1:         return NS_OK;
    1: 
    1:     // get the child's docCSInfo object
    1:     nsCOMPtr<nsIDocumentCharsetInfo> dcInfo = NULL;
    1:     res = childAsDocShell->GetDocumentCharsetInfo(getter_AddRefs(dcInfo));
    1:     if (NS_FAILED(res) || (!dcInfo))
    1:         return NS_OK;
    1: 
    1:     // get the parent's current charset
37433:     if (!mContentViewer)
37433:         return NS_OK;
37433:     nsIDocument* doc = mContentViewer->GetDocument();
37433:     if (!doc)
    1:         return NS_OK;
    1:     const nsACString &parentCS = doc->GetDocumentCharacterSet();
    1: 
79445:     bool isWyciwyg = false;
    1: 
    1:     if (mCurrentURI) {
    1:         // Check if the url is wyciwyg
    1:         mCurrentURI->SchemeIs("wyciwyg", &isWyciwyg);      
    1:     }
    1: 
    1:     if (!isWyciwyg) {
    1:         // If this docshell is loaded from a wyciwyg: URI, don't
    1:         // advertise our charset since it does not in any way reflect
    1:         // the actual source charset, which is what we're trying to
    1:         // expose here.
    1: 
    1:         // set the child's parentCharset
    1:         nsCOMPtr<nsIAtom> parentCSAtom(do_GetAtom(parentCS));
    1:         res = dcInfo->SetParentCharset(parentCSAtom);
    1:         if (NS_FAILED(res))
    1:             return NS_OK;
    1: 
    1:         PRInt32 charsetSource = doc->GetDocumentCharacterSetSource();
    1: 
    1:         // set the child's parentCharset
    1:         res = dcInfo->SetParentCharsetSource(charsetSource);
    1:         if (NS_FAILED(res))
    1:             return NS_OK;
    1:     }
    1: 
    1:     // printf("### 1 >>> Adding child. Parent CS = %s. ItemType = %d.\n", NS_LossyConvertUTF16toASCII(parentCS).get(), mItemType);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::RemoveChild(nsIDocShellTreeItem * aChild)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChild);
    1: 
    1:     nsRefPtr<nsDocLoader> childAsDocLoader = GetAsDocLoader(aChild);
    1:     NS_ENSURE_TRUE(childAsDocLoader, NS_ERROR_UNEXPECTED);
    1:     
    1:     nsresult rv = RemoveChildLoader(childAsDocLoader);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     aChild->SetTreeOwner(nsnull);
    1: 
    1:     return nsDocLoader::AddDocLoaderAsChildOfRoot(childAsDocLoader);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetChildAt(PRInt32 aIndex, nsIDocShellTreeItem ** aChild)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChild);
    1: 
    1: #ifdef DEBUG
    1:     if (aIndex < 0) {
    1:       NS_WARNING("Negative index passed to GetChildAt");
    1:     }
29263:     else if (aIndex >= mChildList.Count()) {
    1:       NS_WARNING("Too large an index passed to GetChildAt");
    1:     }
    1: #endif
    1: 
29263:     nsIDocumentLoader* child = SafeChildAt(aIndex);
    1:     NS_ENSURE_TRUE(child, NS_ERROR_UNEXPECTED);
    1:     
    1:     return CallQueryInterface(child, aChild);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::FindChildWithName(const PRUnichar * aName,
79445:                               bool aRecurse, bool aSameType,
    1:                               nsIDocShellTreeItem * aRequestor,
    1:                               nsIDocShellTreeItem * aOriginalRequestor,
    1:                               nsIDocShellTreeItem ** _retval)
    1: {
    1:     NS_ENSURE_ARG(aName);
    1:     NS_ENSURE_ARG_POINTER(_retval);
    1: 
    1:     *_retval = nsnull;          // if we don't find one, we return NS_OK and a null result 
    1: 
    1:     if (!*aName)
    1:         return NS_OK;
    1: 
    1:     nsXPIDLString childName;
29263:     PRInt32 i, n = mChildList.Count();
    1:     for (i = 0; i < n; i++) {
29263:         nsCOMPtr<nsIDocShellTreeItem> child = do_QueryInterface(ChildAt(i));
    1:         NS_ENSURE_TRUE(child, NS_ERROR_FAILURE);
    1:         PRInt32 childType;
    1:         child->GetItemType(&childType);
    1: 
    1:         if (aSameType && (childType != mItemType))
    1:             continue;
    1: 
79445:         bool childNameEquals = false;
    1:         child->NameEquals(aName, &childNameEquals);
    1:         if (childNameEquals && ItemIsActive(child) &&
    1:             CanAccessItem(child, aOriginalRequestor)) {
    1:             child.swap(*_retval);
    1:             break;
    1:         }
    1: 
    1:         if (childType != mItemType)     //Only ask it to check children if it is same type
    1:             continue;
    1: 
    1:         if (aRecurse && (aRequestor != child))  // Only ask the child if it isn't the requestor
    1:         {
    1:             // See if child contains the shell with the given name
    1: #ifdef DEBUG
    1:             nsresult rv =
    1: #endif
 1160:             child->FindChildWithName(aName, PR_TRUE,
    1:                                      aSameType,
 3233:                                      static_cast<nsIDocShellTreeItem*>
 3233:                                                 (this),
    1:                                      aOriginalRequestor,
    1:                                      _retval);
    1:             NS_ASSERTION(NS_SUCCEEDED(rv),
    1:                          "FindChildWithName should not fail here");
    1:             if (*_retval)           // found it
    1:                 return NS_OK;
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIDocShellHistory
    1: //*****************************************************************************   
    1: NS_IMETHODIMP
    1: nsDocShell::GetChildSHEntry(PRInt32 aChildOffset, nsISHEntry ** aResult)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1:     NS_ENSURE_ARG_POINTER(aResult);
    1:     *aResult = nsnull;
    1: 
    1:     
    1:     // A nsISHEntry for a child is *only* available when the parent is in
    1:     // the progress of loading a document too...
    1:     
    1:     if (mLSHE) {
    1:         /* Before looking for the subframe's url, check
    1:          * the expiration status of the parent. If the parent
    1:          * has expired from cache, then subframes will not be 
    1:          * loaded from history in certain situations.  
    1:          */
79445:         bool parentExpired=false;
    1:         mLSHE->GetExpirationStatus(&parentExpired);
    1:         
    1:         /* Get the parent's Load Type so that it can be set on the child too.
    1:          * By default give a loadHistory value
    1:          */
    1:         PRUint32 loadType = nsIDocShellLoadInfo::loadHistory;
    1:         mLSHE->GetLoadType(&loadType);  
    1:         // If the user did a shift-reload on this frameset page, 
    1:         // we don't want to load the subframes from history.
    1:         if (loadType == nsIDocShellLoadInfo::loadReloadBypassCache ||
    1:             loadType == nsIDocShellLoadInfo::loadReloadBypassProxy ||
    1:             loadType == nsIDocShellLoadInfo::loadReloadBypassProxyAndCache ||
    1:             loadType == nsIDocShellLoadInfo::loadRefresh)
    1:             return rv;
    1:         
    1:         /* If the user pressed reload and the parent frame has expired
    1:          *  from cache, we do not want to load the child frame from history.
    1:          */
    1:         if (parentExpired && (loadType == nsIDocShellLoadInfo::loadReloadNormal)) {
    1:             // The parent has expired. Return null.
    1:             *aResult = nsnull;
    1:             return rv;
    1:         }
    1: 
    1:         nsCOMPtr<nsISHContainer> container(do_QueryInterface(mLSHE));
    1:         if (container) {
    1:             // Get the child subframe from session history.
    1:             rv = container->GetChildAt(aChildOffset, aResult);            
    1:             if (*aResult) 
    1:                 (*aResult)->SetLoadType(loadType);            
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::AddChildSHEntry(nsISHEntry * aCloneRef, nsISHEntry * aNewEntry,
64491:                             PRInt32 aChildOffset, PRUint32 loadType,
79445:                             bool aCloneChildren)
    1: {
    1:     nsresult rv;
    1: 
37802:     if (mLSHE && loadType != LOAD_PUSHSTATE) {
    1:         /* You get here if you are currently building a 
    1:          * hierarchy ie.,you just visited a frameset page
    1:          */
    1:         nsCOMPtr<nsISHContainer> container(do_QueryInterface(mLSHE, &rv));
    1:         if (container) {
    1:             rv = container->AddChild(aNewEntry, aChildOffset);
    1:         }
    1:     }
    1:     else if (!aCloneRef) {
    1:         /* This is an initial load in some subframe.  Just append it if we can */
    1:         nsCOMPtr<nsISHContainer> container(do_QueryInterface(mOSHE, &rv));
    1:         if (container) {
    1:             rv = container->AddChild(aNewEntry, aChildOffset);
    1:         }
    1:     }
    1:     else if (mSessionHistory) {
    1:         /* You are currently in the rootDocShell.
    1:          * You will get here when a subframe has a new url
    1:          * to load and you have walked up the tree all the 
    1:          * way to the top to clone the current SHEntry hierarchy
    1:          * and replace the subframe where a new url was loaded with
    1:          * a new entry.
    1:          */
    1:         PRInt32 index = -1;
    1:         nsCOMPtr<nsIHistoryEntry> currentHE;
    1:         mSessionHistory->GetIndex(&index);
    1:         if (index < 0)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         rv = mSessionHistory->GetEntryAtIndex(index, PR_FALSE,
    1:                                               getter_AddRefs(currentHE));
    1:         NS_ENSURE_TRUE(currentHE, NS_ERROR_FAILURE);
    1: 
    1:         nsCOMPtr<nsISHEntry> currentEntry(do_QueryInterface(currentHE));
    1:         if (currentEntry) {
    1:             PRUint32 cloneID = 0;
    1:             nsCOMPtr<nsISHEntry> nextEntry;
    1:             aCloneRef->GetID(&cloneID);
    1:             rv = CloneAndReplace(currentEntry, this, cloneID, aNewEntry,
64491:                                  aCloneChildren, getter_AddRefs(nextEntry));
    1: 
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 nsCOMPtr<nsISHistoryInternal>
    1:                     shPrivate(do_QueryInterface(mSessionHistory));
    1:                 NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
    1:                 rv = shPrivate->AddEntry(nextEntry, PR_TRUE);
    1:             }
    1:         }
    1:     }
    1:     else {
    1:         /* Just pass this along */
    1:         nsCOMPtr<nsIDocShellHistory> parent =
    1:             do_QueryInterface(GetAsSupports(mParent), &rv);
    1:         if (parent) {
37802:             rv = parent->AddChildSHEntry(aCloneRef, aNewEntry, aChildOffset,
64491:                                          loadType, aCloneChildren);
    1:         }          
    1:     }
    1:     return rv;
    1: }
    1: 
    1: nsresult
64491: nsDocShell::DoAddChildSHEntry(nsISHEntry* aNewEntry, PRInt32 aChildOffset,
79445:                               bool aCloneChildren)
    1: {
    1:     /* You will get here when you are in a subframe and
    1:      * a new url has been loaded on you. 
    1:      * The mOSHE in this subframe will be the previous url's
    1:      * mOSHE. This mOSHE will be used as the identification
    1:      * for this subframe in the  CloneAndReplace function.
    1:      */
    1: 
19870:     // In this case, we will end up calling AddEntry, which increases the
19870:     // current index by 1
19870:     nsCOMPtr<nsISHistory> rootSH;
19870:     GetRootSessionHistory(getter_AddRefs(rootSH));
19870:     if (rootSH) {
19870:         rootSH->GetIndex(&mPreviousTransIndex);
19870:     }
19870: 
    1:     nsresult rv;
    1:     nsCOMPtr<nsIDocShellHistory> parent =
    1:         do_QueryInterface(GetAsSupports(mParent), &rv);
    1:     if (parent) {
64491:         rv = parent->AddChildSHEntry(mOSHE, aNewEntry, aChildOffset, mLoadType,
64491:                                      aCloneChildren);
    1:     }
    1: 
19870: 
19870:     if (rootSH) {
19870:         rootSH->GetIndex(&mLoadedTransIndex);
19870: #ifdef DEBUG_PAGE_CACHE
19870:         printf("Previous index: %d, Loaded index: %d\n\n", mPreviousTransIndex,
19870:                mLoadedTransIndex);
19870: #endif
19870:     }
19870: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::SetUseGlobalHistory(bool aUseGlobalHistory)
    1: {
    1:     nsresult rv;
    1: 
61540:     mUseGlobalHistory = aUseGlobalHistory;
61540: 
    1:     if (!aUseGlobalHistory) {
    1:         mGlobalHistory = nsnull;
    1:         return NS_OK;
    1:     }
    1: 
62239:     // No need to initialize mGlobalHistory if IHistory is available.
62239:     nsCOMPtr<IHistory> history = services::GetHistoryService();
62239:     if (history) {
62239:         return NS_OK;
62239:     }
62239: 
    1:     if (mGlobalHistory) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     mGlobalHistory = do_GetService(NS_GLOBALHISTORY2_CONTRACTID, &rv);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetUseGlobalHistory(bool *aUseGlobalHistory)
    1: {
61540:     *aUseGlobalHistory = mUseGlobalHistory;
    1:     return NS_OK;
    1: }
    1: 
50721: NS_IMETHODIMP
50721: nsDocShell::RemoveFromSessionHistory()
50721: {
50721:     nsCOMPtr<nsISHistoryInternal> internalHistory;
50721:     nsCOMPtr<nsISHistory> sessionHistory;
50721:     nsCOMPtr<nsIDocShellTreeItem> root;
50721:     GetSameTypeRootTreeItem(getter_AddRefs(root));
50721:     if (root) {
50721:         nsCOMPtr<nsIWebNavigation> rootAsWebnav =
50721:             do_QueryInterface(root);
50721:         if (rootAsWebnav) {
50721:             rootAsWebnav->GetSessionHistory(getter_AddRefs(sessionHistory));
50721:             internalHistory = do_QueryInterface(sessionHistory);
50721:         }
50721:     }
50721:     if (!internalHistory) {
50721:         return NS_OK;
50721:     }
50721: 
50721:     PRInt32 index = 0;
50721:     sessionHistory->GetIndex(&index);
50721:     nsAutoTArray<PRUint64, 16> ids;
50721:     ids.AppendElement(mHistoryID);
50721:     internalHistory->RemoveEntries(ids, index);
50721:     return NS_OK;
50721: }
50721: 
50721: NS_IMETHODIMP
79445: nsDocShell::SetCreatedDynamically(bool aDynamic)
50721: {
50721:     mDynamicallyCreated = aDynamic;
50721:     return NS_OK;
50721: }
50721: 
50721: NS_IMETHODIMP
79445: nsDocShell::GetCreatedDynamically(bool* aDynamic)
50721: {
50721:     *aDynamic = mDynamicallyCreated;
50721:     return NS_OK;
50721: }
50721: 
50721: NS_IMETHODIMP
79445: nsDocShell::GetCurrentSHEntry(nsISHEntry** aEntry, bool* aOSHE)
50721: {
50721:     *aOSHE = PR_FALSE;
50721:     *aEntry = nsnull;
50721:     if (mLSHE) {
50721:         NS_ADDREF(*aEntry = mLSHE);
50721:     } else if (mOSHE) {
50721:         NS_ADDREF(*aEntry = mOSHE);
50721:         *aOSHE = PR_TRUE;
50721:     }
50721:     return NS_OK;
50721: }
50721: 
50721: void
50721: nsDocShell::ClearFrameHistory(nsISHEntry* aEntry)
50721: {
50721:   nsCOMPtr<nsISHContainer> shcontainer = do_QueryInterface(aEntry);
50721:   nsCOMPtr<nsISHistory> rootSH;
50721:   GetRootSessionHistory(getter_AddRefs(rootSH));
50721:   nsCOMPtr<nsISHistoryInternal> history = do_QueryInterface(rootSH);
50721:   if (!history || !shcontainer) {
50721:     return;
50721:   }
50721: 
50721:   PRInt32 count = 0;
50721:   shcontainer->GetChildCount(&count);
50721:   nsAutoTArray<PRUint64, 16> ids;
50721:   for (PRInt32 i = 0; i < count; ++i) {
50721:     nsCOMPtr<nsISHEntry> child;
50721:     shcontainer->GetChildAt(i, getter_AddRefs(child));
50721:     if (child) {
50721:       PRUint64 id = 0;
50721:       child->GetDocshellID(&id);
50721:       ids.AppendElement(id);
50721:     }
50721:   }
50721:   PRInt32 index = 0;
50721:   rootSH->GetIndex(&index);
50721:   history->RemoveEntries(ids, index);
50721: }
50721: 
    1: //-------------------------------------
    1: //-- Helper Method for Print discovery
    1: //-------------------------------------
79445: bool 
79445: nsDocShell::IsPrintingOrPP(bool aDisplayErrorDialog)
    1: {
    1:   if (mIsPrintingOrPP && aDisplayErrorDialog) {
    1:     DisplayLoadError(NS_ERROR_DOCUMENT_IS_PRINTMODE, nsnull, nsnull);
    1:   }
    1: 
    1:   return mIsPrintingOrPP;
    1: }
    1: 
79445: bool
79445: nsDocShell::IsNavigationAllowed(bool aDisplayPrintErrorDialog)
 2400: {
 2400:     return !IsPrintingOrPP(aDisplayPrintErrorDialog) && !mFiredUnloadEvent;
 2400: }
 2400: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIWebNavigation
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetCanGoBack(bool * aCanGoBack)
    1: {
 2400:     if (!IsNavigationAllowed(PR_FALSE)) {
    1:       *aCanGoBack = PR_FALSE;
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GetCanGoBack(aCanGoBack);   
    1:     return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetCanGoForward(bool * aCanGoForward)
    1: {
 2400:     if (!IsNavigationAllowed(PR_FALSE)) {
    1:       *aCanGoForward = PR_FALSE;
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH)); 
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GetCanGoForward(aCanGoForward);
    1:     return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GoBack()
    1: {
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GoBack();
    1:     return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GoForward()
    1: {
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GoForward();
    1:     return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::GotoIndex(PRInt32 aIndex)
    1: {
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
    1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
    1:     rv = webnav->GotoIndex(aIndex);
    1:     return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::LoadURI(const PRUnichar * aURI,
    1:                     PRUint32 aLoadFlags,
    1:                     nsIURI * aReferringURI,
    1:                     nsIInputStream * aPostStream,
    1:                     nsIInputStream * aHeaderStream)
    1: {
21935:     NS_ASSERTION((aLoadFlags & 0xf) == 0, "Unexpected flags");
21935:     
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsCOMPtr<nsIURI> uri;
    1:     nsresult rv = NS_OK;
    1: 
    1:     // Create a URI from our string; if that succeeds, we want to
    1:     // change aLoadFlags to not include the ALLOW_THIRD_PARTY_FIXUP
    1:     // flag.
    1: 
    1:     NS_ConvertUTF16toUTF8 uriString(aURI);
    1:     // Cleanup the empty spaces that might be on each end.
    1:     uriString.Trim(" ");
    1:     // Eliminate embedded newlines, which single-line text fields now allow:
    1:     uriString.StripChars("\r\n");
    1:     NS_ENSURE_TRUE(!uriString.IsEmpty(), NS_ERROR_FAILURE);
    1: 
    1:     rv = NS_NewURI(getter_AddRefs(uri), uriString);
    1:     if (uri) {
    1:         aLoadFlags &= ~LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
    1:     }
    1:     
    1:     if (sURIFixup) {
    1:         // Call the fixup object.  This will clobber the rv from NS_NewURI
    1:         // above, but that's fine with us.  Note that we need to do this even
    1:         // if NS_NewURI returned a URI, because fixup handles nested URIs, etc
    1:         // (things like view-source:mozilla.org for example).
    1:         PRUint32 fixupFlags = 0;
    1:         if (aLoadFlags & LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP) {
    1:           fixupFlags |= nsIURIFixup::FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP;
    1:         }
    1:         rv = sURIFixup->CreateFixupURI(uriString, fixupFlags,
    1:                                        getter_AddRefs(uri));
    1:     }
    1:     // else no fixup service so just use the URI we created and see
    1:     // what happens
    1: 
    1:     if (NS_ERROR_MALFORMED_URI == rv) {
    1:         DisplayLoadError(rv, uri, aURI);
    1:     }
    1: 
    1:     if (NS_FAILED(rv) || !uri)
    1:         return NS_ERROR_FAILURE;
    1: 
 5873:     PopupControlState popupState;
 5873:     if (aLoadFlags & LOAD_FLAGS_ALLOW_POPUPS) {
 5873:         popupState = openAllowed;
 5873:         aLoadFlags &= ~LOAD_FLAGS_ALLOW_POPUPS;
 5873:     } else {
 5873:         popupState = openOverridden;
 5873:     }
 5873:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
 5873:     nsAutoPopupStatePusher statePusher(win, popupState);
 5873: 
 2235:     // Don't pass certain flags that aren't needed and end up confusing
 2235:     // ConvertLoadTypeToDocShellLoadInfo.  We do need to ensure that they are
 2235:     // passed to LoadURI though, since it uses them.
 2235:     PRUint32 extraFlags = (aLoadFlags & EXTRA_LOAD_FLAGS);
 2235:     aLoadFlags &= ~EXTRA_LOAD_FLAGS;
    1: 
    1:     nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
    1:     rv = CreateLoadInfo(getter_AddRefs(loadInfo));
    1:     if (NS_FAILED(rv)) return rv;
    1:     
    1:     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_NORMAL, aLoadFlags);
    1:     loadInfo->SetLoadType(ConvertLoadTypeToDocShellLoadInfo(loadType));
    1:     loadInfo->SetPostDataStream(aPostStream);
    1:     loadInfo->SetReferrer(aReferringURI);
    1:     loadInfo->SetHeadersStream(aHeaderStream);
    1: 
 2235:     rv = LoadURI(uri, loadInfo, extraFlags, PR_TRUE);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::DisplayLoadError(nsresult aError, nsIURI *aURI,
    1:                              const PRUnichar *aURL,
    1:                              nsIChannel* aFailedChannel)
    1: {
    1:     // Get prompt and string bundle servcies
    1:     nsCOMPtr<nsIPrompt> prompter;
    1:     nsCOMPtr<nsIStringBundle> stringBundle;
    1:     GetPromptAndStringBundle(getter_AddRefs(prompter),
    1:                              getter_AddRefs(stringBundle));
    1: 
    1:     NS_ENSURE_TRUE(stringBundle, NS_ERROR_FAILURE);
    1:     NS_ENSURE_TRUE(prompter, NS_ERROR_FAILURE);
    1: 
    1:     nsAutoString error;
13314:     const PRUint32 kMaxFormatStrArgs = 3;
    1:     nsAutoString formatStrs[kMaxFormatStrArgs];
    1:     PRUint32 formatStrCount = 0;
79445:     bool addHostPort = false;
    1:     nsresult rv = NS_OK;
    1:     nsAutoString messageStr;
 5528:     nsCAutoString cssClass;
 7236:     nsCAutoString errorPage;
 7236: 
 7236:     errorPage.AssignLiteral("neterror");
    1: 
    1:     // Turn the error code into a human readable error message.
    1:     if (NS_ERROR_UNKNOWN_PROTOCOL == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
    1:         // extract the scheme
    1:         nsCAutoString scheme;
    1:         aURI->GetScheme(scheme);
    1:         CopyASCIItoUTF16(scheme, formatStrs[0]);
    1:         formatStrCount = 1;
    1:         error.AssignLiteral("protocolNotFound");
    1:     }
    1:     else if (NS_ERROR_FILE_NOT_FOUND == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
    1:         error.AssignLiteral("fileNotFound");
    1:     }
    1:     else if (NS_ERROR_UNKNOWN_HOST == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
    1:         // Get the host
    1:         nsCAutoString host;
 8889:         nsCOMPtr<nsIURI> innermostURI = NS_GetInnermostURI(aURI);
 8889:         innermostURI->GetHost(host);
    1:         CopyUTF8toUTF16(host, formatStrs[0]);
    1:         formatStrCount = 1;
    1:         error.AssignLiteral("dnsNotFound");
    1:     }
    1:     else if(NS_ERROR_CONNECTION_REFUSED == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
13314:         addHostPort = PR_TRUE;
    1:         error.AssignLiteral("connectionFailure");
    1:     }
    1:     else if(NS_ERROR_NET_INTERRUPT == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
13314:         addHostPort = PR_TRUE;
    1:         error.AssignLiteral("netInterrupt");
    1:     }
    1:     else if (NS_ERROR_NET_TIMEOUT == aError) {
    1:         NS_ENSURE_ARG_POINTER(aURI);
    1:         // Get the host
    1:         nsCAutoString host;
    1:         aURI->GetHost(host);
    1:         CopyUTF8toUTF16(host, formatStrs[0]);
    1:         formatStrCount = 1;
    1:         error.AssignLiteral("netTimeout");
    1:     }
37926:     else if (NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION == aError) {
37926:         // CSP error
37926:         cssClass.AssignLiteral("neterror");
37926:         error.AssignLiteral("cspFrameAncestorBlocked");
37926:     }
    1:     else if (NS_ERROR_GET_MODULE(aError) == NS_ERROR_MODULE_SECURITY) {
 7252:         nsCOMPtr<nsINSSErrorsService> nsserr =
 7252:             do_GetService(NS_NSS_ERRORS_SERVICE_CONTRACTID);
 7252: 
 7252:         PRUint32 errorClass;
 7252:         if (!nsserr ||
 7252:             NS_FAILED(nsserr->GetErrorClass(aError, &errorClass))) {
 7252:           errorClass = nsINSSErrorsService::ERROR_CLASS_SSL_PROTOCOL;
 7252:         }
 7252: 
    1:         nsCOMPtr<nsISupports> securityInfo;
    1:         nsCOMPtr<nsITransportSecurityInfo> tsi;
    1:         if (aFailedChannel)
    1:             aFailedChannel->GetSecurityInfo(getter_AddRefs(securityInfo));
    1:         tsi = do_QueryInterface(securityInfo);
    1:         if (tsi) {
    1:             // Usually we should have aFailedChannel and get a detailed message
    1:             tsi->GetErrorMessage(getter_Copies(messageStr));
    1:         }
    1:         else {
    1:             // No channel, let's obtain the generic error message
    1:             if (nsserr) {
    1:                 nsserr->GetErrorMessage(aError, messageStr);
    1:             }
    1:         }
 7252:         if (!messageStr.IsEmpty()) {
 7252:             if (errorClass == nsINSSErrorsService::ERROR_CLASS_BAD_CERT) {
 7252:                 error.AssignLiteral("nssBadCert");
51363: 
51363:                 // if this is a Strict-Transport-Security host and the cert
51363:                 // is bad, don't allow overrides (STS Spec section 7.3).
51363:                 nsCOMPtr<nsIStrictTransportSecurityService> stss =
51363:                           do_GetService(NS_STSSERVICE_CONTRACTID, &rv);
51363:                 NS_ENSURE_SUCCESS(rv, rv);
51363: 
79445:                 bool isStsHost = false;
51363:                 rv = stss->IsStsURI(aURI, &isStsHost);
51363:                 NS_ENSURE_SUCCESS(rv, rv);
51363: 
51363:                 if (isStsHost)
51363:                   cssClass.AssignLiteral("badStsCert");
51363: 
72449:                 if (Preferences::GetBool(
79445:                         "browser.xul.error_pages.expert_bad_cert", false)) {
14875:                     cssClass.AssignLiteral("expertBadCert");
14875:                 }
21051: 
21051:                 // See if an alternate cert error page is registered
72449:                 nsAdoptingCString alternateErrorPage =
72449:                     Preferences::GetCString(
72449:                         "security.alternate_certificate_error_page");
21051:                 if (alternateErrorPage)
21051:                     errorPage.Assign(alternateErrorPage);
 7252:             } else {
 2609:                 error.AssignLiteral("nssFailure2");
 7252:             }
 7252:         }
 7236:     } else if (NS_ERROR_PHISHING_URI == aError || NS_ERROR_MALWARE_URI == aError) {
 7236:         nsCAutoString host;
 7236:         aURI->GetHost(host);
 7236:         CopyUTF8toUTF16(host, formatStrs[0]);
 7236:         formatStrCount = 1;
 7236: 
 7236:         // Malware and phishing detectors may want to use an alternate error
 7236:         // page, but if the pref's not set, we'll fall back on the standard page
72449:         nsAdoptingCString alternateErrorPage =
72449:             Preferences::GetCString("urlclassifier.alternate_error_page");
 7236:         if (alternateErrorPage)
 7236:             errorPage.Assign(alternateErrorPage);
 7236: 
 7236:         if (NS_ERROR_PHISHING_URI == aError)
 7236:             error.AssignLiteral("phishingBlocked");
 7236:         else
 7236:             error.AssignLiteral("malwareBlocked");
 7236:         cssClass.AssignLiteral("blacklist");
    1:     }
    1:     else {
    1:         // Errors requiring simple formatting
    1:         switch (aError) {
    1:         case NS_ERROR_MALFORMED_URI:
    1:             // URI is malformed
    1:             error.AssignLiteral("malformedURI");
    1:             break;
    1:         case NS_ERROR_REDIRECT_LOOP:
    1:             // Doc failed to load because the server generated too many redirects
    1:             error.AssignLiteral("redirectLoop");
    1:             break;
    1:         case NS_ERROR_UNKNOWN_SOCKET_TYPE:
    1:             // Doc failed to load because PSM is not installed
    1:             error.AssignLiteral("unknownSocketType");
    1:             break;
    1:         case NS_ERROR_NET_RESET:
    1:             // Doc failed to load because the server kept reseting the connection
    1:             // before we could read any data from it
    1:             error.AssignLiteral("netReset");
    1:             break;
    1:         case NS_ERROR_DOCUMENT_NOT_CACHED:
13314:             // Doc failed to load because we are offline and the cache does not
    1:             // contain a copy of the document.
71902:         case NS_ERROR_OFFLINE:
71902:             // Doc failed to load because we are offline
    1:             error.AssignLiteral("netOffline");
    1:             break;
    1:         case NS_ERROR_DOCUMENT_IS_PRINTMODE:
    1:             // Doc navigation attempted while Printing or Print Preview
    1:             error.AssignLiteral("isprinting");
    1:             break;
    1:         case NS_ERROR_PORT_ACCESS_NOT_ALLOWED:
    1:             // Port blocked for security reasons
13314:             addHostPort = PR_TRUE;
    1:             error.AssignLiteral("deniedPortAccess");
    1:             break;
    1:         case NS_ERROR_UNKNOWN_PROXY_HOST:
    1:             // Proxy hostname could not be resolved.
    1:             error.AssignLiteral("proxyResolveFailure");
    1:             break;
    1:         case NS_ERROR_PROXY_CONNECTION_REFUSED:
    1:             // Proxy connection was refused.
    1:             error.AssignLiteral("proxyConnectFailure");
    1:             break;
    1:         case NS_ERROR_INVALID_CONTENT_ENCODING:
    1:             // Bad Content Encoding.
    1:             error.AssignLiteral("contentEncodingError");
    1:             break;
60516:         case NS_ERROR_REMOTE_XUL:
60516:         {
60516:             error.AssignLiteral("remoteXUL");
60516:             break;
60516:         }
 8363:         case NS_ERROR_UNSAFE_CONTENT_TYPE:
 8363:             // Channel refused to load from an unrecognized content type.
 8363:             error.AssignLiteral("unsafeContentType");
 8363:             break;
71421:         case NS_ERROR_CORRUPTED_CONTENT:
71421:             // Broken Content Detected. e.g. Content-MD5 check failure.
71421:             error.AssignLiteral("corruptedContentError");
71421:             break;
    1:         }
    1:     }
    1: 
    1:     // Test if the error should be displayed
    1:     if (error.IsEmpty()) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Test if the error needs to be formatted
    1:     if (!messageStr.IsEmpty()) {
    1:         // already obtained message
    1:     }
13314:     else {
13314:         if (addHostPort) {
13314:             // Build up the host:port string.
13314:             nsCAutoString hostport;
13314:             if (aURI) {
13314:                 aURI->GetHostPort(hostport);
13314:             } else {
13314:                 hostport.AssignLiteral("?");
13314:             }
13314:             CopyUTF8toUTF16(hostport, formatStrs[formatStrCount++]);
13314:         }
13314: 
13314:         nsCAutoString spec;
13314:         rv = NS_ERROR_NOT_AVAILABLE;
13314:         if (aURI) {
13314:             // displaying "file://" is aesthetically unpleasing and could even be
13314:             // confusing to the user
79445:             bool isFileURI = false;
13314:             rv = aURI->SchemeIs("file", &isFileURI);
13314:             if (NS_SUCCEEDED(rv) && isFileURI)
13314:                 aURI->GetPath(spec);
13314:             else
13314:                 aURI->GetSpec(spec);
13314: 
13314:             nsCAutoString charset;
13314:             // unescape and convert from origin charset
13314:             aURI->GetOriginCharset(charset);
13314:             nsCOMPtr<nsITextToSubURI> textToSubURI(
13314:                 do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv));
13314:             if (NS_SUCCEEDED(rv)) {
13314:                 rv = textToSubURI->UnEscapeURIForUI(charset, spec, formatStrs[formatStrCount]);
13314:             }
13314:         } else {
13314:             spec.AssignLiteral("?");
13314:         }
13314:         if (NS_FAILED(rv))
13314:             CopyUTF8toUTF16(spec, formatStrs[formatStrCount]);
13314:         rv = NS_OK;
13314:         ++formatStrCount;
13314: 
    1:         const PRUnichar *strs[kMaxFormatStrArgs];
    1:         for (PRUint32 i = 0; i < formatStrCount; i++) {
    1:             strs[i] = formatStrs[i].get();
    1:         }
    1:         nsXPIDLString str;
    1:         rv = stringBundle->FormatStringFromName(
    1:             error.get(),
    1:             strs, formatStrCount, getter_Copies(str));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:         messageStr.Assign(str.get());
    1:     }
    1: 
    1:     // Display the error as a page or an alert prompt
    1:     NS_ENSURE_FALSE(messageStr.IsEmpty(), NS_ERROR_FAILURE);
    1:     // Note: For now, display an alert instead of an error page if we have no
    1:     // URI object. Missing URI objects are handled badly by session history.
    1:     if (mUseErrorPages && aURI && aFailedChannel) {
    1:         // Display an error page
 7236:         LoadErrorPage(aURI, aURL, errorPage.get(), error.get(),
 7236:                       messageStr.get(), cssClass.get(), aFailedChannel);
    1:     } 
    1:     else
    1:     {
    1:         // The prompter reqires that our private window has a document (or it
    1:         // asserts). Satisfy that assertion now since GetDocument will force
    1:         // creation of one if it hasn't already been created.
    1:         nsCOMPtr<nsPIDOMWindow> pwin(do_QueryInterface(mScriptGlobal));
    1:         if (pwin) {
    1:             nsCOMPtr<nsIDOMDocument> doc;
    1:             pwin->GetDocument(getter_AddRefs(doc));
    1:         }
    1: 
    1:         // Display a message box
    1:         prompter->Alert(nsnull, messageStr.get());
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::LoadErrorPage(nsIURI *aURI, const PRUnichar *aURL,
 7236:                           const char *aErrorPage,
    1:                           const PRUnichar *aErrorType,
    1:                           const PRUnichar *aDescription,
 5528:                           const char *aCSSClass,
    1:                           nsIChannel* aFailedChannel)
    1: {
    1: #if defined(PR_LOGGING) && defined(DEBUG)
    1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         aURI->GetSpec(spec);
    1: 
    1:         nsCAutoString chanName;
    1:         if (aFailedChannel)
    1:             aFailedChannel->GetName(chanName);
    1:         else
    1:             chanName.AssignLiteral("<no channel>");
    1: 
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:                ("nsDocShell[%p]::LoadErrorPage(\"%s\", \"%s\", {...}, [%s])\n", this,
    1:                 spec.get(), NS_ConvertUTF16toUTF8(aURL).get(), chanName.get()));
    1:     }
    1: #endif
34780:     mFailedChannel = aFailedChannel;
34780:     mFailedURI = aURI;
34780:     mFailedLoadType = mLoadType;
34780: 
37802:     if (mLSHE) {
80309:         // If we don't give mLSHE a new doc identifier here, when we go back or
80309:         // forward to another SHEntry with the same doc identifier, the error
80309:         // page will persist.
80309:         mLSHE->SetUniqueDocIdentifier();
37802:     }
37802: 
    1:     nsCAutoString url;
    1:     nsCAutoString charset;
    1:     if (aURI)
    1:     {
    1:         nsresult rv = aURI->GetSpec(url);
    1:         rv |= aURI->GetOriginCharset(charset);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else if (aURL)
    1:     {
    1:         CopyUTF16toUTF8(aURL, url);
    1:     }
    1:     else
    1:     {
    1:         return NS_ERROR_INVALID_POINTER;
    1:     }
    1: 
    1:     // Create a URL to pass all the error information through to the page.
    1: 
58806: #undef SAFE_ESCAPE
58806: #define SAFE_ESCAPE(cstring, escArg1, escArg2)  \
58806:     {                                           \
58806:         char* s = nsEscape(escArg1, escArg2);   \
58806:         if (!s)                                 \
58806:             return NS_ERROR_OUT_OF_MEMORY;      \
58806:         cstring.Adopt(s);                       \
58806:     }
58806:     nsCString escapedUrl, escapedCharset, escapedError, escapedDescription,
58806:               escapedCSSClass;
58806:     SAFE_ESCAPE(escapedUrl, url.get(), url_Path);
58806:     SAFE_ESCAPE(escapedCharset, charset.get(), url_Path);
58806:     SAFE_ESCAPE(escapedError,
58806:                 NS_ConvertUTF16toUTF8(aErrorType).get(), url_Path);
58806:     SAFE_ESCAPE(escapedDescription,
58806:                 NS_ConvertUTF16toUTF8(aDescription).get(), url_Path);
58806:     if (aCSSClass) {
58806:         SAFE_ESCAPE(escapedCSSClass, aCSSClass, url_Path);
58806:     }
 7236:     nsCString errorPageUrl("about:");
 7236:     errorPageUrl.AppendASCII(aErrorPage);
 7236:     errorPageUrl.AppendLiteral("?e=");
    1: 
58806:     errorPageUrl.AppendASCII(escapedError.get());
    1:     errorPageUrl.AppendLiteral("&u=");
58806:     errorPageUrl.AppendASCII(escapedUrl.get());
58806:     if (!escapedCSSClass.IsEmpty()) {
 5528:         errorPageUrl.AppendASCII("&s=");
58806:         errorPageUrl.AppendASCII(escapedCSSClass.get());
 5528:     }
    1:     errorPageUrl.AppendLiteral("&c=");
58806:     errorPageUrl.AppendASCII(escapedCharset.get());
    1:     errorPageUrl.AppendLiteral("&d=");
58806:     errorPageUrl.AppendASCII(escapedDescription.get());
    1: 
    1:     nsCOMPtr<nsIURI> errorPageURI;
    1:     nsresult rv = NS_NewURI(getter_AddRefs(errorPageURI), errorPageUrl);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
20758:     return InternalLoad(errorPageURI, nsnull, nsnull,
20758:                         INTERNAL_LOAD_FLAGS_INHERIT_OWNER, nsnull, nsnull,
    1:                         nsnull, nsnull, LOAD_ERROR_PAGE,
54823:                         nsnull, PR_TRUE, nsnull, nsnull);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Reload(PRUint32 aReloadFlags)
    1: {
 2400:     if (!IsNavigationAllowed()) {
    1:       return NS_OK; // JS may not handle returning of an error code
    1:     }
    1:     nsresult rv;
    1:     NS_ASSERTION(((aReloadFlags & 0xf) == 0),
    1:                  "Reload command not updated to use load flags!");
21935:     NS_ASSERTION((aReloadFlags & EXTRA_LOAD_FLAGS) == 0,
21935:                  "Don't pass these flags to Reload");
    1: 
    1:     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_RELOAD_NORMAL, aReloadFlags);
    1:     NS_ENSURE_TRUE(IsValidLoadType(loadType), NS_ERROR_INVALID_ARG);
    1: 
    1:     // Send notifications to the HistoryListener if any, about the impending reload
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     nsCOMPtr<nsISHistoryInternal> shistInt(do_QueryInterface(rootSH));
79445:     bool canReload = true; 
    1:     if (rootSH) {
    1:       nsCOMPtr<nsISHistoryListener> listener;
    1:       shistInt->GetListener(getter_AddRefs(listener));
    1:       if (listener) {
    1:         listener->OnHistoryReload(mCurrentURI, aReloadFlags, &canReload);
    1:       }
    1:     }
    1: 
    1:     if (!canReload)
    1:       return NS_OK;
    1:     
    1:     /* If you change this part of code, make sure bug 45297 does not re-occur */
    1:     if (mOSHE) {
    1:         rv = LoadHistoryEntry(mOSHE, loadType);
    1:     }
    1:     else if (mLSHE) { // In case a reload happened before the current load is done
    1:         rv = LoadHistoryEntry(mLSHE, loadType);
    1:     }
    1:     else {
48097:         nsCOMPtr<nsIDocument> doc(do_GetInterface(GetAsSupports(this)));
    1: 
    1:         nsIPrincipal* principal = nsnull;
    1:         nsAutoString contentTypeHint;
    1:         if (doc) {
    1:             principal = doc->NodePrincipal();
    1:             doc->GetContentType(contentTypeHint);
    1:         }
    1: 
    1:         rv = InternalLoad(mCurrentURI,
    1:                           mReferrerURI,
    1:                           principal,
    1:                           INTERNAL_LOAD_FLAGS_NONE, // Do not inherit owner from document
    1:                           nsnull,         // No window target
    1:                           NS_LossyConvertUTF16toASCII(contentTypeHint).get(),
    1:                           nsnull,         // No post data
    1:                           nsnull,         // No headers data
    1:                           loadType,       // Load type
    1:                           nsnull,         // No SHEntry
    1:                           PR_TRUE,
    1:                           nsnull,         // No nsIDocShell
54823:                           nsnull);        // No nsIRequest
    1:     }
    1:     
14631: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Stop(PRUint32 aStopFlags)
    1: {
    1:     // Revoke any pending event related to content viewer restoration
    1:     mRestorePresentationEvent.Revoke();
    1: 
34780:     if (mLoadType == LOAD_ERROR_PAGE) {
34780:         if (mLSHE) {
30832:             // Since error page loads never unset mLSHE, do so now
30832:             SetHistoryEntry(&mOSHE, mLSHE);
30832:             SetHistoryEntry(&mLSHE, nsnull);
30832:         }
30832: 
34780:         mFailedChannel = nsnull;
34780:         mFailedURI = nsnull;
34780:     }
34780: 
 5536:     if (nsIWebNavigation::STOP_CONTENT & aStopFlags) {
    1:         // Stop the document loading
    1:         if (mContentViewer)
    1:             mContentViewer->Stop();
    1:     }
    1: 
    1:     if (nsIWebNavigation::STOP_NETWORK & aStopFlags) {
    1:         // Suspend any timers that were set for this loader.  We'll clear
    1:         // them out for good in CreateContentViewer.
    1:         if (mRefreshURIList) {
    1:             SuspendRefreshURIs();
    1:             mSavedRefreshURIList.swap(mRefreshURIList);
    1:             mRefreshURIList = nsnull;
    1:         }
    1: 
    1:         // XXXbz We could also pass |this| to nsIURILoader::Stop.  That will
    1:         // just call Stop() on us as an nsIDocumentLoader... We need fewer
    1:         // redundant apis!
    1:         Stop();
    1:     }
    1: 
29263:     PRInt32 n;
29263:     PRInt32 count = mChildList.Count();
    1:     for (n = 0; n < count; n++) {
29263:         nsCOMPtr<nsIWebNavigation> shellAsNav(do_QueryInterface(ChildAt(n)));
    1:         if (shellAsNav)
    1:             shellAsNav->Stop(aStopFlags);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetDocument(nsIDOMDocument ** aDocument)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aDocument);
    1:     NS_ENSURE_SUCCESS(EnsureContentViewer(), NS_ERROR_FAILURE);
    1: 
    1:     return mContentViewer->GetDOMDocument(aDocument);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCurrentURI(nsIURI ** aURI)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aURI);
    1: 
    1:     if (mCurrentURI) {
    1:         return NS_EnsureSafeToReturn(mCurrentURI, aURI);
    1:     }
    1: 
    1:     *aURI = nsnull;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetReferringURI(nsIURI ** aURI)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aURI);
    1: 
    1:     *aURI = mReferrerURI;
    1:     NS_IF_ADDREF(*aURI);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetSessionHistory(nsISHistory * aSessionHistory)
    1: {
    1: 
    1:     NS_ENSURE_TRUE(aSessionHistory, NS_ERROR_FAILURE);
    1:     // make sure that we are the root docshell and
    1:     // set a handle to root docshell in SH.
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1:     /* Get the root docshell. If *this* is the root docshell
    1:      * then save a handle to *this* in SH. SH needs it to do
    1:      * traversions thro' its entries
    1:      */
    1:     GetSameTypeRootTreeItem(getter_AddRefs(root));
    1:     NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
 3233:     if (root.get() == static_cast<nsIDocShellTreeItem *>(this)) {
    1:         mSessionHistory = aSessionHistory;
    1:         nsCOMPtr<nsISHistoryInternal>
    1:             shPrivate(do_QueryInterface(mSessionHistory));
    1:         NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
    1:         shPrivate->SetRootDocShell(this);
    1:         return NS_OK;
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: 
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSessionHistory(nsISHistory ** aSessionHistory)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aSessionHistory);
    1:     *aSessionHistory = mSessionHistory;
    1:     NS_IF_ADDREF(*aSessionHistory);
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIWebPageDescriptor
    1: //*****************************************************************************
    1: NS_IMETHODIMP
    1: nsDocShell::LoadPage(nsISupports *aPageDescriptor, PRUint32 aDisplayType)
    1: {
    1:     nsCOMPtr<nsISHEntry> shEntryIn(do_QueryInterface(aPageDescriptor));
    1: 
    1:     // Currently, the opaque 'page descriptor' is an nsISHEntry...
    1:     if (!shEntryIn) {
    1:         return NS_ERROR_INVALID_POINTER;
    1:     }
    1: 
    1:     // Now clone shEntryIn, since we might end up modifying it later on, and we
    1:     // want a page descriptor to be reusable.
    1:     nsCOMPtr<nsISHEntry> shEntry;
    1:     nsresult rv = shEntryIn->Clone(getter_AddRefs(shEntry));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
80309:     // Give our cloned shEntry a new document identifier so this load is
80309:     // independent of all other loads.  (This is important, in particular,
80309:     // for bugs 582795 and 585298.)
80309:     rv = shEntry->SetUniqueDocIdentifier();
58183:     NS_ENSURE_SUCCESS(rv, rv);
58183: 
    1:     //
    1:     // load the page as view-source
    1:     //
    1:     if (nsIWebPageDescriptor::DISPLAY_AS_SOURCE == aDisplayType) {
    1:         nsCOMPtr<nsIURI> oldUri, newUri;
    1:         nsCString spec, newSpec;
    1: 
    1:         // Create a new view-source URI and replace the original.
    1:         rv = shEntry->GetURI(getter_AddRefs(oldUri));
    1:         if (NS_FAILED(rv))
    1:               return rv;
    1: 
    1:         oldUri->GetSpec(spec);
    1:         newSpec.AppendLiteral("view-source:");
    1:         newSpec.Append(spec);
    1: 
    1:         rv = NS_NewURI(getter_AddRefs(newUri), newSpec);
    1:         if (NS_FAILED(rv)) {
    1:             return rv;
    1:         }
    1:         shEntry->SetURI(newUri);
    1:     }
    1: 
    1:     rv = LoadHistoryEntry(shEntry, LOAD_HISTORY);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCurrentDescriptor(nsISupports **aPageDescriptor)
    1: {
    1:     NS_PRECONDITION(aPageDescriptor, "Null out param?");
    1: 
    1:     *aPageDescriptor = nsnull;
    1: 
    1:     nsISHEntry* src = mOSHE ? mOSHE : mLSHE;
    1:     if (src) {
    1:         nsCOMPtr<nsISHEntry> dest;
    1: 
    1:         nsresult rv = src->Clone(getter_AddRefs(dest));
    1:         if (NS_FAILED(rv)) {
    1:             return rv;
    1:         }
    1: 
    1:         // null out inappropriate cloned attributes...
    1:         dest->SetParent(nsnull);
    1:         dest->SetIsSubFrame(PR_FALSE);
    1:         
    1:         return CallQueryInterface(dest, aPageDescriptor);
    1:     }
    1: 
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIBaseWindow
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::InitWindow(nativeWindow parentNativeWindow,
    1:                        nsIWidget * parentWidget, PRInt32 x, PRInt32 y,
    1:                        PRInt32 cx, PRInt32 cy)
    1: {
    1:     SetParentWidget(parentWidget);
    1:     SetPositionAndSize(x, y, cx, cy, PR_FALSE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Create()
    1: {
72449:     if (mCreated) {
28078:         // We've already been created
28078:         return NS_OK;
28078:     }
28078: 
    1:     NS_ASSERTION(mItemType == typeContent || mItemType == typeChrome,
    1:                  "Unexpected item type in docshell");
    1: 
72449:     NS_ENSURE_TRUE(Preferences::GetRootBranch(), NS_ERROR_FAILURE);
72449:     mCreated = PR_TRUE;
72449: 
72449:     mAllowSubframes =
72449:         Preferences::GetBool("browser.frames.enabled", mAllowSubframes);
    1: 
74431:     if (gValidateOrigin == 0xffffffff) {
    1:         // Check pref to see if we should prevent frameset spoofing
72449:         gValidateOrigin =
79445:             Preferences::GetBool("browser.frame.validate_origin", true);
    1:     }
    1: 
    1:     // Should we use XUL error pages instead of alerts if possible?
72449:     mUseErrorPages =
72449:         Preferences::GetBool("browser.xul.error_pages.enabled", mUseErrorPages);
72449: 
72449:     if (mObserveErrorPages) {
72449:         Preferences::AddStrongObserver(this, "browser.xul.error_pages.enabled");
    1:     }
    1: 
    1:     nsCOMPtr<nsIObserverService> serv = do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
    1:     if (serv) {
    1:         const char* msg = mItemType == typeContent ?
    1:             NS_WEBNAVIGATION_CREATE : NS_CHROME_WEBNAVIGATION_CREATE;
    1:         serv->NotifyObservers(GetAsSupports(this), msg, nsnull);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Destroy()
    1: {
    1:     NS_ASSERTION(mItemType == typeContent || mItemType == typeChrome,
    1:                  "Unexpected item type in docshell");
    1: 
    1:     if (!mIsBeingDestroyed) {
    1:         nsCOMPtr<nsIObserverService> serv =
    1:             do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
    1:         if (serv) {
    1:             const char* msg = mItemType == typeContent ?
    1:                 NS_WEBNAVIGATION_DESTROY : NS_CHROME_WEBNAVIGATION_DESTROY;
    1:             serv->NotifyObservers(GetAsSupports(this), msg, nsnull);
    1:         }
    1:     }
    1:     
    1:     mIsBeingDestroyed = PR_TRUE;
    1: 
    1:     // Remove our pref observers
    1:     if (mObserveErrorPages) {
72449:         Preferences::RemoveObserver(this, "browser.xul.error_pages.enabled");
    1:         mObserveErrorPages = PR_FALSE;
    1:     }
    1: 
10676:     // Make sure to blow away our mLoadingURI just in case.  No loads
10676:     // from inside this pagehide.
10676:     mLoadingURI = nsnull;
10676: 
    1:     // Fire unload event before we blow anything away.
    1:     (void) FirePageHideNotification(PR_TRUE);
    1: 
15052:     // Clear pointers to any detached nsEditorData that's lying
15052:     // around in shistory entries. Breaks cycle. See bug 430921.
15052:     if (mOSHE)
15052:       mOSHE->SetEditorData(nsnull);
15052:     if (mLSHE)
15052:       mLSHE->SetEditorData(nsnull);
15052:       
    1:     // Note: mContentListener can be null if Init() failed and we're being
    1:     // called from the destructor.
    1:     if (mContentListener) {
    1:         mContentListener->DropDocShellreference();
    1:         mContentListener->SetParentContentListener(nsnull);
    1:         // Note that we do NOT set mContentListener to null here; that
    1:         // way if someone tries to do a load in us after this point
    1:         // the nsDSURIContentListener will block it.  All of which
    1:         // means that we should do this before calling Stop(), of
    1:         // course.
    1:     }
    1: 
    1:     // Stop any URLs that are currently being loaded...
    1:     Stop(nsIWebNavigation::STOP_ALL);
    1: 
14631:     mEditorData = nsnull;
    1: 
    1:     mTransferableHookData = nsnull;
    1: 
    1:     // Save the state of the current document, before destroying the window.
    1:     // This is needed to capture the state of a frameset when the new document
    1:     // causes the frameset to be destroyed...
    1:     PersistLayoutHistoryState();
    1: 
    1:     // Remove this docshell from its parent's child list
 1160:     nsCOMPtr<nsIDocShellTreeItem> docShellParentAsItem =
    1:         do_QueryInterface(GetAsSupports(mParent));
 1160:     if (docShellParentAsItem)
 1160:         docShellParentAsItem->RemoveChild(this);
    1: 
    1:     if (mContentViewer) {
    1:         mContentViewer->Close(nsnull);
    1:         mContentViewer->Destroy();
    1:         mContentViewer = nsnull;
    1:     }
    1: 
    1:     nsDocLoader::Destroy();
    1:     
    1:     mParentWidget = nsnull;
    1:     mCurrentURI = nsnull;
    1: 
    1:     if (mScriptGlobal) {
    1:         nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
    1:         win->SetDocShell(nsnull);
    1: 
    1:         mScriptGlobal = nsnull;
    1:     }
    1: 
27412:     if (mSessionHistory) {
27412:         // We want to destroy these content viewers now rather than
27412:         // letting their destruction wait for the session history
27412:         // entries to get garbage collected.  (Bug 488394)
27412:         nsCOMPtr<nsISHistoryInternal> shPrivate =
27412:             do_QueryInterface(mSessionHistory);
27412:         if (shPrivate) {
27412:             shPrivate->EvictAllContentViewers();
27412:         }
    1:         mSessionHistory = nsnull;
27412:     }
27412: 
    1:     SetTreeOwner(nsnull);
    1: 
    1:     // required to break ref cycle
    1:     mSecurityUI = nsnull;
    1: 
    1:     // Cancel any timers that were set for this docshell; this is needed
    1:     // to break the cycle between us and the timers.
    1:     CancelRefreshURITimers();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetPosition(PRInt32 x, PRInt32 y)
    1: {
    1:     mBounds.x = x;
    1:     mBounds.y = y;
    1: 
    1:     if (mContentViewer)
    1:         NS_ENSURE_SUCCESS(mContentViewer->Move(x, y), NS_ERROR_FAILURE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPosition(PRInt32 * aX, PRInt32 * aY)
    1: {
    1:     PRInt32 dummyHolder;
    1:     return GetPositionAndSize(aX, aY, &dummyHolder, &dummyHolder);
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::SetSize(PRInt32 aCX, PRInt32 aCY, bool aRepaint)
    1: {
    1:     PRInt32 x = 0, y = 0;
    1:     GetPosition(&x, &y);
    1:     return SetPositionAndSize(x, y, aCX, aCY, aRepaint);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetSize(PRInt32 * aCX, PRInt32 * aCY)
    1: {
    1:     PRInt32 dummyHolder;
    1:     return GetPositionAndSize(&dummyHolder, &dummyHolder, aCX, aCY);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetPositionAndSize(PRInt32 x, PRInt32 y, PRInt32 cx,
79445:                                PRInt32 cy, bool fRepaint)
    1: {
    1:     mBounds.x = x;
    1:     mBounds.y = y;
    1:     mBounds.width = cx;
    1:     mBounds.height = cy;
    1: 
 6162:     // Hold strong ref, since SetBounds can make us null out mContentViewer
 6162:     nsCOMPtr<nsIContentViewer> viewer = mContentViewer;
 6162:     if (viewer) {
    1:         //XXX Border figured in here or is that handled elsewhere?
 6162:         NS_ENSURE_SUCCESS(viewer->SetBounds(mBounds), NS_ERROR_FAILURE);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPositionAndSize(PRInt32 * x, PRInt32 * y, PRInt32 * cx,
    1:                                PRInt32 * cy)
    1: {
    1:     // We should really consider just getting this information from
    1:     // our window instead of duplicating the storage and code...
33393:     if (cx || cy) {
33393:         // Caller wants to know our size; make sure to give them up to
33393:         // date information.
48097:         nsCOMPtr<nsIDocument> doc(do_GetInterface(GetAsSupports(mParent)));
    1:         if (doc) {
    1:             doc->FlushPendingNotifications(Flush_Layout);
    1:         }
33393:     }
    1:     
 1027:     DoGetPositionAndSize(x, y, cx, cy);
 1027:     return NS_OK;
 1027: }
 1027: 
 1027: void
 1027: nsDocShell::DoGetPositionAndSize(PRInt32 * x, PRInt32 * y, PRInt32 * cx,
 1027:                                  PRInt32 * cy)
 1027: {    
    1:     if (x)
    1:         *x = mBounds.x;
    1:     if (y)
    1:         *y = mBounds.y;
    1:     if (cx)
    1:         *cx = mBounds.width;
    1:     if (cy)
    1:         *cy = mBounds.height;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::Repaint(bool aForce)
    1: {
26050:     nsCOMPtr<nsIPresShell> presShell;
26050:     GetPresShell(getter_AddRefs(presShell));
26050:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
26050: 
26050:     nsIViewManager* viewManager = presShell->GetViewManager();
    1:     NS_ENSURE_TRUE(viewManager, NS_ERROR_FAILURE);
    1: 
    1:     // what about aForce ?
    1:     NS_ENSURE_SUCCESS(viewManager->UpdateAllViews(0), NS_ERROR_FAILURE);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetParentWidget(nsIWidget ** parentWidget)
    1: {
    1:     NS_ENSURE_ARG_POINTER(parentWidget);
    1: 
    1:     *parentWidget = mParentWidget;
    1:     NS_IF_ADDREF(*parentWidget);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetParentWidget(nsIWidget * aParentWidget)
    1: {
    1:     mParentWidget = aParentWidget;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetParentNativeWindow(nativeWindow * parentNativeWindow)
    1: {
    1:     NS_ENSURE_ARG_POINTER(parentNativeWindow);
    1: 
    1:     if (mParentWidget)
    1:         *parentNativeWindow = mParentWidget->GetNativeData(NS_NATIVE_WIDGET);
    1:     else
    1:         *parentNativeWindow = nsnull;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetParentNativeWindow(nativeWindow parentNativeWindow)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetVisibility(bool * aVisibility)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aVisibility);
21191: 
    1:     *aVisibility = PR_FALSE;
21191: 
21191:     if (!mContentViewer)
21191:         return NS_OK;
21191: 
    1:     nsCOMPtr<nsIPresShell> presShell;
21191:     GetPresShell(getter_AddRefs(presShell));
21191:     if (!presShell)
21191:         return NS_OK;
    1: 
    1:     // get the view manager
    1:     nsIViewManager* vm = presShell->GetViewManager();
    1:     NS_ENSURE_TRUE(vm, NS_ERROR_FAILURE);
    1: 
    1:     // get the root view
64435:     nsIView *view = vm->GetRootView(); // views are not ref counted
    1:     NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
    1: 
    1:     // if our root view is hidden, we are not visible
21191:     if (view->GetVisibility() == nsViewVisibility_kHide)
21191:         return NS_OK;
    1: 
    1:     // otherwise, we must walk up the document and view trees checking
19435:     // for a hidden view, unless we're an off screen browser, which 
19435:     // would make this test meaningless.
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> treeItem = this;
    1:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
    1:     treeItem->GetParent(getter_AddRefs(parentItem));
    1:     while (parentItem) {
    1:         nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(treeItem));
    1:         docShell->GetPresShell(getter_AddRefs(presShell));
    1: 
    1:         nsCOMPtr<nsIDocShell> parentDS = do_QueryInterface(parentItem);
    1:         nsCOMPtr<nsIPresShell> pPresShell;
    1:         parentDS->GetPresShell(getter_AddRefs(pPresShell));
    1: 
    1:         // Null-check for crash in bug 267804
    1:         if (!pPresShell) {
21191:             NS_NOTREACHED("parent docshell has null pres shell");
    1:             return NS_OK;
    1:         }
    1: 
    1:         nsIContent *shellContent =
    1:             pPresShell->GetDocument()->FindContentForSubDocument(presShell->GetDocument());
    1:         NS_ASSERTION(shellContent, "subshell not in the map");
    1: 
36700:         nsIFrame* frame = shellContent ? shellContent->GetPrimaryFrame() : nsnull;
79445:         bool isDocShellOffScreen = false;
19435:         docShell->GetIsOffScreenBrowser(&isDocShellOffScreen);
21191:         if (frame && !frame->AreAncestorViewsVisible() && !isDocShellOffScreen)
21191:             return NS_OK;
    1: 
    1:         treeItem = parentItem;
    1:         treeItem->GetParent(getter_AddRefs(parentItem));
    1:     }
    1: 
21191:     nsCOMPtr<nsIBaseWindow> treeOwnerAsWin(do_QueryInterface(mTreeOwner));
    1:     if (!treeOwnerAsWin) {
    1:         *aVisibility = PR_TRUE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Check with the tree owner as well to give embedders a chance to
    1:     // expose visibility as well.
    1:     return treeOwnerAsWin->GetVisibility(aVisibility);
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::SetIsOffScreenBrowser(bool aIsOffScreen) 
19435: {
19435:     mIsOffScreenBrowser = aIsOffScreen;
19435:     return NS_OK;
19435: }
19435: 
19435: NS_IMETHODIMP
79445: nsDocShell::GetIsOffScreenBrowser(bool *aIsOffScreen) 
19435: {
19435:     *aIsOffScreen = mIsOffScreenBrowser;
19435:     return NS_OK;
19435: }
19435: 
19435: NS_IMETHODIMP
79445: nsDocShell::SetIsActive(bool aIsActive)
48937: {
48937:   // We disallow setting active on chrome docshells.
48937:   if (mItemType == nsIDocShellTreeItem::typeChrome)
48937:     return NS_ERROR_INVALID_ARG;
48937: 
48937:   // Keep track ourselves.
48937:   mIsActive = aIsActive;
48937: 
48937:   // Tell the PresShell about it.
48937:   nsCOMPtr<nsIPresShell> pshell;
48937:   GetPresShell(getter_AddRefs(pshell));
48937:   if (pshell)
48937:     pshell->SetIsActive(aIsActive);
48937: 
63938:   // Tell the window about it
63938:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(mScriptGlobal);
63938:   if (win) {
63938:       win->SetIsBackground(!aIsActive);
80229:       nsCOMPtr<nsIDocument> doc = do_QueryInterface(win->GetExtantDocument());
80229:       if (doc) {
80229:           doc->PostVisibilityUpdateEvent();
80229:       }
63938:   }
63938: 
48937:   // Recursively tell all of our children
48937:   PRInt32 n = mChildList.Count();
48937:   for (PRInt32 i = 0; i < n; ++i) {
48937:       nsCOMPtr<nsIDocShell> docshell = do_QueryInterface(ChildAt(i));
48937:       if (docshell)
48937:         docshell->SetIsActive(aIsActive);
48937:   }
48937: 
48937:   return NS_OK;
48937: }
48937: 
48937: NS_IMETHODIMP
79445: nsDocShell::GetIsActive(bool *aIsActive)
48937: {
48937:   *aIsActive = mIsActive;
48937:   return NS_OK;
48937: }
48937: 
48937: NS_IMETHODIMP
79445: nsDocShell::SetIsAppTab(bool aIsAppTab)
56685: {
56685:   mIsAppTab = aIsAppTab;
56685:   return NS_OK;
56685: }
56685: 
56685: NS_IMETHODIMP
79445: nsDocShell::GetIsAppTab(bool *aIsAppTab)
56685: {
56685:   *aIsAppTab = mIsAppTab;
56685:   return NS_OK;
56685: }
56685: 
56685: NS_IMETHODIMP
79445: nsDocShell::SetVisibility(bool aVisibility)
    1: {
    1:     if (!mContentViewer)
    1:         return NS_OK;
    1:     if (aVisibility) {
    1:         mContentViewer->Show();
    1:     }
    1:     else {
    1:         mContentViewer->Hide();
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetEnabled(bool *aEnabled)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEnabled);
    1:   *aEnabled = PR_TRUE;
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::SetEnabled(bool aEnabled)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetBlurSuppression(bool *aBlurSuppression)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aBlurSuppression);
    1:   *aBlurSuppression = PR_FALSE;
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::SetBlurSuppression(bool aBlurSuppression)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
29018: nsDocShell::SetFocus()
29018: {
29018:   return NS_OK;
29018: }
29018: 
29018: NS_IMETHODIMP
    1: nsDocShell::GetMainWidget(nsIWidget ** aMainWidget)
    1: {
    1:     // We don't create our own widget, so simply return the parent one. 
    1:     return GetParentWidget(aMainWidget);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetTitle(PRUnichar ** aTitle)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aTitle);
    1: 
    1:     *aTitle = ToNewUnicode(mTitle);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetTitle(const PRUnichar * aTitle)
    1: {
    1:     // Store local title
    1:     mTitle = aTitle;
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parent;
    1:     GetSameTypeParent(getter_AddRefs(parent));
    1: 
    1:     // When title is set on the top object it should then be passed to the 
    1:     // tree owner.
    1:     if (!parent) {
    1:         nsCOMPtr<nsIBaseWindow>
    1:             treeOwnerAsWin(do_QueryInterface(mTreeOwner));
    1:         if (treeOwnerAsWin)
    1:             treeOwnerAsWin->SetTitle(aTitle);
    1:     }
    1: 
61540:     if (mCurrentURI && mLoadType != LOAD_ERROR_PAGE && mUseGlobalHistory) {
47716:         nsCOMPtr<IHistory> history = services::GetHistoryService();
47716:         if (history) {
47716:             history->SetURITitle(mCurrentURI, mTitle);
47716:         }
47716:         else if (mGlobalHistory) {
38791:             mGlobalHistory->SetPageTitle(mCurrentURI, nsString(mTitle));
    1:         }
47716:     }
    1: 
31319:     // Update SessionHistory with the document's title.
31319:     if (mOSHE && mLoadType != LOAD_BYPASS_HISTORY &&
31319:         mLoadType != LOAD_ERROR_PAGE) {
31319: 
    1:         mOSHE->SetTitle(mTitle);    
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIScrollable
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetCurScrollPos(PRInt32 scrollOrientation, PRInt32 * curPos)
    1: {
    1:     NS_ENSURE_ARG_POINTER(curPos);
    1: 
37072:     nsIScrollableFrame* sf = GetRootScrollFrame();
37072:     NS_ENSURE_TRUE(sf, NS_ERROR_FAILURE);
37072: 
37072:     nsPoint pt = sf->GetScrollPosition();
    1: 
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
37072:         *curPos = pt.x;
    1:         return NS_OK;
    1: 
    1:     case ScrollOrientation_Y:
37072:         *curPos = pt.y;
    1:         return NS_OK;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetCurScrollPos(PRInt32 scrollOrientation, PRInt32 curPos)
    1: {
37072:     nsIScrollableFrame* sf = GetRootScrollFrame();
37072:     NS_ENSURE_TRUE(sf, NS_ERROR_FAILURE);
37072: 
37072:     nsPoint pt = sf->GetScrollPosition();
    1: 
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
37072:         pt.x = curPos;
    1:         break;
    1: 
    1:     case ScrollOrientation_Y:
37072:         pt.y = curPos;
    1:         break;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
37072:     }
37072: 
37072:     sf->ScrollTo(pt, nsIScrollableFrame::INSTANT);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetCurScrollPosEx(PRInt32 curHorizontalPos, PRInt32 curVerticalPos)
    1: {
37072:     nsIScrollableFrame* sf = GetRootScrollFrame();
37072:     NS_ENSURE_TRUE(sf, NS_ERROR_FAILURE);
37072: 
37072:     sf->ScrollTo(nsPoint(curHorizontalPos, curVerticalPos),
37072:                  nsIScrollableFrame::INSTANT);
    1:     return NS_OK;
    1: }
    1: 
    1: // XXX This is wrong
    1: NS_IMETHODIMP
    1: nsDocShell::GetScrollRange(PRInt32 scrollOrientation,
    1:                            PRInt32 * minPos, PRInt32 * maxPos)
    1: {
    1:     NS_ENSURE_ARG_POINTER(minPos && maxPos);
    1: 
37072:     nsIScrollableFrame* sf = GetRootScrollFrame();
37072:     NS_ENSURE_TRUE(sf, NS_ERROR_FAILURE);
37072: 
37072:     nsSize portSize = sf->GetScrollPortRect().Size();
37072:     nsRect range = sf->GetScrollRange();
    1: 
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
37072:         *minPos = range.x;
37072:         *maxPos = range.XMost() + portSize.width;
    1:         return NS_OK;
    1: 
    1:     case ScrollOrientation_Y:
37072:         *minPos = range.y;
37072:         *maxPos = range.YMost() + portSize.height;
    1:         return NS_OK;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetScrollRange(PRInt32 scrollOrientation,
    1:                            PRInt32 minPos, PRInt32 maxPos)
    1: {
    1:     //XXX First Check
    1:     /*
    1:        Retrieves or Sets the valid ranges for the thumb.  When maxPos is set to 
    1:        something less than the current thumb position, curPos is set = to maxPos.
    1: 
    1:        @return NS_OK - Setting or Getting completed successfully.
    1:        NS_ERROR_INVALID_ARG - returned when curPos is not within the
    1:        minPos and maxPos.
    1:      */
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetScrollRangeEx(PRInt32 minHorizontalPos,
    1:                              PRInt32 maxHorizontalPos, PRInt32 minVerticalPos,
    1:                              PRInt32 maxVerticalPos)
    1: {
    1:     //XXX First Check
    1:     /*
    1:        Retrieves or Sets the valid ranges for the thumb.  When maxPos is set to 
    1:        something less than the current thumb position, curPos is set = to maxPos.
    1: 
    1:        @return NS_OK - Setting or Getting completed successfully.
    1:        NS_ERROR_INVALID_ARG - returned when curPos is not within the
    1:        minPos and maxPos.
    1:      */
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
28078: // This returns setting for all documents in this docshell
    1: NS_IMETHODIMP
    1: nsDocShell::GetDefaultScrollbarPreferences(PRInt32 scrollOrientation,
    1:                                            PRInt32 * scrollbarPref)
    1: {
    1:     NS_ENSURE_ARG_POINTER(scrollbarPref);
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
    1:         *scrollbarPref = mDefaultScrollbarPref.x;
    1:         return NS_OK;
    1: 
    1:     case ScrollOrientation_Y:
    1:         *scrollbarPref = mDefaultScrollbarPref.y;
    1:         return NS_OK;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // Set scrolling preference for all documents in this shell
    1: //
    1: // There are three possible values stored in the shell:
    1: //  1) nsIScrollable::Scrollbar_Never = no scrollbar
    1: //  2) nsIScrollable::Scrollbar_Auto = scrollbar appears if the document
    1: //     being displayed would normally have scrollbar
    1: //  3) nsIScrollable::Scrollbar_Always = scrollbar always appears
    1: //
    1: // One important client is nsHTMLFrameInnerFrame::CreateWebShell()
    1: NS_IMETHODIMP
    1: nsDocShell::SetDefaultScrollbarPreferences(PRInt32 scrollOrientation,
    1:                                            PRInt32 scrollbarPref)
    1: {
    1:     switch (scrollOrientation) {
    1:     case ScrollOrientation_X:
    1:         mDefaultScrollbarPref.x = scrollbarPref;
    1:         return NS_OK;
    1: 
    1:     case ScrollOrientation_Y:
    1:         mDefaultScrollbarPref.y = scrollbarPref;
    1:         return NS_OK;
    1: 
    1:     default:
    1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
    1:     }
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetScrollbarVisibility(bool * verticalVisible,
79445:                                    bool * horizontalVisible)
    1: {
37072:     nsIScrollableFrame* sf = GetRootScrollFrame();
37072:     NS_ENSURE_TRUE(sf, NS_ERROR_FAILURE);
37072: 
37292:     PRUint32 scrollbarVisibility = sf->GetScrollbarVisibility();
    1:     if (verticalVisible)
37292:         *verticalVisible = (scrollbarVisibility & nsIScrollableFrame::VERTICAL) != 0;
    1:     if (horizontalVisible)
37292:         *horizontalVisible = (scrollbarVisibility & nsIScrollableFrame::HORIZONTAL) != 0;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsITextScroll
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::ScrollByLines(PRInt32 numLines)
    1: {
37072:     nsIScrollableFrame* sf = GetRootScrollFrame();
37072:     NS_ENSURE_TRUE(sf, NS_ERROR_FAILURE);
37072: 
37072:     sf->ScrollBy(nsIntPoint(0, numLines), nsIScrollableFrame::LINES,
37072:                  nsIScrollableFrame::SMOOTH);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::ScrollByPages(PRInt32 numPages)
    1: {
37072:     nsIScrollableFrame* sf = GetRootScrollFrame();
37072:     NS_ENSURE_TRUE(sf, NS_ERROR_FAILURE);
37072: 
37072:     sf->ScrollBy(nsIntPoint(0, numPages), nsIScrollableFrame::PAGES,
37072:                  nsIScrollableFrame::SMOOTH);
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIScriptGlobalObjectOwner
    1: //*****************************************************************************   
    1: 
    1: nsIScriptGlobalObject*
    1: nsDocShell::GetScriptGlobalObject()
    1: {
    1:     NS_ENSURE_SUCCESS(EnsureScriptEnvironment(), nsnull);
    1: 
    1:     return mScriptGlobal;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIRefreshURI
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::RefreshURI(nsIURI * aURI, PRInt32 aDelay, bool aRepeat,
79445:                        bool aMetaRefresh)
    1: {
    1:     NS_ENSURE_ARG(aURI);
    1: 
    1:     /* Check if Meta refresh/redirects are permitted. Some
    1:      * embedded applications may not want to do this.
    1:      * Must do this before sending out NOTIFY_REFRESH events
    1:      * because listeners may have side effects (e.g. displaying a
    1:      * button to manually trigger the refresh later).
    1:      */
79445:     bool allowRedirects = true;
    1:     GetAllowMetaRedirects(&allowRedirects);
    1:     if (!allowRedirects)
    1:         return NS_OK;
    1: 
    1:     // If any web progress listeners are listening for NOTIFY_REFRESH events,
    1:     // give them a chance to block this refresh.
79445:     bool sameURI;
    1:     nsresult rv = aURI->Equals(mCurrentURI, &sameURI);
    1:     if (NS_FAILED(rv))
    1:         sameURI = PR_FALSE;
    1:     if (!RefreshAttempted(this, aURI, aDelay, sameURI))
    1:         return NS_OK;
    1: 
    1:     nsRefreshTimer *refreshTimer = new nsRefreshTimer();
    1:     NS_ENSURE_TRUE(refreshTimer, NS_ERROR_OUT_OF_MEMORY);
    1:     PRUint32 busyFlags = 0;
    1:     GetBusyFlags(&busyFlags);
    1: 
    1:     nsCOMPtr<nsISupports> dataRef = refreshTimer;    // Get the ref count to 1
    1: 
    1:     refreshTimer->mDocShell = this;
    1:     refreshTimer->mURI = aURI;
    1:     refreshTimer->mDelay = aDelay;
    1:     refreshTimer->mRepeat = aRepeat;
    1:     refreshTimer->mMetaRefresh = aMetaRefresh;
    1: 
    1:     if (!mRefreshURIList) {
    1:         NS_ENSURE_SUCCESS(NS_NewISupportsArray(getter_AddRefs(mRefreshURIList)),
    1:                           NS_ERROR_FAILURE);
    1:     }
    1: 
    1:     if (busyFlags & BUSY_FLAGS_BUSY) {
    1:         // We are busy loading another page. Don't create the
    1:         // timer right now. Instead queue up the request and trigger the
    1:         // timer in EndPageLoad(). 
    1:         mRefreshURIList->AppendElement(refreshTimer);
    1:     }
    1:     else {
    1:         // There is no page loading going on right now.  Create the
    1:         // timer and fire it right away.
    1:         nsCOMPtr<nsITimer> timer = do_CreateInstance("@mozilla.org/timer;1");
    1:         NS_ENSURE_TRUE(timer, NS_ERROR_FAILURE);
    1: 
    1:         mRefreshURIList->AppendElement(timer);      // owning timer ref
    1:         timer->InitWithCallback(refreshTimer, aDelay, nsITimer::TYPE_ONE_SHOT);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
18977: nsresult
18977: nsDocShell::ForceRefreshURIFromTimer(nsIURI * aURI,
18977:                                      PRInt32 aDelay, 
79445:                                      bool aMetaRefresh,
18977:                                      nsITimer* aTimer)
18977: {
18977:     NS_PRECONDITION(aTimer, "Must have a timer here");
18977: 
18977:     // Remove aTimer from mRefreshURIList if needed
18977:     if (mRefreshURIList) {
18977:         PRUint32 n = 0;
18977:         mRefreshURIList->Count(&n);
18977: 
18977:         for (PRUint32 i = 0;  i < n; ++i) {
18977:             nsCOMPtr<nsITimer> timer = do_QueryElementAt(mRefreshURIList, i);
18977:             if (timer == aTimer) {
18977:                 mRefreshURIList->RemoveElementAt(i);
18977:                 break;
18977:             }
18977:         }
18977:     }
18977: 
18977:     return ForceRefreshURI(aURI, aDelay, aMetaRefresh);
18977: }
18977: 
    1: NS_IMETHODIMP
    1: nsDocShell::ForceRefreshURI(nsIURI * aURI,
    1:                             PRInt32 aDelay, 
79445:                             bool aMetaRefresh)
    1: {
    1:     NS_ENSURE_ARG(aURI);
    1: 
    1:     nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
    1:     CreateLoadInfo(getter_AddRefs(loadInfo));
    1:     NS_ENSURE_TRUE(loadInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     /* We do need to pass in a referrer, but we don't want it to
    1:      * be sent to the server.
    1:      */
    1:     loadInfo->SetSendReferrer(PR_FALSE);
    1: 
    1:     /* for most refreshes the current URI is an appropriate
    1:      * internal referrer
    1:      */
    1:     loadInfo->SetReferrer(mCurrentURI);
    1: 
25969:     /* Don't ever "guess" on which owner to use to avoid picking
25969:      * the current owner.
25969:      */
25969:     loadInfo->SetOwnerIsExplicit(PR_TRUE);
25969: 
    1:     /* Check if this META refresh causes a redirection
    1:      * to another site. 
    1:      */
79445:     bool equalUri = false;
    1:     nsresult rv = aURI->Equals(mCurrentURI, &equalUri);
25969:     if (NS_SUCCEEDED(rv) && (!equalUri) && aMetaRefresh &&
25969:         aDelay <= REFRESH_REDIRECT_TIMER) {
25969: 
25969:         /* It is a META refresh based redirection within the threshold time
25969:          * we have in mind (15000 ms as defined by REFRESH_REDIRECT_TIMER).
25969:          * Pass a REPLACE flag to LoadURI().
    1:          */
    1:         loadInfo->SetLoadType(nsIDocShellLoadInfo::loadNormalReplace);
    1:             
    1:         /* for redirects we mimic HTTP, which passes the
    1:          *  original referrer
    1:          */
    1:         nsCOMPtr<nsIURI> internalReferrer;
    1:         GetReferringURI(getter_AddRefs(internalReferrer));
    1:         if (internalReferrer) {
    1:             loadInfo->SetReferrer(internalReferrer);
    1:         }
    1:     }
25969:     else {
    1:         loadInfo->SetLoadType(nsIDocShellLoadInfo::loadRefresh);
25969:     }
25969: 
    1:     /*
    1:      * LoadURI(...) will cancel all refresh timers... This causes the
    1:      * Timer and its refreshData instance to be released...
    1:      */
    1:     LoadURI(aURI, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, PR_TRUE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::SetupRefreshURIFromHeader(nsIURI * aBaseURI,
    1:                                       const nsACString & aHeader)
    1: {
    1:     // Refresh headers are parsed with the following format in mind
    1:     // <META HTTP-EQUIV=REFRESH CONTENT="5; URL=http://uri">
    1:     // By the time we are here, the following is true:
    1:     // header = "REFRESH"
    1:     // content = "5; URL=http://uri" // note the URL attribute is
    1:     // optional, if it is absent, the currently loaded url is used.
    1:     // Also note that the seconds and URL separator can be either
    1:     // a ';' or a ','. The ',' separator should be illegal but CNN
    1:     // is using it.
    1:     // 
    1:     // We need to handle the following strings, where
    1:     //  - X is a set of digits
    1:     //  - URI is either a relative or absolute URI
    1:     //
    1:     // Note that URI should start with "url=" but we allow omission
    1:     //
    1:     // "" || ";" || "," 
    1:     //  empty string. use the currently loaded URI
    1:     //  and refresh immediately.
    1:     // "X" || "X;" || "X,"
    1:     //  Refresh the currently loaded URI in X seconds.
    1:     // "X; URI" || "X, URI"
    1:     //  Refresh using URI as the destination in X seconds.
    1:     // "URI" || "; URI" || ", URI"
    1:     //  Refresh immediately using URI as the destination.
    1:     // 
    1:     // Currently, anything immediately following the URI, if
    1:     // separated by any char in the set "'\"\t\r\n " will be
    1:     // ignored. So "10; url=go.html ; foo=bar" will work,
    1:     // and so will "10; url='go.html'; foo=bar". However,
    1:     // "10; url=go.html; foo=bar" will result in the uri
    1:     // "go.html;" since ';' and ',' are valid uri characters.
    1:     // 
    1:     // Note that we need to remove any tokens wrapping the URI.
    1:     // These tokens currently include spaces, double and single
    1:     // quotes.
    1: 
    1:     // when done, seconds is 0 or the given number of seconds
    1:     //            uriAttrib is empty or the URI specified
    1:     nsCAutoString uriAttrib;
    1:     PRInt32 seconds = 0;
79445:     bool specifiesSeconds = false;
    1: 
    1:     nsACString::const_iterator iter, tokenStart, doneIterating;
    1: 
    1:     aHeader.BeginReading(iter);
    1:     aHeader.EndReading(doneIterating);
    1: 
    1:     // skip leading whitespace
    1:     while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:         ++iter;
    1: 
    1:     tokenStart = iter;
    1: 
    1:     // skip leading + and -
    1:     if (iter != doneIterating && (*iter == '-' || *iter == '+'))
    1:         ++iter;
    1: 
    1:     // parse number
    1:     while (iter != doneIterating && (*iter >= '0' && *iter <= '9')) {
    1:         seconds = seconds * 10 + (*iter - '0');
    1:         specifiesSeconds = PR_TRUE;
    1:         ++iter;
    1:     }
    1: 
    1:     if (iter != doneIterating) {
    1:         // if we started with a '-', number is negative
    1:         if (*tokenStart == '-')
    1:             seconds = -seconds;
    1: 
    1:         // skip to next ';' or ','
    1:         nsACString::const_iterator iterAfterDigit = iter;
    1:         while (iter != doneIterating && !(*iter == ';' || *iter == ','))
    1:         {
    1:             if (specifiesSeconds)
    1:             {
    1:                 // Non-whitespace characters here mean that the string is
    1:                 // malformed but tolerate sites that specify a decimal point,
    1:                 // even though meta refresh only works on whole seconds.
    1:                 if (iter == iterAfterDigit &&
    1:                     !nsCRT::IsAsciiSpace(*iter) && *iter != '.')
    1:                 {
    1:                     // The characters between the seconds and the next
    1:                     // section are just garbage!
    1:                     //   e.g. content="2a0z+,URL=http://www.mozilla.org/"
    1:                     // Just ignore this redirect.
    1:                     return NS_ERROR_FAILURE;
    1:                 }
    1:                 else if (nsCRT::IsAsciiSpace(*iter))
    1:                 {
    1:                     // We've had at least one whitespace so tolerate the mistake
    1:                     // and drop through.
    1:                     // e.g. content="10 foo"
    1:                     ++iter;
    1:                     break;
    1:                 }
    1:             }
    1:             ++iter;
    1:         }
    1: 
    1:         // skip any remaining whitespace
    1:         while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:             ++iter;
    1: 
    1:         // skip ';' or ','
    1:         if (iter != doneIterating && (*iter == ';' || *iter == ',')) {
    1:             ++iter;
    1:         }
    1: 
    1:         // skip whitespace
    1:         while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:             ++iter;
    1:     }
    1: 
    1:     // possible start of URI
    1:     tokenStart = iter;
    1: 
    1:     // skip "url = " to real start of URI
    1:     if (iter != doneIterating && (*iter == 'u' || *iter == 'U')) {
    1:         ++iter;
    1:         if (iter != doneIterating && (*iter == 'r' || *iter == 'R')) {
    1:             ++iter;
    1:             if (iter != doneIterating && (*iter == 'l' || *iter == 'L')) {
    1:                 ++iter;
    1: 
    1:                 // skip whitespace
    1:                 while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:                     ++iter;
    1: 
    1:                 if (iter != doneIterating && *iter == '=') {
    1:                     ++iter;
    1: 
    1:                     // skip whitespace
    1:                     while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
    1:                         ++iter;
    1: 
    1:                     // found real start of URI
    1:                     tokenStart = iter;
    1:                 }
    1:             }
    1:         }
    1:     }
    1: 
    1:     // skip a leading '"' or '\''.
    1: 
79445:     bool isQuotedURI = false;
    1:     if (tokenStart != doneIterating && (*tokenStart == '"' || *tokenStart == '\''))
    1:     {
    1:         isQuotedURI = PR_TRUE;
    1:         ++tokenStart;
    1:     }
    1: 
    1:     // set iter to start of URI
    1:     iter = tokenStart;
    1: 
    1:     // tokenStart here points to the beginning of URI
    1: 
    1:     // grab the rest of the URI
    1:     while (iter != doneIterating)
    1:     {
    1:         if (isQuotedURI && (*iter == '"' || *iter == '\''))
    1:             break;
    1:         ++iter;
    1:     }
    1: 
    1:     // move iter one back if the last character is a '"' or '\''
    1:     if (iter != tokenStart && isQuotedURI) {
    1:         --iter;
    1:         if (!(*iter == '"' || *iter == '\''))
    1:             ++iter;
    1:     }
    1: 
    1:     // URI is whatever's contained from tokenStart to iter.
    1:     // note: if tokenStart == doneIterating, so is iter.
    1: 
    1:     nsresult rv = NS_OK;
    1: 
    1:     nsCOMPtr<nsIURI> uri;
79445:     bool specifiesURI = false;
    1:     if (tokenStart == iter) {
    1:         uri = aBaseURI;
    1:     }
    1:     else {
    1:         uriAttrib = Substring(tokenStart, iter);
    1:         // NS_NewURI takes care of any whitespace surrounding the URL
    1:         rv = NS_NewURI(getter_AddRefs(uri), uriAttrib, nsnull, aBaseURI);
    1:         specifiesURI = PR_TRUE;
    1:     }
    1: 
    1:     // No URI or seconds were specified
    1:     if (!specifiesSeconds && !specifiesURI)
    1:     {
    1:         // Do nothing because the alternative is to spin around in a refresh
    1:         // loop forever!
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:         nsCOMPtr<nsIScriptSecurityManager>
    1:             securityManager(do_GetService
    1:                             (NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             rv = securityManager->
    1:                 CheckLoadURI(aBaseURI, uri,
    1:                              nsIScriptSecurityManager::
    1:                              LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT);
25969: 
25969:             if (NS_SUCCEEDED(rv)) {
79445:                 bool isjs = true;
25969:                 rv = NS_URIChainHasFlags(uri,
25969:                   nsIProtocolHandler::URI_OPENING_EXECUTES_SCRIPT, &isjs);
25969:                 NS_ENSURE_SUCCESS(rv, rv);
25969: 
25969:                 if (isjs) {
25969:                     return NS_ERROR_FAILURE;
25969:                 }
25969:             }
25969: 
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 // Since we can't travel back in time yet, just pretend
    1:                 // negative numbers do nothing at all.
    1:                 if (seconds < 0)
    1:                     return NS_ERROR_FAILURE;
    1: 
    1:                 rv = RefreshURI(uri, seconds * 1000, PR_FALSE, PR_TRUE);
    1:             }
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::SetupRefreshURI(nsIChannel * aChannel)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel, &rv));
    1:     if (NS_SUCCEEDED(rv)) {
    1:         nsCAutoString refreshHeader;
    1:         rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("refresh"),
    1:                                             refreshHeader);
    1: 
    1:         if (!refreshHeader.IsEmpty()) {
    1:             SetupReferrerFromChannel(aChannel);
    1:             rv = SetupRefreshURIFromHeader(mCurrentURI, refreshHeader);
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 return NS_REFRESHURI_HEADER_FOUND;
    1:             }
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: static void
    1: DoCancelRefreshURITimers(nsISupportsArray* aTimerList)
    1: {
    1:     if (!aTimerList)
    1:         return;
    1: 
    1:     PRUint32 n=0;
    1:     aTimerList->Count(&n);
    1: 
    1:     while (n) {
    1:         nsCOMPtr<nsITimer> timer(do_QueryElementAt(aTimerList, --n));
    1: 
    1:         aTimerList->RemoveElementAt(n);    // bye bye owning timer ref
    1: 
    1:         if (timer)
    1:             timer->Cancel();        
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::CancelRefreshURITimers()
    1: {
    1:     DoCancelRefreshURITimers(mRefreshURIList);
    1:     DoCancelRefreshURITimers(mSavedRefreshURIList);
    1:     mRefreshURIList = nsnull;
    1:     mSavedRefreshURIList = nsnull;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetRefreshPending(bool* _retval)
    1: {
    1:     if (!mRefreshURIList) {
    1:         *_retval = PR_FALSE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     PRUint32 count;
    1:     nsresult rv = mRefreshURIList->Count(&count);
    1:     if (NS_SUCCEEDED(rv))
    1:         *_retval = (count != 0);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SuspendRefreshURIs()
    1: {
    1:     if (mRefreshURIList) {
    1:         PRUint32 n = 0;
    1:         mRefreshURIList->Count(&n);
    1: 
    1:         for (PRUint32 i = 0;  i < n; ++i) {
    1:             nsCOMPtr<nsITimer> timer = do_QueryElementAt(mRefreshURIList, i);
    1:             if (!timer)
    1:                 continue;  // this must be a nsRefreshURI already
    1: 
    1:             // Replace this timer object with a nsRefreshTimer object.
    1:             nsCOMPtr<nsITimerCallback> callback;
    1:             timer->GetCallback(getter_AddRefs(callback));
    1: 
    1:             timer->Cancel();
    1: 
    1:             nsCOMPtr<nsITimerCallback> rt = do_QueryInterface(callback);
    1:             NS_ASSERTION(rt, "RefreshURIList timer callbacks should only be RefreshTimer objects");
    1: 
    1:             mRefreshURIList->ReplaceElementAt(rt, i);
    1:         }
    1:     }
    1: 
    1:     // Suspend refresh URIs for our child shells as well.
29263:     PRInt32 n = mChildList.Count();
29263: 
29263:     for (PRInt32 i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
    1:         if (shell)
    1:             shell->SuspendRefreshURIs();
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::ResumeRefreshURIs()
    1: {
    1:     RefreshURIFromQueue();
    1: 
    1:     // Resume refresh URIs for our child shells as well.
29263:     PRInt32 n = mChildList.Count();
29263: 
29263:     for (PRInt32 i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
    1:         if (shell)
    1:             shell->ResumeRefreshURIs();
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::RefreshURIFromQueue()
    1: {
    1:     if (!mRefreshURIList)
    1:         return NS_OK;
    1:     PRUint32 n = 0;
    1:     mRefreshURIList->Count(&n);
    1: 
    1:     while (n) {
    1:         nsCOMPtr<nsISupports> element;
    1:         mRefreshURIList->GetElementAt(--n, getter_AddRefs(element));
    1:         nsCOMPtr<nsITimerCallback> refreshInfo(do_QueryInterface(element));
    1: 
    1:         if (refreshInfo) {   
    1:             // This is the nsRefreshTimer object, waiting to be
    1:             // setup in a timer object and fired.                         
    1:             // Create the timer and  trigger it.
 3233:             PRUint32 delay = static_cast<nsRefreshTimer*>(static_cast<nsITimerCallback*>(refreshInfo))->GetDelay();
    1:             nsCOMPtr<nsITimer> timer = do_CreateInstance("@mozilla.org/timer;1");
    1:             if (timer) {    
    1:                 // Replace the nsRefreshTimer element in the queue with
    1:                 // its corresponding timer object, so that in case another
    1:                 // load comes through before the timer can go off, the timer will
    1:                 // get cancelled in CancelRefreshURITimer()
    1:                 mRefreshURIList->ReplaceElementAt(timer, n);
    1:                 timer->InitWithCallback(refreshInfo, delay, nsITimer::TYPE_ONE_SHOT);
    1:             }           
    1:         }        
    1:     }  // while
    1:  
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIContentViewerContainer
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Embed(nsIContentViewer * aContentViewer,
    1:                   const char *aCommand, nsISupports * aExtraInfo)
    1: {
    1:     // Save the LayoutHistoryState of the previous document, before
    1:     // setting up new document
    1:     PersistLayoutHistoryState();
    1: 
    1:     nsresult rv = SetupNewViewer(aContentViewer);
    1: 
    1:     // If we are loading a wyciwyg url from history, change the base URI for 
    1:     // the document to the original http url that created the document.write().
    1:     // This makes sure that all relative urls in a document.written page loaded
    1:     // via history work properly.
    1:     if (mCurrentURI &&
    1:        (mLoadType & LOAD_CMD_HISTORY ||
    1:         mLoadType == LOAD_RELOAD_NORMAL ||
    1:         mLoadType == LOAD_RELOAD_CHARSET_CHANGE)){
79445:         bool isWyciwyg = false;
    1:         // Check if the url is wyciwyg
    1:         rv = mCurrentURI->SchemeIs("wyciwyg", &isWyciwyg);      
    1:         if (isWyciwyg && NS_SUCCEEDED(rv))
    1:             SetBaseUrlForWyciwyg(aContentViewer);
    1:     }
    1:     // XXX What if SetupNewViewer fails?
14887:     if (mLSHE) {
14887:         // Restore the editing state, if it's stored in session history.
14887:         if (mLSHE->HasDetachedEditor()) {
14887:             ReattachEditorToWindow(mLSHE);
14887:         }
63196:         // Set history.state
63196:         SetDocCurrentStateObj(mLSHE);
63196: 
    1:         SetHistoryEntry(&mOSHE, mLSHE);
14887:     }
    1: 
79445:     bool updateHistory = true;
    1: 
    1:     // Determine if this type of load should update history
    1:     switch (mLoadType) {
    1:     case LOAD_NORMAL_REPLACE:
    1:     case LOAD_STOP_CONTENT_AND_REPLACE:
    1:     case LOAD_RELOAD_BYPASS_CACHE:
    1:     case LOAD_RELOAD_BYPASS_PROXY:
    1:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
    1:         updateHistory = PR_FALSE;
    1:         break;
    1:     default:
    1:         break;
    1:     }
    1: 
    1:     if (!updateHistory)
    1:         SetLayoutHistoryState(nsnull);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* void setIsPrinting (in boolean aIsPrinting); */
    1: NS_IMETHODIMP 
79445: nsDocShell::SetIsPrinting(bool aIsPrinting)
    1: {
    1:     mIsPrintingOrPP = aIsPrinting;
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIWebProgressListener
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnProgressChange(nsIWebProgress * aProgress,
    1:                              nsIRequest * aRequest,
    1:                              PRInt32 aCurSelfProgress,
    1:                              PRInt32 aMaxSelfProgress,
    1:                              PRInt32 aCurTotalProgress,
    1:                              PRInt32 aMaxTotalProgress)
    1: {
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnStateChange(nsIWebProgress * aProgress, nsIRequest * aRequest,
    1:                           PRUint32 aStateFlags, nsresult aStatus)
    1: {
    1:     nsresult rv;
    1: 
    1:     if ((~aStateFlags & (STATE_START | STATE_IS_NETWORK)) == 0) {
72298:         // Save timing statistics.
72298:         nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
72298:         nsCOMPtr<nsIURI> uri;
72298:         channel->GetURI(getter_AddRefs(uri));
72298:         nsCAutoString aURI;
72298:         uri->GetAsciiSpec(aURI);
72298:         // If load type is not set, this is not a 'normal' load.
72298:         // No need to collect timing.
72298:         if (mLoadType == 0) {
72298:           mTiming = nsnull;
72298:         }
72298:         else {
72298:           rv = MaybeInitTiming();
72298:         }
72298:         if (mTiming) {
72298:           mTiming->NotifyFetchStart(uri, ConvertLoadTypeToNavigationType(mLoadType));
72298:         }
72298: 
    1:         nsCOMPtr<nsIWyciwygChannel>  wcwgChannel(do_QueryInterface(aRequest));
    1:         nsCOMPtr<nsIWebProgress> webProgress =
    1:             do_QueryInterface(GetAsSupports(this));
    1: 
    1:         // Was the wyciwyg document loaded on this docshell?
    1:         if (wcwgChannel && !mLSHE && (mItemType == typeContent) && aProgress == webProgress.get()) {
79445:             bool equalUri = true;
    1:             // Store the wyciwyg url in session history, only if it is
    1:             // being loaded fresh for the first time. We don't want 
    1:             // multiple entries for successive loads
    1:             if (mCurrentURI &&
    1:                 NS_SUCCEEDED(uri->Equals(mCurrentURI, &equalUri)) &&
    1:                 !equalUri) {
50721: 
50721:                 nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
50721:                 GetSameTypeParent(getter_AddRefs(parentAsItem));
50721:                 nsCOMPtr<nsIDocShell> parentDS(do_QueryInterface(parentAsItem));
79445:                 bool inOnLoadHandler = false;
50721:                 if (parentDS) {
50721:                   parentDS->GetIsExecutingOnLoadHandler(&inOnLoadHandler);
50721:                 }
50721:                 if (inOnLoadHandler) {
50721:                     // We're handling parent's load event listener, which causes
50721:                     // document.write in a subdocument.
50721:                     // Need to clear the session history for all child
50721:                     // docshells so that we can handle them like they would
50721:                     // all be added dynamically.
50721:                     nsCOMPtr<nsIDocShellHistory> parent =
50721:                         do_QueryInterface(parentAsItem);
50721:                     if (parent) {
79445:                         bool oshe = false;
50721:                         nsCOMPtr<nsISHEntry> entry;
50721:                         parent->GetCurrentSHEntry(getter_AddRefs(entry), &oshe);
50721:                         static_cast<nsDocShell*>(parent.get())->
50721:                             ClearFrameHistory(entry);
50721:                     }
50721:                 }
50721: 
    1:                 // This is a document.write(). Get the made-up url
    1:                 // from the channel and store it in session history.
64491:                 // Pass false for aCloneChildren, since we're creating
64491:                 // a new DOM here.
64491:                 rv = AddToSessionHistory(uri, wcwgChannel, nsnull, PR_FALSE,
22687:                                          getter_AddRefs(mLSHE));
71723:                 SetCurrentURI(uri, aRequest, PR_TRUE);
    1:                 // Save history state of the previous page
    1:                 rv = PersistLayoutHistoryState();
24072:                 // We'll never get an Embed() for this load, so just go ahead
24072:                 // and SetHistoryEntry now.
    1:                 SetHistoryEntry(&mOSHE, mLSHE);
    1:             }
    1:         
    1:         }
    1:         // Page has begun to load
    1:         mBusyFlags = BUSY_FLAGS_BUSY | BUSY_FLAGS_BEFORE_PAGE_LOAD;
32813: 
32819:         if ((aStateFlags & STATE_RESTORING) == 0) {
32813:             // Show the progress cursor if the pref is set
79445:             if (Preferences::GetBool("ui.use_activity_cursor", false)) {
32813:                 nsCOMPtr<nsIWidget> mainWidget;
32813:                 GetMainWidget(getter_AddRefs(mainWidget));
32813:                 if (mainWidget) {
32813:                     mainWidget->SetCursor(eCursor_spinning);
32813:                 }
32813:             }
    1:         }
32819:     }
    1:     else if ((~aStateFlags & (STATE_TRANSFERRING | STATE_IS_DOCUMENT)) == 0) {
    1:         // Page is loading
    1:         mBusyFlags = BUSY_FLAGS_BUSY | BUSY_FLAGS_PAGE_LOADING;
    1:     }
    1:     else if ((aStateFlags & STATE_STOP) && (aStateFlags & STATE_IS_NETWORK)) {
    1:         // Page has finished loading
    1:         mBusyFlags = BUSY_FLAGS_NONE;
32813: 
32813:         // Hide the progress cursor if the pref is set
79445:         if (Preferences::GetBool("ui.use_activity_cursor", false)) {
32813:             nsCOMPtr<nsIWidget> mainWidget;
32813:             GetMainWidget(getter_AddRefs(mainWidget));
32813:             if (mainWidget) {
32813:                 mainWidget->SetCursor(eCursor_standard);
32813:             }
32813:         }
    1:     }
    1:     if ((~aStateFlags & (STATE_IS_DOCUMENT | STATE_STOP)) == 0) {
    1:         nsCOMPtr<nsIWebProgress> webProgress =
    1:             do_QueryInterface(GetAsSupports(this));
    1:         // Is the document stop notification for this document?
    1:         if (aProgress == webProgress.get()) {
    1:             nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
    1:             EndPageLoad(aProgress, channel, aStatus);
    1:         }
    1:     }
    1:     // note that redirect state changes will go through here as well, but it
    1:     // is better to handle those in OnRedirectStateChange where more
    1:     // information is available.
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnLocationChange(nsIWebProgress * aProgress,
    1:                              nsIRequest * aRequest, nsIURI * aURI)
    1: {
    1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:     return NS_OK;
    1: }
    1: 
54823: void
    1: nsDocShell::OnRedirectStateChange(nsIChannel* aOldChannel,
    1:                                   nsIChannel* aNewChannel,
    1:                                   PRUint32 aRedirectFlags,
    1:                                   PRUint32 aStateFlags)
    1: {
    1:     NS_ASSERTION(aStateFlags & STATE_REDIRECTING,
    1:                  "Calling OnRedirectStateChange when there is no redirect");
    1:     if (!(aStateFlags & STATE_IS_DOCUMENT))
54823:         return; // not a toplevel document
    1: 
47715:     nsCOMPtr<nsIURI> oldURI, newURI;
    1:     aOldChannel->GetURI(getter_AddRefs(oldURI));
47715:     aNewChannel->GetURI(getter_AddRefs(newURI));
47715:     if (!oldURI || !newURI) {
54823:         return;
47715:     }
72298:     // On session restore we get a redirect from page to itself. Don't count it.
79445:     bool equals = false;
72298:     if (mTiming &&
72298:         !(mLoadType == LOAD_HISTORY &&
72298:           NS_SUCCEEDED(newURI->Equals(oldURI, &equals)) && equals)) {
72298:         mTiming->NotifyRedirect(oldURI, newURI);
72298:     }
47715: 
47715:     // Below a URI visit is saved (see AddURIVisit method doc).
47715:     // The visit chain looks something like:
47715:     //   ...
47715:     //   Site N - 1
47715:     //                =>  Site N
47715:     //   (redirect to =>) Site N + 1 (we are here!)
47715: 
47715:     // Get N - 1 and transition type
47715:     nsCOMPtr<nsIURI> previousURI;
47715:     PRUint32 previousFlags = 0;
47715:     ExtractLastVisit(aOldChannel, getter_AddRefs(previousURI), &previousFlags);
47715: 
47715:     if (aRedirectFlags & nsIChannelEventSink::REDIRECT_INTERNAL ||
47715:         ChannelIsPost(aOldChannel)) {
47715:         // 1. Internal redirects are ignored because they are specific to the
47715:         //    channel implementation.
47715:         // 2. POSTs are not saved by global history.
47715:         //
47715:         // Regardless, we need to propagate the previous visit to the new
47715:         // channel.
47715:         SaveLastVisit(aNewChannel, previousURI, previousFlags);
47715:     }
47715:     else {
47715:         nsCOMPtr<nsIURI> referrer;
47715:         // Treat referrer as null if there is an error getting it.
47715:         (void)NS_GetReferrerFromChannel(aOldChannel,
47715:                                         getter_AddRefs(referrer));
47715: 
47715:         // Add visit N -1 => N
47715:         AddURIVisit(oldURI, referrer, previousURI, previousFlags);
47715: 
47715:         // Since N + 1 could be the final destination, we will not save N => N + 1
47715:         // here.  OnNewURI will do that, so we will cache it.
47715:         SaveLastVisit(aNewChannel, oldURI, aRedirectFlags);
    1:     }
21311: 
21311:     // check if the new load should go through the application cache.
21311:     nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
21311:         do_QueryInterface(aNewChannel);
21311:     if (appCacheChannel) {
56242:         // Permission will be checked in the parent process.
56242:         if (GeckoProcessType_Default != XRE_GetProcessType())
56242:             appCacheChannel->SetChooseApplicationCache(PR_TRUE);
56242:         else
21311:             appCacheChannel->SetChooseApplicationCache(ShouldCheckAppCache(newURI));
21311:     }
42150: 
42150:     if (!(aRedirectFlags & nsIChannelEventSink::REDIRECT_INTERNAL) && 
42150:         mLoadType & (LOAD_CMD_RELOAD | LOAD_CMD_HISTORY)) {
42150:         mLoadType = LOAD_NORMAL_REPLACE;
42150:         SetHistoryEntry(&mLSHE, nsnull);
42150:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnStatusChange(nsIWebProgress * aWebProgress,
    1:                            nsIRequest * aRequest,
    1:                            nsresult aStatus, const PRUnichar * aMessage)
    1: {
    1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::OnSecurityChange(nsIWebProgress * aWebProgress,
    1:                              nsIRequest * aRequest, PRUint32 state)
    1: {
    1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsDocShell::EndPageLoad(nsIWebProgress * aProgress,
    1:                         nsIChannel * aChannel, nsresult aStatus)
    1: {
28078:     if(!aChannel)
28078:         return NS_ERROR_NULL_POINTER;
28078:     
28078:     nsCOMPtr<nsIURI> url;
28078:     nsresult rv = aChannel->GetURI(getter_AddRefs(url));
28078:     if (NS_FAILED(rv)) return rv;
28078: 
72924:     nsCOMPtr<nsITimedChannel> timingChannel =
72924:         do_QueryInterface(aChannel);
72924:     if (timingChannel) {
72924:         TimeStamp channelCreationTime;
72924:         rv = timingChannel->GetChannelCreation(&channelCreationTime);
72924:         if (NS_SUCCEEDED(rv) && !channelCreationTime.IsNull()) {
72924:             PRUint32 interval = (PRUint32)
72924:                 (TimeStamp::Now() - channelCreationTime)
72924:                 .ToMilliseconds();
72924:             Telemetry::Accumulate(Telemetry::TOTAL_CONTENT_PAGE_LOAD_TIME, 
72924:                                   interval);
72924:         }
72924:     }
72924: 
72298:     // Timing is picked up by the window, we don't need it anymore
72298:     mTiming = nsnull;
72298: 
28078:     // clean up reload state for meta charset
28078:     if (eCharsetReloadRequested == mCharsetReloadState)
28078:         mCharsetReloadState = eCharsetReloadStopOrigional;
28078:     else 
28078:         mCharsetReloadState = eCharsetReloadInit;
28078: 
28078:     // Save a pointer to the currently-loading history entry.
28078:     // nsDocShell::EndPageLoad will clear mLSHE, but we may need this history
28078:     // entry further down in this method.
28078:     nsCOMPtr<nsISHEntry> loadingSHE = mLSHE;
28078:   
    1:     //
    1:     // one of many safeguards that prevent death and destruction if
    1:     // someone is so very very rude as to bring this window down
    1:     // during this load handler.
    1:     //
    1:     nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
 5528: 
37802:     // Notify the ContentViewer that the Document has finished loading.  This
37802:     // will cause any OnLoad(...) and PopState(...) handlers to fire.
    1:     if (!mEODForCurrentDocument && mContentViewer) {
    1:         mIsExecutingOnLoadHandler = PR_TRUE;
63195:         mContentViewer->LoadComplete(aStatus);
    1:         mIsExecutingOnLoadHandler = PR_FALSE;
    1: 
    1:         mEODForCurrentDocument = PR_TRUE;
    1: 
    1:         // If all documents have completed their loading
    1:         // favor native event dispatch priorities
    1:         // over performance
    1:         if (--gNumberOfDocumentsLoading == 0) {
    1:           // Hint to use normal native event dispatch priorities 
    1:           FavorPerformanceHint(PR_FALSE, NS_EVENT_STARVATION_DELAY_HINT);
    1:         }
    1:     }
    1:     /* Check if the httpChannel has any cache-control related response headers,
    1:      * like no-store, no-cache. If so, update SHEntry so that 
    1:      * when a user goes back/forward to this page, we appropriately do 
    1:      * form value restoration or load from server.
    1:      */
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1:     if (!httpChannel) // HttpChannel could be hiding underneath a Multipart channel.    
    1:         GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
    1: 
    1:     if (httpChannel) {
    1:         // figure out if SH should be saving layout state.
79445:         bool discardLayoutState = ShouldDiscardLayoutState(httpChannel);       
    1:         if (mLSHE && discardLayoutState && (mLoadType & LOAD_CMD_NORMAL) &&
    1:             (mLoadType != LOAD_BYPASS_HISTORY) && (mLoadType != LOAD_ERROR_PAGE))
    1:             mLSHE->SetSaveLayoutStateFlag(PR_FALSE);            
    1:     }
    1: 
    1:     // Clear mLSHE after calling the onLoadHandlers. This way, if the
    1:     // onLoadHandler tries to load something different in
    1:     // itself or one of its children, we can deal with it appropriately.
    1:     if (mLSHE) {
    1:         mLSHE->SetLoadType(nsIDocShellLoadInfo::loadHistory);
    1: 
    1:         // Clear the mLSHE reference to indicate document loading is done one
    1:         // way or another.
    1:         SetHistoryEntry(&mLSHE, nsnull);
    1:     }
    1:     // if there's a refresh header in the channel, this method
    1:     // will set it up for us. 
    1:     RefreshURIFromQueue();
    1: 
28078:     // Test whether this is the top frame or a subframe
79445:     bool isTopFrame = true;
28078:     nsCOMPtr<nsIDocShellTreeItem> targetParentTreeItem;
28078:     rv = GetSameTypeParent(getter_AddRefs(targetParentTreeItem));
28078:     if (NS_SUCCEEDED(rv) && targetParentTreeItem) {
28078:         isTopFrame = PR_FALSE;
28078:     }
28078: 
28078:     //
28078:     // If the page load failed, then deal with the error condition...
28078:     // Errors are handled as follows:
28078:     //   1. Check to see if it's a file not found error or bad content
28078:     //      encoding error.
28078:     //   2. Send the URI to a keyword server (if enabled)
28078:     //   3. If the error was DNS failure, then add www and .com to the URI
28078:     //      (if appropriate).
28078:     //   4. Throw an error dialog box...
28078:     //
28078:     if (url && NS_FAILED(aStatus)) {
28078:         if (aStatus == NS_ERROR_FILE_NOT_FOUND ||
71421:             aStatus == NS_ERROR_CORRUPTED_CONTENT ||
28078:             aStatus == NS_ERROR_INVALID_CONTENT_ENCODING) {
28078:             DisplayLoadError(aStatus, url, nsnull, aChannel);
28078:             return NS_OK;
28078:         }
28078: 
28078:         if (sURIFixup) {
28078:             //
28078:             // Try and make an alternative URI from the old one
28078:             //
28078:             nsCOMPtr<nsIURI> newURI;
28078: 
28078:             nsCAutoString oldSpec;
28078:             url->GetSpec(oldSpec);
28078:       
28078:             //
28078:             // First try keyword fixup
28078:             //
28078:             if (aStatus == NS_ERROR_UNKNOWN_HOST && mAllowKeywordFixup) {
79445:                 bool keywordsEnabled =
79445:                     Preferences::GetBool("keyword.enabled", false);
28078: 
28078:                 nsCAutoString host;
28078:                 url->GetHost(host);
28078: 
28078:                 nsCAutoString scheme;
28078:                 url->GetScheme(scheme);
28078: 
28078:                 PRInt32 dotLoc = host.FindChar('.');
28078: 
28078:                 // we should only perform a keyword search under the following
28078:                 // conditions:
28078:                 // (0) Pref keyword.enabled is true
28078:                 // (1) the url scheme is http (or https)
28078:                 // (2) the url does not have a protocol scheme
28078:                 // If we don't enforce such a policy, then we end up doing
28078:                 // keyword searchs on urls we don't intend like imap, file,
28078:                 // mailbox, etc. This could lead to a security problem where we
28078:                 // send data to the keyword server that we shouldn't be.
28078:                 // Someone needs to clean up keywords in general so we can
28078:                 // determine on a per url basis if we want keywords
28078:                 // enabled...this is just a bandaid...
28078:                 if (keywordsEnabled && !scheme.IsEmpty() &&
28078:                     (scheme.Find("http") != 0)) {
28078:                     keywordsEnabled = PR_FALSE;
28078:                 }
28078: 
28078:                 if (keywordsEnabled && (kNotFound == dotLoc)) {
28078:                     // only send non-qualified hosts to the keyword server
28078:                     //
28078:                     // If this string was passed through nsStandardURL by
28078:                     // chance, then it may have been converted from UTF-8 to
28078:                     // ACE, which would result in a completely bogus keyword
28078:                     // query.  Here we try to recover the original Unicode
28078:                     // value, but this is not 100% correct since the value may
28078:                     // have been normalized per the IDN normalization rules.
28078:                     //
28078:                     // Since we don't have access to the exact original string
28078:                     // that was entered by the user, this will just have to do.
79445:                     bool isACE;
28078:                     nsCAutoString utf8Host;
28078:                     nsCOMPtr<nsIIDNService> idnSrv =
28078:                         do_GetService(NS_IDNSERVICE_CONTRACTID);
28078:                     if (idnSrv &&
28078:                         NS_SUCCEEDED(idnSrv->IsACE(host, &isACE)) && isACE &&
28078:                         NS_SUCCEEDED(idnSrv->ConvertACEtoUTF8(host, utf8Host)))
28078:                         sURIFixup->KeywordToURI(utf8Host,
28078:                                                 getter_AddRefs(newURI));
28078:                     else
28078:                         sURIFixup->KeywordToURI(host, getter_AddRefs(newURI));
28078:                 } // end keywordsEnabled
28078:             }
28078: 
28078:             //
28078:             // Now try change the address, e.g. turn http://foo into
28078:             // http://www.foo.com
28078:             //
28078:             if (aStatus == NS_ERROR_UNKNOWN_HOST ||
28078:                 aStatus == NS_ERROR_NET_RESET) {
79445:                 bool doCreateAlternate = true;
28078: 
28078:                 // Skip fixup for anything except a normal document load
28078:                 // operation on the topframe.
28078:         
28078:                 if (mLoadType != LOAD_NORMAL || !isTopFrame) {
28078:                     doCreateAlternate = PR_FALSE;
28078:                 }
28078:                 else {
28078:                     // Test if keyword lookup produced a new URI or not
28078:                     if (newURI) {
79445:                         bool sameURI = false;
28078:                         url->Equals(newURI, &sameURI);
28078:                         if (!sameURI) {
28078:                             // Keyword lookup made a new URI so no need to try
28078:                             // an alternate one.
28078:                             doCreateAlternate = PR_FALSE;
28078:                         }
28078:                     }
28078:                 }
28078:                 if (doCreateAlternate) {
28078:                     newURI = nsnull;
28078:                     sURIFixup->CreateFixupURI(oldSpec,
28078:                       nsIURIFixup::FIXUP_FLAGS_MAKE_ALTERNATE_URI,
28078:                                               getter_AddRefs(newURI));
28078:                 }
28078:             }
28078: 
28078:             // Did we make a new URI that is different to the old one? If so
28078:             // load it.
28078:             //
28078:             if (newURI) {
28078:                 // Make sure the new URI is different from the old one,
28078:                 // otherwise there's little point trying to load it again.
79445:                 bool sameURI = false;
28078:                 url->Equals(newURI, &sameURI);
28078:                 if (!sameURI) {
28078:                     nsCAutoString newSpec;
28078:                     newURI->GetSpec(newSpec);
28078:                     NS_ConvertUTF8toUTF16 newSpecW(newSpec);
28078: 
28078:                     return LoadURI(newSpecW.get(),  // URI string
28078:                                    LOAD_FLAGS_NONE, // Load flags
28078:                                    nsnull,          // Referring URI
28078:                                    nsnull,          // Post data stream
28078:                                    nsnull);         // Headers stream
28078:                 }
28078:             }
28078:         }
28078: 
28078:         // Well, fixup didn't work :-(
28078:         // It is time to throw an error dialog box, and be done with it...
28078: 
28078:         // Errors to be shown only on top-level frames
28078:         if ((aStatus == NS_ERROR_UNKNOWN_HOST || 
28078:              aStatus == NS_ERROR_CONNECTION_REFUSED ||
28078:              aStatus == NS_ERROR_UNKNOWN_PROXY_HOST || 
28078:              aStatus == NS_ERROR_PROXY_CONNECTION_REFUSED) &&
28078:             (isTopFrame || mUseErrorPages)) {
28078:             DisplayLoadError(aStatus, url, nsnull, aChannel);
28078:         }
28078:         // Errors to be shown for any frame
28078:         else if (aStatus == NS_ERROR_NET_TIMEOUT ||
28078:                  aStatus == NS_ERROR_REDIRECT_LOOP ||
28078:                  aStatus == NS_ERROR_UNKNOWN_SOCKET_TYPE ||
28078:                  aStatus == NS_ERROR_NET_INTERRUPT ||
28078:                  aStatus == NS_ERROR_NET_RESET ||
71902:                  aStatus == NS_ERROR_OFFLINE ||
28078:                  aStatus == NS_ERROR_MALWARE_URI ||
28078:                  aStatus == NS_ERROR_PHISHING_URI ||
28078:                  aStatus == NS_ERROR_UNSAFE_CONTENT_TYPE ||
60516:                  aStatus == NS_ERROR_REMOTE_XUL ||
28078:                  NS_ERROR_GET_MODULE(aStatus) == NS_ERROR_MODULE_SECURITY) {
28078:             DisplayLoadError(aStatus, url, nsnull, aChannel);
28078:         }
28078:         else if (aStatus == NS_ERROR_DOCUMENT_NOT_CACHED) {
28078:             /* A document that was requested to be fetched *only* from
28078:              * the cache is not in cache. May be this is one of those 
28078:              * postdata results. Throw a  dialog to the user,
28078:              * saying that the page has expired from cache and ask if 
28078:              * they wish to refetch the page from the net. Do this only
28078:              * if the request is a form post.
28078:              */
28078:             nsCAutoString method;
28078:             if (httpChannel)
28078:                 httpChannel->GetRequestMethod(method);
28078:             if (method.Equals("POST") && !NS_IsOffline()) {
79445:                 bool repost;
28078:                 rv = ConfirmRepost(&repost);
28078:                 if (NS_FAILED(rv)) return rv;
28078:                 // If the user pressed cancel in the dialog, return. Don't try
28078:                 // to load the page without the post data.
28078:                 if (!repost)
28078:                     return NS_OK;
28078: 
28078:                 // The user wants to repost the data to the server.
28078:                 // If the page was loaded due to a back/forward/go
28078:                 // operation, update the session history index.
28078:                 // This is similar to the updating done in
28078:                 // nsDocShell::OnNewURI() for regular pages
28078:                 nsCOMPtr<nsISHistory> rootSH=mSessionHistory;
28078:                 if (!mSessionHistory) {
28078:                     nsCOMPtr<nsIDocShellTreeItem> root;
28078:                     //Get the root docshell
28078:                     GetSameTypeRootTreeItem(getter_AddRefs(root));
28078:                     if (root) {
28078:                         // QI root to nsIWebNavigation
28078:                         nsCOMPtr<nsIWebNavigation> rootAsWebnav =
28078:                             do_QueryInterface(root);
28078:                         if (rootAsWebnav) {
28078:                             // Get the handle to SH from the root docshell
28078:                             rootAsWebnav->GetSessionHistory(getter_AddRefs(rootSH));
28078:                         }
28078:                     }
28078:                 }  // mSessionHistory
28078: 
28078:                 if (rootSH && (mLoadType & LOAD_CMD_HISTORY)) {
28078:                     nsCOMPtr<nsISHistoryInternal> shInternal =
28078:                         do_QueryInterface(rootSH);
28078:                     if (shInternal) {
28078:                         rootSH->GetIndex(&mPreviousTransIndex);
28078:                         shInternal->UpdateIndex();
28078:                         rootSH->GetIndex(&mLoadedTransIndex);
28078: #ifdef DEBUG_PAGE_CACHE
28078:                         printf("Previous index: %d, Loaded index: %d\n\n",
28078:                                mPreviousTransIndex, mLoadedTransIndex);
28078: #endif
28078:                     }
28078:                 }
28078: 
28078:                 // Make it look like we really did honestly finish loading the
28078:                 // history page we were loading, since the "reload" load we're
28078:                 // about to kick off will reload our current history entry.
28078:                 // This is a bit of a hack, and if the force-load fails I think
28078:                 // we'll end up being confused about what page we're on... but
28078:                 // we would anyway, since we've updated the session history
28078:                 // index above.
28078:                 SetHistoryEntry(&mOSHE, loadingSHE);
28078: 
28078:                 // The user does want to repost the data to the server.
28078:                 // Initiate a new load again.
28078: 
28078:                 // Get the postdata if any from the channel.
28078:                 nsCOMPtr<nsIInputStream> inputStream;
28078:                 nsCOMPtr<nsIURI> referrer;
28078:                 if (httpChannel) {
28078:                     httpChannel->GetReferrer(getter_AddRefs(referrer));
28078:                     nsCOMPtr<nsIUploadChannel> uploadChannel =
28078:                         do_QueryInterface(aChannel);
28078:                     if (uploadChannel) {
28078:                         uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
28078:                     }
28078:                 }
28078:                 nsCOMPtr<nsISeekableStream> postDataSeekable =
28078:                     do_QueryInterface(inputStream);
28078:                 if (postDataSeekable) {
28078:                     postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
28078:                 }
28078:                 InternalLoad(url,                               // URI
28078:                              referrer,                          // Referring URI
28078:                              nsnull,                            // Owner
28078:                              INTERNAL_LOAD_FLAGS_INHERIT_OWNER, // Inherit owner
28078:                              nsnull,                            // No window target
28078:                              nsnull,                            // No type hint
28078:                              inputStream,                       // Post data stream
28078:                              nsnull,                            // No headers stream
28078:                              LOAD_RELOAD_BYPASS_PROXY_AND_CACHE,// Load type
28078:                              nsnull,                            // No SHEntry
28078:                              PR_TRUE,                           // first party site
28078:                              nsnull,                            // No nsIDocShell
54823:                              nsnull);                           // No nsIRequest
28078:             }
28078:             else {
28078:                 DisplayLoadError(aStatus, url, nsnull, aChannel);
28078:             }
28078:         }
28078:   } // if we have a host
28078: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: Content Viewer Management
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::EnsureContentViewer()
    1: {
    1:     if (mContentViewer)
    1:         return NS_OK;
    1:     if (mIsBeingDestroyed)
    1:         return NS_ERROR_FAILURE;
    1: 
41653:     NS_TIME_FUNCTION;
41653: 
    1:     nsIPrincipal* principal = nsnull;
27151:     nsCOMPtr<nsIURI> baseURI;
    1: 
    1:     nsCOMPtr<nsPIDOMWindow> piDOMWindow(do_QueryInterface(mScriptGlobal));
    1:     if (piDOMWindow) {
    1:         principal = piDOMWindow->GetOpenerScriptPrincipal();
    1:     }
    1: 
    1:     if (!principal) {
    1:         principal = GetInheritedPrincipal(PR_FALSE);
27151:         nsCOMPtr<nsIDocShellTreeItem> parentItem;
27151:         GetSameTypeParent(getter_AddRefs(parentItem));
27151:         if (parentItem) {
27151:             nsCOMPtr<nsPIDOMWindow> domWin = do_GetInterface(GetAsSupports(this));
27151:             if (domWin) {
27151:                 nsCOMPtr<nsIContent> parentContent =
27151:                     do_QueryInterface(domWin->GetFrameElementInternal());
27151:                 if (parentContent) {
27151:                     baseURI = parentContent->GetBaseURI();
27151:                 }
27151:             }
27151:         }
27151:     }
27151: 
27151:     nsresult rv = CreateAboutBlankContentViewer(principal, baseURI);
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
48097:         nsCOMPtr<nsIDocument> doc(do_GetInterface(GetAsSupports(this)));
    1:         NS_ASSERTION(doc,
    1:                      "Should have doc if CreateAboutBlankContentViewer "
    1:                      "succeeded!");
    1: 
    1:         doc->SetIsInitialDocument(PR_TRUE);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
27151: nsDocShell::CreateAboutBlankContentViewer(nsIPrincipal* aPrincipal,
60827:                                           nsIURI* aBaseURI,
79445:                                           bool aTryToSaveOldPresentation)
    1: {
    1:   nsCOMPtr<nsIDocument> blankDoc;
    1:   nsCOMPtr<nsIContentViewer> viewer;
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   /* mCreatingDocument should never be true at this point. However, it's
    1:      a theoretical possibility. We want to know about it and make it stop,
    1:      and this sounds like a job for an assertion. */
    1:   NS_ASSERTION(!mCreatingDocument, "infinite(?) loop creating document averted");
    1:   if (mCreatingDocument)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   mCreatingDocument = PR_TRUE;
    1: 
    1:   // mContentViewer->PermitUnload may release |this| docshell.
    1:   nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
    1:   
    1:   if (mContentViewer) {
    1:     // We've got a content viewer already. Make sure the user
    1:     // permits us to discard the current document and replace it
    1:     // with about:blank. And also ensure we fire the unload events
    1:     // in the current document.
    1: 
72298:     // Make sure timing is created. Unload gets fired first for
72298:     // document loaded from the session history.
72298:     rv = MaybeInitTiming();
72298:     if (mTiming) {
72298:       mTiming->NotifyBeforeUnload();
72298:     }
72298: 
79445:     bool okToUnload;
34032:     rv = mContentViewer->PermitUnload(PR_FALSE, &okToUnload);
    1: 
    1:     if (NS_SUCCEEDED(rv) && !okToUnload) {
    1:       // The user chose not to unload the page, interrupt the load.
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
60827:     mSavingOldViewer = aTryToSaveOldPresentation && 
60827:                        CanSavePresentation(LOAD_NORMAL, nsnull, nsnull);
    1: 
72298:     if (mTiming) {
72298:       mTiming->NotifyUnloadAccepted(mCurrentURI);
72298:     }
72298: 
10676:     // Make sure to blow away our mLoadingURI just in case.  No loads
10676:     // from inside this pagehide.
10676:     mLoadingURI = nsnull;
10676:     
69789:     // Stop any in-progress loading, so that we don't accidentally trigger any
69789:     // PageShow notifications from Embed() interrupting our loading below.
69789:     Stop();
69789: 
    1:     // Notify the current document that it is about to be unloaded!!
    1:     //
    1:     // It is important to fire the unload() notification *before* any state
    1:     // is changed within the DocShell - otherwise, javascript will get the
    1:     // wrong information :-(
    1:     //
    1:     (void) FirePageHideNotification(!mSavingOldViewer);
    1:   }
    1: 
 5212:   // Now make sure we don't think we're in the middle of firing unload after
 5212:   // this point.  This will make us fire unload when the about:blank document
 5212:   // unloads... but that's ok, more or less.  Would be nice if it fired load
 5212:   // too, of course.
 5212:   mFiredUnloadEvent = PR_FALSE;
 5212: 
68796:   nsCOMPtr<nsIDocumentLoaderFactory> docFactory =
68796:       nsContentUtils::FindInternalContentViewer("text/html");
68796: 
    1:   if (docFactory) {
    1:     // generate (about:blank) document to load
    1:     docFactory->CreateBlankDocument(mLoadGroup, aPrincipal,
    1:                                     getter_AddRefs(blankDoc));
    1:     if (blankDoc) {
27151:       // Hack: set the base URI manually, since this document never
27151:       // got Reset() with a channel.
27151:       blankDoc->SetBaseURI(aBaseURI);
27151: 
 3233:       blankDoc->SetContainer(static_cast<nsIDocShell *>(this));
    1: 
    1:       // create a content viewer for us and the new document
    1:       docFactory->CreateInstanceForDocument(NS_ISUPPORTS_CAST(nsIDocShell *, this),
    1:                     blankDoc, "view", getter_AddRefs(viewer));
    1: 
    1:       // hook 'em up
    1:       if (viewer) {
 3233:         viewer->SetContainer(static_cast<nsIContentViewerContainer *>(this));
    1:         Embed(viewer, "", 0);
    1: 
71723:         SetCurrentURI(blankDoc->GetDocumentURI(), nsnull, PR_TRUE);
36505:         rv = mIsBeingDestroyed ? NS_ERROR_NOT_AVAILABLE : NS_OK;
    1:       }
    1:     }
    1:   }
    1:   mCreatingDocument = PR_FALSE;
    1: 
    1:   // The transient about:blank viewer doesn't have a session history entry.
    1:   SetHistoryEntry(&mOSHE, nsnull);
    1: 
    1:   return rv;
    1: }
    1: 
55593: NS_IMETHODIMP
55593: nsDocShell::CreateAboutBlankContentViewer(nsIPrincipal *aPrincipal)
55593: {
55593:     return CreateAboutBlankContentViewer(aPrincipal, nsnull);
55593: }
55593: 
79445: bool
    1: nsDocShell::CanSavePresentation(PRUint32 aLoadType,
    1:                                 nsIRequest *aNewRequest,
    1:                                 nsIDocument *aNewDocument)
    1: {
    1:     if (!mOSHE)
    1:         return PR_FALSE; // no entry to save into
    1: 
62557:     nsCOMPtr<nsIContentViewer> viewer;
62557:     mOSHE->GetContentViewer(getter_AddRefs(viewer));
62557:     if (viewer) {
62557:         NS_WARNING("mOSHE already has a content viewer!");
62557:         return PR_FALSE;
62557:     }
62557: 
    1:     // Only save presentation for "normal" loads and link loads.  Anything else
    1:     // probably wants to refetch the page, so caching the old presentation
    1:     // would be incorrect.
    1:     if (aLoadType != LOAD_NORMAL &&
    1:         aLoadType != LOAD_HISTORY &&
    1:         aLoadType != LOAD_LINK &&
    1:         aLoadType != LOAD_STOP_CONTENT &&
    1:         aLoadType != LOAD_STOP_CONTENT_AND_REPLACE &&
    1:         aLoadType != LOAD_ERROR_PAGE)
    1:         return PR_FALSE;
    1: 
    1:     // If the session history entry has the saveLayoutState flag set to false,
    1:     // then we should not cache the presentation.
79445:     bool canSaveState;
    1:     mOSHE->GetSaveLayoutStateFlag(&canSaveState);
37970:     if (!canSaveState)
    1:         return PR_FALSE;
    1: 
    1:     // If the document is not done loading, don't cache it.
    1:     nsCOMPtr<nsPIDOMWindow> pWin = do_QueryInterface(mScriptGlobal);
    1:     if (!pWin || pWin->IsLoading())
    1:         return PR_FALSE;
    1: 
    1:     if (pWin->WouldReuseInnerWindow(aNewDocument))
    1:         return PR_FALSE;
    1: 
    1:     // Avoid doing the work of saving the presentation state in the case where
    1:     // the content viewer cache is disabled.
    1:     if (nsSHistory::GetMaxTotalViewers() == 0)
    1:         return PR_FALSE;
    1: 
    1:     // Don't cache the content viewer if we're in a subframe and the subframe
    1:     // pref is disabled.
79445:     bool cacheFrames =
72449:         Preferences::GetBool("browser.sessionhistory.cache_subframes",
79445:                              false);
    1:     if (!cacheFrames) {
    1:         nsCOMPtr<nsIDocShellTreeItem> root;
    1:         GetSameTypeParent(getter_AddRefs(root));
    1:         if (root && root != this) {
    1:             return PR_FALSE;  // this is a subframe load
    1:         }
    1:     }
    1: 
    1:     // If the document does not want its presentation cached, then don't.
    1:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(pWin->GetExtantDocument());
    1:     if (!doc || !doc->CanSavePresentation(aNewRequest))
    1:         return PR_FALSE;
    1: 
    1:     return PR_TRUE;
    1: }
    1: 
14631: void
14887: nsDocShell::ReattachEditorToWindow(nsISHEntry *aSHEntry)
14631: {
14631:     NS_ASSERTION(!mEditorData,
14631:                  "Why reattach an editor when we already have one?");
14887:     NS_ASSERTION(aSHEntry && aSHEntry->HasDetachedEditor(),
14631:                  "Reattaching when there's not a detached editor.");
14631: 
14887:     if (mEditorData || !aSHEntry)
14631:         return;
14631: 
14631:     mEditorData = aSHEntry->ForgetEditorData();
14631:     if (mEditorData) {
58636: #ifdef DEBUG
58636:         nsresult rv =
58636: #endif
58636:         mEditorData->ReattachToWindow(this);
58636:         NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to reattach editing session");
14631:     }
14631: }
14631: 
14631: void
24129: nsDocShell::DetachEditorFromWindow()
24129: {
24129:     if (!mEditorData || mEditorData->WaitingForLoad()) {
24129:         // If there's nothing to detach, or if the editor data is actually set
24129:         // up for the _new_ page that's coming in, don't detach.
14631:         return;
24129:     }
24129: 
24129:     NS_ASSERTION(!mOSHE || !mOSHE->HasDetachedEditor(),
14887:                  "Detaching editor when it's already detached.");
14631: 
14631:     nsresult res = mEditorData->DetachFromWindow();
14631:     NS_ASSERTION(NS_SUCCEEDED(res), "Failed to detach editor");
14631: 
14631:     if (NS_SUCCEEDED(res)) {
24129:         // Make mOSHE hold the owning ref to the editor data.
24129:         if (mOSHE)
24129:             mOSHE->SetEditorData(mEditorData.forget());
14887:         else
14887:             mEditorData = nsnull;
14631:     }
14631: 
14631: #ifdef DEBUG
14631:     {
79445:         bool isEditable;
14631:         GetEditable(&isEditable);
14631:         NS_ASSERTION(!isEditable,
14631:                      "Window is still editable after detaching editor.");
14631:     }
14631: #endif // DEBUG
14631: }
14631: 
    1: nsresult
    1: nsDocShell::CaptureState()
    1: {
    1:     if (!mOSHE || mOSHE == mLSHE) {
    1:         // No entry to save into, or we're replacing the existing entry.
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nsCOMPtr<nsPIDOMWindow> privWin = do_QueryInterface(mScriptGlobal);
    1:     if (!privWin)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsISupports> windowState;
19870:     nsresult rv = privWin->SaveWindowState(getter_AddRefs(windowState));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:     nsCOMPtr<nsIURI> uri;
    1:     mOSHE->GetURI(getter_AddRefs(uri));
    1:     nsCAutoString spec;
    1:     if (uri)
    1:         uri->GetSpec(spec);
    1:     printf("Saving presentation into session history\n");
    1:     printf("  SH URI: %s\n", spec.get());
    1: #endif
    1: 
    1:     rv = mOSHE->SetWindowState(windowState);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Suspend refresh URIs and save off the timer queue
    1:     rv = mOSHE->SetRefreshURIList(mSavedRefreshURIList);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Capture the current content viewer bounds.
30537:     if (mContentViewer) {
30537:         nsIntRect bounds;
30537:         mContentViewer->GetBounds(bounds);
    1:         rv = mOSHE->SetViewerBounds(bounds);
30537:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     // Capture the docshell hierarchy.
    1:     mOSHE->ClearChildShells();
    1: 
29263:     PRInt32 childCount = mChildList.Count();
29263:     for (PRInt32 i = 0; i < childCount; ++i) {
29263:         nsCOMPtr<nsIDocShellTreeItem> childShell = do_QueryInterface(ChildAt(i));
    1:         NS_ASSERTION(childShell, "null child shell");
    1: 
    1:         mOSHE->AddChildShell(childShell);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::RestorePresentationEvent::Run()
    1: {
    1:     if (mDocShell && NS_FAILED(mDocShell->RestoreFromHistory()))
    1:         NS_WARNING("RestoreFromHistory failed");
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::BeginRestore(nsIContentViewer *aContentViewer, bool aTop)
    1: {
    1:     nsresult rv;
    1:     if (!aContentViewer) {
    1:         rv = EnsureContentViewer();
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         aContentViewer = mContentViewer;
    1:     }
    1: 
    1:     // Dispatch events for restoring the presentation.  We try to simulate
    1:     // the progress notifications loading the document would cause, so we add
    1:     // the document's channel to the loadgroup to initiate stateChange
    1:     // notifications.
    1: 
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     aContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
    1:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:     if (doc) {
    1:         nsIChannel *channel = doc->GetChannel();
    1:         if (channel) {
    1:             mEODForCurrentDocument = PR_FALSE;
    1:             mIsRestoringDocument = PR_TRUE;
    1:             mLoadGroup->AddRequest(channel, nsnull);
    1:             mIsRestoringDocument = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     if (!aTop) {
 3339:         // This point corresponds to us having gotten OnStartRequest or
 3339:         // STATE_START, so do the same thing that CreateContentViewer does at
 3339:         // this point to ensure that unload/pagehide events for this document
 3339:         // will fire when it's unloaded again.
 3339:         mFiredUnloadEvent = PR_FALSE;
 3339: 
    1:         // For non-top frames, there is no notion of making sure that the
    1:         // previous document is in the domwindow when STATE_START notifications
    1:         // happen.  We can just call BeginRestore for all of the child shells
    1:         // now.
    1:         rv = BeginRestoreChildren();
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::BeginRestoreChildren()
    1: {
29263:     PRInt32 n = mChildList.Count();
29263:     for (PRInt32 i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
    1:         if (child) {
    1:             nsresult rv = child->BeginRestore(nsnull, PR_FALSE);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::FinishRestore()
    1: {
    1:     // First we call finishRestore() on our children.  In the simulated load,
    1:     // all of the child frames finish loading before the main document.
    1: 
29263:     PRInt32 n = mChildList.Count();
29263:     for (PRInt32 i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
    1:         if (child) {
    1:             child->FinishRestore();
    1:         }
    1:     }
    1: 
14887:     if (mOSHE && mOSHE->HasDetachedEditor()) {
14887:       ReattachEditorToWindow(mOSHE);
14887:     }
14887: 
48097:     nsCOMPtr<nsIDocument> doc = do_GetInterface(GetAsSupports(this));
    1:     if (doc) {
    1:         // Finally, we remove the request from the loadgroup.  This will
    1:         // cause onStateChange(STATE_STOP) to fire, which will fire the
    1:         // pageshow event to the chrome.
    1: 
    1:         nsIChannel *channel = doc->GetChannel();
    1:         if (channel) {
    1:             mIsRestoringDocument = PR_TRUE;
    1:             mLoadGroup->RemoveRequest(channel, nsnull, NS_OK);
    1:             mIsRestoringDocument = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsDocShell::GetRestoringDocument(bool *aRestoring)
    1: {
    1:     *aRestoring = mIsRestoringDocument;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
79445: nsDocShell::RestorePresentation(nsISHEntry *aSHEntry, bool *aRestoring)
    1: {
    1:     NS_ASSERTION(mLoadType & LOAD_CMD_HISTORY,
    1:                  "RestorePresentation should only be called for history loads");
    1: 
    1:     nsCOMPtr<nsIContentViewer> viewer;
    1:     aSHEntry->GetContentViewer(getter_AddRefs(viewer));
    1: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:     nsCOMPtr<nsIURI> uri;
    1:     aSHEntry->GetURI(getter_AddRefs(uri));
    1: 
    1:     nsCAutoString spec;
    1:     if (uri)
    1:         uri->GetSpec(spec);
    1: #endif
    1: 
    1:     *aRestoring = PR_FALSE;
    1: 
    1:     if (!viewer) {
    1: #ifdef DEBUG_PAGE_CACHE
    1:         printf("no saved presentation for uri: %s\n", spec.get());
    1: #endif
    1:         return NS_OK;
    1:     }
    1: 
    1:     // We need to make sure the content viewer's container is this docshell.
    1:     // In subframe navigation, it's possible for the docshell that the
    1:     // content viewer was originally loaded into to be replaced with a
    1:     // different one.  We don't currently support restoring the presentation
    1:     // in that case.
    1: 
    1:     nsCOMPtr<nsISupports> container;
    1:     viewer->GetContainer(getter_AddRefs(container));
    1:     if (!::SameCOMIdentity(container, GetAsSupports(this))) {
    1: #ifdef DEBUG_PAGE_CACHE
    1:         printf("No valid container, clearing presentation\n");
    1: #endif
    1:         aSHEntry->SetContentViewer(nsnull);
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     NS_ASSERTION(mContentViewer != viewer, "Restoring existing presentation");
    1: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:     printf("restoring presentation from session history: %s\n", spec.get());
    1: #endif
    1: 
    1:     SetHistoryEntry(&mLSHE, aSHEntry);
    1: 
    1:     // Add the request to our load group.  We do this before swapping out
    1:     // the content viewers so that consumers of STATE_START can access
    1:     // the old document.  We only deal with the toplevel load at this time --
    1:     // to be consistent with normal document loading, subframes cannot start
    1:     // loading until after data arrives, which is after STATE_START completes.
    1: 
    1:     BeginRestore(viewer, PR_TRUE);
    1: 
    1:     // Post an event that will remove the request after we've returned
    1:     // to the event loop.  This mimics the way it is called by nsIChannel
    1:     // implementations.
    1: 
    1:     // Revoke any pending restore (just in case)
    1:     NS_ASSERTION(!mRestorePresentationEvent.IsPending(),
    1:         "should only have one RestorePresentationEvent");
    1:     mRestorePresentationEvent.Revoke();
    1: 
    1:     nsRefPtr<RestorePresentationEvent> evt = new RestorePresentationEvent(this);
    1:     nsresult rv = NS_DispatchToCurrentThread(evt);
    1:     if (NS_SUCCEEDED(rv)) {
    1:         mRestorePresentationEvent = evt.get();
    1:         // The rest of the restore processing will happen on our event
    1:         // callback.
    1:         *aRestoring = PR_TRUE;
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::RestoreFromHistory()
    1: {
    1:     mRestorePresentationEvent.Forget();
    1: 
    1:     // This section of code follows the same ordering as CreateContentViewer.
    1:     if (!mLSHE)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsIContentViewer> viewer;
    1:     mLSHE->GetContentViewer(getter_AddRefs(viewer));
    1:     if (!viewer)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     if (mSavingOldViewer) {
    1:         // We determined that it was safe to cache the document presentation
    1:         // at the time we initiated the new load.  We need to check whether
    1:         // it's still safe to do so, since there may have been DOM mutations
    1:         // or new requests initiated.
    1:         nsCOMPtr<nsIDOMDocument> domDoc;
    1:         viewer->GetDOMDocument(getter_AddRefs(domDoc));
    1:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:         nsIRequest *request = nsnull;
    1:         if (doc)
    1:             request = doc->GetChannel();
    1:         mSavingOldViewer = CanSavePresentation(mLoadType, request, doc);
    1:     }
    1: 
71056:     nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV(
63383:         do_QueryInterface(mContentViewer));
71056:     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV(
63383:         do_QueryInterface(viewer));
63383:     PRInt32 minFontSize = 0;
 5357:     float textZoom = 1.0f;
 5357:     float pageZoom = 1.0f;
79445:     bool styleDisabled = false;
 5357:     if (oldMUDV && newMUDV) {
63383:         oldMUDV->GetMinFontSize(&minFontSize);
 5357:         oldMUDV->GetTextZoom(&textZoom);
 5357:         oldMUDV->GetFullZoom(&pageZoom);
47685:         oldMUDV->GetAuthorStyleDisabled(&styleDisabled);
 5357:     }
    1: 
    1:     // Protect against mLSHE going away via a load triggered from
    1:     // pagehide or unload.
    1:     nsCOMPtr<nsISHEntry> origLSHE = mLSHE;
    1: 
10676:     // Make sure to blow away our mLoadingURI just in case.  No loads
10676:     // from inside this pagehide.
10676:     mLoadingURI = nsnull;
10676:     
    1:     // Notify the old content viewer that it's being hidden.
    1:     FirePageHideNotification(!mSavingOldViewer);
    1: 
    1:     // If mLSHE was changed as a result of the pagehide event, then
    1:     // something else was loaded.  Don't finish restoring.
    1:     if (mLSHE != origLSHE)
    1:       return NS_OK;
    1: 
    1:     // Set mFiredUnloadEvent = PR_FALSE so that the unload handler for the
    1:     // *new* document will fire.
    1:     mFiredUnloadEvent = PR_FALSE;
    1: 
    1:     mURIResultedInDocument = PR_TRUE;
    1:     nsCOMPtr<nsISHistory> rootSH;
    1:     GetRootSessionHistory(getter_AddRefs(rootSH));
    1:     if (rootSH) {
    1:         nsCOMPtr<nsISHistoryInternal> hist = do_QueryInterface(rootSH);
19870:         rootSH->GetIndex(&mPreviousTransIndex);
    1:         hist->UpdateIndex();
19870:         rootSH->GetIndex(&mLoadedTransIndex);
19870: #ifdef DEBUG_PAGE_CACHE
19870:         printf("Previous index: %d, Loaded index: %d\n\n", mPreviousTransIndex,
19870:                    mLoadedTransIndex);
19870: #endif
    1:     }
    1: 
    1:     // Rather than call Embed(), we will retrieve the viewer from the session
    1:     // history entry and swap it in.
    1:     // XXX can we refactor this so that we can just call Embed()?
    1:     PersistLayoutHistoryState();
    1:     nsresult rv;
    1:     if (mContentViewer) {
    1:         if (mSavingOldViewer && NS_FAILED(CaptureState())) {
    1:             if (mOSHE) {
    1:                 mOSHE->SyncPresentationState();
    1:             }
    1:             mSavingOldViewer = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     mSavedRefreshURIList = nsnull;
    1: 
    1:     // In cases where we use a transient about:blank viewer between loads,
    1:     // we never show the transient viewer, so _its_ previous viewer is never
    1:     // unhooked from the view hierarchy.  Destroy any such previous viewer now,
    1:     // before we grab the root view sibling, so that we don't grab a view
    1:     // that's about to go away.
    1: 
    1:     if (mContentViewer) {
    1:         nsCOMPtr<nsIContentViewer> previousViewer;
    1:         mContentViewer->GetPreviousViewer(getter_AddRefs(previousViewer));
    1:         if (previousViewer) {
    1:             mContentViewer->SetPreviousViewer(nsnull);
    1:             previousViewer->Destroy();
    1:         }
    1:     }
    1: 
    1:     // Save off the root view's parent and sibling so that we can insert the
    1:     // new content viewer's root view at the same position.  Also save the
    1:     // bounds of the root view's widget.
    1: 
    1:     nsIView *rootViewSibling = nsnull, *rootViewParent = nsnull;
23738:     nsIntRect newBounds(0, 0, 0, 0);
    1: 
    1:     nsCOMPtr<nsIPresShell> oldPresShell;
    1:     nsDocShell::GetPresShell(getter_AddRefs(oldPresShell));
    1:     if (oldPresShell) {
    1:         nsIViewManager *vm = oldPresShell->GetViewManager();
    1:         if (vm) {
64435:             nsIView *oldRootView = vm->GetRootView();
    1: 
    1:             if (oldRootView) {
    1:                 rootViewSibling = oldRootView->GetNextSibling();
    1:                 rootViewParent = oldRootView->GetParent();
    1: 
30537:                 mContentViewer->GetBounds(newBounds);
    1:             }
    1:         }
    1:     }
    1: 
    1:     // Transfer ownership to mContentViewer.  By ensuring that either the
    1:     // docshell or the session history, but not both, have references to the
    1:     // content viewer, we prevent the viewer from being torn down after
    1:     // Destroy() is called.
    1: 
    1:     if (mContentViewer) {
    1:         mContentViewer->Close(mSavingOldViewer ? mOSHE.get() : nsnull);
    1:         viewer->SetPreviousViewer(mContentViewer);
    1:     }
62825:     if (mOSHE && (!mContentViewer || !mSavingOldViewer)) {
62825:         // We don't plan to save a viewer in mOSHE; tell it to drop
62825:         // any other state it's holding.
62825:         mOSHE->SyncPresentationState();
62825:     }
    1: 
36625:     // Order the mContentViewer setup just like Embed does.
36625:     mContentViewer = nsnull;
36625: 
36625:     // Now that we're about to switch documents, forget all of our children.
36625:     // Note that we cached them as needed up in CaptureState above.
36625:     DestroyChildren();
36625: 
    1:     mContentViewer.swap(viewer);
    1: 
    1:     // Grab all of the related presentation from the SHEntry now.
    1:     // Clearing the viewer from the SHEntry will clear all of this state.
    1:     nsCOMPtr<nsISupports> windowState;
    1:     mLSHE->GetWindowState(getter_AddRefs(windowState));
    1:     mLSHE->SetWindowState(nsnull);
    1: 
79445:     bool sticky;
    1:     mLSHE->GetSticky(&sticky);
    1: 
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
    1: 
    1:     nsCOMArray<nsIDocShellTreeItem> childShells;
    1:     PRInt32 i = 0;
    1:     nsCOMPtr<nsIDocShellTreeItem> child;
    1:     while (NS_SUCCEEDED(mLSHE->ChildShellAt(i++, getter_AddRefs(child))) &&
    1:            child) {
    1:         childShells.AppendObject(child);
    1:     }
    1: 
    1:     // get the previous content viewer size
23738:     nsIntRect oldBounds(0, 0, 0, 0);
    1:     mLSHE->GetViewerBounds(oldBounds);
    1: 
    1:     // Restore the refresh URI list.  The refresh timers will be restarted
    1:     // when EndPageLoad() is called.
    1:     nsCOMPtr<nsISupportsArray> refreshURIList;
    1:     mLSHE->GetRefreshURIList(getter_AddRefs(refreshURIList));
    1: 
    1:     // Reattach to the window object.
    1:     rv = mContentViewer->Open(windowState, mLSHE);
    1: 
62826:     // Hack to keep nsDocShellEditorData alive across the
62826:     // SetContentViewer(nsnull) call below.
62826:     nsAutoPtr<nsDocShellEditorData> data(mLSHE->ForgetEditorData());
62826: 
    1:     // Now remove it from the cached presentation.
    1:     mLSHE->SetContentViewer(nsnull);
    1:     mEODForCurrentDocument = PR_FALSE;
    1: 
62826:     mLSHE->SetEditorData(data.forget());
62826: 
    1: #ifdef DEBUG
    1:  {
    1:      nsCOMPtr<nsISupportsArray> refreshURIs;
    1:      mLSHE->GetRefreshURIList(getter_AddRefs(refreshURIs));
    1:      nsCOMPtr<nsIDocShellTreeItem> childShell;
    1:      mLSHE->ChildShellAt(0, getter_AddRefs(childShell));
    1:      NS_ASSERTION(!refreshURIs && !childShell,
    1:                   "SHEntry should have cleared presentation state");
    1:  }
    1: #endif
    1: 
    1:     // Restore the sticky state of the viewer.  The viewer has set this state
    1:     // on the history entry in Destroy() just before marking itself non-sticky,
    1:     // to avoid teardown of the presentation.
    1:     mContentViewer->SetSticky(sticky);
    1: 
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // mLSHE is now our currently-loaded document.
    1:     SetHistoryEntry(&mOSHE, mLSHE);
    1:     
    1:     // XXX special wyciwyg handling in Embed()?
    1: 
    1:     // We aren't going to restore any items from the LayoutHistoryState,
    1:     // but we don't want them to stay around in case the page is reloaded.
    1:     SetLayoutHistoryState(nsnull);
    1: 
    1:     // This is the end of our Embed() replacement
    1: 
    1:     mSavingOldViewer = PR_FALSE;
    1:     mEODForCurrentDocument = PR_FALSE;
    1: 
    1:     // Tell the event loop to favor plevents over user events, see comments
    1:     // in CreateContentViewer.
    1:     if (++gNumberOfDocumentsLoading == 1)
    1:         FavorPerformanceHint(PR_TRUE, NS_EVENT_STARVATION_DELAY_HINT);
    1: 
    1: 
 5357:     if (oldMUDV && newMUDV) {
63383:         newMUDV->SetMinFontSize(minFontSize);
 5357:         newMUDV->SetTextZoom(textZoom);
 5357:         newMUDV->SetFullZoom(pageZoom);
47685:         newMUDV->SetAuthorStyleDisabled(styleDisabled);
 5357:     }
    1: 
    1:     nsCOMPtr<nsIDocument> document = do_QueryInterface(domDoc);
25723:     PRUint32 parentSuspendCount = 0;
    1:     if (document) {
25722:         nsCOMPtr<nsIDocShellTreeItem> parent;
25722:         GetParent(getter_AddRefs(parent));
48097:         nsCOMPtr<nsIDocument> d = do_GetInterface(parent);
25723:         if (d) {
25723:             if (d->EventHandlingSuppressed()) {
25722:                 document->SuppressEventHandling(d->EventHandlingSuppressed());
25722:             }
25723:             nsCOMPtr<nsPIDOMWindow> parentWindow = d->GetWindow();
25723:             if (parentWindow) {
25723:                 parentSuspendCount = parentWindow->TimeoutSuspendCount();
25723:             }
25723:         }
25722: 
    1:         // Use the uri from the mLSHE we had when we entered this function
    1:         // (which need not match the document's URI if anchors are involved),
    1:         // since that's the history entry we're loading.  Note that if we use
    1:         // origLSHE we don't have to worry about whether the entry in question
    1:         // is still mLSHE or whether it's now mOSHE.
    1:         nsCOMPtr<nsIURI> uri;
    1:         origLSHE->GetURI(getter_AddRefs(uri));
71723:         SetCurrentURI(uri, document->GetChannel(), PR_TRUE);
    1:     }
    1: 
    1:     // This is the end of our CreateContentViewer() replacement.
    1:     // Now we simulate a load.  First, we restore the state of the javascript
    1:     // window object.
    1:     nsCOMPtr<nsPIDOMWindow> privWin =
 3233:         do_GetInterface(static_cast<nsIInterfaceRequestor*>(this));
    1:     NS_ASSERTION(privWin, "could not get nsPIDOMWindow interface");
    1: 
    1:     rv = privWin->RestoreWindowState(windowState);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
16977:     // Now, dispatch a title change event which would happen as the
    1:     // <head> is parsed.
16977:     document->NotifyPossibleTitleChange(PR_FALSE);
    1: 
    1:     // Now we simulate appending child docshells for subframes.
    1:     for (i = 0; i < childShells.Count(); ++i) {
    1:         nsIDocShellTreeItem *childItem = childShells.ObjectAt(i);
 6685:         nsCOMPtr<nsIDocShell> childShell = do_QueryInterface(childItem);
 6685: 
 6685:         // Make sure to not clobber the state of the child.  Since AddChild
 6685:         // always clobbers it, save it off first.
79445:         bool allowPlugins;
 6685:         childShell->GetAllowPlugins(&allowPlugins);
 6685: 
79445:         bool allowJavascript;
 6685:         childShell->GetAllowJavascript(&allowJavascript);
 6685: 
79445:         bool allowRedirects;
 6685:         childShell->GetAllowMetaRedirects(&allowRedirects);
 6685: 
79445:         bool allowSubframes;
 6685:         childShell->GetAllowSubframes(&allowSubframes);
 6685: 
79445:         bool allowImages;
 6685:         childShell->GetAllowImages(&allowImages);
 6685: 
79445:         bool allowDNSPrefetch;
28460:         childShell->GetAllowDNSPrefetch(&allowDNSPrefetch);
28460: 
48937:         // this.AddChild(child) calls child.SetDocLoaderParent(this), meaning
48937:         // that the child inherits our state. Among other things, this means
48937:         // that the child inherits our mIsActive, which is what we want.
    1:         AddChild(childItem);
    1: 
 6685:         childShell->SetAllowPlugins(allowPlugins);
 6685:         childShell->SetAllowJavascript(allowJavascript);
 6685:         childShell->SetAllowMetaRedirects(allowRedirects);
 6685:         childShell->SetAllowSubframes(allowSubframes);
 6685:         childShell->SetAllowImages(allowImages);
28460:         childShell->SetAllowDNSPrefetch(allowDNSPrefetch);
 6685: 
    1:         rv = childShell->BeginRestore(nsnull, PR_FALSE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     nsCOMPtr<nsIPresShell> shell;
    1:     nsDocShell::GetPresShell(getter_AddRefs(shell));
    1: 
    1:     nsIViewManager *newVM = shell ? shell->GetViewManager() : nsnull;
64435:     nsIView *newRootView = newVM ? newVM->GetRootView() : nsnull;
    1: 
    1:     // Insert the new root view at the correct location in the view tree.
    1:     if (rootViewParent) {
    1:         nsIViewManager *parentVM = rootViewParent->GetViewManager();
    1: 
    1:         if (parentVM && newRootView) {
    1:             // InsertChild(parent, child, sib, PR_TRUE) inserts the child after
    1:             // sib in content order, which is before sib in view order. BUT
    1:             // when sib is null it inserts at the end of the the document
    1:             // order, i.e., first in view order.  But when oldRootSibling is
    1:             // null, the old root as at the end of the view list --- last in
    1:             // content order --- and we want to call InsertChild(parent, child,
    1:             // nsnull, PR_FALSE) in that case.
    1:             parentVM->InsertChild(rootViewParent, newRootView,
    1:                                   rootViewSibling,
    1:                                   rootViewSibling ? PR_TRUE : PR_FALSE);
    1: 
    1:             NS_ASSERTION(newRootView->GetNextSibling() == rootViewSibling,
    1:                          "error in InsertChild");
    1:         }
    1:     }
    1: 
25723:     // If parent is suspended, increase suspension count.
25723:     // This can't be done as early as event suppression since this
25723:     // depends on docshell tree.
25723:     if (parentSuspendCount) {
25723:       privWin->SuspendTimeouts(parentSuspendCount, PR_FALSE);
25723:     }
25723: 
    1:     // Now that all of the child docshells have been put into place, we can
    1:     // restart the timers for the window and all of the child frames.
    1:     privWin->ResumeTimeouts();
    1: 
    1:     // Restore the refresh URI list.  The refresh timers will be restarted
    1:     // when EndPageLoad() is called.
    1:     mRefreshURIList = refreshURIList;
    1: 
    1:     // Meta-refresh timers have been restarted for this shell, but not
    1:     // for our children.  Walk the child shells and restart their timers.
29263:     PRInt32 n = mChildList.Count();
    1:     for (i = 0; i < n; ++i) {
29263:         nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
    1:         if (child)
    1:             child->ResumeRefreshURIs();
    1:     }
    1: 
    1:     // Make sure this presentation is the same size as the previous
    1:     // presentation.  If this is not the same size we showed it at last time,
    1:     // then we need to resize the widget.
    1: 
    1:     // XXXbryner   This interacts poorly with Firefox's infobar.  If the old
    1:     // presentation had the infobar visible, then we will resize the new
    1:     // presentation to that smaller size.  However, firing the locationchanged
    1:     // event will hide the infobar, which will immediately resize the window
    1:     // back to the larger size.  A future optimization might be to restore
    1:     // the presentation at the "wrong" size, then fire the locationchanged
    1:     // event and check whether the docshell's new size is the same as the
    1:     // cached viewer size (skipping the resize if they are equal).
    1: 
    1:     if (newRootView) {
68638:         if (!newBounds.IsEmpty() && !newBounds.IsEqualEdges(oldBounds)) {
    1: #ifdef DEBUG_PAGE_CACHE
    1:             printf("resize widget(%d, %d, %d, %d)\n", newBounds.x,
    1:                    newBounds.y, newBounds.width, newBounds.height);
    1: #endif
30537:             mContentViewer->SetBounds(newBounds);
34480:         } else {
34482:             nsIScrollableFrame *rootScrollFrame =
34482:               shell->GetRootScrollFrameAsScrollableExternal();
34480:             if (rootScrollFrame) {
34480:                 rootScrollFrame->PostScrolledAreaEventForCurrentArea();
34480:             }
    1:         }
    1:     }
    1: 
62286:     // The FinishRestore call below can kill these, null them out so we don't
62286:     // have invalid pointer lying around.
62286:     newRootView = rootViewSibling = rootViewParent = nsnull;
62286:     newVM = nsnull;
62286: 
    1:     // Simulate the completion of the load.
    1:     nsDocShell::FinishRestore();
    1: 
    1:     // Restart plugins, and paint the content.
62286:     if (shell) {
    1:         shell->Thaw();
    1: 
62286:         newVM = shell->GetViewManager();
62286:         if (newVM) {
62286:             // When we insert the root view above the resulting invalidate is
62286:             // dropped because painting is suppressed in the presshell until we
62286:             // call Thaw. So we issue the invalidate here.
64435:             newRootView = newVM->GetRootView();
62286:             if (newRootView) {
62286:                 newVM->UpdateView(newRootView, NS_VMREFRESH_NO_SYNC);
62286:             }
62286:         }
62286:     }
62286: 
    1:     return privWin->FireDelayedDOMEvents();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::CreateContentViewer(const char *aContentType,
    1:                                 nsIRequest * request,
    1:                                 nsIStreamListener ** aContentHandler)
    1: {
    1:     *aContentHandler = nsnull;
    1: 
    1:     // Can we check the content type of the current content viewer
    1:     // and reuse it without destroying it and re-creating it?
    1: 
    1:     NS_ASSERTION(mLoadGroup, "Someone ignored return from Init()?");
    1: 
    1:     // Instantiate the content viewer object
    1:     nsCOMPtr<nsIContentViewer> viewer;
    1:     nsresult rv = NewContentViewerObj(aContentType, request, mLoadGroup,
    1:                                       aContentHandler, getter_AddRefs(viewer));
    1: 
    1:     if (NS_FAILED(rv))
60516:         return rv;
    1: 
    1:     // Notify the current document that it is about to be unloaded!!
    1:     //
    1:     // It is important to fire the unload() notification *before* any state
    1:     // is changed within the DocShell - otherwise, javascript will get the
    1:     // wrong information :-(
    1:     //
    1: 
    1:     if (mSavingOldViewer) {
    1:         // We determined that it was safe to cache the document presentation
    1:         // at the time we initiated the new load.  We need to check whether
    1:         // it's still safe to do so, since there may have been DOM mutations
    1:         // or new requests initiated.
    1:         nsCOMPtr<nsIDOMDocument> domDoc;
    1:         viewer->GetDOMDocument(getter_AddRefs(domDoc));
    1:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:         mSavingOldViewer = CanSavePresentation(mLoadType, request, doc);
    1:     }
    1: 
10676:     NS_ASSERTION(!mLoadingURI, "Re-entering unload?");
10676:     
10676:     nsCOMPtr<nsIChannel> aOpenedChannel = do_QueryInterface(request);
10676:     if (aOpenedChannel) {
10676:         aOpenedChannel->GetURI(getter_AddRefs(mLoadingURI));
10676:     }
    1:     FirePageHideNotification(!mSavingOldViewer);
10676:     mLoadingURI = nsnull;
    1: 
    1:     // Set mFiredUnloadEvent = PR_FALSE so that the unload handler for the
    1:     // *new* document will fire.
    1:     mFiredUnloadEvent = PR_FALSE;
    1: 
    1:     // we've created a new document so go ahead and call
    1:     // OnLoadingSite(), but don't fire OnLocationChange()
    1:     // notifications before we've called Embed(). See bug 284993.
    1:     mURIResultedInDocument = PR_TRUE;
    1: 
34780:     if (mLoadType == LOAD_ERROR_PAGE) {
34780:         // We need to set the SH entry and our current URI here and not
34780:         // at the moment we load the page. We want the same behavior 
34780:         // of Stop() as for a normal page load. See bug 514232 for details.
34780: 
34780:         // Revert mLoadType to load type to state the page load failed,
34780:         // following function calls need it.
34780:         mLoadType = mFailedLoadType;
34780: 
34780:         nsCOMPtr<nsIChannel> failedChannel = mFailedChannel;
34780:         nsCOMPtr<nsIURI> failedURI = mFailedURI;
34780:         mFailedChannel = nsnull;
34780:         mFailedURI = nsnull;
34780: 
34780:         // Create an shistory entry for the old load, if we have a channel
34780:         if (failedChannel) {
34780:             mURIResultedInDocument = PR_TRUE;
34780:             OnLoadingSite(failedChannel, PR_TRUE, PR_FALSE);
34780:         } else if (failedURI) {
34780:             mURIResultedInDocument = PR_TRUE;
64491:             OnNewURI(failedURI, nsnull, nsnull, mLoadType, PR_TRUE, PR_FALSE,
64491:                      PR_FALSE);
34780:         }
34780: 
35007:         // Be sure to have a correct mLSHE, it may have been cleared by
35007:         // EndPageLoad. See bug 302115.
35007:         if (mSessionHistory && !mLSHE) {
35007:             PRInt32 idx;
35007:             mSessionHistory->GetRequestedIndex(&idx);
35007:             if (idx == -1)
35007:                 mSessionHistory->GetIndex(&idx);
35007: 
35007:             nsCOMPtr<nsIHistoryEntry> entry;
35007:             mSessionHistory->GetEntryAtIndex(idx, PR_FALSE,
35007:                                              getter_AddRefs(entry));
35007:             mLSHE = do_QueryInterface(entry);
35007:         }
35007: 
34780:         // Set our current URI
34780:         SetCurrentURI(failedURI);
34780: 
34780:         mLoadType = LOAD_ERROR_PAGE;
34780:     }
34780: 
79445:     bool onLocationChangeNeeded = OnLoadingSite(aOpenedChannel, false);
    1: 
    1:     // let's try resetting the load group if we need to...
    1:     nsCOMPtr<nsILoadGroup> currentLoadGroup;
    1:     NS_ENSURE_SUCCESS(aOpenedChannel->
    1:                       GetLoadGroup(getter_AddRefs(currentLoadGroup)),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     if (currentLoadGroup != mLoadGroup) {
    1:         nsLoadFlags loadFlags = 0;
    1: 
    1:         //Cancel any URIs that are currently loading...
    1:         /// XXX: Need to do this eventually      Stop();
    1:         //
    1:         // Retarget the document to this loadgroup...
    1:         //
    1:         /* First attach the channel to the right loadgroup
    1:          * and then remove from the old loadgroup. This 
    1:          * puts the notifications in the right order and
    1:          * we don't null-out mLSHE in OnStateChange() for 
    1:          * all redirected urls
    1:          */
    1:         aOpenedChannel->SetLoadGroup(mLoadGroup);
    1: 
    1:         // Mark the channel as being a document URI...
    1:         aOpenedChannel->GetLoadFlags(&loadFlags);
    1:         loadFlags |= nsIChannel::LOAD_DOCUMENT_URI;
    1: 
    1:         aOpenedChannel->SetLoadFlags(loadFlags);
    1: 
    1:         mLoadGroup->AddRequest(request, nsnull);
    1:         if (currentLoadGroup)
    1:             currentLoadGroup->RemoveRequest(request, nsnull,
    1:                                             NS_BINDING_RETARGETED);
    1: 
    1:         // Update the notification callbacks, so that progress and
    1:         // status information are sent to the right docshell...
    1:         aOpenedChannel->SetNotificationCallbacks(this);
    1:     }
    1: 
    1:     NS_ENSURE_SUCCESS(Embed(viewer, "", (nsISupports *) nsnull),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     mSavedRefreshURIList = nsnull;
    1:     mSavingOldViewer = PR_FALSE;
    1:     mEODForCurrentDocument = PR_FALSE;
    1: 
    1:     // if this document is part of a multipart document,
    1:     // the ID can be used to distinguish it from the other parts.
    1:     nsCOMPtr<nsIMultiPartChannel> multiPartChannel(do_QueryInterface(request));
    1:     if (multiPartChannel) {
    1:       nsCOMPtr<nsIPresShell> shell;
    1:       rv = GetPresShell(getter_AddRefs(shell));
    1:       if (NS_SUCCEEDED(rv) && shell) {
    1:         nsIDocument *doc = shell->GetDocument();
    1:         if (doc) {
    1:           PRUint32 partID;
    1:           multiPartChannel->GetPartID(&partID);
    1:           doc->SetPartID(partID);
    1:         }
    1:       }
    1:     }
    1: 
    1:     // Give hint to native plevent dispatch mechanism. If a document
    1:     // is loading the native plevent dispatch mechanism should favor
    1:     // performance over normal native event dispatch priorities.
    1:     if (++gNumberOfDocumentsLoading == 1) {
    1:       // Hint to favor performance for the plevent notification mechanism.
    1:       // We want the pages to load as fast as possible even if its means 
    1:       // native messages might be starved.
    1:       FavorPerformanceHint(PR_TRUE, NS_EVENT_STARVATION_DELAY_HINT);
    1:     }
    1: 
    1:     if (onLocationChangeNeeded) {
71723:       FireOnLocationChange(this, request, mCurrentURI);
    1:     }
    1:   
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::NewContentViewerObj(const char *aContentType,
    1:                                 nsIRequest * request, nsILoadGroup * aLoadGroup,
    1:                                 nsIStreamListener ** aContentHandler,
    1:                                 nsIContentViewer ** aViewer)
    1: {
    1:     nsCOMPtr<nsIChannel> aOpenedChannel = do_QueryInterface(request);
    1: 
43473:     nsCOMPtr<nsIDocumentLoaderFactory> docLoaderFactory =
68796:         nsContentUtils::FindInternalContentViewer(aContentType);
    1:     if (!docLoaderFactory) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Now create an instance of the content viewer
    1:     // nsLayoutDLF makes the determination if it should be a "view-source" instead of "view"
60516:     nsresult rv = docLoaderFactory->CreateInstance("view",
    1:                                                    aOpenedChannel,
    1:                                                    aLoadGroup, aContentType,
 3051:                                                    static_cast<nsIContentViewerContainer*>(this),
 3051:                                                    nsnull,
    1:                                                    aContentHandler,
60516:                                                    aViewer);
60516:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3233:     (*aViewer)->SetContainer(static_cast<nsIContentViewerContainer *>(this));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetupNewViewer(nsIContentViewer * aNewViewer)
    1: {
    1:     //
    1:     // Copy content viewer state from previous or parent content viewer.
    1:     //
    1:     // The following logic is mirrored in nsHTMLDocument::StartDocumentLoad!
    1:     //
    1:     // Do NOT to maintain a reference to the old content viewer outside
    1:     // of this "copying" block, or it will not be destroyed until the end of
    1:     // this routine and all <SCRIPT>s and event handlers fail! (bug 20315)
    1:     //
    1:     // In this block of code, if we get an error result, we return it
    1:     // but if we get a null pointer, that's perfectly legal for parent
    1:     // and parentContentViewer.
    1:     //
    1: 
    1:     PRInt32 x = 0;
    1:     PRInt32 y = 0;
    1:     PRInt32 cx = 0;
    1:     PRInt32 cy = 0;
    1: 
    1:     // This will get the size from the current content viewer or from the
    1:     // Init settings
 1027:     DoGetPositionAndSize(&x, &y, &cx, &cy);
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
    1:     NS_ENSURE_SUCCESS(GetSameTypeParent(getter_AddRefs(parentAsItem)),
    1:                       NS_ERROR_FAILURE);
    1:     nsCOMPtr<nsIDocShell> parent(do_QueryInterface(parentAsItem));
    1: 
    1:     nsCAutoString defaultCharset;
    1:     nsCAutoString forceCharset;
    1:     nsCAutoString hintCharset;
    1:     PRInt32 hintCharsetSource;
    1:     nsCAutoString prevDocCharset;
63383:     PRInt32 minFontSize;
    1:     float textZoom;
 5357:     float pageZoom;
79445:     bool styleDisabled;
    1:     // |newMUDV| also serves as a flag to set the data from the above vars
71056:     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV;
    1: 
    1:     if (mContentViewer || parent) {
71056:         nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV;
    1:         if (mContentViewer) {
    1:             // Get any interesting state from old content viewer
    1:             // XXX: it would be far better to just reuse the document viewer ,
    1:             //      since we know we're just displaying the same document as before
    1:             oldMUDV = do_QueryInterface(mContentViewer);
    1: 
    1:             // Tell the old content viewer to hibernate in session history when
    1:             // it is destroyed.
    1: 
    1:             if (mSavingOldViewer && NS_FAILED(CaptureState())) {
    1:                 if (mOSHE) {
    1:                     mOSHE->SyncPresentationState();
    1:                 }
    1:                 mSavingOldViewer = PR_FALSE;
    1:             }
    1:         }
    1:         else {
    1:             // No old content viewer, so get state from parent's content viewer
    1:             nsCOMPtr<nsIContentViewer> parentContentViewer;
    1:             parent->GetContentViewer(getter_AddRefs(parentContentViewer));
    1:             oldMUDV = do_QueryInterface(parentContentViewer);
    1:         }
    1: 
    1:         if (oldMUDV) {
    1:             nsresult rv;
    1: 
    1:             newMUDV = do_QueryInterface(aNewViewer,&rv);
    1:             if (newMUDV) {
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetDefaultCharacterSet(defaultCharset),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetForceCharacterSet(forceCharset),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetHintCharacterSet(hintCharset),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetHintCharacterSetSource(&hintCharsetSource),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
63383:                                   GetMinFontSize(&minFontSize),
63383:                                   NS_ERROR_FAILURE);
63383:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetTextZoom(&textZoom),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
 5357:                                   GetFullZoom(&pageZoom),
 5357:                                   NS_ERROR_FAILURE);
 5357:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetAuthorStyleDisabled(&styleDisabled),
    1:                                   NS_ERROR_FAILURE);
    1:                 NS_ENSURE_SUCCESS(oldMUDV->
    1:                                   GetPrevDocCharacterSet(prevDocCharset),
    1:                                   NS_ERROR_FAILURE);
    1:             }
    1:         }
    1:     }
    1: 
    1:     nscolor bgcolor = NS_RGBA(0, 0, 0, 0);
    1:     // Ensure that the content viewer is destroyed *after* the GC - bug 71515
    1:     nsCOMPtr<nsIContentViewer> kungfuDeathGrip = mContentViewer;
    1:     if (mContentViewer) {
    1:         // Stop any activity that may be happening in the old document before
    1:         // releasing it...
    1:         mContentViewer->Stop();
    1: 
25385:         // Try to extract the canvas background color from the old
25385:         // presentation shell, so we can use it for the next document.
    1:         nsCOMPtr<nsIDocumentViewer> docviewer =
    1:         do_QueryInterface(mContentViewer);
    1: 
    1:         if (docviewer) {
    1:             nsCOMPtr<nsIPresShell> shell;
    1:             docviewer->GetPresShell(getter_AddRefs(shell));
    1: 
    1:             if (shell) {
25385:                 bgcolor = shell->GetCanvasBackground();
    1:             }
    1:         }
    1: 
    1:         mContentViewer->Close(mSavingOldViewer ? mOSHE.get() : nsnull);
    1:         aNewViewer->SetPreviousViewer(mContentViewer);
62825:     }
62825:     if (mOSHE && (!mContentViewer || !mSavingOldViewer)) {
62825:         // We don't plan to save a viewer in mOSHE; tell it to drop
62825:         // any other state it's holding.
62825:         mOSHE->SyncPresentationState();
62825:     }
    1: 
    1:     mContentViewer = nsnull;
    1: 
36625:     // Now that we're about to switch documents, forget all of our children.
36625:     // Note that we cached them as needed up in CaptureState above.
36625:     DestroyChildren();
36625: 
    1:     mContentViewer = aNewViewer;
    1: 
    1:     nsCOMPtr<nsIWidget> widget;
    1:     NS_ENSURE_SUCCESS(GetMainWidget(getter_AddRefs(widget)), NS_ERROR_FAILURE);
    1: 
23738:     nsIntRect bounds(x, y, cx, cy);
    1: 
72298:     nsCOMPtr<nsIDocumentViewer> docviewer =
72298:         do_QueryInterface(mContentViewer);
72298:     if (docviewer) {
72298:         docviewer->SetNavigationTiming(mTiming);
72298:     }
72298: 
17009:     if (NS_FAILED(mContentViewer->Init(widget, bounds))) {
    1:         mContentViewer = nsnull;
    1:         NS_ERROR("ContentViewer Initialization failed");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // If we have old state to copy, set the old state onto the new content
    1:     // viewer
    1:     if (newMUDV) {
    1:         NS_ENSURE_SUCCESS(newMUDV->SetDefaultCharacterSet(defaultCharset),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetForceCharacterSet(forceCharset),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetHintCharacterSet(hintCharset),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->
    1:                           SetHintCharacterSetSource(hintCharsetSource),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetPrevDocCharacterSet(prevDocCharset),
    1:                           NS_ERROR_FAILURE);
63383:         NS_ENSURE_SUCCESS(newMUDV->SetMinFontSize(minFontSize),
63383:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetTextZoom(textZoom),
    1:                           NS_ERROR_FAILURE);
 5357:         NS_ENSURE_SUCCESS(newMUDV->SetFullZoom(pageZoom),
 5357:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_SUCCESS(newMUDV->SetAuthorStyleDisabled(styleDisabled),
    1:                           NS_ERROR_FAILURE);
    1:     }
    1: 
25385:     // Stuff the bgcolor from the old pres shell into the new
25385:     // pres shell. This improves page load continuity.
    1:     if (docviewer) {
    1:         nsCOMPtr<nsIPresShell> shell;
    1:         docviewer->GetPresShell(getter_AddRefs(shell));
    1: 
    1:         if (shell) {
25385:             shell->SetCanvasBackground(bgcolor);
    1:         }
    1:     }
    1: 
    1: // XXX: It looks like the LayoutState gets restored again in Embed()
    1: //      right after the call to SetupNewViewer(...)
    1: 
    1:     // We don't show the mContentViewer yet, since we want to draw the old page
    1:     // until we have enough of the new page to show.  Just return with the new
    1:     // viewer still set to hidden.
    1: 
    1:     return NS_OK;
    1: }
    1: 
37802: nsresult
62765: nsDocShell::SetDocCurrentStateObj(nsISHEntry *shEntry)
37802: {
37802:     nsCOMPtr<nsIDocument> document = do_GetInterface(GetAsSupports(this));
37802:     NS_ENSURE_TRUE(document, NS_ERROR_FAILURE);
37802: 
69563:     nsCOMPtr<nsIStructuredCloneContainer> scContainer;
70002:     if (shEntry) {
69563:         nsresult rv = shEntry->GetStateData(getter_AddRefs(scContainer));
37802:         NS_ENSURE_SUCCESS(rv, rv);
37802: 
70002:         // If shEntry is null, just set the document's state object to null.
70002:     }
70002: 
69563:     // It's OK for scContainer too be null here; that just means there's no
69563:     // state data associated with this history entry.
69563:     document->SetStateObject(scContainer);
69563: 
37802:     return NS_OK;
37802: }
    1: 
    1: nsresult
    1: nsDocShell::CheckLoadingPermissions()
    1: {
    1:     // This method checks whether the caller may load content into
    1:     // this docshell. Even though we've done our best to hide windows
    1:     // from code that doesn't have the right to access them, it's
    1:     // still possible for an evil site to open a window and access
    1:     // frames in the new window through window.frames[] (which is
    1:     // allAccess for historic reasons), so we still need to do this
    1:     // check on load.
    1:     nsresult rv = NS_OK, sameOrigin = NS_OK;
    1: 
    1:     if (!gValidateOrigin || !IsFrame()) {
    1:         // Origin validation was turned off, or we're not a frame.
    1:         // Permit all loads.
    1: 
    1:         return rv;
    1:     }
    1: 
    1:     // We're a frame. Check that the caller has write permission to
    1:     // the parent before allowing it to load anything into this
    1:     // docshell.
    1: 
    1:     nsCOMPtr<nsIScriptSecurityManager> securityManager =
    1:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
79445:     bool ubwEnabled = false;
    1:     rv = securityManager->IsCapabilityEnabled("UniversalBrowserWrite",
    1:                                               &ubwEnabled);
    1:     if (NS_FAILED(rv) || ubwEnabled) {
    1:         return rv;
    1:     }
    1: 
    1:     nsCOMPtr<nsIPrincipal> subjPrincipal;
    1:     rv = securityManager->GetSubjectPrincipal(getter_AddRefs(subjPrincipal));
    1:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && subjPrincipal, rv);
    1: 
    1:     // Check if the caller is from the same origin as this docshell,
24692:     // or any of its ancestors.
    1:     nsCOMPtr<nsIDocShellTreeItem> item(this);
    1:     do {
    1:         nsCOMPtr<nsIScriptGlobalObject> sgo(do_GetInterface(item));
    1:         nsCOMPtr<nsIScriptObjectPrincipal> sop(do_QueryInterface(sgo));
    1: 
    1:         nsIPrincipal *p;
    1:         if (!sop || !(p = sop->GetPrincipal())) {
    1:             return NS_ERROR_UNEXPECTED;
    1:         }
    1: 
    1:         // Compare origins
79445:         bool equal;
 3286:         sameOrigin = subjPrincipal->Equals(p, &equal);
    1:         if (NS_SUCCEEDED(sameOrigin)) {
 3286:             if (equal) {
    1:                 // Same origin, permit load
    1: 
    1:                 return sameOrigin;
    1:             }
    1: 
 3286:             sameOrigin = NS_ERROR_DOM_PROP_ACCESS_DENIED;
 3286:         }
 3286: 
    1:         nsCOMPtr<nsIDocShellTreeItem> tmp;
    1:         item->GetSameTypeParent(getter_AddRefs(tmp));
    1:         item.swap(tmp);
    1:     } while (item);
    1: 
    1:     return sameOrigin;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: Site Loading
    1: //*****************************************************************************   
70868: namespace
70868: {
70868: 
70868: // Callback used by CopyFavicon to inform the favicon service that one URI
70868: // (mNewURI) has the same favicon URI (OnFaviconDataAvailable's aFaviconURI) as
70868: // another.
70868: class nsCopyFaviconCallback : public nsIFaviconDataCallback
70868: {
70868: public:
70868:     NS_DECL_ISUPPORTS
70868: 
70868:     nsCopyFaviconCallback(nsIURI *aNewURI)
70868:       : mNewURI(aNewURI)
70868:     {
70868:     }
70868: 
70868:     NS_IMETHODIMP
70868:     OnFaviconDataAvailable(nsIURI *aFaviconURI, PRUint32 aDataLen,
70868:                            const PRUint8 *aData, const nsACString &aMimeType)
70868:     {
70868:         NS_ASSERTION(aDataLen == 0,
70868:                      "We weren't expecting the callback to deliver data.");
70868:         nsCOMPtr<mozIAsyncFavicons> favSvc =
70868:             do_GetService("@mozilla.org/browser/favicon-service;1");
70868:         NS_ENSURE_STATE(favSvc);
70868: 
70868:         return favSvc->SetAndFetchFaviconForPage(mNewURI, aFaviconURI,
70868:                                                  PR_FALSE, nsnull);
70868:     }
70868: 
70868: private:
70868:     nsCOMPtr<nsIURI> mNewURI;
70868: };
70868: 
70868: NS_IMPL_ISUPPORTS1(nsCopyFaviconCallback, nsIFaviconDataCallback)
70868: 
70868: // Tell the favicon service that aNewURI has the same favicon as aOldURI.
70868: void CopyFavicon(nsIURI *aOldURI, nsIURI *aNewURI)
70868: {
70868:     nsCOMPtr<mozIAsyncFavicons> favSvc =
70868:         do_GetService("@mozilla.org/browser/favicon-service;1");
70868:     if (favSvc) {
70868:         nsCOMPtr<nsIFaviconDataCallback> callback =
70868:             new nsCopyFaviconCallback(aNewURI);
70868:         favSvc->GetFaviconURLForPage(aOldURI, callback);
70868:     }
70868: }
70868: 
70868: } // anonymous namespace
70868: 
10676: class InternalLoadEvent : public nsRunnable
10676: {
10676: public:
10676:     InternalLoadEvent(nsDocShell* aDocShell, nsIURI * aURI, nsIURI * aReferrer,
10676:                       nsISupports * aOwner, PRUint32 aFlags,
10999:                       const char* aTypeHint, nsIInputStream * aPostData,
10676:                       nsIInputStream * aHeadersData, PRUint32 aLoadType,
79445:                       nsISHEntry * aSHEntry, bool aFirstParty) :
10676:         mDocShell(aDocShell),
10676:         mURI(aURI),
10676:         mReferrer(aReferrer),
10676:         mOwner(aOwner),
10676:         mPostData(aPostData),
10676:         mHeadersData(aHeadersData),
28564:         mSHEntry(aSHEntry),
28564:         mFlags(aFlags),
10676:         mLoadType(aLoadType),
10676:         mFirstParty(aFirstParty)
10676:     {
10676:         // Make sure to keep null things null as needed
10676:         if (aTypeHint) {
10676:             mTypeHint = aTypeHint;
10676:         }
10676:     }
10676:     
10676:     NS_IMETHOD Run() {
10676:         return mDocShell->InternalLoad(mURI, mReferrer, mOwner, mFlags,
10999:                                        nsnull, mTypeHint.get(),
10676:                                        mPostData, mHeadersData, mLoadType,
54823:                                        mSHEntry, mFirstParty, nsnull, nsnull);
10676:     }
10676: 
10676: private:
28564: 
28564:     // Use IDL strings so .get() returns null by default
28564:     nsXPIDLString mWindowTarget;
28564:     nsXPIDLCString mTypeHint;
28564: 
10676:     nsRefPtr<nsDocShell> mDocShell;
10676:     nsCOMPtr<nsIURI> mURI;
10676:     nsCOMPtr<nsIURI> mReferrer;
10676:     nsCOMPtr<nsISupports> mOwner;
10676:     nsCOMPtr<nsIInputStream> mPostData;
10676:     nsCOMPtr<nsIInputStream> mHeadersData;
28564:     nsCOMPtr<nsISHEntry> mSHEntry;
28564:     PRUint32 mFlags;
10676:     PRUint32 mLoadType;
79445:     bool mFirstParty;
10676: };
10676: 
    1: NS_IMETHODIMP
    1: nsDocShell::InternalLoad(nsIURI * aURI,
    1:                          nsIURI * aReferrer,
    1:                          nsISupports * aOwner,
    1:                          PRUint32 aFlags,
    1:                          const PRUnichar *aWindowTarget,
    1:                          const char* aTypeHint,
    1:                          nsIInputStream * aPostData,
    1:                          nsIInputStream * aHeadersData,
    1:                          PRUint32 aLoadType,
    1:                          nsISHEntry * aSHEntry,
79445:                          bool aFirstParty,
    1:                          nsIDocShell** aDocShell,
54823:                          nsIRequest** aRequest)
    1: {
    1:     nsresult rv = NS_OK;
    1: 
    1: #ifdef PR_LOGGING
    1:     if (gDocShellLeakLog && PR_LOG_TEST(gDocShellLeakLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         if (aURI)
    1:             aURI->GetSpec(spec);
    1:         PR_LogPrint("DOCSHELL %p InternalLoad %s\n", this, spec.get());
    1:     }
    1: #endif
    1:     
    1:     // Initialize aDocShell/aRequest
    1:     if (aDocShell) {
    1:         *aDocShell = nsnull;
    1:     }
    1:     if (aRequest) {
    1:         *aRequest = nsnull;
    1:     }
    1: 
    1:     if (!aURI) {
    1:         return NS_ERROR_NULL_POINTER;
    1:     }
    1: 
    1:     NS_ENSURE_TRUE(IsValidLoadType(aLoadType), NS_ERROR_INVALID_ARG);
    1: 
    1:     NS_ENSURE_TRUE(!mIsBeingDestroyed, NS_ERROR_NOT_AVAILABLE);
    1: 
    1:     // wyciwyg urls can only be loaded through history. Any normal load of
    1:     // wyciwyg through docshell is  illegal. Disallow such loads.
    1:     if (aLoadType & LOAD_CMD_NORMAL) {
79445:         bool isWyciwyg = false;
    1:         rv = aURI->SchemeIs("wyciwyg", &isWyciwyg);   
    1:         if ((isWyciwyg && NS_SUCCEEDED(rv)) || NS_FAILED(rv)) 
    1:             return NS_ERROR_FAILURE;
    1:     }
    1: 
79445:     bool bIsJavascript = false;
    1:     if (NS_FAILED(aURI->SchemeIs("javascript", &bIsJavascript))) {
    1:         bIsJavascript = PR_FALSE;
    1:     }
    1: 
    1:     //
    1:     // First, notify any nsIContentPolicy listeners about the document load.
    1:     // Only abort the load if a content policy listener explicitly vetos it!
    1:     //
    1:     nsCOMPtr<nsIDOMElement> requestingElement;
    1:     // Use nsPIDOMWindow since we _want_ to cross the chrome boundary if needed
    1:     nsCOMPtr<nsPIDOMWindow> privateWin(do_QueryInterface(mScriptGlobal));
    1:     if (privateWin)
    1:         requestingElement = privateWin->GetFrameElementInternal();
    1: 
    1:     PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
    1:     PRUint32 contentType;
    1:     if (IsFrame()) {
    1:         NS_ASSERTION(requestingElement, "A frame but no DOM element!?");
    1:         contentType = nsIContentPolicy::TYPE_SUBDOCUMENT;
    1:     } else {
    1:         contentType = nsIContentPolicy::TYPE_DOCUMENT;
    1:     }
    1: 
    1:     nsISupports* context = requestingElement;
    1:     if (!context) {
    1:         context =  mScriptGlobal;
    1:     }
 4444: 
 4367:     // XXXbz would be nice to know the loading principal here... but we don't
 4444:     nsCOMPtr<nsIPrincipal> loadingPrincipal;
 4444:     if (aReferrer) {
 4444:         nsCOMPtr<nsIScriptSecurityManager> secMan =
 4444:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
 4444:         NS_ENSURE_SUCCESS(rv, rv);
 4444: 
 4444:         rv = secMan->GetCodebasePrincipal(aReferrer,
 4444:                                           getter_AddRefs(loadingPrincipal));
 4444:     }
 4444:     
    1:     rv = NS_CheckContentLoadPolicy(contentType,
    1:                                    aURI,
 4444:                                    loadingPrincipal,
    1:                                    context,
    1:                                    EmptyCString(), //mime guess
    1:                                    nsnull,         //extra
    1:                                    &shouldLoad);
    1: 
    1:     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
    1:         if (NS_SUCCEEDED(rv) && shouldLoad == nsIContentPolicy::REJECT_TYPE) {
    1:             return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
    1:         }
    1: 
    1:         return NS_ERROR_CONTENT_BLOCKED;
    1:     }
    1: 
    1:     nsCOMPtr<nsISupports> owner(aOwner);
    1:     //
    1:     // Get an owner from the current document if necessary.  Note that we only
15185:     // do this for URIs that inherit a security context and local file URIs;
15185:     // in particular we do NOT do this for about:blank.  This way, random
15185:     // about:blank loads that have no owner (which basically means they were
15185:     // done by someone from chrome manually messing with our nsIWebNavigation
15185:     // or by C++ setting document.location) don't get a funky principal.  If
15185:     // callers want something interesting to happen with the about:blank
15185:     // principal in this case, they should pass an owner in.
    1:     //
    1:     {
79445:         bool inherits;
  853:         // One more twist: Don't inherit the owner for external loads.
  853:         if (aLoadType != LOAD_NORMAL_EXTERNAL && !owner &&
  853:             (aFlags & INTERNAL_LOAD_FLAGS_INHERIT_OWNER) &&
78531:             NS_SUCCEEDED(nsContentUtils::URIInheritsSecurityContext(aURI,
78531:                                                                     &inherits)) &&
27265:             inherits) {
 8363: 
69698:             owner = GetInheritedPrincipal(PR_TRUE);
69698:         }
69698:     }
69698: 
 8363:     // Don't allow loads that would inherit our security context
 8363:     // if this document came from an unsafe channel.
69698:     {
79445:         bool willInherit;
78531:         // This condition needs to match the one in
78531:         // nsContentUtils::SetUpChannelOwner.
69698:         // Except we reverse the rv check to be safe in case
78531:         // nsContentUtils::URIInheritsSecurityContext fails here and
78531:         // succeeds there.
78531:         rv = nsContentUtils::URIInheritsSecurityContext(aURI, &willInherit);
78530:         if (NS_FAILED(rv) || willInherit || NS_IsAboutBlank(aURI)) {
 8363:             nsCOMPtr<nsIDocShellTreeItem> treeItem = this;
 8363:             do {
 8363:                 nsCOMPtr<nsIDocShell> itemDocShell =
 8363:                     do_QueryInterface(treeItem);
79445:                 bool isUnsafe;
 8363:                 if (itemDocShell &&
 8363:                     NS_SUCCEEDED(itemDocShell->GetChannelIsUnsafe(&isUnsafe)) &&
 8363:                     isUnsafe) {
 8363:                     return NS_ERROR_DOM_SECURITY_ERR;
 8363:                 }
 8363: 
 8363:                 nsCOMPtr<nsIDocShellTreeItem> parent;
 8363:                 treeItem->GetSameTypeParent(getter_AddRefs(parent));
 8363:                 parent.swap(treeItem);
 8363:             } while (treeItem);
    1:         }
    1:     }
    1:     
    1:     //
    1:     // Resolve the window target before going any further...
    1:     // If the load has been targeted to another DocShell, then transfer the
    1:     // load to it...
    1:     //
    1:     if (aWindowTarget && *aWindowTarget) {
    1:         // We've already done our owner-inheriting.  Mask out that bit, so we
    1:         // don't try inheriting an owner from the target window if we came up
    1:         // with a null owner above.
    1:         aFlags = aFlags & ~INTERNAL_LOAD_FLAGS_INHERIT_OWNER;
    1:         
    1:         // Locate the target DocShell.
    1:         // This may involve creating a new toplevel window - if necessary.
    1:         //
    1:         nsCOMPtr<nsIDocShellTreeItem> targetItem;
    1:         FindItemWithName(aWindowTarget, nsnull, this,
    1:                          getter_AddRefs(targetItem));
    1: 
    1:         nsCOMPtr<nsIDocShell> targetDocShell = do_QueryInterface(targetItem);
    1:         
79445:         bool isNewWindow = false;
    1:         if (!targetDocShell) {
73870:             nsCOMPtr<nsIDOMWindow> win =
    1:                 do_GetInterface(GetAsSupports(this));
    1:             NS_ENSURE_TRUE(win, NS_ERROR_NOT_AVAILABLE);
    1: 
    1:             nsDependentString name(aWindowTarget);
    1:             nsCOMPtr<nsIDOMWindow> newWin;
    1:             rv = win->Open(EmptyString(), // URL to load
    1:                            name,          // window name
    1:                            EmptyString(), // Features
    1:                            getter_AddRefs(newWin));
    1: 
    1:             // In some cases the Open call doesn't actually result in a new
    1:             // window being opened.  We can detect these cases by examining the
    1:             // document in |newWin|, if any.
    1:             nsCOMPtr<nsPIDOMWindow> piNewWin = do_QueryInterface(newWin);
    1:             if (piNewWin) {
    1:                 nsCOMPtr<nsIDocument> newDoc =
    1:                     do_QueryInterface(piNewWin->GetExtantDocument());
    1:                 if (!newDoc || newDoc->IsInitialDocument()) {
    1:                     isNewWindow = PR_TRUE;
    1:                     aFlags |= INTERNAL_LOAD_FLAGS_FIRST_LOAD;
    1:                 }
    1:             }
    1: 
    1:             nsCOMPtr<nsIWebNavigation> webNav = do_GetInterface(newWin);
    1:             targetDocShell = do_QueryInterface(webNav);
    1:         }
    1: 
    1:         //
    1:         // Transfer the load to the target DocShell...  Pass nsnull as the
    1:         // window target name from to prevent recursive retargeting!
    1:         //
    1:         if (NS_SUCCEEDED(rv) && targetDocShell) {
    1:             rv = targetDocShell->InternalLoad(aURI,
    1:                                               aReferrer,
    1:                                               owner,
    1:                                               aFlags,
    1:                                               nsnull,         // No window target
    1:                                               aTypeHint,
    1:                                               aPostData,
    1:                                               aHeadersData,
    1:                                               aLoadType,
    1:                                               aSHEntry,
    1:                                               aFirstParty,
    1:                                               aDocShell,
54823:                                               aRequest);
    1:             if (rv == NS_ERROR_NO_CONTENT) {
    1:                 // XXXbz except we never reach this code!
    1:                 if (isNewWindow) {
    1:                     //
    1:                     // At this point, a new window has been created, but the
    1:                     // URI did not have any data associated with it...
    1:                     //
    1:                     // So, the best we can do, is to tear down the new window
    1:                     // that was just created!
    1:                     //
73870:                     nsCOMPtr<nsIDOMWindow> domWin =
    1:                         do_GetInterface(targetDocShell);
    1:                     if (domWin) {
    1:                         domWin->Close();
    1:                     }
    1:                 }
    1:                 //
    1:                 // NS_ERROR_NO_CONTENT should not be returned to the
    1:                 // caller... This is an internal error code indicating that
    1:                 // the URI had no data associated with it - probably a 
    1:                 // helper-app style protocol (ie. mailto://)
    1:                 //
    1:                 rv = NS_OK;
    1:             }
    1:             else if (isNewWindow) {
    1:                 // XXX: Once new windows are created hidden, the new
    1:                 //      window will need to be made visible...  For now,
    1:                 //      do nothing.
    1:             }
    1:         }
    1: 
    1:         // Else we ran out of memory, or were a popup and got blocked,
    1:         // or something.
    1:         
    1:         return rv;
    1:     }
    1: 
    1:     //
    1:     // Load is being targetted at this docshell so return an error if the
    1:     // docshell is in the process of being destroyed.
    1:     //
    1:     if (mIsBeingDestroyed) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
10999:     rv = CheckLoadingPermissions();
10999:     if (NS_FAILED(rv)) {
10999:         return rv;
10999:     }
10999: 
14660:     // If this docshell is owned by a frameloader, make sure to cancel
14660:     // possible frameloader initialization before loading a new page.
14660:     nsCOMPtr<nsIDocShellTreeItem> parent;
14660:     GetParent(getter_AddRefs(parent));
14660:     if (parent) {
48097:       nsCOMPtr<nsIDocument> doc = do_GetInterface(parent);
14660:       if (doc) {
14660:         doc->TryCancelFrameLoaderInitialization(this);
14660:       }
14660:     }
14660: 
10999:     if (mFiredUnloadEvent) {
10999:         if (IsOKToLoadURI(aURI)) {
10999:             NS_PRECONDITION(!aWindowTarget || !*aWindowTarget,
10999:                             "Shouldn't have a window target here!");
10999: 
10999:             // If this is a replace load, make whatever load triggered
10999:             // the unload event also a replace load, so we don't
10999:             // create extra history entries.
10999:             if (LOAD_TYPE_HAS_FLAGS(aLoadType, LOAD_FLAGS_REPLACE_HISTORY)) {
10999:                 mLoadType = LOAD_NORMAL_REPLACE;
10999:             }
10999:             
10999:             // Do this asynchronously
10999:             nsCOMPtr<nsIRunnable> ev =
10999:                 new InternalLoadEvent(this, aURI, aReferrer, aOwner, aFlags,
10999:                                       aTypeHint, aPostData, aHeadersData,
10999:                                       aLoadType, aSHEntry, aFirstParty);
10999:             return NS_DispatchToCurrentThread(ev);
10999:         }
10999: 
10999:         // Just ignore this load attempt
10999:         return NS_OK;
10999:     }
10999: 
    1:     // Before going any further vet loads initiated by external programs.
    1:     if (aLoadType == LOAD_NORMAL_EXTERNAL) {
    1:         // Disallow external chrome: loads targetted at content windows
79445:         bool isChrome = false;
    1:         if (NS_SUCCEEDED(aURI->SchemeIs("chrome", &isChrome)) && isChrome) {
    1:             NS_WARNING("blocked external chrome: url -- use '-chrome' option");
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         // clear the decks to prevent context bleed-through (bug 298255)
27151:         rv = CreateAboutBlankContentViewer(nsnull, nsnull);
    1:         if (NS_FAILED(rv))
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         // reset loadType so we don't have to add lots of tests for
    1:         // LOAD_NORMAL_EXTERNAL after this point
    1:         aLoadType = LOAD_NORMAL;
    1:     }
    1: 
    1:     mAllowKeywordFixup =
    1:       (aFlags & INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP) != 0;
    1:     mURIResultedInDocument = PR_FALSE;  // reset the clock...
    1: 
37802:     if (aLoadType == LOAD_NORMAL ||
    1:         aLoadType == LOAD_STOP_CONTENT ||
    1:         LOAD_TYPE_HAS_FLAGS(aLoadType, LOAD_FLAGS_REPLACE_HISTORY) ||
    1:         aLoadType == LOAD_HISTORY ||
37802:         aLoadType == LOAD_LINK) {
37802: 
68728:         // Split mCurrentURI and aURI on the '#' character.  Make sure we read
71389:         // the return values of SplitURIAtHash; if it fails, we don't want to
71389:         // allow a short-circuited navigation.
68728:         nsCAutoString curBeforeHash, curHash, newBeforeHash, newHash;
68728:         nsresult splitRv1, splitRv2;
71389:         splitRv1 = mCurrentURI ?
71389:             nsContentUtils::SplitURIAtHash(mCurrentURI,
71390:                                            curBeforeHash, curHash) :
71390:             NS_ERROR_FAILURE;
68728:         splitRv2 = nsContentUtils::SplitURIAtHash(aURI, newBeforeHash, newHash);
68728: 
79445:         bool sameExceptHashes = NS_SUCCEEDED(splitRv1) &&
68728:                                   NS_SUCCEEDED(splitRv2) &&
68728:                                   curBeforeHash.Equals(newBeforeHash);
68728: 
80309:         bool sameDocIdent = PR_FALSE;
37802:         if (mOSHE && aSHEntry) {
68728:             // We're doing a history load.
68728: 
80309:             PRUint64 ourDocIdent, otherDocIdent;
80309:             mOSHE->GetDocIdentifier(&ourDocIdent);
80309:             aSHEntry->GetDocIdentifier(&otherDocIdent);
80309:             sameDocIdent = (ourDocIdent == otherDocIdent);
68728: 
68728: #ifdef DEBUG
80309:             if (sameDocIdent) {
68728:                 nsCOMPtr<nsIInputStream> currentPostData;
68728:                 mOSHE->GetPostData(getter_AddRefs(currentPostData));
68728:                 NS_ASSERTION(currentPostData == aPostData,
68728:                              "Different POST data for entries for the same page?");
68728:             }
68728: #endif
68728:         }
68728: 
68728:         // A short-circuited load happens when we navigate between two SHEntries
68728:         // for the same document.  We do a short-circuited load under two
68728:         // circumstances.  Either
68728:         //
68728:         //  a) we're navigating between two different SHEntries which have the
68728:         //     same document identifiers, or
68728:         //
68728:         //  b) we're navigating to a new shentry whose URI differs from the
68728:         //     current URI only in its hash, the new hash is non-empty, and
68728:         //     we're not doing a POST.
68728:         //
68728:         // The restriction tha the SHEntries in (a) must be different ensures
68728:         // that history.go(0) and the like trigger full refreshes, rather than
68728:         // short-circuited loads.
80309:         bool doShortCircuitedLoad = (sameDocIdent && mOSHE != aSHEntry) ||
68728:                                       (!aSHEntry && aPostData == nsnull &&
68728:                                        sameExceptHashes && !newHash.IsEmpty());
68728: 
68728:         // Fire a hashchange event if we're doing a short-circuited load and the
68728:         // URIs differ only in their hashes.
79445:         bool doHashchange = doShortCircuitedLoad &&
68728:                               sameExceptHashes &&
68728:                               !curHash.Equals(newHash);
68728: 
68728:         if (doShortCircuitedLoad) {
68729:             // Save the current URI; we need it if we fire a hashchange later.
68729:             nsCOMPtr<nsIURI> oldURI = mCurrentURI;
68729: 
68728:             // Save the position of the scrollers.
68728:             nscoord cx = 0, cy = 0;
68728:             GetCurScrollPos(ScrollOrientation_X, &cx);
68728:             GetCurScrollPos(ScrollOrientation_Y, &cy);
68728: 
77010:             // ScrollToAnchor doesn't necessarily cause us to scroll the window;
77010:             // the function decides whether a scroll is appropriate based on the
77010:             // arguments it receives.  But even if we don't end up scrolling,
77010:             // ScrollToAnchor performs other important tasks, such as informing
77010:             // the presShell that we have a new hash.  See bug 680257.
71441:             rv = ScrollToAnchor(curHash, newHash, aLoadType);
68728:             NS_ENSURE_SUCCESS(rv, rv);
68728: 
    1:             mLoadType = aLoadType;
    1:             mURIResultedInDocument = PR_TRUE;
    1: 
    1:             /* we need to assign mLSHE to aSHEntry right here, so that on History loads,
    1:              * SetCurrentURI() called from OnNewURI() will send proper
    1:              * onLocationChange() notifications to the browser to update
    1:              * back/forward buttons.
    1:              */
    1:             SetHistoryEntry(&mLSHE, aSHEntry);
    1: 
    1:             /* This is a anchor traversal with in the same page.
    1:              * call OnNewURI() so that, this traversal will be 
    1:              * recorded in session and global history.
    1:              */
22687:             nsCOMPtr<nsISupports> owner;
22687:             if (mOSHE) {
22687:                 mOSHE->GetOwner(getter_AddRefs(owner));
22687:             }
64491:             // Pass true for aCloneSHChildren, since we're not
64491:             // changing documents here, so all of our subframes are
64491:             // still relevant to the new session history entry.
64491:             OnNewURI(aURI, nsnull, owner, mLoadType, PR_TRUE, PR_TRUE, PR_TRUE);
37802: 
    1:             nsCOMPtr<nsIInputStream> postData;
80309:             PRUint64 docIdent = PRUint64(-1);
12420:             nsCOMPtr<nsISupports> cacheKey;
    1: 
    1:             if (mOSHE) {
    1:                 /* save current position of scroller(s) (bug 59774) */
    1:                 mOSHE->SetScrollPosition(cx, cy);
    1:                 // Get the postdata and page ident from the current page, if
    1:                 // the new load is being done via normal means.  Note that
    1:                 // "normal means" can be checked for just by checking for
    1:                 // LOAD_CMD_NORMAL, given the loadType and allowScroll check
    1:                 // above -- it filters out some LOAD_CMD_NORMAL cases that we
    1:                 // wouldn't want here.
    1:                 if (aLoadType & LOAD_CMD_NORMAL) {
    1:                     mOSHE->GetPostData(getter_AddRefs(postData));
80309:                     mOSHE->GetDocIdentifier(&docIdent);
12420:                     mOSHE->GetCacheKey(getter_AddRefs(cacheKey));
    1:                 }
    1:             }
    1: 
    1:             /* Assign mOSHE to mLSHE. This will either be a new entry created
    1:              * by OnNewURI() for normal loads or aSHEntry for history loads.
    1:              */
    1:             if (mLSHE) {
    1:                 SetHistoryEntry(&mOSHE, mLSHE);
    1:                 // Save the postData obtained from the previous page
    1:                 // in to the session history entry created for the 
    1:                 // anchor page, so that any history load of the anchor
    1:                 // page will restore the appropriate postData.
    1:                 if (postData)
    1:                     mOSHE->SetPostData(postData);
    1: 
12420:                 // Make sure we won't just repost without hitting the
12420:                 // cache first
12420:                 if (cacheKey)
12420:                     mOSHE->SetCacheKey(cacheKey);
80309: 
80309:                 // Propagate our document identifier to the new mOSHE so that
80309:                 // we'll know it's related by an anchor navigation or pushState.
80309:                 if (docIdent != PRUint64(-1))
80309:                     mOSHE->SetDocIdentifier(docIdent);
    1:             }
    1: 
    1:             /* restore previous position of scroller(s), if we're moving
    1:              * back in history (bug 59774)
    1:              */
    1:             if (mOSHE && (aLoadType == LOAD_HISTORY || aLoadType == LOAD_RELOAD_NORMAL))
    1:             {
    1:                 nscoord bx, by;
    1:                 mOSHE->GetScrollPosition(&bx, &by);
    1:                 SetCurScrollPosEx(bx, by);
    1:             }
    1: 
    1:             /* Clear out mLSHE so that further anchor visits get
    1:              * recorded in SH and SH won't misbehave. 
    1:              */
    1:             SetHistoryEntry(&mLSHE, nsnull);
    1:             /* Set the title for the SH entry for this target url. so that
    1:              * SH menus in go/back/forward buttons won't be empty for this.
    1:              */
    1:             if (mSessionHistory) {
    1:                 PRInt32 index = -1;
    1:                 mSessionHistory->GetIndex(&index);
    1:                 nsCOMPtr<nsIHistoryEntry> hEntry;
    1:                 mSessionHistory->GetEntryAtIndex(index, PR_FALSE,
    1:                                                  getter_AddRefs(hEntry));
    1:                 NS_ENSURE_TRUE(hEntry, NS_ERROR_FAILURE);
    1:                 nsCOMPtr<nsISHEntry> shEntry(do_QueryInterface(hEntry));
    1:                 if (shEntry)
    1:                     shEntry->SetTitle(mTitle);
    1:             }
    1: 
39380:             /* Set the title for the Global History entry for this anchor url.
39380:              */
61540:             if (mUseGlobalHistory) {
50529:                 nsCOMPtr<IHistory> history = services::GetHistoryService();
50529:                 if (history) {
50529:                     history->SetURITitle(aURI, mTitle);
50529:                 }
50529:                 else if (mGlobalHistory) {
39380:                     mGlobalHistory->SetPageTitle(aURI, mTitle);
39380:                 }
61540:             }
39380: 
80309:             if (sameDocIdent) {
37802:                 // Set the doc's URI according to the new history entry's URI
37802:                 nsCOMPtr<nsIURI> newURI;
37802:                 mOSHE->GetURI(getter_AddRefs(newURI));
37802:                 NS_ENSURE_TRUE(newURI, NS_ERROR_FAILURE);
37802:                 nsCOMPtr<nsIDocument> doc =
37802:                   do_GetInterface(GetAsSupports(this));
37802:                 NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
37802: 
37802:                 doc->SetDocumentURI(newURI);
37802:             }
37802: 
62765:             SetDocCurrentStateObj(mOSHE);
37802: 
62730:             // Dispatch the popstate and hashchange events, as appropriate.
37802:             nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(mScriptGlobal);
37802:             if (window) {
80309:                 // Need the doHashchange check here since sameDocIdent is
63196:                 // false if we're navigating to a new shentry (i.e. a aSHEntry
63196:                 // is null), such as when clicking a <a href="#foo">.
80309:                 if (sameDocIdent || doHashchange) {
63195:                   window->DispatchSyncPopState();
63196:                 }
37802: 
68729:                 if (doHashchange) {
68729:                   // Make sure to use oldURI here, not mCurrentURI, because by
68729:                   // now, mCurrentURI has changed!
68729:                   window->DispatchAsyncHashchange(oldURI, aURI);
68729:                 }
29975:             }
29975: 
70868:             // Inform the favicon service that the favicon for oldURI also
70868:             // applies to aURI.
70868:             CopyFavicon(oldURI, aURI);
70868: 
    1:             return NS_OK;
    1:         }
    1:     }
    1:     
    1:     // mContentViewer->PermitUnload can destroy |this| docShell, which
    1:     // causes the next call of CanSavePresentation to crash. 
    1:     // Hold onto |this| until we return, to prevent a crash from happening. 
    1:     // (bug#331040)
    1:     nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
    1: 
72298:     rv = MaybeInitTiming();
72298:     if (mTiming) {
72298:       mTiming->NotifyBeforeUnload();
72298:     }
    1:     // Check if the page doesn't want to be unloaded. The javascript:
    1:     // protocol handler deals with this for javascript: URLs.
    1:     if (!bIsJavascript && mContentViewer) {
79445:         bool okToUnload;
34032:         rv = mContentViewer->PermitUnload(PR_FALSE, &okToUnload);
    1: 
    1:         if (NS_SUCCEEDED(rv) && !okToUnload) {
    1:             // The user chose not to unload the page, interrupt the
    1:             // load.
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
72298:     if (mTiming) {
72298:       mTiming->NotifyUnloadAccepted(mCurrentURI);
72298:     }
72298: 
    1:     // Check for saving the presentation here, before calling Stop().
    1:     // This is necessary so that we can catch any pending requests.
    1:     // Since the new request has not been created yet, we pass null for the
    1:     // new request parameter.
    1:     // Also pass nsnull for the document, since it doesn't affect the return
    1:     // value for our purposes here.
79445:     bool savePresentation = CanSavePresentation(aLoadType, nsnull, nsnull);
    1: 
    1:     // Don't stop current network activity for javascript: URL's since
    1:     // they might not result in any data, and thus nothing should be
    1:     // stopped in those cases. In the case where they do result in
    1:     // data, the javascript: URL channel takes care of stopping
    1:     // current network activity.
    1:     if (!bIsJavascript) {
    1:         // Stop any current network activity.
    1:         // Also stop content if this is a zombie doc. otherwise 
    1:         // the onload will be delayed by other loads initiated in the 
    1:         // background by the first document that
    1:         // didn't fully load before the next load was initiated.
    1:         // If not a zombie, don't stop content until data 
    1:         // starts arriving from the new URI...
    1: 
    1:         nsCOMPtr<nsIContentViewer> zombieViewer;
    1:         if (mContentViewer) {
    1:             mContentViewer->GetPreviousViewer(getter_AddRefs(zombieViewer));
    1:         }
    1: 
    1:         if (zombieViewer ||
    1:             LOAD_TYPE_HAS_FLAGS(aLoadType, LOAD_FLAGS_STOP_CONTENT)) {
    1:             rv = Stop(nsIWebNavigation::STOP_ALL);
    1:         } else {
    1:             rv = Stop(nsIWebNavigation::STOP_NETWORK);
    1:         }
    1: 
    1:         if (NS_FAILED(rv)) 
    1:             return rv;
    1:     }
    1: 
    1:     mLoadType = aLoadType;
    1: 
    1:     // mLSHE should be assigned to aSHEntry, only after Stop() has
    1:     // been called. But when loading an error page, do not clear the
    1:     // mLSHE for the real page.
    1:     if (mLoadType != LOAD_ERROR_PAGE)
    1:         SetHistoryEntry(&mLSHE, aSHEntry);
    1: 
    1:     mSavingOldViewer = savePresentation;
    1: 
    1:     // If we have a saved content viewer in history, restore and show it now.
    1:     if (aSHEntry && (mLoadType & LOAD_CMD_HISTORY)) {
50721:         // Make sure our history ID points to the same ID as
50721:         // SHEntry's docshell ID.
50721:         aSHEntry->GetDocshellID(&mHistoryID);
50721: 
 6685:         // It's possible that the previous viewer of mContentViewer is the
 6685:         // viewer that will end up in aSHEntry when it gets closed.  If that's
 6685:         // the case, we need to go ahead and force it into its shentry so we
 6685:         // can restore it.
 6685:         if (mContentViewer) {
 6685:             nsCOMPtr<nsIContentViewer> prevViewer;
 6685:             mContentViewer->GetPreviousViewer(getter_AddRefs(prevViewer));
 6685:             if (prevViewer) {
 6685: #ifdef DEBUG
 6685:                 nsCOMPtr<nsIContentViewer> prevPrevViewer;
 6685:                 prevViewer->GetPreviousViewer(getter_AddRefs(prevPrevViewer));
 6685:                 NS_ASSERTION(!prevPrevViewer, "Should never have viewer chain here");
 6685: #endif
 6685:                 nsCOMPtr<nsISHEntry> viewerEntry;
 6685:                 prevViewer->GetHistoryEntry(getter_AddRefs(viewerEntry));
 6685:                 if (viewerEntry == aSHEntry) {
 6685:                     // Make sure this viewer ends up in the right place
 6685:                     mContentViewer->SetPreviousViewer(nsnull);
 6685:                     prevViewer->Destroy();
 6685:                 }
 6685:             }
 6685:         }
    1:         nsCOMPtr<nsISHEntry> oldEntry = mOSHE;
79445:         bool restoring;
    1:         rv = RestorePresentation(aSHEntry, &restoring);
    1:         if (restoring)
    1:             return rv;
    1: 
    1:         // We failed to restore the presentation, so clean up.
    1:         // Both the old and new history entries could potentially be in
    1:         // an inconsistent state.
    1:         if (NS_FAILED(rv)) {
    1:             if (oldEntry)
    1:                 oldEntry->SyncPresentationState();
    1: 
    1:             aSHEntry->SyncPresentationState();
    1:         }
    1:     }
    1: 
    1:     nsCOMPtr<nsIRequest> req;
    1:     rv = DoURILoad(aURI, aReferrer,
    1:                    !(aFlags & INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER),
    1:                    owner, aTypeHint, aPostData, aHeadersData, aFirstParty,
    1:                    aDocShell, getter_AddRefs(req),
10966:                    (aFlags & INTERNAL_LOAD_FLAGS_FIRST_LOAD) != 0,
29288:                    (aFlags & INTERNAL_LOAD_FLAGS_BYPASS_CLASSIFIER) != 0,
54823:                    (aFlags & INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES) != 0);
    1:     if (req && aRequest)
    1:         NS_ADDREF(*aRequest = req);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:         nsCOMPtr<nsIChannel> chan(do_QueryInterface(req));
    1:         DisplayLoadError(rv, aURI, nsnull, chan);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsIPrincipal*
79445: nsDocShell::GetInheritedPrincipal(bool aConsiderCurrentDocument)
    1: {
    1:     nsCOMPtr<nsIDocument> document;
    1: 
    1:     if (aConsiderCurrentDocument && mContentViewer) {
37433:         document = mContentViewer->GetDocument();
    1:     }
    1: 
    1:     if (!document) {
    1:         nsCOMPtr<nsIDocShellTreeItem> parentItem;
    1:         GetSameTypeParent(getter_AddRefs(parentItem));
    1:         if (parentItem) {
48097:             document = do_GetInterface(parentItem);
    1:         }
    1:     }
    1: 
    1:     if (!document) {
    1:         if (!aConsiderCurrentDocument) {
    1:             return nsnull;
    1:         }
    1: 
    1:         // Make sure we end up with _something_ as the principal no matter
    1:         // what.
    1:         EnsureContentViewer();  // If this fails, we'll just get a null
    1:                                 // docViewer and bail.
    1: 
37433:         if (!mContentViewer)
    1:             return nsnull;
37433:         document = mContentViewer->GetDocument();
    1:     }
    1: 
    1:     //-- Get the document's principal
    1:     if (document) {
    1:         return document->NodePrincipal();
    1:     }
    1: 
    1:     return nsnull;
    1: }
    1: 
79445: bool
20651: nsDocShell::ShouldCheckAppCache(nsIURI *aURI)
20651: {
20651:     nsCOMPtr<nsIOfflineCacheUpdateService> offlineService =
20651:         do_GetService(NS_OFFLINECACHEUPDATESERVICE_CONTRACTID);
20651:     if (!offlineService) {
20651:         return PR_FALSE;
20651:     }
20651: 
79445:     bool allowed;
20651:     nsresult rv = offlineService->OfflineAppAllowedForURI(aURI,
20651:                                                           nsnull,
20651:                                                           &allowed);
20651:     return NS_SUCCEEDED(rv) && allowed;
20651: }
20651: 
    1: nsresult
    1: nsDocShell::DoURILoad(nsIURI * aURI,
    1:                       nsIURI * aReferrerURI,
79445:                       bool aSendReferrer,
    1:                       nsISupports * aOwner,
    1:                       const char * aTypeHint,
    1:                       nsIInputStream * aPostData,
    1:                       nsIInputStream * aHeadersData,
79445:                       bool aFirstParty,
    1:                       nsIDocShell ** aDocShell,
    1:                       nsIRequest ** aRequest,
79445:                       bool aIsNewWindowTarget,
79445:                       bool aBypassClassifier,
79445:                       bool aForceAllowCookies)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIURILoader> uriLoader;
    1: 
    1:     uriLoader = do_GetService(NS_URI_LOADER_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
    1:     if (aFirstParty) {
    1:         // tag first party URL loads
    1:         loadFlags |= nsIChannel::LOAD_INITIAL_DOCUMENT_URI;
    1:     }
    1: 
    1:     if (mLoadType == LOAD_ERROR_PAGE) {
    1:         // Error pages are LOAD_BACKGROUND
    1:         loadFlags |= nsIChannel::LOAD_BACKGROUND;
    1:     }
    1: 
41209:     // check for Content Security Policy to pass along with the
41209:     // new channel we are creating
41209:     nsCOMPtr<nsIChannelPolicy> channelPolicy;
41209:     if (IsFrame()) {
41209:         // check the parent docshell for a CSP
41209:         nsCOMPtr<nsIContentSecurityPolicy> csp;
41209:         nsCOMPtr<nsIDocShellTreeItem> parentItem;
41209:         GetSameTypeParent(getter_AddRefs(parentItem));
48097:         nsCOMPtr<nsIDocument> doc = do_GetInterface(parentItem);
41209:         if (doc) {
41209:             rv = doc->NodePrincipal()->GetCsp(getter_AddRefs(csp));
41209:             NS_ENSURE_SUCCESS(rv, rv);
41209:             if (csp) {
41209:                 channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
41209:                 channelPolicy->SetContentSecurityPolicy(csp);
41209:                 channelPolicy->SetLoadType(nsIContentPolicy::TYPE_SUBDOCUMENT);
41209:             }
41209:         }
41209:     }
41209: 
    1:     // open a channel for the url
    1:     nsCOMPtr<nsIChannel> channel;
    1: 
    1:     rv = NS_NewChannel(getter_AddRefs(channel),
    1:                        aURI,
    1:                        nsnull,
    1:                        nsnull,
 3233:                        static_cast<nsIInterfaceRequestor *>(this),
41209:                        loadFlags,
41209:                        channelPolicy);
    1:     if (NS_FAILED(rv)) {
    1:         if (rv == NS_ERROR_UNKNOWN_PROTOCOL) {
    1:             // This is a uri with a protocol scheme we don't know how
    1:             // to handle.  Embedders might still be interested in
    1:             // handling the load, though, so we fire a notification
    1:             // before throwing the load away.
79445:             bool abort = false;
    1:             nsresult rv2 = mContentListener->OnStartURIOpen(aURI, &abort);
    1:             if (NS_SUCCEEDED(rv2) && abort) {
    1:                 // Hey, they're handling the load for us!  How convenient!
    1:                 return NS_OK;
    1:             }
    1:         }
    1:             
    1:         return rv;
    1:     }
    1: 
21311:     nsCOMPtr<nsIApplicationCacheChannel> appCacheChannel =
21311:         do_QueryInterface(channel);
21311:     if (appCacheChannel) {
21366:         // Any document load should not inherit application cache.
21311:         appCacheChannel->SetInheritApplicationCache(PR_FALSE);
21366: 
21366:         // Loads with the correct permissions should check for a matching
21366:         // application cache.
56242:         // Permission will be checked in the parent process
56242:         if (GeckoProcessType_Default != XRE_GetProcessType())
56242:             appCacheChannel->SetChooseApplicationCache(PR_TRUE);
56242:         else
56242:             appCacheChannel->SetChooseApplicationCache(
56242:                 ShouldCheckAppCache(aURI));
21311:     }
21311: 
    1:     // Make sure to give the caller a channel if we managed to create one
    1:     // This is important for correct error page/session history interaction
    1:     if (aRequest)
    1:         NS_ADDREF(*aRequest = channel);
    1: 
    1:     channel->SetOriginalURI(aURI);
    1:     if (aTypeHint && *aTypeHint) {
    1:         channel->SetContentType(nsDependentCString(aTypeHint));
    1:         mContentTypeHint = aTypeHint;
    1:     }
    1:     else {
    1:         mContentTypeHint.Truncate();
    1:     }
    1:     
    1:     //hack
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:     nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal(do_QueryInterface(channel));
    1:     if (httpChannelInternal) {
29288:       if (aForceAllowCookies) {
29288:         httpChannelInternal->SetForceAllowThirdPartyCookie(PR_TRUE);
29288:       } 
    1:       if (aFirstParty) {
    1:         httpChannelInternal->SetDocumentURI(aURI);
    1:       } else {
    1:         httpChannelInternal->SetDocumentURI(aReferrerURI);
    1:       }
    1:     }
    1: 
    1:     nsCOMPtr<nsIWritablePropertyBag2> props(do_QueryInterface(channel));
    1:     if (props)
    1:     {
    1:       // save true referrer for those who need it (e.g. xpinstall whitelisting)
    1:       // Currently only http and ftp channels support this.
    1:       props->SetPropertyAsInterface(NS_LITERAL_STRING("docshell.internalReferrer"),
    1:                                     aReferrerURI);
    1:     }
    1: 
    1:     //
    1:     // If this is a HTTP channel, then set up the HTTP specific information
    1:     // (ie. POST data, referrer, ...)
    1:     //
    1:     if (httpChannel) {
    1:         nsCOMPtr<nsICachingChannel>  cacheChannel(do_QueryInterface(httpChannel));
    1:         /* Get the cache Key from SH */
    1:         nsCOMPtr<nsISupports> cacheKey;
    1:         if (mLSHE) {
    1:             mLSHE->GetCacheKey(getter_AddRefs(cacheKey));
    1:         }
    1:         else if (mOSHE)          // for reload cases
    1:             mOSHE->GetCacheKey(getter_AddRefs(cacheKey));
    1: 
    1:         // figure out if we need to set the post data stream on the channel...
    1:         // right now, this is only done for http channels.....
    1:         if (aPostData) {
    1:             // XXX it's a bit of a hack to rewind the postdata stream here but
    1:             // it has to be done in case the post data is being reused multiple
    1:             // times.
    1:             nsCOMPtr<nsISeekableStream>
    1:                 postDataSeekable(do_QueryInterface(aPostData));
    1:             if (postDataSeekable) {
    1:                 rv = postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
    1:                 NS_ENSURE_SUCCESS(rv, rv);
    1:             }
    1: 
    1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
    1:             NS_ASSERTION(uploadChannel, "http must support nsIUploadChannel");
    1: 
    1:             // we really need to have a content type associated with this stream!!
    1:             uploadChannel->SetUploadStream(aPostData, EmptyCString(), -1);
    1:             /* If there is a valid postdata *and* it is a History Load,
    1:              * set up the cache key on the channel, to retrieve the
    1:              * data *only* from the cache. If it is a normal reload, the 
    1:              * cache is free to go to the server for updated postdata. 
    1:              */
    1:             if (cacheChannel && cacheKey) {
    1:                 if (mLoadType == LOAD_HISTORY || mLoadType == LOAD_RELOAD_CHARSET_CHANGE) {
    1:                     cacheChannel->SetCacheKey(cacheKey);
    1:                     PRUint32 loadFlags;
    1:                     if (NS_SUCCEEDED(channel->GetLoadFlags(&loadFlags)))
    1:                         channel->SetLoadFlags(loadFlags | nsICachingChannel::LOAD_ONLY_FROM_CACHE);
    1:                 }
    1:                 else if (mLoadType == LOAD_RELOAD_NORMAL)
    1:                     cacheChannel->SetCacheKey(cacheKey);
    1:             }         
    1:         }
    1:         else {
    1:             /* If there is no postdata, set the cache key on the channel, and
    1:              * do not set the LOAD_ONLY_FROM_CACHE flag, so that the channel
    1:              * will be free to get it from net if it is not found in cache.
    1:              * New cache may use it creatively on CGI pages with GET
    1:              * method and even on those that say "no-cache"
    1:              */
    1:             if (mLoadType == LOAD_HISTORY || mLoadType == LOAD_RELOAD_NORMAL 
    1:                 || mLoadType == LOAD_RELOAD_CHARSET_CHANGE) {
    1:                 if (cacheChannel && cacheKey)
    1:                     cacheChannel->SetCacheKey(cacheKey);
    1:             }
    1:         }
    1:         if (aHeadersData) {
    1:             rv = AddHeadersToChannel(aHeadersData, httpChannel);
    1:         }
    1:         // Set the referrer explicitly
    1:         if (aReferrerURI && aSendReferrer) {
    1:             // Referrer is currenly only set for link clicks here.
    1:             httpChannel->SetReferrer(aReferrerURI);
    1:         }
    1:     }
78531: 
13414:     nsCOMPtr<nsIPrincipal> ownerPrincipal(do_QueryInterface(aOwner));
78531:     nsContentUtils::SetUpChannelOwner(ownerPrincipal, channel, aURI, PR_TRUE);
13414: 
    1:     nsCOMPtr<nsIScriptChannel> scriptChannel = do_QueryInterface(channel);
    1:     if (scriptChannel) {
    1:         // Allow execution against our context if the principals match
    1:         scriptChannel->
    1:             SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
    1:     }
    1: 
    1:     if (aIsNewWindowTarget) {
    1:         nsCOMPtr<nsIWritablePropertyBag2> props = do_QueryInterface(channel);
    1:         if (props) {
    1:             props->SetPropertyAsBool(
    1:                 NS_LITERAL_STRING("docshell.newWindowTarget"),
    1:                 PR_TRUE);
    1:         }
    1:     }
    1: 
79445:     if (Preferences::GetBool("dom.enable_performance", false)) {
72986:         nsCOMPtr<nsITimedChannel> timedChannel(do_QueryInterface(channel));
72986:         if (timedChannel) {
72986:             timedChannel->SetTimingEnabled(PR_TRUE);
72986:         }
72986:     }
72986: 
10966:     rv = DoChannelLoad(channel, uriLoader, aBypassClassifier);
    1: 
    1:     //
    1:     // If the channel load failed, we failed and nsIWebProgress just ain't
    1:     // gonna happen.
    1:     //
    1:     if (NS_SUCCEEDED(rv)) {
    1:         if (aDocShell) {
    1:           *aDocShell = this;
    1:           NS_ADDREF(*aDocShell);
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: static NS_METHOD
    1: AppendSegmentToString(nsIInputStream *in,
    1:                       void *closure,
    1:                       const char *fromRawSegment,
    1:                       PRUint32 toOffset,
    1:                       PRUint32 count,
    1:                       PRUint32 *writeCount)
    1: {
    1:     // aFromSegment now contains aCount bytes of data.
    1: 
 3233:     nsCAutoString *buf = static_cast<nsCAutoString *>(closure);
    1:     buf->Append(fromRawSegment, count);
    1: 
    1:     // Indicate that we have consumed all of aFromSegment
    1:     *writeCount = count;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::AddHeadersToChannel(nsIInputStream *aHeadersData,
    1:                                 nsIChannel *aGenericChannel)
    1: {
    1:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aGenericChannel);
    1:     NS_ENSURE_STATE(httpChannel);
    1: 
    1:     PRUint32 numRead;
    1:     nsCAutoString headersString;
    1:     nsresult rv = aHeadersData->ReadSegments(AppendSegmentToString,
    1:                                              &headersString,
    1:                                              PR_UINT32_MAX,
    1:                                              &numRead);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // used during the manipulation of the String from the InputStream
    1:     nsCAutoString headerName;
    1:     nsCAutoString headerValue;
    1:     PRInt32 crlf;
    1:     PRInt32 colon;
    1: 
    1:     //
    1:     // Iterate over the headersString: for each "\r\n" delimited chunk,
    1:     // add the value as a header to the nsIHttpChannel
    1:     //
    1: 
    1:     static const char kWhitespace[] = "\b\t\r\n ";
    1:     while (PR_TRUE) {
    1:         crlf = headersString.Find("\r\n");
    1:         if (crlf == kNotFound)
    1:             return NS_OK;
    1: 
    1:         const nsCSubstring &oneHeader = StringHead(headersString, crlf);
    1: 
    1:         colon = oneHeader.FindChar(':');
    1:         if (colon == kNotFound)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         headerName = StringHead(oneHeader, colon);
    1:         headerValue = Substring(oneHeader, colon + 1);
    1: 
    1:         headerName.Trim(kWhitespace);
    1:         headerValue.Trim(kWhitespace);
    1: 
    1:         headersString.Cut(0, crlf + 2);
    1: 
    1:         //
    1:         // FINALLY: we can set the header!
    1:         // 
    1: 
    1:         rv = httpChannel->SetRequestHeader(headerName, headerValue, PR_TRUE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     NS_NOTREACHED("oops");
    1:     return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: nsresult nsDocShell::DoChannelLoad(nsIChannel * aChannel,
10966:                                    nsIURILoader * aURILoader,
79445:                                    bool aBypassClassifier)
    1: {
    1:     nsresult rv;
    1:     // Mark the channel as being a document URI and allow content sniffing...
    1:     nsLoadFlags loadFlags = 0;
    1:     (void) aChannel->GetLoadFlags(&loadFlags);
    1:     loadFlags |= nsIChannel::LOAD_DOCUMENT_URI |
    1:                  nsIChannel::LOAD_CALL_CONTENT_SNIFFERS;
    1: 
    1:     // Load attributes depend on load type...
    1:     switch (mLoadType) {
    1:     case LOAD_HISTORY:
73554:         {
73554:             // Only send VALIDATE_NEVER if mLSHE's URI was never changed via
73554:             // push/replaceState (bug 669671).
79445:             bool uriModified = false;
73554:             if (mLSHE) {
73554:                 mLSHE->GetURIWasModified(&uriModified);
73554:             }
73554: 
73554:             if (!uriModified)
    1:                 loadFlags |= nsIRequest::VALIDATE_NEVER;
73554:         }
    1:         break;
    1: 
    1:     case LOAD_RELOAD_CHARSET_CHANGE:
    1:         loadFlags |= nsIRequest::LOAD_FROM_CACHE;
    1:         break;
    1:     
    1:     case LOAD_RELOAD_NORMAL:
    1:     case LOAD_REFRESH:
    1:         loadFlags |= nsIRequest::VALIDATE_ALWAYS;
    1:         break;
    1: 
    1:     case LOAD_NORMAL_BYPASS_CACHE:
    1:     case LOAD_NORMAL_BYPASS_PROXY:
    1:     case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
    1:     case LOAD_RELOAD_BYPASS_CACHE:
    1:     case LOAD_RELOAD_BYPASS_PROXY:
    1:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
74259:         loadFlags |= nsIRequest::LOAD_BYPASS_CACHE |
74259:                      nsIRequest::LOAD_FRESH_CONNECTION;
    1:         break;
    1: 
    1:     case LOAD_NORMAL:
    1:     case LOAD_LINK:
    1:         // Set cache checking flags
72449:         switch (Preferences::GetInt("browser.cache.check_doc_frequency", -1)) {
    1:         case 0:
    1:             loadFlags |= nsIRequest::VALIDATE_ONCE_PER_SESSION;
    1:             break;
    1:         case 1:
    1:             loadFlags |= nsIRequest::VALIDATE_ALWAYS;
    1:             break;
    1:         case 2:
    1:             loadFlags |= nsIRequest::VALIDATE_NEVER;
    1:             break;
    1:         }
    1:         break;
    1:     }
    1: 
42552:     if (!aBypassClassifier) {
42552:         loadFlags |= nsIChannel::LOAD_CLASSIFY_URI;
42552:     }
42552: 
    1:     (void) aChannel->SetLoadFlags(loadFlags);
    1: 
    1:     rv = aURILoader->OpenURI(aChannel,
    1:                              (mLoadType == LOAD_LINK),
    1:                              this);
 5528:     NS_ENSURE_SUCCESS(rv, rv);
 5528: 
 5528:     return NS_OK;
 5528: }
 5528: 
29975: nsresult
68728: nsDocShell::ScrollToAnchor(nsACString & aCurHash, nsACString & aNewHash,
68728:                            PRUint32 aLoadType)
68728: {
    1:     if (!mCurrentURI) {
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsCOMPtr<nsIPresShell> shell;
    1:     nsresult rv = GetPresShell(getter_AddRefs(shell));
    1:     if (NS_FAILED(rv) || !shell) {
    1:         // If we failed to get the shell, or if there is no shell,
    1:         // nothing left to do here.
    1:         return rv;
    1:     }
    1: 
    1:     // If we have no new anchor, we do not want to scroll, unless there is a
    1:     // current anchor and we are doing a history load.  So return if we have no
    1:     // new anchor, and there is no current anchor or the load is not a history
    1:     // load.
68728:     if ((aCurHash.IsEmpty() || aLoadType != LOAD_HISTORY) &&
68728:         aNewHash.IsEmpty()) {
68728:         return NS_OK;
68728:     }
29975: 
71441:     // Take the '#' off aNewHash to get the ref name.  (aNewHash might be empty,
71441:     // but that's fine.)
71441:     nsDependentCSubstring newHashName(aNewHash, 1);
71441: 
    1:     // Both the new and current URIs refer to the same page. We can now
    1:     // browse to the hash stored in the new URI.
    1: 
71441:     if (!newHashName.IsEmpty()) {
    1:         // anchor is there, but if it's a load from history,
    1:         // we don't have any anchor jumping to do
79445:         bool scroll = aLoadType != LOAD_HISTORY &&
    1:                         aLoadType != LOAD_RELOAD_NORMAL;
    1: 
71441:         char *str = ToNewCString(newHashName);
    1:         if (!str) {
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1: 
    1:         // nsUnescape modifies the string that is passed into it.
    1:         nsUnescape(str);
    1: 
    1:         // We assume that the bytes are in UTF-8, as it says in the
    1:         // spec:
    1:         // http://www.w3.org/TR/html4/appendix/notes.html#h-B.2.1
    1: 
    1:         // We try the UTF-8 string first, and then try the document's
    1:         // charset (see below).  If the string is not UTF-8,
    1:         // conversion will fail and give us an empty Unicode string.
    1:         // In that case, we should just fall through to using the
    1:         // page's charset.
    1:         rv = NS_ERROR_FAILURE;
    1:         NS_ConvertUTF8toUTF16 uStr(str);
    1:         if (!uStr.IsEmpty()) {
    1:             rv = shell->GoToAnchor(NS_ConvertUTF8toUTF16(str), scroll);
    1:         }
    1:         nsMemory::Free(str);
    1: 
    1:         // Above will fail if the anchor name is not UTF-8.  Need to
    1:         // convert from document charset to unicode.
    1:         if (NS_FAILED(rv)) {
    1:                 
    1:             // Get a document charset
    1:             NS_ENSURE_TRUE(mContentViewer, NS_ERROR_FAILURE);
37433:             nsIDocument* doc = mContentViewer->GetDocument();
37433:             NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
    1:             const nsACString &aCharset = doc->GetDocumentCharacterSet();
    1: 
    1:             nsCOMPtr<nsITextToSubURI> textToSubURI =
    1:                 do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             // Unescape and convert to unicode
    1:             nsXPIDLString uStr;
    1: 
    1:             rv = textToSubURI->UnEscapeAndConvert(PromiseFlatCString(aCharset).get(),
71441:                                                   PromiseFlatCString(newHashName).get(),
    1:                                                   getter_Copies(uStr));
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             // Ignore return value of GoToAnchor, since it will return an error
    1:             // if there is no such anchor in the document, which is actually a
    1:             // success condition for us (we want to update the session history
    1:             // with the new URI no matter whether we actually scrolled
    1:             // somewhere).
    1:             shell->GoToAnchor(uStr, scroll);
    1:         }
    1:     }
    1:     else {
    1: 
    1:         // Tell the shell it's at an anchor, without scrolling.
    1:         shell->GoToAnchor(EmptyString(), PR_FALSE);
    1:         
    1:         // An empty anchor was found, but if it's a load from history,
    1:         // we don't have to jump to the top of the page. Scrollbar 
    1:         // position will be restored by the caller, based on positions
    1:         // stored in session history.
    1:         if (aLoadType == LOAD_HISTORY || aLoadType == LOAD_RELOAD_NORMAL)
74644:             return NS_OK;
74644:         // An empty anchor. Scroll to the top of the page.  Ignore the
74644:         // return value; failure to scroll here (e.g. if there is no
74644:         // root scrollframe) is not grounds for canceling the load!
74644:         SetCurScrollPosEx(0, 0);
74644:     }
74644: 
74644:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocShell::SetupReferrerFromChannel(nsIChannel * aChannel)
    1: {
    1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1:     if (httpChannel) {
    1:         nsCOMPtr<nsIURI> referrer;
    1:         nsresult rv = httpChannel->GetReferrer(getter_AddRefs(referrer));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             SetReferrerURI(referrer);
    1:         }
    1:     }
    1: }
    1: 
79445: bool
22687: nsDocShell::OnNewURI(nsIURI * aURI, nsIChannel * aChannel, nsISupports* aOwner,
79445:                      PRUint32 aLoadType, bool aFireOnLocationChange,
79445:                      bool aAddToGlobalHistory, bool aCloneSHChildren)
    1: {
22687:     NS_PRECONDITION(aURI, "uri is null");
22687:     NS_PRECONDITION(!aChannel || !aOwner, "Shouldn't have both set");
22687: 
    1: #if defined(PR_LOGGING) && defined(DEBUG)
    1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         aURI->GetSpec(spec);
    1: 
    1:         nsCAutoString chanName;
    1:         if (aChannel)
    1:             aChannel->GetName(chanName);
    1:         else
    1:             chanName.AssignLiteral("<no channel>");
    1: 
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:                ("nsDocShell[%p]::OnNewURI(\"%s\", [%s], 0x%x)\n", this, spec.get(),
    1:                 chanName.get(), aLoadType));
    1:     }
    1: #endif
    1: 
79445:     bool updateHistory = true;
79445:     bool equalUri = false;
79445:     bool shAvailable = true;  
    1: 
    1:     // Get the post data from the channel
    1:     nsCOMPtr<nsIInputStream> inputStream;
    1:     if (aChannel) {
    1:         nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1: 
    1:         // Check if the HTTPChannel is hiding under a multiPartChannel
    1:         if (!httpChannel)  {
    1:             GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
    1:         }
    1: 
    1:         if (httpChannel) {
    1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
    1:             if (uploadChannel) {
    1:                 uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
    1:             }
37802: 
37802:             // If the response status indicates an error, unlink this session
80309:             // history entry from any entries sharing its doc ident.
37802:             PRUint32 responseStatus;
37802:             nsresult rv = httpChannel->GetResponseStatus(&responseStatus);
37802:             if (mLSHE && NS_SUCCEEDED(rv) && responseStatus >= 400) {
80309:                 mLSHE->SetUniqueDocIdentifier();
37802:             }
    1:         }
    1:     }
    1:     /* Create SH Entry (mLSHE) only if there is a  SessionHistory object (mSessionHistory) in
    1:      * the current frame or in the root docshell
    1:      */
    1:     nsCOMPtr<nsISHistory> rootSH = mSessionHistory;
    1:     if (!rootSH) {
    1:         // Get the handle to SH from the root docshell          
    1:         GetRootSessionHistory(getter_AddRefs(rootSH));
    1:         if (!rootSH)
    1:             shAvailable = PR_FALSE;
    1:     }  // rootSH
    1: 
    1: 
    1:     // Determine if this type of load should update history.
    1:     if (aLoadType == LOAD_BYPASS_HISTORY ||
    1:         aLoadType == LOAD_ERROR_PAGE ||
    1:         aLoadType & LOAD_CMD_HISTORY ||
    1:         aLoadType & LOAD_CMD_RELOAD)
    1:         updateHistory = PR_FALSE;
    1: 
    1:     // Check if the url to be loaded is the same as the one already loaded.
    1:     if (mCurrentURI)
    1:         aURI->Equals(mCurrentURI, &equalUri);
    1: 
    1: #ifdef DEBUG
    1:     PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:            ("  shAvailable=%i updateHistory=%i equalURI=%i\n",
    1:             shAvailable, updateHistory, equalUri));
48154: 
50371:     if (shAvailable && mCurrentURI && !mOSHE && aLoadType != LOAD_ERROR_PAGE) {
78530:         NS_ASSERTION(NS_IsAboutBlank(mCurrentURI), "no SHEntry for a non-transient viewer?");
48154:     }
    1: #endif
    1: 
    1:     /* If the url to be loaded is the same as the one already there,
    1:      * and the original loadType is LOAD_NORMAL, LOAD_LINK, or
    1:      * LOAD_STOP_CONTENT, set loadType to LOAD_NORMAL_REPLACE so that
    1:      * AddToSessionHistory() won't mess with the current SHEntry and
    1:      * if this page has any frame children, it also will be handled
    1:      * properly. see bug 83684
    1:      *
48154:      * NB: If mOSHE is null but we have a current URI, then it means
48154:      * that we must be at the transient about:blank content viewer
48154:      * (asserted above) and we should let the normal load continue,
48154:      * since there's nothing to replace.
48154:      *
    1:      * XXX Hopefully changing the loadType at this time will not hurt  
    1:      *  anywhere. The other way to take care of sequentially repeating
    1:      *  frameset pages is to add new methods to nsIDocShellTreeItem.
    1:      * Hopefully I don't have to do that. 
    1:      */
    1:     if (equalUri &&
48154:         mOSHE &&
    1:         (mLoadType == LOAD_NORMAL ||
    1:          mLoadType == LOAD_LINK ||
    1:          mLoadType == LOAD_STOP_CONTENT) &&
    1:         !inputStream)
    1:     {
    1:         mLoadType = LOAD_NORMAL_REPLACE;
    1:     }
    1: 
    1:     // If this is a refresh to the currently loaded url, we don't
    1:     // have to update session or global history.
    1:     if (mLoadType == LOAD_REFRESH && !inputStream && equalUri) {
    1:         SetHistoryEntry(&mLSHE, mOSHE);
    1:     }
    1: 
    1:     /* If the user pressed shift-reload, cache will create a new cache key
    1:      * for the page. Save the new cacheKey in Session History. 
    1:      * see bug 90098
    1:      */
    1:     if (aChannel &&
    1:         (aLoadType == LOAD_RELOAD_BYPASS_CACHE ||
    1:          aLoadType == LOAD_RELOAD_BYPASS_PROXY ||
    1:          aLoadType == LOAD_RELOAD_BYPASS_PROXY_AND_CACHE)) {
    1:         NS_ASSERTION(!updateHistory,
    1:                      "We shouldn't be updating history for forced reloads!");
    1:         
    1:         nsCOMPtr<nsICachingChannel> cacheChannel(do_QueryInterface(aChannel));
    1:         nsCOMPtr<nsISupports>  cacheKey;
    1:         // Get the Cache Key and store it in SH.
    1:         if (cacheChannel)
    1:             cacheChannel->GetCacheKey(getter_AddRefs(cacheKey));
    1:         // If we already have a loading history entry, store the new cache key
    1:         // in it.  Otherwise, since we're doing a reload and won't be updating
    1:         // our history entry, store the cache key in our current history entry.
    1:         if (mLSHE)
    1:             mLSHE->SetCacheKey(cacheKey);
    1:         else if (mOSHE)
    1:             mOSHE->SetCacheKey(cacheKey);
50721: 
50721:         // Since we're force-reloading, clear all the sub frame history.
50721:         ClearFrameHistory(mLSHE);
50721:         ClearFrameHistory(mOSHE);
50721:     }
50721: 
50721:     if (aLoadType == LOAD_RELOAD_NORMAL) {
50721:         nsCOMPtr<nsISHEntry> currentSH;
79445:         bool oshe = false;
50721:         GetCurrentSHEntry(getter_AddRefs(currentSH), &oshe);
79445:         bool dynamicallyAddedChild = false;
50721:         if (currentSH) {
50721:           currentSH->HasDynamicallyAddedChild(&dynamicallyAddedChild);
50721:         }
50721:         if (dynamicallyAddedChild) {
50721:           ClearFrameHistory(currentSH);
50721:         }
50721:     }
50721: 
50721:     if (aLoadType == LOAD_REFRESH) {
50721:         ClearFrameHistory(mLSHE);
50721:         ClearFrameHistory(mOSHE);
    1:     }
    1: 
    1:     if (updateHistory && shAvailable) { 
    1:         // Update session history if necessary...
    1:         if (!mLSHE && (mItemType == typeContent) && mURIResultedInDocument) {
    1:             /* This is  a fresh page getting loaded for the first time
    1:              *.Create a Entry for it and add it to SH, if this is the
    1:              * rootDocShell
    1:              */
64491:             (void) AddToSessionHistory(aURI, aChannel, aOwner, aCloneSHChildren,
22687:                                        getter_AddRefs(mLSHE));
    1:         }
    1: 
    1:         if (aAddToGlobalHistory) {
47715:             // If this is a POST request, we do not want to include this in global
47715:             // history.
47715:             if (!ChannelIsPost(aChannel)) {
47715:                 nsCOMPtr<nsIURI> previousURI;
47715:                 PRUint32 previousFlags = 0;
47715:                 ExtractLastVisit(aChannel, getter_AddRefs(previousURI),
47715:                                  &previousFlags);
47715: 
47715:                 nsCOMPtr<nsIURI> referrer;
47715:                 // Treat referrer as null if there is an error getting it.
47715:                 (void)NS_GetReferrerFromChannel(aChannel,
47715:                                                 getter_AddRefs(referrer));
47715: 
47715:                 AddURIVisit(aURI, referrer, previousURI, previousFlags);
47715:             }
    1:         }
    1:     }
    1: 
71454:     // If this was a history load or a refresh,
71454:     // update the index in SH. 
71454:     if (rootSH && (mLoadType & (LOAD_CMD_HISTORY | LOAD_CMD_RELOAD))) {
    1:         nsCOMPtr<nsISHistoryInternal> shInternal(do_QueryInterface(rootSH));
    1:         if (shInternal) {
19870:             rootSH->GetIndex(&mPreviousTransIndex);
    1:             shInternal->UpdateIndex();
19870:             rootSH->GetIndex(&mLoadedTransIndex);
19870: #ifdef DEBUG_PAGE_CACHE
19870:             printf("Previous index: %d, Loaded index: %d\n\n",
19870:                    mPreviousTransIndex, mLoadedTransIndex);
19870: #endif
    1:         }
    1:     }
79445:     bool onLocationChangeNeeded = SetCurrentURI(aURI, aChannel,
71723:                                                   aFireOnLocationChange);
    1:     // Make sure to store the referrer from the channel, if any
    1:     SetupReferrerFromChannel(aChannel);
    1:     return onLocationChangeNeeded;
    1: }
    1: 
79445: bool
79445: nsDocShell::OnLoadingSite(nsIChannel * aChannel, bool aFireOnLocationChange,
79445:                           bool aAddToGlobalHistory)
    1: {
    1:     nsCOMPtr<nsIURI> uri;
    1:     // If this a redirect, use the final url (uri)
    1:     // else use the original url
    1:     //
    1:     // Note that this should match what documents do (see nsDocument::Reset).
 7109:     NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
    1:     NS_ENSURE_TRUE(uri, PR_FALSE);
    1: 
64491:     // Pass false for aCloneSHChildren, since we're loading a new page here.
22687:     return OnNewURI(uri, aChannel, nsnull, mLoadType, aFireOnLocationChange,
64491:                     aAddToGlobalHistory, PR_FALSE);
    1: 
    1: }
    1: 
    1: void
    1: nsDocShell::SetReferrerURI(nsIURI * aURI)
    1: {
    1:     mReferrerURI = aURI;        // This assigment addrefs
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: Session History
    1: //*****************************************************************************
37802: 
37802: NS_IMETHODIMP
37802: nsDocShell::AddState(nsIVariant *aData, const nsAString& aTitle,
79445:                      const nsAString& aURL, bool aReplace, JSContext* aCx)
37802: {
37802:     // Implements History.pushState and History.replaceState
37802: 
37802:     // Here's what we do, roughly in the order specified by HTML5:
69563:     // 1. Serialize aData using structured clone.
37802:     // 2. If the third argument is present,
37802:     //     a. Resolve the url, relative to the first script's base URL
37802:     //     b. If (a) fails, raise a SECURITY_ERR
37802:     //     c. Compare the resulting absolute URL to the document's address.  If
37802:     //        any part of the URLs difer other than the <path>, <query>, and
37802:     //        <fragment> components, raise a SECURITY_ERR and abort.
37802:     // 3. If !aReplace:
37802:     //     Remove from the session history all entries after the current entry,
51605:     //     as we would after a regular navigation, and save the current
51605:     //     entry's scroll position (bug 590573).
37802:     // 4. As apropriate, either add a state object entry to the session history
37802:     //    after the current entry with the following properties, or modify the
37802:     //    current session history entry to set
37802:     //      a. cloned data as the state object,
48096:     //      b. if the third argument was present, the absolute URL found in
37802:     //         step 2
51305:     //    Also clear the new history entry's POST data (see bug 580069).
37802:     // 5. If aReplace is false (i.e. we're doing a pushState instead of a
37802:     //    replaceState), notify bfcache that we've navigated to a new page.
37802:     // 6. If the third argument is present, set the document's current address
37802:     //    to the absolute URL found in step 2.
37802:     //
37802:     // It's important that this function not run arbitrary scripts after step 1
37802:     // and before completing step 5.  For example, if a script called
37802:     // history.back() before we completed step 5, bfcache might destroy an
80309:     // active content viewer.  Since EvictContentViewers at the end of step 5
80309:     // might run script, we can't just put a script blocker around the critical
80309:     // section.
48096:     //
48096:     // Note that we completely ignore the aTitle parameter.
37802: 
37802:     nsresult rv;
37802: 
69563:     nsCOMPtr<nsIDocument> document = do_GetInterface(GetAsSupports(this));
69563:     NS_ENSURE_TRUE(document, NS_ERROR_FAILURE);
69563: 
69563:     // Step 1: Serialize aData using structured clone.
69563:     nsCOMPtr<nsIStructuredCloneContainer> scContainer;
69563: 
69563:     // scContainer->Init might cause arbitrary JS to run, and this code might
69563:     // navigate the page we're on, potentially to a different origin! (bug
62848:     // 634834)  To protect against this, we abort if our principal changes due
69563:     // to the InitFromVariant() call.
62848:     {
62848:         nsCOMPtr<nsIDocument> origDocument =
62848:             do_GetInterface(GetAsSupports(this));
62848:         if (!origDocument)
62848:             return NS_ERROR_DOM_SECURITY_ERR;
62848:         nsCOMPtr<nsIPrincipal> origPrincipal = origDocument->NodePrincipal();
62848: 
69563:         scContainer = new nsStructuredCloneContainer();
69563:         JSContext *cx = aCx;
69563:         if (!cx) {
69563:             cx = nsContentUtils::GetContextFromDocument(document);
69563:         }
69563:         rv = scContainer->InitFromVariant(aData, cx);
69563: 
69563:         // If we're running in the document's context and the structured clone
69563:         // failed, clear the context's pending exception.  See bug 637116.
69563:         if (NS_FAILED(rv) && !aCx) {
69563:             JS_ClearPendingException(aCx);
69563:         }
37802:         NS_ENSURE_SUCCESS(rv, rv);
37802: 
62848:         nsCOMPtr<nsIDocument> newDocument =
62848:             do_GetInterface(GetAsSupports(this));
62848:         if (!newDocument)
62848:             return NS_ERROR_DOM_SECURITY_ERR;
62848:         nsCOMPtr<nsIPrincipal> newPrincipal = newDocument->NodePrincipal();
62848: 
79445:         bool principalsEqual = false;
62848:         origPrincipal->Equals(newPrincipal, &principalsEqual);
62848:         NS_ENSURE_TRUE(principalsEqual, NS_ERROR_DOM_SECURITY_ERR);
62848:     }
62848: 
37802:     // Check that the state object isn't too long.
69563:     // Default max length: 640k bytes.
72449:     PRInt32 maxStateObjSize =
72449:         Preferences::GetInt("browser.history.maxStateObjectSize", 0xA0000);
41712:     if (maxStateObjSize < 0) {
37802:         maxStateObjSize = 0;
41712:     }
69563: 
69563:     PRUint64 scSize;
69563:     rv = scContainer->GetSerializedNBytes(&scSize);
69563:     NS_ENSURE_SUCCESS(rv, rv);
69563: 
69563:     NS_ENSURE_TRUE(scSize <= (PRUint32)maxStateObjSize,
37802:                    NS_ERROR_ILLEGAL_VALUE);
37802: 
37802:     // Step 2: Resolve aURL
79445:     bool equalURIs = true;
37802:     nsCOMPtr<nsIURI> oldURI = mCurrentURI;
37802:     nsCOMPtr<nsIURI> newURI;
37802:     if (aURL.Length() == 0) {
37802:         newURI = mCurrentURI;
37802:     }
37802:     else {
37802:         // 2a: Resolve aURL relative to mURI
37802: 
41900:         nsIURI* docBaseURI = document->GetDocBaseURI();
37802:         if (!docBaseURI)
37802:             return NS_ERROR_FAILURE;
37802: 
37802:         nsCAutoString spec;
37802:         docBaseURI->GetSpec(spec);
37802: 
37802:         nsCAutoString charset;
37802:         rv = docBaseURI->GetOriginCharset(charset);
37802:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
37802: 
37802:         rv = NS_NewURI(getter_AddRefs(newURI), aURL,
37802:                        charset.get(), docBaseURI);
37802: 
37802:         // 2b: If 2a fails, raise a SECURITY_ERR
37802:         if (NS_FAILED(rv)) {
37802:             return NS_ERROR_DOM_SECURITY_ERR;
37802:         }
37802: 
37802:         // 2c: Same-origin check.
78531:         if (!nsContentUtils::URIIsLocalFile(newURI)) {
37802:             // In addition to checking that the security manager says that
37802:             // the new URI has the same origin as our current URI, we also
37802:             // check that the two URIs have the same userpass. (The
37802:             // security manager says that |http://foo.com| and
37802:             // |http://me@foo.com| have the same origin.)  mCurrentURI
37802:             // won't contain the password part of the userpass, so this
37802:             // means that it's never valid to specify a password in a
37802:             // pushState or replaceState URI.
37802: 
37802:             nsCOMPtr<nsIScriptSecurityManager> secMan =
37802:                 do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
37802:             NS_ENSURE_TRUE(secMan, NS_ERROR_FAILURE);
37802: 
37802:             // It's very important that we check that newURI is of the same
37802:             // origin as mCurrentURI, not docBaseURI, because a page can
37802:             // set docBaseURI arbitrarily to any domain.
37802:             nsCAutoString currentUserPass, newUserPass;
37802:             NS_ENSURE_SUCCESS(mCurrentURI->GetUserPass(currentUserPass),
37802:                               NS_ERROR_FAILURE);
37802:             NS_ENSURE_SUCCESS(newURI->GetUserPass(newUserPass),
37802:                               NS_ERROR_FAILURE);
37802:             if (NS_FAILED(secMan->CheckSameOriginURI(mCurrentURI,
37802:                                                      newURI, PR_TRUE)) ||
37802:                 !currentUserPass.Equals(newUserPass)) {
37802: 
37802:                 return NS_ERROR_DOM_SECURITY_ERR;
37802:             }
37802:         }
37802:         else {
37802:             // It's a file:// URI
37802:             nsCOMPtr<nsIScriptObjectPrincipal> docScriptObj =
37802:                 do_QueryInterface(document);
37802: 
37802:             if (!docScriptObj) {
37802:                 return NS_ERROR_DOM_SECURITY_ERR;
37802:             }
37802: 
37802:             nsCOMPtr<nsIPrincipal> principal = docScriptObj->GetPrincipal();
37802: 
37802:             if (!principal ||
37802:                 NS_FAILED(principal->CheckMayLoad(newURI, PR_TRUE))) {
37802: 
37802:                 return NS_ERROR_DOM_SECURITY_ERR;
37802:             }
37802:         }
37802: 
37802:         mCurrentURI->Equals(newURI, &equalURIs);
37802: 
37802:     } // end of same-origin check
37802: 
37802:     nsCOMPtr<nsISHistory> sessionHistory = mSessionHistory;
37802:     if (!sessionHistory) {
37802:         // Get the handle to SH from the root docshell
37802:         GetRootSessionHistory(getter_AddRefs(sessionHistory));
37802:     }
37802:     NS_ENSURE_TRUE(sessionHistory, NS_ERROR_FAILURE);
37802: 
37802:     nsCOMPtr<nsISHistoryInternal> shInternal =
37802:         do_QueryInterface(sessionHistory, &rv);
37802:     NS_ENSURE_SUCCESS(rv, rv);
37802: 
51605:     // Step 3: Create a new entry in the session history. This will erase
37802:     // all SHEntries after the new entry and make this entry the current
37802:     // one.  This operation may modify mOSHE, which we need later, so we
37802:     // keep a reference here.
37802:     NS_ENSURE_TRUE(mOSHE, NS_ERROR_FAILURE);
37802:     nsCOMPtr<nsISHEntry> oldOSHE = mOSHE;
37802: 
62179:     mLoadType = LOAD_PUSHSTATE;
62179: 
37802:     nsCOMPtr<nsISHEntry> newSHEntry;
37802:     if (!aReplace) {
51605:         // Save the current scroll position (bug 590573).
51605:         nscoord cx = 0, cy = 0;
51605:         GetCurScrollPos(ScrollOrientation_X, &cx);
51605:         GetCurScrollPos(ScrollOrientation_Y, &cy);
51605:         mOSHE->SetScrollPosition(cx, cy);
51605: 
64491:         // Since we're not changing which page we have loaded, pass
64491:         // true for aCloneChildren.
64491:         rv = AddToSessionHistory(newURI, nsnull, nsnull, PR_TRUE,
37802:                                  getter_AddRefs(newSHEntry));
37802:         NS_ENSURE_SUCCESS(rv, rv);
37802: 
37802:         NS_ENSURE_TRUE(newSHEntry, NS_ERROR_FAILURE);
37802: 
80309:         // Set the new SHEntry's document identifier, if we can.
80309:         PRUint64 ourDocIdent;
80309:         NS_ENSURE_SUCCESS(oldOSHE->GetDocIdentifier(&ourDocIdent),
80309:                           NS_ERROR_FAILURE);
80309:         NS_ENSURE_SUCCESS(newSHEntry->SetDocIdentifier(ourDocIdent),
37802:                           NS_ERROR_FAILURE);
37802: 
70087:         // Set the new SHEntry's title (bug 655273).
70087:         nsString title;
70087:         mOSHE->GetTitle(getter_Copies(title));
70087:         newSHEntry->SetTitle(title);
70087: 
37802:         // AddToSessionHistory may not modify mOSHE.  In case it doesn't,
37802:         // we'll just set mOSHE here.
37802:         mOSHE = newSHEntry;
37802: 
37802:     } else {
37802:         newSHEntry = mOSHE;
37802:         newSHEntry->SetURI(newURI);
37802:     }
37802: 
51305:     // Step 4: Modify new/original session history entry and clear its POST
51305:     // data, if there is any.
69563:     newSHEntry->SetStateData(scContainer);
51305:     newSHEntry->SetPostData(nsnull);
37802: 
73554:     // If this push/replaceState changed the document's current URI and the new
73554:     // URI differs from the old URI in more than the hash, or if the old
73554:     // SHEntry's URI was modified in this way by a push/replaceState call
73554:     // set URIWasModified to true for the current SHEntry (bug 669671).
79445:     bool sameExceptHashes = true, oldURIWasModified = false;
73554:     newURI->EqualsExceptRef(mCurrentURI, &sameExceptHashes);
73554:     oldOSHE->GetURIWasModified(&oldURIWasModified);
73554:     newSHEntry->SetURIWasModified(!sameExceptHashes || oldURIWasModified);
73554: 
37802:     // Step 5: If aReplace is false, indicating that we're doing a pushState
37802:     // rather than a replaceState, notify bfcache that we've added a page to
37802:     // the history so it can evict content viewers if appropriate.
37802:     if (!aReplace) {
37802:         nsCOMPtr<nsISHistory> rootSH;
37802:         GetRootSessionHistory(getter_AddRefs(rootSH));
37802:         NS_ENSURE_TRUE(rootSH, NS_ERROR_UNEXPECTED);
37802: 
37802:         nsCOMPtr<nsISHistoryInternal> internalSH =
37802:             do_QueryInterface(rootSH);
37802:         NS_ENSURE_TRUE(internalSH, NS_ERROR_UNEXPECTED);
37802: 
37802:         PRInt32 curIndex = -1;
37802:         rv = rootSH->GetIndex(&curIndex);
37802:         if (NS_SUCCEEDED(rv) && curIndex > -1) {
80309:             internalSH->EvictContentViewers(curIndex - 1, curIndex);
37802:         }
37802:     }
37802: 
37802:     // Step 6: If the document's URI changed, update document's URI and update
41712:     // global history.
41712:     //
41712:     // We need to call FireOnLocationChange so that the browser's address bar
41712:     // gets updated and the back button is enabled, but we only need to
41712:     // explicitly call FireOnLocationChange if we're not calling SetCurrentURI,
41712:     // since SetCurrentURI will call FireOnLocationChange for us.
37802:     if (!equalURIs) {
71723:         SetCurrentURI(newURI, nsnull, PR_TRUE);
37802:         document->SetDocumentURI(newURI);
37802: 
47715:         AddURIVisit(newURI, oldURI, oldURI, 0);
69911: 
69911:         // AddURIVisit doesn't set the title for the new URI in global history,
69911:         // so do that here.
69911:         if (mUseGlobalHistory) {
69911:             nsCOMPtr<IHistory> history = services::GetHistoryService();
69911:             if (history) {
69911:                 history->SetURITitle(newURI, mTitle);
69911:             }
69911:             else if (mGlobalHistory) {
69911:                 mGlobalHistory->SetPageTitle(newURI, mTitle);
69911:             }
69911:         }
70109: 
70109:         // Inform the favicon service that our old favicon applies to this new
70109:         // URI.
70868:         CopyFavicon(oldURI, newURI);
37802:     }
41712:     else {
52044:         FireDummyOnLocationChange();
41712:     }
69563:     document->SetStateObject(scContainer);
37802: 
37802:     return NS_OK;
37802: }
37802: 
79445: bool
    1: nsDocShell::ShouldAddToSessionHistory(nsIURI * aURI)
    1: {
    1:     // I believe none of the about: urls should go in the history. But then
    1:     // that could just be me... If the intent is only deny about:blank then we
    1:     // should just do a spec compare, rather than two gets of the scheme and
    1:     // then the path.  -Gagan
    1:     nsresult rv;
    1:     nsCAutoString buf;
    1: 
    1:     rv = aURI->GetScheme(buf);
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
    1:     if (buf.Equals("about")) {
    1:         rv = aURI->GetPath(buf);
    1:         if (NS_FAILED(rv))
    1:             return PR_FALSE;
    1: 
    1:         if (buf.Equals("blank")) {
    1:             return PR_FALSE;
    1:         }
    1:     }
    1:     return PR_TRUE;
    1: }
    1: 
    1: nsresult
22687: nsDocShell::AddToSessionHistory(nsIURI * aURI, nsIChannel * aChannel,
79445:                                 nsISupports* aOwner, bool aCloneChildren,
64491:                                 nsISHEntry ** aNewEntry)
22687: {
22687:     NS_PRECONDITION(aURI, "uri is null");
22687:     NS_PRECONDITION(!aChannel || !aOwner, "Shouldn't have both set");
22687: 
    1: #if defined(PR_LOGGING) && defined(DEBUG)
    1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
    1:         nsCAutoString spec;
    1:         aURI->GetSpec(spec);
    1: 
    1:         nsCAutoString chanName;
    1:         if (aChannel)
    1:             aChannel->GetName(chanName);
    1:         else
    1:             chanName.AssignLiteral("<no channel>");
    1: 
    1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
    1:                ("nsDocShell[%p]::AddToSessionHistory(\"%s\", [%s])\n", this, spec.get(),
    1:                 chanName.get()));
    1:     }
    1: #endif
    1: 
    1:     nsresult rv = NS_OK;
    1:     nsCOMPtr<nsISHEntry> entry;
79445:     bool shouldPersist;
    1: 
    1:     shouldPersist = ShouldAddToSessionHistory(aURI);
    1: 
    1:     // Get a handle to the root docshell 
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1:     GetSameTypeRootTreeItem(getter_AddRefs(root));     
    1:     /*
    1:      * If this is a LOAD_FLAGS_REPLACE_HISTORY in a subframe, we use
    1:      * the existing SH entry in the page and replace the url and
    1:      * other vitalities.
    1:      */
    1:     if (LOAD_TYPE_HAS_FLAGS(mLoadType, LOAD_FLAGS_REPLACE_HISTORY) &&
 3233:         root != static_cast<nsIDocShellTreeItem *>(this)) {
    1:         // This is a subframe 
    1:         entry = mOSHE;
    1:         nsCOMPtr<nsISHContainer> shContainer(do_QueryInterface(entry));
    1:         if (shContainer) {
    1:             PRInt32 childCount = 0;
    1:             shContainer->GetChildCount(&childCount);
    1:             // Remove all children of this entry 
    1:             for (PRInt32 i = childCount - 1; i >= 0; i--) {
    1:                 nsCOMPtr<nsISHEntry> child;
    1:                 shContainer->GetChildAt(i, getter_AddRefs(child));
    1:                 shContainer->RemoveChild(child);
    1:             }  // for
    1:         }  // shContainer
    1:     }
    1: 
    1:     // Create a new entry if necessary.
    1:     if (!entry) {
    1:         entry = do_CreateInstance(NS_SHENTRY_CONTRACTID);
    1: 
    1:         if (!entry) {
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         }
    1:     }
    1: 
    1:     // Get the post data & referrer
    1:     nsCOMPtr<nsIInputStream> inputStream;
    1:     nsCOMPtr<nsIURI> referrerURI;
    1:     nsCOMPtr<nsISupports> cacheKey;
22687:     nsCOMPtr<nsISupports> owner = aOwner;
79445:     bool expired = false;
79445:     bool discardLayoutState = false;
46915:     nsCOMPtr<nsICachingChannel> cacheChannel;
    1:     if (aChannel) {
46915:         cacheChannel = do_QueryInterface(aChannel);
46915: 
    1:         /* If there is a caching channel, get the Cache Key and store it
    1:          * in SH.
    1:          */
    1:         if (cacheChannel) {
    1:             cacheChannel->GetCacheKey(getter_AddRefs(cacheKey));
    1:         }
    1:         nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
    1:         
    1:         // Check if the httpChannel is hiding under a multipartChannel
    1:         if (!httpChannel) {
    1:             GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
    1:         }
    1:         if (httpChannel) {
    1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
    1:             if (uploadChannel) {
    1:                 uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
    1:             }
    1:             httpChannel->GetReferrer(getter_AddRefs(referrerURI));
    1: 
    1:             discardLayoutState = ShouldDiscardLayoutState(httpChannel);
    1:         }
    1:         aChannel->GetOwner(getter_AddRefs(owner));
    1:     }
    1: 
    1:     //Title is set in nsDocShell::SetTitle()
    1:     entry->Create(aURI,              // uri
    1:                   EmptyString(),     // Title
    1:                   inputStream,       // Post data stream
    1:                   nsnull,            // LayoutHistory state
    1:                   cacheKey,          // CacheKey
    1:                   mContentTypeHint,  // Content-type
50721:                   owner,             // Channel or provided owner
50721:                   mHistoryID,
50721:                   mDynamicallyCreated);
    1:     entry->SetReferrerURI(referrerURI);
    1:     /* If cache got a 'no-store', ask SH not to store
    1:      * HistoryLayoutState. By default, SH will set this
    1:      * flag to PR_TRUE and save HistoryLayoutState.
    1:      */    
    1:     if (discardLayoutState) {
    1:         entry->SetSaveLayoutStateFlag(PR_FALSE);
    1:     }
46915:     if (cacheChannel) {
    1:         // Check if the page has expired from cache
46915:         PRUint32 expTime = 0;
46915:         cacheChannel->GetCacheTokenExpirationTime(&expTime);
    1:         PRUint32 now = PRTimeToSeconds(PR_Now());
    1:         if (expTime <=  now)
    1:             expired = PR_TRUE;
    1:     }
37970:     if (expired)
    1:         entry->SetExpirationStatus(PR_TRUE);
    1: 
    1: 
 3233:     if (root == static_cast<nsIDocShellTreeItem *>(this) && mSessionHistory) {
64491:         // If we need to clone our children onto the new session
64491:         // history entry, do so now.
64491:         if (aCloneChildren && mOSHE) {
61863:             PRUint32 cloneID;
61863:             mOSHE->GetID(&cloneID);
61863:             nsCOMPtr<nsISHEntry> newEntry;
61863:             CloneAndReplace(mOSHE, this, cloneID, entry, PR_TRUE, getter_AddRefs(newEntry));
61863:             NS_ASSERTION(entry == newEntry, "The new session history should be in the new entry");
61863:         }
61863: 
    1:         // This is the root docshell
    1:         if (LOAD_TYPE_HAS_FLAGS(mLoadType, LOAD_FLAGS_REPLACE_HISTORY)) {            
    1:             // Replace current entry in session history.
    1:             PRInt32  index = 0;   
    1:             mSessionHistory->GetIndex(&index);
    1:             nsCOMPtr<nsISHistoryInternal>   shPrivate(do_QueryInterface(mSessionHistory));
    1:             // Replace the current entry with the new entry
    1:             if (shPrivate)
    1:                 rv = shPrivate->ReplaceEntry(index, entry);          
    1:         }
    1:         else {
    1:             // Add to session history
    1:             nsCOMPtr<nsISHistoryInternal>
    1:                 shPrivate(do_QueryInterface(mSessionHistory));
    1:             NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
19870:             mSessionHistory->GetIndex(&mPreviousTransIndex);
    1:             rv = shPrivate->AddEntry(entry, shouldPersist);
19870:             mSessionHistory->GetIndex(&mLoadedTransIndex);
19870: #ifdef DEBUG_PAGE_CACHE
19870:             printf("Previous index: %d, Loaded index: %d\n\n",
19870:                    mPreviousTransIndex, mLoadedTransIndex);
19870: #endif
    1:         }
    1:     }
    1:     else {  
    1:         // This is a subframe.
    1:         if (!mOSHE || !LOAD_TYPE_HAS_FLAGS(mLoadType,
    1:                                            LOAD_FLAGS_REPLACE_HISTORY))
64491:             rv = DoAddChildSHEntry(entry, mChildOffset, aCloneChildren);
    1:     }
    1: 
    1:     // Return the new SH entry...
    1:     if (aNewEntry) {
    1:         *aNewEntry = nsnull;
    1:         if (NS_SUCCEEDED(rv)) {
    1:             *aNewEntry = entry;
    1:             NS_ADDREF(*aNewEntry);
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::LoadHistoryEntry(nsISHEntry * aEntry, PRUint32 aLoadType)
    1: {
10676:     if (!IsNavigationAllowed()) {
10676:         return NS_OK;
10676:     }
10676:     
    1:     nsCOMPtr<nsIURI> uri;
    1:     nsCOMPtr<nsIInputStream> postData;
    1:     nsCOMPtr<nsIURI> referrerURI;
    1:     nsCAutoString contentType;
    1:     nsCOMPtr<nsISupports> owner;
    1: 
    1:     NS_ENSURE_TRUE(aEntry, NS_ERROR_FAILURE);
    1: 
    1:     NS_ENSURE_SUCCESS(aEntry->GetURI(getter_AddRefs(uri)), NS_ERROR_FAILURE);
    1:     NS_ENSURE_SUCCESS(aEntry->GetReferrerURI(getter_AddRefs(referrerURI)),
    1:                       NS_ERROR_FAILURE);
    1:     NS_ENSURE_SUCCESS(aEntry->GetPostData(getter_AddRefs(postData)),
    1:                       NS_ERROR_FAILURE);
    1:     NS_ENSURE_SUCCESS(aEntry->GetContentType(contentType), NS_ERROR_FAILURE);
    1:     NS_ENSURE_SUCCESS(aEntry->GetOwner(getter_AddRefs(owner)),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     // Calling CreateAboutBlankContentViewer can set mOSHE to null, and if
    1:     // that's the only thing holding a ref to aEntry that will cause aEntry to
    1:     // die while we're loading it.  So hold a strong ref to aEntry here, just
    1:     // in case.
    1:     nsCOMPtr<nsISHEntry> kungFuDeathGrip(aEntry);
79445:     bool isJS;
    1:     nsresult rv = uri->SchemeIs("javascript", &isJS);
    1:     if (NS_FAILED(rv) || isJS) {
    1:         // We're loading a URL that will execute script from inside asyncOpen.
    1:         // Replace the current document with about:blank now to prevent
    1:         // anything from the current document from leaking into any JavaScript
    1:         // code in the URL.
 6712:         nsCOMPtr<nsIPrincipal> prin = do_QueryInterface(owner);
60827:         // Don't cache the presentation if we're going to just reload the
60827:         // current entry. Caching would lead to trying to save the different
60827:         // content viewers in the same nsISHEntry object.
60827:         rv = CreateAboutBlankContentViewer(prin, nsnull, aEntry != mOSHE);
    1: 
    1:         if (NS_FAILED(rv)) {
    1:             // The creation of the intermittent about:blank content
    1:             // viewer failed for some reason (potentially because the
    1:             // user prevented it). Interrupt the history load.
    1:             return NS_OK;
    1:         }
    1: 
    1:         if (!owner) {
    1:             // Ensure that we have an owner.  Otherwise javascript: URIs will
    1:             // pick it up from the about:blank page we just loaded, and we
    1:             // don't really want even that in this case.
    1:             owner = do_CreateInstance("@mozilla.org/nullprincipal;1");
    1:             NS_ENSURE_TRUE(owner, NS_ERROR_OUT_OF_MEMORY);
    1:         }
    1:     }
    1: 
    1:     /* If there is a valid postdata *and* the user pressed
    1:      * reload or shift-reload, take user's permission before we  
    1:      * repost the data to the server.
    1:      */
    1:     if ((aLoadType & LOAD_CMD_RELOAD) && postData) {
79445:       bool repost;
    1:       rv = ConfirmRepost(&repost);
    1:       if (NS_FAILED(rv)) return rv;
    1: 
    1:       // If the user pressed cancel in the dialog, return.  We're done here.
    1:       if (!repost)
    1:         return NS_BINDING_ABORTED;
    1:     }
    1: 
    1:     rv = InternalLoad(uri,
    1:                       referrerURI,
    1:                       owner,
    1:                       INTERNAL_LOAD_FLAGS_NONE, // Do not inherit owner from document (security-critical!)
    1:                       nsnull,            // No window target
    1:                       contentType.get(), // Type hint
    1:                       postData,          // Post data stream
    1:                       nsnull,            // No headers stream
    1:                       aLoadType,         // Load type
    1:                       aEntry,            // SHEntry
    1:                       PR_TRUE,
    1:                       nsnull,            // No nsIDocShell
54823:                       nsnull);           // No nsIRequest
    1:     return rv;
    1: }
    1: 
79445: NS_IMETHODIMP nsDocShell::GetShouldSaveLayoutState(bool* aShould)
    1: {
    1:     *aShould = PR_FALSE;
    1:     if (mOSHE) {
    1:         // Don't capture historystate and save it in history
    1:         // if the page asked not to do so.
    1:         mOSHE->GetSaveLayoutStateFlag(aShould);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::PersistLayoutHistoryState()
    1: {
    1:     nsresult  rv = NS_OK;
    1:     
    1:     if (mOSHE) {
    1:         nsCOMPtr<nsIPresShell> shell;
    1:         rv = GetPresShell(getter_AddRefs(shell));
    1:         if (NS_SUCCEEDED(rv) && shell) {
    1:             nsCOMPtr<nsILayoutHistoryState> layoutState;
    1:             rv = shell->CaptureHistoryState(getter_AddRefs(layoutState),
    1:                                             PR_TRUE);
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: /* static */ nsresult
    1: nsDocShell::WalkHistoryEntries(nsISHEntry *aRootEntry,
    1:                                nsDocShell *aRootShell,
    1:                                WalkHistoryEntriesFunc aCallback,
    1:                                void *aData)
    1: {
    1:     NS_ENSURE_TRUE(aRootEntry, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsISHContainer> container(do_QueryInterface(aRootEntry));
    1:     if (!container)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     PRInt32 childCount;
    1:     container->GetChildCount(&childCount);
    1:     for (PRInt32 i = 0; i < childCount; i++) {
    1:         nsCOMPtr<nsISHEntry> childEntry;
    1:         container->GetChildAt(i, getter_AddRefs(childEntry));
    1:         if (!childEntry) {
    1:             // childEntry can be null for valid reasons, for example if the
    1:             // docshell at index i never loaded anything useful.
50721:             // Remember to clone also nulls in the child array (bug 464064).
50721:             aCallback(nsnull, nsnull, i, aData);
    1:             continue;
    1:         }
    1: 
    1:         nsDocShell *childShell = nsnull;
    1:         if (aRootShell) {
    1:             // Walk the children of aRootShell and see if one of them
    1:             // has srcChild as a SHEntry.
    1: 
29263:             PRInt32 childCount = aRootShell->mChildList.Count();
29263:             for (PRInt32 j = 0; j < childCount; ++j) {
    1:                 nsDocShell *child =
29263:                     static_cast<nsDocShell*>(aRootShell->ChildAt(j));
    1: 
    1:                 if (child->HasHistoryEntry(childEntry)) {
    1:                     childShell = child;
    1:                     break;
    1:                 }
    1:             }
    1:         }
    1:         nsresult rv = aCallback(childEntry, childShell, i, aData);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: // callback data for WalkHistoryEntries
15594: struct NS_STACK_CLASS CloneAndReplaceData
    1: {
    1:     CloneAndReplaceData(PRUint32 aCloneID, nsISHEntry *aReplaceEntry,
79445:                         bool aCloneChildren, nsISHEntry *aDestTreeParent)
    1:         : cloneID(aCloneID),
61863:           cloneChildren(aCloneChildren),
    1:           replaceEntry(aReplaceEntry),
    1:           destTreeParent(aDestTreeParent) { }
    1: 
    1:     PRUint32              cloneID;
79445:     bool                  cloneChildren;
    1:     nsISHEntry           *replaceEntry;
    1:     nsISHEntry           *destTreeParent;
    1:     nsCOMPtr<nsISHEntry>  resultEntry;
    1: };
    1: 
    1: /* static */ nsresult
    1: nsDocShell::CloneAndReplaceChild(nsISHEntry *aEntry, nsDocShell *aShell,
    1:                                  PRInt32 aEntryIndex, void *aData)
    1: {
    1:     nsCOMPtr<nsISHEntry> dest;
    1: 
 3233:     CloneAndReplaceData *data = static_cast<CloneAndReplaceData*>(aData);
    1:     PRUint32 cloneID = data->cloneID;
    1:     nsISHEntry *replaceEntry = data->replaceEntry;
    1: 
50721:     nsCOMPtr<nsISHContainer> container =
50721:       do_QueryInterface(data->destTreeParent);
50721:     if (!aEntry) {
50721:         if (container) {
50721:             container->AddChild(nsnull, aEntryIndex);
50721:         }
50721:         return NS_OK;
50721:     }
50721:     
    1:     PRUint32 srcID;
    1:     aEntry->GetID(&srcID);
    1: 
70984:     nsresult rv = NS_OK;
    1:     if (srcID == cloneID) {
61863:         // Replace the entry
    1:         dest = replaceEntry;
70984:     } else {
70984:         // Clone the SHEntry...
70984:         rv = aEntry->Clone(getter_AddRefs(dest));
70984:         NS_ENSURE_SUCCESS(rv, rv);
70984:     }
    1:     dest->SetIsSubFrame(PR_TRUE);
61863: 
70984:     if (srcID != cloneID || data->cloneChildren) {
61863:         // Walk the children
61863:         CloneAndReplaceData childData(cloneID, replaceEntry,
61863:                                       data->cloneChildren, dest);
70984:         rv = WalkHistoryEntries(aEntry, aShell,
61863:                                 CloneAndReplaceChild, &childData);
70984:         NS_ENSURE_SUCCESS(rv, rv);
70984:     }
70984: 
70984:     if (srcID != cloneID && aShell) {
    1:         aShell->SwapHistoryEntries(aEntry, dest);
    1:     }
    1: 
    1:     if (container)
    1:         container->AddChild(dest, aEntryIndex);
    1: 
    1:     data->resultEntry = dest;
70984:     return rv;
    1: }
    1: 
    1: /* static */ nsresult
    1: nsDocShell::CloneAndReplace(nsISHEntry *aSrcEntry,
    1:                                    nsDocShell *aSrcShell,
    1:                                    PRUint32 aCloneID,
    1:                                    nsISHEntry *aReplaceEntry,
79445:                                    bool aCloneChildren,
    1:                                    nsISHEntry **aResultEntry)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aResultEntry);
    1:     NS_ENSURE_TRUE(aReplaceEntry, NS_ERROR_FAILURE);
    1: 
61863:     CloneAndReplaceData data(aCloneID, aReplaceEntry, aCloneChildren, nsnull);
    1:     nsresult rv = CloneAndReplaceChild(aSrcEntry, aSrcShell, 0, &data);
    1: 
    1:     data.resultEntry.swap(*aResultEntry);
    1:     return rv;
    1: }
    1: 
    1: void
    1: nsDocShell::SwapHistoryEntries(nsISHEntry *aOldEntry, nsISHEntry *aNewEntry)
    1: {
    1:     if (aOldEntry == mOSHE)
    1:         mOSHE = aNewEntry;
    1: 
    1:     if (aOldEntry == mLSHE)
    1:         mLSHE = aNewEntry;
    1: }
    1: 
    1: 
    1: struct SwapEntriesData
    1: {
    1:     nsDocShell *ignoreShell;     // constant; the shell to ignore
    1:     nsISHEntry *destTreeRoot;    // constant; the root of the dest tree
    1:     nsISHEntry *destTreeParent;  // constant; the node under destTreeRoot
    1:                                  // whose children will correspond to aEntry
    1: };
    1: 
    1: 
    1: nsresult
    1: nsDocShell::SetChildHistoryEntry(nsISHEntry *aEntry, nsDocShell *aShell,
    1:                                  PRInt32 aEntryIndex, void *aData)
    1: {
 3233:     SwapEntriesData *data = static_cast<SwapEntriesData*>(aData);
    1:     nsDocShell *ignoreShell = data->ignoreShell;
    1: 
    1:     if (!aShell || aShell == ignoreShell)
    1:         return NS_OK;
    1: 
    1:     nsISHEntry *destTreeRoot = data->destTreeRoot;
    1: 
    1:     nsCOMPtr<nsISHEntry> destEntry;
    1:     nsCOMPtr<nsISHContainer> container =
    1:         do_QueryInterface(data->destTreeParent);
    1: 
    1:     if (container) {
    1:         // aEntry is a clone of some child of destTreeParent, but since the
    1:         // trees aren't necessarily in sync, we'll have to locate it.
    1:         // Note that we could set aShell's entry to null if we don't find a
    1:         // corresponding entry under destTreeParent.
    1: 
    1:         PRUint32 targetID, id;
    1:         aEntry->GetID(&targetID);
    1: 
    1:         // First look at the given index, since this is the common case.
    1:         nsCOMPtr<nsISHEntry> entry;
    1:         container->GetChildAt(aEntryIndex, getter_AddRefs(entry));
    1:         if (entry && NS_SUCCEEDED(entry->GetID(&id)) && id == targetID) {
    1:             destEntry.swap(entry);
    1:         } else {
    1:             PRInt32 childCount;
    1:             container->GetChildCount(&childCount);
    1:             for (PRInt32 i = 0; i < childCount; ++i) {
    1:                 container->GetChildAt(i, getter_AddRefs(entry));
    1:                 if (!entry)
    1:                     continue;
    1: 
    1:                 entry->GetID(&id);
    1:                 if (id == targetID) {
    1:                     destEntry.swap(entry);
    1:                     break;
    1:                 }
    1:             }
    1:         }
    1:     } else {
    1:         destEntry = destTreeRoot;
    1:     }
    1: 
    1:     aShell->SwapHistoryEntries(aEntry, destEntry);
    1: 
    1:     // Now handle the children of aEntry.
    1:     SwapEntriesData childData = { ignoreShell, destTreeRoot, destEntry };
    1:     return WalkHistoryEntries(aEntry, aShell,
    1:                               SetChildHistoryEntry, &childData);
    1: }
    1: 
    1: 
    1: static nsISHEntry*
    1: GetRootSHEntry(nsISHEntry *aEntry)
    1: {
    1:     nsCOMPtr<nsISHEntry> rootEntry = aEntry;
    1:     nsISHEntry *result = nsnull;
    1:     while (rootEntry) {
    1:         result = rootEntry;
    1:         result->GetParent(getter_AddRefs(rootEntry));
    1:     }
    1: 
    1:     return result;
    1: }
    1: 
    1: 
    1: void
    1: nsDocShell::SetHistoryEntry(nsCOMPtr<nsISHEntry> *aPtr, nsISHEntry *aEntry)
    1: {
    1:     // We need to sync up the docshell and session history trees for
    1:     // subframe navigation.  If the load was in a subframe, we forward up to
    1:     // the root docshell, which will then recursively sync up all docshells
    1:     // to their corresponding entries in the new session history tree.
    1:     // If we don't do this, then we can cache a content viewer on the wrong
    1:     // cloned entry, and subsequently restore it at the wrong time.
    1: 
    1:     nsISHEntry *newRootEntry = GetRootSHEntry(aEntry);
    1:     if (newRootEntry) {
    1:         // newRootEntry is now the new root entry.
    1:         // Find the old root entry as well.
    1: 
    1:         // Need a strong ref. on |oldRootEntry| so it isn't destroyed when
    1:         // SetChildHistoryEntry() does SwapHistoryEntries() (bug 304639).
    1:         nsCOMPtr<nsISHEntry> oldRootEntry = GetRootSHEntry(*aPtr);
    1:         if (oldRootEntry) {
79651:             nsCOMPtr<nsIDocShellTreeItem> rootAsItem;
79651:             GetSameTypeRootTreeItem(getter_AddRefs(rootAsItem));
79651:             nsCOMPtr<nsIDocShell> rootShell = do_QueryInterface(rootAsItem);
    1:             if (rootShell) { // if we're the root just set it, nothing to swap
    1:                 SwapEntriesData data = { this, newRootEntry };
    1:                 nsIDocShell *rootIDocShell =
 3233:                     static_cast<nsIDocShell*>(rootShell);
 3233:                 nsDocShell *rootDocShell = static_cast<nsDocShell*>
 3233:                                                       (rootIDocShell);
    1: 
    1: #ifdef NS_DEBUG
    1:                 nsresult rv =
    1: #endif
    1:                 SetChildHistoryEntry(oldRootEntry, rootDocShell,
    1:                                                    0, &data);
    1:                 NS_ASSERTION(NS_SUCCEEDED(rv), "SetChildHistoryEntry failed");
    1:             }
    1:         }
    1:     }
    1: 
    1:     *aPtr = aEntry;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsDocShell::GetRootSessionHistory(nsISHistory ** aReturn)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1:     //Get the root docshell
    1:     rv = GetSameTypeRootTreeItem(getter_AddRefs(root));
    1:     // QI to nsIWebNavigation
    1:     nsCOMPtr<nsIWebNavigation> rootAsWebnav(do_QueryInterface(root));
    1:     if (rootAsWebnav) {
    1:         // Get the handle to SH from the root docshell
    1:         rv = rootAsWebnav->GetSessionHistory(aReturn);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::GetHttpChannel(nsIChannel * aChannel, nsIHttpChannel ** aReturn)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aReturn);
    1:     if (!aChannel)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsIMultiPartChannel>  multiPartChannel(do_QueryInterface(aChannel));
    1:     if (multiPartChannel) {
    1:         nsCOMPtr<nsIChannel> baseChannel;
    1:         multiPartChannel->GetBaseChannel(getter_AddRefs(baseChannel));
    1:         nsCOMPtr<nsIHttpChannel>  httpChannel(do_QueryInterface(baseChannel));
    1:         *aReturn = httpChannel;
    1:         NS_IF_ADDREF(*aReturn);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
79445: bool 
    1: nsDocShell::ShouldDiscardLayoutState(nsIHttpChannel * aChannel)
    1: {    
    1:     // By default layout State will be saved. 
    1:     if (!aChannel)
    1:         return PR_FALSE;
    1: 
    1:     // figure out if SH should be saving layout state 
    1:     nsCOMPtr<nsISupports> securityInfo;
79445:     bool noStore = false, noCache = false;
    1:     aChannel->GetSecurityInfo(getter_AddRefs(securityInfo));
    1:     aChannel->IsNoStoreResponse(&noStore);
    1:     aChannel->IsNoCacheResponse(&noCache);
    1: 
    1:     return (noStore || (noCache && securityInfo));
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: nsIEditorDocShell
    1: //*****************************************************************************   
    1: 
    1: NS_IMETHODIMP nsDocShell::GetEditor(nsIEditor * *aEditor)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEditor);
14887: 
14887:   if (!mEditorData) {
14887:     *aEditor = nsnull;
14887:     return NS_OK;
14887:   }
    1: 
    1:   return mEditorData->GetEditor(aEditor);
    1: }
    1: 
    1: NS_IMETHODIMP nsDocShell::SetEditor(nsIEditor * aEditor)
    1: {
    1:   nsresult rv = EnsureEditorData();
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   return mEditorData->SetEditor(aEditor);
    1: }
    1: 
    1: 
79445: NS_IMETHODIMP nsDocShell::GetEditable(bool *aEditable)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEditable);
    1:   *aEditable = mEditorData && mEditorData->GetEditable();
    1:   return NS_OK;
    1: }
    1: 
    1: 
79445: NS_IMETHODIMP nsDocShell::GetHasEditingSession(bool *aHasEditingSession)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aHasEditingSession);
    1:   
    1:   if (mEditorData)
    1:   {
    1:     nsCOMPtr<nsIEditingSession> editingSession;
    1:     mEditorData->GetEditingSession(getter_AddRefs(editingSession));
    1:     *aHasEditingSession = (editingSession.get() != nsnull);
    1:   }
    1:   else
    1:   {
    1:     *aHasEditingSession = PR_FALSE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDocShell::MakeEditable(bool inWaitForUriLoad)
    1: {
    1:   nsresult rv = EnsureEditorData();
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   return mEditorData->MakeEditable(inWaitForUriLoad);
    1: }
    1: 
47715: bool
47715: nsDocShell::ChannelIsPost(nsIChannel* aChannel)
47715: {
47715:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
47715:     if (!httpChannel) {
47715:         return false;
47715:     }
47715: 
47715:     nsCAutoString method;
47715:     httpChannel->GetRequestMethod(method);
47715:     return method.Equals("POST");
47715: }
47715: 
47715: void
47715: nsDocShell::ExtractLastVisit(nsIChannel* aChannel,
47715:                              nsIURI** aURI,
47715:                              PRUint32* aChannelRedirectFlags)
47715: {
47715:     nsCOMPtr<nsIPropertyBag2> props(do_QueryInterface(aChannel));
47715:     if (!props) {
47715:         return;
47715:     }
47715: 
47715:     nsresult rv = props->GetPropertyAsInterface(
47715:         NS_LITERAL_STRING("docshell.previousURI"),
47715:         NS_GET_IID(nsIURI),
47715:         reinterpret_cast<void**>(aURI)
47715:     );
47715: 
47715:     if (NS_FAILED(rv)) {
47715:         // There is no last visit for this channel, so this must be the first
47715:         // link.  Link the visit to the referrer of this request, if any.
47715:         // Treat referrer as null if there is an error getting it.
47715:         (void)NS_GetReferrerFromChannel(aChannel, aURI);
47715:     }
47715:     else {
47715:       rv = props->GetPropertyAsUint32(
47715:           NS_LITERAL_STRING("docshell.previousFlags"),
47715:           aChannelRedirectFlags
47715:       );
47715: 
47715:       NS_WARN_IF_FALSE(
58635:           NS_SUCCEEDED(rv),
47715:           "Could not fetch previous flags, URI will be treated like referrer"
47715:       );
47715:     }
47715: }
47715: 
47715: void
47715: nsDocShell::SaveLastVisit(nsIChannel* aChannel,
47715:                           nsIURI* aURI,
47715:                           PRUint32 aChannelRedirectFlags)
47715: {
47715:     nsCOMPtr<nsIWritablePropertyBag2> props(do_QueryInterface(aChannel));
47715:     if (!props || !aURI) {
47715:         return;
47715:     }
47715: 
47715:     props->SetPropertyAsInterface(NS_LITERAL_STRING("docshell.previousURI"),
47715:                                   aURI);
47715:     props->SetPropertyAsUint32(NS_LITERAL_STRING("docshell.previousFlags"),
47715:                                aChannelRedirectFlags);
47715: }
47715: 
47715: void
47715: nsDocShell::AddURIVisit(nsIURI* aURI,
47715:                         nsIURI* aReferrerURI,
47715:                         nsIURI* aPreviousURI,
47715:                         PRUint32 aChannelRedirectFlags)
47715: {
47715:     NS_ASSERTION(aURI, "Visited URI is null!");
47715: 
61540:     // Only content-type docshells save URI visits.  Also don't do
61540:     // anything here if we're not supposed to use global history.
61540:     if (mItemType != typeContent || !mUseGlobalHistory) {
47715:         return;
47715:     }
47715: 
47715:     nsCOMPtr<IHistory> history = services::GetHistoryService();
47715: 
47715:     if (history) {
47715:         PRUint32 visitURIFlags = 0;
47715: 
47715:         if (!IsFrame()) {
47715:             visitURIFlags |= IHistory::TOP_LEVEL;
47715:         }
47715: 
47715:         if (aChannelRedirectFlags & nsIChannelEventSink::REDIRECT_TEMPORARY) {
47715:             visitURIFlags |= IHistory::REDIRECT_TEMPORARY;
47715:         }
47715:         else if (aChannelRedirectFlags &
47715:                  nsIChannelEventSink::REDIRECT_PERMANENT) {
47715:             visitURIFlags |= IHistory::REDIRECT_PERMANENT;
47715:         }
47715: 
47715:         (void)history->VisitURI(aURI, aPreviousURI, visitURIFlags);
47715:     }
47715:     else if (mGlobalHistory) {
47715:         // Falls back to sync global history interface.
47715:         (void)mGlobalHistory->AddURI(aURI,
47715:                                      !!aChannelRedirectFlags,
47715:                                      !IsFrame(),
47715:                                      aReferrerURI);
47715:     }
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell: Helper Routines
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetLoadType(PRUint32 aLoadType)
    1: {
    1:     mLoadType = aLoadType;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetLoadType(PRUint32 * aLoadType)
    1: {
    1:     *aLoadType = mLoadType;
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
79445: nsDocShell::ConfirmRepost(bool * aRepost)
    1: {
    1:   nsCOMPtr<nsIPrompt> prompter;
 3233:   CallGetInterface(this, static_cast<nsIPrompt**>(getter_AddRefs(prompter)));
60887:   if (!prompter) {
60887:       return NS_ERROR_NOT_AVAILABLE;
60887:   }
    1: 
42314:   nsCOMPtr<nsIStringBundleService> stringBundleService =
42314:     mozilla::services::GetStringBundleService();
42314:   if (!stringBundleService)
42314:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIStringBundle> appBundle;
42314:   nsresult rv = stringBundleService->CreateBundle(kAppstringsBundleURL,
    1:                                                   getter_AddRefs(appBundle));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIStringBundle> brandBundle;
    1:   rv = stringBundleService->CreateBundle(kBrandBundleURL, getter_AddRefs(brandBundle));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   NS_ASSERTION(prompter && brandBundle && appBundle,
    1:                "Unable to set up repost prompter.");
    1: 
    1:   nsXPIDLString brandName;
    1:   rv = brandBundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
    1:                                       getter_Copies(brandName));
 9886: 
 9886:   nsXPIDLString msgString, button0Title;
 9886:   if (NS_FAILED(rv)) { // No brand, use the generic version.
 9886:     rv = appBundle->GetStringFromName(NS_LITERAL_STRING("confirmRepostPrompt").get(),
 9886:                                       getter_Copies(msgString));
 9886:   }
 9886:   else {
 9886:     // Brand available - if the app has an override file with formatting, the app name will
 9886:     // be included. Without an override, the prompt will look like the generic version.
    1:     const PRUnichar *formatStrings[] = { brandName.get() };
 9886:     rv = appBundle->FormatStringFromName(NS_LITERAL_STRING("confirmRepostPrompt").get(),
80291:                                          formatStrings, NS_ARRAY_LENGTH(formatStrings),
    1:                                          getter_Copies(msgString));
 9886:   }
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   rv = appBundle->GetStringFromName(NS_LITERAL_STRING("resendButton.label").get(),
    1:                                     getter_Copies(button0Title));
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   PRInt32 buttonPressed;
71294:   // The actual value here is irrelevant, but we can't pass an invalid
79445:   // bool through XPConnect.
79445:   bool checkState = false;
    1:   rv = prompter->
    1:          ConfirmEx(nsnull, msgString.get(),
    1:                    (nsIPrompt::BUTTON_POS_0 * nsIPrompt::BUTTON_TITLE_IS_STRING) +
    1:                    (nsIPrompt::BUTTON_POS_1 * nsIPrompt::BUTTON_TITLE_CANCEL),
29073:                    button0Title.get(), nsnull, nsnull, nsnull, &checkState, &buttonPressed);
    1:   if (NS_FAILED(rv)) return rv;
    1: 
    1:   *aRepost = (buttonPressed == 0);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetPromptAndStringBundle(nsIPrompt ** aPrompt,
    1:                                      nsIStringBundle ** aStringBundle)
    1: {
    1:     NS_ENSURE_SUCCESS(GetInterface(NS_GET_IID(nsIPrompt), (void **) aPrompt),
    1:                       NS_ERROR_FAILURE);
    1: 
42314:     nsCOMPtr<nsIStringBundleService> stringBundleService =
42314:       mozilla::services::GetStringBundleService();
    1:     NS_ENSURE_TRUE(stringBundleService, NS_ERROR_FAILURE);
    1: 
    1:     NS_ENSURE_SUCCESS(stringBundleService->
    1:                       CreateBundle(kAppstringsBundleURL,
    1:                                    aStringBundle),
    1:                       NS_ERROR_FAILURE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetChildOffset(nsIDOMNode * aChild, nsIDOMNode * aParent,
    1:                            PRInt32 * aOffset)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aChild || aParent);
    1: 
    1:     nsCOMPtr<nsIDOMNodeList> childNodes;
    1:     NS_ENSURE_SUCCESS(aParent->GetChildNodes(getter_AddRefs(childNodes)),
    1:                       NS_ERROR_FAILURE);
    1:     NS_ENSURE_TRUE(childNodes, NS_ERROR_FAILURE);
    1: 
    1:     PRInt32 i = 0;
    1: 
    1:     for (; PR_TRUE; i++) {
    1:         nsCOMPtr<nsIDOMNode> childNode;
    1:         NS_ENSURE_SUCCESS(childNodes->Item(i, getter_AddRefs(childNode)),
    1:                           NS_ERROR_FAILURE);
    1:         NS_ENSURE_TRUE(childNode, NS_ERROR_FAILURE);
    1: 
    1:         if (childNode.get() == aChild) {
    1:             *aOffset = i;
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
37072: nsIScrollableFrame *
37072: nsDocShell::GetRootScrollFrame()
37072: {
    1:     nsCOMPtr<nsIPresShell> shell;
37072:     NS_ENSURE_SUCCESS(GetPresShell(getter_AddRefs(shell)), nsnull);
37072:     NS_ENSURE_TRUE(shell, nsnull);
37072: 
37072:     return shell->GetRootScrollFrameAsScrollableExternal();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::EnsureScriptEnvironment()
    1: {
    1:     if (mScriptGlobal)
    1:         return NS_OK;
    1: 
    1:     if (mIsBeingDestroyed) {
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1: 
41653:     NS_TIME_FUNCTION;
41653: 
 7837: #ifdef DEBUG
 7837:     NS_ASSERTION(!mInEnsureScriptEnv,
 7837:                  "Infinite loop! Calling EnsureScriptEnvironment() from "
 7837:                  "within EnsureScriptEnvironment()!");
 7837: 
 7837:     // Yeah, this isn't re-entrant safe, but that's ok since if we
 7837:     // re-enter this method, we'll infinitely loop...
79445:     AutoRestore<bool> boolSetter(mInEnsureScriptEnv);
74021:     mInEnsureScriptEnv = PR_TRUE;
 7837: #endif
 7837: 
    1:     nsCOMPtr<nsIDOMScriptObjectFactory> factory =
    1:         do_GetService(kDOMScriptObjectFactoryCID);
    1:     NS_ENSURE_TRUE(factory, NS_ERROR_FAILURE);
    1: 
 4422:     nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(mTreeOwner));
36177:     NS_ENSURE_TRUE(browserChrome, NS_ERROR_NOT_AVAILABLE);
 4422: 
 4422:     PRUint32 chromeFlags;
 4422:     browserChrome->GetChromeFlags(&chromeFlags);
 4422: 
79445:     bool isModalContentWindow =
 4422:         (chromeFlags & nsIWebBrowserChrome::CHROME_MODAL) &&
 4422:         !(chromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME);
 4422: 
 4422:     // If our window is modal and we're not opened as chrome, make
 4422:     // this window a modal content window.
    1:     factory->NewScriptGlobalObject(mItemType == typeChrome,
 4422:                                    isModalContentWindow,
    1:                                    getter_AddRefs(mScriptGlobal));
    1:     NS_ENSURE_TRUE(mScriptGlobal, NS_ERROR_FAILURE);
    1: 
    1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
 3233:     win->SetDocShell(static_cast<nsIDocShell *>(this));
    1: 
    1:     // Ensure the script object is set to run javascript - other languages
    1:     // setup on demand.
    1:     // XXXmarkh - should this be setup to run the default language for this doc?
    1:     nsresult rv;
    1:     rv = mScriptGlobal->EnsureScriptEnvironment(nsIProgrammingLanguage::JAVASCRIPT);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 7837: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::EnsureEditorData()
    1: {
79445:     bool openDocHasDetachedEditor = mOSHE && mOSHE->HasDetachedEditor();
14887:     if (!mEditorData && !mIsBeingDestroyed && !openDocHasDetachedEditor) {
14887:         // We shouldn't recreate the editor data if it already exists, or
14887:         // we're shutting down, or we already have a detached editor data
14887:         // stored in the session history. We should only have one editordata
14887:         // per docshell.
    1:         mEditorData = new nsDocShellEditorData(this);
    1:     }
    1: 
    1:     return mEditorData ? NS_OK : NS_ERROR_NOT_AVAILABLE;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::EnsureTransferableHookData()
    1: {
    1:     if (!mTransferableHookData) {
    1:         mTransferableHookData = new nsTransferableHookData();
    1:         if (!mTransferableHookData) return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsDocShell::EnsureFind()
    1: {
    1:     nsresult rv;
    1:     if (!mFind)
    1:     {
    1:         mFind = do_CreateInstance("@mozilla.org/embedcomp/find;1", &rv);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1:     
    1:     // we promise that the nsIWebBrowserFind that we return has been set
    1:     // up to point to the focused, or content window, so we have to
    1:     // set that up each time.
    1: 
    1:     nsIScriptGlobalObject* scriptGO = GetScriptGlobalObject();
    1:     NS_ENSURE_TRUE(scriptGO, NS_ERROR_UNEXPECTED);
    1: 
    1:     // default to our window
29018:     nsCOMPtr<nsIDOMWindow> windowToSearch(do_QueryInterface(mScriptGlobal));
29018: 
29018:     nsCOMPtr<nsIDocShellTreeItem> root;
29018:     GetRootTreeItem(getter_AddRefs(root));
29018: 
29018:     // if the active window is the same window that this docshell is in,
29018:     // use the currently focused frame
29018:     nsCOMPtr<nsIDOMWindow> rootWindow = do_GetInterface(root);
29018:     nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
29018:     if (fm) {
29018:       nsCOMPtr<nsIDOMWindow> activeWindow;
29018:       fm->GetActiveWindow(getter_AddRefs(activeWindow));
29018:       if (activeWindow == rootWindow)
29018:         fm->GetFocusedWindow(getter_AddRefs(windowToSearch));
    1:     }
    1: 
    1:     nsCOMPtr<nsIWebBrowserFindInFrames> findInFrames = do_QueryInterface(mFind);
    1:     if (!findInFrames) return NS_ERROR_NO_INTERFACE;
    1:     
    1:     rv = findInFrames->SetRootSearchFrame(rootWindow);
    1:     if (NS_FAILED(rv)) return rv;
    1:     rv = findInFrames->SetCurrentSearchFrame(windowToSearch);
    1:     if (NS_FAILED(rv)) return rv;
    1:     
    1:     return NS_OK;
    1: }
    1: 
79445: bool
    1: nsDocShell::IsFrame()
    1: {
    1:     nsCOMPtr<nsIDocShellTreeItem> parent =
    1:         do_QueryInterface(GetAsSupports(mParent));
    1:     if (parent) {
    1:         PRInt32 parentType = ~mItemType;        // Not us
    1:         parent->GetItemType(&parentType);
    1:         if (parentType == mItemType)    // This is a frame
    1:             return PR_TRUE;
    1:     }
    1: 
    1:     return PR_FALSE;
    1: }
    1: 
    1: /* boolean IsBeingDestroyed (); */
    1: NS_IMETHODIMP 
79445: nsDocShell::IsBeingDestroyed(bool *aDoomed)
    1: {
    1:   NS_ENSURE_ARG(aDoomed);
    1:   *aDoomed = mIsBeingDestroyed;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
79445: nsDocShell::GetIsExecutingOnLoadHandler(bool *aResult)
    1: {
    1:   NS_ENSURE_ARG(aResult);
    1:   *aResult = mIsExecutingOnLoadHandler;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetLayoutHistoryState(nsILayoutHistoryState **aLayoutHistoryState)
    1: {
    1:   if (mOSHE)
    1:     mOSHE->GetLayoutHistoryState(aLayoutHistoryState);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::SetLayoutHistoryState(nsILayoutHistoryState *aLayoutHistoryState)
    1: {
    1:   if (mOSHE)
    1:     mOSHE->SetLayoutHistoryState(aLayoutHistoryState);
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: //***    nsRefreshTimer: Object Management
    1: //*****************************************************************************
    1: 
    1: nsRefreshTimer::nsRefreshTimer()
    1:     : mDelay(0), mRepeat(PR_FALSE), mMetaRefresh(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsRefreshTimer::~nsRefreshTimer()
    1: {
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsRefreshTimer::nsISupports
    1: //*****************************************************************************   
    1: 
    1: NS_IMPL_THREADSAFE_ADDREF(nsRefreshTimer)
    1: NS_IMPL_THREADSAFE_RELEASE(nsRefreshTimer)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsRefreshTimer)
    1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsITimerCallback)
    1:     NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
    1: NS_INTERFACE_MAP_END_THREADSAFE
    1: 
    1: ///*****************************************************************************
    1: // nsRefreshTimer::nsITimerCallback
    1: //******************************************************************************
    1: NS_IMETHODIMP
    1: nsRefreshTimer::Notify(nsITimer * aTimer)
    1: {
    1:     NS_ASSERTION(mDocShell, "DocShell is somehow null");
    1: 
    1:     if (mDocShell && aTimer) {
    1:         // Get the delay count to determine load type
    1:         PRUint32 delay = 0;
    1:         aTimer->GetDelay(&delay);
18977:         mDocShell->ForceRefreshURIFromTimer(mURI, delay, mMetaRefresh, aTimer);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::InterfaceRequestorProxy
    1: //*****************************************************************************
    1: nsDocShell::InterfaceRequestorProxy::InterfaceRequestorProxy(nsIInterfaceRequestor* p)
    1: {
    1:     if (p) {
    1:         mWeakPtr = do_GetWeakReference(p);
    1:     }
    1: }
    1:  
    1: nsDocShell::InterfaceRequestorProxy::~InterfaceRequestorProxy()
    1: {
    1:     mWeakPtr = nsnull;
    1: }
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsDocShell::InterfaceRequestorProxy, nsIInterfaceRequestor) 
    1:   
    1: NS_IMETHODIMP 
    1: nsDocShell::InterfaceRequestorProxy::GetInterface(const nsIID & aIID, void **aSink)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aSink);
    1:     nsCOMPtr<nsIInterfaceRequestor> ifReq = do_QueryReferent(mWeakPtr);
    1:     if (ifReq) {
    1:         return ifReq->GetInterface(aIID, aSink);
    1:     }
    1:     *aSink = nsnull;
    1:     return NS_NOINTERFACE;
    1: }
    1: 
    1: nsresult
    1: nsDocShell::SetBaseUrlForWyciwyg(nsIContentViewer * aContentViewer)
    1: {
    1:     if (!aContentViewer)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsCOMPtr<nsIURI> baseURI;
    1:     nsresult rv = NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     if (sURIFixup)
    1:         rv = sURIFixup->CreateExposableURI(mCurrentURI,
    1:                                            getter_AddRefs(baseURI));
    1: 
    1:     // Get the current document and set the base uri
    1:     if (baseURI) {
37433:         nsIDocument* document = aContentViewer->GetDocument();
37433:         if (document) {
    1:             rv = document->SetBaseURI(baseURI);
    1:         }
    1:     }
    1:     return rv;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIAuthPromptProvider
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::GetAuthPrompt(PRUint32 aPromptReason, const nsIID& iid,
    1:                           void** aResult)
    1: {
    1:     // a priority prompt request will override a false mAllowAuth setting
79445:     bool priorityPrompt = (aPromptReason == PROMPT_PROXY);
    1: 
    1:     if (!mAllowAuth && !priorityPrompt)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // we're either allowing auth, or it's a proxy request
    1:     nsresult rv;
    1:     nsCOMPtr<nsIPromptFactory> wwatch =
    1:       do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = EnsureScriptEnvironment();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIDOMWindow> window(do_QueryInterface(mScriptGlobal));
    1: 
    1:     // Get the an auth prompter for our window so that the parenting
    1:     // of the dialogs works as it should when using tabs.
    1: 
    1:     return wwatch->GetPrompt(window, iid,
 3233:                              reinterpret_cast<void**>(aResult));
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsDocShell::nsIObserver
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsDocShell::Observe(nsISupports *aSubject, const char *aTopic,
    1:                     const PRUnichar *aData)
    1: {
    1:     nsresult rv = NS_OK;
    1:     if (mObserveErrorPages &&
    1:         !nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) &&
    1:         !nsCRT::strcmp(aData,
    1:           NS_LITERAL_STRING("browser.xul.error_pages.enabled").get())) {
    1: 
79445:         bool tmpbool;
72449:         rv = Preferences::GetBool("browser.xul.error_pages.enabled", &tmpbool);
    1:         if (NS_SUCCEEDED(rv))
    1:             mUseErrorPages = tmpbool;
    1: 
    1:     } else {
    1:         rv = NS_ERROR_UNEXPECTED;
    1:     }
    1:     return rv;
    1: }
    1: 
21877: //*****************************************************************************
21877: // nsDocShell::nsILoadContext
21877: //*****************************************************************************
21877: NS_IMETHODIMP
21877: nsDocShell::GetAssociatedWindow(nsIDOMWindow** aWindow)
21877: {
51517:     CallGetInterface(this, aWindow);
51517:     return NS_OK;
21877: }
21877: 
21877: NS_IMETHODIMP
21877: nsDocShell::GetTopWindow(nsIDOMWindow** aWindow)
21877: {
51517:     nsCOMPtr<nsIDOMWindow> win = do_GetInterface(GetAsSupports(this));
51517:     if (win) {
51517:         win->GetTop(aWindow);
51517:     }
51517:     return NS_OK;
21877: }
21877: 
21877: NS_IMETHODIMP
79445: nsDocShell::IsAppOfType(PRUint32 aAppType, bool *aIsOfType)
21877: {
21877:     nsCOMPtr<nsIDocShell> shell = this;
21877:     while (shell) {
21877:         PRUint32 type;
21877:         shell->GetAppType(&type);
21877:         if (type == aAppType) {
21877:             *aIsOfType = PR_TRUE;
21877:             return NS_OK;
21877:         }
21877:         nsCOMPtr<nsIDocShellTreeItem> item = do_QueryInterface(shell);
21877:         nsCOMPtr<nsIDocShellTreeItem> parent;
21877:         item->GetParent(getter_AddRefs(parent));
21877:         shell = do_QueryInterface(parent);
21877:     }
21877: 
21877:     *aIsOfType = PR_FALSE;
21877:     return NS_OK;
21877: }
21877: 
21877: NS_IMETHODIMP
79445: nsDocShell::GetIsContent(bool *aIsContent)
21877: {
21877:     *aIsContent = (mItemType == typeContent);
21877:     return NS_OK;
21877: }
21877: 
79445: bool
10676: nsDocShell::IsOKToLoadURI(nsIURI* aURI)
10676: {
10676:     NS_PRECONDITION(aURI, "Must have a URI!");
10676:     
10676:     if (!mFiredUnloadEvent) {
10676:         return PR_TRUE;
10676:     }
10676: 
10676:     if (!mLoadingURI) {
10676:         return PR_FALSE;
10676:     }
10676: 
10676:     nsCOMPtr<nsIScriptSecurityManager> secMan =
10676:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
10676:     return
10676:         secMan &&
10676:         NS_SUCCEEDED(secMan->CheckSameOriginURI(aURI, mLoadingURI, PR_FALSE));
10676: }
10676: 
28078: //
28078: // Routines for selection and clipboard
28078: //
28078: nsresult
28078: nsDocShell::GetControllerForCommand(const char * inCommand,
28078:                                     nsIController** outController)
28078: {
28078:   NS_ENSURE_ARG_POINTER(outController);
28078:   *outController = nsnull;
28078: 
28078:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(mScriptGlobal));
28078:   if (window) {
38336:       nsCOMPtr<nsPIWindowRoot> root = window->GetTopWindowRoot();
38336:       if (root) {
38336:           return root->GetControllerForCommand(inCommand, outController);
38336:       }
38336:   }
38336: 
38336:   return NS_ERROR_FAILURE;
28078: }
28078: 
28078: nsresult
79445: nsDocShell::IsCommandEnabled(const char * inCommand, bool* outEnabled)
28078: {
28078:   NS_ENSURE_ARG_POINTER(outEnabled);
28078:   *outEnabled = PR_FALSE;
28078: 
28078:   nsresult rv = NS_ERROR_FAILURE;
28078:   
28078:   nsCOMPtr<nsIController> controller;
28078:   rv = GetControllerForCommand (inCommand, getter_AddRefs(controller));
28078:   if (controller)
28078:     rv = controller->IsCommandEnabled(inCommand, outEnabled);
28078:   
28078:   return rv;
28078: }
28078: 
28078: nsresult
28078: nsDocShell::DoCommand(const char * inCommand)
28078: {
28078:   nsresult rv = NS_ERROR_FAILURE;
28078:   
28078:   nsCOMPtr<nsIController> controller;
28078:   rv = GetControllerForCommand(inCommand, getter_AddRefs(controller));
28078:   if (controller)
28078:     rv = controller->DoCommand(inCommand);
28078:   
28078:   return rv;
28078: }
28078: 
28078: nsresult
28078: nsDocShell::EnsureCommandHandler()
28078: {
28078:   if (!mCommandManager)
28078:   {
28078:     nsCOMPtr<nsPICommandUpdater> commandUpdater =
28078:       do_CreateInstance("@mozilla.org/embedcomp/command-manager;1");
28078:     if (!commandUpdater) return NS_ERROR_OUT_OF_MEMORY;
28078:     
28078:     nsCOMPtr<nsIDOMWindow> domWindow =
28078:       do_GetInterface(static_cast<nsIInterfaceRequestor *>(this));
28078: 
28078:     nsresult rv = commandUpdater->Init(domWindow);
28078:     if (NS_SUCCEEDED(rv))
28078:       mCommandManager = do_QueryInterface(commandUpdater);
28078:   }
28078:   
28078:   return mCommandManager ? NS_OK : NS_ERROR_FAILURE;
28078: }
28078: 
28078: NS_IMETHODIMP
79445: nsDocShell::CanCutSelection(bool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_cut", aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
79445: nsDocShell::CanCopySelection(bool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_copy", aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
79445: nsDocShell::CanCopyLinkLocation(bool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_copyLink", aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
79445: nsDocShell::CanCopyImageLocation(bool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_copyImageLocation",
28078:                           aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
79445: nsDocShell::CanCopyImageContents(bool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_copyImageContents",
28078:                           aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
79445: nsDocShell::CanPaste(bool* aResult)
28078: {
28078:   return IsCommandEnabled("cmd_paste", aResult);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CutSelection(void)
28078: {
28078:   return DoCommand ( "cmd_cut" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CopySelection(void)
28078: {
28078:   return DoCommand ( "cmd_copy" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CopyLinkLocation(void)
28078: {
28078:   return DoCommand ( "cmd_copyLink" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CopyImageLocation(void)
28078: {
28078:   return DoCommand ( "cmd_copyImageLocation" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::CopyImageContents(void)
28078: {
28078:   return DoCommand ( "cmd_copyImageContents" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::Paste(void)
28078: {
28078:   return DoCommand ( "cmd_paste" );
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::SelectAll(void)
28078: {
28078:   return DoCommand ( "cmd_selectAll" );
28078: }
28078: 
28078: //
28078: // SelectNone
28078: //
28078: // Collapses the current selection, insertion point ends up at beginning
28078: // of previous selection.
28078: //
28078: NS_IMETHODIMP
28078: nsDocShell::SelectNone(void)
28078: {
28078:   return DoCommand ( "cmd_selectNone" );
28078: }
28078: 
28078: //----------------------------------------------------------------------
28078: 
28078: // link handling
28078: 
28078: class OnLinkClickEvent : public nsRunnable {
28078: public:
28078:   OnLinkClickEvent(nsDocShell* aHandler, nsIContent* aContent,
28078:                    nsIURI* aURI,
28078:                    const PRUnichar* aTargetSpec,
72783:                    nsIInputStream* aPostDataStream, 
72783:                    nsIInputStream* aHeadersDataStream,
79445:                    bool aIsTrusted);
28078: 
28078:   NS_IMETHOD Run() {
28078:     nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(mHandler->mScriptGlobal));
28078:     nsAutoPopupStatePusher popupStatePusher(window, mPopupState);
28078: 
72783:     nsCxPusher pusher;
72783:     if (mIsTrusted || pusher.Push(mContent)) {
28078:       mHandler->OnLinkClickSync(mContent, mURI,
28078:                                 mTargetSpec.get(), mPostDataStream,
28078:                                 mHeadersDataStream,
28078:                                 nsnull, nsnull);
72783:     }
28078:     return NS_OK;
28078:   }
28078: 
28078: private:
28078:   nsRefPtr<nsDocShell>     mHandler;
28078:   nsCOMPtr<nsIURI>         mURI;
28078:   nsString                 mTargetSpec;
28078:   nsCOMPtr<nsIInputStream> mPostDataStream;
28078:   nsCOMPtr<nsIInputStream> mHeadersDataStream;
28078:   nsCOMPtr<nsIContent>     mContent;
28078:   PopupControlState        mPopupState;
79445:   bool                     mIsTrusted;
28078: };
28078: 
28078: OnLinkClickEvent::OnLinkClickEvent(nsDocShell* aHandler,
28078:                                    nsIContent *aContent,
28078:                                    nsIURI* aURI,
28078:                                    const PRUnichar* aTargetSpec,
28078:                                    nsIInputStream* aPostDataStream,
72783:                                    nsIInputStream* aHeadersDataStream,
79445:                                    bool aIsTrusted)
28078:   : mHandler(aHandler)
28078:   , mURI(aURI)
28078:   , mTargetSpec(aTargetSpec)
28078:   , mPostDataStream(aPostDataStream)
28078:   , mHeadersDataStream(aHeadersDataStream)
28078:   , mContent(aContent)
72783:   , mIsTrusted(aIsTrusted)
28078: {
28078:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(mHandler->mScriptGlobal));
28078: 
28078:   mPopupState = window->GetPopupControlState();
28078: }
28078: 
28078: //----------------------------------------
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::OnLinkClick(nsIContent* aContent,
28078:                         nsIURI* aURI,
28078:                         const PRUnichar* aTargetSpec,
28078:                         nsIInputStream* aPostDataStream,
72783:                         nsIInputStream* aHeadersDataStream,
79445:                         bool aIsTrusted)
28078: {
28078:   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
28078: 
28078:   if (!IsOKToLoadURI(aURI)) {
28078:     return NS_OK;
28078:   }
28078: 
28078:   if (aContent->IsEditable()) {
28078:     return NS_OK;
28078:   }
28078: 
56685:   nsresult rv = NS_ERROR_FAILURE;
56685:   nsAutoString target;
56685: 
56685:   nsCOMPtr<nsIWebBrowserChrome3> browserChrome3 = do_GetInterface(mTreeOwner);
56685:   if (browserChrome3) {
56685:     nsCOMPtr<nsIDOMNode> linkNode = do_QueryInterface(aContent);
56685:     nsAutoString oldTarget(aTargetSpec);
56685:     rv = browserChrome3->OnBeforeLinkTraversal(oldTarget, aURI,
56685:                                                linkNode, mIsAppTab, target);
56685:   }
56685:   
56685:   if (NS_FAILED(rv))
56685:     target = aTargetSpec;  
56685: 
28078:   nsCOMPtr<nsIRunnable> ev =
56685:       new OnLinkClickEvent(this, aContent, aURI, target.get(),
72783:                            aPostDataStream, aHeadersDataStream, aIsTrusted);
28078:   return NS_DispatchToCurrentThread(ev);
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::OnLinkClickSync(nsIContent *aContent,
28078:                             nsIURI* aURI,
28078:                             const PRUnichar* aTargetSpec,
28078:                             nsIInputStream* aPostDataStream,
28078:                             nsIInputStream* aHeadersDataStream,
28078:                             nsIDocShell** aDocShell,
54823:                             nsIRequest** aRequest)
28078: {
28078:   // Initialize the DocShell / Request
28078:   if (aDocShell) {
28078:     *aDocShell = nsnull;
28078:   }
28078:   if (aRequest) {
28078:     *aRequest = nsnull;
28078:   }
28078: 
28078:   if (!IsOKToLoadURI(aURI)) {
28078:     return NS_OK;
28078:   }
28078: 
28078:   if (aContent->IsEditable()) {
28078:     return NS_OK;
28078:   }
28078: 
28078:   {
28078:     // defer to an external protocol handler if necessary...
28078:     nsCOMPtr<nsIExternalProtocolService> extProtService =
28078:         do_GetService(NS_EXTERNALPROTOCOLSERVICE_CONTRACTID);
28078:     if (extProtService) {
28078:       nsCAutoString scheme;
28078:       aURI->GetScheme(scheme);
28078:       if (!scheme.IsEmpty()) {
28078:         // if the URL scheme does not correspond to an exposed protocol, then we
28078:         // need to hand this link click over to the external protocol handler.
79445:         bool isExposed;
28078:         nsresult rv = extProtService->IsExposedProtocol(scheme.get(), &isExposed);
28078:         if (NS_SUCCEEDED(rv) && !isExposed) {
28078:           return extProtService->LoadURI(aURI, this); 
28078:         }
28078:       }
28078:     }
28078:   }
28078: 
28078:   // Get the owner document of the link that was clicked, this will be
28078:   // the document that the link is in, or the last document that the
28078:   // link was in. From that document, we'll get the URI to use as the
28078:   // referer, since the current URI in this docshell may be a
28078:   // new document that we're in the process of loading.
28078:   nsCOMPtr<nsIDocument> refererDoc = aContent->GetOwnerDoc();
28078:   NS_ENSURE_TRUE(refererDoc, NS_ERROR_UNEXPECTED);
28078: 
72519:   // Now check that the refererDoc's inner window is the current inner
72519:   // window for mScriptGlobal.  If it's not, then we don't want to
72519:   // follow this link.
72519:   nsPIDOMWindow* refererInner = refererDoc->GetInnerWindow();
72519:   NS_ENSURE_TRUE(refererInner, NS_ERROR_UNEXPECTED);
72519:   nsCOMPtr<nsPIDOMWindow> outerWindow = do_QueryInterface(mScriptGlobal);
72519:   if (!outerWindow || outerWindow->GetCurrentInnerWindow() != refererInner) {
72519:       // We're no longer the current inner window
72519:       return NS_OK;
72519:   }
72519: 
28078:   nsCOMPtr<nsIURI> referer = refererDoc->GetDocumentURI();
28078: 
28078:   // referer could be null here in some odd cases, but that's ok,
28078:   // we'll just load the link w/o sending a referer in those cases.
28078: 
28078:   nsAutoString target(aTargetSpec);
28078: 
28078:   // If this is an anchor element, grab its type property to use as a hint
28078:   nsAutoString typeHint;
28078:   nsCOMPtr<nsIDOMHTMLAnchorElement> anchor(do_QueryInterface(aContent));
28078:   if (anchor) {
28078:     anchor->GetType(typeHint);
48102:     NS_ConvertUTF16toUTF8 utf8Hint(typeHint);
48102:     nsCAutoString type, dummy;
48102:     NS_ParseContentType(utf8Hint, type, dummy);
48102:     CopyUTF8toUTF16(type, typeHint);
28078:   }
28078: 
78936:   // Clone the URI now, in case a content policy or something messes
78936:   // with it under InternalLoad; we do _not_ want to change the URI
78936:   // our caller passed in.
78936:   nsCOMPtr<nsIURI> clonedURI;
78936:   aURI->Clone(getter_AddRefs(clonedURI));
78936:   if (!clonedURI) {
78936:     return NS_ERROR_OUT_OF_MEMORY;
78936:   }
78936:   
78936:   nsresult rv = InternalLoad(clonedURI,                 // New URI
28078:                              referer,                   // Referer URI
28078:                              aContent->NodePrincipal(), // Owner is our node's
28078:                                                         // principal
28078:                              INTERNAL_LOAD_FLAGS_NONE,
28078:                              target.get(),              // Window target
28078:                              NS_LossyConvertUTF16toASCII(typeHint).get(),
28078:                              aPostDataStream,           // Post data stream
28078:                              aHeadersDataStream,        // Headers stream
28078:                              LOAD_LINK,                 // Load type
28078:                              nsnull,                    // No SHEntry
28078:                              PR_TRUE,                   // first party site
28078:                              aDocShell,                 // DocShell out-param
54823:                              aRequest);                 // Request out-param
28078:   if (NS_SUCCEEDED(rv)) {
28078:     DispatchPings(aContent, referer);
28078:   }
28078:   return rv;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::OnOverLink(nsIContent* aContent,
28078:                        nsIURI* aURI,
28078:                        const PRUnichar* aTargetSpec)
28078: {
28078:   if (aContent->IsEditable()) {
28078:     return NS_OK;
28078:   }
28078: 
28078:   nsCOMPtr<nsIWebBrowserChrome2> browserChrome2 = do_GetInterface(mTreeOwner);
28078:   nsresult rv = NS_ERROR_FAILURE;
28078: 
28078:   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
28078:   if (!browserChrome2) {
28078:     browserChrome = do_GetInterface(mTreeOwner);
28078:     if (!browserChrome)
28078:       return rv;
28078:   }
28078: 
28078:   nsCOMPtr<nsITextToSubURI> textToSubURI =
28078:       do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
28078:   if (NS_FAILED(rv))
28078:     return rv;
28078: 
28078:   // use url origin charset to unescape the URL
28078:   nsCAutoString charset;
28078:   rv = aURI->GetOriginCharset(charset);
28078:   NS_ENSURE_SUCCESS(rv, rv);
28078: 
28078:   nsCAutoString spec;
28078:   rv = aURI->GetSpec(spec);
28078:   NS_ENSURE_SUCCESS(rv, rv);
28078: 
28078:   nsAutoString uStr;
28078:   rv = textToSubURI->UnEscapeURIForUI(charset, spec, uStr);    
28078:   NS_ENSURE_SUCCESS(rv, rv);
28078: 
28078:   if (browserChrome2) {
28078:     nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aContent);
28078:     rv = browserChrome2->SetStatusWithContext(nsIWebBrowserChrome::STATUS_LINK,
28078:                                               uStr, element);
28078:   } else {
28078:     rv = browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_LINK, uStr.get());
28078:   }
28078:   return rv;
28078: }
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::OnLeaveLink()
28078: {
28078:   nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(mTreeOwner));
28078:   nsresult rv = NS_ERROR_FAILURE;
28078: 
28078:   if (browserChrome)  {
28078:       rv = browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_LINK,
28078:                                     EmptyString().get());
28078:   }
28078:   return rv;
28078: }
28078: 
28078: //----------------------------------------------------------------------
28078: // Web Shell Services API
28078: 
28078: //This functions is only called when a new charset is detected in loading a document. 
28078: //Its name should be changed to "CharsetReloadDocument"
28078: NS_IMETHODIMP
28078: nsDocShell::ReloadDocument(const char* aCharset,
28078:                            PRInt32 aSource)
28078: {
28078: 
38791:   // XXX hack. keep the aCharset and aSource wait to pick it up
28078:   nsCOMPtr<nsIContentViewer> cv;
28078:   NS_ENSURE_SUCCESS(GetContentViewer(getter_AddRefs(cv)), NS_ERROR_FAILURE);
28078:   if (cv)
28078:   {
28078:     nsCOMPtr<nsIMarkupDocumentViewer> muDV = do_QueryInterface(cv);  
28078:     if (muDV)
28078:     {
28078:       PRInt32 hint;
28078:       muDV->GetHintCharacterSetSource(&hint);
28078:       if (aSource > hint)
28078:       {
38791:         nsCString charset(aCharset);
38791:         muDV->SetHintCharacterSet(charset);
28078:         muDV->SetHintCharacterSetSource(aSource);
28078:         if(eCharsetReloadRequested != mCharsetReloadState) 
28078:         {
28078:           mCharsetReloadState = eCharsetReloadRequested;
28078:           return Reload(LOAD_FLAGS_CHARSET_CHANGE);
28078:         }
28078:       }
28078:     }
28078:   }
38791:   //return failure if this request is not accepted due to mCharsetReloadState
28078:   return NS_ERROR_DOCSHELL_REQUEST_REJECTED;
28078: }
28078: 
28078: 
28078: NS_IMETHODIMP
28078: nsDocShell::StopDocumentLoad(void)
28078: {
28078:   if(eCharsetReloadRequested != mCharsetReloadState) 
28078:   {
28078:     Stop(nsIWebNavigation::STOP_ALL);
28078:     return NS_OK;
28078:   }
28078:   //return failer if this request is not accepted due to mCharsetReloadState
28078:   return NS_ERROR_DOCSHELL_REQUEST_REJECTED;
28078: }
28078: 
28078: NS_IMETHODIMP
35581: nsDocShell::GetPrintPreview(nsIWebBrowserPrint** aPrintPreview)
35581: {
35581:   *aPrintPreview = nsnull;
35581: #if NS_PRINT_PREVIEW
35581:   nsCOMPtr<nsIDocumentViewerPrint> print = do_QueryInterface(mContentViewer);
35581:   if (!print || !print->IsInitializedForPrintPreview()) {
35581:     Stop(nsIWebNavigation::STOP_ALL);
35581:     nsCOMPtr<nsIPrincipal> principal =
35581:       do_CreateInstance("@mozilla.org/nullprincipal;1");
35581:     NS_ENSURE_STATE(principal);
35581:     nsresult rv = CreateAboutBlankContentViewer(principal, nsnull);
35581:     NS_ENSURE_SUCCESS(rv, rv);
35581:     print = do_QueryInterface(mContentViewer);
35581:     NS_ENSURE_STATE(print);
35581:     print->InitializeForPrintPreview();
35581:   }
35581:   nsCOMPtr<nsIWebBrowserPrint> result = do_QueryInterface(print);
35581:   result.forget(aPrintPreview);
35581:   return NS_OK;
35581: #else
35581:   return NS_ERROR_NOT_IMPLEMENTED;
35581: #endif
35581: }
35581: 
70432: 
28078: #ifdef DEBUG
28078: unsigned long nsDocShell::gNumberOfDocShells = 0;
28078: #endif
46407: 
46407: NS_IMETHODIMP
79445: nsDocShell::GetCanExecuteScripts(bool *aResult)
46407: {
46407:   NS_ENSURE_ARG_POINTER(aResult);
46407:   *aResult = PR_FALSE; // disallow by default
46407: 
46407:   nsCOMPtr<nsIDocShell> docshell = this;
46407:   nsCOMPtr<nsIDocShellTreeItem> globalObjTreeItem =
46407:       do_QueryInterface(docshell);
46407: 
46407:   if (globalObjTreeItem)
46407:   {
46407:       nsCOMPtr<nsIDocShellTreeItem> treeItem(globalObjTreeItem);
46407:       nsCOMPtr<nsIDocShellTreeItem> parentItem;
79445:       bool firstPass = true;
79445:       bool lookForParents = false;
46407: 
46407:       // Walk up the docshell tree to see if any containing docshell disallows scripts
46407:       do
46407:       {
46407:           nsresult rv = docshell->GetAllowJavascript(aResult);
46407:           if (NS_FAILED(rv)) return rv;
46407:           if (!*aResult) {
46407:               nsDocShell* realDocshell = static_cast<nsDocShell*>(docshell.get());
46407:               if (realDocshell->mContentViewer) {
46407:                   nsIDocument* doc = realDocshell->mContentViewer->GetDocument();
46407:                   if (doc && doc->HasFlag(NODE_IS_EDITABLE) &&
46407:                       realDocshell->mEditorData) {
46407:                       nsCOMPtr<nsIEditingSession> editSession;
46407:                       realDocshell->mEditorData->GetEditingSession(getter_AddRefs(editSession));
79445:                       bool jsDisabled = false;
46407:                       if (editSession &&
46407:                           NS_SUCCEEDED(rv = editSession->GetJsAndPluginsDisabled(&jsDisabled))) {
46407:                           if (firstPass) {
46407:                               if (jsDisabled) {
46407:                                   // We have a docshell which has been explicitly set
46407:                                   // to design mode, so we disallow scripts.
46407:                                   return NS_OK;
46407:                               }
46407:                               // The docshell was not explicitly set to design mode,
46407:                               // so it must be so because a parent was explicitly
46407:                               // set to design mode.  We don't need to look at higher
46407:                               // docshells.
46407:                               *aResult = PR_TRUE;
46407:                               break;
46407:                           } else if (lookForParents && jsDisabled) {
46407:                               // If a parent was explicitly set to design mode,
46407:                               // we should allow script execution on the child.
46407:                               *aResult = PR_TRUE;
46407:                               break;
46407:                           }
46407:                           // If the child docshell allows scripting, and the
46407:                           // parent is inside design mode, we don't need to look
46407:                           // further.
46407:                           *aResult = PR_TRUE;
46407:                           return NS_OK;
46407:                       }
46407:                       NS_WARNING("The editing session does not work?");
46407:                       return NS_FAILED(rv) ? rv : NS_ERROR_FAILURE;
46407:                   }
46407:                   if (firstPass) {
46407:                       // Don't be too hard on docshells on the first pass.
46407:                       // There may be a parent docshell which has been set
46407:                       // to design mode, so look for it.
46407:                       lookForParents = PR_TRUE;
46407:                   } else {
46407:                       // We have a docshell which disallows scripts
46407:                       // and is not editable, so we shouldn't allow
46407:                       // scripts at all.
46407:                       return NS_OK;
46407:                   }
46407:               }
46407:           } else if (lookForParents) {
46407:               // The parent docshell was not explicitly set to design
46407:               // mode, so js on the child docshell was disabled for
46407:               // another reason.  Therefore, we need to disable js.
48119:               *aResult = PR_FALSE;
46407:               return NS_OK;
46407:           }
46407:           firstPass = PR_FALSE;
46407: 
46407:           treeItem->GetParent(getter_AddRefs(parentItem));
46407:           treeItem.swap(parentItem);
46407:           docshell = do_QueryInterface(treeItem);
46407: #ifdef DEBUG
46407:           if (treeItem && !docshell) {
46407:             NS_ERROR("cannot get a docshell from a treeItem!");
46407:           }
46407: #endif // DEBUG
46407:       } while (treeItem && docshell);
46407:   }
46407: 
46407:   return NS_OK;
46407: }
