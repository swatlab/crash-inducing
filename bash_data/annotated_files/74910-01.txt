 4133: /* -*- Mode: c; tab-width: 8; c-basic-offset: 4; indent-tabs-mode: t; -*- */
    1: /* cairo - a vector graphics library with display and print output
    1:  *
    1:  * Copyright © 2002 University of Southern California
    1:  * Copyright © 2005 Red Hat, Inc.
    1:  *
    1:  * This library is free software; you can redistribute it and/or
    1:  * modify it either under the terms of the GNU Lesser General Public
    1:  * License version 2.1 as published by the Free Software Foundation
    1:  * (the "LGPL") or, at your option, under the terms of the Mozilla
    1:  * Public License Version 1.1 (the "MPL"). If you do not alter this
    1:  * notice, a recipient may use your version of this file under either
    1:  * the MPL or the LGPL.
    1:  *
    1:  * You should have received a copy of the LGPL along with this library
    1:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
70960:  * Foundation, Inc., 51 Franklin Street, Suite 500, Boston, MA 02110-1335, USA
    1:  * You should have received a copy of the MPL along with this library
    1:  * in the file COPYING-MPL-1.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License
    1:  * Version 1.1 (the "License"); you may not use this file except in
    1:  * compliance with the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
    1:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
    1:  * the specific language governing rights and limitations.
    1:  *
    1:  * The Original Code is the cairo graphics library.
    1:  *
    1:  * The Initial Developer of the Original Code is University of Southern
    1:  * California.
    1:  *
    1:  * Contributor(s):
    1:  *	Carl D. Worth <cworth@cworth.org>
    1:  */
    1: 
 4133: #include "cairoint.h"
 3847: 
    1: #include "cairo-surface-fallback-private.h"
    1: #include "cairo-clip-private.h"
70960: #include "cairo-device-private.h"
70960: #include "cairo-error-private.h"
41340: #include "cairo-recording-surface-private.h"
41340: #include "cairo-region-private.h"
41340: #include "cairo-tee-surface-private.h"
    1: 
70960: /**
70960:  * SECTION:cairo-surface
70960:  * @Title: cairo_surface_t
70960:  * @Short_Description: Base class for surfaces
70960:  * @See_Also: #cairo_t, #cairo_pattern_t
70960:  *
70960:  * #cairo_surface_t is the abstract type representing all different drawing
70960:  * targets that cairo can render to.  The actual drawings are
70960:  * performed using a cairo <firstterm>context</firstterm>.
70960:  *
70960:  * A cairo surface is created by using <firstterm>backend</firstterm>-specific
70960:  * constructors, typically of the form
70960:  * cairo_<emphasis>backend</emphasis>_surface_create().
70960:  *
70960:  * Most surface types allow accessing the surface without using Cairo
70960:  * functions. If you do this, keep in mind that it is mandatory that you call
70960:  * cairo_surface_flush() before reading from or writing to the surface and that
70960:  * you must use cairo_surface_mark_dirty() after modifying it.
70960:  * <example>
70960:  * <title>Directly modifying an image surface</title>
70960:  * <programlisting>
70960:  * void
70960:  * modify_image_surface (cairo_surface_t *surface)
70960:  * {
70960:  *   unsigned char *data;
70960:  *   int width, height, stride;
70960:  *
70960:  *   // flush to ensure all writing to the image was done
70960:  *   cairo_surface_flush (surface);
70960:  *
70960:  *   // modify the image
70960:  *   data = cairo_image_surface_get_data (surface);
70960:  *   width = cairo_image_surface_get_width (surface);
70960:  *   height = cairo_image_surface_get_height (surface);
70960:  *   stride = cairo_image_surface_get_stride (surface);
70960:  *   modify_image_data (data, width, height, stride);
70960:  *
70960:  *   // mark the image dirty so Cairo clears its caches.
70960:  *   cairo_surface_mark_dirty (surface);
70960:  * }
70960:  * </programlisting>
70960:  * </example>
70960:  * Note that for other surface types it might be necessary to acquire the
70960:  * surface's device first. See cairo_device_acquire() for a discussion of
70960:  * devices.
70960:  */
70960: 
  314: #define DEFINE_NIL_SURFACE(status, name)			\
  314: const cairo_surface_t name = {					\
26419:     NULL,				/* backend */		\
70960:     NULL,				/* device */		\
26419:     CAIRO_SURFACE_TYPE_IMAGE,		/* type */		\
26419:     CAIRO_CONTENT_COLOR,		/* content */		\
 8452:     CAIRO_REFERENCE_COUNT_INVALID,	/* ref_count */		\
  314:     status,				/* status */		\
41340:     0,					/* unique id */		\
40590:     FALSE,				/* finished */		\
41340:     TRUE,				/* is_clear */		\
41340:     FALSE,				/* has_font_options */	\
70960:     FALSE,				/* owns_device */	\
59761:     FALSE,				/* permit_subpixel_antialiasing */ \
26419:     { 0, 0, 0, NULL, },			/* user_data */		\
26419:     { 0, 0, 0, NULL, },			/* mime_data */         \
26419:     { 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 },   /* device_transform */	\
26419:     { 1.0, 0.0,	0.0, 1.0, 0.0, 0.0 },	/* device_transform_inverse */	\
70960:     { NULL, NULL },			/* device_transform_observers */ \
 6154:     0.0,				/* x_resolution */	\
 6154:     0.0,				/* y_resolution */	\
  314:     0.0,				/* x_fallback_resolution */	\
  314:     0.0,				/* y_fallback_resolution */	\
32473:     NULL,				/* snapshot_of */	\
32473:     NULL,				/* snapshot_detach */	\
70960:     { NULL, NULL },			/* snapshots */		\
70960:     { NULL, NULL },			/* snapshot */		\
18904:     { CAIRO_ANTIALIAS_DEFAULT,		/* antialias */		\
18904:       CAIRO_SUBPIXEL_ORDER_DEFAULT,	/* subpixel_order */	\
70960:       CAIRO_LCD_FILTER_DEFAULT,		/* lcd_filter */	\
18904:       CAIRO_HINT_STYLE_DEFAULT,		/* hint_style */	\
70960:       CAIRO_HINT_METRICS_DEFAULT,	/* hint_metrics */	\
70960:       CAIRO_ROUND_GLYPH_POS_DEFAULT	/* round_glyph_positions */	\
  314:     }					/* font_options */	\
  314: }
    1: 
41340: /* XXX error object! */
41340: 
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_NO_MEMORY, _cairo_surface_nil);
32473: static DEFINE_NIL_SURFACE(CAIRO_STATUS_SURFACE_TYPE_MISMATCH, _cairo_surface_nil_surface_type_mismatch);
41340: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_STATUS, _cairo_surface_nil_invalid_status);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_CONTENT, _cairo_surface_nil_invalid_content);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_FORMAT, _cairo_surface_nil_invalid_format);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_VISUAL, _cairo_surface_nil_invalid_visual);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_FILE_NOT_FOUND, _cairo_surface_nil_file_not_found);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_TEMP_FILE_ERROR, _cairo_surface_nil_temp_file_error);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_READ_ERROR, _cairo_surface_nil_read_error);
10694: static DEFINE_NIL_SURFACE(CAIRO_STATUS_WRITE_ERROR, _cairo_surface_nil_write_error);
11708: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_STRIDE, _cairo_surface_nil_invalid_stride);
29608: static DEFINE_NIL_SURFACE(CAIRO_STATUS_INVALID_SIZE, _cairo_surface_nil_invalid_size);
70960: static DEFINE_NIL_SURFACE(CAIRO_STATUS_DEVICE_TYPE_MISMATCH, _cairo_surface_nil_device_type_mismatch);
70960: static DEFINE_NIL_SURFACE(CAIRO_STATUS_DEVICE_ERROR, _cairo_surface_nil_device_error);
    1: 
    1: /**
    1:  * _cairo_surface_set_error:
    1:  * @surface: a surface
16122:  * @status: a status value indicating an error
    1:  *
 8452:  * Atomically sets surface->status to @status and calls _cairo_error;
16122:  * Does nothing if status is %CAIRO_STATUS_SUCCESS or any of the internal
16122:  * status values.
    1:  *
    1:  * All assignments of an error status to surface->status should happen
 8452:  * through _cairo_surface_set_error(). Note that due to the nature of
 8452:  * the atomic operation, it is not safe to call this function on the
 8452:  * nil objects.
    1:  *
    1:  * The purpose of this function is to allow the user to set a
    1:  * breakpoint in _cairo_error() to generate a stack trace for when the
    1:  * user causes cairo to detect an error.
 8452:  *
 8452:  * Return value: the error status.
    1:  **/
 8452: cairo_status_t
    1: _cairo_surface_set_error (cairo_surface_t *surface,
    1: 			  cairo_status_t status)
    1: {
70960:     if (status == CAIRO_INT_STATUS_NOTHING_TO_DO)
70960: 	status = CAIRO_STATUS_SUCCESS;
70960: 
 8452:     if (status == CAIRO_STATUS_SUCCESS || status >= CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	return status;
 8452: 
    1:     /* Don't overwrite an existing error. This preserves the first
 8452:      * error, which is the most significant. */
 8452:     _cairo_status_set_error (&surface->status, status);
    1: 
 8452:     return _cairo_error (status);
    1: }
    1: 
    1: /**
    1:  * cairo_surface_get_type:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * This function returns the type of the backend used to create
    1:  * a surface. See #cairo_surface_type_t for available types.
    1:  *
    1:  * Return value: The type of @surface.
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: cairo_surface_type_t
    1: cairo_surface_get_type (cairo_surface_t *surface)
    1: {
    1:     /* We don't use surface->backend->type here so that some of the
    1:      * special "wrapper" surfaces such as cairo_paginated_surface_t
    1:      * can override surface->type with the type of the "child"
    1:      * surface. */
    1:     return surface->type;
    1: }
    1: slim_hidden_def (cairo_surface_get_type);
    1: 
    1: /**
    1:  * cairo_surface_get_content:
    1:  * @surface: a #cairo_surface_t
    1:  *
  314:  * This function returns the content type of @surface which indicates
  314:  * whether the surface contains color and/or alpha information. See
    1:  * #cairo_content_t.
    1:  *
  314:  * Return value: The content type of @surface.
  314:  *
    1:  * Since: 1.2
    1:  **/
    1: cairo_content_t
    1: cairo_surface_get_content (cairo_surface_t *surface)
    1: {
    1:     return surface->content;
    1: }
    1: slim_hidden_def(cairo_surface_get_content);
    1: 
    1: /**
    1:  * cairo_surface_status:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Checks whether an error has previously occurred for this
    1:  * surface.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS, %CAIRO_STATUS_NULL_POINTER,
    1:  * %CAIRO_STATUS_NO_MEMORY, %CAIRO_STATUS_READ_ERROR,
 8452:  * %CAIRO_STATUS_INVALID_CONTENT, %CAIRO_STATUS_INVALID_FORMAT, or
    1:  * %CAIRO_STATUS_INVALID_VISUAL.
    1:  **/
    1: cairo_status_t
    1: cairo_surface_status (cairo_surface_t *surface)
    1: {
    1:     return surface->status;
    1: }
    1: slim_hidden_def (cairo_surface_status);
    1: 
32473: static unsigned int
32473: _cairo_surface_allocate_unique_id (void)
32473: {
41340:     static cairo_atomic_int_t unique_id;
32473: 
32473: #if CAIRO_NO_MUTEX
32473:     if (++unique_id == 0)
32473: 	unique_id = 1;
32473:     return unique_id;
32473: #else
41340:     cairo_atomic_int_t old, id;
32473: 
32473:     do {
32473: 	old = _cairo_atomic_uint_get (&unique_id);
32473: 	id = old + 1;
32473: 	if (id == 0)
32473: 	    id = 1;
32473:     } while (! _cairo_atomic_uint_cmpxchg (&unique_id, old, id));
32473: 
32473:     return id;
32473: #endif
32473: }
32473: 
70960: /**
70960:  * cairo_surface_get_device:
70960:  * @surface: a #cairo_surface_t
70960:  *
70960:  * This function returns the device for a @surface.
70960:  * See #cairo_device_t.
70960:  *
70960:  * Return value: The device for @surface or %NULL if the surface does
70960:  *               not have an associated device.
70960:  *
70960:  * Since: 1.10
70960:  **/
70960: cairo_device_t *
70960: cairo_surface_get_device (cairo_surface_t *surface)
70960: {
70960:     if (unlikely (surface->status))
70960: 	return _cairo_device_create_in_error (surface->status);
70960: 
70960:     return surface->device;
70960: }
70960: 
32473: static cairo_bool_t
32473: _cairo_surface_has_snapshots (cairo_surface_t *surface)
32473: {
70960:     return ! cairo_list_is_empty (&surface->snapshots);
70960: }
70960: 
70960: static cairo_bool_t
70960: _cairo_surface_has_mime_data (cairo_surface_t *surface)
70960: {
70960:     return surface->mime_data.num_elements != 0;
70960: }
70960: 
70960: static void
70960: _cairo_surface_detach_mime_data (cairo_surface_t *surface)
70960: {
70960:     if (! _cairo_surface_has_mime_data (surface))
70960: 	return;
70960: 
70960:     _cairo_user_data_array_fini (&surface->mime_data);
70960:     _cairo_user_data_array_init (&surface->mime_data);
32473: }
32473: 
32473: static void
32473: _cairo_surface_detach_snapshots (cairo_surface_t *surface)
32473: {
70960:     while (_cairo_surface_has_snapshots (surface)) {
70960: 	_cairo_surface_detach_snapshot (cairo_list_first_entry (&surface->snapshots,
70960: 								cairo_surface_t,
70960: 								snapshot));
32473:     }
32473: }
32473: 
70960: void
70960: _cairo_surface_detach_snapshot (cairo_surface_t *snapshot)
70960: {
70960:     assert (snapshot->snapshot_of != NULL);
70960: 
70960:     snapshot->snapshot_of = NULL;
70960:     cairo_list_del (&snapshot->snapshot);
70960: 
70960:     if (snapshot->snapshot_detach != NULL)
70960: 	snapshot->snapshot_detach (snapshot);
70960: 
70960:     cairo_surface_destroy (snapshot);
70960: }
70960: 
70960: void
32473: _cairo_surface_attach_snapshot (cairo_surface_t *surface,
32473: 				 cairo_surface_t *snapshot,
32473: 				 cairo_surface_func_t detach_func)
32473: {
32473:     assert (surface != snapshot);
70960:     assert (snapshot->snapshot_of != surface);
70960: 
70960:     cairo_surface_reference (snapshot);
32473: 
32473:     if (snapshot->snapshot_of != NULL)
32473: 	_cairo_surface_detach_snapshot (snapshot);
32473: 
32473:     snapshot->snapshot_of = surface;
32473:     snapshot->snapshot_detach = detach_func;
32473: 
70960:     cairo_list_add (&snapshot->snapshot, &surface->snapshots);
70960: 
70960:     assert (_cairo_surface_has_snapshot (surface, snapshot->backend) == snapshot);
32473: }
32473: 
32473: cairo_surface_t *
32473: _cairo_surface_has_snapshot (cairo_surface_t *surface,
70960: 			     const cairo_surface_backend_t *backend)
32473: {
70960:     cairo_surface_t *snapshot;
70960: 
70960:     cairo_list_foreach_entry (snapshot, cairo_surface_t,
70960: 			      &surface->snapshots, snapshot)
32473:     {
70960: 	/* XXX is_similar? */
70960: 	if (snapshot->backend == backend)
70960: 	    return snapshot;
32473:     }
32473: 
32473:     return NULL;
32473: }
32473: 
32473: static cairo_bool_t
32473: _cairo_surface_is_writable (cairo_surface_t *surface)
32473: {
32473:     return ! surface->finished &&
32473: 	   surface->snapshot_of == NULL &&
70960: 	   ! _cairo_surface_has_snapshots (surface) &&
70960: 	   ! _cairo_surface_has_mime_data (surface);
32473: }
32473: 
32473: static void
32473: _cairo_surface_begin_modification (cairo_surface_t *surface)
32473: {
32473:     assert (surface->status == CAIRO_STATUS_SUCCESS);
32473:     assert (! surface->finished);
32473:     assert (surface->snapshot_of == NULL);
32473: 
32473:     _cairo_surface_detach_snapshots (surface);
70960:     _cairo_surface_detach_mime_data (surface);
32473: }
32473: 
    1: void
    1: _cairo_surface_init (cairo_surface_t			*surface,
    1: 		     const cairo_surface_backend_t	*backend,
70960: 		     cairo_device_t			*device,
    1: 		     cairo_content_t			 content)
    1: {
 4133:     CAIRO_MUTEX_INITIALIZE ();
 4133: 
 3847:     surface->backend = backend;
70960:     surface->device = cairo_device_reference (device);
    1:     surface->content = content;
    1:     surface->type = backend->type;
    1: 
 8452:     CAIRO_REFERENCE_COUNT_INIT (&surface->ref_count, 1);
    1:     surface->status = CAIRO_STATUS_SUCCESS;
41340:     surface->unique_id = _cairo_surface_allocate_unique_id ();
40590:     surface->finished = FALSE;
41340:     surface->is_clear = FALSE;
70960:     surface->owns_device = (device != NULL);
59761:     surface->has_font_options = FALSE;
59761:     surface->permit_subpixel_antialiasing = TRUE;
    1: 
    1:     _cairo_user_data_array_init (&surface->user_data);
26419:     _cairo_user_data_array_init (&surface->mime_data);
    1: 
    1:     cairo_matrix_init_identity (&surface->device_transform);
    1:     cairo_matrix_init_identity (&surface->device_transform_inverse);
70960:     cairo_list_init (&surface->device_transform_observers);
    1: 
 6154:     surface->x_resolution = CAIRO_SURFACE_RESOLUTION_DEFAULT;
 6154:     surface->y_resolution = CAIRO_SURFACE_RESOLUTION_DEFAULT;
 6154: 
    1:     surface->x_fallback_resolution = CAIRO_SURFACE_FALLBACK_RESOLUTION_DEFAULT;
    1:     surface->y_fallback_resolution = CAIRO_SURFACE_FALLBACK_RESOLUTION_DEFAULT;
    1: 
70960:     cairo_list_init (&surface->snapshots);
32473:     surface->snapshot_of = NULL;
    1: }
    1: 
41340: static void
41340: _cairo_surface_copy_similar_properties (cairo_surface_t *surface,
41340: 					cairo_surface_t *other)
41340: {
41340:     if (other->has_font_options || other->backend != surface->backend) {
41340: 	cairo_font_options_t options;
41340: 
41340: 	cairo_surface_get_font_options (other, &options);
41340: 	_cairo_surface_set_font_options (surface, &options);
41340:     }
41340: 
59761:     surface->permit_subpixel_antialiasing = other->permit_subpixel_antialiasing;
59761: 
41340:     cairo_surface_set_fallback_resolution (surface,
41340: 					   other->x_fallback_resolution,
41340: 					   other->y_fallback_resolution);
41340: }
41340: 
    1: cairo_surface_t *
    1: _cairo_surface_create_similar_scratch (cairo_surface_t *other,
    1: 				       cairo_content_t	content,
    1: 				       int		width,
    1: 				       int		height)
    1: {
41340:     cairo_surface_t *surface;
41340: 
41340:     if (unlikely (other->status))
10694: 	return _cairo_surface_create_in_error (other->status);
    1: 
41340:     if (other->backend->create_similar == NULL)
41340: 	return NULL;
41340: 
41340:     surface = other->backend->create_similar (other,
41340: 					      content, width, height);
41340:     if (surface == NULL || surface->status)
21379: 	return surface;
41340: 
41340:     _cairo_surface_copy_similar_properties (surface, other);
    1: 
    1:     return surface;
    1: }
    1: 
    1: /**
    1:  * cairo_surface_create_similar:
    1:  * @other: an existing surface used to select the backend of the new surface
    1:  * @content: the content for the new surface
    1:  * @width: width of the new surface, (in device-space units)
    1:  * @height: height of the new surface (in device-space units)
    1:  *
    1:  * Create a new surface that is as compatible as possible with an
    1:  * existing surface. For example the new surface will have the same
    1:  * fallback resolution and font options as @other. Generally, the new
    1:  * surface will also use the same backend as @other, unless that is
    1:  * not possible for some reason. The type of the returned surface may
    1:  * be examined with cairo_surface_get_type().
    1:  *
    1:  * Initially the surface contents are all 0 (transparent if contents
    1:  * have transparency, black otherwise.)
    1:  *
    1:  * Return value: a pointer to the newly allocated surface. The caller
11708:  * owns the surface and should call cairo_surface_destroy() when done
    1:  * with it.
    1:  *
    1:  * This function always returns a valid pointer, but it will return a
    1:  * pointer to a "nil" surface if @other is already in an error state
    1:  * or any other error occurs.
    1:  **/
    1: cairo_surface_t *
    1: cairo_surface_create_similar (cairo_surface_t  *other,
    1: 			      cairo_content_t	content,
    1: 			      int		width,
    1: 			      int		height)
    1: {
41340:     if (unlikely (other->status))
10694: 	return _cairo_surface_create_in_error (other->status);
70960:     if (unlikely (other->finished))
70960: 	return _cairo_surface_create_in_error (CAIRO_STATUS_SURFACE_FINISHED);
    1: 
41340:     if (unlikely (! CAIRO_CONTENT_VALID (content)))
10694: 	return _cairo_surface_create_in_error (_cairo_error (CAIRO_STATUS_INVALID_CONTENT));
    1: 
41340:     return _cairo_surface_create_similar_solid (other,
41340: 						content, width, height,
41340: 						CAIRO_COLOR_TRANSPARENT,
41340: 						TRUE);
    1: }
    1: 
    1: cairo_surface_t *
    1: _cairo_surface_create_similar_solid (cairo_surface_t	 *other,
    1: 				     cairo_content_t	  content,
    1: 				     int		  width,
    1: 				     int		  height,
41340: 				     const cairo_color_t *color,
41340: 				     cairo_bool_t allow_fallback)
    1: {
    1:     cairo_status_t status;
    1:     cairo_surface_t *surface;
41340:     cairo_solid_pattern_t pattern;
    1: 
    1:     surface = _cairo_surface_create_similar_scratch (other, content,
    1: 						     width, height);
41340:     if (surface == NULL && allow_fallback)
41340: 	surface = _cairo_image_surface_create_with_content (content,
41340: 							    width, height);
41340:     if (surface == NULL || surface->status)
10694: 	return surface;
    1: 
70960:     _cairo_pattern_init_solid (&pattern, color);
    1:     status = _cairo_surface_paint (surface,
    1: 				   color == CAIRO_COLOR_TRANSPARENT ?
16122: 				   CAIRO_OPERATOR_CLEAR : CAIRO_OPERATOR_SOURCE,
41340: 				   &pattern.base, NULL);
26419:     if (unlikely (status)) {
    1: 	cairo_surface_destroy (surface);
41340: 	surface = _cairo_surface_create_in_error (status);
    1:     }
    1: 
    1:     return surface;
    1: }
    1: 
16122: cairo_surface_t *
16122: _cairo_surface_create_solid_pattern_surface (cairo_surface_t	   *other,
26419: 					     const cairo_solid_pattern_t *solid_pattern)
16122: {
26419:     if (other->backend->create_solid_pattern_surface != NULL) {
16122: 	cairo_surface_t *surface;
16122: 
26419: 	surface = other->backend->create_solid_pattern_surface (other,
26419: 								solid_pattern);
16122: 	if (surface)
16122: 	    return surface;
16122:     }
16122: 
26419:     return _cairo_surface_create_similar_solid (other,
70960: 						_cairo_color_get_content (&solid_pattern->color),
16122: 						1, 1,
41340: 						&solid_pattern->color,
41340: 						FALSE);
16122: }
16122: 
16122: cairo_int_status_t
16122: _cairo_surface_repaint_solid_pattern_surface (cairo_surface_t	    *other,
16122: 					      cairo_surface_t       *solid_surface,
26419: 					      const cairo_solid_pattern_t *solid_pattern)
16122: {
26419:     /* Solid pattern surface for these backends are special and not trivial
26419:      * to repaint.  Skip repainting.
16122:      *
16122:      * This does not work optimally with things like analysis surface that
16122:      * are proxies.  But returning UNSUPPORTED is *safe* as it only
16122:      * disables some caching.
16122:      */
26419:     if (other->backend->create_solid_pattern_surface != NULL &&
26419: 	! other->backend->can_repaint_solid_pattern_surface (solid_surface,
26419: 							     solid_pattern))
26419:     {
16122: 	return CAIRO_INT_STATUS_UNSUPPORTED;
26419:     }
26419: 
26419:     return _cairo_surface_paint (solid_surface,
26419: 				 CAIRO_OPERATOR_SOURCE,
26419: 				 &solid_pattern->base,
26419: 				 NULL);
16122: }
16122: 
    1: /**
    1:  * cairo_surface_reference:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Increases the reference count on @surface by one. This prevents
    1:  * @surface from being destroyed until a matching call to
    1:  * cairo_surface_destroy() is made.
    1:  *
  314:  * The number of references to a #cairo_surface_t can be get using
  314:  * cairo_surface_get_reference_count().
  314:  *
    1:  * Return value: the referenced #cairo_surface_t.
    1:  **/
    1: cairo_surface_t *
    1: cairo_surface_reference (cairo_surface_t *surface)
    1: {
 8452:     if (surface == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
    1: 	return surface;
    1: 
 8452:     assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&surface->ref_count));
    1: 
 8452:     _cairo_reference_count_inc (&surface->ref_count);
    1: 
    1:     return surface;
    1: }
    1: slim_hidden_def (cairo_surface_reference);
    1: 
    1: /**
    1:  * cairo_surface_destroy:
 4133:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Decreases the reference count on @surface by one. If the result is
    1:  * zero, then @surface and all associated resources are freed.  See
    1:  * cairo_surface_reference().
    1:  **/
    1: void
    1: cairo_surface_destroy (cairo_surface_t *surface)
    1: {
 8452:     if (surface == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
    1: 	return;
    1: 
 8452:     assert (CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&surface->ref_count));
    1: 
 8452:     if (! _cairo_reference_count_dec_and_test (&surface->ref_count))
    1: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
32473: 
  314:     if (! surface->finished)
    1: 	cairo_surface_finish (surface);
    1: 
70960:     /* paranoid check that nobody took a reference whilst finishing */
70960:     assert (! CAIRO_REFERENCE_COUNT_HAS_REFERENCE (&surface->ref_count));
70960: 
    1:     _cairo_user_data_array_fini (&surface->user_data);
26419:     _cairo_user_data_array_fini (&surface->mime_data);
70960: 
70960:     if (surface->owns_device)
70960:         cairo_device_destroy (surface->device);
    1: 
    1:     free (surface);
    1: }
    1: slim_hidden_def(cairo_surface_destroy);
    1: 
    1: /**
  314:  * cairo_surface_get_reference_count:
  314:  * @surface: a #cairo_surface_t
  314:  *
  314:  * Returns the current reference count of @surface.
  314:  *
  314:  * Return value: the current reference count of @surface.  If the
  314:  * object is a nil object, 0 will be returned.
  314:  *
  314:  * Since: 1.4
  314:  **/
  314: unsigned int
  314: cairo_surface_get_reference_count (cairo_surface_t *surface)
  314: {
 8452:     if (surface == NULL ||
 8452: 	    CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
  314: 	return 0;
  314: 
 8452:     return CAIRO_REFERENCE_COUNT_GET_VALUE (&surface->ref_count);
  314: }
  314: 
  314: /**
    1:  * cairo_surface_finish:
    1:  * @surface: the #cairo_surface_t to finish
    1:  *
    1:  * This function finishes the surface and drops all references to
    1:  * external resources.  For example, for the Xlib backend it means
    1:  * that cairo will no longer access the drawable, which can be freed.
    1:  * After calling cairo_surface_finish() the only valid operations on a
16122:  * surface are getting and setting user, referencing and
16122:  * destroying, and flushing and finishing it.
16122:  * Further drawing to the surface will not affect the
16122:  * surface but will instead trigger a %CAIRO_STATUS_SURFACE_FINISHED
    1:  * error.
    1:  *
    1:  * When the last call to cairo_surface_destroy() decreases the
    1:  * reference count to zero, cairo will call cairo_surface_finish() if
    1:  * it hasn't been called already, before freeing the resources
    1:  * associated with the surface.
    1:  **/
    1: void
    1: cairo_surface_finish (cairo_surface_t *surface)
    1: {
    1:     cairo_status_t status;
    1: 
  314:     if (surface == NULL)
  314: 	return;
  314: 
 8452:     if (CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
  314: 	return;
  314: 
16122:     if (surface->finished)
    1: 	return;
    1: 
70960:     /* update the snapshots *before* we declare the surface as finished */
70960:     _cairo_surface_detach_snapshots (surface);
70960:     if (surface->snapshot_of != NULL)
70960: 	_cairo_surface_detach_snapshot (surface);
70960: 
16122:     cairo_surface_flush (surface);
70960:     surface->finished = TRUE;
    1: 
16122:     /* call finish even if in error mode */
16122:     if (surface->backend->finish) {
    1: 	status = surface->backend->finish (surface);
26419: 	if (unlikely (status))
 8452: 	    status = _cairo_surface_set_error (surface, status);
16122:     }
    1: }
    1: slim_hidden_def (cairo_surface_finish);
    1: 
    1: /**
70960:  * _cairo_surface_release_device_reference:
70960:  * @surface: a #cairo_surface_t
70960:  *
70960:  * This function makes @surface release the reference to its device. The
70960:  * function is intended to be used for avoiding cycling references for
70960:  * surfaces that are owned by their device, for example cache surfaces.
70960:  * Note that the @surface will still assume that the device is available.
70960:  * So it is the caller's responsibility to ensure the device stays around
70960:  * until the @surface is destroyed. Just calling cairo_surface_finish() is
70960:  * not enough.
70960:  **/
70960: void
70960: _cairo_surface_release_device_reference (cairo_surface_t *surface)
70960: {
70960:     assert (surface->owns_device);
70960: 
70960:     cairo_device_destroy (surface->device);
70960:     surface->owns_device = FALSE;
70960: }
70960: 
70960: /**
    1:  * cairo_surface_get_user_data:
    1:  * @surface: a #cairo_surface_t
    1:  * @key: the address of the #cairo_user_data_key_t the user data was
    1:  * attached to
    1:  *
    1:  * Return user data previously attached to @surface using the specified
    1:  * key.  If no user data has been attached with the given key this
    1:  * function returns %NULL.
    1:  *
    1:  * Return value: the user data previously attached or %NULL.
    1:  **/
    1: void *
    1: cairo_surface_get_user_data (cairo_surface_t		 *surface,
    1: 			     const cairo_user_data_key_t *key)
    1: {
    1:     return _cairo_user_data_array_get_data (&surface->user_data,
    1: 					    key);
    1: }
    1: 
    1: /**
    1:  * cairo_surface_set_user_data:
    1:  * @surface: a #cairo_surface_t
    1:  * @key: the address of a #cairo_user_data_key_t to attach the user data to
    1:  * @user_data: the user data to attach to the surface
    1:  * @destroy: a #cairo_destroy_func_t which will be called when the
    1:  * surface is destroyed or when new user data is attached using the
    1:  * same key.
    1:  *
    1:  * Attach user data to @surface.  To remove user data from a surface,
    1:  * call this function with the key that was used to set it and %NULL
    1:  * for @data.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
    1:  * slot could not be allocated for the user data.
    1:  **/
    1: cairo_status_t
    1: cairo_surface_set_user_data (cairo_surface_t		 *surface,
    1: 			     const cairo_user_data_key_t *key,
    1: 			     void			 *user_data,
    1: 			     cairo_destroy_func_t	 destroy)
    1: {
 8452:     if (CAIRO_REFERENCE_COUNT_IS_INVALID (&surface->ref_count))
21379: 	return surface->status;
    1: 
    1:     return _cairo_user_data_array_set_data (&surface->user_data,
    1: 					    key, user_data, destroy);
    1: }
    1: 
    1: /**
26419:  * cairo_surface_get_mime_data:
26419:  * @surface: a #cairo_surface_t
26419:  * @mime_type: the mime type of the image data
26419:  * @data: the image data to attached to the surface
26419:  * @length: the length of the image data
26419:  *
26419:  * Return mime data previously attached to @surface using the
26419:  * specified mime type.  If no data has been attached with the given
26419:  * mime type, @data is set %NULL.
26419:  *
26419:  * Since: 1.10
26419:  **/
26419: void
26419: cairo_surface_get_mime_data (cairo_surface_t		*surface,
26419:                              const char			*mime_type,
26419:                              const unsigned char       **data,
70960:                              unsigned long		*length)
26419: {
32473:     cairo_user_data_slot_t *slots;
32473:     int i, num_slots;
26419: 
26419:     *data = NULL;
26419:     *length = 0;
32473:     if (unlikely (surface->status))
26419: 	return;
26419: 
32473:     /* The number of mime-types attached to a surface is usually small,
32473:      * typically zero. Therefore it is quicker to do a strcmp() against
32473:      * each key than it is to intern the string (i.e. compute a hash,
32473:      * search the hash table, and do a final strcmp).
32473:      */
32473:     num_slots = surface->mime_data.num_elements;
32473:     slots = _cairo_array_index (&surface->mime_data, 0);
32473:     for (i = 0; i < num_slots; i++) {
32473: 	if (strcmp ((char *) slots[i].key, mime_type) == 0) {
32473: 	    cairo_mime_data_t *mime_data = slots[i].user_data;
32473: 
32473: 	    *data = mime_data->data;
32473: 	    *length = mime_data->length;
32346: 	    return;
32346: 	}
32473:     }
26419: }
26419: slim_hidden_def (cairo_surface_get_mime_data);
26419: 
26419: static void
26419: _cairo_mime_data_destroy (void *ptr)
26419: {
26419:     cairo_mime_data_t *mime_data = ptr;
26419: 
26419:     if (! _cairo_reference_count_dec_and_test (&mime_data->ref_count))
26419: 	return;
26419: 
26419:     if (mime_data->destroy && mime_data->closure)
26419: 	mime_data->destroy (mime_data->closure);
26419: 
26419:     free (mime_data);
26419: }
26419: 
26419: /**
70960:  * CAIRO_MIME_TYPE_JP2:
70960:  *
70960:  * The Joint Photographic Experts Group (JPEG) 2000 image coding standard (ISO/IEC 15444-1).
70960:  *
70960:  * @Since: 1.10
70960:  */
70960: 
70960: /**
70960:  * CAIRO_MIME_TYPE_JPEG:
70960:  *
70960:  * The Joint Photographic Experts Group (JPEG) image coding standard (ISO/IEC 10918-1).
70960:  *
70960:  * @Since: 1.10
70960:  */
70960: 
70960: /**
70960:  * CAIRO_MIME_TYPE_PNG:
70960:  *
70960:  * The Portable Network Graphics image file format (ISO/IEC 15948).
70960:  *
70960:  * @Since: 1.10
70960:  */
70960: 
70960: /**
70960:  * CAIRO_MIME_TYPE_URI:
70960:  *
70960:  * URI for an image file (unofficial MIME type).
70960:  *
70960:  * @Since: 1.10
70960:  */
70960: 
70960: /**
26419:  * cairo_surface_set_mime_data:
26419:  * @surface: a #cairo_surface_t
70960:  * @mime_type: the MIME type of the image data
26419:  * @data: the image data to attach to the surface
26419:  * @length: the length of the image data
26419:  * @destroy: a #cairo_destroy_func_t which will be called when the
26419:  * surface is destroyed or when new image data is attached using the
26419:  * same mime type.
26419:  * @closure: the data to be passed to the @destroy notifier
26419:  *
26419:  * Attach an image in the format @mime_type to @surface. To remove
26419:  * the data from a surface, call this function with same mime type
26419:  * and %NULL for @data.
26419:  *
70960:  * The attached image (or filename) data can later be used by backends
70960:  * which support it (currently: PDF, PS, SVG and Win32 Printing
70960:  * surfaces) to emit this data instead of making a snapshot of the
70960:  * @surface.  This approach tends to be faster and requires less
70960:  * memory and disk space.
70960:  *
70960:  * The recognized MIME types are the following: %CAIRO_MIME_TYPE_JPEG,
70960:  * %CAIRO_MIME_TYPE_PNG, %CAIRO_MIME_TYPE_JP2, %CAIRO_MIME_TYPE_URI.
70960:  *
70960:  * See corresponding backend surface docs for details about which MIME
70960:  * types it can handle. Caution: the associated MIME data will be
70960:  * discarded if you draw on the surface afterwards. Use this function
70960:  * with care.
70960:  *
26419:  * Since: 1.10
26419:  *
26419:  * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY if a
26419:  * slot could not be allocated for the user data.
26419:  **/
26419: cairo_status_t
26419: cairo_surface_set_mime_data (cairo_surface_t		*surface,
26419:                              const char			*mime_type,
26419:                              const unsigned char	*data,
70960:                              unsigned long		 length,
26419: 			     cairo_destroy_func_t	 destroy,
26419: 			     void			*closure)
26419: {
26419:     cairo_status_t status;
26419:     cairo_mime_data_t *mime_data;
26419: 
26419:     if (unlikely (surface->status))
26419: 	return surface->status;
70960:     if (surface->finished)
70960: 	return _cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));
26419: 
26419:     status = _cairo_intern_string (&mime_type, -1);
26419:     if (unlikely (status))
26419: 	return _cairo_surface_set_error (surface, status);
26419: 
26419:     if (data != NULL) {
26419: 	mime_data = malloc (sizeof (cairo_mime_data_t));
26419: 	if (unlikely (mime_data == NULL))
26419: 	    return _cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_NO_MEMORY));
26419: 
26419: 	CAIRO_REFERENCE_COUNT_INIT (&mime_data->ref_count, 1);
26419: 
26419: 	mime_data->data = (unsigned char *) data;
26419: 	mime_data->length = length;
26419: 	mime_data->destroy = destroy;
26419: 	mime_data->closure = closure;
26419:     } else
26419: 	mime_data = NULL;
26419: 
26419:     status = _cairo_user_data_array_set_data (&surface->mime_data,
26419: 					      (cairo_user_data_key_t *) mime_type,
26419: 					      mime_data,
26419: 					      _cairo_mime_data_destroy);
26419:     if (unlikely (status)) {
26419: 	if (mime_data != NULL)
26419: 	    free (mime_data);
26419: 
26419: 	return _cairo_surface_set_error (surface, status);
26419:     }
26419: 
26419:     return CAIRO_STATUS_SUCCESS;
26419: }
26419: slim_hidden_def (cairo_surface_set_mime_data);
26419: 
26419: static void
26419: _cairo_mime_data_reference (const void *key, void *elt, void *closure)
26419: {
26419:     cairo_mime_data_t *mime_data = elt;
26419: 
26419:     _cairo_reference_count_inc (&mime_data->ref_count);
26419: }
26419: 
26419: cairo_status_t
26419: _cairo_surface_copy_mime_data (cairo_surface_t *dst,
26419: 			       cairo_surface_t *src)
26419: {
26419:     cairo_status_t status;
26419: 
26419:     if (dst->status)
26419: 	return dst->status;
26419: 
26419:     if (src->status)
26419: 	return _cairo_surface_set_error (dst, src->status);
26419: 
26419:     /* first copy the mime-data, discarding any already set on dst */
26419:     status = _cairo_user_data_array_copy (&dst->mime_data, &src->mime_data);
26419:     if (unlikely (status))
26419: 	return _cairo_surface_set_error (dst, status);
26419: 
26419:     /* now increment the reference counters for the copies */
26419:     _cairo_user_data_array_foreach (&dst->mime_data,
26419: 				    _cairo_mime_data_reference,
26419: 				    NULL);
26419: 
26419:     return CAIRO_STATUS_SUCCESS;
26419: }
26419: 
26419: /**
    1:  * _cairo_surface_set_font_options:
    1:  * @surface: a #cairo_surface_t
    1:  * @options: a #cairo_font_options_t object that contains the
    1:  *   options to use for this surface instead of backend's default
    1:  *   font options.
    1:  *
    1:  * Sets the default font rendering options for the surface.
    1:  * This is useful to correctly propagate default font options when
    1:  * falling back to an image surface in a backend implementation.
    1:  * This affects the options returned in cairo_surface_get_font_options().
    1:  *
    1:  * If @options is %NULL the surface options are reset to those of
    1:  * the backend default.
    1:  **/
    1: void
    1: _cairo_surface_set_font_options (cairo_surface_t       *surface,
    1: 				 cairo_font_options_t  *options)
    1: {
 8452:     cairo_status_t status;
 8452: 
 8452:     if (surface->status)
 8452: 	return;
 8452: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
 8452:     if (surface->finished) {
 8452: 	status = _cairo_surface_set_error (surface,
70960: 		                           _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));
 8452: 	return;
 8452:     }
 8452: 
    1:     if (options) {
    1: 	surface->has_font_options = TRUE;
    1: 	_cairo_font_options_init_copy (&surface->font_options, options);
    1:     } else {
    1: 	surface->has_font_options = FALSE;
    1:     }
    1: }
    1: 
    1: /**
    1:  * cairo_surface_get_font_options:
    1:  * @surface: a #cairo_surface_t
    1:  * @options: a #cairo_font_options_t object into which to store
    1:  *   the retrieved options. All existing values are overwritten
    1:  *
    1:  * Retrieves the default font rendering options for the surface.
    1:  * This allows display surfaces to report the correct subpixel order
    1:  * for rendering on them, print surfaces to disable hinting of
    1:  * metrics and so forth. The result can then be used with
    1:  * cairo_scaled_font_create().
    1:  **/
    1: void
    1: cairo_surface_get_font_options (cairo_surface_t       *surface,
    1: 				cairo_font_options_t  *options)
    1: {
 4133:     if (cairo_font_options_status (options))
 4133: 	return;
 4133: 
18904:     if (surface->status) {
18904: 	_cairo_font_options_init_default (options);
18904: 	return;
18904:     }
18904: 
    1:     if (! surface->has_font_options) {
    1: 	surface->has_font_options = TRUE;
    1: 
 4133: 	_cairo_font_options_init_default (&surface->font_options);
 4133: 
    1: 	if (!surface->finished && surface->backend->get_font_options) {
    1: 	    surface->backend->get_font_options (surface, &surface->font_options);
    1: 	}
    1:     }
    1: 
    1:     _cairo_font_options_init_copy (options, &surface->font_options);
    1: }
    1: slim_hidden_def (cairo_surface_get_font_options);
    1: 
    1: /**
    1:  * cairo_surface_flush:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Do any pending drawing for the surface and also restore any
70960:  * temporary modifications cairo has made to the surface's
    1:  * state. This function must be called before switching from
    1:  * drawing on the surface with cairo to drawing on it directly
    1:  * with native APIs. If the surface doesn't support direct access,
    1:  * then this function does nothing.
    1:  **/
    1: void
    1: cairo_surface_flush (cairo_surface_t *surface)
    1: {
 8452:     cairo_status_t status;
 8452: 
    1:     if (surface->status)
    1: 	return;
    1: 
16122:     if (surface->finished)
    1: 	return;
    1: 
32473:     /* update the current snapshots *before* the user updates the surface */
32473:     _cairo_surface_detach_snapshots (surface);
32473: 
    1:     if (surface->backend->flush) {
    1: 	status = surface->backend->flush (surface);
26419: 	if (unlikely (status))
 8452: 	    status = _cairo_surface_set_error (surface, status);
    1:     }
    1: }
16122: slim_hidden_def (cairo_surface_flush);
    1: 
    1: /**
    1:  * cairo_surface_mark_dirty:
    1:  * @surface: a #cairo_surface_t
    1:  *
    1:  * Tells cairo that drawing has been done to surface using means other
    1:  * than cairo, and that cairo should reread any cached areas. Note
    1:  * that you must call cairo_surface_flush() before doing such drawing.
    1:  */
    1: void
    1: cairo_surface_mark_dirty (cairo_surface_t *surface)
    1: {
    1:     cairo_surface_mark_dirty_rectangle (surface, 0, 0, -1, -1);
    1: }
70960: slim_hidden_def (cairo_surface_mark_dirty);
    1: 
    1: /**
    1:  * cairo_surface_mark_dirty_rectangle:
    1:  * @surface: a #cairo_surface_t
    1:  * @x: X coordinate of dirty rectangle
    1:  * @y: Y coordinate of dirty rectangle
    1:  * @width: width of dirty rectangle
    1:  * @height: height of dirty rectangle
    1:  *
    1:  * Like cairo_surface_mark_dirty(), but drawing has been done only to
    1:  * the specified rectangle, so that cairo can retain cached contents
    1:  * for other parts of the surface.
    1:  *
    1:  * Any cached clip set on the surface will be reset by this function,
    1:  * to make sure that future cairo calls have the clip set that they
    1:  * expect.
    1:  */
    1: void
    1: cairo_surface_mark_dirty_rectangle (cairo_surface_t *surface,
    1: 				    int              x,
    1: 				    int              y,
    1: 				    int              width,
    1: 				    int              height)
    1: {
 8452:     cairo_status_t status;
 8452: 
    1:     if (surface->status)
    1: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
    1:     if (surface->finished) {
70960: 	status = _cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));
    1: 	return;
    1:     }
    1: 
32473:     /* The application *should* have called cairo_surface_flush() before
32473:      * modifying the surface independently of cairo (and thus having to
32473:      * call mark_dirty()). */
32473:     assert (! _cairo_surface_has_snapshots (surface));
70960:     assert (! _cairo_surface_has_mime_data (surface));
32473: 
41340:     surface->is_clear = FALSE;
41340: 
41340:     if (surface->backend->mark_dirty_rectangle != NULL) {
    1: 	/* XXX: FRAGILE: We're ignoring the scaling component of
    1: 	 * device_transform here. I don't know what the right thing to
    1: 	 * do would actually be if there were some scaling here, but
    1: 	 * we avoid this since device_transfom scaling is not exported
    1: 	 * publicly and mark_dirty is not used internally. */
    1: 	status = surface->backend->mark_dirty_rectangle (surface,
    1:                                                          x + surface->device_transform.x0,
    1:                                                          y + surface->device_transform.y0,
    1: 							 width, height);
    1: 
26419: 	if (unlikely (status))
 8452: 	    status = _cairo_surface_set_error (surface, status);
    1:     }
    1: }
    1: slim_hidden_def (cairo_surface_mark_dirty_rectangle);
    1: 
    1: /**
    1:  * _cairo_surface_set_device_scale:
    1:  * @surface: a #cairo_surface_t
    1:  * @sx: a scale factor in the X direction
    1:  * @sy: a scale factor in the Y direction
    1:  *
    1:  * Private function for setting an extra scale factor to affect all
    1:  * drawing to a surface. This is used, for example, when replaying a
41340:  * recording surface to an image fallback intended for an eventual
41340:  * vector-oriented backend. Since the recording surface will record
    1:  * coordinates in one backend space, but the image fallback uses a
    1:  * different backend space, (differing by the fallback resolution
    1:  * scale factors), we need a scale factor correction.
    1:  *
16122:  * Caution: Not all places we use device transform correctly handle
16122:  * both a translate and a scale.  An audit would be nice.
    1:  **/
    1: void
    1: _cairo_surface_set_device_scale (cairo_surface_t *surface,
    1: 				 double		  sx,
    1: 				 double		  sy)
    1: {
 8452:     cairo_status_t status;
 8452: 
    1:     if (surface->status)
    1: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
    1:     if (surface->finished) {
70960: 	status = _cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));
    1: 	return;
    1:     }
    1: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
    1:     surface->device_transform.xx = sx;
    1:     surface->device_transform.yy = sy;
16122:     surface->device_transform.xy = 0.0;
16122:     surface->device_transform.yx = 0.0;
    1: 
21379:     surface->device_transform_inverse = surface->device_transform;
21379:     status = cairo_matrix_invert (&surface->device_transform_inverse);
21379:     /* should always be invertible unless given pathological input */
21379:     assert (status == CAIRO_STATUS_SUCCESS);
70960: 
70960:     _cairo_observers_notify (&surface->device_transform_observers, surface);
    1: }
    1: 
    1: /**
    1:  * cairo_surface_set_device_offset:
    1:  * @surface: a #cairo_surface_t
    1:  * @x_offset: the offset in the X direction, in device units
    1:  * @y_offset: the offset in the Y direction, in device units
    1:  *
    1:  * Sets an offset that is added to the device coordinates determined
    1:  * by the CTM when drawing to @surface. One use case for this function
    1:  * is when we want to create a #cairo_surface_t that redirects drawing
    1:  * for a portion of an onscreen surface to an offscreen surface in a
    1:  * way that is completely invisible to the user of the cairo
    1:  * API. Setting a transformation via cairo_translate() isn't
    1:  * sufficient to do this, since functions like
    1:  * cairo_device_to_user() will expose the hidden offset.
    1:  *
    1:  * Note that the offset affects drawing to the surface as well as
    1:  * using the surface in a source pattern.
    1:  **/
    1: void
    1: cairo_surface_set_device_offset (cairo_surface_t *surface,
    1: 				 double           x_offset,
    1: 				 double           y_offset)
    1: {
 8452:     cairo_status_t status;
 8452: 
    1:     if (surface->status)
    1: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
    1:     if (surface->finished) {
70960: 	status = _cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));
    1: 	return;
    1:     }
    1: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
    1:     surface->device_transform.x0 = x_offset;
    1:     surface->device_transform.y0 = y_offset;
    1: 
21379:     surface->device_transform_inverse = surface->device_transform;
21379:     status = cairo_matrix_invert (&surface->device_transform_inverse);
21379:     /* should always be invertible unless given pathological input */
21379:     assert (status == CAIRO_STATUS_SUCCESS);
70960: 
70960:     _cairo_observers_notify (&surface->device_transform_observers, surface);
    1: }
    1: slim_hidden_def (cairo_surface_set_device_offset);
    1: 
    1: /**
    1:  * cairo_surface_get_device_offset:
    1:  * @surface: a #cairo_surface_t
    1:  * @x_offset: the offset in the X direction, in device units
    1:  * @y_offset: the offset in the Y direction, in device units
    1:  *
    1:  * This function returns the previous device offset set by
    1:  * cairo_surface_set_device_offset().
    1:  *
    1:  * Since: 1.2
    1:  **/
    1: void
    1: cairo_surface_get_device_offset (cairo_surface_t *surface,
    1: 				 double          *x_offset,
    1: 				 double          *y_offset)
    1: {
  314:     if (x_offset)
    1: 	*x_offset = surface->device_transform.x0;
  314:     if (y_offset)
    1: 	*y_offset = surface->device_transform.y0;
    1: }
    1: slim_hidden_def (cairo_surface_get_device_offset);
    1: 
    1: /**
    1:  * cairo_surface_set_fallback_resolution:
    1:  * @surface: a #cairo_surface_t
    1:  * @x_pixels_per_inch: horizontal setting for pixels per inch
    1:  * @y_pixels_per_inch: vertical setting for pixels per inch
    1:  *
    1:  * Set the horizontal and vertical resolution for image fallbacks.
    1:  *
    1:  * When certain operations aren't supported natively by a backend,
    1:  * cairo will fallback by rendering operations to an image and then
    1:  * overlaying that image onto the output. For backends that are
    1:  * natively vector-oriented, this function can be used to set the
    1:  * resolution used for these image fallbacks, (larger values will
    1:  * result in more detailed images, but also larger file sizes).
    1:  *
    1:  * Some examples of natively vector-oriented backends are the ps, pdf,
    1:  * and svg backends.
    1:  *
    1:  * For backends that are natively raster-oriented, image fallbacks are
    1:  * still possible, but they are always performed at the native
    1:  * device resolution. So this function has no effect on those
    1:  * backends.
    1:  *
11708:  * Note: The fallback resolution only takes effect at the time of
    1:  * completing a page (with cairo_show_page() or cairo_copy_page()) so
    1:  * there is currently no way to have more than one fallback resolution
    1:  * in effect on a single page.
    1:  *
13980:  * The default fallback resoultion is 300 pixels per inch in both
13980:  * dimensions.
13980:  *
    1:  * Since: 1.2
    1:  **/
    1: void
    1: cairo_surface_set_fallback_resolution (cairo_surface_t	*surface,
    1: 				       double		 x_pixels_per_inch,
    1: 				       double		 y_pixels_per_inch)
    1: {
 8452:     cairo_status_t status;
 8452: 
 8452:     if (surface->status)
 8452: 	return;
 8452: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
 8452:     if (surface->finished) {
70960: 	status = _cairo_surface_set_error (surface, _cairo_error (CAIRO_STATUS_SURFACE_FINISHED));
 8452: 	return;
 8452:     }
 8452: 
41340:     if (x_pixels_per_inch <= 0 || y_pixels_per_inch <= 0) {
41340: 	/* XXX Could delay raising the error until we fallback, but throwing
41340: 	 * the error here means that we can catch the real culprit.
41340: 	 */
41340: 	status = _cairo_surface_set_error (surface, CAIRO_STATUS_INVALID_MATRIX);
41340: 	return;
41340:     }
41340: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
    1:     surface->x_fallback_resolution = x_pixels_per_inch;
    1:     surface->y_fallback_resolution = y_pixels_per_inch;
    1: }
    1: slim_hidden_def (cairo_surface_set_fallback_resolution);
    1: 
16122: /**
16122:  * cairo_surface_get_fallback_resolution:
16122:  * @surface: a #cairo_surface_t
16122:  * @x_pixels_per_inch: horizontal pixels per inch
16122:  * @y_pixels_per_inch: vertical pixels per inch
16122:  *
16122:  * This function returns the previous fallback resolution set by
16122:  * cairo_surface_set_fallback_resolution(), or default fallback
16122:  * resolution if never set.
16122:  *
16122:  * Since: 1.8
16122:  **/
16122: void
16122: cairo_surface_get_fallback_resolution (cairo_surface_t	*surface,
16122: 				       double		*x_pixels_per_inch,
16122: 				       double		*y_pixels_per_inch)
16122: {
16122:     if (x_pixels_per_inch)
16122: 	*x_pixels_per_inch = surface->x_fallback_resolution;
16122:     if (y_pixels_per_inch)
16122: 	*y_pixels_per_inch = surface->y_fallback_resolution;
16122: }
16122: 
28304: int
28304: _cairo_surface_get_text_path_fill_threshold (const cairo_surface_t *surface)
28304: {
28304:     return surface->backend->fill == NULL ? 10240 : 256;
28304: }
28304: 
    1: cairo_bool_t
    1: _cairo_surface_has_device_transform (cairo_surface_t *surface)
    1: {
    1:     return ! _cairo_matrix_is_identity (&surface->device_transform);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_acquire_source_image:
    1:  * @surface: a #cairo_surface_t
    1:  * @image_out: location to store a pointer to an image surface that
    1:  *    has identical contents to @surface. This surface could be @surface
    1:  *    itself, a surface held internal to @surface, or it could be a new
    1:  *    surface with a copy of the relevant portion of @surface.
    1:  * @image_extra: location to store image specific backend data
    1:  *
    1:  * Gets an image surface to use when drawing as a fallback when drawing with
    1:  * @surface as a source. _cairo_surface_release_source_image() must be called
    1:  * when finished.
    1:  *
10414:  * Return value: %CAIRO_STATUS_SUCCESS if an image was stored in @image_out.
    1:  * %CAIRO_INT_STATUS_UNSUPPORTED if an image cannot be retrieved for the specified
    1:  * surface. Or %CAIRO_STATUS_NO_MEMORY.
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_acquire_source_image (cairo_surface_t         *surface,
    1: 				     cairo_image_surface_t  **image_out,
    1: 				     void                   **image_extra)
    1: {
29608:     cairo_status_t status;
29608: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
21379:     assert (!surface->finished);
21379: 
10414:     if (surface->backend->acquire_source_image == NULL)
10414: 	return CAIRO_INT_STATUS_UNSUPPORTED;
10414: 
29608:     status = surface->backend->acquire_source_image (surface,
29608: 						     image_out, image_extra);
29608:     if (unlikely (status))
29608: 	return _cairo_surface_set_error (surface, status);
29608: 
74910:     if (PIXMAN_FORMAT_BPP((*image_out)->pixman_format) == 0) {
74910: 	volatile char* acquire_source_image_ptr[10];
74910: 	volatile char* crasher;
74910: 	int i;
74910:         for (i = 0; i < 10; i++) {
74910: 	    acquire_source_image_ptr[i] = (char*)surface->backend->acquire_source_image;
74910: 	}
74910: 	crasher = NULL;
74910: 	*crasher = acquire_source_image_ptr[5];
74910:     }
29608:     _cairo_debug_check_image_surface_is_defined (&(*image_out)->base);
29608: 
29608:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_release_source_image:
    1:  * @surface: a #cairo_surface_t
    1:  * @image_extra: same as return from the matching _cairo_surface_acquire_source_image()
    1:  *
    1:  * Releases any resources obtained with _cairo_surface_acquire_source_image()
    1:  **/
    1: void
    1: _cairo_surface_release_source_image (cairo_surface_t        *surface,
    1: 				     cairo_image_surface_t  *image,
    1: 				     void                   *image_extra)
    1: {
    1:     assert (!surface->finished);
    1: 
    1:     if (surface->backend->release_source_image)
    1: 	surface->backend->release_source_image (surface, image, image_extra);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_acquire_dest_image:
    1:  * @surface: a #cairo_surface_t
    1:  * @interest_rect: area of @surface for which fallback drawing is being done.
    1:  *    A value of %NULL indicates that the entire surface is desired.
11708:  *    XXXX I'd like to get rid of being able to pass %NULL here (nothing seems to)
    1:  * @image_out: location to store a pointer to an image surface that includes at least
    1:  *    the intersection of @interest_rect with the visible area of @surface.
    1:  *    This surface could be @surface itself, a surface held internal to @surface,
    1:  *    or it could be a new surface with a copy of the relevant portion of @surface.
    1:  *    If a new surface is created, it should have the same channels and depth
    1:  *    as @surface so that copying to and from it is exact.
    1:  * @image_rect: location to store area of the original surface occupied
    1:  *    by the surface stored in @image.
    1:  * @image_extra: location to store image specific backend data
    1:  *
    1:  * Retrieves a local image for a surface for implementing a fallback drawing
    1:  * operation. After calling this function, the implementation of the fallback
    1:  * drawing operation draws the primitive to the surface stored in @image_out
    1:  * then calls _cairo_surface_release_dest_image(),
    1:  * which, if a temporary surface was created, copies the bits back to the
    1:  * main surface and frees the temporary surface.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or %CAIRO_STATUS_NO_MEMORY.
    1:  *  %CAIRO_INT_STATUS_UNSUPPORTED can be returned but this will mean that
    1:  *  the backend can't draw with fallbacks. It's possible for the routine
11708:  *  to store %NULL in @local_out and return %CAIRO_STATUS_SUCCESS;
    1:  *  that indicates that no part of @interest_rect is visible, so no drawing
    1:  *  is necessary. _cairo_surface_release_dest_image() should not be called in that
    1:  *  case.
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_acquire_dest_image (cairo_surface_t         *surface,
 4133: 				   cairo_rectangle_int_t   *interest_rect,
    1: 				   cairo_image_surface_t  **image_out,
 4133: 				   cairo_rectangle_int_t   *image_rect,
    1: 				   void                   **image_extra)
    1: {
29608:     cairo_status_t status;
29608: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
32473:     assert (_cairo_surface_is_writable (surface));
21379: 
10414:     if (surface->backend->acquire_dest_image == NULL)
10414: 	return CAIRO_INT_STATUS_UNSUPPORTED;
10414: 
29608:     status = surface->backend->acquire_dest_image (surface,
    1: 						   interest_rect,
 8452: 						   image_out,
 8452: 						   image_rect,
29608: 						   image_extra);
29608:     if (unlikely (status))
29608: 	return _cairo_surface_set_error (surface, status);
29608: 
29608:     _cairo_debug_check_image_surface_is_defined (&(*image_out)->base);
29608: 
29608:     return CAIRO_STATUS_SUCCESS;
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_release_dest_image:
    1:  * @surface: a #cairo_surface_t
    1:  * @interest_rect: same as passed to the matching _cairo_surface_acquire_dest_image()
    1:  * @image: same as returned from the matching _cairo_surface_acquire_dest_image()
    1:  * @image_rect: same as returned from the matching _cairo_surface_acquire_dest_image()
    1:  * @image_extra: same as return from the matching _cairo_surface_acquire_dest_image()
    1:  *
    1:  * Finishes the operation started with _cairo_surface_acquire_dest_image(), by, if
    1:  * necessary, copying the image from @image back to @surface and freeing any
    1:  * resources that were allocated.
    1:  **/
    1: void
    1: _cairo_surface_release_dest_image (cairo_surface_t         *surface,
 4133: 				   cairo_rectangle_int_t   *interest_rect,
    1: 				   cairo_image_surface_t   *image,
 4133: 				   cairo_rectangle_int_t   *image_rect,
    1: 				   void                    *image_extra)
    1: {
32473:     assert (_cairo_surface_is_writable (surface));
    1: 
    1:     if (surface->backend->release_dest_image)
    1: 	surface->backend->release_dest_image (surface, interest_rect,
    1: 					      image, image_rect, image_extra);
    1: }
    1: 
32473: static cairo_status_t
41340: _cairo_recording_surface_clone_similar (cairo_surface_t  *surface,
32473: 					cairo_surface_t  *src,
32473: 					int               src_x,
32473: 					int               src_y,
32473: 					int               width,
32473: 					int               height,
32473: 					int              *clone_offset_x,
32473: 					int              *clone_offset_y,
32473: 					cairo_surface_t **clone_out)
32473: {
41340:     cairo_recording_surface_t *recorder = (cairo_recording_surface_t *) src;
32473:     cairo_surface_t *similar;
32473:     cairo_status_t status;
32473: 
70960:     similar = _cairo_surface_has_snapshot (src, surface->backend);
32473:     if (similar != NULL) {
32473: 	*clone_out = cairo_surface_reference (similar);
32473: 	*clone_offset_x = 0;
32473: 	*clone_offset_y = 0;
32473: 	return CAIRO_STATUS_SUCCESS;
32473:     }
32473: 
41340:     if (recorder->unbounded ||
41340: 	width*height*8 < recorder->extents.width*recorder->extents.height)
41340:     {
70960: 	similar = _cairo_surface_create_similar_solid (surface,
41340: 						       src->content,
70960: 						       width, height,
70960:                                                        CAIRO_COLOR_TRANSPARENT,
70960:                                                        FALSE);
41340: 	if (similar == NULL)
41340: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
41340: 	if (unlikely (similar->status))
41340: 	    return similar->status;
32473: 
32473: 	cairo_surface_set_device_offset (similar, -src_x, -src_y);
32473: 
41340: 	status = _cairo_recording_surface_replay (src, similar);
32473: 	if (unlikely (status)) {
32473: 	    cairo_surface_destroy (similar);
32473: 	    return status;
32473: 	}
32473:     } else {
41340: 	similar = _cairo_surface_create_similar_scratch (surface,
41340: 							 src->content,
41340: 							 recorder->extents.width,
41340: 							 recorder->extents.height);
41340: 	if (similar == NULL)
41340: 	    return CAIRO_INT_STATUS_UNSUPPORTED;
41340: 	if (unlikely (similar->status))
41340: 	    return similar->status;
41340: 
41340: 	status = _cairo_recording_surface_replay (src, similar);
32473: 	if (unlikely (status)) {
32473: 	    cairo_surface_destroy (similar);
32473: 	    return status;
32473: 	}
32473: 
70960: 	_cairo_surface_attach_snapshot (src, similar, NULL);
32473: 
32473: 	src_x = src_y = 0;
32473:     }
32473: 
32473:     *clone_out = similar;
32473:     *clone_offset_x = src_x;
32473:     *clone_offset_y = src_y;
32473:     return CAIRO_STATUS_SUCCESS;
32473: }
32473: 
26419: struct acquire_source_image_data
26419: {
26419:     cairo_surface_t *src;
26419:     cairo_image_surface_t *image;
26419:     void *image_extra;
26419: };
26419: 
26419: static void
26419: _wrap_release_source_image (void *data)
26419: {
26419:     struct acquire_source_image_data *acquire_data = data;
39069:     _cairo_surface_release_source_image (acquire_data->src,
39069: 					 acquire_data->image,
39069: 					 acquire_data->image_extra);
26419:     free(data);
26419: }
26419: 
26419: static cairo_status_t
26419: _wrap_image (cairo_surface_t *src,
26419: 	     cairo_image_surface_t *image,
26419: 	     void *image_extra,
26419: 	     cairo_image_surface_t **out)
26419: {
26419:     static cairo_user_data_key_t wrap_image_key;
28077:     cairo_image_surface_t *surface;
26419:     cairo_status_t status;
26419: 
26419:     struct acquire_source_image_data *data = malloc (sizeof (*data));
39069:     if (unlikely (data == NULL))
39069: 	return _cairo_error (CAIRO_STATUS_NO_MEMORY);
26419:     data->src = src;
26419:     data->image = image;
26419:     data->image_extra = image_extra;
26419: 
39069:     surface = (cairo_image_surface_t*)
39069: 	_cairo_image_surface_create_with_pixman_format (image->data,
39069: 							image->pixman_format,
36265: 							image->width,
36265: 							image->height,
36265: 							image->stride);
28077:     status = surface->base.status;
39069:     if (status) {
39069: 	free (data);
26419: 	return status;
39069:     }
26419: 
28077:     status = _cairo_user_data_array_set_data (&surface->base.user_data,
26419: 					      &wrap_image_key,
26419: 					      data,
26419: 					      _wrap_release_source_image);
26419:     if (status) {
28077: 	cairo_surface_destroy (&surface->base);
39069: 	free (data);
26419: 	return status;
26419:     }
26419: 
39069:     pixman_image_set_component_alpha (
39069: 	surface->pixman_image,
28363: 	pixman_image_get_component_alpha (image->pixman_image));
28077: 
28077:     *out = surface;
26419:     return CAIRO_STATUS_SUCCESS;
26419: }
26419: 
    1: /**
    1:  * _cairo_surface_clone_similar:
    1:  * @surface: a #cairo_surface_t
    1:  * @src: the source image
    1:  * @src_x: extent for the rectangle in src we actually care about
    1:  * @src_y: extent for the rectangle in src we actually care about
    1:  * @width: extent for the rectangle in src we actually care about
    1:  * @height: extent for the rectangle in src we actually care about
    1:  * @clone_out: location to store a surface compatible with @surface
    1:  *   and with contents identical to @src. The caller must call
    1:  *   cairo_surface_destroy() on the result.
    1:  *
    1:  * Creates a surface with contents identical to @src but that
    1:  *   can be used efficiently with @surface. If @surface and @src are
    1:  *   already compatible then it may return a new reference to @src.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS if a surface was created and stored
    1:  *   in @clone_out. Otherwise %CAIRO_INT_STATUS_UNSUPPORTED or another
    1:  *   error like %CAIRO_STATUS_NO_MEMORY.
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_clone_similar (cairo_surface_t  *surface,
    1: 			      cairo_surface_t  *src,
    1: 			      int               src_x,
    1: 			      int               src_y,
    1: 			      int               width,
    1: 			      int               height,
21379: 			      int              *clone_offset_x,
21379: 			      int              *clone_offset_y,
    1: 			      cairo_surface_t **clone_out)
    1: {
 6154:     cairo_status_t status = CAIRO_INT_STATUS_UNSUPPORTED;
    1:     cairo_image_surface_t *image;
    1:     void *image_extra;
    1: 
26419:     if (unlikely (surface->status))
12588: 	return surface->status;
12588: 
26419:     if (unlikely (surface->finished))
 8452: 	return _cairo_error (CAIRO_STATUS_SURFACE_FINISHED);
    1: 
70960: #if CAIRO_HAS_TEE_SURFACE
70960: 
41340:     if (src->type == CAIRO_SURFACE_TYPE_TEE) {
41340: 	cairo_surface_t *match;
41340: 
41340: 	match = _cairo_tee_surface_find_match (src,
41340: 					       surface->backend,
41340: 					       src->content);
41340: 	if (match != NULL)
41340: 	    src = match;
41340:     }
41340: 
70960: #endif
70960: 
41340:     if (surface->backend->clone_similar != NULL) {
21379: 	status = surface->backend->clone_similar (surface, src,
21379: 						  src_x, src_y,
21379: 						  width, height,
21379: 						  clone_offset_x,
21379: 						  clone_offset_y,
21379: 						  clone_out);
 6154: 	if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
29608: 	    if (_cairo_surface_is_image (src))
29608: 		return CAIRO_INT_STATUS_UNSUPPORTED;
29608: 
26419: 	    /* First check to see if we can replay to a similar surface */
41340: 	    if (_cairo_surface_is_recording (src)) {
41340: 		return _cairo_recording_surface_clone_similar (surface, src,
32473: 							       src_x, src_y,
32473: 							       width, height,
32473: 							       clone_offset_x,
32473: 							       clone_offset_y,
32473: 							       clone_out);
26419: 	    }
26419: 
 6154: 	    /* If we failed, try again with an image surface */
 6154: 	    status = _cairo_surface_acquire_source_image (src, &image, &image_extra);
 6154: 	    if (status == CAIRO_STATUS_SUCCESS) {
26419: 		status = _wrap_image(src, image, image_extra, &image);
26419: 		if (status != CAIRO_STATUS_SUCCESS) {
26419: 		    _cairo_surface_release_source_image (src, image, image_extra);
26419: 		} else {
 6154: 		    status =
 6154: 			surface->backend->clone_similar (surface, &image->base,
 4414: 							 src_x, src_y,
 4414: 							 width, height,
21379: 							 clone_offset_x,
21379: 							 clone_offset_y,
 4414: 							 clone_out);
26419: 		    cairo_surface_destroy(&image->base);
26419: 		}
 6154: 	    }
 6154: 	}
 6154:     }
 6154: 
 6154:     /* If we're still unsupported, hit our fallback path to get a clone */
29608:     if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
 6154: 	status =
21379: 	    _cairo_surface_fallback_clone_similar (surface, src,
21379: 						   src_x, src_y,
21379: 						   width, height,
21379: 						   clone_offset_x,
21379: 						   clone_offset_y,
21379: 						   clone_out);
29608:     }
    1: 
26419:     if (unlikely (status))
    1: 	return status;
    1: 
 6154:     /* Update the clone's device_transform (which the underlying surface
 6154:      * backend knows nothing about) */
 6154:     if (*clone_out != src) {
    1: 	(*clone_out)->device_transform = src->device_transform;
  314: 	(*clone_out)->device_transform_inverse = src->device_transform_inverse;
  314:     }
    1: 
    1:     return status;
    1: }
    1: 
 4133: /**
 4133:  * _cairo_surface_is_similar
 4133:  * @surface_a: a #cairo_surface_t
 4133:  * @surface_b: a #cairo_surface_t
 4133:  * @content: a #cairo_content_t
 4133:  *
 4133:  * Find out whether the given surfaces share the same backend,
 4133:  * and if so, whether they can be considered similar.
 4133:  *
 4133:  * The definition of "similar" depends on the backend. In
 4133:  * general, it means that the surface is equivalent to one
11708:  * that would have been generated by a call to cairo_surface_create_similar().
 4133:  *
11708:  * Return value: %TRUE if the surfaces are similar.
 4133:  **/
 4133: cairo_bool_t
 4133: _cairo_surface_is_similar (cairo_surface_t *surface_a,
70960: 	                   cairo_surface_t *surface_b)
 4133: {
 4133:     if (surface_a->backend != surface_b->backend)
 4133: 	return FALSE;
 4133: 
 4133:     if (surface_a->backend->is_similar != NULL)
70960: 	return surface_a->backend->is_similar (surface_a, surface_b);
 4133: 
 4133:     return TRUE;
 4133: }
 4133: 
    1: cairo_status_t
    1: _cairo_surface_composite (cairo_operator_t	op,
26419: 			  const cairo_pattern_t	*src,
26419: 			  const cairo_pattern_t	*mask,
    1: 			  cairo_surface_t	*dst,
    1: 			  int			src_x,
    1: 			  int			src_y,
    1: 			  int			mask_x,
    1: 			  int			mask_y,
    1: 			  int			dst_x,
    1: 			  int			dst_y,
    1: 			  unsigned int		width,
41340: 			  unsigned int		height,
41340: 			  cairo_region_t	*clip_region)
    1: {
    1:     cairo_int_status_t status;
    1: 
41340:     if (unlikely (dst->status))
32473: 	return dst->status;
32473: 
32473:     assert (_cairo_surface_is_writable (dst));
32473: 
    1:     if (mask) {
    1: 	/* These operators aren't interpreted the same way by the backends;
    1: 	 * they are implemented in terms of other operators in cairo-gstate.c
    1: 	 */
    1: 	assert (op != CAIRO_OPERATOR_SOURCE && op != CAIRO_OPERATOR_CLEAR);
    1:     }
    1: 
    1:     if (dst->backend->composite) {
    1: 	status = dst->backend->composite (op,
    1: 					  src, mask, dst,
    1:                                           src_x, src_y,
    1:                                           mask_x, mask_y,
    1:                                           dst_x, dst_y,
41340: 					  width, height,
41340: 					  clip_region);
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	    return _cairo_surface_set_error (dst, status);
    1:     }
    1: 
 8452:     return _cairo_surface_set_error (dst,
 8452: 	    _cairo_surface_fallback_composite (op,
    1: 					      src, mask, dst,
    1: 					      src_x, src_y,
    1: 					      mask_x, mask_y,
    1: 					      dst_x, dst_y,
41340: 					      width, height,
41340: 					      clip_region));
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_fill_rectangle:
    1:  * @surface: a #cairo_surface_t
    1:  * @op: the operator to apply to the rectangle
    1:  * @color: the source color
    1:  * @x: X coordinate of rectangle, in backend coordinates
    1:  * @y: Y coordinate of rectangle, in backend coordinates
    1:  * @width: width of rectangle, in backend coordinates
    1:  * @height: height of rectangle, in backend coordinates
    1:  *
    1:  * Applies an operator to a rectangle using a solid color as the source.
    1:  * See _cairo_surface_fill_rectangles() for full details.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or the error that occurred
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_fill_rectangle (cairo_surface_t	   *surface,
    1: 			       cairo_operator_t	    op,
    1: 			       const cairo_color_t *color,
    1: 			       int		    x,
    1: 			       int		    y,
    1: 			       int		    width,
    1: 			       int		    height)
    1: {
 4133:     cairo_rectangle_int_t rect;
    1: 
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
32473:     assert (_cairo_surface_is_writable (surface));
    1: 
    1:     rect.x = x;
    1:     rect.y = y;
    1:     rect.width = width;
    1:     rect.height = height;
    1: 
    1:     return _cairo_surface_fill_rectangles (surface, op, color, &rect, 1);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_fill_region:
    1:  * @surface: a #cairo_surface_t
    1:  * @op: the operator to apply to the region
    1:  * @color: the source color
    1:  * @region: the region to modify, in backend coordinates
    1:  *
    1:  * Applies an operator to a set of rectangles specified as a
 4133:  * #cairo_region_t using a solid color as the source.
    1:  * See _cairo_surface_fill_rectangles() for full details.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or the error that occurred
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_fill_region (cairo_surface_t	   *surface,
    1: 			    cairo_operator_t	    op,
    1: 			    const cairo_color_t    *color,
 4133: 			    cairo_region_t         *region)
    1: {
28364:     int num_rects;
10414:     cairo_rectangle_int_t stack_rects[CAIRO_STACK_ARRAY_LENGTH (cairo_rectangle_int_t)];
 8452:     cairo_rectangle_int_t *rects = stack_rects;
    1:     cairo_status_t status;
    1:     int i;
    1: 
12588:     if (surface->status)
12588: 	return surface->status;
12588: 
32473:     assert (_cairo_surface_is_writable (surface));
21379: 
28364:     num_rects = cairo_region_num_rectangles (region);
28364:     if (num_rects == 0)
 8452: 	return CAIRO_STATUS_SUCCESS;
 8452: 
41340:     /* catch a common reduction of _cairo_clip_combine_with_surface() */
41340:     if (op == CAIRO_OPERATOR_IN &&
41340: 	_cairo_color_equal (color, CAIRO_COLOR_WHITE))
41340:     {
41340: 	return CAIRO_STATUS_SUCCESS;
41340:     }
41340: 
28364:     if (num_rects > ARRAY_LENGTH (stack_rects)) {
28364: 	rects = _cairo_malloc_ab (num_rects,
 8452: 				  sizeof (cairo_rectangle_int_t));
26419: 	if (rects == NULL) {
 8452: 	    return _cairo_surface_set_error (surface,
26419: 					     _cairo_error (CAIRO_STATUS_NO_MEMORY));
 4133: 	}
 4133:     }
    1: 
28364:     for (i = 0; i < num_rects; i++)
28364: 	cairo_region_get_rectangle (region, i, &rects[i]);
    1: 
41340:     status =  _cairo_surface_fill_rectangles (surface,
41340: 					      op, color, rects, num_rects);
    1: 
 4133:     if (rects != stack_rects)
    1: 	free (rects);
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_fill_rectangles:
    1:  * @surface: a #cairo_surface_t
    1:  * @op: the operator to apply to the region
    1:  * @color: the source color
    1:  * @rects: the rectangles to modify, in backend coordinates
    1:  * @num_rects: the number of rectangles in @rects
    1:  *
    1:  * Applies an operator to a set of rectangles using a solid color
    1:  * as the source. Note that even if the operator is an unbounded operator
    1:  * such as %CAIRO_OPERATOR_IN, only the given set of rectangles
    1:  * is affected. This differs from _cairo_surface_composite_trapezoids()
    1:  * where the entire destination rectangle is cleared.
    1:  *
    1:  * Return value: %CAIRO_STATUS_SUCCESS or the error that occurred
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_fill_rectangles (cairo_surface_t		*surface,
    1: 				cairo_operator_t         op,
    1: 				const cairo_color_t	*color,
 4133: 				cairo_rectangle_int_t	*rects,
    1: 				int			 num_rects)
    1: {
    1:     cairo_int_status_t status;
    1: 
    1:     if (surface->status)
    1: 	return surface->status;
    1: 
32473:     assert (_cairo_surface_is_writable (surface));
    1: 
    1:     if (num_rects == 0)
    1: 	return CAIRO_STATUS_SUCCESS;
    1: 
    1:     if (surface->backend->fill_rectangles) {
41340: 	status = surface->backend->fill_rectangles (surface,
41340: 						    op, color,
    1: 						    rects, num_rects);
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	    return _cairo_surface_set_error (surface, status);
    1:     }
    1: 
 8452:     return _cairo_surface_set_error (surface,
41340: 	    _cairo_surface_fallback_fill_rectangles (surface,
41340: 						     op, color,
 8452: 						     rects, num_rects));
    1: }
    1: 
70960: static cairo_status_t
70960: _pattern_has_error (const cairo_pattern_t *pattern)
70960: {
70960:     const cairo_surface_pattern_t *spattern;
70960: 
70960:     if (unlikely (pattern->status))
70960: 	return pattern->status;
70960: 
70960:     if (pattern->type != CAIRO_PATTERN_TYPE_SURFACE)
70960: 	return CAIRO_STATUS_SUCCESS;
70960: 
70960:     spattern = (const cairo_surface_pattern_t *) pattern;
70960:     if (unlikely (spattern->surface->status))
70960: 	return spattern->surface->status;
70960: 
70960:     if (unlikely (spattern->surface->finished))
70960: 	return _cairo_error (CAIRO_STATUS_SURFACE_FINISHED);
70960: 
70960:     return CAIRO_STATUS_SUCCESS;
70960: }
70960: 
    1: cairo_status_t
    1: _cairo_surface_paint (cairo_surface_t	*surface,
    1: 		      cairo_operator_t	 op,
26419: 		      const cairo_pattern_t *source,
41340: 		      cairo_clip_t	    *clip)
    1: {
    1:     cairo_status_t status;
41340: 
41340:     if (unlikely (surface->status))
12588: 	return surface->status;
12588: 
41340:     if (clip && clip->all_clipped)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
70960:     if (op == CAIRO_OPERATOR_CLEAR && surface->is_clear)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
70960:     if (op == CAIRO_OPERATOR_OVER &&
70960: 	_cairo_pattern_is_clear (source))
70960:     {
70960: 	return CAIRO_STATUS_SUCCESS;
41340:     }
41340: 
70960:     status = _pattern_has_error (source);
70960:     if (unlikely (status))
70960: 	return status;
70960: 
32473:     _cairo_surface_begin_modification (surface);
21379: 
41340:     if (surface->backend->paint != NULL) {
41340: 	status = surface->backend->paint (surface, op, source, clip);
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
    1:             goto FINISH;
    1:     }
    1: 
41340:     status = _cairo_surface_fallback_paint (surface, op, source, clip);
    1: 
    1:  FINISH:
70960:     surface->is_clear = op == CAIRO_OPERATOR_CLEAR && clip == NULL;
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: cairo_status_t
    1: _cairo_surface_mask (cairo_surface_t		*surface,
    1: 		     cairo_operator_t		 op,
26419: 		     const cairo_pattern_t	*source,
26419: 		     const cairo_pattern_t	*mask,
41340: 		     cairo_clip_t		*clip)
    1: {
    1:     cairo_status_t status;
41340: 
41340:     if (unlikely (surface->status))
12588: 	return surface->status;
12588: 
41340:     if (clip && clip->all_clipped)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
41340:     if (op == CAIRO_OPERATOR_CLEAR && surface->is_clear)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
41340:     /* If the mask is blank, this is just an expensive no-op */
70960:     if (_cairo_pattern_is_clear (mask) &&
70960: 	_cairo_operator_bounded_by_mask (op))
70960:     {
41340: 	return CAIRO_STATUS_SUCCESS;
41340:     }
41340: 
70960:     if (op == CAIRO_OPERATOR_OVER &&
70960: 	_cairo_pattern_is_clear (source))
70960:     {
70960: 	return CAIRO_STATUS_SUCCESS;
70960:     }
70960: 
70960:     status = _pattern_has_error (source);
70960:     if (unlikely (status))
70960: 	return status;
70960: 
70960:     status = _pattern_has_error (mask);
70960:     if (unlikely (status))
70960: 	return status;
70960: 
40590:     _cairo_surface_begin_modification (surface);
40590: 
41340:     if (surface->backend->mask != NULL) {
41340: 	status = surface->backend->mask (surface, op, source, mask, clip);
41340: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
40590:             goto FINISH;
40574:     }
40574: 
41340:     status = _cairo_surface_fallback_mask (surface, op, source, mask, clip);
41340: 
 3847:  FINISH:
70960:     surface->is_clear = FALSE;
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: cairo_status_t
 6154: _cairo_surface_fill_stroke (cairo_surface_t	    *surface,
 6154: 			    cairo_operator_t	     fill_op,
26419: 			    const cairo_pattern_t   *fill_source,
 6154: 			    cairo_fill_rule_t	     fill_rule,
 6154: 			    double		     fill_tolerance,
 6154: 			    cairo_antialias_t	     fill_antialias,
 6154: 			    cairo_path_fixed_t	    *path,
 6154: 			    cairo_operator_t	     stroke_op,
26419: 			    const cairo_pattern_t   *stroke_source,
70960: 			    const cairo_stroke_style_t    *stroke_style,
70960: 			    const cairo_matrix_t	    *stroke_ctm,
70960: 			    const cairo_matrix_t	    *stroke_ctm_inverse,
 6154: 			    double		     stroke_tolerance,
26419: 			    cairo_antialias_t	     stroke_antialias,
41340: 			    cairo_clip_t	    *clip)
 6154: {
 6154:     cairo_status_t status;
 6154: 
41340:     if (unlikely (surface->status))
12588: 	return surface->status;
12588: 
41340:     if (clip && clip->all_clipped)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
41340:     if (surface->is_clear &&
41340: 	fill_op == CAIRO_OPERATOR_CLEAR &&
41340: 	stroke_op == CAIRO_OPERATOR_CLEAR)
41340:     {
41340: 	return CAIRO_STATUS_SUCCESS;
41340:     }
41340: 
70960:     status = _pattern_has_error (fill_source);
70960:     if (unlikely (status))
70960: 	return status;
70960: 
70960:     status = _pattern_has_error (stroke_source);
70960:     if (unlikely (status))
70960: 	return status;
70960: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
 6154:     if (surface->backend->fill_stroke) {
 6154: 	cairo_matrix_t dev_ctm = *stroke_ctm;
 6154: 	cairo_matrix_t dev_ctm_inverse = *stroke_ctm_inverse;
 6154: 
26419: 	status = surface->backend->fill_stroke (surface,
26419: 						fill_op, fill_source, fill_rule,
26419: 						fill_tolerance, fill_antialias,
26419: 						path,
26419: 						stroke_op, stroke_source,
26419: 						stroke_style,
26419: 						&dev_ctm, &dev_ctm_inverse,
26419: 						stroke_tolerance, stroke_antialias,
41340: 						clip);
 6154: 
 6154: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
41340: 	    goto FINISH;
 6154:     }
 6154: 
 6154:     status = _cairo_surface_fill (surface, fill_op, fill_source, path,
41340: 				  fill_rule, fill_tolerance, fill_antialias,
41340: 				  clip);
26419:     if (unlikely (status))
41340: 	goto FINISH;
 6154: 
 6154:     status = _cairo_surface_stroke (surface, stroke_op, stroke_source, path,
 6154: 				    stroke_style, stroke_ctm, stroke_ctm_inverse,
41340: 				    stroke_tolerance, stroke_antialias,
41340: 				    clip);
26419:     if (unlikely (status))
41340: 	goto FINISH;
41340: 
41340:   FINISH:
70960:     surface->is_clear = FALSE;
41340: 
 8452:     return _cairo_surface_set_error (surface, status);
 6154: }
 6154: 
 6154: cairo_status_t
    1: _cairo_surface_stroke (cairo_surface_t		*surface,
    1: 		       cairo_operator_t		 op,
26419: 		       const cairo_pattern_t	*source,
    1: 		       cairo_path_fixed_t	*path,
70960: 		       const cairo_stroke_style_t	*stroke_style,
70960: 		       const cairo_matrix_t		*ctm,
70960: 		       const cairo_matrix_t		*ctm_inverse,
    1: 		       double			 tolerance,
26419: 		       cairo_antialias_t	 antialias,
41340: 		       cairo_clip_t		*clip)
    1: {
    1:     cairo_status_t status;
41340: 
41340:     if (unlikely (surface->status))
12588: 	return surface->status;
12588: 
41340:     if (clip && clip->all_clipped)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
41340:     if (op == CAIRO_OPERATOR_CLEAR && surface->is_clear)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
70960:     if (op == CAIRO_OPERATOR_OVER &&
70960: 	_cairo_pattern_is_clear (source))
70960:     {
70960: 	return CAIRO_STATUS_SUCCESS;
70960:     }
70960: 
70960:     status = _pattern_has_error (source);
70960:     if (unlikely (status))
70960: 	return status;
70960: 
32473:     _cairo_surface_begin_modification (surface);
21379: 
41340:     if (surface->backend->stroke != NULL) {
26419: 	status = surface->backend->stroke (surface, op, source,
26419: 					   path, stroke_style,
41340: 					   ctm, ctm_inverse,
41340: 					   tolerance, antialias,
41340: 					   clip);
26419: 
26419: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
26419:             goto FINISH;
26419:     }
26419: 
26419:     status = _cairo_surface_fallback_stroke (surface, op, source,
    1:                                              path, stroke_style,
41340:                                              ctm, ctm_inverse,
41340:                                              tolerance, antialias,
41340: 					     clip);
    1: 
26419:  FINISH:
70960:     surface->is_clear = FALSE;
26419: 
26419:     return _cairo_surface_set_error (surface, status);
26419: }
26419: 
26419: cairo_status_t
26419: _cairo_surface_fill (cairo_surface_t	*surface,
26419: 		     cairo_operator_t	 op,
26419: 		     const cairo_pattern_t *source,
26419: 		     cairo_path_fixed_t	*path,
26419: 		     cairo_fill_rule_t	 fill_rule,
26419: 		     double		 tolerance,
26419: 		     cairo_antialias_t	 antialias,
41340: 		     cairo_clip_t	*clip)
26419: {
26419:     cairo_status_t status;
41340: 
41340:     if (unlikely (surface->status))
26419: 	return surface->status;
26419: 
41340:     if (clip && clip->all_clipped)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
41340:     if (op == CAIRO_OPERATOR_CLEAR && surface->is_clear)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
70960:     if (op == CAIRO_OPERATOR_OVER &&
70960: 	_cairo_pattern_is_clear (source))
70960:     {
70960: 	return CAIRO_STATUS_SUCCESS;
70960:     }
70960: 
70960:     status = _pattern_has_error (source);
70960:     if (unlikely (status))
70960: 	return status;
70960: 
32473:     _cairo_surface_begin_modification (surface);
26419: 
41340:     if (surface->backend->fill != NULL) {
26419: 	status = surface->backend->fill (surface, op, source,
26419: 					 path, fill_rule,
41340: 					 tolerance, antialias,
41340: 					 clip);
26419: 
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
    1:             goto FINISH;
    1:     }
    1: 
26419:     status = _cairo_surface_fallback_fill (surface, op, source,
26419:                                            path, fill_rule,
41340:                                            tolerance, antialias,
41340: 					   clip);
    1: 
    1:  FINISH:
70960:     surface->is_clear = FALSE;
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: cairo_status_t
    1: _cairo_surface_composite_trapezoids (cairo_operator_t		op,
26419: 				     const cairo_pattern_t	*pattern,
    1: 				     cairo_surface_t		*dst,
    1: 				     cairo_antialias_t		antialias,
    1: 				     int			src_x,
    1: 				     int			src_y,
    1: 				     int			dst_x,
    1: 				     int			dst_y,
    1: 				     unsigned int		width,
    1: 				     unsigned int		height,
    1: 				     cairo_trapezoid_t		*traps,
41340: 				     int			num_traps,
41340: 				     cairo_region_t		*clip_region)
    1: {
    1:     cairo_int_status_t status;
    1: 
32473:     if (dst->status)
32473: 	return dst->status;
32473: 
32473:     assert (_cairo_surface_is_writable (dst));
32473: 
    1:     /* These operators aren't interpreted the same way by the backends;
    1:      * they are implemented in terms of other operators in cairo-gstate.c
    1:      */
    1:     assert (op != CAIRO_OPERATOR_SOURCE && op != CAIRO_OPERATOR_CLEAR);
    1: 
    1:     if (dst->backend->composite_trapezoids) {
    1: 	status = dst->backend->composite_trapezoids (op,
    1: 						     pattern, dst,
    1: 						     antialias,
    1: 						     src_x, src_y,
    1:                                                      dst_x, dst_y,
    1: 						     width, height,
41340: 						     traps, num_traps,
41340: 						     clip_region);
    1: 	if (status != CAIRO_INT_STATUS_UNSUPPORTED)
 8452: 	    return _cairo_surface_set_error (dst, status);
    1:     }
    1: 
 8452:     return  _cairo_surface_set_error (dst,
 8452: 	    _cairo_surface_fallback_composite_trapezoids (op, pattern, dst,
    1: 							  antialias,
    1: 							  src_x, src_y,
    1: 							  dst_x, dst_y,
    1: 							  width, height,
41340: 							  traps, num_traps,
41340: 							  clip_region));
    1: }
    1: 
26419: cairo_span_renderer_t *
26419: _cairo_surface_create_span_renderer (cairo_operator_t		 op,
26419: 				     const cairo_pattern_t	*pattern,
26419: 				     cairo_surface_t		*dst,
26419: 				     cairo_antialias_t	         antialias,
41340: 				     const cairo_composite_rectangles_t *rects,
41340: 				     cairo_region_t		*clip_region)
26419: {
32473:     assert (dst->snapshot_of == NULL);
26419: 
41340:     if (unlikely (dst->status))
26419: 	return _cairo_span_renderer_create_in_error (dst->status);
26419: 
41340:     if (unlikely (dst->finished))
26419: 	return _cairo_span_renderer_create_in_error (CAIRO_STATUS_SURFACE_FINISHED);
26419: 
26419:     if (dst->backend->create_span_renderer) {
26419: 	return dst->backend->create_span_renderer (op,
26419: 						   pattern, dst,
26419: 						   antialias,
41340: 						   rects,
41340: 						   clip_region);
26419:     }
26419:     ASSERT_NOT_REACHED;
26419:     return _cairo_span_renderer_create_in_error (CAIRO_INT_STATUS_UNSUPPORTED);
26419: }
26419: 
26419: cairo_bool_t
26419: _cairo_surface_check_span_renderer (cairo_operator_t		 op,
26419: 				    const cairo_pattern_t	*pattern,
26419: 				    cairo_surface_t		*dst,
41340: 				    cairo_antialias_t	         antialias)
26419: {
32473:     assert (dst->snapshot_of == NULL);
41340:     assert (dst->status == CAIRO_STATUS_SUCCESS);
41340:     assert (! dst->finished);
41340: 
41340:     /* XXX: Currently we have no mono span renderer */
41340:     if (antialias == CAIRO_ANTIALIAS_NONE)
26419: 	return FALSE;
26419: 
41340:     if (dst->backend->check_span_renderer != NULL)
41340: 	return dst->backend->check_span_renderer (op, pattern, dst, antialias);
41340: 
26419:     return FALSE;
26419: }
26419: 
 6154: /**
 6154:  * cairo_surface_copy_page:
11708:  * @surface: a #cairo_surface_t
 6154:  *
 6154:  * Emits the current page for backends that support multiple pages,
 6154:  * but doesn't clear it, so that the contents of the current page will
 6154:  * be retained for the next page.  Use cairo_surface_show_page() if you
 6154:  * want to get an empty page after the emission.
 6154:  *
18904:  * There is a convenience function for this that takes a #cairo_t,
18904:  * namely cairo_copy_page().
18904:  *
 6154:  * Since: 1.6
 6154:  */
11708: void
 6154: cairo_surface_copy_page (cairo_surface_t *surface)
    1: {
11886:     cairo_status_t status_ignored;
11886: 
    1:     if (surface->status)
11708: 	return;
    1: 
32473:     assert (surface->snapshot_of == NULL);
21379: 
11708:     if (surface->finished) {
11886: 	status_ignored = _cairo_surface_set_error (surface,
11886: 		                                 CAIRO_STATUS_SURFACE_FINISHED);
11708: 	return;
11708:     }
    1: 
 4133:     /* It's fine if some backends don't implement copy_page */
    1:     if (surface->backend->copy_page == NULL)
11708: 	return;
    1: 
11886:     status_ignored = _cairo_surface_set_error (surface,
 8452: 			                 surface->backend->copy_page (surface));
    1: }
 6154: slim_hidden_def (cairo_surface_copy_page);
 6154: 
 6154: /**
 6154:  * cairo_surface_show_page:
 6154:  * @surface: a #cairo_Surface_t
 6154:  *
 6154:  * Emits and clears the current page for backends that support multiple
 6154:  * pages.  Use cairo_surface_copy_page() if you don't want to clear the page.
 6154:  *
18904:  * There is a convenience function for this that takes a #cairo_t,
18904:  * namely cairo_show_page().
18904:  *
 6154:  * Since: 1.6
 6154:  **/
11708: void
 6154: cairo_surface_show_page (cairo_surface_t *surface)
    1: {
11886:     cairo_status_t status_ignored;
11886: 
    1:     if (surface->status)
11708: 	return;
    1: 
11708:     if (surface->finished) {
11886: 	status_ignored = _cairo_surface_set_error (surface,
11886: 		                                 CAIRO_STATUS_SURFACE_FINISHED);
11708: 	return;
11708:     }
    1: 
70960:     _cairo_surface_begin_modification (surface);
70960: 
 4133:     /* It's fine if some backends don't implement show_page */
    1:     if (surface->backend->show_page == NULL)
11708: 	return;
    1: 
11886:     status_ignored = _cairo_surface_set_error (surface,
 8452: 			                 surface->backend->show_page (surface));
    1: }
 6154: slim_hidden_def (cairo_surface_show_page);
    1: 
    1: /**
    1:  * _cairo_surface_get_extents:
    1:  * @surface: the #cairo_surface_t to fetch extents for
    1:  *
    1:  * This function returns a bounding box for the surface.  The surface
    1:  * bounds are defined as a region beyond which no rendering will
    1:  * possibly be recorded, in other words, it is the maximum extent of
    1:  * potentially usable coordinates.
    1:  *
41340:  * For vector surfaces, (PDF, PS, SVG and recording-surfaces), the surface
    1:  * might be conceived as unbounded, but we force the user to provide a
    1:  * maximum size at the time of surface_create. So get_extents uses
    1:  * that size.
    1:  *
11708:  * Note: The coordinates returned are in "backend" space rather than
    1:  * "surface" space. That is, they are relative to the true (0,0)
    1:  * origin rather than the device_transform origin. This might seem a
11708:  * bit inconsistent with other #cairo_surface_t interfaces, but all
    1:  * current callers are within the surface layer where backend space is
    1:  * desired.
    1:  *
    1:  * This behavior would have to be changed is we ever exported a public
    1:  * variant of this function.
    1:  */
41340: cairo_bool_t
    1: _cairo_surface_get_extents (cairo_surface_t         *surface,
16122: 			    cairo_rectangle_int_t   *extents)
    1: {
70960:     cairo_bool_t bounded;
70960: 
70960:     bounded = FALSE;
41340:     if (surface->backend->get_extents != NULL)
41340: 	bounded = surface->backend->get_extents (surface, extents);
41340: 
41340:     if (! bounded)
41340: 	_cairo_unbounded_rectangle_init (extents);
41340: 
41340:     return bounded;
16122: }
16122: 
18904: /**
18904:  * cairo_surface_has_show_text_glyphs:
18904:  * @surface: a #cairo_surface_t
18904:  *
18904:  * Returns whether the surface supports
18904:  * sophisticated cairo_show_text_glyphs() operations.  That is,
18904:  * whether it actually uses the provided text and cluster data
18904:  * to a cairo_show_text_glyphs() call.
18904:  *
18904:  * Note: Even if this function returns %FALSE, a
18904:  * cairo_show_text_glyphs() operation targeted at @surface will
18904:  * still succeed.  It just will
18904:  * act like a cairo_show_glyphs() operation.  Users can use this
18904:  * function to avoid computing UTF-8 text and cluster mapping if the
18904:  * target surface does not use it.
18904:  *
18904:  * Return value: %TRUE if @surface supports
18904:  *               cairo_show_text_glyphs(), %FALSE otherwise
18904:  *
18904:  * Since: 1.8
18904:  **/
16122: cairo_bool_t
18904: cairo_surface_has_show_text_glyphs (cairo_surface_t	    *surface)
16122: {
18904:     cairo_status_t status_ignored;
18904: 
18904:     if (surface->status)
18904: 	return FALSE;
18904: 
18904:     if (surface->finished) {
18904: 	status_ignored = _cairo_surface_set_error (surface,
18904: 						   CAIRO_STATUS_SURFACE_FINISHED);
18904: 	return FALSE;
18904:     }
18904: 
16122:     if (surface->backend->has_show_text_glyphs)
16122: 	return surface->backend->has_show_text_glyphs (surface);
16122:     else
16122: 	return surface->backend->show_text_glyphs != NULL;
    1: }
18904: slim_hidden_def (cairo_surface_has_show_text_glyphs);
    1: 
59761: /**
59761:  * cairo_surface_set_subpixel_antialiasing:
59761:  * @surface: a #cairo_surface_t
59761:  *
59761:  * Sets whether the surface permits subpixel antialiasing. By default,
59761:  * surfaces permit subpixel antialiasing.
59761:  *
59761:  * Enabling subpixel antialiasing for CONTENT_COLOR_ALPHA surfaces generally
59761:  * requires that the pixels in the areas under a subpixel antialiasing
59761:  * operation already be opaque.
59761:  *
59761:  * Since: 1.12
59761:  **/
59761: void
59761: cairo_surface_set_subpixel_antialiasing (cairo_surface_t *surface,
59761:                                          cairo_subpixel_antialiasing_t enabled)
59761: {
59761:     if (surface->status)
59761:         return;
59761: 
59761:     if (surface->finished) {
59761:         _cairo_surface_set_error (surface, CAIRO_STATUS_SURFACE_FINISHED);
59761:         return;
59761:     }
59761: 
59761:     surface->permit_subpixel_antialiasing =
59761:         enabled == CAIRO_SUBPIXEL_ANTIALIASING_ENABLED;
59761: }
59761: slim_hidden_def (cairo_surface_set_subpixel_antialiasing);
59761: 
59761: /**
59761:  * cairo_surface_get_subpixel_antialiasing:
59761:  * @surface: a #cairo_surface_t
59761:  *
59761:  * Gets whether the surface supports subpixel antialiasing. By default,
59761:  * CAIRO_CONTENT_COLOR surfaces support subpixel antialiasing but other
59761:  * surfaces do not.
59761:  *
59761:  * Since: 1.12
59761:  **/
59761: cairo_subpixel_antialiasing_t
59761: cairo_surface_get_subpixel_antialiasing (cairo_surface_t *surface)
59761: {
59761:     if (surface->status)
59761:         return CAIRO_SUBPIXEL_ANTIALIASING_DISABLED;
59761: 
59761:     return surface->permit_subpixel_antialiasing ?
59761:         CAIRO_SUBPIXEL_ANTIALIASING_ENABLED : CAIRO_SUBPIXEL_ANTIALIASING_DISABLED;
59761: }
59761: slim_hidden_def (cairo_surface_get_subpixel_antialiasing);
59761: 
 6154: /* Note: the backends may modify the contents of the glyph array as long as
16122:  * they do not return %CAIRO_INT_STATUS_UNSUPPORTED. This makes it possible to
 6154:  * avoid copying the array again and again, and edit it in-place.
 6154:  * Backends are in fact free to use the array as a generic buffer as they
 6154:  * see fit.
16122:  *
16122:  * For show_glyphs backend method, and NOT for show_text_glyphs method,
16122:  * when they do return UNSUPPORTED, they may adjust remaining_glyphs to notify
16122:  * that they have successfully rendered some of the glyphs (from the beginning
16122:  * of the array), but not all.  If they don't touch remaining_glyphs, it
16122:  * defaults to all glyphs.
16122:  *
 6154:  * See commits 5a9642c5746fd677aed35ce620ce90b1029b1a0c and
 6154:  * 1781e6018c17909311295a9cc74b70500c6b4d0a for the rationale.
 6154:  */
    1: cairo_status_t
16122: _cairo_surface_show_text_glyphs (cairo_surface_t	    *surface,
    1: 				 cairo_operator_t	     op,
26419: 				 const cairo_pattern_t	    *source,
16122: 				 const char		    *utf8,
16122: 				 int			     utf8_len,
    1: 				 cairo_glyph_t		    *glyphs,
    1: 				 int			     num_glyphs,
16122: 				 const cairo_text_cluster_t *clusters,
16122: 				 int			     num_clusters,
21379: 				 cairo_text_cluster_flags_t  cluster_flags,
26419: 				 cairo_scaled_font_t	    *scaled_font,
41340: 				 cairo_clip_t		    *clip)
    1: {
    1:     cairo_status_t status;
    1:     cairo_scaled_font_t *dev_scaled_font = scaled_font;
41340: 
41340:     if (unlikely (surface->status))
12588: 	return surface->status;
12588: 
32473:     if (num_glyphs == 0 && utf8_len == 0)
    1: 	return CAIRO_STATUS_SUCCESS;
    1: 
41340:     if (clip && clip->all_clipped)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
41340:     if (op == CAIRO_OPERATOR_CLEAR && surface->is_clear)
41340: 	return CAIRO_STATUS_SUCCESS;
41340: 
70960:     status = _pattern_has_error (source);
70960:     if (unlikely (status))
70960: 	return status;
70960: 
32473:     _cairo_surface_begin_modification (surface);
32473: 
    1:     if (_cairo_surface_has_device_transform (surface) &&
    1: 	! _cairo_matrix_is_integer_translation (&surface->device_transform, NULL, NULL))
    1:     {
16122: 	cairo_font_options_t font_options;
16122: 	cairo_matrix_t dev_ctm, font_matrix;
    1: 
16122: 	cairo_scaled_font_get_font_matrix (scaled_font, &font_matrix);
    1: 	cairo_scaled_font_get_ctm (scaled_font, &dev_ctm);
    1: 	cairo_matrix_multiply (&dev_ctm, &dev_ctm, &surface->device_transform);
16122: 	cairo_scaled_font_get_font_options (scaled_font, &font_options);
    1: 	dev_scaled_font = cairo_scaled_font_create (cairo_scaled_font_get_font_face (scaled_font),
    1: 						    &font_matrix,
    1: 						    &dev_ctm,
16122: 						    &font_options);
    1:     }
 4133:     status = cairo_scaled_font_status (dev_scaled_font);
41340:     if (unlikely (status))
 8452: 	return _cairo_surface_set_error (surface, status);
    1: 
  314:     status = CAIRO_INT_STATUS_UNSUPPORTED;
  314: 
16122:     /* The logic here is duplicated in _cairo_analysis_surface show_glyphs and
16122:      * show_text_glyphs.  Keep in synch. */
16122:     if (clusters) {
16122: 	/* A real show_text_glyphs call.  Try show_text_glyphs backend
16122: 	 * method first */
41340: 	if (surface->backend->show_text_glyphs != NULL) {
26419: 	    status = surface->backend->show_text_glyphs (surface, op,
26419: 							 source,
16122: 							 utf8, utf8_len,
16122: 							 glyphs, num_glyphs,
21379: 							 clusters, num_clusters, cluster_flags,
41340: 							 dev_scaled_font,
41340: 							 clip);
16122: 	}
41340: 	if (status == CAIRO_INT_STATUS_UNSUPPORTED &&
41340: 	    surface->backend->show_glyphs)
41340: 	{
16122: 	    int remaining_glyphs = num_glyphs;
26419: 	    status = surface->backend->show_glyphs (surface, op,
26419: 						    source,
    1: 						    glyphs, num_glyphs,
16122: 						    dev_scaled_font,
41340: 						    clip,
41340: 						    &remaining_glyphs);
16122: 	    glyphs += num_glyphs - remaining_glyphs;
16122: 	    num_glyphs = remaining_glyphs;
16122: 	    if (status == CAIRO_INT_STATUS_UNSUPPORTED && remaining_glyphs == 0)
16122: 		status = CAIRO_STATUS_SUCCESS;
16122: 	}
16122:     } else {
16122: 	/* A mere show_glyphs call.  Try show_glyphs backend method first */
41340: 	if (surface->backend->show_glyphs != NULL) {
16122: 	    int remaining_glyphs = num_glyphs;
26419: 	    status = surface->backend->show_glyphs (surface, op,
26419: 						    source,
16122: 						    glyphs, num_glyphs,
16122: 						    dev_scaled_font,
41340: 						    clip,
41340: 						    &remaining_glyphs);
16122: 	    glyphs += num_glyphs - remaining_glyphs;
16122: 	    num_glyphs = remaining_glyphs;
16122: 	    if (status == CAIRO_INT_STATUS_UNSUPPORTED && remaining_glyphs == 0)
16122: 		status = CAIRO_STATUS_SUCCESS;
41340: 	} else if (surface->backend->show_text_glyphs != NULL) {
16122: 	    /* Intentionally only try show_text_glyphs method for show_glyphs
16122: 	     * calls if backend does not have show_glyphs.  If backend has
16122: 	     * both methods implemented, we don't fallback from show_glyphs to
16122: 	     * show_text_glyphs, and hence the backend can assume in its
16122: 	     * show_text_glyphs call that clusters is not NULL (which also
16122: 	     * implies that UTF-8 is not NULL, unless the text is
16122: 	     * zero-length).
16122: 	     */
26419: 	    status = surface->backend->show_text_glyphs (surface, op,
26419: 							 source,
16122: 							 utf8, utf8_len,
16122: 							 glyphs, num_glyphs,
21379: 							 clusters, num_clusters, cluster_flags,
41340: 							 dev_scaled_font,
41340: 							 clip);
16122: 	}
16122:     }
    1: 
41340:     if (status == CAIRO_INT_STATUS_UNSUPPORTED) {
26419: 	status = _cairo_surface_fallback_show_glyphs (surface, op,
26419: 						      source,
    1: 						      glyphs, num_glyphs,
41340: 						      dev_scaled_font,
41340: 						      clip);
41340:     }
    1: 
    1:     if (dev_scaled_font != scaled_font)
    1: 	cairo_scaled_font_destroy (dev_scaled_font);
    1: 
70960:     surface->is_clear = FALSE;
    1: 
 8452:     return _cairo_surface_set_error (surface, status);
    1: }
    1: 
    1: /* XXX: Previously, we had a function named _cairo_surface_show_glyphs
16122:  * with not-so-useful semantics. We've now got a
16122:  * _cairo_surface_show_text_glyphs with the proper semantics, and its
    1:  * fallback still uses this old function (which still needs to be
    1:  * cleaned up in terms of both semantics and naming). */
    1: cairo_status_t
    1: _cairo_surface_old_show_glyphs (cairo_scaled_font_t	*scaled_font,
    1: 				cairo_operator_t	 op,
26419: 				const cairo_pattern_t	*pattern,
    1: 				cairo_surface_t		*dst,
    1: 				int			 source_x,
    1: 				int			 source_y,
    1: 				int			 dest_x,
    1: 				int			 dest_y,
    1: 				unsigned int		 width,
    1: 				unsigned int		 height,
    1: 				cairo_glyph_t		*glyphs,
41340: 				int			 num_glyphs,
41340: 				cairo_region_t		*clip_region)
    1: {
    1:     cairo_status_t status;
    1: 
    1:     if (dst->status)
    1: 	return dst->status;
    1: 
32473:     assert (_cairo_surface_is_writable (dst));
    1: 
    1:     if (dst->backend->old_show_glyphs) {
    1: 	status = dst->backend->old_show_glyphs (scaled_font,
    1: 						op, pattern, dst,
    1: 						source_x, source_y,
    1:                                                 dest_x, dest_y,
    1: 						width, height,
41340: 						glyphs, num_glyphs,
41340: 						clip_region);
    1:     } else
    1: 	status = CAIRO_INT_STATUS_UNSUPPORTED;
    1: 
 8452:     return _cairo_surface_set_error (dst, status);
    1: }
    1: 
    1: static cairo_status_t
    1: _cairo_surface_composite_fixup_unbounded_internal (cairo_surface_t         *dst,
 4133: 						   cairo_rectangle_int_t   *src_rectangle,
 4133: 						   cairo_rectangle_int_t   *mask_rectangle,
    1: 						   int			    dst_x,
    1: 						   int			    dst_y,
    1: 						   unsigned int		    width,
41340: 						   unsigned int		    height,
41340: 						   cairo_region_t	    *clip_region)
    1: {
 4133:     cairo_rectangle_int_t dst_rectangle;
32473:     cairo_region_t clear_region;
 4133:     cairo_status_t status;
    1: 
28364:     /* The area that was drawn is the area in the destination rectangle but
28364:      * not within the source or the mask.
    1:      */
    1:     dst_rectangle.x = dst_x;
    1:     dst_rectangle.y = dst_y;
    1:     dst_rectangle.width = width;
    1:     dst_rectangle.height = height;
28364: 
32473:     _cairo_region_init_rectangle (&clear_region, &dst_rectangle);
    1: 
41340:     if (clip_region != NULL) {
41340: 	status = cairo_region_intersect (&clear_region, clip_region);
41340: 	if (unlikely (status))
41340: 	    goto CLEANUP_REGIONS;
41340:     }
41340: 
41340:     if (src_rectangle != NULL) {
28364:         if (! _cairo_rectangle_intersect (&dst_rectangle, src_rectangle))
26419: 	    goto EMPTY;
26419:     }
26419: 
41340:     if (mask_rectangle != NULL) {
28364:         if (! _cairo_rectangle_intersect (&dst_rectangle, mask_rectangle))
26419: 	    goto EMPTY;
26419:     }
    1: 
28364:     /* Now compute the area that is in dst but not drawn */
32473:     status = cairo_region_subtract_rectangle (&clear_region, &dst_rectangle);
41340:     if (unlikely (status) || cairo_region_is_empty (&clear_region))
    1:         goto CLEANUP_REGIONS;
    1: 
26419:   EMPTY:
41340:     status = _cairo_surface_fill_region (dst, CAIRO_OPERATOR_CLEAR,
    1:                                          CAIRO_COLOR_TRANSPARENT,
32473:                                          &clear_region);
    1: 
    1:   CLEANUP_REGIONS:
32473:     _cairo_region_fini (&clear_region);
    1: 
 8452:     return _cairo_surface_set_error (dst, status);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_composite_fixup_unbounded:
    1:  * @dst: the destination surface
    1:  * @src_attr: source surface attributes (from _cairo_pattern_acquire_surface())
    1:  * @src_width: width of source surface
    1:  * @src_height: height of source surface
    1:  * @mask_attr: mask surface attributes or %NULL if no mask
    1:  * @mask_width: width of mask surface
    1:  * @mask_height: height of mask surface
    1:  * @src_x: @src_x from _cairo_surface_composite()
    1:  * @src_y: @src_y from _cairo_surface_composite()
    1:  * @mask_x: @mask_x from _cairo_surface_composite()
    1:  * @mask_y: @mask_y from _cairo_surface_composite()
    1:  * @dst_x: @dst_x from _cairo_surface_composite()
    1:  * @dst_y: @dst_y from _cairo_surface_composite()
    1:  * @width: @width from _cairo_surface_composite()
    1:  * @height: @height_x from _cairo_surface_composite()
    1:  *
    1:  * Eeek! Too many parameters! This is a helper function to take care of fixing
    1:  * up for bugs in libpixman and RENDER where, when asked to composite an
    1:  * untransformed surface with an unbounded operator (like CLEAR or SOURCE)
    1:  * only the region inside both the source and the mask is affected.
    1:  * This function clears the region that should have been drawn but was wasn't.
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_composite_fixup_unbounded (cairo_surface_t            *dst,
    1: 					  cairo_surface_attributes_t *src_attr,
    1: 					  int                         src_width,
    1: 					  int                         src_height,
    1: 					  cairo_surface_attributes_t *mask_attr,
    1: 					  int                         mask_width,
    1: 					  int                         mask_height,
    1: 					  int			      src_x,
    1: 					  int			      src_y,
    1: 					  int			      mask_x,
    1: 					  int			      mask_y,
    1: 					  int			      dst_x,
    1: 					  int			      dst_y,
    1: 					  unsigned int		      width,
41340: 					  unsigned int		      height,
41340: 					  cairo_region_t	     *clip_region)
    1: {
 4133:     cairo_rectangle_int_t src_tmp, mask_tmp;
 4133:     cairo_rectangle_int_t *src_rectangle = NULL;
 4133:     cairo_rectangle_int_t *mask_rectangle = NULL;
    1: 
41340:     if (unlikely (dst->status))
12588: 	return dst->status;
12588: 
32473:     assert (_cairo_surface_is_writable (dst));
21379: 
    1:     /* The RENDER/libpixman operators are clipped to the bounds of the untransformed,
    1:      * non-repeating sources and masks. Other sources and masks can be ignored.
    1:      */
    1:     if (_cairo_matrix_is_integer_translation (&src_attr->matrix, NULL, NULL) &&
    1: 	src_attr->extend == CAIRO_EXTEND_NONE)
    1:     {
    1: 	src_tmp.x = (dst_x - (src_x + src_attr->x_offset));
    1: 	src_tmp.y = (dst_y - (src_y + src_attr->y_offset));
    1: 	src_tmp.width = src_width;
    1: 	src_tmp.height = src_height;
    1: 
    1: 	src_rectangle = &src_tmp;
    1:     }
    1: 
    1:     if (mask_attr &&
    1: 	_cairo_matrix_is_integer_translation (&mask_attr->matrix, NULL, NULL) &&
    1: 	mask_attr->extend == CAIRO_EXTEND_NONE)
    1:     {
    1: 	mask_tmp.x = (dst_x - (mask_x + mask_attr->x_offset));
    1: 	mask_tmp.y = (dst_y - (mask_y + mask_attr->y_offset));
    1: 	mask_tmp.width = mask_width;
    1: 	mask_tmp.height = mask_height;
    1: 
    1: 	mask_rectangle = &mask_tmp;
    1:     }
    1: 
    1:     return _cairo_surface_composite_fixup_unbounded_internal (dst, src_rectangle, mask_rectangle,
41340: 							      dst_x, dst_y, width, height,
41340: 							      clip_region);
    1: }
    1: 
    1: /**
    1:  * _cairo_surface_composite_shape_fixup_unbounded:
    1:  * @dst: the destination surface
    1:  * @src_attr: source surface attributes (from _cairo_pattern_acquire_surface())
    1:  * @src_width: width of source surface
    1:  * @src_height: height of source surface
    1:  * @mask_width: width of mask surface
    1:  * @mask_height: height of mask surface
    1:  * @src_x: @src_x from _cairo_surface_composite()
    1:  * @src_y: @src_y from _cairo_surface_composite()
    1:  * @mask_x: @mask_x from _cairo_surface_composite()
    1:  * @mask_y: @mask_y from _cairo_surface_composite()
    1:  * @dst_x: @dst_x from _cairo_surface_composite()
    1:  * @dst_y: @dst_y from _cairo_surface_composite()
    1:  * @width: @width from _cairo_surface_composite()
    1:  * @height: @height_x from _cairo_surface_composite()
    1:  *
    1:  * Like _cairo_surface_composite_fixup_unbounded(), but instead of
    1:  * handling the case where we have a source pattern and a mask
    1:  * pattern, handle the case where we are compositing a source pattern
    1:  * using a mask we create ourselves, as in
    1:  * _cairo_surface_composite_glyphs() or _cairo_surface_composite_trapezoids()
    1:  **/
    1: cairo_status_t
    1: _cairo_surface_composite_shape_fixup_unbounded (cairo_surface_t            *dst,
    1: 						cairo_surface_attributes_t *src_attr,
    1: 						int                         src_width,
    1: 						int                         src_height,
    1: 						int                         mask_width,
    1: 						int                         mask_height,
    1: 						int			    src_x,
    1: 						int			    src_y,
    1: 						int			    mask_x,
    1: 						int			    mask_y,
    1: 						int			    dst_x,
    1: 						int			    dst_y,
    1: 						unsigned int		    width,
41340: 						unsigned int		    height,
41340: 						cairo_region_t	    *clip_region)
    1: {
41340:     cairo_rectangle_int_t src_tmp, *src= NULL;
41340:     cairo_rectangle_int_t mask;
    1: 
12588:     if (dst->status)
12588: 	return dst->status;
12588: 
32473:     assert (_cairo_surface_is_writable (dst));
21379: 
    1:     /* The RENDER/libpixman operators are clipped to the bounds of the untransformed,
    1:      * non-repeating sources and masks. Other sources and masks can be ignored.
    1:      */
    1:     if (_cairo_matrix_is_integer_translation (&src_attr->matrix, NULL, NULL) &&
    1: 	src_attr->extend == CAIRO_EXTEND_NONE)
    1:     {
    1: 	src_tmp.x = (dst_x - (src_x + src_attr->x_offset));
    1: 	src_tmp.y = (dst_y - (src_y + src_attr->y_offset));
    1: 	src_tmp.width  = src_width;
    1: 	src_tmp.height = src_height;
    1: 
41340: 	src = &src_tmp;
    1:     }
    1: 
41340:     mask.x = dst_x - mask_x;
41340:     mask.y = dst_y - mask_y;
41340:     mask.width  = mask_width;
41340:     mask.height = mask_height;
41340: 
41340:     return _cairo_surface_composite_fixup_unbounded_internal (dst, src, &mask,
41340: 							      dst_x, dst_y, width, height,
41340: 							      clip_region);
    1: }
    1: 
 6154: /**
 6154:  * _cairo_surface_set_resolution
 6154:  * @surface: the surface
 6154:  * @x_res: x resolution, in dpi
 6154:  * @y_res: y resolution, in dpi
 6154:  *
 6154:  * Set the actual surface resolution of @surface to the given x and y DPI.
 6154:  * Mainly used for correctly computing the scale factor when fallback
 6154:  * rendering needs to take place in the paginated surface.
 6154:  */
 6154: void
 6154: _cairo_surface_set_resolution (cairo_surface_t *surface,
 6154: 			       double x_res,
 6154: 			       double y_res)
 6154: {
12588:     if (surface->status)
12588: 	return;
12588: 
 6154:     surface->x_resolution = x_res;
 6154:     surface->y_resolution = y_res;
 6154: }
 6154: 
41340: /* Generic methods for determining operation extents. */
41340: 
41340: static void
41340: _rectangle_intersect_clip (cairo_rectangle_int_t *extents, cairo_clip_t *clip)
41340: {
41340:     const cairo_rectangle_int_t *clip_extents;
41340:     cairo_bool_t is_empty;
41340: 
41340:     clip_extents = NULL;
41340:     if (clip != NULL)
41340: 	clip_extents = _cairo_clip_get_extents (clip);
41340: 
41340:     if (clip_extents != NULL)
41340: 	is_empty = _cairo_rectangle_intersect (extents, clip_extents);
41340: }
41340: 
41340: static void
41340: _cairo_surface_operation_extents (cairo_surface_t *surface,
41340: 				  cairo_operator_t op,
41340: 				  const cairo_pattern_t *source,
41340: 				  cairo_clip_t *clip,
41340: 				  cairo_rectangle_int_t *extents)
41340: {
41340:     cairo_bool_t is_empty;
41340: 
41340:     is_empty = _cairo_surface_get_extents (surface, extents);
41340: 
41340:     if (_cairo_operator_bounded_by_source (op)) {
41340: 	cairo_rectangle_int_t source_extents;
41340: 
41340: 	_cairo_pattern_get_extents (source, &source_extents);
41340: 	is_empty = _cairo_rectangle_intersect (extents, &source_extents);
41340:     }
41340: 
41340:     _rectangle_intersect_clip (extents, clip);
41340: }
41340: 
41340: cairo_status_t
41340: _cairo_surface_paint_extents (cairo_surface_t *surface,
41340: 			      cairo_operator_t		op,
41340: 			      const cairo_pattern_t	*source,
41340: 			      cairo_clip_t		*clip,
41340: 			      cairo_rectangle_int_t	*extents)
41340: {
41340:     _cairo_surface_operation_extents (surface, op, source, clip, extents);
41340:     return CAIRO_STATUS_SUCCESS;
41340: }
41340: 
41340: cairo_status_t
41340: _cairo_surface_mask_extents (cairo_surface_t *surface,
41340: 			     cairo_operator_t		 op,
41340: 			     const cairo_pattern_t	*source,
41340: 			     const cairo_pattern_t	*mask,
41340: 			     cairo_clip_t		*clip,
41340: 			     cairo_rectangle_int_t	*extents)
41340: {
41340:     cairo_bool_t is_empty;
41340: 
41340:     _cairo_surface_operation_extents (surface, op, source, clip, extents);
41340: 
41340:     if (_cairo_operator_bounded_by_mask (op)) {
41340: 	cairo_rectangle_int_t mask_extents;
41340: 
41340: 	_cairo_pattern_get_extents (mask, &mask_extents);
41340: 	is_empty = _cairo_rectangle_intersect (extents, &mask_extents);
41340:     }
41340: 
41340:     return CAIRO_STATUS_SUCCESS;
41340: }
41340: 
41340: cairo_status_t
41340: _cairo_surface_stroke_extents (cairo_surface_t *surface,
41340: 			       cairo_operator_t op,
41340: 			       const cairo_pattern_t *source,
41340: 			       cairo_path_fixed_t	*path,
70960: 			       const cairo_stroke_style_t *style,
41340: 			       const cairo_matrix_t *ctm,
41340: 			       const cairo_matrix_t *ctm_inverse,
41340: 			       double tolerance,
41340: 			       cairo_antialias_t	 antialias,
41340: 			       cairo_clip_t *clip,
41340: 			       cairo_rectangle_int_t *extents)
41340: {
41340:     cairo_status_t status;
41340:     cairo_bool_t is_empty;
41340: 
41340:     _cairo_surface_operation_extents (surface, op, source, clip, extents);
41340: 
41340:     if (_cairo_operator_bounded_by_mask (op)) {
41340: 	cairo_rectangle_int_t mask_extents;
41340: 
41340: 	status = _cairo_path_fixed_stroke_extents (path, style,
41340: 						   ctm, ctm_inverse,
41340: 						   tolerance,
41340: 						   &mask_extents);
41340: 	if (unlikely (status))
41340: 	    return status;
41340: 
41340: 	is_empty = _cairo_rectangle_intersect (extents, &mask_extents);
41340:     }
41340: 
41340:     return CAIRO_STATUS_SUCCESS;
41340: }
41340: 
41340: cairo_status_t
41340: _cairo_surface_fill_extents (cairo_surface_t		*surface,
41340: 			     cairo_operator_t		 op,
41340: 			     const cairo_pattern_t	*source,
41340: 			     cairo_path_fixed_t		*path,
41340: 			     cairo_fill_rule_t		 fill_rule,
41340: 			     double			 tolerance,
41340: 			     cairo_antialias_t		 antialias,
41340: 			     cairo_clip_t		*clip,
41340: 			     cairo_rectangle_int_t	*extents)
41340: {
41340:     cairo_bool_t is_empty;
41340: 
41340:     _cairo_surface_operation_extents (surface, op, source, clip, extents);
41340: 
41340:     if (_cairo_operator_bounded_by_mask (op)) {
41340: 	cairo_rectangle_int_t mask_extents;
41340: 
41340: 	_cairo_path_fixed_fill_extents (path, fill_rule, tolerance,
41340: 					&mask_extents);
41340: 	is_empty = _cairo_rectangle_intersect (extents, &mask_extents);
41340:     }
41340: 
41340:     return CAIRO_STATUS_SUCCESS;
41340: }
41340: 
41340: cairo_status_t
41340: _cairo_surface_glyphs_extents (cairo_surface_t *surface,
41340: 			       cairo_operator_t	   op,
41340: 			       const cairo_pattern_t *source,
41340: 			       cairo_glyph_t	  *glyphs,
41340: 			       int		   num_glyphs,
41340: 			       cairo_scaled_font_t  *scaled_font,
41340: 			       cairo_clip_t         *clip,
41340: 			       cairo_rectangle_int_t *extents)
41340: {
41340:     cairo_status_t	     status;
41340:     cairo_bool_t             is_empty;
41340: 
41340:     _cairo_surface_operation_extents (surface, op, source, clip, extents);
41340: 
41340:     if (_cairo_operator_bounded_by_mask (op)) {
41340: 	cairo_rectangle_int_t glyph_extents;
41340: 
41340: 	status = _cairo_scaled_font_glyph_device_extents (scaled_font,
41340: 							  glyphs,
41340: 							  num_glyphs,
41340: 							  &glyph_extents,
41340: 							  NULL);
41340: 	if (unlikely (status))
41340: 	    return status;
41340: 
41340: 	is_empty = _cairo_rectangle_intersect (extents, &glyph_extents);
41340:     }
41340: 
41340:     return CAIRO_STATUS_SUCCESS;
41340: }
41340: 
10694: cairo_surface_t *
10694: _cairo_surface_create_in_error (cairo_status_t status)
10694: {
10694:     switch (status) {
10694:     case CAIRO_STATUS_NO_MEMORY:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil;
32473:     case CAIRO_STATUS_SURFACE_TYPE_MISMATCH:
32473: 	return (cairo_surface_t *) &_cairo_surface_nil_surface_type_mismatch;
41340:     case CAIRO_STATUS_INVALID_STATUS:
41340: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_status;
10694:     case CAIRO_STATUS_INVALID_CONTENT:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_content;
10694:     case CAIRO_STATUS_INVALID_FORMAT:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_format;
10694:     case CAIRO_STATUS_INVALID_VISUAL:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_visual;
10694:     case CAIRO_STATUS_READ_ERROR:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_read_error;
10694:     case CAIRO_STATUS_WRITE_ERROR:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_write_error;
10694:     case CAIRO_STATUS_FILE_NOT_FOUND:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_file_not_found;
10694:     case CAIRO_STATUS_TEMP_FILE_ERROR:
10694: 	return (cairo_surface_t *) &_cairo_surface_nil_temp_file_error;
11708:     case CAIRO_STATUS_INVALID_STRIDE:
11708: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_stride;
29608:     case CAIRO_STATUS_INVALID_SIZE:
29608: 	return (cairo_surface_t *) &_cairo_surface_nil_invalid_size;
70960:     case CAIRO_STATUS_DEVICE_TYPE_MISMATCH:
70960: 	return (cairo_surface_t *) &_cairo_surface_nil_device_type_mismatch;
70960:     case CAIRO_STATUS_DEVICE_ERROR:
70960: 	return (cairo_surface_t *) &_cairo_surface_nil_device_error;
13979:     case CAIRO_STATUS_SUCCESS:
28364:     case CAIRO_STATUS_LAST_STATUS:
13979: 	ASSERT_NOT_REACHED;
13979: 	/* fall-through */
13979:     case CAIRO_STATUS_INVALID_RESTORE:
13979:     case CAIRO_STATUS_INVALID_POP_GROUP:
13979:     case CAIRO_STATUS_NO_CURRENT_POINT:
13979:     case CAIRO_STATUS_INVALID_MATRIX:
13979:     case CAIRO_STATUS_NULL_POINTER:
13979:     case CAIRO_STATUS_INVALID_STRING:
13979:     case CAIRO_STATUS_INVALID_PATH_DATA:
13979:     case CAIRO_STATUS_SURFACE_FINISHED:
13979:     case CAIRO_STATUS_PATTERN_TYPE_MISMATCH:
13979:     case CAIRO_STATUS_INVALID_DASH:
13979:     case CAIRO_STATUS_INVALID_DSC_COMMENT:
13979:     case CAIRO_STATUS_INVALID_INDEX:
13979:     case CAIRO_STATUS_CLIP_NOT_REPRESENTABLE:
16122:     case CAIRO_STATUS_FONT_TYPE_MISMATCH:
16122:     case CAIRO_STATUS_USER_FONT_IMMUTABLE:
16122:     case CAIRO_STATUS_USER_FONT_ERROR:
16122:     case CAIRO_STATUS_NEGATIVE_COUNT:
16122:     case CAIRO_STATUS_INVALID_CLUSTERS:
18904:     case CAIRO_STATUS_INVALID_SLANT:
18904:     case CAIRO_STATUS_INVALID_WEIGHT:
29608:     case CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED:
10694:     default:
10694: 	_cairo_error_throw (CAIRO_STATUS_NO_MEMORY);
10694: 	return (cairo_surface_t *) &_cairo_surface_nil;
10694:     }
10694: }
10694: 
    1: /*  LocalWords:  rasterized
    1:  */
