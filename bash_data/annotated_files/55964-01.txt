    1: /* -*- Mode: c++; tab-width: 2; indent-tabs-mode: nil; -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is a Cocoa widget run loop and event implementation.
    1:  *
    1:  * The Initial Developer of the Original Code is Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Mark Mentovai <mark@moxienet.com> (Original Author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Runs the main native Cocoa run loop, interrupting it as needed to process
    1:  * Gecko events.
    1:  */
    1: 
    1: #import <Cocoa/Cocoa.h>
36292: #include <dlfcn.h>
    1: 
    1: #include "nsAppShell.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIFile.h"
    1: #include "nsDirectoryServiceDefs.h"
    1: #include "nsString.h"
 3574: #include "nsIRollupListener.h"
 3574: #include "nsIWidget.h"
 6111: #include "nsThreadUtils.h"
 6111: #include "nsIWindowMediator.h"
 6111: #include "nsServiceManagerUtils.h"
 6111: #include "nsIInterfaceRequestor.h"
 6111: #include "nsIWebBrowserChrome.h"
11690: #include "nsObjCExceptions.h"
13608: #include "nsCocoaUtils.h"
15585: #include "nsChildView.h"
20595: #include "nsToolkit.h"
 3574: 
33318: #include "npapi.h"
33318: 
 3574: // defined in nsChildView.mm
 3574: extern nsIRollupListener * gRollupListener;
 3574: extern nsIWidget         * gRollupWidget;
22847: extern PRUint32          gLastModifierState;
    1: 
 6111: // defined in nsCocoaWindow.mm
 6111: extern PRInt32             gXULModalLevel;
 6111: 
20595: static PRBool gAppShellMethodsSwizzled = PR_FALSE;
20595: // List of current Cocoa app-modal windows (nested if more than one).
26321: nsCocoaAppModalWindowList *gCocoaAppModalWindowList = NULL;
20595: 
26321: // Push a Cocoa app-modal window onto the top of our list.
26321: nsresult nsCocoaAppModalWindowList::PushCocoa(NSWindow *aWindow, NSModalSession aSession)
20595: {
20595:   NS_ENSURE_STATE(aWindow && aSession);
26321:   mList.AppendElement(nsCocoaAppModalWindowListItem(aWindow, aSession));
20595:   return NS_OK;
20595: }
20595: 
26321: // Pop the topmost Cocoa app-modal window off our list.  aWindow and aSession
26321: // are just used to check that it's what we expect it to be.
26321: nsresult nsCocoaAppModalWindowList::PopCocoa(NSWindow *aWindow, NSModalSession aSession)
20595: {
20595:   NS_ENSURE_STATE(aWindow && aSession);
26321: 
26321:   for (int i = mList.Length(); i > 0; --i) {
26321:     nsCocoaAppModalWindowListItem &item = mList.ElementAt(i - 1);
26321:     if (item.mSession) {
26321:       NS_ASSERTION((item.mWindow == aWindow) && (item.mSession == aSession),
26321:                    "PopCocoa() called without matching call to PushCocoa()!");
26321:       mList.RemoveElementAt(i - 1);
26321:       return NS_OK;
20595:     }
26321:   }
26321: 
26321:   NS_ERROR("PopCocoa() called without matching call to PushCocoa()!");
26321:   return NS_ERROR_FAILURE;
26321: }
26321: 
26321: // Push a Gecko-modal window onto the top of our list.
26321: nsresult nsCocoaAppModalWindowList::PushGecko(NSWindow *aWindow, nsCocoaWindow *aWidget)
26321: {
26321:   NS_ENSURE_STATE(aWindow && aWidget);
26321:   mList.AppendElement(nsCocoaAppModalWindowListItem(aWindow, aWidget));
20595:   return NS_OK;
20595: }
20595: 
26321: // Pop the topmost Gecko-modal window off our list.  aWindow and aWidget are
26321: // just used to check that it's what we expect it to be.
26321: nsresult nsCocoaAppModalWindowList::PopGecko(NSWindow *aWindow, nsCocoaWindow *aWidget)
26321: {
26321:   NS_ENSURE_STATE(aWindow && aWidget);
26321: 
26321:   for (int i = mList.Length(); i > 0; --i) {
26321:     nsCocoaAppModalWindowListItem &item = mList.ElementAt(i - 1);
26321:     if (item.mWidget) {
26321:       NS_ASSERTION((item.mWindow == aWindow) && (item.mWidget == aWidget),
26321:                    "PopGecko() called without matching call to PushGecko()!");
26321:       mList.RemoveElementAt(i - 1);
26321:       return NS_OK;
26321:     }
26321:   }
26321: 
26321:   NS_ERROR("PopGecko() called without matching call to PushGecko()!");
26321:   return NS_ERROR_FAILURE;
26321: }
26321: 
20595: // The "current session" is normally the "session" corresponding to the
20595: // top-most Cocoa app-modal window (both on the screen and in our list).
20595: // But because Cocoa app-modal dialog can be "interrupted" by a Gecko-modal
20595: // dialog, the top-most Cocoa app-modal dialog may already have finished
20595: // (and no longer be visible).  In this case we need to check the list for
20595: // the "next" visible Cocoa app-modal window (and return its "session"), or
20595: // (if no Cocoa app-modal window is visible) return nil.  This way we ensure
20595: // (as we need to) that all nested Cocoa app-modal sessions are dealt with
20595: // before we get to any Gecko-modal session(s).  See nsAppShell::
20595: // ProcessNextNativeEvent() below.
20595: NSModalSession nsCocoaAppModalWindowList::CurrentSession()
20595: {
20595:   if (![NSApp _isRunningAppModal])
20595:     return nil;
20595: 
26321:   NSModalSession currentSession = nil;
26321: 
26321:   for (int i = mList.Length(); i > 0; --i) {
26321:     nsCocoaAppModalWindowListItem &item = mList.ElementAt(i - 1);
26321:     if (item.mSession && [item.mWindow isVisible]) {
26321:       currentSession = item.mSession;
20595:       break;
20595:     }
20595:   }
20595: 
20595:   return currentSession;
20595: }
20595: 
26321: // Has a Gecko modal dialog popped up over a Cocoa app-modal dialog?
26321: PRBool nsCocoaAppModalWindowList::GeckoModalAboveCocoaModal()
26321: {
26321:   if (mList.IsEmpty())
26321:     return PR_FALSE;
26321: 
26321:   nsCocoaAppModalWindowListItem &topItem = mList.ElementAt(mList.Length() - 1);
26321: 
26321:   return (topItem.mWidget != nsnull);
26321: }
26321: 
    1: // AppShellDelegate
    1: //
 6111: // Cocoa bridge class.  An object of this class is registered to receive
 6111: // notifications.
    1: //
    1: @interface AppShellDelegate : NSObject
    1: {
    1:   @private
    1:     nsAppShell* mAppShell;
    1: }
    1: 
    1: - (id)initWithAppShell:(nsAppShell*)aAppShell;
    1: - (void)applicationWillTerminate:(NSNotification*)aNotification;
 3574: - (void)beginMenuTracking:(NSNotification*)aNotification;
    1: @end
    1: 
    1: // nsAppShell implementation
    1: 
    4: NS_IMETHODIMP
    4: nsAppShell::ResumeNative(void)
    4: {
    4:   nsresult retval = nsBaseAppShell::ResumeNative();
  383:   if (NS_SUCCEEDED(retval) && (mSuspendNativeCount == 0) &&
  383:       mSkippedNativeCallback)
  383:   {
  383:     mSkippedNativeCallback = PR_FALSE;
    4:     ScheduleNativeEventCallback();
  383:   }
    4:   return retval;
    4: }
    4: 
    1: nsAppShell::nsAppShell()
    1: : mAutoreleasePools(nsnull)
 6111: , mDelegate(nsnull)
 6111: , mCFRunLoop(NULL)
 6111: , mCFRunLoopSource(NULL)
    1: , mRunningEventLoop(PR_FALSE)
 6111: , mStarted(PR_FALSE)
    1: , mTerminated(PR_FALSE)
  383: , mSkippedNativeCallback(PR_FALSE)
 6111: , mHadMoreEventsCount(0)
 6349: , mRecursionDepth(0)
 6349: , mNativeEventCallbackDepth(0)
29293: , mNativeEventScheduledDepth(0)
    1: {
24533:   // A Cocoa event loop is running here if (and only if) we've been embedded
24533:   // by a Cocoa app (like Camino).
24533:   mRunningCocoaEmbedded = [NSApp isRunning] ? PR_TRUE : PR_FALSE;
    1: }
    1: 
    1: nsAppShell::~nsAppShell()
    1: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11690: 
 6111:   if (mCFRunLoop) {
 6111:     if (mCFRunLoopSource) {
 6111:       ::CFRunLoopRemoveSource(mCFRunLoop, mCFRunLoopSource,
 6111:                               kCFRunLoopCommonModes);
 6111:       ::CFRelease(mCFRunLoopSource);
 6111:     }
 6111:     ::CFRelease(mCFRunLoop);
 6111:   }
 6111: 
    1:   if (mAutoreleasePools) {
    1:     NS_ASSERTION(::CFArrayGetCount(mAutoreleasePools) == 0,
    1:                  "nsAppShell destroyed without popping all autorelease pools");
    1:     ::CFRelease(mAutoreleasePools);
    1:   }
    1: 
    1:   [mDelegate release];
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK
    1: }
    1: 
    1: // Init
    1: //
 6111: // Loads the nib (see bug 316076c21) and sets up the CFRunLoopSource used to
 6111: // interrupt the main native run loop.
    1: //
    1: // public
    1: nsresult
    1: nsAppShell::Init()
    1: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11690: 
 6111:   // No event loop is running yet (unless Camino is running, or another
40763:   // embedding app that uses NSApplicationMain()).
    1:   NSAutoreleasePool* localPool = [[NSAutoreleasePool alloc] init];
    1: 
    1:   // mAutoreleasePools is used as a stack of NSAutoreleasePool objects created
    1:   // by |this|.  CFArray is used instead of NSArray because NSArray wants to
    1:   // retain each object you add to it, and you can't retain an
    1:   // NSAutoreleasePool.
    1:   mAutoreleasePools = ::CFArrayCreateMutable(nsnull, 0, nsnull);
    1:   NS_ENSURE_STATE(mAutoreleasePools);
    1: 
    1:   // Get the path of the nib file, which lives in the GRE location
    1:   nsCOMPtr<nsIFile> nibFile;
    1:   nsresult rv = NS_GetSpecialDirectory(NS_GRE_DIR, getter_AddRefs(nibFile));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nibFile->AppendNative(NS_LITERAL_CSTRING("res"));
    1:   nibFile->AppendNative(NS_LITERAL_CSTRING("MainMenu.nib"));
    1: 
    1:   nsCAutoString nibPath;
    1:   rv = nibFile->GetNativePath(nibPath);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 6111:   // This call initializes NSApplication unless:
 6111:   // 1) we're using xre -- NSApp's already been initialized by
 6111:   //    MacApplicationDelegate.mm's EnsureUseCocoaDockAPI().
 6111:   // 2) Camino is running (or another embedding app that uses
 6111:   //    NSApplicationMain()) -- NSApp's already been initialized and
 6111:   //    its main run loop is already running.
    1:   [NSBundle loadNibFile:
    1:                      [NSString stringWithUTF8String:(const char*)nibPath.get()]
    1:       externalNameTable:
    1:            [NSDictionary dictionaryWithObject:[NSApplication sharedApplication]
    1:                                        forKey:@"NSOwner"]
    1:                withZone:NSDefaultMallocZone()];
    1: 
    1:   mDelegate = [[AppShellDelegate alloc] initWithAppShell:this];
    1:   NS_ENSURE_STATE(mDelegate);
    1: 
 6111:   // Add a CFRunLoopSource to the main native run loop.  The source is
 6111:   // responsible for interrupting the run loop when Gecko events are ready.
    1: 
 6111:   mCFRunLoop = [[NSRunLoop currentRunLoop] getCFRunLoop];
 6111:   NS_ENSURE_STATE(mCFRunLoop);
 6111:   ::CFRetain(mCFRunLoop);
 6111: 
 6111:   CFRunLoopSourceContext context;
 6111:   bzero(&context, sizeof(context));
 6111:   // context.version = 0;
 6111:   context.info = this;
 6111:   context.perform = ProcessGeckoEvents;
 6111:   
 6111:   mCFRunLoopSource = ::CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &context);
 6111:   NS_ENSURE_STATE(mCFRunLoopSource);
 6111: 
 6111:   ::CFRunLoopAddSource(mCFRunLoop, mCFRunLoopSource, kCFRunLoopCommonModes);
    1: 
    1:   rv = nsBaseAppShell::Init();
    1: 
33318: #ifndef NP_NO_CARBON
15585:   NS_InstallPluginKeyEventsHandler();
33318: #endif
15585: 
20595:   gCocoaAppModalWindowList = new nsCocoaAppModalWindowList;
20595:   if (!gAppShellMethodsSwizzled) {
20595:     nsToolkit::SwizzleMethods([NSApplication class], @selector(beginModalSessionForWindow:),
20595:                               @selector(nsAppShell_NSApplication_beginModalSessionForWindow:));
20595:     nsToolkit::SwizzleMethods([NSApplication class], @selector(endModalSession:),
20595:                               @selector(nsAppShell_NSApplication_endModalSession:));
55964:     // We should only replace the original terminate: method if we're not
55964:     // running in a Cocoa embedder (like Camino).  See bug 604901.
55964:     if (!mRunningCocoaEmbedded) {
55964:       nsToolkit::SwizzleMethods([NSApplication class], @selector(terminate:),
55964:                                 @selector(nsAppShell_NSApplication_terminate:));
55964:     }
38441:     if (!nsToolkit::OnSnowLeopardOrLater()) {
36292:       dlopen("/System/Library/Frameworks/Carbon.framework/Frameworks/Print.framework/Versions/Current/Plugins/PrintCocoaUI.bundle/Contents/MacOS/PrintCocoaUI",
36292:              RTLD_LAZY);
36292:       Class PDEPluginCallbackClass = ::NSClassFromString(@"PDEPluginCallback");
36292:       nsresult rv1 = nsToolkit::SwizzleMethods(PDEPluginCallbackClass, @selector(initWithPrintWindowController:),
36292:                                                @selector(nsAppShell_PDEPluginCallback_initWithPrintWindowController:));
36292:       if (NS_SUCCEEDED(rv1)) {
36292:         nsToolkit::SwizzleMethods(PDEPluginCallbackClass, @selector(dealloc),
36292:                                   @selector(nsAppShell_PDEPluginCallback_dealloc));
36292:       }
36292:     }
20595:     gAppShellMethodsSwizzled = PR_TRUE;
20595:   }
20595: 
    1:   [localPool release];
    1: 
    1:   return rv;
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: // ProcessGeckoEvents
    1: //
 6111: // The "perform" target of mCFRunLoop, called when mCFRunLoopSource is
 6111: // signalled from ScheduleNativeEventCallback.
    1: //
 6111: // Arrange for Gecko events to be processed on demand (in response to a call
 6111: // to ScheduleNativeEventCallback(), if processing of Gecko events via "native
20595: // methods" hasn't been suspended).  This happens in NativeEventCallback().
    1: //
 6111: // protected static
    1: void
 6111: nsAppShell::ProcessGeckoEvents(void* aInfo)
    1: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11690: 
 6111:   nsAppShell* self = static_cast<nsAppShell*> (aInfo);
    1: 
 6111:   if (self->mRunningEventLoop) {
 6111:     self->mRunningEventLoop = PR_FALSE;
 6111: 
 6272:     // The run loop may be sleeping -- [NSRunLoop runMode:...]
 6111:     // won't return until it's given a reason to wake up.  Awaken it by
 6111:     // posting a bogus event.  There's no need to make the event
 6111:     // presentable.
 6253:     //
 6253:     // But _don't_ set windowNumber to '-1' -- that can lead to nasty
 6253:     // wierdness like bmo bug 397039 (a crash in [NSApp sendEvent:] on one of
 6253:     // these fake events, because the -1 has gotten changed into the number
 6253:     // of an actual NSWindow object, and that NSWindow object has just been
 6253:     // destroyed).  Setting windowNumber to '0' seems to work fine -- this
 6253:     // seems to prevent the OS from ever trying to associate our bogus event
 6253:     // with a particular NSWindow object.
    1:     [NSApp postEvent:[NSEvent otherEventWithType:NSApplicationDefined
    1:                                         location:NSMakePoint(0,0)
    1:                                    modifierFlags:0
    1:                                        timestamp:0
 6253:                                     windowNumber:0
    1:                                          context:NULL
    1:                                          subtype:0
    1:                                            data1:0
    1:                                            data2:0]
    1:              atStart:NO];
    1:   }
    1: 
 6111:   if (self->mSuspendNativeCount <= 0) {
 6349:     ++self->mNativeEventCallbackDepth;
 6111:     self->NativeEventCallback();
 6349:     --self->mNativeEventCallbackDepth;
  383:   } else {
 6111:     self->mSkippedNativeCallback = PR_TRUE;
  383:   }
    1: 
 6111:   // Still needed to fix bug 343033 ("5-10 second delay or hang or crash
 6111:   // when quitting Cocoa Firefox").
    1:   [NSApp postEvent:[NSEvent otherEventWithType:NSApplicationDefined
    1:                                       location:NSMakePoint(0,0)
    1:                                  modifierFlags:0
    1:                                      timestamp:0
 6253:                                   windowNumber:0
    1:                                        context:NULL
    1:                                        subtype:0
    1:                                          data1:0
    1:                                          data2:0]
    1:            atStart:NO];
 6111: 
29293:   // Normally every call to ScheduleNativeEventCallback() results in
29293:   // exactly one call to ProcessGeckoEvents().  So each Release() here
29293:   // normally balances exactly one AddRef() in ScheduleNativeEventCallback().
29293:   // But if Exit() is called just after ScheduleNativeEventCallback(), the
29293:   // corresponding call to ProcessGeckoEvents() will never happen.  We check
29293:   // for this possibility in two different places -- here and in Exit()
29293:   // itself.  If we find here that Exit() has been called (that mTerminated
29293:   // is PR_TRUE), it's because we've been called recursively, that Exit() was
29293:   // called from self->NativeEventCallback() above, and that we're unwinding
29293:   // the recursion.  In this case we'll never be called again, and we balance
29293:   // here any extra calls to ScheduleNativeEventCallback().
29293:   //
29293:   // When ProcessGeckoEvents() is called recursively, it's because of a
29293:   // call to ScheduleNativeEventCallback() from NativeEventCallback().  We
29293:   // balance the "extra" AddRefs here (rather than always in Exit()) in order
29293:   // to ensure that 'self' stays alive until the end of this method.  We also
29293:   // make sure not to finish the balancing until all the recursion has been
29293:   // unwound.
29293:   if (self->mTerminated) {
29293:     PRInt32 releaseCount = 0;
29293:     if (self->mNativeEventScheduledDepth > self->mNativeEventCallbackDepth) {
29293:       releaseCount = PR_AtomicSet(&self->mNativeEventScheduledDepth,
29293:                                   self->mNativeEventCallbackDepth);
29293:     }
29293:     while (releaseCount-- > self->mNativeEventCallbackDepth)
29293:       self->Release();
29293:   } else {
29293:     // As best we can tell, every call to ProcessGeckoEvents() is triggered
29293:     // by a call to ScheduleNativeEventCallback().  But we've seen a few
29293:     // (non-reproducible) cases of double-frees that *might* have been caused
29293:     // by spontaneous calls (from the OS) to ProcessGeckoEvents().  So we
29293:     // deal with that possibility here.
29293:     if (PR_AtomicDecrement(&self->mNativeEventScheduledDepth) < 0) {
29293:       PR_AtomicSet(&self->mNativeEventScheduledDepth, 0);
29293:       NS_WARNING("Spontaneous call to ProcessGeckoEvents()!");
29293:     } else {
29293:       self->Release();
29293:     }
29293:   }
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: // WillTerminate
    1: //
    1: // Called by the AppShellDelegate when an NSApplicationWillTerminate
    1: // notification is posted.  After this method is called, native events should
 6111: // no longer be processed.  The NSApplicationWillTerminate notification is
 6111: // only posted when [NSApp terminate:] is called, which doesn't happen on a
 6111: // "normal" application quit.
    1: //
    1: // public
    1: void
    1: nsAppShell::WillTerminate()
    1: {
 6111:   if (mTerminated)
 6111:     return;
 6111: 
55879:   // Make sure that the nsAppExitEvent posted by nsAppStartup::Quit() (called
55879:   // from [MacApplicationDelegate applicationShouldTerminate:]) gets run.
 6111:   NS_ProcessPendingEvents(NS_GetCurrentThread());
 6111: 
55879:   mTerminated = PR_TRUE;
    1: }
    1: 
    1: // ScheduleNativeEventCallback
    1: //
    1: // Called (possibly on a non-main thread) when Gecko has an event that
    1: // needs to be processed.  The Gecko event needs to be processed on the
    1: // main thread, so the native run loop must be interrupted.
    1: //
 6111: // In nsBaseAppShell.cpp, the mNativeEventPending variable is used to
 6111: // ensure that ScheduleNativeEventCallback() is called no more than once
 6111: // per call to NativeEventCallback().  ProcessGeckoEvents() can skip its
 6111: // call to NativeEventCallback() if processing of Gecko events by native
 6111: // means is suspended (using nsIAppShell::SuspendNative()), which will
 6111: // suspend calls from nsBaseAppShell::OnDispatchedEvent() to
 6111: // ScheduleNativeEventCallback().  But when Gecko event processing by
 6111: // native means is resumed (in ResumeNative()), an extra call is made to
 6111: // ScheduleNativeEventCallback() (from ResumeNative()).  This triggers
 6111: // another call to ProcessGeckoEvents(), which calls NativeEventCallback(),
 6111: // and nsBaseAppShell::OnDispatchedEvent() resumes calling
 6111: // ScheduleNativeEventCallback().
 6111: //
    1: // protected virtual
    1: void
    1: nsAppShell::ScheduleNativeEventCallback()
    1: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11690: 
 6111:   if (mTerminated)
 6111:     return;
    1: 
29293:   // Each AddRef() here is normally balanced by exactly one Release() in
29293:   // ProcessGeckoEvents().  But there are exceptions, for which see
29293:   // ProcessGeckoEvents() and Exit().
 6111:   NS_ADDREF_THIS();
29293:   PR_AtomicIncrement(&mNativeEventScheduledDepth);
    1: 
 6111:   // This will invoke ProcessGeckoEvents on the main thread.
 6111:   ::CFRunLoopSourceSignal(mCFRunLoopSource);
 6111:   ::CFRunLoopWakeUp(mCFRunLoop);
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: // ProcessNextNativeEvent
    1: //
    1: // If aMayWait is false, process a single native event.  If it is true, run
    1: // the native run loop until stopped by ProcessGeckoEvents.
    1: //
    1: // Returns true if more events are waiting in the native event queue.
    1: //
 6272: // But (now that we're using [NSRunLoop runMode:beforeDate:]) it's too
 6272: // expensive to call ProcessNextNativeEvent() many times in a row (in a
 6111: // tight loop), so we never return true more than kHadMoreEventsCountMax
 6111: // times in a row.  This doesn't seem to cause native event starvation.
 6111: //
    1: // protected virtual
    1: PRBool
    1: nsAppShell::ProcessNextNativeEvent(PRBool aMayWait)
    1: {
 6111:   PRBool moreEvents = PR_FALSE;
11690: 
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11690: 
    1:   PRBool eventProcessed = PR_FALSE;
 6111:   NSString* currentMode = nil;
    1: 
    1:   if (mTerminated)
13299:     return PR_FALSE;
    1: 
26321:   // We don't want any native events to be processed here (via Gecko) while
26321:   // Cocoa is displaying an app-modal dialog (as opposed to a window-modal
26321:   // "sheet" or a Gecko-modal dialog).  Otherwise Cocoa event-processing loops
26321:   // may be interrupted, and inappropriate events may get through to the
26321:   // browser window(s) underneath.  This resolves bmo bugs 419668 and 420967.
26321:   //
26321:   // But we need more complex handling (we need to make an exception) if a
26321:   // Gecko modal dialog is running above the Cocoa app-modal dialog -- for
26321:   // which see below.
26321:   if ([NSApp _isRunningAppModal] &&
26321:       (!gCocoaAppModalWindowList || !gCocoaAppModalWindowList->GeckoModalAboveCocoaModal()))
26321:     return PR_FALSE;
26321: 
    1:   PRBool wasRunningEventLoop = mRunningEventLoop;
    1:   mRunningEventLoop = aMayWait;
    1:   NSDate* waitUntil = nil;
    1:   if (aMayWait)
    1:     waitUntil = [NSDate distantFuture];
    1: 
 6272:   NSRunLoop* currentRunLoop = [NSRunLoop currentRunLoop];
 6272: 
    1:   do {
    1:     // No autorelease pool is provided here, because OnProcessNextEvent
    1:     // and AfterProcessNextEvent are responsible for maintaining it.
    1:     NS_ASSERTION(mAutoreleasePools && ::CFArrayGetCount(mAutoreleasePools),
    1:                  "No autorelease pool for native event");
    1: 
 6111:     // If an event is waiting to be processed, run the main event loop
 6111:     // just long enough to process it.  For some reason, using [NSApp
 6111:     // nextEventMatchingMask:...] to dequeue the event and [NSApp sendEvent:]
 6111:     // to "send" it causes trouble, so we no longer do that.  (The trouble
 6111:     // was very strange, and only happened while processing Gecko events on
 6111:     // demand (via ProcessGeckoEvents()), as opposed to processing Gecko
 6111:     // events in a tight loop (via nsBaseAppShell::Run()):  Particularly in
 6111:     // Camino, mouse-down events sometimes got dropped (or mis-handled), so
 6111:     // that (for example) you sometimes needed to click more than once on a
 6111:     // button to make it work (the zoom button was particularly susceptible).
 6111:     // You also sometimes had to ctrl-click or right-click multiple times to
 6111:     // bring up a context menu.)
 6111: 
 6272:     // Now that we're using [NSRunLoop runMode:beforeDate:], it's too
 6272:     // expensive to call ProcessNextNativeEvent() many times in a row, so we
 6272:     // never return true more than kHadMoreEventsCountMax in a row.  I'm not
 6272:     // entirely sure why [NSRunLoop runMode:beforeDate:] is too expensive,
 6272:     // since it and its cousin [NSRunLoop acceptInputForMode:beforeDate:] are
 6111:     // designed to be called in a tight loop.  Possibly the problem is due to
 6272:     // combining [NSRunLoop runMode:beforeDate] with [NSApp
 6111:     // nextEventMatchingMask:...].
 6111: 
 6340:     // We special-case timer events (events of type NSPeriodic) to avoid
 6340:     // starving them.  Apple's documentation is very scanty, and it's now
 6340:     // more scanty than it used to be.  But it appears that [NSRunLoop
 6340:     // acceptInputForMode:beforeDate:] doesn't process timer events at all,
 6340:     // that it is called from [NSRunLoop runMode:beforeDate:], and that
 6340:     // [NSRunLoop runMode:beforeDate:], though it does process timer events,
 6340:     // doesn't return after doing so.  To get around this, when aWait is
 6340:     // PR_FALSE we check for timer events and process them using [NSApp
 6340:     // sendEvent:].  When aWait is PR_TRUE [NSRunLoop runMode:beforeDate:]
 6340:     // will only return on a "real" event.  But there's code in
 6340:     // ProcessGeckoEvents() that should (when need be) wake us up by sending
 6340:     // a "fake" "real" event.  (See Apple's current doc on [NSRunLoop
 6340:     // runMode:beforeDate:] and a quote from what appears to be an older
 6340:     // version of this doc at
 6272:     // http://lists.apple.com/archives/cocoa-dev/2001/May/msg00559.html.)
 6272: 
 6111:     // If the current mode is something else than NSDefaultRunLoopMode, look
 6111:     // for events in that mode.
 6272:     currentMode = [currentRunLoop currentMode];
 6111:     if (!currentMode)
 6111:       currentMode = NSDefaultRunLoopMode;
 6111: 
 6272:     NSEvent* nextEvent = nil;
 6272: 
 6349:     // If we're running modal (or not in a Gecko "main" event loop) we still
 6349:     // need to use nextEventMatchingMask and sendEvent -- otherwise (in
 6349:     // Minefield) the modal window (or non-main event loop) won't receive key
 6349:     // events or most mouse events.
 6349:     if ([NSApp _isRunningModal] || !InGeckoMainEventLoop()) {
10562:       if ((nextEvent = [NSApp nextEventMatchingMask:NSAnyEventMask
    1:                                           untilDate:waitUntil
 6111:                                              inMode:currentMode
10562:                                             dequeue:YES])) {
26321:         // If we're in a Cocoa app-modal session that's been interrupted by a
26321:         // Gecko-modal dialog, send the event to the Cocoa app-modal dialog's
26321:         // session.  This ensures that the app-modal session won't be starved
26321:         // of events, and fixes bugs 463473 and 442442.  (The case of an
26321:         // ordinary Cocoa app-modal dialog has been dealt with above.)
20595:         //
26321:         // Otherwise (if we're in an ordinary Gecko-modal dialog, or if we're
26321:         // otherwise not in a Gecko main event loop), process the event as
26321:         // expected.
20595:         NSModalSession currentAppModalSession = nil;
20595:         if (gCocoaAppModalWindowList)
20595:           currentAppModalSession = gCocoaAppModalWindowList->CurrentSession();
20595:         if (currentAppModalSession) {
20595:           [NSApp _modalSession:currentAppModalSession sendEvent:nextEvent];
20595:         } else {
 6272:           [NSApp sendEvent:nextEvent];
20595:         }
 6111:         eventProcessed = PR_TRUE;
    1:       }
 6111:     } else {
 6111:       if (aMayWait ||
 6272:           (nextEvent = [NSApp nextEventMatchingMask:NSAnyEventMask
 6111:                                           untilDate:nil
 6111:                                              inMode:currentMode
 6272:                                             dequeue:NO])) {
 6272:         if (nextEvent && ([nextEvent type] == NSPeriodic)) {
 6272:           nextEvent = [NSApp nextEventMatchingMask:NSAnyEventMask
 6272:                                          untilDate:waitUntil
 6272:                                             inMode:currentMode
 6272:                                            dequeue:YES];
 6272:           [NSApp sendEvent:nextEvent];
 6272:         } else {
 6272:           [currentRunLoop runMode:currentMode beforeDate:waitUntil];
 6272:         }
    1:         eventProcessed = PR_TRUE;
    1:       }
 6111:     }
    1:   } while (mRunningEventLoop);
    1: 
 6111:   if (eventProcessed && (mHadMoreEventsCount < kHadMoreEventsCountMax)) {
 6111:     moreEvents = ([NSApp nextEventMatchingMask:NSAnyEventMask
 6111:                                      untilDate:nil
 6111:                                         inMode:currentMode
 6111:                                        dequeue:NO] != nil);
 6111:   }
 6111: 
 6111:   if (moreEvents) {
 6111:     // Once this reaches kHadMoreEventsCountMax, it will be reset to 0 the
 6111:     // next time through (whether or not we process any events then).
 6111:     ++mHadMoreEventsCount;
 6111:   } else {
 6111:     mHadMoreEventsCount = 0;
 6111:   }
 6111: 
    1:   mRunningEventLoop = wasRunningEventLoop;
    1: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK;
11690: 
27993:   if (!moreEvents) {
27993:     nsChildView::UpdateCurrentInputEventCount();
27993:   }
27993: 
 6111:   return moreEvents;
    1: }
    1: 
 6349: // Returns PR_TRUE if Gecko events are currently being processed in its "main"
 6349: // event loop (or one of its "main" event loops).  Returns PR_FALSE if Gecko
 6349: // events are being processed in a "nested" event loop, or if we're not
 6349: // running in any sort of Gecko event loop.  How we process native events in
 6349: // ProcessNextNativeEvent() turns on our decision (and if we make the wrong
 6349: // choice, the result may be a hang).
 6349: //
 6349: // We define the "main" event loop(s) as the place (or places) where Gecko
 6349: // event processing "normally" takes place, and all other Gecko event loops
 6349: // as "nested".  The "nested" event loops are normally processed while a call
 6349: // from a "main" event loop is on the stack ... but not always.  For example,
 6349: // the Venkman JavaScript debugger runs a "nested" event loop (in jsdService::
 6349: // EnterNestedEventLoop()) whenever it breaks into the current script.  But
 6349: // if this happens as the result of the user pressing a key combination, there
 6349: // won't be any other Gecko event-processing call on the stack (e.g.
 6349: // NS_ProcessNextEvent() or NS_ProcessPendingEvents()).  (In the current
 6349: // nsAppShell implementation, what counts as the "main" event loop is what
 6349: // nsBaseAppShell::NativeEventCallback() does to process Gecko events.  We
 6349: // don't currently use nsBaseAppShell::Run().)
 6349: PRBool
 6349: nsAppShell::InGeckoMainEventLoop()
 6349: {
 6349:   if ((gXULModalLevel > 0) || (mRecursionDepth > 0))
 6349:     return PR_FALSE;
 6349:   if (mNativeEventCallbackDepth <= 0)
 6349:     return PR_FALSE;
 6349:   return PR_TRUE;
 6349: }
 6349: 
    1: // Run
    1: //
 6111: // Overrides the base class's Run() method to call [NSApp run] (which spins
 6111: // the native run loop until the application quits).  Since (unlike the base
 6111: // class's Run() method) we don't process any Gecko events here, they need
 6111: // to be processed elsewhere (in NativeEventCallback(), called from
 6111: // ProcessGeckoEvents()).
    1: //
 6111: // Camino calls [NSApp run] on its own (via NSApplicationMain()), and so
 6111: // doesn't call nsAppShell::Run().
    1: //
    1: // public
    1: NS_IMETHODIMP
    1: nsAppShell::Run(void)
    1: {
 6111:   NS_ASSERTION(!mStarted, "nsAppShell::Run() called multiple times");
 6111:   if (mStarted)
 6111:     return NS_OK;
 6111: 
 6111:   mStarted = PR_TRUE;
11690:   NS_OBJC_TRY_ABORT([NSApp run]);
 6111: 
 6111:   return NS_OK;
    1: }
    1: 
 6111: NS_IMETHODIMP
 6111: nsAppShell::Exit(void)
 6111: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11690: 
 6111:   // This method is currently called more than once -- from (according to
 6111:   // mento) an nsAppExitEvent dispatched by nsAppStartup::Quit() and from an
 6111:   // XPCOM shutdown notification that nsBaseAppShell has registered to
 6111:   // receive.  So we need to ensure that multiple calls won't break anything.
 6111:   // But we should also complain about it (since it isn't quite kosher).
 6226:   if (mTerminated) {
 6226:     NS_WARNING("nsAppShell::Exit() called redundantly");
 6111:     return NS_OK;
 6226:   }
 6111: 
 6111:   mTerminated = PR_TRUE;
 6111: 
20595:   delete gCocoaAppModalWindowList;
20595:   gCocoaAppModalWindowList = NULL;
20595: 
33318: #ifndef NP_NO_CARBON
15585:   NS_RemovePluginKeyEventsHandler();
33318: #endif
15585: 
 6111:   // Quoting from Apple's doc on the [NSApplication stop:] method (from their
 6111:   // doc on the NSApplication class):  "If this method is invoked during a
 6111:   // modal event loop, it will break that loop but not the main event loop."
 6111:   // nsAppShell::Exit() shouldn't be called from a modal event loop.  So if
 6111:   // it is we complain about it (to users of debug builds) and call [NSApp
 6111:   // stop:] one extra time.  (I'm not sure if modal event loops can be nested
 6111:   // -- Apple's docs don't say one way or the other.  But the return value
 6111:   // of [NSApp _isRunningModal] doesn't change immediately after a call to
 6111:   // [NSApp stop:], so we have to assume that one extra call to [NSApp stop:]
 6111:   // will do the job.)
 6111:   BOOL cocoaModal = [NSApp _isRunningModal];
 6111:   NS_ASSERTION(!cocoaModal,
 6111:                "Don't call nsAppShell::Exit() from a modal event loop!");
 6111:   if (cocoaModal)
 6111:     [NSApp stop:nsnull];
 6111:   [NSApp stop:nsnull];
 6111: 
29293:   // A call to Exit() just after a call to ScheduleNativeEventCallback()
29293:   // prevents the (normally) matching call to ProcessGeckoEvents() from
29293:   // happening.  If we've been called from ProcessGeckoEvents() (as usually
29293:   // happens), we take care of it there.  But if we have an unbalanced call
29293:   // to ScheduleNativeEventCallback() and ProcessGeckoEvents() isn't on the
29293:   // stack, we need to take care of the problem here.
29293:   if (!mNativeEventCallbackDepth && mNativeEventScheduledDepth) {
29293:     PRInt32 releaseCount = PR_AtomicSet(&mNativeEventScheduledDepth, 0);
29293:     while (releaseCount-- > 0)
29293:       NS_RELEASE_THIS();
29293:   }
29293: 
 6111:   return nsBaseAppShell::Exit();
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: // OnProcessNextEvent
    1: //
    1: // This nsIThreadObserver method is called prior to processing an event.
    1: // Set up an autorelease pool that will service any autoreleased Cocoa
    1: // objects during this event.  This includes native events processed by
    1: // ProcessNextNativeEvent.  The autorelease pool will be popped by
    1: // AfterProcessNextEvent, it is important for these two methods to be
    1: // tightly coupled.
    1: //
    1: // public
    1: NS_IMETHODIMP
    1: nsAppShell::OnProcessNextEvent(nsIThreadInternal *aThread, PRBool aMayWait,
    1:                                PRUint32 aRecursionDepth)
    1: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11690: 
 6349:   mRecursionDepth = aRecursionDepth;
 6349: 
    1:   NS_ASSERTION(mAutoreleasePools,
    1:                "No stack on which to store autorelease pool");
    1: 
    1:   NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
    1:   ::CFArrayAppendValue(mAutoreleasePools, pool);
    1: 
    1:   return nsBaseAppShell::OnProcessNextEvent(aThread, aMayWait, aRecursionDepth);
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: // AfterProcessNextEvent
    1: //
    1: // This nsIThreadObserver method is called after event processing is complete.
    1: // The Cocoa implementation cleans up the autorelease pool create by the
    1: // previous OnProcessNextEvent call.
    1: //
    1: // public
    1: NS_IMETHODIMP
    1: nsAppShell::AfterProcessNextEvent(nsIThreadInternal *aThread,
    1:                                   PRUint32 aRecursionDepth)
    1: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11690: 
 6349:   mRecursionDepth = aRecursionDepth;
 6349: 
    1:   CFIndex count = ::CFArrayGetCount(mAutoreleasePools);
    1: 
    1:   NS_ASSERTION(mAutoreleasePools && count,
    1:                "Processed an event, but there's no autorelease pool?");
    1: 
 6375:   const NSAutoreleasePool* pool = static_cast<const NSAutoreleasePool*>
 6375:     (::CFArrayGetValueAtIndex(mAutoreleasePools, count - 1));
    1:   ::CFArrayRemoveValueAtIndex(mAutoreleasePools, count - 1);
    1:   [pool release];
    1: 
    1:   return nsBaseAppShell::AfterProcessNextEvent(aThread, aRecursionDepth);
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
13608: 
    1: // AppShellDelegate implementation
    1: 
13608: 
    1: @implementation AppShellDelegate
    1: // initWithAppShell:
    1: //
    1: // Constructs the AppShellDelegate object
    1: - (id)initWithAppShell:(nsAppShell*)aAppShell
    1: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11690: 
    1:   if ((self = [self init])) {
    1:     mAppShell = aAppShell;
    1: 
    1:     [[NSNotificationCenter defaultCenter] addObserver:self
    1:                                              selector:@selector(applicationWillTerminate:)
    1:                                                  name:NSApplicationWillTerminateNotification
    1:                                                object:NSApp];
22847:     [[NSNotificationCenter defaultCenter] addObserver:self
22847:                                              selector:@selector(applicationDidBecomeActive:)
22847:                                                  name:NSApplicationDidBecomeActiveNotification
22847:                                                object:NSApp];
 3574:     [[NSDistributedNotificationCenter defaultCenter] addObserver:self
 3574:                                                         selector:@selector(beginMenuTracking:)
 3574:                                                             name:@"com.apple.HIToolbox.beginMenuTrackingNotification"
 3574:                                                           object:nil];
    1:   }
    1: 
    1:   return self;
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
    1: - (void)dealloc
    1: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11690: 
    1:   [[NSNotificationCenter defaultCenter] removeObserver:self];
 3574:   [[NSDistributedNotificationCenter defaultCenter] removeObserver:self];
    1:   [super dealloc];
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: // applicationWillTerminate:
    1: //
    1: // Notify the nsAppShell that native event processing should be discontinued.
    1: - (void)applicationWillTerminate:(NSNotification*)aNotification
    1: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11690: 
    1:   mAppShell->WillTerminate();
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
 3574: 
22847: // applicationDidBecomeActive
22847: //
22847: // Make sure gLastModifierState is updated when we become active (since we
22847: // won't have received [ChildView flagsChanged:] messages while inactive).
22847: - (void)applicationDidBecomeActive:(NSNotification*)aNotification
22847: {
22847:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
22847: 
22847:   // [NSEvent modifierFlags] is valid on every kind of event, so we don't need
22847:   // to worry about getting an NSInternalInconsistencyException here.
22847:   NSEvent* currentEvent = [NSApp currentEvent];
22847:   if (currentEvent) {
38441:     gLastModifierState = [currentEvent modifierFlags] & NSDeviceIndependentModifierFlagsMask;
22847:   }
22847: 
22847:   NS_OBJC_END_TRY_ABORT_BLOCK;
22847: }
22847: 
 3574: // beginMenuTracking
 3574: //
 3574: // Roll up our context menu (if any) when some other app (or the OS) opens
 3574: // any sort of menu.  But make sure we don't do this for notifications we
 3574: // send ourselves (whose 'sender' will be @"org.mozilla.gecko.PopupWindow").
 3574: - (void)beginMenuTracking:(NSNotification*)aNotification
 3574: {
11690:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11690: 
 3574:   NSString *sender = [aNotification object];
 3574:   if (!sender || ![sender isEqualToString:@"org.mozilla.gecko.PopupWindow"]) {
 3574:     if (gRollupListener && gRollupWidget)
29148:       gRollupListener->Rollup(nsnull, nsnull);
 3574:   }
11690: 
11690:   NS_OBJC_END_TRY_ABORT_BLOCK;
 3574: }
 3574: 
    1: @end
20595: 
55879: // We hook beginModalSessionForWindow: and endModalSession: in order to
55879: // maintain a list of Cocoa app-modal windows (and the "sessions" to which
55879: // they correspond).  We need this in order to deal with the consequences
55879: // of a Cocoa app-modal dialog being "interrupted" by a Gecko-modal dialog.
55879: // See nsCocoaAppModalWindowList::CurrentSession() and
55879: // nsAppShell::ProcessNextNativeEvent() above.
55879: //
55879: // We hook terminate: in order to make OS-initiated termination work nicely
55879: // with Gecko's shutdown sequence.  (Two ways to trigger OS-initiated
55879: // termination:  1) Quit from the Dock menu; 2) Log out from (or shut down)
55879: // your computer while the browser is active.)
20595: @interface NSApplication (MethodSwizzling)
20595: - (NSModalSession)nsAppShell_NSApplication_beginModalSessionForWindow:(NSWindow *)aWindow;
20595: - (void)nsAppShell_NSApplication_endModalSession:(NSModalSession)aSession;
55964: - (void)nsAppShell_NSApplication_terminate:(id)sender;
20595: @end
20595: 
20595: @implementation NSApplication (MethodSwizzling)
20595: 
20595: // Called if and only if a Cocoa app-modal session is beginning.  Always call
26321: // gCocoaAppModalWindowList->PushCocoa() here (if gCocoaAppModalWindowList is
20595: // non-nil).
20595: - (NSModalSession)nsAppShell_NSApplication_beginModalSessionForWindow:(NSWindow *)aWindow
20595: {
20595:   NSModalSession session =
20595:     [self nsAppShell_NSApplication_beginModalSessionForWindow:aWindow];
20595:   if (gCocoaAppModalWindowList)
26321:     gCocoaAppModalWindowList->PushCocoa(aWindow, session);
20595:   return session;
20595: }
20595: 
20595: // Called to end any Cocoa modal session (app-modal or otherwise).  Only call
26321: // gCocoaAppModalWindowList->PopCocoa() when an app-modal session is ending
26321: // (and when gCocoaAppModalWindowList is non-nil).
20595: - (void)nsAppShell_NSApplication_endModalSession:(NSModalSession)aSession
20595: {
20595:   BOOL wasRunningAppModal = [NSApp _isRunningAppModal];
20595:   NSWindow *prevAppModalWindow = [NSApp modalWindow];
20595:   [self nsAppShell_NSApplication_endModalSession:aSession];
20595:   if (gCocoaAppModalWindowList &&
20595:       wasRunningAppModal && (prevAppModalWindow != [NSApp modalWindow]))
26321:     gCocoaAppModalWindowList->PopCocoa(prevAppModalWindow, aSession);
20595: }
20595: 
55879: // Called by the OS after [MacApplicationDelegate applicationShouldTerminate:]
55879: // has returned NSTerminateNow.  This method "subclasses" and replaces the
55879: // OS's original implementation.  The only thing the orginal method does which
55879: // we need is that it posts NSApplicationWillTerminateNotification.  Everything
55879: // else is unneeded (because it's handled elsewhere), or actively interferes
55879: // with Gecko's shutdown sequence.  For example the original terminate: method
55879: // causes the app to exit() inside [NSApp run] (called from nsAppShell::Run()
55879: // above), which means that nothing runs after the call to nsAppStartup::Run()
55879: // in XRE_Main(), which in particular means that ScopedXPCOMStartup's destructor
55879: // and NS_ShutdownXPCOM() never get called.
55964: - (void)nsAppShell_NSApplication_terminate:(id)sender
55879: {
55879:   [[NSNotificationCenter defaultCenter] postNotificationName:NSApplicationWillTerminateNotification
55879:                                                       object:NSApp];
55879: }
55879: 
20595: @end
36292: 
36476: @interface NSObject (PDEPluginCallbackMethodSwizzling)
36476: - (id)nsAppShell_PDEPluginCallback_initWithPrintWindowController:(id)controller;
36292: - (void)nsAppShell_PDEPluginCallback_dealloc;
36292: @end
36292: 
36476: @implementation NSObject (PDEPluginCallbackMethodSwizzling)
36292: 
36292: // On Leopard, the PDEPluginCallback class in Apple's PrintCocoaUI module
36292: // fails to retain and release its PMPrintWindowController object.  This
36292: // causes the PMPrintWindowController to sometimes be deleted prematurely,
36292: // leading to crashes on attempts to access it.  One example is bug 396680,
36292: // caused by attempting to call a deleted PMPrintWindowController object's
36292: // printSettings method.  We work around the problem by hooking the
36292: // appropriate methods and retaining and releasing the object ourselves.
36292: // PrintCocoaUI.bundle is a "plugin" of the Carbon framework's Print
36292: // framework.
36292: 
36476: - (id)nsAppShell_PDEPluginCallback_initWithPrintWindowController:(id)controller
36292: {
36292:   return [self nsAppShell_PDEPluginCallback_initWithPrintWindowController:[controller retain]];
36292: }
36292: 
36292: - (void)nsAppShell_PDEPluginCallback_dealloc
36292: {
36476:   // Since the PDEPluginCallback class is undocumented (and the OS header
36476:   // files have no definition for it), we need to use low-level methods to
36476:   // access its _printWindowController variable.  (object_getInstanceVariable()
36476:   // is also available in Objective-C 2.0, so this code is 64-bit safe.)
36476:   id _printWindowController = nil;
36476:   object_getInstanceVariable(self, "_printWindowController",
36476:                              (void **) &_printWindowController);
36476:   [_printWindowController release];
36292:   [self nsAppShell_PDEPluginCallback_dealloc];
36292: }
36292: 
36292: @end
