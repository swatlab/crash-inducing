    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
22821:  *   Thomas K. Dyas <tdyas@zecador.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsChildView_h_
    1: #define nsChildView_h_
    1: 
    1: // formal protocols
    1: #include "mozView.h"
    1: #ifdef ACCESSIBILITY
42313: #include "nsAccessible.h"
    1: #include "mozAccessibleProtocol.h"
    1: #endif
    1: 
    1: #include "nsAutoPtr.h"
    1: #include "nsISupports.h"
    1: #include "nsBaseWidget.h"
14641: #include "nsIPluginInstanceOwner.h"
    1: #include "nsIPluginWidget.h"
    1: #include "nsWeakPtr.h"
33316: #include "nsCocoaTextInputHandler.h"
33316: #include "nsCocoaUtils.h"
    1: 
    1: #include "nsIAppShell.h"
    1: 
    1: #include "nsString.h"
    1: #include "nsIDragService.h"
    1: 
32120: #include "npapi.h"
  384: 
  384: #import <Carbon/Carbon.h>
  384: #import <Cocoa/Cocoa.h>
41434: #import <AppKit/NSOpenGL.h>
    1: 
    1: class gfxASurface;
  384: class nsChildView;
31534: class nsCocoaWindow;
  130: union nsPluginPort;
    1: 
62871: namespace mozilla {
62871: namespace gl {
62871: class TextureImage;
62871: }
62871: }
62871: 
39656: #ifndef NP_NO_CARBON
15585: enum {
15585:   // Currently focused ChildView (while this TSM document is active).
15585:   // Transient (only set while TSMProcessRawKeyEvent() is processing a key
15585:   // event), and the ChildView will be retained and released around the call
15585:   // to TSMProcessRawKeyEvent() -- so it can be weak.
15585:   kFocusedChildViewTSMDocPropertyTag  = 'GKFV', // type ChildView* [WEAK]
15585: };
15585: 
15585: // Undocumented HIToolbox function used by WebKit to allow Carbon-based IME
15585: // to work in a Cocoa-based browser (like Safari or Cocoa-widgets Firefox).
15585: // (Recent WebKit versions actually use a thin wrapper around this function
15585: // called WKSendKeyEventToTSM().)
15585: //
15585: // Calling TSMProcessRawKeyEvent() from ChildView's keyDown: and keyUp:
15585: // methods (when the ChildView is a plugin view) bypasses Cocoa's IME
15585: // infrastructure and (instead) causes Carbon TSM events to be sent on each
15585: // NSKeyDown event.  We install a Carbon event handler
15585: // (PluginKeyEventsHandler()) to catch these events and pass them to Gecko
15585: // (which in turn passes them to the plugin).
15585: extern "C" long TSMProcessRawKeyEvent(EventRef carbonEvent);
39656: #endif // NP_NO_CARBON
15585: 
15585: @interface NSEvent (Undocumented)
15585: 
15585: // Return Cocoa event's corresponding Carbon event.  Not initialized (on
15585: // synthetic events) until the OS actually "sends" the event.  This method
15585: // has been present in the same form since at least OS X 10.2.8.
15585: - (EventRef)_eventRef;
15585: 
15585: @end
15585: 
19319: // Support for pixel scroll deltas, not part of NSEvent.h
19319: // See http://lists.apple.com/archives/cocoa-dev/2007/Feb/msg00050.html
19319: @interface NSEvent (DeviceDelta)
41072:   - (CGFloat)deviceDeltaX;
41072:   - (CGFloat)deviceDeltaY;
19319: @end
19319: 
57004: // Undocumented scrollPhase flag that lets us discern between real scrolls and
57004: // automatically firing momentum scroll events.
57004: @interface NSEvent (ScrollPhase)
57004: - (long long)_scrollPhase;
57004: @end
57004: 
    1: @interface ChildView : NSView<
    1: #ifdef ACCESSIBILITY
    1:                               mozAccessible,
    1: #endif
    1:                               mozView, NSTextInput>
    1: {
    1: @private
    1:   // the nsChildView that created the view. It retains this NSView, so
    1:   // the link back to it must be weak.
    1:   nsChildView* mGeckoChild;
    1: 
    1:   BOOL mIsPluginView;
32120:   NPEventModel mPluginEventModel;
54248:   NPDrawingModel mPluginDrawingModel;
    1: 
12429:   // The following variables are only valid during key down event processing.
12429:   // Their current usage needs to be fixed to avoid problems with nested event
12429:   // loops that can confuse them. Once a variable is set during key down event
12429:   // processing, if an event spawns a nested event loop the previously set value
12429:   // will be wiped out.
12429:   NSEvent* mCurKeyEvent;
 8339:   PRBool mKeyDownHandled;
12429:   // While we process key down events we need to keep track of whether or not
12429:   // we sent a key press event. This helps us make sure we do send one
12429:   // eventually.
12429:   BOOL mKeyPressSent;
13042:   // Valid when mKeyPressSent is true.
13042:   PRBool mKeyPressHandled;
    1: 
    1:   // needed for NSTextInput implementation
    1:   NSRange mMarkedRange;
    1:   
13976:   // when mouseDown: is called, we store its event here (strong)
13976:   NSEvent* mLastMouseDownEvent;
    1: 
47792:   // Whether the last mouse down event was blocked from Gecko.
47792:   BOOL mBlockedLastMouseDown;
47792: 
47792:   // when acceptsFirstMouse: is called, we store the event here (strong)
47792:   NSEvent* mClickThroughMouseDownEvent;
47792: 
    1:   // rects that were invalidated during a draw, so have pending drawing
    1:   NSMutableArray* mPendingDirtyRects;
    1:   BOOL mPendingFullDisplay;
43368:   BOOL mPendingDisplay;
    1: 
    1:   // Holds our drag service across multiple drag calls. The reference to the
    1:   // service is obtained when the mouse enters the view and is released when
    1:   // the mouse exits or there is a drop. This prevents us from having to
    1:   // re-establish the connection to the service manager many times per second
    1:   // when handling |draggingUpdated:| messages.
    1:   nsIDragService* mDragService;
    1: 
39656: #ifndef NP_NO_CARBON
15585:   // For use with plugins, so that we can support IME in them.  We can't use
15585:   // Cocoa TSM documents (those created and managed by the NSTSMInputContext
15585:   // class) -- for some reason TSMProcessRawKeyEvent() doesn't work with them.
15585:   TSMDocumentID mPluginTSMDoc;
61078:   BOOL mPluginTSMInComposition;
39656: #endif
43436:   BOOL mPluginComplexTextInputRequested;
20793: 
61078:   // When this is YES the next key up event (keyUp:) will be ignored.
61078:   BOOL mIgnoreNextKeyUpEvent;
61078: 
43776:   NSOpenGLContext *mGLContext;
41434: 
20793:   // Simple gestures support
20793:   //
20793:   // mGestureState is used to detect when Cocoa has called both
20793:   // magnifyWithEvent and rotateWithEvent within the same
20793:   // beginGestureWithEvent and endGestureWithEvent sequence. We
20793:   // discard the spurious gesture event so as not to confuse Gecko.
20793:   //
20793:   // mCumulativeMagnification keeps track of the total amount of
20793:   // magnification peformed during a magnify gesture so that we can
20793:   // send that value with the final MozMagnifyGesture event.
20793:   //
20793:   // mCumulativeRotation keeps track of the total amount of rotation
20793:   // performed during a rotate gesture so we can send that value with
20793:   // the final MozRotateGesture event.
20793:   enum {
20793:     eGestureState_None,
20793:     eGestureState_StartGesture,
20793:     eGestureState_MagnifyGesture,
20793:     eGestureState_RotateGesture
20793:   } mGestureState;
20793:   float mCumulativeMagnification;
20793:   float mCumulativeRotation;
61878: 
61878:   BOOL mDidForceRefreshOpenGL;
    1: }
    1: 
22821: // class initialization
22821: + (void)initialize;
22821: 
    1: // these are sent to the first responder when the window key status changes
    1: - (void)viewsWindowDidBecomeKey;
    1: - (void)viewsWindowDidResignKey;
 2000: 
 2000: // Stop NSView hierarchy being changed during [ChildView drawRect:]
 2000: - (void)delayedTearDown;
10367: 
10367: - (void)sendFocusEvent:(PRUint32)eventType;
15585: 
32976: - (void)handleMouseMoved:(NSEvent*)aEvent;
32976: 
55858: - (void)drawRect:(NSRect)aRect inTitlebarContext:(CGContextRef)aContext;
34054: 
32976: - (void)sendMouseEnterOrExitEvent:(NSEvent*)aEvent
32976:                             enter:(BOOL)aEnter
32976:                              type:(nsMouseEvent::exitType)aType;
32976: 
33318: #ifndef NP_NO_CARBON
15585: - (void) processPluginKeyEvent:(EventRef)aKeyEvent;
33318: #endif
43436: - (void)pluginRequestsComplexTextInputForCurrentEvent;
20793: 
41434: - (void)update;
41434: - (void)lockFocus;
41434: - (void) _surfaceNeedsUpdate:(NSNotification*)notification;
41434: 
50708: - (BOOL)isPluginView;
50708: 
57526: // Are we processing an NSLeftMouseDown event that will fail to click through?
57526: // If so, we shouldn't focus or unfocus a plugin.
57526: - (BOOL)isInFailingLeftClickThrough;
57526: 
20793: // Simple gestures support
20793: //
20793: // XXX - The swipeWithEvent, beginGestureWithEvent, magnifyWithEvent,
20793: // rotateWithEvent, and endGestureWithEvent methods are part of a
20793: // PRIVATE interface exported by nsResponder and reverse-engineering
20793: // was necessary to obtain the methods' prototypes. Thus, Apple may
20793: // change the interface in the future without notice.
20793: //
20793: // The prototypes were obtained from the following link:
20793: // http://cocoadex.com/2008/02/nsevent-modifications-swipe-ro.html
20793: - (void)swipeWithEvent:(NSEvent *)anEvent;
20793: - (void)beginGestureWithEvent:(NSEvent *)anEvent;
20793: - (void)magnifyWithEvent:(NSEvent *)anEvent;
20793: - (void)rotateWithEvent:(NSEvent *)anEvent;
20793: - (void)endGestureWithEvent:(NSEvent *)anEvent;
    1: @end
    1: 
32976: class ChildViewMouseTracker {
32976: 
32976: public:
32976: 
32976:   static void MouseMoved(NSEvent* aEvent);
32976:   static void OnDestroyView(ChildView* aView);
47792:   static BOOL WindowAcceptsEvent(NSWindow* aWindow, NSEvent* aEvent,
47792:                                  ChildView* aView, BOOL isClickThrough = NO);
35621:   static void ReEvaluateMouseEnterState(NSEvent* aEvent = nil);
37413:   static ChildView* ViewForEvent(NSEvent* aEvent);
32976: 
32976:   static ChildView* sLastMouseEventView;
32976: 
32976: private:
32976: 
32976:   static NSWindow* WindowForEvent(NSEvent* aEvent);
32976: };
32976: 
  539: //-------------------------------------------------------------------------
  539: //
    1: // nsChildView
    1: //
    1: //-------------------------------------------------------------------------
    1: 
    1: class nsChildView : public nsBaseWidget,
15919:                     public nsIPluginWidget
    1: {
    1: private:
    1:   typedef nsBaseWidget Inherited;
    1: 
    1: public:
    1:                           nsChildView();
    1:   virtual                 ~nsChildView();
    1:   
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   // nsIWidget interface
    1:   NS_IMETHOD              Create(nsIWidget *aParent,
33013:                                  nsNativeWidget aNativeParent,
23738:                                  const nsIntRect &aRect,
    1:                                  EVENT_CALLBACK aHandleEventFunction,
    1:                                  nsIDeviceContext *aContext,
    1:                                  nsIAppShell *aAppShell = nsnull,
    1:                                  nsIToolkit *aToolkit = nsnull,
    1:                                  nsWidgetInitData *aInitData = nsnull);
    1: 
    1:   NS_IMETHOD              Destroy();
    1: 
    1:   NS_IMETHOD              Show(PRBool aState);
    1:   NS_IMETHOD              IsVisible(PRBool& outState);
    1: 
21041:   NS_IMETHOD              SetParent(nsIWidget* aNewParent);
    1:   virtual nsIWidget*      GetParent(void);
50783:   virtual float           GetDPI();
    1: 
    1:   NS_IMETHOD              ConstrainPosition(PRBool aAllowSlop,
    1:                                             PRInt32 *aX, PRInt32 *aY);
    1:   NS_IMETHOD              Move(PRInt32 aX, PRInt32 aY);
    1:   NS_IMETHOD              Resize(PRInt32 aWidth,PRInt32 aHeight, PRBool aRepaint);
    1:   NS_IMETHOD              Resize(PRInt32 aX, PRInt32 aY,PRInt32 aWidth,PRInt32 aHeight, PRBool aRepaint);
    1: 
    1:   NS_IMETHOD              Enable(PRBool aState);
    1:   NS_IMETHOD              IsEnabled(PRBool *aState);
    1:   NS_IMETHOD              SetFocus(PRBool aRaise);
23738:   NS_IMETHOD              GetBounds(nsIntRect &aRect);
    1: 
23738:   NS_IMETHOD              Invalidate(const nsIntRect &aRect, PRBool aIsSynchronous);
    1: 
    1:   virtual void*           GetNativeData(PRUint32 aDataType);
30515:   virtual nsresult        ConfigureChildren(const nsTArray<Configuration>& aConfigurations);
25183:   virtual nsIntPoint      WidgetToScreenOffset();
16520:   virtual PRBool          ShowsResizeIndicator(nsIntRect* aResizerRect);
    1: 
    1:   static  PRBool          ConvertStatus(nsEventStatus aStatus)
    1:                           { return aStatus == nsEventStatus_eConsumeNoDefault; }
    1:   NS_IMETHOD              DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus);
    1: 
    1:   NS_IMETHOD              Update();
54780:   virtual PRBool          GetShouldAccelerate();
    1: 
    1:   NS_IMETHOD        SetCursor(nsCursor aCursor);
    1:   NS_IMETHOD        SetCursor(imgIContainer* aCursor, PRUint32 aHotspotX, PRUint32 aHotspotY);
    1:   
36806:   NS_IMETHOD        CaptureRollupEvents(nsIRollupListener * aListener, nsIMenuRollup * aMenuRollup, 
36806:                                         PRBool aDoCapture, PRBool aConsumeRollupEvent);
    1:   NS_IMETHOD        SetTitle(const nsAString& title);
    1: 
    1:   NS_IMETHOD        GetAttention(PRInt32 aCycleCount);
    1: 
27993:   virtual PRBool HasPendingInputEvent();
27993: 
15578:   NS_IMETHOD        ActivateNativeMenuItemAt(const nsAString& indexString);
21081:   NS_IMETHOD        ForceUpdateNativeMenuAt(const nsAString& indexString);
15578: 
15919:   NS_IMETHOD        ResetInputState();
15919:   NS_IMETHOD        SetIMEOpenState(PRBool aState);
15919:   NS_IMETHOD        GetIMEOpenState(PRBool* aState);
58017:   NS_IMETHOD        SetInputMode(const IMEContext& aContext);
58019:   NS_IMETHOD        GetInputMode(IMEContext& aContext);
15919:   NS_IMETHOD        CancelIMEComposition();
15919:   NS_IMETHOD        GetToggledKeyState(PRUint32 aKeyCode,
15919:                                        PRBool* aLEDState);
33316:   NS_IMETHOD        OnIMEFocusChange(PRBool aFocus);
15919: 
    1:   // nsIPluginWidget
23738:   NS_IMETHOD        GetPluginClipRect(nsIntRect& outClipRect, nsIntPoint& outOrigin, PRBool& outWidgetVisible);
    1:   NS_IMETHOD        StartDrawPlugin();
    1:   NS_IMETHOD        EndDrawPlugin();
14641:   NS_IMETHOD        SetPluginInstanceOwner(nsIPluginInstanceOwner* aInstanceOwner);
    1: 
32019:   NS_IMETHOD        SetPluginEventModel(int inEventModel);
32019:   NS_IMETHOD        GetPluginEventModel(int* outEventModel);
54248:   NS_IMETHOD        SetPluginDrawingModel(int inDrawingModel);
32019: 
43436:   NS_IMETHOD        StartComplexTextInputForCurrentEvent();
43436: 
16601:   virtual nsTransparencyMode GetTransparencyMode();
16601:   virtual void                SetTransparencyMode(nsTransparencyMode aMode);
 9499: 
32976:   virtual nsresult SynthesizeNativeKeyEvent(PRInt32 aNativeKeyboardLayout,
32976:                                             PRInt32 aNativeKeyCode,
32976:                                             PRUint32 aModifierFlags,
32976:                                             const nsAString& aCharacters,
32976:                                             const nsAString& aUnmodifiedCharacters);
32976: 
32976:   virtual nsresult SynthesizeNativeMouseEvent(nsIntPoint aPoint,
32976:                                               PRUint32 aNativeMessage,
32976:                                               PRUint32 aModifierFlags);
32976:   
    1:   // Mac specific methods
    1:   
    1:   virtual PRBool    DispatchWindowEvent(nsGUIEvent& event);
    1:   
    1: #ifdef ACCESSIBILITY
42313:   already_AddRefed<nsAccessible> GetDocumentAccessible();
    1: #endif
    1: 
    1:   virtual gfxASurface* GetThebesSurface();
60224:   virtual void DrawOver(LayerManager* aManager, nsIntRect aRect);
    1: 
60289:   virtual void UpdateThemeGeometries(const nsTArray<ThemeGeometry>& aThemeGeometries);
60289: 
 6348:   NS_IMETHOD BeginSecureKeyboardInput();
 6348:   NS_IMETHOD EndSecureKeyboardInput();
 6348: 
14641:   void              HidePlugin();
30549:   void              UpdatePluginPort();
14641: 
27679:   void              ResetParent();
27679: 
27993:   static PRBool DoHasPendingInputEvent();
27993:   static PRUint32 GetCurrentInputEventCount();
27993:   static void UpdateCurrentInputEventCount();
30515: 
33316:   nsCocoaTextInputHandler* TextInputHandler() { return &mTextInputHandler; }
33316:   NSView<mozView>* GetEditorView();
33316: 
52100:   PRBool IsPluginView() { return (mWindowType == eWindowType_plugin); }
52100: 
54249:   void PaintQD();
54249: 
57526:   nsCocoaWindow*    GetXULWindowWidget();
57526: 
54312:   NS_IMETHOD        ReparentNativeWidget(nsIWidget* aNewParent);
    1: protected:
    1: 
    1:   PRBool            ReportDestroyEvent();
    1:   PRBool            ReportMoveEvent();
    1:   PRBool            ReportSizeEvent();
    1: 
    1:   // override to create different kinds of child views. Autoreleases, so
    1:   // caller must retain.
    1:   virtual NSView*   CreateCocoaView(NSRect inFrame);
    1:   void              TearDownView();
    1: 
51050:   virtual already_AddRefed<nsIWidget>
51050:   AllocateChildPopupWidget()
51050:   {
51050:     static NS_DEFINE_IID(kCPopUpCID, NS_POPUP_CID);
51050:     nsCOMPtr<nsIWidget> widget = do_CreateInstance(kCPopUpCID);
51050:     return widget.forget();
51050:   }
51050: 
    1: protected:
    1: 
    1:   NSView<mozView>*      mView;      // my parallel cocoa view (ChildView or NativeScrollbarView), [STRONG]
33316:   nsCocoaTextInputHandler mTextInputHandler;
58019:   IMEContext            mIMEContext;
    1: 
    1:   NSView<mozView>*      mParentView;
    1:   nsIWidget*            mParentWidget;
    1: 
    1: #ifdef ACCESSIBILITY
    1:   // weak ref to this childview's associated mozAccessible for speed reasons 
    1:   // (we get queried for it *a lot* but don't want to own it)
    1:   nsWeakPtr             mAccessible;
    1: #endif
    1: 
    1:   nsRefPtr<gfxASurface> mTempThebesSurface;
62871:   nsRefPtr<mozilla::gl::TextureImage> mResizerImage;
    1: 
    1:   PRPackedBool          mVisible;
    1:   PRPackedBool          mDrawing;
    1:   PRPackedBool          mPluginDrawing;
50639:   PRPackedBool          mIsDispatchPaint; // Is a paint event being dispatched
    1: 
32799:   NP_CGContext          mPluginCGContext;
43647: #ifndef NP_NO_QUICKDRAW
32799:   NP_Port               mPluginQDPort;
43647: #endif
14641:   nsIPluginInstanceOwner* mPluginInstanceOwner; // [WEAK]
27993: 
27993:   static PRUint32 sLastInputEventCount;
    1: };
    1: 
15585: void NS_InstallPluginKeyEventsHandler();
15585: void NS_RemovePluginKeyEventsHandler();
    1: 
    1: #endif // nsChildView_h_
