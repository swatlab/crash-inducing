84016: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-
84016:  * ***** BEGIN LICENSE BLOCK *****
84016:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
84016:  *
84016:  * The contents of this file are subject to the Mozilla Public License Version
84016:  * 1.1 (the "License"); you may not use this file except in compliance with
84016:  * the License. You may obtain a copy of the License at
84016:  * http://www.mozilla.org/MPL/
84016:  *
84016:  * Software distributed under the License is distributed on an "AS IS" basis,
84016:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
84016:  * for the specific language governing rights and limitations under the
84016:  * License.
84016:  *
84016:  * The Original Code is Mozilla Android code.
84016:  *
84016:  * The Initial Developer of the Original Code is Mozilla Foundation.
84016:  * Portions created by the Initial Developer are Copyright (C) 2009-2010
84016:  * the Initial Developer. All Rights Reserved.
84016:  *
84016:  * Contributor(s):
84016:  *   Vladimir Vukicevic <vladimir@pobox.com>
84016:  *   Matt Brubeck <mbrubeck@mozilla.com>
84016:  *   Vivien Nicolas <vnicolas@mozilla.com>
84016:  *
84016:  * Alternatively, the contents of this file may be used under the terms of
84016:  * either the GNU General Public License Version 2 or later (the "GPL"), or
84016:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
84016:  * in which case the provisions of the GPL or the LGPL are applicable instead
84016:  * of those above. If you wish to allow use of your version of this file only
84016:  * under the terms of either the GPL or the LGPL, and not to allow others to
84016:  * use your version of this file under the terms of the MPL, indicate your
84016:  * decision by deleting the provisions above and replace them with the notice
84016:  * and other provisions required by the GPL or the LGPL. If you do not delete
84016:  * the provisions above, a recipient may use your version of this file under
84016:  * the terms of any one of the MPL, the GPL or the LGPL.
84016:  *
84016:  * ***** END LICENSE BLOCK ***** */
84016: 
84016: package org.mozilla.gecko;
84016: 
84016: import java.io.*;
84016: import java.util.*;
84016: import java.util.zip.*;
84016: import java.nio.*;
84016: import java.nio.channels.FileChannel;
84016: import java.util.concurrent.*;
84016: import java.lang.reflect.*;
84016: 
84016: import android.os.*;
84016: import android.app.*;
84016: import android.text.*;
84016: import android.view.*;
84016: import android.view.inputmethod.*;
84016: import android.content.*;
84016: import android.content.res.*;
84016: import android.graphics.*;
84016: import android.widget.*;
84016: import android.hardware.*;
84016: 
84016: import android.util.*;
84016: import android.net.*;
84016: import android.database.*;
84016: import android.provider.*;
84016: import android.content.pm.*;
84016: import android.content.pm.PackageManager.*;
84016: import dalvik.system.*;
84016: 
84016: abstract public class GeckoApp
84016:     extends Activity
84016: {
84016:     private static final String LOG_FILE_NAME     = "GeckoApp";
84016: 
84016:     public static final String ACTION_ALERT_CLICK = "org.mozilla.gecko.ACTION_ALERT_CLICK";
84016:     public static final String ACTION_ALERT_CLEAR = "org.mozilla.gecko.ACTION_ALERT_CLEAR";
84016:     public static final String ACTION_WEBAPP      = "org.mozilla.gecko.WEBAPP";
84016:     public static final String ACTION_DEBUG       = "org.mozilla.gecko.DEBUG";
84016:     public static final String ACTION_BOOKMARK    = "org.mozilla.gecko.BOOKMARK";
84016: 
84016:     public static AbsoluteLayout mainLayout;
84016:     public static GeckoSurfaceView surfaceView;
84016:     public static SurfaceView cameraView;
84016:     public static GeckoApp mAppContext;
84016:     public static boolean mFullscreen = false;
84016:     public static File sGREDir = null;
84016:     static Thread mLibLoadThread = null;
84016:     public Handler mMainHandler;
84016:     private IntentFilter mConnectivityFilter;
84016:     private BroadcastReceiver mConnectivityReceiver;
84016:     private BroadcastReceiver mBatteryReceiver;
84016: 
84016:     enum LaunchState {PreLaunch, Launching, WaitForDebugger,
84016:                       Launched, GeckoRunning, GeckoExiting};
84016:     private static LaunchState sLaunchState = LaunchState.PreLaunch;
84016:     private static boolean sTryCatchAttached = false;
84016: 
84016: 
84016:     static boolean checkLaunchState(LaunchState checkState) {
84016:         synchronized(sLaunchState) {
84016:             return sLaunchState == checkState;
84016:         }
84016:     }
84016: 
84016:     static void setLaunchState(LaunchState setState) {
84016:         synchronized(sLaunchState) {
84016:             sLaunchState = setState;
84016:         }
84016:     }
84016: 
84016:     // if mLaunchState is equal to checkState this sets mLaunchState to setState
84016:     // and return true. Otherwise we return false.
84016:     static boolean checkAndSetLaunchState(LaunchState checkState, LaunchState setState) {
84016:         synchronized(sLaunchState) {
84016:             if (sLaunchState != checkState)
84016:                 return false;
84016:             sLaunchState = setState;
84016:             return true;
84016:         }
84016:     }
84016: 
84016:     void showErrorDialog(String message)
84016:     {
84016:         new AlertDialog.Builder(this)
84016:             .setMessage(message)
84016:             .setCancelable(false)
84016:             .setPositiveButton(R.string.exit_label,
84016:                                new DialogInterface.OnClickListener() {
84016:                                    public void onClick(DialogInterface dialog,
84016:                                                        int id)
84016:                                    {
84016:                                        GeckoApp.this.finish();
84016:                                        System.exit(0);
84016:                                    }
84016:                                }).show();
84016:     }
84016: 
84016:     public static final String PLUGIN_ACTION = "android.webkit.PLUGIN";
84016: 
84016:     /**
84016:      * A plugin that wish to be loaded in the WebView must provide this permission
84016:      * in their AndroidManifest.xml.
84016:      */
84016:     public static final String PLUGIN_PERMISSION = "android.webkit.permission.PLUGIN";
84016: 
84016:     private static final String LOGTAG = "PluginManager";
84016: 
84016:     private static final String PLUGIN_SYSTEM_LIB = "/system/lib/plugins/";
84016: 
84016:     private static final String PLUGIN_TYPE = "type";
84016:     private static final String TYPE_NATIVE = "native";
84016:     public ArrayList<PackageInfo> mPackageInfoCache = new ArrayList<PackageInfo>();
84016: 
84016:     String[] getPluginDirectories() {
84016: 
84016:         ArrayList<String> directories = new ArrayList<String>();
84016:         PackageManager pm = this.mAppContext.getPackageManager();
84016:         List<ResolveInfo> plugins = pm.queryIntentServices(new Intent(PLUGIN_ACTION),
84016:                 PackageManager.GET_SERVICES | PackageManager.GET_META_DATA);
84016: 
84016:         synchronized(mPackageInfoCache) {
84016: 
84016:             // clear the list of existing packageInfo objects
84016:             mPackageInfoCache.clear();
84016: 
84016: 
84016:             for (ResolveInfo info : plugins) {
84016: 
84016:                 // retrieve the plugin's service information
84016:                 ServiceInfo serviceInfo = info.serviceInfo;
84016:                 if (serviceInfo == null) {
84016:                     Log.w(LOGTAG, "Ignore bad plugin");
84016:                     continue;
84016:                 }
84016: 
84016:                 Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName);
84016: 
84016: 
84016:                 // retrieve information from the plugin's manifest
84016:                 PackageInfo pkgInfo;
84016:                 try {
84016:                     pkgInfo = pm.getPackageInfo(serviceInfo.packageName,
84016:                                     PackageManager.GET_PERMISSIONS
84016:                                     | PackageManager.GET_SIGNATURES);
84016:                 } catch (Exception e) {
84016:                     Log.w(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
84016:                     continue;
84016:                 }
84016:                 if (pkgInfo == null) {
84016:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Could not load package information.");
84016:                     continue;
84016:                 }
84016: 
84016:                 /*
84016:                  * find the location of the plugin's shared library. The default
84016:                  * is to assume the app is either a user installed app or an
84016:                  * updated system app. In both of these cases the library is
84016:                  * stored in the app's data directory.
84016:                  */
84016:                 String directory = pkgInfo.applicationInfo.dataDir + "/lib";
84016:                 final int appFlags = pkgInfo.applicationInfo.flags;
84016:                 final int updatedSystemFlags = ApplicationInfo.FLAG_SYSTEM |
84016:                                                ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
84016:                 // preloaded system app with no user updates
84016:                 if ((appFlags & updatedSystemFlags) == ApplicationInfo.FLAG_SYSTEM) {
84016:                     directory = PLUGIN_SYSTEM_LIB + pkgInfo.packageName;
84016:                 }
84016: 
84016:                 // check if the plugin has the required permissions
84016:                 String permissions[] = pkgInfo.requestedPermissions;
84016:                 if (permissions == null) {
84016:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Does not have required permission.");
84016:                     continue;
84016:                 }
84016:                 boolean permissionOk = false;
84016:                 for (String permit : permissions) {
84016:                     if (PLUGIN_PERMISSION.equals(permit)) {
84016:                         permissionOk = true;
84016:                         break;
84016:                     }
84016:                 }
84016:                 if (!permissionOk) {
84016:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Does not have required permission (2).");
84016:                     continue;
84016:                 }
84016: 
84016:                 // check to ensure the plugin is properly signed
84016:                 Signature signatures[] = pkgInfo.signatures;
84016:                 if (signatures == null) {
84016:                     Log.w(LOGTAG, "Loading plugin: " + serviceInfo.packageName + ". Not signed.");
84016:                     continue;
84016:                 }
84016: 
84016:                 // determine the type of plugin from the manifest
84016:                 if (serviceInfo.metaData == null) {
84016:                     Log.e(LOGTAG, "The plugin '" + serviceInfo.name + "' has no type defined");
84016:                     continue;
84016:                 }
84016: 
84016:                 String pluginType = serviceInfo.metaData.getString(PLUGIN_TYPE);
84016:                 if (!TYPE_NATIVE.equals(pluginType)) {
84016:                     Log.e(LOGTAG, "Unrecognized plugin type: " + pluginType);
84016:                     continue;
84016:                 }
84016: 
84016:                 try {
84016:                     Class<?> cls = getPluginClass(serviceInfo.packageName, serviceInfo.name);
84016: 
84016:                     //TODO implement any requirements of the plugin class here!
84016:                     boolean classFound = true;
84016: 
84016:                     if (!classFound) {
84016:                         Log.e(LOGTAG, "The plugin's class' " + serviceInfo.name + "' does not extend the appropriate class.");
84016:                         continue;
84016:                     }
84016: 
84016:                 } catch (NameNotFoundException e) {
84016:                     Log.e(LOGTAG, "Can't find plugin: " + serviceInfo.packageName);
84016:                     continue;
84016:                 } catch (ClassNotFoundException e) {
84016:                     Log.e(LOGTAG, "Can't find plugin's class: " + serviceInfo.name);
84016:                     continue;
84016:                 }
84016: 
84016:                 // if all checks have passed then make the plugin available
84016:                 mPackageInfoCache.add(pkgInfo);
84016:                 directories.add(directory);
84016:             }
84016:         }
84016: 
84016:         return directories.toArray(new String[directories.size()]);
84016:     }
84016: 
84016:     Class<?> getPluginClass(String packageName, String className)
84016:             throws NameNotFoundException, ClassNotFoundException {
84016:         Context pluginContext = this.mAppContext.createPackageContext(packageName,
84016:                 Context.CONTEXT_INCLUDE_CODE |
84016:                 Context.CONTEXT_IGNORE_SECURITY);
84016:         ClassLoader pluginCL = pluginContext.getClassLoader();
84016:         return pluginCL.loadClass(className);
84016:     }
84016: 
84016:     // Returns true when the intent is going to be handled by gecko launch
84016:     boolean launch(Intent intent)
84016:     {
84016:         if (!checkAndSetLaunchState(LaunchState.Launching, LaunchState.Launched))
84016:             return false;
84016: 
84016:         if (intent == null)
84016:             intent = getIntent();
84016:         final Intent i = intent;
84016:         new Thread() {
84016:             public void run() {
84016:                 try {
84016:                     if (mLibLoadThread != null)
84016:                         mLibLoadThread.join();
84016:                 } catch (InterruptedException ie) {}
84016: 
84016:                 // Show the URL we are about to load, if the intent has one
84016:                 if (Intent.ACTION_VIEW.equals(i.getAction())) {
84016:                     surfaceView.mSplashURL = i.getDataString();
84016:                 }
84016:                 surfaceView.drawSplashScreen();
84016: 
84016:                 // unpack files in the components directory
84016:                 try {
84016:                     unpackComponents();
84016:                 } catch (FileNotFoundException fnfe) {
84016:                     Log.e(LOG_FILE_NAME, "error unpacking components", fnfe);
84016:                     Looper.prepare();
84016:                     showErrorDialog(getString(R.string.error_loading_file));
84016:                     Looper.loop();
84016:                     return;
84016:                 } catch (IOException ie) {
84016:                     Log.e(LOG_FILE_NAME, "error unpacking components", ie);
84016:                     String msg = ie.getMessage();
84016:                     Looper.prepare();
84016:                     if (msg != null && msg.equalsIgnoreCase("No space left on device"))
84016:                         showErrorDialog(getString(R.string.no_space_to_start_error));
84016:                     else
84016:                         showErrorDialog(getString(R.string.error_loading_file));
84016:                     Looper.loop();
84016:                     return;
84016:                 }
84016: 
84016:                 // and then fire us up
84016:                 try {
84016:                     String env = i.getStringExtra("env0");
84016:                     GeckoAppShell.runGecko(getApplication().getPackageResourcePath(),
84016:                                            i.getStringExtra("args"),
84016:                                            i.getDataString());
84016:                 } catch (Exception e) {
84016:                     Log.e(LOG_FILE_NAME, "top level exception", e);
84016:                     StringWriter sw = new StringWriter();
84016:                     PrintWriter pw = new PrintWriter(sw);
84016:                     e.printStackTrace(pw);
84016:                     pw.flush();
84016:                     GeckoAppShell.reportJavaCrash(sw.toString());
84016:                 }
84016:             }
84016:         }.start();
84016:         return true;
84016:     }
84016: 
84016:     /** Called when the activity is first created. */
84016:     @Override
84016:     public void onCreate(Bundle savedInstanceState)
84016:     {
84016:         mAppContext = this;
84016:         mMainHandler = new Handler();
84016: 
84016:         if (!sTryCatchAttached) {
84016:             sTryCatchAttached = true;
84016:             mMainHandler.post(new Runnable() {
84016:                 public void run() {
84016:                     try {
84016:                         Looper.loop();
84016:                     } catch (Exception e) {
84016:                         Log.e(LOG_FILE_NAME, "top level exception", e);
84016:                         StringWriter sw = new StringWriter();
84016:                         PrintWriter pw = new PrintWriter(sw);
84016:                         e.printStackTrace(pw);
84016:                         pw.flush();
84016:                         GeckoAppShell.reportJavaCrash(sw.toString());
84016:                     }
84016:                     // resetting this is kinda pointless, but oh well
84016:                     sTryCatchAttached = false;
84016:                 }
84016:             });
84016:         }
84016: 
84016:         SharedPreferences settings = getPreferences(Activity.MODE_PRIVATE);
84016:         String localeCode = settings.getString(getPackageName() + ".locale", "");
84016:         if (localeCode != null && localeCode.length() > 0)
84016:             GeckoAppShell.setSelectedLocale(localeCode);
84016: 
84016:         Log.i(LOG_FILE_NAME, "create");
84016:         super.onCreate(savedInstanceState);
84016: 
84016:         if (sGREDir == null)
84016:             sGREDir = new File(this.getApplicationInfo().dataDir);
84016: 
84016:         getWindow().setFlags(mFullscreen ?
84016:                              WindowManager.LayoutParams.FLAG_FULLSCREEN : 0,
84016:                              WindowManager.LayoutParams.FLAG_FULLSCREEN);
84016: 
84016:         if (cameraView == null) {
84016:             cameraView = new SurfaceView(this);
84016:             cameraView.getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
84016:         }
84016: 
84016:         if (surfaceView == null)
84016:             surfaceView = new GeckoSurfaceView(this);
84016:         else
84016:             mainLayout.removeAllViews();
84016: 
84016:         mainLayout = new AbsoluteLayout(this);
84016:         mainLayout.addView(surfaceView,
84016:                            new AbsoluteLayout.LayoutParams(AbsoluteLayout.LayoutParams.MATCH_PARENT, // level 8
84016:                                                            AbsoluteLayout.LayoutParams.MATCH_PARENT,
84016:                                                            0,
84016:                                                            0));
84016: 
84016:         setContentView(mainLayout,
84016:                        new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT,
84016:                                                   ViewGroup.LayoutParams.FILL_PARENT));
84016: 
84016:         mConnectivityFilter = new IntentFilter();
84016:         mConnectivityFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
84016:         mConnectivityReceiver = new GeckoConnectivityReceiver();
84016: 
84016:         IntentFilter batteryFilter = new IntentFilter();
84016:         batteryFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
84016:         mBatteryReceiver = new GeckoBatteryManager();
84016:         registerReceiver(mBatteryReceiver, batteryFilter);
84016: 
87554:         if (SmsManager.getInstance() != null) {
88061:             SmsManager.getInstance().start();
87554:         }
87532: 
87564:         GeckoNetworkManager.getInstance().init();
87563: 
84016:         if (!checkAndSetLaunchState(LaunchState.PreLaunch,
84016:                                     LaunchState.Launching))
84016:             return;
84016: 
84016:         checkAndLaunchUpdate();
84016:         mLibLoadThread = new Thread(new Runnable() {
84016:             public void run() {
84016:                 // At some point while loading the gecko libs our default locale gets set
84016:                 // so just save it to locale here and reset it as default after the join
84016:                 Locale locale = Locale.getDefault();
84016:                 GeckoAppShell.loadGeckoLibs(
84016:                     getApplication().getPackageResourcePath());
84016:                 Locale.setDefault(locale);
84016:                 Resources res = getBaseContext().getResources();
84016:                 Configuration config = res.getConfiguration();
84016:                 config.locale = locale;
84016:                 res.updateConfiguration(config, res.getDisplayMetrics());
84016:             }});
84016:         mLibLoadThread.start();
84016:     }
84016: 
84016:     public void enableCameraView() {
84016:         // Some phones (eg. nexus S) need at least a 8x16 preview size
84016:         mainLayout.addView(cameraView, new AbsoluteLayout.LayoutParams(8, 16, 0, 0));
84016:     }
84016: 
84016:     public void disableCameraView() {
84016:         mainLayout.removeView(cameraView);
84016:     }
84016: 
84016:     @Override
84016:     protected void onNewIntent(Intent intent) {
84016:         if (checkLaunchState(LaunchState.GeckoExiting)) {
84016:             // We're exiting and shouldn't try to do anything else just incase
84016:             // we're hung for some reason we'll force the process to exit
84016:             System.exit(0);
84016:             return;
84016:         }
84016:         final String action = intent.getAction();
84016:         if (ACTION_DEBUG.equals(action) &&
84016:             checkAndSetLaunchState(LaunchState.Launching, LaunchState.WaitForDebugger)) {
84016: 
84016:             mMainHandler.postDelayed(new Runnable() {
84016:                 public void run() {
84016:                     Log.i(LOG_FILE_NAME, "Launching from debug intent after 5s wait");
84016:                     setLaunchState(LaunchState.Launching);
84016:                     launch(null);
84016:                 }
84016:             }, 1000 * 5 /* 5 seconds */);
84016:             Log.i(LOG_FILE_NAME, "Intent : ACTION_DEBUG - waiting 5s before launching");
84016:             return;
84016:         }
84016:         if (checkLaunchState(LaunchState.WaitForDebugger) || launch(intent))
84016:             return;
84016: 
84016:         if (Intent.ACTION_MAIN.equals(action)) {
84016:             Log.i(LOG_FILE_NAME, "Intent : ACTION_MAIN");
84016:             GeckoAppShell.sendEventToGecko(new GeckoEvent(""));
84016:         }
84016:         else if (Intent.ACTION_VIEW.equals(action)) {
84016:             String uri = intent.getDataString();
84016:             GeckoAppShell.sendEventToGecko(new GeckoEvent(uri));
84016:             Log.i(LOG_FILE_NAME,"onNewIntent: "+uri);
84016:         }
84016:         else if (ACTION_WEBAPP.equals(action)) {
84016:             String uri = intent.getStringExtra("args");
84016:             GeckoAppShell.sendEventToGecko(new GeckoEvent(uri));
84016:             Log.i(LOG_FILE_NAME,"Intent : WEBAPP - " + uri);
84016:         }
84016:         else if (ACTION_BOOKMARK.equals(action)) {
84016:             String args = intent.getStringExtra("args");
84016:             GeckoAppShell.sendEventToGecko(new GeckoEvent(args));
84016:             Log.i(LOG_FILE_NAME,"Intent : BOOKMARK - " + args);
84016:         }
84016:     }
84016: 
84016:     @Override
84016:     public void onPause()
84016:     {
84016:         Log.i(LOG_FILE_NAME, "pause");
84016:         GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_PAUSING));
84016:         // The user is navigating away from this activity, but nothing
84016:         // has come to the foreground yet; for Gecko, we may want to
84016:         // stop repainting, for example.
84016: 
84016:         // Whatever we do here should be fast, because we're blocking
84016:         // the next activity from showing up until we finish.
84016: 
84016:         // onPause will be followed by either onResume or onStop.
84016:         super.onPause();
84016: 
84016:         unregisterReceiver(mConnectivityReceiver);
87564:         GeckoNetworkManager.getInstance().stop();
84016:     }
84016: 
84016:     @Override
84016:     public void onResume()
84016:     {
84016:         Log.i(LOG_FILE_NAME, "resume");
84016:         if (checkLaunchState(LaunchState.GeckoRunning))
84016:             GeckoAppShell.onResume();
84016:         // After an onPause, the activity is back in the foreground.
84016:         // Undo whatever we did in onPause.
84016:         super.onResume();
84016: 
84016:         // Just in case. Normally we start in onNewIntent
84016:         if (checkLaunchState(LaunchState.PreLaunch) ||
84016:             checkLaunchState(LaunchState.Launching))
84016:             onNewIntent(getIntent());
84016: 
84016:         registerReceiver(mConnectivityReceiver, mConnectivityFilter);
87564:         GeckoNetworkManager.getInstance().start();
84016:     }
84016: 
84016:     @Override
84016:     public void onStop()
84016:     {
84016:         Log.i(LOG_FILE_NAME, "stop");
84016:         // We're about to be stopped, potentially in preparation for
84016:         // being destroyed.  We're killable after this point -- as I
84016:         // understand it, in extreme cases the process can be terminated
84016:         // without going through onDestroy.
84016:         //
84016:         // We might also get an onRestart after this; not sure what
84016:         // that would mean for Gecko if we were to kill it here.
84016:         // Instead, what we should do here is save prefs, session,
84016:         // etc., and generally mark the profile as 'clean', and then
84016:         // dirty it again if we get an onResume.
84016: 
84016:         GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_STOPPING));
84016:         super.onStop();
84016:         GeckoAppShell.putChildInBackground();
84016:     }
84016: 
84016:     @Override
84016:     public void onRestart()
84016:     {
84016:         Log.i(LOG_FILE_NAME, "restart");
84016:         GeckoAppShell.putChildInForeground();
84016:         super.onRestart();
84016:     }
84016: 
84016:     @Override
84016:     public void onStart()
84016:     {
84016:         Log.i(LOG_FILE_NAME, "start");
84016:         GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_START));
84016:         super.onStart();
84016:     }
84016: 
84016:     @Override
84016:     public void onDestroy()
84016:     {
84016:         Log.i(LOG_FILE_NAME, "destroy");
84016: 
84016:         // Tell Gecko to shutting down; we'll end up calling System.exit()
84016:         // in onXreExit.
84016:         if (isFinishing())
84016:             GeckoAppShell.sendEventToGecko(new GeckoEvent(GeckoEvent.ACTIVITY_SHUTDOWN));
84016: 
87554:         if (SmsManager.getInstance() != null) {
88061:             SmsManager.getInstance().stop();
88061:             if (isFinishing())
87554:                 SmsManager.getInstance().shutdown();
87554:         }
87554: 
87564:         GeckoNetworkManager.getInstance().stop();
87564: 
84016:         super.onDestroy();
84016: 
84016:         unregisterReceiver(mBatteryReceiver);
84016:     }
84016: 
84016:     @Override
84016:     public void onConfigurationChanged(android.content.res.Configuration newConfig)
84016:     {
84016:         Log.i(LOG_FILE_NAME, "configuration changed");
84016:         // nothing, just ignore
84016:         super.onConfigurationChanged(newConfig);
84016:     }
84016: 
84016:     @Override
84016:     public void onLowMemory()
84016:     {
84016:         Log.e(LOG_FILE_NAME, "low memory");
84016:         if (checkLaunchState(LaunchState.GeckoRunning))
84016:             GeckoAppShell.onLowMemory();
84016:         super.onLowMemory();
84016:     }
84016: 
84016:     abstract public String getPackageName();
84016:     abstract public String getContentProcessName();
84016: 
84016:     protected void unpackComponents()
84016:         throws IOException, FileNotFoundException
84016:     {
84016:         File applicationPackage = new File(getApplication().getPackageResourcePath());
84016:         File componentsDir = new File(sGREDir, "components");
84016:         if (componentsDir.lastModified() == applicationPackage.lastModified())
84016:             return;
84016: 
84016:         componentsDir.mkdir();
84016:         componentsDir.setLastModified(applicationPackage.lastModified());
84016: 
84016:         GeckoAppShell.killAnyZombies();
84016: 
84016:         ZipFile zip = new ZipFile(applicationPackage);
84016: 
84016:         byte[] buf = new byte[32768];
84016:         try {
84016:             if (unpackFile(zip, buf, null, "removed-files"))
84016:                 removeFiles();
84016:         } catch (Exception ex) {
84016:             // This file may not be there, so just log any errors and move on
84016:             Log.w(LOG_FILE_NAME, "error removing files", ex);
84016:         }
84016: 
84016:         // copy any .xpi file into an extensions/ directory
84016:         Enumeration<? extends ZipEntry> zipEntries = zip.entries();
84016:         while (zipEntries.hasMoreElements()) {
84016:             ZipEntry entry = zipEntries.nextElement();
84016:             if (entry.getName().startsWith("extensions/") && entry.getName().endsWith(".xpi")) {
84016:                 Log.i("GeckoAppJava", "installing extension : " + entry.getName());
84016:                 unpackFile(zip, buf, entry, entry.getName());
84016:             }
84016:         }
84016:     }
84016: 
84016:     void removeFiles() throws IOException {
84016:         BufferedReader reader = new BufferedReader(
84016:             new FileReader(new File(sGREDir, "removed-files")));
84016:         try {
84016:             for (String removedFileName = reader.readLine(); 
84016:                  removedFileName != null; removedFileName = reader.readLine()) {
84016:                 File removedFile = new File(sGREDir, removedFileName);
84016:                 if (removedFile.exists())
84016:                     removedFile.delete();
84016:             }
84016:         } finally {
84016:             reader.close();
84016:         }
84016:         
84016:     }
84016: 
84016:     private boolean unpackFile(ZipFile zip, byte[] buf, ZipEntry fileEntry,
84016:                             String name)
84016:         throws IOException, FileNotFoundException
84016:     {
84016:         if (fileEntry == null)
84016:             fileEntry = zip.getEntry(name);
84016:         if (fileEntry == null)
84016:             throw new FileNotFoundException("Can't find " + name + " in " +
84016:                                             zip.getName());
84016: 
84016:         File outFile = new File(sGREDir, name);
84016:         if (outFile.lastModified() == fileEntry.getTime() &&
84016:             outFile.length() == fileEntry.getSize())
84016:             return false;
84016: 
84016:         File dir = outFile.getParentFile();
84016:         if (!dir.exists())
84016:             dir.mkdirs();
84016: 
84016:         InputStream fileStream;
84016:         fileStream = zip.getInputStream(fileEntry);
84016: 
84016:         OutputStream outStream = new FileOutputStream(outFile);
84016: 
84016:         while (fileStream.available() > 0) {
84016:             int read = fileStream.read(buf, 0, buf.length);
84016:             outStream.write(buf, 0, read);
84016:         }
84016: 
84016:         fileStream.close();
84016:         outStream.close();
84016:         outFile.setLastModified(fileEntry.getTime());
84016:         return true;
84016:     }
84016: 
84016:     public void addEnvToIntent(Intent intent) {
84016:         Map<String,String> envMap = System.getenv();
84016:         Set<Map.Entry<String,String>> envSet = envMap.entrySet();
84016:         Iterator<Map.Entry<String,String>> envIter = envSet.iterator();
84016:         int c = 0;
84016:         while (envIter.hasNext()) {
84016:             Map.Entry<String,String> entry = envIter.next();
84016:             intent.putExtra("env" + c, entry.getKey() + "="
84016:                             + entry.getValue());
84016:             c++;
84016:         }
84016:     }
84016: 
84016:     public void doRestart() {
84016:         try {
84016:             String action = "org.mozilla.gecko.restart";
84016:             Intent intent = new Intent(action);
84016:             intent.setClassName(getPackageName(),
84016:                                 getPackageName() + ".Restarter");
84016:             addEnvToIntent(intent);
84016:             intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
84016:                             Intent.FLAG_ACTIVITY_MULTIPLE_TASK);
84016:             Log.i(LOG_FILE_NAME, intent.toString());
84016:             GeckoAppShell.killAnyZombies();
84016:             startActivity(intent);
84016:         } catch (Exception e) {
84016:             Log.i(LOG_FILE_NAME, "error doing restart", e);
84016:         }
84016:         finish();
84016:         // Give the restart process time to start before we die
84016:         GeckoAppShell.waitForAnotherGeckoProc();
84016:     }
84016: 
84016:     public void handleNotification(String action, String alertName, String alertCookie) {
84016:         GeckoAppShell.handleNotification(action, alertName, alertCookie);
84016:     }
84016: 
84016:     private void checkAndLaunchUpdate() {
84016:         Log.i(LOG_FILE_NAME, "Checking for an update");
84016: 
84016:         int statusCode = 8; // UNEXPECTED_ERROR
84016:         File baseUpdateDir = null;
84016:         if (Build.VERSION.SDK_INT >= 8)
84016:             baseUpdateDir = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS);
84016:         else
84016:             baseUpdateDir = new File(Environment.getExternalStorageDirectory().getPath(), "download");
84016: 
84016:         File updateDir = new File(new File(baseUpdateDir, "updates"),"0");
84016: 
84016:         File updateFile = new File(updateDir, "update.apk");
84016:         File statusFile = new File(updateDir, "update.status");
84016: 
84016:         if (!statusFile.exists() || !readUpdateStatus(statusFile).equals("pending"))
84016:             return;
84016: 
84016:         if (!updateFile.exists())
84016:             return;
84016: 
84016:         Log.i(LOG_FILE_NAME, "Update is available!");
84016: 
84016:         // Launch APK
84016:         File updateFileToRun = new File(updateDir, getPackageName() + "-update.apk");
84016:         try {
84016:             if (updateFile.renameTo(updateFileToRun)) {
84016:                 String amCmd = "/system/bin/am start -a android.intent.action.VIEW " +
84016:                                "-n com.android.packageinstaller/.PackageInstallerActivity -d file://" +
84016:                                updateFileToRun.getPath();
84016:                 Log.i(LOG_FILE_NAME, amCmd);
84016:                 Runtime.getRuntime().exec(amCmd);
84016:                 statusCode = 0; // OK
84016:             } else {
84016:                 Log.i(LOG_FILE_NAME, "Cannot rename the update file!");
84016:                 statusCode = 7; // WRITE_ERROR
84016:             }
84016:         } catch (Exception e) {
84016:             Log.i(LOG_FILE_NAME, "error launching installer to update", e);
84016:         }
84016: 
84016:         // Update the status file
84016:         String status = statusCode == 0 ? "succeeded\n" : "failed: "+ statusCode + "\n";
84016: 
84016:         OutputStream outStream;
84016:         try {
84016:             byte[] buf = status.getBytes("UTF-8");
84016:             outStream = new FileOutputStream(statusFile);
84016:             outStream.write(buf, 0, buf.length);
84016:             outStream.close();
84016:         } catch (Exception e) {
84016:             Log.i(LOG_FILE_NAME, "error writing status file", e);
84016:         }
84016: 
84016:         if (statusCode == 0)
84016:             System.exit(0);
84016:     }
84016: 
84016:     private String readUpdateStatus(File statusFile) {
84016:         String status = "";
84016:         try {
84016:             BufferedReader reader = new BufferedReader(new FileReader(statusFile));
84016:             status = reader.readLine();
84016:             reader.close();
84016:         } catch (Exception e) {
84016:             Log.i(LOG_FILE_NAME, "error reading update status", e);
84016:         }
84016:         return status;
84016:     }
84016: 
84016:     static final int FILE_PICKER_REQUEST = 1;
84016: 
84016:     private SynchronousQueue<String> mFilePickerResult = new SynchronousQueue();
84016:     public String showFilePicker(String aMimeType) {
84016:         Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
84016:         intent.addCategory(Intent.CATEGORY_OPENABLE);
84016:         intent.setType(aMimeType);
84016:         GeckoApp.this.
84016:             startActivityForResult(
84016:                 Intent.createChooser(intent, getString(R.string.choose_file)),
84016:                 FILE_PICKER_REQUEST);
84016:         String filePickerResult = "";
84016: 
84016:         try {
84016:             while (null == (filePickerResult = mFilePickerResult.poll(1, TimeUnit.MILLISECONDS))) {
84016:                 Log.i("GeckoApp", "processing events from showFilePicker ");
84016:                 GeckoAppShell.processNextNativeEvent();
84016:             }
84016:         } catch (InterruptedException e) {
84016:             Log.i(LOG_FILE_NAME, "showing file picker ",  e);
84016:         }
84016: 
84016:         return filePickerResult;
84016:     }
84016: 
84016:     @Override
84016:     protected void onActivityResult(int requestCode, int resultCode,
84016:                                     Intent data) {
84016:         String filePickerResult = "";
84016:         if (data != null && resultCode == RESULT_OK) {
84016:             try {
84016:                 ContentResolver cr = getContentResolver();
84016:                 Uri uri = data.getData();
84016:                 Cursor cursor = GeckoApp.mAppContext.getContentResolver().query(
84016:                     uri, 
84016:                     new String[] { OpenableColumns.DISPLAY_NAME },
84016:                     null, 
84016:                     null, 
84016:                     null);
84016:                 String name = null;
84016:                 if (cursor != null) {
84016:                     try {
84016:                         if (cursor.moveToNext()) {
84016:                             name = cursor.getString(0);
84016:                         }
84016:                     } finally {
84016:                         cursor.close();
84016:                     }
84016:                 }
84016:                 String fileName = "tmp_";
84016:                 String fileExt = null;
84016:                 int period;
84016:                 if (name == null || (period = name.lastIndexOf('.')) == -1) {
84016:                     String mimeType = cr.getType(uri);
84016:                     fileExt = "." + GeckoAppShell.getExtensionFromMimeType(mimeType);
84016:                 } else {
84016:                     fileExt = name.substring(period);
84016:                     fileName = name.substring(0, period);
84016:                 }
84016:                 File file = File.createTempFile(fileName, fileExt, sGREDir);
84016: 
84016:                 FileOutputStream fos = new FileOutputStream(file);
84016:                 InputStream is = cr.openInputStream(uri);
84016:                 byte[] buf = new byte[4096];
84016:                 int len = is.read(buf);
84016:                 while (len != -1) {
84016:                     fos.write(buf, 0, len);
84016:                     len = is.read(buf);
84016:                 }
84016:                 fos.close();
84016:                 filePickerResult =  file.getAbsolutePath();
84016:             }catch (Exception e) {
84016:                 Log.e(LOG_FILE_NAME, "showing file picker", e);
84016:             }
84016:         }
84016:         try {
84016:             mFilePickerResult.put(filePickerResult);
84016:         } catch (InterruptedException e) {
84016:             Log.i(LOG_FILE_NAME, "error returning file picker result", e);
84016:         }
84016:     }
84016: }
