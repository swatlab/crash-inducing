   1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
   1:  * vim: ft=cpp tw=78 sw=4 et ts=4 sts=4 cin
   1:  * ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is the Mozilla browser.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications, Inc.
   1:  * Portions created by the Initial Developer are Copyright (C) 1999
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Travis Bogard <travis@netscape.com>
   1:  *   Pierre Phaneuf <pp@ludusdesign.com>
   1:  *   Peter Annema <disttsc@bart.nl>
   1:  *   Dan Rosen <dr@netscape.com>
1585:  *   Mats Palmgren <mats.palmgren@bredband.net>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #ifdef MOZ_LOGGING
   1: // so we can get logging even in release builds (but only for some things)
   1: #define FORCE_PR_LOG 1
   1: #endif
   1: 
   1: #include "nsIBrowserDOMWindow.h"
   1: #include "nsIComponentManager.h"
   1: #include "nsIContent.h"
   1: #include "nsIDocument.h"
   1: #include "nsIDOMDocument.h"
   1: #include "nsIDOMNSDocument.h"
   1: #include "nsIDOMElement.h"
   1: #include "nsIDOMStorage.h"
   1: #include "nsPIDOMStorage.h"
   1: #include "nsIDocumentViewer.h"
   1: #include "nsIDocumentLoaderFactory.h"
   1: #include "nsCURILoader.h"
5528: #include "nsURILoader.h"
   1: #include "nsDocShellCID.h"
   1: #include "nsLayoutCID.h"
   1: #include "nsDOMCID.h"
   1: #include "nsIDOMScriptObjectFactory.h"
   1: #include "nsNetUtil.h"
   1: #include "nsRect.h"
   1: #include "prprf.h"
   1: #include "nsIMarkupDocumentViewer.h"
   1: #include "nsXPIDLString.h"
   1: #include "nsReadableUtils.h"
   1: #include "nsIDOMEventTarget.h"
   1: #include "nsIDOMChromeWindow.h"
   1: #include "nsIDOMWindowInternal.h"
   1: #include "nsIWebBrowserChrome.h"
   1: #include "nsPoint.h"
   1: #include "nsGfxCIID.h"
   1: #include "nsIObserverService.h"
   1: #include "nsIPrompt.h"
   1: #include "nsIAuthPrompt.h"
   1: #include "nsIAuthPrompt2.h"
   1: #include "nsTextFormatter.h"
   1: #include "nsIChannelEventSink.h"
   1: #include "nsIUploadChannel.h"
   1: #include "nsISecurityEventSink.h"
   1: #include "nsIScriptSecurityManager.h"
   1: #include "nsIJSContextStack.h"
   1: #include "nsIScriptObjectPrincipal.h"
   1: #include "nsDocumentCharsetInfoCID.h"
   1: #include "nsICanvasFrame.h"
   1: #include "nsIScrollableFrame.h"
   1: #include "nsContentPolicyUtils.h" // NS_CheckContentLoadPolicy(...)
   1: #include "nsICategoryManager.h"
   1: #include "nsXPCOMCID.h"
   1: #include "nsISeekableStream.h"
   1: #include "nsAutoPtr.h"
   1: #include "nsIPrefService.h"
   1: #include "nsIPrefBranch.h"
   1: #include "nsIPrefBranch2.h"
   1: #include "nsIWritablePropertyBag2.h"
   1: #include "nsIAppShell.h"
   1: #include "nsWidgetsCID.h"
   1: #include "nsDOMJSUtils.h"
   1: #include "nsIInterfaceRequestorUtils.h"
   1: #include "nsIView.h"
   1: #include "nsIViewManager.h"
   1: #include "nsIScrollableView.h"
   1: #include "nsIScriptChannel.h"
5528: #include "nsIURIClassifier.h"
   1: 
   1: // we want to explore making the document own the load group
   1: // so we can associate the document URI with the load group.
   1: // until this point, we have an evil hack:
   1: #include "nsIHttpChannelInternal.h"  
   1: 
   1: 
   1: // Local Includes
   1: #include "nsDocShell.h"
   1: #include "nsDocShellLoadInfo.h"
   1: #include "nsCDefaultURIFixup.h"
   1: #include "nsDocShellEnumerator.h"
   1: #include "nsSHistory.h"
   1: 
   1: // Helper Classes
   1: #include "nsDOMError.h"
   1: #include "nsEscape.h"
   1: 
   1: // Interfaces Needed
   1: #include "nsIUploadChannel.h"
   1: #include "nsIProgressEventSink.h"
   1: #include "nsIWebProgress.h"
   1: #include "nsILayoutHistoryState.h"
   1: #include "nsITimer.h"
   1: #include "nsISHistoryInternal.h"
   1: #include "nsIPrincipal.h"
   1: #include "nsIHistoryEntry.h"
   1: #include "nsISHistoryListener.h"
   1: #include "nsIWindowWatcher.h"
   1: #include "nsIPromptFactory.h"
   1: #include "nsIObserver.h"
   1: #include "nsINestedURI.h"
   1: #include "nsITransportSecurityInfo.h"
   1: #include "nsINSSErrorsService.h"
   1: 
   1: // Editor-related
   1: #include "nsIEditingSession.h"
   1: 
   1: #include "nsPIDOMWindow.h"
   1: #include "nsIDOMDocument.h"
   1: #include "nsICachingChannel.h"
   1: #include "nsICacheVisitor.h"
   1: #include "nsIMultiPartChannel.h"
   1: #include "nsIWyciwygChannel.h"
   1: 
   1: // The following are for bug #13871: Prevent frameset spoofing
   1: #include "nsIHTMLDocument.h"
   1: 
   1: // For reporting errors with the console service.
   1: // These can go away if error reporting is propagated up past nsDocShell.
   1: #include "nsIConsoleService.h"
   1: #include "nsIScriptError.h"
   1: 
   1: // used to dispatch urls to default protocol handlers
   1: #include "nsCExternalHandlerService.h"
   1: #include "nsIExternalProtocolService.h"
   1: 
   1: #include "nsIFocusController.h"
   1: 
   1: #include "nsITextToSubURI.h"
   1: 
8363: #include "nsIJARChannel.h"
8363: 
   1: #include "prlog.h"
   1: #include "prmem.h"
   1: 
   1: #include "nsISelectionDisplay.h"
   1: 
   1: #include "nsIGlobalHistory2.h"
   1: #include "nsIGlobalHistory3.h"
   1: 
   1: #ifdef DEBUG_DOCSHELL_FOCUS
   1: #include "nsIEventStateManager.h"
   1: #endif
   1: 
   1: #include "nsIFrame.h"
   1: 
   1: // for embedding
   1: #include "nsIWebBrowserChromeFocus.h"
   1: 
   1: #include "nsPluginError.h"
   1: 
   1: static NS_DEFINE_IID(kDeviceContextCID, NS_DEVICE_CONTEXT_CID);
   1: static NS_DEFINE_CID(kDOMScriptObjectFactoryCID,
   1:                      NS_DOM_SCRIPT_OBJECT_FACTORY_CID);
   1: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
   1: 
   1: #if defined(DEBUG_bryner) || defined(DEBUG_chb)
   1: //#define DEBUG_DOCSHELL_FOCUS
   1: #define DEBUG_PAGE_CACHE
   1: #endif
   1: 
   1: #include "nsContentErrors.h"
   1: 
   1: // Number of documents currently loading
   1: static PRInt32 gNumberOfDocumentsLoading = 0;
   1: 
   1: // Global count of existing docshells.
   1: static PRInt32 gDocShellCount = 0;
   1: 
   1: // Global reference to the URI fixup service.
   1: nsIURIFixup *nsDocShell::sURIFixup = 0;
   1: 
   1: // True means we validate window targets to prevent frameset
   1: // spoofing. Initialize this to a non-bolean value so we know to check
   1: // the pref on the creation of the first docshell.
   1: static PRBool gValidateOrigin = (PRBool)0xffffffff;
   1: 
   1: // Hint for native dispatch of events on how long to delay after 
   1: // all documents have loaded in milliseconds before favoring normal
   1: // native event dispatch priorites over performance
   1: #define NS_EVENT_STARVATION_DELAY_HINT 2000
   1: 
   1: // This is needed for displaying an error message 
   1: // when navigation is attempted on a document when printing
   1: // The value arbitrary as long as it doesn't conflict with
   1: // any of the other values in the errors in DisplayLoadError
   1: #define NS_ERROR_DOCUMENT_IS_PRINTMODE  NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_GENERAL,2001)
   1: 
   1: #ifdef PR_LOGGING
   1: #ifdef DEBUG
   1: static PRLogModuleInfo* gDocShellLog;
   1: #endif
   1: static PRLogModuleInfo* gDocShellLeakLog;
   1: #endif
   1: 
   1: const char kBrandBundleURL[]      = "chrome://branding/locale/brand.properties";
   1: const char kAppstringsBundleURL[] = "chrome://global/locale/appstrings.properties";
   1: 
   1: static void
   1: FavorPerformanceHint(PRBool perfOverStarvation, PRUint32 starvationDelay)
   1: {
   1:     nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
   1:     if (appShell)
   1:         appShell->FavorPerformanceHint(perfOverStarvation, starvationDelay);
   1: }
   1: 
   1: //*****************************************************************************
   1: //***    nsDocShellFocusController
   1: //*****************************************************************************
   1: 
   1: class nsDocShellFocusController
   1: {
   1: 
   1: public:
   1:   static nsDocShellFocusController* GetInstance() { return &mDocShellFocusControllerSingleton; }
   1:   virtual ~nsDocShellFocusController(){}
   1: 
   1:   void Focus(nsIDocShell* aDS);
   1:   void ClosingDown(nsIDocShell* aDS);
   1: 
   1: protected:
   1:   nsDocShellFocusController(){}
   1: 
   1:   nsIDocShell* mFocusedDocShell; // very weak reference
   1: 
   1: private:
   1:   static nsDocShellFocusController mDocShellFocusControllerSingleton;
   1: };
   1: 
   1: nsDocShellFocusController nsDocShellFocusController::mDocShellFocusControllerSingleton;
   1: 
   1: //*****************************************************************************
   1: //***    nsDocShell: Object Management
   1: //*****************************************************************************
   1: 
   1: nsDocShell::nsDocShell():
   1:     nsDocLoader(),
   1:     mAllowSubframes(PR_TRUE),
   1:     mAllowPlugins(PR_TRUE),
   1:     mAllowJavascript(PR_TRUE),
   1:     mAllowMetaRedirects(PR_TRUE),
   1:     mAllowImages(PR_TRUE),
   1:     mFocusDocFirst(PR_FALSE),
   1:     mHasFocus(PR_FALSE),
   1:     mCreatingDocument(PR_FALSE),
   1:     mUseErrorPages(PR_FALSE),
   1:     mObserveErrorPages(PR_TRUE),
   1:     mAllowAuth(PR_TRUE),
   1:     mAllowKeywordFixup(PR_FALSE),
   1:     mFiredUnloadEvent(PR_FALSE),
   1:     mEODForCurrentDocument(PR_FALSE),
   1:     mURIResultedInDocument(PR_FALSE),
   1:     mIsBeingDestroyed(PR_FALSE),
   1:     mIsExecutingOnLoadHandler(PR_FALSE),
   1:     mIsPrintingOrPP(PR_FALSE),
   1:     mSavingOldViewer(PR_FALSE),
   1:     mAppType(nsIDocShell::APP_TYPE_UNKNOWN),
   1:     mChildOffset(0),
   1:     mBusyFlags(BUSY_FLAGS_NONE),
   1:     mMarginWidth(0),
   1:     mMarginHeight(0),
   1:     mItemType(typeContent),
   1:     mDefaultScrollbarPref(Scrollbar_Auto, Scrollbar_Auto),
   1:     mPreviousTransIndex(-1),
   1:     mLoadedTransIndex(-1),
   1:     mEditorData(nsnull),
   1:     mTreeOwner(nsnull),
   1:     mChromeEventHandler(nsnull)
7837: #ifdef DEBUG
7837:     , mInEnsureScriptEnv(PR_FALSE)
7837: #endif
   1: {
   1:     if (gDocShellCount++ == 0) {
   1:         NS_ASSERTION(sURIFixup == nsnull,
   1:                      "Huh, sURIFixup not null in first nsDocShell ctor!");
   1: 
   1:         CallGetService(NS_URIFIXUP_CONTRACTID, &sURIFixup);
   1:     }
   1: 
   1: #ifdef PR_LOGGING
   1: #ifdef DEBUG
   1:     if (! gDocShellLog)
   1:         gDocShellLog = PR_NewLogModule("nsDocShell");
   1: #endif
   1:     if (nsnull == gDocShellLeakLog)
   1:         gDocShellLeakLog = PR_NewLogModule("nsDocShellLeak");
   1:     if (gDocShellLeakLog)
   1:         PR_LOG(gDocShellLeakLog, PR_LOG_DEBUG, ("DOCSHELL %p created\n", this));
   1: #endif
   1: }
   1: 
   1: nsDocShell::~nsDocShell()
   1: {
   1:     nsDocShellFocusController* dsfc = nsDocShellFocusController::GetInstance();
   1:     if (dsfc) {
   1:       dsfc->ClosingDown(this);
   1:     }
   1:     Destroy();
   1: 
   1:     if (--gDocShellCount == 0) {
   1:         NS_IF_RELEASE(sURIFixup);
   1:     }
   1: 
   1: #ifdef PR_LOGGING
   1:     if (gDocShellLeakLog)
   1:         PR_LOG(gDocShellLeakLog, PR_LOG_DEBUG, ("DOCSHELL %p destroyed\n", this));
   1: #endif
   1: }
   1: 
   1: nsresult
   1: nsDocShell::Init()
   1: {
   1:     nsresult rv = nsDocLoader::Init();
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     NS_ASSERTION(mLoadGroup, "Something went wrong!");
   1: 
   1:     mContentListener = new nsDSURIContentListener(this);
   1:     NS_ENSURE_TRUE(mContentListener, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:     rv = mContentListener->Init();
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     if (!mStorages.Init())
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:     // We want to hold a strong ref to the loadgroup, so it better hold a weak
   1:     // ref to us...  use an InterfaceRequestorProxy to do this.
   1:     nsCOMPtr<InterfaceRequestorProxy> proxy =
3233:         new InterfaceRequestorProxy(static_cast<nsIInterfaceRequestor*>
3233:                                                (this));
   1:     NS_ENSURE_TRUE(proxy, NS_ERROR_OUT_OF_MEMORY);
   1:     mLoadGroup->SetNotificationCallbacks(proxy);
   1: 
   1:     rv = nsDocLoader::AddDocLoaderAsChildOfRoot(this);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     
   1:     // Add as |this| a progress listener to itself.  A little weird, but
   1:     // simpler than reproducing all the listener-notification logic in
   1:     // overrides of the various methods via which nsDocLoader can be
   1:     // notified.   Note that this holds an nsWeakPtr to ourselves, so it's ok.
   1:     return AddProgressListener(this, nsIWebProgress::NOTIFY_STATE_DOCUMENT |
   1:                                      nsIWebProgress::NOTIFY_STATE_NETWORK);
   1:     
   1: }
   1: 
   1: void
   1: nsDocShell::DestroyChildren()
   1: {
   1:     nsCOMPtr<nsIDocShellTreeItem> shell;
   1:     PRInt32 n = mChildList.Count();
   1:     for (PRInt32 i = 0; i < n; i++) {
   1:         shell = do_QueryInterface(ChildAt(i));
   1:         NS_ASSERTION(shell, "docshell has null child");
   1: 
   1:         if (shell) {
   1:             shell->SetTreeOwner(nsnull);
   1:         }
   1:     }
   1: 
   1:     nsDocLoader::DestroyChildren();
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsISupports
   1: //*****************************************************************************   
   1: 
   1: NS_IMPL_ADDREF_INHERITED(nsDocShell, nsDocLoader)
   1: NS_IMPL_RELEASE_INHERITED(nsDocShell, nsDocLoader)
   1: 
   1: NS_INTERFACE_MAP_BEGIN(nsDocShell)
   1:     NS_INTERFACE_MAP_ENTRY(nsIDocShell)
   1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellTreeItem)
   1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellTreeNode)
   1:     NS_INTERFACE_MAP_ENTRY(nsIDocShellHistory)
   1:     NS_INTERFACE_MAP_ENTRY(nsIWebNavigation)
   1:     NS_INTERFACE_MAP_ENTRY(nsIBaseWindow)
   1:     NS_INTERFACE_MAP_ENTRY(nsIScrollable)
   1:     NS_INTERFACE_MAP_ENTRY(nsITextScroll)
   1:     NS_INTERFACE_MAP_ENTRY(nsIDocCharset)
   1:     NS_INTERFACE_MAP_ENTRY(nsIScriptGlobalObjectOwner)
   1:     NS_INTERFACE_MAP_ENTRY(nsIRefreshURI)
   1:     NS_INTERFACE_MAP_ENTRY(nsIWebProgressListener)
   1:     NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
   1:     NS_INTERFACE_MAP_ENTRY(nsIContentViewerContainer)
   1:     NS_INTERFACE_MAP_ENTRY(nsIEditorDocShell)
   1:     NS_INTERFACE_MAP_ENTRY(nsIWebPageDescriptor)
   1:     NS_INTERFACE_MAP_ENTRY(nsIAuthPromptProvider)
   1:     NS_INTERFACE_MAP_ENTRY(nsIObserver)
   1: NS_INTERFACE_MAP_END_INHERITING(nsDocLoader)
   1: 
   1: ///*****************************************************************************
   1: // nsDocShell::nsIInterfaceRequestor
   1: //*****************************************************************************   
   1: NS_IMETHODIMP nsDocShell::GetInterface(const nsIID & aIID, void **aSink)
   1: {
   1:     NS_PRECONDITION(aSink, "null out param");
   1: 
   1:     *aSink = nsnull;
   1: 
   1:     if (aIID.Equals(NS_GET_IID(nsIURIContentListener))) {
   1:         *aSink = mContentListener;
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsIScriptGlobalObject)) &&
   1:              NS_SUCCEEDED(EnsureScriptEnvironment())) {
   1:         *aSink = mScriptGlobal;
   1:     }
   1:     else if ((aIID.Equals(NS_GET_IID(nsIDOMWindowInternal)) ||
   1:               aIID.Equals(NS_GET_IID(nsPIDOMWindow)) ||
   1:               aIID.Equals(NS_GET_IID(nsIDOMWindow))) &&
   1:              NS_SUCCEEDED(EnsureScriptEnvironment())) {
   1:         return mScriptGlobal->QueryInterface(aIID, aSink);
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsIDOMDocument)) &&
   1:              NS_SUCCEEDED(EnsureContentViewer())) {
   1:         mContentViewer->GetDOMDocument((nsIDOMDocument **) aSink);
   1:         return *aSink ? NS_OK : NS_NOINTERFACE;
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsIPrompt)) &&
   1:              NS_SUCCEEDED(EnsureScriptEnvironment())) {
   1:         nsresult rv;
   1:         nsCOMPtr<nsIWindowWatcher> wwatch =
   1:             do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:         nsCOMPtr<nsIDOMWindow> window(do_QueryInterface(mScriptGlobal));
   1: 
   1:         // Get the an auth prompter for our window so that the parenting
   1:         // of the dialogs works as it should when using tabs.
   1: 
   1:         nsIPrompt *prompt;
   1:         rv = wwatch->GetNewPrompter(window, &prompt);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:         *aSink = prompt;
   1:         return NS_OK;
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
   1:              aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
   1:         return NS_SUCCEEDED(
   1:                 GetAuthPrompt(PROMPT_NORMAL, aIID, aSink)) ?
   1:                 NS_OK : NS_NOINTERFACE;
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsISHistory))) {
   1:         nsCOMPtr<nsISHistory> shistory;
   1:         nsresult
   1:             rv =
   1:             GetSessionHistory(getter_AddRefs(shistory));
   1:         if (NS_SUCCEEDED(rv) && shistory) {
   1:             *aSink = shistory;
   1:             NS_ADDREF((nsISupports *) * aSink);
   1:             return NS_OK;
   1:         }
   1:         return NS_NOINTERFACE;
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsIWebBrowserFind))) {
   1:         nsresult rv = EnsureFind();
   1:         if (NS_FAILED(rv)) return rv;
   1: 
   1:         *aSink = mFind;
   1:         NS_ADDREF((nsISupports*)*aSink);
   1:         return NS_OK;
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsIEditingSession)) && NS_SUCCEEDED(EnsureEditorData())) {
   1:       nsCOMPtr<nsIEditingSession> editingSession;
   1:       mEditorData->GetEditingSession(getter_AddRefs(editingSession));
   1:       if (editingSession)
   1:       {
   1:         *aSink = editingSession;
   1:         NS_ADDREF((nsISupports *)*aSink);
   1:         return NS_OK;
   1:       }  
   1: 
   1:       return NS_NOINTERFACE;   
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsIClipboardDragDropHookList)) 
   1:             && NS_SUCCEEDED(EnsureTransferableHookData())) {
   1:         *aSink = mTransferableHookData;
   1:         NS_ADDREF((nsISupports *)*aSink);
   1:         return NS_OK;
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsISelectionDisplay))) {
   1:       nsCOMPtr<nsIPresShell> shell;
   1:       nsresult rv = GetPresShell(getter_AddRefs(shell));
   1:       if (NS_SUCCEEDED(rv) && shell)
   1:         return shell->QueryInterface(aIID,aSink);    
   1:     }
   1:     else if (aIID.Equals(NS_GET_IID(nsIDocShellTreeOwner))) {
   1:       nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
   1:       nsresult rv = GetTreeOwner(getter_AddRefs(treeOwner));
   1:       if (NS_SUCCEEDED(rv) && treeOwner)
   1:         return treeOwner->QueryInterface(aIID, aSink);
   1:     }
   1:     else {
   1:         return nsDocLoader::GetInterface(aIID, aSink);
   1:     }
   1: 
   1:     NS_IF_ADDREF(((nsISupports *) * aSink));
   1:     return *aSink ? NS_OK : NS_NOINTERFACE;
   1: }
   1: 
   1: PRUint32
   1: nsDocShell::
   1: ConvertDocShellLoadInfoToLoadType(nsDocShellInfoLoadType aDocShellLoadType)
   1: {
   1:     PRUint32 loadType = LOAD_NORMAL;
   1: 
   1:     switch (aDocShellLoadType) {
   1:     case nsIDocShellLoadInfo::loadNormal:
   1:         loadType = LOAD_NORMAL;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadNormalReplace:
   1:         loadType = LOAD_NORMAL_REPLACE;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadNormalExternal:
   1:         loadType = LOAD_NORMAL_EXTERNAL;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadHistory:
   1:         loadType = LOAD_HISTORY;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadNormalBypassCache:
   1:         loadType = LOAD_NORMAL_BYPASS_CACHE;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadNormalBypassProxy:
   1:         loadType = LOAD_NORMAL_BYPASS_PROXY;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadNormalBypassProxyAndCache:
   1:         loadType = LOAD_NORMAL_BYPASS_PROXY_AND_CACHE;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadReloadNormal:
   1:         loadType = LOAD_RELOAD_NORMAL;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadReloadCharsetChange:
   1:         loadType = LOAD_RELOAD_CHARSET_CHANGE;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadReloadBypassCache:
   1:         loadType = LOAD_RELOAD_BYPASS_CACHE;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadReloadBypassProxy:
   1:         loadType = LOAD_RELOAD_BYPASS_PROXY;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadReloadBypassProxyAndCache:
   1:         loadType = LOAD_RELOAD_BYPASS_PROXY_AND_CACHE;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadLink:
   1:         loadType = LOAD_LINK;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadRefresh:
   1:         loadType = LOAD_REFRESH;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadBypassHistory:
   1:         loadType = LOAD_BYPASS_HISTORY;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadStopContent:
   1:         loadType = LOAD_STOP_CONTENT;
   1:         break;
   1:     case nsIDocShellLoadInfo::loadStopContentAndReplace:
   1:         loadType = LOAD_STOP_CONTENT_AND_REPLACE;
   1:         break;
   1:     default:
   1:         NS_NOTREACHED("Unexpected nsDocShellInfoLoadType value");
   1:     }
   1: 
   1:     return loadType;
   1: }
   1: 
   1: 
   1: nsDocShellInfoLoadType
   1: nsDocShell::ConvertLoadTypeToDocShellLoadInfo(PRUint32 aLoadType)
   1: {
   1:     nsDocShellInfoLoadType docShellLoadType = nsIDocShellLoadInfo::loadNormal;
   1:     switch (aLoadType) {
   1:     case LOAD_NORMAL:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadNormal;
   1:         break;
   1:     case LOAD_NORMAL_REPLACE:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalReplace;
   1:         break;
   1:     case LOAD_NORMAL_EXTERNAL:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalExternal;
   1:         break;
   1:     case LOAD_NORMAL_BYPASS_CACHE:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalBypassCache;
   1:         break;
   1:     case LOAD_NORMAL_BYPASS_PROXY:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalBypassProxy;
   1:         break;
   1:     case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadNormalBypassProxyAndCache;
   1:         break;
   1:     case LOAD_HISTORY:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadHistory;
   1:         break;
   1:     case LOAD_RELOAD_NORMAL:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadNormal;
   1:         break;
   1:     case LOAD_RELOAD_CHARSET_CHANGE:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadCharsetChange;
   1:         break;
   1:     case LOAD_RELOAD_BYPASS_CACHE:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadBypassCache;
   1:         break;
   1:     case LOAD_RELOAD_BYPASS_PROXY:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadBypassProxy;
   1:         break;
   1:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadReloadBypassProxyAndCache;
   1:         break;
   1:     case LOAD_LINK:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadLink;
   1:         break;
   1:     case LOAD_REFRESH:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadRefresh;
   1:         break;
   1:     case LOAD_BYPASS_HISTORY:
   1:     case LOAD_ERROR_PAGE:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadBypassHistory;
   1:         break;
   1:     case LOAD_STOP_CONTENT:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadStopContent;
   1:         break;
   1:     case LOAD_STOP_CONTENT_AND_REPLACE:
   1:         docShellLoadType = nsIDocShellLoadInfo::loadStopContentAndReplace;
   1:         break;
   1:     default:
   1:         NS_NOTREACHED("Unexpected load type value");
   1:     }
   1: 
   1:     return docShellLoadType;
   1: }                                                                               
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIDocShell
   1: //*****************************************************************************   
   1: NS_IMETHODIMP
   1: nsDocShell::LoadURI(nsIURI * aURI,
   1:                     nsIDocShellLoadInfo * aLoadInfo,
   1:                     PRUint32 aLoadFlags,
   1:                     PRBool aFirstParty)
   1: {
6422:     if (!IsNavigationAllowed()) {
2400:       return NS_OK; // JS may not handle returning of an error code
2400:     }
   1:     nsresult rv;
   1:     nsCOMPtr<nsIURI> referrer;
   1:     nsCOMPtr<nsIInputStream> postStream;
   1:     nsCOMPtr<nsIInputStream> headersStream;
   1:     nsCOMPtr<nsISupports> owner;
   1:     PRBool inheritOwner = PR_FALSE;
   1:     PRBool sendReferrer = PR_TRUE;
   1:     nsCOMPtr<nsISHEntry> shEntry;
   1:     nsXPIDLString target;
   1:     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_NORMAL, aLoadFlags);    
   1: 
   1:     NS_ENSURE_ARG(aURI);
   1: 
   1:     // Extract the info from the DocShellLoadInfo struct...
   1:     if (aLoadInfo) {
   1:         aLoadInfo->GetReferrer(getter_AddRefs(referrer));
   1: 
   1:         nsDocShellInfoLoadType lt = nsIDocShellLoadInfo::loadNormal;
   1:         aLoadInfo->GetLoadType(&lt);
   1:         // Get the appropriate loadType from nsIDocShellLoadInfo type
   1:         loadType = ConvertDocShellLoadInfoToLoadType(lt);
   1: 
   1:         aLoadInfo->GetOwner(getter_AddRefs(owner));
   1:         aLoadInfo->GetInheritOwner(&inheritOwner);
   1:         aLoadInfo->GetSHEntry(getter_AddRefs(shEntry));
   1:         aLoadInfo->GetTarget(getter_Copies(target));
   1:         aLoadInfo->GetPostDataStream(getter_AddRefs(postStream));
   1:         aLoadInfo->GetHeadersStream(getter_AddRefs(headersStream));
   1:         aLoadInfo->GetSendReferrer(&sendReferrer);
   1:     }
   1: 
   1: #if defined(PR_LOGGING) && defined(DEBUG)
   1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
   1:         nsCAutoString uristr;
   1:         aURI->GetAsciiSpec(uristr);
   1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
   1:                ("nsDocShell[%p]: loading %s with flags 0x%08x",
   1:                 this, uristr.get(), aLoadFlags));
   1:     }
   1: #endif
   1: 
   1:     if (!shEntry &&
   1:         !LOAD_TYPE_HAS_FLAGS(loadType, LOAD_FLAGS_REPLACE_HISTORY)) {
   1:         // First verify if this is a subframe.
   1:         nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
   1:         GetSameTypeParent(getter_AddRefs(parentAsItem));
   1:         nsCOMPtr<nsIDocShell> parentDS(do_QueryInterface(parentAsItem));
   1:         PRUint32 parentLoadType;
   1: 
3233:         if (parentDS && parentDS != static_cast<nsIDocShell *>(this)) {
   1:             /* OK. It is a subframe. Checkout the 
   1:              * parent's loadtype. If the parent was loaded thro' a history
   1:              * mechanism, then get the SH entry for the child from the parent.
   1:              * This is done to restore frameset navigation while going back/forward.
   1:              * If the parent was loaded through any other loadType, set the
   1:              * child's loadType too accordingly, so that session history does not
   1:              * get confused. 
   1:              */
   1:             
   1:             // Get the parent's load type
   1:             parentDS->GetLoadType(&parentLoadType);            
   1: 
   1:             nsCOMPtr<nsIDocShellHistory> parent(do_QueryInterface(parentAsItem));
   1:             if (parent) {
   1:                 // Get the ShEntry for the child from the parent
   1:                 parent->GetChildSHEntry(mChildOffset, getter_AddRefs(shEntry));
   1:                 // Make some decisions on the child frame's loadType based on the 
   1:                 // parent's loadType. 
   1:                 if (mCurrentURI == nsnull) {
   1:                     // This is a newly created frame. Check for exception cases first. 
   1:                     // By default the subframe will inherit the parent's loadType.
   1:                     if (shEntry && (parentLoadType == LOAD_NORMAL ||
   1:                                     parentLoadType == LOAD_LINK   ||
   1:                                     parentLoadType == LOAD_NORMAL_EXTERNAL)) {
   1:                         // The parent was loaded normally. In this case, this *brand new* child really shouldn't
   1:                         // have a SHEntry. If it does, it could be because the parent is replacing an
   1:                         // existing frame with a new frame, in the onLoadHandler. We don't want this
   1:                         // url to get into session history. Clear off shEntry, and set laod type to
   1:                         // LOAD_BYPASS_HISTORY. 
   1:                         PRBool inOnLoadHandler=PR_FALSE;
   1:                         parentDS->GetIsExecutingOnLoadHandler(&inOnLoadHandler);
   1:                         if (inOnLoadHandler) {
   1:                             loadType = LOAD_NORMAL_REPLACE;
   1:                             shEntry = nsnull;
   1:                         }
   1:                     }   
   1:                     else if (parentLoadType == LOAD_REFRESH) {
   1:                         // Clear shEntry. For refresh loads, we have to load
   1:                         // what comes thro' the pipe, not what's in history.
   1:                         shEntry = nsnull;
   1:                     }
   1:                     else if ((parentLoadType == LOAD_BYPASS_HISTORY) ||
   1:                              (parentLoadType == LOAD_ERROR_PAGE) ||
   1:                               (shEntry && 
   1:                                ((parentLoadType & LOAD_CMD_HISTORY) || 
   1:                                 (parentLoadType == LOAD_RELOAD_NORMAL) || 
   1:                                 (parentLoadType == LOAD_RELOAD_CHARSET_CHANGE)))) {
   1:                         // If the parent url, bypassed history or was loaded from
   1:                         // history, pass on the parent's loadType to the new child 
   1:                         // frame too, so that the child frame will also
   1:                         // avoid getting into history. 
   1:                         loadType = parentLoadType;
   1:                     }
   1:                 }
   1:                 else {
   1:                     // This is a pre-existing subframe. If the load was not originally initiated
   1:                     // by session history, (if (!shEntry) condition succeeded) and mCurrentURI is not null,
   1:                     // it is possible that a parent's onLoadHandler or even self's onLoadHandler is loading 
   1:                     // a new page in this child. Check parent's and self's busy flag  and if it is set,
   1:                     // we don't want this onLoadHandler load to get in to session history.
   1:                     PRUint32 parentBusy = BUSY_FLAGS_NONE;
   1:                     PRUint32 selfBusy = BUSY_FLAGS_NONE;
   1:                     parentDS->GetBusyFlags(&parentBusy);                    
   1:                     GetBusyFlags(&selfBusy);
   1:                     if (((parentBusy & BUSY_FLAGS_BUSY) ||
   1:                          (selfBusy & BUSY_FLAGS_BUSY)) &&
   1:                         shEntry) {
   1:                         loadType = LOAD_NORMAL_REPLACE;
   1:                         shEntry = nsnull; 
   1:                     }
   1:                 }
   1:             } // parent
   1:         } //parentDS
   1:         else {  
   1:             // This is the root docshell. If we got here while  
   1:             // executing an onLoad Handler,this load will not go 
   1:             // into session history.
   1:             PRBool inOnLoadHandler=PR_FALSE;
   1:             GetIsExecutingOnLoadHandler(&inOnLoadHandler);
   1:             if (inOnLoadHandler) {
   1:                 loadType = LOAD_NORMAL_REPLACE;
   1:             }
   1:         } 
   1:     } // !shEntry
   1: 
   1:     if (shEntry) {
   1: #ifdef DEBUG
   1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
   1:               ("nsDocShell[%p]: loading from session history", this));
   1: #endif
   1: 
   1:         rv = LoadHistoryEntry(shEntry, loadType);
   1:     }
   1:     // Perform the load...
   1:     else {
3596:         // We need an owner (a referring principal). 4 possibilities:
3596:         // (1) If the system principal was passed in and we're a typeContent
3596:         //     docshell, inherit the principal from the current document
3596:         //     instead.
3596:         // (2) In all other cases when the principal passed in is not null,
3596:         //     use that principal.
3596:         // (3) If the caller has allowed inheriting from the current document,
   1:         //     or if we're being called from system code (eg chrome JS or pure
   1:         //     C++) then inheritOwner should be true and InternalLoad will get
   1:         //     an owner from the current document. If none of these things are
   1:         //     true, then
3596:         // (4) we pass a null owner into the channel, and an owner will be
3596:         //     created later from the channel's internal data.
   1:         //
   1:         // NOTE: This all only works because the only thing the owner is used  
3596:         //       for in InternalLoad is data:, javascript:, and about:blank
3596:         //       URIs.  For other URIs this would all be dead wrong!
3596:         nsCOMPtr<nsIScriptSecurityManager> secMan =
3596:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
3596:         NS_ENSURE_SUCCESS(rv, rv);
3596: 
3596:         if (owner && mItemType != typeChrome) {
3596:             nsCOMPtr<nsIPrincipal> ownerPrincipal = do_QueryInterface(owner);
3596:             PRBool isSystem;
3596:             rv = secMan->IsSystemPrincipal(ownerPrincipal, &isSystem);
3596:             NS_ENSURE_SUCCESS(rv, rv);
3596:             
3596:             if (isSystem) {
3596:                 owner = nsnull;
3596:                 inheritOwner = PR_TRUE;
3596:             }
3596:         }
   1:         if (!owner && !inheritOwner) {
   1:             // See if there's system or chrome JS code running
   1:             rv = secMan->SubjectPrincipalIsSystem(&inheritOwner);
   1:             if (NS_FAILED(rv)) {
   1:                 // Set it back to false
   1:                 inheritOwner = PR_FALSE;
   1:             }
   1:         }
   1: 
   1:         PRUint32 flags = 0;
   1: 
   1:         if (inheritOwner)
   1:             flags |= INTERNAL_LOAD_FLAGS_INHERIT_OWNER;
   1: 
   1:         if (!sendReferrer)
   1:             flags |= INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER;
   1:             
   1:         if (aLoadFlags & LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP)
   1:             flags |= INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
   1: 
   1:         if (aLoadFlags & LOAD_FLAGS_FIRST_LOAD)
   1:             flags |= INTERNAL_LOAD_FLAGS_FIRST_LOAD;
   1: 
   1:         rv = InternalLoad(aURI,
   1:                           referrer,
   1:                           owner,
   1:                           flags,
   1:                           target.get(),
   1:                           nsnull,         // No type hint
   1:                           postStream,
   1:                           headersStream,
   1:                           loadType,
   1:                           nsnull,         // No SHEntry
   1:                           aFirstParty,
   1:                           nsnull,         // No nsIDocShell
   1:                           nsnull);        // No nsIRequest
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::LoadStream(nsIInputStream *aStream, nsIURI * aURI,
   1:                        const nsACString &aContentType,
   1:                        const nsACString &aContentCharset,
   1:                        nsIDocShellLoadInfo * aLoadInfo)
   1: {
   1:     NS_ENSURE_ARG(aStream);
   1: 
   1:     mAllowKeywordFixup = PR_FALSE;
   1: 
   1:     // if the caller doesn't pass in a URI we need to create a dummy URI. necko
   1:     // currently requires a URI in various places during the load. Some consumers
   1:     // do as well.
   1:     nsCOMPtr<nsIURI> uri = aURI;
   1:     if (!uri) {
   1:         // HACK ALERT
   1:         nsresult rv = NS_OK;
   1:         uri = do_CreateInstance(NS_SIMPLEURI_CONTRACTID, &rv);
   1:         if (NS_FAILED(rv))
   1:             return rv;
   1:         // Make sure that the URI spec "looks" like a protocol and path...
   1:         // For now, just use a bogus protocol called "internal"
   1:         rv = uri->SetSpec(NS_LITERAL_CSTRING("internal:load-stream"));
   1:         if (NS_FAILED(rv))
   1:             return rv;
   1:     }
   1: 
   1:     PRUint32 loadType = LOAD_NORMAL;
   1:     if (aLoadInfo) {
   1:         nsDocShellInfoLoadType lt = nsIDocShellLoadInfo::loadNormal;
   1:         (void) aLoadInfo->GetLoadType(&lt);
   1:         // Get the appropriate LoadType from nsIDocShellLoadInfo type
   1:         loadType = ConvertDocShellLoadInfoToLoadType(lt);
   1:     }
   1: 
   1:     NS_ENSURE_SUCCESS(Stop(nsIWebNavigation::STOP_NETWORK), NS_ERROR_FAILURE);
   1: 
   1:     mLoadType = loadType;
   1: 
   1:     // build up a channel for this stream.
   1:     nsCOMPtr<nsIChannel> channel;
   1:     NS_ENSURE_SUCCESS(NS_NewInputStreamChannel
   1:                       (getter_AddRefs(channel), uri, aStream,
   1:                        aContentType, aContentCharset),
   1:                       NS_ERROR_FAILURE);
   1: 
   1:     nsCOMPtr<nsIURILoader>
   1:         uriLoader(do_GetService(NS_URI_LOADER_CONTRACTID));
   1:     NS_ENSURE_TRUE(uriLoader, NS_ERROR_FAILURE);
   1: 
   1:     NS_ENSURE_SUCCESS(DoChannelLoad(channel, uriLoader), NS_ERROR_FAILURE);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::CreateLoadInfo(nsIDocShellLoadInfo ** aLoadInfo)
   1: {
   1:     nsDocShellLoadInfo *loadInfo = new nsDocShellLoadInfo();
   1:     NS_ENSURE_TRUE(loadInfo, NS_ERROR_OUT_OF_MEMORY);
   1:     nsCOMPtr<nsIDocShellLoadInfo> localRef(loadInfo);
   1: 
   1:     *aLoadInfo = localRef;
   1:     NS_ADDREF(*aLoadInfo);
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: /*
   1:  * Reset state to a new content model within the current document and the document
   1:  * viewer.  Called by the document before initiating an out of band document.write().
   1:  */
   1: NS_IMETHODIMP
   1: nsDocShell::PrepareForNewContentModel()
   1: {
   1:   mEODForCurrentDocument = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::FirePageHideNotification(PRBool aIsUnload)
   1: {
   1:     if (mContentViewer && !mFiredUnloadEvent) {
   1:         // Keep an explicit reference since calling PageHide could release
   1:         // mContentViewer
   1:         nsCOMPtr<nsIContentViewer> kungFuDeathGrip(mContentViewer);
   1:         mFiredUnloadEvent = PR_TRUE;
   1: 
   1:         mContentViewer->PageHide(aIsUnload);
   1: 
8259:         nsAutoTArray<nsCOMPtr<nsIDocShell>, 8> kids;
   1:         PRInt32 i, n = mChildList.Count();
8259:         kids.SetCapacity(n);
   1:         for (i = 0; i < n; i++) {
8259:             kids.AppendElement(do_QueryInterface(ChildAt(i)));
8259:         }
8259: 
8259:         n = kids.Length();
8259:         for (i = 0; i < n; ++i) {
8259:             if (kids[i]) {
8259:                 kids[i]->FirePageHideNotification(aIsUnload);
   1:             }
   1:         }
   1:     }
2400: 
8553:     // Now make sure our editor, if any, is torn down before we go
8553:     // any farther.
8553:     if (mEditorData) {
8553:         mEditorData->TearDownEditor();
8553:     }
8553: 
   1:     return NS_OK;
   1: }
   1: 
   1: //
   1: // Bug 13871: Prevent frameset spoofing
   1: //
   1: // This routine answers: 'Is origin's document from same domain as
   1: // target's document?'
   1: //
   1: /* static */
   1: PRBool
   1: nsDocShell::ValidateOrigin(nsIDocShellTreeItem* aOriginTreeItem,
   1:                            nsIDocShellTreeItem* aTargetTreeItem)
   1: {
   1:     nsCOMPtr<nsIScriptSecurityManager> securityManager =
   1:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
   1:     NS_ENSURE_TRUE(securityManager, PR_FALSE);
   1: 
   1:     nsCOMPtr<nsIPrincipal> subjectPrincipal;
   1:     nsresult rv =
   1:         securityManager->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
   1:     NS_ENSURE_SUCCESS(rv, PR_FALSE);
   1: 
   1:     if (subjectPrincipal) {
   1:         // We're called from JS, check if UniversalBrowserWrite is
   1:         // enabled.
   1:         PRBool ubwEnabled = PR_FALSE;
   1:         rv = securityManager->IsCapabilityEnabled("UniversalBrowserWrite",
   1:                                                   &ubwEnabled);
   1:         NS_ENSURE_SUCCESS(rv, PR_FALSE);
   1: 
   1:         if (ubwEnabled) {
   1:             return PR_TRUE;
   1:         }
   1:     }
   1: 
   1:     // Get origin document principal
   1:     nsCOMPtr<nsIDOMDocument> originDOMDocument =
   1:         do_GetInterface(aOriginTreeItem);
   1:     nsCOMPtr<nsIDocument> originDocument(do_QueryInterface(originDOMDocument));
   1:     NS_ENSURE_TRUE(originDocument, PR_FALSE);
   1:     
   1:     // Get target principal
   1:     nsCOMPtr<nsIDOMDocument> targetDOMDocument =
   1:         do_GetInterface(aTargetTreeItem);
   1:     nsCOMPtr<nsIDocument> targetDocument(do_QueryInterface(targetDOMDocument));
   1:     NS_ENSURE_TRUE(targetDocument, PR_FALSE);
   1: 
3286:     PRBool equal;
   1:     return
3286:         NS_SUCCEEDED(originDocument->NodePrincipal()->
3286:                        Equals(targetDocument->NodePrincipal(), &equal)) &&
3286:         equal;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetEldestPresContext(nsPresContext** aPresContext)
   1: {
   1:     nsresult rv = NS_OK;
   1: 
   1:     NS_ENSURE_ARG_POINTER(aPresContext);
   1:     *aPresContext = nsnull;
   1: 
   1:     nsCOMPtr<nsIContentViewer> viewer = mContentViewer;
   1:     while (viewer) {
   1:         nsCOMPtr<nsIContentViewer> prevViewer;
   1:         viewer->GetPreviousViewer(getter_AddRefs(prevViewer));
   1:         if (prevViewer)
   1:             viewer = prevViewer;
   1:         else {
   1:             nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(viewer));
   1:             if (docv)
   1:                 rv = docv->GetPresContext(aPresContext);
   1:             break;
   1:         }
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetPresContext(nsPresContext ** aPresContext)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aPresContext);
   1:     *aPresContext = nsnull;
   1: 
   1:     if (!mContentViewer)
   1:       return NS_OK;
   1: 
   1:     nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(mContentViewer));
   1:     NS_ENSURE_TRUE(docv, NS_ERROR_NO_INTERFACE);
   1: 
   1:     return docv->GetPresContext(aPresContext);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetPresShell(nsIPresShell ** aPresShell)
   1: {
   1:     nsresult rv = NS_OK;
   1: 
   1:     NS_ENSURE_ARG_POINTER(aPresShell);
   1:     *aPresShell = nsnull;
   1: 
   1:     nsCOMPtr<nsPresContext> presContext;
   1:     (void) GetPresContext(getter_AddRefs(presContext));
   1: 
   1:     if (presContext) {
   1:         NS_IF_ADDREF(*aPresShell = presContext->GetPresShell());
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetEldestPresShell(nsIPresShell** aPresShell)
   1: {
   1:     nsresult rv = NS_OK;
   1: 
   1:     NS_ENSURE_ARG_POINTER(aPresShell);
   1:     *aPresShell = nsnull;
   1: 
   1:     nsCOMPtr<nsPresContext> presContext;
   1:     (void) GetEldestPresContext(getter_AddRefs(presContext));
   1: 
   1:     if (presContext) {
   1:         NS_IF_ADDREF(*aPresShell = presContext->GetPresShell());
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetContentViewer(nsIContentViewer ** aContentViewer)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aContentViewer);
   1: 
   1:     *aContentViewer = mContentViewer;
   1:     NS_IF_ADDREF(*aContentViewer);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetChromeEventHandler(nsIDOMEventTarget* aChromeEventHandler)
   1: {
   1:     nsCOMPtr<nsPIDOMEventTarget> piTarget =
   1:       do_QueryInterface(aChromeEventHandler);
   1:     // Weak reference. Don't addref.
   1:     mChromeEventHandler = piTarget;
   1: 
   1:     NS_ASSERTION(!mScriptGlobal,
   1:                  "SetChromeEventHandler() called after the script global "
   1:                  "object was created! This means that the script global "
   1:                  "object in this docshell won't get the right chrome event "
   1:                  "handler. You really don't want to see this assert, FIX "
   1:                  "YOUR CODE!");
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetChromeEventHandler(nsIDOMEventTarget** aChromeEventHandler)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aChromeEventHandler);
   1:     nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(mChromeEventHandler);
   1:     target.swap(*aChromeEventHandler);
   1:     return NS_OK;
   1: }
   1: 
   1: /* [noscript] void setCurrentURI (in nsIURI uri); */
   1: NS_IMETHODIMP
   1: nsDocShell::SetCurrentURI(nsIURI *aURI)
   1: {
   1:     SetCurrentURI(aURI, nsnull, PR_TRUE);
   1:     return NS_OK;
   1: }
   1: 
   1: PRBool
   1: nsDocShell::SetCurrentURI(nsIURI *aURI, nsIRequest *aRequest,
   1:                           PRBool aFireOnLocationChange)
   1: {
   1: #ifdef PR_LOGGING
   1:     if (gDocShellLeakLog && PR_LOG_TEST(gDocShellLeakLog, PR_LOG_DEBUG)) {
   1:         nsCAutoString spec;
   1:         if (aURI)
   1:             aURI->GetSpec(spec);
   1:         PR_LogPrint("DOCSHELL %p SetCurrentURI %s\n", this, spec.get());
   1:     }
   1: #endif
   1: 
   1:     // We don't want to send a location change when we're displaying an error
   1:     // page, and we don't want to change our idea of "current URI" either
   1:     if (mLoadType == LOAD_ERROR_PAGE) {
   1:         return PR_FALSE;
   1:     }
   1: 
   1:     mCurrentURI = NS_TryToMakeImmutable(aURI);
   1:     
   1:     PRBool isRoot = PR_FALSE;   // Is this the root docshell
   1:     PRBool isSubFrame = PR_FALSE;  // Is this a subframe navigation?
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> root;
   1: 
   1:     GetSameTypeRootTreeItem(getter_AddRefs(root));
3233:     if (root.get() == static_cast<nsIDocShellTreeItem *>(this)) 
   1:     {
   1:         // This is the root docshell
   1:         isRoot = PR_TRUE;
   1:     }
   1:     if (mLSHE) {
   1:         mLSHE->GetIsSubFrame(&isSubFrame);
   1:     }
   1: 
   1:     if (!isSubFrame && !isRoot) {
   1:       /* 
   1:        * We don't want to send OnLocationChange notifications when
   1:        * a subframe is being loaded for the first time, while
   1:        * visiting a frameset page
   1:        */
   1:       return PR_FALSE; 
   1:     }
   1: 
   1:     if (aFireOnLocationChange) {
   1:         FireOnLocationChange(this, aRequest, aURI);
   1:     }
   1:     return !aFireOnLocationChange;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetCharset(char** aCharset)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aCharset);
   1:     *aCharset = nsnull; 
   1: 
   1:     nsCOMPtr<nsIPresShell> presShell;
   1:     GetPresShell(getter_AddRefs(presShell));
   1:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
   1:     nsIDocument *doc = presShell->GetDocument();
   1:     NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
   1:     *aCharset = ToNewCString(doc->GetDocumentCharacterSet());
   1:     if (!*aCharset) {
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetCharset(const char* aCharset)
   1: {
   1:     // set the default charset
   1:     nsCOMPtr<nsIContentViewer> viewer;
   1:     GetContentViewer(getter_AddRefs(viewer));
   1:     if (viewer) {
   1:       nsCOMPtr<nsIMarkupDocumentViewer> muDV(do_QueryInterface(viewer));
   1:       if (muDV) {
   1:         NS_ENSURE_SUCCESS(muDV->SetDefaultCharacterSet(nsDependentCString(aCharset)),
   1:                           NS_ERROR_FAILURE);
   1:       }
   1:     }
   1: 
   1:     // set the charset override
   1:     nsCOMPtr<nsIDocumentCharsetInfo> dcInfo;
   1:     GetDocumentCharsetInfo(getter_AddRefs(dcInfo));
   1:     if (dcInfo) {
   1:       nsCOMPtr<nsIAtom> csAtom;
   1:       csAtom = do_GetAtom(aCharset);
   1:       dcInfo->SetForcedCharset(csAtom);
   1:     }
   1: 
   1:     return NS_OK;
   1: } 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetDocumentCharsetInfo(nsIDocumentCharsetInfo **
   1:                                    aDocumentCharsetInfo)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aDocumentCharsetInfo);
   1: 
   1:     // if the mDocumentCharsetInfo does not exist already, we create it now
   1:     if (!mDocumentCharsetInfo) {
   1:         mDocumentCharsetInfo = do_CreateInstance(NS_DOCUMENTCHARSETINFO_CONTRACTID);
   1:         if (!mDocumentCharsetInfo)
   1:             return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     *aDocumentCharsetInfo = mDocumentCharsetInfo;
   1:     NS_IF_ADDREF(*aDocumentCharsetInfo);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetDocumentCharsetInfo(nsIDocumentCharsetInfo *
   1:                                    aDocumentCharsetInfo)
   1: {
   1:     mDocumentCharsetInfo = aDocumentCharsetInfo;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
8363: nsDocShell::GetChannelIsUnsafe(PRBool *aUnsafe)
8363: {
8363:     *aUnsafe = PR_FALSE;
8363: 
8363:     nsCOMPtr<nsIChannel> channel;
8363:     GetCurrentDocumentChannel(getter_AddRefs(channel));
8363:     if (!channel) {
8363:         return NS_OK;
8363:     }
8363: 
8363:     nsCOMPtr<nsIJARChannel> jarChannel = do_QueryInterface(channel);
8363:     if (!jarChannel) {
8363:         return NS_OK;
8363:     }
8363: 
8363:     return jarChannel->GetIsUnsafe(aUnsafe);
8363: }
8363: 
8363: NS_IMETHODIMP
   1: nsDocShell::GetAllowPlugins(PRBool * aAllowPlugins)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aAllowPlugins);
   1: 
   1:     *aAllowPlugins = mAllowPlugins;
8363:     if (!mAllowPlugins) {
8363:         return NS_OK;
8363:     }
8363: 
8363:     PRBool unsafe;
8363:     *aAllowPlugins = NS_SUCCEEDED(GetChannelIsUnsafe(&unsafe)) && !unsafe;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetAllowPlugins(PRBool aAllowPlugins)
   1: {
   1:     mAllowPlugins = aAllowPlugins;
   1:     //XXX should enable or disable a plugin host
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetAllowJavascript(PRBool * aAllowJavascript)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aAllowJavascript);
   1: 
   1:     *aAllowJavascript = mAllowJavascript;
8363:     if (!mAllowJavascript) {
8363:         return NS_OK;
8363:     }
8363: 
8363:     PRBool unsafe;
8363:     *aAllowJavascript = NS_SUCCEEDED(GetChannelIsUnsafe(&unsafe)) && !unsafe;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetAllowJavascript(PRBool aAllowJavascript)
   1: {
   1:     mAllowJavascript = aAllowJavascript;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::GetAllowMetaRedirects(PRBool * aReturn)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aReturn);
   1: 
   1:     *aReturn = mAllowMetaRedirects;
8363:     if (!mAllowMetaRedirects) {
8363:         return NS_OK;
8363:     }
8363: 
8363:     PRBool unsafe;
8363:     *aReturn = NS_SUCCEEDED(GetChannelIsUnsafe(&unsafe)) && !unsafe;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::SetAllowMetaRedirects(PRBool aValue)
   1: {
   1:     mAllowMetaRedirects = aValue;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::GetAllowSubframes(PRBool * aAllowSubframes)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aAllowSubframes);
   1: 
   1:     *aAllowSubframes = mAllowSubframes;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::SetAllowSubframes(PRBool aAllowSubframes)
   1: {
   1:     mAllowSubframes = aAllowSubframes;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::GetAllowImages(PRBool * aAllowImages)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aAllowImages);
   1: 
   1:     *aAllowImages = mAllowImages;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::SetAllowImages(PRBool aAllowImages)
   1: {
   1:     mAllowImages = aAllowImages;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetDocShellEnumerator(PRInt32 aItemType, PRInt32 aDirection, nsISimpleEnumerator **outEnum)
   1: {
   1:     NS_ENSURE_ARG_POINTER(outEnum);
   1:     *outEnum = nsnull;
   1:     
   1:     nsRefPtr<nsDocShellEnumerator> docShellEnum;
   1:     if (aDirection == ENUMERATE_FORWARDS)
   1:         docShellEnum = new nsDocShellForwardsEnumerator;
   1:     else
   1:         docShellEnum = new nsDocShellBackwardsEnumerator;
   1:     
   1:     if (!docShellEnum) return NS_ERROR_OUT_OF_MEMORY;
   1:     
   1:     nsresult rv = docShellEnum->SetEnumDocShellType(aItemType);
   1:     if (NS_FAILED(rv)) return rv;
   1: 
   1:     rv = docShellEnum->SetEnumerationRootItem((nsIDocShellTreeItem *)this);
   1:     if (NS_FAILED(rv)) return rv;
   1: 
   1:     rv = docShellEnum->First();
   1:     if (NS_FAILED(rv)) return rv;
   1: 
   1:     rv = docShellEnum->QueryInterface(NS_GET_IID(nsISimpleEnumerator), (void **)outEnum);
   1: 
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetAppType(PRUint32 * aAppType)
   1: {
   1:     *aAppType = mAppType;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetAppType(PRUint32 aAppType)
   1: {
   1:     mAppType = aAppType;
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetAllowAuth(PRBool * aAllowAuth)
   1: {
   1:     *aAllowAuth = mAllowAuth;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetAllowAuth(PRBool aAllowAuth)
   1: {
   1:     mAllowAuth = aAllowAuth;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetZoom(float *zoom)
   1: {
   1:     NS_ENSURE_ARG_POINTER(zoom);
   1:     *zoom = 1.0f;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetZoom(float zoom)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetMarginWidth(PRInt32 * aWidth)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aWidth);
   1: 
   1:     *aWidth = mMarginWidth;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetMarginWidth(PRInt32 aWidth)
   1: {
   1:     mMarginWidth = aWidth;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetMarginHeight(PRInt32 * aHeight)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aHeight);
   1: 
   1:     *aHeight = mMarginHeight;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetMarginHeight(PRInt32 aHeight)
   1: {
   1:     mMarginHeight = aHeight;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetBusyFlags(PRUint32 * aBusyFlags)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aBusyFlags);
   1: 
   1:     *aBusyFlags = mBusyFlags;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::TabToTreeOwner(PRBool aForward, PRBool* aTookFocus)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aTookFocus);
   1:     
   1:     nsCOMPtr<nsIWebBrowserChromeFocus> chromeFocus = do_GetInterface(mTreeOwner);
   1:     if (chromeFocus) {
   1:         if (aForward)
   1:             *aTookFocus = NS_SUCCEEDED(chromeFocus->FocusNextElement());
   1:         else
   1:             *aTookFocus = NS_SUCCEEDED(chromeFocus->FocusPrevElement());
   1:     } else
   1:         *aTookFocus = PR_FALSE;
   1:     
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetSecurityUI(nsISecureBrowserUI **aSecurityUI)
   1: {
   1:     NS_IF_ADDREF(*aSecurityUI = mSecurityUI);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetSecurityUI(nsISecureBrowserUI *aSecurityUI)
   1: {
   1:     mSecurityUI = aSecurityUI;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetUseErrorPages(PRBool *aUseErrorPages)
   1: {
   1:     *aUseErrorPages = mUseErrorPages;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetUseErrorPages(PRBool aUseErrorPages)
   1: {
   1:     // If mUseErrorPages is set explicitly, stop observing the pref.
   1:     if (mObserveErrorPages) {
   1:         nsCOMPtr<nsIPrefBranch2> prefs(do_QueryInterface(mPrefs));
   1:         if (prefs) {
   1:             prefs->RemoveObserver("browser.xul.error_pages.enabled", this);
   1:             mObserveErrorPages = PR_FALSE;
   1:         }
   1:     }
   1:     mUseErrorPages = aUseErrorPages;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetPreviousTransIndex(PRInt32 *aPreviousTransIndex)
   1: {
   1:     *aPreviousTransIndex = mPreviousTransIndex;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetLoadedTransIndex(PRInt32 *aLoadedTransIndex)
   1: {
   1:     *aLoadedTransIndex = mLoadedTransIndex;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::HistoryPurged(PRInt32 aNumEntries)
   1: {
   1:     // These indices are used for fastback cache eviction, to determine
   1:     // which session history entries are candidates for content viewer
   1:     // eviction.  We need to adjust by the number of entries that we
   1:     // just purged from history, so that we look at the right session history
   1:     // entries during eviction.
   1:     mPreviousTransIndex = PR_MAX(-1, mPreviousTransIndex - aNumEntries);
   1:     mLoadedTransIndex = PR_MAX(0, mLoadedTransIndex - aNumEntries);
   1: 
   1:     PRInt32 count = mChildList.Count();
   1:     for (PRInt32 i = 0; i < count; ++i) {
   1:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
   1:         if (shell) {
   1:             shell->HistoryPurged(aNumEntries);
   1:         }
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetSessionStorageForURI(nsIURI* aURI,
   1:                                     nsIDOMStorage** aStorage)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aStorage);
   1: 
   1:     *aStorage = nsnull;
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> topItem;
   1:     nsresult rv = GetSameTypeRootTreeItem(getter_AddRefs(topItem));
   1:     if (NS_FAILED(rv))
   1:         return rv;
   1: 
   1:     if (!topItem)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     nsCOMPtr<nsIDocShell> topDocShell = do_QueryInterface(topItem);
   1:     if (topDocShell != this)
   1:         return topDocShell->GetSessionStorageForURI(aURI, aStorage);
   1: 
   1:     nsCAutoString currentDomain;
   1:     rv = aURI->GetAsciiHost(currentDomain);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     if (currentDomain.IsEmpty())
   1:         return NS_OK;
   1: 
   1:     if (!mStorages.Get(currentDomain, aStorage)) {
   1:         nsCOMPtr<nsIDOMStorage> newstorage =
   1:             do_CreateInstance("@mozilla.org/dom/storage;1");
   1:         if (!newstorage)
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:         nsCOMPtr<nsPIDOMStorage> pistorage = do_QueryInterface(newstorage);
   1:         if (!pistorage)
   1:             return NS_ERROR_FAILURE;
   1:         pistorage->Init(aURI, NS_ConvertUTF8toUTF16(currentDomain), PR_FALSE);
   1: 
   1:         if (!mStorages.Put(currentDomain, newstorage))
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1: 		
   1:         *aStorage = newstorage;
   1:         NS_ADDREF(*aStorage);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::AddSessionStorage(const nsACString& aDomain,
   1:                               nsIDOMStorage* aStorage)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aStorage);
   1: 
   1:     if (aDomain.IsEmpty())
   1:         return NS_OK;
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> topItem;
   1:     nsresult rv = GetSameTypeRootTreeItem(getter_AddRefs(topItem));
   1:     if (NS_FAILED(rv))
   1:         return rv;
   1: 
   1:     if (topItem) {
   1:         nsCOMPtr<nsIDocShell> topDocShell = do_QueryInterface(topItem);
   1:         if (topDocShell == this) {
   1:             if (!mStorages.Put(aDomain, aStorage))
   1:                 return NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1:         else {
   1:             return topDocShell->AddSessionStorage(aDomain, aStorage);
   1:         }
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetCurrentDocumentChannel(nsIChannel** aResult)
   1: {
   1:     *aResult = nsnull;
   1:     if (!mContentViewer)
   1:         return NS_OK;
   1: 
   1:     nsCOMPtr<nsIDOMDocument> domDoc;
   1:     nsresult rv = mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
   1:     if (NS_FAILED(rv))
   1:         return rv;
   1: 
   1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
   1:     if (doc) {
   1:       *aResult = doc->GetChannel();
   1:       NS_IF_ADDREF(*aResult);
   1:     }
   1:   
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIDocShellTreeItem
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetName(PRUnichar ** aName)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aName);
   1:     *aName = ToNewUnicode(mName);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetName(const PRUnichar * aName)
   1: {
   1:     mName = aName;              // this does a copy of aName
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::NameEquals(const PRUnichar *aName, PRBool *_retval)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aName);
   1:     NS_ENSURE_ARG_POINTER(_retval);
   1:     *_retval = mName.Equals(aName);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetItemType(PRInt32 * aItemType)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aItemType);
   1: 
   1:     *aItemType = mItemType;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetItemType(PRInt32 aItemType)
   1: {
   1:     NS_ENSURE_ARG((aItemType == typeChrome) || (typeContent == aItemType));
   1: 
   1:     // Only allow setting the type on root docshells.  Those would be the ones
   1:     // that have the docloader service as mParent or have no mParent at all.
   1:     nsCOMPtr<nsIDocumentLoader> docLoaderService =
   1:         do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
   1:     NS_ENSURE_TRUE(docLoaderService, NS_ERROR_UNEXPECTED);
   1:     
   1:     NS_ENSURE_STATE(!mParent || mParent == docLoaderService);
   1: 
   1:     mItemType = aItemType;
   1: 
   1:     // disable auth prompting for anything but content
   1:     mAllowAuth = mItemType == typeContent; 
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetParent(nsIDocShellTreeItem ** aParent)
   1: {
   1:     if (!mParent) {
   1:         *aParent = nsnull;
   1:     } else {
   1:         CallQueryInterface(mParent, aParent);
   1:     }
   1:     // Note that in the case when the parent is not an nsIDocShellTreeItem we
   1:     // don't want to throw; we just want to return null.
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::SetDocLoaderParent(nsDocLoader * aParent)
   1: {
   1:     nsDocLoader::SetDocLoaderParent(aParent);
   1: 
   1:     // Curse ambiguous nsISupports inheritance!
   1:     nsISupports* parent = GetAsSupports(aParent);
   1: 
   1:     // If parent is another docshell, we inherit all their flags for
   1:     // allowing plugins, scripting etc.
   1:     nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(parent));
   1:     if (parentAsDocShell)
   1:     {
   1:         PRBool value;
   1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowPlugins(&value)))
   1:         {
   1:             SetAllowPlugins(value);
   1:         }
   1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowJavascript(&value)))
   1:         {
   1:             SetAllowJavascript(value);
   1:         }
   1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowMetaRedirects(&value)))
   1:         {
   1:             SetAllowMetaRedirects(value);
   1:         }
   1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowSubframes(&value)))
   1:         {
   1:             SetAllowSubframes(value);
   1:         }
   1:         if (NS_SUCCEEDED(parentAsDocShell->GetAllowImages(&value)))
   1:         {
   1:             SetAllowImages(value);
   1:         }
   1:     }
   1: 
   1:     nsCOMPtr<nsIURIContentListener> parentURIListener(do_GetInterface(parent));
   1:     if (parentURIListener)
   1:         mContentListener->SetParentContentListener(parentURIListener);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetSameTypeParent(nsIDocShellTreeItem ** aParent)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aParent);
   1:     *aParent = nsnull;
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> parent =
   1:         do_QueryInterface(GetAsSupports(mParent));
   1:     if (!parent)
   1:         return NS_OK;
   1: 
   1:     PRInt32 parentType;
   1:     NS_ENSURE_SUCCESS(parent->GetItemType(&parentType), NS_ERROR_FAILURE);
   1: 
   1:     if (parentType == mItemType) {
   1:         parent.swap(*aParent);
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetRootTreeItem(nsIDocShellTreeItem ** aRootTreeItem)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aRootTreeItem);
3233:     *aRootTreeItem = static_cast<nsIDocShellTreeItem *>(this);
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> parent;
   1:     NS_ENSURE_SUCCESS(GetParent(getter_AddRefs(parent)), NS_ERROR_FAILURE);
   1:     while (parent) {
   1:         *aRootTreeItem = parent;
   1:         NS_ENSURE_SUCCESS((*aRootTreeItem)->GetParent(getter_AddRefs(parent)),
   1:                           NS_ERROR_FAILURE);
   1:     }
   1:     NS_ADDREF(*aRootTreeItem);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetSameTypeRootTreeItem(nsIDocShellTreeItem ** aRootTreeItem)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aRootTreeItem);
3233:     *aRootTreeItem = static_cast<nsIDocShellTreeItem *>(this);
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> parent;
   1:     NS_ENSURE_SUCCESS(GetSameTypeParent(getter_AddRefs(parent)),
   1:                       NS_ERROR_FAILURE);
   1:     while (parent) {
   1:         *aRootTreeItem = parent;
   1:         NS_ENSURE_SUCCESS((*aRootTreeItem)->
   1:                           GetSameTypeParent(getter_AddRefs(parent)),
   1:                           NS_ERROR_FAILURE);
   1:     }
   1:     NS_ADDREF(*aRootTreeItem);
   1:     return NS_OK;
   1: }
   1: 
   1: /* static */
   1: PRBool
   1: nsDocShell::CanAccessItem(nsIDocShellTreeItem* aTargetItem,
   1:                           nsIDocShellTreeItem* aAccessingItem,
   1:                           PRBool aConsiderOpener)
   1: {
   1:     NS_PRECONDITION(aTargetItem, "Must have target item!");
   1: 
   1:     if (!gValidateOrigin || !aAccessingItem) {
   1:         // Good to go
   1:         return PR_TRUE;
   1:     }
   1: 
   1:     // XXXbz should we care if aAccessingItem or the document therein is
   1:     // chrome?  Should those get extra privileges?
   1: 
   1:     // Now do a security check
   1:     // Bug 13871: Prevent frameset spoofing
   1:     //     See BugSplat 336170, 338737 and XP_FindNamedContextInList in
   1:     //     the classic codebase
   1:     //     Nav's behaviour was:
   1:     //         - pref controlled: "browser.frame.validate_origin" 
   1:     //           (gValidateOrigin)
   1:     //         - allow load if host of target or target's parent is same
   1:     //           as host of origin
   1:     //         - allow load if target is a top level window
   1:     
   1:     //     We are going to be a little more restrictive, with the
   1:     //     following algorithm:
   1:     //         - pref controlled in the same way
   1:     //         - allow access if the two treeitems are in the same tree
   1:     //         - allow access if the aTargetItem or one of its ancestors
   1:     //           has the same origin as aAccessingItem
   1:     //         - allow access if the target is a toplevel window and we can
   1:     //           access its opener.  Note that we only allow one level of
   1:     //           recursion there.
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> targetRoot;
   1:     aTargetItem->GetSameTypeRootTreeItem(getter_AddRefs(targetRoot));
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> accessingRoot;
   1:     aAccessingItem->GetSameTypeRootTreeItem(getter_AddRefs(accessingRoot));
   1: 
   1:     if (targetRoot == accessingRoot) {
   1:         return PR_TRUE;
   1:     }
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> target = aTargetItem;
   1:     do {
   1:         if (ValidateOrigin(aAccessingItem, target)) {
   1:             return PR_TRUE;
   1:         }
   1:             
   1:         nsCOMPtr<nsIDocShellTreeItem> parent;
   1:         target->GetSameTypeParent(getter_AddRefs(parent));
   1:         parent.swap(target);
   1:     } while (target);
   1: 
   1:     if (aTargetItem != targetRoot) {
   1:         // target is a subframe, not in accessor's frame hierarchy, and all its
   1:         // ancestors have origins different from that of the accessor. Don't
   1:         // allow access.
   1:         return PR_FALSE;
   1:     }
   1: 
   1:     if (!aConsiderOpener) {
   1:         // All done here
   1:         return PR_FALSE;
   1:     }
   1: 
   1:     nsCOMPtr<nsIDOMWindow> targetWindow(do_GetInterface(aTargetItem));
   1:     nsCOMPtr<nsIDOMWindowInternal> targetInternal(do_QueryInterface(targetWindow));
   1:     if (!targetInternal) {
   1:         NS_ERROR("This should not happen, really");
   1:         return PR_FALSE;
   1:     }
   1: 
   1:     nsCOMPtr<nsIDOMWindowInternal> targetOpener;
   1:     targetInternal->GetOpener(getter_AddRefs(targetOpener));
   1:     nsCOMPtr<nsIWebNavigation> openerWebNav(do_GetInterface(targetOpener));
   1:     nsCOMPtr<nsIDocShellTreeItem> openerItem(do_QueryInterface(openerWebNav));
   1: 
   1:     if (!openerItem) {
   1:         return PR_FALSE;
   1:     }
   1: 
   1:     return CanAccessItem(openerItem, aAccessingItem, PR_FALSE);    
   1: }
   1: 
   1: static PRBool
   1: ItemIsActive(nsIDocShellTreeItem *aItem)
   1: {
   1:     nsCOMPtr<nsIDOMWindow> tmp(do_GetInterface(aItem));
   1:     nsCOMPtr<nsIDOMWindowInternal> window(do_QueryInterface(tmp));
   1: 
   1:     if (window) {
   1:         PRBool isClosed;
   1: 
   1:         if (NS_SUCCEEDED(window->GetClosed(&isClosed)) && !isClosed) {
   1:             return PR_TRUE;
   1:         }
   1:     }
   1: 
   1:     return PR_FALSE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::FindItemWithName(const PRUnichar * aName,
   1:                              nsISupports * aRequestor,
   1:                              nsIDocShellTreeItem * aOriginalRequestor,
   1:                              nsIDocShellTreeItem ** _retval)
   1: {
   1:     NS_ENSURE_ARG(aName);
   1:     NS_ENSURE_ARG_POINTER(_retval);
   1: 
   1:     // If we don't find one, we return NS_OK and a null result
   1:     *_retval = nsnull;
   1: 
   1:     if (!*aName)
   1:         return NS_OK;
   1: 
   1:     if (!aRequestor)
   1:     {
   1:         nsCOMPtr<nsIDocShellTreeItem> foundItem;
   1: 
   1:         // This is the entry point into the target-finding algorithm.  Check
   1:         // for special names.  This should only be done once, hence the check
   1:         // for a null aRequestor.
   1: 
   1:         nsDependentString name(aName);
   1:         if (name.LowerCaseEqualsLiteral("_self")) {
   1:             foundItem = this;
   1:         }
   1:         else if (name.LowerCaseEqualsLiteral("_blank") ||
   1:                  name.LowerCaseEqualsLiteral("_new"))
   1:         {
   1:             // Just return null.  Caller must handle creating a new window with
   1:             // a blank name himself.
   1:             return NS_OK;
   1:         }
   1:         else if (name.LowerCaseEqualsLiteral("_parent"))
   1:         {
   1:             GetSameTypeParent(getter_AddRefs(foundItem));
   1:             if(!foundItem)
   1:                 foundItem = this;
   1:         }
   1:         else if (name.LowerCaseEqualsLiteral("_top"))
   1:         {
   1:             GetSameTypeRootTreeItem(getter_AddRefs(foundItem));
   1:             NS_ASSERTION(foundItem, "Must have this; worst case it's us!");
   1:         }
   1:         // _main is an IE target which should be case-insensitive but isn't
   1:         // see bug 217886 for details
   1:         else if (name.LowerCaseEqualsLiteral("_content") ||
   1:                  name.EqualsLiteral("_main"))
   1:         {
   1:             // Must pass our same type root as requestor to the
   1:             // treeowner to make sure things work right.
   1:             nsCOMPtr<nsIDocShellTreeItem> root;
   1:             GetSameTypeRootTreeItem(getter_AddRefs(root));
   1:             if (mTreeOwner) {
   1:                 NS_ASSERTION(root, "Must have this; worst case it's us!");
   1:                 mTreeOwner->FindItemWithName(aName, root, aOriginalRequestor,
   1:                                              getter_AddRefs(foundItem));
   1:             }
   1: #ifdef DEBUG
   1:             else {
   1:                 NS_ERROR("Someone isn't setting up the tree owner.  "
   1:                          "You might like to try that.  "
   1:                          "Things will.....you know, work.");
   1:                 // Note: _content should always exist.  If we don't have one
   1:                 // hanging off the treeowner, just create a named window....
   1:                 // so don't return here, in case we did that and can now find
   1:                 // it.                
   1:                 // XXXbz should we be using |root| instead of creating
   1:                 // a new window?
   1:             }
   1: #endif
   1:         }
   1: 
   1:         if (foundItem && !CanAccessItem(foundItem, aOriginalRequestor)) {
   1:             foundItem = nsnull;
   1:         }
   1: 
   1:         if (foundItem) {
   1:             // We return foundItem here even if it's not an active
   1:             // item since all the names we've dealt with so far are
   1:             // special cases that we won't bother looking for further.
   1: 
   1:             foundItem.swap(*_retval);
   1:             return NS_OK;
   1:         }
   1:     }
   1: 
   1:     // Keep looking
   1:         
   1:     // First we check our name.
   1:     if (mName.Equals(aName) && ItemIsActive(this) &&
   1:         CanAccessItem(this, aOriginalRequestor)) {
   1:         NS_ADDREF(*_retval = this);
   1:         return NS_OK;
   1:     }
   1: 
   1:     // This QI may fail, but the places where we want to compare, comparing
   1:     // against nsnull serves the same purpose.
   1:     nsCOMPtr<nsIDocShellTreeItem> reqAsTreeItem(do_QueryInterface(aRequestor));
   1: 
   1:     // Second we check our children making sure not to ask a child if
   1:     // it is the aRequestor.
   1: #ifdef DEBUG
   1:     nsresult rv =
   1: #endif
   1:     FindChildWithName(aName, PR_TRUE, PR_TRUE, reqAsTreeItem,
   1:                       aOriginalRequestor, _retval);
   1:     NS_ASSERTION(NS_SUCCEEDED(rv),
   1:                  "FindChildWithName should not be failing here.");
   1:     if (*_retval)
   1:         return NS_OK;
   1:         
   1:     // Third if we have a parent and it isn't the requestor then we
   1:     // should ask it to do the search.  If it is the requestor we
   1:     // should just stop here and let the parent do the rest.  If we
   1:     // don't have a parent, then we should ask the
   1:     // docShellTreeOwner to do the search.
   1:     nsCOMPtr<nsIDocShellTreeItem> parentAsTreeItem =
   1:         do_QueryInterface(GetAsSupports(mParent));
   1:     if (parentAsTreeItem) {
   1:         if (parentAsTreeItem == reqAsTreeItem)
   1:             return NS_OK;
   1: 
   1:         PRInt32 parentType;
   1:         parentAsTreeItem->GetItemType(&parentType);
   1:         if (parentType == mItemType) {
   1:             return parentAsTreeItem->
   1:                 FindItemWithName(aName,
3233:                                  static_cast<nsIDocShellTreeItem*>
3233:                                             (this),
   1:                                  aOriginalRequestor,
   1:                                  _retval);
   1:         }
   1:     }
   1: 
   1:     // If the parent is null or not of the same type fall through and ask tree
   1:     // owner.
   1: 
   1:     // This may fail, but comparing against null serves the same purpose
   1:     nsCOMPtr<nsIDocShellTreeOwner>
   1:         reqAsTreeOwner(do_QueryInterface(aRequestor));
   1: 
   1:     if (mTreeOwner && mTreeOwner != reqAsTreeOwner) {
   1:         return mTreeOwner->
   1:             FindItemWithName(aName, this, aOriginalRequestor, _retval);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetTreeOwner(nsIDocShellTreeOwner ** aTreeOwner)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aTreeOwner);
   1: 
   1:     *aTreeOwner = mTreeOwner;
   1:     NS_IF_ADDREF(*aTreeOwner);
   1:     return NS_OK;
   1: }
   1: 
   1: #ifdef DEBUG_DOCSHELL_FOCUS
   1: static void 
1160: PrintDocTree(nsIDocShellTreeItem * aParentNode, int aLevel)
   1: {
   1:   for (PRInt32 i=0;i<aLevel;i++) printf("  ");
   1: 
   1:   PRInt32 childWebshellCount;
   1:   aParentNode->GetChildCount(&childWebshellCount);
   1:   nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(aParentNode));
   1:   PRInt32 type;
1160:   aParentNode->GetItemType(&type);
   1:   nsCOMPtr<nsIPresShell> presShell;
   1:   parentAsDocShell->GetPresShell(getter_AddRefs(presShell));
   1:   nsCOMPtr<nsPresContext> presContext;
   1:   parentAsDocShell->GetPresContext(getter_AddRefs(presContext));
   1:   nsIDocument *doc = presShell->GetDocument();
   1: 
   1:   nsCOMPtr<nsIDOMWindowInternal> domwin(doc->GetWindow());
   1: 
   1:   nsCOMPtr<nsIWidget> widget;
   1:   nsIViewManager* vm = presShell->GetViewManager();
   1:   if (vm) {
   1:     vm->GetWidget(getter_AddRefs(widget));
   1:   }
  58:   nsIContent* rootContent = doc->GetRootContent();
   1: 
   1:   printf("DS %p  Ty %s  Doc %p DW %p EM %p CN %p\n",  
  58:     (void*)parentAsDocShell.get(), 
   1:     type==nsIDocShellTreeItem::typeChrome?"Chr":"Con", 
  58:      (void*)doc, (void*)domwin.get(),
  58:      (void*)presContext->EventStateManager(), (void*)rootContent);
   1: 
   1:   if (childWebshellCount > 0) {
   1:     for (PRInt32 i=0;i<childWebshellCount;i++) {
   1:       nsCOMPtr<nsIDocShellTreeItem> child;
   1:       aParentNode->GetChildAt(i, getter_AddRefs(child));
1160:       PrintDocTree(child, aLevel+1);
   1:     }
   1:   }
   1: }
   1: 
   1: static void 
1160: PrintDocTree(nsIDocShellTreeItem * aParentNode)
   1: {
   1:   NS_ASSERTION(aParentNode, "Pointer is null!");
   1: 
   1:   nsCOMPtr<nsIDocShellTreeItem> parentItem;
1160:   aParentNode->GetParent(getter_AddRefs(parentItem));
   1:   while (parentItem) {
   1:     nsCOMPtr<nsIDocShellTreeItem>tmp;
   1:     parentItem->GetParent(getter_AddRefs(tmp));
   1:     if (!tmp) {
   1:       break;
   1:     }
   1:     parentItem = tmp;
   1:   }
   1: 
   1:   if (!parentItem) {
1160:     parentItem = aParentNode;
1160:   }
1160: 
1160:   PrintDocTree(parentItem, 0);
   1: }
   1: #endif
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetTreeOwner(nsIDocShellTreeOwner * aTreeOwner)
   1: {
   1: #ifdef DEBUG_DOCSHELL_FOCUS
1160:     nsCOMPtr<nsIDocShellTreeItem> item(do_QueryInterface(aTreeOwner));
1160:     if (item) {
1160:       PrintDocTree(item);
   1:     }
   1: #endif
   1: 
   1:     // Don't automatically set the progress based on the tree owner for frames
   1:     if (!IsFrame()) {
   1:         nsCOMPtr<nsIWebProgress> webProgress =
   1:             do_QueryInterface(GetAsSupports(this));
   1: 
   1:         if (webProgress) {
   1:             nsCOMPtr<nsIWebProgressListener>
   1:                 oldListener(do_QueryInterface(mTreeOwner));
   1:             nsCOMPtr<nsIWebProgressListener>
   1:                 newListener(do_QueryInterface(aTreeOwner));
   1: 
   1:             if (oldListener) {
   1:                 webProgress->RemoveProgressListener(oldListener);
   1:             }
   1: 
   1:             if (newListener) {
   1:                 webProgress->AddProgressListener(newListener,
   1:                                                  nsIWebProgress::NOTIFY_ALL);
   1:             }
   1:         }
   1:     }
   1: 
   1:     mTreeOwner = aTreeOwner;    // Weak reference per API
   1: 
   1:     PRInt32 i, n = mChildList.Count();
   1:     for (i = 0; i < n; i++) {
   1:         nsCOMPtr<nsIDocShellTreeItem> child = do_QueryInterface(ChildAt(i));
   1:         NS_ENSURE_TRUE(child, NS_ERROR_FAILURE);
   1:         PRInt32 childType = ~mItemType; // Set it to not us in case the get fails
   1:         child->GetItemType(&childType); // We don't care if this fails, if it does we won't set the owner
   1:         if (childType == mItemType)
   1:             child->SetTreeOwner(aTreeOwner);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
1585: nsDocShell::SetChildOffset(PRUint32 aChildOffset)
   1: {
   1:     mChildOffset = aChildOffset;
   1:     return NS_OK;
   1: }
   1: 
2400: NS_IMETHODIMP
2400: nsDocShell::GetIsInUnload(PRBool* aIsInUnload)
2400: {
2400:     *aIsInUnload = mFiredUnloadEvent;
2400:     return NS_OK;
2400: }
2400: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIDocShellTreeNode
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetChildCount(PRInt32 * aChildCount)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aChildCount);
   1:     *aChildCount = mChildList.Count();
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::AddChild(nsIDocShellTreeItem * aChild)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aChild);
   1: 
   1:     nsRefPtr<nsDocLoader> childAsDocLoader = GetAsDocLoader(aChild);
   1:     NS_ENSURE_TRUE(childAsDocLoader, NS_ERROR_UNEXPECTED);
   1: 
   1:     // Make sure we're not creating a loop in the docshell tree
   1:     nsDocLoader* ancestor = this;
   1:     do {
   1:         if (childAsDocLoader == ancestor) {
   1:             return NS_ERROR_ILLEGAL_VALUE;
   1:         }
   1:         ancestor = ancestor->GetParent();
   1:     } while (ancestor);
   1:     
   1:     // Make sure to remove the child from its current parent.
   1:     nsDocLoader* childsParent = childAsDocLoader->GetParent();
   1:     if (childsParent) {
   1:         childsParent->RemoveChildLoader(childAsDocLoader);
   1:     }
   1: 
   1:     // Make sure to clear the treeowner in case this child is a different type
   1:     // from us.
   1:     aChild->SetTreeOwner(nsnull);
   1:     
   1:     nsresult res = AddChildLoader(childAsDocLoader);
   1:     NS_ENSURE_SUCCESS(res, res);
1585:     NS_ASSERTION(mChildList.Count() > 0,
1585:                  "child list must not be empty after a successful add");
   1: 
   1:     // Set the child's index in the parent's children list 
   1:     // XXX What if the parent had different types of children?
   1:     // XXX in that case docshell hierarchy and SH hierarchy won't match.
1585:     {
1585:         nsCOMPtr<nsIDocShell> childDocShell = do_QueryInterface(aChild);
1585:         if (childDocShell)
1585:             childDocShell->SetChildOffset(mChildList.Count() - 1);
1585:     }
   1: 
   1:     /* Set the child's global history if the parent has one */
   1:     if (mGlobalHistory) {
   1:         nsCOMPtr<nsIDocShellHistory>
   1:             dsHistoryChild(do_QueryInterface(aChild));
   1:         if (dsHistoryChild)
   1:             dsHistoryChild->SetUseGlobalHistory(PR_TRUE);
   1:     }
   1: 
   1: 
   1:     PRInt32 childType = ~mItemType;     // Set it to not us in case the get fails
   1:     aChild->GetItemType(&childType);
   1:     if (childType != mItemType)
   1:         return NS_OK;
   1:     // Everything below here is only done when the child is the same type.
   1: 
   1: 
   1:     aChild->SetTreeOwner(mTreeOwner);
   1: 
   1:     nsCOMPtr<nsIDocShell> childAsDocShell(do_QueryInterface(aChild));
   1:     if (!childAsDocShell)
   1:         return NS_OK;
   1: 
   1:     // charset, style-disabling, and zoom will be inherited in SetupNewViewer()
   1: 
   1:     // Now take this document's charset and set the parentCharset field of the 
   1:     // child's DocumentCharsetInfo to it. We'll later use that field, in the 
   1:     // loading process, for the charset choosing algorithm.
   1:     // If we fail, at any point, we just return NS_OK.
   1:     // This code has some performance impact. But this will be reduced when 
   1:     // the current charset will finally be stored as an Atom, avoiding the
   1:     // alias resolution extra look-up.
   1: 
   1:     // we are NOT going to propagate the charset is this Chrome's docshell
   1:     if (mItemType == nsIDocShellTreeItem::typeChrome)
   1:         return NS_OK;
   1: 
   1:     // get the child's docCSInfo object
   1:     nsCOMPtr<nsIDocumentCharsetInfo> dcInfo = NULL;
   1:     res = childAsDocShell->GetDocumentCharsetInfo(getter_AddRefs(dcInfo));
   1:     if (NS_FAILED(res) || (!dcInfo))
   1:         return NS_OK;
   1: 
   1:     // get the parent's current charset
   1:     nsCOMPtr<nsIDocumentViewer> docv(do_QueryInterface(mContentViewer));
   1:     if (!docv)
   1:         return NS_OK;
   1:     nsCOMPtr<nsIDocument> doc;
   1:     res = docv->GetDocument(getter_AddRefs(doc));
   1:     if (NS_FAILED(res) || (!doc))
   1:         return NS_OK;
   1:     const nsACString &parentCS = doc->GetDocumentCharacterSet();
   1: 
   1:     PRBool isWyciwyg = PR_FALSE;
   1: 
   1:     if (mCurrentURI) {
   1:         // Check if the url is wyciwyg
   1:         mCurrentURI->SchemeIs("wyciwyg", &isWyciwyg);      
   1:     }
   1: 
   1:     if (!isWyciwyg) {
   1:         // If this docshell is loaded from a wyciwyg: URI, don't
   1:         // advertise our charset since it does not in any way reflect
   1:         // the actual source charset, which is what we're trying to
   1:         // expose here.
   1: 
   1:         // set the child's parentCharset
   1:         nsCOMPtr<nsIAtom> parentCSAtom(do_GetAtom(parentCS));
   1:         res = dcInfo->SetParentCharset(parentCSAtom);
   1:         if (NS_FAILED(res))
   1:             return NS_OK;
   1: 
   1:         PRInt32 charsetSource = doc->GetDocumentCharacterSetSource();
   1: 
   1:         // set the child's parentCharset
   1:         res = dcInfo->SetParentCharsetSource(charsetSource);
   1:         if (NS_FAILED(res))
   1:             return NS_OK;
   1:     }
   1: 
   1:     // printf("### 1 >>> Adding child. Parent CS = %s. ItemType = %d.\n", NS_LossyConvertUTF16toASCII(parentCS).get(), mItemType);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::RemoveChild(nsIDocShellTreeItem * aChild)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aChild);
   1: 
   1:     nsRefPtr<nsDocLoader> childAsDocLoader = GetAsDocLoader(aChild);
   1:     NS_ENSURE_TRUE(childAsDocLoader, NS_ERROR_UNEXPECTED);
   1:     
   1:     nsresult rv = RemoveChildLoader(childAsDocLoader);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     
   1:     aChild->SetTreeOwner(nsnull);
   1: 
   1:     return nsDocLoader::AddDocLoaderAsChildOfRoot(childAsDocLoader);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetChildAt(PRInt32 aIndex, nsIDocShellTreeItem ** aChild)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aChild);
   1: 
   1: #ifdef DEBUG
   1:     if (aIndex < 0) {
   1:       NS_WARNING("Negative index passed to GetChildAt");
   1:     }
   1:     else if (aIndex >= mChildList.Count()) {
   1:       NS_WARNING("Too large an index passed to GetChildAt");
   1:     }
   1: #endif
   1: 
   1:     nsIDocumentLoader* child = SafeChildAt(aIndex);
   1:     NS_ENSURE_TRUE(child, NS_ERROR_UNEXPECTED);
   1:     
   1:     return CallQueryInterface(child, aChild);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::FindChildWithName(const PRUnichar * aName,
   1:                               PRBool aRecurse, PRBool aSameType,
   1:                               nsIDocShellTreeItem * aRequestor,
   1:                               nsIDocShellTreeItem * aOriginalRequestor,
   1:                               nsIDocShellTreeItem ** _retval)
   1: {
   1:     NS_ENSURE_ARG(aName);
   1:     NS_ENSURE_ARG_POINTER(_retval);
   1: 
   1:     *_retval = nsnull;          // if we don't find one, we return NS_OK and a null result 
   1: 
   1:     if (!*aName)
   1:         return NS_OK;
   1: 
   1:     nsXPIDLString childName;
   1:     PRInt32 i, n = mChildList.Count();
   1:     for (i = 0; i < n; i++) {
   1:         nsCOMPtr<nsIDocShellTreeItem> child = do_QueryInterface(ChildAt(i));
   1:         NS_ENSURE_TRUE(child, NS_ERROR_FAILURE);
   1:         PRInt32 childType;
   1:         child->GetItemType(&childType);
   1: 
   1:         if (aSameType && (childType != mItemType))
   1:             continue;
   1: 
   1:         PRBool childNameEquals = PR_FALSE;
   1:         child->NameEquals(aName, &childNameEquals);
   1:         if (childNameEquals && ItemIsActive(child) &&
   1:             CanAccessItem(child, aOriginalRequestor)) {
   1:             child.swap(*_retval);
   1:             break;
   1:         }
   1: 
   1:         if (childType != mItemType)     //Only ask it to check children if it is same type
   1:             continue;
   1: 
   1:         if (aRecurse && (aRequestor != child))  // Only ask the child if it isn't the requestor
   1:         {
   1:             // See if child contains the shell with the given name
   1: #ifdef DEBUG
   1:             nsresult rv =
   1: #endif
1160:             child->FindChildWithName(aName, PR_TRUE,
   1:                                      aSameType,
3233:                                      static_cast<nsIDocShellTreeItem*>
3233:                                                 (this),
   1:                                      aOriginalRequestor,
   1:                                      _retval);
   1:             NS_ASSERTION(NS_SUCCEEDED(rv),
   1:                          "FindChildWithName should not fail here");
   1:             if (*_retval)           // found it
   1:                 return NS_OK;
   1:         }
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIDocShellHistory
   1: //*****************************************************************************   
   1: NS_IMETHODIMP
   1: nsDocShell::GetChildSHEntry(PRInt32 aChildOffset, nsISHEntry ** aResult)
   1: {
   1:     nsresult rv = NS_OK;
   1: 
   1:     NS_ENSURE_ARG_POINTER(aResult);
   1:     *aResult = nsnull;
   1: 
   1:     
   1:     // A nsISHEntry for a child is *only* available when the parent is in
   1:     // the progress of loading a document too...
   1:     
   1:     if (mLSHE) {
   1:         /* Before looking for the subframe's url, check
   1:          * the expiration status of the parent. If the parent
   1:          * has expired from cache, then subframes will not be 
   1:          * loaded from history in certain situations.  
   1:          */
   1:         PRBool parentExpired=PR_FALSE;
   1:         mLSHE->GetExpirationStatus(&parentExpired);
   1:         
   1:         /* Get the parent's Load Type so that it can be set on the child too.
   1:          * By default give a loadHistory value
   1:          */
   1:         PRUint32 loadType = nsIDocShellLoadInfo::loadHistory;
   1:         mLSHE->GetLoadType(&loadType);  
   1:         // If the user did a shift-reload on this frameset page, 
   1:         // we don't want to load the subframes from history.
   1:         if (loadType == nsIDocShellLoadInfo::loadReloadBypassCache ||
   1:             loadType == nsIDocShellLoadInfo::loadReloadBypassProxy ||
   1:             loadType == nsIDocShellLoadInfo::loadReloadBypassProxyAndCache ||
   1:             loadType == nsIDocShellLoadInfo::loadRefresh)
   1:             return rv;
   1:         
   1:         /* If the user pressed reload and the parent frame has expired
   1:          *  from cache, we do not want to load the child frame from history.
   1:          */
   1:         if (parentExpired && (loadType == nsIDocShellLoadInfo::loadReloadNormal)) {
   1:             // The parent has expired. Return null.
   1:             *aResult = nsnull;
   1:             return rv;
   1:         }
   1: 
   1:         nsCOMPtr<nsISHContainer> container(do_QueryInterface(mLSHE));
   1:         if (container) {
   1:             // Get the child subframe from session history.
   1:             rv = container->GetChildAt(aChildOffset, aResult);            
   1:             if (*aResult) 
   1:                 (*aResult)->SetLoadType(loadType);            
   1:         }
   1:     }
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::AddChildSHEntry(nsISHEntry * aCloneRef, nsISHEntry * aNewEntry,
   1:                             PRInt32 aChildOffset)
   1: {
   1:     nsresult rv;
   1: 
   1:     if (mLSHE) {
   1:         /* You get here if you are currently building a 
   1:          * hierarchy ie.,you just visited a frameset page
   1:          */
   1:         nsCOMPtr<nsISHContainer> container(do_QueryInterface(mLSHE, &rv));
   1:         if (container) {
   1:             rv = container->AddChild(aNewEntry, aChildOffset);
   1:         }
   1:     }
   1:     else if (!aCloneRef) {
   1:         /* This is an initial load in some subframe.  Just append it if we can */
   1:         nsCOMPtr<nsISHContainer> container(do_QueryInterface(mOSHE, &rv));
   1:         if (container) {
   1:             rv = container->AddChild(aNewEntry, aChildOffset);
   1:         }
   1:     }
   1:     else if (mSessionHistory) {
   1:         /* You are currently in the rootDocShell.
   1:          * You will get here when a subframe has a new url
   1:          * to load and you have walked up the tree all the 
   1:          * way to the top to clone the current SHEntry hierarchy
   1:          * and replace the subframe where a new url was loaded with
   1:          * a new entry.
   1:          */
   1:         PRInt32 index = -1;
   1:         nsCOMPtr<nsIHistoryEntry> currentHE;
   1:         mSessionHistory->GetIndex(&index);
   1:         if (index < 0)
   1:             return NS_ERROR_FAILURE;
   1: 
   1:         rv = mSessionHistory->GetEntryAtIndex(index, PR_FALSE,
   1:                                               getter_AddRefs(currentHE));
   1:         NS_ENSURE_TRUE(currentHE, NS_ERROR_FAILURE);
   1: 
   1:         nsCOMPtr<nsISHEntry> currentEntry(do_QueryInterface(currentHE));
   1:         if (currentEntry) {
   1:             PRUint32 cloneID = 0;
   1:             nsCOMPtr<nsISHEntry> nextEntry;
   1:             aCloneRef->GetID(&cloneID);
   1:             rv = CloneAndReplace(currentEntry, this, cloneID, aNewEntry,
   1:                                  getter_AddRefs(nextEntry));
   1: 
   1:             if (NS_SUCCEEDED(rv)) {
   1:                 nsCOMPtr<nsISHistoryInternal>
   1:                     shPrivate(do_QueryInterface(mSessionHistory));
   1:                 NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
   1:                 rv = shPrivate->AddEntry(nextEntry, PR_TRUE);
   1:             }
   1:         }
   1:     }
   1:     else {
   1:         /* Just pass this along */
   1:         nsCOMPtr<nsIDocShellHistory> parent =
   1:             do_QueryInterface(GetAsSupports(mParent), &rv);
   1:         if (parent) {
   1:             rv = parent->AddChildSHEntry(aCloneRef, aNewEntry, aChildOffset);
   1:         }          
   1:     }
   1:     return rv;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::DoAddChildSHEntry(nsISHEntry* aNewEntry, PRInt32 aChildOffset)
   1: {
   1:     /* You will get here when you are in a subframe and
   1:      * a new url has been loaded on you. 
   1:      * The mOSHE in this subframe will be the previous url's
   1:      * mOSHE. This mOSHE will be used as the identification
   1:      * for this subframe in the  CloneAndReplace function.
   1:      */
   1: 
   1:     // In this case, we will end up calling AddEntry, which increases the
   1:     // current index by 1
   1:     nsCOMPtr<nsISHistory> rootSH;
   1:     GetRootSessionHistory(getter_AddRefs(rootSH));
   1:     if (rootSH) {
   1:         rootSH->GetIndex(&mPreviousTransIndex);
   1:     }
   1: 
   1:     nsresult rv;
   1:     nsCOMPtr<nsIDocShellHistory> parent =
   1:         do_QueryInterface(GetAsSupports(mParent), &rv);
   1:     if (parent) {
   1:         rv = parent->AddChildSHEntry(mOSHE, aNewEntry, aChildOffset);
   1:     }
   1: 
   1: 
   1:     if (rootSH) {
   1:         rootSH->GetIndex(&mLoadedTransIndex);
   1: #ifdef DEBUG_PAGE_CACHE
   1:         printf("Previous index: %d, Loaded index: %d\n\n", mPreviousTransIndex,
   1:                mLoadedTransIndex);
   1: #endif
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetUseGlobalHistory(PRBool aUseGlobalHistory)
   1: {
   1:     nsresult rv;
   1: 
   1:     if (!aUseGlobalHistory) {
   1:         mGlobalHistory = nsnull;
   1:         return NS_OK;
   1:     }
   1: 
   1:     if (mGlobalHistory) {
   1:         return NS_OK;
   1:     }
   1: 
   1:     mGlobalHistory = do_GetService(NS_GLOBALHISTORY2_CONTRACTID, &rv);
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetUseGlobalHistory(PRBool *aUseGlobalHistory)
   1: {
   1:     *aUseGlobalHistory = (mGlobalHistory != nsnull);
   1:     return NS_OK;
   1: }
   1: 
   1: //-------------------------------------
   1: //-- Helper Method for Print discovery
   1: //-------------------------------------
   1: PRBool 
   1: nsDocShell::IsPrintingOrPP(PRBool aDisplayErrorDialog)
   1: {
   1:   if (mIsPrintingOrPP && aDisplayErrorDialog) {
   1:     DisplayLoadError(NS_ERROR_DOCUMENT_IS_PRINTMODE, nsnull, nsnull);
   1:   }
   1: 
   1:   return mIsPrintingOrPP;
   1: }
   1: 
2400: PRBool
2400: nsDocShell::IsNavigationAllowed(PRBool aDisplayPrintErrorDialog)
2400: {
2400:     return !IsPrintingOrPP(aDisplayPrintErrorDialog) && !mFiredUnloadEvent;
2400: }
2400: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIWebNavigation
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetCanGoBack(PRBool * aCanGoBack)
   1: {
2400:     if (!IsNavigationAllowed(PR_FALSE)) {
   1:       *aCanGoBack = PR_FALSE;
   1:       return NS_OK; // JS may not handle returning of an error code
   1:     }
   1:     nsresult rv;
   1:     nsCOMPtr<nsISHistory> rootSH;
   1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
   1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
   1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
   1:     rv = webnav->GetCanGoBack(aCanGoBack);   
   1:     return rv;
   1: 
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetCanGoForward(PRBool * aCanGoForward)
   1: {
2400:     if (!IsNavigationAllowed(PR_FALSE)) {
   1:       *aCanGoForward = PR_FALSE;
   1:       return NS_OK; // JS may not handle returning of an error code
   1:     }
   1:     nsresult rv;
   1:     nsCOMPtr<nsISHistory> rootSH;
   1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH)); 
   1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
   1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
   1:     rv = webnav->GetCanGoForward(aCanGoForward);
   1:     return rv;
   1: 
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GoBack()
   1: {
2400:     if (!IsNavigationAllowed()) {
   1:       return NS_OK; // JS may not handle returning of an error code
   1:     }
   1:     nsresult rv;
   1:     nsCOMPtr<nsISHistory> rootSH;
   1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
   1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
   1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
   1:     rv = webnav->GoBack();
   1:     return rv;
   1: 
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GoForward()
   1: {
2400:     if (!IsNavigationAllowed()) {
   1:       return NS_OK; // JS may not handle returning of an error code
   1:     }
   1:     nsresult rv;
   1:     nsCOMPtr<nsISHistory> rootSH;
   1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
   1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
   1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
   1:     rv = webnav->GoForward();
   1:     return rv;
   1: 
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::GotoIndex(PRInt32 aIndex)
   1: {
2400:     if (!IsNavigationAllowed()) {
   1:       return NS_OK; // JS may not handle returning of an error code
   1:     }
   1:     nsresult rv;
   1:     nsCOMPtr<nsISHistory> rootSH;
   1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
   1:     nsCOMPtr<nsIWebNavigation> webnav(do_QueryInterface(rootSH));
   1:     NS_ENSURE_TRUE(webnav, NS_ERROR_FAILURE);
   1:     rv = webnav->GotoIndex(aIndex);
   1:     return rv;
   1: 
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::LoadURI(const PRUnichar * aURI,
   1:                     PRUint32 aLoadFlags,
   1:                     nsIURI * aReferringURI,
   1:                     nsIInputStream * aPostStream,
   1:                     nsIInputStream * aHeaderStream)
   1: {
2400:     if (!IsNavigationAllowed()) {
   1:       return NS_OK; // JS may not handle returning of an error code
   1:     }
   1:     nsCOMPtr<nsIURI> uri;
   1:     nsresult rv = NS_OK;
   1: 
   1:     // Create a URI from our string; if that succeeds, we want to
   1:     // change aLoadFlags to not include the ALLOW_THIRD_PARTY_FIXUP
   1:     // flag.
   1: 
   1:     NS_ConvertUTF16toUTF8 uriString(aURI);
   1:     // Cleanup the empty spaces that might be on each end.
   1:     uriString.Trim(" ");
   1:     // Eliminate embedded newlines, which single-line text fields now allow:
   1:     uriString.StripChars("\r\n");
   1:     NS_ENSURE_TRUE(!uriString.IsEmpty(), NS_ERROR_FAILURE);
   1: 
   1:     rv = NS_NewURI(getter_AddRefs(uri), uriString);
   1:     if (uri) {
   1:         aLoadFlags &= ~LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
   1:     }
   1:     
   1:     if (sURIFixup) {
   1:         // Call the fixup object.  This will clobber the rv from NS_NewURI
   1:         // above, but that's fine with us.  Note that we need to do this even
   1:         // if NS_NewURI returned a URI, because fixup handles nested URIs, etc
   1:         // (things like view-source:mozilla.org for example).
   1:         PRUint32 fixupFlags = 0;
   1:         if (aLoadFlags & LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP) {
   1:           fixupFlags |= nsIURIFixup::FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP;
   1:         }
   1:         rv = sURIFixup->CreateFixupURI(uriString, fixupFlags,
   1:                                        getter_AddRefs(uri));
   1:     }
   1:     // else no fixup service so just use the URI we created and see
   1:     // what happens
   1: 
   1:     if (NS_ERROR_MALFORMED_URI == rv) {
   1:         DisplayLoadError(rv, uri, aURI);
   1:     }
   1: 
   1:     if (NS_FAILED(rv) || !uri)
   1:         return NS_ERROR_FAILURE;
   1: 
5873:     PopupControlState popupState;
5873:     if (aLoadFlags & LOAD_FLAGS_ALLOW_POPUPS) {
5873:         popupState = openAllowed;
5873:         aLoadFlags &= ~LOAD_FLAGS_ALLOW_POPUPS;
5873:     } else {
5873:         popupState = openOverridden;
5873:     }
5873:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
5873:     nsAutoPopupStatePusher statePusher(win, popupState);
5873: 
2235:     // Don't pass certain flags that aren't needed and end up confusing
2235:     // ConvertLoadTypeToDocShellLoadInfo.  We do need to ensure that they are
2235:     // passed to LoadURI though, since it uses them.
2235:     PRUint32 extraFlags = (aLoadFlags & EXTRA_LOAD_FLAGS);
2235:     aLoadFlags &= ~EXTRA_LOAD_FLAGS;
   1: 
   1:     nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
   1:     rv = CreateLoadInfo(getter_AddRefs(loadInfo));
   1:     if (NS_FAILED(rv)) return rv;
   1:     
   1:     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_NORMAL, aLoadFlags);
   1:     loadInfo->SetLoadType(ConvertLoadTypeToDocShellLoadInfo(loadType));
   1:     loadInfo->SetPostDataStream(aPostStream);
   1:     loadInfo->SetReferrer(aReferringURI);
   1:     loadInfo->SetHeadersStream(aHeaderStream);
   1: 
2235:     rv = LoadURI(uri, loadInfo, extraFlags, PR_TRUE);
   1: 
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::DisplayLoadError(nsresult aError, nsIURI *aURI,
   1:                              const PRUnichar *aURL,
   1:                              nsIChannel* aFailedChannel)
   1: {
   1:     // Get prompt and string bundle servcies
   1:     nsCOMPtr<nsIPrompt> prompter;
   1:     nsCOMPtr<nsIStringBundle> stringBundle;
   1:     GetPromptAndStringBundle(getter_AddRefs(prompter),
   1:                              getter_AddRefs(stringBundle));
   1: 
   1:     NS_ENSURE_TRUE(stringBundle, NS_ERROR_FAILURE);
   1:     NS_ENSURE_TRUE(prompter, NS_ERROR_FAILURE);
   1: 
   1:     nsAutoString error;
   1:     const PRUint32 kMaxFormatStrArgs = 2;
   1:     nsAutoString formatStrs[kMaxFormatStrArgs];
   1:     PRUint32 formatStrCount = 0;
   1:     nsresult rv = NS_OK;
   1:     nsAutoString messageStr;
5528:     nsCAutoString cssClass;
7236:     nsCAutoString errorPage;
7236: 
7236:     errorPage.AssignLiteral("neterror");
   1: 
   1:     // Turn the error code into a human readable error message.
   1:     if (NS_ERROR_UNKNOWN_PROTOCOL == aError) {
   1:         NS_ENSURE_ARG_POINTER(aURI);
   1:         // extract the scheme
   1:         nsCAutoString scheme;
   1:         aURI->GetScheme(scheme);
   1:         CopyASCIItoUTF16(scheme, formatStrs[0]);
   1:         formatStrCount = 1;
   1:         error.AssignLiteral("protocolNotFound");
   1:     }
   1:     else if (NS_ERROR_FILE_NOT_FOUND == aError) {
   1:         NS_ENSURE_ARG_POINTER(aURI);
   1:         nsCAutoString spec;
   1:         // displaying "file://" is aesthetically unpleasing and could even be
   1:         // confusing to the user
   1:         PRBool isFileURI = PR_FALSE;
   1:         rv = aURI->SchemeIs("file", &isFileURI);
   1:         if (NS_FAILED(rv))
   1:             return rv;
   1:         if (isFileURI)
   1:             aURI->GetPath(spec);
   1:         else
   1:             aURI->GetSpec(spec);
   1:         nsCAutoString charset;
   1:         // unescape and convert from origin charset
   1:         aURI->GetOriginCharset(charset);
   1:         nsCOMPtr<nsITextToSubURI> textToSubURI(
   1:                 do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv));
   1:         if (NS_SUCCEEDED(rv))
   1:             // UnEscapeURIForUI always succeeds 
   1:             textToSubURI->UnEscapeURIForUI(charset, spec, formatStrs[0]);
   1:         else 
   1:             CopyUTF8toUTF16(spec, formatStrs[0]);
   1:         rv = NS_OK;
   1:         formatStrCount = 1;
   1:         error.AssignLiteral("fileNotFound");
   1:     }
   1:     else if (NS_ERROR_UNKNOWN_HOST == aError) {
   1:         NS_ENSURE_ARG_POINTER(aURI);
   1:         // Get the host
   1:         nsCAutoString host;
   1:         aURI->GetHost(host);
   1:         CopyUTF8toUTF16(host, formatStrs[0]);
   1:         formatStrCount = 1;
   1:         error.AssignLiteral("dnsNotFound");
   1:     }
   1:     else if(NS_ERROR_CONNECTION_REFUSED == aError) {
   1:         NS_ENSURE_ARG_POINTER(aURI);
   1:         // Build up the host:port string.
   1:         nsCAutoString hostport;
   1:         aURI->GetHostPort(hostport);
   1:         CopyUTF8toUTF16(hostport, formatStrs[0]);
   1:         formatStrCount = 1;
   1:         error.AssignLiteral("connectionFailure");
   1:     }
   1:     else if(NS_ERROR_NET_INTERRUPT == aError) {
   1:         NS_ENSURE_ARG_POINTER(aURI);
   1:         // Build up the host:port string.
   1:         nsCAutoString hostport;
   1:         aURI->GetHostPort(hostport);
   1:         CopyUTF8toUTF16(hostport, formatStrs[0]);
   1:         formatStrCount = 1;
   1:         error.AssignLiteral("netInterrupt");
   1:     }
   1:     else if (NS_ERROR_NET_TIMEOUT == aError) {
   1:         NS_ENSURE_ARG_POINTER(aURI);
   1:         // Get the host
   1:         nsCAutoString host;
   1:         aURI->GetHost(host);
   1:         CopyUTF8toUTF16(host, formatStrs[0]);
   1:         formatStrCount = 1;
   1:         error.AssignLiteral("netTimeout");
   1:     }
   1:     else if (NS_ERROR_GET_MODULE(aError) == NS_ERROR_MODULE_SECURITY) {
7252:         nsCOMPtr<nsINSSErrorsService> nsserr =
7252:             do_GetService(NS_NSS_ERRORS_SERVICE_CONTRACTID);
7252: 
7252:         PRUint32 errorClass;
7252:         if (!nsserr ||
7252:             NS_FAILED(nsserr->GetErrorClass(aError, &errorClass))) {
7252:           errorClass = nsINSSErrorsService::ERROR_CLASS_SSL_PROTOCOL;
7252:         }
7252: 
   1:         nsCOMPtr<nsISupports> securityInfo;
   1:         nsCOMPtr<nsITransportSecurityInfo> tsi;
   1:         if (aFailedChannel)
   1:             aFailedChannel->GetSecurityInfo(getter_AddRefs(securityInfo));
   1:         tsi = do_QueryInterface(securityInfo);
   1:         if (tsi) {
   1:             // Usually we should have aFailedChannel and get a detailed message
   1:             tsi->GetErrorMessage(getter_Copies(messageStr));
   1:         }
   1:         else {
   1:             // No channel, let's obtain the generic error message
   1:             if (nsserr) {
   1:                 nsserr->GetErrorMessage(aError, messageStr);
   1:             }
   1:         }
7252:         if (!messageStr.IsEmpty()) {
7252:             if (errorClass == nsINSSErrorsService::ERROR_CLASS_BAD_CERT) {
7252:                 error.AssignLiteral("nssBadCert");
7252:             } else {
2609:                 error.AssignLiteral("nssFailure2");
7252:             }
7252:         }
7236:     } else if (NS_ERROR_PHISHING_URI == aError || NS_ERROR_MALWARE_URI == aError) {
7236:         nsCAutoString host;
7236:         aURI->GetHost(host);
7236:         CopyUTF8toUTF16(host, formatStrs[0]);
7236:         formatStrCount = 1;
7236: 
7236:         // Malware and phishing detectors may want to use an alternate error
7236:         // page, but if the pref's not set, we'll fall back on the standard page
7236:         nsXPIDLCString alternateErrorPage;
7236:         mPrefs->GetCharPref("urlclassifier.alternate_error_page",
7236:                             getter_Copies(alternateErrorPage));
7236:         if (alternateErrorPage)
7236:             errorPage.Assign(alternateErrorPage);
7236: 
7236:         if (NS_ERROR_PHISHING_URI == aError)
7236:             error.AssignLiteral("phishingBlocked");
7236:         else
7236:             error.AssignLiteral("malwareBlocked");
7236:         cssClass.AssignLiteral("blacklist");
   1:     }
   1:     else {
   1:         // Errors requiring simple formatting
   1:         switch (aError) {
   1:         case NS_ERROR_MALFORMED_URI:
   1:             // URI is malformed
   1:             error.AssignLiteral("malformedURI");
   1:             break;
   1:         case NS_ERROR_REDIRECT_LOOP:
   1:             // Doc failed to load because the server generated too many redirects
   1:             error.AssignLiteral("redirectLoop");
   1:             break;
   1:         case NS_ERROR_UNKNOWN_SOCKET_TYPE:
   1:             // Doc failed to load because PSM is not installed
   1:             error.AssignLiteral("unknownSocketType");
   1:             break;
   1:         case NS_ERROR_NET_RESET:
   1:             // Doc failed to load because the server kept reseting the connection
   1:             // before we could read any data from it
   1:             error.AssignLiteral("netReset");
   1:             break;
   1:         case NS_ERROR_DOCUMENT_NOT_CACHED:
   1:             // Doc falied to load because we are offline and the cache does not
   1:             // contain a copy of the document.
   1:             error.AssignLiteral("netOffline");
   1:             break;
   1:         case NS_ERROR_DOCUMENT_IS_PRINTMODE:
   1:             // Doc navigation attempted while Printing or Print Preview
   1:             error.AssignLiteral("isprinting");
   1:             break;
   1:         case NS_ERROR_PORT_ACCESS_NOT_ALLOWED:
   1:             // Port blocked for security reasons
   1:             error.AssignLiteral("deniedPortAccess");
   1:             break;
   1:         case NS_ERROR_UNKNOWN_PROXY_HOST:
   1:             // Proxy hostname could not be resolved.
   1:             error.AssignLiteral("proxyResolveFailure");
   1:             break;
   1:         case NS_ERROR_PROXY_CONNECTION_REFUSED:
   1:             // Proxy connection was refused.
   1:             error.AssignLiteral("proxyConnectFailure");
   1:             break;
   1:         case NS_ERROR_INVALID_CONTENT_ENCODING:
   1:             // Bad Content Encoding.
   1:             error.AssignLiteral("contentEncodingError");
   1:             break;
8363:         case NS_ERROR_UNSAFE_CONTENT_TYPE:
8363:             // Channel refused to load from an unrecognized content type.
8363:             error.AssignLiteral("unsafeContentType");
8363:             break;
   1:         }
   1:     }
   1: 
   1:     // Test if the error should be displayed
   1:     if (error.IsEmpty()) {
   1:         return NS_OK;
   1:     }
   1: 
   1:     // Test if the error needs to be formatted
   1:     if (!messageStr.IsEmpty()) {
   1:         // already obtained message
   1:     }
   1:     else if (formatStrCount > 0) {
   1:         const PRUnichar *strs[kMaxFormatStrArgs];
   1:         for (PRUint32 i = 0; i < formatStrCount; i++) {
   1:             strs[i] = formatStrs[i].get();
   1:         }
   1:         nsXPIDLString str;
   1:         rv = stringBundle->FormatStringFromName(
   1:             error.get(),
   1:             strs, formatStrCount, getter_Copies(str));
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:         messageStr.Assign(str.get());
   1:     }
   1:     else
   1:     {
   1:         nsXPIDLString str;
   1:         rv = stringBundle->GetStringFromName(
   1:                 error.get(),
   1:                 getter_Copies(str));
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:         messageStr.Assign(str.get());
   1:     }
   1: 
   1:     // Display the error as a page or an alert prompt
   1:     NS_ENSURE_FALSE(messageStr.IsEmpty(), NS_ERROR_FAILURE);
   1:     // Note: For now, display an alert instead of an error page if we have no
   1:     // URI object. Missing URI objects are handled badly by session history.
   1:     if (mUseErrorPages && aURI && aFailedChannel) {
   1:         // Display an error page
7236:         LoadErrorPage(aURI, aURL, errorPage.get(), error.get(),
7236:                       messageStr.get(), cssClass.get(), aFailedChannel);
   1:     } 
   1:     else
   1:     {
   1:         // The prompter reqires that our private window has a document (or it
   1:         // asserts). Satisfy that assertion now since GetDocument will force
   1:         // creation of one if it hasn't already been created.
   1:         nsCOMPtr<nsPIDOMWindow> pwin(do_QueryInterface(mScriptGlobal));
   1:         if (pwin) {
   1:             nsCOMPtr<nsIDOMDocument> doc;
   1:             pwin->GetDocument(getter_AddRefs(doc));
   1:         }
   1: 
   1:         // Display a message box
   1:         prompter->Alert(nsnull, messageStr.get());
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::LoadErrorPage(nsIURI *aURI, const PRUnichar *aURL,
7236:                           const char *aErrorPage,
   1:                           const PRUnichar *aErrorType,
   1:                           const PRUnichar *aDescription,
5528:                           const char *aCSSClass,
   1:                           nsIChannel* aFailedChannel)
   1: {
   1: #if defined(PR_LOGGING) && defined(DEBUG)
   1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
   1:         nsCAutoString spec;
   1:         aURI->GetSpec(spec);
   1: 
   1:         nsCAutoString chanName;
   1:         if (aFailedChannel)
   1:             aFailedChannel->GetName(chanName);
   1:         else
   1:             chanName.AssignLiteral("<no channel>");
   1: 
   1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
   1:                ("nsDocShell[%p]::LoadErrorPage(\"%s\", \"%s\", {...}, [%s])\n", this,
   1:                 spec.get(), NS_ConvertUTF16toUTF8(aURL).get(), chanName.get()));
   1:     }
   1: #endif
   1:     // Create an shistory entry for the old load, if we have a channel
   1:     if (aFailedChannel) {
   1:         mURIResultedInDocument = PR_TRUE;
   1:         OnLoadingSite(aFailedChannel, PR_TRUE, PR_FALSE);
   1:     } else if (aURI) {
   1:         mURIResultedInDocument = PR_TRUE;
   1:         OnNewURI(aURI, nsnull, mLoadType, PR_TRUE, PR_FALSE);
   1:     }
   1:     // Be sure to have a correct mLSHE, it may have been cleared by
   1:     // EndPageLoad. See bug 302115.
   1:     if (mSessionHistory && !mLSHE) {
   1:         PRInt32 idx;
   1:         mSessionHistory->GetRequestedIndex(&idx);
   1:         nsCOMPtr<nsIHistoryEntry> entry;
   1:         mSessionHistory->GetEntryAtIndex(idx, PR_FALSE,
   1:                                          getter_AddRefs(entry));
   1:         mLSHE = do_QueryInterface(entry);
   1: 
   1:     }
   1: 
   1:     nsCAutoString url;
   1:     nsCAutoString charset;
   1:     if (aURI)
   1:     {
   1:         // Set our current URI
   1:         SetCurrentURI(aURI);
   1: 
   1:         nsresult rv = aURI->GetSpec(url);
   1:         rv |= aURI->GetOriginCharset(charset);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:     }
   1:     else if (aURL)
   1:     {
   1:         CopyUTF16toUTF8(aURL, url);
   1:     }
   1:     else
   1:     {
   1:         return NS_ERROR_INVALID_POINTER;
   1:     }
   1: 
   1:     // Create a URL to pass all the error information through to the page.
   1: 
   1:     char *escapedUrl = nsEscape(url.get(), url_Path);
   1:     char *escapedCharset = nsEscape(charset.get(), url_Path);
   1:     char *escapedError = nsEscape(NS_ConvertUTF16toUTF8(aErrorType).get(), url_Path);
   1:     char *escapedDescription = nsEscape(NS_ConvertUTF16toUTF8(aDescription).get(), url_Path);
5528:     char *escapedCSSClass = nsEscape(aCSSClass, url_Path);
   1: 
7236:     nsCString errorPageUrl("about:");
7236:     errorPageUrl.AppendASCII(aErrorPage);
7236:     errorPageUrl.AppendLiteral("?e=");
   1: 
   1:     errorPageUrl.AppendASCII(escapedError);
   1:     errorPageUrl.AppendLiteral("&u=");
   1:     errorPageUrl.AppendASCII(escapedUrl);
5528:     if (escapedCSSClass && escapedCSSClass[0]) {
5528:         errorPageUrl.AppendASCII("&s=");
5528:         errorPageUrl.AppendASCII(escapedCSSClass);
5528:     }
   1:     errorPageUrl.AppendLiteral("&c=");
   1:     errorPageUrl.AppendASCII(escapedCharset);
   1:     errorPageUrl.AppendLiteral("&d=");
   1:     errorPageUrl.AppendASCII(escapedDescription);
   1: 
   1:     nsMemory::Free(escapedDescription);
   1:     nsMemory::Free(escapedError);
   1:     nsMemory::Free(escapedUrl);
   1:     nsMemory::Free(escapedCharset);
5528:     nsMemory::Free(escapedCSSClass);
   1: 
   1:     nsCOMPtr<nsIURI> errorPageURI;
   1:     nsresult rv = NS_NewURI(getter_AddRefs(errorPageURI), errorPageUrl);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     return InternalLoad(errorPageURI, nsnull, nsnull, PR_TRUE, nsnull, nsnull,
   1:                         nsnull, nsnull, LOAD_ERROR_PAGE,
   1:                         nsnull, PR_TRUE, nsnull, nsnull);
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::Reload(PRUint32 aReloadFlags)
   1: {
2400:     if (!IsNavigationAllowed()) {
   1:       return NS_OK; // JS may not handle returning of an error code
   1:     }
   1:     nsresult rv;
   1:     NS_ASSERTION(((aReloadFlags & 0xf) == 0),
   1:                  "Reload command not updated to use load flags!");
   1: 
   1:     PRUint32 loadType = MAKE_LOAD_TYPE(LOAD_RELOAD_NORMAL, aReloadFlags);
   1:     NS_ENSURE_TRUE(IsValidLoadType(loadType), NS_ERROR_INVALID_ARG);
   1: 
   1:     // Send notifications to the HistoryListener if any, about the impending reload
   1:     nsCOMPtr<nsISHistory> rootSH;
   1:     rv = GetRootSessionHistory(getter_AddRefs(rootSH));
   1:     nsCOMPtr<nsISHistoryInternal> shistInt(do_QueryInterface(rootSH));
   1:     PRBool canReload = PR_TRUE; 
   1:     if (rootSH) {
   1:       nsCOMPtr<nsISHistoryListener> listener;
   1:       shistInt->GetListener(getter_AddRefs(listener));
   1:       if (listener) {
   1:         listener->OnHistoryReload(mCurrentURI, aReloadFlags, &canReload);
   1:       }
   1:     }
   1: 
   1:     if (!canReload)
   1:       return NS_OK;
   1:     
   1:     /* If you change this part of code, make sure bug 45297 does not re-occur */
   1:     if (mOSHE) {
   1:         rv = LoadHistoryEntry(mOSHE, loadType);
   1:     }
   1:     else if (mLSHE) { // In case a reload happened before the current load is done
   1:         rv = LoadHistoryEntry(mLSHE, loadType);
   1:     }
   1:     else {
   1:         nsCOMPtr<nsIDOMDocument> domDoc(do_GetInterface(GetAsSupports(this)));
   1:         nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
   1: 
   1:         nsIPrincipal* principal = nsnull;
   1:         nsAutoString contentTypeHint;
   1:         if (doc) {
   1:             principal = doc->NodePrincipal();
   1:             doc->GetContentType(contentTypeHint);
   1:         }
   1: 
   1:         rv = InternalLoad(mCurrentURI,
   1:                           mReferrerURI,
   1:                           principal,
   1:                           INTERNAL_LOAD_FLAGS_NONE, // Do not inherit owner from document
   1:                           nsnull,         // No window target
   1:                           NS_LossyConvertUTF16toASCII(contentTypeHint).get(),
   1:                           nsnull,         // No post data
   1:                           nsnull,         // No headers data
   1:                           loadType,       // Load type
   1:                           nsnull,         // No SHEntry
   1:                           PR_TRUE,
   1:                           nsnull,         // No nsIDocShell
   1:                           nsnull);        // No nsIRequest
   1:     }
   1:     
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::Stop(PRUint32 aStopFlags)
   1: {
   1:     // Revoke any pending event related to content viewer restoration
   1:     mRestorePresentationEvent.Revoke();
   1: 
5536:     if (nsIWebNavigation::STOP_CONTENT & aStopFlags) {
   1:         // Stop the document loading
   1:         if (mContentViewer)
   1:             mContentViewer->Stop();
   1:     }
   1: 
   1:     if (nsIWebNavigation::STOP_NETWORK & aStopFlags) {
   1:         // Suspend any timers that were set for this loader.  We'll clear
   1:         // them out for good in CreateContentViewer.
   1:         if (mRefreshURIList) {
   1:             SuspendRefreshURIs();
   1:             mSavedRefreshURIList.swap(mRefreshURIList);
   1:             mRefreshURIList = nsnull;
   1:         }
   1: 
5528:         if (mClassifier) {
5528:             mClassifier->Cancel();
5528:             mClassifier = nsnull;
5528:         }
5528: 
   1:         // XXXbz We could also pass |this| to nsIURILoader::Stop.  That will
   1:         // just call Stop() on us as an nsIDocumentLoader... We need fewer
   1:         // redundant apis!
   1:         Stop();
   1:     }
   1: 
   1:     PRInt32 n;
   1:     PRInt32 count = mChildList.Count();
   1:     for (n = 0; n < count; n++) {
   1:         nsCOMPtr<nsIWebNavigation> shellAsNav(do_QueryInterface(ChildAt(n)));
   1:         if (shellAsNav)
   1:             shellAsNav->Stop(aStopFlags);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: /*
   1: NS_IMETHODIMP nsDocShell::SetDocument(nsIDOMDocument* aDocument,
   1:    const PRUnichar* aContentType)
   1: {
   1:    //XXX First Checkin
   1:    NS_ERROR("Not Yet Implemented");
   1:    return NS_ERROR_FAILURE;
   1: }
   1: */
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetDocument(nsIDOMDocument ** aDocument)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aDocument);
   1:     NS_ENSURE_SUCCESS(EnsureContentViewer(), NS_ERROR_FAILURE);
   1: 
   1:     return mContentViewer->GetDOMDocument(aDocument);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetCurrentURI(nsIURI ** aURI)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aURI);
   1: 
   1:     if (mCurrentURI) {
   1:         return NS_EnsureSafeToReturn(mCurrentURI, aURI);
   1:     }
   1: 
   1:     *aURI = nsnull;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetReferringURI(nsIURI ** aURI)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aURI);
   1: 
   1:     *aURI = mReferrerURI;
   1:     NS_IF_ADDREF(*aURI);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetSessionHistory(nsISHistory * aSessionHistory)
   1: {
   1: 
   1:     NS_ENSURE_TRUE(aSessionHistory, NS_ERROR_FAILURE);
   1:     // make sure that we are the root docshell and
   1:     // set a handle to root docshell in SH.
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> root;
   1:     /* Get the root docshell. If *this* is the root docshell
   1:      * then save a handle to *this* in SH. SH needs it to do
   1:      * traversions thro' its entries
   1:      */
   1:     GetSameTypeRootTreeItem(getter_AddRefs(root));
   1:     NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
3233:     if (root.get() == static_cast<nsIDocShellTreeItem *>(this)) {
   1:         mSessionHistory = aSessionHistory;
   1:         nsCOMPtr<nsISHistoryInternal>
   1:             shPrivate(do_QueryInterface(mSessionHistory));
   1:         NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
   1:         shPrivate->SetRootDocShell(this);
   1:         return NS_OK;
   1:     }
   1:     return NS_ERROR_FAILURE;
   1: 
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetSessionHistory(nsISHistory ** aSessionHistory)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aSessionHistory);
   1:     *aSessionHistory = mSessionHistory;
   1:     NS_IF_ADDREF(*aSessionHistory);
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIWebPageDescriptor
   1: //*****************************************************************************   
   1: NS_IMETHODIMP
   1: nsDocShell::LoadPage(nsISupports *aPageDescriptor, PRUint32 aDisplayType)
   1: {
   1:     nsCOMPtr<nsISHEntry> shEntryIn(do_QueryInterface(aPageDescriptor));
   1: 
   1:     // Currently, the opaque 'page descriptor' is an nsISHEntry...
   1:     if (!shEntryIn) {
   1:         return NS_ERROR_INVALID_POINTER;
   1:     }
   1: 
   1:     // Now clone shEntryIn, since we might end up modifying it later on, and we
   1:     // want a page descriptor to be reusable.
   1:     nsCOMPtr<nsISHEntry> shEntry;
   1:     nsresult rv = shEntryIn->Clone(getter_AddRefs(shEntry));
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1:     
   1:     //
   1:     // load the page as view-source
   1:     //
   1:     if (nsIWebPageDescriptor::DISPLAY_AS_SOURCE == aDisplayType) {
   1:         nsCOMPtr<nsIURI> oldUri, newUri;
   1:         nsCString spec, newSpec;
   1: 
   1:         // Create a new view-source URI and replace the original.
   1:         rv = shEntry->GetURI(getter_AddRefs(oldUri));
   1:         if (NS_FAILED(rv))
   1:               return rv;
   1: 
   1:         oldUri->GetSpec(spec);
   1:         newSpec.AppendLiteral("view-source:");
   1:         newSpec.Append(spec);
   1: 
   1:         rv = NS_NewURI(getter_AddRefs(newUri), newSpec);
   1:         if (NS_FAILED(rv)) {
   1:             return rv;
   1:         }
   1:         shEntry->SetURI(newUri);
   1:     }
   1: 
   1:     rv = LoadHistoryEntry(shEntry, LOAD_HISTORY);
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetCurrentDescriptor(nsISupports **aPageDescriptor)
   1: {
   1:     NS_PRECONDITION(aPageDescriptor, "Null out param?");
   1: 
   1:     *aPageDescriptor = nsnull;
   1: 
   1:     nsISHEntry* src = mOSHE ? mOSHE : mLSHE;
   1:     if (src) {
   1:         nsCOMPtr<nsISHEntry> dest;
   1: 
   1:         nsresult rv = src->Clone(getter_AddRefs(dest));
   1:         if (NS_FAILED(rv)) {
   1:             return rv;
   1:         }
   1: 
   1:         // null out inappropriate cloned attributes...
   1:         dest->SetParent(nsnull);
   1:         dest->SetIsSubFrame(PR_FALSE);
   1:         
   1:         return CallQueryInterface(dest, aPageDescriptor);
   1:     }
   1: 
   1:     return NS_ERROR_NOT_AVAILABLE;
   1: }
   1: 
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIBaseWindow
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::InitWindow(nativeWindow parentNativeWindow,
   1:                        nsIWidget * parentWidget, PRInt32 x, PRInt32 y,
   1:                        PRInt32 cx, PRInt32 cy)
   1: {
   1:     NS_ENSURE_ARG(parentWidget);        // DocShells must get a widget for a parent
   1: 
   1:     SetParentWidget(parentWidget);
   1:     SetPositionAndSize(x, y, cx, cy, PR_FALSE);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::Create()
   1: {
   1:     NS_ASSERTION(mItemType == typeContent || mItemType == typeChrome,
   1:                  "Unexpected item type in docshell");
   1: 
   1:     nsresult rv = NS_ERROR_FAILURE;
   1:     mPrefs = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     PRBool tmpbool;
   1: 
   1:     rv = mPrefs->GetBoolPref("browser.frames.enabled", &tmpbool);
   1:     if (NS_SUCCEEDED(rv))
   1:         mAllowSubframes = tmpbool;
   1: 
   1:     if (gValidateOrigin == (PRBool)0xffffffff) {
   1:         // Check pref to see if we should prevent frameset spoofing
   1:         rv = mPrefs->GetBoolPref("browser.frame.validate_origin", &tmpbool);
   1:         if (NS_SUCCEEDED(rv)) {
   1:             gValidateOrigin = tmpbool;
   1:         } else {
   1:             gValidateOrigin = PR_TRUE;
   1:         }
   1:     }
   1: 
   1:     // Should we use XUL error pages instead of alerts if possible?
   1:     rv = mPrefs->GetBoolPref("browser.xul.error_pages.enabled", &tmpbool);
   1:     if (NS_SUCCEEDED(rv))
   1:         mUseErrorPages = tmpbool;
   1: 
   1:     nsCOMPtr<nsIPrefBranch2> prefs(do_QueryInterface(mPrefs, &rv));
   1:     if (NS_SUCCEEDED(rv) && mObserveErrorPages) {
   1:         prefs->AddObserver("browser.xul.error_pages.enabled", this, PR_FALSE);
   1:     }
   1: 
   1:     nsCOMPtr<nsIObserverService> serv = do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
   1:     if (serv) {
   1:         const char* msg = mItemType == typeContent ?
   1:             NS_WEBNAVIGATION_CREATE : NS_CHROME_WEBNAVIGATION_CREATE;
   1:         serv->NotifyObservers(GetAsSupports(this), msg, nsnull);
   1:     }    
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::Destroy()
   1: {
   1:     NS_ASSERTION(mItemType == typeContent || mItemType == typeChrome,
   1:                  "Unexpected item type in docshell");
   1: 
   1:     if (!mIsBeingDestroyed) {
   1:         nsCOMPtr<nsIObserverService> serv =
   1:             do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
   1:         if (serv) {
   1:             const char* msg = mItemType == typeContent ?
   1:                 NS_WEBNAVIGATION_DESTROY : NS_CHROME_WEBNAVIGATION_DESTROY;
   1:             serv->NotifyObservers(GetAsSupports(this), msg, nsnull);
   1:         }
   1:     }
   1:     
   1:     mIsBeingDestroyed = PR_TRUE;
   1: 
   1:     // Remove our pref observers
   1:     if (mObserveErrorPages) {
   1:         nsCOMPtr<nsIPrefBranch2> prefs(do_QueryInterface(mPrefs));
   1:         if (prefs) {
   1:             prefs->RemoveObserver("browser.xul.error_pages.enabled", this);
   1:             mObserveErrorPages = PR_FALSE;
   1:         }
   1:     }
   1: 
   1:     // Fire unload event before we blow anything away.
   1:     (void) FirePageHideNotification(PR_TRUE);
   1: 
   1:     // Note: mContentListener can be null if Init() failed and we're being
   1:     // called from the destructor.
   1:     if (mContentListener) {
   1:         mContentListener->DropDocShellreference();
   1:         mContentListener->SetParentContentListener(nsnull);
   1:         // Note that we do NOT set mContentListener to null here; that
   1:         // way if someone tries to do a load in us after this point
   1:         // the nsDSURIContentListener will block it.  All of which
   1:         // means that we should do this before calling Stop(), of
   1:         // course.
   1:     }
   1: 
   1:     // Stop any URLs that are currently being loaded...
   1:     Stop(nsIWebNavigation::STOP_ALL);
   1: 
   1:     delete mEditorData;
   1:     mEditorData = 0;
   1: 
   1:     mTransferableHookData = nsnull;
   1: 
   1:     // Save the state of the current document, before destroying the window.
   1:     // This is needed to capture the state of a frameset when the new document
   1:     // causes the frameset to be destroyed...
   1:     PersistLayoutHistoryState();
   1: 
   1:     // Remove this docshell from its parent's child list
1160:     nsCOMPtr<nsIDocShellTreeItem> docShellParentAsItem =
   1:         do_QueryInterface(GetAsSupports(mParent));
1160:     if (docShellParentAsItem)
1160:         docShellParentAsItem->RemoveChild(this);
   1: 
   1:     if (mContentViewer) {
   1:         mContentViewer->Close(nsnull);
   1:         mContentViewer->Destroy();
   1:         mContentViewer = nsnull;
   1:     }
   1: 
   1:     nsDocLoader::Destroy();
   1:     
   1:     mParentWidget = nsnull;
   1:     mCurrentURI = nsnull;
   1: 
   1:     if (mScriptGlobal) {
   1:         nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
   1:         win->SetDocShell(nsnull);
   1: 
   1:         mScriptGlobal = nsnull;
   1:     }
   1: 
   1:     mSessionHistory = nsnull;
   1:     SetTreeOwner(nsnull);
   1: 
   1:     // required to break ref cycle
   1:     mSecurityUI = nsnull;
   1: 
   1:     // Cancel any timers that were set for this docshell; this is needed
   1:     // to break the cycle between us and the timers.
   1:     CancelRefreshURITimers();
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetPosition(PRInt32 x, PRInt32 y)
   1: {
   1:     mBounds.x = x;
   1:     mBounds.y = y;
   1: 
   1:     if (mContentViewer)
   1:         NS_ENSURE_SUCCESS(mContentViewer->Move(x, y), NS_ERROR_FAILURE);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetPosition(PRInt32 * aX, PRInt32 * aY)
   1: {
   1:     PRInt32 dummyHolder;
   1:     return GetPositionAndSize(aX, aY, &dummyHolder, &dummyHolder);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetSize(PRInt32 aCX, PRInt32 aCY, PRBool aRepaint)
   1: {
   1:     PRInt32 x = 0, y = 0;
   1:     GetPosition(&x, &y);
   1:     return SetPositionAndSize(x, y, aCX, aCY, aRepaint);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetSize(PRInt32 * aCX, PRInt32 * aCY)
   1: {
   1:     PRInt32 dummyHolder;
   1:     return GetPositionAndSize(&dummyHolder, &dummyHolder, aCX, aCY);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetPositionAndSize(PRInt32 x, PRInt32 y, PRInt32 cx,
   1:                                PRInt32 cy, PRBool fRepaint)
   1: {
   1:     mBounds.x = x;
   1:     mBounds.y = y;
   1:     mBounds.width = cx;
   1:     mBounds.height = cy;
   1: 
6162:     // Hold strong ref, since SetBounds can make us null out mContentViewer
6162:     nsCOMPtr<nsIContentViewer> viewer = mContentViewer;
6162:     if (viewer) {
   1:         //XXX Border figured in here or is that handled elsewhere?
6162:         NS_ENSURE_SUCCESS(viewer->SetBounds(mBounds), NS_ERROR_FAILURE);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetPositionAndSize(PRInt32 * x, PRInt32 * y, PRInt32 * cx,
   1:                                PRInt32 * cy)
   1: {
   1:     // We should really consider just getting this information from
   1:     // our window instead of duplicating the storage and code...
   1:     nsCOMPtr<nsIDOMDocument> document(do_GetInterface(GetAsSupports(mParent)));
   1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(document));
   1:     if (doc) {
   1:         doc->FlushPendingNotifications(Flush_Layout);
   1:     }
   1:     
1027:     DoGetPositionAndSize(x, y, cx, cy);
1027:     return NS_OK;
1027: }
1027: 
1027: void
1027: nsDocShell::DoGetPositionAndSize(PRInt32 * x, PRInt32 * y, PRInt32 * cx,
1027:                                  PRInt32 * cy)
1027: {    
   1:     if (x)
   1:         *x = mBounds.x;
   1:     if (y)
   1:         *y = mBounds.y;
   1:     if (cx)
   1:         *cx = mBounds.width;
   1:     if (cy)
   1:         *cy = mBounds.height;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::Repaint(PRBool aForce)
   1: {
   1:     nsCOMPtr<nsPresContext> context;
   1:     GetPresContext(getter_AddRefs(context));
   1:     NS_ENSURE_TRUE(context, NS_ERROR_FAILURE);
   1: 
   1:     nsIViewManager* viewManager = context->GetViewManager();
   1:     NS_ENSURE_TRUE(viewManager, NS_ERROR_FAILURE);
   1: 
   1:     // what about aForce ?
   1:     NS_ENSURE_SUCCESS(viewManager->UpdateAllViews(0), NS_ERROR_FAILURE);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetParentWidget(nsIWidget ** parentWidget)
   1: {
   1:     NS_ENSURE_ARG_POINTER(parentWidget);
   1: 
   1:     *parentWidget = mParentWidget;
   1:     NS_IF_ADDREF(*parentWidget);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetParentWidget(nsIWidget * aParentWidget)
   1: {
   1:     mParentWidget = aParentWidget;
   1: 
   1:     if (!mParentWidget) {
   1:         // If the parent widget is set to null we don't want to hold
   1:         // on to the current device context any more since it is
   1:         // associated with the parent widget we no longer own. We'll
   1:         // need to create a new device context if one is needed again.
   1: 
   1:         mDeviceContext = nsnull;
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetParentNativeWindow(nativeWindow * parentNativeWindow)
   1: {
   1:     NS_ENSURE_ARG_POINTER(parentNativeWindow);
   1: 
   1:     if (mParentWidget)
   1:         *parentNativeWindow = mParentWidget->GetNativeData(NS_NATIVE_WIDGET);
   1:     else
   1:         *parentNativeWindow = nsnull;
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetParentNativeWindow(nativeWindow parentNativeWindow)
   1: {
   1:     return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetVisibility(PRBool * aVisibility)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aVisibility);
   1:     if (!mContentViewer) {
   1:         *aVisibility = PR_FALSE;
   1:         return NS_OK;
   1:     }
   1: 
   1:     // get the pres shell
   1:     nsCOMPtr<nsIPresShell> presShell;
   1:     NS_ENSURE_SUCCESS(GetPresShell(getter_AddRefs(presShell)),
   1:                       NS_ERROR_FAILURE);
   1:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
   1: 
   1:     // get the view manager
   1:     nsIViewManager* vm = presShell->GetViewManager();
   1:     NS_ENSURE_TRUE(vm, NS_ERROR_FAILURE);
   1: 
   1:     // get the root view
   1:     nsIView *view = nsnull; // views are not ref counted
   1:     NS_ENSURE_SUCCESS(vm->GetRootView(view), NS_ERROR_FAILURE);
   1:     NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
   1: 
   1:     // if our root view is hidden, we are not visible
   1:     if (view->GetVisibility() == nsViewVisibility_kHide) {
   1:         *aVisibility = PR_FALSE;
   1:         return NS_OK;
   1:     }
   1: 
   1:     // otherwise, we must walk up the document and view trees checking
   1:     // for a hidden view.
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> treeItem = this;
   1:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
   1:     treeItem->GetParent(getter_AddRefs(parentItem));
   1:     while (parentItem) {
   1:         nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(treeItem));
   1:         docShell->GetPresShell(getter_AddRefs(presShell));
   1: 
   1:         nsCOMPtr<nsIDocShell> parentDS = do_QueryInterface(parentItem);
   1:         nsCOMPtr<nsIPresShell> pPresShell;
   1:         parentDS->GetPresShell(getter_AddRefs(pPresShell));
   1: 
   1:         // Null-check for crash in bug 267804
   1:         if (!pPresShell) {
   1:             NS_NOTREACHED("docshell has null pres shell");
   1:             *aVisibility = PR_FALSE;
   1:             return NS_OK;
   1:         }
   1: 
   1:         nsIContent *shellContent =
   1:             pPresShell->GetDocument()->FindContentForSubDocument(presShell->GetDocument());
   1:         NS_ASSERTION(shellContent, "subshell not in the map");
   1: 
   1:         nsIFrame* frame = pPresShell->GetPrimaryFrameFor(shellContent);
   1:         if (frame && !frame->AreAncestorViewsVisible()) {
   1:             *aVisibility = PR_FALSE;
   1:             return NS_OK;
   1:         }
   1: 
   1:         treeItem = parentItem;
   1:         treeItem->GetParent(getter_AddRefs(parentItem));
   1:     }
   1: 
   1:     nsCOMPtr<nsIBaseWindow>
   1:         treeOwnerAsWin(do_QueryInterface(mTreeOwner));
   1:     if (!treeOwnerAsWin) {
   1:         *aVisibility = PR_TRUE;
   1:         return NS_OK;
   1:     }
   1: 
   1:     // Check with the tree owner as well to give embedders a chance to
   1:     // expose visibility as well.
   1:     return treeOwnerAsWin->GetVisibility(aVisibility);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetVisibility(PRBool aVisibility)
   1: {
   1:     if (!mContentViewer)
   1:         return NS_OK;
   1:     if (aVisibility) {
   1:         mContentViewer->Show();
   1:     }
   1:     else {
   1:         mContentViewer->Hide();
   1:     }
   1:     
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetEnabled(PRBool *aEnabled)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aEnabled);
   1:   *aEnabled = PR_TRUE;
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetEnabled(PRBool aEnabled)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetBlurSuppression(PRBool *aBlurSuppression)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aBlurSuppression);
   1:   *aBlurSuppression = PR_FALSE;
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetBlurSuppression(PRBool aBlurSuppression)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetMainWidget(nsIWidget ** aMainWidget)
   1: {
   1:     // We don't create our own widget, so simply return the parent one. 
   1:     return GetParentWidget(aMainWidget);
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetFocus()
   1: {
   1: #ifdef DEBUG_DOCSHELL_FOCUS
  58:   printf("nsDocShell::SetFocus %p\n", (void*)this);
   1: #endif
   1: 
   1:   // Tell itself (and the DocShellFocusController) who has focus
   1:   // this way focus gets removed from the currently focused DocShell
   1: 
   1:   SetHasFocus(PR_TRUE);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetTitle(PRUnichar ** aTitle)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aTitle);
   1: 
   1:     *aTitle = ToNewUnicode(mTitle);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetTitle(const PRUnichar * aTitle)
   1: {
   1:     // Store local title
   1:     mTitle = aTitle;
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> parent;
   1:     GetSameTypeParent(getter_AddRefs(parent));
   1: 
   1:     // When title is set on the top object it should then be passed to the 
   1:     // tree owner.
   1:     if (!parent) {
   1:         nsCOMPtr<nsIBaseWindow>
   1:             treeOwnerAsWin(do_QueryInterface(mTreeOwner));
   1:         if (treeOwnerAsWin)
   1:             treeOwnerAsWin->SetTitle(aTitle);
   1:     }
   1: 
   1:     if (mGlobalHistory && mCurrentURI && mLoadType != LOAD_ERROR_PAGE) {
   1:         mGlobalHistory->SetPageTitle(mCurrentURI, nsDependentString(aTitle));
   1:     }
   1: 
   1: 
   1:     // Update SessionHistory with the document's title. If the
   1:     // page was loaded from history or the page bypassed history,
   1:     // there is no need to update the title. There is no need to
   1:     // go to mSessionHistory to update the title. Setting it in mOSHE 
   1:     // would suffice. 
   1:     if (mOSHE && (mLoadType != LOAD_BYPASS_HISTORY) &&
   1:         (mLoadType != LOAD_HISTORY) && (mLoadType != LOAD_ERROR_PAGE)) {
   1:         mOSHE->SetTitle(mTitle);    
   1:     }
   1: 
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIScrollable
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetCurScrollPos(PRInt32 scrollOrientation, PRInt32 * curPos)
   1: {
   1:     NS_ENSURE_ARG_POINTER(curPos);
   1: 
   1:     nsIScrollableView* scrollView;
   1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
   1:                       NS_ERROR_FAILURE);
   1:     if (!scrollView) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     nscoord x, y;
   1:     NS_ENSURE_SUCCESS(scrollView->GetScrollPosition(x, y), NS_ERROR_FAILURE);
   1: 
   1:     switch (scrollOrientation) {
   1:     case ScrollOrientation_X:
   1:         *curPos = x;
   1:         return NS_OK;
   1: 
   1:     case ScrollOrientation_Y:
   1:         *curPos = y;
   1:         return NS_OK;
   1: 
   1:     default:
   1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
   1:     }
   1:     return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetCurScrollPos(PRInt32 scrollOrientation, PRInt32 curPos)
   1: {
   1:     nsIScrollableView* scrollView;
   1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
   1:                       NS_ERROR_FAILURE);
   1:     if (!scrollView) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     PRInt32 other;
   1:     PRInt32 x;
   1:     PRInt32 y;
   1: 
   1:     GetCurScrollPos(scrollOrientation, &other);
   1: 
   1:     switch (scrollOrientation) {
   1:     case ScrollOrientation_X:
   1:         x = curPos;
   1:         y = other;
   1:         break;
   1: 
   1:     case ScrollOrientation_Y:
   1:         x = other;
   1:         y = curPos;
   1:         break;
   1: 
   1:     default:
   1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
   1:         x = 0;
   1:         y = 0;                  // fix compiler warning, not actually executed
   1:     }
   1: 
   1:     NS_ENSURE_SUCCESS(scrollView->ScrollTo(x, y, NS_VMREFRESH_IMMEDIATE),
   1:                       NS_ERROR_FAILURE);
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetCurScrollPosEx(PRInt32 curHorizontalPos, PRInt32 curVerticalPos)
   1: {
   1:     nsIScrollableView* scrollView;
   1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
   1:                       NS_ERROR_FAILURE);
   1:     if (!scrollView) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     NS_ENSURE_SUCCESS(scrollView->ScrollTo(curHorizontalPos, curVerticalPos,
   1:                                            NS_VMREFRESH_IMMEDIATE),
   1:                       NS_ERROR_FAILURE);
   1:     return NS_OK;
   1: }
   1: 
   1: // XXX This is wrong
   1: NS_IMETHODIMP
   1: nsDocShell::GetScrollRange(PRInt32 scrollOrientation,
   1:                            PRInt32 * minPos, PRInt32 * maxPos)
   1: {
   1:     NS_ENSURE_ARG_POINTER(minPos && maxPos);
   1: 
   1:     nsIScrollableView* scrollView;
   1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
   1:                       NS_ERROR_FAILURE);
   1:     if (!scrollView) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     PRInt32 cx;
   1:     PRInt32 cy;
   1: 
   1:     NS_ENSURE_SUCCESS(scrollView->GetContainerSize(&cx, &cy), NS_ERROR_FAILURE);
   1:     *minPos = 0;
   1: 
   1:     switch (scrollOrientation) {
   1:     case ScrollOrientation_X:
   1:         *maxPos = cx;
   1:         return NS_OK;
   1: 
   1:     case ScrollOrientation_Y:
   1:         *maxPos = cy;
   1:         return NS_OK;
   1: 
   1:     default:
   1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
   1:     }
   1: 
   1:     return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetScrollRange(PRInt32 scrollOrientation,
   1:                            PRInt32 minPos, PRInt32 maxPos)
   1: {
   1:     //XXX First Check
   1:     /*
   1:        Retrieves or Sets the valid ranges for the thumb.  When maxPos is set to 
   1:        something less than the current thumb position, curPos is set = to maxPos.
   1: 
   1:        @return NS_OK - Setting or Getting completed successfully.
   1:        NS_ERROR_INVALID_ARG - returned when curPos is not within the
   1:        minPos and maxPos.
   1:      */
   1:     return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetScrollRangeEx(PRInt32 minHorizontalPos,
   1:                              PRInt32 maxHorizontalPos, PRInt32 minVerticalPos,
   1:                              PRInt32 maxVerticalPos)
   1: {
   1:     //XXX First Check
   1:     /*
   1:        Retrieves or Sets the valid ranges for the thumb.  When maxPos is set to 
   1:        something less than the current thumb position, curPos is set = to maxPos.
   1: 
   1:        @return NS_OK - Setting or Getting completed successfully.
   1:        NS_ERROR_INVALID_ARG - returned when curPos is not within the
   1:        minPos and maxPos.
   1:      */
   1:     return NS_ERROR_FAILURE;
   1: }
   1: 
   1: // This returns setting for all documents in this webshell
   1: NS_IMETHODIMP
   1: nsDocShell::GetDefaultScrollbarPreferences(PRInt32 scrollOrientation,
   1:                                            PRInt32 * scrollbarPref)
   1: {
   1:     NS_ENSURE_ARG_POINTER(scrollbarPref);
   1:     switch (scrollOrientation) {
   1:     case ScrollOrientation_X:
   1:         *scrollbarPref = mDefaultScrollbarPref.x;
   1:         return NS_OK;
   1: 
   1:     case ScrollOrientation_Y:
   1:         *scrollbarPref = mDefaultScrollbarPref.y;
   1:         return NS_OK;
   1: 
   1:     default:
   1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
   1:     }
   1:     return NS_ERROR_FAILURE;
   1: }
   1: 
   1: // Set scrolling preference for all documents in this shell
   1: //
   1: // There are three possible values stored in the shell:
   1: //  1) nsIScrollable::Scrollbar_Never = no scrollbar
   1: //  2) nsIScrollable::Scrollbar_Auto = scrollbar appears if the document
   1: //     being displayed would normally have scrollbar
   1: //  3) nsIScrollable::Scrollbar_Always = scrollbar always appears
   1: //
   1: // One important client is nsHTMLFrameInnerFrame::CreateWebShell()
   1: NS_IMETHODIMP
   1: nsDocShell::SetDefaultScrollbarPreferences(PRInt32 scrollOrientation,
   1:                                            PRInt32 scrollbarPref)
   1: {
   1:     switch (scrollOrientation) {
   1:     case ScrollOrientation_X:
   1:         mDefaultScrollbarPref.x = scrollbarPref;
   1:         return NS_OK;
   1: 
   1:     case ScrollOrientation_Y:
   1:         mDefaultScrollbarPref.y = scrollbarPref;
   1:         return NS_OK;
   1: 
   1:     default:
   1:         NS_ENSURE_TRUE(PR_FALSE, NS_ERROR_INVALID_ARG);
   1:     }
   1:     return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetScrollbarVisibility(PRBool * verticalVisible,
   1:                                    PRBool * horizontalVisible)
   1: {
   1:     nsIScrollableView* scrollView;
   1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
   1:                       NS_ERROR_FAILURE);
   1:     if (!scrollView)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     // We should now call nsLayoutUtils::GetScrollableFrameFor,
   1:     // but we can't because of stupid linkage!
   1:     nsIFrame* scrollFrame =
3233:         static_cast<nsIFrame*>(scrollView->View()->GetParent()->GetClientData());
   1:     if (!scrollFrame)
   1:         return NS_ERROR_FAILURE;
   1:     nsIScrollableFrame* scrollable = nsnull;
   1:     CallQueryInterface(scrollFrame, &scrollable);
   1:     if (!scrollable)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     nsMargin scrollbars = scrollable->GetActualScrollbarSizes();
   1:     if (verticalVisible)
   1:         *verticalVisible = scrollbars.left != 0 || scrollbars.right != 0;
   1:     if (horizontalVisible)
   1:         *horizontalVisible = scrollbars.top != 0 || scrollbars.bottom != 0;
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsITextScroll
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::ScrollByLines(PRInt32 numLines)
   1: {
   1:     nsIScrollableView* scrollView;
   1: 
   1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
   1:                       NS_ERROR_FAILURE);
   1:     if (!scrollView) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     NS_ENSURE_SUCCESS(scrollView->ScrollByLines(0, numLines), NS_ERROR_FAILURE);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::ScrollByPages(PRInt32 numPages)
   1: {
   1:     nsIScrollableView* scrollView;
   1: 
   1:     NS_ENSURE_SUCCESS(GetRootScrollableView(&scrollView),
   1:                       NS_ERROR_FAILURE);
   1:     if (!scrollView) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     NS_ENSURE_SUCCESS(scrollView->ScrollByPages(0, numPages), NS_ERROR_FAILURE);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIScriptGlobalObjectOwner
   1: //*****************************************************************************   
   1: 
   1: nsIScriptGlobalObject*
   1: nsDocShell::GetScriptGlobalObject()
   1: {
   1:     NS_ENSURE_SUCCESS(EnsureScriptEnvironment(), nsnull);
   1: 
   1:     return mScriptGlobal;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIRefreshURI
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::RefreshURI(nsIURI * aURI, PRInt32 aDelay, PRBool aRepeat,
   1:                        PRBool aMetaRefresh)
   1: {
   1:     NS_ENSURE_ARG(aURI);
   1: 
   1:     /* Check if Meta refresh/redirects are permitted. Some
   1:      * embedded applications may not want to do this.
   1:      * Must do this before sending out NOTIFY_REFRESH events
   1:      * because listeners may have side effects (e.g. displaying a
   1:      * button to manually trigger the refresh later).
   1:      */
   1:     PRBool allowRedirects = PR_TRUE;
   1:     GetAllowMetaRedirects(&allowRedirects);
   1:     if (!allowRedirects)
   1:         return NS_OK;
   1: 
   1:     // If any web progress listeners are listening for NOTIFY_REFRESH events,
   1:     // give them a chance to block this refresh.
   1:     PRBool sameURI;
   1:     nsresult rv = aURI->Equals(mCurrentURI, &sameURI);
   1:     if (NS_FAILED(rv))
   1:         sameURI = PR_FALSE;
   1:     if (!RefreshAttempted(this, aURI, aDelay, sameURI))
   1:         return NS_OK;
   1: 
   1:     nsRefreshTimer *refreshTimer = new nsRefreshTimer();
   1:     NS_ENSURE_TRUE(refreshTimer, NS_ERROR_OUT_OF_MEMORY);
   1:     PRUint32 busyFlags = 0;
   1:     GetBusyFlags(&busyFlags);
   1: 
   1:     nsCOMPtr<nsISupports> dataRef = refreshTimer;    // Get the ref count to 1
   1: 
   1:     refreshTimer->mDocShell = this;
   1:     refreshTimer->mURI = aURI;
   1:     refreshTimer->mDelay = aDelay;
   1:     refreshTimer->mRepeat = aRepeat;
   1:     refreshTimer->mMetaRefresh = aMetaRefresh;
   1: 
   1:     if (!mRefreshURIList) {
   1:         NS_ENSURE_SUCCESS(NS_NewISupportsArray(getter_AddRefs(mRefreshURIList)),
   1:                           NS_ERROR_FAILURE);
   1:     }
   1: 
   1:     if (busyFlags & BUSY_FLAGS_BUSY) {
   1:         // We are busy loading another page. Don't create the
   1:         // timer right now. Instead queue up the request and trigger the
   1:         // timer in EndPageLoad(). 
   1:         mRefreshURIList->AppendElement(refreshTimer);
   1:     }
   1:     else {
   1:         // There is no page loading going on right now.  Create the
   1:         // timer and fire it right away.
   1:         nsCOMPtr<nsITimer> timer = do_CreateInstance("@mozilla.org/timer;1");
   1:         NS_ENSURE_TRUE(timer, NS_ERROR_FAILURE);
   1: 
   1:         mRefreshURIList->AppendElement(timer);      // owning timer ref
   1:         timer->InitWithCallback(refreshTimer, aDelay, nsITimer::TYPE_ONE_SHOT);
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::ForceRefreshURI(nsIURI * aURI,
   1:                             PRInt32 aDelay, 
   1:                             PRBool aMetaRefresh)
   1: {
   1:     NS_ENSURE_ARG(aURI);
   1: 
   1:     nsCOMPtr<nsIDocShellLoadInfo> loadInfo;
   1:     CreateLoadInfo(getter_AddRefs(loadInfo));
   1:     NS_ENSURE_TRUE(loadInfo, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:     /* We do need to pass in a referrer, but we don't want it to
   1:      * be sent to the server.
   1:      */
   1:     loadInfo->SetSendReferrer(PR_FALSE);
   1: 
   1:     /* for most refreshes the current URI is an appropriate
   1:      * internal referrer
   1:      */
   1:     loadInfo->SetReferrer(mCurrentURI);
   1: 
   1:     /* Check if this META refresh causes a redirection
   1:      * to another site. 
   1:      */
   1:     PRBool equalUri = PR_FALSE;
   1:     nsresult rv = aURI->Equals(mCurrentURI, &equalUri);
   1:     if (NS_SUCCEEDED(rv) && (!equalUri) && aMetaRefresh) {
   1: 
   1:         /* It is a META refresh based redirection. Now check if it happened
   1:            within the threshold time we have in mind(15000 ms as defined by
   1:            REFRESH_REDIRECT_TIMER). If so, pass a REPLACE flag to LoadURI().
   1:          */
   1:         if (aDelay <= REFRESH_REDIRECT_TIMER) {
   1:             loadInfo->SetLoadType(nsIDocShellLoadInfo::loadNormalReplace);
   1:             
   1:             /* for redirects we mimic HTTP, which passes the
   1:              *  original referrer
   1:              */
   1:             nsCOMPtr<nsIURI> internalReferrer;
   1:             GetReferringURI(getter_AddRefs(internalReferrer));
   1:             if (internalReferrer) {
   1:                 loadInfo->SetReferrer(internalReferrer);
   1:             }
   1:         }
   1:         else
   1:             loadInfo->SetLoadType(nsIDocShellLoadInfo::loadRefresh);
   1:         /*
   1:          * LoadURI(...) will cancel all refresh timers... This causes the
   1:          * Timer and its refreshData instance to be released...
   1:          */
   1:         LoadURI(aURI, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, PR_TRUE);
   1:         return NS_OK;
   1:     }
   1:     else
   1:         loadInfo->SetLoadType(nsIDocShellLoadInfo::loadRefresh);
   1: 
   1:     LoadURI(aURI, loadInfo, nsIWebNavigation::LOAD_FLAGS_NONE, PR_TRUE);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::SetupRefreshURIFromHeader(nsIURI * aBaseURI,
   1:                                       const nsACString & aHeader)
   1: {
   1:     // Refresh headers are parsed with the following format in mind
   1:     // <META HTTP-EQUIV=REFRESH CONTENT="5; URL=http://uri">
   1:     // By the time we are here, the following is true:
   1:     // header = "REFRESH"
   1:     // content = "5; URL=http://uri" // note the URL attribute is
   1:     // optional, if it is absent, the currently loaded url is used.
   1:     // Also note that the seconds and URL separator can be either
   1:     // a ';' or a ','. The ',' separator should be illegal but CNN
   1:     // is using it.
   1:     // 
   1:     // We need to handle the following strings, where
   1:     //  - X is a set of digits
   1:     //  - URI is either a relative or absolute URI
   1:     //
   1:     // Note that URI should start with "url=" but we allow omission
   1:     //
   1:     // "" || ";" || "," 
   1:     //  empty string. use the currently loaded URI
   1:     //  and refresh immediately.
   1:     // "X" || "X;" || "X,"
   1:     //  Refresh the currently loaded URI in X seconds.
   1:     // "X; URI" || "X, URI"
   1:     //  Refresh using URI as the destination in X seconds.
   1:     // "URI" || "; URI" || ", URI"
   1:     //  Refresh immediately using URI as the destination.
   1:     // 
   1:     // Currently, anything immediately following the URI, if
   1:     // separated by any char in the set "'\"\t\r\n " will be
   1:     // ignored. So "10; url=go.html ; foo=bar" will work,
   1:     // and so will "10; url='go.html'; foo=bar". However,
   1:     // "10; url=go.html; foo=bar" will result in the uri
   1:     // "go.html;" since ';' and ',' are valid uri characters.
   1:     // 
   1:     // Note that we need to remove any tokens wrapping the URI.
   1:     // These tokens currently include spaces, double and single
   1:     // quotes.
   1: 
   1:     // when done, seconds is 0 or the given number of seconds
   1:     //            uriAttrib is empty or the URI specified
   1:     nsCAutoString uriAttrib;
   1:     PRInt32 seconds = 0;
   1:     PRBool specifiesSeconds = PR_FALSE;
   1: 
   1:     nsACString::const_iterator iter, tokenStart, doneIterating;
   1: 
   1:     aHeader.BeginReading(iter);
   1:     aHeader.EndReading(doneIterating);
   1: 
   1:     // skip leading whitespace
   1:     while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
   1:         ++iter;
   1: 
   1:     tokenStart = iter;
   1: 
   1:     // skip leading + and -
   1:     if (iter != doneIterating && (*iter == '-' || *iter == '+'))
   1:         ++iter;
   1: 
   1:     // parse number
   1:     while (iter != doneIterating && (*iter >= '0' && *iter <= '9')) {
   1:         seconds = seconds * 10 + (*iter - '0');
   1:         specifiesSeconds = PR_TRUE;
   1:         ++iter;
   1:     }
   1: 
   1:     if (iter != doneIterating) {
   1:         // if we started with a '-', number is negative
   1:         if (*tokenStart == '-')
   1:             seconds = -seconds;
   1: 
   1:         // skip to next ';' or ','
   1:         nsACString::const_iterator iterAfterDigit = iter;
   1:         while (iter != doneIterating && !(*iter == ';' || *iter == ','))
   1:         {
   1:             if (specifiesSeconds)
   1:             {
   1:                 // Non-whitespace characters here mean that the string is
   1:                 // malformed but tolerate sites that specify a decimal point,
   1:                 // even though meta refresh only works on whole seconds.
   1:                 if (iter == iterAfterDigit &&
   1:                     !nsCRT::IsAsciiSpace(*iter) && *iter != '.')
   1:                 {
   1:                     // The characters between the seconds and the next
   1:                     // section are just garbage!
   1:                     //   e.g. content="2a0z+,URL=http://www.mozilla.org/"
   1:                     // Just ignore this redirect.
   1:                     return NS_ERROR_FAILURE;
   1:                 }
   1:                 else if (nsCRT::IsAsciiSpace(*iter))
   1:                 {
   1:                     // We've had at least one whitespace so tolerate the mistake
   1:                     // and drop through.
   1:                     // e.g. content="10 foo"
   1:                     ++iter;
   1:                     break;
   1:                 }
   1:             }
   1:             ++iter;
   1:         }
   1: 
   1:         // skip any remaining whitespace
   1:         while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
   1:             ++iter;
   1: 
   1:         // skip ';' or ','
   1:         if (iter != doneIterating && (*iter == ';' || *iter == ',')) {
   1:             ++iter;
   1:         }
   1: 
   1:         // skip whitespace
   1:         while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
   1:             ++iter;
   1:     }
   1: 
   1:     // possible start of URI
   1:     tokenStart = iter;
   1: 
   1:     // skip "url = " to real start of URI
   1:     if (iter != doneIterating && (*iter == 'u' || *iter == 'U')) {
   1:         ++iter;
   1:         if (iter != doneIterating && (*iter == 'r' || *iter == 'R')) {
   1:             ++iter;
   1:             if (iter != doneIterating && (*iter == 'l' || *iter == 'L')) {
   1:                 ++iter;
   1: 
   1:                 // skip whitespace
   1:                 while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
   1:                     ++iter;
   1: 
   1:                 if (iter != doneIterating && *iter == '=') {
   1:                     ++iter;
   1: 
   1:                     // skip whitespace
   1:                     while (iter != doneIterating && nsCRT::IsAsciiSpace(*iter))
   1:                         ++iter;
   1: 
   1:                     // found real start of URI
   1:                     tokenStart = iter;
   1:                 }
   1:             }
   1:         }
   1:     }
   1: 
   1:     // skip a leading '"' or '\''.
   1: 
   1:     PRBool isQuotedURI = PR_FALSE;
   1:     if (tokenStart != doneIterating && (*tokenStart == '"' || *tokenStart == '\''))
   1:     {
   1:         isQuotedURI = PR_TRUE;
   1:         ++tokenStart;
   1:     }
   1: 
   1:     // set iter to start of URI
   1:     iter = tokenStart;
   1: 
   1:     // tokenStart here points to the beginning of URI
   1: 
   1:     // grab the rest of the URI
   1:     while (iter != doneIterating)
   1:     {
   1:         if (isQuotedURI && (*iter == '"' || *iter == '\''))
   1:             break;
   1:         ++iter;
   1:     }
   1: 
   1:     // move iter one back if the last character is a '"' or '\''
   1:     if (iter != tokenStart && isQuotedURI) {
   1:         --iter;
   1:         if (!(*iter == '"' || *iter == '\''))
   1:             ++iter;
   1:     }
   1: 
   1:     // URI is whatever's contained from tokenStart to iter.
   1:     // note: if tokenStart == doneIterating, so is iter.
   1: 
   1:     nsresult rv = NS_OK;
   1: 
   1:     nsCOMPtr<nsIURI> uri;
   1:     PRBool specifiesURI = PR_FALSE;
   1:     if (tokenStart == iter) {
   1:         uri = aBaseURI;
   1:     }
   1:     else {
   1:         uriAttrib = Substring(tokenStart, iter);
   1:         // NS_NewURI takes care of any whitespace surrounding the URL
   1:         rv = NS_NewURI(getter_AddRefs(uri), uriAttrib, nsnull, aBaseURI);
   1:         specifiesURI = PR_TRUE;
   1:     }
   1: 
   1:     // No URI or seconds were specified
   1:     if (!specifiesSeconds && !specifiesURI)
   1:     {
   1:         // Do nothing because the alternative is to spin around in a refresh
   1:         // loop forever!
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     if (NS_SUCCEEDED(rv)) {
   1:         nsCOMPtr<nsIScriptSecurityManager>
   1:             securityManager(do_GetService
   1:                             (NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv));
   1:         if (NS_SUCCEEDED(rv)) {
   1:             rv = securityManager->
   1:                 CheckLoadURI(aBaseURI, uri,
   1:                              nsIScriptSecurityManager::
   1:                              LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT);
   1:             if (NS_SUCCEEDED(rv)) {
   1:                 // Since we can't travel back in time yet, just pretend
   1:                 // negative numbers do nothing at all.
   1:                 if (seconds < 0)
   1:                     return NS_ERROR_FAILURE;
   1: 
   1:                 rv = RefreshURI(uri, seconds * 1000, PR_FALSE, PR_TRUE);
   1:             }
   1:         }
   1:     }
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::SetupRefreshURI(nsIChannel * aChannel)
   1: {
   1:     nsresult rv;
   1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel, &rv));
   1:     if (NS_SUCCEEDED(rv)) {
   1:         nsCAutoString refreshHeader;
   1:         rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("refresh"),
   1:                                             refreshHeader);
   1: 
   1:         if (!refreshHeader.IsEmpty()) {
   1:             SetupReferrerFromChannel(aChannel);
   1:             rv = SetupRefreshURIFromHeader(mCurrentURI, refreshHeader);
   1:             if (NS_SUCCEEDED(rv)) {
   1:                 return NS_REFRESHURI_HEADER_FOUND;
   1:             }
   1:         }
   1:     }
   1:     return rv;
   1: }
   1: 
   1: static void
   1: DoCancelRefreshURITimers(nsISupportsArray* aTimerList)
   1: {
   1:     if (!aTimerList)
   1:         return;
   1: 
   1:     PRUint32 n=0;
   1:     aTimerList->Count(&n);
   1: 
   1:     while (n) {
   1:         nsCOMPtr<nsITimer> timer(do_QueryElementAt(aTimerList, --n));
   1: 
   1:         aTimerList->RemoveElementAt(n);    // bye bye owning timer ref
   1: 
   1:         if (timer)
   1:             timer->Cancel();        
   1:     }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::CancelRefreshURITimers()
   1: {
   1:     DoCancelRefreshURITimers(mRefreshURIList);
   1:     DoCancelRefreshURITimers(mSavedRefreshURIList);
   1:     mRefreshURIList = nsnull;
   1:     mSavedRefreshURIList = nsnull;
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetRefreshPending(PRBool* _retval)
   1: {
   1:     if (!mRefreshURIList) {
   1:         *_retval = PR_FALSE;
   1:         return NS_OK;
   1:     }
   1: 
   1:     PRUint32 count;
   1:     nsresult rv = mRefreshURIList->Count(&count);
   1:     if (NS_SUCCEEDED(rv))
   1:         *_retval = (count != 0);
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SuspendRefreshURIs()
   1: {
   1:     if (mRefreshURIList) {
   1:         PRUint32 n = 0;
   1:         mRefreshURIList->Count(&n);
   1: 
   1:         for (PRUint32 i = 0;  i < n; ++i) {
   1:             nsCOMPtr<nsITimer> timer = do_QueryElementAt(mRefreshURIList, i);
   1:             if (!timer)
   1:                 continue;  // this must be a nsRefreshURI already
   1: 
   1:             // Replace this timer object with a nsRefreshTimer object.
   1:             nsCOMPtr<nsITimerCallback> callback;
   1:             timer->GetCallback(getter_AddRefs(callback));
   1: 
   1:             timer->Cancel();
   1: 
   1:             nsCOMPtr<nsITimerCallback> rt = do_QueryInterface(callback);
   1:             NS_ASSERTION(rt, "RefreshURIList timer callbacks should only be RefreshTimer objects");
   1: 
   1:             mRefreshURIList->ReplaceElementAt(rt, i);
   1:         }
   1:     }
   1: 
   1:     // Suspend refresh URIs for our child shells as well.
   1:     PRInt32 n = mChildList.Count();
   1: 
   1:     for (PRInt32 i = 0; i < n; ++i) {
   1:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
   1:         if (shell)
   1:             shell->SuspendRefreshURIs();
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::ResumeRefreshURIs()
   1: {
   1:     RefreshURIFromQueue();
   1: 
   1:     // Resume refresh URIs for our child shells as well.
   1:     PRInt32 n = mChildList.Count();
   1: 
   1:     for (PRInt32 i = 0; i < n; ++i) {
   1:         nsCOMPtr<nsIDocShell> shell = do_QueryInterface(ChildAt(i));
   1:         if (shell)
   1:             shell->ResumeRefreshURIs();
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::RefreshURIFromQueue()
   1: {
   1:     if (!mRefreshURIList)
   1:         return NS_OK;
   1:     PRUint32 n = 0;
   1:     mRefreshURIList->Count(&n);
   1: 
   1:     while (n) {
   1:         nsCOMPtr<nsISupports> element;
   1:         mRefreshURIList->GetElementAt(--n, getter_AddRefs(element));
   1:         nsCOMPtr<nsITimerCallback> refreshInfo(do_QueryInterface(element));
   1: 
   1:         if (refreshInfo) {   
   1:             // This is the nsRefreshTimer object, waiting to be
   1:             // setup in a timer object and fired.                         
   1:             // Create the timer and  trigger it.
3233:             PRUint32 delay = static_cast<nsRefreshTimer*>(static_cast<nsITimerCallback*>(refreshInfo))->GetDelay();
   1:             nsCOMPtr<nsITimer> timer = do_CreateInstance("@mozilla.org/timer;1");
   1:             if (timer) {    
   1:                 // Replace the nsRefreshTimer element in the queue with
   1:                 // its corresponding timer object, so that in case another
   1:                 // load comes through before the timer can go off, the timer will
   1:                 // get cancelled in CancelRefreshURITimer()
   1:                 mRefreshURIList->ReplaceElementAt(timer, n);
   1:                 timer->InitWithCallback(refreshInfo, delay, nsITimer::TYPE_ONE_SHOT);
   1:             }           
   1:         }        
   1:     }  // while
   1:  
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIContentViewerContainer
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::Embed(nsIContentViewer * aContentViewer,
   1:                   const char *aCommand, nsISupports * aExtraInfo)
   1: {
   1:     // Save the LayoutHistoryState of the previous document, before
   1:     // setting up new document
   1:     PersistLayoutHistoryState();
   1: 
   1:     nsresult rv = SetupNewViewer(aContentViewer);
   1: 
   1:     // If we are loading a wyciwyg url from history, change the base URI for 
   1:     // the document to the original http url that created the document.write().
   1:     // This makes sure that all relative urls in a document.written page loaded
   1:     // via history work properly.
   1:     if (mCurrentURI &&
   1:        (mLoadType & LOAD_CMD_HISTORY ||
   1:         mLoadType == LOAD_RELOAD_NORMAL ||
   1:         mLoadType == LOAD_RELOAD_CHARSET_CHANGE)){
   1:         PRBool isWyciwyg = PR_FALSE;
   1:         // Check if the url is wyciwyg
   1:         rv = mCurrentURI->SchemeIs("wyciwyg", &isWyciwyg);      
   1:         if (isWyciwyg && NS_SUCCEEDED(rv))
   1:             SetBaseUrlForWyciwyg(aContentViewer);
   1:     }
   1:     // XXX What if SetupNewViewer fails?
   1:     if (mLSHE)
   1:         SetHistoryEntry(&mOSHE, mLSHE);
   1: 
   1:     PRBool updateHistory = PR_TRUE;
   1: 
   1:     // Determine if this type of load should update history
   1:     switch (mLoadType) {
   1:     case LOAD_NORMAL_REPLACE:
   1:     case LOAD_STOP_CONTENT_AND_REPLACE:
   1:     case LOAD_RELOAD_BYPASS_CACHE:
   1:     case LOAD_RELOAD_BYPASS_PROXY:
   1:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
   1:         updateHistory = PR_FALSE;
   1:         break;
   1:     default:
   1:         break;
   1:     }
   1: 
   1:     if (!updateHistory)
   1:         SetLayoutHistoryState(nsnull);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: /* void setIsPrinting (in boolean aIsPrinting); */
   1: NS_IMETHODIMP 
   1: nsDocShell::SetIsPrinting(PRBool aIsPrinting)
   1: {
   1:     mIsPrintingOrPP = aIsPrinting;
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIWebProgressListener
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::OnProgressChange(nsIWebProgress * aProgress,
   1:                              nsIRequest * aRequest,
   1:                              PRInt32 aCurSelfProgress,
   1:                              PRInt32 aMaxSelfProgress,
   1:                              PRInt32 aCurTotalProgress,
   1:                              PRInt32 aMaxTotalProgress)
   1: {
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::OnStateChange(nsIWebProgress * aProgress, nsIRequest * aRequest,
   1:                           PRUint32 aStateFlags, nsresult aStatus)
   1: {
   1:     nsresult rv;
   1: 
   1:     // Update the busy cursor
   1:     if ((~aStateFlags & (STATE_START | STATE_IS_NETWORK)) == 0) {
   1:         nsCOMPtr<nsIWyciwygChannel>  wcwgChannel(do_QueryInterface(aRequest));
   1:         nsCOMPtr<nsIWebProgress> webProgress =
   1:             do_QueryInterface(GetAsSupports(this));
   1: 
   1:         // Was the wyciwyg document loaded on this docshell?
   1:         if (wcwgChannel && !mLSHE && (mItemType == typeContent) && aProgress == webProgress.get()) {
   1:             nsCOMPtr<nsIURI> uri;
   1:             wcwgChannel->GetURI(getter_AddRefs(uri));
   1:         
   1:             PRBool equalUri = PR_TRUE;
   1:             // Store the wyciwyg url in session history, only if it is
   1:             // being loaded fresh for the first time. We don't want 
   1:             // multiple entries for successive loads
   1:             if (mCurrentURI &&
   1:                 NS_SUCCEEDED(uri->Equals(mCurrentURI, &equalUri)) &&
   1:                 !equalUri) {
   1:                 // This is a document.write(). Get the made-up url
   1:                 // from the channel and store it in session history.
   1:                 rv = AddToSessionHistory(uri, wcwgChannel, getter_AddRefs(mLSHE));
   1:                 SetCurrentURI(uri, aRequest, PR_TRUE);
   1:                 // Save history state of the previous page
   1:                 rv = PersistLayoutHistoryState();
   1:                 if (mOSHE)
   1:                     SetHistoryEntry(&mOSHE, mLSHE);
   1:             }
   1:         
   1:         }
   1:         // Page has begun to load
   1:         mBusyFlags = BUSY_FLAGS_BUSY | BUSY_FLAGS_BEFORE_PAGE_LOAD;
   1:         nsCOMPtr<nsIWidget> mainWidget;
   1:         GetMainWidget(getter_AddRefs(mainWidget));
   1:         if (mainWidget) {
   1:             mainWidget->SetCursor(eCursor_spinning);
   1:         }
   1:     }
   1:     else if ((~aStateFlags & (STATE_TRANSFERRING | STATE_IS_DOCUMENT)) == 0) {
   1:         // Page is loading
   1:         mBusyFlags = BUSY_FLAGS_BUSY | BUSY_FLAGS_PAGE_LOADING;
   1:     }
   1:     else if ((aStateFlags & STATE_STOP) && (aStateFlags & STATE_IS_NETWORK)) {
   1:         // Page has finished loading
   1:         mBusyFlags = BUSY_FLAGS_NONE;
   1:         nsCOMPtr<nsIWidget> mainWidget;
   1:         GetMainWidget(getter_AddRefs(mainWidget));
   1:         if (mainWidget) {
   1:             mainWidget->SetCursor(eCursor_standard);
   1:         }
   1:     }
   1:     if ((~aStateFlags & (STATE_IS_DOCUMENT | STATE_STOP)) == 0) {
   1:         nsCOMPtr<nsIWebProgress> webProgress =
   1:             do_QueryInterface(GetAsSupports(this));
   1:         // Is the document stop notification for this document?
   1:         if (aProgress == webProgress.get()) {
   1:             nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
   1:             EndPageLoad(aProgress, channel, aStatus);
   1:         }
   1:     }
   1:     // note that redirect state changes will go through here as well, but it
   1:     // is better to handle those in OnRedirectStateChange where more
   1:     // information is available.
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::OnLocationChange(nsIWebProgress * aProgress,
   1:                              nsIRequest * aRequest, nsIURI * aURI)
   1: {
   1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
   1:     return NS_OK;
   1: }
   1: 
   1: void
   1: nsDocShell::OnRedirectStateChange(nsIChannel* aOldChannel,
   1:                                   nsIChannel* aNewChannel,
   1:                                   PRUint32 aRedirectFlags,
   1:                                   PRUint32 aStateFlags)
   1: {
   1:     NS_ASSERTION(aStateFlags & STATE_REDIRECTING,
   1:                  "Calling OnRedirectStateChange when there is no redirect");
   1:     if (!(aStateFlags & STATE_IS_DOCUMENT))
   1:         return; // not a toplevel document
   1: 
5528:     // If this load is being checked by the URI classifier, we need to
5528:     // query the classifier again for the new URI.
5528:     if (mClassifier) {
5528:         mClassifier->SetChannel(aNewChannel);
5528: 
5528:         // we call the nsClassifierCallback:Run() from the main loop to
5528:         // give the channel a chance to AsyncOpen() the channel before
5528:         // we suspend it.
5528:         NS_DispatchToCurrentThread(mClassifier);
5528:     }
5528: 
   1:     nsCOMPtr<nsIGlobalHistory3> history3(do_QueryInterface(mGlobalHistory));
   1:     nsresult result = NS_ERROR_NOT_IMPLEMENTED;
   1:     if (history3) {
   1:         // notify global history of this redirect
   1:         result = history3->AddDocumentRedirect(aOldChannel, aNewChannel,
   1:                                                aRedirectFlags, !IsFrame());
   1:     }
   1: 
   1:     if (result == NS_ERROR_NOT_IMPLEMENTED) {
   1:         // when there is no GlobalHistory3, or it doesn't implement
   1:         // AddToplevelRedirect, we fall back to GlobalHistory2.  Just notify
   1:         // that the redirecting page was a redirect so it will be link colored
   1:         // but not visible.
   1:         nsCOMPtr<nsIURI> oldURI;
   1:         aOldChannel->GetURI(getter_AddRefs(oldURI));
   1:         if (! oldURI)
   1:             return; // nothing to tell anybody about
   1:         AddToGlobalHistory(oldURI, PR_TRUE, aOldChannel);
   1:     }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::OnStatusChange(nsIWebProgress * aWebProgress,
   1:                            nsIRequest * aRequest,
   1:                            nsresult aStatus, const PRUnichar * aMessage)
   1: {
   1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::OnSecurityChange(nsIWebProgress * aWebProgress,
   1:                              nsIRequest * aRequest, PRUint32 state)
   1: {
   1:     NS_NOTREACHED("notification excluded in AddProgressListener(...)");
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: nsresult
   1: nsDocShell::EndPageLoad(nsIWebProgress * aProgress,
   1:                         nsIChannel * aChannel, nsresult aStatus)
   1: {
   1:     //
   1:     // one of many safeguards that prevent death and destruction if
   1:     // someone is so very very rude as to bring this window down
   1:     // during this load handler.
   1:     //
   1:     nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
5528: 
5528:     // We're done with the URI classifier for this channel
5528:     mClassifier = nsnull;
5528: 
   1:     //
   1:     // Notify the ContentViewer that the Document has finished loading...
   1:     //
   1:     // This will cause any OnLoad(...) handlers to fire, if it is a HTML
   1:     // document...
   1:     //
   1:     if (!mEODForCurrentDocument && mContentViewer) {
   1:         mIsExecutingOnLoadHandler = PR_TRUE;
   1:         mContentViewer->LoadComplete(aStatus);
   1:         mIsExecutingOnLoadHandler = PR_FALSE;
   1: 
   1:         mEODForCurrentDocument = PR_TRUE;
   1: 
   1:         // If all documents have completed their loading
   1:         // favor native event dispatch priorities
   1:         // over performance
   1:         if (--gNumberOfDocumentsLoading == 0) {
   1:           // Hint to use normal native event dispatch priorities 
   1:           FavorPerformanceHint(PR_FALSE, NS_EVENT_STARVATION_DELAY_HINT);
   1:         }
   1:     }
   1:     /* Check if the httpChannel has any cache-control related response headers,
   1:      * like no-store, no-cache. If so, update SHEntry so that 
   1:      * when a user goes back/forward to this page, we appropriately do 
   1:      * form value restoration or load from server.
   1:      */
   1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
   1:     if (!httpChannel) // HttpChannel could be hiding underneath a Multipart channel.    
   1:         GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
   1: 
   1:     if (httpChannel) {
   1:         // figure out if SH should be saving layout state.
   1:         PRBool discardLayoutState = ShouldDiscardLayoutState(httpChannel);       
   1:         if (mLSHE && discardLayoutState && (mLoadType & LOAD_CMD_NORMAL) &&
   1:             (mLoadType != LOAD_BYPASS_HISTORY) && (mLoadType != LOAD_ERROR_PAGE))
   1:             mLSHE->SetSaveLayoutStateFlag(PR_FALSE);            
   1:     }
   1: 
   1:     // Clear mLSHE after calling the onLoadHandlers. This way, if the
   1:     // onLoadHandler tries to load something different in
   1:     // itself or one of its children, we can deal with it appropriately.
   1:     if (mLSHE) {
   1:         mLSHE->SetLoadType(nsIDocShellLoadInfo::loadHistory);
   1: 
   1:         // Clear the mLSHE reference to indicate document loading is done one
   1:         // way or another.
   1:         SetHistoryEntry(&mLSHE, nsnull);
   1:     }
   1:     // if there's a refresh header in the channel, this method
   1:     // will set it up for us. 
   1:     RefreshURIFromQueue();
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: //*****************************************************************************
   1: // nsDocShell: Content Viewer Management
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::EnsureContentViewer()
   1: {
   1:     if (mContentViewer)
   1:         return NS_OK;
   1:     if (mIsBeingDestroyed)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     nsIPrincipal* principal = nsnull;
   1: 
   1:     nsCOMPtr<nsPIDOMWindow> piDOMWindow(do_QueryInterface(mScriptGlobal));
   1:     if (piDOMWindow) {
   1:         principal = piDOMWindow->GetOpenerScriptPrincipal();
   1:     }
   1: 
   1:     if (!principal) {
   1:         principal = GetInheritedPrincipal(PR_FALSE);
   1:     }
   1: 
   1:     nsresult rv = CreateAboutBlankContentViewer(principal);
   1: 
   1:     if (NS_SUCCEEDED(rv)) {
   1:         nsCOMPtr<nsIDOMDocument> domDoc;
   1:         mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
   1:         nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
   1:         NS_ASSERTION(doc,
   1:                      "Should have doc if CreateAboutBlankContentViewer "
   1:                      "succeeded!");
   1: 
   1:         doc->SetIsInitialDocument(PR_TRUE);
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::EnsureDeviceContext()
   1: {
   1:     if (mDeviceContext)
   1:         return NS_OK;
   1: 
   1:     mDeviceContext = do_CreateInstance(kDeviceContextCID);
   1:     NS_ENSURE_TRUE(mDeviceContext, NS_ERROR_FAILURE);
   1: 
   1:     nsCOMPtr<nsIWidget> widget;
   1:     GetMainWidget(getter_AddRefs(widget));
   1:     NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
   1: 
   1:     mDeviceContext->Init(widget->GetNativeData(NS_NATIVE_WIDGET));
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::CreateAboutBlankContentViewer(nsIPrincipal* aPrincipal)
   1: {
   1:   nsCOMPtr<nsIDocument> blankDoc;
   1:   nsCOMPtr<nsIContentViewer> viewer;
   1:   nsresult rv = NS_ERROR_FAILURE;
   1: 
   1:   /* mCreatingDocument should never be true at this point. However, it's
   1:      a theoretical possibility. We want to know about it and make it stop,
   1:      and this sounds like a job for an assertion. */
   1:   NS_ASSERTION(!mCreatingDocument, "infinite(?) loop creating document averted");
   1:   if (mCreatingDocument)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   mCreatingDocument = PR_TRUE;
   1: 
   1:   // mContentViewer->PermitUnload may release |this| docshell.
   1:   nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
   1:   
   1:   if (mContentViewer) {
   1:     // We've got a content viewer already. Make sure the user
   1:     // permits us to discard the current document and replace it
   1:     // with about:blank. And also ensure we fire the unload events
   1:     // in the current document.
   1: 
   1:     PRBool okToUnload;
   1:     rv = mContentViewer->PermitUnload(&okToUnload);
   1: 
   1:     if (NS_SUCCEEDED(rv) && !okToUnload) {
   1:       // The user chose not to unload the page, interrupt the load.
   1:       return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     mSavingOldViewer = CanSavePresentation(LOAD_NORMAL, nsnull, nsnull);
   1: 
   1:     // Notify the current document that it is about to be unloaded!!
   1:     //
   1:     // It is important to fire the unload() notification *before* any state
   1:     // is changed within the DocShell - otherwise, javascript will get the
   1:     // wrong information :-(
   1:     //
   1:     (void) FirePageHideNotification(!mSavingOldViewer);
   1:   }
   1: 
5212:   // Now make sure we don't think we're in the middle of firing unload after
5212:   // this point.  This will make us fire unload when the about:blank document
5212:   // unloads... but that's ok, more or less.  Would be nice if it fired load
5212:   // too, of course.
5212:   mFiredUnloadEvent = PR_FALSE;
5212: 
   1:   // one helper factory, please
   1:   nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID));
   1:   if (!catMan)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsXPIDLCString contractId;
   1:   rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", "text/html", getter_Copies(contractId));
   1:   if (NS_FAILED(rv))
   1:     return rv;
   1: 
   1:   nsCOMPtr<nsIDocumentLoaderFactory> docFactory(do_GetService(contractId));
   1:   if (docFactory) {
   1:     // generate (about:blank) document to load
   1:     docFactory->CreateBlankDocument(mLoadGroup, aPrincipal,
   1:                                     getter_AddRefs(blankDoc));
   1:     if (blankDoc) {
3233:       blankDoc->SetContainer(static_cast<nsIDocShell *>(this));
   1: 
   1:       // create a content viewer for us and the new document
   1:       docFactory->CreateInstanceForDocument(NS_ISUPPORTS_CAST(nsIDocShell *, this),
   1:                     blankDoc, "view", getter_AddRefs(viewer));
   1: 
   1:       // hook 'em up
   1:       if (viewer) {
3233:         viewer->SetContainer(static_cast<nsIContentViewerContainer *>(this));
   1:         nsCOMPtr<nsIDOMDocument> domdoc(do_QueryInterface(blankDoc));
   1:         Embed(viewer, "", 0);
   1:         viewer->SetDOMDocument(domdoc);
   1: 
   1:         SetCurrentURI(blankDoc->GetDocumentURI(), nsnull, PR_TRUE);
   1:         rv = NS_OK;
   1:       }
   1:     }
   1:   }
   1:   mCreatingDocument = PR_FALSE;
   1: 
   1:   // The transient about:blank viewer doesn't have a session history entry.
   1:   SetHistoryEntry(&mOSHE, nsnull);
   1: 
   1:   return rv;
   1: }
   1: 
   1: PRBool
   1: nsDocShell::CanSavePresentation(PRUint32 aLoadType,
   1:                                 nsIRequest *aNewRequest,
   1:                                 nsIDocument *aNewDocument)
   1: {
   1:     if (!mOSHE)
   1:         return PR_FALSE; // no entry to save into
   1: 
   1:     // Only save presentation for "normal" loads and link loads.  Anything else
   1:     // probably wants to refetch the page, so caching the old presentation
   1:     // would be incorrect.
   1:     if (aLoadType != LOAD_NORMAL &&
   1:         aLoadType != LOAD_HISTORY &&
   1:         aLoadType != LOAD_LINK &&
   1:         aLoadType != LOAD_STOP_CONTENT &&
   1:         aLoadType != LOAD_STOP_CONTENT_AND_REPLACE &&
   1:         aLoadType != LOAD_ERROR_PAGE)
   1:         return PR_FALSE;
   1: 
   1:     // If the session history entry has the saveLayoutState flag set to false,
   1:     // then we should not cache the presentation.
   1:     PRBool canSaveState;
   1:     mOSHE->GetSaveLayoutStateFlag(&canSaveState);
   1:     if (canSaveState == PR_FALSE)
   1:         return PR_FALSE;
   1: 
   1:     // If the document is not done loading, don't cache it.
   1:     nsCOMPtr<nsPIDOMWindow> pWin = do_QueryInterface(mScriptGlobal);
   1:     if (!pWin || pWin->IsLoading())
   1:         return PR_FALSE;
   1: 
   1:     if (pWin->WouldReuseInnerWindow(aNewDocument))
   1:         return PR_FALSE;
   1: 
   1:     // Avoid doing the work of saving the presentation state in the case where
   1:     // the content viewer cache is disabled.
   1:     if (nsSHistory::GetMaxTotalViewers() == 0)
   1:         return PR_FALSE;
   1: 
   1:     // Don't cache the content viewer if we're in a subframe and the subframe
   1:     // pref is disabled.
   1:     PRBool cacheFrames = PR_FALSE;
   1:     mPrefs->GetBoolPref("browser.sessionhistory.cache_subframes",
   1:                         &cacheFrames);
   1:     if (!cacheFrames) {
   1:         nsCOMPtr<nsIDocShellTreeItem> root;
   1:         GetSameTypeParent(getter_AddRefs(root));
   1:         if (root && root != this) {
   1:             return PR_FALSE;  // this is a subframe load
   1:         }
   1:     }
   1: 
   1:     // If the document does not want its presentation cached, then don't.
   1:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(pWin->GetExtantDocument());
   1:     if (!doc || !doc->CanSavePresentation(aNewRequest))
   1:         return PR_FALSE;
   1: 
   1:     return PR_TRUE;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::CaptureState()
   1: {
   1:     if (!mOSHE || mOSHE == mLSHE) {
   1:         // No entry to save into, or we're replacing the existing entry.
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     nsCOMPtr<nsPIDOMWindow> privWin = do_QueryInterface(mScriptGlobal);
   1:     if (!privWin)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     nsCOMPtr<nsISupports> windowState;
   1:     nsresult rv = privWin->SaveWindowState(getter_AddRefs(windowState));
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1: #ifdef DEBUG_PAGE_CACHE
   1:     nsCOMPtr<nsIURI> uri;
   1:     mOSHE->GetURI(getter_AddRefs(uri));
   1:     nsCAutoString spec;
   1:     if (uri)
   1:         uri->GetSpec(spec);
   1:     printf("Saving presentation into session history\n");
   1:     printf("  SH URI: %s\n", spec.get());
   1: #endif
   1: 
   1:     rv = mOSHE->SetWindowState(windowState);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     // Suspend refresh URIs and save off the timer queue
   1:     rv = mOSHE->SetRefreshURIList(mSavedRefreshURIList);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     // Capture the current content viewer bounds.
   1:     nsCOMPtr<nsIPresShell> shell;
   1:     nsDocShell::GetPresShell(getter_AddRefs(shell));
   1:     if (shell) {
   1:         nsIViewManager *vm = shell->GetViewManager();
   1:         if (vm) {
   1:             nsIView *rootView = nsnull;
   1:             vm->GetRootView(rootView);
   1:             if (rootView) {
   1:                 nsIWidget *widget = rootView->GetWidget();
   1:                 if (widget) {
   1:                     nsRect bounds(0, 0, 0, 0);
   1:                     widget->GetBounds(bounds);
   1:                     rv = mOSHE->SetViewerBounds(bounds);
   1:                 }
   1:             }
   1:         }
   1:     }
   1: 
   1:     // Capture the docshell hierarchy.
   1:     mOSHE->ClearChildShells();
   1: 
   1:     PRInt32 childCount = mChildList.Count();
   1:     for (PRInt32 i = 0; i < childCount; ++i) {
   1:         nsCOMPtr<nsIDocShellTreeItem> childShell = do_QueryInterface(ChildAt(i));
   1:         NS_ASSERTION(childShell, "null child shell");
   1: 
   1:         mOSHE->AddChildShell(childShell);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::RestorePresentationEvent::Run()
   1: {
   1:     if (mDocShell && NS_FAILED(mDocShell->RestoreFromHistory()))
   1:         NS_WARNING("RestoreFromHistory failed");
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::BeginRestore(nsIContentViewer *aContentViewer, PRBool aTop)
   1: {
   1:     nsresult rv;
   1:     if (!aContentViewer) {
   1:         rv = EnsureContentViewer();
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:         aContentViewer = mContentViewer;
   1:     }
   1: 
   1:     // Dispatch events for restoring the presentation.  We try to simulate
   1:     // the progress notifications loading the document would cause, so we add
   1:     // the document's channel to the loadgroup to initiate stateChange
   1:     // notifications.
   1: 
   1:     nsCOMPtr<nsIDOMDocument> domDoc;
   1:     aContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
   1:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
   1:     if (doc) {
   1:         nsIChannel *channel = doc->GetChannel();
   1:         if (channel) {
   1:             mEODForCurrentDocument = PR_FALSE;
   1:             mIsRestoringDocument = PR_TRUE;
   1:             mLoadGroup->AddRequest(channel, nsnull);
   1:             mIsRestoringDocument = PR_FALSE;
   1:         }
   1:     }
   1: 
   1:     if (!aTop) {
3339:         // This point corresponds to us having gotten OnStartRequest or
3339:         // STATE_START, so do the same thing that CreateContentViewer does at
3339:         // this point to ensure that unload/pagehide events for this document
3339:         // will fire when it's unloaded again.
3339:         mFiredUnloadEvent = PR_FALSE;
3339:         
   1:         // For non-top frames, there is no notion of making sure that the
   1:         // previous document is in the domwindow when STATE_START notifications
   1:         // happen.  We can just call BeginRestore for all of the child shells
   1:         // now.
   1:         rv = BeginRestoreChildren();
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::BeginRestoreChildren()
   1: {
   1:     PRInt32 n = mChildList.Count();
   1:     for (PRInt32 i = 0; i < n; ++i) {
   1:         nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
   1:         if (child) {
   1:             nsresult rv = child->BeginRestore(nsnull, PR_FALSE);
   1:             NS_ENSURE_SUCCESS(rv, rv);
   1:         }
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::FinishRestore()
   1: {
   1:     // First we call finishRestore() on our children.  In the simulated load,
   1:     // all of the child frames finish loading before the main document.
   1: 
   1:     PRInt32 n = mChildList.Count();
   1:     for (PRInt32 i = 0; i < n; ++i) {
   1:         nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
   1:         if (child) {
   1:             child->FinishRestore();
   1:         }
   1:     }
   1: 
   1:     if (mContentViewer) {
   1:         nsCOMPtr<nsIDOMDocument> domDoc;
   1:         mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
   1: 
   1:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
   1:         if (doc) {
   1:             // Finally, we remove the request from the loadgroup.  This will
   1:             // cause onStateChange(STATE_STOP) to fire, which will fire the
   1:             // pageshow event to the chrome.
   1: 
   1:             nsIChannel *channel = doc->GetChannel();
   1:             if (channel) {
   1:                 mIsRestoringDocument = PR_TRUE;
   1:                 mLoadGroup->RemoveRequest(channel, nsnull, NS_OK);
   1:                 mIsRestoringDocument = PR_FALSE;
   1:             }
   1:         }
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetRestoringDocument(PRBool *aRestoring)
   1: {
   1:     *aRestoring = mIsRestoringDocument;
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::RestorePresentation(nsISHEntry *aSHEntry, PRBool *aRestoring)
   1: {
   1:     NS_ASSERTION(mLoadType & LOAD_CMD_HISTORY,
   1:                  "RestorePresentation should only be called for history loads");
   1: 
   1:     nsCOMPtr<nsIContentViewer> viewer;
   1:     aSHEntry->GetContentViewer(getter_AddRefs(viewer));
   1: 
   1: #ifdef DEBUG_PAGE_CACHE
   1:     nsCOMPtr<nsIURI> uri;
   1:     aSHEntry->GetURI(getter_AddRefs(uri));
   1: 
   1:     nsCAutoString spec;
   1:     if (uri)
   1:         uri->GetSpec(spec);
   1: #endif
   1: 
   1:     *aRestoring = PR_FALSE;
   1: 
   1:     if (!viewer) {
   1: #ifdef DEBUG_PAGE_CACHE
   1:         printf("no saved presentation for uri: %s\n", spec.get());
   1: #endif
   1:         return NS_OK;
   1:     }
   1: 
   1:     // We need to make sure the content viewer's container is this docshell.
   1:     // In subframe navigation, it's possible for the docshell that the
   1:     // content viewer was originally loaded into to be replaced with a
   1:     // different one.  We don't currently support restoring the presentation
   1:     // in that case.
   1: 
   1:     nsCOMPtr<nsISupports> container;
   1:     viewer->GetContainer(getter_AddRefs(container));
   1:     if (!::SameCOMIdentity(container, GetAsSupports(this))) {
   1: #ifdef DEBUG_PAGE_CACHE
   1:         printf("No valid container, clearing presentation\n");
   1: #endif
   1:         aSHEntry->SetContentViewer(nsnull);
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     NS_ASSERTION(mContentViewer != viewer, "Restoring existing presentation");
   1: 
   1: #ifdef DEBUG_PAGE_CACHE
   1:     printf("restoring presentation from session history: %s\n", spec.get());
   1: #endif
   1: 
   1:     SetHistoryEntry(&mLSHE, aSHEntry);
   1: 
   1:     // Add the request to our load group.  We do this before swapping out
   1:     // the content viewers so that consumers of STATE_START can access
   1:     // the old document.  We only deal with the toplevel load at this time --
   1:     // to be consistent with normal document loading, subframes cannot start
   1:     // loading until after data arrives, which is after STATE_START completes.
   1: 
   1:     BeginRestore(viewer, PR_TRUE);
   1: 
   1:     // Post an event that will remove the request after we've returned
   1:     // to the event loop.  This mimics the way it is called by nsIChannel
   1:     // implementations.
   1: 
   1:     // Revoke any pending restore (just in case)
   1:     NS_ASSERTION(!mRestorePresentationEvent.IsPending(),
   1:         "should only have one RestorePresentationEvent");
   1:     mRestorePresentationEvent.Revoke();
   1: 
   1:     nsRefPtr<RestorePresentationEvent> evt = new RestorePresentationEvent(this);
   1:     nsresult rv = NS_DispatchToCurrentThread(evt);
   1:     if (NS_SUCCEEDED(rv)) {
   1:         mRestorePresentationEvent = evt.get();
   1:         // The rest of the restore processing will happen on our event
   1:         // callback.
   1:         *aRestoring = PR_TRUE;
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::RestoreFromHistory()
   1: {
   1:     mRestorePresentationEvent.Forget();
   1: 
   1:     // This section of code follows the same ordering as CreateContentViewer.
   1:     if (!mLSHE)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     nsCOMPtr<nsIContentViewer> viewer;
   1:     mLSHE->GetContentViewer(getter_AddRefs(viewer));
   1:     if (!viewer)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     if (mSavingOldViewer) {
   1:         // We determined that it was safe to cache the document presentation
   1:         // at the time we initiated the new load.  We need to check whether
   1:         // it's still safe to do so, since there may have been DOM mutations
   1:         // or new requests initiated.
   1:         nsCOMPtr<nsIDOMDocument> domDoc;
   1:         viewer->GetDOMDocument(getter_AddRefs(domDoc));
   1:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
   1:         nsIRequest *request = nsnull;
   1:         if (doc)
   1:             request = doc->GetChannel();
   1:         mSavingOldViewer = CanSavePresentation(mLoadType, request, doc);
   1:     }
   1: 
   1:     nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV(do_QueryInterface(mContentViewer));
   1:     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV(do_QueryInterface(viewer));
5357:     float textZoom = 1.0f;
5357:     float pageZoom = 1.0f;
5357:     if (oldMUDV && newMUDV) {
5357:         oldMUDV->GetTextZoom(&textZoom);
5357:         oldMUDV->GetFullZoom(&pageZoom);
5357:     }
   1: 
   1:     // Protect against mLSHE going away via a load triggered from
   1:     // pagehide or unload.
   1:     nsCOMPtr<nsISHEntry> origLSHE = mLSHE;
   1: 
   1:     // Notify the old content viewer that it's being hidden.
   1:     FirePageHideNotification(!mSavingOldViewer);
   1: 
   1:     // If mLSHE was changed as a result of the pagehide event, then
   1:     // something else was loaded.  Don't finish restoring.
   1:     if (mLSHE != origLSHE)
   1:       return NS_OK;
   1: 
   1:     // Set mFiredUnloadEvent = PR_FALSE so that the unload handler for the
   1:     // *new* document will fire.
   1:     mFiredUnloadEvent = PR_FALSE;
   1: 
   1:     mURIResultedInDocument = PR_TRUE;
   1:     nsCOMPtr<nsISHistory> rootSH;
   1:     GetRootSessionHistory(getter_AddRefs(rootSH));
   1:     if (rootSH) {
   1:         nsCOMPtr<nsISHistoryInternal> hist = do_QueryInterface(rootSH);
   1:         rootSH->GetIndex(&mPreviousTransIndex);
   1:         hist->UpdateIndex();
   1:         rootSH->GetIndex(&mLoadedTransIndex);
   1: #ifdef DEBUG_PAGE_CACHE
   1:         printf("Previous index: %d, Loaded index: %d\n\n", mPreviousTransIndex,
   1:                    mLoadedTransIndex);
   1: #endif
   1:     }
   1: 
   1:     // Rather than call Embed(), we will retrieve the viewer from the session
   1:     // history entry and swap it in.
   1:     // XXX can we refactor this so that we can just call Embed()?
   1:     PersistLayoutHistoryState();
   1:     nsresult rv;
   1:     if (mContentViewer) {
   1:         if (mSavingOldViewer && NS_FAILED(CaptureState())) {
   1:             if (mOSHE) {
   1:                 mOSHE->SyncPresentationState();
   1:             }
   1:             mSavingOldViewer = PR_FALSE;
   1:         }
   1:     }
   1: 
   1:     mSavedRefreshURIList = nsnull;
   1: 
   1:     // In cases where we use a transient about:blank viewer between loads,
   1:     // we never show the transient viewer, so _its_ previous viewer is never
   1:     // unhooked from the view hierarchy.  Destroy any such previous viewer now,
   1:     // before we grab the root view sibling, so that we don't grab a view
   1:     // that's about to go away.
   1: 
   1:     if (mContentViewer) {
   1:         nsCOMPtr<nsIContentViewer> previousViewer;
   1:         mContentViewer->GetPreviousViewer(getter_AddRefs(previousViewer));
   1:         if (previousViewer) {
   1:             mContentViewer->SetPreviousViewer(nsnull);
   1:             previousViewer->Destroy();
   1:         }
   1:     }
   1: 
   1:     // Save off the root view's parent and sibling so that we can insert the
   1:     // new content viewer's root view at the same position.  Also save the
   1:     // bounds of the root view's widget.
   1: 
   1:     nsIView *rootViewSibling = nsnull, *rootViewParent = nsnull;
   1:     nsRect newBounds(0, 0, 0, 0);
   1: 
   1:     nsCOMPtr<nsIPresShell> oldPresShell;
   1:     nsDocShell::GetPresShell(getter_AddRefs(oldPresShell));
   1:     if (oldPresShell) {
   1:         nsIViewManager *vm = oldPresShell->GetViewManager();
   1:         if (vm) {
   1:             nsIView *oldRootView = nsnull;
   1:             vm->GetRootView(oldRootView);
   1: 
   1:             if (oldRootView) {
   1:                 rootViewSibling = oldRootView->GetNextSibling();
   1:                 rootViewParent = oldRootView->GetParent();
   1: 
   1:                 nsIWidget *widget = oldRootView->GetWidget();
   1:                 if (widget) {
   1:                     widget->GetBounds(newBounds);
   1:                 }
   1:             }
   1:         }
   1:     }
   1: 
   1:     // Transfer ownership to mContentViewer.  By ensuring that either the
   1:     // docshell or the session history, but not both, have references to the
   1:     // content viewer, we prevent the viewer from being torn down after
   1:     // Destroy() is called.
   1: 
   1:     if (mContentViewer) {
   1:         mContentViewer->Close(mSavingOldViewer ? mOSHE.get() : nsnull);
   1:         viewer->SetPreviousViewer(mContentViewer);
   1:     }
   1: 
   1:     mContentViewer.swap(viewer);
   1:     viewer = nsnull; // force a release to complete ownership transfer
   1: 
   1:     // Grab all of the related presentation from the SHEntry now.
   1:     // Clearing the viewer from the SHEntry will clear all of this state.
   1:     nsCOMPtr<nsISupports> windowState;
   1:     mLSHE->GetWindowState(getter_AddRefs(windowState));
   1:     mLSHE->SetWindowState(nsnull);
   1: 
   1:     PRBool sticky;
   1:     mLSHE->GetSticky(&sticky);
   1: 
   1:     nsCOMPtr<nsIDOMDocument> domDoc;
   1:     mContentViewer->GetDOMDocument(getter_AddRefs(domDoc));
   1: 
   1:     nsCOMArray<nsIDocShellTreeItem> childShells;
   1:     PRInt32 i = 0;
   1:     nsCOMPtr<nsIDocShellTreeItem> child;
   1:     while (NS_SUCCEEDED(mLSHE->ChildShellAt(i++, getter_AddRefs(child))) &&
   1:            child) {
   1:         childShells.AppendObject(child);
   1:     }
   1: 
   1:     // get the previous content viewer size
   1:     nsRect oldBounds(0, 0, 0, 0);
   1:     mLSHE->GetViewerBounds(oldBounds);
   1: 
   1:     // Restore the refresh URI list.  The refresh timers will be restarted
   1:     // when EndPageLoad() is called.
   1:     nsCOMPtr<nsISupportsArray> refreshURIList;
   1:     mLSHE->GetRefreshURIList(getter_AddRefs(refreshURIList));
   1: 
   1:     // Reattach to the window object.
   1:     rv = mContentViewer->Open(windowState, mLSHE);
   1: 
   1:     // Now remove it from the cached presentation.
   1:     mLSHE->SetContentViewer(nsnull);
   1:     mEODForCurrentDocument = PR_FALSE;
   1: 
   1: #ifdef DEBUG
   1:  {
   1:      nsCOMPtr<nsISupportsArray> refreshURIs;
   1:      mLSHE->GetRefreshURIList(getter_AddRefs(refreshURIs));
   1:      nsCOMPtr<nsIDocShellTreeItem> childShell;
   1:      mLSHE->ChildShellAt(0, getter_AddRefs(childShell));
   1:      NS_ASSERTION(!refreshURIs && !childShell,
   1:                   "SHEntry should have cleared presentation state");
   1:  }
   1: #endif
   1: 
   1:     // Restore the sticky state of the viewer.  The viewer has set this state
   1:     // on the history entry in Destroy() just before marking itself non-sticky,
   1:     // to avoid teardown of the presentation.
   1:     mContentViewer->SetSticky(sticky);
   1: 
   1:     // Now that we have switched documents, forget all of our children.
   1:     DestroyChildren();
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     // mLSHE is now our currently-loaded document.
   1:     SetHistoryEntry(&mOSHE, mLSHE);
   1:     
   1:     // XXX special wyciwyg handling in Embed()?
   1: 
   1:     // We aren't going to restore any items from the LayoutHistoryState,
   1:     // but we don't want them to stay around in case the page is reloaded.
   1:     SetLayoutHistoryState(nsnull);
   1: 
   1:     // This is the end of our Embed() replacement
   1: 
   1:     mSavingOldViewer = PR_FALSE;
   1:     mEODForCurrentDocument = PR_FALSE;
   1: 
   1:     // Tell the event loop to favor plevents over user events, see comments
   1:     // in CreateContentViewer.
   1:     if (++gNumberOfDocumentsLoading == 1)
   1:         FavorPerformanceHint(PR_TRUE, NS_EVENT_STARVATION_DELAY_HINT);
   1: 
   1: 
5357:     if (oldMUDV && newMUDV) {
5357:         newMUDV->SetTextZoom(textZoom);
5357:         newMUDV->SetFullZoom(pageZoom);
5357:     }
   1: 
   1:     nsCOMPtr<nsIDocument> document = do_QueryInterface(domDoc);
   1:     if (document) {
   1:         // Use the uri from the mLSHE we had when we entered this function
   1:         // (which need not match the document's URI if anchors are involved),
   1:         // since that's the history entry we're loading.  Note that if we use
   1:         // origLSHE we don't have to worry about whether the entry in question
   1:         // is still mLSHE or whether it's now mOSHE.
   1:         nsCOMPtr<nsIURI> uri;
   1:         origLSHE->GetURI(getter_AddRefs(uri));
   1:         SetCurrentURI(uri, document->GetChannel(), PR_TRUE);
   1:     }
   1: 
   1:     // This is the end of our CreateContentViewer() replacement.
   1:     // Now we simulate a load.  First, we restore the state of the javascript
   1:     // window object.
   1:     nsCOMPtr<nsPIDOMWindow> privWin =
3233:         do_GetInterface(static_cast<nsIInterfaceRequestor*>(this));
   1:     NS_ASSERTION(privWin, "could not get nsPIDOMWindow interface");
   1: 
   1:     rv = privWin->RestoreWindowState(windowState);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     // Now, dispatch a title change event which would happed as the
   1:     // <head> is parsed.
   1:     nsCOMPtr<nsIDOMNSDocument> nsDoc = do_QueryInterface(document);
   1:     if (nsDoc) {
   1:         const nsAFlatString &title = document->GetDocumentTitle();
   1:         nsDoc->SetTitle(title);
   1:     }
   1: 
   1:     // Now we simulate appending child docshells for subframes.
   1:     for (i = 0; i < childShells.Count(); ++i) {
   1:         nsIDocShellTreeItem *childItem = childShells.ObjectAt(i);
6685:         nsCOMPtr<nsIDocShell> childShell = do_QueryInterface(childItem);
6685: 
6685:         // Make sure to not clobber the state of the child.  Since AddChild
6685:         // always clobbers it, save it off first.
6685:         PRBool allowPlugins;
6685:         childShell->GetAllowPlugins(&allowPlugins);
6685: 
6685:         PRBool allowJavascript;
6685:         childShell->GetAllowJavascript(&allowJavascript);
6685: 
6685:         PRBool allowRedirects;
6685:         childShell->GetAllowMetaRedirects(&allowRedirects);
6685: 
6685:         PRBool allowSubframes;
6685:         childShell->GetAllowSubframes(&allowSubframes);
6685: 
6685:         PRBool allowImages;
6685:         childShell->GetAllowImages(&allowImages);
6685:         
   1:         AddChild(childItem);
   1: 
6685:         childShell->SetAllowPlugins(allowPlugins);
6685:         childShell->SetAllowJavascript(allowJavascript);
6685:         childShell->SetAllowMetaRedirects(allowRedirects);
6685:         childShell->SetAllowSubframes(allowSubframes);
6685:         childShell->SetAllowImages(allowImages);
6685: 
   1:         rv = childShell->BeginRestore(nsnull, PR_FALSE);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:     }
   1: 
   1:     nsCOMPtr<nsIPresShell> shell;
   1:     nsDocShell::GetPresShell(getter_AddRefs(shell));
   1: 
   1:     nsIViewManager *newVM = shell ? shell->GetViewManager() : nsnull;
   1:     nsIView *newRootView = nsnull;
   1:     if (newVM)
   1:         newVM->GetRootView(newRootView);
   1: 
   1:     // Insert the new root view at the correct location in the view tree.
   1:     if (rootViewParent) {
   1:         nsIViewManager *parentVM = rootViewParent->GetViewManager();
   1: 
   1:         if (parentVM && newRootView) {
   1:             // InsertChild(parent, child, sib, PR_TRUE) inserts the child after
   1:             // sib in content order, which is before sib in view order. BUT
   1:             // when sib is null it inserts at the end of the the document
   1:             // order, i.e., first in view order.  But when oldRootSibling is
   1:             // null, the old root as at the end of the view list --- last in
   1:             // content order --- and we want to call InsertChild(parent, child,
   1:             // nsnull, PR_FALSE) in that case.
   1:             parentVM->InsertChild(rootViewParent, newRootView,
   1:                                   rootViewSibling,
   1:                                   rootViewSibling ? PR_TRUE : PR_FALSE);
   1: 
   1:             NS_ASSERTION(newRootView->GetNextSibling() == rootViewSibling,
   1:                          "error in InsertChild");
   1:         }
   1:     }
   1: 
   1:     // Now that all of the child docshells have been put into place, we can
   1:     // restart the timers for the window and all of the child frames.
   1:     privWin->ResumeTimeouts();
   1: 
   1:     // Restore the refresh URI list.  The refresh timers will be restarted
   1:     // when EndPageLoad() is called.
   1:     mRefreshURIList = refreshURIList;
   1: 
   1:     // Meta-refresh timers have been restarted for this shell, but not
   1:     // for our children.  Walk the child shells and restart their timers.
   1:     PRInt32 n = mChildList.Count();
   1:     for (i = 0; i < n; ++i) {
   1:         nsCOMPtr<nsIDocShell> child = do_QueryInterface(ChildAt(i));
   1:         if (child)
   1:             child->ResumeRefreshURIs();
   1:     }
   1: 
   1:     // Make sure this presentation is the same size as the previous
   1:     // presentation.  If this is not the same size we showed it at last time,
   1:     // then we need to resize the widget.
   1: 
   1:     // XXXbryner   This interacts poorly with Firefox's infobar.  If the old
   1:     // presentation had the infobar visible, then we will resize the new
   1:     // presentation to that smaller size.  However, firing the locationchanged
   1:     // event will hide the infobar, which will immediately resize the window
   1:     // back to the larger size.  A future optimization might be to restore
   1:     // the presentation at the "wrong" size, then fire the locationchanged
   1:     // event and check whether the docshell's new size is the same as the
   1:     // cached viewer size (skipping the resize if they are equal).
   1: 
   1:     if (newRootView) {
   1:         nsIWidget *widget = newRootView->GetWidget();
   1:         if (widget && !newBounds.IsEmpty() && newBounds != oldBounds) {
   1: #ifdef DEBUG_PAGE_CACHE
   1:             printf("resize widget(%d, %d, %d, %d)\n", newBounds.x,
   1:                    newBounds.y, newBounds.width, newBounds.height);
   1: #endif
   1: 
   1:             widget->Resize(newBounds.x, newBounds.y, newBounds.width,
   1:                            newBounds.height, PR_FALSE);
   1:         }
   1:     }
   1: 
   1:     // Simulate the completion of the load.
   1:     nsDocShell::FinishRestore();
   1: 
   1:     // Restart plugins, and paint the content.
   1:     if (shell)
   1:         shell->Thaw();
   1: 
   1:     return privWin->FireDelayedDOMEvents();
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::CreateContentViewer(const char *aContentType,
   1:                                 nsIRequest * request,
   1:                                 nsIStreamListener ** aContentHandler)
   1: {
   1:     *aContentHandler = nsnull;
   1: 
   1:     // Can we check the content type of the current content viewer
   1:     // and reuse it without destroying it and re-creating it?
   1: 
   1:     NS_ASSERTION(mLoadGroup, "Someone ignored return from Init()?");
   1: 
   1:     // Instantiate the content viewer object
   1:     nsCOMPtr<nsIContentViewer> viewer;
   1:     nsresult rv = NewContentViewerObj(aContentType, request, mLoadGroup,
   1:                                       aContentHandler, getter_AddRefs(viewer));
   1: 
   1:     if (NS_FAILED(rv))
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     // Notify the current document that it is about to be unloaded!!
   1:     //
   1:     // It is important to fire the unload() notification *before* any state
   1:     // is changed within the DocShell - otherwise, javascript will get the
   1:     // wrong information :-(
   1:     //
   1: 
   1:     if (mSavingOldViewer) {
   1:         // We determined that it was safe to cache the document presentation
   1:         // at the time we initiated the new load.  We need to check whether
   1:         // it's still safe to do so, since there may have been DOM mutations
   1:         // or new requests initiated.
   1:         nsCOMPtr<nsIDOMDocument> domDoc;
   1:         viewer->GetDOMDocument(getter_AddRefs(domDoc));
   1:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
   1:         mSavingOldViewer = CanSavePresentation(mLoadType, request, doc);
   1:     }
   1: 
   1:     FirePageHideNotification(!mSavingOldViewer);
   1: 
   1:     // Set mFiredUnloadEvent = PR_FALSE so that the unload handler for the
   1:     // *new* document will fire.
   1:     mFiredUnloadEvent = PR_FALSE;
   1: 
   1:     // we've created a new document so go ahead and call
   1:     // OnLoadingSite(), but don't fire OnLocationChange()
   1:     // notifications before we've called Embed(). See bug 284993.
   1:     mURIResultedInDocument = PR_TRUE;
   1: 
   1:     nsCOMPtr<nsIChannel> aOpenedChannel = do_QueryInterface(request);
   1: 
   1:     PRBool onLocationChangeNeeded = OnLoadingSite(aOpenedChannel, PR_FALSE);
   1: 
   1:     // let's try resetting the load group if we need to...
   1:     nsCOMPtr<nsILoadGroup> currentLoadGroup;
   1:     NS_ENSURE_SUCCESS(aOpenedChannel->
   1:                       GetLoadGroup(getter_AddRefs(currentLoadGroup)),
   1:                       NS_ERROR_FAILURE);
   1: 
   1:     if (currentLoadGroup != mLoadGroup) {
   1:         nsLoadFlags loadFlags = 0;
   1: 
   1:         //Cancel any URIs that are currently loading...
   1:         /// XXX: Need to do this eventually      Stop();
   1:         //
   1:         // Retarget the document to this loadgroup...
   1:         //
   1:         /* First attach the channel to the right loadgroup
   1:          * and then remove from the old loadgroup. This 
   1:          * puts the notifications in the right order and
   1:          * we don't null-out mLSHE in OnStateChange() for 
   1:          * all redirected urls
   1:          */
   1:         aOpenedChannel->SetLoadGroup(mLoadGroup);
   1: 
   1:         // Mark the channel as being a document URI...
   1:         aOpenedChannel->GetLoadFlags(&loadFlags);
   1:         loadFlags |= nsIChannel::LOAD_DOCUMENT_URI;
   1: 
   1:         aOpenedChannel->SetLoadFlags(loadFlags);
   1: 
   1:         mLoadGroup->AddRequest(request, nsnull);
   1:         if (currentLoadGroup)
   1:             currentLoadGroup->RemoveRequest(request, nsnull,
   1:                                             NS_BINDING_RETARGETED);
   1: 
   1:         // Update the notification callbacks, so that progress and
   1:         // status information are sent to the right docshell...
   1:         aOpenedChannel->SetNotificationCallbacks(this);
   1:     }
   1: 
   1:     NS_ENSURE_SUCCESS(Embed(viewer, "", (nsISupports *) nsnull),
   1:                       NS_ERROR_FAILURE);
   1: 
   1:     mSavedRefreshURIList = nsnull;
   1:     mSavingOldViewer = PR_FALSE;
   1:     mEODForCurrentDocument = PR_FALSE;
   1: 
   1:     // if this document is part of a multipart document,
   1:     // the ID can be used to distinguish it from the other parts.
   1:     nsCOMPtr<nsIMultiPartChannel> multiPartChannel(do_QueryInterface(request));
   1:     if (multiPartChannel) {
   1:       nsCOMPtr<nsIPresShell> shell;
   1:       rv = GetPresShell(getter_AddRefs(shell));
   1:       if (NS_SUCCEEDED(rv) && shell) {
   1:         nsIDocument *doc = shell->GetDocument();
   1:         if (doc) {
   1:           PRUint32 partID;
   1:           multiPartChannel->GetPartID(&partID);
   1:           doc->SetPartID(partID);
   1:         }
   1:       }
   1:     }
   1: 
   1:     // Give hint to native plevent dispatch mechanism. If a document
   1:     // is loading the native plevent dispatch mechanism should favor
   1:     // performance over normal native event dispatch priorities.
   1:     if (++gNumberOfDocumentsLoading == 1) {
   1:       // Hint to favor performance for the plevent notification mechanism.
   1:       // We want the pages to load as fast as possible even if its means 
   1:       // native messages might be starved.
   1:       FavorPerformanceHint(PR_TRUE, NS_EVENT_STARVATION_DELAY_HINT);
   1:     }
   1: 
   1:     if (onLocationChangeNeeded) {
   1:       FireOnLocationChange(this, request, mCurrentURI);
   1:     }
   1:   
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::NewContentViewerObj(const char *aContentType,
   1:                                 nsIRequest * request, nsILoadGroup * aLoadGroup,
   1:                                 nsIStreamListener ** aContentHandler,
   1:                                 nsIContentViewer ** aViewer)
   1: {
   1:     nsCOMPtr<nsIChannel> aOpenedChannel = do_QueryInterface(request);
   1: 
   1:     nsresult rv;
   1:     nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv));
   1:     if (NS_FAILED(rv))
   1:       return rv;
   1:     
   1:     nsXPIDLCString contractId;
   1:     rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", aContentType, getter_Copies(contractId));
   1: 
   1:     // Create an instance of the document-loader-factory
   1:     nsCOMPtr<nsIDocumentLoaderFactory> docLoaderFactory;
   1:     if (NS_SUCCEEDED(rv))
   1:         docLoaderFactory = do_GetService(contractId.get());
   1: 
   1:     if (!docLoaderFactory) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     // Now create an instance of the content viewer
   1:     // nsLayoutDLF makes the determination if it should be a "view-source" instead of "view"
   1:     NS_ENSURE_SUCCESS(docLoaderFactory->CreateInstance("view",
   1:                                                        aOpenedChannel,
   1:                                                        aLoadGroup, aContentType,
3051:                                                        static_cast<nsIContentViewerContainer*>(this),
3051:                                                        nsnull,
   1:                                                        aContentHandler,
   1:                                                        aViewer),
   1:                       NS_ERROR_FAILURE);
   1: 
3233:     (*aViewer)->SetContainer(static_cast<nsIContentViewerContainer *>(this));
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetupNewViewer(nsIContentViewer * aNewViewer)
   1: {
   1:     //
   1:     // Copy content viewer state from previous or parent content viewer.
   1:     //
   1:     // The following logic is mirrored in nsHTMLDocument::StartDocumentLoad!
   1:     //
   1:     // Do NOT to maintain a reference to the old content viewer outside
   1:     // of this "copying" block, or it will not be destroyed until the end of
   1:     // this routine and all <SCRIPT>s and event handlers fail! (bug 20315)
   1:     //
   1:     // In this block of code, if we get an error result, we return it
   1:     // but if we get a null pointer, that's perfectly legal for parent
   1:     // and parentContentViewer.
   1:     //
   1: 
   1:     PRInt32 x = 0;
   1:     PRInt32 y = 0;
   1:     PRInt32 cx = 0;
   1:     PRInt32 cy = 0;
   1: 
   1:     // This will get the size from the current content viewer or from the
   1:     // Init settings
1027:     DoGetPositionAndSize(&x, &y, &cx, &cy);
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
   1:     NS_ENSURE_SUCCESS(GetSameTypeParent(getter_AddRefs(parentAsItem)),
   1:                       NS_ERROR_FAILURE);
   1:     nsCOMPtr<nsIDocShell> parent(do_QueryInterface(parentAsItem));
   1: 
   1:     nsCAutoString defaultCharset;
   1:     nsCAutoString forceCharset;
   1:     nsCAutoString hintCharset;
   1:     PRInt32 hintCharsetSource;
   1:     nsCAutoString prevDocCharset;
   1:     float textZoom;
5357:     float pageZoom;
   1:     PRBool styleDisabled;
   1:     // |newMUDV| also serves as a flag to set the data from the above vars
   1:     nsCOMPtr<nsIMarkupDocumentViewer> newMUDV;
   1: 
   1:     if (mContentViewer || parent) {
   1:         nsCOMPtr<nsIMarkupDocumentViewer> oldMUDV;
   1:         if (mContentViewer) {
   1:             // Get any interesting state from old content viewer
   1:             // XXX: it would be far better to just reuse the document viewer ,
   1:             //      since we know we're just displaying the same document as before
   1:             oldMUDV = do_QueryInterface(mContentViewer);
   1: 
   1:             // Tell the old content viewer to hibernate in session history when
   1:             // it is destroyed.
   1: 
   1:             if (mSavingOldViewer && NS_FAILED(CaptureState())) {
   1:                 if (mOSHE) {
   1:                     mOSHE->SyncPresentationState();
   1:                 }
   1:                 mSavingOldViewer = PR_FALSE;
   1:             }
   1:         }
   1:         else {
   1:             // No old content viewer, so get state from parent's content viewer
   1:             nsCOMPtr<nsIContentViewer> parentContentViewer;
   1:             parent->GetContentViewer(getter_AddRefs(parentContentViewer));
   1:             oldMUDV = do_QueryInterface(parentContentViewer);
   1:         }
   1: 
   1:         if (oldMUDV) {
   1:             nsresult rv;
   1: 
   1:             newMUDV = do_QueryInterface(aNewViewer,&rv);
   1:             if (newMUDV) {
   1:                 NS_ENSURE_SUCCESS(oldMUDV->
   1:                                   GetDefaultCharacterSet(defaultCharset),
   1:                                   NS_ERROR_FAILURE);
   1:                 NS_ENSURE_SUCCESS(oldMUDV->
   1:                                   GetForceCharacterSet(forceCharset),
   1:                                   NS_ERROR_FAILURE);
   1:                 NS_ENSURE_SUCCESS(oldMUDV->
   1:                                   GetHintCharacterSet(hintCharset),
   1:                                   NS_ERROR_FAILURE);
   1:                 NS_ENSURE_SUCCESS(oldMUDV->
   1:                                   GetHintCharacterSetSource(&hintCharsetSource),
   1:                                   NS_ERROR_FAILURE);
   1:                 NS_ENSURE_SUCCESS(oldMUDV->
   1:                                   GetTextZoom(&textZoom),
   1:                                   NS_ERROR_FAILURE);
   1:                 NS_ENSURE_SUCCESS(oldMUDV->
5357:                                   GetFullZoom(&pageZoom),
5357:                                   NS_ERROR_FAILURE);
5357:                 NS_ENSURE_SUCCESS(oldMUDV->
   1:                                   GetAuthorStyleDisabled(&styleDisabled),
   1:                                   NS_ERROR_FAILURE);
   1:                 NS_ENSURE_SUCCESS(oldMUDV->
   1:                                   GetPrevDocCharacterSet(prevDocCharset),
   1:                                   NS_ERROR_FAILURE);
   1:             }
   1:         }
   1:     }
   1: 
   1:     // It is necessary to obtain the focus controller to utilize its ability
   1:     // to suppress focus.  This is necessary to fix Win32-only bugs related to
   1:     // a loss of focus when mContentViewer is set to null.  The internal window
   1:     // is destroyed, and the OS focuses the parent window.  This call ends up
   1:     // notifying the focus controller that the outer window should focus
   1:     // and this hoses us on any link traversal.
   1:     //
   1:     // Please do not touch any of the focus controller code here without
   1:     // testing bugs #28580 and 50509.  These are immensely important bugs,
   1:     // so PLEASE take care not to regress them if you decide to alter this 
   1:     // code later              -- hyatt
   1:     nsIFocusController *focusController = nsnull;
   1:     if (mScriptGlobal) {
   1:         nsCOMPtr<nsPIDOMWindow> ourWindow = do_QueryInterface(mScriptGlobal);
   1:         focusController = ourWindow->GetRootFocusController();
   1:         if (focusController) {
   1:             // Suppress the command dispatcher.
   1:             focusController->SetSuppressFocus(PR_TRUE,
   1:                                               "Win32-Only Link Traversal Issue");
   1:             // Remove focus from the element that has it
   1:             nsCOMPtr<nsIDOMWindowInternal> focusedWindow;
   1:             focusController->GetFocusedWindow(getter_AddRefs(focusedWindow));
   1: 
   1:             // We want to null out the last focused element if the document containing
   1:             // it is going away.  If the last focused element is in a descendent
   1:             // window of our domwindow, its document will be destroyed when we
   1:             // destroy our children.  So, check for this case and null out the
   1:             // last focused element.  See bug 70484.
   1: 
   1:             PRBool isSubWindow = PR_FALSE;
   1:             nsCOMPtr<nsIDOMWindow> curwin;
   1:             if (focusedWindow)
   1:               focusedWindow->GetParent(getter_AddRefs(curwin));
   1:             while (curwin) {
   1:               if (curwin == ourWindow) {
   1:                 isSubWindow = PR_TRUE;
   1:                 break;
   1:               }
   1: 
   1:               // don't use nsCOMPtr here to avoid extra addref
   1:               // when assigning to curwin
   1:               nsIDOMWindow* temp;
   1:               curwin->GetParent(&temp);
   1:               if (curwin == temp) {
   1:                 NS_RELEASE(temp);
   1:                 break;
   1:               }
   1:               curwin = dont_AddRef(temp);
   1:             }
   1: 
   1:             if (ourWindow == focusedWindow || isSubWindow)
   1:               focusController->ResetElementFocus();
   1:         }
   1:     }
   1: 
   1:     nscolor bgcolor = NS_RGBA(0, 0, 0, 0);
   1:     PRBool bgSet = PR_FALSE;
   1: 
   1:     // Ensure that the content viewer is destroyed *after* the GC - bug 71515
   1:     nsCOMPtr<nsIContentViewer> kungfuDeathGrip = mContentViewer;
   1:     if (mContentViewer) {
   1:         // Stop any activity that may be happening in the old document before
   1:         // releasing it...
   1:         mContentViewer->Stop();
   1: 
   1:         // Try to extract the default background color from the old
   1:         // view manager, so we can use it for the next document.
   1:         nsCOMPtr<nsIDocumentViewer> docviewer =
   1:         do_QueryInterface(mContentViewer);
   1: 
   1:         if (docviewer) {
   1:             nsCOMPtr<nsIPresShell> shell;
   1:             docviewer->GetPresShell(getter_AddRefs(shell));
   1: 
   1:             if (shell) {
   1:                 nsIViewManager* vm = shell->GetViewManager();
   1: 
   1:                 if (vm) {
   1:                     vm->GetDefaultBackgroundColor(&bgcolor);
   1:                     // If the background color is not known, don't propagate it.
   1:                     bgSet = NS_GET_A(bgcolor) != 0;
   1:                 }
   1:             }
   1:         }
   1: 
   1:         mContentViewer->Close(mSavingOldViewer ? mOSHE.get() : nsnull);
   1:         aNewViewer->SetPreviousViewer(mContentViewer);
   1: 
   1:         mContentViewer = nsnull;
   1:     }
   1: 
   1:     mContentViewer = aNewViewer;
   1: 
   1:     nsCOMPtr<nsIWidget> widget;
   1:     NS_ENSURE_SUCCESS(GetMainWidget(getter_AddRefs(widget)), NS_ERROR_FAILURE);
   1: 
   1:     if (widget) {
   1:         NS_ENSURE_SUCCESS(EnsureDeviceContext(), NS_ERROR_FAILURE);
   1:     }
   1: 
   1:     nsRect bounds(x, y, cx, cy);
   1: 
   1:     if (NS_FAILED(mContentViewer->Init(widget, mDeviceContext, bounds))) {
   1:         mContentViewer = nsnull;
   1:         NS_ERROR("ContentViewer Initialization failed");
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     // If we have old state to copy, set the old state onto the new content
   1:     // viewer
   1:     if (newMUDV) {
   1:         NS_ENSURE_SUCCESS(newMUDV->SetDefaultCharacterSet(defaultCharset),
   1:                           NS_ERROR_FAILURE);
   1:         NS_ENSURE_SUCCESS(newMUDV->SetForceCharacterSet(forceCharset),
   1:                           NS_ERROR_FAILURE);
   1:         NS_ENSURE_SUCCESS(newMUDV->SetHintCharacterSet(hintCharset),
   1:                           NS_ERROR_FAILURE);
   1:         NS_ENSURE_SUCCESS(newMUDV->
   1:                           SetHintCharacterSetSource(hintCharsetSource),
   1:                           NS_ERROR_FAILURE);
   1:         NS_ENSURE_SUCCESS(newMUDV->SetPrevDocCharacterSet(prevDocCharset),
   1:                           NS_ERROR_FAILURE);
   1:         NS_ENSURE_SUCCESS(newMUDV->SetTextZoom(textZoom),
   1:                           NS_ERROR_FAILURE);
5357:         NS_ENSURE_SUCCESS(newMUDV->SetFullZoom(pageZoom),
5357:                           NS_ERROR_FAILURE);
   1:         NS_ENSURE_SUCCESS(newMUDV->SetAuthorStyleDisabled(styleDisabled),
   1:                           NS_ERROR_FAILURE);
   1:     }
   1: 
   1:     // End copying block (Don't mess with the old content/document viewer
   1:     // beyond here!!)
   1: 
   1:     // See the book I wrote above regarding why the focus controller is 
   1:     // being used here.  -- hyatt
   1: 
   1:     /* Note it's important that focus suppression be turned off no earlier
   1:        because in cases where the docshell is lazily creating an about:blank
   1:        document, mContentViewer->Init finally puts a reference to that
   1:        document into the DOM window, which prevents an infinite recursion
   1:        attempting to lazily create the document as focus is unsuppressed
   1:        (bug 110856). */
   1:     if (focusController)
   1:         focusController->SetSuppressFocus(PR_FALSE,
   1:                                           "Win32-Only Link Traversal Issue");
   1: 
   1:     if (bgSet && widget) {
   1:         // Stuff the bgcolor from the last view manager into the new
   1:         // view manager. This improves page load continuity.
   1:         nsCOMPtr<nsIDocumentViewer> docviewer =
   1:             do_QueryInterface(mContentViewer);
   1: 
   1:         if (docviewer) {
   1:             nsCOMPtr<nsIPresShell> shell;
   1:             docviewer->GetPresShell(getter_AddRefs(shell));
   1: 
   1:             if (shell) {
   1:                 nsIViewManager* vm = shell->GetViewManager();
   1: 
   1:                 if (vm) {
   1:                     vm->SetDefaultBackgroundColor(bgcolor);
   1:                 }
   1:             }
   1:         }
   1:     }
   1: 
   1: // XXX: It looks like the LayoutState gets restored again in Embed()
   1: //      right after the call to SetupNewViewer(...)
   1: 
   1:     // We don't show the mContentViewer yet, since we want to draw the old page
   1:     // until we have enough of the new page to show.  Just return with the new
   1:     // viewer still set to hidden.
   1: 
   1:     // Now that we have switched documents, forget all of our children
   1:     DestroyChildren();
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: nsresult
   1: nsDocShell::CheckLoadingPermissions()
   1: {
   1:     // This method checks whether the caller may load content into
   1:     // this docshell. Even though we've done our best to hide windows
   1:     // from code that doesn't have the right to access them, it's
   1:     // still possible for an evil site to open a window and access
   1:     // frames in the new window through window.frames[] (which is
   1:     // allAccess for historic reasons), so we still need to do this
   1:     // check on load.
   1:     nsresult rv = NS_OK, sameOrigin = NS_OK;
   1: 
   1:     if (!gValidateOrigin || !IsFrame()) {
   1:         // Origin validation was turned off, or we're not a frame.
   1:         // Permit all loads.
   1: 
   1:         return rv;
   1:     }
   1: 
   1:     // We're a frame. Check that the caller has write permission to
   1:     // the parent before allowing it to load anything into this
   1:     // docshell.
   1: 
   1:     nsCOMPtr<nsIScriptSecurityManager> securityManager =
   1:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     PRBool ubwEnabled = PR_FALSE;
   1:     rv = securityManager->IsCapabilityEnabled("UniversalBrowserWrite",
   1:                                               &ubwEnabled);
   1:     if (NS_FAILED(rv) || ubwEnabled) {
   1:         return rv;
   1:     }
   1: 
   1:     nsCOMPtr<nsIPrincipal> subjPrincipal;
   1:     rv = securityManager->GetSubjectPrincipal(getter_AddRefs(subjPrincipal));
   1:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && subjPrincipal, rv);
   1: 
   1:     // Check if the caller is from the same origin as this docshell,
   1:     // or any of it's ancestors.
   1:     nsCOMPtr<nsIDocShellTreeItem> item(this);
   1:     do {
   1:         nsCOMPtr<nsIScriptGlobalObject> sgo(do_GetInterface(item));
   1:         nsCOMPtr<nsIScriptObjectPrincipal> sop(do_QueryInterface(sgo));
   1: 
   1:         nsIPrincipal *p;
   1:         if (!sop || !(p = sop->GetPrincipal())) {
   1:             return NS_ERROR_UNEXPECTED;
   1:         }
   1: 
   1:         // Compare origins
3286:         PRBool equal;
3286:         sameOrigin = subjPrincipal->Equals(p, &equal);
   1:         if (NS_SUCCEEDED(sameOrigin)) {
3286:             if (equal) {
   1:                 // Same origin, permit load
   1: 
   1:                 return sameOrigin;
   1:             }
   1: 
3286:             sameOrigin = NS_ERROR_DOM_PROP_ACCESS_DENIED;
3286:         }
3286: 
   1:         nsCOMPtr<nsIDocShellTreeItem> tmp;
   1:         item->GetSameTypeParent(getter_AddRefs(tmp));
   1:         item.swap(tmp);
   1:     } while (item);
   1: 
   1:     // The caller is not from the same origin as this item, or any if
   1:     // this items ancestors. Only permit loading content if both are
   1:     // part of the same window, assuming we can find the window of the
   1:     // caller.
   1: 
   1:     nsCOMPtr<nsIJSContextStack> stack =
   1:         do_GetService("@mozilla.org/js/xpc/ContextStack;1");
   1:     if (!stack) {
   1:         // No context stack available. Should never happen, but in
   1:         // case it does, return the sameOrigin error from the security
   1:         // check above.
   1: 
   1:         return sameOrigin;
   1:     }
   1: 
   1:     JSContext *cx = nsnull;
   1:     stack->Peek(&cx);
   1: 
   1:     if (!cx) {
   1:         // No caller docshell reachable, return the sameOrigin error
   1:         // from the security check above.
   1: 
   1:         return sameOrigin;
   1:     }
   1: 
   1:     nsIScriptContext *currentCX = GetScriptContextFromJSContext(cx);
   1:     nsCOMPtr<nsIDocShellTreeItem> callerTreeItem;
   1:     nsCOMPtr<nsPIDOMWindow> win;
   1:     if (currentCX &&
   1:         (win = do_QueryInterface(currentCX->GetGlobalObject())) &&
   1:         (callerTreeItem = do_QueryInterface(win->GetDocShell()))) {
   1:         nsCOMPtr<nsIDocShellTreeItem> callerRoot;
   1:         callerTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(callerRoot));
   1: 
   1:         nsCOMPtr<nsIDocShellTreeItem> ourRoot;
   1:         GetSameTypeRootTreeItem(getter_AddRefs(ourRoot));
   1: 
   1:         if (ourRoot == callerRoot) {
   1:             // The running JS is in the same window as the target
   1:             // frame, permit load.
   1:             sameOrigin = NS_OK;
   1:         }
   1:     }
   1: 
   1:     return sameOrigin;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell: Site Loading
   1: //*****************************************************************************   
   1: NS_IMETHODIMP
   1: nsDocShell::InternalLoad(nsIURI * aURI,
   1:                          nsIURI * aReferrer,
   1:                          nsISupports * aOwner,
   1:                          PRUint32 aFlags,
   1:                          const PRUnichar *aWindowTarget,
   1:                          const char* aTypeHint,
   1:                          nsIInputStream * aPostData,
   1:                          nsIInputStream * aHeadersData,
   1:                          PRUint32 aLoadType,
   1:                          nsISHEntry * aSHEntry,
   1:                          PRBool aFirstParty,
   1:                          nsIDocShell** aDocShell,
   1:                          nsIRequest** aRequest)
   1: {
3339:     if (mFiredUnloadEvent) {
3339:       return NS_OK; // JS may not handle returning of an error code
3339:     }
3339: 
   1:     nsresult rv = NS_OK;
   1: 
   1: #ifdef PR_LOGGING
   1:     if (gDocShellLeakLog && PR_LOG_TEST(gDocShellLeakLog, PR_LOG_DEBUG)) {
   1:         nsCAutoString spec;
   1:         if (aURI)
   1:             aURI->GetSpec(spec);
   1:         PR_LogPrint("DOCSHELL %p InternalLoad %s\n", this, spec.get());
   1:     }
   1: #endif
   1:     
   1:     // Initialize aDocShell/aRequest
   1:     if (aDocShell) {
   1:         *aDocShell = nsnull;
   1:     }
   1:     if (aRequest) {
   1:         *aRequest = nsnull;
   1:     }
   1: 
   1:     if (!aURI) {
   1:         return NS_ERROR_NULL_POINTER;
   1:     }
   1: 
   1:     NS_ENSURE_TRUE(IsValidLoadType(aLoadType), NS_ERROR_INVALID_ARG);
   1: 
   1:     NS_ENSURE_TRUE(!mIsBeingDestroyed, NS_ERROR_NOT_AVAILABLE);
   1: 
   1:     // wyciwyg urls can only be loaded through history. Any normal load of
   1:     // wyciwyg through docshell is  illegal. Disallow such loads.
   1:     if (aLoadType & LOAD_CMD_NORMAL) {
   1:         PRBool isWyciwyg = PR_FALSE;
   1:         rv = aURI->SchemeIs("wyciwyg", &isWyciwyg);   
   1:         if ((isWyciwyg && NS_SUCCEEDED(rv)) || NS_FAILED(rv)) 
   1:             return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     PRBool bIsJavascript = PR_FALSE;
   1:     if (NS_FAILED(aURI->SchemeIs("javascript", &bIsJavascript))) {
   1:         bIsJavascript = PR_FALSE;
   1:     }
   1: 
   1:     //
   1:     // First, notify any nsIContentPolicy listeners about the document load.
   1:     // Only abort the load if a content policy listener explicitly vetos it!
   1:     //
   1:     nsCOMPtr<nsIDOMElement> requestingElement;
   1:     // Use nsPIDOMWindow since we _want_ to cross the chrome boundary if needed
   1:     nsCOMPtr<nsPIDOMWindow> privateWin(do_QueryInterface(mScriptGlobal));
   1:     if (privateWin)
   1:         requestingElement = privateWin->GetFrameElementInternal();
   1: 
   1:     PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
   1:     PRUint32 contentType;
   1:     if (IsFrame()) {
   1:         NS_ASSERTION(requestingElement, "A frame but no DOM element!?");
   1:         contentType = nsIContentPolicy::TYPE_SUBDOCUMENT;
   1:     } else {
   1:         contentType = nsIContentPolicy::TYPE_DOCUMENT;
   1:     }
   1: 
   1:     nsISupports* context = requestingElement;
   1:     if (!context) {
   1:         context =  mScriptGlobal;
   1:     }
4444: 
4367:     // XXXbz would be nice to know the loading principal here... but we don't
4444:     nsCOMPtr<nsIPrincipal> loadingPrincipal;
4444:     if (aReferrer) {
4444:         nsCOMPtr<nsIScriptSecurityManager> secMan =
4444:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID, &rv);
4444:         NS_ENSURE_SUCCESS(rv, rv);
4444: 
4444:         rv = secMan->GetCodebasePrincipal(aReferrer,
4444:                                           getter_AddRefs(loadingPrincipal));
4444:     }
4444:     
   1:     rv = NS_CheckContentLoadPolicy(contentType,
   1:                                    aURI,
4444:                                    loadingPrincipal,
   1:                                    context,
   1:                                    EmptyCString(), //mime guess
   1:                                    nsnull,         //extra
   1:                                    &shouldLoad);
   1: 
   1:     if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
   1:         if (NS_SUCCEEDED(rv) && shouldLoad == nsIContentPolicy::REJECT_TYPE) {
   1:             return NS_ERROR_CONTENT_BLOCKED_SHOW_ALT;
   1:         }
   1: 
   1:         return NS_ERROR_CONTENT_BLOCKED;
   1:     }
   1: 
   1:     nsCOMPtr<nsISupports> owner(aOwner);
   1:     //
   1:     // Get an owner from the current document if necessary.  Note that we only
   1:     // do this for URIs that inherit a security context; in particular we do
   1:     // NOT do this for about:blank.  This way, random about:blank loads that
   1:     // have no owner (which basically means they were done by someone from
   1:     // chrome manually messing with our nsIWebNavigation or by C++ setting
   1:     // document.location) don't get a funky principal.  If callers want
   1:     // something interesting to happen with the about:blank principal in this
   1:     // case, they should pass an owner in.
   1:     //
   1:     {
   1:         PRBool inherits;
 853:         // One more twist: Don't inherit the owner for external loads.
 853:         if (aLoadType != LOAD_NORMAL_EXTERNAL && !owner &&
 853:             (aFlags & INTERNAL_LOAD_FLAGS_INHERIT_OWNER) &&
   1:             NS_SUCCEEDED(URIInheritsSecurityContext(aURI, &inherits)) &&
   1:             inherits) {
8363: 
8363:             // Don't allow loads that would inherit our security context
8363:             // if this document came from an unsafe channel.
8363:             nsCOMPtr<nsIDocShellTreeItem> treeItem = this;
8363:             do {
8363:                 nsCOMPtr<nsIDocShell> itemDocShell =
8363:                     do_QueryInterface(treeItem);
8363:                 PRBool isUnsafe;
8363:                 if (itemDocShell &&
8363:                     NS_SUCCEEDED(itemDocShell->GetChannelIsUnsafe(&isUnsafe)) &&
8363:                     isUnsafe) {
8363:                     return NS_ERROR_DOM_SECURITY_ERR;
8363:                 }
8363: 
8363:                 nsCOMPtr<nsIDocShellTreeItem> parent;
8363:                 treeItem->GetSameTypeParent(getter_AddRefs(parent));
8363:                 parent.swap(treeItem);
8363:             } while (treeItem);
8363: 
   1:             owner = GetInheritedPrincipal(PR_TRUE);
   1:         }
   1:     }
   1: 
   1:     //
   1:     // Resolve the window target before going any further...
   1:     // If the load has been targeted to another DocShell, then transfer the
   1:     // load to it...
   1:     //
   1:     if (aWindowTarget && *aWindowTarget) {
   1:         // We've already done our owner-inheriting.  Mask out that bit, so we
   1:         // don't try inheriting an owner from the target window if we came up
   1:         // with a null owner above.
   1:         aFlags = aFlags & ~INTERNAL_LOAD_FLAGS_INHERIT_OWNER;
   1:         
   1:         // Locate the target DocShell.
   1:         // This may involve creating a new toplevel window - if necessary.
   1:         //
   1:         nsCOMPtr<nsIDocShellTreeItem> targetItem;
   1:         FindItemWithName(aWindowTarget, nsnull, this,
   1:                          getter_AddRefs(targetItem));
   1: 
   1:         nsCOMPtr<nsIDocShell> targetDocShell = do_QueryInterface(targetItem);
   1:         
   1:         PRBool isNewWindow = PR_FALSE;
   1:         if (!targetDocShell) {
   1:             nsCOMPtr<nsIDOMWindowInternal> win =
   1:                 do_GetInterface(GetAsSupports(this));
   1:             NS_ENSURE_TRUE(win, NS_ERROR_NOT_AVAILABLE);
   1: 
   1:             nsDependentString name(aWindowTarget);
   1:             nsCOMPtr<nsIDOMWindow> newWin;
   1:             rv = win->Open(EmptyString(), // URL to load
   1:                            name,          // window name
   1:                            EmptyString(), // Features
   1:                            getter_AddRefs(newWin));
   1: 
   1:             // In some cases the Open call doesn't actually result in a new
   1:             // window being opened.  We can detect these cases by examining the
   1:             // document in |newWin|, if any.
   1:             nsCOMPtr<nsPIDOMWindow> piNewWin = do_QueryInterface(newWin);
   1:             if (piNewWin) {
   1:                 nsCOMPtr<nsIDocument> newDoc =
   1:                     do_QueryInterface(piNewWin->GetExtantDocument());
   1:                 if (!newDoc || newDoc->IsInitialDocument()) {
   1:                     isNewWindow = PR_TRUE;
   1:                     aFlags |= INTERNAL_LOAD_FLAGS_FIRST_LOAD;
   1:                 }
   1:             }
   1: 
   1:             nsCOMPtr<nsIWebNavigation> webNav = do_GetInterface(newWin);
   1:             targetDocShell = do_QueryInterface(webNav);
   1: 
   1:             nsCOMPtr<nsIScriptObjectPrincipal> sop =
   1:                 do_QueryInterface(mScriptGlobal);
   1:             nsCOMPtr<nsIURI> currentCodebase;
   1: 
   1:             if (sop) {
   1:                 nsIPrincipal *principal = sop->GetPrincipal();
   1: 
   1:                 if (principal) {
   1:                     principal->GetURI(getter_AddRefs(currentCodebase));
   1:                 }
   1:             }
   1: 
   1:             // We opened a new window for the target, clone the
   1:             // session storage if the current URI's domain matches
   1:             // that of the loading URI.
   1:             if (targetDocShell && currentCodebase && aURI) {
   1:                 nsCAutoString thisDomain, newDomain;
   1:                 nsresult gethostrv = currentCodebase->GetAsciiHost(thisDomain);
   1:                 gethostrv |= aURI->GetAsciiHost(newDomain);
   1:                 if (NS_SUCCEEDED(gethostrv) && thisDomain.Equals(newDomain)) {
   1:                     nsCOMPtr<nsIDOMStorage> storage;
   1:                     GetSessionStorageForURI(currentCodebase,
   1:                                             getter_AddRefs(storage));
   1:                     nsCOMPtr<nsPIDOMStorage> piStorage =
   1:                         do_QueryInterface(storage);
   1:                     if (piStorage) {
   1:                         nsCOMPtr<nsIDOMStorage> newstorage =
   1:                             piStorage->Clone(currentCodebase);
   1:                         targetDocShell->AddSessionStorage(thisDomain,
   1:                                                           newstorage);
   1:                     }
   1:                 }
   1:             }
   1:         }
   1:         
   1:         //
   1:         // Transfer the load to the target DocShell...  Pass nsnull as the
   1:         // window target name from to prevent recursive retargeting!
   1:         //
   1:         if (NS_SUCCEEDED(rv) && targetDocShell) {
   1:             rv = targetDocShell->InternalLoad(aURI,
   1:                                               aReferrer,
   1:                                               owner,
   1:                                               aFlags,
   1:                                               nsnull,         // No window target
   1:                                               aTypeHint,
   1:                                               aPostData,
   1:                                               aHeadersData,
   1:                                               aLoadType,
   1:                                               aSHEntry,
   1:                                               aFirstParty,
   1:                                               aDocShell,
   1:                                               aRequest);
   1:             if (rv == NS_ERROR_NO_CONTENT) {
   1:                 // XXXbz except we never reach this code!
   1:                 if (isNewWindow) {
   1:                     //
   1:                     // At this point, a new window has been created, but the
   1:                     // URI did not have any data associated with it...
   1:                     //
   1:                     // So, the best we can do, is to tear down the new window
   1:                     // that was just created!
   1:                     //
   1:                     nsCOMPtr<nsIDOMWindowInternal> domWin =
   1:                         do_GetInterface(targetDocShell);
   1:                     if (domWin) {
   1:                         domWin->Close();
   1:                     }
   1:                 }
   1:                 //
   1:                 // NS_ERROR_NO_CONTENT should not be returned to the
   1:                 // caller... This is an internal error code indicating that
   1:                 // the URI had no data associated with it - probably a 
   1:                 // helper-app style protocol (ie. mailto://)
   1:                 //
   1:                 rv = NS_OK;
   1:             }
   1:             else if (isNewWindow) {
   1:                 // XXX: Once new windows are created hidden, the new
   1:                 //      window will need to be made visible...  For now,
   1:                 //      do nothing.
   1:             }
   1:         }
   1: 
   1:         // Else we ran out of memory, or were a popup and got blocked,
   1:         // or something.
   1:         
   1:         return rv;
   1:     }
   1: 
   1:     //
   1:     // Load is being targetted at this docshell so return an error if the
   1:     // docshell is in the process of being destroyed.
   1:     //
   1:     if (mIsBeingDestroyed) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     // Before going any further vet loads initiated by external programs.
   1:     if (aLoadType == LOAD_NORMAL_EXTERNAL) {
   1:         // Disallow external chrome: loads targetted at content windows
   1:         PRBool isChrome = PR_FALSE;
   1:         if (NS_SUCCEEDED(aURI->SchemeIs("chrome", &isChrome)) && isChrome) {
   1:             NS_WARNING("blocked external chrome: url -- use '-chrome' option");
   1:             return NS_ERROR_FAILURE;
   1:         }
   1: 
   1:         // clear the decks to prevent context bleed-through (bug 298255)
   1:         rv = CreateAboutBlankContentViewer(nsnull);
   1:         if (NS_FAILED(rv))
   1:             return NS_ERROR_FAILURE;
   1: 
   1:         // reset loadType so we don't have to add lots of tests for
   1:         // LOAD_NORMAL_EXTERNAL after this point
   1:         aLoadType = LOAD_NORMAL;
   1:     }
   1: 
   1:     rv = CheckLoadingPermissions();
   1:     if (NS_FAILED(rv)) {
   1:         return rv;
   1:     }
   1: 
   1:     mAllowKeywordFixup =
   1:       (aFlags & INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP) != 0;
   1:     mURIResultedInDocument = PR_FALSE;  // reset the clock...
   1:    
   1:     //
   1:     // First:
   1:     // Check to see if the new URI is an anchor in the existing document.
   1:     // Skip this check if we're doing some sort of abnormal load, if the
   1:     // new load is a non-history load and has postdata, or if we're doing
   1:     // a history load and the page identifiers of mOSHE and aSHEntry
   1:     // don't match.
   1:     //
   1:     PRBool allowScroll = PR_TRUE;
   1:     if (!aSHEntry) {
   1:         allowScroll = (aPostData == nsnull);
   1:     } else if (mOSHE) {
   1:         PRUint32 ourPageIdent;
   1:         mOSHE->GetPageIdentifier(&ourPageIdent);
   1:         PRUint32 otherPageIdent;
   1:         aSHEntry->GetPageIdentifier(&otherPageIdent);
   1:         allowScroll = (ourPageIdent == otherPageIdent);
   1: #ifdef DEBUG
   1:         if (allowScroll) {
   1:             nsCOMPtr<nsIInputStream> currentPostData;
   1:             mOSHE->GetPostData(getter_AddRefs(currentPostData));
   1:             NS_ASSERTION(currentPostData == aPostData,
   1:                          "Different POST data for entries for the same page?");
   1:         }
   1: #endif
   1:     }
   1:     
   1:     if ((aLoadType == LOAD_NORMAL ||
   1:          aLoadType == LOAD_STOP_CONTENT ||
   1:          LOAD_TYPE_HAS_FLAGS(aLoadType, LOAD_FLAGS_REPLACE_HISTORY) ||
   1:          aLoadType == LOAD_HISTORY ||
   1:          aLoadType == LOAD_LINK) && allowScroll) {
   1:         PRBool wasAnchor = PR_FALSE;
   1:         nscoord cx, cy;
   1:         NS_ENSURE_SUCCESS(ScrollIfAnchor(aURI, &wasAnchor, aLoadType, &cx, &cy), NS_ERROR_FAILURE);
   1:         if (wasAnchor) {
   1:             mLoadType = aLoadType;
   1:             mURIResultedInDocument = PR_TRUE;
   1: 
   1:             /* we need to assign mLSHE to aSHEntry right here, so that on History loads, 
   1:              * SetCurrentURI() called from OnNewURI() will send proper 
   1:              * onLocationChange() notifications to the browser to update
   1:              * back/forward buttons. 
   1:              */
   1:             SetHistoryEntry(&mLSHE, aSHEntry);
   1: 
   1:             /* This is a anchor traversal with in the same page.
   1:              * call OnNewURI() so that, this traversal will be 
   1:              * recorded in session and global history.
   1:              */
   1:             OnNewURI(aURI, nsnull, mLoadType, PR_TRUE);
   1:             nsCOMPtr<nsIInputStream> postData;
   1:             PRUint32 pageIdent = PR_UINT32_MAX;
   1:             
   1:             if (mOSHE) {
   1:                 /* save current position of scroller(s) (bug 59774) */
   1:                 mOSHE->SetScrollPosition(cx, cy);
   1:                 // Get the postdata and page ident from the current page, if
   1:                 // the new load is being done via normal means.  Note that
   1:                 // "normal means" can be checked for just by checking for
   1:                 // LOAD_CMD_NORMAL, given the loadType and allowScroll check
   1:                 // above -- it filters out some LOAD_CMD_NORMAL cases that we
   1:                 // wouldn't want here.
   1:                 if (aLoadType & LOAD_CMD_NORMAL) {
   1:                     mOSHE->GetPostData(getter_AddRefs(postData));
   1:                     mOSHE->GetPageIdentifier(&pageIdent);
   1:                 }
   1:             }
   1:             
   1:             /* Assign mOSHE to mLSHE. This will either be a new entry created
   1:              * by OnNewURI() for normal loads or aSHEntry for history loads.
   1:              */
   1:             if (mLSHE) {
   1:                 SetHistoryEntry(&mOSHE, mLSHE);
   1:                 // Save the postData obtained from the previous page
   1:                 // in to the session history entry created for the 
   1:                 // anchor page, so that any history load of the anchor
   1:                 // page will restore the appropriate postData.
   1:                 if (postData)
   1:                     mOSHE->SetPostData(postData);
   1:                 
   1:                 // Propagate our page ident to the new mOSHE so that
   1:                 // we'll know it just differed by a scroll on the page.
   1:                 if (pageIdent != PR_UINT32_MAX)
   1:                     mOSHE->SetPageIdentifier(pageIdent);
   1:             }
   1: 
   1:             /* restore previous position of scroller(s), if we're moving
   1:              * back in history (bug 59774)
   1:              */
   1:             if (mOSHE && (aLoadType == LOAD_HISTORY || aLoadType == LOAD_RELOAD_NORMAL))
   1:             {
   1:                 nscoord bx, by;
   1:                 mOSHE->GetScrollPosition(&bx, &by);
   1:                 SetCurScrollPosEx(bx, by);
   1:             }
   1: 
   1:             /* Clear out mLSHE so that further anchor visits get
   1:              * recorded in SH and SH won't misbehave. 
   1:              */
   1:             SetHistoryEntry(&mLSHE, nsnull);
   1:             /* Set the title for the SH entry for this target url. so that
   1:              * SH menus in go/back/forward buttons won't be empty for this.
   1:              */
   1:             if (mSessionHistory) {
   1:                 PRInt32 index = -1;
   1:                 mSessionHistory->GetIndex(&index);
   1:                 nsCOMPtr<nsIHistoryEntry> hEntry;
   1:                 mSessionHistory->GetEntryAtIndex(index, PR_FALSE,
   1:                                                  getter_AddRefs(hEntry));
   1:                 NS_ENSURE_TRUE(hEntry, NS_ERROR_FAILURE);
   1:                 nsCOMPtr<nsISHEntry> shEntry(do_QueryInterface(hEntry));
   1:                 if (shEntry)
   1:                     shEntry->SetTitle(mTitle);
   1:             }
   1: 
   1:             return NS_OK;
   1:         }
   1:     }
   1:     
   1:     // mContentViewer->PermitUnload can destroy |this| docShell, which
   1:     // causes the next call of CanSavePresentation to crash. 
   1:     // Hold onto |this| until we return, to prevent a crash from happening. 
   1:     // (bug#331040)
   1:     nsCOMPtr<nsIDocShell> kungFuDeathGrip(this);
   1: 
   1:     // Check if the page doesn't want to be unloaded. The javascript:
   1:     // protocol handler deals with this for javascript: URLs.
   1:     if (!bIsJavascript && mContentViewer) {
   1:         PRBool okToUnload;
   1:         rv = mContentViewer->PermitUnload(&okToUnload);
   1: 
   1:         if (NS_SUCCEEDED(rv) && !okToUnload) {
   1:             // The user chose not to unload the page, interrupt the
   1:             // load.
   1:             return NS_OK;
   1:         }
   1:     }
   1: 
   1:     // Check for saving the presentation here, before calling Stop().
   1:     // This is necessary so that we can catch any pending requests.
   1:     // Since the new request has not been created yet, we pass null for the
   1:     // new request parameter.
   1:     // Also pass nsnull for the document, since it doesn't affect the return
   1:     // value for our purposes here.
   1:     PRBool savePresentation = CanSavePresentation(aLoadType, nsnull, nsnull);
   1: 
   1:     // Don't stop current network activity for javascript: URL's since
   1:     // they might not result in any data, and thus nothing should be
   1:     // stopped in those cases. In the case where they do result in
   1:     // data, the javascript: URL channel takes care of stopping
   1:     // current network activity.
   1:     if (!bIsJavascript) {
   1:         // Stop any current network activity.
   1:         // Also stop content if this is a zombie doc. otherwise 
   1:         // the onload will be delayed by other loads initiated in the 
   1:         // background by the first document that
   1:         // didn't fully load before the next load was initiated.
   1:         // If not a zombie, don't stop content until data 
   1:         // starts arriving from the new URI...
   1: 
   1:         nsCOMPtr<nsIContentViewer> zombieViewer;
   1:         if (mContentViewer) {
   1:             mContentViewer->GetPreviousViewer(getter_AddRefs(zombieViewer));
   1:         }
   1: 
   1:         if (zombieViewer ||
   1:             LOAD_TYPE_HAS_FLAGS(aLoadType, LOAD_FLAGS_STOP_CONTENT)) {
   1:             rv = Stop(nsIWebNavigation::STOP_ALL);
   1:         } else {
   1:             rv = Stop(nsIWebNavigation::STOP_NETWORK);
   1:         }
   1: 
   1:         if (NS_FAILED(rv)) 
   1:             return rv;
   1:     }
   1: 
   1:     mLoadType = aLoadType;
   1:     
   1:     // mLSHE should be assigned to aSHEntry, only after Stop() has
   1:     // been called. But when loading an error page, do not clear the
   1:     // mLSHE for the real page.
   1:     if (mLoadType != LOAD_ERROR_PAGE)
   1:         SetHistoryEntry(&mLSHE, aSHEntry);
   1: 
   1:     mSavingOldViewer = savePresentation;
   1: 
   1:     // If we have a saved content viewer in history, restore and show it now.
   1:     if (aSHEntry && (mLoadType & LOAD_CMD_HISTORY)) {
6685:         // It's possible that the previous viewer of mContentViewer is the
6685:         // viewer that will end up in aSHEntry when it gets closed.  If that's
6685:         // the case, we need to go ahead and force it into its shentry so we
6685:         // can restore it.
6685:         if (mContentViewer) {
6685:             nsCOMPtr<nsIContentViewer> prevViewer;
6685:             mContentViewer->GetPreviousViewer(getter_AddRefs(prevViewer));
6685:             if (prevViewer) {
6685: #ifdef DEBUG
6685:                 nsCOMPtr<nsIContentViewer> prevPrevViewer;
6685:                 prevViewer->GetPreviousViewer(getter_AddRefs(prevPrevViewer));
6685:                 NS_ASSERTION(!prevPrevViewer, "Should never have viewer chain here");
6685: #endif
6685:                 nsCOMPtr<nsISHEntry> viewerEntry;
6685:                 prevViewer->GetHistoryEntry(getter_AddRefs(viewerEntry));
6685:                 if (viewerEntry == aSHEntry) {
6685:                     // Make sure this viewer ends up in the right place
6685:                     mContentViewer->SetPreviousViewer(nsnull);
6685:                     prevViewer->Destroy();
6685:                 }
6685:             }
6685:         }
   1:         nsCOMPtr<nsISHEntry> oldEntry = mOSHE;
   1:         PRBool restoring;
   1:         rv = RestorePresentation(aSHEntry, &restoring);
   1:         if (restoring)
   1:             return rv;
   1: 
   1:         // We failed to restore the presentation, so clean up.
   1:         // Both the old and new history entries could potentially be in
   1:         // an inconsistent state.
   1:         if (NS_FAILED(rv)) {
   1:             if (oldEntry)
   1:                 oldEntry->SyncPresentationState();
   1: 
   1:             aSHEntry->SyncPresentationState();
   1:         }
   1:     }
   1: 
   1:     nsCOMPtr<nsIRequest> req;
   1:     rv = DoURILoad(aURI, aReferrer,
   1:                    !(aFlags & INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER),
   1:                    owner, aTypeHint, aPostData, aHeadersData, aFirstParty,
   1:                    aDocShell, getter_AddRefs(req),
   1:                    (aFlags & INTERNAL_LOAD_FLAGS_FIRST_LOAD) != 0);
   1:     if (req && aRequest)
   1:         NS_ADDREF(*aRequest = req);
   1: 
   1:     if (NS_FAILED(rv)) {
   1:         nsCOMPtr<nsIChannel> chan(do_QueryInterface(req));
   1:         DisplayLoadError(rv, aURI, nsnull, chan);
   1:     }
   1:     
   1:     return rv;
   1: }
   1: 
   1: nsIPrincipal*
   1: nsDocShell::GetInheritedPrincipal(PRBool aConsiderCurrentDocument)
   1: {
   1:     nsCOMPtr<nsIDocument> document;
   1: 
   1:     if (aConsiderCurrentDocument && mContentViewer) {
   1:         nsCOMPtr<nsIDocumentViewer>
   1:             docViewer(do_QueryInterface(mContentViewer));
   1:         if (!docViewer)
   1:             return nsnull;
   1:         docViewer->GetDocument(getter_AddRefs(document));
   1:     }
   1: 
   1:     if (!document) {
   1:         nsCOMPtr<nsIDocShellTreeItem> parentItem;
   1:         GetSameTypeParent(getter_AddRefs(parentItem));
   1:         if (parentItem) {
   1:             nsCOMPtr<nsIDOMDocument> parentDomDoc(do_GetInterface(parentItem));
   1:             document = do_QueryInterface(parentDomDoc);
   1:         }
   1:     }
   1: 
   1:     if (!document) {
   1:         if (!aConsiderCurrentDocument) {
   1:             return nsnull;
   1:         }
   1: 
   1:         // Make sure we end up with _something_ as the principal no matter
   1:         // what.
   1:         EnsureContentViewer();  // If this fails, we'll just get a null
   1:                                 // docViewer and bail.
   1: 
   1:         nsCOMPtr<nsIDocumentViewer>
   1:             docViewer(do_QueryInterface(mContentViewer));
   1:         if (!docViewer)
   1:             return nsnull;
   1:         docViewer->GetDocument(getter_AddRefs(document));
   1:     }
   1: 
   1:     //-- Get the document's principal
   1:     if (document) {
   1:         return document->NodePrincipal();
   1:     }
   1: 
   1:     return nsnull;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::DoURILoad(nsIURI * aURI,
   1:                       nsIURI * aReferrerURI,
   1:                       PRBool aSendReferrer,
   1:                       nsISupports * aOwner,
   1:                       const char * aTypeHint,
   1:                       nsIInputStream * aPostData,
   1:                       nsIInputStream * aHeadersData,
   1:                       PRBool aFirstParty,
   1:                       nsIDocShell ** aDocShell,
   1:                       nsIRequest ** aRequest,
   1:                       PRBool aIsNewWindowTarget)
   1: {
   1:     nsresult rv;
   1:     nsCOMPtr<nsIURILoader> uriLoader;
   1: 
   1:     uriLoader = do_GetService(NS_URI_LOADER_CONTRACTID, &rv);
   1:     if (NS_FAILED(rv)) return rv;
   1: 
   1:     nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
   1:     if (aFirstParty) {
   1:         // tag first party URL loads
   1:         loadFlags |= nsIChannel::LOAD_INITIAL_DOCUMENT_URI;
   1:     }
   1: 
   1:     if (mLoadType == LOAD_ERROR_PAGE) {
   1:         // Error pages are LOAD_BACKGROUND
   1:         loadFlags |= nsIChannel::LOAD_BACKGROUND;
   1:     }
   1: 
   1:     // open a channel for the url
   1:     nsCOMPtr<nsIChannel> channel;
   1: 
   1:     rv = NS_NewChannel(getter_AddRefs(channel),
   1:                        aURI,
   1:                        nsnull,
   1:                        nsnull,
3233:                        static_cast<nsIInterfaceRequestor *>(this),
   1:                        loadFlags);
   1:     if (NS_FAILED(rv)) {
   1:         if (rv == NS_ERROR_UNKNOWN_PROTOCOL) {
   1:             // This is a uri with a protocol scheme we don't know how
   1:             // to handle.  Embedders might still be interested in
   1:             // handling the load, though, so we fire a notification
   1:             // before throwing the load away.
   1:             PRBool abort = PR_FALSE;
   1:             nsresult rv2 = mContentListener->OnStartURIOpen(aURI, &abort);
   1:             if (NS_SUCCEEDED(rv2) && abort) {
   1:                 // Hey, they're handling the load for us!  How convenient!
   1:                 return NS_OK;
   1:             }
   1:         }
   1:             
   1:         return rv;
   1:     }
   1: 
   1:     // Make sure to give the caller a channel if we managed to create one
   1:     // This is important for correct error page/session history interaction
   1:     if (aRequest)
   1:         NS_ADDREF(*aRequest = channel);
   1: 
   1:     channel->SetOriginalURI(aURI);
   1:     if (aTypeHint && *aTypeHint) {
   1:         channel->SetContentType(nsDependentCString(aTypeHint));
   1:         mContentTypeHint = aTypeHint;
   1:     }
   1:     else {
   1:         mContentTypeHint.Truncate();
   1:     }
   1:     
   1:     //hack
   1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
   1:     nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal(do_QueryInterface(channel));
   1:     if (httpChannelInternal) {
   1:       if (aFirstParty) {
   1:         httpChannelInternal->SetDocumentURI(aURI);
   1:       } else {
   1:         httpChannelInternal->SetDocumentURI(aReferrerURI);
   1:       }
   1:     }
   1: 
   1:     nsCOMPtr<nsIWritablePropertyBag2> props(do_QueryInterface(channel));
   1:     if (props)
   1:     {
   1:       // save true referrer for those who need it (e.g. xpinstall whitelisting)
   1:       // Currently only http and ftp channels support this.
   1:       props->SetPropertyAsInterface(NS_LITERAL_STRING("docshell.internalReferrer"),
   1:                                     aReferrerURI);
   1:     }
   1: 
   1:     //
   1:     // If this is a HTTP channel, then set up the HTTP specific information
   1:     // (ie. POST data, referrer, ...)
   1:     //
   1:     if (httpChannel) {
   1:         nsCOMPtr<nsICachingChannel>  cacheChannel(do_QueryInterface(httpChannel));
   1:         /* Get the cache Key from SH */
   1:         nsCOMPtr<nsISupports> cacheKey;
   1:         if (mLSHE) {
   1:             mLSHE->GetCacheKey(getter_AddRefs(cacheKey));
   1:         }
   1:         else if (mOSHE)          // for reload cases
   1:             mOSHE->GetCacheKey(getter_AddRefs(cacheKey));
   1: 
   1:         // figure out if we need to set the post data stream on the channel...
   1:         // right now, this is only done for http channels.....
   1:         if (aPostData) {
   1:             // XXX it's a bit of a hack to rewind the postdata stream here but
   1:             // it has to be done in case the post data is being reused multiple
   1:             // times.
   1:             nsCOMPtr<nsISeekableStream>
   1:                 postDataSeekable(do_QueryInterface(aPostData));
   1:             if (postDataSeekable) {
   1:                 rv = postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
   1:                 NS_ENSURE_SUCCESS(rv, rv);
   1:             }
   1: 
   1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
   1:             NS_ASSERTION(uploadChannel, "http must support nsIUploadChannel");
   1: 
   1:             // we really need to have a content type associated with this stream!!
   1:             uploadChannel->SetUploadStream(aPostData, EmptyCString(), -1);
   1:             /* If there is a valid postdata *and* it is a History Load,
   1:              * set up the cache key on the channel, to retrieve the
   1:              * data *only* from the cache. If it is a normal reload, the 
   1:              * cache is free to go to the server for updated postdata. 
   1:              */
   1:             if (cacheChannel && cacheKey) {
   1:                 if (mLoadType == LOAD_HISTORY || mLoadType == LOAD_RELOAD_CHARSET_CHANGE) {
   1:                     cacheChannel->SetCacheKey(cacheKey);
   1:                     PRUint32 loadFlags;
   1:                     if (NS_SUCCEEDED(channel->GetLoadFlags(&loadFlags)))
   1:                         channel->SetLoadFlags(loadFlags | nsICachingChannel::LOAD_ONLY_FROM_CACHE);
   1:                 }
   1:                 else if (mLoadType == LOAD_RELOAD_NORMAL)
   1:                     cacheChannel->SetCacheKey(cacheKey);
   1:             }         
   1:         }
   1:         else {
   1:             /* If there is no postdata, set the cache key on the channel, and
   1:              * do not set the LOAD_ONLY_FROM_CACHE flag, so that the channel
   1:              * will be free to get it from net if it is not found in cache.
   1:              * New cache may use it creatively on CGI pages with GET
   1:              * method and even on those that say "no-cache"
   1:              */
   1:             if (mLoadType == LOAD_HISTORY || mLoadType == LOAD_RELOAD_NORMAL 
   1:                 || mLoadType == LOAD_RELOAD_CHARSET_CHANGE) {
   1:                 if (cacheChannel && cacheKey)
   1:                     cacheChannel->SetCacheKey(cacheKey);
   1:             }
   1:         }
   1:         if (aHeadersData) {
   1:             rv = AddHeadersToChannel(aHeadersData, httpChannel);
   1:         }
   1:         // Set the referrer explicitly
   1:         if (aReferrerURI && aSendReferrer) {
   1:             // Referrer is currenly only set for link clicks here.
   1:             httpChannel->SetReferrer(aReferrerURI);
   1:         }
   1:     }
   1:     //
   1:     // Set the owner of the channel, but only for channels that can't
   1:     // provide their own security context.
   1:     //
   1:     // XXX: Is seems wrong that the owner is ignored - even if one is
   1:     //      supplied) unless the URI is javascript or data or about:blank.
   1:     // XXX: If this is ever changed, check all callers for what owners they're
   1:     //      passing in.  In particular, see the code and comments in LoadURI
   1:     //      where we fall back on inheriting the owner if called
   1:     //      from chrome.  That would be very wrong if this code changed
   1:     //      anything but channels that can't provide their own security context!
   1:     //
   1:     //      (Currently chrome URIs set the owner when they are created!
   1:     //      So setting a NULL owner would be bad!)
   1:     //
   1: 
   1:     PRBool inherit;
   1:     // We expect URIInheritsSecurityContext to return success for an
   1:     // about:blank URI, so don't call IsAboutBlank() if this call fails.
   1:     rv = URIInheritsSecurityContext(aURI, &inherit);
   1:     if (NS_SUCCEEDED(rv) && (inherit || IsAboutBlank(aURI))) {
   1:         channel->SetOwner(aOwner);
   1:         nsCOMPtr<nsIScriptChannel> scriptChannel = do_QueryInterface(channel);
   1:         if (scriptChannel) {
   1:             // Allow execution against our context if the principals match
   1:             scriptChannel->
   1:                 SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
   1:         }
   1:     }
   1: 
   1:     if (aIsNewWindowTarget) {
   1:         nsCOMPtr<nsIWritablePropertyBag2> props = do_QueryInterface(channel);
   1:         if (props) {
   1:             props->SetPropertyAsBool(
   1:                 NS_LITERAL_STRING("docshell.newWindowTarget"),
   1:                 PR_TRUE);
   1:         }
   1:     }
   1: 
   1:     rv = DoChannelLoad(channel, uriLoader);
   1:     
   1:     //
   1:     // If the channel load failed, we failed and nsIWebProgress just ain't
   1:     // gonna happen.
   1:     //
   1:     if (NS_SUCCEEDED(rv)) {
   1:         if (aDocShell) {
   1:           *aDocShell = this;
   1:           NS_ADDREF(*aDocShell);
   1:         }
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: static NS_METHOD
   1: AppendSegmentToString(nsIInputStream *in,
   1:                       void *closure,
   1:                       const char *fromRawSegment,
   1:                       PRUint32 toOffset,
   1:                       PRUint32 count,
   1:                       PRUint32 *writeCount)
   1: {
   1:     // aFromSegment now contains aCount bytes of data.
   1: 
3233:     nsCAutoString *buf = static_cast<nsCAutoString *>(closure);
   1:     buf->Append(fromRawSegment, count);
   1: 
   1:     // Indicate that we have consumed all of aFromSegment
   1:     *writeCount = count;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::AddHeadersToChannel(nsIInputStream *aHeadersData,
   1:                                 nsIChannel *aGenericChannel)
   1: {
   1:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aGenericChannel);
   1:     NS_ENSURE_STATE(httpChannel);
   1: 
   1:     PRUint32 numRead;
   1:     nsCAutoString headersString;
   1:     nsresult rv = aHeadersData->ReadSegments(AppendSegmentToString,
   1:                                              &headersString,
   1:                                              PR_UINT32_MAX,
   1:                                              &numRead);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     // used during the manipulation of the String from the InputStream
   1:     nsCAutoString headerName;
   1:     nsCAutoString headerValue;
   1:     PRInt32 crlf;
   1:     PRInt32 colon;
   1: 
   1:     //
   1:     // Iterate over the headersString: for each "\r\n" delimited chunk,
   1:     // add the value as a header to the nsIHttpChannel
   1:     //
   1: 
   1:     static const char kWhitespace[] = "\b\t\r\n ";
   1:     while (PR_TRUE) {
   1:         crlf = headersString.Find("\r\n");
   1:         if (crlf == kNotFound)
   1:             return NS_OK;
   1: 
   1:         const nsCSubstring &oneHeader = StringHead(headersString, crlf);
   1: 
   1:         colon = oneHeader.FindChar(':');
   1:         if (colon == kNotFound)
   1:             return NS_ERROR_UNEXPECTED;
   1: 
   1:         headerName = StringHead(oneHeader, colon);
   1:         headerValue = Substring(oneHeader, colon + 1);
   1: 
   1:         headerName.Trim(kWhitespace);
   1:         headerValue.Trim(kWhitespace);
   1: 
   1:         headersString.Cut(0, crlf + 2);
   1: 
   1:         //
   1:         // FINALLY: we can set the header!
   1:         // 
   1: 
   1:         rv = httpChannel->SetRequestHeader(headerName, headerValue, PR_TRUE);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:     }
   1: 
   1:     NS_NOTREACHED("oops");
   1:     return NS_ERROR_UNEXPECTED;
   1: }
   1: 
   1: nsresult nsDocShell::DoChannelLoad(nsIChannel * aChannel,
   1:                                    nsIURILoader * aURILoader)
   1: {
   1:     nsresult rv;
   1:     // Mark the channel as being a document URI and allow content sniffing...
   1:     nsLoadFlags loadFlags = 0;
   1:     (void) aChannel->GetLoadFlags(&loadFlags);
   1:     loadFlags |= nsIChannel::LOAD_DOCUMENT_URI |
   1:                  nsIChannel::LOAD_CALL_CONTENT_SNIFFERS;
   1: 
   1:     // Load attributes depend on load type...
   1:     switch (mLoadType) {
   1:     case LOAD_HISTORY:
   1:         loadFlags |= nsIRequest::VALIDATE_NEVER;
   1:         break;
   1: 
   1:     case LOAD_RELOAD_CHARSET_CHANGE:
   1:         loadFlags |= nsIRequest::LOAD_FROM_CACHE;
   1:         break;
   1:     
   1:     case LOAD_RELOAD_NORMAL:
   1:     case LOAD_REFRESH:
   1:         loadFlags |= nsIRequest::VALIDATE_ALWAYS;
   1:         break;
   1: 
   1:     case LOAD_NORMAL_BYPASS_CACHE:
   1:     case LOAD_NORMAL_BYPASS_PROXY:
   1:     case LOAD_NORMAL_BYPASS_PROXY_AND_CACHE:
   1:     case LOAD_RELOAD_BYPASS_CACHE:
   1:     case LOAD_RELOAD_BYPASS_PROXY:
   1:     case LOAD_RELOAD_BYPASS_PROXY_AND_CACHE:
   1:         loadFlags |= nsIRequest::LOAD_BYPASS_CACHE;
   1:         break;
   1: 
   1:     case LOAD_NORMAL:
   1:     case LOAD_LINK:
   1:         // Set cache checking flags
   1:         PRInt32 prefSetting;
   1:         if (NS_SUCCEEDED
   1:             (mPrefs->
   1:              GetIntPref("browser.cache.check_doc_frequency",
   1:                         &prefSetting))) {
   1:             switch (prefSetting) {
   1:             case 0:
   1:                 loadFlags |= nsIRequest::VALIDATE_ONCE_PER_SESSION;
   1:                 break;
   1:             case 1:
   1:                 loadFlags |= nsIRequest::VALIDATE_ALWAYS;
   1:                 break;
   1:             case 2:
   1:                 loadFlags |= nsIRequest::VALIDATE_NEVER;
   1:                 break;
   1:             }
   1:         }
   1:         break;
   1:     }
   1: 
   1:     (void) aChannel->SetLoadFlags(loadFlags);
   1: 
   1:     rv = aURILoader->OpenURI(aChannel,
   1:                              (mLoadType == LOAD_LINK),
   1:                              this);
5528:     NS_ENSURE_SUCCESS(rv, rv);
5528: 
5528:     rv = CheckClassifier(aChannel);
5528:     if (NS_FAILED(rv)) {
5528:         aChannel->Cancel(rv);
   1:         return rv;
   1:     }
   1: 
5528:     return NS_OK;
5528: }
5528: 
5528: nsresult
5528: nsDocShell::CheckClassifier(nsIChannel *aChannel)
5528: {
5528:     nsRefPtr<nsClassifierCallback> classifier = new nsClassifierCallback();
5528:     if (!classifier) return NS_ERROR_OUT_OF_MEMORY;
5528: 
5528:     classifier->SetChannel(aChannel);
5528:     nsresult rv = classifier->Run();
5528:     if (rv == NS_ERROR_FACTORY_NOT_REGISTERED) {
5528:         // no URI classifier, ignore this
5528:         return NS_OK;
5528:     }
5528:     NS_ENSURE_SUCCESS(rv, rv);
5528: 
5528:     mClassifier = classifier;
5528: 
5528:     return NS_OK;
5528: }
5528: 
   1: NS_IMETHODIMP
   1: nsDocShell::ScrollIfAnchor(nsIURI * aURI, PRBool * aWasAnchor,
   1:                            PRUint32 aLoadType, nscoord *cx, nscoord *cy)
   1: {
   1:     NS_ASSERTION(aURI, "null uri arg");
   1:     NS_ASSERTION(aWasAnchor, "null anchor arg");
   1: 
   1:     if (aURI == nsnull || aWasAnchor == nsnull) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1: 
   1:     *aWasAnchor = PR_FALSE;
   1: 
   1:     if (!mCurrentURI) {
   1:         return NS_OK;
   1:     }
   1: 
   1:     nsCOMPtr<nsIPresShell> shell;
   1:     nsresult rv = GetPresShell(getter_AddRefs(shell));
   1:     if (NS_FAILED(rv) || !shell) {
   1:         // If we failed to get the shell, or if there is no shell,
   1:         // nothing left to do here.
   1:         
   1:         return rv;
   1:     }
   1: 
   1:     // NOTE: we assume URIs are absolute for comparison purposes
   1: 
   1:     nsCAutoString currentSpec;
   1:     NS_ENSURE_SUCCESS(mCurrentURI->GetSpec(currentSpec),
   1:                       NS_ERROR_FAILURE);
   1: 
   1:     nsCAutoString newSpec;
   1:     NS_ENSURE_SUCCESS(aURI->GetSpec(newSpec), NS_ERROR_FAILURE);
   1: 
   1:     // Search for hash marks in the current URI and the new URI and
   1:     // take a copy of everything to the left of the hash for
   1:     // comparison.
   1: 
   1:     const char kHash = '#';
   1: 
   1:     // Split the new URI into a left and right part
   1:     // (assume we're parsing it out right
   1:     nsACString::const_iterator urlStart, urlEnd, refStart, refEnd;
   1:     newSpec.BeginReading(urlStart);
   1:     newSpec.EndReading(refEnd);
   1:     
   1:     PRInt32 hashNew = newSpec.FindChar(kHash);
   1:     if (hashNew == 0) {
   1:         return NS_OK;           // Strange URI
   1:     }
   1: 
   1:     if (hashNew > 0) {
   1:         // found it
   1:         urlEnd = urlStart;
   1:         urlEnd.advance(hashNew);
   1:         
   1:         refStart = urlEnd;
   1:         ++refStart;             // advanced past '#'
   1:         
   1:     }
   1:     else {
   1:         // no hash at all
   1:         urlEnd = refStart = refEnd;
   1:     }
   1:     const nsACString& sNewLeft = Substring(urlStart, urlEnd);
   1:     const nsACString& sNewRef =  Substring(refStart, refEnd);
   1:                                           
   1:     // Split the current URI in a left and right part
   1:     nsACString::const_iterator currentLeftStart, currentLeftEnd;
   1:     currentSpec.BeginReading(currentLeftStart);
   1: 
   1:     PRInt32 hashCurrent = currentSpec.FindChar(kHash);
   1:     if (hashCurrent == 0) {
   1:         return NS_OK;           // Strange URI 
   1:     }
   1: 
   1:     if (hashCurrent > 0) {
   1:         currentLeftEnd = currentLeftStart;
   1:         currentLeftEnd.advance(hashCurrent);
   1:     }
   1:     else {
   1:         currentSpec.EndReading(currentLeftEnd);
   1:     }
   1: 
   1:     // If we have no new anchor, we do not want to scroll, unless there is a
   1:     // current anchor and we are doing a history load.  So return if we have no
   1:     // new anchor, and there is no current anchor or the load is not a history
   1:     // load.
   1:     NS_ASSERTION(hashNew != 0 && hashCurrent != 0,
   1:                  "What happened to the early returns above?");
   1:     if (hashNew == kNotFound &&
   1:         (hashCurrent == kNotFound || aLoadType != LOAD_HISTORY)) {
   1:         return NS_OK;
   1:     }
   1: 
   1:     // Compare the URIs.
   1:     //
   1:     // NOTE: this is a case sensitive comparison because some parts of the
   1:     // URI are case sensitive, and some are not. i.e. the domain name
   1:     // is case insensitive but the the paths are not.
   1:     //
   1:     // This means that comparing "http://www.ABC.com/" to "http://www.abc.com/"
   1:     // will fail this test.
   1: 
   1:     if (!Substring(currentLeftStart, currentLeftEnd).Equals(sNewLeft)) {
   1:         return NS_OK;           // URIs not the same
   1:     }
   1: 
   1:     // Now we know we are dealing with an anchor
   1:     *aWasAnchor = PR_TRUE;
   1: 
   1:     // Both the new and current URIs refer to the same page. We can now
   1:     // browse to the hash stored in the new URI.
   1:     //
   1:     // But first let's capture positions of scroller(s) that can
   1:     // (and usually will) be modified by GoToAnchor() call.
   1: 
   1:     GetCurScrollPos(ScrollOrientation_X, cx);
   1:     GetCurScrollPos(ScrollOrientation_Y, cy);
   1: 
   1:     if (!sNewRef.IsEmpty()) {
   1:         // anchor is there, but if it's a load from history,
   1:         // we don't have any anchor jumping to do
   1:         PRBool scroll = aLoadType != LOAD_HISTORY &&
   1:                         aLoadType != LOAD_RELOAD_NORMAL;
   1: 
   1:         char *str = ToNewCString(sNewRef);
   1:         if (!str) {
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1: 
   1:         // nsUnescape modifies the string that is passed into it.
   1:         nsUnescape(str);
   1: 
   1:         // We assume that the bytes are in UTF-8, as it says in the
   1:         // spec:
   1:         // http://www.w3.org/TR/html4/appendix/notes.html#h-B.2.1
   1: 
   1:         // We try the UTF-8 string first, and then try the document's
   1:         // charset (see below).  If the string is not UTF-8,
   1:         // conversion will fail and give us an empty Unicode string.
   1:         // In that case, we should just fall through to using the
   1:         // page's charset.
   1:         rv = NS_ERROR_FAILURE;
   1:         NS_ConvertUTF8toUTF16 uStr(str);
   1:         if (!uStr.IsEmpty()) {
   1:             rv = shell->GoToAnchor(NS_ConvertUTF8toUTF16(str), scroll);
   1:         }
   1:         nsMemory::Free(str);
   1: 
   1:         // Above will fail if the anchor name is not UTF-8.  Need to
   1:         // convert from document charset to unicode.
   1:         if (NS_FAILED(rv)) {
   1:                 
   1:             // Get a document charset
   1:             NS_ENSURE_TRUE(mContentViewer, NS_ERROR_FAILURE);
   1:             nsCOMPtr<nsIDocumentViewer>
   1:                 docv(do_QueryInterface(mContentViewer));
   1:             NS_ENSURE_TRUE(docv, NS_ERROR_FAILURE);
   1:             nsCOMPtr<nsIDocument> doc;
   1:             rv = docv->GetDocument(getter_AddRefs(doc));
   1:             NS_ENSURE_SUCCESS(rv, rv);
   1:             const nsACString &aCharset = doc->GetDocumentCharacterSet();
   1: 
   1:             nsCOMPtr<nsITextToSubURI> textToSubURI =
   1:                 do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
   1:             NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:             // Unescape and convert to unicode
   1:             nsXPIDLString uStr;
   1: 
   1:             rv = textToSubURI->UnEscapeAndConvert(PromiseFlatCString(aCharset).get(),
   1:                                                   PromiseFlatCString(sNewRef).get(),
   1:                                                   getter_Copies(uStr));
   1:             NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:             // Ignore return value of GoToAnchor, since it will return an error
   1:             // if there is no such anchor in the document, which is actually a
   1:             // success condition for us (we want to update the session history
   1:             // with the new URI no matter whether we actually scrolled
   1:             // somewhere).
   1:             shell->GoToAnchor(uStr, scroll);
   1:         }
   1:     }
   1:     else {
   1: 
   1:         // Tell the shell it's at an anchor, without scrolling.
   1:         shell->GoToAnchor(EmptyString(), PR_FALSE);
   1:         
   1:         // An empty anchor was found, but if it's a load from history,
   1:         // we don't have to jump to the top of the page. Scrollbar 
   1:         // position will be restored by the caller, based on positions
   1:         // stored in session history.
   1:         if (aLoadType == LOAD_HISTORY || aLoadType == LOAD_RELOAD_NORMAL)
   1:             return rv;
   1:         //An empty anchor. Scroll to the top of the page.
   1:         rv = SetCurScrollPosEx(0, 0);
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: void
   1: nsDocShell::SetupReferrerFromChannel(nsIChannel * aChannel)
   1: {
   1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
   1:     if (httpChannel) {
   1:         nsCOMPtr<nsIURI> referrer;
   1:         nsresult rv = httpChannel->GetReferrer(getter_AddRefs(referrer));
   1:         if (NS_SUCCEEDED(rv)) {
   1:             SetReferrerURI(referrer);
   1:         }
   1:     }
   1: }
   1: 
   1: PRBool
   1: nsDocShell::OnNewURI(nsIURI * aURI, nsIChannel * aChannel,
   1:                      PRUint32 aLoadType, PRBool aFireOnLocationChange,
   1:                      PRBool aAddToGlobalHistory)
   1: {
   1:     NS_ASSERTION(aURI, "uri is null");
   1: #if defined(PR_LOGGING) && defined(DEBUG)
   1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
   1:         nsCAutoString spec;
   1:         aURI->GetSpec(spec);
   1: 
   1:         nsCAutoString chanName;
   1:         if (aChannel)
   1:             aChannel->GetName(chanName);
   1:         else
   1:             chanName.AssignLiteral("<no channel>");
   1: 
   1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
   1:                ("nsDocShell[%p]::OnNewURI(\"%s\", [%s], 0x%x)\n", this, spec.get(),
   1:                 chanName.get(), aLoadType));
   1:     }
   1: #endif
   1: 
   1:     PRBool updateHistory = PR_TRUE;
   1:     PRBool equalUri = PR_FALSE;
   1:     PRBool shAvailable = PR_TRUE;  
   1: 
   1:     // Get the post data from the channel
   1:     nsCOMPtr<nsIInputStream> inputStream;
   1:     if (aChannel) {
   1:         nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
   1:         
   1:         // Check if the HTTPChannel is hiding under a multiPartChannel
   1:         if (!httpChannel)  {
   1:             GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
   1:         }
   1: 
   1:         if (httpChannel) {
   1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
   1:             if (uploadChannel) {
   1:                 uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
   1:             }
   1:         }
   1:     }
   1:     /* Create SH Entry (mLSHE) only if there is a  SessionHistory object (mSessionHistory) in
   1:      * the current frame or in the root docshell
   1:      */
   1:     nsCOMPtr<nsISHistory> rootSH = mSessionHistory;
   1:     if (!rootSH) {
   1:         // Get the handle to SH from the root docshell          
   1:         GetRootSessionHistory(getter_AddRefs(rootSH));
   1:         if (!rootSH)
   1:             shAvailable = PR_FALSE;
   1:     }  // rootSH
   1: 
   1: 
   1:     // Determine if this type of load should update history.
   1:     if (aLoadType == LOAD_BYPASS_HISTORY ||
   1:         aLoadType == LOAD_ERROR_PAGE ||
   1:         aLoadType & LOAD_CMD_HISTORY ||
   1:         aLoadType & LOAD_CMD_RELOAD)
   1:         updateHistory = PR_FALSE;
   1: 
   1:     // Check if the url to be loaded is the same as the one already loaded. 
   1:     if (mCurrentURI)
   1:         aURI->Equals(mCurrentURI, &equalUri);
   1: 
   1: #ifdef DEBUG
   1:     PR_LOG(gDocShellLog, PR_LOG_DEBUG,
   1:            ("  shAvailable=%i updateHistory=%i equalURI=%i\n",
   1:             shAvailable, updateHistory, equalUri));
   1: #endif
   1: 
   1:     /* If the url to be loaded is the same as the one already there,
   1:      * and the original loadType is LOAD_NORMAL, LOAD_LINK, or
   1:      * LOAD_STOP_CONTENT, set loadType to LOAD_NORMAL_REPLACE so that
   1:      * AddToSessionHistory() won't mess with the current SHEntry and
   1:      * if this page has any frame children, it also will be handled
   1:      * properly. see bug 83684
   1:      *
   1:      * XXX Hopefully changing the loadType at this time will not hurt  
   1:      *  anywhere. The other way to take care of sequentially repeating
   1:      *  frameset pages is to add new methods to nsIDocShellTreeItem.
   1:      * Hopefully I don't have to do that. 
   1:      */
   1:     if (equalUri &&
   1:         (mLoadType == LOAD_NORMAL ||
   1:          mLoadType == LOAD_LINK ||
   1:          mLoadType == LOAD_STOP_CONTENT) &&
   1:         !inputStream)
   1:     {
   1:         mLoadType = LOAD_NORMAL_REPLACE;
   1:     }
   1: 
   1:     // If this is a refresh to the currently loaded url, we don't
   1:     // have to update session or global history.
   1:     if (mLoadType == LOAD_REFRESH && !inputStream && equalUri) {
   1:         SetHistoryEntry(&mLSHE, mOSHE);
   1:     }
   1: 
   1: 
   1:     /* If the user pressed shift-reload, cache will create a new cache key
   1:      * for the page. Save the new cacheKey in Session History. 
   1:      * see bug 90098
   1:      */
   1:     if (aChannel &&
   1:         (aLoadType == LOAD_RELOAD_BYPASS_CACHE ||
   1:          aLoadType == LOAD_RELOAD_BYPASS_PROXY ||
   1:          aLoadType == LOAD_RELOAD_BYPASS_PROXY_AND_CACHE)) {
   1:         NS_ASSERTION(!updateHistory,
   1:                      "We shouldn't be updating history for forced reloads!");
   1:         
   1:         nsCOMPtr<nsICachingChannel> cacheChannel(do_QueryInterface(aChannel));
   1:         nsCOMPtr<nsISupports>  cacheKey;
   1:         // Get the Cache Key  and store it in SH.         
   1:         if (cacheChannel) 
   1:             cacheChannel->GetCacheKey(getter_AddRefs(cacheKey));
   1:         // If we already have a loading history entry, store the new cache key
   1:         // in it.  Otherwise, since we're doing a reload and won't be updating
   1:         // our history entry, store the cache key in our current history entry.
   1:         if (mLSHE)
   1:             mLSHE->SetCacheKey(cacheKey);
   1:         else if (mOSHE)
   1:             mOSHE->SetCacheKey(cacheKey);
   1:     }
   1: 
   1:     if (updateHistory && shAvailable) { 
   1:         // Update session history if necessary...
   1:         if (!mLSHE && (mItemType == typeContent) && mURIResultedInDocument) {
   1:             /* This is  a fresh page getting loaded for the first time
   1:              *.Create a Entry for it and add it to SH, if this is the
   1:              * rootDocShell
   1:              */
   1:             (void) AddToSessionHistory(aURI, aChannel, getter_AddRefs(mLSHE));
   1:         }
   1: 
   1:         // Update Global history
   1:         if (aAddToGlobalHistory) {
   1:             // Get the referrer uri from the channel
   1:             AddToGlobalHistory(aURI, PR_FALSE, aChannel);
   1:         }
   1:     }
   1: 
   1:     // If this was a history load, update the index in 
   1:     // SH. 
   1:     if (rootSH && (mLoadType & LOAD_CMD_HISTORY)) {
   1:         nsCOMPtr<nsISHistoryInternal> shInternal(do_QueryInterface(rootSH));
   1:         if (shInternal) {
   1:             rootSH->GetIndex(&mPreviousTransIndex);
   1:             shInternal->UpdateIndex();
   1:             rootSH->GetIndex(&mLoadedTransIndex);
   1: #ifdef DEBUG_PAGE_CACHE
   1:             printf("Previous index: %d, Loaded index: %d\n\n",
   1:                    mPreviousTransIndex, mLoadedTransIndex);
   1: #endif
   1:         }
   1:     }
   1:     PRBool onLocationChangeNeeded = SetCurrentURI(aURI, aChannel,
   1:                                                   aFireOnLocationChange);
   1:     // Make sure to store the referrer from the channel, if any
   1:     SetupReferrerFromChannel(aChannel);
   1:     return onLocationChangeNeeded;
   1: }
   1: 
   1: PRBool
   1: nsDocShell::OnLoadingSite(nsIChannel * aChannel, PRBool aFireOnLocationChange,
   1:                           PRBool aAddToGlobalHistory)
   1: {
   1:     nsCOMPtr<nsIURI> uri;
   1:     // If this a redirect, use the final url (uri)
   1:     // else use the original url
   1:     //
   1:     // Note that this should match what documents do (see nsDocument::Reset).
7109:     NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
   1:     NS_ENSURE_TRUE(uri, PR_FALSE);
   1: 
   1:     return OnNewURI(uri, aChannel, mLoadType, aFireOnLocationChange,
   1:                     aAddToGlobalHistory);
   1: 
   1: }
   1: 
   1: void
   1: nsDocShell::SetReferrerURI(nsIURI * aURI)
   1: {
   1:     mReferrerURI = aURI;        // This assigment addrefs
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell: Session History
   1: //*****************************************************************************   
   1: PRBool
   1: nsDocShell::ShouldAddToSessionHistory(nsIURI * aURI)
   1: {
   1:     // I believe none of the about: urls should go in the history. But then
   1:     // that could just be me... If the intent is only deny about:blank then we
   1:     // should just do a spec compare, rather than two gets of the scheme and
   1:     // then the path.  -Gagan
   1:     nsresult rv;
   1:     nsCAutoString buf;
   1: 
   1:     rv = aURI->GetScheme(buf);
   1:     if (NS_FAILED(rv))
   1:         return PR_FALSE;
   1: 
   1:     if (buf.Equals("about")) {
   1:         rv = aURI->GetPath(buf);
   1:         if (NS_FAILED(rv))
   1:             return PR_FALSE;
   1: 
   1:         if (buf.Equals("blank")) {
   1:             return PR_FALSE;
   1:         }
   1:     }
   1:     return PR_TRUE;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::AddToSessionHistory(nsIURI * aURI,
   1:                                 nsIChannel * aChannel, nsISHEntry ** aNewEntry)
   1: {
   1: #if defined(PR_LOGGING) && defined(DEBUG)
   1:     if (PR_LOG_TEST(gDocShellLog, PR_LOG_DEBUG)) {
   1:         nsCAutoString spec;
   1:         aURI->GetSpec(spec);
   1: 
   1:         nsCAutoString chanName;
   1:         if (aChannel)
   1:             aChannel->GetName(chanName);
   1:         else
   1:             chanName.AssignLiteral("<no channel>");
   1: 
   1:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
   1:                ("nsDocShell[%p]::AddToSessionHistory(\"%s\", [%s])\n", this, spec.get(),
   1:                 chanName.get()));
   1:     }
   1: #endif
   1: 
   1:     nsresult rv = NS_OK;
   1:     nsCOMPtr<nsISHEntry> entry;
   1:     PRBool shouldPersist;
   1: 
   1:     shouldPersist = ShouldAddToSessionHistory(aURI);
   1: 
   1:     // Get a handle to the root docshell 
   1:     nsCOMPtr<nsIDocShellTreeItem> root;
   1:     GetSameTypeRootTreeItem(getter_AddRefs(root));     
   1:     /*
   1:      * If this is a LOAD_FLAGS_REPLACE_HISTORY in a subframe, we use
   1:      * the existing SH entry in the page and replace the url and
   1:      * other vitalities.
   1:      */
   1:     if (LOAD_TYPE_HAS_FLAGS(mLoadType, LOAD_FLAGS_REPLACE_HISTORY) &&
3233:         root != static_cast<nsIDocShellTreeItem *>(this)) {
   1:         // This is a subframe 
   1:         entry = mOSHE;
   1:         nsCOMPtr<nsISHContainer> shContainer(do_QueryInterface(entry));
   1:         if (shContainer) {
   1:             PRInt32 childCount = 0;
   1:             shContainer->GetChildCount(&childCount);
   1:             // Remove all children of this entry 
   1:             for (PRInt32 i = childCount - 1; i >= 0; i--) {
   1:                 nsCOMPtr<nsISHEntry> child;
   1:                 shContainer->GetChildAt(i, getter_AddRefs(child));
   1:                 shContainer->RemoveChild(child);
   1:             }  // for
   1:         }  // shContainer
   1:     }
   1: 
   1:     // Create a new entry if necessary.
   1:     if (!entry) {
   1:         entry = do_CreateInstance(NS_SHENTRY_CONTRACTID);
   1: 
   1:         if (!entry) {
   1:             return NS_ERROR_OUT_OF_MEMORY;
   1:         }
   1:     }
   1: 
   1:     // Get the post data & referrer
   1:     nsCOMPtr<nsIInputStream> inputStream;
   1:     nsCOMPtr<nsIURI> referrerURI;
   1:     nsCOMPtr<nsISupports> cacheKey;
   1:     nsCOMPtr<nsISupports> cacheToken;
   1:     nsCOMPtr<nsISupports> owner;
   1:     PRBool expired = PR_FALSE;
   1:     PRBool discardLayoutState = PR_FALSE;
   1:     if (aChannel) {
   1:         nsCOMPtr<nsICachingChannel>
   1:             cacheChannel(do_QueryInterface(aChannel));
   1:         /* If there is a caching channel, get the Cache Key  and store it 
   1:          * in SH.
   1:          */
   1:         if (cacheChannel) {
   1:             cacheChannel->GetCacheKey(getter_AddRefs(cacheKey));
   1:             cacheChannel->GetCacheToken(getter_AddRefs(cacheToken));
   1:         }
   1:         nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aChannel));
   1:         
   1:         // Check if the httpChannel is hiding under a multipartChannel
   1:         if (!httpChannel) {
   1:             GetHttpChannel(aChannel, getter_AddRefs(httpChannel));
   1:         }
   1:         if (httpChannel) {
   1:             nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
   1:             if (uploadChannel) {
   1:                 uploadChannel->GetUploadStream(getter_AddRefs(inputStream));
   1:             }
   1:             httpChannel->GetReferrer(getter_AddRefs(referrerURI));
   1: 
   1:             discardLayoutState = ShouldDiscardLayoutState(httpChannel);
   1:         }
   1:         aChannel->GetOwner(getter_AddRefs(owner));
   1:     }
   1: 
   1:     //Title is set in nsDocShell::SetTitle()
   1:     entry->Create(aURI,              // uri
   1:                   EmptyString(),     // Title
   1:                   inputStream,       // Post data stream
   1:                   nsnull,            // LayoutHistory state
   1:                   cacheKey,          // CacheKey
   1:                   mContentTypeHint,  // Content-type
   1:                   owner);            // Channel owner
   1:     entry->SetReferrerURI(referrerURI);
   1:     /* If cache got a 'no-store', ask SH not to store
   1:      * HistoryLayoutState. By default, SH will set this
   1:      * flag to PR_TRUE and save HistoryLayoutState.
   1:      */    
   1:     if (discardLayoutState) {
   1:         entry->SetSaveLayoutStateFlag(PR_FALSE);
   1:     }
   1:     if (cacheToken) {
   1:         // Check if the page has expired from cache 
   1:         nsCOMPtr<nsICacheEntryInfo> cacheEntryInfo(do_QueryInterface(cacheToken));
   1:         if (cacheEntryInfo) {        
   1:             PRUint32 expTime;         
   1:             cacheEntryInfo->GetExpirationTime(&expTime);         
   1:             PRUint32 now = PRTimeToSeconds(PR_Now());                  
   1:             if (expTime <=  now)            
   1:                 expired = PR_TRUE;         
   1:          
   1:         }
   1:     }
   1:     if (expired == PR_TRUE)
   1:         entry->SetExpirationStatus(PR_TRUE);
   1: 
   1: 
3233:     if (root == static_cast<nsIDocShellTreeItem *>(this) && mSessionHistory) {
   1:         // This is the root docshell
   1:         if (LOAD_TYPE_HAS_FLAGS(mLoadType, LOAD_FLAGS_REPLACE_HISTORY)) {            
   1:             // Replace current entry in session history.
   1:             PRInt32  index = 0;   
   1:             mSessionHistory->GetIndex(&index);
   1:             nsCOMPtr<nsISHistoryInternal>   shPrivate(do_QueryInterface(mSessionHistory));
   1:             // Replace the current entry with the new entry
   1:             if (shPrivate)
   1:                 rv = shPrivate->ReplaceEntry(index, entry);          
   1:         }
   1:         else {
   1:             // Add to session history
   1:             nsCOMPtr<nsISHistoryInternal>
   1:                 shPrivate(do_QueryInterface(mSessionHistory));
   1:             NS_ENSURE_TRUE(shPrivate, NS_ERROR_FAILURE);
   1:             mSessionHistory->GetIndex(&mPreviousTransIndex);
   1:             rv = shPrivate->AddEntry(entry, shouldPersist);
   1:             mSessionHistory->GetIndex(&mLoadedTransIndex);
   1: #ifdef DEBUG_PAGE_CACHE
   1:             printf("Previous index: %d, Loaded index: %d\n\n",
   1:                    mPreviousTransIndex, mLoadedTransIndex);
   1: #endif
   1:         }
   1:     }
   1:     else {  
   1:         // This is a subframe.
   1:         if (!mOSHE || !LOAD_TYPE_HAS_FLAGS(mLoadType,
   1:                                            LOAD_FLAGS_REPLACE_HISTORY))
   1:             rv = DoAddChildSHEntry(entry, mChildOffset);
   1:     }
   1: 
   1:     // Return the new SH entry...
   1:     if (aNewEntry) {
   1:         *aNewEntry = nsnull;
   1:         if (NS_SUCCEEDED(rv)) {
   1:             *aNewEntry = entry;
   1:             NS_ADDREF(*aNewEntry);
   1:         }
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::LoadHistoryEntry(nsISHEntry * aEntry, PRUint32 aLoadType)
   1: {
   1:     nsCOMPtr<nsIURI> uri;
   1:     nsCOMPtr<nsIInputStream> postData;
   1:     nsCOMPtr<nsIURI> referrerURI;
   1:     nsCAutoString contentType;
   1:     nsCOMPtr<nsISupports> owner;
   1: 
   1:     NS_ENSURE_TRUE(aEntry, NS_ERROR_FAILURE);
   1: 
   1:     NS_ENSURE_SUCCESS(aEntry->GetURI(getter_AddRefs(uri)), NS_ERROR_FAILURE);
   1:     NS_ENSURE_SUCCESS(aEntry->GetReferrerURI(getter_AddRefs(referrerURI)),
   1:                       NS_ERROR_FAILURE);
   1:     NS_ENSURE_SUCCESS(aEntry->GetPostData(getter_AddRefs(postData)),
   1:                       NS_ERROR_FAILURE);
   1:     NS_ENSURE_SUCCESS(aEntry->GetContentType(contentType), NS_ERROR_FAILURE);
   1:     NS_ENSURE_SUCCESS(aEntry->GetOwner(getter_AddRefs(owner)),
   1:                       NS_ERROR_FAILURE);
   1: 
   1:     // Calling CreateAboutBlankContentViewer can set mOSHE to null, and if
   1:     // that's the only thing holding a ref to aEntry that will cause aEntry to
   1:     // die while we're loading it.  So hold a strong ref to aEntry here, just
   1:     // in case.
   1:     nsCOMPtr<nsISHEntry> kungFuDeathGrip(aEntry);
   1:     PRBool isJS;
   1:     nsresult rv = uri->SchemeIs("javascript", &isJS);
   1:     if (NS_FAILED(rv) || isJS) {
   1:         // We're loading a URL that will execute script from inside asyncOpen.
   1:         // Replace the current document with about:blank now to prevent
   1:         // anything from the current document from leaking into any JavaScript
   1:         // code in the URL.
6712:         nsCOMPtr<nsIPrincipal> prin = do_QueryInterface(owner);
6712:         rv = CreateAboutBlankContentViewer(prin);
   1: 
   1:         if (NS_FAILED(rv)) {
   1:             // The creation of the intermittent about:blank content
   1:             // viewer failed for some reason (potentially because the
   1:             // user prevented it). Interrupt the history load.
   1:             return NS_OK;
   1:         }
   1: 
   1:         if (!owner) {
   1:             // Ensure that we have an owner.  Otherwise javascript: URIs will
   1:             // pick it up from the about:blank page we just loaded, and we
   1:             // don't really want even that in this case.
   1:             owner = do_CreateInstance("@mozilla.org/nullprincipal;1");
   1:             NS_ENSURE_TRUE(owner, NS_ERROR_OUT_OF_MEMORY);
   1:         }
   1:     }
   1: 
   1:     /* If there is a valid postdata *and* the user pressed
   1:      * reload or shift-reload, take user's permission before we  
   1:      * repost the data to the server.
   1:      */
   1:     if ((aLoadType & LOAD_CMD_RELOAD) && postData) {
   1:       PRBool repost;
   1:       rv = ConfirmRepost(&repost);
   1:       if (NS_FAILED(rv)) return rv;
   1: 
   1:       // If the user pressed cancel in the dialog, return.  We're done here.
   1:       if (!repost)
   1:         return NS_BINDING_ABORTED;
   1:     }
   1: 
   1:     rv = InternalLoad(uri,
   1:                       referrerURI,
   1:                       owner,
   1:                       INTERNAL_LOAD_FLAGS_NONE, // Do not inherit owner from document (security-critical!)
   1:                       nsnull,            // No window target
   1:                       contentType.get(), // Type hint
   1:                       postData,          // Post data stream
   1:                       nsnull,            // No headers stream
   1:                       aLoadType,         // Load type
   1:                       aEntry,            // SHEntry
   1:                       PR_TRUE,
   1:                       nsnull,            // No nsIDocShell
   1:                       nsnull);           // No nsIRequest
   1:     return rv;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::GetShouldSaveLayoutState(PRBool* aShould)
   1: {
   1:     *aShould = PR_FALSE;
   1:     if (mOSHE) {
   1:         // Don't capture historystate and save it in history
   1:         // if the page asked not to do so.
   1:         mOSHE->GetSaveLayoutStateFlag(aShould);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::PersistLayoutHistoryState()
   1: {
   1:     nsresult  rv = NS_OK;
   1:     
   1:     if (mOSHE) {
   1:         PRBool shouldSave;
   1:         GetShouldSaveLayoutState(&shouldSave);
   1:         if (!shouldSave)
   1:             return NS_OK;
   1: 
   1:         nsCOMPtr<nsIPresShell> shell;
   1:         rv = GetPresShell(getter_AddRefs(shell));
   1:         if (NS_SUCCEEDED(rv) && shell) {
   1:             nsCOMPtr<nsILayoutHistoryState> layoutState;
   1:             rv = shell->CaptureHistoryState(getter_AddRefs(layoutState),
   1:                                             PR_TRUE);
   1:         }
   1:     }
   1: 
   1:     return rv;
   1: }
   1: 
   1: /* static */ nsresult
   1: nsDocShell::WalkHistoryEntries(nsISHEntry *aRootEntry,
   1:                                nsDocShell *aRootShell,
   1:                                WalkHistoryEntriesFunc aCallback,
   1:                                void *aData)
   1: {
   1:     NS_ENSURE_TRUE(aRootEntry, NS_ERROR_FAILURE);
   1: 
   1:     nsCOMPtr<nsISHContainer> container(do_QueryInterface(aRootEntry));
   1:     if (!container)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     PRInt32 childCount;
   1:     container->GetChildCount(&childCount);
   1:     for (PRInt32 i = 0; i < childCount; i++) {
   1:         nsCOMPtr<nsISHEntry> childEntry;
   1:         container->GetChildAt(i, getter_AddRefs(childEntry));
   1:         if (!childEntry) {
   1:             // childEntry can be null for valid reasons, for example if the
   1:             // docshell at index i never loaded anything useful.
   1:             continue;
   1:         }
   1: 
   1:         nsDocShell *childShell = nsnull;
   1:         if (aRootShell) {
   1:             // Walk the children of aRootShell and see if one of them
   1:             // has srcChild as a SHEntry.
   1: 
   1:             PRInt32 childCount = aRootShell->mChildList.Count();
   1:             for (PRInt32 j = 0; j < childCount; ++j) {
   1:                 nsDocShell *child =
3233:                     static_cast<nsDocShell*>(aRootShell->ChildAt(j));
   1: 
   1:                 if (child->HasHistoryEntry(childEntry)) {
   1:                     childShell = child;
   1:                     break;
   1:                 }
   1:             }
   1:         }
   1:         nsresult rv = aCallback(childEntry, childShell, i, aData);
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: // callback data for WalkHistoryEntries
   1: struct CloneAndReplaceData
   1: {
   1:     CloneAndReplaceData(PRUint32 aCloneID, nsISHEntry *aReplaceEntry,
   1:                         nsISHEntry *aDestTreeParent)
   1:         : cloneID(aCloneID),
   1:           replaceEntry(aReplaceEntry),
   1:           destTreeParent(aDestTreeParent) { }
   1: 
   1:     PRUint32              cloneID;
   1:     nsISHEntry           *replaceEntry;
   1:     nsISHEntry           *destTreeParent;
   1:     nsCOMPtr<nsISHEntry>  resultEntry;
   1: };
   1: 
   1: /* static */ nsresult
   1: nsDocShell::CloneAndReplaceChild(nsISHEntry *aEntry, nsDocShell *aShell,
   1:                                  PRInt32 aEntryIndex, void *aData)
   1: {
   1:     nsresult result = NS_OK;
   1:     nsCOMPtr<nsISHEntry> dest;
   1: 
3233:     CloneAndReplaceData *data = static_cast<CloneAndReplaceData*>(aData);
   1:     PRUint32 cloneID = data->cloneID;
   1:     nsISHEntry *replaceEntry = data->replaceEntry;
   1: 
   1:     PRUint32 srcID;
   1:     aEntry->GetID(&srcID);
   1: 
   1:     if (srcID == cloneID) {
   1:         // Just replace the entry, and don't walk the children.
   1:         dest = replaceEntry;
   1:         dest->SetIsSubFrame(PR_TRUE);
   1:     } else {
   1:         // Clone the SHEntry...
   1:         result = aEntry->Clone(getter_AddRefs(dest));
   1:         if (NS_FAILED(result))
   1:             return result;
   1: 
   1:         // This entry is for a subframe navigation
   1:         dest->SetIsSubFrame(PR_TRUE);
   1: 
   1:         // Walk the children
   1:         CloneAndReplaceData childData(cloneID, replaceEntry, dest);
   1:         result = WalkHistoryEntries(aEntry, aShell,
   1:                                     CloneAndReplaceChild, &childData);
   1:         if (NS_FAILED(result))
   1:             return result;
   1: 
   1:         if (aShell)
   1:             aShell->SwapHistoryEntries(aEntry, dest);
   1:     }
   1: 
   1:     nsCOMPtr<nsISHContainer> container =
   1:         do_QueryInterface(data->destTreeParent);
   1:     if (container)
   1:         container->AddChild(dest, aEntryIndex);
   1: 
   1:     data->resultEntry = dest;
   1:     return result;
   1: }
   1: 
   1: /* static */ nsresult
   1: nsDocShell::CloneAndReplace(nsISHEntry *aSrcEntry,
   1:                                    nsDocShell *aSrcShell,
   1:                                    PRUint32 aCloneID,
   1:                                    nsISHEntry *aReplaceEntry,
   1:                                    nsISHEntry **aResultEntry)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aResultEntry);
   1:     NS_ENSURE_TRUE(aReplaceEntry, NS_ERROR_FAILURE);
   1: 
   1:     CloneAndReplaceData data(aCloneID, aReplaceEntry, nsnull);
   1:     nsresult rv = CloneAndReplaceChild(aSrcEntry, aSrcShell, 0, &data);
   1: 
   1:     data.resultEntry.swap(*aResultEntry);
   1:     return rv;
   1: }
   1: 
   1: 
   1: void
   1: nsDocShell::SwapHistoryEntries(nsISHEntry *aOldEntry, nsISHEntry *aNewEntry)
   1: {
   1:     if (aOldEntry == mOSHE)
   1:         mOSHE = aNewEntry;
   1: 
   1:     if (aOldEntry == mLSHE)
   1:         mLSHE = aNewEntry;
   1: }
   1: 
   1: 
   1: struct SwapEntriesData
   1: {
   1:     nsDocShell *ignoreShell;     // constant; the shell to ignore
   1:     nsISHEntry *destTreeRoot;    // constant; the root of the dest tree
   1:     nsISHEntry *destTreeParent;  // constant; the node under destTreeRoot
   1:                                  // whose children will correspond to aEntry
   1: };
   1: 
   1: 
   1: nsresult
   1: nsDocShell::SetChildHistoryEntry(nsISHEntry *aEntry, nsDocShell *aShell,
   1:                                  PRInt32 aEntryIndex, void *aData)
   1: {
3233:     SwapEntriesData *data = static_cast<SwapEntriesData*>(aData);
   1:     nsDocShell *ignoreShell = data->ignoreShell;
   1: 
   1:     if (!aShell || aShell == ignoreShell)
   1:         return NS_OK;
   1: 
   1:     nsISHEntry *destTreeRoot = data->destTreeRoot;
   1: 
   1:     nsCOMPtr<nsISHEntry> destEntry;
   1:     nsCOMPtr<nsISHContainer> container =
   1:         do_QueryInterface(data->destTreeParent);
   1: 
   1:     if (container) {
   1:         // aEntry is a clone of some child of destTreeParent, but since the
   1:         // trees aren't necessarily in sync, we'll have to locate it.
   1:         // Note that we could set aShell's entry to null if we don't find a
   1:         // corresponding entry under destTreeParent.
   1: 
   1:         PRUint32 targetID, id;
   1:         aEntry->GetID(&targetID);
   1: 
   1:         // First look at the given index, since this is the common case.
   1:         nsCOMPtr<nsISHEntry> entry;
   1:         container->GetChildAt(aEntryIndex, getter_AddRefs(entry));
   1:         if (entry && NS_SUCCEEDED(entry->GetID(&id)) && id == targetID) {
   1:             destEntry.swap(entry);
   1:         } else {
   1:             PRInt32 childCount;
   1:             container->GetChildCount(&childCount);
   1:             for (PRInt32 i = 0; i < childCount; ++i) {
   1:                 container->GetChildAt(i, getter_AddRefs(entry));
   1:                 if (!entry)
   1:                     continue;
   1: 
   1:                 entry->GetID(&id);
   1:                 if (id == targetID) {
   1:                     destEntry.swap(entry);
   1:                     break;
   1:                 }
   1:             }
   1:         }
   1:     } else {
   1:         destEntry = destTreeRoot;
   1:     }
   1: 
   1:     aShell->SwapHistoryEntries(aEntry, destEntry);
   1: 
   1:     // Now handle the children of aEntry.
   1:     SwapEntriesData childData = { ignoreShell, destTreeRoot, destEntry };
   1:     return WalkHistoryEntries(aEntry, aShell,
   1:                               SetChildHistoryEntry, &childData);
   1: }
   1: 
   1: 
   1: static nsISHEntry*
   1: GetRootSHEntry(nsISHEntry *aEntry)
   1: {
   1:     nsCOMPtr<nsISHEntry> rootEntry = aEntry;
   1:     nsISHEntry *result = nsnull;
   1:     while (rootEntry) {
   1:         result = rootEntry;
   1:         result->GetParent(getter_AddRefs(rootEntry));
   1:     }
   1: 
   1:     return result;
   1: }
   1: 
   1: 
   1: void
   1: nsDocShell::SetHistoryEntry(nsCOMPtr<nsISHEntry> *aPtr, nsISHEntry *aEntry)
   1: {
   1:     // We need to sync up the docshell and session history trees for
   1:     // subframe navigation.  If the load was in a subframe, we forward up to
   1:     // the root docshell, which will then recursively sync up all docshells
   1:     // to their corresponding entries in the new session history tree.
   1:     // If we don't do this, then we can cache a content viewer on the wrong
   1:     // cloned entry, and subsequently restore it at the wrong time.
   1: 
   1:     nsISHEntry *newRootEntry = GetRootSHEntry(aEntry);
   1:     if (newRootEntry) {
   1:         // newRootEntry is now the new root entry.
   1:         // Find the old root entry as well.
   1: 
   1:         // Need a strong ref. on |oldRootEntry| so it isn't destroyed when
   1:         // SetChildHistoryEntry() does SwapHistoryEntries() (bug 304639).
   1:         nsCOMPtr<nsISHEntry> oldRootEntry = GetRootSHEntry(*aPtr);
   1:         if (oldRootEntry) {
   1:             nsCOMPtr<nsIDocShellTreeItem> parentAsItem;
   1:             GetSameTypeParent(getter_AddRefs(parentAsItem));
   1:             nsCOMPtr<nsIDocShell> rootShell = do_QueryInterface(parentAsItem);
   1:             if (rootShell) { // if we're the root just set it, nothing to swap
   1:                 SwapEntriesData data = { this, newRootEntry };
   1:                 nsIDocShell *rootIDocShell =
3233:                     static_cast<nsIDocShell*>(rootShell);
3233:                 nsDocShell *rootDocShell = static_cast<nsDocShell*>
3233:                                                       (rootIDocShell);
   1: 
   1: #ifdef NS_DEBUG
   1:                 nsresult rv =
   1: #endif
   1:                 SetChildHistoryEntry(oldRootEntry, rootDocShell,
   1:                                                    0, &data);
   1:                 NS_ASSERTION(NS_SUCCEEDED(rv), "SetChildHistoryEntry failed");
   1:             }
   1:         }
   1:     }
   1: 
   1:     *aPtr = aEntry;
   1: }
   1: 
   1: 
   1: nsresult
   1: nsDocShell::GetRootSessionHistory(nsISHistory ** aReturn)
   1: {
   1:     nsresult rv;
   1: 
   1:     nsCOMPtr<nsIDocShellTreeItem> root;
   1:     //Get the root docshell
   1:     rv = GetSameTypeRootTreeItem(getter_AddRefs(root));
   1:     // QI to nsIWebNavigation
   1:     nsCOMPtr<nsIWebNavigation> rootAsWebnav(do_QueryInterface(root));
   1:     if (rootAsWebnav) {
   1:         // Get the handle to SH from the root docshell
   1:         rv = rootAsWebnav->GetSessionHistory(aReturn);
   1:     }
   1:     return rv;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::GetHttpChannel(nsIChannel * aChannel, nsIHttpChannel ** aReturn)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aReturn);
   1:     if (!aChannel)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     nsCOMPtr<nsIMultiPartChannel>  multiPartChannel(do_QueryInterface(aChannel));
   1:     if (multiPartChannel) {
   1:         nsCOMPtr<nsIChannel> baseChannel;
   1:         multiPartChannel->GetBaseChannel(getter_AddRefs(baseChannel));
   1:         nsCOMPtr<nsIHttpChannel>  httpChannel(do_QueryInterface(baseChannel));
   1:         *aReturn = httpChannel;
   1:         NS_IF_ADDREF(*aReturn);
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: PRBool 
   1: nsDocShell::ShouldDiscardLayoutState(nsIHttpChannel * aChannel)
   1: {    
   1:     // By default layout State will be saved. 
   1:     if (!aChannel)
   1:         return PR_FALSE;
   1: 
   1:     // figure out if SH should be saving layout state 
   1:     nsCOMPtr<nsISupports> securityInfo;
   1:     PRBool noStore = PR_FALSE, noCache = PR_FALSE;
   1:     aChannel->GetSecurityInfo(getter_AddRefs(securityInfo));
   1:     aChannel->IsNoStoreResponse(&noStore);
   1:     aChannel->IsNoCacheResponse(&noCache);
   1: 
   1:     return (noStore || (noCache && securityInfo));
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell: nsIEditorDocShell
   1: //*****************************************************************************   
   1: 
   1: NS_IMETHODIMP nsDocShell::GetEditor(nsIEditor * *aEditor)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aEditor);
   1:   nsresult rv = EnsureEditorData();
   1:   if (NS_FAILED(rv)) return rv;
   1:   
   1:   return mEditorData->GetEditor(aEditor);
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::SetEditor(nsIEditor * aEditor)
   1: {
   1:   nsresult rv = EnsureEditorData();
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   return mEditorData->SetEditor(aEditor);
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsDocShell::GetEditable(PRBool *aEditable)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aEditable);
   1:   *aEditable = mEditorData && mEditorData->GetEditable();
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsDocShell::GetHasEditingSession(PRBool *aHasEditingSession)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aHasEditingSession);
   1:   
   1:   if (mEditorData)
   1:   {
   1:     nsCOMPtr<nsIEditingSession> editingSession;
   1:     mEditorData->GetEditingSession(getter_AddRefs(editingSession));
   1:     *aHasEditingSession = (editingSession.get() != nsnull);
   1:   }
   1:   else
   1:   {
   1:     *aHasEditingSession = PR_FALSE;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsDocShell::MakeEditable(PRBool inWaitForUriLoad)
   1: {
   1:   nsresult rv = EnsureEditorData();
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   return mEditorData->MakeEditable(inWaitForUriLoad);
   1: }
   1: 
   1: nsresult
   1: nsDocShell::AddToGlobalHistory(nsIURI * aURI, PRBool aRedirect,
   1:                                nsIChannel * aChannel)
   1: {
   1:     if (mItemType != typeContent || !mGlobalHistory)
   1:         return NS_OK;
   1: 
   1:     PRBool visited;
   1:     nsresult rv = mGlobalHistory->IsVisited(aURI, &visited);
   1:     if (NS_FAILED(rv))
   1:         return rv;
   1: 
   1:     nsCOMPtr<nsIURI> referrer;
8309:     if (aChannel)
8309:         NS_GetReferrerFromChannel(aChannel, getter_AddRefs(referrer));
   1: 
   1:     rv = mGlobalHistory->AddURI(aURI, aRedirect, !IsFrame(), referrer);
   1:     if (NS_FAILED(rv))
   1:         return rv;
   1: 
   1:     if (!visited) {
   1:         nsCOMPtr<nsIObserverService> obsService =
   1:             do_GetService("@mozilla.org/observer-service;1");
   1:         if (obsService) {
   1:             obsService->NotifyObservers(aURI, NS_LINK_VISITED_EVENT_TOPIC, nsnull);
   1:         }
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell: Helper Routines
   1: //*****************************************************************************
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetLoadType(PRUint32 aLoadType)
   1: {
   1:     mLoadType = aLoadType;
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetLoadType(PRUint32 * aLoadType)
   1: {
   1:     *aLoadType = mLoadType;
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::ConfirmRepost(PRBool * aRepost)
   1: {
   1:   nsresult rv;
   1:   nsCOMPtr<nsIPrompt> prompter;
3233:   CallGetInterface(this, static_cast<nsIPrompt**>(getter_AddRefs(prompter)));
   1: 
   1:   nsCOMPtr<nsIStringBundleService> 
   1:       stringBundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIStringBundle> appBundle;
   1:   rv = stringBundleService->CreateBundle(kAppstringsBundleURL,
   1:                                          getter_AddRefs(appBundle));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   nsCOMPtr<nsIStringBundle> brandBundle;
   1:   rv = stringBundleService->CreateBundle(kBrandBundleURL, getter_AddRefs(brandBundle));
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   NS_ASSERTION(prompter && brandBundle && appBundle,
   1:                "Unable to set up repost prompter.");
   1: 
   1:   nsXPIDLString brandName;
   1:   rv = brandBundle->GetStringFromName(NS_LITERAL_STRING("brandShortName").get(),
   1:                                       getter_Copies(brandName));
   1:   if (NS_FAILED(rv)) return rv;
   1:   const PRUnichar *formatStrings[] = { brandName.get() };
   1: 
   1:   nsXPIDLString msgString, button0Title;
   1:   rv = appBundle->FormatStringFromName(NS_LITERAL_STRING("confirmRepost").get(),
   1:                                         formatStrings, NS_ARRAY_LENGTH(formatStrings),
   1:                                         getter_Copies(msgString));
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   rv = appBundle->GetStringFromName(NS_LITERAL_STRING("resendButton.label").get(),
   1:                                     getter_Copies(button0Title));
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   PRInt32 buttonPressed;
   1:   rv = prompter->
   1:          ConfirmEx(nsnull, msgString.get(),
   1:                    (nsIPrompt::BUTTON_POS_0 * nsIPrompt::BUTTON_TITLE_IS_STRING) +
   1:                    (nsIPrompt::BUTTON_POS_1 * nsIPrompt::BUTTON_TITLE_CANCEL),
   1:                    button0Title.get(), nsnull, nsnull, nsnull, nsnull, &buttonPressed);
   1:   if (NS_FAILED(rv)) return rv;
   1: 
   1:   *aRepost = (buttonPressed == 0);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetPromptAndStringBundle(nsIPrompt ** aPrompt,
   1:                                      nsIStringBundle ** aStringBundle)
   1: {
   1:     NS_ENSURE_SUCCESS(GetInterface(NS_GET_IID(nsIPrompt), (void **) aPrompt),
   1:                       NS_ERROR_FAILURE);
   1: 
   1:     nsCOMPtr<nsIStringBundleService>
   1:         stringBundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID));
   1:     NS_ENSURE_TRUE(stringBundleService, NS_ERROR_FAILURE);
   1: 
   1:     NS_ENSURE_SUCCESS(stringBundleService->
   1:                       CreateBundle(kAppstringsBundleURL,
   1:                                    aStringBundle),
   1:                       NS_ERROR_FAILURE);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetChildOffset(nsIDOMNode * aChild, nsIDOMNode * aParent,
   1:                            PRInt32 * aOffset)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aChild || aParent);
   1: 
   1:     nsCOMPtr<nsIDOMNodeList> childNodes;
   1:     NS_ENSURE_SUCCESS(aParent->GetChildNodes(getter_AddRefs(childNodes)),
   1:                       NS_ERROR_FAILURE);
   1:     NS_ENSURE_TRUE(childNodes, NS_ERROR_FAILURE);
   1: 
   1:     PRInt32 i = 0;
   1: 
   1:     for (; PR_TRUE; i++) {
   1:         nsCOMPtr<nsIDOMNode> childNode;
   1:         NS_ENSURE_SUCCESS(childNodes->Item(i, getter_AddRefs(childNode)),
   1:                           NS_ERROR_FAILURE);
   1:         NS_ENSURE_TRUE(childNode, NS_ERROR_FAILURE);
   1: 
   1:         if (childNode.get() == aChild) {
   1:             *aOffset = i;
   1:             return NS_OK;
   1:         }
   1:     }
   1: 
   1:     return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetRootScrollableView(nsIScrollableView ** aOutScrollView)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aOutScrollView);
   1: 
   1:     nsCOMPtr<nsIPresShell> shell;
   1:     NS_ENSURE_SUCCESS(GetPresShell(getter_AddRefs(shell)), NS_ERROR_FAILURE);
   1:     NS_ENSURE_TRUE(shell, NS_ERROR_NULL_POINTER);
   1: 
   1:     NS_ENSURE_SUCCESS(shell->GetViewManager()->GetRootScrollableView(aOutScrollView),
   1:                       NS_ERROR_FAILURE);
   1: 
   1:     if (*aOutScrollView == nsnull) {
   1:         return NS_ERROR_FAILURE;
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::EnsureScriptEnvironment()
   1: {
   1:     if (mScriptGlobal)
   1:         return NS_OK;
   1: 
   1:     if (mIsBeingDestroyed) {
   1:         return NS_ERROR_NOT_AVAILABLE;
   1:     }
   1: 
7837: #ifdef DEBUG
7837:     NS_ASSERTION(!mInEnsureScriptEnv,
7837:                  "Infinite loop! Calling EnsureScriptEnvironment() from "
7837:                  "within EnsureScriptEnvironment()!");
7837: 
7837:     // Yeah, this isn't re-entrant safe, but that's ok since if we
7837:     // re-enter this method, we'll infinitely loop...
7837:     mInEnsureScriptEnv = PR_TRUE;
7837: #endif
7837: 
   1:     nsCOMPtr<nsIDOMScriptObjectFactory> factory =
   1:         do_GetService(kDOMScriptObjectFactoryCID);
   1:     NS_ENSURE_TRUE(factory, NS_ERROR_FAILURE);
   1: 
4422:     nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(mTreeOwner));
4422:     NS_ENSURE_TRUE(browserChrome, NS_ERROR_NOT_AVAILABLE);
4422: 
4422:     PRUint32 chromeFlags;
4422:     browserChrome->GetChromeFlags(&chromeFlags);
4422: 
4422:     PRBool isModalContentWindow =
4422:         (chromeFlags & nsIWebBrowserChrome::CHROME_MODAL) &&
4422:         !(chromeFlags & nsIWebBrowserChrome::CHROME_OPENAS_CHROME);
4422: 
4422:     // If our window is modal and we're not opened as chrome, make
4422:     // this window a modal content window.
   1:     factory->NewScriptGlobalObject(mItemType == typeChrome,
4422:                                    isModalContentWindow,
   1:                                    getter_AddRefs(mScriptGlobal));
   1:     NS_ENSURE_TRUE(mScriptGlobal, NS_ERROR_FAILURE);
   1: 
   1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(mScriptGlobal));
3233:     win->SetDocShell(static_cast<nsIDocShell *>(this));
   1: 
   1:     // Ensure the script object is set to run javascript - other languages
   1:     // setup on demand.
   1:     // XXXmarkh - should this be setup to run the default language for this doc?
   1:     nsresult rv;
   1:     rv = mScriptGlobal->EnsureScriptEnvironment(nsIProgrammingLanguage::JAVASCRIPT);
   1:     NS_ENSURE_SUCCESS(rv, rv);
7837: 
7837: #ifdef DEBUG
7837:     mInEnsureScriptEnv = PR_FALSE;
7837: #endif
7837: 
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::EnsureEditorData()
   1: {
   1:     if (!mEditorData && !mIsBeingDestroyed)
   1:     {
   1:         mEditorData = new nsDocShellEditorData(this);
   1:         if (!mEditorData) return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1: 
   1:     return mEditorData ? NS_OK : NS_ERROR_NOT_AVAILABLE;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::EnsureTransferableHookData()
   1: {
   1:     if (!mTransferableHookData) {
   1:         mTransferableHookData = new nsTransferableHookData();
   1:         if (!mTransferableHookData) return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsDocShell::EnsureFind()
   1: {
   1:     nsresult rv;
   1:     if (!mFind)
   1:     {
   1:         mFind = do_CreateInstance("@mozilla.org/embedcomp/find;1", &rv);
   1:         if (NS_FAILED(rv)) return rv;
   1:     }
   1:     
   1:     // we promise that the nsIWebBrowserFind that we return has been set
   1:     // up to point to the focused, or content window, so we have to
   1:     // set that up each time.
   1: 
   1:     nsIScriptGlobalObject* scriptGO = GetScriptGlobalObject();
   1:     NS_ENSURE_TRUE(scriptGO, NS_ERROR_UNEXPECTED);
   1: 
   1:     // default to our window
   1:     nsCOMPtr<nsIDOMWindow> rootWindow = do_QueryInterface(scriptGO);
   1:     nsCOMPtr<nsIDOMWindow> windowToSearch = rootWindow;
   1: 
   1:     // if we can, search the focused window
   1:     nsCOMPtr<nsPIDOMWindow> ourWindow = do_QueryInterface(scriptGO);
   1:     nsIFocusController *focusController = nsnull;
   1:     if (ourWindow)
   1:         focusController = ourWindow->GetRootFocusController();
   1:     if (focusController)
   1:     {
   1:         nsCOMPtr<nsIDOMWindowInternal> focusedWindow;
   1:         focusController->GetFocusedWindow(getter_AddRefs(focusedWindow));
   1:         if (focusedWindow)
   1:             windowToSearch = focusedWindow;
   1:     }
   1: 
   1:     nsCOMPtr<nsIWebBrowserFindInFrames> findInFrames = do_QueryInterface(mFind);
   1:     if (!findInFrames) return NS_ERROR_NO_INTERFACE;
   1:     
   1:     rv = findInFrames->SetRootSearchFrame(rootWindow);
   1:     if (NS_FAILED(rv)) return rv;
   1:     rv = findInFrames->SetCurrentSearchFrame(windowToSearch);
   1:     if (NS_FAILED(rv)) return rv;
   1:     
   1:     return NS_OK;
   1: }
   1: 
   1: PRBool
   1: nsDocShell::IsFrame()
   1: {
   1:     nsCOMPtr<nsIDocShellTreeItem> parent =
   1:         do_QueryInterface(GetAsSupports(mParent));
   1:     if (parent) {
   1:         PRInt32 parentType = ~mItemType;        // Not us
   1:         parent->GetItemType(&parentType);
   1:         if (parentType == mItemType)    // This is a frame
   1:             return PR_TRUE;
   1:     }
   1: 
   1:     return PR_FALSE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetHasFocus(PRBool *aHasFocus)
   1: {
   1:   *aHasFocus = mHasFocus;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetHasFocus(PRBool aHasFocus)
   1: {
   1: #ifdef DEBUG_DOCSHELL_FOCUS
  58:     printf(">>>>>>>>>> nsDocShell::SetHasFocus: %p  %s\n", (void*)this,
  58:            aHasFocus?"Yes":"No");
   1: #endif
   1: 
   1:   mHasFocus = aHasFocus;
   1: 
   1:   nsDocShellFocusController* dsfc = nsDocShellFocusController::GetInstance();
   1:   if (dsfc && aHasFocus) {
   1:     dsfc->Focus(this);
   1:   }
   1: 
   1:   if (!aHasFocus) {
   1:       // We may be in a situation where the focus outline was shown
   1:       // on this document because the user tabbed into it, but the focus
   1:       // is now switching to another document via a click.  In this case,
   1:       // we need to make sure the focus outline is removed from this document.
   1:       SetCanvasHasFocus(PR_FALSE);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // Find an nsICanvasFrame under aFrame.  Only search the principal
   1: // child lists.  aFrame must be non-null.
   1: static nsICanvasFrame* FindCanvasFrame(nsIFrame* aFrame)
   1: {
   1:     nsICanvasFrame* canvasFrame;
   1:     if (NS_SUCCEEDED(CallQueryInterface(aFrame, &canvasFrame))) {
   1:         return canvasFrame;
   1:     }
   1: 
   1:     nsIFrame* kid = aFrame->GetFirstChild(nsnull);
   1:     while (kid) {
   1:         canvasFrame = FindCanvasFrame(kid);
   1:         if (canvasFrame) {
   1:             return canvasFrame;
   1:         }
   1:         kid = kid->GetNextSibling();
   1:     }
   1: 
   1:     return nsnull;
   1: }
   1: 
   1: //-------------------------------------------------------
   1: // Tells the HTMLFrame/CanvasFrame that is now has focus
   1: NS_IMETHODIMP
   1: nsDocShell::SetCanvasHasFocus(PRBool aCanvasHasFocus)
   1: {
   1:   if (mEditorData && mEditorData->GetEditable())
   1:     return NS_ERROR_NOT_AVAILABLE;
   1: 
   1:   nsCOMPtr<nsIPresShell> presShell;
   1:   GetPresShell(getter_AddRefs(presShell));
   1:   if (!presShell) return NS_ERROR_FAILURE;
   1: 
   1:   nsIDocument *doc = presShell->GetDocument();
   1:   if (!doc) return NS_ERROR_FAILURE;
   1: 
   1:   nsIContent *rootContent = doc->GetRootContent();
   1:   if (rootContent) {
   1:       nsIFrame* frame = presShell->GetPrimaryFrameFor(rootContent);
   1:       if (frame) {
   1:           frame = frame->GetParent();
   1:           if (frame) {
   1:               nsICanvasFrame* canvasFrame;
   1:               if (NS_SUCCEEDED(CallQueryInterface(frame, &canvasFrame))) {
   1:                   return canvasFrame->SetHasFocus(aCanvasHasFocus);
   1:               }
   1:           }
   1:       }
   1:   } else {
   1:       // Look for the frame the hard way
   1:       nsIFrame* frame = presShell->GetRootFrame();
   1:       if (frame) {
   1:           nsICanvasFrame* canvasFrame = FindCanvasFrame(frame);
   1:           if (canvasFrame) {
   1:               return canvasFrame->SetHasFocus(aCanvasHasFocus);
   1:           }
   1:       }      
   1:   }
   1:   
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetCanvasHasFocus(PRBool *aCanvasHasFocus)
   1: {
   1:   return NS_ERROR_FAILURE;
   1: }
   1: 
   1: /* boolean IsBeingDestroyed (); */
   1: NS_IMETHODIMP 
   1: nsDocShell::IsBeingDestroyed(PRBool *aDoomed)
   1: {
   1:   NS_ENSURE_ARG(aDoomed);
   1:   *aDoomed = mIsBeingDestroyed;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP 
   1: nsDocShell::GetIsExecutingOnLoadHandler(PRBool *aResult)
   1: {
   1:   NS_ENSURE_ARG(aResult);
   1:   *aResult = mIsExecutingOnLoadHandler;
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetLayoutHistoryState(nsILayoutHistoryState **aLayoutHistoryState)
   1: {
   1:   if (mOSHE)
   1:     mOSHE->GetLayoutHistoryState(aLayoutHistoryState);
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::SetLayoutHistoryState(nsILayoutHistoryState *aLayoutHistoryState)
   1: {
   1:   if (mOSHE)
   1:     mOSHE->SetLayoutHistoryState(aLayoutHistoryState);
   1:   return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: //***    nsRefreshTimer: Object Management
   1: //*****************************************************************************
   1: 
   1: nsRefreshTimer::nsRefreshTimer()
   1:     : mDelay(0), mRepeat(PR_FALSE), mMetaRefresh(PR_FALSE)
   1: {
   1: }
   1: 
   1: nsRefreshTimer::~nsRefreshTimer()
   1: {
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsRefreshTimer::nsISupports
   1: //*****************************************************************************   
   1: 
   1: NS_IMPL_THREADSAFE_ADDREF(nsRefreshTimer)
   1: NS_IMPL_THREADSAFE_RELEASE(nsRefreshTimer)
   1: 
   1: NS_INTERFACE_MAP_BEGIN(nsRefreshTimer)
   1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsITimerCallback)
   1:     NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
   1: NS_INTERFACE_MAP_END_THREADSAFE
   1: 
   1: ///*****************************************************************************
   1: // nsRefreshTimer::nsITimerCallback
   1: //******************************************************************************
   1: NS_IMETHODIMP
   1: nsRefreshTimer::Notify(nsITimer * aTimer)
   1: {
   1:     NS_ASSERTION(mDocShell, "DocShell is somehow null");
   1: 
   1:     if (mDocShell && aTimer) {
   1:         // Get the delay count to determine load type
   1:         PRUint32 delay = 0;
   1:         aTimer->GetDelay(&delay);
   1:         nsCOMPtr<nsIRefreshURI> refreshURI = do_QueryInterface(mDocShell);
   1:         if (refreshURI)
   1:             refreshURI->ForceRefreshURI(mURI, delay, mMetaRefresh);
   1:     }
   1:     return NS_OK;
   1: }
   1: 
   1: //*****************************************************************************
   1: //***    nsDocShellFocusController: Object Management
   1: //*****************************************************************************
   1: void 
   1: nsDocShellFocusController::Focus(nsIDocShell* aDocShell)
   1: {
   1: #ifdef DEBUG_DOCSHELL_FOCUS
  58:   printf("****** nsDocShellFocusController Focus To: %p  Blur To: %p\n",
  58:          (void*)aDocShell, (void*)mFocusedDocShell);
   1: #endif
   1: 
   1:   if (aDocShell != mFocusedDocShell) {
   1:     if (mFocusedDocShell) {
   1:       mFocusedDocShell->SetHasFocus(PR_FALSE);
   1:     }
   1:     mFocusedDocShell = aDocShell;
   1:   }
   1: 
   1: }
   1: 
   1: //--------------------------------------------------
   1: // This is need for when the document with focus goes away
   1: void 
   1: nsDocShellFocusController::ClosingDown(nsIDocShell* aDocShell)
   1: {
   1:   if (aDocShell == mFocusedDocShell) {
   1:     mFocusedDocShell = nsnull;
   1:   }
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::InterfaceRequestorProxy
   1: //*****************************************************************************
   1: nsDocShell::InterfaceRequestorProxy::InterfaceRequestorProxy(nsIInterfaceRequestor* p)
   1: {
   1:     if (p) {
   1:         mWeakPtr = do_GetWeakReference(p);
   1:     }
   1: }
   1:  
   1: nsDocShell::InterfaceRequestorProxy::~InterfaceRequestorProxy()
   1: {
   1:     mWeakPtr = nsnull;
   1: }
   1: 
   1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsDocShell::InterfaceRequestorProxy, nsIInterfaceRequestor) 
   1:   
   1: NS_IMETHODIMP 
   1: nsDocShell::InterfaceRequestorProxy::GetInterface(const nsIID & aIID, void **aSink)
   1: {
   1:     NS_ENSURE_ARG_POINTER(aSink);
   1:     nsCOMPtr<nsIInterfaceRequestor> ifReq = do_QueryReferent(mWeakPtr);
   1:     if (ifReq) {
   1:         return ifReq->GetInterface(aIID, aSink);
   1:     }
   1:     *aSink = nsnull;
   1:     return NS_NOINTERFACE;
   1: }
   1: 
   1: nsresult
   1: nsDocShell::SetBaseUrlForWyciwyg(nsIContentViewer * aContentViewer)
   1: {
   1:     if (!aContentViewer)
   1:         return NS_ERROR_FAILURE;
   1: 
   1:     nsCOMPtr<nsIURI> baseURI;
   1:     nsCOMPtr<nsIDocument> document;
   1:     nsresult rv = NS_ERROR_NOT_AVAILABLE;
   1: 
   1:     if (sURIFixup)
   1:         rv = sURIFixup->CreateExposableURI(mCurrentURI,
   1:                                            getter_AddRefs(baseURI));
   1: 
   1:     // Get the current document and set the base uri
   1:     if (baseURI) {
   1:         nsCOMPtr<nsIDocumentViewer> docViewer(do_QueryInterface(aContentViewer));
   1:         if (docViewer) {
   1:             rv = docViewer->GetDocument(getter_AddRefs(document));
   1:             if (document)
   1:                 rv = document->SetBaseURI(baseURI);
   1:         }
   1:     }
   1:     return rv;
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIAuthPromptProvider
   1: //*****************************************************************************
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::GetAuthPrompt(PRUint32 aPromptReason, const nsIID& iid,
   1:                           void** aResult)
   1: {
   1:     // a priority prompt request will override a false mAllowAuth setting
   1:     PRBool priorityPrompt = (aPromptReason == PROMPT_PROXY);
   1: 
   1:     if (!mAllowAuth && !priorityPrompt)
   1:         return NS_ERROR_NOT_AVAILABLE;
   1: 
   1:     // we're either allowing auth, or it's a proxy request
   1:     nsresult rv;
   1:     nsCOMPtr<nsIPromptFactory> wwatch =
   1:       do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     rv = EnsureScriptEnvironment();
   1:     NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:     nsCOMPtr<nsIDOMWindow> window(do_QueryInterface(mScriptGlobal));
   1: 
   1:     // Get the an auth prompter for our window so that the parenting
   1:     // of the dialogs works as it should when using tabs.
   1: 
   1:     return wwatch->GetPrompt(window, iid,
3233:                              reinterpret_cast<void**>(aResult));
   1: }
   1: 
   1: //*****************************************************************************
   1: // nsDocShell::nsIObserver
   1: //*****************************************************************************
   1: 
   1: NS_IMETHODIMP
   1: nsDocShell::Observe(nsISupports *aSubject, const char *aTopic,
   1:                     const PRUnichar *aData)
   1: {
   1:     nsresult rv = NS_OK;
   1:     if (mObserveErrorPages &&
   1:         !nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) &&
   1:         !nsCRT::strcmp(aData,
   1:           NS_LITERAL_STRING("browser.xul.error_pages.enabled").get())) {
   1: 
   1:         nsCOMPtr<nsIPrefBranch> prefs(do_QueryInterface(aSubject, &rv));
   1:         NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:         PRBool tmpbool;
   1:         rv = prefs->GetBoolPref("browser.xul.error_pages.enabled", &tmpbool);
   1:         if (NS_SUCCEEDED(rv))
   1:             mUseErrorPages = tmpbool;
   1: 
   1:     } else {
   1:         rv = NS_ERROR_UNEXPECTED;
   1:     }
   1:     return rv;
   1: }
   1: 
   1: /* static */
   1: nsresult
   1: nsDocShell::URIInheritsSecurityContext(nsIURI* aURI, PRBool* aResult)
   1: {
   1:     // Note: about:blank URIs do NOT inherit the security context from the
   1:     // current document, which is what this function tests for...
   1:     return NS_URIChainHasFlags(aURI,
   1:                                nsIProtocolHandler::URI_INHERITS_SECURITY_CONTEXT,
   1:                                aResult);
   1: }
   1: 
   1: /* static */
   1: PRBool
   1: nsDocShell::IsAboutBlank(nsIURI* aURI)
   1: {
   1:     NS_PRECONDITION(aURI, "Must have URI");
   1:     
   1:     // GetSpec can be expensive for some URIs, so check the scheme first.
   1:     PRBool isAbout = PR_FALSE;
   1:     if (NS_FAILED(aURI->SchemeIs("about", &isAbout)) || !isAbout) {
   1:         return PR_FALSE;
   1:     }
   1:     
   1:     nsCAutoString str;
   1:     aURI->GetSpec(str);
   1:     return str.EqualsLiteral("about:blank");
   1: }
   1: 
5528: //*****************************************************************************
5528: // nsClassifierCallback
5528: //*****************************************************************************
5528: 
5528: NS_IMPL_THREADSAFE_ISUPPORTS2(nsClassifierCallback,
5528:                               nsIURIClassifierCallback,
5528:                               nsIRunnable)
5528: 
5528: NS_IMETHODIMP
5528: nsClassifierCallback::Run()
5528: {
5528:     if (!mChannel) {
5528:         return NS_OK;
5528:     }
5528: 
5528:     NS_ASSERTION(!mSuspendedChannel,
5528:                  "nsClassifierCallback::Run() called while a "
5528:                  "channel is still suspended.");
5528: 
5528:     nsCOMPtr<nsIChannel> channel;
5528:     channel.swap(mChannel);
5528: 
5528:     // Don't bother to run the classifier on a load that has already failed.
5528:     // (this might happen after a redirect)
5528:     PRUint32 status;
5528:     channel->GetStatus(&status);
5528:     if (NS_FAILED(status))
5528:         return NS_OK;
5528: 
5528:     // Don't bother to run the classifier on a load that's coming from the
5528:     // cache and doesn't need validaton.
5528:     nsCOMPtr<nsICachingChannel> cachingChannel = do_QueryInterface(channel);
5528:     if (cachingChannel) {
5528:         PRBool fromCache;
5528:         if (NS_SUCCEEDED(cachingChannel->IsFromCache(&fromCache)) &&
5528:             fromCache) {
5528:             return NS_OK;
5528:         }
5528:     }
5528: 
5528:     nsCOMPtr<nsIURI> uri;
5528:     nsresult rv = channel->GetURI(getter_AddRefs(uri));
5528:     NS_ENSURE_SUCCESS(rv, rv);
5528: 
8380:     // Don't bother checking certain types of URIs.
8380:     PRBool hasFlags;
8380:     rv = NS_URIChainHasFlags(uri,
8380:                              nsIProtocolHandler::URI_DANGEROUS_TO_LOAD,
8380:                              &hasFlags);
8380:     NS_ENSURE_SUCCESS(rv, rv);
8380:     if (hasFlags) return NS_OK;
8380: 
8380:     rv = NS_URIChainHasFlags(uri,
8380:                              nsIProtocolHandler::URI_IS_LOCAL_FILE,
8380:                              &hasFlags);
8380:     NS_ENSURE_SUCCESS(rv, rv);
8380:     if (hasFlags) return NS_OK;
8380: 
8380:     rv = NS_URIChainHasFlags(uri,
8380:                              nsIProtocolHandler::URI_IS_UI_RESOURCE,
8380:                              &hasFlags);
8380:     NS_ENSURE_SUCCESS(rv, rv);
8380:     if (hasFlags) return NS_OK;
5528: 
5528:     nsCOMPtr<nsIURIClassifier> uriClassifier =
5528:         do_GetService(NS_URICLASSIFIERSERVICE_CONTRACTID, &rv);
5528:     if (NS_FAILED(rv)) return rv;
5528: 
5528:     PRBool expectCallback;
5528:     rv = uriClassifier->Classify(uri, this, &expectCallback);
5528:     if (NS_FAILED(rv)) return rv;
5528: 
5528:     if (expectCallback) {
5528:         // Suspend the channel, it will be resumed when we get the classifier
5528:         // callback.
5528:         rv = channel->Suspend();
8380:         if (NS_FAILED(rv)) {
8380:             // Some channels (including nsJSChannel) fail on Suspend.  This
8380:             // shouldn't be fatal, but will prevent malware from being
8380:             // blocked on these channels.
8380:             return NS_OK;
8380:         }
8380: 
5528:         mSuspendedChannel = channel;
5530: #ifdef DEBUG
5528:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
5528:                ("nsClassifierCallback[%p]: suspended channel %p",
5528:                 this, mSuspendedChannel.get()));
5529: #endif
5528:     }
5528: 
5528:     return NS_OK;
5528: }
5528: 
5528: NS_IMETHODIMP
5528: nsClassifierCallback::OnClassifyComplete(nsresult aErrorCode)
5528: {
5528:     if (mSuspendedChannel) {
5528:         if (NS_FAILED(aErrorCode)) {
5530: #ifdef DEBUG
5528:             PR_LOG(gDocShellLog, PR_LOG_DEBUG,
5528:                    ("nsClassifierCallback[%p]: cancelling channel %p with error code: %d",
5528:                     this, mSuspendedChannel.get(), aErrorCode));
5530: #endif
5528:             mSuspendedChannel->Cancel(aErrorCode);
5530:         }
5530: #ifdef DEBUG
5528:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
5528:                ("nsClassifierCallback[%p]: resuming channel %p from OnClassifyComplete",
5528:                 this, mSuspendedChannel.get()));
5529: #endif
5528:         mSuspendedChannel->Resume();
5528:         mSuspendedChannel = nsnull;
5528:     }
5528: 
5528:     return NS_OK;
5528: }
5528: 
5528: void
5528: nsClassifierCallback::Cancel()
5528: {
5528:     if (mSuspendedChannel) {
5530: #ifdef DEBUG
5528:         PR_LOG(gDocShellLog, PR_LOG_DEBUG,
5528:                ("nsClassifierCallback[%p]: resuming channel %p from Cancel()",
5528:                 this, mSuspendedChannel.get()));
5529: #endif
5528:         mSuspendedChannel->Resume();
5528:         mSuspendedChannel = nsnull;
5528:     }
5528: 
5528:     if (mChannel) {
5528:         mChannel = nsnull;
5528:     }
5528: }
