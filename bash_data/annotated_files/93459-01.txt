35729: // Copyright (c) 2006-2008 The Chromium Authors. All rights reserved.
35729: // Use of this source code is governed by a BSD-style license that can be
35729: // found in the LICENSE file.
35729: 
35729: #ifndef BASE_LOGGING_H_
35729: #define BASE_LOGGING_H_
35729: 
35729: #include <string>
35729: #include <cstring>
35729: 
35729: #include "base/basictypes.h"
36053: #include "prlog.h"
36053: 
36053: // Replace the Chromium logging code with NSPR-based logging code and
36053: // some C++ wrappers to emulate std::ostream
36053: 
36061: namespace mozilla {
36053: 
36061: enum LogSeverity {
36061:   LOG_INFO,
36061:   LOG_WARNING,
36061:   LOG_ERROR,
36061:   LOG_ERROR_REPORT,
36061:   LOG_FATAL,
36061:   LOG_0 = LOG_ERROR
36061: };
36061: 
36061: class Logger
36053: {
36053: public:
36061:   Logger(LogSeverity severity, const char* file, int line)
36061:     : mSeverity(severity)
36061:     , mFile(file)
36061:     , mLine(line)
36053:     , mMsg(NULL)
36053:   { }
36060: 
36061:   ~Logger();
36053: 
36053:   // not private so that the operator<< overloads can get to it
36061:   void printf(const char* fmt, ...);
36053: 
36053: private:
36053:   static PRLogModuleInfo* gChromiumPRLog;
36057:   static PRLogModuleInfo* GetLog();
36053: 
36061:   LogSeverity mSeverity;
36061:   const char* mFile;
36061:   int mLine;
36061:   char* mMsg;
36053: 
36061:   DISALLOW_EVIL_CONSTRUCTORS(Logger);
36061: };
36061: 
36061: class LogWrapper
36061: {
36061: public:
36061:   LogWrapper(LogSeverity severity, const char* file, int line) :
36061:     log(severity, file, line) { }
36061: 
36061:   operator Logger&() const { return log; }
36061: 
36061: private:
36061:   mutable Logger log;
36061: 
36061:   DISALLOW_EVIL_CONSTRUCTORS(LogWrapper);
36053: };
36053: 
36053: struct EmptyLog
36053: {
36053: };
36053: 
36061: } // namespace mozilla
36061: 
36061: mozilla::Logger& operator<<(mozilla::Logger& log, const char* s);
36061: mozilla::Logger& operator<<(mozilla::Logger& log, const std::string& s);
36061: mozilla::Logger& operator<<(mozilla::Logger& log, int i);
36061: mozilla::Logger& operator<<(mozilla::Logger& log, const std::wstring& s);
36061: mozilla::Logger& operator<<(mozilla::Logger& log, void* p);
36061: 
36053: template<class T>
36061: const mozilla::EmptyLog& operator <<(const mozilla::EmptyLog& log, const T&)
36061: {
36061:   return log;
36061: }
36053: 
36061: #define LOG(info) mozilla::LogWrapper(mozilla::LOG_ ## info, __FILE__, __LINE__)
36061: #define LOG_IF(info, condition) \
36062:   if (!(condition)) mozilla::LogWrapper(mozilla::LOG_ ## info, __FILE__, __LINE__)
36053: 
36061: #ifdef DEBUG
36061: #define DLOG(info) LOG(info)
36061: #define DLOG_IF(info) LOG_IF(info)
36061: #define DCHECK(condition) CHECK(condition)
36061: #else
36061: #define DLOG(info) mozilla::EmptyLog()
36061: #define DLOG_IF(info, condition) mozilla::EmptyLog()
36061: #define DCHECK(condition) while (false && (condition)) mozilla::EmptyLog()
36061: #endif
36053: 
93114: #define LOG_ASSERT(cond) CHECK(0)
93114: #define DLOG_ASSERT(cond) DCHECK(0)
36053: 
36053: #define NOTREACHED() LOG(ERROR)
36053: #define NOTIMPLEMENTED() LOG(ERROR)
36053: 
36062: #define CHECK(condition) LOG_IF(FATAL, condition)
36062: 
36053: #define DCHECK_EQ(v1, v2) DCHECK((v1) == (v2))
36053: #define DCHECK_NE(v1, v2) DCHECK((v1) != (v2))
36053: #define DCHECK_LE(v1, v2) DCHECK((v1) <= (v2))
36053: #define DCHECK_LT(v1, v2) DCHECK((v1) < (v2))
36053: #define DCHECK_GE(v1, v2) DCHECK((v1) >= (v2))
36053: #define DCHECK_GT(v1, v2) DCHECK((v1) > (v2))
36053: 
35729: #endif  // BASE_LOGGING_H_
