 35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 35740:  * vim: sw=4 ts=4 et :
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 35740: 
103111: #ifdef MOZ_WIDGET_GTK
 39263: #include <glib.h>
 48383: #elif XP_MACOSX
 71284: #include "PluginInterposeOSX.h"
 48383: #include "PluginUtilsOSX.h"
 39263: #endif
 43456: #ifdef MOZ_WIDGET_QT
 43456: #include <QtCore/QCoreApplication>
 43456: #include <QtCore/QEventLoop>
105637: #include "NestedLoopTimer.h"
 43456: #endif
 39263: 
 38121: #include "base/process_util.h"
 38121: 
 70842: #include "mozilla/Preferences.h"
 41382: #include "mozilla/unused.h"
 38121: #include "mozilla/ipc/SyncChannel.h"
 35893: #include "mozilla/plugins/PluginModuleParent.h"
 35895: #include "mozilla/plugins/BrowserStreamParent.h"
 79569: #include "mozilla/dom/PCrashReporterParent.h"
 39742: #include "PluginIdentifierParent.h"
 35746: 
 49311: #include "nsAutoPtr.h"
 37384: #include "nsCRT.h"
 35913: #include "nsNPAPIPlugin.h"
101111: #include "nsIFile.h"
107142: #include "nsPrintfCString.h"
107142: 
107142: #include "prsystem.h"
 35913: 
 72466: #ifdef XP_WIN
 72466: #include "mozilla/widget/AudioSession.h"
 72466: #endif
 88104: #include "sampler.h"
 72466: 
 38121: using base::KillProcess;
 38121: 
 36010: using mozilla::PluginLibrary;
 38121: using mozilla::ipc::SyncChannel;
 79569: using mozilla::dom::PCrashReporterParent;
 79569: using mozilla::dom::CrashReporterParent;
 35913: 
 70842: using namespace mozilla;
 35913: using namespace mozilla::plugins;
 72341: using namespace mozilla::plugins::parent;
 35913: 
104355: #ifdef MOZ_CRASHREPORTER
104355: #include "mozilla/dom/CrashReporterParent.h"
104355: 
104355: using namespace CrashReporter;
104355: #endif
104355: 
 76704: static const char kChildTimeoutPref[] = "dom.ipc.plugins.timeoutSecs";
 76704: static const char kParentTimeoutPref[] = "dom.ipc.plugins.parentTimeoutSecs";
 49311: static const char kLaunchTimeoutPref[] = "dom.ipc.plugins.processLaunchTimeoutSecs";
 38121: 
 38121: template<>
 38121: struct RunnableMethodTraits<mozilla::plugins::PluginModuleParent>
 38121: {
 38121:     typedef mozilla::plugins::PluginModuleParent Class;
 38121:     static void RetainCallee(Class* obj) { }
 38121:     static void ReleaseCallee(Class* obj) { }
 38121: };
 38121: 
 36063: // static
 36010: PluginLibrary*
 64609: PluginModuleParent::LoadModule(const char* aFilePath)
 35740: {
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35740: 
108991:     int32_t prefSecs = Preferences::GetInt(kLaunchTimeoutPref, 0);
 49311: 
 35740:     // Block on the child process being launched and initialized.
 49311:     nsAutoPtr<PluginModuleParent> parent(new PluginModuleParent(aFilePath));
 49311:     bool launched = parent->mSubprocess->Launch(prefSecs * 1000);
 49311:     if (!launched) {
 49311:         // Need to set this so the destructor doesn't complain.
 49311:         parent->mShutdown = true;
106838:         return nullptr;
 49311:     }
 36063:     parent->Open(parent->mSubprocess->GetChannel(),
 36063:                  parent->mSubprocess->GetChildProcessHandle());
 35740: 
 76704:     TimeoutChanged(kChildTimeoutPref, parent);
 79569: 
 79569: #ifdef MOZ_CRASHREPORTER
 80609:     // If this fails, we're having IPC troubles, and we're doomed anyways.
 80609:     if (!CrashReporterParent::CreateCrashReporter(parent.get())) {
 80609:         parent->mShutdown = true;
106838:         return nullptr;
 80609:     }
 79569: #endif
 79569: 
 49311:     return parent.forget();
 35740: }
 35740: 
 35740: 
 64609: PluginModuleParent::PluginModuleParent(const char* aFilePath)
 64609:     : mSubprocess(new PluginProcessParent(aFilePath))
 36145:     , mShutdown(false)
 62174:     , mClearSiteDataSupported(false)
 62174:     , mGetSitesWithDataSupported(false)
 36145:     , mNPNIface(NULL)
 36304:     , mPlugin(NULL)
 39793:     , mTaskFactory(this)
107142: #ifdef XP_WIN
108923:     , mPluginCpuUsageOnHang()
107142: #endif
103452: #ifdef MOZ_CRASHREPORTER_INJECTOR
103452:     , mFlashProcess1(0)
103452:     , mFlashProcess2(0)
103452: #endif
 35740: {
 36063:     NS_ASSERTION(mSubprocess, "Out of memory!");
 36063: 
 98908:     mIdentifiers.Init();
 38121: 
 76704:     Preferences::RegisterCallback(TimeoutChanged, kChildTimeoutPref, this);
 76704:     Preferences::RegisterCallback(TimeoutChanged, kParentTimeoutPref, this);
 35740: }
 35740: 
 35893: PluginModuleParent::~PluginModuleParent()
 35740: {
 39312:     NS_ASSERTION(OkToCleanup(), "unsafe destruction");
 39312: 
 36145:     if (!mShutdown) {
 36145:         NS_WARNING("Plugin host deleted the module without shutting down.");
 36145:         NPError err;
 36145:         NP_Shutdown(&err);
 36145:     }
 36145:     NS_ASSERTION(mShutdown, "NP_Shutdown didn't");
 36145: 
 36063:     if (mSubprocess) {
 36063:         mSubprocess->Delete();
106838:         mSubprocess = nullptr;
 36063:     }
 38121: 
103452: #ifdef MOZ_CRASHREPORTER_INJECTOR
103452:     if (mFlashProcess1)
104355:         UnregisterInjectorCallback(mFlashProcess1);
103452:     if (mFlashProcess2)
104355:         UnregisterInjectorCallback(mFlashProcess2);
103452: #endif
103452: 
 76704:     Preferences::UnregisterCallback(TimeoutChanged, kChildTimeoutPref, this);
 76704:     Preferences::UnregisterCallback(TimeoutChanged, kParentTimeoutPref, this);
 35740: }
 35740: 
 39793: #ifdef MOZ_CRASHREPORTER
 36145: void
104355: PluginModuleParent::WriteExtraDataForMinidump(AnnotationTable& notes)
 37384: {
 39793:     typedef nsDependentCString CS;
 37384: 
 37384:     // Get the plugin filename, try to get just the file leafname
 37384:     const std::string& pluginFile = mSubprocess->GetPluginFilePath();
 37384:     size_t filePos = pluginFile.rfind(FILE_PATH_SEPARATOR);
 37384:     if (filePos == std::string::npos)
 37384:         filePos = 0;
 37384:     else
 37384:         filePos++;
 39793:     notes.Put(CS("PluginFilename"), CS(pluginFile.substr(filePos).c_str()));
 39793: 
 37384:     //TODO: add plugin name and version: bug 539841
 37384:     // (as PluginName, PluginVersion)
 39793:     notes.Put(CS("PluginName"), CS(""));
 39793:     notes.Put(CS("PluginVersion"), CS(""));
 38688: 
103452:     CrashReporterParent* crashReporter = CrashReporter();
103452:     if (crashReporter) {
107142: #ifdef XP_WIN
108923:         if (mPluginCpuUsageOnHang.Length() > 0) {
108923:             notes.Put(CS("NumberOfProcessors"),
108923:                       nsPrintfCString("%d", PR_GetNumberOfProcessors()));
108923: 
108922:             nsCString cpuUsageStr;
108923:             cpuUsageStr.AppendFloat(std::ceil(mPluginCpuUsageOnHang[0] * 100) / 100);
108922:             notes.Put(CS("PluginCpuUsage"), cpuUsageStr);
108922: 
108923: #ifdef MOZ_CRASHREPORTER_INJECTOR
108991:             for (uint32_t i=1; i<mPluginCpuUsageOnHang.Length(); ++i) {
108923:                 nsCString tempStr;
108923:                 tempStr.AppendFloat(std::ceil(mPluginCpuUsageOnHang[i] * 100) / 100);
108923:                 notes.Put(nsPrintfCString("CpuUsageFlashProcess%d", i), tempStr);
108923:             }
108923: #endif
107142:         }
107142: #endif
107142:     }
 37384: }
 39793: #endif  // MOZ_CRASHREPORTER
 38688: 
 38121: int
 38121: PluginModuleParent::TimeoutChanged(const char* aPref, void* aModule)
 38121: {
 39785:     NS_ASSERTION(NS_IsMainThread(), "Wrong thead!");
 76704:     if (!strcmp(aPref, kChildTimeoutPref)) {
 76704:       // The timeout value used by the parent for children
108991:       int32_t timeoutSecs = Preferences::GetInt(kChildTimeoutPref, 0);
114048:       int32_t timeoutMs = (timeoutSecs > 0) ? (1000 * timeoutSecs) :
 38121:                         SyncChannel::kNoTimeout;
 38121:       static_cast<PluginModuleParent*>(aModule)->SetReplyTimeoutMs(timeoutMs);
 76704:     } else if (!strcmp(aPref, kParentTimeoutPref)) {
 76704:       // The timeout value used by the child for its parent
108991:       int32_t timeoutSecs = Preferences::GetInt(kParentTimeoutPref, 0);
 90631:       unused << static_cast<PluginModuleParent*>(aModule)->SendSetParentHangTimeout(timeoutSecs);
 76704:     }
 38121:     return 0;
 38121: }
 38121: 
 38121: void
 38121: PluginModuleParent::CleanupFromTimeout()
 38121: {
102627:     if (!mShutdown && OkToCleanup())
 38121:         Close();
 38121: }
 38121: 
107142: #ifdef XP_WIN
107142: namespace {
107142: 
108991: uint64_t
107142: FileTimeToUTC(const FILETIME& ftime) 
107142: {
107142:   ULARGE_INTEGER li;
107142:   li.LowPart = ftime.dwLowDateTime;
107142:   li.HighPart = ftime.dwHighDateTime;
107142:   return li.QuadPart;
107142: }
107142: 
108923: struct CpuUsageSamples
108923: {
108991:   uint64_t sampleTimes[2];
108991:   uint64_t cpuTimes[2];
108923: };
108923: 
107901: bool 
108923: GetProcessCpuUsage(const InfallibleTArray<base::ProcessHandle>& processHandles, InfallibleTArray<float>& cpuUsage)
107866: {
108923:   InfallibleTArray<CpuUsageSamples> samples(processHandles.Length());
107142:   FILETIME creationTime, exitTime, kernelTime, userTime, currentTime;
107142:   BOOL res;
107142: 
108991:   for (uint32_t i = 0; i < processHandles.Length(); ++i) {
107142:     ::GetSystemTimeAsFileTime(&currentTime);
108923:     res = ::GetProcessTimes(processHandles[i], &creationTime, &exitTime, &kernelTime, &userTime);
107142:     if (!res) {
107142:       NS_WARNING("failed to get process times");
107142:       return false;
107142:     }
107142:   
108923:     CpuUsageSamples s;
108923:     s.sampleTimes[0] = FileTimeToUTC(currentTime);
108923:     s.cpuTimes[0]    = FileTimeToUTC(kernelTime) + FileTimeToUTC(userTime);
108923:     samples.AppendElement(s);
108923:   }
107142: 
107142:   // we already hung for a while, a little bit longer won't matter
107142:   ::Sleep(50);
107142: 
108991:   const int32_t numberOfProcessors = PR_GetNumberOfProcessors();
108923: 
108991:   for (uint32_t i = 0; i < processHandles.Length(); ++i) {
107142:     ::GetSystemTimeAsFileTime(&currentTime);
108923:     res = ::GetProcessTimes(processHandles[i], &creationTime, &exitTime, &kernelTime, &userTime);
107142:     if (!res) {
107142:       NS_WARNING("failed to get process times");
107142:       return false;
107142:     }
107142: 
108923:     samples[i].sampleTimes[1] = FileTimeToUTC(currentTime);
108923:     samples[i].cpuTimes[1]    = FileTimeToUTC(kernelTime) + FileTimeToUTC(userTime);    
107142: 
108991:     const uint64_t deltaSampleTime = samples[i].sampleTimes[1] - samples[i].sampleTimes[0];
108991:     const uint64_t deltaCpuTime    = samples[i].cpuTimes[1]    - samples[i].cpuTimes[0];
108923:     const float usage = 100.f * (float(deltaCpuTime) / deltaSampleTime) / numberOfProcessors;
108923:     cpuUsage.AppendElement(usage);
108923:   }
107142: 
107142:   return true;
107142: }
107142: 
107142: } // anonymous namespace
107142: #endif // #ifdef XP_WIN
107142: 
 38121: bool
 38121: PluginModuleParent::ShouldContinueFromReplyTimeout()
 38121: {
 39793: #ifdef MOZ_CRASHREPORTER
 79569:     CrashReporterParent* crashReporter = CrashReporter();
111617:     crashReporter->AnnotateCrashReport(NS_LITERAL_CSTRING("PluginHang"),
111617:                                        NS_LITERAL_CSTRING("1"));
 79569:     if (crashReporter->GeneratePairedMinidump(this)) {
 79569:         mPluginDumpID = crashReporter->ChildDumpID();
 39793:         PLUGIN_LOG_DEBUG(
111617:                 ("generated paired browser/plugin minidumps: %s)",
111617:                  NS_ConvertUTF16toUTF8(mPluginDumpID).get()));
111617: 
114681:         nsAutoCString additionalDumps("browser");
114681: 
114681: #ifdef MOZ_CRASHREPORTER_INJECTOR
114681:         nsCOMPtr<nsIFile> pluginDumpFile;
114681: 
114681:         if (GetMinidumpForID(mPluginDumpID, getter_AddRefs(pluginDumpFile)) &&
114681:             pluginDumpFile) {
114681:           nsCOMPtr<nsIFile> childDumpFile;
114681: 
114681:           if (mFlashProcess1 &&
114681:               TakeMinidumpForChild(mFlashProcess1,
114681:                                    getter_AddRefs(childDumpFile))) {
114681:             additionalDumps.Append(",flash1");
114681:             RenameAdditionalHangMinidump(pluginDumpFile, childDumpFile,
114681:                                          NS_LITERAL_CSTRING("flash1"));
114681:           }
114681:           if (mFlashProcess2 &&
114681:               TakeMinidumpForChild(mFlashProcess2,
114681:                                    getter_AddRefs(childDumpFile))) {
114681:             additionalDumps.Append(",flash2");
114681:             RenameAdditionalHangMinidump(pluginDumpFile, childDumpFile,
114681:                                          NS_LITERAL_CSTRING("flash2"));
114681:           }
114681:         }
114681: #endif
114681: 
111617:         crashReporter->AnnotateCrashReport(
111617:             NS_LITERAL_CSTRING("additional_minidumps"),
114681:             additionalDumps);
 79569:     } else {
 39793:         NS_WARNING("failed to capture paired minidumps from hang");
 39793:     }
 39793: #endif
 39793: 
107142: #ifdef XP_WIN
108923:     // collect cpu usage for plugin processes
108923: 
108923:     InfallibleTArray<base::ProcessHandle> processHandles;
108923:     base::ProcessHandle handle;
108923: 
108923:     processHandles.AppendElement(OtherProcess());
108923: #ifdef MOZ_CRASHREPORTER_INJECTOR
108923:     if (mFlashProcess1 && base::OpenProcessHandle(mFlashProcess1, &handle)) {
108923:       processHandles.AppendElement(handle);
108923:     }
108923:     if (mFlashProcess2 && base::OpenProcessHandle(mFlashProcess2, &handle)) {
108923:       processHandles.AppendElement(handle);
108923:     }
108923: #endif
108923: 
108923:     if (!GetProcessCpuUsage(processHandles, mPluginCpuUsageOnHang)) {
108923:       mPluginCpuUsageOnHang.Clear();
107142:     }
107142: #endif
107142: 
 39793:     // this must run before the error notification from the channel,
 39793:     // or not at all
 38121:     MessageLoop::current()->PostTask(
 38121:         FROM_HERE,
 39793:         mTaskFactory.NewRunnableMethod(
 39793:             &PluginModuleParent::CleanupFromTimeout));
 38121: 
 39793:     if (!KillProcess(OtherProcess(), 1, false))
 39793:         NS_WARNING("failed to kill subprocess!");
 38121: 
 39793:     return false;
 38121: }
 38121: 
 79569: #ifdef MOZ_CRASHREPORTER
 79569: CrashReporterParent*
 79569: PluginModuleParent::CrashReporter()
 79569: {
 79569:     return static_cast<CrashReporterParent*>(ManagedPCrashReporterParent()[0]);
 79569: }
 79569: 
107562: #ifdef MOZ_CRASHREPORTER_INJECTOR
104355: static void
104355: RemoveMinidump(nsIFile* minidump)
104355: {
104355:     if (!minidump)
104355:         return;
104355: 
104355:     minidump->Remove(false);
104355:     nsCOMPtr<nsIFile> extraFile;
104355:     if (GetExtraFileForMinidump(minidump,
104355:                                 getter_AddRefs(extraFile))) {
104355:         extraFile->Remove(true);
104355:     }
104355: }
107562: #endif // MOZ_CRASHREPORTER_INJECTOR
104355: 
104355: void
104355: PluginModuleParent::ProcessFirstMinidump()
104355: {
104355:     CrashReporterParent* crashReporter = CrashReporter();
104355:     if (!crashReporter)
104355:         return;
104355: 
104355:     AnnotationTable notes;
104355:     notes.Init(4);
104355:     WriteExtraDataForMinidump(notes);
104355: 
111617:     if (!mPluginDumpID.IsEmpty()) {
111617:         crashReporter->GenerateChildData(&notes);
104355:         return;
104355:     }
104355: 
115367:     uint32_t sequence = UINT32_MAX;
104355:     nsCOMPtr<nsIFile> dumpFile;
110974:     nsAutoCString flashProcessType;
104355:     TakeMinidump(getter_AddRefs(dumpFile), &sequence);
104355: 
104355: #ifdef MOZ_CRASHREPORTER_INJECTOR
104355:     nsCOMPtr<nsIFile> childDumpFile;
108991:     uint32_t childSequence;
104355: 
104355:     if (mFlashProcess1 &&
104355:         TakeMinidumpForChild(mFlashProcess1,
104355:                              getter_AddRefs(childDumpFile),
104355:                              &childSequence)) {
104355:         if (childSequence < sequence) {
104355:             RemoveMinidump(dumpFile);
104355:             dumpFile = childDumpFile;
104355:             sequence = childSequence;
104355:             flashProcessType.AssignLiteral("Broker");
104355:         }
104355:         else {
104355:             RemoveMinidump(childDumpFile);
104355:         }
104355:     }
104355:     if (mFlashProcess2 &&
104355:         TakeMinidumpForChild(mFlashProcess2,
104355:                              getter_AddRefs(childDumpFile),
104355:                              &childSequence)) {
104355:         if (childSequence < sequence) {
104355:             RemoveMinidump(dumpFile);
104355:             dumpFile = childDumpFile;
104355:             sequence = childSequence;
104355:             flashProcessType.AssignLiteral("Sandbox");
104355:         }
104355:         else {
104355:             RemoveMinidump(childDumpFile);
104355:         }
104355:     }
104355: #endif
104355: 
104355:     if (!dumpFile) {
104355:         NS_WARNING("[PluginModuleParent::ActorDestroy] abnormal shutdown without minidump!");
104355:         return;
104355:     }
104355: 
104355:     PLUGIN_LOG_DEBUG(("got child minidump: %s",
104355:                       NS_ConvertUTF16toUTF8(mPluginDumpID).get()));
104355: 
104355:     GetIDFromMinidump(dumpFile, mPluginDumpID);
104355:     if (!flashProcessType.IsEmpty()) {
104355:         notes.Put(NS_LITERAL_CSTRING("FlashProcessDump"), flashProcessType);
104355:     }
104355:     crashReporter->GenerateCrashReportForMinidump(dumpFile, &notes);
104355: }
104355: #endif
104355: 
 37384: void
 36145: PluginModuleParent::ActorDestroy(ActorDestroyReason why)
 36145: {
 36145:     switch (why) {
 37384:     case AbnormalShutdown: {
 39793: #ifdef MOZ_CRASHREPORTER
104355:         ProcessFirstMinidump();
 39793: #endif
 37384: 
 36304:         mShutdown = true;
 36304:         // Defer the PluginCrashed method so that we don't re-enter
 36304:         // and potentially modify the actor child list while enumerating it.
 39793:         if (mPlugin)
 39793:             MessageLoop::current()->PostTask(
 39793:                 FROM_HERE,
 39793:                 mTaskFactory.NewRunnableMethod(
 39793:                     &PluginModuleParent::NotifyPluginCrashed));
 36304:         break;
 37384:     }
 36145:     case NormalShutdown:
 36145:         mShutdown = true;
 36145:         break;
 36145: 
 36145:     default:
 36145:         NS_ERROR("Unexpected shutdown reason for toplevel actor.");
 36145:     }
 36145: }
 36145: 
 39312: void
 39312: PluginModuleParent::NotifyPluginCrashed()
 39312: {
 39617:     if (!OkToCleanup()) {
 39617:         // there's still plugin code on the C++ stack.  try again
 39617:         MessageLoop::current()->PostDelayedTask(
 39793:             FROM_HERE,
 39793:             mTaskFactory.NewRunnableMethod(
 39793:                 &PluginModuleParent::NotifyPluginCrashed), 10);
 39617:         return;
 39617:     }
 39617: 
 39312:     if (mPlugin)
 39794:         mPlugin->PluginCrashed(mPluginDumpID, mBrowserDumpID);
 39312: }
 39312: 
 39742: PPluginIdentifierParent*
 39742: PluginModuleParent::AllocPPluginIdentifier(const nsCString& aString,
 72341:                                            const int32_t& aInt,
 72341:                                            const bool& aTemporary)
 39742: {
 72341:     if (aTemporary) {
 72341:         NS_ERROR("Plugins don't create temporary identifiers.");
 72341:         return NULL; // should abort the plugin
 72341:     }
 72341: 
 39742:     NPIdentifier npident = aString.IsVoid() ?
 39742:         mozilla::plugins::parent::_getintidentifier(aInt) :
 39742:         mozilla::plugins::parent::_getstringidentifier(aString.get());
 39742: 
 39742:     if (!npident) {
 39742:         NS_WARNING("Failed to get identifier!");
106838:         return nullptr;
 39742:     }
 39742: 
 72341:     PluginIdentifierParent* ident = new PluginIdentifierParent(npident, false);
 39742:     mIdentifiers.Put(npident, ident);
 39742:     return ident;
 39742: }
 39742: 
 39742: bool
 39742: PluginModuleParent::DeallocPPluginIdentifier(PPluginIdentifierParent* aActor)
 39742: {
 39742:     delete aActor;
 39742:     return true;
 39742: }
 39742: 
 35898: PPluginInstanceParent*
 35943: PluginModuleParent::AllocPPluginInstance(const nsCString& aMimeType,
 35746:                                          const uint16_t& aMode,
 57141:                                          const InfallibleTArray<nsCString>& aNames,
 57141:                                          const InfallibleTArray<nsCString>& aValues,
 35746:                                          NPError* rv)
 35740: {
 35890:     NS_ERROR("Not reachable!");
 35890:     return NULL;
 35740: }
 35740: 
 35926: bool
 36138: PluginModuleParent::DeallocPPluginInstance(PPluginInstanceParent* aActor)
 35746: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 35893:     delete aActor;
 35926:     return true;
 35746: }
 35746: 
 35746: void
 35893: PluginModuleParent::SetPluginFuncs(NPPluginFuncs* aFuncs)
 35746: {
 35746:     aFuncs->version = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
106838:     aFuncs->javaClass = nullptr;
 35746: 
 62174:     // Gecko should always call these functions through a PluginLibrary object.
 62174:     aFuncs->newp = NULL;
 62174:     aFuncs->clearsitedata = NULL;
 62174:     aFuncs->getsiteswithdata = NULL;
 62174: 
 35910:     aFuncs->destroy = NPP_Destroy;
 35910:     aFuncs->setwindow = NPP_SetWindow;
 35910:     aFuncs->newstream = NPP_NewStream;
 35910:     aFuncs->destroystream = NPP_DestroyStream;
 35910:     aFuncs->asfile = NPP_StreamAsFile;
 35910:     aFuncs->writeready = NPP_WriteReady;
 35910:     aFuncs->write = NPP_Write;
 35910:     aFuncs->print = NPP_Print;
 35910:     aFuncs->event = NPP_HandleEvent;
 35910:     aFuncs->urlnotify = NPP_URLNotify;
 35910:     aFuncs->getvalue = NPP_GetValue;
 35910:     aFuncs->setvalue = NPP_SetValue;
 60021:     aFuncs->gotfocus = NULL;
 60021:     aFuncs->lostfocus = NULL;
 60021:     aFuncs->urlredirectnotify = NULL;
 60021: 
 62174:     // Provide 'NPP_URLRedirectNotify', 'NPP_ClearSiteData', and
 62174:     // 'NPP_GetSitesWithData' functionality if it is supported by the plugin.
 60021:     bool urlRedirectSupported = false;
 62174:     unused << CallOptionalFunctionsSupported(&urlRedirectSupported,
 62174:                                              &mClearSiteDataSupported,
 62174:                                              &mGetSitesWithDataSupported);
 60021:     if (urlRedirectSupported) {
 60021:       aFuncs->urlredirectnotify = NPP_URLRedirectNotify;
 60021:     }
 35746: }
 35746: 
 35747: NPError
 35893: PluginModuleParent::NPP_Destroy(NPP instance,
 37311:                                 NPSavedData** /*saved*/)
 35747: {
 35747:     // FIXME/cjones:
 35747:     //  (1) send a "destroy" message to the child
 35747:     //  (2) the child shuts down its instance
 35747:     //  (3) remove both parent and child IDs from map
 35747:     //  (4) free parent
 37099:     PLUGIN_LOG_DEBUG_FUNCTION;
 35747: 
 35893:     PluginInstanceParent* parentInstance =
 35893:         static_cast<PluginInstanceParent*>(instance->pdata);
 35747: 
 36101:     if (!parentInstance)
 36101:         return NPERR_NO_ERROR;
 36101: 
 37311:     NPError retval = parentInstance->Destroy();
106838:     instance->pdata = nullptr;
 35747: 
 41382:     unused << PluginInstanceParent::Call__delete__(parentInstance);
 37311:     return retval;
 35740: }
 35740: 
 35910: NPError
 35910: PluginModuleParent::NPP_NewStream(NPP instance, NPMIMEType type,
 35910:                                   NPStream* stream, NPBool seekable,
 35910:                                   uint16_t* stype)
 35910: {
 88104:     SAMPLE_LABEL("PluginModuleParent", "NPP_NewStream");
 36144:     PluginInstanceParent* i = InstCast(instance);
 36144:     if (!i)
 36144:         return NPERR_GENERIC_ERROR;
 36144: 
 36144:     return i->NPP_NewStream(type, stream, seekable,
 35910:                             stype);
 35910: }
 35910: 
 35910: NPError
 35913: PluginModuleParent::NPP_SetWindow(NPP instance, NPWindow* window)
 35913: {
 36144:     PluginInstanceParent* i = InstCast(instance);
 36144:     if (!i)
 36144:         return NPERR_GENERIC_ERROR;
 36144: 
 36144:     return i->NPP_SetWindow(window);
 35913: }
 35913: 
 35913: NPError
 35910: PluginModuleParent::NPP_DestroyStream(NPP instance,
 35910:                                       NPStream* stream,
 35910:                                       NPReason reason)
 35910: {
 36144:     PluginInstanceParent* i = InstCast(instance);
 36144:     if (!i)
 36144:         return NPERR_GENERIC_ERROR;
 36144: 
 36144:     return i->NPP_DestroyStream(stream, reason);
 35910: }
 35910: 
 35910: int32_t
 35910: PluginModuleParent::NPP_WriteReady(NPP instance,
 35910:                                    NPStream* stream)
 35910: {
 36144:     BrowserStreamParent* s = StreamCast(instance, stream);
 36144:     if (!s)
 36144:         return -1;
 36144: 
 36144:     return s->WriteReady();
 35910: }
 35910: 
 35910: int32_t
 35910: PluginModuleParent::NPP_Write(NPP instance,
 35910:                               NPStream* stream,
 35910:                               int32_t offset,
 35910:                               int32_t len,
 35910:                               void* buffer)
 35910: {
 36144:     BrowserStreamParent* s = StreamCast(instance, stream);
 36144:     if (!s)
 36144:         return -1;
 36144: 
 36144:     return s->Write(offset, len, buffer);
 35910: }
 35910: 
 35910: void
 35910: PluginModuleParent::NPP_StreamAsFile(NPP instance,
 35910:                                      NPStream* stream,
 35910:                                      const char* fname)
 35910: {
 36144:     BrowserStreamParent* s = StreamCast(instance, stream);
 36144:     if (!s)
 36144:         return;
 36144: 
 36144:     s->StreamAsFile(fname);
 35910: }
 35910: 
 35910: void
 35910: PluginModuleParent::NPP_Print(NPP instance, NPPrint* platformPrint)
 35910: {
 36144:     PluginInstanceParent* i = InstCast(instance);
 36144:     if (i)
 36144:         i->NPP_Print(platformPrint);
 35910: }
 35910: 
 35910: int16_t
 35910: PluginModuleParent::NPP_HandleEvent(NPP instance, void* event)
 35910: {
 36144:     PluginInstanceParent* i = InstCast(instance);
 36144:     if (!i)
 36144:         return false;
 36144: 
 36144:     return i->NPP_HandleEvent(event);
 35910: }
 35910: 
 35910: void
 35910: PluginModuleParent::NPP_URLNotify(NPP instance, const char* url,
 35910:                                   NPReason reason, void* notifyData)
 35910: {
 36144:     PluginInstanceParent* i = InstCast(instance);
 36144:     if (!i)
 36144:         return;
 36144: 
 36144:     i->NPP_URLNotify(url, reason, notifyData);
 35910: }
 35910: 
 35910: NPError
 35910: PluginModuleParent::NPP_GetValue(NPP instance,
 35910:                                  NPPVariable variable, void *ret_value)
 35910: {
 36144:     PluginInstanceParent* i = InstCast(instance);
 36144:     if (!i)
 36144:         return NPERR_GENERIC_ERROR;
 36144: 
 36144:     return i->NPP_GetValue(variable, ret_value);
 35910: }
 35910: 
 35910: NPError
 35910: PluginModuleParent::NPP_SetValue(NPP instance, NPNVariable variable,
 35910:                                  void *value)
 35910: {
 36144:     PluginInstanceParent* i = InstCast(instance);
 36144:     if (!i)
 36144:         return NPERR_GENERIC_ERROR;
 36144: 
 36144:     return i->NPP_SetValue(variable, value);
 35910: }
 35910: 
 35926: bool
 57138: PluginModuleParent::RecvBackUpXResources(const FileDescriptor& aXSocketFd)
 57138: {
 57138: #ifndef MOZ_X11
 57138:     NS_RUNTIMEABORT("This message only makes sense on X11 platforms");
 57138: #else
 95307:     NS_ABORT_IF_FALSE(0 > mPluginXSocketFdDup.get(),
 57138:                       "Already backed up X resources??");
 95307:     mPluginXSocketFdDup.forget();
108503:     mPluginXSocketFdDup.reset(aXSocketFd.PlatformHandle());
 57138: #endif
 57138:     return true;
 57138: }
 57138: 
 60021: void
 60021: PluginModuleParent::NPP_URLRedirectNotify(NPP instance, const char* url,
 60021:                                           int32_t status, void* notifyData)
 60021: {
 60021:   PluginInstanceParent* i = InstCast(instance);
 60021:   if (!i)
 60021:     return;
 60021: 
 60021:   i->NPP_URLRedirectNotify(url, status, notifyData);
 60021: }
 60021: 
 57138: bool
 35968: PluginModuleParent::AnswerNPN_UserAgent(nsCString* userAgent)
 35968: {
106838:     *userAgent = NullableString(mNPNIface->uagent(nullptr));
 35968:     return true;
 35968: }
 35968: 
 72341: PluginIdentifierParent*
 72341: PluginModuleParent::GetIdentifierForNPIdentifier(NPP npp, NPIdentifier aIdentifier)
 35835: {
 95428:     PluginIdentifierParent* ident;
 72341:     if (mIdentifiers.Get(aIdentifier, &ident)) {
 72341:         if (ident->IsTemporary()) {
 72341:             ident->AddTemporaryRef();
 72341:         }
 72341:         return ident;
 72341:     }
 72341: 
 39742:     nsCString string;
 39742:     int32_t intval = -1;
 72341:     bool temporary = false;
 39742:     if (mozilla::plugins::parent::_identifierisstring(aIdentifier)) {
 39742:         NPUTF8* chars =
 39742:             mozilla::plugins::parent::_utf8fromidentifier(aIdentifier);
 39742:         if (!chars) {
106838:             return nullptr;
 35934:         }
 39742:         string.Adopt(chars);
 72341:         temporary = !NPStringIdentifierIsPermanent(npp, aIdentifier);
 35927:     }
 39742:     else {
 39742:         intval = mozilla::plugins::parent::_intfromidentifier(aIdentifier);
 80486:         string.SetIsVoid(true);
 35835:     }
 72341: 
 72341:     ident = new PluginIdentifierParent(aIdentifier, temporary);
 72341:     if (!SendPPluginIdentifierConstructor(ident, string, intval, temporary))
106838:         return nullptr;
 41028: 
 72341:     if (!temporary) {
 39742:         mIdentifiers.Put(aIdentifier, ident);
 35934:     }
 39742:     return ident;
 35835: }
 35890: 
 35893: PluginInstanceParent*
 35893: PluginModuleParent::InstCast(NPP instance)
 35890: {
 35893:     PluginInstanceParent* ip =
 35893:         static_cast<PluginInstanceParent*>(instance->pdata);
 36144: 
 36144:     // If the plugin crashed and the PluginInstanceParent was deleted,
 36144:     // instance->pdata will be NULL.
 36144:     if (!ip)
 36144:         return NULL;
 36144: 
 35893:     if (instance != ip->mNPP) {
 35890:         NS_RUNTIMEABORT("Corrupted plugin data.");
 35893:     }
 35890:     return ip;
 35890: }
 35890: 
 35895: BrowserStreamParent*
 35893: PluginModuleParent::StreamCast(NPP instance,
 35893:                                NPStream* s)
 35890: {
 35893:     PluginInstanceParent* ip = InstCast(instance);
 36144:     if (!ip)
 36144:         return NULL;
 36144: 
 35895:     BrowserStreamParent* sp =
 35938:         static_cast<BrowserStreamParent*>(static_cast<AStream*>(s->pdata));
 35893:     if (sp->mNPP != ip || s != sp->mStream) {
 35890:         NS_RUNTIMEABORT("Corrupted plugin stream data.");
 35893:     }
 35890:     return sp;
 35890: }
 35890: 
 36010: bool
 36010: PluginModuleParent::HasRequiredFunctions()
 36010: {
 36010:     return true;
 36010: }
 36010: 
 52409: nsresult
 52409: PluginModuleParent::AsyncSetWindow(NPP instance, NPWindow* window)
 52409: {
 52409:     PluginInstanceParent* i = InstCast(instance);
 52409:     if (!i)
 52409:         return NS_ERROR_FAILURE;
 52409: 
 52409:     return i->AsyncSetWindow(window);
 52409: }
 52409: 
 77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
 77498: nsresult
 77498: PluginModuleParent::HandleGUIEvent(NPP instance,
 77498:                                    const nsGUIEvent& anEvent,
 77498:                                    bool* handled)
 77498: {
 77498:     PluginInstanceParent* i = InstCast(instance);
 77498:     if (!i)
 77498:         return NS_ERROR_FAILURE;
 77498: 
 77498:     return i->HandleGUIEvent(anEvent, handled);
 77498: }
 77498: #endif
 77498: 
 52409: nsresult
 89708: PluginModuleParent::GetImageContainer(NPP instance,
 89708:                              mozilla::layers::ImageContainer** aContainer)
 62473: {
 62473:     PluginInstanceParent* i = InstCast(instance);
 89708:     return !i ? NS_ERROR_FAILURE : i->GetImageContainer(aContainer);
 62473: }
 62473: 
 62704: nsresult
 62981: PluginModuleParent::GetImageSize(NPP instance,
 62981:                                  nsIntSize* aSize)
 62981: {
 62981:     PluginInstanceParent* i = InstCast(instance);
 62981:     return !i ? NS_ERROR_FAILURE : i->GetImageSize(aSize);
 62981: }
 62981: 
 62981: nsresult
 62704: PluginModuleParent::SetBackgroundUnknown(NPP instance)
 62704: {
 62704:     PluginInstanceParent* i = InstCast(instance);
 62704:     if (!i)
 62704:         return NS_ERROR_FAILURE;
 62704: 
 62704:     return i->SetBackgroundUnknown();
 62704: }
 62704: 
 62704: nsresult
 62704: PluginModuleParent::BeginUpdateBackground(NPP instance,
 62704:                                           const nsIntRect& aRect,
 62704:                                           gfxContext** aCtx)
 62704: {
 62704:     PluginInstanceParent* i = InstCast(instance);
 62704:     if (!i)
 62704:         return NS_ERROR_FAILURE;
 62704: 
 62704:     return i->BeginUpdateBackground(aRect, aCtx);
 62704: }
 62704: 
 62704: nsresult
 62704: PluginModuleParent::EndUpdateBackground(NPP instance,
 62704:                                         gfxContext* aCtx,
 62704:                                         const nsIntRect& aRect)
 62704: {
 62704:     PluginInstanceParent* i = InstCast(instance);
 62704:     if (!i)
 62704:         return NS_ERROR_FAILURE;
 62704: 
 62704:     return i->EndUpdateBackground(aCtx, aRect);
 62704: }
 62704: 
 82142: #if defined(XP_UNIX) && !defined(XP_MACOSX) && !defined(MOZ_WIDGET_GONK)
 36010: nsresult
 36010: PluginModuleParent::NP_Initialize(NPNetscapeFuncs* bFuncs, NPPluginFuncs* pFuncs, NPError* error)
 36010: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 36010: 
 36010:     mNPNIface = bFuncs;
 36010: 
 36145:     if (mShutdown) {
 36145:         *error = NPERR_GENERIC_ERROR;
 36145:         return NS_ERROR_FAILURE;
 36145:     }
 36145: 
 93035:     uint32_t flags = 0;
 93035: 
 93035:     if (!CallNP_Initialize(flags, error)) {
 36102:         return NS_ERROR_FAILURE;
 36010:     }
 36010:     else if (*error != NPERR_NO_ERROR) {
 36010:         return NS_OK;
 36010:     }
 36010: 
 36010:     SetPluginFuncs(pFuncs);
 60021: 
 36010:     return NS_OK;
 36010: }
 36010: #else
 36010: nsresult
 36010: PluginModuleParent::NP_Initialize(NPNetscapeFuncs* bFuncs, NPError* error)
 36010: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 36010: 
 36010:     mNPNIface = bFuncs;
 36010: 
 36145:     if (mShutdown) {
 36145:         *error = NPERR_GENERIC_ERROR;
 36145:         return NS_ERROR_FAILURE;
 36145:     }
 36145: 
 93035:     uint32_t flags = 0;
 97835: #ifdef XP_WIN
 93035:     flags |= kAllowAsyncDrawing;
 97835: #endif
 93035: 
 93035:     if (!CallNP_Initialize(flags, error))
 36102:         return NS_ERROR_FAILURE;
 36010: 
 90760: #if defined XP_WIN
 72466:     // Send the info needed to join the chrome process's audio session to the
 72466:     // plugin process
 72466:     nsID id;
 72466:     nsString sessionName;
 72466:     nsString iconPath;
 72466: 
 72466:     if (NS_SUCCEEDED(mozilla::widget::GetAudioSessionData(id, sessionName,
 72466:                                                           iconPath)))
 98623:         unused << SendSetAudioSessionData(id, sessionName, iconPath);
 72466: #endif
 72466: 
103452: #ifdef MOZ_CRASHREPORTER_INJECTOR
103452:     InitializeInjector();
103452: #endif
103452: 
 36010:     return NS_OK;
 36010: }
 36010: #endif
 36010: 
 36010: nsresult
 36010: PluginModuleParent::NP_Shutdown(NPError* error)
 36010: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 36010: 
 36145:     if (mShutdown) {
 36145:         *error = NPERR_GENERIC_ERROR;
 36145:         return NS_ERROR_FAILURE;
 36145:     }
 36145: 
 36140:     bool ok = CallNP_Shutdown(error);
 36010: 
 36140:     // if NP_Shutdown() is nested within another RPC call, this will
 36140:     // break things.  but lord help us if we're doing that anyway; the
 36140:     // plugin dso will have been unloaded on the other side by the
 36140:     // CallNP_Shutdown() message
 36039:     Close();
 36039: 
 36039:     return ok ? NS_OK : NS_ERROR_FAILURE;
 36010: }
 36010: 
 36010: nsresult
 37635: PluginModuleParent::NP_GetMIMEDescription(const char** mimeDesc)
 36010: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 36010: 
 37635:     *mimeDesc = "application/x-foobar";
 36010:     return NS_OK;
 36010: }
 36010: 
 36010: nsresult
 36010: PluginModuleParent::NP_GetValue(void *future, NPPVariable aVariable,
 36010:                                    void *aValue, NPError* error)
 36010: {
 37099:     PR_LOG(gPluginLog, PR_LOG_WARNING, ("%s Not implemented, requested variable %i", __FUNCTION__,
 37099:                                         (int) aVariable));
 36010: 
 36010:     //TODO: implement this correctly
 36010:     *error = NPERR_GENERIC_ERROR;
 36010:     return NS_OK;
 36010: }
 36010: 
 36764: #if defined(XP_WIN) || defined(XP_MACOSX) || defined(XP_OS2)
 36010: nsresult
 36010: PluginModuleParent::NP_GetEntryPoints(NPPluginFuncs* pFuncs, NPError* error)
 36010: {
 36010:     NS_ASSERTION(pFuncs, "Null pointer!");
 36010: 
 60021:     // We need to have the child process update its function table
 60021:     // here by actually calling NP_GetEntryPoints since the parent's
 60021:     // function table can reflect NULL entries in the child's table.
 60021:     if (!CallNP_GetEntryPoints(error)) {
 60021:         return NS_ERROR_FAILURE;
 60021:     }
 60021:     else if (*error != NPERR_NO_ERROR) {
 60021:         return NS_OK;
 60021:     }
 60021: 
 36010:     SetPluginFuncs(pFuncs);
 60021: 
 36010:     return NS_OK;
 36010: }
 36010: #endif
 36010: 
 36010: nsresult
 36010: PluginModuleParent::NPP_New(NPMIMEType pluginType, NPP instance,
 36010:                             uint16_t mode, int16_t argc, char* argn[],
 36010:                             char* argv[], NPSavedData* saved,
 36010:                             NPError* error)
 36010: {
 37099:     PLUGIN_LOG_DEBUG_METHOD;
 36010: 
 36145:     if (mShutdown) {
 36145:         *error = NPERR_GENERIC_ERROR;
 36145:         return NS_ERROR_FAILURE;
 36145:     }
 36145: 
 36010:     // create the instance on the other side
 57141:     InfallibleTArray<nsCString> names;
 57141:     InfallibleTArray<nsCString> values;
 36010: 
 36010:     for (int i = 0; i < argc; ++i) {
 36010:         names.AppendElement(NullableString(argn[i]));
 36010:         values.AppendElement(NullableString(argv[i]));
 36010:     }
 36010: 
 36098:     PluginInstanceParent* parentInstance =
 41029:         new PluginInstanceParent(this, instance,
 41029:                                  nsDependentCString(pluginType), mNPNIface);
 36010: 
 37311:     if (!parentInstance->Init()) {
 37311:         delete parentInstance;
 37311:         return NS_ERROR_FAILURE;
 37311:     }
 37311: 
 36098:     instance->pdata = parentInstance;
 36010: 
 36010:     if (!CallPPluginInstanceConstructor(parentInstance,
 36010:                                         nsDependentCString(pluginType), mode,
 36098:                                         names, values, error)) {
 36098:         // |parentInstance| is automatically deleted.
106838:         instance->pdata = nullptr;
 36101:         // if IPC is down, we'll get an immediate "failed" return, but
 36101:         // without *error being set.  So make sure that the error
 36101:         // condition is signaled to nsNPAPIPluginInstance
 36101:         if (NPERR_NO_ERROR == *error)
 36101:             *error = NPERR_GENERIC_ERROR;
 36010:         return NS_ERROR_FAILURE;
 36098:     }
 36010: 
 36098:     if (*error != NPERR_NO_ERROR) {
 37311:         NPP_Destroy(instance, 0);
 42215:         return NS_ERROR_FAILURE;
 36098:     }
 36010: 
 76704:     TimeoutChanged(kParentTimeoutPref, this);
 76704:     
 36010:     return NS_OK;
 36010: }
 36010: 
 62174: nsresult
 62174: PluginModuleParent::NPP_ClearSiteData(const char* site, uint64_t flags,
 62174:                                       uint64_t maxAge)
 62174: {
 62174:     if (!mClearSiteDataSupported)
 62174:         return NS_ERROR_NOT_AVAILABLE;
 62174: 
 62174:     NPError result;
 62174:     if (!CallNPP_ClearSiteData(NullableString(site), flags, maxAge, &result))
 62174:         return NS_ERROR_FAILURE;
 62174: 
 62174:     switch (result) {
 62174:     case NPERR_NO_ERROR:
 62174:         return NS_OK;
 62174:     case NPERR_TIME_RANGE_NOT_SUPPORTED:
 62174:         return NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED;
 62174:     case NPERR_MALFORMED_SITE:
 62174:         return NS_ERROR_INVALID_ARG;
 62174:     default:
 62174:         return NS_ERROR_FAILURE;
 62174:     }
 62174: }
 62174: 
 62174: nsresult
 62174: PluginModuleParent::NPP_GetSitesWithData(InfallibleTArray<nsCString>& result)
 62174: {
 62174:     if (!mGetSitesWithDataSupported)
 62174:         return NS_ERROR_NOT_AVAILABLE;
 62174: 
 62174:     if (!CallNPP_GetSitesWithData(&result))
 62174:         return NS_ERROR_FAILURE;
 62174: 
 62174:     return NS_OK;
 62174: }
 62174: 
 72866: #if defined(XP_MACOSX)
 72866: nsresult
 79445: PluginModuleParent::IsRemoteDrawingCoreAnimation(NPP instance, bool *aDrawing)
 72866: {
 72866:     PluginInstanceParent* i = InstCast(instance);
 72866:     if (!i)
 72866:         return NS_ERROR_FAILURE;
 72866: 
 72866:     return i->IsRemoteDrawingCoreAnimation(aDrawing);
 72866: }
 72866: #endif
 72866: 
 36125: bool
 36125: PluginModuleParent::AnswerNPN_GetValue_WithBoolReturn(const NPNVariable& aVariable,
 36125:                                                       NPError* aError,
 36125:                                                       bool* aBoolVal)
 36125: {
 36125:     NPBool boolVal = false;
106838:     *aError = mozilla::plugins::parent::_getvalue(nullptr, aVariable, &boolVal);
 36125:     *aBoolVal = boolVal ? true : false;
 36125:     return true;
 36125: }
 38685: 
 43456: #if defined(MOZ_WIDGET_QT)
 43456: static const int kMaxtimeToProcessEvents = 30;
 43456: bool
 43456: PluginModuleParent::AnswerProcessSomeEvents()
 43456: {
 43456:     PLUGIN_LOG_DEBUG(("Spinning mini nested loop ..."));
 43456:     QCoreApplication::processEvents(QEventLoop::AllEvents, kMaxtimeToProcessEvents);
 43456: 
 43456:     PLUGIN_LOG_DEBUG(("... quitting mini nested loop"));
 43456: 
 43456:     return true;
 43456: }
 43456: 
 48383: #elif defined(XP_MACOSX)
 48383: bool
 48383: PluginModuleParent::AnswerProcessSomeEvents()
 48383: {
 48383:     mozilla::plugins::PluginUtilsOSX::InvokeNativeEventLoop();
 48383:     return true;
 48383: }
 48383: 
103111: #elif !defined(MOZ_WIDGET_GTK)
 38685: bool
 38685: PluginModuleParent::AnswerProcessSomeEvents()
 38685: {
 38685:     NS_RUNTIMEABORT("unreached");
 38685:     return false;
 38685: }
 38685: 
 38685: #else
 38685: static const int kMaxChancesToProcessEvents = 20;
 38685: 
 38685: bool
 38685: PluginModuleParent::AnswerProcessSomeEvents()
 38685: {
 38685:     PLUGIN_LOG_DEBUG(("Spinning mini nested loop ..."));
 38685: 
 39263:     int i = 0;
 39263:     for (; i < kMaxChancesToProcessEvents; ++i)
 39263:         if (!g_main_context_iteration(NULL, FALSE))
 39263:             break;
 38685: 
 39263:     PLUGIN_LOG_DEBUG(("... quitting mini nested loop; processed %i tasks", i));
 38685: 
 38685:     return true;
 38685: }
 38685: #endif
 41029: 
 41651: bool
 41651: PluginModuleParent::RecvProcessNativeEventsInRPCCall()
 41651: {
 41651:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 41651: #if defined(OS_WIN)
 41651:     ProcessNativeEventsInRPCCall();
 41651:     return true;
 41651: #else
 41651:     NS_NOTREACHED(
 70027:         "PluginModuleParent::RecvProcessNativeEventsInRPCCall not implemented!");
 50439:     return false;
 50439: #endif
 50439: }
 50439: 
 70027: void
 70027: PluginModuleParent::ProcessRemoteNativeEventsInRPCCall()
 70027: {
 70027: #if defined(OS_WIN)
 98623:     unused << SendProcessNativeEventsInRPCCall();
 70027:     return;
 70027: #endif
 70027:     NS_NOTREACHED(
 70027:         "PluginModuleParent::ProcessRemoteNativeEventsInRPCCall not implemented!");
 70027: }
 70027: 
 50439: bool
 50439: PluginModuleParent::RecvPluginShowWindow(const uint32_t& aWindowId, const bool& aModal,
 50439:                                          const int32_t& aX, const int32_t& aY,
 50439:                                          const size_t& aWidth, const size_t& aHeight)
 50439: {
 50439:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 50439: #if defined(XP_MACOSX)
 50439:     CGRect windowBound = ::CGRectMake(aX, aY, aWidth, aHeight);
 50439:     mac_plugin_interposing::parent::OnPluginShowWindow(aWindowId, windowBound, aModal);
 50439:     return true;
 50439: #else
 50439:     NS_NOTREACHED(
 50439:         "PluginInstanceParent::RecvPluginShowWindow not implemented!");
 50439:     return false;
 50439: #endif
 50439: }
 50439: 
 50439: bool
 50439: PluginModuleParent::RecvPluginHideWindow(const uint32_t& aWindowId)
 50439: {
 50439:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 50439: #if defined(XP_MACOSX)
 50439:     mac_plugin_interposing::parent::OnPluginHideWindow(aWindowId, OtherSidePID());
 50439:     return true;
 50439: #else
 50439:     NS_NOTREACHED(
 50439:         "PluginInstanceParent::RecvPluginHideWindow not implemented!");
 41651:     return false;
 41651: #endif
 41651: }
 41651: 
 79569: PCrashReporterParent*
 79569: PluginModuleParent::AllocPCrashReporter(mozilla::dom::NativeThreadId* id,
108991:                                         uint32_t* processType)
 79569: {
 79569: #ifdef MOZ_CRASHREPORTER
 79569:     return new CrashReporterParent();
 79569: #else
106838:     return nullptr;
 79569: #endif
 79569: }
 79569: 
 79569: bool
 79569: PluginModuleParent::DeallocPCrashReporter(PCrashReporterParent* actor)
 79569: {
 79569:     delete actor;
 79569:     return true;
 79569: }
 79569: 
 70434: bool
 70434: PluginModuleParent::RecvSetCursor(const NSCursorInfo& aCursorInfo)
 70434: {
 70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 70434: #if defined(XP_MACOSX)
 70434:     mac_plugin_interposing::parent::OnSetCursor(aCursorInfo);
 70434:     return true;
 70434: #else
 70434:     NS_NOTREACHED(
 70434:         "PluginInstanceParent::RecvSetCursor not implemented!");
 70434:     return false;
 70434: #endif
 70434: }
 70434: 
 70434: bool
 70434: PluginModuleParent::RecvShowCursor(const bool& aShow)
 70434: {
 70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 70434: #if defined(XP_MACOSX)
 70434:     mac_plugin_interposing::parent::OnShowCursor(aShow);
 70434:     return true;
 70434: #else
 70434:     NS_NOTREACHED(
 70434:         "PluginInstanceParent::RecvShowCursor not implemented!");
 70434:     return false;
 70434: #endif
 70434: }
 70434: 
 70434: bool
 70434: PluginModuleParent::RecvPushCursor(const NSCursorInfo& aCursorInfo)
 70434: {
 70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 70434: #if defined(XP_MACOSX)
 70434:     mac_plugin_interposing::parent::OnPushCursor(aCursorInfo);
 70434:     return true;
 70434: #else
 70434:     NS_NOTREACHED(
 70434:         "PluginInstanceParent::RecvPushCursor not implemented!");
 70434:     return false;
 70434: #endif
 70434: }
 70434: 
 70434: bool
 70434: PluginModuleParent::RecvPopCursor()
 70434: {
 70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 70434: #if defined(XP_MACOSX)
 70434:     mac_plugin_interposing::parent::OnPopCursor();
 70434:     return true;
 70434: #else
 70434:     NS_NOTREACHED(
 70434:         "PluginInstanceParent::RecvPopCursor not implemented!");
 70434:     return false;
 70434: #endif
 70434: }
 70434: 
 70434: bool
 70434: PluginModuleParent::RecvGetNativeCursorsSupported(bool* supported)
 70434: {
 70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 70434: #if defined(XP_MACOSX)
 94707:     *supported =
 94707:       Preferences::GetBool("dom.ipc.plugins.nativeCursorSupport", false);
 70434:     return true;
 70434: #else
 70434:     NS_NOTREACHED(
 70434:         "PluginInstanceParent::RecvGetNativeCursorSupportLevel not implemented!");
 70434:     return false;
 70434: #endif
 70434: }
 70434: 
 74398: bool
 74398: PluginModuleParent::RecvNPN_SetException(PPluginScriptableObjectParent* aActor,
 74398:                                          const nsCString& aMessage)
 74398: {
 74398:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 74398: 
 74398:     NPObject* aNPObj = NULL;
 74398:     if (aActor) {
 74398:         aNPObj = static_cast<PluginScriptableObjectParent*>(aActor)->GetObject(true);
 74398:         if (!aNPObj) {
 74398:             NS_ERROR("Failed to get object!");
 74398:             return false;
 74398:         }
 74398:     }
 74398:     mozilla::plugins::parent::_setexception(aNPObj, NullableStringGet(aMessage));
 74398:     return true;
 74398: }
 99801: 
 99801: bool
 99801: PluginModuleParent::RecvNPN_ReloadPlugins(const bool& aReloadPages)
 99801: {
 99801:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
 99801: 
 99801:     mozilla::plugins::parent::_reloadplugins(aReloadPages);
 99801:     return true;
 99801: }
103452: 
103452: #ifdef MOZ_CRASHREPORTER_INJECTOR
103452: 
103452: // We only add the crash reporter to subprocess which have the filename
103452: // FlashPlayerPlugin*
103452: #define FLASH_PROCESS_PREFIX "FLASHPLAYERPLUGIN"
103452: 
103452: static DWORD
103452: GetFlashChildOfPID(DWORD pid, HANDLE snapshot)
103452: {
103452:     PROCESSENTRY32 entry = {
103452:         sizeof(entry)
103452:     };
103452:     for (BOOL ok = Process32First(snapshot, &entry);
103452:          ok;
103452:          ok = Process32Next(snapshot, &entry)) {
103452:         if (entry.th32ParentProcessID == pid) {
103452:             nsString name(entry.szExeFile);
103452:             ToUpperCase(name);
103452:             if (StringBeginsWith(name, NS_LITERAL_STRING(FLASH_PROCESS_PREFIX))) {
103452:                 return entry.th32ProcessID;
103452:             }
103452:         }
103452:     }
103452:     return 0;
103452: }
103452: 
103452: // We only look for child processes of the Flash plugin, NPSWF*
103452: #define FLASH_PLUGIN_PREFIX "NPSWF"
103452: 
103452: void
103452: PluginModuleParent::InitializeInjector()
103452: {
103452:     if (!Preferences::GetBool("dom.ipc.plugins.flash.subprocess.crashreporter.enabled", false))
103452:         return;
103452: 
103452:     nsCString path(Process()->GetPluginFilePath().c_str());
103452:     ToUpperCase(path);
108991:     int32_t lastSlash = path.RFindCharInSet("\\/");
103452:     if (kNotFound == lastSlash)
103452:         return;
103452: 
103452:     if (!StringBeginsWith(Substring(path, lastSlash + 1),
103452:                           NS_LITERAL_CSTRING(FLASH_PLUGIN_PREFIX)))
103452:         return;
103452: 
103452:     HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
103452:     if (INVALID_HANDLE_VALUE == snapshot)
103452:         return;
103452: 
103452:     DWORD pluginProcessPID = GetProcessId(Process()->GetChildProcessHandle());
103452:     mFlashProcess1 = GetFlashChildOfPID(pluginProcessPID, snapshot);
103452:     if (mFlashProcess1) {
103452:         InjectCrashReporterIntoProcess(mFlashProcess1, this);
103452: 
103452:         mFlashProcess2 = GetFlashChildOfPID(mFlashProcess1, snapshot);
103452:         if (mFlashProcess2) {
103452:             InjectCrashReporterIntoProcess(mFlashProcess2, this);
103452:         }
103452:     }
103452: }
103452: 
103452: void
104355: PluginModuleParent::OnCrash(DWORD processID)
103452: {
116111:     if (!mShutdown) {
103778:         GetIPCChannel()->CloseWithError();
103452:         KillProcess(OtherProcess(), 1, false);
103452:     }
116111: }
103452: 
103452: #endif // MOZ_CRASHREPORTER_INJECTOR
