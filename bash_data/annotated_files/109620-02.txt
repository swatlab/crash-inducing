     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef __NS_SVGSVGELEMENT_H__
     1: #define __NS_SVGSVGELEMENT_H__
     1: 
 86429: #include "DOMSVGTests.h"
 88281: #include "mozilla/dom/FromParser.h"
     1: #include "nsIDOMSVGFitToViewBox.h"
     1: #include "nsIDOMSVGLocatable.h"
 88281: #include "nsIDOMSVGPoint.h"
 88281: #include "nsIDOMSVGSVGElement.h"
     1: #include "nsIDOMSVGZoomAndPan.h"
 88281: #include "nsSVGEnum.h"
     1: #include "nsSVGLength2.h"
 88281: #include "nsSVGStylableElement.h"
 24554: #include "nsSVGViewBox.h"
 59471: #include "SVGAnimatedPreserveAspectRatio.h"
102310: #include "mozilla/Attributes.h"
  2617: 
 88281: class nsIDOMSVGMatrix;
 23697: class nsSMILTimeContainer;
 98726: class nsSVGViewElement;
 98726: namespace mozilla {
 98726:   class SVGFragmentIdentifier;
 98726: }
 23697: 
     1: typedef nsSVGStylableElement nsSVGSVGElementBase;
     1: 
 27870: class nsSVGSVGElement;
 27870: 
 27870: class nsSVGTranslatePoint {
 27870: public:
 98711:   nsSVGTranslatePoint()
 98711:     : mX(0.0f)
 98711:     , mY(0.0f)
 98711:   {}
 98711: 
 98711:   nsSVGTranslatePoint(float aX, float aY)
 98711:     : mX(aX)
 98711:     , mY(aY)
 98711:   {}
 27870: 
 27870:   void SetX(float aX)
 27870:     { mX = aX; }
 27870:   void SetY(float aY)
 27870:     { mY = aY; }
 27870:   float GetX() const
 27870:     { return mX; }
 27870:   float GetY() const
 27870:     { return mY; }
 27870: 
 27870:   nsresult ToDOMVal(nsSVGSVGElement *aElement, nsIDOMSVGPoint **aResult);
 27870: 
 98711:   bool operator!=(const nsSVGTranslatePoint &rhs) const {
 98711:     return mX != rhs.mX || mY != rhs.mY;
 98711:   }
 98711: 
 27870: private:
 27870: 
102310:   struct DOMVal MOZ_FINAL : public nsIDOMSVGPoint {
 27870:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 27870:     NS_DECL_CYCLE_COLLECTION_CLASS(DOMVal)
 27870: 
 27870:     DOMVal(nsSVGTranslatePoint* aVal, nsSVGSVGElement *aElement)
 27870:       : mVal(aVal), mElement(aElement) {}
 27870: 
 27870:     NS_IMETHOD GetX(float *aValue)
 27870:       { *aValue = mVal->GetX(); return NS_OK; }
 27870:     NS_IMETHOD GetY(float *aValue)
 27870:       { *aValue = mVal->GetY(); return NS_OK; }
 27870: 
 27870:     NS_IMETHOD SetX(float aValue);
 27870:     NS_IMETHOD SetY(float aValue);
 27870: 
 27870:     NS_IMETHOD MatrixTransform(nsIDOMSVGMatrix *matrix,
 27870:                                nsIDOMSVGPoint **_retval);
 27870: 
 27870:     nsSVGTranslatePoint *mVal; // kept alive because it belongs to mElement
 27870:     nsRefPtr<nsSVGSVGElement> mElement;
 27870:   };
 27870: 
 27870:   float mX;
 27870:   float mY;
 27870: };
 27870: 
  8142: class svgFloatSize {
  8142: public:
  8142:   svgFloatSize(float aWidth, float aHeight)
  8142:     : width(aWidth)
  8142:     , height(aHeight)
  8142:   {}
 79445:   bool operator!=(const svgFloatSize& rhs) {
  8142:     return width != rhs.width || height != rhs.height;
  8142:   }
  8142:   float width;
  8142:   float height;
  8142: };
  8142: 
     1: class nsSVGSVGElement : public nsSVGSVGElementBase,
  2617:                         public nsIDOMSVGSVGElement,
 86429:                         public DOMSVGTests,
     1:                         public nsIDOMSVGFitToViewBox,
     1:                         public nsIDOMSVGLocatable,
     1:                         public nsIDOMSVGZoomAndPan
     1: {
     1:   friend class nsSVGOuterSVGFrame;
     1:   friend class nsSVGInnerSVGFrame;
 59474:   friend class nsSVGImageFrame;
 98726:   friend class mozilla::SVGFragmentIdentifier;
     1: 
     1:   friend nsresult NS_NewSVGSVGElement(nsIContent **aResult,
 94340:                                       already_AddRefed<nsINodeInfo> aNodeInfo,
 56805:                                       mozilla::dom::FromParser aFromParser);
 94340:   nsSVGSVGElement(already_AddRefed<nsINodeInfo> aNodeInfo,
 56805:                   mozilla::dom::FromParser aFromParser);
     1:   
     1: public:
 59470:   typedef mozilla::SVGAnimatedPreserveAspectRatio SVGAnimatedPreserveAspectRatio;
 59474:   typedef mozilla::SVGPreserveAspectRatio SVGPreserveAspectRatio;
     1: 
     1:   // interfaces:
     1:   NS_DECL_ISUPPORTS_INHERITED
 37113:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsSVGSVGElement, nsSVGSVGElementBase)
     1:   NS_DECL_NSIDOMSVGSVGELEMENT
     1:   NS_DECL_NSIDOMSVGFITTOVIEWBOX
     1:   NS_DECL_NSIDOMSVGLOCATABLE
     1:   NS_DECL_NSIDOMSVGZOOMANDPAN
     1:   
     1:   // xxx I wish we could use virtual inheritance
     1:   NS_FORWARD_NSIDOMNODE(nsSVGSVGElementBase::)
     1:   NS_FORWARD_NSIDOMELEMENT(nsSVGSVGElementBase::)
     1:   NS_FORWARD_NSIDOMSVGELEMENT(nsSVGSVGElementBase::)
     1: 
  2617:   /**
  2617:    * For use by zoom controls to allow currentScale, currentTranslate.x and
  2617:    * currentTranslate.y to be set by a single operation that dispatches a
  2617:    * single SVGZoom event (instead of one SVGZoom and two SVGScroll events).
  2617:    */
     1:   NS_IMETHOD SetCurrentScaleTranslate(float s, float x, float y);
  2617: 
  2617:   /**
  2617:    * For use by pan controls to allow currentTranslate.x and currentTranslate.y
  2617:    * to be set by a single operation that dispatches a single SVGScroll event
  2617:    * (instead of two).
  2617:    */
     1:   NS_IMETHOD SetCurrentTranslate(float x, float y);
  2617: 
  2617:   /**
 27870:    * Retrieve the value of currentScale and currentTranslate.
  2617:    */
 27870:   const nsSVGTranslatePoint& GetCurrentTranslate() { return mCurrentTranslate; }
 27870:   float GetCurrentScale() { return mCurrentScale; }
  2617: 
  2617:   /**
  2617:    * Retrieve the value of currentScale, currentTranslate.x or
  2617:    * currentTranslate.y prior to the last change made to any one of them.
  2617:    */
 27870:   const nsSVGTranslatePoint& GetPreviousTranslate() { return mPreviousTranslate; }
 23856:   float GetPreviousScale() { return mPreviousScale; }
     1: 
 23697:   nsSMILTimeContainer* GetTimedDocumentRoot();
 23697: 
     1:   // nsIContent interface
 79445:   NS_IMETHOD_(bool) IsAttributeMapped(const nsIAtom* aAttribute) const;
 23697:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
     1: 
     1:   // nsSVGElement specializations:
 90361:   virtual gfxMatrix PrependLocalTransformsTo(const gfxMatrix &aMatrix,
 90361:                       TransformTypes aWhich = eAllTransforms) const;
 91474:   virtual bool HasValidDimensions() const;
 37974:  
     1:   // nsSVGSVGElement methods:
108991:   float GetLength(uint8_t mCtxType);
     1: 
     1:   // public helpers:
 97650: 
 97650:   /**
 97650:    * Returns true if this element has a base/anim value for its "viewBox"
 97650:    * attribute that defines a viewBox rectangle with finite values.
 97650:    *
 97650:    * Note that this does not check whether we need to synthesize a viewBox,
 97650:    * so you must call ShouldSynthesizeViewBox() if you need to check that too.
 97650:    *
 97650:    * Note also that this method does not pay attention to whether the width or
 97650:    * height values of the viewBox rect are positive!
 97650:    */
 97650:   bool HasViewBox() const {
 97650:     return mViewBox.IsExplicitlySet();
 97650:   }
 97650: 
 97650:   /**
 97650:    * Returns true if we should synthesize a viewBox for ourselves (that is, if
 97650:    * we're the root element in an image document, and we're not currently being
 97650:    * painted for an <svg:image> element).
 97650:    *
 97650:    * Only call this method if HasViewBox() returns false.
 97650:    */
 97650:   bool ShouldSynthesizeViewBox() const;
 97650: 
 98711:   bool HasViewBoxOrSyntheticViewBox() const {
 98711:     return HasViewBox() || ShouldSynthesizeViewBox();
 98711:   }
 98711: 
 71887:   gfxMatrix GetViewBoxTransform() const;
     1: 
 98711:   bool HasChildrenOnlyTransform() const {
 98711:     return mHasChildrenOnlyTransform;
 98711:   }
 98711: 
109620:   enum ChildrenOnlyTransformChangedFlags {
109620:     eDuringReflow = 1
109620:   };
109620: 
 98711:   /**
 98711:    * This method notifies the style system that the overflow rects of our
 98711:    * immediate childrens' frames need to be updated. It is called by our own
 98711:    * frame when changes (e.g. to currentScale) cause our children-only
 98711:    * transform to change.
 98711:    *
 98711:    * The reason we have this method instead of overriding
 98711:    * GetAttributeChangeHint is because we need to act on non-attribute (e.g.
 98711:    * currentScale) changes in addition to attribute (e.g. viewBox) changes.
 98711:    */
109620:   void ChildrenOnlyTransformChanged(PRUint32 aFlags = 0);
 98711: 
 62243:   // This services any pending notifications for the transform on on this root
 62243:   // <svg> node needing to be recalculated.  (Only applicable in
 62243:   // SVG-as-an-image documents.)
 62243:   virtual void FlushImageTransformInvalidation();
 59474: 
 94340:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
     1: 
 24554:   svgFloatSize GetViewportSize() const {
  8142:     return svgFloatSize(mViewportWidth, mViewportHeight);
  8142:   }
  8142: 
 24554:   void SetViewportSize(const svgFloatSize& aSize) {
  8142:     mViewportWidth  = aSize.width;
  8142:     mViewportHeight = aSize.height;
  8142:   }
  8142: 
 48124:   virtual nsXPCClassInfo* GetClassInfo();
 57610: 
 96919:   virtual nsIDOMNode* AsDOMNode() { return this; }
 96919: 
 59474: private:
     1:   // nsSVGElement overrides
 79445:   bool IsEventName(nsIAtom* aName);
     1: 
 23697:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
 23697:                               nsIContent* aBindingParent,
 79445:                               bool aCompileEventHandlers);
 79445:   virtual void UnbindFromTree(bool aDeep, bool aNullParent);
 23697: 
     1:   // implementation helpers:
 23697: 
 98726:   // Methods for <image> elements to override my "PreserveAspectRatio" value.
 98726:   // These are private so that only our friends (nsSVGImageFrame in
 98726:   // particular) have access.
 98726:   void SetImageOverridePreserveAspectRatio(const SVGPreserveAspectRatio& aPAR);
 98726:   void ClearImageOverridePreserveAspectRatio();
 98726: 
 98726:   // Set/Clear properties to hold old or override versions of attributes
 98726:   bool SetPreserveAspectRatioProperty(const SVGPreserveAspectRatio& aPAR);
 98726:   const SVGPreserveAspectRatio* GetPreserveAspectRatioProperty() const;
 98726:   bool ClearPreserveAspectRatioProperty();
 98726:   bool SetViewBoxProperty(const nsSVGViewBoxRect& aViewBox);
 98726:   const nsSVGViewBoxRect* GetViewBoxProperty() const;
 98726:   bool ClearViewBoxProperty();
108991:   bool SetZoomAndPanProperty(uint16_t aValue);
108991:   uint16_t GetZoomAndPanProperty() const;
 98726:   bool ClearZoomAndPanProperty();
 98726: 
 79445:   bool IsRoot() const {
  8938:     NS_ASSERTION((IsInDoc() && !GetParent()) ==
 80526:                  (OwnerDoc() && (OwnerDoc()->GetRootElement() == this)),
  8938:                  "Can't determine if we're root");
  8938:     return IsInDoc() && !GetParent();
  8938:   }
     1: 
 64140:   /**
 64140:    * Returns true if this is an SVG <svg> element that is the child of
 64140:    * another non-foreignObject SVG element.
 64140:    */
 79445:   bool IsInner() const {
 67658:     const nsIContent *parent = GetFlattenedTreeParent();
 84637:     return parent && parent->IsSVG() &&
 64140:            parent->Tag() != nsGkAtoms::foreignObject;
 64140:   }
 64140: 
 23697:   /* 
 23697:    * While binding to the tree we need to determine if we will be the outermost
 23697:    * <svg> element _before_ the children are bound (as they want to know what
 23697:    * timed document root to register with) and therefore _before_ our parent is
 23697:    * set (both actions are performed by nsGenericElement::BindToTree) so we
 23697:    * can't use GetOwnerSVGElement() as it relies on GetParent(). This code is
 23697:    * basically a simplified version of GetOwnerSVGElement that uses the parent
 23697:    * parameters passed in instead.
 23697:    */
 79445:   bool WillBeOutermostSVG(nsIContent* aParent,
 23697:                           nsIContent* aBindingParent) const;
 23697: 
     1:   // invalidate viewbox -> viewport xform & inform frames
     1:   void InvalidateTransformNotifyFrame();
     1: 
 80486:   // Returns true if we have at least one of the following:
 59474:   // - a (valid or invalid) value for the preserveAspectRatio attribute
 59474:   // - a SMIL-animated value for the preserveAspectRatio attribute
 79445:   bool HasPreserveAspectRatio();
 59474: 
 98726:  /**
 98726:   * Returns the explicit viewBox rect, if specified, or else a synthesized
 98726:   * viewBox, if appropriate, or else a viewBox matching the dimensions of the
 98726:   * SVG viewport.
 98726:   */
 98726:   nsSVGViewBoxRect GetViewBoxWithSynthesis(
 98726:       float aViewportWidth, float aViewportHeight) const;
 98726:   /**
 98726:    * Returns the explicit or default preserveAspectRatio, unless we're
 98726:    * synthesizing a viewBox, in which case it returns the "none" value.
 98726:    */
 98726:   SVGPreserveAspectRatio GetPreserveAspectRatioWithOverride() const;
 98726: 
     1:   virtual LengthAttributesInfo GetLengthInfo();
     1: 
     1:   enum { X, Y, WIDTH, HEIGHT };
     1:   nsSVGLength2 mLengthAttributes[4];
     1:   static LengthInfo sLengthInfo[4];
     1: 
  5347:   virtual EnumAttributesInfo GetEnumInfo();
  5347: 
  5347:   enum { ZOOMANDPAN };
  5347:   nsSVGEnum mEnumAttributes[1];
  5347:   static nsSVGEnumMapping sZoomAndPanMap[];
  5347:   static EnumInfo sEnumInfo[1];
  5347: 
 24554:   virtual nsSVGViewBox *GetViewBox();
 59470:   virtual SVGAnimatedPreserveAspectRatio *GetPreserveAspectRatio();
 23313: 
 24554:   nsSVGViewBox                   mViewBox;
 59470:   SVGAnimatedPreserveAspectRatio mPreserveAspectRatio;
 23313: 
     1:   nsSVGSVGElement               *mCoordCtx;
     1: 
  8142:   // The size of the rectangular SVG viewport into which we render. This is
  8142:   // not (necessarily) the same as the content area. See:
  8142:   //
  8142:   //   http://www.w3.org/TR/SVG11/coords.html#ViewportSpace
  8142:   //
  8142:   // XXXjwatt Currently only used for outer <svg>, but maybe we could use -1 to
  8142:   // flag this as an inner <svg> to save the overhead of GetCtx calls?
  8142:   // XXXjwatt our frame should probably reset these when it's destroyed.
  8142:   float mViewportWidth, mViewportHeight;
  8142: 
 23697:   // The time container for animations within this SVG document fragment. Set
 23697:   // for all outermost <svg> elements (not nested <svg> elements).
 23697:   nsAutoPtr<nsSMILTimeContainer> mTimedDocumentRoot;
 23697: 
     1:   // zoom and pan
 27870:   // IMPORTANT: see the comment in RecordCurrentScaleTranslate before writing
 27870:   // code to change any of these!
 27870:   nsSVGTranslatePoint               mCurrentTranslate;
 27870:   float                             mCurrentScale;
 27870:   nsSVGTranslatePoint               mPreviousTranslate;
     1:   float                             mPreviousScale;
 23697: 
 23697:   // For outermost <svg> elements created from parsing, animation is started by
 23697:   // the onload event in accordance with the SVG spec, but for <svg> elements
 23697:   // created by script or promoted from inner <svg> to outermost <svg> we need
 23697:   // to manually kick off animation when they are bound to the tree.
 79445:   bool                              mStartAnimationOnBindToTree;
 79445:   bool                              mImageNeedsTransformInvalidation;
 79445:   bool                              mIsPaintingSVGImageElement;
 98711:   bool                              mHasChildrenOnlyTransform;
 99905:   bool                              mUseCurrentView;
     1: };
     1: 
     1: #endif
