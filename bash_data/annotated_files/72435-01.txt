26627: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
26627:  * ***** BEGIN LICENSE BLOCK *****
26627:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
26627:  *
26627:  * The contents of this file are subject to the Mozilla Public License Version
26627:  * 1.1 (the "License"); you may not use this file except in compliance with
26627:  * the License. You may obtain a copy of the License at
26627:  * http://www.mozilla.org/MPL/
26627:  *
26627:  * Software distributed under the License is distributed on an "AS IS" basis,
26627:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
26627:  * for the specific language governing rights and limitations under the
26627:  * License.
26627:  *
26627:  * The Original Code is Mozilla Corporation code.
26627:  *
36532:  * The Initial Developer of the Original Code is Mozilla Foundation.
26627:  * Portions created by the Initial Developer are Copyright (C) 2006-2009
26627:  * the Initial Developer. All Rights Reserved.
26627:  *
26627:  * Contributor(s):
26627:  *   Vladimir Vukicevic <vladimir@pobox.com>
26627:  *   Masayuki Nakano <masayuki@d-toybox.com>
26627:  *   John Daggett <jdaggett@mozilla.com>
26627:  *   Jonathan Kew <jfkthame@gmail.com>
26627:  *
26627:  * Alternatively, the contents of this file may be used under the terms of
26627:  * either the GNU General Public License Version 2 or later (the "GPL"), or
26627:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
26627:  * in which case the provisions of the GPL or the LGPL are applicable instead
26627:  * of those above. If you wish to allow use of your version of this file only
26627:  * under the terms of either the GPL or the LGPL, and not to allow others to
26627:  * use your version of this file under the terms of the MPL, indicate your
26627:  * decision by deleting the provisions above and replace them with the notice
26627:  * and other provisions required by the GPL or the LGPL. If you do not delete
26627:  * the provisions above, a recipient may use your version of this file under
26627:  * the terms of any one of the MPL, the GPL or the LGPL.
26627:  *
26627:  * ***** END LICENSE BLOCK ***** */
26627: 
26627: #include "prtypes.h"
71173: #include "nsAlgorithm.h"
26627: #include "prmem.h"
26627: #include "nsString.h"
26627: #include "nsBidiUtils.h"
26627: 
26627: #include "gfxTypes.h"
26627: 
26627: #include "nsPromiseFlatString.h"
26627: 
26627: #include "gfxContext.h"
26627: #include "gfxPlatform.h"
26627: #include "gfxPlatformMac.h"
39206: #include "gfxCoreTextShaper.h"
39206: #include "gfxMacFont.h"
26627: 
26627: #include "gfxFontTest.h"
26627: #include "gfxFontUtils.h"
26627: 
26627: #include "gfxQuartzSurface.h"
31590: #include "gfxMacPlatformFontList.h"
26627: #include "gfxUserFontSet.h"
26627: 
26627: #include "nsUnicodeRange.h"
26627: 
26627: // standard font descriptors that we construct the first time they're needed
39206: CTFontDescriptorRef gfxCoreTextShaper::sDefaultFeaturesDescriptor = NULL;
39206: CTFontDescriptorRef gfxCoreTextShaper::sDisableLigaturesDescriptor = NULL;
26627: 
39206: gfxCoreTextShaper::gfxCoreTextShaper(gfxMacFont *aFont)
39206:     : gfxFontShaper(aFont)
30358: {
39206:     // Create our CTFontRef
72435:     if (gfxMacPlatformFontList::UseATSFontEntry()) {
72435:         ATSFontEntry *fe = static_cast<ATSFontEntry*>(aFont->GetFontEntry());
72435:         mCTFont = ::CTFontCreateWithPlatformFont(fe->GetATSFontRef(),
39206:                                                  aFont->GetAdjustedSize(),
39206:                                                  NULL,
39206:                                                  GetDefaultFeaturesDescriptor());
72435:     } else {
72435:         mCTFont = ::CTFontCreateWithGraphicsFont(aFont->GetCGFontRef(),
72435:                                                  aFont->GetAdjustedSize(),
72435:                                                  NULL,
72435:                                                  GetDefaultFeaturesDescriptor());
72435:     }
26627: 
26627:     // Set up the default attribute dictionary that we will need each time we create a CFAttributedString
39206:     mAttributesDict = ::CFDictionaryCreate(kCFAllocatorDefault,
26627:                                            (const void**) &kCTFontAttributeName,
26627:                                            (const void**) &mCTFont,
26627:                                            1, // count of attributes
26627:                                            &kCFTypeDictionaryKeyCallBacks,
26627:                                            &kCFTypeDictionaryValueCallBacks);
34722: }
34722: 
39206: gfxCoreTextShaper::~gfxCoreTextShaper()
39206: {
39206:     if (mAttributesDict) {
39206:         ::CFRelease(mAttributesDict);
26627:     }
39206:     if (mCTFont) {
37211:         ::CFRelease(mCTFont);
26627:     }
26627: }
26627: 
39447: PRBool
39206: gfxCoreTextShaper::InitTextRun(gfxContext *aContext,
39206:                                gfxTextRun *aTextRun,
37211:                                const PRUnichar *aString,
37211:                                PRUint32 aRunStart,
43525:                                PRUint32 aRunLength,
43525:                                PRInt32 aRunScript)
26627: {
37211:     // aRunStart and aRunLength define the section of the textRun and of aString
37211:     // that is to be drawn with this particular font
26627: 
37211:     PRBool disableLigatures = (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES) != 0;
26627: 
37211:     // Create a CFAttributedString with text and style info, so we can use CoreText to lay it out.
37211: 
37211:     PRBool isRTL = aTextRun->IsRightToLeft();
37211: 
37211:     // we need to bidi-wrap the text if the run is RTL,
37211:     // or if it is an LTR run but may contain (overridden) RTL chars
37211:     PRBool bidiWrap = isRTL;
37211:     if (!bidiWrap && (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT) == 0) {
37211:         PRUint32 i;
37211:         for (i = aRunStart; i < aRunStart + aRunLength; ++i) {
37211:             if (gfxFontUtils::PotentialRTLChar(aString[i])) {
37211:                 bidiWrap = PR_TRUE;
37211:                 break;
37211:             }
37211:         }
37211:     }
37211: 
37211:     // If there's a possibility of any bidi, we wrap the text with direction overrides
37211:     // to ensure neutrals or characters that were bidi-overridden in HTML behave properly.
37533:     const UniChar beginLTR[]    = { 0x202d, 0x20 };
37533:     const UniChar beginRTL[]    = { 0x202e, 0x20 };
40536:     const UniChar endBidiWrap[] = { 0x20, 0x2e, 0x202c };
37211: 
37211:     PRUint32 startOffset;
37211:     CFStringRef stringObj;
37211:     if (bidiWrap) {
37211:         startOffset = isRTL ?
37211:             sizeof(beginRTL) / sizeof(beginRTL[0]) : sizeof(beginLTR) / sizeof(beginLTR[0]);
37211:         CFMutableStringRef mutableString =
37211:             ::CFStringCreateMutable(kCFAllocatorDefault,
37211:                                     aRunLength + startOffset +
37211:                                     sizeof(endBidiWrap) / sizeof(endBidiWrap[0]));
37211:         ::CFStringAppendCharacters(mutableString,
37211:                                    isRTL ? beginRTL : beginLTR,
37211:                                    startOffset);
37211:         ::CFStringAppendCharacters(mutableString,
37211:                                    aString + aRunStart, aRunLength);
37211:         ::CFStringAppendCharacters(mutableString,
37211:                                    endBidiWrap,
37211:                                    sizeof(endBidiWrap) / sizeof(endBidiWrap[0]));
37211:         stringObj = mutableString;
37211:     } else {
37211:         startOffset = 0;
37211:         stringObj = ::CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault,
37211:                                                          aString + aRunStart,
37211:                                                          aRunLength,
37211:                                                          kCFAllocatorNull);
37211:     }
37211: 
37211:     CFDictionaryRef attrObj;
37211:     if (disableLigatures) {
37211:         // For letterspacing (or maybe other situations) we need to make a copy of the CTFont
37211:         // with the ligature feature disabled
37211:         CTFontRef ctFont =
72435:             CreateCTFontWithDisabledLigatures(::CTFontGetSize(mCTFont));
37211: 
37211:         attrObj =
37211:             ::CFDictionaryCreate(kCFAllocatorDefault,
37211:                                  (const void**) &kCTFontAttributeName,
37211:                                  (const void**) &ctFont,
37211:                                  1, // count of attributes
26627:                                  &kCFTypeDictionaryKeyCallBacks,
26627:                                  &kCFTypeDictionaryValueCallBacks);
37211:         // Having created the dict, we're finished with our ligature-disabled CTFontRef
37211:         ::CFRelease(ctFont);
37211:     } else {
39206:         attrObj = mAttributesDict;
37211:         ::CFRetain(attrObj);
26627:     }
26627: 
37211:     // Now we can create an attributed string
37211:     CFAttributedStringRef attrStringObj =
37211:         ::CFAttributedStringCreate(kCFAllocatorDefault, stringObj, attrObj);
37211:     ::CFRelease(stringObj);
37211:     ::CFRelease(attrObj);
26627: 
37211:     // Create the CoreText line from our string, then we're done with it
37211:     CTLineRef line = ::CTLineCreateWithAttributedString(attrStringObj);
37211:     ::CFRelease(attrStringObj);
26627: 
37211:     // and finally retrieve the glyph data and store into the gfxTextRun
37211:     CFArrayRef glyphRuns = ::CTLineGetGlyphRuns(line);
37211:     PRUint32 numRuns = ::CFArrayGetCount(glyphRuns);
26627: 
37211:     // Iterate through the glyph runs.
37211:     // Note that this includes the bidi wrapper, so we have to be careful
37211:     // not to include the extra glyphs from there
39447:     PRBool success = PR_TRUE;
37211:     for (PRUint32 runIndex = 0; runIndex < numRuns; runIndex++) {
37211:         CTRunRef aCTRun = (CTRunRef)::CFArrayGetValueAtIndex(glyphRuns, runIndex);
39447:         if (SetGlyphsFromRun(aTextRun, aCTRun, startOffset,
39447:                              aRunStart, aRunLength) != NS_OK) {
39447:             success = PR_FALSE;
37211:             break;
26627:         }
39447:     }
26627: 
37211:     ::CFRelease(line);
39447: 
39447:     return success;
26627: }
26627: 
26627: #define SMALL_GLYPH_RUN 128 // preallocated size of our auto arrays for per-glyph data;
26627:                             // some testing indicates that 90%+ of glyph runs will fit
26627:                             // without requiring a separate allocation
26627: 
37211: nsresult
39206: gfxCoreTextShaper::SetGlyphsFromRun(gfxTextRun *aTextRun,
37211:                                     CTRunRef aCTRun,
37211:                                     PRInt32 aStringOffset, // offset in the string used to build the CTLine
37211:                                     PRInt32 aRunStart,     // starting offset of this font run in the gfxTextRun
37211:                                     PRInt32 aRunLength)    // length of this font run in characters
26627: {
37211:     // The textRun has been bidi-wrapped; aStringOffset is the number
37211:     // of chars at the beginning of the CTLine that we should skip.
37211:     // aRunStart and aRunLength define the range of characters
26627:     // within the textRun that are "real" data we need to handle.
26627:     // aCTRun is a glyph run from the CoreText layout process.
26627: 
26627:     PRBool isLTR = !aTextRun->IsRightToLeft();
26627:     PRInt32 direction = isLTR ? 1 : -1;
26627: 
37211:     PRInt32 numGlyphs = ::CTRunGetGlyphCount(aCTRun);
39206:     if (numGlyphs == 0) {
26627:         return NS_OK;
39206:     }
26627: 
37211:     // character offsets get really confusing here, as we have to keep track of
37211:     // (a) the text in the actual textRun we're constructing
37211:     // (b) the "font run" being rendered with the current font, defined by aRunStart and aRunLength
37211:     //     parameters to InitTextRun
37211:     // (c) the string that was handed to CoreText, which contains the text of the font run
37211:     //     plus directional-override padding
37211:     // (d) the CTRun currently being processed, which may be a sub-run of the CoreText line
37211:     //     (but may extend beyond the actual font run into the bidi wrapping text).
37211:     //     aStringOffset tells us how many initial characters of the line to ignore.
37211: 
37211:     // get the source string range within the CTLine's text
37211:     CFRange stringRange = ::CTRunGetStringRange(aCTRun);
37211:     // skip the run if it is entirely outside the actual range of the font run
37211:     if (stringRange.location - aStringOffset + stringRange.length <= 0 ||
39206:         stringRange.location - aStringOffset >= aRunLength) {
26627:         return NS_OK;
39206:     }
26627: 
26627:     // retrieve the laid-out glyph data from the CTRun
26627:     nsAutoArrayPtr<CGGlyph> glyphsArray;
26627:     nsAutoArrayPtr<CGPoint> positionsArray;
26627:     nsAutoArrayPtr<CFIndex> glyphToCharArray;
26627:     const CGGlyph* glyphs = NULL;
26627:     const CGPoint* positions = NULL;
26627:     const CFIndex* glyphToChar = NULL;
26627: 
26627:     // Testing indicates that CTRunGetGlyphsPtr (almost?) always succeeds,
26627:     // and so allocating a new array and copying data with CTRunGetGlyphs
26627:     // will be extremely rare.
26627:     // If this were not the case, we could use an nsAutoTArray<> to
26627:     // try and avoid the heap allocation for small runs.
26627:     // It's possible that some future change to CoreText will mean that
26627:     // CTRunGetGlyphsPtr fails more often; if this happens, nsAutoTArray<>
26627:     // may become an attractive option.
37211:     glyphs = ::CTRunGetGlyphsPtr(aCTRun);
37567:     if (!glyphs) {
37567:         glyphsArray = new (std::nothrow) CGGlyph[numGlyphs];
39206:         if (!glyphsArray) {
26627:             return NS_ERROR_OUT_OF_MEMORY;
39206:         }
37211:         ::CTRunGetGlyphs(aCTRun, ::CFRangeMake(0, 0), glyphsArray.get());
26627:         glyphs = glyphsArray.get();
26627:     }
26627: 
37211:     positions = ::CTRunGetPositionsPtr(aCTRun);
37567:     if (!positions) {
37567:         positionsArray = new (std::nothrow) CGPoint[numGlyphs];
39206:         if (!positionsArray) {
26627:             return NS_ERROR_OUT_OF_MEMORY;
39206:         }
37211:         ::CTRunGetPositions(aCTRun, ::CFRangeMake(0, 0), positionsArray.get());
26627:         positions = positionsArray.get();
26627:     }
26627: 
37211:     // Remember that the glyphToChar indices relate to the CoreText line
37211:     // not to the beginning of the textRun, the font run, or the stringRange of the glyph run
37211:     glyphToChar = ::CTRunGetStringIndicesPtr(aCTRun);
37567:     if (!glyphToChar) {
37567:         glyphToCharArray = new (std::nothrow) CFIndex[numGlyphs];
39206:         if (!glyphToCharArray) {
26627:             return NS_ERROR_OUT_OF_MEMORY;
39206:         }
37211:         ::CTRunGetStringIndices(aCTRun, ::CFRangeMake(0, 0), glyphToCharArray.get());
26627:         glyphToChar = glyphToCharArray.get();
26627:     }
26627: 
37211:     double runWidth = ::CTRunGetTypographicBounds(aCTRun, ::CFRangeMake(0, 0), NULL, NULL, NULL);
26627: 
26627:     nsAutoTArray<gfxTextRun::DetailedGlyph,1> detailedGlyphs;
26627:     gfxTextRun::CompressedGlyph g;
26627:     const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();
26627: 
26627:     // CoreText gives us the glyphindex-to-charindex mapping, which relates each glyph
26627:     // to a source text character; we also need the charindex-to-glyphindex mapping to
26627:     // find the glyph for a given char. Note that some chars may not map to any glyph
26627:     // (ligature continuations), and some may map to several glyphs (eg Indic split vowels).
26627:     // We set the glyph index to NO_GLYPH for chars that have no associated glyph, and we
26627:     // record the last glyph index for cases where the char maps to several glyphs,
26627:     // so that our clumping will include all the glyph fragments for the character.
37211: 
37211:     // The charToGlyph array is indexed by char position within the stringRange of the glyph run.
26627: 
26627:     static const PRInt32 NO_GLYPH = -1;
26627:     nsAutoTArray<PRInt32,SMALL_GLYPH_RUN> charToGlyphArray;
39206:     if (!charToGlyphArray.SetLength(stringRange.length)) {
26627:         return NS_ERROR_OUT_OF_MEMORY;
39206:     }
26627:     PRInt32 *charToGlyph = charToGlyphArray.Elements();
39206:     for (PRInt32 offset = 0; offset < stringRange.length; ++offset) {
26627:         charToGlyph[offset] = NO_GLYPH;
39206:     }
37650:     for (PRInt32 i = 0; i < numGlyphs; ++i) {
37650:         PRInt32 loc = glyphToChar[i] - stringRange.location;
37211:         if (loc >= 0 && loc < stringRange.length) {
37650:             charToGlyph[loc] = i;
37211:         }
37211:     }
26627: 
26627:     // Find character and glyph clumps that correspond, allowing for ligatures,
26627:     // indic reordering, split glyphs, etc.
26627:     //
26627:     // The idea is that we'll find a character sequence starting at the first char of stringRange,
26627:     // and extend it until it includes the character associated with the first glyph;
26627:     // we also extend it as long as there are "holes" in the range of glyphs. So we
26627:     // will eventually have a contiguous sequence of characters, starting at the beginning
26627:     // of the range, that map to a contiguous sequence of glyphs, starting at the beginning
26627:     // of the glyph array. That's a clump; then we update the starting positions and repeat.
26627:     //
26627:     // NB: In the case of RTL layouts, we iterate over the stringRange in reverse.
26627:     //
37211:     // This may find characters that fall outside the range aRunStart:aRunLength,
26627:     // so we won't necessarily use everything we find here.
26627: 
26627:     PRInt32 glyphStart = 0; // looking for a clump that starts at this glyph index
26627:     PRInt32 charStart = isLTR ?
37211:         0 : stringRange.length-1; // and this char index (in the stringRange of the glyph run)
26627: 
26627:     while (glyphStart < numGlyphs) { // keep finding groups until all glyphs are accounted for
26627: 
27838:         PRBool inOrder = PR_TRUE;
27838:         PRInt32 charEnd = glyphToChar[glyphStart] - stringRange.location;
37650:         NS_ASSERTION(charEnd >= 0 && charEnd < stringRange.length,
37650:                      "glyph-to-char mapping points outside string range");
26627:         PRInt32 glyphEnd = glyphStart;
27838:         PRInt32 charLimit = isLTR ? stringRange.length : -1;
27838:         do {
27838:             // This is normally executed once for each iteration of the outer loop,
27838:             // but in unusual cases where the character/glyph association is complex,
27838:             // the initial character range might correspond to a non-contiguous
27838:             // glyph range with "holes" in it. If so, we will repeat this loop to
27838:             // extend the character range until we have a contiguous glyph sequence.
37650:             NS_ASSERTION((direction > 0 && charEnd < charLimit) ||
37650:                          (direction < 0 && charEnd > charLimit),
37650:                          "no characters left in range?");
27838:             charEnd += direction;
37650:             while (charEnd != charLimit && charToGlyph[charEnd] == NO_GLYPH) {
27838:                 charEnd += direction;
27838:             }
26627: 
27838:             // find the maximum glyph index covered by the clump so far
27838:             for (PRInt32 i = charStart; i != charEnd; i += direction) {
27838:                 if (charToGlyph[i] != NO_GLYPH) {
71173:                     glyphEnd = NS_MAX(glyphEnd, charToGlyph[i] + 1); // update extent of glyph range
27838:                 }
27838:             }
26627: 
27838:             if (glyphEnd == glyphStart + 1) {
27838:                 // for the common case of a single-glyph clump, we can skip the following checks
27838:                 break;
27838:             }
26627: 
27838:             if (glyphEnd == glyphStart) {
27838:                 // no glyphs, try to extend the clump
27838:                 continue;
27838:             }
26627: 
27838:             // check whether all glyphs in the range are associated with the characters
27838:             // in our clump; if not, we have a discontinuous range, and should extend it
27838:             // unless we've reached the end of the text
27838:             PRBool allGlyphsAreWithinCluster = PR_TRUE;
27838:             PRInt32 prevGlyphCharIndex = charStart;
27838:             for (PRInt32 i = glyphStart; i < glyphEnd; ++i) {
27838:                 PRInt32 glyphCharIndex = glyphToChar[i] - stringRange.location;
26627:                 if (isLTR) {
27838:                     if (glyphCharIndex < charStart || glyphCharIndex >= charEnd) {
27838:                         allGlyphsAreWithinCluster = PR_FALSE;
27838:                         break;
27838:                     }
27838:                     if (glyphCharIndex < prevGlyphCharIndex) {
27838:                         inOrder = PR_FALSE;
27838:                     }
27838:                     prevGlyphCharIndex = glyphCharIndex;
26627:                 } else {
27838:                     if (glyphCharIndex > charStart || glyphCharIndex <= charEnd) {
27838:                         allGlyphsAreWithinCluster = PR_FALSE;
27838:                         break;
26627:                     }
27838:                     if (glyphCharIndex > prevGlyphCharIndex) {
27838:                         inOrder = PR_FALSE;
27838:                     }
27838:                     prevGlyphCharIndex = glyphCharIndex;
27838:                 }
27838:             }
27838:             if (allGlyphsAreWithinCluster) {
27838:                 break;
27838:             }
27838:         } while (charEnd != charLimit);
26627: 
26627:         NS_ASSERTION(glyphStart < glyphEnd, "character/glyph clump contains no glyphs!");
26627:         NS_ASSERTION(charStart != charEnd, "character/glyph contains no characters!");
26627: 
26627:         // Now charStart..charEnd is a ligature clump, corresponding to glyphStart..glyphEnd;
26627:         // Set baseCharIndex to the char we'll actually attach the glyphs to (1st of ligature),
37211:         // and endCharIndex to the limit (position beyond the last char),
37211:         // adjusting for the offset of the stringRange relative to the textRun.
26627:         PRInt32 baseCharIndex, endCharIndex;
26627:         if (isLTR) {
39206:             while (charEnd < stringRange.length && charToGlyph[charEnd] == NO_GLYPH) {
26627:                 charEnd++;
39206:             }
37211:             baseCharIndex = charStart + stringRange.location - aStringOffset + aRunStart;
37211:             endCharIndex = charEnd + stringRange.location - aStringOffset + aRunStart;
26627:         } else {
39206:             while (charEnd >= 0 && charToGlyph[charEnd] == NO_GLYPH) {
26627:                 charEnd--;
39206:             }
37211:             baseCharIndex = charEnd + stringRange.location - aStringOffset + aRunStart + 1;
37211:             endCharIndex = charStart + stringRange.location - aStringOffset + aRunStart + 1;
26627:         }
26627: 
27838:         // Then we check if the clump falls outside our actual string range; if so, just go to the next.
37211:         if (endCharIndex <= aRunStart || baseCharIndex >= aRunStart + aRunLength) {
26627:             glyphStart = glyphEnd;
26627:             charStart = charEnd;
26627:             continue;
26627:         }
27838:         // Ensure we won't try to go beyond the valid length of the textRun's text
71173:         baseCharIndex = NS_MAX(baseCharIndex, aRunStart);
71173:         endCharIndex = NS_MIN(endCharIndex, aRunStart + aRunLength);
26627: 
26627:         // Now we're ready to set the glyph info in the textRun; measure the glyph width
26627:         // of the first (perhaps only) glyph, to see if it is "Simple"
26627:         double toNextGlyph;
39206:         if (glyphStart < numGlyphs-1) {
26627:             toNextGlyph = positions[glyphStart+1].x - positions[glyphStart].x;
39206:         } else {
26627:             toNextGlyph = positions[0].x + runWidth - positions[glyphStart].x;
39206:         }
26627:         PRInt32 advance = PRInt32(toNextGlyph * appUnitsPerDevUnit);
26627: 
26627:         // Check if it's a simple one-to-one mapping
26627:         PRInt32 glyphsInClump = glyphEnd - glyphStart;
26627:         if (glyphsInClump == 1 &&
26627:             gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyphs[glyphStart]) &&
26627:             gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
37211:             aTextRun->IsClusterStart(baseCharIndex) &&
26627:             positions[glyphStart].y == 0.0)
26627:         {
37211:             aTextRun->SetSimpleGlyph(baseCharIndex,
26627:                                      g.SetSimpleGlyph(advance, glyphs[glyphStart]));
26627:         } else {
26627:             // collect all glyphs in a list to be assigned to the first char;
26627:             // there must be at least one in the clump, and we already measured its advance,
26627:             // hence the placement of the loop-exit test and the measurement of the next glyph
26627:             while (1) {
26627:                 gfxTextRun::DetailedGlyph *details = detailedGlyphs.AppendElement();
26627:                 details->mGlyphID = glyphs[glyphStart];
26627:                 details->mXOffset = 0;
26627:                 details->mYOffset = -positions[glyphStart].y * appUnitsPerDevUnit;
26627:                 details->mAdvance = advance;
39206:                 if (++glyphStart >= glyphEnd) {
26627:                    break;
39206:                 }
39206:                 if (glyphStart < numGlyphs-1) {
26627:                     toNextGlyph = positions[glyphStart+1].x - positions[glyphStart].x;
39206:                 } else {
26627:                     toNextGlyph = positions[0].x + runWidth - positions[glyphStart].x;
39206:                 }
26627:                 advance = PRInt32(toNextGlyph * appUnitsPerDevUnit);
26627:             }
26627: 
26627:             gfxTextRun::CompressedGlyph g;
37211:             g.SetComplex(aTextRun->IsClusterStart(baseCharIndex),
26627:                          PR_TRUE, detailedGlyphs.Length());
37211:             aTextRun->SetGlyphs(baseCharIndex, g, detailedGlyphs.Elements());
26627: 
26627:             detailedGlyphs.Clear();
26627:         }
26627: 
26627:         // the rest of the chars in the group are ligature continuations, no associated glyphs
37211:         while (++baseCharIndex != endCharIndex && baseCharIndex < aRunStart + aRunLength) {
37211:             g.SetComplex(inOrder && aTextRun->IsClusterStart(baseCharIndex),
26627:                          PR_FALSE, 0);
37211:             aTextRun->SetGlyphs(baseCharIndex, g, nsnull);
26627:         }
26627: 
26627:         glyphStart = glyphEnd;
26627:         charStart = charEnd;
26627:     }
26627: 
26627:     return NS_OK;
26627: }
26627: 
37211: // Construct the font attribute descriptor that we'll apply by default when creating a CTFontRef.
37211: // This will turn off line-edge swashes by default, because we don't know the actual line breaks
37211: // when doing glyph shaping.
37211: void
39206: gfxCoreTextShaper::CreateDefaultFeaturesDescriptor()
26627: {
39206:     if (sDefaultFeaturesDescriptor != NULL) {
37211:         return;
39206:     }
37211: 
37211:     SInt16 val = kSmartSwashType;
37211:     CFNumberRef swashesType =
37211:         ::CFNumberCreate(kCFAllocatorDefault,
37211:                          kCFNumberSInt16Type,
37211:                          &val);
37211:     val = kLineInitialSwashesOffSelector;
37211:     CFNumberRef lineInitialsOffSelector =
37211:         ::CFNumberCreate(kCFAllocatorDefault,
37211:                          kCFNumberSInt16Type,
37211:                          &val);
37211: 
37211:     CFTypeRef keys[]   = { kCTFontFeatureTypeIdentifierKey,
37211:                            kCTFontFeatureSelectorIdentifierKey };
37211:     CFTypeRef values[] = { swashesType,
37211:                            lineInitialsOffSelector };
37211:     CFDictionaryRef featureSettings[2];
37211:     featureSettings[0] =
37211:         ::CFDictionaryCreate(kCFAllocatorDefault,
37211:                              (const void **) keys,
37211:                              (const void **) values,
37211:                              NS_ARRAY_LENGTH(keys),
37211:                              &kCFTypeDictionaryKeyCallBacks,
37211:                              &kCFTypeDictionaryValueCallBacks);
37211:     ::CFRelease(lineInitialsOffSelector);
37211: 
37211:     val = kLineFinalSwashesOffSelector;
37211:     CFNumberRef lineFinalsOffSelector =
37211:         ::CFNumberCreate(kCFAllocatorDefault,
37211:                          kCFNumberSInt16Type,
37211:                          &val);
37211:     values[1] = lineFinalsOffSelector;
37211:     featureSettings[1] =
37211:         ::CFDictionaryCreate(kCFAllocatorDefault,
37211:                              (const void **) keys,
37211:                              (const void **) values,
37211:                              NS_ARRAY_LENGTH(keys),
37211:                              &kCFTypeDictionaryKeyCallBacks,
37211:                              &kCFTypeDictionaryValueCallBacks);
37211:     ::CFRelease(lineFinalsOffSelector);
37211:     ::CFRelease(swashesType);
37211: 
37211:     CFArrayRef featuresArray =
37211:         ::CFArrayCreate(kCFAllocatorDefault,
37211:                         (const void **) featureSettings,
37211:                         NS_ARRAY_LENGTH(featureSettings),
37211:                         &kCFTypeArrayCallBacks);
37211:     ::CFRelease(featureSettings[0]);
37211:     ::CFRelease(featureSettings[1]);
37211: 
37211:     const CFTypeRef attrKeys[]   = { kCTFontFeatureSettingsAttribute };
37211:     const CFTypeRef attrValues[] = { featuresArray };
37211:     CFDictionaryRef attributesDict =
37211:         ::CFDictionaryCreate(kCFAllocatorDefault,
37211:                              (const void **) attrKeys,
37211:                              (const void **) attrValues,
37211:                              NS_ARRAY_LENGTH(attrKeys),
37211:                              &kCFTypeDictionaryKeyCallBacks,
37211:                              &kCFTypeDictionaryValueCallBacks);
37211:     ::CFRelease(featuresArray);
37211: 
37211:     sDefaultFeaturesDescriptor =
37211:         ::CTFontDescriptorCreateWithAttributes(attributesDict);
37211:     ::CFRelease(attributesDict);
26627: }
26627: 
72435: // Create a CTFontRef, with the Common Ligatures feature disabled
37211: CTFontRef
72435: gfxCoreTextShaper::CreateCTFontWithDisabledLigatures(CGFloat aSize)
37211: {
37211:     if (sDisableLigaturesDescriptor == NULL) {
37211:         // initialize cached descriptor to turn off the Common Ligatures feature
37211:         SInt16 val = kLigaturesType;
37211:         CFNumberRef ligaturesType =
37211:             ::CFNumberCreate(kCFAllocatorDefault,
37211:                              kCFNumberSInt16Type,
37211:                              &val);
37211:         val = kCommonLigaturesOffSelector;
37211:         CFNumberRef commonLigaturesOffSelector =
37211:             ::CFNumberCreate(kCFAllocatorDefault,
37211:                              kCFNumberSInt16Type,
37211:                              &val);
26627: 
37211:         const CFTypeRef keys[]   = { kCTFontFeatureTypeIdentifierKey,
37211:                                      kCTFontFeatureSelectorIdentifierKey };
37211:         const CFTypeRef values[] = { ligaturesType,
37211:                                      commonLigaturesOffSelector };
37211:         CFDictionaryRef featureSettingDict =
37211:             ::CFDictionaryCreate(kCFAllocatorDefault,
37211:                                  (const void **) keys,
37211:                                  (const void **) values,
37211:                                  NS_ARRAY_LENGTH(keys),
37211:                                  &kCFTypeDictionaryKeyCallBacks,
37211:                                  &kCFTypeDictionaryValueCallBacks);
37211:         ::CFRelease(ligaturesType);
37211:         ::CFRelease(commonLigaturesOffSelector);
26627: 
37211:         CFArrayRef featuresArray =
37211:             ::CFArrayCreate(kCFAllocatorDefault,
37211:                             (const void **) &featureSettingDict,
37211:                             1,
37211:                             &kCFTypeArrayCallBacks);
37211:         ::CFRelease(featureSettingDict);
26627: 
37211:         CFDictionaryRef attributesDict =
37211:             ::CFDictionaryCreate(kCFAllocatorDefault,
37211:                                  (const void **) &kCTFontFeatureSettingsAttribute,
37211:                                  (const void **) &featuresArray,
37211:                                  1, // count of keys & values
37211:                                  &kCFTypeDictionaryKeyCallBacks,
37211:                                  &kCFTypeDictionaryValueCallBacks);
37211:         ::CFRelease(featuresArray);
26627: 
37211:         sDisableLigaturesDescriptor =
72435:             ::CTFontDescriptorCreateCopyWithAttributes(GetDefaultFeaturesDescriptor(),
72435:                                                        attributesDict);
37211:         ::CFRelease(attributesDict);
26627:     }
26627: 
72435:     if (gfxMacPlatformFontList::UseATSFontEntry()) {
72435:         ATSFontEntry *fe = static_cast<ATSFontEntry*>(mFont->GetFontEntry());
72435:         return ::CTFontCreateWithPlatformFont(fe->GetATSFontRef(), aSize, NULL,
72435:                                               sDisableLigaturesDescriptor);
72435:     }
72435: 
72435:     gfxMacFont *f = static_cast<gfxMacFont*>(mFont);
72435:     return ::CTFontCreateWithGraphicsFont(f->GetCGFontRef(), aSize, NULL,
72435:                                           sDisableLigaturesDescriptor);
26627: }
26627: 
26627: void
39206: gfxCoreTextShaper::Shutdown() // [static]
26627: {
37211:     if (sDisableLigaturesDescriptor != NULL) {
37211:         ::CFRelease(sDisableLigaturesDescriptor);
37211:         sDisableLigaturesDescriptor = NULL;
26627:     }        
37211:     if (sDefaultFeaturesDescriptor != NULL) {
37211:         ::CFRelease(sDefaultFeaturesDescriptor);
37211:         sDefaultFeaturesDescriptor = NULL;
26627:     }
37211: }
