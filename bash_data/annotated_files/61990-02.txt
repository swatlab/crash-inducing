35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #ifndef dom_plugins_PluginInstanceChild_h
35893: #define dom_plugins_PluginInstanceChild_h 1
35740: 
35898: #include "mozilla/plugins/PPluginInstanceChild.h"
35893: #include "mozilla/plugins/PluginScriptableObjectChild.h"
36138: #include "mozilla/plugins/StreamNotifyChild.h"
61408: #include "mozilla/plugins/PPluginSurfaceChild.h"
36124: #if defined(OS_WIN)
36124: #include "mozilla/gfx/SharedDIBWin.h"
41029: #elif defined(OS_MACOSX)
41029: #include "nsCoreAnimationSupport.h"
41029: #include "base/timer.h"
36124: #endif
35740: 
35740: #include "npfunctions.h"
35925: #include "nsAutoPtr.h"
35925: #include "nsTArray.h"
37348: #include "ChildAsyncCall.h"
37348: #include "ChildTimer.h"
38281: #include "nsRect.h"
38669: #include "nsTHashtable.h"
44183: #include "mozilla/PaintTracker.h"
53942: #include "gfxASurface.h"
35740: 
35740: namespace mozilla {
35740: namespace plugins {
35740: 
35898: class PBrowserStreamChild;
35898: class BrowserStreamChild;
39283: class StreamNotifyChild;
35897: 
35898: class PluginInstanceChild : public PPluginInstanceChild
35740: {
35938:     friend class BrowserStreamChild;
35938:     friend class PluginStreamChild;
39283:     friend class StreamNotifyChild; 
35938: 
35747: #ifdef OS_WIN
35747:     friend LRESULT CALLBACK PluginWindowProc(HWND hWnd,
35747:                                              UINT message,
35747:                                              WPARAM wParam,
35747:                                              LPARAM lParam);
35747: #endif
35747: 
35746: protected:
39279:     virtual bool AnswerNPP_SetWindow(const NPRemoteWindow& window);
35746: 
35951:     virtual bool
35951:     AnswerNPP_GetValue_NPPVpluginNeedsXEmbed(bool* needs, NPError* rv);
35926:     virtual bool
35925:     AnswerNPP_GetValue_NPPVpluginScriptableNPObject(PPluginScriptableObjectChild** value,
35925:                                                     NPError* result);
35740: 
35933:     virtual bool
37350:     AnswerNPP_SetValue_NPNVprivateModeBool(const bool& value, NPError* result);
37350: 
37350:     virtual bool
36011:     AnswerNPP_HandleEvent(const NPRemoteEvent& event, int16_t* handled);
39883:     virtual bool
39883:     AnswerNPP_HandleEvent_Shmem(const NPRemoteEvent& event, Shmem& mem, int16_t* handled, Shmem* rtnmem);
41029:     virtual bool
41029:     AnswerNPP_HandleEvent_IOSurface(const NPRemoteEvent& event, const uint32_t& surface, int16_t* handled);
35933: 
53940:     // Async rendering
53940:     virtual bool
53940:     RecvAsyncSetWindow(const gfxSurfaceType& aSurfaceType,
53940:                        const NPRemoteWindow& aWindow);
53940: 
58646:     virtual void
58646:     DoAsyncSetWindow(const gfxSurfaceType& aSurfaceType,
58646:                      const NPRemoteWindow& aWindow,
58646:                      bool aIsAsync);
58646: 
61408:     virtual PPluginSurfaceChild* AllocPPluginSurface(const WindowsSharedMemoryHandle&,
61408:                                                      const gfxIntSize&, const bool&) {
61408:         return new PPluginSurfaceChild();
61408:     }
61408: 
61408:     virtual bool DeallocPPluginSurface(PPluginSurfaceChild* s) {
61408:         delete s;
61408:         return true;
61408:     }
61408: 
39265:     NS_OVERRIDE
39265:     virtual bool
39265:     AnswerPaint(const NPRemoteEvent& event, int16_t* handled)
39265:     {
44183:         PaintTracker pt;
39265:         return AnswerNPP_HandleEvent(event, handled);
39265:     }
39265: 
39720:     NS_OVERRIDE
39720:     virtual bool
39720:     RecvWindowPosChanged(const NPRemoteEvent& event);
39720: 
37311:     virtual bool
37311:     AnswerNPP_Destroy(NPError* result);
37311: 
35898:     virtual PPluginScriptableObjectChild*
35943:     AllocPPluginScriptableObject();
35835: 
35926:     virtual bool
35943:     DeallocPPluginScriptableObject(PPluginScriptableObjectChild* aObject);
35835: 
38994:     NS_OVERRIDE virtual bool
38994:     RecvPPluginScriptableObjectConstructor(PPluginScriptableObjectChild* aActor);
35965: 
35898:     virtual PBrowserStreamChild*
35943:     AllocPBrowserStream(const nsCString& url,
35893:                         const uint32_t& length,
35890:                         const uint32_t& lastmodified,
35990:                         PStreamNotifyChild* notifyData,
35890:                         const nsCString& headers,
35893:                         const nsCString& mimeType,
35893:                         const bool& seekable,
35893:                         NPError* rv,
35893:                         uint16_t *stype);
35890: 
35926:     virtual bool
37126:     AnswerPBrowserStreamConstructor(
37126:             PBrowserStreamChild* aActor,
37126:             const nsCString& url,
37126:             const uint32_t& length,
37126:             const uint32_t& lastmodified,
37126:             PStreamNotifyChild* notifyData,
37126:             const nsCString& headers,
37126:             const nsCString& mimeType,
37126:             const bool& seekable,
37126:             NPError* rv,
37126:             uint16_t* stype);
37126:         
37126:     virtual bool
36138:     DeallocPBrowserStream(PBrowserStreamChild* stream);
35890: 
35938:     virtual PPluginStreamChild*
35943:     AllocPPluginStream(const nsCString& mimeType,
35938:                        const nsCString& target,
35938:                        NPError* result);
35938: 
35938:     virtual bool
36138:     DeallocPPluginStream(PPluginStreamChild* stream);
35938: 
35904:     virtual PStreamNotifyChild*
35943:     AllocPStreamNotify(const nsCString& url, const nsCString& target,
35904:                        const bool& post, const nsCString& buffer,
35904:                        const bool& file,
35904:                        NPError* result);
35904: 
36110:     NS_OVERRIDE virtual bool
36138:     DeallocPStreamNotify(PStreamNotifyChild* notifyData);
35904: 
37550:     virtual bool
37550:     AnswerSetPluginFocus();
37550: 
37554:     virtual bool
37554:     AnswerUpdateWindow();
37554: 
35740: public:
58734:     PluginInstanceChild(const NPPluginFuncs* aPluginIface);
35740: 
35893:     virtual ~PluginInstanceChild();
35740: 
35747:     bool Initialize();
35740: 
35740:     NPP GetNPP()
35740:     {
35740:         return &mData;
35740:     }
35740: 
35893:     NPError
35951:     NPN_GetValue(NPNVariable aVariable, void* aValue);
35951: 
35951:     NPError
35951:     NPN_SetValue(NPPVariable aVariable, void* aValue);
35740: 
35925:     PluginScriptableObjectChild*
35945:     GetActorForNPObject(NPObject* aObject);
35925: 
35938:     NPError
35938:     NPN_NewStream(NPMIMEType aMIMEType, const char* aWindow,
35938:                   NPStream** aStream);
35938: 
36835:     void InvalidateRect(NPRect* aInvalidRect);
36082: 
37348:     uint32_t ScheduleTimer(uint32_t interval, bool repeat, TimerFunc func);
37348:     void UnscheduleTimer(uint32_t id);
37348: 
39979:     void AsyncCall(PluginThreadCallback aFunc, void* aUserData);
39979: 
58734:     int GetQuirks();
38660: 
60021:     void NPN_URLRedirectResponse(void* notifyData, NPBool allow);
60021: 
56343: private:
56343:     friend class PluginModuleChild;
56343: 
38354:     NPError
38354:     InternalGetNPObjectForValue(NPNVariable aValue,
38354:                                 NPObject** aObject);
38354: 
35747: #if defined(OS_WIN)
35747:     static bool RegisterWindowClass();
35747:     bool CreatePluginWindow();
35747:     void DestroyPluginWindow();
35747:     void ReparentPluginWindow(HWND hWndParent);
35747:     void SizePluginWindow(int width, int height);
38103:     int16_t WinlessHandleEvent(NPEvent& event);
39729:     void CreateWinlessPopupSurrogate();
39729:     void DestroyWinlessPopupSurrogate();
39729:     void InitPopupMenuHook();
41342:     void SetupFlashMsgThrottle();
41997:     void UnhookWinlessFlashThrottle();
56343:     void HookSetWindowLongPtr();
56343:     static inline PRBool SetWindowLongHookCheck(HWND hWnd,
56343:                                                 int nIndex,
56343:                                                 LONG_PTR newLong);
41342:     void FlashThrottleMessage(HWND, UINT, WPARAM, LPARAM, bool);
35747:     static LRESULT CALLBACK DummyWindowProc(HWND hWnd,
35747:                                             UINT message,
35747:                                             WPARAM wParam,
35747:                                             LPARAM lParam);
35747:     static LRESULT CALLBACK PluginWindowProc(HWND hWnd,
35747:                                              UINT message,
35747:                                              WPARAM wParam,
35747:                                              LPARAM lParam);
39729:     static BOOL WINAPI TrackPopupHookProc(HMENU hMenu,
39729:                                           UINT uFlags,
39729:                                           int x,
39729:                                           int y,
39729:                                           int nReserved,
39729:                                           HWND hWnd,
39729:                                           CONST RECT *prcRect);
41342:     static BOOL CALLBACK EnumThreadWindowsCallback(HWND hWnd,
41342:                                                    LPARAM aParam);
41342:     static LRESULT CALLBACK WinlessHiddenFlashWndProc(HWND hWnd,
41342:                                                       UINT message,
41342:                                                       WPARAM wParam,
41342:                                                       LPARAM lParam);
56343: #ifdef _WIN64
56343:     static LONG_PTR WINAPI SetWindowLongPtrAHook(HWND hWnd,
56343:                                                  int nIndex,
56343:                                                  LONG_PTR newLong);
56343:     static LONG_PTR WINAPI SetWindowLongPtrWHook(HWND hWnd,
56343:                                                  int nIndex,
56343:                                                  LONG_PTR newLong);
56343:                       
56343: #else
56343:     static LONG WINAPI SetWindowLongAHook(HWND hWnd,
56343:                                           int nIndex,
56343:                                           LONG newLong);
56343:     static LONG WINAPI SetWindowLongWHook(HWND hWnd,
56343:                                           int nIndex,
56343:                                           LONG newLong);
56343: #endif
60621:     void HookSystemParametersInfo();
41342: 
41342:     class FlashThrottleAsyncMsg : public ChildAsyncCall
41342:     {
41342:       public:
41342:         FlashThrottleAsyncMsg();
41342:         FlashThrottleAsyncMsg(PluginInstanceChild* aInst, 
41342:                               HWND aWnd, UINT aMsg,
41342:                               WPARAM aWParam, LPARAM aLParam,
41342:                               bool isWindowed)
41342:           : ChildAsyncCall(aInst, nsnull, nsnull),
41342:           mWnd(aWnd),
41342:           mMsg(aMsg),
41342:           mWParam(aWParam),
41342:           mLParam(aLParam),
41342:           mWindowed(isWindowed)
41342:         {}
41342: 
41342:         NS_OVERRIDE void Run();
41342: 
41342:         WNDPROC GetProc();
41342:         HWND GetWnd() { return mWnd; }
41342:         UINT GetMsg() { return mMsg; }
41342:         WPARAM GetWParam() { return mWParam; }
41342:         LPARAM GetLParam() { return mLParam; }
41342: 
41342:       private:
41342:         HWND                 mWnd;
41342:         UINT                 mMsg;
41342:         WPARAM               mWParam;
41342:         LPARAM               mLParam;
41342:         bool                 mWindowed;
41342:     };
41342: 
35747: #endif
35747: 
35740:     const NPPluginFuncs* mPluginIface;
35740:     NPP_t mData;
35740:     NPWindow mWindow;
37311: 
38354:     // Cached scriptable actors to avoid IPC churn
38354:     PluginScriptableObjectChild* mCachedWindowActor;
38354:     PluginScriptableObjectChild* mCachedElementActor;
38354: 
35980: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35740:     NPSetWindowCallbackStruct mWsInfo;
35747: #elif defined(OS_WIN)
35747:     HWND mPluginWindowHWND;
35747:     WNDPROC mPluginWndProc;
35747:     HWND mPluginParentHWND;
38103:     int mNestedEventLevelDepth;
38103:     HWND mCachedWinlessPluginHWND;
39729:     HWND mWinlessPopupSurrogateHWND;
38281:     nsIntPoint mPluginSize;
41342:     WNDPROC mWinlessThrottleOldWndProc;
41997:     HWND mWinlessHiddenMsgHWND;
35746: #endif
35925: 
37348:     friend class ChildAsyncCall;
39979: 
39979:     Mutex mAsyncCallMutex;
37348:     nsTArray<ChildAsyncCall*> mPendingAsyncCalls;
37884:     nsTArray<nsAutoPtr<ChildTimer> > mTimers;
37348: 
38669:     /**
38669:      * During destruction we enumerate all remaining scriptable objects and
38669:      * invalidate/delete them. Enumeration can re-enter, so maintain a
38669:      * hash separate from PluginModuleChild.mObjectMap.
38669:      */
38669:     nsAutoPtr< nsTHashtable<DeletingObjectEntry> > mDeletingHash;
38669: 
36124: #if defined(OS_WIN)
36124: private:
36124:     // Shared dib rendering management for windowless plugins.
39279:     bool SharedSurfaceSetWindow(const NPRemoteWindow& aWindow);
36270:     int16_t SharedSurfacePaint(NPEvent& evcopy);
36124:     void SharedSurfaceRelease();
36270:     bool AlphaExtractCacheSetup();
36270:     void AlphaExtractCacheRelease();
36270:     void UpdatePaintClipRect(RECT* aRect);
36124: 
36124: private:
36270:     enum {
36270:       RENDER_NATIVE,
36270:       RENDER_BACK_ONE,
36270:       RENDER_BACK_TWO 
36270:     };
36124:     gfx::SharedDIBWin mSharedSurfaceDib;
36270:     struct {
36270:       PRUint16        doublePass;
36270:       HDC             hdc;
36270:       HBITMAP         bmp;
36270:     } mAlphaExtract;
36124: #endif // defined(OS_WIN)
40120: #if defined(OS_MACOSX)
40120: private:
54520: #if defined(__i386__)
54520:     NPEventModel          mEventModel;
54520: #endif
40120:     CGColorSpaceRef       mShColorSpace;
40120:     CGContextRef          mShContext;
41029:     int16_t               mDrawingModel;
41029:     nsCARenderer          mCARenderer;
48383: 
48383: public:
48383:     const NPCocoaEvent* getCurrentEvent() {
48383:         return mCurrentEvent;
48383:     }
48383: 
54520: #if defined(__i386__)
54520:     NPEventModel EventModel() { return mEventModel; }
54520: #endif
54520: 
48383: private:
48383:     const NPCocoaEvent   *mCurrentEvent;
40120: #endif
53942: 
57225:     bool IsVisible() {
57225:         return mWindow.clipRect.top != 0 ||
57225:             mWindow.clipRect.left != 0 ||
57225:             mWindow.clipRect.bottom != 0 ||
57225:             mWindow.clipRect.right != 0;
57225:     }
57225: 
53942:     // ShowPluginFrame - in general does four things:
53942:     // 1) Create mCurrentSurface optimized for rendering to parent process
53942:     // 2) Updated mCurrentSurface to be a complete copy of mBackSurface
53942:     // 3) Draw the invalidated plugin area into mCurrentSurface
53942:     // 4) Send it to parent process.
57202:     bool ShowPluginFrame(void);
54551: 
57213:     // If we can read back safely from mBackSurface, copy
57213:     // mSurfaceDifferenceRect from mBackSurface to mFrontSurface.
57213:     // @return Whether the back surface could be read.
57213:     bool ReadbackDifferenceRect(const nsIntRect& rect);
53942: 
53942:     // Post ShowPluginFrame task
53942:     void AsyncShowPluginFrame(void);
53942: 
57202:     // In the PaintRect functions, aSurface is the size of the full plugin
57202:     // window. Each PaintRect function renders into the subrectangle aRect of
57202:     // aSurface (possibly more if we're working around a Flash bug).
53942: 
53942:     // Paint plugin content rectangle to surface with bg color filling
53942:     void PaintRectToSurface(const nsIntRect& aRect,
53942:                             gfxASurface* aSurface,
53942:                             const gfxRGBA& aColor);
53942: 
53942:     // Render plugin content to surface using
53942:     // white/black image alpha extraction algorithm
53942:     void PaintRectWithAlphaExtraction(const nsIntRect& aRect,
53942:                                       gfxASurface* aSurface);
53942: 
53942:     // Call plugin NPAPI function to render plugin content to surface
53942:     // @param - aSurface - should be compatible with current platform plugin rendering
53942:     // @return - FALSE if plugin not painted to surface
53942:     void PaintRectToPlatformSurface(const nsIntRect& aRect,
53942:                                     gfxASurface* aSurface);
53942: 
53942:     // Update NPWindow platform attributes and call plugin "setwindow"
53942:     // @param - aForceSetWindow - call setwindow even if platform attributes are the same
57202:     void UpdateWindowAttributes(bool aForceSetWindow = false);
53942: 
53942:     // Create optimized mCurrentSurface for parent process rendering
53942:     // @return FALSE if optimized surface not created
57202:     bool CreateOptSurface(void);
53942: 
53942:     // Create mHelperSurface if mCurrentSurface non compatible with plugins
53942:     // @return TRUE if helper surface created successfully, or not needed
57202:     bool MaybeCreatePlatformHelperSurface(void);
53942: 
53942:     // Make sure that we have surface for rendering
57202:     bool EnsureCurrentBuffer(void);
53942: 
53942:     // Helper function for delayed InvalidateRect call
53942:     // non null mCurrentInvalidateTask will call this function
53942:     void InvalidateRectDelayed(void);
53942: 
61408:     // Clear mCurrentSurface/mCurrentSurfaceActor/mHelperSurface
61408:     void ClearCurrentSurface();
61408: 
61408:     // Swap mCurrentSurface/mBackSurface and their associated actors
61408:     void SwapSurfaces();
61408: 
61408:     // Clear all surfaces in response to NPP_Destroy
61408:     void ClearAllSurfaces();
61408: 
53942:     // Set as true when SetupLayer called
53942:     // and go with different path in InvalidateRect function
57202:     bool mLayersRendering;
57202: 
53942:     // Current surface available for rendering
53942:     nsRefPtr<gfxASurface> mCurrentSurface;
57202: 
53942:     // Back surface, just keeping reference to
53942:     // surface which is on ParentProcess side
53942:     nsRefPtr<gfxASurface> mBackSurface;
57202: 
61408: #ifdef XP_WIN
61408:     // These actors mirror mCurrentSurface/mBackSurface
61408:     PPluginSurfaceChild* mCurrentSurfaceActor;
61408:     PPluginSurfaceChild* mBackSurfaceActor;
61408: #endif
61408: 
57214:     // Accumulated invalidate rect, while back buffer is not accessible,
57214:     // in plugin coordinates.
53942:     nsIntRect mAccumulatedInvalidRect;
57202: 
53942:     // Plugin only call SetTransparent
53942:     // and does not remember their transparent state
53942:     // and p->getvalue return always false
57202:     bool mIsTransparent;
57202: 
53942:     // Surface type optimized of parent process
53942:     gfxSurfaceType mSurfaceType;
53942: 
53942:     // Keep InvalidateRect task pointer to be able Cancel it on Destroy
53942:     CancelableTask *mCurrentInvalidateTask;
53942: 
58646:     // Keep AsyncSetWindow task pointer to be able to Cancel it on Destroy
58646:     CancelableTask *mCurrentAsyncSetWindowTask;
58646: 
53942:     // True while plugin-child in plugin call
53942:     // Use to prevent plugin paint re-enter
57202:     bool mPendingPluginCall;
53942: 
53942:     // On some platforms, plugins may not support rendering to a surface with
53942:     // alpha, or not support rendering to an image surface.
53942:     // In those cases we need to draw to a temporary platform surface; we cache
53942:     // that surface here.
53942:     nsRefPtr<gfxASurface> mHelperSurface;
53942: 
53942:     // true when plugin does not support painting to ARGB32 surface
53942:     // this is false for maemo platform, and false if plugin
53942:     // supports NPPVpluginTransparentAlphaBool (which is not part of NPAPI yet)
57202:     bool mDoAlphaExtraction;
53942: 
60641:     // true when the plugin has painted at least once. We use this to ensure
60641:     // that we ask a plugin to paint at least once even if it's invisible;
60641:     // some plugin (instances) rely on this in order to work properly.
60641:     bool mHasPainted;
60641: 
53942:     // Cached rectangle rendered to previous surface(mBackSurface)
57214:     // Used for reading back to current surface and syncing data,
57214:     // in plugin coordinates.
53942:     nsIntRect mSurfaceDifferenceRect;
53942: 
54931: #if (MOZ_PLATFORM_MAEMO == 5) || (MOZ_PLATFORM_MAEMO == 6)
54551:     // Maemo5 Flash does not remember WindowlessLocal state
54551:     // we should listen for NPP values negotiation and remember it
54551:     PRPackedBool          mMaemoImageRendering;
54551: #endif
35740: };
35740: 
35740: } // namespace plugins
35740: } // namespace mozilla
35740: 
35893: #endif // ifndef dom_plugins_PluginInstanceChild_h
