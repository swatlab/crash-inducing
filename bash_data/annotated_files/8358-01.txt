   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Mats Palmgren <mats.palmgren@bredband.net>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsFileControlFrame.h"
   1: 
   1: #include "nsIContent.h"
   1: #include "prtypes.h"
   1: #include "nsIAtom.h"
   1: #include "nsPresContext.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsWidgetsCID.h"
   1: #include "nsIComponentManager.h"
   1: #include "nsHTMLParts.h"
   1: #include "nsIDOMHTMLInputElement.h"
   1: #include "nsIFormControl.h"
   1: #include "nsINameSpaceManager.h"
   1: #include "nsCOMPtr.h"
   1: #include "nsIDOMElement.h"
   1: #include "nsIDOMDocument.h"
   1: #include "nsIDocument.h"
   1: #include "nsIDOMMouseListener.h"
   1: #include "nsIPresShell.h"
   1: #include "nsIDOMHTMLInputElement.h"
   1: #include "nsXPCOM.h"
   1: #include "nsISupportsPrimitives.h"
   1: #include "nsIComponentManager.h"
   1: #include "nsPIDOMWindow.h"
   1: #include "nsIFilePicker.h"
   1: #include "nsIDOMMouseEvent.h"
   1: #include "nsINodeInfo.h"
1418: #include "nsIDOMEventTarget.h"
   1: #include "nsILocalFile.h"
   1: #include "nsIFileControlElement.h"
   1: #include "nsNodeInfoManager.h"
   1: #include "nsContentCreatorFunctions.h"
   1: #include "nsContentUtils.h"
   1: #include "nsDisplayList.h"
6385: #ifdef ACCESSIBILITY
6385: #include "nsIAccessibilityService.h"
6385: #endif
   1: 
   1: #define SYNC_TEXT 0x1
   1: #define SYNC_BUTTON 0x2
   1: #define SYNC_BOTH 0x3
   1: 
   1: nsIFrame*
   1: NS_NewFileControlFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
   1: {
   1:   return new (aPresShell) nsFileControlFrame(aContext);
   1: }
   1: 
   1: nsFileControlFrame::nsFileControlFrame(nsStyleContext* aContext):
   1:   nsAreaFrame(aContext),
   1:   mTextFrame(nsnull), 
   1:   mCachedState(nsnull)
   1: {
   1: }
   1: 
   1: nsFileControlFrame::~nsFileControlFrame()
   1: {
   1:   if (mCachedState) {
   1:     delete mCachedState;
   1:     mCachedState = nsnull;
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsFileControlFrame::Init(nsIContent* aContent,
   1:                          nsIFrame*   aParent,
   1:                          nsIFrame*   aPrevInFlow)
   1: {
   1:   nsresult rv = nsAreaFrame::Init(aContent, aParent, aPrevInFlow);
   1:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   mMouseListener = new MouseListener(this);
   1:   NS_ENSURE_TRUE(mMouseListener, NS_ERROR_OUT_OF_MEMORY);
   1: 
   1:   return rv;
   1: }
   1: 
   1: void
   1: nsFileControlFrame::Destroy()
   1: {
   1:   mTextFrame = nsnull;
   1:   // remove mMouseListener as a mouse event listener (bug 40533, bug 355931)
   1:   if (mBrowse) {
1418:     mBrowse->RemoveEventListenerByIID(mMouseListener,
   1:                                        NS_GET_IID(nsIDOMMouseListener));
   1:     nsContentUtils::DestroyAnonymousContent(&mBrowse);
   1:   }
   1:   if (mTextContent) {
1418:     mTextContent->RemoveEventListenerByIID(mMouseListener,
   1:                                            NS_GET_IID(nsIDOMMouseListener));
   1:     nsContentUtils::DestroyAnonymousContent(&mTextContent);
   1:   }
   1: 
   1:   mMouseListener->ForgetFrame();
   1:   nsAreaFrame::Destroy();
   1: }
   1: 
   1: nsresult
   1: nsFileControlFrame::CreateAnonymousContent(nsTArray<nsIContent*>& aElements)
   1: {
   1:   // Get the NodeInfoManager and tag necessary to create input elements
   1:   nsCOMPtr<nsIDocument> doc = mContent->GetDocument();
   1: 
   1:   nsCOMPtr<nsINodeInfo> nodeInfo;
   1:   doc->NodeInfoManager()->GetNodeInfo(nsGkAtoms::input, nsnull,
   1:                                       kNameSpaceID_None,
   1:                                       getter_AddRefs(nodeInfo));
   1: 
   1:   // Create the text content
   1:   NS_NewHTMLElement(getter_AddRefs(mTextContent), nodeInfo);
   1:   if (!mTextContent)
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:   mTextContent->SetAttr(kNameSpaceID_None, nsGkAtoms::type,
   1:                         NS_LITERAL_STRING("text"), PR_FALSE);
   1: 
   1:   nsCOMPtr<nsIDOMHTMLInputElement> textControl = do_QueryInterface(mTextContent);
   1:   if (textControl) {
   1:     nsCOMPtr<nsIFileControlElement> fileControl = do_QueryInterface(mContent);
   1:     if (fileControl) {
   1:       // Initialize value when we create the content in case the value was set
   1:       // before we got here
   1:       nsAutoString value;
   1:       fileControl->GetFileName(value);
   1:       textControl->SetValue(value);
   1:     }
   1: 
   1:     textControl->SetTabIndex(-1);
   1:     textControl->SetReadOnly(PR_TRUE);
   1:   }
   1: 
   1:   if (!aElements.AppendElement(mTextContent))
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:   // register as an event listener of the textbox to open file dialog on mouse click
1418:   mTextContent->AddEventListenerByIID(mMouseListener,
   1:                                       NS_GET_IID(nsIDOMMouseListener));
   1: 
   1:   // Create the browse button
   1:   NS_NewHTMLElement(getter_AddRefs(mBrowse), nodeInfo);
   1:   if (!mBrowse)
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:   mBrowse->SetAttr(kNameSpaceID_None, nsGkAtoms::type,
   1:                    NS_LITERAL_STRING("button"), PR_FALSE);
   1:   nsCOMPtr<nsIDOMHTMLInputElement> fileContent = do_QueryInterface(mContent);
   1:   nsCOMPtr<nsIDOMHTMLInputElement> browseControl = do_QueryInterface(mBrowse);
   1:   if (fileContent && browseControl) {
   1:     PRInt32 tabIndex;
   1:     nsAutoString accessKey;
   1: 
   1:     fileContent->GetAccessKey(accessKey);
   1:     browseControl->SetAccessKey(accessKey);
   1:     fileContent->GetTabIndex(&tabIndex);
   1:     browseControl->SetTabIndex(tabIndex);
   1:   }
   1: 
   1:   if (!aElements.AppendElement(mBrowse))
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1: 
   1:   // register as an event listener of the button to open file dialog on mouse click
1418:   mBrowse->AddEventListenerByIID(mMouseListener,
   1:                                  NS_GET_IID(nsIDOMMouseListener));
   1: 
   1:   SyncAttr(kNameSpaceID_None, nsGkAtoms::size,     SYNC_TEXT);
   1:   SyncAttr(kNameSpaceID_None, nsGkAtoms::disabled, SYNC_BOTH);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: // Frames are not refcounted, no need to AddRef
   1: NS_IMETHODIMP
   1: nsFileControlFrame::QueryInterface(const nsIID& aIID, void** aInstancePtr)
   1: {
3114:   NS_PRECONDITION(aInstancePtr, "null out param");
3114: 
   1:   if (aIID.Equals(NS_GET_IID(nsIAnonymousContentCreator))) {
3233:     *aInstancePtr = static_cast<nsIAnonymousContentCreator*>(this);
   1:     return NS_OK;
   1:   }
   1:   if (aIID.Equals(NS_GET_IID(nsIFormControlFrame))) {
3233:     *aInstancePtr = static_cast<nsIFormControlFrame*>(this);
   1:     return NS_OK;
   1:   }
3114: 
   1:   return nsAreaFrame::QueryInterface(aIID, aInstancePtr);
   1: }
   1: 
   1: void 
   1: nsFileControlFrame::SetFocus(PRBool aOn, PRBool aRepaint)
   1: {
   1:   // Fix for Bug 6133 
   1:   if (mTextFrame) {
   1:     nsIContent* content = mTextFrame->GetContent();
   1:     if (content) {
 238:       content->SetFocus(PresContext());
   1:     }
   1:   }
   1: }
   1: 
   1: /**
   1:  * This is called when our browse button is clicked
   1:  */
   1: nsresult 
   1: nsFileControlFrame::MouseClick(nsIDOMEvent* aMouseEvent)
   1: {
   1:   // only allow the left button
   1:   nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aMouseEvent);
   1:   if (mouseEvent) {
   1:     PRUint16 whichButton;
   1:     if (NS_SUCCEEDED(mouseEvent->GetButton(&whichButton))) {
   1:       if (whichButton != 0) {
   1:         return NS_OK;
   1:       }
   1:     }
   1:   }
   1: 
   1: 
   1:   nsresult result;
   1: 
   1:   // Get parent nsIDOMWindowInternal object.
   1:   nsIContent* content = GetContent();
   1:   if (!content)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   nsCOMPtr<nsIDocument> doc = content->GetDocument();
   1:   if (!doc)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   // Get Loc title
   1:   nsXPIDLString title;
   1:   nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
   1:                                      "FileUpload", title);
   1: 
   1:   nsCOMPtr<nsIFilePicker> filePicker = do_CreateInstance("@mozilla.org/filepicker;1");
   1:   if (!filePicker)
   1:     return NS_ERROR_FAILURE;
   1: 
   1:   result = filePicker->Init(doc->GetWindow(), title, nsIFilePicker::modeOpen);
   1:   if (NS_FAILED(result))
   1:     return result;
   1: 
   1:   // Set filter "All Files"
   1:   filePicker->AppendFilters(nsIFilePicker::filterAll);
   1: 
   1:   // Set default directry and filename
   1:   nsAutoString defaultName;
   1:   GetFormProperty(nsGkAtoms::value, defaultName);
   1: 
   1:   nsCOMPtr<nsILocalFile> currentFile = do_CreateInstance("@mozilla.org/file/local;1");
   1:   if (currentFile && !defaultName.IsEmpty()) {
   1:     result = currentFile->InitWithPath(defaultName);
   1:     if (NS_SUCCEEDED(result)) {
   1:       nsAutoString leafName;
   1:       currentFile->GetLeafName(leafName);
   1:       if (!leafName.IsEmpty()) {
   1:         filePicker->SetDefaultString(leafName);
   1:       }
   1: 
   1:       // set directory
   1:       nsCOMPtr<nsIFile> parentFile;
   1:       currentFile->GetParent(getter_AddRefs(parentFile));
   1:       if (parentFile) {
   1:         nsCOMPtr<nsILocalFile> parentLocalFile = do_QueryInterface(parentFile, &result);
   1:         if (parentLocalFile)
   1:           filePicker->SetDisplayDirectory(parentLocalFile);
   1:       }
   1:     }
   1:   }
   1: 
   1:   // Tell our textframe to remember the currently focused value
   1:   mTextFrame->InitFocusedValue();
   1: 
   1:   // Open dialog
   1:   PRInt16 mode;
   1:   result = filePicker->Show(&mode);
   1:   if (NS_FAILED(result))
   1:     return result;
   1:   if (mode == nsIFilePicker::returnCancel)
   1:     return NS_OK;
   1: 
   1:   if (!mTextFrame) {
   1:     // We got destroyed while the filepicker was up.  Don't do anything here.
   1:     return NS_OK;
   1:   }
   1:   
   1:   // Set property
   1:   nsCOMPtr<nsILocalFile> localFile;
   1:   result = filePicker->GetFile(getter_AddRefs(localFile));
   1:   if (localFile) {
   1:     nsAutoString unicodePath;
   1:     result = localFile->GetPath(unicodePath);
   1:     if (!unicodePath.IsEmpty()) {
   1:       // Tell mTextFrame that this update of the value is a user initiated
   1:       // change. Otherwise it'll think that the value is being set by a script
   1:       // and not fire onchange when it should.
   1:       PRBool oldState = mTextFrame->GetFireChangeEventState();
   1:       mTextFrame->SetFireChangeEventState(PR_TRUE);
   1:       nsCOMPtr<nsIFileControlElement> fileControl = do_QueryInterface(mContent);
   1:       if (fileControl) {
   1:         fileControl->SetFileName(unicodePath);
   1:       }
   1:       
3469:       mTextFrame->SetFireChangeEventState(oldState);
   1:       // May need to fire an onchange here
   1:       mTextFrame->CheckFireOnChange();
   1:       return NS_OK;
   1:     }
   1:   }
   1: 
   1:   return NS_FAILED(result) ? result : NS_ERROR_FAILURE;
   1: }
   1: 
   1: nscoord
   1: nsFileControlFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
   1: {
   1:   nscoord result;
   1:   DISPLAY_MIN_WIDTH(this, result);
   1: 
   1:   // Our min width is our pref width
   1:   result = GetPrefWidth(aRenderingContext);
   1:   return result;
   1: }
   1: 
   1: NS_IMETHODIMP nsFileControlFrame::Reflow(nsPresContext*          aPresContext, 
   1:                                          nsHTMLReflowMetrics&     aDesiredSize,
   1:                                          const nsHTMLReflowState& aReflowState, 
   1:                                          nsReflowStatus&          aStatus)
   1: {
   1:   DO_GLOBAL_REFLOW_COUNT("nsFileControlFrame");
   1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
   1: 
   1:   aStatus = NS_FRAME_COMPLETE;
   1: 
   1:   if (mState & NS_FRAME_FIRST_REFLOW) {
   1:     mTextFrame = GetTextControlFrame(aPresContext, this);
   1:     NS_ENSURE_TRUE(mTextFrame, NS_ERROR_UNEXPECTED);
   1:     if (mCachedState) {
   1:       mTextFrame->SetFormProperty(nsGkAtoms::value, *mCachedState);
   1:       delete mCachedState;
   1:       mCachedState = nsnull;
   1:     }
   1:   }
   1: 
   1:   // The Areaframe takes care of all our reflow
8358:   return nsAreaFrame::Reflow(aPresContext, aDesiredSize, aReflowState,
   1:                              aStatus);
   1: }
   1: 
   1: /*
   1: NS_IMETHODIMP
   1: nsFileControlFrame::SetInitialChildList(nsIAtom*        aListName,
   1:                                         nsIFrame*       aChildList)
   1: {
   1:   nsAreaFrame::SetInitialChildList(aListName, aChildList);
   1: 
   1:   // given that the CSS frame constructor created all our frames. We need to find the text field
   1:   // so we can get info from it.
   1:   mTextFrame = GetTextControlFrame(this);
   1: }
   1: */
   1: 
   1: nsNewFrame*
   1: nsFileControlFrame::GetTextControlFrame(nsPresContext* aPresContext, nsIFrame* aStart)
   1: {
   1:   nsNewFrame* result = nsnull;
   1: #ifndef DEBUG_NEWFRAME
   1:   // find the text control frame.
   1:   nsIFrame* childFrame = aStart->GetFirstChild(nsnull);
   1: 
   1:   while (childFrame) {
   1:     // see if the child is a text control
   1:     nsCOMPtr<nsIFormControl> formCtrl =
   1:       do_QueryInterface(childFrame->GetContent());
   1: 
   1:     if (formCtrl && formCtrl->GetType() == NS_FORM_INPUT_TEXT) {
   1:       result = (nsNewFrame*)childFrame;
   1:     }
   1: 
   1:     // if not continue looking
   1:     nsNewFrame* frame = GetTextControlFrame(aPresContext, childFrame);
   1:     if (frame)
   1:        result = frame;
   1:      
   1:     childFrame = childFrame->GetNextSibling();
   1:   }
   1: 
   1:   return result;
   1: #else
   1:   return nsnull;
   1: #endif
   1: }
   1: 
   1: PRIntn
   1: nsFileControlFrame::GetSkipSides() const
   1: {
   1:   return 0;
   1: }
   1: 
   1: void
   1: nsFileControlFrame::SyncAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
   1:                              PRInt32 aWhichControls)
   1: {
   1:   nsAutoString value;
   1:   if (mContent->GetAttr(aNameSpaceID, aAttribute, value)) {
   1:     if (aWhichControls & SYNC_TEXT && mTextContent) {
   1:       mTextContent->SetAttr(aNameSpaceID, aAttribute, value, PR_TRUE);
   1:     }
   1:     if (aWhichControls & SYNC_BUTTON && mBrowse) {
   1:       mBrowse->SetAttr(aNameSpaceID, aAttribute, value, PR_TRUE);
   1:     }
   1:   } else {
   1:     if (aWhichControls & SYNC_TEXT && mTextContent) {
   1:       mTextContent->UnsetAttr(aNameSpaceID, aAttribute, PR_TRUE);
   1:     }
   1:     if (aWhichControls & SYNC_BUTTON && mBrowse) {
   1:       mBrowse->UnsetAttr(aNameSpaceID, aAttribute, PR_TRUE);
   1:     }
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsFileControlFrame::AttributeChanged(PRInt32         aNameSpaceID,
   1:                                      nsIAtom*        aAttribute,
   1:                                      PRInt32         aModType)
   1: {
   1:   // propagate disabled to text / button inputs
   1:   if (aNameSpaceID == kNameSpaceID_None &&
   1:       aAttribute == nsGkAtoms::disabled) {
   1:     SyncAttr(aNameSpaceID, aAttribute, SYNC_BOTH);
   1:   // propagate size to text
   1:   } else if (aNameSpaceID == kNameSpaceID_None &&
   1:              aAttribute == nsGkAtoms::size) {
   1:     SyncAttr(aNameSpaceID, aAttribute, SYNC_TEXT);
   1:   }
   1: 
   1:   return nsAreaFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
   1: }
   1: 
   1: PRBool
   1: nsFileControlFrame::IsLeaf() const
   1: {
   1:   return PR_TRUE;
   1: }
   1: 
   1: #ifdef NS_DEBUG
   1: NS_IMETHODIMP
   1: nsFileControlFrame::GetFrameName(nsAString& aResult) const
   1: {
   1:   return MakeFrameName(NS_LITERAL_STRING("FileControl"), aResult);
   1: }
   1: #endif
   1: 
   1: nsresult
   1: nsFileControlFrame::SetFormProperty(nsIAtom* aName,
   1:                                     const nsAString& aValue)
   1: {
   1:   if (nsGkAtoms::value == aName) {
   1:     if (mTextFrame) {
   1:       mTextFrame->SetValue(aValue);
   1:     } else {
   1:       if (mCachedState) delete mCachedState;
   1:       mCachedState = new nsString(aValue);
   1:       NS_ENSURE_TRUE(mCachedState, NS_ERROR_OUT_OF_MEMORY);
   1:     }
   1:   }
   1:   return NS_OK;
   1: }      
   1: 
   1: nsresult
   1: nsFileControlFrame::GetFormProperty(nsIAtom* aName, nsAString& aValue) const
   1: {
   1:   aValue.Truncate();  // initialize out param
   1: 
   1:   if (nsGkAtoms::value == aName) {
   1:     NS_ASSERTION(!mCachedState || !mTextFrame,
   1:                  "If we have a cached state, we better have no mTextFrame");
   1:     if (mCachedState) {
   1:       aValue.Assign(*mCachedState);
4633:     } else {
4633:       nsCOMPtr<nsIFileControlElement> fileControl =
4633:         do_QueryInterface(mContent);
   1:       if (fileControl) {
   1:         fileControl->GetFileName(aValue);
   1:       }
   1:     }
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP
   1: nsFileControlFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                                      const nsRect&           aDirtyRect,
   1:                                      const nsDisplayListSet& aLists)
   1: {
   1:   // Our background is inherited to the text input, and we don't really want to
   1:   // paint it or out padding and borders (which we never have anyway, per
   1:   // styles in forms.css) -- doing it just makes us look ugly in some cases and
   1:   // has no effect in others.
   1:   nsDisplayListCollection tempList;
   1:   nsresult rv = nsAreaFrame::BuildDisplayList(aBuilder, aDirtyRect, tempList);
   1:   if (NS_FAILED(rv))
   1:     return rv;
   1: 
   1:   tempList.BorderBackground()->DeleteAll();
8358: 
8358:   rv = OverflowClip(aBuilder, tempList, aLists,
8358:                     nsRect(aBuilder->ToReferenceFrame(this), GetSize()));
8358:   NS_ENSURE_SUCCESS(rv, rv);
   1: 
   1:   // Disabled file controls don't pass mouse events to their children, so we
   1:   // put an invisible item in the display list above the children
   1:   // just to catch events
   1:   // REVIEW: I'm not sure why we do this, but that's what nsFileControlFrame::
   1:   // GetFrameForPoint was doing
   1:   if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled) && 
   1:       IsVisibleForPainting(aBuilder)) {
   1:     nsDisplayItem* item = new (aBuilder) nsDisplayEventReceiver(this);
   1:     if (!item)
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     aLists.Content()->AppendToTop(item);
   1:   }
   1: 
   1:   return DisplaySelectionOverlay(aBuilder, aLists);
   1: }
   1: 
6385: #ifdef ACCESSIBILITY
6385: NS_IMETHODIMP nsFileControlFrame::GetAccessible(nsIAccessible** aAccessible)
6385: {
8231:   // Accessible object exists just to hold onto its children, for later shutdown
8231:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
8231: 
8231:   if (accService) {
8231:     return accService->CreateHTMLGenericAccessible(static_cast<nsIFrame*>(this), aAccessible);
8231:   }
8231: 
6385:   return NS_ERROR_FAILURE;
6385: }
6385: #endif
6385: 
   1: ////////////////////////////////////////////////////////////
   1: // Mouse listener implementation
   1: 
   1: NS_IMPL_ISUPPORTS1(nsFileControlFrame::MouseListener, nsIDOMMouseListener)
   1: 
   1: NS_IMETHODIMP
   1: nsFileControlFrame::MouseListener::MouseClick(nsIDOMEvent* aMouseEvent)
   1: {
   1:   if (mFrame) {
   1:     return mFrame->MouseClick(aMouseEvent);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
