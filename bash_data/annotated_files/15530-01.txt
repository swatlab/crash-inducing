    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jscntxt_h___
    1: #define jscntxt_h___
    1: /*
    1:  * JS execution context.
    1:  */
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsclist.h"
    1: #include "jslong.h"
    1: #include "jsatom.h"
    1: #include "jsconfig.h"
    1: #include "jsdhash.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsobj.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
    1: #include "jsregexp.h"
    1: #include "jsutil.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
    1: /*
    1:  * js_GetSrcNote cache to avoid O(n^2) growth in finding a source note for a
15530:  * given pc in a script.  We use the script->code pointer to tag the cache,
15530:  * instead of the script address itself, so that source notes are always found
15530:  * by offset from the bytecode with which they were generated.
    1:  */
    1: typedef struct JSGSNCache {
15530:     jsbytecode      *code;
    1:     JSDHashTable    table;
    1: #ifdef JS_GSNMETER
    1:     uint32          hits;
    1:     uint32          misses;
    1:     uint32          fills;
    1:     uint32          clears;
    1: # define GSN_CACHE_METER(cache,cnt) (++(cache)->cnt)
    1: #else
    1: # define GSN_CACHE_METER(cache,cnt) /* nothing */
    1: #endif
    1: } JSGSNCache;
    1: 
    1: #define GSN_CACHE_CLEAR(cache)                                                \
    1:     JS_BEGIN_MACRO                                                            \
15530:         (cache)->code = NULL;                                                 \
    1:         if ((cache)->table.ops) {                                             \
    1:             JS_DHashTableFinish(&(cache)->table);                             \
    1:             (cache)->table.ops = NULL;                                        \
    1:         }                                                                     \
    1:         GSN_CACHE_METER(cache, clears);                                       \
    1:     JS_END_MACRO
    1: 
    1: /* These helper macros take a cx as parameter and operate on its GSN cache. */
    1: #define JS_CLEAR_GSN_CACHE(cx)      GSN_CACHE_CLEAR(&JS_GSN_CACHE(cx))
    1: #define JS_METER_GSN_CACHE(cx,cnt)  GSN_CACHE_METER(&JS_GSN_CACHE(cx), cnt)
    1: 
    1: #ifdef JS_THREADSAFE
    1: 
    1: /*
    1:  * Structure uniquely representing a thread.  It holds thread-private data
    1:  * that can be accessed without a global lock.
    1:  */
    1: struct JSThread {
    1:     /* Linked list of all contexts active on this thread. */
    1:     JSCList             contextList;
    1: 
    1:     /* Opaque thread-id, from NSPR's PR_GetCurrentThread(). */
    1:     jsword              id;
    1: 
    1:     /*
    1:      * Thread-local version of JSRuntime.gcMallocBytes to avoid taking
    1:      * locks on each JS_malloc.
    1:      */
    1:     uint32              gcMallocBytes;
    1: 
15500:     /* Thread-local gc free lists array. */
15500:     JSGCThing           *gcFreeLists[GC_NUM_FREELISTS];
15500: 
    1:     /*
    1:      * Store the GSN cache in struct JSThread, not struct JSContext, both to
    1:      * save space and to simplify cleanup in js_GC.  Any embedding (Firefox
    1:      * or another Gecko application) that uses many contexts per thread is
    1:      * unlikely to interleave js_GetSrcNote-intensive loops in the decompiler
    1:      * among two or more contexts running script in one thread.
    1:      */
    1:     JSGSNCache          gsnCache;
11377: 
11377:     /* Property cache for faster call/get/set invocation. */
11377:     JSPropertyCache     propertyCache;
    1: };
    1: 
    1: #define JS_GSN_CACHE(cx)        ((cx)->thread->gsnCache)
11377: #define JS_PROPERTY_CACHE(cx)   ((cx)->thread->propertyCache)
    1: 
    1: extern void JS_DLL_CALLBACK
    1: js_ThreadDestructorCB(void *ptr);
    1: 
    1: extern JSBool
    1: js_SetContextThread(JSContext *cx);
    1: 
    1: extern void
    1: js_ClearContextThread(JSContext *cx);
    1: 
    1: extern JSThread *
    1: js_GetCurrentThread(JSRuntime *rt);
    1: 
    1: #endif /* JS_THREADSAFE */
    1: 
    1: typedef enum JSDestroyContextMode {
    1:     JSDCM_NO_GC,
    1:     JSDCM_MAYBE_GC,
    1:     JSDCM_FORCE_GC,
    1:     JSDCM_NEW_FAILED
    1: } JSDestroyContextMode;
    1: 
    1: typedef enum JSRuntimeState {
    1:     JSRTS_DOWN,
    1:     JSRTS_LAUNCHING,
    1:     JSRTS_UP,
    1:     JSRTS_LANDING
    1: } JSRuntimeState;
    1: 
    1: typedef struct JSPropertyTreeEntry {
    1:     JSDHashEntryHdr     hdr;
    1:     JSScopeProperty     *child;
    1: } JSPropertyTreeEntry;
    1: 
    1: /*
    1:  * Forward declaration for opaque JSRuntime.nativeIteratorStates.
    1:  */
    1: typedef struct JSNativeIteratorState JSNativeIteratorState;
    1: 
11041: typedef struct JSSetSlotRequest JSSetSlotRequest;
11041: 
11041: struct JSSetSlotRequest {
11041:     JSObject            *obj;           /* object containing slot to set */
11041:     JSObject            *pobj;          /* new proto or parent reference */
11041:     uint16              slot;           /* which to set, proto or parent */
11041:     uint16              errnum;         /* JSMSG_NO_ERROR or error result */
11041:     JSSetSlotRequest    *next;          /* next request in GC worklist */
11041: };
11041: 
    1: struct JSRuntime {
    1:     /* Runtime state, synchronized by the stateChange/gcLock condvar/lock. */
    1:     JSRuntimeState      state;
    1: 
    1:     /* Context create/destroy callback. */
    1:     JSContextCallback   cxCallback;
    1: 
    1:     /* Garbage collector state, used by jsgc.c. */
 5917:     JSGCChunkInfo       *gcChunkList;
    1:     JSGCArenaList       gcArenaList[GC_NUM_FREELISTS];
12282:     JSGCDoubleArenaList gcDoubleArenaList;
    1:     JSDHashTable        gcRootsHash;
    1:     JSDHashTable        *gcLocksHash;
    1:     jsrefcount          gcKeepAtoms;
    1:     uint32              gcBytes;
    1:     uint32              gcLastBytes;
    1:     uint32              gcMaxBytes;
    1:     uint32              gcMaxMallocBytes;
10985:     uint32              gcStackPoolLifespan;
    1:     uint32              gcLevel;
    1:     uint32              gcNumber;
  583:     JSTracer            *gcMarkingTracer;
    1: 
    1:     /*
    1:      * NB: do not pack another flag here by claiming gcPadding unless the new
    1:      * flag is written only by the GC thread.  Atomic updates to packed bytes
    1:      * are not guaranteed, so stores issued by one thread may be lost due to
    1:      * unsynchronized read-modify-write cycles on other threads.
    1:      */
    1:     JSPackedBool        gcPoke;
    1:     JSPackedBool        gcRunning;
 7944:     uint16              gcPadding;
 1492: #ifdef JS_GC_ZEAL
 7944:     jsrefcount          gcZeal;
 1492: #endif
    1: 
    1:     JSGCCallback        gcCallback;
    1:     uint32              gcMallocBytes;
 5917:     JSGCArenaInfo       *gcUntracedArenaStackTop;
    1: #ifdef DEBUG
 5917:     size_t              gcTraceLaterCount;
    1: #endif
    1: 
    1:     /*
    1:      * Table for tracking iterators to ensure that we close iterator's state
    1:      * before finalizing the iterable object.
    1:      */
    1:     JSPtrTable          gcIteratorTable;
    1: 
  958:     /*
  958:      * The trace operation and its data argument to trace embedding-specific
  958:      * GC roots.
  958:      */
  958:     JSTraceDataOp       gcExtraRootsTraceOp;
  958:     void                *gcExtraRootsData;
  958: 
11041:     /*
11041:      * Used to serialize cycle checks when setting __proto__ or __parent__ by
11041:      * requesting the GC handle the required cycle detection. If the GC hasn't
11041:      * been poked, it won't scan for garbage. This member is protected by
11041:      * rt->gcLock.
11041:      */
11041:     JSSetSlotRequest    *setSlotRequests;
11041: 
    1:     /* Random number generator state, used by jsmath.c. */
    1:     JSBool              rngInitialized;
    1:     int64               rngMultiplier;
    1:     int64               rngAddend;
    1:     int64               rngMask;
    1:     int64               rngSeed;
    1:     jsdouble            rngDscale;
    1: 
    1:     /* Well-known numbers held for use by this runtime's contexts. */
    1:     jsdouble            *jsNaN;
    1:     jsdouble            *jsNegativeInfinity;
    1:     jsdouble            *jsPositiveInfinity;
    1: 
    1: #ifdef JS_THREADSAFE
    1:     JSLock              *deflatedStringCacheLock;
    1: #endif
    1:     JSHashTable         *deflatedStringCache;
    1: #ifdef DEBUG
    1:     uint32              deflatedStringCacheBytes;
    1: #endif
    1: 
 4127:     /*
 4127:      * Empty and unit-length strings held for use by this runtime's contexts.
 4127:      * The unitStrings array and its elements are created on demand.
 4127:      */
    1:     JSString            *emptyString;
 4127:     JSString            **unitStrings;
    1: 
    1:     /* List of active contexts sharing this runtime; protected by gcLock. */
    1:     JSCList             contextList;
    1: 
 2433:     /* Per runtime debug hooks -- see jsprvtd.h and jsdbgapi.h. */
 2433:     JSDebugHooks        globalDebugHooks;
    1: 
    1:     /* More debugging state, see jsdbgapi.c. */
    1:     JSCList             trapList;
    1:     JSCList             watchPointList;
    1: 
    1:     /* Client opaque pointer */
    1:     void                *data;
    1: 
    1: #ifdef JS_THREADSAFE
    1:     /* These combine to interlock the GC and new requests. */
    1:     PRLock              *gcLock;
    1:     PRCondVar           *gcDone;
    1:     PRCondVar           *requestDone;
    1:     uint32              requestCount;
    1:     JSThread            *gcThread;
    1: 
    1:     /* Lock and owning thread pointer for JS_LOCK_RUNTIME. */
    1:     PRLock              *rtLock;
    1: #ifdef DEBUG
    1:     jsword              rtLockOwner;
    1: #endif
    1: 
    1:     /* Used to synchronize down/up state change; protected by gcLock. */
    1:     PRCondVar           *stateChange;
    1: 
    1:     /*
11739:      * State for sharing single-threaded titles, once a second thread tries to
11739:      * lock a title.  The titleSharingDone condvar is protected by rt->gcLock
    1:      * to minimize number of locks taken in JS_EndRequest.
    1:      *
11739:      * The titleSharingTodo linked list is likewise "global" per runtime, not
    1:      * one-list-per-context, to conserve space over all contexts, optimizing
11739:      * for the likely case that titles become shared rarely, and among a very
    1:      * small set of threads (contexts).
    1:      */
11739:     PRCondVar           *titleSharingDone;
11739:     JSTitle             *titleSharingTodo;
    1: 
    1: /*
11739:  * Magic terminator for the rt->titleSharingTodo linked list, threaded through
11739:  * title->u.link.  This hack allows us to test whether a title is on the list
11739:  * by asking whether title->u.link is non-null.  We use a large, likely bogus
    1:  * pointer here to distinguish this value from any valid u.count (small int)
    1:  * value.
    1:  */
11739: #define NO_TITLE_SHARING_TODO   ((JSTitle *) 0xfeedbeef)
    1: 
    1:     /*
    1:      * Lock serializing trapList and watchPointList accesses, and count of all
    1:      * mutations to trapList and watchPointList made by debugger threads.  To
    1:      * keep the code simple, we define debuggerMutations for the thread-unsafe
    1:      * case too.
    1:      */
    1:     PRLock              *debuggerLock;
    1: #endif /* JS_THREADSAFE */
    1:     uint32              debuggerMutations;
    1: 
    1:     /*
    1:      * Check property accessibility for objects of arbitrary class.  Used at
    1:      * present to check f.caller accessibility for any function object f.
    1:      */
    1:     JSCheckAccessOp     checkObjectAccess;
    1: 
    1:     /* Security principals serialization support. */
    1:     JSPrincipalsTranscoder principalsTranscoder;
    1: 
    1:     /* Optional hook to find principals for an object in this runtime. */
    1:     JSObjectPrincipalsFinder findObjectPrincipals;
    1: 
    1:     /*
    1:      * Shared scope property tree, and arena-pool for allocating its nodes.
    1:      * The propertyRemovals counter is incremented for every js_ClearScope,
    1:      * and for each js_RemoveScopeProperty that frees a slot in an object.
    1:      * See js_NativeGet and js_NativeSet in jsobj.c.
    1:      */
    1:     JSDHashTable        propertyTreeHash;
    1:     JSScopeProperty     *propertyFreeList;
    1:     JSArenaPool         propertyArenaPool;
    1:     int32               propertyRemovals;
    1: 
    1:     /* Script filename table. */
    1:     struct JSHashTable  *scriptFilenameTable;
    1:     JSCList             scriptFilenamePrefixes;
    1: #ifdef JS_THREADSAFE
    1:     PRLock              *scriptFilenameTableLock;
    1: #endif
    1: 
    1:     /* Number localization, used by jsnum.c */
    1:     const char          *thousandsSeparator;
    1:     const char          *decimalSeparator;
    1:     const char          *numGrouping;
    1: 
    1:     /*
    1:      * Weak references to lazily-created, well-known XML singletons.
    1:      *
    1:      * NB: Singleton objects must be carefully disconnected from the rest of
    1:      * the object graph usually associated with a JSContext's global object,
    1:      * including the set of standard class objects.  See jsxml.c for details.
    1:      */
    1:     JSObject            *anynameObject;
    1:     JSObject            *functionNamespaceObject;
    1: 
    1:     /*
    1:      * A helper list for the GC, so it can mark native iterator states. See
  583:      * js_TraceNativeIteratorStates for details.
    1:      */
    1:     JSNativeIteratorState *nativeIteratorStates;
    1: 
    1: #ifndef JS_THREADSAFE
    1:     /*
    1:      * For thread-unsafe embeddings, the GSN cache lives in the runtime and
    1:      * not each context, since we expect it to be filled once when decompiling
    1:      * a longer script, then hit repeatedly as js_GetSrcNote is called during
    1:      * the decompiler activation that filled it.
    1:      */
    1:     JSGSNCache          gsnCache;
    1: 
11377:     /* Property cache for faster call/get/set invocation. */
11377:     JSPropertyCache     propertyCache;
11377: 
    1: #define JS_GSN_CACHE(cx)        ((cx)->runtime->gsnCache)
11377: #define JS_PROPERTY_CACHE(cx)   ((cx)->runtime->propertyCache)
    1: #endif
    1: 
11377:     /*
11377:      * Object shape (property cache structural type) identifier generator.
11377:      *
11377:      * Type 0 stands for the empty scope, and must not be regenerated due to
11377:      * uint32 wrap-around. Since we use atomic pre-increment, the initial
11377:      * value for the first typed non-empty scope will be 1.
11377:      *
11377:      * The GC compresses live types, minimizing rt->shapeGen in the process.
11377:      * If this counter overflows into SHAPE_OVERFLOW_BIT (in jsinterp.h), the
11377:      * GC will disable property caches for all threads, to avoid aliasing two
11377:      * different types. Updated by js_GenerateShape (in jsinterp.c).
11377:      */
11377:     uint32              shapeGen;
11377: 
 4342:     /* Literal table maintained by jsatom.c functions. */
 4342:     JSAtomState         atomState;
 4342: 
10954:     /*
10954:      * Various metering fields are defined at the end of JSRuntime. In this
10954:      * way there is no need to recompile all the code that refers to other
10954:      * fields of JSRuntime after enabling the corresponding metering macro.
10954:      */
10954: 
10217: #if defined DEBUG || defined JS_DUMP_PROPTREE_STATS
    1:     /* Function invocation metering. */
    1:     jsrefcount          inlineCalls;
    1:     jsrefcount          nativeCalls;
    1:     jsrefcount          nonInlineCalls;
    1:     jsrefcount          constructs;
    1: 
11739:     /* Title lock and scope property metering. */
    1:     jsrefcount          claimAttempts;
11739:     jsrefcount          claimedTitles;
    1:     jsrefcount          deadContexts;
    1:     jsrefcount          deadlocksAvoided;
    1:     jsrefcount          liveScopes;
11739:     jsrefcount          sharedTitles;
    1:     jsrefcount          totalScopes;
    1:     jsrefcount          liveScopeProps;
10217:     jsrefcount          liveScopePropsPreSweep;
    1:     jsrefcount          totalScopeProps;
    1:     jsrefcount          livePropTreeNodes;
    1:     jsrefcount          duplicatePropTreeNodes;
    1:     jsrefcount          totalPropTreeNodes;
    1:     jsrefcount          propTreeKidsChunks;
    1:     jsrefcount          middleDeleteFixups;
    1: 
    1:     /* String instrumentation. */
    1:     jsrefcount          liveStrings;
    1:     jsrefcount          totalStrings;
    1:     jsrefcount          liveDependentStrings;
    1:     jsrefcount          totalDependentStrings;
10217:     jsrefcount          badUndependStrings;
    1:     double              lengthSum;
    1:     double              lengthSquaredSum;
    1:     double              strdepLengthSum;
    1:     double              strdepLengthSquaredSum;
10217: #endif /* DEBUG || JS_DUMP_PROPTREE_STATS */
10217: 
10217: #ifdef JS_SCOPE_DEPTH_METER
10217:     /*
10217:      * Stats on runtime prototype chain lookups and scope chain depths, i.e.,
10217:      * counts of objects traversed on a chain until the wanted id is found.
10217:      */
10217:     JSBasicStats        protoLookupDepthStats;
10217:     JSBasicStats        scopeSearchDepthStats;
10217: 
10217:     /*
10217:      * Stats on compile-time host environment and lexical scope chain lengths
10217:      * (maximum depths).
10217:      */
10217:     JSBasicStats        hostenvScopeDepthStats;
10217:     JSBasicStats        lexicalScopeDepthStats;
    1: #endif
10954: 
10954: #ifdef JS_GCMETER
10954:     JSGCStats           gcStats;
10954: #endif
    1: };
    1: 
    1: #ifdef DEBUG
    1: # define JS_RUNTIME_METER(rt, which)    JS_ATOMIC_INCREMENT(&(rt)->which)
    1: # define JS_RUNTIME_UNMETER(rt, which)  JS_ATOMIC_DECREMENT(&(rt)->which)
    1: #else
    1: # define JS_RUNTIME_METER(rt, which)    /* nothing */
    1: # define JS_RUNTIME_UNMETER(rt, which)  /* nothing */
    1: #endif
    1: 
    1: #define JS_KEEP_ATOMS(rt)   JS_ATOMIC_INCREMENT(&(rt)->gcKeepAtoms);
    1: #define JS_UNKEEP_ATOMS(rt) JS_ATOMIC_DECREMENT(&(rt)->gcKeepAtoms);
    1: 
    1: #ifdef JS_ARGUMENT_FORMATTER_DEFINED
    1: /*
    1:  * Linked list mapping format strings for JS_{Convert,Push}Arguments{,VA} to
    1:  * formatter functions.  Elements are sorted in non-increasing format string
    1:  * length order.
    1:  */
    1: struct JSArgumentFormatMap {
    1:     const char          *format;
    1:     size_t              length;
    1:     JSArgumentFormatter formatter;
    1:     JSArgumentFormatMap *next;
    1: };
    1: #endif
    1: 
    1: struct JSStackHeader {
    1:     uintN               nslots;
    1:     JSStackHeader       *down;
    1: };
    1: 
    1: #define JS_STACK_SEGMENT(sh)    ((jsval *)(sh) + 2)
    1: 
    1: /*
    1:  * Key and entry types for the JSContext.resolvingTable hash table, typedef'd
    1:  * here because all consumers need to see these declarations (and not just the
    1:  * typedef names, as would be the case for an opaque pointer-to-typedef'd-type
    1:  * declaration), along with cx->resolvingTable.
    1:  */
    1: typedef struct JSResolvingKey {
    1:     JSObject            *obj;
    1:     jsid                id;
    1: } JSResolvingKey;
    1: 
    1: typedef struct JSResolvingEntry {
    1:     JSDHashEntryHdr     hdr;
    1:     JSResolvingKey      key;
    1:     uint32              flags;
    1: } JSResolvingEntry;
    1: 
    1: #define JSRESFLAG_LOOKUP        0x1     /* resolving id from lookup */
    1: #define JSRESFLAG_WATCH         0x2     /* resolving id from watch */
    1: 
    1: typedef struct JSLocalRootChunk JSLocalRootChunk;
    1: 
    1: #define JSLRS_CHUNK_SHIFT       8
    1: #define JSLRS_CHUNK_SIZE        JS_BIT(JSLRS_CHUNK_SHIFT)
    1: #define JSLRS_CHUNK_MASK        JS_BITMASK(JSLRS_CHUNK_SHIFT)
    1: 
    1: struct JSLocalRootChunk {
    1:     jsval               roots[JSLRS_CHUNK_SIZE];
    1:     JSLocalRootChunk    *down;
    1: };
    1: 
    1: typedef struct JSLocalRootStack {
    1:     uint32              scopeMark;
    1:     uint32              rootCount;
    1:     JSLocalRootChunk    *topChunk;
    1:     JSLocalRootChunk    firstChunk;
    1: } JSLocalRootStack;
    1: 
    1: #define JSLRS_NULL_MARK ((uint32) -1)
    1: 
 3235: /*
 3235:  * Macros to push/pop JSTempValueRooter instances to context-linked stack of
 3235:  * temporary GC roots. If you need to protect a result value that flows out of
 3235:  * a C function across several layers of other functions, use the
 3235:  * js_LeaveLocalRootScopeWithResult internal API (see further below) instead.
 3235:  *
10448:  * The macros also provide a simple way to get a single rooted pointer via
10448:  * JS_PUSH_TEMP_ROOT_<KIND>(cx, NULL, &tvr). Then &tvr.u.<kind> gives the
10448:  * necessary pointer.
10448:  *
 3235:  * JSTempValueRooter.count defines the type of the rooted value referenced by
10448:  * JSTempValueRooter.u union of type JSTempValueUnion. When count is positive
10448:  * or zero, u.array points to a vector of jsvals. Otherwise it must be one of
10448:  * the following constants:
 3235:  */
10448: #define JSTVU_SINGLE        (-1)    /* u.value or u.<gcthing> is single jsval
10448:                                        or GC-thing */
10448: #define JSTVU_TRACE         (-2)    /* u.trace is a hook to trace a custom
10448:                                      * structure */
10448: #define JSTVU_SPROP         (-3)    /* u.sprop roots property tree node */
10448: #define JSTVU_WEAK_ROOTS    (-4)    /* u.weakRoots points to saved weak roots */
10448: #define JSTVU_PARSE_CONTEXT (-5)    /* u.parseContext roots JSParseContext* */
10448: #define JSTVU_SCRIPT        (-6)    /* u.script roots JSScript* */
    1: 
    1: /*
10448:  * Here single JSTVU_SINGLE covers both jsval and pointers to any GC-thing via
10448:  * reinterpreting the thing as JSVAL_OBJECT. It works because the GC-thing is
10448:  * aligned on a 0 mod 8 boundary, and object has the 0 jsval tag. So any
10448:  * GC-thing may be tagged as if it were an object and untagged, if it's then
10448:  * used only as an opaque pointer until discriminated by other means than tag
10448:  * bits. This is how, for example, js_GetGCThingTraceKind uses its |thing|
10448:  * parameter -- it consults GC-thing flags stored separately from the thing to
10448:  * decide the kind of thing.
    1:  *
 3235:  * The following checks that this type-punning is possible.
    1:  */
 3235: JS_STATIC_ASSERT(sizeof(JSTempValueUnion) == sizeof(jsval));
10448: JS_STATIC_ASSERT(sizeof(JSTempValueUnion) == sizeof(void *));
    1: 
10448: #define JS_PUSH_TEMP_ROOT_COMMON(cx,x,tvr,cnt,kind)                           \
    1:     JS_BEGIN_MACRO                                                            \
    1:         JS_ASSERT((cx)->tempValueRooters != (tvr));                           \
10448:         (tvr)->count = (cnt);                                                 \
10448:         (tvr)->u.kind = (x);                                                  \
    1:         (tvr)->down = (cx)->tempValueRooters;                                 \
    1:         (cx)->tempValueRooters = (tvr);                                       \
    1:     JS_END_MACRO
    1: 
    1: #define JS_POP_TEMP_ROOT(cx,tvr)                                              \
    1:     JS_BEGIN_MACRO                                                            \
    1:         JS_ASSERT((cx)->tempValueRooters == (tvr));                           \
    1:         (cx)->tempValueRooters = (tvr)->down;                                 \
    1:     JS_END_MACRO
    1: 
10448: #define JS_PUSH_TEMP_ROOT(cx,cnt,arr,tvr)                                     \
    1:     JS_BEGIN_MACRO                                                            \
10448:         JS_ASSERT((int)(cnt) >= 0);                                           \
10448:         JS_PUSH_TEMP_ROOT_COMMON(cx, arr, tvr, (ptrdiff_t) (cnt), array);     \
    1:     JS_END_MACRO
    1: 
10448: #define JS_PUSH_SINGLE_TEMP_ROOT(cx,val,tvr)                                  \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, val, tvr, JSTVU_SINGLE, value)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_OBJECT(cx,obj,tvr)                                  \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, obj, tvr, JSTVU_SINGLE, object)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_STRING(cx,str,tvr)                                  \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, str, tvr, JSTVU_SINGLE, string)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_QNAME(cx,qn,tvr)                                    \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, qn, tvr, JSTVU_SINGLE, qname)
10448: 
14331: #define JS_PUSH_TEMP_ROOT_NAMESPACE(cx,ns,tvr)                                \
14331:     JS_PUSH_TEMP_ROOT_COMMON(cx, ns, tvr, JSTVU_SINGLE, nspace)
14331: 
10448: #define JS_PUSH_TEMP_ROOT_XML(cx,xml_,tvr)                                    \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, xml_, tvr, JSTVU_SINGLE, xml)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_TRACE(cx,trace_,tvr)                                \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, trace_, tvr, JSTVU_TRACE, trace)
10448: 
    1: #define JS_PUSH_TEMP_ROOT_SPROP(cx,sprop_,tvr)                                \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, sprop_, tvr, JSTVU_SPROP, sprop)
    1: 
    1: #define JS_PUSH_TEMP_ROOT_WEAK_COPY(cx,weakRoots_,tvr)                        \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, weakRoots_, tvr, JSTVU_WEAK_ROOTS, weakRoots)
    1: 
 3235: #define JS_PUSH_TEMP_ROOT_PARSE_CONTEXT(cx,pc,tvr)                            \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, pc, tvr, JSTVU_PARSE_CONTEXT, parseContext)
 3235: 
 7359: #define JS_PUSH_TEMP_ROOT_SCRIPT(cx,script_,tvr)                              \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, script_, tvr, JSTVU_SCRIPT, script)
 7359: 
    1: struct JSContext {
    1:     /* JSRuntime contextList linkage. */
    1:     JSCList             links;
    1: 
 9780:     /*
 9780:      * Operation count. It is declared early in the structure as a frequently
 9780:      * accessed field.
 9780:      */
 9780:     int32               operationCount;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:     /*
    1:      * Bit-set formed from binary exponentials of the XML_* tiny-ids defined
    1:      * for boolean settings in jsxml.c, plus an XSF_CACHE_VALID bit.  Together
    1:      * these act as a cache of the boolean XML.ignore* and XML.prettyPrinting
    1:      * property values associated with this context's global object.
    1:      */
    1:     uint8               xmlSettingFlags;
 6024:     uint8               padding;
 6018: #else
 6024:     uint16              padding;
    1: #endif
    1: 
    1:     /* Runtime version control identifier. */
    1:     uint16              version;
    1: 
    1:     /* Per-context options. */
    1:     uint32              options;            /* see jsapi.h for JSOPTION_* */
    1: 
    1:     /* Locale specific callbacks for string conversion. */
    1:     JSLocaleCallbacks   *localeCallbacks;
    1: 
    1:     /*
    1:      * cx->resolvingTable is non-null and non-empty if we are initializing
    1:      * standard classes lazily, or if we are otherwise recursing indirectly
    1:      * from js_LookupProperty through a JSClass.resolve hook.  It is used to
    1:      * limit runaway recursion (see jsapi.c and jsobj.c).
    1:      */
    1:     JSDHashTable        *resolvingTable;
    1: 
    1: #if JS_HAS_LVALUE_RETURN
    1:     /*
    1:      * Secondary return value from native method called on the left-hand side
    1:      * of an assignment operator.  The native should store the object in which
    1:      * to set a property in *rval, and return the property's id expressed as a
    1:      * jsval by calling JS_SetCallReturnValue2(cx, idval).
    1:      */
    1:     jsval               rval2;
    1:     JSPackedBool        rval2set;
    1: #endif
    1: 
    1:     /*
    1:      * True if generating an error, to prevent runaway recursion.
    1:      * NB: generatingError packs with rval2set, #if JS_HAS_LVALUE_RETURN;
    1:      * with insideGCMarkCallback and with throwing below.
    1:      */
    1:     JSPackedBool        generatingError;
    1: 
    1:     /* Flag to indicate that we run inside gcCallback(cx, JSGC_MARK_END). */
    1:     JSPackedBool        insideGCMarkCallback;
    1: 
    1:     /* Exception state -- the exception member is a GC root by definition. */
    1:     JSPackedBool        throwing;           /* is there a pending exception? */
    1:     jsval               exception;          /* most-recently-thrown exception */
    1: 
 5344:     /* Limit pointer for checking native stack consumption during recursion. */
    1:     jsuword             stackLimit;
    1: 
 5344:     /* Quota on the size of arenas used to compile and execute scripts. */
 5344:     size_t              scriptStackQuota;
 5344: 
    1:     /* Data shared by threads in an address space. */
    1:     JSRuntime           *runtime;
    1: 
    1:     /* Stack arena pool and frame pointer register. */
    1:     JSArenaPool         stackPool;
    1:     JSStackFrame        *fp;
    1: 
    1:     /* Temporary arena pool used while compiling and decompiling. */
    1:     JSArenaPool         tempPool;
    1: 
    1:     /* Top-level object and pointer to top stack frame's scope chain. */
    1:     JSObject            *globalObject;
    1: 
    1:     /* Storage to root recently allocated GC things and script result. */
    1:     JSWeakRoots         weakRoots;
    1: 
    1:     /* Regular expression class statics (XXX not shared globally). */
    1:     JSRegExpStatics     regExpStatics;
    1: 
    1:     /* State for object and array toSource conversion. */
    1:     JSSharpObjectMap    sharpObjectMap;
    1: 
    1:     /* Argument formatter support for JS_{Convert,Push}Arguments{,VA}. */
    1:     JSArgumentFormatMap *argumentFormatMap;
    1: 
    1:     /* Last message string and trace file for debugging. */
    1:     char                *lastMessage;
    1: #ifdef DEBUG
    1:     void                *tracefp;
    1: #endif
    1: 
 9780:     /* Per-context optional error reporter. */
    1:     JSErrorReporter     errorReporter;
    1: 
 9780:     /*
 9780:      * Flag indicating that the operation callback is set. When the flag is 0
 9780:      * but operationCallback is not null, operationCallback stores the branch
 9780:      * callback.
 9780:      */
 9780:     uint32              operationCallbackIsSet :    1;
 9780:     uint32              operationLimit         :    31;
 9780:     JSOperationCallback operationCallback;
 9780: 
    1:     /* Interpreter activation count. */
    1:     uintN               interpLevel;
    1: 
    1:     /* Client opaque pointer */
    1:     void                *data;
    1: 
    1:     /* GC and thread-safe state. */
    1:     JSStackFrame        *dormantFrameChain; /* dormant stack frame to scan */
    1: #ifdef JS_THREADSAFE
    1:     JSThread            *thread;
    1:     jsrefcount          requestDepth;
 7286:     /* Same as requestDepth but ignoring JS_SuspendRequest/JS_ResumeRequest */
 7286:     jsrefcount          outstandingRequests;
11739:     JSTitle             *titleToShare;      /* weak reference, see jslock.c */
11739:     JSTitle             *lockedSealedTitle; /* weak ref, for low-cost sealed
11739:                                                title locking */
    1:     JSCList             threadLinks;        /* JSThread contextList linkage */
    1: 
    1: #define CX_FROM_THREAD_LINKS(tl) \
    1:     ((JSContext *)((char *)(tl) - offsetof(JSContext, threadLinks)))
    1: #endif
    1: 
    1:     /* PDL of stack headers describing stack slots not rooted by argv, etc. */
    1:     JSStackHeader       *stackHeaders;
    1: 
    1:     /* Optional stack of heap-allocated scoped local GC roots. */
    1:     JSLocalRootStack    *localRootStack;
    1: 
    1:     /* Stack of thread-stack-allocated temporary GC roots. */
    1:     JSTempValueRooter   *tempValueRooters;
 2433: 
12282:     /* List of pre-allocated doubles. */
12282:     JSGCDoubleCell      *doubleFreeList;
12282: 
 2433:     /* Debug hooks associated with the current context. */
 2433:     JSDebugHooks        *debugHooks;
    1: };
    1: 
    1: #ifdef JS_THREADSAFE
    1: # define JS_THREAD_ID(cx)       ((cx)->thread ? (cx)->thread->id : 0)
    1: #endif
    1: 
    1: #ifdef __cplusplus
    1: /* FIXME(bug 332648): Move this into a public header. */
    1: class JSAutoTempValueRooter
    1: {
    1:   public:
    1:     JSAutoTempValueRooter(JSContext *cx, size_t len, jsval *vec)
    1:         : mContext(cx) {
    1:         JS_PUSH_TEMP_ROOT(mContext, len, vec, &mTvr);
    1:     }
    1:     JSAutoTempValueRooter(JSContext *cx, jsval v)
    1:         : mContext(cx) {
    1:         JS_PUSH_SINGLE_TEMP_ROOT(mContext, v, &mTvr);
    1:     }
    1: 
    1:     ~JSAutoTempValueRooter() {
    1:         JS_POP_TEMP_ROOT(mContext, &mTvr);
    1:     }
    1: 
    1:   private:
15009: #ifndef AIX
    1:     static void *operator new(size_t);
    1:     static void operator delete(void *, size_t);
15009: #endif
    1: 
    1:     JSContext *mContext;
    1:     JSTempValueRooter mTvr;
    1: };
    1: #endif
    1: 
    1: /*
    1:  * Slightly more readable macros for testing per-context option settings (also
    1:  * to hide bitset implementation detail).
    1:  *
    1:  * JSOPTION_XML must be handled specially in order to propagate from compile-
    1:  * to run-time (from cx->options to script->version/cx->version).  To do that,
    1:  * we copy JSOPTION_XML from cx->options into cx->version as JSVERSION_HAS_XML
    1:  * whenever options are set, and preserve this XML flag across version number
    1:  * changes done via the JS_SetVersion API.
    1:  *
    1:  * But when executing a script or scripted function, the interpreter changes
    1:  * cx->version, including the XML flag, to script->version.  Thus JSOPTION_XML
    1:  * is a compile-time option that causes a run-time version change during each
    1:  * activation of the compiled script.  That version change has the effect of
    1:  * changing JS_HAS_XML_OPTION, so that any compiling done via eval enables XML
    1:  * support.  If an XML-enabled script or function calls a non-XML function,
    1:  * the flag bit will be cleared during the callee's activation.
    1:  *
    1:  * Note that JS_SetVersion API calls never pass JSVERSION_HAS_XML or'd into
    1:  * that API's version parameter.
    1:  *
    1:  * Note also that script->version must contain this XML option flag in order
    1:  * for XDR'ed scripts to serialize and deserialize with that option preserved
    1:  * for detection at run-time.  We can't copy other compile-time options into
    1:  * script->version because that would break backward compatibility (certain
    1:  * other options, e.g. JSOPTION_VAROBJFIX, are analogous to JSOPTION_XML).
    1:  */
    1: #define JS_HAS_OPTION(cx,option)        (((cx)->options & (option)) != 0)
    1: #define JS_HAS_STRICT_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_STRICT)
    1: #define JS_HAS_WERROR_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_WERROR)
    1: #define JS_HAS_COMPILE_N_GO_OPTION(cx)  JS_HAS_OPTION(cx, JSOPTION_COMPILE_N_GO)
    1: #define JS_HAS_ATLINE_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_ATLINE)
    1: 
    1: #define JSVERSION_MASK                  0x0FFF  /* see JSVersion in jspubtd.h */
    1: #define JSVERSION_HAS_XML               0x1000  /* flag induced by XML option */
    1: 
 3164: #define JSVERSION_NUMBER(cx)            ((JSVersion)((cx)->version &          \
 3164:                                                      JSVERSION_MASK))
    1: #define JS_HAS_XML_OPTION(cx)           ((cx)->version & JSVERSION_HAS_XML || \
    1:                                          JSVERSION_NUMBER(cx) >= JSVERSION_1_6)
    1: 
    1: /*
    1:  * Initialize a library-wide thread private data index, and remember that it
    1:  * has already been done, so that it happens only once ever.  Returns true on
    1:  * success.
    1:  */
    1: extern JSBool
 3424: js_InitThreadPrivateIndex(void (JS_DLL_CALLBACK *ptr)(void *));
    1: 
    1: /*
    1:  * Common subroutine of JS_SetVersion and js_SetVersion, to update per-context
    1:  * data that depends on version.
    1:  */
    1: extern void
    1: js_OnVersionChange(JSContext *cx);
    1: 
    1: /*
    1:  * Unlike the JS_SetVersion API, this function stores JSVERSION_HAS_XML and
    1:  * any future non-version-number flags induced by compiler options.
    1:  */
    1: extern void
    1: js_SetVersion(JSContext *cx, JSVersion version);
    1: 
    1: /*
    1:  * Create and destroy functions for JSContext, which is manually allocated
    1:  * and exclusively owned.
    1:  */
    1: extern JSContext *
    1: js_NewContext(JSRuntime *rt, size_t stackChunkSize);
    1: 
    1: extern void
    1: js_DestroyContext(JSContext *cx, JSDestroyContextMode mode);
    1: 
    1: /*
    1:  * Return true if cx points to a context in rt->contextList, else return false.
11739:  * NB: the caller (see jslock.c:ClaimTitle) must hold rt->gcLock.
    1:  */
    1: extern JSBool
    1: js_ValidContextPointer(JSRuntime *rt, JSContext *cx);
    1: 
    1: /*
    1:  * If unlocked, acquire and release rt->gcLock around *iterp update; otherwise
    1:  * the caller must be holding rt->gcLock.
    1:  */
    1: extern JSContext *
    1: js_ContextIterator(JSRuntime *rt, JSBool unlocked, JSContext **iterp);
    1: 
    1: /*
    1:  * JSClass.resolve and watchpoint recursion damping machinery.
    1:  */
    1: extern JSBool
    1: js_StartResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                   JSResolvingEntry **entryp);
    1: 
    1: extern void
    1: js_StopResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                  JSResolvingEntry *entry, uint32 generation);
    1: 
    1: /*
    1:  * Local root set management.
    1:  *
    1:  * NB: the jsval parameters below may be properly tagged jsvals, or GC-thing
    1:  * pointers cast to (jsval).  This relies on JSObject's tag being zero, but
    1:  * on the up side it lets us push int-jsval-encoded scopeMark values on the
    1:  * local root stack.
    1:  */
    1: extern JSBool
    1: js_EnterLocalRootScope(JSContext *cx);
    1: 
    1: #define js_LeaveLocalRootScope(cx) \
    1:     js_LeaveLocalRootScopeWithResult(cx, JSVAL_NULL)
    1: 
    1: extern void
    1: js_LeaveLocalRootScopeWithResult(JSContext *cx, jsval rval);
    1: 
    1: extern void
    1: js_ForgetLocalRoot(JSContext *cx, jsval v);
    1: 
    1: extern int
    1: js_PushLocalRoot(JSContext *cx, JSLocalRootStack *lrs, jsval v);
    1: 
    1: extern void
  583: js_TraceLocalRoots(JSTracer *trc, JSLocalRootStack *lrs);
    1: 
    1: /*
    1:  * Report an exception, which is currently realized as a printf-style format
    1:  * string and its arguments.
    1:  */
    1: typedef enum JSErrNum {
    1: #define MSG_DEF(name, number, count, exception, format) \
    1:     name = number,
    1: #include "js.msg"
    1: #undef MSG_DEF
    1:     JSErr_Limit
    1: } JSErrNum;
    1: 
    1: extern const JSErrorFormatString *
    1: js_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber);
    1: 
    1: #ifdef va_start
    1: extern JSBool
    1: js_ReportErrorVA(JSContext *cx, uintN flags, const char *format, va_list ap);
    1: 
    1: extern JSBool
    1: js_ReportErrorNumberVA(JSContext *cx, uintN flags, JSErrorCallback callback,
    1:                        void *userRef, const uintN errorNumber,
    1:                        JSBool charArgs, va_list ap);
    1: 
    1: extern JSBool
    1: js_ExpandErrorArguments(JSContext *cx, JSErrorCallback callback,
    1:                         void *userRef, const uintN errorNumber,
    1:                         char **message, JSErrorReport *reportp,
    1:                         JSBool *warningp, JSBool charArgs, va_list ap);
    1: #endif
    1: 
    1: extern void
    1: js_ReportOutOfMemory(JSContext *cx);
    1: 
    1: /*
 8296:  * Report that cx->scriptStackQuota is exhausted.
 8296:  */
 8296: extern void
 8296: js_ReportOutOfScriptQuota(JSContext *cx);
 8296: 
 8296: extern void
 8296: js_ReportOverRecursed(JSContext *cx);
 8296: 
12983: extern void
12983: js_ReportAllocationOverflow(JSContext *cx);
12983: 
11139: #define JS_CHECK_RECURSION(cx, onerror)                                       \
11139:     JS_BEGIN_MACRO                                                            \
11139:         int stackDummy_;                                                      \
11139:                                                                               \
11139:         if (!JS_CHECK_STACK_SIZE(cx, stackDummy_)) {                          \
11139:             js_ReportOverRecursed(cx);                                        \
11139:             onerror;                                                          \
11139:         }                                                                     \
11139:     JS_END_MACRO
11139: 
 8296: /*
    1:  * Report an exception using a previously composed JSErrorReport.
    1:  * XXXbe remove from "friend" API
    1:  */
    1: extern JS_FRIEND_API(void)
    1: js_ReportErrorAgain(JSContext *cx, const char *message, JSErrorReport *report);
    1: 
    1: extern void
    1: js_ReportIsNotDefined(JSContext *cx, const char *name);
    1: 
    1: /*
 7897:  * Report an attempt to access the property of a null or undefined value (v).
 7897:  */
 7897: extern JSBool
 7897: js_ReportIsNullOrUndefined(JSContext *cx, intN spindex, jsval v,
 7897:                            JSString *fallback);
 7897: 
 7897: /*
    1:  * Report error using js_DecompileValueGenerator(cx, spindex, v, fallback) as
    1:  * the first argument for the error message. If the error message has less
    1:  * then 3 arguments, use null for arg1 or arg2.
    1:  */
    1: extern JSBool
    1: js_ReportValueErrorFlags(JSContext *cx, uintN flags, const uintN errorNumber,
    1:                          intN spindex, jsval v, JSString *fallback,
    1:                          const char *arg1, const char *arg2);
    1: 
    1: #define js_ReportValueError(cx,errorNumber,spindex,v,fallback)                \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, NULL, NULL))
    1: 
    1: #define js_ReportValueError2(cx,errorNumber,spindex,v,fallback,arg1)          \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, arg1, NULL))
    1: 
    1: #define js_ReportValueError3(cx,errorNumber,spindex,v,fallback,arg1,arg2)     \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, arg1, arg2))
    1: 
    1: extern JSErrorFormatString js_ErrorFormatString[JSErr_Limit];
    1: 
    1: /*
    1:  * See JS_SetThreadStackLimit in jsapi.c, where we check that the stack grows
    1:  * in the expected direction.  On Unix-y systems, JS_STACK_GROWTH_DIRECTION is
    1:  * computed on the build host by jscpucfg.c and written into jsautocfg.h.  The
    1:  * macro is hardcoded in jscpucfg.h on Windows and Mac systems (for historical
    1:  * reasons pre-dating autoconf usage).
    1:  */
    1: #if JS_STACK_GROWTH_DIRECTION > 0
    1: # define JS_CHECK_STACK_SIZE(cx, lval)  ((jsuword)&(lval) < (cx)->stackLimit)
    1: #else
    1: # define JS_CHECK_STACK_SIZE(cx, lval)  ((jsuword)&(lval) > (cx)->stackLimit)
    1: #endif
    1: 
 9780: /*
 9780:  * Update the operation counter according to the given weight and call the
 9780:  * operation callback when we reach the operation limit. To make this
 9780:  * frequently executed macro faster we decrease the counter from
 9780:  * JSContext.operationLimit and compare against zero to check the limit.
 9780:  *
 9780:  * This macro can run the full GC. Return true if it is OK to continue and
 9780:  * false otherwise.
 9780:  */
 9780: #define JS_CHECK_OPERATION_LIMIT(cx, weight)                                  \
 9780:     (JS_CHECK_OPERATION_WEIGHT(weight),                                       \
 9780:      (((cx)->operationCount -= (weight)) > 0 || js_ResetOperationCount(cx)))
 9780: 
 9780: /*
 9780:  * A version of JS_CHECK_OPERATION_LIMIT that just updates the operation count
 9780:  * without calling the operation callback or any other API. This macro resets
 9780:  * the count to 0 when it becomes negative to prevent a wrap-around when the
 9780:  * macro is called repeatably.
 9780:  */
 9780: #define JS_COUNT_OPERATION(cx, weight)                                        \
 9780:     ((void)(JS_CHECK_OPERATION_WEIGHT(weight),                                \
 9780:             (cx)->operationCount = ((cx)->operationCount > 0)                 \
 9780:                                    ? (cx)->operationCount - (weight)          \
 9780:                                    : 0))
 9780: 
 9780: /*
 9780:  * The implementation of the above macros assumes that subtracting weights
 9780:  * twice from a positive number does not wrap-around INT32_MIN.
 9780:  */
 9780: #define JS_CHECK_OPERATION_WEIGHT(weight)                                     \
 9780:     (JS_ASSERT((uint32) (weight) > 0),                                        \
 9780:      JS_ASSERT((uint32) (weight) < JS_BIT(30)))
 9780: 
    1: /* Relative operations weights. */
    1: #define JSOW_JUMP                   1
    1: #define JSOW_ALLOCATION             100
    1: #define JSOW_LOOKUP_PROPERTY        5
    1: #define JSOW_GET_PROPERTY           10
    1: #define JSOW_SET_PROPERTY           20
    1: #define JSOW_NEW_PROPERTY           200
    1: #define JSOW_DELETE_PROPERTY        30
10142: #define JSOW_ENTER_SHARP            JS_OPERATION_WEIGHT_BASE
10142: #define JSOW_SCRIPT_JUMP            JS_OPERATION_WEIGHT_BASE
    1: 
    1: /*
 9780:  * Reset the operation count and call the operation callback assuming that the
    1:  * operation limit is reached.
    1:  */
    1: extern JSBool
 9780: js_ResetOperationCount(JSContext *cx);
    1: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jscntxt_h___ */
