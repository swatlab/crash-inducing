 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JavaScript iterators.
     1:  */
 80468: #include "mozilla/Util.h"
 80468: 
     1: #include "jstypes.h"
     1: #include "jsutil.h"
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jsbool.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsexn.h"
     1: #include "jsfun.h"
     1: #include "jsgc.h"
     1: #include "jsinterp.h"
     1: #include "jsiter.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
 42733: #include "jsproxy.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: 
     1: #if JS_HAS_XML_SUPPORT
     1: #include "jsxml.h"
     1: #endif
     1: 
 84344: #include "ds/Sort.h"
 80506: #include "frontend/TokenStream.h"
 97569: #include "gc/Marking.h"
 75062: #include "vm/GlobalObject.h"
 75062: 
 77343: #include "jsinferinlines.h"
 40858: #include "jsobjinlines.h"
 40858: 
105836: #include "builtin/Iterator-inl.h"
 69223: #include "vm/Stack-inl.h"
 72107: #include "vm/String-inl.h"
 69223: 
 80468: using namespace mozilla;
 37741: using namespace js;
 54707: using namespace js::gc;
 37741: 
103624: Class js::ElementIteratorClass = {
103624:     "ElementIterator",
103624:     JSCLASS_HAS_RESERVED_SLOTS(ElementIteratorObject::NumSlots),
103624:     JS_PropertyStub,         /* addProperty */
103624:     JS_PropertyStub,         /* delProperty */
103624:     JS_PropertyStub,         /* getProperty */
103624:     JS_StrictPropertyStub,   /* setProperty */
103624:     JS_EnumerateStub,
103624:     JS_ResolveStub,
103624:     JS_ConvertStub,
103624:     NULL,                    /* finalize    */
103624:     NULL,                    /* checkAccess */
103624:     NULL,                    /* call        */
103624:     NULL,                    /* construct   */
103624:     NULL,                    /* hasInstance */
103624:     NULL,                    /* trace       */
103624:     {
103624:         NULL,                /* equality       */
103624:         NULL,                /* outerObject    */
103624:         NULL,                /* innerObject    */
105837:         NULL,                /* iteratorObject */
103624:         NULL                 /* unused  */
103624:     }
103624: };
103624: 
 83316: static const gc::AllocKind ITERATOR_FINALIZE_KIND = gc::FINALIZE_OBJECT2;
 83316: 
 42641: void
 42641: NativeIterator::mark(JSTracer *trc)
 42641: {
 87655:     for (HeapPtr<JSFlatString> *str = begin(); str < end(); str++)
 90409:         MarkString(trc, str, "prop");
 48470:     if (obj)
 90409:         MarkObject(trc, &obj, "obj");
 42641: }
  3436: 
 48470: struct IdHashPolicy {
 48470:     typedef jsid Lookup;
 48470:     static HashNumber hash(jsid id) {
 48470:         return JSID_BITS(id);
 48470:     }
 48470:     static bool match(jsid id1, jsid id2) {
 48470:         return id1 == id2;
 48470:     }
 48470: };
 48470: 
 72091: typedef HashSet<jsid, IdHashPolicy> IdSet;
 48470: 
 48470: static inline bool
 48470: NewKeyValuePair(JSContext *cx, jsid id, const Value &val, Value *rval)
 42641: {
 48470:     Value vec[2] = { IdToValue(id), val };
 80468:     AutoArrayRooter tvr(cx, ArrayLength(vec), vec);
     1: 
 59234:     JSObject *aobj = NewDenseCopiedArray(cx, 2, vec);
 42641:     if (!aobj)
 42641:         return false;
 48470:     rval->setObject(*aobj);
 42641:     return true;
 42641: }
 42641: 
 42641: static inline bool
 42691: Enumerate(JSContext *cx, JSObject *obj, JSObject *pobj, jsid id,
 91237:           bool enumerable, unsigned flags, IdSet& ht, AutoIdVector *props)
     1: {
 72089:     JS_ASSERT_IF(flags & JSITER_OWNONLY, obj == pobj);
 72089: 
 79933:     /*
 79933:      * We implement __proto__ using a property on |Object.prototype|, but
 79933:      * because __proto__ is highly deserving of removal, we don't want it to
 79933:      * show up in property enumeration, even if only for |Object.prototype|
 79933:      * (think introspection by Prototype-like frameworks that add methods to
 79933:      * the built-in prototypes).  So exclude __proto__ if the object where the
 79933:      * property was found has no [[Prototype]] and might be |Object.prototype|.
 79933:      */
 79933:     if (JS_UNLIKELY(!pobj->getProto() && JSID_IS_ATOM(id, cx->runtime->atomState.protoAtom)))
 79933:         return true;
 79933: 
 72560:     if (!(flags & JSITER_OWNONLY) || pobj->isProxy() || pobj->getOps()->enumerate) {
 72560:         /* If we've already seen this, we definitely won't add it. */
 48470:         IdSet::AddPtr p = ht.lookupForAdd(id);
 42641:         if (JS_UNLIKELY(!!p))
 42641:             return true;
 47569: 
 47569:         /*
 72089:          * It's not necessary to add properties to the hash table at the end of
 72560:          * the prototype chain, but custom enumeration behaviors might return
 72560:          * duplicated properties, so always add in such cases.
 47569:          */
 72560:         if ((pobj->getProto() || pobj->isProxy() || pobj->getOps()->enumerate) && !ht.add(p, id))
 42641:             return false;
 42641:     }
 47569: 
 48470:     if (enumerable || (flags & JSITER_HIDDEN))
 61055:         return props->append(id);
 48470: 
 42641:     return true;
 42641: }
 42641: 
 42641: static bool
 99364: EnumerateNativeProperties(JSContext *cx, JSObject *obj_, JSObject *pobj_, unsigned flags, IdSet &ht,
 61055:                           AutoIdVector *props)
 42641: {
 99421:     RootedObject obj(cx, obj_), pobj(cx, pobj_);
 86437: 
 54562:     size_t initialLength = props->length();
 42641: 
 42641:     /* Collect all unique properties from this object's scope. */
 86437:     Shape::Range r = pobj->lastProperty()->all();
 99364:     Shape::Range::AutoRooter root(cx, &r);
 86437:     for (; !r.empty(); r.popFront()) {
103639:         Shape &shape = r.front();
 52503: 
 83221:         if (!JSID_IS_DEFAULT_XML_NAMESPACE(shape.propid()) &&
 83221:             !Enumerate(cx, obj, pobj, shape.propid(), shape.enumerable(), flags, ht, props))
 47569:         {
 42641:             return false;
 42641:         }
 42641:     }
 42641: 
 64335:     ::Reverse(props->begin() + initialLength, props->end());
 42641:     return true;
 42641: }
 42641: 
 42641: static bool
 91237: EnumerateDenseArrayProperties(JSContext *cx, JSObject *obj, JSObject *pobj, unsigned flags,
 61055:                               IdSet &ht, AutoIdVector *props)
 42641: {
 97828:     if (!Enumerate(cx, obj, pobj, NameToId(cx->runtime->atomState.lengthAtom), false,
 47569:                    flags, ht, props)) {
 47569:         return false;
 47569:     }
 42641: 
 48537:     if (pobj->getArrayLength() > 0) {
 77343:         size_t initlen = pobj->getDenseArrayInitializedLength();
 74457:         const Value *vp = pobj->getDenseArrayElements();
 77343:         for (size_t i = 0; i < initlen; ++i, ++vp) {
 48470:             if (!vp->isMagic(JS_ARRAY_HOLE)) {
 42641:                 /* Dense arrays never get so large that i would not fit into an integer id. */
 72089:                 if (!Enumerate(cx, obj, pobj, INT_TO_JSID(i), true, flags, ht, props))
 42641:                     return false;
 42641:             }
 42641:         }
 42641:     }
 47569: 
 42641:     return true;
 42641: }
 42641: 
 84344: #ifdef JS_MORE_DETERMINISTIC
 84344: 
 84344: struct SortComparatorIds
 84344: {
 84344:     JSContext   *const cx;
 84344: 
 84344:     SortComparatorIds(JSContext *cx)
 84344:       : cx(cx) {}
 84344: 
 84344:     bool operator()(jsid a, jsid b, bool *lessOrEqualp)
 84344:     {
 84344:         /* Pick an arbitrary total order on jsids that is stable across executions. */
 84344:         JSString *astr = IdToString(cx, a);
 84344: 	if (!astr)
 84344: 	    return false;
 84344:         JSString *bstr = IdToString(cx, b);
 84344:         if (!bstr)
 84344:             return false;
 84344: 
 84755:         int32_t result;
 84344:         if (!CompareStrings(cx, astr, bstr, &result))
 84344:             return false;
 84344: 
 84344:         *lessOrEqualp = (result <= 0);
 84344:         return true;
 84344:     }
 84344: };
 84344: 
 84344: #endif /* JS_MORE_DETERMINISTIC */
 84344: 
 47459: static bool
 99364: Snapshot(JSContext *cx, JSObject *obj_, unsigned flags, AutoIdVector *props)
 42641: {
 48470:     IdSet ht(cx);
 47569:     if (!ht.init(32))
101773:         return false;
 42641: 
 99421:     RootedObject obj(cx, obj_), pobj(cx);
 86437:     pobj = obj;
 86437: 
 47459:     do {
 48470:         Class *clasp = pobj->getClass();
 42691:         if (pobj->isNative() &&
 48622:             !pobj->getOps()->enumerate &&
 42641:             !(clasp->flags & JSCLASS_NEW_ENUMERATE)) {
 42691:             if (!clasp->enumerate(cx, pobj))
 47459:                 return false;
 61055:             if (!EnumerateNativeProperties(cx, obj, pobj, flags, ht, props))
 47459:                 return false;
 42691:         } else if (pobj->isDenseArray()) {
 61055:             if (!EnumerateDenseArrayProperties(cx, obj, pobj, flags, ht, props))
 47459:                 return false;
 42641:         } else {
 42733:             if (pobj->isProxy()) {
 48470:                 AutoIdVector proxyProps(cx);
 42733:                 if (flags & JSITER_OWNONLY) {
 61423:                     if (flags & JSITER_HIDDEN) {
 79386:                         if (!Proxy::getOwnPropertyNames(cx, pobj, proxyProps))
 61423:                             return false;
 61423:                     } else {
 79386:                         if (!Proxy::keys(cx, pobj, proxyProps))
 47459:                             return false;
 61423:                     }
 42733:                 } else {
 79386:                     if (!Proxy::enumerate(cx, pobj, proxyProps))
 47459:                         return false;
 42733:                 }
 47460:                 for (size_t n = 0, len = proxyProps.length(); n < len; n++) {
 72089:                     if (!Enumerate(cx, obj, pobj, proxyProps[n], true, flags, ht, props))
 47459:                         return false;
 42733:                 }
 42733:                 /* Proxy objects enumerate the prototype on their own, so we are done here. */
 42733:                 break;
 42733:             }
 48470:             Value state;
 47569:             JSIterateOp op = (flags & JSITER_HIDDEN) ? JSENUMERATE_INIT_ALL : JSENUMERATE_INIT;
 47569:             if (!pobj->enumerate(cx, op, &state, NULL))
 47459:                 return false;
 48470:             if (state.isMagic(JS_NATIVE_ENUMERATE)) {
 61055:                 if (!EnumerateNativeProperties(cx, obj, pobj, flags, ht, props))
 47459:                     return false;
 42641:             } else {
 42641:                 while (true) {
 42641:                     jsid id;
 42691:                     if (!pobj->enumerate(cx, JSENUMERATE_NEXT, &state, &id))
 47459:                         return false;
 48470:                     if (state.isNull())
 42641:                         break;
 72089:                     if (!Enumerate(cx, obj, pobj, id, true, flags, ht, props))
 47459:                         return false;
 42641:                 }
 42641:             }
 42641:         }
     1: 
 98644:         if (flags & JSITER_OWNONLY)
 42641:             break;
 98644: 
 98644: #if JS_HAS_XML_SUPPORT
 98644:         if (pobj->isXML())
 98644:             break;
 98644: #endif
 47459:     } while ((pobj = pobj->getProto()) != NULL);
     1: 
 84344: #ifdef JS_MORE_DETERMINISTIC
 84344: 
 84344:     /*
 84344:      * In some cases the enumeration order for an object depends on the
 84344:      * execution mode (interpreter vs. JIT), especially for native objects
 84344:      * with a class enumerate hook (where resolving a property changes the
 84344:      * resulting enumeration order). These aren't really bugs, but the
 84344:      * differences can change the generated output and confuse correctness
 84344:      * fuzzers, so we sort the ids if such a fuzzer is running.
 84344:      *
 84344:      * We don't do this in the general case because (a) doing so is slow,
 84344:      * and (b) it also breaks the web, which expects enumeration order to
 84344:      * follow the order in which properties are added, in certain cases.
 84344:      * Since ECMA does not specify an enumeration order for objects, both
 84344:      * behaviors are technically correct to do.
 84344:      */
 84344: 
 84344:     jsid *ids = props->begin();
 84344:     size_t n = props->length();
 84344: 
 84344:     Vector<jsid> tmp(cx);
 84344:     if (!tmp.resizeUninitialized(n))
 84344:         return false;
 84344: 
 84344:     if (!MergeSort(ids, n, tmp.begin(), SortComparatorIds(cx)))
 84344:         return false;
 84344: 
 84344: #endif /* JS_MORE_DETERMINISTIC */
 84344: 
 47459:     return true;
 42641: }
 42641: 
 42641: bool
 79734: js::VectorToIdArray(JSContext *cx, AutoIdVector &props, JSIdArray **idap)
 42641: {
 47459:     JS_STATIC_ASSERT(sizeof(JSIdArray) > sizeof(jsid));
 47459:     size_t len = props.length();
 47459:     size_t idsz = len * sizeof(jsid);
 47459:     size_t sz = (sizeof(JSIdArray) - sizeof(jsid)) + idsz;
 64560:     JSIdArray *ida = static_cast<JSIdArray *>(cx->malloc_(sz));
 47459:     if (!ida)
 47459:         return false;
 47459: 
 91450:     ida->length = static_cast<int>(len);
 82129:     jsid *v = props.begin();
 91450:     for (int i = 0; i < ida->length; i++)
 82129:         ida->vector[i].init(v[i]);
 42641:     *idap = ida;
 42641:     return true;
 42641: }
 42641: 
 55632: JS_FRIEND_API(bool)
 91237: js::GetPropertyNames(JSContext *cx, JSObject *obj, unsigned flags, AutoIdVector *props)
 42733: {
 61055:     return Snapshot(cx, obj, flags & (JSITER_OWNONLY | JSITER_HIDDEN), props);
 42733: }
 42733: 
 74914: size_t sCustomIteratorCount = 0;
 74914: 
 42641: static inline bool
 95355: GetCustomIterator(JSContext *cx, HandleObject obj, unsigned flags, Value *vp)
 42641: {
 82893:     JS_CHECK_RECURSION(cx, return false);
 82893: 
 42641:     /* Check whether we have a valid __iterator__ method. */
105837:     PropertyName *name = cx->runtime->atomState.iteratorIntrinsicAtom;
 98960:     if (!GetMethod(cx, obj, name, 0, vp))
 42641:         return false;
 42641: 
 42641:     /* If there is no custom __iterator__ method, we are done here. */
 60775:     if (!vp->isObject()) {
 60775:         vp->setUndefined();
 42641:         return true;
 60775:     }
 42641: 
 74914:     if (!cx->runningWithTrustedPrincipals())
 74914:         ++sCustomIteratorCount;
 74914: 
 42641:     /* Otherwise call it and return that object. */
 48470:     Value arg = BooleanValue((flags & JSITER_FOREACH) == 0);
 76829:     if (!Invoke(cx, ObjectValue(*obj), *vp, 1, &arg, vp))
 42641:         return false;
 48470:     if (vp->isPrimitive()) {
 43211:         /*
 91364:          * We are always coming from js::ValueToIterator, and we are no longer on
 43211:          * trace, so the object we are iterating over is on top of the stack (-1).
 43211:          */
 57812:         JSAutoByteString bytes;
 97828:         if (!js_AtomToPrintableString(cx, name, &bytes))
 57812:             return false;
 43211:         js_ReportValueError2(cx, JSMSG_BAD_TRAP_RETURN_VALUE,
 57812:                              -1, ObjectValue(*obj), NULL, bytes.ptr());
 42641:         return false;
 42641:     }
 42641:     return true;
 42641: }
 42641: 
 42641: template <typename T>
 42641: static inline bool
 42641: Compare(T *a, T *b, size_t c)
 42641: {
 42641:     size_t n = (c + size_t(7)) / size_t(8);
 42641:     switch (c % 8) {
 42641:       case 0: do { if (*a++ != *b++) return false;
 42641:       case 7:      if (*a++ != *b++) return false;
 42641:       case 6:      if (*a++ != *b++) return false;
 42641:       case 5:      if (*a++ != *b++) return false;
 42641:       case 4:      if (*a++ != *b++) return false;
 42641:       case 3:      if (*a++ != *b++) return false;
 42641:       case 2:      if (*a++ != *b++) return false;
 42641:       case 1:      if (*a++ != *b++) return false;
 42641:               } while (--n > 0);
 42641:     }
 42641:     return true;
 42641: }
 42641: 
105836: static inline PropertyIteratorObject *
105836: NewPropertyIteratorObject(JSContext *cx, unsigned flags)
 43190: {
 47497:     if (flags & JSITER_ENUMERATE) {
103990:         RootedTypeObject type(cx, cx->compartment->getEmptyType(cx));
 83230:         if (!type)
 83230:             return NULL;
 83230: 
105836:         RootedShape shape(cx, EmptyShape::getInitialShape(cx, &PropertyIteratorObject::class_,
105836:                                                           NULL, NULL, ITERATOR_FINALIZE_KIND));
103990:         if (!shape)
 80622:             return NULL;
 83230: 
103990:         JSObject *obj = JSObject::create(cx, ITERATOR_FINALIZE_KIND, shape, type, NULL);
 47497:         if (!obj)
 68902:             return NULL;
 64242: 
 83233:         JS_ASSERT(obj->numFixedSlots() == JSObject::ITER_CLASS_NFIXED_SLOTS);
105836:         return &obj->asPropertyIterator();
 47497:     }
 47497: 
105836:     return &NewBuiltinClassInstance(cx, &PropertyIteratorObject::class_)->asPropertyIterator();
 43190: }
 43190: 
 48470: NativeIterator *
 84755: NativeIterator::allocateIterator(JSContext *cx, uint32_t slength, const AutoIdVector &props)
 48470: {
 48470:     size_t plength = props.length();
 48470:     NativeIterator *ni = (NativeIterator *)
 87655:         cx->malloc_(sizeof(NativeIterator)
 87655:                     + plength * sizeof(JSString *)
 87655:                     + slength * sizeof(Shape *));
 48470:     if (!ni)
 48470:         return NULL;
 87872:     AutoValueVector strings(cx);
 87655:     ni->props_array = ni->props_cursor = (HeapPtr<JSFlatString> *) (ni + 1);
 82129:     ni->props_end = ni->props_array + plength;
 82129:     if (plength) {
 87655:         for (size_t i = 0; i < plength; i++) {
 87655:             JSFlatString *str = IdToString(cx, props[i]);
 87872:             if (!str || !strings.append(StringValue(str)))
 87655:                 return NULL;
 87655:             ni->props_array[i].init(str);
 87655:         }
 82129:     }
 48470:     return ni;
 48470: }
 48470: 
 48470: inline void
 91237: NativeIterator::init(JSObject *obj, unsigned flags, uint32_t slength, uint32_t key)
 48470: {
 82129:     this->obj.init(obj);
 48470:     this->flags = flags;
103639:     this->shapes_array = (Shape **) this->props_end;
 48470:     this->shapes_length = slength;
 48470:     this->shapes_key = key;
 48470: }
 48470: 
 43281: static inline void
105836: RegisterEnumerator(JSContext *cx, PropertyIteratorObject *iterobj, NativeIterator *ni)
 43281: {
 43281:     /* Register non-escaping native enumerators (for-in) with the current context. */
 43281:     if (ni->flags & JSITER_ENUMERATE) {
 43281:         ni->next = cx->enumerators;
 43281:         cx->enumerators = iterobj;
 53519: 
 53519:         JS_ASSERT(!(ni->flags & JSITER_ACTIVE));
 62413:         ni->flags |= JSITER_ACTIVE;
 43281:     }
 43281: }
 43281: 
 48470: static inline bool
 95355: VectorToKeyIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &keys,
 84755:                     uint32_t slength, uint32_t key, Value *vp)
 43190: {
 48470:     JS_ASSERT(!(flags & JSITER_FOREACH));
 48470: 
 77361:     if (obj) {
 83248:         if (obj->hasSingletonType() && !obj->setIteratedSingleton(cx))
 83248:             return false;
 77353:         types::MarkTypeObjectFlags(cx, obj, types::OBJECT_FLAG_ITERATED);
 77361:     }
 77343: 
105836:     Rooted<PropertyIteratorObject *> iterobj(cx, NewPropertyIteratorObject(cx, flags));
 43190:     if (!iterobj)
 43190:         return false;
 43190: 
 61055:     NativeIterator *ni = NativeIterator::allocateIterator(cx, slength, keys);
 43190:     if (!ni)
 53404:         return false;
 53404:     ni->init(obj, flags, slength, key);
 53404: 
 53404:     if (slength) {
 53404:         /*
 53404:          * Fill in the shape array from scratch.  We can't use the array that was
 53404:          * computed for the cache lookup earlier, as constructing iterobj could
 53404:          * have triggered a shape-regenerating GC.  Don't bother with regenerating
 53404:          * the shape key; if such a GC *does* occur, we can only get hits through
 53404:          * the one-slot lastNativeIterator cache.
 53404:          */
 53404:         JSObject *pobj = obj;
 53404:         size_t ind = 0;
 53404:         do {
 83221:             ni->shapes_array[ind++] = pobj->lastProperty();
 53404:             pobj = pobj->getProto();
 53404:         } while (pobj);
 53404:         JS_ASSERT(ind == slength);
 53404:     }
 47525: 
 43190:     iterobj->setNativeIterator(ni);
 48470:     vp->setObject(*iterobj);
 43281: 
 43281:     RegisterEnumerator(cx, iterobj, ni);
 43190:     return true;
 43190: }
 43190: 
 55632: namespace js {
 55632: 
 43190: bool
 95355: VectorToKeyIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &props, Value *vp)
 48470: {
 53404:     return VectorToKeyIterator(cx, obj, flags, props, 0, 0, vp);
 48470: }
 48470: 
 53404: bool
 95355: VectorToValueIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &keys,
 53404:                       Value *vp)
 48470: {
 48470:     JS_ASSERT(flags & JSITER_FOREACH);
 48470: 
 77361:     if (obj) {
 83248:         if (obj->hasSingletonType() && !obj->setIteratedSingleton(cx))
 83248:             return false;
 77353:         types::MarkTypeObjectFlags(cx, obj, types::OBJECT_FLAG_ITERATED);
 77361:     }
 77343: 
105836:     Rooted<PropertyIteratorObject*> iterobj(cx, NewPropertyIteratorObject(cx, flags));
 48470:     if (!iterobj)
 48470:         return false;
 48470: 
 61055:     NativeIterator *ni = NativeIterator::allocateIterator(cx, 0, keys);
 48470:     if (!ni)
 53404:         return false;
 53404:     ni->init(obj, flags, 0, 0);
 48470: 
 48470:     iterobj->setNativeIterator(ni);
 48470:     vp->setObject(*iterobj);
 48470: 
 48470:     RegisterEnumerator(cx, iterobj, ni);
 48470:     return true;
 48470: }
 48470: 
 48470: bool
 95355: EnumeratedIdVectorToIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &props, Value *vp)
 48470: {
 48470:     if (!(flags & JSITER_FOREACH))
 48470:         return VectorToKeyIterator(cx, obj, flags, props, vp);
 48470: 
 61055:     return VectorToValueIterator(cx, obj, flags, props, vp);
 48470: }
 48470: 
 59250: static inline void
 59250: UpdateNativeIterator(NativeIterator *ni, JSObject *obj)
 59250: {
 59250:     // Update the object for which the native iterator is associated, so
 59250:     // SuppressDeletedPropertyHelper will recognize the iterator as a match.
 59250:     ni->obj = obj;
 59250: }
 59250: 
 48470: bool
 95355: GetIterator(JSContext *cx, HandleObject obj, unsigned flags, Value *vp)
 42641: {
105837:     if (flags == JSITER_FOR_OF) {
105837:         // for-of loop. The iterator is simply |obj.iterator()|.
105837:         Value method;
105837:         if (!obj->getProperty(cx, obj, cx->runtime->atomState.iteratorAtom, &method))
105837:             return false;
105837: 
105837:         // Throw if obj.iterator isn't callable. js::Invoke is about to check
105837:         // for this kind of error anyway, but it would throw an inscrutable
105837:         // error message about |method| rather than this nice one about |obj|.
105837:         if (!method.isObject() || !method.toObject().isCallable()) {
105837:             char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, ObjectOrNullValue(obj), NULL);
105837:             if (!bytes)
105837:                 return false;
105837:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_ITERABLE, bytes);
105837:             cx->free_(bytes);
105837:             return false;
105837:         }
105837: 
105837:         if (!Invoke(cx, ObjectOrNullValue(obj), method, 0, NULL, vp))
105837:             return false;
105838: 
105838:         if (!ToObject(cx, vp))
105838:             return false;
105837:         return true;
105837:     }
105837: 
103639:     Vector<Shape *, 8> shapes(cx);
 84755:     uint32_t key = 0;
 42641: 
 42641:     bool keysOnly = (flags == JSITER_ENUMERATE);
 42641: 
 42641:     if (obj) {
 80307:         if (JSIteratorOp op = obj->getClass()->ext.iteratorObject) {
105837:             JSObject *iterobj = op(cx, obj, !(flags & JSITER_FOREACH));
 56574:             if (!iterobj)
 56574:                 return false;
 56574:             vp->setObject(*iterobj);
 77399:             types::MarkIteratorUnknown(cx);
 56574:             return true;
 56574:         }
 56574: 
 42641:         if (keysOnly) {
     1:             /*
 53404:              * Check to see if this is the same as the most recent object which
 53404:              * was iterated over.  We don't explicitly check for shapeless
 53404:              * objects here, as they are not inserted into the cache and
 53404:              * will result in a miss.
 53404:              */
105836:             PropertyIteratorObject *last = cx->runtime->nativeIterCache.last;
 53404:             JSObject *proto = obj->getProto();
 53404:             if (last) {
 53404:                 NativeIterator *lastni = last->getNativeIterator();
 62573:                 if (!(lastni->flags & (JSITER_ACTIVE|JSITER_UNREUSABLE)) &&
 53531:                     obj->isNative() &&
 83221:                     obj->lastProperty() == lastni->shapes_array[0] &&
 53531:                     proto && proto->isNative() &&
 83221:                     proto->lastProperty() == lastni->shapes_array[1] &&
 53404:                     !proto->getProto()) {
 53404:                     vp->setObject(*last);
 59250:                     UpdateNativeIterator(lastni, obj);
 53404:                     RegisterEnumerator(cx, last, lastni);
 53404:                     return true;
 53404:                 }
 53404:             }
 53404: 
 53404:             /*
 42641:              * The iterator object for JSITER_ENUMERATE never escapes, so we
 42641:              * don't care for the proper parent/proto to be set. This also
 53404:              * allows us to re-use a previous iterator object that is not
 53404:              * currently active.
     1:              */
 42641:             JSObject *pobj = obj;
 42641:             do {
 42641:                 if (!pobj->isNative() ||
 83332:                     pobj->hasUncacheableProto() ||
 48622:                     obj->getOps()->enumerate ||
 42641:                     pobj->getClass()->enumerate != JS_EnumerateStub) {
 42641:                     shapes.clear();
 42641:                     goto miss;
     1:                 }
103639:                 Shape *shape = pobj->lastProperty();
 86976:                 key = (key + (key << 16)) ^ (uintptr_t(shape) >> 3);
 83221:                 if (!shapes.append((Shape *) shape))
 42641:                     return false;
 42641:                 pobj = pobj->getProto();
 42641:             } while (pobj);
 42641: 
105836:             PropertyIteratorObject *iterobj = cx->runtime->nativeIterCache.get(key);
 42641:             if (iterobj) {
 43190:                 NativeIterator *ni = iterobj->getNativeIterator();
 62573:                 if (!(ni->flags & (JSITER_ACTIVE|JSITER_UNREUSABLE)) &&
 53404:                     ni->shapes_key == key &&
 42641:                     ni->shapes_length == shapes.length() &&
 42641:                     Compare(ni->shapes_array, shapes.begin(), ni->shapes_length)) {
 48470:                     vp->setObject(*iterobj);
 43281: 
 59250:                     UpdateNativeIterator(ni, obj);
 43281:                     RegisterEnumerator(cx, iterobj, ni);
 53404:                     if (shapes.length() == 2)
 97466:                         cx->runtime->nativeIterCache.last = iterobj;
 42641:                     return true;
 42641:                 }
 42641:             }
 42641:         }
 42641: 
 42641:       miss:
 77399:         if (obj->isProxy()) {
 77399:             types::MarkIteratorUnknown(cx);
 79386:             return Proxy::iterate(cx, obj, flags, vp);
 77399:         }
 42641:         if (!GetCustomIterator(cx, obj, flags, vp))
 42641:             return false;
 77399:         if (!vp->isUndefined()) {
 77399:             types::MarkIteratorUnknown(cx);
 42641:             return true;
 42641:         }
 77399:     }
 42641: 
 48470:     /* NB: for (var p in null) succeeds by iterating over no properties. */
 48470: 
 61055:     AutoIdVector keys(cx);
 48470:     if (flags & JSITER_FOREACH) {
 61055:         if (JS_LIKELY(obj != NULL) && !Snapshot(cx, obj, flags, &keys))
 42641:             return false;
 53404:         JS_ASSERT(shapes.empty());
 61055:         if (!VectorToValueIterator(cx, obj, flags, keys, vp))
 53404:             return false;
 53404:     } else {
 61055:         if (JS_LIKELY(obj != NULL) && !Snapshot(cx, obj, flags, &keys))
 47459:             return false;
 53404:         if (!VectorToKeyIterator(cx, obj, flags, keys, shapes.length(), key, vp))
 53404:             return false;
 53404:     }
 53404: 
105836:     PropertyIteratorObject *iterobj = &vp->toObject().asPropertyIterator();
 53404: 
 53404:     /* Cache the iterator object if possible. */
 59954:     if (shapes.length())
 97466:         cx->runtime->nativeIterCache.set(key, iterobj);
 53404: 
 53404:     if (shapes.length() == 2)
 97466:         cx->runtime->nativeIterCache.last = iterobj;
 53404:     return true;
 42641: }
 42641: 
 55632: }
 55632: 
     1: static JSBool
 91237: Iterator(JSContext *cx, unsigned argc, Value *vp)
     1: {
 99943:     CallArgs args = CallArgsFromVp(argc, vp);
 99943:     if (args.length() == 0) {
 99943:         js_ReportMissingArg(cx, args.calleev(), 0);
 99943:         return false;
 99943:     }
 99943: 
 99943:     bool keyonly = false;
 99943:     if (args.length() >= 2)
 99943:         keyonly = js_ValueToBoolean(args[1]);
 91237:     unsigned flags = JSITER_OWNONLY | (keyonly ? 0 : (JSITER_FOREACH | JSITER_KEYVALUE));
 99943: 
 99943:     if (!ValueToIterator(cx, flags, &args[0]))
 99943:         return false;
 99943:     args.rval() = args[0];
 99943:     return true;
     1: }
     1: 
103624: JSBool
103624: js_ThrowStopIteration(JSContext *cx)
103624: {
103624:     JS_ASSERT(!JS_IsExceptionPending(cx));
103636:     RootedValue v(cx);
103990:     if (js_FindClassObject(cx, NullPtr(), JSProto_StopIteration, &v))
103624:         cx->setPendingException(v);
103624:     return JS_FALSE;
103624: }
103624: 
105479: static bool
105479: IsIterator(const Value &v)
     1: {
105836:     return v.isObject() && v.toObject().hasClass(&PropertyIteratorObject::class_);
105479: }
 79389: 
105479: static bool
105479: iterator_next_impl(JSContext *cx, CallArgs args)
105479: {
105479:     JS_ASSERT(IsIterator(args.thisv()));
105479: 
105479:     Rooted<JSObject*> thisObj(cx, &args.thisv().toObject());
     1: 
101161:     if (!js_IteratorMore(cx, thisObj, &args.rval()))
 42641:         return false;
 79389: 
 79387:     if (!args.rval().toBoolean()) {
  6464:         js_ThrowStopIteration(cx);
 42641:         return false;
     1:     }
 79389: 
101161:     return js_IteratorNext(cx, thisObj, &args.rval());
     1: }
     1: 
105479: static JSBool
105837: iterator_iterator(JSContext *cx, unsigned argc, Value *vp)
105837: {
105837:     CallArgs args = CallArgsFromVp(argc, vp);
105837:     args.rval() = args.thisv();
105837:     return true;
105837: }
105837: 
105837: static JSBool
105479: iterator_next(JSContext *cx, unsigned argc, Value *vp)
105479: {
105479:     CallArgs args = CallArgsFromVp(argc, vp);
105479:     return CallNonGenericMethod(cx, IsIterator, iterator_next_impl, args);
105479: }
105479: 
     1: static JSFunctionSpec iterator_methods[] = {
105837:     JS_FN("iterator",  iterator_iterator,   0, 0),
105837:     JS_FN("next",      iterator_next,       0, 0),
  4127:     JS_FS_END
     1: };
     1: 
105837: JSObject *
105837: iterator_iteratorObject(JSContext *cx, HandleObject obj, JSBool keysonly)
105837: {
105837:     return obj;
105837: }
105837: 
105836: void
105836: PropertyIteratorObject::trace(JSTracer *trc, JSObject *obj)
105836: {
105836:     if (NativeIterator *ni = obj->asPropertyIterator().getNativeIterator())
105836:         ni->mark(trc);
105836: }
105836: 
105836: void
105836: PropertyIteratorObject::finalize(FreeOp *fop, JSObject *obj)
105836: {
105836:     if (NativeIterator *ni = obj->asPropertyIterator().getNativeIterator()) {
105836:         obj->asPropertyIterator().setNativeIterator(NULL);
105836:         fop->free_(ni);
105836:     }
105836: }
105836: 
105836: Class PropertyIteratorObject::class_ = {
105836:     "Iterator",
105836:     JSCLASS_IMPLEMENTS_BARRIERS |
105836:     JSCLASS_HAS_CACHED_PROTO(JSProto_Iterator) |
105836:     JSCLASS_HAS_PRIVATE,
105836:     JS_PropertyStub,         /* addProperty */
105836:     JS_PropertyStub,         /* delProperty */
105836:     JS_PropertyStub,         /* getProperty */
105836:     JS_StrictPropertyStub,   /* setProperty */
105836:     JS_EnumerateStub,
105836:     JS_ResolveStub,
105836:     JS_ConvertStub,
105836:     finalize,
105836:     NULL,                    /* checkAccess */
105836:     NULL,                    /* call        */
105836:     NULL,                    /* construct   */
105836:     NULL,                    /* hasInstance */
105836:     trace,
105836:     {
105836:         NULL,                /* equality       */
105836:         NULL,                /* outerObject    */
105836:         NULL,                /* innerObject    */
105837:         iterator_iteratorObject,
105836:         NULL                 /* unused  */
105836:     }
105836: };
105836: 
 91160: #if JS_HAS_GENERATORS
 91160: static JSBool
 91160: CloseGenerator(JSContext *cx, JSObject *genobj);
 91160: #endif
 91160: 
105837: bool
 91947: js::ValueToIterator(JSContext *cx, unsigned flags, Value *vp)
     1: {
     1:     /* JSITER_KEYVALUE must always come with JSITER_FOREACH */
 42641:     JS_ASSERT_IF(flags & JSITER_KEYVALUE, flags & JSITER_FOREACH);
 42641: 
 42641:     /*
 42641:      * Make sure the more/next state machine doesn't get stuck. A value might be
 42641:      * left in iterValue when a trace is left due to an operation time-out after
 42641:      * JSOP_MOREITER but before the value is picked up by FOR*.
 42641:      */
 48470:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
     1: 
 99421:     RootedObject obj(cx);
 48470:     if (vp->isObject()) {
 40867:         /* Common case. */
 48470:         obj = &vp->toObject();
     1:     } else {
     1:         /*
     1:          * Enumerating over null and undefined gives an empty enumerator.
     1:          * This is contrary to ECMA-262 9.9 ToObject, invoked from step 3 of
     1:          * the first production in 12.6.4 and step 4 of the second production,
 40867:          * but it's "web JS" compatible. ES5 fixed for-in to match this de-facto
 40867:          * standard.
     1:          */
101314:         if (flags & JSITER_ENUMERATE) {
 95355:             if (!js_ValueToObjectOrNull(cx, *vp, obj.address()))
 40395:                 return false;
 56574:             /* fall through */
     1:         } else {
     1:             obj = js_ValueToNonNullObject(cx, *vp);
     1:             if (!obj)
 40395:                 return false;
     1:         }
     1:     }
     1: 
 42641:     return GetIterator(cx, obj, flags, vp);
  5899: }
     1: 
 91160: bool
 91947: js::CloseIterator(JSContext *cx, JSObject *obj)
  3025: {
 48470:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
  3025: 
105836:     if (obj->isPropertyIterator()) {
 43281:         /* Remove enumerators from the active list, which is a stack. */
105836:         NativeIterator *ni = obj->asPropertyIterator().getNativeIterator();
 53404: 
 62413:         if (ni->flags & JSITER_ENUMERATE) {
 43281:             JS_ASSERT(cx->enumerators == obj);
 43281:             cx->enumerators = ni->next;
 43281: 
 53404:             JS_ASSERT(ni->flags & JSITER_ACTIVE);
 53404:             ni->flags &= ~JSITER_ACTIVE;
 53404: 
 53519:             /*
 53519:              * Reset the enumerator; it may still be in the cached iterators
 53519:              * for this thread, and can be reused.
 53519:              */
 42641:             ni->props_cursor = ni->props_array;
 42641:         }
  3025:     }
  3025: #if JS_HAS_GENERATORS
 77817:     else if (obj->isGenerator()) {
 42641:         return CloseGenerator(cx, obj);
  3025:     }
  3025: #endif
  3025:     return JS_TRUE;
  3025: }
  3025: 
 91160: bool
 91947: js::UnwindIteratorForException(JSContext *cx, JSObject *obj)
 91160: {
 99421:     RootedValue v(cx, cx->getPendingException());
 91160:     cx->clearPendingException();
 91160:     if (!CloseIterator(cx, obj))
 91160:         return false;
 91160:     cx->setPendingException(v);
 91160:     return true;
 91160: }
 91160: 
 91947: void
 91947: js::UnwindIteratorForUncatchableException(JSContext *cx, JSObject *obj)
 91947: {
105836:     if (obj->isPropertyIterator()) {
105836:         NativeIterator *ni = obj->asPropertyIterator().getNativeIterator();
 91947:         if (ni->flags & JSITER_ENUMERATE) {
 91947:             JS_ASSERT(cx->enumerators == obj);
 91947:             cx->enumerators = ni->next;
 91947:         }
 91947:     }
 91947: }
 91160: 
 43281: /*
 55519:  * Suppress enumeration of deleted properties. This function must be called
 55519:  * when a property is deleted and there might be active enumerators.
 55519:  *
 55519:  * We maintain a list of active non-escaping for-in enumerators. To suppress
 55519:  * a property, we check whether each active enumerator contains the (obj, id)
 55519:  * pair and has not yet enumerated |id|. If so, and |id| is the next property,
 55519:  * we simply advance the cursor. Otherwise, we delete |id| from the list.
 43281:  *
 43281:  * We do not suppress enumeration of a property deleted along an object's
 43281:  * prototype chain. Only direct deletions on the object are handled.
 55519:  *
 55519:  * This function can suppress multiple properties at once. The |predicate|
 55519:  * argument is an object which can be called on an id and returns true or
 55519:  * false. It also must have a method |matchesAtMostOne| which allows us to
 55519:  * stop searching after the first deletion if true.
 43281:  */
 87655: template<typename StringPredicate>
 55519: static bool
 97353: SuppressDeletedPropertyHelper(JSContext *cx, HandleObject obj, StringPredicate predicate)
 43281: {
105836:     PropertyIteratorObject *iterobj = cx->enumerators;
 43281:     while (iterobj) {
 47383:       again:
 43281:         NativeIterator *ni = iterobj->getNativeIterator();
 48470:         /* This only works for identified surpressed keys, not values. */
 48470:         if (ni->isKeyIter() && ni->obj == obj && ni->props_cursor < ni->props_end) {
 43281:             /* Check whether id is still to come. */
 87655:             HeapPtr<JSFlatString> *props_cursor = ni->current();
 87655:             HeapPtr<JSFlatString> *props_end = ni->end();
 87655:             for (HeapPtr<JSFlatString> *idp = props_cursor; idp < props_end; ++idp) {
 55519:                 if (predicate(*idp)) {
 43281:                     /*
 43281:                      * Check whether another property along the prototype chain
 43281:                      * became visible as a result of this deletion.
 43281:                      */
 43281:                     if (obj->getProto()) {
 86437:                         JSObject *proto = obj->getProto();
103636:                         RootedObject obj2(cx);
103716:                         RootedShape prop(cx);
 99421:                         RootedId id(cx);
 98960:                         if (!ValueToId(cx, StringValue(*idp), id.address()))
 87655:                             return false;
 87655:                         if (!proto->lookupGeneric(cx, id, &obj2, &prop))
 43281:                             return false;
 43290:                         if (prop) {
 91237:                             unsigned attrs;
 86437:                             if (obj2->isNative())
103716:                                 attrs = prop->attributes();
 87655:                             else if (!obj2->getGenericAttributes(cx, id, &attrs))
 43281:                                 return false;
 56567: 
 43281:                             if (attrs & JSPROP_ENUMERATE)
 43281:                                 continue;
 43281:                         }
 43281:                     }
 43281: 
 43281:                     /*
 47383:                      * If lookupProperty or getAttributes above removed a property from
 47383:                      * ni, start over.
 47383:                      */
 47383:                     if (props_end != ni->props_end || props_cursor != ni->props_cursor)
 47383:                         goto again;
 47383: 
 47383:                     /*
 55519:                      * No property along the prototype chain stepped in to take the
 43281:                      * property's place, so go ahead and delete id from the list.
 43281:                      * If it is the next property to be enumerated, just skip it.
 43281:                      */
 47383:                     if (idp == props_cursor) {
 61055:                         ni->incCursor();
 43281:                     } else {
 87655:                         for (HeapPtr<JSFlatString> *p = idp; p + 1 != props_end; p++)
 82129:                             *p = *(p + 1);
 61055:                         ni->props_end = ni->end() - 1;
 89967: 
 89967:                         /*
 95221:                          * This invokes the pre barrier on this element, since
 95221:                          * it's no longer going to be marked, and ensures that
 95221:                          * any existing remembered set entry will be dropped.
 89967:                          */
 95221:                         *ni->props_end = NULL;
 43281:                     }
 62573: 
 62573:                     /* Don't reuse modified native iterators. */
 62573:                     ni->flags |= JSITER_UNREUSABLE;
 62573: 
 55519:                     if (predicate.matchesAtMostOne())
 43281:                         break;
 43281:                 }
 43281:             }
 43281:         }
 43281:         iterobj = ni->next;
 43281:     }
 43281:     return true;
 43281: }
 43281: 
 87655: class SingleStringPredicate {
 97353:     Handle<JSFlatString*> str;
 55519: public:
 97353:     SingleStringPredicate(JSContext *cx, Handle<JSFlatString*> str) : str(str) {}
 55519: 
 87655:     bool operator()(JSFlatString *str) { return EqualStrings(str, this->str); }
 55519:     bool matchesAtMostOne() { return true; }
 55519: };
 55519: 
 55519: bool
 97353: js_SuppressDeletedProperty(JSContext *cx, HandleObject obj, jsid id)
 55519: {
 99421:     Rooted<JSFlatString*> str(cx, IdToString(cx, id));
 87655:     if (!str)
 87655:         return false;
 97353:     return SuppressDeletedPropertyHelper(cx, obj, SingleStringPredicate(cx, str));
 55519: }
 55519: 
 78344: bool
 97353: js_SuppressDeletedElement(JSContext *cx, HandleObject obj, uint32_t index)
 78344: {
 78344:     jsid id;
 78344:     if (!IndexToId(cx, index, &id))
 78344:         return false;
 87655:     return js_SuppressDeletedProperty(cx, obj, id);
 78344: }
 78344: 
 55519: class IndexRangePredicate {
 84755:     uint32_t begin, end;
 79934: 
 55519:   public:
 84755:     IndexRangePredicate(uint32_t begin, uint32_t end) : begin(begin), end(end) {}
 55519: 
 87655:     bool operator()(JSFlatString *str) {
 84755:         uint32_t index;
 87655:         return str->isIndex(&index) && begin <= index && index < end;
 79934:     }
 79934: 
 55519:     bool matchesAtMostOne() { return false; }
 55519: };
 55519: 
 55519: bool
 97353: js_SuppressDeletedElements(JSContext *cx, HandleObject obj, uint32_t begin, uint32_t end)
 55519: {
 55519:     return SuppressDeletedPropertyHelper(cx, obj, IndexRangePredicate(begin, end));
 55519: }
 55519: 
103624: const uint32_t CLOSED_INDEX = UINT32_MAX;
103624: 
103624: JSObject *
103624: ElementIteratorObject::create(JSContext *cx, HandleObject obj)
103624: {
103624:     JS_ASSERT(obj);
103624:     JSObject *iterobj = NewObjectWithGivenProto(cx, &ElementIteratorClass, NULL, obj);
103624:     if (iterobj) {
103624:         iterobj->setReservedSlot(TargetSlot, ObjectValue(*obj));
103624:         iterobj->setReservedSlot(IndexSlot, Int32Value(0));
103624:     }
103624:     return iterobj;
103624: }
103624: 
103624: inline uint32_t
103624: ElementIteratorObject::getIndex() const
103624: {
103624:     return uint32_t(getReservedSlot(IndexSlot).toInt32());
103624: }
103624: 
103624: inline JSObject *
103624: ElementIteratorObject::getTargetObject() const
103624: {
103624:     return &getReservedSlot(TargetSlot).toObject();
103624: }
103624: 
103624: inline void
103624: ElementIteratorObject::setIndex(uint32_t index)
103624: {
103624:     setReservedSlot(IndexSlot, Int32Value(int32_t(index)));
103624: }
103624: 
103624: bool
103624: ElementIteratorObject::iteratorNext(JSContext *cx, Value *vp)
103624: {
103624:     Rooted<ElementIteratorObject*> self(cx, this);
103624: 
103624:     uint32_t i, length;
103624:     RootedObject obj(cx, getTargetObject());
103624:     if (!js_GetLengthProperty(cx, obj, &length))
103624:         goto error;
103624: 
103624:     i = self->getIndex();
103624:     if (i >= length) {
103624:         self->setIndex(CLOSED_INDEX);
103624:         vp->setMagic(JS_NO_ITER_VALUE);
103624:         return true;
103624:     }
103624: 
103624:     JS_ASSERT(i + 1 > i);
103624:     if (!obj->getElement(cx, obj, i, vp))
103624:         goto error;
103624: 
103624:     /* On success, bump the index. */
103624:     self->setIndex(i + 1);
103624:     return true;
103624: 
103624:   error:
103624:     self->setIndex(CLOSED_INDEX);
103624:     return false;
103624: }
103624: 
103624: inline js::ElementIteratorObject *
103624: JSObject::asElementIterator()
103624: {
103624:     JS_ASSERT(isElementIterator());
103624:     return static_cast<js::ElementIteratorObject *>(this);
103624: }
103624: 
 42641: JSBool
 95355: js_IteratorMore(JSContext *cx, HandleObject iterobj, Value *rval)
     1: {
 42641:     /* Fast path for native iterators */
 61055:     NativeIterator *ni = NULL;
105836:     if (iterobj->isPropertyIterator()) {
 61055:         /* Key iterators are handled by fast-paths. */
105836:         ni = iterobj->asPropertyIterator().getNativeIterator();
 61055:         bool more = ni->props_cursor < ni->props_end;
 61055:         if (ni->isKeyIter() || !more) {
 61055:             rval->setBoolean(more);
 42641:             return true;
     1:         }
 61055:     }
     1: 
 42641:     /* We might still have a pending value. */
 48470:     if (!cx->iterValue.isMagic(JS_NO_ITER_VALUE)) {
 48470:         rval->setBoolean(true);
 42641:         return true;
     1:     }
     1: 
 72108:     /* We're reentering below and can call anything. */
 72108:     JS_CHECK_RECURSION(cx, return false);
 72108: 
 42641:     /* Fetch and cache the next value from the iterator. */
 89622:     if (ni) {
 89622:         JS_ASSERT(!ni->isKeyIter());
 99421:         RootedId id(cx);
 98960:         if (!ValueToId(cx, StringValue(*ni->current()), id.address()))
 89622:             return false;
 89622:         ni->incCursor();
 89622:         if (!ni->obj->getGeneric(cx, id, rval))
 89622:             return false;
 89622:         if ((ni->flags & JSITER_KEYVALUE) && !NewKeyValuePair(cx, id, *rval, rval))
 89622:             return false;
103624:     } else if (iterobj->isElementIterator()) {
103624:         /*
103624:          * Like native iterators, element iterators do not have a .next
103624:          * method, so this fast path is necessary for correctness.
103624:          */
103624:         if (!iterobj->asElementIterator()->iteratorNext(cx, rval))
103624:             return false;
103624:         if (rval->isMagic(JS_NO_ITER_VALUE)) {
103624:             cx->iterValue.setMagic(JS_NO_ITER_VALUE);
103624:             rval->setBoolean(false);
103624:             return true;
103624:         }
103624:     } else if (iterobj->isProxy()) {
103624:         if (!Proxy::iteratorNext(cx, iterobj, rval))
103624:             return false;
103624:         if (rval->isMagic(JS_NO_ITER_VALUE)) {
103624:             rval->setBoolean(false);
103624:             return true;
103624:         }
 89622:     } else {
 89622:         /* Call the iterator object's .next method. */
 98960:         if (!GetMethod(cx, iterobj, cx->runtime->atomState.nextAtom, 0, rval))
 42641:             return false;
 76829:         if (!Invoke(cx, ObjectValue(*iterobj), *rval, 0, NULL, rval)) {
     1:             /* Check for StopIteration. */
 77817:             if (!cx->isExceptionPending() || !IsStopIteration(cx->getPendingException()))
 42641:                 return false;
     1: 
 60211:             cx->clearPendingException();
 48470:             cx->iterValue.setMagic(JS_NO_ITER_VALUE);
 48470:             rval->setBoolean(false);
 42641:             return true;
     1:         }
 61055:     }
     1: 
 42641:     /* Cache the value returned by iterobj.next() so js_IteratorNext() can find it. */
 48470:     JS_ASSERT(!rval->isMagic(JS_NO_ITER_VALUE));
 42641:     cx->iterValue = *rval;
 48470:     rval->setBoolean(true);
 42641:     return true;
 42641: }
 42641: 
 42641: JSBool
 48470: js_IteratorNext(JSContext *cx, JSObject *iterobj, Value *rval)
 42641: {
 42641:     /* Fast path for native iterators */
105836:     if (iterobj->isPropertyIterator()) {
 42641:         /*
 42641:          * Implement next directly as all the methods of the native iterator are
 42641:          * read-only and permanent.
 42641:          */
105836:         NativeIterator *ni = iterobj->asPropertyIterator().getNativeIterator();
 80307:         if (ni->isKeyIter()) {
 60785:             JS_ASSERT(ni->props_cursor < ni->props_end);
 87655:             *rval = StringValue(*ni->current());
 61055:             ni->incCursor();
 42641: 
 61055:             if (rval->isString())
 42641:                 return true;
 42641: 
 42641:             JSString *str;
 91450:             int i;
 78537:             if (rval->isInt32() && StaticStrings::hasInt(i = rval->toInt32())) {
 78537:                 str = cx->runtime->staticStrings.getInt(i);
 42641:             } else {
 84160:                 str = ToString(cx, *rval);
 42641:                 if (!str)
 42641:                     return false;
 42641:             }
 42641: 
 48470:             rval->setString(str);
 42641:             return true;
 42641:         }
 61055:     }
 42641: 
 48470:     JS_ASSERT(!cx->iterValue.isMagic(JS_NO_ITER_VALUE));
 42641:     *rval = cx->iterValue;
 48470:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
 42641: 
 42641:     return true;
     1: }
     1: 
     1: static JSBool
 98960: stopiter_hasInstance(JSContext *cx, HandleObject obj, const Value *v, JSBool *bp)
     1: {
 77817:     *bp = IsStopIteration(*v);
     1:     return JS_TRUE;
     1: }
     1: 
 77817: Class js::StopIterationClass = {
105837:     "StopIteration",
 56574:     JSCLASS_HAS_CACHED_PROTO(JSProto_StopIteration) |
 56576:     JSCLASS_FREEZE_PROTO,
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub,
 48622:     NULL,                    /* finalize    */
 48622:     NULL,                    /* checkAccess */
 48622:     NULL,                    /* call        */
 98058:     stopiter_hasInstance,
 98058:     NULL                     /* construct   */
     1: };
     1: 
     1: #if JS_HAS_GENERATORS
     1: 
     1: static void
 94738: generator_finalize(FreeOp *fop, JSObject *obj)
     1: {
 31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
 31452:     if (!gen)
 31452:         return;
     1: 
     1:     /*
 31452:      * gen is open when a script has not called its close method while
 31452:      * explicitly manipulating it.
     1:      */
 31452:     JS_ASSERT(gen->state == JSGEN_NEWBORN ||
 31452:               gen->state == JSGEN_CLOSED ||
     1:               gen->state == JSGEN_OPEN);
101075:     JS_POISON(gen->fp, JS_FREE_PATTERN, sizeof(StackFrame));
101075:     JS_POISON(gen, JS_FREE_PATTERN, sizeof(JSGenerator));
 94738:     fop->free_(gen);
     1: }
     1: 
   583: static void
101616: MarkGeneratorFrame(JSTracer *trc, JSGenerator *gen)
 82129: {
101075:     MarkValueRange(trc,
101075:                    HeapValueify(gen->fp->generatorArgsSnapshotBegin()),
101075:                    HeapValueify(gen->fp->generatorArgsSnapshotEnd()),
101075:                    "Generator Floating Args");
101075:     gen->fp->mark(trc);
101075:     MarkValueRange(trc,
101075:                    HeapValueify(gen->fp->generatorSlotsSnapshotBegin()),
101075:                    HeapValueify(gen->regs.sp),
101075:                    "Generator Floating Stack");
 82129: }
 82129: 
 82129: static void
 82129: GeneratorWriteBarrierPre(JSContext *cx, JSGenerator *gen)
 82129: {
 82129:     JSCompartment *comp = cx->compartment;
 82129:     if (comp->needsBarrier())
101616:         MarkGeneratorFrame(comp->barrierTracer(), gen);
101616: }
101616: 
101616: /*
101616:  * Only mark generator frames/slots when the generator is not active on the
101616:  * stack or closed. Barriers when copying onto the stack or closing preserve
101616:  * gc invariants.
101616:  */
102714: bool
102714: js::GeneratorHasMarkableFrame(JSGenerator *gen)
101616: {
101616:     return gen->state == JSGEN_NEWBORN || gen->state == JSGEN_OPEN;
101616: }
101616: 
101616: /*
101616:  * When a generator is closed, the GC things reachable from the contained frame
101616:  * and slots become unreachable and thus require a write barrier.
101616:  */
101616: static void
101616: SetGeneratorClosed(JSContext *cx, JSGenerator *gen)
101616: {
101616:     JS_ASSERT(gen->state != JSGEN_CLOSED);
101616:     if (GeneratorHasMarkableFrame(gen))
101616:         GeneratorWriteBarrierPre(cx, gen);
101616:     gen->state = JSGEN_CLOSED;
 82129: }
 82129: 
 82129: static void
   583: generator_trace(JSTracer *trc, JSObject *obj)
     1: {
 31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
  4282:     if (!gen)
  4282:         return;
  4282: 
101616:     if (GeneratorHasMarkableFrame(gen))
101616:         MarkGeneratorFrame(trc, gen);
     1: }
     1: 
 77817: Class js::GeneratorClass = {
 78098:     "Generator",
 90410:     JSCLASS_HAS_PRIVATE | JSCLASS_IMPLEMENTS_BARRIERS,
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub,
 48622:     generator_finalize,
 48622:     NULL,                    /* checkAccess */
 48622:     NULL,                    /* call        */
 48622:     NULL,                    /* construct   */
 48622:     NULL,                    /* hasInstance */
 64218:     generator_trace,
 48622:     {
 48622:         NULL,                /* equality       */
 48622:         NULL,                /* outerObject    */
 48622:         NULL,                /* innerObject    */
105837:         iterator_iteratorObject,
 56565:         NULL                 /* unused */
 48622:     }
     1: };
     1: 
     1: /*
     1:  * Called from the JSOP_GENERATOR case in the interpreter, with fp referring
     1:  * to the frame by which the generator function was activated.  Create a new
 69223:  * JSGenerator object, which contains its own StackFrame that we populate
     1:  * from *fp.  We know that upon return, the JSOP_GENERATOR opcode will return
     1:  * from the activation in fp, so we can steal away fp->callobj and fp->argsobj
     1:  * if they are non-null.
     1:  */
 86484: JSObject *
 37777: js_NewGenerator(JSContext *cx)
     1: {
 71695:     FrameRegs &stackRegs = cx->regs();
101075:     JS_ASSERT(stackRegs.stackDepth() == 0);
 71695:     StackFrame *stackfp = stackRegs.fp();
 53840: 
 99421:     Rooted<GlobalObject*> global(cx, &stackfp->global());
 78098:     JSObject *proto = global->getOrCreateGeneratorPrototype(cx);
 78098:     if (!proto)
 78098:         return NULL;
 83275:     JSObject *obj = NewObjectWithGivenProto(cx, &GeneratorClass, proto, global);
 78098:     if (!obj)
 78098:         return NULL;
 78098: 
     1:     /* Load and compute stack slot counts. */
101075:     Value *stackvp = stackfp->generatorArgsSnapshotBegin();
101075:     unsigned vplen = stackfp->generatorArgsSnapshotEnd() - stackvp;
     1: 
 42714:     /* Compute JSGenerator size. */
 91237:     unsigned nbytes = sizeof(JSGenerator) +
 48470:                    (-1 + /* one Value included in JSGenerator */
 42714:                     vplen +
 42714:                     VALUES_PER_STACK_FRAME +
101075:                     stackfp->script()->nslots) * sizeof(HeapValue);
 90005: 
 90005:     JS_ASSERT(nbytes % sizeof(Value) == 0);
 90005:     JS_STATIC_ASSERT(sizeof(StackFrame) % sizeof(HeapValue) == 0);
 42714: 
 64560:     JSGenerator *gen = (JSGenerator *) cx->malloc_(nbytes);
     1:     if (!gen)
 31452:         return NULL;
 90005:     SetValueRangeToUndefined((Value *)gen, nbytes / sizeof(Value));
     1: 
 42714:     /* Cut up floatingStack space. */
101075:     HeapValue *genvp = gen->stackSnapshot;
 69223:     StackFrame *genfp = reinterpret_cast<StackFrame *>(genvp + vplen);
 42714: 
 42714:     /* Initialize JSGenerator. */
 82129:     gen->obj.init(obj);
 42714:     gen->state = JSGEN_NEWBORN;
 43281:     gen->enumerators = NULL;
101075:     gen->fp = genfp;
101075:     gen->prevGenerator = NULL;
 42708: 
 71695:     /* Copy from the stack to the generator's floating frame. */
 71697:     gen->regs.rebaseFromTo(stackRegs, *genfp);
102714:     genfp->copyFrameAndValues<StackFrame::DoPostBarrier>(cx, (Value *)genvp, stackfp,
102714:                                                          stackvp, stackRegs.sp);
     1: 
 31452:     obj->setPrivate(gen);
     1:     return obj;
     1: }
     1: 
101616: static void
101616: SetGeneratorClosed(JSContext *cx, JSGenerator *gen);
101616: 
     1: typedef enum JSGeneratorOp {
     1:     JSGENOP_NEXT,
     1:     JSGENOP_SEND,
     1:     JSGENOP_THROW,
     1:     JSGENOP_CLOSE
     1: } JSGeneratorOp;
     1: 
     1: /*
     1:  * Start newborn or restart yielding generator and perform the requested
     1:  * operation inside its frame.
     1:  */
 86484: static JSBool
     1: SendToGenerator(JSContext *cx, JSGeneratorOp op, JSObject *obj,
 48470:                 JSGenerator *gen, const Value &arg)
     1: {
  3554:     if (gen->state == JSGEN_RUNNING || gen->state == JSGEN_CLOSING) {
101075:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NESTING_GENERATOR);
  3554:         return JS_FALSE;
  3554:     }
  3554: 
 82129:     /*
 82129:      * Write barrier is needed since the generator stack can be updated,
 82129:      * and it's not barriered in any other way. We need to do it before
 82129:      * gen->state changes, which can cause us to trace the generator
 82129:      * differently.
 82129:      *
 82129:      * We could optimize this by setting a bit on the generator to signify
 82129:      * that it has been marked. If this bit has already been set, there is no
 82129:      * need to mark again. The bit would have to be reset before the next GC,
 82129:      * or else some kind of epoch scheme would have to be used.
 82129:      */
 82129:     GeneratorWriteBarrierPre(cx, gen);
 82129: 
     1:     JS_ASSERT(gen->state == JSGEN_NEWBORN || gen->state == JSGEN_OPEN);
     1:     switch (op) {
     1:       case JSGENOP_NEXT:
     1:       case JSGENOP_SEND:
     1:         if (gen->state == JSGEN_OPEN) {
     1:             /*
     1:              * Store the argument to send as the result of the yield
     1:              * expression.
     1:              */
 53840:             gen->regs.sp[-1] = arg;
     1:         }
     1:         gen->state = JSGEN_RUNNING;
     1:         break;
     1: 
     1:       case JSGENOP_THROW:
 60211:         cx->setPendingException(arg);
     1:         gen->state = JSGEN_RUNNING;
     1:         break;
     1: 
     1:       default:
     1:         JS_ASSERT(op == JSGENOP_CLOSE);
 60211:         cx->setPendingException(MagicValue(JS_GENERATOR_CLOSING));
     1:         gen->state = JSGEN_CLOSING;
     1:         break;
     1:     }
     1: 
 42714:     JSBool ok;
 42714:     {
 71695:         GeneratorFrameGuard gfg;
 71695:         if (!cx->stack.pushGeneratorFrame(cx, gen, &gfg)) {
101616:             SetGeneratorClosed(cx, gen);
 42714:             return JS_FALSE;
 42714:         }
 42714: 
 71695:         StackFrame *fp = gfg.fp();
 71695:         gen->regs = cx->regs();
 42714: 
 53840:         cx->enterGenerator(gen);   /* OOM check above. */
105836:         PropertyIteratorObject *enumerators = cx->enumerators;
 43281:         cx->enumerators = gen->enumerators;
 43281: 
 71695:         ok = RunScript(cx, fp->script(), fp);
 42708: 
 43281:         gen->enumerators = cx->enumerators;
 43281:         cx->enumerators = enumerators;
 53840:         cx->leaveGenerator(gen);
 53840:     }
 42708: 
101075:     if (gen->fp->isYielding()) {
     1:         /* Yield cannot fail, throw or be called on closing. */
     1:         JS_ASSERT(ok);
 60211:         JS_ASSERT(!cx->isExceptionPending());
     1:         JS_ASSERT(gen->state == JSGEN_RUNNING);
     1:         JS_ASSERT(op != JSGENOP_CLOSE);
101075:         gen->fp->clearYielding();
     1:         gen->state = JSGEN_OPEN;
     1:         return JS_TRUE;
     1:     }
     1: 
101075:     gen->fp->clearReturnValue();
101616:     SetGeneratorClosed(cx, gen);
     1:     if (ok) {
     1:         /* Returned, explicitly or by falling off the end. */
     1:         if (op == JSGENOP_CLOSE)
     1:             return JS_TRUE;
  6464:         return js_ThrowStopIteration(cx);
     1:     }
     1: 
     1:     /*
  9780:      * An error, silent termination by operation callback or an exception.
     1:      * Propagate the condition to the caller.
     1:      */
     1:     return JS_FALSE;
     1: }
     1: 
 86484: static JSBool
  3436: CloseGenerator(JSContext *cx, JSObject *obj)
     1: {
 77817:     JS_ASSERT(obj->isGenerator());
  3025: 
 31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
  3025:     if (!gen) {
  3025:         /* Generator prototype object. */
  3025:         return JS_TRUE;
  3025:     }
  3025: 
  3025:     if (gen->state == JSGEN_CLOSED)
  3025:         return JS_TRUE;
  3025: 
 48470:     return SendToGenerator(cx, JSGENOP_CLOSE, obj, gen, UndefinedValue());
     1: }
     1: 
105479: static bool
105479: IsGenerator(const Value &v)
     1: {
105479:     return v.isObject() && v.toObject().hasClass(&GeneratorClass);
105479: }
 79389: 
105479: static bool
105479: generator_send_impl(JSContext *cx, CallArgs args)
105479: {
105479:     JS_ASSERT(IsGenerator(args.thisv()));
105479: 
105479:     Rooted<JSObject*> thisObj(cx, &args.thisv().toObject());
     1: 
101161:     JSGenerator *gen = (JSGenerator *) thisObj->getPrivate();
104199:     if (!gen || gen->state == JSGEN_CLOSED) {
     1:         /* This happens when obj is the generator prototype. See bug 352885. */
104199:         return js_ThrowStopIteration(cx);
     1:     }
     1: 
104199:     if (gen->state == JSGEN_NEWBORN && args.hasDefined(0)) {
     1:         js_ReportValueError(cx, JSMSG_BAD_GENERATOR_SEND,
 79387:                             JSDVG_SEARCH_STACK, args[0], NULL);
 79387:         return false;
     1:     }
     1: 
104199:     if (!SendToGenerator(cx, JSGENOP_SEND, thisObj, gen,
104199:                          args.length() > 0 ? args[0] : UndefinedValue()))
104199:     {
 79387:         return false;
     1:     }
     1: 
104199:     args.rval() = gen->fp->returnValue();
104199:     return true;
104199: 
104199: }
104199: 
104199: static JSBool
105479: generator_send(JSContext *cx, unsigned argc, Value *vp)
104199: {
104199:     CallArgs args = CallArgsFromVp(argc, vp);
105479:     return CallNonGenericMethod(cx, IsGenerator, generator_send_impl, args);
105479: }
104199: 
105479: static bool
105479: generator_next_impl(JSContext *cx, CallArgs args)
105479: {
105479:     JS_ASSERT(IsGenerator(args.thisv()));
105479: 
105479:     Rooted<JSObject*> thisObj(cx, &args.thisv().toObject());
104199: 
104199:     JSGenerator *gen = (JSGenerator *) thisObj->getPrivate();
104199:     if (!gen || gen->state == JSGEN_CLOSED) {
104199:         /* This happens when obj is the generator prototype. See bug 352885. */
104199:         return js_ThrowStopIteration(cx);
104199:     }
104199: 
104199:     if (!SendToGenerator(cx, JSGENOP_NEXT, thisObj, gen, UndefinedValue()))
 79387:         return false;
 64224: 
101075:     args.rval() = gen->fp->returnValue();
 79387:     return true;
     1: }
     1: 
     1: static JSBool
105479: generator_next(JSContext *cx, unsigned argc, Value *vp)
     1: {
104199:     CallArgs args = CallArgsFromVp(argc, vp);
105479:     return CallNonGenericMethod(cx, IsGenerator, generator_next_impl, args);
105479: }
104199: 
105479: static bool
105479: generator_throw_impl(JSContext *cx, CallArgs args)
105479: {
105479:     JS_ASSERT(IsGenerator(args.thisv()));
105479: 
105479:     Rooted<JSObject*> thisObj(cx, &args.thisv().toObject());
104199: 
104199:     JSGenerator *gen = (JSGenerator *) thisObj->getPrivate();
104199:     if (!gen || gen->state == JSGEN_CLOSED) {
104199:         /* This happens when obj is the generator prototype. See bug 352885. */
104199:         cx->setPendingException(args.length() >= 1 ? args[0] : UndefinedValue());
104199:         return false;
     1:     }
     1: 
104199:     if (!SendToGenerator(cx, JSGENOP_THROW, thisObj, gen,
104199:                          args.length() > 0 ? args[0] : UndefinedValue()))
     1:     {
104199:         return false;
     1:     }
     1: 
104199:     args.rval() = gen->fp->returnValue();
104199:     return true;
104199: 
     1: }
     1: 
     1: static JSBool
105479: generator_throw(JSContext *cx, unsigned argc, Value *vp)
     1: {
104199:     CallArgs args = CallArgsFromVp(argc, vp);
105479:     return CallNonGenericMethod(cx, IsGenerator, generator_throw_impl, args);
105479: }
104199: 
105479: static bool
105479: generator_close_impl(JSContext *cx, CallArgs args)
105479: {
105479:     JS_ASSERT(IsGenerator(args.thisv()));
105479: 
105479:     Rooted<JSObject*> thisObj(cx, &args.thisv().toObject());
104199: 
104199:     JSGenerator *gen = (JSGenerator *) thisObj->getPrivate();
104199:     if (!gen || gen->state == JSGEN_CLOSED) {
104199:         /* This happens when obj is the generator prototype. See bug 352885. */
104199:         args.rval().setUndefined();
104199:         return true;
104199:     }
104199: 
104199:     if (gen->state == JSGEN_NEWBORN) {
104199:         SetGeneratorClosed(cx, gen);
104199:         args.rval().setUndefined();
104199:         return true;
104199:     }
104199: 
104199:     if (!SendToGenerator(cx, JSGENOP_CLOSE, thisObj, gen, UndefinedValue()))
104199:         return false;
104199: 
104199:     args.rval() = gen->fp->returnValue();
104199:     return true;
     1: }
     1: 
105479: static JSBool
105479: generator_close(JSContext *cx, unsigned argc, Value *vp)
105479: {
105479:     CallArgs args = CallArgsFromVp(argc, vp);
105479:     return CallNonGenericMethod(cx, IsGenerator, generator_close_impl, args);
105479: }
105479: 
105837: #define JSPROP_ROPERM   (JSPROP_READONLY | JSPROP_PERMANENT)
105837: 
     1: static JSFunctionSpec generator_methods[] = {
105837:     JS_FN("iterator",  iterator_iterator,  0, 0),
105837:     JS_FN("next",      generator_next,     0,JSPROP_ROPERM),
105837:     JS_FN("send",      generator_send,     1,JSPROP_ROPERM),
105837:     JS_FN("throw",     generator_throw,    1,JSPROP_ROPERM),
105837:     JS_FN("close",     generator_close,    0,JSPROP_ROPERM),
  4127:     JS_FS_END
     1: };
     1: 
     1: #endif /* JS_HAS_GENERATORS */
     1: 
103624: static bool
103624: InitIteratorClass(JSContext *cx, Handle<GlobalObject*> global)
 75062: {
105836:     Rooted<JSObject*> iteratorProto(cx,
105836:         global->createBlankPrototype(cx, &PropertyIteratorObject::class_));
 75062:     if (!iteratorProto)
 75062:         return false;
 75062: 
 80307:     AutoIdVector blank(cx);
 80307:     NativeIterator *ni = NativeIterator::allocateIterator(cx, 0, blank);
 80307:     if (!ni)
 80307:         return false;
 80307:     ni->init(NULL, 0 /* flags */, 0, 0);
 80307: 
105836:     iteratorProto->asPropertyIterator().setNativeIterator(ni);
 80307: 
103990:     RootedFunction ctor(cx, global->createConstructor(cx, Iterator, CLASS_NAME(cx, Iterator), 2));
 75062:     if (!ctor)
 75062:         return false;
103624: 
 75062:     if (!LinkConstructorAndPrototype(cx, ctor, iteratorProto))
 75062:         return false;
103624: 
 75062:     if (!DefinePropertiesAndBrand(cx, iteratorProto, NULL, iterator_methods))
 75062:         return false;
103624: 
103624:     return DefineConstructorAndPrototype(cx, global, JSProto_Iterator, ctor, iteratorProto);
 75062: }
 75062: 
103624: /* static */ bool
103624: GlobalObject::initGeneratorClass(JSContext *cx, Handle<GlobalObject*> global)
103624: {
 75062: #if JS_HAS_GENERATORS
103624:     RootedObject proto(cx, global->createBlankPrototype(cx, &GeneratorClass));
 78098:     if (!proto || !DefinePropertiesAndBrand(cx, proto, NULL, generator_methods))
 75063:         return false;
 97353:     global->setReservedSlot(GENERATOR_PROTO, ObjectValue(*proto));
103624: #endif
103624:     return true;
103559: }
 75062: 
103624: static JSObject *
103624: InitStopIterationClass(JSContext *cx, Handle<GlobalObject*> global)
103624: {
103624:     RootedObject proto(cx, global->createBlankPrototype(cx, &StopIterationClass));
 75064:     if (!proto || !proto->freeze(cx))
103624:         return NULL;
 75064: 
 75064:     /* This should use a non-JSProtoKey'd slot, but this is easier for now. */
 75064:     if (!DefineConstructorAndPrototype(cx, global, JSProto_StopIteration, proto, proto))
103624:         return NULL;
 75064: 
 77817:     MarkStandardClassInitializedNoProto(global, &StopIterationClass);
 75064: 
103624:     return proto;
 75062: }
 75062: 
     1: JSObject *
     1: js_InitIteratorClasses(JSContext *cx, JSObject *obj)
     1: {
103624:     JS_ASSERT(obj->isNative());
103624: 
 99421:     Rooted<GlobalObject*> global(cx, &obj->asGlobal());
103624: 
103624:     /*
103624:      * Bail if Iterator has already been initialized.  We test for Iterator
103624:      * rather than for StopIteration because if js_InitIteratorClasses recurs,
103624:      * as happens when the StopIteration object is frozen, initializing the
103624:      * Iterator class a second time will assert.
103624:      */
103636:     RootedObject iter(cx);
103624:     if (!js_GetClassObject(cx, global, JSProto_Iterator, &iter))
     1:         return NULL;
103624:     if (iter)
103624:         return iter;
103624: 
103624:     if (!InitIteratorClass(cx, global) || !GlobalObject::initGeneratorClass(cx, global))
103624:         return NULL;
103624:     return InitStopIterationClass(cx, global);
     1: }
