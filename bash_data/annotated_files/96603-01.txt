    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:cindent:ts=2:et:sw=2:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Uri Bernstein <uriber@gmail.com>
    1:  *   Eli Friedman <sharparrow1@yahoo.com>
39425:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* base class of all rendering objects */
    1: 
86054: #include "mozilla/Attributes.h"
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nsCOMPtr.h"
    1: #include "nsFrame.h"
    1: #include "nsFrameList.h"
32107: #include "nsPlaceholderFrame.h"
    1: #include "nsLineLayout.h"
    1: #include "nsIContent.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIAtom.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsCRT.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIDOMEvent.h"
84833: #include "nsAsyncDOMEvent.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsIPresShell.h"
    1: #include "prlog.h"
    1: #include "prprf.h"
    1: #include <stdarg.h>
    1: #include "nsFrameManager.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsLayoutUtils.h"
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessible.h"
    1: #endif
    1: 
70982: #include "nsIDOMNode.h"
    1: #include "nsIEditorDocShell.h"
68780: #include "nsEventStateManager.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsFrameSelection.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsCSSFrameConstructor.h"
    1: 
    1: #include "nsFrameTraversal.h"
    1: #include "nsStyleChangeList.h"
    1: #include "nsIDOMRange.h"
85101: #include "nsRange.h"
23533: #include "nsITableLayout.h"    //selection necessity
    1: #include "nsITableCellLayout.h"//  "
    1: #include "nsITextControlFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIPercentHeightObserver.h"
23015: #include "nsStyleStructInlines.h"
    1: 
    1: #ifdef IBMBIDI
    1: #include "nsBidiPresUtils.h"
    1: #endif
    1: 
    1: // For triple-click pref
    1: #include "nsIServiceManager.h"
    1: #include "imgIContainer.h"
    1: #include "imgIRequest.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsLayoutErrors.h"
  549: #include "nsContentErrors.h"
86231: #include "nsContainerFrame.h"
    1: #include "nsBoxLayoutState.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsDisplayList.h"
35581: #include "nsIObjectLoadingContent.h"
47753: #include "nsExpirationTracker.h"
19125: #include "nsSVGIntegrationUtils.h"
19948: #include "nsSVGEffects.h"
72242: #include "nsChangeHint.h"
80910: #include "nsDeckFrame.h"
95533: #include "nsTableFrame.h"
19125: 
    1: #include "gfxContext.h"
93575: #include "nsRenderingContext.h"
51776: #include "CSSCalc.h"
79482: #include "nsAbsoluteContainingBlock.h"
95534: #include "nsFontInflationData.h"
 5235: 
70840: #include "mozilla/Preferences.h"
78130: #include "mozilla/LookAndFeel.h"
70840: 
39965: using namespace mozilla;
64542: using namespace mozilla::layers;
88122: using namespace mozilla::layout;
39965: 
    1: // Struct containing cached metrics for box-wrapped frames.
    1: struct nsBoxLayoutMetrics
    1: {
    1:   nsSize mPrefSize;
    1:   nsSize mMinSize;
    1:   nsSize mMaxSize;
    1: 
    1:   nsSize mBlockMinSize;
    1:   nsSize mBlockPrefSize;
    1:   nscoord mBlockAscent;
    1: 
    1:   nscoord mFlex;
    1:   nscoord mAscent;
    1: 
    1:   nsSize mLastSize;
    1: };
    1: 
    1: struct nsContentAndOffset
    1: {
    1:   nsIContent* mContent;
    1:   PRInt32 mOffset;
    1: };
    1: 
    1: // Some Misc #defines
    1: #define SELECTION_DEBUG        0
    1: #define FORCE_SELECTION_UPDATE 1
    1: #define CALC_DEBUG             0
    1: 
    1: 
    1: #include "nsILineIterator.h"
    1: 
    1: //non Hack prototypes
    1: #if 0
    1: static void RefreshContentFrames(nsPresContext* aPresContext, nsIContent * aStartContent, nsIContent * aEndContent);
    1: #endif
    1: 
    1: #include "prenv.h"
    1: 
31709: // Formerly the nsIFrameDebug interface
    1: 
    1: #ifdef NS_DEBUG
79445: static bool gShowFrameBorders = false;
79445: 
79445: void nsFrame::ShowFrameBorders(bool aEnable)
    1: {
    1:   gShowFrameBorders = aEnable;
    1: }
    1: 
79445: bool nsFrame::GetShowFrameBorders()
    1: {
    1:   return gShowFrameBorders;
    1: }
    1: 
79445: static bool gShowEventTargetFrameBorder = false;
79445: 
79445: void nsFrame::ShowEventTargetFrameBorder(bool aEnable)
    1: {
    1:   gShowEventTargetFrameBorder = aEnable;
    1: }
    1: 
79445: bool nsFrame::GetShowEventTargetFrameBorder()
    1: {
    1:   return gShowEventTargetFrameBorder;
    1: }
    1: 
    1: /**
    1:  * Note: the log module is created during library initialization which
    1:  * means that you cannot perform logging before then.
    1:  */
    1: static PRLogModuleInfo* gLogModule;
    1: 
    1: static PRLogModuleInfo* gStyleVerifyTreeLogModuleInfo;
    1: 
74671: static PRUint32 gStyleVerifyTreeEnable = 0x55;
    1: 
79445: bool
31709: nsFrame::GetVerifyStyleTreeEnable()
    1: {
74671:   if (gStyleVerifyTreeEnable == 0x55) {
    1:     if (nsnull == gStyleVerifyTreeLogModuleInfo) {
    1:       gStyleVerifyTreeLogModuleInfo = PR_NewLogModule("styleverifytree");
    1:       gStyleVerifyTreeEnable = 0 != gStyleVerifyTreeLogModuleInfo->level;
    1:     }
    1:   }
    1:   return gStyleVerifyTreeEnable;
    1: }
    1: 
    1: void
79445: nsFrame::SetVerifyStyleTreeEnable(bool aEnabled)
    1: {
    1:   gStyleVerifyTreeEnable = aEnabled;
    1: }
    1: 
    1: PRLogModuleInfo*
31709: nsFrame::GetLogModuleInfo()
    1: {
    1:   if (nsnull == gLogModule) {
    1:     gLogModule = PR_NewLogModule("frame");
    1:   }
    1:   return gLogModule;
    1: }
    1: 
    1: void
31709: nsFrame::DumpFrameTree(nsIFrame* aFrame)
    1: {
  238:     RootFrameList(aFrame->PresContext(), stdout, 0);
    1: }
    1: 
    1: void
31709: nsFrame::RootFrameList(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent)
31709: {
31709:   if (!aPresContext || !out)
    1:     return;
    1: 
    1:   nsIPresShell *shell = aPresContext->GetPresShell();
31709:   if (shell) {
    1:     nsIFrame* frame = shell->FrameManager()->GetRootFrame();
31709:     if(frame) {
31709:       frame->List(out, aIndent);
    1:     }
    1:   }
    1: }
    1: #endif
    1: 
79482: static void
79482: DestroyAbsoluteContainingBlock(void* aPropertyValue)
79482: {
79482:   delete static_cast<nsAbsoluteContainingBlock*>(aPropertyValue);
79482: }
79482: 
79482: NS_DECLARE_FRAME_PROPERTY(AbsoluteContainingBlockProperty, DestroyAbsoluteContainingBlock)
79482: 
79482: bool
79482: nsIFrame::HasAbsolutelyPositionedChildren() const {
79482:   return IsAbsoluteContainer() && GetAbsoluteContainingBlock()->HasAbsoluteFrames();
79482: }
79482: 
79482: nsAbsoluteContainingBlock*
79482: nsIFrame::GetAbsoluteContainingBlock() const {
79482:   NS_ASSERTION(IsAbsoluteContainer(), "The frame is not marked as an abspos container correctly");
79482:   nsAbsoluteContainingBlock* absCB = static_cast<nsAbsoluteContainingBlock*>
79482:     (Properties().Get(AbsoluteContainingBlockProperty()));
79482:   NS_ASSERTION(absCB, "The frame is marked as an abspos container but doesn't have the property");
79482:   return absCB;
79482: }
79482: 
79482: void
79482: nsIFrame::MarkAsAbsoluteContainingBlock() {
79482:   AddStateBits(NS_FRAME_HAS_ABSPOS_CHILDREN);
79482:   Properties().Set(AbsoluteContainingBlockProperty(), new nsAbsoluteContainingBlock(GetAbsoluteListID()));
79482: }
79482: 
80875: bool
80875: nsIFrame::CheckAndClearPaintedState()
80875: {
80875:   bool result = (GetStateBits() & NS_FRAME_PAINTED_THEBES);
80875:   RemoveStateBits(NS_FRAME_PAINTED_THEBES);
80875:   
80875:   nsIFrame::ChildListIterator lists(this);
80875:   for (; !lists.IsDone(); lists.Next()) {
80875:     nsFrameList::Enumerator childFrames(lists.CurrentList());
80875:     for (; !childFrames.AtEnd(); childFrames.Next()) {
80875:       nsIFrame* child = childFrames.get();
80875:       if (child->CheckAndClearPaintedState()) {
80875:         result = true;
80875:       }
80875:     }
80875:   }
80875:   return result;
80875: }
80875: 
80910: bool
80910: nsIFrame::IsVisibleConsideringAncestors(PRUint32 aFlags) const
80910: {
80910:   if (!GetStyleVisibility()->IsVisible()) {
80910:     return false;
80910:   }
80910: 
80910:   const nsIFrame* frame = this;
80910:   while (frame) {
80910:     nsIView* view = frame->GetView();
80910:     if (view && view->GetVisibility() == nsViewVisibility_kHide)
80910:       return false;
80910:     
80910:     nsIFrame* parent = frame->GetParent();
80910:     nsDeckFrame* deck = do_QueryFrame(parent);
80910:     if (deck) {
80910:       if (deck->GetSelectedBox() != frame)
80910:         return false;
80910:     }
80910: 
80910:     if (parent) {
80910:       frame = parent;
80910:     } else {
80910:       parent = nsLayoutUtils::GetCrossDocParentFrame(frame);
80910:       if (!parent)
80910:         break;
80910: 
80910:       if ((aFlags & nsIFrame::VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY) == 0 &&
80910:           parent->PresContext()->IsChrome() && !frame->PresContext()->IsChrome()) {
80910:         break;
80910:       }
80910: 
80910:       if (!parent->GetStyleVisibility()->IsVisible())
80910:         return false;
80910: 
80910:       frame = parent;
80910:     }
80910:   }
80910: 
80910:   return true;
80910: }
80910: 
79445: static bool ApplyOverflowClipping(nsDisplayListBuilder* aBuilder,
77286:                                     const nsIFrame* aFrame,
77286:                                     const nsStyleDisplay* aDisp, 
77286:                                     nsRect* aRect);
77286: 
91411: static bool ApplyClipPropClipping(nsDisplayListBuilder* aBuilder,
77286:                                   const nsStyleDisplay* aDisp, 
77286:                                   const nsIFrame* aFrame,
77286:                                   nsRect* aRect);
77286: 
    1: void
15183: NS_MergeReflowStatusInto(nsReflowStatus* aPrimary, nsReflowStatus aSecondary)
15183: {
15183:   *aPrimary |= aSecondary &
15183:     (NS_FRAME_NOT_COMPLETE | NS_FRAME_OVERFLOW_INCOMPLETE |
15183:      NS_FRAME_TRUNCATED | NS_FRAME_REFLOW_NEXTINFLOW);
15183:   if (*aPrimary & NS_FRAME_NOT_COMPLETE) {
15183:     *aPrimary &= ~NS_FRAME_OVERFLOW_INCOMPLETE;
15183:   }
15183: }
15183: 
15183: void
34904: nsWeakFrame::InitInternal(nsIFrame* aFrame)
    1: {
  238:   Clear(mFrame ? mFrame->PresContext()->GetPresShell() : nsnull);
    1:   mFrame = aFrame;
    1:   if (mFrame) {
  238:     nsIPresShell* shell = mFrame->PresContext()->GetPresShell();
    1:     NS_WARN_IF_FALSE(shell, "Null PresShell in nsWeakFrame!");
    1:     if (shell) {
    1:       shell->AddWeakFrame(this);
    1:     } else {
    1:       mFrame = nsnull;
    1:     }
    1:   }
    1: }
    1: 
    1: nsIFrame*
    1: NS_NewEmptyFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsFrame(aContext);
    1: }
    1: 
    1: nsFrame::nsFrame(nsStyleContext* aContext)
    1: {
    1:   MOZ_COUNT_CTOR(nsFrame);
    1: 
    1:   mState = NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY;
    1:   mStyleContext = aContext;
    1:   mStyleContext->AddRef();
    1: }
    1: 
    1: nsFrame::~nsFrame()
    1: {
    1:   MOZ_COUNT_DTOR(nsFrame);
    1: 
    1:   NS_IF_RELEASE(mContent);
    1:   if (mStyleContext)
    1:     mStyleContext->Release();
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsFrame)
32423: 
32423: // Dummy operator delete.  Will never be called, but must be defined
32423: // to satisfy some C++ ABIs.
32423: void
32423: nsFrame::operator delete(void *, size_t)
32423: {
32423:   NS_RUNTIMEABORT("nsFrame::operator delete should never be called");
32423: }
32423: 
23554: NS_QUERYFRAME_HEAD(nsFrame)
23554:   NS_QUERYFRAME_ENTRY(nsIFrame)
32423: NS_QUERYFRAME_TAIL_INHERITANCE_ROOT
    1: 
    1: /////////////////////////////////////////////////////////////////////////////
    1: // nsIFrame
    1: 
88118: static bool
88118: IsFontSizeInflationContainer(nsIFrame* aFrame,
88118:                              const nsStyleDisplay* aStyleDisplay)
88118: {
88118:   /*
88118:    * Font size inflation is built around the idea that we're inflating
88118:    * the fonts for a pan-and-zoom UI so that when the user scales up a
88118:    * block or other container to fill the width of the device, the fonts
88118:    * will be readable.  To do this, we need to pick what counts as a
88118:    * container.
88118:    *
88118:    * From a code perspective, the only hard requirement is that frames
88118:    * that are line participants
88118:    * (nsIFrame::IsFrameOfType(nsIFrame::eLineParticipant)) are never
88118:    * containers, since line layout assumes that the inflation is
88118:    * consistent within a line.
88118:    *
88118:    * This is not an imposition, since we obviously want a bunch of text
88118:    * (possibly with inline elements) flowing within a block to count the
88118:    * block (or higher) as its container.
88118:    *
88118:    * We also want form controls, including the text in the anonymous
88118:    * content inside of them, to match each other and the text next to
88118:    * them, so they and their anonymous content should also not be a
88118:    * container.
88118:    *
88118:    * However, because we can't reliably compute sizes across XUL during
88118:    * reflow, any XUL frame with a XUL parent is always a container.
88118:    *
88118:    * There are contexts where it would be nice if some blocks didn't
88118:    * count as a container, so that, for example, an indented quotation
88118:    * didn't end up with a smaller font size.  However, it's hard to
88118:    * distinguish these situations where we really do want the indented
88118:    * thing to count as a container, so we don't try, and blocks are
88118:    * always containers.
88118:    */
96450: 
96450:   // The root frame should always be an inflation container.
96450:   if (!aFrame->GetParent()) {
96450:     return true;
96450:   }
96450: 
88127:   nsIContent *content = aFrame->GetContent();
88118:   bool isInline = (aStyleDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE ||
88121:                    (aStyleDisplay->IsFloating() &&
88121:                     aFrame->GetType() == nsGkAtoms::letterFrame) ||
88127:                    // Given multiple frames for the same node, only the
88127:                    // outer one should be considered a container.
88127:                    // (Important, e.g., for nsSelectsAreaFrame.)
96450:                    (aFrame->GetParent()->GetContent() == content) ||
88127:                    (content && (content->IsHTML(nsGkAtoms::option) ||
88127:                                 content->IsHTML(nsGkAtoms::optgroup) ||
88127:                                 content->IsInNativeAnonymousSubtree()))) &&
96450:                   !(aFrame->IsBoxFrame() && aFrame->GetParent()->IsBoxFrame());
88118:   NS_ASSERTION(!aFrame->IsFrameOfType(nsIFrame::eLineParticipant) ||
88118:                isInline ||
88118:                // br frames and mathml frames report being line
88118:                // participants even when their position or display is
88118:                // set
88118:                aFrame->GetType() == nsGkAtoms::brFrame ||
88118:                aFrame->IsFrameOfType(nsIFrame::eMathML),
88118:                "line participants must not be containers");
88118:   NS_ASSERTION(aFrame->GetType() != nsGkAtoms::bulletFrame || isInline,
88118:                "bullets should not be containers");
88118:   return !isInline;
88118: }
88118: 
    1: NS_IMETHODIMP
    1: nsFrame::Init(nsIContent*      aContent,
    1:               nsIFrame*        aParent,
    1:               nsIFrame*        aPrevInFlow)
    1: {
 6219:   NS_PRECONDITION(!mContent, "Double-initing a frame?");
    1:   NS_ASSERTION(IsFrameOfType(eDEBUGAllFrames) &&
    1:                !IsFrameOfType(eDEBUGNoFrames),
    1:                "IsFrameOfType implementation that doesn't call base class");
    1: 
    1:   mContent = aContent;
    1:   mParent = aParent;
    1: 
    1:   if (aContent) {
    1:     NS_ADDREF(aContent);
    1:   }
    1: 
    1:   if (aPrevInFlow) {
    1:     // Make sure the general flags bits are the same
    1:     nsFrameState state = aPrevInFlow->GetStateBits();
    1: 
    1:     // Make bits that are currently off (see constructor) the same:
85101:     mState |= state & (NS_FRAME_INDEPENDENT_SELECTION |
19948:                        NS_FRAME_IS_SPECIAL |
50423:                        NS_FRAME_MAY_BE_TRANSFORMED);
    1:   }
    1:   if (mParent) {
    1:     nsFrameState state = mParent->GetStateBits();
    1: 
    1:     // Make bits that are currently off (see constructor) the same:
    1:     mState |= state & (NS_FRAME_INDEPENDENT_SELECTION |
    1:                        NS_FRAME_GENERATED_CONTENT);
    1:   }
88118:   const nsStyleDisplay *disp = GetStyleDisplay();
88118:   if (disp->HasTransform()) {
19214:     // The frame gets reconstructed if we toggle the -moz-transform
19214:     // property, so we can set this bit here and then ignore it.
50423:     mState |= NS_FRAME_MAY_BE_TRANSFORMED;
19214:   }
19214: 
96603:   if (nsLayoutUtils::FontSizeInflationEnabled(PresContext()) || !GetParent()
88118: #ifdef DEBUG
88118:       // We have assertions that check inflation invariants even when
88118:       // font size inflation is not enabled.
88118:       || true
88118: #endif
88118:       ) {
88118:     if (IsFontSizeInflationContainer(this, disp)) {
95533:       AddStateBits(NS_FRAME_FONT_INFLATION_CONTAINER);
95533:       if (!GetParent() ||
95533:           // I'd use NS_FRAME_OUT_OF_FLOW, but it's not set yet.
95533:           disp->IsFloating() || disp->IsAbsolutelyPositioned()) {
95533:         AddStateBits(NS_FRAME_FONT_INFLATION_FLOW_ROOT);
95533:       }
95533:     }
95533:     NS_ASSERTION(GetParent() ||
95533:                  (GetStateBits() & NS_FRAME_FONT_INFLATION_CONTAINER),
95533:                  "root frame should always be a container");
88118:   }
88118: 
20836:   DidSetStyleContext(nsnull);
    1: 
    1:   if (IsBoxWrapped())
80486:     InitBoxMetrics(false);
    1: 
    1:   return NS_OK;
    1: }
    1: 
77154: NS_IMETHODIMP nsFrame::SetInitialChildList(ChildListID     aListID,
30790:                                            nsFrameList&    aChildList)
    1: {
    1:   // XXX This shouldn't be getting called at all, but currently is for backwards
    1:   // compatility reasons...
    1: #if 0
    1:   NS_ERROR("not a container");
    1:   return NS_ERROR_UNEXPECTED;
    1: #else
30790:   NS_ASSERTION(aChildList.IsEmpty(), "not a container");
    1:   return NS_OK;
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsFrame::AppendFrames(ChildListID     aListID,
30941:                       nsFrameList&    aFrameList)
    1: {
80486:   NS_PRECONDITION(false, "not a container");
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsFrame::InsertFrames(ChildListID     aListID,
    1:                       nsIFrame*       aPrevFrame,
30941:                       nsFrameList&    aFrameList)
    1: {
80486:   NS_PRECONDITION(false, "not a container");
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: NS_IMETHODIMP
77154: nsFrame::RemoveFrame(ChildListID     aListID,
    1:                      nsIFrame*       aOldFrame)
    1: {
80486:   NS_PRECONDITION(false, "not a container");
    1:   return NS_ERROR_UNEXPECTED;
    1: }
    1: 
    1: void
36647: nsFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
28371:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
28371:     "destroy called on frame while scripts not blocked");
36646:   NS_ASSERTION(!GetNextSibling() && !GetPrevSibling(),
36646:                "Frames should be removed before destruction.");
36647:   NS_ASSERTION(aDestructRoot, "Must specify destruct root");
28371: 
19948:   nsSVGEffects::InvalidateDirectRenderingObservers(this);
19948: 
    1:   // Get the view pointer now before the frame properties disappear
    1:   // when we call NotifyDestroyingFrame()
    1:   nsIView* view = GetView();
  238:   nsPresContext* presContext = PresContext();
    1: 
    1:   nsIPresShell *shell = presContext->GetPresShell();
28300:   if (mState & NS_FRAME_OUT_OF_FLOW) {
28300:     nsPlaceholderFrame* placeholder =
28300:       shell->FrameManager()->GetPlaceholderFrameFor(this);
36647:     NS_ASSERTION(!placeholder || (aDestructRoot != this),
36647:                  "Don't call Destroy() on OOFs, call Destroy() on the placeholder.");
36647:     NS_ASSERTION(!placeholder ||
36647:                  nsLayoutUtils::IsProperAncestorFrame(aDestructRoot, placeholder),
36647:                  "Placeholder relationship should have been torn down already; "
36647:                  "this might mean we have a stray placeholder in the tree.");
28300:     if (placeholder) {
28300:       shell->FrameManager()->UnregisterPlaceholderFrame(placeholder);
28300:       placeholder->SetOutOfFlowFrame(nsnull);
28300:     }
28300:   }
    1: 
77680:   // If we have any IB split special siblings, clear their references to us.
77200:   // (Note: This has to happen before we call shell->NotifyDestroyingFrame,
77200:   // because that clears our Properties() table.)
77200:   if (mState & NS_FRAME_IS_SPECIAL) {
77680:     // Delete previous sibling's reference to me.
77680:     nsIFrame* prevSib = static_cast<nsIFrame*>
77680:       (Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
77680:     if (prevSib) {
77680:       NS_WARN_IF_FALSE(this ==
77680:          prevSib->Properties().Get(nsIFrame::IBSplitSpecialSibling()),
77680:          "IB sibling chain is inconsistent");
77680:       prevSib->Properties().Delete(nsIFrame::IBSplitSpecialSibling());
77680:     }
77680: 
77680:     // Delete next sibling's reference to me.
77200:     nsIFrame* nextSib = static_cast<nsIFrame*>
77200:       (Properties().Get(nsIFrame::IBSplitSpecialSibling()));
77200:     if (nextSib) {
77200:       NS_WARN_IF_FALSE(this ==
77200:          nextSib->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()),
77680:          "IB sibling chain is inconsistent");
77200:       nextSib->Properties().Delete(nsIFrame::IBSplitSpecialPrevSibling());
77200:     }
77200:   }
77200: 
    1:   shell->NotifyDestroyingFrame(this);
    1: 
85101:   if (mState & NS_FRAME_EXTERNAL_REFERENCE) {
    1:     shell->ClearFrameRefs(this);
    1:   }
    1: 
    1:   if (view) {
    1:     // Break association between view and frame
82566:     view->SetFrame(nsnull);
    1: 
    1:     // Destroy the view
    1:     view->Destroy();
    1:   }
    1: 
36653:   // Make sure that our deleted frame can't be returned from GetPrimaryFrame()
36653:   if (mContent && mContent->GetPrimaryFrame() == this) {
36653:     mContent->SetPrimaryFrame(nsnull);
36653:   }
36653: 
32511:   // Must retrieve the object ID before calling destructors, so the
32423:   // vtable is still valid.
32423:   //
32423:   // Note to future tweakers: having the method that returns the
32423:   // object size call the destructor will not avoid an indirect call;
32423:   // the compiler cannot devirtualize the call to the destructor even
32423:   // if it's from a method defined in the same class.
32423: 
32511:   nsQueryFrame::FrameIID id = GetFrameId();
32423:   this->~nsFrame();
32423: 
32423:   // Now that we're totally cleaned out, we need to add ourselves to
32423:   // the presshell's recycler.
32511:   shell->FreeFrame(id, this);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetOffsets(PRInt32 &aStart, PRInt32 &aEnd) const
    1: {
    1:   aStart = 0;
    1:   aEnd = 0;
    1:   return NS_OK;
    1: }
    1: 
79445: static bool
25231: EqualImages(imgIRequest *aOldImage, imgIRequest *aNewImage)
25231: {
25231:   if (aOldImage == aNewImage)
80486:     return true;
25231: 
25231:   if (!aOldImage || !aNewImage)
80486:     return false;
25231: 
25231:   nsCOMPtr<nsIURI> oldURI, newURI;
25231:   aOldImage->GetURI(getter_AddRefs(oldURI));
25231:   aNewImage->GetURI(getter_AddRefs(newURI));
79445:   bool equal;
25231:   return NS_SUCCEEDED(oldURI->Equals(newURI, &equal)) && equal;
25231: }
25231: 
    1: // Subclass hook for style post processing
20441: /* virtual */ void
20836: nsFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
20324: {
25231:   if (aOldStyleContext) {
25231:     // If the old context had a background image image and new context
25231:     // does not have the same image, clear the image load notifier
25231:     // (which keeps the image loading, if it still is) for the frame.
25231:     // We want to do this conservatively because some frames paint their
25231:     // backgrounds from some other frame's style data, and we don't want
25231:     // to clear those notifiers unless we have to.  (They'll be reset
25231:     // when we paint, although we could miss a notification in that
25231:     // interval.)
25276:     const nsStyleBackground *oldBG = aOldStyleContext->GetStyleBackground();
25276:     const nsStyleBackground *newBG = GetStyleBackground();
25276:     NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, oldBG) {
30993:       if (i >= newBG->mImageCount ||
30993:           oldBG->mLayers[i].mImage != newBG->mLayers[i].mImage) {
94919:         // stop the image loading for the frame, the image has changed
94919:         PresContext()->SetImageLoaders(this,
94919:           nsPresContext::BACKGROUND_IMAGE, nsnull);
94919:         break;
25276:       }
25231:     }
38828: 
38828:     // If we detect a change on margin, padding or border, we store the old
38828:     // values on the frame itself between now and reflow, so if someone
38828:     // calls GetUsed(Margin|Border|Padding)() before the next reflow, we
38828:     // can give an accurate answer.
38828:     // We don't want to set the property if one already exists.
39965:     FrameProperties props = Properties();
38828:     nsMargin oldValue(0, 0, 0, 0);
38828:     nsMargin newValue(0, 0, 0, 0);
38863:     const nsStyleMargin* oldMargin = aOldStyleContext->PeekStyleMargin();
38828:     if (oldMargin && oldMargin->GetMargin(oldValue)) {
38828:       if ((!GetStyleMargin()->GetMargin(newValue) || oldValue != newValue) &&
39965:           !props.Get(UsedMarginProperty())) {
39965:         props.Set(UsedMarginProperty(), new nsMargin(oldValue));
38828:       }
38828:     }
38828: 
38863:     const nsStylePadding* oldPadding = aOldStyleContext->PeekStylePadding();
38828:     if (oldPadding && oldPadding->GetPadding(oldValue)) {
38828:       if ((!GetStylePadding()->GetPadding(newValue) || oldValue != newValue) &&
39965:           !props.Get(UsedPaddingProperty())) {
39965:         props.Set(UsedPaddingProperty(), new nsMargin(oldValue));
38828:       }
38828:     }
38828: 
38863:     const nsStyleBorder* oldBorder = aOldStyleContext->PeekStyleBorder();
38828:     if (oldBorder) {
38828:       oldValue = oldBorder->GetActualBorder();
38828:       newValue = GetStyleBorder()->GetActualBorder();
38828:       if (oldValue != newValue &&
39965:           !props.Get(UsedBorderProperty())) {
39965:         props.Set(UsedBorderProperty(), new nsMargin(oldValue));
38828:       }
38828:     }
25231:   }
25231: 
25231:   imgIRequest *oldBorderImage = aOldStyleContext
25231:     ? aOldStyleContext->GetStyleBorder()->GetBorderImage()
25231:     : nsnull;
25231:   // For border-images, we can't be as conservative (we need to set the
25231:   // new loaders if there has been any change) since the CalcDifference
25231:   // call depended on the result of GetActualBorder() and that result
25231:   // depends on whether the image has loaded, start the image load now
25231:   // so that we'll get notified when it completes loading and can do a
25231:   // restyle.  Otherwise, the image might finish loading from the
25231:   // network before we start listening to its notifications, and then
25231:   // we'll never know that it's finished loading.  Likewise, we want to
25231:   // do this for freshly-created frames to prevent a similar race if the
25231:   // image loads between reflow (which can depend on whether the image
25231:   // is loaded) and paint.  We also don't really care about any callers
25231:   // who try to paint borders with a different style context, because
25231:   // they won't have the correct size for the border either.
94919:   if (!EqualImages(oldBorderImage, GetStyleBorder()->GetBorderImage())) {
25231:     // stop and restart the image loading/notification
94919:     PresContext()->SetupBorderImageLoaders(this, GetStyleBorder());
23015:   }
27659: 
27659:   // If the page contains markup that overrides text direction, and
27659:   // does not contain any characters that would activate the Unicode
27659:   // bidi algorithm, we need to call |SetBidiEnabled| on the pres
27659:   // context before reflow starts.  See bug 115921.
27659:   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL) {
27659:     PresContext()->SetBidiEnabled();
27659:   }
    1: }
    1: 
77152: // MSVC fails with link error "one or more multiply defined symbols found",
77152: // gcc fails with "hidden symbol `nsIFrame::kPrincipalList' isn't defined"
77152: // etc if they are not defined.
77152: #ifndef _MSC_VER
77152: // static nsIFrame constants; initialized in the header file.
77152: const nsIFrame::ChildListID nsIFrame::kPrincipalList;
77152: const nsIFrame::ChildListID nsIFrame::kAbsoluteList;
77152: const nsIFrame::ChildListID nsIFrame::kBulletList;
77152: const nsIFrame::ChildListID nsIFrame::kCaptionList;
77152: const nsIFrame::ChildListID nsIFrame::kColGroupList;
77152: const nsIFrame::ChildListID nsIFrame::kExcessOverflowContainersList;
77152: const nsIFrame::ChildListID nsIFrame::kFixedList;
77152: const nsIFrame::ChildListID nsIFrame::kFloatList;
77152: const nsIFrame::ChildListID nsIFrame::kOverflowContainersList;
77152: const nsIFrame::ChildListID nsIFrame::kOverflowList;
77152: const nsIFrame::ChildListID nsIFrame::kOverflowOutOfFlowList;
77152: const nsIFrame::ChildListID nsIFrame::kPopupList;
77152: const nsIFrame::ChildListID nsIFrame::kPushedFloatsList;
77152: const nsIFrame::ChildListID nsIFrame::kSelectPopupList;
77152: const nsIFrame::ChildListID nsIFrame::kNoReflowPrincipalList;
77152: #endif
77152: 
    1: /* virtual */ nsMargin
    1: nsIFrame::GetUsedMargin() const
    1: {
    1:   nsMargin margin(0, 0, 0, 0);
38828:   if ((mState & NS_FRAME_FIRST_REFLOW) &&
38828:       !(mState & NS_FRAME_IN_REFLOW))
38828:     return margin;
38828: 
 3233:   nsMargin *m = static_cast<nsMargin*>
39965:                            (Properties().Get(UsedMarginProperty()));
    1:   if (m) {
    1:     margin = *m;
38828:   } else {
38828: #ifdef DEBUG
79445:     bool hasMargin = 
38828: #endif
38828:     GetStyleMargin()->GetMargin(margin);
38828:     NS_ASSERTION(hasMargin, "We should have a margin here! (out of memory?)");
    1:   }
    1:   return margin;
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsIFrame::GetUsedBorder() const
    1: {
38828:   nsMargin border(0, 0, 0, 0);
38828:   if ((mState & NS_FRAME_FIRST_REFLOW) &&
38828:       !(mState & NS_FRAME_IN_REFLOW))
38828:     return border;
    1: 
    1:   // Theme methods don't use const-ness.
 3233:   nsIFrame *mutable_this = const_cast<nsIFrame*>(this);
    1: 
    1:   const nsStyleDisplay *disp = GetStyleDisplay();
    1:   if (mutable_this->IsThemed(disp)) {
23738:     nsIntMargin result;
  238:     nsPresContext *presContext = PresContext();
    1:     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
    1:                                              mutable_this, disp->mAppearance,
    1:                                              &result);
38828:     border.left = presContext->DevPixelsToAppUnits(result.left);
38828:     border.top = presContext->DevPixelsToAppUnits(result.top);
38828:     border.right = presContext->DevPixelsToAppUnits(result.right);
38828:     border.bottom = presContext->DevPixelsToAppUnits(result.bottom);
38828:     return border;
38828:   }
38828: 
38828:   nsMargin *b = static_cast<nsMargin*>
39965:                            (Properties().Get(UsedBorderProperty()));
38828:   if (b) {
38828:     border = *b;
38828:   } else {
38828:     border = GetStyleBorder()->GetActualBorder();
38828:   }
38828:   return border;
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsIFrame::GetUsedPadding() const
    1: {
    1:   nsMargin padding(0, 0, 0, 0);
38828:   if ((mState & NS_FRAME_FIRST_REFLOW) &&
38828:       !(mState & NS_FRAME_IN_REFLOW))
38828:     return padding;
    1: 
    1:   // Theme methods don't use const-ness.
 3233:   nsIFrame *mutable_this = const_cast<nsIFrame*>(this);
    1: 
    1:   const nsStyleDisplay *disp = GetStyleDisplay();
    1:   if (mutable_this->IsThemed(disp)) {
  238:     nsPresContext *presContext = PresContext();
23738:     nsIntMargin widget;
    1:     if (presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
    1:                                                   mutable_this,
    1:                                                   disp->mAppearance,
23738:                                                   &widget)) {
23738:       padding.top = presContext->DevPixelsToAppUnits(widget.top);
23738:       padding.right = presContext->DevPixelsToAppUnits(widget.right);
23738:       padding.bottom = presContext->DevPixelsToAppUnits(widget.bottom);
23738:       padding.left = presContext->DevPixelsToAppUnits(widget.left);
    1:       return padding;
    1:     }
    1:   }
38828: 
 3233:   nsMargin *p = static_cast<nsMargin*>
39965:                            (Properties().Get(UsedPaddingProperty()));
    1:   if (p) {
    1:     padding = *p;
38828:   } else {
38828: #ifdef DEBUG
79445:     bool hasPadding = 
38828: #endif
38828:     GetStylePadding()->GetPadding(padding);
38828:     NS_ASSERTION(hasPadding, "We should have padding here! (out of memory?)");
    1:   }
    1:   return padding;
    1: }
    1: 
    1: void
    1: nsIFrame::ApplySkipSides(nsMargin& aMargin) const
    1: {
    1:   PRIntn skipSides = GetSkipSides();
    1:   if (skipSides & (1 << NS_SIDE_TOP))
    1:     aMargin.top = 0;
    1:   if (skipSides & (1 << NS_SIDE_RIGHT))
    1:     aMargin.right = 0;
    1:   if (skipSides & (1 << NS_SIDE_BOTTOM))
    1:     aMargin.bottom = 0;
    1:   if (skipSides & (1 << NS_SIDE_LEFT))
    1:     aMargin.left = 0;
    1: }
    1: 
    1: nsRect
68635: nsIFrame::GetPaddingRectRelativeToSelf() const
68635: {
68635:   nsMargin bp(GetUsedBorder());
68635:   ApplySkipSides(bp);
68635:   nsRect r(0, 0, mRect.width, mRect.height);
68635:   r.Deflate(bp);
68635:   return r;
68635: }
68635: 
68635: nsRect
    1: nsIFrame::GetPaddingRect() const
    1: {
68635:   return GetPaddingRectRelativeToSelf() + GetPosition();
    1: }
    1: 
79445: bool
19214: nsIFrame::IsTransformed() const
19214: {
50423:   return (mState & NS_FRAME_MAY_BE_TRANSFORMED) &&
19214:     GetStyleDisplay()->HasTransform();
19214: }
19214: 
79445: bool
77286: nsIFrame::Preserves3DChildren() const
77286: {
77850:   if (GetStyleDisplay()->mTransformStyle != NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D || !IsTransformed())
80486:       return false;
77850: 
77850:   // If we're all scroll frame, then all descendants will be clipped, so we can't preserve 3d.
77850:   if (GetType() == nsGkAtoms::scrollFrame)
80486:       return false;
77286: 
77286:   nsRect temp;
77286:   return (!ApplyOverflowClipping(nsnull, this, GetStyleDisplay(), &temp) &&
91411:       !ApplyClipPropClipping(nsnull, GetStyleDisplay(), this, &temp) &&
77286:       !nsSVGIntegrationUtils::UsingEffectsForFrame(this));
77286: }
77286: 
79445: bool
77850: nsIFrame::Preserves3D() const
77850: {
77850:   if (!GetParent() || !GetParent()->Preserves3DChildren() || !IsTransformed()) {
80486:     return false;
80486:   }
80486:   return true;
77850: }
77850: 
90156: bool
90156: nsIFrame::HasPerspective() const
90156: {
90156:   if (!IsTransformed()) {
90156:     return false;
90156:   }
90156:   const nsStyleDisplay* parentDisp = nsnull;
90156:   nsStyleContext* parentStyleContext = GetStyleContext()->GetParent();
90156:   if (parentStyleContext) {
90156:     parentDisp = parentStyleContext->GetStyleDisplay();
90156:   }
90156: 
90156:   if (parentDisp &&
90156:       parentDisp->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
90156:       parentDisp->mChildPerspective.GetCoordValue() > 0.0) {
90156:     return true;
90156:   }
90156:   return false;
90156: }
90156: 
92049: bool
92049: nsIFrame::ChildrenHavePerspective() const
92049: {
92049:   const nsStyleDisplay *disp = GetStyleContext()->GetStyleDisplay();
92049:   if (disp &&
92049:       disp->mChildPerspective.GetUnit() == eStyleUnit_Coord &&
92049:       disp->mChildPerspective.GetCoordValue() > 0.0) {
92049:     return true;
92049:   }
92049:   return false;
92049: }
92049: 
    1: nsRect
68635: nsIFrame::GetContentRectRelativeToSelf() const
    1: {
    1:   nsMargin bp(GetUsedBorderAndPadding());
    1:   ApplySkipSides(bp);
68635:   nsRect r(0, 0, mRect.width, mRect.height);
    1:   r.Deflate(bp);
    1:   return r;
    1: }
    1: 
68635: nsRect
68635: nsIFrame::GetContentRect() const
68635: {
68635:   return GetContentRectRelativeToSelf() + GetPosition();
68635: }
68635: 
79445: bool
52126: nsIFrame::ComputeBorderRadii(const nsStyleCorners& aBorderRadius,
52127:                              const nsSize& aFrameSize,
52130:                              const nsSize& aBorderArea,
52128:                              PRIntn aSkipSides,
52126:                              nscoord aRadii[8])
52126: {
52126:   // Percentages are relative to whichever side they're on.
52126:   NS_FOR_CSS_HALF_CORNERS(i) {
52126:     const nsStyleCoord c = aBorderRadius.Get(i);
52127:     nscoord axis =
52127:       NS_HALF_CORNER_IS_X(i) ? aFrameSize.width : aFrameSize.height;
52126: 
52281:     if (c.IsCoordPercentCalcUnit()) {
52281:       aRadii[i] = nsRuleNode::ComputeCoordPercentCalc(c, axis);
52281:       if (aRadii[i] < 0) {
52281:         // clamp calc()
52281:         aRadii[i] = 0;
52281:       }
52281:     } else {
52126:       NS_NOTREACHED("ComputeBorderRadii: bad unit");
52126:       aRadii[i] = 0;
52126:     }
52128:   }
52128: 
52128:   if (aSkipSides & (1 << NS_SIDE_TOP)) {
52128:     aRadii[NS_CORNER_TOP_LEFT_X] = 0;
52128:     aRadii[NS_CORNER_TOP_LEFT_Y] = 0;
52128:     aRadii[NS_CORNER_TOP_RIGHT_X] = 0;
52128:     aRadii[NS_CORNER_TOP_RIGHT_Y] = 0;
52128:   }
52128: 
52128:   if (aSkipSides & (1 << NS_SIDE_RIGHT)) {
52128:     aRadii[NS_CORNER_TOP_RIGHT_X] = 0;
52128:     aRadii[NS_CORNER_TOP_RIGHT_Y] = 0;
52128:     aRadii[NS_CORNER_BOTTOM_RIGHT_X] = 0;
52128:     aRadii[NS_CORNER_BOTTOM_RIGHT_Y] = 0;
52128:   }
52128: 
52128:   if (aSkipSides & (1 << NS_SIDE_BOTTOM)) {
52128:     aRadii[NS_CORNER_BOTTOM_RIGHT_X] = 0;
52128:     aRadii[NS_CORNER_BOTTOM_RIGHT_Y] = 0;
52128:     aRadii[NS_CORNER_BOTTOM_LEFT_X] = 0;
52128:     aRadii[NS_CORNER_BOTTOM_LEFT_Y] = 0;
52128:   }
52128: 
52128:   if (aSkipSides & (1 << NS_SIDE_LEFT)) {
52128:     aRadii[NS_CORNER_BOTTOM_LEFT_X] = 0;
52128:     aRadii[NS_CORNER_BOTTOM_LEFT_Y] = 0;
52128:     aRadii[NS_CORNER_TOP_LEFT_X] = 0;
52128:     aRadii[NS_CORNER_TOP_LEFT_Y] = 0;
52128:   }
52128: 
52130:   // css3-background specifies this algorithm for reducing
52130:   // corner radii when they are too big.
79445:   bool haveRadius = false;
52130:   double ratio = 1.0f;
52130:   NS_FOR_CSS_SIDES(side) {
80486:     PRUint32 hc1 = NS_SIDE_TO_HALF_CORNER(side, false, true);
80486:     PRUint32 hc2 = NS_SIDE_TO_HALF_CORNER(side, true, true);
52130:     nscoord length =
52130:       NS_SIDE_IS_VERTICAL(side) ? aBorderArea.height : aBorderArea.width;
52130:     nscoord sum = aRadii[hc1] + aRadii[hc2];
52130:     if (sum)
80486:       haveRadius = true;
52130: 
52130:     // avoid floating point division in the normal case
52130:     if (length < sum)
52130:       ratio = NS_MIN(ratio, double(length)/sum);
52130:   }
52130:   if (ratio < 1.0) {
52130:     NS_FOR_CSS_HALF_CORNERS(corner) {
52130:       aRadii[corner] *= ratio;
52130:     }
52130:   }
52130: 
52130:   return haveRadius;
52126: }
52126: 
52131: /* static */ void
52131: nsIFrame::InsetBorderRadii(nscoord aRadii[8], const nsMargin &aOffsets)
52131: {
52131:   NS_FOR_CSS_SIDES(side) {
68637:     nscoord offset = aOffsets.Side(side);
80486:     PRUint32 hc1 = NS_SIDE_TO_HALF_CORNER(side, false, false);
80486:     PRUint32 hc2 = NS_SIDE_TO_HALF_CORNER(side, true, false);
52131:     aRadii[hc1] = NS_MAX(0, aRadii[hc1] - offset);
52131:     aRadii[hc2] = NS_MAX(0, aRadii[hc2] - offset);
52131:   }
52131: }
52131: 
52131: /* static */ void
52131: nsIFrame::OutsetBorderRadii(nscoord aRadii[8], const nsMargin &aOffsets)
52131: {
52131:   NS_FOR_CSS_SIDES(side) {
68637:     nscoord offset = aOffsets.Side(side);
80486:     PRUint32 hc1 = NS_SIDE_TO_HALF_CORNER(side, false, false);
80486:     PRUint32 hc2 = NS_SIDE_TO_HALF_CORNER(side, true, false);
52131:     if (aRadii[hc1] > 0)
52131:       aRadii[hc1] += offset;
52131:     if (aRadii[hc2] > 0)
52131:       aRadii[hc2] += offset;
52131:   }
52131: }
52131: 
79445: /* virtual */ bool
52131: nsIFrame::GetBorderRadii(nscoord aRadii[8]) const
52131: {
55048:   if (IsThemed()) {
55048:     // When we're themed, the native theme code draws the border and
55048:     // background, and therefore it doesn't make sense to tell other
55048:     // code that's interested in border-radius that we have any radii.
55048:     //
55048:     // In an ideal world, we might have a way for the them to tell us an
55048:     // border radius, but since we don't, we're better off assuming
55048:     // zero.
55048:     NS_FOR_CSS_HALF_CORNERS(corner) {
55048:       aRadii[corner] = 0;
55048:     }
80486:     return false;
55048:   }
52131:   nsSize size = GetSize();
52131:   return ComputeBorderRadii(GetStyleBorder()->mBorderRadius, size, size,
52131:                             GetSkipSides(), aRadii);
52131: }
52131: 
79445: bool
52131: nsIFrame::GetPaddingBoxBorderRadii(nscoord aRadii[8]) const
52131: {
52131:   if (!GetBorderRadii(aRadii))
80486:     return false;
52131:   InsetBorderRadii(aRadii, GetUsedBorder());
52131:   NS_FOR_CSS_HALF_CORNERS(corner) {
52131:     if (aRadii[corner])
80486:       return true;
80486:   }
80486:   return false;
52131: }
52131: 
79445: bool
52131: nsIFrame::GetContentBoxBorderRadii(nscoord aRadii[8]) const
52131: {
52131:   if (!GetBorderRadii(aRadii))
80486:     return false;
52131:   InsetBorderRadii(aRadii, GetUsedBorderAndPadding());
52131:   NS_FOR_CSS_HALF_CORNERS(corner) {
52131:     if (aRadii[corner])
80486:       return true;
80486:   }
80486:   return false;
52131: }
52131: 
    1: nsStyleContext*
    1: nsFrame::GetAdditionalStyleContext(PRInt32 aIndex) const
    1: {
    1:   NS_PRECONDITION(aIndex >= 0, "invalid index number");
    1:   return nsnull;
    1: }
    1: 
    1: void
    1: nsFrame::SetAdditionalStyleContext(PRInt32 aIndex, 
    1:                                    nsStyleContext* aStyleContext)
    1: {
    1:   NS_PRECONDITION(aIndex >= 0, "invalid index number");
    1: }
    1: 
    1: nscoord
    1: nsFrame::GetBaseline() const
    1: {
 1158:   NS_ASSERTION(!NS_SUBTREE_DIRTY(this),
    1:                "frame must not be dirty");
    1:   // Default to the bottom margin edge, per CSS2.1's definition of the
    1:   // 'baseline' value of 'vertical-align'.
    1:   return mRect.height + GetUsedMargin().bottom;
    1: }
    1: 
91756: const nsFrameList&
79483: nsFrame::GetChildList(ChildListID aListID) const
79483: {
79483:   if (IsAbsoluteContainer() &&
79483:       aListID == GetAbsoluteListID()) {
79483:     return GetAbsoluteContainingBlock()->GetChildList();
79483:   } else {
79483:     return nsFrameList::EmptyList();
79483:   }
79483: }
79483: 
79483: void
79483: nsFrame::GetChildLists(nsTArray<ChildList>* aLists) const
79483: {
79483:   if (IsAbsoluteContainer()) {
79483:     nsFrameList absoluteList = GetAbsoluteContainingBlock()->GetChildList();
79483:     absoluteList.AppendIfNonempty(aLists, GetAbsoluteListID());
79483:   }
79483: }
79483: 
74711: static nsIFrame*
74711: GetActiveSelectionFrame(nsPresContext* aPresContext, nsIFrame* aFrame)
74711: {
74711:   nsIContent* capturingContent = nsIPresShell::GetCapturingContent();
74711:   if (capturingContent) {
74711:     nsIFrame* activeFrame = aPresContext->GetPrimaryFrameFor(capturingContent);
74711:     return activeFrame ? activeFrame : aFrame;
74711:   }
74711: 
74711:   return aFrame;
74711: }
74711: 
    1: PRInt16
79445: nsFrame::DisplaySelection(nsPresContext* aPresContext, bool isOkToTurnOn)
    1: {
    1:   PRInt16 selType = nsISelectionController::SELECTION_OFF;
    1: 
    1:   nsCOMPtr<nsISelectionController> selCon;
    1:   nsresult result = GetSelectionController(aPresContext, getter_AddRefs(selCon));
    1:   if (NS_SUCCEEDED(result) && selCon) {
    1:     result = selCon->GetDisplaySelection(&selType);
    1:     if (NS_SUCCEEDED(result) && (selType != nsISelectionController::SELECTION_OFF)) {
    1:       // Check whether style allows selection.
79445:       bool selectable;
    1:       IsSelectable(&selectable, nsnull);
    1:       if (!selectable) {
    1:         selType = nsISelectionController::SELECTION_OFF;
80486:         isOkToTurnOn = false;
    1:       }
    1:     }
    1:     if (isOkToTurnOn && (selType == nsISelectionController::SELECTION_OFF)) {
    1:       selCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
    1:       selType = nsISelectionController::SELECTION_ON;
    1:     }
    1:   }
    1:   return selType;
    1: }
    1: 
    1: class nsDisplaySelectionOverlay : public nsDisplayItem {
    1: public:
51260:   nsDisplaySelectionOverlay(nsDisplayListBuilder* aBuilder,
51260:                             nsFrame* aFrame, PRInt16 aSelectionValue)
51260:     : nsDisplayItem(aBuilder, aFrame), mSelectionValue(aSelectionValue) {
    1:     MOZ_COUNT_CTOR(nsDisplaySelectionOverlay);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplaySelectionOverlay() {
    1:     MOZ_COUNT_DTOR(nsDisplaySelectionOverlay);
    1:   }
    1: #endif
    1: 
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
68481:                      nsRenderingContext* aCtx);
47732:   NS_DISPLAY_DECL_NAME("SelectionOverlay", TYPE_SELECTION_OVERLAY)
    1: private:
    1:   PRInt16 mSelectionValue;
    1: };
    1: 
    1: void nsDisplaySelectionOverlay::Paint(nsDisplayListBuilder* aBuilder,
68481:                                       nsRenderingContext* aCtx)
    1: {
78130:   LookAndFeel::ColorID colorID;
    1:   if (mSelectionValue == nsISelectionController::SELECTION_ON) {
78130:     colorID = LookAndFeel::eColorID_TextSelectBackground;
    1:   } else if (mSelectionValue == nsISelectionController::SELECTION_ATTENTION) {
78130:     colorID = LookAndFeel::eColorID_TextSelectBackgroundAttention;
    1:   } else {
78130:     colorID = LookAndFeel::eColorID_TextSelectBackgroundDisabled;
78130:   }
78130: 
78130:   nscolor color = LookAndFeel::GetColor(colorID, NS_RGB(255, 255, 255));
    1: 
    1:   gfxRGBA c(color);
    1:   c.a = .5;
    1: 
15229:   gfxContext *ctx = aCtx->ThebesContext();
    1:   ctx->SetColor(c);
    1: 
33368:   nsIntRect pxRect =
33368:     mVisibleRect.ToOutsidePixels(mFrame->PresContext()->AppUnitsPerDevPixel());
   54:   ctx->NewPath();
80486:   ctx->Rectangle(gfxRect(pxRect.x, pxRect.y, pxRect.width, pxRect.height), true);
    1:   ctx->Fill();
    1: }
    1: 
    1: /********************************************************
    1: * Refreshes each content's frame
    1: *********************************************************/
    1: 
    1: nsresult
    1: nsFrame::DisplaySelectionOverlay(nsDisplayListBuilder*   aBuilder,
52291:                                  nsDisplayList*          aList,
    1:                                  PRUint16                aContentType)
    1: {
85101:   if (!IsSelected() || !IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1:     
  238:   nsPresContext* presContext = PresContext();
    1:   nsIPresShell *shell = presContext->PresShell();
    1:   if (!shell)
    1:     return NS_OK;
    1: 
39668:   PRInt16 displaySelection = shell->GetSelectionFlags();
    1:   if (!(displaySelection & aContentType))
    1:     return NS_OK;
    1: 
 8295:   const nsFrameSelection* frameSelection = GetConstFrameSelection();
    1:   PRInt16 selectionValue = frameSelection->GetDisplaySelection();
    1: 
    1:   if (selectionValue <= nsISelectionController::SELECTION_HIDDEN)
    1:     return NS_OK; // selection is hidden or off
    1: 
    1:   nsIContent *newContent = mContent->GetParent();
    1: 
    1:   //check to see if we are anonymous content
    1:   PRInt32 offset = 0;
    1:   if (newContent) {
    1:     // XXXbz there has GOT to be a better way of determining this!
    1:     offset = newContent->IndexOf(mContent);
    1:   }
    1: 
    1:   SelectionDetails *details;
    1:   //look up to see what selection(s) are on this frame
80486:   details = frameSelection->LookUpSelection(newContent, offset, 1, false);
    1:   // XXX is the above really necessary? We don't actually DO anything
    1:   // with the details other than test that they're non-null
    1:   if (!details)
    1:     return NS_OK;
    1:   
    1:   while (details) {
    1:     SelectionDetails *next = details->mNext;
    1:     delete details;
    1:     details = next;
    1:   }
    1: 
52291:   return aList->AppendNewToTop(new (aBuilder)
51260:       nsDisplaySelectionOverlay(aBuilder, this, selectionValue));
    1: }
    1: 
    1: nsresult
    1: nsFrame::DisplayOutlineUnconditional(nsDisplayListBuilder*   aBuilder,
    1:                                      const nsDisplayListSet& aLists)
    1: {
    1:   if (GetStyleOutline()->GetOutlineStyle() == NS_STYLE_BORDER_STYLE_NONE)
    1:     return NS_OK;
    1:     
51260:   return aLists.Outlines()->AppendNewToTop(
51260:       new (aBuilder) nsDisplayOutline(aBuilder, this));
    1: }
    1: 
    1: nsresult
    1: nsFrame::DisplayOutline(nsDisplayListBuilder*   aBuilder,
    1:                         const nsDisplayListSet& aLists)
    1: {
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   return DisplayOutlineUnconditional(aBuilder, aLists);
    1: }
    1: 
    1: nsresult
    1: nsIFrame::DisplayCaret(nsDisplayListBuilder* aBuilder,
39949:                        const nsRect& aDirtyRect, nsDisplayList* aList)
    1: {
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
39949:   return aList->AppendNewToTop(
51260:       new (aBuilder) nsDisplayCaret(aBuilder, this, aBuilder->GetCaret()));
    1: }
    1: 
40078: nscolor
40078: nsIFrame::GetCaretColorAt(PRInt32 aOffset)
40078: {
40078:   // Use text color.
40078:   return GetStyleColor()->mColor;
40078: }
40078: 
    1: nsresult
30510: nsFrame::DisplayBackgroundUnconditional(nsDisplayListBuilder*   aBuilder,
30510:                                         const nsDisplayListSet& aLists,
95349:                                         bool                    aForceBackground,
95349:                                         nsDisplayBackground**   aBackground)
30510: {
30510:   // Here we don't try to detect background propagation. Frames that might
30510:   // receive a propagated background should just set aForceBackground to
80486:   // true.
30510:   if (aBuilder->IsForEventDelivery() || aForceBackground ||
30510:       !GetStyleBackground()->IsTransparent() || GetStyleDisplay()->mAppearance) {
95349:     nsDisplayBackground* bg = new (aBuilder) nsDisplayBackground(aBuilder, this);
95349:     *aBackground = bg;
95349:     return aLists.BorderBackground()->AppendNewToTop(bg);
95349:   }
95349:   *aBackground = nsnull;
30510:   return NS_OK;
30510: }
30510: 
30510: nsresult
    1: nsFrame::DisplayBorderBackgroundOutline(nsDisplayListBuilder*   aBuilder,
    1:                                         const nsDisplayListSet& aLists,
79445:                                         bool                    aForceBackground)
    1: {
    1:   // The visibility check belongs here since child elements have the
    1:   // opportunity to override the visibility property and display even if
    1:   // their parent is hidden.
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
95486:   nsCSSShadowArray* shadows = GetStyleBorder()->mBoxShadow;
95486:   if (shadows && shadows->HasShadowWithInset(false)) {
15700:     nsresult rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
51260:         nsDisplayBoxShadowOuter(aBuilder, this));
15700:     NS_ENSURE_SUCCESS(rv, rv);
15700:   }
15700: 
95349:   nsDisplayBackground* bg;
30510:   nsresult rv =
95349:     DisplayBackgroundUnconditional(aBuilder, aLists, aForceBackground, &bg);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
95486:   if (shadows && shadows->HasShadowWithInset(true)) {
30510:     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
51260:         nsDisplayBoxShadowInner(aBuilder, this));
24818:     NS_ENSURE_SUCCESS(rv, rv);
24818:   }
24818: 
95349:   // If there's a themed background, we should not create a border item.
95646:   // It won't be rendered.
95646:   if ((!bg || !bg->IsThemed()) && GetStyleBorder()->HasBorder()) {
30510:     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
51260:         nsDisplayBorder(aBuilder, this));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return DisplayOutlineUnconditional(aBuilder, aLists);
    1: }
    1: 
79445: bool
91411: nsIFrame::GetClipPropClipRect(const nsStyleDisplay* aDisp, nsRect* aRect,
77286:                               const nsSize& aSize) const
    1: {
    1:   NS_PRECONDITION(aRect, "Must have aRect out parameter");
    1: 
    1:   if (!aDisp->IsAbsolutelyPositioned() ||
    1:       !(aDisp->mClipFlags & NS_STYLE_CLIP_RECT))
80486:     return false;
    1: 
  204:   *aRect = aDisp->mClip;
  204:   if (NS_STYLE_CLIP_RIGHT_AUTO & aDisp->mClipFlags) {
  462:     aRect->width = aSize.width - aRect->x;
  204:   }
  204:   if (NS_STYLE_CLIP_BOTTOM_AUTO & aDisp->mClipFlags) {
  462:     aRect->height = aSize.height - aRect->y;
    1:   }
80486:   return true;
    1: }
    1: 
91411: static bool ApplyClipPropClipping(nsDisplayListBuilder* aBuilder,
77286:                                   const nsStyleDisplay* aDisp, const nsIFrame* aFrame,
    1:                                   nsRect* aRect) {
91411:   if (!aFrame->GetClipPropClipRect(aDisp, aRect, aFrame->GetSize()))
80486:     return false;
    1: 
77286:   if (aBuilder) {
    1:     *aRect += aBuilder->ToReferenceFrame(aFrame);
77286:   }
80486:   return true;
    1: }
    1: 
79445: static bool ApplyOverflowClipping(nsDisplayListBuilder* aBuilder,
77286:                                   const nsIFrame* aFrame,
    1:                                   const nsStyleDisplay* aDisp, nsRect* aRect) {
    1:   // REVIEW: from nsContainerFrame.cpp SyncFrameViewGeometryDependentProperties,
    1:   // except that that function used the border-edge for
    1:   // -moz-hidden-unscrollable which I don't think is correct... Also I've
    1:   // changed -moz-hidden-unscrollable to apply to any kind of frame.
    1: 
    1:   // Only -moz-hidden-unscrollable is handled here (and 'hidden' for table
55006:   // frames, and any non-visible value for blocks in a paginated context).
55006:   // Other overflow clipping is applied by nsHTML/XULScrollFrame.
    1:   // We allow -moz-hidden-unscrollable to apply to any kind of frame. This
    1:   // is required by comboboxes which make their display text (an inline frame)
    1:   // have clipping.
87630:   if (!nsFrame::ApplyOverflowClipping(aFrame, aDisp)) {
87630:     return false;
87630:   }
77286:   *aRect = aFrame->GetPaddingRect() - aFrame->GetPosition();
77286:   if (aBuilder) {
77286:     *aRect += aBuilder->ToReferenceFrame(aFrame);
77286:   }
80486:   return true;
    1: }
    1: 
    1: class nsOverflowClipWrapper : public nsDisplayWrapper
    1: {
    1: public:
    1:   /**
    1:    * Create a wrapper to apply overflow clipping for aContainer.
80486:    * @param aClipBorderBackground set to true to clip the BorderBackground()
    1:    * list, otherwise it will not be clipped
80486:    * @param aClipAll set to true to clip all descendants, even those for
    1:    * which we aren't the containing block
    1:    */
    1:   nsOverflowClipWrapper(nsIFrame* aContainer, const nsRect& aRect,
52293:                         const nscoord aRadii[8],
79445:                         bool aClipBorderBackground, bool aClipAll)
    1:     : mContainer(aContainer), mRect(aRect),
52293:       mClipBorderBackground(aClipBorderBackground), mClipAll(aClipAll),
80486:       mHaveRadius(false)
52293:   {
52293:     memcpy(mRadii, aRadii, sizeof(mRadii));
52293:     NS_FOR_CSS_HALF_CORNERS(corner) {
52293:       if (aRadii[corner] > 0) {
80486:         mHaveRadius = true;
52293:         break;
52293:       }
52293:     }
52293:   }
79445:   virtual bool WrapBorderBackground() { return mClipBorderBackground; }
    1:   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
    1:                                   nsIFrame* aFrame, nsDisplayList* aList) {
    1:     // We are not a stacking context root. There is no valid underlying
    1:     // frame for the whole list. These items are all in-flow descendants so
    1:     // we can safely just clip them.
52293:     if (mHaveRadius) {
52293:       return new (aBuilder) nsDisplayClipRoundedRect(aBuilder, nsnull, aList,
52293:                                                      mRect, mRadii);
52293:     }
52289:     return new (aBuilder) nsDisplayClip(aBuilder, nsnull, aList, mRect);
    1:   }
    1:   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
    1:                                   nsDisplayItem* aItem) {
    1:     nsIFrame* f = aItem->GetUnderlyingFrame();
52293:     if (mClipAll ||
52293:         nsLayoutUtils::IsProperAncestorFrame(mContainer, f, nsnull)) {
52293:       if (mHaveRadius) {
52293:         return new (aBuilder) nsDisplayClipRoundedRect(aBuilder, f, aItem,
52293:                                                        mRect, mRadii);
52293:       }
52289:       return new (aBuilder) nsDisplayClip(aBuilder, f, aItem, mRect);
52293:     }
    1:     return aItem;
    1:   }
    1: protected:
    1:   nsIFrame*    mContainer;
    1:   nsRect       mRect;
52293:   nscoord      mRadii[8];
79445:   bool mClipBorderBackground;
79445:   bool mClipAll;
79445:   bool mHaveRadius;
    1: };
    1: 
91411: class nsDisplayClipPropWrapper : public nsDisplayWrapper
    1: {
    1: public:
91411:   nsDisplayClipPropWrapper(const nsRect& aRect)
52290:     : mRect(aRect) {}
    1:   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
    1:                                   nsIFrame* aFrame, nsDisplayList* aList) {
    1:     // We are not a stacking context root. There is no valid underlying
    1:     // frame for the whole list.
52289:     return new (aBuilder) nsDisplayClip(aBuilder, nsnull, aList, mRect);
    1:   }
    1:   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
    1:                                   nsDisplayItem* aItem) {
51260:     return new (aBuilder) nsDisplayClip(aBuilder, aItem->GetUnderlyingFrame(),
52289:                                         aItem, mRect);
    1:   }
    1: protected:
    1:   nsRect    mRect;
    1: };
    1: 
    1: nsresult
    1: nsIFrame::OverflowClip(nsDisplayListBuilder*   aBuilder,
    1:                        const nsDisplayListSet& aFromSet,
    1:                        const nsDisplayListSet& aToSet,
    1:                        const nsRect&           aClipRect,
52293:                        const nscoord           aClipRadii[8],
79445:                        bool                    aClipBorderBackground,
79445:                        bool                    aClipAll)
    1: {
52293:   nsOverflowClipWrapper wrapper(this, aClipRect, aClipRadii,
52293:                                 aClipBorderBackground, aClipAll);
    1:   return wrapper.WrapLists(aBuilder, this, aFromSet, aToSet);
    1: }
    1: 
    1: static nsresult
    1: BuildDisplayListWithOverflowClip(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
    1:     const nsRect& aDirtyRect, const nsDisplayListSet& aSet,
52293:     const nsRect& aClipRect, const nscoord aClipRadii[8])
    1: {
    1:   nsDisplayListCollection set;
    1:   nsresult rv = aFrame->BuildDisplayList(aBuilder, aDirtyRect, set);
    1:   NS_ENSURE_SUCCESS(rv, rv);
39949:   rv = aBuilder->DisplayCaret(aFrame, aDirtyRect, aSet.Content());
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
52293:   return aFrame->OverflowClip(aBuilder, set, aSet, aClipRect, aClipRadii);
    1: }
    1: 
    1: #ifdef NS_DEBUG
68481: static void PaintDebugBorder(nsIFrame* aFrame, nsRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect, nsPoint aPt) {
    1:   nsRect r(aPt, aFrame->GetSize());
    1:   if (aFrame->HasView()) {
    1:     aCtx->SetColor(NS_RGB(0,0,255));
    1:   } else {
    1:     aCtx->SetColor(NS_RGB(255,0,0));
    1:   }
    1:   aCtx->DrawRect(r);
    1: }
    1: 
68481: static void PaintEventTargetBorder(nsIFrame* aFrame, nsRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect, nsPoint aPt) {
    1:   nsRect r(aPt, aFrame->GetSize());
    1:   aCtx->SetColor(NS_RGB(128,0,128));
    1:   aCtx->DrawRect(r);
    1: }
    1: 
    1: static void
    1: DisplayDebugBorders(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
    1:                     const nsDisplayListSet& aLists) {
    1:   // Draw a border around the child
    1:   // REVIEW: From nsContainerFrame::PaintChild
31709:   if (nsFrame::GetShowFrameBorders() && !aFrame->GetRect().IsEmpty()) {
    1:     aLists.Outlines()->AppendNewToTop(new (aBuilder)
51260:         nsDisplayGeneric(aBuilder, aFrame, PaintDebugBorder, "DebugBorder",
47732:                          nsDisplayItem::TYPE_DEBUG_BORDER));
    1:   }
    1:   // Draw a border around the current event target
31709:   if (nsFrame::GetShowEventTargetFrameBorder() &&
  238:       aFrame->PresContext()->PresShell()->GetDrawEventTargetFrame() == aFrame) {
    1:     aLists.Outlines()->AppendNewToTop(new (aBuilder)
51260:         nsDisplayGeneric(aBuilder, aFrame, PaintEventTargetBorder, "EventTargetBorder",
47732:                          nsDisplayItem::TYPE_EVENT_TARGET_BORDER));
    1:   }
    1: }
    1: #endif
    1: 
77286: static nsresult
79635: WrapPreserve3DListInternal(nsIFrame* aFrame, nsDisplayListBuilder *aBuilder, nsDisplayList *aList, PRUint32& aIndex)
79635: {
79635:   if (aIndex > nsDisplayTransform::INDEX_MAX) {
79635:     return NS_OK;
79635:   }
79635: 
77286:   nsresult rv = NS_OK;
77286:   nsDisplayList newList;
79635:   nsDisplayList temp;
77286:   while (nsDisplayItem *item = aList->RemoveBottom()) {
77850:     nsIFrame *childFrame = item->GetUnderlyingFrame();
79635: 
79635:     // We accumulate sequential items that aren't transforms into the 'temp' list
79635:     // and then flush this list into newList by wrapping the whole lot with a single
79635:     // nsDisplayTransform.
79635: 
82356:     if (childFrame && (childFrame->GetParent()->Preserves3DChildren() || childFrame == aFrame)) {
77286:       switch (item->GetType()) {
77286:         case nsDisplayItem::TYPE_TRANSFORM: {
79635:           if (!temp.IsEmpty()) {
79635:             newList.AppendToTop(new (aBuilder) nsDisplayTransform(aBuilder, aFrame, &temp, aIndex++));
79635:           }
79635:           newList.AppendToTop(item);
77286:           break;
77286:         }
77286:         case nsDisplayItem::TYPE_WRAP_LIST: {
79635:           if (!temp.IsEmpty()) {
79635:             newList.AppendToTop(new (aBuilder) nsDisplayTransform(aBuilder, aFrame, &temp, aIndex++));
79635:           }
77286:           nsDisplayWrapList *list = static_cast<nsDisplayWrapList*>(item);
79635:           rv = WrapPreserve3DListInternal(aFrame, aBuilder, list->GetList(), aIndex);
79923:           newList.AppendToTop(list->GetList());
79923:           list->~nsDisplayWrapList();
77286:           break;
77286:         }
77286:         case nsDisplayItem::TYPE_OPACITY: {
79635:           if (!temp.IsEmpty()) {
79635:             newList.AppendToTop(new (aBuilder) nsDisplayTransform(aBuilder, aFrame, &temp, aIndex++));
79635:           }
77286:           nsDisplayOpacity *opacity = static_cast<nsDisplayOpacity*>(item);
79635:           rv = WrapPreserve3DListInternal(aFrame, aBuilder, opacity->GetList(), aIndex);
95693:           opacity->UpdateBounds(aBuilder);
79635:           newList.AppendToTop(item);
77286:           break;
77286:         }
77286:         default: {
79635:           temp.AppendToTop(item);
77286:           break;
77286:         }
77286:       } 
77286:     } else {
79635:       temp.AppendToTop(item);
79635:     }
79635:  
79635:     if (NS_FAILED(rv) || !item || aIndex > nsDisplayTransform::INDEX_MAX)
77286:       return rv;
79635:   }
79635:     
79635:   if (!temp.IsEmpty()) {
79635:     newList.AppendToTop(new (aBuilder) nsDisplayTransform(aBuilder, aFrame, &temp, aIndex++));
77286:   }
77286: 
77286:   aList->AppendToTop(&newList);
77286:   return NS_OK;
77286: }
77286: 
79635: static nsresult
79635: WrapPreserve3DList(nsIFrame* aFrame, nsDisplayListBuilder* aBuilder, nsDisplayList *aList)
79635: {
79635:   PRUint32 index = 0;
79635:   return WrapPreserve3DListInternal(aFrame, aBuilder, aList, index);
79635: }
79635: 
    1: nsresult
    1: nsIFrame::BuildDisplayListForStackingContext(nsDisplayListBuilder* aBuilder,
    1:                                              const nsRect&         aDirtyRect,
    1:                                              nsDisplayList*        aList) {
 3724:   if (GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE)
    1:     return NS_OK;
    1: 
    1:   // Replaced elements have their visibility handled here, because
    1:   // they're visually atomic
    1:   if (IsFrameOfType(eReplaced) && !IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
91411:   nsRect clipPropClip;
    1:   const nsStyleDisplay* disp = GetStyleDisplay();
34209:   // We can stop right away if this is a zero-opacity stacking context and
70349:   // we're painting.
70349:   if (disp->mOpacity == 0.0 && aBuilder->IsForPainting())
34209:     return NS_OK;
34209: 
91411:   bool applyClipPropClipping =
91411:       ApplyClipPropClipping(aBuilder, disp, this, &clipPropClip);
    1:   nsRect dirtyRect = aDirtyRect;
19214: 
79445:   bool inTransform = aBuilder->IsInTransform();
50423:   if ((mState & NS_FRAME_MAY_BE_TRANSFORMED) &&
30541:       disp->HasTransform()) {
84920:     if (nsDisplayTransform::ShouldPrerenderTransformedContent(aBuilder, this) ||
84920:         Preserves3DChildren()) {
84920:       dirtyRect = GetVisualOverflowRectRelativeToSelf();
84920:     } else {
78032:       // Transform dirtyRect into our frame's local coordinate space. Note that
78032:       // the new value is the bounds of the old value's transformed vertices, so
78032:       // the area covered by dirtyRect may increase here.
78032:       //
78032:       // Although we don't bother to check for and maintain the 1x1 size of the
78032:       // magic rect indicating a hit test point, in reality this is extremely
78032:       // unlikely to matter. The rect starts off with dimensions of 1x1 *app*
78032:       // units, and it would require a very large number of elements with
78032:       // transforms along a parent chain to noticably expand this by an entire
78032:       // device pixel.
84920:       if (!nsDisplayTransform::UntransformRect(dirtyRect, this, nsPoint(0, 0), &dirtyRect)) {
78032:         // we have a singular transform - just grab the entire overflow rect
74283:         dirtyRect = GetVisualOverflowRectRelativeToSelf();
74283:       }
84920:     }
80486:     inTransform = true;
30541:   }
19214: 
91411:   if (applyClipPropClipping) {
    1:     dirtyRect.IntersectRect(dirtyRect,
91411:                             clipPropClip - aBuilder->ToReferenceFrame(this));
    1:   }
    1: 
79445:   bool usingSVGEffects = nsSVGIntegrationUtils::UsingEffectsForFrame(this);
19125:   if (usingSVGEffects) {
19125:     dirtyRect =
19125:       nsSVGIntegrationUtils::GetRequiredSourceForInvalidArea(this, dirtyRect);
19125:   }
19125: 
79483:   // Mark the display list items for absolutely positioned children
79692:   MarkAbsoluteFramesForDisplayList(aBuilder, dirtyRect);
79483: 
    1:   nsDisplayListCollection set;
    1:   nsresult rv;
    1:   {    
95645:     nsDisplayListBuilder::AutoBuildingDisplayList rootSetter(aBuilder, true);
30541:     nsDisplayListBuilder::AutoInTransformSetter
30541:       inTransformSetter(aBuilder, inTransform);
    1:     rv = BuildDisplayList(aBuilder, dirtyRect, set);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:   if (aBuilder->IsBackgroundOnly()) {
    1:     set.BlockBorderBackgrounds()->DeleteAll();
    1:     set.Floats()->DeleteAll();
    1:     set.Content()->DeleteAll();
    1:     set.PositionedDescendants()->DeleteAll();
    1:     set.Outlines()->DeleteAll();
    1:   }
    1:   
    1:   // This z-order sort also sorts secondarily by content order. We need to do
    1:   // this so that boxes produced by the same element are placed together
    1:   // in the sort. Consider a position:relative inline element that breaks
    1:   // across lines and has absolutely positioned children; all the abs-pos
    1:   // children should be z-ordered after all the boxes for the position:relative
    1:   // element itself.
    1:   set.PositionedDescendants()->SortByZOrder(aBuilder, GetContent());
    1:   
    1:   nsRect overflowClip;
    1:   if (ApplyOverflowClipping(aBuilder, this, disp, &overflowClip)) {
52293:     nscoord radii[8];
52293:     this->GetPaddingBoxBorderRadii(radii);
52293:     nsOverflowClipWrapper wrapper(this, overflowClip, radii,
80486:                                   false, false);
    1:     rv = wrapper.WrapListsInPlace(aBuilder, this, set);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   // We didn't use overflowClip to restrict the dirty rect, since some of the
    1:   // descendants may not be clipped by it. Even if we end up with unnecessary
33368:   // display items, they'll be pruned during ComputeVisibility.  
    1: 
    1:   nsDisplayList resultList;
    1:   // Now follow the rules of http://www.w3.org/TR/CSS21/zindex.html
    1:   // 1,2: backgrounds and borders
    1:   resultList.AppendToTop(set.BorderBackground());
    1:   // 3: negative z-index children.
    1:   for (;;) {
    1:     nsDisplayItem* item = set.PositionedDescendants()->GetBottom();
    1:     if (item) {
    1:       nsIFrame* f = item->GetUnderlyingFrame();
    1:       NS_ASSERTION(f, "After sorting, every item in the list should have an underlying frame");
    1:       if (nsLayoutUtils::GetZIndex(f) < 0) {
    1:         set.PositionedDescendants()->RemoveBottom();
    1:         resultList.AppendToTop(item);
    1:         continue;
    1:       }
    1:     }
    1:     break;
    1:   }
    1:   // 4: block backgrounds
    1:   resultList.AppendToTop(set.BlockBorderBackgrounds());
    1:   // 5: floats
    1:   resultList.AppendToTop(set.Floats());
 3660:   // 7: general content
    1:   resultList.AppendToTop(set.Content());
 3660:   // 7.5: outlines, in content tree order. We need to sort by content order
    1:   // because an element with outline that breaks and has children with outline
    1:   // might have placed child outline items between its own outline items.
    1:   // The element's outline items need to all come before any child outline
    1:   // items.
    1:   set.Outlines()->SortByContentOrder(aBuilder, GetContent());
    1: #ifdef NS_DEBUG
    1:   DisplayDebugBorders(aBuilder, this, set);
    1: #endif
   67:   resultList.AppendToTop(set.Outlines());
 3660:   // 8, 9: non-negative z-index children
 3660:   resultList.AppendToTop(set.PositionedDescendants());
    1: 
78033:   /* If we have absolute position clipping and we have, or will have, items to
78033:    * be clipped, wrap the list in a clip wrapper.
78033:    */
91411:   if (applyClipPropClipping &&
78033:       (!resultList.IsEmpty() || usingSVGEffects)) {
91411:     nsDisplayClipPropWrapper wrapper(clipPropClip);
    1:     nsDisplayItem* item = wrapper.WrapList(aBuilder, this, &resultList);
    1:     if (!item)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     // resultList was emptied
    1:     resultList.AppendToTop(item);
    1:   }
    1: 
78032:   /* If there are any SVG effects, wrap the list up in an SVG effects item
78032:    * (which also handles CSS group opacity). Note that we create an SVG effects
78032:    * item even if resultList is empty, since a filter can produce graphical
78032:    * output even if the element being filtered wouldn't otherwise do so.
78032:    */
19125:   if (usingSVGEffects) {
19214:     /* List now emptied, so add the new list to the top. */
51260:     rv = resultList.AppendNewToTop(
51260:         new (aBuilder) nsDisplaySVGEffects(aBuilder, this, &resultList));
51260:     if (NS_FAILED(rv))
51260:       return rv;
78032:   }
78032:   /* Else, if the list is non-empty and there is CSS group opacity without SVG
78032:    * effects, wrap it up in an opacity item.
54268:    */
78032:   else if (disp->mOpacity < 1.0f && !resultList.IsEmpty()) {
51260:     rv = resultList.AppendNewToTop(
51260:         new (aBuilder) nsDisplayOpacity(aBuilder, this, &resultList));
51260:     if (NS_FAILED(rv))
51260:       return rv;
19214:   }
19214: 
77286:   /* If we're going to apply a transformation and don't have preserve-3d set, wrap 
77286:    * everything in an nsDisplayTransform. If there's nothing in the list, don't add 
77286:    * anything.
77286:    *
77286:    * For the preserve-3d case we want to individually wrap every child in the list with
77286:    * a separate nsDisplayTransform instead. When the child is already an nsDisplayTransform,
77286:    * we can skip this step, as the computed transform will already include our own.
77286:    *
77286:    * We also traverse into sublists created by nsDisplayWrapList or nsDisplayOpacity, so that
77286:    * we find all the correct children.
19214:    */
50423:   if ((mState & NS_FRAME_MAY_BE_TRANSFORMED) &&
54268:       disp->HasTransform() && !resultList.IsEmpty()) {
77286:     if (Preserves3DChildren()) {
77286:       rv = WrapPreserve3DList(this, aBuilder, &resultList);
77286:       if (NS_FAILED(rv))
77286:         return rv;
77286:     } else {
51260:       rv = resultList.AppendNewToTop(
51260:         new (aBuilder) nsDisplayTransform(aBuilder, this, &resultList));
51260:       if (NS_FAILED(rv))
51260:         return rv;
19214:     }
77286:   }
19214: 
    1:   aList->AppendToTop(&resultList);
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsIFrame::BuildDisplayListForChild(nsDisplayListBuilder*   aBuilder,
    1:                                    nsIFrame*               aChild,
    1:                                    const nsRect&           aDirtyRect,
    1:                                    const nsDisplayListSet& aLists,
    1:                                    PRUint32                aFlags) {
    1:   // If painting is restricted to just the background of the top level frame,
    1:   // then we have nothing to do here.
    1:   if (aBuilder->IsBackgroundOnly())
    1:     return NS_OK;
    1: 
81616:   nsIFrame* child = aChild;
81616:   if (child->GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE)
    1:     return NS_OK;
    1: 
80486:   // true if this is a real or pseudo stacking context
79445:   bool pseudoStackingContext =
    1:     (aFlags & DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT) != 0;
    1:   if ((aFlags & DISPLAY_CHILD_INLINE) &&
81616:       !child->IsFrameOfType(eLineParticipant)) {
    1:     // child is a non-inline frame in an inline context, i.e.,
    1:     // it acts like inline-block or inline-table. Therefore it is a
    1:     // pseudo-stacking-context.
80486:     pseudoStackingContext = true;
    1:   }
    1: 
    1:   // dirty rect in child-relative coordinates
81616:   nsRect dirty = aDirtyRect - child->GetOffsetTo(this);
81616: 
81616:   nsIAtom* childType = child->GetType();
    1:   if (childType == nsGkAtoms::placeholderFrame) {
81616:     nsPlaceholderFrame* placeholder = static_cast<nsPlaceholderFrame*>(child);
81616:     child = placeholder->GetOutOfFlowFrame();
81616:     NS_ASSERTION(child, "No out of flow frame?");
81617:     // If 'child' is a pushed float then it's owned by a block that's not an
81617:     // ancestor of the placeholder, and it will be painted by that block and
81617:     // should not be painted through the placeholder.
81617:     if (!child || nsLayoutUtils::IsPopup(child) ||
81617:         (child->GetStateBits() & NS_FRAME_IS_PUSHED_FLOAT))
    1:       return NS_OK;
    1:     // Make sure that any attempt to use childType below is disappointed. We
    1:     // could call GetType again but since we don't currently need it, let's
    1:     // avoid the virtual call.
    1:     childType = nsnull;
 3724:     // Recheck NS_FRAME_TOO_DEEP_IN_FRAME_TREE
81616:     if (child->GetStateBits() & NS_FRAME_TOO_DEEP_IN_FRAME_TREE)
    1:       return NS_OK;
 3233:     nsRect* savedDirty = static_cast<nsRect*>
81616:       (child->Properties().Get(nsDisplayListBuilder::OutOfFlowDirtyRectProperty()));
    1:     if (savedDirty) {
    1:       dirty = *savedDirty;
    1:     } else {
    1:       // The out-of-flow frame did not intersect the dirty area. We may still
    1:       // need to traverse into it, since it may contain placeholders we need
    1:       // to enter to reach other out-of-flow frames that are visible.
68639:       dirty.SetEmpty();
    1:     }
80486:     pseudoStackingContext = true;
79483:   }
79483: 
79483:   // Mark the display list items for absolutely positioned children
81616:   child->MarkAbsoluteFramesForDisplayList(aBuilder, dirty);
79483: 
79483:   if (childType != nsGkAtoms::placeholderFrame &&
79483:       aBuilder->GetSelectedFramesOnly() &&
81616:       child->IsLeaf() &&
85101:       !aChild->IsSelected()) {
47337:     return NS_OK;
47337:   }
47337: 
58774:   if (aBuilder->GetIncludeAllOutOfFlows() &&
81616:       (child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
81616:     dirty = child->GetVisualOverflowRect();
81616:   } else if (!(child->GetStateBits() & NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO)) {
81616:     // No need to descend into child to catch placeholders for visible
    1:     // positioned stuff. So see if we can short-circuit frame traversal here.
    1: 
81616:     // We can stop if child's frame subtree's intersection with the
26699:     // dirty area is empty.
    1:     // If the child is a scrollframe that we want to ignore, then we need
    1:     // to descend into it because its scrolled child may intersect the dirty
    1:     // area even if the scrollframe itself doesn't.
81616:     if (child != aBuilder->GetIgnoreScrollFrame()) {
26699:       nsRect childDirty;
94996:       if (!childDirty.IntersectRect(dirty, child->GetVisualOverflowRect()))
    1:         return NS_OK;
26699:       // Usually we could set dirty to childDirty now but there's no
26699:       // benefit, and it can be confusing. It can especially confuse
26699:       // situations where we're going to ignore a scrollframe's clipping;
26699:       // we wouldn't want to clip the dirty area to the scrollframe's
26699:       // bounds in that case.
26699:     }
    1:   }
    1: 
    1:   // XXX need to have inline-block and inline-table set pseudoStackingContext
    1:   
    1:   const nsStyleDisplay* ourDisp = GetStyleDisplay();
    1:   // REVIEW: Taken from nsBoxFrame::Paint
    1:   // Don't paint our children if the theme object is a leaf.
    1:   if (IsThemed(ourDisp) &&
  238:       !PresContext()->GetTheme()->WidgetIsContainer(ourDisp->mAppearance))
    1:     return NS_OK;
    1: 
19214:   // Child is composited if it's transformed, partially transparent, or has
19214:   // SVG effects.
81616:   const nsStyleDisplay* disp = child->GetStyleDisplay();
79445:   bool isVisuallyAtomic = disp->mOpacity != 1.0f
81616:     || child->IsTransformed()
81616:     || nsSVGIntegrationUtils::UsingEffectsForFrame(child);
71013: 
79445:   bool isPositioned = disp->IsPositioned();
78035:   if (isVisuallyAtomic || isPositioned || disp->IsFloating() ||
32107:       (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
    1:     // If you change this, also change IsPseudoStackingContextFromStyle()
80486:     pseudoStackingContext = true;
    1:   }
    1: 
95645:   nsDisplayListBuilder::AutoBuildingDisplayList
95645:     buildingForChild(aBuilder, child, pseudoStackingContext);
95645: 
    1:   nsRect overflowClip;
52293:   nscoord overflowClipRadii[8];
79445:   bool applyOverflowClip =
81616:     ApplyOverflowClipping(aBuilder, child, disp, &overflowClip);
52293:   if (applyOverflowClip) {
81616:     child->GetPaddingBoxBorderRadii(overflowClipRadii);
52293:   }
    1:   // Don't use overflowClip to restrict the dirty rect, since some of the
    1:   // descendants may not be clipped by it. Even if we end up with unnecessary
33368:   // display items, they'll be pruned during ComputeVisibility. Note that
    1:   // this overflow-clipping here only applies to overflow:-moz-hidden-unscrollable;
    1:   // overflow:hidden etc creates an nsHTML/XULScrollFrame which does its own
    1:   // clipping.
    1: 
    1:   nsresult rv;
    1:   if (!pseudoStackingContext) {
    1:     // THIS IS THE COMMON CASE.
    1:     // Not a pseudo or real stacking context. Do the simple thing and
    1:     // return early.
    1:     if (applyOverflowClip) {
81616:       rv = BuildDisplayListWithOverflowClip(aBuilder, child, dirty, aLists,
52293:                                             overflowClip, overflowClipRadii);
    1:     } else {
81616:       rv = child->BuildDisplayList(aBuilder, dirty, aLists);
    1:       if (NS_SUCCEEDED(rv)) {
81616:         rv = aBuilder->DisplayCaret(child, dirty, aLists.Content());
    1:       }
    1:     }
    1: #ifdef NS_DEBUG
81616:     DisplayDebugBorders(aBuilder, child, aLists);
    1: #endif
    1:     return rv;
    1:   }
    1:   
    1:   nsDisplayList list;
    1:   nsDisplayList extraPositionedDescendants;
81616:   const nsStylePosition* pos = child->GetStylePosition();
    1:   if ((isPositioned && pos->mZIndex.GetUnit() == eStyleUnit_Integer) ||
78035:       isVisuallyAtomic || (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
    1:     // True stacking context
81616:     rv = child->BuildDisplayListForStackingContext(aBuilder, dirty, &list);
    1:     if (NS_SUCCEEDED(rv)) {
81616:       rv = aBuilder->DisplayCaret(child, dirty, &list);
    1:     }
    1:   } else {
    1:     nsRect clipRect;
91411:     bool applyClipPropClipping =
91411:         ApplyClipPropClipping(aBuilder, disp, child, &clipRect);
 7046:     // A pseudo-stacking context (e.g., a positioned element with z-index auto).
78032:     // We allow positioned descendants of the child to escape to our parent
78032:     // stacking context's positioned descendant list, because they might be
    1:     // z-index:non-auto
    1:     nsDisplayListCollection pseudoStack;
    1:     nsRect clippedDirtyRect = dirty;
91411:     if (applyClipPropClipping) {
    1:       // clipRect is in builder-reference-frame coordinates,
81616:       // dirty/clippedDirtyRect are in child coordinates
    1:       clippedDirtyRect.IntersectRect(clippedDirtyRect,
81616:                                      clipRect - aBuilder->ToReferenceFrame(child));
    1:     }
    1:     
    1:     if (applyOverflowClip) {
81616:       rv = BuildDisplayListWithOverflowClip(aBuilder, child, clippedDirtyRect,
52293:                                             pseudoStack, overflowClip,
52293:                                             overflowClipRadii);
    1:     } else {
81616:       rv = child->BuildDisplayList(aBuilder, clippedDirtyRect, pseudoStack);
    1:       if (NS_SUCCEEDED(rv)) {
81616:         rv = aBuilder->DisplayCaret(child, dirty, pseudoStack.Content());
    1:       }
    1:     }
    1:     
    1:     if (NS_SUCCEEDED(rv)) {
91411:       if (applyClipPropClipping) {
91411:         nsDisplayClipPropWrapper wrapper(clipRect);
81616:         rv = wrapper.WrapListsInPlace(aBuilder, child, pseudoStack);
    1:       }
    1:     }
    1:     list.AppendToTop(pseudoStack.BorderBackground());
    1:     list.AppendToTop(pseudoStack.BlockBorderBackgrounds());
    1:     list.AppendToTop(pseudoStack.Floats());
    1:     list.AppendToTop(pseudoStack.Content());
 3660:     list.AppendToTop(pseudoStack.Outlines());
    1:     extraPositionedDescendants.AppendToTop(pseudoStack.PositionedDescendants());
    1: #ifdef NS_DEBUG
81616:     DisplayDebugBorders(aBuilder, child, aLists);
    1: #endif
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:     
78035:   if (isPositioned || isVisuallyAtomic ||
    1:       (aFlags & DISPLAY_CHILD_FORCE_STACKING_CONTEXT)) {
    1:     // Genuine stacking contexts, and positioned pseudo-stacking-contexts,
    1:     // go in this level.
95487:     if (!list.IsEmpty()) {
    1:       rv = aLists.PositionedDescendants()->AppendNewToTop(new (aBuilder)
81616:           nsDisplayWrapList(aBuilder, child, &list));
    1:       NS_ENSURE_SUCCESS(rv, rv);
95487:     }
    1:   } else if (disp->IsFloating()) {
95487:     if (!list.IsEmpty()) {
    1:       rv = aLists.Floats()->AppendNewToTop(new (aBuilder)
81616:           nsDisplayWrapList(aBuilder, child, &list));
    1:       NS_ENSURE_SUCCESS(rv, rv);
95487:     }
    1:   } else {
    1:     aLists.Content()->AppendToTop(&list);
    1:   }
    1:   // We delay placing the positioned descendants of positioned frames to here,
    1:   // because in the absence of z-index this is the correct order for them.
    1:   // This doesn't affect correctness because the positioned descendants list
    1:   // is sorted by z-order and content in BuildDisplayListForStackingContext,
    1:   // but it means that sort routine needs to do less work.
    1:   aLists.PositionedDescendants()->AppendToTop(&extraPositionedDescendants);
    1:   return NS_OK;
    1: }
    1: 
52294: void
79483: nsIFrame::MarkAbsoluteFramesForDisplayList(nsDisplayListBuilder* aBuilder,
79483:                                            const nsRect& aDirtyRect)
79483: {
79483:   if (IsAbsoluteContainer()) {
79483:     aBuilder->MarkFramesForDisplayList(this, GetAbsoluteContainingBlock()->GetChildList(), aDirtyRect);
79483:   }
79483: }
79483: 
79483: void
52294: nsIFrame::WrapReplacedContentForBorderRadius(nsDisplayListBuilder* aBuilder,
52294:                                              nsDisplayList* aFromList,
52294:                                              const nsDisplayListSet& aToLists)
52294: {
52294:   nscoord radii[8];
52294:   if (GetContentBoxBorderRadii(radii)) {
52294:     // If we have a border-radius, we have to clip our content to that
52294:     // radius.
52294:     nsDisplayListCollection set;
52294:     set.Content()->AppendToTop(aFromList);
52294:     nsRect clipRect = GetContentRect() - GetPosition() +
52294:                       aBuilder->ToReferenceFrame(this);
80486:     OverflowClip(aBuilder, set, aToLists, clipRect, radii, false, true);
52294: 
52294:     return;
52294:   }
52294: 
52294:   aToLists.Content()->AppendToTop(aFromList);
52294: }
52294: 
    1: NS_IMETHODIMP  
79435: nsFrame::GetContentForEvent(nsEvent* aEvent,
    1:                             nsIContent** aContent)
    1: {
32180:   nsIFrame* f = nsLayoutUtils::GetNonGeneratedAncestor(this);
32180:   *aContent = f->GetContent();
    1:   NS_IF_ADDREF(*aContent);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrame::FireDOMEvent(const nsAString& aDOMEventName, nsIContent *aContent)
    1: {
25812:   nsIContent* target = aContent ? aContent : mContent;
25812: 
25812:   if (target) {
84833:     nsRefPtr<nsAsyncDOMEvent> event =
84833:       new nsAsyncDOMEvent(target, aDOMEventName, true, false);
72509:     if (NS_FAILED(event->PostDOMEvent()))
84833:       NS_WARNING("Failed to dispatch nsAsyncDOMEvent");
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::HandleEvent(nsPresContext* aPresContext, 
    1:                      nsGUIEvent*     aEvent,
    1:                      nsEventStatus*  aEventStatus)
    1: {
    1: 
    1:   if (aEvent->message == NS_MOUSE_MOVE) {
    1:     return HandleDrag(aPresContext, aEvent, aEventStatus);
    1:   }
    1: 
    1:   if (aEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:       static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton) {
    1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
    1:       HandlePress(aPresContext, aEvent, aEventStatus);
    1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
    1:       HandleRelease(aPresContext, aEvent, aEventStatus);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 8295: nsFrame::GetDataForTableSelection(const nsFrameSelection *aFrameSelection,
    1:                                   nsIPresShell *aPresShell, nsMouseEvent *aMouseEvent, 
    1:                                   nsIContent **aParentContent, PRInt32 *aContentOffset, PRInt32 *aTarget)
    1: {
    1:   if (!aFrameSelection || !aPresShell || !aMouseEvent || !aParentContent || !aContentOffset || !aTarget)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   *aParentContent = nsnull;
    1:   *aContentOffset = 0;
    1:   *aTarget = 0;
    1: 
39668:   PRInt16 displaySelection = aPresShell->GetSelectionFlags();
    1: 
79445:   bool selectingTableCells = aFrameSelection->GetTableCellSelection();
    1: 
    1:   // DISPLAY_ALL means we're in an editor.
    1:   // If already in cell selection mode, 
    1:   //  continue selecting with mouse drag or end on mouse up,
    1:   //  or when using shift key to extend block of cells
    1:   //  (Mouse down does normal selection unless Ctrl/Cmd is pressed)
79445:   bool doTableSelection =
    1:      displaySelection == nsISelectionDisplay::DISPLAY_ALL && selectingTableCells &&
    1:      (aMouseEvent->message == NS_MOUSE_MOVE ||
    1:       (aMouseEvent->message == NS_MOUSE_BUTTON_UP &&
    1:        aMouseEvent->button == nsMouseEvent::eLeftButton) ||
    1:       aMouseEvent->isShift);
    1: 
    1:   if (!doTableSelection)
    1:   {  
    1:     // In Browser, special 'table selection' key must be pressed for table selection
    1:     // or when just Shift is pressed and we're already in table/cell selection mode
 6499: #ifdef XP_MACOSX
    1:     doTableSelection = aMouseEvent->isMeta || (aMouseEvent->isShift && selectingTableCells);
    1: #else
    1:     doTableSelection = aMouseEvent->isControl || (aMouseEvent->isShift && selectingTableCells);
    1: #endif
    1:   }
    1:   if (!doTableSelection) 
    1:     return NS_OK;
    1: 
    1:   // Get the cell frame or table frame (or parent) of the current content node
    1:   nsIFrame *frame = this;
79445:   bool foundCell = false;
79445:   bool foundTable = false;
    1: 
    1:   // Get the limiting node to stop parent frame search
    1:   nsIContent* limiter = aFrameSelection->GetLimiter();
    1: 
56876:   // If our content node is an ancestor of the limiting node,
56876:   // we should stop the search right now.
56876:   if (limiter && nsContentUtils::ContentIsDescendantOf(limiter, GetContent()))
56876:     return NS_OK;
56876: 
    1:   //We don't initiate row/col selection from here now,
    1:   //  but we may in future
79445:   //bool selectColumn = false;
79445:   //bool selectRow = false;
    1:   
39668:   while (frame)
    1:   {
    1:     // Check for a table cell by querying to a known CellFrame interface
23554:     nsITableCellLayout *cellElement = do_QueryFrame(frame);
23554:     if (cellElement)
    1:     {
80486:       foundCell = true;
    1:       //TODO: If we want to use proximity to top or left border
    1:       //      for row and column selection, this is the place to do it
    1:       break;
    1:     }
    1:     else
    1:     {
    1:       // If not a cell, check for table
    1:       // This will happen when starting frame is the table or child of a table,
    1:       //  such as a row (we were inbetween cells or in table border)
23554:       nsITableLayout *tableElement = do_QueryFrame(frame);
23554:       if (tableElement)
    1:       {
80486:         foundTable = true;
    1:         //TODO: How can we select row when along left table edge
    1:         //  or select column when along top edge?
    1:         break;
    1:       } else {
    1:         frame = frame->GetParent();
    1:         // Stop if we have hit the selection's limiting content node
    1:         if (frame && frame->GetContent() == limiter)
    1:           break;
    1:       }
    1:     }
    1:   }
    1:   // We aren't in a cell or table
    1:   if (!foundCell && !foundTable) return NS_OK;
    1: 
    1:   nsIContent* tableOrCellContent = frame->GetContent();
    1:   if (!tableOrCellContent) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIContent> parentContent = tableOrCellContent->GetParent();
    1:   if (!parentContent) return NS_ERROR_FAILURE;
    1: 
    1:   PRInt32 offset = parentContent->IndexOf(tableOrCellContent);
    1:   // Not likely?
    1:   if (offset < 0) return NS_ERROR_FAILURE;
    1: 
    1:   // Everything is OK -- set the return values
    1:   *aParentContent = parentContent;
    1:   NS_ADDREF(*aParentContent);
    1: 
    1:   *aContentOffset = offset;
    1: 
    1: #if 0
    1:   if (selectRow)
    1:     *aTarget = nsISelectionPrivate::TABLESELECTION_ROW;
    1:   else if (selectColumn)
    1:     *aTarget = nsISelectionPrivate::TABLESELECTION_COLUMN;
    1:   else 
    1: #endif
    1:   if (foundCell)
    1:     *aTarget = nsISelectionPrivate::TABLESELECTION_CELL;
    1:   else if (foundTable)
    1:     *aTarget = nsISelectionPrivate::TABLESELECTION_TABLE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFrame::IsSelectable(bool* aSelectable, PRUint8* aSelectStyle) const
    1: {
    1:   if (!aSelectable) //it's ok if aSelectStyle is null
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // Like 'visibility', we must check all the parents: if a parent
    1:   // is not selectable, none of its children is selectable.
    1:   //
    1:   // The -moz-all value acts similarly: if a frame has 'user-select:-moz-all',
    1:   // all its children are selectable, even those with 'user-select:none'.
    1:   //
    1:   // As a result, if 'none' and '-moz-all' are not present in the frame hierarchy,
    1:   // aSelectStyle returns the first style that is not AUTO. If these values
    1:   // are present in the frame hierarchy, aSelectStyle returns the style of the
    1:   // topmost parent that has either 'none' or '-moz-all'.
    1:   //
    1:   // For instance, if the frame hierarchy is:
    1:   //    AUTO     -> _MOZ_ALL -> NONE -> TEXT,     the returned value is _MOZ_ALL
    1:   //    TEXT     -> NONE     -> AUTO -> _MOZ_ALL, the returned value is NONE
    1:   //    _MOZ_ALL -> TEXT     -> AUTO -> AUTO,     the returned value is _MOZ_ALL
    1:   //    AUTO     -> CELL     -> TEXT -> AUTO,     the returned value is TEXT
    1:   //
    1:   PRUint8 selectStyle  = NS_STYLE_USER_SELECT_AUTO;
    1:   nsIFrame* frame      = (nsIFrame*)this;
    1: 
    1:   while (frame) {
    1:     const nsStyleUIReset* userinterface = frame->GetStyleUIReset();
    1:     switch (userinterface->mUserSelect) {
    1:       case NS_STYLE_USER_SELECT_ALL:
    1:       case NS_STYLE_USER_SELECT_NONE:
    1:       case NS_STYLE_USER_SELECT_MOZ_ALL:
    1:         // override the previous values
    1:         selectStyle = userinterface->mUserSelect;
    1:         break;
    1:       default:
    1:         // otherwise return the first value which is not 'auto'
    1:         if (selectStyle == NS_STYLE_USER_SELECT_AUTO) {
    1:           selectStyle = userinterface->mUserSelect;
    1:         }
    1:         break;
    1:     }
    1:     frame = frame->GetParent();
    1:   }
    1: 
    1:   // convert internal values to standard values
    1:   if (selectStyle == NS_STYLE_USER_SELECT_AUTO)
    1:     selectStyle = NS_STYLE_USER_SELECT_TEXT;
    1:   else
    1:   if (selectStyle == NS_STYLE_USER_SELECT_MOZ_ALL)
    1:     selectStyle = NS_STYLE_USER_SELECT_ALL;
    1:   else
    1:   if (selectStyle == NS_STYLE_USER_SELECT_MOZ_NONE)
    1:     selectStyle = NS_STYLE_USER_SELECT_NONE;
    1: 
    1:   // return stuff
    1:   if (aSelectStyle)
    1:     *aSelectStyle = selectStyle;
    1:   if (mState & NS_FRAME_GENERATED_CONTENT)
80486:     *aSelectable = false;
79843:   else
79843:     *aSelectable = (selectStyle != NS_STYLE_USER_SELECT_NONE);
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * Handles the Mouse Press Event for the frame
    1:  */
    1: NS_IMETHODIMP
    1: nsFrame::HandlePress(nsPresContext* aPresContext, 
    1:                      nsGUIEvent*     aEvent,
    1:                      nsEventStatus*  aEventStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
    1:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   //We often get out of sync state issues with mousedown events that
    1:   //get interrupted by alerts/dialogs.
    1:   //Check with the ESM to see if we should process this one
68780:   if (!aPresContext->EventStateManager()->EventStatusOK(aEvent)) 
    1:     return NS_OK;
    1: 
    1:   nsresult rv;
    1:   nsIPresShell *shell = aPresContext->GetPresShell();
    1:   if (!shell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // if we are in Navigator and the click is in a draggable node, we don't want
    1:   // to start selection because we don't want to interfere with a potential
    1:   // drag of said node and steal all its glory.
39668:   PRInt16 isEditor = shell->GetSelectionFlags();
39668:   //weaaak. only the editor can display frame selection not just text and images
    1:   isEditor = isEditor == nsISelectionDisplay::DISPLAY_ALL;
    1: 
    1:   nsInputEvent* keyEvent = (nsInputEvent*)aEvent;
14472:   if (!keyEvent->isAlt) {
    1:     
    1:     for (nsIContent* content = mContent; content;
    1:          content = content->GetParent()) {
14472:       if (nsContentUtils::ContentIsDraggable(content) &&
14472:           !content->IsEditable()) {
    1:         // coordinate stuff is the fix for bug #55921
    1:         if ((mRect - GetPosition()).Contains(
    1:                nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this)))
    1:           return NS_OK;
    1:       }
    1:     }
14472:   }
    1: 
74711:   // check whether style allows selection
74711:   // if not, don't tell selection the mouse event even occurred.  
79445:   bool    selectable;
74711:   PRUint8 selectStyle;
74711:   rv = IsSelectable(&selectable, &selectStyle);
74711:   if (NS_FAILED(rv)) return rv;
74711:   
74711:   // check for select: none
74711:   if (!selectable)
74711:     return NS_OK;
74711: 
74711:   // When implementing NS_STYLE_USER_SELECT_ELEMENT, NS_STYLE_USER_SELECT_ELEMENTS and
74711:   // NS_STYLE_USER_SELECT_TOGGLE, need to change this logic
79445:   bool useFrameSelection = (selectStyle == NS_STYLE_USER_SELECT_TEXT);
74711: 
74711:   // If the mouse is dragged outside the nearest enclosing scrollable area
73455:   // while making a selection, the area will be scrolled. To do this, capture
74711:   // the mouse on the nearest scrollable frame. If there isn't a scrollable
74711:   // frame, or something else is already capturing the mouse, there's no
74711:   // reason to capture.
74711:   if (!nsIPresShell::GetCapturingContent()) {
74711:     nsIFrame* checkFrame = this;
74711:     nsIScrollableFrame *scrollFrame = nsnull;
74711:     while (checkFrame) {
74711:       scrollFrame = do_QueryFrame(checkFrame);
74711:       if (scrollFrame) {
74711:         nsIPresShell::SetCapturingContent(checkFrame->GetContent(), CAPTURE_IGNOREALLOWED);
74711:         break;
74711:       }
74711:       checkFrame = checkFrame->GetParent();
74711:     }
74711:   }
74711: 
74711:   // XXX This is screwy; it really should use the selection frame, not the
74711:   // event frame
74711:   const nsFrameSelection* frameselection = nsnull;
74711:   if (useFrameSelection)
74711:     frameselection = GetConstFrameSelection();
74711:   else
74711:     frameselection = shell->ConstFrameSelection();
74711: 
74711:   if (!frameselection || frameselection->GetDisplaySelection() == nsISelectionController::SELECTION_OFF)
    1:     return NS_OK;//nothing to do we cannot affect selection from here
    1: 
    1:   nsMouseEvent *me = (nsMouseEvent *)aEvent;
    1: 
 6499: #ifdef XP_MACOSX
    1:   if (me->isControl)
84939:     return NS_OK;//short circuit. hard coded for mac due to time restraints.
79445:   bool control = me->isMeta;
20590: #else
79445:   bool control = me->isControl;
    1: #endif
20590: 
74711:   nsRefPtr<nsFrameSelection> fc = const_cast<nsFrameSelection*>(frameselection);
    1:   if (me->clickCount > 1)
    1:   {
 8295:     // These methods aren't const but can't actually delete anything,
 8295:     // so no need for nsWeakFrame.
80486:     fc->SetMouseDownState(true);
80486:     fc->SetMouseDoubleDown(true);
20590:     return HandleMultiplePress(aPresContext, aEvent, aEventStatus, control);
    1:   }
    1: 
26712:   nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
26712:   ContentOffsets offsets = GetContentOffsetsFromPoint(pt);
26712: 
    1:   if (!offsets.content)
    1:     return NS_ERROR_FAILURE;
    1: 
84939:   // On touchables devices, touch the screen is usually a pan action,
84939:   // so let reposition the caret if needed but do not select text
84939:   if (Preferences::GetBool("browser.ignoreNativeFrameTextSelection", false)) {
84939:     return fc->HandleClick(offsets.content, offsets.StartOffset(),
84939:                            offsets.EndOffset(), false, false,
84939:                            offsets.associateWithNext);
84939:   }
84939: 
    1:   // Let Ctrl/Cmd+mouse down do table selection instead of drag initiation
    1:   nsCOMPtr<nsIContent>parentContent;
    1:   PRInt32  contentOffset;
    1:   PRInt32 target;
74711:   rv = GetDataForTableSelection(frameselection, shell, me, getter_AddRefs(parentContent), &contentOffset, &target);
    1:   if (NS_SUCCEEDED(rv) && parentContent)
    1:   {
80486:     fc->SetMouseDownState(true);
74711:     return fc->HandleTableSelection(parentContent, contentOffset, target, me);
74711:   }
74711: 
74711:   fc->SetDelayedCaretData(0);
    1: 
    1:   // Check if any part of this frame is selected, and if the
    1:   // user clicked inside the selected region. If so, we delay
    1:   // starting a new selection since the user may be trying to
    1:   // drag the selected region to some other app.
    1: 
    1:   SelectionDetails *details = 0;
85101:   if (GetContent()->IsSelectionDescendant())
    1:   {
79445:     bool inSelection = false;
74711:     details = frameselection->LookUpSelection(offsets.content, 0,
80486:         offsets.EndOffset(), false);
    1: 
    1:     //
    1:     // If there are any details, check to see if the user clicked
    1:     // within any selected region of the frame.
    1:     //
    1: 
    1:     SelectionDetails *curDetail = details;
    1: 
    1:     while (curDetail)
    1:     {
    1:       //
    1:       // If the user clicked inside a selection, then just
    1:       // return without doing anything. We will handle placing
    1:       // the caret later on when the mouse is released. We ignore
69254:       // the spellcheck, find and url formatting selections.
    1:       //
    1:       if (curDetail->mType != nsISelectionController::SELECTION_SPELLCHECK &&
18761:           curDetail->mType != nsISelectionController::SELECTION_FIND &&
69254:           curDetail->mType != nsISelectionController::SELECTION_URLSECONDARY &&
    1:           curDetail->mStart <= offsets.StartOffset() &&
    1:           offsets.EndOffset() <= curDetail->mEnd)
    1:       {
80486:         inSelection = true;
20685:       }
20685: 
20685:       SelectionDetails *nextDetail = curDetail->mNext;
20685:       delete curDetail;
20685:       curDetail = nextDetail;
20685:     }
20685: 
20685:     if (inSelection) {
80486:       fc->SetMouseDownState(false);
74711:       fc->SetDelayedCaretData(me);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
80486:   fc->SetMouseDownState(true);
    1: 
 8295:   // Do not touch any nsFrame members after this point without adding
 8295:   // weakFrame checks.
74711:   rv = fc->HandleClick(offsets.content, offsets.StartOffset(),
    1:                        offsets.EndOffset(), me->isShift, control,
    1:                        offsets.associateWithNext);
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   if (offsets.offset != offsets.secondaryOffset)
74711:     fc->MaintainSelection();
    1: 
    1:   if (isEditor && !me->isShift &&
    1:       (offsets.EndOffset() - offsets.StartOffset()) == 1)
    1:   {
    1:     // A single node is selected and we aren't extending an existing
    1:     // selection, which means the user clicked directly on an object (either
    1:     // -moz-user-select: all or a non-text node without children).
    1:     // Therefore, disable selection extension during mouse moves.
    1:     // XXX This is a bit hacky; shouldn't editor be able to deal with this?
80486:     fc->SetMouseDownState(false);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: /**
    1:   * Multiple Mouse Press -- line or paragraph selection -- for the frame.
    1:   * Wouldn't it be nice if this didn't have to be hardwired into Frame code?
    1:  */
    1: NS_IMETHODIMP
    1: nsFrame::HandleMultiplePress(nsPresContext* aPresContext, 
    1:                              nsGUIEvent*    aEvent,
20590:                              nsEventStatus* aEventStatus,
79445:                              bool           aControlHeld)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEventStatus);
    1:   if (nsEventStatus_eConsumeNoDefault == *aEventStatus) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Find out whether we're doing line or paragraph selection.
    1:   // If browser.triple_click_selects_paragraph is true, triple-click selects paragraph.
    1:   // Otherwise, triple-click selects line, and quadruple-click selects paragraph
    1:   // (on platforms that support quadruple-click).
    1:   nsSelectionAmount beginAmount, endAmount;
    1:   nsMouseEvent *me = (nsMouseEvent *)aEvent;
    1:   if (!me) return NS_OK;
    1: 
    1:   if (me->clickCount == 4) {
    1:     beginAmount = endAmount = eSelectParagraph;
    1:   } else if (me->clickCount == 3) {
70840:     if (Preferences::GetBool("browser.triple_click_selects_paragraph")) {
    1:       beginAmount = endAmount = eSelectParagraph;
    1:     } else {
    1:       beginAmount = eSelectBeginLine;
    1:       endAmount = eSelectEndLine;
    1:     }
    1:   } else if (me->clickCount == 2) {
    1:     // We only want inline frames; PeekBackwardAndForward dislikes blocks
    1:     beginAmount = endAmount = eSelectWord;
    1:   } else {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
    1:   ContentOffsets offsets = GetContentOffsetsFromPoint(pt);
    1:   if (!offsets.content) return NS_ERROR_FAILURE;
    1: 
    1:   nsIFrame* theFrame;
    1:   PRInt32 offset;
    1:   // Maybe make this a static helper?
 8295:   const nsFrameSelection* frameSelection =
 8295:     PresContext()->GetPresShell()->ConstFrameSelection();
 8295:   theFrame = frameSelection->
    1:     GetFrameForNodeOffset(offsets.content, offsets.offset,
    1:                           nsFrameSelection::HINT(offsets.associateWithNext),
    1:                           &offset);
    1:   if (!theFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
 3233:   nsFrame* frame = static_cast<nsFrame*>(theFrame);
    1: 
    1:   return frame->PeekBackwardAndForward(beginAmount, endAmount,
    1:                                        offsets.offset, aPresContext,
20590:                                        beginAmount != eSelectWord,
20590:                                        aControlHeld);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::PeekBackwardAndForward(nsSelectionAmount aAmountBack,
    1:                                 nsSelectionAmount aAmountForward,
    1:                                 PRInt32 aStartPos,
    1:                                 nsPresContext* aPresContext,
79445:                                 bool aJumpLines,
79445:                                 bool aMultipleSelection)
20590: {
    1:   nsIFrame* baseFrame = this;
    1:   PRInt32 baseOffset = aStartPos;
20590:   nsresult rv;
20590: 
    1:   if (aAmountBack == eSelectWord) {
    1:     // To avoid selecting the previous word when at start of word,
    1:     // first move one character forward.
94058:     nsPeekOffsetStruct pos(eSelectCharacter,
    1:                            eDirNext,
    1:                            aStartPos,
    1:                            0,
    1:                            aJumpLines,
80486:                            true,  //limit on scrolled views
80486:                            false,
80486:                            false);
    1:     rv = PeekOffset(&pos);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       baseFrame = pos.mResultFrame;
    1:       baseOffset = pos.mContentOffset;
    1:     }
    1:   }
20590: 
20590:   // Use peek offset one way then the other:
94058:   nsPeekOffsetStruct startpos(aAmountBack,
    1:                               eDirPrevious,
    1:                               baseOffset,
    1:                               0,
    1:                               aJumpLines,
80486:                               true,  //limit on scrolled views
80486:                               false,
80486:                               false);
    1:   rv = baseFrame->PeekOffset(&startpos);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
94058:   nsPeekOffsetStruct endpos(aAmountForward,
    1:                             eDirNext,
    1:                             aStartPos,
    1:                             0,
    1:                             aJumpLines,
80486:                             true,  //limit on scrolled views
80486:                             false,
80486:                             false);
    1:   rv = PeekOffset(&endpos);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
20590:   // Keep frameSelection alive.
20590:   nsRefPtr<nsFrameSelection> frameSelection = GetFrameSelection();
20590: 
20590:   rv = frameSelection->HandleClick(startpos.mResultContent,
20590:                                    startpos.mContentOffset, startpos.mContentOffset,
80486:                                    false, aMultipleSelection,
20590:                                    nsFrameSelection::HINTRIGHT);
    1:   if (NS_FAILED(rv))
    1:     return rv;
20590: 
20590:   rv = frameSelection->HandleClick(endpos.mResultContent,
20590:                                    endpos.mContentOffset, endpos.mContentOffset,
80486:                                    true, false,
20590:                                    nsFrameSelection::HINTLEFT);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   // maintain selection
 5907:   return frameSelection->MaintainSelection(aAmountBack);
    1: }
    1: 
74711: NS_IMETHODIMP nsFrame::HandleDrag(nsPresContext* aPresContext, 
    1:                                   nsGUIEvent*     aEvent,
    1:                                   nsEventStatus*  aEventStatus)
    1: {
79445:   bool    selectable;
74711:   PRUint8 selectStyle;
74711:   IsSelectable(&selectable, &selectStyle);
74711:   // XXX Do we really need to exclude non-selectable content here?
74711:   // GetContentOffsetsFromPoint can handle it just fine, although some
74711:   // other stuff might not like it.
74711:   if (!selectable)
74711:     return NS_OK;
74711:   if (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF) {
74711:     return NS_OK;
74711:   }
74711:   nsIPresShell *presShell = aPresContext->PresShell();
74711: 
74711:   nsRefPtr<nsFrameSelection> frameselection = GetFrameSelection();
79445:   bool mouseDown = frameselection->GetMouseDownState();
74711:   if (!mouseDown)
74711:     return NS_OK;
74711: 
74711:   frameselection->StopAutoScrollTimer();
    1: 
    1:   // Check if we are dragging in a table cell
    1:   nsCOMPtr<nsIContent> parentContent;
    1:   PRInt32 contentOffset;
    1:   PRInt32 target;
74711:   nsMouseEvent *me = (nsMouseEvent *)aEvent;
74711:   nsresult result;
74711:   result = GetDataForTableSelection(frameselection, presShell, me,
74711:                                     getter_AddRefs(parentContent),
    1:                                     &contentOffset, &target);      
    1: 
35219:   nsWeakFrame weakThis = this;
74711:   if (NS_SUCCEEDED(result) && parentContent) {
74711:     frameselection->HandleTableSelection(parentContent, contentOffset, target, me);
    1:   } else {
    1:     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
74711:     frameselection->HandleDrag(this, pt);
    1:   }
    1: 
35219:   // The frameselection object notifies selection listeners synchronously above
35219:   // which might have killed us.
35219:   if (!weakThis.IsAlive()) {
35219:     return NS_OK;
35219:   }
35219: 
74711:   // get the nearest scrollframe
74711:   nsIFrame* checkFrame = this;
74711:   nsIScrollableFrame *scrollFrame = nsnull;
74711:   while (checkFrame) {
74711:     scrollFrame = do_QueryFrame(checkFrame);
74711:     if (scrollFrame) {
74711:       break;
74711:     }
74711:     checkFrame = checkFrame->GetParent();
74711:   }
74711: 
74711:   if (scrollFrame) {
74711:     nsIFrame* capturingFrame = scrollFrame->GetScrolledFrame();
74711:     if (capturingFrame) {
74711:       nsPoint pt =
74711:         nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, capturingFrame);
74711:       frameselection->StartAutoScrollTimer(capturingFrame, pt, 30);
74711:     }
74711:   }
74711: 
73455:   return NS_OK;
73455: }
73455: 
74711: /**
74711:  * This static method handles part of the nsFrame::HandleRelease in a way
74711:  * which doesn't rely on the nsFrame object to stay alive.
74711:  */
74711: static nsresult
74711: HandleFrameSelection(nsFrameSelection*         aFrameSelection,
74711:                      nsIFrame::ContentOffsets& aOffsets,
79445:                      bool                      aHandleTableSel,
74711:                      PRInt32                   aContentOffsetForTableSel,
74711:                      PRInt32                   aTargetForTableSel,
74711:                      nsIContent*               aParentContentForTableSel,
    1:                      nsGUIEvent*               aEvent,
    1:                      nsEventStatus*            aEventStatus)
    1: {
74711:   if (!aFrameSelection) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
74711: 
74711:   if (nsEventStatus_eConsumeNoDefault != *aEventStatus) {
74711:     if (!aHandleTableSel) {
96303:       if (!aOffsets.content || !aFrameSelection->HasDelayedCaretData()) {
74711:         return NS_ERROR_FAILURE;
74711:       }
    1: 
    1:       // We are doing this to simulate what we would have done on HandlePress.
    1:       // We didn't do it there to give the user an opportunity to drag
    1:       // the text, but since they didn't drag, we want to place the
    1:       // caret.
    1:       // However, we'll use the mouse position from the release, since:
    1:       //  * it's easier
    1:       //  * that's the normal click position to use (although really, in
    1:       //    the normal case, small movements that don't count as a drag
    1:       //    can do selection)
80486:       aFrameSelection->SetMouseDownState(true);
    1: 
74711:       rv = aFrameSelection->HandleClick(aOffsets.content,
74711:                                         aOffsets.StartOffset(),
74711:                                         aOffsets.EndOffset(),
96303:                                         aFrameSelection->IsShiftDownInDelayedCaretData(),
96303:                                         false,
74711:                                         aOffsets.associateWithNext);
74711:       if (NS_FAILED(rv)) {
74711:         return rv;
74711:       }
74711:     } else if (aParentContentForTableSel) {
80486:       aFrameSelection->SetMouseDownState(false);
74711:       rv = aFrameSelection->HandleTableSelection(aParentContentForTableSel,
74711:                                                  aContentOffsetForTableSel,
74711:                                                  aTargetForTableSel,
74711:                                                  (nsMouseEvent *)aEvent);
74711:       if (NS_FAILED(rv)) {
74711:         return rv;
74711:       }
74711:     }
    1:     aFrameSelection->SetDelayedCaretData(0);
74711:   }
74711: 
80486:   aFrameSelection->SetMouseDownState(false);
74711:   aFrameSelection->StopAutoScrollTimer();
74711: 
    1:   return NS_OK;
    1: }
    1: 
74711: NS_IMETHODIMP nsFrame::HandleRelease(nsPresContext* aPresContext,
74711:                                      nsGUIEvent*    aEvent,
74711:                                      nsEventStatus* aEventStatus)
74711: {
74711:   nsIFrame* activeFrame = GetActiveSelectionFrame(aPresContext, this);
74711: 
74711:   nsCOMPtr<nsIContent> captureContent = nsIPresShell::GetCapturingContent();
74711: 
74711:   // We can unconditionally stop capturing because
74711:   // we should never be capturing when the mouse button is up
74711:   nsIPresShell::SetCapturingContent(nsnull, 0);
74711: 
79445:   bool selectionOff =
74711:     (DisplaySelection(aPresContext) == nsISelectionController::SELECTION_OFF);
74711: 
74711:   nsRefPtr<nsFrameSelection> frameselection;
74711:   ContentOffsets offsets;
    1:   nsCOMPtr<nsIContent> parentContent;
    1:   PRInt32 contentOffsetForTableSel = 0;
    1:   PRInt32 targetForTableSel = 0;
79445:   bool handleTableSelection = true;
74711: 
74711:   if (!selectionOff) {
74711:     frameselection = GetFrameSelection();
74711:     if (nsEventStatus_eConsumeNoDefault != *aEventStatus && frameselection) {
74711:       // Check if the frameselection recorded the mouse going down.
74711:       // If not, the user must have clicked in a part of the selection.
74711:       // Place the caret before continuing!
74711: 
79445:       bool mouseDown = frameselection->GetMouseDownState();
96303: 
96303:       if (!mouseDown && frameselection->HasDelayedCaretData() &&
96303:           frameselection->GetClickCountInDelayedCaretData() < 2) {
74711:         nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, this);
74711:         offsets = GetContentOffsetsFromPoint(pt);
80486:         handleTableSelection = false;
74711:       } else {
74711:         GetDataForTableSelection(frameselection, PresContext()->PresShell(),
74711:                                  (nsMouseEvent *)aEvent,
74711:                                  getter_AddRefs(parentContent),
74711:                                  &contentOffsetForTableSel,
74711:                                  &targetForTableSel);
74711:       }
74711:     }
74711:   }
74711: 
74711:   // We might be capturing in some other document and the event just happened to
74711:   // trickle down here. Make sure that document's frame selection is notified.
74711:   // Note, this may cause the current nsFrame object to be deleted, bug 336592.
74711:   nsRefPtr<nsFrameSelection> frameSelection;
74711:   if (activeFrame != this &&
74711:       static_cast<nsFrame*>(activeFrame)->DisplaySelection(activeFrame->PresContext())
74711:         != nsISelectionController::SELECTION_OFF) {
74711:       frameSelection = activeFrame->GetFrameSelection();
74711:   }
74711: 
74711:   // Also check the selection of the capturing content which might be in a
74711:   // different document.
74711:   if (!frameSelection && captureContent) {
74711:     nsIDocument* doc = captureContent->GetCurrentDoc();
74711:     if (doc) {
74711:       nsIPresShell* capturingShell = doc->GetShell();
74711:       if (capturingShell && capturingShell != PresContext()->GetPresShell()) {
74711:         frameSelection = capturingShell->FrameSelection();
74711:       }
74711:     }
74711:   }
74711: 
74711:   if (frameSelection) {
80486:     frameSelection->SetMouseDownState(false);
74711:     frameSelection->StopAutoScrollTimer();
74711:   }
74711: 
74711:   // Do not call any methods of the current object after this point!!!
    1:   // The object is perhaps dead!
74711: 
74711:   return selectionOff
74711:     ? NS_OK
74711:     : HandleFrameSelection(frameselection, offsets, handleTableSelection,
74711:                            contentOffsetForTableSel, targetForTableSel,
74711:                            parentContent, aEvent, aEventStatus);
    1: }
    1: 
15599: struct NS_STACK_CLASS FrameContentRange {
    1:   FrameContentRange(nsIContent* aContent, PRInt32 aStart, PRInt32 aEnd) :
    1:     content(aContent), start(aStart), end(aEnd) { }
    1:   nsCOMPtr<nsIContent> content;
    1:   PRInt32 start;
    1:   PRInt32 end;
    1: };
    1: 
    1: // Retrieve the content offsets of a frame
    1: static FrameContentRange GetRangeForFrame(nsIFrame* aFrame) {
    1:   nsCOMPtr<nsIContent> content, parent;
    1:   content = aFrame->GetContent();
    1:   if (!content) {
    1:     NS_WARNING("Frame has no content");
    1:     return FrameContentRange(nsnull, -1, -1);
    1:   }
    1:   nsIAtom* type = aFrame->GetType();
    1:   if (type == nsGkAtoms::textFrame) {
    1:     PRInt32 offset, offsetEnd;
    1:     aFrame->GetOffsets(offset, offsetEnd);
    1:     return FrameContentRange(content, offset, offsetEnd);
    1:   }
    1:   if (type == nsGkAtoms::brFrame) {
    1:     parent = content->GetParent();
    1:     PRInt32 beginOffset = parent->IndexOf(content);
    1:     return FrameContentRange(parent, beginOffset, beginOffset);
    1:   }
    1:   // Loop to deal with anonymous content, which has no index; this loop
    1:   // probably won't run more than twice under normal conditions
    1:   do {
    1:     parent  = content->GetParent();
    1:     if (parent) {
    1:       PRInt32 beginOffset = parent->IndexOf(content);
    1:       if (beginOffset >= 0)
    1:         return FrameContentRange(parent, beginOffset, beginOffset + 1);
    1:       content = parent;
    1:     }
    1:   } while (parent);
    1: 
    1:   // The root content node must act differently
    1:   return FrameContentRange(content, 0, content->GetChildCount());
    1: }
    1: 
    1: // The FrameTarget represents the closest frame to a point that can be selected
    1: // The frame is the frame represented, frameEdge says whether one end of the
    1: // frame is the result (in which case different handling is needed), and
    1: // afterFrame says which end is repersented if frameEdge is true
    1: struct FrameTarget {
79445:   FrameTarget(nsIFrame* aFrame, bool aFrameEdge, bool aAfterFrame,
79445:               bool aEmptyBlock = false) :
43565:     frame(aFrame), frameEdge(aFrameEdge), afterFrame(aAfterFrame),
43565:     emptyBlock(aEmptyBlock) { }
    1:   static FrameTarget Null() {
80486:     return FrameTarget(nsnull, false, false);
    1:   }
79445:   bool IsNull() {
    1:     return !frame;
    1:   }
    1:   nsIFrame* frame;
79445:   bool frameEdge;
79445:   bool afterFrame;
79445:   bool emptyBlock;
    1: };
    1: 
    1: // See function implementation for information
    1: static FrameTarget GetSelectionClosestFrame(nsIFrame* aFrame, nsPoint aPoint);
    1: 
79445: static bool SelfIsSelectable(nsIFrame* aFrame)
    1: {
    1:   return !(aFrame->IsGeneratedContentFrame() ||
    1:            aFrame->GetStyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_NONE);
    1: }
    1: 
79445: static bool SelectionDescendToKids(nsIFrame* aFrame) {
    1:   PRUint8 style = aFrame->GetStyleUIReset()->mUserSelect;
    1:   nsIFrame* parent = aFrame->GetParent();
    1:   // If we are only near (not directly over) then don't traverse
    1:   // frames with independent selection (e.g. text and list controls)
    1:   // unless we're already inside such a frame (see bug 268497).  Note that this
    1:   // prevents any of the users of this method from entering form controls.
    1:   // XXX We might want some way to allow using the up-arrow to go into a form
    1:   // control, but the focus didn't work right anyway; it'd probably be enough
    1:   // if the left and right arrows could enter textboxes (which I don't believe
    1:   // they can at the moment)
    1:   return !aFrame->IsGeneratedContentFrame() &&
    1:          style != NS_STYLE_USER_SELECT_ALL  &&
    1:          style != NS_STYLE_USER_SELECT_NONE &&
    1:          ((parent->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION) ||
    1:           !(aFrame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION));
    1: }
    1: 
    1: static FrameTarget GetSelectionClosestFrameForChild(nsIFrame* aChild,
    1:                                                     nsPoint aPoint)
    1: {
    1:   nsIFrame* parent = aChild->GetParent();
    1:   if (SelectionDescendToKids(aChild)) {
    1:     nsPoint pt = aPoint - aChild->GetOffsetTo(parent);
    1:     return GetSelectionClosestFrame(aChild, pt);
    1:   }
80486:   return FrameTarget(aChild, false, false);
    1: }
    1: 
    1: // When the cursor needs to be at the beginning of a block, it shouldn't be
    1: // before the first child.  A click on a block whose first child is a block
    1: // should put the cursor in the child.  The cursor shouldn't be between the
    1: // blocks, because that's not where it's expected.
    1: // Note that this method is guaranteed to succeed.
    1: static FrameTarget DrillDownToSelectionFrame(nsIFrame* aFrame,
79445:                                              bool aEndFrame) {
    1:   if (SelectionDescendToKids(aFrame)) {
    1:     nsIFrame* result = nsnull;
77154:     nsIFrame *frame = aFrame->GetFirstPrincipalChild();
    1:     if (!aEndFrame) {
    1:       while (frame && (!SelfIsSelectable(frame) ||
    1:                         frame->IsEmpty()))
    1:         frame = frame->GetNextSibling();
    1:       if (frame)
    1:         result = frame;
    1:     } else {
    1:       // Because the frame tree is singly linked, to find the last frame,
    1:       // we have to iterate through all the frames
    1:       // XXX I have a feeling this could be slow for long blocks, although
    1:       //     I can't find any slowdowns
    1:       while (frame) {
    1:         if (!frame->IsEmpty() && SelfIsSelectable(frame))
    1:           result = frame;
    1:         frame = frame->GetNextSibling();
    1:       }
    1:     }
    1:     if (result)
    1:       return DrillDownToSelectionFrame(result, aEndFrame);
    1:   }
    1:   // If the current frame has no targetable children, target the current frame
80486:   return FrameTarget(aFrame, true, aEndFrame);
    1: }
    1: 
    1: // This method finds the closest valid FrameTarget on a given line; if there is
    1: // no valid FrameTarget on the line, it returns a null FrameTarget
    1: static FrameTarget GetSelectionClosestFrameForLine(
    1:                       nsBlockFrame* aParent,
    1:                       nsBlockFrame::line_iterator aLine,
    1:                       nsPoint aPoint)
    1: {
    1:   nsIFrame *frame = aLine->mFirstChild;
    1:   // Account for end of lines (any iterator from the block is valid)
    1:   if (aLine == aParent->end_lines())
80486:     return DrillDownToSelectionFrame(aParent, true);
    1:   nsIFrame *closestFromLeft = nsnull, *closestFromRight = nsnull;
    1:   nsRect rect = aLine->mBounds;
    1:   nscoord closestLeft = rect.x, closestRight = rect.XMost();
    1:   for (PRInt32 n = aLine->GetChildCount(); n;
    1:        --n, frame = frame->GetNextSibling()) {
    1:     if (!SelfIsSelectable(frame) || frame->IsEmpty())
    1:       continue;
    1:     nsRect frameRect = frame->GetRect();
    1:     if (aPoint.x >= frameRect.x) {
    1:       if (aPoint.x < frameRect.XMost()) {
    1:         return GetSelectionClosestFrameForChild(frame, aPoint);
    1:       }
    1:       if (frameRect.XMost() >= closestLeft) {
    1:         closestFromLeft = frame;
    1:         closestLeft = frameRect.XMost();
    1:       }
    1:     } else {
    1:       if (frameRect.x <= closestRight) {
    1:         closestFromRight = frame;
    1:         closestRight = frameRect.x;
    1:       }
    1:     }
    1:   }
    1:   if (!closestFromLeft && !closestFromRight) {
    1:     // We should only get here if there are no selectable frames on a line
    1:     // XXX Do we need more elaborate handling here?
    1:     return FrameTarget::Null();
    1:   }
    1:   if (closestFromLeft &&
    1:       (!closestFromRight ||
    1:        (abs(aPoint.x - closestLeft) <= abs(aPoint.x - closestRight)))) {
    1:     return GetSelectionClosestFrameForChild(closestFromLeft, aPoint);
    1:   }
    1:   return GetSelectionClosestFrameForChild(closestFromRight, aPoint);
    1: }
    1: 
    1: // This method is for the special handling we do for block frames; they're
    1: // special because they represent paragraphs and because they are organized
    1: // into lines, which have bounds that are not stored elsewhere in the
    1: // frame tree.  Returns a null FrameTarget for frames which are not
43565: // blocks or blocks with no lines except editable one.
    1: static FrameTarget GetSelectionClosestFrameForBlock(nsIFrame* aFrame,
    1:                                                     nsPoint aPoint)
    1: {
15909:   nsBlockFrame* bf = nsLayoutUtils::GetAsBlock(aFrame); // used only for QI
15909:   if (!bf)
    1:     return FrameTarget::Null();
    1: 
    1:   // This code searches for the correct line
    1:   nsBlockFrame::line_iterator firstLine = bf->begin_lines();
    1:   nsBlockFrame::line_iterator end = bf->end_lines();
43565:   if (firstLine == end) {
43565:     nsIContent *blockContent = aFrame->GetContent();
43565:     if (blockContent && blockContent->IsEditable()) {
43565:       // If the frame is ediable empty block, we should return it with empty
43565:       // flag.
80486:       return FrameTarget(aFrame, false, false, true);
43565:     }
    1:     return FrameTarget::Null();
43565:   }
    1:   nsBlockFrame::line_iterator curLine = firstLine;
    1:   nsBlockFrame::line_iterator closestLine = end;
    1:   while (curLine != end) {
    1:     // Check to see if our point lies with the line's Y bounds
    1:     nscoord y = aPoint.y - curLine->mBounds.y;
    1:     nscoord height = curLine->mBounds.height;
    1:     if (y >= 0 && y < height) {
    1:       closestLine = curLine;
    1:       break; // We found the line; stop looking
    1:     }
    1:     if (y < 0)
    1:       break;
    1:     ++curLine;
    1:   }
    1: 
    1:   if (closestLine == end) {
    1:     nsBlockFrame::line_iterator prevLine = curLine.prev();
    1:     nsBlockFrame::line_iterator nextLine = curLine;
    1:     // Avoid empty lines
    1:     while (nextLine != end && nextLine->IsEmpty())
    1:       ++nextLine;
    1:     while (prevLine != end && prevLine->IsEmpty())
    1:       --prevLine;
    1: 
    1:     // This hidden pref dictates whether a point above or below all lines comes
    1:     // up with a line or the beginning or end of the frame; 0 on Windows,
    1:     // 1 on other platforms by default at the writing of this code
    1:     PRInt32 dragOutOfFrame =
70842:       Preferences::GetInt("browser.drag_out_of_frame_style");
    1: 
    1:     if (prevLine == end) {
    1:       if (dragOutOfFrame == 1 || nextLine == end)
80486:         return DrillDownToSelectionFrame(aFrame, false);
    1:       closestLine = nextLine;
    1:     } else if (nextLine == end) {
    1:       if (dragOutOfFrame == 1)
80486:         return DrillDownToSelectionFrame(aFrame, true);
    1:       closestLine = prevLine;
    1:     } else { // Figure out which line is closer
    1:       if (aPoint.y - prevLine->mBounds.YMost() < nextLine->mBounds.y - aPoint.y)
    1:         closestLine = prevLine;
    1:       else
    1:         closestLine = nextLine;
    1:     }
    1:   }
    1: 
    1:   do {
    1:     FrameTarget target = GetSelectionClosestFrameForLine(bf, closestLine,
    1:                                                          aPoint);
    1:     if (!target.IsNull())
    1:       return target;
    1:     ++closestLine;
    1:   } while (closestLine != end);
    1:   // Fall back to just targeting the last targetable place
80486:   return DrillDownToSelectionFrame(aFrame, true);
    1: }
    1: 
    1: // GetSelectionClosestFrame is the helper function that calculates the closest
    1: // frame to the given point.
    1: // It doesn't completely account for offset styles, so needs to be used in
    1: // restricted environments.
    1: // Cannot handle overlapping frames correctly, so it should receive the output
    1: // of GetFrameForPoint
    1: // Guaranteed to return a valid FrameTarget
    1: static FrameTarget GetSelectionClosestFrame(nsIFrame* aFrame, nsPoint aPoint)
    1: {
    1:   {
    1:     // Handle blocks; if the frame isn't a block, the method fails
    1:     FrameTarget target = GetSelectionClosestFrameForBlock(aFrame, aPoint);
    1:     if (!target.IsNull())
    1:       return target;
    1:   }
    1: 
77154:   nsIFrame *kid = aFrame->GetFirstPrincipalChild();
    1: 
    1:   if (kid) {
    1:     // Go through all the child frames to find the closest one
    1: 
    1:     // Large number to force the comparison to succeed
    1:     const nscoord HUGE_DISTANCE = nscoord_MAX;
    1:     nscoord closestXDistance = HUGE_DISTANCE;
    1:     nscoord closestYDistance = HUGE_DISTANCE;
    1:     nsIFrame *closestFrame = nsnull;
    1: 
    1:     for (; kid; kid = kid->GetNextSibling()) {
    1:       if (!SelfIsSelectable(kid) || kid->IsEmpty())
    1:         continue;
    1: 
    1:       nsRect rect = kid->GetRect();
    1: 
    1:       nscoord fromLeft = aPoint.x - rect.x;
    1:       nscoord fromRight = aPoint.x - rect.XMost();
    1: 
    1:       nscoord xDistance;
    1:       if (fromLeft >= 0 && fromRight <= 0) {
    1:         xDistance = 0;
    1:       } else {
32531:         xDistance = NS_MIN(abs(fromLeft), abs(fromRight));
    1:       }
    1: 
    1:       if (xDistance <= closestXDistance)
    1:       {
    1:         if (xDistance < closestXDistance)
    1:           closestYDistance = HUGE_DISTANCE;
    1: 
    1:         nscoord fromTop = aPoint.y - rect.y;
    1:         nscoord fromBottom = aPoint.y - rect.YMost();
    1: 
    1:         nscoord yDistance;
    1:         if (fromTop >= 0 && fromBottom <= 0)
    1:           yDistance = 0;
    1:         else
32531:           yDistance = NS_MIN(abs(fromTop), abs(fromBottom));
    1: 
    1:         if (yDistance < closestYDistance)
    1:         {
    1:           closestXDistance = xDistance;
    1:           closestYDistance = yDistance;
    1:           closestFrame = kid;
    1:         }
    1:       }
    1:     }
    1:     if (closestFrame)
    1:       return GetSelectionClosestFrameForChild(closestFrame, aPoint);
    1:   }
80486:   return FrameTarget(aFrame, false, false);
    1: }
    1: 
    1: nsIFrame::ContentOffsets OffsetsForSingleFrame(nsIFrame* aFrame, nsPoint aPoint)
    1: {
    1:   nsIFrame::ContentOffsets offsets;
    1:   FrameContentRange range = GetRangeForFrame(aFrame);
    1:   offsets.content = range.content;
    1:   // If there are continuations (meaning it's not one rectangle), this is the
    1:   // best this function can do
    1:   if (aFrame->GetNextContinuation() || aFrame->GetPrevContinuation()) {
    1:     offsets.offset = range.start;
    1:     offsets.secondaryOffset = range.end;
80486:     offsets.associateWithNext = true;
    1:     return offsets;
    1:   }
    1: 
    1:   // Figure out whether the offsets should be over, after, or before the frame
    1:   nsRect rect(nsPoint(0, 0), aFrame->GetSize());
    1: 
79445:   bool isBlock = (aFrame->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_INLINE);
79445:   bool isRtl = (aFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL);
    1:   if ((isBlock && rect.y < aPoint.y) ||
    1:       (!isBlock && ((isRtl  && rect.x + rect.width / 2 > aPoint.x) || 
    1:                     (!isRtl && rect.x + rect.width / 2 < aPoint.x)))) {
    1:     offsets.offset = range.end;
    1:     if (rect.Contains(aPoint))
    1:       offsets.secondaryOffset = range.start;
    1:     else
    1:       offsets.secondaryOffset = range.end;
    1:   } else {
    1:     offsets.offset = range.start;
    1:     if (rect.Contains(aPoint))
    1:       offsets.secondaryOffset = range.end;
    1:     else
    1:       offsets.secondaryOffset = range.start;
    1:   }
    1:   offsets.associateWithNext = (offsets.offset == range.start);
    1:   return offsets;
    1: }
    1: 
    1: static nsIFrame* AdjustFrameForSelectionStyles(nsIFrame* aFrame) {
    1:   nsIFrame* adjustedFrame = aFrame;
    1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent())
    1:   {
    1:     // These are the conditions that make all children not able to handle
    1:     // a cursor.
    1:     if (frame->GetStyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_NONE || 
    1:         frame->GetStyleUIReset()->mUserSelect == NS_STYLE_USER_SELECT_ALL || 
    1:         frame->IsGeneratedContentFrame()) {
    1:       adjustedFrame = frame;
    1:     }
    1:   }
    1:   return adjustedFrame;
    1: }
    1:   
    1: 
    1: nsIFrame::ContentOffsets nsIFrame::GetContentOffsetsFromPoint(nsPoint aPoint,
79445:                                                               bool aIgnoreSelectionStyle)
    1: {
    1:   nsIFrame *adjustedFrame;
    1:   if (aIgnoreSelectionStyle) {
    1:     adjustedFrame = this;
    1:   }
    1:   else {
    1:     // This section of code deals with special selection styles.  Note that
    1:     // -moz-none and -moz-all exist, even though they don't need to be explicitly
    1:     // handled.
    1:     // The offset is forced not to end up in generated content; content offsets
    1:     // cannot represent content outside of the document's content tree.
    1: 
    1:     adjustedFrame = AdjustFrameForSelectionStyles(this);
    1: 
    1:     // -moz-user-select: all needs special handling, because clicking on it
    1:     // should lead to the whole frame being selected
    1:     if (adjustedFrame && adjustedFrame->GetStyleUIReset()->mUserSelect ==
    1:         NS_STYLE_USER_SELECT_ALL) {
    1:       return OffsetsForSingleFrame(adjustedFrame, aPoint +
    1:                                    this->GetOffsetTo(adjustedFrame));
    1:     }
    1: 
    1:     // For other cases, try to find a closest frame starting from the parent of
    1:     // the unselectable frame
    1:     if (adjustedFrame != this)
    1:       adjustedFrame = adjustedFrame->GetParent();
    1:   }
    1: 
    1:   nsPoint adjustedPoint = aPoint + this->GetOffsetTo(adjustedFrame);
    1: 
    1:   FrameTarget closest = GetSelectionClosestFrame(adjustedFrame, adjustedPoint);
    1: 
43565:   if (closest.emptyBlock) {
43565:     ContentOffsets offsets;
43565:     NS_ASSERTION(closest.frame,
43565:                  "closest.frame must not be null when it's empty");
43565:     offsets.content = closest.frame->GetContent();
43565:     offsets.offset = 0;
43565:     offsets.secondaryOffset = 0;
80486:     offsets.associateWithNext = true;
43565:     return offsets;
43565:   }
43565: 
    1:   // If the correct offset is at one end of a frame, use offset-based
    1:   // calculation method
    1:   if (closest.frameEdge) {
    1:     ContentOffsets offsets;
    1:     FrameContentRange range = GetRangeForFrame(closest.frame);
    1:     offsets.content = range.content;
    1:     if (closest.afterFrame)
    1:       offsets.offset = range.end;
    1:     else
    1:       offsets.offset = range.start;
    1:     offsets.secondaryOffset = offsets.offset;
    1:     offsets.associateWithNext = (offsets.offset == range.start);
    1:     return offsets;
    1:   }
    1:   nsPoint pt = aPoint - closest.frame->GetOffsetTo(this);
 3233:   return static_cast<nsFrame*>(closest.frame)->CalcContentOffsetsFromFramePoint(pt);
    1: 
    1:   // XXX should I add some kind of offset standardization?
    1:   // consider <b>xxxxx</b><i>zzzzz</i>; should any click between the last
    1:   // x and first z put the cursor in the same logical position in addition
    1:   // to the same visual position?
    1: }
    1: 
    1: nsIFrame::ContentOffsets nsFrame::CalcContentOffsetsFromFramePoint(nsPoint aPoint)
    1: {
    1:   return OffsetsForSingleFrame(this, aPoint);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetCursor(const nsPoint& aPoint,
    1:                    nsIFrame::Cursor& aCursor)
    1: {
    1:   FillCursorInformationFromStyle(GetStyleUserInterface(), aCursor);
    1:   if (NS_STYLE_CURSOR_AUTO == aCursor.mCursor) {
    1:     aCursor.mCursor = NS_STYLE_CURSOR_DEFAULT;
    1:   }
    1: 
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Resize and incremental reflow
    1: 
    1: /* virtual */ void
    1: nsFrame::MarkIntrinsicWidthsDirty()
    1: {
    1:   // This version is meant only for what used to be box-to-block adaptors.
    1:   // It should not be called by other derived classes.
    1:   if (IsBoxWrapped()) {
    1:     nsBoxLayoutMetrics *metrics = BoxMetrics();
    1: 
    1:     SizeNeedsRecalc(metrics->mPrefSize);
    1:     SizeNeedsRecalc(metrics->mMinSize);
    1:     SizeNeedsRecalc(metrics->mMaxSize);
    1:     SizeNeedsRecalc(metrics->mBlockPrefSize);
    1:     SizeNeedsRecalc(metrics->mBlockMinSize);
    1:     CoordNeedsRecalc(metrics->mFlex);
    1:     CoordNeedsRecalc(metrics->mAscent);
    1:   }
95534: 
95534:   if (GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
95534:     nsFontInflationData::MarkFontInflationDataTextDirty(this);
95534:   }
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1:   DISPLAY_MIN_WIDTH(this, result);
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1:   DISPLAY_PREF_WIDTH(this, result);
    1:   return result;
    1: }
    1: 
    1: /* virtual */ void
68481: nsFrame::AddInlineMinWidth(nsRenderingContext *aRenderingContext,
    1:                            nsIFrame::InlineMinWidthData *aData)
    1: {
    1:   NS_ASSERTION(GetParent(), "Must have a parent if we get here!");
79445:   bool canBreak = !CanContinueTextRun() &&
    1:     GetParent()->GetStyleText()->WhiteSpaceCanWrap();
    1:   
    1:   if (canBreak)
 2668:     aData->OptionallyBreak(aRenderingContext);
    1:   aData->trailingWhitespace = 0;
80486:   aData->skipWhitespace = false;
    1:   aData->trailingTextFrame = nsnull;
    1:   aData->currentLine += nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
    1:                             this, nsLayoutUtils::MIN_WIDTH);
80486:   aData->atStartOfLine = false;
    1:   if (canBreak)
 2668:     aData->OptionallyBreak(aRenderingContext);
    1: }
    1: 
    1: /* virtual */ void
68481: nsFrame::AddInlinePrefWidth(nsRenderingContext *aRenderingContext,
    1:                             nsIFrame::InlinePrefWidthData *aData)
    1: {
    1:   aData->trailingWhitespace = 0;
80486:   aData->skipWhitespace = false;
 6254:   nscoord myPref = nsLayoutUtils::IntrinsicForContainer(aRenderingContext, 
    1:                        this, nsLayoutUtils::PREF_WIDTH);
 6254:   aData->currentLine = NSCoordSaturatingAdd(aData->currentLine, myPref);
    1: }
    1: 
    1: void
68481: nsIFrame::InlineMinWidthData::ForceBreak(nsRenderingContext *aRenderingContext)
    1: {
    1:   currentLine -= trailingWhitespace;
32531:   prevLines = NS_MAX(prevLines, currentLine);
    1:   currentLine = trailingWhitespace = 0;
    1: 
24551:   for (PRUint32 i = 0, i_end = floats.Length(); i != i_end; ++i) {
24551:     nsIFrame *floatFrame = floats[i];
    1:     nscoord float_min =
    1:       nsLayoutUtils::IntrinsicForContainer(aRenderingContext, floatFrame,
    1:                                            nsLayoutUtils::MIN_WIDTH);
    1:     if (float_min > prevLines)
    1:       prevLines = float_min;
    1:   }
    1:   floats.Clear();
    1:   trailingTextFrame = nsnull;
80486:   skipWhitespace = true;
    1: }
    1: 
    1: void
68481: nsIFrame::InlineMinWidthData::OptionallyBreak(nsRenderingContext *aRenderingContext,
64410:                                               nscoord aHyphenWidth)
 2668: {
 2668:   trailingTextFrame = nsnull;
 2668: 
 2668:   // If we can fit more content into a smaller width by staying on this
 2668:   // line (because we're still at a negative offset due to negative
 2668:   // text-indent or negative margin), don't break.  Otherwise, do the
 2668:   // same as ForceBreak.  it doesn't really matter when we accumulate
 2668:   // floats.
64410:   if (currentLine + aHyphenWidth < 0 || atStartOfLine)
 2668:     return;
64410:   currentLine += aHyphenWidth;
 2668:   ForceBreak(aRenderingContext);
 2668: }
 2668: 
 2668: void
68481: nsIFrame::InlinePrefWidthData::ForceBreak(nsRenderingContext *aRenderingContext)
    1: {
24551:   if (floats.Length() != 0) {
    1:             // preferred widths accumulated for floats that have already
    1:             // been cleared past
    1:     nscoord floats_done = 0,
    1:             // preferred widths accumulated for floats that have not yet
    1:             // been cleared past
    1:             floats_cur_left = 0,
    1:             floats_cur_right = 0;
    1: 
24551:     for (PRUint32 i = 0, i_end = floats.Length(); i != i_end; ++i) {
24551:       nsIFrame *floatFrame = floats[i];
    1:       const nsStyleDisplay *floatDisp = floatFrame->GetStyleDisplay();
    1:       if (floatDisp->mBreakType == NS_STYLE_CLEAR_LEFT ||
    1:           floatDisp->mBreakType == NS_STYLE_CLEAR_RIGHT ||
    1:           floatDisp->mBreakType == NS_STYLE_CLEAR_LEFT_AND_RIGHT) {
12743:         nscoord floats_cur = NSCoordSaturatingAdd(floats_cur_left,
12743:                                                   floats_cur_right);
    1:         if (floats_cur > floats_done)
    1:           floats_done = floats_cur;
    1:         if (floatDisp->mBreakType != NS_STYLE_CLEAR_RIGHT)
    1:           floats_cur_left = 0;
    1:         if (floatDisp->mBreakType != NS_STYLE_CLEAR_LEFT)
    1:           floats_cur_right = 0;
    1:       }
    1: 
    1:       nscoord &floats_cur = floatDisp->mFloats == NS_STYLE_FLOAT_LEFT
    1:                               ? floats_cur_left : floats_cur_right;
13553:       nscoord floatWidth =
    1:           nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
12743:                                                floatFrame,
13553:                                                nsLayoutUtils::PREF_WIDTH);
13553:       // Negative-width floats don't change the available space so they
13553:       // shouldn't change our intrinsic line width either.
13553:       floats_cur =
32531:         NSCoordSaturatingAdd(floats_cur, NS_MAX(0, floatWidth));
12743:     }
12743: 
12743:     nscoord floats_cur =
12743:       NSCoordSaturatingAdd(floats_cur_left, floats_cur_right);
    1:     if (floats_cur > floats_done)
    1:       floats_done = floats_cur;
    1: 
 7750:     currentLine = NSCoordSaturatingAdd(currentLine, floats_done);
    1: 
    1:     floats.Clear();
    1:   }
    1: 
12743:   currentLine =
12743:     NSCoordSaturatingSubtract(currentLine, trailingWhitespace, nscoord_MAX);
32531:   prevLines = NS_MAX(prevLines, currentLine);
    1:   currentLine = trailingWhitespace = 0;
80486:   skipWhitespace = true;
    1: }
    1: 
    1: static void
    1: AddCoord(const nsStyleCoord& aStyle,
68481:          nsRenderingContext* aRenderingContext,
    1:          nsIFrame* aFrame,
52283:          nscoord* aCoord, float* aPercent,
79445:          bool aClampNegativeToZero)
    1: {
52481:   switch (aStyle.GetUnit()) {
52481:     case eStyleUnit_Coord: {
52481:       NS_ASSERTION(!aClampNegativeToZero || aStyle.GetCoordValue() >= 0,
52481:                    "unexpected negative value");
52481:       *aCoord += aStyle.GetCoordValue();
51776:       return;
51776:     }
52481:     case eStyleUnit_Percent: {
52481:       NS_ASSERTION(!aClampNegativeToZero || aStyle.GetPercentValue() >= 0.0f,
52481:                    "unexpected negative value");
52481:       *aPercent += aStyle.GetPercentValue();
52481:       return;
52481:     }
52481:     case eStyleUnit_Calc: {
52481:       const nsStyleCoord::Calc *calc = aStyle.GetCalcValue();
52283:       if (aClampNegativeToZero) {
52283:         // This is far from ideal when one is negative and one is positive.
52481:         *aCoord += NS_MAX(calc->mLength, 0);
52481:         *aPercent += NS_MAX(calc->mPercent, 0.0f);
52481:       } else {
52481:         *aCoord += calc->mLength;
52481:         *aPercent += calc->mPercent;
52481:       }
52481:       return;
52481:     }
52481:     default: {
52481:       return;
52481:     }
52481:   }
    1: }
    1: 
    1: /* virtual */ nsIFrame::IntrinsicWidthOffsetData
68481: nsFrame::IntrinsicWidthOffsets(nsRenderingContext* aRenderingContext)
    1: {
    1:   IntrinsicWidthOffsetData result;
    1: 
    1:   const nsStyleMargin *styleMargin = GetStyleMargin();
12630:   AddCoord(styleMargin->mMargin.GetLeft(), aRenderingContext, this,
80486:            &result.hMargin, &result.hPctMargin, false);
12630:   AddCoord(styleMargin->mMargin.GetRight(), aRenderingContext, this,
80486:            &result.hMargin, &result.hPctMargin, false);
    1: 
    1:   const nsStylePadding *stylePadding = GetStylePadding();
12630:   AddCoord(stylePadding->mPadding.GetLeft(), aRenderingContext, this,
80486:            &result.hPadding, &result.hPctPadding, true);
12630:   AddCoord(stylePadding->mPadding.GetRight(), aRenderingContext, this,
80486:            &result.hPadding, &result.hPctPadding, true);
    1: 
    1:   const nsStyleBorder *styleBorder = GetStyleBorder();
15992:   result.hBorder += styleBorder->GetActualBorderWidth(NS_SIDE_LEFT);
15992:   result.hBorder += styleBorder->GetActualBorderWidth(NS_SIDE_RIGHT);
    1: 
    1:   const nsStyleDisplay *disp = GetStyleDisplay();
    1:   if (IsThemed(disp)) {
  238:     nsPresContext *presContext = PresContext();
    1: 
23738:     nsIntMargin border;
    1:     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
    1:                                              this, disp->mAppearance,
    1:                                              &border);
    1:     result.hBorder = presContext->DevPixelsToAppUnits(border.LeftRight());
    1: 
23738:     nsIntMargin padding;
    1:     if (presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
    1:                                                   this, disp->mAppearance,
    1:                                                   &padding)) {
    1:       result.hPadding = presContext->DevPixelsToAppUnits(padding.LeftRight());
    1:       result.hPctPadding = 0;
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
 8142: /* virtual */ nsIFrame::IntrinsicSize
 8142: nsFrame::GetIntrinsicSize()
 8142: {
 8142:   return IntrinsicSize(); // default is width/height set to eStyleUnit_None
 8142: }
 8142: 
 2301: /* virtual */ nsSize
 2301: nsFrame::GetIntrinsicRatio()
 2301: {
 2301:   return nsSize(0, 0);
 2301: }
 2301: 
    1: /* virtual */ nsSize
68481: nsFrame::ComputeSize(nsRenderingContext *aRenderingContext,
    1:                      nsSize aCBSize, nscoord aAvailableWidth,
    1:                      nsSize aMargin, nsSize aBorder, nsSize aPadding,
93353:                      PRUint32 aFlags)
    1: {
    1:   nsSize result = ComputeAutoSize(aRenderingContext, aCBSize, aAvailableWidth,
93353:                                   aMargin, aBorder, aPadding,
93353:                                   aFlags & eShrinkWrap);
    1:   nsSize boxSizingAdjust(0,0);
    1:   const nsStylePosition *stylePos = GetStylePosition();
    1: 
    1:   switch (stylePos->mBoxSizing) {
    1:     case NS_STYLE_BOX_SIZING_BORDER:
    1:       boxSizingAdjust += aBorder;
    1:       // fall through
    1:     case NS_STYLE_BOX_SIZING_PADDING:
    1:       boxSizingAdjust += aPadding;
    1:   }
 1068:   nscoord boxSizingToMarginEdgeWidth =
 1068:     aMargin.width + aBorder.width + aPadding.width - boxSizingAdjust.width;
    1: 
    1:   // Compute width
    1: 
    1:   if (stylePos->mWidth.GetUnit() != eStyleUnit_Auto) {
    1:     result.width =
 1068:       nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
 1068:         aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
 1068:         stylePos->mWidth);
    1:   }
    1: 
 1363:   if (stylePos->mMaxWidth.GetUnit() != eStyleUnit_None) {
    1:     nscoord maxWidth =
 1068:       nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
 1068:         aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
 1068:         stylePos->mMaxWidth);
    1:     if (maxWidth < result.width)
    1:       result.width = maxWidth;
    1:   }
    1: 
    1:   nscoord minWidth =
 1068:     nsLayoutUtils::ComputeWidthValue(aRenderingContext, this,
 1068:       aCBSize.width, boxSizingAdjust.width, boxSizingToMarginEdgeWidth,
 1068:       stylePos->mMinWidth);
    1:   if (minWidth > result.width)
    1:     result.width = minWidth;
    1: 
    1:   // Compute height
    1: 
51411:   if (!nsLayoutUtils::IsAutoHeight(stylePos->mHeight, aCBSize.height)) {
    1:     result.height =
51406:       nsLayoutUtils::ComputeHeightValue(aCBSize.height, stylePos->mHeight) -
    1:       boxSizingAdjust.height;
    1:   }
    1: 
    1:   if (result.height != NS_UNCONSTRAINEDSIZE) {
51411:     if (!nsLayoutUtils::IsAutoHeight(stylePos->mMaxHeight, aCBSize.height)) {
    1:       nscoord maxHeight =
51406:         nsLayoutUtils::ComputeHeightValue(aCBSize.height, stylePos->mMaxHeight) -
    1:         boxSizingAdjust.height;
    1:       if (maxHeight < result.height)
    1:         result.height = maxHeight;
    1:     }
    1: 
51411:     if (!nsLayoutUtils::IsAutoHeight(stylePos->mMinHeight, aCBSize.height)) {
    1:       nscoord minHeight =
51406:         nsLayoutUtils::ComputeHeightValue(aCBSize.height, stylePos->mMinHeight) -
    1:         boxSizingAdjust.height;
    1:       if (minHeight > result.height)
    1:         result.height = minHeight;
    1:     }
    1:   }
    1: 
    1:   const nsStyleDisplay *disp = GetStyleDisplay();
    1:   if (IsThemed(disp)) {
23738:     nsIntSize widget(0, 0);
79445:     bool canOverride = true;
  238:     nsPresContext *presContext = PresContext();
    1:     presContext->GetTheme()->
    1:       GetMinimumWidgetSize(aRenderingContext, this, disp->mAppearance,
23738:                            &widget, &canOverride);
23738: 
23738:     nsSize size;
23738:     size.width = presContext->DevPixelsToAppUnits(widget.width);
23738:     size.height = presContext->DevPixelsToAppUnits(widget.height);
    1: 
    1:     // GMWS() returns border-box; we need content-box
    1:     size.width -= aBorder.width + aPadding.width;
    1:     size.height -= aBorder.height + aPadding.height;
    1: 
    1:     if (size.height > result.height || !canOverride)
    1:       result.height = size.height;
    1:     if (size.width > result.width || !canOverride)
    1:       result.width = size.width;
    1:   }
    1: 
    1:   if (result.width < 0)
    1:     result.width = 0;
    1: 
    1:   if (result.height < 0)
    1:     result.height = 0;
    1: 
    1:   return result;
    1: }
    1: 
 6862: nsRect
 6862: nsIFrame::ComputeTightBounds(gfxContext* aContext) const
 6862: {
55035:   return GetVisualOverflowRect();
 6862: }
 6862: 
 6862: nsRect
 6862: nsFrame::ComputeSimpleTightBounds(gfxContext* aContext) const
 6862: {
 6862:   if (GetStyleOutline()->GetOutlineStyle() != NS_STYLE_BORDER_STYLE_NONE ||
95646:       GetStyleBorder()->HasBorder() || !GetStyleBackground()->IsTransparent() ||
 6862:       GetStyleDisplay()->mAppearance) {
 6862:     // Not necessarily tight, due to clipping, negative
 6862:     // outline-offset, and lots of other issues, but that's OK
55035:     return GetVisualOverflowRect();
 6862:   }
 6862: 
 6862:   nsRect r(0, 0, 0, 0);
77153:   ChildListIterator lists(this);
77153:   for (; !lists.IsDone(); lists.Next()) {
77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:       nsIFrame* child = childFrames.get();
 6862:       r.UnionRect(r, child->ComputeTightBounds(aContext) + child->GetPosition());
77153:     }
77153:   }
 6862:   return r;
 6862: }
 6862: 
    1: /* virtual */ nsSize
68481: nsFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
    1:                          nsSize aCBSize, nscoord aAvailableWidth,
    1:                          nsSize aMargin, nsSize aBorder, nsSize aPadding,
79445:                          bool aShrinkWrap)
    1: {
    1:   // Use basic shrink-wrapping as a default implementation.
    1:   nsSize result(0xdeadbeef, NS_UNCONSTRAINEDSIZE);
    1: 
    1:   // don't bother setting it if the result won't be used
    1:   if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
    1:     nscoord availBased = aAvailableWidth - aMargin.width - aBorder.width -
    1:                          aPadding.width;
    1:     result.width = ShrinkWidthToFit(aRenderingContext, availBased);
    1:   }
    1:   return result;
    1: }
    1: 
    1: nscoord
68481: nsFrame::ShrinkWidthToFit(nsRenderingContext *aRenderingContext,
    1:                           nscoord aWidthInCB)
    1: {
88122:   // If we're a container for font size inflation, then shrink
88122:   // wrapping inside of us should not apply font size inflation.
96285:   AutoMaybeDisableFontInflation an(this);
88122: 
    1:   nscoord result;
    1:   nscoord minWidth = GetMinWidth(aRenderingContext);
    1:   if (minWidth > aWidthInCB) {
    1:     result = minWidth;
    1:   } else {
    1:     nscoord prefWidth = GetPrefWidth(aRenderingContext);
    1:     if (prefWidth > aWidthInCB) {
    1:       result = aWidthInCB;
    1:     } else {
    1:       result = prefWidth;
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::WillReflow(nsPresContext* aPresContext)
    1: {
    1: #ifdef DEBUG_dbaron_off
    1:   // bug 81268
    1:   NS_ASSERTION(!(mState & NS_FRAME_IN_REFLOW),
    1:                "nsFrame::WillReflow: frame is already in reflow");
    1: #endif
    1: 
    1:   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
    1:                      ("WillReflow: oldState=%x", mState));
    1:   mState |= NS_FRAME_IN_REFLOW;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::DidReflow(nsPresContext*           aPresContext,
    1:                    const nsHTMLReflowState*  aReflowState,
    1:                    nsDidReflowStatus         aStatus)
    1: {
    1:   NS_FRAME_TRACE_MSG(NS_FRAME_TRACE_CALLS,
    1:                      ("nsFrame::DidReflow: aStatus=%d", aStatus));
79483: 
    1:   if (NS_FRAME_REFLOW_FINISHED == aStatus) {
    1:     mState &= ~(NS_FRAME_IN_REFLOW | NS_FRAME_FIRST_REFLOW | NS_FRAME_IS_DIRTY |
    1:                 NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   }
    1: 
 7370:   // Notify the percent height observer if there is a percent height.
 7370:   // The observer may be able to initiate another reflow with a computed
 7370:   // height. This happens in the case where a table cell has no computed
 7370:   // height but can fabricate one when the cell height is known.
    1:   if (aReflowState && aReflowState->mPercentHeightObserver &&
51406:       !GetPrevInFlow()) {
51406:     const nsStyleCoord &height = aReflowState->mStylePosition->mHeight;
51406:     if (height.HasPercent()) {
    1:       aReflowState->mPercentHeightObserver->NotifyPercentHeight(*aReflowState);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
79483: void
79483: nsFrame::FinishReflowWithAbsoluteFrames(nsPresContext*           aPresContext,
79483:                                         nsHTMLReflowMetrics&     aDesiredSize,
79483:                                         const nsHTMLReflowState& aReflowState,
96502:                                         nsReflowStatus&          aStatus)
96502: {
96502:   ReflowAbsoluteFrames(aPresContext, aDesiredSize, aReflowState, aStatus);
79483: 
79483:   FinishAndStoreOverflow(&aDesiredSize);
79483: }
79483: 
79483: void
79483: nsFrame::DestroyAbsoluteFrames(nsIFrame* aDestructRoot)
79483: {
79483:   if (IsAbsoluteContainer()) {
79483:     GetAbsoluteContainingBlock()->DestroyFrames(this, aDestructRoot);
79483:   }
79483: }
79483: 
79483: void
79483: nsFrame::ReflowAbsoluteFrames(nsPresContext*           aPresContext,
79483:                               nsHTMLReflowMetrics&     aDesiredSize,
79483:                               const nsHTMLReflowState& aReflowState,
96502:                               nsReflowStatus&          aStatus)
79483: {
79483:   if (HasAbsolutelyPositionedChildren()) {
79483:     nsAbsoluteContainingBlock* absoluteContainer = GetAbsoluteContainingBlock();
79483: 
79483:     // Let the absolutely positioned container reflow any absolutely positioned
79483:     // child frames that need to be reflowed
79483: 
79483:     // The containing block for the abs pos kids is formed by our padding edge.
79483:     nsMargin computedBorder =
79483:       aReflowState.mComputedBorderPadding - aReflowState.mComputedPadding;
79483:     nscoord containingBlockWidth =
79483:       aDesiredSize.width - computedBorder.LeftRight();
79483:     nscoord containingBlockHeight =
79483:       aDesiredSize.height - computedBorder.TopBottom();
79483: 
79483:     nsContainerFrame* container = do_QueryFrame(this);
79483:     NS_ASSERTION(container, "Abs-pos children only supported on container frames for now");
79483: 
79483:     absoluteContainer->Reflow(container, aPresContext, aReflowState, aStatus,
79483:                               containingBlockWidth, containingBlockHeight,
96502:                               true, true, true, // XXX could be optimized
79483:                               &aDesiredSize.mOverflowAreas);
79483:   }
79483: }
79483: 
79445: /* virtual */ bool
    1: nsFrame::CanContinueTextRun() const
    1: {
    1:   // By default, a frame will *not* allow a text run to be continued
    1:   // through it.
80486:   return false;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::Reflow(nsPresContext*          aPresContext,
    1:                 nsHTMLReflowMetrics&     aDesiredSize,
    1:                 const nsHTMLReflowState& aReflowState,
    1:                 nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsFrame");
    1:   aDesiredSize.width = 0;
    1:   aDesiredSize.height = 0;
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
31131: nsFrame::CharacterDataChanged(CharacterDataChangeInfo* aInfo)
    1: {
    1:   NS_NOTREACHED("should only be called for text frames");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::AttributeChanged(PRInt32         aNameSpaceID,
    1:                           nsIAtom*        aAttribute,
    1:                           PRInt32         aModType)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // Flow member functions
    1: 
    1: nsSplittableType
    1: nsFrame::GetSplittableType() const
    1: {
    1:   return NS_FRAME_NOT_SPLITTABLE;
    1: }
    1: 
    1: nsIFrame* nsFrame::GetPrevContinuation() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::SetPrevContinuation(nsIFrame* aPrevContinuation)
    1: {
    1:   // Ignore harmless requests to set it to NULL
    1:   if (aPrevContinuation) {
    1:     NS_ERROR("not splittable");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsIFrame* nsFrame::GetNextContinuation() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::SetNextContinuation(nsIFrame*)
    1: {
    1:   NS_ERROR("not splittable");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: nsIFrame* nsFrame::GetPrevInFlowVirtual() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::SetPrevInFlow(nsIFrame* aPrevInFlow)
    1: {
    1:   // Ignore harmless requests to set it to NULL
    1:   if (aPrevInFlow) {
    1:     NS_ERROR("not splittable");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIFrame* nsFrame::GetNextInFlowVirtual() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP nsFrame::SetNextInFlow(nsIFrame*)
    1: {
    1:   NS_ERROR("not splittable");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
10780: nsIFrame* nsIFrame::GetTailContinuation()
10780: {
10780:   nsIFrame* frame = this;
10780:   while (frame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
10780:     frame = frame->GetPrevContinuation();
10780:     NS_ASSERTION(frame, "first continuation can't be overflow container");
10780:   }
10780:   for (nsIFrame* next = frame->GetNextContinuation();
10780:        next && !(next->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER);
10780:        next = frame->GetNextContinuation())  {
10780:     frame = next;
10780:   }
10780:   NS_POSTCONDITION(frame, "illegal state in continuation chain.");
10780:   return frame;
10780: }
10780: 
39965: NS_DECLARE_FRAME_PROPERTY(ViewProperty, nsnull)
39965: 
    1: // Associated view object
    1: nsIView*
    1: nsIFrame::GetView() const
    1: {
    1:   // Check the frame state bit and see if the frame has a view
    1:   if (!(GetStateBits() & NS_FRAME_HAS_VIEW))
    1:     return nsnull;
    1: 
    1:   // Check for a property on the frame
39965:   void* value = Properties().Get(ViewProperty());
    1:   NS_ASSERTION(value, "frame state bit was set but frame has no view");
 3233:   return static_cast<nsIView*>(value);
    1: }
    1: 
    1: /* virtual */ nsIView*
    1: nsIFrame::GetViewExternal() const
    1: {
    1:   return GetView();
    1: }
    1: 
    1: nsresult
    1: nsIFrame::SetView(nsIView* aView)
    1: {
    1:   if (aView) {
82566:     aView->SetFrame(this);
    1: 
    1:     // Set a property on the frame
39965:     Properties().Set(ViewProperty(), aView);
    1: 
    1:     // Set the frame state bit that says the frame has a view
    1:     AddStateBits(NS_FRAME_HAS_VIEW);
    1: 
    1:     // Let all of the ancestors know they have a descendant with a view.
    1:     for (nsIFrame* f = GetParent();
    1:          f && !(f->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW);
    1:          f = f->GetParent())
    1:       f->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIFrame* nsIFrame::GetAncestorWithViewExternal() const
    1: {
    1:   return GetAncestorWithView();
    1: }
    1: 
    1: // Find the first geometric parent that has a view
    1: nsIFrame* nsIFrame::GetAncestorWithView() const
    1: {
    1:   for (nsIFrame* f = mParent; nsnull != f; f = f->GetParent()) {
    1:     if (f->HasView()) {
    1:       return f;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: // virtual
    1: nsPoint nsIFrame::GetOffsetToExternal(const nsIFrame* aOther) const
    1: {
    1:   return GetOffsetTo(aOther);
    1: }
    1: 
    1: nsPoint nsIFrame::GetOffsetTo(const nsIFrame* aOther) const
    1: {
    1:   NS_PRECONDITION(aOther,
    1:                   "Must have frame for destination coordinate system!");
47895: 
47902:   NS_ASSERTION(PresContext() == aOther->PresContext(),
47902:                "GetOffsetTo called on frames in different documents");
47895: 
    1:   nsPoint offset(0, 0);
    1:   const nsIFrame* f;
47895:   for (f = this; f != aOther && f; f = f->GetParent()) {
    1:     offset += f->GetPosition();
    1:   }
    1: 
    1:   if (f != aOther) {
18884:     // Looks like aOther wasn't an ancestor of |this|.  So now we have
47895:     // the root-frame-relative position of |this| in |offset|.  Convert back
18884:     // to the coordinates of aOther
18884:     while (aOther) {
18884:       offset -= aOther->GetPosition();
47895:       aOther = aOther->GetParent();
47895:     }
47895:   }
47895: 
47895:   return offset;
47895: }
47895: 
47895: nsPoint nsIFrame::GetOffsetToCrossDoc(const nsIFrame* aOther) const
47895: {
47895:   return GetOffsetToCrossDoc(aOther, PresContext()->AppUnitsPerDevPixel());
47895: }
47895: 
47895: nsPoint
47895: nsIFrame::GetOffsetToCrossDoc(const nsIFrame* aOther, const PRInt32 aAPD) const
47895: {
47895:   NS_PRECONDITION(aOther,
47895:                   "Must have frame for destination coordinate system!");
47895:   NS_ASSERTION(PresContext()->GetRootPresContext() ==
47895:                  aOther->PresContext()->GetRootPresContext(),
47895:                "trying to get the offset between frames in different document "
47895:                "hierarchies?");
71107:   if (PresContext()->GetRootPresContext() !=
71107:         aOther->PresContext()->GetRootPresContext()) {
71107:     // crash right away, we are almost certainly going to crash anyway.
79845:     NS_RUNTIMEABORT("trying to get the offset between frames in different "
79845:                     "document hierarchies?");
71107:   }
47895: 
47895:   const nsIFrame* root = nsnull;
47895:   // offset will hold the final offset
47895:   // docOffset holds the currently accumulated offset at the current APD, it
47895:   // will be converted and added to offset when the current APD changes.
47895:   nsPoint offset(0, 0), docOffset(0, 0);
47895:   const nsIFrame* f = this;
47895:   PRInt32 currAPD = PresContext()->AppUnitsPerDevPixel();
47895:   while (f && f != aOther) {
47895:     docOffset += f->GetPosition();
47895:     nsIFrame* parent = f->GetParent();
47895:     if (parent) {
47895:       f = parent;
47895:     } else {
47895:       nsPoint newOffset(0, 0);
47895:       root = f;
47895:       f = nsLayoutUtils::GetCrossDocParentFrame(f, &newOffset);
47895:       PRInt32 newAPD = f ? f->PresContext()->AppUnitsPerDevPixel() : 0;
47895:       if (!f || newAPD != currAPD) {
47895:         // Convert docOffset to the right APD and add it to offset.
47895:         offset += docOffset.ConvertAppUnits(currAPD, aAPD);
47895:         docOffset.x = docOffset.y = 0;
47895:       }
47895:       currAPD = newAPD;
47895:       docOffset += newOffset;
47895:     }
47895:   }
47895:   if (f == aOther) {
47895:     offset += docOffset.ConvertAppUnits(currAPD, aAPD);
47895:   } else {
47895:     // Looks like aOther wasn't an ancestor of |this|.  So now we have
47895:     // the root-document-relative position of |this| in |offset|. Subtract the
47895:     // root-document-relative position of |aOther| from |offset|.
47895:     // This call won't try to recurse again because root is an ancestor of
47895:     // aOther.
47895:     nsPoint negOffset = aOther->GetOffsetToCrossDoc(root, aAPD);
47895:     offset -= negOffset;
    1:   }
    1: 
    1:   return offset;
    1: }
    1: 
    1: // virtual
    1: nsIntRect nsIFrame::GetScreenRectExternal() const
    1: {
    1:   return GetScreenRect();
    1: }
    1: 
    1: nsIntRect nsIFrame::GetScreenRect() const
    1: {
34969:   return GetScreenRectInAppUnits().ToNearestPixels(PresContext()->AppUnitsPerCSSPixel());
15364: }
15364: 
15364: // virtual
15364: nsRect nsIFrame::GetScreenRectInAppUnitsExternal() const
15364: {
15364:   return GetScreenRectInAppUnits();
15364: }
15364: 
15364: nsRect nsIFrame::GetScreenRectInAppUnits() const
15364: {
30531:   nsPresContext* presContext = PresContext();
30531:   nsIFrame* rootFrame =
30531:     presContext->PresShell()->FrameManager()->GetRootFrame();
30531:   nsPoint rootScreenPos(0, 0);
30531:   nsPoint rootFrameOffsetInParent(0, 0);
30531:   nsIFrame* rootFrameParent =
30531:     nsLayoutUtils::GetCrossDocParentFrame(rootFrame, &rootFrameOffsetInParent);
30531:   if (rootFrameParent) {
30531:     nsRect parentScreenRectAppUnits = rootFrameParent->GetScreenRectInAppUnits();
30531:     nsPresContext* parentPresContext = rootFrameParent->PresContext();
30531:     double parentScale = double(presContext->AppUnitsPerDevPixel())/
30531:         parentPresContext->AppUnitsPerDevPixel();
30531:     nsPoint rootPt = parentScreenRectAppUnits.TopLeft() + rootFrameOffsetInParent;
30531:     rootScreenPos.x = NS_round(parentScale*rootPt.x);
30531:     rootScreenPos.y = NS_round(parentScale*rootPt.y);
30531:   } else {
30531:     nsCOMPtr<nsIWidget> rootWidget;
30531:     presContext->PresShell()->GetViewManager()->GetRootWidget(getter_AddRefs(rootWidget));
30531:     if (rootWidget) {
30531:       nsIntPoint rootDevPx = rootWidget->WidgetToScreenOffset();
30531:       rootScreenPos.x = presContext->DevPixelsToAppUnits(rootDevPx.x);
30531:       rootScreenPos.y = presContext->DevPixelsToAppUnits(rootDevPx.y);
30531:     }
30531:   }
30531: 
30531:   return nsRect(rootScreenPos + GetOffsetTo(rootFrame), GetSize());
    1: }
    1: 
    1: // Returns the offset from this frame to the closest geometric parent that
    1: // has a view. Also returns the containing view or null in case of error
    1: NS_IMETHODIMP nsFrame::GetOffsetFromView(nsPoint&  aOffset,
    1:                                          nsIView** aView) const
    1: {
    1:   NS_PRECONDITION(nsnull != aView, "null OUT parameter pointer");
    1:   nsIFrame* frame = (nsIFrame*)this;
    1: 
    1:   *aView = nsnull;
    1:   aOffset.MoveTo(0, 0);
    1:   do {
    1:     aOffset += frame->GetPosition();
    1:     frame = frame->GetParent();
    1:   } while (frame && !frame->HasView());
    1:   if (frame)
    1:     *aView = frame->GetView();
    1:   return NS_OK;
    1: }
    1: 
    1: nsIWidget*
47148: nsIFrame::GetNearestWidget() const
    1: {
    1:   return GetClosestView()->GetNearestWidget(nsnull);
    1: }
    1: 
39425: nsIWidget*
47148: nsIFrame::GetNearestWidget(nsPoint& aOffset) const
39425: {
39425:   nsPoint offsetToView;
39425:   nsPoint offsetToWidget;
39425:   nsIWidget* widget =
39425:     GetClosestView(&offsetToView)->GetNearestWidget(&offsetToWidget);
39425:   aOffset = offsetToView + offsetToWidget;
39425:   return widget;
39425: }
39425: 
    1: nsIAtom*
    1: nsFrame::GetType() const
    1: {
    1:   return nsnull;
    1: }
    1: 
79445: bool
    1: nsIFrame::IsLeaf() const
    1: {
80486:   return true;
    1: }
    1: 
64542: Layer*
47740: nsIFrame::InvalidateLayer(const nsRect& aDamageRect, PRUint32 aDisplayItemKey)
47740: {
47740:   NS_ASSERTION(aDisplayItemKey > 0, "Need a key");
47740: 
64542:   Layer* layer = FrameLayerBuilder::GetDedicatedLayer(this, aDisplayItemKey);
64542:   if (!layer) {
47740:     Invalidate(aDamageRect);
64542:     return nsnull;
47740:   }
47740: 
59684:   PRUint32 flags = INVALIDATE_NO_THEBES_LAYERS;
59684:   if (aDisplayItemKey == nsDisplayItem::TYPE_VIDEO ||
64542:       aDisplayItemKey == nsDisplayItem::TYPE_PLUGIN ||
64542:       aDisplayItemKey == nsDisplayItem::TYPE_CANVAS) {
63210:     flags |= INVALIDATE_NO_UPDATE_LAYER_TREE;
59684:   }
59684: 
59684:   InvalidateWithFlags(aDamageRect, flags);
64542:   return layer;
47740: }
47740: 
61256: void
61256: nsIFrame::InvalidateTransformLayer()
61256: {
61256:   NS_ASSERTION(mParent, "How can a viewport frame have a transform?");
61256: 
79445:   bool hasLayer =
64542:       FrameLayerBuilder::GetDedicatedLayer(this, nsDisplayItem::TYPE_TRANSFORM) != nsnull;
61256:   // Invalidate post-transform area in the parent. We have to invalidate
61256:   // in the parent because our transform style may have changed from what was
61256:   // used to paint this frame.
61256:   // It's OK to bypass the SVG effects processing and other processing
61256:   // performed if we called this->InvalidateWithFlags, because those effects
61256:   // are performed before applying transforms.
61256:   mParent->InvalidateInternal(GetVisualOverflowRect() + GetPosition(),
61256:                               0, 0, this,
61256:                               hasLayer ? INVALIDATE_NO_THEBES_LAYERS : 0);
61256: }
61256: 
47753: class LayerActivity {
47753: public:
72242:   LayerActivity(nsIFrame* aFrame) : mFrame(aFrame), mChangeHint(nsChangeHint(0)) {}
47753:   ~LayerActivity();
47753:   nsExpirationState* GetExpirationState() { return &mState; }
47753: 
47753:   nsIFrame* mFrame;
47753:   nsExpirationState mState;
72242:   // mChangeHint can be some combination of nsChangeHint_UpdateOpacityLayer and
72242:   // nsChangeHint_UpdateTransformLayer (or neither)
72242:   // The presence of those bits indicates whether opacity or transform
72242:   // changes have been detected.
72242:   nsChangeHint mChangeHint;
47753: };
47753: 
86633: class LayerActivityTracker MOZ_FINAL : public nsExpirationTracker<LayerActivity,4> {
47753: public:
47753:   // 75-100ms is a good timeout period. We use 4 generations of 25ms each.
47753:   enum { GENERATION_MS = 100 };
47753:   LayerActivityTracker()
47753:     : nsExpirationTracker<LayerActivity,4>(GENERATION_MS) {}
47753:   ~LayerActivityTracker() {
47753:     AgeAllGenerations();
47753:   }
47753: 
47753:   virtual void NotifyExpired(LayerActivity* aObject);
47753: };
47753: 
47753: static LayerActivityTracker* gLayerActivityTracker = nsnull;
47753: 
47753: LayerActivity::~LayerActivity()
47753: {
47753:   if (mFrame) {
47753:     NS_ASSERTION(gLayerActivityTracker, "Should still have a tracker");
47753:     gLayerActivityTracker->RemoveObject(this);
47753:   }
47753: }
47753: 
47753: static void DestroyLayerActivity(void* aPropertyValue)
47753: {
47753:   delete static_cast<LayerActivity*>(aPropertyValue);
47753: }
47753: 
47753: NS_DECLARE_FRAME_PROPERTY(LayerActivityProperty, DestroyLayerActivity)
47753: 
47753: void
47753: LayerActivityTracker::NotifyExpired(LayerActivity* aObject)
47753: {
47753:   RemoveObject(aObject);
47753: 
47753:   nsIFrame* f = aObject->mFrame;
47753:   aObject->mFrame = nsnull;
47753:   f->Properties().Delete(LayerActivityProperty());
51756:   f->InvalidateFrameSubtree();
47753: }
47753: 
47753: void
72242: nsIFrame::MarkLayersActive(nsChangeHint aChangeHint)
47753: {
47753:   FrameProperties properties = Properties();
47753:   LayerActivity* layerActivity =
47753:     static_cast<LayerActivity*>(properties.Get(LayerActivityProperty()));
47753:   if (layerActivity) {
47753:     gLayerActivityTracker->MarkUsed(layerActivity);
47753:   } else {
47753:     if (!gLayerActivityTracker) {
47753:       gLayerActivityTracker = new LayerActivityTracker();
47753:     }
47753:     layerActivity = new LayerActivity(this);
47753:     gLayerActivityTracker->AddObject(layerActivity);
47753:     properties.Set(LayerActivityProperty(), layerActivity);
47753:   }
72242:   NS_UpdateHint(layerActivity->mChangeHint, aChangeHint);
47753: }
47753: 
79445: bool
47753: nsIFrame::AreLayersMarkedActive()
47753: {
47753:   return Properties().Get(LayerActivityProperty()) != nsnull;
47753: }
47753: 
79445: bool
72242: nsIFrame::AreLayersMarkedActive(nsChangeHint aChangeHint)
72242: {
72242:   LayerActivity* layerActivity =
72242:     static_cast<LayerActivity*>(Properties().Get(LayerActivityProperty()));
72242:   return layerActivity && (layerActivity->mChangeHint & aChangeHint);
72242: }
72242: 
47753: /* static */ void
47753: nsFrame::ShutdownLayerActivityTimer()
47753: {
47753:   delete gLayerActivityTracker;
47753:   gLayerActivityTracker = nsnull;
47753: }
47753: 
47740: void
19380: nsIFrame::InvalidateWithFlags(const nsRect& aDamageRect, PRUint32 aFlags)
    1: {
    1:   if (aDamageRect.IsEmpty()) {
    1:     return;
    1:   }
    1: 
    1:   // Don't allow invalidates to do anything when
    1:   // painting is suppressed.
59171:   nsIPresShell *shell = PresContext()->GetPresShell();
    1:   if (shell) {
40049:     if (shell->IsPaintingSuppressed())
    1:       return;
    1:   }
    1: 
19380:   InvalidateInternal(aDamageRect, 0, 0, nsnull, aFlags);
    1: }
    1: 
19214: /**
19214:  * Helper function that funnels an InvalidateInternal request up to the
19214:  * parent.  This function is used so that if MOZ_SVG is not defined, we still
19214:  * have unified control paths in the InvalidateInternal chain.
19214:  *
19214:  * @param aDamageRect The rect to invalidate.
19214:  * @param aX The x offset from the origin of this frame to the rectangle.
19214:  * @param aY The y offset from the origin of this frame to the rectangle.
19214:  * @param aImmediate Whether to redraw immediately.
19214:  * @return None, though this funnels the request up to the parent frame.
19214:  */
19214: void
19214: nsIFrame::InvalidateInternalAfterResize(const nsRect& aDamageRect, nscoord aX,
19380:                                         nscoord aY, PRUint32 aFlags)
19214: {
96046:   if (aDamageRect.IsEmpty()) {
96046:     return;
96046:   }
96046: 
19214:   /* If we're a transformed frame, then we need to apply our transform to the
19214:    * damage rectangle so that the redraw correctly redraws the transformed
19214:    * region.  We're moved over aX and aY from our origin, but since this aX
19214:    * and aY is contained within our border, we need to scoot back by -aX and
19214:    * -aY to get back to the origin of the transform.
19214:    *
19214:    * There's one more problem, though, and that's that we don't know what
19214:    * coordinate space this rectangle is in.  Sometimes it's in the local
19214:    * coordinate space for the frame, and sometimes its in the transformed
19214:    * coordinate space.  If we get it wrong, we'll display incorrectly.  Until I
19214:    * find a better fix for this problem, we'll invalidate the union of the two
19214:    * rectangles (original rectangle and transformed rectangle).  At least one of
19214:    * these will be correct.
19214:    *
77286:    * When we are preserving-3d, we can have arbitrary hierarchies of preserved 3d
77286:    * children. The computed transform on these children is relative to the root
77286:    * transform object in the hierarchy, not necessarily their direct ancestor.
77286:    * In this case we transform by the child's transform, and mark the rectangle
77286:    * as being transformed until it is passed up to the root of the hierarchy.
77286:    *
19214:    * See bug #452496 for more details.
19214:    */
77286: 
77286:   // Check the transformed flags and remove it
79445:   bool rectIsTransformed = (aFlags & INVALIDATE_ALREADY_TRANSFORMED);
77286:   if (!Preserves3D()) {
77286:     // We only want to remove the flag if we aren't preserving 3d. Otherwise
77286:     // the rect will already have been transformed into the root preserve-3d
77286:     // frame coordinate space, and we should continue passing it up without
77286:     // further transforms.
77286:     aFlags &= ~INVALIDATE_ALREADY_TRANSFORMED;
77286:   }
77286: 
47731:   if ((mState & NS_FRAME_HAS_CONTAINER_LAYER) &&
47731:       !(aFlags & INVALIDATE_NO_THEBES_LAYERS)) {
47731:     // XXX for now I'm going to assume this is in the local coordinate space
47731:     // This only matters for frames with transforms and retained layers,
47731:     // which can't happen right now since transforms trigger fallback
47731:     // rendering and the display items that trigger layers are nested inside
47731:     // the nsDisplayTransform
47731:     // XXX need to set INVALIDATE_NO_THEBES_LAYERS for certain kinds of
47731:     // invalidation, e.g. video update, 'opacity' change
47731:     FrameLayerBuilder::InvalidateThebesLayerContents(this,
47731:         aDamageRect + nsPoint(aX, aY));
47731:     // Don't need to invalidate any more Thebes layers
47731:     aFlags |= INVALIDATE_NO_THEBES_LAYERS;
55830:     if (aFlags & INVALIDATE_ONLY_THEBES_LAYERS) {
55830:       return;
55830:     }
47731:   }
77286:   if (IsTransformed() && !rectIsTransformed) {
19214:     nsRect newDamageRect;
63072:     newDamageRect.UnionRect(nsDisplayTransform::TransformRectOut
19214:                             (aDamageRect, this, nsPoint(-aX, -aY)), aDamageRect);
77286: 
77286:     // If we are preserving 3d, then our computed transform includes that of any
77286:     // ancestor frames that also preserve 3d. Mark the rectangle as already being
77286:     // transformed into the parent's coordinate space.
77286:     if (Preserves3D()) {
77286:       aFlags |= INVALIDATE_ALREADY_TRANSFORMED;
77286:     }
77286: 
19214:     GetParent()->
19214:       InvalidateInternal(newDamageRect, aX + mRect.x, aY + mRect.y, this,
19380:                          aFlags);
19214:   }
19214:   else 
19214:     GetParent()->
19380:       InvalidateInternal(aDamageRect, aX + mRect.x, aY + mRect.y, this, aFlags);
19214: }
19214: 
    1: void
    1: nsIFrame::InvalidateInternal(const nsRect& aDamageRect, nscoord aX, nscoord aY,
19380:                              nsIFrame* aForChild, PRUint32 aFlags)
    1: {
50430:   nsSVGEffects::InvalidateDirectRenderingObservers(this);
19125:   if (nsSVGIntegrationUtils::UsingEffectsForFrame(this)) {
19125:     nsRect r = nsSVGIntegrationUtils::GetInvalidAreaForChangedSource(this,
19125:             aDamageRect + nsPoint(aX, aY));
19214:     /* Rectangle is now in our own local space, so aX and aY are effectively
19214:      * zero.  Thus we'll pretend that the entire time this was in our own
19214:      * local coordinate space and do any remaining processing.
19214:      */
19380:     InvalidateInternalAfterResize(r, 0, 0, aFlags);
19125:     return;
19125:   }
19125:   
19380:   InvalidateInternalAfterResize(aDamageRect, aX, aY, aFlags);
19214: }
19214: 
74283: gfx3DMatrix
86353: nsIFrame::GetTransformMatrix(nsIFrame* aStopAtAncestor,
86353:                              nsIFrame** aOutAncestor)
19214: {
19214:   NS_PRECONDITION(aOutAncestor, "Need a place to put the ancestor!");
19214: 
19214:   /* If we're transformed, we want to hand back the combination
19214:    * transform/translate matrix that will apply our current transform, then
19214:    * shift us to our parent.
19214:    */
19214:   if (IsTransformed()) {
19214:     /* Compute the delta to the parent, which we need because we are converting
19214:      * coordinates to our parent.
19214:      */
86353:     NS_ASSERTION(nsLayoutUtils::GetCrossDocParentFrame(this),
86353: 	             "Cannot transform the viewport frame!");
19214:     PRInt32 scaleFactor = PresContext()->AppUnitsPerDevPixel();
19214: 
74283:     gfx3DMatrix result =
19214:       nsDisplayTransform::GetResultingTransformMatrix(this, nsPoint(0, 0),
77286:                                                       scaleFactor, nsnull, aOutAncestor);
77286:     nsPoint delta = GetOffsetToCrossDoc(*aOutAncestor);
19214:     /* Combine the raw transform with a translation to our parent. */
74753:     result *= gfx3DMatrix::Translation
74283:       (NSAppUnitsToFloatPixels(delta.x, scaleFactor),
74283:        NSAppUnitsToFloatPixels(delta.y, scaleFactor),
74283:        0.0f);
19214:     return result;
19214:   }
19214:   
77286:   *aOutAncestor = nsLayoutUtils::GetCrossDocParentFrame(this);
77286:   
19214:   /* Otherwise, we're not transformed.  In that case, we'll walk up the frame
19214:    * tree until we either hit the root frame or something that may be
19214:    * transformed.  We'll then change coordinates into that frame, since we're
19214:    * guaranteed that nothing in-between can be transformed.  First, however,
19214:    * we have to check to see if we have a parent.  If not, we'll set the
19214:    * outparam to null (indicating that there's nothing left) and will hand back
19214:    * the identity matrix.
19214:    */
19214:   if (!*aOutAncestor)
74283:     return gfx3DMatrix();
19214:   
19214:   /* Keep iterating while the frame can't possibly be transformed. */
86353:   while (!(*aOutAncestor)->IsTransformed() && *aOutAncestor != aStopAtAncestor) {
19214:     /* If no parent, stop iterating.  Otherwise, update the ancestor. */
19214:     nsIFrame* parent = nsLayoutUtils::GetCrossDocParentFrame(*aOutAncestor);
19214:     if (!parent)
19214:       break;
19214: 
19214:     *aOutAncestor = parent;
19214:   }
19214: 
19214:   NS_ASSERTION(*aOutAncestor, "Somehow ended up with a null ancestor...?");
19214: 
19214:   /* Translate from this frame to our ancestor, if it exists.  That's the
19214:    * entire transform, so we're done.
19214:    */
47902:   nsPoint delta = GetOffsetToCrossDoc(*aOutAncestor);
19214:   PRInt32 scaleFactor = PresContext()->AppUnitsPerDevPixel();
74283:   return gfx3DMatrix().Translation
74283:     (NSAppUnitsToFloatPixels(delta.x, scaleFactor),
74283:      NSAppUnitsToFloatPixels(delta.y, scaleFactor),
74283:      0.0f);
    1: }
    1: 
    1: void
11384: nsIFrame::InvalidateRectDifference(const nsRect& aR1, const nsRect& aR2)
11384: {
11384:   nsRect sizeHStrip, sizeVStrip;
11384:   nsLayoutUtils::GetRectDifferenceStrips(aR1, aR2, &sizeHStrip, &sizeVStrip);
11384:   Invalidate(sizeVStrip);
11384:   Invalidate(sizeHStrip);
11384: }
11384: 
11384: void
51756: nsIFrame::InvalidateFrameSubtree()
11384: {
55040:   Invalidate(GetVisualOverflowRectRelativeToSelf());
51752:   FrameLayerBuilder::InvalidateThebesLayersInSubtree(this);
11384: }
11384: 
51756: void
51756: nsIFrame::InvalidateOverflowRect()
51756: {
55040:   Invalidate(GetVisualOverflowRectRelativeToSelf());
51756: }
51756: 
47735: NS_DECLARE_FRAME_PROPERTY(DeferInvalidatesProperty, nsIFrame::DestroyRegion)
47735: 
11384: void
19380: nsIFrame::InvalidateRoot(const nsRect& aDamageRect, PRUint32 aFlags)
19380: {
47771:   NS_ASSERTION(nsLayoutUtils::GetDisplayRootFrame(this) == this,
47771:                "Can only call this on display roots");
47771: 
47731:   if ((mState & NS_FRAME_HAS_CONTAINER_LAYER) &&
47731:       !(aFlags & INVALIDATE_NO_THEBES_LAYERS)) {
47775:     FrameLayerBuilder::InvalidateThebesLayerContents(this, aDamageRect);
55830:     if (aFlags & INVALIDATE_ONLY_THEBES_LAYERS) {
55830:       return;
55830:     }
47731:   }
47731: 
47775:   nsRect rect = aDamageRect;
47735:   nsRegion* excludeRegion = static_cast<nsRegion*>
47735:     (Properties().Get(DeferInvalidatesProperty()));
87340:   if (excludeRegion && (aFlags & INVALIDATE_EXCLUDE_CURRENT_PAINT)) {
47735:     nsRegion r;
47735:     r.Sub(rect, *excludeRegion);
47735:     if (r.IsEmpty())
47735:       return;
47735:     rect = r.GetBounds();
47735:   }
47735: 
59684:   if (!(aFlags & INVALIDATE_NO_UPDATE_LAYER_TREE)) {
59684:     AddStateBits(NS_FRAME_UPDATE_LAYER_TREE);
59684:   }
59684: 
    1:   nsIView* view = GetView();
    1:   NS_ASSERTION(view, "This can only be called on frames with views");
87353:   view->GetViewManager()->InvalidateViewNoSuppression(view, rect);
47735: }
47735: 
47735: void
47735: nsIFrame::BeginDeferringInvalidatesForDisplayRoot(const nsRegion& aExcludeRegion)
47735: {
47735:   NS_ASSERTION(nsLayoutUtils::GetDisplayRootFrame(this) == this,
47735:                "Can only call this on display roots");
47735:   Properties().Set(DeferInvalidatesProperty(), new nsRegion(aExcludeRegion));
47735: }
47735: 
47735: void
47735: nsIFrame::EndDeferringInvalidatesForDisplayRoot()
47735: {
47735:   NS_ASSERTION(nsLayoutUtils::GetDisplayRootFrame(this) == this,
47735:                "Can only call this on display roots");
47735:   Properties().Delete(DeferInvalidatesProperty());
    1: }
    1: 
20711: /**
20711:  * @param aAnyOutlineOrEffects set to true if this frame has any
20711:  * outline, SVG effects or box shadows that mean we need to invalidate
20711:  * the whole overflow area if the frame's size changes.
20711:  */
19125: static nsRect
79445: ComputeOutlineAndEffectsRect(nsIFrame* aFrame, bool* aAnyOutlineOrEffects,
19125:                              const nsRect& aOverflowRect,
35702:                              const nsSize& aNewSize,
79445:                              bool aStoreRectProperties) {
19125:   nsRect r = aOverflowRect;
80486:   *aAnyOutlineOrEffects = false;
19125: 
19125:   // box-shadow
51262:   nsCSSShadowArray* boxShadows = aFrame->GetStyleBorder()->mBoxShadow;
26940:   if (boxShadows) {
19125:     nsRect shadows;
52476:     PRInt32 A2D = aFrame->PresContext()->AppUnitsPerDevPixel();
19125:     for (PRUint32 i = 0; i < boxShadows->Length(); ++i) {
35702:       nsRect tmpRect(nsPoint(0, 0), aNewSize);
19125:       nsCSSShadowItem* shadow = boxShadows->ShadowAt(i);
24818: 
24818:       // inset shadows are never painted outside the frame
24818:       if (shadow->mInset)
24818:         continue;
19207: 
19207:       tmpRect.MoveBy(nsPoint(shadow->mXOffset, shadow->mYOffset));
52476:       tmpRect.Inflate(shadow->mSpread, shadow->mSpread);
52476:       tmpRect.Inflate(
52476:         nsContextBoxBlur::GetBlurRadiusMargin(shadow->mRadius, A2D));
19125: 
19125:       shadows.UnionRect(shadows, tmpRect);
19125:     }
19125:     r.UnionRect(r, shadows);
80486:     *aAnyOutlineOrEffects = true;
19125:   }
19125: 
    1:   const nsStyleOutline* outline = aFrame->GetStyleOutline();
    1:   PRUint8 outlineStyle = outline->GetOutlineStyle();
    1:   if (outlineStyle != NS_STYLE_BORDER_STYLE_NONE) {
    1:     nscoord width;
    1: #ifdef DEBUG
79445:     bool result = 
    1: #endif
    1:       outline->GetOutlineWidth(width);
    1:     NS_ASSERTION(result, "GetOutlineWidth had no cached outline width");
    1:     if (width > 0) {
19125:       if (aStoreRectProperties) {
39965:         aFrame->Properties().
39965:           Set(nsIFrame::OutlineInnerRectProperty(), new nsRect(r));
19125:       }
19125: 
19205:       nscoord offset = outline->mOutlineOffset;
32531:       nscoord inflateBy = NS_MAX(width + offset, 0);
55040:       // FIXME (bug 599652): We probably want outline to be drawn around
55040:       // something smaller than the visual overflow rect (perhaps the
55040:       // scrollable overflow rect is correct).  When we change that, we
55040:       // need to keep this code (and the storing of properties just
55040:       // above) in sync with GetOutlineInnerRect in nsCSSRendering.cpp.
    1:       r.Inflate(inflateBy, inflateBy);
80486:       *aAnyOutlineOrEffects = true;
19125:     }
19125:   }
19125:   
19125:   // Note that we don't remove the outlineInnerRect if a frame loses outline
19125:   // style. That would require an extra property lookup for every frame,
19125:   // or a new frame state bit to track whether a property had been stored,
19125:   // or something like that. It's not worth doing that here. At most it's
19125:   // only one heap-allocated rect per frame and it will be cleaned up when
19125:   // the frame dies.
19125: 
19125:   if (nsSVGIntegrationUtils::UsingEffectsForFrame(aFrame)) {
80486:     *aAnyOutlineOrEffects = true;
19125:     if (aStoreRectProperties) {
39965:       aFrame->Properties().
39965:         Set(nsIFrame::PreEffectsBBoxProperty(), new nsRect(r));
19125:     }
19125:     r = nsSVGIntegrationUtils::ComputeFrameEffectsRect(aFrame, r);
19125:   }
19125: 
    1:   return r;
    1: }
    1: 
14460: nsPoint
14460: nsIFrame::GetRelativeOffset(const nsStyleDisplay* aDisplay) const
14460: {
14460:   if (!aDisplay || NS_STYLE_POSITION_RELATIVE == aDisplay->mPosition) {
14460:     nsPoint *offsets = static_cast<nsPoint*>
39965:       (Properties().Get(ComputedOffsetProperty()));
14460:     if (offsets) {
14460:       return *offsets;
14460:     }
14460:   }
14460:   return nsPoint(0,0);
14460: }
14460: 
    1: nsRect
55021: nsIFrame::GetOverflowRect(nsOverflowType aType) const
55021: {
55021:   NS_ABORT_IF_FALSE(aType == eVisualOverflow || aType == eScrollableOverflow,
55021:                     "unexpected type");
55021: 
    1:   // Note that in some cases the overflow area might not have been
    1:   // updated (yet) to reflect any outline set on the frame or the area
    1:   // of child frames. That's OK because any reflow that updates these
    1:   // areas will invalidate the appropriate area, so any (mis)uses of
    1:   // this method will be fixed up.
11909: 
26950:   if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
26950:     // there is an overflow rect, and it's not stored as deltas but as
26950:     // a separately-allocated rect
55021:     return static_cast<nsOverflowAreas*>(const_cast<nsIFrame*>(this)->
55021:              GetOverflowAreasProperty())->Overflow(aType);
55021:   }
55021: 
55021:   if (aType == eVisualOverflow &&
55021:       mOverflow.mType != NS_FRAME_OVERFLOW_NONE) {
55021:     return GetVisualOverflowFromDeltas();
55021:   }
55021: 
55021:   return nsRect(nsPoint(0, 0), GetSize());
55021: }
55021: 
55021: nsOverflowAreas
55021: nsIFrame::GetOverflowAreas() const
55021: {
55021:   if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
55021:     // there is an overflow rect, and it's not stored as deltas but as
55021:     // a separately-allocated rect
55021:     return *const_cast<nsIFrame*>(this)->GetOverflowAreasProperty();
55021:   }
55021: 
55021:   return nsOverflowAreas(GetVisualOverflowFromDeltas(),
55021:                          nsRect(nsPoint(0, 0), GetSize()));
    1: }
    1: 
19284: nsRect
55021: nsIFrame::GetScrollableOverflowRectRelativeToParent() const
55021: {
55021:   return GetScrollableOverflowRect() + mRect.TopLeft();
19284: }
19284: 
19284: nsRect
55021: nsIFrame::GetVisualOverflowRectRelativeToSelf() const
19284: {
50423:   if (IsTransformed()) {
87626:     nsOverflowAreas* preTransformOverflows = static_cast<nsOverflowAreas*>
87626:       (Properties().Get(PreTransformOverflowAreasProperty()));
87626:     if (preTransformOverflows)
87626:       return preTransformOverflows->VisualOverflow();
39967:   }
55021:   return GetVisualOverflowRect();
19284: }
19284: 
87626: /* virtual */ bool
87626: nsFrame::UpdateOverflow()
87626: {
87626:   nsRect rect(nsPoint(0, 0), GetSize());
87626:   nsOverflowAreas overflowAreas(rect, rect);
87626: 
87626:   bool isBox = IsBoxFrame() || IsBoxWrapped();
87626:   if (!isBox || (!IsCollapsed() && !DoesClipChildren())) {
87626:     nsLayoutUtils::UnionChildOverflow(this, overflowAreas);
87626:   }
87626: 
87626:   if (FinishAndStoreOverflow(overflowAreas, GetSize())) {
87626:     nsIView* view = GetView();
87626:     if (view) {
87626:       PRUint32 flags = 0;
87626:       GetLayoutFlags(flags);
87626: 
87626:       if ((flags & NS_FRAME_NO_SIZE_VIEW) == 0) {
87626:         // Make sure the frame's view is properly sized.
87626:         nsIViewManager* vm = view->GetViewManager();
87626:         vm->ResizeView(view, overflowAreas.VisualOverflow(), true);
87626:       }
87626:     }
87626: 
87626:     return true;
87626:   }
87626: 
87626:   return false;
87626: }
87626: 
    1: void
17140: nsFrame::CheckInvalidateSizeChange(nsHTMLReflowMetrics& aNewDesiredSize)
17140: {
55040:   nsIFrame::CheckInvalidateSizeChange(mRect, GetVisualOverflowRect(),
20711:       nsSize(aNewDesiredSize.width, aNewDesiredSize.height));
17140: }
17140: 
34422: static void
34422: InvalidateRectForFrameSizeChange(nsIFrame* aFrame, const nsRect& aRect)
34422: {
40177:   nsStyleContext *bgSC;
40177:   if (!nsCSSRendering::FindBackground(aFrame->PresContext(), aFrame, &bgSC)) {
34422:     nsIFrame* rootFrame =
34422:       aFrame->PresContext()->PresShell()->FrameManager()->GetRootFrame();
34422:     rootFrame->Invalidate(nsRect(nsPoint(0, 0), rootFrame->GetSize()));
34422:   }
34422: 
34422:   aFrame->Invalidate(aRect);
34422: }
34422: 
17140: void
17140: nsIFrame::CheckInvalidateSizeChange(const nsRect& aOldRect,
55040:                                     const nsRect& aOldVisualOverflowRect,
20711:                                     const nsSize& aNewDesiredSize)
17140: {
33360:   if (aNewDesiredSize == aOldRect.Size())
    1:     return;
    1: 
    1:   // Below, we invalidate the old frame area (or, in the case of
    1:   // outline, combined area) if the outline, border or background
    1:   // settings indicate that something other than the difference
    1:   // between the old and new areas needs to be painted. We are
    1:   // assuming that the difference between the old and new areas will
    1:   // be invalidated by some other means. That also means invalidating
    1:   // the old frame area is the same as invalidating the new frame area
    1:   // (since in either case the UNION of old and new areas will be
    1:   // invalidated)
    1: 
34422:   // We use InvalidateRectForFrameSizeChange throughout this method, even
34422:   // though root-invalidation is technically only needed in the case where
34422:   // layer.RenderingMightDependOnFrameSize().  This allows us to simplify the
34422:   // code somewhat and return immediately after invalidation in the earlier
34422:   // cases.
34422: 
    1:   // Invalidate the entire old frame+outline if the frame has an outline
79445:   bool anyOutlineOrEffects;
19125:   nsRect r = ComputeOutlineAndEffectsRect(this, &anyOutlineOrEffects,
55040:                                           aOldVisualOverflowRect,
55040:                                           aNewDesiredSize,
80486:                                           false);
19125:   if (anyOutlineOrEffects) {
55040:     r.UnionRect(aOldVisualOverflowRect, r);
34422:     InvalidateRectForFrameSizeChange(this, r);
    1:     return;
    1:   }
    1: 
28109:   // Invalidate the old frame border box if the frame has borders. Those
28109:   // borders may be moving.
    1:   const nsStyleBorder* border = GetStyleBorder();
    1:   NS_FOR_CSS_SIDES(side) {
15992:     if (border->GetActualBorderWidth(side) != 0) {
28109:       if ((side == NS_SIDE_LEFT || side == NS_SIDE_TOP) &&
28109:           !nsLayoutUtils::HasNonZeroCornerOnSide(border->mBorderRadius, side) &&
28109:           !border->GetBorderImage() &&
28109:           border->GetBorderStyle(side) == NS_STYLE_BORDER_STYLE_SOLID) {
28109:         // We also need to be sure that the bottom-left or top-right
28109:         // corner is simple. For example, if the bottom or right border
28109:         // has a different color, we would need to invalidate the corner
28109:         // area. But that's OK because if there is a right or bottom border,
28109:         // we'll invalidate the entire border-box here anyway.
28109:         continue;
28109:       }
34422:       InvalidateRectForFrameSizeChange(this, nsRect(0, 0, aOldRect.width, aOldRect.height));
    1:       return;
    1:     }
    1:   }
    1: 
33360:   const nsStyleBackground *bg = GetStyleBackground();
33360:   if (!bg->IsTransparent()) {
    1:     // Invalidate the old frame background if the frame has a background
    1:     // whose position depends on the size of the frame
25276:     NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, bg) {
25276:       const nsStyleBackground::Layer &layer = bg->mLayers[i];
34422:       if (layer.RenderingMightDependOnFrameSize()) {
34422:         InvalidateRectForFrameSizeChange(this, nsRect(0, 0, aOldRect.width, aOldRect.height));
    1:         return;
    1:       }
    1:     }
33360: 
33360:     // Invalidate the old frame background if the frame has a background
33360:     // that is being clipped by border-radius, since the old or new area
33360:     // clipped off by the radius is not necessarily in the area that has
33360:     // already been invalidated (even if only the top-left corner has a
33360:     // border radius).
33360:     if (nsLayoutUtils::HasNonZeroCorner(border->mBorderRadius)) {
34422:       InvalidateRectForFrameSizeChange(this, nsRect(0, 0, aOldRect.width, aOldRect.height));
33360:       return;
33360:     }
33360:   }
25276: }
    1: 
    1: // Define the MAX_FRAME_DEPTH to be the ContentSink's MAX_REFLOW_DEPTH plus
    1: // 4 for the frames above the document's frames: 
    1: //  the Viewport, GFXScroll, ScrollPort, and Canvas
    1: #define MAX_FRAME_DEPTH (MAX_REFLOW_DEPTH+4)
    1: 
79445: bool
    1: nsFrame::IsFrameTreeTooDeep(const nsHTMLReflowState& aReflowState,
60343:                             nsHTMLReflowMetrics& aMetrics,
60343:                             nsReflowStatus& aStatus)
    1: {
    1:   if (aReflowState.mReflowDepth >  MAX_FRAME_DEPTH) {
60342:     NS_WARNING("frame tree too deep; setting zero size and returning");
 3724:     mState |= NS_FRAME_TOO_DEEP_IN_FRAME_TREE;
55021:     ClearOverflowRects();
    1:     aMetrics.width = 0;
    1:     aMetrics.height = 0;
    1:     aMetrics.ascent = 0;
    1:     aMetrics.mCarriedOutBottomMargin.Zero();
55039:     aMetrics.mOverflowAreas.Clear();
60343: 
60343:     if (GetNextInFlow()) {
60343:       // Reflow depth might vary between reflows, so we might have
60343:       // successfully reflowed and split this frame before.  If so, we
60343:       // shouldn't delete its continuations.
60343:       aStatus = NS_FRAME_NOT_COMPLETE;
60343:     } else {
60343:       aStatus = NS_FRAME_COMPLETE;
60343:     }
60343: 
80486:     return true;
    1:   }
 3724:   mState &= ~NS_FRAME_TOO_DEEP_IN_FRAME_TREE;
80486:   return false;
    1: }
    1: 
79487: bool
79487: nsIFrame::IsBlockWrapper() const
79487: {
79487:   nsIAtom *pseudoType = GetStyleContext()->GetPseudo();
79487:   return (pseudoType == nsCSSAnonBoxes::mozAnonymousBlock ||
79487:           pseudoType == nsCSSAnonBoxes::mozAnonymousPositionedBlock ||
79487:           pseudoType == nsCSSAnonBoxes::cellContent);
79487: }
79487: 
79487: static nsIFrame*
79487: GetNearestBlockContainer(nsIFrame* frame)
79487: {
79487:   // The block wrappers we use to wrap blocks inside inlines aren't
79487:   // described in the CSS spec.  We need to make them not be containing
79487:   // blocks.
79487:   // Since the parent of such a block is either a normal block or
79487:   // another such pseudo, this shouldn't cause anything bad to happen.
79487:   // Also the anonymous blocks inside table cells are not containing blocks.
79487:   while (frame->IsFrameOfType(nsIFrame::eLineParticipant) ||
90880:          frame->IsBlockWrapper() ||
90880:          // Table rows are not containing blocks either
90880:          frame->GetType() == nsGkAtoms::tableRowFrame) {
79487:     frame = frame->GetParent();
79487:     NS_ASSERTION(frame, "How come we got to the root frame without seeing a containing block?");
79487:   }
79487:   return frame;
79487: }
79487: 
79487: nsIFrame*
79487: nsIFrame::GetContainingBlock() const
79487: {
79487:   // MathML frames might have absolute positioning style, but they would
79487:   // still be in-flow.  So we have to check to make sure that the frame
79487:   // is really out-of-flow too.
79487:   if (GetStyleDisplay()->IsAbsolutelyPositioned() &&
79487:       (GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
79487:     return GetParent(); // the parent is always the containing block
79487:   }
79487:   return GetNearestBlockContainer(GetParent());
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: 
    1: PRInt32 nsFrame::ContentIndexInContainer(const nsIFrame* aFrame)
    1: {
    1:   PRInt32 result = -1;
    1: 
    1:   nsIContent* content = aFrame->GetContent();
    1:   if (content) {
    1:     nsIContent* parentContent = content->GetParent();
    1:     if (parentContent) {
    1:       result = parentContent->IndexOf(content);
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: /**
    1:  * List a frame tree to stdout. Meant to be called from gdb.
    1:  */
    1: void
    1: DebugListFrameTree(nsIFrame* aFrame)
    1: {
    1:   ((nsFrame*)aFrame)->List(stdout, 0);
    1: }
    1: 
    1: 
    1: // Debugging
    1: NS_IMETHODIMP
    1: nsFrame::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   IndentBy(out, aIndent);
    1:   ListTag(out);
    1: #ifdef DEBUG_waterson
 3233:   fprintf(out, " [parent=%p]", static_cast<void*>(mParent));
    1: #endif
    1:   if (HasView()) {
 3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
    1:   }
    1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
    1:   if (0 != mState) {
85981:     fprintf(out, " [state=%016llx]", (unsigned long long)mState);
    1:   }
    1:   nsIFrame* prevInFlow = GetPrevInFlow();
    1:   nsIFrame* nextInFlow = GetNextInFlow();
    1:   if (nsnull != prevInFlow) {
 3233:     fprintf(out, " prev-in-flow=%p", static_cast<void*>(prevInFlow));
    1:   }
    1:   if (nsnull != nextInFlow) {
 3233:     fprintf(out, " next-in-flow=%p", static_cast<void*>(nextInFlow));
 3233:   }
 3233:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
 3233:   nsFrame* f = const_cast<nsFrame*>(this);
55040:   if (f->HasOverflowAreas()) {
55040:     nsRect overflowArea = f->GetVisualOverflowRect();
55040:     fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
55040:             overflowArea.width, overflowArea.height);
55040:     overflowArea = f->GetScrollableOverflowRect();
55040:     fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
11909:             overflowArea.width, overflowArea.height);
    1:   }
46249:   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
    1:   fputs("\n", out);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Frame"), aResult);
    1: }
    1: 
    1: NS_IMETHODIMP_(nsFrameState)
    1: nsFrame::GetDebugStateBits() const
    1: {
    1:   // We'll ignore these flags for the purposes of comparing frame state:
    1:   //
    1:   //   NS_FRAME_EXTERNAL_REFERENCE
    1:   //     because this is set by the event state manager or the
    1:   //     caret code when a frame is focused. Depending on whether
    1:   //     or not the regression tests are run as the focused window
    1:   //     will make this value vary randomly.
    1: #define IRRELEVANT_FRAME_STATE_FLAGS NS_FRAME_EXTERNAL_REFERENCE
    1: 
    1: #define FRAME_STATE_MASK (~(IRRELEVANT_FRAME_STATE_FLAGS))
    1: 
    1:   return GetStateBits() & FRAME_STATE_MASK;
    1: }
    1: 
    1: nsresult
    1: nsFrame::MakeFrameName(const nsAString& aType, nsAString& aResult) const
    1: {
    1:   aResult = aType;
    1:   if (mContent && !mContent->IsNodeOfType(nsINode::eTEXT)) {
    1:     nsAutoString buf;
    1:     mContent->Tag()->ToString(buf);
    1:     aResult.Append(NS_LITERAL_STRING("(") + buf + NS_LITERAL_STRING(")"));
    1:   }
    1:   char buf[40];
    1:   PR_snprintf(buf, sizeof(buf), "(%d)", ContentIndexInContainer(this));
    1:   AppendASCIItoUTF16(buf, aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsFrame::XMLQuote(nsString& aString)
    1: {
    1:   PRInt32 i, len = aString.Length();
    1:   for (i = 0; i < len; i++) {
    1:     PRUnichar ch = aString.CharAt(i);
    1:     if (ch == '<') {
    1:       nsAutoString tmp(NS_LITERAL_STRING("&lt;"));
    1:       aString.Cut(i, 1);
    1:       aString.Insert(tmp, i);
    1:       len += 3;
    1:       i += 3;
    1:     }
    1:     else if (ch == '>') {
    1:       nsAutoString tmp(NS_LITERAL_STRING("&gt;"));
    1:       aString.Cut(i, 1);
    1:       aString.Insert(tmp, i);
    1:       len += 3;
    1:       i += 3;
    1:     }
    1:     else if (ch == '\"') {
    1:       nsAutoString tmp(NS_LITERAL_STRING("&quot;"));
    1:       aString.Cut(i, 1);
    1:       aString.Insert(tmp, i);
    1:       len += 5;
    1:       i += 5;
    1:     }
    1:   }
    1: }
    1: #endif
    1: 
79445: bool
    1: nsIFrame::IsVisibleForPainting(nsDisplayListBuilder* aBuilder) {
    1:   if (!GetStyleVisibility()->IsVisible())
80486:     return false;
    1:   nsISelection* sel = aBuilder->GetBoundingSelection();
    1:   return !sel || IsVisibleInSelection(sel);
    1: }
    1: 
79445: bool
    1: nsIFrame::IsVisibleForPainting() {
    1:   if (!GetStyleVisibility()->IsVisible())
80486:     return false;
    1: 
  238:   nsPresContext* pc = PresContext();
    1:   if (!pc->IsRenderingOnlySelection())
80486:     return true;
    1: 
    1:   nsCOMPtr<nsISelectionController> selcon(do_QueryInterface(pc->PresShell()));
    1:   if (selcon) {
    1:     nsCOMPtr<nsISelection> sel;
    1:     selcon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:                          getter_AddRefs(sel));
    1:     if (sel)
    1:       return IsVisibleInSelection(sel);
    1:   }
80486:   return true;
    1: }
    1: 
79445: bool
    1: nsIFrame::IsVisibleInSelection(nsDisplayListBuilder* aBuilder) {
    1:   nsISelection* sel = aBuilder->GetBoundingSelection();
    1:   return !sel || IsVisibleInSelection(sel);
    1: }
    1: 
79445: bool
    1: nsIFrame::IsVisibleOrCollapsedForPainting(nsDisplayListBuilder* aBuilder) {
    1:   if (!GetStyleVisibility()->IsVisibleOrCollapsed())
80486:     return false;
    1:   nsISelection* sel = aBuilder->GetBoundingSelection();
    1:   return !sel || IsVisibleInSelection(sel);
    1: }
    1: 
79445: bool
    1: nsIFrame::IsVisibleInSelection(nsISelection* aSelection)
    1: {
85101:   if (!GetContent() || !GetContent()->IsSelectionDescendant()) {
85101:     return false;
85101:   }
    1:   
    1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent));
79445:   bool vis;
80486:   nsresult rv = aSelection->ContainsNode(node, true, &vis);
    1:   return NS_FAILED(rv) || vis;
    1: }
    1: 
79445: /* virtual */ bool
    1: nsFrame::IsEmpty()
    1: {
80486:   return false;
    1: }
    1: 
79445: bool
    1: nsIFrame::CachedIsEmpty()
    1: {
    1:   NS_PRECONDITION(!(GetStateBits() & NS_FRAME_IS_DIRTY),
    1:                   "Must only be called on reflowed lines");
    1:   return IsEmpty();
    1: }
    1: 
79445: /* virtual */ bool
    1: nsFrame::IsSelfEmpty()
    1: {
80486:   return false;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::GetSelectionController(nsPresContext *aPresContext, nsISelectionController **aSelCon)
    1: {
    1:   if (!aPresContext || !aSelCon)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   nsIFrame *frame = this;
    1:   while (frame && (frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION)) {
23554:     nsITextControlFrame *tcf = do_QueryFrame(frame);
23554:     if (tcf) {
43129:       return tcf->GetOwnedSelectionController(aSelCon);
    1:     }
    1:     frame = frame->GetParent();
    1:   }
    1: 
    1:   return CallQueryInterface(aPresContext->GetPresShell(), aSelCon);
    1: }
    1: 
 8295: already_AddRefed<nsFrameSelection>
 8295: nsIFrame::GetFrameSelection()
 8295: {
 8295:   nsFrameSelection* fs =
 8295:     const_cast<nsFrameSelection*>(GetConstFrameSelection());
 8295:   NS_IF_ADDREF(fs);
 8295:   return fs;
 8295: }
 8295: 
 8295: const nsFrameSelection*
85101: nsIFrame::GetConstFrameSelection() const
85101: {
85101:   nsIFrame* frame = const_cast<nsIFrame*>(this);
    1:   while (frame && (frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION)) {
23554:     nsITextControlFrame* tcf = do_QueryFrame(frame);
23554:     if (tcf) {
    1:       return tcf->GetOwnedFrameSelection();
    1:     }
    1:     frame = frame->GetParent();
    1:   }
    1: 
 8295:   return PresContext()->PresShell()->ConstFrameSelection();
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
24806: nsFrame::DumpRegressionData(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent)
    1: {
    1:   IndentBy(out, aIndent);
    1:   fprintf(out, "<frame va=\"%ld\" type=\"", PRUptrdiff(this));
    1:   nsAutoString name;
    1:   GetFrameName(name);
    1:   XMLQuote(name);
    1:   fputs(NS_LossyConvertUTF16toASCII(name).get(), out);
43479:   fprintf(out, "\" state=\"%016llx\" parent=\"%ld\">\n",
85981:           (unsigned long long)GetDebugStateBits(), PRUptrdiff(mParent));
    1: 
    1:   aIndent++;
24806:   DumpBaseRegressionData(aPresContext, out, aIndent);
    1:   aIndent--;
    1: 
    1:   IndentBy(out, aIndent);
    1:   fprintf(out, "</frame>\n");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
24806: nsFrame::DumpBaseRegressionData(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent)
    1: {
32845:   if (GetNextSibling()) {
    1:     IndentBy(out, aIndent);
32845:     fprintf(out, "<next-sibling va=\"%ld\"/>\n", PRUptrdiff(GetNextSibling()));
    1:   }
    1: 
    1:   if (HasView()) {
    1:     IndentBy(out, aIndent);
    1:     fprintf(out, "<view va=\"%ld\">\n", PRUptrdiff(GetView()));
    1:     aIndent++;
    1:     // XXX add in code to dump out view state too...
    1:     aIndent--;
    1:     IndentBy(out, aIndent);
    1:     fprintf(out, "</view>\n");
    1:   }
    1: 
    1:   IndentBy(out, aIndent);
    1:   fprintf(out, "<bbox x=\"%d\" y=\"%d\" w=\"%d\" h=\"%d\"/>\n",
    1:           mRect.x, mRect.y, mRect.width, mRect.height);
    1: 
    1:   // Now dump all of the children on all of the child lists
77153:   ChildListIterator lists(this);
77153:   for (; !lists.IsDone(); lists.Next()) {
    1:     IndentBy(out, aIndent);
77153:     if (lists.CurrentID() != kPrincipalList) {
77153:       fprintf(out, "<child-list name=\"%s\">\n", mozilla::layout::ChildListName(lists.CurrentID()));
    1:     }
    1:     else {
    1:       fprintf(out, "<child-list>\n");
    1:     }
    1:     aIndent++;
77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:       nsIFrame* kid = childFrames.get();
31709:       kid->DumpRegressionData(aPresContext, out, aIndent);
    1:     }
    1:     aIndent--;
    1:     IndentBy(out, aIndent);
    1:     fprintf(out, "</child-list>\n");
    1:   }
    1: }
    1: #endif
    1: 
85101: bool
85101: nsIFrame::IsFrameSelected() const
85101: {
85101:   NS_ASSERTION(!GetContent() || GetContent()->IsSelectionDescendant(),
85101:                "use the public IsSelected() instead");
85101:   return nsRange::IsNodeSelected(GetContent(), 0,
85101:                                  GetContent()->GetChildCount());
    1: }
    1: 
    1: NS_IMETHODIMP
 4741: nsFrame::GetPointFromOffset(PRInt32 inOffset, nsPoint* outPoint)
    1: {
    1:   NS_PRECONDITION(outPoint != nsnull, "Null parameter");
38960:   nsRect contentRect = GetContentRect() - GetPosition();
38960:   nsPoint pt = contentRect.TopLeft();
    1:   if (mContent)
    1:   {
    1:     nsIContent* newContent = mContent->GetParent();
    1:     if (newContent){
    1:       PRInt32 newOffset = newContent->IndexOf(mContent);
    1: 
79445:       bool isRTL = (NS_GET_EMBEDDING_LEVEL(this) & 1) == 1;
19264:       if ((!isRTL && inOffset > newOffset) ||
38960:           (isRTL && inOffset <= newOffset)) {
38960:         pt = contentRect.TopRight();
38960:       }
38960:     }
38960:   }
38960:   *outPoint = pt;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsFrame::GetChildFrameContainingOffset(PRInt32 inContentOffset, bool inHint, PRInt32* outFrameContentOffset, nsIFrame **outChildFrame)
    1: {
    1:   NS_PRECONDITION(outChildFrame && outFrameContentOffset, "Null parameter");
    1:   *outFrameContentOffset = (PRInt32)inHint;
    1:   //the best frame to reflect any given offset would be a visible frame if possible
    1:   //i.e. we are looking for a valid frame to place the blinking caret 
    1:   nsRect rect = GetRect();
    1:   if (!rect.width || !rect.height)
    1:   {
    1:     //if we have a 0 width or height then lets look for another frame that possibly has
    1:     //the same content.  If we have no frames in flow then just let us return 'this' frame
    1:     nsIFrame* nextFlow = GetNextInFlow();
    1:     if (nextFlow)
    1:       return nextFlow->GetChildFrameContainingOffset(inContentOffset, inHint, outFrameContentOffset, outChildFrame);
    1:   }
    1:   *outChildFrame = this;
    1:   return NS_OK;
    1: }
    1: 
    1: //
    1: // What I've pieced together about this routine:
    1: // Starting with a block frame (from which a line frame can be gotten)
    1: // and a line number, drill down and get the first/last selectable
    1: // frame on that line, depending on aPos->mDirection.
    1: // aOutSideLimit != 0 means ignore aLineStart, instead work from
    1: // the end (if > 0) or beginning (if < 0).
    1: //
    1: nsresult
    1: nsFrame::GetNextPrevLineFromeBlockFrame(nsPresContext* aPresContext,
    1:                                         nsPeekOffsetStruct *aPos,
    1:                                         nsIFrame *aBlockFrame, 
    1:                                         PRInt32 aLineStart, 
    1:                                         PRInt8 aOutSideLimit
    1:                                         )
    1: {
    1:   //magic numbers aLineStart will be -1 for end of block 0 will be start of block
    1:   if (!aBlockFrame || !aPos)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   aPos->mResultFrame = nsnull;
    1:   aPos->mResultContent = nsnull;
    1:   aPos->mAttachForward = (aPos->mDirection == eDirNext);
    1: 
21112:   nsAutoLineIterator it = aBlockFrame->GetLineIterator();
21112:   if (!it)
21112:     return NS_ERROR_FAILURE;
    1:   PRInt32 searchingLine = aLineStart;
21112:   PRInt32 countLines = it->GetNumLines();
    1:   if (aOutSideLimit > 0) //start at end
    1:     searchingLine = countLines;
    1:   else if (aOutSideLimit <0)//start at beginning
    1:     searchingLine = -1;//"next" will be 0  
    1:   else 
    1:     if ((aPos->mDirection == eDirPrevious && searchingLine == 0) || 
    1:        (aPos->mDirection == eDirNext && searchingLine >= (countLines -1) )){
    1:       //we need to jump to new block frame.
    1:            return NS_ERROR_FAILURE;
    1:     }
    1:   PRInt32 lineFrameCount;
    1:   nsIFrame *resultFrame = nsnull;
    1:   nsIFrame *farStoppingFrame = nsnull; //we keep searching until we find a "this" frame then we go to next line
    1:   nsIFrame *nearStoppingFrame = nsnull; //if we are backing up from edge, stop here
    1:   nsIFrame *firstFrame;
    1:   nsIFrame *lastFrame;
    1:   nsRect  rect;
79445:   bool isBeforeFirstFrame, isAfterLastFrame;
79445:   bool found = false;
21112: 
21112:   nsresult result = NS_OK;
    1:   while (!found)
    1:   {
    1:     if (aPos->mDirection == eDirPrevious)
    1:       searchingLine --;
    1:     else
    1:       searchingLine ++;
    1:     if ((aPos->mDirection == eDirPrevious && searchingLine < 0) || 
    1:        (aPos->mDirection == eDirNext && searchingLine >= countLines ))
    1:     {
    1:       //we need to jump to new block frame.
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     PRUint32 lineFlags;
    1:     result = it->GetLine(searchingLine, &firstFrame, &lineFrameCount,
    1:                          rect, &lineFlags);
    1:     if (!lineFrameCount) 
    1:       continue;
    1:     if (NS_SUCCEEDED(result)){
    1:       lastFrame = firstFrame;
    1:       for (;lineFrameCount > 1;lineFrameCount --){
    1:         //result = lastFrame->GetNextSibling(&lastFrame, searchingLine);
    1:         result = it->GetNextSiblingOnLine(lastFrame, searchingLine);
    1:         if (NS_FAILED(result) || !lastFrame){
    1:           NS_ERROR("GetLine promised more frames than could be found");
    1:           return NS_ERROR_FAILURE;
    1:         }
    1:       }
    1:       GetLastLeaf(aPresContext, &lastFrame);
    1: 
    1:       if (aPos->mDirection == eDirNext){
    1:         nearStoppingFrame = firstFrame;
    1:         farStoppingFrame = lastFrame;
    1:       }
    1:       else{
    1:         nearStoppingFrame = lastFrame;
    1:         farStoppingFrame = firstFrame;
    1:       }
    1:       nsPoint offset;
    1:       nsIView * view; //used for call of get offset from view
    1:       aBlockFrame->GetOffsetFromView(offset,&view);
    1:       nscoord newDesiredX  = aPos->mDesiredX - offset.x;//get desired x into blockframe coordinates!
    1:       result = it->FindFrameAt(searchingLine, newDesiredX, &resultFrame, &isBeforeFirstFrame, &isAfterLastFrame);
    1:       if(NS_FAILED(result))
    1:         continue;
    1:     }
    1: 
    1:     if (NS_SUCCEEDED(result) && resultFrame)
    1:     {
    1:       //check to see if this is ANOTHER blockframe inside the other one if so then call into its lines
21112:       nsAutoLineIterator newIt = resultFrame->GetLineIterator();
21112:       if (newIt)
    1:       {
    1:         aPos->mResultFrame = resultFrame;
    1:         return NS_OK;
    1:       }
    1:       //resultFrame is not a block frame
21112:       result = NS_ERROR_FAILURE;
    1: 
21105:       nsCOMPtr<nsIFrameEnumerator> frameTraversal;
    1:       result = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
    1:                                     aPresContext, resultFrame,
    1:                                     ePostOrder,
80486:                                     false, // aVisual
    1:                                     aPos->mScrollViewStop,
80486:                                     false     // aFollowOOFs
    1:                                     );
    1:       if (NS_FAILED(result))
    1:         return result;
    1:       nsIFrame *storeOldResultFrame = resultFrame;
    1:       while ( !found ){
    1:         nsPoint point;
    1:         point.x = aPos->mDesiredX;
    1: 
    1:         nsRect tempRect = resultFrame->GetRect();
    1:         nsPoint offset;
    1:         nsIView * view; //used for call of get offset from view
    1:         result = resultFrame->GetOffsetFromView(offset, &view);
    1:         if (NS_FAILED(result))
    1:           return result;
    1:         point.y = tempRect.height + offset.y;
    1: 
    1:         //special check. if we allow non-text selection then we can allow a hit location to fall before a table. 
    1:         //otherwise there is no way to get and click signal to fall before a table (it being a line iterator itself)
    1:         nsIPresShell *shell = aPresContext->GetPresShell();
    1:         if (!shell)
    1:           return NS_ERROR_FAILURE;
39668:         PRInt16 isEditor = shell->GetSelectionFlags();
    1:         isEditor = isEditor == nsISelectionDisplay::DISPLAY_ALL;
    1:         if ( isEditor )
    1:         {
    1:           if (resultFrame->GetType() == nsGkAtoms::tableOuterFrame)
    1:           {
    1:             if (((point.x - offset.x + tempRect.x)<0) ||  ((point.x - offset.x+ tempRect.x)>tempRect.width))//off left/right side
    1:             {
    1:               nsIContent* content = resultFrame->GetContent();
    1:               if (content)
    1:               {
    1:                 nsIContent* parent = content->GetParent();
    1:                 if (parent)
    1:                 {
    1:                   aPos->mResultContent = parent;
    1:                   aPos->mContentOffset = parent->IndexOf(content);
80486:                   aPos->mAttachForward = false;
    1:                   if ((point.x - offset.x+ tempRect.x)>tempRect.width)
    1:                   {
    1:                     aPos->mContentOffset++;//go to end of this frame
80486:                     aPos->mAttachForward = true;
    1:                   }
    1:                   //result frame is the result frames parent.
    1:                   aPos->mResultFrame = resultFrame->GetParent();
    1:                   return NS_POSITION_BEFORE_TABLE;
    1:                 }
    1:               }
    1:             }
    1:           }
    1:         }
    1: 
    1:         if (!resultFrame->HasView())
    1:         {
    1:           nsIView* view;
    1:           nsPoint offset;
    1:           resultFrame->GetOffsetFromView(offset, &view);
    1:           ContentOffsets offsets =
    1:               resultFrame->GetContentOffsetsFromPoint(point - offset);
    1:           aPos->mResultContent = offsets.content;
    1:           aPos->mContentOffset = offsets.offset;
    1:           aPos->mAttachForward = offsets.associateWithNext;
    1:           if (offsets.content)
    1:           {
79445:             bool selectable;
    1:             resultFrame->IsSelectable(&selectable, nsnull);
    1:             if (selectable)
    1:             {
80486:               found = true;
    1:               break;
    1:             }
    1:           }
    1:         }
    1: 
    1:         if (aPos->mDirection == eDirPrevious && (resultFrame == farStoppingFrame))
    1:           break;
    1:         if (aPos->mDirection == eDirNext && (resultFrame == nearStoppingFrame))
    1:           break;
    1:         //always try previous on THAT line if that fails go the other way
21105:         frameTraversal->Prev();
21105:         resultFrame = frameTraversal->CurrentItem();
21105:         if (!resultFrame)
21105:           return NS_ERROR_FAILURE;
    1:       }
    1: 
    1:       if (!found){
    1:         resultFrame = storeOldResultFrame;
    1:         result = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
    1:                                       aPresContext, resultFrame,
    1:                                       eLeaf,
80486:                                       false, // aVisual
    1:                                       aPos->mScrollViewStop,
80486:                                       false     // aFollowOOFs
    1:                                       );
    1:       }
    1:       while ( !found ){
    1:         nsPoint point(aPos->mDesiredX, 0);
    1:         nsIView* view;
    1:         nsPoint offset;
    1:         resultFrame->GetOffsetFromView(offset, &view);
    1:         ContentOffsets offsets =
    1:             resultFrame->GetContentOffsetsFromPoint(point - offset);
    1:         aPos->mResultContent = offsets.content;
    1:         aPos->mContentOffset = offsets.offset;
    1:         aPos->mAttachForward = offsets.associateWithNext;
    1:         if (offsets.content)
    1:         {
79445:           bool selectable;
    1:           resultFrame->IsSelectable(&selectable, nsnull);
    1:           if (selectable)
    1:           {
80486:             found = true;
    1:             if (resultFrame == farStoppingFrame)
80486:               aPos->mAttachForward = false;
    1:             else
80486:               aPos->mAttachForward = true;
    1:             break;
    1:           }
    1:         }
    1:         if (aPos->mDirection == eDirPrevious && (resultFrame == nearStoppingFrame))
    1:           break;
    1:         if (aPos->mDirection == eDirNext && (resultFrame == farStoppingFrame))
    1:           break;
    1:         //previous didnt work now we try "next"
21105:         frameTraversal->Next();
21105:         nsIFrame *tempFrame = frameTraversal->CurrentItem();
21105:         if (!tempFrame)
    1:           break;
21105:         resultFrame = tempFrame;
    1:       }
    1:       aPos->mResultFrame = resultFrame;
    1:     }
    1:     else {
    1:         //we need to jump to new block frame.
    1:       aPos->mAmount = eSelectLine;
    1:       aPos->mStartOffset = 0;
    1:       aPos->mAttachForward = !(aPos->mDirection == eDirNext);
    1:       if (aPos->mDirection == eDirPrevious)
    1:         aPos->mStartOffset = -1;//start from end
    1:      return aBlockFrame->PeekOffset(aPos);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
94058: nsIFrame::CaretPosition
94058: nsIFrame::GetExtremeCaretPosition(bool aStart)
94058: {
94058:   CaretPosition result;
    1: 
    1:   FrameTarget targetFrame = DrillDownToSelectionFrame(this, !aStart);
    1:   FrameContentRange range = GetRangeForFrame(targetFrame.frame);
    1:   result.mResultContent = range.content;
    1:   result.mContentOffset = aStart ? range.start : range.end;
    1:   return result;
    1: }
    1: 
    1: // Find the first (or last) descendant of the given frame
    1: // which is either a block frame or a BRFrame.
    1: static nsContentAndOffset
    1: FindBlockFrameOrBR(nsIFrame* aFrame, nsDirection aDirection)
    1: {
    1:   nsContentAndOffset result;
    1:   result.mContent =  nsnull;
12151:   result.mOffset = 0;
    1: 
    1:   if (aFrame->IsGeneratedContentFrame())
    1:     return result;
    1: 
    1:   // Treat form controls as inline leaves
    1:   // XXX we really need a way to determine whether a frame is inline-level
23554:   nsIFormControlFrame* fcf = do_QueryFrame(aFrame);
23554:   if (fcf)
    1:     return result;
    1:   
    1:   // Check the frame itself
    1:   // Fall through "special" block frames because their mContent is the content
    1:   // of the inline frames they were created from. The first/last child of
    1:   // such frames is the real block frame we're looking for.
19264:   if ((nsLayoutUtils::GetAsBlock(aFrame) && !(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL)) ||
    1:       aFrame->GetType() == nsGkAtoms::brFrame) {
    1:     nsIContent* content = aFrame->GetContent();
    1:     result.mContent = content->GetParent();
12151:     // In some cases (bug 310589, bug 370174) we end up here with a null content.
12151:     // This probably shouldn't ever happen, but since it sometimes does, we want
12151:     // to avoid crashing here.
12151:     NS_ASSERTION(result.mContent, "Unexpected orphan content");
12118:     if (result.mContent)
    1:       result.mOffset = result.mContent->IndexOf(content) + 
    1:         (aDirection == eDirPrevious ? 1 : 0);
    1:     return result;
    1:   }
    1: 
    1:   // If this is a preformatted text frame, see if it ends with a newline
    1:   if (aFrame->HasTerminalNewline() &&
16575:       aFrame->GetStyleContext()->GetStyleText()->NewlineIsSignificant()) {
    1:     PRInt32 startOffset, endOffset;
    1:     aFrame->GetOffsets(startOffset, endOffset);
    1:     result.mContent = aFrame->GetContent();
    1:     result.mOffset = endOffset - (aDirection == eDirPrevious ? 0 : 1);
    1:     return result;
    1:   }
    1: 
    1:   // Iterate over children and call ourselves recursively
    1:   if (aDirection == eDirPrevious) {
77154:     nsIFrame* child = aFrame->GetLastChild(nsIFrame::kPrincipalList);
    1:     while(child && !result.mContent) {
    1:       result = FindBlockFrameOrBR(child, aDirection);
33388:       child = child->GetPrevSibling();
    1:     }
    1:   } else { // eDirNext
77154:     nsIFrame* child = aFrame->GetFirstPrincipalChild();
    1:     while(child && !result.mContent) {
    1:       result = FindBlockFrameOrBR(child, aDirection);
    1:       child = child->GetNextSibling();
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsIFrame::PeekOffsetParagraph(nsPeekOffsetStruct *aPos)
    1: {
    1:   nsIFrame* frame = this;
    1:   nsContentAndOffset blockFrameOrBR;
    1:   blockFrameOrBR.mContent = nsnull;
79445:   bool reachedBlockAncestor = false;
    1: 
    1:   // Go through containing frames until reaching a block frame.
    1:   // In each step, search the previous (or next) siblings for the closest
    1:   // "stop frame" (a block frame or a BRFrame).
    1:   // If found, set it to be the selection boundray and abort.
    1:   
    1:   if (aPos->mDirection == eDirPrevious) {
    1:     while (!reachedBlockAncestor) {
    1:       nsIFrame* parent = frame->GetParent();
  532:       // Treat a frame associated with the root content as if it were a block frame.
  532:       if (!frame->mContent || !frame->mContent->GetParent()) {
80486:         reachedBlockAncestor = true;
    1:         break;
    1:       }
33388:       nsIFrame* sibling = frame->GetPrevSibling();
    1:       while (sibling && !blockFrameOrBR.mContent) {
    1:         blockFrameOrBR = FindBlockFrameOrBR(sibling, eDirPrevious);
33388:         sibling = sibling->GetPrevSibling();
    1:       }
    1:       if (blockFrameOrBR.mContent) {
    1:         aPos->mResultContent = blockFrameOrBR.mContent;
    1:         aPos->mContentOffset = blockFrameOrBR.mOffset;
    1:         break;
    1:       }
    1:       frame = parent;
15909:       reachedBlockAncestor = (nsLayoutUtils::GetAsBlock(frame) != nsnull);
    1:     }
    1:     if (reachedBlockAncestor) { // no "stop frame" found
    1:       aPos->mResultContent = frame->GetContent();
    1:       aPos->mContentOffset = 0;
    1:     }
    1:   } else { // eDirNext
    1:     while (!reachedBlockAncestor) {
    1:       nsIFrame* parent = frame->GetParent();
  532:       // Treat a frame associated with the root content as if it were a block frame.
  532:       if (!frame->mContent || !frame->mContent->GetParent()) {
80486:         reachedBlockAncestor = true;
    1:         break;
    1:       }
    1:       nsIFrame* sibling = frame;
    1:       while (sibling && !blockFrameOrBR.mContent) {
    1:         blockFrameOrBR = FindBlockFrameOrBR(sibling, eDirNext);
    1:         sibling = sibling->GetNextSibling();
    1:       }
    1:       if (blockFrameOrBR.mContent) {
    1:         aPos->mResultContent = blockFrameOrBR.mContent;
    1:         aPos->mContentOffset = blockFrameOrBR.mOffset;
    1:         break;
    1:       }
    1:       frame = parent;
15909:       reachedBlockAncestor = (nsLayoutUtils::GetAsBlock(frame) != nsnull);
    1:     }
    1:     if (reachedBlockAncestor) { // no "stop frame" found
    1:       aPos->mResultContent = frame->GetContent();
    1:       if (aPos->mResultContent)
    1:         aPos->mContentOffset = aPos->mResultContent->GetChildCount();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Determine movement direction relative to frame
79445: static bool IsMovingInFrameDirection(nsIFrame* frame, nsDirection aDirection, bool aVisual)
79445: {
79445:   bool isReverseDirection = aVisual ?
80486:     (NS_GET_EMBEDDING_LEVEL(frame) & 1) != (NS_GET_BASE_LEVEL(frame) & 1) : false;
    1:   return aDirection == (isReverseDirection ? eDirPrevious : eDirNext);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsIFrame::PeekOffset(nsPeekOffsetStruct* aPos)
    1: {
    1:   if (!aPos)
    1:     return NS_ERROR_NULL_POINTER;
    1:   nsresult result = NS_ERROR_FAILURE;
    1: 
    1:   if (mState & NS_FRAME_IS_DIRTY)
    1:     return NS_ERROR_UNEXPECTED;
    1: 
    1:   // Translate content offset to be relative to frame
    1:   FrameContentRange range = GetRangeForFrame(this);
    1:   PRInt32 offset = aPos->mStartOffset - range.start;
    1:   nsIFrame* current = this;
    1:   
    1:   switch (aPos->mAmount) {
    1:     case eSelectCharacter:
59604:     case eSelectCluster:
    1:     {
79445:       bool eatingNonRenderableWS = false;
79445:       bool done = false;
79445:       bool jumpedLine = false;
    1:       
    1:       while (!done) {
79445:         bool movingInFrameDirection =
    1:           IsMovingInFrameDirection(current, aPos->mDirection, aPos->mVisual);
    1: 
    1:         if (eatingNonRenderableWS)
    1:           done = current->PeekOffsetNoAmount(movingInFrameDirection, &offset); 
    1:         else
59604:           done = current->PeekOffsetCharacter(movingInFrameDirection, &offset,
59604:                                               aPos->mAmount == eSelectCluster);
    1: 
    1:         if (!done) {
    1:           result =
    1:             current->GetFrameFromDirection(aPos->mDirection, aPos->mVisual,
    1:                                            aPos->mJumpLines, aPos->mScrollViewStop,
    1:                                            &current, &offset, &jumpedLine);
    1:           if (NS_FAILED(result))
    1:             return result;
    1: 
    1:           // If we jumped lines, it's as if we found a character, but we still need
    1:           // to eat non-renderable content on the new line.
    1:           if (jumpedLine)
80486:             eatingNonRenderableWS = true;
    1:         }
    1:       }
    1: 
    1:       // Set outputs
    1:       range = GetRangeForFrame(current);
    1:       aPos->mResultFrame = current;
    1:       aPos->mResultContent = range.content;
    1:       // Output offset is relative to content, not frame
    1:       aPos->mContentOffset = offset < 0 ? range.end : range.start + offset;
53724:       // If we're dealing with a text frame and moving backward positions us at
53724:       // the end of that line, decrease the offset by one to make sure that
53724:       // we're placed before the linefeed character on the previous line.
53724:       if (offset < 0 && jumpedLine &&
53724:           aPos->mDirection == eDirPrevious &&
53724:           current->GetStyleText()->NewlineIsSignificant() &&
53724:           current->HasTerminalNewline()) {
53724:         --aPos->mContentOffset;
53724:       }
    1:       
    1:       break;
    1:     }
63601:     case eSelectWordNoSpace:
63601:       // eSelectWordNoSpace means that we should not be eating any whitespace when
63601:       // moving to the adjacent word.  This means that we should set aPos->
63601:       // mWordMovementType to eEndWord if we're moving forwards, and to eStartWord
63601:       // if we're moving backwards.
63601:       if (aPos->mDirection == eDirPrevious) {
63601:         aPos->mWordMovementType = eStartWord;
63601:       } else {
63601:         aPos->mWordMovementType = eEndWord;
63601:       }
63601:       // Intentionally fall through the eSelectWord case.
    1:     case eSelectWord:
    1:     {
    1:       // wordSelectEatSpace means "are we looking for a boundary between whitespace
    1:       // and non-whitespace (in the direction we're moving in)".
    1:       // It is true when moving forward and looking for a beginning of a word, or
    1:       // when moving backwards and looking for an end of a word.
79445:       bool wordSelectEatSpace;
    1:       if (aPos->mWordMovementType != eDefaultBehavior) {
    1:         // aPos->mWordMovementType possible values:
    1:         //       eEndWord: eat the space if we're moving backwards
    1:         //       eStartWord: eat the space if we're moving forwards
    1:         wordSelectEatSpace = ((aPos->mWordMovementType == eEndWord) == (aPos->mDirection == eDirPrevious));
    1:       }
    1:       else {
    1:         // Use the hidden preference which is based on operating system behavior.
    1:         // This pref only affects whether moving forward by word should go to the end of this word or start of the next word.
    1:         // When going backwards, the start of the word is always used, on every operating system.
 3049:         wordSelectEatSpace = aPos->mDirection == eDirNext &&
70840:           Preferences::GetBool("layout.word_select.eat_space_to_next_word");
    1:       }
    1:       
 5453:       // mSawBeforeType means "we already saw characters of the type
    1:       // before the boundary we're looking for". Examples:
    1:       // 1. If we're moving forward, looking for a word beginning (i.e. a boundary
80486:       //    between whitespace and non-whitespace), then eatingWS==true means
    1:       //    "we already saw some whitespace".
    1:       // 2. If we're moving backward, looking for a word beginning (i.e. a boundary
80486:       //    between non-whitespace and whitespace), then eatingWS==true means
    1:       //    "we already saw some non-whitespace".
 5453:       PeekWordState state;
64445:       PRInt32 offsetAdjustment = 0;
79445:       bool done = false;
    1:       while (!done) {
79445:         bool movingInFrameDirection =
    1:           IsMovingInFrameDirection(current, aPos->mDirection, aPos->mVisual);
    1:         
 5453:         done = current->PeekOffsetWord(movingInFrameDirection, wordSelectEatSpace,
 5453:                                        aPos->mIsKeyboardSelect, &offset, &state);
    1:         
    1:         if (!done) {
    1:           nsIFrame* nextFrame;
    1:           PRInt32 nextFrameOffset;
79445:           bool jumpedLine;
    1:           result =
    1:             current->GetFrameFromDirection(aPos->mDirection, aPos->mVisual,
    1:                                            aPos->mJumpLines, aPos->mScrollViewStop,
    1:                                            &nextFrame, &nextFrameOffset, &jumpedLine);
    1:           // We can't jump lines if we're looking for whitespace following
    1:           // non-whitespace, and we already encountered non-whitespace.
    1:           if (NS_FAILED(result) ||
19264:               (jumpedLine && !wordSelectEatSpace && state.mSawBeforeType)) {
80486:             done = true;
64445:             // If we've crossed the line boundary, check to make sure that we
64445:             // have not consumed a trailing newline as whitesapce if it's significant.
64445:             if (jumpedLine && wordSelectEatSpace &&
64445:                 current->HasTerminalNewline() &&
64445:                 current->GetStyleText()->NewlineIsSignificant()) {
64445:               offsetAdjustment = -1;
64445:             }
    1:           } else {
 7679:             if (jumpedLine) {
 7679:               state.mContext.Truncate();
 7679:             }
    1:             current = nextFrame;
    1:             offset = nextFrameOffset;
    1:             // Jumping a line is equivalent to encountering whitespace
    1:             if (wordSelectEatSpace && jumpedLine)
 5453:               state.SetSawBeforeType();
    1:           }
    1:         }
    1:       }
    1:       
    1:       // Set outputs
    1:       range = GetRangeForFrame(current);
    1:       aPos->mResultFrame = current;
    1:       aPos->mResultContent = range.content;
    1:       // Output offset is relative to content, not frame
64445:       aPos->mContentOffset = (offset < 0 ? range.end : range.start + offset) + offsetAdjustment;
    1:       break;
    1:     }
    1:     case eSelectLine :
    1:     {
21112:       nsAutoLineIterator iter;
    1:       nsIFrame *blockFrame = this;
    1: 
    1:       while (NS_FAILED(result)){
20200:         PRInt32 thisLine = nsFrame::GetLineNumber(blockFrame, aPos->mScrollViewStop, &blockFrame);
    1:         if (thisLine < 0) 
    1:           return  NS_ERROR_FAILURE;
21112:         iter = blockFrame->GetLineIterator();
21112:         NS_ASSERTION(iter, "GetLineNumber() succeeded but no block frame?");
21112:         result = NS_OK;
    1: 
    1:         int edgeCase = 0;//no edge case. this should look at thisLine
    1:         
79445:         bool doneLooping = false;//tells us when no more block frames hit.
    1:         //this part will find a frame or a block frame. if it's a block frame
    1:         //it will "drill down" to find a viable frame or it will return an error.
    1:         nsIFrame *lastFrame = this;
    1:         do {
  238:           result = nsFrame::GetNextPrevLineFromeBlockFrame(PresContext(),
    1:                                                            aPos, 
    1:                                                            blockFrame, 
    1:                                                            thisLine, 
    1:                                                            edgeCase //start from thisLine
    1:             );
    1:           if (NS_SUCCEEDED(result) && (!aPos->mResultFrame || aPos->mResultFrame == lastFrame))//we came back to same spot! keep going
    1:           {
    1:             aPos->mResultFrame = nsnull;
    1:             if (aPos->mDirection == eDirPrevious)
    1:               thisLine--;
    1:             else
    1:               thisLine++;
    1:           }
    1:           else //if failure or success with different frame.
80486:             doneLooping = true; //do not continue with while loop
    1: 
    1:           lastFrame = aPos->mResultFrame; //set last frame 
    1: 
    1:           if (NS_SUCCEEDED(result) && aPos->mResultFrame 
    1:             && blockFrame != aPos->mResultFrame)// make sure block element is not the same as the one we had before
    1:           {
    1: /* SPECIAL CHECK FOR TABLE NAVIGATION
    1:   tables need to navigate also and the frame that supports it is nsTableRowGroupFrame which is INSIDE
    1:   nsTableOuterFrame.  if we have stumbled onto an nsTableOuter we need to drill into nsTableRowGroup
    1:   if we hit a header or footer that's ok just go into them,
    1: */
79445:             bool searchTableBool = false;
    1:             if (aPos->mResultFrame->GetType() == nsGkAtoms::tableOuterFrame ||
    1:                 aPos->mResultFrame->GetType() == nsGkAtoms::tableCellFrame)
    1:             {
77154:               nsIFrame *frame = aPos->mResultFrame->GetFirstPrincipalChild();
    1:               //got the table frame now
    1:               while(frame) //ok time to drill down to find iterator
    1:               {
21112:                 iter = frame->GetLineIterator();
21112:                 if (iter)
    1:                 {
    1:                   aPos->mResultFrame = frame;
80486:                   searchTableBool = true;
21112:                   result = NS_OK;
    1:                   break; //while(frame)
    1:                 }
21112:                 result = NS_ERROR_FAILURE;
77154:                 frame = frame->GetFirstPrincipalChild();
    1:               }
    1:             }
21112: 
21112:             if (!searchTableBool) {
21112:               iter = aPos->mResultFrame->GetLineIterator();
21112:               result = iter ? NS_OK : NS_ERROR_FAILURE;
21112:             }
    1:             if (NS_SUCCEEDED(result) && iter)//we've struck another block element!
    1:             {
80486:               doneLooping = false;
    1:               if (aPos->mDirection == eDirPrevious)
    1:                 edgeCase = 1;//far edge, search from end backwards
    1:               else
    1:                 edgeCase = -1;//near edge search from beginning onwards
    1:               thisLine=0;//this line means nothing now.
    1:               //everything else means something so keep looking "inside" the block
    1:               blockFrame = aPos->mResultFrame;
    1: 
    1:             }
    1:             else
    1:             {
    1:               result = NS_OK;//THIS is to mean that everything is ok to the containing while loop
    1:               break;
    1:             }
    1:           }
    1:         } while (!doneLooping);
    1:       }
    1:       return result;
    1:     }
    1: 
    1:     case eSelectParagraph:
    1:       return PeekOffsetParagraph(aPos);
    1: 
    1:     case eSelectBeginLine:
    1:     case eSelectEndLine:
    1:     {
    1:       // Adjusted so that the caret can't get confused when content changes
    1:       nsIFrame* blockFrame = AdjustFrameForSelectionStyles(this);
20200:       PRInt32 thisLine = nsFrame::GetLineNumber(blockFrame, aPos->mScrollViewStop, &blockFrame);
    1:       if (thisLine < 0)
    1:         return NS_ERROR_FAILURE;
21112:       nsAutoLineIterator it = blockFrame->GetLineIterator();
21112:       NS_ASSERTION(it, "GetLineNumber() succeeded but no block frame?");
    1: 
    1:       PRInt32 lineFrameCount;
    1:       nsIFrame *firstFrame;
    1:       nsRect usedRect;
    1:       PRUint32 lineFlags;
    1:       nsIFrame* baseFrame = nsnull;
79445:       bool endOfLine = (eSelectEndLine == aPos->mAmount);
    1:       
    1: #ifdef IBMBIDI
  238:       if (aPos->mVisual && PresContext()->BidiEnabled()) {
79445:         bool lineIsRTL = it->GetDirection();
79445:         bool isReordered;
    1:         nsIFrame *lastFrame;
    1:         result = it->CheckLineOrder(thisLine, &isReordered, &firstFrame, &lastFrame);
    1:         baseFrame = endOfLine ? lastFrame : firstFrame;
 5419:         if (baseFrame) {
    1:           nsBidiLevel embeddingLevel = nsBidiPresUtils::GetFrameEmbeddingLevel(baseFrame);
    1:           // If the direction of the frame on the edge is opposite to that of the line,
    1:           // we'll need to drill down to its opposite end, so reverse endOfLine.
    1:           if ((embeddingLevel & 1) == !lineIsRTL)
    1:             endOfLine = !endOfLine;
 5419:         }
    1:       } else
    1: #endif
    1:       {
    1:         it->GetLine(thisLine, &firstFrame, &lineFrameCount, usedRect, &lineFlags);
    1: 
    1:         nsIFrame* frame = firstFrame;
    1:         for (PRInt32 count = lineFrameCount; count;
    1:              --count, frame = frame->GetNextSibling()) {
    1:           if (!frame->IsGeneratedContentFrame()) {
    1:             baseFrame = frame;
    1:             if (!endOfLine)
    1:               break;
    1:           }
    1:         }
    1:       }
    1:       if (!baseFrame)
    1:         return NS_ERROR_FAILURE;
    1:       FrameTarget targetFrame = DrillDownToSelectionFrame(baseFrame,
    1:                                                           endOfLine);
    1:       FrameContentRange range = GetRangeForFrame(targetFrame.frame);
    1:       aPos->mResultContent = range.content;
    1:       aPos->mContentOffset = endOfLine ? range.end : range.start;
54193:       if (endOfLine && targetFrame.frame->HasTerminalNewline()) {
54193:         // Do not position the caret after the terminating newline if we're
54193:         // trying to move to the end of line (see bug 596506)
54193:         --aPos->mContentOffset;
54193:       }
    1:       aPos->mResultFrame = targetFrame.frame;
    1:       aPos->mAttachForward = (aPos->mContentOffset == range.start);
    1:       if (!range.content)
    1:         return NS_ERROR_FAILURE;
    1:       return NS_OK;
    1:     }
    1: 
    1:     default: 
    1:     {
80486:       NS_ASSERTION(false, "Invalid amount");
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
79445: bool
79445: nsFrame::PeekOffsetNoAmount(bool aForward, PRInt32* aOffset)
    1: {
    1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
    1:   // Sure, we can stop right here.
80486:   return true;
    1: }
    1: 
79445: bool
79445: nsFrame::PeekOffsetCharacter(bool aForward, PRInt32* aOffset,
79445:                              bool aRespectClusters)
    1: {
    1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
    1:   PRInt32 startOffset = *aOffset;
    1:   // A negative offset means "end of frame", which in our case means offset 1.
    1:   if (startOffset < 0)
    1:     startOffset = 1;
    1:   if (aForward == (startOffset == 0)) {
    1:     // We're before the frame and moving forward, or after it and moving backwards:
    1:     // skip to the other side and we're done.
    1:     *aOffset = 1 - startOffset;
80486:     return true;
80486:   }
80486:   return false;
    1: }
    1: 
79445: bool
79445: nsFrame::PeekOffsetWord(bool aForward, bool aWordSelectEatSpace, bool aIsKeyboardSelect,
 5453:                         PRInt32* aOffset, PeekWordState* aState)
    1: {
    1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
    1:   PRInt32 startOffset = *aOffset;
 7679:   // This isn't text, so truncate the context
 7679:   aState->mContext.Truncate();
    1:   if (startOffset < 0)
    1:     startOffset = 1;
    1:   if (aForward == (startOffset == 0)) {
    1:     // We're before the frame and moving forward, or after it and moving backwards.
    1:     // If we're looking for non-whitespace, we found it (without skipping this frame).
 5453:     if (!aState->mAtStart) {
 5453:       if (aState->mLastCharWasPunctuation) {
 5453:         // We're not punctuation, so this is a punctuation boundary.
80486:         if (BreakWordBetweenPunctuation(aState, aForward, false, false, aIsKeyboardSelect))
80486:           return true;
 5453:       } else {
 5453:         // This is not a punctuation boundary.
 5453:         if (aWordSelectEatSpace && aState->mSawBeforeType)
80486:           return true;
 5453:       }
 5453:     }
    1:     // Otherwise skip to the other side and note that we encountered non-whitespace.
    1:     *aOffset = 1 - startOffset;
80486:     aState->Update(false, // not punctuation
80486:                    false     // not whitespace
12505:                    );
    1:     if (!aWordSelectEatSpace)
 5453:       aState->SetSawBeforeType();
    1:   }
80486:   return false;
    1: }
    1: 
79445: bool
12505: nsFrame::BreakWordBetweenPunctuation(const PeekWordState* aState,
79445:                                      bool aForward,
79445:                                      bool aPunctAfter, bool aWhitespaceAfter,
79445:                                      bool aIsKeyboardSelect)
12505: {
12505:   NS_ASSERTION(aPunctAfter != aState->mLastCharWasPunctuation,
12505:                "Call this only at punctuation boundaries");
12505:   if (aState->mLastCharWasWhitespace) {
12505:     // We always stop between whitespace and punctuation
80486:     return true;
12505:   }
70840:   if (!Preferences::GetBool("layout.word_select.stop_at_punctuation")) {
12505:     // When this pref is false, we never stop at a punctuation boundary unless
12505:     // it's after whitespace
80486:     return false;
 5453:   }
 5453:   if (!aIsKeyboardSelect) {
 5453:     // mouse caret movement (e.g. word selection) always stops at every punctuation boundary
80486:     return true;
 5453:   }
79445:   bool afterPunct = aForward ? aState->mLastCharWasPunctuation : aPunctAfter;
12505:   if (!afterPunct) {
12505:     // keyboard caret movement only stops after punctuation (in content order)
80486:     return false;
12505:   }
12505:   // Stop only if we've seen some non-punctuation since the last whitespace;
12505:   // don't stop after punctuation that follows whitespace.
12505:   return aState->mSeenNonPunctuationSinceWhitespace;
 5453: }
 5453: 
    1: NS_IMETHODIMP
79445: nsFrame::CheckVisibility(nsPresContext* , PRInt32 , PRInt32 , bool , bool *, bool *)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: PRInt32
79445: nsFrame::GetLineNumber(nsIFrame *aFrame, bool aLockScroll, nsIFrame** aContainingBlock)
    1: {
    1:   NS_ASSERTION(aFrame, "null aFrame");
  238:   nsFrameManager* frameManager = aFrame->PresContext()->FrameManager();
    1:   nsIFrame *blockFrame = aFrame;
    1:   nsIFrame *thisBlock;
21112:   nsAutoLineIterator it;
    1:   nsresult result = NS_ERROR_FAILURE;
    1:   while (NS_FAILED(result) && blockFrame)
    1:   {
    1:     thisBlock = blockFrame;
    1:     if (thisBlock->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
    1:       //if we are searching for a frame that is not in flow we will not find it. 
    1:       //we must instead look for its placeholder
 6521:       if (thisBlock->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
 6521:         // abspos continuations don't have placeholders, get the fif
 6521:         thisBlock = thisBlock->GetFirstInFlow();
 6521:       }
    1:       thisBlock = frameManager->GetPlaceholderFrameFor(thisBlock);
    1:       if (!thisBlock)
    1:         return -1;
    1:     }  
    1:     blockFrame = thisBlock->GetParent();
    1:     result = NS_OK;
    1:     if (blockFrame) {
20200:       if (aLockScroll && blockFrame->GetType() == nsGkAtoms::scrollFrame)
20200:         return -1;
21112:       it = blockFrame->GetLineIterator();
21112:       if (!it)
21112:         result = NS_ERROR_FAILURE;
    1:     }
    1:   }
    1:   if (!blockFrame || !it)
    1:     return -1;
    1: 
    1:   if (aContainingBlock)
    1:     *aContainingBlock = blockFrame;
21112:   return it->FindLineContaining(thisBlock);
    1: }
    1: 
    1: nsresult
79445: nsIFrame::GetFrameFromDirection(nsDirection aDirection, bool aVisual,
79445:                                 bool aJumpLines, bool aScrollViewStop, 
79445:                                 nsIFrame** aOutFrame, PRInt32* aOutOffset, bool* aOutJumpedLine)
    1: {
21112:   nsresult result;
21112: 
    1:   if (!aOutFrame || !aOutOffset || !aOutJumpedLine)
    1:     return NS_ERROR_NULL_POINTER;
    1:   
  238:   nsPresContext* presContext = PresContext();
    1:   *aOutFrame = nsnull;
    1:   *aOutOffset = 0;
80486:   *aOutJumpedLine = false;
    1: 
    1:   // Find the prev/next selectable frame
79445:   bool selectable = false;
    1:   nsIFrame *traversedFrame = this;
    1:   while (!selectable) {
    1:     nsIFrame *blockFrame;
    1:     
20200:     PRInt32 thisLine = nsFrame::GetLineNumber(traversedFrame, aScrollViewStop, &blockFrame);
    1:     if (thisLine < 0)
    1:       return NS_ERROR_FAILURE;
21112: 
21112:     nsAutoLineIterator it = blockFrame->GetLineIterator();
21112:     NS_ASSERTION(it, "GetLineNumber() succeeded but no block frame?");
    1: 
79445:     bool atLineEdge;
    1:     nsIFrame *firstFrame;
    1:     nsIFrame *lastFrame;
    1: #ifdef IBMBIDI
    1:     if (aVisual && presContext->BidiEnabled()) {
79445:       bool lineIsRTL = it->GetDirection();
79445:       bool isReordered;
    1:       result = it->CheckLineOrder(thisLine, &isReordered, &firstFrame, &lastFrame);
    1:       nsIFrame** framePtr = aDirection == eDirPrevious ? &firstFrame : &lastFrame;
    1:       if (*framePtr) {
    1:         nsBidiLevel embeddingLevel = nsBidiPresUtils::GetFrameEmbeddingLevel(*framePtr);
19264:         if ((((embeddingLevel & 1) && lineIsRTL) || (!(embeddingLevel & 1) && !lineIsRTL)) ==
    1:             (aDirection == eDirPrevious)) {
    1:           nsFrame::GetFirstLeaf(presContext, framePtr);
    1:         } else {
    1:           nsFrame::GetLastLeaf(presContext, framePtr);
    1:         }
    1:         atLineEdge = *framePtr == traversedFrame;
    1:       } else {
80486:         atLineEdge = true;
    1:       }
    1:     } else
    1: #endif
    1:     {
    1:       nsRect  nonUsedRect;
    1:       PRInt32 lineFrameCount;
    1:       PRUint32 lineFlags;
    1:       result = it->GetLine(thisLine, &firstFrame, &lineFrameCount,nonUsedRect,
    1:                            &lineFlags);
    1:       if (NS_FAILED(result))
    1:         return result;
    1: 
    1:       if (aDirection == eDirPrevious) {
    1:         nsFrame::GetFirstLeaf(presContext, &firstFrame);
    1:         atLineEdge = firstFrame == traversedFrame;
    1:       } else { // eDirNext
    1:         lastFrame = firstFrame;
    1:         for (;lineFrameCount > 1;lineFrameCount --){
    1:           result = it->GetNextSiblingOnLine(lastFrame, thisLine);
    1:           if (NS_FAILED(result) || !lastFrame){
43756:             NS_ERROR("should not be reached nsFrame");
    1:             return NS_ERROR_FAILURE;
    1:           }
    1:         }
    1:         nsFrame::GetLastLeaf(presContext, &lastFrame);
    1:         atLineEdge = lastFrame == traversedFrame;
    1:       }
    1:     }
    1: 
    1:     if (atLineEdge) {
80486:       *aOutJumpedLine = true;
    1:       if (!aJumpLines)
    1:         return NS_ERROR_FAILURE; //we are done. cannot jump lines
    1:     }
    1: 
21105:     nsCOMPtr<nsIFrameEnumerator> frameTraversal;
    1:     result = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
    1:                                   presContext, traversedFrame,
    1:                                   eLeaf,
    1:                                   aVisual && presContext->BidiEnabled(),
    1:                                   aScrollViewStop,
80486:                                   true     // aFollowOOFs
    1:                                   );
    1:     if (NS_FAILED(result))
    1:       return result;
    1: 
    1:     if (aDirection == eDirNext)
21105:       frameTraversal->Next();
    1:     else
21105:       frameTraversal->Prev();
21105: 
21105:     traversedFrame = frameTraversal->CurrentItem();
21105:     if (!traversedFrame)
21105:       return NS_ERROR_FAILURE;
    1:     traversedFrame->IsSelectable(&selectable, nsnull);
    1:   } // while (!selectable)
    1: 
    1:   *aOutOffset = (aDirection == eDirNext) ? 0 : -1;
    1: 
    1: #ifdef IBMBIDI
    1:   if (aVisual) {
    1:     PRUint8 newLevel = NS_GET_EMBEDDING_LEVEL(traversedFrame);
    1:     PRUint8 newBaseLevel = NS_GET_BASE_LEVEL(traversedFrame);
    1:     if ((newLevel & 1) != (newBaseLevel & 1)) // The new frame is reverse-direction, go to the other end
    1:       *aOutOffset = -1 - *aOutOffset;
    1:   }
    1: #endif
    1:   *aOutFrame = traversedFrame;
    1:   return NS_OK;
    1: }
    1: 
    1: nsIView* nsIFrame::GetClosestView(nsPoint* aOffset) const
    1: {
    1:   nsPoint offset(0,0);
    1:   for (const nsIFrame *f = this; f; f = f->GetParent()) {
    1:     if (f->HasView()) {
    1:       if (aOffset)
    1:         *aOffset = offset;
    1:       return f->GetView();
    1:     }
    1:     offset += f->GetPosition();
    1:   }
    1: 
    1:   NS_NOTREACHED("No view on any parent?  How did that happen?");
    1:   return nsnull;
    1: }
    1: 
    1: 
    1: /* virtual */ void
    1: nsFrame::ChildIsDirty(nsIFrame* aChild)
    1: {
    1:   NS_NOTREACHED("should never be called on a frame that doesn't inherit from "
    1:                 "nsContainerFrame");
    1: }
    1: 
    1: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsFrame::CreateAccessible()
46338: {
46338:   return nsnull;
    1: }
    1: #endif
    1: 
55021: NS_DECLARE_FRAME_PROPERTY(OverflowAreasProperty,
55021:                           nsIFrame::DestroyOverflowAreas)
39965: 
83439: bool
55021: nsIFrame::ClearOverflowRects()
55021: {
83439:   if (mOverflow.mType == NS_FRAME_OVERFLOW_NONE) {
83439:     return false;
83439:   }
55021:   if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
55021:     Properties().Delete(OverflowAreasProperty());
55021:   }
39965:   mOverflow.mType = NS_FRAME_OVERFLOW_NONE;
83439:   return true;
39965: }
39965: 
11909: /** Create or retrieve the previously stored overflow area, if the frame does 
11909:  * not overflow and no creation is required return nsnull.
11909:  * @return pointer to the overflow area rectangle 
11909:  */
55021: nsOverflowAreas*
55021: nsIFrame::GetOverflowAreasProperty()
55021: {
39965:   FrameProperties props = Properties();
55021:   nsOverflowAreas *overflow =
55021:     static_cast<nsOverflowAreas*>(props.Get(OverflowAreasProperty()));
55021: 
55021:   if (overflow) {
55021:     return overflow; // the property already exists
55021:   }
55021: 
    1:   // The property isn't set yet, so allocate a new rect, set the property,
    1:   // and return the newly allocated rect
55021:   overflow = new nsOverflowAreas;
55021:   props.Set(OverflowAreasProperty(), overflow);
    1:   return overflow;
    1: }
    1: 
26950: /** Set the overflowArea rect, storing it as deltas or a separate rect
26950:  * depending on its size in relation to the primary frame rect.
26950:  */
83439: bool
55021: nsIFrame::SetOverflowAreas(const nsOverflowAreas& aOverflowAreas)
55021: {
55021:   if (mOverflow.mType == NS_FRAME_OVERFLOW_LARGE) {
55021:     nsOverflowAreas *overflow =
55021:       static_cast<nsOverflowAreas*>(Properties().Get(OverflowAreasProperty()));
83439:     bool changed = *overflow != aOverflowAreas;
55021:     *overflow = aOverflowAreas;
55021: 
55021:     // Don't bother with converting to the deltas form if we already
55021:     // have a property.
83439:     return changed;
55021:   }
55021: 
55021:   const nsRect& vis = aOverflowAreas.VisualOverflow();
55021:   PRUint32 l = -vis.x, // left edge: positive delta is leftwards
55021:            t = -vis.y, // top: positive is upwards
55021:            r = vis.XMost() - mRect.width, // right: positive is rightwards
55021:            b = vis.YMost() - mRect.height; // bottom: positive is downwards
68638:   if (aOverflowAreas.ScrollableOverflow().IsEqualEdges(nsRect(nsPoint(0, 0), GetSize())) &&
55021:       l <= NS_FRAME_OVERFLOW_DELTA_MAX &&
26950:       t <= NS_FRAME_OVERFLOW_DELTA_MAX &&
26950:       r <= NS_FRAME_OVERFLOW_DELTA_MAX &&
26950:       b <= NS_FRAME_OVERFLOW_DELTA_MAX &&
55021:       // we have to check these against zero because we *never* want to
55021:       // set a frame as having no overflow in this function.  This is
55021:       // because FinishAndStoreOverflow calls this function prior to
55021:       // SetRect based on whether the overflow areas match aNewSize.
55021:       // In the case where the overflow areas exactly match mRect but
55021:       // do not match aNewSize, we need to store overflow in a property
55021:       // so that our eventual SetRect/SetSize will know that it has to
55021:       // reset our overflow areas.
26950:       (l | t | r | b) != 0) {
83439:     VisualDeltas oldDeltas = mOverflow.mVisualDeltas;
26950:     // It's a "small" overflow area so we store the deltas for each edge
26950:     // directly in the frame, rather than allocating a separate rect.
55021:     // If they're all zero, that's fine; we're setting things to
55021:     // no-overflow.
55021:     mOverflow.mVisualDeltas.mLeft   = l;
55021:     mOverflow.mVisualDeltas.mTop    = t;
55021:     mOverflow.mVisualDeltas.mRight  = r;
55021:     mOverflow.mVisualDeltas.mBottom = b;
83439:     // There was no scrollable overflow before, and there isn't now.
83439:     return oldDeltas != mOverflow.mVisualDeltas;
26950:   } else {
83439:     bool changed = !aOverflowAreas.ScrollableOverflow().IsEqualEdges(nsRect(nsPoint(0, 0), GetSize())) ||
83439:       !aOverflowAreas.VisualOverflow().IsEqualEdges(GetVisualOverflowFromDeltas());
83439: 
26950:     // it's a large overflow area that we need to store as a property
26950:     mOverflow.mType = NS_FRAME_OVERFLOW_LARGE;
55021:     nsOverflowAreas* overflow = GetOverflowAreasProperty();
55021:     NS_ASSERTION(overflow, "should have created areas");
55021:     *overflow = aOverflowAreas;
83439:     return changed;
26950:   }
26950: }
26950: 
79445: inline bool
13951: IsInlineFrame(nsIFrame *aFrame)
13951: {
13951:   nsIAtom *type = aFrame->GetType();
79483:   return type == nsGkAtoms::inlineFrame;
13951: }
13951: 
83439: bool
55024: nsIFrame::FinishAndStoreOverflow(nsOverflowAreas& aOverflowAreas,
55024:                                  nsSize aNewSize)
55024: {
55024:   nsRect bounds(nsPoint(0, 0), aNewSize);
80449:   // Store the passed in overflow area if we are a preserve-3d frame,
80449:   // and it's not just the frame bounds.
90156:   if ((Preserves3D() || HasPerspective()) && (!aOverflowAreas.VisualOverflow().IsEqualEdges(bounds) ||
80449:                         !aOverflowAreas.ScrollableOverflow().IsEqualEdges(bounds))) {
80449:     nsOverflowAreas* initial =
80449:       static_cast<nsOverflowAreas*>(Properties().Get(nsIFrame::InitialOverflowProperty()));
80449:     if (!initial) {
80449:       Properties().Set(nsIFrame::InitialOverflowProperty(),
80449:                        new nsOverflowAreas(aOverflowAreas));
80449:     } else if (initial != &aOverflowAreas) {
80449:       *initial = aOverflowAreas;
80449:     }
80449:   }
55024: 
    1:   // This is now called FinishAndStoreOverflow() instead of 
    1:   // StoreOverflow() because frame-generic ways of adding overflow
    1:   // can happen here, e.g. CSS2 outline and native theme.
87432:   // If the overflow area width or height is nscoord_MAX, then a
87432:   // saturating union may have encounted an overflow, so the overflow may not
87432:   // contain the frame border-box. Don't warn in that case.
55024:   NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
87432:     DebugOnly<nsRect*> r = &aOverflowAreas.Overflow(otype);
    1:     NS_ASSERTION(aNewSize.width == 0 || aNewSize.height == 0 ||
87432:                  r->width == nscoord_MAX || r->height == nscoord_MAX ||
87432:                  r->Contains(nsRect(nsPoint(0,0), aNewSize)),
    1:                  "Computed overflow area must contain frame bounds");
55024:   }
    1: 
46323:   // If we clip our children, clear accumulated overflow area. The
46323:   // children are actually clipped to the padding-box, but since the
46323:   // overflow area should include the entire border-box, just set it to
46323:   // the border-box here.
    1:   const nsStyleDisplay* disp = GetStyleDisplay();
46323:   NS_ASSERTION((disp->mOverflowY == NS_STYLE_OVERFLOW_CLIP) ==
46323:                (disp->mOverflowX == NS_STYLE_OVERFLOW_CLIP),
46323:                "If one overflow is clip, the other should be too");
87630:   if (nsFrame::ApplyOverflowClipping(this, disp)) {
46323:     // The contents are actually clipped to the padding area 
55024:     aOverflowAreas.SetAllTo(bounds);
46323:   }
46323: 
46323:   // Overflow area must always include the frame's top-left and bottom-right,
46323:   // even if the frame rect is empty.
46323:   // Pending a real fix for bug 426879, don't do this for inline frames
46323:   // with zero width.
46323:   if (aNewSize.width != 0 || !IsInlineFrame(this)) {
55024:     NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
55024:       nsRect& o = aOverflowAreas.Overflow(otype);
68638:       o.UnionRectEdges(o, bounds);
55024:     }
87435:   }
46323: 
46323:   // Note that NS_STYLE_OVERFLOW_CLIP doesn't clip the frame background,
46323:   // so we add theme background overflow here so it's not clipped.
 5894:   if (!IsBoxWrapped() && IsThemed(disp)) {
55024:     nsRect r(bounds);
  238:     nsPresContext *presContext = PresContext();
    1:     if (presContext->GetTheme()->
    1:           GetWidgetOverflow(presContext->DeviceContext(), this,
    1:                             disp->mAppearance, &r)) {
73475:       nsRect& vo = aOverflowAreas.VisualOverflow();
73475:       vo.UnionRectEdges(vo, r);
55024:     }
55024:   }
55024: 
55024:   // Nothing in here should affect scrollable overflow.
79445:   bool hasOutlineOrEffects;
55024:   aOverflowAreas.VisualOverflow() =
51893:     ComputeOutlineAndEffectsRect(this, &hasOutlineOrEffects,
55024:                                  aOverflowAreas.VisualOverflow(), aNewSize,
80486:                                  true);
51893: 
51893:   // Absolute position clipping
91411:   bool didHaveClipPropClip = (GetStateBits() & NS_FRAME_HAS_CLIP) != 0;
91411:   nsRect clipPropClipRect;
91411:   bool hasClipPropClip = GetClipPropClipRect(disp, &clipPropClipRect, aNewSize);
91411:   if (hasClipPropClip) {
55024:     NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
55024:       nsRect& o = aOverflowAreas.Overflow(otype);
91411:       o.IntersectRect(o, clipPropClipRect);
55024:     }
51893:     AddStateBits(NS_FRAME_HAS_CLIP);
51893:   } else {
51893:     RemoveStateBits(NS_FRAME_HAS_CLIP);
51893:   }
19284: 
90089:   bool preTransformVisualOverflowChanged =
90089:     !GetVisualOverflowRectRelativeToSelf().IsEqualInterior(aOverflowAreas.VisualOverflow());
90089: 
19284:   /* If we're transformed, transform the overflow rect by the current transformation. */
79445:   bool hasTransform = IsTransformed();
39966:   if (hasTransform) {
87626:     Properties().Set(nsIFrame::PreTransformOverflowAreasProperty(),
87626:                      new nsOverflowAreas(aOverflowAreas));
19284:     /* Since our size might not actually have been computed yet, we need to make sure that we use the
19284:      * correct dimensions by overriding the stored bounding rectangle with the value the caller has
19284:      * ensured us we'll use.
19284:      */
19284:     nsRect newBounds(nsPoint(0, 0), aNewSize);
55024:     // Transform affects both overflow areas.
55024:     NS_FOR_FRAME_OVERFLOW_TYPES(otype) {
55024:       nsRect& o = aOverflowAreas.Overflow(otype);
55024:       o = nsDisplayTransform::TransformRect(o, this, nsPoint(0, 0), &newBounds);
55024:     }
82355:     if (Preserves3DChildren()) {
77286:       ComputePreserve3DChildrenOverflow(aOverflowAreas, newBounds);
92049:     } else if (ChildrenHavePerspective()) {
92049:       RecomputePerspectiveChildrenOverflow(this->GetStyleContext(), &newBounds);
77286:     }
87626:   } else {
87626:     Properties().Delete(nsIFrame::PreTransformOverflowAreasProperty());
92049:     if (ChildrenHavePerspective()) {
92049:       nsRect newBounds(nsPoint(0, 0), aNewSize);
92049:       RecomputePerspectiveChildrenOverflow(this->GetStyleContext(), &newBounds);
92049:     }
92049:   }
92049:     
55024: 
83439:   bool anyOverflowChanged;
55024:   if (aOverflowAreas != nsOverflowAreas(bounds, bounds)) {
83439:     anyOverflowChanged = SetOverflowAreas(aOverflowAreas);
20711:   } else {
83439:     anyOverflowChanged = ClearOverflowRects();
55024:   }
55024: 
90089:   if (preTransformVisualOverflowChanged) {
51893:     if (hasOutlineOrEffects) {
51893:       // When there's an outline or box-shadow or SVG effects,
39966:       // changes to those styles might require repainting of the old and new
39966:       // overflow areas. Repainting of the old overflow area is handled in
20711:       // nsCSSFrameConstructor::DoApplyRenderingChangeToTree in response
20711:       // to nsChangeHint_RepaintFrame. Since the new overflow area is not
20711:       // known at that time, we have to handle it here.
20711:       // If the overflow area hasn't changed, then we don't have to do
20711:       // anything here since repainting the old overflow area was enough.
20711:       // If there is no outline or other effects now, then we don't have
20711:       // to do anything here since removing those styles can't require
20711:       // repainting of areas that weren't in the old overflow area.
55024:       Invalidate(aOverflowAreas.VisualOverflow());
91411:     } else if (hasClipPropClip || didHaveClipPropClip) {
51893:       // If we are (or were) clipped by the 'clip' property, and our
51893:       // overflow area changes, it might be because the clipping changed.
51893:       // The nsChangeHint_RepaintFrame for the style change will only
51893:       // repaint the old overflow area, so if the overflow area has
51893:       // changed (in particular, if it grows), we have to repaint the
51893:       // new area here.
55024:       Invalidate(aOverflowAreas.VisualOverflow());
90089:     }
90089:   }
90089:   if (anyOverflowChanged && hasTransform) {
51893:     // When there's a transform, changes to that style might require
51893:     // repainting of the old and new overflow areas in the widget.
51893:     // Repainting of the frame itself will not be required if there's
51893:     // a retained layer, so we can call InvalidateLayer here
51893:     // which will avoid repainting ThebesLayers if possible.
51893:     // nsCSSFrameConstructor::DoApplyRenderingChangeToTree repaints
51893:     // the old overflow area in the widget in response to
51893:     // nsChangeHint_UpdateTransformLayer. But since the new overflow
51893:     // area is not known at that time, we have to handle it here.
51893:     // If the overflow area hasn't changed, then it doesn't matter that
51893:     // we didn't reach here since repainting the old overflow area was enough.
51893:     // If there is no transform now, then the container layer for
51893:     // the transform will go away and the frame contents will change
51893:     // ThebesLayers, forcing it to be invalidated, so it doesn't matter
51893:     // that we didn't reach here.
55024:     InvalidateLayer(aOverflowAreas.VisualOverflow(),
55024:                     nsDisplayItem::TYPE_TRANSFORM);
51893:   }
83439: 
83439:   return anyOverflowChanged;
    1: }
    1: 
90156: void
92049: nsIFrame::RecomputePerspectiveChildrenOverflow(const nsStyleContext* aStartStyle, const nsRect* aBounds)
90156: {
90156:   // Children may check our size when getting our transform, make sure it's valid.
90156:   nsSize oldSize = GetSize();
90156:   if (aBounds) {
90156:     SetSize(aBounds->Size());
90156:   }
90156:   nsIFrame::ChildListIterator lists(this);
90156:   for (; !lists.IsDone(); lists.Next()) {
90156:     nsFrameList::Enumerator childFrames(lists.CurrentList());
90156:     for (; !childFrames.AtEnd(); childFrames.Next()) {
90156:       nsIFrame* child = childFrames.get();
90156:       if (child->HasPerspective()) {
90156:         nsOverflowAreas* overflow = 
90156:           static_cast<nsOverflowAreas*>(child->Properties().Get(nsIFrame::InitialOverflowProperty()));
90156:         nsRect bounds(nsPoint(0, 0), child->GetSize());
90156:         if (overflow) {
90156:           child->FinishAndStoreOverflow(*overflow, bounds.Size());
90156:         } else {
90156:           nsOverflowAreas boundsOverflow;
90156:           boundsOverflow.SetAllTo(bounds);
90156:           child->FinishAndStoreOverflow(boundsOverflow, bounds.Size());
90156:         }
92049:       } else if (child->GetStyleContext()->GetParent() == aStartStyle ||
92049:                  child->GetStyleContext() == aStartStyle) {
92049:         // Recurse into frames with the same style context, or a direct
92049:         // child style context.
92049:         child->RecomputePerspectiveChildrenOverflow(aStartStyle, nsnull);
90156:       }
90156:     }
90156:   }
90156:   // Restore our old size just in case something depends on this elesewhere.
90156:   SetSize(oldSize);
90156: }
90156: 
80449: /* The overflow rects for leaf nodes in a preserve-3d hierarchy depends on
80449:  * the mRect value for their parents (since we use their transform, and transform
80449:  * depends on this for transform-origin etc). These weren't necessarily correct
80449:  * when we reflowed initially, so walk over all preserve-3d children and repeat the
80449:  * overflow calculation.
80449:  */
80449: static void
80449: RecomputePreserve3DChildrenOverflow(nsIFrame* aFrame, const nsRect* aBounds)
80449: {
80449:   // Children may check our size when getting our transform, make sure it's valid.
80449:   nsSize oldSize = aFrame->GetSize();
80449:   if (aBounds) {
80449:     aFrame->SetSize(aBounds->Size());
80449:   }
80449:   nsIFrame::ChildListIterator lists(aFrame);
80449:   for (; !lists.IsDone(); lists.Next()) {
80449:     nsFrameList::Enumerator childFrames(lists.CurrentList());
80449:     for (; !childFrames.AtEnd(); childFrames.Next()) {
80449:       nsIFrame* child = childFrames.get();
80449:       if (child->Preserves3DChildren()) {
80449:         RecomputePreserve3DChildrenOverflow(child, NULL);
80449:       } else if (child->Preserves3D()) {
80449:         nsOverflowAreas* overflow = 
80449:           static_cast<nsOverflowAreas*>(child->Properties().Get(nsIFrame::InitialOverflowProperty()));
80449:         nsRect bounds(nsPoint(0, 0), child->GetSize());
80449:         if (overflow) {
80449:           child->FinishAndStoreOverflow(*overflow, bounds.Size());
80449:         } else {
80449:           nsOverflowAreas boundsOverflow;
80449:           boundsOverflow.SetAllTo(bounds);
80449:           child->FinishAndStoreOverflow(boundsOverflow, bounds.Size());
80449:         }
80449:       }
80449:     }
80449:   }
80449:   // Restore our old size just in case something depends on this elesewhere.
80449:   aFrame->SetSize(oldSize);
80449:  
80449:   // Only repeat computing our overflow in recursive calls since the initial caller is still
80449:   // in the middle of doing this and we don't want an infinite loop.
80449:   if (!aBounds) {
80449:     nsOverflowAreas* overflow = 
80449:       static_cast<nsOverflowAreas*>(aFrame->Properties().Get(nsIFrame::InitialOverflowProperty()));
80449:     nsRect bounds(nsPoint(0, 0), aFrame->GetSize());
80449:     if (overflow) {
80449:       overflow->UnionAllWith(bounds); 
80449:       aFrame->FinishAndStoreOverflow(*overflow, bounds.Size());
80449:     } else {
80449:       nsOverflowAreas boundsOverflow;
80449:       boundsOverflow.SetAllTo(bounds);
80449:       aFrame->FinishAndStoreOverflow(boundsOverflow, bounds.Size());
80449:     }
80449:   }
80449: }
80449: 
    1: void
77286: nsIFrame::ComputePreserve3DChildrenOverflow(nsOverflowAreas& aOverflowAreas, const nsRect& aBounds)
77286: {
77286:   // When we are preserving 3d we need to iterate over all children separately.
77286:   // If the child also preserves 3d then their overflow will already been in our
77286:   // coordinate space, otherwise we need to transform.
80449: 
80449:   // If we're the top frame in a preserve 3d chain then we need to recalculate the overflow
80449:   // areas of all our children since they will have used our size/offset which was invalid at
80449:   // the time.
80449:   if (!Preserves3D()) {
80449:     RecomputePreserve3DChildrenOverflow(this, &aBounds);
80449:   }
80449: 
77286:   nsRect childVisual;
77286:   nsRect childScrollable;
77286:   nsIFrame::ChildListIterator lists(this);
77286:   for (; !lists.IsDone(); lists.Next()) {
77286:     nsFrameList::Enumerator childFrames(lists.CurrentList());
77286:     for (; !childFrames.AtEnd(); childFrames.Next()) {
77286:       nsIFrame* child = childFrames.get();
80449:       nsPoint offset = child->GetPosition();
80449:       nsRect visual = child->GetVisualOverflowRect();
80449:       nsRect scrollable = child->GetScrollableOverflowRect();
80449:       visual.MoveBy(offset);
80449:       scrollable.MoveBy(offset);
77286:       if (child->Preserves3D()) {
80449:         childVisual = childVisual.Union(visual);
80449:         childScrollable = childScrollable.Union(scrollable);
77286:       } else {
77286:         childVisual = 
80449:           childVisual.Union(nsDisplayTransform::TransformRect(visual, 
77286:                             this, nsPoint(0,0), &aBounds));
77286:         childScrollable = 
80449:           childScrollable.Union(nsDisplayTransform::TransformRect(scrollable,
77286:                                 this, nsPoint(0,0), &aBounds));
77286:       }
77286:     }
77286:   }
77286: 
82355:   aOverflowAreas.Overflow(eVisualOverflow) = aOverflowAreas.Overflow(eVisualOverflow).Union(childVisual);
82355:   aOverflowAreas.Overflow(eScrollableOverflow) = aOverflowAreas.Overflow(eScrollableOverflow).Union(childScrollable);
77286: }
77286: 
77286: void
55021: nsFrame::ConsiderChildOverflow(nsOverflowAreas& aOverflowAreas,
    1:                                nsIFrame* aChildFrame)
    1: {
55021:   aOverflowAreas.UnionWith(aChildFrame->GetOverflowAreas() +
55021:                            aChildFrame->GetPosition());
    1: }
    1: 
    1: /**
34459:  * This function takes a "special" frame and _if_ that frame is an anonymous
34459:  * block created by an ib split it returns the block's preceding inline.  This
34459:  * is needed because the split inline's style context is the parent of the
34459:  * anonymous block's style context.
    1:  *
34459:  * If aFrame is not an anonymous block, null is returned.
    1:  */
34459: static nsIFrame*
90155: GetIBSpecialSiblingForAnonymousBlock(const nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "Must have a non-null frame!");
    1:   NS_ASSERTION(aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL,
    1:                "GetIBSpecialSibling should not be called on a non-special frame");
    1: 
34387:   nsIAtom* type = aFrame->GetStyleContext()->GetPseudo();
19125:   if (type != nsCSSAnonBoxes::mozAnonymousBlock &&
19125:       type != nsCSSAnonBoxes::mozAnonymousPositionedBlock) {
34459:     // it's not an anonymous block
34459:     return nsnull;
34459:   }
34459: 
34459:   // Find the first continuation of the frame.  (Ugh.  This ends up
    1:   // being O(N^2) when it is called O(N) times.)
34459:   aFrame = aFrame->GetFirstContinuation();
    1: 
    1:   /*
    1:    * Now look up the nsGkAtoms::IBSplitSpecialPrevSibling
34459:    * property.
    1:    */
39965:   nsIFrame *specialSibling = static_cast<nsIFrame*>
39965:     (aFrame->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
34459:   NS_ASSERTION(specialSibling, "Broken frame tree?");
34459:   return specialSibling;
    1: }
    1: 
    1: /**
    1:  * Get the parent, corrected for the mangled frame tree resulting from
    1:  * having a block within an inline.  The result only differs from the
    1:  * result of |GetParent| when |GetParent| returns an anonymous block
    1:  * that was created for an element that was 'display: inline' because
    1:  * that element contained a block.
    1:  *
    1:  * Also skip anonymous scrolled-content parents; inherit directly from the
    1:  * outer scroll frame.
    1:  */
78202: static nsIFrame*
78202: GetCorrectedParent(const nsIFrame* aFrame)
    1: {
    1:   nsIFrame *parent = aFrame->GetParent();
  549:   if (!parent) {
78202:     return nsnull;
78202:   }
78202: 
  553:   // Outer tables are always anon boxes; if we're in here for an outer
  553:   // table, that actually means its the _inner_ table that wants to
  553:   // know its parent.  So get the pseudo of the inner in that case.
78202:   nsIAtom* pseudo = aFrame->GetStyleContext()->GetPseudo();
  553:   if (pseudo == nsCSSAnonBoxes::tableOuter) {
78202:     pseudo = aFrame->GetFirstPrincipalChild()->GetStyleContext()->GetPseudo();
78202:   }
78202:   return nsFrame::CorrectStyleParentFrame(parent, pseudo);
  549: }
  549: 
  549: /* static */
  549: nsIFrame*
  549: nsFrame::CorrectStyleParentFrame(nsIFrame* aProspectiveParent,
  549:                                  nsIAtom* aChildPseudo)
  549: {
  549:   NS_PRECONDITION(aProspectiveParent, "Must have a prospective parent");
  549: 
  549:   // Anon boxes are parented to their actual parent already, except
  549:   // for non-elements.  Those should not be treated as an anon box.
  549:   if (aChildPseudo && aChildPseudo != nsCSSAnonBoxes::mozNonElement &&
  549:       nsCSSAnonBoxes::IsAnonBox(aChildPseudo)) {
  549:     NS_ASSERTION(aChildPseudo != nsCSSAnonBoxes::mozAnonymousBlock &&
  549:                  aChildPseudo != nsCSSAnonBoxes::mozAnonymousPositionedBlock,
  549:                  "Should have dealt with kids that have NS_FRAME_IS_SPECIAL "
  549:                  "elsewhere");
  549:     return aProspectiveParent;
  549:   }
  549: 
 7046:   // Otherwise, walk up out of all anon boxes.  For placeholder frames, walk out
40137:   // of all pseudo-elements as well.  Otherwise ReparentStyleContext could cause
 3599:   // style data to be out of sync with the frame tree.
  549:   nsIFrame* parent = aProspectiveParent;
  549:   do {
  549:     if (parent->GetStateBits() & NS_FRAME_IS_SPECIAL) {
34459:       nsIFrame* sibling = GetIBSpecialSiblingForAnonymousBlock(parent);
  549: 
  549:       if (sibling) {
34459:         // |parent| was a block in an {ib} split; use the inline as
  549:         // |the style parent.
  549:         parent = sibling;
  549:       }
  549:     }
  549:       
34387:     nsIAtom* parentPseudo = parent->GetStyleContext()->GetPseudo();
 3599:     if (!parentPseudo ||
 3599:         (!nsCSSAnonBoxes::IsAnonBox(parentPseudo) &&
 3599:          // nsPlaceholderFrame pases in nsGkAtoms::placeholderFrame for
 3599:          // aChildPseudo (even though that's not a valid pseudo-type) just to
 3599:          // trigger this behavior of walking up to the nearest non-pseudo
 3599:          // ancestor.
 3599:          aChildPseudo != nsGkAtoms::placeholderFrame)) {
  549:       return parent;
  549:     }
  549: 
    1:     parent = parent->GetParent();
  549:   } while (parent);
  549: 
34387:   if (aProspectiveParent->GetStyleContext()->GetPseudo() ==
18953:       nsCSSAnonBoxes::viewportScroll) {
18953:     // aProspectiveParent is the scrollframe for a viewport
18953:     // and the kids are the anonymous scrollbars
18953:     return aProspectiveParent;
18953:   }
18953: 
18953:   // We can get here if the root element is absolutely positioned.
18953:   // We can't test for this very accurately, but it can only happen
18953:   // when the prospective parent is a canvas frame.
18953:   NS_ASSERTION(aProspectiveParent->GetType() == nsGkAtoms::canvasFrame,
18888:                "Should have found a parent before this");
18953:   return nsnull;
18885: }
18885: 
78202: nsIFrame*
90155: nsFrame::DoGetParentStyleContextFrame() const
78202: {
    1:   if (mContent && !mContent->GetParent() &&
34387:       !GetStyleContext()->GetPseudo()) {
    1:     // we're a frame for the root.  We have no style context parent.
78202:     return nsnull;
    1:   }
    1:   
    1:   if (!(mState & NS_FRAME_OUT_OF_FLOW)) {
    1:     /*
34459:      * If this frame is an anonymous block created when an inline with a block
34459:      * inside it got split, then the parent style context is on its preceding
34459:      * inline. We can get to it using GetIBSpecialSiblingForAnonymousBlock.
    1:      */
    1:     if (mState & NS_FRAME_IS_SPECIAL) {
78202:       nsIFrame* specialSibling = GetIBSpecialSiblingForAnonymousBlock(this);
78202:       if (specialSibling) {
78202:         return specialSibling;
    1:       }
  549:     }
    1: 
    1:     // If this frame is one of the blocks that split an inline, we must
    1:     // return the "special" inline parent, i.e., the parent that this
    1:     // frame would have if we didn't mangle the frame structure.
78202:     return GetCorrectedParent(this);
    1:   }
    1: 
    1:   // For out-of-flow frames, we must resolve underneath the
    1:   // placeholder's parent.
90155:   const nsIFrame* oofFrame = this;
32108:   if ((oofFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
32108:       GetPrevInFlow()) {
32108:     // Out of flows that are continuations do not
 6521:     // have placeholders. Use their first-in-flow's placeholder.
 6521:     oofFrame = oofFrame->GetFirstInFlow();
 6521:   }
78202:   nsIFrame* placeholder = oofFrame->PresContext()->FrameManager()->
78202:                             GetPlaceholderFrameFor(oofFrame);
    1:   if (!placeholder) {
    1:     NS_NOTREACHED("no placeholder frame for out-of-flow frame");
78202:     return GetCorrectedParent(this);
78202:   }
78202:   return placeholder->GetParentStyleContextFrame();
78202: }
    1: 
    1: void
    1: nsFrame::GetLastLeaf(nsPresContext* aPresContext, nsIFrame **aFrame)
    1: {
    1:   if (!aFrame || !*aFrame)
    1:     return;
    1:   nsIFrame *child = *aFrame;
    1:   //if we are a block frame then go for the last line of 'this'
    1:   while (1){
77154:     child = child->GetFirstPrincipalChild();
    1:     if (!child)
    1:       return;//nothing to do
    1:     nsIFrame* siblingFrame;
    1:     nsIContent* content;
    1:     //ignore anonymous elements, e.g. mozTableAdd* mozTableRemove*
    1:     //see bug 278197 comment #12 #13 for details
    1:     while ((siblingFrame = child->GetNextSibling()) &&
    1:            (content = siblingFrame->GetContent()) &&
16126:            !content->IsRootOfNativeAnonymousSubtree())
    1:       child = siblingFrame;
    1:     *aFrame = child;
    1:   }
    1: }
    1: 
    1: void
    1: nsFrame::GetFirstLeaf(nsPresContext* aPresContext, nsIFrame **aFrame)
    1: {
    1:   if (!aFrame || !*aFrame)
    1:     return;
    1:   nsIFrame *child = *aFrame;
    1:   while (1){
77154:     child = child->GetFirstPrincipalChild();
    1:     if (!child)
    1:       return;//nothing to do
    1:     *aFrame = child;
    1:   }
    1: }
    1: 
10152: /* virtual */ const void*
    1: nsFrame::GetStyleDataExternal(nsStyleStructID aSID) const
    1: {
    1:   NS_ASSERTION(mStyleContext, "unexpected null pointer");
    1:   return mStyleContext->GetStyleData(aSID);
    1: }
    1: 
79445: /* virtual */ bool
79445: nsIFrame::IsFocusable(PRInt32 *aTabIndex, bool aWithMouse)
    1: {
    1:   PRInt32 tabIndex = -1;
    1:   if (aTabIndex) {
    1:     *aTabIndex = -1; // Default for early return is not focusable
    1:   }
79445:   bool isFocusable = false;
    1: 
80910:   if (mContent && mContent->IsElement() && IsVisibleConsideringAncestors()) {
    1:     const nsStyleUserInterface* ui = GetStyleUserInterface();
    1:     if (ui->mUserFocus != NS_STYLE_USER_FOCUS_IGNORE &&
    1:         ui->mUserFocus != NS_STYLE_USER_FOCUS_NONE) {
    1:       // Pass in default tabindex of -1 for nonfocusable and 0 for focusable
    1:       tabIndex = 0;
    1:     }
41071:     isFocusable = mContent->IsFocusable(&tabIndex, aWithMouse);
    1:     if (!isFocusable && !aWithMouse &&
    1:         GetType() == nsGkAtoms::scrollFrame &&
33329:         mContent->IsHTML() &&
16126:         !mContent->IsRootOfNativeAnonymousSubtree() &&
16126:         mContent->GetParent() &&
    1:         !mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
    1:       // Elements with scrollable view are focusable with script & tabbable
    1:       // Otherwise you couldn't scroll them with keyboard, which is
    1:       // an accessibility issue (e.g. Section 508 rules)
    1:       // However, we don't make them to be focusable with the mouse,
    1:       // because the extra focus outlines are considered unnecessarily ugly.
    1:       // When clicked on, the selection position within the element 
    1:       // will be enough to make them keyboard scrollable.
23554:       nsIScrollableFrame *scrollFrame = do_QueryFrame(this);
68635:       if (scrollFrame &&
77134:           scrollFrame->GetScrollbarStyles() != nsIScrollableFrame::ScrollbarStyles(NS_STYLE_OVERFLOW_HIDDEN, NS_STYLE_OVERFLOW_HIDDEN) &&
77134:           !scrollFrame->GetScrollRange().IsEqualEdges(nsRect(0, 0, 0, 0))) {
    1:           // Scroll bars will be used for overflow
80486:           isFocusable = true;
    1:           tabIndex = 0;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aTabIndex) {
    1:     *aTabIndex = tabIndex;
    1:   }
    1:   return isFocusable;
    1: }
    1: 
    1: /**
80486:  * @return true if this text frame ends with a newline character.  It
80486:  * should return false if this is not a text frame.
    1:  */
79445: bool
    1: nsIFrame::HasTerminalNewline() const
    1: {
80486:   return false;
    1: }
    1: 
    1: /* static */
    1: void nsFrame::FillCursorInformationFromStyle(const nsStyleUserInterface* ui,
    1:                                              nsIFrame::Cursor& aCursor)
    1: {
    1:   aCursor.mCursor = ui->mCursor;
80486:   aCursor.mHaveHotspot = false;
    1:   aCursor.mHotspotX = aCursor.mHotspotY = 0.0f;
    1: 
    1:   for (nsCursorImage *item = ui->mCursorArray,
    1:                  *item_end = ui->mCursorArray + ui->mCursorArrayLength;
    1:        item < item_end; ++item) {
    1:     PRUint32 status;
50819:     nsresult rv = item->GetImage()->GetImageStatus(&status);
32424:     if (NS_SUCCEEDED(rv) && (status & imgIRequest::STATUS_LOAD_COMPLETE)) {
    1:       // This is the one we want
50819:       item->GetImage()->GetImage(getter_AddRefs(aCursor.mContainer));
    1:       aCursor.mHaveHotspot = item->mHaveHotspot;
    1:       aCursor.mHotspotX = item->mHotspotX;
    1:       aCursor.mHotspotY = item->mHotspotY;
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFrame::RefreshSizeCache(nsBoxLayoutState& aState)
    1: {
  256:   // XXXbz this comment needs some rewriting to make sense in the
  256:   // post-reflow-branch world.
    1:   
    1:   // Ok we need to compute our minimum, preferred, and maximum sizes.
    1:   // 1) Maximum size. This is easy. Its infinite unless it is overloaded by CSS.
    1:   // 2) Preferred size. This is a little harder. This is the size the block would be 
    1:   //      if it were laid out on an infinite canvas. So we can get this by reflowing
    1:   //      the block with and INTRINSIC width and height. We can also do a nice optimization
    1:   //      for incremental reflow. If the reflow is incremental then we can pass a flag to 
    1:   //      have the block compute the preferred width for us! Preferred height can just be
    1:   //      the minimum height;
    1:   // 3) Minimum size. This is a toughy. We can pass the block a flag asking for the max element
    1:   //    size. That would give us the width. Unfortunately you can only ask for a maxElementSize
    1:   //    during an incremental reflow. So on other reflows we will just have to use 0.
    1:   //    The min height on the other hand is fairly easy we need to get the largest
    1:   //    line height. This can be done with the line iterator.
    1: 
    1:   // if we do have a rendering context
    1:   nsresult rv = NS_OK;
68481:   nsRenderingContext* rendContext = aState.GetRenderingContext();
    1:   if (rendContext) {
    1:     nsPresContext* presContext = aState.PresContext();
    1: 
    1:     // If we don't have any HTML constraints and it's a resize, then nothing in the block
    1:     // could have changed, so no refresh is necessary.
    1:     nsBoxLayoutMetrics* metrics = BoxMetrics();
    1:     if (!DoesNeedRecalc(metrics->mBlockPrefSize))
    1:       return NS_OK;
    1: 
    1:     // get the old rect.
    1:     nsRect oldRect = GetRect();
    1: 
    1:     // the rect we plan to size to.
    1:     nsRect rect(oldRect);
    1: 
    1:     nsMargin bp(0,0,0,0);
    1:     GetBorderAndPadding(bp);
    1: 
88122:     {
88122:       // If we're a container for font size inflation, then shrink
88122:       // wrapping inside of us should not apply font size inflation.
96285:       AutoMaybeDisableFontInflation an(this);
88122: 
88122:       metrics->mBlockPrefSize.width =
88122:         GetPrefWidth(rendContext) + bp.LeftRight();
88122:       metrics->mBlockMinSize.width =
88122:         GetMinWidth(rendContext) + bp.LeftRight();
88122:     }
    1: 
    1:     // do the nasty.
    1:     nsHTMLReflowMetrics desiredSize;
    1:     rv = BoxReflow(aState, presContext, desiredSize, rendContext,
    1:                    rect.x, rect.y,
    1:                    metrics->mBlockPrefSize.width, NS_UNCONSTRAINEDSIZE);
    1: 
    1:     nsRect newRect = GetRect();
    1: 
    1:     // make sure we draw any size change
    1:     if (oldRect.width != newRect.width || oldRect.height != newRect.height) {
    1:       newRect.x = 0;
    1:       newRect.y = 0;
    1:       Redraw(aState, &newRect);
    1:     }
    1: 
13001:     metrics->mBlockMinSize.height = 0;
13001:     // ok we need the max ascent of the items on the line. So to do this
13001:     // ask the block for its line iterator. Get the max ascent.
21112:     nsAutoLineIterator lines = GetLineIterator();
13001:     if (lines) 
13001:     {
13001:       metrics->mBlockMinSize.height = 0;
13001:       int count = 0;
13001:       nsIFrame* firstFrame = nsnull;
13001:       PRInt32 framesOnLine;
13001:       nsRect lineBounds;
13001:       PRUint32 lineFlags;
13001: 
13001:       do {
13001:          lines->GetLine(count, &firstFrame, &framesOnLine, lineBounds, &lineFlags);
13001: 
13001:          if (lineBounds.height > metrics->mBlockMinSize.height)
13001:            metrics->mBlockMinSize.height = lineBounds.height;
13001: 
13001:          count++;
13001:       } while(firstFrame);
13001:     } else {
13001:       metrics->mBlockMinSize.height = desiredSize.height;
13001:     }
13001: 
13001:     metrics->mBlockPrefSize.height = metrics->mBlockMinSize.height;
    1: 
    1:     if (desiredSize.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE) {
    1:       if (!nsLayoutUtils::GetFirstLineBaseline(this, &metrics->mBlockAscent))
    1:         metrics->mBlockAscent = GetBaseline();
    1:     } else {
    1:       metrics->mBlockAscent = desiredSize.ascent;
    1:     }
    1: 
    1: #ifdef DEBUG_adaptor
    1:     printf("min=(%d,%d), pref=(%d,%d), ascent=%d\n", metrics->mBlockMinSize.width,
    1:                                                      metrics->mBlockMinSize.height,
    1:                                                      metrics->mBlockPrefSize.width,
    1:                                                      metrics->mBlockPrefSize.height,
    1:                                                      metrics->mBlockAscent);
    1: #endif
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
21112: /* virtual */ nsILineIterator*
21112: nsFrame::GetLineIterator()
21112: {
21112:   return nsnull;
21112: }
21112: 
    1: nsSize
    1: nsFrame::GetPrefSize(nsBoxLayoutState& aState)
    1: {
    1:   nsSize size(0,0);
    1:   DISPLAY_PREF_SIZE(this, size);
    1:   // If the size is cached, and there are no HTML constraints that we might
    1:   // be depending on, then we just return the cached size.
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mPrefSize)) {
39604:     return metrics->mPrefSize;
    1:   }
    1: 
87626:   if (IsCollapsed())
    1:     return size;
    1: 
    1:   // get our size in CSS.
79445:   bool widthSet, heightSet;
79445:   bool completelyRedefined = nsIBox::AddCSSPrefSize(this, size, widthSet, heightSet);
    1: 
    1:   // Refresh our caches with new sizes.
    1:   if (!completelyRedefined) {
    1:     RefreshSizeCache(aState);
39604:     nsSize blockSize = metrics->mBlockPrefSize;
    1: 
    1:     // notice we don't need to add our borders or padding
    1:     // in. That's because the block did it for us.
39604:     if (!widthSet)
39604:       size.width = blockSize.width;
39604:     if (!heightSet)
39604:       size.height = blockSize.height;
    1:   }
    1: 
    1:   metrics->mPrefSize = size;
    1:   return size;
    1: }
    1: 
    1: nsSize
    1: nsFrame::GetMinSize(nsBoxLayoutState& aState)
    1: {
    1:   nsSize size(0,0);
    1:   DISPLAY_MIN_SIZE(this, size);
    1:   // Don't use the cache if we have HTMLReflowState constraints --- they might have changed
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mMinSize)) {
    1:     size = metrics->mMinSize;
    1:     return size;
    1:   }
    1: 
87626:   if (IsCollapsed())
    1:     return size;
    1: 
    1:   // get our size in CSS.
79445:   bool widthSet, heightSet;
79445:   bool completelyRedefined =
39604:     nsIBox::AddCSSMinSize(aState, this, size, widthSet, heightSet);
    1: 
    1:   // Refresh our caches with new sizes.
    1:   if (!completelyRedefined) {
    1:     RefreshSizeCache(aState);
39604:     nsSize blockSize = metrics->mBlockMinSize;
39604: 
39604:     if (!widthSet)
39604:       size.width = blockSize.width;
39604:     if (!heightSet)
39604:       size.height = blockSize.height;
    1:   }
    1: 
    1:   metrics->mMinSize = size;
    1:   return size;
    1: }
    1: 
    1: nsSize
    1: nsFrame::GetMaxSize(nsBoxLayoutState& aState)
    1: {
    1:   nsSize size(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
    1:   DISPLAY_MAX_SIZE(this, size);
    1:   // Don't use the cache if we have HTMLReflowState constraints --- they might have changed
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mMaxSize)) {
    1:     size = metrics->mMaxSize;
    1:     return size;
    1:   }
    1: 
87626:   if (IsCollapsed())
    1:     return size;
    1: 
    1:   size = nsBox::GetMaxSize(aState);
    1:   metrics->mMaxSize = size;
    1: 
    1:   return size;
    1: }
    1: 
    1: nscoord
    1: nsFrame::GetFlex(nsBoxLayoutState& aState)
    1: {
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mFlex))
    1:      return metrics->mFlex;
    1: 
    1:   metrics->mFlex = nsBox::GetFlex(aState);
    1: 
    1:   return metrics->mFlex;
    1: }
    1: 
    1: nscoord
    1: nsFrame::GetBoxAscent(nsBoxLayoutState& aState)
    1: {
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   if (!DoesNeedRecalc(metrics->mAscent))
    1:     return metrics->mAscent;
    1: 
87626:   if (IsCollapsed()) {
    1:     metrics->mAscent = 0;
    1:   } else {
    1:     // Refresh our caches with new sizes.
    1:     RefreshSizeCache(aState);
    1:     metrics->mAscent = metrics->mBlockAscent;
    1:   }
    1: 
    1:   return metrics->mAscent;
    1: }
    1: 
    1: nsresult
    1: nsFrame::DoLayout(nsBoxLayoutState& aState)
    1: {
    1:   nsRect ourRect(mRect);
    1: 
68481:   nsRenderingContext* rendContext = aState.GetRenderingContext();
    1:   nsPresContext* presContext = aState.PresContext();
    1:   nsHTMLReflowMetrics desiredSize;
    1:   nsresult rv = NS_OK;
    1:  
    1:   if (rendContext) {
    1: 
    1:     rv = BoxReflow(aState, presContext, desiredSize, rendContext,
    1:                    ourRect.x, ourRect.y, ourRect.width, ourRect.height);
    1: 
87626:     if (IsCollapsed()) {
    1:       SetSize(nsSize(0, 0));
    1:     } else {
    1: 
    1:       // if our child needs to be bigger. This might happend with
    1:       // wrapping text. There is no way to predict its height until we
    1:       // reflow it. Now that we know the height reshuffle upward.
    1:       if (desiredSize.width > ourRect.width ||
    1:           desiredSize.height > ourRect.height) {
    1: 
    1: #ifdef DEBUG_GROW
    1:         DumpBox(stdout);
    1:         printf(" GREW from (%d,%d) -> (%d,%d)\n",
    1:                ourRect.width, ourRect.height,
    1:                desiredSize.width, desiredSize.height);
    1: #endif
    1: 
    1:         if (desiredSize.width > ourRect.width)
    1:           ourRect.width = desiredSize.width;
    1: 
    1:         if (desiredSize.height > ourRect.height)
    1:           ourRect.height = desiredSize.height;
    1:       }
    1: 
    1:       // ensure our size is what we think is should be. Someone could have
    1:       // reset the frame to be smaller or something dumb like that. 
    1:       SetSize(nsSize(ourRect.width, ourRect.height));
    1:     }
    1:   }
    1: 
35703:   // Should we do this if IsCollapsed() is true?
35703:   nsSize size(GetSize());
55039:   desiredSize.width = size.width;
55039:   desiredSize.height = size.height;
55039:   desiredSize.UnionOverflowAreasWithDesiredBounds();
92006: 
92006:   if (HasAbsolutelyPositionedChildren()) {
92006:     // Set up a |reflowState| to pass into ReflowAbsoluteFrames
92006:     nsHTMLReflowState reflowState(aState.PresContext(), this,
92006:                                   aState.GetRenderingContext(),
96492:                                   nsSize(size.width, NS_UNCONSTRAINEDSIZE),
96492:                                   nsHTMLReflowState::DUMMY_PARENT_REFLOW_STATE);
92006: 
92006:     // Set up a |reflowStatus| to pass into ReflowAbsoluteFrames
92006:     // (just a dummy value; hopefully that's OK)
92006:     nsReflowStatus reflowStatus = NS_FRAME_COMPLETE;
92006:     ReflowAbsoluteFrames(aState.PresContext(), desiredSize,
92006:                          reflowState, reflowStatus);
92006:   }
92006: 
55024:   FinishAndStoreOverflow(desiredSize.mOverflowAreas, size);
35703: 
    1:   SyncLayout(aState);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsFrame::BoxReflow(nsBoxLayoutState&        aState,
    1:                    nsPresContext*           aPresContext,
    1:                    nsHTMLReflowMetrics&     aDesiredSize,
68481:                    nsRenderingContext*     aRenderingContext,
    1:                    nscoord                  aX,
    1:                    nscoord                  aY,
    1:                    nscoord                  aWidth,
    1:                    nscoord                  aHeight,
79445:                    bool                     aMoveFrame)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsBoxToBlockAdaptor");
    1: 
    1: #ifdef DEBUG_REFLOW
    1:   nsAdaptorAddIndents();
    1:   printf("Reflowing: ");
    1:   nsFrame::ListTag(stdout, mFrame);
    1:   printf("\n");
    1:   gIndent2++;
    1: #endif
    1: 
    1:   //printf("width=%d, height=%d\n", aWidth, aHeight);
    1:   /*
    1:   nsIBox* parent;
    1:   GetParentBox(&parent);
    1: 
    1:  // if (parent->GetStateBits() & NS_STATE_CURRENTLY_IN_DEBUG)
    1:   //   printf("In debug\n");
    1:   */
    1: 
    1:   nsBoxLayoutMetrics *metrics = BoxMetrics();
    1:   nsReflowStatus status = NS_FRAME_COMPLETE;
    1: 
79445:   bool needsReflow = NS_SUBTREE_DIRTY(this);
    1: 
    1:   // if we don't need a reflow then 
    1:   // lets see if we are already that size. Yes? then don't even reflow. We are done.
    1:   if (!needsReflow) {
    1:       
    1:       if (aWidth != NS_INTRINSICSIZE && aHeight != NS_INTRINSICSIZE) {
    1:       
    1:           // if the new calculated size has a 0 width or a 0 height
    1:           if ((metrics->mLastSize.width == 0 || metrics->mLastSize.height == 0) && (aWidth == 0 || aHeight == 0)) {
80486:                needsReflow = false;
    1:                aDesiredSize.width = aWidth; 
    1:                aDesiredSize.height = aHeight; 
    1:                SetSize(nsSize(aDesiredSize.width, aDesiredSize.height));
    1:           } else {
    1:             aDesiredSize.width = metrics->mLastSize.width;
    1:             aDesiredSize.height = metrics->mLastSize.height;
    1: 
    1:             // remove the margin. The rect of our child does not include it but our calculated size does.
    1:             // don't reflow if we are already the right size
    1:             if (metrics->mLastSize.width == aWidth && metrics->mLastSize.height == aHeight)
80486:                   needsReflow = false;
    1:             else
80486:                   needsReflow = true;
    1:    
    1:           }
    1:       } else {
    1:           // if the width or height are intrinsic alway reflow because
    1:           // we don't know what it should be.
80486:          needsReflow = true;
    1:       }
    1:   }
    1:                              
    1:   // ok now reflow the child into the spacers calculated space
    1:   if (needsReflow) {
    1: 
    1:     aDesiredSize.width = 0;
    1:     aDesiredSize.height = 0;
    1: 
    1:     // create a reflow state to tell our child to flow at the given size.
    1: 
    1:     // Construct a bogus parent reflow state so that there's a usable
    1:     // containing block reflow state.
    1:     nsMargin margin(0,0,0,0);
    1:     GetMargin(margin);
    1: 
    1:     nsSize parentSize(aWidth, aHeight);
    1:     if (parentSize.height != NS_INTRINSICSIZE)
    1:       parentSize.height += margin.TopBottom();
    1:     if (parentSize.width != NS_INTRINSICSIZE)
    1:       parentSize.width += margin.LeftRight();
    1: 
    1:     nsIFrame *parentFrame = GetParent();
    1:     nsFrameState savedState = parentFrame->GetStateBits();
    1:     nsHTMLReflowState parentReflowState(aPresContext, parentFrame,
    1:                                         aRenderingContext,
96492:                                         parentSize,
96492:                                         nsHTMLReflowState::DUMMY_PARENT_REFLOW_STATE);
43376:     parentFrame->RemoveStateBits(~nsFrameState(0));
    1:     parentFrame->AddStateBits(savedState);
    1: 
    1:     // This may not do very much useful, but it's probably worth trying.
    1:     if (parentSize.width != NS_INTRINSICSIZE)
41671:       parentReflowState.SetComputedWidth(NS_MAX(parentSize.width, 0));
    1:     if (parentSize.height != NS_INTRINSICSIZE)
41671:       parentReflowState.SetComputedHeight(NS_MAX(parentSize.height, 0));
    1:     parentReflowState.mComputedMargin.SizeTo(0, 0, 0, 0);
    1:     // XXX use box methods
    1:     parentFrame->GetPadding(parentReflowState.mComputedPadding);
    1:     parentFrame->GetBorder(parentReflowState.mComputedBorderPadding);
    1:     parentReflowState.mComputedBorderPadding +=
    1:       parentReflowState.mComputedPadding;
    1: 
    1:     // XXX Is it OK that this reflow state has no parent reflow state?
    1:     // (It used to have a bogus parent, skipping all the boxes).
  256:     nsSize availSize(aWidth, NS_INTRINSICSIZE);
    1:     nsHTMLReflowState reflowState(aPresContext, this, aRenderingContext,
96492:                                   availSize,
96492:                                   nsHTMLReflowState::DUMMY_PARENT_REFLOW_STATE);
    1: 
    1:     // Construct the parent chain manually since constructing it normally
    1:     // messes up dimensions.
82667:     const nsHTMLReflowState *outerReflowState = aState.OuterReflowState();
82667:     NS_ASSERTION(!outerReflowState || outerReflowState->frame != this,
82667:                  "in and out of XUL on a single frame?");
82667:     if (outerReflowState && outerReflowState->frame == parentFrame) {
82667:       // We're a frame (such as a text control frame) that jumps into
82667:       // box reflow and then straight out of it on the child frame.
82667:       // This means we actually have a real parent reflow state.
88124:       // nsLayoutUtils::InflationMinFontSizeFor used to need this to be
88124:       // linked up correctly for text control frames, so do so here).
82667:       reflowState.parentReflowState = outerReflowState;
82667:       reflowState.mCBReflowState = outerReflowState;
82667:     } else {
    1:       reflowState.parentReflowState = &parentReflowState;
    1:       reflowState.mCBReflowState = &parentReflowState;
82667:     }
14159:     reflowState.mReflowDepth = aState.GetReflowDepth();
    1: 
    1:     // mComputedWidth and mComputedHeight are content-box, not
    1:     // border-box
    1:     if (aWidth != NS_INTRINSICSIZE) {
    1:       nscoord computedWidth =
    1:         aWidth - reflowState.mComputedBorderPadding.LeftRight();
32531:       computedWidth = NS_MAX(computedWidth, 0);
    1:       reflowState.SetComputedWidth(computedWidth);
    1:     }
29122: 
29122:     // Most child frames of box frames (e.g. subdocument or scroll frames)
29122:     // need to be constrained to the provided size and overflow as necessary.
29122:     // The one exception are block frames, because we need to know their
29122:     // natural height excluding any overflow area which may be caused by
29122:     // various CSS effects such as shadow or outline.
29122:     if (!IsFrameOfType(eBlockFrame)) {
    1:       if (aHeight != NS_INTRINSICSIZE) {
 4166:         nscoord computedHeight =
    1:           aHeight - reflowState.mComputedBorderPadding.TopBottom();
32531:         computedHeight = NS_MAX(computedHeight, 0);
 4166:         reflowState.SetComputedHeight(computedHeight);
  256:       } else {
 4166:         reflowState.SetComputedHeight(
  256:           ComputeSize(aRenderingContext, availSize, availSize.width,
  256:                       nsSize(reflowState.mComputedMargin.LeftRight(),
  256:                              reflowState.mComputedMargin.TopBottom()),
  256:                       nsSize(reflowState.mComputedBorderPadding.LeftRight() -
  256:                                reflowState.mComputedPadding.LeftRight(),
  256:                              reflowState.mComputedBorderPadding.TopBottom() -
  256:                                reflowState.mComputedPadding.TopBottom()),
  256:                       nsSize(reflowState.mComputedPadding.LeftRight(),
  256:                                reflowState.mComputedPadding.TopBottom()),
80486:                       false).height
 4166:           );
    1:       }
29122:     }
    1: 
    1:     // Box layout calls SetRect before Layout, whereas non-box layout
    1:     // calls SetRect after Reflow.
    1:     // XXX Perhaps we should be doing this by twiddling the rect back to
    1:     // mLastSize before calling Reflow and then switching it back, but
    1:     // However, mLastSize can also be the size passed to BoxReflow by
    1:     // RefreshSizeCache, so that doesn't really make sense.
82671:     if (metrics->mLastSize.width != aWidth) {
80486:       reflowState.mFlags.mHResize = true;
82671: 
82671:       // When font size inflation is enabled, a horizontal resize
82671:       // requires a full reflow.  See nsHTMLReflowState::InitResizeFlags
82671:       // for more details.
82671:       if (nsLayoutUtils::FontSizeInflationEnabled(aPresContext)) {
82671:         AddStateBits(NS_FRAME_IS_DIRTY);
82671:       }
82671:     }
    1:     if (metrics->mLastSize.height != aHeight)
80486:       reflowState.mFlags.mVResize = true;
    1: 
    1:     #ifdef DEBUG_REFLOW
    1:       nsAdaptorAddIndents();
 4166:       printf("Size=(%d,%d)\n",reflowState.ComputedWidth(),
 4166:              reflowState.ComputedHeight());
    1:       nsAdaptorAddIndents();
    1:       nsAdaptorPrintReason(reflowState);
    1:       printf("\n");
    1:     #endif
    1: 
    1:        // place the child and reflow
    1:     WillReflow(aPresContext);
    1: 
    1:     Reflow(aPresContext, aDesiredSize, reflowState, status);
    1: 
    1:     NS_ASSERTION(NS_FRAME_IS_COMPLETE(status), "bad status");
    1: 
    1:     PRUint32 layoutFlags = aState.LayoutFlags();
    1:     nsContainerFrame::FinishReflowChild(this, aPresContext, &reflowState,
    1:                                         aDesiredSize, aX, aY, layoutFlags | NS_FRAME_NO_MOVE_FRAME);
    1: 
    1:     // Save the ascent.  (bug 103925)
87626:     if (IsCollapsed()) {
    1:       metrics->mAscent = 0;
    1:     } else {
    1:       if (aDesiredSize.ascent == nsHTMLReflowMetrics::ASK_FOR_BASELINE) {
    1:         if (!nsLayoutUtils::GetFirstLineBaseline(this, &metrics->mAscent))
    1:           metrics->mAscent = GetBaseline();
    1:       } else
    1:         metrics->mAscent = aDesiredSize.ascent;
    1:     }
    1: 
    1:   } else {
    1:     aDesiredSize.ascent = metrics->mBlockAscent;
    1:   }
    1: 
    1: #ifdef DEBUG_REFLOW
    1:   if (aHeight != NS_INTRINSICSIZE && aDesiredSize.height != aHeight)
    1:   {
    1:           nsAdaptorAddIndents();
    1:           printf("*****got taller!*****\n");
    1:          
    1:   }
    1:   if (aWidth != NS_INTRINSICSIZE && aDesiredSize.width != aWidth)
    1:   {
    1:           nsAdaptorAddIndents();
    1:           printf("*****got wider!******\n");
    1:          
    1:   }
    1: #endif
    1: 
    1:   if (aWidth == NS_INTRINSICSIZE)
    1:      aWidth = aDesiredSize.width;
    1: 
    1:   if (aHeight == NS_INTRINSICSIZE)
    1:      aHeight = aDesiredSize.height;
    1: 
    1:   metrics->mLastSize.width = aDesiredSize.width;
    1:   metrics->mLastSize.height = aDesiredSize.height;
    1: 
    1: #ifdef DEBUG_REFLOW
    1:   gIndent2--;
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
39965: static void
39965: DestroyBoxMetrics(void* aPropertyValue)
39965: {
39965:   delete static_cast<nsBoxLayoutMetrics*>(aPropertyValue);
39965: }
39965: 
39965: NS_DECLARE_FRAME_PROPERTY(BoxMetricsProperty, DestroyBoxMetrics)
39965: 
    1: nsBoxLayoutMetrics*
    1: nsFrame::BoxMetrics() const
    1: {
    1:   nsBoxLayoutMetrics* metrics =
39965:     static_cast<nsBoxLayoutMetrics*>(Properties().Get(BoxMetricsProperty()));
    1:   NS_ASSERTION(metrics, "A box layout method was called but InitBoxMetrics was never called");
    1:   return metrics;
    1: }
    1: 
51752: void
51752: nsFrame::SetParent(nsIFrame* aParent)
    1: {
79445:   bool wasBoxWrapped = IsBoxWrapped();
51752:   mParent = aParent;
39965:   if (!wasBoxWrapped && IsBoxWrapped()) {
80486:     InitBoxMetrics(true);
39965:   } else if (wasBoxWrapped && !IsBoxWrapped()) {
39965:     Properties().Delete(BoxMetricsProperty());
39965:   }
    1: 
51752:   if (GetStateBits() & (NS_FRAME_HAS_VIEW | NS_FRAME_HAS_CHILD_WITH_VIEW)) {
51752:     for (nsIFrame* f = aParent;
51752:          f && !(f->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW);
51752:          f = f->GetParent()) {
51752:       f->AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
51752:     }
51752:   }
51752: 
51752:   if (GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT) {
51752:     for (nsIFrame* f = aParent;
51752:          f && !(f->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
51752:          f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
51752:       f->AddStateBits(NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
51752:     }
51752:   }
    1: }
    1: 
    1: void
79445: nsFrame::InitBoxMetrics(bool aClear)
    1: {
39965:   FrameProperties props = Properties();
39965:   if (aClear) {
39965:     props.Delete(BoxMetricsProperty());
39965:   }
    1: 
    1:   nsBoxLayoutMetrics *metrics = new nsBoxLayoutMetrics();
39965:   props.Set(BoxMetricsProperty(), metrics);
    1: 
    1:   nsFrame::MarkIntrinsicWidthsDirty();
    1:   metrics->mBlockAscent = 0;
    1:   metrics->mLastSize.SizeTo(0, 0);
    1: }
    1: 
    1: // Box layout debugging
    1: #ifdef DEBUG_REFLOW
    1: PRInt32 gIndent2 = 0;
    1: 
    1: void
    1: nsAdaptorAddIndents()
    1: {
    1:     for(PRInt32 i=0; i < gIndent2; i++)
    1:     {
    1:         printf(" ");
    1:     }
    1: }
    1: 
    1: void
    1: nsAdaptorPrintReason(nsHTMLReflowState& aReflowState)
    1: {
    1:     char* reflowReasonString;
    1: 
    1:     switch(aReflowState.reason) 
    1:     {
    1:         case eReflowReason_Initial:
    1:           reflowReasonString = "initial";
    1:           break;
    1: 
    1:         case eReflowReason_Resize:
    1:           reflowReasonString = "resize";
    1:           break;
    1:         case eReflowReason_Dirty:
    1:           reflowReasonString = "dirty";
    1:           break;
    1:         case eReflowReason_StyleChange:
    1:           reflowReasonString = "stylechange";
    1:           break;
    1:         case eReflowReason_Incremental: 
    1:         {
    1:             switch (aReflowState.reflowCommand->Type()) {
    1:               case eReflowType_StyleChanged:
    1:                  reflowReasonString = "incremental (StyleChanged)";
    1:               break;
    1:               case eReflowType_ReflowDirty:
    1:                  reflowReasonString = "incremental (ReflowDirty)";
    1:               break;
    1:               default:
    1:                  reflowReasonString = "incremental (Unknown)";
    1:             }
    1:         }                             
    1:         break;
    1:         default:
    1:           reflowReasonString = "unknown";
    1:           break;
    1:     }
    1: 
    1:     printf("%s",reflowReasonString);
    1: }
    1: 
    1: #endif
    1: #ifdef DEBUG_LAYOUT
    1: void
    1: nsFrame::GetBoxName(nsAutoString& aName)
    1: {
31709:   GetFrameName(aName);
    1: }
    1: #endif
    1: 
    1: #ifdef NS_DEBUG
    1: static void
    1: GetTagName(nsFrame* aFrame, nsIContent* aContent, PRIntn aResultSize,
    1:            char* aResult)
    1: {
    1:   if (aContent) {
39100:     PR_snprintf(aResult, aResultSize, "%s@%p",
39100:                 nsAtomCString(aContent->Tag()).get(), aFrame);
39100:   }
39100:   else {
39100:     PR_snprintf(aResult, aResultSize, "@%p", aFrame);
39100:   }
    1: }
    1: 
    1: void
79445: nsFrame::Trace(const char* aMethod, bool aEnter)
    1: {
    1:   if (NS_FRAME_LOG_TEST(gLogModule, NS_FRAME_TRACE_CALLS)) {
    1:     char tagbuf[40];
    1:     GetTagName(this, mContent, sizeof(tagbuf), tagbuf);
    1:     PR_LogPrint("%s: %s %s", tagbuf, aEnter ? "enter" : "exit", aMethod);
    1:   }
    1: }
    1: 
    1: void
79445: nsFrame::Trace(const char* aMethod, bool aEnter, nsReflowStatus aStatus)
    1: {
    1:   if (NS_FRAME_LOG_TEST(gLogModule, NS_FRAME_TRACE_CALLS)) {
    1:     char tagbuf[40];
    1:     GetTagName(this, mContent, sizeof(tagbuf), tagbuf);
    1:     PR_LogPrint("%s: %s %s, status=%scomplete%s",
    1:                 tagbuf, aEnter ? "enter" : "exit", aMethod,
    1:                 NS_FRAME_IS_NOT_COMPLETE(aStatus) ? "not" : "",
    1:                 (NS_FRAME_REFLOW_NEXTINFLOW & aStatus) ? "+reflow" : "");
    1:   }
    1: }
    1: 
    1: void
    1: nsFrame::TraceMsg(const char* aFormatString, ...)
    1: {
    1:   if (NS_FRAME_LOG_TEST(gLogModule, NS_FRAME_TRACE_CALLS)) {
    1:     // Format arguments into a buffer
    1:     char argbuf[200];
    1:     va_list ap;
    1:     va_start(ap, aFormatString);
    1:     PR_vsnprintf(argbuf, sizeof(argbuf), aFormatString, ap);
    1:     va_end(ap);
    1: 
    1:     char tagbuf[40];
    1:     GetTagName(this, mContent, sizeof(tagbuf), tagbuf);
    1:     PR_LogPrint("%s: %s", tagbuf, argbuf);
    1:   }
    1: }
    1: 
    1: void
30790: nsFrame::VerifyDirtyBitSet(const nsFrameList& aFrameList)
30790: {
30790:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
30790:     NS_ASSERTION(e.get()->GetStateBits() & NS_FRAME_IS_DIRTY,
30790:                  "dirty bit not set");
    1:   }
    1: }
    1: 
    1: // Start Display Reflow
    1: #ifdef DEBUG
    1: 
    1: DR_cookie::DR_cookie(nsPresContext*          aPresContext,
    1:                      nsIFrame*                aFrame, 
    1:                      const nsHTMLReflowState& aReflowState,
    1:                      nsHTMLReflowMetrics&     aMetrics,
    1:                      nsReflowStatus&          aStatus)
    1:   :mPresContext(aPresContext), mFrame(aFrame), mReflowState(aReflowState), mMetrics(aMetrics), mStatus(aStatus)
    1: {
    1:   MOZ_COUNT_CTOR(DR_cookie);
    1:   mValue = nsFrame::DisplayReflowEnter(aPresContext, mFrame, mReflowState);
    1: }
    1: 
    1: DR_cookie::~DR_cookie()
    1: {
    1:   MOZ_COUNT_DTOR(DR_cookie);
    1:   nsFrame::DisplayReflowExit(mPresContext, mFrame, mMetrics, mStatus, mValue);
    1: }
    1: 
    1: DR_layout_cookie::DR_layout_cookie(nsIFrame* aFrame)
    1:   : mFrame(aFrame)
    1: {
    1:   MOZ_COUNT_CTOR(DR_layout_cookie);
    1:   mValue = nsFrame::DisplayLayoutEnter(mFrame);
    1: }
    1: 
    1: DR_layout_cookie::~DR_layout_cookie()
    1: {
    1:   MOZ_COUNT_DTOR(DR_layout_cookie);
    1:   nsFrame::DisplayLayoutExit(mFrame, mValue);
    1: }
    1: 
    1: DR_intrinsic_width_cookie::DR_intrinsic_width_cookie(
    1:                      nsIFrame*                aFrame, 
    1:                      const char*              aType,
    1:                      nscoord&                 aResult)
    1:   : mFrame(aFrame)
    1:   , mType(aType)
    1:   , mResult(aResult)
    1: {
    1:   MOZ_COUNT_CTOR(DR_intrinsic_width_cookie);
    1:   mValue = nsFrame::DisplayIntrinsicWidthEnter(mFrame, mType);
    1: }
    1: 
    1: DR_intrinsic_width_cookie::~DR_intrinsic_width_cookie()
    1: {
    1:   MOZ_COUNT_DTOR(DR_intrinsic_width_cookie);
    1:   nsFrame::DisplayIntrinsicWidthExit(mFrame, mType, mResult, mValue);
    1: }
    1: 
    1: DR_intrinsic_size_cookie::DR_intrinsic_size_cookie(
    1:                      nsIFrame*                aFrame, 
    1:                      const char*              aType,
    1:                      nsSize&                  aResult)
    1:   : mFrame(aFrame)
    1:   , mType(aType)
    1:   , mResult(aResult)
    1: {
    1:   MOZ_COUNT_CTOR(DR_intrinsic_size_cookie);
    1:   mValue = nsFrame::DisplayIntrinsicSizeEnter(mFrame, mType);
    1: }
    1: 
    1: DR_intrinsic_size_cookie::~DR_intrinsic_size_cookie()
    1: {
    1:   MOZ_COUNT_DTOR(DR_intrinsic_size_cookie);
    1:   nsFrame::DisplayIntrinsicSizeExit(mFrame, mType, mResult, mValue);
    1: }
    1: 
41687: DR_init_constraints_cookie::DR_init_constraints_cookie(
41687:                      nsIFrame*                aFrame,
41687:                      nsHTMLReflowState*       aState,
41687:                      nscoord                  aCBWidth,
41687:                      nscoord                  aCBHeight,
41687:                      const nsMargin*          aMargin,
41687:                      const nsMargin*          aPadding)
41687:   : mFrame(aFrame)
41687:   , mState(aState)
41687: {
41687:   MOZ_COUNT_CTOR(DR_init_constraints_cookie);
41687:   mValue = nsHTMLReflowState::DisplayInitConstraintsEnter(mFrame, mState,
41687:                                                           aCBWidth, aCBHeight,
41687:                                                           aMargin, aPadding);
41687: }
41687: 
41687: DR_init_constraints_cookie::~DR_init_constraints_cookie()
41687: {
41687:   MOZ_COUNT_DTOR(DR_init_constraints_cookie);
41687:   nsHTMLReflowState::DisplayInitConstraintsExit(mFrame, mState, mValue);
41687: }
41687: 
41687: DR_init_offsets_cookie::DR_init_offsets_cookie(
41687:                      nsIFrame*                aFrame,
41687:                      nsCSSOffsetState*        aState,
41687:                      nscoord                  aCBWidth,
41687:                      const nsMargin*          aMargin,
41687:                      const nsMargin*          aPadding)
41687:   : mFrame(aFrame)
41687:   , mState(aState)
41687: {
41687:   MOZ_COUNT_CTOR(DR_init_offsets_cookie);
41687:   mValue = nsCSSOffsetState::DisplayInitOffsetsEnter(mFrame, mState, aCBWidth,
41687:                                                      aMargin, aPadding);
41687: }
41687: 
41687: DR_init_offsets_cookie::~DR_init_offsets_cookie()
41687: {
41687:   MOZ_COUNT_DTOR(DR_init_offsets_cookie);
41687:   nsCSSOffsetState::DisplayInitOffsetsExit(mFrame, mState, mValue);
41687: }
41687: 
41687: DR_init_type_cookie::DR_init_type_cookie(
41687:                      nsIFrame*                aFrame,
41687:                      nsHTMLReflowState*       aState)
41687:   : mFrame(aFrame)
41687:   , mState(aState)
41687: {
41687:   MOZ_COUNT_CTOR(DR_init_type_cookie);
41687:   mValue = nsHTMLReflowState::DisplayInitFrameTypeEnter(mFrame, mState);
41687: }
41687: 
41687: DR_init_type_cookie::~DR_init_type_cookie()
41687: {
41687:   MOZ_COUNT_DTOR(DR_init_type_cookie);
41687:   nsHTMLReflowState::DisplayInitFrameTypeExit(mFrame, mState, mValue);
41687: }
41687: 
    1: struct DR_FrameTypeInfo;
    1: struct DR_FrameTreeNode;
    1: struct DR_Rule;
    1: 
    1: struct DR_State
    1: {
    1:   DR_State();
    1:   ~DR_State();
    1:   void Init();
    1:   void AddFrameTypeInfo(nsIAtom* aFrameType,
    1:                         const char* aFrameNameAbbrev,
    1:                         const char* aFrameName);
    1:   DR_FrameTypeInfo* GetFrameTypeInfo(nsIAtom* aFrameType);
    1:   DR_FrameTypeInfo* GetFrameTypeInfo(char* aFrameName);
    1:   void InitFrameTypeTable();
    1:   DR_FrameTreeNode* CreateTreeNode(nsIFrame*                aFrame,
    1:                                    const nsHTMLReflowState* aReflowState);
    1:   void FindMatchingRule(DR_FrameTreeNode& aNode);
79445:   bool RuleMatches(DR_Rule&          aRule,
    1:                      DR_FrameTreeNode& aNode);
79445:   bool GetToken(FILE* aFile,
40496:                   char* aBuf,
40496:                   size_t aBufSize);
    1:   DR_Rule* ParseRule(FILE* aFile);
    1:   void ParseRulesFile();
24551:   void AddRule(nsTArray<DR_Rule*>& aRules,
    1:                DR_Rule&            aRule);
79445:   bool IsWhiteSpace(int c);
79445:   bool GetNumber(char*    aBuf, 
    1:                  PRInt32&  aNumber);
    1:   void PrettyUC(nscoord aSize,
    1:                 char*   aBuf);
41687:   void PrintMargin(const char* tag, const nsMargin* aMargin);
    1:   void DisplayFrameTypeInfo(nsIFrame* aFrame,
    1:                             PRInt32   aIndent);
    1:   void DeleteTreeNode(DR_FrameTreeNode& aNode);
    1: 
79445:   bool        mInited;
79445:   bool        mActive;
    1:   PRInt32     mCount;
    1:   PRInt32     mAssert;
    1:   PRInt32     mIndent;
79445:   bool        mIndentUndisplayedFrames;
79445:   bool        mDisplayPixelErrors;
24551:   nsTArray<DR_Rule*>          mWildRules;
26081:   nsTArray<DR_FrameTypeInfo>  mFrameTypeTable;
    1:   // reflow specific state
24551:   nsTArray<DR_FrameTreeNode*> mFrameTreeLeaves;
    1: };
    1: 
    1: static DR_State *DR_state; // the one and only DR_State
    1: 
    1: struct DR_RulePart 
    1: {
    1:   DR_RulePart(nsIAtom* aFrameType) : mFrameType(aFrameType), mNext(0) {}
    1:   void Destroy();
    1: 
    1:   nsIAtom*     mFrameType;
    1:   DR_RulePart* mNext;
    1: };
    1: 
    1: void DR_RulePart::Destroy()
    1: {
    1:   if (mNext) {
    1:     mNext->Destroy();
    1:   }
    1:   delete this;
    1: }
    1: 
    1: struct DR_Rule 
    1: {
80486:   DR_Rule() : mLength(0), mTarget(nsnull), mDisplay(false) {
    1:     MOZ_COUNT_CTOR(DR_Rule);
    1:   }
    1:   ~DR_Rule() {
    1:     if (mTarget) mTarget->Destroy();
    1:     MOZ_COUNT_DTOR(DR_Rule);
    1:   }
    1:   void AddPart(nsIAtom* aFrameType);
    1: 
    1:   PRUint32      mLength;
    1:   DR_RulePart*  mTarget;
79445:   bool          mDisplay;
    1: };
    1: 
    1: void DR_Rule::AddPart(nsIAtom* aFrameType)
    1: {
    1:   DR_RulePart* newPart = new DR_RulePart(aFrameType);
    1:   newPart->mNext = mTarget;
    1:   mTarget = newPart;
    1:   mLength++;
    1: }
    1: 
    1: struct DR_FrameTypeInfo
    1: {
    1:   DR_FrameTypeInfo(nsIAtom* aFrmeType, const char* aFrameNameAbbrev, const char* aFrameName);
    1:   ~DR_FrameTypeInfo() { 
    1:       PRInt32 numElements;
24551:       numElements = mRules.Length();
    1:       for (PRInt32 i = numElements - 1; i >= 0; i--) {
24551:         delete mRules.ElementAt(i);
    1:       }
    1:    }
    1: 
    1:   nsIAtom*    mType;
    1:   char        mNameAbbrev[16];
    1:   char        mName[32];
24551:   nsTArray<DR_Rule*> mRules;
26081: private:
86054:   DR_FrameTypeInfo& operator=(const DR_FrameTypeInfo&) MOZ_DELETE;
    1: };
    1: 
    1: DR_FrameTypeInfo::DR_FrameTypeInfo(nsIAtom* aFrameType, 
    1:                                    const char* aFrameNameAbbrev, 
    1:                                    const char* aFrameName)
    1: {
    1:   mType = aFrameType;
64079:   PL_strncpyz(mNameAbbrev, aFrameNameAbbrev, sizeof(mNameAbbrev));
64079:   PL_strncpyz(mName, aFrameName, sizeof(mName));
    1: }
    1: 
    1: struct DR_FrameTreeNode
    1: {
    1:   DR_FrameTreeNode(nsIFrame* aFrame, DR_FrameTreeNode* aParent) : mFrame(aFrame), mParent(aParent), mDisplay(0), mIndent(0)
    1:   {
    1:     MOZ_COUNT_CTOR(DR_FrameTreeNode);
    1:   }
    1: 
    1:   ~DR_FrameTreeNode()
    1:   {
    1:     MOZ_COUNT_DTOR(DR_FrameTreeNode);
    1:   }
    1: 
    1:   nsIFrame*         mFrame;
    1:   DR_FrameTreeNode* mParent;
79445:   bool              mDisplay;
    1:   PRUint32          mIndent;
    1: };
    1: 
    1: // DR_State implementation
    1: 
    1: DR_State::DR_State() 
80486: : mInited(false), mActive(false), mCount(0), mAssert(-1), mIndent(0), 
80486:   mIndentUndisplayedFrames(false), mDisplayPixelErrors(false)
    1: {
    1:   MOZ_COUNT_CTOR(DR_State);
    1: }
    1: 
    1: void DR_State::Init() 
    1: {
    1:   char* env = PR_GetEnv("GECKO_DISPLAY_REFLOW_ASSERT");
    1:   PRInt32 num;
    1:   if (env) {
    1:     if (GetNumber(env, num)) 
    1:       mAssert = num;
    1:     else 
    1:       printf("GECKO_DISPLAY_REFLOW_ASSERT - invalid value = %s", env);
    1:   }
    1: 
    1:   env = PR_GetEnv("GECKO_DISPLAY_REFLOW_INDENT_START");
    1:   if (env) {
    1:     if (GetNumber(env, num)) 
    1:       mIndent = num;
    1:     else 
    1:       printf("GECKO_DISPLAY_REFLOW_INDENT_START - invalid value = %s", env);
    1:   }
    1: 
    1:   env = PR_GetEnv("GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES");
    1:   if (env) {
    1:     if (GetNumber(env, num)) 
    1:       mIndentUndisplayedFrames = num;
    1:     else 
    1:       printf("GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES - invalid value = %s", env);
    1:   }
    1: 
    1:   env = PR_GetEnv("GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS");
    1:   if (env) {
    1:     if (GetNumber(env, num)) 
    1:       mDisplayPixelErrors = num;
    1:     else 
    1:       printf("GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS - invalid value = %s", env);
    1:   }
    1: 
    1:   InitFrameTypeTable();
    1:   ParseRulesFile();
80486:   mInited = true;
    1: }
    1: 
    1: DR_State::~DR_State()
    1: {
    1:   MOZ_COUNT_DTOR(DR_State);
    1:   PRInt32 numElements, i;
24551:   numElements = mWildRules.Length();
    1:   for (i = numElements - 1; i >= 0; i--) {
24551:     delete mWildRules.ElementAt(i);
24551:   }
24551:   numElements = mFrameTreeLeaves.Length();
    1:   for (i = numElements - 1; i >= 0; i--) {
24551:     delete mFrameTreeLeaves.ElementAt(i);
24551:   }
    1: }
    1: 
79445: bool DR_State::GetNumber(char*     aBuf, 
    1:                            PRInt32&  aNumber)
    1: {
    1:   if (sscanf(aBuf, "%d", &aNumber) > 0) 
80486:     return true;
    1:   else 
80486:     return false;
    1: }
    1: 
79445: bool DR_State::IsWhiteSpace(int c) {
    1:   return (c == ' ') || (c == '\t') || (c == '\n') || (c == '\r');
    1: }
    1: 
79445: bool DR_State::GetToken(FILE* aFile,
40496:                           char* aBuf,
40496:                           size_t aBufSize)
    1: {
79445:   bool haveToken = false;
    1:   aBuf[0] = 0;
    1:   // get the 1st non whitespace char
    1:   int c = -1;
    1:   for (c = getc(aFile); (c > 0) && IsWhiteSpace(c); c = getc(aFile)) {
    1:   }
    1: 
    1:   if (c > 0) {
80486:     haveToken = true;
    1:     aBuf[0] = c;
    1:     // get everything up to the next whitespace char
40496:     size_t cX;
40496:     for (cX = 1; cX + 1 < aBufSize ; cX++) {
40496:       c = getc(aFile);
    1:       if (c < 0) { // EOF
    1:         ungetc(' ', aFile); 
    1:         break;
    1:       }
    1:       else {
    1:         if (IsWhiteSpace(c)) {
    1:           break;
    1:         }
    1:         else {
    1:           aBuf[cX] = c;
    1:         }
    1:       }
    1:     }
    1:     aBuf[cX] = 0;
    1:   }
    1:   return haveToken;
    1: }
    1: 
    1: DR_Rule* DR_State::ParseRule(FILE* aFile)
    1: {
    1:   char buf[128];
    1:   PRInt32 doDisplay;
    1:   DR_Rule* rule = nsnull;
40496:   while (GetToken(aFile, buf, sizeof(buf))) {
    1:     if (GetNumber(buf, doDisplay)) {
    1:       if (rule) { 
 6770:         rule->mDisplay = !!doDisplay;
    1:         break;
    1:       }
    1:       else {
    1:         printf("unexpected token - %s \n", buf);
    1:       }
    1:     }
    1:     else {
    1:       if (!rule) {
    1:         rule = new DR_Rule;
    1:       }
    1:       if (strcmp(buf, "*") == 0) {
    1:         rule->AddPart(nsnull);
    1:       }
    1:       else {
    1:         DR_FrameTypeInfo* info = GetFrameTypeInfo(buf);
    1:         if (info) {
    1:           rule->AddPart(info->mType);
    1:         }
    1:         else {
    1:           printf("invalid frame type - %s \n", buf);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return rule;
    1: }
    1: 
24551: void DR_State::AddRule(nsTArray<DR_Rule*>& aRules,
    1:                        DR_Rule&            aRule)
    1: {
24551:   PRInt32 numRules = aRules.Length();
    1:   for (PRInt32 ruleX = 0; ruleX < numRules; ruleX++) {
24551:     DR_Rule* rule = aRules.ElementAt(ruleX);
    1:     NS_ASSERTION(rule, "program error");
    1:     if (aRule.mLength > rule->mLength) {
24551:       aRules.InsertElementAt(ruleX, &aRule);
    1:       return;
    1:     }
    1:   }
    1:   aRules.AppendElement(&aRule);
    1: }
    1: 
    1: void DR_State::ParseRulesFile()
    1: {
    1:   char* path = PR_GetEnv("GECKO_DISPLAY_REFLOW_RULES_FILE");
    1:   if (path) {
    1:     FILE* inFile = fopen(path, "r");
    1:     if (inFile) {
    1:       for (DR_Rule* rule = ParseRule(inFile); rule; rule = ParseRule(inFile)) {
    1:         if (rule->mTarget) {
    1:           nsIAtom* fType = rule->mTarget->mFrameType;
    1:           if (fType) {
    1:             DR_FrameTypeInfo* info = GetFrameTypeInfo(fType);
    1:             if (info) {
    1:               AddRule(info->mRules, *rule);
    1:             }
    1:           }
    1:           else {
    1:             AddRule(mWildRules, *rule);
    1:           }
80486:           mActive = true;
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: void DR_State::AddFrameTypeInfo(nsIAtom* aFrameType,
    1:                                 const char* aFrameNameAbbrev,
    1:                                 const char* aFrameName)
    1: {
26081:   mFrameTypeTable.AppendElement(DR_FrameTypeInfo(aFrameType, aFrameNameAbbrev, aFrameName));
    1: }
    1: 
    1: DR_FrameTypeInfo* DR_State::GetFrameTypeInfo(nsIAtom* aFrameType)
    1: {
24551:   PRInt32 numEntries = mFrameTypeTable.Length();
    1:   NS_ASSERTION(numEntries != 0, "empty FrameTypeTable");
    1:   for (PRInt32 i = 0; i < numEntries; i++) {
26081:     DR_FrameTypeInfo& info = mFrameTypeTable.ElementAt(i);
26081:     if (info.mType == aFrameType) {
26081:       return &info;
26081:     }
26081:   }
26081:   return &mFrameTypeTable.ElementAt(numEntries - 1); // return unknown frame type
    1: }
    1: 
    1: DR_FrameTypeInfo* DR_State::GetFrameTypeInfo(char* aFrameName)
    1: {
24551:   PRInt32 numEntries = mFrameTypeTable.Length();
    1:   NS_ASSERTION(numEntries != 0, "empty FrameTypeTable");
    1:   for (PRInt32 i = 0; i < numEntries; i++) {
26081:     DR_FrameTypeInfo& info = mFrameTypeTable.ElementAt(i);
26081:     if ((strcmp(aFrameName, info.mName) == 0) || (strcmp(aFrameName, info.mNameAbbrev) == 0)) {
26081:       return &info;
26081:     }
26081:   }
26081:   return &mFrameTypeTable.ElementAt(numEntries - 1); // return unknown frame type
    1: }
    1: 
    1: void DR_State::InitFrameTypeTable()
    1: {  
    1:   AddFrameTypeInfo(nsGkAtoms::blockFrame,            "block",     "block");
    1:   AddFrameTypeInfo(nsGkAtoms::brFrame,               "br",        "br");
    1:   AddFrameTypeInfo(nsGkAtoms::bulletFrame,           "bullet",    "bullet");
    1:   AddFrameTypeInfo(nsGkAtoms::gfxButtonControlFrame, "button",    "gfxButtonControl");
    1:   AddFrameTypeInfo(nsGkAtoms::HTMLButtonControlFrame, "HTMLbutton",    "HTMLButtonControl");
    1:   AddFrameTypeInfo(nsGkAtoms::HTMLCanvasFrame,       "HTMLCanvas","HTMLCanvas");
    1:   AddFrameTypeInfo(nsGkAtoms::subDocumentFrame,      "subdoc",    "subDocument");
    1:   AddFrameTypeInfo(nsGkAtoms::imageFrame,            "img",       "image");
    1:   AddFrameTypeInfo(nsGkAtoms::inlineFrame,           "inline",    "inline");
    1:   AddFrameTypeInfo(nsGkAtoms::letterFrame,           "letter",    "letter");
    1:   AddFrameTypeInfo(nsGkAtoms::lineFrame,             "line",      "line");
    1:   AddFrameTypeInfo(nsGkAtoms::listControlFrame,      "select",    "select");
    1:   AddFrameTypeInfo(nsGkAtoms::objectFrame,           "obj",       "object");
    1:   AddFrameTypeInfo(nsGkAtoms::pageFrame,             "page",      "page");
    1:   AddFrameTypeInfo(nsGkAtoms::placeholderFrame,      "place",     "placeholder");
    1:   AddFrameTypeInfo(nsGkAtoms::canvasFrame,           "canvas",    "canvas");
    1:   AddFrameTypeInfo(nsGkAtoms::rootFrame,             "root",      "root");
    1:   AddFrameTypeInfo(nsGkAtoms::scrollFrame,           "scroll",    "scroll");
    1:   AddFrameTypeInfo(nsGkAtoms::tableCaptionFrame,     "caption",   "tableCaption");
    1:   AddFrameTypeInfo(nsGkAtoms::tableCellFrame,        "cell",      "tableCell");
    1:   AddFrameTypeInfo(nsGkAtoms::bcTableCellFrame,      "bcCell",    "bcTableCell");
    1:   AddFrameTypeInfo(nsGkAtoms::tableColFrame,         "col",       "tableCol");
    1:   AddFrameTypeInfo(nsGkAtoms::tableColGroupFrame,    "colG",      "tableColGroup");
    1:   AddFrameTypeInfo(nsGkAtoms::tableFrame,            "tbl",       "table");
    1:   AddFrameTypeInfo(nsGkAtoms::tableOuterFrame,       "tblO",      "tableOuter");
    1:   AddFrameTypeInfo(nsGkAtoms::tableRowGroupFrame,    "rowG",      "tableRowGroup");
    1:   AddFrameTypeInfo(nsGkAtoms::tableRowFrame,         "row",       "tableRow");
    1:   AddFrameTypeInfo(nsGkAtoms::textInputFrame,        "textCtl",   "textInput");
    1:   AddFrameTypeInfo(nsGkAtoms::textFrame,             "text",      "text");
    1:   AddFrameTypeInfo(nsGkAtoms::viewportFrame,         "VP",        "viewport");
23176: #ifdef MOZ_XUL
23176:   AddFrameTypeInfo(nsGkAtoms::XULLabelFrame,         "XULLabel",  "XULLabel");
41687:   AddFrameTypeInfo(nsGkAtoms::boxFrame,              "Box",       "Box");
41687:   AddFrameTypeInfo(nsGkAtoms::sliderFrame,           "Slider",    "Slider");
41687:   AddFrameTypeInfo(nsGkAtoms::popupSetFrame,         "PopupSet",  "PopupSet");
23176: #endif
    1:   AddFrameTypeInfo(nsnull,                               "unknown",   "unknown");
    1: }
    1: 
    1: 
    1: void DR_State::DisplayFrameTypeInfo(nsIFrame* aFrame,
    1:                                     PRInt32   aIndent)
    1: { 
    1:   DR_FrameTypeInfo* frameTypeInfo = GetFrameTypeInfo(aFrame->GetType());
    1:   if (frameTypeInfo) {
    1:     for (PRInt32 i = 0; i < aIndent; i++) {
    1:       printf(" ");
    1:     }
    1:     if(!strcmp(frameTypeInfo->mNameAbbrev, "unknown")) {
31709:       if (aFrame) {
    1:        nsAutoString  name;
31709:        aFrame->GetFrameName(name);
    1:        printf("%s %p ", NS_LossyConvertUTF16toASCII(name).get(), (void*)aFrame);
    1:       }
    1:       else {
    1:         printf("%s %p ", frameTypeInfo->mNameAbbrev, (void*)aFrame);
    1:       }
    1:     }
    1:     else {
    1:       printf("%s %p ", frameTypeInfo->mNameAbbrev, (void*)aFrame);
    1:     }
    1:   }
    1: }
    1: 
79445: bool DR_State::RuleMatches(DR_Rule&          aRule,
    1:                              DR_FrameTreeNode& aNode)
    1: {
    1:   NS_ASSERTION(aRule.mTarget, "program error");
    1: 
    1:   DR_RulePart* rulePart;
    1:   DR_FrameTreeNode* parentNode;
    1:   for (rulePart = aRule.mTarget->mNext, parentNode = aNode.mParent;
    1:        rulePart && parentNode;
    1:        rulePart = rulePart->mNext, parentNode = parentNode->mParent) {
    1:     if (rulePart->mFrameType) {
    1:       if (parentNode->mFrame) {
    1:         if (rulePart->mFrameType != parentNode->mFrame->GetType()) {
80486:           return false;
80486:         }
80486:       }
80486:       else NS_ASSERTION(false, "program error");
    1:     }
    1:     // else wild card match
    1:   }
80486:   return true;
    1: }
    1: 
    1: void DR_State::FindMatchingRule(DR_FrameTreeNode& aNode)
    1: {
    1:   if (!aNode.mFrame) {
80486:     NS_ASSERTION(false, "invalid DR_FrameTreeNode \n");
    1:     return;
    1:   }
    1: 
79445:   bool matchingRule = false;
    1: 
    1:   DR_FrameTypeInfo* info = GetFrameTypeInfo(aNode.mFrame->GetType());
    1:   NS_ASSERTION(info, "program error");
24551:   PRInt32 numRules = info->mRules.Length();
    1:   for (PRInt32 ruleX = 0; ruleX < numRules; ruleX++) {
24551:     DR_Rule* rule = info->mRules.ElementAt(ruleX);
    1:     if (rule && RuleMatches(*rule, aNode)) {
    1:       aNode.mDisplay = rule->mDisplay;
80486:       matchingRule = true;
    1:       break;
    1:     }
    1:   }
    1:   if (!matchingRule) {
24551:     PRInt32 numWildRules = mWildRules.Length();
    1:     for (PRInt32 ruleX = 0; ruleX < numWildRules; ruleX++) {
24551:       DR_Rule* rule = mWildRules.ElementAt(ruleX);
    1:       if (rule && RuleMatches(*rule, aNode)) {
    1:         aNode.mDisplay = rule->mDisplay;
    1:         break;
    1:       }
    1:     }
    1:   }
    1: }
    1:     
    1: DR_FrameTreeNode* DR_State::CreateTreeNode(nsIFrame*                aFrame,
    1:                                            const nsHTMLReflowState* aReflowState)
    1: {
    1:   // find the frame of the parent reflow state (usually just the parent of aFrame)
    1:   nsIFrame* parentFrame;
    1:   if (aReflowState) {
    1:     const nsHTMLReflowState* parentRS = aReflowState->parentReflowState;
    1:     parentFrame = (parentRS) ? parentRS->frame : nsnull;
    1:   } else {
    1:     parentFrame = aFrame->GetParent();
    1:   }
    1: 
    1:   // find the parent tree node leaf
    1:   DR_FrameTreeNode* parentNode = nsnull;
    1:   
    1:   DR_FrameTreeNode* lastLeaf = nsnull;
24551:   if(mFrameTreeLeaves.Length())
26081:     lastLeaf = mFrameTreeLeaves.ElementAt(mFrameTreeLeaves.Length() - 1);
    1:   if (lastLeaf) {
    1:     for (parentNode = lastLeaf; parentNode && (parentNode->mFrame != parentFrame); parentNode = parentNode->mParent) {
    1:     }
    1:   }
    1:   DR_FrameTreeNode* newNode = new DR_FrameTreeNode(aFrame, parentNode);
    1:   FindMatchingRule(*newNode);
    1: 
    1:   newNode->mIndent = mIndent;
    1:   if (newNode->mDisplay || mIndentUndisplayedFrames) {
    1:     ++mIndent;
    1:   }
    1: 
    1:   if (lastLeaf && (lastLeaf == parentNode)) {
24551:     mFrameTreeLeaves.RemoveElementAt(mFrameTreeLeaves.Length() - 1);
    1:   }
    1:   mFrameTreeLeaves.AppendElement(newNode);
    1:   mCount++;
    1: 
    1:   return newNode;
    1: }
    1: 
    1: void DR_State::PrettyUC(nscoord aSize,
    1:                         char*   aBuf)
    1: {
    1:   if (NS_UNCONSTRAINEDSIZE == aSize) {
    1:     strcpy(aBuf, "UC");
    1:   }
    1:   else {
    1:     if ((nscoord)0xdeadbeefU == aSize)
    1:     {
    1:       strcpy(aBuf, "deadbeef");
    1:     }
    1:     else {
    1:       sprintf(aBuf, "%d", aSize);
    1:     }
    1:   }
    1: }
    1: 
41687: void DR_State::PrintMargin(const char *tag, const nsMargin* aMargin)
41687: {
41687:   if (aMargin) {
41687:     char t[16], r[16], b[16], l[16];
41687:     PrettyUC(aMargin->top, t);
41687:     PrettyUC(aMargin->right, r);
41687:     PrettyUC(aMargin->bottom, b);
41687:     PrettyUC(aMargin->left, l);
41687:     printf(" %s=%s,%s,%s,%s", tag, t, r, b, l);
41687:   } else {
41687:     // use %p here for consistency with other null-pointer printouts
41687:     printf(" %s=%p", tag, (void*)aMargin);
41687:   }
41687: }
41687: 
    1: void DR_State::DeleteTreeNode(DR_FrameTreeNode& aNode)
    1: {
    1:   mFrameTreeLeaves.RemoveElement(&aNode);
24551:   PRInt32 numLeaves = mFrameTreeLeaves.Length();
24551:   if ((0 == numLeaves) || (aNode.mParent != mFrameTreeLeaves.ElementAt(numLeaves - 1))) {
    1:     mFrameTreeLeaves.AppendElement(aNode.mParent);
    1:   }
    1: 
    1:   if (aNode.mDisplay || mIndentUndisplayedFrames) {
    1:     --mIndent;
    1:   }
    1:   // delete the tree node 
    1:   delete &aNode;
    1: }
    1: 
    1: static void
    1: CheckPixelError(nscoord aSize,
    1:                 PRInt32 aPixelToTwips)
    1: {
    1:   if (NS_UNCONSTRAINEDSIZE != aSize) {
    1:     if ((aSize % aPixelToTwips) > 0) {
    1:       printf("VALUE %d is not a whole pixel \n", aSize);
    1:     }
    1:   }
    1: }
    1: 
    1: static void DisplayReflowEnterPrint(nsPresContext*          aPresContext,
    1:                                     nsIFrame*                aFrame,
    1:                                     const nsHTMLReflowState& aReflowState,
    1:                                     DR_FrameTreeNode&        aTreeNode,
79445:                                     bool                     aChanged)
    1: {
    1:   if (aTreeNode.mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, aTreeNode.mIndent);
    1: 
    1:     char width[16];
    1:     char height[16];
    1: 
    1:     DR_state->PrettyUC(aReflowState.availableWidth, width);
    1:     DR_state->PrettyUC(aReflowState.availableHeight, height);
    1:     printf("Reflow a=%s,%s ", width, height);
    1: 
    1:     DR_state->PrettyUC(aReflowState.ComputedWidth(), width);
 4166:     DR_state->PrettyUC(aReflowState.ComputedHeight(), height);
    1:     printf("c=%s,%s ", width, height);
    1: 
    1:     if (aFrame->GetStateBits() & NS_FRAME_IS_DIRTY)
    1:       printf("dirty ");
    1: 
    1:     if (aFrame->GetStateBits() & NS_FRAME_HAS_DIRTY_CHILDREN)
    1:       printf("dirty-children ");
    1: 
    1:     if (aReflowState.mFlags.mSpecialHeightReflow)
    1:       printf("special-height ");
    1: 
    1:     if (aReflowState.mFlags.mHResize)
    1:       printf("h-resize ");
    1: 
    1:     if (aReflowState.mFlags.mVResize)
    1:       printf("v-resize ");
    1: 
    1:     nsIFrame* inFlow = aFrame->GetPrevInFlow();
    1:     if (inFlow) {
    1:       printf("pif=%p ", (void*)inFlow);
    1:     }
    1:     inFlow = aFrame->GetNextInFlow();
    1:     if (inFlow) {
    1:       printf("nif=%p ", (void*)inFlow);
    1:     }
    1:     if (aChanged) 
    1:       printf("CHANGED \n");
    1:     else 
    1:       printf("cnt=%d \n", DR_state->mCount);
    1:     if (DR_state->mDisplayPixelErrors) {
    1:       PRInt32 p2t = aPresContext->AppUnitsPerDevPixel();
    1:       CheckPixelError(aReflowState.availableWidth, p2t);
    1:       CheckPixelError(aReflowState.availableHeight, p2t);
    1:       CheckPixelError(aReflowState.ComputedWidth(), p2t);
 4166:       CheckPixelError(aReflowState.ComputedHeight(), p2t);
    1:     }
    1:   }
    1: }
    1: 
    1: void* nsFrame::DisplayReflowEnter(nsPresContext*          aPresContext,
    1:                                   nsIFrame*                aFrame,
    1:                                   const nsHTMLReflowState& aReflowState)
    1: {
    1:   if (!DR_state->mInited) DR_state->Init();
    1:   if (!DR_state->mActive) return nsnull;
    1: 
    1:   NS_ASSERTION(aFrame, "invalid call");
    1: 
    1:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, &aReflowState);
    1:   if (treeNode) {
80486:     DisplayReflowEnterPrint(aPresContext, aFrame, aReflowState, *treeNode, false);
    1:   }
    1:   return treeNode;
    1: }
    1: 
    1: void* nsFrame::DisplayLayoutEnter(nsIFrame* aFrame)
    1: {
    1:   if (!DR_state->mInited) DR_state->Init();
    1:   if (!DR_state->mActive) return nsnull;
    1: 
    1:   NS_ASSERTION(aFrame, "invalid call");
    1: 
    1:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nsnull);
    1:   if (treeNode && treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1:     printf("Layout\n");
    1:   }
    1:   return treeNode;
    1: }
    1: 
    1: void* nsFrame::DisplayIntrinsicWidthEnter(nsIFrame* aFrame,
    1:                                           const char* aType)
    1: {
    1:   if (!DR_state->mInited) DR_state->Init();
    1:   if (!DR_state->mActive) return nsnull;
    1: 
    1:   NS_ASSERTION(aFrame, "invalid call");
    1: 
    1:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nsnull);
    1:   if (treeNode && treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1:     printf("Get%sWidth\n", aType);
    1:   }
    1:   return treeNode;
    1: }
    1: 
    1: void* nsFrame::DisplayIntrinsicSizeEnter(nsIFrame* aFrame,
    1:                                          const char* aType)
    1: {
    1:   if (!DR_state->mInited) DR_state->Init();
    1:   if (!DR_state->mActive) return nsnull;
    1: 
    1:   NS_ASSERTION(aFrame, "invalid call");
    1: 
    1:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nsnull);
    1:   if (treeNode && treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1:     printf("Get%sSize\n", aType);
    1:   }
    1:   return treeNode;
    1: }
    1: 
    1: void nsFrame::DisplayReflowExit(nsPresContext*      aPresContext,
    1:                                 nsIFrame*            aFrame,
    1:                                 nsHTMLReflowMetrics& aMetrics,
    1:                                 nsReflowStatus       aStatus,
    1:                                 void*                aFrameTreeNode)
    1: {
    1:   if (!DR_state->mActive) return;
    1: 
    1:   NS_ASSERTION(aFrame, "DisplayReflowExit - invalid call");
    1:   if (!aFrameTreeNode) return;
    1: 
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
    1:   if (treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1: 
    1:     char width[16];
    1:     char height[16];
    1:     char x[16];
    1:     char y[16];
    1:     DR_state->PrettyUC(aMetrics.width, width);
    1:     DR_state->PrettyUC(aMetrics.height, height);
    1:     printf("Reflow d=%s,%s", width, height);
    1: 
 4006:     if (!NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
    1:       printf(" status=0x%x", aStatus);
    1:     }
55040:     if (aFrame->HasOverflowAreas()) {
55040:       DR_state->PrettyUC(aMetrics.VisualOverflow().x, x);
55040:       DR_state->PrettyUC(aMetrics.VisualOverflow().y, y);
55040:       DR_state->PrettyUC(aMetrics.VisualOverflow().width, width);
55040:       DR_state->PrettyUC(aMetrics.VisualOverflow().height, height);
55040:       printf(" vis-o=(%s,%s) %s x %s", x, y, width, height);
55040: 
55040:       nsRect storedOverflow = aFrame->GetVisualOverflowRect();
11909:       DR_state->PrettyUC(storedOverflow.x, x);
11909:       DR_state->PrettyUC(storedOverflow.y, y);
11909:       DR_state->PrettyUC(storedOverflow.width, width);
11909:       DR_state->PrettyUC(storedOverflow.height, height);
55040:       printf(" vis-sto=(%s,%s) %s x %s", x, y, width, height);
55040: 
55040:       DR_state->PrettyUC(aMetrics.ScrollableOverflow().x, x);
55040:       DR_state->PrettyUC(aMetrics.ScrollableOverflow().y, y);
55040:       DR_state->PrettyUC(aMetrics.ScrollableOverflow().width, width);
55040:       DR_state->PrettyUC(aMetrics.ScrollableOverflow().height, height);
55040:       printf(" scr-o=(%s,%s) %s x %s", x, y, width, height);
55040: 
55040:       storedOverflow = aFrame->GetScrollableOverflowRect();
55040:       DR_state->PrettyUC(storedOverflow.x, x);
55040:       DR_state->PrettyUC(storedOverflow.y, y);
55040:       DR_state->PrettyUC(storedOverflow.width, width);
55040:       DR_state->PrettyUC(storedOverflow.height, height);
55040:       printf(" scr-sto=(%s,%s) %s x %s", x, y, width, height);
    1:     }
    1:     printf("\n");
    1:     if (DR_state->mDisplayPixelErrors) {
    1:       PRInt32 p2t = aPresContext->AppUnitsPerDevPixel();
    1:       CheckPixelError(aMetrics.width, p2t);
    1:       CheckPixelError(aMetrics.height, p2t);
    1:     }
    1:   }
    1:   DR_state->DeleteTreeNode(*treeNode);
    1: }
    1: 
    1: void nsFrame::DisplayLayoutExit(nsIFrame*            aFrame,
    1:                                 void*                aFrameTreeNode)
    1: {
    1:   if (!DR_state->mActive) return;
    1: 
    1:   NS_ASSERTION(aFrame, "non-null frame required");
    1:   if (!aFrameTreeNode) return;
    1: 
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
    1:   if (treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1:     nsRect rect = aFrame->GetRect();
    1:     printf("Layout=%d,%d,%d,%d\n", rect.x, rect.y, rect.width, rect.height);
    1:   }
    1:   DR_state->DeleteTreeNode(*treeNode);
    1: }
    1: 
    1: void nsFrame::DisplayIntrinsicWidthExit(nsIFrame*            aFrame,
    1:                                         const char*          aType,
    1:                                         nscoord              aResult,
    1:                                         void*                aFrameTreeNode)
    1: {
    1:   if (!DR_state->mActive) return;
    1: 
    1:   NS_ASSERTION(aFrame, "non-null frame required");
    1:   if (!aFrameTreeNode) return;
    1: 
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
    1:   if (treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
36972:     char width[16];
36972:     DR_state->PrettyUC(aResult, width);
36972:     printf("Get%sWidth=%s\n", aType, width);
    1:   }
    1:   DR_state->DeleteTreeNode(*treeNode);
    1: }
    1: 
    1: void nsFrame::DisplayIntrinsicSizeExit(nsIFrame*            aFrame,
    1:                                        const char*          aType,
    1:                                        nsSize               aResult,
    1:                                        void*                aFrameTreeNode)
    1: {
    1:   if (!DR_state->mActive) return;
    1: 
    1:   NS_ASSERTION(aFrame, "non-null frame required");
    1:   if (!aFrameTreeNode) return;
    1: 
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aFrameTreeNode;
    1:   if (treeNode->mDisplay) {
    1:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
    1: 
    1:     char width[16];
    1:     char height[16];
    1:     DR_state->PrettyUC(aResult.width, width);
    1:     DR_state->PrettyUC(aResult.height, height);
    1:     printf("Get%sSize=%s,%s\n", aType, width, height);
    1:   }
    1:   DR_state->DeleteTreeNode(*treeNode);
    1: }
    1: 
    1: /* static */ void
    1: nsFrame::DisplayReflowStartup()
    1: {
    1:   DR_state = new DR_State();
    1: }
    1: 
    1: /* static */ void
    1: nsFrame::DisplayReflowShutdown()
    1: {
    1:   delete DR_state;
    1:   DR_state = nsnull;
    1: }
    1: 
    1: void DR_cookie::Change() const
    1: {
    1:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)mValue;
    1:   if (treeNode && treeNode->mDisplay) {
80486:     DisplayReflowEnterPrint(mPresContext, mFrame, mReflowState, *treeNode, true);
    1:   }
    1: }
    1: 
41687: /* static */ void*
41687: nsHTMLReflowState::DisplayInitConstraintsEnter(nsIFrame* aFrame,
41687:                                                nsHTMLReflowState* aState,
41687:                                                nscoord aContainingBlockWidth,
41687:                                                nscoord aContainingBlockHeight,
41687:                                                const nsMargin* aBorder,
41687:                                                const nsMargin* aPadding)
41687: {
41687:   NS_PRECONDITION(aFrame, "non-null frame required");
41687:   NS_PRECONDITION(aState, "non-null state required");
41687: 
41687:   if (!DR_state->mInited) DR_state->Init();
41687:   if (!DR_state->mActive) return nsnull;
41687: 
41687:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, aState);
41687:   if (treeNode && treeNode->mDisplay) {
41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
41687: 
41687:     printf("InitConstraints parent=%p",
41687:            (void*)aState->parentReflowState);
41687: 
41687:     char width[16];
41687:     char height[16];
41687: 
41687:     DR_state->PrettyUC(aContainingBlockWidth, width);
41687:     DR_state->PrettyUC(aContainingBlockHeight, height);
41687:     printf(" cb=%s,%s", width, height);
41687: 
41687:     DR_state->PrettyUC(aState->availableWidth, width);
41687:     DR_state->PrettyUC(aState->availableHeight, height);
41687:     printf(" as=%s,%s", width, height);
41687: 
41687:     DR_state->PrintMargin("b", aBorder);
41687:     DR_state->PrintMargin("p", aPadding);
41687:     putchar('\n');
41687:   }
41687:   return treeNode;
41687: }
41687: 
41687: /* static */ void
41687: nsHTMLReflowState::DisplayInitConstraintsExit(nsIFrame* aFrame,
41687:                                               nsHTMLReflowState* aState,
41687:                                               void* aValue)
41687: {
41687:   NS_PRECONDITION(aFrame, "non-null frame required");
41687:   NS_PRECONDITION(aState, "non-null state required");
41687: 
41687:   if (!DR_state->mActive) return;
41687:   if (!aValue) return;
41687: 
41687:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aValue;
41687:   if (treeNode->mDisplay) {
41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
41687:     char cmiw[16], cw[16], cmxw[16], cmih[16], ch[16], cmxh[16];
41687:     DR_state->PrettyUC(aState->mComputedMinWidth, cmiw);
41687:     DR_state->PrettyUC(aState->mComputedWidth, cw);
41687:     DR_state->PrettyUC(aState->mComputedMaxWidth, cmxw);
41687:     DR_state->PrettyUC(aState->mComputedMinHeight, cmih);
41687:     DR_state->PrettyUC(aState->mComputedHeight, ch);
41687:     DR_state->PrettyUC(aState->mComputedMaxHeight, cmxh);
41687:     printf("InitConstraints= cw=(%s <= %s <= %s) ch=(%s <= %s <= %s)",
41687:            cmiw, cw, cmxw, cmih, ch, cmxh);
41687:     DR_state->PrintMargin("co", &aState->mComputedOffsets);
41687:     putchar('\n');
41687:   }
41687:   DR_state->DeleteTreeNode(*treeNode);
41687: }
41687: 
41687: 
41687: /* static */ void*
41687: nsCSSOffsetState::DisplayInitOffsetsEnter(nsIFrame* aFrame,
41687:                                           nsCSSOffsetState* aState,
41687:                                           nscoord aContainingBlockWidth,
41687:                                           const nsMargin* aBorder,
41687:                                           const nsMargin* aPadding)
41687: {
41687:   NS_PRECONDITION(aFrame, "non-null frame required");
41687:   NS_PRECONDITION(aState, "non-null state required");
41687: 
41687:   if (!DR_state->mInited) DR_state->Init();
41687:   if (!DR_state->mActive) return nsnull;
41687: 
41687:   // aState is not necessarily a nsHTMLReflowState
41687:   DR_FrameTreeNode* treeNode = DR_state->CreateTreeNode(aFrame, nsnull);
41687:   if (treeNode && treeNode->mDisplay) {
41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
41687: 
41687:     char width[16];
41687:     DR_state->PrettyUC(aContainingBlockWidth, width);
41687:     printf("InitOffsets cbw=%s", width);
41687:     DR_state->PrintMargin("b", aBorder);
41687:     DR_state->PrintMargin("p", aPadding);
41687:     putchar('\n');
41687:   }
41687:   return treeNode;
41687: }
41687: 
41687: /* static */ void
41687: nsCSSOffsetState::DisplayInitOffsetsExit(nsIFrame* aFrame,
41687:                                          nsCSSOffsetState* aState,
41687:                                          void* aValue)
41687: {
41687:   NS_PRECONDITION(aFrame, "non-null frame required");
41687:   NS_PRECONDITION(aState, "non-null state required");
41687: 
41687:   if (!DR_state->mActive) return;
41687:   if (!aValue) return;
41687: 
41687:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aValue;
41687:   if (treeNode->mDisplay) {
41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
41687:     printf("InitOffsets=");
41687:     DR_state->PrintMargin("m", &aState->mComputedMargin);
41687:     DR_state->PrintMargin("p", &aState->mComputedPadding);
41687:     DR_state->PrintMargin("p+b", &aState->mComputedBorderPadding);
41687:     putchar('\n');
41687:   }
41687:   DR_state->DeleteTreeNode(*treeNode);
41687: }
41687: 
41687: /* static */ void*
41687: nsHTMLReflowState::DisplayInitFrameTypeEnter(nsIFrame* aFrame,
41687:                                              nsHTMLReflowState* aState)
41687: {
41687:   NS_PRECONDITION(aFrame, "non-null frame required");
41687:   NS_PRECONDITION(aState, "non-null state required");
41687: 
41687:   if (!DR_state->mInited) DR_state->Init();
41687:   if (!DR_state->mActive) return nsnull;
41687: 
41687:   // we don't print anything here
41687:   return DR_state->CreateTreeNode(aFrame, aState);
41687: }
41687: 
41687: /* static */ void
41687: nsHTMLReflowState::DisplayInitFrameTypeExit(nsIFrame* aFrame,
41687:                                             nsHTMLReflowState* aState,
41687:                                             void* aValue)
41687: {
41687:   NS_PRECONDITION(aFrame, "non-null frame required");
41687:   NS_PRECONDITION(aState, "non-null state required");
41687: 
41687:   if (!DR_state->mActive) return;
41687:   if (!aValue) return;
41687: 
41687:   DR_FrameTreeNode* treeNode = (DR_FrameTreeNode*)aValue;
41687:   if (treeNode->mDisplay) {
41687:     DR_state->DisplayFrameTypeInfo(aFrame, treeNode->mIndent);
41687:     printf("InitFrameType");
41687: 
41687:     const nsStyleDisplay *disp = aState->mStyleDisplay;
41687: 
41687:     if (aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
41687:       printf(" out-of-flow");
41687:     if (aFrame->GetPrevInFlow())
41687:       printf(" prev-in-flow");
41687:     if (disp->IsAbsolutelyPositioned())
41687:       printf(" abspos");
41687:     if (disp->IsFloating())
41687:       printf(" float");
41687: 
41687:     // This array must exactly match the NS_STYLE_DISPLAY constants.
41687:     const char *const displayTypes[] = {
41687:       "none", "block", "inline", "inline-block", "list-item", "marker",
41687:       "run-in", "compact", "table", "inline-table", "table-row-group",
41687:       "table-column", "table-column-group", "table-header-group",
41687:       "table-footer-group", "table-row", "table-cell", "table-caption",
41687:       "box", "inline-box",
41687: #ifdef MOZ_XUL
41687:       "grid", "inline-grid", "grid-group", "grid-line", "stack",
41687:       "inline-stack", "deck", "popup", "groupbox",
41687: #endif
41687:     };
80467:     if (disp->mDisplay >= ArrayLength(displayTypes))
41687:       printf(" display=%u", disp->mDisplay);
41687:     else
41687:       printf(" display=%s", displayTypes[disp->mDisplay]);
41687: 
41687:     // This array must exactly match the NS_CSS_FRAME_TYPE constants.
41687:     const char *const cssFrameTypes[] = {
41687:       "unknown", "inline", "block", "floating", "absolute", "internal-table"
41687:     };
41687:     nsCSSFrameType bareType = NS_FRAME_GET_TYPE(aState->mFrameType);
41687:     bool repNoBlock = NS_FRAME_IS_REPLACED_NOBLOCK(aState->mFrameType);
41687:     bool repBlock = NS_FRAME_IS_REPLACED_CONTAINS_BLOCK(aState->mFrameType);
41687: 
80467:     if (bareType >= ArrayLength(cssFrameTypes)) {
41687:       printf(" result=type %u", bareType);
41687:     } else {
41687:       printf(" result=%s", cssFrameTypes[bareType]);
41687:     }
41687:     printf("%s%s\n", repNoBlock ? " +rep" : "", repBlock ? " +repBlk" : "");
41687:   }
41687:   DR_state->DeleteTreeNode(*treeNode);
41687: }
41687: 
    1: #endif
    1: // End Display Reflow
    1: 
    1: #endif
