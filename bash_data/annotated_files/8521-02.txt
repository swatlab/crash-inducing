   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: // vim:cindent:ts=2:et:sw=2:
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: /*
   1:  * rendering object for CSS display:block and display:list-item objects,
   1:  * also used inside table cells
   1:  */
   1: 
   1: #ifndef nsBlockFrame_h___
   1: #define nsBlockFrame_h___
   1: 
   1: #include "nsHTMLContainerFrame.h"
   1: #include "nsHTMLParts.h"
   1: #include "nsAbsoluteContainingBlock.h"
   1: #include "nsLineBox.h"
   1: #include "nsCSSPseudoElements.h"
   1: #include "nsStyleSet.h"
   1: 
   1: enum LineReflowStatus {
   1:   // The line was completely reflowed and fit in available width, and we should
   1:   // try to pull up content from the next line if possible.
   1:   LINE_REFLOW_OK,
   1:   // The line was completely reflowed and fit in available width, but we should
   1:   // not try to pull up content from the next line.
   1:   LINE_REFLOW_STOP,
   1:   // We need to reflow the line again at its current vertical position. The
   1:   // new reflow should not try to pull up any frames from the next line.
   1:   LINE_REFLOW_REDO_NO_PULL,
   1:   // We need to reflow the line again at a lower vertical postion where there
   1:   // may be more horizontal space due to different float configuration.
   1:   LINE_REFLOW_REDO_NEXT_BAND,
   1:   // The line did not fit in the available vertical space. Try pushing it to
   1:   // the next page or column if it's not the first line on the current page/column.
   1:   LINE_REFLOW_TRUNCATED
   1: };
   1: 
   1: class nsBlockReflowState;
5145: class nsBlockInFlowLineIterator;
   1: class nsBulletFrame;
   1: class nsLineBox;
   1: class nsFirstLineFrame;
   1: class nsILineIterator;
   1: class nsIntervalSet;
   1: /**
   1:  * Child list name indices
   1:  * @see #GetAdditionalChildListName()
   1:  */
4006: #define NS_BLOCK_LIST_COUNT  (NS_CONTAINER_LIST_COUNT_INCL_OC + 4)
   1: 
   1: /**
   1:  * Some invariants:
   1:  * -- The overflow out-of-flows list contains the out-of-
   1:  * flow frames whose placeholders are in the overflow list.
   1:  * -- A given piece of content has at most one placeholder
   1:  * frame in a block's normal child list.
   1:  * -- A given piece of content can have an unlimited number
   1:  * of placeholder frames in the overflow-lines list.
   1:  * -- A line containing a continuation placeholder contains
   1:  * only continuation placeholders.
   1:  * -- While a block is being reflowed, its overflowPlaceholdersList
   1:  * frame property points to an nsFrameList in its
   1:  * nsBlockReflowState. This list contains placeholders for
   1:  * floats whose prev-in-flow is in the block's regular line
   1:  * list. The list is always empty/non-existent after the
   1:  * block has been reflowed.
   1:  * -- In all these frame lists, if there are two frames for
   1:  * the same content appearing in the list, then the frames
   1:  * appear with the prev-in-flow before the next-in-flow.
   1:  * -- While reflowing a block, its overflow line list
   1:  * will usually be empty but in some cases will have lines
   1:  * (while we reflow the block at its shrink-wrap width).
   1:  * In this case any new overflowing content must be
   1:  * prepended to the overflow lines.
   1:  */
   1: 
   1: // see nsHTMLParts.h for the public block state bits
6829: 
6829: /**
6829:  * Something in the block has changed that requires Bidi resolution to be
6829:  * performed on the block. This flag must be either set on all blocks in a 
6829:  * continuation chain or none of them.
6829:  */
5590: #define NS_BLOCK_NEEDS_BIDI_RESOLUTION      0x00100000 
   1: #define NS_BLOCK_HAS_LINE_CURSOR            0x01000000
   1: #define NS_BLOCK_HAS_OVERFLOW_LINES         0x02000000
   1: #define NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS  0x04000000
   1: #define NS_BLOCK_HAS_OVERFLOW_PLACEHOLDERS  0x08000000
   1: 
   1: // Set on any block that has descendant frames in the normal
   1: // flow with 'clear' set to something other than 'none'
   1: // (including <BR CLEAR="..."> frames)
   1: #define NS_BLOCK_HAS_CLEAR_CHILDREN         0x10000000
   1: 
   1: #define nsBlockFrameSuper nsHTMLContainerFrame
   1: 
   1: #define NS_BLOCK_FRAME_CID \
   1:  { 0xa6cf90df, 0x15b3, 0x11d2,{0x93, 0x2e, 0x00, 0x80, 0x5f, 0x8a, 0xdd, 0x32}}
   1: 
   1: extern const nsIID kBlockFrameCID;
   1: 
   1: /*
   1:  * Base class for block and inline frames.
   1:  * The block frame has an additional named child list:
   1:  * - "Absolute-list" which contains the absolutely positioned frames
   1:  *
   1:  * @see nsGkAtoms::absoluteList
   1:  */ 
   1: class nsBlockFrame : public nsBlockFrameSuper
   1: {
   1: public:
   1:   typedef nsLineList::iterator                  line_iterator;
   1:   typedef nsLineList::const_iterator            const_line_iterator;
   1:   typedef nsLineList::reverse_iterator          reverse_line_iterator;
   1:   typedef nsLineList::const_reverse_iterator    const_reverse_line_iterator;
   1: 
   1:   line_iterator begin_lines() { return mLines.begin(); }
   1:   line_iterator end_lines() { return mLines.end(); }
   1:   const_line_iterator begin_lines() const { return mLines.begin(); }
   1:   const_line_iterator end_lines() const { return mLines.end(); }
   1:   reverse_line_iterator rbegin_lines() { return mLines.rbegin(); }
   1:   reverse_line_iterator rend_lines() { return mLines.rend(); }
   1:   const_reverse_line_iterator rbegin_lines() const { return mLines.rbegin(); }
   1:   const_reverse_line_iterator rend_lines() const { return mLines.rend(); }
   1: 
   1:   friend nsIFrame* NS_NewBlockFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags);
   1: 
   1:   // nsISupports
   1:   NS_IMETHOD  QueryInterface(const nsIID& aIID, void** aInstancePtr);
   1: 
   1:   // nsIFrame
   1:   NS_IMETHOD Init(nsIContent*      aContent,
   1:                   nsIFrame*        aParent,
   1:                   nsIFrame*        aPrevInFlow);
   1:   NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
   1:                                  nsIFrame*       aChildList);
   1:   NS_IMETHOD  AppendFrames(nsIAtom*        aListName,
   1:                            nsIFrame*       aFrameList);
   1:   NS_IMETHOD  InsertFrames(nsIAtom*        aListName,
   1:                            nsIFrame*       aPrevFrame,
   1:                            nsIFrame*       aFrameList);
   1:   NS_IMETHOD  RemoveFrame(nsIAtom*        aListName,
   1:                           nsIFrame*       aOldFrame);
   1:   virtual nsIFrame* GetFirstChild(nsIAtom* aListName) const;
   1:   virtual nscoord GetBaseline() const;
   1:   virtual nsIAtom* GetAdditionalChildListName(PRInt32 aIndex) const;
   1:   virtual void Destroy();
   1:   virtual nsSplittableType GetSplittableType() const;
   1:   virtual PRBool IsContainingBlock() const;
   1:   virtual PRBool IsFloatContainingBlock() const;
   1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
   1:                               const nsRect&           aDirtyRect,
   1:                               const nsDisplayListSet& aLists);
   1:   virtual void InvalidateInternal(const nsRect& aDamageRect,
   1:                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
   1:                                   PRBool aImmediate);
   1:   virtual nsIAtom* GetType() const;
4006:   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
4006:   {
4006:     return nsContainerFrame::IsFrameOfType(aFlags &
4006:              ~(nsIFrame::eCanContainOverflowContainers));
4006:   }
4006: 
   1: #ifdef DEBUG
   1:   NS_IMETHOD List(FILE* out, PRInt32 aIndent) const;
   1:   NS_IMETHOD_(nsFrameState) GetDebugStateBits() const;
   1:   NS_IMETHOD GetFrameName(nsAString& aResult) const;
   1:   NS_IMETHOD VerifyTree() const;
   1: #endif
   1: 
   1: #ifdef ACCESSIBILITY
   1:   NS_IMETHOD GetAccessible(nsIAccessible** aAccessible);
   1: #endif
   1: 
   1:   // line cursor methods to speed up searching for the line(s)
   1:   // containing a point. The basic idea is that we set the cursor
   1:   // property if the lines' combinedArea.ys and combinedArea.yMosts
   1:   // are non-decreasing (considering only non-empty combinedAreas;
   1:   // empty combinedAreas never participate in event handling or
   1:   // painting), and the block has sufficient number of lines. The
   1:   // cursor property points to a "recently used" line. If we get a
   1:   // series of requests that work on lines
   1:   // "near" the cursor, then we can find those nearby lines quickly by
   1:   // starting our search at the cursor.
   1: 
   1:   // Clear out line cursor because we're disturbing the lines (i.e., Reflow)
   1:   void ClearLineCursor();
   1:   // Get the first line that might contain y-coord 'y', or nsnull if you must search
   1:   // all lines. If nonnull is returned then we guarantee that the lines'
   1:   // combinedArea.ys and combinedArea.yMosts are non-decreasing.
   1:   // The actual line returned might not contain 'y', but if not, it is guaranteed
   1:   // to be before any line which does contain 'y'.
   1:   nsLineBox* GetFirstLineContaining(nscoord y);
   1:   // Set the line cursor to our first line. Only call this if you
   1:   // guarantee that the lines' combinedArea.ys and combinedArea.yMosts
   1:   // are non-decreasing.
   1:   void SetupLineCursor();
   1: 
   1:   virtual void ChildIsDirty(nsIFrame* aChild);
   1:   virtual PRBool IsVisibleInSelection(nsISelection* aSelection);
   1: 
   1:   virtual PRBool IsEmpty();
   1:   virtual PRBool CachedIsEmpty();
   1:   virtual PRBool IsSelfEmpty();
   1: 
   1:   virtual void MarkIntrinsicWidthsDirty();
   1:   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);
   1:   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
   1: 
6862:   virtual nsRect ComputeTightBounds(gfxContext* aContext) const;
6862:   
   1:   NS_IMETHOD Reflow(nsPresContext*          aPresContext,
   1:                     nsHTMLReflowMetrics&     aDesiredSize,
   1:                     const nsHTMLReflowState& aReflowState,
   1:                     nsReflowStatus&          aStatus);
   1: 
   1:   NS_IMETHOD AttributeChanged(PRInt32         aNameSpaceID,
   1:                               nsIAtom*        aAttribute,
   1:                               PRInt32         aModType);
   1: 
4006:   virtual nsresult StealFrame(nsPresContext* aPresContext,
4006:                               nsIFrame*      aChild,
4006:                               PRBool         aForceNormal);
4006: 
   1:   virtual void DeleteNextInFlowChild(nsPresContext* aPresContext,
   1:                                      nsIFrame*       aNextInFlow);
   1: 
   1:   /**
   1:    * Determines whether the collapsed margin carried out of the last
   1:    * line includes the margin-top of a line with clearance (in which
   1:    * case we must avoid collapsing that margin with our bottom margin)
   1:    */
   1:   PRBool CheckForCollapsedBottomMarginFromClearanceLine();
   1: 
   1:   /** return the topmost block child based on y-index.
   1:     * almost always the first or second line, if there is one.
   1:     * accounts for lines that hold only compressed white space, etc.
   1:     */
   1:   nsIFrame* GetTopBlockChild(nsPresContext *aPresContext);
   1: 
   1:   // Returns the line containing aFrame, or end_lines() if the frame
   1:   // isn't in the block.
   1:   line_iterator FindLineFor(nsIFrame* aFrame);
   1: 
   1:   static nsresult GetCurrentLine(nsBlockReflowState *aState, nsLineBox **aOutCurrentLine);
   1: 
   1:   // Create a contination for aPlaceholder and its out of flow frame and
   1:   // add it to the list of overflow floats
   1:   nsresult SplitPlaceholder(nsBlockReflowState& aState, nsIFrame* aPlaceholder);
   1:   
   1:   PRBool HandleOverflowPlaceholdersForPulledFrame(
   1:     nsBlockReflowState& aState, nsIFrame* aFrame);
   1: 
   1:   PRBool HandleOverflowPlaceholdersOnPulledLine(
   1:     nsBlockReflowState& aState, nsLineBox* aLine);
   1: 
   1:   static PRBool BlockIsMarginRoot(nsIFrame* aBlock);
   1:   static PRBool BlockNeedsSpaceManager(nsIFrame* aBlock);
7046:   /**
7046:    * Walks up the frame tree, starting with aCandidate, and returns the first
7046:    * block frame that it encounters.
7046:    */
7046:   static nsBlockFrame* GetNearestAncestorBlock(nsIFrame* aCandidate);
   1:   
   1: protected:
   1:   nsBlockFrame(nsStyleContext* aContext)
   1:     : nsHTMLContainerFrame(aContext)
   1:     , mMinWidth(NS_INTRINSIC_WIDTH_UNKNOWN)
   1:     , mPrefWidth(NS_INTRINSIC_WIDTH_UNKNOWN)
4205:     , mAbsoluteContainer(nsGkAtoms::absoluteList)
   1:   {
   1: #ifdef DEBUG
   1:   InitDebugFlags();
   1: #endif
   1:   }
   1:   virtual ~nsBlockFrame();
   1: 
 551: #ifdef DEBUG
   1:   already_AddRefed<nsStyleContext> GetFirstLetterStyle(nsPresContext* aPresContext)
   1:   {
   1:     return aPresContext->StyleSet()->
   1:       ProbePseudoStyleFor(mContent,
   1:                           nsCSSPseudoElements::firstLetter, mStyleContext);
   1:   }
 551: #endif
   1: 
   1:   /*
   1:    * Overides member function of nsHTMLContainerFrame. Needed to handle the 
   1:    * lines in a nsBlockFrame properly.
   1:    */
   1:   virtual void PaintTextDecorationLine(nsIRenderingContext& aRenderingContext,
   1:                                        nsPoint aPt,
   1:                                        nsLineBox* aLine,
   1:                                        nscolor aColor,
   1:                                        nscoord aOffset,
   1:                                        nscoord aAscent,
4302:                                        nscoord aSize,
4302:                                        const PRUint8 aDecoration);
   1: 
   1:   void TryAllLines(nsLineList::iterator* aIterator,
6709:                    nsLineList::iterator* aStartIterator,
   1:                    nsLineList::iterator* aEndIterator,
   1:                    PRBool* aInOverflowLines);
   1: 
   1:   void SetFlags(PRUint32 aFlags) {
   1:     mState &= ~NS_BLOCK_FLAGS_MASK;
   1:     mState |= aFlags;
   1:   }
   1: 
   1:   PRBool HaveOutsideBullet() const {
   1: #if defined(DEBUG) && !defined(DEBUG_rods)
   1:     if(mState & NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET) {
   1:       NS_ASSERTION(mBullet,"NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET flag set and no mBullet");
   1:     }
   1: #endif
   1:     return 0 != (mState & NS_BLOCK_FRAME_HAS_OUTSIDE_BULLET);
   1:   }
   1: 
   1:   /** move the frames contained by aLine by aDY
   1:     * if aLine is a block, its child floats are added to the state manager
   1:     */
   1:   void SlideLine(nsBlockReflowState& aState,
   1:                  nsLineBox* aLine, nscoord aDY);
   1: 
   1:   virtual PRIntn GetSkipSides() const;
   1: 
   1:   virtual void ComputeFinalSize(const nsHTMLReflowState& aReflowState,
   1:                                 nsBlockReflowState&      aState,
   1:                                 nsHTMLReflowMetrics&     aMetrics);
   1: 
   1:   void ComputeCombinedArea(const nsHTMLReflowState& aReflowState,
   1:                            nsHTMLReflowMetrics& aMetrics);
   1: 
   1:   /** add the frames in aFrameList to this block after aPrevSibling
   1:     * this block thinks in terms of lines, but the frame construction code
   1:     * knows nothing about lines at all. So we need to find the line that
   1:     * contains aPrevSibling and add aFrameList after aPrevSibling on that line.
   1:     * new lines are created as necessary to handle block data in aFrameList.
   1:     */
   1:   nsresult AddFrames(nsIFrame* aFrameList,
   1:                      nsIFrame* aPrevSibling);
   1: 
   1: #ifdef IBMBIDI
   1:   /**
1920:    * Perform Bidi resolution on this frame
1920:    */
1920:   nsresult ResolveBidi();
1920: 
1920:   /**
   1:    * Test whether the frame is a form control in a visual Bidi page.
   1:    * This is necessary for backwards-compatibility, because most visual
   1:    * pages use logical order for form controls so that they will
   1:    * display correctly on native widgets in OSs with Bidi support
   1:    * @param aPresContext the pres context
   1:    * @return whether the frame is a BIDI form control
   1:    */
   1:   PRBool IsVisualFormControl(nsPresContext* aPresContext);
   1: #endif
   1: 
   1: public:
   1:   /** does all the real work for removing aDeletedFrame from this
   1:     * finds the line containing aFrame.
   1:     * handled continued frames
   1:     * marks lines dirty as needed
   1:     * @param aDestroyFrames if false then we don't actually destroy the
   1:     * frame or its next in flows, we just remove them. This does NOT work
   1:     * on out of flow frames so always use PR_TRUE for out of flows.
   1:     * @param aRemoveOnlyFluidContinuations if true, only in-flows are removed;
   1:     * if false, all continuations are removed.
   1:     */
   1:   nsresult DoRemoveFrame(nsIFrame* aDeletedFrame, PRBool aDestroyFrames = PR_TRUE, 
   1:                          PRBool aRemoveOnlyFluidContinuations = PR_TRUE);
 686: 
 686:   void ReparentFloats(nsIFrame* aFirstFrame,
 686:                       nsBlockFrame* aOldParent, PRBool aFromOverflow,
 686:                       PRBool aReparentSiblings);
 686: 
   1: protected:
   1: 
   1:   /** grab overflow lines from this block's prevInFlow, and make them
   1:     * part of this block's mLines list.
   1:     * @return PR_TRUE if any lines were drained.
   1:     */
   1:   PRBool DrainOverflowLines(nsBlockReflowState& aState);
   1: 
   1:   /**
   1:     * Remove a float from our float list and also the float cache
   1:     * for the line its placeholder is on.
   1:     */
   1:   line_iterator RemoveFloat(nsIFrame* aFloat);
   1: 
   1:   void CollectFloats(nsIFrame* aFrame, nsFrameList& aList, nsIFrame** aTail,
 686:                      PRBool aFromOverflow, PRBool aCollectFromSiblings);
   1:   // Remove a float, abs, rel positioned frame from the appropriate block's list
   1:   static void DoRemoveOutOfFlowFrame(nsIFrame* aFrame);
   1: 
   1:   /** set up the conditions necessary for an resize reflow
   1:     * the primary task is to mark the minimumly sufficient lines dirty. 
   1:     */
   1:   nsresult PrepareResizeReflow(nsBlockReflowState& aState);
   1: 
   1:   /** reflow all lines that have been marked dirty */
   1:   nsresult ReflowDirtyLines(nsBlockReflowState& aState);
   1: 
   1:   //----------------------------------------
   1:   // Methods for line reflow
   1:   /**
   1:    * Reflow a line.  
   1:    * @param aState           the current reflow state
   1:    * @param aLine            the line to reflow.  can contain a single block frame
   1:    *                         or contain 1 or more inline frames.
   1:    * @param aKeepReflowGoing [OUT] indicates whether the caller should continue to reflow more lines
   1:    */
   1:   nsresult ReflowLine(nsBlockReflowState& aState,
   1:                       line_iterator aLine,
   1:                       PRBool* aKeepReflowGoing);
   1: 
   1:   // Return PR_TRUE if aLine gets pushed.
8521:   void PlaceLine(nsBlockReflowState& aState,
   1:                  nsLineLayout&       aLineLayout,
   1:                  line_iterator       aLine,
   1:                  PRBool*             aKeepReflowGoing);
   1: 
   1:   /**
   1:    * Mark |aLine| dirty, and, if necessary because of possible
7719:    * pull-up, mark the previous line dirty as well. Also invalidates textruns
7719:    * on those lines because the text in the lines might have changed due to
7719:    * addition/removal of frames.
   1:    */
   1:   nsresult MarkLineDirty(line_iterator aLine);
   1: 
   1:   // XXX where to go
   1:   PRBool ShouldJustifyLine(nsBlockReflowState& aState,
   1:                            line_iterator aLine);
   1: 
   1:   void DeleteLine(nsBlockReflowState& aState,
   1:                   nsLineList::iterator aLine,
   1:                   nsLineList::iterator aLineEnd);
   1: 
   1:   //----------------------------------------
   1:   // Methods for individual frame reflow
   1: 
   1:   PRBool ShouldApplyTopMargin(nsBlockReflowState& aState,
   1:                               nsLineBox* aLine);
   1: 
   1:   nsresult ReflowBlockFrame(nsBlockReflowState& aState,
   1:                             line_iterator aLine,
   1:                             PRBool* aKeepGoing);
   1: 
   1:   nsresult ReflowInlineFrames(nsBlockReflowState& aState,
   1:                               line_iterator aLine,
   1:                               PRBool* aKeepLineGoing);
   1: 
   1:   nsresult DoReflowInlineFrames(nsBlockReflowState& aState,
   1:                                 nsLineLayout& aLineLayout,
   1:                                 line_iterator aLine,
   1:                                 PRBool* aKeepReflowGoing,
   1:                                 LineReflowStatus* aLineReflowStatus,
   1:                                 PRBool aAllowPullUp);
   1: 
   1:   nsresult ReflowInlineFrame(nsBlockReflowState& aState,
   1:                              nsLineLayout& aLineLayout,
   1:                              line_iterator aLine,
   1:                              nsIFrame* aFrame,
   1:                              LineReflowStatus* aLineReflowStatus);
   1: 
   1:   // An incomplete aReflowStatus indicates the float should be split
   1:   // but only if the available height is constrained.
   1:   nsresult ReflowFloat(nsBlockReflowState& aState,
   1:                        nsPlaceholderFrame* aPlaceholder,
2480:                        nsMargin&           aFloatMargin,
   1:                        nsReflowStatus&     aReflowStatus);
   1: 
   1:   //----------------------------------------
   1:   // Methods for pushing/pulling lines/frames
   1: 
   1:   virtual nsresult CreateContinuationFor(nsBlockReflowState& aState,
   1:                                          nsLineBox*          aLine,
   1:                                          nsIFrame*           aFrame,
   1:                                          PRBool&             aMadeNewFrame);
   1: 
   1:   // Push aLine which contains a positioned element that was truncated. Clean up any 
   1:   // placeholders on the same line that were continued. Set aKeepReflowGoing to false. 
   1:   void PushTruncatedPlaceholderLine(nsBlockReflowState& aState,
   1:                                     line_iterator       aLine,
   1:                                     PRBool&             aKeepReflowGoing);
   1: 
   1:   nsresult SplitLine(nsBlockReflowState& aState,
   1:                      nsLineLayout& aLineLayout,
   1:                      line_iterator aLine,
   1:                      nsIFrame* aFrame,
   1:                      LineReflowStatus* aLineReflowStatus);
   1: 
   1:   nsresult PullFrame(nsBlockReflowState& aState,
   1:                      line_iterator aLine,
   1:                      nsIFrame*& aFrameResult);
   1: 
   1:   PRBool PullFrameFrom(nsBlockReflowState& aState,
   1:                        nsLineBox* aLine,
   1:                        nsBlockFrame* aFromContainer,
   1:                        PRBool aFromOverflowLine,
   1:                        nsLineList::iterator aFromLine,
   1:                        nsIFrame*& aFrameResult);
   1: 
   1:   void PushLines(nsBlockReflowState& aState,
   1:                  nsLineList::iterator aLineBefore);
   1: 
   1:   void PropagateFloatDamage(nsBlockReflowState& aState,
   1:                             nsLineBox* aLine,
   1:                             nscoord aDeltaY);
   1: 
   1:   void CheckFloats(nsBlockReflowState& aState);
   1: 
   1:   //----------------------------------------
   1:   // List handling kludge
   1: 
1158:   // If this returns PR_TRUE, the block it's called on should get the
1158:   // NS_FRAME_HAS_DIRTY_CHILDREN bit set on it by the caller; either directly
1158:   // if it's already in reflow, or via calling FrameNeedsReflow() to schedule a
1158:   // reflow.
1158:   PRBool RenumberLists(nsPresContext* aPresContext);
   1: 
   1:   PRBool RenumberListsInBlock(nsPresContext* aPresContext,
   1:                               nsBlockFrame* aContainerFrame,
   1:                               PRInt32* aOrdinal,
   1:                               PRInt32 aDepth);
   1: 
   1:   PRBool RenumberListsFor(nsPresContext* aPresContext, nsIFrame* aKid, PRInt32* aOrdinal, PRInt32 aDepth);
   1: 
   1:   static PRBool FrameStartsCounterScope(nsIFrame* aFrame);
   1: 
   1:   void ReflowBullet(nsBlockReflowState& aState,
   1:                     nsHTMLReflowMetrics& aMetrics);
   1: 
   1:   //----------------------------------------
   1: 
   1: public:
   1:   nsLineList* GetOverflowLines() const;
   1: protected:
   1:   nsLineList* RemoveOverflowLines();
   1:   nsresult SetOverflowLines(nsLineList* aOverflowLines);
   1: 
   1:   nsFrameList* GetOverflowPlaceholders() const;
   1: 
   1:   /**
   1:    * This class is useful for efficiently modifying the out of flow
   1:    * overflow list. It gives the client direct writable access to
   1:    * the frame list temporarily but ensures that property is only
   1:    * written back if absolutely necessary.
   1:    */
   1:   struct nsAutoOOFFrameList {
   1:     nsFrameList mList;
   1: 
   1:     nsAutoOOFFrameList(nsBlockFrame* aBlock) :
   1:       mList(aBlock->GetOverflowOutOfFlows().FirstChild()),
   1:       aOldHead(mList.FirstChild()), mBlock(aBlock) {}
   1:     ~nsAutoOOFFrameList() {
   1:       if (mList.FirstChild() != aOldHead) {
   1:         mBlock->SetOverflowOutOfFlows(mList);
   1:       }
   1:     }
   1:   protected:
   1:     nsIFrame* aOldHead;
   1:     nsBlockFrame* mBlock;
   1:   };
   1:   friend struct nsAutoOOFFrameList;
   1: 
   1:   nsFrameList GetOverflowOutOfFlows() const;
   1:   void SetOverflowOutOfFlows(const nsFrameList& aList);
   1: 
   1:   nsIFrame* LastChild();
   1: 
   1: #ifdef NS_DEBUG
   1:   void VerifyLines(PRBool aFinalCheckOK);
   1:   void VerifyOverflowSituation();
   1:   PRInt32 GetDepth() const;
   1: #endif
   1: 
   1:   nscoord mMinWidth, mPrefWidth;
   1: 
   1:   nsLineList mLines;
   1: 
   1:   // List of all floats in this block
   1:   nsFrameList mFloats;
   1: 
   1:   // XXX_fix_me: subclass one more time!
   1:   // For list-item frames, this is the bullet frame.
   1:   nsBulletFrame* mBullet;
   1: 
   1:   friend class nsBlockReflowState;
5145:   friend class nsBlockInFlowLineIterator;
   1: 
   1: private:
   1:   nsAbsoluteContainingBlock mAbsoluteContainer;
   1: 
   1: 
   1: #ifdef DEBUG
   1: public:
   1:   static PRBool gLamePaintMetrics;
   1:   static PRBool gLameReflowMetrics;
   1:   static PRBool gNoisy;
   1:   static PRBool gNoisyDamageRepair;
   1:   static PRBool gNoisyIntrinsic;
   1:   static PRBool gNoisyReflow;
   1:   static PRBool gReallyNoisyReflow;
   1:   static PRBool gNoisySpaceManager;
   1:   static PRBool gVerifyLines;
   1:   static PRBool gDisableResizeOpt;
   1: 
   1:   static PRInt32 gNoiseIndent;
   1: 
   1:   static const char* kReflowCommandType[];
   1: 
   1: protected:
   1:   static void InitDebugFlags();
   1: #endif
   1: };
   1: 
   1: #ifdef DEBUG
   1: class AutoNoisyIndenter {
   1: public:
   1:   AutoNoisyIndenter(PRBool aDoIndent) : mIndented(aDoIndent) {
   1:     if (mIndented) {
   1:       nsBlockFrame::gNoiseIndent++;
   1:     }
   1:   }
   1:   ~AutoNoisyIndenter() {
   1:     if (mIndented) {
   1:       nsBlockFrame::gNoiseIndent--;
   1:     }
   1:   }
   1: private:
   1:   PRBool mIndented;
   1: };
   1: #endif
   1: 
5145: /**
5145:  * Iterates over all lines in the prev-in-flows/next-in-flows of this block.
5145:  */
5145: class nsBlockInFlowLineIterator {
5145: public:
5145:   typedef nsBlockFrame::line_iterator line_iterator;
5145:   nsBlockInFlowLineIterator(nsBlockFrame* aFrame, line_iterator& aLine, PRBool aInOverflow);
5145: 
5145:   line_iterator GetLine() { return mLine; }
5145:   nsBlockFrame* GetContainer() { return mFrame; }
5145:   PRBool GetInOverflow() { return mInOverflowLines != nsnull; }
5145:   /**
5145:    * Returns false if there are no more lines. After this has returned false,
5145:    * don't call any methods on this object again.
5145:    */
5145:   PRBool Next();
5145:   /**
5145:    * Returns false if there are no more lines. After this has returned false,
5145:    * don't call any methods on this object again.
5145:    */
5145:   PRBool Prev();
5145: 
5145: private:
5145:   nsBlockFrame* mFrame;
5145:   line_iterator mLine;
5145:   nsLineList*   mInOverflowLines;
5145: };
5145: 
   1: #endif /* nsBlockFrame_h___ */
