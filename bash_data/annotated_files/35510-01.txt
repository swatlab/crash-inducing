    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Johnny Stenback <jst@netscape.com>
    1:  *   L. David Baron  <dbaron@dbaron.org>
    1:  *   Pierre Phaneuf  <pp@ludusdesign.com>
    1:  *   Pete Collins    <petejc@collab.net>
    1:  *   James Ross      <silver@warwickcompsoc.co.uk>
16977:  *   Ryan Jones      <sciguyryan@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for all our document implementations.
    1:  */
    1: 
    1: #include "plstr.h"
 7783: #include "prprf.h"
    1: 
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsDocument.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsContentList.h"
    1: #include "nsIObserver.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIScriptRuntime.h"
    1: #include "nsCOMArray.h"
    1: 
    1: #include "nsGUIEvent.h"
    1: 
    1: #include "nsIDOMStyleSheet.h"
    1: #include "nsDOMAttribute.h"
    1: #include "nsIDOMDOMStringList.h"
    1: #include "nsIDOMDOMImplementation.h"
    1: #include "nsIDOMDocumentView.h"
    1: #include "nsIDOMAbstractView.h"
    1: #include "nsIDOMDocumentXBL.h"
    1: #include "nsGenericElement.h"
16977: #include "nsGenericHTMLElement.h"
    1: #include "nsIDOMEventGroup.h"
    1: #include "nsIDOMCDATASection.h"
    1: #include "nsIDOMProcessingInstruction.h"
    1: #include "nsDOMString.h"
    1: #include "nsNodeUtils.h"
 5440: #include "nsLayoutUtils.h" // for GetFrameForPoint
 5440: #include "nsIFrame.h"
    1: 
    1: #include "nsRange.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMComment.h"
    1: #include "nsDOMDocumentType.h"
16103: #include "nsNodeIterator.h"
    1: #include "nsTreeWalker.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: 
    1: #include "nsContentCID.h"
    1: #include "nsDOMError.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsIXBLService.h"
    1: #include "nsIXPointer.h"
    1: #include "nsIFileChannel.h"
    1: #include "nsIMultiPartChannel.h"
    1: #include "nsIRefreshURI.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIScriptError.h"
    1: 
    1: #include "nsNetUtil.h"     // for NS_MakeAbsoluteURI
    1: 
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIPrivateDOMImplementation.h"
    1: 
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMElement.h"
29018: #include "nsFocusManager.h"
    1: 
    1: // for radio group stuff
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsIRadioVisitor.h"
    1: #include "nsIFormControl.h"
    1: 
    1: #include "nsXMLEventsManager.h"
    1: 
    1: #include "nsBidiUtils.h"
    1: 
    1: static NS_DEFINE_CID(kDOMEventGroupCID, NS_DOMEVENTGROUP_CID);
    1: 
    1: #include "nsIDOMUserDataHandler.h"
    1: #include "nsScriptEventManager.h"
    1: #include "nsIDOMXPathEvaluator.h"
    1: #include "nsIXPathEvaluatorInternal.h"
    1: #include "nsIParserService.h"
    1: #include "nsContentCreatorFunctions.h"
    1: 
    1: #include "nsIScriptContext.h"
    1: #include "nsBindingManager.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLFormElement.h"
    1: #include "nsIRequest.h"
    1: #include "nsILink.h"
    1: 
    1: #include "nsICharsetAlias.h"
    1: #include "nsIParser.h"
    1: #include "nsIContentSink.h"
    1: 
    1: #include "nsDateTimeFormatCID.h"
    1: #include "nsIDateTimeFormat.h"
    1: #include "nsEventDispatcher.h"
   62: #include "nsMutationEvent.h"
    1: #include "nsIDOMXPathEvaluator.h"
    1: #include "nsDOMCID.h"
    1: 
29420: #include "jsapi.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsCycleCollector.h"
 1353: #include "nsCCUncollectableMarker.h"
 2324: #include "nsIContentPolicy.h"
20078: #include "nsContentPolicyUtils.h"
20078: #include "nsICategoryManager.h"
20078: #include "nsIDocumentLoaderFactory.h"
20078: #include "nsIContentViewer.h"
20078: #include "nsIXMLContentSink.h"
20078: #include "nsContentErrors.h"
20078: #include "nsIXULDocument.h"
20078: #include "nsIPrompt.h"
21811: #include "nsIPropertyBag2.h"
29539: #include "nsIDOMPageTransitionEvent.h"
12256: #include "nsFrameLoader.h"
34389: #ifdef MOZ_MEDIA
34207: #include "nsHTMLMediaElement.h"
34389: #endif // MOZ_MEDIA
12256: 
14228: #include "mozAutoDocUpdate.h"
14228: 
23697: #ifdef MOZ_SMIL
23697: #include "nsSMILAnimationController.h"
23697: #include "imgIContainer.h"
25961: #include "nsSVGUtils.h"
23697: #endif // MOZ_SMIL
23697: 
20078: 
    1: #ifdef MOZ_LOGGING
    1: // so we can get logging even in release builds
    1: #define FORCE_PR_LOG 1
    1: #endif
    1: #include "prlog.h"
    1: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo* gDocumentLeakPRLog;
    1: #endif
    1: 
    1: void
    1: nsUint32ToContentHashEntry::Destroy()
    1: {
    1:   HashSet* set = GetHashSet();
    1:   if (set) {
    1:     delete set;
    1:   } else {
    1:     nsIContent* content = GetContent();
    1:     NS_IF_RELEASE(content);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsUint32ToContentHashEntry::PutContent(nsIContent* aVal)
    1: {
    1:   // Add the value to the hash if it is there
    1:   HashSet* set = GetHashSet();
    1:   if (set) {
    1:     nsISupportsHashKey* entry = set->PutEntry(aVal);
    1:     return entry ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // If an element is already there, create a hashtable and both of these to it
    1:   nsIContent* oldVal = GetContent();
    1:   if (oldVal) {
    1:     nsresult rv = InitHashSet(&set);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsISupportsHashKey* entry = set->PutEntry(oldVal);
    1:     if (!entry) {
    1:       // OOM - we can't insert aVal, but we can at least put oldVal back (even
    1:       // if we didn't, we'd still have to release oldVal so that we don't leak)
    1:       delete set;
    1:       SetContent(oldVal);
    1:       // SetContent adds another reference, so release the one we had
    1:       NS_RELEASE(oldVal);
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     // The hashset adds its own reference, so release the one we had
    1:     NS_RELEASE(oldVal);
    1: 
    1:     entry = set->PutEntry(aVal);
    1:     return entry ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   // Nothing exists in the hash right now, so just set the single pointer
    1:   return SetContent(aVal);
    1: }
    1: 
    1: void
    1: nsUint32ToContentHashEntry::RemoveContent(nsIContent* aVal)
    1: {
    1:   // Remove from the hash if the hash is there
    1:   HashSet* set = GetHashSet();
    1:   if (set) {
    1:     set->RemoveEntry(aVal);
    1:     if (set->Count() == 0) {
    1:       delete set;
    1:       mValOrHash = nsnull;
    1:     }
    1:     return;
    1:   }
    1: 
    1:   // Remove the ptr if there is just a ptr
    1:   nsIContent* v = GetContent();
    1:   if (v == aVal) {
    1:     NS_IF_RELEASE(v);
    1:     mValOrHash = nsnull;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsUint32ToContentHashEntry::InitHashSet(HashSet** aSet)
    1: {
    1:   HashSet* newSet = new HashSet();
    1:   if (!newSet) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   nsresult rv = newSet->Init();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mValOrHash = newSet;
    1:   *aSet = newSet;
    1:   return NS_OK;
    1: }
    1: 
20261: static PLDHashOperator
    1: nsUint32ToContentHashEntryVisitorCallback(nsISupportsHashKey* aEntry,
    1:                                           void* aClosure)
    1: {
    1:   nsUint32ToContentHashEntry::Visitor* visitor =
 3233:     static_cast<nsUint32ToContentHashEntry::Visitor*>(aClosure);
 3233:   visitor->Visit(static_cast<nsIContent*>(aEntry->GetKey()));
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: void
    1: nsUint32ToContentHashEntry::VisitContent(Visitor* aVisitor)
    1: {
    1:   HashSet* set = GetHashSet();
    1:   if (set) {
    1:     set->EnumerateEntries(nsUint32ToContentHashEntryVisitorCallback, aVisitor);
    1:     if (set->Count() == 0) {
    1:       delete set;
    1:       mValOrHash = nsnull;
    1:     }
    1:     return;
    1:   }
    1: 
    1:   nsIContent* v = GetContent();
    1:   if (v) {
    1:     aVisitor->Visit(v);
    1:   }
    1: }
    1: 
15474: #define NAME_NOT_VALID ((nsBaseContentList*)1)
15474: 
15474: nsIdentifierMapEntry::~nsIdentifierMapEntry()
15474: {
15474:   if (mNameContentList && mNameContentList != NAME_NOT_VALID) {
15474:     NS_RELEASE(mNameContentList);
15474:   }
33810: 
33810:   for (PRInt32 i = 0; i < mIdContentList.Count(); ++i) {
33810:     nsIContent* content = static_cast<nsIContent*>(mIdContentList[i]);
33810:     NS_RELEASE(content);
33810:   }
15474: }
15474: 
15474: void
15474: nsIdentifierMapEntry::Traverse(nsCycleCollectionTraversalCallback* aCallback)
15474: {
18993:   if (mNameContentList != NAME_NOT_VALID) {
18993:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback,
18993:                                        "mIdentifierMap mNameContentList");
19130:     aCallback->NoteXPCOMChild(static_cast<nsIDOMNodeList*>(mNameContentList));
18993:   }
18993: 
18993:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback, "mIdentifierMap mDocAllList");
15474:   aCallback->NoteXPCOMChild(static_cast<nsIDOMNodeList*>(mDocAllList));
33810: 
33810:   for (PRInt32 i = 0; i < mIdContentList.Count(); ++i) {
33810:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback,
33810:                                        "mIdentifierMap mIdContentList element");
33810:     aCallback->NoteXPCOMChild(static_cast<nsIContent*>(mIdContentList[i]));
33810:   }
15474: }
15474: 
15474: void
15474: nsIdentifierMapEntry::SetInvalidName()
15474: {
15474:   mNameContentList = NAME_NOT_VALID;
15474: }
15474: 
15474: PRBool
15474: nsIdentifierMapEntry::IsInvalidName()
15474: {
15474:   return mNameContentList == NAME_NOT_VALID;
15474: }
15474: 
15474: nsresult
15474: nsIdentifierMapEntry::CreateNameContentList()
15474: {
15474:   mNameContentList = new nsBaseContentList();
15474:   NS_ENSURE_TRUE(mNameContentList, NS_ERROR_OUT_OF_MEMORY);
15474:   NS_ADDREF(mNameContentList);
15474:   return NS_OK;
15474: }
15474: 
15474: nsIContent*
26475: nsIdentifierMapEntry::GetIdContent()
26475: {
26475:   return static_cast<nsIContent*>(mIdContentList.SafeElementAt(0));
15474: }
15474: 
15475: void
15475: nsIdentifierMapEntry::AppendAllIdContent(nsCOMArray<nsIContent>* aElements)
15475: {
15475:   for (PRInt32 i = 0; i < mIdContentList.Count(); ++i) {
15475:     aElements->AppendObject(static_cast<nsIContent*>(mIdContentList[i]));
15475:   }
15475: }
15475: 
15515: void
15515: nsIdentifierMapEntry::AddContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
15515:                                                void* aData)
15515: {
15515:   if (!mChangeCallbacks) {
15515:     mChangeCallbacks = new nsTHashtable<ChangeCallbackEntry>;
15515:     if (!mChangeCallbacks)
15515:       return;
15515:     mChangeCallbacks->Init();
15515:   }
15515: 
15515:   ChangeCallback cc = { aCallback, aData };
15515:   mChangeCallbacks->PutEntry(cc);
15515: }
15515: 
15515: void
15515: nsIdentifierMapEntry::RemoveContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
15515:                                                   void* aData)
15515: {
15515:   if (!mChangeCallbacks)
15515:     return;
15515:   ChangeCallback cc = { aCallback, aData };
15515:   mChangeCallbacks->RemoveEntry(cc);
15515:   if (mChangeCallbacks->Count() == 0) {
15515:     mChangeCallbacks = nsnull;
15515:   }
15515: }
15515: 
15515: struct FireChangeArgs {
15515:   nsIContent* mFrom;
15515:   nsIContent* mTo;
15515: };
15515: 
20261: static PLDHashOperator
15515: FireChangeEnumerator(nsIdentifierMapEntry::ChangeCallbackEntry *aEntry, void *aArg)
15515: {
15515:   FireChangeArgs* args = static_cast<FireChangeArgs*>(aArg);
15515:   return aEntry->mKey.mCallback(args->mFrom, args->mTo, aEntry->mKey.mData)
15515:       ? PL_DHASH_NEXT : PL_DHASH_REMOVE;
15515: }
15515: 
15515: void
15515: nsIdentifierMapEntry::FireChangeCallbacks(nsIContent* aOldContent,
15515:                                           nsIContent* aNewContent)
15515: {
15515:   if (!mChangeCallbacks)
15515:     return;
15515: 
15515:   FireChangeArgs args = { aOldContent, aNewContent };
15515:   mChangeCallbacks->EnumerateEntries(FireChangeEnumerator, &args);
15515: }
15515: 
15474: PRBool
15474: nsIdentifierMapEntry::AddIdContent(nsIContent* aContent)
15474: {
15474:   NS_PRECONDITION(aContent, "Must have content");
15474:   NS_PRECONDITION(mIdContentList.IndexOf(nsnull) < 0,
15474:                   "Why is null in our list?");
26475: 
26475: #ifdef DEBUG
26475:   nsIContent* currentContent =
26475:     static_cast<nsIContent*>(mIdContentList.SafeElementAt(0));
26475: #endif
15474: 
15474:   // Common case
15474:   if (mIdContentList.Count() == 0) {
15515:     if (!mIdContentList.AppendElement(aContent))
15515:       return PR_FALSE;
33810:     NS_ADDREF(aContent);
26475:     NS_ASSERTION(currentContent == nsnull, "How did that happen?");
15515:     FireChangeCallbacks(nsnull, aContent);
15515:     return PR_TRUE;
15474:   }
15474: 
26475:   // We seem to have multiple content nodes for the same id, or XUL is messing
26475:   // with us.  Search for the right place to insert the content.
15474:   PRInt32 start = 0;
15474:   PRInt32 end = mIdContentList.Count();
15474:   do {
15474:     NS_ASSERTION(start < end, "Bogus start/end");
15474:     
15474:     PRInt32 cur = (start + end) / 2;
15474:     NS_ASSERTION(cur >= start && cur < end, "What happened here?");
15474: 
15474:     nsIContent* curContent = static_cast<nsIContent*>(mIdContentList[cur]);
15474:     if (curContent == aContent) {
15474:       // Already in the list, so already in the right spot.  Get out of here.
26475:       // XXXbz this only happens because XUL does all sorts of random
26475:       // UpdateIdTableEntry calls.  Hate, hate, hate!
15474:       return PR_TRUE;
15474:     }
15474: 
15474:     if (nsContentUtils::PositionIsBefore(aContent, curContent)) {
15474:       end = cur;
15474:     } else {
15474:       start = cur + 1;
15474:     }
15474:   } while (start != end);
15474: 
15515:   if (!mIdContentList.InsertElementAt(aContent, start))
15515:     return PR_FALSE;
33810:   NS_ADDREF(aContent);
15515:   if (start == 0) {
26475:     nsIContent* oldContent =
26475:       static_cast<nsIContent*>(mIdContentList.SafeElementAt(1));
26475:     NS_ASSERTION(currentContent == oldContent, "How did that happen?");
26475:     FireChangeCallbacks(oldContent, aContent);
15515:   }
15515:   return PR_TRUE;
15474: }
15474: 
15474: PRBool
15474: nsIdentifierMapEntry::RemoveIdContent(nsIContent* aContent)
15474: {
15515:   // This should only be called while the document is in an update.
15515:   // Assertions near the call to this method guarantee this.
15515: 
15474:   // XXXbz should this ever Compact() I guess when all the content is gone
15474:   // we'll just get cleaned up in the natural order of things...
15515:   nsIContent* currentContent = static_cast<nsIContent*>(mIdContentList.SafeElementAt(0));
15515:   if (!mIdContentList.RemoveElement(aContent))
15515:     return PR_FALSE;
15515:   if (currentContent == aContent) {
15515:     FireChangeCallbacks(currentContent,
15515:                         static_cast<nsIContent*>(mIdContentList.SafeElementAt(0)));
15515:   }
33816:   // Make sure the release happens after the check above, since it'll
33816:   // null out aContent.
33816:   NS_RELEASE(aContent);
15515:   return mIdContentList.Count() == 0 && !mNameContentList && !mChangeCallbacks;
15474: }
15474: 
15474: void
15474: nsIdentifierMapEntry::AddNameContent(nsIContent* aContent)
15474: {
15474:   if (!mNameContentList || mNameContentList == NAME_NOT_VALID)
15474:     return;
15474: 
15474:   // NOTE: this indexof is absolutely needed, since we don't flush
15474:   // content notifications when we do document.foo resolution.  So
15474:   // aContent may be in our list already and just now getting notified
15474:   // for!
15474:   if (mNameContentList->IndexOf(aContent, PR_FALSE) < 0) {
15474:     mNameContentList->AppendElement(aContent);
15474:   }
15474: }
15474: 
15474: void
15474: nsIdentifierMapEntry::RemoveNameContent(nsIContent* aContent)
15474: {
15474:   if (mNameContentList && mNameContentList != NAME_NOT_VALID) {
15474:     mNameContentList->RemoveElement(aContent);
15474:   }
15474: }
15474: 
    1: // Helper structs for the content->subdoc map
    1: 
    1: class SubDocMapEntry : public PLDHashEntryHdr
    1: {
    1: public:
    1:   // Both of these are strong references
    1:   nsIContent *mKey; // must be first, to look like PLDHashEntryStub
    1:   nsIDocument *mSubDocument;
    1: };
    1: 
    1: struct FindContentData
    1: {
    1:   FindContentData(nsIDocument *aSubDoc)
    1:     : mSubDocument(aSubDoc), mResult(nsnull)
    1:   {
    1:   }
    1: 
    1:   nsISupports *mSubDocument;
    1:   nsIContent *mResult;
    1: };
    1: 
    1: 
    1: /**
    1:  * A struct that holds all the information about a radio group.
    1:  */
    1: struct nsRadioGroupStruct
    1: {
    1:   /**
    1:    * A strong pointer to the currently selected radio button.
    1:    */
    1:   nsCOMPtr<nsIDOMHTMLInputElement> mSelectedRadioButton;
 6365:   nsCOMArray<nsIFormControl> mRadioButtons;
    1: };
    1: 
    1: 
    1: nsDOMStyleSheetList::nsDOMStyleSheetList(nsIDocument *aDocument)
    1: {
    1:   mLength = -1;
    1:   // Not reference counted to avoid circular references.
    1:   // The document will tell us when its going away.
    1:   mDocument = aDocument;
    1:   mDocument->AddObserver(this);
    1: }
    1: 
    1: nsDOMStyleSheetList::~nsDOMStyleSheetList()
    1: {
    1:   if (mDocument) {
    1:     mDocument->RemoveObserver(this);
    1:   }
    1: }
    1: 
    1: // XXX couldn't we use the GetIIDs method from CSSStyleSheetList here?
    1: // QueryInterface implementation for nsDOMStyleSheetList
 9123: NS_INTERFACE_TABLE_HEAD(nsDOMStyleSheetList)
 9123:   NS_INTERFACE_TABLE3(nsDOMStyleSheetList,
 9123:                       nsIDOMStyleSheetList,
 9123:                       nsIDocumentObserver,
 9123:                       nsIMutationObserver)
 9123:   NS_INTERFACE_TABLE_TO_MAP_SEGUE
29480:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(StyleSheetList)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsDOMStyleSheetList)
    1: NS_IMPL_RELEASE(nsDOMStyleSheetList)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStyleSheetList::GetLength(PRUint32* aLength)
    1: {
    1:   if (mDocument) {
    1:     // XXX Find the number and then cache it. We'll use the
    1:     // observer notification to figure out if new ones have
    1:     // been added or removed.
    1:     if (-1 == mLength) {
    1:       mLength = mDocument->GetNumberOfStyleSheets();
    1: 
    1: #ifdef DEBUG
    1:       PRInt32 i;
    1:       for (i = 0; i < mLength; i++) {
    1:         nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(i);
    1:         nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(sheet));
    1:         NS_ASSERTION(domss, "All \"normal\" sheets implement nsIDOMStyleSheet");
    1:       }
    1: #endif
    1:     }
    1:     *aLength = mLength;
    1:   }
    1:   else {
    1:     *aLength = 0;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
20752: nsIStyleSheet*
20752: nsDOMStyleSheetList::GetItemAt(PRUint32 aIndex)
20752: {
20752:   if (!mDocument || aIndex >= (PRUint32)mDocument->GetNumberOfStyleSheets()) {
20752:     return nsnull;
20752:   }
20752: 
    1:   nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(aIndex);
    1:   NS_ASSERTION(sheet, "Must have a sheet");
20752: 
20752:   return sheet;
20752: }
20752: 
20752: NS_IMETHODIMP
20752: nsDOMStyleSheetList::Item(PRUint32 aIndex, nsIDOMStyleSheet** aReturn)
20752: {
20752:   nsIStyleSheet *sheet = GetItemAt(aIndex);
20752:   if (!sheet) {
20752:       *aReturn = nsnull;
20752: 
20752:       return NS_OK;
20752:   }
20752: 
    1:   return CallQueryInterface(sheet, aReturn);
    1: }
    1: 
    1: void
    1: nsDOMStyleSheetList::NodeWillBeDestroyed(const nsINode *aNode)
    1: {
    1:   mDocument = nsnull;
    1: }
    1: 
    1: void
    1: nsDOMStyleSheetList::StyleSheetAdded(nsIDocument *aDocument,
    1:                                      nsIStyleSheet* aStyleSheet,
    1:                                      PRBool aDocumentSheet)
    1: {
    1:   if (aDocumentSheet && -1 != mLength) {
    1:     nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(aStyleSheet));
    1:     if (domss) {
    1:       mLength++;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsDOMStyleSheetList::StyleSheetRemoved(nsIDocument *aDocument,
    1:                                        nsIStyleSheet* aStyleSheet,
    1:                                        PRBool aDocumentSheet)
    1: {
    1:   if (aDocumentSheet && -1 != mLength) {
    1:     nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(aStyleSheet));
    1:     if (domss) {
    1:       mLength--;
    1:     }
    1:   }
    1: }
    1: 
    1: // nsOnloadBlocker implementation
    1: NS_IMPL_ISUPPORTS1(nsOnloadBlocker, nsIRequest)
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::GetName(nsACString &aResult)
    1: { 
    1:   aResult.AssignLiteral("about:document-onload-blocker");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::IsPending(PRBool *_retval)
    1: {
    1:   *_retval = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::GetStatus(nsresult *status)
    1: {
    1:   *status = NS_OK;
    1:   return NS_OK;
    1: } 
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::Cancel(nsresult status)
    1: {
    1:   return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::Suspend(void)
    1: {
    1:   return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::Resume(void)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::GetLoadGroup(nsILoadGroup * *aLoadGroup)
    1: {
    1:   *aLoadGroup = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::SetLoadGroup(nsILoadGroup * aLoadGroup)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::GetLoadFlags(nsLoadFlags *aLoadFlags)
    1: {
    1:   *aLoadFlags = nsIRequest::LOAD_NORMAL;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::SetLoadFlags(nsLoadFlags aLoadFlags)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // ==================================================================
20078: 
20078: nsExternalResourceMap::nsExternalResourceMap()
20078:   : mHaveShutDown(PR_FALSE)
20078: {
20078:   mMap.Init();
20078:   mPendingLoads.Init();
20078: }
20078: 
20078: nsIDocument*
20078: nsExternalResourceMap::RequestResource(nsIURI* aURI,
20078:                                        nsINode* aRequestingNode,
20078:                                        nsDocument* aDisplayDocument,
20078:                                        ExternalResourceLoad** aPendingLoad)
20078: {
20078:   // If we ever start allowing non-same-origin loads here, we might need to do
20078:   // something interesting with aRequestingPrincipal even for the hashtable
20078:   // gets.
20078:   NS_PRECONDITION(aURI, "Must have a URI");
20078:   NS_PRECONDITION(aRequestingNode, "Must have a node");
20078:   *aPendingLoad = nsnull;
20078:   if (mHaveShutDown) {
20078:     return nsnull;
20078:   }
20078:   
20078:   // First, make sure we strip the ref from aURI.
20078:   nsCOMPtr<nsIURI> clone;
20078:   aURI->Clone(getter_AddRefs(clone));
20078:   if (!clone) {
20078:     return nsnull;
20078:   }
20078:   nsCOMPtr<nsIURL> url(do_QueryInterface(clone));
20078:   if (url) {
20078:     url->SetRef(EmptyCString());
20078:   }
20078:   
20078:   ExternalResource* resource;
20078:   mMap.Get(clone, &resource);
20078:   if (resource) {
20078:     return resource->mDocument;
20078:   }
20078: 
20078:   nsRefPtr<PendingLoad> load;
20078:   mPendingLoads.Get(clone, getter_AddRefs(load));
20078:   if (load) {
20078:     NS_ADDREF(*aPendingLoad = load);
20078:     return nsnull;
20078:   }
20078: 
20078:   load = new PendingLoad(aDisplayDocument);
20078:   if (!load) {
20078:     return nsnull;
20078:   }
20078: 
20078:   if (!mPendingLoads.Put(clone, load)) {
20078:     return nsnull;
20078:   }
20078: 
20078:   if (NS_FAILED(load->StartLoad(clone, aRequestingNode))) {
20078:     // Make sure we don't thrash things by trying this load again, since
20078:     // chances are it failed for good reasons (security check, etc).
20078:     AddExternalResource(clone, nsnull, nsnull, aDisplayDocument);
20078:   } else {
20078:     NS_ADDREF(*aPendingLoad = load);
20078:   }
20078: 
20078:   return nsnull;
20078: }
20078: 
20078: struct
20078: nsExternalResourceEnumArgs
20078: {
20078:   nsIDocument::nsSubDocEnumFunc callback;
20078:   void *data;
20078: };
20078: 
20705: static PLDHashOperator
20078: ExternalResourceEnumerator(nsIURI* aKey,
20078:                            nsExternalResourceMap::ExternalResource* aData,
20078:                            void* aClosure)
20078: {
20078:   nsExternalResourceEnumArgs* args =
20078:     static_cast<nsExternalResourceEnumArgs*>(aClosure);
20463:   PRBool next =
20463:     aData->mDocument ? args->callback(aData->mDocument, args->data) : PR_TRUE;
20078:   return next ? PL_DHASH_NEXT : PL_DHASH_STOP;
20078: }
20078: 
20078: void
20078: nsExternalResourceMap::EnumerateResources(nsIDocument::nsSubDocEnumFunc aCallback,
20078:                                           void* aData)
20078: {
20078:   nsExternalResourceEnumArgs args = { aCallback, aData };
20078:   mMap.EnumerateRead(ExternalResourceEnumerator, &args);
20078: }
20078: 
20705: static PLDHashOperator
20078: ExternalResourceTraverser(nsIURI* aKey,
20078:                           nsExternalResourceMap::ExternalResource* aData,
20078:                           void* aClosure)
20078: {
20078:   nsCycleCollectionTraversalCallback *cb = 
20078:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
20078: 
20078:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
20078:                                      "mExternalResourceMap.mMap entry"
20078:                                      "->mDocument");
20078:   cb->NoteXPCOMChild(aData->mDocument);
20078: 
20078:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
20078:                                      "mExternalResourceMap.mMap entry"
20078:                                      "->mViewer");
20078:   cb->NoteXPCOMChild(aData->mViewer);
20078: 
20078:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
20078:                                      "mExternalResourceMap.mMap entry"
20078:                                      "->mLoadGroup");
20078:   cb->NoteXPCOMChild(aData->mLoadGroup);
20078: 
20078:   return PL_DHASH_NEXT;
20078: }
20078: 
20078: void
20078: nsExternalResourceMap::Traverse(nsCycleCollectionTraversalCallback* aCallback) const
20078: {
20078:   // mPendingLoads will get cleared out as the requests complete, so
20078:   // no need to worry about those here.
20078:   mMap.EnumerateRead(ExternalResourceTraverser, aCallback);
20078: }
20078: 
20078: nsresult
20078: nsExternalResourceMap::AddExternalResource(nsIURI* aURI,
20078:                                            nsIDocumentViewer* aViewer,
20078:                                            nsILoadGroup* aLoadGroup,
20078:                                            nsIDocument* aDisplayDocument)
20078: {
20078:   NS_PRECONDITION(aURI, "Unexpected call");
20078:   NS_PRECONDITION((aViewer && aLoadGroup) || (!aViewer && !aLoadGroup),
20078:                   "Must have both or neither");
20078:   
20078:   nsRefPtr<PendingLoad> load;
20078:   mPendingLoads.Get(aURI, getter_AddRefs(load));
20078:   mPendingLoads.Remove(aURI);
20078: 
20078:   nsresult rv = NS_OK;
20078:   
20078:   nsCOMPtr<nsIDocument> doc;
20078:   if (aViewer) {
20078:     aViewer->GetDocument(getter_AddRefs(doc));
20078:     NS_ASSERTION(doc, "Must have a document");
20078: 
20078:     nsCOMPtr<nsIXULDocument> xulDoc = do_QueryInterface(doc);
20078:     if (xulDoc) {
20078:       // We don't handle XUL stuff here yet.
20078:       rv = NS_ERROR_NOT_AVAILABLE;
20078:     } else {
20078:       doc->SetDisplayDocument(aDisplayDocument);
20078: 
23738:       rv = aViewer->Init(nsnull, nsIntRect(0, 0, 0, 0));
20078:       if (NS_SUCCEEDED(rv)) {
20078:         rv = aViewer->Open(nsnull, nsnull);
20078:       }
20078:     }
20078:     
20078:     if (NS_FAILED(rv)) {
20078:       doc = nsnull;
20078:       aViewer = nsnull;
20078:       aLoadGroup = nsnull;
20078:     }
20078:   }
20078: 
20078:   ExternalResource* newResource = new ExternalResource();
20078:   if (newResource && !mMap.Put(aURI, newResource)) {
20078:     delete newResource;
20078:     newResource = nsnull;
20078:     if (NS_SUCCEEDED(rv)) {
20078:       rv = NS_ERROR_OUT_OF_MEMORY;
20078:     }
20078:   }
20078: 
20078:   if (newResource) {
20078:     newResource->mDocument = doc;
20078:     newResource->mViewer = aViewer;
20078:     newResource->mLoadGroup = aLoadGroup;
20078:   }
20078: 
20078:   const nsTArray< nsCOMPtr<nsIObserver> > & obs = load->Observers();
20078:   for (PRUint32 i = 0; i < obs.Length(); ++i) {
20078:     obs[i]->Observe(doc, "external-resource-document-created", nsnull);
20078:   }
20078: 
20078:   return rv;
20078: }
20078: 
20078: NS_IMPL_ISUPPORTS2(nsExternalResourceMap::PendingLoad,
20078:                    nsIStreamListener,
20078:                    nsIRequestObserver)
20078: 
20078: NS_IMETHODIMP
20078: nsExternalResourceMap::PendingLoad::OnStartRequest(nsIRequest *aRequest,
20078:                                                    nsISupports *aContext)
20078: {
20078:   nsExternalResourceMap& map = mDisplayDocument->ExternalResourceMap();
20078:   if (map.HaveShutDown()) {
20078:     return NS_BINDING_ABORTED;
20078:   }
20078: 
20078:   nsCOMPtr<nsIDocumentViewer> viewer;
20078:   nsCOMPtr<nsILoadGroup> loadGroup;
20078:   nsresult rv = SetupViewer(aRequest, getter_AddRefs(viewer),
20078:                             getter_AddRefs(loadGroup));
20078: 
20078:   // Make sure to do this no matter what
20078:   nsresult rv2 = map.AddExternalResource(mURI, viewer, loadGroup,
20078:                                          mDisplayDocument);
20078:   if (NS_FAILED(rv)) {
20078:     return rv;
20078:   }
20078:   if (NS_FAILED(rv2)) {
20078:     mTargetListener = nsnull;
20078:     return rv2;
20078:   }
20078:   
20078:   return mTargetListener->OnStartRequest(aRequest, aContext);
20078: }
20078: 
20078: nsresult
20078: nsExternalResourceMap::PendingLoad::SetupViewer(nsIRequest* aRequest,
20078:                                                 nsIDocumentViewer** aViewer,
20078:                                                 nsILoadGroup** aLoadGroup)
20078: {
20078:   NS_PRECONDITION(!mTargetListener, "Unexpected call to OnStartRequest");
20078:   *aViewer = nsnull;
20078:   *aLoadGroup = nsnull;
20078:   
20078:   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
20078:   NS_ENSURE_TRUE(chan, NS_ERROR_UNEXPECTED);
20078: 
20078:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aRequest));
20078:   if (httpChannel) {
20078:     PRBool requestSucceeded;
20078:     if (NS_FAILED(httpChannel->GetRequestSucceeded(&requestSucceeded)) ||
20078:         !requestSucceeded) {
20078:       // Bail out on this load, since it looks like we have an HTTP error page
20078:       return NS_BINDING_ABORTED;
20078:     }
20078:   }
20078:  
20078:   nsCAutoString type;
20078:   chan->GetContentType(type);
20078: 
20078:   nsCOMPtr<nsILoadGroup> loadGroup;
20078:   chan->GetLoadGroup(getter_AddRefs(loadGroup));
20078: 
20078:   // Give this document its own loadgroup
20078:   nsCOMPtr<nsILoadGroup> newLoadGroup =
20078:         do_CreateInstance(NS_LOADGROUP_CONTRACTID);
20078:   NS_ENSURE_TRUE(newLoadGroup, NS_ERROR_OUT_OF_MEMORY);
20078:   newLoadGroup->SetLoadGroup(loadGroup);
20078: 
20078:   nsCOMPtr<nsIInterfaceRequestor> callbacks;
20078:   loadGroup->GetNotificationCallbacks(getter_AddRefs(callbacks));
20078: 
20078:   nsCOMPtr<nsIInterfaceRequestor> newCallbacks =
20078:     new LoadgroupCallbacks(callbacks);
20078:   newLoadGroup->SetNotificationCallbacks(newCallbacks);
20078: 
20078:   // This is some serious hackery cribbed from docshell
20078:   nsCOMPtr<nsICategoryManager> catMan =
20078:     do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
20078:   NS_ENSURE_TRUE(catMan, NS_ERROR_NOT_AVAILABLE);
20078:   nsXPIDLCString contractId;
20078:   nsresult rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", type.get(),
20078:                                          getter_Copies(contractId));
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078:   nsCOMPtr<nsIDocumentLoaderFactory> docLoaderFactory =
20078:     do_GetService(contractId);
20078:   NS_ENSURE_TRUE(docLoaderFactory, NS_ERROR_NOT_AVAILABLE);
20078: 
20078:   nsCOMPtr<nsIContentViewer> viewer;
20078:   nsCOMPtr<nsIStreamListener> listener;
20078:   rv = docLoaderFactory->CreateInstance("external-resource", chan, newLoadGroup,
20078:                                         type.get(), nsnull, nsnull,
20078:                                         getter_AddRefs(listener),
20078:                                         getter_AddRefs(viewer));
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078: 
20078:   nsCOMPtr<nsIDocumentViewer> docViewer = do_QueryInterface(viewer);
20078:   NS_ENSURE_TRUE(docViewer, NS_ERROR_UNEXPECTED);
20078: 
20078:   nsCOMPtr<nsIParser> parser = do_QueryInterface(listener);
20078:   if (!parser) {
20078:     /// We don't want to deal with the various fake documents yet
20078:     return NS_ERROR_NOT_IMPLEMENTED;
20078:   }
20078: 
20078:   // We can't handle HTML and other weird things here yet.
20078:   nsIContentSink* sink = parser->GetContentSink();
20078:   nsCOMPtr<nsIXMLContentSink> xmlSink = do_QueryInterface(sink);
20078:   if (!xmlSink) {
20078:     return NS_ERROR_NOT_IMPLEMENTED;
20078:   }
20078: 
20078:   listener.swap(mTargetListener);
20078:   docViewer.swap(*aViewer);
20078:   newLoadGroup.swap(*aLoadGroup);
20078:   return NS_OK;
20078: }
20078: 
20078: NS_IMETHODIMP
20078: nsExternalResourceMap::PendingLoad::OnDataAvailable(nsIRequest* aRequest,
20078:                                                     nsISupports* aContext,
20078:                                                     nsIInputStream* aStream,
20078:                                                     PRUint32 aOffset,
20078:                                                     PRUint32 aCount)
20078: {
20078:   NS_PRECONDITION(mTargetListener, "Shouldn't be getting called!");
20078:   if (mDisplayDocument->ExternalResourceMap().HaveShutDown()) {
20078:     return NS_BINDING_ABORTED;
20078:   }
20078:   return mTargetListener->OnDataAvailable(aRequest, aContext, aStream, aOffset,
20078:                                           aCount);
20078: }
20078: 
20078: NS_IMETHODIMP
20078: nsExternalResourceMap::PendingLoad::OnStopRequest(nsIRequest* aRequest,
20078:                                                   nsISupports* aContext,
20078:                                                   nsresult aStatus)
20078: {
20078:   // mTargetListener might be null if SetupViewer or AddExternalResource failed
20078:   if (mTargetListener) {
20078:     nsCOMPtr<nsIStreamListener> listener;
20078:     mTargetListener.swap(listener);
20078:     return listener->OnStopRequest(aRequest, aContext, aStatus);
20078:   }
20078: 
20078:   return NS_OK;
20078: }
20078: 
20078: nsresult
20078: nsExternalResourceMap::PendingLoad::StartLoad(nsIURI* aURI,
20078:                                               nsINode* aRequestingNode)
20078: {
20078:   NS_PRECONDITION(aURI, "Must have a URI");
20078:   NS_PRECONDITION(aRequestingNode, "Must have a node");
20078: 
20078:   // Time to start a load.  First, the security checks.
20078: 
20078:   nsIPrincipal* requestingPrincipal = aRequestingNode->NodePrincipal();
20078: 
20078:   nsresult rv = nsContentUtils::GetSecurityManager()->
20078:     CheckLoadURIWithPrincipal(requestingPrincipal, aURI,
20078:                               nsIScriptSecurityManager::STANDARD);
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078:   
20078:   rv = requestingPrincipal->CheckMayLoad(aURI, PR_TRUE);
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078: 
20078:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
20078:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OTHER,
20078:                                  aURI,
20078:                                  requestingPrincipal,
20078:                                  aRequestingNode,
20078:                                  EmptyCString(), //mime guess
20078:                                  nsnull,         //extra
20078:                                  &shouldLoad,
20078:                                  nsContentUtils::GetContentPolicy(),
20078:                                  nsContentUtils::GetSecurityManager());
20078:   if (NS_FAILED(rv)) return rv;
20078:   if (NS_CP_REJECTED(shouldLoad)) {
20078:     // Disallowed by content policy
20078:     return NS_ERROR_CONTENT_BLOCKED;
20078:   }
20078: 
20078:   nsIDocument* doc = aRequestingNode->GetOwnerDoc();
20078:   if (!doc) {
20078:     return NS_ERROR_NOT_AVAILABLE;
20078:   }
20078: 
21937:   nsCOMPtr<nsIInterfaceRequestor> req = nsContentUtils::GetSameOriginChecker();
21937:   NS_ENSURE_TRUE(req, NS_ERROR_OUT_OF_MEMORY);
21937: 
20078:   nsCOMPtr<nsILoadGroup> loadGroup = doc->GetDocumentLoadGroup();
20078:   nsCOMPtr<nsIChannel> channel;
21937:   rv = NS_NewChannel(getter_AddRefs(channel), aURI, nsnull, loadGroup, req);
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078: 
20078:   mURI = aURI;
20078: 
20078:   return channel->AsyncOpen(this, nsnull);
20078: }
20078: 
20078: NS_IMPL_ISUPPORTS1(nsExternalResourceMap::LoadgroupCallbacks,
20078:                    nsIInterfaceRequestor)
20078: 
21877: #define IMPL_SHIM(_i) \
21877:   NS_IMPL_ISUPPORTS1(nsExternalResourceMap::LoadgroupCallbacks::_i##Shim, _i)
21877: 
21877: IMPL_SHIM(nsILoadContext)
21878: IMPL_SHIM(nsIProgressEventSink)
21878: IMPL_SHIM(nsIChannelEventSink)
21878: IMPL_SHIM(nsISecurityEventSink)
21878: IMPL_SHIM(nsIApplicationCacheContainer)
21877: 
21877: #undef IMPL_SHIM
21877: 
21877: #define IID_IS(_i) aIID.Equals(NS_GET_IID(_i))
21877: 
21877: #define TRY_SHIM(_i)                                                       \
21877:   PR_BEGIN_MACRO                                                           \
21877:     if (IID_IS(_i)) {                                                      \
21877:       nsCOMPtr<_i> real = do_GetInterface(mCallbacks);                     \
21877:       if (!real) {                                                         \
21877:         return NS_NOINTERFACE;                                             \
21877:       }                                                                    \
21877:       nsCOMPtr<_i> shim = new _i##Shim(this, real);                        \
21877:       if (!shim) {                                                         \
21877:         return NS_ERROR_OUT_OF_MEMORY;                                     \
21877:       }                                                                    \
21877:       *aSink = shim.forget().get();                                        \
21877:       return NS_OK;                                                        \
21877:     }                                                                      \
21877:   PR_END_MACRO
21877: 
20078: NS_IMETHODIMP
20078: nsExternalResourceMap::LoadgroupCallbacks::GetInterface(const nsIID & aIID,
20078:                                                         void **aSink)
20078: {
20078:   if (mCallbacks &&
21877:       (IID_IS(nsIPrompt) || IID_IS(nsIAuthPrompt) || IID_IS(nsIAuthPrompt2))) {
20078:     return mCallbacks->GetInterface(aIID, aSink);
20078:   }
21877: 
21877:   *aSink = nsnull;
21877: 
21877:   TRY_SHIM(nsILoadContext);
21877:   TRY_SHIM(nsIProgressEventSink);
21877:   TRY_SHIM(nsIChannelEventSink);
21877:   TRY_SHIM(nsISecurityEventSink);
21877:   TRY_SHIM(nsIApplicationCacheContainer);
21877:     
21877:   return NS_NOINTERFACE;
21877: }
21877: 
21877: #undef TRY_SHIM
20078: #undef IID_IS
20078: 
20078: nsExternalResourceMap::ExternalResource::~ExternalResource()
20078: {
20078:   if (mViewer) {
20078:     mViewer->Close(nsnull);
20078:     mViewer->Destroy();
20078:   }
20078: }
20078: 
20078: // ==================================================================
    1: // =
    1: // ==================================================================
    1: 
    1: // If we ever have an nsIDocumentObserver notification for stylesheet title
    1: // changes, we could make this inherit from nsDOMStringList instead of
    1: // reimplementing nsIDOMDOMStringList.
    1: class nsDOMStyleSheetSetList : public nsIDOMDOMStringList
    1:                           
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_DECL_NSIDOMDOMSTRINGLIST
    1: 
    1:   nsDOMStyleSheetSetList(nsIDocument* aDocument);
    1: 
    1:   void Disconnect()
    1:   {
    1:     mDocument = nsnull;
    1:   }
    1: 
    1: protected:
    1:   // Rebuild our list of style sets
23904:   nsresult GetSets(nsTArray<nsString>& aStyleSets);
    1:   
    1:   nsIDocument* mDocument;  // Our document; weak ref.  It'll let us know if it
    1:                            // dies.
    1: };
    1: 
    1: NS_IMPL_ADDREF(nsDOMStyleSheetSetList)
    1: NS_IMPL_RELEASE(nsDOMStyleSheetSetList)
21218: NS_INTERFACE_TABLE_HEAD(nsDOMStyleSheetSetList)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsDOMStyleSheetSetList)
21218:     NS_INTERFACE_TABLE_ENTRY(nsDOMStyleSheetSetList, nsIDOMDOMStringList)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DOMStringList)
    1: NS_INTERFACE_MAP_END
    1: 
    1: nsDOMStyleSheetSetList::nsDOMStyleSheetSetList(nsIDocument* aDocument)
    1:   : mDocument(aDocument)
    1: {
    1:   NS_ASSERTION(mDocument, "Must have document!");
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStyleSheetSetList::Item(PRUint32 aIndex, nsAString& aResult)
    1: {
23904:   nsTArray<nsString> styleSets;
    1:   nsresult rv = GetSets(styleSets);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
23904:   if (aIndex >= styleSets.Length()) {
    1:     SetDOMStringToNull(aResult);
    1:   } else {
23904:     aResult = styleSets[aIndex];
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStyleSheetSetList::GetLength(PRUint32 *aLength)
    1: {
23904:   nsTArray<nsString> styleSets;
    1:   nsresult rv = GetSets(styleSets);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
23904:   *aLength = styleSets.Length();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStyleSheetSetList::Contains(const nsAString& aString, PRBool *aResult)
    1: {
23904:   nsTArray<nsString> styleSets;
    1:   nsresult rv = GetSets(styleSets);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
23904:   *aResult = styleSets.Contains(aString);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
23904: nsDOMStyleSheetSetList::GetSets(nsTArray<nsString>& aStyleSets)
    1: {
    1:   if (!mDocument) {
    1:     return NS_OK; // Spec says "no exceptions", and we have no style sets if we
    1:                   // have no document, for sure
    1:   }
    1:   
    1:   PRInt32 count = mDocument->GetNumberOfStyleSheets();
    1:   nsAutoString title;
    1:   nsAutoString temp;
    1:   for (PRInt32 index = 0; index < count; index++) {
    1:     nsIStyleSheet* sheet = mDocument->GetStyleSheetAt(index);
    1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
    1:     sheet->GetTitle(title);
23904:     if (!title.IsEmpty() && !aStyleSets.Contains(title) &&
23904:         !aStyleSets.AppendElement(title)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // ==================================================================
    1: // =
    1: // ==================================================================
    1: 
    1: class nsDOMImplementation : public nsIDOMDOMImplementation,
    1:                             public nsIPrivateDOMImplementation
    1: {
    1: public:
 6475:   nsDOMImplementation(nsIScriptGlobalObject* aScriptObject,
 6475:                       nsIURI* aDocumentURI,
    1:                       nsIURI* aBaseURI,
    1:                       nsIPrincipal* aPrincipal);
    1:   virtual ~nsDOMImplementation();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIDOMDOMImplementation
    1:   NS_DECL_NSIDOMDOMIMPLEMENTATION
    1: 
    1:   // nsIPrivateDOMImplementation
    1:   NS_IMETHOD Init(nsIURI* aDocumentURI, nsIURI* aBaseURI,
    1:                   nsIPrincipal* aPrincipal);
    1: 
    1: protected:
 6475:   nsWeakPtr mScriptObject;
    1:   nsCOMPtr<nsIURI> mDocumentURI;
    1:   nsCOMPtr<nsIURI> mBaseURI;
    1:   nsCOMPtr<nsIPrincipal> mPrincipal;
    1: };
    1: 
    1: 
    1: nsresult
    1: NS_NewDOMImplementation(nsIDOMDOMImplementation** aInstancePtrResult)
    1: {
 6475:   *aInstancePtrResult = new nsDOMImplementation(nsnull, nsnull, nsnull, nsnull);
    1:   if (!*aInstancePtrResult) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ADDREF(*aInstancePtrResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 6475: nsDOMImplementation::nsDOMImplementation(nsIScriptGlobalObject* aScriptObject,
 6475:                                          nsIURI* aDocumentURI,
    1:                                          nsIURI* aBaseURI,
    1:                                          nsIPrincipal* aPrincipal)
 6475:   : mScriptObject(do_GetWeakReference(aScriptObject)),
 6475:     mDocumentURI(aDocumentURI),
    1:     mBaseURI(aBaseURI),
    1:     mPrincipal(aPrincipal)
    1: {
    1: }
    1: 
    1: nsDOMImplementation::~nsDOMImplementation()
    1: {
    1: }
    1: 
    1: // QueryInterface implementation for nsDOMImplementation
    1: NS_INTERFACE_MAP_BEGIN(nsDOMImplementation)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDOMImplementation)
    1:   NS_INTERFACE_MAP_ENTRY(nsIPrivateDOMImplementation)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMDOMImplementation)
    1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(DOMImplementation)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsDOMImplementation)
    1: NS_IMPL_RELEASE(nsDOMImplementation)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDOMImplementation::HasFeature(const nsAString& aFeature,
    1:                                 const nsAString& aVersion,
    1:                                 PRBool* aReturn)
    1: {
    1:   return nsGenericElement::InternalIsSupported(
 3233:            static_cast<nsIDOMDOMImplementation*>(this),
    1:            aFeature, aVersion, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMImplementation::CreateDocumentType(const nsAString& aQualifiedName,
    1:                                         const nsAString& aPublicId,
    1:                                         const nsAString& aSystemId,
    1:                                         nsIDOMDocumentType** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::CheckQName(aQualifiedName);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aQualifiedName);
    1:   NS_ENSURE_TRUE(name, NS_ERROR_OUT_OF_MEMORY);
    1: 
15348:   // Indicate that there is no internal subset (not just an empty one)
15348:   nsAutoString voidString;
15348:   voidString.SetIsVoid(PR_TRUE);
    1:   return NS_NewDOMDocumentType(aReturn, nsnull, mPrincipal, name, nsnull,
15348:                                nsnull, aPublicId, aSystemId, voidString);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMImplementation::CreateDocument(const nsAString& aNamespaceURI,
    1:                                     const nsAString& aQualifiedName,
    1:                                     nsIDOMDocumentType* aDoctype,
    1:                                     nsIDOMDocument** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   nsresult rv;
    1:   if (!aQualifiedName.IsEmpty()) {
    1:     nsIParserService *parserService = nsContentUtils::GetParserService();
    1:     NS_ENSURE_TRUE(parserService, NS_ERROR_FAILURE);
    1: 
    1:     const nsAFlatString& qName = PromiseFlatString(aQualifiedName);
    1:     const PRUnichar *colon;
    1:     rv = parserService->CheckQName(qName, PR_TRUE, &colon);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (colon &&
    1:         (DOMStringIsNull(aNamespaceURI) ||
    1:          (Substring(qName.get(), colon).EqualsLiteral("xml") &&
    1:           !aNamespaceURI.EqualsLiteral("http://www.w3.org/XML/1998/namespace")))) {
    1:       return NS_ERROR_DOM_NAMESPACE_ERR;
    1:     }
    1:   }
    1:   else if (DOMStringIsNull(aQualifiedName) &&
    1:            !DOMStringIsNull(aNamespaceURI)) {
    1:     return NS_ERROR_DOM_NAMESPACE_ERR;
    1:   }
    1: 
    1:   if (aDoctype) {
    1:     nsCOMPtr<nsIDOMDocument> owner;
    1:     aDoctype->GetOwnerDocument(getter_AddRefs(owner));
    1:     if (owner) {
    1:       return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
    1:     }
    1:   }
    1: 
 6475:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
 6475:     do_QueryReferent(mScriptObject);
 6475: 
    1:   return nsContentUtils::CreateDocument(aNamespaceURI, aQualifiedName, aDoctype,
    1:                                         mDocumentURI, mBaseURI, mPrincipal,
 6475:                                         scriptHandlingObject, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMImplementation::Init(nsIURI* aDocumentURI, nsIURI* aBaseURI,
    1:                           nsIPrincipal* aPrincipal)
    1: {
    1:   // Note: can't require that the args be non-null, since at least one
    1:   // caller (XMLHttpRequest) doesn't have decent args to pass in.
    1:   mDocumentURI = aDocumentURI;
    1:   mBaseURI = aBaseURI;
    1:   mPrincipal = aPrincipal;
    1:   return NS_OK;
    1: }
    1: 
    1: // ==================================================================
    1: // =
    1: // ==================================================================
    1: 
    1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
    1: nsDocument::nsDocument(const char* aContentType)
34205:   : nsIDocument()
    1: {
    1:   mContentType = aContentType;
    1:   
    1: #ifdef PR_LOGGING
    1:   if (!gDocumentLeakPRLog)
    1:     gDocumentLeakPRLog = PR_NewLogModule("DocumentLeak");
    1: 
    1:   if (gDocumentLeakPRLog)
    1:     PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
    1:            ("DOCUMENT %p created", this));
    1: #endif
    1: 
    1:   // Start out mLastStyleSheetSet as null, per spec
    1:   SetDOMStringToNull(mLastStyleSheetSet);
    1: }
    1: 
20261: static PLDHashOperator
11731: ClearAllBoxObjects(const void* aKey, nsPIBoxObject* aBoxObject, void* aUserArg)
11731: {
11731:   if (aBoxObject) {
11731:     aBoxObject->Clear();
11731:   }
11731:   return PL_DHASH_NEXT;
11731: }
11731: 
    1: nsDocument::~nsDocument()
    1: {
    1: #ifdef PR_LOGGING
    1:   if (gDocumentLeakPRLog)
    1:     PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
    1:            ("DOCUMENT %p destroyed", this));
    1: #endif
    1: 
    1: #ifdef DEBUG
 3233:   nsCycleCollector_DEBUG_wasFreed(static_cast<nsIDocument*>(this));
    1: #endif
    1: 
    1:   mInDestructor = PR_TRUE;
    1: 
    1:   // Clear mObservers to keep it in sync with the mutationobserver list
    1:   mObservers.Clear();
    1: 
    1:   if (mStyleSheetSetList) {
    1:     mStyleSheetSetList->Disconnect();
    1:   }
    1: 
    1:   mParentDocument = nsnull;
    1: 
    1:   // Kill the subdocument map, doing this will release its strong
    1:   // references, if any.
    1:   if (mSubDocuments) {
    1:     PL_DHashTableDestroy(mSubDocuments);
    1: 
    1:     mSubDocuments = nsnull;
    1:   }
    1: 
    1:   // Destroy link map now so we don't waste time removing
    1:   // links one by one
    1:   DestroyLinkMap();
    1: 
14228:   nsAutoScriptBlocker scriptBlocker;
14228: 
 8938:   PRInt32 indx; // must be signed
    1:   PRUint32 count = mChildren.ChildCount();
    1:   for (indx = PRInt32(count) - 1; indx >= 0; --indx) {
    1:     mChildren.ChildAt(indx)->UnbindFromTree();
    1:     mChildren.RemoveChildAt(indx);
    1:   }
 8938:   mCachedRootContent = nsnull;
    1: 
    1:   // Let the stylesheets know we're going away
    1:   indx = mStyleSheets.Count();
    1:   while (--indx >= 0) {
    1:     mStyleSheets[indx]->SetOwningDocument(nsnull);
    1:   }
    1:   indx = mCatalogSheets.Count();
    1:   while (--indx >= 0) {
    1:     mCatalogSheets[indx]->SetOwningDocument(nsnull);
    1:   }
    1:   if (mAttrStyleSheet)
    1:     mAttrStyleSheet->SetOwningDocument(nsnull);
    1:   if (mStyleAttrStyleSheet)
    1:     mStyleAttrStyleSheet->SetOwningDocument(nsnull);
    1: 
    1:   if (mListenerManager) {
    1:     mListenerManager->Disconnect();
    1:   }
    1: 
    1:   if (mScriptLoader) {
    1:     mScriptLoader->DropDocumentReference();
    1:   }
    1: 
    1:   if (mCSSLoader) {
    1:     // Could be null here if Init() failed
    1:     mCSSLoader->DropDocumentReference();
    1:     NS_RELEASE(mCSSLoader);
    1:   }
    1: 
    1:   // XXX Ideally we'd do this cleanup in the nsIDocument destructor.
    1:   if (mNodeInfoManager) {
    1:     mNodeInfoManager->DropDocumentReference();
    1:     NS_RELEASE(mNodeInfoManager);
    1:   }
    1: 
    1:   if (mAttrStyleSheet) {
    1:     mAttrStyleSheet->SetOwningDocument(nsnull);
    1:   }
    1:   
    1:   if (mStyleAttrStyleSheet) {
    1:     mStyleAttrStyleSheet->SetOwningDocument(nsnull);
    1:   }
    1: 
    1:   delete mHeaderData;
11731: 
11731:   if (mBoxObjectTable) {
11731:     mBoxObjectTable->EnumerateRead(ClearAllBoxObjects, nsnull);
    1:     delete mBoxObjectTable;
11731:   }
28045: 
28045:   mPendingTitleChangeEvent.Revoke();
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDocument)
    1: 
12033: NS_INTERFACE_TABLE_HEAD(nsDocument)
21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
21218:   NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsDocument)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsINode)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDocument)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOM3DocumentEvent)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentStyle)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMNSDocumentStyle)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentRange)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentXBL)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIScriptObjectPrincipal)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOM3EventTarget)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMNSEventTarget)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsPIDOMEventTarget)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsISupportsWeakReference)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIRadioGroupContainer)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIMutationObserver)
16106:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMNodeSelector)
18430:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIApplicationCacheContainer)
29215:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMXPathNSResolver)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDocument)
12033:   if (aIID.Equals(NS_GET_IID(nsIDOMXPathEvaluator)) ||
12033:       aIID.Equals(NS_GET_IID(nsIXPathEvaluatorInternal))) {
12033:     if (!mXPathEvaluatorTearoff) {
12033:       nsresult rv;
12033:       mXPathEvaluatorTearoff =
12033:         do_CreateInstance(NS_XPATH_EVALUATOR_CONTRACTID,
12033:                           static_cast<nsIDocument *>(this), &rv);
12033:       NS_ENSURE_SUCCESS(rv, rv);
12033:     }
12033: 
12033:     return mXPathEvaluatorTearoff->QueryInterface(aIID, aInstancePtr);
12033:   }
12033:   else
12033: NS_INTERFACE_MAP_END
12033: 
12033: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsDocument, nsIDocument)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS_WITH_DESTROY(nsDocument, 
    1:                                                         nsIDocument,
 1391:                                                         nsNodeUtils::LastRelease(this))
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsDocument)
30001:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_END
    1: 
20261: static PLDHashOperator
    1: SubDocTraverser(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,
    1:                 void *arg)
    1: {
 3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(arg);
    1: 
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mSubDocuments entry->mKey");
    1:   cb->NoteXPCOMChild(entry->mKey);
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mSubDocuments entry->mSubDocument");
    1:   cb->NoteXPCOMChild(entry->mSubDocument);
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
20078: RadioGroupsTraverser(const nsAString& aKey, nsRadioGroupStruct* aData,
20078:                      void* aClosure)
 6365: {
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
    1: 
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
13202:                                    "mRadioGroups entry->mSelectedRadioButton");
 6365:   cb->NoteXPCOMChild(aData->mSelectedRadioButton);
 6365: 
 6365:   PRUint32 i, count = aData->mRadioButtons.Count();
    1:   for (i = 0; i < count; ++i) {
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
13202:                                        "mRadioGroups entry->mRadioButtons[i]");
 6365:     cb->NoteXPCOMChild(aData->mRadioButtons[i]);
 6365:   }
 6365: 
 6365:   return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
11731: BoxObjectTraverser(const void* key, nsPIBoxObject* boxObject, void* userArg)
    1: {
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(userArg);
    1:  
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mBoxObjectTable entry");
    1:   cb->NoteXPCOMChild(boxObject);
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: class LinkMapTraversalVisitor : public nsUint32ToContentHashEntry::Visitor
    1: {
    1: public:
    1:   nsCycleCollectionTraversalCallback *mCb;
    1:   virtual void Visit(nsIContent* aContent)
    1:   {
18993:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*mCb, "mLinkMap entry");
    1:     mCb->NoteXPCOMChild(aContent);
    1:   }
    1: };
    1: 
20261: static PLDHashOperator
    1: LinkMapTraverser(nsUint32ToContentHashEntry* aEntry, void* userArg)
    1: {
    1:   LinkMapTraversalVisitor visitor;
 3233:   visitor.mCb = static_cast<nsCycleCollectionTraversalCallback*>(userArg);
    1:   aEntry->VisitContent(&visitor);
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
15474: IdentifierMapEntryTraverse(nsIdentifierMapEntry *aEntry, void *aArg)
15474: {
15474:   nsCycleCollectionTraversalCallback *cb =
15474:     static_cast<nsCycleCollectionTraversalCallback*>(aArg);
15474:   aEntry->Traverse(cb);
15474:   return PL_DHASH_NEXT;
15474: }
15474: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsDocument)
30001:   // Always need to traverse script objects, so do that before we check
30001:   // if we're uncollectable.
30001:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
30001: 
30096:   if (nsCCUncollectableMarker::InGeneration(cb, tmp->GetMarkedCCGeneration())) {
25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
 1353:   }
 1353: 
15474:   tmp->mIdentifierMap.EnumerateEntries(IdentifierMapEntryTraverse, &cb);
15474: 
20078:   tmp->mExternalResourceMap.Traverse(&cb);
20078: 
13669:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
13669: 
    1:   // Traverse the mChildren nsAttrAndChildArray.
    1:   for (PRInt32 indx = PRInt32(tmp->mChildren.ChildCount()); indx > 0; --indx) {
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildren[i]");
    1:     cb.NoteXPCOMChild(tmp->mChildren.ChildAt(indx - 1));
    1:   }
    1: 
 1391:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA
 1391: 
    1:   // Traverse all nsIDocument pointer members.
 8938:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCachedRootContent)
13669:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mNodeInfoManager,
13669:                                                   nsNodeInfoManager)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSecurityInfo)
20078:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDisplayDocument)
    1: 
    1:   // Traverse all nsDocument nsCOMPtrs.
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mParser)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptGlobalObject)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mListenerManager)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDOMStyleSheets)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptLoader)
    1: 
20078:   tmp->mRadioGroups.EnumerateRead(RadioGroupsTraverser, &cb);
    1: 
    1:   // The boxobject for an element will only exist as long as it's in the
    1:   // document, so we'll traverse the table here instead of from the element.
    1:   if (tmp->mBoxObjectTable) {
    1:     tmp->mBoxObjectTable->EnumerateRead(BoxObjectTraverser, &cb);
    1:   }
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannel)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mStyleAttrStyleSheet)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptEventManager)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mXPathEvaluatorTearoff)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLayoutHistoryState)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnloadBlocker)
33055:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstBaseNodeWithHref)
34007:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDOMImplementation)
    1: 
    1:   // An element will only be in the linkmap as long as it's in the
    1:   // document, so we'll traverse the table here instead of from the element.
    1:   if (tmp->mLinkMap.IsInitialized()) {
    1:     tmp->mLinkMap.EnumerateEntries(LinkMapTraverser, &cb);
    1:   }
    1: 
    1:   // Traverse all our nsCOMArrays.
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mStyleSheets)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mCatalogSheets)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mVisitednessChangedURIs)
30065:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mPreloadingImages)
    1: 
23697: #ifdef MOZ_SMIL
23697:   // Traverse animation components
23697:   if (tmp->mAnimationController) {
23697:     tmp->mAnimationController->Traverse(&cb);
23697:   }
23697: #endif // MOZ_SMIL
23697: 
    1:   if (tmp->mSubDocuments && tmp->mSubDocuments->ops) {
    1:     PL_DHashTableEnumerate(tmp->mSubDocuments, SubDocTraverser, &cb);
    1:   }
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsDocument)
30001:   NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_END
30001: 
30001: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDocument)
 8462:   // Tear down linkmap. This is a performance optimization so that we
 8462:   // don't waste time removing links one by one as they are removed
 8462:   // from the doc.
 8462:   tmp->DestroyLinkMap();
 8462: 
20078:   // Clear out our external resources
20078:   tmp->mExternalResourceMap.Shutdown();
20078: 
14228:   nsAutoScriptBlocker scriptBlocker;
14228: 
    1:   // Unlink the mChildren nsAttrAndChildArray.
    1:   for (PRInt32 indx = PRInt32(tmp->mChildren.ChildCount()) - 1; 
    1:        indx >= 0; --indx) {
    1:     tmp->mChildren.ChildAt(indx)->UnbindFromTree();
    1:     tmp->mChildren.RemoveChildAt(indx);
    1:   }
    1: 
 8938:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCachedRootContent)
20078:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDisplayDocument)
33055:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFirstBaseNodeWithHref)
34007:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDOMImplementation)
 8938: 
 1391:   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
 1391: 
    1:   tmp->mParentDocument = nsnull;
    1: 
30065:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mPreloadingImages)
30065: 
    1:   // nsDocument has a pretty complex destructor, so we're going to
    1:   // assume that *most* cycles you actually want to break somewhere
    1:   // else, and not unlink an awful lot here.
    1:   //
    1:   // In rare cases where you think an unlink will help here, add one
    1:   // manually.
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
    1: 
    1: nsresult
    1: nsDocument::Init()
    1: {
13669:   if (mCSSLoader || mNodeInfoManager || mScriptLoader) {
    1:     return NS_ERROR_ALREADY_INITIALIZED;
    1:   }
    1: 
15474:   mIdentifierMap.Init();
    1:   mLinkMap.Init();
 6365:   mRadioGroups.Init();
    1: 
    1:   // Force initialization.
    1:   nsINode::nsSlots* slots = GetSlots();
 8678:   NS_ENSURE_TRUE(slots,NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // Prepend self as mutation-observer whether we need it or not (some
    1:   // subclasses currently do, other don't). This is because the code in
    1:   // nsNodeUtils always notifies the first observer first, expecting the
    1:   // first observer to be the document.
 9596:   NS_ENSURE_TRUE(slots->mMutationObservers.PrependElementUnlessExists(static_cast<nsIMutationObserver*>(this)),
    1:                  NS_ERROR_OUT_OF_MEMORY);
    1: 
    1: 
    1:   mOnloadBlocker = new nsOnloadBlocker();
    1:   NS_ENSURE_TRUE(mOnloadBlocker, NS_ERROR_OUT_OF_MEMORY);
    1:   
    1:   NS_NewCSSLoader(this, &mCSSLoader);
    1:   NS_ENSURE_TRUE(mCSSLoader, NS_ERROR_OUT_OF_MEMORY);
33262:   // Assume we're not quirky, until we know otherwise
    1:   mCSSLoader->SetCompatibilityMode(eCompatibility_FullStandards);
    1: 
11169:   mNodeInfoManager = new nsNodeInfoManager();
11169:   NS_ENSURE_TRUE(mNodeInfoManager, NS_ERROR_OUT_OF_MEMORY);
11169: 
11169:   NS_ADDREF(mNodeInfoManager);
11169: 
11169:   nsresult  rv = mNodeInfoManager->Init(this);
11169:   NS_ENSURE_SUCCESS(rv, rv);
11169: 
11169:   mNodeInfo = mNodeInfoManager->GetDocumentNodeInfo();
11169:   NS_ENSURE_TRUE(mNodeInfo, NS_ERROR_OUT_OF_MEMORY);
11169: 
    1:   NS_ASSERTION(GetOwnerDoc() == this, "Our nodeinfo is busted!");
    1: 
 2007:   mScriptLoader = new nsScriptLoader(this);
 2007:   NS_ENSURE_TRUE(mScriptLoader, NS_ERROR_OUT_OF_MEMORY);
 2007: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocument::AddXMLEventsContent(nsIContent *aXMLEventsElement)
    1: {
    1:   if (!mXMLEventsManager) {
    1:     mXMLEventsManager = new nsXMLEventsManager();
    1:     NS_ENSURE_TRUE(mXMLEventsManager, NS_ERROR_OUT_OF_MEMORY);
    1:     AddObserver(mXMLEventsManager);
    1:   }
    1:   mXMLEventsManager->AddXMLEventsContent(aXMLEventsElement);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup)
    1: {
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsCOMPtr<nsIPrincipal> principal;
    1:   if (aChannel) {
    1:     // Note: this code is duplicated in nsXULDocument::StartDocumentLoad and
    1:     // nsScriptSecurityManager::GetChannelPrincipal.    
    1:     // Note: this should match nsDocShell::OnLoadingSite
 7109:     NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
    1: 
    1:     nsIScriptSecurityManager *securityManager =
    1:       nsContentUtils::GetSecurityManager();
    1:     if (securityManager) {
    1:       securityManager->GetChannelPrincipal(aChannel,
    1:                                            getter_AddRefs(principal));
    1:     }
    1:   }
    1: 
    1:   ResetToURI(uri, aLoadGroup, principal);
    1: 
21811:   nsCOMPtr<nsIPropertyBag2> bag = do_QueryInterface(aChannel);
21811:   if (bag) {
21811:     nsCOMPtr<nsIURI> baseURI;
21811:     bag->GetPropertyAsInterface(NS_LITERAL_STRING("baseURI"),
21811:                                 NS_GET_IID(nsIURI), getter_AddRefs(baseURI));
21811:     if (baseURI) {
21811:       mDocumentBaseURI = baseURI;
21811:     }
21811:   }
21811: 
    1:   mChannel = aChannel;
    1: }
    1: 
    1: void
    1: nsDocument::ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
    1:                        nsIPrincipal* aPrincipal)
    1: {
    1:   NS_PRECONDITION(aURI, "Null URI passed to ResetToURI");
    1: 
    1: #ifdef PR_LOGGING
    1:   if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
    1:     nsCAutoString spec;
    1:     aURI->GetSpec(spec);
    1:     PR_LogPrint("DOCUMENT %p ResetToURI %s", this, spec.get());
    1:   }
    1: #endif
    1: 
15474:   mIdentifierMap.Clear();
    1: 
    1:   SetPrincipal(nsnull);
    1:   mSecurityInfo = nsnull;
    1: 
    1:   mDocumentLoadGroup = nsnull;
    1: 
    1:   // Delete references to sub-documents and kill the subdocument map,
    1:   // if any. It holds strong references
    1:   if (mSubDocuments) {
    1:     PL_DHashTableDestroy(mSubDocuments);
    1: 
    1:     mSubDocuments = nsnull;
    1:   }
    1: 
    1:   // Destroy link map now so we don't waste time removing
    1:   // links one by one
    1:   DestroyLinkMap();
    1: 
    1:   PRUint32 count = mChildren.ChildCount();
11681:   { // Scope for update
11681:     MOZ_AUTO_DOC_UPDATE(this, UPDATE_CONTENT_MODEL, PR_TRUE);    
    1:     for (PRInt32 i = PRInt32(count) - 1; i >= 0; i--) {
    1:       nsCOMPtr<nsIContent> content = mChildren.ChildAt(i);
    1: 
33055:       mChildren.RemoveChildAt(i);
    1:       nsNodeUtils::ContentRemoved(this, content, i);
    1:       content->UnbindFromTree();
    1:     }
11681:   }
 8938:   mCachedRootContent = nsnull;
    1: 
    1:   // Reset our stylesheets
    1:   ResetStylesheetsToURI(aURI);
    1:   
    1:   // Release the listener manager
    1:   if (mListenerManager) {
    1:     mListenerManager->Disconnect();
    1:     mListenerManager = nsnull;
    1:   }
    1: 
    1:   // Release the stylesheets list.
    1:   mDOMStyleSheets = nsnull;
    1: 
    1:   SetDocumentURI(aURI);
33055:   // If mDocumentBaseURI is null, nsIDocument::GetBaseURI() returns
33055:   // mDocumentURI.
33055:   mDocumentBaseURI = nsnull;
    1: 
    1:   if (aLoadGroup) {
    1:     mDocumentLoadGroup = do_GetWeakReference(aLoadGroup);
    1:     // there was an assertion here that aLoadGroup was not null.  This
28078:     // is no longer valid: nsDocShell::SetDocument does not create a
28078:     // load group, and it works just fine
28078: 
28078:     // XXXbz what does "just fine" mean exactly?  And given that there
28078:     // is no nsDocShell::SetDocument, what is this talking about?
    1:   }
    1: 
    1:   mLastModified.Truncate();
    1:   // XXXbz I guess we're assuming that the caller will either pass in
    1:   // a channel with a useful type or call SetContentType?
    1:   mContentType.Truncate();
    1:   mContentLanguage.Truncate();
    1:   mBaseTarget.Truncate();
    1:   mReferrer.Truncate();
    1: 
    1:   mXMLDeclarationBits = 0;
    1: 
    1:   // Now get our new principal
    1:   if (aPrincipal) {
    1:     SetPrincipal(aPrincipal);
    1:   } else {
    1:     nsIScriptSecurityManager *securityManager =
    1:       nsContentUtils::GetSecurityManager();
    1:     if (securityManager) {
    1:       nsCOMPtr<nsIPrincipal> principal;
    1:       nsresult rv =
    1:         securityManager->GetCodebasePrincipal(mDocumentURI,
    1:                                               getter_AddRefs(principal));
    1:       if (NS_SUCCEEDED(rv)) {
    1:         SetPrincipal(principal);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsDocument::ResetStylesheetsToURI(nsIURI* aURI)
    1: {
    1:   NS_PRECONDITION(aURI, "Null URI passed to ResetStylesheetsToURI");
    1: 
    1:   mozAutoDocUpdate upd(this, UPDATE_STYLE, PR_TRUE);
    1:   
    1:   // The stylesheets should forget us
    1:   PRInt32 indx = mStyleSheets.Count();
    1:   while (--indx >= 0) {
    1:     nsIStyleSheet* sheet = mStyleSheets[indx];
    1:     sheet->SetOwningDocument(nsnull);
    1: 
    1:     PRBool applicable;
    1:     sheet->GetApplicable(applicable);
    1:     if (applicable) {
    1:       RemoveStyleSheetFromStyleSets(sheet);
    1:     }
    1: 
    1:     // XXX Tell observers?
    1:   }
    1: 
    1:   indx = mCatalogSheets.Count();
    1:   while (--indx >= 0) {
    1:     nsIStyleSheet* sheet = mCatalogSheets[indx];
    1:     sheet->SetOwningDocument(nsnull);
    1: 
    1:     PRBool applicable;
    1:     sheet->GetApplicable(applicable);
    1:     if (applicable) {
 1722:       nsPresShellIterator iter(this);
 1722:       nsCOMPtr<nsIPresShell> shell;
 1722:       while ((shell = iter.GetNextShell())) {
 1722:         shell->StyleSet()->RemoveStyleSheet(nsStyleSet::eAgentSheet, sheet);
    1:       }
    1:     }
    1: 
    1:     // XXX Tell observers?
    1:   }
    1: 
    1: 
    1:   // Release all the sheets
    1:   mStyleSheets.Clear();
    1:   // NOTE:  We don't release the catalog sheets.  It doesn't really matter
    1:   // now, but it could in the future -- in which case not releasing them
    1:   // is probably the right thing to do.
    1: 
    1:   // Now reset our inline style and attribute sheets.
    1:   nsresult rv;
    1:   nsStyleSet::sheetType attrSheetType = GetAttrSheetType();
    1:   if (mAttrStyleSheet) {
    1:     // Remove this sheet from all style sets
 1722:     nsPresShellIterator iter(this);
 1722:     nsCOMPtr<nsIPresShell> shell;
 1722:     while ((shell = iter.GetNextShell())) {
 1722:       shell->StyleSet()->RemoveStyleSheet(attrSheetType, mAttrStyleSheet);
    1:     }
    1:     rv = mAttrStyleSheet->Reset(aURI);
    1:   } else {
    1:     rv = NS_NewHTMLStyleSheet(getter_AddRefs(mAttrStyleSheet), aURI, this);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Don't use AddStyleSheet, since it'll put the sheet into style
    1:   // sets in the document level, which is not desirable here.
    1:   mAttrStyleSheet->SetOwningDocument(this);
    1:   
    1:   if (mStyleAttrStyleSheet) {
    1:     // Remove this sheet from all style sets
 1722:     nsPresShellIterator iter(this);
 1722:     nsCOMPtr<nsIPresShell> shell;
 1722:     while ((shell = iter.GetNextShell())) {
 1722:       shell->StyleSet()->
    1:         RemoveStyleSheet(nsStyleSet::eStyleAttrSheet, mStyleAttrStyleSheet);
    1:     }
    1:     rv = mStyleAttrStyleSheet->Reset(aURI);
    1:   } else {
    1:     rv = NS_NewHTMLCSSStyleSheet(getter_AddRefs(mStyleAttrStyleSheet), aURI,
    1:                                                 this);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // The loop over style sets below will handle putting this sheet
    1:   // into style sets as needed.
    1:   mStyleAttrStyleSheet->SetOwningDocument(this);
    1: 
    1:   // Now set up our style sets
 1722:   nsPresShellIterator iter(this);
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell())) {
 1722:     FillStyleSet(shell->StyleSet());
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsStyleSet::sheetType
    1: nsDocument::GetAttrSheetType()
    1: {
    1:   return nsStyleSet::ePresHintSheet;
    1: }
    1: 
    1: void
    1: nsDocument::FillStyleSet(nsStyleSet* aStyleSet)
    1: {
    1:   NS_PRECONDITION(aStyleSet, "Must have a style set");
    1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::ePresHintSheet) == 0,
    1:                   "Style set already has a preshint sheet?");
    1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eHTMLPresHintSheet) == 0,
    1:                   "Style set already has a HTML preshint sheet?");
    1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eDocSheet) == 0,
    1:                   "Style set already has document sheets?");
    1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eStyleAttrSheet) == 0,
    1:                   "Style set already has style attr sheets?");
    1:   NS_PRECONDITION(mStyleAttrStyleSheet, "No style attr stylesheet?");
    1:   NS_PRECONDITION(mAttrStyleSheet, "No attr stylesheet?");
    1:   
    1:   aStyleSet->AppendStyleSheet(GetAttrSheetType(), mAttrStyleSheet);
    1: 
    1:   aStyleSet->AppendStyleSheet(nsStyleSet::eStyleAttrSheet,
    1:                               mStyleAttrStyleSheet);
    1: 
    1:   PRInt32 i;
    1:   for (i = mStyleSheets.Count() - 1; i >= 0; --i) {
    1:     nsIStyleSheet* sheet = mStyleSheets[i];
    1:     PRBool sheetApplicable;
    1:     sheet->GetApplicable(sheetApplicable);
    1:     if (sheetApplicable) {
    1:       aStyleSet->AddDocStyleSheet(sheet, this);
    1:     }
    1:   }
    1: 
    1:   for (i = mCatalogSheets.Count() - 1; i >= 0; --i) {
    1:     nsIStyleSheet* sheet = mCatalogSheets[i];
    1:     PRBool sheetApplicable;
    1:     sheet->GetApplicable(sheetApplicable);
    1:     if (sheetApplicable) {
    1:       aStyleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, sheet);
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsDocument::StartDocumentLoad(const char* aCommand, nsIChannel* aChannel,
    1:                               nsILoadGroup* aLoadGroup,
    1:                               nsISupports* aContainer,
    1:                               nsIStreamListener **aDocListener,
    1:                               PRBool aReset, nsIContentSink* aSink)
    1: {
    1: #ifdef PR_LOGGING
    1:   if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
    1:     nsCOMPtr<nsIURI> uri;
    1:     aChannel->GetURI(getter_AddRefs(uri));
    1:     nsCAutoString spec;
    1:     if (uri)
    1:       uri->GetSpec(spec);
    1:     PR_LogPrint("DOCUMENT %p StartDocumentLoad %s", this, spec.get());
    1:   }
    1: #endif
    1: 
23639:   SetReadyStateInternal(READYSTATE_LOADING);
23639: 
 4064:   if (nsCRT::strcmp(kLoadAsData, aCommand) == 0) {
 4064:     mLoadedAsData = PR_TRUE;
 4064:     // We need to disable script & style loading in this case.
 4064:     // We leave them disabled even in EndLoad(), and let anyone
 4064:     // who puts the document on display to worry about enabling.
 4064: 
 4064:     // Do not load/process scripts when loading as data
 4064:     ScriptLoader()->SetEnabled(PR_FALSE);
 4064: 
 4064:     // styles
 4064:     CSSLoader()->SetEnabled(PR_FALSE); // Do not load/process styles when loading as data
20078:   } else if (nsCRT::strcmp("external-resource", aCommand) == 0) {
20078:     // Allow CSS, but not scripts
20078:     ScriptLoader()->SetEnabled(PR_FALSE);
 4064:   }
 4064: 
10474:   mMayStartLayout = PR_FALSE;
10474: 
16447:   mHaveInputEncoding = PR_TRUE;
16447: 
    1:   if (aReset) {
    1:     Reset(aChannel, aLoadGroup);
    1:   }
    1: 
    1:   nsCAutoString contentType;
    1:   if (NS_SUCCEEDED(aChannel->GetContentType(contentType))) {
    1:     // XXX this is only necessary for viewsource:
    1:     nsACString::const_iterator start, end, semicolon;
    1:     contentType.BeginReading(start);
    1:     contentType.EndReading(end);
    1:     semicolon = start;
    1:     FindCharInReadable(';', semicolon, end);
    1:     mContentType = Substring(start, semicolon);
    1:   }
    1: 
    1:   RetrieveRelevantHeaders(aChannel);
    1: 
    1:   mChannel = aChannel;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::StopDocumentLoad()
    1: {
    1:   if (mParser) {
    1:     mParser->Terminate();
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::SetDocumentURI(nsIURI* aURI)
    1: {
33055:   nsCOMPtr<nsIURI> oldBase = nsIDocument::GetBaseURI();
    1:   mDocumentURI = NS_TryToMakeImmutable(aURI);
33055:   nsIURI* newBase = nsIDocument::GetBaseURI();
33055: 
33055:   PRBool equalBases = PR_FALSE;
33055:   if (oldBase && newBase) {
33055:     oldBase->Equals(newBase, &equalBases);
33055:   }
33055:   else {
33055:     equalBases = !oldBase && !newBase;
33055:   }
33055: 
33055:   // If changing the document's URI changed the base URI of the document, we
33055:   // need to refresh the hrefs of all the links on the page.
33055:   if (!equalBases) {
33055:     RefreshLinkHrefs();
33055:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLastModified(nsAString& aLastModified)
    1: {
    1:   if (!mLastModified.IsEmpty()) {
    1:     aLastModified.Assign(mLastModified);
    1:   } else {
    1:     // If we for whatever reason failed to find the last modified time
    1:     // (or even the current time), fall back to what NS4.x returned.
    1:     aLastModified.Assign(NS_LITERAL_STRING("01/01/1970 00:00:00"));
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
15474: void
15474: nsDocument::UpdateNameTableEntry(nsIContent *aContent)
15474: {
15474:   if (!mIsRegularHTML)
15474:     return;
15474: 
15474:   nsIAtom* name = nsContentUtils::IsNamedItem(aContent);
15474:   if (!name)
15474:     return;
15474: 
15474:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(name);
15474:   if (!entry) {
15474:     // We're not tracking the elements with this name
15474:     return;
15474:   }
15474: 
15474:   entry->AddNameContent(aContent);
15474: }
15474: 
15474: void
15474: nsDocument::RemoveFromNameTable(nsIContent *aContent)
15474: {
15474:   if (!mIsRegularHTML)
15474:     return;
15474: 
15474:   nsIAtom* name = nsContentUtils::IsNamedItem(aContent);
15474:   if (!name)
15474:     return;
15474: 
15474:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(name);
15474:   if (!entry) {
15474:     // We're not tracking the elements with this name
15474:     return;
15474:   }
15474: 
15474:   entry->RemoveNameContent(aContent);
15474: }
15474: 
15474: void
15474: nsDocument::UpdateIdTableEntry(nsIContent *aContent)
15474: {
15474:   nsIAtom* id = aContent->GetID();
15474:   if (!id)
15474:     return;
15474: 
26475:   nsIdentifierMapEntry *entry = mIdentifierMap.PutEntry(id);
26475: 
26475:   if (entry) { /* True except on OOM */
15474:     entry->AddIdContent(aContent);
15474:   }
15474: }
15474: 
15474: void
15474: nsDocument::RemoveFromIdTable(nsIContent *aContent)
15474: {
15474:   nsIAtom* id = aContent->GetID();
15474:   if (!id)
15474:     return;
15474: 
15474:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(id);
26475:   if (!entry) /* Should be false unless we had OOM when adding the entry */
15474:     return;
15474: 
15474:   if (entry->RemoveIdContent(aContent)) {
15474:     mIdentifierMap.RemoveEntry(id);
15474:   }
15474: }
15474: 
15474: void
15474: nsDocument::UnregisterNamedItems(nsIContent *aContent)
15474: {
26475:   if (!aContent->IsNodeOfType(nsINode::eELEMENT)) {
26475:     // non-element nodes are not named items nor can they have children.
15474:     return;
15474:   }
15474: 
15474:   RemoveFromNameTable(aContent);
15474:   RemoveFromIdTable(aContent);
15474: 
27150:   for (nsINode::ChildIterator iter(aContent); !iter.IsDone(); iter.Next()) {
27150:     UnregisterNamedItems(iter);
27150:   }
15474: }
15474: 
15474: void
15474: nsDocument::RegisterNamedItems(nsIContent *aContent)
15474: {
26475:   if (!aContent->IsNodeOfType(nsINode::eELEMENT)) {
26475:     // non-element nodes are not named items nor can they have children.
15474:     return;
15474:   }
15474: 
15474:   UpdateNameTableEntry(aContent);
15474:   UpdateIdTableEntry(aContent);
15474: 
27150:   for (nsINode::ChildIterator iter(aContent); !iter.IsDone(); iter.Next()) {
27150:     RegisterNamedItems(iter);
27150:   }
15474: }
15474: 
15474: void
15474: nsDocument::ContentAppended(nsIDocument* aDocument,
15474:                             nsIContent* aContainer,
15474:                             PRInt32 aNewIndexInContainer)
15474: {
15474:   NS_ASSERTION(aDocument == this, "unexpected doc");
15474: 
27150:   for (nsINode::ChildIterator iter(aContainer, aNewIndexInContainer);
27150:        !iter.IsDone();
27150:        iter.Next()) {
27150:     RegisterNamedItems(iter);
27150:   }
15474: }
15474: 
15474: void
15474: nsDocument::ContentInserted(nsIDocument* aDocument,
15474:                             nsIContent* aContainer,
15474:                             nsIContent* aContent,
15474:                             PRInt32 aIndexInContainer)
15474: {
15474:   NS_ASSERTION(aDocument == this, "unexpected doc");
15474: 
15474:   NS_ABORT_IF_FALSE(aContent, "Null content!");
15474: 
15474:   RegisterNamedItems(aContent);
15474: }
15474: 
15474: void
15474: nsDocument::ContentRemoved(nsIDocument* aDocument,
15474:                            nsIContent* aContainer,
15474:                            nsIContent* aChild,
15474:                            PRInt32 aIndexInContainer)
15474: {
15474:   NS_ASSERTION(aDocument == this, "unexpected doc");
15474: 
15474:   NS_ABORT_IF_FALSE(aChild, "Null content!");
15474: 
15474:   UnregisterNamedItems(aChild);
15474: }
15474: 
15474: void
29833: nsDocument::AttributeWillChange(nsIDocument* aDocument,
29833:                                 nsIContent* aContent, PRInt32 aNameSpaceID,
29833:                                 nsIAtom* aAttribute, PRInt32 aModType)
15474: {
15474:   NS_ABORT_IF_FALSE(aContent, "Null content!");
15474:   NS_PRECONDITION(aAttribute, "Must have an attribute that's changing!");
15474: 
15474:   if (aNameSpaceID != kNameSpaceID_None)
15474:     return;
15474:   if (aAttribute == nsGkAtoms::name) {
15474:     RemoveFromNameTable(aContent);
15474:   } else if (aAttribute == aContent->GetIDAttributeName()) {
15474:     RemoveFromIdTable(aContent);
15474:   }
15474: }
15474: 
15474: void
15474: nsDocument::AttributeChanged(nsIDocument* aDocument,
15474:                              nsIContent* aContent, PRInt32 aNameSpaceID,
15474:                              nsIAtom* aAttribute, PRInt32 aModType,
15474:                              PRUint32 aStateMask)
15474: {
15474:   NS_ASSERTION(aDocument == this, "unexpected doc");
15474: 
15474:   NS_ABORT_IF_FALSE(aContent, "Null content!");
15474:   NS_PRECONDITION(aAttribute, "Must have an attribute that's changing!");
15474: 
15474:   if (aNameSpaceID != kNameSpaceID_None)
15474:     return;
15474:   if (aAttribute == nsGkAtoms::name) {
15474:     UpdateNameTableEntry(aContent);
15474:   } else if (aAttribute == aContent->GetIDAttributeName()) {
15474:     UpdateIdTableEntry(aContent);
15474:   }
15474: }
15474: 
    1: nsIPrincipal*
    1: nsDocument::GetPrincipal()
    1: {
    1:   return NodePrincipal();
    1: }
    1: 
28460: extern PRBool sDisablePrefetchHTTPSPref;
28460: 
    1: void
    1: nsDocument::SetPrincipal(nsIPrincipal *aNewPrincipal)
    1: {
28460:   if (aNewPrincipal && mAllowDNSPrefetch && sDisablePrefetchHTTPSPref) {
28460:     nsCOMPtr<nsIURI> uri;
28460:     aNewPrincipal->GetURI(getter_AddRefs(uri));
28460:     PRBool isHTTPS;
28460:     if (!uri || NS_FAILED(uri->SchemeIs("https", &isHTTPS)) ||
28460:         isHTTPS) {
28460:       mAllowDNSPrefetch = PR_FALSE;
28460:     }
28460:   }
    1:   mNodeInfoManager->SetDocumentPrincipal(aNewPrincipal);
    1: }
    1: 
    1: NS_IMETHODIMP
18430: nsDocument::GetApplicationCache(nsIApplicationCache **aApplicationCache)
18430: {
18430:   NS_IF_ADDREF(*aApplicationCache = mApplicationCache);
18430: 
18430:   return NS_OK;
18430: }
18430: 
18430: NS_IMETHODIMP
18430: nsDocument::SetApplicationCache(nsIApplicationCache *aApplicationCache)
18430: {
18430:   mApplicationCache = aApplicationCache;
18430: 
18430:   return NS_OK;
18430: }
18430: 
18430: NS_IMETHODIMP
    1: nsDocument::GetContentType(nsAString& aContentType)
    1: {
    1:   CopyUTF8toUTF16(mContentType, aContentType);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::SetContentType(const nsAString& aContentType)
    1: {
    1:   NS_ASSERTION(mContentType.IsEmpty() ||
    1:                mContentType.Equals(NS_ConvertUTF16toUTF8(aContentType)),
    1:                "Do you really want to change the content-type?");
    1: 
    1:   CopyUTF16toUTF8(aContentType, mContentType);
    1: }
    1: 
    1: /* Return true if the document is in the focused top-level window, and is an
    1:  * ancestor of the focused DOMWindow. */
    1: NS_IMETHODIMP
    1: nsDocument::HasFocus(PRBool* aResult)
    1: {
    1:   *aResult = PR_FALSE;
    1: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm)
29018:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   // Is there a focused DOMWindow?
29018:   nsCOMPtr<nsIDOMWindow> focusedWindow;
29018:   fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
29018:   if (!focusedWindow)
29018:     return NS_OK;
    1: 
    1:   // Are we an ancestor of the focused DOMWindow?
    1:   nsCOMPtr<nsIDOMDocument> domDocument;
    1:   focusedWindow->GetDocument(getter_AddRefs(domDocument));
    1:   nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
    1: 
    1:   for (nsIDocument* currentDoc = document; currentDoc;
    1:        currentDoc = currentDoc->GetParentDocument()) {
    1:     if (currentDoc == this) {
    1:       // Yes, we are an ancestor
    1:       *aResult = PR_TRUE;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetReferrer(nsAString& aReferrer)
    1: {
    1:   CopyUTF8toUTF16(mReferrer, aReferrer);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetActiveElement(nsIDOMElement **aElement)
    1: {
    1:   *aElement = nsnull;
    1: 
    1:   // Get the focused element.
29018:   nsCOMPtr<nsPIDOMWindow> window = GetWindow();
    1:   if (!window) {
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm)
29018:     return NS_ERROR_NOT_AVAILABLE;
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> focusedWindow;
29018:   nsIContent* focusedContent =
29018:     nsFocusManager::GetFocusedDescendant(window, PR_FALSE, getter_AddRefs(focusedWindow));
29018: 
29018:   // an element in this document is focused, so return it
29018:   if (focusedContent) {
29018:     // be safe and make sure the element is from this document
29018:     if (focusedContent->GetOwnerDoc() != this) {
29018:       NS_WARNING("Focused element found from another document");
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
29018:     CallQueryInterface(focusedContent, aElement);
29018:     return NS_OK;
    1:   }
    1: 
    1:   // No focused element anywhere in this document.  Try to get the BODY.
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc =
 3233:     do_QueryInterface(static_cast<nsIDocument*>(this));
    1:   if (htmlDoc) {
    1:     nsCOMPtr<nsIDOMHTMLElement> bodyElement;
    1:     htmlDoc->GetBody(getter_AddRefs(bodyElement));
    1:     if (bodyElement) {
    1:       *aElement = bodyElement;
    1:       NS_ADDREF(*aElement);
 7851:     }
 7851:     // Because of IE compatibility, return null when html document doesn't have
 7851:     // a body.
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If we couldn't get a BODY, return the root element.
    1:   return GetDocumentElement(aElement);
    1: }
    1: 
    1: NS_IMETHODIMP
 5440: nsDocument::ElementFromPoint(PRInt32 aX, PRInt32 aY, nsIDOMElement** aReturn)
 5440: {
21333:   return ElementFromPointHelper(aX, aY, PR_FALSE, PR_TRUE, aReturn);
21333: }
21333: 
21333: nsresult
21333: nsDocument::ElementFromPointHelper(PRInt32 aX, PRInt32 aY,
21333:                                    PRBool aIgnoreRootScrollFrame,
21333:                                    PRBool aFlushLayout,
21333:                                    nsIDOMElement** aReturn)
21333: {
 5440:   NS_ENSURE_ARG_POINTER(aReturn);
 5440:   *aReturn = nsnull;
 5440:   // As per the the spec, we return null if either coord is negative
31237:   if (!aIgnoreRootScrollFrame && (aX < 0 || aY < 0))
 5440:     return NS_OK;
 5440: 
 5440:   nscoord x = nsPresContext::CSSPixelsToAppUnits(aX);
 5440:   nscoord y = nsPresContext::CSSPixelsToAppUnits(aY);
 5440:   nsPoint pt(x, y);
 5440: 
 5440:   // Make sure the layout information we get is up-to-date, and
 5440:   // ensure we get a root frame (for everything but XUL)
21333:   if (aFlushLayout)
 5440:     FlushPendingNotifications(Flush_Layout);
 5440: 
 5440:   nsIPresShell *ps = GetPrimaryShell();
 5440:   NS_ENSURE_STATE(ps);
 5440:   nsIFrame *rootFrame = ps->GetRootFrame();
 5440: 
 5440:   // XUL docs, unlike HTML, have no frame tree until everything's done loading
 5440:   if (!rootFrame)
 5440:     return NS_OK; // return null to premature XUL callers as a reminder to wait
 5440: 
21333:   nsIFrame *ptFrame = nsLayoutUtils::GetFrameForPoint(rootFrame, pt, PR_TRUE,
21333:                                                       aIgnoreRootScrollFrame);
 5440:   if (!ptFrame)
 5440:     return NS_OK;
 5440: 
 5440:   nsIContent* ptContent = ptFrame->GetContent();
 5440:   NS_ENSURE_STATE(ptContent);
 5440: 
 5440:   // If the content is in a subdocument, try to get the element from |this| doc
 5440:   nsIDocument *currentDoc = ptContent->GetCurrentDoc();
 5440:   if (currentDoc && (currentDoc != this)) {
 5440:     *aReturn = CheckAncestryAndGetFrame(currentDoc).get();
 5440:     return NS_OK;
 5440:   }
 5440: 
 5440:   // If we have an anonymous element (such as an internal div from a textbox),
 5440:   // or a node that isn't an element (such as a text frame node),
 5440:   // replace it with the first non-anonymous parent node of type element.
 5440:   while (ptContent &&
26031:          (!ptContent->IsNodeOfType(nsINode::eELEMENT) ||
26031:           ptContent->IsInAnonymousSubtree())) {
16126:     // XXXldb: Faster to jump to GetBindingParent if non-null?
 5440:     ptContent = ptContent->GetParent();
 5440:   }
 5440:  
 5440:   if (ptContent)
 5440:     CallQueryInterface(ptContent, aReturn);
 5440:   return NS_OK;
 5440: }
 5440: 
 5440: NS_IMETHODIMP
    1: nsDocument::GetElementsByClassName(const nsAString& aClasses,
    1:                                    nsIDOMNodeList** aReturn)
    1: {
 6158:   return GetElementsByClassNameHelper(this, aClasses, aReturn);
    1: }
    1: 
23622: struct ClassMatchingInfo {
23622:   nsCOMArray<nsIAtom> mClasses;
23622:   nsCaseTreatment mCaseTreatment;
23622: };
    1: 
    1: // static GetElementsByClassName helpers
    1: nsresult
 6158: nsDocument::GetElementsByClassNameHelper(nsINode* aRootNode,
    1:                                          const nsAString& aClasses,
    1:                                          nsIDOMNodeList** aReturn)
    1: {
 6158:   NS_PRECONDITION(aRootNode, "Must have root node");
 6158:   
    1:   nsAttrValue attrValue;
    1:   attrValue.ParseAtomArray(aClasses);
    1:   // nsAttrValue::Equals is sensitive to order, so we'll send an array
23622:   ClassMatchingInfo* info = new ClassMatchingInfo;
23622:   NS_ENSURE_TRUE(info, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (attrValue.Type() == nsAttrValue::eAtomArray) {
23622:     info->mClasses.AppendObjects(*(attrValue.GetAtomArrayValue()));
19769:   } else if (attrValue.Type() == nsAttrValue::eAtom) {
23622:     info->mClasses.AppendObject(attrValue.GetAtomValue());
    1:   }
    1: 
    1:   nsBaseContentList* elements;
23622:   if (info->mClasses.Count() > 0) {
23622:     info->mCaseTreatment =
23622:       aRootNode->GetOwnerDoc()->GetCompatibilityMode() ==
23622:         eCompatibility_NavQuirks ?
23622:           eIgnoreCase : eCaseMatters;
23622:   
 6158:     elements = new nsContentList(aRootNode, MatchClassNames,
23622:                                  DestroyClassNameArray, info);
    1:   } else {
23622:     delete info;
23622:     info = nsnull;
    1:     elements = new nsBaseContentList();
    1:   }
    1:   if (!elements) {
23622:     delete info;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   *aReturn = elements;
    1:   NS_ADDREF(*aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsDocument::MatchClassNames(nsIContent* aContent,
    1:                             PRInt32 aNamespaceID,
    1:                             nsIAtom* aAtom, void* aData)
    1: {
    1:   // We can't match if there are no class names
    1:   const nsAttrValue* classAttr = aContent->GetClasses();
    1:   if (!classAttr) {
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   // need to match *all* of the classes
23622:   ClassMatchingInfo* info = static_cast<ClassMatchingInfo*>(aData);
23622:   PRInt32 length = info->mClasses.Count();
    1:   PRInt32 i;
    1:   for (i = 0; i < length; ++i) {
23622:     if (!classAttr->Contains(info->mClasses.ObjectAt(i),
23622:                              info->mCaseTreatment)) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1:   
    1:   return PR_TRUE;
    1: }
    1: 
    1: // static
    1: void
    1: nsDocument::DestroyClassNameArray(void* aData)
    1: {
23622:   ClassMatchingInfo* info = static_cast<ClassMatchingInfo*>(aData);
23622:   delete info;
    1: }
    1: 
32435: NS_IMETHODIMP
32435: nsDocument::ReleaseCapture()
32435: {
32435:   // only release the capture if the caller can access it. This prevents a
32435:   // page from stopping a scrollbar grab for example.
32435:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(nsIPresShell::GetCapturingContent());
32435:   if (node && nsContentUtils::CanCallerAccess(node)) {
32435:     nsIPresShell::SetCapturingContent(nsnull, 0);
32435:   }
32435:   return NS_OK;
32435: }
32435: 
    1: nsresult
    1: nsDocument::SetBaseURI(nsIURI* aURI)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
33055:   nsCOMPtr<nsIURI> oldBase = nsIDocument::GetBaseURI();
    1:   if (aURI) {
    1:     rv = nsContentUtils::GetSecurityManager()->
    1:       CheckLoadURIWithPrincipal(NodePrincipal(), aURI,
    1:                                 nsIScriptSecurityManager::STANDARD);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       mDocumentBaseURI = NS_TryToMakeImmutable(aURI);
    1:     }
    1:   } else {
    1:     mDocumentBaseURI = nsnull;
    1:   }
    1: 
33055:   nsIURI* newBase = nsIDocument::GetBaseURI();
33055:   PRBool equalBases = PR_FALSE;
33055:   if (oldBase && newBase) {
33055:     oldBase->Equals(newBase, &equalBases);
33055:   }
33055:   else {
33055:     equalBases = !oldBase && !newBase;
33055:   }
33055: 
33055:   // If the document's base URI has changed, we need to re-resolve all the
33055:   // cached link hrefs relative to the new base.
33055:   if (!equalBases) {
33055:     RefreshLinkHrefs();
33055:   }
33055: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsDocument::GetBaseTarget(nsAString &aBaseTarget) const
    1: {
    1:   aBaseTarget.Assign(mBaseTarget);
    1: }
    1: 
    1: void
    1: nsDocument::SetBaseTarget(const nsAString &aBaseTarget)
    1: {
    1:   mBaseTarget.Assign(aBaseTarget);
    1: }
    1: 
    1: void
    1: nsDocument::SetDocumentCharacterSet(const nsACString& aCharSetID)
    1: {
    1:   if (!mCharacterSet.Equals(aCharSetID)) {
    1:     mCharacterSet = aCharSetID;
    1: 
    1: #ifdef DEBUG
    1:     nsCOMPtr<nsICharsetAlias> calias(do_GetService(NS_CHARSETALIAS_CONTRACTID));
    1:     if (calias) {
    1:       nsCAutoString canonicalName;
    1:       calias->GetPreferred(aCharSetID, canonicalName);
    1:       NS_ASSERTION(canonicalName.Equals(aCharSetID),
    1:                    "charset name must be canonical");
    1:     }
    1: #endif
    1: 
26413:     PRInt32 n = mCharSetObservers.Length();
    1: 
    1:     for (PRInt32 i = 0; i < n; i++) {
26413:       nsIObserver* observer = mCharSetObservers.ElementAt(i);
 3233: 
 3233:       observer->Observe(static_cast<nsIDocument *>(this), "charset",
    1:                         NS_ConvertASCIItoUTF16(aCharSetID).get());
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsDocument::AddCharSetObserver(nsIObserver* aObserver)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aObserver);
    1: 
    1:   NS_ENSURE_TRUE(mCharSetObservers.AppendElement(aObserver), NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::RemoveCharSetObserver(nsIObserver* aObserver)
    1: {
    1:   mCharSetObservers.RemoveElement(aObserver);
    1: }
    1: 
    1: void
    1: nsDocument::GetHeaderData(nsIAtom* aHeaderField, nsAString& aData) const
    1: {
    1:   aData.Truncate();
    1:   const nsDocHeaderData* data = mHeaderData;
    1:   while (data) {
    1:     if (data->mField == aHeaderField) {
    1:       aData = data->mData;
    1: 
    1:       break;
    1:     }
    1:     data = data->mNext;
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::SetHeaderData(nsIAtom* aHeaderField, const nsAString& aData)
    1: {
    1:   if (!aHeaderField) {
    1:     NS_ERROR("null headerField");
    1:     return;
    1:   }
    1: 
    1:   if (!mHeaderData) {
    1:     if (!aData.IsEmpty()) { // don't bother storing empty string
    1:       mHeaderData = new nsDocHeaderData(aHeaderField, aData);
    1:     }
    1:   }
    1:   else {
    1:     nsDocHeaderData* data = mHeaderData;
    1:     nsDocHeaderData** lastPtr = &mHeaderData;
    1:     PRBool found = PR_FALSE;
    1:     do {  // look for existing and replace
    1:       if (data->mField == aHeaderField) {
    1:         if (!aData.IsEmpty()) {
    1:           data->mData.Assign(aData);
    1:         }
    1:         else {  // don't store empty string
    1:           *lastPtr = data->mNext;
    1:           data->mNext = nsnull;
    1:           delete data;
    1:         }
    1:         found = PR_TRUE;
    1: 
    1:         break;
    1:       }
    1:       lastPtr = &(data->mNext);
    1:       data = *lastPtr;
    1:     } while (data);
    1: 
    1:     if (!aData.IsEmpty() && !found) {
    1:       // didn't find, append
    1:       *lastPtr = new nsDocHeaderData(aHeaderField, aData);
    1:     }
    1:   }
    1: 
    1:   if (aHeaderField == nsGkAtoms::headerContentLanguage) {
    1:     CopyUTF16toUTF8(aData, mContentLanguage);
    1:   }
    1: 
    1:   // Set the default script-type on the root element.
    1:   if (aHeaderField == nsGkAtoms::headerContentScriptType) {
    1:     nsIContent *root = GetRootContent();
    1:     if (root) {
    1:       // Get the script-type ID for this value.
    1:       nsresult rv;
    1:       nsCOMPtr<nsIScriptRuntime> runtime;
    1:       rv = NS_GetScriptRuntime(aData, getter_AddRefs(runtime));
    1:       if (NS_FAILED(rv) || runtime == nsnull) {
    1:         NS_WARNING("The script-type is unknown");
    1:       } else {
    1:         root->SetScriptTypeID(runtime->GetScriptTypeID());
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aHeaderField == nsGkAtoms::headerDefaultStyle) {
    1:     // Only mess with our stylesheets if we don't have a lastStyleSheetSet, per
    1:     // spec.
    1:     if (DOMStringIsNull(mLastStyleSheetSet)) {
    1:       // Calling EnableStyleSheetsForSetInternal, not SetSelectedStyleSheetSet,
    1:       // per spec.  The idea here is that we're changing our preferred set and
    1:       // that shouldn't change the value of lastStyleSheetSet.  Also, we're
    1:       // using the Internal version so we can update the CSSLoader and not have
    1:       // to worry about null strings.
    1:       EnableStyleSheetsForSetInternal(aData, PR_TRUE);
    1:     }
    1:   }
    1: 
    1:   if (aHeaderField == nsGkAtoms::refresh) {
    1:     // We get into this code before we have a script global yet, so get to
    1:     // our container via mDocumentContainer.
    1:     nsCOMPtr<nsIRefreshURI> refresher = do_QueryReferent(mDocumentContainer);
    1:     if (refresher) {
    1:       // Note: using mDocumentURI instead of mBaseURI here, for consistency
    1:       // (used to just use the current URI of our webnavigation, but that
    1:       // should really be the same thing).  Note that this code can run
    1:       // before the current URI of the webnavigation has been updated, so we
    1:       // can't assert equality here.
    1:       refresher->SetupRefreshURIFromHeader(mDocumentURI,
 6396:                                            NS_ConvertUTF16toUTF8(aData));
    1:     }
    1:   }
28460: 
28460:   if (aHeaderField == nsGkAtoms::headerDNSPrefetchControl &&
28460:       mAllowDNSPrefetch) {
28460:     // Chromium treats any value other than 'on' (case insensitive) as 'off'.
28460:     mAllowDNSPrefetch = aData.IsEmpty() || aData.LowerCaseEqualsLiteral("on");
28460:   }
    1: }
    1: 
    1: PRBool
    1: nsDocument::TryChannelCharset(nsIChannel *aChannel,
    1:                               PRInt32& aCharsetSource,
    1:                               nsACString& aCharset)
    1: {
    1:   if(kCharsetFromChannel <= aCharsetSource) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (aChannel) {
    1:     nsCAutoString charsetVal;
    1:     nsresult rv = aChannel->GetContentCharset(charsetVal);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       nsCOMPtr<nsICharsetAlias> calias(do_GetService(NS_CHARSETALIAS_CONTRACTID));
    1:       if (calias) {
    1:         nsCAutoString preferred;
    1:         rv = calias->GetPreferred(charsetVal,
    1:                                   preferred);
    1:         if(NS_SUCCEEDED(rv)) {
    1:           aCharset = preferred;
    1:           aCharsetSource = kCharsetFromChannel;
    1:           return PR_TRUE;
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsDocument::CreateShell(nsPresContext* aContext, nsIViewManager* aViewManager,
    1:                         nsStyleSet* aStyleSet,
    1:                         nsIPresShell** aInstancePtrResult)
    1: {
    1:   // Don't add anything here.  Add it to |doCreateShell| instead.
    1:   // This exists so that subclasses can pass other values for the 4th
    1:   // parameter some of the time.
    1:   return doCreateShell(aContext, aViewManager, aStyleSet,
    1:                        eCompatibility_FullStandards, aInstancePtrResult);
    1: }
    1: 
    1: nsresult
    1: nsDocument::doCreateShell(nsPresContext* aContext,
    1:                           nsIViewManager* aViewManager, nsStyleSet* aStyleSet,
    1:                           nsCompatibility aCompatMode,
    1:                           nsIPresShell** aInstancePtrResult)
    1: {
    1:   *aInstancePtrResult = nsnull;
    1: 
    1:   NS_ENSURE_FALSE(mShellsAreHidden, NS_ERROR_FAILURE);
    1: 
    1:   FillStyleSet(aStyleSet);
    1:   
    1:   nsCOMPtr<nsIPresShell> shell;
    1:   nsresult rv = NS_NewPresShell(getter_AddRefs(shell));
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   rv = shell->Init(this, aContext, aViewManager, aStyleSet, aCompatMode);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Note: we don't hold a ref to the shell (it holds a ref to us)
 9536:   NS_ENSURE_TRUE(mPresShells.AppendElementUnlessExists(shell),
 9031:                  NS_ERROR_OUT_OF_MEMORY);
    1:   shell.swap(*aInstancePtrResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsDocument::DeleteShell(nsIPresShell* aShell)
    1: {
 9536:   return mPresShells.RemoveElement(aShell);
 1722: }
 1722: 
    1: 
  981: nsIPresShell *
  981: nsDocument::GetPrimaryShell() const
  981: {
 9536:   return mShellsAreHidden ? nsnull : mPresShells.SafeElementAt(0, nsnull);
    1: }
    1: 
20261: static void
    1: SubDocClearEntry(PLDHashTable *table, PLDHashEntryHdr *entry)
    1: {
 3233:   SubDocMapEntry *e = static_cast<SubDocMapEntry *>(entry);
    1: 
    1:   NS_RELEASE(e->mKey);
 8462:   if (e->mSubDocument) {
 8462:     e->mSubDocument->SetParentDocument(nsnull);
 8462:     NS_RELEASE(e->mSubDocument);
 8462:   }
    1: }
    1: 
20261: static PRBool
    1: SubDocInitEntry(PLDHashTable *table, PLDHashEntryHdr *entry, const void *key)
    1: {
    1:   SubDocMapEntry *e =
 3233:     const_cast<SubDocMapEntry *>
 3233:               (static_cast<const SubDocMapEntry *>(entry));
 3233: 
 3233:   e->mKey = const_cast<nsIContent *>
 3233:                       (static_cast<const nsIContent *>(key));
    1:   NS_ADDREF(e->mKey);
    1: 
    1:   e->mSubDocument = nsnull;
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsDocument::SetSubDocumentFor(nsIContent *aContent, nsIDocument* aSubDoc)
    1: {
    1:   NS_ENSURE_TRUE(aContent, NS_ERROR_UNEXPECTED);
    1: 
    1:   if (!aSubDoc) {
    1:     // aSubDoc is nsnull, remove the mapping
    1: 
    1:     if (mSubDocuments) {
    1:       SubDocMapEntry *entry =
 3233:         static_cast<SubDocMapEntry*>
 3233:                    (PL_DHashTableOperate(mSubDocuments, aContent,
    1:                                             PL_DHASH_LOOKUP));
    1: 
    1:       if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:         PL_DHashTableRawRemove(mSubDocuments, entry);
    1:       }
    1:     }
    1:   } else {
    1:     if (!mSubDocuments) {
    1:       // Create a new hashtable
    1: 
    1:       static PLDHashTableOps hash_table_ops =
    1:       {
    1:         PL_DHashAllocTable,
    1:         PL_DHashFreeTable,
    1:         PL_DHashVoidPtrKeyStub,
    1:         PL_DHashMatchEntryStub,
    1:         PL_DHashMoveEntryStub,
    1:         SubDocClearEntry,
    1:         PL_DHashFinalizeStub,
    1:         SubDocInitEntry
    1:       };
    1: 
    1:       mSubDocuments = PL_NewDHashTable(&hash_table_ops, nsnull,
    1:                                        sizeof(SubDocMapEntry), 16);
    1:       if (!mSubDocuments) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:     }
    1: 
    1:     // Add a mapping to the hash table
    1:     SubDocMapEntry *entry =
 3233:       static_cast<SubDocMapEntry*>
 3233:                  (PL_DHashTableOperate(mSubDocuments, aContent,
    1:                                           PL_DHASH_ADD));
    1: 
    1:     if (!entry) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (entry->mSubDocument) {
    1:       entry->mSubDocument->SetParentDocument(nsnull);
    1: 
    1:       // Release the old sub document
    1:       NS_RELEASE(entry->mSubDocument);
    1:     }
    1: 
    1:     entry->mSubDocument = aSubDoc;
    1:     NS_ADDREF(entry->mSubDocument);
    1: 
    1:     aSubDoc->SetParentDocument(this);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIDocument*
    1: nsDocument::GetSubDocumentFor(nsIContent *aContent) const
    1: {
    1:   if (mSubDocuments) {
    1:     SubDocMapEntry *entry =
 3233:       static_cast<SubDocMapEntry*>
 3233:                  (PL_DHashTableOperate(mSubDocuments, aContent,
    1:                                           PL_DHASH_LOOKUP));
    1: 
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:       return entry->mSubDocument;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
20261: static PLDHashOperator
    1: FindContentEnumerator(PLDHashTable *table, PLDHashEntryHdr *hdr,
    1:                       PRUint32 number, void *arg)
    1: {
 3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
 3233:   FindContentData *data = static_cast<FindContentData*>(arg);
    1: 
    1:   if (entry->mSubDocument == data->mSubDocument) {
    1:     data->mResult = entry->mKey;
    1: 
    1:     return PL_DHASH_STOP;
    1:   }
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: nsIContent*
    1: nsDocument::FindContentForSubDocument(nsIDocument *aDocument) const
    1: {
    1:   NS_ENSURE_TRUE(aDocument, nsnull);
    1: 
    1:   if (!mSubDocuments) {
    1:     return nsnull;
    1:   }
    1: 
    1:   FindContentData data(aDocument);
    1:   PL_DHashTableEnumerate(mSubDocuments, FindContentEnumerator, &data);
    1: 
    1:   return data.mResult;
    1: }
    1: 
    1: PRBool
    1: nsDocument::IsNodeOfType(PRUint32 aFlags) const
    1: {
    1:     return !(aFlags & ~eDOCUMENT);
    1: }
    1: 
    1: nsIContent*
 8938: nsDocument::GetRootContentInternal() const
 8938: {
 8938:   // Loop backwards because any non-elements, such as doctypes and PIs
 8938:   // are likely to appear before the root element.
 8938:   PRUint32 i;
 8938:   for (i = mChildren.ChildCount(); i > 0; --i) {
 8938:     nsIContent* child = mChildren.ChildAt(i - 1);
 8938:     if (child->IsNodeOfType(nsINode::eELEMENT)) {
 8938:       const_cast<nsDocument*>(this)->mCachedRootContent = child;
 8938:       return child;
 8938:     }
 8938:   }
 8938:   
 8938:   const_cast<nsDocument*>(this)->mCachedRootContent = nsnull;
 8938:   return nsnull;
 8938: }
 8938: 
 8938: nsIContent *
    1: nsDocument::GetChildAt(PRUint32 aIndex) const
    1: {
    1:   return mChildren.GetSafeChildAt(aIndex);
    1: }
    1: 
    1: PRInt32
    1: nsDocument::IndexOf(nsINode* aPossibleChild) const
    1: {
    1:   return mChildren.IndexOfChild(aPossibleChild);
    1: }
    1: 
    1: PRUint32
    1: nsDocument::GetChildCount() const
    1: {
    1:   return mChildren.ChildCount();
    1: }
    1: 
15810: nsIContent * const *
22251: nsDocument::GetChildArray(PRUint32* aChildCount) const
22251: {
22251:   return mChildren.GetChildArray(aChildCount);
15810: }
15810:   
15810: 
    1: nsresult
    1: nsDocument::InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                           PRBool aNotify)
    1: {
 8938:   if (aKid->IsNodeOfType(nsINode::eELEMENT) &&
 8938:       GetRootContent()) {
    1:     NS_ERROR("Inserting element child when we already have one");
    1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:   }
    1: 
 8938:   return nsGenericElement::doInsertChildAt(aKid, aIndex, aNotify,
    1:                                            nsnull, this, mChildren);
    1: }
    1: 
    1: nsresult
    1: nsDocument::AppendChildTo(nsIContent* aKid, PRBool aNotify)
    1: {
    1:   // Make sure to _not_ call the subclass InsertChildAt here.  If
    1:   // subclasses wanted to hook into this stuff, they would have
    1:   // overridden AppendChildTo.
    1:   // XXXbz maybe this should just be a non-virtual method on nsINode?
    1:   // Feels that way to me...
    1:   return nsDocument::InsertChildAt(aKid, GetChildCount(), aNotify);
    1: }
    1: 
    1: nsresult
29805: nsDocument::RemoveChildAt(PRUint32 aIndex, PRBool aNotify, PRBool aMutationEvent)
29805: {
29805:   NS_ASSERTION(aMutationEvent, "Someone tried to inhibit mutations on document child removal.");
    1:   nsCOMPtr<nsIContent> oldKid = GetChildAt(aIndex);
 8938:   if (!oldKid) {
 8938:     return NS_OK;
 8938:   }
 8938: 
 8938:   if (oldKid->IsNodeOfType(nsINode::eELEMENT)) {
 8938:     // Destroy the link map up front before we mess with the child list.
    1:     DestroyLinkMap();
 8938:   }
 8938: 
 8938:   nsresult rv = nsGenericElement::doRemoveChildAt(aIndex, aNotify, oldKid,
29805:                                                   nsnull, this, mChildren, 
29805:                                                   aMutationEvent);
 8938:   mCachedRootContent = nsnull;
    1:   return rv;
    1: }
    1: 
    1: PRInt32
    1: nsDocument::GetNumberOfStyleSheets() const
    1: {
    1:   return mStyleSheets.Count();
    1: }
    1: 
    1: nsIStyleSheet*
    1: nsDocument::GetStyleSheetAt(PRInt32 aIndex) const
    1: {
    1:   NS_ENSURE_TRUE(0 <= aIndex && aIndex < mStyleSheets.Count(), nsnull);
    1:   return mStyleSheets[aIndex];
    1: }
    1: 
    1: PRInt32
    1: nsDocument::GetIndexOfStyleSheet(nsIStyleSheet* aSheet) const
    1: {
    1:   return mStyleSheets.IndexOf(aSheet);
    1: }
    1: 
    1: void
    1: nsDocument::AddStyleSheetToStyleSets(nsIStyleSheet* aSheet)
    1: {
 1722:   nsPresShellIterator iter(this);
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell())) {
 1722:     shell->StyleSet()->AddDocStyleSheet(aSheet, this);
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::AddStyleSheet(nsIStyleSheet* aSheet)
    1: {
    1:   NS_PRECONDITION(aSheet, "null arg");
    1:   mStyleSheets.AppendObject(aSheet);
    1:   aSheet->SetOwningDocument(this);
    1: 
    1:   PRBool applicable;
    1:   aSheet->GetApplicable(applicable);
    1: 
    1:   if (applicable) {
    1:     AddStyleSheetToStyleSets(aSheet);
    1:   }
    1: 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, PR_TRUE));
    1: }
    1: 
    1: void
    1: nsDocument::RemoveStyleSheetFromStyleSets(nsIStyleSheet* aSheet)
    1: {
 1722:   nsPresShellIterator iter(this);
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell())) {
 1722:     shell->StyleSet()->RemoveStyleSheet(nsStyleSet::eDocSheet, aSheet);
 1722:   }
    1: }
    1: 
    1: void
    1: nsDocument::RemoveStyleSheet(nsIStyleSheet* aSheet)
    1: {
    1:   NS_PRECONDITION(aSheet, "null arg");
    1:   nsCOMPtr<nsIStyleSheet> sheet = aSheet; // hold ref so it won't die too soon
    1: 
    1:   if (!mStyleSheets.RemoveObject(aSheet)) {
    1:     NS_NOTREACHED("stylesheet not found");
    1:     return;
    1:   }
    1: 
    1:   if (!mIsGoingAway) {
    1:     PRBool applicable = PR_TRUE;
    1:     aSheet->GetApplicable(applicable);
    1:     if (applicable) {
    1:       RemoveStyleSheetFromStyleSets(aSheet);
    1:     }
    1: 
    1:     NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetRemoved, (this, aSheet, PR_TRUE));
    1:   }
    1: 
    1:   aSheet->SetOwningDocument(nsnull);
    1: }
    1: 
    1: void
    1: nsDocument::UpdateStyleSheets(nsCOMArray<nsIStyleSheet>& aOldSheets,
    1:                               nsCOMArray<nsIStyleSheet>& aNewSheets)
    1: {
    1:   BeginUpdate(UPDATE_STYLE);
    1: 
    1:   // XXX Need to set the sheet on the ownernode, if any
    1:   NS_PRECONDITION(aOldSheets.Count() == aNewSheets.Count(),
    1:                   "The lists must be the same length!");
    1:   PRInt32 count = aOldSheets.Count();
    1: 
    1:   nsCOMPtr<nsIStyleSheet> oldSheet;
    1:   PRInt32 i;
    1:   for (i = 0; i < count; ++i) {
    1:     oldSheet = aOldSheets[i];
    1: 
    1:     // First remove the old sheet.
    1:     NS_ASSERTION(oldSheet, "None of the old sheets should be null");
    1:     PRInt32 oldIndex = mStyleSheets.IndexOf(oldSheet);
    1:     RemoveStyleSheet(oldSheet);  // This does the right notifications
    1: 
    1:     // Now put the new one in its place.  If it's null, just ignore it.
    1:     nsIStyleSheet* newSheet = aNewSheets[i];
    1:     if (newSheet) {
    1:       mStyleSheets.InsertObjectAt(newSheet, oldIndex);
    1:       newSheet->SetOwningDocument(this);
    1:       PRBool applicable = PR_TRUE;
    1:       newSheet->GetApplicable(applicable);
    1:       if (applicable) {
    1:         AddStyleSheetToStyleSets(newSheet);
    1:       }
    1: 
    1:       NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, newSheet, PR_TRUE));
    1:     }
    1:   }
    1: 
    1:   EndUpdate(UPDATE_STYLE);
    1: }
    1: 
    1: void
    1: nsDocument::InsertStyleSheetAt(nsIStyleSheet* aSheet, PRInt32 aIndex)
    1: {
    1:   NS_PRECONDITION(aSheet, "null ptr");
    1:   mStyleSheets.InsertObjectAt(aSheet, aIndex);
    1: 
    1:   aSheet->SetOwningDocument(this);
    1: 
    1:   PRBool applicable;
    1:   aSheet->GetApplicable(applicable);
    1: 
    1:   if (applicable) {
    1:     AddStyleSheetToStyleSets(aSheet);
    1:   }
    1: 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, PR_TRUE));
    1: }
    1: 
    1: 
    1: void
    1: nsDocument::SetStyleSheetApplicableState(nsIStyleSheet* aSheet,
    1:                                          PRBool aApplicable)
    1: {
    1:   NS_PRECONDITION(aSheet, "null arg");
    1: 
    1:   // If we're actually in the document style sheet list
    1:   if (-1 != mStyleSheets.IndexOf(aSheet)) {
    1:     if (aApplicable) {
    1:       AddStyleSheetToStyleSets(aSheet);
    1:     } else {
    1:       RemoveStyleSheetFromStyleSets(aSheet);
    1:     }
    1:   }
    1: 
    1:   // We have to always notify, since this will be called for sheets
    1:   // that are children of sheets in our style set, as well as some
    1:   // sheets for nsHTMLEditor.
    1: 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetApplicableStateChanged,
    1:                                (this, aSheet, aApplicable));
    1: }
    1: 
    1: // These three functions are a lot like the implementation of the
    1: // corresponding API for regular stylesheets.
    1: 
    1: PRInt32
    1: nsDocument::GetNumberOfCatalogStyleSheets() const
    1: {
    1:   return mCatalogSheets.Count();
    1: }
    1: 
    1: nsIStyleSheet*
    1: nsDocument::GetCatalogStyleSheetAt(PRInt32 aIndex) const
    1: {
    1:   NS_ENSURE_TRUE(0 <= aIndex && aIndex < mCatalogSheets.Count(), nsnull);
    1:   return mCatalogSheets[aIndex];
    1: }
    1: 
    1: void
    1: nsDocument::AddCatalogStyleSheet(nsIStyleSheet* aSheet)
    1: {
    1:   mCatalogSheets.AppendObject(aSheet);
    1:   aSheet->SetOwningDocument(this);
    1: 
    1:   PRBool applicable;
    1:   aSheet->GetApplicable(applicable);
    1:                                                                                 
    1:   if (applicable) {
    1:     // This is like |AddStyleSheetToStyleSets|, but for an agent sheet.
 1722:     nsPresShellIterator iter(this);
 1722:     nsCOMPtr<nsIPresShell> shell;
 1722:     while ((shell = iter.GetNextShell())) {
 1722:       shell->StyleSet()->AppendStyleSheet(nsStyleSet::eAgentSheet, aSheet);
 1722:     }
    1:   }
    1:                                                                                 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, PR_FALSE));
    1: }
    1: 
    1: void
    1: nsDocument::EnsureCatalogStyleSheet(const char *aStyleSheetURI)
    1: {
    1:   nsICSSLoader* cssLoader = CSSLoader();
    1:   PRBool enabled;
    1:   if (NS_SUCCEEDED(cssLoader->GetEnabled(&enabled)) && enabled) {
    1:     PRInt32 sheetCount = GetNumberOfCatalogStyleSheets();
    1:     for (PRInt32 i = 0; i < sheetCount; i++) {
    1:       nsIStyleSheet* sheet = GetCatalogStyleSheetAt(i);
    1:       NS_ASSERTION(sheet, "unexpected null stylesheet in the document");
    1:       if (sheet) {
    1:         nsCOMPtr<nsIURI> uri;
    1:         sheet->GetSheetURI(getter_AddRefs(uri));
    1:         nsCAutoString uriStr;
    1:         uri->GetSpec(uriStr);
    1:         if (uriStr.Equals(aStyleSheetURI))
    1:           return;
    1:       }
    1:     }
    1: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     NS_NewURI(getter_AddRefs(uri), aStyleSheetURI);
    1:     if (uri) {
    1:       nsCOMPtr<nsICSSStyleSheet> sheet;
26242:       cssLoader->LoadSheetSync(uri, PR_TRUE, PR_TRUE, getter_AddRefs(sheet));
    1:       if (sheet) {
    1:         BeginUpdate(UPDATE_STYLE);
    1:         AddCatalogStyleSheet(sheet);
    1:         EndUpdate(UPDATE_STYLE);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsIScriptGlobalObject*
    1: nsDocument::GetScriptGlobalObject() const
    1: {
    1:    // If we're going away, we've already released the reference to our
    1:    // ScriptGlobalObject.  We can, however, try to obtain it for the
    1:    // caller through our docshell.
    1: 
14469:    // We actually need to start returning the docshell's script global
14469:    // object as soon as nsDocumentViewer::Close has called
14469:    // RemovedFromDocShell on us.
14469:    if (mRemovedFromDocShell) {
    1:      nsCOMPtr<nsIInterfaceRequestor> requestor =
    1:        do_QueryReferent(mDocumentContainer);
    1:      if (requestor) {
    1:        nsCOMPtr<nsIScriptGlobalObject> globalObject = do_GetInterface(requestor);
    1:        return globalObject;
    1:      }
    1:    }
    1: 
    1:    return mScriptGlobalObject;
    1: }
    1: 
    1: nsIScriptGlobalObject*
    1: nsDocument::GetScopeObject()
    1: {
    1:   nsCOMPtr<nsIScriptGlobalObject> scope(do_QueryReferent(mScopeObject));
    1:   return scope;
    1: }
    1: 
34207: static void
34207: NotifyActivityChanged(nsIContent *aContent, void *aUnused)
34207: {
34207: #ifdef MOZ_MEDIA
34207:   nsCOMPtr<nsIDOMHTMLMediaElement> domMediaElem(do_QueryInterface(aContent));
34207:   if (domMediaElem) {
34207:     nsHTMLMediaElement* mediaElem = static_cast<nsHTMLMediaElement*>(aContent);
34207:     mediaElem->NotifyOwnerDocumentActivityChanged();
34207:   }
34207: #endif
34207: }
34207: 
34207: void
34207: nsIDocument::SetContainer(nsISupports* aContainer)
34207: {
34207:   mDocumentContainer = do_GetWeakReference(aContainer);
34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull);
34207: }
34207: 
    1: void
    1: nsDocument::SetScriptGlobalObject(nsIScriptGlobalObject *aScriptGlobalObject)
    1: {
    1: #ifdef DEBUG
    1:   {
    1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aScriptGlobalObject));
    1: 
    1:     NS_ASSERTION(!win || win->IsInnerWindow(),
    1:                  "Script global object must be an inner window!");
    1:   }
    1: #endif
    1: 
    1:   if (mScriptGlobalObject && !aScriptGlobalObject) {
    1:     // We're detaching from the window.  We need to grab a pointer to
    1:     // our layout history state now.
    1:     mLayoutHistoryState = GetLayoutHistoryState();
    1: 
    1:     // Also make sure to remove our onload blocker now if we haven't done it yet
    1:     if (mOnloadBlockCount != 0) {
    1:       nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1:       if (loadGroup) {
    1:         loadGroup->RemoveRequest(mOnloadBlocker, nsnull, NS_OK);
    1:       }
    1:     }
    1:   }
    1: 
    1:   mScriptGlobalObject = aScriptGlobalObject;
    1: 
    1:   if (aScriptGlobalObject) {
18343:     mScriptObject = nsnull;
 6475:     mHasHadScriptHandlingObject = PR_TRUE;
    1:     // Go back to using the docshell for the layout history state
    1:     mLayoutHistoryState = nsnull;
    1:     mScopeObject = do_GetWeakReference(aScriptGlobalObject);
28460: 
29979: #ifdef DEBUG
31428:     if (!mWillReparent) {
29979:       // We really shouldn't have a wrapper here but if we do we need to make sure
29979:       // it has the correct parent.
30001:       JSObject *obj = GetWrapper();
29420:       if (obj) {
29420:         JSObject *newScope = aScriptGlobalObject->GetGlobalJSObject();
29420:         nsIScriptContext *scx = aScriptGlobalObject->GetContext();
29420:         JSContext *cx = scx ? (JSContext *)scx->GetNativeContext() : nsnull;
29420:         if (!cx) {
29420:           nsContentUtils::ThreadJSContextStack()->Peek(&cx);
29420:           if (!cx) {
29420:             nsContentUtils::ThreadJSContextStack()->GetSafeJSContext(&cx);
29420:             NS_ASSERTION(cx, "Uhoh, no context, this is bad!");
29420:           }
29420:         }
29420:         if (cx) {
29979:           NS_ASSERTION(JS_GetGlobalForObject(cx, obj) == newScope,
29979:                        "Wrong scope, this is really bad!");
29979:         }
29979:       }
31428:     }
29979: #endif
29420: 
28460:     if (mAllowDNSPrefetch) {
28460:       nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
28460:       if (docShell) {
28460: #ifdef DEBUG
28460:         nsCOMPtr<nsIWebNavigation> webNav =
28460:           do_GetInterface(aScriptGlobalObject);
28460:         NS_ASSERTION(SameCOMIdentity(webNav, docShell),
28460:                      "Unexpected container or script global?");
28460: #endif
28460:         PRBool allowDNSPrefetch;
28460:         docShell->GetAllowDNSPrefetch(&allowDNSPrefetch);
28460:         mAllowDNSPrefetch = allowDNSPrefetch;
28460:       }
28460:     }
    1:   }
 9596: 
 9596:   // Remember the pointer to our window (or lack there of), to avoid
 9596:   // having to QI every time it's asked for.
 9596:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(mScriptGlobalObject);
 9596:   mWindow = window;
    1: }
    1: 
 6475: nsIScriptGlobalObject*
 6475: nsDocument::GetScriptHandlingObject(PRBool& aHasHadScriptHandlingObject) const
 6475: {
 6475:   aHasHadScriptHandlingObject = mHasHadScriptHandlingObject;
 6475:   if (mScriptGlobalObject) {
 6475:     return mScriptGlobalObject;
 6475:   }
 6475: 
 6475:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
 6475:     do_QueryReferent(mScriptObject);
 8094:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(scriptHandlingObject);
 8094:   if (win) {
 8947:     NS_ASSERTION(win->IsInnerWindow(), "Should have inner window here!");
 8094:     nsPIDOMWindow* outer = win->GetOuterWindow();
 8094:     if (!outer || outer->GetCurrentInnerWindow() != win) {
 8094:       NS_WARNING("Wrong inner/outer window combination!");
 8094:       return nsnull;
 8094:     }
 8094:   }
 6475:   return scriptHandlingObject;
 6475: }
 6475: void
 6475: nsDocument::SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject)
 6475: {
 6475:   NS_ASSERTION(!mScriptGlobalObject ||
 6475:                mScriptGlobalObject == aScriptObject,
 6475:                "Wrong script object!");
 8947:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aScriptObject);
 8947:   NS_ASSERTION(!win || win->IsInnerWindow(), "Should have inner window here!");
15633:   mScopeObject = mScriptObject = do_GetWeakReference(aScriptObject);
 6475:   if (aScriptObject) {
 6475:     mHasHadScriptHandlingObject = PR_TRUE;
 6475:   }
 6475: }
 6475: 
    1: nsPIDOMWindow *
    1: nsDocument::GetWindow()
    1: {
 9596:   if (mWindow) {
 9596:     return mWindow->GetOuterWindow();
 9596:   }
 9596: 
    1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(GetScriptGlobalObject()));
    1: 
    1:   if (!win) {
    1:     return nsnull;
    1:   }
    1: 
    1:   return win->GetOuterWindow();
    1: }
    1: 
    1: nsPIDOMWindow *
    1: nsDocument::GetInnerWindow()
    1: {
22210:   if (!mRemovedFromDocShell) {
22210:     return mWindow;
22210:   }
22210: 
    1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(GetScriptGlobalObject()));
    1: 
    1:   return win;
    1: }
    1: 
    1: nsScriptLoader*
 2007: nsDocument::ScriptLoader()
 2007: {
    1:   return mScriptLoader;
    1: }
    1: 
    1: // Note: We don't hold a reference to the document observer; we assume
    1: // that it has a live reference to the document.
    1: void
    1: nsDocument::AddObserver(nsIDocumentObserver* aObserver)
    1: {
    1:   // The array makes sure the observer isn't already in the list
 9536:   mObservers.AppendElementUnlessExists(aObserver);
    1:   AddMutationObserver(aObserver);
    1: }
    1: 
    1: PRBool
    1: nsDocument::RemoveObserver(nsIDocumentObserver* aObserver)
    1: {
    1:   // If we're in the process of destroying the document (and we're
    1:   // informing the observers of the destruction), don't remove the
    1:   // observers from the list. This is not a big deal, since we
    1:   // don't hold a live reference to the observers.
    1:   if (!mInDestructor) {
    1:     RemoveMutationObserver(aObserver);
 9536:     return mObservers.RemoveElement(aObserver);
    1:   }
    1: 
    1:   return mObservers.Contains(aObserver);
    1: }
    1: 
    1: void
24482: nsDocument::MaybeEndOutermostXBLUpdate()
24482: {
24482:   // Only call BindingManager()->EndOutermostUpdate() when
24482:   // we're not in an update and it is safe to run scripts.
24482:   if (mUpdateNestLevel == 0 && mInXBLUpdate) {
24482:     if (nsContentUtils::IsSafeToRunScript()) {
24482:       mInXBLUpdate = PR_FALSE;
24482:       BindingManager()->EndOutermostUpdate();
24482:     } else if (!mInDestructor) {
24482:       nsContentUtils::AddScriptRunner(
24482:         NS_NEW_RUNNABLE_METHOD(nsDocument, this, MaybeEndOutermostXBLUpdate));
24482:     }
24482:   }
24482: }
24482: 
24482: void
    1: nsDocument::BeginUpdate(nsUpdateType aUpdateType)
    1: {
24482:   if (mUpdateNestLevel == 0 && !mInXBLUpdate) {
24482:     mInXBLUpdate = PR_TRUE;
13669:     BindingManager()->BeginOutermostUpdate();
 2025:   }
 2025:   
    1:   ++mUpdateNestLevel;
13098:   if (aUpdateType == UPDATE_CONTENT_MODEL) {
14319:     nsContentUtils::AddRemovableScriptBlocker();
14319:   }
14319:   else {
13098:     nsContentUtils::AddScriptBlocker();
    1:   }
26217:   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginUpdate, (this, aUpdateType));
14319: }
    1: 
    1: void
    1: nsDocument::EndUpdate(nsUpdateType aUpdateType)
    1: {
26217:   NS_DOCUMENT_NOTIFY_OBSERVERS(EndUpdate, (this, aUpdateType));
26217: 
14319:   if (aUpdateType == UPDATE_CONTENT_MODEL) {
14319:     nsContentUtils::RemoveRemovableScriptBlocker();
14319:   }
14319:   else {
13098:     nsContentUtils::RemoveScriptBlocker();
14319:   }
    1: 
    1:   --mUpdateNestLevel;
24482: 
 2025:   // This set of updates may have created XBL bindings.  Let the
 2025:   // binding manager know we're done.
24482:   MaybeEndOutermostXBLUpdate();
24482: 
24482:   MaybeInitializeFinalizeFrameLoaders();
    1: }
    1: 
    1: void
    1: nsDocument::BeginLoad()
    1: {
    1:   // Block onload here to prevent having to deal with blocking and
    1:   // unblocking it while we know the document is loading.
    1:   BlockOnload();
    1: 
16373:   if (mScriptLoader) {
16373:     mScriptLoader->BeginDeferringScripts();
16373:   }
16373: 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginLoad, (this));
    1: }
    1: 
    1: PRBool
15515: nsDocument::CheckGetElementByIdArg(const nsIAtom* aId)
15515: {
15515:   if (aId == nsGkAtoms::_empty) {
    1:     nsContentUtils::ReportToConsole(
    1:         nsContentUtils::eDOM_PROPERTIES,
    1:         "EmptyGetElementByIdParam",
    1:         nsnull, 0,
    1:         nsnull,
    1:         EmptyString(), 0, 0,
    1:         nsIScriptError::warningFlag,
    1:         "DOM");
    1:     return PR_FALSE;
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
15515: nsIdentifierMapEntry*
15515: nsDocument::GetElementByIdInternal(nsIAtom* aID)
15515: {
15474:   // We don't have to flush before we do the initial hashtable lookup, since if
15474:   // the id is already in the hashtable it couldn't have been removed without
15474:   // us being notified (all removals notify immediately, as far as I can tell).
15474:   // So do the lookup first.
15515:   nsIdentifierMapEntry *entry = mIdentifierMap.PutEntry(aID);
15515:   NS_ENSURE_TRUE(entry, nsnull);
15515: 
15515:   if (entry->GetIdContent())
15515:     return entry;
15515: 
26475:   // Now we have to flush.  It could be that we know nothing about this ID yet
26475:   // but more content has been added to the document since.  Note that we have
26475:   // to flush notifications, so that the entry will get updated properly.
15474: 
15474:   // Make sure to stash away the current generation so we can check whether
15474:   // the table changes when we flush.
15474:   PRUint32 generation = mIdentifierMap.GetGeneration();
15474:   
15474:   FlushPendingNotifications(Flush_ContentAndNotify);
15474: 
15474:   if (generation != mIdentifierMap.GetGeneration()) {
15474:     // Table changed, so the entry pointer is no longer valid; look up the
15474:     // entry again, adding if necessary (the adding may be necessary in case
15474:     // the flush actually deleted entries).
15515:     entry = mIdentifierMap.PutEntry(aID);
15515:   }
15515:   
15515:   return entry;
15515: }
15515: 
15515: NS_IMETHODIMP
15515: nsDocument::GetElementById(const nsAString& aElementId,
15515:                            nsIDOMElement** aReturn)
15515: {
15515:   NS_ENSURE_ARG_POINTER(aReturn);
15515:   *aReturn = nsnull;
15515: 
15515:   nsCOMPtr<nsIAtom> idAtom(do_GetAtom(aElementId));
15515:   NS_ENSURE_TRUE(idAtom, NS_ERROR_OUT_OF_MEMORY);
15515:   if (!CheckGetElementByIdArg(idAtom))
15474:     return NS_OK;
15515: 
15515:   nsIdentifierMapEntry *entry = GetElementByIdInternal(idAtom);
15515:   NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
15515: 
26475:   nsIContent *e = entry->GetIdContent();
26475:   if (!e)
15515:     return NS_OK;
15474: 
15474:   return CallQueryInterface(e, aReturn);
15474: }
15474: 
15515: nsIContent*
15515: nsDocument::AddIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
15515:                                 void* aData)
15515: {
15515:   if (!CheckGetElementByIdArg(aID))
15515:     return nsnull;
15515: 
15515:   nsIdentifierMapEntry *entry = GetElementByIdInternal(aID);
15515:   NS_ENSURE_TRUE(entry, nsnull);
15515: 
15515:   entry->AddContentChangeCallback(aObserver, aData);
15515:   return entry->GetIdContent();
15515: }
15515: 
15515: void
15515: nsDocument::RemoveIDTargetObserver(nsIAtom* aID,
15515:                                    IDTargetObserver aObserver, void* aData)
15515: {
15515:   if (!CheckGetElementByIdArg(aID))
15515:     return;
15515: 
22725:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(aID);
22725:   if (!entry) {
22725:     // We don't need to do the stuff that GetElementByIdInternal does;
22725:     // if there's no entry already in mIdentifierMap, then there's no
22725:     // callback to remove.
15515:     return;
22725:   }
15515: 
15515:   entry->RemoveContentChangeCallback(aObserver, aData);
15515: }
15515: 
    1: void
    1: nsDocument::DispatchContentLoadedEvents()
    1: {
 6205:   // If you add early returns from this method, make sure you're
 6205:   // calling UnblockOnload properly.
 6205:   
30065:   // Unpin references to preloaded images
30065:   mPreloadingImages.Clear();
30065:     
    1:   // Fire a DOM event notifying listeners that this document has been
    1:   // loaded (excluding images and other loads initiated by this
    1:   // document).
 3233:   nsContentUtils::DispatchTrustedEvent(this, static_cast<nsIDocument*>(this),
    1:                                        NS_LITERAL_STRING("DOMContentLoaded"),
    1:                                        PR_TRUE, PR_TRUE);
    1: 
    1:   // If this document is a [i]frame, fire a DOMFrameContentLoaded
    1:   // event on all parent documents notifying that the HTML (excluding
    1:   // other external files such as images and stylesheets) in a frame
    1:   // has finished loading.
    1: 
    1:   // target_frame is the [i]frame element that will be used as the
    1:   // target for the event. It's the [i]frame whose content is done
    1:   // loading.
    1:   nsCOMPtr<nsIDOMEventTarget> target_frame;
    1: 
11417:   if (mParentDocument) {
11417:     target_frame =
11417:       do_QueryInterface(mParentDocument->FindContentForSubDocument(this));
    1:   }
    1: 
    1:   if (target_frame) {
11417:     nsCOMPtr<nsIDocument> parent = mParentDocument;
14930:     do {
    1:       nsCOMPtr<nsIDOMDocumentEvent> document_event =
11417:         do_QueryInterface(parent);
    1: 
    1:       nsCOMPtr<nsIDOMEvent> event;
    1:       nsCOMPtr<nsIPrivateDOMEvent> privateEvent;
    1:       if (document_event) {
    1:         document_event->CreateEvent(NS_LITERAL_STRING("Events"),
    1:                                     getter_AddRefs(event));
    1: 
    1:         privateEvent = do_QueryInterface(event);
    1:       }
    1: 
    1:       if (event && privateEvent) {
    1:         event->InitEvent(NS_LITERAL_STRING("DOMFrameContentLoaded"), PR_TRUE,
    1:                          PR_TRUE);
    1: 
    1:         privateEvent->SetTarget(target_frame);
    1:         privateEvent->SetTrusted(PR_TRUE);
    1: 
    1:         // To dispatch this event we must manually call
    1:         // nsEventDispatcher::Dispatch() on the ancestor document since the
    1:         // target is not in the same document, so the event would never reach
    1:         // the ancestor document if we used the normal event
    1:         // dispatching code.
    1: 
20234:         nsEvent* innerEvent = privateEvent->GetInternalNSEvent();
    1:         if (innerEvent) {
    1:           nsEventStatus status = nsEventStatus_eIgnore;
    1: 
11417:           nsIPresShell *shell = parent->GetPrimaryShell();
    1:           if (shell) {
    1:             nsCOMPtr<nsPresContext> context = shell->GetPresContext();
    1: 
    1:             if (context) {
11417:               nsEventDispatcher::Dispatch(parent, context, innerEvent, event,
11417:                                           &status);
11417:             }
11417:           }
11417:         }
11417:       }
14930:       
14930:       parent = parent->GetParentDocument();
14930:     } while (parent);
    1:   }
 6205: 
25379:   // If the document has a manifest attribute, fire a MozApplicationManifest
25379:   // event.
25379:   nsIContent* root = GetRootContent();
25379:   if (root && root->HasAttr(kNameSpaceID_None, nsGkAtoms::manifest)) {
25379:     nsContentUtils::DispatchChromeEvent(this, static_cast<nsIDocument*>(this),
25379:                                         NS_LITERAL_STRING("MozApplicationManifest"),
25379:                                         PR_TRUE, PR_TRUE);
25379:   }
25379: 
 6205:   UnblockOnload(PR_TRUE);
    1: }
    1: 
    1: void
    1: nsDocument::EndLoad()
    1: {
 6177:   // Drop the ref to our parser, if any, but keep hold of the sink so that we
 6177:   // can flush it from FlushPendingNotifications as needed.  We might have to
 6177:   // do that to get a StartLayout() to happen.
 6170:   if (mParser) {
 6170:     mWeakSink = do_GetWeakReference(mParser->GetContentSink());
    1:     mParser = nsnull;
 6170:   }
    1:   
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(EndLoad, (this));
24144:   
24144:   if (!mSynchronousDOMContentLoaded) {
24144:     nsRefPtr<nsIRunnable> ev =
24144:       new nsRunnableMethod<nsDocument>(this,
24144:                                        &nsDocument::DispatchContentLoadedEvents);
24144:     NS_DispatchToCurrentThread(ev);
24144:   } else {
24144:     DispatchContentLoadedEvents();
24144:   }
    1: }
    1: 
    1: void
    1: nsDocument::ContentStatesChanged(nsIContent* aContent1, nsIContent* aContent2,
    1:                                  PRInt32 aStateMask)
    1: {
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(ContentStatesChanged,
    1:                                (this, aContent1, aContent2, aStateMask));
    1: }
    1: 
    1: void
    1: nsDocument::StyleRuleChanged(nsIStyleSheet* aStyleSheet,
    1:                              nsIStyleRule* aOldStyleRule,
    1:                              nsIStyleRule* aNewStyleRule)
    1: {
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleChanged,
    1:                                (this, aStyleSheet,
    1:                                 aOldStyleRule, aNewStyleRule));
    1: }
    1: 
    1: void
    1: nsDocument::StyleRuleAdded(nsIStyleSheet* aStyleSheet,
    1:                            nsIStyleRule* aStyleRule)
    1: {
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleAdded,
    1:                                (this, aStyleSheet, aStyleRule));
    1: }
    1: 
    1: void
    1: nsDocument::StyleRuleRemoved(nsIStyleSheet* aStyleSheet,
    1:                              nsIStyleRule* aStyleRule)
    1: {
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleRemoved,
    1:                                (this, aStyleSheet, aStyleRule));
    1: }
    1: 
    1: 
    1: //
    1: // nsIDOMDocument interface
    1: //
    1: NS_IMETHODIMP
    1: nsDocument::GetDoctype(nsIDOMDocumentType** aDoctype)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDoctype);
    1: 
    1:   *aDoctype = nsnull;
    1:   PRInt32 i, count;
    1:   count = mChildren.ChildCount();
    1:   for (i = 0; i < count; i++) {
 8938:     CallQueryInterface(mChildren.ChildAt(i), aDoctype);
 8938: 
 8938:     if (*aDoctype) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetImplementation(nsIDOMDOMImplementation** aImplementation)
    1: {
34007:   if (!mDOMImplementation) {
    1:     nsCOMPtr<nsIURI> uri;
    1:     NS_NewURI(getter_AddRefs(uri), "about:blank");
    1:     NS_ENSURE_TRUE(uri, NS_ERROR_OUT_OF_MEMORY);
 6475:     PRBool hasHadScriptObject = PR_TRUE;
 6475:     nsIScriptGlobalObject* scriptObject =
 6475:       GetScriptHandlingObject(hasHadScriptObject);
 6475:     NS_ENSURE_STATE(scriptObject || !hasHadScriptObject);
34007:     mDOMImplementation = new nsDOMImplementation(scriptObject, uri, uri,
 6475:                                                  NodePrincipal());
34007:     if (!mDOMImplementation) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
34007:   }
34007: 
34007:   NS_ADDREF(*aImplementation = mDOMImplementation);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetDocumentElement(nsIDOMElement** aDocumentElement)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDocumentElement);
    1: 
 8938:   nsIContent* root = GetRootContent();
 8938:   if (root) {
 8938:     return CallQueryInterface(root, aDocumentElement);
 8938:   }
 8938: 
    1:   *aDocumentElement = nsnull;
 8938: 
 8938:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateElement(const nsAString& aTagName,
    1:                           nsIDOMElement** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::CheckQName(aTagName, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
31946:   NS_ASSERTION(!IsHTML(),
    1:                "nsDocument::CreateElement() called on document that is not "
    1:                "case sensitive. Fix caller, or fix "
    1:                "nsDocument::CreateElement()!");
    1: 
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aTagName);
    1: 
    1:   nsCOMPtr<nsIContent> content;
    1:   rv = CreateElem(name, nsnull, GetDefaultNamespaceID(), PR_TRUE,
    1:                   getter_AddRefs(content));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return CallQueryInterface(content, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateElementNS(const nsAString& aNamespaceURI,
    1:                             const nsAString& aQualifiedName,
    1:                             nsIDOMElement** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
    1:   nsresult rv = nsContentUtils::GetNodeInfoFromQName(aNamespaceURI,
    1:                                                      aQualifiedName,
    1:                                                      mNodeInfoManager,
    1:                                                      getter_AddRefs(nodeInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIContent> content;
14437:   NS_NewElement(getter_AddRefs(content), nodeInfo->NamespaceID(), nodeInfo,
14437:                 PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return CallQueryInterface(content, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateTextNode(const nsAString& aData, nsIDOMText** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIContent> text;
    1:   nsresult rv = NS_NewTextNode(getter_AddRefs(text), mNodeInfoManager);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Don't notify; this node is still being created.
    1:     text->SetText(aData, PR_FALSE);
    1: 
    1:     rv = CallQueryInterface(text, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateDocumentFragment(nsIDOMDocumentFragment** aReturn)
    1: {
    1:   return NS_NewDocumentFragment(aReturn, mNodeInfoManager);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateComment(const nsAString& aData, nsIDOMComment** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   // Make sure the substring "--" is not present in aData.  Otherwise
    1:   // we'll create a document that can't be serialized.
    1:   if (FindInReadable(NS_LITERAL_STRING("--"), aData)) {
    1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> comment;
    1:   nsresult rv = NS_NewCommentNode(getter_AddRefs(comment), mNodeInfoManager);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Don't notify; this node is still being created.
    1:     comment->SetText(aData, PR_FALSE);
    1: 
    1:     rv = CallQueryInterface(comment, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateCDATASection(const nsAString& aData,
    1:                                nsIDOMCDATASection** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   *aReturn = nsnull;
    1: 
    1:   if (FindInReadable(NS_LITERAL_STRING("]]>"), aData))
    1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
    1: 
    1:   nsCOMPtr<nsIContent> content;
    1:   nsresult rv = NS_NewXMLCDATASection(getter_AddRefs(content),
    1:                                       mNodeInfoManager);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Don't notify; this node is still being created.
    1:     content->SetText(aData, PR_FALSE);
    1: 
    1:     rv = CallQueryInterface(content, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateProcessingInstruction(const nsAString& aTarget,
    1:                                         const nsAString& aData,
    1:                                         nsIDOMProcessingInstruction** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::CheckQName(aTarget, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (FindInReadable(NS_LITERAL_STRING("?>"), aData)) {
    1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> content;
    1:   rv = NS_NewXMLProcessingInstruction(getter_AddRefs(content),
    1:                                       mNodeInfoManager, aTarget, aData);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   return CallQueryInterface(content, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateAttribute(const nsAString& aName,
    1:                             nsIDOMAttr** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1:   NS_ENSURE_TRUE(mNodeInfoManager, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult rv = nsContentUtils::CheckQName(aName, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString value;
    1:   nsDOMAttribute* attribute;
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
    1:   rv = mNodeInfoManager->GetNodeInfo(aName, nsnull, kNameSpaceID_None,
    1:                                      getter_AddRefs(nodeInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
11169:   attribute = new nsDOMAttribute(nsnull, nodeInfo, value);
    1:   NS_ENSURE_TRUE(attribute, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   return CallQueryInterface(attribute, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateAttributeNS(const nsAString & aNamespaceURI,
    1:                               const nsAString & aQualifiedName,
    1:                               nsIDOMAttr **aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1:   *aResult = nsnull;
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
    1:   nsresult rv = nsContentUtils::GetNodeInfoFromQName(aNamespaceURI,
    1:                                                      aQualifiedName,
    1:                                                      mNodeInfoManager,
    1:                                                      getter_AddRefs(nodeInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString value;
11169:   nsDOMAttribute* attribute = new nsDOMAttribute(nsnull, nodeInfo, value);
    1:   NS_ENSURE_TRUE(attribute, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   return CallQueryInterface(attribute, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateEntityReference(const nsAString& aName,
    1:                                   nsIDOMEntityReference** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:   *aReturn = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetElementsByTagName(const nsAString& aTagname,
    1:                                  nsIDOMNodeList** aReturn)
    1: {
    1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aTagname);
    1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsContentList *list = NS_GetContentList(this, nameAtom, kNameSpaceID_Unknown).get();
    1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // transfer ref to aReturn
    1:   *aReturn = list;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
    1:                                    const nsAString& aLocalName,
    1:                                    nsIDOMNodeList** aReturn)
    1: {
    1:   PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
    1: 
    1:   if (!aNamespaceURI.EqualsLiteral("*")) {
    1:     nsresult rv =
    1:       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
    1:                                                             nameSpaceId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aLocalName);
    1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsContentList *list = NS_GetContentList(this, nameAtom, nameSpaceId).get();
    1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // transfer ref to aReturn
    1:   *aReturn = list;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetAsync(PRBool *aAsync)
    1: {
    1:   NS_ERROR("nsDocument::GetAsync() should be overriden by subclass!");
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetAsync(PRBool aAsync)
    1: {
    1:   NS_ERROR("nsDocument::SetAsync() should be overriden by subclass!");
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::Load(const nsAString& aUrl, PRBool *aReturn)
    1: {
    1:   NS_ERROR("nsDocument::Load() should be overriden by subclass!");
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::EvaluateFIXptr(const nsAString& aExpression, nsIDOMRange **aRange)
    1: {
    1:   NS_ERROR("nsDocument::EvaluateFIXptr() should be overriden by subclass!");
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::EvaluateXPointer(const nsAString& aExpression,
    1:                              nsIXPointerResult **aResult)
    1: {
    1:   NS_ERROR("nsDocument::EvaluateXPointer() should be overriden by subclass!");
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetStyleSheets(nsIDOMStyleSheetList** aStyleSheets)
    1: {
    1:   if (!mDOMStyleSheets) {
    1:     mDOMStyleSheets = new nsDOMStyleSheetList(this);
    1:     if (!mDOMStyleSheets) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   *aStyleSheets = mDOMStyleSheets;
    1:   NS_ADDREF(*aStyleSheets);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetSelectedStyleSheetSet(nsAString& aSheetSet)
    1: {
    1:   aSheetSet.Truncate();
    1:   
    1:   // Look through our sheets, find the selected set title
    1:   PRInt32 count = GetNumberOfStyleSheets();
    1:   nsAutoString title;
    1:   for (PRInt32 index = 0; index < count; index++) {
    1:     nsIStyleSheet* sheet = GetStyleSheetAt(index);
    1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
    1: 
    1:     nsCOMPtr<nsIDOMStyleSheet> domSheet = do_QueryInterface(sheet);
    1:     NS_ASSERTION(domSheet, "Sheet must QI to nsIDOMStyleSheet");
    1:     PRBool disabled;
    1:     domSheet->GetDisabled(&disabled);
    1:     if (disabled) {
    1:       // Disabled sheets don't affect the currently selected set
    1:       continue;
    1:     }
    1:     
    1:     sheet->GetTitle(title);
    1: 
    1:     if (aSheetSet.IsEmpty()) {
    1:       aSheetSet = title;
    1:     } else if (!title.IsEmpty() && !aSheetSet.Equals(title)) {
    1:       // Sheets from multiple sets enabled; return null string, per spec.
    1:       SetDOMStringToNull(aSheetSet);
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetSelectedStyleSheetSet(const nsAString& aSheetSet)
    1: {
    1:   if (DOMStringIsNull(aSheetSet)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Must update mLastStyleSheetSet before doing anything else with stylesheets
    1:   // or CSSLoaders.
    1:   mLastStyleSheetSet = aSheetSet;
    1:   EnableStyleSheetsForSetInternal(aSheetSet, PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLastStyleSheetSet(nsAString& aSheetSet)
    1: {
    1:   aSheetSet = mLastStyleSheetSet;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetPreferredStyleSheetSet(nsAString& aSheetSet)
    1: {
    1:   GetHeaderData(nsGkAtoms::headerDefaultStyle, aSheetSet);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetStyleSheetSets(nsIDOMDOMStringList** aList)
    1: {
    1:   if (!mStyleSheetSetList) {
    1:     mStyleSheetSetList = new nsDOMStyleSheetSetList(this);
    1:     if (!mStyleSheetSetList) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aList = mStyleSheetSetList);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::EnableStyleSheetsForSet(const nsAString& aSheetSet)
    1: {
    1:   // Per spec, passing in null is a no-op.
    1:   if (!DOMStringIsNull(aSheetSet)) {
    1:     // Note: must make sure to not change the CSSLoader's preferred sheet --
    1:     // that value should be equal to either our lastStyleSheetSet (if that's
    1:     // non-null) or to our preferredStyleSheetSet.  And this method doesn't
    1:     // change either of those.
    1:     EnableStyleSheetsForSetInternal(aSheetSet, PR_FALSE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::EnableStyleSheetsForSetInternal(const nsAString& aSheetSet,
    1:                                             PRBool aUpdateCSSLoader)
    1: {
    1:   BeginUpdate(UPDATE_STYLE);
    1:   PRInt32 count = GetNumberOfStyleSheets();
    1:   nsAutoString title;
    1:   for (PRInt32 index = 0; index < count; index++) {
    1:     nsIStyleSheet* sheet = GetStyleSheetAt(index);
    1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
    1:     sheet->GetTitle(title);
    1:     if (!title.IsEmpty()) {
    1:       sheet->SetEnabled(title.Equals(aSheetSet));
    1:     }
    1:   }
    1:   if (aUpdateCSSLoader) {
    1:     CSSLoader()->SetPreferredSheet(aSheetSet);
    1:   }
    1:   EndUpdate(UPDATE_STYLE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetCharacterSet(nsAString& aCharacterSet)
    1: {
    1:   CopyASCIItoUTF16(GetDocumentCharacterSet(), aCharacterSet);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::ImportNode(nsIDOMNode* aImportedNode,
    1:                        PRBool aDeep,
    1:                        nsIDOMNode** aResult)
    1: {
    1:   NS_ENSURE_ARG(aImportedNode);
    1: 
    1:   *aResult = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aImportedNode);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   PRUint16 nodeType;
    1:   aImportedNode->GetNodeType(&nodeType);
    1:   switch (nodeType) {
    1:     case nsIDOMNode::ATTRIBUTE_NODE:
    1:     case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
    1:     case nsIDOMNode::ELEMENT_NODE:
    1:     case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
    1:     case nsIDOMNode::TEXT_NODE:
    1:     case nsIDOMNode::CDATA_SECTION_NODE:
    1:     case nsIDOMNode::COMMENT_NODE:
    1:     {
    1:       nsCOMPtr<nsINode> imported = do_QueryInterface(aImportedNode);
    1:       NS_ENSURE_TRUE(imported, NS_ERROR_FAILURE);
    1: 
    1:       nsCOMPtr<nsIDOMNode> newNode;
    1:       nsCOMArray<nsINode> nodesWithProperties;
    1:       rv = nsNodeUtils::Clone(imported, aDeep, mNodeInfoManager,
    1:                               nodesWithProperties, getter_AddRefs(newNode));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       nsIDocument *ownerDoc = imported->GetOwnerDoc();
    1:       if (ownerDoc) {
    1:         rv = nsNodeUtils::CallUserDataHandlers(nodesWithProperties, ownerDoc,
    1:                                                nsIDOMUserDataHandler::NODE_IMPORTED,
    1:                                                PR_TRUE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1: 
    1:       newNode.swap(*aResult);
    1: 
    1:       return NS_OK;
    1:     }
    1:     case nsIDOMNode::ENTITY_NODE:
    1:     case nsIDOMNode::ENTITY_REFERENCE_NODE:
    1:     case nsIDOMNode::NOTATION_NODE:
    1:     {
    1:       return NS_ERROR_NOT_IMPLEMENTED;
    1:     }
    1:     default:
    1:     {
    1:       NS_WARNING("Don't know how to clone this nodetype for importNode.");
    1: 
    1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:     }
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::AddBinding(nsIDOMElement* aContent, const nsAString& aURI)
    1: {
    1:   NS_ENSURE_ARG(aContent);
    1:   
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aContent);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aContent));
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   rv = NS_NewURI(getter_AddRefs(uri), aURI);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
 3645:   // Figure out the right principal to use
 3645:   nsCOMPtr<nsIPrincipal> subject;
 3645:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 3645:   if (secMan) {
 3645:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
 3645:     NS_ENSURE_SUCCESS(rv, rv);
 3645:   }
 3645: 
 3645:   if (!subject) {
 3645:     // Fall back to our principal.  Or should we fall back to the null
 3645:     // principal?  The latter would just mean no binding loads....
 3645:     subject = NodePrincipal();
 3645:   }
 3645:   
13669:   return BindingManager()->AddLayeredBinding(content, uri, subject);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::RemoveBinding(nsIDOMElement* aContent, const nsAString& aURI)
    1: {
    1:   NS_ENSURE_ARG(aContent);
    1: 
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aContent);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   rv = NS_NewURI(getter_AddRefs(uri), aURI);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aContent));
13669:   return BindingManager()->RemoveLayeredBinding(content, uri);
    1: }
    1: 
    1: NS_IMETHODIMP
 2324: nsDocument::LoadBindingDocument(const nsAString& aURI)
    1: {
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURI,
    1:                           mCharacterSet.get(),
 3233:                           static_cast<nsIDocument *>(this)->GetBaseURI());
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3645:   // Figure out the right principal to use
 3645:   nsCOMPtr<nsIPrincipal> subject;
 3645:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 3645:   if (secMan) {
 3645:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
 3645:     NS_ENSURE_SUCCESS(rv, rv);
 3645:   }
 3645: 
 3645:   if (!subject) {
 3645:     // Fall back to our principal.  Or should we fall back to the null
 3645:     // principal?  The latter would just mean no binding loads....
 3645:     subject = NodePrincipal();
 3645:   }
 3645:   
13669:   BindingManager()->LoadBindingDocument(this, uri, subject);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetBindingParent(nsIDOMNode* aNode, nsIDOMElement** aResult)
    1: {
    1:   *aResult = nsnull;
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
    1:   if (!content)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(content->GetBindingParent()));
    1:   NS_IF_ADDREF(*aResult = elt);
    1:   return NS_OK;
    1: }
    1: 
    1: static nsresult
    1: GetElementByAttribute(nsIContent* aContent, nsIAtom* aAttrName,
    1:                       const nsAString& aAttrValue, PRBool aUniversalMatch,
    1:                       nsIDOMElement** aResult)
    1: {
    1:   if (aUniversalMatch ? aContent->HasAttr(kNameSpaceID_None, aAttrName) :
    1:                         aContent->AttrValueIs(kNameSpaceID_None, aAttrName,
    1:                                               aAttrValue, eCaseMatters)) {
    1:     return CallQueryInterface(aContent, aResult);
    1:   }
    1: 
    1:   PRUint32 childCount = aContent->GetChildCount();
    1: 
    1:   for (PRUint32 i = 0; i < childCount; ++i) {
    1:     nsIContent *current = aContent->GetChildAt(i);
    1: 
    1:     GetElementByAttribute(current, aAttrName, aAttrValue, aUniversalMatch,
    1:                           aResult);
    1: 
    1:     if (*aResult)
    1:       return NS_OK;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetAnonymousElementByAttribute(nsIDOMElement* aElement,
    1:                                            const nsAString& aAttrName,
    1:                                            const nsAString& aAttrValue,
    1:                                            nsIDOMElement** aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1:   GetAnonymousNodes(aElement, getter_AddRefs(nodeList));
    1: 
    1:   if (!nodeList)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIAtom> attribute = do_GetAtom(aAttrName);
    1: 
    1:   PRUint32 length;
    1:   nodeList->GetLength(&length);
    1: 
    1:   PRBool universalMatch = aAttrValue.EqualsLiteral("*");
    1: 
    1:   for (PRUint32 i = 0; i < length; ++i) {
    1:     nsCOMPtr<nsIDOMNode> current;
    1:     nodeList->Item(i, getter_AddRefs(current));
    1: 
    1:     nsCOMPtr<nsIContent> content(do_QueryInterface(current));
    1: 
    1:     GetElementByAttribute(content, attribute, aAttrValue, universalMatch,
    1:                           aResult);
    1:     if (*aResult)
    1:       return NS_OK;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetAnonymousNodes(nsIDOMElement* aElement,
    1:                               nsIDOMNodeList** aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
13669:   return BindingManager()->GetAnonymousNodesFor(content, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateRange(nsIDOMRange** aReturn)
    1: {
    1:   nsresult rv = NS_NewRange(aReturn);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     (*aReturn)->SetStart(this, 0);
    1:     (*aReturn)->SetEnd(this, 0);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateNodeIterator(nsIDOMNode *aRoot,
    1:                                PRUint32 aWhatToShow,
    1:                                nsIDOMNodeFilter *aFilter,
    1:                                PRBool aEntityReferenceExpansion,
    1:                                nsIDOMNodeIterator **_retval)
    1: {
16103:   *_retval = nsnull;
16103: 
16103:   if (!aRoot)
16103:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
16103: 
16103:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aRoot);
16103:   NS_ENSURE_SUCCESS(rv, rv);
16103: 
16103:   NS_ENSURE_ARG_POINTER(_retval);
16103: 
16103:   nsCOMPtr<nsINode> root = do_QueryInterface(aRoot);
16103:   NS_ENSURE_TRUE(root, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
16103: 
16103:   nsNodeIterator *iterator = new nsNodeIterator(root,
16103:                                                 aWhatToShow,
16103:                                                 aFilter,
16103:                                                 aEntityReferenceExpansion);
16103:   NS_ENSURE_TRUE(iterator, NS_ERROR_OUT_OF_MEMORY);
16103: 
16103:   NS_ADDREF(*_retval = iterator);
16103: 
16103:   return NS_OK; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateTreeWalker(nsIDOMNode *aRoot,
    1:                              PRUint32 aWhatToShow,
    1:                              nsIDOMNodeFilter *aFilter,
    1:                              PRBool aEntityReferenceExpansion,
    1:                              nsIDOMTreeWalker **_retval)
    1: {
    1:   *_retval = nsnull;
    1: 
16103:   if (!aRoot)
    1:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1: 
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aRoot);
16103:   NS_ENSURE_SUCCESS(rv, rv);
16103: 
16103:   NS_ENSURE_ARG_POINTER(_retval);
16103: 
16103:   nsCOMPtr<nsINode> root = do_QueryInterface(aRoot);
16103:   NS_ENSURE_TRUE(root, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
16103: 
16103:   nsTreeWalker* walker = new nsTreeWalker(root,
16103:                                           aWhatToShow,
16103:                                           aFilter,
16103:                                           aEntityReferenceExpansion);
16103:   NS_ENSURE_TRUE(walker, NS_ERROR_OUT_OF_MEMORY);
16103: 
16103:   NS_ADDREF(*_retval = walker);
16103: 
16103:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetDefaultView(nsIDOMAbstractView** aDefaultView)
    1: {
    1:   nsPIDOMWindow* win = GetWindow();
    1:   if (win) {
    1:     return CallQueryInterface(win, aDefaultView);
    1:   }
    1: 
    1:   *aDefaultView = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLocation(nsIDOMLocation **_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1:   *_retval = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMWindowInternal> w(do_QueryInterface(mScriptGlobalObject));
    1: 
    1:   if (!w) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return w->GetLocation(_retval);
    1: }
    1: 
16977: nsIContent*
16977: nsDocument::GetHtmlContent()
16977: {
16977:   nsIContent* rootContent = GetRootContent();
16977:   if (rootContent && rootContent->Tag() == nsGkAtoms::html &&
33329:       rootContent->IsHTML())
16977:     return rootContent;
16977:   return nsnull;
16977: }
16977: 
16977: nsIContent*
16977: nsDocument::GetHtmlChildContent(nsIAtom* aTag)
16977: {
16977:   nsIContent* html = GetHtmlContent();
16977:   if (!html)
16977:     return nsnull;
16977: 
16977:   // Look for the element with aTag inside html. This needs to run
16977:   // forwards to find the first such element.
16977:   for (PRUint32 i = 0; i < html->GetChildCount(); ++i) {
16977:     nsIContent* result = html->GetChildAt(i);
33329:     if (result->Tag() == aTag && result->IsHTML())
16977:       return result;
16977:   }
16977:   return nsnull;
16977: }
16977: 
16977: nsIContent*
33329: nsDocument::GetTitleContent(PRUint32 aNamespace)
16977: {
16977:   // mMayHaveTitleElement will have been set to true if any HTML or SVG
16977:   // <title> element has been bound to this document. So if it's false,
16977:   // we know there is nothing to do here. This avoids us having to search
16977:   // the whole DOM if someone calls document.title on a large document
16977:   // without a title.
16977:   if (!mMayHaveTitleElement)
16977:     return nsnull;
16977: 
16977:   nsRefPtr<nsContentList> list =
16977:     NS_GetContentList(this, nsGkAtoms::title, kNameSpaceID_Unknown);
16977:   if (!list)
16977:     return nsnull;
16977: 
16977:   for (PRUint32 i = 0; ; ++i) {
16977:     // Avoid calling list->Length --- by calling Item one at a time,
16977:     // we can avoid scanning the whole document to build the list of all
16977:     // matches
16977:     nsIContent* elem = list->Item(i, PR_FALSE);
16977:     if (!elem)
16977:       return nsnull;
33329:     if (elem->IsInNamespace(aNamespace))
16977:       return elem;
16977:   }
16977: }
16977: 
16977: void
33329: nsDocument::GetTitleFromElement(PRUint32 aNamespace, nsAString& aTitle)
33329: {
33329:   nsIContent* title = GetTitleContent(aNamespace);
16977:   if (!title)
16977:     return;
16977:   nsContentUtils::GetNodeTextContent(title, PR_FALSE, aTitle);
16977: }
16977: 
    1: NS_IMETHODIMP
    1: nsDocument::GetTitle(nsAString& aTitle)
    1: {
16977:   aTitle.Truncate();
16977: 
16977:   nsIContent *rootContent = GetRootContent();
16977:   if (!rootContent)
16977:     return NS_OK;
16977: 
16977:   nsAutoString tmp;
16977: 
16977:   switch (rootContent->GetNameSpaceID()) {
16977: #ifdef MOZ_XUL
16977:     case kNameSpaceID_XUL:
16977:       rootContent->GetAttr(kNameSpaceID_None, nsGkAtoms::title, tmp);
16977:       break;
16977: #endif
16977: #ifdef MOZ_SVG
16977:     case kNameSpaceID_SVG:
16977:       if (rootContent->Tag() == nsGkAtoms::svg) {
33329:         GetTitleFromElement(kNameSpaceID_SVG, tmp);
16977:         break;
16977:       } // else fall through
16977: #endif
16977:     default:
33329:       GetTitleFromElement(kNameSpaceID_XHTML, tmp);
16977:       break;
16977:   }
16977: 
16977:   tmp.CompressWhitespace();
16977:   aTitle = tmp;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetTitle(const nsAString& aTitle)
    1: {
16977:   nsIContent *rootContent = GetRootContent();
16977:   if (!rootContent)
16977:     return NS_OK;
16977: 
16977:   switch (rootContent->GetNameSpaceID()) {
16977: #ifdef MOZ_SVG
16977:     case kNameSpaceID_SVG:
16977:       return NS_OK; // SVG doesn't support setting a title
16977: #endif
16977: #ifdef MOZ_XUL
16977:     case kNameSpaceID_XUL:
16977:       return rootContent->SetAttr(kNameSpaceID_None, nsGkAtoms::title,
16977:                                   aTitle, PR_TRUE);
16977: #endif
16977:   }
16977: 
16977:   // Batch updates so that mutation events don't change "the title
16977:   // element" under us
16977:   mozAutoDocUpdate updateBatch(this, UPDATE_CONTENT_MODEL, PR_TRUE);
16977: 
33329:   nsIContent* title = GetTitleContent(kNameSpaceID_XHTML);
16977:   if (!title) {
16977:     nsIContent *head = GetHeadContent();
16977:     if (!head)
16977:       return NS_OK;
16977: 
16977:     {
16977:       nsCOMPtr<nsINodeInfo> titleInfo;
19197:       titleInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::title, nsnull,
33339:                                                 kNameSpaceID_XHTML);
16977:       if (!titleInfo)
16977:         return NS_OK;
16977:       title = NS_NewHTMLTitleElement(titleInfo);
16977:       if (!title)
16977:         return NS_OK;
16977:     }
16977: 
16977:     head->AppendChildTo(title, PR_TRUE);
16977:   }
16977: 
16977:   return nsContentUtils::SetNodeTextContent(title, aTitle, PR_FALSE);
16977: }
16977: 
16977: void
16977: nsDocument::NotifyPossibleTitleChange(PRBool aBoundTitleElement)
16977: {
16977:   if (aBoundTitleElement) {
16977:     mMayHaveTitleElement = PR_TRUE;
16977:   }
16977:   if (mPendingTitleChangeEvent.IsPending())
16977:     return;
16977: 
28045:   nsRefPtr<nsNonOwningRunnableMethod<nsDocument> > event =
28045:       new nsNonOwningRunnableMethod<nsDocument>(this,
16977:             &nsDocument::DoNotifyPossibleTitleChange);
16977:   nsresult rv = NS_DispatchToCurrentThread(event);
16977:   if (NS_SUCCEEDED(rv)) {
16977:     mPendingTitleChangeEvent = event;
16977:   }
16977: }
16977: 
16977: void
16977: nsDocument::DoNotifyPossibleTitleChange()
16977: {
16977:   mPendingTitleChangeEvent.Forget();
18363:   mHaveFiredTitleChange = PR_TRUE;
16977: 
16977:   nsAutoString title;
16977:   GetTitle(title);
16977: 
 1722:   nsPresShellIterator iter(this);
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell())) {
    1:     nsCOMPtr<nsISupports> container = shell->GetPresContext()->GetContainer();
    1:     if (!container)
    1:       continue;
    1: 
    1:     nsCOMPtr<nsIBaseWindow> docShellWin = do_QueryInterface(container);
    1:     if (!docShellWin)
    1:       continue;
    1: 
16977:     docShellWin->SetTitle(PromiseFlatString(title).get());
16977:   }
    1: 
    1:   // Fire a DOM event for the title change.
25813:   nsContentUtils::DispatchChromeEvent(this, static_cast<nsIDocument*>(this),
    1:                                       NS_LITERAL_STRING("DOMTitleChanged"),
    1:                                       PR_TRUE, PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult)
    1: {
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
    1:   NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);
 1839: 
11731:   nsIDocument* doc = content->GetOwnerDoc();
 1839:   NS_ENSURE_TRUE(doc == this, NS_ERROR_DOM_WRONG_DOCUMENT_ERR);
    1: 
33329:   if (!mHasWarnedAboutBoxObjects && !content->IsXUL()) {
11731:     mHasWarnedAboutBoxObjects = PR_TRUE;
11731:     nsContentUtils::ReportToConsole(nsContentUtils::eDOM_PROPERTIES,
11731:                                     "UseOfGetBoxObjectForWarning",
11731:                                     nsnull, 0,
11731:                                     static_cast<nsIDocument*>(this)->
11731:                                       GetDocumentURI(),
11731:                                     EmptyString(), 0, 0,
11731:                                     nsIScriptError::warningFlag,
11731:                                     "BoxObjects");
11731:   }
11731: 
    1:   *aResult = nsnull;
    1: 
    1:   if (!mBoxObjectTable) {
11731:     mBoxObjectTable = new nsInterfaceHashtable<nsVoidPtrHashKey, nsPIBoxObject>;
    1:     if (mBoxObjectTable && !mBoxObjectTable->Init(12)) {
    1:       mBoxObjectTable = nsnull;
    1:     }
    1:   } else {
    1:     // Want to use Get(content, aResult); but it's the wrong type
    1:     *aResult = mBoxObjectTable->GetWeak(content);
    1:     if (*aResult) {
    1:       NS_ADDREF(*aResult);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   PRInt32 namespaceID;
13669:   nsCOMPtr<nsIAtom> tag = BindingManager()->ResolveTag(content, &namespaceID);
    1: 
    1:   nsCAutoString contractID("@mozilla.org/layout/xul-boxobject");
    1:   if (namespaceID == kNameSpaceID_XUL) {
    1:     if (tag == nsGkAtoms::browser ||
    1:         tag == nsGkAtoms::editor ||
    1:         tag == nsGkAtoms::iframe)
    1:       contractID += "-container";
    1:     else if (tag == nsGkAtoms::menu)
    1:       contractID += "-menu";
    1:     else if (tag == nsGkAtoms::popup ||
    1:              tag == nsGkAtoms::menupopup ||
 3129:              tag == nsGkAtoms::panel ||
    1:              tag == nsGkAtoms::tooltip)
    1:       contractID += "-popup";
    1:     else if (tag == nsGkAtoms::tree)
    1:       contractID += "-tree";
    1:     else if (tag == nsGkAtoms::listbox)
    1:       contractID += "-listbox";
    1:     else if (tag == nsGkAtoms::scrollbox)
    1:       contractID += "-scrollbox";
    1:   }
    1:   contractID += ";1";
    1: 
    1:   nsCOMPtr<nsPIBoxObject> boxObject(do_CreateInstance(contractID.get()));
    1:   if (!boxObject)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   boxObject->Init(content);
    1: 
    1:   if (mBoxObjectTable) {
    1:     mBoxObjectTable->Put(content, boxObject.get());
    1:   }
    1: 
    1:   *aResult = boxObject;
    1:   NS_ADDREF(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::ClearBoxObjectFor(nsIContent* aContent)
    1: {
    1:   if (mBoxObjectTable) {
    1:     nsPIBoxObject *boxObject = mBoxObjectTable->GetWeak(aContent);
    1:     if (boxObject) {
    1:       boxObject->Clear();
    1:       mBoxObjectTable->Remove(aContent);
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsDocument::GetXBLChildNodesFor(nsIContent* aContent, nsIDOMNodeList** aResult)
    1: {
13669:   return BindingManager()->GetXBLChildNodesFor(aContent, aResult);
    1: }
    1: 
    1: nsresult
    1: nsDocument::GetContentListFor(nsIContent* aContent, nsIDOMNodeList** aResult)
    1: {
13669:   return BindingManager()->GetContentListFor(aContent, aResult);
    1: }
    1: 
    1: void
    1: nsDocument::FlushSkinBindings()
    1: {
13669:   BindingManager()->FlushSkinBindings();
    1: }
    1: 
12256: nsresult
13433: nsDocument::InitializeFrameLoader(nsFrameLoader* aLoader)
13433: {
13433:   mInitializableFrameLoaders.RemoveElement(aLoader);
13433:   // Don't even try to initialize.
13433:   if (mInDestructor) {
13433:     NS_WARNING("Trying to initialize a frame loader while"
13433:                "document is being deleted");
13433:     return NS_ERROR_FAILURE;
13433:   }
23256: 
13433:   mInitializableFrameLoaders.AppendElement(aLoader);
23256:   if (!mFrameLoaderRunner) {
24482:     mFrameLoaderRunner =
24482:       NS_NEW_RUNNABLE_METHOD(nsDocument, this,
24482:                              MaybeInitializeFinalizeFrameLoaders);
23256:     NS_ENSURE_TRUE(mFrameLoaderRunner, NS_ERROR_OUT_OF_MEMORY);
23256:     nsContentUtils::AddScriptRunner(mFrameLoaderRunner);
13433:   }
13433:   return NS_OK;
13433: }
13433: 
13433: nsresult
12256: nsDocument::FinalizeFrameLoader(nsFrameLoader* aLoader)
12256: {
13433:   mInitializableFrameLoaders.RemoveElement(aLoader);
12256:   if (mInDestructor) {
12256:     return NS_ERROR_FAILURE;
12256:   }
23256: 
12256:   mFinalizableFrameLoaders.AppendElement(aLoader);
23256:   if (!mFrameLoaderRunner) {
24482:     mFrameLoaderRunner =
24482:       NS_NEW_RUNNABLE_METHOD(nsDocument, this,
24482:                              MaybeInitializeFinalizeFrameLoaders);
23256:     NS_ENSURE_TRUE(mFrameLoaderRunner, NS_ERROR_OUT_OF_MEMORY);
23256:     nsContentUtils::AddScriptRunner(mFrameLoaderRunner);
12256:   }
12256:   return NS_OK;
12256: }
12256: 
14464: void
24482: nsDocument::MaybeInitializeFinalizeFrameLoaders()
24482: {
24482:   if (mDelayFrameLoaderInitialization || mUpdateNestLevel != 0) {
24482:     // This method will be recalled when mUpdateNestLevel drops to 0,
24482:     // or when !mDelayFrameLoaderInitialization.
23256:     mFrameLoaderRunner = nsnull;
23256:     return;
23256:   }
23256: 
24482:   // We're not in an update, but it is not safe to run scripts, so
24482:   // postpone frameloader initialization and finalization.
24482:   if (!nsContentUtils::IsSafeToRunScript()) {
24482:     if (!mInDestructor && !mFrameLoaderRunner &&
24482:         (mInitializableFrameLoaders.Length() ||
24482:          mFinalizableFrameLoaders.Length())) {
24482:       mFrameLoaderRunner =
24482:         NS_NEW_RUNNABLE_METHOD(nsDocument, this,
24482:                                MaybeInitializeFinalizeFrameLoaders);
24482:       nsContentUtils::AddScriptRunner(mFrameLoaderRunner);
24482:     }
24482:     return;
24482:   }
24482:   mFrameLoaderRunner = nsnull;
24482: 
14660:   // Don't use a temporary array for mInitializableFrameLoaders, because
14660:   // loading a frame may cause some other frameloader to be removed from the
14660:   // array. But be careful to keep the loader alive when starting the load!
14660:   while (mInitializableFrameLoaders.Length()) {
14660:     nsRefPtr<nsFrameLoader> loader = mInitializableFrameLoaders[0];
14660:     mInitializableFrameLoaders.RemoveElementAt(0);
14660:     NS_ASSERTION(loader, "null frameloader in the array?");
14660:     loader->ReallyStartLoading();
14660:   }
14660: 
14660:   PRUint32 length = mFinalizableFrameLoaders.Length();
14464:   if (length > 0) {
14464:     nsTArray<nsRefPtr<nsFrameLoader> > loaders;
14464:     mFinalizableFrameLoaders.SwapElements(loaders);
14464:     for (PRUint32 i = 0; i < length; ++i) {
14464:       loaders[i]->Finalize();
14464:     }
14464:   }
14464: }
14464: 
14660: void
14660: nsDocument::TryCancelFrameLoaderInitialization(nsIDocShell* aShell)
14660: {
14660:   PRUint32 length = mInitializableFrameLoaders.Length();
14660:   for (PRUint32 i = 0; i < length; ++i) {
14660:     if (mInitializableFrameLoaders[i]->GetExistingDocShell() == aShell) {
14660:       mInitializableFrameLoaders.RemoveElementAt(i);
14660:       return;
14660:     }
14660:   }
14660: }
14660: 
14757: PRBool
14757: nsDocument::FrameLoaderScheduledToBeFinalized(nsIDocShell* aShell)
14757: {
14757:   if (aShell) {
14757:     PRUint32 length = mFinalizableFrameLoaders.Length();
14757:     for (PRUint32 i = 0; i < length; ++i) {
14757:       if (mFinalizableFrameLoaders[i]->GetExistingDocShell() == aShell) {
14757:         return PR_TRUE;
14757:       }
14757:     }
14757:   }
14757:   return PR_FALSE;
14757: }
14757: 
20078: nsIDocument*
20078: nsDocument::RequestExternalResource(nsIURI* aURI,
20078:                                     nsINode* aRequestingNode,
20078:                                     ExternalResourceLoad** aPendingLoad)
20078: {
20078:   NS_PRECONDITION(aURI, "Must have a URI");
20078:   NS_PRECONDITION(aRequestingNode, "Must have a node");
20078:   if (mDisplayDocument) {
20078:     return mDisplayDocument->RequestExternalResource(aURI,
20078:                                                      aRequestingNode,
20078:                                                      aPendingLoad);
20078:   }
20078: 
20078:   return mExternalResourceMap.RequestResource(aURI, aRequestingNode,
20078:                                               this, aPendingLoad);
20078: }
20078: 
20078: void
20078: nsDocument::EnumerateExternalResources(nsSubDocEnumFunc aCallback, void* aData)
20078: {
20078:   mExternalResourceMap.EnumerateResources(aCallback, aData);
20078: }
20078: 
23697: #ifdef MOZ_SMIL
23697: nsSMILAnimationController*
23697: nsDocument::GetAnimationController()
23697: {
23697:   // We create the animation controller lazily because most documents won't want
23697:   // one and only SVG documents and the like will call this
23697:   if (mAnimationController)
23697:     return mAnimationController;
35510:   // Refuse to create an Animation Controller if SMIL is disabled, and also
35510:   // for data documents.
35510:   if (!NS_SMILEnabled() || mLoadedAsData)
25961:     return nsnull;
23697: 
23697:   mAnimationController = NS_NewSMILAnimationController(this);
23697:   
23697:   // If there's a presContext then check the animation mode and pause if
23697:   // necessary.
23697:   nsIPresShell *shell = GetPrimaryShell();
23697:   if (mAnimationController && shell) {
23697:     nsPresContext *context = shell->GetPresContext();
23697:     if (context &&
23697:         context->ImageAnimationMode() == imgIContainer::kDontAnimMode) {
23697:       mAnimationController->Pause(nsSMILTimeContainer::PAUSE_USERPREF);
23697:     }
23697:   }
23697: 
23697:   return mAnimationController;
23697: }
23697: #endif // MOZ_SMIL
23697: 
    1: struct DirTable {
    1:   const char* mName;
    1:   PRUint8     mValue;
    1: };
    1: 
    1: static const DirTable dirAttributes[] = {
    1:   {"ltr", IBMBIDI_TEXTDIRECTION_LTR},
    1:   {"rtl", IBMBIDI_TEXTDIRECTION_RTL},
    1:   {0}
    1: };
    1: 
    1: /**
    1:  * Retrieve the "direction" property of the document.
    1:  *
    1:  * @lina 01/09/2001
    1:  */
    1: NS_IMETHODIMP
    1: nsDocument::GetDir(nsAString& aDirection)
    1: {
    1:   PRUint32 options = GetBidiOptions();
    1:   for (const DirTable* elt = dirAttributes; elt->mName; elt++) {
    1:     if (GET_BIDI_OPTION_DIRECTION(options) == elt->mValue) {
    1:       CopyASCIItoUTF16(elt->mName, aDirection);
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * Set the "direction" property of the document.
    1:  *
    1:  * @lina 01/09/2001
    1:  */
    1: NS_IMETHODIMP
    1: nsDocument::SetDir(const nsAString& aDirection)
    1: {
    1:   PRUint32 options = GetBidiOptions();
    1: 
    1:   for (const DirTable* elt = dirAttributes; elt->mName; elt++) {
    1:     if (aDirection == NS_ConvertASCIItoUTF16(elt->mName)) {
    1:       if (GET_BIDI_OPTION_DIRECTION(options) != elt->mValue) {
    1:         SET_BIDI_OPTION_DIRECTION(options, elt->mValue);
  981:         nsIPresShell *shell = GetPrimaryShell();
    1:         if (shell) {
    1:           nsPresContext *context = shell->GetPresContext();
    1:           NS_ENSURE_TRUE(context, NS_ERROR_UNEXPECTED);
    1:           context->SetBidi(options, PR_TRUE);
    1:         } else {
    1:           // No presentation; just set it on ourselves
    1:           SetBidiOptions(options);
    1:         }
    1:       }
    1: 
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //
    1: // nsIDOMNode methods
    1: //
    1: NS_IMETHODIMP
    1: nsDocument::GetNodeName(nsAString& aNodeName)
    1: {
    1:   aNodeName.AssignLiteral("#document");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNodeValue(nsAString& aNodeValue)
    1: {
    1:   SetDOMStringToNull(aNodeValue);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetNodeValue(const nsAString& aNodeValue)
    1: {
    1:   // The DOM spec says that when nodeValue is defined to be null "setting it
    1:   // has no effect", so we don't throw an exception.
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNodeType(PRUint16* aNodeType)
    1: {
    1:   *aNodeType = nsIDOMNode::DOCUMENT_NODE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetParentNode(nsIDOMNode** aParentNode)
    1: {
    1:   *aParentNode = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetChildNodes(nsIDOMNodeList** aChildNodes)
    1: {
23258:   return nsINode::GetChildNodes(aChildNodes);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::HasChildNodes(PRBool* aHasChildNodes)
    1: {
    1:   NS_ENSURE_ARG(aHasChildNodes);
    1: 
    1:   *aHasChildNodes = (mChildren.ChildCount() != 0);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::HasAttributes(PRBool* aHasAttributes)
    1: {
    1:   NS_ENSURE_ARG(aHasAttributes);
    1: 
    1:   *aHasAttributes = PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetFirstChild(nsIDOMNode** aFirstChild)
    1: {
23258:   return nsINode::GetFirstChild(aFirstChild);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLastChild(nsIDOMNode** aLastChild)
    1: {
23258:   return nsINode::GetLastChild(aLastChild);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetPreviousSibling(nsIDOMNode** aPreviousSibling)
    1: {
    1:   *aPreviousSibling = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNextSibling(nsIDOMNode** aNextSibling)
    1: {
    1:   *aNextSibling = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetAttributes(nsIDOMNamedNodeMap** aAttributes)
    1: {
    1:   *aAttributes = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNamespaceURI(nsAString& aNamespaceURI)
    1: {
    1:   SetDOMStringToNull(aNamespaceURI);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetPrefix(nsAString& aPrefix)
    1: {
    1:   SetDOMStringToNull(aPrefix);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetPrefix(const nsAString& aPrefix)
    1: {
    1:   return NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLocalName(nsAString& aLocalName)
    1: {
    1:   SetDOMStringToNull(aLocalName);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::InsertBefore(nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,
    1:                          nsIDOMNode** aReturn)
    1: {
    1:   return nsGenericElement::doReplaceOrInsertBefore(PR_FALSE, aNewChild, aRefChild, nsnull, this,
    1:                                           aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
    1:                          nsIDOMNode** aReturn)
    1: {
    1:   return nsGenericElement::doReplaceOrInsertBefore(PR_TRUE, aNewChild, aOldChild, nsnull, this,
    1:                                           aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
    1: {
    1:   return nsGenericElement::doRemoveChild(aOldChild, nsnull, this, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
    1: {
    1:   return nsDocument::InsertBefore(aNewChild, nsnull, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CloneNode(PRBool aDeep, nsIDOMNode** aReturn)
    1: {
19384:   return nsNodeUtils::CloneNodeImpl(this, aDeep, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::Normalize()
    1: {
    1:   PRInt32 count = mChildren.ChildCount();
    1:   for (PRInt32 i = 0; i < count; ++i) {
    1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mChildren.ChildAt(i)));
    1: 
    1:     if (node) {
    1:       node->Normalize();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::IsSupported(const nsAString& aFeature, const nsAString& aVersion,
    1:                         PRBool* aReturn)
    1: {
 3233:   return nsGenericElement::InternalIsSupported(static_cast<nsIDOMDocument*>(this),
    1:                                                aFeature, aVersion, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetBaseURI(nsAString &aURI)
    1: {
    1:   nsCAutoString spec;
33055:   if (nsIDocument::GetBaseURI()) {
33055:     nsIDocument::GetBaseURI()->GetSpec(spec);
    1:   }
    1: 
    1:   CopyUTF8toUTF16(spec, aURI);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetTextContent(nsAString &aTextContent)
    1: {
    1:   SetDOMStringToNull(aTextContent);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetTextContent(const nsAString& aTextContent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CompareDocumentPosition(nsIDOMNode* aOther, PRUint16* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aOther);
    1: 
    1:   // We could optimize this by getting the other nodes current document
    1:   // and comparing with ourself. But then we'd have to deal with the
    1:   // current document being null and such so it's easier this way.
    1:   // It's hardly a case to optimize anyway.
    1: 
    1:   nsCOMPtr<nsINode> other = do_QueryInterface(aOther);
    1:   NS_ENSURE_TRUE(other, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
    1: 
    1:   *aReturn = nsContentUtils::ComparePosition(other, this);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::IsSameNode(nsIDOMNode* aOther, PRBool* aReturn)
    1: {
    1:   PRBool sameNode = PR_FALSE;
    1: 
    1:   if (this == aOther) {
    1:     sameNode = PR_TRUE;
    1:   }
    1: 
    1:   *aReturn = sameNode;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::IsEqualNode(nsIDOMNode* aOther, PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aOther);
    1: 
    1:   *aReturn = PR_FALSE;
    1: 
    1:   // Node type check by QI.  We also reuse this later.
    1:   nsCOMPtr<nsIDocument> aOtherDoc = do_QueryInterface(aOther);
    1:   if (!aOtherDoc) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Child nodes check.
    1:   PRUint32 childCount = GetChildCount();
    1:   if (childCount != aOtherDoc->GetChildCount()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   for (PRUint32 i = 0; i < childCount; i++) {
    1:     nsIContent* aChild1 = GetChildAt(i);
    1:     nsIContent* aChild2 = aOtherDoc->GetChildAt(i);
    1:     if (!nsNode3Tearoff::AreNodesEqual(aChild1, aChild2)) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   /* Checks not needed:  Prefix, namespace URI, local name, node name,
    1:      node value, attributes.
    1:    */
    1: 
    1:   *aReturn = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::IsDefaultNamespace(const nsAString& aNamespaceURI,
    1:                                PRBool* aReturn)
    1: {
    1:   nsAutoString defaultNamespace;
    1:   LookupNamespaceURI(EmptyString(), defaultNamespace);
    1:   *aReturn = aNamespaceURI.Equals(defaultNamespace);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetFeature(const nsAString& aFeature,
    1:                        const nsAString& aVersion,
    1:                        nsISupports** aReturn)
    1: {
 3233:   return nsGenericElement::InternalGetFeature(static_cast<nsIDOMDocument*>(this),
    1:                                               aFeature, aVersion, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetUserData(const nsAString &aKey,
    1:                         nsIVariant *aData,
    1:                         nsIDOMUserDataHandler *aHandler,
    1:                         nsIVariant **aResult)
    1: {
 1391:   return nsNodeUtils::SetUserData(this, aKey, aData, aHandler, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetUserData(const nsAString &aKey,
    1:                         nsIVariant **aResult)
    1: {
 1391:   return nsNodeUtils::GetUserData(this, aKey, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::LookupPrefix(const nsAString& aNamespaceURI,
    1:                          nsAString& aPrefix)
    1: {
 8938:   nsCOMPtr<nsIDOM3Node> root(do_QueryInterface(GetRootContent()));
    1:   if (root) {
    1:     return root->LookupPrefix(aNamespaceURI, aPrefix);
    1:   }
    1: 
    1:   SetDOMStringToNull(aPrefix);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::LookupNamespaceURI(const nsAString& aNamespacePrefix,
    1:                                nsAString& aNamespaceURI)
    1: {
 8938:   if (NS_FAILED(nsContentUtils::LookupNamespaceURI(GetRootContent(),
    1:                                                    aNamespacePrefix,
    1:                                                    aNamespaceURI))) {
    1:     SetDOMStringToNull(aNamespaceURI);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetInputEncoding(nsAString& aInputEncoding)
    1: {
16447:   if (mHaveInputEncoding) {
    1:     return GetCharacterSet(aInputEncoding);
    1:   }
    1: 
16447:   SetDOMStringToNull(aInputEncoding);
16447:   return NS_OK;
16447: }
16447: 
    1: NS_IMETHODIMP
    1: nsDocument::GetXmlEncoding(nsAString& aXmlEncoding)
    1: {
    1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS &&
    1:       mXMLDeclarationBits & XML_DECLARATION_BITS_ENCODING_EXISTS) {
    1:     // XXX We don't store the encoding given in the xml declaration.
    1:     // For now, just output the inputEncoding which we do store.
    1:     GetInputEncoding(aXmlEncoding);
    1:   } else {
    1:     SetDOMStringToNull(aXmlEncoding);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetXmlStandalone(PRBool *aXmlStandalone)
    1: {
    1:   *aXmlStandalone = 
    1:     mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS &&
    1:     mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_EXISTS &&
    1:     mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_YES;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetXmlStandalone(PRBool aXmlStandalone)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetXmlVersion(nsAString& aXmlVersion)
    1: {
    1:   // If there is no declaration, the value is "1.0".
    1: 
    1:   // XXX We only support "1.0", so always output "1.0" until that changes.
    1:   aXmlVersion.AssignLiteral("1.0");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetXmlVersion(const nsAString& aXmlVersion)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetStrictErrorChecking(PRBool *aStrictErrorChecking)
    1: {
    1:   // This attribute is true by default, and we don't really support it being false.
    1:   *aStrictErrorChecking = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetStrictErrorChecking(PRBool aStrictErrorChecking)
    1: {
    1:   // We don't really support non-strict error checking, so just no-op for now.
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetDocumentURI(nsAString& aDocumentURI)
    1: {
    1:   if (mDocumentURI) {
    1:     nsCAutoString uri;
    1:     mDocumentURI->GetSpec(uri);
    1:     CopyUTF8toUTF16(uri, aDocumentURI);
    1:   } else {
    1:     SetDOMStringToNull(aDocumentURI);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetDocumentURI(const nsAString& aDocumentURI)
    1: {
    1:   // Not allowing this yet, need to think about security ramifications first.
    1:   // We use mDocumentURI to get principals for this document.
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: static void BlastSubtreeToPieces(nsINode *aNode);
    1: 
20261: PLDHashOperator
    1: BlastFunc(nsAttrHashKey::KeyType aKey, nsIDOMNode *aData, void* aUserArg)
    1: {
    1:   nsCOMPtr<nsIAttribute> *attr =
 3233:     static_cast<nsCOMPtr<nsIAttribute>*>(aUserArg);
    1: 
    1:   *attr = do_QueryInterface(aData);
    1: 
    1:   NS_ASSERTION(attr->get(),
    1:                "non-nsIAttribute somehow made it into the hashmap?!");
    1: 
    1:   return PL_DHASH_STOP;
    1: }
    1: 
    1: static void
    1: BlastSubtreeToPieces(nsINode *aNode)
    1: {
    1:   PRUint32 i, count;
    1:   if (aNode->IsNodeOfType(nsINode::eELEMENT)) {
 3233:     nsGenericElement *element = static_cast<nsGenericElement*>(aNode);
    1:     const nsDOMAttributeMap *map = element->GetAttributeMap();
    1:     if (map) {
    1:       nsCOMPtr<nsIAttribute> attr;
    1:       while (map->Enumerate(BlastFunc, &attr) > 0) {
    1:         BlastSubtreeToPieces(attr);
    1: 
19629: #ifdef DEBUG
19629:         nsresult rv =
19629: #endif
19629:           element->UnsetAttr(attr->NodeInfo()->NamespaceID(),
    1:                              attr->NodeInfo()->NameAtom(),
    1:                              PR_FALSE);
    1: 
    1:         // XXX Should we abort here?
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, UnsetAttr shouldn't fail!");
    1:       }
    1:     }
    1:   }
    1: 
    1:   count = aNode->GetChildCount();
    1:   for (i = 0; i < count; ++i) {
    1:     BlastSubtreeToPieces(aNode->GetChildAt(0));
19629: #ifdef DEBUG
19629:     nsresult rv =
19629: #endif
19629:       aNode->RemoveChildAt(0, PR_FALSE);
    1: 
    1:     // XXX Should we abort here?
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, RemoveChildAt shouldn't fail!");
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::AdoptNode(nsIDOMNode *aAdoptedNode, nsIDOMNode **aResult)
    1: {
    1:   NS_ENSURE_ARG(aAdoptedNode);
    1: 
    1:   *aResult = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aAdoptedNode);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsINode> adoptedNode;
    1:   PRUint16 nodeType;
    1:   aAdoptedNode->GetNodeType(&nodeType);
    1:   switch (nodeType) {
    1:     case nsIDOMNode::ATTRIBUTE_NODE:
    1:     {
    1:       // Remove from ownerElement.
    1:       nsCOMPtr<nsIDOMAttr> adoptedAttr = do_QueryInterface(aAdoptedNode, &rv);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       nsCOMPtr<nsIDOMElement> ownerElement;
    1:       rv = adoptedAttr->GetOwnerElement(getter_AddRefs(ownerElement));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       if (ownerElement) {
    1:         nsCOMPtr<nsIDOMAttr> newAttr;
    1:         rv = ownerElement->RemoveAttributeNode(adoptedAttr,
    1:                                                getter_AddRefs(newAttr));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         newAttr.swap(adoptedAttr);
    1:       }
    1: 
    1:       adoptedNode = do_QueryInterface(adoptedAttr, &rv);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:       break;
    1:     }
    1:     case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
    1:     case nsIDOMNode::ELEMENT_NODE:
    1:     case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
    1:     case nsIDOMNode::TEXT_NODE:
    1:     case nsIDOMNode::CDATA_SECTION_NODE:
    1:     case nsIDOMNode::COMMENT_NODE:
    1:     {
    1:       adoptedNode = do_QueryInterface(aAdoptedNode, &rv);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       // We don't want to adopt an element into its own contentDocument or into
    1:       // a descendant contentDocument, so we check if the frameElement of this
    1:       // document or any of its parents is the adopted node or one of its
    1:       // descendants.
    1:       nsIDocument *doc = this;
    1:       do {
    1:         nsPIDOMWindow *win = doc->GetWindow();
    1:         if (win) {
    1:           nsCOMPtr<nsINode> node =
    1:             do_QueryInterface(win->GetFrameElementInternal());
    1:           if (node &&
    1:               nsContentUtils::ContentIsDescendantOf(node, adoptedNode)) {
    1:             return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:           }
    1:         }
    1:       } while ((doc = doc->GetParentDocument()));
    1: 
    1:       // Remove from parent.
    1:       nsCOMPtr<nsIDOMNode> parent;
    1:       aAdoptedNode->GetParentNode(getter_AddRefs(parent));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       if (parent) {
    1:         nsCOMPtr<nsIDOMNode> newChild;
    1:         rv = parent->RemoveChild(aAdoptedNode, getter_AddRefs(newChild));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1: 
    1:       break;
    1:     }
    1:     case nsIDOMNode::ENTITY_REFERENCE_NODE:
    1:     {
    1:       return NS_ERROR_NOT_IMPLEMENTED;
    1:     }
    1:     case nsIDOMNode::DOCUMENT_NODE:
    1:     case nsIDOMNode::DOCUMENT_TYPE_NODE:
    1:     case nsIDOMNode::ENTITY_NODE:
    1:     case nsIDOMNode::NOTATION_NODE:
    1:     {
    1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:     }
    1:     default:
    1:     {
    1:       NS_WARNING("Don't know how to adopt this nodetype for adoptNode.");
    1: 
    1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:     }
    1:   }
    1: 
    1:   nsIDocument *oldDocument = adoptedNode->GetOwnerDoc();
    1:   PRBool sameDocument = oldDocument == this;
    1: 
    1:   JSContext *cx = nsnull;
    1:   JSObject *oldScope = nsnull;
    1:   JSObject *newScope = nsnull;
    1:   if (!sameDocument && oldDocument) {
    1:     rv = nsContentUtils::GetContextAndScopes(oldDocument, this, &cx, &oldScope,
    1:                                              &newScope);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsCOMArray<nsINode> nodesWithProperties;
    1:   rv = nsNodeUtils::Adopt(adoptedNode, sameDocument ? nsnull : mNodeInfoManager,
    1:                           cx, oldScope, newScope, nodesWithProperties);
    1:   if (NS_FAILED(rv)) {
    1:     // Disconnect all nodes from their parents, since some have the old document
    1:     // as their ownerDocument and some have this as their ownerDocument.
    1:     BlastSubtreeToPieces(adoptedNode);
    1: 
    1:     if (!sameDocument && oldDocument) {
    1:       PRUint32 i, count = nodesWithProperties.Count();
    1:       for (i = 0; i < count; ++i) {
    1:         // Remove all properties.
    1:         oldDocument->PropertyTable()->
    1:           DeleteAllPropertiesFor(nodesWithProperties[i]);
    1:       }
    1:     }
    1: 
    1:     return rv;
    1:   }
    1: 
    1:   PRUint32 i, count = nodesWithProperties.Count();
    1:   if (!sameDocument && oldDocument) {
    1:     nsPropertyTable *oldTable = oldDocument->PropertyTable();
    1:     nsPropertyTable *newTable = PropertyTable();
    1:     for (i = 0; i < count; ++i) {
    1:       rv = oldTable->TransferOrDeleteAllPropertiesFor(nodesWithProperties[i],
    1:                                                       newTable);
    1:       if (NS_FAILED(rv)) {
    1:         while (++i < count) {
    1:           oldTable->DeleteAllPropertiesFor(nodesWithProperties[i]);
    1:         }
    1: 
    1:         // Disconnect all nodes from their parents.
    1:         BlastSubtreeToPieces(adoptedNode);
    1: 
    1:         return rv;
    1:       }
    1:     }
    1:   }
    1: 
    1:   rv = nsNodeUtils::CallUserDataHandlers(nodesWithProperties, this,
    1:                                          nsIDOMUserDataHandler::NODE_ADOPTED,
    1:                                          PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return CallQueryInterface(adoptedNode, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetDomConfig(nsIDOMDOMConfiguration **aConfig)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::NormalizeDocument()
    1: {
    1:   // We don't support DOMConfigurations yet, so this just
    1:   // does a straight shot of normalization.
    1:   return Normalize();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::RenameNode(nsIDOMNode *aNode,
    1:                        const nsAString& namespaceURI,
    1:                        const nsAString& qualifiedName,
    1:                        nsIDOMNode **aReturn)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetOwnerDocument(nsIDOMDocument** aOwnerDocument)
    1: {
23258:   return nsINode::GetOwnerDocument(aOwnerDocument);
    1: }
    1: 
29474: nsIEventListenerManager*
29474: nsDocument::GetListenerManager(PRBool aCreateIfNotFound)
29474: {
29474:   if (mListenerManager || !aCreateIfNotFound) {
29474:     return mListenerManager;
    1:   }
    1: 
    1:   nsresult rv = NS_NewEventListenerManager(getter_AddRefs(mListenerManager));
29474:   NS_ENSURE_SUCCESS(rv, nsnull);
    1: 
 3233:   mListenerManager->SetListenerTarget(static_cast<nsIDocument *>(this));
    1: 
29474:   return mListenerManager;
    1: }
    1: 
 1419: nsresult
    1: nsDocument::GetSystemEventGroup(nsIDOMEventGroup **aGroup)
    1: {
29474:   nsIEventListenerManager* manager = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(manager);
    1:   return manager->GetSystemEventGroupLM(aGroup);
    1: }
    1: 
    1: nsresult
    1: nsDocument::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
    1:   aVisitor.mCanHandle = PR_TRUE;
    1:    // FIXME! This is a hack to make middle mouse paste working also in Editor.
    1:    // Bug 329119
    1:   aVisitor.mForceContentDispatch = PR_TRUE;
    1: 
    1:   // Load events must not propagate to |window| object, see bug 335251.
    1:   if (aVisitor.mEvent->message != NS_LOAD) {
20135:     nsCOMPtr<nsPIDOMEventTarget> parentTarget = do_QueryInterface(GetWindow());
20135:     aVisitor.mParentTarget = parentTarget;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocument::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocument::DispatchDOMEvent(nsEvent* aEvent,
    1:                              nsIDOMEvent* aDOMEvent,
    1:                              nsPresContext* aPresContext,
    1:                              nsEventStatus* aEventStatus)
    1: {
 3233:   return nsEventDispatcher::DispatchDOMEvent(static_cast<nsINode*>(this),
    1:                                              aEvent, aDOMEvent,
    1:                                              aPresContext, aEventStatus);
    1: }
    1: 
    1: nsresult
    1: nsDocument::AddEventListenerByIID(nsIDOMEventListener *aListener,
    1:                                   const nsIID& aIID)
    1: {
29474:   nsIEventListenerManager* manager = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(manager);
29474:   return manager->AddEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE);
    1: }
    1: 
    1: nsresult
    1: nsDocument::RemoveEventListenerByIID(nsIDOMEventListener *aListener,
    1:                                      const nsIID& aIID)
    1: {
29474:   return mListenerManager ?
    1:     mListenerManager->RemoveEventListenerByIID(aListener, aIID,
29474:                                                NS_EVENT_FLAG_BUBBLE) :
29474:     NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsDocument::AddEventListener(const nsAString& aType,
    1:                              nsIDOMEventListener* aListener,
    1:                              PRBool aUseCapture)
    1: {
34888:   return AddEventListener(aType, aListener, aUseCapture,
34888:                           !nsContentUtils::IsChromeDoc(this));
    1: }
    1: 
    1: nsresult
    1: nsDocument::RemoveEventListener(const nsAString& aType,
    1:                                 nsIDOMEventListener* aListener,
    1:                                 PRBool aUseCapture)
    1: {
    1:   return RemoveGroupedEventListener(aType, aListener, aUseCapture, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::DispatchEvent(nsIDOMEvent* aEvent, PRBool *_retval)
    1: {
    1:   // Obtain a presentation context
  981:   nsIPresShell *shell = GetPrimaryShell();
    1:   nsCOMPtr<nsPresContext> context;
    1:   if (shell) {
    1:      context = shell->GetPresContext();
    1:   }
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsresult rv =
 3233:     nsEventDispatcher::DispatchDOMEvent(static_cast<nsINode*>(this),
    1:                                         nsnull, aEvent, context, &status);
    1: 
    1:   *_retval = (status != nsEventStatus_eConsumeNoDefault);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::AddGroupedEventListener(const nsAString& aType,
    1:                                     nsIDOMEventListener *aListener,
    1:                                     PRBool aUseCapture,
    1:                                     nsIDOMEventGroup *aEvtGrp)
    1: {
29474:   nsIEventListenerManager* manager = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(manager);
    1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
29474:   return manager->AddEventListenerByType(aListener, aType, flags, aEvtGrp);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::RemoveGroupedEventListener(const nsAString& aType,
    1:                                        nsIDOMEventListener *aListener,
    1:                                        PRBool aUseCapture,
    1:                                        nsIDOMEventGroup *aEvtGrp)
    1: {
29474:   if (mListenerManager) {
    1:     PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1:     mListenerManager->RemoveEventListenerByType(aListener, aType, flags,
    1:                                                 aEvtGrp);
29474:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CanTrigger(const nsAString & type, PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::IsRegisteredHere(const nsAString & type, PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::AddEventListener(const nsAString& aType,
    1:                              nsIDOMEventListener *aListener,
34888:                              PRBool aUseCapture, PRBool aWantsUntrusted)
34888: {
29474:   nsIEventListenerManager* manager = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(manager);
    1: 
    1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1: 
34888:   if (aWantsUntrusted) {
    1:     flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
    1:   }
    1: 
    1:   return manager->AddEventListenerByType(aListener, aType, flags, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateEvent(const nsAString& aEventType, nsIDOMEvent** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   *aReturn = nsnull;
    1: 
    1:   // Obtain a presentation shell
    1: 
  981:   nsIPresShell *shell = GetPrimaryShell();
    1: 
    1:   nsPresContext *presContext = nsnull;
    1: 
    1:   if (shell) {
    1:     // Retrieve the context
    1:     presContext = shell->GetPresContext();
    1:   }
    1: 
    1:   // Create event even without presContext.
    1:   return nsEventDispatcher::CreateEvent(presContext, nsnull,
    1:                                         aEventType, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateEventGroup(nsIDOMEventGroup **aInstancePtrResult)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsIDOMEventGroup> group(do_CreateInstance(kDOMEventGroupCID, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *aInstancePtrResult = group;
    1:   NS_ADDREF(*aInstancePtrResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::FlushPendingNotifications(mozFlushType aType)
    1: {
 6170:   nsCOMPtr<nsIContentSink> sink;
 6170:   if (mParser) {
 6170:     sink = mParser->GetContentSink();
 6170:   } else {
 6170:     sink = do_QueryReferent(mWeakSink);
 6170:   }
    1:   // Determine if it is safe to flush the sink notifications
    1:   // by determining if it safe to flush all the presshells.
 6170:   if (sink && (aType == Flush_Content || IsSafeToFlush())) {
    1:     sink->FlushPendingNotifications(aType);
    1:   }
    1: 
    1:   // Should we be flushing pending binding constructors in here?
    1: 
19869:   if (aType <= Flush_ContentAndNotify) {
    1:     // Nothing to do here
    1:     return;
    1:   }
    1: 
    1:   // If we have a parent we must flush the parent too to ensure that our
30709:   // container is reflowed if its size was changed.  But if it's not safe to
11417:   // flush ourselves, then don't flush the parent, since that can cause things
11417:   // like resizes of our frame's widget, which we can't handle while flushing
11417:   // is unsafe.
16227:   // Since media queries mean that a size change of our container can
16227:   // affect style, we need to promote a style flush on ourself to a
16227:   // layout flush on our parent, since we need our container to be the
16227:   // correct size to determine the correct style.
11417:   if (mParentDocument && IsSafeToFlush()) {
16227:     mozFlushType parentType = aType;
27993:     if (aType >= Flush_Style)
27993:       parentType = PR_MAX(Flush_Layout, aType);
16227:     mParentDocument->FlushPendingNotifications(parentType);
    1:   }
    1: 
 1722:   nsPresShellIterator iter(this);
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell())) {
    1:     shell->FlushPendingNotifications(aType);
    1:   }
    1: }
    1: 
    1: nsIScriptEventManager*
    1: nsDocument::GetScriptEventManager()
    1: {
    1:   if (!mScriptEventManager) {
    1:     mScriptEventManager = new nsScriptEventManager(this);
    1:     // automatically AddRefs
    1:   }
    1: 
    1:   return mScriptEventManager;
    1: }
    1: 
    1: void
    1: nsDocument::SetXMLDeclaration(const PRUnichar *aVersion,
    1:                               const PRUnichar *aEncoding,
    1:                               const PRInt32 aStandalone)
    1: {
    1:   if (!aVersion || *aVersion == '\0') {
    1:     mXMLDeclarationBits = 0;
    1:     return;
    1:   }
    1: 
    1:   mXMLDeclarationBits = XML_DECLARATION_BITS_DECLARATION_EXISTS;
    1: 
    1:   if (aEncoding && *aEncoding != '\0') {
    1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_ENCODING_EXISTS;
    1:   }
    1: 
    1:   if (aStandalone == 1) {
    1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_STANDALONE_EXISTS |
    1:                            XML_DECLARATION_BITS_STANDALONE_YES;
    1:   }
    1:   else if (aStandalone == 0) {
    1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_STANDALONE_EXISTS;
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::GetXMLDeclaration(nsAString& aVersion, nsAString& aEncoding,
    1:                               nsAString& aStandalone)
    1: {
    1:   aVersion.Truncate();
    1:   aEncoding.Truncate();
    1:   aStandalone.Truncate();
    1: 
    1:   if (!(mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS)) {
    1:     return;
    1:   }
    1: 
    1:   // always until we start supporting 1.1 etc.
    1:   aVersion.AssignLiteral("1.0");
    1: 
    1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_ENCODING_EXISTS) {
    1:     // This is what we have stored, not necessarily what was written
    1:     // in the original
    1:     GetCharacterSet(aEncoding);
    1:   }
    1: 
    1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_EXISTS) {
    1:     if (mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_YES) {
    1:       aStandalone.AssignLiteral("yes");
    1:     } else {
    1:       aStandalone.AssignLiteral("no");
    1:     }
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsDocument::IsScriptEnabled()
    1: {
    1:   nsCOMPtr<nsIScriptSecurityManager> sm(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID));
20078:   NS_ENSURE_TRUE(sm, PR_FALSE);
    1: 
    1:   nsIScriptGlobalObject* globalObject = GetScriptGlobalObject();
20078:   NS_ENSURE_TRUE(globalObject, PR_FALSE);
    1: 
    1:   nsIScriptContext *scriptContext = globalObject->GetContext();
20078:   NS_ENSURE_TRUE(scriptContext, PR_FALSE);
    1: 
    1:   JSContext* cx = (JSContext *) scriptContext->GetNativeContext();
20078:   NS_ENSURE_TRUE(cx, PR_FALSE);
    1: 
    1:   PRBool enabled;
    1:   nsresult rv = sm->CanExecuteScripts(cx, NodePrincipal(), &enabled);
20078:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1:   return enabled;
    1: }
    1: 
    1: nsresult
    1: nsDocument::GetRadioGroup(const nsAString& aName,
    1:                           nsRadioGroupStruct **aRadioGroup)
    1: {
    1:   nsAutoString tmKey(aName);
31946:   if(IsHTML())
    1:      ToLowerCase(tmKey); //should case-insensitive.
 6365:   if (mRadioGroups.Get(tmKey, aRadioGroup))
 6365:     return NS_OK;
 6365: 
 6365:   nsAutoPtr<nsRadioGroupStruct> radioGroup(new nsRadioGroupStruct());
    1:   NS_ENSURE_TRUE(radioGroup, NS_ERROR_OUT_OF_MEMORY);
 6365:   NS_ENSURE_TRUE(mRadioGroups.Put(tmKey, radioGroup), NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   *aRadioGroup = radioGroup;
 6365:   radioGroup.forget();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetCurrentRadioButton(const nsAString& aName,
    1:                                   nsIDOMHTMLInputElement* aRadio)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (radioGroup) {
    1:     radioGroup->mSelectedRadioButton = aRadio;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetCurrentRadioButton(const nsAString& aName,
    1:                                   nsIDOMHTMLInputElement** aRadio)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (radioGroup) {
    1:     *aRadio = radioGroup->mSelectedRadioButton;
    1:     NS_IF_ADDREF(*aRadio);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetPositionInGroup(nsIDOMHTMLInputElement *aRadio,
    1:                                PRInt32 *aPositionIndex,
    1:                                PRInt32 *aItemsInGroup)
    1: {
    1:   *aPositionIndex = 0;
    1:   *aItemsInGroup = 1;
    1:   nsAutoString name;
    1:   aRadio->GetName(name);
    1:   if (name.IsEmpty()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   nsresult rv = GetRadioGroup(name, &radioGroup);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIFormControl> radioControl(do_QueryInterface(aRadio));
    1:   NS_ASSERTION(radioControl, "Radio button should implement nsIFormControl");
    1:   *aPositionIndex = radioGroup->mRadioButtons.IndexOf(radioControl);
    1:   NS_ASSERTION(*aPositionIndex >= 0, "Radio button not found in its own group");
    1:   *aItemsInGroup = radioGroup->mRadioButtons.Count();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNextRadioButton(const nsAString& aName,
    1:                                const PRBool aPrevious,
    1:                                nsIDOMHTMLInputElement*  aFocusedRadio,
    1:                                nsIDOMHTMLInputElement** aRadioOut)
    1: {
    1:   // XXX Can we combine the HTML radio button method impls of 
    1:   //     nsDocument and nsHTMLFormControl?
    1:   // XXX Why is HTML radio button stuff in nsDocument, as 
    1:   //     opposed to nsHTMLDocument?
    1:   *aRadioOut = nsnull;
    1: 
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (!radioGroup) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Return the radio button relative to the focused radio button.
    1:   // If no radio is focused, get the radio relative to the selected one.
    1:   nsCOMPtr<nsIDOMHTMLInputElement> currentRadio;
    1:   if (aFocusedRadio) {
    1:     currentRadio = aFocusedRadio;
    1:   }
    1:   else {
    1:     currentRadio = radioGroup->mSelectedRadioButton;
    1:     if (!currentRadio) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1:   nsCOMPtr<nsIFormControl> radioControl(do_QueryInterface(currentRadio));
    1:   PRInt32 index = radioGroup->mRadioButtons.IndexOf(radioControl);
    1:   if (index < 0) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   PRInt32 numRadios = radioGroup->mRadioButtons.Count();
    1:   PRBool disabled;
    1:   nsCOMPtr<nsIDOMHTMLInputElement> radio;
    1:   do {
    1:     if (aPrevious) {
    1:       if (--index < 0) {
    1:         index = numRadios -1;
    1:       }
    1:     }
    1:     else if (++index >= numRadios) {
    1:       index = 0;
    1:     }
 6365:     radio = do_QueryInterface(radioGroup->mRadioButtons[index]);
    1:     NS_ASSERTION(radio, "mRadioButtons holding a non-radio button");
    1:     radio->GetDisabled(&disabled);
    1:   } while (disabled && radio != currentRadio);
    1: 
    1:   NS_IF_ADDREF(*aRadioOut = radio);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::AddToRadioGroup(const nsAString& aName,
    1:                             nsIFormControl* aRadio)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (radioGroup) {
 6365:     radioGroup->mRadioButtons.AppendObject(aRadio);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::RemoveFromRadioGroup(const nsAString& aName,
    1:                                  nsIFormControl* aRadio)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (radioGroup) {
 6365:     radioGroup->mRadioButtons.RemoveObject(aRadio);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::WalkRadioGroup(const nsAString& aName,
    1:                            nsIRadioVisitor* aVisitor,
    1:                            PRBool aFlushContent)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (!radioGroup) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRBool stop = PR_FALSE;
    1:   for (int i = 0; i < radioGroup->mRadioButtons.Count(); i++) {
 6365:     aVisitor->Visit(radioGroup->mRadioButtons[i], &stop);
    1:     if (stop) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::RetrieveRelevantHeaders(nsIChannel *aChannel)
    1: {
    1:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aChannel);
    1:   PRTime modDate = LL_ZERO;
    1:   nsresult rv;
    1: 
    1:   if (httpChannel) {
    1:     nsCAutoString tmp;
    1:     rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("last-modified"),
    1:                                         tmp);
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:       PRTime time;
    1:       PRStatus st = PR_ParseTimeString(tmp.get(), PR_TRUE, &time);
    1:       if (st == PR_SUCCESS) {
    1:         modDate = time;
    1:       }
    1:     }
    1: 
    1:     // The misspelled key 'referer' is as per the HTTP spec
    1:     rv = httpChannel->GetRequestHeader(NS_LITERAL_CSTRING("referer"),
    1:                                        mReferrer);
    1:     if (NS_FAILED(rv)) {
    1:       mReferrer.Truncate();
    1:     }
    1: 
    1:     static const char *const headers[] = {
    1:       "default-style",
    1:       "content-style-type",
    1:       "content-language",
    1:       "content-disposition",
    1:       "refresh",
21577:       "x-dns-prefetch-control",
    1:       // add more http headers if you need
    1:       // XXXbz don't add content-location support without reading bug
    1:       // 238654 and its dependencies/dups first.
    1:       0
    1:     };
    1:     
    1:     nsCAutoString headerVal;
    1:     const char *const *name = headers;
    1:     while (*name) {
    1:       rv =
    1:         httpChannel->GetResponseHeader(nsDependentCString(*name), headerVal);
    1:       if (NS_SUCCEEDED(rv) && !headerVal.IsEmpty()) {
    1:         nsCOMPtr<nsIAtom> key = do_GetAtom(*name);
    1:         SetHeaderData(key, NS_ConvertASCIItoUTF16(headerVal));
    1:       }
    1:       ++name;
    1:     }
    1:   } else {
    1:     nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(aChannel);
    1:     if (fileChannel) {
    1:       nsCOMPtr<nsIFile> file;
    1:       fileChannel->GetFile(getter_AddRefs(file));
    1:       if (file) {
    1:         PRTime msecs;
    1:         rv = file->GetLastModifiedTime(&msecs);
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
    1:           PRInt64 intermediateValue;
    1:           LL_I2L(intermediateValue, PR_USEC_PER_MSEC);
    1:           LL_MUL(modDate, msecs, intermediateValue);
    1:         }
    1:       }
    1:     } else {
    1:       nsCOMPtr<nsIMultiPartChannel> partChannel = do_QueryInterface(aChannel);
    1:       if (partChannel) {
    1:         nsCAutoString contentDisp;
    1:         rv = partChannel->GetContentDisposition(contentDisp);
    1:         if (NS_SUCCEEDED(rv) && !contentDisp.IsEmpty()) {
    1:           SetHeaderData(nsGkAtoms::headerContentDisposition,
    1:                         NS_ConvertASCIItoUTF16(contentDisp));
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (LL_IS_ZERO(modDate)) {
    1:     // We got nothing from our attempt to ask nsIFileChannel and
    1:     // nsIHttpChannel for the last modified time. Return the current
    1:     // time.
    1:     modDate = PR_Now();
    1:   }
    1: 
    1:   mLastModified.Truncate();
    1:   if (LL_NE(modDate, LL_ZERO)) {
    1:     PRExplodedTime prtime;
    1:     PR_ExplodeTime(modDate, PR_LocalTimeParameters, &prtime);
    1:     // "MM/DD/YYYY hh:mm:ss"
 7783:     char formatedTime[24];
 7783:     if (PR_snprintf(formatedTime, sizeof(formatedTime),
 7783:                     "%02ld/%02ld/%04hd %02ld:%02ld:%02ld",
    1:                     prtime.tm_month + 1, prtime.tm_mday, prtime.tm_year,
    1:                     prtime.tm_hour     ,  prtime.tm_min,  prtime.tm_sec)) {
    1:       CopyASCIItoUTF16(nsDependentCString(formatedTime), mLastModified);
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsDocument::CreateElem(nsIAtom *aName, nsIAtom *aPrefix, PRInt32 aNamespaceID,
    1:                        PRBool aDocumentDefaultType, nsIContent **aResult)
    1: {
    1: #ifdef DEBUG
    1:   nsAutoString qName;
    1:   if (aPrefix) {
    1:     aPrefix->ToString(qName);
    1:     qName.Append(':');
    1:   }
    1:   const char *name;
    1:   aName->GetUTF8String(&name);
    1:   AppendUTF8toUTF16(name, qName);
    1: 
11568:   // Note: "a:b:c" is a valid name in non-namespaces XML, and
11568:   // nsDocument::CreateElement can call us with such a name and no prefix,
11568:   // which would cause an error if we just used PR_TRUE here.
11568:   PRBool nsAware = aPrefix != nsnull || aNamespaceID != GetDefaultNamespaceID();
11568:   NS_ASSERTION(NS_SUCCEEDED(nsContentUtils::CheckQName(qName, nsAware)),
11568:                "Don't pass invalid prefixes to nsDocument::CreateElem, "
    1:                "check caller.");
    1: #endif
    1: 
    1:   *aResult = nsnull;
    1:   
    1:   PRInt32 elementType = aDocumentDefaultType ? mDefaultElementType :
    1:     aNamespaceID;
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
19197:   nodeInfo = mNodeInfoManager->GetNodeInfo(aName, aPrefix, aNamespaceID);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
14437:   return NS_NewElement(aResult, elementType, nodeInfo, PR_FALSE);
    1: }
    1: 
    1: PRBool
    1: nsDocument::IsSafeToFlush() const
    1: {
    1:   PRBool isSafeToFlush = PR_TRUE;
 3233:   nsPresShellIterator iter(const_cast<nsIDocument*>
 3233:                                      (static_cast<const nsIDocument*>(this)));
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell()) && isSafeToFlush) {
    1:     shell->IsSafeToFlush(isSafeToFlush);
    1:   }
    1:   return isSafeToFlush;
    1: }
    1: 
    1: nsresult
    1: nsDocument::Sanitize()
    1: {
    1:   // Sanitize the document by resetting all password fields and any form
    1:   // fields with autocomplete=off to their default values.  We do this now,
    1:   // instead of when the presentation is restored, to offer some protection
    1:   // in case there is ever an exploit that allows a cached document to be
    1:   // accessed from a different document.
    1: 
    1:   // First locate all input elements, regardless of whether they are
    1:   // in a form, and reset the password and autocomplete=off elements.
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodes;
    1:   nsresult rv = GetElementsByTagName(NS_LITERAL_STRING("input"),
    1:                                      getter_AddRefs(nodes));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 length = 0;
    1:   if (nodes)
    1:     nodes->GetLength(&length);
    1: 
    1:   nsCOMPtr<nsIDOMNode> item;
    1:   nsAutoString value;
    1:   PRUint32 i;
    1: 
    1:   for (i = 0; i < length; ++i) {
    1:     nodes->Item(i, getter_AddRefs(item));
    1:     NS_ASSERTION(item, "null item in node list!");
    1: 
    1:     nsCOMPtr<nsIDOMHTMLInputElement> input = do_QueryInterface(item);
    1:     if (!input)
    1:       continue;
    1: 
    1:     PRBool resetValue = PR_FALSE;
    1: 
    1:     input->GetAttribute(NS_LITERAL_STRING("autocomplete"), value);
    1:     if (value.LowerCaseEqualsLiteral("off")) {
    1:       resetValue = PR_TRUE;
    1:     } else {
    1:       input->GetType(value);
    1:       if (value.LowerCaseEqualsLiteral("password"))
    1:         resetValue = PR_TRUE;
    1:     }
    1: 
    1:     if (resetValue) {
    1:       nsCOMPtr<nsIFormControl> fc = do_QueryInterface(input);
    1:       fc->Reset();
    1:     }
    1:   }
    1: 
    1:   // Now locate all _form_ elements that have autocomplete=off and reset them
    1:   rv = GetElementsByTagName(NS_LITERAL_STRING("form"), getter_AddRefs(nodes));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   length = 0;
    1:   if (nodes)
    1:     nodes->GetLength(&length);
    1: 
    1:   for (i = 0; i < length; ++i) {
    1:     nodes->Item(i, getter_AddRefs(item));
    1:     NS_ASSERTION(item, "null item in nodelist");
    1: 
    1:     nsCOMPtr<nsIDOMHTMLFormElement> form = do_QueryInterface(item);
    1:     if (!form)
    1:       continue;
    1: 
    1:     form->GetAttribute(NS_LITERAL_STRING("autocomplete"), value);
    1:     if (value.LowerCaseEqualsLiteral("off"))
    1:       form->Reset();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: struct SubDocEnumArgs
    1: {
    1:   nsIDocument::nsSubDocEnumFunc callback;
    1:   void *data;
    1: };
    1: 
20261: static PLDHashOperator
    1: SubDocHashEnum(PLDHashTable *table, PLDHashEntryHdr *hdr,
    1:                PRUint32 number, void *arg)
    1: {
 3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
 3233:   SubDocEnumArgs *args = static_cast<SubDocEnumArgs*>(arg);
    1: 
    1:   nsIDocument *subdoc = entry->mSubDocument;
    1:   PRBool next = subdoc ? args->callback(subdoc, args->data) : PR_TRUE;
    1: 
    1:   return next ? PL_DHASH_NEXT : PL_DHASH_STOP;
    1: }
    1: 
    1: void
    1: nsDocument::EnumerateSubDocuments(nsSubDocEnumFunc aCallback, void *aData)
    1: {
    1:   if (mSubDocuments) {
    1:     SubDocEnumArgs args = { aCallback, aData };
    1:     PL_DHashTableEnumerate(mSubDocuments, SubDocHashEnum, &args);
    1:   }
    1: }
    1: 
20261: static PLDHashOperator
    1: CanCacheSubDocument(PLDHashTable *table, PLDHashEntryHdr *hdr,
    1:                     PRUint32 number, void *arg)
    1: {
 3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
 3233:   PRBool *canCacheArg = static_cast<PRBool*>(arg);
    1: 
    1:   nsIDocument *subdoc = entry->mSubDocument;
    1: 
    1:   // The aIgnoreRequest we were passed is only for us, so don't pass it on.
    1:   PRBool canCache = subdoc ? subdoc->CanSavePresentation(nsnull) : PR_FALSE;
    1:   if (!canCache) {
    1:     *canCacheArg = PR_FALSE;
    1:     return PL_DHASH_STOP;
    1:   }
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: #ifdef DEBUG_bryner
    1: #define DEBUG_PAGE_CACHE
    1: #endif
    1: 
    1: PRBool
    1: nsDocument::CanSavePresentation(nsIRequest *aNewRequest)
    1: {
25722:   if (EventHandlingSuppressed()) {
25722:     return PR_FALSE;
25722:   }
25722: 
25722:   nsPIDOMWindow* win = GetInnerWindow();
25722:   if (win && win->TimeoutSuspendCount()) {
25722:     return PR_FALSE;
25722:   }
25722: 
    1:   // Check our event listener manager for unload/beforeunload listeners.
 1418:   nsCOMPtr<nsPIDOMEventTarget> piTarget = do_QueryInterface(mScriptGlobalObject);
 1418:   if (piTarget) {
29474:     nsIEventListenerManager* manager =
29474:       piTarget->GetListenerManager(PR_FALSE);
    1:     if (manager && manager->HasUnloadListeners()) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1:   if (loadGroup) {
    1:     nsCOMPtr<nsISimpleEnumerator> requests;
    1:     loadGroup->GetRequests(getter_AddRefs(requests));
    1: 
    1:     PRBool hasMore = PR_FALSE;
    1: 
    1:     while (NS_SUCCEEDED(requests->HasMoreElements(&hasMore)) && hasMore) {
    1:       nsCOMPtr<nsISupports> elem;
    1:       requests->GetNext(getter_AddRefs(elem));
    1: 
    1:       nsCOMPtr<nsIRequest> request = do_QueryInterface(elem);
    1:       if (request && request != aNewRequest) {
    1: #ifdef DEBUG_PAGE_CACHE
    1:         nsCAutoString requestName, docSpec;
    1:         request->GetName(requestName);
    1:         if (mDocumentURI)
    1:           mDocumentURI->GetSpec(docSpec);
    1: 
    1:         printf("document %s has request %s\n",
    1:                docSpec.get(), requestName.get());
    1: #endif
    1:         return PR_FALSE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   PRBool canCache = PR_TRUE;
    1:   if (mSubDocuments)
    1:     PL_DHashTableEnumerate(mSubDocuments, CanCacheSubDocument, &canCache);
    1: 
    1:   return canCache;
    1: }
    1: 
    1: void
    1: nsDocument::Destroy()
    1: {
    1:   // The ContentViewer wants to release the document now.  So, tell our content
    1:   // to drop any references to the document so that it can be destroyed.
    1:   if (mIsGoingAway)
    1:     return;
    1: 
    1:   mIsGoingAway = PR_TRUE;
 8462: 
14469:   RemovedFromDocShell();
14188: 
 8462:   PRUint32 i, count = mChildren.ChildCount();
 8462:   for (i = 0; i < count; ++i) {
 8462:     mChildren.ChildAt(i)->DestroyContent();
 8462:   }
 8462: 
    1:   mLayoutHistoryState = nsnull;
    1: 
    1:   nsContentList::OnDocumentDestroy(this);
 8710: 
20078:   // Shut down our external resource map.  We might not need this for
20078:   // leak-fixing if we fix DocumentViewerImpl to do cycle-collection, but
20078:   // tearing down all those frame trees right now is the right thing to do.
20078:   mExternalResourceMap.Shutdown();
21384: 
21384:   // XXX We really should let cycle collection do this, but that currently still
21384:   //     leaks (see https://bugzilla.mozilla.org/show_bug.cgi?id=406684).
30001:   nsContentUtils::ReleaseWrapper(static_cast<nsINode*>(this), this);
33810: 
33810:   // Try really really hard to make sure we don't leak things through
33810:   // mIdentifierMap
33810:   mIdentifierMap.Clear();
    1: }
    1: 
14188: void
14469: nsDocument::RemovedFromDocShell()
14469: {
14469:   if (mRemovedFromDocShell)
14188:     return;
14188: 
14469:   mRemovedFromDocShell = PR_TRUE;
34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull); 
14188: 
14188:   PRUint32 i, count = mChildren.ChildCount();
14188:   for (i = 0; i < count; ++i) {
14188:     mChildren.ChildAt(i)->SaveSubtreeState();
14188:   }
14188: }
14188: 
    1: already_AddRefed<nsILayoutHistoryState>
    1: nsDocument::GetLayoutHistoryState() const
    1: {
    1:   nsILayoutHistoryState* state = nsnull;
    1:   if (!mScriptGlobalObject) {
    1:     NS_IF_ADDREF(state = mLayoutHistoryState);
    1:   } else {
    1:     nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mDocumentContainer));
    1:     if (docShell) {
    1:       docShell->GetLayoutHistoryState(&state);
    1:     }
    1:   }
    1: 
    1:   return state;
    1: }
    1: 
    1: void
    1: nsDocument::BlockOnload()
    1: {
20078:   if (mDisplayDocument) {
20078:     mDisplayDocument->BlockOnload();
20078:     return;
20078:   }
20078:   
    1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
    1:   // -- it's not ours.
    1:   if (mOnloadBlockCount == 0 && mScriptGlobalObject) {
    1:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1:     if (loadGroup) {
    1:       loadGroup->AddRequest(mOnloadBlocker, nsnull);
    1:     }
    1:   }
    1:   ++mOnloadBlockCount;      
    1: }
    1: 
    1: void
    1: nsDocument::UnblockOnload(PRBool aFireSync)
    1: {
20078:   if (mDisplayDocument) {
20078:     mDisplayDocument->UnblockOnload(aFireSync);
20078:     return;
20078:   }
20078: 
    1:   if (mOnloadBlockCount == 0) {
    1:     NS_NOTREACHED("More UnblockOnload() calls than BlockOnload() calls; dropping call");
    1:     return;
    1:   }
    1: 
    1:   --mOnloadBlockCount;
    1: 
    1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
    1:   // -- it's not ours.
    1:   if (mOnloadBlockCount == 0 && mScriptGlobalObject) {
    1:     if (aFireSync) {
    1:       // Increment mOnloadBlockCount, since DoUnblockOnload will decrement it
    1:       ++mOnloadBlockCount;
    1:       DoUnblockOnload();
    1:     } else {
    1:       PostUnblockOnloadEvent();
    1:     }
    1:   }
    1: }
    1: 
    1: class nsUnblockOnloadEvent : public nsRunnable {
    1: public:
    1:   nsUnblockOnloadEvent(nsDocument *doc) : mDoc(doc) {}
    1:   NS_IMETHOD Run() {
    1:     mDoc->DoUnblockOnload();
    1:     return NS_OK;
    1:   }
    1: private:  
    1:   nsRefPtr<nsDocument> mDoc;
    1: };
    1: 
    1: void
    1: nsDocument::PostUnblockOnloadEvent()
    1: {
    1:   nsCOMPtr<nsIRunnable> evt = new nsUnblockOnloadEvent(this);
    1:   nsresult rv = NS_DispatchToCurrentThread(evt);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Stabilize block count so we don't post more events while this one is up
    1:     ++mOnloadBlockCount;
    1:   } else {
    1:     NS_WARNING("failed to dispatch nsUnblockOnloadEvent");
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::DoUnblockOnload()
    1: {
20078:   NS_PRECONDITION(!mDisplayDocument,
20078:                   "Shouldn't get here for resource document");
20078:   NS_PRECONDITION(mOnloadBlockCount != 0,
    1:                   "Shouldn't have a count of zero here, since we stabilized in "
    1:                   "PostUnblockOnloadEvent");
    1:   
    1:   --mOnloadBlockCount;
    1: 
    1:   if (mOnloadBlockCount != 0) {
    1:     // We blocked again after the last unblock.  Nothing to do here.  We'll
    1:     // post a new event when we unblock again.
    1:     return;
    1:   }
    1: 
    1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
    1:   // -- it's not ours.
    1:   if (mScriptGlobalObject) {
    1:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1:     if (loadGroup) {
    1:       loadGroup->RemoveRequest(mOnloadBlocker, nsnull, NS_OK);
    1:     }
    1:   }
    1: }
    1: 
    1: /* See if document is a child of this.  If so, return the frame element in this
    1:  * document that holds currentDoc (or an ancestor). */
    1: already_AddRefed<nsIDOMElement>
    1: nsDocument::CheckAncestryAndGetFrame(nsIDocument* aDocument) const
    1: {
    1:   nsIDocument* parentDoc;
    1:   for (parentDoc = aDocument->GetParentDocument();
 3233:        parentDoc != static_cast<const nsIDocument* const>(this);
    1:        parentDoc = parentDoc->GetParentDocument()) {
    1:     if (!parentDoc) {
    1:       return nsnull;
    1:     }
    1: 
    1:     aDocument = parentDoc;
    1:   }
    1: 
    1:   // In a child document.  Get the appropriate frame.
    1:   nsPIDOMWindow* currentWindow = aDocument->GetWindow();
    1:   if (!currentWindow) {
    1:     return nsnull;
    1:   }
    1:   nsIDOMElement* frameElement = currentWindow->GetFrameElementInternal();
    1:   if (!frameElement) {
    1:     return nsnull;
    1:   }
    1: 
    1:   // Sanity check result
    1:   nsCOMPtr<nsIDOMDocument> domDocument;
    1:   frameElement->GetOwnerDocument(getter_AddRefs(domDocument));
    1:   if (domDocument != this) {
    1:     NS_ERROR("Child documents should live in windows the parent owns");
    1:     return nsnull;
    1:   }
    1: 
    1:   NS_ADDREF(frameElement);
    1:   return frameElement;
    1: }
    1: 
    1: void
29539: nsDocument::DispatchPageTransition(nsPIDOMEventTarget* aDispatchTarget,
29539:                                    const nsAString& aType,
29539:                                    PRBool aPersisted)
29539: {
29539:   if (aDispatchTarget) {
29539:     nsCOMPtr<nsIDOMEvent> event;
29539:     CreateEvent(NS_LITERAL_STRING("pagetransition"), getter_AddRefs(event));
29539:     nsCOMPtr<nsIDOMPageTransitionEvent> ptEvent = do_QueryInterface(event);
29539:     nsCOMPtr<nsIPrivateDOMEvent> pEvent = do_QueryInterface(ptEvent);
29539:     if (pEvent && NS_SUCCEEDED(ptEvent->InitPageTransitionEvent(aType, PR_TRUE,
29539:                                                                 PR_TRUE,
29539:                                                                 aPersisted))) {
29539:       pEvent->SetTrusted(PR_TRUE);
29539:       pEvent->SetTarget(this);
29539:       nsEventDispatcher::DispatchDOMEvent(aDispatchTarget, nsnull, event,
29539:                                           nsnull, nsnull);
29539:     }
29539:   }
    1: }
    1: 
    1: void
25572: nsDocument::OnPageShow(PRBool aPersisted, nsIDOMEventTarget* aDispatchStartTarget)
    1: {
    1:   mVisible = PR_TRUE;
34207: 
34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull); 
    1:   UpdateLinkMap();
    1:   
 8938:   nsIContent* root = GetRootContent();
 8938:   if (aPersisted && root) {
    1:     // Send out notifications that our <link> elements are attached.
 8938:     nsRefPtr<nsContentList> links = NS_GetContentList(root,
    1:                                                       nsGkAtoms::link,
    1:                                                       kNameSpaceID_Unknown);
    1: 
    1:     if (links) {
    1:       PRUint32 linkCount = links->Length(PR_TRUE);
    1:       for (PRUint32 i = 0; i < linkCount; ++i) {
    1:         nsCOMPtr<nsILink> link = do_QueryInterface(links->Item(i, PR_FALSE));
    1:         if (link) {
    1:           link->LinkAdded();
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
25572:   // See nsIDocument
25572:   if (!aDispatchStartTarget) {
25575:     // Set mIsShowing before firing events, in case those event handlers
25575:     // move us around.
23147:     mIsShowing = PR_TRUE;
25572:   }
23147:  
23697: #ifdef MOZ_SMIL
23697:   if (mAnimationController) {
23697:     mAnimationController->OnPageShow();
23697:   }
23697: #endif
29539:   nsCOMPtr<nsPIDOMEventTarget> target =
29539:     aDispatchStartTarget ? do_QueryInterface(aDispatchStartTarget) :
29539:                            do_QueryInterface(GetWindow());
29539:   DispatchPageTransition(target, NS_LITERAL_STRING("pageshow"), aPersisted);
25572: }
    1: 
    1: void
25572: nsDocument::OnPageHide(PRBool aPersisted, nsIDOMEventTarget* aDispatchStartTarget)
    1: {
    1:   // Send out notifications that our <link> elements are detached,
    1:   // but only if this is not a full unload.
 8938:   nsIContent* root = GetRootContent();
 8938:   if (aPersisted && root) {
 8938:     nsRefPtr<nsContentList> links = NS_GetContentList(root,
    1:                                                       nsGkAtoms::link,
    1:                                                       kNameSpaceID_Unknown);
    1: 
    1:     if (links) {
    1:       PRUint32 linkCount = links->Length(PR_TRUE);
    1:       for (PRUint32 i = 0; i < linkCount; ++i) {
    1:         nsCOMPtr<nsILink> link = do_QueryInterface(links->Item(i, PR_FALSE));
    1:         if (link) {
    1:           link->LinkRemoved();
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
25572:   // See nsIDocument
25572:   if (!aDispatchStartTarget) {
25575:     // Set mIsShowing before firing events, in case those event handlers
25575:     // move us around.
23147:     mIsShowing = PR_FALSE;
25572:   }
23147: 
23697: #ifdef MOZ_SMIL
23697:   if (mAnimationController) {
23697:     mAnimationController->OnPageHide();
23697:   }
23697: #endif
23697:   
    1:   // Now send out a PageHide event.
29539:   nsCOMPtr<nsPIDOMEventTarget> target =
29539:     aDispatchStartTarget ? do_QueryInterface(aDispatchStartTarget) :
29539:                            do_QueryInterface(GetWindow());
29539:   DispatchPageTransition(target, NS_LITERAL_STRING("pagehide"), aPersisted);
    1: 
    1:   mVisible = PR_FALSE;
34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull);
    1: }
    1: 
   62: void
   62: nsDocument::WillDispatchMutationEvent(nsINode* aTarget)
   62: {
   62:   NS_ASSERTION(mSubtreeModifiedDepth != 0 ||
   62:                mSubtreeModifiedTargets.Count() == 0,
   62:                "mSubtreeModifiedTargets not cleared after dispatching?");
   62:   ++mSubtreeModifiedDepth;
   62:   if (aTarget) {
 3137:     // MayDispatchMutationEvent is often called just before this method,
 3137:     // so it has already appended the node to mSubtreeModifiedTargets.
 3137:     PRInt32 count = mSubtreeModifiedTargets.Count();
 3137:     if (!count || mSubtreeModifiedTargets[count - 1] != aTarget) {
   62:       mSubtreeModifiedTargets.AppendObject(aTarget);
   62:     }
   62:   }
 3137: }
   62: 
   62: void
   62: nsDocument::MutationEventDispatched(nsINode* aTarget)
   62: {
   62:   --mSubtreeModifiedDepth;
   62:   if (mSubtreeModifiedDepth == 0) {
   62:     PRInt32 count = mSubtreeModifiedTargets.Count();
   62:     if (!count) {
   62:       return;
   62:     }
   62: 
   62:     nsCOMPtr<nsPIDOMWindow> window;
   62:     window = do_QueryInterface(GetScriptGlobalObject());
   62:     if (window &&
   62:         !window->HasMutationListeners(NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED)) {
   62:       mSubtreeModifiedTargets.Clear();
   62:       return;
   62:     }
   62: 
   62:     nsCOMArray<nsINode> realTargets;
   62:     for (PRInt32 i = 0; i < count; ++i) {
   62:       nsINode* possibleTarget = mSubtreeModifiedTargets[i];
13936:       nsCOMPtr<nsIContent> content = do_QueryInterface(possibleTarget);
13936:       if (content && content->IsInNativeAnonymousSubtree()) {
13936:         continue;
13936:       }
   62: 
   62:       nsINode* commonAncestor = nsnull;
   62:       PRInt32 realTargetCount = realTargets.Count();
   62:       for (PRInt32 j = 0; j < realTargetCount; ++j) {
   62:         commonAncestor =
   62:           nsContentUtils::GetCommonAncestor(possibleTarget, realTargets[j]);
   62:         if (commonAncestor) {
   62:           realTargets.ReplaceObjectAt(commonAncestor, j);
   62:           break;
   62:         }
   62:       }
   62:       if (!commonAncestor) {
   62:         realTargets.AppendObject(possibleTarget);
   62:       }
   62:     }
   62: 
   62:     mSubtreeModifiedTargets.Clear();
   62: 
   62:     PRInt32 realTargetCount = realTargets.Count();
   62:     for (PRInt32 k = 0; k < realTargetCount; ++k) {
34394:       mozAutoRemovableBlockerRemover blockerRemover(this);
14319: 
   62:       nsMutationEvent mutation(PR_TRUE, NS_MUTATION_SUBTREEMODIFIED);
   62:       nsEventDispatcher::Dispatch(realTargets[k], nsnull, &mutation);
   62:     }
   62:   }
   62: }
   62: 
    1: static PRUint32 GetURIHash(nsIURI* aURI)
    1: {
    1:   nsCAutoString str;
    1:   aURI->GetSpec(str);
    1:   return HashString(str);
    1: }
    1: 
    1: void
    1: nsDocument::AddStyleRelevantLink(nsIContent* aContent, nsIURI* aURI)
    1: {
    1:   nsUint32ToContentHashEntry* entry = mLinkMap.PutEntry(GetURIHash(aURI));
    1:   if (!entry) // out of memory?
    1:     return;
    1:   entry->PutContent(aContent);
    1: }
    1: 
    1: void
    1: nsDocument::ForgetLink(nsIContent* aContent)
    1: {
    1:   // Important optimization! If the link map is empty (as it will be
    1:   // during teardown because we destroy the map early), then stop
    1:   // now before we waste time constructing a URI object.
    1:   if (mLinkMap.Count() == 0)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   if (!aContent->IsLink(getter_AddRefs(uri)))
    1:     return;
    1:   PRUint32 hash = GetURIHash(uri);
    1:   nsUint32ToContentHashEntry* entry = mLinkMap.GetEntry(hash);
    1:   if (!entry)
    1:     return;
    1: 
    1:   entry->RemoveContent(aContent);
    1:   if (entry->IsEmpty()) {
    1:     // Remove the entry and allow the table to resize, in case
    1:     // a lot of links are being removed from the document or modified
    1:     mLinkMap.RemoveEntry(hash);
    1:   }
    1: }
    1: 
    1: class URIVisitNotifier : public nsUint32ToContentHashEntry::Visitor
    1: {
    1: public:
    1:   nsCAutoString matchURISpec;
    1:   nsCOMArray<nsIContent> contentVisited;
    1:   
    1:   virtual void Visit(nsIContent* aContent) {
    1:     // Ensure that the URIs really match before we try to do anything
    1:     nsCOMPtr<nsIURI> uri;
    1:     if (!aContent->IsLink(getter_AddRefs(uri))) {
    1:       NS_ERROR("Should have found a URI for content in the link map");
    1:       return;
    1:     }
    1:     nsCAutoString spec;
    1:     uri->GetSpec(spec);
    1:     // We use nsCString::Equals here instead of nsIURI::Equals because
    1:     // history matching is all based on spec equality
    1:     if (!spec.Equals(matchURISpec))
    1:       return;
    1: 
    1:     // Throw away the cached link state so it gets refetched by the style
33055:     // system.  We can't call ContentStatesChanged here, because that might
33055:     // modify the hashtable.  Instead, we'll just insert into this array and
33055:     // leave it to our caller to call ContentStatesChanged.
30307:     aContent->SetLinkState(eLinkState_Unknown);
    1:     contentVisited.AppendObject(aContent);
    1:   }
    1: };
    1: 
    1: void
    1: nsDocument::NotifyURIVisitednessChanged(nsIURI* aURI)
    1: {
    1:   if (!mVisible) {
    1:     mVisitednessChangedURIs.AppendObject(aURI);
    1:     return;
    1:   }
    1: 
    1:   nsUint32ToContentHashEntry* entry = mLinkMap.GetEntry(GetURIHash(aURI));
    1:   if (!entry)
    1:     return;
    1: 
    1:   URIVisitNotifier visitor;
    1:   aURI->GetSpec(visitor.matchURISpec);
    1:   entry->VisitContent(&visitor);
33055: 
33055:   MOZ_AUTO_DOC_UPDATE(this, UPDATE_CONTENT_STATE, PR_TRUE);
    1:   for (PRUint32 count = visitor.contentVisited.Count(), i = 0; i < count; ++i) {
    1:     ContentStatesChanged(visitor.contentVisited[i],
    1:                          nsnull, NS_EVENT_STATE_VISITED);
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::DestroyLinkMap()
    1: {
    1:   mVisitednessChangedURIs.Clear();
    1:   mLinkMap.Clear();
    1: }
    1: 
    1: void
    1: nsDocument::UpdateLinkMap()
    1: {
    1:   NS_ASSERTION(mVisible,
    1:                "Should only be updating the link map in visible documents");
    1:   if (!mVisible)
    1:     return;
    1: 
    1:   PRInt32 count = mVisitednessChangedURIs.Count();
    1:   for (PRInt32 i = 0; i < count; ++i) {
    1:     NotifyURIVisitednessChanged(mVisitednessChangedURIs[i]);
    1:   }
    1:   mVisitednessChangedURIs.Clear();
    1: }
    1: 
33055: class RefreshLinkStateVisitor : public nsUint32ToContentHashEntry::Visitor
33055: {
33055: public:
33055:   nsCOMArray<nsIContent> contentVisited;
33055: 
33055:   virtual void Visit(nsIContent* aContent) {
33055:     // We can't call ContentStatesChanged here, because that may modify the link
33055:     // map.  Instead, we just add to an array and call ContentStatesChanged
33055:     // later.
33055:     aContent->SetLinkState(eLinkState_Unknown);
33055:     contentVisited.AppendObject(aContent);
33055:   }
33055: };
33055: 
33055: static PLDHashOperator
33055: RefreshLinkStateTraverser(nsUint32ToContentHashEntry* aEntry,
33055:                                void* userArg)
33055: {
33055:   RefreshLinkStateVisitor *visitor =
33055:     static_cast<RefreshLinkStateVisitor*>(userArg);
33055: 
33055:   aEntry->VisitContent(visitor);
33055:   return PL_DHASH_NEXT;
33055: }
33055: 
33055: 
33055: // Helper function for nsDocument::RefreshLinkHrefs
33055: static void
33055: DropCachedHrefsRecursive(nsIContent * const elem)
33055: {
33055:   // Drop the element's cached href, if it has one.  (If it doesn't have
33055:   // one, this call does nothing.)  We could check first that elem is an <a>
33055:   // tag to avoid making a virtual call, but it turns out not to make a
33055:   // substantial perf difference either way.  This doesn't restyle the link,
33055:   // but we do that later.
33055:   elem->DropCachedHref();
33055: 
33055:   PRUint32 childCount;
33055:   nsIContent * const * child = elem->GetChildArray(&childCount);
33055:   nsIContent * const * end = child + childCount;
33055:   for ( ; child != end; ++child) {
33055:     DropCachedHrefsRecursive(*child);
33055:   }
33055: }
33055: 
33055: void
33055: nsDocument::RefreshLinkHrefs()
33055: {
33055:   if (!GetRootContent())
33055:     return;
33055: 
33055:   // First, walk the DOM and clear the cached hrefs of all the <a> tags.
33055:   DropCachedHrefsRecursive(GetRootContent());
33055: 
33055:   // Now update the styles of everything in the linkmap.
33055:   RefreshLinkStateVisitor visitor;
33055:   mLinkMap.EnumerateEntries(RefreshLinkStateTraverser, &visitor);
33055: 
33055:   MOZ_AUTO_DOC_UPDATE(this, UPDATE_CONTENT_STATE, PR_TRUE);
33055:   for (PRUint32 count = visitor.contentVisited.Count(), i = 0; i < count; i++) {
33055:     ContentStatesChanged(visitor.contentVisited[i],
33055:                          nsnull, NS_EVENT_STATE_VISITED);
33055:   }
33055: }
33055: 
33055: nsIContent*
33055: nsDocument::GetFirstBaseNodeWithHref()
33055: {
33055:   return mFirstBaseNodeWithHref;
33055: }
33055: 
33055: nsresult
33055: nsDocument::SetFirstBaseNodeWithHref(nsIContent *elem)
33055: {
33055:   mFirstBaseNodeWithHref = elem;
33055: 
33055:   if (!elem) {
33055:     SetBaseURI(nsnull);
33055:     return NS_OK;
33055:   }
33055: 
33055:   NS_ASSERTION(elem->Tag() == nsGkAtoms::base,
33055:                "Setting base node to a non <base> element?");
33055:   NS_ASSERTION(elem->GetNameSpaceID() == kNameSpaceID_XHTML,
33055:                "Setting base node to a non XHTML element?");
33055: 
33055:   nsIDocument* doc = elem->GetOwnerDoc();
33055:   nsIURI* currentURI = nsIDocument::GetDocumentURI();
33055: 
33055:   // Resolve the <base> element's href relative to our current URI
33055:   nsAutoString href;
33055:   PRBool hasHref = elem->GetAttr(kNameSpaceID_None, nsGkAtoms::href, href);
33055:   NS_ASSERTION(hasHref,
33055:                "Setting first base node to a node with no href attr?");
33055: 
33055:   nsCOMPtr<nsIURI> newBaseURI;
33055:   nsContentUtils::NewURIWithDocumentCharset(
33055:     getter_AddRefs(newBaseURI), href, doc, currentURI);
33055: 
33055:   // Try to set our base URI.  If that fails, try to set our base URI to null.
33055:   nsresult rv =  SetBaseURI(newBaseURI);
33055:   if (NS_FAILED(rv)) {
33055:     return SetBaseURI(nsnull);
33055:   }
33055:   return rv;
33055: }
33055: 
    1: NS_IMETHODIMP
    1: nsDocument::GetScriptTypeID(PRUint32 *aScriptType)
    1: {
    1:     NS_ERROR("No default script type here - ask some element");
    1:     return nsIProgrammingLanguage::UNKNOWN;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetScriptTypeID(PRUint32 aScriptType)
    1: {
    1:     NS_ERROR("Can't change default script type for a document");
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
16106: 
16106: NS_IMETHODIMP
16106: nsDocument::QuerySelector(const nsAString& aSelector,
16106:                           nsIDOMElement **aReturn)
16106: {
16106:   return nsGenericElement::doQuerySelector(this, aSelector, aReturn);
16106: }
16106: 
16106: NS_IMETHODIMP
16106: nsDocument::QuerySelectorAll(const nsAString& aSelector,
16106:                              nsIDOMNodeList **aReturn)
16106: {
16106:   return nsGenericElement::doQuerySelectorAll(this, aSelector, aReturn);
16106: }
19384: 
19384: nsresult
19384: nsDocument::CloneDocHelper(nsDocument* clone) const
19384: {
19384:   // Init document
19384:   nsresult rv = clone->Init();
19384:   NS_ENSURE_SUCCESS(rv, rv);
19384: 
19384:   // Set URI/principal
19384:   clone->nsDocument::SetDocumentURI(nsIDocument::GetDocumentURI());
19384:   // Must set the principal first, since SetBaseURI checks it.
19384:   clone->SetPrincipal(NodePrincipal());
22362:   clone->mDocumentBaseURI = mDocumentBaseURI;
19384: 
19384:   // Set scripting object
19384:   PRBool hasHadScriptObject = PR_TRUE;
19384:   nsIScriptGlobalObject* scriptObject =
19384:     GetScriptHandlingObject(hasHadScriptObject);
19384:   NS_ENSURE_STATE(scriptObject || !hasHadScriptObject);
19384:   clone->SetScriptHandlingObject(scriptObject);
19384: 
19384:   // Make the clone a data document
19384:   clone->SetLoadedAsData(PR_TRUE);
19384: 
19384:   // Misc state
19384: 
19384:   // State from nsIDocument
19384:   clone->mCharacterSet = mCharacterSet;
19384:   clone->mCharacterSetSource = mCharacterSetSource;
19384:   clone->mCompatMode = mCompatMode;
19384:   clone->mBidiOptions = mBidiOptions;
19384:   clone->mContentLanguage = mContentLanguage;
19384:   clone->mContentType = mContentType;
19384:   clone->mSecurityInfo = mSecurityInfo;
19384: 
19384:   // State from nsDocument
19384:   clone->mIsRegularHTML = mIsRegularHTML;
19384:   clone->mXMLDeclarationBits = mXMLDeclarationBits;
19384:   clone->mBaseTarget = mBaseTarget;
23639:   return NS_OK;
23639: }
23639: 
23639: void
23639: nsDocument::SetReadyStateInternal(ReadyState rs)
23639: {
23639:   mReadyState = rs;
23639:   // TODO fire "readystatechange"
23639: }
23639: 
29975: nsIDocument::ReadyState
29975: nsDocument::GetReadyStateEnum()
29975: {
29975:   return mReadyState;
29975: }
23639: 
23639: NS_IMETHODIMP
23639: nsDocument::GetReadyState(nsAString& aReadyState)
23639: {
23639:   switch(mReadyState) {
23639:   case READYSTATE_LOADING :
23639:     aReadyState.Assign(NS_LITERAL_STRING("loading"));
23639:     break;
23639:   case READYSTATE_INTERACTIVE :
23639:     aReadyState.Assign(NS_LITERAL_STRING("interactive"));
23639:     break;
23639:   case READYSTATE_COMPLETE :
23639:     aReadyState.Assign(NS_LITERAL_STRING("complete"));
23639:     break;  
23639:   default:
23639:     aReadyState.Assign(NS_LITERAL_STRING("uninitialized"));
23639:   }
23639:   return NS_OK;
23639: }
25722: 
25722: static PRBool
25722: SuppressEventHandlingInDocument(nsIDocument* aDocument, void* aData)
25722: {
25722:   aDocument->SuppressEventHandling(*static_cast<PRUint32*>(aData));
25722:   return PR_TRUE;
25722: }
25722: 
25722: void
25722: nsDocument::SuppressEventHandling(PRUint32 aIncrease)
25722: {
25722:   mEventsSuppressed += aIncrease;
25722:   EnumerateSubDocuments(SuppressEventHandlingInDocument, &aIncrease);
25722: }
25722: 
26591: static void
26591: FireOrClearDelayedEvents(nsTArray<nsCOMPtr<nsIDocument> >& aDocuments,
26591:                          PRBool aFireEvents)
26591: {
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm)
29018:     return;
29018: 
26591:   for (PRUint32 i = 0; i < aDocuments.Length(); ++i) {
26591:     if (!aDocuments[i]->EventHandlingSuppressed()) {
29018:       fm->FireDelayedEvents(aDocuments[i]);
26591:       nsPresShellIterator iter(aDocuments[i]);
26591:       nsCOMPtr<nsIPresShell> shell;
26591:       while ((shell = iter.GetNextShell())) {
26591:         shell->FireOrClearDelayedEvents(aFireEvents);
26591:       }
26591:     }
26591:   }
26591: }
26591: 
30065: void
30065: nsDocument::MaybePreLoadImage(nsIURI* uri)
30065: {
30065:   // Early exit if the img is already present in the img-cache
30065:   // which indicates that the "real" load has already started and
30065:   // that we shouldn't preload it.
30065:   if (nsContentUtils::IsImageInCache(uri)) {
30065:     return;
30065:   }
30065: 
30065:   // Image not in cache - trigger preload
30065:   nsCOMPtr<imgIRequest> request;
30065:   nsresult rv =
30065:     nsContentUtils::LoadImage(uri,
30065:                               this,
30065:                               NodePrincipal(),
30065:                               mDocumentURI, // uri of document used as referrer
30065:                               nsnull,       // no observer
30065:                               nsIRequest::LOAD_NORMAL,
30065:                               getter_AddRefs(request));
30065: 
30065:   // Pin image-reference to avoid evicting it from the img-cache before
30065:   // the "real" load occurs. Unpinned in DispatchContentLoadedEvents and
30065:   // unlink
30065:   if (NS_SUCCEEDED(rv)) {
30065:     mPreloadingImages.AppendObject(request);
30065:   }
30065: }
26591: class nsDelayedEventDispatcher : public nsRunnable
26591: {
26591: public:
26591:   nsDelayedEventDispatcher(nsTArray<nsCOMPtr<nsIDocument> >& aDocuments)
26591:   {
26591:     mDocuments.SwapElements(aDocuments);
26591:   }
26591:   virtual ~nsDelayedEventDispatcher() {}
26591: 
26591:   NS_IMETHOD Run()
26591:   {
26591:     FireOrClearDelayedEvents(mDocuments, PR_TRUE);
26591:     return NS_OK;
26591:   }
26591: 
26591: private:
26591:   nsTArray<nsCOMPtr<nsIDocument> > mDocuments;
26591: };
26591: 
25722: static PRBool
25722: GetAndUnsuppressSubDocuments(nsIDocument* aDocument, void* aData)
25722: {
25722:   PRUint32 suppression = aDocument->EventHandlingSuppressed();
25722:   if (suppression > 0) {
25722:     static_cast<nsDocument*>(aDocument)->DecreaseEventSuppression();
25722:   }
26591:   nsTArray<nsCOMPtr<nsIDocument> >* docs =
26591:     static_cast<nsTArray<nsCOMPtr<nsIDocument> >* >(aData);
26591:   docs->AppendElement(aDocument);
25722:   aDocument->EnumerateSubDocuments(GetAndUnsuppressSubDocuments, docs);
25722:   return PR_TRUE;
25722: }
25722: 
25722: void
25722: nsDocument::UnsuppressEventHandlingAndFireEvents(PRBool aFireEvents)
25722: {
25722:   if (mEventsSuppressed > 0) {
25722:     --mEventsSuppressed;
25722:   }
26591: 
26591:   nsTArray<nsCOMPtr<nsIDocument> > documents;
26591:   documents.AppendElement(this);
25722:   EnumerateSubDocuments(GetAndUnsuppressSubDocuments, &documents);
26591: 
26591:   if (aFireEvents) {
26591:     NS_DispatchToCurrentThread(new nsDelayedEventDispatcher(documents));
26591:   } else {
26591:     FireOrClearDelayedEvents(documents, PR_FALSE);
26591:   }
26591: }
26591: 
34394: nsISupports*
34394: nsDocument::GetCurrentContentSink()
34394: {
34394:   return mParser ? mParser->GetContentSink() : nsnull;
34394: }
34394: 
28108: void
28108: nsIDocument::RegisterFreezableElement(nsIContent* aContent)
28108: {
28108:   if (!mFreezableElements) {
28108:     mFreezableElements = new nsTHashtable<nsPtrHashKey<nsIContent> >();
28108:     if (!mFreezableElements)
28108:       return;
28108:     mFreezableElements->Init();
28108:   }
28108:   mFreezableElements->PutEntry(aContent);
28108: }
28108: 
28108: PRBool
28108: nsIDocument::UnregisterFreezableElement(nsIContent* aContent)
28108: {
28108:   if (!mFreezableElements)
28108:     return PR_FALSE;
28108:   if (!mFreezableElements->GetEntry(aContent))
28108:     return PR_FALSE;
28108:   mFreezableElements->RemoveEntry(aContent);
28108:   return PR_TRUE;
28108: }
28108: 
28108: struct EnumerateFreezablesData {
28108:   nsIDocument::FreezableElementEnumerator mEnumerator;
28108:   void* mData;
28108: };
28108: 
28108: static PLDHashOperator
28108: EnumerateFreezables(nsPtrHashKey<nsIContent>* aEntry, void* aData)
28108: {
28108:   EnumerateFreezablesData* data = static_cast<EnumerateFreezablesData*>(aData);
28108:   data->mEnumerator(aEntry->GetKey(), data->mData);
28108:   return PL_DHASH_NEXT;
28108: }
28108: 
28108: void
28108: nsIDocument::EnumerateFreezableElements(FreezableElementEnumerator aEnumerator,
28108:                                         void* aData)
28108: {
28108:   if (!mFreezableElements)
28108:     return;
28108:   EnumerateFreezablesData data = { aEnumerator, aData };
28108:   mFreezableElements->EnumerateEntries(EnumerateFreezables, &data);
28108: }
