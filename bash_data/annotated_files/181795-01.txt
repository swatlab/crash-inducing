 72423: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 72423: 
 72423: #include "SourceSurfaceD2DTarget.h"
 72423: #include "Logging.h"
 72423: #include "DrawTargetD2D.h"
102492: #include "Tools.h"
 72423: 
 72423: #include <algorithm>
 72423: 
 72423: namespace mozilla {
 72423: namespace gfx {
 72423: 
 84361: SourceSurfaceD2DTarget::SourceSurfaceD2DTarget(DrawTargetD2D* aDrawTarget,
 84361:                                                ID3D10Texture2D* aTexture,
 84361:                                                SurfaceFormat aFormat)
 84361:   : mDrawTarget(aDrawTarget)
 84361:   , mTexture(aTexture)
 84361:   , mFormat(aFormat)
102492:   , mOwnsCopy(false)
 72423: {
 72423: }
 72423: 
 72423: SourceSurfaceD2DTarget::~SourceSurfaceD2DTarget()
 72423: {
 84361:   // We don't need to do anything special here to notify our mDrawTarget. It must
 84361:   // already have cleared its mSnapshot field, otherwise this object would
 84361:   // be kept alive.
102492:   if (mOwnsCopy) {
102492:     IntSize size = GetSize();
102492: 
102492:     DrawTargetD2D::mVRAMUsageSS -= size.width * size.height * BytesPerPixel(mFormat);
102492:   }
 72423: }
 72423: 
 72423: IntSize
 72423: SourceSurfaceD2DTarget::GetSize() const
 72423: {
 72423:   D3D10_TEXTURE2D_DESC desc;
 72423:   mTexture->GetDesc(&desc);
 72423: 
 72423:   return IntSize(desc.Width, desc.Height);
 72423: }
 72423: 
 72423: SurfaceFormat
 72423: SourceSurfaceD2DTarget::GetFormat() const
 72423: {
 72423:   return mFormat;
 72423: }
 72423: 
 72423: TemporaryRef<DataSourceSurface>
 72423: SourceSurfaceD2DTarget::GetDataSurface()
 72423: {
 72423:   RefPtr<DataSourceSurfaceD2DTarget> dataSurf =
178292:     new DataSourceSurfaceD2DTarget(mFormat);
 72423: 
 72423:   D3D10_TEXTURE2D_DESC desc;
 72423:   mTexture->GetDesc(&desc);
 72423: 
 72423:   desc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
 72423:   desc.Usage = D3D10_USAGE_STAGING;
 72423:   desc.BindFlags = 0;
 72423:   desc.MiscFlags = 0;
 72423: 
108475:   HRESULT hr = Factory::GetDirect3D10Device()->CreateTexture2D(&desc, nullptr, byRef(dataSurf->mTexture));
 72423: 
 72423:   if (FAILED(hr)) {
 72423:     gfxDebug() << "Failed to create staging texture for SourceSurface. Code: " << hr;
108475:     return nullptr;
 72423:   }
 72423:   Factory::GetDirect3D10Device()->CopyResource(dataSurf->mTexture, mTexture);
 72423: 
 72423:   return dataSurf;
 72423: }
 72423: 
 72423: ID3D10ShaderResourceView*
 72423: SourceSurfaceD2DTarget::GetSRView()
 72423: {
 72423:   if (mSRView) {
 72423:     return mSRView;
 72423:   }
 72423: 
108475:   HRESULT hr = Factory::GetDirect3D10Device()->CreateShaderResourceView(mTexture, nullptr, byRef(mSRView));
 72423: 
 72423:   if (FAILED(hr)) {
 72423:     gfxWarning() << "Failed to create ShaderResourceView. Code: " << hr;
 72423:   }
 72423: 
 72423:   return mSRView;
 72423: }
 72423: 
 72423: void
 72423: SourceSurfaceD2DTarget::DrawTargetWillChange()
 72423: {
 72423:   RefPtr<ID3D10Texture2D> oldTexture = mTexture;
 72423: 
 72423:   D3D10_TEXTURE2D_DESC desc;
 72423:   mTexture->GetDesc(&desc);
 72423: 
147982:   // Our original texture might implement the keyed mutex flag. We shouldn't
147982:   // need that here. We actually specifically don't want it since we don't lock
147982:   // our texture for usage!
147982:   desc.MiscFlags = 0;
147982: 
 72423:   // Get a copy of the surface data so the content at snapshot time was saved.
108475:   Factory::GetDirect3D10Device()->CreateTexture2D(&desc, nullptr, byRef(mTexture));
 72423:   Factory::GetDirect3D10Device()->CopyResource(mTexture, oldTexture);
 72423: 
108475:   mBitmap = nullptr;
 72423: 
102492:   DrawTargetD2D::mVRAMUsageSS += desc.Width * desc.Height * BytesPerPixel(mFormat);
102492:   mOwnsCopy = true;
102492: 
 72423:   // We now no longer depend on the source surface content remaining the same.
 72423:   MarkIndependent();
 72423: }
 72423: 
 72423: ID2D1Bitmap*
 72423: SourceSurfaceD2DTarget::GetBitmap(ID2D1RenderTarget *aRT)
 72423: {
 72423:   if (mBitmap) {
 72423:     return mBitmap;
 72423:   }
 72423: 
 72423:   HRESULT hr;
 72423:   D3D10_TEXTURE2D_DESC desc;
 72423:   mTexture->GetDesc(&desc);
 72423: 
 72423:   IntSize size(desc.Width, desc.Height);
 72423:   
 72423:   RefPtr<IDXGISurface> surf;
 72423:   hr = mTexture->QueryInterface((IDXGISurface**)byRef(surf));
 72423: 
 72423:   if (FAILED(hr)) {
 72423:     gfxWarning() << "Failed to query interface texture to DXGISurface. Code: " << hr;
108475:     return nullptr;
 72423:   }
 72423: 
172174:   D2D1_BITMAP_PROPERTIES props = D2D1::BitmapProperties(D2DPixelFormat(mFormat));
 72423:   hr = aRT->CreateSharedBitmap(IID_IDXGISurface, surf, &props, byRef(mBitmap));
 72423: 
 72423:   if (FAILED(hr)) {
180003:     // This seems to happen for SurfaceFormat::A8 sometimes...
181795:     hr = aRT->CreateBitmap(D2D1::SizeU(desc.Width, desc.Height),
172174:                            D2D1::BitmapProperties(D2DPixelFormat(mFormat)),
 86250:                            byRef(mBitmap));
 86250: 
181795:     if (FAILED(hr)) {
181795:       gfxWarning() << "Failed in CreateBitmap. Code: " << hr;
181795:       return nullptr;
181795:     }
181795: 
 88626:     RefPtr<ID2D1RenderTarget> rt;
 88626: 
 86250:     if (mDrawTarget) {
 88626:       rt = mDrawTarget->mRT;
 88626:     }
 88626: 
 88626:     if (!rt) {
 88626:       // Okay, we already separated from our drawtarget. And we're an A8
 88626:       // surface the only way we can get to a bitmap is by creating a
 88626:       // a rendertarget and from there copying to a bitmap! Terrible!
 88626:       RefPtr<IDXGISurface> surface;
 88626: 
 88626:       hr = mTexture->QueryInterface((IDXGISurface**)byRef(surface));
 88626: 
 88626:       if (FAILED(hr)) {
 88626:         gfxWarning() << "Failed to QI texture to surface.";
108475:         return nullptr;
 88626:       }
 88626: 
 88626:       D2D1_RENDER_TARGET_PROPERTIES props =
172174:         D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT, D2DPixelFormat(mFormat));
 88626:       hr = DrawTargetD2D::factory()->CreateDxgiSurfaceRenderTarget(surface, props, byRef(rt));
 88626: 
 88626:       if (FAILED(hr)) {
 88626:         gfxWarning() << "Failed to create D2D render target for texture.";
108475:         return nullptr;
 88626:       }
 88626:     }
 88626: 
108475:     mBitmap->CopyFromRenderTarget(nullptr, rt, nullptr);
 86250:     return mBitmap;
 86250:   }
 72423: 
 72423:   return mBitmap;
 72423: }
 72423: 
 72423: void
 72423: SourceSurfaceD2DTarget::MarkIndependent()
 72423: {
 84361:   if (mDrawTarget) {
 84361:     MOZ_ASSERT(mDrawTarget->mSnapshot == this);
108475:     mDrawTarget->mSnapshot = nullptr;
108475:     mDrawTarget = nullptr;
 72423:   }
 72423: }
 72423: 
178292: DataSourceSurfaceD2DTarget::DataSourceSurfaceD2DTarget(SurfaceFormat aFormat)
178292:   : mFormat(aFormat)
 72423:   , mMapped(false)
 72423: {
 72423: }
 72423: 
 72423: DataSourceSurfaceD2DTarget::~DataSourceSurfaceD2DTarget()
 72423: {
 72423:   if (mMapped) {
 72423:     mTexture->Unmap(0);
 72423:   }
 72423: }
 72423: 
 72423: IntSize
 72423: DataSourceSurfaceD2DTarget::GetSize() const
 72423: {
 72423:   D3D10_TEXTURE2D_DESC desc;
 72423:   mTexture->GetDesc(&desc);
 72423: 
 72423:   return IntSize(desc.Width, desc.Height);
 72423: }
 72423: 
 72423: SurfaceFormat
 72423: DataSourceSurfaceD2DTarget::GetFormat() const
 72423: {
 72423:   return mFormat;
 72423: }
 72423: 
 99076: uint8_t*
 72423: DataSourceSurfaceD2DTarget::GetData()
 72423: {
 72423:   EnsureMapped();
 72423: 
 72423:   return (unsigned char*)mMap.pData;
 72423: }
 72423: 
 72423: int32_t
 72423: DataSourceSurfaceD2DTarget::Stride()
 72423: {
 72423:   EnsureMapped();
 72423:   return mMap.RowPitch;
 72423: }
 72423: 
180796: bool
180796: DataSourceSurfaceD2DTarget::Map(MapType aMapType, MappedSurface *aMappedSurface)
180796: {
180796:   // DataSourceSurfaces used with the new Map API should not be used with GetData!!
180796:   MOZ_ASSERT(!mMapped);
180796:   MOZ_ASSERT(!mIsMapped);
180796: 
180796:   if (!mTexture) {
180796:     return false;
180796:   }
180796: 
180796:   D3D10_MAP mapType;
180796: 
180796:   if (aMapType == MapType::READ) {
180796:     mapType = D3D10_MAP_READ;
180796:   } else if (aMapType == MapType::WRITE) {
180796:     mapType = D3D10_MAP_WRITE;
180796:   } else {
180796:     mapType = D3D10_MAP_READ_WRITE;
180796:   }
180796: 
180796:   D3D10_MAPPED_TEXTURE2D map;
180796: 
180796:   HRESULT hr = mTexture->Map(0, mapType, 0, &map);
180796: 
180796:   if (FAILED(hr)) {
180796:     gfxWarning() << "Texture map failed with code: " << hr;
180796:     return false;
180796:   }
180796: 
180796:   aMappedSurface->mData = (uint8_t*)map.pData;
180796:   aMappedSurface->mStride = map.RowPitch;
180796: 
180796:   return true;
180796: }
180796: 
180796: void
180796: DataSourceSurfaceD2DTarget::Unmap()
180796: {
180796:   MOZ_ASSERT(mIsMapped);
180796: 
180796:   mTexture->Unmap(0);
180796: }
180796: 
 72423: void
 72423: DataSourceSurfaceD2DTarget::EnsureMapped()
 72423: {
180796:   // Do not use GetData() after having used Map!
180796:   MOZ_ASSERT(!mIsMapped);
 72423:   if (!mMapped) {
 72423:     HRESULT hr = mTexture->Map(0, D3D10_MAP_READ, 0, &mMap);
 72423:     if (FAILED(hr)) {
 72423:       gfxWarning() << "Failed to map texture to memory. Code: " << hr;
 72423:       return;
 72423:     }
 72423:     mMapped = true;
 72423:   }
 72423: }
 72423: 
 72423: }
 72423: }
