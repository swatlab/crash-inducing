53840: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
56201:  * vim: set ts=4 sw=4 et tw=99:
53840:  *
53840:  * ***** BEGIN LICENSE BLOCK *****
53840:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
53840:  *
53840:  * The contents of this file are subject to the Mozilla Public License Version
53840:  * 1.1 (the "License"); you may not use this file except in compliance with
53840:  * the License. You may obtain a copy of the License at
53840:  * http://www.mozilla.org/MPL/
53840:  *
53840:  * Software distributed under the License is distributed on an "AS IS" basis,
53840:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
53840:  * for the specific language governing rights and limitations under the
53840:  * License.
53840:  *
53840:  * The Original Code is SpiderMonkey code.
53840:  *
53840:  * The Initial Developer of the Original Code is
53840:  * Mozilla Corporation.
53840:  * Portions created by the Initial Developer are Copyright (C) 2010
53840:  * the Initial Developer. All Rights Reserved.
53840:  *
53840:  * Contributor(s):
53840:  *   Luke Wagner <lw@mozilla.com>
53840:  *
53840:  * Alternatively, the contents of this file may be used under the terms of
53840:  * either of the GNU General Public License Version 2 or later (the "GPL"),
53840:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
53840:  * in which case the provisions of the GPL or the LGPL are applicable instead
53840:  * of those above. If you wish to allow use of your version of this file only
53840:  * under the terms of either the GPL or the LGPL, and not to allow others to
53840:  * use your version of this file under the terms of the MPL, indicate your
53840:  * decision by deleting the provisions above and replace them with the notice
53840:  * and other provisions required by the GPL or the LGPL. If you do not delete
53840:  * the provisions above, a recipient may use your version of this file under
53840:  * the terms of any one of the MPL, the GPL or the LGPL.
53840:  *
53840:  * ***** END LICENSE BLOCK ***** */
53840: 
53840: #ifndef jsinterpinlines_h__
53840: #define jsinterpinlines_h__
53840: 
55711: #include "jsapi.h"
55711: #include "jsbool.h"
55711: #include "jsinterp.h"
55711: #include "jsnum.h"
55565: #include "jsprobes.h"
55711: #include "jsstr.h"
55565: #include "methodjit/MethodJIT.h"
55565: 
53840: inline void
55517: JSStackFrame::initPrev(JSContext *cx)
55517: {
55517:     JS_ASSERT(flags_ & JSFRAME_HAS_PREVPC);
55517:     if (JSFrameRegs *regs = cx->regs) {
55517:         prev_ = regs->fp;
55517:         prevpc_ = regs->pc;
55517:         JS_ASSERT_IF(!prev_->isDummyFrame() && !prev_->hasImacropc(),
55517:                      uint32(prevpc_ - prev_->script()->code) < prev_->script()->length);
55517:     } else {
55517:         prev_ = NULL;
55517: #ifdef DEBUG
55517:         prevpc_ = (jsbytecode *)0xbadc;
55517: #endif
55517:     }
55517: }
55517: 
55517: inline void
55517: JSStackFrame::resetGeneratorPrev(JSContext *cx)
55517: {
57808:     flags_ |= JSFRAME_HAS_PREVPC;
55517:     initPrev(cx);
55517: }
55517: 
55517: inline void
53840: JSStackFrame::initCallFrame(JSContext *cx, JSObject &callee, JSFunction *fun,
53840:                             uint32 nactual, uint32 flagsArg)
53840: {
53840:     JS_ASSERT((flagsArg & ~(JSFRAME_CONSTRUCTING |
53840:                             JSFRAME_OVERFLOW_ARGS |
53840:                             JSFRAME_UNDERFLOW_ARGS)) == 0);
53840:     JS_ASSERT(fun == callee.getFunctionPrivate());
53840: 
53840:     /* Initialize stack frame members. */
55483:     flags_ = JSFRAME_FUNCTION | JSFRAME_HAS_PREVPC | JSFRAME_HAS_SCOPECHAIN | flagsArg;
53840:     exec.fun = fun;
53840:     args.nactual = nactual;  /* only need to write if over/under-flow */
53840:     scopeChain_ = callee.getParent();
55517:     initPrev(cx);
53840:     JS_ASSERT(!hasImacropc());
53840:     JS_ASSERT(!hasHookData());
53840:     JS_ASSERT(annotation() == NULL);
53840: 
53840:     JS_ASSERT(!hasCallObj());
53840: }
53840: 
53840: inline void
55565: JSStackFrame::resetInvokeCallFrame()
55565: {
55565:     /* Undo changes to frame made during execution; see initCallFrame */
55565: 
55565:     if (hasArgsObj())
55565:         args.nactual = argsObj().getArgsInitialLength();
55565: 
55565:     JS_ASSERT(!(flags_ & ~(JSFRAME_FUNCTION |
55565:                            JSFRAME_OVERFLOW_ARGS |
55565:                            JSFRAME_UNDERFLOW_ARGS |
55565:                            JSFRAME_HAS_CALL_OBJ |
55565:                            JSFRAME_HAS_ARGS_OBJ |
55565:                            JSFRAME_OVERRIDE_ARGS |
55565:                            JSFRAME_HAS_PREVPC |
55565:                            JSFRAME_HAS_RVAL |
55565:                            JSFRAME_HAS_SCOPECHAIN |
55565:                            JSFRAME_HAS_ANNOTATION |
56201:                            JSFRAME_FINISHED_IN_INTERPRETER)));
55565:     flags_ &= JSFRAME_FUNCTION |
55565:               JSFRAME_OVERFLOW_ARGS |
55565:               JSFRAME_HAS_PREVPC |
55565:               JSFRAME_UNDERFLOW_ARGS;
55565: 
55565:     JS_ASSERT_IF(!hasCallObj(), scopeChain_ == calleeValue().toObject().getParent());
55565:     JS_ASSERT_IF(hasCallObj(), scopeChain_ == callObj().getParent());
55565:     if (hasCallObj())
55565:         scopeChain_ = callObj().getParent();
55565: 
55565:     JS_ASSERT(exec.fun == calleeValue().toObject().getFunctionPrivate());
55565:     JS_ASSERT(!hasImacropc());
55565:     JS_ASSERT(!hasHookData());
55565:     JS_ASSERT(annotation() == NULL);
55565:     JS_ASSERT(!hasCallObj());
55565: }
55565: 
55565: inline void
57715: JSStackFrame::initCallFrameCallerHalf(JSContext *cx, uint32 flagsArg,
57715:                                       void *ncode)
53840: {
53840:     JS_ASSERT((flagsArg & ~(JSFRAME_CONSTRUCTING |
53840:                             JSFRAME_FUNCTION |
53840:                             JSFRAME_OVERFLOW_ARGS |
53840:                             JSFRAME_UNDERFLOW_ARGS)) == 0);
53840: 
53840:     flags_ = JSFRAME_FUNCTION | flagsArg;
57715:     prev_ = cx->regs->fp;
57715:     ncode_ = ncode;
53840: }
53840: 
53840: /*
53840:  * The "early prologue" refers to the members that are stored for the benefit
53840:  * of slow paths before initializing the rest of the members.
53840:  */
53840: inline void
57715: JSStackFrame::initCallFrameEarlyPrologue(JSFunction *fun, uint32 nactual)
53840: {
53840:     exec.fun = fun;
57715:     if (flags_ & (JSFRAME_OVERFLOW_ARGS | JSFRAME_UNDERFLOW_ARGS))
57715:         args.nactual = nactual;
53840: }
53840: 
53840: /*
53840:  * The "late prologue" refers to the members that are stored after having
53840:  * checked for stack overflow and formal/actual arg mismatch.
53840:  */
53840: inline void
53840: JSStackFrame::initCallFrameLatePrologue()
53840: {
53840:     SetValueRangeToUndefined(slots(), script()->nfixed);
53840: }
53840: 
53840: inline void
55517: JSStackFrame::initEvalFrame(JSContext *cx, JSScript *script, JSStackFrame *prev, uint32 flagsArg)
53840: {
53840:     JS_ASSERT(flagsArg & JSFRAME_EVAL);
53840:     JS_ASSERT((flagsArg & ~(JSFRAME_EVAL | JSFRAME_DEBUGGER)) == 0);
54832:     JS_ASSERT(prev->flags_ & (JSFRAME_FUNCTION | JSFRAME_GLOBAL));
53840: 
53840:     /* Copy (callee, thisv). */
53840:     js::Value *dstvp = (js::Value *)this - 2;
54832:     js::Value *srcvp = prev->flags_ & (JSFRAME_GLOBAL | JSFRAME_EVAL)
54832:                        ? (js::Value *)prev - 2
54832:                        : prev->formalArgs() - 2;
53840:     dstvp[0] = srcvp[0];
53840:     dstvp[1] = srcvp[1];
54832:     JS_ASSERT_IF(prev->flags_ & JSFRAME_FUNCTION,
53840:                  dstvp[0].toObject().isFunction());
53840: 
53840:     /* Initialize stack frame members. */
55483:     flags_ = flagsArg | JSFRAME_HAS_PREVPC | JSFRAME_HAS_SCOPECHAIN |
54832:              (prev->flags_ & (JSFRAME_FUNCTION |
53840:                               JSFRAME_GLOBAL |
53840:                               JSFRAME_HAS_CALL_OBJ));
53840:     if (isFunctionFrame()) {
54832:         exec = prev->exec;
53840:         args.script = script;
53840:     } else {
53840:         exec.script = script;
53840:     }
55517: 
54832:     scopeChain_ = &prev->scopeChain();
54832:     JS_ASSERT_IF(isFunctionFrame(), &callObj() == &prev->callObj());
54832: 
55517:     prev_ = prev;
55517:     prevpc_ = prev->pc(cx);
53840:     JS_ASSERT(!hasImacropc());
53840:     JS_ASSERT(!hasHookData());
54832:     setAnnotation(prev->annotation());
53840: }
53840: 
53840: inline void
53840: JSStackFrame::initGlobalFrame(JSScript *script, JSObject &chain, uint32 flagsArg)
53840: {
53840:     JS_ASSERT((flagsArg & ~(JSFRAME_EVAL | JSFRAME_DEBUGGER)) == 0);
53840: 
53840:     /* Initialize (callee, thisv). */
53840:     js::Value *vp = (js::Value *)this - 2;
53840:     vp[0].setUndefined();
53840:     vp[1].setUndefined();  /* Set after frame pushed using thisObject */
53840: 
53840:     /* Initialize stack frame members. */
55483:     flags_ = flagsArg | JSFRAME_GLOBAL | JSFRAME_HAS_PREVPC | JSFRAME_HAS_SCOPECHAIN;
53840:     exec.script = script;
53840:     args.script = (JSScript *)0xbad;
53840:     scopeChain_ = &chain;
53840:     prev_ = NULL;
53840:     JS_ASSERT(!hasImacropc());
53840:     JS_ASSERT(!hasHookData());
53840:     JS_ASSERT(annotation() == NULL);
53840: }
53840: 
53840: inline void
53840: JSStackFrame::initDummyFrame(JSContext *cx, JSObject &chain)
53840: {
53840:     js::PodZero(this);
55483:     flags_ = JSFRAME_DUMMY | JSFRAME_HAS_PREVPC | JSFRAME_HAS_SCOPECHAIN;
55517:     initPrev(cx);
53840:     chain.isGlobal();
53840:     setScopeChainNoCallObj(chain);
53840: }
53840: 
53840: inline void
53840: JSStackFrame::stealFrameAndSlots(js::Value *vp, JSStackFrame *otherfp,
53840:                                  js::Value *othervp, js::Value *othersp)
53840: {
53840:     JS_ASSERT(vp == (js::Value *)this - (otherfp->formalArgsEnd() - othervp));
53840:     JS_ASSERT(othervp == otherfp->actualArgs() - 2);
53840:     JS_ASSERT(othersp >= otherfp->slots());
53840:     JS_ASSERT(othersp <= otherfp->base() + otherfp->numSlots());
53840: 
53840:     size_t nbytes = (othersp - othervp) * sizeof(js::Value);
53840:     memcpy(vp, othervp, nbytes);
53840:     JS_ASSERT(vp == actualArgs() - 2);
53840: 
53840:     /*
53840:      * Repoint Call, Arguments, Block and With objects to the new live frame.
53840:      * Call and Arguments are done directly because we have pointers to them.
53840:      * Block and With objects are done indirectly through 'liveFrame'. See
53840:      * js_LiveFrameToFloating comment in jsiter.h.
53840:      */
53840:     if (hasCallObj()) {
53840:         callObj().setPrivate(this);
53840:         otherfp->flags_ &= ~JSFRAME_HAS_CALL_OBJ;
56201:         if (js_IsNamedLambda(fun())) {
56201:             JSObject *env = callObj().getParent();
56201:             JS_ASSERT(env->getClass() == &js_DeclEnvClass);
56201:             env->setPrivate(this);
56201:         }
53840:     }
53840:     if (hasArgsObj()) {
53840:         argsObj().setPrivate(this);
53840:         otherfp->flags_ &= ~JSFRAME_HAS_ARGS_OBJ;
53840:     }
53840: }
53840: 
53840: inline js::Value &
53840: JSStackFrame::canonicalActualArg(uintN i) const
53840: {
53840:     if (i < numFormalArgs())
53840:         return formalArg(i);
53840:     JS_ASSERT(i < numActualArgs());
53840:     return actualArgs()[i];
53840: }
53840: 
53840: template <class Op>
53840: inline void
53840: JSStackFrame::forEachCanonicalActualArg(Op op)
53840: {
53840:     uintN nformal = fun()->nargs;
53840:     js::Value *formals = formalArgsEnd() - nformal;
53840:     uintN nactual = numActualArgs();
53840:     if (nactual <= nformal) {
53840:         uintN i = 0;
53840:         js::Value *actualsEnd = formals + nactual;
53840:         for (js::Value *p = formals; p != actualsEnd; ++p, ++i)
53840:             op(i, p);
53840:     } else {
53840:         uintN i = 0;
53840:         js::Value *formalsEnd = formalArgsEnd();
53840:         for (js::Value *p = formals; p != formalsEnd; ++p, ++i)
53840:             op(i, p);
53840:         js::Value *actuals = formalsEnd - (nactual + 2);
53840:         js::Value *actualsEnd = formals - 2;
53840:         for (js::Value *p = actuals; p != actualsEnd; ++p, ++i)
53840:             op(i, p);
53840:     }
53840: }
53840: 
53840: template <class Op>
53840: inline void
53840: JSStackFrame::forEachFormalArg(Op op)
53840: {
53840:     js::Value *formals = formalArgsEnd() - fun()->nargs;
53840:     js::Value *formalsEnd = formalArgsEnd();
53840:     uintN i = 0;
53840:     for (js::Value *p = formals; p != formalsEnd; ++p, ++i)
53840:         op(i, p);
53840: }
53840: 
57718: namespace js {
57718: 
57718: struct STATIC_SKIP_INFERENCE CopyNonHoleArgsTo
57718: {
57718:     CopyNonHoleArgsTo(JSObject *aobj, Value *dst) : aobj(aobj), dst(dst) {}
57718:     JSObject *aobj;
57718:     Value *dst;
57718:     void operator()(uintN argi, Value *src) {
57718:         if (aobj->getArgsElement(argi).isMagic(JS_ARGS_HOLE))
57718:             dst->setUndefined();
57718:         else
57718:             *dst = *src;
57718:         ++dst;
57718:     }
57718: };
57718: 
57718: struct CopyTo
57718: {
57718:     Value *dst;
57718:     CopyTo(Value *dst) : dst(dst) {}
57718:     void operator()(uintN, Value *src) {
57718:         *dst++ = *src;
57718:     }
57718: };
57718: 
57718: }
57718: 
55565: JS_ALWAYS_INLINE void
55565: JSStackFrame::clearMissingArgs()
55565: {
55565:     if (flags_ & JSFRAME_UNDERFLOW_ARGS)
55565:         SetValueRangeToUndefined(formalArgs() + numActualArgs(), formalArgsEnd());
55565: }
55565: 
55713: inline bool
55713: JSStackFrame::computeThis(JSContext *cx)
53840: {
53840:     js::Value &thisv = thisValue();
55713:     if (thisv.isObject())
55713:         return true;
55713:     if (isFunctionFrame()) {
55713:         if (fun()->acceptsPrimitiveThis())
55713:             return true;
55713:         /*
55713:          * Eval function frames have their own |this| slot, which is a copy of the function's
55713:          * |this| slot. If we lazily wrap a primitive |this| in an eval function frame, the
55713:          * eval's frame will get the wrapper, but the function's frame will not. To prevent
55713:          * this, we always wrap a function's |this| before pushing an eval frame, and should
55713:          * thus never see an unwrapped primitive in a non-strict eval function frame.
55713:          */
55713:         JS_ASSERT(!isEvalFrame());
55713:     }
53840:     if (!js::ComputeThisFromArgv(cx, &thisv + 1))
53840:         return NULL;
53840:     JS_ASSERT(IsSaneThisObject(thisv.toObject()));
53840:     return &thisv.toObject();
53840: }
53840: 
53840: inline JSObject &
53840: JSStackFrame::varobj(js::StackSegment *seg) const
53840: {
53840:     JS_ASSERT(seg->contains(this));
53840:     return isFunctionFrame() ? callObj() : seg->getInitialVarObj();
53840: }
53840: 
53840: inline JSObject &
53840: JSStackFrame::varobj(JSContext *cx) const
53840: {
53840:     JS_ASSERT(cx->activeSegment()->contains(this));
53840:     return isFunctionFrame() ? callObj() : cx->activeSegment()->getInitialVarObj();
53840: }
53840: 
53840: inline uintN
53840: JSStackFrame::numActualArgs() const
53840: {
55516:     JS_ASSERT(hasArgs());
53840:     if (JS_UNLIKELY(flags_ & (JSFRAME_OVERFLOW_ARGS | JSFRAME_UNDERFLOW_ARGS)))
53840:         return hasArgsObj() ? argsObj().getArgsInitialLength() : args.nactual;
53840:     return numFormalArgs();
53840: }
53840: 
53840: inline js::Value *
53840: JSStackFrame::actualArgs() const
53840: {
55516:     JS_ASSERT(hasArgs());
55516:     js::Value *argv = formalArgs();
53840:     if (JS_UNLIKELY(flags_ & JSFRAME_OVERFLOW_ARGS)) {
53840:         uintN nactual = hasArgsObj() ? argsObj().getArgsInitialLength() : args.nactual;
53840:         return argv - (2 + nactual);
53840:     }
53840:     return argv;
53840: }
53840: 
53840: inline js::Value *
53840: JSStackFrame::actualArgsEnd() const
53840: {
55516:     JS_ASSERT(hasArgs());
53840:     if (JS_UNLIKELY(flags_ & JSFRAME_OVERFLOW_ARGS))
55516:         return formalArgs() - 2;
55516:     return formalArgs() + numActualArgs();
53840: }
53840: 
53840: inline void
53840: JSStackFrame::setArgsObj(JSObject &obj)
53840: {
53840:     JS_ASSERT_IF(hasArgsObj(), &obj == args.obj);
53840:     JS_ASSERT_IF(!hasArgsObj(), numActualArgs() == obj.getArgsInitialLength());
53840:     args.obj = &obj;
53840:     flags_ |= JSFRAME_HAS_ARGS_OBJ;
53840: }
53840: 
53840: inline void
54832: JSStackFrame::clearArgsObj()
54832: {
54832:     JS_ASSERT(hasArgsObj());
54832:     args.nactual = args.obj->getArgsInitialLength();
54832:     flags_ ^= JSFRAME_HAS_ARGS_OBJ;
54832: }
54832: 
54832: inline void
53840: JSStackFrame::setScopeChainNoCallObj(JSObject &obj)
53840: {
53840: #ifdef DEBUG
53840:     JS_ASSERT(&obj != NULL);
53840:     JSObject *callObjBefore = maybeCallObj();
55483:     if (!hasCallObj() && &scopeChain() != sInvalidScopeChain) {
55483:         for (JSObject *pobj = &scopeChain(); pobj; pobj = pobj->getParent())
53840:             JS_ASSERT_IF(pobj->isCall(), pobj->getPrivate() != this);
53840:     }
53840: #endif
53840:     scopeChain_ = &obj;
55483:     flags_ |= JSFRAME_HAS_SCOPECHAIN;
53840:     JS_ASSERT(callObjBefore == maybeCallObj());
53840: }
53840: 
53840: inline void
53840: JSStackFrame::setScopeChainAndCallObj(JSObject &obj)
53840: {
53840:     JS_ASSERT(&obj != NULL);
53840:     JS_ASSERT(!hasCallObj() && obj.isCall() && obj.getPrivate() == this);
53840:     scopeChain_ = &obj;
55483:     flags_ |= JSFRAME_HAS_SCOPECHAIN | JSFRAME_HAS_CALL_OBJ;
53840: }
53840: 
54832: inline void
54832: JSStackFrame::clearCallObj()
54832: {
54832:     JS_ASSERT(hasCallObj());
54832:     flags_ ^= JSFRAME_HAS_CALL_OBJ;
54832: }
54832: 
53840: inline JSObject &
53840: JSStackFrame::callObj() const
53840: {
53840:     JS_ASSERT(hasCallObj());
53840:     JSObject *pobj = &scopeChain();
53840:     while (JS_UNLIKELY(pobj->getClass() != &js_CallClass)) {
53840:         JS_ASSERT(js_IsCacheableNonGlobalScope(pobj) || pobj->isWith());
53840:         pobj = pobj->getParent();
53840:     }
53840:     return *pobj;
53840: }
53840: 
53840: inline JSObject *
53840: JSStackFrame::maybeCallObj() const
53840: {
53840:     return hasCallObj() ? &callObj() : NULL;
53840: }
53840: 
53840: namespace js {
53840: 
55565: class AutoPreserveEnumerators {
55565:     JSContext *cx;
55565:     JSObject *enumerators;
55565: 
55565:   public:
55565:     AutoPreserveEnumerators(JSContext *cx) : cx(cx), enumerators(cx->enumerators)
55565:     {
55565:     }
55565: 
55565:     ~AutoPreserveEnumerators()
55565:     {
55565:         cx->enumerators = enumerators;
55565:     }
55565: };
55565: 
55565: struct AutoInterpPreparer  {
55565:     JSContext *cx;
55565:     JSScript *script;
55565: 
55565:     AutoInterpPreparer(JSContext *cx, JSScript *script)
55565:       : cx(cx), script(script)
55565:     {
55565:         cx->interpLevel++;
55565:     }
55565: 
55565:     ~AutoInterpPreparer()
55565:     {
55565:         --cx->interpLevel;
55565:     }
55565: };
55565: 
53840: inline void
53840: PutActivationObjects(JSContext *cx, JSStackFrame *fp)
53840: {
53840:     JS_ASSERT(fp->isFunctionFrame() && !fp->isEvalFrame());
53840: 
53840:     /* The order is important as js_PutCallObject needs to access argsObj. */
53840:     if (fp->hasCallObj()) {
53840:         js_PutCallObject(cx, fp);
53840:     } else if (fp->hasArgsObj()) {
53840:         js_PutArgsObject(cx, fp);
53840:     }
53840: }
53840: 
55565: class InvokeSessionGuard
55565: {
55565:     InvokeArgsGuard args_;
55565:     InvokeFrameGuard frame_;
56749:     Value savedCallee_, savedThis_;
55565:     Value *formals_, *actuals_;
55565:     unsigned nformals_;
55565:     JSScript *script_;
55565:     void *code_;
55565:     Value *stackLimit_;
55565:     jsbytecode *stop_;
55565: 
55565:     bool optimized() const { return frame_.pushed(); }
55565: 
55565:   public:
55565:     InvokeSessionGuard() : args_(), frame_() {}
55565:     ~InvokeSessionGuard() {}
55565: 
55565:     bool start(JSContext *cx, const Value &callee, const Value &thisv, uintN argc);
55565:     bool invoke(JSContext *cx) const;
55565: 
55565:     bool started() const {
55565:         return args_.pushed();
55565:     }
55565: 
55565:     Value &operator[](unsigned i) const {
55565:         JS_ASSERT(i < argc());
55565:         Value &arg = i < nformals_ ? formals_[i] : actuals_[i];
55565:         JS_ASSERT_IF(optimized(), &arg == &frame_.fp()->canonicalActualArg(i));
55565:         JS_ASSERT_IF(!optimized(), &arg == &args_[i]);
55565:         return arg;
55565:     }
55565: 
55565:     uintN argc() const {
55565:         return args_.argc();
55565:     }
55565: 
55565:     const Value &rval() const {
55565:         return optimized() ? frame_.fp()->returnValue() : args_.rval();
55565:     }
55565: };
55565: 
55565: inline bool
55565: InvokeSessionGuard::invoke(JSContext *cx) const
55565: {
55565:     /* N.B. Must be kept in sync with Invoke */
55565: 
56749:     /* Refer to canonical (callee, this) for optimized() sessions. */
56749:     formals_[-2] = savedCallee_;
56749:     formals_[-1] = savedThis_;
56749: 
56749:     if (!optimized())
55565:         return Invoke(cx, args_, 0);
55565: 
55565:     /* Clear any garbage left from the last Invoke. */
55565:     JSStackFrame *fp = frame_.fp();
55565:     fp->clearMissingArgs();
55565:     fp->resetInvokeCallFrame();
55565:     SetValueRangeToUndefined(fp->slots(), script_->nfixed);
55565: 
55565:     JSBool ok;
55565:     {
55565:         AutoPreserveEnumerators preserve(cx);
57757:         Probes::enterJSFun(cx, fp->fun(), script_);
55565: #ifdef JS_METHODJIT
57831:         if (code_ != script_->getJIT(fp->isConstructing())->invokeEntry)
57831:             *(volatile int *)0x101 = 0;
57831: 
55565:         AutoInterpPreparer prepareInterp(cx, script_);
55565:         ok = mjit::EnterMethodJIT(cx, fp, code_, stackLimit_);
55565:         cx->regs->pc = stop_;
55565: #else
55565:         cx->regs->pc = script_->code;
55565:         ok = Interpret(cx, cx->fp());
55565: #endif
57757:         Probes::exitJSFun(cx, fp->fun(), script_);
55565:     }
55565: 
55565:     PutActivationObjects(cx, fp);
55565: 
55565:     /* Don't clobber callee with rval; rval gets read from fp->rval. */
55565:     return ok;
55565: }
55565: 
55711: namespace detail {
55711: 
55711: template<typename T> class PrimitiveBehavior { };
55711: 
55711: template<>
55711: class PrimitiveBehavior<JSString *> {
55711:   public:
55711:     static inline bool isType(const Value &v) { return v.isString(); }
55711:     static inline JSString *extract(const Value &v) { return v.toString(); }
55711:     static inline Class *getClass() { return &js_StringClass; }
55711: };
55711: 
55711: template<>
55711: class PrimitiveBehavior<bool> {
55711:   public:
55711:     static inline bool isType(const Value &v) { return v.isBoolean(); }
55711:     static inline bool extract(const Value &v) { return v.toBoolean(); }
55711:     static inline Class *getClass() { return &js_BooleanClass; }
55711: };
55711: 
55711: template<>
55711: class PrimitiveBehavior<double> {
55711:   public:
55711:     static inline bool isType(const Value &v) { return v.isNumber(); }
55711:     static inline double extract(const Value &v) { return v.toNumber(); }
55711:     static inline Class *getClass() { return &js_NumberClass; }
55711: };
55711: 
55711: } // namespace detail
55711: 
55711: template <typename T>
55711: bool
55711: GetPrimitiveThis(JSContext *cx, Value *vp, T *v)
55711: {
55711:     typedef detail::PrimitiveBehavior<T> Behavior;
55711: 
55711:     const Value &thisv = vp[1];
55711:     if (Behavior::isType(thisv)) {
55711:         *v = Behavior::extract(thisv);
55711:         return true;
55711:     }
55711: 
55711:     if (thisv.isObjectOrNull()) {
55711:         JSObject *obj = thisv.toObjectOrNull();
55711:         if (!obj || obj->getClass() != Behavior::getClass()) {
55711:             obj = ComputeThisFromVp(cx, vp);
55711:             if (!InstanceOf(cx, obj, Behavior::getClass(), vp + 2))
55711:                 return false;
55711:         }
55711:         *v = Behavior::extract(thisv.toObject().getPrimitiveThis());
55711:         return true;
55711:     }
55711: 
55750:     ReportIncompatibleMethod(cx, vp, Behavior::getClass());
55750:     return false;
55711: }
55711: 
55713: /*
55713:  * Return an object on which we should look for the properties of |value|.
55713:  * This helps us implement the custom [[Get]] method that ES5's GetValue
55713:  * algorithm uses for primitive values, without actually constructing the
55713:  * temporary object that the specification does.
55713:  * 
55713:  * For objects, return the object itself. For string, boolean, and number
55713:  * primitive values, return the appropriate constructor's prototype. For
55713:  * undefined and null, throw an error and return NULL, attributing the
55713:  * problem to the value at |spindex| on the stack.
55713:  */
55713: JS_ALWAYS_INLINE JSObject *
55713: ValuePropertyBearer(JSContext *cx, const Value &v, int spindex)
55713: {
55713:     if (v.isObject())
55713:         return &v.toObject();
55713: 
55713:     JSProtoKey protoKey;
55713:     if (v.isString()) {
55713:         protoKey = JSProto_String;
55713:     } else if (v.isNumber()) {
55713:         protoKey = JSProto_Number;
55713:     } else if (v.isBoolean()) {
55713:         protoKey = JSProto_Boolean;
55713:     } else {
55713:         JS_ASSERT(v.isNull() || v.isUndefined());
55713:         js_ReportIsNullOrUndefined(cx, spindex, v, NULL);
55713:         return NULL;
55713:     }
55713: 
55713:     JSObject *pobj;
55713:     if (!js_GetClassPrototype(cx, NULL, protoKey, &pobj))
55713:         return NULL;
55713:     return pobj;
55713: }
55713: 
56201: static inline bool
56201: ScriptEpilogue(JSContext *cx, JSStackFrame *fp, JSBool ok)
56201: {
57757:     if (!fp->isExecuteFrame())
57757:         Probes::exitJSFun(cx, fp->maybeFun(), fp->maybeScript());
57757: 
56201:     JSInterpreterHook hook = cx->debugHooks->callHook;
57830:     void* hookData;
57830: 
57830:     if (hook && (hookData = fp->maybeHookData()) && !fp->isExecuteFrame())
57830:         hook(cx, fp, JS_FALSE, &ok, hookData);
56201: 
56201:     /*
56201:      * An eval frame's parent owns its activation objects. A yielding frame's
56201:      * activation objects are transferred to the floating frame, stored in the
56201:      * generator.
56201:      */
56201:     if (fp->isFunctionFrame() && !fp->isEvalFrame() && !fp->isYielding())
56201:         PutActivationObjects(cx, fp);
56201: 
56201:     /*
56201:      * If inline-constructing, replace primitive rval with the new object
56201:      * passed in via |this|, and instrument this constructor invocation.
56201:      */
56201:     if (fp->isConstructing()) {
56201:         if (fp->returnValue().isPrimitive())
56201:             fp->setReturnValue(ObjectValue(fp->constructorThis()));
56201:         JS_RUNTIME_METER(cx->runtime, constructs);
56201:     }
56201: 
56201:     return ok;
56201: }
56201: 
53840: }
53840: 
53840: #endif /* jsinterpinlines_h__ */
