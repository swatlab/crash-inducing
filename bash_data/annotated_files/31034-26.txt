16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: basic codebook pack/unpack/code/decode operations
31034:  last mod: $Id: codebook.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: #include <stdlib.h>
16295: #include <string.h>
16295: #include <math.h>
16295: #include <ogg/ogg.h>
16295: #include "vorbis/codec.h"
16295: #include "codebook.h"
16295: #include "scales.h"
16295: #include "misc.h"
16295: #include "os.h"
16295: 
16295: /* packs the given codebook into the bitstream **************************/
16295: 
16295: int vorbis_staticbook_pack(const static_codebook *c,oggpack_buffer *opb){
16295:   long i,j;
16295:   int ordered=0;
16295: 
16295:   /* first the basic parameters */
16295:   oggpack_write(opb,0x564342,24);
16295:   oggpack_write(opb,c->dim,16);
16295:   oggpack_write(opb,c->entries,24);
16295: 
16295:   /* pack the codewords.  There are two packings; length ordered and
16295:      length random.  Decide between the two now. */
16295: 
16295:   for(i=1;i<c->entries;i++)
16295:     if(c->lengthlist[i-1]==0 || c->lengthlist[i]<c->lengthlist[i-1])break;
16295:   if(i==c->entries)ordered=1;
16295: 
16295:   if(ordered){
16295:     /* length ordered.  We only need to say how many codewords of
16295:        each length.  The actual codewords are generated
16295:        deterministically */
16295: 
16295:     long count=0;
16295:     oggpack_write(opb,1,1);  /* ordered */
16295:     oggpack_write(opb,c->lengthlist[0]-1,5); /* 1 to 32 */
16295: 
16295:     for(i=1;i<c->entries;i++){
16295:       long this=c->lengthlist[i];
16295:       long last=c->lengthlist[i-1];
16295:       if(this>last){
16295:         for(j=last;j<this;j++){
16295:           oggpack_write(opb,i-count,_ilog(c->entries-count));
16295:           count=i;
16295:         }
16295:       }
16295:     }
16295:     oggpack_write(opb,i-count,_ilog(c->entries-count));
16295: 
16295:   }else{
16295:     /* length random.  Again, we don't code the codeword itself, just
16295:        the length.  This time, though, we have to encode each length */
16295:     oggpack_write(opb,0,1);   /* unordered */
16295: 
16295:     /* algortihmic mapping has use for 'unused entries', which we tag
16295:        here.  The algorithmic mapping happens as usual, but the unused
16295:        entry has no codeword. */
16295:     for(i=0;i<c->entries;i++)
16295:       if(c->lengthlist[i]==0)break;
16295: 
16295:     if(i==c->entries){
16295:       oggpack_write(opb,0,1); /* no unused entries */
16295:       for(i=0;i<c->entries;i++)
16295:         oggpack_write(opb,c->lengthlist[i]-1,5);
16295:     }else{
16295:       oggpack_write(opb,1,1); /* we have unused entries; thus we tag */
16295:       for(i=0;i<c->entries;i++){
16295:         if(c->lengthlist[i]==0){
16295:           oggpack_write(opb,0,1);
16295:         }else{
16295:           oggpack_write(opb,1,1);
16295:           oggpack_write(opb,c->lengthlist[i]-1,5);
16295:         }
16295:       }
16295:     }
16295:   }
16295: 
16295:   /* is the entry number the desired return value, or do we have a
16295:      mapping? If we have a mapping, what type? */
16295:   oggpack_write(opb,c->maptype,4);
16295:   switch(c->maptype){
16295:   case 0:
16295:     /* no mapping */
16295:     break;
16295:   case 1:case 2:
16295:     /* implicitly populated value mapping */
16295:     /* explicitly populated value mapping */
16295: 
16295:     if(!c->quantlist){
16295:       /* no quantlist?  error */
16295:       return(-1);
16295:     }
16295: 
16295:     /* values that define the dequantization */
16295:     oggpack_write(opb,c->q_min,32);
16295:     oggpack_write(opb,c->q_delta,32);
16295:     oggpack_write(opb,c->q_quant-1,4);
16295:     oggpack_write(opb,c->q_sequencep,1);
16295: 
16295:     {
16295:       int quantvals;
16295:       switch(c->maptype){
16295:       case 1:
16295:         /* a single column of (c->entries/c->dim) quantized values for
16295:            building a full value list algorithmically (square lattice) */
16295:         quantvals=_book_maptype1_quantvals(c);
16295:         break;
16295:       case 2:
16295:         /* every value (c->entries*c->dim total) specified explicitly */
16295:         quantvals=c->entries*c->dim;
16295:         break;
16295:       default: /* NOT_REACHABLE */
16295:         quantvals=-1;
16295:       }
16295: 
16295:       /* quantized values */
16295:       for(i=0;i<quantvals;i++)
16295:         oggpack_write(opb,labs(c->quantlist[i]),c->q_quant);
16295: 
16295:     }
16295:     break;
16295:   default:
16295:     /* error case; we don't have any other map types now */
16295:     return(-1);
16295:   }
16295: 
16295:   return(0);
16295: }
16295: 
16295: /* unpacks a codebook from the packet buffer into the codebook struct,
16295:    readies the codebook auxiliary structures for decode *************/
16295: int vorbis_staticbook_unpack(oggpack_buffer *opb,static_codebook *s){
16295:   long i,j;
16295:   memset(s,0,sizeof(*s));
16295:   s->allocedp=1;
16295: 
16295:   /* make sure alignment is correct */
16295:   if(oggpack_read(opb,24)!=0x564342)goto _eofout;
16295: 
16295:   /* first the basic parameters */
16295:   s->dim=oggpack_read(opb,16);
16295:   s->entries=oggpack_read(opb,24);
16295:   if(s->entries==-1)goto _eofout;
16295: 
30043:   if(_ilog(s->dim)+_ilog(s->entries)>24)goto _eofout;
30043: 
16295:   /* codeword ordering.... length ordered or unordered? */
16295:   switch((int)oggpack_read(opb,1)){
16295:   case 0:
16295:     /* unordered */
16295:     s->lengthlist=_ogg_malloc(sizeof(*s->lengthlist)*s->entries);
16295: 
16295:     /* allocated but unused entries? */
16295:     if(oggpack_read(opb,1)){
16295:       /* yes, unused entries */
16295: 
16295:       for(i=0;i<s->entries;i++){
16295:         if(oggpack_read(opb,1)){
16295:           long num=oggpack_read(opb,5);
16295:           if(num==-1)goto _eofout;
16295:           s->lengthlist[i]=num+1;
16295:         }else
16295:           s->lengthlist[i]=0;
16295:       }
16295:     }else{
16295:       /* all entries used; no tagging */
16295:       for(i=0;i<s->entries;i++){
16295:         long num=oggpack_read(opb,5);
16295:         if(num==-1)goto _eofout;
16295:         s->lengthlist[i]=num+1;
16295:       }
16295:     }
16295: 
16295:     break;
16295:   case 1:
16295:     /* ordered */
16295:     {
16295:       long length=oggpack_read(opb,5)+1;
16295:       s->lengthlist=_ogg_malloc(sizeof(*s->lengthlist)*s->entries);
16295: 
16295:       for(i=0;i<s->entries;){
16295:         long num=oggpack_read(opb,_ilog(s->entries-i));
16295:         if(num==-1)goto _eofout;
16295:         for(j=0;j<num && i<s->entries;j++,i++)
16295:           s->lengthlist[i]=length;
16295:         length++;
16295:       }
16295:     }
16295:     break;
16295:   default:
16295:     /* EOF */
16295:     return(-1);
16295:   }
16295: 
16295:   /* Do we have a mapping to unpack? */
16295:   switch((s->maptype=oggpack_read(opb,4))){
16295:   case 0:
16295:     /* no mapping */
16295:     break;
16295:   case 1: case 2:
16295:     /* implicitly populated value mapping */
16295:     /* explicitly populated value mapping */
16295: 
16295:     s->q_min=oggpack_read(opb,32);
16295:     s->q_delta=oggpack_read(opb,32);
16295:     s->q_quant=oggpack_read(opb,4)+1;
16295:     s->q_sequencep=oggpack_read(opb,1);
31034:     if(s->q_sequencep==-1)goto _eofout;
16295: 
16295:     {
16295:       int quantvals=0;
16295:       switch(s->maptype){
16295:       case 1:
30043:         quantvals=(s->dim==0?0:_book_maptype1_quantvals(s));
16295:         break;
16295:       case 2:
16295:         quantvals=s->entries*s->dim;
16295:         break;
16295:       }
16295: 
16295:       /* quantized values */
16295:       s->quantlist=_ogg_malloc(sizeof(*s->quantlist)*quantvals);
16295:       for(i=0;i<quantvals;i++)
16295:         s->quantlist[i]=oggpack_read(opb,s->q_quant);
16295: 
16295:       if(quantvals&&s->quantlist[quantvals-1]==-1)goto _eofout;
16295:     }
16295:     break;
16295:   default:
16295:     goto _errout;
16295:   }
16295: 
16295:   /* all set */
16295:   return(0);
16295: 
16295:  _errout:
16295:  _eofout:
16295:   vorbis_staticbook_clear(s);
16295:   return(-1);
16295: }
16295: 
16295: /* returns the number of bits ************************************************/
16295: int vorbis_book_encode(codebook *book, int a, oggpack_buffer *b){
16295:   if(a<0 || a>=book->c->entries)return(0);
16295:   oggpack_write(b,book->codelist[a],book->c->lengthlist[a]);
16295:   return(book->c->lengthlist[a]);
16295: }
16295: 
16295: /* One the encode side, our vector writers are each designed for a
16295: specific purpose, and the encoder is not flexible without modification:
16295: 
16295: The LSP vector coder uses a single stage nearest-match with no
16295: interleave, so no step and no error return.  This is specced by floor0
16295: and doesn't change.
16295: 
16295: Residue0 encoding interleaves, uses multiple stages, and each stage
16295: peels of a specific amount of resolution from a lattice (thus we want
16295: to match by threshold, not nearest match).  Residue doesn't *have* to
16295: be encoded that way, but to change it, one will need to add more
16295: infrastructure on the encode side (decode side is specced and simpler) */
16295: 
16295: /* floor0 LSP (single stage, non interleaved, nearest match) */
16295: /* returns entry number and *modifies a* to the quantization value *****/
16295: int vorbis_book_errorv(codebook *book,float *a){
16295:   int dim=book->dim,k;
16295:   int best=_best(book,a,1);
16295:   for(k=0;k<dim;k++)
16295:     a[k]=(book->valuelist+best*dim)[k];
16295:   return(best);
16295: }
16295: 
16295: /* returns the number of bits and *modifies a* to the quantization value *****/
16295: int vorbis_book_encodev(codebook *book,int best,float *a,oggpack_buffer *b){
16295:   int k,dim=book->dim;
16295:   for(k=0;k<dim;k++)
16295:     a[k]=(book->valuelist+best*dim)[k];
16295:   return(vorbis_book_encode(book,best,b));
16295: }
16295: 
16295: /* the 'eliminate the decode tree' optimization actually requires the
16295:    codewords to be MSb first, not LSb.  This is an annoying inelegancy
16295:    (and one of the first places where carefully thought out design
16295:    turned out to be wrong; Vorbis II and future Ogg codecs should go
16295:    to an MSb bitpacker), but not actually the huge hit it appears to
16295:    be.  The first-stage decode table catches most words so that
16295:    bitreverse is not in the main execution path. */
16295: 
16295: static ogg_uint32_t bitreverse(ogg_uint32_t x){
16295:   x=    ((x>>16)&0x0000ffff) | ((x<<16)&0xffff0000);
16295:   x=    ((x>> 8)&0x00ff00ff) | ((x<< 8)&0xff00ff00);
16295:   x=    ((x>> 4)&0x0f0f0f0f) | ((x<< 4)&0xf0f0f0f0);
16295:   x=    ((x>> 2)&0x33333333) | ((x<< 2)&0xcccccccc);
16295:   return((x>> 1)&0x55555555) | ((x<< 1)&0xaaaaaaaa);
16295: }
16295: 
16295: STIN long decode_packed_entry_number(codebook *book, oggpack_buffer *b){
16295:   int  read=book->dec_maxlength;
16295:   long lo,hi;
16295:   long lok = oggpack_look(b,book->dec_firsttablen);
16295: 
16295:   if (lok >= 0) {
16295:     long entry = book->dec_firsttable[lok];
16295:     if(entry&0x80000000UL){
16295:       lo=(entry>>15)&0x7fff;
16295:       hi=book->used_entries-(entry&0x7fff);
16295:     }else{
16295:       oggpack_adv(b, book->dec_codelengths[entry-1]);
16295:       return(entry-1);
16295:     }
16295:   }else{
16295:     lo=0;
16295:     hi=book->used_entries;
16295:   }
16295: 
16295:   lok = oggpack_look(b, read);
16295: 
16295:   while(lok<0 && read>1)
16295:     lok = oggpack_look(b, --read);
16295:   if(lok<0)return -1;
16295: 
16295:   /* bisect search for the codeword in the ordered list */
16295:   {
16295:     ogg_uint32_t testword=bitreverse((ogg_uint32_t)lok);
16295: 
16295:     while(hi-lo>1){
16295:       long p=(hi-lo)>>1;
16295:       long test=book->codelist[lo+p]>testword;
16295:       lo+=p&(test-1);
16295:       hi-=p&(-test);
16295:       }
16295: 
16295:     if(book->dec_codelengths[lo]<=read){
16295:       oggpack_adv(b, book->dec_codelengths[lo]);
16295:       return(lo);
16295:     }
16295:   }
16295: 
16295:   oggpack_adv(b, read);
16295: 
16295:   return(-1);
16295: }
16295: 
16295: /* Decode side is specced and easier, because we don't need to find
16295:    matches using different criteria; we simply read and map.  There are
16295:    two things we need to do 'depending':
16295: 
16295:    We may need to support interleave.  We don't really, but it's
16295:    convenient to do it here rather than rebuild the vector later.
16295: 
16295:    Cascades may be additive or multiplicitive; this is not inherent in
16295:    the codebook, but set in the code using the codebook.  Like
16295:    interleaving, it's easiest to do it here.
16295:    addmul==0 -> declarative (set the value)
16295:    addmul==1 -> additive
16295:    addmul==2 -> multiplicitive */
16295: 
16295: /* returns the [original, not compacted] entry number or -1 on eof *********/
16295: long vorbis_book_decode(codebook *book, oggpack_buffer *b){
16295:   if(book->used_entries>0){
16295:     long packed_entry=decode_packed_entry_number(book,b);
16295:     if(packed_entry>=0)
16295:       return(book->dec_index[packed_entry]);
16295:   }
16295: 
16295:   /* if there's no dec_index, the codebook unpacking isn't collapsed */
16295:   return(-1);
16295: }
16295: 
16295: /* returns 0 on OK or -1 on eof *************************************/
16295: long vorbis_book_decodevs_add(codebook *book,float *a,oggpack_buffer *b,int n){
16295:   if(book->used_entries>0){
16295:     int step=n/book->dim;
16295:     long *entry = alloca(sizeof(*entry)*step);
16295:     float **t = alloca(sizeof(*t)*step);
16295:     int i,j,o;
16295: 
16295:     for (i = 0; i < step; i++) {
16295:       entry[i]=decode_packed_entry_number(book,b);
16295:       if(entry[i]==-1)return(-1);
16295:       t[i] = book->valuelist+entry[i]*book->dim;
16295:     }
16295:     for(i=0,o=0;i<book->dim;i++,o+=step)
16295:       for (j=0;j<step;j++)
16295:         a[o+j]+=t[j][i];
16295:   }
16295:   return(0);
16295: }
16295: 
16295: long vorbis_book_decodev_add(codebook *book,float *a,oggpack_buffer *b,int n){
16295:   if(book->used_entries>0){
16295:     int i,j,entry;
16295:     float *t;
16295: 
16295:     if(book->dim>8){
16295:       for(i=0;i<n;){
16295:         entry = decode_packed_entry_number(book,b);
16295:         if(entry==-1)return(-1);
16295:         t     = book->valuelist+entry*book->dim;
16295:         for (j=0;j<book->dim;)
16295:           a[i++]+=t[j++];
16295:       }
16295:     }else{
16295:       for(i=0;i<n;){
16295:         entry = decode_packed_entry_number(book,b);
16295:         if(entry==-1)return(-1);
16295:         t     = book->valuelist+entry*book->dim;
16295:         j=0;
16295:         switch((int)book->dim){
16295:         case 8:
16295:           a[i++]+=t[j++];
16295:         case 7:
16295:           a[i++]+=t[j++];
16295:         case 6:
16295:           a[i++]+=t[j++];
16295:         case 5:
16295:           a[i++]+=t[j++];
16295:         case 4:
16295:           a[i++]+=t[j++];
16295:         case 3:
16295:           a[i++]+=t[j++];
16295:         case 2:
16295:           a[i++]+=t[j++];
16295:         case 1:
16295:           a[i++]+=t[j++];
16295:         case 0:
16295:           break;
16295:         }
16295:       }
16295:     }
16295:   }
16295:   return(0);
16295: }
16295: 
16295: long vorbis_book_decodev_set(codebook *book,float *a,oggpack_buffer *b,int n){
16295:   if(book->used_entries>0){
16295:     int i,j,entry;
16295:     float *t;
16295: 
16295:     for(i=0;i<n;){
16295:       entry = decode_packed_entry_number(book,b);
16295:       if(entry==-1)return(-1);
16295:       t     = book->valuelist+entry*book->dim;
16295:       for (j=0;j<book->dim;)
16295:         a[i++]=t[j++];
16295:     }
16295:   }else{
16295:     int i,j;
16295: 
16295:     for(i=0;i<n;){
16295:       for (j=0;j<book->dim;)
16295:         a[i++]=0.f;
16295:     }
16295:   }
16295:   return(0);
16295: }
16295: 
16295: long vorbis_book_decodevv_add(codebook *book,float **a,long offset,int ch,
16295:                               oggpack_buffer *b,int n){
16295: 
16295:   long i,j,entry;
16295:   int chptr=0;
16295:   if(book->used_entries>0){
16295:     for(i=offset/ch;i<(offset+n)/ch;){
16295:       entry = decode_packed_entry_number(book,b);
16295:       if(entry==-1)return(-1);
16295:       {
16295:         const float *t = book->valuelist+entry*book->dim;
16295:         for (j=0;j<book->dim;j++){
16295:           a[chptr++][i]+=t[j];
16295:           if(chptr==ch){
16295:             chptr=0;
16295:             i++;
16295:           }
16295:         }
16295:       }
16295:     }
16295:   }
16295:   return(0);
16295: }
16295: 
16295: #ifdef _V_SELFTEST
16295: /* Simple enough; pack a few candidate codebooks, unpack them.  Code a
16295:    number of vectors through (keeping track of the quantized values),
16295:    and decode using the unpacked book.  quantized version of in should
16295:    exactly equal out */
16295: 
16295: #include <stdio.h>
16295: 
16295: #include "vorbis/book/lsp20_0.vqh"
16295: #include "vorbis/book/res0a_13.vqh"
16295: #define TESTSIZE 40
16295: 
16295: float test1[TESTSIZE]={
16295:   0.105939f,
16295:   0.215373f,
16295:   0.429117f,
16295:   0.587974f,
16295: 
16295:   0.181173f,
16295:   0.296583f,
16295:   0.515707f,
16295:   0.715261f,
16295: 
16295:   0.162327f,
16295:   0.263834f,
16295:   0.342876f,
16295:   0.406025f,
16295: 
16295:   0.103571f,
16295:   0.223561f,
16295:   0.368513f,
16295:   0.540313f,
16295: 
16295:   0.136672f,
16295:   0.395882f,
16295:   0.587183f,
16295:   0.652476f,
16295: 
16295:   0.114338f,
16295:   0.417300f,
16295:   0.525486f,
16295:   0.698679f,
16295: 
16295:   0.147492f,
16295:   0.324481f,
16295:   0.643089f,
16295:   0.757582f,
16295: 
16295:   0.139556f,
16295:   0.215795f,
16295:   0.324559f,
16295:   0.399387f,
16295: 
16295:   0.120236f,
16295:   0.267420f,
16295:   0.446940f,
16295:   0.608760f,
16295: 
16295:   0.115587f,
16295:   0.287234f,
16295:   0.571081f,
16295:   0.708603f,
16295: };
16295: 
16295: float test3[TESTSIZE]={
16295:   0,1,-2,3,4,-5,6,7,8,9,
16295:   8,-2,7,-1,4,6,8,3,1,-9,
16295:   10,11,12,13,14,15,26,17,18,19,
16295:   30,-25,-30,-1,-5,-32,4,3,-2,0};
16295: 
16295: static_codebook *testlist[]={&_vq_book_lsp20_0,
16295:                              &_vq_book_res0a_13,NULL};
16295: float   *testvec[]={test1,test3};
16295: 
16295: int main(){
16295:   oggpack_buffer write;
16295:   oggpack_buffer read;
16295:   long ptr=0,i;
16295:   oggpack_writeinit(&write);
16295: 
16295:   fprintf(stderr,"Testing codebook abstraction...:\n");
16295: 
16295:   while(testlist[ptr]){
16295:     codebook c;
16295:     static_codebook s;
16295:     float *qv=alloca(sizeof(*qv)*TESTSIZE);
16295:     float *iv=alloca(sizeof(*iv)*TESTSIZE);
16295:     memcpy(qv,testvec[ptr],sizeof(*qv)*TESTSIZE);
16295:     memset(iv,0,sizeof(*iv)*TESTSIZE);
16295: 
16295:     fprintf(stderr,"\tpacking/coding %ld... ",ptr);
16295: 
16295:     /* pack the codebook, write the testvector */
16295:     oggpack_reset(&write);
16295:     vorbis_book_init_encode(&c,testlist[ptr]); /* get it into memory
16295:                                                   we can write */
16295:     vorbis_staticbook_pack(testlist[ptr],&write);
16295:     fprintf(stderr,"Codebook size %ld bytes... ",oggpack_bytes(&write));
16295:     for(i=0;i<TESTSIZE;i+=c.dim){
16295:       int best=_best(&c,qv+i,1);
16295:       vorbis_book_encodev(&c,best,qv+i,&write);
16295:     }
16295:     vorbis_book_clear(&c);
16295: 
16295:     fprintf(stderr,"OK.\n");
16295:     fprintf(stderr,"\tunpacking/decoding %ld... ",ptr);
16295: 
16295:     /* transfer the write data to a read buffer and unpack/read */
16295:     oggpack_readinit(&read,oggpack_get_buffer(&write),oggpack_bytes(&write));
16295:     if(vorbis_staticbook_unpack(&read,&s)){
16295:       fprintf(stderr,"Error unpacking codebook.\n");
16295:       exit(1);
16295:     }
16295:     if(vorbis_book_init_decode(&c,&s)){
16295:       fprintf(stderr,"Error initializing codebook.\n");
16295:       exit(1);
16295:     }
16295: 
16295:     for(i=0;i<TESTSIZE;i+=c.dim)
16295:       if(vorbis_book_decodev_set(&c,iv+i,&read,c.dim)==-1){
16295:         fprintf(stderr,"Error reading codebook test data (EOP).\n");
16295:         exit(1);
16295:       }
16295:     for(i=0;i<TESTSIZE;i++)
16295:       if(fabs(qv[i]-iv[i])>.000001){
16295:         fprintf(stderr,"read (%g) != written (%g) at position (%ld)\n",
16295:                 iv[i],qv[i],i);
16295:         exit(1);
16295:       }
16295: 
16295:     fprintf(stderr,"OK\n");
16295:     ptr++;
16295:   }
16295: 
16295:   /* The above is the trivial stuff; now try unquantizing a log scale codebook */
16295: 
16295:   exit(0);
16295: }
16295: 
16295: #endif
