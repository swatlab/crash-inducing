29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS debugging API.
    1:  */
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsclist.h"
    1: #include "jsapi.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
 8444: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
 8444: #include "jsparse.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
28997: #include "jsstaticcheck.h"
    1: #include "jsstr.h"
    1: 
30283: #include "jsatominlines.h"
40410: #include "jsobjinlines.h"
35453: #include "jsscopeinlines.h"
30283: 
15453: #include "jsautooplen.h"
15453: 
37741: using namespace js;
37741: 
    1: typedef struct JSTrap {
    1:     JSCList         links;
    1:     JSScript        *script;
    1:     jsbytecode      *pc;
    1:     JSOp            op;
    1:     JSTrapHandler   handler;
    1:     void            *closure;
    1: } JSTrap;
    1: 
    1: #define DBG_LOCK(rt)            JS_ACQUIRE_LOCK((rt)->debuggerLock)
    1: #define DBG_UNLOCK(rt)          JS_RELEASE_LOCK((rt)->debuggerLock)
    1: #define DBG_LOCK_EVAL(rt,expr)  (DBG_LOCK(rt), (expr), DBG_UNLOCK(rt))
    1: 
    1: /*
    1:  * NB: FindTrap must be called with rt->debuggerLock acquired.
    1:  */
    1: static JSTrap *
    1: FindTrap(JSRuntime *rt, JSScript *script, jsbytecode *pc)
    1: {
    1:     JSTrap *trap;
    1: 
    1:     for (trap = (JSTrap *)rt->trapList.next;
18414:          &trap->links != &rt->trapList;
    1:          trap = (JSTrap *)trap->links.next) {
    1:         if (trap->script == script && trap->pc == pc)
    1:             return trap;
    1:     }
    1:     return NULL;
    1: }
    1: 
13496: jsbytecode *
13496: js_UntrapScriptCode(JSContext *cx, JSScript *script)
    1: {
13496:     jsbytecode *code;
13496:     JSRuntime *rt;
    1:     JSTrap *trap;
    1: 
13496:     code = script->code;
13496:     rt = cx->runtime;
13496:     DBG_LOCK(rt);
13496:     for (trap = (JSTrap *)rt->trapList.next;
18414:          &trap->links !=
18414:                 &rt->trapList;
13496:          trap = (JSTrap *)trap->links.next) {
14917:         if (trap->script == script &&
14917:             (size_t)(trap->pc - script->code) < script->length) {
13496:             if (code == script->code) {
14665:                 jssrcnote *sn, *notes;
14665:                 size_t nbytes;
14665: 
14665:                 nbytes = script->length * sizeof(jsbytecode);
32723:                 notes = script->notes();
14665:                 for (sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
14665:                     continue;
14665:                 nbytes += (sn - notes + 1) * sizeof *sn;
14665: 
30851:                 code = (jsbytecode *) cx->malloc(nbytes);
13496:                 if (!code)
13496:                     break;
14665:                 memcpy(code, script->code, nbytes);
26569:                 JS_PURGE_GSN_CACHE(cx);
13496:             }
13496:             code[trap->pc - script->code] = trap->op;
13496:         }
13496:     }
13496:     DBG_UNLOCK(rt);
13496:     return code;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
    1:            JSTrapHandler handler, void *closure)
    1: {
    1:     JSTrap *junk, *trap, *twin;
    1:     JSRuntime *rt;
    1:     uint32 sample;
    1: 
34290:     if (script == JSScript::emptyScript()) {
34290:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage,
34290:                                      NULL, JSMSG_READ_ONLY, "empty script");
34290:         return JS_FALSE;
34290:     }
34290: 
13474:     JS_ASSERT((JSOp) *pc != JSOP_TRAP);
    1:     junk = NULL;
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     trap = FindTrap(rt, script, pc);
    1:     if (trap) {
    1:         JS_ASSERT(trap->script == script && trap->pc == pc);
    1:         JS_ASSERT(*pc == JSOP_TRAP);
    1:     } else {
    1:         sample = rt->debuggerMutations;
    1:         DBG_UNLOCK(rt);
30851:         trap = (JSTrap *) cx->malloc(sizeof *trap);
14790:         if (!trap)
14790:             return JS_FALSE;
14790:         trap->closure = NULL;
    1:         DBG_LOCK(rt);
    1:         twin = (rt->debuggerMutations != sample)
    1:                ? FindTrap(rt, script, pc)
    1:                : NULL;
    1:         if (twin) {
    1:             junk = trap;
    1:             trap = twin;
    1:         } else {
    1:             JS_APPEND_LINK(&trap->links, &rt->trapList);
    1:             ++rt->debuggerMutations;
    1:             trap->script = script;
    1:             trap->pc = pc;
    1:             trap->op = (JSOp)*pc;
    1:             *pc = JSOP_TRAP;
    1:         }
    1:     }
    1:     trap->handler = handler;
    1:     trap->closure = closure;
    1:     DBG_UNLOCK(rt);
35076:     if (junk)
30851:         cx->free(junk);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSOp)
    1: JS_GetTrapOpcode(JSContext *cx, JSScript *script, jsbytecode *pc)
    1: {
11813:     JSRuntime *rt;
    1:     JSTrap *trap;
11813:     JSOp op;
    1: 
11813:     rt = cx->runtime;
11813:     DBG_LOCK(rt);
11813:     trap = FindTrap(rt, script, pc);
11813:     op = trap ? trap->op : (JSOp) *pc;
11813:     DBG_UNLOCK(rt);
11813:     return op;
    1: }
    1: 
    1: static void
    1: DestroyTrapAndUnlock(JSContext *cx, JSTrap *trap)
    1: {
    1:     ++cx->runtime->debuggerMutations;
    1:     JS_REMOVE_LINK(&trap->links);
    1:     *trap->pc = (jsbytecode)trap->op;
    1:     DBG_UNLOCK(cx->runtime);
30851:     cx->free(trap);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
    1:              JSTrapHandler *handlerp, void **closurep)
    1: {
    1:     JSTrap *trap;
    1: 
    1:     DBG_LOCK(cx->runtime);
    1:     trap = FindTrap(cx->runtime, script, pc);
    1:     if (handlerp)
    1:         *handlerp = trap ? trap->handler : NULL;
    1:     if (closurep)
    1:         *closurep = trap ? trap->closure : NULL;
    1:     if (trap)
    1:         DestroyTrapAndUnlock(cx, trap);
    1:     else
    1:         DBG_UNLOCK(cx->runtime);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearScriptTraps(JSContext *cx, JSScript *script)
    1: {
    1:     JSRuntime *rt;
    1:     JSTrap *trap, *next;
    1:     uint32 sample;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (trap = (JSTrap *)rt->trapList.next;
18414:          &trap->links != &rt->trapList;
    1:          trap = next) {
    1:         next = (JSTrap *)trap->links.next;
    1:         if (trap->script == script) {
    1:             sample = rt->debuggerMutations;
    1:             DestroyTrapAndUnlock(cx, trap);
    1:             DBG_LOCK(rt);
    1:             if (rt->debuggerMutations != sample + 1)
    1:                 next = (JSTrap *)rt->trapList.next;
    1:         }
    1:     }
    1:     DBG_UNLOCK(rt);
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_ClearAllTraps(JSContext *cx)
    1: {
    1:     JSRuntime *rt;
    1:     JSTrap *trap, *next;
    1:     uint32 sample;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (trap = (JSTrap *)rt->trapList.next;
18414:          &trap->links != &rt->trapList;
    1:          trap = next) {
    1:         next = (JSTrap *)trap->links.next;
    1:         sample = rt->debuggerMutations;
    1:         DestroyTrapAndUnlock(cx, trap);
    1:         DBG_LOCK(rt);
    1:         if (rt->debuggerMutations != sample + 1)
    1:             next = (JSTrap *)rt->trapList.next;
    1:     }
    1:     DBG_UNLOCK(rt);
    1: }
    1: 
35076: /*
35076:  * NB: js_MarkTraps does not acquire cx->runtime->debuggerLock, since the
35076:  * debugger should never be racing with the GC (i.e., the debugger must
35076:  * respect the request model).
35076:  */
35076: void
35076: js_MarkTraps(JSTracer *trc)
35076: {
35076:     JSRuntime *rt = trc->context->runtime;
35076: 
35076:     for (JSTrap *trap = (JSTrap *) rt->trapList.next;
35076:          &trap->links != &rt->trapList;
35076:          trap = (JSTrap *) trap->links.next) {
35076:         if (trap->closure) {
35076:             JS_SET_TRACING_NAME(trc, "trap->closure");
35076:             js_CallValueTracerIfGCThing(trc, (jsval) trap->closure);
35076:         }
35076:     }
35076: }
35076: 
    1: JS_PUBLIC_API(JSTrapStatus)
    1: JS_HandleTrap(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval)
    1: {
    1:     JSTrap *trap;
    1:     jsint op;
    1:     JSTrapStatus status;
    1: 
    1:     DBG_LOCK(cx->runtime);
    1:     trap = FindTrap(cx->runtime, script, pc);
    1:     JS_ASSERT(!trap || trap->handler);
    1:     if (!trap) {
    1:         op = (JSOp) *pc;
    1:         DBG_UNLOCK(cx->runtime);
    1: 
    1:         /* Defend against "pc for wrong script" API usage error. */
    1:         JS_ASSERT(op != JSOP_TRAP);
    1: 
    1: #ifdef JS_THREADSAFE
    1:         /* If the API was abused, we must fail for want of the real op. */
    1:         if (op == JSOP_TRAP)
    1:             return JSTRAP_ERROR;
    1: 
    1:         /* Assume a race with a debugger thread and try to carry on. */
    1:         *rval = INT_TO_JSVAL(op);
    1:         return JSTRAP_CONTINUE;
    1: #else
    1:         /* Always fail if single-threaded (must be an API usage error). */
    1:         return JSTRAP_ERROR;
    1: #endif
    1:     }
    1:     DBG_UNLOCK(cx->runtime);
    1: 
    1:     /*
    1:      * It's important that we not use 'trap->' after calling the callback --
    1:      * the callback might remove the trap!
    1:      */
    1:     op = (jsint)trap->op;
    1:     status = trap->handler(cx, script, pc, rval, trap->closure);
    1:     if (status == JSTRAP_CONTINUE) {
    1:         /* By convention, return the true op to the interpreter in rval. */
    1:         *rval = INT_TO_JSVAL(op);
    1:     }
    1:     return status;
    1: }
    1: 
35331: #ifdef JS_TRACER
35331: static void
35331: JITInhibitingHookChange(JSRuntime *rt, bool wasInhibited)
35331: {
35331:     if (wasInhibited) {
35331:         if (!rt->debuggerInhibitsJIT()) {
35331:             for (JSCList *cl = rt->contextList.next; cl != &rt->contextList; cl = cl->next)
35331:                 js_ContextFromLinkField(cl)->updateJITEnabled();
35331:         }
35331:     } else if (rt->debuggerInhibitsJIT()) {
35331:         for (JSCList *cl = rt->contextList.next; cl != &rt->contextList; cl = cl->next)
35331:             js_ContextFromLinkField(cl)->jitEnabled = false;
35331:     }
35331: }
35331: 
35331: static void
35331: LeaveTraceRT(JSRuntime *rt)
35331: {
35331:     JSThreadData *data = js_CurrentThreadData(rt);
35331:     JSContext *cx = data ? data->traceMonitor.tracecx : NULL;
35331:     JS_UNLOCK_GC(rt);
35331: 
35331:     if (cx)
37741:         LeaveTrace(cx);
35331: }
35331: #endif
35331: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetInterrupt(JSRuntime *rt, JSTrapHandler handler, void *closure)
    1: {
35331: #ifdef JS_TRACER
40840:     {
40840:         AutoLockGC lock(rt);
35331:         bool wasInhibited = rt->debuggerInhibitsJIT();
35331: #endif
 2433:         rt->globalDebugHooks.interruptHandler = handler;
 2433:         rt->globalDebugHooks.interruptHandlerData = closure;
35331: #ifdef JS_TRACER
35331:         JITInhibitingHookChange(rt, wasInhibited);
40840:     }
35331:     LeaveTraceRT(rt);
35331: #endif
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ClearInterrupt(JSRuntime *rt, JSTrapHandler *handlerp, void **closurep)
    1: {
35331: #ifdef JS_TRACER
40840:     AutoLockGC lock(rt);
35331:     bool wasInhibited = rt->debuggerInhibitsJIT();
35331: #endif
    1:     if (handlerp)
35331:         *handlerp = rt->globalDebugHooks.interruptHandler;
    1:     if (closurep)
 2433:         *closurep = rt->globalDebugHooks.interruptHandlerData;
 2433:     rt->globalDebugHooks.interruptHandler = 0;
 2433:     rt->globalDebugHooks.interruptHandlerData = 0;
35331: #ifdef JS_TRACER
35331:     JITInhibitingHookChange(rt, wasInhibited);
35331: #endif
    1:     return JS_TRUE;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: typedef struct JSWatchPoint {
    1:     JSCList             links;
    1:     JSObject            *object;        /* weak link, see js_FinalizeObject */
    1:     JSScopeProperty     *sprop;
    1:     JSPropertyOp        setter;
    1:     JSWatchPointHandler handler;
32694:     JSObject            *closure;
    1:     uintN               flags;
    1: } JSWatchPoint;
    1: 
    1: #define JSWP_LIVE       0x1             /* live because set and not cleared */
    1: #define JSWP_HELD       0x2             /* held while running handler/setter */
    1: 
35453: static bool
35453: IsWatchedProperty(JSContext *cx, JSScopeProperty *sprop);
35453: 
    1: /*
    1:  * NB: DropWatchPointAndUnlock releases cx->runtime->debuggerLock in all cases.
    1:  */
    1: static JSBool
    1: DropWatchPointAndUnlock(JSContext *cx, JSWatchPoint *wp, uintN flag)
    1: {
35453:     JSBool ok;
    1:     JSScopeProperty *sprop;
 9828:     JSScope *scope;
    1:     JSPropertyOp setter;
    1: 
    1:     ok = JS_TRUE;
    1:     wp->flags &= ~flag;
    1:     if (wp->flags != 0) {
    1:         DBG_UNLOCK(cx->runtime);
    1:         return ok;
    1:     }
    1: 
    1:     /*
    1:      * Remove wp from the list, then if there are no other watchpoints for
    1:      * wp->sprop in any scope, restore wp->sprop->setter from wp.
    1:      */
    1:     ++cx->runtime->debuggerMutations;
    1:     JS_REMOVE_LINK(&wp->links);
    1:     sprop = wp->sprop;
    1: 
    1:     /*
    1:      * Passing null for the scope parameter tells js_GetWatchedSetter to find
    1:      * any watch point for sprop, and not to lock or unlock rt->debuggerLock.
    1:      * If js_ChangeNativePropertyAttrs fails, propagate failure after removing
    1:      * wp->closure's root and freeing wp.
    1:      */
    1:     setter = js_GetWatchedSetter(cx->runtime, NULL, sprop);
    1:     DBG_UNLOCK(cx->runtime);
    1:     if (!setter) {
 9828:         JS_LOCK_OBJ(cx, wp->object);
40847:         scope = wp->object->scope();
    1: 
    1:         /*
35453:          * If the property wasn't found on wp->object, or it isn't still being
35453:          * watched, then someone else must have deleted or unwatched it, and we
35453:          * don't need to change the property attributes.
    1:          */
35453:         JSScopeProperty *wprop = scope->lookup(sprop->id);
35453:         if (wprop &&
40265:             wprop->hasSetterValue() == sprop->hasSetterValue() &&
35453:             IsWatchedProperty(cx, wprop)) {
40265:             sprop = scope->changeProperty(cx, wprop, 0, wprop->attributes(),
39894:                                           wprop->getter(), wp->setter);
    1:             if (!sprop)
    1:                 ok = JS_FALSE;
    1:         }
35453:         JS_UNLOCK_SCOPE(cx, scope);
    1:     }
    1: 
30851:     cx->free(wp);
    1:     return ok;
    1: }
    1: 
    1: /*
  583:  * NB: js_TraceWatchPoints does not acquire cx->runtime->debuggerLock, since
    1:  * the debugger should never be racing with the GC (i.e., the debugger must
    1:  * respect the request model).
    1:  */
    1: void
 5816: js_TraceWatchPoints(JSTracer *trc, JSObject *obj)
    1: {
    1:     JSRuntime *rt;
    1:     JSWatchPoint *wp;
    1: 
  583:     rt = trc->context->runtime;
  583: 
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = (JSWatchPoint *)wp->links.next) {
 5816:         if (wp->object == obj) {
30852:             wp->sprop->trace(trc);
41860:             if (wp->sprop->hasSetterValue() && wp->setter)
41860:                 JS_CALL_OBJECT_TRACER(trc, CastAsObject(wp->setter), "wp->setter");
 5816:             JS_SET_TRACING_NAME(trc, "wp->closure");
32694:             js_CallValueTracerIfGCThing(trc, OBJECT_TO_JSVAL(wp->closure));
    1:         }
 5816:     }
 5816: }
 5816: 
 5816: void
 5816: js_SweepWatchPoints(JSContext *cx)
 5816: {
 5816:     JSRuntime *rt;
 5816:     JSWatchPoint *wp, *next;
 5816:     uint32 sample;
 5816: 
 5816:     rt = cx->runtime;
 5816:     DBG_LOCK(rt);
 5816:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
 5816:          wp = next) {
 5816:         next = (JSWatchPoint *)wp->links.next;
36410:         if (js_IsAboutToBeFinalized(wp->object)) {
 5816:             sample = rt->debuggerMutations;
 5816: 
 5816:             /* Ignore failures. */
 5816:             DropWatchPointAndUnlock(cx, wp, JSWP_LIVE);
 5816:             DBG_LOCK(rt);
 5816:             if (rt->debuggerMutations != sample + 1)
 5816:                 next = (JSWatchPoint *)rt->watchPointList.next;
 5816:         }
 5816:     }
 5816:     DBG_UNLOCK(rt);
 5816: }
 5816: 
 5816: 
    1: 
    1: /*
    1:  * NB: FindWatchPoint must be called with rt->debuggerLock acquired.
    1:  */
    1: static JSWatchPoint *
41855: FindWatchPoint(JSRuntime *rt, JSScope *scope, jsid id)
    1: {
    1:     JSWatchPoint *wp;
    1: 
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = (JSWatchPoint *)wp->links.next) {
40847:         if (wp->object->scope() == scope && wp->sprop->id == id)
    1:             return wp;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: JSScopeProperty *
41855: js_FindWatchPoint(JSRuntime *rt, JSScope *scope, jsid id)
    1: {
    1:     JSWatchPoint *wp;
    1:     JSScopeProperty *sprop;
    1: 
    1:     DBG_LOCK(rt);
    1:     wp = FindWatchPoint(rt, scope, id);
    1:     sprop = wp ? wp->sprop : NULL;
    1:     DBG_UNLOCK(rt);
    1:     return sprop;
    1: }
    1: 
    1: /*
    1:  * Secret handshake with DropWatchPointAndUnlock: if (!scope), we know our
    1:  * caller has acquired rt->debuggerLock, so we don't have to.
    1:  */
    1: JSPropertyOp
    1: js_GetWatchedSetter(JSRuntime *rt, JSScope *scope,
    1:                     const JSScopeProperty *sprop)
    1: {
    1:     JSPropertyOp setter;
    1:     JSWatchPoint *wp;
    1: 
    1:     setter = NULL;
    1:     if (scope)
    1:         DBG_LOCK(rt);
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = (JSWatchPoint *)wp->links.next) {
40847:         if ((!scope || wp->object->scope() == scope) && wp->sprop == sprop) {
    1:             setter = wp->setter;
    1:             break;
    1:         }
    1:     }
    1:     if (scope)
    1:         DBG_UNLOCK(rt);
    1:     return setter;
    1: }
    1: 
18907: JSBool
    1: js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSRuntime *rt;
    1:     JSWatchPoint *wp;
    1:     JSScopeProperty *sprop;
    1:     jsval propid, userid;
    1:     JSScope *scope;
    1:     JSBool ok;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = (JSWatchPoint *)wp->links.next) {
    1:         sprop = wp->sprop;
    1:         if (wp->object == obj && SPROP_USERID(sprop) == id &&
    1:             !(wp->flags & JSWP_HELD)) {
    1:             wp->flags |= JSWP_HELD;
    1:             DBG_UNLOCK(rt);
    1: 
    1:             JS_LOCK_OBJ(cx, obj);
    1:             propid = ID_TO_VALUE(sprop->id);
38562:             userid = SPROP_USERID(sprop);
40847:             scope = obj->scope();
    1:             JS_UNLOCK_OBJ(cx, obj);
    1: 
    1:             /* NB: wp is held, so we can safely dereference it still. */
    1:             ok = wp->handler(cx, obj, propid,
    1:                              SPROP_HAS_VALID_SLOT(sprop, scope)
40430:                              ? obj->getSlotMT(cx, sprop->slot)
    1:                              : JSVAL_VOID,
    1:                              vp, wp->closure);
    1:             if (ok) {
    1:                 /*
    1:                  * Create a pseudo-frame for the setter invocation so that any
    1:                  * stack-walking security code under the setter will correctly
    1:                  * identify the guilty party.  So that the watcher appears to
    1:                  * be active to obj_eval and other such code, point frame.pc
    1:                  * at the JSOP_STOP at the end of the script.
 6040:                  *
 6040:                  * The pseudo-frame is not created for fast natives as they
 6040:                  * are treated as interpreter frame extensions and always
 6040:                  * trusted.
    1:                  */
    1:                 JSObject *closure;
    1:                 JSClass *clasp;
    1:                 JSFunction *fun;
    1:                 JSScript *script;
 6040:                 JSBool injectFrame;
30265:                 uintN nslots, slotsStart;
    1:                 jsval smallv[5];
    1:                 jsval *argv;
    1:                 JSStackFrame frame;
13168:                 JSFrameRegs regs;
    1: 
32694:                 closure = wp->closure;
40826:                 clasp = closure->getClass();
    1:                 if (clasp == &js_FunctionClass) {
13691:                     fun = GET_FUNCTION_PRIVATE(cx, closure);
    1:                     script = FUN_SCRIPT(fun);
    1:                 } else if (clasp == &js_ScriptClass) {
    1:                     fun = NULL;
32684:                     script = (JSScript *) closure->getPrivate();
    1:                 } else {
    1:                     fun = NULL;
    1:                     script = NULL;
    1:                 }
    1: 
30265:                 slotsStart = nslots = 2;
 6040:                 injectFrame = JS_TRUE;
    1:                 if (fun) {
13702:                     nslots += FUN_MINARGS(fun);
13702:                     if (!FUN_INTERPRETED(fun)) {
    1:                         nslots += fun->u.n.extra;
13702:                         injectFrame = !(fun->flags & JSFUN_FAST_NATIVE);
 6040:                     }
30265: 
30265:                     slotsStart = nslots;
    1:                 }
30265:                 if (script)
30265:                     nslots += script->nslots;
    1: 
 6040:                 if (injectFrame) {
    1:                     if (nslots <= JS_ARRAY_LENGTH(smallv)) {
    1:                         argv = smallv;
    1:                     } else {
30851:                         argv = (jsval *) cx->malloc(nslots * sizeof(jsval));
    1:                         if (!argv) {
    1:                             DBG_LOCK(rt);
    1:                             DropWatchPointAndUnlock(cx, wp, JSWP_HELD);
    1:                             return JS_FALSE;
    1:                         }
    1:                     }
    1: 
    1:                     argv[0] = OBJECT_TO_JSVAL(closure);
    1:                     argv[1] = JSVAL_NULL;
40229:                     PodZero(argv + 2, nslots - 2);
    1: 
40229:                     PodZero(&frame);
    1:                     frame.script = script;
13168:                     frame.regs = NULL;
30027:                     frame.fun = fun;
30027:                     frame.argv = argv + 2;
30027:                     frame.down = js_GetTopStackFrame(cx);
39930:                     frame.scopeChain = closure->getParent();
30265:                     if (script && script->nslots)
30265:                         frame.slots = argv + slotsStart;
    1:                     if (script) {
    1:                         JS_ASSERT(script->length >= JSOP_STOP_LENGTH);
13168:                         regs.pc = script->code + script->length
    1:                                   - JSOP_STOP_LENGTH;
32797:                         regs.sp = NULL;
13168:                         frame.regs = &regs;
30027:                         if (fun &&
30027:                             JSFUN_HEAVYWEIGHT_TEST(fun->flags) &&
30027:                             !js_GetCallObject(cx, &frame)) {
30027:                             if (argv != smallv)
30851:                                 cx->free(argv);
30027:                             DBG_LOCK(rt);
30027:                             DropWatchPointAndUnlock(cx, wp, JSWP_HELD);
30027:                             return JS_FALSE;
    1:                         }
30027:                     }
    1: 
    1:                     cx->fp = &frame;
 6040:                 }
 6040: #ifdef __GNUC__
 6040:                 else
 6040:                     argv = NULL;    /* suppress bogus gcc warnings */
 6040: #endif
    1:                 ok = !wp->setter ||
40265:                      (sprop->hasSetterValue()
24846:                       ? js_InternalCall(cx, obj,
41860:                                         CastAsObjectJSVal(wp->setter),
    1:                                         1, vp, vp)
25050:                       : wp->setter(cx, obj, userid, vp));
 6040:                 if (injectFrame) {
 5897:                     /* Evil code can cause us to have an arguments object. */
31823:                     frame.putActivationObjects(cx);
    1:                     cx->fp = frame.down;
    1:                     if (argv != smallv)
30851:                         cx->free(argv);
    1:                 }
 6040:             }
    1:             DBG_LOCK(rt);
    1:             return DropWatchPointAndUnlock(cx, wp, JSWP_HELD) && ok;
    1:         }
    1:     }
    1:     DBG_UNLOCK(rt);
    1:     return JS_TRUE;
    1: }
    1: 
29885: JSBool
    1: js_watch_set_wrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                      jsval *rval)
    1: {
    1:     JSObject *funobj;
    1:     JSFunction *wrapper;
    1:     jsval userid;
    1: 
    1:     funobj = JSVAL_TO_OBJECT(argv[-2]);
13691:     wrapper = GET_FUNCTION_PRIVATE(cx, funobj);
    1:     userid = ATOM_KEY(wrapper->atom);
    1:     *rval = argv[0];
    1:     return js_watch_set(cx, obj, userid, rval);
    1: }
    1: 
35453: static bool
35453: IsWatchedProperty(JSContext *cx, JSScopeProperty *sprop)
35453: {
40265:     if (sprop->hasSetterValue()) {
39894:         JSObject *funobj = sprop->setterObject();
41860:         if (!funobj || !funobj->isFunction())
39904:             return false;
39904: 
35453:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
35453:         return FUN_NATIVE(fun) == js_watch_set_wrapper;
35453:     }
39894:     return sprop->setterOp() == js_watch_set;
35453: }
35453: 
    1: JSPropertyOp
    1: js_WrapWatchedSetter(JSContext *cx, jsid id, uintN attrs, JSPropertyOp setter)
    1: {
    1:     JSAtom *atom;
    1:     JSFunction *wrapper;
    1: 
    1:     if (!(attrs & JSPROP_SETTER))
    1:         return &js_watch_set;   /* & to silence schoolmarmish MSVC */
    1: 
    1:     if (JSID_IS_ATOM(id)) {
    1:         atom = JSID_TO_ATOM(id);
    1:     } else if (JSID_IS_INT(id)) {
10573:         if (!js_ValueToStringId(cx, INT_JSID_TO_JSVAL(id), &id))
    1:             return NULL;
10573:         atom = JSID_TO_ATOM(id);
    1:     } else {
    1:         atom = NULL;
    1:     }
41120: 
    1:     wrapper = js_NewFunction(cx, NULL, js_watch_set_wrapper, 1, 0,
41860:                              setter ? CastAsObject(setter)->getParent() : NULL, atom);
    1:     if (!wrapper)
    1:         return NULL;
41860:     return CastAsPropertyOp(FUN_OBJECT(wrapper));
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
10573: JS_SetWatchPoint(JSContext *cx, JSObject *obj, jsval idval,
    1:                  JSWatchPointHandler handler, void *closure)
    1: {
35046:     JSObject *origobj;
35046:     jsval v;
35046:     uintN attrs;
    1:     jsid propid;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1:     JSScopeProperty *sprop;
    1:     JSRuntime *rt;
    1:     JSBool ok;
    1:     JSWatchPoint *wp;
    1:     JSPropertyOp watcher;
    1: 
35046:     origobj = obj;
35046:     obj = js_GetWrappedObject(cx, obj);
35046:     OBJ_TO_INNER_OBJECT(cx, obj);
35046:     if (!obj)
    1:         return JS_FALSE;
    1: 
24284:     if (JSVAL_IS_INT(idval)) {
10573:         propid = INT_JSVAL_TO_JSID(idval);
24284:     } else {
24284:         if (!js_ValueToStringId(cx, idval, &propid))
    1:             return JS_FALSE;
30270:         propid = js_CheckForStringIndex(propid);
24284:     }
    1: 
35046:     /*
35046:      * If, by unwrapping and innerizing, we changed the object, check
35046:      * again to make sure that we're allowed to set a watch point.
35046:      */
35046:     if (origobj != obj && !obj->checkAccess(cx, propid, JSACC_WATCH, &v, &attrs))
35046:         return JS_FALSE;
35046: 
40430:     if (!obj->isNative()) {
35046:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_WATCH,
40826:                              obj->getClass()->name);
35046:         return JS_FALSE;
35046:     }
35046: 
    1:     if (!js_LookupProperty(cx, obj, propid, &pobj, &prop))
    1:         return JS_FALSE;
    1:     sprop = (JSScopeProperty *) prop;
    1:     rt = cx->runtime;
    1:     if (!sprop) {
    1:         /* Check for a deleted symbol watchpoint, which holds its property. */
40847:         sprop = js_FindWatchPoint(rt, obj->scope(), propid);
    1:         if (!sprop) {
    1:             /* Make a new property in obj so we can watch for the first set. */
32573:             if (!js_DefineNativeProperty(cx, obj, propid, JSVAL_VOID, NULL, NULL,
32573:                                          JSPROP_ENUMERATE, 0, 0, &prop)) {
    1:                 return JS_FALSE;
    1:             }
    1:             sprop = (JSScopeProperty *) prop;
    1:         }
    1:     } else if (pobj != obj) {
    1:         /* Clone the prototype property so we can watch the right object. */
    1:         jsval value;
    1:         JSPropertyOp getter, setter;
    1:         uintN attrs, flags;
    1:         intN shortid;
    1: 
40430:         if (pobj->isNative()) {
40847:             value = SPROP_HAS_VALID_SLOT(sprop, pobj->scope())
40847:                     ? pobj->lockedGetSlot(sprop->slot)
    1:                     : JSVAL_VOID;
39894:             getter = sprop->getter();
39894:             setter = sprop->setter();
40265:             attrs = sprop->attributes();
38562:             flags = sprop->getFlags();
    1:             shortid = sprop->shortid;
    1:         } else {
31501:             if (!pobj->getProperty(cx, propid, &value) ||
31501:                 !pobj->getAttributes(cx, propid, prop, &attrs)) {
31501:                 pobj->dropProperty(cx, prop);
    1:                 return JS_FALSE;
    1:             }
    1:             getter = setter = NULL;
    1:             flags = 0;
    1:             shortid = 0;
    1:         }
31501:         pobj->dropProperty(cx, prop);
    1: 
    1:         /* Recall that obj is native, whether or not pobj is native. */
    1:         if (!js_DefineNativeProperty(cx, obj, propid, value, getter, setter,
    1:                                      attrs, flags, shortid, &prop)) {
    1:             return JS_FALSE;
    1:         }
    1:         sprop = (JSScopeProperty *) prop;
    1:     }
    1: 
    1:     /*
    1:      * At this point, prop/sprop exists in obj, obj is locked, and we must
31501:      * obj->dropProperty(cx, prop) before returning.
    1:      */
    1:     ok = JS_TRUE;
    1:     DBG_LOCK(rt);
40847:     wp = FindWatchPoint(rt, obj->scope(), propid);
    1:     if (!wp) {
    1:         DBG_UNLOCK(rt);
40265:         watcher = js_WrapWatchedSetter(cx, propid, sprop->attributes(), sprop->setter());
    1:         if (!watcher) {
    1:             ok = JS_FALSE;
    1:             goto out;
    1:         }
    1: 
30851:         wp = (JSWatchPoint *) cx->malloc(sizeof *wp);
    1:         if (!wp) {
    1:             ok = JS_FALSE;
    1:             goto out;
    1:         }
    1:         wp->handler = NULL;
    1:         wp->closure = NULL;
    1:         wp->object = obj;
39894:         wp->setter = sprop->setter();
    1:         wp->flags = JSWP_LIVE;
    1: 
    1:         /* XXXbe nest in obj lock here */
40265:         sprop = js_ChangeNativePropertyAttrs(cx, obj, sprop, 0, sprop->attributes(),
39894:                                              sprop->getter(), watcher);
    1:         if (!sprop) {
    1:             /* Self-link so DropWatchPointAndUnlock can JS_REMOVE_LINK it. */
    1:             JS_INIT_CLIST(&wp->links);
    1:             DBG_LOCK(rt);
    1:             DropWatchPointAndUnlock(cx, wp, JSWP_LIVE);
    1:             ok = JS_FALSE;
    1:             goto out;
    1:         }
    1:         wp->sprop = sprop;
    1: 
    1:         /*
    1:          * Now that wp is fully initialized, append it to rt's wp list.
    1:          * Because obj is locked we know that no other thread could have added
    1:          * a watchpoint for (obj, propid).
    1:          */
    1:         DBG_LOCK(rt);
40847:         JS_ASSERT(!FindWatchPoint(rt, obj->scope(), propid));
    1:         JS_APPEND_LINK(&wp->links, &rt->watchPointList);
    1:         ++rt->debuggerMutations;
    1:     }
    1:     wp->handler = handler;
32694:     wp->closure = reinterpret_cast<JSObject*>(closure);
    1:     DBG_UNLOCK(rt);
    1: 
    1: out:
31501:     obj->dropProperty(cx, prop);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ClearWatchPoint(JSContext *cx, JSObject *obj, jsval id,
    1:                    JSWatchPointHandler *handlerp, void **closurep)
    1: {
    1:     JSRuntime *rt;
    1:     JSWatchPoint *wp;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = (JSWatchPoint *)wp->links.next) {
    1:         if (wp->object == obj && SPROP_USERID(wp->sprop) == id) {
    1:             if (handlerp)
    1:                 *handlerp = wp->handler;
    1:             if (closurep)
    1:                 *closurep = wp->closure;
    1:             return DropWatchPointAndUnlock(cx, wp, JSWP_LIVE);
    1:         }
    1:     }
    1:     DBG_UNLOCK(rt);
    1:     if (handlerp)
    1:         *handlerp = NULL;
    1:     if (closurep)
    1:         *closurep = NULL;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ClearWatchPointsForObject(JSContext *cx, JSObject *obj)
    1: {
    1:     JSRuntime *rt;
    1:     JSWatchPoint *wp, *next;
    1:     uint32 sample;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = next) {
    1:         next = (JSWatchPoint *)wp->links.next;
    1:         if (wp->object == obj) {
    1:             sample = rt->debuggerMutations;
    1:             if (!DropWatchPointAndUnlock(cx, wp, JSWP_LIVE))
    1:                 return JS_FALSE;
    1:             DBG_LOCK(rt);
    1:             if (rt->debuggerMutations != sample + 1)
    1:                 next = (JSWatchPoint *)rt->watchPointList.next;
    1:         }
    1:     }
    1:     DBG_UNLOCK(rt);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_ClearAllWatchPoints(JSContext *cx)
    1: {
    1:     JSRuntime *rt;
    1:     JSWatchPoint *wp, *next;
    1:     uint32 sample;
    1: 
    1:     rt = cx->runtime;
    1:     DBG_LOCK(rt);
    1:     for (wp = (JSWatchPoint *)rt->watchPointList.next;
18414:          &wp->links != &rt->watchPointList;
    1:          wp = next) {
    1:         next = (JSWatchPoint *)wp->links.next;
    1:         sample = rt->debuggerMutations;
    1:         if (!DropWatchPointAndUnlock(cx, wp, JSWP_LIVE))
    1:             return JS_FALSE;
    1:         DBG_LOCK(rt);
    1:         if (rt->debuggerMutations != sample + 1)
    1:             next = (JSWatchPoint *)rt->watchPointList.next;
    1:     }
    1:     DBG_UNLOCK(rt);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc)
    1: {
    1:     return js_PCToLineNumber(cx, script, pc);
    1: }
    1: 
    1: JS_PUBLIC_API(jsbytecode *)
    1: JS_LineNumberToPC(JSContext *cx, JSScript *script, uintN lineno)
    1: {
    1:     return js_LineNumberToPC(script, lineno);
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_GetFunctionScript(JSContext *cx, JSFunction *fun)
    1: {
    1:     return FUN_SCRIPT(fun);
    1: }
    1: 
    1: JS_PUBLIC_API(JSNative)
    1: JS_GetFunctionNative(JSContext *cx, JSFunction *fun)
    1: {
    1:     return FUN_NATIVE(fun);
    1: }
    1: 
 4127: JS_PUBLIC_API(JSFastNative)
 4127: JS_GetFunctionFastNative(JSContext *cx, JSFunction *fun)
 4127: {
13702:     return FUN_FAST_NATIVE(fun);
 4127: }
 4127: 
    1: JS_PUBLIC_API(JSPrincipals *)
    1: JS_GetScriptPrincipals(JSContext *cx, JSScript *script)
    1: {
    1:     return script->principals;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  *  Stack Frame Iterator
    1:  */
    1: JS_PUBLIC_API(JSStackFrame *)
    1: JS_FrameIterator(JSContext *cx, JSStackFrame **iteratorp)
    1: {
22652:     *iteratorp = (*iteratorp == NULL) ? js_GetTopStackFrame(cx) : (*iteratorp)->down;
    1:     return *iteratorp;
    1: }
    1: 
    1: JS_PUBLIC_API(JSScript *)
    1: JS_GetFrameScript(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     return fp->script;
    1: }
    1: 
    1: JS_PUBLIC_API(jsbytecode *)
    1: JS_GetFramePC(JSContext *cx, JSStackFrame *fp)
    1: {
13168:     return fp->regs ? fp->regs->pc : NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(JSStackFrame *)
    1: JS_GetScriptedCaller(JSContext *cx, JSStackFrame *fp)
    1: {
22652:     return js_GetScriptedCaller(cx, fp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSPrincipals *)
    1: JS_StackFramePrincipals(JSContext *cx, JSStackFrame *fp)
    1: {
18870:     JSSecurityCallbacks *callbacks;
18870: 
    1:     if (fp->fun) {
18870:         callbacks = JS_GetSecurityCallbacks(cx);
18870:         if (callbacks && callbacks->findObjectPrincipals) {
31939:             if (FUN_OBJECT(fp->fun) != fp->callee())
31939:                 return callbacks->findObjectPrincipals(cx, fp->callee());
    1:             /* FALL THROUGH */
    1:         }
    1:     }
    1:     if (fp->script)
    1:         return fp->script->principals;
    1:     return NULL;
    1: }
    1: 
38586: JSPrincipals *
38586: js_EvalFramePrincipals(JSContext *cx, JSObject *callee, JSStackFrame *caller)
    1: {
    1:     JSPrincipals *principals, *callerPrincipals;
18870:     JSSecurityCallbacks *callbacks;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
38586:     if (callbacks && callbacks->findObjectPrincipals)
38586:         principals = callbacks->findObjectPrincipals(cx, callee);
38586:     else
    1:         principals = NULL;
    1:     if (!caller)
    1:         return principals;
    1:     callerPrincipals = JS_StackFramePrincipals(cx, caller);
    1:     return (callerPrincipals && principals &&
    1:             callerPrincipals->subsume(callerPrincipals, principals))
    1:            ? principals
    1:            : callerPrincipals;
    1: }
    1: 
38586: JS_PUBLIC_API(JSPrincipals *)
38586: JS_EvalFramePrincipals(JSContext *cx, JSStackFrame *fp, JSStackFrame *caller)
38586: {
38586:     return js_EvalFramePrincipals(cx, fp->callee(), caller);
38586: }
38586: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetFrameAnnotation(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     if (fp->annotation && fp->script) {
    1:         JSPrincipals *principals = JS_StackFramePrincipals(cx, fp);
    1: 
    1:         if (principals && principals->globalPrivilegesEnabled(cx, principals)) {
    1:             /*
    1:              * Give out an annotation only if privileges have not been revoked
    1:              * or disabled globally.
    1:              */
    1:             return fp->annotation;
    1:         }
    1:     }
    1: 
    1:     return NULL;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetFrameAnnotation(JSContext *cx, JSStackFrame *fp, void *annotation)
    1: {
    1:     fp->annotation = annotation;
    1: }
    1: 
    1: JS_PUBLIC_API(void *)
    1: JS_GetFramePrincipalArray(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     JSPrincipals *principals;
    1: 
    1:     principals = JS_StackFramePrincipals(cx, fp);
    1:     if (!principals)
    1:         return NULL;
    1:     return principals->getPrincipalArray(cx, principals);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsNativeFrame(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     return !fp->script;
    1: }
    1: 
    1: /* this is deprecated, use JS_GetFrameScopeChain instead */
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     return fp->scopeChain;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameScopeChain(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     /* Force creation of argument and call objects if not yet created */
    1:     (void) JS_GetFrameCallObject(cx, fp);
    1:     return js_GetScopeChain(cx, fp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameCallObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     if (! fp->fun)
    1:         return NULL;
    1: 
    1:     /* Force creation of argument object if not yet created */
    1:     (void) js_GetArgsObject(cx, fp);
    1: 
    1:     /*
    1:      * XXX ill-defined: null return here means error was reported, unlike a
    1:      *     null returned above or in the #else
    1:      */
25217:     return js_GetCallObject(cx, fp);
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameThis(JSContext *cx, JSStackFrame *fp)
    1: {
40424:     return fp->getThisObject(cx);
    1: }
    1: 
    1: JS_PUBLIC_API(JSFunction *)
    1: JS_GetFrameFunction(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     return fp->fun;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameFunctionObject(JSContext *cx, JSStackFrame *fp)
    1: {
18955:     if (!fp->fun)
18955:         return NULL;
18572: 
40430:     JS_ASSERT(fp->callee()->isFunction());
32684:     JS_ASSERT(fp->callee()->getPrivate() == fp->fun);
31939:     return fp->callee();
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsConstructorFrame(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     return (fp->flags & JSFRAME_CONSTRUCTING) != 0;
    1: }
    1: 
    1: JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameCalleeObject(JSContext *cx, JSStackFrame *fp)
    1: {
31939:     return fp->callee();
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsDebuggerFrame(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     return (fp->flags & JSFRAME_DEBUGGER) != 0;
    1: }
    1: 
    1: JS_PUBLIC_API(jsval)
    1: JS_GetFrameReturnValue(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     return fp->rval;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetFrameReturnValue(JSContext *cx, JSStackFrame *fp, jsval rval)
    1: {
    1:     fp->rval = rval;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(const char *)
    1: JS_GetScriptFilename(JSContext *cx, JSScript *script)
    1: {
    1:     return script->filename;
    1: }
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_GetScriptBaseLineNumber(JSContext *cx, JSScript *script)
    1: {
    1:     return script->lineno;
    1: }
    1: 
    1: JS_PUBLIC_API(uintN)
    1: JS_GetScriptLineExtent(JSContext *cx, JSScript *script)
    1: {
    1:     return js_GetScriptLineExtent(script);
    1: }
    1: 
    1: JS_PUBLIC_API(JSVersion)
    1: JS_GetScriptVersion(JSContext *cx, JSScript *script)
    1: {
 3164:     return (JSVersion) (script->version & JSVERSION_MASK);
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetNewScriptHook(JSRuntime *rt, JSNewScriptHook hook, void *callerdata)
    1: {
 2433:     rt->globalDebugHooks.newScriptHook = hook;
 2433:     rt->globalDebugHooks.newScriptHookData = callerdata;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_SetDestroyScriptHook(JSRuntime *rt, JSDestroyScriptHook hook,
    1:                         void *callerdata)
    1: {
 2433:     rt->globalDebugHooks.destroyScriptHook = hook;
 2433:     rt->globalDebugHooks.destroyScriptHookData = callerdata;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateUCInStackFrame(JSContext *cx, JSStackFrame *fp,
    1:                           const jschar *chars, uintN length,
    1:                           const char *filename, uintN lineno,
    1:                           jsval *rval)
    1: {
28998:     JS_ASSERT_NOT_ON_TRACE(cx);
28997: 
    1:     JSObject *scobj;
24620:     JSScript *script;
    1:     JSBool ok;
    1: 
    1:     scobj = JS_GetFrameScopeChain(cx, fp);
    1:     if (!scobj)
    1:         return JS_FALSE;
    1: 
24620:     /*
24620:      * NB: This function breaks the assumption that the compiler can see all
27012:      * calls and properly compute a static level. In order to get around this,
27012:      * we use a static level that will cause us not to attempt to optimize
24620:      * variable references made by this frame.
24620:      */
40860:     script = Compiler::compileScript(cx, scobj, fp, JS_StackFramePrincipals(cx, fp),
33751:                                      TCF_COMPILE_N_GO, chars, length, NULL,
33751:                                      filename, lineno, NULL, JS_DISPLAY_SIZE);
28952: 
    1:     if (!script)
    1:         return JS_FALSE;
    1: 
28952:     JSStackFrame *displayCopy[JS_DISPLAY_SIZE];
28952:     if (cx->fp != fp) {
28952:         memcpy(displayCopy, cx->display, sizeof displayCopy);
28952: 
29100:         /*
29100:          * Set up cx->display as it would have been when fp was active.
29100:          *
29100:          * NB: To reconstruct cx->display for fp, we have to follow the frame
29100:          * chain from oldest to youngest, in the opposite direction to its
29100:          * single linkge. To avoid the obvious recursive reversal algorithm,
29100:          * which might use too much stack, we reverse in place and reverse
29100:          * again as we reconstruct the display. This is safe because cx is
29100:          * thread-local and we can't cause GC until the call to js_Execute
29100:          * below.
29100:          */
29100:         JSStackFrame *fp2 = fp, *last = NULL;
29100:         while (fp2) {
29100:             JSStackFrame *next = fp2->down;
29100:             fp2->down = last;
29100:             last = fp2;
29100:             fp2 = next;
28952:         }
29100: 
29100:         fp2 = last;
29100:         last = NULL;
29100:         while (fp2) {
29100:             JSStackFrame *next = fp2->down;
29100:             fp2->down = last;
29100:             last = fp2;
29100: 
29100:             JSScript *script = fp2->script;
29100:             if (script && script->staticLevel < JS_DISPLAY_SIZE)
29100:                 cx->display[script->staticLevel] = fp2;
29100:             fp2 = next;
28952:         }
28952:     }
28952: 
    1:     ok = js_Execute(cx, scobj, script, fp, JSFRAME_DEBUGGER | JSFRAME_EVAL,
    1:                     rval);
28952: 
28952:     if (cx->fp != fp)
28952:         memcpy(cx->display, displayCopy, sizeof cx->display);
    1:     js_DestroyScript(cx, script);
    1:     return ok;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_EvaluateInStackFrame(JSContext *cx, JSStackFrame *fp,
    1:                         const char *bytes, uintN length,
    1:                         const char *filename, uintN lineno,
    1:                         jsval *rval)
    1: {
    1:     jschar *chars;
    1:     JSBool ok;
    1:     size_t len = length;
    1: 
    1:     chars = js_InflateString(cx, bytes, &len);
    1:     if (!chars)
    1:         return JS_FALSE;
    1:     length = (uintN) len;
    1:     ok = JS_EvaluateUCInStackFrame(cx, fp, chars, length, filename, lineno,
    1:                                    rval);
30851:     cx->free(chars);
    1: 
    1:     return ok;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: /* XXXbe this all needs to be reworked to avoid requiring JSScope types. */
    1: 
    1: JS_PUBLIC_API(JSScopeProperty *)
    1: JS_PropertyIterator(JSObject *obj, JSScopeProperty **iteratorp)
    1: {
    1:     JSScopeProperty *sprop;
    1:     JSScope *scope;
    1: 
    1:     sprop = *iteratorp;
40847:     scope = obj->scope();
    1: 
    1:     /* XXXbe minor(?) incompatibility: iterate in reverse definition order */
35453:     sprop = sprop ? sprop->parent : scope->lastProperty();
    1:     *iteratorp = sprop;
    1:     return sprop;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyDesc(JSContext *cx, JSObject *obj, JSScopeProperty *sprop,
    1:                    JSPropertyDesc *pd)
    1: {
    1:     pd->id = ID_TO_VALUE(sprop->id);
    1: 
40378:     JSBool wasThrowing = cx->throwing;
40403:     AutoValueRooter lastException(cx, cx->exception);
    1:     cx->throwing = JS_FALSE;
    1: 
    1:     if (!js_GetProperty(cx, obj, sprop->id, &pd->value)) {
    1:         if (!cx->throwing) {
    1:             pd->flags = JSPD_ERROR;
    1:             pd->value = JSVAL_VOID;
    1:         } else {
    1:             pd->flags = JSPD_EXCEPTION;
    1:             pd->value = cx->exception;
    1:         }
    1:     } else {
    1:         pd->flags = 0;
    1:     }
    1: 
    1:     cx->throwing = wasThrowing;
35076:     if (wasThrowing)
35076:         cx->exception = lastException.value();
    1: 
40265:     pd->flags |= (sprop->enumerable() ? JSPD_ENUMERATE : 0)
40265:               |  (!sprop->writable()  ? JSPD_READONLY  : 0)
40265:               |  (!sprop->configurable() ? JSPD_PERMANENT : 0);
13706:     pd->spare = 0;
39894:     if (sprop->getter() == js_GetCallArg) {
13706:         pd->slot = sprop->shortid;
13706:         pd->flags |= JSPD_ARGUMENT;
39894:     } else if (sprop->getter() == js_GetCallVar) {
13706:         pd->slot = sprop->shortid;
13706:         pd->flags |= JSPD_VARIABLE;
13706:     } else {
13706:         pd->slot = 0;
    1:     }
    1:     pd->alias = JSVAL_VOID;
35076: 
40847:     JSScope *scope = obj->scope();
    1:     if (SPROP_HAS_VALID_SLOT(sprop, scope)) {
35076:         JSScopeProperty *aprop;
35453:         for (aprop = scope->lastProperty(); aprop; aprop = aprop->parent) {
    1:             if (aprop != sprop && aprop->slot == sprop->slot) {
    1:                 pd->alias = ID_TO_VALUE(aprop->id);
    1:                 break;
    1:             }
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyDescArray(JSContext *cx, JSObject *obj, JSPropertyDescArray *pda)
    1: {
    1:     JSClass *clasp;
    1:     JSScope *scope;
    1:     uint32 i, n;
    1:     JSPropertyDesc *pd;
    1:     JSScopeProperty *sprop;
    1: 
40826:     clasp = obj->getClass();
40430:     if (!obj->isNative() || (clasp->flags & JSCLASS_NEW_ENUMERATE)) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_DESCRIBE_PROPS, clasp->name);
    1:         return JS_FALSE;
    1:     }
    1:     if (!clasp->enumerate(cx, obj))
    1:         return JS_FALSE;
    1: 
    1:     /* have no props, or object's scope has not mutated from that of proto */
40847:     scope = obj->scope();
30645:     if (scope->entryCount == 0) {
    1:         pda->length = 0;
    1:         pda->array = NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     n = scope->entryCount;
30851:     pd = (JSPropertyDesc *) cx->malloc((size_t)n * sizeof(JSPropertyDesc));
    1:     if (!pd)
    1:         return JS_FALSE;
    1:     i = 0;
35453:     for (sprop = scope->lastProperty(); sprop; sprop = sprop->parent) {
    1:         if (!js_AddRoot(cx, &pd[i].id, NULL))
    1:             goto bad;
    1:         if (!js_AddRoot(cx, &pd[i].value, NULL))
    1:             goto bad;
    1:         if (!JS_GetPropertyDesc(cx, obj, sprop, &pd[i]))
    1:             goto bad;
    1:         if ((pd[i].flags & JSPD_ALIAS) && !js_AddRoot(cx, &pd[i].alias, NULL))
    1:             goto bad;
    1:         if (++i == n)
    1:             break;
    1:     }
    1:     pda->length = i;
    1:     pda->array = pd;
    1:     return JS_TRUE;
    1: 
    1: bad:
    1:     pda->length = i + 1;
    1:     pda->array = pd;
    1:     JS_PutPropertyDescArray(cx, pda);
    1:     return JS_FALSE;
    1: }
    1: 
    1: JS_PUBLIC_API(void)
    1: JS_PutPropertyDescArray(JSContext *cx, JSPropertyDescArray *pda)
    1: {
    1:     JSPropertyDesc *pd;
    1:     uint32 i;
    1: 
    1:     pd = pda->array;
    1:     for (i = 0; i < pda->length; i++) {
    1:         js_RemoveRoot(cx->runtime, &pd[i].id);
    1:         js_RemoveRoot(cx->runtime, &pd[i].value);
    1:         if (pd[i].flags & JSPD_ALIAS)
    1:             js_RemoveRoot(cx->runtime, &pd[i].alias);
    1:     }
30851:     cx->free(pd);
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetDebuggerHandler(JSRuntime *rt, JSTrapHandler handler, void *closure)
    1: {
 2433:     rt->globalDebugHooks.debuggerHandler = handler;
 2433:     rt->globalDebugHooks.debuggerHandlerData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetSourceHandler(JSRuntime *rt, JSSourceHandler handler, void *closure)
    1: {
 2433:     rt->globalDebugHooks.sourceHandler = handler;
 2433:     rt->globalDebugHooks.sourceHandlerData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetExecuteHook(JSRuntime *rt, JSInterpreterHook hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.executeHook = hook;
 2433:     rt->globalDebugHooks.executeHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetCallHook(JSRuntime *rt, JSInterpreterHook hook, void *closure)
    1: {
35331: #ifdef JS_TRACER
40840:     {
40840:         AutoLockGC lock(rt);
35331:         bool wasInhibited = rt->debuggerInhibitsJIT();
35331: #endif
 2433:         rt->globalDebugHooks.callHook = hook;
 2433:         rt->globalDebugHooks.callHookData = closure;
35331: #ifdef JS_TRACER
35331:         JITInhibitingHookChange(rt, wasInhibited);
40840:     }
35331:     if (hook)
35331:         LeaveTraceRT(rt);
35331: #endif
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetObjectHook(JSRuntime *rt, JSObjectHook hook, void *closure)
    1: {
35331: #ifdef JS_TRACER
40840:     {
40840:         AutoLockGC lock(rt);
35331:         bool wasInhibited = rt->debuggerInhibitsJIT();
35331: #endif
 2433:         rt->globalDebugHooks.objectHook = hook;
 2433:         rt->globalDebugHooks.objectHookData = closure;
35331: #ifdef JS_TRACER
35331:         JITInhibitingHookChange(rt, wasInhibited);
40840:     }
35331:     if (hook)
35331:         LeaveTraceRT(rt);
35331: #endif
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetThrowHook(JSRuntime *rt, JSTrapHandler hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.throwHook = hook;
 2433:     rt->globalDebugHooks.throwHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_SetDebugErrorHook(JSRuntime *rt, JSDebugErrorHook hook, void *closure)
    1: {
 2433:     rt->globalDebugHooks.debugErrorHook = hook;
 2433:     rt->globalDebugHooks.debugErrorHookData = closure;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /************************************************************************/
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetObjectTotalSize(JSContext *cx, JSObject *obj)
    1: {
    1:     size_t nbytes;
    1:     JSScope *scope;
    1: 
    1:     nbytes = sizeof *obj;
35057:     if (obj->dslots) {
    1:         nbytes += ((uint32)obj->dslots[-1] - JS_INITIAL_NSLOTS + 1)
    1:                   * sizeof obj->dslots[0];
    1:     }
40430:     if (obj->isNative()) {
40847:         scope = obj->scope();
37766:         if (!scope->isSharedEmpty()) {
    1:             nbytes += sizeof *scope;
    1:             nbytes += SCOPE_CAPACITY(scope) * sizeof(JSScopeProperty *);
    1:         }
    1:     }
    1:     return nbytes;
    1: }
    1: 
    1: static size_t
    1: GetAtomTotalSize(JSContext *cx, JSAtom *atom)
    1: {
    1:     size_t nbytes;
    1: 
 4529:     nbytes = sizeof(JSAtom *) + sizeof(JSDHashEntryStub);
    1:     if (ATOM_IS_STRING(atom)) {
    1:         nbytes += sizeof(JSString);
29366:         nbytes += (ATOM_TO_STRING(atom)->flatLength() + 1) * sizeof(jschar);
    1:     } else if (ATOM_IS_DOUBLE(atom)) {
    1:         nbytes += sizeof(jsdouble);
    1:     }
    1:     return nbytes;
    1: }
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetFunctionTotalSize(JSContext *cx, JSFunction *fun)
    1: {
    1:     size_t nbytes;
    1: 
    1:     nbytes = sizeof *fun;
13824:     nbytes += JS_GetObjectTotalSize(cx, FUN_OBJECT(fun));
    1:     if (FUN_INTERPRETED(fun))
    1:         nbytes += JS_GetScriptTotalSize(cx, fun->u.i.script);
    1:     if (fun->atom)
    1:         nbytes += GetAtomTotalSize(cx, fun->atom);
    1:     return nbytes;
    1: }
    1: 
    1: #include "jsemit.h"
    1: 
    1: JS_PUBLIC_API(size_t)
    1: JS_GetScriptTotalSize(JSContext *cx, JSScript *script)
    1: {
    1:     size_t nbytes, pbytes;
    1:     jsatomid i;
    1:     jssrcnote *sn, *notes;
 3235:     JSObjectArray *objarray;
    1:     JSPrincipals *principals;
    1: 
    1:     nbytes = sizeof *script;
18285:     if (script->u.object)
18285:         nbytes += JS_GetObjectTotalSize(cx, script->u.object);
    1: 
    1:     nbytes += script->length * sizeof script->code[0];
    1:     nbytes += script->atomMap.length * sizeof script->atomMap.vector[0];
    1:     for (i = 0; i < script->atomMap.length; i++)
    1:         nbytes += GetAtomTotalSize(cx, script->atomMap.vector[i]);
    1: 
    1:     if (script->filename)
    1:         nbytes += strlen(script->filename) + 1;
    1: 
32723:     notes = script->notes();
    1:     for (sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
    1:         continue;
    1:     nbytes += (sn - notes + 1) * sizeof *sn;
    1: 
 3235:     if (script->objectsOffset != 0) {
32723:         objarray = script->objects();
 3235:         i = objarray->length;
 3235:         nbytes += sizeof *objarray + i * sizeof objarray->vector[0];
 3235:         do {
 3235:             nbytes += JS_GetObjectTotalSize(cx, objarray->vector[--i]);
 3235:         } while (i != 0);
 3235:     }
 3235: 
 3235:     if (script->regexpsOffset != 0) {
32723:         objarray = script->regexps();
 3235:         i = objarray->length;
 3235:         nbytes += sizeof *objarray + i * sizeof objarray->vector[0];
 3235:         do {
 3235:             nbytes += JS_GetObjectTotalSize(cx, objarray->vector[--i]);
 3235:         } while (i != 0);
 3235:     }
 3235: 
 3235:     if (script->trynotesOffset != 0) {
 3235:         nbytes += sizeof(JSTryNoteArray) +
32723:             script->trynotes()->length * sizeof(JSTryNote);
    1:     }
    1: 
    1:     principals = script->principals;
    1:     if (principals) {
    1:         JS_ASSERT(principals->refcount);
    1:         pbytes = sizeof *principals;
    1:         if (principals->refcount > 1)
    1:             pbytes = JS_HOWMANY(pbytes, principals->refcount);
    1:         nbytes += pbytes;
    1:     }
    1: 
    1:     return nbytes;
    1: }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_GetTopScriptFilenameFlags(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     if (!fp)
22652:         fp = js_GetTopStackFrame(cx);
    1:     while (fp) {
 4127:         if (fp->script)
    1:             return JS_GetScriptFilenameFlags(fp->script);
    1:         fp = fp->down;
    1:     }
    1:     return 0;
    1:  }
    1: 
    1: JS_PUBLIC_API(uint32)
    1: JS_GetScriptFilenameFlags(JSScript *script)
    1: {
    1:     JS_ASSERT(script);
    1:     if (!script->filename)
    1:         return JSFILENAME_NULL;
    1:     return js_GetScriptFilenameFlags(script->filename);
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_FlagScriptFilenamePrefix(JSRuntime *rt, const char *prefix, uint32 flags)
    1: {
    1:     if (!js_SaveScriptFilenameRT(rt, prefix, flags))
    1:         return JS_FALSE;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: JS_IsSystemObject(JSContext *cx, JSObject *obj)
    1: {
32603:     return obj->isSystem();
    1: }
    1: 
 7987: JS_PUBLIC_API(JSObject *)
 7987: JS_NewSystemObject(JSContext *cx, JSClass *clasp, JSObject *proto,
 7987:                    JSObject *parent, JSBool system)
    1: {
 7987:     JSObject *obj;
    1: 
40858:     obj = NewObject(cx, clasp, proto, parent);
 7987:     if (obj && system)
32603:         obj->setSystem();
 7987:     return obj;
    1: }
 2433: 
 2433: /************************************************************************/
 2433: 
35331: JS_PUBLIC_API(const JSDebugHooks *)
 2433: JS_GetGlobalDebugHooks(JSRuntime *rt)
 2433: {
 2433:     return &rt->globalDebugHooks;
 2433: }
 2433: 
37717: const JSDebugHooks js_NullDebugHooks = {};
37717: 
 2433: JS_PUBLIC_API(JSDebugHooks *)
35331: JS_SetContextDebugHooks(JSContext *cx, const JSDebugHooks *hooks)
 2433: {
35331:     JS_ASSERT(hooks);
37717:     if (hooks != &cx->runtime->globalDebugHooks && hooks != &js_NullDebugHooks)
37741:         LeaveTrace(cx);
 2433: 
35331: #ifdef JS_TRACER
40840:     AutoLockGC lock(cx->runtime);
35331: #endif
35331:     JSDebugHooks *old = const_cast<JSDebugHooks *>(cx->debugHooks);
 2433:     cx->debugHooks = hooks;
35331: #ifdef JS_TRACER
35331:     cx->updateJITEnabled();
35331: #endif
 2433:     return old;
 2433: }
10339: 
37717: JS_PUBLIC_API(JSDebugHooks *)
37717: JS_ClearContextDebugHooks(JSContext *cx)
37717: {
37717:     return JS_SetContextDebugHooks(cx, &js_NullDebugHooks);
37717: }
37717: 
10339: #ifdef MOZ_SHARK
10339: 
13496: #include <CHUD/CHUD.h>
13496: 
10447: JS_PUBLIC_API(JSBool)
10447: JS_StartChudRemote()
10339: {
10339:     if (chudIsRemoteAccessAcquired() &&
10339:         (chudStartRemotePerfMonitor("Mozilla") == chudSuccess)) {
10339:         return JS_TRUE;
10339:     }
10339: 
10339:     return JS_FALSE;
10339: }
10339: 
10447: JS_PUBLIC_API(JSBool)
10447: JS_StopChudRemote()
10339: {
10339:     if (chudIsRemoteAccessAcquired() &&
10339:         (chudStopRemotePerfMonitor() == chudSuccess)) {
10339:         return JS_TRUE;
10339:     }
10339: 
10339:     return JS_FALSE;
10339: }
10339: 
10447: JS_PUBLIC_API(JSBool)
10447: JS_ConnectShark()
10339: {
10339:     if (!chudIsInitialized() && (chudInitialize() != chudSuccess))
10339:         return JS_FALSE;
10339: 
10339:     if (chudAcquireRemoteAccess() != chudSuccess)
10339:         return JS_FALSE;
10339: 
10339:     return JS_TRUE;
10339: }
10339: 
10447: JS_PUBLIC_API(JSBool)
10447: JS_DisconnectShark()
10339: {
10339:     if (chudIsRemoteAccessAcquired() && (chudReleaseRemoteAccess() != chudSuccess))
10339:         return JS_FALSE;
10339: 
10339:     return JS_TRUE;
10339: }
10339: 
10339: JS_FRIEND_API(JSBool)
10447: js_StartShark(JSContext *cx, JSObject *obj,
10339:               uintN argc, jsval *argv, jsval *rval)
10339: {
10447:     if (!JS_StartChudRemote()) {
10339:         JS_ReportError(cx, "Error starting CHUD.");
28412:         return JS_FALSE;
10339:     }
10339: 
10339:     return JS_TRUE;
10339: }
10339: 
10339: JS_FRIEND_API(JSBool)
10447: js_StopShark(JSContext *cx, JSObject *obj,
10339:              uintN argc, jsval *argv, jsval *rval)
10339: {
10447:     if (!JS_StopChudRemote()) {
10339:         JS_ReportError(cx, "Error stopping CHUD.");
28412:         return JS_FALSE;
10339:     }
10339: 
10339:     return JS_TRUE;
10339: }
10339: 
10339: JS_FRIEND_API(JSBool)
10447: js_ConnectShark(JSContext *cx, JSObject *obj,
10339:                 uintN argc, jsval *argv, jsval *rval)
10339: {
10447:     if (!JS_ConnectShark()) {
10339:         JS_ReportError(cx, "Error connecting to Shark.");
28412:         return JS_FALSE;
10339:     }
10339: 
10339:     return JS_TRUE;
10339: }
10339: 
10339: JS_FRIEND_API(JSBool)
10447: js_DisconnectShark(JSContext *cx, JSObject *obj,
10339:                    uintN argc, jsval *argv, jsval *rval)
10339: {
10447:     if (!JS_DisconnectShark()) {
10339:         JS_ReportError(cx, "Error disconnecting from Shark.");
28412:         return JS_FALSE;
10339:     }
10339: 
10339:     return JS_TRUE;
10339: }
10339: 
10339: #endif /* MOZ_SHARK */
15763: 
15763: #ifdef MOZ_CALLGRIND
15763: 
15763: #include <valgrind/callgrind.h>
15763: 
15763: JS_FRIEND_API(JSBool)
15763: js_StartCallgrind(JSContext *cx, JSObject *obj,
15763:                   uintN argc, jsval *argv, jsval *rval)
15763: {
15763:     CALLGRIND_START_INSTRUMENTATION;
15763:     CALLGRIND_ZERO_STATS;
15763:     return JS_TRUE;
15763: }
15763: 
15763: JS_FRIEND_API(JSBool)
15763: js_StopCallgrind(JSContext *cx, JSObject *obj,
15763:                  uintN argc, jsval *argv, jsval *rval)
15763: {
15763:     CALLGRIND_STOP_INSTRUMENTATION;
15763:     return JS_TRUE;
15763: }
15763: 
15763: JS_FRIEND_API(JSBool)
15763: js_DumpCallgrind(JSContext *cx, JSObject *obj,
15763:                  uintN argc, jsval *argv, jsval *rval)
15763: {
15763:     JSString *str;
15763:     char *cstr;
15763: 
15763:     if (argc > 0 && JSVAL_IS_STRING(argv[0])) {
15763:         str = JSVAL_TO_STRING(argv[0]);
29366:         cstr = js_DeflateString(cx, str->chars(), str->length());
15763:         if (cstr) {
15763:             CALLGRIND_DUMP_STATS_AT(cstr);
30851:             cx->free(cstr);
15763:             return JS_TRUE;
15763:         }
15763:     }
15763:     CALLGRIND_DUMP_STATS;
15763: 
15763:     return JS_TRUE;
15763: }
15763: 
15763: #endif /* MOZ_CALLGRIND */
16288: 
16288: #ifdef MOZ_VTUNE
16288: #include <VTuneApi.h>
16288: 
16288: static const char *vtuneErrorMessages[] = {
16288:   "unknown, error #0",
16288:   "invalid 'max samples' field",
16288:   "invalid 'samples per buffer' field",
16288:   "invalid 'sample interval' field",
16288:   "invalid path",
16288:   "sample file in use",
16288:   "invalid 'number of events' field",
16288:   "unknown, error #7",
16288:   "internal error",
16288:   "bad event name",
16288:   "VTStopSampling called without calling VTStartSampling",
16288:   "no events selected for event-based sampling",
16288:   "events selected cannot be run together",
16288:   "no sampling parameters",
16288:   "sample database already exists",
16288:   "sampling already started",
16288:   "time-based sampling not supported",
16288:   "invalid 'sampling parameters size' field",
16288:   "invalid 'event size' field",
16288:   "sampling file already bound",
16288:   "invalid event path",
16288:   "invalid license",
16288:   "invalid 'global options' field",
16288: 
16288: };
16288: 
16288: JS_FRIEND_API(JSBool)
16288: js_StartVtune(JSContext *cx, JSObject *obj,
16288:               uintN argc, jsval *argv, jsval *rval)
16288: {
16288:     VTUNE_EVENT events[] = {
16288:         { 1000000, 0, 0, 0, "CPU_CLK_UNHALTED.CORE" },
16288:         { 1000000, 0, 0, 0, "INST_RETIRED.ANY" },
16288:     };
16288: 
16288:     U32 n_events = sizeof(events) / sizeof(VTUNE_EVENT);
16288:     char *default_filename = "mozilla-vtune.tb5";
16288:     JSString *str;
16288:     U32 status;
16288: 
28412:     VTUNE_SAMPLING_PARAMS params =
16288:         sizeof(VTUNE_SAMPLING_PARAMS),
16288:         sizeof(VTUNE_EVENT),
16288:         0, 0, /* Reserved fields */
16288:         1,    /* Initialize in "paused" state */
16288:         0,    /* Max samples, or 0 for "continuous" */
16288:         4096, /* Samples per buffer */
16288:         0.1,  /* Sampling interval in ms */
16288:         1,    /* 1 for event-based sampling, 0 for time-based */
16288: 
16288:         n_events,
16288:         events,
16288:         default_filename,
16288:     };
16288: 
16288:     if (argc > 0 && JSVAL_IS_STRING(argv[0])) {
16288:         str = JSVAL_TO_STRING(argv[0]);
29366:         params.tb5Filename = js_DeflateString(cx, str->chars(), str->length());
16288:     }
16288: 
16288:     status = VTStartSampling(&params);
16288: 
16288:     if (params.tb5Filename != default_filename)
30851:         cx->free(params.tb5Filename);
16288: 
16288:     if (status != 0) {
16288:         if (status == VTAPI_MULTIPLE_RUNS)
16288:             VTStopSampling(0);
16288:         if (status < sizeof(vtuneErrorMessages))
16288:             JS_ReportError(cx, "Vtune setup error: %s",
16288:                            vtuneErrorMessages[status]);
16288:         else
16288:             JS_ReportError(cx, "Vtune setup error: %d",
16288:                            status);
16288:         return JS_FALSE;
16288:     }
16288:     return JS_TRUE;
16288: }
16288: 
16288: JS_FRIEND_API(JSBool)
16288: js_StopVtune(JSContext *cx, JSObject *obj,
16288:              uintN argc, jsval *argv, jsval *rval)
16288: {
16288:     U32 status = VTStopSampling(1);
16288:     if (status) {
16288:         if (status < sizeof(vtuneErrorMessages))
16288:             JS_ReportError(cx, "Vtune shutdown error: %s",
16288:                            vtuneErrorMessages[status]);
16288:         else
16288:             JS_ReportError(cx, "Vtune shutdown error: %d",
16288:                            status);
16288:         return JS_FALSE;
16288:     }
16288:     return JS_TRUE;
16288: }
16288: 
16288: JS_FRIEND_API(JSBool)
16288: js_PauseVtune(JSContext *cx, JSObject *obj,
16288:               uintN argc, jsval *argv, jsval *rval)
16288: {
16288:     VTPause();
16288:     return JS_TRUE;
16288: }
16288: 
16288: JS_FRIEND_API(JSBool)
16288: js_ResumeVtune(JSContext *cx, JSObject *obj,
16288:                uintN argc, jsval *argv, jsval *rval)
16288: {
16288:     VTResume();
16288:     return JS_TRUE;
16288: }
16288: 
16288: #endif /* MOZ_VTUNE */
31063: 
31063: #ifdef MOZ_TRACEVIS
31063: /*
31063:  * Ethogram - Javascript wrapper for TraceVis state
31063:  *
31063:  * ethology: The scientific study of animal behavior,
31063:  *           especially as it occurs in a natural environment.
31063:  * ethogram: A pictorial catalog of the behavioral patterns of
31063:  *           an organism or a species.
31063:  *
31063:  */
31063: #if defined(XP_WIN)
31063: #include <windows.h>
31063: #else
31063: #include <sys/time.h>
31063: #endif
31063: #include "jstracer.h"
31063: 
31063: #define ETHOGRAM_BUF_SIZE 65536
31063: 
31063: static JSBool
31063: ethogram_construct(JSContext *cx, JSObject *obj,
31063:                    uintN argc, jsval *argv, jsval *rval);
31063: static void
31063: ethogram_finalize(JSContext *cx, JSObject *obj);
31063: 
31063: static JSClass ethogram_class = {
31063:     "Ethogram",
31063:     JSCLASS_HAS_PRIVATE,
31063:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
31063:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, ethogram_finalize,
31063:     JSCLASS_NO_OPTIONAL_MEMBERS
31063: };
31063: 
31063: struct EthogramEvent {
31063:     TraceVisState s;
31063:     TraceVisExitReason r;
31063:     int ts;
31063:     int tus;
31063:     JSString *filename;
31063:     int lineno;
31063: };
31063: 
31063: static int
31063: compare_strings(const void *k1, const void *k2)
31063: {
31063:     return strcmp((const char *) k1, (const char *) k2) == 0;
31063: }
31063: 
31063: class EthogramEventBuffer {
31063: private:
31063:     EthogramEvent mBuf[ETHOGRAM_BUF_SIZE];
31063:     int mReadPos;
31063:     int mWritePos;
31063:     JSObject *mFilenames;
31063:     int mStartSecond;
31063: 
31063:     struct EthogramScriptEntry {
31063:         char *filename;
31063:         JSString *jsfilename;
31063: 
31063:         EthogramScriptEntry *next;
31063:     };
31063:     EthogramScriptEntry *mScripts;
31063: 
31063: public:
31063:     friend JSBool
31063:     ethogram_construct(JSContext *cx, JSObject *obj,
31063:                        uintN argc, jsval *argv, jsval *rval);
31063: 
31063:     inline void push(TraceVisState s, TraceVisExitReason r, char *filename, int lineno) {
31063:         mBuf[mWritePos].s = s;
31063:         mBuf[mWritePos].r = r;
31063: #if defined(XP_WIN)
31063:         FILETIME now;
31063:         GetSystemTimeAsFileTime(&now);
31063:         unsigned long long raw_us = 0.1 *
31063:             (((unsigned long long) now.dwHighDateTime << 32ULL) |
31063:              (unsigned long long) now.dwLowDateTime);
31063:         unsigned int sec = raw_us / 1000000L;
31063:         unsigned int usec = raw_us % 1000000L;
31063:         mBuf[mWritePos].ts = sec - mStartSecond;
31063:         mBuf[mWritePos].tus = usec;
31063: #else
31063:         struct timeval tv;
31063:         gettimeofday(&tv, NULL);
31063:         mBuf[mWritePos].ts = tv.tv_sec - mStartSecond;
31063:         mBuf[mWritePos].tus = tv.tv_usec;
31063: #endif
31063: 
31063:         JSString *jsfilename = findScript(filename);
31063:         mBuf[mWritePos].filename = jsfilename;
31063:         mBuf[mWritePos].lineno = lineno;
31063: 
31063:         mWritePos = (mWritePos + 1) % ETHOGRAM_BUF_SIZE;
31063:         if (mWritePos == mReadPos) {
31063:             mReadPos = (mWritePos + 1) % ETHOGRAM_BUF_SIZE;
31063:         }
31063:     }
31063: 
31063:     inline EthogramEvent *pop() {
31063:         EthogramEvent *e = &mBuf[mReadPos];
31063:         mReadPos = (mReadPos + 1) % ETHOGRAM_BUF_SIZE;
31063:         return e;
31063:     }
31063: 
31063:     bool isEmpty() {
31063:         return (mReadPos == mWritePos);
31063:     }
31063: 
31063:     EthogramScriptEntry *addScript(JSContext *cx, JSObject *obj, char *filename, JSString *jsfilename) {
31063:         JSHashNumber hash = JS_HashString(filename);
31063:         JSHashEntry **hep = JS_HashTableRawLookup(traceVisScriptTable, hash, filename);
31063:         if (*hep != NULL)
31063:             return JS_FALSE;
31063: 
31063:         JS_HashTableRawAdd(traceVisScriptTable, hep, hash, filename, this);
31063: 
31063:         EthogramScriptEntry * entry = (EthogramScriptEntry *) JS_malloc(cx, sizeof(EthogramScriptEntry));
31063:         if (entry == NULL)
31063:             return NULL;
31063: 
31063:         entry->next = mScripts;
31063:         mScripts = entry;
31063:         entry->filename = filename;
31063:         entry->jsfilename = jsfilename;
31063: 
31063:         return mScripts;
31063:     }
31063: 
31063:     void removeScripts(JSContext *cx) {
31063:         EthogramScriptEntry *se = mScripts;
31063:         while (se != NULL) {
31063:             char *filename = se->filename;
31063: 
31063:             JSHashNumber hash = JS_HashString(filename);
31063:             JSHashEntry **hep = JS_HashTableRawLookup(traceVisScriptTable, hash, filename);
31063:             JSHashEntry *he = *hep;
31063:             if (he) {
31063:                 /* we hardly knew he */
31063:                 JS_HashTableRawRemove(traceVisScriptTable, hep, he);
31063:             }
31063: 
31063:             EthogramScriptEntry *se_head = se;
31063:             se = se->next;
31063:             JS_free(cx, se_head);
31063:         }
31063:     }
31063: 
31063:     JSString *findScript(char *filename) {
31063:         EthogramScriptEntry *se = mScripts;
31063:         while (se != NULL) {
31063:             if (compare_strings(se->filename, filename))
31063:                 return (se->jsfilename);
31063:             se = se->next;
31063:         }
31063:         return NULL;
31063:     }
31063: 
31063:     JSObject *filenames() {
31063:         return mFilenames;
31063:     }
31063: 
31063:     int length() {
31063:         if (mWritePos < mReadPos)
31063:             return (mWritePos + ETHOGRAM_BUF_SIZE) - mReadPos;
31063:         else
31063:             return mWritePos - mReadPos;
31063:     }
31063: };
31063: 
31063: static char jstv_empty[] = "<null>";
31063: 
31063: inline char *
31063: jstv_Filename(JSStackFrame *fp)
31063: {
31063:     while (fp && fp->script == NULL)
31063:         fp = fp->down;
31063:     return (fp && fp->script && fp->script->filename)
31063:            ? (char *)fp->script->filename
31063:            : jstv_empty;
31063: }
31063: inline uintN
31063: jstv_Lineno(JSContext *cx, JSStackFrame *fp)
31063: {
31063:     while (fp && fp->regs == NULL)
31063:         fp = fp->down;
31063:     return (fp && fp->regs) ? js_FramePCToLineNumber(cx, fp) : 0;
31063: }
31063: 
31063: /* Collect states here and distribute to a matching buffer, if any */
31063: JS_FRIEND_API(void)
38585: js::StoreTraceVisState(JSContext *cx, TraceVisState s, TraceVisExitReason r)
31063: {
31063:     JSStackFrame *fp = cx->fp;
31063: 
31063:     char *script_file = jstv_Filename(fp);
31063:     JSHashNumber hash = JS_HashString(script_file);
31063: 
31063:     JSHashEntry **hep = JS_HashTableRawLookup(traceVisScriptTable, hash, script_file);
31063:     /* update event buffer, flag if overflowed */
31063:     JSHashEntry *he = *hep;
31063:     if (he) {
31063:         EthogramEventBuffer *p;
31063:         p = (EthogramEventBuffer *) he->value;
31063: 
31063:         p->push(s, r, script_file, jstv_Lineno(cx, fp));
31063:     }
31063: }
31063: 
31063: static JSBool
31063: ethogram_construct(JSContext *cx, JSObject *obj,
31063:                    uintN argc, jsval *argv, jsval *rval)
31063: {
31063:     EthogramEventBuffer *p;
31063: 
31063:     p = (EthogramEventBuffer *) JS_malloc(cx, sizeof(EthogramEventBuffer));
31063: 
31063:     p->mReadPos = p->mWritePos = 0;
31063:     p->mScripts = NULL;
31063:     p->mFilenames = JS_NewArrayObject(cx, 0, NULL);
31063: 
31063: #if defined(XP_WIN)
31063:     FILETIME now;
31063:     GetSystemTimeAsFileTime(&now);
31063:     unsigned long long raw_us = 0.1 *
31063:         (((unsigned long long) now.dwHighDateTime << 32ULL) |
31063:          (unsigned long long) now.dwLowDateTime);
31063:     unsigned int s = raw_us / 1000000L;
31063:     p->mStartSecond = s;
31063: #else
31063:     struct timeval tv;
31063:     gettimeofday(&tv, NULL);
31063:     p->mStartSecond = tv.tv_sec;
31063: #endif
31063:     jsval filenames = OBJECT_TO_JSVAL(p->filenames());
31063:     if (!JS_DefineProperty(cx, obj, "filenames", filenames,
31063:                            NULL, NULL, JSPROP_READONLY|JSPROP_PERMANENT))
31063:         return JS_FALSE;
31063: 
31063:     if (!JS_IsConstructing(cx)) {
31063:         obj = JS_NewObject(cx, &ethogram_class, NULL, NULL);
31063:         if (!obj)
31063:             return JS_FALSE;
31063:         *rval = OBJECT_TO_JSVAL(obj);
31063:     }
31063:     JS_SetPrivate(cx, obj, p);
31063:     return JS_TRUE;
31063: }
31063: 
31063: static void
31063: ethogram_finalize(JSContext *cx, JSObject *obj)
31063: {
31063:     EthogramEventBuffer *p;
31063:     p = (EthogramEventBuffer *) JS_GetInstancePrivate(cx, obj, &ethogram_class, NULL);
31063:     if (!p)
31063:         return;
31063: 
31063:     p->removeScripts(cx);
31063: 
31063:     JS_free(cx, p);
31063: }
31063: 
31063: static JSBool
31063: ethogram_addScript(JSContext *cx, JSObject *obj,
31063:                    uintN argc, jsval *argv, jsval *rval)
31063: {
31063:     JSString *str;
31063:     char *filename = NULL;
31063:     if (argc > 0 && JSVAL_IS_STRING(argv[0])) {
31063:         str = JSVAL_TO_STRING(argv[0]);
31063:         filename = js_DeflateString(cx,
31063:                                     str->chars(),
31063:                                     str->length());
31063:     }
31063: 
31063:     /* silently ignore no args */
31063:     if (!filename)
31063:         return JS_TRUE;
31063: 
31063:     EthogramEventBuffer *p = (EthogramEventBuffer *) JS_GetInstancePrivate(cx, obj, &ethogram_class, argv);
31063: 
31063:     p->addScript(cx, obj, filename, str);
31063:     JS_CallFunctionName(cx, p->filenames(), "push", 1, argv, rval);
31063:     return JS_TRUE;
31063: }
31063: 
31063: static JSBool
31063: ethogram_getAllEvents(JSContext *cx, JSObject *obj,
31063:                       uintN argc, jsval *argv, jsval *rval)
31063: {
31063:     EthogramEventBuffer *p;
31063: 
31063:     p = (EthogramEventBuffer *) JS_GetInstancePrivate(cx, obj, &ethogram_class, argv);
31063:     if (!p)
31063:         return JS_FALSE;
31063: 
31063:     if (p->isEmpty()) {
31063:         *rval = JSVAL_NULL;
31063:         return JS_TRUE;
31063:     }
31063: 
31063:     JSObject *rarray = JS_NewArrayObject(cx, 0, NULL);
31063:     if (rarray == NULL) {
31063:         *rval = JSVAL_NULL;
31063:         return JS_TRUE;
31063:     }
31063: 
31063:     *rval = OBJECT_TO_JSVAL(rarray);
31063: 
31063:     for (int i = 0; !p->isEmpty(); i++) {
31063: 
31063:         JSObject *x = JS_NewObject(cx, NULL, NULL, NULL);
31063:         if (x == NULL)
31063:             return JS_FALSE;
31063: 
31063:         EthogramEvent *e = p->pop();
31063: 
31063:         jsval state = INT_TO_JSVAL(e->s);
31063:         jsval reason = INT_TO_JSVAL(e->r);
31063:         jsval ts = INT_TO_JSVAL(e->ts);
31063:         jsval tus = INT_TO_JSVAL(e->tus);
31063: 
31063:         jsval filename = STRING_TO_JSVAL(e->filename);
31063:         jsval lineno = INT_TO_JSVAL(e->lineno);
31063: 
31063:         if (!JS_SetProperty(cx, x, "state", &state))
31063:             return JS_FALSE;
31063:         if (!JS_SetProperty(cx, x, "reason", &reason))
31063:             return JS_FALSE;
31063:         if (!JS_SetProperty(cx, x, "ts", &ts))
31063:             return JS_FALSE;
31063:         if (!JS_SetProperty(cx, x, "tus", &tus))
31063:             return JS_FALSE;
31063: 
31063:         if (!JS_SetProperty(cx, x, "filename", &filename))
31063:             return JS_FALSE;
31063:         if (!JS_SetProperty(cx, x, "lineno", &lineno))
31063:             return JS_FALSE;
31063: 
31063:         jsval element = OBJECT_TO_JSVAL(x);
31063:         JS_SetElement(cx, rarray, i, &element);
31063:     }
31063: 
31063:     return JS_TRUE;
31063: }
31063: 
31063: static JSBool
31063: ethogram_getNextEvent(JSContext *cx, JSObject *obj,
31063:                       uintN argc, jsval *argv, jsval *rval)
31063: {
31063:     EthogramEventBuffer *p;
31063: 
31063:     p = (EthogramEventBuffer *) JS_GetInstancePrivate(cx, obj, &ethogram_class, argv);
31063:     if (!p)
31063:         return JS_FALSE;
31063: 
31063:     JSObject *x = JS_NewObject(cx, NULL, NULL, NULL);
31063:     if (x == NULL)
31063:         return JS_FALSE;
31063: 
31063:     if (p->isEmpty()) {
31063:         *rval = JSVAL_NULL;
31063:         return JS_TRUE;
31063:     }
31063: 
31063:     EthogramEvent *e = p->pop();
31063:     jsval state = INT_TO_JSVAL(e->s);
31063:     jsval reason = INT_TO_JSVAL(e->r);
31063:     jsval ts = INT_TO_JSVAL(e->ts);
31063:     jsval tus = INT_TO_JSVAL(e->tus);
31063: 
31063:     jsval filename = STRING_TO_JSVAL(e->filename);
31063:     jsval lineno = INT_TO_JSVAL(e->lineno);
31063: 
31063:     if (!JS_SetProperty(cx, x, "state", &state))
31063:         return JS_FALSE;
31063:     if (!JS_SetProperty(cx, x, "reason", &reason))
31063:         return JS_FALSE;
31063:     if (!JS_SetProperty(cx, x, "ts", &ts))
31063:         return JS_FALSE;
31063:     if (!JS_SetProperty(cx, x, "tus", &tus))
31063:         return JS_FALSE;
31063:     if (!JS_SetProperty(cx, x, "filename", &filename))
31063:         return JS_FALSE;
31063: 
31063:     if (!JS_SetProperty(cx, x, "lineno", &lineno))
31063:         return JS_FALSE;
31063: 
31063:     *rval = OBJECT_TO_JSVAL(x);
31063: 
31063:     return JS_TRUE;
31063: }
31063: 
31063: static JSFunctionSpec ethogram_methods[] = {
31063:     {"addScript",    ethogram_addScript,    1},
31063:     {"getAllEvents", ethogram_getAllEvents, 0},
31063:     {"getNextEvent", ethogram_getNextEvent, 0},
31063:     {0}
31063: };
31063: 
31063: /*
31063:  * An |Ethogram| organizes the output of a collection of files that should be
31063:  * monitored together. A single object gets events for the group.
31063:  */
31063: JS_FRIEND_API(JSBool)
31063: js_InitEthogram(JSContext *cx, JSObject *obj,
31063:                 uintN argc, jsval *argv, jsval *rval)
31063: {
31063:     if (!traceVisScriptTable) {
31063:         traceVisScriptTable = JS_NewHashTable(8, JS_HashString, compare_strings,
31063:                                          NULL, NULL, NULL);
31063:     }
31063: 
31063:     JS_InitClass(cx, JS_GetGlobalObject(cx), NULL, &ethogram_class,
31063:                  ethogram_construct, 0, NULL, ethogram_methods,
31063:                  NULL, NULL);
31063: 
31063:     return JS_TRUE;
31063: }
31063: 
31063: JS_FRIEND_API(JSBool)
31063: js_ShutdownEthogram(JSContext *cx, JSObject *obj,
31063:                     uintN argc, jsval *argv, jsval *rval)
31063: {
31063:     if (traceVisScriptTable)
31063:         JS_HashTableDestroy(traceVisScriptTable);
31063: 
31063:     return JS_TRUE;
31063: }
31063: 
31063: #endif /* MOZ_TRACEVIS */
