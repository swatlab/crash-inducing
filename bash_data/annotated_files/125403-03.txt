113445: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
113445:  * vim: set ts=4 sw=4 et tw=99:
111655:  *
113445:  * This Source Code Form is subject to the terms of the Mozilla Public
113445:  * License, v. 2.0. If a copy of the MPL was not distributed with this
113445:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
111655: 
111655: #ifndef jsion_bytecode_analyzer_h__
111655: #define jsion_bytecode_analyzer_h__
111655: 
111706: // This file declares the data structures for building a MIRGraph from a
111706: // JSScript.
111706: 
111655: #include "MIR.h"
111706: #include "MIRGraph.h"
111655: 
111655: namespace js {
111655: namespace ion {
111655: 
122028: class CodeGenerator;
113582: 
111665: class IonBuilder : public MIRGenerator
111655: {
111655:     enum ControlStatus {
111655:         ControlStatus_Error,
111655:         ControlStatus_Ended,        // There is no continuation/join point.
111655:         ControlStatus_Joined,       // Created a join node.
111655:         ControlStatus_Jumped,       // Parsing another branch at the same level.
111655:         ControlStatus_None          // No control flow.
111655:     };
111655: 
111663:     struct DeferredEdge : public TempObject
111663:     {
111663:         MBasicBlock *block;
111663:         DeferredEdge *next;
111663: 
111663:         DeferredEdge(MBasicBlock *block, DeferredEdge *next)
111663:           : block(block), next(next)
111663:         { }
111663:     };
111663: 
111929:     struct ControlFlowInfo {
111668:         // Entry in the cfgStack.
124795:         uint32_t cfgEntry;
111662: 
111668:         // Label that continues go to.
111668:         jsbytecode *continuepc;
111668: 
124795:         ControlFlowInfo(uint32_t cfgEntry, jsbytecode *continuepc)
111668:           : cfgEntry(cfgEntry),
111668:             continuepc(continuepc)
111662:         { }
111662:     };
111662: 
111655:     // To avoid recursion, the bytecode analyzer uses a stack where each entry
111655:     // is a small state machine. As we encounter branches or jumps in the
111655:     // bytecode, we push information about the edges on the stack so that the
111655:     // CFG can be built in a tree-like fashion.
111655:     struct CFGState {
111655:         enum State {
111655:             IF_TRUE,            // if() { }, no else.
111655:             IF_TRUE_EMPTY_ELSE, // if() { }, empty else
111655:             IF_ELSE_TRUE,       // if() { X } else { }
111655:             IF_ELSE_FALSE,      // if() { } else { X }
111774:             DO_WHILE_LOOP_BODY, // do { x } while ()
111774:             DO_WHILE_LOOP_COND, // do { } while (x)
111658:             WHILE_LOOP_COND,    // while (x) { }
111664:             WHILE_LOOP_BODY,    // while () { x }
111664:             FOR_LOOP_COND,      // for (; x;) { }
111664:             FOR_LOOP_BODY,      // for (; ;) { x }
111929:             FOR_LOOP_UPDATE,    // for (; ; x) { }
112205:             TABLE_SWITCH,       // switch() { x }
113028:             LOOKUP_SWITCH,      // switch() { x }
124883:             COND_SWITCH_CASE,   // switch() { case X: ... }
124883:             COND_SWITCH_BODY,   // switch() { case ...: X }
112205:             AND_OR              // && x, || x
111655:         };
111655: 
111655:         State state;            // Current state of this control structure.
111655:         jsbytecode *stopAt;     // Bytecode at which to stop the processing loop.
111655: 
111655:         // For if structures, this contains branch information.
111655:         union {
111655:             struct {
111655:                 MBasicBlock *ifFalse;
111655:                 jsbytecode *falseEnd;
111655:                 MBasicBlock *ifTrue;    // Set when the end of the true path is reached.
111655:             } branch;
111655:             struct {
111662:                 // Common entry point.
111662:                 MBasicBlock *entry;
111658: 
111662:                 // Position of where the loop body starts and ends.
111662:                 jsbytecode *bodyStart;
111662:                 jsbytecode *bodyEnd;
111662: 
111662:                 // pc immediately after the loop exits.
111662:                 jsbytecode *exitpc;
111662: 
111662:                 // Common exit point. Created lazily, so it may be NULL.
111662:                 MBasicBlock *successor;
111663: 
111663:                 // Deferred break and continue targets.
111663:                 DeferredEdge *breaks;
111663:                 DeferredEdge *continues;
111664: 
111664:                 // For-loops only.
111664:                 jsbytecode *condpc;
111664:                 jsbytecode *updatepc;
111664:                 jsbytecode *updateEnd;
111655:             } loop;
111929:             struct {
111929:                 // pc immediately after the switch.
111929:                 jsbytecode *exitpc;
111929: 
111929:                 // Deferred break and continue targets.
111929:                 DeferredEdge *breaks;
111929: 
111929:                 // MIR instruction
111929:                 MTableSwitch *ins;
111929: 
111929:                 // The number of current successor that get mapped into a block. 
124795:                 uint32_t currentBlock;
111929: 
111929:             } tableswitch;
113028:             struct {
113028:                 // pc immediately after the switch.
113028:                 jsbytecode *exitpc;
113028: 
113028:                 // Deferred break and continue targets.
113028:                 DeferredEdge *breaks;
113028: 
113028:                 // Vector of body blocks to process
113028:                 FixedList<MBasicBlock *> *bodies;
113028: 
113028:                 // The number of current successor that get mapped into a block. 
124795:                 uint32_t currentBlock;
113028:             } lookupswitch;
124883:             struct {
124883:                 // Vector of body blocks to process after the cases.
124883:                 FixedList<MBasicBlock *> *bodies;
124883: 
124883:                 // When processing case statements, this counter points at the
124883:                 // last uninitialized body.  When processing bodies, this
124883:                 // counter targets the next body to process.
124883:                 uint32_t currentIdx;
124883: 
124883:                 // Remember the block index of the default case.
124883:                 jsbytecode *defaultTarget;
124883:                 uint32_t defaultIdx;
124883: 
124883:                 // Block immediately after the switch.
124883:                 jsbytecode *exitpc;
124883:                 DeferredEdge *breaks;
124883:             } condswitch;
111655:         };
111655: 
111661:         inline bool isLoop() const {
111661:             switch (state) {
111774:               case DO_WHILE_LOOP_COND:
111774:               case DO_WHILE_LOOP_BODY:
111661:               case WHILE_LOOP_COND:
111661:               case WHILE_LOOP_BODY:
112661:               case FOR_LOOP_COND:
112661:               case FOR_LOOP_BODY:
112661:               case FOR_LOOP_UPDATE:
111661:                 return true;
111661:               default:
111661:                 return false;
111661:             }
111661:         }
111661: 
111655:         static CFGState If(jsbytecode *join, MBasicBlock *ifFalse);
111655:         static CFGState IfElse(jsbytecode *trueEnd, jsbytecode *falseEnd, MBasicBlock *ifFalse);
112205:         static CFGState AndOr(jsbytecode *join, MBasicBlock *joinStart);
113028:         static CFGState TableSwitch(jsbytecode *exitpc, MTableSwitch *ins);
113028:         static CFGState LookupSwitch(jsbytecode *exitpc);
124883:         static CFGState CondSwitch(jsbytecode *exitpc, jsbytecode *defaultTarget);
111655:     };
111655: 
112127:     static int CmpSuccessors(const void *a, const void *b);
112127: 
111655:   public:
113485:     IonBuilder(JSContext *cx, TempAllocator *temp, MIRGraph *graph,
124795:                TypeOracle *oracle, CompileInfo *info, size_t inliningDepth = 0, uint32_t loopDepth = 0);
111655: 
111706:     bool build();
113354:     bool buildInline(IonBuilder *callerBuilder, MResumePoint *callerResumePoint,
113431:                      MDefinition *thisDefn, MDefinitionVector &args);
111655: 
111655:   private:
111655:     bool traverseBytecode();
111655:     ControlStatus snoopControlFlow(JSOp op);
113129:     bool processIterators();
111655:     bool inspectOpcode(JSOp op);
124795:     uint32_t readIndex(jsbytecode *pc);
112118:     JSAtom *readAtom(jsbytecode *pc);
112477:     bool abort(const char *message, ...);
113436:     void spew(const char *message);
111655: 
112206:     static bool inliningEnabled() {
112206:         return js_IonOptions.inlining;
112206:     }
112206: 
124795:     JSFunction *getSingleCallTarget(uint32_t argc, jsbytecode *pc);
124795:     unsigned getPolyCallTargets(uint32_t argc, jsbytecode *pc,
113370:                                 AutoObjectVector &targets, uint32_t maxTargets);
112874:     bool canInlineTarget(JSFunction *target);
112206: 
111662:     void popCfgStack();
111664:     bool processDeferredContinues(CFGState &state);
111655:     ControlStatus processControlEnd();
111655:     ControlStatus processCfgStack();
111655:     ControlStatus processCfgEntry(CFGState &state);
111655:     ControlStatus processIfEnd(CFGState &state);
111655:     ControlStatus processIfElseTrueEnd(CFGState &state);
111655:     ControlStatus processIfElseFalseEnd(CFGState &state);
111774:     ControlStatus processDoWhileBodyEnd(CFGState &state);
111774:     ControlStatus processDoWhileCondEnd(CFGState &state);
111658:     ControlStatus processWhileCondEnd(CFGState &state);
111658:     ControlStatus processWhileBodyEnd(CFGState &state);
111664:     ControlStatus processForCondEnd(CFGState &state);
111664:     ControlStatus processForBodyEnd(CFGState &state);
111664:     ControlStatus processForUpdateEnd(CFGState &state);
111929:     ControlStatus processNextTableSwitchCase(CFGState &state);
113028:     ControlStatus processNextLookupSwitchCase(CFGState &state);
124883:     ControlStatus processCondSwitchCase(CFGState &state);
124883:     ControlStatus processCondSwitchBody(CFGState &state);
124883:     ControlStatus processSwitchBreak(JSOp op, jssrcnote *sn);
124883:     ControlStatus processSwitchEnd(DeferredEdge *breaks, jsbytecode *exitpc);
112205:     ControlStatus processAndOrEnd(CFGState &state);
111655:     ControlStatus processReturn(JSOp op);
112478:     ControlStatus processThrow();
111663:     ControlStatus processContinue(JSOp op, jssrcnote *sn);
111663:     ControlStatus processBreak(JSOp op, jssrcnote *sn);
111664:     ControlStatus maybeLoop(JSOp op, jssrcnote *sn);
111662:     bool pushLoop(CFGState::State state, jsbytecode *stopAt, MBasicBlock *entry,
111668:                   jsbytecode *bodyStart, jsbytecode *bodyEnd, jsbytecode *exitpc,
111668:                   jsbytecode *continuepc = NULL);
111655: 
124795:     MBasicBlock *addBlock(MBasicBlock *block, uint32_t loopDepth);
111655:     MBasicBlock *newBlock(MBasicBlock *predecessor, jsbytecode *pc);
124795:     MBasicBlock *newBlock(MBasicBlock *predecessor, jsbytecode *pc, uint32_t loopDepth);
113482:     MBasicBlock *newBlock(MBasicBlock *predecessor, jsbytecode *pc, MResumePoint *priorResumePoint);
124883:     MBasicBlock *newBlockPopN(MBasicBlock *predecessor, jsbytecode *pc, uint32_t popped);
112870:     MBasicBlock *newBlockAfter(MBasicBlock *at, MBasicBlock *predecessor, jsbytecode *pc);
113130:     MBasicBlock *newOsrPreheader(MBasicBlock *header, jsbytecode *loopEntry);
111879:     MBasicBlock *newPendingLoopHeader(MBasicBlock *predecessor, jsbytecode *pc);
111655:     MBasicBlock *newBlock(jsbytecode *pc) {
111655:         return newBlock(NULL, pc);
111655:     }
112870:     MBasicBlock *newBlockAfter(MBasicBlock *at, jsbytecode *pc) {
112870:         return newBlockAfter(at, NULL, pc);
112870:     }
112030: 
112030:     // Given a list of pending breaks, creates a new block and inserts a Goto
112030:     // linking each break to the new block.
111929:     MBasicBlock *createBreakCatchBlock(DeferredEdge *edge, jsbytecode *pc);
112030: 
112030:     // Finishes loops that do not actually loop, containing only breaks or
112030:     // returns.
112030:     ControlStatus processBrokenLoop(CFGState &state);
112030: 
112030:     // Computes loop phis, places them in all successors of a loop, then
112030:     // handles any pending breaks.
112030:     ControlStatus finishLoop(CFGState &state, MBasicBlock *successor);
112030: 
112397:     void assertValidLoopHeadOp(jsbytecode *pc);
112397: 
111664:     ControlStatus forLoop(JSOp op, jssrcnote *sn);
112663:     ControlStatus whileOrForInLoop(JSOp op, jssrcnote *sn);
111664:     ControlStatus doWhileLoop(JSOp op, jssrcnote *sn);
111929:     ControlStatus tableSwitch(JSOp op, jssrcnote *sn);
113028:     ControlStatus lookupSwitch(JSOp op, jssrcnote *sn);
124883:     ControlStatus condSwitch(JSOp op, jssrcnote *sn);
111655: 
112049:     // Please see the Big Honkin' Comment about how resume points work in
111711:     // IonBuilder.cpp, near the definition for this function.
112681:     bool resume(MInstruction *ins, jsbytecode *pc, MResumePoint::Mode mode);
112049:     bool resumeAt(MInstruction *ins, jsbytecode *pc);
112049:     bool resumeAfter(MInstruction *ins);
124557:     bool maybeInsertResume();
111679: 
112397:     void insertRecompileCheck();
112397: 
112425:     bool initParameters();
112108:     void rewriteParameters();
113175:     bool initScopeChain();
111655:     bool pushConstant(const Value &v);
113609:     bool pushTypeBarrier(MInstruction *ins, types::StackTypeSet *actual, types::StackTypeSet *observed);
116269:     void monitorResult(MInstruction *ins, types::TypeSet *barrier, types::TypeSet *types);
112874: 
112874:     JSObject *getSingletonPrototype(JSFunction *target);
112874: 
112874:     MDefinition *createThisNative();
112874:     MDefinition *createThisScripted(MDefinition *callee);
112984:     MDefinition *createThisScriptedSingleton(HandleFunction target, HandleObject proto, MDefinition *callee);
112984:     MDefinition *createThis(HandleFunction target, MDefinition *callee);
125292:     MInstruction *createDeclEnvObject(MDefinition *callee, MDefinition *scopeObj);
113175:     MInstruction *createCallObject(MDefinition *callee, MDefinition *scopeObj);
112874: 
124795:     bool makeCall(HandleFunction target, uint32_t argc, bool constructing);
112920: 
113176:     MDefinition *walkScopeChain(unsigned hops);
113176: 
113380:     MInstruction *addBoundsCheck(MDefinition *index, MDefinition *length);
120777:     MInstruction *addShapeGuard(MDefinition *obj, const Shape *shape, BailoutKind bailoutKind);
113380: 
124795:     JSObject *getNewArrayTemplateObject(uint32_t count);
113485: 
113386:     bool invalidatedIdempotentCache();
113386: 
113436:     bool loadSlot(MDefinition *obj, Shape *shape, MIRType rvalType);
113436:     bool storeSlot(MDefinition *obj, Shape *shape, MDefinition *value, bool needsBarrier);
113436: 
119120:     // jsop_getprop() helpers.
119120:     bool getPropTryArgumentsLength(bool *emitted);
119120:     bool getPropTryConstant(bool *emitted, HandleId id, types::StackTypeSet *barrier,
119120:                             types::StackTypeSet *types, TypeOracle::UnaryTypes unaryTypes);
119120:     bool getPropTryDefiniteSlot(bool *emitted, HandlePropertyName name,
119120:                             types::StackTypeSet *barrier, types::StackTypeSet *types,
119120:                             TypeOracle::Unary unary, TypeOracle::UnaryTypes unaryTypes);
119120:     bool getPropTryCommonGetter(bool *emitted, HandleId id, types::StackTypeSet *barrier,
119120:                                 types::StackTypeSet *types, TypeOracle::UnaryTypes unaryTypes);
119120:     bool getPropTryMonomorphic(bool *emitted, HandleId id, types::StackTypeSet *barrier,
119120:                                TypeOracle::Unary unary, TypeOracle::UnaryTypes unaryTypes);
119120:     bool getPropTryPolymorphic(bool *emitted, HandlePropertyName name, HandleId id,
119120:                                types::StackTypeSet *barrier, types::StackTypeSet *types,
119120:                                TypeOracle::Unary unary, TypeOracle::UnaryTypes unaryTypes);
119120: 
112429:     bool jsop_add(MDefinition *left, MDefinition *right);
112016:     bool jsop_bitnot();
111800:     bool jsop_bitop(JSOp op);
111655:     bool jsop_binary(JSOp op);
112088:     bool jsop_binary(JSOp op, MDefinition *left, MDefinition *right);
112291:     bool jsop_pos();
112012:     bool jsop_neg();
124795:     bool jsop_defvar(uint32_t index);
112064:     bool jsop_notearg();
124795:     bool jsop_funcall(uint32_t argc);
124795:     bool jsop_funapply(uint32_t argc);
124795:     bool jsop_call(uint32_t argc, bool constructing);
111679:     bool jsop_ifeq(JSOp op);
124883:     bool jsop_condswitch();
112205:     bool jsop_andor(JSOp op);
112229:     bool jsop_dup2();
112397:     bool jsop_loophead(jsbytecode *pc);
111996:     bool jsop_compare(JSOp op);
113095:     bool jsop_getgname(HandlePropertyName name);
113095:     bool jsop_setgname(HandlePropertyName name);
113095:     bool jsop_getname(HandlePropertyName name);
122024:     bool jsop_intrinsicname(HandlePropertyName name);
112766:     bool jsop_bindname(PropertyName *name);
112231:     bool jsop_getelem();
112231:     bool jsop_getelem_dense();
112904:     bool jsop_getelem_typed(int arrayType);
113164:     bool jsop_getelem_string();
112231:     bool jsop_setelem();
112231:     bool jsop_setelem_dense();
112936:     bool jsop_setelem_typed(int arrayType);
112309:     bool jsop_length();
112309:     bool jsop_length_fastPath();
113199:     bool jsop_arguments();
113198:     bool jsop_arguments_length();
113198:     bool jsop_arguments_getelem();
113198:     bool jsop_arguments_setelem();
112696:     bool jsop_not();
113095:     bool jsop_getprop(HandlePropertyName name);
113095:     bool jsop_setprop(HandlePropertyName name);
114101:     bool jsop_delprop(HandlePropertyName name);
124795:     bool jsop_newarray(uint32_t count);
113095:     bool jsop_newobject(HandleObject baseObj);
112734:     bool jsop_initelem();
112734:     bool jsop_initelem_dense();
113095:     bool jsop_initprop(HandlePropertyName name);
112541:     bool jsop_regexp(RegExpObject *reobj);
112543:     bool jsop_object(JSObject *obj);
112691:     bool jsop_lambda(JSFunction *fun);
124795:     bool jsop_deflocalfun(uint32_t local, JSFunction *fun);
112372:     bool jsop_this();
112684:     bool jsop_typeof();
112705:     bool jsop_toid();
124795:     bool jsop_iter(uint8_t flags);
113496:     bool jsop_iternext();
112663:     bool jsop_itermore();
112663:     bool jsop_iterend();
119236:     bool jsop_in();
122291:     bool jsop_in_dense();
113170:     bool jsop_instanceof();
113176:     bool jsop_getaliasedvar(ScopeCoordinate sc);
113176:     bool jsop_setaliasedvar(ScopeCoordinate sc);
111655: 
112206:     /* Inlining. */
112206: 
112206:     enum InliningStatus
112206:     {
112206:         InliningStatus_Error,
112206:         InliningStatus_NotInlined,
112206:         InliningStatus_Inlined
112206:     };
112206: 
113334:     // Inlining helpers.
124795:     bool discardCallArgs(uint32_t argc, MDefinitionVector &argv, MBasicBlock *bb);
124795:     bool discardCall(uint32_t argc, MDefinitionVector &argv, MBasicBlock *bb);
113609:     types::StackTypeSet *getInlineReturnTypeSet();
113334:     MIRType getInlineReturnType();
124795:     types::StackTypeSet *getInlineArgTypeSet(uint32_t argc, uint32_t arg);
124795:     MIRType getInlineArgType(uint32_t argc, uint32_t arg);
113334: 
113334:     // Array natives.
124795:     InliningStatus inlineArray(uint32_t argc, bool constructing);
124795:     InliningStatus inlineArrayPopShift(MArrayPopShift::Mode mode, uint32_t argc, bool constructing);
124795:     InliningStatus inlineArrayPush(uint32_t argc, bool constructing);
124795:     InliningStatus inlineArrayConcat(uint32_t argc, bool constructing);
113334: 
113334:     // Math natives.
124795:     InliningStatus inlineMathAbs(uint32_t argc, bool constructing);
124795:     InliningStatus inlineMathFloor(uint32_t argc, bool constructing);
124795:     InliningStatus inlineMathRound(uint32_t argc, bool constructing);
124795:     InliningStatus inlineMathSqrt(uint32_t argc, bool constructing);
124795:     InliningStatus inlineMathMinMax(bool max, uint32_t argc, bool constructing);
124795:     InliningStatus inlineMathPow(uint32_t argc, bool constructing);
124795:     InliningStatus inlineMathRandom(uint32_t argc, bool constructing);
124795:     InliningStatus inlineMathFunction(MMathFunction::Function function, uint32_t argc,
113334:                                       bool constructing);
113334: 
113334:     // String natives.
124795:     InliningStatus inlineStringObject(uint32_t argc, bool constructing);
124795:     InliningStatus inlineStrCharCodeAt(uint32_t argc, bool constructing);
124795:     InliningStatus inlineStrFromCharCode(uint32_t argc, bool constructing);
124795:     InliningStatus inlineStrCharAt(uint32_t argc, bool constructing);
113334: 
116030:     // RegExp natives.
124795:     InliningStatus inlineRegExpTest(uint32_t argc, bool constructing);
116030: 
124795:     InliningStatus inlineNativeCall(JSNative native, uint32_t argc, bool constructing);
113036: 
124795:     bool jsop_call_inline(HandleFunction callee, uint32_t argc, bool constructing,
113431:                           MConstant *constFun, MBasicBlock *bottom,
113431:                           Vector<MDefinition *, 8, IonAllocPolicy> &retvalDefns);
124795:     bool inlineScriptedCall(AutoObjectVector &targets, uint32_t argc, bool constructing,
113609:                             types::StackTypeSet *types, types::StackTypeSet *barrier);
124795:     bool makeInliningDecision(AutoObjectVector &targets, uint32_t argc);
112206: 
124795:     MCall *makeCallHelper(HandleFunction target, uint32_t argc, bool constructing);
124795:     bool makeCallBarrier(HandleFunction target, uint32_t argc, bool constructing,
113609:                          types::StackTypeSet *types, types::StackTypeSet *barrier);
113327: 
113609:     inline bool TestCommonPropFunc(JSContext *cx, types::StackTypeSet *types,
113327:                                    HandleId id, JSFunction **funcp,
124266:                                    bool isGetter, bool *isDOM,
124266:                                    MDefinition **guardOut);
113327: 
113482:     bool annotateGetPropertyCache(JSContext *cx, MDefinition *obj, MGetPropertyCache *getPropCache,
113609:                                   types::StackTypeSet *objTypes, types::StackTypeSet *pushedTypes);
113482: 
113482:     MGetPropertyCache *checkInlineableGetPropertyCache(uint32_t argc);
113482: 
113482:     MPolyInlineDispatch *
113482:     makePolyInlineDispatch(JSContext *cx, AutoObjectVector &targets, int argc,
113482:                            MGetPropertyCache *getPropCache,
113609:                            types::StackTypeSet *types, types::StackTypeSet *barrier,
113482:                            MBasicBlock *bottom,
113482:                            Vector<MDefinition *, 8, IonAllocPolicy> &retvalDefns);
113482: 
124001:     const types::TypeSet *cloneTypeSet(const types::TypeSet *types);
124001: 
115105:     // A builder is inextricably tied to a particular script.
115105:     HeapPtrScript script_;
115105: 
122028:     // If off thread compilation is successful, the final code generator is
122028:     // attached here. Code has been generated, but not linked (there is not yet
122028:     // an IonScript). This is heap allocated, and must be explicitly destroyed.
122028:     CodeGenerator *backgroundCodegen_;
122028: 
112139:   public:
113582:     // Compilation index for this attempt.
113582:     types::RecompileInfo const recompileInfo;
113582: 
113485:     void clearForBackEnd();
113485: 
125006:     UnrootedScript script() const { return script_.get(); }
115105: 
122028:     CodeGenerator *backgroundCodegen() const { return backgroundCodegen_; }
122028:     void setBackgroundCodegen(CodeGenerator *codegen) { backgroundCodegen_ = codegen; }
122028: 
111655:   private:
113485:     JSContext *cx;
113485: 
112139:     jsbytecode *pc;
111655:     MBasicBlock *current;
124795:     uint32_t loopDepth_;
112206: 
112206:     /* Information used for inline-call builders. */
112206:     MResumePoint *callerResumePoint_;
112206:     jsbytecode *callerPC() {
112206:         return callerResumePoint_ ? callerResumePoint_->pc() : NULL;
112206:     }
112753:     IonBuilder *callerBuilder_;
112206: 
111677:     Vector<CFGState, 8, IonAllocPolicy> cfgStack_;
111929:     Vector<ControlFlowInfo, 4, IonAllocPolicy> loops_;
111929:     Vector<ControlFlowInfo, 0, IonAllocPolicy> switches_;
113129:     Vector<MInstruction *, 2, IonAllocPolicy> iterators_;
111685:     TypeOracle *oracle;
112206:     size_t inliningDepth;
113383: 
113383:     // True if script->failedBoundsCheck is set for the current script or
113383:     // an outer script.
113383:     bool failedBoundsCheck_;
113411: 
120777:     // True if script->failedShapeGuard is set for the current script or
120777:     // an outer script.
120777:     bool failedShapeGuard_;
120777: 
113411:     // If this script can use a lazy arguments object, it wil be pre-created
113411:     // here.
113411:     MInstruction *lazyArguments_;
111655: };
111655: 
111655: } // namespace ion
111655: } // namespace js
111655: 
111655: #endif // jsion_bytecode_analyzer_h__
111655: 
