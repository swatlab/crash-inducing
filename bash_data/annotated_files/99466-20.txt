28495: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
28495: 
28495: #include "nsCOMPtr.h"
28495: #include "nsDOMError.h"
28495: #include "nsDOMStorage.h"
28495: #include "nsDOMStorageDBWrapper.h"
28495: #include "nsIFile.h"
75026: #include "nsIURL.h"
28495: #include "nsIVariant.h"
28495: #include "nsIEffectiveTLDService.h"
28495: #include "nsAppDirectoryServiceDefs.h"
28495: #include "mozStorageCID.h"
28495: #include "mozStorageHelper.h"
28495: #include "mozIStorageService.h"
28495: #include "mozIStorageValueArray.h"
28495: #include "mozIStorageFunction.h"
28495: #include "nsPrintfCString.h"
28495: #include "nsNetUtil.h"
28495: 
28495: void ReverseString(const nsCSubstring& source, nsCSubstring& result)
28495: {
28495:   nsACString::const_iterator sourceBegin, sourceEnd;
28495:   source.BeginReading(sourceBegin);
28495:   source.EndReading(sourceEnd);
28495: 
28495:   result.SetLength(source.Length());
28495:   nsACString::iterator destEnd;
28495:   result.EndWriting(destEnd);
28495: 
28495:   while (sourceBegin != sourceEnd) {
28495:     *(--destEnd) = *sourceBegin;
28495:     ++sourceBegin;
28495:   }
28495: }
28495: 
56436: nsDOMStorageDBWrapper::nsDOMStorageDBWrapper()
56436: {
56436: }
56436: 
56436: nsDOMStorageDBWrapper::~nsDOMStorageDBWrapper()
56436: {
56436: }
56436: 
83067: void
83067: nsDOMStorageDBWrapper::Close()
83067: {
83067:   mPersistentDB.Close();
83067:   mChromePersistentDB.Close();
83067: }
83067: 
28495: nsresult
28495: nsDOMStorageDBWrapper::Init()
28495: {
28495:   nsresult rv;
28495: 
52374:   rv = mPersistentDB.Init(NS_LITERAL_STRING("webappsstore.sqlite"));
52374:   NS_ENSURE_SUCCESS(rv, rv);
52374: 
52374:   rv = mChromePersistentDB.Init(NS_LITERAL_STRING("chromeappsstore.sqlite"));
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:   rv = mSessionOnlyDB.Init(&mPersistentDB);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:   rv = mPrivateBrowsingDB.Init();
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:   return NS_OK;
28495: }
28495: 
28495: nsresult
60667: nsDOMStorageDBWrapper::FlushAndDeleteTemporaryTables(bool force)
56436: {
60667:   nsresult rv1, rv2;
60667:   rv1 = mChromePersistentDB.FlushTemporaryTables(force);
60667:   rv2 = mPersistentDB.FlushTemporaryTables(force);
56436: 
60667:   // Everything flushed?  Then no need for a timer.
60667:   if (!mChromePersistentDB.mTempTableLoads.Count() && 
60667:       !mPersistentDB.mTempTableLoads.Count())
60667:     StopTempTableFlushTimer();
56436: 
60667:   return NS_FAILED(rv1) ? rv1 : rv2;
56436: }
56436: 
78721: #define IMPL_FORWARDER_GUTS(_return, _code)                                \
78483:   PR_BEGIN_MACRO                                                      \
78483:   if (aStorage->CanUseChromePersist())                                \
78721:     _return mChromePersistentDB._code;                                \
99466:   if (nsDOMStorageManager::gStorageManager->InPrivateBrowsingMode())  \
78721:     _return mPrivateBrowsingDB._code;                                 \
78483:   if (aStorage->SessionOnly())                                        \
78721:     _return mSessionOnlyDB._code;                                     \
78721:   _return mPersistentDB._code;                                        \
78483:   PR_END_MACRO
78483: 
78721: #define IMPL_FORWARDER(_code)                                  \
78721:   IMPL_FORWARDER_GUTS(return, _code)
78721: 
78721: #define IMPL_VOID_FORWARDER(_code)                                    \
78721:   IMPL_FORWARDER_GUTS((void), _code)
78721: 
56436: nsresult
58092: nsDOMStorageDBWrapper::GetAllKeys(DOMStorageImpl* aStorage,
28495:                                   nsTHashtable<nsSessionStorageEntry>* aKeys)
28495: {
78483:   IMPL_FORWARDER(GetAllKeys(aStorage, aKeys));
28495: }
28495: 
28495: nsresult
58092: nsDOMStorageDBWrapper::GetKeyValue(DOMStorageImpl* aStorage,
28495:                                    const nsAString& aKey,
28495:                                    nsAString& aValue,
79445:                                    bool* aSecure)
28495: {
78483:   IMPL_FORWARDER(GetKeyValue(aStorage, aKey, aValue, aSecure));
28495: }
28495: 
28495: nsresult
58092: nsDOMStorageDBWrapper::SetKey(DOMStorageImpl* aStorage,
28495:                               const nsAString& aKey,
28495:                               const nsAString& aValue,
79445:                               bool aSecure,
28495:                               PRInt32 aQuota,
79445:                               bool aExcludeOfflineFromUsage,
28495:                               PRInt32 *aNewUsage)
28495: {
78483:   IMPL_FORWARDER(SetKey(aStorage, aKey, aValue, aSecure,
78483:                         aQuota, aExcludeOfflineFromUsage, aNewUsage));
28495: }
28495: 
28495: nsresult
58092: nsDOMStorageDBWrapper::SetSecure(DOMStorageImpl* aStorage,
28495:                                  const nsAString& aKey,
79445:                                  const bool aSecure)
28495: {
78483:   IMPL_FORWARDER(SetSecure(aStorage, aKey, aSecure));
28495: }
28495: 
28495: nsresult
58092: nsDOMStorageDBWrapper::RemoveKey(DOMStorageImpl* aStorage,
28495:                                  const nsAString& aKey,
79445:                                  bool aExcludeOfflineFromUsage,
28495:                                  PRInt32 aKeyUsage)
28495: {
78483:   IMPL_FORWARDER(RemoveKey(aStorage, aKey, aExcludeOfflineFromUsage, aKeyUsage));
28495: }
28495: 
28495: nsresult
58092: nsDOMStorageDBWrapper::ClearStorage(DOMStorageImpl* aStorage)
28495: {
78483:   IMPL_FORWARDER(ClearStorage(aStorage));
28495: }
28495: 
78721: void
78721: nsDOMStorageDBWrapper::MarkScopeCached(DOMStorageImpl* aStorage)
78721: {
78721:   IMPL_VOID_FORWARDER(MarkScopeCached(aStorage));
78721: }
78721: 
78721: bool
78721: nsDOMStorageDBWrapper::IsScopeDirty(DOMStorageImpl* aStorage)
78721: {
78721:   IMPL_FORWARDER(IsScopeDirty(aStorage));
78721: }
78721: 
28495: nsresult
28495: nsDOMStorageDBWrapper::DropSessionOnlyStoragesForHost(const nsACString& aHostName)
28495: {
80486:   return mSessionOnlyDB.RemoveOwner(aHostName, true);
28495: }
28495: 
28495: nsresult
28495: nsDOMStorageDBWrapper::DropPrivateBrowsingStorages()
28495: {
28495:   return mPrivateBrowsingDB.RemoveAll();
28495: }
28495: 
28495: nsresult
28495: nsDOMStorageDBWrapper::RemoveOwner(const nsACString& aOwner,
79445:                                    bool aIncludeSubDomains)
28495: {
28495:   nsresult rv;
28495: 
28495:   rv = mPrivateBrowsingDB.RemoveOwner(aOwner, aIncludeSubDomains);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
99466:   if (nsDOMStorageManager::gStorageManager->InPrivateBrowsingMode())
99466:     return NS_OK;
99466: 
28495:   rv = mSessionOnlyDB.RemoveOwner(aOwner, aIncludeSubDomains);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:   rv = mPersistentDB.RemoveOwner(aOwner, aIncludeSubDomains);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:   return rv;
28495: }
28495: 
28495: 
28495: nsresult
28495: nsDOMStorageDBWrapper::RemoveOwners(const nsTArray<nsString> &aOwners,
79445:                                     bool aIncludeSubDomains, bool aMatch)
28495: {
28495:   nsresult rv;
28495: 
28495:   rv = mPrivateBrowsingDB.RemoveOwners(aOwners, aIncludeSubDomains, aMatch);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
99466:   if (nsDOMStorageManager::gStorageManager->InPrivateBrowsingMode())
99466:     return NS_OK;
99466: 
28495:   rv = mSessionOnlyDB.RemoveOwners(aOwners, aIncludeSubDomains, aMatch);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:   rv = mPersistentDB.RemoveOwners(aOwners, aIncludeSubDomains, aMatch);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:   return rv;
28495: }
28495: 
28495: nsresult
99466: nsDOMStorageDBWrapper::RemoveAll()
99466: {
99466:   nsresult rv;
99466: 
99466:   rv = mPrivateBrowsingDB.RemoveAll();
99466:   NS_ENSURE_SUCCESS(rv, rv);
99466: 
99466:   if (nsDOMStorageManager::gStorageManager->InPrivateBrowsingMode())
99466:     return NS_OK;
99466: 
99466:   rv = mSessionOnlyDB.RemoveAll();
99466:   NS_ENSURE_SUCCESS(rv, rv);
99466: 
99466:   rv = mPersistentDB.RemoveAll();
99466:   NS_ENSURE_SUCCESS(rv, rv);
99466: 
99466:   return rv;
99466: }
99466: 
99466: nsresult
58092: nsDOMStorageDBWrapper::GetUsage(DOMStorageImpl* aStorage,
79445:                                 bool aExcludeOfflineFromUsage, PRInt32 *aUsage)
28495: {
78483:   IMPL_FORWARDER(GetUsage(aStorage, aExcludeOfflineFromUsage, aUsage));
28495: }
28495: 
28495: nsresult
28495: nsDOMStorageDBWrapper::GetUsage(const nsACString& aDomain,
99466:                                 bool aIncludeSubDomains, PRInt32 *aUsage)
28495: {
99466:   if (nsDOMStorageManager::gStorageManager->InPrivateBrowsingMode())
28495:     return mPrivateBrowsingDB.GetUsage(aDomain, aIncludeSubDomains, aUsage);
28495: 
28495: #if 0
28495:   // XXX Check where from all this method gets called, not sure this should
28495:   // include any potential session-only data
28495:   nsresult rv;
28495:   rv = mSessionOnlyDB.GetUsage(aDomain, aIncludeSubDomains, aUsage);
28495:   if (NS_SUECEEDED(rv))
28495:     return rv;
28495: #endif
28495: 
28495:   return mPersistentDB.GetUsage(aDomain, aIncludeSubDomains, aUsage);
28495: }
28495: 
28495: nsresult
28495: nsDOMStorageDBWrapper::CreateOriginScopeDBKey(nsIURI* aUri, nsACString& aKey)
28495: {
28495:   nsresult rv;
28495: 
28495:   rv = CreateDomainScopeDBKey(aUri, aKey);
28495:   if (NS_FAILED(rv))
28495:     return rv;
28495: 
28495:   nsCAutoString scheme;
28495:   rv = aUri->GetScheme(scheme);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:   aKey.AppendLiteral(":");
28495:   aKey.Append(scheme);
28495: 
28495:   PRInt32 port = NS_GetRealPort(aUri);
28495:   if (port != -1) {
28495:     aKey.AppendLiteral(":");
96873:     aKey.Append(nsPrintfCString("%d", port));
28495:   }
28495: 
28495:   return NS_OK;
28495: }
28495: 
28495: nsresult
28495: nsDOMStorageDBWrapper::CreateDomainScopeDBKey(nsIURI* aUri, nsACString& aKey)
28495: {
28495:   nsresult rv;
28495: 
43675:   nsCAutoString domainScope;
43675:   rv = aUri->GetAsciiHost(domainScope);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
43675:   if (domainScope.IsEmpty()) {
43675:     // About pages have an empty host but a valid path.  Since they are handled
43675:     // internally by our own redirector, we can trust them and use path as key.
75026:     // if file:/// protocol, let's make the exact directory the domain
79445:     bool isScheme = false;
75026:     if ((NS_SUCCEEDED(aUri->SchemeIs("about", &isScheme)) && isScheme) ||
75026:         (NS_SUCCEEDED(aUri->SchemeIs("moz-safe-about", &isScheme)) && isScheme)) {
43675:       rv = aUri->GetPath(domainScope);
43675:       NS_ENSURE_SUCCESS(rv, rv);
61752:       // While the host is always canonicalized to lowercase, the path is not,
61752:       // thus need to force the casing.
61752:       ToLowerCase(domainScope);
43675:     }
75026:     else if (NS_SUCCEEDED(aUri->SchemeIs("file", &isScheme)) && isScheme) {
75026:       nsCOMPtr<nsIURL> url = do_QueryInterface(aUri, &rv);
75026:       NS_ENSURE_SUCCESS(rv, rv);
75026:       rv = url->GetDirectory(domainScope);
75026:       NS_ENSURE_SUCCESS(rv, rv);
75026:     }
43675:   }
43675: 
43675:   rv = CreateDomainScopeDBKey(domainScope, aKey);
28495:   NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:   return NS_OK;
28495: }
28495: 
28495: nsresult
28495: nsDOMStorageDBWrapper::CreateDomainScopeDBKey(const nsACString& aAsciiDomain,
28495:                                               nsACString& aKey)
28495: {
28495:   if (aAsciiDomain.IsEmpty())
28495:     return NS_ERROR_NOT_AVAILABLE;
28495: 
28495:   ReverseString(aAsciiDomain, aKey);
28495: 
28495:   aKey.AppendLiteral(".");
28495:   return NS_OK;
28495: }
28495: 
28495: nsresult
28495: nsDOMStorageDBWrapper::CreateQuotaDomainDBKey(const nsACString& aAsciiDomain,
79445:                                               bool aIncludeSubDomains,
79445:                                               bool aEffectiveTLDplus1Only,
28495:                                               nsACString& aKey)
28495: {
28495:   nsresult rv;
28495: 
34057:   nsCAutoString subdomainsDBKey;
34057:   if (aEffectiveTLDplus1Only) {
28495:     nsCOMPtr<nsIEffectiveTLDService> eTLDService(do_GetService(
28495:       NS_EFFECTIVETLDSERVICE_CONTRACTID, &rv));
28495:     NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:     nsCOMPtr<nsIURI> uri;
28495:     rv = NS_NewURI(getter_AddRefs(uri), NS_LITERAL_CSTRING("http://") + aAsciiDomain);
28495:     NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:     nsCAutoString eTLDplusOne;
28495:     rv = eTLDService->GetBaseDomain(uri, 0, eTLDplusOne);
28495:     if (NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS == rv) {
28495:       // XXX bug 357323 - what to do for localhost/file exactly?
28495:       eTLDplusOne = aAsciiDomain;
28495:       rv = NS_OK;
28495:     }
28495:     NS_ENSURE_SUCCESS(rv, rv);
28495: 
28495:     CreateDomainScopeDBKey(eTLDplusOne, subdomainsDBKey);
34057:   }
34057:   else
34057:     CreateDomainScopeDBKey(aAsciiDomain, subdomainsDBKey);
28495: 
28495:   if (!aIncludeSubDomains)
28495:     subdomainsDBKey.AppendLiteral(":");
28495: 
28495:   aKey.Assign(subdomainsDBKey);
28495:   return NS_OK;
28495: }
34057: 
34057: nsresult
34057: nsDOMStorageDBWrapper::GetDomainFromScopeKey(const nsACString& aScope,
34057:                                          nsACString& aDomain)
34057: {
34057:   nsCAutoString reverseDomain, scope;
34057:   scope = aScope;
34057:   scope.Left(reverseDomain, scope.FindChar(':')-1);
34057: 
34057:   ReverseString(reverseDomain, aDomain);
34057:   return NS_OK;
34057: }
59411: 
59411: void
59411: nsDOMStorageDBWrapper::EnsureTempTableFlushTimer()
59411: {
59411:   if (!mTempTableFlushTimer) {
59411:     nsresult rv;
59411:     mTempTableFlushTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
59411: 
59411:     if (!NS_SUCCEEDED(rv)) {
59411:       mTempTableFlushTimer = nsnull;
59411:       return;
59411:     }
59411: 
59411:     mTempTableFlushTimer->Init(nsDOMStorageManager::gStorageManager, 5000,
59411:                                nsITimer::TYPE_REPEATING_SLACK);
59411:   }
59411: }
59411: 
59411: void
59411: nsDOMStorageDBWrapper::StopTempTableFlushTimer()
59411: {
59411:   if (mTempTableFlushTimer) {
59411:     mTempTableFlushTimer->Cancel();
59411:     mTempTableFlushTimer = nsnull;
59411:   }
59411: }
59411: 
