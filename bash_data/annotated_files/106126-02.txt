     1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
  3573:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* The "Components" xpcom objects for JavaScript. */
     1: 
 86979: #include "mozilla/unused.h"
 86979: 
     1: #include "xpcprivate.h"
 98833: #include "XPCQuickStubs.h"
     1: #include "nsReadableUtils.h"
  1493: #include "xpcIJSModuleLoader.h"
     1: #include "nsIScriptObjectPrincipal.h"
     1: #include "nsIDOMWindow.h"
 80384: #include "XPCJSWeakReference.h"
 21405: #include "XPCWrapper.h"
 55590: #include "jsproxy.h"
 55675: #include "WrapperFactory.h"
 55675: #include "XrayWrapper.h"
 55675: #include "nsNullPrincipal.h"
 59512: #include "nsJSUtils.h"
  1493: #include "mozJSComponentLoader.h"
 72859: #include "nsContentUtils.h"
 81273: #include "jsgc.h"
 86469: #include "jsfriendapi.h"
 97171: #include "AccessCheck.h"
 97422: #include "mozilla/dom/BindingUtils.h"
101313: #include "mozilla/Preferences.h"
101616: #include "nsPrincipal.h"
101869: #include "mozilla/Attributes.h"
103385: #include "nsIScriptContext.h"
 81273: 
 86979: using namespace mozilla;
 81273: using namespace js;
 99328: using namespace xpc;
 94512: 
 97422: using mozilla::dom::DestroyProtoOrIfaceCache;
 94512: 
     1: /***************************************************************************/
     1: // stuff used by all
     1: 
 91237: static nsresult ThrowAndFail(unsigned errNum, JSContext* cx, bool* retval)
     1: {
     1:     XPCThrower::Throw(errNum, cx);
 82794:     *retval = false;
     1:     return NS_OK;
     1: }
     1: 
     1: static JSBool
     1: JSValIsInterfaceOfType(JSContext *cx, jsval v, REFNSIID iid)
     1: {
     1:     nsCOMPtr<nsIXPConnect> xpc;
     1:     nsCOMPtr<nsIXPConnectWrappedNative> wn;
     1:     nsCOMPtr<nsISupports> sup;
     1:     nsISupports* iface;
     1:     if (!JSVAL_IS_PRIMITIVE(v) &&
     1:         nsnull != (xpc = nsXPConnect::GetXPConnect()) &&
     1:         NS_SUCCEEDED(xpc->GetWrappedNativeOfJSObject(cx, JSVAL_TO_OBJECT(v),
     1:                                                      getter_AddRefs(wn))) && wn &&
 80389:         NS_SUCCEEDED(wn->Native()->QueryInterface(iid, (void**)&iface)) && iface) {
     1:         NS_RELEASE(iface);
 82794:         return true;
 82794:     }
 82794:     return false;
     1: }
     1: 
     1: char* xpc_CloneAllAccess()
     1: {
     1:     static const char allAccess[] = "AllAccess";
     1:     return (char*)nsMemory::Clone(allAccess, sizeof(allAccess));
     1: }
     1: 
     1: char * xpc_CheckAccessList(const PRUnichar* wideName, const char* list[])
     1: {
     1:     nsCAutoString asciiName;
     1:     CopyUTF16toUTF8(nsDependentString(wideName), asciiName);
     1: 
     1:     for (const char** p = list; *p; p++)
     1:         if (!strcmp(*p, asciiName.get()))
     1:             return xpc_CloneAllAccess();
     1: 
     1:     return nsnull;
     1: }
     1: 
     1: /***************************************************************************/
 76740: /***************************************************************************/
 76740: /***************************************************************************/
 76740: 
 76740: 
 76740: 
 76740: class nsXPCComponents_Interfaces :
 76740:             public nsIXPCComponents_Interfaces,
 76740:             public nsIXPCScriptable,
 76740:             public nsIClassInfo,
 76740:             public nsISecurityCheckedComponent
 76740: {
 76740: public:
 76740:     // all the interface method declarations...
 76740:     NS_DECL_ISUPPORTS
 76740:     NS_DECL_NSIXPCCOMPONENTS_INTERFACES
 76740:     NS_DECL_NSIXPCSCRIPTABLE
 76740:     NS_DECL_NSICLASSINFO
 76740:     NS_DECL_NSISECURITYCHECKEDCOMPONENT
 76740: 
 76740: public:
 76740:     nsXPCComponents_Interfaces();
 76740:     virtual ~nsXPCComponents_Interfaces();
 76740: 
 76740: private:
 76740:     nsCOMPtr<nsIInterfaceInfoManager> mManager;
 76740: };
     1: 
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Interfaces::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 75171:     const PRUint32 count = 3;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
 76740:     PUSH_IID(nsIXPCComponents_Interfaces)
     1:     PUSH_IID(nsIXPCScriptable)
 75171:     PUSH_IID(nsISecurityCheckedComponent)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Interfaces::GetHelperForLanguage(PRUint32 language,
     1:                                                  nsISupports **retval)
     1: {
     1:     *retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Interfaces::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Interfaces::GetClassDescription(char * *aClassDescription)
     1: {
     1:     static const char classDescription[] = "XPCComponents_Interfaces";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Interfaces::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCComponents_Interfaces::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Interfaces::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Interfaces::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: nsXPCComponents_Interfaces::nsXPCComponents_Interfaces() :
     1:     mManager(do_GetService(NS_INTERFACEINFOMANAGER_SERVICE_CONTRACTID))
     1: {
     1: }
     1: 
     1: nsXPCComponents_Interfaces::~nsXPCComponents_Interfaces()
     1: {
     1:     // empty
     1: }
     1: 
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Interfaces)
 76740:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Interfaces)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
 75171:   NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
 76740:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Interfaces)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Interfaces)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Interfaces)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_Interfaces
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_Interfaces"
     1: #define                             XPC_MAP_WANT_NEWRESOLVE
     1: #define                             XPC_MAP_WANT_NEWENUMERATE
     1: #define XPC_MAP_FLAGS               nsIXPCScriptable::DONT_ENUM_STATIC_PROPS |\
     1:                                     nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
     1: 
 79445: /* bool newEnumerate (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 enum_op, in JSValPtr statep, out JSID idp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Interfaces::NewEnumerate(nsIXPConnectWrappedNative *wrapper,
     1:                                          JSContext * cx, JSObject * obj,
     1:                                          PRUint32 enum_op, jsval * statep,
 79445:                                          jsid * idp, bool *_retval)
     1: {
     1:     nsIEnumerator* e;
     1: 
 80389:     switch (enum_op) {
     1:         case JSENUMERATE_INIT:
 47569:         case JSENUMERATE_INIT_ALL:
     1:         {
     1:             if (!mManager ||
     1:                 NS_FAILED(mManager->EnumerateInterfaces(&e)) || !e ||
     1:                 NS_FAILED(e->First()))
     1: 
     1:             {
     1:                 *statep = JSVAL_NULL;
     1:                 return NS_ERROR_UNEXPECTED;
     1:             }
     1: 
     1:             *statep = PRIVATE_TO_JSVAL(e);
     1:             if (idp)
 48470:                 *idp = INT_TO_JSID(0); // indicate that we don't know the count
     1:             return NS_OK;
     1:         }
     1:         case JSENUMERATE_NEXT:
     1:         {
     1:             nsCOMPtr<nsISupports> isup;
     1: 
     1:             e = (nsIEnumerator*) JSVAL_TO_PRIVATE(*statep);
     1: 
 80389:             while (1) {
     1:                 if (NS_ENUMERATOR_FALSE == e->IsDone() &&
 80389:                     NS_SUCCEEDED(e->CurrentItem(getter_AddRefs(isup))) && isup) {
     1:                     e->Next();
     1:                     nsCOMPtr<nsIInterfaceInfo> iface(do_QueryInterface(isup));
 80389:                     if (iface) {
     1:                         JSString* idstr;
     1:                         const char* name;
 79445:                         bool scriptable;
     1: 
     1:                         if (NS_SUCCEEDED(iface->IsScriptable(&scriptable)) &&
 80389:                             !scriptable) {
     1:                             continue;
     1:                         }
     1: 
     1:                         if (NS_SUCCEEDED(iface->GetNameShared(&name)) && name &&
     1:                             nsnull != (idstr = JS_NewStringCopyZ(cx, name)) &&
 80389:                             JS_ValueToId(cx, STRING_TO_JSVAL(idstr), idp)) {
     1:                             return NS_OK;
     1:                         }
     1:                     }
     1:                 }
     1:                 // else...
     1:                 break;
     1:             }
     1:             // FALL THROUGH
     1:         }
     1: 
     1:         case JSENUMERATE_DESTROY:
     1:         default:
     1:             e = (nsIEnumerator*) JSVAL_TO_PRIVATE(*statep);
     1:             NS_IF_RELEASE(e);
     1:             *statep = JSVAL_NULL;
     1:             return NS_OK;
     1:     }
     1: }
     1: 
 79445: /* bool newResolve (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval id, in PRUint32 flags, out JSObjectPtr objp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Interfaces::NewResolve(nsIXPConnectWrappedNative *wrapper,
     1:                                        JSContext * cx, JSObject * obj,
 48470:                                        jsid id, PRUint32 flags,
 79445:                                        JSObject * *objp, bool *_retval)
     1: {
 57812:     JSAutoByteString name;
     1:     if (mManager &&
 48470:         JSID_IS_STRING(id) &&
 57812:         name.encode(cx, JSID_TO_STRING(id)) &&
 80389:         name.ptr()[0] != '{') { // we only allow interfaces by name here
     1:         nsCOMPtr<nsIInterfaceInfo> info;
 57812:         mManager->GetInfoForName(name.ptr(), getter_AddRefs(info));
     1:         if (!info)
     1:             return NS_OK;
     1: 
     1:         nsCOMPtr<nsIJSIID> nsid =
  3233:             dont_AddRef(static_cast<nsIJSIID*>(nsJSIID::NewID(info)));
     1: 
 80389:         if (nsid) {
     1:             nsCOMPtr<nsIXPConnect> xpc;
     1:             wrapper->GetXPConnect(getter_AddRefs(xpc));
 80389:             if (xpc) {
     1:                 nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     1:                 if (NS_SUCCEEDED(xpc->WrapNative(cx, obj,
  3233:                                                  static_cast<nsIJSIID*>(nsid),
     1:                                                  NS_GET_IID(nsIJSIID),
 80389:                                                  getter_AddRefs(holder)))) {
     1:                     JSObject* idobj;
 80389:                     if (holder && NS_SUCCEEDED(holder->GetJSObject(&idobj))) {
     1:                         *objp = obj;
 48470:                         *_retval = JS_DefinePropertyById(cx, obj, id,
     1:                                                          OBJECT_TO_JSVAL(idobj),
     1:                                                          nsnull, nsnull,
     1:                                                          JSPROP_ENUMERATE |
     1:                                                          JSPROP_READONLY |
 26167:                                                          JSPROP_PERMANENT);
     1:                     }
     1:                 }
     1:             }
     1:         }
     1:     }
     1:     return NS_OK;
     1: }
     1: 
 75171: /* string canCreateWrapper (in nsIIDPtr iid); */
 75171: NS_IMETHODIMP
 75171: nsXPCComponents_Interfaces::CanCreateWrapper(const nsIID * iid, char **_retval)
 75171: {
 75171:     // We let anyone do this...
 75171:     *_retval = xpc_CloneAllAccess();
 75171:     return NS_OK;
 75171: }
 75171: 
 75171: /* string canCallMethod (in nsIIDPtr iid, in wstring methodName); */
 75171: NS_IMETHODIMP
 75171: nsXPCComponents_Interfaces::CanCallMethod(const nsIID * iid, const PRUnichar *methodName, char **_retval)
 75171: {
 75171:     // If you have to ask, then the answer is NO
 75171:     *_retval = nsnull;
 75171:     return NS_OK;
 75171: }
 75171: 
 75171: /* string canGetProperty (in nsIIDPtr iid, in wstring propertyName); */
 75171: NS_IMETHODIMP
 75171: nsXPCComponents_Interfaces::CanGetProperty(const nsIID * iid, const PRUnichar *propertyName, char **_retval)
 75171: {
 75171:     // If you have to ask, then the answer is NO
 75171:     *_retval = nsnull;
 75171:     return NS_OK;
 75171: }
 75171: 
 75171: /* string canSetProperty (in nsIIDPtr iid, in wstring propertyName); */
 75171: NS_IMETHODIMP
 75171: nsXPCComponents_Interfaces::CanSetProperty(const nsIID * iid, const PRUnichar *propertyName, char **_retval)
 75171: {
 75171:     // If you have to ask, then the answer is NO
 75171:     *_retval = nsnull;
 75171:     return NS_OK;
 75171: }
 75171: 
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: 
     1: class nsXPCComponents_InterfacesByID :
 76740:             public nsIXPCComponents_InterfacesByID,
     1:             public nsIXPCScriptable,
 75171:             public nsIClassInfo,
 75171:             public nsISecurityCheckedComponent
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
 76740:     NS_DECL_NSIXPCCOMPONENTS_INTERFACESBYID
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSICLASSINFO
 75171:     NS_DECL_NSISECURITYCHECKEDCOMPONENT
     1: 
     1: public:
     1:     nsXPCComponents_InterfacesByID();
     1:     virtual ~nsXPCComponents_InterfacesByID();
     1: 
     1: private:
     1:     nsCOMPtr<nsIInterfaceInfoManager> mManager;
     1: };
     1: 
     1: /***************************************************************************/
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_InterfacesByID::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 75171:     const PRUint32 count = 3;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
 76740:     PUSH_IID(nsIXPCComponents_InterfacesByID)
     1:     PUSH_IID(nsIXPCScriptable)
 75171:     PUSH_IID(nsISecurityCheckedComponent)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_InterfacesByID::GetHelperForLanguage(PRUint32 language,
     1:                                                      nsISupports **retval)
     1: {
     1:     *retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_InterfacesByID::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_InterfacesByID::GetClassDescription(char * *aClassDescription)
     1: {
 76889:     static const char classDescription[] = "XPCComponents_InterfacesByID";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_InterfacesByID::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCComponents_InterfacesByID::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_InterfacesByID::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_InterfacesByID::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: nsXPCComponents_InterfacesByID::nsXPCComponents_InterfacesByID() :
     1:     mManager(do_GetService(NS_INTERFACEINFOMANAGER_SERVICE_CONTRACTID))
     1: {
     1: }
     1: 
     1: nsXPCComponents_InterfacesByID::~nsXPCComponents_InterfacesByID()
     1: {
     1:     // empty
     1: }
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_InterfacesByID)
 76740:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_InterfacesByID)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
 75171:   NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
 76740:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_InterfacesByID)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_InterfacesByID)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_InterfacesByID)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_InterfacesByID
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_InterfacesByID"
     1: #define                             XPC_MAP_WANT_NEWRESOLVE
     1: #define                             XPC_MAP_WANT_NEWENUMERATE
     1: #define XPC_MAP_FLAGS               nsIXPCScriptable::DONT_ENUM_STATIC_PROPS |\
     1:                                     nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
 79445: /* bool newEnumerate (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 enum_op, in JSValPtr statep, out JSID idp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_InterfacesByID::NewEnumerate(nsIXPConnectWrappedNative *wrapper,
     1:                                              JSContext * cx, JSObject * obj,
     1:                                              PRUint32 enum_op, jsval * statep,
 79445:                                              jsid * idp, bool *_retval)
     1: {
     1:     nsIEnumerator* e;
     1: 
 80389:     switch (enum_op) {
     1:         case JSENUMERATE_INIT:
 47569:         case JSENUMERATE_INIT_ALL:
     1:         {
     1:             if (!mManager ||
     1:                 NS_FAILED(mManager->EnumerateInterfaces(&e)) || !e ||
     1:                 NS_FAILED(e->First()))
     1: 
     1:             {
     1:                 *statep = JSVAL_NULL;
     1:                 return NS_ERROR_UNEXPECTED;
     1:             }
     1: 
     1:             *statep = PRIVATE_TO_JSVAL(e);
     1:             if (idp)
 48470:                 *idp = INT_TO_JSID(0); // indicate that we don't know the count
     1:             return NS_OK;
     1:         }
     1:         case JSENUMERATE_NEXT:
     1:         {
     1:             nsCOMPtr<nsISupports> isup;
     1: 
     1:             e = (nsIEnumerator*) JSVAL_TO_PRIVATE(*statep);
     1: 
 80389:             while (1) {
     1:                 if (NS_ENUMERATOR_FALSE == e->IsDone() &&
 80389:                     NS_SUCCEEDED(e->CurrentItem(getter_AddRefs(isup))) && isup) {
     1:                     e->Next();
     1:                     nsCOMPtr<nsIInterfaceInfo> iface(do_QueryInterface(isup));
 80389:                     if (iface) {
     1:                         nsIID const *iid;
 10204:                         char idstr[NSID_LENGTH];
     1:                         JSString* jsstr;
 79445:                         bool scriptable;
     1: 
     1:                         if (NS_SUCCEEDED(iface->IsScriptable(&scriptable)) &&
 80389:                             !scriptable) {
     1:                             continue;
     1:                         }
     1: 
 80389:                         if (NS_SUCCEEDED(iface->GetIIDShared(&iid))) {
 10204:                             iid->ToProvidedString(idstr);
     1:                             jsstr = JS_NewStringCopyZ(cx, idstr);
     1:                             if (jsstr &&
 80389:                                 JS_ValueToId(cx, STRING_TO_JSVAL(jsstr), idp)) {
     1:                                 return NS_OK;
     1:                             }
     1:                         }
     1:                     }
     1:                 }
     1:                 // else...
     1:                 break;
     1:             }
     1:             // FALL THROUGH
     1:         }
     1: 
     1:         case JSENUMERATE_DESTROY:
     1:         default:
     1:             e = (nsIEnumerator*) JSVAL_TO_PRIVATE(*statep);
     1:             NS_IF_RELEASE(e);
     1:             *statep = JSVAL_NULL;
     1:             return NS_OK;
     1:     }
     1: }
     1: 
 79445: /* bool newResolve (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval id, in PRUint32 flags, out JSObjectPtr objp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_InterfacesByID::NewResolve(nsIXPConnectWrappedNative *wrapper,
     1:                                            JSContext * cx, JSObject * obj,
 48470:                                            jsid id, PRUint32 flags,
 79445:                                            JSObject * *objp, bool *_retval)
     1: {
     1:     const jschar* name = nsnull;
     1: 
     1:     if (mManager &&
 48470:         JSID_IS_STRING(id) &&
 48470:         38 == JS_GetStringLength(JSID_TO_STRING(id)) &&
 80389:         nsnull != (name = JS_GetInternedStringChars(JSID_TO_STRING(id)))) {
     1:         nsID iid;
 59889:         if (!iid.Parse(NS_ConvertUTF16toUTF8(name).get()))
     1:             return NS_OK;
     1: 
     1:         nsCOMPtr<nsIInterfaceInfo> info;
     1:         mManager->GetInfoForIID(&iid, getter_AddRefs(info));
     1:         if (!info)
     1:             return NS_OK;
     1: 
     1:         nsCOMPtr<nsIJSIID> nsid =
  3233:             dont_AddRef(static_cast<nsIJSIID*>(nsJSIID::NewID(info)));
     1: 
     1:         if (!nsid)
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:         nsCOMPtr<nsIXPConnect> xpc;
     1:         wrapper->GetXPConnect(getter_AddRefs(xpc));
 80389:         if (xpc) {
     1:             nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     1:             if (NS_SUCCEEDED(xpc->WrapNative(cx, obj,
  3233:                                              static_cast<nsIJSIID*>(nsid),
     1:                                              NS_GET_IID(nsIJSIID),
 80389:                                              getter_AddRefs(holder)))) {
     1:                 JSObject* idobj;
 80389:                 if (holder && NS_SUCCEEDED(holder->GetJSObject(&idobj))) {
     1:                     *objp = obj;
 48470:                     *_retval =
 48470:                         JS_DefinePropertyById(cx, obj, id,
     1:                                               OBJECT_TO_JSVAL(idobj),
     1:                                               nsnull, nsnull,
     1:                                               JSPROP_ENUMERATE |
     1:                                               JSPROP_READONLY |
 26167:                                               JSPROP_PERMANENT);
     1:                 }
     1:             }
     1:         }
     1:     }
     1:     return NS_OK;
     1: }
     1: 
 75171: /* string canCreateWrapper (in nsIIDPtr iid); */
 75171: NS_IMETHODIMP
 75171: nsXPCComponents_InterfacesByID::CanCreateWrapper(const nsIID * iid, char **_retval)
 75171: {
 75171:     // We let anyone do this...
 75171:     *_retval = xpc_CloneAllAccess();
 75171:     return NS_OK;
 75171: }
 75171: 
 75171: /* string canCallMethod (in nsIIDPtr iid, in wstring methodName); */
 75171: NS_IMETHODIMP
 75171: nsXPCComponents_InterfacesByID::CanCallMethod(const nsIID * iid, const PRUnichar *methodName, char **_retval)
 75171: {
 75171:     // If you have to ask, then the answer is NO
 75171:     *_retval = nsnull;
 75171:     return NS_OK;
 75171: }
 75171: 
 75171: /* string canGetProperty (in nsIIDPtr iid, in wstring propertyName); */
 75171: NS_IMETHODIMP
 75171: nsXPCComponents_InterfacesByID::CanGetProperty(const nsIID * iid, const PRUnichar *propertyName, char **_retval)
 75171: {
 75171:     // If you have to ask, then the answer is NO
 75171:     *_retval = nsnull;
 75171:     return NS_OK;
 75171: }
 75171: 
 75171: /* string canSetProperty (in nsIIDPtr iid, in wstring propertyName); */
 75171: NS_IMETHODIMP
 75171: nsXPCComponents_InterfacesByID::CanSetProperty(const nsIID * iid, const PRUnichar *propertyName, char **_retval)
 75171: {
 75171:     // If you have to ask, then the answer is NO
 75171:     *_retval = nsnull;
 75171:     return NS_OK;
 75171: }
 75171: 
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: 
     1: 
     1: 
     1: class nsXPCComponents_Classes :
     1:   public nsIXPCComponents_Classes,
     1:   public nsIXPCScriptable,
     1:   public nsIClassInfo
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCCOMPONENTS_CLASSES
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSICLASSINFO
     1: 
     1: public:
     1:     nsXPCComponents_Classes();
     1:     virtual ~nsXPCComponents_Classes();
     1: };
     1: 
     1: /***************************************************************************/
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Classes::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 68602:     const PRUint32 count = 2;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
     1:     PUSH_IID(nsIXPCComponents_Classes)
     1:     PUSH_IID(nsIXPCScriptable)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Classes::GetHelperForLanguage(PRUint32 language,
     1:                                               nsISupports **retval)
     1: {
     1:     *retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Classes::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Classes::GetClassDescription(char * *aClassDescription)
     1: {
     1:     static const char classDescription[] = "XPCComponents_Classes";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Classes::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCComponents_Classes::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Classes::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Classes::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: nsXPCComponents_Classes::nsXPCComponents_Classes()
     1: {
     1: }
     1: 
     1: nsXPCComponents_Classes::~nsXPCComponents_Classes()
     1: {
     1:     // empty
     1: }
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Classes)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Classes)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Classes)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Classes)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Classes)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_Classes
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_Classes"
     1: #define                             XPC_MAP_WANT_NEWRESOLVE
     1: #define                             XPC_MAP_WANT_NEWENUMERATE
     1: #define XPC_MAP_FLAGS               nsIXPCScriptable::DONT_ENUM_STATIC_PROPS |\
     1:                                     nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
     1: 
 79445: /* bool newEnumerate (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 enum_op, in JSValPtr statep, out JSID idp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Classes::NewEnumerate(nsIXPConnectWrappedNative *wrapper,
     1:                                       JSContext * cx, JSObject * obj,
     1:                                       PRUint32 enum_op, jsval * statep,
 79445:                                       jsid * idp, bool *_retval)
     1: {
     1:     nsISimpleEnumerator* e;
     1: 
 80389:     switch (enum_op) {
     1:         case JSENUMERATE_INIT:
 47569:         case JSENUMERATE_INIT_ALL:
     1:         {
     1:             nsCOMPtr<nsIComponentRegistrar> compMgr;
     1:             if (NS_FAILED(NS_GetComponentRegistrar(getter_AddRefs(compMgr))) || !compMgr ||
 80389:                 NS_FAILED(compMgr->EnumerateContractIDs(&e)) || !e ) {
     1:                 *statep = JSVAL_NULL;
     1:                 return NS_ERROR_UNEXPECTED;
     1:             }
     1: 
     1:             *statep = PRIVATE_TO_JSVAL(e);
     1:             if (idp)
 48470:                 *idp = INT_TO_JSID(0); // indicate that we don't know the count
     1:             return NS_OK;
     1:         }
     1:         case JSENUMERATE_NEXT:
     1:         {
     1:             nsCOMPtr<nsISupports> isup;
 79445:             bool hasMore;
     1:             e = (nsISimpleEnumerator*) JSVAL_TO_PRIVATE(*statep);
     1: 
     1:             if (NS_SUCCEEDED(e->HasMoreElements(&hasMore)) && hasMore &&
 80389:                 NS_SUCCEEDED(e->GetNext(getter_AddRefs(isup))) && isup) {
     1:                 nsCOMPtr<nsISupportsCString> holder(do_QueryInterface(isup));
 80389:                 if (holder) {
     1:                     nsCAutoString name;
 80389:                     if (NS_SUCCEEDED(holder->GetData(name))) {
     1:                         JSString* idstr = JS_NewStringCopyN(cx, name.get(), name.Length());
     1:                         if (idstr &&
 80389:                             JS_ValueToId(cx, STRING_TO_JSVAL(idstr), idp)) {
     1:                             return NS_OK;
     1:                         }
     1:                     }
     1:                 }
     1:             }
     1:             // else... FALL THROUGH
     1:         }
     1: 
     1:         case JSENUMERATE_DESTROY:
     1:         default:
     1:             e = (nsISimpleEnumerator*) JSVAL_TO_PRIVATE(*statep);
     1:             NS_IF_RELEASE(e);
     1:             *statep = JSVAL_NULL;
     1:             return NS_OK;
     1:     }
     1: }
     1: 
 79445: /* bool newResolve (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval id, in PRUint32 flags, out JSObjectPtr objp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Classes::NewResolve(nsIXPConnectWrappedNative *wrapper,
     1:                                     JSContext * cx, JSObject * obj,
 48470:                                     jsid id, PRUint32 flags,
 79445:                                     JSObject * *objp, bool *_retval)
     1: 
     1: {
 57812:     JSAutoByteString name;
     1: 
 48470:     if (JSID_IS_STRING(id) &&
 57812:         name.encode(cx, JSID_TO_STRING(id)) &&
 80389:         name.ptr()[0] != '{') { // we only allow contractids here
     1:         nsCOMPtr<nsIJSCID> nsid =
 57812:             dont_AddRef(static_cast<nsIJSCID*>(nsJSCID::NewID(name.ptr())));
 80389:         if (nsid) {
     1:             nsCOMPtr<nsIXPConnect> xpc;
     1:             wrapper->GetXPConnect(getter_AddRefs(xpc));
 80389:             if (xpc) {
     1:                 nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     1:                 if (NS_SUCCEEDED(xpc->WrapNative(cx, obj,
  3233:                                                  static_cast<nsIJSCID*>(nsid),
     1:                                                  NS_GET_IID(nsIJSCID),
 80389:                                                  getter_AddRefs(holder)))) {
     1:                     JSObject* idobj;
 80389:                     if (holder && NS_SUCCEEDED(holder->GetJSObject(&idobj))) {
     1:                         *objp = obj;
 48470:                         *_retval = JS_DefinePropertyById(cx, obj, id,
     1:                                                          OBJECT_TO_JSVAL(idobj),
     1:                                                          nsnull, nsnull,
     1:                                                          JSPROP_ENUMERATE |
     1:                                                          JSPROP_READONLY |
 26167:                                                          JSPROP_PERMANENT);
     1:                     }
     1:                 }
     1:             }
     1:         }
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: 
     1: class nsXPCComponents_ClassesByID :
     1:   public nsIXPCComponents_ClassesByID,
     1:   public nsIXPCScriptable,
     1:   public nsIClassInfo
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCCOMPONENTS_CLASSESBYID
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSICLASSINFO
     1: 
     1: public:
     1:     nsXPCComponents_ClassesByID();
     1:     virtual ~nsXPCComponents_ClassesByID();
     1: };
     1: 
     1: /***************************************************************************/
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ClassesByID::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 68602:     const PRUint32 count = 2;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
     1:     PUSH_IID(nsIXPCComponents_ClassesByID)
     1:     PUSH_IID(nsIXPCScriptable)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ClassesByID::GetHelperForLanguage(PRUint32 language,
     1:                                                   nsISupports **retval)
     1: {
     1:     *retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ClassesByID::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ClassesByID::GetClassDescription(char * *aClassDescription)
     1: {
 76889:     static const char classDescription[] = "XPCComponents_ClassesByID";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ClassesByID::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCComponents_ClassesByID::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ClassesByID::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ClassesByID::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: nsXPCComponents_ClassesByID::nsXPCComponents_ClassesByID()
     1: {
     1: }
     1: 
     1: nsXPCComponents_ClassesByID::~nsXPCComponents_ClassesByID()
     1: {
     1:     // empty
     1: }
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_ClassesByID)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_ClassesByID)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_ClassesByID)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_ClassesByID)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_ClassesByID)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_ClassesByID
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_ClassesByID"
     1: #define                             XPC_MAP_WANT_NEWRESOLVE
     1: #define                             XPC_MAP_WANT_NEWENUMERATE
     1: #define XPC_MAP_FLAGS               nsIXPCScriptable::DONT_ENUM_STATIC_PROPS |\
     1:                                     nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
 79445: /* bool newEnumerate (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 enum_op, in JSValPtr statep, out JSID idp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ClassesByID::NewEnumerate(nsIXPConnectWrappedNative *wrapper,
     1:                                           JSContext * cx, JSObject * obj,
     1:                                           PRUint32 enum_op, jsval * statep,
 79445:                                           jsid * idp, bool *_retval)
     1: {
     1:     nsISimpleEnumerator* e;
     1: 
 80389:     switch (enum_op) {
     1:         case JSENUMERATE_INIT:
 47569:         case JSENUMERATE_INIT_ALL:
     1:         {
     1:             nsCOMPtr<nsIComponentRegistrar> compMgr;
     1:             if (NS_FAILED(NS_GetComponentRegistrar(getter_AddRefs(compMgr))) || !compMgr ||
 80389:                 NS_FAILED(compMgr->EnumerateCIDs(&e)) || !e ) {
     1:                 *statep = JSVAL_NULL;
     1:                 return NS_ERROR_UNEXPECTED;
     1:             }
     1: 
     1:             *statep = PRIVATE_TO_JSVAL(e);
     1:             if (idp)
 48470:                 *idp = INT_TO_JSID(0); // indicate that we don't know the count
     1:             return NS_OK;
     1:         }
     1:         case JSENUMERATE_NEXT:
     1:         {
     1:             nsCOMPtr<nsISupports> isup;
 79445:             bool hasMore;
     1:             e = (nsISimpleEnumerator*) JSVAL_TO_PRIVATE(*statep);
     1: 
     1:             if (NS_SUCCEEDED(e->HasMoreElements(&hasMore)) && hasMore &&
 80389:                 NS_SUCCEEDED(e->GetNext(getter_AddRefs(isup))) && isup) {
     1:                 nsCOMPtr<nsISupportsID> holder(do_QueryInterface(isup));
 80389:                 if (holder) {
     1:                     char* name;
 80389:                     if (NS_SUCCEEDED(holder->ToString(&name)) && name) {
     1:                         JSString* idstr = JS_NewStringCopyZ(cx, name);
     1:                         nsMemory::Free(name);
     1:                         if (idstr &&
 80389:                             JS_ValueToId(cx, STRING_TO_JSVAL(idstr), idp)) {
     1:                             return NS_OK;
     1:                         }
     1:                     }
     1:                 }
     1:             }
     1:             // else... FALL THROUGH
     1:         }
     1: 
     1:         case JSENUMERATE_DESTROY:
     1:         default:
     1:             e = (nsISimpleEnumerator*) JSVAL_TO_PRIVATE(*statep);
     1:             NS_IF_RELEASE(e);
     1:             *statep = JSVAL_NULL;
     1:             return NS_OK;
     1:     }
     1: }
     1: 
 79445: static bool
     1: IsRegisteredCLSID(const char* str)
     1: {
 79445:     bool registered;
     1:     nsID id;
     1: 
     1:     if (!id.Parse(str))
 80486:         return false;
     1: 
     1:     nsCOMPtr<nsIComponentRegistrar> compMgr;
     1:     if (NS_FAILED(NS_GetComponentRegistrar(getter_AddRefs(compMgr))) || !compMgr ||
     1:         NS_FAILED(compMgr->IsCIDRegistered(id, &registered)))
 80486:         return false;
     1: 
     1:     return registered;
     1: }
     1: 
 79445: /* bool newResolve (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval id, in PRUint32 flags, out JSObjectPtr objp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ClassesByID::NewResolve(nsIXPConnectWrappedNative *wrapper,
     1:                                         JSContext * cx, JSObject * obj,
 48470:                                         jsid id, PRUint32 flags,
 79445:                                         JSObject * *objp, bool *_retval)
     1: {
 57812:     JSAutoByteString name;
     1: 
 48470:     if (JSID_IS_STRING(id) &&
 57812:         name.encode(cx, JSID_TO_STRING(id)) &&
 57812:         name.ptr()[0] == '{' &&
 80389:         IsRegisteredCLSID(name.ptr())) { // we only allow canonical CLSIDs here
     1:         nsCOMPtr<nsIJSCID> nsid =
 57812:             dont_AddRef(static_cast<nsIJSCID*>(nsJSCID::NewID(name.ptr())));
 80389:         if (nsid) {
     1:             nsCOMPtr<nsIXPConnect> xpc;
     1:             wrapper->GetXPConnect(getter_AddRefs(xpc));
 80389:             if (xpc) {
     1:                 nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     1:                 if (NS_SUCCEEDED(xpc->WrapNative(cx, obj,
  3233:                                                  static_cast<nsIJSCID*>(nsid),
     1:                                                  NS_GET_IID(nsIJSCID),
 80389:                                                  getter_AddRefs(holder)))) {
     1:                     JSObject* idobj;
 80389:                     if (holder && NS_SUCCEEDED(holder->GetJSObject(&idobj))) {
     1:                         *objp = obj;
 48470:                         *_retval = JS_DefinePropertyById(cx, obj, id,
     1:                                                          OBJECT_TO_JSVAL(idobj),
     1:                                                          nsnull, nsnull,
     1:                                                          JSPROP_ENUMERATE |
     1:                                                          JSPROP_READONLY |
 26167:                                                          JSPROP_PERMANENT);
     1:                     }
     1:                 }
     1:             }
     1:         }
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: /***************************************************************************/
     1: 
     1: // Currently the possible results do not change at runtime, so they are only
     1: // cached once (unlike ContractIDs, CLSIDs, and IIDs)
     1: 
     1: class nsXPCComponents_Results :
     1:   public nsIXPCComponents_Results,
     1:   public nsIXPCScriptable,
     1:   public nsIClassInfo
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCCOMPONENTS_RESULTS
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSICLASSINFO
     1: 
     1: public:
     1:     nsXPCComponents_Results();
     1:     virtual ~nsXPCComponents_Results();
     1: };
     1: 
     1: /***************************************************************************/
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Results::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 68602:     const PRUint32 count = 2;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
     1:     PUSH_IID(nsIXPCComponents_Results)
     1:     PUSH_IID(nsIXPCScriptable)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Results::GetHelperForLanguage(PRUint32 language,
     1:                                               nsISupports **retval)
     1: {
     1:     *retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Results::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Results::GetClassDescription(char * *aClassDescription)
     1: {
 76889:     static const char classDescription[] = "XPCComponents_Results";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Results::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCComponents_Results::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Results::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Results::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: nsXPCComponents_Results::nsXPCComponents_Results()
     1: {
     1: }
     1: 
     1: nsXPCComponents_Results::~nsXPCComponents_Results()
     1: {
     1:     // empty
     1: }
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Results)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Results)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Results)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Results)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Results)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_Results
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_Results"
     1: #define                             XPC_MAP_WANT_NEWRESOLVE
     1: #define                             XPC_MAP_WANT_NEWENUMERATE
     1: #define XPC_MAP_FLAGS               nsIXPCScriptable::DONT_ENUM_STATIC_PROPS |\
     1:                                     nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
 79445: /* bool newEnumerate (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 enum_op, in JSValPtr statep, out JSID idp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Results::NewEnumerate(nsIXPConnectWrappedNative *wrapper,
     1:                                       JSContext * cx, JSObject * obj,
     1:                                       PRUint32 enum_op, jsval * statep,
 79445:                                       jsid * idp, bool *_retval)
     1: {
     1:     void** iter;
     1: 
 80389:     switch (enum_op) {
     1:         case JSENUMERATE_INIT:
 47569:         case JSENUMERATE_INIT_ALL:
     1:         {
     1:             if (idp)
 48470:                 *idp = INT_TO_JSID(nsXPCException::GetNSResultCount());
     1: 
     1:             void** space = (void**) new char[sizeof(void*)];
     1:             *space = nsnull;
     1:             *statep = PRIVATE_TO_JSVAL(space);
     1:             return NS_OK;
     1:         }
     1:         case JSENUMERATE_NEXT:
     1:         {
     1:             const char* name;
     1:             iter = (void**) JSVAL_TO_PRIVATE(*statep);
 80389:             if (nsXPCException::IterateNSResults(nsnull, &name, nsnull, iter)) {
     1:                 JSString* idstr = JS_NewStringCopyZ(cx, name);
     1:                 if (idstr && JS_ValueToId(cx, STRING_TO_JSVAL(idstr), idp))
     1:                     return NS_OK;
     1:             }
     1:             // else... FALL THROUGH
     1:         }
     1: 
     1:         case JSENUMERATE_DESTROY:
     1:         default:
     1:             iter = (void**) JSVAL_TO_PRIVATE(*statep);
     1:             delete [] (char*) iter;
     1:             *statep = JSVAL_NULL;
     1:             return NS_OK;
     1:     }
     1: }
     1: 
     1: 
 79445: /* bool newResolve (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval id, in PRUint32 flags, out JSObjectPtr objp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Results::NewResolve(nsIXPConnectWrappedNative *wrapper,
     1:                                     JSContext * cx, JSObject * obj,
 48470:                                     jsid id, PRUint32 flags,
 79445:                                     JSObject * *objp, bool *_retval)
     1: {
 57812:     JSAutoByteString name;
 57812: 
 80389:     if (JSID_IS_STRING(id) && name.encode(cx, JSID_TO_STRING(id))) {
     1:         const char* rv_name;
     1:         void* iter = nsnull;
     1:         nsresult rv;
 80389:         while (nsXPCException::IterateNSResults(&rv, &rv_name, nsnull, &iter)) {
 80389:             if (!strcmp(name.ptr(), rv_name)) {
     1:                 jsval val;
     1: 
     1:                 *objp = obj;
 90955:                 if (!JS_NewNumberValue(cx, (double)rv, &val) ||
 48470:                     !JS_DefinePropertyById(cx, obj, id, val,
     1:                                            nsnull, nsnull,
     1:                                            JSPROP_ENUMERATE |
     1:                                            JSPROP_READONLY |
 80389:                                            JSPROP_PERMANENT)) {
     1:                     return NS_ERROR_UNEXPECTED;
     1:                 }
     1:             }
     1:         }
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: /***************************************************************************/
     1: // JavaScript Constructor for nsIJSID objects (Components.ID)
     1: 
     1: class nsXPCComponents_ID :
     1:   public nsIXPCComponents_ID,
     1:   public nsIXPCScriptable,
     1:   public nsIClassInfo
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCCOMPONENTS_ID
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSICLASSINFO
     1: 
     1: 
     1: public:
     1:     nsXPCComponents_ID();
     1:     virtual ~nsXPCComponents_ID();
     1: 
     1: private:
 30017:     static nsresult CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
     1:                                     JSContext * cx, JSObject * obj,
     1:                                     PRUint32 argc, jsval * argv,
 79445:                                     jsval * vp, bool *_retval);
     1: };
     1: 
     1: /***************************************************************************/
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ID::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 68602:     const PRUint32 count = 2;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
     1:     PUSH_IID(nsIXPCComponents_ID)
     1:     PUSH_IID(nsIXPCScriptable)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ID::GetHelperForLanguage(PRUint32 language,
     1:                                          nsISupports **retval)
     1: {
     1:     *retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ID::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ID::GetClassDescription(char * *aClassDescription)
     1: {
 76889:     static const char classDescription[] = "XPCComponents_ID";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ID::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCComponents_ID::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ID::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ID::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: nsXPCComponents_ID::nsXPCComponents_ID()
     1: {
     1: }
     1: 
     1: nsXPCComponents_ID::~nsXPCComponents_ID()
     1: {
     1:     // empty
     1: }
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_ID)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_ID)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_ID)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_ID)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_ID)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_ID
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_ID"
     1: #define                             XPC_MAP_WANT_CALL
     1: #define                             XPC_MAP_WANT_CONSTRUCT
     1: #define                             XPC_MAP_WANT_HASINSTANCE
 77550: #define XPC_MAP_FLAGS               nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
     1: 
 79445: /* bool call (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 argc, in JSValPtr argv, in JSValPtr vp); */
     1: NS_IMETHODIMP
 79445: nsXPCComponents_ID::Call(nsIXPConnectWrappedNative *wrapper, JSContext * cx, JSObject * obj, PRUint32 argc, jsval * argv, jsval * vp, bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: 
     1: }
     1: 
 79445: /* bool construct (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 argc, in JSValPtr argv, in JSValPtr vp); */
     1: NS_IMETHODIMP
 79445: nsXPCComponents_ID::Construct(nsIXPConnectWrappedNative *wrapper, JSContext * cx, JSObject * obj, PRUint32 argc, jsval * argv, jsval * vp, bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: }
     1: 
 30017: // static
 30017: nsresult
     1: nsXPCComponents_ID::CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
     1:                                     JSContext * cx, JSObject * obj,
     1:                                     PRUint32 argc, jsval * argv,
 79445:                                     jsval * vp, bool *_retval)
     1: {
     1:     // make sure we have at least one arg
     1: 
     1:     if (!argc)
     1:         return ThrowAndFail(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx, _retval);
     1: 
     1:     XPCCallContext ccx(JS_CALLER, cx);
     1:     if (!ccx.IsValid())
     1:         return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1: 
     1:     XPCContext* xpcc = ccx.GetXPCContext();
     1: 
     1:     // Do the security check if necessary
     1: 
     1:     nsIXPCSecurityManager* sm =
 80387:             xpcc->GetAppropriateSecurityManager(nsIXPCSecurityManager::HOOK_CREATE_INSTANCE);
 80389:     if (sm && NS_FAILED(sm->CanCreateInstance(cx, nsJSID::GetCID()))) {
     1:         // the security manager vetoed. It should have set an exception.
 82794:         *_retval = false;
     1:         return NS_OK;
     1:     }
     1: 
     1:     // convert the first argument into a string and see if it looks like an id
     1: 
     1:     JSString* jsstr;
 57812:     JSAutoByteString bytes;
     1:     nsID id;
     1: 
     1:     if (!(jsstr = JS_ValueToString(cx, argv[0])) ||
 57812:         !bytes.encode(cx, jsstr) ||
 80389:         !id.Parse(bytes.ptr())) {
     1:         return ThrowAndFail(NS_ERROR_XPC_BAD_ID_STRING, cx, _retval);
     1:     }
     1: 
     1:     // make the new object and return it.
     1: 
     1:     JSObject* newobj = xpc_NewIDObject(cx, obj, id);
     1: 
     1:     if (vp)
     1:         *vp = OBJECT_TO_JSVAL(newobj);
     1: 
     1:     return NS_OK;
     1: }
     1: 
 79445: /* bool hasInstance (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval val, out bool bp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_ID::HasInstance(nsIXPConnectWrappedNative *wrapper,
     1:                                 JSContext * cx, JSObject * obj,
 79445:                                 const jsval &val, bool *bp, bool *_retval)
     1: {
     1:     if (bp)
     1:         *bp = JSValIsInterfaceOfType(cx, val, NS_GET_IID(nsIJSID));
     1:     return NS_OK;
     1: }
     1: 
     1: /***************************************************************************/
     1: // JavaScript Constructor for nsIXPCException objects (Components.Exception)
     1: 
     1: class nsXPCComponents_Exception :
     1:   public nsIXPCComponents_Exception,
     1:   public nsIXPCScriptable,
     1:   public nsIClassInfo
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCCOMPONENTS_EXCEPTION
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSICLASSINFO
     1: 
     1: 
     1: public:
     1:     nsXPCComponents_Exception();
     1:     virtual ~nsXPCComponents_Exception();
     1: 
     1: private:
 30017:     static nsresult CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
     1:                                     JSContext * cx, JSObject * obj,
     1:                                     PRUint32 argc, jsval * argv,
 79445:                                     jsval * vp, bool *_retval);
     1: };
     1: 
     1: /***************************************************************************/
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Exception::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 68602:     const PRUint32 count = 2;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
     1:     PUSH_IID(nsIXPCComponents_Exception)
     1:     PUSH_IID(nsIXPCScriptable)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Exception::GetHelperForLanguage(PRUint32 language,
     1:                                                 nsISupports **retval)
     1: {
     1:     *retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Exception::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Exception::GetClassDescription(char * *aClassDescription)
     1: {
 76889:     static const char classDescription[] = "XPCComponents_Exception";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Exception::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCComponents_Exception::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Exception::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Exception::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: nsXPCComponents_Exception::nsXPCComponents_Exception()
     1: {
     1: }
     1: 
     1: nsXPCComponents_Exception::~nsXPCComponents_Exception()
     1: {
     1:     // empty
     1: }
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Exception)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Exception)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Exception)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Exception)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Exception)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_Exception
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_Exception"
     1: #define                             XPC_MAP_WANT_CALL
     1: #define                             XPC_MAP_WANT_CONSTRUCT
     1: #define                             XPC_MAP_WANT_HASINSTANCE
 77550: #define XPC_MAP_FLAGS               nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
     1: 
 79445: /* bool call (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 argc, in JSValPtr argv, in JSValPtr vp); */
     1: NS_IMETHODIMP
 79445: nsXPCComponents_Exception::Call(nsIXPConnectWrappedNative *wrapper, JSContext * cx, JSObject * obj, PRUint32 argc, jsval * argv, jsval * vp, bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: 
     1: }
     1: 
 79445: /* bool construct (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 argc, in JSValPtr argv, in JSValPtr vp); */
     1: NS_IMETHODIMP
 79445: nsXPCComponents_Exception::Construct(nsIXPConnectWrappedNative *wrapper, JSContext * cx, JSObject * obj, PRUint32 argc, jsval * argv, jsval * vp, bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: }
     1: 
 95469: struct NS_STACK_CLASS ExceptionArgParser
 95469: {
 95469:     ExceptionArgParser(JSContext *context,
 95469:                        nsXPConnect *xpconnect)
 95469:         : eMsg("exception")
 95469:         , eResult(NS_ERROR_FAILURE)
 95469:         , cx(context)
 95469:         , xpc(xpconnect)
 95469:     {}
 95469: 
 95469:     // Public exception parameter values. During construction, these are
 95469:     // initialized to the appropriate defaults.
 95469:     const char*             eMsg;
 95469:     nsresult                eResult;
     1:     nsCOMPtr<nsIStackFrame> eStack;
     1:     nsCOMPtr<nsISupports>   eData;
     1: 
 95469:     // Parse the constructor arguments into the above |eFoo| parameter values.
 95469:     bool parse(uint32_t argc, JS::Value *argv) {
 95471:         /*
 95471:          * The Components.Exception takes a series of arguments, all of them
 95471:          * optional:
 95471:          *
 95471:          * Argument 0: Exception message (defaults to 'exception').
 95472:          * Argument 1: Result code (defaults to NS_ERROR_FAILURE) _or_ options
 95472:          *             object (see below).
 95471:          * Argument 2: Stack (defaults to the current stack, which we trigger
 95471:          *                    by leaving this NULL in the parser).
 95471:          * Argument 3: Optional user data (defaults to NULL).
 95472:          *
 95472:          * To dig our way out of this clunky API, we now support passing an
 95472:          * options object as the second parameter (as opposed to a result code).
 95472:          * If this is the case, all subsequent arguments are ignored, and the
 95472:          * following properties are parsed out of the object (using the
 95472:          * associated default if the property does not exist):
 95472:          *
 95472:          *   result:    Result code (see argument 1).
 95472:          *   stack:     Call stack (see argument 2).
 95472:          *   data:      User data (see argument 3).
 95471:          */
 95471:         if (argc > 0 && !parseMessage(argv[0]))
 95469:             return false;
 95472:         if (argc > 1) {
 95472:             if (argv[1].isObject())
 95472:                 return parseOptionsObject(argv[1].toObject());
 95472:             if (!parseResult(argv[1]))
 95469:                 return false;
 95472:         }
 95471:         if (argc > 2 && !parseStack(argv[2]))
 95469:             return false;
 95471:         if (argc > 3 && !parseData(argv[3]))
 95469:             return false;
 95469:         return true;
 95469:     }
 95469: 
 95469:   protected:
 95469: 
 95470:     /*
 95470:      * Parsing helpers.
 95470:      */
 95470: 
 95470:     bool parseMessage(JS::Value &v) {
 95470:         JSString *str = JS_ValueToString(cx, v);
 95470:         if (!str)
 95470:            return false;
 95470:         eMsg = messageBytes.encode(cx, str);
 95470:         return !!eMsg;
 95470:     }
 95470: 
 95470:     bool parseResult(JS::Value &v) {
 95470:         return JS_ValueToECMAInt32(cx, v, (int32_t*) &eResult);
 95470:     }
 95470: 
 95470:     bool parseStack(JS::Value &v) {
 95470:         if (!v.isObject()) {
 95470:             // eStack has already been initialized to null, which is what we want
 95470:             // for any non-object values (including null).
 95470:             return true;
 95470:         }
 95470: 
 95470:         return NS_SUCCEEDED(xpc->WrapJS(cx, JSVAL_TO_OBJECT(v),
 95470:                                         NS_GET_IID(nsIStackFrame),
 95470:                                         getter_AddRefs(eStack)));
 95470:     }
 95470: 
 95470:     bool parseData(JS::Value &v) {
 95470:         if (!v.isObject()) {
 95470:             // eData has already been initialized to null, which is what we want
 95470:             // for any non-object values (including null).
 95470:             return true;
 95470:         }
 95470: 
 95470:         return NS_SUCCEEDED(xpc->WrapJS(cx, &v.toObject(),
 95470:                                         NS_GET_IID(nsISupports),
 95470:                                         getter_AddRefs(eData)));
 95470:     }
 95470: 
 95472:     bool parseOptionsObject(JSObject &obj) {
 95472:         JS::Value v;
 95472: 
 95472:         if (!getOption(obj, "result", &v) ||
 95472:             (!v.isUndefined() && !parseResult(v)))
 95472:             return false;
 95472: 
 95472:         if (!getOption(obj, "stack", &v) ||
 95472:             (!v.isUndefined() && !parseStack(v)))
 95472:             return false;
 95472: 
 95472:         if (!getOption(obj, "data", &v) ||
 95472:             (!v.isUndefined() && !parseData(v)))
 95472:             return false;
 95472: 
 95472:         return true;
 95472:     }
 95472: 
 95472:     bool getOption(JSObject &obj, const char *name, JS::Value *rv) {
 95472:         // Look for the property.
 95472:         JSBool found;
 95472:         if (!JS_HasProperty(cx, &obj, name, &found))
 95472:             return false;
 95472: 
 95472:         // If it wasn't found, indicate with undefined.
 95472:         if (!found) {
 95472:             *rv = JSVAL_VOID;
 95472:             return true;
 95472:         }
 95472: 
 95472:         // Get the property.
 95472:         return JS_GetProperty(cx, &obj, name, rv);
 95472:     }
 95472: 
 95470:     /*
 95470:      * Internal data members.
 95470:      */
 95470: 
 95469:     // If there's a non-default exception string, hold onto the allocated bytes.
 95469:     JSAutoByteString messageBytes;
 95469: 
 95469:     // Various bits and pieces that are helpful to have around.
 95469:     JSContext *cx;
 95469:     nsXPConnect *xpc;
 95469: };
 95469: 
 95469: // static
 95469: nsresult
 95469: nsXPCComponents_Exception::CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
 95469:                                            JSContext * cx, JSObject * obj,
 95469:                                            PRUint32 argc, jsval * argv,
 95469:                                            jsval * vp, bool *_retval)
 95469: {
 95469:     XPCCallContext ccx(JS_CALLER, cx);
 95469:     if (!ccx.IsValid())
 95469:         return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
 95469: 
 95469:     nsXPConnect* xpc = ccx.GetXPConnect();
 95469:     XPCContext* xpcc = ccx.GetXPCContext();
 95469: 
 95469:     // Do the security check if necessary
 95469: 
 95469:     nsIXPCSecurityManager* sm =
 95469:             xpcc->GetAppropriateSecurityManager(nsIXPCSecurityManager::HOOK_CREATE_INSTANCE);
 95469:     if (sm && NS_FAILED(sm->CanCreateInstance(cx, nsXPCException::GetCID()))) {
 95469:         // the security manager vetoed. It should have set an exception.
 95469:         *_retval = false;
 95469:         return NS_OK;
 95469:     }
 95469: 
 95469:     // Parse the arguments to the Exception constructor.
 95469:     ExceptionArgParser args(cx, xpc);
 95469:     if (!args.parse(argc, argv))
 95469:         return ThrowAndFail(NS_ERROR_XPC_BAD_CONVERT_JS, cx, _retval);
 95469: 
     1:     nsCOMPtr<nsIException> e;
 95469:     nsXPCException::NewException(args.eMsg, args.eResult, args.eStack,
 95469:                                  args.eData, getter_AddRefs(e));
     1:     if (!e)
     1:         return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1: 
     1:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     1:     JSObject* newObj = nsnull;
     1: 
     1:     if (NS_FAILED(xpc->WrapNative(cx, obj, e, NS_GET_IID(nsIXPCException),
     1:                                   getter_AddRefs(holder))) || !holder ||
 80389:         NS_FAILED(holder->GetJSObject(&newObj)) || !newObj) {
     1:         return ThrowAndFail(NS_ERROR_XPC_CANT_CREATE_WN, cx, _retval);
     1:     }
     1: 
     1:     if (vp)
     1:         *vp = OBJECT_TO_JSVAL(newObj);
     1: 
     1:     return NS_OK;
     1: }
     1: 
 79445: /* bool hasInstance (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval val, out bool bp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Exception::HasInstance(nsIXPConnectWrappedNative *wrapper,
     1:                                        JSContext * cx, JSObject * obj,
 79445:                                        const jsval &val, bool *bp,
 79445:                                        bool *_retval)
     1: {
     1:     if (bp)
     1:         *bp = JSValIsInterfaceOfType(cx, val, NS_GET_IID(nsIException));
     1:     return NS_OK;
     1: }
     1: 
     1: /***************************************************************************/
     1: // This class is for the thing returned by "new Component.Constructor".
     1: 
     1: // XXXjband we use this CID for security check, but security system can't see
     1: // it since it has no registed factory. Security really kicks in when we try
     1: // to build a wrapper around an instance.
     1: 
     1: // {B4A95150-E25A-11d3-8F61-0010A4E73D9A}
     1: #define NS_XPCCONSTRUCTOR_CID                                                 \
     1: { 0xb4a95150, 0xe25a, 0x11d3,                                                 \
     1:     { 0x8f, 0x61, 0x0, 0x10, 0xa4, 0xe7, 0x3d, 0x9a } }
     1: 
     1: class nsXPCConstructor :
     1:   public nsIXPCConstructor,
     1:   public nsIXPCScriptable,
     1:   public nsIClassInfo
     1: {
     1: public:
     1:     NS_DEFINE_STATIC_CID_ACCESSOR(NS_XPCCONSTRUCTOR_CID)
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCCONSTRUCTOR
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSICLASSINFO
     1: 
     1: public:
     1:     nsXPCConstructor(); // not implemented
     1:     nsXPCConstructor(nsIJSCID* aClassID,
     1:                      nsIJSIID* aInterfaceID,
     1:                      const char* aInitializer);
     1:     virtual ~nsXPCConstructor();
     1: 
     1: private:
 30017:     nsresult CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
     1:                              JSContext * cx, JSObject * obj,
     1:                              PRUint32 argc, jsval * argv,
 79445:                              jsval * vp, bool *_retval);
     1: private:
     1:     nsIJSCID* mClassID;
     1:     nsIJSIID* mInterfaceID;
     1:     char*     mInitializer;
     1: };
     1: 
     1: /***************************************************************************/
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 68602:     const PRUint32 count = 2;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
     1:     PUSH_IID(nsIXPCConstructor)
     1:     PUSH_IID(nsIXPCScriptable)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetHelperForLanguage(PRUint32 language,
     1:                                        nsISupports **retval)
     1: {
     1:     *retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetClassDescription(char * *aClassDescription)
     1: {
 76889:     static const char classDescription[] = "XPCConstructor";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCConstructor::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: nsXPCConstructor::nsXPCConstructor(nsIJSCID* aClassID,
     1:                                    nsIJSIID* aInterfaceID,
     1:                                    const char* aInitializer)
     1: {
     1:     NS_IF_ADDREF(mClassID = aClassID);
     1:     NS_IF_ADDREF(mInterfaceID = aInterfaceID);
     1:     mInitializer = aInitializer ?
     1:         (char*) nsMemory::Clone(aInitializer, strlen(aInitializer)+1) :
     1:         nsnull;
     1: }
     1: 
     1: nsXPCConstructor::~nsXPCConstructor()
     1: {
     1:     NS_IF_RELEASE(mClassID);
     1:     NS_IF_RELEASE(mInterfaceID);
     1:     if (mInitializer)
     1:         nsMemory::Free(mInitializer);
     1: }
     1: 
     1: /* readonly attribute nsIJSCID classID; */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetClassID(nsIJSCID * *aClassID)
     1: {
     1:     NS_IF_ADDREF(*aClassID = mClassID);
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute nsIJSIID interfaceID; */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetInterfaceID(nsIJSIID * *aInterfaceID)
     1: {
     1:     NS_IF_ADDREF(*aInterfaceID = mInterfaceID);
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string initializer; */
     1: NS_IMETHODIMP
     1: nsXPCConstructor::GetInitializer(char * *aInitializer)
     1: {
     1:     XPC_STRING_GETTER_BODY(aInitializer, mInitializer);
     1: }
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCConstructor)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCConstructor)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCConstructor)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCConstructor)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCConstructor)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCConstructor
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCConstructor"
     1: #define                             XPC_MAP_WANT_CALL
     1: #define                             XPC_MAP_WANT_CONSTRUCT
     1: #define XPC_MAP_FLAGS               0
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
     1: 
 79445: /* bool call (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 argc, in JSValPtr argv, in JSValPtr vp); */
     1: NS_IMETHODIMP
 79445: nsXPCConstructor::Call(nsIXPConnectWrappedNative *wrapper, JSContext * cx, JSObject * obj, PRUint32 argc, jsval * argv, jsval * vp, bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: 
     1: }
     1: 
 79445: /* bool construct (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 argc, in JSValPtr argv, in JSValPtr vp); */
     1: NS_IMETHODIMP
 79445: nsXPCConstructor::Construct(nsIXPConnectWrappedNative *wrapper, JSContext * cx, JSObject * obj, PRUint32 argc, jsval * argv, jsval * vp, bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: }
     1: 
 30017: // static
 30017: nsresult
     1: nsXPCConstructor::CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
     1:                                   JSContext * cx, JSObject * obj,
     1:                                   PRUint32 argc, jsval * argv,
 79445:                                   jsval * vp, bool *_retval)
     1: {
     1:     XPCCallContext ccx(JS_CALLER, cx);
     1:     if (!ccx.IsValid())
     1:         return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1: 
     1:     nsXPConnect* xpc = ccx.GetXPConnect();
     1: 
     1:     // security check not required because we are going to call through the
     1:     // code which is reflected into JS which will do that for us later.
     1: 
     1:     nsCOMPtr<nsIXPConnectJSObjectHolder> cidHolder;
     1:     nsCOMPtr<nsIXPConnectJSObjectHolder> iidHolder;
     1:     JSObject* cidObj;
     1:     JSObject* iidObj;
     1: 
     1:     if (NS_FAILED(xpc->WrapNative(cx, obj, mClassID, NS_GET_IID(nsIJSCID),
     1:                                   getter_AddRefs(cidHolder))) || !cidHolder ||
     1:         NS_FAILED(cidHolder->GetJSObject(&cidObj)) || !cidObj ||
     1:         NS_FAILED(xpc->WrapNative(cx, obj, mInterfaceID, NS_GET_IID(nsIJSIID),
     1:                                   getter_AddRefs(iidHolder))) || !iidHolder ||
 80389:         NS_FAILED(iidHolder->GetJSObject(&iidObj)) || !iidObj) {
     1:         return ThrowAndFail(NS_ERROR_XPC_CANT_CREATE_WN, cx, _retval);
     1:     }
     1: 
     1:     jsval ctorArgs[1] = {OBJECT_TO_JSVAL(iidObj)};
     1:     jsval val;
     1: 
     1:     if (!JS_CallFunctionName(cx, cidObj, "createInstance", 1, ctorArgs, &val) ||
 80389:         JSVAL_IS_PRIMITIVE(val)) {
     1:         // createInstance will have thrown an exception
 82794:         *_retval = false;
     1:         return NS_OK;
     1:     }
     1: 
     1:     // root the result
     1:     if (vp)
     1:         *vp = val;
     1: 
     1:     // call initializer method if supplied
 80389:     if (mInitializer) {
     1:         JSObject* newObj = JSVAL_TO_OBJECT(val);
     1:         jsval fun;
     1:         jsval ignored;
     1: 
     1:         // first check existence of function property for better error reporting
     1:         if (!JS_GetProperty(cx, newObj, mInitializer, &fun) ||
 80389:             JSVAL_IS_PRIMITIVE(fun)) {
     1:             return ThrowAndFail(NS_ERROR_XPC_BAD_INITIALIZER_NAME, cx, _retval);
     1:         }
     1: 
 80389:         if (!JS_CallFunctionValue(cx, newObj, fun, argc, argv, &ignored)) {
     1:             // function should have thrown an exception
 82794:             *_retval = false;
     1:             return NS_OK;
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: /*******************************************************/
     1: // JavaScript Constructor for nsIXPCConstructor objects (Components.Constructor)
     1: 
     1: class nsXPCComponents_Constructor :
     1:   public nsIXPCComponents_Constructor,
     1:   public nsIXPCScriptable,
     1:   public nsIClassInfo
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCCOMPONENTS_CONSTRUCTOR
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSICLASSINFO
     1: 
     1: public:
     1:     nsXPCComponents_Constructor();
     1:     virtual ~nsXPCComponents_Constructor();
     1: 
     1: private:
 30017:     static nsresult CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
     1:                                     JSContext * cx, JSObject * obj,
     1:                                     PRUint32 argc, jsval * argv,
 79445:                                     jsval * vp, bool *_retval);
     1: };
     1: 
     1: /***************************************************************************/
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Constructor::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 68602:     const PRUint32 count = 2;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
     1:     PUSH_IID(nsIXPCComponents_Constructor)
     1:     PUSH_IID(nsIXPCScriptable)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Constructor::GetHelperForLanguage(PRUint32 language,
     1:                                                   nsISupports **retval)
     1: {
     1:     *retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Constructor::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Constructor::GetClassDescription(char * *aClassDescription)
     1: {
 76889:     static const char classDescription[] = "XPCComponents_Constructor";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Constructor::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCComponents_Constructor::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Constructor::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Constructor::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: nsXPCComponents_Constructor::nsXPCComponents_Constructor()
     1: {
     1: }
     1: 
     1: nsXPCComponents_Constructor::~nsXPCComponents_Constructor()
     1: {
     1:     // empty
     1: }
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Constructor)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Constructor)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Constructor)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Constructor)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Constructor)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_Constructor
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_Constructor"
     1: #define                             XPC_MAP_WANT_CALL
     1: #define                             XPC_MAP_WANT_CONSTRUCT
     1: #define                             XPC_MAP_WANT_HASINSTANCE
 77550: #define XPC_MAP_FLAGS               nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
     1: 
 79445: /* bool call (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 argc, in JSValPtr argv, in JSValPtr vp); */
     1: NS_IMETHODIMP
 79445: nsXPCComponents_Constructor::Call(nsIXPConnectWrappedNative *wrapper, JSContext * cx, JSObject * obj, PRUint32 argc, jsval * argv, jsval * vp, bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: }
     1: 
 79445: /* bool construct (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in PRUint32 argc, in JSValPtr argv, in JSValPtr vp); */
     1: NS_IMETHODIMP
 79445: nsXPCComponents_Constructor::Construct(nsIXPConnectWrappedNative *wrapper, JSContext * cx, JSObject * obj, PRUint32 argc, jsval * argv, jsval * vp, bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: }
     1: 
 30017: // static
 30017: nsresult
     1: nsXPCComponents_Constructor::CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
     1:                                              JSContext * cx, JSObject * obj,
     1:                                              PRUint32 argc, jsval * argv,
 79445:                                              jsval * vp, bool *_retval)
     1: {
     1:     // make sure we have at least one arg
     1: 
     1:     if (!argc)
     1:         return ThrowAndFail(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx, _retval);
     1: 
     1:     // get the various other object pointers we need
     1: 
     1:     XPCCallContext ccx(JS_CALLER, cx);
     1:     if (!ccx.IsValid())
     1:         return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1: 
     1:     nsXPConnect* xpc = ccx.GetXPConnect();
     1:     XPCContext* xpcc = ccx.GetXPCContext();
     1:     XPCWrappedNativeScope* scope =
     1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, obj);
     1:     nsXPCComponents* comp;
     1: 
     1:     if (!xpc || !xpcc || !scope || !(comp = scope->GetComponents()))
     1:         return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1: 
     1:     // Do the security check if necessary
     1: 
     1:     nsIXPCSecurityManager* sm =
 80387:             xpcc->GetAppropriateSecurityManager(nsIXPCSecurityManager::HOOK_CREATE_INSTANCE);
 80389:     if (sm && NS_FAILED(sm->CanCreateInstance(cx, nsXPCConstructor::GetCID()))) {
     1:         // the security manager vetoed. It should have set an exception.
 82794:         *_retval = false;
     1:         return NS_OK;
     1:     }
     1: 
     1:     // initialization params for the Constructor object we will create
     1:     nsCOMPtr<nsIJSCID> cClassID;
     1:     nsCOMPtr<nsIJSIID> cInterfaceID;
     1:     const char*        cInitializer = nsnull;
 57812:     JSAutoByteString  cInitializerBytes;
     1: 
 80389:     if (argc >= 3) {
     1:         // argv[2] is an initializer function or property name
     1:         JSString* str = JS_ValueToString(cx, argv[2]);
 57812:         if (!str || !(cInitializer = cInitializerBytes.encode(cx, str)))
     1:             return ThrowAndFail(NS_ERROR_XPC_BAD_CONVERT_JS, cx, _retval);
     1:     }
     1: 
 80389:     if (argc >= 2) {
     1:         // argv[1] is an iid name string
     1:         // XXXjband support passing "Components.interfaces.foo"?
     1: 
 76740:         nsCOMPtr<nsIXPCComponents_Interfaces> ifaces;
     1:         nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     1:         JSObject* ifacesObj = nsnull;
     1: 
     1:         // we do the lookup by asking the Components.interfaces object
     1:         // for the property with this name - i.e. we let its caching of these
     1:         // nsIJSIID objects work for us.
     1: 
     1:         if (NS_FAILED(comp->GetInterfaces(getter_AddRefs(ifaces))) ||
     1:             NS_FAILED(xpc->WrapNative(cx, obj, ifaces,
 76740:                                       NS_GET_IID(nsIXPCComponents_Interfaces),
     1:                                       getter_AddRefs(holder))) || !holder ||
 80389:             NS_FAILED(holder->GetJSObject(&ifacesObj)) || !ifacesObj) {
     1:             return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1:         }
     1: 
     1:         JSString* str = JS_ValueToString(cx, argv[1]);
 57721:         jsid id;
 57721:         if (!str || !JS_ValueToId(cx, STRING_TO_JSVAL(str), &id))
     1:             return ThrowAndFail(NS_ERROR_XPC_BAD_CONVERT_JS, cx, _retval);
     1: 
     1:         jsval val;
 57721:         if (!JS_GetPropertyById(cx, ifacesObj, id, &val) || JSVAL_IS_PRIMITIVE(val))
     1:             return ThrowAndFail(NS_ERROR_XPC_BAD_IID, cx, _retval);
     1: 
     1:         nsCOMPtr<nsIXPConnectWrappedNative> wn;
     1:         if (NS_FAILED(xpc->GetWrappedNativeOfJSObject(cx, JSVAL_TO_OBJECT(val),
     1:                                                       getter_AddRefs(wn))) || !wn ||
 80389:             !(cInterfaceID = do_QueryWrappedNative(wn))) {
     1:             return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1:         }
 80390:     } else {
     1:         nsCOMPtr<nsIInterfaceInfo> info;
     1:         xpc->GetInfoForIID(&NS_GET_IID(nsISupports), getter_AddRefs(info));
     1: 
 80389:         if (info) {
     1:             cInterfaceID =
 80387:                 dont_AddRef(static_cast<nsIJSIID*>(nsJSIID::NewID(info)));
     1:         }
     1:         if (!cInterfaceID)
     1:             return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1:     }
     1: 
     1:     // a new scope to avoid warnings about shadowed names
     1:     {
     1:         // argv[0] is a contractid name string
     1:         // XXXjband support passing "Components.classes.foo"?
     1: 
     1:         // we do the lookup by asking the Components.classes object
     1:         // for the property with this name - i.e. we let its caching of these
     1:         // nsIJSCID objects work for us.
     1: 
     1:         nsCOMPtr<nsIXPCComponents_Classes> classes;
     1:         nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
     1:         JSObject* classesObj = nsnull;
     1: 
     1:         if (NS_FAILED(comp->GetClasses(getter_AddRefs(classes))) ||
     1:             NS_FAILED(xpc->WrapNative(cx, obj, classes,
     1:                                       NS_GET_IID(nsIXPCComponents_Classes),
     1:                                       getter_AddRefs(holder))) || !holder ||
 80389:             NS_FAILED(holder->GetJSObject(&classesObj)) || !classesObj) {
     1:             return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1:         }
     1: 
     1:         JSString* str = JS_ValueToString(cx, argv[0]);
 57721:         jsid id;
 57721:         if (!str || !JS_ValueToId(cx, STRING_TO_JSVAL(str), &id))
     1:             return ThrowAndFail(NS_ERROR_XPC_BAD_CONVERT_JS, cx, _retval);
     1: 
     1:         jsval val;
 57721:         if (!JS_GetPropertyById(cx, classesObj, id, &val) || JSVAL_IS_PRIMITIVE(val))
     1:             return ThrowAndFail(NS_ERROR_XPC_BAD_CID, cx, _retval);
     1: 
     1:         nsCOMPtr<nsIXPConnectWrappedNative> wn;
     1:         if (NS_FAILED(xpc->GetWrappedNativeOfJSObject(cx, JSVAL_TO_OBJECT(val),
     1:                                                       getter_AddRefs(wn))) || !wn ||
 80389:             !(cClassID = do_QueryWrappedNative(wn))) {
     1:             return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1:         }
     1:     }
     1: 
     1:     nsCOMPtr<nsIXPCConstructor> ctor =
  3233:         static_cast<nsIXPCConstructor*>
  3233:                    (new nsXPCConstructor(cClassID, cInterfaceID, cInitializer));
     1:     if (!ctor)
     1:         return ThrowAndFail(NS_ERROR_XPC_UNEXPECTED, cx, _retval);
     1: 
     1:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder2;
     1:     JSObject* newObj = nsnull;
     1: 
     1:     if (NS_FAILED(xpc->WrapNative(cx, obj, ctor, NS_GET_IID(nsIXPCConstructor),
     1:                                   getter_AddRefs(holder2))) || !holder2 ||
 80389:         NS_FAILED(holder2->GetJSObject(&newObj)) || !newObj) {
     1:         return ThrowAndFail(NS_ERROR_XPC_CANT_CREATE_WN, cx, _retval);
     1:     }
     1: 
     1:     if (vp)
     1:         *vp = OBJECT_TO_JSVAL(newObj);
     1: 
     1:     return NS_OK;
     1: }
     1: 
 79445: /* bool hasInstance (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval val, out bool bp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Constructor::HasInstance(nsIXPConnectWrappedNative *wrapper,
     1:                                          JSContext * cx, JSObject * obj,
 79445:                                          const jsval &val, bool *bp,
 79445:                                          bool *_retval)
     1: {
     1:     if (bp)
     1:         *bp = JSValIsInterfaceOfType(cx, val, NS_GET_IID(nsIXPCConstructor));
     1:     return NS_OK;
     1: }
     1: 
     1: /***************************************************************************/
     1: // Javascript constructor for the sandbox object
     1: class nsXPCComponents_utils_Sandbox : public nsIXPCComponents_utils_Sandbox,
     1:                                       public nsIXPCScriptable
     1: {
     1: public:
     1:     // Aren't macros nice?
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCCOMPONENTS_UTILS_SANDBOX
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1: 
     1: public:
     1:     nsXPCComponents_utils_Sandbox();
     1:     virtual ~nsXPCComponents_utils_Sandbox();
     1: 
     1: private:
 30017:     static nsresult CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
     1:                                     JSContext * cx, JSObject * obj,
     1:                                     PRUint32 argc, jsval * argv,
 79445:                                     jsval * vp, bool *_retval);
     1: };
     1: 
     1: class nsXPCComponents_Utils :
     1:             public nsIXPCComponents_Utils,
 68602:             public nsIXPCScriptable,
 68602:             public nsISecurityCheckedComponent
     1: {
     1: public:
     1:     // all the interface method declarations...
     1:     NS_DECL_ISUPPORTS
     1:     NS_DECL_NSIXPCSCRIPTABLE
     1:     NS_DECL_NSISECURITYCHECKEDCOMPONENT
     1:     NS_DECL_NSIXPCCOMPONENTS_UTILS
     1: 
     1: public:
     1:     nsXPCComponents_Utils() { }
     1:     virtual ~nsXPCComponents_Utils() { }
     1: 
     1: private:
     1:     nsCOMPtr<nsIXPCComponents_utils_Sandbox> mSandbox;
     1: };
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_Utils)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_Utils)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_Utils)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_Utils)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_Utils)
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_Utils
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_Utils"
     1: #define XPC_MAP_FLAGS               nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
     1: NS_IMETHODIMP
     1: nsXPCComponents_Utils::GetSandbox(nsIXPCComponents_utils_Sandbox **aSandbox)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aSandbox);
     1:     if (!mSandbox && !(mSandbox = new nsXPCComponents_utils_Sandbox())) {
     1:         *aSandbox = nsnull;
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1:     NS_ADDREF(*aSandbox = mSandbox);
     1:     return NS_OK;
     1: }
     1: 
     1: /* void lookupMethod (); */
     1: NS_IMETHODIMP
 84863: nsXPCComponents_Utils::LookupMethod(const JS::Value& object,
 84863:                                     const JS::Value& name,
 84863:                                     JSContext *cx,
 84863:                                     JS::Value *retval)
 84863: {
  6113:     JSAutoRequest ar(cx);
  6113: 
     1:     // first param must be a JSObject
105651:     if (!object.isObject())
     1:         return NS_ERROR_XPC_BAD_CONVERT_JS;
105651:     JSObject *obj = &object.toObject();
105651: 
105651:     // second param must be a string.
105651:     if (!JSVAL_IS_STRING(name))
105651:         return NS_ERROR_XPC_BAD_CONVERT_JS;
105651:     JSString *methodName = name.toString();
105651:     jsid methodId = INTERNED_STRING_TO_JSID(cx, JS_InternJSString(cx, methodName));
105651: 
105651:     // If |obj| is a cross-compartment wrapper, try to puncture it. If this fails,
105651:     // we don't have full access to the other compartment, in which case we throw.
105651:     // Otherwise, enter the compartment.
105651:     if (js::IsCrossCompartmentWrapper(obj)) {
105651:         obj = js::UnwrapOneChecked(cx, obj);
 77549:         if (!obj)
 77549:             return NS_ERROR_XPC_BAD_CONVERT_JS;
105651:     }
105651: 
105651:     {
105651:         // Enter the target compartment.
105651:         JSAutoEnterCompartment ac;
105651:         if (!ac.enter(cx, obj))
105651:             return NS_ERROR_FAILURE;
105651: 
105651:         // Now, try to create an Xray wrapper around the object. This won't work
105651:         // if the object isn't Xray-able. In that case, we throw.
105651:         JSObject *xray = WrapperFactory::WrapForSameCompartmentXray(cx, obj);
105651:         if (!xray)
 36853:             return NS_ERROR_XPC_BAD_CONVERT_JS;
  2890: 
105651:         // Alright, now do the lookup.
105651:         *retval = JSVAL_VOID;
105651:         JSPropertyDescriptor desc;
105651:         if (!JS_GetPropertyDescriptorById(cx, xray, methodId, 0, &desc))
105651:             return NS_ERROR_FAILURE;
105651: 
105651:         // First look for a method value. If that's not there, try a getter,
105651:         // since historically lookupMethod also works for getters.
105651:         JSObject *methodObj = desc.value.isObject() ? &desc.value.toObject() : NULL;
105651:         if (!methodObj && (desc.attrs & JSPROP_GETTER))
105651:             methodObj = JS_FUNC_TO_DATA_PTR(JSObject *, desc.getter);
105651: 
105651:         // Callers of this function seem to expect bound methods. Make it happen.
105651:         // Note that this is unnecessary until bug 658909 is fixed.
105651:         if (methodObj && JS_ObjectIsCallable(cx, methodObj))
105651:             methodObj = JS_BindCallable(cx, methodObj, obj);
105651: 
105651:         // Set the return value if appropriate.
105651:         *retval = methodObj ? ObjectValue(*methodObj) : JSVAL_VOID;
105651:     }
105651: 
105651:     // Now that we've left the target compartment, wrap for the caller.
105651:     if (!JS_WrapValue(cx, retval))
105651:         return NS_ERROR_FAILURE;;
105651: 
     1:     return NS_OK;
     1: }
     1: 
     1: /* void reportError (); */
     1: NS_IMETHODIMP
 84868: nsXPCComponents_Utils::ReportError(const JS::Value &error, JSContext *cx)
     1: {
     1:     // This function shall never fail! Silently eat any failure conditions.
     1: 
 80387:     nsCOMPtr<nsIConsoleService> console(do_GetService(NS_CONSOLESERVICE_CONTRACTID));
 80387: 
 86030:     nsCOMPtr<nsIScriptError> scripterr(do_CreateInstance(NS_SCRIPTERROR_CONTRACTID));
     1: 
 84868:     if (!scripterr || !console)
     1:         return NS_OK;
     1: 
  6082:     JSAutoRequest ar(cx);
  6082: 
 77330:     const PRUint64 innerWindowID = nsJSUtils::GetCurrentlyRunningCodeInnerWindowID(cx);
 59512: 
 84868:     JSErrorReport *err = JS_ErrorFromException(cx, error);
 80389:     if (err) {
     1:         // It's a proper JS Error
     1:         nsAutoString fileUni;
     1:         CopyUTF8toUTF16(err->filename, fileUni);
     1: 
     1:         PRUint32 column = err->uctokenptr - err->uclinebuf;
     1: 
 84868:         nsresult rv = scripterr->InitWithWindowID(
 84868:                 static_cast<const PRUnichar*>(err->ucmessage), fileUni.get(),
 84868:                 static_cast<const PRUnichar*>(err->uclinebuf), err->lineno,
 84868:                 column, err->flags, "XPConnect JavaScript", innerWindowID);
 84868:         NS_ENSURE_SUCCESS(rv, NS_OK);
     1: 
 86030:         console->LogMessage(scripterr);
     1:         return NS_OK;
     1:     }
     1: 
 84868:     // It's not a JS Error object, so we synthesize as best we're able.
 84868:     JSString *msgstr = JS_ValueToString(cx, error);
 84868:     if (!msgstr) {
 84868:         return NS_OK;
 84868:     }
     1: 
     1:     nsCOMPtr<nsIStackFrame> frame;
     1:     nsXPConnect *xpc = nsXPConnect::GetXPConnect();
     1:     if (xpc)
     1:         xpc->GetCurrentJSStack(getter_AddRefs(frame));
     1: 
     1:     nsXPIDLCString fileName;
     1:     PRInt32 lineNo = 0;
 80389:     if (frame) {
     1:         frame->GetFilename(getter_Copies(fileName));
     1:         frame->GetLineNumber(&lineNo);
     1:     }
     1: 
 59889:     const jschar *msgchars = JS_GetStringCharsZ(cx, msgstr);
 59889:     if (!msgchars)
 59889:         return NS_OK;
 59889: 
 84868:     nsresult rv = scripterr->InitWithWindowID(
 84868:             reinterpret_cast<const PRUnichar *>(msgchars),
     1:             NS_ConvertUTF8toUTF16(fileName).get(),
 84868:             nsnull, lineNo, 0, 0, "XPConnect JavaScript", innerWindowID);
 84868:     NS_ENSURE_SUCCESS(rv, NS_OK);
 84868: 
 86030:     console->LogMessage(scripterr);
     1:     return NS_OK;
     1: }
     1: 
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsIURI.h"
     1: #include "nsNetUtil.h"
     1: const char kScriptSecurityManagerContractID[] = NS_SCRIPTSECURITYMANAGER_CONTRACTID;
     1: 
 15495: NS_IMPL_THREADSAFE_ISUPPORTS1(PrincipalHolder, nsIScriptObjectPrincipal)
     1: 
     1: nsIPrincipal *
     1: PrincipalHolder::GetPrincipal()
     1: {
     1:     return mHoldee;
     1: }
     1: 
 18907: static JSBool
 91237: SandboxDump(JSContext *cx, unsigned argc, jsval *vp)
     1: {
     1:     JSString *str;
     1:     if (!argc)
 82794:         return true;
     1: 
 53557:     str = JS_ValueToString(cx, JS_ARGV(cx, vp)[0]);
     1:     if (!str)
 82794:         return false;
     1: 
 59889:     size_t length;
 59889:     const jschar *chars = JS_GetStringCharsZAndLength(cx, str, &length);
 43422:     if (!chars)
 82794:         return false;
     1: 
 59889:     nsDependentString wstr(chars, length);
 43422:     char *cstr = ToNewUTF8String(wstr);
 43422:     if (!cstr)
 82794:         return false;
 43422: 
 69620: #if defined(XP_MACOSX)
 43422:     // Be nice and convert all \r to \n.
 43422:     char *c = cstr, *cEnd = cstr + strlen(cstr);
 43422:     while (c < cEnd) {
 43422:         if (*c == '\r')
 43422:             *c = '\n';
 43422:         c++;
 43422:     }
 43422: #endif
 43422: 
 91627:     fputs(cstr, stdout);
 91627:     fflush(stdout);
 43422:     NS_Free(cstr);
 53557:     JS_SET_RVAL(cx, vp, JSVAL_TRUE);
 82794:     return true;
     1: }
     1: 
 18907: static JSBool
 91237: SandboxDebug(JSContext *cx, unsigned argc, jsval *vp)
     1: {
     1: #ifdef DEBUG
 53557:     return SandboxDump(cx, argc, vp);
     1: #else
 82794:     return true;
     1: #endif
     1: }
     1: 
 18907: static JSBool
 91237: SandboxImport(JSContext *cx, unsigned argc, jsval *vp)
 53557: {
 53557:     JSObject *thisobj = JS_THIS_OBJECT(cx, vp);
 53557:     if (!thisobj)
 82794:         return false;
 53557: 
 55590:     jsval *argv = JS_ARGV(cx, vp);
 55590:     if (argc < 1 || JSVAL_IS_PRIMITIVE(argv[0])) {
  3407:         XPCThrower::Throw(NS_ERROR_INVALID_ARG, cx);
 82794:         return false;
  3407:     }
  3407: 
  3407:     JSString *funname;
  3407:     if (argc > 1) {
  3407:         // Use the second parameter as the function name.
  3407:         funname = JS_ValueToString(cx, argv[1]);
  3407:         if (!funname)
 82794:             return false;
  3407:         argv[1] = STRING_TO_JSVAL(funname);
  3407:     } else {
 55601:         // NB: funobj must only be used to get the JSFunction out.
 55601:         JSObject *funobj = JSVAL_TO_OBJECT(argv[0]);
 79734:         if (js::IsProxy(funobj)) {
 71347:             funobj = XPCWrapper::UnsafeUnwrapSecurityWrapper(funobj);
 55601:         }
 55601: 
 55601:         JSAutoEnterCompartment ac;
 55601:         if (!ac.enter(cx, funobj)) {
 82794:             return false;
 55601:         }
 55601: 
 55601:         JSFunction *fun = JS_ValueToFunction(cx, OBJECT_TO_JSVAL(funobj));
 55601:         if (!fun) {
 55601:             XPCThrower::Throw(NS_ERROR_INVALID_ARG, cx);
 82794:             return false;
 55601:         }
 55601: 
  3407:         // Use the actual function name as the name.
  3407:         funname = JS_GetFunctionId(fun);
  3407:         if (!funname) {
  3407:             XPCThrower::Throw(NS_ERROR_INVALID_ARG, cx);
 82794:             return false;
  3407:         }
  3407:     }
  3407: 
 40559:     jsid id;
 40559:     if (!JS_ValueToId(cx, STRING_TO_JSVAL(funname), &id))
 82794:         return false;
 53557: 
 53557:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
 53557:     return JS_SetPropertyById(cx, thisobj, id, &argv[0]);
  3407: }
  3407: 
 18907: static JSBool
101616: CreateXMLHttpRequest(JSContext *cx, unsigned argc, jsval *vp)
101616: {
101616:     JSObject *global = JS_GetGlobalForScopeChain(cx);
101616:     MOZ_ASSERT(global);
101616: 
101616:     nsCOMPtr<nsISupports> inst;
101616:     nsresult rv;
101616:     inst = do_CreateInstance("@mozilla.org/xmlextras/xmlhttprequest;1", &rv);
101616:     if (NS_FAILED(rv))
101616:         return false;
101616: 
101616:     rv = nsContentUtils::WrapNative(cx, global, inst, vp);
101616:     if (NS_FAILED(rv))
101616:         return false;
101616: 
101616:     return true;
101616: }
101616: 
101616: static JSBool
 98960: sandbox_enumerate(JSContext *cx, JSHandleObject obj)
     1: {
     1:     return JS_EnumerateStandardClasses(cx, obj);
     1: }
     1: 
 18907: static JSBool
 98960: sandbox_resolve(JSContext *cx, JSHandleObject obj, JSHandleId id)
     1: {
     1:     JSBool resolved;
 55659:     return JS_ResolveStandardClass(cx, obj, id, &resolved);
     1: }
     1: 
 18907: static void
 94738: sandbox_finalize(JSFreeOp *fop, JSObject *obj)
     1: {
     1:     nsIScriptObjectPrincipal *sop =
 10858:         (nsIScriptObjectPrincipal *)xpc_GetJSPrivate(obj);
     1:     NS_IF_RELEASE(sop);
 94512:     DestroyProtoOrIfaceCache(obj);
     1: }
     1: 
 28927: static JSBool
 98960: sandbox_convert(JSContext *cx, JSHandleObject obj, JSType type, jsval *vp)
 28927: {
 28927:     if (type == JSTYPE_OBJECT) {
 28927:         *vp = OBJECT_TO_JSVAL(obj);
 82794:         return true;
 28927:     }
 28927: 
 28927:     return JS_ConvertStub(cx, obj, type, vp);
 28927: }
 28927: 
     1: static JSClass SandboxClass = {
     1:     "Sandbox",
 80070:     XPCONNECT_GLOBAL_FLAGS,
 62397:     JS_PropertyStub,   JS_PropertyStub, JS_PropertyStub, JS_StrictPropertyStub,
 28927:     sandbox_enumerate, sandbox_resolve, sandbox_convert,  sandbox_finalize,
 90546:     NULL, NULL, NULL, NULL, TraceXPCGlobal
     1: };
     1: 
     1: static JSFunctionSpec SandboxFunctions[] = {
 53557:     {"dump",    SandboxDump,    1,0},
 53557:     {"debug",   SandboxDebug,   1,0},
 53557:     {"importFunction", SandboxImport, 1,0},
 53557:     {nsnull,nsnull,0,0}
     1: };
     1: 
     1: /***************************************************************************/
     1: nsXPCComponents_utils_Sandbox::nsXPCComponents_utils_Sandbox()
     1: {
     1: }
     1: 
     1: nsXPCComponents_utils_Sandbox::~nsXPCComponents_utils_Sandbox()
     1: {
     1: }
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents_utils_Sandbox)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents_utils_Sandbox)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents_utils_Sandbox)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents_utils_Sandbox)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents_utils_Sandbox)
     1: 
     1: // We use the nsIXPScriptable macros to generate lots of stuff for us.
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents_utils_Sandbox
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents_utils_Sandbox"
     1: #define                             XPC_MAP_WANT_CALL
     1: #define                             XPC_MAP_WANT_CONSTRUCT
     1: #define XPC_MAP_FLAGS               0
     1: #include "xpc_map_end.h" /* This #undef's the above. */
     1: 
 56473: static bool
 56473: WrapForSandbox(JSContext *cx, bool wantXrays, jsval *vp)
 56473: {
 56473:     return wantXrays
 56473:            ? JS_WrapValue(cx, vp)
 56473:            : xpc::WrapperFactory::WaiveXrayAndWrap(cx, vp);
 56473: }
 56473: 
 56748: // Needed to distinguish multiple compartments with the same origin from each
 56748: // other. The only thing we need out of identity objects are unique addresses.
101869: class Identity MOZ_FINAL : public nsISupports
 56748: {
 56748:     NS_DECL_ISUPPORTS
 56748: };
 56748: 
 56748: NS_IMPL_ISUPPORTS0(Identity)
 56748: 
 95795: xpc::SandboxProxyHandler xpc::sandboxProxyHandler;
 95795: 
104537: // A proxy handler that lets us wrap callables and invoke them with
104537: // the correct this object, while forwarding all other operations down
104537: // to them directly.
104537: class SandboxCallableProxyHandler : public js::DirectWrapper {
104537: public:
104537:     SandboxCallableProxyHandler() : js::DirectWrapper(0)
104537:     {
104537:     }
104537: 
104537:     virtual bool call(JSContext *cx, JSObject *proxy, unsigned argc,
104537:                       Value *vp);
104537: };
104537: 
104537: bool
104537: SandboxCallableProxyHandler::call(JSContext *cx, JSObject *proxy, unsigned argc,
104537:                                   Value *vp)
104537: {
104537:     // We forward the call to our underlying callable. The callable to forward
104537:     // to can be gotten via GetProxyCall.
104537: 
104537:     // The parent of our proxy is the SandboxProxyHandler proxy
104537:     JSObject *sandboxProxy = JS_GetParent(proxy);
104537:     MOZ_ASSERT(js::IsProxy(sandboxProxy) &&
104537:                js::GetProxyHandler(sandboxProxy) == &xpc::sandboxProxyHandler);
104537: 
104537:     // The parent of the sandboxProxy is the sandbox global, and the
104537:     // target object is the original proto.
104537:     JSObject *sandboxGlobal = JS_GetParent(sandboxProxy);
104537:     MOZ_ASSERT(js::GetObjectJSClass(sandboxGlobal) == &SandboxClass);
104537: 
104537:     // If our this object is the sandbox global, we call with this set to the
104537:     // original proto instead.  Note that we very carefully avoid using JS_THIS
104537:     // or JS_THIS_OBJECT here, because we do NOT want to box undefined into the
104537:     // global.  Instead, we just pass it through to our callable, and it will
104537:     // compute the global based on its own scope chain, which will do the right
104537:     // thing.
104537:     JS::Value thisVal = JS_THIS_VALUE(cx, vp);
104537:     if (thisVal == ObjectValue(*sandboxGlobal)) {
104537:         thisVal = ObjectValue(*js::GetProxyTargetObject(sandboxProxy));
104537:     }
104537: 
104537:     return JS::Call(cx, thisVal, js::GetProxyCall(proxy), argc,
104537:                     JS_ARGV(cx, vp), vp);
104537: }
104537: 
104537: static SandboxCallableProxyHandler sandboxCallableProxyHandler;
104537: 
104537: // Wrap a callable such that if we're called with oldThisObj as the
104537: // "this" we will instead call it with newThisObj as the this.
104537: static JSObject*
104537: WrapCallable(JSContext *cx, JSObject *callable, JSObject *sandboxProtoProxy)
104537: {
104537:     MOZ_ASSERT(JS_ObjectIsCallable(cx, callable));
104537:     // Our proxy is wrapping the callable.  So we need to use the
104537:     // callable as the private.  We use the given sandboxProtoProxy as
104537:     // the parent, and our call() hook depends on that.
104537:     MOZ_ASSERT(js::IsProxy(sandboxProtoProxy) &&
104537:                js::GetProxyHandler(sandboxProtoProxy) ==
104537:                  &xpc::sandboxProxyHandler);
104537: 
104537:     // We need to pass the given callable in as the "call" and
104537:     // "construct" so we get a function proxy.
104537:     return js::NewProxyObject(cx, &sandboxCallableProxyHandler,
104537:                               ObjectValue(*callable), nsnull,
104537:                               sandboxProtoProxy, callable, callable);
104537: }
104537: 
 95795: template<typename Op>
104537: bool BindPropertyOp(JSContext *cx, Op& op, PropertyDescriptor *desc, jsid id,
104537:                     unsigned attrFlag, JSObject *sandboxProtoProxy)
 95795: {
 95795:     if (!op) {
 95795:         return true;
 95795:     }
 95795: 
 95795:     JSObject *func;
 95795:     if (desc->attrs & attrFlag) {
 95795:         // Already an object
 95795:         func = JS_FUNC_TO_DATA_PTR(JSObject *, op);
 95795:     } else {
 95795:         // We have an actual property op.  For getters, we use 0
 95795:         // args, for setters we use 1 arg.
 95795:         uint32_t args = (attrFlag == JSPROP_GETTER) ? 0 : 1;
 95795:         func = GeneratePropertyOp(cx, desc->obj, id, args, op);
 95795:         if (!func)
 95795:             return false;
 95795:     }
104537:     func = WrapCallable(cx, func, sandboxProtoProxy);
 95795:     if (!func)
 95795:         return false;
 95795:     op = JS_DATA_TO_FUNC_PTR(Op, func);
 95795:     desc->attrs |= attrFlag;
 95795:     return true;
 95795: }
 95795: 
 97884: extern JSBool
 98960: XPC_WN_Helper_GetProperty(JSContext *cx, JSHandleObject obj, JSHandleId id, jsval *vp);
 97884: extern JSBool
 98960: XPC_WN_Helper_SetProperty(JSContext *cx, JSHandleObject obj, JSHandleId id, JSBool strict, jsval *vp);
 97884: 
 95795: bool
 95795: xpc::SandboxProxyHandler::getPropertyDescriptor(JSContext *cx, JSObject *proxy,
 98960:                                                 jsid id_, bool set,
 95795:                                                 PropertyDescriptor *desc)
 95795: {
 99421:     JS::RootedObject obj(cx, wrappedObject(proxy));
 99421:     JS::RootedId id(cx, id_);
 98960: 
 95795:     JS_ASSERT(js::GetObjectCompartment(obj) == js::GetObjectCompartment(proxy));
 95795:     // XXXbz Not sure about the JSRESOLVE_QUALIFIED here, but we have
 95795:     // no way to tell for sure whether to use it.
 95795:     if (!JS_GetPropertyDescriptorById(cx, obj, id,
 95795:                                       (set ? JSRESOLVE_ASSIGNING : 0) | JSRESOLVE_QUALIFIED,
 95795:                                       desc))
 95795:         return false;
 95795: 
 95795:     if (!desc->obj)
 95795:         return true; // No property, nothing to do
 95795: 
 95795:     // Now fix up the getter/setter/value as needed to be bound to desc->obj
 95795:     // Don't mess with holder_get and holder_set, though, because those rely on
 95795:     // the "vp is prefilled with the value in the slot" behavior that property
 95795:     // ops can in theory rely on, but our property op forwarder doesn't know how
 95795:     // to make that happen.  Since we really only need to rebind the DOM methods
 95795:     // here, not rebindings holder_get and holder_set is OK.
 97884:     //
 97884:     // Similarly, don't mess with XPC_WN_Helper_GetProperty and
 97884:     // XPC_WN_Helper_SetProperty, for the same reasons: that could confuse our
 97884:     // access to expandos when we're not doing Xrays.
 95795:     if (desc->getter != xpc::holder_get &&
 97884:         desc->getter != XPC_WN_Helper_GetProperty &&
104537:         !BindPropertyOp(cx, desc->getter, desc, id, JSPROP_GETTER, proxy))
 95795:         return false;
 95795:     if (desc->setter != xpc::holder_set &&
 97884:         desc->setter != XPC_WN_Helper_SetProperty &&
104537:         !BindPropertyOp(cx, desc->setter, desc, id, JSPROP_SETTER, proxy))
 95795:         return false;
 95795:     if (desc->value.isObject()) {
 95795:         JSObject* val = &desc->value.toObject();
 95795:         if (JS_ObjectIsCallable(cx, val)) {
104537:             val = WrapCallable(cx, val, proxy);
 95795:             if (!val)
 95795:                 return false;
 95795:             desc->value = ObjectValue(*val);
 95795:         }
 95795:     }
 95795: 
 95795:     return true;
 95795: }
 95795: 
 95795: bool
 95795: xpc::SandboxProxyHandler::getOwnPropertyDescriptor(JSContext *cx,
 95795:                                                    JSObject *proxy,
 95795:                                                    jsid id, bool set,
 95795:                                                    PropertyDescriptor *desc)
 95795: {
 95795:     if (!getPropertyDescriptor(cx, proxy, id, set, desc))
 95795:         return false;
 95795: 
 95795:     if (desc->obj != wrappedObject(proxy))
 95795:         desc->obj = nsnull;
 95795: 
 95795:     return true;
 95795: }
 95795: 
     1: nsresult
101616: xpc_CreateSandboxObject(JSContext *cx, jsval *vp, nsISupports *prinOrSop, SandboxOptions& options)
     1: {
     1:     // Create the sandbox global object
     1:     nsresult rv;
     1:     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
     1:     if (NS_FAILED(rv))
     1:         return NS_ERROR_XPC_UNEXPECTED;
     1: 
     1:     nsCOMPtr<nsIScriptObjectPrincipal> sop(do_QueryInterface(prinOrSop));
     1: 
     1:     if (!sop) {
     1:         nsCOMPtr<nsIPrincipal> principal(do_QueryInterface(prinOrSop));
     1: 
     1:         if (!principal) {
     1:             principal = do_CreateInstance("@mozilla.org/nullprincipal;1", &rv);
     1:             NS_ASSERTION(NS_FAILED(rv) || principal,
     1:                          "Bad return from do_CreateInstance");
     1: 
     1:             if (!principal || NS_FAILED(rv)) {
 40558:                 if (NS_SUCCEEDED(rv)) {
     1:                     rv = NS_ERROR_FAILURE;
 40558:                 }
     1: 
     1:                 return rv;
     1:             }
     1:         }
     1: 
     1:         sop = new PrincipalHolder(principal);
     1:         if (!sop)
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
 48503:     nsIPrincipal *principal = sop->GetPrincipal();
 55675: 
 48503:     JSCompartment *compartment;
 48503:     JSObject *sandbox;
 48503: 
 97461:     nsRefPtr<Identity> identity = new Identity();
 97461:     rv = xpc_CreateGlobalObject(cx, &SandboxClass, principal, identity,
101616:                                 options.wantXrays, &sandbox, &compartment);
 48503:     NS_ENSURE_SUCCESS(rv, rv);
 48503: 
 86990:     JS::AutoObjectRooter tvr(cx, sandbox);
 47550: 
 47550:     {
 54733:         JSAutoEnterCompartment ac;
 47550:         if (!ac.enter(cx, sandbox))
 47550:             return NS_ERROR_XPC_UNEXPECTED;
 47550: 
101616:         if (options.proto) {
101616:             bool ok = JS_WrapObject(cx, &options.proto);
 55675:             if (!ok)
 55675:                 return NS_ERROR_XPC_UNEXPECTED;
 55675: 
101616:             if (xpc::WrapperFactory::IsXrayWrapper(options.proto) && !options.wantXrays) {
101616:                 jsval v = OBJECT_TO_JSVAL(options.proto);
 59624:                 if (!xpc::WrapperFactory::WaiveXrayAndWrap(cx, &v))
 59624:                     return NS_ERROR_FAILURE;
101616:                 options.proto = JSVAL_TO_OBJECT(v);
 55675:             }
 55675: 
 95795:             // Now check what sort of thing we've got in |proto|
101616:             JSObject *unwrappedProto = js::UnwrapObject(options.proto, false);
 95795:             js::Class *unwrappedClass = js::GetObjectClass(unwrappedProto);
 95795:             if (IS_WRAPPER_CLASS(unwrappedClass) ||
 97422:                 mozilla::dom::IsDOMClass(Jsvalify(unwrappedClass))) {
 95795:                 // Wrap it up in a proxy that will do the right thing in terms
 95795:                 // of this-binding for methods.
101616:                 options.proto = js::NewProxyObject(cx, &xpc::sandboxProxyHandler,
101616:                                                    ObjectValue(*options.proto), nsnull,
 95795:                                                    sandbox);
101616:                 if (!options.proto)
 95795:                     return NS_ERROR_OUT_OF_MEMORY;
 95795:             }
 95795: 
101616:             ok = JS_SetPrototype(cx, sandbox, options.proto);
 55675:             if (!ok)
 55675:                 return NS_ERROR_XPC_UNEXPECTED;
 55675:         }
 55675: 
     1:         // Pass on ownership of sop to |sandbox|.
 89826:         JS_SetPrivate(sandbox, sop.forget().get());
     1: 
 99153:         XPCCallContext ccx(NATIVE_CALLER, cx);
 99153:         if (!ccx.IsValid())
 99153:             return NS_ERROR_XPC_UNEXPECTED;
 99153: 
 99153:         {
 99153:           JSAutoEnterCompartment ac;
 99153:           if (!ac.enter(ccx, sandbox))
 99153:               return NS_ERROR_XPC_UNEXPECTED;
 99153:           XPCWrappedNativeScope* scope =
 99153:               XPCWrappedNativeScope::GetNewOrUsed(ccx, sandbox);
 99153: 
 99153:           if (!scope)
 99153:               return NS_ERROR_XPC_UNEXPECTED;
 99153: 
101616:           if (options.wantComponents &&
101616:               !nsXPCComponents::AttachComponentsObject(ccx, scope, sandbox))
 99153:               return NS_ERROR_XPC_UNEXPECTED;
 99153: 
 99153:           if (!XPCNativeWrapper::AttachNewConstructorObject(ccx, sandbox))
 99153:               return NS_ERROR_XPC_UNEXPECTED;
 99153:         }
 99153: 
 99153:         if (!JS_DefineFunctions(cx, sandbox, SandboxFunctions))
     1:             return NS_ERROR_XPC_UNEXPECTED;
101616: 
101616:         if (options.wantXHRConstructor &&
101616:             !JS_DefineFunction(cx, sandbox, "XMLHttpRequest", CreateXMLHttpRequest, 0, JSFUN_CONSTRUCTOR))
101616:             return NS_ERROR_XPC_UNEXPECTED;
 47550:     }
     1: 
 40558:     if (vp) {
     1:         *vp = OBJECT_TO_JSVAL(sandbox);
101616:         if (!WrapForSandbox(cx, options.wantXrays, vp)) {
 55590:             return NS_ERROR_UNEXPECTED;
 40558:         }
 40558:     }
  3407: 
 99154:     // Set the location information for the new global, so that tools like
 99154:     // about:memory may use that information
101616:     xpc::SetLocationForGlobal(sandbox, options.sandboxName);
 76944: 
     1:     return NS_OK;
     1: }
     1: 
 79445: /* bool call(in nsIXPConnectWrappedNative wrapper,
     1:                in JSContextPtr cx,
     1:                in JSObjectPtr obj,
     1:                in PRUint32 argc,
     1:                in JSValPtr argv,
     1:                in JSValPtr vp);
     1: */
     1: NS_IMETHODIMP
     1: nsXPCComponents_utils_Sandbox::Call(nsIXPConnectWrappedNative *wrapper,
     1:                                     JSContext * cx,
     1:                                     JSObject * obj,
     1:                                     PRUint32 argc,
     1:                                     jsval * argv,
     1:                                     jsval * vp,
 79445:                                     bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: }
     1: 
 79445: /* bool construct(in nsIXPConnectWrappedNative wrapper,
     1:                     in JSContextPtr cx,
     1:                     in JSObjectPtr obj,
     1:                     in PRUint32 argc,
     1:                     in JSValPtr argv,
     1:                     in JSValPtr vp);
     1: */
     1: NS_IMETHODIMP
     1: nsXPCComponents_utils_Sandbox::Construct(nsIXPConnectWrappedNative *wrapper,
     1:                                          JSContext * cx,
     1:                                          JSObject * obj,
     1:                                          PRUint32 argc,
     1:                                          jsval * argv,
     1:                                          jsval * vp,
 79445:                                          bool *_retval)
     1: {
     1:     return CallOrConstruct(wrapper, cx, obj, argc, argv, vp, _retval);
     1: }
     1: 
101616: // for sandbox constructor the first argument can be a URI string in which case
101616: // we use the related Codebase Principal for the sandbox
101616: nsresult
101616: GetPrincipalFromString(JSContext *cx, JSString *codebase, nsIPrincipal **principal)
101616: {
101616:     MOZ_ASSERT(principal);
101616:     MOZ_ASSERT(codebase);
101616:     nsCOMPtr<nsIURI> uri;
101616:     nsDependentJSString codebaseStr;
101616:     NS_ENSURE_TRUE(codebaseStr.init(cx, codebase), NS_ERROR_FAILURE);
101616:     nsresult rv = NS_NewURI(getter_AddRefs(uri), codebaseStr);
101616:     NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:     nsCOMPtr<nsIScriptSecurityManager> secman =
101616:         do_GetService(kScriptSecurityManagerContractID);
101616:     NS_ENSURE_TRUE(secman, NS_ERROR_FAILURE);
101616: 
106023:     // We could allow passing in the app-id and browser-element info to the
106023:     // sandbox constructor. But creating a sandbox based on a string is a
106023:     // deprecated API so no need to add features to it.
106023:     rv = secman->GetNoAppCodebasePrincipal(uri, principal);
101616:     NS_ENSURE_SUCCESS(rv, rv);
101616:     NS_ENSURE_TRUE(*principal, NS_ERROR_FAILURE);
101616: 
101616:     return NS_OK;
101616: }
101616: 
101616: // for sandbox constructor  the first argument can be a principal object or
101616: // a script object principal (Document, Window)
101616: nsresult
101616: GetPrincipalOrSOP(JSContext *cx, JSObject &from, nsISupports **out)
101616: {
101616:     MOZ_ASSERT(out);
101616:     *out = NULL;
101616: 
101616:     nsCOMPtr<nsIXPConnect> xpc = nsXPConnect::GetXPConnect();
101616:     if (!xpc)
101616:         return NS_ERROR_XPC_UNEXPECTED;
101616:     nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
101616:     xpc->GetWrappedNativeOfJSObject(cx, &from,
101616:                                     getter_AddRefs(wrapper));
101616: 
101616:     NS_ENSURE_TRUE(wrapper, NS_ERROR_INVALID_ARG);
101616: 
101616:     if (nsCOMPtr<nsIScriptObjectPrincipal> sop = do_QueryWrappedNative(wrapper)) {
101616:         sop.forget(out);
101616:         return NS_OK;
101616:     }
101616: 
101616:     nsCOMPtr<nsIPrincipal> principal = do_QueryWrappedNative(wrapper);
101616:     principal.forget(out);
101616:     NS_ENSURE_TRUE(*out, NS_ERROR_INVALID_ARG);
101616: 
101616:     return NS_OK;
101616: }
101616: 
101616: // the first parameter of the sandbox constructor might be an array of principals, either in string
101616: // format or actual objects (see GetPrincipalOrSOP)
101616: nsresult
101616: GetExpandedPrincipal(JSContext *cx, JSObject &arrayObj, nsIExpandedPrincipal **out)
101616: {
101616:     MOZ_ASSERT(out);
101616:     uint32_t length;
101616: 
101616:     if (!JS_IsArrayObject(cx, &arrayObj) ||
101616:         !JS_GetArrayLength(cx, &arrayObj, &length) ||
101616:         !length)
101616:     {
101616:         // we need a white list of principals or uri strings to create an
101616:         // expanded principal, if we got an empty array or something else
101616:         // report error
101616:         return NS_ERROR_INVALID_ARG;
101616:     }
101616: 
101616:     nsTArray< nsCOMPtr<nsIPrincipal> > allowedDomains(length);
101616:     allowedDomains.SetLength(length);
101616:     nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
101616:     NS_ENSURE_TRUE(ssm, NS_ERROR_XPC_UNEXPECTED);
101616: 
101616:     for (uint32_t i = 0; i < length; ++i) {
101616:         jsval allowed;
101616: 
101616:         if (!JS_GetElement(cx, &arrayObj, i, &allowed))
101616:             return NS_ERROR_INVALID_ARG;
101616: 
101616:         nsresult rv;
101616:         nsCOMPtr<nsIPrincipal> principal;
101616:         if (allowed.isString()) {
101616:             // in case of string let's try to fetch a codebase principal from it
101616:             rv = GetPrincipalFromString(cx, allowed.toString(), getter_AddRefs(principal));
101616:             NS_ENSURE_SUCCESS(rv, rv);
101616:         } else if (allowed.isObject()) {
101616:             // in case of object let's see if it's a Principal or a ScriptObjectPrincipal
101616:             nsCOMPtr<nsISupports> prinOrSop;
101616:             rv = GetPrincipalOrSOP(cx, allowed.toObject(), getter_AddRefs(prinOrSop));
101616:             NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:             nsCOMPtr<nsIScriptObjectPrincipal> sop(do_QueryInterface(prinOrSop));
101616:             principal = do_QueryInterface(prinOrSop);
101616:             if (sop) {
101616:                 principal = sop->GetPrincipal();
101616:             }
101616:         }
101616:         NS_ENSURE_TRUE(principal, NS_ERROR_INVALID_ARG);
101616: 
101616:         // We do not allow ExpandedPrincipals to contain any system principals
101616:         bool isSystem;
101616:         rv = ssm->IsSystemPrincipal(principal, &isSystem);
101616:         NS_ENSURE_SUCCESS(rv, rv);
101616:         NS_ENSURE_FALSE(isSystem, NS_ERROR_INVALID_ARG);
101616:         allowedDomains[i] = principal;
101616:   }
101616: 
101616:   nsCOMPtr<nsIExpandedPrincipal> result = new nsExpandedPrincipal(allowedDomains);
101616:   result.forget(out);
101616:   return NS_OK;
101616: }
101616: 
101616: // helper that tries to get a property form the options object
101616: nsresult
101616: GetPropFromOptions(JSContext *cx, JSObject &from, const char *name, jsval *prop, JSBool *found)
101616: {
101616:     if (!JS_HasProperty(cx, &from, name, found))
101616:         return NS_ERROR_INVALID_ARG;
101616: 
101616:     if (found && !JS_GetProperty(cx, &from, name, prop))
101616:         return NS_ERROR_INVALID_ARG;
101616: 
101616:     return NS_OK;
101616: }
101616: 
101616: // helper that tries to get a boolean property form the options object
101616: nsresult
101616: GetBoolPropFromOptions(JSContext *cx, JSObject &from, const char *name, bool *prop)
101616: {
101616:     MOZ_ASSERT(prop);
101616:     jsval propVal;
101616:     JSBool found;
101616:     if (NS_FAILED(GetPropFromOptions(cx, from, name, &propVal, &found)))
101616:         return NS_ERROR_INVALID_ARG;
101616: 
101616:     if (!found)
101616:         return NS_OK;
101616: 
101616:     if (!propVal.isBoolean())
101616:         return NS_ERROR_INVALID_ARG;
101616: 
101616:     *prop = propVal.toBoolean();
101616:     return NS_OK;
101616: }
101616: 
101616: // helper that tries to get an object property form the options object
101616: nsresult
101616: GetObjPropFromOptions(JSContext *cx, JSObject &from, const char *name, JSObject **prop)
101616: {
101616:     MOZ_ASSERT(prop);
101616:     jsval propVal;
101616:     JSBool found;
101616: 
101616:     if (NS_FAILED(GetPropFromOptions(cx, from, name, &propVal, &found)))
101616:         return NS_ERROR_INVALID_ARG;
101616: 
101616:     if (!found) {
101616:         *prop = NULL;
101616:         return NS_OK;
101616:     }
101616: 
101616:     if (!propVal.isObject())
101616:         return NS_ERROR_INVALID_ARG;
101616: 
101616:     *prop = &propVal.toObject();
101616:     return NS_OK;
101616: }
101616: 
101616: // helper that tries to get a string property form the options object
101616: nsresult
101616: GetStringPropFromOptions(JSContext *cx, JSObject &from, const char *name, nsCString &prop)
101616: {
101616:     jsval propVal;
101616:     JSBool found;
101616:     nsresult rv = GetPropFromOptions(cx, from, name, &propVal, &found);
101616:     NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:     if (!found)
101616:         return NS_OK;
101616: 
101616:     NS_ENSURE_TRUE(propVal.isString(), NS_ERROR_INVALID_ARG);
101616: 
101616:     char *tmp = JS_EncodeString(cx, propVal.toString());
101616:     NS_ENSURE_TRUE(tmp, NS_ERROR_INVALID_ARG);
101616:     prop.Adopt(tmp, strlen(tmp));
101616:     return NS_OK;
101616: }
101616: 
101616: // helper that parsing the sandbox options object (from) and sets the fields of the incoming options struct (options)
101616: nsresult
101616: ParseOptionsObject(JSContext *cx, jsval from, SandboxOptions &options)
101616: {
101616:     NS_ENSURE_TRUE(from.isObject(), NS_ERROR_INVALID_ARG);
101616:     JSObject &optionsObject = from.toObject();
101616:     nsresult rv = GetObjPropFromOptions(cx, optionsObject,
101616:                                         "sandboxPrototype", &options.proto);
101616:     NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:     rv = GetBoolPropFromOptions(cx, optionsObject,
101616:                                 "wantXrays", &options.wantXrays);
101616:     NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:     rv = GetBoolPropFromOptions(cx, optionsObject,
101616:                                 "wantComponents", &options.wantComponents);
101616:     NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:     rv = GetBoolPropFromOptions(cx, optionsObject,
101616:                                 "wantXHRConstructor", &options.wantXHRConstructor);
101616:     NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:     rv = GetStringPropFromOptions(cx, optionsObject,
101616:                                   "sandboxName", options.sandboxName);
101616:     NS_ENSURE_SUCCESS(rv, rv);
101616: 
101616:     return NS_OK;
101616: }
101616: 
102234: static nsresult
102234: AssembleSandboxMemoryReporterName(JSContext *cx, nsCString &sandboxName)
102234: {
102234:     // Use a default name when the caller did not provide a sandboxName.
102234:     if (sandboxName.IsEmpty())
102234:         sandboxName = NS_LITERAL_CSTRING("[anonymous sandbox]");
102234: 
101616:     nsXPConnect* xpc = nsXPConnect::GetXPConnect();
101616:     NS_ENSURE_TRUE(xpc, NS_ERROR_XPC_UNEXPECTED);
101616: 
101616:     // Get the xpconnect native call context.
101616:     nsAXPCNativeCallContext *cc = nsnull;
101616:     xpc->GetCurrentNativeCallContext(&cc);
101616:     NS_ENSURE_TRUE(cc, NS_ERROR_INVALID_ARG);
101616: 
101616:     // Get the current source info from xpc.
101616:     nsCOMPtr<nsIStackFrame> frame;
101616:     xpc->GetCurrentJSStack(getter_AddRefs(frame));
101616: 
102234:     // Append the caller's location information.
102234:     if (frame) {
102234:         nsCString location;
102234:         PRInt32 lineNumber = 0;
102234:         frame->GetFilename(getter_Copies(location));
102234:         frame->GetLineNumber(&lineNumber);
102234:         
102234:         sandboxName.AppendLiteral(" (from: ");
102234:         sandboxName.Append(location);
102234:         sandboxName.AppendLiteral(":");
102234:         sandboxName.AppendInt(lineNumber);
102234:         sandboxName.AppendLiteral(")");
102234:     }
101616: 
101616:     return NS_OK;
101616: }
101616: 
 30017: // static
 30017: nsresult
     1: nsXPCComponents_utils_Sandbox::CallOrConstruct(nsIXPConnectWrappedNative *wrapper,
     1:                                                JSContext * cx, JSObject * obj,
 98362:                                                PRUint32 argc, JS::Value * argv,
 79445:                                                jsval * vp, bool *_retval)
     1: {
     1:     if (argc < 1)
     1:         return ThrowAndFail(NS_ERROR_XPC_NOT_ENOUGH_ARGS, cx, _retval);
     1: 
     1:     nsresult rv;
     1: 
     1:     // Make sure to set up principals on the sandbox before initing classes
     1:     nsCOMPtr<nsIPrincipal> principal;
101616:     nsCOMPtr<nsIExpandedPrincipal> expanded;
101616:     nsCOMPtr<nsISupports> prinOrSop;
101616: 
 98362:     if (argv[0].isString()) {
101616:         rv = GetPrincipalFromString(cx, argv[0].toString(), getter_AddRefs(principal));
101616:         prinOrSop = principal;
101616:     } else if (argv[0].isObject()) {
101616:         if (JS_IsArrayObject(cx, &argv[0].toObject())) {
101616:             rv = GetExpandedPrincipal(cx, argv[0].toObject(), getter_AddRefs(expanded));
101616:             prinOrSop = expanded;
101616:         } else {
101616:             rv = GetPrincipalOrSOP(cx, argv[0].toObject(), getter_AddRefs(prinOrSop));
101616:         }
101616:     } else {
101616:         return ThrowAndFail(NS_ERROR_INVALID_ARG, cx, _retval);
101616:     }
101616: 
101616:     if (NS_FAILED(rv))
101615:         return ThrowAndFail(rv, cx, _retval);
101616: 
101616:     SandboxOptions options;
101616: 
101616:     if (argc > 1 && NS_FAILED(ParseOptionsObject(cx, argv[1], options)))
101591:         return ThrowAndFail(NS_ERROR_INVALID_ARG, cx, _retval);
101615: 
102234:     if (NS_FAILED(AssembleSandboxMemoryReporterName(cx, options.sandboxName)))
 89156:         return ThrowAndFail(NS_ERROR_INVALID_ARG, cx, _retval);
101616: 
101616:     rv = xpc_CreateSandboxObject(cx, vp, prinOrSop, options);
101616: 
101616:     if (NS_FAILED(rv))
     1:         return ThrowAndFail(rv, cx, _retval);
     1: 
 80486:     *_retval = true;
     1: 
     1:     return rv;
     1: }
     1: 
103008: class ContextHolder : public nsIScriptObjectPrincipal
103008:                     , public nsIScriptContextPrincipal
     1: {
     1: public:
103008:     ContextHolder(JSContext *aOuterCx, JSObject *aSandbox, nsIPrincipal *aPrincipal);
 39552:     virtual ~ContextHolder();
     1: 
     1:     JSContext * GetJSContext()
     1:     {
     1:         return mJSContext;
     1:     }
     1: 
103008:     nsIScriptObjectPrincipal * GetObjectPrincipal() { return this; }
103008:     nsIPrincipal * GetPrincipal() { return mPrincipal; }
103008: 
     1:     NS_DECL_ISUPPORTS
     1: 
     1: private:
 18907:     static JSBool ContextHolderOperationCallback(JSContext *cx);
     1: 
 39552:     JSContext* mJSContext;
     1:     JSContext* mOrigCx;
103008:     nsCOMPtr<nsIPrincipal> mPrincipal;
     1: };
     1: 
103008: NS_IMPL_ISUPPORTS2(ContextHolder, nsIScriptObjectPrincipal, nsIScriptContextPrincipal)
     1: 
101313: ContextHolder::ContextHolder(JSContext *aOuterCx,
101313:                              JSObject *aSandbox,
103008:                              nsIPrincipal *aPrincipal)
 39552:     : mJSContext(JS_NewContext(JS_GetRuntime(aOuterCx), 1024)),
103008:       mOrigCx(aOuterCx),
103008:       mPrincipal(aPrincipal)
     1: {
 80389:     if (mJSContext) {
103008:         bool isChrome;
103008:         DebugOnly<nsresult> rv = XPCWrapper::GetSecurityManager()->
103008:                                    IsSystemPrincipal(mPrincipal, &isChrome);
103008:         MOZ_ASSERT(NS_SUCCEEDED(rv));
101313:         bool allowXML = Preferences::GetBool(isChrome ?
101313:                                              "javascript.options.xml.chrome" :
101313:                                              "javascript.options.xml.content");
101313: 
 35587:         JSAutoRequest ar(mJSContext);
     1:         JS_SetOptions(mJSContext,
 74456:                       JS_GetOptions(mJSContext) |
     1:                       JSOPTION_DONT_REPORT_UNCAUGHT |
 99821:                       JSOPTION_PRIVATE_IS_NSISUPPORTS |
101313:                       (allowXML ? JSOPTION_ALLOW_XML : 0));
     1:         JS_SetGlobalObject(mJSContext, aSandbox);
     1:         JS_SetContextPrivate(mJSContext, this);
 25087:         JS_SetOperationCallback(mJSContext, ContextHolderOperationCallback);
 23442:     }
     1: }
     1: 
 39552: ContextHolder::~ContextHolder()
 39552: {
 39552:     if (mJSContext)
 39552:         JS_DestroyContextNoGC(mJSContext);
 39552: }
 39552: 
 18907: JSBool
 10142: ContextHolder::ContextHolderOperationCallback(JSContext *cx)
     1: {
     1:     ContextHolder* thisObject =
  3233:         static_cast<ContextHolder*>(JS_GetContextPrivate(cx));
     1:     NS_ASSERTION(thisObject, "How did that happen?");
     1: 
 10142:     JSContext *origCx = thisObject->mOrigCx;
 10142:     JSOperationCallback callback = JS_GetOperationCallback(origCx);
 82794:     JSBool ok = true;
 10142:     if (callback)
 10142:         ok = callback(origCx);
 10142:     return ok;
 10142: }
     1: 
     1: /***************************************************************************/
     1: 
     1: /* void evalInSandbox(in AString source, in nativeobj sandbox); */
     1: NS_IMETHODIMP
 84866: nsXPCComponents_Utils::EvalInSandbox(const nsAString& source,
 84866:                                      const JS::Value& sandboxVal,
 84866:                                      const JS::Value& version,
 84866:                                      const JS::Value& filenameVal,
 84866:                                      PRInt32 lineNumber,
 84866:                                      JSContext *cx,
 84866:                                      PRUint8 optionalArgc,
 84866:                                      JS::Value *retval)
 84866: {
 24474:     JSObject *sandbox;
 84866:     if (!JS_ValueToObject(cx, sandboxVal, &sandbox) || !sandbox)
     1:         return NS_ERROR_INVALID_ARG;
 24474: 
 84866:     // Optional third argument: JS version, as a string.
 24474:     JSVersion jsVersion = JSVERSION_DEFAULT;
 84866:     if (optionalArgc >= 1) {
 84866:         JSString *jsVersionStr = JS_ValueToString(cx, version);
 84866:         if (!jsVersionStr)
 84866:             return NS_ERROR_INVALID_ARG;
 84866: 
 57812:         JSAutoByteString bytes(cx, jsVersionStr);
 57812:         if (!bytes)
 57812:             return NS_ERROR_INVALID_ARG;
 84866: 
 57812:         jsVersion = JS_StringToVersion(bytes.ptr());
 24474:         if (jsVersion == JSVERSION_UNKNOWN)
 24474:             return NS_ERROR_INVALID_ARG;
 24474:     }
 24474: 
 84866:     // Optional fourth and fifth arguments: filename and line number.
 84866:     nsXPIDLCString filename;
 84866:     PRInt32 lineNo = (optionalArgc >= 3) ? lineNumber : 0;
 84866:     if (optionalArgc >= 2) {
 84866:         JSString *filenameStr = JS_ValueToString(cx, filenameVal);
 84866:         if (!filenameStr)
 84866:             return NS_ERROR_INVALID_ARG;
 84866: 
 57812:         JSAutoByteString filenameBytes;
 57812:         if (!filenameBytes.encode(cx, filenameStr))
 57812:             return NS_ERROR_INVALID_ARG;
 57812:         filename = filenameBytes.ptr();
 24474:     } else {
     1:         // Get the current source info from xpc.
 84866:         nsresult rv;
 84866:         nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID(), &rv);
 84866:         NS_ENSURE_SUCCESS(rv, rv);
 84866: 
     1:         nsCOMPtr<nsIStackFrame> frame;
     1:         xpc->GetCurrentJSStack(getter_AddRefs(frame));
     1:         if (frame) {
     1:             frame->GetFilename(getter_Copies(filename));
     1:             frame->GetLineNumber(&lineNo);
     1:         }
     1:     }
     1: 
 84866:     return xpc_EvalInSandbox(cx, sandbox, source, filename.get(), lineNo,
 84866:                              jsVersion, false, retval);
 68602: }
 68602: 
     1: nsresult
     1: xpc_EvalInSandbox(JSContext *cx, JSObject *sandbox, const nsAString& source,
  3573:                   const char *filename, PRInt32 lineNo,
 79445:                   JSVersion jsVersion, bool returnStringOnly, jsval *rval)
     1: {
 81562:     JS_AbortIfWrongThread(JS_GetRuntime(cx));
 81562: 
 40559: #ifdef DEBUG
 40559:     // NB: The "unsafe" unwrap here is OK because we must be called from chrome.
 40559:     {
 40559:         nsIScriptSecurityManager *ssm = XPCWrapper::GetSecurityManager();
 40559:         if (ssm) {
 41435:             JSStackFrame *fp;
 41435:             nsIPrincipal *subjectPrincipal =
 41435:                 ssm->GetCxSubjectPrincipalAndFrame(cx, &fp);
 79445:             bool system;
 40559:             ssm->IsSystemPrincipal(subjectPrincipal, &system);
 47338:             if (fp && !system) {
 47338:                 ssm->IsCapabilityEnabled("UniversalXPConnect", &system);
 47338:                 NS_ASSERTION(system, "Bad caller!");
 47338:             }
 40559:         }
 40559:     }
 40559: #endif
 40559: 
 71347:     sandbox = XPCWrapper::UnsafeUnwrapSecurityWrapper(sandbox);
 79734:     if (!sandbox || js::GetObjectJSClass(sandbox) != &SandboxClass) {
     1:         return NS_ERROR_INVALID_ARG;
 40558:     }
     1: 
     1:     nsIScriptObjectPrincipal *sop =
 10858:         (nsIScriptObjectPrincipal*)xpc_GetJSPrivate(sandbox);
     1:     NS_ASSERTION(sop, "Invalid sandbox passed");
     1:     nsCOMPtr<nsIPrincipal> prin = sop->GetPrincipal();
     1: 
 91900:     if (!prin) {
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
 91900:     nsCAutoString filenameBuf;
 91900:     if (!filename) {
 91900:         // Default to the spec of the principal.
 91900:         nsJSPrincipals::get(prin)->GetScriptLocation(filenameBuf);
 91900:         filename = filenameBuf.get();
 91900:         lineNo = 1;
 91900:     }
 91900: 
 40558:     JSObject *callingScope;
 40558:     {
 40558:         JSAutoRequest req(cx);
 40558: 
 80154:         callingScope = JS_GetGlobalForScopeChain(cx);
 40558:         if (!callingScope) {
 62851:             return NS_ERROR_FAILURE;
 62851:         }
 40558:     }
 40558: 
103008:     nsRefPtr<ContextHolder> sandcx = new ContextHolder(cx, sandbox, prin);
     1:     if (!sandcx || !sandcx->GetJSContext()) {
     1:         JS_ReportError(cx, "Can't prepare context for evalInSandbox");
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
 24474:     if (jsVersion != JSVERSION_DEFAULT)
 24474:         JS_SetVersion(sandcx->GetJSContext(), jsVersion);
 24474: 
102554:     XPCJSContextStack *stack = XPCJSRuntime::Get()->GetJSContextStack();
102554:     MOZ_ASSERT(stack);
 86979:     if (!stack->Push(sandcx->GetJSContext())) {
102554:         JS_ReportError(cx, "Unable to initialize XPConnect with the sandbox context");
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
103008:     nsresult rv = NS_OK;
     1: 
 20176:     {
 40289:         JSAutoRequest req(sandcx->GetJSContext());
 55590:         JSAutoEnterCompartment ac;
 40558: 
 55590:         if (!ac.enter(sandcx->GetJSContext(), sandbox)) {
 86979:             if (stack)
 86979:                 unused << stack->Pop();
 55657:             return NS_ERROR_FAILURE;
 55590:         }
 55590: 
 91900:         jsval v;
 91900:         JSString *str = nsnull;
 40558:         JSBool ok =
 40558:             JS_EvaluateUCScriptForPrincipals(sandcx->GetJSContext(), sandbox,
 91900:                                              nsJSPrincipals::get(prin),
  3233:                                              reinterpret_cast<const jschar *>
  3233:                                                              (PromiseFlatString(source).get()),
     1:                                              source.Length(), filename, lineNo,
 55590:                                              &v);
 55590:         if (ok && returnStringOnly && !(JSVAL_IS_VOID(v))) {
 55590:             ok = !!(str = JS_ValueToString(sandcx->GetJSContext(), v));
 40558:         }
 40558: 
 40558:         if (!ok) {
 40558:             // The sandbox threw an exception, convert it to a string (if
 40558:             // asked) or convert it to a SJOW.
 40558: 
     1:             jsval exn;
     1:             if (JS_GetPendingException(sandcx->GetJSContext(), &exn)) {
  3573:                 JS_ClearPendingException(sandcx->GetJSContext());
 55590: 
  3573:                 if (returnStringOnly) {
  3573:                     // The caller asked for strings only, convert the
  3573:                     // exception into a string.
  3573:                     str = JS_ValueToString(sandcx->GetJSContext(), exn);
  3573: 
  3573:                     if (str) {
  3573:                         // We converted the exception to a string. Use that
  3573:                         // as the value exception.
 55590:                         exn = STRING_TO_JSVAL(str);
 55590:                         if (JS_WrapValue(cx, &exn)) {
 61824:                             JS_SetPendingException(cx, exn);
  3573:                         } else {
  3573:                             JS_ClearPendingException(cx);
  3573:                             rv = NS_ERROR_FAILURE;
  3573:                         }
 47550:                     } else {
 55590:                         JS_ClearPendingException(cx);
 55590:                         rv = NS_ERROR_FAILURE;
 55590:                     }
 55590:                 } else {
 55590:                     if (JS_WrapValue(cx, &exn)) {
 47550:                         JS_SetPendingException(cx, exn);
 47550:                     }
 47550:                 }
 47550: 
  3573: 
  3573:                 // Clear str so we don't confuse callers.
  3573:                 str = nsnull;
     1:             } else {
     1:                 rv = NS_ERROR_OUT_OF_MEMORY;
     1:             }
 40558:         } else {
 40558:             // Convert the result into something safe for our caller.
 55590:             JSAutoRequest req(cx);
 55657:             JSAutoEnterCompartment ac;
  3573:             if (str) {
 55590:                 v = STRING_TO_JSVAL(str);
 55590:             }
 55590: 
 99328:             CompartmentPrivate *sandboxdata = GetCompartmentPrivate(sandbox);
 56473:             if (!ac.enter(cx, callingScope) ||
 56473:                 !WrapForSandbox(cx, sandboxdata->wantXrays, &v)) {
 40558:                 rv = NS_ERROR_FAILURE;
 40558:             }
 55590: 
 55590:             if (NS_SUCCEEDED(rv)) {
 55590:                 *rval = v;
 40558:             }
  3573:         }
 20176:     }
  3573: 
 86979:     if (stack)
 86979:         unused << stack->Pop();
     1: 
     1:     return rv;
     1: }
     1: 
  1725: /* JSObject import (in AUTF8String registryLocation,
  1493:  *                  [optional] in JSObject targetObj);
  1493:  */
  1493: NS_IMETHODIMP
 84864: nsXPCComponents_Utils::Import(const nsACString& registryLocation,
 84864:                               const JS::Value& targetObj,
 84864:                               JSContext* cx,
 84864:                               PRUint8 optionalArgc,
 84864:                               JS::Value* retval)
  1493: {
  1493:     nsCOMPtr<xpcIJSModuleLoader> moduleloader =
  1493:         do_GetService(MOZJSCOMPONENTLOADER_CONTRACTID);
  1493:     if (!moduleloader)
  1493:         return NS_ERROR_FAILURE;
 84864:     return moduleloader->Import(registryLocation, targetObj, cx, optionalArgc, retval);
  1493: }
  1493: 
 71853: /* unload (in AUTF8String registryLocation);
 71853:  */
 71853: NS_IMETHODIMP
 71853: nsXPCComponents_Utils::Unload(const nsACString & registryLocation)
 71853: {
 71853:     nsCOMPtr<xpcIJSModuleLoader> moduleloader =
 71853:         do_GetService(MOZJSCOMPONENTLOADER_CONTRACTID);
 71853:     if (!moduleloader)
 71853:         return NS_ERROR_FAILURE;
 71853:     return moduleloader->Unload(registryLocation);
 71853: }
 71853: 
  3213: /* xpcIJSWeakReference getWeakReference (); */
  3213: NS_IMETHODIMP
 84870: nsXPCComponents_Utils::GetWeakReference(const JS::Value &object, JSContext *cx,
 84870:                                         xpcIJSWeakReference **_retval)
  3213: {
 84870:     nsRefPtr<xpcJSWeakReference> ref = new xpcJSWeakReference();
 84870:     nsresult rv = ref->Init(cx, object);
 84870:     NS_ENSURE_SUCCESS(rv, rv);
 84870:     ref.forget(_retval);
  3213:     return NS_OK;
  3213: }
  3213: 
  3213: /* void forceGC (); */
  3213: NS_IMETHODIMP
 94960: nsXPCComponents_Utils::ForceGC()
 94960: {
 94960:     JSRuntime* rt = nsXPConnect::GetRuntimeInstance()->GetJSRuntime();
 94960:     js::PrepareForFullGC(rt);
 94960:     js::GCForReason(rt, js::gcreason::COMPONENT_UTILS);
  3213:     return NS_OK;
  3213: }
     1: 
 87775: /* void forceShrinkingGC (); */
 87775: NS_IMETHODIMP
 94960: nsXPCComponents_Utils::ForceShrinkingGC()
 94960: {
 94960:     JSRuntime* rt = nsXPConnect::GetRuntimeInstance()->GetJSRuntime();
 94960:     js::PrepareForFullGC(rt);
 94960:     js::ShrinkingGC(rt, js::gcreason::COMPONENT_UTILS);
 87775:     return NS_OK;
 87775: }
 87775: 
 72859: class PreciseGCRunnable : public nsRunnable
 72859: {
 72859:   public:
 94960:     PreciseGCRunnable(ScheduledGCCallback* aCallback, bool aShrinking)
 94960:     : mCallback(aCallback), mShrinking(aShrinking) {}
 72859: 
 72859:     NS_IMETHOD Run()
 72859:     {
 94960:         JSRuntime* rt = nsXPConnect::GetRuntimeInstance()->GetJSRuntime();
 72859: 
 72859:         JSContext *cx;
 72859:         JSContext *iter = nsnull;
 72859:         while ((cx = JS_ContextIterator(rt, &iter)) != NULL) {
 72859:             if (JS_IsRunning(cx)) {
 72859:                 return NS_DispatchToMainThread(this);
 72859:             }
 72859:         }
 72859: 
 94960:         js::PrepareForFullGC(rt);
 87775:         if (mShrinking)
 94960:             js::ShrinkingGC(rt, js::gcreason::COMPONENT_UTILS);
 87775:         else
 94960:             js::GCForReason(rt, js::gcreason::COMPONENT_UTILS);
 72859: 
 72859:         mCallback->Callback();
 72859:         return NS_OK;
 72859:     }
 72859: 
 72859:   private:
 72859:     nsRefPtr<ScheduledGCCallback> mCallback;
 87775:     bool mShrinking;
 72859: };
 72859: 
 94960: /* void schedulePreciseGC(in ScheduledGCCallback callback); */
 72859: NS_IMETHODIMP
 94960: nsXPCComponents_Utils::SchedulePreciseGC(ScheduledGCCallback* aCallback)
 94960: {
 94960:     nsRefPtr<PreciseGCRunnable> event = new PreciseGCRunnable(aCallback, false);
 87775:     return NS_DispatchToMainThread(event);
 87775: }
 87775: 
 94960: /* void schedulePreciseShrinkingGC(in ScheduledGCCallback callback); */
 87775: NS_IMETHODIMP
 94960: nsXPCComponents_Utils::SchedulePreciseShrinkingGC(ScheduledGCCallback* aCallback)
 94960: {
 94960:     nsRefPtr<PreciseGCRunnable> event = new PreciseGCRunnable(aCallback, true);
 72859:     return NS_DispatchToMainThread(event);
 72859: }
 72859: 
 80352: /* [implicit_jscontext] jsval nondeterministicGetWeakMapKeys(in jsval aMap); */
 80352: NS_IMETHODIMP
 98362: nsXPCComponents_Utils::NondeterministicGetWeakMapKeys(const JS::Value &aMap,
 80352:                                                       JSContext *aCx,
 98362:                                                       JS::Value *aKeys)
 98362: {
 98362:     if (!aMap.isObject()) {
 98362:         aKeys->setUndefined();
 80352:         return NS_OK;
 80352:     }
 80352:     JSObject *objRet;
 98362:     if (!JS_NondeterministicGetWeakMapKeys(aCx, &aMap.toObject(), &objRet))
 80352:         return NS_ERROR_OUT_OF_MEMORY;
 98362:     *aKeys = objRet ? ObjectValue(*objRet) : UndefinedValue();
 80352:     return NS_OK;
 80352: }
 80352: 
 91659: /* void getDebugObject(); */
 91659: NS_IMETHODIMP
 91659: nsXPCComponents_Utils::GetJSTestingFunctions(JSContext *cx,
 91659:                                              JS::Value *retval)
 91659: {
 91659:     JSObject *obj = js::GetTestingFunctions(cx);
 91659:     if (!obj)
 91659:         return NS_ERROR_XPC_JAVASCRIPT_ERROR;
 91659:     *retval = OBJECT_TO_JSVAL(obj);
 91659:     return NS_OK;
 91659: }
 91659: 
 41835: /* void getGlobalForObject(); */
 41835: NS_IMETHODIMP
 83348: nsXPCComponents_Utils::GetGlobalForObject(const JS::Value& object,
 83348:                                           JSContext *cx,
 83348:                                           JS::Value *retval)
 83348: {
 83348:   // First argument must be an object.
 83348:   if (JSVAL_IS_PRIMITIVE(object))
 41835:     return NS_ERROR_XPC_BAD_CONVERT_JS;
 41835: 
 93303:   // Wrappers are parented to their the global in their home compartment. But
 93303:   // when getting the global for a cross-compartment wrapper, we really want
 93303:   // a wrapper for the foreign global. So we need to unwrap before getting the
 93303:   // parent, enter the compartment for the duration of the call, and wrap the
 93303:   // result.
102586:   JS::Rooted<JSObject*> obj(cx, JSVAL_TO_OBJECT(object));
 93303:   obj = js::UnwrapObject(obj);
 93303:   {
 93303:     JSAutoEnterCompartment ac;
 93303:     if (!ac.enter(cx, obj))
 93303:       return NS_ERROR_FAILURE;
 93303:     obj = JS_GetGlobalForObject(cx, obj);
 93303:   }
102586:   JS_WrapObject(cx, obj.address());
 83348:   *retval = OBJECT_TO_JSVAL(obj);
 41835: 
 48622:   // Outerize if necessary.
 79734:   if (JSObjectOp outerize = js::GetObjectClass(obj)->ext.outerObject)
102586:       *retval = OBJECT_TO_JSVAL(outerize(cx, obj));
 83348: 
 41835:   return NS_OK;
 41835: }
 41835: 
 73054: /* jsval createObjectIn(in jsval vobj); */
 73054: NS_IMETHODIMP
 73054: nsXPCComponents_Utils::CreateObjectIn(const jsval &vobj, JSContext *cx, jsval *rval)
 73054: {
 73054:     if (!cx)
 73054:         return NS_ERROR_FAILURE;
 73054: 
 73054:     // first argument must be an object
 73054:     if (JSVAL_IS_PRIMITIVE(vobj))
 73054:         return NS_ERROR_XPC_BAD_CONVERT_JS;
 73054: 
 79734:     JSObject *scope = js::UnwrapObject(JSVAL_TO_OBJECT(vobj));
 73054:     JSObject *obj;
 73054:     {
 73054:         JSAutoEnterCompartment ac;
 73054:         if (!ac.enter(cx, scope))
 73054:             return NS_ERROR_FAILURE;
 73054: 
 73054:         obj = JS_NewObject(cx, nsnull, nsnull, scope);
 73054:         if (!obj)
 73054:             return NS_ERROR_FAILURE;
 73054:     }
 73054: 
 73054:     if (!JS_WrapObject(cx, &obj))
 73054:         return NS_ERROR_FAILURE;
 73054:     *rval = OBJECT_TO_JSVAL(obj);
 73054:     return NS_OK;
 73054: }
 73054: 
102368: /* jsval createObjectIn(in jsval vobj); */
102368: NS_IMETHODIMP
102368: nsXPCComponents_Utils::CreateArrayIn(const jsval &vobj, JSContext *cx, jsval *rval)
102368: {
102368:     if (!cx)
102368:         return NS_ERROR_FAILURE;
102368: 
102368:     // first argument must be an object
102368:     if (JSVAL_IS_PRIMITIVE(vobj))
102368:         return NS_ERROR_XPC_BAD_CONVERT_JS;
102368: 
102368:     JSObject *scope = js::UnwrapObject(JSVAL_TO_OBJECT(vobj));
102368:     JSObject *obj;
102368:     {
102368:         JSAutoEnterCompartment ac;
102368:         if (!ac.enter(cx, scope))
102368:             return NS_ERROR_FAILURE;
102368: 
102368:         obj =  JS_NewArrayObject(cx, 0, NULL);
102368:         if (!obj)
102368:             return NS_ERROR_FAILURE;
102368:     }
102368: 
102368:     if (!JS_WrapObject(cx, &obj))
102368:         return NS_ERROR_FAILURE;
102368:     *rval = OBJECT_TO_JSVAL(obj);
102368:     return NS_OK;
102368: }
102368: 
 73054: JSBool
 91237: FunctionWrapper(JSContext *cx, unsigned argc, jsval *vp)
 73054: {
 98362:     JSObject *callee = &JS_CALLEE(cx, vp).toObject();
 98362:     JS::Value v = js::GetFunctionNativeReserved(callee, 0);
 98362:     NS_ASSERTION(v.isObject(), "weird function");
 73054: 
 83114:     JSObject *obj = JS_THIS_OBJECT(cx, vp);
 83114:     if (!obj) {
 83114:         return JS_FALSE;
 83114:     }
 83114:     return JS_CallFunctionValue(cx, obj, v, argc, JS_ARGV(cx, vp), vp);
 73054: }
 73054: 
 73054: JSBool
 73054: WrapCallable(JSContext *cx, JSObject *obj, jsid id, JSObject *propobj, jsval *vp)
 73054: {
 83262:     JSFunction *fun = js::NewFunctionByIdWithReserved(cx, FunctionWrapper, 0, 0,
 73054:                                                       JS_GetGlobalForObject(cx, obj), id);
 73054:     if (!fun)
 82794:         return false;
 73054: 
 73054:     JSObject *funobj = JS_GetFunctionObject(fun);
 83258:     js::SetFunctionNativeReserved(funobj, 0, OBJECT_TO_JSVAL(propobj));
 73054:     *vp = OBJECT_TO_JSVAL(funobj);
 82794:     return true;
 73054: }
 73054: 
 73054: /* void makeObjectPropsNormal(jsval vobj); */
 73054: NS_IMETHODIMP
 73054: nsXPCComponents_Utils::MakeObjectPropsNormal(const jsval &vobj, JSContext *cx)
 73054: {
 73054:     if (!cx)
 73054:         return NS_ERROR_FAILURE;
 73054: 
 73054:     // first argument must be an object
 73054:     if (JSVAL_IS_PRIMITIVE(vobj))
 73054:         return NS_ERROR_XPC_BAD_CONVERT_JS;
 73054: 
 79734:     JSObject *obj = js::UnwrapObject(JSVAL_TO_OBJECT(vobj));
 73054: 
 73054:     JSAutoEnterCompartment ac;
 73054:     if (!ac.enter(cx, obj))
 73054:         return NS_ERROR_FAILURE;
 73054: 
 86994:     JS::AutoIdArray ida(cx, JS_Enumerate(cx, obj));
 73054:     if (!ida)
 73054:         return NS_ERROR_FAILURE;
 73054: 
 73054:     for (size_t i = 0; i < ida.length(); ++i) {
 73054:         jsid id = ida[i];
 73054:         jsval v;
 73054: 
 73054:         if (!JS_GetPropertyById(cx, obj, id, &v))
 73054:             return NS_ERROR_FAILURE;
 73054: 
 73054:         if (JSVAL_IS_PRIMITIVE(v))
 73054:             continue;
 73054: 
 73054:         JSObject *propobj = JSVAL_TO_OBJECT(v);
 73054:         // TODO Deal with non-functions.
 79734:         if (!js::IsWrapper(propobj) || !JS_ObjectIsCallable(cx, propobj))
 73054:             continue;
 73054: 
 73054:         if (!WrapCallable(cx, obj, id, propobj, &v) ||
 73054:             !JS_SetPropertyById(cx, obj, id, &v))
 73054:             return NS_ERROR_FAILURE;
 73054:     }
 73054: 
 73054:     return NS_OK;
 73054: }
 73054: 
105788: NS_IMETHODIMP
105788: nsXPCComponents_Utils::IsDeadWrapper(const jsval &obj, bool *out)
105788: {
105788:     *out = false;
105788:     if (JSVAL_IS_PRIMITIVE(obj))
105788:         return NS_ERROR_INVALID_ARG;
105788: 
105788:     *out = JS_IsDeadWrapper(JSVAL_TO_OBJECT(obj));
105788:     return NS_OK;
105788: }
105788: 
106126: /* void recomputerWrappers(jsval vobj); */
106126: NS_IMETHODIMP
106126: nsXPCComponents_Utils::RecomputeWrappers(const jsval &vobj, JSContext *cx)
106126: {
106126:     // Determine the compartment of the given object, if any.
106126:     JSCompartment *c = vobj.isObject()
106126:                        ? js::GetObjectCompartment(js::UnwrapObject(&vobj.toObject()))
106126:                        : NULL;
106126: 
106126:     // If no compartment was given, recompute all.
106126:     if (!c)
106126:         return js::RecomputeWrappers(cx, js::AllCompartments(), js::AllCompartments());
106126: 
106126:     // Otherwise, recompute wrappers for the given compartment.
106126:     return js::RecomputeWrappers(cx, js::SingleCompartment(c), js::AllCompartments()) &&
106126:            js::RecomputeWrappers(cx, js::AllCompartments(), js::SingleCompartment(c));
106126: }
106126: 
     1: /* string canCreateWrapper (in nsIIDPtr iid); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Utils::CanCreateWrapper(const nsIID * iid, char **_retval)
     1: {
     1:     // We let anyone do this...
     1:     *_retval = xpc_CloneAllAccess();
     1:     return NS_OK;
     1: }
     1: 
     1: /* string canCallMethod (in nsIIDPtr iid, in wstring methodName); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Utils::CanCallMethod(const nsIID * iid, const PRUnichar *methodName, char **_retval)
     1: {
     1:     static const char* allowed[] = { "lookupMethod", "evalInSandbox", nsnull };
     1:     *_retval = xpc_CheckAccessList(methodName, allowed);
     1:     return NS_OK;
     1: }
     1: 
     1: /* string canGetProperty (in nsIIDPtr iid, in wstring propertyName); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Utils::CanGetProperty(const nsIID * iid, const PRUnichar *propertyName, char **_retval)
     1: {
     1:     *_retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* string canSetProperty (in nsIIDPtr iid, in wstring propertyName); */
     1: NS_IMETHODIMP
     1: nsXPCComponents_Utils::CanSetProperty(const nsIID * iid, const PRUnichar *propertyName, char **_retval)
     1: {
     1:     // If you have to ask, then the answer is NO
     1:     *_retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
 80969: nsresult
 86464: GetBoolOption(JSContext* cx, uint32_t aOption, bool* aValue)
 80969: {
 80969:     *aValue = !!(JS_GetOptions(cx) & aOption);
 80969:     return NS_OK;
 80969: }
 80969: 
 80969: nsresult
 86464: SetBoolOption(JSContext* cx, uint32_t aOption, bool aValue)
 80969: {
 86464:     uint32_t options = JS_GetOptions(cx);
 80969:     if (aValue) {
 80969:         options |= aOption;
 80969:     } else {
 80969:         options &= ~aOption;
 80969:     }
 80969:     JS_SetOptions(cx, options & JSALLOPTION_MASK);
 80969:     return NS_OK;
 80969: }
 80969: 
 80969: #define GENERATE_JSOPTION_GETTER_SETTER(_attr, _flag)                   \
 80969:     NS_IMETHODIMP                                                       \
 83362:     nsXPCComponents_Utils::Get## _attr(JSContext* cx, bool* aValue)     \
 80969:     {                                                                   \
 83362:         return GetBoolOption(cx, _flag, aValue);                        \
 80969:     }                                                                   \
 80969:     NS_IMETHODIMP                                                       \
 83362:     nsXPCComponents_Utils::Set## _attr(JSContext* cx, bool aValue)      \
 80969:     {                                                                   \
 83362:         return SetBoolOption(cx, _flag, aValue);                        \
 80969:     }
 80969: 
 80969: GENERATE_JSOPTION_GETTER_SETTER(Strict, JSOPTION_STRICT)
 80969: GENERATE_JSOPTION_GETTER_SETTER(Werror, JSOPTION_WERROR)
 80969: GENERATE_JSOPTION_GETTER_SETTER(Atline, JSOPTION_ATLINE)
 99820: GENERATE_JSOPTION_GETTER_SETTER(Xml, JSOPTION_MOAR_XML)
 80969: GENERATE_JSOPTION_GETTER_SETTER(Relimit, JSOPTION_RELIMIT)
 80969: GENERATE_JSOPTION_GETTER_SETTER(Methodjit, JSOPTION_METHODJIT)
 80969: GENERATE_JSOPTION_GETTER_SETTER(Methodjit_always, JSOPTION_METHODJIT_ALWAYS)
 97827: GENERATE_JSOPTION_GETTER_SETTER(Strict_mode, JSOPTION_STRICT_MODE)
 80969: 
 80969: #undef GENERATE_JSOPTION_GETTER_SETTER
 80969: 
 80969: NS_IMETHODIMP
 80969: nsXPCComponents_Utils::SetGCZeal(PRInt32 aValue, JSContext* cx)
 80969: {
 80969: #ifdef JS_GC_ZEAL
 94870:     JS_SetGCZeal(cx, PRUint8(aValue), JS_DEFAULT_ZEAL_FREQ);
 80969: #endif
 80969:     return NS_OK;
 80969: }
 80969: 
105546: NS_IMETHODIMP
105546: nsXPCComponents_Utils::NukeSandbox(const JS::Value &obj, JSContext *cx)
105546: {
105546:     NS_ENSURE_TRUE(obj.isObject(), NS_ERROR_INVALID_ARG);
105546:     JSObject *wrapper = &obj.toObject();
105546:     NS_ENSURE_TRUE(IsWrapper(wrapper), NS_ERROR_INVALID_ARG);
105546:     JSObject *sb = UnwrapObject(wrapper);
105546:     NS_ENSURE_TRUE(GetObjectJSClass(sb) == &SandboxClass, NS_ERROR_INVALID_ARG);
105546:     NukeCrossCompartmentWrappers(cx, AllCompartments(), 
105546:                                  SingleCompartment(GetObjectCompartment(sb)),
105548:                                  NukeWindowReferences);
105546:     return NS_OK;
105546: }
105546: 
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: /***************************************************************************/
     1: 
     1: // XXXjband We ought to cache the wrapper in the object's slots rather than
     1: // re-wrapping on demand
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsXPCComponents)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCComponents)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptable)
     1:   NS_INTERFACE_MAP_ENTRY(nsIClassInfo)
     1:   NS_INTERFACE_MAP_ENTRY(nsISecurityCheckedComponent)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPCComponents)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(nsXPCComponents)
     1: NS_IMPL_THREADSAFE_RELEASE(nsXPCComponents)
     1: 
     1: /* void getInterfaces (out PRUint32 count, [array, size_is (count), retval]
     1:                        out nsIIDPtr array); */
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetInterfaces(PRUint32 *aCount, nsIID * **aArray)
     1: {
 68602:     const PRUint32 count = 3;
     1:     *aCount = count;
     1:     nsIID **array;
  3233:     *aArray = array = static_cast<nsIID**>(nsMemory::Alloc(count * sizeof(nsIID*)));
     1:     if (!array)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     PRUint32 index = 0;
     1:     nsIID* clone;
     1: #define PUSH_IID(id)                                                          \
  3233:     clone = static_cast<nsIID *>(nsMemory::Clone(&NS_GET_IID( id ),           \
     1:                                                  sizeof(nsIID)));             \
     1:     if (!clone)                                                               \
     1:         goto oom;                                                             \
     1:     array[index++] = clone;
     1: 
     1:     PUSH_IID(nsIXPCComponents)
     1:     PUSH_IID(nsIXPCScriptable)
     1:     PUSH_IID(nsISecurityCheckedComponent)
     1: #undef PUSH_IID
     1: 
     1:     return NS_OK;
     1: oom:
     1:     while (index)
     1:         nsMemory::Free(array[--index]);
     1:     nsMemory::Free(array);
     1:     *aArray = nsnull;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* nsISupports getHelperForLanguage (in PRUint32 language); */
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetHelperForLanguage(PRUint32 language,
     1:                                       nsISupports **retval)
     1: {
 97170:     *retval = static_cast<nsIXPCComponents*>(this);
 97170:     NS_ADDREF(this);
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute string contractID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetContractID(char * *aContractID)
     1: {
     1:     *aContractID = nsnull;
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
     1: /* readonly attribute string classDescription; */
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetClassDescription(char * *aClassDescription)
     1: {
     1:     static const char classDescription[] = "XPCComponents";
     1:     *aClassDescription = (char*)nsMemory::Clone(classDescription, sizeof(classDescription));
     1:     return *aClassDescription ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
     1: }
     1: 
     1: /* readonly attribute nsCIDPtr classID; */
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetClassID(nsCID * *aClassID)
     1: {
     1:     *aClassID = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 implementationLanguage; */
     1: NS_IMETHODIMP
 80387: nsXPCComponents::GetImplementationLanguage(PRUint32 *aImplementationLanguage)
     1: {
     1:     *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRUint32 flags; */
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetFlags(PRUint32 *aFlags)
     1: {
     1:     *aFlags = nsIClassInfo::THREADSAFE;
     1:     return NS_OK;
     1: }
     1: 
     1: /* [notxpcom] readonly attribute nsCID classIDNoAlloc; */
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
     1: {
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: }
     1: 
 97169: nsXPCComponents::nsXPCComponents(XPCWrappedNativeScope* aScope)
 97169:     :   mScope(aScope),
 97169:         mInterfaces(nsnull),
     1:         mInterfacesByID(nsnull),
     1:         mClasses(nsnull),
     1:         mClassesByID(nsnull),
     1:         mResults(nsnull),
     1:         mID(nsnull),
     1:         mException(nsnull),
     1:         mConstructor(nsnull),
     1:         mUtils(nsnull)
     1: {
 97169:     MOZ_ASSERT(aScope, "aScope must not be null");
     1: }
     1: 
     1: nsXPCComponents::~nsXPCComponents()
     1: {
     1:     ClearMembers();
     1: }
     1: 
     1: void
     1: nsXPCComponents::ClearMembers()
     1: {
     1:     NS_IF_RELEASE(mInterfaces);
     1:     NS_IF_RELEASE(mInterfacesByID);
     1:     NS_IF_RELEASE(mClasses);
     1:     NS_IF_RELEASE(mClassesByID);
     1:     NS_IF_RELEASE(mResults);
     1:     NS_IF_RELEASE(mID);
     1:     NS_IF_RELEASE(mException);
     1:     NS_IF_RELEASE(mConstructor);
     1:     NS_IF_RELEASE(mUtils);
     1: }
     1: 
     1: /*******************************************/
 76740: #define XPC_IMPL_GET_OBJ_METHOD(_n)                                           \
 76740: NS_IMETHODIMP nsXPCComponents::Get##_n(nsIXPCComponents_##_n * *a##_n) {      \
     1:     NS_ENSURE_ARG_POINTER(a##_n);                                             \
     1:     if (!m##_n) {                                                             \
     1:         if (!(m##_n = new nsXPCComponents_##_n())) {                          \
     1:             *a##_n = nsnull;                                                  \
     1:             return NS_ERROR_OUT_OF_MEMORY;                                    \
     1:         }                                                                     \
     1:         NS_ADDREF(m##_n);                                                     \
     1:     }                                                                         \
     1:     NS_ADDREF(m##_n);                                                         \
     1:     *a##_n = m##_n;                                                           \
     1:     return NS_OK;                                                             \
     1: }
     1: 
 76740: XPC_IMPL_GET_OBJ_METHOD(Interfaces)
 76740: XPC_IMPL_GET_OBJ_METHOD(InterfacesByID)
 76740: XPC_IMPL_GET_OBJ_METHOD(Classes)
 76740: XPC_IMPL_GET_OBJ_METHOD(ClassesByID)
 76740: XPC_IMPL_GET_OBJ_METHOD(Results)
 76740: XPC_IMPL_GET_OBJ_METHOD(ID)
 76740: XPC_IMPL_GET_OBJ_METHOD(Exception)
 76740: XPC_IMPL_GET_OBJ_METHOD(Constructor)
 76740: XPC_IMPL_GET_OBJ_METHOD(Utils)
     1: 
     1: #undef XPC_IMPL_GET_OBJ_METHOD
     1: /*******************************************/
     1: 
     1: NS_IMETHODIMP
 79445: nsXPCComponents::IsSuccessCode(nsresult result, bool *out)
     1: {
     1:     *out = NS_SUCCEEDED(result);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetStack(nsIStackFrame * *aStack)
     1: {
     1:     nsresult rv;
     1:     nsXPConnect* xpc = nsXPConnect::GetXPConnect();
     1:     if (!xpc)
     1:         return NS_ERROR_FAILURE;
     1:     rv = xpc->GetCurrentJSStack(aStack);
     1:     return rv;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetManager(nsIComponentManager * *aManager)
     1: {
     1:     NS_ASSERTION(aManager, "bad param");
     1:     return NS_GetComponentManager(aManager);
     1: }
     1: 
     1: /**********************************************/
     1: 
     1: // The nsIXPCScriptable map declaration that will generate stubs for us...
     1: #define XPC_MAP_CLASSNAME           nsXPCComponents
     1: #define XPC_MAP_QUOTED_CLASSNAME   "nsXPCComponents"
     1: #define                             XPC_MAP_WANT_NEWRESOLVE
     1: #define                             XPC_MAP_WANT_GETPROPERTY
     1: #define                             XPC_MAP_WANT_SETPROPERTY
 97170: #define                             XPC_MAP_WANT_PRECREATE
     1: #define XPC_MAP_FLAGS               nsIXPCScriptable::ALLOW_PROP_MODS_DURING_RESOLVE
     1: #include "xpc_map_end.h" /* This will #undef the above */
     1: 
 79445: /* bool newResolve (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval id, in PRUint32 flags, out JSObjectPtr objp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents::NewResolve(nsIXPConnectWrappedNative *wrapper,
     1:                             JSContext * cx, JSObject * obj,
 48470:                             jsid id, PRUint32 flags,
 79445:                             JSObject * *objp, bool *_retval)
     1: {
 20312:     XPCJSRuntime* rt = nsXPConnect::GetRuntimeInstance();
     1:     if (!rt)
     1:         return NS_ERROR_FAILURE;
     1: 
 91237:     unsigned attrs = 0;
     1: 
 48470:     if (id == rt->GetStringID(XPCJSRuntime::IDX_LAST_RESULT))
     1:         attrs = JSPROP_READONLY;
 48470:     else if (id != rt->GetStringID(XPCJSRuntime::IDX_RETURN_CODE))
     1:         return NS_OK;
     1: 
     1:     *objp = obj;
 48470:     *_retval = JS_DefinePropertyById(cx, obj, id, JSVAL_VOID, nsnull, nsnull,
 26167:                                      JSPROP_ENUMERATE | JSPROP_PERMANENT |
 26167:                                      attrs);
     1:     return NS_OK;
     1: }
     1: 
 79445: /* bool getProperty (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsval id, in JSValPtr vp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents::GetProperty(nsIXPConnectWrappedNative *wrapper,
     1:                              JSContext * cx, JSObject * obj,
 79445:                              jsid id, jsval * vp, bool *_retval)
     1: {
 20312:     XPCContext* xpcc = XPCContext::GetXPCContext(cx);
     1:     if (!xpcc)
     1:         return NS_ERROR_FAILURE;
     1: 
 82794:     bool doResult = false;
     1:     nsresult res;
     1:     XPCJSRuntime* rt = xpcc->GetRuntime();
 80389:     if (id == rt->GetStringID(XPCJSRuntime::IDX_LAST_RESULT)) {
     1:         res = xpcc->GetLastResult();
 82794:         doResult = true;
 80390:     } else if (id == rt->GetStringID(XPCJSRuntime::IDX_RETURN_CODE)) {
     1:         res = xpcc->GetPendingResult();
 82794:         doResult = true;
     1:     }
     1: 
     1:     nsresult rv = NS_OK;
 80389:     if (doResult) {
 90955:         if (!JS_NewNumberValue(cx, (double) res, vp))
     1:             return NS_ERROR_OUT_OF_MEMORY;
     1:         rv = NS_SUCCESS_I_DID_SOMETHING;
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
 79445: /* bool setProperty (in nsIXPConnectWrappedNative wrapper, in JSContextPtr cx, in JSObjectPtr obj, in jsid id, in JSValPtr vp); */
     1: NS_IMETHODIMP
     1: nsXPCComponents::SetProperty(nsIXPConnectWrappedNative *wrapper,
 48470:                              JSContext * cx, JSObject * obj, jsid id,
 79445:                              jsval * vp, bool *_retval)
     1: {
 20312:     XPCContext* xpcc = XPCContext::GetXPCContext(cx);
     1:     if (!xpcc)
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     XPCJSRuntime* rt = xpcc->GetRuntime();
     1:     if (!rt)
     1:         return NS_ERROR_FAILURE;
     1: 
 80389:     if (id == rt->GetStringID(XPCJSRuntime::IDX_RETURN_CODE)) {
     1:         nsresult rv;
 84755:         if (JS_ValueToECMAUint32(cx, *vp, (uint32_t*)&rv)) {
     1:             xpcc->SetPendingResult(rv);
     1:             xpcc->SetLastResult(rv);
     1:             return NS_SUCCESS_I_DID_SOMETHING;
     1:         }
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     return NS_ERROR_XPC_CANT_MODIFY_PROP_ON_WN;
     1: }
     1: 
     1: // static
     1: JSBool
 97170: nsXPCComponents::AttachComponentsObject(XPCCallContext& ccx,
     1:                                         XPCWrappedNativeScope* aScope,
     1:                                         JSObject* aGlobal)
     1: {
     1:     if (!aGlobal)
 82794:         return false;
     1: 
 97170:     nsXPCComponents* components = aScope->GetComponents();
 97170:     if (!components) {
 97170:         components = new nsXPCComponents(aScope);
     1:         if (!components)
 82794:             return false;
 97170:         aScope->SetComponents(components);
 97170:     }
     1: 
     1:     nsCOMPtr<nsIXPCComponents> cholder(components);
     1: 
     1:     AutoMarkingNativeInterfacePtr iface(ccx);
     1:     iface = XPCNativeInterface::GetNewOrUsed(ccx, &NS_GET_IID(nsIXPCComponents));
     1: 
     1:     if (!iface)
 82794:         return false;
     1: 
     1:     nsCOMPtr<XPCWrappedNative> wrapper;
 51515:     xpcObjectHelper helper(cholder);
 91578:     XPCWrappedNative::GetNewOrUsed(ccx, helper, aScope, iface, getter_AddRefs(wrapper));
     1:     if (!wrapper)
 82794:         return false;
     1: 
 98432:     // The call to wrap() here is necessary even though the object is same-
 98432:     // compartment, because it applies our security wrapper.
 98432:     js::Value v = ObjectValue(*wrapper->GetFlatJSObject());
 98432:     if (!JS_WrapValue(ccx, &v))
 98432:         return false;
 98432: 
     1:     jsid id = ccx.GetRuntime()->GetStringID(XPCJSRuntime::IDX_COMPONENTS);
 98432:     return JS_DefinePropertyById(ccx, aGlobal, id, v, nsnull, nsnull,
 26167:                                  JSPROP_PERMANENT | JSPROP_READONLY);
     1: }
     1: 
     1: /* void lookupMethod (); */
 84863: NS_IMETHODIMP
 84863: nsXPCComponents::LookupMethod(const JS::Value& object,
 84863:                               const JS::Value& name,
 84863:                               JSContext *cx,
 84863:                               JS::Value *retval)
 84863: {
 84863:     NS_WARNING("Components.lookupMethod deprecated, use Components.utils.lookupMethod");
 84863: 
     1:     nsCOMPtr<nsIXPCComponents_Utils> utils;
 84863:     nsresult rv = GetUtils(getter_AddRefs(utils));
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
 84863:     return utils->LookupMethod(object, name, cx, retval);
     1: }
     1: 
     1: /* void reportError (); */
 84868: NS_IMETHODIMP nsXPCComponents::ReportError(const JS::Value &error, JSContext *cx)
     1: {
 84868:     NS_WARNING("Components.reportError deprecated, use Components.utils.reportError");
 84868: 
     1:     nsCOMPtr<nsIXPCComponents_Utils> utils;
 84868:     nsresult rv = GetUtils(getter_AddRefs(utils));
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
 84868:     return utils->ReportError(error, cx);
     1: }
     1: 
     1: /* string canCreateWrapper (in nsIIDPtr iid); */
     1: NS_IMETHODIMP
     1: nsXPCComponents::CanCreateWrapper(const nsIID * iid, char **_retval)
     1: {
     1:     // We let anyone do this...
     1:     *_retval = xpc_CloneAllAccess();
     1:     return NS_OK;
     1: }
     1: 
     1: /* string canCallMethod (in nsIIDPtr iid, in wstring methodName); */
     1: NS_IMETHODIMP
     1: nsXPCComponents::CanCallMethod(const nsIID * iid, const PRUnichar *methodName, char **_retval)
     1: {
     1:     static const char* allowed[] = { "isSuccessCode", "lookupMethod", nsnull };
     1:     *_retval = xpc_CheckAccessList(methodName, allowed);
     1:     return NS_OK;
     1: }
     1: 
     1: /* string canGetProperty (in nsIIDPtr iid, in wstring propertyName); */
     1: NS_IMETHODIMP
     1: nsXPCComponents::CanGetProperty(const nsIID * iid, const PRUnichar *propertyName, char **_retval)
     1: {
 75171:     static const char* allowed[] = { "interfaces", "interfacesByID", "results", nsnull};
 75171:     *_retval = xpc_CheckAccessList(propertyName, allowed);
     1:     return NS_OK;
     1: }
     1: 
     1: /* string canSetProperty (in nsIIDPtr iid, in wstring propertyName); */
     1: NS_IMETHODIMP
     1: nsXPCComponents::CanSetProperty(const nsIID * iid, const PRUnichar *propertyName, char **_retval)
     1: {
     1:     // If you have to ask, then the answer is NO
     1:     *_retval = nsnull;
     1:     return NS_OK;
     1: }
 97170: 
 97170: NS_IMETHODIMP
 97170: nsXPCComponents::PreCreate(nsISupports *nativeObj, JSContext *cx, JSObject *globalObj, JSObject **parentObj)
 97170: {
 97170:   // this should never happen
 97170:   if (!mScope) {
 97170:       NS_WARNING("mScope must not be null when nsXPCComponents::PreCreate is called");
 97170:       return NS_ERROR_FAILURE;
 97170:   }
 97170:   *parentObj = mScope->GetGlobalJSObject();
 97170:   return NS_OK;
 98432: }
