54814: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
54814:  * ***** BEGIN LICENSE BLOCK *****
54814:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54814:  *
54814:  * The contents of this file are subject to the Mozilla Public License Version
54814:  * 1.1 (the "License"); you may not use this file except in compliance with
54814:  * the License. You may obtain a copy of the License at
54814:  * http://www.mozilla.org/MPL/
54814:  *
54814:  * Software distributed under the License is distributed on an "AS IS" basis,
54814:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54814:  * for the specific language governing rights and limitations under the
54814:  * License.
54814:  *
54814:  * The Original Code is Mozilla Corporation code.
54814:  *
54814:  * The Initial Developer of the Original Code is Mozilla Foundation.
54814:  * Portions created by the Initial Developer are Copyright (C) 2009
54814:  * the Initial Developer. All Rights Reserved.
54814:  *
54814:  * Contributor(s):
54814:  *   Bas Schouten <bschouten@mozilla.com>
54814:  *
54814:  * Alternatively, the contents of this file may be used under the terms of
54814:  * either the GNU General Public License Version 2 or later (the "GPL"), or
54814:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54814:  * in which case the provisions of the GPL or the LGPL are applicable instead
54814:  * of those above. If you wish to allow use of your version of this file only
54814:  * under the terms of either the GPL or the LGPL, and not to allow others to
54814:  * use your version of this file under the terms of the MPL, indicate your
54814:  * decision by deleting the provisions above and replace them with the notice
54814:  * and other provisions required by the GPL or the LGPL. If you do not delete
54814:  * the provisions above, a recipient may use your version of this file under
54814:  * the terms of any one of the MPL, the GPL or the LGPL.
54814:  *
54814:  * ***** END LICENSE BLOCK ***** */
54814: 
54814: #include "ImageLayerD3D10.h"
54814: #include "gfxImageSurface.h"
59257: #include "gfxD2DSurface.h"
59256: #include "gfxWindowsSurface.h"
54814: #include "yuv_convert.h"
60419: #include "../d3d9/Nv3DVUtils.h"
54814: 
54814: namespace mozilla {
54814: namespace layers {
54814: 
59256: static already_AddRefed<ID3D10Texture2D>
59256: SurfaceToTexture(ID3D10Device *aDevice,
59256:                  gfxASurface *aSurface,
59256:                  const gfxIntSize &aSize)
59256: {
59256:   if (aSurface && aSurface->GetType() == gfxASurface::SurfaceTypeD2D) {
59256:     void *data = aSurface->GetData(&gKeyD3D10Texture);
59256:     if (data) {
59256:       nsRefPtr<ID3D10Texture2D> texture = static_cast<ID3D10Texture2D*>(data);
59256:       ID3D10Device *dev;
59256:       texture->GetDevice(&dev);
59256:       if (dev == aDevice) {
59256:         return texture.forget();
59256:       }
59256:     }
59256:   }
59256: 
59256:   nsRefPtr<gfxImageSurface> imageSurface = aSurface->GetAsImageSurface();
59256: 
59256:   if (!imageSurface) {
59256:     imageSurface = new gfxImageSurface(aSize,
59256:                                        gfxASurface::ImageFormatARGB32);
59256:     
59256:     nsRefPtr<gfxContext> context = new gfxContext(imageSurface);
59256:     context->SetSource(aSurface);
59256:     context->SetOperator(gfxContext::OPERATOR_SOURCE);
59256:     context->Paint();
59256:   }
59256: 
59256:   D3D10_SUBRESOURCE_DATA data;
59256:   
59256:   CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM,
59256:                              imageSurface->GetSize().width,
59256:                              imageSurface->GetSize().height,
59256:                              1, 1);
59256:   desc.Usage = D3D10_USAGE_IMMUTABLE;
59256:   
59256:   data.pSysMem = imageSurface->Data();
59256:   data.SysMemPitch = imageSurface->Stride();
59256: 
59256:   nsRefPtr<ID3D10Texture2D> texture;
60334:   HRESULT hr = aDevice->CreateTexture2D(&desc, &data, getter_AddRefs(texture));
60334: 
62211:   if (FAILED(hr)) {
60334:     LayerManagerD3D10::ReportFailure(NS_LITERAL_CSTRING("Failed to create texture for image surface"),
60334:                                      hr);
62211:   }
62211: 
59256:   return texture.forget();
59256: }
59256: 
59718: ImageContainerD3D10::ImageContainerD3D10(ID3D10Device1 *aDevice)
59718:   : ImageContainer(nsnull)
59718:   , mDevice(aDevice)
54814: {
54814: }
54814: 
54814: already_AddRefed<Image>
54814: ImageContainerD3D10::CreateImage(const Image::Format *aFormats,
54814:                                  PRUint32 aNumFormats)
54814: {
54814:   if (!aNumFormats) {
54814:     return nsnull;
54814:   }
54814:   nsRefPtr<Image> img;
54814:   if (aFormats[0] == Image::PLANAR_YCBCR) {
56466:     img = new PlanarYCbCrImageD3D10(mDevice);
54814:   } else if (aFormats[0] == Image::CAIRO_SURFACE) {
56466:     img = new CairoImageD3D10(mDevice);
54814:   }
54814:   return img.forget();
54814: }
54814: 
54814: void
54814: ImageContainerD3D10::SetCurrentImage(Image *aImage)
54814: {
69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
54814: 
54814:   mActiveImage = aImage;
63615:   CurrentImageChanged();
54814: }
54814: 
54814: already_AddRefed<Image>
54814: ImageContainerD3D10::GetCurrentImage()
54814: {
69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
54814: 
54814:   nsRefPtr<Image> retval = mActiveImage;
54814:   return retval.forget();
54814: }
54814: 
54814: already_AddRefed<gfxASurface>
54814: ImageContainerD3D10::GetCurrentAsSurface(gfxIntSize *aSize)
54814: {
69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
54814:   if (!mActiveImage) {
54814:     return nsnull;
54814:   }
54814: 
54814:   if (mActiveImage->GetFormat() == Image::PLANAR_YCBCR) {
54814:     PlanarYCbCrImageD3D10 *yuvImage =
54814:       static_cast<PlanarYCbCrImageD3D10*>(mActiveImage.get());
54814:     if (yuvImage->HasData()) {
54814:       *aSize = yuvImage->mSize;
54814:     }
54814:   } else if (mActiveImage->GetFormat() == Image::CAIRO_SURFACE) {
54814:     CairoImageD3D10 *cairoImage =
54814:       static_cast<CairoImageD3D10*>(mActiveImage.get());
54814:     *aSize = cairoImage->mSize;
54814:   }
54814: 
54814:   return static_cast<ImageD3D10*>(mActiveImage->GetImplData())->GetAsSurface();
54814: }
54814: 
54814: gfxIntSize
54814: ImageContainerD3D10::GetCurrentSize()
54814: {
69142:   ReentrantMonitorAutoEnter mon(mReentrantMonitor);
54814:   if (!mActiveImage) {
54814:     return gfxIntSize(0,0);
54814:   }
54814:   if (mActiveImage->GetFormat() == Image::PLANAR_YCBCR) {
54814:     PlanarYCbCrImageD3D10 *yuvImage =
54814:       static_cast<PlanarYCbCrImageD3D10*>(mActiveImage.get());
54814:     if (!yuvImage->HasData()) {
54814:       return gfxIntSize(0,0);
54814:     }
54814:     return yuvImage->mSize;
54814: 
54814:   } else if (mActiveImage->GetFormat() == Image::CAIRO_SURFACE) {
54814:     CairoImageD3D10 *cairoImage =
54814:       static_cast<CairoImageD3D10*>(mActiveImage.get());
54814:     return cairoImage->mSize;
54814:   }
54814: 
54814:   return gfxIntSize(0,0);
54814: }
54814: 
79445: bool
54814: ImageContainerD3D10::SetLayerManager(LayerManager *aManager)
54814: {
59258:   if (aManager->GetBackendType() == LayerManager::LAYERS_D3D10) {
80486:     return true;
59258:   }
80486:   return false;
54814: }
54814: 
54814: Layer*
54814: ImageLayerD3D10::GetLayer()
54814: {
54814:   return this;
54814: }
54814: 
54814: void
57097: ImageLayerD3D10::RenderLayer()
54814: {
54814:   if (!GetContainer()) {
54814:     return;
54814:   }
54814: 
54814:   nsRefPtr<Image> image = GetContainer()->GetCurrentImage();
60860:   if (!image) {
60860:     return;
60860:   }
54814: 
57097:   SetEffectTransformAndOpacity();
54814: 
54814:   ID3D10EffectTechnique *technique;
54814: 
59718:   if (GetContainer()->GetBackendType() != LayerManager::LAYERS_D3D10 ||
59258:       image->GetFormat() == Image::CAIRO_SURFACE)
59258:   {
59258:     gfxIntSize size;
59258:     bool hasAlpha;
59258:     nsRefPtr<ID3D10ShaderResourceView> srView;
59258: 
59718:     if (GetContainer()->GetBackendType() != LayerManager::LAYERS_D3D10)
59715:     {
59258:       nsRefPtr<gfxASurface> surf = GetContainer()->GetCurrentAsSurface(&size);
59258:       
59258:       nsRefPtr<ID3D10Texture2D> texture = SurfaceToTexture(device(), surf, size);
59258: 
60334:       if (!texture) {
60334:         NS_WARNING("Failed to create texture for surface.");
60334:         return;
60334:       }
60334:       
59258:       hasAlpha = surf->GetContentType() == gfxASurface::CONTENT_COLOR_ALPHA;
59258:       
59258:       device()->CreateShaderResourceView(texture, NULL, getter_AddRefs(srView));
59258:     } else {
59718:       ImageContainerD3D10 *container =
59718:         static_cast<ImageContainerD3D10*>(GetContainer());
60335: 
59718:       if (container->device() != device()) {
59718:         container->SetDevice(device());
59718:       }
59718: 
59258:       // image->GetFormat() == Image::CAIRO_SURFACE
59258:       CairoImageD3D10 *cairoImage =
59258:         static_cast<CairoImageD3D10*>(image.get());
60335:       
60335:       if (cairoImage->mDevice != device()) {
60335:         // This shader resource view was for an old device! Can't draw that
60335:         // now.
60335:         return;
60335:       }
60335: 
59258:       srView = cairoImage->mSRView;
59258:       hasAlpha = cairoImage->mHasAlpha;
59258:       size = cairoImage->mSize;
59258:     }
59258: 
59258:     if (hasAlpha) {
59258:       if (mFilter == gfxPattern::FILTER_NEAREST) {
59258:         technique = effect()->GetTechniqueByName("RenderRGBALayerPremulPoint");
59258:       } else {
59258:         technique = effect()->GetTechniqueByName("RenderRGBALayerPremul");
59258:       }
59258:     } else {
59258:       if (mFilter == gfxPattern::FILTER_NEAREST) {
59258:         technique = effect()->GetTechniqueByName("RenderRGBLayerPremulPoint");
59258:       } else {
59258:         technique = effect()->GetTechniqueByName("RenderRGBLayerPremul");
59258:       }
59258:     }
59258: 
59258:     if (srView) {
59258:       effect()->GetVariableByName("tRGB")->AsShaderResource()->SetResource(srView);
59258:     }
59258: 
59258:     effect()->GetVariableByName("vLayerQuad")->AsVector()->SetFloatVector(
59258:       ShaderConstantRectD3D10(
59258:         (float)0,
59258:         (float)0,
59258:         (float)size.width,
59258:         (float)size.height)
59258:       );
59258:   } else if (image->GetFormat() == Image::PLANAR_YCBCR) {
54814:     PlanarYCbCrImageD3D10 *yuvImage =
54814:       static_cast<PlanarYCbCrImageD3D10*>(image.get());
54814: 
54814:     if (!yuvImage->HasData()) {
54814:       return;
54814:     }
54814: 
60335:     if (yuvImage->mDevice != device()) {
60335:         // These shader resources were created for an old device! Can't draw
60335:         // that here.
60335:         return;
60335:     }
60335: 
54814:     // TODO: At some point we should try to deal with mFilter here, you don't
54814:     // really want to use point filtering in the case of NEAREST, since that
54814:     // would also use point filtering for Chroma upsampling. Where most likely
54814:     // the user would only want point filtering for final RGB image upsampling.
54814: 
54814:     technique = effect()->GetTechniqueByName("RenderYCbCrLayer");
54814: 
54814:     effect()->GetVariableByName("tY")->AsShaderResource()->SetResource(yuvImage->mYView);
54814:     effect()->GetVariableByName("tCb")->AsShaderResource()->SetResource(yuvImage->mCbView);
54814:     effect()->GetVariableByName("tCr")->AsShaderResource()->SetResource(yuvImage->mCrView);
54814: 
60419:     /*
60419:      * Send 3d control data and metadata to NV3DVUtils
60419:      */
60419:     if (GetNv3DVUtils()) {
60419:       Nv_Stereo_Mode mode;
60419:       switch (yuvImage->mData.mStereoMode) {
60419:       case STEREO_MODE_LEFT_RIGHT:
60419:         mode = NV_STEREO_MODE_LEFT_RIGHT;
60419:         break;
60419:       case STEREO_MODE_RIGHT_LEFT:
60419:         mode = NV_STEREO_MODE_RIGHT_LEFT;
60419:         break;
60419:       case STEREO_MODE_BOTTOM_TOP:
60419:         mode = NV_STEREO_MODE_BOTTOM_TOP;
60419:         break;
60419:       case STEREO_MODE_TOP_BOTTOM:
60419:         mode = NV_STEREO_MODE_TOP_BOTTOM;
60419:         break;
60419:       case STEREO_MODE_MONO:
60419:         mode = NV_STEREO_MODE_MONO;
60419:         break;
60419:       }
60419:       
60419:       // Send control data even in mono case so driver knows to leave stereo mode.
60419:       GetNv3DVUtils()->SendNv3DVControl(mode, true, FIREFOX_3DV_APP_HANDLE);
60419: 
60419:       if (yuvImage->mData.mStereoMode != STEREO_MODE_MONO) {
60419:         // Dst resource is optional
60419:         GetNv3DVUtils()->SendNv3DVMetaData((unsigned int)yuvImage->mSize.width, 
60419:                                            (unsigned int)yuvImage->mSize.height, (HANDLE)(yuvImage->mYTexture), (HANDLE)(NULL));
60419:       }
60419:     }
60419: 
54814:     effect()->GetVariableByName("vLayerQuad")->AsVector()->SetFloatVector(
54814:       ShaderConstantRectD3D10(
54814:         (float)0,
54814:         (float)0,
54814:         (float)yuvImage->mSize.width,
54814:         (float)yuvImage->mSize.height)
54814:       );
73016: 
73016:     effect()->GetVariableByName("vTextureCoords")->AsVector()->SetFloatVector(
73016:       ShaderConstantRectD3D10(
73016:         (float)yuvImage->mData.mPicX / yuvImage->mData.mYSize.width,
73016:         (float)yuvImage->mData.mPicY / yuvImage->mData.mYSize.height,
73016:         (float)yuvImage->mData.mPicSize.width / yuvImage->mData.mYSize.width,
73016:         (float)yuvImage->mData.mPicSize.height / yuvImage->mData.mYSize.height)
73016:        );
54814:   }
54814: 
54814:   technique->GetPassByIndex(0)->Apply(0);
54814:   device()->Draw(4, 0);
63615: 
73016:   if (image->GetFormat() == Image::PLANAR_YCBCR) {
73016:     effect()->GetVariableByName("vTextureCoords")->AsVector()->
73016:       SetFloatVector(ShaderConstantRectD3D10(0, 0, 1.0f, 1.0f));
73016:   }
73016: 
63615:   GetContainer()->NotifyPaintedImage(image);
54814: }
54814: 
56466: PlanarYCbCrImageD3D10::PlanarYCbCrImageD3D10(ID3D10Device1 *aDevice)
54814:   : PlanarYCbCrImage(static_cast<ImageD3D10*>(this))
74548:   , mBufferSize(0)
56466:   , mDevice(aDevice)
80486:   , mHasData(false)
54814: {
54814: }
54814: 
54814: void
54814: PlanarYCbCrImageD3D10::SetData(const PlanarYCbCrImage::Data &aData)
54814: {
74548:   mBuffer = CopyData(mData, mSize, mBufferSize, aData);
54814: 
54814:   AllocateTextures();
54814: 
80486:   mHasData = true;
54814: }
54814: 
54814: void
54814: PlanarYCbCrImageD3D10::AllocateTextures()
54814: {
54814:   D3D10_SUBRESOURCE_DATA dataY;
54814:   D3D10_SUBRESOURCE_DATA dataCb;
54814:   D3D10_SUBRESOURCE_DATA dataCr;
54814:   CD3D10_TEXTURE2D_DESC descY(DXGI_FORMAT_R8_UNORM,
54814:                               mData.mYSize.width,
54814:                               mData.mYSize.height, 1, 1);
54814:   CD3D10_TEXTURE2D_DESC descCbCr(DXGI_FORMAT_R8_UNORM,
54814:                                  mData.mCbCrSize.width,
54814:                                  mData.mCbCrSize.height, 1, 1);
54814: 
54814:   descY.Usage = descCbCr.Usage = D3D10_USAGE_IMMUTABLE;
54814: 
54814:   dataY.pSysMem = mData.mYChannel;
54814:   dataY.SysMemPitch = mData.mYStride;
54814:   dataCb.pSysMem = mData.mCbChannel;
54814:   dataCb.SysMemPitch = mData.mCbCrStride;
54814:   dataCr.pSysMem = mData.mCrChannel;
54814:   dataCr.SysMemPitch = mData.mCbCrStride;
54814: 
81355:   HRESULT hr = mDevice->CreateTexture2D(&descY, &dataY, getter_AddRefs(mYTexture));
81355:   if (!FAILED(hr)) {
81355:       hr = mDevice->CreateTexture2D(&descCbCr, &dataCb, getter_AddRefs(mCbTexture));
81355:   }
81355:   if (!FAILED(hr)) {
81355:       hr = mDevice->CreateTexture2D(&descCbCr, &dataCr, getter_AddRefs(mCrTexture));
81355:   }
81355:   if (FAILED(hr)) {
81355:     LayerManagerD3D10::ReportFailure(NS_LITERAL_CSTRING("PlanarYCbCrImageD3D10::AllocateTextures(): Failed to create texture"),
81355:                                      hr);
81355:     return;
81355:   }
56117:   mDevice->CreateShaderResourceView(mYTexture, NULL, getter_AddRefs(mYView));
56117:   mDevice->CreateShaderResourceView(mCbTexture, NULL, getter_AddRefs(mCbView));
56117:   mDevice->CreateShaderResourceView(mCrTexture, NULL, getter_AddRefs(mCrView));
54814: }
54814: 
54814: already_AddRefed<gfxASurface>
54814: PlanarYCbCrImageD3D10::GetAsSurface()
54814: {
54814:   nsRefPtr<gfxImageSurface> imageSurface =
54814:     new gfxImageSurface(mSize, gfxASurface::ImageFormatRGB24);
54814:   
73016:   gfx::YUVType type = 
73016:     gfx::TypeFromSize(mData.mYSize.width,
73016:                       mData.mYSize.height,
73016:                       mData.mCbCrSize.width,
73016:                       mData.mCbCrSize.height);
73016: 
54814:   // Convert from YCbCr to RGB now
54814:   gfx::ConvertYCbCrToRGB32(mData.mYChannel,
54814:                            mData.mCbChannel,
54814:                            mData.mCrChannel,
54814:                            imageSurface->Data(),
73016:                            mData.mPicX,
73016:                            mData.mPicY,
73016:                            mData.mPicSize.width,
73016:                            mData.mPicSize.height,
54814:                            mData.mYStride,
54814:                            mData.mCbCrStride,
54814:                            imageSurface->Stride(),
73016:                            type);
54814: 
54814:   return imageSurface.forget().get();
54814: }
54814: 
54814: CairoImageD3D10::~CairoImageD3D10()
54814: {
54814: }
54814: 
54814: void
54814: CairoImageD3D10::SetData(const CairoImage::Data &aData)
54814: {
54814:   mSize = aData.mSize;
59256:   NS_ASSERTION(aData.mSurface->GetContentType() != gfxASurface::CONTENT_ALPHA,
59256:                "Invalid content type passed to CairoImageD3D10.");
54814: 
59256:   mTexture = SurfaceToTexture(mDevice, aData.mSurface, mSize);
54814: 
60334:   if (!mTexture) {
60334:     NS_WARNING("Failed to create texture for CairoImage.");
60334:     return;
60334:   }
60334: 
59256:   if (aData.mSurface->GetContentType() == gfxASurface::CONTENT_COLOR) {
59256:     mHasAlpha = false;
54814:   } else {
59256:     mHasAlpha = true;
54814:   }
54814: 
56466:   mDevice->CreateShaderResourceView(mTexture, NULL, getter_AddRefs(mSRView));
54814: }
54814: 
54814: already_AddRefed<gfxASurface>
54814: CairoImageD3D10::GetAsSurface()
54814: {
59791:   nsRefPtr<ID3D10Texture2D> surfTexture;
59791: 
59791:   // Make a copy of the texture since our current texture is not suitable for
59792:   // drawing with Direct2D because it is immutable and cannot be bound as a
59792:   // render target.
59791:   D3D10_TEXTURE2D_DESC texDesc;
59791:   mTexture->GetDesc(&texDesc);
59791:   texDesc.Usage = D3D10_USAGE_DEFAULT;
59791:   texDesc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
59791:   texDesc.MiscFlags = D3D10_RESOURCE_MISC_GDI_COMPATIBLE;
59791: 
81355:   HRESULT hr = mDevice->CreateTexture2D(&texDesc, NULL, getter_AddRefs(surfTexture));
81355:   if (FAILED(hr)) {
81355:     LayerManagerD3D10::ReportFailure(NS_LITERAL_CSTRING("CairoImageD3D10::GetAsSurface(): Failed to create texture"),
81355:                                      hr);
81355:     return nsnull;
81355:   }
59791: 
59791:   mDevice->CopyResource(surfTexture, mTexture);
59791: 
59257:   nsRefPtr<gfxASurface> surf =
59791:     new gfxD2DSurface(surfTexture, mHasAlpha ? gfxASurface::CONTENT_COLOR_ALPHA :
59257:                                                gfxASurface::CONTENT_COLOR);
59257:   return surf.forget();
54814: }
54814: 
54814: } /* layers */
54814: } /* mozilla */
