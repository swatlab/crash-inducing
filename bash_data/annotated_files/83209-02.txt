    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
24724: #include "nsTArray.h"
    1: #include "nsCellMap.h"
    1: #include "nsTableFrame.h"
    1: #include "nsTableCellFrame.h"
    1: #include "nsTableRowGroupFrame.h"
    1: 
82828: 
82828: static void
82828: SetDamageArea(PRInt32 aXOrigin,
82828:               PRInt32 aYOrigin,
82828:               PRInt32 aWidth,
82828:               PRInt32 aHeight,
82828:               nsRect& aDamageArea)
82828: {
82828:   NS_ASSERTION(aXOrigin >= 0, "negative col index");
82828:   NS_ASSERTION(aYOrigin >= 0, "negative row index");
82828:   NS_ASSERTION(aWidth >= 0, "negative horizontal damage");
82828:   NS_ASSERTION(aHeight >= 0, "negative vertical damage");
82828:   aDamageArea.x      = aXOrigin;
82828:   aDamageArea.y      = aYOrigin;
82828:   aDamageArea.width  = aWidth;
82828:   aDamageArea.height = aHeight;
82828: }
82828:  
    1: // Empty static array used for SafeElementAt() calls on mRows.
    1: static nsCellMap::CellDataArray * sEmptyRow;
    1: 
    1: // CellData
    1: 
    1: CellData::CellData(nsTableCellFrame* aOrigCell)
    1: {
    1:   MOZ_COUNT_CTOR(CellData);
    1:   mOrigCell = aOrigCell;
    1: }
    1: 
    1: CellData::~CellData()
    1: {
    1:   MOZ_COUNT_DTOR(CellData);
    1: }
    1: 
    1: BCCellData::BCCellData(nsTableCellFrame* aOrigCell)
    1: :CellData(aOrigCell)
    1: {
    1:   MOZ_COUNT_CTOR(BCCellData);
    1: }
    1: 
    1: BCCellData::~BCCellData()
    1: {
    1:   MOZ_COUNT_DTOR(BCCellData);
    1: }
    1: 
    1: // nsTableCellMap
    1: 
    1: nsTableCellMap::nsTableCellMap(nsTableFrame&   aTableFrame,
79445:                                bool            aBorderCollapse)
    1: :mTableFrame(aTableFrame), mFirstMap(nsnull), mBCInfo(nsnull)
    1: {
    1:   MOZ_COUNT_CTOR(nsTableCellMap);
    1: 
 2141:   nsTableFrame::RowGroupArray orderedRowGroups;
 2141:   aTableFrame.OrderRowGroups(orderedRowGroups);
    1: 
 2141:   nsTableRowGroupFrame* prior = nsnull;
 2141:   for (PRUint32 rgX = 0; rgX < orderedRowGroups.Length(); rgX++) {
 2141:     nsTableRowGroupFrame* rgFrame = orderedRowGroups[rgX];
37262:     InsertGroupCellMap(rgFrame, prior);
 2141:     prior = rgFrame;
    1:   }
    1:   if (aBorderCollapse) {
    1:     mBCInfo = new BCInfo();
    1:   }
    1: }
    1: 
    1: nsTableCellMap::~nsTableCellMap()
    1: {
    1:   MOZ_COUNT_DTOR(nsTableCellMap);
    1: 
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
    1:     nsCellMap* next = cellMap->GetNextSibling();
    1:     delete cellMap;
    1:     cellMap = next;
    1:   }
    1: 
    1:   if (mBCInfo) {
    1:     DeleteRightBottomBorders();
    1:     delete mBCInfo;
    1:   }
    1: }
    1: 
    1: // Get the bcData holding the border segments of the right edge of the table
    1: BCData*
    1: nsTableCellMap::GetRightMostBorder(PRInt32 aRowIndex)
    1: {
    1:   if (!mBCInfo) ABORT1(nsnull);
    1: 
24724:   PRInt32 numRows = mBCInfo->mRightBorders.Length();
    1:   if (aRowIndex < numRows) {
26081:     return &mBCInfo->mRightBorders.ElementAt(aRowIndex);
    1:   }
    1: 
26081:   if (!mBCInfo->mRightBorders.SetLength(aRowIndex+1))
26081:     ABORT1(nsnull);
26081:   return &mBCInfo->mRightBorders.ElementAt(aRowIndex);
    1: }
    1: 
    1: // Get the bcData holding the border segments of the bottom edge of the table
    1: BCData*
    1: nsTableCellMap::GetBottomMostBorder(PRInt32 aColIndex)
    1: {
    1:   if (!mBCInfo) ABORT1(nsnull);
    1: 
24724:   PRInt32 numCols = mBCInfo->mBottomBorders.Length();
    1:   if (aColIndex < numCols) {
26081:     return &mBCInfo->mBottomBorders.ElementAt(aColIndex);
    1:   }
    1: 
26081:   if (!mBCInfo->mBottomBorders.SetLength(aColIndex+1))
26081:     ABORT1(nsnull);
26081:   return &mBCInfo->mBottomBorders.ElementAt(aColIndex);
    1: }
    1: 
    1: // delete the borders corresponding to the right and bottom edges of the table
    1: void
    1: nsTableCellMap::DeleteRightBottomBorders()
    1: {
    1:   if (mBCInfo) {
24724:     mBCInfo->mBottomBorders.Clear();
24724:     mBCInfo->mRightBorders.Clear();
    1:   }
    1: }
    1: 
    1: void
    1: nsTableCellMap::InsertGroupCellMap(nsCellMap* aPrevMap,
    1:                                    nsCellMap& aNewMap)
    1: {
    1:   nsCellMap* next;
    1:   if (aPrevMap) {
    1:     next = aPrevMap->GetNextSibling();
    1:     aPrevMap->SetNextSibling(&aNewMap);
    1:   }
    1:   else {
    1:     next = mFirstMap;
    1:     mFirstMap = &aNewMap;
    1:   }
    1:   aNewMap.SetNextSibling(next);
    1: }
    1: 
37262: void nsTableCellMap::InsertGroupCellMap(nsTableRowGroupFrame*  aNewGroup,
    1:                                         nsTableRowGroupFrame*& aPrevGroup)
    1: {
    1:   nsCellMap* newMap = new nsCellMap(aNewGroup, mBCInfo != nsnull);
    1:   nsCellMap* prevMap = nsnull;
    1:   nsCellMap* lastMap = mFirstMap;
    1:   if (aPrevGroup) {
    1:     nsCellMap* map = mFirstMap;
    1:     while (map) {
    1:       lastMap = map;
    1:       if (map->GetRowGroup() == aPrevGroup) {
    1:         prevMap = map;
    1:         break;
    1:       }
    1:       map = map->GetNextSibling();
    1:     }
    1:   }
    1:   if (!prevMap) {
    1:     if (aPrevGroup) {
    1:       prevMap = lastMap;
    1:       aPrevGroup = (prevMap) ? prevMap->GetRowGroup() : nsnull;
    1:     }
    1:     else {
    1:       aPrevGroup = nsnull;
    1:     }
    1:   }
    1:   InsertGroupCellMap(prevMap, *newMap);
    1: }
    1: 
    1: void nsTableCellMap::RemoveGroupCellMap(nsTableRowGroupFrame* aGroup)
    1: {
    1:   nsCellMap* map = mFirstMap;
    1:   nsCellMap* prior = nsnull;
    1:   while (map) {
    1:     if (map->GetRowGroup() == aGroup) {
    1:       nsCellMap* next = map->GetNextSibling();
    1:       if (mFirstMap == map) {
    1:         mFirstMap = next;
    1:       }
    1:       else {
    1:         prior->SetNextSibling(next);
    1:       }
    1:       delete map;
    1:       break;
    1:     }
    1:     prior = map;
    1:     map = map->GetNextSibling();
    1:   }
    1: }
    1: 
    1: static nsCellMap*
    1: FindMapFor(const nsTableRowGroupFrame* aRowGroup,
    1:            nsCellMap* aStart,
    1:            const nsCellMap* aEnd)
    1: {
    1:   for (nsCellMap* map = aStart; map != aEnd; map = map->GetNextSibling()) {
    1:     if (aRowGroup == map->GetRowGroup()) {
    1:       return map;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsCellMap*
    1: nsTableCellMap::GetMapFor(const nsTableRowGroupFrame* aRowGroup,
    1:                           nsCellMap* aStartHint) const
    1: {
    1:   NS_PRECONDITION(aRowGroup, "Must have a rowgroup");
    1:   NS_ASSERTION(!aRowGroup->GetPrevInFlow(), "GetMapFor called with continuation");
    1:   if (aStartHint) {
    1:     nsCellMap* map = FindMapFor(aRowGroup, aStartHint, nsnull);
    1:     if (map) {
    1:       return map;
    1:     }
    1:   }
    1: 
    1:   nsCellMap* map = FindMapFor(aRowGroup, mFirstMap, aStartHint);
    1:   if (map) {
    1:     return map;
    1:   }
    1: 
    1:   // if aRowGroup is a repeated header or footer find the header or footer it was repeated from
    1:   if (aRowGroup->IsRepeatable()) {
 3233:     nsTableFrame* fifTable = static_cast<nsTableFrame*>(mTableFrame.GetFirstInFlow());
    1: 
    1:     const nsStyleDisplay* display = aRowGroup->GetStyleDisplay();
    1:     nsTableRowGroupFrame* rgOrig =
 2141:       (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == display->mDisplay) ?
 2141:       fifTable->GetTHead() : fifTable->GetTFoot();
    1:     // find the row group cell map using the original header/footer
    1:     if (rgOrig && rgOrig != aRowGroup) {
    1:       return GetMapFor(rgOrig, aStartHint);
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: void
    1: nsTableCellMap::Synchronize(nsTableFrame* aTableFrame)
    1: {
 2141:   nsTableFrame::RowGroupArray orderedRowGroups;
75183:   nsAutoTArray<nsCellMap*, 8> maps;
    1: 
 2141:   aTableFrame->OrderRowGroups(orderedRowGroups);
 2141:   if (!orderedRowGroups.Length()) {
    1:     return;
    1:   }
    1: 
 2141:   // XXXbz this fails if orderedRowGroups is missing some row groups
 2141:   // (due to OOM when appending to the array, e.g. -- we leak maps in
 2141:   // that case).
 2141: 
    1:   // Scope |map| outside the loop so we can use it as a hint.
    1:   nsCellMap* map = nsnull;
 2141:   for (PRUint32 rgX = 0; rgX < orderedRowGroups.Length(); rgX++) {
 2141:     nsTableRowGroupFrame* rgFrame = orderedRowGroups[rgX];
13441:     map = GetMapFor((nsTableRowGroupFrame*)rgFrame->GetFirstInFlow(), map);
    1:     if (map) {
    1:       if (!maps.AppendElement(map)) {
    1:         delete map;
33407:         map = nsnull;
    1:         NS_WARNING("Could not AppendElement");
33407:         break;
    1:       }
    1:     }
    1:   }
 2141: 
 2141:   PRInt32 mapIndex = maps.Length() - 1;  // Might end up -1
 2141:   nsCellMap* nextMap = maps.ElementAt(mapIndex);
    1:   nextMap->SetNextSibling(nsnull);
    1:   for (mapIndex-- ; mapIndex >= 0; mapIndex--) {
 2141:     nsCellMap* map = maps.ElementAt(mapIndex);
    1:     map->SetNextSibling(nextMap);
    1:     nextMap = map;
    1:   }
    1:   mFirstMap = nextMap;
    1: }
    1: 
79445: bool
    1: nsTableCellMap::HasMoreThanOneCell(PRInt32 aRowIndex) const
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
    1:   nsCellMap* map = mFirstMap;
    1:   while (map) {
    1:     if (map->GetRowCount() > rowIndex) {
    1:       return map->HasMoreThanOneCell(rowIndex);
    1:     }
    1:     rowIndex -= map->GetRowCount();
    1:     map = map->GetNextSibling();
    1:   }
80486:   return false;
    1: }
    1: 
    1: PRInt32
    1: nsTableCellMap::GetNumCellsOriginatingInRow(PRInt32 aRowIndex) const
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
    1:   nsCellMap* map = mFirstMap;
    1:   while (map) {
    1:     if (map->GetRowCount() > rowIndex) {
    1:       return map->GetNumCellsOriginatingInRow(rowIndex);
    1:     }
    1:     rowIndex -= map->GetRowCount();
    1:     map = map->GetNextSibling();
    1:   }
    1:   return 0;
    1: }
    1: PRInt32
    1: nsTableCellMap::GetEffectiveRowSpan(PRInt32 aRowIndex,
    1:                                     PRInt32 aColIndex) const
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
    1:   nsCellMap* map = mFirstMap;
    1:   while (map) {
    1:     if (map->GetRowCount() > rowIndex) {
80486:       return map->GetRowSpan(rowIndex, aColIndex, true);
    1:     }
    1:     rowIndex -= map->GetRowCount();
    1:     map = map->GetNextSibling();
    1:   }
    1:   NS_NOTREACHED("Bogus row index?");
    1:   return 0;
    1: }
    1: 
    1: PRInt32
    1: nsTableCellMap::GetEffectiveColSpan(PRInt32 aRowIndex,
    1:                                     PRInt32 aColIndex) const
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
    1:   nsCellMap* map = mFirstMap;
    1:   while (map) {
    1:     if (map->GetRowCount() > rowIndex) {
79445:       bool zeroColSpan;
    1:       return map->GetEffectiveColSpan(*this, rowIndex, aColIndex, zeroColSpan);
    1:     }
    1:     rowIndex -= map->GetRowCount();
    1:     map = map->GetNextSibling();
    1:   }
    1:   NS_NOTREACHED("Bogus row index?");
    1:   return 0;
    1: }
    1: 
    1: nsTableCellFrame*
    1: nsTableCellMap::GetCellFrame(PRInt32   aRowIndex,
    1:                              PRInt32   aColIndex,
    1:                              CellData& aData,
79445:                              bool      aUseRowIfOverlap) const
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
    1:   nsCellMap* map = mFirstMap;
    1:   while (map) {
    1:     if (map->GetRowCount() > rowIndex) {
    1:       return map->GetCellFrame(rowIndex, aColIndex, aData, aUseRowIfOverlap);
    1:     }
    1:     rowIndex -= map->GetRowCount();
    1:     map = map->GetNextSibling();
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: nsColInfo*
    1: nsTableCellMap::GetColInfoAt(PRInt32 aColIndex)
    1: {
24724:   PRInt32 numColsToAdd = aColIndex + 1 - mCols.Length();
    1:   if (numColsToAdd > 0) {
    1:     AddColsAtEnd(numColsToAdd);  // XXX this could fail to add cols in theory
    1:   }
26081:   return &mCols.ElementAt(aColIndex);
    1: }
    1: 
    1: PRInt32
    1: nsTableCellMap::GetRowCount() const
    1: {
    1:   PRInt32 numRows = 0;
    1:   nsCellMap* map = mFirstMap;
    1:   while (map) {
    1:     numRows += map->GetRowCount();
    1:     map = map->GetNextSibling();
    1:   }
    1:   return numRows;
    1: }
    1: 
    1: CellData*
    1: nsTableCellMap::GetDataAt(PRInt32 aRowIndex,
    1:                           PRInt32 aColIndex) const
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
    1:   nsCellMap* map = mFirstMap;
    1:   while (map) {
    1:     if (map->GetRowCount() > rowIndex) {
    1:       return map->GetDataAt(rowIndex, aColIndex);
    1:     }
    1:     rowIndex -= map->GetRowCount();
    1:     map = map->GetNextSibling();
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: void
    1: nsTableCellMap::AddColsAtEnd(PRUint32 aNumCols)
    1: {
26081:   if (!mCols.AppendElements(aNumCols)) {
    1:     NS_WARNING("Could not AppendElement");
    1:   }
    1:   if (mBCInfo) {
26081:     if (!mBCInfo->mBottomBorders.AppendElements(aNumCols)) {
    1:       NS_WARNING("Could not AppendElement");
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsTableCellMap::RemoveColsAtEnd()
    1: {
    1:   // Remove the cols at the end which don't have originating cells or cells spanning
    1:   // into them. Only do this if the col was created as eColAnonymousCell
    1:   PRInt32 numCols = GetColCount();
    1:   PRInt32 lastGoodColIndex = mTableFrame.GetIndexOfLastRealCol();
    1:   for (PRInt32 colX = numCols - 1; (colX >= 0) && (colX > lastGoodColIndex); colX--) {
26081:     nsColInfo& colInfo = mCols.ElementAt(colX);
26081:     if ((colInfo.mNumCellsOrig <= 0) && (colInfo.mNumCellsSpan <= 0))  {
    1:       mCols.RemoveElementAt(colX);
    1: 
    1:       if (mBCInfo) {
24724:         PRInt32 count = mBCInfo->mBottomBorders.Length();
    1:         if (colX < count) {
    1:           mBCInfo->mBottomBorders.RemoveElementAt(colX);
    1:         }
    1:       }
    1:     }
    1:     else break; // only remove until we encounter the 1st valid one
    1:   }
    1: }
    1: 
    1: void
    1: nsTableCellMap::ClearCols()
    1: {
26081:   mCols.Clear();
26081:   if (mBCInfo)
26081:     mBCInfo->mBottomBorders.Clear();
    1: }
    1: void
37262: nsTableCellMap::InsertRows(nsTableRowGroupFrame*       aParent,
24724:                            nsTArray<nsTableRowFrame*>& aRows,
    1:                            PRInt32                     aFirstRowIndex,
79445:                            bool                        aConsiderSpans,
    1:                            nsRect&                     aDamageArea)
    1: {
24724:   PRInt32 numNewRows = aRows.Length();
    1:   if ((numNewRows <= 0) || (aFirstRowIndex < 0)) ABORT0();
    1: 
    1:   PRInt32 rowIndex = aFirstRowIndex;
82828:   PRInt32 rgStartRowIndex = 0;
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
    1:     nsTableRowGroupFrame* rg = cellMap->GetRowGroup();
37262:     if (rg == aParent) {
82828:       cellMap->InsertRows(*this, aRows, rowIndex, aConsiderSpans,
82828:                           rgStartRowIndex, aDamageArea);
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:       Dump("after InsertRows");
    1: #endif
    1:       if (mBCInfo) {
24724:         PRInt32 count = mBCInfo->mRightBorders.Length();
    1:         if (aFirstRowIndex < count) {
    1:           for (PRInt32 rowX = aFirstRowIndex; rowX < aFirstRowIndex + numNewRows; rowX++) {
26081:             if (!mBCInfo->mRightBorders.InsertElementAt(rowX))
26081:               ABORT0();
    1:           }
    1:         }
    1:         else {
    1:           GetRightMostBorder(aFirstRowIndex); // this will create missing entries
    1:           for (PRInt32 rowX = aFirstRowIndex + 1; rowX < aFirstRowIndex + numNewRows; rowX++) {
26081:             if (!mBCInfo->mRightBorders.AppendElement())
26081:               ABORT0();
    1:           }
    1:         }
    1:       }
    1:       return;
    1:     }
82828:     PRInt32 rowCount = cellMap->GetRowCount();
82828:     rgStartRowIndex += rowCount;
82828:     rowIndex -= rowCount;
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1: 
    1:   NS_ERROR("Attempt to insert row into wrong map.");
    1: }
    1: 
    1: void
    1: nsTableCellMap::RemoveRows(PRInt32         aFirstRowIndex,
    1:                            PRInt32         aNumRowsToRemove,
79445:                            bool            aConsiderSpans,
    1:                            nsRect&         aDamageArea)
    1: {
    1:   PRInt32 rowIndex = aFirstRowIndex;
82828:   PRInt32 rgStartRowIndex = 0;
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
82828:     PRInt32 rowCount = cellMap->GetRowCount();
82828:     if (rowCount > rowIndex) {
82828:       cellMap->RemoveRows(*this, rowIndex, aNumRowsToRemove, aConsiderSpans,
82828:                           rgStartRowIndex, aDamageArea);
    1:       if (mBCInfo) {
    1:         for (PRInt32 rowX = aFirstRowIndex + aNumRowsToRemove - 1; rowX >= aFirstRowIndex; rowX--) {
24724:           if (PRUint32(rowX) < mBCInfo->mRightBorders.Length()) {
    1:             mBCInfo->mRightBorders.RemoveElementAt(rowX);
    1:           }
    1:         }
    1:       }
    1:       break;
    1:     }
82828:     rgStartRowIndex += rowCount;
82828:     rowIndex -= rowCount;
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   Dump("after RemoveRows");
    1: #endif
    1: }
    1: 
    1: 
    1: 
    1: CellData*
    1: nsTableCellMap::AppendCell(nsTableCellFrame& aCellFrame,
    1:                            PRInt32           aRowIndex,
79445:                            bool              aRebuildIfNecessary,
    1:                            nsRect&           aDamageArea)
    1: {
    1:   NS_ASSERTION(&aCellFrame == aCellFrame.GetFirstInFlow(), "invalid call on continuing frame");
    1:   nsIFrame* rgFrame = aCellFrame.GetParent(); // get the row
    1:   if (!rgFrame) return 0;
    1:   rgFrame = rgFrame->GetParent();   // get the row group
    1:   if (!rgFrame) return 0;
    1: 
    1:   CellData* result = nsnull;
    1:   PRInt32 rowIndex = aRowIndex;
82828:   PRInt32 rgStartRowIndex = 0;
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
    1:     if (cellMap->GetRowGroup() == rgFrame) {
82828:       result = cellMap->AppendCell(*this, &aCellFrame, rowIndex,
82828:                                    aRebuildIfNecessary, rgStartRowIndex,
82828:                                    aDamageArea);
    1:       break;
    1:     }
82828:     PRInt32 rowCount = cellMap->GetRowCount();
82828:     rgStartRowIndex += rowCount;
82828:     rowIndex -= rowCount;
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   Dump("after AppendCell");
    1: #endif
    1:   return result;
    1: }
    1: 
    1: 
    1: void
24724: nsTableCellMap::InsertCells(nsTArray<nsTableCellFrame*>& aCellFrames,
    1:                             PRInt32                      aRowIndex,
    1:                             PRInt32                      aColIndexBefore,
    1:                             nsRect&                      aDamageArea)
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
82828:   PRInt32 rgStartRowIndex = 0;
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
82828:     PRInt32 rowCount = cellMap->GetRowCount();
82828:     if (rowCount > rowIndex) {
82828:       cellMap->InsertCells(*this, aCellFrames, rowIndex, aColIndexBefore,
82828:                            rgStartRowIndex, aDamageArea);
    1:       break;
    1:     }
82828:     rgStartRowIndex += rowCount;
82828:     rowIndex -= rowCount;
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   Dump("after InsertCells");
    1: #endif
    1: }
    1: 
    1: 
    1: void
    1: nsTableCellMap::RemoveCell(nsTableCellFrame* aCellFrame,
    1:                            PRInt32           aRowIndex,
    1:                            nsRect&           aDamageArea)
    1: {
    1:   if (!aCellFrame) ABORT0();
    1:   NS_ASSERTION(aCellFrame == (nsTableCellFrame *)aCellFrame->GetFirstInFlow(),
    1:                "invalid call on continuing frame");
    1:   PRInt32 rowIndex = aRowIndex;
82828:   PRInt32 rgStartRowIndex = 0;
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
82828:     PRInt32 rowCount = cellMap->GetRowCount();
82828:     if (rowCount > rowIndex) {
82828:       cellMap->RemoveCell(*this, aCellFrame, rowIndex, rgStartRowIndex,
82828:                           aDamageArea);
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:       Dump("after RemoveCell");
    1: #endif
    1:       return;
    1:     }
82828:     rgStartRowIndex += rowCount;
82828:     rowIndex -= rowCount;
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1:   // if we reach this point - the cell did not get removed, the caller of this routine
    1:   // will delete the cell and the cellmap will probably hold a reference to
    1:   // the deleted cell which will cause a subsequent crash when this cell is
    1:   // referenced later
    1:   NS_ERROR("nsTableCellMap::RemoveCell - could not remove cell");
    1: }
    1: 
    1: void
    1: nsTableCellMap::RebuildConsideringCells(nsCellMap*                   aCellMap,
24724:                                         nsTArray<nsTableCellFrame*>* aCellFrames,
    1:                                         PRInt32                      aRowIndex,
    1:                                         PRInt32                      aColIndex,
79445:                                         bool                         aInsert,
    1:                                         nsRect&                      aDamageArea)
    1: {
    1:   PRInt32 numOrigCols = GetColCount();
    1:   ClearCols();
    1:   nsCellMap* cellMap = mFirstMap;
    1:   PRInt32 rowCount = 0;
    1:   while (cellMap) {
    1:     if (cellMap == aCellMap) {
82828:       cellMap->RebuildConsideringCells(*this, numOrigCols, aCellFrames,
82828:                                        aRowIndex, aColIndex, aInsert);
    1:     }
    1:     else {
82828:       cellMap->RebuildConsideringCells(*this, numOrigCols, nsnull, -1, 0,
82828:                                        false);
    1:     }
    1:     rowCount += cellMap->GetRowCount();
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1:   SetDamageArea(0, 0, GetColCount(), rowCount, aDamageArea);
    1: }
    1: 
    1: void
    1: nsTableCellMap::RebuildConsideringRows(nsCellMap*                  aCellMap,
    1:                                        PRInt32                     aStartRowIndex,
24724:                                        nsTArray<nsTableRowFrame*>* aRowsToInsert,
    1:                                        PRInt32                     aNumRowsToRemove,
    1:                                        nsRect&                     aDamageArea)
    1: {
    1:   NS_PRECONDITION(!aRowsToInsert || aNumRowsToRemove == 0,
    1:                   "Can't handle both removing and inserting rows at once");
    1: 
    1:   PRInt32 numOrigCols = GetColCount();
    1:   ClearCols();
    1:   nsCellMap* cellMap = mFirstMap;
    1:   PRInt32 rowCount = 0;
    1:   while (cellMap) {
    1:     if (cellMap == aCellMap) {
82828:       cellMap->RebuildConsideringRows(*this, aStartRowIndex, aRowsToInsert,
82828:                                       aNumRowsToRemove);
    1:     }
    1:     else {
82828:       cellMap->RebuildConsideringCells(*this, numOrigCols, nsnull, -1, 0,
82828:                                        false);
    1:     }
    1:     rowCount += cellMap->GetRowCount();
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1:   SetDamageArea(0, 0, GetColCount(), rowCount, aDamageArea);
    1: }
    1: 
    1: PRInt32
    1: nsTableCellMap::GetNumCellsOriginatingInCol(PRInt32 aColIndex) const
    1: {
24724:   PRInt32 colCount = mCols.Length();
    1:   if ((aColIndex >= 0) && (aColIndex < colCount)) {
26081:     return mCols.ElementAt(aColIndex).mNumCellsOrig;
    1:   }
    1:   else {
    1:     NS_ERROR("nsCellMap::GetNumCellsOriginatingInCol - bad col index");
    1:     return 0;
    1:   }
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: void
    1: nsTableCellMap::Dump(char* aString) const
    1: {
    1:   if (aString)
    1:     printf("%s \n", aString);
    1:   printf("***** START TABLE CELL MAP DUMP ***** %p\n", (void*)this);
    1:   // output col info
24724:   PRInt32 colCount = mCols.Length();
    1:   printf ("cols array orig/span-> %p", (void*)this);
    1:   for (PRInt32 colX = 0; colX < colCount; colX++) {
26081:     const nsColInfo& colInfo = mCols.ElementAt(colX);
26081:     printf ("%d=%d/%d ", colX, colInfo.mNumCellsOrig, colInfo.mNumCellsSpan);
    1:   }
24724:   printf(" cols in cache %d\n", mTableFrame.GetColCache().Length());
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
    1:     cellMap->Dump(nsnull != mBCInfo);
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1:   if (nsnull != mBCInfo) {
    1:     printf("***** bottom borders *****\n");
    1:     nscoord       size;
    1:     BCBorderOwner owner;
41419:     mozilla::css::Side side;
79445:     bool          segStart;
79445:     bool          bevel;
    1:     PRInt32       colIndex;
24724:     PRInt32 numCols = mBCInfo->mBottomBorders.Length();
    1:     for (PRInt32 i = 0; i <= 2; i++) {
    1: 
    1:       printf("\n          ");
    1:       for (colIndex = 0; colIndex < numCols; colIndex++) {
26081:         BCData& cd = mBCInfo->mBottomBorders.ElementAt(colIndex);
    1:         if (0 == i) {
26081:           size = cd.GetTopEdge(owner, segStart);
    1:           printf("t=%d%X%d ", size, owner, segStart);
    1:         }
    1:         else if (1 == i) {
26081:           size = cd.GetLeftEdge(owner, segStart);
    1:           printf("l=%d%X%d ", size, owner, segStart);
    1:         }
    1:         else {
26081:           size = cd.GetCorner(side, bevel);
    1:           printf("c=%d%X%d ", size, side, bevel);
    1:         }
    1:       }
26081:       BCData& cd = mBCInfo->mLowerRightCorner;
    1:       if (0 == i) {
26081:          size = cd.GetTopEdge(owner, segStart);
    1:          printf("t=%d%X%d ", size, owner, segStart);
    1:       }
    1:       else if (1 == i) {
26081:         size = cd.GetLeftEdge(owner, segStart);
    1:         printf("l=%d%X%d ", size, owner, segStart);
    1:       }
    1:       else {
26081:         size = cd.GetCorner(side, bevel);
    1:         printf("c=%d%X%d ", size, side, bevel);
    1:       }
    1:     }
    1:     printf("\n");
    1:   }
    1:   printf("***** END TABLE CELL MAP DUMP *****\n");
    1: }
    1: #endif
    1: 
    1: nsTableCellFrame*
    1: nsTableCellMap::GetCellInfoAt(PRInt32  aRowIndex,
    1:                               PRInt32  aColIndex,
79445:                               bool*  aOriginates,
    1:                               PRInt32* aColSpan) const
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
    1:     if (cellMap->GetRowCount() > rowIndex) {
    1:       return cellMap->GetCellInfoAt(*this, rowIndex, aColIndex, aOriginates, aColSpan);
    1:     }
    1:     rowIndex -= cellMap->GetRowCount();
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1:   return nsnull;
    1: }
    1: 
11311: PRInt32
11311: nsTableCellMap::GetIndexByRowAndColumn(PRInt32 aRow, PRInt32 aColumn) const
11311: {
11311:   PRInt32 index = 0;
11311: 
24724:   PRInt32 colCount = mCols.Length();
11311:   PRInt32 rowIndex = aRow;
11311: 
11311:   nsCellMap* cellMap = mFirstMap;
11311:   while (cellMap) {
11311:     PRInt32 rowCount = cellMap->GetRowCount();
12717:     if (rowIndex >= rowCount) {
11311:       // If the rowCount is less than the rowIndex, this means that the index is
11311:       // not within the current map. If so, get the index of the last cell in
11311:       // the last row.
29821:       rowIndex -= rowCount;
29821: 
29821:       PRInt32 cellMapIdx = cellMap->GetHighestIndex(colCount);
29821:       if (cellMapIdx != -1)
12717:         index += cellMapIdx + 1;
29821: 
11311:     } else {
11311:       // Index is in valid range for this cellmap, so get the index of rowIndex
11311:       // and aColumn.
11311:       PRInt32 cellMapIdx = cellMap->GetIndexByRowAndColumn(colCount, rowIndex,
11311:                                                            aColumn);
29821:       if (cellMapIdx == -1)
29821:         return -1; // no cell at the given row and column.
29821: 
11311:       index += cellMapIdx;
11311:       return index;  // no need to look through further maps here
11311:     }
11311: 
11311:     cellMap = cellMap->GetNextSibling();
11311:   }
11311: 
11311:   return -1;
11311: }
11311: 
11311: void
11311: nsTableCellMap::GetRowAndColumnByIndex(PRInt32 aIndex,
11311:                                        PRInt32 *aRow, PRInt32 *aColumn) const
11311: {
11311:   *aRow = -1;
11311:   *aColumn = -1;
11311: 
24724:   PRInt32 colCount = mCols.Length();
11311: 
11311:   PRInt32 previousRows = 0;
11311:   PRInt32 index = aIndex;
11311: 
11311:   nsCellMap* cellMap = mFirstMap;
11311:   while (cellMap) {
11311:     PRInt32 rowCount = cellMap->GetRowCount();
11311:     // Determine the highest possible index in this map to see
11311:     // if wanted index is in here.
29821:     PRInt32 cellMapIdx = cellMap->GetHighestIndex(colCount);
29821:     if (cellMapIdx == -1) {
29821:       // The index is not within this map, increase the total row index
29821:       // accordingly.
29821:       previousRows += rowCount;
29821:     } else {
11311:       if (index > cellMapIdx) {
11311:         // The index is not within this map, so decrease it by the cellMapIdx
11311:         // determined index and increase the total row index accordingly.
12717:         index -= cellMapIdx + 1;
11311:         previousRows += rowCount;
11311:       } else {
11311:         cellMap->GetRowAndColumnByIndex(colCount, index, aRow, aColumn);
11311:         // If there were previous indexes, take them into account.
11311:         *aRow += previousRows;
11311:         return; // no need to look any further.
11311:       }
11311:     }
11311: 
11311:     cellMap = cellMap->GetNextSibling();
11311:   }
11311: }
    1: 
79445: bool nsTableCellMap::RowIsSpannedInto(PRInt32 aRowIndex,
    1:                                         PRInt32 aNumEffCols) const
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
    1:     if (cellMap->GetRowCount() > rowIndex) {
    1:       return cellMap->RowIsSpannedInto(rowIndex, aNumEffCols);
    1:     }
    1:     rowIndex -= cellMap->GetRowCount();
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
80486:   return false;
    1: }
    1: 
79445: bool nsTableCellMap::RowHasSpanningCells(PRInt32 aRowIndex,
    1:                                            PRInt32 aNumEffCols) const
    1: {
    1:   PRInt32 rowIndex = aRowIndex;
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
    1:     if (cellMap->GetRowCount() > rowIndex) {
    1:       return cellMap->RowHasSpanningCells(rowIndex, aNumEffCols);
    1:     }
    1:     rowIndex -= cellMap->GetRowCount();
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
80486:   return false;
    1: }
    1: 
    1: void nsTableCellMap::ExpandZeroColSpans()
    1: {
80486:   mTableFrame.SetNeedColSpanExpansion(false); // mark the work done
80486:   mTableFrame.SetHasZeroColSpans(false); // reset the bit, if there is a
    1:                                             // zerospan it will be set again.
    1:   nsCellMap* cellMap = mFirstMap;
    1:   while (cellMap) {
    1:     cellMap->ExpandZeroColSpans(*this);
    1:     cellMap = cellMap->GetNextSibling();
    1:   }
    1: }
26081: 
26081: void
62666: nsTableCellMap::ResetTopStart(PRUint8    aSide,
    1:                               nsCellMap& aCellMap,
    1:                               PRUint32   aRowIndex,
    1:                               PRUint32   aColIndex,
79445:                               bool       aIsLowerRight)
    1: {
26081:   if (!mBCInfo || aIsLowerRight) ABORT0();
    1: 
    1:   BCCellData* cellData;
    1:   BCData* bcData = nsnull;
    1: 
    1:   switch(aSide) {
    1:   case NS_SIDE_BOTTOM:
    1:     aRowIndex++;
62666:     // FALLTHROUGH
    1:   case NS_SIDE_TOP:
    1:     cellData = (BCCellData*)aCellMap.GetDataAt(aRowIndex, aColIndex);
    1:     if (cellData) {
    1:       bcData = &cellData->mData;
    1:     }
    1:     else {
    1:       NS_ASSERTION(aSide == NS_SIDE_BOTTOM, "program error");
    1:       // try the next row group
    1:       nsCellMap* cellMap = aCellMap.GetNextSibling();
    1:       if (cellMap) {
    1:         cellData = (BCCellData*)cellMap->GetDataAt(0, aColIndex);
    1:         if (cellData) {
    1:           bcData = &cellData->mData;
    1:         }
    1:         else {
    1:           bcData = GetBottomMostBorder(aColIndex);
    1:         }
    1:       }
    1:     }
    1:     break;
    1:   case NS_SIDE_RIGHT:
    1:     aColIndex++;
62666:     // FALLTHROUGH
    1:   case NS_SIDE_LEFT:
    1:     cellData = (BCCellData*)aCellMap.GetDataAt(aRowIndex, aColIndex);
    1:     if (cellData) {
    1:       bcData = &cellData->mData;
    1:     }
    1:     else {
    1:       NS_ASSERTION(aSide == NS_SIDE_RIGHT, "program error");
    1:       bcData = GetRightMostBorder(aRowIndex);
    1:     }
    1:     break;
    1:   }
26081:   if (bcData) {
80486:     bcData->SetTopStart(false);
26081:   }
    1: }
    1: 
    1: // store the aSide border segment at coord = (aRowIndex, aColIndex). For top/left, store
    1: // the info at coord. For bottom/left store it at the adjacent location so that it is
    1: // top/left at that location. If the new location is at the right or bottom edge of the
    1: // table, then store it one of the special arrays (right most borders, bottom most borders).
    1: void
41419: nsTableCellMap::SetBCBorderEdge(mozilla::css::Side aSide,
    1:                                 nsCellMap&    aCellMap,
    1:                                 PRUint32      aCellMapStart,
    1:                                 PRUint32      aRowIndex,
    1:                                 PRUint32      aColIndex,
    1:                                 PRUint32      aLength,
    1:                                 BCBorderOwner aOwner,
    1:                                 nscoord       aSize,
79445:                                 bool          aChanged)
    1: {
    1:   if (!mBCInfo) ABORT0();
    1: 
    1:   BCCellData* cellData;
    1:   PRInt32 lastIndex, xIndex, yIndex;
    1:   PRInt32 xPos = aColIndex;
    1:   PRInt32 yPos = aRowIndex;
    1:   PRInt32 rgYPos = aRowIndex - aCellMapStart;
79445:   bool changed;
    1: 
    1:   switch(aSide) {
    1:   case NS_SIDE_BOTTOM:
    1:     rgYPos++;
    1:     yPos++;
    1:   case NS_SIDE_TOP:
    1:     lastIndex = xPos + aLength - 1;
    1:     for (xIndex = xPos; xIndex <= lastIndex; xIndex++) {
    1:       changed = aChanged && (xIndex == xPos);
    1:       BCData* bcData = nsnull;
    1:       cellData = (BCCellData*)aCellMap.GetDataAt(rgYPos, xIndex);
    1:       if (!cellData) {
    1:         PRInt32 numRgRows = aCellMap.GetRowCount();
    1:         if (yPos < numRgRows) { // add a dead cell data
    1:           nsRect damageArea;
82828:           cellData = (BCCellData*)aCellMap.AppendCell(*this, nsnull, rgYPos,
82828:                                                        false, 0, damageArea);
82828:           if (!cellData) ABORT0();
    1:         }
    1:         else {
    1:           NS_ASSERTION(aSide == NS_SIDE_BOTTOM, "program error");
    1:           // try the next non empty row group
    1:           nsCellMap* cellMap = aCellMap.GetNextSibling();
    1:           while (cellMap && (0 == cellMap->GetRowCount())) {
    1:             cellMap = cellMap->GetNextSibling();
    1:           }
    1:           if (cellMap) {
    1:             cellData = (BCCellData*)cellMap->GetDataAt(0, xIndex);
    1:             if (!cellData) { // add a dead cell
    1:               nsRect damageArea;
82828:               cellData = (BCCellData*)cellMap->AppendCell(*this, nsnull, 0,
82828:                                                            false, 0,
82828:                                                            damageArea);
    1:             }
    1:           }
    1:           else { // must be at the end of the table
    1:             bcData = GetBottomMostBorder(xIndex);
    1:           }
    1:         }
    1:       }
    1:       if (!bcData && cellData) {
    1:         bcData = &cellData->mData;
    1:       }
    1:       if (bcData) {
    1:         bcData->SetTopEdge(aOwner, aSize, changed);
    1:       }
    1:       else NS_ERROR("Cellmap: Top edge not found");
    1:     }
    1:     break;
    1:   case NS_SIDE_RIGHT:
    1:     xPos++;
    1:   case NS_SIDE_LEFT:
    1:     // since top, bottom borders were set, there should already be a cellData entry
    1:     lastIndex = rgYPos + aLength - 1;
    1:     for (yIndex = rgYPos; yIndex <= lastIndex; yIndex++) {
    1:       changed = aChanged && (yIndex == rgYPos);
    1:       cellData = (BCCellData*)aCellMap.GetDataAt(yIndex, xPos);
    1:       if (cellData) {
    1:         cellData->mData.SetLeftEdge(aOwner, aSize, changed);
    1:       }
    1:       else {
    1:         NS_ASSERTION(aSide == NS_SIDE_RIGHT, "program error");
    1:         BCData* bcData = GetRightMostBorder(yIndex + aCellMapStart);
    1:         if (bcData) {
    1:           bcData->SetLeftEdge(aOwner, aSize, changed);
    1:         }
    1:         else NS_ERROR("Cellmap: Left edge not found");
    1:       }
    1:     }
    1:     break;
    1:   }
    1: }
    1: 
    1: // store corner info (aOwner, aSubSize, aBevel). For aCorner = eTopLeft, store the info at
    1: // (aRowIndex, aColIndex). For eTopRight, store it in the entry to the right where
    1: // it would be top left. For eBottomRight, store it in the entry to the bottom. etc.
    1: void
    1: nsTableCellMap::SetBCBorderCorner(Corner      aCorner,
    1:                                   nsCellMap&  aCellMap,
    1:                                   PRUint32    aCellMapStart,
    1:                                   PRUint32    aRowIndex,
    1:                                   PRUint32    aColIndex,
41419:                                   mozilla::css::Side aOwner,
    1:                                   nscoord     aSubSize,
79445:                                   bool        aBevel,
79445:                                   bool        aIsBottomRight)
    1: {
    1:   if (!mBCInfo) ABORT0();
    1: 
    1:   if (aIsBottomRight) {
    1:     mBCInfo->mLowerRightCorner.SetCorner(aSubSize, aOwner, aBevel);
    1:     return;
    1:   }
    1: 
    1:   PRInt32 xPos = aColIndex;
    1:   PRInt32 yPos = aRowIndex;
    1:   PRInt32 rgYPos = aRowIndex - aCellMapStart;
    1: 
    1:   if (eTopRight == aCorner) {
    1:     xPos++;
    1:   }
    1:   else if (eBottomRight == aCorner) {
    1:     xPos++;
    1:     rgYPos++;
    1:     yPos++;
    1:   }
    1:   else if (eBottomLeft == aCorner) {
    1:     rgYPos++;
    1:     yPos++;
    1:   }
    1: 
    1:   BCCellData* cellData = nsnull;
    1:   BCData*     bcData   = nsnull;
    1:   if (GetColCount() <= xPos) {
    1:     NS_ASSERTION(xPos == GetColCount(), "program error");
    1:     // at the right edge of the table as we checked the corner before
    1:     NS_ASSERTION(!aIsBottomRight, "should be handled before");
    1:     bcData = GetRightMostBorder(yPos);
    1:   }
    1:   else {
    1:     cellData = (BCCellData*)aCellMap.GetDataAt(rgYPos, xPos);
    1:     if (!cellData) {
    1:       PRInt32 numRgRows = aCellMap.GetRowCount();
    1:       if (yPos < numRgRows) { // add a dead cell data
    1:         nsRect damageArea;
82828:         cellData = (BCCellData*)aCellMap.AppendCell(*this, nsnull, rgYPos,
82828:                                                      false, 0, damageArea);
    1:       }
    1:       else {
    1:         // try the next non empty row group
    1:         nsCellMap* cellMap = aCellMap.GetNextSibling();
    1:         while (cellMap && (0 == cellMap->GetRowCount())) {
    1:           cellMap = cellMap->GetNextSibling();
    1:         }
    1:         if (cellMap) {
    1:           cellData = (BCCellData*)cellMap->GetDataAt(0, xPos);
    1:           if (!cellData) { // add a dead cell
    1:             nsRect damageArea;
82828:             cellData = (BCCellData*)cellMap->AppendCell(*this, nsnull, 0,
82828:                                                          false, 0, damageArea);
    1:           }
    1:         }
50641:         else { // must be at the bottom of the table
    1:           bcData = GetBottomMostBorder(xPos);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   if (!bcData && cellData) {
    1:     bcData = &cellData->mData;
    1:   }
    1:   if (bcData) {
    1:     bcData->SetCorner(aSubSize, aOwner, aBevel);
    1:   }
    1:   else NS_ERROR("program error: Corner not found");
    1: }
    1: 
79445: nsCellMap::nsCellMap(nsTableRowGroupFrame* aRowGroup, bool aIsBC)
37262:   : mRows(8), mContentRowCount(0), mRowGroupFrame(aRowGroup),
    1:     mNextSibling(nsnull), mIsBC(aIsBC),
37262:     mPresContext(aRowGroup->PresContext())
    1: {
    1:   MOZ_COUNT_CTOR(nsCellMap);
    1:   NS_ASSERTION(mPresContext, "Must have prescontext");
    1: }
    1: 
    1: nsCellMap::~nsCellMap()
    1: {
    1:   MOZ_COUNT_DTOR(nsCellMap);
    1: 
    1:   PRUint32 mapRowCount = mRows.Length();
    1:   for (PRUint32 rowX = 0; rowX < mapRowCount; rowX++) {
    1:     CellDataArray &row = mRows[rowX];
    1:     PRUint32 colCount = row.Length();
    1:     for (PRUint32 colX = 0; colX < colCount; colX++) {
    1:       DestroyCellData(row[colX]);
    1:     }
    1:   }
    1: }
    1: 
    1: /* static */
73868: void
    1: nsCellMap::Init()
    1: {
73868:   NS_ABORT_IF_FALSE(!sEmptyRow, "How did that happen?");
    1:   sEmptyRow = new nsCellMap::CellDataArray();
    1: }
    1: 
    1: /* static */
    1: void
    1: nsCellMap::Shutdown()
    1: {
    1:   delete sEmptyRow;
    1:   sEmptyRow = nsnull;
    1: }
    1: 
    1: nsTableCellFrame*
    1: nsCellMap::GetCellFrame(PRInt32   aRowIndexIn,
    1:                         PRInt32   aColIndexIn,
    1:                         CellData& aData,
79445:                         bool      aUseRowIfOverlap) const
    1: {
    1:   PRInt32 rowIndex = aRowIndexIn - aData.GetRowSpanOffset();
    1:   PRInt32 colIndex = aColIndexIn - aData.GetColSpanOffset();
    1:   if (aData.IsOverlap()) {
    1:     if (aUseRowIfOverlap) {
    1:       colIndex = aColIndexIn;
    1:     }
    1:     else {
    1:       rowIndex = aRowIndexIn;
    1:     }
    1:   }
    1: 
    1:   CellData* data =
    1:     mRows.SafeElementAt(rowIndex, *sEmptyRow).SafeElementAt(colIndex);
    1:   if (data) {
    1:     return data->GetCellFrame();
    1:   }
    1:   return nsnull;
    1: }
    1: 
11311: PRInt32
29821: nsCellMap::GetHighestIndex(PRInt32 aColCount)
29821: {
29821:   PRInt32 index = -1;
29821:   PRInt32 rowCount = mRows.Length();
29821:   for (PRInt32 rowIdx = 0; rowIdx < rowCount; rowIdx++) {
29821:     const CellDataArray& row = mRows[rowIdx];
29821: 
29821:     for (PRInt32 colIdx = 0; colIdx < aColCount; colIdx++) {
29821:       CellData* data = row.SafeElementAt(colIdx);
29821:       // No data means row doesn't have more cells.
29821:       if (!data)
29821:         break;
29821: 
29821:       if (data->IsOrig())
29821:         index++;
29821:     }
29821:   }
29821: 
29821:   return index;
29821: }
29821: 
29821: PRInt32
11311: nsCellMap::GetIndexByRowAndColumn(PRInt32 aColCount,
11311:                                   PRInt32 aRow, PRInt32 aColumn) const
11311: {
29821:   if (PRUint32(aRow) >= mRows.Length())
29821:     return -1;
29821: 
11311:   PRInt32 index = -1;
29821:   PRInt32 lastColsIdx = aColCount - 1;
11311: 
29821:   // Find row index of the cell where row span is started.
29821:   const CellDataArray& row = mRows[aRow];
29821:   CellData* data = row.SafeElementAt(aColumn);
29821:   PRInt32 origRow = data ? aRow - data->GetRowSpanOffset() : aRow;
11311: 
29821:   // Calculate cell index.
29821:   for (PRInt32 rowIdx = 0; rowIdx <= origRow; rowIdx++) {
11311:     const CellDataArray& row = mRows[rowIdx];
29821:     PRInt32 colCount = (rowIdx == origRow) ? aColumn : lastColsIdx;
11311: 
11311:     for (PRInt32 colIdx = 0; colIdx <= colCount; colIdx++) {
29821:       data = row.SafeElementAt(colIdx);
29821:       // No data means row doesn't have more cells.
29821:       if (!data)
29821:         break;
29821: 
29821:       if (data->IsOrig())
11311:         index++;
11311:     }
11311:   }
11311: 
29821:   // Given row and column don't point to the cell.
29821:   if (!data)
29821:     return -1;
29821: 
11311:   return index;
11311: }
11311: 
11311: void
11311: nsCellMap::GetRowAndColumnByIndex(PRInt32 aColCount, PRInt32 aIndex,
11311:                                   PRInt32 *aRow, PRInt32 *aColumn) const
11311: {
11311:   *aRow = -1;
11311:   *aColumn = -1;
11311: 
11311:   PRInt32 index = aIndex;
11311:   PRInt32 rowCount = mRows.Length();
11311: 
11311:   for (PRInt32 rowIdx = 0; rowIdx < rowCount; rowIdx++) {
11311:     const CellDataArray& row = mRows[rowIdx];
11311: 
11311:     for (PRInt32 colIdx = 0; colIdx < aColCount; colIdx++) {
11311:       CellData* data = row.SafeElementAt(colIdx);
29821: 
29821:       // The row doesn't have more cells.
29821:       if (!data)
29821:         break;
29821: 
29821:       if (data->IsOrig())
11311:         index--;
11311: 
11311:       if (index < 0) {
11311:         *aRow = rowIdx;
11311:         *aColumn = colIdx;
11311:         return;
11311:       }
11311:     }
11311:   }
11311: }
11311: 
79445: bool nsCellMap::Grow(nsTableCellMap& aMap,
    1:                        PRInt32         aNumRows,
    1:                        PRInt32         aRowIndex)
    1: {
    1:   NS_ASSERTION(aNumRows >= 1, "Why are we calling this?");
    1: 
    1:   // Get the number of cols we want to use for preallocating the row arrays.
    1:   PRInt32 numCols = aMap.GetColCount();
    1:   if (numCols == 0) {
    1:     numCols = 4;
    1:   }
    1:   PRUint32 startRowIndex = (aRowIndex >= 0) ? aRowIndex : mRows.Length();
    1:   NS_ASSERTION(startRowIndex <= mRows.Length(), "Missing grow call inbetween");
    1: 
    1:   return mRows.InsertElementsAt(startRowIndex, aNumRows, numCols) != nsnull;
    1: }
    1: 
    1: void nsCellMap::GrowRow(CellDataArray& aRow,
    1:                         PRInt32        aNumCols)
    1: 
    1: {
    1:   // Have to have the cast to get the template to do the right thing.
    1:   aRow.InsertElementsAt(aRow.Length(), aNumCols, (CellData*)nsnull);
    1: }
    1: 
    1: void
    1: nsCellMap::InsertRows(nsTableCellMap&             aMap,
24724:                       nsTArray<nsTableRowFrame*>& aRows,
    1:                       PRInt32                     aFirstRowIndex,
79445:                       bool                        aConsiderSpans,
82828:                       PRInt32                     aRgFirstRowIndex,
    1:                       nsRect&                     aDamageArea)
    1: {
    1:   PRInt32 numCols = aMap.GetColCount();
    1:   NS_ASSERTION(aFirstRowIndex >= 0, "nsCellMap::InsertRows called with negative rowIndex");
    1:   if (PRUint32(aFirstRowIndex) > mRows.Length()) {
    1:     // create (aFirstRowIndex - mRows.Length()) empty rows up to aFirstRowIndex
    1:     PRInt32 numEmptyRows = aFirstRowIndex - mRows.Length();
    1:     if (!Grow(aMap, numEmptyRows)) {
    1:       return;
    1:     }
    1:   }
    1: 
    1:   if (!aConsiderSpans) {
    1:     // update mContentRowCount, since non-empty rows will be added
32531:     mContentRowCount = NS_MAX(aFirstRowIndex, mContentRowCount);
82828:     ExpandWithRows(aMap, aRows, aFirstRowIndex, aRgFirstRowIndex, aDamageArea);
    1:     return;
    1:   }
    1: 
    1:   // if any cells span into or out of the row being inserted, then rebuild
79445:   bool spansCauseRebuild = CellsSpanInOrOut(aFirstRowIndex,
    1:                                               aFirstRowIndex, 0, numCols - 1);
    1: 
    1:   // update mContentRowCount, since non-empty rows will be added
32531:   mContentRowCount = NS_MAX(aFirstRowIndex, mContentRowCount);
    1: 
    1:   // if any of the new cells span out of the new rows being added, then rebuild
    1:   // XXX it would be better to only rebuild the portion of the map that follows the new rows
    1:   if (!spansCauseRebuild && (PRUint32(aFirstRowIndex) < mRows.Length())) {
    1:     spansCauseRebuild = CellsSpanOut(aRows);
    1:   }
    1:   if (spansCauseRebuild) {
    1:     aMap.RebuildConsideringRows(this, aFirstRowIndex, &aRows, 0, aDamageArea);
    1:   }
    1:   else {
82828:     ExpandWithRows(aMap, aRows, aFirstRowIndex, aRgFirstRowIndex, aDamageArea);
    1:   }
    1: }
    1: 
    1: void
    1: nsCellMap::RemoveRows(nsTableCellMap& aMap,
    1:                       PRInt32         aFirstRowIndex,
    1:                       PRInt32         aNumRowsToRemove,
79445:                       bool            aConsiderSpans,
82828:                       PRInt32         aRgFirstRowIndex,
    1:                       nsRect&         aDamageArea)
    1: {
    1:   PRInt32 numRows = mRows.Length();
    1:   PRInt32 numCols = aMap.GetColCount();
    1: 
    1:   if (aFirstRowIndex >= numRows) {
    1:     // reduce the content based row count based on the function arguments
    1:     // as they are known to be real rows even if the cell map did not create
    1:     // rows for them before.
    1:     mContentRowCount -= aNumRowsToRemove;
    1:     return;
    1:   }
    1:   if (!aConsiderSpans) {
82828:     ShrinkWithoutRows(aMap, aFirstRowIndex, aNumRowsToRemove, aRgFirstRowIndex,
82828:                       aDamageArea);
    1:     return;
    1:   }
    1:   PRInt32 endRowIndex = aFirstRowIndex + aNumRowsToRemove - 1;
    1:   if (endRowIndex >= numRows) {
    1:     NS_ERROR("nsCellMap::RemoveRows tried to remove too many rows");
    1:     endRowIndex = numRows - 1;
    1:   }
79445:   bool spansCauseRebuild = CellsSpanInOrOut(aFirstRowIndex, endRowIndex,
    1:                                               0, numCols - 1);
    1:   if (spansCauseRebuild) {
82828:     aMap.RebuildConsideringRows(this, aFirstRowIndex, nsnull, aNumRowsToRemove,
82828:                                 aDamageArea);
    1:   }
    1:   else {
82828:     ShrinkWithoutRows(aMap, aFirstRowIndex, aNumRowsToRemove, aRgFirstRowIndex,
82828:                       aDamageArea);
    1:   }
    1: }
    1: 
    1: 
    1: 
    1: 
    1: CellData*
    1: nsCellMap::AppendCell(nsTableCellMap&   aMap,
    1:                       nsTableCellFrame* aCellFrame,
    1:                       PRInt32           aRowIndex,
79445:                       bool              aRebuildIfNecessary,
82828:                       PRInt32           aRgFirstRowIndex,
    1:                       nsRect&           aDamageArea,
    1:                       PRInt32*          aColToBeginSearch)
    1: {
    1:   NS_ASSERTION(!!aMap.mBCInfo == mIsBC, "BC state mismatch");
    1:   PRInt32 origNumMapRows = mRows.Length();
    1:   PRInt32 origNumCols = aMap.GetColCount();
79445:   bool    zeroRowSpan = false;
    1:   PRInt32 rowSpan = (aCellFrame) ? GetRowSpanForNewCell(aCellFrame, aRowIndex,
    1:                                                         zeroRowSpan) : 1;
    1:   // add new rows if necessary
    1:   PRInt32 endRowIndex = aRowIndex + rowSpan - 1;
    1:   if (endRowIndex >= origNumMapRows) {
    1:     // XXXbz handle allocation failures?
    1:     Grow(aMap, 1 + endRowIndex - origNumMapRows);
    1:   }
    1: 
    1:   // get the first null or dead CellData in the desired row. It will equal origNumCols if there are none
    1:   CellData* origData = nsnull;
    1:   PRInt32 startColIndex = 0;
    1:   if (aColToBeginSearch)
    1:     startColIndex = *aColToBeginSearch;
    1:   for (; startColIndex < origNumCols; startColIndex++) {
    1:     CellData* data = GetDataAt(aRowIndex, startColIndex);
    1:     if (!data)
    1:       break;
39021:     // The border collapse code relies on having multiple dead cell data entries
39021:     // in a row.
39021:     if (data->IsDead() && aCellFrame) {
    1:       origData = data;
    1:       break;
    1:     }
    1:     if (data->IsZeroColSpan() ) {
    1:       // appending a cell collapses zerospans.
    1:       CollapseZeroColSpan(aMap, data, aRowIndex, startColIndex);
    1:       // ask again for the data as it should be modified
    1:       origData = GetDataAt(aRowIndex, startColIndex);
    1:       NS_ASSERTION(origData->IsDead(),
    1:                    "The cellposition should have been cleared");
    1:       break;
    1:     }
    1:   }
    1:   // We found the place to append the cell, when the next cell is appended
    1:   // the next search does not need to duplicate the search but can start
    1:   // just at the next cell.
    1:   if (aColToBeginSearch)
    1:     *aColToBeginSearch =  startColIndex + 1;
    1: 
79445:   bool    zeroColSpan = false;
    1:   PRInt32 colSpan = (aCellFrame) ?
    1:                     GetColSpanForNewCell(*aCellFrame, zeroColSpan) : 1;
    1:   if (zeroColSpan) {
80486:     aMap.mTableFrame.SetHasZeroColSpans(true);
80486:     aMap.mTableFrame.SetNeedColSpanExpansion(true);
    1:   }
    1: 
    1:   // if the new cell could potentially span into other rows and collide with
    1:   // originating cells there, we will play it safe and just rebuild the map
    1:   if (aRebuildIfNecessary && (aRowIndex < mContentRowCount - 1) && (rowSpan > 1)) {
24724:     nsAutoTArray<nsTableCellFrame*, 1> newCellArray;
    1:     newCellArray.AppendElement(aCellFrame);
80486:     aMap.RebuildConsideringCells(this, &newCellArray, aRowIndex, startColIndex, true, aDamageArea);
    1:     return origData;
    1:   }
32531:   mContentRowCount = NS_MAX(mContentRowCount, aRowIndex + 1);
    1: 
    1:   // add new cols to the table map if necessary
    1:   PRInt32 endColIndex = startColIndex + colSpan - 1;
    1:   if (endColIndex >= origNumCols) {
    1:     NS_ASSERTION(aCellFrame, "dead cells should not require new columns");
    1:     aMap.AddColsAtEnd(1 + endColIndex - origNumCols);
    1:   }
    1: 
    1:   // Setup CellData for this cell
    1:   if (origData) {
    1:     NS_ASSERTION(origData->IsDead(), "replacing a non dead cell is a memory leak");
    1:     if (aCellFrame) { // do nothing to replace a dead cell with a dead cell
    1:       origData->Init(aCellFrame);
    1:       // we are replacing a dead cell, increase the number of cells
    1:       // originating at this column
    1:       nsColInfo* colInfo = aMap.GetColInfoAt(startColIndex);
    1:       NS_ASSERTION(colInfo, "access to a non existing column");
    1:       if (colInfo) {
    1:         colInfo->mNumCellsOrig++;
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     origData = AllocCellData(aCellFrame);
    1:     if (!origData) ABORT1(origData);
    1:     SetDataAt(aMap, *origData, aRowIndex, startColIndex);
    1:   }
    1: 
82828:   if (aRebuildIfNecessary) {
82828:     //the caller depends on the damageArea
82828:     // The special case for zeroRowSpan is to adjust for the '2' in
82828:     // GetRowSpanForNewCell.
82828:     PRUint32 height = zeroRowSpan ? endRowIndex - aRowIndex  :
82828:                                     1 + endRowIndex - aRowIndex;
82828:     SetDamageArea(startColIndex, aRgFirstRowIndex + aRowIndex,
82828:                   1 + endColIndex - startColIndex, height, aDamageArea);
82828:   }
    1: 
    1:   if (!aCellFrame) {
    1:     return origData;
    1:   }
    1: 
    1:   // initialize the cell frame
    1:   aCellFrame->SetColIndex(startColIndex);
    1: 
    1:   // Create CellData objects for the rows that this cell spans. Set
    1:   // their mOrigCell to nsnull and their mSpanData to point to data.
    1:   for (PRInt32 rowX = aRowIndex; rowX <= endRowIndex; rowX++) {
    1:     // The row at rowX will need to have at least endColIndex columns
    1:     mRows[rowX].SetCapacity(endColIndex);
    1:     for (PRInt32 colX = startColIndex; colX <= endColIndex; colX++) {
    1:       if ((rowX != aRowIndex) || (colX != startColIndex)) { // skip orig cell data done above
    1:         CellData* cellData = GetDataAt(rowX, colX);
    1:         if (cellData) {
    1:           if (cellData->IsOrig()) {
    1:             NS_ERROR("cannot overlap originating cell");
    1:             continue;
    1:           }
    1:           if (rowX > aRowIndex) { // row spanning into cell
    1:             if (cellData->IsRowSpan()) {
    1:               // do nothing, this can be caused by rowspan which is overlapped
    1:               // by a another cell with a rowspan and a colspan
    1:             }
    1:             else {
    1:               cellData->SetRowSpanOffset(rowX - aRowIndex);
    1:               if (zeroRowSpan) {
80486:                 cellData->SetZeroRowSpan(true);
    1:               }
    1:             }
    1:           }
    1:           if (colX > startColIndex) { // col spanning into cell
    1:             if (!cellData->IsColSpan()) {
    1:               if (cellData->IsRowSpan()) {
80486:                 cellData->SetOverlap(true);
    1:               }
    1:               cellData->SetColSpanOffset(colX - startColIndex);
    1:               if (zeroColSpan) {
80486:                 cellData->SetZeroColSpan(true);
    1:               }
    1: 
    1:               nsColInfo* colInfo = aMap.GetColInfoAt(colX);
    1:               colInfo->mNumCellsSpan++;
    1:             }
    1:           }
    1:         }
    1:         else {
    1:           cellData = AllocCellData(nsnull);
    1:           if (!cellData) return origData;
    1:           if (rowX > aRowIndex) {
    1:             cellData->SetRowSpanOffset(rowX - aRowIndex);
    1:             if (zeroRowSpan) {
80486:               cellData->SetZeroRowSpan(true);
    1:             }
    1:           }
    1:           if (colX > startColIndex) {
    1:             cellData->SetColSpanOffset(colX - startColIndex);
    1:             if (zeroColSpan) {
80486:               cellData->SetZeroColSpan(true);
    1:             }
    1:           }
    1:           SetDataAt(aMap, *cellData, rowX, colX);
    1:         }
    1:       }
    1:     }
    1:   }
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("appended cell=%p row=%d \n", aCellFrame, aRowIndex);
    1:   aMap.Dump();
    1: #endif
    1:   return origData;
    1: }
    1: 
    1: void nsCellMap::CollapseZeroColSpan(nsTableCellMap& aMap,
    1:                                     CellData*       aOrigData,
    1:                                     PRInt32         aRowIndex,
    1:                                     PRInt32         aColIndex)
    1: {
    1:   // if after a colspan = 0 cell another cell is appended in a row the html 4
    1:   // spec is already violated. In principle one should then append the cell
    1:   // after the last column but then the zero spanning cell would also have
    1:   // to grow. The only plausible way to break this cycle is ignore the zero
    1:   // colspan and reset the cell to colspan = 1.
    1: 
    1:   NS_ASSERTION(aOrigData && aOrigData->IsZeroColSpan(),
    1:                "zero colspan should have been passed");
    1:   // find the originating cellframe
80486:   nsTableCellFrame* cell = GetCellFrame(aRowIndex, aColIndex, *aOrigData, true);
    1:   NS_ASSERTION(cell, "originating cell not found");
    1: 
    1:   // find the clearing region
    1:   PRInt32 startRowIndex = aRowIndex - aOrigData->GetRowSpanOffset();
79445:   bool    zeroSpan;
    1:   PRInt32 rowSpan = GetRowSpanForNewCell(cell, startRowIndex, zeroSpan);
    1:   PRInt32 endRowIndex = startRowIndex + rowSpan;
    1: 
    1:   PRInt32 origColIndex = aColIndex - aOrigData->GetColSpanOffset();
    1:   PRInt32 endColIndex = origColIndex +
    1:                         GetEffectiveColSpan(aMap, startRowIndex,
    1:                                             origColIndex, zeroSpan);
    1:   for (PRInt32 colX = origColIndex +1; colX < endColIndex; colX++) {
    1:     // Start the collapse just after the originating cell, since
    1:     // we're basically making the originating cell act as if it
    1:     // has colspan="1".
    1:     nsColInfo* colInfo = aMap.GetColInfoAt(colX);
    1:     colInfo->mNumCellsSpan -= rowSpan;
    1: 
    1:     for (PRInt32 rowX = startRowIndex; rowX < endRowIndex; rowX++)
    1:     {
    1:       CellData* data = mRows[rowX][colX];
    1:       NS_ASSERTION(data->IsZeroColSpan(),
    1:                    "Overwriting previous data - memory leak");
    1:       data->Init(nsnull); // mark the cell as a dead cell.
    1:     }
    1:   }
    1: }
    1: 
79445: bool nsCellMap::CellsSpanOut(nsTArray<nsTableRowFrame*>& aRows) const
    1: {
24724:   PRInt32 numNewRows = aRows.Length();
    1:   for (PRInt32 rowX = 0; rowX < numNewRows; rowX++) {
    1:     nsIFrame* rowFrame = (nsIFrame *) aRows.ElementAt(rowX);
77154:     nsIFrame* childFrame = rowFrame->GetFirstPrincipalChild();
26583:     while (childFrame) {
26583:       nsTableCellFrame *cellFrame = do_QueryFrame(childFrame);
26583:       if (cellFrame) {
79445:         bool zeroSpan;
26583:         PRInt32 rowSpan = GetRowSpanForNewCell(cellFrame, rowX, zeroSpan);
42272:         if (zeroSpan || rowX + rowSpan > numNewRows) {
80486:           return true;
    1:         }
    1:       }
26583:       childFrame = childFrame->GetNextSibling();
    1:     }
    1:   }
80486:   return false;
    1: }
    1: 
80486: // return true if any cells have rows spans into or out of the region
    1: // defined by the row and col indices or any cells have colspans into the region
79445: bool nsCellMap::CellsSpanInOrOut(PRInt32 aStartRowIndex,
    1:                                    PRInt32 aEndRowIndex,
    1:                                    PRInt32 aStartColIndex,
    1:                                    PRInt32 aEndColIndex) const
    1: {
    1:   /*
    1:    * this routine will watch the cells adjacent to the region or at the edge
    1:    * they are marked with *. The routine will verify whether they span in or
    1:    * are spanned out.
    1:    *
    1:    *                           startCol          endCol
    1:    *             r1c1   r1c2   r1c3      r1c4    r1c5    r1rc6  r1c7
    1:    *  startrow   r2c1   r2c2  *r2c3     *r2c4   *r2c5   *r2rc6  r2c7
    1:    *  endrow     r3c1   r3c2  *r3c3      r3c4    r3c5   *r3rc6  r3c7
    1:    *             r4c1   r4c2  *r4c3     *r4c4   *r4c5    r4rc6  r4c7
    1:    *             r5c1   r5c2   r5c3      r5c4    r5c5    r5rc6  r5c7
    1:    */
    1: 
    1:   PRInt32 numRows = mRows.Length(); // use the cellmap rows to determine the
    1:                                     // current cellmap extent.
    1:   for (PRInt32 colX = aStartColIndex; colX <= aEndColIndex; colX++) {
    1:     CellData* cellData;
    1:     if (aStartRowIndex > 0) {
    1:       cellData = GetDataAt(aStartRowIndex, colX);
    1:       if (cellData && (cellData->IsRowSpan())) {
80486:         return true; // there is a row span into the region
    1:       }
    1:       if ((aStartRowIndex >= mContentRowCount) &&  (mContentRowCount > 0)) {
    1:         cellData = GetDataAt(mContentRowCount - 1, colX);
    1:         if (cellData && cellData->IsZeroRowSpan()) {
80486:           return true;  // When we expand the zerospan it'll span into our row
    1:         }
    1:       }
    1:     }
    1:     if (aEndRowIndex < numRows - 1) { // is there anything below aEndRowIndex
    1:       cellData = GetDataAt(aEndRowIndex + 1, colX);
    1:       if ((cellData) && (cellData->IsRowSpan())) {
80486:         return true; // there is a row span out of the region
    1:       }
    1:     }
    1:     else {
    1:       cellData = GetDataAt(aEndRowIndex, colX);
    1:       if ((cellData) && (cellData->IsRowSpan()) && (mContentRowCount < numRows)) {
80486:         return true; // this cell might be the cause of a dead row
    1:       }
    1:     }
    1:   }
    1:   if (aStartColIndex > 0) {
    1:     for (PRInt32 rowX = aStartRowIndex; rowX <= aEndRowIndex; rowX++) {
    1:       CellData* cellData = GetDataAt(rowX, aStartColIndex);
    1:       if (cellData && (cellData->IsColSpan())) {
80486:         return true; // there is a col span into the region
    1:       }
    1:       cellData = GetDataAt(rowX, aEndColIndex + 1);
    1:       if (cellData && (cellData->IsColSpan())) {
80486:         return true; // there is a col span out of the region
80486:       }
80486:     }
80486:   }
80486:   return false;
    1: }
    1: 
    1: void nsCellMap::InsertCells(nsTableCellMap&              aMap,
24724:                             nsTArray<nsTableCellFrame*>& aCellFrames,
    1:                             PRInt32                      aRowIndex,
    1:                             PRInt32                      aColIndexBefore,
82828:                             PRInt32                      aRgFirstRowIndex,
    1:                             nsRect&                      aDamageArea)
    1: {
24724:   if (aCellFrames.Length() == 0) return;
    1:   NS_ASSERTION(aColIndexBefore >= -1, "index out of range");
    1:   PRInt32 numCols = aMap.GetColCount();
    1:   if (aColIndexBefore >= numCols) {
    1:     NS_ERROR("Inserting instead of appending cells indicates a serious cellmap error");
    1:     aColIndexBefore = numCols - 1;
    1:   }
    1: 
    1:   // get the starting col index of the 1st new cells
    1:   PRInt32 startColIndex;
    1:   for (startColIndex = aColIndexBefore + 1; startColIndex < numCols; startColIndex++) {
    1:     CellData* data = GetDataAt(aRowIndex, startColIndex);
    1:     if (!data || data->IsOrig() || data->IsDead()) {
    1:       // // Not a span.  Stop.
    1:       break;
    1:     }
    1:     if (data->IsZeroColSpan()) {
    1:       // Zero colspans collapse.  Stop in this case too.
    1:       CollapseZeroColSpan(aMap, data, aRowIndex, startColIndex);
    1:       break;
    1:     }
    1:   }
    1: 
    1:   // record whether inserted cells are going to cause complications due
    1:   // to existing row spans, col spans or table sizing.
79445:   bool spansCauseRebuild = false;
    1: 
    1:   // check that all cells have the same row span
24724:   PRInt32 numNewCells = aCellFrames.Length();
79445:   bool zeroRowSpan = false;
    1:   PRInt32 rowSpan = 0;
    1:   for (PRInt32 cellX = 0; cellX < numNewCells; cellX++) {
24724:     nsTableCellFrame* cell = aCellFrames.ElementAt(cellX);
    1:     PRInt32 rowSpan2 = GetRowSpanForNewCell(cell, aRowIndex, zeroRowSpan);
    1:     if (rowSpan == 0) {
    1:       rowSpan = rowSpan2;
    1:     }
    1:     else if (rowSpan != rowSpan2) {
80486:       spansCauseRebuild = true;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   // check if the new cells will cause the table to add more rows
    1:   if (!spansCauseRebuild) {
    1:     if (mRows.Length() < PRUint32(aRowIndex + rowSpan)) {
80486:       spansCauseRebuild = true;
    1:     }
    1:   }
    1: 
    1:   if (!spansCauseRebuild) {
    1:     spansCauseRebuild = CellsSpanInOrOut(aRowIndex, aRowIndex + rowSpan - 1,
    1:                                          startColIndex, numCols - 1);
    1:   }
    1:   if (spansCauseRebuild) {
82828:     aMap.RebuildConsideringCells(this, &aCellFrames, aRowIndex, startColIndex,
82828:                                  true, aDamageArea);
    1:   }
    1:   else {
82828:     ExpandWithCells(aMap, aCellFrames, aRowIndex, startColIndex, rowSpan,
82828:                     zeroRowSpan, aRgFirstRowIndex, aDamageArea);
    1:   }
    1: }
    1: 
    1: void
    1: nsCellMap::ExpandWithRows(nsTableCellMap&             aMap,
24724:                           nsTArray<nsTableRowFrame*>& aRowFrames,
    1:                           PRInt32                     aStartRowIndexIn,
82828:                           PRInt32                     aRgFirstRowIndex,
    1:                           nsRect&                     aDamageArea)
    1: {
    1:   PRInt32 startRowIndex = (aStartRowIndexIn >= 0) ? aStartRowIndexIn : 0;
    1:   NS_ASSERTION(PRUint32(startRowIndex) <= mRows.Length(), "caller should have grown cellmap before");
    1: 
24724:   PRInt32 numNewRows  = aRowFrames.Length();
    1:   mContentRowCount += numNewRows;
    1: 
    1:   PRInt32 endRowIndex = startRowIndex + numNewRows - 1;
    1: 
    1:   // shift the rows after startRowIndex down and insert empty rows that will
    1:   // be filled via the AppendCell call below
    1:   if (!Grow(aMap, numNewRows, startRowIndex)) {
    1:     return;
    1:   }
    1: 
    1: 
    1:   PRInt32 newRowIndex = 0;
    1:   for (PRInt32 rowX = startRowIndex; rowX <= endRowIndex; rowX++) {
24724:     nsTableRowFrame* rFrame = aRowFrames.ElementAt(newRowIndex);
    1:     // append cells
77154:     nsIFrame* cFrame = rFrame->GetFirstPrincipalChild();
    1:     PRInt32 colIndex = 0;
    1:     while (cFrame) {
26583:       nsTableCellFrame *cellFrame = do_QueryFrame(cFrame);
26583:       if (cellFrame) {
82828:         AppendCell(aMap, cellFrame, rowX, false, aRgFirstRowIndex, aDamageArea,
82828:                    &colIndex);
    1:       }
    1:       cFrame = cFrame->GetNextSibling();
    1:     }
    1:     newRowIndex++;
    1:   }
82828:   SetDamageArea(0, aRgFirstRowIndex + startRowIndex, aMap.GetColCount(),
82828:                 1 + endRowIndex - startRowIndex, aDamageArea);
    1: }
    1: 
    1: void nsCellMap::ExpandWithCells(nsTableCellMap&              aMap,
24724:                                 nsTArray<nsTableCellFrame*>& aCellFrames,
    1:                                 PRInt32                      aRowIndex,
    1:                                 PRInt32                      aColIndex,
    1:                                 PRInt32                      aRowSpan, // same for all cells
79445:                                 bool                         aRowSpanIsZero,
82828:                                 PRInt32                      aRgFirstRowIndex,
    1:                                 nsRect&                      aDamageArea)
    1: {
    1:   NS_ASSERTION(!!aMap.mBCInfo == mIsBC, "BC state mismatch");
    1:   PRInt32 endRowIndex = aRowIndex + aRowSpan - 1;
    1:   PRInt32 startColIndex = aColIndex;
    1:   PRInt32 endColIndex = aColIndex;
24724:   PRInt32 numCells = aCellFrames.Length();
    1:   PRInt32 totalColSpan = 0;
    1: 
    1:   // add cellData entries for the space taken up by the new cells
    1:   for (PRInt32 cellX = 0; cellX < numCells; cellX++) {
24724:     nsTableCellFrame* cellFrame = aCellFrames.ElementAt(cellX);
    1:     CellData* origData = AllocCellData(cellFrame); // the originating cell
    1:     if (!origData) return;
    1: 
    1:     // set the starting and ending col index for the new cell
79445:     bool zeroColSpan = false;
    1:     PRInt32 colSpan = GetColSpanForNewCell(*cellFrame, zeroColSpan);
    1:     if (zeroColSpan) {
80486:       aMap.mTableFrame.SetHasZeroColSpans(true);
80486:       aMap.mTableFrame.SetNeedColSpanExpansion(true);
    1:     }
    1:     totalColSpan += colSpan;
    1:     if (cellX == 0) {
    1:       endColIndex = aColIndex + colSpan - 1;
    1:     }
    1:     else {
    1:       startColIndex = endColIndex + 1;
    1:       endColIndex   = startColIndex + colSpan - 1;
    1:     }
    1: 
    1:     // add the originating cell data and any cell data corresponding to row/col spans
    1:     for (PRInt32 rowX = aRowIndex; rowX <= endRowIndex; rowX++) {
    1:       CellDataArray& row = mRows[rowX];
    1:       // Pre-allocate all the cells we'll need in this array, setting
    1:       // them to null.
    1:       // Have to have the cast to get the template to do the right thing.
24724:       PRInt32 insertionIndex = row.Length();
27264:       if (insertionIndex > startColIndex) {
27264:         insertionIndex = startColIndex;
    1:       }
    1:       if (!row.InsertElementsAt(insertionIndex, endColIndex - insertionIndex + 1,
    1:                                 (CellData*)nsnull) &&
    1:           rowX == aRowIndex) {
    1:         // Failed to insert the slots, and this is the very first row.  That
    1:         // means that we need to clean up |origData| before returning, since
    1:         // the cellmap doesn't own it yet.
    1:         DestroyCellData(origData);
    1:         return;
    1:       }
    1: 
27264:       for (PRInt32 colX = startColIndex; colX <= endColIndex; colX++) {
    1:         CellData* data = origData;
    1:         if ((rowX != aRowIndex) || (colX != startColIndex)) {
    1:           data = AllocCellData(nsnull);
    1:           if (!data) return;
    1:           if (rowX > aRowIndex) {
    1:             data->SetRowSpanOffset(rowX - aRowIndex);
    1:             if (aRowSpanIsZero) {
80486:               data->SetZeroRowSpan(true);
    1:             }
    1:           }
    1:           if (colX > startColIndex) {
    1:             data->SetColSpanOffset(colX - startColIndex);
    1:             if (zeroColSpan) {
80486:               data->SetZeroColSpan(true);
    1:             }
    1:           }
    1:         }
    1:         SetDataAt(aMap, *data, rowX, colX);
    1:       }
    1:     }
    1:     cellFrame->SetColIndex(startColIndex);
    1:   }
82828:   PRInt32 damageHeight = NS_MIN(GetRowGroup()->GetRowCount() - aRowIndex,
82828:                                 aRowSpan);
82828:   SetDamageArea(aColIndex, aRgFirstRowIndex + aRowIndex,
82828:                 1 + endColIndex - aColIndex, damageHeight, aDamageArea);
    1: 
    1:   PRInt32 rowX;
    1: 
    1:   // update the row and col info due to shifting
    1:   for (rowX = aRowIndex; rowX <= endRowIndex; rowX++) {
    1:     CellDataArray& row = mRows[rowX];
    1:     PRUint32 numCols = row.Length();
    1:     PRUint32 colX;
    1:     for (colX = aColIndex + totalColSpan; colX < numCols; colX++) {
    1:       CellData* data = row[colX];
    1:       if (data) {
    1:         // increase the origin and span counts beyond the spanned cols
    1:         if (data->IsOrig()) {
    1:           // a cell that gets moved needs adjustment as well as it new orignating col
    1:           data->GetCellFrame()->SetColIndex(colX);
    1:           nsColInfo* colInfo = aMap.GetColInfoAt(colX);
    1:           colInfo->mNumCellsOrig++;
    1:         }
    1:         if (data->IsColSpan()) {
    1:           nsColInfo* colInfo = aMap.GetColInfoAt(colX);
    1:           colInfo->mNumCellsSpan++;
    1:         }
    1: 
    1:         // decrease the origin and span counts within the spanned cols
    1:         PRInt32 colX2 = colX - totalColSpan;
    1:         nsColInfo* colInfo2 = aMap.GetColInfoAt(colX2);
    1:         if (data->IsOrig()) {
    1:           // the old originating col of a moved cell needs adjustment
    1:           colInfo2->mNumCellsOrig--;
    1:         }
    1:         if (data->IsColSpan()) {
    1:           colInfo2->mNumCellsSpan--;
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void nsCellMap::ShrinkWithoutRows(nsTableCellMap& aMap,
    1:                                   PRInt32         aStartRowIndex,
    1:                                   PRInt32         aNumRowsToRemove,
82828:                                   PRInt32         aRgFirstRowIndex,
    1:                                   nsRect&         aDamageArea)
    1: {
    1:   NS_ASSERTION(!!aMap.mBCInfo == mIsBC, "BC state mismatch");
    1:   PRInt32 endRowIndex = aStartRowIndex + aNumRowsToRemove - 1;
    1:   PRUint32 colCount = aMap.GetColCount();
    1:   for (PRInt32 rowX = endRowIndex; rowX >= aStartRowIndex; --rowX) {
    1:     CellDataArray& row = mRows[rowX];
    1:     PRUint32 colX;
    1:     for (colX = 0; colX < colCount; colX++) {
    1:       CellData* data = row.SafeElementAt(colX);
    1:       if (data) {
    1:         // Adjust the column counts.
    1:         if (data->IsOrig()) {
    1:           // Decrement the column count.
    1:           nsColInfo* colInfo = aMap.GetColInfoAt(colX);
    1:           colInfo->mNumCellsOrig--;
    1:         }
    1:         // colspan=0 is only counted as a spanned cell in the 1st col it spans
    1:         else if (data->IsColSpan()) {
    1:           nsColInfo* colInfo = aMap.GetColInfoAt(colX);
    1:           colInfo->mNumCellsSpan--;
    1:         }
    1:       }
    1:     }
    1: 
    1:     PRUint32 rowLength = row.Length();
    1:     // Delete our row information.
    1:     for (colX = 0; colX < rowLength; colX++) {
    1:       DestroyCellData(row[colX]);
    1:     }
    1: 
    1:     mRows.RemoveElementAt(rowX);
    1: 
    1:     // Decrement our row and next available index counts.
    1:     mContentRowCount--;
    1:   }
    1:   aMap.RemoveColsAtEnd();
82828:   SetDamageArea(0, aRgFirstRowIndex + aStartRowIndex, aMap.GetColCount(), 0,
82828:                 aDamageArea);
    1: }
    1: 
    1: PRInt32 nsCellMap::GetColSpanForNewCell(nsTableCellFrame& aCellFrameToAdd,
79445:                                         bool&           aIsZeroColSpan) const
    1: {
80486:   aIsZeroColSpan = false;
    1:   PRInt32 colSpan = aCellFrameToAdd.GetColSpan();
    1:   if (0 == colSpan) {
    1:     colSpan = 1; // set the min colspan it will be expanded later
80486:     aIsZeroColSpan = true;
    1:   }
    1:   return colSpan;
    1: }
    1: 
    1: PRInt32 nsCellMap::GetEffectiveColSpan(const nsTableCellMap& aMap,
    1:                                        PRInt32         aRowIndex,
    1:                                        PRInt32         aColIndex,
79445:                                        bool&         aZeroColSpan) const
    1: {
    1:   PRInt32 numColsInTable = aMap.GetColCount();
80486:   aZeroColSpan = false;
    1:   PRInt32 colSpan = 1;
    1:   if (PRUint32(aRowIndex) >= mRows.Length()) {
    1:     return colSpan;
    1:   }
    1: 
    1:   const CellDataArray& row = mRows[aRowIndex];
    1:   PRInt32 colX;
    1:   CellData* data;
    1:   PRInt32 maxCols = numColsInTable;
79445:   bool hitOverlap = false; // XXX this is not ever being set to true
    1:   for (colX = aColIndex + 1; colX < maxCols; colX++) {
    1:     data = row.SafeElementAt(colX);
    1:     if (data) {
    1:       // for an overlapping situation get the colspan from the originating cell and
    1:       // use that as the max number of cols to iterate. Since this is rare, only
    1:       // pay the price of looking up the cell's colspan here.
    1:       if (!hitOverlap && data->IsOverlap()) {
    1:         CellData* origData = row.SafeElementAt(aColIndex);
    1:         if (origData && origData->IsOrig()) {
    1:           nsTableCellFrame* cellFrame = origData->GetCellFrame();
    1:           if (cellFrame) {
    1:             // possible change the number of colums to iterate
32531:             maxCols = NS_MIN(aColIndex + cellFrame->GetColSpan(), maxCols);
    1:             if (colX >= maxCols)
    1:               break;
    1:           }
    1:         }
    1:       }
    1:       if (data->IsColSpan()) {
    1:         colSpan++;
    1:         if (data->IsZeroColSpan()) {
80486:           aZeroColSpan = true;
    1:         }
    1:       }
    1:       else {
    1:         break;
    1:       }
    1:     }
    1:     else break;
    1:   }
    1:   return colSpan;
    1: }
    1: 
    1: PRInt32
    1: nsCellMap::GetRowSpanForNewCell(nsTableCellFrame* aCellFrameToAdd,
    1:                                 PRInt32           aRowIndex,
79445:                                 bool&           aIsZeroRowSpan) const
    1: {
80486:   aIsZeroRowSpan = false;
    1:   PRInt32 rowSpan = aCellFrameToAdd->GetRowSpan();
    1:   if (0 == rowSpan) {
    1:     // Use a min value of 2 for a zero rowspan to make computations easier
    1:     // elsewhere. Zero rowspans are only content dependent!
32531:     rowSpan = NS_MAX(2, mContentRowCount - aRowIndex);
80486:     aIsZeroRowSpan = true;
    1:   }
    1:   return rowSpan;
    1: }
    1: 
79445: bool nsCellMap::HasMoreThanOneCell(PRInt32 aRowIndex) const
    1: {
    1:   const CellDataArray& row = mRows.SafeElementAt(aRowIndex, *sEmptyRow);
    1:   PRUint32 maxColIndex = row.Length();
    1:   PRUint32 count = 0;
    1:   PRUint32 colIndex;
    1:   for (colIndex = 0; colIndex < maxColIndex; colIndex++) {
    1:     CellData* cellData = row[colIndex];
    1:     if (cellData && (cellData->GetCellFrame() || cellData->IsRowSpan()))
    1:       count++;
    1:     if (count > 1)
80486:       return true;
80486:   }
80486:   return false;
    1: }
    1: 
    1: PRInt32
    1: nsCellMap::GetNumCellsOriginatingInRow(PRInt32 aRowIndex) const
    1: {
    1:   const CellDataArray& row = mRows.SafeElementAt(aRowIndex, *sEmptyRow);
    1:   PRUint32 count = 0;
    1:   PRUint32 maxColIndex = row.Length();
    1:   PRUint32 colIndex;
    1:   for (colIndex = 0; colIndex < maxColIndex; colIndex++) {
    1:     CellData* cellData = row[colIndex];
    1:     if (cellData && cellData->IsOrig())
    1:       count++;
    1:   }
    1:   return count;
    1: }
    1: 
    1: PRInt32 nsCellMap::GetRowSpan(PRInt32  aRowIndex,
    1:                               PRInt32  aColIndex,
79445:                               bool     aGetEffective) const
    1: {
    1:   PRInt32 rowSpan = 1;
    1:   PRInt32 rowCount = (aGetEffective) ? mContentRowCount : mRows.Length();
    1:   PRInt32 rowX;
    1:   for (rowX = aRowIndex + 1; rowX < rowCount; rowX++) {
    1:     CellData* data = GetDataAt(rowX, aColIndex);
    1:     if (data) {
    1:       if (data->IsRowSpan()) {
    1:         rowSpan++;
    1:       }
    1:       else {
    1:         break;
    1:       }
    1:     }
    1:     else break;
    1:   }
    1:   return rowSpan;
    1: }
    1: 
    1: void nsCellMap::ShrinkWithoutCell(nsTableCellMap&   aMap,
    1:                                   nsTableCellFrame& aCellFrame,
    1:                                   PRInt32           aRowIndex,
    1:                                   PRInt32           aColIndex,
82828:                                   PRInt32           aRgFirstRowIndex,
    1:                                   nsRect&           aDamageArea)
    1: {
    1:   NS_ASSERTION(!!aMap.mBCInfo == mIsBC, "BC state mismatch");
    1:   PRUint32 colX, rowX;
    1: 
    1:   // get the rowspan and colspan from the cell map since the content may have changed
79445:   bool zeroColSpan;
    1:   PRUint32 numCols = aMap.GetColCount();
80486:   PRInt32 rowSpan = GetRowSpan(aRowIndex, aColIndex, false);
    1:   PRUint32 colSpan = GetEffectiveColSpan(aMap, aRowIndex, aColIndex, zeroColSpan);
    1:   PRUint32 endRowIndex = aRowIndex + rowSpan - 1;
    1:   PRUint32 endColIndex = aColIndex + colSpan - 1;
    1: 
    1:   if (aMap.mTableFrame.HasZeroColSpans()) {
80486:     aMap.mTableFrame.SetNeedColSpanExpansion(true);
    1:   }
    1: 
    1:   // adjust the col counts due to the deleted cell before removing it
    1:   for (colX = aColIndex; colX <= endColIndex; colX++) {
    1:     nsColInfo* colInfo = aMap.GetColInfoAt(colX);
    1:     if (colX == PRUint32(aColIndex)) {
    1:       colInfo->mNumCellsOrig--;
    1:     }
    1:     else  {
    1:       colInfo->mNumCellsSpan--;
    1:     }
    1:   }
    1: 
    1:   // remove the deleted cell and cellData entries for it
    1:   for (rowX = aRowIndex; rowX <= endRowIndex; rowX++) {
    1:     CellDataArray& row = mRows[rowX];
    1: 
    1:     // endIndexForRow points at the first slot we don't want to clean up.  This
    1:     // makes the aColIndex == 0 case work right with our unsigned int colX.
    1:     NS_ASSERTION(endColIndex + 1 <= row.Length(), "span beyond the row size!");
32531:     PRUint32 endIndexForRow = NS_MIN(endColIndex + 1, row.Length());
    1: 
    1:     // Since endIndexForRow <= row.Length(), enough to compare aColIndex to it.
    1:     if (PRUint32(aColIndex) < endIndexForRow) {
    1:       for (colX = endIndexForRow; colX > PRUint32(aColIndex); colX--) {
    1:         DestroyCellData(row[colX-1]);
    1:       }
    1:       row.RemoveElementsAt(aColIndex, endIndexForRow - aColIndex);
    1:     }
    1:   }
    1: 
    1:   numCols = aMap.GetColCount();
    1: 
    1:   // update the row and col info due to shifting
    1:   for (rowX = aRowIndex; rowX <= endRowIndex; rowX++) {
    1:     CellDataArray& row = mRows[rowX];
    1:     for (colX = aColIndex; colX < numCols - colSpan; colX++) {
    1:       CellData* data = row.SafeElementAt(colX);
    1:       if (data) {
    1:         if (data->IsOrig()) {
    1:           // a cell that gets moved to the left needs adjustment in its new location
    1:           data->GetCellFrame()->SetColIndex(colX);
    1:           nsColInfo* colInfo = aMap.GetColInfoAt(colX);
    1:           colInfo->mNumCellsOrig++;
    1:           // a cell that gets moved to the left needs adjustment in its old location
    1:           colInfo = aMap.GetColInfoAt(colX + colSpan);
    1:           if (colInfo) {
    1:             colInfo->mNumCellsOrig--;
    1:           }
    1:         }
    1: 
    1:         else if (data->IsColSpan()) {
    1:           // a cell that gets moved to the left needs adjustment
    1:           // in its new location
    1:           nsColInfo* colInfo = aMap.GetColInfoAt(colX);
    1:           colInfo->mNumCellsSpan++;
    1:           // a cell that gets moved to the left needs adjustment
    1:           // in its old location
    1:           colInfo = aMap.GetColInfoAt(colX + colSpan);
    1:           if (colInfo) {
    1:             colInfo->mNumCellsSpan--;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1:   aMap.RemoveColsAtEnd();
83209:   SetDamageArea(aColIndex, aRgFirstRowIndex + aRowIndex,
83209:                 NS_MAX(0, aMap.GetColCount() - aColIndex - 1),
83209:                 1 + endRowIndex - aRowIndex, aDamageArea);
    1: }
    1: 
    1: void
    1: nsCellMap::RebuildConsideringRows(nsTableCellMap&             aMap,
    1:                                   PRInt32                     aStartRowIndex,
24724:                                   nsTArray<nsTableRowFrame*>* aRowsToInsert,
82828:                                   PRInt32                     aNumRowsToRemove)
    1: {
    1:   NS_ASSERTION(!!aMap.mBCInfo == mIsBC, "BC state mismatch");
    1:   // copy the old cell map into a new array
    1:   PRUint32 numOrigRows = mRows.Length();
    1:   nsTArray<CellDataArray> origRows;
    1:   mRows.SwapElements(origRows);
    1: 
    1:   PRInt32 rowNumberChange;
    1:   if (aRowsToInsert) {
24724:     rowNumberChange = aRowsToInsert->Length();
    1:   } else {
    1:     rowNumberChange = -aNumRowsToRemove;
    1:   }
    1: 
    1:   // adjust mContentRowCount based on the function arguments as they are known to
    1:   // be real rows.
    1:   mContentRowCount += rowNumberChange;
    1:   NS_ASSERTION(mContentRowCount >= 0, "previous mContentRowCount was wrong");
    1:   // mRows is empty now.  Grow it to the size we expect it to have.
    1:   if (mContentRowCount) {
    1:     if (!Grow(aMap, mContentRowCount)) {
    1:       // Bail, I guess...  Not sure what else we can do here.
    1:       return;
    1:     }
    1:   }
    1: 
    1:   // aStartRowIndex might be after all existing rows so we should limit the
    1:   // copy to the amount of exisiting rows
32531:   PRUint32 copyEndRowIndex = NS_MIN(numOrigRows, PRUint32(aStartRowIndex));
    1: 
    1:   // rowX keeps track of where we are in mRows while setting up the
    1:   // new cellmap.
    1:   PRUint32 rowX = 0;
82828:   nsRect damageArea;
    1:   // put back the rows before the affected ones just as before.  Note that we
    1:   // can't just copy the old rows in bit-for-bit, because they might be
    1:   // spanning out into the rows we're adding/removing.
    1:   for ( ; rowX < copyEndRowIndex; rowX++) {
    1:     const CellDataArray& row = origRows[rowX];
    1:     PRUint32 numCols = row.Length();
    1:     for (PRUint32 colX = 0; colX < numCols; colX++) {
    1:       // put in the original cell from the cell map
    1:       const CellData* data = row.ElementAt(colX);
    1:       if (data && data->IsOrig()) {
82828:         AppendCell(aMap, data->GetCellFrame(), rowX, false, 0, damageArea);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Now handle the new rows being inserted, if any.
    1:   PRUint32 copyStartRowIndex;
    1:   rowX = aStartRowIndex;
    1:   if (aRowsToInsert) {
    1:     // add in the new cells and create rows if necessary
24724:     PRInt32 numNewRows = aRowsToInsert->Length();
    1:     for (PRInt32 newRowX = 0; newRowX < numNewRows; newRowX++) {
24724:       nsTableRowFrame* rFrame = aRowsToInsert->ElementAt(newRowX);
77154:       nsIFrame* cFrame = rFrame->GetFirstPrincipalChild();
    1:       while (cFrame) {
26583:         nsTableCellFrame *cellFrame = do_QueryFrame(cFrame);
26583:         if (cellFrame) {
82828:           AppendCell(aMap, cellFrame, rowX, false, 0, damageArea);
    1:         }
    1:         cFrame = cFrame->GetNextSibling();
    1:       }
    1:       rowX++;
    1:     }
    1:     copyStartRowIndex = aStartRowIndex;
    1:   }
    1:   else {
    1:     copyStartRowIndex = aStartRowIndex + aNumRowsToRemove;
    1:   }
    1: 
    1:   // put back the rows after the affected ones just as before.  Again, we can't
    1:   // just copy the old bits because that would not handle the new rows spanning
    1:   // out or our earlier old rows spanning through the damaged area.
    1:   for (PRUint32 copyRowX = copyStartRowIndex; copyRowX < numOrigRows;
    1:        copyRowX++) {
    1:     const CellDataArray& row = origRows[copyRowX];
    1:     PRUint32 numCols = row.Length();
    1:     for (PRUint32 colX = 0; colX < numCols; colX++) {
    1:       // put in the original cell from the cell map
    1:       CellData* data = row.ElementAt(colX);
    1:       if (data && data->IsOrig()) {
82828:         AppendCell(aMap, data->GetCellFrame(), rowX, false, 0, damageArea);
    1:       }
    1:     }
    1:     rowX++;
    1:   }
    1: 
    1:   // delete the old cell map.  Now rowX no longer has anything to do with mRows
    1:   for (rowX = 0; rowX < numOrigRows; rowX++) {
    1:     CellDataArray& row = origRows[rowX];
    1:     PRUint32 len = row.Length();
    1:     for (PRUint32 colX = 0; colX < len; colX++) {
    1:       DestroyCellData(row[colX]);
    1:     }
    1:   }
    1: }
    1: 
24724: void
24724: nsCellMap::RebuildConsideringCells(nsTableCellMap&              aMap,
    1:                                    PRInt32                      aNumOrigCols,
24724:                                    nsTArray<nsTableCellFrame*>* aCellFrames,
    1:                                    PRInt32                      aRowIndex,
    1:                                    PRInt32                      aColIndex,
82828:                                    bool                         aInsert)
    1: {
    1:   NS_ASSERTION(!!aMap.mBCInfo == mIsBC, "BC state mismatch");
    1:   // copy the old cell map into a new array
24724:   PRInt32 numOrigRows  = mRows.Length();
    1:   nsTArray<CellDataArray> origRows;
    1:   mRows.SwapElements(origRows);
    1: 
24724:   PRInt32 numNewCells = (aCellFrames) ? aCellFrames->Length() : 0;
    1: 
    1:   // the new cells might extend the previous column number
    1:   NS_ASSERTION(aNumOrigCols >= aColIndex, "Appending cells far beyond cellmap data?!");
32531:   PRInt32 numCols = aInsert ? NS_MAX(aNumOrigCols, aColIndex + 1) : aNumOrigCols;
    1: 
    1:   // build the new cell map.  Hard to say what, if anything, we can preallocate
    1:   // here...  Should come back to that sometime, perhaps.
24724:   PRInt32 rowX;
82828:   nsRect damageArea;
    1:   for (rowX = 0; rowX < numOrigRows; rowX++) {
    1:     const CellDataArray& row = origRows[rowX];
    1:     for (PRInt32 colX = 0; colX < numCols; colX++) {
    1:       if ((rowX == aRowIndex) && (colX == aColIndex)) {
    1:         if (aInsert) { // put in the new cells
    1:           for (PRInt32 cellX = 0; cellX < numNewCells; cellX++) {
24724:             nsTableCellFrame* cell = aCellFrames->ElementAt(cellX);
    1:             if (cell) {
82828:               AppendCell(aMap, cell, rowX, false, 0, damageArea);
    1:             }
    1:           }
    1:         }
    1:         else {
    1:           continue; // do not put the deleted cell back
    1:         }
    1:       }
    1:       // put in the original cell from the cell map
    1:       CellData* data = row.SafeElementAt(colX);
    1:       if (data && data->IsOrig()) {
82828:         AppendCell(aMap, data->GetCellFrame(), rowX, false, 0, damageArea);
    1:       }
    1:     }
    1:   }
    1:   if (aInsert && numOrigRows <= aRowIndex) { // append the new cells below the last original row
    1:     NS_ASSERTION (numOrigRows == aRowIndex, "Appending cells far beyond the last row");
    1:     for (PRInt32 cellX = 0; cellX < numNewCells; cellX++) {
24724:       nsTableCellFrame* cell = aCellFrames->ElementAt(cellX);
    1:       if (cell) {
82828:         AppendCell(aMap, cell, aRowIndex, false, 0, damageArea);
    1:       }
    1:     }
    1:   }
    1: 
    1:   // delete the old cell map
    1:   for (rowX = 0; rowX < numOrigRows; rowX++) {
    1:     CellDataArray& row = origRows[rowX];
    1:     PRUint32 len = row.Length();
    1:     for (PRUint32 colX = 0; colX < len; colX++) {
    1:       DestroyCellData(row.SafeElementAt(colX));
    1:     }
    1:   }
11996:   // expand the cellmap to cover empty content rows
24724:   if (mRows.Length() < PRUint32(mContentRowCount)) {
11996:     Grow(aMap, mContentRowCount - mRows.Length());
11996:   }
11996: 
    1: }
    1: 
    1: void nsCellMap::RemoveCell(nsTableCellMap&   aMap,
    1:                            nsTableCellFrame* aCellFrame,
    1:                            PRInt32           aRowIndex,
82828:                            PRInt32           aRgFirstRowIndex,
    1:                            nsRect&           aDamageArea)
    1: {
    1:   PRUint32 numRows = mRows.Length();
    1:   if (PRUint32(aRowIndex) >= numRows) {
    1:     NS_ERROR("bad arg in nsCellMap::RemoveCell");
    1:     return;
    1:   }
    1:   PRInt32 numCols = aMap.GetColCount();
    1: 
    1:   // Now aRowIndex is guaranteed OK.
    1: 
    1:   // get the starting col index of the cell to remove
    1:   PRInt32 startColIndex;
    1:   for (startColIndex = 0; startColIndex < numCols; startColIndex++) {
    1:     CellData* data = mRows[aRowIndex].SafeElementAt(startColIndex);
    1:     if (data && (data->IsOrig()) && (aCellFrame == data->GetCellFrame())) {
    1:       break; // we found the col index
    1:     }
    1:   }
    1: 
80486:   PRInt32 rowSpan = GetRowSpan(aRowIndex, startColIndex, false);
    1:   // record whether removing the cells is going to cause complications due
    1:   // to existing row spans, col spans or table sizing.
79445:   bool spansCauseRebuild = CellsSpanInOrOut(aRowIndex,
    1:                                               aRowIndex + rowSpan - 1,
    1:                                               startColIndex, numCols - 1);
    1:   // XXX if the cell has a col span to the end of the map, and the end has no originating
    1:   // cells, we need to assume that this the only such cell, and rebuild so that there are
    1:   // no extraneous cols at the end. The same is true for removing rows.
    1:   if (!aCellFrame->GetRowSpan() || !aCellFrame->GetColSpan())
80486:     spansCauseRebuild = true;
    1: 
    1:   if (spansCauseRebuild) {
82828:     aMap.RebuildConsideringCells(this, nsnull, aRowIndex, startColIndex, false,
82828:                                  aDamageArea);
    1:   }
    1:   else {
82828:     ShrinkWithoutCell(aMap, *aCellFrame, aRowIndex, startColIndex,
82828:                       aRgFirstRowIndex, aDamageArea);
    1:   }
    1: }
    1: 
    1: void nsCellMap::ExpandZeroColSpans(nsTableCellMap& aMap)
    1: {
    1:   NS_ASSERTION(!!aMap.mBCInfo == mIsBC, "BC state mismatch");
    1:   PRUint32 numRows = mRows.Length();
    1:   PRUint32 numCols = aMap.GetColCount();
    1:   PRUint32 rowIndex, colIndex;
    1: 
    1:   for (rowIndex = 0; rowIndex < numRows; rowIndex++) {
    1:     for (colIndex = 0; colIndex < numCols; colIndex++) {
    1:       CellData* data = mRows[rowIndex].SafeElementAt(colIndex);
    1:       if (!data || !data->IsOrig())
    1:         continue;
    1:       nsTableCellFrame* cell = data->GetCellFrame();
    1:       NS_ASSERTION(cell, "There has to be a cell");
    1:       PRInt32 cellRowSpan = cell->GetRowSpan();
    1:       PRInt32 cellColSpan = cell->GetColSpan();
79445:       bool rowZeroSpan = (0 == cell->GetRowSpan());
79445:       bool colZeroSpan = (0 == cell->GetColSpan());
    1:       if (colZeroSpan) {
80486:         aMap.mTableFrame.SetHasZeroColSpans(true);
    1:         // do the expansion
    1:         NS_ASSERTION(numRows > 0, "Bogus numRows");
    1:         NS_ASSERTION(numCols > 0, "Bogus numCols");
    1:         PRUint32 endRowIndex =  rowZeroSpan ? numRows - 1 :
    1:                                               rowIndex + cellRowSpan - 1;
    1:         PRUint32 endColIndex =  colZeroSpan ? numCols - 1 :
    1:                                               colIndex + cellColSpan - 1;
    1:         PRUint32 colX, rowX;
    1:         colX = colIndex + 1;
    1:         while (colX <= endColIndex) {
    1:           // look at columns from here to our colspan.  For each one, check
    1:           // the rows from here to our rowspan to make sure there is no
    1:           // obstacle to marking that column as a zerospanned column; if there
    1:           // isn't, mark it so
    1:           for (rowX = rowIndex; rowX <= endRowIndex; rowX++) {
    1:             CellData* oldData = GetDataAt(rowX, colX);
    1:             if (oldData) {
    1:               if (oldData->IsOrig()) {
    1:                 break; // something is in the way
    1:               }
    1:               if (oldData->IsRowSpan()) {
    1:                 if ((rowX - rowIndex) != oldData->GetRowSpanOffset()) {
    1:                   break;
    1:                 }
    1:               }
    1:               if (oldData->IsColSpan()) {
    1:                 if ((colX - colIndex) != oldData->GetColSpanOffset()) {
    1:                   break;
    1:                 }
    1:               }
    1:             }
    1:           }
    1:           if (endRowIndex >= rowX)
    1:             break;// we hit something
    1:           for (rowX = rowIndex; rowX <= endRowIndex; rowX++) {
    1:             CellData* newData = AllocCellData(nsnull);
    1:             if (!newData) return;
    1: 
    1:             newData->SetColSpanOffset(colX - colIndex);
80486:             newData->SetZeroColSpan(true);
    1: 
    1:             if (rowX > rowIndex) {
    1:               newData->SetRowSpanOffset(rowX - rowIndex);
    1:               if (rowZeroSpan)
80486:                 newData->SetZeroRowSpan(true);
    1:             }
    1:             SetDataAt(aMap, *newData, rowX, colX);
    1:           }
    1:           colX++;
    1:         }  // while (colX <= endColIndex)
    1:       } // if zerocolspan
    1:     }
    1:   }
    1: }
    1: #ifdef NS_DEBUG
79445: void nsCellMap::Dump(bool aIsBorderCollapse) const
    1: {
    1:   printf("\n  ***** START GROUP CELL MAP DUMP ***** %p\n", (void*)this);
    1:   nsTableRowGroupFrame* rg = GetRowGroup();
    1:   const nsStyleDisplay* display = rg->GetStyleDisplay();
    1:   switch (display->mDisplay) {
    1:   case NS_STYLE_DISPLAY_TABLE_HEADER_GROUP:
    1:     printf("  thead ");
    1:     break;
    1:   case NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP:
    1:     printf("  tfoot ");
    1:     break;
    1:   case NS_STYLE_DISPLAY_TABLE_ROW_GROUP:
    1:     printf("  tbody ");
    1:     break;
    1:   default:
    1:     printf("HUH? wrong display type on rowgroup");
    1:   }
    1:   PRUint32 mapRowCount = mRows.Length();
    1:   printf("mapRowCount=%u tableRowCount=%d\n", mapRowCount, mContentRowCount);
    1: 
    1: 
    1:   PRUint32 rowIndex, colIndex;
    1:   for (rowIndex = 0; rowIndex < mapRowCount; rowIndex++) {
    1:     const CellDataArray& row = mRows[rowIndex];
    1:     printf("  row %d : ", rowIndex);
    1:     PRUint32 colCount = row.Length();
    1:     for (colIndex = 0; colIndex < colCount; colIndex++) {
    1:       CellData* cd = row[colIndex];
    1:       if (cd) {
    1:         if (cd->IsOrig()) {
    1:           printf("C%d,%d  ", rowIndex, colIndex);
    1:         } else {
    1:           nsTableCellFrame* cell = nsnull;
    1:           if (cd->IsRowSpan()) {
80486:             cell = GetCellFrame(rowIndex, colIndex, *cd, true);
    1:             printf("R ");
    1:           }
    1:           if (cd->IsColSpan()) {
80486:             cell = GetCellFrame(rowIndex, colIndex, *cd, false);
    1:             printf("C ");
    1:           }
    1:           if (!(cd->IsRowSpan() && cd->IsColSpan())) {
    1:             printf("  ");
    1:           }
    1:           printf("  ");
    1:         }
    1:       } else {
    1:         printf("----  ");
    1:       }
    1:     }
    1:     if (aIsBorderCollapse) {
    1:       nscoord       size;
    1:       BCBorderOwner owner;
41419:       mozilla::css::Side side;
79445:       bool          segStart;
79445:       bool          bevel;
    1:       for (PRInt32 i = 0; i <= 2; i++) {
    1:         printf("\n          ");
    1:         for (colIndex = 0; colIndex < colCount; colIndex++) {
    1:           BCCellData* cd = (BCCellData *)row[colIndex];
    1:           if (cd) {
    1:             if (0 == i) {
    1:               size = cd->mData.GetTopEdge(owner, segStart);
    1:               printf("t=%d%d%d ", size, owner, segStart);
    1:             }
    1:             else if (1 == i) {
    1:               size = cd->mData.GetLeftEdge(owner, segStart);
    1:               printf("l=%d%d%d ", size, owner, segStart);
    1:             }
    1:             else {
    1:               size = cd->mData.GetCorner(side, bevel);
    1:               printf("c=%d%d%d ", size, side, bevel);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:     printf("\n");
    1:   }
    1: 
    1:   // output info mapping Ci,j to cell address
    1:   PRUint32 cellCount = 0;
    1:   for (PRUint32 rIndex = 0; rIndex < mapRowCount; rIndex++) {
    1:     const CellDataArray& row = mRows[rIndex];
    1:     PRUint32 colCount = row.Length();
    1:     printf("  ");
    1:     for (colIndex = 0; colIndex < colCount; colIndex++) {
    1:       CellData* cd = row[colIndex];
    1:       if (cd) {
    1:         if (cd->IsOrig()) {
    1:           nsTableCellFrame* cellFrame = cd->GetCellFrame();
    1:           PRInt32 cellFrameColIndex;
    1:           cellFrame->GetColIndex(cellFrameColIndex);
    1:           printf("C%d,%d=%p(%d)  ", rIndex, colIndex, (void*)cellFrame,
    1:                  cellFrameColIndex);
    1:           cellCount++;
    1:         }
    1:       }
    1:     }
    1:     printf("\n");
    1:   }
    1: 
    1:   printf("  ***** END GROUP CELL MAP DUMP *****\n");
    1: }
    1: #endif
    1: 
    1: CellData*
    1: nsCellMap::GetDataAt(PRInt32         aMapRowIndex,
    1:                      PRInt32         aColIndex) const
    1: {
    1:   return
    1:     mRows.SafeElementAt(aMapRowIndex, *sEmptyRow).SafeElementAt(aColIndex);
    1: }
    1: 
    1: // only called if the cell at aMapRowIndex, aColIndex is null or dead
    1: // (the latter from ExpandZeroColSpans).
    1: void nsCellMap::SetDataAt(nsTableCellMap& aMap,
    1:                           CellData&       aNewCell,
    1:                           PRInt32         aMapRowIndex,
    1:                           PRInt32         aColIndex)
    1: {
    1:   NS_ASSERTION(!!aMap.mBCInfo == mIsBC, "BC state mismatch");
    1:   if (PRUint32(aMapRowIndex) >= mRows.Length()) {
    1:     NS_ERROR("SetDataAt called with row index > num rows");
    1:     return;
    1:   }
    1: 
    1:   CellDataArray& row = mRows[aMapRowIndex];
    1: 
    1:   // the table map may need cols added
    1:   PRInt32 numColsToAdd = aColIndex + 1 - aMap.GetColCount();
    1:   if (numColsToAdd > 0) {
    1:     aMap.AddColsAtEnd(numColsToAdd);
    1:   }
    1:   // the row may need cols added
    1:   numColsToAdd = aColIndex + 1 - row.Length();
    1:   if (numColsToAdd > 0) {
    1:     // XXXbz need to handle allocation failures.
    1:     GrowRow(row, numColsToAdd);
    1:   }
    1: 
    1:   DestroyCellData(row[aColIndex]);
    1: 
    1:   row.ReplaceElementsAt(aColIndex, 1, &aNewCell);
    1:   // update the originating cell counts if cell originates in this row, col
    1:   nsColInfo* colInfo = aMap.GetColInfoAt(aColIndex);
    1:   if (colInfo) {
    1:     if (aNewCell.IsOrig()) {
    1:       colInfo->mNumCellsOrig++;
    1:     }
    1:     else if (aNewCell.IsColSpan()) {
    1:       colInfo->mNumCellsSpan++;
    1:     }
    1:   }
    1:   else NS_ERROR("SetDataAt called with col index > table map num cols");
    1: }
    1: 
    1: nsTableCellFrame*
    1: nsCellMap::GetCellInfoAt(const nsTableCellMap& aMap,
    1:                          PRInt32               aRowX,
    1:                          PRInt32               aColX,
79445:                          bool*               aOriginates,
    1:                          PRInt32*              aColSpan) const
    1: {
    1:   if (aOriginates) {
80486:     *aOriginates = false;
    1:   }
    1:   CellData* data = GetDataAt(aRowX, aColX);
    1:   nsTableCellFrame* cellFrame = nsnull;
    1:   if (data) {
    1:     if (data->IsOrig()) {
    1:       cellFrame = data->GetCellFrame();
    1:       if (aOriginates)
80486:         *aOriginates = true;
    1:     }
    1:     else {
80486:       cellFrame = GetCellFrame(aRowX, aColX, *data, true);
    1:     }
    1:     if (cellFrame && aColSpan) {
    1:       PRInt32 initialColIndex;
    1:       cellFrame->GetColIndex(initialColIndex);
79445:       bool zeroSpan;
    1:       *aColSpan = GetEffectiveColSpan(aMap, aRowX, initialColIndex, zeroSpan);
    1:     }
    1:   }
    1:   return cellFrame;
    1: }
    1: 
    1: 
79445: bool nsCellMap::RowIsSpannedInto(PRInt32         aRowIndex,
    1:                                    PRInt32         aNumEffCols) const
    1: {
    1:   if ((0 > aRowIndex) || (aRowIndex >= mContentRowCount)) {
80486:     return false;
    1:   }
    1:   for (PRInt32 colIndex = 0; colIndex < aNumEffCols; colIndex++) {
    1:     CellData* cd = GetDataAt(aRowIndex, colIndex);
    1:     if (cd) { // there's really a cell at (aRowIndex, colIndex)
    1:       if (cd->IsSpan()) { // the cell at (aRowIndex, colIndex) is the result of a span
80486:         if (cd->IsRowSpan() && GetCellFrame(aRowIndex, colIndex, *cd, true)) { // XXX why the last check
80486:           return true;
80486:         }
80486:       }
80486:     }
80486:   }
80486:   return false;
    1: }
    1: 
79445: bool nsCellMap::RowHasSpanningCells(PRInt32 aRowIndex,
    1:                                       PRInt32 aNumEffCols) const
    1: {
    1:   if ((0 > aRowIndex) || (aRowIndex >= mContentRowCount)) {
80486:     return false;
    1:   }
    1:   if (aRowIndex != mContentRowCount - 1) {
    1:     // aRowIndex is not the last row, so we check the next row after aRowIndex for spanners
    1:     for (PRInt32 colIndex = 0; colIndex < aNumEffCols; colIndex++) {
    1:       CellData* cd = GetDataAt(aRowIndex, colIndex);
    1:       if (cd && (cd->IsOrig())) { // cell originates
    1:         CellData* cd2 = GetDataAt(aRowIndex + 1, colIndex);
    1:         if (cd2 && cd2->IsRowSpan()) { // cd2 is spanned by a row
80486:           if (cd->GetCellFrame() == GetCellFrame(aRowIndex + 1, colIndex, *cd2, true)) {
80486:             return true;
80486:           }
80486:         }
80486:       }
80486:     }
80486:   }
80486:   return false;
    1: }
    1: 
    1: void nsCellMap::DestroyCellData(CellData* aData)
    1: {
    1:   if (!aData) {
    1:     return;
    1:   }
    1: 
    1:   if (mIsBC) {
 3233:     BCCellData* bcData = static_cast<BCCellData*>(aData);
    1:     bcData->~BCCellData();
    1:     mPresContext->FreeToShell(sizeof(BCCellData), bcData);
    1:   } else {
    1:     aData->~CellData();
    1:     mPresContext->FreeToShell(sizeof(CellData), aData);
    1:   }
    1: }
    1: 
    1: CellData* nsCellMap::AllocCellData(nsTableCellFrame* aOrigCell)
    1: {
    1:   if (mIsBC) {
    1:     BCCellData* data = (BCCellData*)
    1:       mPresContext->AllocateFromShell(sizeof(BCCellData));
    1:     if (data) {
    1:       new (data) BCCellData(aOrigCell);
    1:     }
    1:     return data;
    1:   }
    1: 
    1:   CellData* data = (CellData*)
    1:     mPresContext->AllocateFromShell(sizeof(CellData));
    1:   if (data) {
    1:     new (data) CellData(aOrigCell);
    1:   }
    1:   return data;
    1: }
    1: 
    1: void
    1: nsCellMapColumnIterator::AdvanceRowGroup()
    1: {
    1:   do {
    1:     mCurMapStart += mCurMapContentRowCount;
    1:     mCurMap = mCurMap->GetNextSibling();
    1:     if (!mCurMap) {
    1:       // Set mCurMapContentRowCount and mCurMapRelevantRowCount to 0 in case
    1:       // mCurMap has no next sibling.  This can happen if we just handled the
    1:       // last originating cell.  Future calls will end up with mFoundCells ==
    1:       // mOrigCells, but for this one mFoundCells was definitely not big enough
    1:       // if we got here.
    1:       mCurMapContentRowCount = 0;
    1:       mCurMapRelevantRowCount = 0;
    1:       break;
    1:     }
    1: 
    1:     mCurMapContentRowCount = mCurMap->GetRowCount();
    1:     PRUint32 rowArrayLength = mCurMap->mRows.Length();
32531:     mCurMapRelevantRowCount = NS_MIN(mCurMapContentRowCount, rowArrayLength);
    1:   } while (0 == mCurMapRelevantRowCount);
    1: 
    1:   NS_ASSERTION(mCurMapRelevantRowCount != 0 || !mCurMap,
    1:                "How did that happen?");
    1: 
    1:   // Set mCurMapRow to 0, since cells can't span across table row groups.
    1:   mCurMapRow = 0;
    1: }
    1: 
    1: void
    1: nsCellMapColumnIterator::IncrementRow(PRInt32 aIncrement)
    1: {
    1:   NS_PRECONDITION(aIncrement >= 0, "Bogus increment");
    1:   NS_PRECONDITION(mCurMap, "Bogus mOrigCells?");
    1:   if (aIncrement == 0) {
    1:     AdvanceRowGroup();
    1:   }
    1:   else {
    1:     mCurMapRow += aIncrement;
    1:     if (mCurMapRow >= mCurMapRelevantRowCount) {
    1:       AdvanceRowGroup();
    1:     }
    1:   }
    1: }
    1: 
    1: nsTableCellFrame*
    1: nsCellMapColumnIterator::GetNextFrame(PRInt32* aRow, PRInt32* aColSpan)
    1: {
    1:   // Fast-path for the case when we don't have anything left in the column and
    1:   // we know it.
    1:   if (mFoundCells == mOrigCells) {
    1:     *aRow = 0;
    1:     *aColSpan = 1;
    1:     return nsnull;
    1:   }
    1: 
    1:   while (1) {
    1:     NS_ASSERTION(mCurMapRow < mCurMapRelevantRowCount, "Bogus mOrigCells?");
    1:     // Safe to just get the row (which is faster than calling GetDataAt(), but
    1:     // there may not be that many cells in it, so have to use SafeElementAt for
    1:     // the mCol.
    1:     const nsCellMap::CellDataArray& row = mCurMap->mRows[mCurMapRow];
    1:     CellData* cellData = row.SafeElementAt(mCol);
    1:     if (!cellData || cellData->IsDead()) {
    1:       // Could hit this if there are fewer cells in this row than others, for
    1:       // example.
    1:       IncrementRow(1);
    1:       continue;
    1:     }
    1: 
    1:     if (cellData->IsColSpan()) {
    1:       // Look up the originating data for this cell, advance by its relative rowspan.
    1:       PRInt32 rowspanOffset = cellData->GetRowSpanOffset();
80486:       nsTableCellFrame* cellFrame = mCurMap->GetCellFrame(mCurMapRow, mCol, *cellData, false);
    1:       NS_ASSERTION(cellFrame,"Must have usable originating data here");
    1:       PRInt32 rowSpan = cellFrame->GetRowSpan();
    1:       if (rowSpan == 0) {
    1:         AdvanceRowGroup();
    1:       }
    1:       else {
    1:         IncrementRow(rowSpan - rowspanOffset);
    1:       }
    1:       continue;
    1:     }
    1: 
    1:     NS_ASSERTION(cellData->IsOrig(),
    1:                  "Must have originating cellData by this point.  "
    1:                  "See comment on mCurMapRow in header.");
    1: 
    1:     nsTableCellFrame* cellFrame = cellData->GetCellFrame();
    1:     NS_ASSERTION(cellFrame, "Orig data without cellframe?");
    1: 
    1:     *aRow = mCurMapStart + mCurMapRow;
79445:     bool ignoredZeroSpan;
    1:     *aColSpan = mCurMap->GetEffectiveColSpan(*mMap, mCurMapRow, mCol,
    1:                                              ignoredZeroSpan);
    1: 
    1:     IncrementRow(cellFrame->GetRowSpan());
    1: 
    1:     ++mFoundCells;
    1: 
72952:     NS_ABORT_IF_FALSE(cellData == mMap->GetDataAt(*aRow, mCol),
    1:                       "Giving caller bogus row?");
    1: 
    1:     return cellFrame;
    1:   }
    1: 
    1:   NS_NOTREACHED("Can't get here");
    1:   return nsnull;
    1: }
