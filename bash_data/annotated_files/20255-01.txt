    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set sw=4 ts=8 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS lexical scanner.
    1:  */
    1: #include "jsstddef.h"
    1: #include <stdio.h>      /* first to avoid trouble on some systems */
    1: #include <errno.h>
    1: #include <limits.h>
    1: #include <math.h>
    1: #ifdef HAVE_MEMORY_H
    1: #include <memory.h>
    1: #endif
    1: #include <stdarg.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsdtoa.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsemit.h"
    1: #include "jsexn.h"
    1: #include "jsnum.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsregexp.h"
    1: #include "jsscan.h"
    1: #include "jsscript.h"
18989: #include "jsstaticcheck.h"
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #define JS_KEYWORD(keyword, type, op, version) \
    1:     const char js_##keyword##_str[] = #keyword;
    1: #include "jskeyword.tbl"
    1: #undef JS_KEYWORD
    1: 
    1: struct keyword {
    1:     const char  *chars;         /* C string with keyword text */
    1:     JSTokenType tokentype;      /* JSTokenType */
    1:     JSOp        op;             /* JSOp */
    1:     JSVersion   version;        /* JSVersion */
    1: };
    1: 
    1: static const struct keyword keyword_defs[] = {
    1: #define JS_KEYWORD(keyword, type, op, version) \
    1:     {js_##keyword##_str, type, op, version},
    1: #include "jskeyword.tbl"
    1: #undef JS_KEYWORD
    1: };
    1: 
 8336: #define KEYWORD_COUNT JS_ARRAY_LENGTH(keyword_defs)
    1: 
    1: static const struct keyword *
    1: FindKeyword(const jschar *s, size_t length)
    1: {
    1:     register size_t i;
    1:     const struct keyword *kw;
    1:     const char *chars;
    1: 
    1:     JS_ASSERT(length != 0);
    1: 
    1: #define JSKW_LENGTH()           length
    1: #define JSKW_AT(column)         s[column]
    1: #define JSKW_GOT_MATCH(index)   i = (index); goto got_match;
    1: #define JSKW_TEST_GUESS(index)  i = (index); goto test_guess;
    1: #define JSKW_NO_MATCH()         goto no_match;
    1: #include "jsautokw.h"
    1: #undef JSKW_NO_MATCH
    1: #undef JSKW_TEST_GUESS
    1: #undef JSKW_GOT_MATCH
    1: #undef JSKW_AT
    1: #undef JSKW_LENGTH
    1: 
    1:   got_match:
    1:     return &keyword_defs[i];
    1: 
    1:   test_guess:
    1:     kw = &keyword_defs[i];
    1:     chars = kw->chars;
    1:     do {
    1:         if (*s++ != (unsigned char)(*chars++))
    1:             goto no_match;
    1:     } while (--length != 0);
    1:     return kw;
    1: 
    1:   no_match:
    1:     return NULL;
    1: }
    1: 
    1: JSTokenType
    1: js_CheckKeyword(const jschar *str, size_t length)
    1: {
    1:     const struct keyword *kw;
    1: 
    1:     JS_ASSERT(length != 0);
    1:     kw = FindKeyword(str, length);
    1:     return kw ? kw->tokentype : TOK_EOF;
    1: }
    1: 
    1: JS_FRIEND_API(void)
    1: js_MapKeywords(void (*mapfun)(const char *))
    1: {
    1:     size_t i;
    1: 
    1:     for (i = 0; i != KEYWORD_COUNT; ++i)
    1:         mapfun(keyword_defs[i].chars);
    1: }
    1: 
   53: JSBool
   53: js_IsIdentifier(JSString *str)
   53: {
   53:     size_t length;
   53:     jschar c, *chars, *end;
   53: 
 4718:     JSSTRING_CHARS_AND_LENGTH(str, chars, length);
   53:     if (length == 0)
   53:         return JS_FALSE;
   53:     c = *chars;
   53:     if (!JS_ISIDSTART(c))
   53:         return JS_FALSE;
   53:     end = chars + length;
   53:     while (++chars != end) {
   53:         c = *chars;
   53:         if (!JS_ISIDENT(c))
   53:             return JS_FALSE;
   53:     }
   53:     return JS_TRUE;
   53: }
   53: 
    1: #define TBMIN   64
    1: 
    1: static JSBool
    1: GrowTokenBuf(JSStringBuffer *sb, size_t newlength)
    1: {
    1:     JSContext *cx;
    1:     jschar *base;
    1:     ptrdiff_t offset, length;
    1:     size_t tbsize;
    1:     JSArenaPool *pool;
    1: 
 3164:     cx = (JSContext*) sb->data;
    1:     base = sb->base;
    1:     offset = PTRDIFF(sb->ptr, base, jschar);
    1:     pool = &cx->tempPool;
    1:     if (!base) {
    1:         tbsize = TBMIN * sizeof(jschar);
    1:         length = TBMIN - 1;
    1:         JS_ARENA_ALLOCATE_CAST(base, jschar *, pool, tbsize);
    1:     } else {
    1:         length = PTRDIFF(sb->limit, base, jschar);
    1:         if ((size_t)length >= ~(size_t)0 / sizeof(jschar)) {
    1:             base = NULL;
    1:         } else {
    1:             tbsize = (length + 1) * sizeof(jschar);
    1:             length += length + 1;
    1:             JS_ARENA_GROW_CAST(base, jschar *, pool, tbsize, tbsize);
    1:         }
    1:     }
    1:     if (!base) {
 8296:         js_ReportOutOfScriptQuota(cx);
    1:         sb->base = STRING_BUFFER_ERROR_BASE;
    1:         return JS_FALSE;
    1:     }
    1:     sb->base = base;
    1:     sb->limit = base + length;
    1:     sb->ptr = base + offset;
    1:     return JS_TRUE;
    1: }
    1: 
 6561: JSBool
 6561: js_InitTokenStream(JSContext *cx, JSTokenStream *ts,
 6561:                    const jschar *base, size_t length,
 6561:                    FILE *fp, const char *filename, uintN lineno)
    1: {
 6561:     jschar *buf;
    1:     size_t nb;
    1: 
 6561:     JS_ASSERT_IF(fp, !base);
 6561:     JS_ASSERT_IF(!base, length == 0);
 6561:     nb = fp
 6561:          ? 2 * JS_LINE_LIMIT * sizeof(jschar)
 6561:          : JS_LINE_LIMIT * sizeof(jschar);
 6561:     JS_ARENA_ALLOCATE_CAST(buf, jschar *, &cx->tempPool, nb);
10159:     if (!buf) {
 8296:         js_ReportOutOfScriptQuota(cx);
 6561:         return JS_FALSE;
    1:     }
 6561:     memset(buf, 0, nb);
 6561:     memset(ts, 0, sizeof(*ts));
 6561:     ts->filename = filename;
 6561:     ts->lineno = lineno;
 6561:     ts->linebuf.base = ts->linebuf.limit = ts->linebuf.ptr = buf;
 6561:     if (fp) {
 6561:         ts->file = fp;
 6561:         ts->userbuf.base = buf + JS_LINE_LIMIT;
 6561:         ts->userbuf.ptr = ts->userbuf.limit = ts->userbuf.base + JS_LINE_LIMIT;
 6561:     } else {
    1:         ts->userbuf.base = (jschar *)base;
    1:         ts->userbuf.limit = (jschar *)base + length;
    1:         ts->userbuf.ptr = (jschar *)base;
 6561:     }
    1:     ts->tokenbuf.grow = GrowTokenBuf;
    1:     ts->tokenbuf.data = cx;
 2433:     ts->listener = cx->debugHooks->sourceHandler;
 2433:     ts->listenerData = cx->debugHooks->sourceHandlerData;
 6561:     return JS_TRUE;
    1: }
    1: 
 6561: void
    1: js_CloseTokenStream(JSContext *cx, JSTokenStream *ts)
    1: {
    1:     if (ts->flags & TSF_OWNFILENAME)
    1:         JS_free(cx, (void *) ts->filename);
    1: }
    1: 
    1: JS_FRIEND_API(int)
    1: js_fgets(char *buf, int size, FILE *file)
    1: {
    1:     int n, i, c;
    1:     JSBool crflag;
    1: 
    1:     n = size - 1;
    1:     if (n < 0)
    1:         return -1;
    1: 
    1:     crflag = JS_FALSE;
    1:     for (i = 0; i < n && (c = getc(file)) != EOF; i++) {
    1:         buf[i] = c;
    1:         if (c == '\n') {        /* any \n ends a line */
    1:             i++;                /* keep the \n; we know there is room for \0 */
    1:             break;
    1:         }
    1:         if (crflag) {           /* \r not followed by \n ends line at the \r */
    1:             ungetc(c, file);
    1:             break;              /* and overwrite c in buf with \0 */
    1:         }
    1:         crflag = (c == '\r');
    1:     }
    1: 
    1:     buf[i] = '\0';
    1:     return i;
    1: }
    1: 
    1: static int32
    1: GetChar(JSTokenStream *ts)
    1: {
    1:     int32 c;
    1:     ptrdiff_t i, j, len, olen;
    1:     JSBool crflag;
    1:     char cbuf[JS_LINE_LIMIT];
    1:     jschar *ubuf, *nl;
    1: 
    1:     if (ts->ungetpos != 0) {
    1:         c = ts->ungetbuf[--ts->ungetpos];
    1:     } else {
    1:         if (ts->linebuf.ptr == ts->linebuf.limit) {
    1:             len = PTRDIFF(ts->userbuf.limit, ts->userbuf.ptr, jschar);
    1:             if (len <= 0) {
    1:                 if (!ts->file) {
    1:                     ts->flags |= TSF_EOF;
    1:                     return EOF;
    1:                 }
    1:         
    1:                 /* Fill ts->userbuf so that \r and \r\n convert to \n. */
    1:                 crflag = (ts->flags & TSF_CRFLAG) != 0;
    1:                 len = js_fgets(cbuf, JS_LINE_LIMIT - crflag, ts->file);
    1:                 if (len <= 0) {
    1:                     ts->flags |= TSF_EOF;
    1:                     return EOF;
    1:                 }
    1:                 olen = len;
    1:                 ubuf = ts->userbuf.base;
    1:                 i = 0;
    1:                 if (crflag) {
    1:                     ts->flags &= ~TSF_CRFLAG;
    1:                     if (cbuf[0] != '\n') {
    1:                         ubuf[i++] = '\n';
    1:                         len++;
    1:                         ts->linepos--;
    1:                     }
    1:                 }
    1:                 for (j = 0; i < len; i++, j++)
    1:                     ubuf[i] = (jschar) (unsigned char) cbuf[j];
    1:                 ts->userbuf.limit = ubuf + len;
    1:                 ts->userbuf.ptr = ubuf;
    1:             }
    1:             if (ts->listener) {
    1:                 ts->listener(ts->filename, ts->lineno, ts->userbuf.ptr, len,
    1:                              &ts->listenerTSData, ts->listenerData);
    1:             }
    1:         
    1:             nl = ts->saveEOL;
    1:             if (!nl) {
    1:                 /*
    1:                  * Any one of \n, \r, or \r\n ends a line (the longest
    1:                  * match wins).  Also allow the Unicode line and paragraph
    1:                  * separators.
    1:                  */
    1:                 for (nl = ts->userbuf.ptr; nl < ts->userbuf.limit; nl++) {
    1:                     /*
    1:                      * Try to prevent value-testing on most characters by
    1:                      * filtering out characters that aren't 000x or 202x.
    1:                      */
    1:                     if ((*nl & 0xDFD0) == 0) {
    1:                         if (*nl == '\n')
    1:                             break;
    1:                         if (*nl == '\r') {
    1:                             if (nl + 1 < ts->userbuf.limit && nl[1] == '\n')
    1:                                 nl++;
    1:                             break;
    1:                         }
    1:                         if (*nl == LINE_SEPARATOR || *nl == PARA_SEPARATOR)
    1:                             break;
    1:                     }
    1:                 }
    1:             }
    1:         
    1:             /*
    1:              * If there was a line terminator, copy thru it into linebuf.
    1:              * Else copy JS_LINE_LIMIT-1 bytes into linebuf.
    1:              */
    1:             if (nl < ts->userbuf.limit)
    1:                 len = PTRDIFF(nl, ts->userbuf.ptr, jschar) + 1;
    1:             if (len >= JS_LINE_LIMIT) {
    1:                 len = JS_LINE_LIMIT - 1;
    1:                 ts->saveEOL = nl;
    1:             } else {
    1:                 ts->saveEOL = NULL;
    1:             }
    1:             js_strncpy(ts->linebuf.base, ts->userbuf.ptr, len);
    1:             ts->userbuf.ptr += len;
    1:             olen = len;
    1:         
    1:             /*
    1:              * Make sure linebuf contains \n for EOL (don't do this in
    1:              * userbuf because the user's string might be readonly).
    1:              */
    1:             if (nl < ts->userbuf.limit) {
    1:                 if (*nl == '\r') {
    1:                     if (ts->linebuf.base[len-1] == '\r') {
    1:                         /*
    1:                          * Does the line segment end in \r?  We must check
    1:                          * for a \n at the front of the next segment before
    1:                          * storing a \n into linebuf.  This case matters
    1:                          * only when we're reading from a file.
    1:                          */
    1:                         if (nl + 1 == ts->userbuf.limit && ts->file) {
    1:                             len--;
    1:                             ts->flags |= TSF_CRFLAG; /* clear NLFLAG? */
    1:                             if (len == 0) {
    1:                                 /*
    1:                                  * This can happen when a segment ends in
    1:                                  * \r\r.  Start over.  ptr == limit in this
    1:                                  * case, so we'll fall into buffer-filling
    1:                                  * code.
    1:                                  */
    1:                                 return GetChar(ts);
    1:                             }
    1:                         } else {
    1:                             ts->linebuf.base[len-1] = '\n';
    1:                         }
    1:                     }
    1:                 } else if (*nl == '\n') {
    1:                     if (nl > ts->userbuf.base &&
    1:                         nl[-1] == '\r' &&
    1:                         ts->linebuf.base[len-2] == '\r') {
    1:                         len--;
    1:                         JS_ASSERT(ts->linebuf.base[len] == '\n');
    1:                         ts->linebuf.base[len-1] = '\n';
    1:                     }
    1:                 } else if (*nl == LINE_SEPARATOR || *nl == PARA_SEPARATOR) {
    1:                     ts->linebuf.base[len-1] = '\n';
    1:                 }
    1:             }
    1:         
    1:             /* Reset linebuf based on adjusted segment length. */
    1:             ts->linebuf.limit = ts->linebuf.base + len;
    1:             ts->linebuf.ptr = ts->linebuf.base;
    1:         
    1:             /* Update position of linebuf within physical userbuf line. */
    1:             if (!(ts->flags & TSF_NLFLAG))
    1:                 ts->linepos += ts->linelen;
    1:             else
    1:                 ts->linepos = 0;
    1:             if (ts->linebuf.limit[-1] == '\n')
    1:                 ts->flags |= TSF_NLFLAG;
    1:             else
    1:                 ts->flags &= ~TSF_NLFLAG;
    1:         
    1:             /* Update linelen from original segment length. */
    1:             ts->linelen = olen;
    1:         }
    1:         c = *ts->linebuf.ptr++;
    1:     }
    1:     if (c == '\n')
    1:         ts->lineno++;
    1:     return c;
    1: }
    1: 
    1: static void
    1: UngetChar(JSTokenStream *ts, int32 c)
    1: {
    1:     if (c == EOF)
    1:         return;
 8336:     JS_ASSERT(ts->ungetpos < JS_ARRAY_LENGTH(ts->ungetbuf));
    1:     if (c == '\n')
    1:         ts->lineno--;
    1:     ts->ungetbuf[ts->ungetpos++] = (jschar)c;
    1: }
    1: 
    1: static int32
    1: PeekChar(JSTokenStream *ts)
    1: {
    1:     int32 c;
    1: 
    1:     c = GetChar(ts);
    1:     UngetChar(ts, c);
    1:     return c;
    1: }
    1: 
    1: /*
    1:  * Peek n chars ahead into ts.  Return true if n chars were read, false if
    1:  * there weren't enough characters in the input stream.  This function cannot
    1:  * be used to peek into or past a newline.
    1:  */
    1: static JSBool
    1: PeekChars(JSTokenStream *ts, intN n, jschar *cp)
    1: {
    1:     intN i, j;
    1:     int32 c;
    1: 
    1:     for (i = 0; i < n; i++) {
    1:         c = GetChar(ts);
    1:         if (c == EOF)
    1:             break;
    1:         if (c == '\n') {
    1:             UngetChar(ts, c);
    1:             break;
    1:         }
    1:         cp[i] = (jschar)c;
    1:     }
    1:     for (j = i - 1; j >= 0; j--)
    1:         UngetChar(ts, cp[j]);
    1:     return i == n;
    1: }
    1: 
    1: static void
    1: SkipChars(JSTokenStream *ts, intN n)
    1: {
    1:     while (--n >= 0)
    1:         GetChar(ts);
    1: }
    1: 
    1: static JSBool
    1: MatchChar(JSTokenStream *ts, int32 expect)
    1: {
    1:     int32 c;
    1: 
    1:     c = GetChar(ts);
    1:     if (c == expect)
    1:         return JS_TRUE;
    1:     UngetChar(ts, c);
    1:     return JS_FALSE;
    1: }
    1: 
 7984: JSBool
 7984: js_ReportCompileErrorNumber(JSContext *cx, JSTokenStream *ts, JSParseNode *pn,
 7984:                             uintN flags, uintN errorNumber, ...)
    1: {
 7984:     JSErrorReport report;
 7984:     char *message;
    1:     size_t linelength;
 7984:     jschar *linechars;
 7984:     char *linebytes;
 7984:     va_list ap;
 7984:     JSBool warning, ok;
 7984:     JSTokenPos *tp;
 7984:     uintN index, i;
    1:     JSErrorReporter onError;
    1: 
 7984:     JS_ASSERT(ts->linebuf.limit < ts->linebuf.base + JS_LINE_LIMIT);
 7984: 
 7984:     if ((flags & JSREPORT_STRICT) && !JS_HAS_STRICT_OPTION(cx))
 7984:         return JS_TRUE;
 7984: 
 7984:     memset(&report, 0, sizeof report);
 7984:     report.flags = flags;
 7984:     report.errorNumber = errorNumber;
    1:     message = NULL;
 7984:     linechars = NULL;
 7984:     linebytes = NULL;
    1: 
18989:     MUST_FLOW_THROUGH("out");
 7984:     va_start(ap, errorNumber);
 7984:     ok = js_ExpandErrorArguments(cx, js_GetErrorMessage, NULL,
 7984:                                  errorNumber, &message, &report, &warning,
 7984:                                  !(flags & JSREPORT_UC), ap);
 7984:     va_end(ap);
 7984:     if (!ok) {
 7984:         warning = JS_FALSE;
 7984:         goto out;
    1:     }
    1: 
 7984:     report.filename = ts->filename;
 7984: 
 7984:     if (pn) {
 7984:         report.lineno = pn->pn_pos.begin.lineno;
 7984:         if (report.lineno != ts->lineno)
 7984:             goto report;
 7984:         tp = &pn->pn_pos;
 6561:     } else {
 9832:         /* Point to the current token, not the next one to get. */
 9832:         tp = &ts->tokens[ts->cursor].pos;
    1:     }
 7984:     report.lineno = ts->lineno;
    1:     linelength = PTRDIFF(ts->linebuf.limit, ts->linebuf.base, jschar);
    1:     linechars = (jschar *)JS_malloc(cx, (linelength + 1) * sizeof(jschar));
    1:     if (!linechars) {
    1:         warning = JS_FALSE;
    1:         goto out;
    1:     }
    1:     memcpy(linechars, ts->linebuf.base, linelength * sizeof(jschar));
    1:     linechars[linelength] = 0;
    1:     linebytes = js_DeflateString(cx, linechars, linelength);
    1:     if (!linebytes) {
    1:         warning = JS_FALSE;
    1:         goto out;
    1:     }
 7984:     report.linebuf = linebytes;
    1: 
    1:     /*
    1:      * FIXME: What should instead happen here is that we should
    1:      * find error-tokens in userbuf, if !ts->file.  That will
    1:      * allow us to deliver a more helpful error message, which
    1:      * includes all or part of the bad string or bad token.  The
    1:      * code here yields something that looks truncated.
    1:      * See https://bugzilla.mozilla.org/show_bug.cgi?id=352970
    1:      */
    1:     index = 0;
    1:     if (tp->begin.lineno == tp->end.lineno) {
    1:         if (tp->begin.index < ts->linepos)
    1:             goto report;
    1: 
    1:         index = tp->begin.index - ts->linepos;
    1:     }
    1: 
 7984:     report.tokenptr = report.linebuf + index;
 7984:     report.uclinebuf = linechars;
 7984:     report.uctokenptr = report.uclinebuf + index;
    1: 
    1:     /*
    1:      * If there's a runtime exception type associated with this error
    1:      * number, set that as the pending exception.  For errors occuring at
    1:      * compile time, this is very likely to be a JSEXN_SYNTAXERR.
    1:      *
    1:      * If an exception is thrown but not caught, the JSREPORT_EXCEPTION
    1:      * flag will be set in report.flags.  Proper behavior for an error
    1:      * reporter is to ignore a report with this flag for all but top-level
    1:      * compilation errors.  The exception will remain pending, and so long
    1:      * as the non-top-level "load", "eval", or "compile" native function
    1:      * returns false, the top-level reporter will eventually receive the
    1:      * uncaught exception report.
    1:      *
    1:      * XXX it'd probably be best if there was only one call to this
    1:      * function, but there seem to be two error reporter call points.
    1:      */
    1:   report:
    1:     onError = cx->errorReporter;
    1: 
    1:     /*
    1:      * Try to raise an exception only if there isn't one already set --
    1:      * otherwise the exception will describe the last compile-time error,
    1:      * which is likely spurious.
    1:      */
 7984:     if (!(ts->flags & TSF_ERROR)) {
 7984:         if (js_ErrorToException(cx, message, &report))
    1:             onError = NULL;
    1:     }
    1: 
    1:     /*
    1:      * Suppress any compile-time errors that don't occur at the top level.
    1:      * This may still fail, as interplevel may be zero in contexts where we
    1:      * don't really want to call the error reporter, as when js is called
    1:      * by other code which could catch the error.
    1:      */
    1:     if (cx->interpLevel != 0 && !JSREPORT_IS_WARNING(flags))
    1:         onError = NULL;
    1: 
    1:     if (onError) {
 2433:         JSDebugErrorHook hook = cx->debugHooks->debugErrorHook;
    1: 
    1:         /*
    1:          * If debugErrorHook is present then we give it a chance to veto
    1:          * sending the error on to the regular error reporter.
    1:          */
 7984:         if (hook && !hook(cx, message, &report,
 2433:                           cx->debugHooks->debugErrorHookData)) {
    1:             onError = NULL;
    1:         }
    1:     }
    1:     if (onError)
 7984:         (*onError)(cx, message, &report);
    1: 
    1:   out:
    1:     if (linebytes)
    1:         JS_free(cx, linebytes);
    1:     if (linechars)
    1:         JS_free(cx, linechars);
    1:     if (message)
    1:         JS_free(cx, message);
 7984:     if (report.ucmessage)
 7984:         JS_free(cx, (void *)report.ucmessage);
    1: 
 7984:     if (report.messageArgs) {
 7984:         if (!(flags & JSREPORT_UC)) {
 7984:             i = 0;
 7984:             while (report.messageArgs[i])
 7984:                 JS_free(cx, (void *)report.messageArgs[i++]);
 7984:         }
 7984:         JS_free(cx, (void *)report.messageArgs);
 7984:     }
 7984: 
 7984:     if (!JSREPORT_IS_WARNING(flags)) {
    1:         /* Set the error flag to suppress spurious reports. */
    1:         ts->flags |= TSF_ERROR;
    1:     }
    1: 
    1:     return warning;
    1: }
    1: 
    1: static JSBool
    1: GrowStringBuffer(JSStringBuffer *sb, size_t newlength)
    1: {
    1:     ptrdiff_t offset;
    1:     jschar *bp;
    1: 
    1:     offset = PTRDIFF(sb->ptr, sb->base, jschar);
    1:     JS_ASSERT(offset >= 0);
    1:     newlength += offset + 1;
    1:     if ((size_t)offset < newlength && newlength < ~(size_t)0 / sizeof(jschar))
 3164:         bp = (jschar *) realloc(sb->base, newlength * sizeof(jschar));
    1:     else
    1:         bp = NULL;
    1:     if (!bp) {
    1:         free(sb->base);
    1:         sb->base = STRING_BUFFER_ERROR_BASE;
    1:         return JS_FALSE;
    1:     }
    1:     sb->base = bp;
    1:     sb->ptr = bp + offset;
    1:     sb->limit = bp + newlength - 1;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static void
    1: FreeStringBuffer(JSStringBuffer *sb)
    1: {
    1:     JS_ASSERT(STRING_BUFFER_OK(sb));
    1:     if (sb->base)
    1:         free(sb->base);
    1: }
    1: 
    1: void
    1: js_InitStringBuffer(JSStringBuffer *sb)
    1: {
    1:     sb->base = sb->limit = sb->ptr = NULL;
    1:     sb->data = NULL;
    1:     sb->grow = GrowStringBuffer;
    1:     sb->free = FreeStringBuffer;
    1: }
    1: 
    1: void
    1: js_FinishStringBuffer(JSStringBuffer *sb)
    1: {
    1:     sb->free(sb);
    1: }
    1: 
    1: #define ENSURE_STRING_BUFFER(sb,n) \
    1:     ((sb)->ptr + (n) <= (sb)->limit || sb->grow(sb, n))
    1: 
    1: static void
    1: FastAppendChar(JSStringBuffer *sb, jschar c)
    1: {
    1:     if (!STRING_BUFFER_OK(sb))
    1:         return;
    1:     if (!ENSURE_STRING_BUFFER(sb, 1))
    1:         return;
    1:     *sb->ptr++ = c;
    1: }
    1: 
    1: void
    1: js_AppendChar(JSStringBuffer *sb, jschar c)
    1: {
    1:     jschar *bp;
    1: 
    1:     if (!STRING_BUFFER_OK(sb))
    1:         return;
    1:     if (!ENSURE_STRING_BUFFER(sb, 1))
    1:         return;
    1:     bp = sb->ptr;
    1:     *bp++ = c;
    1:     *bp = 0;
    1:     sb->ptr = bp;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
    1: void
    1: js_RepeatChar(JSStringBuffer *sb, jschar c, uintN count)
    1: {
    1:     jschar *bp;
    1: 
    1:     if (!STRING_BUFFER_OK(sb) || count == 0)
    1:         return;
    1:     if (!ENSURE_STRING_BUFFER(sb, count))
    1:         return;
    1:     for (bp = sb->ptr; count; --count)
    1:         *bp++ = c;
    1:     *bp = 0;
    1:     sb->ptr = bp;
    1: }
    1: 
    1: void
    1: js_AppendCString(JSStringBuffer *sb, const char *asciiz)
    1: {
    1:     size_t length;
    1:     jschar *bp;
    1: 
    1:     if (!STRING_BUFFER_OK(sb) || *asciiz == '\0')
    1:         return;
    1:     length = strlen(asciiz);
    1:     if (!ENSURE_STRING_BUFFER(sb, length))
    1:         return;
    1:     for (bp = sb->ptr; length; --length)
    1:         *bp++ = (jschar) *asciiz++;
    1:     *bp = 0;
    1:     sb->ptr = bp;
    1: }
    1: 
    1: void
    1: js_AppendJSString(JSStringBuffer *sb, JSString *str)
    1: {
    1:     size_t length;
    1:     jschar *bp;
    1: 
    1:     if (!STRING_BUFFER_OK(sb))
    1:         return;
    1:     length = JSSTRING_LENGTH(str);
    1:     if (length == 0 || !ENSURE_STRING_BUFFER(sb, length))
    1:         return;
    1:     bp = sb->ptr;
    1:     js_strncpy(bp, JSSTRING_CHARS(str), length);
    1:     bp += length;
    1:     *bp = 0;
    1:     sb->ptr = bp;
    1: }
    1: 
    1: static JSBool
    1: GetXMLEntity(JSContext *cx, JSTokenStream *ts)
    1: {
    1:     ptrdiff_t offset, length, i;
    1:     int32 c, d;
    1:     JSBool ispair;
    1:     jschar *bp, digit;
    1:     char *bytes;
    1:     JSErrNum msg;
    1: 
    1:     /* Put the entity, including the '&' already scanned, in ts->tokenbuf. */
    1:     offset = PTRDIFF(ts->tokenbuf.ptr, ts->tokenbuf.base, jschar);
    1:     FastAppendChar(&ts->tokenbuf, '&');
20255:     if (!STRING_BUFFER_OK(&ts->tokenbuf))
20255:         return JS_FALSE;
    1:     while ((c = GetChar(ts)) != ';') {
    1:         if (c == EOF || c == '\n') {
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_END_OF_XML_ENTITY);
    1:             return JS_FALSE;
    1:         }
    1:         FastAppendChar(&ts->tokenbuf, (jschar) c);
20255:         if (!STRING_BUFFER_OK(&ts->tokenbuf))
20255:             return JS_FALSE;
    1:     }
    1: 
    1:     /* Let length be the number of jschars after the '&', including the ';'. */
    1:     length = PTRDIFF(ts->tokenbuf.ptr, ts->tokenbuf.base, jschar) - offset;
    1:     bp = ts->tokenbuf.base + offset;
    1:     c = d = 0;
    1:     ispair = JS_FALSE;
    1:     if (length > 2 && bp[1] == '#') {
    1:         /* Match a well-formed XML Character Reference. */
    1:         i = 2;
    1:         if (length > 3 && JS_TOLOWER(bp[i]) == 'x') {
    1:             if (length > 9)     /* at most 6 hex digits allowed */
    1:                 goto badncr;
    1:             while (++i < length) {
    1:                 digit = bp[i];
    1:                 if (!JS7_ISHEX(digit))
    1:                     goto badncr;
    1:                 c = (c << 4) + JS7_UNHEX(digit);
    1:             }
    1:         } else {
    1:             while (i < length) {
    1:                 digit = bp[i++];
    1:                 if (!JS7_ISDEC(digit))
    1:                     goto badncr;
    1:                 c = (c * 10) + JS7_UNDEC(digit);
    1:                 if (c < 0)
    1:                     goto badncr;
    1:             }
    1:         }
    1: 
    1:         if (0x10000 <= c && c <= 0x10FFFF) {
    1:             /* Form a surrogate pair (c, d) -- c is the high surrogate. */
    1:             d = 0xDC00 + (c & 0x3FF);
    1:             c = 0xD7C0 + (c >> 10);
    1:             ispair = JS_TRUE;
    1:         } else {
    1:             /* Enforce the http://www.w3.org/TR/REC-xml/#wf-Legalchar WFC. */
    1:             if (c != 0x9 && c != 0xA && c != 0xD &&
    1:                 !(0x20 <= c && c <= 0xD7FF) &&
    1:                 !(0xE000 <= c && c <= 0xFFFD)) {
    1:                 goto badncr;
    1:             }
    1:         }
    1:     } else {
    1:         /* Try to match one of the five XML 1.0 predefined entities. */
    1:         switch (length) {
    1:           case 3:
    1:             if (bp[2] == 't') {
    1:                 if (bp[1] == 'l')
    1:                     c = '<';
    1:                 else if (bp[1] == 'g')
    1:                     c = '>';
    1:             }
    1:             break;
    1:           case 4:
    1:             if (bp[1] == 'a' && bp[2] == 'm' && bp[3] == 'p')
    1:                 c = '&';
    1:             break;
    1:           case 5:
    1:             if (bp[3] == 'o') {
    1:                 if (bp[1] == 'a' && bp[2] == 'p' && bp[4] == 's')
    1:                     c = '\'';
    1:                 else if (bp[1] == 'q' && bp[2] == 'u' && bp[4] == 't')
    1:                     c = '"';
    1:             }
    1:             break;
    1:         }
    1:         if (c == 0) {
    1:             msg = JSMSG_UNKNOWN_XML_ENTITY;
    1:             goto bad;
    1:         }
    1:     }
    1: 
    1:     /* If we matched, retract ts->tokenbuf and store the entity's value. */
    1:     *bp++ = (jschar) c;
    1:     if (ispair)
    1:         *bp++ = (jschar) d;
    1:     *bp = 0;
    1:     ts->tokenbuf.ptr = bp;
    1:     return JS_TRUE;
    1: 
    1: badncr:
    1:     msg = JSMSG_BAD_XML_NCR;
    1: bad:
    1:     /* No match: throw a TypeError per ECMA-357 10.3.2.1 step 8(a). */
20255:     JS_ASSERT(STRING_BUFFER_OK(&ts->tokenbuf));
20255:     JS_ASSERT(PTRDIFF(ts->tokenbuf.ptr, bp, jschar) >= 1);
    1:     bytes = js_DeflateString(cx, bp + 1,
    1:                              PTRDIFF(ts->tokenbuf.ptr, bp, jschar) - 1);
    1:     if (bytes) {
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     msg, bytes);
    1:         JS_free(cx, bytes);
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1: JSTokenType
    1: js_PeekToken(JSContext *cx, JSTokenStream *ts)
    1: {
    1:     JSTokenType tt;
    1: 
    1:     if (ts->lookahead != 0) {
    1:         tt = ts->tokens[(ts->cursor + ts->lookahead) & NTOKENS_MASK].type;
    1:     } else {
    1:         tt = js_GetToken(cx, ts);
    1:         js_UngetToken(ts);
    1:     }
    1:     return tt;
    1: }
    1: 
    1: JSTokenType
    1: js_PeekTokenSameLine(JSContext *cx, JSTokenStream *ts)
    1: {
    1:     JSTokenType tt;
    1: 
    1:     if (!ON_CURRENT_LINE(ts, CURRENT_TOKEN(ts).pos))
    1:         return TOK_EOL;
    1:     ts->flags |= TSF_NEWLINES;
    1:     tt = js_PeekToken(cx, ts);
    1:     ts->flags &= ~TSF_NEWLINES;
    1:     return tt;
    1: }
    1: 
    1: /*
    1:  * We have encountered a '\': check for a Unicode escape sequence after it,
    1:  * returning the character code value if we found a Unicode escape sequence.
    1:  * Otherwise, non-destructively return the original '\'.
    1:  */
    1: static int32
    1: GetUnicodeEscape(JSTokenStream *ts)
    1: {
    1:     jschar cp[5];
    1:     int32 c;
    1: 
    1:     if (PeekChars(ts, 5, cp) && cp[0] == 'u' &&
    1:         JS7_ISHEX(cp[1]) && JS7_ISHEX(cp[2]) &&
    1:         JS7_ISHEX(cp[3]) && JS7_ISHEX(cp[4]))
    1:     {
    1:         c = (((((JS7_UNHEX(cp[1]) << 4)
    1:                 + JS7_UNHEX(cp[2])) << 4)
    1:               + JS7_UNHEX(cp[3])) << 4)
    1:             + JS7_UNHEX(cp[4]);
    1:         SkipChars(ts, 5);
    1:         return c;
    1:     }
    1:     return '\\';
    1: }
    1: 
    1: static JSToken *
    1: NewToken(JSTokenStream *ts, ptrdiff_t adjust)
    1: {
    1:     JSToken *tp;
    1: 
    1:     ts->cursor = (ts->cursor + 1) & NTOKENS_MASK;
    1:     tp = &CURRENT_TOKEN(ts);
    1:     tp->ptr = ts->linebuf.ptr + adjust;
    1:     tp->pos.begin.index = ts->linepos +
    1:                           PTRDIFF(tp->ptr, ts->linebuf.base, jschar) -
    1:                           ts->ungetpos;
    1:     tp->pos.begin.lineno = tp->pos.end.lineno = (uint16)ts->lineno;
    1:     return tp;
    1: }
    1: 
16284: static JS_ALWAYS_INLINE JSBool
16027: ScanAsSpace(jschar c)
16027: {
16027:     /* Treat little- and big-endian BOMs as whitespace for compatibility. */
16027:     if (JS_ISSPACE(c) || c == 0xfffe || c == 0xfeff)
16027:         return JS_TRUE;
16027:     return JS_FALSE;
16027: }
16027: 
    1: JSTokenType
    1: js_GetToken(JSContext *cx, JSTokenStream *ts)
    1: {
    1:     JSTokenType tt;
    1:     int32 c, qc;
    1:     JSToken *tp;
    1:     JSAtom *atom;
    1:     JSBool hadUnicodeEscape;
    1:     const struct keyword *kw;
 8656: #if JS_HAS_XML_SUPPORT
 3164:     JSBool inTarget;
 3164:     size_t targetLength;
 3164:     ptrdiff_t contentIndex;
 8656: #endif
    1: 
    1: #define INIT_TOKENBUF()     (ts->tokenbuf.ptr = ts->tokenbuf.base)
    1: #define TOKENBUF_LENGTH()   PTRDIFF(ts->tokenbuf.ptr, ts->tokenbuf.base, jschar)
    1: #define TOKENBUF_OK()       STRING_BUFFER_OK(&ts->tokenbuf)
    1: #define TOKENBUF_TO_ATOM()  (TOKENBUF_OK()                                    \
    1:                              ? js_AtomizeChars(cx,                            \
    1:                                                TOKENBUF_BASE(),               \
    1:                                                TOKENBUF_LENGTH(),             \
    1:                                                0)                             \
    1:                              : NULL)
    1: #define ADD_TO_TOKENBUF(c)  FastAppendChar(&ts->tokenbuf, (jschar) (c))
    1: 
    1: /* The following 4 macros should only be used when TOKENBUF_OK() is true. */
    1: #define TOKENBUF_BASE()     (ts->tokenbuf.base)
 4281: #define TOKENBUF_END()      (ts->tokenbuf.ptr)
    1: #define TOKENBUF_CHAR(i)    (ts->tokenbuf.base[i])
    1: #define TRIM_TOKENBUF(i)    (ts->tokenbuf.ptr = ts->tokenbuf.base + i)
    1: #define NUL_TERM_TOKENBUF() (*ts->tokenbuf.ptr = 0)
    1: 
    1:     /* Check for a pushed-back token resulting from mismatching lookahead. */
    1:     while (ts->lookahead != 0) {
    1:         JS_ASSERT(!(ts->flags & TSF_XMLTEXTMODE));
    1:         ts->lookahead--;
    1:         ts->cursor = (ts->cursor + 1) & NTOKENS_MASK;
    1:         tt = CURRENT_TOKEN(ts).type;
    1:         if (tt != TOK_EOL || (ts->flags & TSF_NEWLINES))
    1:             return tt;
    1:     }
    1: 
    1:     /* If there was a fatal error, keep returning TOK_ERROR. */
    1:     if (ts->flags & TSF_ERROR)
    1:         return TOK_ERROR;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:     if (ts->flags & TSF_XMLTEXTMODE) {
    1:         tt = TOK_XMLSPACE;      /* veto if non-space, return TOK_XMLTEXT */
    1:         tp = NewToken(ts, 0);
    1:         INIT_TOKENBUF();
    1:         qc = (ts->flags & TSF_XMLONLYMODE) ? '<' : '{';
    1: 
    1:         while ((c = GetChar(ts)) != qc && c != '<' && c != EOF) {
    1:             if (c == '&' && qc == '<') {
    1:                 if (!GetXMLEntity(cx, ts))
    1:                     goto error;
    1:                 tt = TOK_XMLTEXT;
    1:                 continue;
    1:             }
    1: 
    1:             if (!JS_ISXMLSPACE(c))
    1:                 tt = TOK_XMLTEXT;
    1:             ADD_TO_TOKENBUF(c);
    1:         }
    1:         UngetChar(ts, c);
    1: 
    1:         if (TOKENBUF_LENGTH() == 0) {
    1:             atom = NULL;
    1:         } else {
    1:             atom = TOKENBUF_TO_ATOM();
    1:             if (!atom)
    1:                 goto error;
    1:         }
    1:         tp->pos.end.lineno = (uint16)ts->lineno;
    1:         tp->t_op = JSOP_STRING;
    1:         tp->t_atom = atom;
    1:         goto out;
    1:     }
    1: 
    1:     if (ts->flags & TSF_XMLTAGMODE) {
    1:         tp = NewToken(ts, 0);
    1:         c = GetChar(ts);
    1:         if (JS_ISXMLSPACE(c)) {
    1:             do {
    1:                 c = GetChar(ts);
    1:             } while (JS_ISXMLSPACE(c));
    1:             UngetChar(ts, c);
    1:             tt = TOK_XMLSPACE;
    1:             goto out;
    1:         }
    1: 
    1:         if (c == EOF) {
    1:             tt = TOK_EOF;
    1:             goto out;
    1:         }
    1: 
    1:         INIT_TOKENBUF();
    1:         if (JS_ISXMLNSSTART(c)) {
    1:             JSBool sawColon = JS_FALSE;
    1: 
    1:             ADD_TO_TOKENBUF(c);
    1:             while ((c = GetChar(ts)) != EOF && JS_ISXMLNAME(c)) {
    1:                 if (c == ':') {
    1:                     int nextc;
    1: 
    1:                     if (sawColon ||
    1:                         (nextc = PeekChar(ts),
    1:                          ((ts->flags & TSF_XMLONLYMODE) || nextc != '{') &&
    1:                          !JS_ISXMLNAME(nextc))) {
 7984:                         js_ReportCompileErrorNumber(cx, ts, NULL,
    1:                                                     JSREPORT_ERROR,
    1:                                                     JSMSG_BAD_XML_QNAME);
    1:                         goto error;
    1:                     }
    1:                     sawColon = JS_TRUE;
    1:                 }
    1: 
    1:                 ADD_TO_TOKENBUF(c);
    1:             }
    1: 
    1:             UngetChar(ts, c);
    1:             atom = TOKENBUF_TO_ATOM();
    1:             if (!atom)
    1:                 goto error;
    1:             tp->t_op = JSOP_STRING;
    1:             tp->t_atom = atom;
    1:             tt = TOK_XMLNAME;
    1:             goto out;
    1:         }
    1: 
    1:         switch (c) {
    1:           case '{':
    1:             if (ts->flags & TSF_XMLONLYMODE)
    1:                 goto bad_xml_char;
    1:             tt = TOK_LC;
    1:             goto out;
    1: 
    1:           case '=':
    1:             tt = TOK_ASSIGN;
    1:             goto out;
    1: 
    1:           case '"':
    1:           case '\'':
    1:             qc = c;
    1:             while ((c = GetChar(ts)) != qc) {
    1:                 if (c == EOF) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_UNTERMINATED_STRING);
    1:                     goto error;
    1:                 }
    1: 
    1:                 /*
    1:                  * XML attribute values are double-quoted when pretty-printed,
    1:                  * so escape " if it is expressed directly in a single-quoted
    1:                  * attribute value.
    1:                  */
    1:                 if (c == '"' && !(ts->flags & TSF_XMLONLYMODE)) {
    1:                     JS_ASSERT(qc == '\'');
    1:                     js_AppendCString(&ts->tokenbuf, js_quot_entity_str);
    1:                     continue;
    1:                 }
    1: 
    1:                 if (c == '&' && (ts->flags & TSF_XMLONLYMODE)) {
    1:                     if (!GetXMLEntity(cx, ts))
    1:                         goto error;
    1:                     continue;
    1:                 }
    1: 
    1:                 ADD_TO_TOKENBUF(c);
    1:             }
    1:             atom = TOKENBUF_TO_ATOM();
    1:             if (!atom)
    1:                 goto error;
    1:             tp->pos.end.lineno = (uint16)ts->lineno;
    1:             tp->t_op = JSOP_STRING;
    1:             tp->t_atom = atom;
    1:             tt = TOK_XMLATTR;
    1:             goto out;
    1: 
    1:           case '>':
    1:             tt = TOK_XMLTAGC;
    1:             goto out;
    1: 
    1:           case '/':
    1:             if (MatchChar(ts, '>')) {
    1:                 tt = TOK_XMLPTAGC;
    1:                 goto out;
    1:             }
    1:             /* FALL THROUGH */
    1: 
    1:           bad_xml_char:
    1:           default:
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_BAD_XML_CHARACTER);
    1:             goto error;
    1:         }
    1:         /* NOTREACHED */
    1:     }
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1: retry:
    1:     do {
    1:         c = GetChar(ts);
    1:         if (c == '\n') {
    1:             ts->flags &= ~TSF_DIRTYLINE;
    1:             if (ts->flags & TSF_NEWLINES)
    1:                 break;
    1:         }
17884:     } while (ScanAsSpace((jschar)c));
    1: 
    1:     tp = NewToken(ts, -1);
    1:     if (c == EOF) {
    1:         tt = TOK_EOF;
    1:         goto out;
    1:     }
    1: 
    1:     hadUnicodeEscape = JS_FALSE;
    1:     if (JS_ISIDSTART(c) ||
    1:         (c == '\\' &&
12751:          (qc = GetUnicodeEscape(ts),
12751:           hadUnicodeEscape = JS_ISIDSTART(qc)))) {
12751:         if (hadUnicodeEscape)
12751:             c = qc;
    1:         INIT_TOKENBUF();
    1:         for (;;) {
    1:             ADD_TO_TOKENBUF(c);
    1:             c = GetChar(ts);
    1:             if (c == '\\') {
12751:                 qc = GetUnicodeEscape(ts);
12751:                 if (!JS_ISIDENT(qc))
    1:                     break;
12751:                 c = qc;
    1:                 hadUnicodeEscape = JS_TRUE;
    1:             } else {
    1:                 if (!JS_ISIDENT(c))
    1:                     break;
    1:             }
    1:         }
    1:         UngetChar(ts, c);
    1: 
    1:         /*
    1:          * Check for keywords unless we saw Unicode escape or parser asks
    1:          * to ignore keywords.
    1:          */
    1:         if (!hadUnicodeEscape &&
    1:             !(ts->flags & TSF_KEYWORD_IS_NAME) &&
    1:             TOKENBUF_OK() &&
    1:             (kw = FindKeyword(TOKENBUF_BASE(), TOKENBUF_LENGTH()))) {
    1:             if (kw->tokentype == TOK_RESERVED) {
 7984:                 if (!js_ReportCompileErrorNumber(cx, ts, NULL,
    1:                                                  JSREPORT_WARNING |
    1:                                                  JSREPORT_STRICT,
    1:                                                  JSMSG_RESERVED_ID,
    1:                                                  kw->chars)) {
    1:                     goto error;
    1:                 }
    1:             } else if (kw->version <= JSVERSION_NUMBER(cx)) {
    1:                 tt = kw->tokentype;
    1:                 tp->t_op = (JSOp) kw->op;
    1:                 goto out;
    1:             }
    1:         }
    1: 
    1:         atom = TOKENBUF_TO_ATOM();
    1:         if (!atom)
    1:             goto error;
    1:         tp->t_op = JSOP_NAME;
    1:         tp->t_atom = atom;
    1:         tt = TOK_NAME;
    1:         goto out;
    1:     }
    1: 
    1:     if (JS7_ISDEC(c) || (c == '.' && JS7_ISDEC(PeekChar(ts)))) {
    1:         jsint radix;
    1:         const jschar *endptr;
    1:         jsdouble dval;
    1: 
    1:         radix = 10;
    1:         INIT_TOKENBUF();
    1: 
    1:         if (c == '0') {
    1:             ADD_TO_TOKENBUF(c);
    1:             c = GetChar(ts);
    1:             if (JS_TOLOWER(c) == 'x') {
    1:                 ADD_TO_TOKENBUF(c);
    1:                 c = GetChar(ts);
    1:                 radix = 16;
    1:             } else if (JS7_ISDEC(c)) {
    1:                 radix = 8;
    1:             }
    1:         }
    1: 
    1:         while (JS7_ISHEX(c)) {
    1:             if (radix < 16) {
    1:                 if (JS7_ISLET(c))
    1:                     break;
    1: 
    1:                 /*
    1:                  * We permit 08 and 09 as decimal numbers, which makes our
    1:                  * behaviour a superset of the ECMA numeric grammar.  We might
    1:                  * not always be so permissive, so we warn about it.
    1:                  */
    1:                 if (radix == 8 && c >= '8') {
 7984:                     if (!js_ReportCompileErrorNumber(cx, ts, NULL,
    1:                                                      JSREPORT_WARNING,
    1:                                                      JSMSG_BAD_OCTAL,
    1:                                                      c == '8' ? "08" : "09")) {
    1:                         goto error;
    1:                     }
    1:                     radix = 10;
    1:                 }
    1:             }
    1:             ADD_TO_TOKENBUF(c);
    1:             c = GetChar(ts);
    1:         }
    1: 
    1:         if (radix == 10 && (c == '.' || JS_TOLOWER(c) == 'e')) {
    1:             if (c == '.') {
    1:                 do {
    1:                     ADD_TO_TOKENBUF(c);
    1:                     c = GetChar(ts);
    1:                 } while (JS7_ISDEC(c));
    1:             }
    1:             if (JS_TOLOWER(c) == 'e') {
    1:                 ADD_TO_TOKENBUF(c);
    1:                 c = GetChar(ts);
    1:                 if (c == '+' || c == '-') {
    1:                     ADD_TO_TOKENBUF(c);
    1:                     c = GetChar(ts);
    1:                 }
    1:                 if (!JS7_ISDEC(c)) {
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_MISSING_EXPONENT);
    1:                     goto error;
    1:                 }
    1:                 do {
    1:                     ADD_TO_TOKENBUF(c);
    1:                     c = GetChar(ts);
    1:                 } while (JS7_ISDEC(c));
    1:             }
    1:         }
    1: 
    1:         /* Put back the next char and NUL-terminate tokenbuf for js_strto*. */
    1:         UngetChar(ts, c);
    1:         ADD_TO_TOKENBUF(0);
    1: 
    1:         if (!TOKENBUF_OK())
    1:             goto error;
    1:         if (radix == 10) {
 4281:             if (!js_strtod(cx, TOKENBUF_BASE(), TOKENBUF_END(),
 4281:                            &endptr, &dval)) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_OUT_OF_MEMORY);
    1:                 goto error;
    1:             }
    1:         } else {
 4281:             if (!js_strtointeger(cx, TOKENBUF_BASE(), TOKENBUF_END(),
 4281:                                  &endptr, radix, &dval)) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_OUT_OF_MEMORY);
    1:                 goto error;
    1:             }
    1:         }
    1:         tp->t_dval = dval;
    1:         tt = TOK_NUMBER;
    1:         goto out;
    1:     }
    1: 
    1:     if (c == '"' || c == '\'') {
    1:         qc = c;
    1:         INIT_TOKENBUF();
    1:         while ((c = GetChar(ts)) != qc) {
    1:             if (c == '\n' || c == EOF) {
    1:                 UngetChar(ts, c);
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_UNTERMINATED_STRING);
    1:                 goto error;
    1:             }
    1:             if (c == '\\') {
    1:                 switch (c = GetChar(ts)) {
    1:                   case 'b': c = '\b'; break;
    1:                   case 'f': c = '\f'; break;
    1:                   case 'n': c = '\n'; break;
    1:                   case 'r': c = '\r'; break;
    1:                   case 't': c = '\t'; break;
    1:                   case 'v': c = '\v'; break;
    1: 
    1:                   default:
    1:                     if ('0' <= c && c < '8') {
    1:                         int32 val = JS7_UNDEC(c);
    1: 
    1:                         c = PeekChar(ts);
    1:                         if ('0' <= c && c < '8') {
    1:                             val = 8 * val + JS7_UNDEC(c);
    1:                             GetChar(ts);
    1:                             c = PeekChar(ts);
    1:                             if ('0' <= c && c < '8') {
    1:                                 int32 save = val;
    1:                                 val = 8 * val + JS7_UNDEC(c);
    1:                                 if (val <= 0377)
    1:                                     GetChar(ts);
    1:                                 else
    1:                                     val = save;
    1:                             }
    1:                         }
    1: 
    1:                         c = (jschar)val;
    1:                     } else if (c == 'u') {
    1:                         jschar cp[4];
    1:                         if (PeekChars(ts, 4, cp) &&
    1:                             JS7_ISHEX(cp[0]) && JS7_ISHEX(cp[1]) &&
    1:                             JS7_ISHEX(cp[2]) && JS7_ISHEX(cp[3])) {
    1:                             c = (((((JS7_UNHEX(cp[0]) << 4)
    1:                                     + JS7_UNHEX(cp[1])) << 4)
    1:                                   + JS7_UNHEX(cp[2])) << 4)
    1:                                 + JS7_UNHEX(cp[3]);
    1:                             SkipChars(ts, 4);
    1:                         }
    1:                     } else if (c == 'x') {
    1:                         jschar cp[2];
    1:                         if (PeekChars(ts, 2, cp) &&
    1:                             JS7_ISHEX(cp[0]) && JS7_ISHEX(cp[1])) {
    1:                             c = (JS7_UNHEX(cp[0]) << 4) + JS7_UNHEX(cp[1]);
    1:                             SkipChars(ts, 2);
    1:                         }
    1:                     } else if (c == '\n') {
    1:                         /* ECMA follows C by removing escaped newlines. */
    1:                         continue;
    1:                     }
    1:                     break;
    1:                 }
    1:             }
    1:             ADD_TO_TOKENBUF(c);
    1:         }
    1:         atom = TOKENBUF_TO_ATOM();
    1:         if (!atom)
    1:             goto error;
    1:         tp->pos.end.lineno = (uint16)ts->lineno;
    1:         tp->t_op = JSOP_STRING;
    1:         tp->t_atom = atom;
    1:         tt = TOK_STRING;
    1:         goto out;
    1:     }
    1: 
    1:     switch (c) {
    1:       case '\n': tt = TOK_EOL; goto eol_out;
    1:       case ';':  tt = TOK_SEMI; break;
    1:       case '[':  tt = TOK_LB; break;
    1:       case ']':  tt = TOK_RB; break;
    1:       case '{':  tt = TOK_LC; break;
    1:       case '}':  tt = TOK_RC; break;
    1:       case '(':  tt = TOK_LP; break;
    1:       case ')':  tt = TOK_RP; break;
    1:       case ',':  tt = TOK_COMMA; break;
    1:       case '?':  tt = TOK_HOOK; break;
    1: 
    1:       case '.':
    1: #if JS_HAS_XML_SUPPORT
    1:         if (MatchChar(ts, c))
    1:             tt = TOK_DBLDOT;
    1:         else
    1: #endif
    1:             tt = TOK_DOT;
    1:         break;
    1: 
    1:       case ':':
    1: #if JS_HAS_XML_SUPPORT
    1:         if (MatchChar(ts, c)) {
    1:             tt = TOK_DBLCOLON;
    1:             break;
    1:         }
    1: #endif
    1:         /*
    1:          * Default so compiler can modify to JSOP_GETTER if 'p getter: v' in an
    1:          * object initializer, likewise for setter.
    1:          */
    1:         tp->t_op = JSOP_NOP;
    1:         tt = TOK_COLON;
    1:         break;
    1: 
    1:       case '|':
    1:         if (MatchChar(ts, c)) {
    1:             tt = TOK_OR;
    1:         } else if (MatchChar(ts, '=')) {
    1:             tp->t_op = JSOP_BITOR;
    1:             tt = TOK_ASSIGN;
    1:         } else {
    1:             tt = TOK_BITOR;
    1:         }
    1:         break;
    1: 
    1:       case '^':
    1:         if (MatchChar(ts, '=')) {
    1:             tp->t_op = JSOP_BITXOR;
    1:             tt = TOK_ASSIGN;
    1:         } else {
    1:             tt = TOK_BITXOR;
    1:         }
    1:         break;
    1: 
    1:       case '&':
    1:         if (MatchChar(ts, c)) {
    1:             tt = TOK_AND;
    1:         } else if (MatchChar(ts, '=')) {
    1:             tp->t_op = JSOP_BITAND;
    1:             tt = TOK_ASSIGN;
    1:         } else {
    1:             tt = TOK_BITAND;
    1:         }
    1:         break;
    1: 
    1:       case '=':
    1:         if (MatchChar(ts, c)) {
    1:             tp->t_op = MatchChar(ts, c) ? JSOP_STRICTEQ : JSOP_EQ;
    1:             tt = TOK_EQOP;
    1:         } else {
    1:             tp->t_op = JSOP_NOP;
    1:             tt = TOK_ASSIGN;
    1:         }
    1:         break;
    1: 
    1:       case '!':
    1:         if (MatchChar(ts, '=')) {
    1:             tp->t_op = MatchChar(ts, '=') ? JSOP_STRICTNE : JSOP_NE;
    1:             tt = TOK_EQOP;
    1:         } else {
    1:             tp->t_op = JSOP_NOT;
    1:             tt = TOK_UNARYOP;
    1:         }
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case '@':
    1:         tt = TOK_AT;
    1:         break;
    1: #endif
    1: 
    1:       case '<':
    1: #if JS_HAS_XML_SUPPORT
    1:         /*
    1:          * After much testing, it's clear that Postel's advice to protocol
    1:          * designers ("be liberal in what you accept, and conservative in what
    1:          * you send") invites a natural-law repercussion for JS as "protocol":
    1:          *
    1:          * "If you are liberal in what you accept, others will utterly fail to
    1:          *  be conservative in what they send."
    1:          *
    1:          * Which means you will get <!-- comments to end of line in the middle
    1:          * of .js files, and after if conditions whose then statements are on
    1:          * the next line, and other wonders.  See at least the following bugs:
    1:          * https://bugzilla.mozilla.org/show_bug.cgi?id=309242
    1:          * https://bugzilla.mozilla.org/show_bug.cgi?id=309712
    1:          * https://bugzilla.mozilla.org/show_bug.cgi?id=310993
    1:          *
    1:          * So without JSOPTION_XML, we never scan an XML comment or CDATA
    1:          * literal.  We always scan <! as the start of an HTML comment hack
    1:          * to end of line, used since Netscape 2 to hide script tag content
    1:          * from script-unaware browsers.
    1:          */
    1:         if ((ts->flags & TSF_OPERAND) &&
    1:             (JS_HAS_XML_OPTION(cx) || PeekChar(ts) != '!')) {
    1:             /* Check for XML comment or CDATA section. */
    1:             if (MatchChar(ts, '!')) {
    1:                 INIT_TOKENBUF();
    1: 
    1:                 /* Scan XML comment. */
    1:                 if (MatchChar(ts, '-')) {
    1:                     if (!MatchChar(ts, '-'))
    1:                         goto bad_xml_markup;
    1:                     while ((c = GetChar(ts)) != '-' || !MatchChar(ts, '-')) {
    1:                         if (c == EOF)
    1:                             goto bad_xml_markup;
    1:                         ADD_TO_TOKENBUF(c);
    1:                     }
    1:                     tt = TOK_XMLCOMMENT;
    1:                     tp->t_op = JSOP_XMLCOMMENT;
    1:                     goto finish_xml_markup;
    1:                 }
    1: 
    1:                 /* Scan CDATA section. */
    1:                 if (MatchChar(ts, '[')) {
    1:                     jschar cp[6];
    1:                     if (PeekChars(ts, 6, cp) &&
    1:                         cp[0] == 'C' &&
    1:                         cp[1] == 'D' &&
    1:                         cp[2] == 'A' &&
    1:                         cp[3] == 'T' &&
    1:                         cp[4] == 'A' &&
    1:                         cp[5] == '[') {
    1:                         SkipChars(ts, 6);
    1:                         while ((c = GetChar(ts)) != ']' ||
    1:                                !PeekChars(ts, 2, cp) ||
    1:                                cp[0] != ']' ||
    1:                                cp[1] != '>') {
    1:                             if (c == EOF)
    1:                                 goto bad_xml_markup;
    1:                             ADD_TO_TOKENBUF(c);
    1:                         }
    1:                         GetChar(ts);            /* discard ] but not > */
    1:                         tt = TOK_XMLCDATA;
    1:                         tp->t_op = JSOP_XMLCDATA;
    1:                         goto finish_xml_markup;
    1:                     }
    1:                     goto bad_xml_markup;
    1:                 }
    1:             }
    1: 
    1:             /* Check for processing instruction. */
    1:             if (MatchChar(ts, '?')) {
 3164:                 inTarget = JS_TRUE;
 3164:                 targetLength = 0;
 3164:                 contentIndex = -1;
    1: 
    1:                 INIT_TOKENBUF();
    1:                 while ((c = GetChar(ts)) != '?' || PeekChar(ts) != '>') {
    1:                     if (c == EOF)
    1:                         goto bad_xml_markup;
    1:                     if (inTarget) {
    1:                         if (JS_ISXMLSPACE(c)) {
    1:                             if (TOKENBUF_LENGTH() == 0)
    1:                                 goto bad_xml_markup;
    1:                             inTarget = JS_FALSE;
    1:                         } else {
    1:                             if (!((TOKENBUF_LENGTH() == 0)
    1:                                   ? JS_ISXMLNSSTART(c)
    1:                                   : JS_ISXMLNS(c))) {
    1:                                 goto bad_xml_markup;
    1:                             }
    1:                             ++targetLength;
    1:                         }
    1:                     } else {
    1:                         if (contentIndex < 0 && !JS_ISXMLSPACE(c))
    1:                             contentIndex = TOKENBUF_LENGTH();
    1:                     }
    1:                     ADD_TO_TOKENBUF(c);
    1:                 }
    1:                 if (targetLength == 0)
    1:                     goto bad_xml_markup;
    1:                 if (!TOKENBUF_OK())
    1:                     goto error;
    1:                 if (contentIndex < 0) {
    1:                     atom = cx->runtime->atomState.emptyAtom;
    1:                 } else {
    1:                     atom = js_AtomizeChars(cx,
    1:                                            &TOKENBUF_CHAR(contentIndex),
    1:                                            TOKENBUF_LENGTH() - contentIndex,
    1:                                            0);
    1:                     if (!atom)
    1:                         goto error;
    1:                 }
    1:                 TRIM_TOKENBUF(targetLength);
    1:                 tp->t_atom2 = atom;
    1:                 tt = TOK_XMLPI;
    1: 
    1:         finish_xml_markup:
    1:                 if (!MatchChar(ts, '>'))
    1:                     goto bad_xml_markup;
    1:                 atom = TOKENBUF_TO_ATOM();
    1:                 if (!atom)
    1:                     goto error;
    1:                 tp->t_atom = atom;
    1:                 tp->pos.end.lineno = (uint16)ts->lineno;
    1:                 goto out;
    1:             }
    1: 
    1:             /* An XML start-of-tag character. */
    1:             tt = MatchChar(ts, '/') ? TOK_XMLETAGO : TOK_XMLSTAGO;
    1:             goto out;
    1: 
    1:         bad_xml_markup:
 7984:             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                         JSMSG_BAD_XML_MARKUP);
    1:             goto error;
    1:         }
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1:         /* NB: treat HTML begin-comment as comment-till-end-of-line */
    1:         if (MatchChar(ts, '!')) {
    1:             if (MatchChar(ts, '-')) {
    1:                 if (MatchChar(ts, '-')) {
    1:                     ts->flags |= TSF_IN_HTML_COMMENT;
    1:                     goto skipline;
    1:                 }
    1:                 UngetChar(ts, '-');
    1:             }
    1:             UngetChar(ts, '!');
    1:         }
    1:         if (MatchChar(ts, c)) {
    1:             tp->t_op = JSOP_LSH;
    1:             tt = MatchChar(ts, '=') ? TOK_ASSIGN : TOK_SHOP;
    1:         } else {
    1:             tp->t_op = MatchChar(ts, '=') ? JSOP_LE : JSOP_LT;
    1:             tt = TOK_RELOP;
    1:         }
    1:         break;
    1: 
    1:       case '>':
    1:         if (MatchChar(ts, c)) {
    1:             tp->t_op = MatchChar(ts, c) ? JSOP_URSH : JSOP_RSH;
    1:             tt = MatchChar(ts, '=') ? TOK_ASSIGN : TOK_SHOP;
    1:         } else {
    1:             tp->t_op = MatchChar(ts, '=') ? JSOP_GE : JSOP_GT;
    1:             tt = TOK_RELOP;
    1:         }
    1:         break;
    1: 
    1:       case '*':
    1:         tp->t_op = JSOP_MUL;
    1:         tt = MatchChar(ts, '=') ? TOK_ASSIGN : TOK_STAR;
    1:         break;
    1: 
    1:       case '/':
    1:         if (MatchChar(ts, '/')) {
    1:             /*
    1:              * Hack for source filters such as the Mozilla XUL preprocessor:
    1:              * "//@line 123\n" sets the number of the *next* line after the
    1:              * comment to 123.
    1:              */
    1:             if (JS_HAS_ATLINE_OPTION(cx)) {
    1:                 jschar cp[5];
    1:                 uintN i, line, temp;
    1:                 char filename[1024];
    1: 
    1:                 if (PeekChars(ts, 5, cp) &&
    1:                     cp[0] == '@' &&
    1:                     cp[1] == 'l' &&
    1:                     cp[2] == 'i' &&
    1:                     cp[3] == 'n' &&
    1:                     cp[4] == 'e') {
    1:                     SkipChars(ts, 5);
17884:                     while ((c = GetChar(ts)) != '\n' && ScanAsSpace((jschar)c))
    1:                         continue;
    1:                     if (JS7_ISDEC(c)) {
    1:                         line = JS7_UNDEC(c);
    1:                         while ((c = GetChar(ts)) != EOF && JS7_ISDEC(c)) {
    1:                             temp = 10 * line + JS7_UNDEC(c);
    1:                             if (temp < line) {
    1:                                 /* Ignore overlarge line numbers. */
    1:                                 goto skipline;
    1:                             }
    1:                             line = temp;
    1:                         }
17884:                         while (c != '\n' && ScanAsSpace((jschar)c))
    1:                             c = GetChar(ts);
    1:                         i = 0;
    1:                         if (c == '"') {
    1:                             while ((c = GetChar(ts)) != EOF && c != '"') {
    1:                                 if (c == '\n') {
    1:                                     UngetChar(ts, c);
    1:                                     goto skipline;
    1:                                 }
    1:                                 if ((c >> 8) != 0 || i >= sizeof filename - 1)
    1:                                     goto skipline;
    1:                                 filename[i++] = (char) c;
    1:                             }
    1:                             if (c == '"') {
    1:                                 while ((c = GetChar(ts)) != '\n' &&
17884:                                        ScanAsSpace((jschar)c)) {
    1:                                     continue;
    1:                                 }
    1:                             }
    1:                         }
    1:                         filename[i] = '\0';
    1:                         if (c == '\n') {
    1:                             if (i > 0) {
    1:                                 if (ts->flags & TSF_OWNFILENAME)
    1:                                     JS_free(cx, (void *) ts->filename);
    1:                                 ts->filename = JS_strdup(cx, filename);
    1:                                 if (!ts->filename)
    1:                                     goto error;
    1:                                 ts->flags |= TSF_OWNFILENAME;
    1:                             }
    1:                             ts->lineno = line;
    1:                         }
    1:                     }
    1:                     UngetChar(ts, c);
    1:                 }
    1:             }
    1: 
    1: skipline:
    1:             /* Optimize line skipping if we are not in an HTML comment. */
    1:             if (ts->flags & TSF_IN_HTML_COMMENT) {
    1:                 while ((c = GetChar(ts)) != EOF && c != '\n') {
    1:                     if (c == '-' && MatchChar(ts, '-') && MatchChar(ts, '>'))
    1:                         ts->flags &= ~TSF_IN_HTML_COMMENT;
    1:                 }
    1:             } else {
    1:                 while ((c = GetChar(ts)) != EOF && c != '\n')
    1:                     continue;
    1:             }
    1:             UngetChar(ts, c);
    1:             ts->cursor = (ts->cursor - 1) & NTOKENS_MASK;
    1:             goto retry;
    1:         }
    1: 
    1:         if (MatchChar(ts, '*')) {
    1:             while ((c = GetChar(ts)) != EOF &&
    1:                    !(c == '*' && MatchChar(ts, '/'))) {
    1:                 /* Ignore all characters until comment close. */
    1:             }
    1:             if (c == EOF) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_UNTERMINATED_COMMENT);
    1:                 goto error;
    1:             }
    1:             ts->cursor = (ts->cursor - 1) & NTOKENS_MASK;
    1:             goto retry;
    1:         }
    1: 
    1:         if (ts->flags & TSF_OPERAND) {
    1:             uintN flags;
    1:             JSBool inCharClass = JS_FALSE;
    1: 
    1:             INIT_TOKENBUF();
    1:             for (;;) {
    1:                 c = GetChar(ts);
    1:                 if (c == '\n' || c == EOF) {
    1:                     UngetChar(ts, c);
 7984:                     js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                                 JSMSG_UNTERMINATED_REGEXP);
    1:                     goto error;
    1:                 }
    1:                 if (c == '\\') {
    1:                     ADD_TO_TOKENBUF(c);
    1:                     c = GetChar(ts);
    1:                 } else if (c == '[') {
    1:                     inCharClass = JS_TRUE;
    1:                 } else if (c == ']') {
    1:                     inCharClass = JS_FALSE;
    1:                 } else if (c == '/' && !inCharClass) {
    1:                     /* For compat with IE, allow unescaped / in char classes. */
    1:                     break;
    1:                 }
    1:                 ADD_TO_TOKENBUF(c);
    1:             }
    1:             for (flags = 0; ; ) {
    1:                 c = PeekChar(ts);
    1:                 if (c == 'g')
    1:                     flags |= JSREG_GLOB;
    1:                 else if (c == 'i')
    1:                     flags |= JSREG_FOLD;
    1:                 else if (c == 'm')
    1:                     flags |= JSREG_MULTILINE;
    1:                 else if (c == 'y')
    1:                     flags |= JSREG_STICKY;
    1:                 else
    1:                     break;
    1:                 GetChar(ts);
    1:             }
    1:             c = PeekChar(ts);
    1:             if (JS7_ISLET(c)) {
    1:                 tp->ptr = ts->linebuf.ptr - 1;
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_BAD_REGEXP_FLAG);
    1:                 (void) GetChar(ts);
    1:                 goto error;
    1:             }
    1:             /* XXXbe fix jsregexp.c so it doesn't depend on NUL termination */
    1:             if (!TOKENBUF_OK())
    1:                 goto error;
    1:             NUL_TERM_TOKENBUF();
 6561:             tp->t_reflags = flags;
 6561:             tt = TOK_REGEXP;
    1:             break;
    1:         }
    1: 
    1:         tp->t_op = JSOP_DIV;
    1:         tt = MatchChar(ts, '=') ? TOK_ASSIGN : TOK_DIVOP;
    1:         break;
    1: 
    1:       case '%':
    1:         tp->t_op = JSOP_MOD;
    1:         tt = MatchChar(ts, '=') ? TOK_ASSIGN : TOK_DIVOP;
    1:         break;
    1: 
    1:       case '~':
    1:         tp->t_op = JSOP_BITNOT;
    1:         tt = TOK_UNARYOP;
    1:         break;
    1: 
    1:       case '+':
    1:         if (MatchChar(ts, '=')) {
    1:             tp->t_op = JSOP_ADD;
    1:             tt = TOK_ASSIGN;
    1:         } else if (MatchChar(ts, c)) {
    1:             tt = TOK_INC;
    1:         } else {
    1:             tp->t_op = JSOP_POS;
    1:             tt = TOK_PLUS;
    1:         }
    1:         break;
    1: 
    1:       case '-':
    1:         if (MatchChar(ts, '=')) {
    1:             tp->t_op = JSOP_SUB;
    1:             tt = TOK_ASSIGN;
    1:         } else if (MatchChar(ts, c)) {
    1:             if (PeekChar(ts) == '>' && !(ts->flags & TSF_DIRTYLINE)) {
    1:                 ts->flags &= ~TSF_IN_HTML_COMMENT;
    1:                 goto skipline;
    1:             }
    1:             tt = TOK_DEC;
    1:         } else {
    1:             tp->t_op = JSOP_NEG;
    1:             tt = TOK_MINUS;
    1:         }
    1:         break;
    1: 
    1: #if JS_HAS_SHARP_VARS
    1:       case '#':
    1:       {
    1:         uint32 n;
    1: 
    1:         c = GetChar(ts);
    1:         if (!JS7_ISDEC(c)) {
    1:             UngetChar(ts, c);
    1:             goto badchar;
    1:         }
    1:         n = (uint32)JS7_UNDEC(c);
    1:         for (;;) {
    1:             c = GetChar(ts);
    1:             if (!JS7_ISDEC(c))
    1:                 break;
    1:             n = 10 * n + JS7_UNDEC(c);
    1:             if (n >= UINT16_LIMIT) {
 7984:                 js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                             JSMSG_SHARPVAR_TOO_BIG);
    1:                 goto error;
    1:             }
    1:         }
    1:         tp->t_dval = (jsdouble) n;
    1:         if (JS_HAS_STRICT_OPTION(cx) &&
    1:             (c == '=' || c == '#')) {
    1:             char buf[20];
    1:             JS_snprintf(buf, sizeof buf, "#%u%c", n, c);
 7984:             if (!js_ReportCompileErrorNumber(cx, ts, NULL,
    1:                                              JSREPORT_WARNING |
    1:                                              JSREPORT_STRICT,
    1:                                              JSMSG_DEPRECATED_USAGE,
    1:                                              buf)) {
    1:                 goto error;
    1:             }
    1:         }
    1:         if (c == '=')
    1:             tt = TOK_DEFSHARP;
    1:         else if (c == '#')
    1:             tt = TOK_USESHARP;
    1:         else
    1:             goto badchar;
    1:         break;
    1:       }
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
    1: #if JS_HAS_SHARP_VARS || JS_HAS_XML_SUPPORT
    1:       badchar:
    1: #endif
    1: 
    1:       default:
 7984:         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
    1:                                     JSMSG_ILLEGAL_CHARACTER);
    1:         goto error;
    1:     }
    1: 
    1: out:
    1:     JS_ASSERT(tt != TOK_EOL);
    1:     ts->flags |= TSF_DIRTYLINE;
    1: 
    1: eol_out:
    1:     if (!STRING_BUFFER_OK(&ts->tokenbuf))
    1:         tt = TOK_ERROR;
    1:     JS_ASSERT(tt < TOK_LIMIT);
    1:     tp->pos.end.index = ts->linepos +
    1:                         PTRDIFF(ts->linebuf.ptr, ts->linebuf.base, jschar) -
    1:                         ts->ungetpos;
    1:     tp->type = tt;
    1:     return tt;
    1: 
    1: error:
    1:     tt = TOK_ERROR;
    1:     ts->flags |= TSF_ERROR;
    1:     goto out;
    1: 
    1: #undef INIT_TOKENBUF
    1: #undef TOKENBUF_LENGTH
    1: #undef TOKENBUF_OK
    1: #undef TOKENBUF_TO_ATOM
    1: #undef ADD_TO_TOKENBUF
    1: #undef TOKENBUF_BASE
    1: #undef TOKENBUF_CHAR
    1: #undef TRIM_TOKENBUF
    1: #undef NUL_TERM_TOKENBUF
    1: }
    1: 
    1: void
    1: js_UngetToken(JSTokenStream *ts)
    1: {
    1:     JS_ASSERT(ts->lookahead < NTOKENS_MASK);
    1:     ts->lookahead++;
    1:     ts->cursor = (ts->cursor - 1) & NTOKENS_MASK;
    1: }
    1: 
    1: JSBool
    1: js_MatchToken(JSContext *cx, JSTokenStream *ts, JSTokenType tt)
    1: {
    1:     if (js_GetToken(cx, ts) == tt)
    1:         return JS_TRUE;
    1:     js_UngetToken(ts);
    1:     return JS_FALSE;
    1: }
