129708: # This Source Code Form is subject to the terms of the Mozilla Public
129708: # License, v. 2.0. If a copy of the MPL was not distributed with this
129708: # file, You can obtain one at http://mozilla.org/MPL/2.0/.
129708: 
129708: from __future__ import unicode_literals
129708: 
163244: import json
156517: import logging
130928: import os
163244: import traceback
163244: import sys
130928: 
156517: from mach.mixin.logging import LoggingMixin
156517: 
156517: import mozpack.path as mozpath
163244: import manifestparser
163244: 
176554: from mozpack.files import FileFinder
176554: 
130928: from .data import (
135313:     ConfigFileSubstitution,
162726:     Defines,
130928:     DirectoryTraversal,
143209:     Exports,
160288:     GeneratedEventWebIDLFile,
166712:     GeneratedInclude,
160247:     GeneratedWebIDLFile,
168104:     HeaderFileSubstitution,
168744:     HostProgram,
168744:     HostSimpleProgram,
166365:     InstallationTarget,
150550:     IPDLFile,
171741:     LibraryDefinition,
159584:     LocalInclude,
163522:     PreprocessedTestWebIDLFile,
160247:     PreprocessedWebIDLFile,
143209:     Program,
143209:     ReaderSummary,
167037:     SandboxWrapped,
168743:     SimpleProgram,
160247:     TestWebIDLFile,
163244:     TestManifest,
135313:     VariablePassthru,
163244:     WebIDLFile,
156517:     XPIDLFile,
130928: )
130928: 
156517: from .reader import (
156517:     MozbuildSandbox,
156517:     SandboxValidationError,
156517: )
129708: 
129708: 
156517: class TreeMetadataEmitter(LoggingMixin):
129708:     """Converts the executed mozbuild files into data structures.
129708: 
129708:     This is a bridge between reader.py and data.py. It takes what was read by
129708:     reader.BuildReader and converts it into the classes defined in the data
129708:     module.
129708:     """
129708: 
129708:     def __init__(self, config):
156517:         self.populate_logger()
156517: 
129708:         self.config = config
129708: 
163244:         # TODO add mozinfo into config or somewhere else.
163244:         mozinfo_path = os.path.join(config.topobjdir, 'mozinfo.json')
163244:         if os.path.exists(mozinfo_path):
163244:             self.mozinfo = json.load(open(mozinfo_path, 'rt'))
163244:         else:
163244:             self.mozinfo = {}
163244: 
171741:         self._libs = {}
171741:         self._final_libs = []
171741: 
129708:     def emit(self, output):
129708:         """Convert the BuildReader output into data structures.
129708: 
129708:         The return value from BuildReader.read_topsrcdir() (a generator) is
129708:         typically fed into this function.
129708:         """
134922:         file_count = 0
134922:         execution_time = 0.0
171754:         sandboxes = {}
134922: 
129708:         for out in output:
129708:             if isinstance(out, MozbuildSandbox):
171754:                 # Keep all sandboxes around, we will need them later.
171789:                 sandboxes[out['OBJDIR']] = out
171754: 
129708:                 for o in self.emit_from_sandbox(out):
129708:                     yield o
169808:                     if not o._ack:
169808:                         raise Exception('Unhandled object of type %s' % type(o))
134922: 
134922:                 # Update the stats.
134922:                 file_count += len(out.all_paths)
134922:                 execution_time += out.execution_time
134922: 
129708:             else:
129708:                 raise Exception('Unhandled output type: %s' % out)
129708: 
171789:         for objdir, libname, final_lib in self._final_libs:
171741:             if final_lib not in self._libs:
171741:                 raise Exception('FINAL_LIBRARY in %s (%s) does not match any '
171789:                                 'LIBRARY_NAME' % (objdir, final_lib))
171741:             libs = self._libs[final_lib]
171741:             if len(libs) > 1:
171741:                 raise Exception('FINAL_LIBRARY in %s (%s) matches a '
171741:                                 'LIBRARY_NAME defined in multiple places (%s)' %
171789:                                 (objdir, final_lib, ', '.join(libs.keys())))
171789:             libs.values()[0].link_static_lib(objdir, libname)
171789:             self._libs[libname][objdir].refcount += 1
171754:             # The refcount can't go above 1 right now. It might in the future,
171754:             # but that will have to be specifically handled. At which point the
171754:             # refcount might have to be a list of referencees, for better error
171754:             # reporting.
171789:             assert self._libs[libname][objdir].refcount <= 1
171754: 
171754:         def recurse_libs(path, name):
171754:             for p, n in self._libs[name][path].static_libraries:
171754:                 yield p
171754:                 for q in recurse_libs(p, n):
171754:                     yield q
171741: 
171741:         for basename, libs in self._libs.items():
171754:             for path, libdef in libs.items():
171754:                 # For all root libraries (i.e. libraries that don't have a
171754:                 # FINAL_LIBRARY), record, for each static library it links
171754:                 # (recursively), that its FINAL_LIBRARY is that root library.
171754:                 if not libdef.refcount:
171754:                     for p in recurse_libs(path, basename):
171754:                         passthru = VariablePassthru(sandboxes[p])
171754:                         passthru.variables['FINAL_LIBRARY'] = basename
171754:                         yield passthru
171741:                 yield libdef
171741: 
134922:         yield ReaderSummary(file_count, execution_time)
134922: 
129708:     def emit_from_sandbox(self, sandbox):
129708:         """Convert a MozbuildSandbox to tree metadata objects.
129708: 
129708:         This is a generator of mozbuild.frontend.data.SandboxDerived instances.
129708:         """
129708:         # We always emit a directory traversal descriptor. This is needed by
129708:         # the recursive make backend.
129708:         for o in self._emit_directory_traversal_from_sandbox(sandbox): yield o
129708: 
130928:         for path in sandbox['CONFIGURE_SUBST_FILES']:
168104:             yield self._create_substitution(ConfigFileSubstitution, sandbox,
168104:                 path)
130928: 
168104:         for path in sandbox['CONFIGURE_DEFINE_FILES']:
168104:             yield self._create_substitution(HeaderFileSubstitution, sandbox,
168104:                 path)
130928: 
156517:         # XPIDL source files get processed and turned into .h and .xpt files.
156517:         # If there are multiple XPIDL files in a directory, they get linked
171750:         # together into a final .xpt, which has the name defined by
171750:         # XPIDL_MODULE.
156517:         xpidl_module = sandbox['XPIDL_MODULE']
156517: 
156517:         if sandbox['XPIDL_SOURCES'] and not xpidl_module:
171750:             raise SandboxValidationError('XPIDL_MODULE must be defined if '
171750:                 'XPIDL_SOURCES is defined.')
156517: 
156517:         if sandbox['XPIDL_SOURCES'] and sandbox['NO_DIST_INSTALL']:
156517:             self.log(logging.WARN, 'mozbuild_warning', dict(
156517:                 path=sandbox.main_path),
156517:                 '{path}: NO_DIST_INSTALL has no effect on XPIDL_SOURCES.')
156517: 
156517:         for idl in sandbox['XPIDL_SOURCES']:
156517:             yield XPIDLFile(sandbox, mozpath.join(sandbox['SRCDIR'], idl),
156517:                 xpidl_module)
156517: 
173057:         for symbol in ('SOURCES', 'HOST_SOURCES', 'UNIFIED_SOURCES'):
164434:             for src in (sandbox[symbol] or []):
164426:                 if not os.path.exists(os.path.join(sandbox['SRCDIR'], src)):
164426:                     raise SandboxValidationError('Reference to a file that '
164434:                         'doesn\'t exist in %s (%s) in %s'
164434:                         % (symbol, src, sandbox['RELATIVEDIR']))
164426: 
171744:         if sandbox.get('LIBXUL_LIBRARY') and sandbox.get('FORCE_STATIC_LIB'):
171744:             raise SandboxValidationError('LIBXUL_LIBRARY implies FORCE_STATIC_LIB')
171744: 
135313:         # Proxy some variables as-is until we have richer classes to represent
135313:         # them. We should aim to keep this set small because it violates the
135313:         # desired abstraction of the build definition away from makefiles.
135313:         passthru = VariablePassthru(sandbox)
144360:         varmap = dict(
144360:             # Makefile.in : moz.build
165814:             ANDROID_GENERATED_RESFILES='ANDROID_GENERATED_RESFILES',
172016:             ANDROID_RESFILES='ANDROID_RESFILES',
152816:             CPP_UNIT_TESTS='CPP_UNIT_TESTS',
159092:             EXPORT_LIBRARY='EXPORT_LIBRARY',
146594:             EXTRA_COMPONENTS='EXTRA_COMPONENTS',
147301:             EXTRA_JS_MODULES='EXTRA_JS_MODULES',
147184:             EXTRA_PP_COMPONENTS='EXTRA_PP_COMPONENTS',
154109:             EXTRA_PP_JS_MODULES='EXTRA_PP_JS_MODULES',
157586:             FAIL_ON_WARNINGS='FAIL_ON_WARNINGS',
172510:             FILES_PER_UNIFIED_FILE='FILES_PER_UNIFIED_FILE',
159092:             FORCE_SHARED_LIB='FORCE_SHARED_LIB',
159092:             FORCE_STATIC_LIB='FORCE_STATIC_LIB',
172832:             GENERATED_FILES='GENERATED_FILES',
146778:             HOST_LIBRARY_NAME='HOST_LIBRARY_NAME',
159092:             IS_COMPONENT='IS_COMPONENT',
147301:             JS_MODULES_PATH='JS_MODULES_PATH',
147464:             LIBS='LIBS',
157591:             LIBXUL_LIBRARY='LIBXUL_LIBRARY',
157599:             MSVC_ENABLE_PGO='MSVC_ENABLE_PGO',
157605:             NO_DIST_INSTALL='NO_DIST_INSTALL',
160549:             OS_LIBS='OS_LIBS',
147832:             SDK_LIBRARY='SDK_LIBRARY',
144360:         )
144360:         for mak, moz in varmap.items():
144360:             if sandbox[moz]:
144360:                 passthru.variables[mak] = sandbox[moz]
135313: 
168055:         # NO_VISIBILITY_FLAGS is slightly different
168055:         if sandbox['NO_VISIBILITY_FLAGS']:
168055:             passthru.variables['VISIBILITY_FLAGS'] = ''
168055: 
166802:         varmap = dict(
168468:             SOURCES={
168468:                 '.s': 'ASFILES',
168468:                 '.asm': 'ASFILES',
168468:                 '.c': 'CSRCS',
168476:                 '.m': 'CMSRCS',
168468:                 '.mm': 'CMMSRCS',
168468:                 '.cc': 'CPPSRCS',
168468:                 '.cpp': 'CPPSRCS',
168468:                 '.S': 'SSRCS',
168468:             },
168468:             HOST_SOURCES={
168468:                 '.c': 'HOST_CSRCS',
168477:                 '.mm': 'HOST_CMMSRCS',
168468:                 '.cc': 'HOST_CPPSRCS',
168468:                 '.cpp': 'HOST_CPPSRCS',
168468:             },
168468:             UNIFIED_SOURCES={
168468:                 '.c': 'UNIFIED_CSRCS',
170581:                 '.mm': 'UNIFIED_CMMSRCS',
168468:                 '.cc': 'UNIFIED_CPPSRCS',
168468:                 '.cpp': 'UNIFIED_CPPSRCS',
168468:             }
166802:         )
168471:         varmap.update(dict(('GENERATED_%s' % k, v) for k, v in varmap.items()
168471:                            if k in ('SOURCES', 'UNIFIED_SOURCES')))
168468:         for variable, mapping in varmap.items():
168468:             for f in sandbox[variable]:
168468:                 ext = os.path.splitext(f)[1]
168468:                 if ext not in mapping:
168468:                     raise SandboxValidationError('%s has an unknown file type in %s' % (f, sandbox['RELATIVEDIR']))
168468:                 l = passthru.variables.setdefault(mapping[ext], [])
168468:                 l.append(f)
168471:                 if variable.startswith('GENERATED_'):
168471:                     l = passthru.variables.setdefault('GARBAGE', [])
168471:                     l.append(f)
166802: 
175142:         no_pgo = sandbox.get('NO_PGO')
175142:         sources = sandbox.get('SOURCES', [])
175142:         no_pgo_sources = [f for f in sources if sources[f].no_pgo]
175142:         if no_pgo:
175142:             if no_pgo_sources:
175142:                 raise SandboxValidationError('NO_PGO and SOURCES[...].no_pgo cannot be set at the same time')
175142:             passthru.variables['NO_PROFILE_GUIDED_OPTIMIZE'] = no_pgo
175142:         if no_pgo_sources:
175142:             passthru.variables['NO_PROFILE_GUIDED_OPTIMIZE'] = no_pgo_sources
175142: 
139977:         exports = sandbox.get('EXPORTS')
139977:         if exports:
159381:             yield Exports(sandbox, exports,
159381:                 dist_install=not sandbox.get('NO_DIST_INSTALL', False))
139977: 
162726:         defines = sandbox.get('DEFINES')
162726:         if defines:
162726:             yield Defines(sandbox, defines)
162726: 
143209:         program = sandbox.get('PROGRAM')
143209:         if program:
143209:             yield Program(sandbox, program, sandbox['CONFIG']['BIN_SUFFIX'])
143209: 
168744:         program = sandbox.get('HOST_PROGRAM')
168744:         if program:
168744:             yield HostProgram(sandbox, program, sandbox['CONFIG']['HOST_BIN_SUFFIX'])
168744: 
168743:         for program in sandbox['SIMPLE_PROGRAMS']:
168743:             yield SimpleProgram(sandbox, program, sandbox['CONFIG']['BIN_SUFFIX'])
168743: 
168744:         for program in sandbox['HOST_SIMPLE_PROGRAMS']:
168744:             yield HostSimpleProgram(sandbox, program, sandbox['CONFIG']['HOST_BIN_SUFFIX'])
168744: 
160837:         simple_lists = [
160837:             ('GENERATED_EVENTS_WEBIDL_FILES', GeneratedEventWebIDLFile),
160837:             ('GENERATED_WEBIDL_FILES', GeneratedWebIDLFile),
160837:             ('IPDL_SOURCES', IPDLFile),
160837:             ('LOCAL_INCLUDES', LocalInclude),
166712:             ('GENERATED_INCLUDES', GeneratedInclude),
163522:             ('PREPROCESSED_TEST_WEBIDL_FILES', PreprocessedTestWebIDLFile),
160837:             ('PREPROCESSED_WEBIDL_FILES', PreprocessedWebIDLFile),
160837:             ('TEST_WEBIDL_FILES', TestWebIDLFile),
160837:             ('WEBIDL_FILES', WebIDLFile),
160837:         ]
160837:         for sandbox_var, klass in simple_lists:
160837:             for name in sandbox.get(sandbox_var, []):
160837:                 yield klass(sandbox, name)
160247: 
166365:         if sandbox.get('FINAL_TARGET') or sandbox.get('XPI_NAME') or \
166365:                 sandbox.get('DIST_SUBDIR'):
166365:             yield InstallationTarget(sandbox)
166365: 
171741:         libname = sandbox.get('LIBRARY_NAME')
171756:         final_lib = sandbox.get('FINAL_LIBRARY')
171756:         if not libname and final_lib:
171756:             # If no LIBRARY_NAME is given, create one.
171756:             libname = sandbox['RELATIVEDIR'].replace('/', '_')
171741:         if libname:
171789:             self._libs.setdefault(libname, {})[sandbox['OBJDIR']] = \
171741:                 LibraryDefinition(sandbox, libname)
171741: 
171741:         if final_lib:
171744:             if sandbox.get('FORCE_STATIC_LIB'):
171744:                 raise SandboxValidationError('FINAL_LIBRARY implies FORCE_STATIC_LIB')
171789:             self._final_libs.append((sandbox['OBJDIR'], libname, final_lib))
171744:             passthru.variables['FORCE_STATIC_LIB'] = True
171741: 
163244:         # While there are multiple test manifests, the behavior is very similar
163244:         # across them. We enforce this by having common handling of all
163244:         # manifests and outputting a single class type with the differences
163244:         # described inside the instance.
163244:         #
163244:         # Keys are variable prefixes and values are tuples describing how these
163244:         # manifests should be handled:
163244:         #
163244:         #    (flavor, install_prefix, active)
163244:         #
163244:         # flavor identifies the flavor of this test.
163244:         # install_prefix is the path prefix of where to install the files in
163244:         #     the tests directory.
163244:         # active indicates whether to filter out inactive tests from the
163244:         #     manifest.
163244:         #
163244:         # We ideally don't filter out inactive tests. However, not every test
163244:         # harness can yet deal with test filtering. Once all harnesses can do
163244:         # this, this feature can be dropped.
163244:         test_manifests = dict(
163244:             A11Y=('a11y', 'testing/mochitest/a11y', True),
163244:             BROWSER_CHROME=('browser-chrome', 'testing/mochitest/browser', True),
164945:             METRO_CHROME=('metro-chrome', 'testing/mochitest/metro', True),
163244:             MOCHITEST=('mochitest', 'testing/mochitest/tests', True),
163244:             MOCHITEST_CHROME=('chrome', 'testing/mochitest/chrome', True),
164980:             MOCHITEST_WEBAPPRT_CHROME=('webapprt-chrome', 'testing/mochitest/webapprtChrome', True),
163446:             WEBRTC_SIGNALLING_TEST=('steeplechase', 'steeplechase', True),
163244:             XPCSHELL_TESTS=('xpcshell', 'xpcshell', False),
163244:         )
163244: 
163244:         for prefix, info in test_manifests.items():
163244:             for path in sandbox.get('%s_MANIFESTS' % prefix, []):
163244:                 for obj in self._process_test_manifest(sandbox, info, path):
163244:                     yield obj
163244: 
167037:         for name, jar in sandbox.get('JAVA_JAR_TARGETS', {}).items():
167037:             yield SandboxWrapped(sandbox, jar)
167037: 
171744:         if passthru.variables:
171744:             yield passthru
171744: 
168104:     def _create_substitution(self, cls, sandbox, path):
168104:         if os.path.isabs(path):
168104:             path = path[1:]
168104: 
168104:         sub = cls(sandbox)
168104:         sub.input_path = os.path.join(sandbox['SRCDIR'], '%s.in' % path)
168104:         sub.output_path = os.path.join(sandbox['OBJDIR'], path)
168104:         sub.relpath = path
168104: 
168104:         return sub
168104: 
163244:     def _process_test_manifest(self, sandbox, info, manifest_path):
163244:         flavor, install_prefix, filter_inactive = info
163244: 
163244:         manifest_path = os.path.normpath(manifest_path)
163244:         path = mozpath.normpath(mozpath.join(sandbox['SRCDIR'], manifest_path))
163244:         manifest_dir = mozpath.dirname(path)
163244:         manifest_reldir = mozpath.dirname(mozpath.relpath(path,
163515:             sandbox['TOPSRCDIR']))
163244: 
163244:         try:
163244:             m = manifestparser.TestManifest(manifests=[path], strict=True)
163244: 
163244:             if not m.tests:
163244:                 raise SandboxValidationError('Empty test manifest: %s'
163244:                     % path)
163244: 
163244:             obj = TestManifest(sandbox, path, m, flavor=flavor,
163244:                 install_prefix=install_prefix,
163244:                 relpath=mozpath.join(manifest_reldir, mozpath.basename(path)),
163244:                 dupe_manifest='dupe-manifest' in m.tests[0])
163244: 
163244:             filtered = m.tests
163244: 
163244:             if filter_inactive:
164222:                 filtered = m.active_tests(disabled=False, **self.mozinfo)
163244: 
163244:             out_dir = mozpath.join(install_prefix, manifest_reldir)
163244: 
176554:             finder = FileFinder(base=manifest_dir, find_executables=False)
176554: 
166648:             # "head" and "tail" lists.
166648:             # All manifests support support-files.
166648:             #
166648:             # Keep a set of already seen support file patterns, because
166648:             # repeatedly processing the patterns from the default section
166648:             # for every test is quite costly (see bug 922517).
166648:             extras = (('head', set()),
166648:                       ('tail', set()),
166648:                       ('support-files', set()))
166648: 
163244:             for test in filtered:
166496:                 obj.tests.append(test)
166496: 
163244:                 obj.installs[mozpath.normpath(test['path'])] = \
172472:                     mozpath.join(out_dir, test['relpath'])
163244: 
166648:                 for thing, seen in extras:
166648:                     value = test.get(thing, '')
166648:                     if value in seen:
166648:                         continue
166648:                     seen.add(value)
166648:                     for pattern in value.split():
163244:                         # We only support globbing on support-files because
163244:                         # the harness doesn't support * for head and tail.
176554:                         #
176554:                         # While we could feed everything through the finder, we
176554:                         # don't because we want explicitly listed files that
176554:                         # no longer exist to raise an error. The finder is also
176554:                         # slower than simple lookup.
163244:                         if '*' in pattern and thing == 'support-files':
176554:                             paths = [f[0] for f in finder.find(pattern)]
176554:                             if not paths:
176554:                                 raise SandboxValidationError('%s support-files '
176554:                                     'wildcard in %s returns no results.' % (
176554:                                     pattern, path))
176554: 
176554:                             for f in paths:
176554:                                 full = mozpath.normpath(mozpath.join(manifest_dir, f))
176554:                                 obj.installs[full] = mozpath.join(out_dir, f)
176554: 
163244:                         else:
163244:                             full = mozpath.normpath(mozpath.join(manifest_dir,
163244:                                 pattern))
172472:                             # Only install paths in our directory. This
172472:                             # rule is somewhat arbitrary and could be lifted.
172472:                             if not full.startswith(manifest_dir):
172472:                                 continue
172472: 
172472:                             obj.installs[full] = mozpath.join(out_dir, pattern)
163244: 
163244:             # We also copy the manifest into the output directory.
163244:             out_path = mozpath.join(out_dir, os.path.basename(manifest_path))
172472:             obj.installs[path] = out_path
163244: 
163244:             # Some manifests reference files that are auto generated as
163244:             # part of the build or shouldn't be installed for some
163244:             # reason. Here, we prune those files from the install set.
163244:             # FUTURE we should be able to detect autogenerated files from
163244:             # other build metadata. Once we do that, we can get rid of this.
163244:             for f in m.tests[0].get('generated-files', '').split():
163244:                 # We re-raise otherwise the stack trace isn't informative.
163244:                 try:
163244:                     del obj.installs[mozpath.join(manifest_dir, f)]
163244:                 except KeyError:
163244:                     raise SandboxValidationError('Error processing test '
163244:                         'manifest %s: entry in generated-files not present '
163244:                         'elsewhere in manifest: %s' % (path, f))
163244: 
163244:                 obj.external_installs.add(mozpath.join(out_dir, f))
163244: 
163244:             yield obj
163244:         except (AssertionError, Exception):
163244:             raise SandboxValidationError('Error processing test '
163244:                 'manifest file %s: %s' % (path,
163244:                     '\n'.join(traceback.format_exception(*sys.exc_info()))))
163244: 
129708:     def _emit_directory_traversal_from_sandbox(self, sandbox):
129708:         o = DirectoryTraversal(sandbox)
129708:         o.dirs = sandbox.get('DIRS', [])
129708:         o.parallel_dirs = sandbox.get('PARALLEL_DIRS', [])
129708:         o.tool_dirs = sandbox.get('TOOL_DIRS', [])
129708:         o.test_dirs = sandbox.get('TEST_DIRS', [])
129708:         o.test_tool_dirs = sandbox.get('TEST_TOOL_DIRS', [])
130926:         o.external_make_dirs = sandbox.get('EXTERNAL_MAKE_DIRS', [])
130926:         o.parallel_external_make_dirs = sandbox.get('PARALLEL_EXTERNAL_MAKE_DIRS', [])
162580:         o.is_tool_dir = sandbox.get('IS_TOOL_DIR', False)
164351:         o.affected_tiers = sandbox.get_affected_tiers()
129708: 
129708:         if 'TIERS' in sandbox:
129708:             for tier in sandbox['TIERS']:
158902:                 o.tier_dirs[tier] = sandbox['TIERS'][tier]['regular'] + \
158902:                     sandbox['TIERS'][tier]['external']
129708:                 o.tier_static_dirs[tier] = sandbox['TIERS'][tier]['static']
129708: 
129708:         yield o
