87457: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
87457:  * ***** BEGIN LICENSE BLOCK *****
87457:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
87457:  *
87457:  * The contents of this file are subject to the Mozilla Public License Version
87457:  * 1.1 (the "License"); you may not use this file except in compliance with
87457:  * the License. You may obtain a copy of the License at
87457:  * http://www.mozilla.org/MPL/
87457:  *
87457:  * Software distributed under the License is distributed on an "AS IS" basis,
87457:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
87457:  * for the specific language governing rights and limitations under the
87457:  * License.
87457:  *
87457:  * The Original Code is Mozilla Corporation code.
87457:  *
87457:  * The Initial Developer of the Original Code is Mozilla Foundation.
87457:  * Portions created by the Initial Developer are Copyright (C) 2011
87457:  * the Initial Developer. All Rights Reserved.
87457:  *
87457:  * Contributor(s):
87457:  *   Matt Woodrow <mwoodrow@mozilla.com>
87457:  *
87457:  * Alternatively, the contents of this file may be used under the terms of
87457:  * either the GNU General Public License Version 2 or later (the "GPL"), or
87457:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
87457:  * in which case the provisions of the GPL or the LGPL are applicable instead
87457:  * of those above. If you wish to allow use of your version of this file only
87457:  * under the terms of either the GPL or the LGPL, and not to allow others to
87457:  * use your version of this file under the terms of the MPL, indicate your
87457:  * decision by deleting the provisions above and replace them with the notice
87457:  * and other provisions required by the GPL or the LGPL. If you do not delete
87457:  * the provisions above, a recipient may use your version of this file under
87457:  * the terms of any one of the MPL, the GPL or the LGPL.
87457:  *
87457:  * ***** END LICENSE BLOCK ***** */
87457: 
87457: #include "ScaledFontBase.h"
88426: 
88426: #include "gfxFont.h"
88426: 
87457: #ifdef USE_SKIA
87457: #include "PathSkia.h"
87457: #include "skia/SkPaint.h"
87457: #include "skia/SkPath.h"
87457: #endif
88426: 
88426: #ifdef USE_CAIRO
88426: #include "PathCairo.h"
88426: #endif
88426: 
87457: #include <vector>
87457: #include <cmath>
88426: 
87457: using namespace std;
87457: 
87457: namespace mozilla {
87457: namespace gfx {
88426: 
87457: ScaledFontBase::~ScaledFontBase()
87457: {
87457: #ifdef USE_SKIA
87457:   SkSafeUnref(mTypeface);
87457: #endif
88426: #ifdef USE_CAIRO
88426:   cairo_scaled_font_destroy(mScaledFont);
88426: #endif
87457: }
87457: 
87457: ScaledFontBase::ScaledFontBase(Float aSize)
87457:   : mSize(aSize)
87457: {
87457: #ifdef USE_SKIA
87457:   mTypeface = NULL;
87457: #endif
88426: #ifdef USE_CAIRO
88426:   mScaledFont = NULL;
88426: #endif
87457: }
87457: 
87457: TemporaryRef<Path>
87457: ScaledFontBase::GetPathForGlyphs(const GlyphBuffer &aBuffer, const DrawTarget *aTarget)
87457: {
87457: #ifdef USE_SKIA
87457:   if (aTarget->GetType() == BACKEND_SKIA) {
87457:     SkPaint paint;
87457:     paint.setTypeface(GetSkTypeface());
87457:     paint.setTextEncoding(SkPaint::kGlyphID_TextEncoding);
87457:     paint.setTextSize(SkFloatToScalar(mSize));
87457: 
87457:     std::vector<uint16_t> indices;
87457:     std::vector<SkPoint> offsets;
87457:     indices.resize(aBuffer.mNumGlyphs);
87457:     offsets.resize(aBuffer.mNumGlyphs);
87457: 
87457:     for (unsigned int i = 0; i < aBuffer.mNumGlyphs; i++) {
87457:       indices[i] = aBuffer.mGlyphs[i].mIndex;
87457:       offsets[i].fX = SkFloatToScalar(aBuffer.mGlyphs[i].mPosition.x);
87457:       offsets[i].fY = SkFloatToScalar(aBuffer.mGlyphs[i].mPosition.y);
87457:     }
87457: 
87457:     SkPath path;
87457:     paint.getPosTextPath(&indices.front(), aBuffer.mNumGlyphs*2, &offsets.front(), &path);
87457:     return new PathSkia(path, FILL_WINDING);
87457:   }
87457: #endif
88426: #ifdef USE_CAIRO
88426:   if (aTarget->GetType() == BACKEND_CAIRO) {
88426:     MOZ_ASSERT(mScaledFont);
88426: 
88426:     RefPtr<PathBuilder> builder_iface = aTarget->CreatePathBuilder();
88426:     PathBuilderCairo* builder = static_cast<PathBuilderCairo*>(builder_iface.get());
88426: 
88426:     // Manually build the path for the PathBuilder.
88426:     RefPtr<CairoPathContext> context = builder->GetPathContext();
88426: 
88426:     cairo_set_scaled_font(*context, mScaledFont);
88426: 
88426:     // Convert our GlyphBuffer into an array of Cairo glyphs.
88426:     std::vector<cairo_glyph_t> glyphs(aBuffer.mNumGlyphs);
88426:     for (uint32_t i = 0; i < aBuffer.mNumGlyphs; ++i) {
88426:       glyphs[i].index = aBuffer.mGlyphs[i].mIndex;
88426:       glyphs[i].x = aBuffer.mGlyphs[i].mPosition.x;
88426:       glyphs[i].y = aBuffer.mGlyphs[i].mPosition.y;
88426:     }
88426: 
88426:     cairo_glyph_path(*context, &glyphs[0], aBuffer.mNumGlyphs);
88426: 
88426:     return builder->Finish();
88426:   }
88426: #endif
87457:   return NULL;
87457: }
87457: 
88426: #ifdef USE_CAIRO
88426: void
88426: ScaledFontBase::SetCairoScaledFont(cairo_scaled_font_t* font)
88426: {
88426:   MOZ_ASSERT(!mScaledFont);
88426: 
88426:   mScaledFont = font;
88426:   cairo_scaled_font_reference(mScaledFont);
87457: }
88426: #endif
88426: 
87457: }
88426: }
