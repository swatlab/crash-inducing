    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object for list-item bullets */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsBulletFrame.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIDocument.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "prprf.h"
    1: #include "nsDisplayList.h"
    1: 
    1: #include "imgILoader.h"
    1: #include "imgIContainer.h"
    1: #include "nsStubImageDecoderObserver.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsContentUtils.h"
    1: 
64006: #ifdef ACCESSIBILITY
64006: #include "nsAccessibilityService.h"
64006: #endif
64006: 
56866: #define BULLET_FRAME_IMAGE_LOADING NS_FRAME_STATE_BIT(63)
56866: 
    1: class nsBulletListener : public nsStubImageDecoderObserver
    1: {
    1: public:
    1:   nsBulletListener();
    1:   virtual ~nsBulletListener();
    1: 
    1:   NS_DECL_ISUPPORTS
    1:   // imgIDecoderObserver (override nsStubImageDecoderObserver)
    1:   NS_IMETHOD OnStartContainer(imgIRequest *aRequest, imgIContainer *aImage);
30479:   NS_IMETHOD OnDataAvailable(imgIRequest *aRequest, PRBool aCurrentFrame,
23738:                              const nsIntRect *aRect);
    1:   NS_IMETHOD OnStopDecode(imgIRequest *aRequest, nsresult status,
    1:                           const PRUnichar *statusArg);
    1:   // imgIContainerObserver (override nsStubImageDecoderObserver)
50544:   NS_IMETHOD FrameChanged(imgIContainer *aContainer,
50544:                           const nsIntRect *dirtyRect);
    1: 
    1:   void SetFrame(nsBulletFrame *frame) { mFrame = frame; }
    1: 
    1: private:
    1:   nsBulletFrame *mFrame;
    1: };
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsBulletFrame)
    1: 
    1: nsBulletFrame::~nsBulletFrame()
    1: {
    1: }
    1: 
    1: void
36647: nsBulletFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:   // Stop image loading first
    1:   if (mImageRequest) {
28448:     mImageRequest->CancelAndForgetObserver(NS_ERROR_FAILURE);
    1:     mImageRequest = nsnull;
    1:   }
    1: 
    1:   if (mListener)
 3233:     reinterpret_cast<nsBulletListener*>(mListener.get())->SetFrame(nsnull);
    1: 
    1:   // Let base class do the rest
36647:   nsFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
    1: nsBulletFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Bullet"), aResult);
    1: }
    1: #endif
    1: 
    1: nsIAtom*
    1: nsBulletFrame::GetType() const
    1: {
    1:   return nsGkAtoms::bulletFrame;
    1: }
    1: 
12912: PRBool
12912: nsBulletFrame::IsEmpty()
12912: {
12912:   return IsSelfEmpty();
12912: }
12912: 
12912: PRBool
12912: nsBulletFrame::IsSelfEmpty() 
12912: {
12912:   return GetStyleList()->mListStyleType == NS_STYLE_LIST_STYLE_NONE;
12912: }
12912: 
20441: /* virtual */ void
20836: nsBulletFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
    1: {
20836:   nsFrame::DidSetStyleContext(aOldStyleContext);
20441: 
35581:   imgIRequest *newRequest = GetStyleList()->GetListStyleImage();
    1: 
    1:   if (newRequest) {
    1: 
    1:     if (!mListener) {
47223:       nsBulletListener *listener = new nsBulletListener();
    1:       NS_ADDREF(listener);
    1:       listener->SetFrame(this);
    1:       listener->QueryInterface(NS_GET_IID(imgIDecoderObserver), getter_AddRefs(mListener));
    1:       NS_ASSERTION(mListener, "queryinterface for the listener failed");
    1:       NS_RELEASE(listener);
    1:     }
    1: 
    1:     PRBool needNewRequest = PR_TRUE;
    1: 
    1:     if (mImageRequest) {
    1:       // Reload the image, maybe...
    1:       nsCOMPtr<nsIURI> oldURI;
    1:       mImageRequest->GetURI(getter_AddRefs(oldURI));
    1:       nsCOMPtr<nsIURI> newURI;
    1:       newRequest->GetURI(getter_AddRefs(newURI));
    1:       if (oldURI && newURI) {
    1:         PRBool same;
    1:         newURI->Equals(oldURI, &same);
    1:         if (same) {
    1:           needNewRequest = PR_FALSE;
    1:         } else {
    1:           mImageRequest->Cancel(NS_ERROR_FAILURE);
    1:           mImageRequest = nsnull;
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (needNewRequest) {
    1:       newRequest->Clone(mListener, getter_AddRefs(mImageRequest));
    1:     }
    1:   } else {
    1:     // No image request on the new style context
    1:     if (mImageRequest) {
    1:       mImageRequest->Cancel(NS_ERROR_FAILURE);
    1:       mImageRequest = nsnull;
    1:     }
    1:   }
64006: 
64006: #ifdef ACCESSIBILITY
64006:   // Update the list bullet accessible. If old style list isn't available then
64006:   // no need to update the accessible tree because it's not created yet.
64006:   if (aOldStyleContext) {
64006:     nsAccessibilityService* accService = nsIPresShell::AccService();
64006:     if (accService) {
64006:       const nsStyleList* oldStyleList = aOldStyleContext->PeekStyleList();
64006:       if (oldStyleList) {
64006:         bool hadBullet = oldStyleList->GetListStyleImage() ||
64006:             oldStyleList->mListStyleType != NS_STYLE_LIST_STYLE_NONE;
64006: 
64006:         const nsStyleList* newStyleList = GetStyleList();
64006:         bool hasBullet = newStyleList->GetListStyleImage() ||
64006:             newStyleList->mListStyleType != NS_STYLE_LIST_STYLE_NONE;
64006: 
64006:         if (hadBullet != hasBullet) {
64006:           accService->UpdateListBullet(PresContext()->GetPresShell(), mContent,
64006:                                        hasBullet);
64006:         }
64006:       }
64006:     }
64006:   }
64006: #endif
    1: }
    1: 
    1: class nsDisplayBullet : public nsDisplayItem {
    1: public:
51260:   nsDisplayBullet(nsDisplayListBuilder* aBuilder, nsBulletFrame* aFrame) :
51260:     nsDisplayItem(aBuilder, aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayBullet);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayBullet() {
    1:     MOZ_COUNT_DTOR(nsDisplayBullet);
    1:   }
    1: #endif
    1: 
59781:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder)
59781:   {
59781:     return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
59781:   }
40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
40570:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames) {
40570:     aOutFrames->AppendElement(mFrame);
40570:   }
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
33368:                      nsIRenderingContext* aCtx);
47732:   NS_DISPLAY_DECL_NAME("Bullet", TYPE_BULLET)
55291: 
59781:   virtual nsRect GetComponentAlphaBounds(nsDisplayListBuilder* aBuilder)
59781:   {
59781:     return GetBounds(aBuilder);
59781:   }
    1: };
    1: 
    1: void nsDisplayBullet::Paint(nsDisplayListBuilder* aBuilder,
33368:                             nsIRenderingContext* aCtx)
    1: {
 3233:   static_cast<nsBulletFrame*>(mFrame)->
51261:     PaintBullet(*aCtx, ToReferenceFrame(), mVisibleRect);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBulletFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                 const nsRect&           aDirtyRect,
    1:                                 const nsDisplayListSet& aLists)
    1: {
    1:   if (!IsVisibleForPainting(aBuilder))
    1:     return NS_OK;
    1: 
    1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsBulletFrame");
    1:   
51260:   return aLists.Content()->AppendNewToTop(
51260:       new (aBuilder) nsDisplayBullet(aBuilder, this));
    1: }
    1: 
    1: void
    1: nsBulletFrame::PaintBullet(nsIRenderingContext& aRenderingContext, nsPoint aPt,
    1:                            const nsRect& aDirtyRect)
    1: {
    1:   const nsStyleList* myList = GetStyleList();
    1:   PRUint8 listStyleType = myList->mListStyleType;
    1: 
35581:   if (myList->GetListStyleImage() && mImageRequest) {
    1:     PRUint32 status;
    1:     mImageRequest->GetImageStatus(&status);
    1:     if (status & imgIRequest::STATUS_LOAD_COMPLETE &&
    1:         !(status & imgIRequest::STATUS_ERROR)) {
    1:       nsCOMPtr<imgIContainer> imageCon;
    1:       mImageRequest->GetImage(getter_AddRefs(imageCon));
    1:       if (imageCon) {
    1:         nsRect dest(mPadding.left, mPadding.top,
    1:                     mRect.width - (mPadding.left + mPadding.right),
    1:                     mRect.height - (mPadding.top + mPadding.bottom));
26926:         nsLayoutUtils::DrawSingleImage(&aRenderingContext,
26926:              imageCon, nsLayoutUtils::GetGraphicsFilterForFrame(this),
32424:              dest + aPt, aDirtyRect, imgIContainer::FLAG_NONE);
    1:         return;
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIFontMetrics> fm;
40176:   aRenderingContext.SetColor(GetVisitedDependentColor(eCSSProperty_color));
    1: 
11630:   mTextIsRTL = PR_FALSE;
    1: 
    1:   nsAutoString text;
    1:   switch (listStyleType) {
    1:   case NS_STYLE_LIST_STYLE_NONE:
    1:     break;
    1: 
    1:   default:
    1:   case NS_STYLE_LIST_STYLE_DISC:
    1:     aRenderingContext.FillEllipse(mPadding.left + aPt.x, mPadding.top + aPt.y,
    1:                                   mRect.width - (mPadding.left + mPadding.right),
    1:                                   mRect.height - (mPadding.top + mPadding.bottom));
    1:     break;
    1: 
    1:   case NS_STYLE_LIST_STYLE_CIRCLE:
    1:     aRenderingContext.DrawEllipse(mPadding.left + aPt.x, mPadding.top + aPt.y,
    1:                                   mRect.width - (mPadding.left + mPadding.right),
    1:                                   mRect.height - (mPadding.top + mPadding.bottom));
    1:     break;
    1: 
    1:   case NS_STYLE_LIST_STYLE_SQUARE:
38214:     {
38214:       nsRect rect(mPadding.TopLeft() + aPt,
38214:                   nsSize(mRect.width - mPadding.LeftRight(),
38214:                          mRect.height - mPadding.TopBottom()));
38214:       // Snap the height and the width of the rectangle to device pixels,
38214:       // and then center the result within the original rectangle, so that
38214:       // all square bullets at the same font size have the same visual
38214:       // size (bug 376690).
38214:       // FIXME: We should really only do this if we're not transformed
38214:       // (like gfxContext::UserToDevicePixelSnapped does).
38214:       nsPresContext *pc = PresContext();
38214:       nsRect snapRect(rect.x, rect.y, 
38214:                       pc->RoundAppUnitsToNearestDevPixels(rect.width),
38214:                       pc->RoundAppUnitsToNearestDevPixels(rect.height));
38214:       snapRect.MoveBy((rect.width - snapRect.width) / 2,
38214:                       (rect.height - snapRect.height) / 2);
38214:       aRenderingContext.FillRect(snapRect.x, snapRect.y,
38214:                                  snapRect.width, snapRect.height);
38214:     }
    1:     break;
    1: 
    1:   case NS_STYLE_LIST_STYLE_DECIMAL:
    1:   case NS_STYLE_LIST_STYLE_OLD_DECIMAL:
    1:   case NS_STYLE_LIST_STYLE_DECIMAL_LEADING_ZERO:
    1:   case NS_STYLE_LIST_STYLE_LOWER_ROMAN:
    1:   case NS_STYLE_LIST_STYLE_UPPER_ROMAN:
    1:   case NS_STYLE_LIST_STYLE_LOWER_ALPHA:
    1:   case NS_STYLE_LIST_STYLE_UPPER_ALPHA:
    1:   case NS_STYLE_LIST_STYLE_OLD_LOWER_ROMAN:
    1:   case NS_STYLE_LIST_STYLE_OLD_UPPER_ROMAN:
    1:   case NS_STYLE_LIST_STYLE_OLD_LOWER_ALPHA:
    1:   case NS_STYLE_LIST_STYLE_OLD_UPPER_ALPHA:
    1:   case NS_STYLE_LIST_STYLE_LOWER_GREEK:
    1:   case NS_STYLE_LIST_STYLE_HEBREW:
    1:   case NS_STYLE_LIST_STYLE_ARMENIAN:
    1:   case NS_STYLE_LIST_STYLE_GEORGIAN:
    1:   case NS_STYLE_LIST_STYLE_CJK_IDEOGRAPHIC:
    1:   case NS_STYLE_LIST_STYLE_HIRAGANA:
    1:   case NS_STYLE_LIST_STYLE_KATAKANA:
    1:   case NS_STYLE_LIST_STYLE_HIRAGANA_IROHA:
    1:   case NS_STYLE_LIST_STYLE_KATAKANA_IROHA:
    1:   case NS_STYLE_LIST_STYLE_MOZ_SIMP_CHINESE_INFORMAL: 
    1:   case NS_STYLE_LIST_STYLE_MOZ_SIMP_CHINESE_FORMAL: 
    1:   case NS_STYLE_LIST_STYLE_MOZ_TRAD_CHINESE_INFORMAL: 
    1:   case NS_STYLE_LIST_STYLE_MOZ_TRAD_CHINESE_FORMAL: 
    1:   case NS_STYLE_LIST_STYLE_MOZ_JAPANESE_INFORMAL: 
    1:   case NS_STYLE_LIST_STYLE_MOZ_JAPANESE_FORMAL: 
    1:   case NS_STYLE_LIST_STYLE_MOZ_CJK_HEAVENLY_STEM:
    1:   case NS_STYLE_LIST_STYLE_MOZ_CJK_EARTHLY_BRANCH:
    1:   case NS_STYLE_LIST_STYLE_MOZ_ARABIC_INDIC:
    1:   case NS_STYLE_LIST_STYLE_MOZ_PERSIAN:
    1:   case NS_STYLE_LIST_STYLE_MOZ_URDU:
    1:   case NS_STYLE_LIST_STYLE_MOZ_DEVANAGARI:
    1:   case NS_STYLE_LIST_STYLE_MOZ_GURMUKHI:
    1:   case NS_STYLE_LIST_STYLE_MOZ_GUJARATI:
    1:   case NS_STYLE_LIST_STYLE_MOZ_ORIYA:
    1:   case NS_STYLE_LIST_STYLE_MOZ_KANNADA:
    1:   case NS_STYLE_LIST_STYLE_MOZ_MALAYALAM:
    1:   case NS_STYLE_LIST_STYLE_MOZ_BENGALI:
    1:   case NS_STYLE_LIST_STYLE_MOZ_TAMIL:
    1:   case NS_STYLE_LIST_STYLE_MOZ_TELUGU:
    1:   case NS_STYLE_LIST_STYLE_MOZ_THAI:
    1:   case NS_STYLE_LIST_STYLE_MOZ_LAO:
    1:   case NS_STYLE_LIST_STYLE_MOZ_MYANMAR:
    1:   case NS_STYLE_LIST_STYLE_MOZ_KHMER:
    1:   case NS_STYLE_LIST_STYLE_MOZ_HANGUL:
    1:   case NS_STYLE_LIST_STYLE_MOZ_HANGUL_CONSONANT:
    1:   case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME:
    1:   case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_NUMERIC:
    1:   case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME_AM:
    1:   case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME_TI_ER:
    1:   case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME_TI_ET:
 4353:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
    1:     GetListItemText(*myList, text);
    1:     aRenderingContext.SetFont(fm);
    1:     nscoord ascent;
    1:     fm->GetMaxAscent(ascent);
11630:     aRenderingContext.SetTextRunRTL(mTextIsRTL);
    1:     aRenderingContext.DrawString(text, mPadding.left + aPt.x,
    1:                                  mPadding.top + aPt.y + ascent);
    1:     break;
    1:   }
    1: }
    1: 
    1: PRInt32
    1: nsBulletFrame::SetListItemOrdinal(PRInt32 aNextOrdinal,
    1:                                   PRBool* aChanged)
    1: {
    1:   // Assume that the ordinal comes from the caller
    1:   PRInt32 oldOrdinal = mOrdinal;
    1:   mOrdinal = aNextOrdinal;
    1: 
    1:   // Try to get value directly from the list-item, if it specifies a
    1:   // value attribute. Note: we do this with our parent's content
    1:   // because our parent is the list-item.
    1:   nsIContent* parentContent = mParent->GetContent();
    1:   if (parentContent) {
    1:     nsGenericHTMLElement *hc =
    1:       nsGenericHTMLElement::FromContent(parentContent);
    1:     if (hc) {
    1:       const nsAttrValue* attr = hc->GetParsedAttr(nsGkAtoms::value);
    1:       if (attr && attr->Type() == nsAttrValue::eInteger) {
    1:         // Use ordinal specified by the value attribute
    1:         mOrdinal = attr->GetIntegerValue();
    1:       }
    1:     }
    1:   }
    1: 
    1:   *aChanged = oldOrdinal != mOrdinal;
    1: 
    1:   return mOrdinal + 1;
    1: }
    1: 
    1: 
    1: // XXX change roman/alpha to use unsigned math so that maxint and
    1: // maxnegint will work
    1: 
    1: /**
    1:  * For all functions below, a return value of PR_TRUE means that we
    1:  * could represent mOrder in the desired numbering system.  PR_FALSE
    1:  * means we had to fall back to decimal
    1:  */
    1: static PRBool DecimalToText(PRInt32 ordinal, nsString& result)
    1: {
    1:    char cbuf[40];
    1:    PR_snprintf(cbuf, sizeof(cbuf), "%ld", ordinal);
    1:    result.AppendASCII(cbuf);
    1:    return PR_TRUE;
    1: }
    1: static PRBool DecimalLeadingZeroToText(PRInt32 ordinal, nsString& result)
    1: {
    1:    char cbuf[40];
    1:    PR_snprintf(cbuf, sizeof(cbuf), "%02ld", ordinal);
    1:    result.AppendASCII(cbuf);
    1:    return PR_TRUE;
    1: }
    1: static PRBool OtherDecimalToText(PRInt32 ordinal, PRUnichar zeroChar, nsString& result)
    1: {
    1:    PRUnichar diff = zeroChar - PRUnichar('0');
    1:    DecimalToText(ordinal, result);
    1:    PRUnichar* p = result.BeginWriting();
    1:    if (ordinal < 0) {
    1:      // skip the leading '-'
    1:      ++p;
    1:    }     
    1:    for(; nsnull != *p ; p++) 
    1:       *p += diff;
    1:    return PR_TRUE;
    1: }
    1: static PRBool TamilToText(PRInt32 ordinal,  nsString& result)
    1: {
    1:    PRUnichar diff = 0x0BE6 - PRUnichar('0');
    1:    DecimalToText(ordinal, result); 
    1:    if (ordinal < 1 || ordinal > 9999) {
    1:      // Can't do those in this system.
    1:      return PR_FALSE;
    1:    }
    1:    PRUnichar* p = result.BeginWriting();
    1:    for(; nsnull != *p ; p++) 
    1:       if(*p != PRUnichar('0'))
    1:          *p += diff;
    1:    return PR_TRUE;
    1: }
    1: 
    1: 
    1: static const char gLowerRomanCharsA[] = "ixcm";
    1: static const char gUpperRomanCharsA[] = "IXCM";
    1: static const char gLowerRomanCharsB[] = "vld";
    1: static const char gUpperRomanCharsB[] = "VLD";
    1: 
    1: static PRBool RomanToText(PRInt32 ordinal, nsString& result, const char* achars, const char* bchars)
    1: {
    1:   if (ordinal < 1 || ordinal > 3999) {
    1:     DecimalToText(ordinal, result);
    1:     return PR_FALSE;
    1:   }
    1:   nsAutoString addOn, decStr;
    1:   decStr.AppendInt(ordinal, 10);
    1:   PRIntn len = decStr.Length();
    1:   const PRUnichar* dp = decStr.get();
    1:   const PRUnichar* end = dp + len;
    1:   PRIntn romanPos = len;
    1:   PRIntn n;
    1: 
    1:   for (; dp < end; dp++) {
    1:     romanPos--;
    1:     addOn.SetLength(0);
    1:     switch(*dp) {
59663:       case '3':
59663:         addOn.Append(PRUnichar(achars[romanPos]));
59663:         // FALLTHROUGH
59663:       case '2':
59663:         addOn.Append(PRUnichar(achars[romanPos]));
59663:         // FALLTHROUGH
59663:       case '1':
59663:         addOn.Append(PRUnichar(achars[romanPos]));
    1:         break;
    1:       case '4':
    1:         addOn.Append(PRUnichar(achars[romanPos]));
    1:         // FALLTHROUGH
    1:       case '5': case '6':
    1:       case '7': case '8':
    1:         addOn.Append(PRUnichar(bchars[romanPos]));
31138:         for(n=0;'5'+n<*dp;n++) {
    1:           addOn.Append(PRUnichar(achars[romanPos]));
    1:         }
    1:         break;
    1:       case '9':
    1:         addOn.Append(PRUnichar(achars[romanPos]));
    1:         addOn.Append(PRUnichar(achars[romanPos+1]));
    1:         break;
    1:       default:
    1:         break;
    1:     }
    1:     result.Append(addOn);
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: #define ALPHA_SIZE 26
    1: static const PRUnichar gLowerAlphaChars[ALPHA_SIZE]  = 
    1: {
    1: 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, // A   B   C   D   E
    1: 0x0066, 0x0067, 0x0068, 0x0069, 0x006A, // F   G   H   I   J
    1: 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, // K   L   M   N   O
    1: 0x0070, 0x0071, 0x0072, 0x0073, 0x0074, // P   Q   R   S   T
    1: 0x0075, 0x0076, 0x0077, 0x0078, 0x0079, // U   V   W   X   Y
    1: 0x007A                                  // Z
    1: };
    1: 
    1: static const PRUnichar gUpperAlphaChars[ALPHA_SIZE]  = 
    1: {
    1: 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, // A   B   C   D   E
    1: 0x0046, 0x0047, 0x0048, 0x0049, 0x004A, // F   G   H   I   J
    1: 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, // K   L   M   N   O
    1: 0x0050, 0x0051, 0x0052, 0x0053, 0x0054, // P   Q   R   S   T
    1: 0x0055, 0x0056, 0x0057, 0x0058, 0x0059, // U   V   W   X   Y
    1: 0x005A                                  // Z
    1: };
    1: 
    1: 
    1: #define KATAKANA_CHARS_SIZE 48
    1: // Page 94 Writing Systems of The World
    1: // after modification by momoi
    1: static const PRUnichar gKatakanaChars[KATAKANA_CHARS_SIZE] =
    1: {
    1: 0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, //  a    i   u    e    o
    1: 0x30AB, 0x30AD, 0x30AF, 0x30B1, 0x30B3, // ka   ki  ku   ke   ko
    1: 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD, // sa  shi  su   se   so
    1: 0x30BF, 0x30C1, 0x30C4, 0x30C6, 0x30C8, // ta  chi tsu   te   to
    1: 0x30CA, 0x30CB, 0x30CC, 0x30CD, 0x30CE, // na   ni  nu   ne   no
    1: 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, // ha   hi  hu   he   ho
    1: 0x30DE, 0x30DF, 0x30E0, 0x30E1, 0x30E2, // ma   mi  mu   me   mo
    1: 0x30E4,         0x30E6,         0x30E8, // ya       yu        yo 
    1: 0x30E9, 0x30EA, 0x30EB, 0x30EC, 0x30ED, // ra   ri  ru   re   ro
    1: 0x30EF, 0x30F0,         0x30F1, 0x30F2, // wa (w)i     (w)e (w)o
    1: 0x30F3                                  //  n
    1: };
    1: 
    1: #define HIRAGANA_CHARS_SIZE 48 
    1: static const PRUnichar gHiraganaChars[HIRAGANA_CHARS_SIZE] =
    1: {
    1: 0x3042, 0x3044, 0x3046, 0x3048, 0x304A, //  a    i    u    e    o
    1: 0x304B, 0x304D, 0x304F, 0x3051, 0x3053, // ka   ki   ku   ke   ko
    1: 0x3055, 0x3057, 0x3059, 0x305B, 0x305D, // sa  shi   su   se   so
    1: 0x305F, 0x3061, 0x3064, 0x3066, 0x3068, // ta  chi  tsu   te   to
    1: 0x306A, 0x306B, 0x306C, 0x306D, 0x306E, // na   ni   nu   ne   no
    1: 0x306F, 0x3072, 0x3075, 0x3078, 0x307B, // ha   hi   hu   he   ho
    1: 0x307E, 0x307F, 0x3080, 0x3081, 0x3082, // ma   mi   mu   me   mo
    1: 0x3084,         0x3086,         0x3088, // ya        yu       yo 
    1: 0x3089, 0x308A, 0x308B, 0x308C, 0x308D, // ra   ri   ru   re   ro
    1: 0x308F, 0x3090,         0x3091, 0x3092, // wa (w)i      (w)e (w)o
    1: 0x3093                                  // n
    1: };
    1: 
    1: 
    1: #define HIRAGANA_IROHA_CHARS_SIZE 47
    1: // Page 94 Writing Systems of The World
    1: static const PRUnichar gHiraganaIrohaChars[HIRAGANA_IROHA_CHARS_SIZE] =
    1: {
    1: 0x3044, 0x308D, 0x306F, 0x306B, 0x307B, //  i   ro   ha   ni   ho
    1: 0x3078, 0x3068, 0x3061, 0x308A, 0x306C, // he   to  chi   ri   nu
    1: 0x308B, 0x3092, 0x308F, 0x304B, 0x3088, // ru (w)o   wa   ka   yo
    1: 0x305F, 0x308C, 0x305D, 0x3064, 0x306D, // ta   re   so  tsu   ne
    1: 0x306A, 0x3089, 0x3080, 0x3046, 0x3090, // na   ra   mu    u (w)i
    1: 0x306E, 0x304A, 0x304F, 0x3084, 0x307E, // no    o   ku   ya   ma
    1: 0x3051, 0x3075, 0x3053, 0x3048, 0x3066, // ke   hu   ko    e   te
    1: 0x3042, 0x3055, 0x304D, 0x3086, 0x3081, //  a   sa   ki   yu   me
    1: 0x307F, 0x3057, 0x3091, 0x3072, 0x3082, // mi  shi (w)e   hi   mo 
    1: 0x305B, 0x3059                          // se   su
    1: };
    1: 
    1: #define KATAKANA_IROHA_CHARS_SIZE 47
    1: static const PRUnichar gKatakanaIrohaChars[KATAKANA_IROHA_CHARS_SIZE] =
    1: {
    1: 0x30A4, 0x30ED, 0x30CF, 0x30CB, 0x30DB, //  i   ro   ha   ni   ho
    1: 0x30D8, 0x30C8, 0x30C1, 0x30EA, 0x30CC, // he   to  chi   ri   nu
    1: 0x30EB, 0x30F2, 0x30EF, 0x30AB, 0x30E8, // ru (w)o   wa   ka   yo
    1: 0x30BF, 0x30EC, 0x30BD, 0x30C4, 0x30CD, // ta   re   so  tsu   ne
    1: 0x30CA, 0x30E9, 0x30E0, 0x30A6, 0x30F0, // na   ra   mu    u (w)i
    1: 0x30CE, 0x30AA, 0x30AF, 0x30E4, 0x30DE, // no    o   ku   ya   ma
    1: 0x30B1, 0x30D5, 0x30B3, 0x30A8, 0x30C6, // ke   hu   ko    e   te
    1: 0x30A2, 0x30B5, 0x30AD, 0x30E6, 0x30E1, //  a   sa   ki   yu   me
    1: 0x30DF, 0x30B7, 0x30F1, 0x30D2, 0x30E2, // mi  shi (w)e   hi   mo 
    1: 0x30BB, 0x30B9                          // se   su
    1: };
    1: 
    1: #define LOWER_GREEK_CHARS_SIZE 24
    1: // Note: 0x03C2 GREEK FINAL SIGMA is not used in here....
    1: static const PRUnichar gLowerGreekChars[LOWER_GREEK_CHARS_SIZE] =
    1: {
    1: 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, // alpha  beta  gamma  delta  epsilon
    1: 0x03B6, 0x03B7, 0x03B8, 0x03B9, 0x03BA, // zeta   eta   theta  iota   kappa   
    1: 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, // lamda  mu    nu     xi     omicron 
    1: 0x03C0, 0x03C1, 0x03C3, 0x03C4, 0x03C5, // pi     rho   sigma  tau    upsilon 
    1: 0x03C6, 0x03C7, 0x03C8, 0x03C9          // phi    chi   psi    omega    
    1: };
    1: 
    1: #define CJK_HEAVENLY_STEM_CHARS_SIZE 10 
    1: static const PRUnichar gCJKHeavenlyStemChars[CJK_HEAVENLY_STEM_CHARS_SIZE] =
    1: {
    1: 0x7532, 0x4e59, 0x4e19, 0x4e01, 0x620a,
    1: 0x5df1, 0x5e9a, 0x8f9b, 0x58ec, 0x7678
    1: };
    1: #define CJK_EARTHLY_BRANCH_CHARS_SIZE 12 
    1: static const PRUnichar gCJKEarthlyBranchChars[CJK_EARTHLY_BRANCH_CHARS_SIZE] =
    1: {
    1: 0x5b50, 0x4e11, 0x5bc5, 0x536f, 0x8fb0, 0x5df3,
    1: 0x5348, 0x672a, 0x7533, 0x9149, 0x620c, 0x4ea5
    1: };
    1: #define HANGUL_CHARS_SIZE 14 
    1: static const PRUnichar gHangulChars[HANGUL_CHARS_SIZE] =
    1: {
    1: 0xac00, 0xb098, 0xb2e4, 0xb77c, 0xb9c8, 0xbc14,
    1: 0xc0ac, 0xc544, 0xc790, 0xcc28, 0xce74, 0xd0c0,
    1: 0xd30c, 0xd558
    1: };
    1: #define HANGUL_CONSONANT_CHARS_SIZE 14 
    1: static const PRUnichar gHangulConsonantChars[HANGUL_CONSONANT_CHARS_SIZE] =
    1: {                                      
    1: 0x3131, 0x3134, 0x3137, 0x3139, 0x3141, 0x3142,
    1: 0x3145, 0x3147, 0x3148, 0x314a, 0x314b, 0x314c,
    1: 0x314d, 0x314e
    1: };
    1: 
    1: // Ge'ez set of Ethiopic ordered list. There are other locale-dependent sets.
    1: // For the time being, let's implement two Ge'ez sets only
    1: // per Momoi san's suggestion in bug 102252. 
    1: // For details, refer to http://www.ethiopic.org/Collation/OrderedLists.html.
    1: #define ETHIOPIC_HALEHAME_CHARS_SIZE 26
    1: static const PRUnichar gEthiopicHalehameChars[ETHIOPIC_HALEHAME_CHARS_SIZE] =
    1: {                                      
    1: 0x1200, 0x1208, 0x1210, 0x1218, 0x1220, 0x1228,
    1: 0x1230, 0x1240, 0x1260, 0x1270, 0x1280, 0x1290,
    1: 0x12a0, 0x12a8, 0x12c8, 0x12d0, 0x12d8, 0x12e8,
    1: 0x12f0, 0x1308, 0x1320, 0x1330, 0x1338, 0x1340,
    1: 0x1348, 0x1350
    1: };
    1: #define ETHIOPIC_HALEHAME_AM_CHARS_SIZE 33
    1: static const PRUnichar gEthiopicHalehameAmChars[ETHIOPIC_HALEHAME_AM_CHARS_SIZE] =
    1: {                                      
    1: 0x1200, 0x1208, 0x1210, 0x1218, 0x1220, 0x1228,
    1: 0x1230, 0x1238, 0x1240, 0x1260, 0x1270, 0x1278,
    1: 0x1280, 0x1290, 0x1298, 0x12a0, 0x12a8, 0x12b8,
    1: 0x12c8, 0x12d0, 0x12d8, 0x12e0, 0x12e8, 0x12f0,
    1: 0x1300, 0x1308, 0x1320, 0x1328, 0x1330, 0x1338,
    1: 0x1340, 0x1348, 0x1350
    1: };
    1: #define ETHIOPIC_HALEHAME_TI_ER_CHARS_SIZE 31
    1: static const PRUnichar gEthiopicHalehameTiErChars[ETHIOPIC_HALEHAME_TI_ER_CHARS_SIZE] =
    1: {                                      
    1: 0x1200, 0x1208, 0x1210, 0x1218, 0x1228, 0x1230,
    1: 0x1238, 0x1240, 0x1250, 0x1260, 0x1270, 0x1278,
    1: 0x1290, 0x1298, 0x12a0, 0x12a8, 0x12b8, 0x12c8,
    1: 0x12d0, 0x12d8, 0x12e0, 0x12e8, 0x12f0, 0x1300,
    1: 0x1308, 0x1320, 0x1328, 0x1330, 0x1338, 0x1348,
    1: 0x1350
    1: };
    1: #define ETHIOPIC_HALEHAME_TI_ET_CHARS_SIZE 34
    1: static const PRUnichar gEthiopicHalehameTiEtChars[ETHIOPIC_HALEHAME_TI_ET_CHARS_SIZE] =
    1: {                                      
    1: 0x1200, 0x1208, 0x1210, 0x1218, 0x1220, 0x1228,
    1: 0x1230, 0x1238, 0x1240, 0x1250, 0x1260, 0x1270,
    1: 0x1278, 0x1280, 0x1290, 0x1298, 0x12a0, 0x12a8,
    1: 0x12b8, 0x12c8, 0x12d0, 0x12d8, 0x12e0, 0x12e8,
    1: 0x12f0, 0x1300, 0x1308, 0x1320, 0x1328, 0x1330,
    1: 0x1338, 0x1340, 0x1348, 0x1350
    1: };
    1: 
    1: 
    1: // We know cjk-ideographic need 31 characters to display 99,999,999,999,999,999
    1: // georgian needs 6 at most
    1: // armenian needs 12 at most
    1: // hebrew may need more...
    1: 
    1: #define NUM_BUF_SIZE 34 
    1: 
    1: static PRBool CharListToText(PRInt32 ordinal, nsString& result, const PRUnichar* chars, PRInt32 aBase)
    1: {
    1:   PRUnichar buf[NUM_BUF_SIZE];
    1:   PRInt32 idx = NUM_BUF_SIZE;
    1:   if (ordinal < 1) {
    1:     DecimalToText(ordinal, result);
    1:     return PR_FALSE;
    1:   }
    1:   do {
    1:     ordinal--; // a == 0
    1:     PRInt32 cur = ordinal % aBase;
    1:     buf[--idx] = chars[cur];
    1:     ordinal /= aBase ;
    1:   } while ( ordinal > 0);
    1:   result.Append(buf+idx,NUM_BUF_SIZE-idx);
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: static const PRUnichar gCJKIdeographicDigit1[10] =
    1: {
    1:   0x96f6, 0x4e00, 0x4e8c, 0x4e09, 0x56db,  // 0 - 4
    1:   0x4e94, 0x516d, 0x4e03, 0x516b, 0x4e5d   // 5 - 9
    1: };
    1: static const PRUnichar gCJKIdeographicDigit2[10] =
    1: {
    1:   0x96f6, 0x58f9, 0x8cb3, 0x53c3, 0x8086,  // 0 - 4
    1:   0x4f0d, 0x9678, 0x67d2, 0x634c, 0x7396   // 5 - 9
    1: };
    1: static const PRUnichar gCJKIdeographicDigit3[10] =
    1: {
    1:   0x96f6, 0x58f9, 0x8d30, 0x53c1, 0x8086,  // 0 - 4
    1:   0x4f0d, 0x9646, 0x67d2, 0x634c, 0x7396   // 5 - 9
    1: };
    1: static const PRUnichar gCJKIdeographicUnit1[4] =
    1: {
    1:   0x000, 0x5341, 0x767e, 0x5343
    1: };
    1: static const PRUnichar gCJKIdeographicUnit2[4] =
    1: {
    1:   0x000, 0x62FE, 0x4F70, 0x4EDF
    1: };
    1: static const PRUnichar gCJKIdeographic10KUnit1[4] =
    1: {
    1:   0x000, 0x842c, 0x5104, 0x5146
    1: };
    1: static const PRUnichar gCJKIdeographic10KUnit2[4] =
    1: {
    1:   0x000, 0x4E07, 0x4ebf, 0x5146
    1: };
    1: static const PRUnichar gCJKIdeographic10KUnit3[4] =
    1: {
    1:   0x000, 0x4E07, 0x5104, 0x5146
    1: };
    1: 
    1: static const PRBool CJKIdeographicToText(PRInt32 ordinal, nsString& result, 
    1:                                    const PRUnichar* digits,
    1:                                    const PRUnichar *unit, 
    1:                                    const PRUnichar* unit10k)
    1: {
    1: // In theory, we need the following if condiction,
    1: // However, the limit, 10 ^ 16, is greater than the max of PRUint32
    1: // so we don't really need to test it here.
    1: // if( ordinal > 9999999999999999)
    1: // {
    1: //    PR_snprintf(cbuf, sizeof(cbuf), "%ld", ordinal);
    1: //    result.Append(cbuf);
    1: // } 
    1: // else 
    1: // {
    1:   if (ordinal < 0) {
    1:     DecimalToText(ordinal, result);
    1:     return PR_FALSE;
    1:   }
    1:   PRUnichar c10kUnit = 0;
    1:   PRUnichar cUnit = 0;
    1:   PRUnichar cDigit = 0;
    1:   PRUint32 ud = 0;
    1:   PRUnichar buf[NUM_BUF_SIZE];
    1:   PRInt32 idx = NUM_BUF_SIZE;
    1:   PRBool bOutputZero = ( 0 == ordinal );
    1:   do {
    1:     if(0 == (ud % 4)) {
    1:       c10kUnit = unit10k[ud/4];
    1:     }
    1:     PRInt32 cur = ordinal % 10;
    1:     cDigit = digits[cur];
    1:     if( 0 == cur)
    1:     {
    1:       cUnit = 0;
    1:       if(bOutputZero) {
    1:         bOutputZero = PR_FALSE;
    1:         if(0 != cDigit)
    1:           buf[--idx] = cDigit;
    1:       }
    1:     }
    1:     else
    1:     {
    1:       bOutputZero = PR_TRUE;
    1:       cUnit = unit[ud%4];
    1: 
    1:       if(0 != c10kUnit)
    1:         buf[--idx] = c10kUnit;
    1:       if(0 != cUnit)
    1:         buf[--idx] = cUnit;
    1:       if((0 != cDigit) && 
    1:          ( (1 != cur) || (1 != (ud%4)) || ( ordinal > 10)) )
    1:         buf[--idx] = cDigit;
    1: 
    1:       c10kUnit =  0;
    1:     }
    1:     ordinal /= 10;
    1:     ++ud;
    1: 
    1:   } while( ordinal > 0);
    1:   result.Append(buf+idx,NUM_BUF_SIZE-idx);
    1: // }
    1:   return PR_TRUE;
    1: }
    1: 
    1: #define HEBREW_GERESH       0x05F3
    1: static const PRUnichar gHebrewDigit[22] = 
    1: {
    1: //   1       2       3       4       5       6       7       8       9
    1: 0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8,
    1: //  10      20      30      40      50      60      70      80      90
    1: 0x05D9, 0x05DB, 0x05DC, 0x05DE, 0x05E0, 0x05E1, 0x05E2, 0x05E4, 0x05E6,
    1: // 100     200     300     400
    1: 0x05E7, 0x05E8, 0x05E9, 0x05EA
    1: };
    1: 
    1: static PRBool HebrewToText(PRInt32 ordinal, nsString& result)
    1: {
11630:   if (ordinal < 1 || ordinal > 999999) {
    1:     DecimalToText(ordinal, result);
    1:     return PR_FALSE;
    1:   }
    1:   PRBool outputSep = PR_FALSE;
11630:   nsAutoString allText, thousandsGroup;
    1:   do {
11630:     thousandsGroup.Truncate();
    1:     PRInt32 n3 = ordinal % 1000;
    1:     // Process digit for 100 - 900
    1:     for(PRInt32 n1 = 400; n1 > 0; )
    1:     {
    1:       if( n3 >= n1)
    1:       {
    1:         n3 -= n1;
11630:         thousandsGroup.Append(gHebrewDigit[(n1/100)-1+18]);
    1:       } else {
    1:         n1 -= 100;
    1:       } // if
    1:     } // for
    1: 
    1:     // Process digit for 10 - 90
    1:     PRInt32 n2;
    1:     if( n3 >= 10 )
    1:     {
    1:       // Special process for 15 and 16
    1:       if(( 15 == n3 ) || (16 == n3)) {
    1:         // Special rule for religious reason...
    1:         // 15 is represented by 9 and 6, not 10 and 5
    1:         // 16 is represented by 9 and 7, not 10 and 6
    1:         n2 = 9;
11630:         thousandsGroup.Append(gHebrewDigit[ n2 - 1]);
    1:       } else {
    1:         n2 = n3 - (n3 % 10);
11630:         thousandsGroup.Append(gHebrewDigit[(n2/10)-1+9]);
    1:       } // if
    1:       n3 -= n2;
    1:     } // if
    1:   
    1:     // Process digit for 1 - 9 
    1:     if ( n3 > 0)
11630:       thousandsGroup.Append(gHebrewDigit[n3-1]);
11630:     if (outputSep) 
11630:       thousandsGroup.Append((PRUnichar)HEBREW_GERESH);
11630:     if (allText.IsEmpty())
11630:       allText = thousandsGroup;
11630:     else
11630:       allText = thousandsGroup + allText;
    1:     ordinal /= 1000;
11630:     outputSep = PR_TRUE;
    1:   } while (ordinal >= 1);
11630: 
11630:   result.Append(allText);
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: static PRBool ArmenianToText(PRInt32 ordinal, nsString& result)
    1: {
    1:   if (ordinal < 1 || ordinal > 9999) { // zero or reach the limit of Armenian numbering system
    1:     DecimalToText(ordinal, result);
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRUnichar buf[NUM_BUF_SIZE];
    1:   PRInt32 idx = NUM_BUF_SIZE;
    1:   PRInt32 d = 0;
    1:   do {
    1:     PRInt32 cur = ordinal % 10;
    1:     if (cur > 0)
    1:     {
    1:       PRUnichar u = 0x0530 + (d * 9) + cur;
    1:       buf[--idx] = u;
    1:     }
    1:     ++d;
    1:     ordinal /= 10;
    1:   } while (ordinal > 0);
    1:   result.Append(buf + idx, NUM_BUF_SIZE - idx);
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: static const PRUnichar gGeorgianValue [ 37 ] = { // 4 * 9 + 1 = 37
    1: //      1       2       3       4       5       6       7       8       9
    1:    0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6, 0x10F1, 0x10D7,
    1: //     10      20      30      40      50      60      70      80      90
    1:    0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC, 0x10F2, 0x10DD, 0x10DE, 0x10DF,
    1: //    100     200     300     400     500     600     700     800     900
    1:    0x10E0, 0x10E1, 0x10E2, 0x10F3, 0x10E4, 0x10E5, 0x10E6, 0x10E7, 0x10E8,
    1: //   1000    2000    3000    4000    5000    6000    7000    8000    9000
    1:    0x10E9, 0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10F4, 0x10EF, 0x10F0,
    1: //  10000
    1:    0x10F5
    1: };
    1: static PRBool GeorgianToText(PRInt32 ordinal, nsString& result)
    1: {
    1:   if (ordinal < 1 || ordinal > 19999) { // zero or reach the limit of Georgian numbering system
    1:     DecimalToText(ordinal, result);
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRUnichar buf[NUM_BUF_SIZE];
    1:   PRInt32 idx = NUM_BUF_SIZE;
    1:   PRInt32 d = 0;
    1:   do {
    1:     PRInt32 cur = ordinal % 10;
    1:     if (cur > 0)
    1:     {
    1:       PRUnichar u = gGeorgianValue[(d * 9 ) + ( cur - 1)];
    1:       buf[--idx] = u;
    1:     }
    1:     ++d;
    1:     ordinal /= 10;
    1:   } while (ordinal > 0);
    1:   result.Append(buf + idx, NUM_BUF_SIZE - idx);
    1:   return PR_TRUE;
    1: }
    1: 
    1: // Convert ordinal to Ethiopic numeric representation.
    1: // The detail is available at http://www.ethiopic.org/Numerals/
    1: // The algorithm used here is based on the pseudo-code put up there by
    1: // Daniel Yacob <yacob@geez.org>.
    1: // Another reference is Unicode 3.0 standard section 11.1.
    1: #define ETHIOPIC_ONE             0x1369
    1: #define ETHIOPIC_TEN             0x1372
    1: #define ETHIOPIC_HUNDRED         0x137B
    1: #define ETHIOPIC_TEN_THOUSAND    0x137C
    1: 
    1: static PRBool EthiopicToText(PRInt32 ordinal, nsString& result)
    1: {
    1:   nsAutoString asciiNumberString;      // decimal string representation of ordinal
    1:   DecimalToText(ordinal, asciiNumberString);
    1:   if (ordinal < 1) {
    1:     result.Append(asciiNumberString);
    1:     return PR_FALSE;
    1:   }
    1:   PRUint8 asciiStringLength = asciiNumberString.Length();
    1: 
    1:   // If number length is odd, add a leading "0"
    1:   // the leading "0" preconditions the string to always have the
    1:   // leading tens place populated, this avoids a check within the loop.
    1:   // If we didn't add the leading "0", decrement asciiStringLength so
    1:   // it will be equivalent to a zero-based index in both cases.
    1:   if (asciiStringLength & 1) {
    1:     asciiNumberString.Insert(NS_LITERAL_STRING("0"), 0);
    1:   } else {
    1:     asciiStringLength--;
    1:   }
    1: 
    1:   // Iterate from the highest digits to lowest
    1:   // indexFromLeft       indexes digits (0 = most significant)
    1:   // groupIndexFromRight indexes pairs of digits (0 = least significant)
    1:   for (PRUint8 indexFromLeft = 0, groupIndexFromRight = asciiStringLength >> 1;
    1:        indexFromLeft <= asciiStringLength;
    1:        indexFromLeft += 2, groupIndexFromRight--) {
    1:     PRUint8 tensValue  = asciiNumberString.CharAt(indexFromLeft) & 0x0F;
    1:     PRUint8 unitsValue = asciiNumberString.CharAt(indexFromLeft + 1) & 0x0F;
    1:     PRUint8 groupValue = tensValue * 10 + unitsValue;
    1: 
    1:     PRBool oddGroup = (groupIndexFromRight & 1);
    1: 
    1:     // we want to clear ETHIOPIC_ONE when it is superfluous
    1:     if (ordinal > 1 &&
    1:         groupValue == 1 &&                  // one without a leading ten
    1:         (oddGroup || indexFromLeft == 0)) { // preceding (100) or leading the sequence
    1:       unitsValue = 0;
    1:     }
    1: 
    1:     // put it all together...
    1:     if (tensValue) {
    1:       // map onto Ethiopic "tens":
    1:       result.Append((PRUnichar) (tensValue +  ETHIOPIC_TEN - 1));
    1:     }
    1:     if (unitsValue) {
    1:       //map onto Ethiopic "units":
    1:       result.Append((PRUnichar) (unitsValue + ETHIOPIC_ONE - 1));
    1:     }
    1:     // Add a separator for all even groups except the last,
    1:     // and for odd groups with non-zero value.
    1:     if (oddGroup) {
    1:       if (groupValue) {
    1:         result.Append((PRUnichar) ETHIOPIC_HUNDRED);
    1:       }
    1:     } else {
    1:       if (groupIndexFromRight) {
    1:         result.Append((PRUnichar) ETHIOPIC_TEN_THOUSAND);
    1:       }
    1:     }
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: /* static */ PRBool
    1: nsBulletFrame::AppendCounterText(PRInt32 aListStyleType,
    1:                                  PRInt32 aOrdinal,
    1:                                  nsString& result)
    1: {
35657:   PRBool success = PR_TRUE;
    1:   
    1:   switch (aListStyleType) {
    1:     case NS_STYLE_LIST_STYLE_NONE: // used by counters code only
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_DISC: // used by counters code only
    1:       // XXX We really need to do this the same way we do list bullets.
    1:       result.Append(PRUnichar(0x2022));
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_CIRCLE: // used by counters code only
    1:       // XXX We really need to do this the same way we do list bullets.
    1:       result.Append(PRUnichar(0x25E6));
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_SQUARE: // used by counters code only
    1:       // XXX We really need to do this the same way we do list bullets.
    1:       result.Append(PRUnichar(0x25FE));
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_DECIMAL:
    1:     case NS_STYLE_LIST_STYLE_OLD_DECIMAL:
    1:     default: // CSS2 say "A users  agent that does not recognize a numbering system
    1:       // should use 'decimal'
    1:       success = DecimalToText(aOrdinal, result);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_DECIMAL_LEADING_ZERO:
    1:       success = DecimalLeadingZeroToText(aOrdinal, result);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_LOWER_ROMAN:
    1:     case NS_STYLE_LIST_STYLE_OLD_LOWER_ROMAN:
    1:       success = RomanToText(aOrdinal, result,
    1:                             gLowerRomanCharsA, gLowerRomanCharsB);
    1:       break;
    1:     case NS_STYLE_LIST_STYLE_UPPER_ROMAN:
    1:     case NS_STYLE_LIST_STYLE_OLD_UPPER_ROMAN:
    1:       success = RomanToText(aOrdinal, result,
    1:                             gUpperRomanCharsA, gUpperRomanCharsB);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_LOWER_ALPHA:
    1:     case NS_STYLE_LIST_STYLE_OLD_LOWER_ALPHA:
    1:       success = CharListToText(aOrdinal, result, gLowerAlphaChars, ALPHA_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_UPPER_ALPHA:
    1:     case NS_STYLE_LIST_STYLE_OLD_UPPER_ALPHA:
    1:       success = CharListToText(aOrdinal, result, gUpperAlphaChars, ALPHA_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_KATAKANA:
    1:       success = CharListToText(aOrdinal, result, gKatakanaChars,
    1:                                KATAKANA_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_HIRAGANA:
    1:       success = CharListToText(aOrdinal, result, gHiraganaChars,
    1:                                HIRAGANA_CHARS_SIZE);
    1:       break;
    1:     
    1:     case NS_STYLE_LIST_STYLE_KATAKANA_IROHA:
    1:       success = CharListToText(aOrdinal, result, gKatakanaIrohaChars,
    1:                                KATAKANA_IROHA_CHARS_SIZE);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_HIRAGANA_IROHA:
    1:       success = CharListToText(aOrdinal, result, gHiraganaIrohaChars,
    1:                                HIRAGANA_IROHA_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_LOWER_GREEK:
    1:       success = CharListToText(aOrdinal, result, gLowerGreekChars ,
    1:                                LOWER_GREEK_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_CJK_IDEOGRAPHIC: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_TRAD_CHINESE_INFORMAL: 
    1:       success = CJKIdeographicToText(aOrdinal, result, gCJKIdeographicDigit1,
    1:                                      gCJKIdeographicUnit1,
    1:                                      gCJKIdeographic10KUnit1);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_TRAD_CHINESE_FORMAL: 
    1:       success = CJKIdeographicToText(aOrdinal, result, gCJKIdeographicDigit2,
    1:                                      gCJKIdeographicUnit2,
    1:                                      gCJKIdeographic10KUnit1);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_SIMP_CHINESE_INFORMAL: 
    1:       success = CJKIdeographicToText(aOrdinal, result, gCJKIdeographicDigit1,
    1:                                      gCJKIdeographicUnit1,
    1:                                      gCJKIdeographic10KUnit2);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_SIMP_CHINESE_FORMAL: 
    1:       success = CJKIdeographicToText(aOrdinal, result, gCJKIdeographicDigit3,
    1:                                      gCJKIdeographicUnit2,
    1:                                      gCJKIdeographic10KUnit2);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_JAPANESE_INFORMAL: 
    1:       success = CJKIdeographicToText(aOrdinal, result, gCJKIdeographicDigit1,
    1:                                      gCJKIdeographicUnit1,
    1:                                      gCJKIdeographic10KUnit3);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_JAPANESE_FORMAL: 
    1:       success = CJKIdeographicToText(aOrdinal, result, gCJKIdeographicDigit2,
    1:                                      gCJKIdeographicUnit2,
    1:                                      gCJKIdeographic10KUnit3);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_HEBREW: 
    1:       success = HebrewToText(aOrdinal, result);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_ARMENIAN: 
    1:       success = ArmenianToText(aOrdinal, result);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_GEORGIAN: 
    1:       success = GeorgianToText(aOrdinal, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_ARABIC_INDIC:
    1:       success = OtherDecimalToText(aOrdinal, 0x0660, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_PERSIAN:
    1:     case NS_STYLE_LIST_STYLE_MOZ_URDU:
    1:       success = OtherDecimalToText(aOrdinal, 0x06f0, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_DEVANAGARI:
    1:       success = OtherDecimalToText(aOrdinal, 0x0966, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_GURMUKHI:
    1:       success = OtherDecimalToText(aOrdinal, 0x0a66, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_GUJARATI:
    1:       success = OtherDecimalToText(aOrdinal, 0x0AE6, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_ORIYA:
    1:       success = OtherDecimalToText(aOrdinal, 0x0B66, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_KANNADA:
    1:       success = OtherDecimalToText(aOrdinal, 0x0CE6, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_MALAYALAM:
    1:       success = OtherDecimalToText(aOrdinal, 0x0D66, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_THAI:
    1:       success = OtherDecimalToText(aOrdinal, 0x0E50, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_LAO:
    1:       success = OtherDecimalToText(aOrdinal, 0x0ED0, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_MYANMAR:
    1:       success = OtherDecimalToText(aOrdinal, 0x1040, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_KHMER:
    1:       success = OtherDecimalToText(aOrdinal, 0x17E0, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_BENGALI:
    1:       success = OtherDecimalToText(aOrdinal, 0x09E6, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_TELUGU:
    1:       success = OtherDecimalToText(aOrdinal, 0x0C66, result);
    1:       break;
    1:  
    1:     case NS_STYLE_LIST_STYLE_MOZ_TAMIL:
    1:       success = TamilToText(aOrdinal, result);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_CJK_HEAVENLY_STEM:
    1:       success = CharListToText(aOrdinal, result, gCJKHeavenlyStemChars,
    1:                                CJK_HEAVENLY_STEM_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_CJK_EARTHLY_BRANCH:
    1:       success = CharListToText(aOrdinal, result, gCJKEarthlyBranchChars,
    1:                                CJK_EARTHLY_BRANCH_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_HANGUL:
    1:       success = CharListToText(aOrdinal, result, gHangulChars, HANGUL_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_HANGUL_CONSONANT:
    1:       success = CharListToText(aOrdinal, result, gHangulConsonantChars,
    1:                                HANGUL_CONSONANT_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME:
    1:       success = CharListToText(aOrdinal, result, gEthiopicHalehameChars,
    1:                                ETHIOPIC_HALEHAME_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_NUMERIC:
    1:       success = EthiopicToText(aOrdinal, result);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME_AM:
    1:       success = CharListToText(aOrdinal, result, gEthiopicHalehameAmChars,
    1:                                ETHIOPIC_HALEHAME_AM_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME_TI_ER:
    1:       success = CharListToText(aOrdinal, result, gEthiopicHalehameTiErChars,
    1:                                ETHIOPIC_HALEHAME_TI_ER_CHARS_SIZE);
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME_TI_ET:
    1:       success = CharListToText(aOrdinal, result, gEthiopicHalehameTiEtChars,
    1:                                ETHIOPIC_HALEHAME_TI_ET_CHARS_SIZE);
    1:       break;
    1:   }
    1:   return success;
    1: }
    1: 
    1: PRBool
    1: nsBulletFrame::GetListItemText(const nsStyleList& aListStyle,
    1:                                nsString& result)
    1: {
    1:   const nsStyleVisibility* vis = GetStyleVisibility();
    1: 
    1:   NS_ASSERTION(aListStyle.mListStyleType != NS_STYLE_LIST_STYLE_NONE &&
    1:                aListStyle.mListStyleType != NS_STYLE_LIST_STYLE_DISC &&
    1:                aListStyle.mListStyleType != NS_STYLE_LIST_STYLE_CIRCLE &&
    1:                aListStyle.mListStyleType != NS_STYLE_LIST_STYLE_SQUARE,
    1:                "we should be using specialized code for these types");
    1:   PRBool success =
    1:     AppendCounterText(aListStyle.mListStyleType, mOrdinal, result);
11630:   if (success && aListStyle.mListStyleType == NS_STYLE_LIST_STYLE_HEBREW)
11630:     mTextIsRTL = PR_TRUE;
    1: 
    1:   // XXX For some of these systems, "." is wrong!  This should really be
11630:   // pushed down into the individual cases!
11630:   nsString suffix = NS_LITERAL_STRING(".");
11630: 
11630:   // We're not going to do proper Bidi reordering on the list item marker, but
11630:   // just display the whole thing as RTL or LTR, so we fake reordering by
11630:   // appending the suffix to the end of the list item marker if the
11630:   // directionality of the characters is the same as the style direction or
11630:   // prepending it to the beginning if they are different.
11630:   result = (mTextIsRTL == (vis->mDirection == NS_STYLE_DIRECTION_RTL)) ?
11630:           result + suffix : suffix + result;
    1:   return success;
    1: }
    1: 
    1: #define MIN_BULLET_SIZE 1
    1: 
    1: 
    1: void
    1: nsBulletFrame::GetDesiredSize(nsPresContext*  aCX,
    1:                               nsIRenderingContext *aRenderingContext,
    1:                               nsHTMLReflowMetrics& aMetrics)
    1: {
    1:   // Reset our padding.  If we need it, we'll set it below.
    1:   mPadding.SizeTo(0, 0, 0, 0);
    1:   
    1:   const nsStyleList* myList = GetStyleList();
    1:   nscoord ascent;
    1: 
56866:   RemoveStateBits(BULLET_FRAME_IMAGE_LOADING);
56866: 
35581:   if (myList->GetListStyleImage() && mImageRequest) {
    1:     PRUint32 status;
    1:     mImageRequest->GetImageStatus(&status);
    1:     if (status & imgIRequest::STATUS_SIZE_AVAILABLE &&
    1:         !(status & imgIRequest::STATUS_ERROR)) {
    1:       // auto size the image
    1:       mComputedSize.width = mIntrinsicSize.width;
    1:       mComputedSize.height = mIntrinsicSize.height;
    1: 
    1:       aMetrics.width = mComputedSize.width;
    1:       aMetrics.ascent = aMetrics.height = mComputedSize.height;
    1: 
56866:       AddStateBits(BULLET_FRAME_IMAGE_LOADING);
56866: 
    1:       return;
    1:     }
    1:   }
    1: 
    1:   // If we're getting our desired size and don't have an image, reset
    1:   // mIntrinsicSize to (0,0).  Otherwise, if we used to have an image, it
    1:   // changed, and the new one is coming in, but we're reflowing before it's
    1:   // fully there, we'll end up with mIntrinsicSize not matching our size, but
    1:   // won't trigger a reflow in OnStartContainer (because mIntrinsicSize will
    1:   // match the image size).
    1:   mIntrinsicSize.SizeTo(0, 0);
    1: 
 4353:   nsCOMPtr<nsIFontMetrics> fm;
 4353:   nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
    1:   nscoord bulletSize;
    1: 
    1:   nsAutoString text;
    1:   switch (myList->mListStyleType) {
    1:     case NS_STYLE_LIST_STYLE_NONE:
    1:       aMetrics.width = 0;
    1:       aMetrics.ascent = aMetrics.height = 0;
    1:       break;
    1: 
    1:     case NS_STYLE_LIST_STYLE_DISC:
    1:     case NS_STYLE_LIST_STYLE_CIRCLE:
    1:     case NS_STYLE_LIST_STYLE_SQUARE:
    1:       fm->GetMaxAscent(ascent);
32531:       bulletSize = NS_MAX(nsPresContext::CSSPixelsToAppUnits(MIN_BULLET_SIZE),
    1:                           NSToCoordRound(0.8f * (float(ascent) / 2.0f)));
    1:       mPadding.bottom = NSToCoordRound(float(ascent) / 8.0f);
    1:       aMetrics.width = mPadding.right + bulletSize;
    1:       aMetrics.ascent = aMetrics.height = mPadding.bottom + bulletSize;
    1:       break;
    1: 
    1:     default:
    1:     case NS_STYLE_LIST_STYLE_DECIMAL_LEADING_ZERO:
    1:     case NS_STYLE_LIST_STYLE_DECIMAL:
    1:     case NS_STYLE_LIST_STYLE_OLD_DECIMAL:
    1:     case NS_STYLE_LIST_STYLE_LOWER_ROMAN:
    1:     case NS_STYLE_LIST_STYLE_UPPER_ROMAN:
    1:     case NS_STYLE_LIST_STYLE_LOWER_ALPHA:
    1:     case NS_STYLE_LIST_STYLE_UPPER_ALPHA:
    1:     case NS_STYLE_LIST_STYLE_OLD_LOWER_ROMAN:
    1:     case NS_STYLE_LIST_STYLE_OLD_UPPER_ROMAN:
    1:     case NS_STYLE_LIST_STYLE_OLD_LOWER_ALPHA:
    1:     case NS_STYLE_LIST_STYLE_OLD_UPPER_ALPHA:
    1:     case NS_STYLE_LIST_STYLE_KATAKANA:
    1:     case NS_STYLE_LIST_STYLE_HIRAGANA:
    1:     case NS_STYLE_LIST_STYLE_KATAKANA_IROHA:
    1:     case NS_STYLE_LIST_STYLE_HIRAGANA_IROHA:
    1:     case NS_STYLE_LIST_STYLE_LOWER_GREEK:
    1:     case NS_STYLE_LIST_STYLE_HEBREW: 
    1:     case NS_STYLE_LIST_STYLE_ARMENIAN: 
    1:     case NS_STYLE_LIST_STYLE_GEORGIAN: 
    1:     case NS_STYLE_LIST_STYLE_CJK_IDEOGRAPHIC: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_SIMP_CHINESE_INFORMAL: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_SIMP_CHINESE_FORMAL: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_TRAD_CHINESE_INFORMAL: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_TRAD_CHINESE_FORMAL: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_JAPANESE_INFORMAL: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_JAPANESE_FORMAL: 
    1:     case NS_STYLE_LIST_STYLE_MOZ_CJK_HEAVENLY_STEM:
    1:     case NS_STYLE_LIST_STYLE_MOZ_CJK_EARTHLY_BRANCH:
    1:     case NS_STYLE_LIST_STYLE_MOZ_ARABIC_INDIC:
    1:     case NS_STYLE_LIST_STYLE_MOZ_PERSIAN:
    1:     case NS_STYLE_LIST_STYLE_MOZ_URDU:
    1:     case NS_STYLE_LIST_STYLE_MOZ_DEVANAGARI:
    1:     case NS_STYLE_LIST_STYLE_MOZ_GURMUKHI:
    1:     case NS_STYLE_LIST_STYLE_MOZ_GUJARATI:
    1:     case NS_STYLE_LIST_STYLE_MOZ_ORIYA:
    1:     case NS_STYLE_LIST_STYLE_MOZ_KANNADA:
    1:     case NS_STYLE_LIST_STYLE_MOZ_MALAYALAM:
    1:     case NS_STYLE_LIST_STYLE_MOZ_BENGALI:
    1:     case NS_STYLE_LIST_STYLE_MOZ_TAMIL:
    1:     case NS_STYLE_LIST_STYLE_MOZ_TELUGU:
    1:     case NS_STYLE_LIST_STYLE_MOZ_THAI:
    1:     case NS_STYLE_LIST_STYLE_MOZ_LAO:
    1:     case NS_STYLE_LIST_STYLE_MOZ_MYANMAR:
    1:     case NS_STYLE_LIST_STYLE_MOZ_KHMER:
    1:     case NS_STYLE_LIST_STYLE_MOZ_HANGUL:
    1:     case NS_STYLE_LIST_STYLE_MOZ_HANGUL_CONSONANT:
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME:
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_NUMERIC:
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME_AM:
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME_TI_ER:
    1:     case NS_STYLE_LIST_STYLE_MOZ_ETHIOPIC_HALEHAME_TI_ET:
    1:       GetListItemText(*myList, text);
    1:       fm->GetHeight(aMetrics.height);
    1:       aRenderingContext->SetFont(fm);
    1:       aMetrics.width = nsLayoutUtils::GetStringWidth(this, aRenderingContext, text.get(), text.Length());
    1:       aMetrics.width += mPadding.right;
    1:       fm->GetMaxAscent(aMetrics.ascent);
    1:       break;
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBulletFrame::Reflow(nsPresContext* aPresContext,
    1:                       nsHTMLReflowMetrics& aMetrics,
    1:                       const nsHTMLReflowState& aReflowState,
    1:                       nsReflowStatus& aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsBulletFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
    1: 
    1:   // Get the base size
    1:   GetDesiredSize(aPresContext, aReflowState.rendContext, aMetrics);
    1: 
    1:   // Add in the border and padding; split the top/bottom between the
    1:   // ascent and descent to make things look nice
    1:   const nsMargin& borderPadding = aReflowState.mComputedBorderPadding;
    1:   aMetrics.width += borderPadding.left + borderPadding.right;
    1:   aMetrics.height += borderPadding.top + borderPadding.bottom;
    1:   aMetrics.ascent += borderPadding.top;
    1: 
 6247:   // XXX this is a bit of a hack, we're assuming that no glyphs used for bullets
 6247:   // overflow their font-boxes. It'll do for now; to fix it for real, we really
 6247:   // should rewrite all the text-handling code here to use gfxTextRun (bug
 6247:   // 397294).
55039:   aMetrics.SetOverflowAreasToDesiredBounds();
 6247: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsBulletFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nsHTMLReflowMetrics metrics;
    1:   DISPLAY_MIN_WIDTH(this, metrics.width);
  238:   GetDesiredSize(PresContext(), aRenderingContext, metrics);
    1:   return metrics.width;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsBulletFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nsHTMLReflowMetrics metrics;
    1:   DISPLAY_PREF_WIDTH(this, metrics.width);
  238:   GetDesiredSize(PresContext(), aRenderingContext, metrics);
    1:   return metrics.width;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsBulletFrame::OnStartContainer(imgIRequest *aRequest,
    1:                                               imgIContainer *aImage)
    1: {
    1:   if (!aImage) return NS_ERROR_INVALID_ARG;
    1:   if (!aRequest) return NS_ERROR_INVALID_ARG;
    1: 
    1:   PRUint32 status;
    1:   aRequest->GetImageStatus(&status);
    1:   if (status & imgIRequest::STATUS_ERROR) {
    1:     return NS_OK;
    1:   }
    1:   
    1:   nscoord w, h;
    1:   aImage->GetWidth(&w);
    1:   aImage->GetHeight(&h);
    1: 
  238:   nsPresContext* presContext = PresContext();
    1: 
    1:   nsSize newsize(nsPresContext::CSSPixelsToAppUnits(w),
    1:                  nsPresContext::CSSPixelsToAppUnits(h));
    1: 
    1:   if (mIntrinsicSize != newsize) {
    1:     mIntrinsicSize = newsize;
    1: 
    1:     // Now that the size is available (or an error occurred), trigger
    1:     // a reflow of the bullet frame.
    1:     nsIPresShell *shell = presContext->GetPresShell();
    1:     if (shell) {
 1158:       shell->FrameNeedsReflow(this, nsIPresShell::eStyleChange,
 1158:                               NS_FRAME_IS_DIRTY);
    1:     }
    1:   }
    1: 
    1:   // Handle animations
    1:   aImage->SetAnimationMode(presContext->ImageAnimationMode());
52149:   // Ensure the animation (if any) is started. Note: There is no
52149:   // corresponding call to Decrement for this. This Increment will be
52149:   // 'cleaned up' by the Request when it is destroyed, but only then.
52149:   aRequest->IncrementAnimationConsumers();
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsBulletFrame::OnDataAvailable(imgIRequest *aRequest,
30479:                                              PRBool aCurrentFrame,
23738:                                              const nsIntRect *aRect)
    1: {
    1:   // The image has changed.
    1:   // Invalidate the entire content area. Maybe it's not optimal but it's simple and
    1:   // always correct, and I'll be a stunned mullet if it ever matters for performance
19380:   Invalidate(nsRect(0, 0, mRect.width, mRect.height));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsBulletFrame::OnStopDecode(imgIRequest *aRequest,
    1:                                           nsresult aStatus,
    1:                                           const PRUnichar *aStatusArg)
    1: {
    1:   // XXX should the bulletframe do anything if the image failed to load?
    1:   //     it didn't in the old code...
    1: 
    1: #if 0
    1:   if (NS_FAILED(aStatus)) {
    1:     // We failed to load the image. Notify the pres shell
    1:     if (NS_FAILED(aStatus) && (mImageRequest == aRequest || !mImageRequest)) {
    1:       imageFailed = PR_TRUE;
    1:     }
    1:   }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsBulletFrame::FrameChanged(imgIContainer *aContainer,
50544:                                           const nsIntRect *aDirtyRect)
    1: {
    1:   // Invalidate the entire content area. Maybe it's not optimal but it's simple and
    1:   // always correct.
19380:   Invalidate(nsRect(0, 0, mRect.width, mRect.height));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsBulletFrame::GetLoadGroup(nsPresContext *aPresContext, nsILoadGroup **aLoadGroup)
    1: {
    1:   if (!aPresContext)
    1:     return;
    1: 
    1:   NS_PRECONDITION(nsnull != aLoadGroup, "null OUT parameter pointer");
    1: 
    1:   nsIPresShell *shell = aPresContext->GetPresShell();
    1: 
    1:   if (!shell)
    1:     return;
    1: 
    1:   nsIDocument *doc = shell->GetDocument();
    1:   if (!doc)
    1:     return;
    1: 
    1:   *aLoadGroup = doc->GetDocumentLoadGroup().get();  // already_AddRefed
    1: }
    1: 
56866: nscoord
56866: nsBulletFrame::GetBaseline() const
56866: {
56866:   nscoord ascent = 0, bottomPadding;
56866:   if (GetStateBits() & BULLET_FRAME_IMAGE_LOADING) {
56866:     ascent = GetRect().height;
56866:   } else {
56866:     nsCOMPtr<nsIFontMetrics> fm;
56866:     nsLayoutUtils::GetFontMetricsForFrame(this, getter_AddRefs(fm));
56866:     const nsStyleList* myList = GetStyleList();
56866:     switch (myList->mListStyleType) {
56866:       case NS_STYLE_LIST_STYLE_NONE:
56866:         break;
56866: 
56866:       case NS_STYLE_LIST_STYLE_DISC:
56866:       case NS_STYLE_LIST_STYLE_CIRCLE:
56866:       case NS_STYLE_LIST_STYLE_SQUARE:
56866:         fm->GetMaxAscent(ascent);
56866:         bottomPadding = NSToCoordRound(float(ascent) / 8.0f);
56866:         ascent = NS_MAX(nsPresContext::CSSPixelsToAppUnits(MIN_BULLET_SIZE),
56866:                         NSToCoordRound(0.8f * (float(ascent) / 2.0f)));
56866:         ascent += bottomPadding;
56866:         break;
56866: 
56866:       default:
56866:         fm->GetMaxAscent(ascent);
56866:         break;
56866:     }
56866:   }
56866:   return ascent + GetUsedBorderAndPadding().top;
56866: }
56866: 
    1: 
    1: 
    1: 
    1: 
    1: 
    1: 
    1: 
    1: NS_IMPL_ISUPPORTS2(nsBulletListener, imgIDecoderObserver, imgIContainerObserver)
    1: 
    1: nsBulletListener::nsBulletListener() :
    1:   mFrame(nsnull)
    1: {
    1: }
    1: 
    1: nsBulletListener::~nsBulletListener()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP nsBulletListener::OnStartContainer(imgIRequest *aRequest,
    1:                                                  imgIContainer *aImage)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return mFrame->OnStartContainer(aRequest, aImage);
    1: }
    1: 
    1: NS_IMETHODIMP nsBulletListener::OnDataAvailable(imgIRequest *aRequest,
30479:                                                 PRBool aCurrentFrame,
23738:                                                 const nsIntRect *aRect)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
30479:   return mFrame->OnDataAvailable(aRequest, aCurrentFrame, aRect);
    1: }
    1: 
    1: NS_IMETHODIMP nsBulletListener::OnStopDecode(imgIRequest *aRequest,
    1:                                              nsresult status,
    1:                                              const PRUnichar *statusArg)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1:   
    1:   return mFrame->OnStopDecode(aRequest, status, statusArg);
    1: }
    1: 
    1: NS_IMETHODIMP nsBulletListener::FrameChanged(imgIContainer *aContainer,
50544:                                              const nsIntRect *aDirtyRect)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
50544:   return mFrame->FrameChanged(aContainer, aDirtyRect);
    1: }
