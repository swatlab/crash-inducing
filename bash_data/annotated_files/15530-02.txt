    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS script operations.
    1:  */
    1: #include "jsstddef.h"
    1: #include <string.h>
    1: #include "jstypes.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
    1: #include "jsconfig.h"
    1: #include "jsdbgapi.h"
    1: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsopcode.h"
 6561: #include "jsparse.h"
    1: #include "jsscript.h"
    1: #if JS_HAS_XDR
    1: #include "jsxdrapi.h"
    1: #endif
    1: 
    1: #if JS_HAS_SCRIPT_OBJECT
    1: 
 4127: static const char js_script_exec_str[]    = "Script.prototype.exec";
 4127: static const char js_script_compile_str[] = "Script.prototype.compile";
    1: 
    1: /*
    1:  * This routine requires that obj has been locked previously.
    1:  */
    1: static jsint
    1: GetScriptExecDepth(JSContext *cx, JSObject *obj)
    1: {
    1:     jsval v;
    1: 
    1:     JS_ASSERT(JS_IS_OBJ_LOCKED(cx, obj));
    1:     v = LOCKED_OBJ_GET_SLOT(obj, JSSLOT_START(&js_ScriptClass));
    1:     return JSVAL_TO_INT(v);
    1: }
    1: 
    1: static void
    1: AdjustScriptExecDepth(JSContext *cx, JSObject *obj, jsint delta)
    1: {
    1:     jsint execDepth;
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     execDepth = GetScriptExecDepth(cx, obj);
    1:     LOCKED_OBJ_SET_SLOT(obj, JSSLOT_START(&js_ScriptClass),
    1:                         INT_TO_JSVAL(execDepth + delta));
    1:     JS_UNLOCK_OBJ(cx, obj);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: static JSBool
 4127: script_toSource(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
    1:     uint32 indent;
    1:     JSScript *script;
    1:     size_t i, j, k, n;
    1:     char buf[16];
    1:     jschar *s, *t;
    1:     JSString *str;
    1: 
 4127:     obj = JS_THIS_OBJECT(cx, vp);
 4127:     if (!JS_InstanceOf(cx, obj, &js_ScriptClass, vp + 2))
    1:         return JS_FALSE;
    1: 
    1:     indent = 0;
12681:     if (argc != 0) {
12681:         indent = js_ValueToECMAUint32(cx, &vp[2]);
12694:         if (JSVAL_IS_NULL(vp[2]))
    1:             return JS_FALSE;
12681:     }
    1: 
    1:     script = (JSScript *) JS_GetPrivate(cx, obj);
    1: 
    1:     /* Let n count the source string length, j the "front porch" length. */
    1:     j = JS_snprintf(buf, sizeof buf, "(new %s(", js_ScriptClass.name);
    1:     n = j + 2;
    1:     if (!script) {
    1:         /* Let k count the constructor argument string length. */
    1:         k = 0;
    1:         s = NULL;               /* quell GCC overwarning */
    1:     } else {
    1:         str = JS_DecompileScript(cx, script, "Script.prototype.toSource",
    1:                                  (uintN)indent);
    1:         if (!str)
    1:             return JS_FALSE;
    1:         str = js_QuoteString(cx, str, '\'');
    1:         if (!str)
    1:             return JS_FALSE;
 4718:         JSSTRING_CHARS_AND_LENGTH(str, s, k);
    1:         n += k;
    1:     }
    1: 
    1:     /* Allocate the source string and copy into it. */
    1:     t = (jschar *) JS_malloc(cx, (n + 1) * sizeof(jschar));
    1:     if (!t)
    1:         return JS_FALSE;
    1:     for (i = 0; i < j; i++)
    1:         t[i] = buf[i];
    1:     for (j = 0; j < k; i++, j++)
    1:         t[i] = s[j];
    1:     t[i++] = ')';
    1:     t[i++] = ')';
    1:     t[i] = 0;
    1: 
    1:     /* Create and return a JS string for t. */
    1:     str = JS_NewUCString(cx, t, n);
    1:     if (!str) {
    1:         JS_free(cx, t);
    1:         return JS_FALSE;
    1:     }
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: #endif /* JS_HAS_TOSOURCE */
    1: 
    1: static JSBool
 4127: script_toString(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     uint32 indent;
 4127:     JSObject *obj;
    1:     JSScript *script;
    1:     JSString *str;
    1: 
    1:     indent = 0;
12681:     if (argc != 0) {
12681:         indent = js_ValueToECMAUint32(cx, &vp[2]);
12694:         if (JSVAL_IS_NULL(vp[2]))
    1:             return JS_FALSE;
12681:     }
    1: 
 4127:     obj = JS_THIS_OBJECT(cx, vp);
 4127:     if (!JS_InstanceOf(cx, obj, &js_ScriptClass, vp + 2))
    1:         return JS_FALSE;
    1:     script = (JSScript *) JS_GetPrivate(cx, obj);
    1:     if (!script) {
 4127:         *vp = STRING_TO_JSVAL(cx->runtime->emptyString);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     str = JS_DecompileScript(cx, script, "Script.prototype.toString",
    1:                              (uintN)indent);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: script_compile_sub(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                    jsval *rval)
    1: {
    1:     JSString *str;
    1:     JSObject *scopeobj;
    1:     jsval v;
    1:     JSScript *script, *oldscript;
    1:     JSStackFrame *fp, *caller;
    1:     const char *file;
    1:     uintN line;
    1:     JSPrincipals *principals;
 8444:     uint32 tcflags;
    1:     jsint execDepth;
    1: 
    1:     /* Make sure obj is a Script object. */
    1:     if (!JS_InstanceOf(cx, obj, &js_ScriptClass, argv))
    1:         return JS_FALSE;
    1: 
    1:     /* If no args, leave private undefined and return early. */
    1:     if (argc == 0)
    1:         goto out;
    1: 
    1:     /* Otherwise, the first arg is the script source to compile. */
    1:     str = js_ValueToString(cx, argv[0]);
    1:     if (!str)
    1:         return JS_FALSE;
    1:     argv[0] = STRING_TO_JSVAL(str);
    1: 
    1:     scopeobj = NULL;
    1:     if (argc >= 2) {
    1:         if (!js_ValueToObject(cx, argv[1], &scopeobj))
    1:             return JS_FALSE;
    1:         argv[1] = OBJECT_TO_JSVAL(scopeobj);
    1:     }
    1: 
    1:     /* Compile using the caller's scope chain, which js_Invoke passes to fp. */
    1:     fp = cx->fp;
    1:     caller = JS_GetScriptedCaller(cx, fp);
    1:     JS_ASSERT(!caller || fp->scopeChain == caller->scopeChain);
    1: 
    1:     if (caller) {
    1:         if (!scopeobj) {
    1:             scopeobj = js_GetScopeChain(cx, caller);
    1:             if (!scopeobj)
    1:                 return JS_FALSE;
    1:             fp->scopeChain = scopeobj;  /* for the compiler's benefit */
    1:         }
    1: 
    1:         principals = JS_EvalFramePrincipals(cx, fp, caller);
12690:         file = js_ComputeFilename(cx, caller, principals, &line);
    1:     } else {
    1:         file = NULL;
    1:         line = 0;
    1:         principals = NULL;
    1:     }
    1: 
    1:     /* Ensure we compile this script with the right (inner) principals. */
 4127:     scopeobj = js_CheckScopeChainValidity(cx, scopeobj, js_script_compile_str);
    1:     if (!scopeobj)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Compile the new script using the caller's scope chain, a la eval().
 8444:      * Unlike jsobj.c:obj_eval, however, we do not pass TCF_COMPILE_N_GO in
 8444:      * tcflags, because compilation is here separated from execution, and the
    1:      * run-time scope chain may not match the compile-time.  JSFRAME_EVAL is
    1:      * tested in jsemit.c and jsscan.c to optimize based on identity of run-
    1:      * and compile-time scope.
    1:      */
    1:     fp->flags |= JSFRAME_SCRIPT_OBJECT;
 8444:     tcflags = 0;
 8444:     script = js_CompileScript(cx, scopeobj, principals, tcflags,
 8444:                               JSSTRING_CHARS(str), JSSTRING_LENGTH(str),
 8444:                               NULL, file, line);
    1:     if (!script)
    1:         return JS_FALSE;
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     execDepth = GetScriptExecDepth(cx, obj);
    1: 
    1:     /*
    1:      * execDepth must be 0 to allow compilation here, otherwise the JSScript
    1:      * struct can be released while running.
    1:      */
    1:     if (execDepth > 0) {
    1:         JS_UNLOCK_OBJ(cx, obj);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_COMPILE_EXECED_SCRIPT);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Swap script for obj's old script, if any. */
    1:     v = LOCKED_OBJ_GET_SLOT(obj, JSSLOT_PRIVATE);
    1:     oldscript = !JSVAL_IS_VOID(v) ? JSVAL_TO_PRIVATE(v) : NULL;
    1:     LOCKED_OBJ_SET_SLOT(obj, JSSLOT_PRIVATE, PRIVATE_TO_JSVAL(script));
    1:     JS_UNLOCK_OBJ(cx, obj);
    1: 
    1:     if (oldscript)
    1:         js_DestroyScript(cx, oldscript);
    1: 
    1:     script->object = obj;
    1:     js_CallNewScriptHook(cx, script, NULL);
    1: 
    1: out:
    1:     /* Return the object. */
    1:     *rval = OBJECT_TO_JSVAL(obj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: script_compile(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     return script_compile_sub(cx, JS_THIS_OBJECT(cx, vp), argc, vp + 2, vp);
 4127: }
 4127: 
 4127: static JSBool
 4127: script_exec_sub(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
 4127:                 jsval *rval)
    1: {
    1:     JSObject *scopeobj, *parent;
    1:     JSStackFrame *fp, *caller;
    1:     JSPrincipals *principals;
    1:     JSScript *script;
    1:     JSBool ok;
    1: 
    1:     if (!JS_InstanceOf(cx, obj, &js_ScriptClass, argv))
    1:         return JS_FALSE;
    1: 
    1:     scopeobj = NULL;
 4127:     if (argc != 0) {
    1:         if (!js_ValueToObject(cx, argv[0], &scopeobj))
    1:             return JS_FALSE;
    1:         argv[0] = OBJECT_TO_JSVAL(scopeobj);
    1:     }
    1: 
    1:     /*
    1:      * Emulate eval() by using caller's this, var object, sharp array, etc.,
    1:      * all propagated by js_Execute via a non-null fourth (down) argument to
    1:      * js_Execute.  If there is no scripted caller, js_Execute uses its second
    1:      * (chain) argument to set the exec frame's varobj, thisp, and scopeChain.
    1:      *
    1:      * Unlike eval, which the compiler detects, Script.prototype.exec may be
    1:      * called from a lightweight function, or even from native code (in which
    1:      * case fp->varobj and fp->scopeChain are null).  If exec is called from
    1:      * a lightweight function, we will need to get a Call object representing
    1:      * its frame, to act as the var object and scope chain head.
    1:      */
    1:     fp = cx->fp;
    1:     caller = JS_GetScriptedCaller(cx, fp);
    1:     if (caller && !caller->varobj) {
    1:         /* Called from a lightweight function. */
    1:         JS_ASSERT(caller->fun && !JSFUN_HEAVYWEIGHT_TEST(caller->fun->flags));
    1: 
    1:         /* Scope chain links from Call object to callee's parent. */
 4127:         parent = OBJ_GET_PARENT(cx, caller->callee);
    1:         if (!js_GetCallObject(cx, caller, parent))
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     if (!scopeobj) {
    1:         /* No scope object passed in: try to use the caller's scope chain. */
    1:         if (caller) {
    1:             /*
    1:              * Load caller->scopeChain after the conditional js_GetCallObject
    1:              * call above, which resets scopeChain as well as varobj.
    1:              */
    1:             scopeobj = js_GetScopeChain(cx, caller);
    1:             if (!scopeobj)
    1:                 return JS_FALSE;
    1:         } else {
    1:             /*
    1:              * Called from native code, so we don't know what scope object to
    1:              * use.  We could use parent (see above), but Script.prototype.exec
    1:              * might be a shared/sealed "superglobal" method.  A more general
    1:              * approach would use cx->globalObject, which will be the same as
    1:              * exec.__parent__ in the non-superglobal case.  In the superglobal
    1:              * case it's the right object: the global, not the superglobal.
    1:              */
    1:             scopeobj = cx->globalObject;
    1:         }
    1:     }
    1: 
 4127:     scopeobj = js_CheckScopeChainValidity(cx, scopeobj, js_script_exec_str);
    1:     if (!scopeobj)
    1:         return JS_FALSE;
    1: 
    1:     /* Keep track of nesting depth for the script. */
    1:     AdjustScriptExecDepth(cx, obj, 1);
    1: 
    1:     /* Must get to out label after this */
    1:     script = (JSScript *) JS_GetPrivate(cx, obj);
    1:     if (!script) {
    1:         ok = JS_FALSE;
    1:         goto out;
    1:     }
    1: 
    1:     /* Belt-and-braces: check that this script object has access to scopeobj. */
    1:     principals = script->principals;
    1:     ok = js_CheckPrincipalsAccess(cx, scopeobj, principals,
    1:                                   CLASS_ATOM(cx, Script));
    1:     if (!ok)
    1:         goto out;
    1: 
    1:     ok = js_Execute(cx, scopeobj, script, caller, JSFRAME_EVAL, rval);
    1: 
    1: out:
    1:     AdjustScriptExecDepth(cx, obj, -1);
    1:     return ok;
    1: }
    1: 
 4127: static JSBool
 4127: script_exec(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     return script_exec_sub(cx, JS_THIS_OBJECT(cx, vp), argc, vp + 2, vp);
 4127: }
 4127: 
    1: #endif /* JS_HAS_SCRIPT_OBJECT */
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: JSBool
    1: js_XDRScript(JSXDRState *xdr, JSScript **scriptp, JSBool *hasMagic)
    1: {
    1:     JSContext *cx;
 3235:     JSScript *script, *oldscript;
13474:     JSBool ok;
13474:     jsbytecode *code;
 3235:     uint32 length, lineno, depth, magic;
 3235:     uint32 natoms, nsrcnotes, ntrynotes, nobjects, nregexps, i;
    1:     uint32 prologLength, version;
11089:     JSTempValueRooter tvr;
 3235:     JSPrincipals *principals;
 3235:     uint32 encodeable;
    1:     JSBool filenameWasSaved;
    1:     jssrcnote *notes, *sn;
    1: 
    1:     cx = xdr->cx;
    1:     script = *scriptp;
 3235:     nsrcnotes = ntrynotes = natoms = nobjects = nregexps = 0;
    1:     filenameWasSaved = JS_FALSE;
    1:     notes = NULL;
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE)
    1:         magic = JSXDR_MAGIC_SCRIPT_CURRENT;
    1:     if (!JS_XDRUint32(xdr, &magic))
    1:         return JS_FALSE;
 3235:     if (magic != JSXDR_MAGIC_SCRIPT_CURRENT) {
 3235:         /* We do not provide binary compatibility with older scripts. */
    1:         if (!hasMagic) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_BAD_SCRIPT_MAGIC);
    1:             return JS_FALSE;
    1:         }
    1:         *hasMagic = JS_FALSE;
    1:         return JS_TRUE;
    1:     }
    1:     if (hasMagic)
    1:         *hasMagic = JS_TRUE;
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         length = script->length;
    1:         prologLength = PTRDIFF(script->main, script->code, jsbytecode);
    1:         JS_ASSERT((int16)script->version != JSVERSION_UNKNOWN);
 3235:         version = (uint32)script->version | (script->ngvars << 16);
    1:         lineno = (uint32)script->lineno;
    1:         depth = (uint32)script->depth;
 3235:         natoms = (uint32)script->atomMap.length;
    1: 
    1:         /* Count the srcnotes, keeping notes pointing at the first one. */
    1:         notes = SCRIPT_NOTES(script);
    1:         for (sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
    1:             continue;
    1:         nsrcnotes = PTRDIFF(sn, notes, jssrcnote);
    1:         nsrcnotes++;            /* room for the terminator */
    1: 
 3235:         if (script->objectsOffset != 0)
 3235:             nobjects = JS_SCRIPT_OBJECTS(script)->length;
 3235:         if (script->regexpsOffset != 0)
 3235:             nregexps = JS_SCRIPT_REGEXPS(script)->length;
 3235:         if (script->trynotesOffset != 0)
 3235:             ntrynotes = JS_SCRIPT_TRYNOTES(script)->length;
    1:     }
    1: 
    1:     if (!JS_XDRUint32(xdr, &length))
    1:         return JS_FALSE;
    1:     if (!JS_XDRUint32(xdr, &prologLength))
    1:         return JS_FALSE;
    1:     if (!JS_XDRUint32(xdr, &version))
    1:         return JS_FALSE;
    1: 
 3235:     /*
 3235:      * To fuse allocations, we need srcnote, atom, objects, regexp and trynote
 3235:      * counts early.
 3235:      */
 3235:     if (!JS_XDRUint32(xdr, &natoms))
 3235:         return JS_FALSE;
    1:     if (!JS_XDRUint32(xdr, &nsrcnotes))
    1:         return JS_FALSE;
    1:     if (!JS_XDRUint32(xdr, &ntrynotes))
    1:         return JS_FALSE;
 3235:     if (!JS_XDRUint32(xdr, &nobjects))
 3235:         return JS_FALSE;
 3235:     if (!JS_XDRUint32(xdr, &nregexps))
 3235:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
 3235:         script = js_NewScript(cx, length, nsrcnotes, natoms, nobjects, nregexps,
 3235:                               ntrynotes);
    1:         if (!script)
    1:             return JS_FALSE;
 3235: 
    1:         script->main += prologLength;
    1:         script->version = (JSVersion) (version & 0xffff);
 3235:         script->ngvars = (uint16) (version >> 16);
    1: 
    1:         /* If we know nsrcnotes, we allocated space for notes in script. */
    1:         notes = SCRIPT_NOTES(script);
    1:         *scriptp = script;
11089:         JS_PUSH_TEMP_ROOT_SCRIPT(cx, script, &tvr);
    1:     }
    1: 
    1:     /*
 3235:      * Control hereafter must goto error on failure, in order for the
 3235:      * DECODE case to destroy script.
    1:      */
    1:     oldscript = xdr->script;
13474:     code = script->code;
13474:     if (xdr->mode == JSXDR_ENCODE) {
13496:         code = js_UntrapScriptCode(cx, script);
13474:         if (!code)
13474:             goto error;
13474:     }
13474: 
    1:     xdr->script = script;
13474:     ok = JS_XDRBytes(xdr, (char *) code, length * sizeof(jsbytecode));
13474: 
13474:     if (code != script->code)
13474:         JS_free(cx, code);
13474: 
13474:     if (!ok)
    1:         goto error;
    1: 
    1:     if (!JS_XDRBytes(xdr, (char *)notes, nsrcnotes * sizeof(jssrcnote)) ||
    1:         !JS_XDRCStringOrNull(xdr, (char **)&script->filename) ||
    1:         !JS_XDRUint32(xdr, &lineno) ||
 3235:         !JS_XDRUint32(xdr, &depth)) {
    1:         goto error;
    1:     }
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         principals = script->principals;
    1:         encodeable = (cx->runtime->principalsTranscoder != NULL);
    1:         if (!JS_XDRUint32(xdr, &encodeable))
    1:             goto error;
    1:         if (encodeable &&
    1:             !cx->runtime->principalsTranscoder(xdr, &principals)) {
    1:             goto error;
    1:         }
    1:     } else {
    1:         if (!JS_XDRUint32(xdr, &encodeable))
    1:             goto error;
    1:         if (encodeable) {
    1:             if (!cx->runtime->principalsTranscoder) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_CANT_DECODE_PRINCIPALS);
    1:                 goto error;
    1:             }
    1:             if (!cx->runtime->principalsTranscoder(xdr, &principals))
    1:                 goto error;
    1:             script->principals = principals;
    1:         }
    1:     }
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         const char *filename = script->filename;
    1:         if (filename) {
    1:             filename = js_SaveScriptFilename(cx, filename);
    1:             if (!filename)
    1:                 goto error;
    1:             JS_free(cx, (void *) script->filename);
    1:             script->filename = filename;
    1:             filenameWasSaved = JS_TRUE;
    1:         }
    1:         script->lineno = (uintN)lineno;
    1:         script->depth = (uintN)depth;
 3235:     }
    1: 
 3235:     for (i = 0; i != natoms; ++i) {
 3235:         if (!js_XDRAtom(xdr, &script->atomMap.vector[i]))
 3235:             goto error;
 3235:     }
 1825: 
    1:     /*
 3235:      * Here looping from 0-to-length to xdr objects is essential. It ensures
 3235:      * that block objects from the script->objects will be written and
 3235:      * restored in the outer-to-inner order. block_xdrObject uses this to
 3235:      * restore the parent chain.
    1:      */
 3235:     for (i = 0; i != nobjects; ++i) {
 3235:         if (!js_XDRObject(xdr, &JS_SCRIPT_OBJECTS(script)->vector[i]))
    1:             goto error;
    1:     }
 3235:     for (i = 0; i != nregexps; ++i) {
 3235:         if (!js_XDRObject(xdr, &JS_SCRIPT_REGEXPS(script)->vector[i]))
 3235:             goto error;
    1:     }
    1: 
 3235:     if (ntrynotes != 0) {
 1825:         /*
 3235:          * We combine tn->kind and tn->stackDepth when serializing as XDR is not
 1825:          * efficient when serializing small integer types.
 1825:          */
 3235:         JSTryNote *tn, *tnfirst;
 3235:         uint32 kindAndDepth;
 1825:         JS_STATIC_ASSERT(sizeof(tn->kind) == sizeof(uint8));
 1825:         JS_STATIC_ASSERT(sizeof(tn->stackDepth) == sizeof(uint16));
    1: 
 3235:         tnfirst = JS_SCRIPT_TRYNOTES(script)->vector;
 3235:         JS_ASSERT(JS_SCRIPT_TRYNOTES(script)->length == ntrynotes);
 3235:         tn = tnfirst + ntrynotes;
 3235:         do {
 3235:             --tn;
 3235:             if (xdr->mode == JSXDR_ENCODE) {
 3235:                 kindAndDepth = ((uint32)tn->kind << 16)
 3235:                                | (uint32)tn->stackDepth;
 3235:             }
 1825:             if (!JS_XDRUint32(xdr, &kindAndDepth) ||
 1825:                 !JS_XDRUint32(xdr, &tn->start) ||
 1825:                 !JS_XDRUint32(xdr, &tn->length)) {
    1:                 goto error;
    1:             }
 3235:             if (xdr->mode == JSXDR_DECODE) {
 1825:                 tn->kind = (uint8)(kindAndDepth >> 16);
 1825:                 tn->stackDepth = (uint16)kindAndDepth;
    1:             }
 3235:         } while (tn != tnfirst);
 3235:     }
    1: 
    1:     xdr->script = oldscript;
11089:     if (xdr->mode == JSXDR_DECODE)
11089:         JS_POP_TEMP_ROOT(cx, &tvr);
    1:     return JS_TRUE;
    1: 
    1:   error:
    1:     if (xdr->mode == JSXDR_DECODE) {
11089:         JS_POP_TEMP_ROOT(cx, &tvr);
    1:         if (script->filename && !filenameWasSaved) {
    1:             JS_free(cx, (void *) script->filename);
    1:             script->filename = NULL;
    1:         }
    1:         js_DestroyScript(cx, script);
    1:         *scriptp = NULL;
    1:     }
 3235:     xdr->script = oldscript;
    1:     return JS_FALSE;
    1: }
    1: 
    1: #if JS_HAS_SCRIPT_OBJECT && JS_HAS_XDR_FREEZE_THAW
    1: /*
    1:  * These cannot be exposed to web content, and chrome does not need them, so
    1:  * we take them out of the Mozilla client altogether.  Fortunately, there is
    1:  * no way to serialize a native function (see fun_xdrObject in jsfun.c).
    1:  */
    1: 
    1: static JSBool
 4127: script_freeze(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
    1:     JSXDRState *xdr;
    1:     JSScript *script;
    1:     JSBool ok, hasMagic;
    1:     uint32 len;
    1:     void *buf;
    1:     JSString *str;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
 4127:     if (!JS_InstanceOf(cx, obj, &js_ScriptClass, vp + 2))
    1:         return JS_FALSE;
    1:     script = (JSScript *) JS_GetPrivate(cx, obj);
    1:     if (!script)
    1:         return JS_TRUE;
    1: 
    1:     /* create new XDR */
    1:     xdr = JS_XDRNewMem(cx, JSXDR_ENCODE);
    1:     if (!xdr)
    1:         return JS_FALSE;
    1: 
    1:     /* write  */
    1:     ok = js_XDRScript(xdr, &script, &hasMagic);
    1:     if (!ok)
    1:         goto out;
    1:     if (!hasMagic) {
 4127:         *vp = JSVAL_VOID;
    1:         goto out;
    1:     }
    1: 
    1:     buf = JS_XDRMemGetData(xdr, &len);
    1:     if (!buf) {
    1:         ok = JS_FALSE;
    1:         goto out;
    1:     }
    1: 
    1:     JS_ASSERT((jsword)buf % sizeof(jschar) == 0);
    1:     len /= sizeof(jschar);
    1: #if IS_BIG_ENDIAN
    1:   {
    1:     jschar *chars;
    1:     uint32 i;
    1: 
    1:     /* Swap bytes in Unichars to keep frozen strings machine-independent. */
    1:     chars = (jschar *)buf;
    1:     for (i = 0; i < len; i++)
    1:         chars[i] = JSXDR_SWAB16(chars[i]);
    1:   }
    1: #endif
    1:     str = JS_NewUCStringCopyN(cx, (jschar *)buf, len);
    1:     if (!str) {
    1:         ok = JS_FALSE;
    1:         goto out;
    1:     }
    1: 
 4127:     *vp = STRING_TO_JSVAL(str);
    1: 
    1: out:
    1:     JS_XDRDestroy(xdr);
    1:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: script_thaw(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
    1:     JSXDRState *xdr;
    1:     JSString *str;
    1:     void *buf;
    1:     uint32 len;
    1:     jsval v;
    1:     JSScript *script, *oldscript;
    1:     JSBool ok, hasMagic;
 1804:     jsint execDepth;
    1: 
11809:     obj = JS_THIS_OBJECT(cx, vp);
 4127:     if (!JS_InstanceOf(cx, obj, &js_ScriptClass, vp + 2))
    1:         return JS_FALSE;
    1: 
    1:     if (argc == 0)
    1:         return JS_TRUE;
 4127:     str = js_ValueToString(cx, vp[2]);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     vp[2] = STRING_TO_JSVAL(str);
    1: 
    1:     /* create new XDR */
    1:     xdr = JS_XDRNewMem(cx, JSXDR_DECODE);
    1:     if (!xdr)
    1:         return JS_FALSE;
    1: 
 4718:     JSSTRING_CHARS_AND_LENGTH(str, buf, len);
    1: #if IS_BIG_ENDIAN
    1:   {
    1:     jschar *from, *to;
    1:     uint32 i;
    1: 
    1:     /* Swap bytes in Unichars to keep frozen strings machine-independent. */
    1:     from = (jschar *)buf;
    1:     to = (jschar *) JS_malloc(cx, len * sizeof(jschar));
    1:     if (!to) {
    1:         JS_XDRDestroy(xdr);
    1:         return JS_FALSE;
    1:     }
    1:     for (i = 0; i < len; i++)
    1:         to[i] = JSXDR_SWAB16(from[i]);
    1:     buf = (char *)to;
    1:   }
    1: #endif
    1:     len *= sizeof(jschar);
    1:     JS_XDRMemSetData(xdr, buf, len);
    1: 
    1:     /* XXXbe should magic mismatch be error, or false return value? */
    1:     ok = js_XDRScript(xdr, &script, &hasMagic);
    1:     if (!ok)
    1:         goto out;
    1:     if (!hasMagic) {
 4127:         *vp = JSVAL_FALSE;
    1:         goto out;
    1:     }
    1: 
    1:     JS_LOCK_OBJ(cx, obj);
    1:     execDepth = GetScriptExecDepth(cx, obj);
    1: 
    1:     /*
    1:      * execDepth must be 0 to allow compilation here, otherwise the JSScript
    1:      * struct can be released while running.
    1:      */
    1:     if (execDepth > 0) {
    1:         JS_UNLOCK_OBJ(cx, obj);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_COMPILE_EXECED_SCRIPT);
    1:         goto out;
    1:     }
    1: 
    1:     /* Swap script for obj's old script, if any. */
    1:     v = LOCKED_OBJ_GET_SLOT(obj, JSSLOT_PRIVATE);
    1:     oldscript = !JSVAL_IS_VOID(v) ? JSVAL_TO_PRIVATE(v) : NULL;
 1806:     LOCKED_OBJ_SET_SLOT(obj, JSSLOT_PRIVATE, PRIVATE_TO_JSVAL(script));
    1:     JS_UNLOCK_OBJ(cx, obj);
    1: 
    1:     if (oldscript)
    1:         js_DestroyScript(cx, oldscript);
    1: 
    1:     script->object = obj;
    1:     js_CallNewScriptHook(cx, script, NULL);
    1: 
    1: out:
    1:     /*
    1:      * We reset the buffer to be NULL so that it doesn't free the chars
 4127:      * memory owned by str (vp[2]).
    1:      */
    1:     JS_XDRMemSetData(xdr, NULL, 0);
    1:     JS_XDRDestroy(xdr);
    1: #if IS_BIG_ENDIAN
    1:     JS_free(cx, buf);
    1: #endif
 4127:     *vp = JSVAL_TRUE;
    1:     return ok;
    1: }
    1: 
    1: static const char js_thaw_str[] = "thaw";
    1: 
    1: #endif /* JS_HAS_SCRIPT_OBJECT && JS_HAS_XDR_FREEZE_THAW */
    1: #endif /* JS_HAS_XDR */
    1: 
    1: #if JS_HAS_SCRIPT_OBJECT
    1: 
    1: static JSFunctionSpec script_methods[] = {
    1: #if JS_HAS_TOSOURCE
 6917:     JS_FN(js_toSource_str,   script_toSource,   0,0,0),
    1: #endif
 6917:     JS_FN(js_toString_str,   script_toString,   0,0,0),
 6917:     JS_FN("compile",         script_compile,    0,2,0),
 6917:     JS_FN("exec",            script_exec,       0,1,0),
    1: #if JS_HAS_XDR_FREEZE_THAW
 6917:     JS_FN("freeze",          script_freeze,     0,0,0),
 6917:     JS_FN(js_thaw_str,       script_thaw,       0,1,0),
    1: #endif /* JS_HAS_XDR_FREEZE_THAW */
 4127:     JS_FS_END
    1: };
    1: 
    1: #endif /* JS_HAS_SCRIPT_OBJECT */
    1: 
    1: static void
    1: script_finalize(JSContext *cx, JSObject *obj)
    1: {
    1:     JSScript *script;
    1: 
    1:     script = (JSScript *) JS_GetPrivate(cx, obj);
    1:     if (script)
    1:         js_DestroyScript(cx, script);
    1: }
    1: 
    1: static JSBool
    1: script_call(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1: #if JS_HAS_SCRIPT_OBJECT
 4127:     return script_exec_sub(cx, JSVAL_TO_OBJECT(argv[-2]), argc, argv, rval);
    1: #else
    1:     return JS_FALSE;
    1: #endif
    1: }
    1: 
  583: static void
  583: script_trace(JSTracer *trc, JSObject *obj)
    1: {
    1:     JSScript *script;
    1: 
  583:     script = (JSScript *) JS_GetPrivate(trc->context, obj);
    1:     if (script)
  583:         js_TraceScript(trc, script);
    1: }
    1: 
    1: #if !JS_HAS_SCRIPT_OBJECT
    1: #define JSProto_Script  JSProto_Object
    1: #endif
    1: 
    1: JS_FRIEND_DATA(JSClass) js_ScriptClass = {
    1:     js_Script_str,
  583:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Script),
    1:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,
    1:     JS_EnumerateStub, JS_ResolveStub,   JS_ConvertStub,   script_finalize,
    1:     NULL,             NULL,             script_call,      NULL,/*XXXbe xdr*/
  583:     NULL,             NULL,             JS_CLASS_TRACE(script_trace), NULL
    1: };
    1: 
    1: #if JS_HAS_SCRIPT_OBJECT
    1: 
    1: static JSBool
    1: Script(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     /* If not constructing, replace obj with a new Script object. */
    1:     if (!(cx->fp->flags & JSFRAME_CONSTRUCTING)) {
    1:         obj = js_NewObject(cx, &js_ScriptClass, NULL, NULL);
    1:         if (!obj)
    1:             return JS_FALSE;
    1: 
    1:         /*
 4127:          * script_compile_sub does not use rval to root its temporaries so we
 4127:          * can use it to root obj.
    1:          */
    1:         *rval = OBJECT_TO_JSVAL(obj);
    1:     }
    1: 
    1:     if (!JS_SetReservedSlot(cx, obj, 0, INT_TO_JSVAL(0)))
    1:         return JS_FALSE;
    1: 
 4127:     return script_compile_sub(cx, obj, argc, argv, rval);
    1: }
    1: 
    1: #if JS_HAS_SCRIPT_OBJECT && JS_HAS_XDR_FREEZE_THAW
    1: 
    1: static JSBool
 4127: script_static_thaw(JSContext *cx, uintN argc, jsval *vp)
    1: {
 4127:     JSObject *obj;
 4127: 
    1:     obj = js_NewObject(cx, &js_ScriptClass, NULL, NULL);
    1:     if (!obj)
    1:         return JS_FALSE;
 4127:     vp[1] = OBJECT_TO_JSVAL(obj);
 4127:     if (!script_thaw(cx, vp))
    1:         return JS_FALSE;
 4127:     *vp = OBJECT_TO_JSVAL(obj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSFunctionSpec script_static_methods[] = {
 6917:     JS_FN(js_thaw_str,       script_static_thaw,     1,1,0),
 4127:     JS_FS_END
    1: };
    1: 
    1: #else  /* !JS_HAS_SCRIPT_OBJECT || !JS_HAS_XDR_FREEZE_THAW */
    1: 
    1: #define script_static_methods   NULL
    1: 
    1: #endif /* !JS_HAS_SCRIPT_OBJECT || !JS_HAS_XDR_FREEZE_THAW */
    1: 
    1: JSObject *
    1: js_InitScriptClass(JSContext *cx, JSObject *obj)
    1: {
    1:     return JS_InitClass(cx, obj, NULL, &js_ScriptClass, Script, 1,
    1:                         NULL, script_methods, NULL, script_static_methods);
    1: }
    1: 
    1: #endif /* JS_HAS_SCRIPT_OBJECT */
    1: 
    1: /*
    1:  * Shared script filename management.
    1:  */
    1: JS_STATIC_DLL_CALLBACK(int)
    1: js_compare_strings(const void *k1, const void *k2)
    1: {
 3164:     return strcmp((const char *) k1, (const char *) k2) == 0;
    1: }
    1: 
    1: /* NB: This struct overlays JSHashEntry -- see jshash.h, do not reorganize. */
    1: typedef struct ScriptFilenameEntry {
    1:     JSHashEntry         *next;          /* hash chain linkage */
    1:     JSHashNumber        keyHash;        /* key hash function result */
    1:     const void          *key;           /* ptr to filename, below */
    1:     uint32              flags;          /* user-defined filename prefix flags */
    1:     JSPackedBool        mark;           /* GC mark flag */
    1:     char                filename[3];    /* two or more bytes, NUL-terminated */
    1: } ScriptFilenameEntry;
    1: 
 4529: JS_STATIC_DLL_CALLBACK(void *)
 4529: js_alloc_table_space(void *priv, size_t size)
 4529: {
 4529:     return malloc(size);
 4529: }
 4529: 
 4529: JS_STATIC_DLL_CALLBACK(void)
 4529: js_free_table_space(void *priv, void *item)
 4529: {
 4529:     free(item);
 4529: }
 4529: 
    1: JS_STATIC_DLL_CALLBACK(JSHashEntry *)
    1: js_alloc_sftbl_entry(void *priv, const void *key)
    1: {
 3164:     size_t nbytes = offsetof(ScriptFilenameEntry, filename) +
 3164:                     strlen((const char *) key) + 1;
    1: 
    1:     return (JSHashEntry *) malloc(JS_MAX(nbytes, sizeof(JSHashEntry)));
    1: }
    1: 
    1: JS_STATIC_DLL_CALLBACK(void)
    1: js_free_sftbl_entry(void *priv, JSHashEntry *he, uintN flag)
    1: {
    1:     if (flag != HT_FREE_ENTRY)
    1:         return;
    1:     free(he);
    1: }
    1: 
    1: static JSHashAllocOps sftbl_alloc_ops = {
    1:     js_alloc_table_space,   js_free_table_space,
    1:     js_alloc_sftbl_entry,   js_free_sftbl_entry
    1: };
    1: 
    1: JSBool
    1: js_InitRuntimeScriptState(JSRuntime *rt)
    1: {
    1: #ifdef JS_THREADSAFE
    1:     JS_ASSERT(!rt->scriptFilenameTableLock);
    1:     rt->scriptFilenameTableLock = JS_NEW_LOCK();
    1:     if (!rt->scriptFilenameTableLock)
    1:         return JS_FALSE;
    1: #endif
    1:     JS_ASSERT(!rt->scriptFilenameTable);
    1:     rt->scriptFilenameTable =
    1:         JS_NewHashTable(16, JS_HashString, js_compare_strings, NULL,
    1:                         &sftbl_alloc_ops, NULL);
    1:     if (!rt->scriptFilenameTable) {
    1:         js_FinishRuntimeScriptState(rt);    /* free lock if threadsafe */
    1:         return JS_FALSE;
    1:     }
    1:     JS_INIT_CLIST(&rt->scriptFilenamePrefixes);
    1:     return JS_TRUE;
    1: }
    1: 
    1: typedef struct ScriptFilenamePrefix {
    1:     JSCList     links;      /* circular list linkage for easy deletion */
    1:     const char  *name;      /* pointer to pinned ScriptFilenameEntry string */
    1:     size_t      length;     /* prefix string length, precomputed */
    1:     uint32      flags;      /* user-defined flags to inherit from this prefix */
    1: } ScriptFilenamePrefix;
    1: 
    1: void
    1: js_FinishRuntimeScriptState(JSRuntime *rt)
    1: {
    1:     if (rt->scriptFilenameTable) {
    1:         JS_HashTableDestroy(rt->scriptFilenameTable);
    1:         rt->scriptFilenameTable = NULL;
    1:     }
    1: #ifdef JS_THREADSAFE
    1:     if (rt->scriptFilenameTableLock) {
    1:         JS_DESTROY_LOCK(rt->scriptFilenameTableLock);
    1:         rt->scriptFilenameTableLock = NULL;
    1:     }
    1: #endif
    1: }
    1: 
    1: void
    1: js_FreeRuntimeScriptState(JSRuntime *rt)
    1: {
    1:     ScriptFilenamePrefix *sfp;
    1: 
    1:     if (!rt->scriptFilenameTable)
    1:         return;
    1: 
    1:     while (!JS_CLIST_IS_EMPTY(&rt->scriptFilenamePrefixes)) {
    1:         sfp = (ScriptFilenamePrefix *) rt->scriptFilenamePrefixes.next;
    1:         JS_REMOVE_LINK(&sfp->links);
    1:         free(sfp);
    1:     }
    1:     js_FinishRuntimeScriptState(rt);
    1: }
    1: 
    1: #ifdef DEBUG_brendan
    1: #define DEBUG_SFTBL
    1: #endif
    1: #ifdef DEBUG_SFTBL
    1: size_t sftbl_savings = 0;
    1: #endif
    1: 
    1: static ScriptFilenameEntry *
    1: SaveScriptFilename(JSRuntime *rt, const char *filename, uint32 flags)
    1: {
    1:     JSHashTable *table;
    1:     JSHashNumber hash;
    1:     JSHashEntry **hep;
    1:     ScriptFilenameEntry *sfe;
    1:     size_t length;
    1:     JSCList *head, *link;
    1:     ScriptFilenamePrefix *sfp;
    1: 
    1:     table = rt->scriptFilenameTable;
    1:     hash = JS_HashString(filename);
    1:     hep = JS_HashTableRawLookup(table, hash, filename);
    1:     sfe = (ScriptFilenameEntry *) *hep;
    1: #ifdef DEBUG_SFTBL
    1:     if (sfe)
    1:         sftbl_savings += strlen(sfe->filename);
    1: #endif
    1: 
    1:     if (!sfe) {
    1:         sfe = (ScriptFilenameEntry *)
    1:               JS_HashTableRawAdd(table, hep, hash, filename, NULL);
    1:         if (!sfe)
    1:             return NULL;
    1:         sfe->key = strcpy(sfe->filename, filename);
    1:         sfe->flags = 0;
    1:         sfe->mark = JS_FALSE;
    1:     }
    1: 
    1:     /* If saving a prefix, add it to the set in rt->scriptFilenamePrefixes. */
    1:     if (flags != 0) {
    1:         /* Search in case filename was saved already; we must be idempotent. */
    1:         sfp = NULL;
    1:         length = strlen(filename);
    1:         for (head = link = &rt->scriptFilenamePrefixes;
    1:              link->next != head;
    1:              link = link->next) {
    1:             /* Lag link behind sfp to insert in non-increasing length order. */
    1:             sfp = (ScriptFilenamePrefix *) link->next;
    1:             if (!strcmp(sfp->name, filename))
    1:                 break;
    1:             if (sfp->length <= length) {
    1:                 sfp = NULL;
    1:                 break;
    1:             }
    1:             sfp = NULL;
    1:         }
    1: 
    1:         if (!sfp) {
    1:             /* No such prefix: add one now. */
    1:             sfp = (ScriptFilenamePrefix *) malloc(sizeof(ScriptFilenamePrefix));
    1:             if (!sfp)
    1:                 return NULL;
    1:             JS_INSERT_AFTER(&sfp->links, link);
    1:             sfp->name = sfe->filename;
    1:             sfp->length = length;
    1:             sfp->flags = 0;
    1:         }
    1: 
    1:         /*
    1:          * Accumulate flags in both sfe and sfp: sfe for later access from the
    1:          * JS_GetScriptedCallerFilenameFlags debug-API, and sfp so that longer
    1:          * filename entries can inherit by prefix.
    1:          */
    1:         sfe->flags |= flags;
    1:         sfp->flags |= flags;
    1:     }
    1: 
    1:     return sfe;
    1: }
    1: 
    1: const char *
    1: js_SaveScriptFilename(JSContext *cx, const char *filename)
    1: {
    1:     JSRuntime *rt;
    1:     ScriptFilenameEntry *sfe;
    1:     JSCList *head, *link;
    1:     ScriptFilenamePrefix *sfp;
    1: 
    1:     rt = cx->runtime;
    1:     JS_ACQUIRE_LOCK(rt->scriptFilenameTableLock);
    1:     sfe = SaveScriptFilename(rt, filename, 0);
    1:     if (!sfe) {
    1:         JS_RELEASE_LOCK(rt->scriptFilenameTableLock);
    1:         JS_ReportOutOfMemory(cx);
    1:         return NULL;
    1:     }
    1: 
    1:     /*
    1:      * Try to inherit flags by prefix.  We assume there won't be more than a
    1:      * few (dozen! ;-) prefixes, so linear search is tolerable.
    1:      * XXXbe every time I've assumed that in the JS engine, I've been wrong!
    1:      */
    1:     for (head = &rt->scriptFilenamePrefixes, link = head->next;
    1:          link != head;
    1:          link = link->next) {
    1:         sfp = (ScriptFilenamePrefix *) link;
    1:         if (!strncmp(sfp->name, filename, sfp->length)) {
    1:             sfe->flags |= sfp->flags;
    1:             break;
    1:         }
    1:     }
    1:     JS_RELEASE_LOCK(rt->scriptFilenameTableLock);
    1:     return sfe->filename;
    1: }
    1: 
    1: const char *
    1: js_SaveScriptFilenameRT(JSRuntime *rt, const char *filename, uint32 flags)
    1: {
    1:     ScriptFilenameEntry *sfe;
    1: 
    1:     /* This may be called very early, via the jsdbgapi.h entry point. */
    1:     if (!rt->scriptFilenameTable && !js_InitRuntimeScriptState(rt))
    1:         return NULL;
    1: 
    1:     JS_ACQUIRE_LOCK(rt->scriptFilenameTableLock);
    1:     sfe = SaveScriptFilename(rt, filename, flags);
    1:     JS_RELEASE_LOCK(rt->scriptFilenameTableLock);
    1:     if (!sfe)
    1:         return NULL;
    1: 
    1:     return sfe->filename;
    1: }
    1: 
    1: /*
    1:  * Back up from a saved filename by its offset within its hash table entry.
    1:  */
    1: #define FILENAME_TO_SFE(fn) \
    1:     ((ScriptFilenameEntry *) ((fn) - offsetof(ScriptFilenameEntry, filename)))
    1: 
    1: /*
    1:  * The sfe->key member, redundant given sfe->filename but required by the old
    1:  * jshash.c code, here gives us a useful sanity check.  This assertion will
    1:  * very likely botch if someone tries to mark a string that wasn't allocated
    1:  * as an sfe->filename.
    1:  */
    1: #define ASSERT_VALID_SFE(sfe)   JS_ASSERT((sfe)->key == (sfe)->filename)
    1: 
    1: uint32
    1: js_GetScriptFilenameFlags(const char *filename)
    1: {
    1:     ScriptFilenameEntry *sfe;
    1: 
    1:     sfe = FILENAME_TO_SFE(filename);
    1:     ASSERT_VALID_SFE(sfe);
    1:     return sfe->flags;
    1: }
    1: 
    1: void
    1: js_MarkScriptFilename(const char *filename)
    1: {
    1:     ScriptFilenameEntry *sfe;
    1: 
    1:     sfe = FILENAME_TO_SFE(filename);
    1:     ASSERT_VALID_SFE(sfe);
    1:     sfe->mark = JS_TRUE;
    1: }
    1: 
    1: JS_STATIC_DLL_CALLBACK(intN)
    1: js_script_filename_marker(JSHashEntry *he, intN i, void *arg)
    1: {
    1:     ScriptFilenameEntry *sfe = (ScriptFilenameEntry *) he;
    1: 
    1:     sfe->mark = JS_TRUE;
    1:     return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: void
    1: js_MarkScriptFilenames(JSRuntime *rt, JSBool keepAtoms)
    1: {
    1:     JSCList *head, *link;
    1:     ScriptFilenamePrefix *sfp;
    1: 
    1:     if (!rt->scriptFilenameTable)
    1:         return;
    1: 
    1:     if (keepAtoms) {
    1:         JS_HashTableEnumerateEntries(rt->scriptFilenameTable,
    1:                                      js_script_filename_marker,
    1:                                      rt);
    1:     }
    1:     for (head = &rt->scriptFilenamePrefixes, link = head->next;
    1:          link != head;
    1:          link = link->next) {
    1:         sfp = (ScriptFilenamePrefix *) link;
    1:         js_MarkScriptFilename(sfp->name);
    1:     }
    1: }
    1: 
    1: JS_STATIC_DLL_CALLBACK(intN)
    1: js_script_filename_sweeper(JSHashEntry *he, intN i, void *arg)
    1: {
    1:     ScriptFilenameEntry *sfe = (ScriptFilenameEntry *) he;
    1: 
    1:     if (!sfe->mark)
    1:         return HT_ENUMERATE_REMOVE;
    1:     sfe->mark = JS_FALSE;
    1:     return HT_ENUMERATE_NEXT;
    1: }
    1: 
    1: void
    1: js_SweepScriptFilenames(JSRuntime *rt)
    1: {
    1:     if (!rt->scriptFilenameTable)
    1:         return;
    1: 
    1:     JS_HashTableEnumerateEntries(rt->scriptFilenameTable,
    1:                                  js_script_filename_sweeper,
    1:                                  rt);
    1: #ifdef DEBUG_notme
    1: #ifdef DEBUG_SFTBL
    1:     printf("script filename table savings so far: %u\n", sftbl_savings);
    1: #endif
    1: #endif
    1: }
    1: 
 3235: /*
 3235:  * JSScript data structures memory alignment:
 3235:  *
 3235:  * JSScript
 3235:  * JSObjectArray    script objects' descriptor if JSScript.objectsOffset != 0,
 3235:  *                    use JS_SCRIPT_OBJECTS(script) macro to access it.
 3235:  * JSObjectArray    script regexps' descriptor if JSScript.regexpsOffset != 0,
 3235:  *                    use JS_SCRIPT_REGEXPS(script) macro to access it.
 3235:  * JSTryNoteArray   script try notes' descriptor if JSScript.tryNotesOffset
 3235:  *                    != 0, use JS_SCRIPT_TRYNOTES(script) macro to access it.
 3235:  * JSAtom *a[]      array of JSScript.atomMap.length atoms pointed by
 3235:  *                    JSScript.atomMap.vector if any.
 3235:  * JSObject *o[]    array of JS_SCRIPT_OBJECTS(script)->length objects if any
 3235:  *                    pointed by JS_SCRIPT_OBJECTS(script)->vector.
 3235:  * JSObject *r[]    array of JS_SCRIPT_REGEXPS(script)->length regexps if any
 3235:  *                    pointed by JS_SCRIPT_REGEXPS(script)->vector.
 3235:  * JSTryNote t[]    array of JS_SCRIPT_TRYNOTES(script)->length try notes if any
 3235:  *                    pointed by JS_SCRIPT_TRYNOTES(script)->vector.
 3235:  * jsbytecode b[]   script bytecode pointed by JSScript.code.
 3235:  * jssrcnote  s[]   script source notes, use SCRIPT_NOTES(script) to access it
 3235:  *
 3235:  * The alignment avoids gaps between entries as alignment requirement for each
 3235:  * subsequent structure or array is the same or divides the alignment
 3235:  * requirement for the previous one.
 3235:  *
 3235:  * The followings asserts checks that assuming that the alignment requirement
 3235:  * for JSObjectArray and JSTryNoteArray are sizeof(void *) and for JSTryNote
 3235:  * it is sizeof(uint32) as the structure consists of 3 uint32 fields.
 3235:  */
 3235: JS_STATIC_ASSERT(sizeof(JSScript) % sizeof(void *) == 0);
 3235: JS_STATIC_ASSERT(sizeof(JSObjectArray) % sizeof(void *) == 0);
 3235: JS_STATIC_ASSERT(sizeof(JSTryNoteArray) == sizeof(JSObjectArray));
 3235: JS_STATIC_ASSERT(sizeof(JSAtom *) == sizeof(JSObject *));
 3235: JS_STATIC_ASSERT(sizeof(JSObject *) % sizeof(uint32) == 0);
 3235: JS_STATIC_ASSERT(sizeof(JSTryNote) == 3 * sizeof(uint32));
 3235: JS_STATIC_ASSERT(sizeof(uint32) % sizeof(jsbytecode) == 0);
 3235: JS_STATIC_ASSERT(sizeof(jsbytecode) % sizeof(jssrcnote) == 0);
 3235: 
 3235: /*
 3235:  * Check that uint8 offset for object, regexp and try note arrays is sufficient.
 3235:  */
 3235: JS_STATIC_ASSERT(sizeof(JSScript) + 2 * sizeof(JSObjectArray) < JS_BIT(8));
 3235: 
    1: JSScript *
 3235: js_NewScript(JSContext *cx, uint32 length, uint32 nsrcnotes, uint32 natoms,
 3235:              uint32 nobjects, uint32 nregexps, uint32 ntrynotes)
    1: {
 3235:     size_t size, vectorSize;
    1:     JSScript *script;
 3235:     uint8 *cursor;
    1: 
 3235:     size = sizeof(JSScript) +
 3235:            sizeof(JSAtom *) * natoms +
 3235:            length * sizeof(jsbytecode) +
 3235:            nsrcnotes * sizeof(jssrcnote);
 3235:     if (nobjects != 0)
 3235:         size += sizeof(JSObjectArray) + nobjects * sizeof(JSObject *);
 3235:     if (nregexps != 0)
 3235:         size += sizeof(JSObjectArray) + nregexps * sizeof(JSObject *);
 3235:     if (ntrynotes != 0)
 3235:         size += sizeof(JSTryNoteArray) + ntrynotes * sizeof(JSTryNote);
 3235: 
 3235:     script = (JSScript *) JS_malloc(cx, size);
    1:     if (!script)
    1:         return NULL;
    1:     memset(script, 0, sizeof(JSScript));
    1:     script->length = length;
    1:     script->version = cx->version;
 3235: 
 3235:     cursor = (uint8 *)script + sizeof(JSScript);
 3235:     if (nobjects != 0) {
 3235:         script->objectsOffset = (uint8)(cursor - (uint8 *)script);
 3235:         cursor += sizeof(JSObjectArray);
 3235:     }
 3235:     if (nregexps != 0) {
 3235:         script->regexpsOffset = (uint8)(cursor - (uint8 *)script);
 3235:         cursor += sizeof(JSObjectArray);
 3235:     }
 3235:     if (ntrynotes != 0) {
 3235:         script->trynotesOffset = (uint8)(cursor - (uint8 *)script);
 3235:         cursor += sizeof(JSTryNoteArray);
 3235:     }
 3235: 
 3235:     if (natoms != 0) {
 3235:         script->atomMap.length = natoms;
 3235:         script->atomMap.vector = (JSAtom **)cursor;
 3235:         vectorSize = natoms * sizeof(script->atomMap.vector[0]);
 3235: 
 3235:         /*
 3235:          * Clear object map's vector so the GC tracing can run when not yet
 3235:          * all atoms are copied to the array.
 3235:          */
 3235:         memset(cursor, 0, vectorSize);
 3235:         cursor += vectorSize;
 3235:     }
 3235:     if (nobjects != 0) {
 3235:         JS_SCRIPT_OBJECTS(script)->length = nobjects;
 3235:         JS_SCRIPT_OBJECTS(script)->vector = (JSObject **)cursor;
 3235:         vectorSize = nobjects * sizeof(JS_SCRIPT_OBJECTS(script)->vector[0]);
 3235:         memset(cursor, 0, vectorSize);
 3235:         cursor += vectorSize;
 3235:     }
 3235:     if (nregexps != 0) {
 3235:         JS_SCRIPT_REGEXPS(script)->length = nregexps;
 3235:         JS_SCRIPT_REGEXPS(script)->vector = (JSObject **)cursor;
 3235:         vectorSize = nregexps * sizeof(JS_SCRIPT_REGEXPS(script)->vector[0]);
 3235:         memset(cursor, 0, vectorSize);
 3235:         cursor += vectorSize;
 3235:     }
 3235:     if (ntrynotes != 0) {
 3235:         JS_SCRIPT_TRYNOTES(script)->length = ntrynotes;
 3235:         JS_SCRIPT_TRYNOTES(script)->vector = (JSTryNote *)cursor;
 3235:         vectorSize = ntrynotes * sizeof(JS_SCRIPT_TRYNOTES(script)->vector[0]);
 3235: #ifdef DEBUG
 3235:         memset(cursor, 0, vectorSize);
 3235: #endif
 3235:         cursor += vectorSize;
 3235:     }
 3235: 
 3235:     script->code = script->main = (jsbytecode *)cursor;
 3235:     JS_ASSERT(cursor +
 3235:               length * sizeof(jsbytecode) +
 3235:               nsrcnotes * sizeof(jssrcnote) ==
 3235:               (uint8 *)script + size);
 3235: 
11377: #ifdef CHECK_SCRIPT_OWNER
11377:     script->owner = cx->thread;
11377: #endif
    1:     return script;
    1: }
    1: 
 8444: JSScript *
 8444: js_NewScriptFromCG(JSContext *cx, JSCodeGenerator *cg)
    1: {
 3025:     uint32 mainLength, prologLength, nsrcnotes;
    1:     JSScript *script;
    1:     const char *filename;
13702:     JSFunction *fun;
    1: 
 3235:     /* The counts of indexed things must be checked during code generation. */
 3235:     JS_ASSERT(cg->atomList.count <= INDEX_LIMIT);
 3235:     JS_ASSERT(cg->objectList.length <= INDEX_LIMIT);
 3235:     JS_ASSERT(cg->regexpList.length <= INDEX_LIMIT);
 3235: 
    1:     mainLength = CG_OFFSET(cg);
    1:     prologLength = CG_PROLOG_OFFSET(cg);
    1:     CG_COUNT_FINAL_SRCNOTES(cg, nsrcnotes);
 3025:     script = js_NewScript(cx, prologLength + mainLength, nsrcnotes,
 3235:                           cg->atomList.count, cg->objectList.length,
 3235:                           cg->regexpList.length, cg->ntrynotes);
    1:     if (!script)
    1:         return NULL;
    1: 
    1:     /* Now that we have script, error control flow must go to label bad. */
    1:     script->main += prologLength;
    1:     memcpy(script->code, CG_PROLOG_BASE(cg), prologLength * sizeof(jsbytecode));
    1:     memcpy(script->main, CG_BASE(cg), mainLength * sizeof(jsbytecode));
 3235:     script->ngvars = cg->treeContext.ngvars;
 3235: 
 3235:     js_InitAtomMap(cx, &script->atomMap, &cg->atomList);
    1: 
 6561:     filename = cg->treeContext.parseContext->tokenStream.filename;
    1:     if (filename) {
    1:         script->filename = js_SaveScriptFilename(cx, filename);
    1:         if (!script->filename)
    1:             goto bad;
    1:     }
    1:     script->lineno = cg->firstLine;
    1:     script->depth = cg->maxStackDepth;
 6561:     script->principals = cg->treeContext.parseContext->principals;
 6561:     if (script->principals)
    1:         JSPRINCIPALS_HOLD(cx, script->principals);
    1: 
    1:     if (!js_FinishTakingSrcNotes(cx, cg, SCRIPT_NOTES(script)))
    1:         goto bad;
 3235:     if (cg->ntrynotes != 0)
 3235:         js_FinishTakingTryNotes(cg, JS_SCRIPT_TRYNOTES(script));
 3235:     if (cg->objectList.length != 0)
 3235:         FinishParsedObjects(&cg->objectList, JS_SCRIPT_OBJECTS(script));
 3235:     if (cg->regexpList.length != 0)
 3235:         FinishParsedObjects(&cg->regexpList, JS_SCRIPT_REGEXPS(script));
    1: 
    1:     /*
    1:      * We initialize fun->u.script to be the script constructed above
    1:      * so that the debugger has a valid FUN_SCRIPT(fun).
    1:      */
13691:     fun = NULL;
 8444:     if (cg->treeContext.flags & TCF_IN_FUNCTION) {
13691:         fun = cg->treeContext.fun;
    1:         JS_ASSERT(FUN_INTERPRETED(fun) && !FUN_SCRIPT(fun));
13691:         js_FreezeLocalNames(cx, fun);
    1:         fun->u.i.script = script;
11377: #ifdef CHECK_SCRIPT_OWNER
11377:         script->owner = NULL;
11377: #endif
    1:         if (cg->treeContext.flags & TCF_FUN_HEAVYWEIGHT)
    1:             fun->flags |= JSFUN_HEAVYWEIGHT;
13691:         if (fun->flags & JSFUN_HEAVYWEIGHT)
10217:             ++cg->treeContext.maxScopeDepth;
    1:     }
    1: 
10217: #ifdef JS_SCOPE_DEPTH_METER
10217:     JS_BASIC_STATS_ACCUM(&cx->runtime->lexicalScopeDepthStats,
10217:                          cg->treeContext.maxScopeDepth);
10217: #endif
10217: 
    1:     /* Tell the debugger about this compiled script. */
    1:     js_CallNewScriptHook(cx, script, fun);
    1:     return script;
    1: 
    1: bad:
    1:     js_DestroyScript(cx, script);
    1:     return NULL;
    1: }
    1: 
    1: JS_FRIEND_API(void)
    1: js_CallNewScriptHook(JSContext *cx, JSScript *script, JSFunction *fun)
    1: {
    1:     JSNewScriptHook hook;
    1: 
 2433:     hook = cx->debugHooks->newScriptHook;
    1:     if (hook) {
 2433:         JS_KEEP_ATOMS(cx->runtime);
    1:         hook(cx, script->filename, script->lineno, script, fun,
 2433:              cx->debugHooks->newScriptHookData);
 2433:         JS_UNKEEP_ATOMS(cx->runtime);
    1:     }
    1: }
    1: 
    1: JS_FRIEND_API(void)
    1: js_CallDestroyScriptHook(JSContext *cx, JSScript *script)
    1: {
    1:     JSDestroyScriptHook hook;
    1: 
 2433:     hook = cx->debugHooks->destroyScriptHook;
    1:     if (hook)
 2433:         hook(cx, script, cx->debugHooks->destroyScriptHookData);
    1: }
    1: 
    1: void
    1: js_DestroyScript(JSContext *cx, JSScript *script)
    1: {
    1:     js_CallDestroyScriptHook(cx, script);
11377:     JS_ClearScriptTraps(cx, script);
    1: 
    1:     if (script->principals)
    1:         JSPRINCIPALS_DROP(cx, script->principals);
11377: 
15530:     if (JS_GSN_CACHE(cx).code == script->code)
    1:         JS_CLEAR_GSN_CACHE(cx);
11377: 
11377:     /*
11377:      * The GC flushes all property caches, so no need to purge just the
11377:      * entries for this script.
11377:      *
11377:      * JS_THREADSAFE note: js_FlushPropertyCacheForScript flushes only the
11377:      * current thread's property cache, so a script not owned by a function
11377:      * or object, which hands off lifetime management for that script to the
11377:      * GC, must be used by only one thread over its lifetime.
11377:      *
11377:      * This should be an API-compatible change, since a script is never safe
11377:      * against premature GC if shared among threads without a rooted object
11377:      * wrapping it to protect the script's mapped atoms against GC. We use
11377:      * script->owner to enforce this requirement via assertions.
11377:      */
11377: #ifdef CHECK_SCRIPT_OWNER
11377:     JS_ASSERT_IF(cx->runtime->gcRunning, !script->owner);
11377: #endif
11377: 
11377:     if (!cx->runtime->gcRunning &&
11377:         !(cx->fp && (cx->fp->flags & JSFRAME_EVAL))) {
11377: #ifdef CHECK_SCRIPT_OWNER
11377:         JS_ASSERT(script->owner == cx->thread);
11377: #endif
11377:         js_FlushPropertyCacheForScript(cx, script);
11377:     }
11377: 
    1:     JS_free(cx, script);
    1: }
    1: 
    1: void
  583: js_TraceScript(JSTracer *trc, JSScript *script)
    1: {
    1:     JSAtomMap *map;
    1:     uintN i, length;
    1:     JSAtom **vector;
 4529:     jsval v;
 3235:     JSObjectArray *objarray;
    1: 
    1:     map = &script->atomMap;
    1:     length = map->length;
    1:     vector = map->vector;
 3235:     for (i = 0; i < length; i++) {
 4529:         v = ATOM_KEY(vector[i]);
 4529:         if (JSVAL_IS_TRACEABLE(v)) {
 3235:             JS_SET_TRACING_INDEX(trc, "atomMap", i);
 4529:             JS_CallTracer(trc, JSVAL_TO_TRACEABLE(v), JSVAL_TRACE_KIND(v));
 4529:         }
 3235:     }
 3235: 
 3235:     if (script->objectsOffset != 0) {
 3235:         objarray = JS_SCRIPT_OBJECTS(script);
 3235:         i = objarray->length;
 3235:         do {
 3235:             --i;
11089:             if (objarray->vector[i]) {
 3235:                 JS_SET_TRACING_INDEX(trc, "objects", i);
 3235:                 JS_CallTracer(trc, objarray->vector[i], JSTRACE_OBJECT);
11089:             }
 3235:         } while (i != 0);
 3235:     }
 3235: 
 3235:     if (script->regexpsOffset != 0) {
 3235:         objarray = JS_SCRIPT_REGEXPS(script);
 3235:         i = objarray->length;
 3235:         do {
 3235:             --i;
11089:             if (objarray->vector[i]) {
 3235:                 JS_SET_TRACING_INDEX(trc, "regexps", i);
 3235:                 JS_CallTracer(trc, objarray->vector[i], JSTRACE_OBJECT);
11089:             }
 3235:         } while (i != 0);
 3235:     }
    1: 
15336:     if (script->object) {
15336:         JS_SET_TRACING_NAME(trc, "object");
15336:         JS_CallTracer(trc, script->object, JSTRACE_OBJECT);
15336:     }
15336: 
  583:     if (IS_GC_MARKING_TRACER(trc) && script->filename)
    1:         js_MarkScriptFilename(script->filename);
    1: }
    1: 
    1: typedef struct GSNCacheEntry {
    1:     JSDHashEntryHdr     hdr;
    1:     jsbytecode          *pc;
    1:     jssrcnote           *sn;
    1: } GSNCacheEntry;
    1: 
    1: #define GSN_CACHE_THRESHOLD     100
    1: 
    1: jssrcnote *
    1: js_GetSrcNoteCached(JSContext *cx, JSScript *script, jsbytecode *pc)
    1: {
    1:     ptrdiff_t target, offset;
    1:     GSNCacheEntry *entry;
    1:     jssrcnote *sn, *result;
    1:     uintN nsrcnotes;
    1: 
    1: 
    1:     target = PTRDIFF(pc, script->code, jsbytecode);
    1:     if ((uint32)target >= script->length)
    1:         return NULL;
    1: 
15530:     if (JS_GSN_CACHE(cx).code == script->code) {
    1:         JS_METER_GSN_CACHE(cx, hits);
    1:         entry = (GSNCacheEntry *)
    1:                 JS_DHashTableOperate(&JS_GSN_CACHE(cx).table, pc,
    1:                                      JS_DHASH_LOOKUP);
    1:         return entry->sn;
    1:     }
    1: 
    1:     JS_METER_GSN_CACHE(cx, misses);
    1:     offset = 0;
    1:     for (sn = SCRIPT_NOTES(script); ; sn = SN_NEXT(sn)) {
    1:         if (SN_IS_TERMINATOR(sn)) {
    1:             result = NULL;
    1:             break;
    1:         }
    1:         offset += SN_DELTA(sn);
    1:         if (offset == target && SN_IS_GETTABLE(sn)) {
    1:             result = sn;
    1:             break;
    1:         }
    1:     }
    1: 
15530:     if (JS_GSN_CACHE(cx).code != script->code &&
    1:         script->length >= GSN_CACHE_THRESHOLD) {
    1:         JS_CLEAR_GSN_CACHE(cx);
    1:         nsrcnotes = 0;
    1:         for (sn = SCRIPT_NOTES(script); !SN_IS_TERMINATOR(sn);
    1:              sn = SN_NEXT(sn)) {
    1:             if (SN_IS_GETTABLE(sn))
    1:                 ++nsrcnotes;
    1:         }
    1:         if (!JS_DHashTableInit(&JS_GSN_CACHE(cx).table, JS_DHashGetStubOps(),
    1:                                NULL, sizeof(GSNCacheEntry),
    1:                                JS_DHASH_DEFAULT_CAPACITY(nsrcnotes))) {
    1:             JS_GSN_CACHE(cx).table.ops = NULL;
    1:         } else {
    1:             pc = script->code;
    1:             for (sn = SCRIPT_NOTES(script); !SN_IS_TERMINATOR(sn);
    1:                  sn = SN_NEXT(sn)) {
    1:                 pc += SN_DELTA(sn);
    1:                 if (SN_IS_GETTABLE(sn)) {
    1:                     entry = (GSNCacheEntry *)
    1:                             JS_DHashTableOperate(&JS_GSN_CACHE(cx).table, pc,
    1:                                                  JS_DHASH_ADD);
    1:                     entry->pc = pc;
    1:                     entry->sn = sn;
    1:                 }
    1:             }
15530:             JS_GSN_CACHE(cx).code = script->code;
    1:             JS_METER_GSN_CACHE(cx, fills);
    1:         }
    1:     }
    1: 
    1:     return result;
    1: }
    1: 
    1: uintN
    1: js_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc)
    1: {
    1:     JSFunction *fun;
    1:     uintN lineno;
    1:     ptrdiff_t offset, target;
    1:     jssrcnote *sn;
    1:     JSSrcNoteType type;
    1: 
    1:     /* Cope with JSStackFrame.pc value prior to entering js_Interpret. */
    1:     if (!pc)
    1:         return 0;
    1: 
    1:     /*
    1:      * Special case: function definition needs no line number note because
    1:      * the function's script contains its starting line number.
    1:      */
 3235:     if (js_CodeSpec[*pc].format & JOF_INDEXBASE)
    1:         pc += js_CodeSpec[*pc].length;
    1:     if (*pc == JSOP_DEFFUN) {
13824:         GET_FUNCTION_FROM_BYTECODE(script, pc, 0, fun);
    1:         return fun->u.i.script->lineno;
    1:     }
    1: 
    1:     /*
    1:      * General case: walk through source notes accumulating their deltas,
    1:      * keeping track of line-number notes, until we pass the note for pc's
    1:      * offset within script->code.
    1:      */
    1:     lineno = script->lineno;
    1:     offset = 0;
    1:     target = PTRDIFF(pc, script->code, jsbytecode);
    1:     for (sn = SCRIPT_NOTES(script); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
    1:         offset += SN_DELTA(sn);
    1:         type = (JSSrcNoteType) SN_TYPE(sn);
    1:         if (type == SRC_SETLINE) {
    1:             if (offset <= target)
    1:                 lineno = (uintN) js_GetSrcNoteOffset(sn, 0);
    1:         } else if (type == SRC_NEWLINE) {
    1:             if (offset <= target)
    1:                 lineno++;
    1:         }
    1:         if (offset > target)
    1:             break;
    1:     }
    1:     return lineno;
    1: }
    1: 
    1: /* The line number limit is the same as the jssrcnote offset limit. */
    1: #define SN_LINE_LIMIT   (SN_3BYTE_OFFSET_FLAG << 16)
    1: 
    1: jsbytecode *
    1: js_LineNumberToPC(JSScript *script, uintN target)
    1: {
    1:     ptrdiff_t offset, best;
    1:     uintN lineno, bestdiff, diff;
    1:     jssrcnote *sn;
    1:     JSSrcNoteType type;
    1: 
    1:     offset = 0;
    1:     best = -1;
    1:     lineno = script->lineno;
    1:     bestdiff = SN_LINE_LIMIT;
    1:     for (sn = SCRIPT_NOTES(script); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
  267:         /*
  267:          * Exact-match only if offset is not in the prolog; otherwise use
  267:          * nearest greater-or-equal line number match.
  267:          */
  267:         if (lineno == target && script->code + offset >= script->main)
    1:             goto out;
  267:         if (lineno >= target) {
    1:             diff = lineno - target;
    1:             if (diff < bestdiff) {
    1:                 bestdiff = diff;
    1:                 best = offset;
    1:             }
    1:         }
    1:         offset += SN_DELTA(sn);
    1:         type = (JSSrcNoteType) SN_TYPE(sn);
    1:         if (type == SRC_SETLINE) {
    1:             lineno = (uintN) js_GetSrcNoteOffset(sn, 0);
    1:         } else if (type == SRC_NEWLINE) {
    1:             lineno++;
    1:         }
    1:     }
    1:     if (best >= 0)
    1:         offset = best;
    1: out:
    1:     return script->code + offset;
    1: }
    1: 
    1: JS_FRIEND_API(uintN)
    1: js_GetScriptLineExtent(JSScript *script)
    1: {
    1:     uintN lineno;
    1:     jssrcnote *sn;
    1:     JSSrcNoteType type;
    1: 
    1:     lineno = script->lineno;
    1:     for (sn = SCRIPT_NOTES(script); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
    1:         type = (JSSrcNoteType) SN_TYPE(sn);
    1:         if (type == SRC_SETLINE) {
    1:             lineno = (uintN) js_GetSrcNoteOffset(sn, 0);
    1:         } else if (type == SRC_NEWLINE) {
    1:             lineno++;
    1:         }
    1:     }
    1:     return 1 + lineno - script->lineno;
    1: }
    1: 
    1: #if JS_HAS_GENERATORS
    1: 
 1825: JSBool
 1825: js_IsInsideTryWithFinally(JSScript *script, jsbytecode *pc)
    1: {
 3235:     JSTryNoteArray *tarray;
 1825:     JSTryNote *tn, *tnlimit;
 1825:     uint32 off;
    1: 
 1825:     JS_ASSERT(script->code <= pc);
 1825:     JS_ASSERT(pc < script->code + script->length);
    1: 
 3235:     if (!script->trynotesOffset != 0)
 1825:         return JS_FALSE;
 3235:     tarray = JS_SCRIPT_TRYNOTES(script);
 3235:     JS_ASSERT(tarray->length != 0);
    1: 
 3235:     tn = tarray->vector;
 3235:     tnlimit = tn + tarray->length;
 1825:     off = (uint32)(pc - script->main);
    1:     do {
 1825:         if (off - tn->start < tn->length) {
 1825:             if (tn->kind == JSTN_FINALLY)
 1825:                 return JS_TRUE;
 1825:             JS_ASSERT(tn->kind == JSTN_CATCH);
    1:         }
 1825:     } while (++tn != tnlimit);
 1825:     return JS_FALSE;
    1: }
    1: 
    1: #endif
