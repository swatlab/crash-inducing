15751: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
15751: /* vim:set ts=2 sw=2 sts=2 et cindent: */
15751: /* ***** BEGIN LICENSE BLOCK *****
39436:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
15751:  *
15751:  * The contents of this file are subject to the Mozilla Public License Version
15751:  * 1.1 (the "License"); you may not use this file except in compliance with
15751:  * the License. You may obtain a copy of the License at
15751:  * http://www.mozilla.org/MPL/
15751:  *
15751:  * Software distributed under the License is distributed on an "AS IS" basis,
15751:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
15751:  * for the specific language governing rights and limitations under the
15751:  * License.
15751:  *
15751:  * The Original Code is Mozilla code.
15751:  *
15751:  * The Initial Developer of the Original Code is the Mozilla Corporation.
15751:  * Portions created by the Initial Developer are Copyright (C) 2007
15751:  * the Initial Developer. All Rights Reserved.
15751:  *
15751:  * Contributor(s):
15751:  *  Chris Double <chris.double@double.co.nz>
15751:  *
15751:  * Alternatively, the contents of this file may be used under the terms of
15751:  * either the GNU General Public License Version 2 or later (the "GPL"), or
15751:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
15751:  * in which case the provisions of the GPL or the LGPL are applicable instead
15751:  * of those above. If you wish to allow use of your version of this file only
15751:  * under the terms of either the GPL or the LGPL, and not to allow others to
15751:  * use your version of this file under the terms of the MPL, indicate your
15751:  * decision by deleting the provisions above and replace them with the notice
15751:  * and other provisions required by the GPL or the LGPL. If you do not delete
15751:  * the provisions above, a recipient may use your version of this file under
15751:  * the terms of any one of the MPL, the GPL or the LGPL.
15751:  *
15751:  * ***** END LICENSE BLOCK ***** */
33372: 
80467: #include "mozilla/Util.h"
80467: 
15751: #include "nsIDOMHTMLMediaElement.h"
15751: #include "nsIDOMHTMLSourceElement.h"
15751: #include "nsHTMLMediaElement.h"
74740: #include "nsTimeRanges.h"
15751: #include "nsGenericHTMLElement.h"
15751: #include "nsPresContext.h"
15751: #include "nsIPresShell.h"
15751: #include "nsGkAtoms.h"
15751: #include "nsSize.h"
15751: #include "nsIFrame.h"
15751: #include "nsIDocument.h"
15751: #include "nsIDOMDocument.h"
15751: #include "nsDOMError.h"
15751: #include "nsNodeInfoManager.h"
15751: #include "nsNetUtil.h"
15751: #include "nsXPCOMStrings.h"
15751: #include "nsThreadUtils.h"
51938: #include "nsIThreadInternal.h"
22874: #include "nsContentUtils.h"
39499: #include "nsFrameManager.h"
15751: #include "nsIScriptSecurityManager.h"
15751: #include "nsIXPConnect.h"
15751: #include "jsapi.h"
15751: 
15751: #include "nsITimer.h"
15751: 
15751: #include "nsEventDispatcher.h"
51394: #include "nsMediaError.h"
21079: #include "nsICategoryManager.h"
41763: #include "nsCharSeparatedTokenizer.h"
32900: #include "nsMediaStream.h"
15751: 
39499: #include "nsIDOMHTMLVideoElement.h"
24155: #include "nsIContentPolicy.h"
24155: #include "nsContentPolicyUtils.h"
24155: #include "nsContentErrors.h"
24155: #include "nsCrossSiteListenerProxy.h"
25849: #include "nsCycleCollectionParticipant.h"
39559: #include "nsICachingChannel.h"
35581: #include "nsLayoutUtils.h"
35581: #include "nsVideoFrame.h"
39499: #include "BasicLayers.h"
40132: #include <limits>
41179: #include "nsIDocShellTreeItem.h"
48889: #include "nsIAsyncVerifyRedirectCallback.h"
51938: #include "nsIAppShell.h"
51938: #include "nsWidgetsCID.h"
24155: 
51477: #include "nsIPrivateDOMEvent.h"
51477: #include "nsIDOMNotifyAudioAvailableEvent.h"
77175: #include "nsMediaFragmentURIParser.h"
82746: #include "nsURIHashKey.h"
86044: #include "nsContentUtils.h"
86044: #include "nsIScriptError.h"
51477: 
16300: #ifdef MOZ_OGG
16300: #include "nsOggDecoder.h"
16300: #endif
21394: #ifdef MOZ_WAVE
21394: #include "nsWaveDecoder.h"
21394: #endif
43339: #ifdef MOZ_WEBM
43339: #include "nsWebMDecoder.h"
43339: #endif
48220: #ifdef MOZ_RAW
48220: #include "nsRawDecoder.h"
48220: #endif
16300: 
33372: #ifdef PR_LOGGING
33372: static PRLogModuleInfo* gMediaElementLog;
33372: static PRLogModuleInfo* gMediaElementEventsLog;
33372: #define LOG(type, msg) PR_LOG(gMediaElementLog, type, msg)
33372: #define LOG_EVENT(type, msg) PR_LOG(gMediaElementEventsLog, type, msg)
33372: #else
33372: #define LOG(type, msg)
33372: #define LOG_EVENT(type, msg)
33372: #endif
25269: 
41207: #include "nsIContentSecurityPolicy.h"
41207: #include "nsIChannelPolicy.h"
41207: #include "nsChannelPolicy.h"
41207: 
70840: #include "mozilla/Preferences.h"
70840: 
70840: using namespace mozilla;
56805: using namespace mozilla::dom;
39499: using namespace mozilla::layers;
39499: 
58179: // Number of milliseconds between timeupdate events as defined by spec
58179: #define TIMEUPDATE_MS 250
58179: 
34207: // Under certain conditions there may be no-one holding references to
34207: // a media element from script, DOM parent, etc, but the element may still
34207: // fire meaningful events in the future so we can't destroy it yet:
34207: // 1) If the element is delaying the load event (or would be, if it were
34207: // in a document), then events up to loadeddata or error could be fired,
34207: // so we need to stay alive.
34207: // 2) If the element is not paused and playback has not ended, then
34207: // we will (or might) play, sending timeupdate and ended events and possibly
34207: // audio output, so we need to stay alive.
34207: // 3) if the element is seeking then we will fire seeking events and possibly
34207: // start playing afterward, so we need to stay alive.
34207: // 4) If autoplay could start playback in this element (if we got enough data),
34207: // then we need to stay alive.
34207: // 5) if the element is currently loading and not suspended,
34207: // script might be waiting for progress events or a 'suspend' event,
34207: // so we need to stay alive. If we're already suspended then (all other
34207: // conditions being met) it's OK to just disappear without firing any more
34207: // events, since we have the freedom to remain suspended indefinitely. Note
34207: // that we could use this 'suspended' loophole to garbage-collect a suspended
34207: // element in case 4 even if it had 'autoplay' set, but we choose not to.
34207: // If someone throws away all references to a loading 'autoplay' element
34207: // sound should still eventually play.
34207: //
34207: // Media elements owned by inactive documents (i.e. documents not contained in any
34207: // document viewer) should never hold a self-reference because none of the
34207: // above conditions are allowed: the element will stop loading and playing
34207: // and never resume loading or playing unless its owner document changes to
34207: // an active document (which can only happen if there is an external reference
34207: // to the element).
34207: // Media elements with no owner doc should be able to hold a self-reference.
34207: // Something native must have created the element and may expect it to
34207: // stay alive to play.
34207: 
34207: // It's very important that any change in state which could change the value of
34207: // needSelfReference in AddRemoveSelfReference be followed by a call to
34207: // AddRemoveSelfReference before this element could die!
34207: // It's especially important if needSelfReference would change to 'true',
34207: // since if we neglect to add a self-reference, this element might be
34207: // garbage collected while there are still event listeners that should
34207: // receive events. If we neglect to remove the self-reference then the element
34207: // just lives longer than it needs to.
34207: 
25269: class nsMediaEvent : public nsRunnable
25269: {
25269: public:
25269: 
25269:   nsMediaEvent(nsHTMLMediaElement* aElement) :
25269:     mElement(aElement),
25849:     mLoadID(mElement->GetCurrentLoadID()) {}
25269:   ~nsMediaEvent() {}
25269: 
25269:   NS_IMETHOD Run() = 0;
25269: 
25269: protected:
79445:   bool IsCancelled() {
25849:     return mElement->GetCurrentLoadID() != mLoadID;
25269:   }
25269: 
38651:   nsRefPtr<nsHTMLMediaElement> mElement;
25849:   PRUint32 mLoadID;
25269: };
25269: 
25269: class nsAsyncEventRunner : public nsMediaEvent
15751: {
15751: private:
15751:   nsString mName;
15751: 
15751: public:
53767:   nsAsyncEventRunner(const nsAString& aName, nsHTMLMediaElement* aElement) :
53767:     nsMediaEvent(aElement), mName(aName)
15751:   {
15751:   }
15751: 
51477:   NS_IMETHOD Run()
51477:   {
25269:     // Silently cancel if our load has been cancelled.
25269:     if (IsCancelled())
25269:       return NS_OK;
51477: 
53767:     return mElement->DispatchEvent(mName);
15751:   }
15751: };
15751: 
51938: class nsSourceErrorEventRunner : public nsMediaEvent
51938: {
51938: private:
51938:   nsCOMPtr<nsIContent> mSource;
25018: public:
51938:   nsSourceErrorEventRunner(nsHTMLMediaElement* aElement,
51938:                            nsIContent* aSource)
51938:     : nsMediaEvent(aElement),
51938:       mSource(aSource)
51938:   {
51938:   }
51938: 
25018:   NS_IMETHOD Run() {
51938:     // Silently cancel if our load has been cancelled.
51938:     if (IsCancelled())
25018:       return NS_OK;
51938:     LOG_EVENT(PR_LOG_DEBUG, ("%p Dispatching simple event source error", mElement.get()));
80526:     return nsContentUtils::DispatchTrustedEvent(mElement->OwnerDoc(),
51938:                                                 mSource,
51938:                                                 NS_LITERAL_STRING("error"),
79547:                                                 false,
79547:                                                 true);
25018:   }
25018: };
25018: 
30151: /**
30151:  * There is a reference cycle involving this class: MediaLoadListener
30151:  * holds a reference to the nsHTMLMediaElement, which holds a reference
30151:  * to an nsIChannel, which holds a reference to this listener.
30151:  * We break the reference cycle in OnStartRequest by clearing mElement.
30151:  */
28370: class nsHTMLMediaElement::MediaLoadListener : public nsIStreamListener,
28370:                                               public nsIChannelEventSink,
38651:                                               public nsIInterfaceRequestor,
38651:                                               public nsIObserver
22826: {
22826:   NS_DECL_ISUPPORTS
22826:   NS_DECL_NSIREQUESTOBSERVER
22826:   NS_DECL_NSISTREAMLISTENER
28370:   NS_DECL_NSICHANNELEVENTSINK
38651:   NS_DECL_NSIOBSERVER
28370:   NS_DECL_NSIINTERFACEREQUESTOR
22826: 
22826: public:
25269:   MediaLoadListener(nsHTMLMediaElement* aElement)
69290:     : mElement(aElement),
69290:       mLoadID(aElement->GetCurrentLoadID())
22826:   {
22826:     NS_ABORT_IF_FALSE(mElement, "Must pass an element to call back");
22826:   }
22826: 
22826: private:
22826:   nsRefPtr<nsHTMLMediaElement> mElement;
22826:   nsCOMPtr<nsIStreamListener> mNextListener;
69290:   PRUint32 mLoadID;
22826: };
22826: 
38651: NS_IMPL_ISUPPORTS5(nsHTMLMediaElement::MediaLoadListener, nsIRequestObserver,
28370:                    nsIStreamListener, nsIChannelEventSink,
38651:                    nsIInterfaceRequestor, nsIObserver)
38651: 
38651: NS_IMETHODIMP
38651: nsHTMLMediaElement::MediaLoadListener::Observe(nsISupports* aSubject,
38651:                                                const char* aTopic, const PRUnichar* aData)
38651: {
38651:   nsContentUtils::UnregisterShutdownObserver(this);
38651: 
38651:   // Clear mElement to break cycle so we don't leak on shutdown
38651:   mElement = nsnull;
38659:   return NS_OK;
38651: }
22826: 
86044: void nsHTMLMediaElement::ReportLoadError(const char* aMsg,
86044:                                          const PRUnichar** aParams,
86044:                                          PRUint32 aParamCount)
86044: {
86044:   nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
86044:                                   "Media",
86044:                                   OwnerDoc(),
86044:                                   nsContentUtils::eDOM_PROPERTIES,
86044:                                   aMsg,
86044:                                   aParams,
86044:                                   aParamCount);
86044: }
86044: 
86044: 
25269: NS_IMETHODIMP nsHTMLMediaElement::MediaLoadListener::OnStartRequest(nsIRequest* aRequest, nsISupports* aContext)
22826: {
38651:   nsContentUtils::UnregisterShutdownObserver(this);
38651: 
86738:   if (!mElement) {
86738:     // We've been notified by the shutdown observer, and are shutting down.
86738:     return NS_BINDING_ABORTED;
86738:   }
86738: 
30151:   // The element is only needed until we've had a chance to call
30151:   // InitializeDecoderForChannel. So make sure mElement is cleared here.
30151:   nsRefPtr<nsHTMLMediaElement> element;
30151:   element.swap(mElement);
30151: 
69290:   if (mLoadID != element->GetCurrentLoadID()) {
69290:     // The channel has been cancelled before we had a chance to create
69290:     // a decoder. Abort, don't dispatch an "error" event, as the new load
69290:     // may not be in an error state.
69290:     return NS_BINDING_ABORTED;
69290:   }
69290: 
26341:   // Don't continue to load if the request failed or has been canceled.
26341:   nsresult status;
82292:   nsresult rv = aRequest->GetStatus(&status);
26341:   NS_ENSURE_SUCCESS(rv, rv);
26341:   if (NS_FAILED(status)) {
30151:     if (element)
30151:       element->NotifyLoadError();
26341:     return status;
26341:   }
22826: 
86044:   nsCOMPtr<nsIHttpChannel> hc = do_QueryInterface(aRequest);
86044:   bool succeeded;
86044:   if (hc && NS_SUCCEEDED(hc->GetRequestSucceeded(&succeeded)) && !succeeded) {
86044:     element->NotifyLoadError();
86044:     PRUint32 responseStatus = 0;
86044:     hc->GetResponseStatus(&responseStatus);
86044:     nsAutoString code;
86044:     code.AppendInt(responseStatus);
86044:     nsAutoString src;
86044:     element->GetCurrentSrc(src);
86044:     const PRUnichar* params[] = { code.get(), src.get() };
86044:     element->ReportLoadError("MediaLoadHttpError", params, ArrayLength(params));
86044:     return NS_BINDING_ABORTED;
86044:   }
86044: 
22826:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
22826:   if (channel &&
30151:       element &&
30159:       NS_SUCCEEDED(rv = element->InitializeDecoderForChannel(channel, getter_AddRefs(mNextListener))) &&
22826:       mNextListener) {
22826:     rv = mNextListener->OnStartRequest(aRequest, aContext);
22826:   } else {
25001:     // If InitializeDecoderForChannel() returned an error, fire a network
25001:     // error.
30151:     if (NS_FAILED(rv) && !mNextListener && element) {
25269:       // Load failed, attempt to load the next candidate resource. If there
32934:       // are none, this will trigger a MEDIA_ERR_SRC_NOT_SUPPORTED error.
30151:       element->NotifyLoadError();
25001:     }
25001:     // If InitializeDecoderForChannel did not return a listener (but may
25001:     // have otherwise succeeded), we abort the connection since we aren't
25001:     // interested in keeping the channel alive ourselves.
22826:     rv = NS_BINDING_ABORTED;
22826:   }
22826: 
22826:   return rv;
22826: }
22826: 
25269: NS_IMETHODIMP nsHTMLMediaElement::MediaLoadListener::OnStopRequest(nsIRequest* aRequest, nsISupports* aContext,
22826:                                                                    nsresult aStatus)
22826: {
22826:   if (mNextListener) {
22826:     return mNextListener->OnStopRequest(aRequest, aContext, aStatus);
22826:   }
22826:   return NS_OK;
22826: }
22826: 
25269: NS_IMETHODIMP nsHTMLMediaElement::MediaLoadListener::OnDataAvailable(nsIRequest* aRequest, nsISupports* aContext,
22826:                                                                      nsIInputStream* aStream, PRUint32 aOffset,
22826:                                                                      PRUint32 aCount)
22826: {
27985:   if (!mNextListener) {
27985:     NS_ERROR("Must have a chained listener; OnStartRequest should have canceled this request");
27985:     return NS_BINDING_ABORTED;
27985:   }
22826:   return mNextListener->OnDataAvailable(aRequest, aContext, aStream, aOffset, aCount);
22826: }
22826: 
48889: NS_IMETHODIMP nsHTMLMediaElement::MediaLoadListener::AsyncOnChannelRedirect(nsIChannel* aOldChannel,
28370:                                                                             nsIChannel* aNewChannel,
48889:                                                                             PRUint32 aFlags,
48889:                                                                             nsIAsyncVerifyRedirectCallback* cb)
28370: {
48889:   // TODO is this really correct?? See bug #579329.
28473:   if (mElement)
28473:     mElement->OnChannelRedirect(aOldChannel, aNewChannel, aFlags);
28370:   nsCOMPtr<nsIChannelEventSink> sink = do_QueryInterface(mNextListener);
28370:   if (sink)
48889:     return sink->AsyncOnChannelRedirect(aOldChannel, aNewChannel, aFlags, cb);
48889: 
48889:   cb->OnRedirectVerifyCallback(NS_OK);
28370:   return NS_OK;
28370: }
28370: 
28370: NS_IMETHODIMP nsHTMLMediaElement::MediaLoadListener::GetInterface(const nsIID & aIID, void **aResult)
28370: {
28370:   return QueryInterface(aIID, aResult);
28370: }
28370: 
25849: NS_IMPL_ADDREF_INHERITED(nsHTMLMediaElement, nsGenericHTMLElement)
25849: NS_IMPL_RELEASE_INHERITED(nsHTMLMediaElement, nsGenericHTMLElement)
25269: 
25849: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLMediaElement)
25269: 
25849: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLMediaElement, nsGenericHTMLElement)
25849:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSourcePointer)
25850:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLoadBlockedDoc)
69107:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSourceLoadCandidate)
25849: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
25849: 
25849: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsHTMLMediaElement, nsGenericHTMLElement)
25849:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mSourcePointer)
38651:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mLoadBlockedDoc)
69107:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mSourceLoadCandidate)
25849: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
25849: 
25849: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsHTMLMediaElement)
38651:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
25849: NS_INTERFACE_MAP_END_INHERITING(nsGenericHTMLElement)
25018: 
15751: // nsIDOMHTMLMediaElement
15751: NS_IMPL_URI_ATTR(nsHTMLMediaElement, Src, src)
15751: NS_IMPL_BOOL_ATTR(nsHTMLMediaElement, Controls, controls)
16290: NS_IMPL_BOOL_ATTR(nsHTMLMediaElement, Autoplay, autoplay)
82534: NS_IMPL_BOOL_ATTR(nsHTMLMediaElement, Loop, loop)
84679: NS_IMPL_BOOL_ATTR(nsHTMLMediaElement, DefaultMuted, muted)
73867: NS_IMPL_ENUM_ATTR_DEFAULT_VALUE(nsHTMLMediaElement, Preload, preload, NULL)
15751: 
25272: /* readonly attribute nsIDOMHTMLMediaElement mozAutoplayEnabled; */
79445: NS_IMETHODIMP nsHTMLMediaElement::GetMozAutoplayEnabled(bool *aAutoplayEnabled)
25272: {
57359:   *aAutoplayEnabled = mAutoplayEnabled;
25272: 
25272:   return NS_OK;
25272: }
25272: 
51394: /* readonly attribute nsIDOMMediaError error; */
51394: NS_IMETHODIMP nsHTMLMediaElement::GetError(nsIDOMMediaError * *aError)
15751: {
15751:   NS_IF_ADDREF(*aError = mError);
15751: 
15751:   return NS_OK;
15751: }
15751: 
16290: /* readonly attribute boolean ended; */
79445: NS_IMETHODIMP nsHTMLMediaElement::GetEnded(bool *aEnded)
16290: {
79547:   *aEnded = mDecoder ? mDecoder->IsEnded() : false;
16290: 
16290:   return NS_OK;
16290: }
16290: 
15751: /* readonly attribute DOMString currentSrc; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetCurrentSrc(nsAString & aCurrentSrc)
15751: {
15751:   nsCAutoString src;
77175:   GetCurrentSpec(src);
15751:   aCurrentSrc = NS_ConvertUTF8toUTF16(src);
15751:   return NS_OK;
15751: }
15751: 
15751: /* readonly attribute unsigned short networkState; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetNetworkState(PRUint16 *aNetworkState)
15751: {
15751:   *aNetworkState = mNetworkState;
15751: 
15751:   return NS_OK;
15751: }
15751: 
28473: nsresult
28473: nsHTMLMediaElement::OnChannelRedirect(nsIChannel *aChannel,
28473:                                       nsIChannel *aNewChannel,
28473:                                       PRUint32 aFlags)
28473: {
28473:   NS_ASSERTION(aChannel == mChannel, "Channels should match!");
28473:   mChannel = aNewChannel;
41190: 
41190:   // Handle forwarding of Range header so that the intial detection
41190:   // of seeking support (via result code 206) works across redirects.
41190:   nsCOMPtr<nsIHttpChannel> http = do_QueryInterface(aChannel);
41190:   NS_ENSURE_STATE(http);
41190: 
41190:   NS_NAMED_LITERAL_CSTRING(rangeHdr, "Range");
41190:  
41190:   nsCAutoString rangeVal;
41190:   if (NS_SUCCEEDED(http->GetRequestHeader(rangeHdr, rangeVal))) {
41190:     NS_ENSURE_STATE(!rangeVal.IsEmpty());
41190: 
41190:     http = do_QueryInterface(aNewChannel);
41190:     NS_ENSURE_STATE(http);
41190:  
79547:     nsresult rv = http->SetRequestHeader(rangeHdr, rangeVal, false);
41190:     NS_ENSURE_SUCCESS(rv, rv);
41190:   }
41190:  
28473:   return NS_OK;
28473: }
28473: 
25849: void nsHTMLMediaElement::AbortExistingLoads()
15751: {
25849:   // Abort any already-running instance of the resource selection algorithm.
25849:   mLoadWaitStatus = NOT_WAITING;
25849: 
25849:   // Set a new load ID. This will cause events which were enqueued
26343:   // with a different load ID to silently be cancelled.
25849:   mCurrentLoadID++;
25269: 
79445:   bool fireTimeUpdate = false;
82746: 
22826:   if (mDecoder) {
82746:     RemoveMediaElementFromURITable();
48190:     fireTimeUpdate = mDecoder->GetCurrentTime() != 0.0;
22826:     mDecoder->Shutdown();
22826:     mDecoder = nsnull;
21079:   }
82746:   mLoadingSrc = nsnull;
21079: 
25849:   if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_LOADING ||
25849:       mNetworkState == nsIDOMHTMLMediaElement::NETWORK_IDLE)
25849:   {
53767:     DispatchEvent(NS_LITERAL_STRING("abort"));
25269:   }
15751: 
15751:   mError = nsnull;
79547:   mLoadedFirstFrame = false;
79547:   mAutoplaying = true;
79547:   mIsLoadingFromSourceChildren = false;
79547:   mSuspendedAfterFirstFrame = false;
79547:   mAllowSuspendAfterFirstFrame = true;
82746:   mLoadIsSuspended = false;
48189:   mSourcePointer = nsnull;
15751: 
21357:   // TODO: The playback rate must be set to the default playback rate.
15751: 
22787:   if (mNetworkState != nsIDOMHTMLMediaElement::NETWORK_EMPTY) {
22787:     mNetworkState = nsIDOMHTMLMediaElement::NETWORK_EMPTY;
22787:     ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_NOTHING);
79547:     mPaused = true;
25849: 
48190:     if (fireTimeUpdate) {
48190:       // Since we destroyed the decoder above, the current playback position
48190:       // will now be reported as 0. The playback position was non-zero when
48190:       // we destroyed the decoder, so fire a timeupdate event so that the
48190:       // change will be reflected in the controls.
79547:       FireTimeUpdate(false);
48190:     }
53767:     DispatchEvent(NS_LITERAL_STRING("emptied"));
15751:   }
25850: 
34207:   // We may have changed mPaused, mAutoplaying, mNetworkState and other
34207:   // things which can affect AddRemoveSelfReference
34207:   AddRemoveSelfReference();
34207: 
79547:   mIsRunningSelectResource = false;
25269: }
22826: 
32934: void nsHTMLMediaElement::NoSupportedMediaSourceError()
25001: {
34207:   NS_ASSERTION(mDelayingLoadEvent, "Load event not delayed during source selection?");
34207: 
51394:   mError = new nsMediaError(nsIDOMMediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
25849:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_NO_SOURCE;
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("error"));
34207:   // This clears mDelayingLoadEvent, so AddRemoveSelfReference will be called
79547:   ChangeDelayLoadStatus(false);
25001: }
25001: 
51938: typedef void (nsHTMLMediaElement::*SyncSectionFn)();
51938: 
51938: // Runs a "synchronous section", a function that must run once the event loop
51938: // has reached a "stable state". See:
51938: // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#synchronous-section
51938: class nsSyncSection : public nsMediaEvent
51938: {
51938: private:
51938:   SyncSectionFn mClosure;
51938: public:
51938:   nsSyncSection(nsHTMLMediaElement* aElement,
51938:                 SyncSectionFn aClosure) :
51938:     nsMediaEvent(aElement),
51938:     mClosure(aClosure)
51938:   {
51938:   }
51938: 
51938:   NS_IMETHOD Run() {
51938:     // Silently cancel if our load has been cancelled.
51938:     if (IsCancelled())
51938:       return NS_OK;
51938:     (mElement.get()->*mClosure)();
51938:     return NS_OK;
51938:   }
51938: };
51938: 
51938: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
51938: 
51938: // Asynchronously awaits a stable state, whereupon aClosure runs on the main
51938: // thread. This adds an event which run aClosure to the appshell's list of 
51938: // sections synchronous the next time control returns to the event loop.
51938: void AsyncAwaitStableState(nsHTMLMediaElement* aElement,
51938:                            SyncSectionFn aClosure)
51938: {
51938:   nsCOMPtr<nsIRunnable> event = new nsSyncSection(aElement, aClosure);
51938:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
51938:   appShell->RunInStableState(event);
51938: }
51938: 
51938: void nsHTMLMediaElement::QueueLoadFromSourceTask()
51938: {
79547:   ChangeDelayLoadStatus(true);
51938:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADING;
51938:   AsyncAwaitStableState(this, &nsHTMLMediaElement::LoadFromSourceChildren);
51938: }
51938: 
51938: void nsHTMLMediaElement::QueueSelectResourceTask()
51938: {
51938:   // Don't allow multiple async select resource calls to be queued.
51938:   if (mIsRunningSelectResource)
51938:     return;
79547:   mIsRunningSelectResource = true;
51938:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_NO_SOURCE;
51938:   AsyncAwaitStableState(this, &nsHTMLMediaElement::SelectResource);
51938: }
51938: 
22826: /* void load (); */
22826: NS_IMETHODIMP nsHTMLMediaElement::Load()
22826: {
25849:   if (mIsRunningLoadMethod)
22826:     return NS_OK;
79547:   SetPlayedOrSeeked(false);
79547:   mIsRunningLoadMethod = true;
25849:   AbortExistingLoads();
25849:   QueueSelectResourceTask();
79547:   mIsRunningLoadMethod = false;
25018:   return NS_OK;
25001: }
22826: 
79445: static bool HasSourceChildren(nsIContent *aElement)
25269: {
78992:   for (nsIContent* child = aElement->GetFirstChild();
78992:        child;
78992:        child = child->GetNextSibling()) {
78992:     if (child->IsHTML(nsGkAtoms::source))
25849:     {
79547:       return true;
25849:     }
25849:   }
79547:   return false;
25849: }
25269: 
25849: void nsHTMLMediaElement::SelectResource()
25849: {
71790:   if (!HasAttr(kNameSpaceID_None, nsGkAtoms::src) && !HasSourceChildren(this)) {
51938:     // The media element has neither a src attribute nor any source
51938:     // element children, abort the load.
51938:     mNetworkState = nsIDOMHTMLMediaElement::NETWORK_EMPTY;
34207:     // This clears mDelayingLoadEvent, so AddRemoveSelfReference will be called
79547:     ChangeDelayLoadStatus(false);
79547:     mIsRunningSelectResource = false;
25849:     return;
25849:   }
25849: 
79547:   ChangeDelayLoadStatus(true);
51938: 
25849:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADING;
34207:   // Load event was delayed, and still is, so no need to call
34207:   // AddRemoveSelfReference, since it must still be held
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("loadstart"));
25849: 
82292:   // If we have a 'src' attribute, use that exclusively.
25849:   nsAutoString src;
82292:   if (GetAttr(kNameSpaceID_None, nsGkAtoms::src, src)) {
25849:     nsCOMPtr<nsIURI> uri;
25849:     nsresult rv = NewURIFromString(src, getter_AddRefs(uri));
25849:     if (NS_SUCCEEDED(rv)) {
33372:       LOG(PR_LOG_DEBUG, ("%p Trying load from src=%s", this, NS_ConvertUTF16toUTF8(src).get()));
55968:       NS_ASSERTION(!mIsLoadingFromSourceChildren,
55968:         "Should think we're not loading from source children by default");
51938:       mLoadingSrc = uri;
50948:       if (mPreloadAction == nsHTMLMediaElement::PRELOAD_NONE) {
50948:         // preload:none media, suspend the load here before we make any
50948:         // network requests.
82746:         SuspendLoad();
79547:         mIsRunningSelectResource = false;
50948:         return;
50948:       }
50948: 
82746:       rv = LoadResource();
51938:       if (NS_SUCCEEDED(rv)) {
79547:         mIsRunningSelectResource = false;
25849:         return;
25849:       }
86044:     } else {
86044:       const PRUnichar* params[] = { src.get() };
86044:       ReportLoadError("MediaLoadInvalidURI", params, ArrayLength(params));
51938:     }
32934:     NoSupportedMediaSourceError();
25849:   } else {
25849:     // Otherwise, the source elements will be used.
79547:     mIsLoadingFromSourceChildren = true;
25849:     LoadFromSourceChildren();
25849:   }
79547:   mIsRunningSelectResource = false;
25849: }
25849: 
25849: void nsHTMLMediaElement::NotifyLoadError()
25849: {
55968:   if (!mIsLoadingFromSourceChildren) {
51938:     LOG(PR_LOG_DEBUG, ("NotifyLoadError(), no supported media error"));
32934:     NoSupportedMediaSourceError();
69107:   } else if (mSourceLoadCandidate) {
51938:     DispatchAsyncSourceError(mSourceLoadCandidate);
25849:     QueueLoadFromSourceTask();
69107:   } else {
69107:     NS_WARNING("Should know the source we were loading from!");
25849:   }
25849: }
25849: 
51477: void nsHTMLMediaElement::NotifyAudioAvailable(float* aFrameBuffer,
51477:                                               PRUint32 aFrameBufferLength,
54997:                                               float aTime)
51477: {
52051:   // Auto manage the memory for the frame buffer, so that if we add an early
52051:   // return-on-error here in future, we won't forget to release the memory.
52051:   // Otherwise we hand ownership of the memory over to the event created by 
52051:   // DispatchAudioAvailableEvent().
52051:   nsAutoArrayPtr<float> frameBuffer(aFrameBuffer);
51477:   // Do same-origin check on element and media before allowing MozAudioAvailable events.
51477:   if (!mMediaSecurityVerified) {
51477:     nsCOMPtr<nsIPrincipal> principal = GetCurrentPrincipal();
51477:     nsresult rv = NodePrincipal()->Subsumes(principal, &mAllowAudioData);
51477:     if (NS_FAILED(rv)) {
79547:       mAllowAudioData = false;
51477:     }
51477:   }
51477: 
52051:   DispatchAudioAvailableEvent(frameBuffer.forget(), aFrameBufferLength, aTime);
51477: }
51477: 
25849: void nsHTMLMediaElement::LoadFromSourceChildren()
25849: {
34207:   NS_ASSERTION(mDelayingLoadEvent,
34207:                "Should delay load event (if in document) during load");
55968:   NS_ASSERTION(mIsLoadingFromSourceChildren,
51938:                "Must remember we're loading from source children");
79547:   while (true) {
51938:     nsIContent* child = GetNextSource();
51938:     if (!child) {
25849:       // Exhausted candidates, wait for more candidates to be appended to
25849:       // the media element.
25849:       mLoadWaitStatus = WAITING_FOR_SOURCE;
51938:       mNetworkState = nsIDOMHTMLMediaElement::NETWORK_NO_SOURCE;
79547:       ChangeDelayLoadStatus(false);
86044:       ReportLoadError("MediaLoadExhaustedCandidates");
25849:       return;
25849:     }
25849: 
51938:     // Must have src attribute.
82292:     nsAutoString src;
51938:     if (!child->GetAttr(kNameSpaceID_None, nsGkAtoms::src, src)) {
86044:       ReportLoadError("MediaLoadSourceMissingSrc");
51938:       DispatchAsyncSourceError(child);
51938:       continue;
51938:     }
51938: 
51938:     // If we have a type attribute, it must be a supported type.
82292:     nsAutoString type;
82292:     if (child->GetAttr(kNameSpaceID_None, nsGkAtoms::type, type) &&
82292:         GetCanPlay(type) == CANPLAY_NO) {
51938:       DispatchAsyncSourceError(child);
86044:       const PRUnichar* params[] = { type.get(), src.get() };
86044:       ReportLoadError("MediaLoadUnsupportedType", params, ArrayLength(params));
51938:       continue;
51938:     }
51938:     LOG(PR_LOG_DEBUG, ("%p Trying load from <source>=%s type=%s", this,
51938:       NS_ConvertUTF16toUTF8(src).get(), NS_ConvertUTF16toUTF8(type).get()));
82292: 
82292:     nsCOMPtr<nsIURI> uri;
51938:     NewURIFromString(src, getter_AddRefs(uri));
51938:     if (!uri) {
51938:       DispatchAsyncSourceError(child);
86044:       const PRUnichar* params[] = { src.get() };
86044:       ReportLoadError("MediaLoadInvalidURI", params, ArrayLength(params));
51938:       continue;
51938:     }
51938: 
51938:     mLoadingSrc = uri;
51938:     NS_ASSERTION(mNetworkState == nsIDOMHTMLMediaElement::NETWORK_LOADING,
51938:                  "Network state should be loading");
25849: 
50948:     if (mPreloadAction == nsHTMLMediaElement::PRELOAD_NONE) {
50948:       // preload:none media, suspend the load here before we make any
50948:       // network requests.
82746:       SuspendLoad();
50948:       return;
50948:     }
50948: 
82746:     if (NS_SUCCEEDED(LoadResource())) {
25849:       return;
82292:     }
25849: 
25849:     // If we fail to load, loop back and try loading the next resource.
51938:     DispatchAsyncSourceError(child);
25849:   }
25849:   NS_NOTREACHED("Execution should not reach here!");
25849: }
25849: 
82746: void nsHTMLMediaElement::SuspendLoad()
50948: {
79547:   mLoadIsSuspended = true;
50948:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_IDLE;
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("suspend"));
79547:   ChangeDelayLoadStatus(false);
50948: }
50948: 
50948: void nsHTMLMediaElement::ResumeLoad(PreloadAction aAction)
50948: {
50948:   NS_ASSERTION(mLoadIsSuspended, "Can only resume preload if halted for one");
79547:   mLoadIsSuspended = false;
50948:   mPreloadAction = aAction;
79547:   ChangeDelayLoadStatus(true);
50949:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADING;
55968:   if (!mIsLoadingFromSourceChildren) {
50948:     // We were loading from the element's src attribute.
82746:     if (NS_FAILED(LoadResource())) {
50948:       NoSupportedMediaSourceError();
50948:     }
50948:   } else {
50948:     // We were loading from a child <source> element. Try to resume the
50948:     // load of that child, and if that fails, try the next child.
82746:     if (NS_FAILED(LoadResource())) {
50948:       LoadFromSourceChildren();
50948:     }
50948:   }
50948: }
50948: 
79445: static bool IsAutoplayEnabled()
50948: {
70840:   return Preferences::GetBool("media.autoplay.enabled");
50948: }
50948: 
50948: void nsHTMLMediaElement::UpdatePreloadAction()
50948: {
50948:   PreloadAction nextAction = PRELOAD_UNDEFINED;
55966:   // If autoplay is set, or we're playing, we should always preload data,
55966:   // as we'll need it to play.
55966:   if ((IsAutoplayEnabled() && HasAttr(kNameSpaceID_None, nsGkAtoms::autoplay)) ||
55966:       !mPaused)
55966:   {
50948:     nextAction = nsHTMLMediaElement::PRELOAD_ENOUGH;
50948:   } else {
50948:     // Find the appropriate preload action by looking at the attribute.
50948:     const nsAttrValue* val = mAttrsAndChildren.GetAttr(nsGkAtoms::preload,
50948:                                                        kNameSpaceID_None);
70842:     PRUint32 preloadDefault =
70842:       Preferences::GetInt("media.preload.default",
62638:                           nsHTMLMediaElement::PRELOAD_ATTR_METADATA);
70842:     PRUint32 preloadAuto =
70842:       Preferences::GetInt("media.preload.auto",
62638:                           nsHTMLMediaElement::PRELOAD_ENOUGH);
50948:     if (!val) {
62638:       // Attribute is not set. Use the preload action specified by the 
62638:       // media.preload.default pref, or just preload metadata if not present.
62638:       nextAction = static_cast<PreloadAction>(preloadDefault);
50948:     } else if (val->Type() == nsAttrValue::eEnum) {
50948:       PreloadAttrValue attr = static_cast<PreloadAttrValue>(val->GetEnumValue());
50948:       if (attr == nsHTMLMediaElement::PRELOAD_ATTR_EMPTY ||
50948:           attr == nsHTMLMediaElement::PRELOAD_ATTR_AUTO)
50948:       {
62638:         nextAction = static_cast<PreloadAction>(preloadAuto);
50948:       } else if (attr == nsHTMLMediaElement::PRELOAD_ATTR_METADATA) {
50948:         nextAction = nsHTMLMediaElement::PRELOAD_METADATA;
50948:       } else if (attr == nsHTMLMediaElement::PRELOAD_ATTR_NONE) {
50948:         nextAction = nsHTMLMediaElement::PRELOAD_NONE;
50948:       }
50948:     } else {
62638:       // Use the suggested "missing value default" of "metadata", or the value
62638:       // specified by the media.preload.default, if present.
62638:       nextAction = static_cast<PreloadAction>(preloadDefault);
50948:     }
50948:   }
50948: 
50948:   if ((mBegun || mIsRunningSelectResource) && nextAction < mPreloadAction) {
50948:     // We've started a load or are already downloading, and the preload was
50948:     // changed to a state where we buffer less. We don't support this case,
50948:     // so don't change the preload behaviour.
50948:     return;
50948:   }
50948: 
50948:   mPreloadAction = nextAction;
50948:   if (nextAction == nsHTMLMediaElement::PRELOAD_ENOUGH) {
50948:     if (mLoadIsSuspended) {
50948:       // Our load was previouly suspended due to the media having preload
50948:       // value "none". The preload value has changed to preload:auto, so
50948:       // resume the load.
50948:       ResumeLoad(PRELOAD_ENOUGH);
50948:     } else {
50948:       // Preload as much of the video as we can, i.e. don't suspend after
50948:       // the first frame.
50948:       StopSuspendingAfterFirstFrame();
50948:     }
50948: 
50948:   } else if (nextAction == nsHTMLMediaElement::PRELOAD_METADATA) {
50948:     // Ensure that the video can be suspended after first frame.
79547:     mAllowSuspendAfterFirstFrame = true;
50948:     if (mLoadIsSuspended) {
50948:       // Our load was previouly suspended due to the media having preload
50948:       // value "none". The preload value has changed to preload:metadata, so
50948:       // resume the load. We'll pause the load again after we've read the
50948:       // metadata.
50948:       ResumeLoad(PRELOAD_METADATA);
50948:     }
50948:   }
50948: }
50948: 
82746: nsresult nsHTMLMediaElement::LoadResource()
25849: {
34207:   NS_ASSERTION(mDelayingLoadEvent,
34207:                "Should delay load event (if in document) during load");
25269: 
51477:   // If a previous call to mozSetup() was made, kill that media stream
51477:   // in order to use this new src instead.
51477:   if (mAudioStream) {
51477:     mAudioStream->Shutdown();
51477:     mAudioStream = nsnull;
51477:   }
51477: 
22826:   if (mChannel) {
22826:     mChannel->Cancel(NS_BINDING_ABORTED);
22826:     mChannel = nsnull;
22826:   }
22826: 
82746:   nsHTMLMediaElement* other = LookupMediaElementURITable(mLoadingSrc);
82746:   if (other) {
82746:     // Clone it.
82746:     nsresult rv = InitializeDecoderAsClone(other->mDecoder);
82746:     if (NS_SUCCEEDED(rv))
82746:       return rv;
82746:   }
82746: 
24226:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
82292:   nsresult rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_MEDIA,
82746:                                           mLoadingSrc,
24226:                                           NodePrincipal(),
38651:                                           static_cast<nsGenericElement*>(this),
24226:                                           EmptyCString(), // mime type
24226:                                           nsnull, // extra
24226:                                           &shouldLoad,
24226:                                           nsContentUtils::GetContentPolicy(),
24226:                                           nsContentUtils::GetSecurityManager());
25849:   NS_ENSURE_SUCCESS(rv, rv);
82292:   if (NS_CP_REJECTED(shouldLoad)) {
82292:     return NS_ERROR_FAILURE;
82292:   }
24226: 
27217:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
41207: 
41207:   // check for a Content Security Policy to pass down to the channel
41207:   // created to load the media content
41207:   nsCOMPtr<nsIChannelPolicy> channelPolicy;
41207:   nsCOMPtr<nsIContentSecurityPolicy> csp;
41207:   rv = NodePrincipal()->GetCsp(getter_AddRefs(csp));
41207:   NS_ENSURE_SUCCESS(rv,rv);
41207:   if (csp) {
41207:     channelPolicy = do_CreateInstance("@mozilla.org/nschannelpolicy;1");
41207:     channelPolicy->SetContentSecurityPolicy(csp);
41207:     channelPolicy->SetLoadType(nsIContentPolicy::TYPE_MEDIA);
41207:   }
57574:   nsCOMPtr<nsIChannel> channel;
57574:   rv = NS_NewChannel(getter_AddRefs(channel),
82746:                      mLoadingSrc,
22826:                      nsnull,
27217:                      loadGroup,
22826:                      nsnull,
41207:                      nsICachingChannel::LOAD_BYPASS_LOCAL_CACHE_IF_BUSY,
41207:                      channelPolicy);
25849:   NS_ENSURE_SUCCESS(rv,rv);
25269: 
57574:   // The listener holds a strong reference to us.  This creates a
57574:   // reference cycle, once we've set mChannel, which is manually broken
57574:   // in the listener's OnStartRequest method after it is finished with
57574:   // the element. The cycle will also be broken if we get a shutdown
57574:   // notification before OnStartRequest fires.  Necko guarantees that
57574:   // OnStartRequest will eventually fire if we don't shut down first.
28370:   nsRefPtr<MediaLoadListener> loadListener = new MediaLoadListener(this);
24155: 
57574:   channel->SetNotificationCallbacks(loadListener);
28370: 
24155:   nsCOMPtr<nsIStreamListener> listener;
24155:   if (ShouldCheckAllowOrigin()) {
57574:     listener =
64070:       new nsCORSListenerProxy(loadListener,
24155:                               NodePrincipal(),
57574:                               channel,
79547:                               false,
24155:                               &rv);
24155:   } else {
24187:     rv = nsContentUtils::GetSecurityManager()->
24187:            CheckLoadURIWithPrincipal(NodePrincipal(),
82746:                                      mLoadingSrc,
24187:                                      nsIScriptSecurityManager::STANDARD);
24155:     listener = loadListener;
24155:   }
57574:   NS_ENSURE_SUCCESS(rv, rv);
22826: 
57574:   nsCOMPtr<nsIHttpChannel> hc = do_QueryInterface(channel);
22826:   if (hc) {
22826:     // Use a byte range request from the start of the resource.
22826:     // This enables us to detect if the stream supports byte range
22826:     // requests, and therefore seeking, early.
22826:     hc->SetRequestHeader(NS_LITERAL_CSTRING("Range"),
22826:                          NS_LITERAL_CSTRING("bytes=0-"),
79547:                          false);
48349: 
54200:     SetRequestHeaders(hc);
22826:   }
22826: 
57574:   rv = channel->AsyncOpen(listener, nsnull);
57574:   NS_ENSURE_SUCCESS(rv, rv);
22826: 
25269:   // Else the channel must be open and starting to download. If it encounters
42263:   // a non-catastrophic failure, it will set a new task to continue loading
57574:   // another candidate.  It's safe to set it as mChannel now.
57574:   mChannel = channel;
57574: 
57574:   // loadListener will be unregistered either on shutdown or when
57574:   // OnStartRequest for the channel we just opened fires.
57574:   nsContentUtils::RegisterShutdownObserver(loadListener);
25849:   return NS_OK;
22826: }
22826: 
22826: nsresult nsHTMLMediaElement::LoadWithChannel(nsIChannel *aChannel,
22826:                                              nsIStreamListener **aListener)
22826: {
22826:   NS_ENSURE_ARG_POINTER(aChannel);
22826:   NS_ENSURE_ARG_POINTER(aListener);
22826: 
22826:   *aListener = nsnull;
22826: 
25849:   AbortExistingLoads();
22826: 
82746:   nsresult rv = aChannel->GetOriginalURI(getter_AddRefs(mLoadingSrc));
82746:   NS_ENSURE_SUCCESS(rv, rv);
82746: 
79547:   ChangeDelayLoadStatus(true);
82746:   rv = InitializeDecoderForChannel(aChannel, aListener);
22826:   if (NS_FAILED(rv)) {
79547:     ChangeDelayLoadStatus(false);
32901:     return rv;
32901:   }
32901: 
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("loadstart"));
32901: 
32901:   return NS_OK;
32901: }
32901: 
32901: NS_IMETHODIMP nsHTMLMediaElement::MozLoadFrom(nsIDOMHTMLMediaElement* aOther)
32901: {
32901:   NS_ENSURE_ARG_POINTER(aOther);
32901: 
32901:   AbortExistingLoads();
32901: 
32901:   nsCOMPtr<nsIContent> content = do_QueryInterface(aOther);
32901:   nsHTMLMediaElement* other = static_cast<nsHTMLMediaElement*>(content.get());
32901:   if (!other || !other->mDecoder)
32901:     return NS_OK;
32901: 
79547:   ChangeDelayLoadStatus(true);
32901: 
82746:   mLoadingSrc = other->mLoadingSrc;
32901:   nsresult rv = InitializeDecoderAsClone(other->mDecoder);
32901:   if (NS_FAILED(rv)) {
79547:     ChangeDelayLoadStatus(false);
22826:     return rv;
22826:   }
22787: 
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("loadstart"));
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* readonly attribute unsigned short readyState; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetReadyState(PRUint16 *aReadyState)
15751: {
15751:   *aReadyState = mReadyState;
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* readonly attribute boolean seeking; */
79445: NS_IMETHODIMP nsHTMLMediaElement::GetSeeking(bool *aSeeking)
15751: {
20627:   *aSeeking = mDecoder && mDecoder->IsSeeking();
15751: 
15751:   return NS_OK;
15751: }
15751: 
60727: /* attribute double currentTime; */
60727: NS_IMETHODIMP nsHTMLMediaElement::GetCurrentTime(double *aCurrentTime)
15751: {
15751:   *aCurrentTime = mDecoder ? mDecoder->GetCurrentTime() : 0.0;
15751:   return NS_OK;
15751: }
15751: 
60727: NS_IMETHODIMP nsHTMLMediaElement::SetCurrentTime(double aCurrentTime)
15751: {
28486:   StopSuspendingAfterFirstFrame();
28486: 
33372:   if (!mDecoder) {
33372:     LOG(PR_LOG_DEBUG, ("%p SetCurrentTime(%f) failed: no decoder", this, aCurrentTime));
20627:     return NS_ERROR_DOM_INVALID_STATE_ERR;
33372:   }
20627: 
33372:   if (mReadyState == nsIDOMHTMLMediaElement::HAVE_NOTHING) {
33372:     LOG(PR_LOG_DEBUG, ("%p SetCurrentTime(%f) failed: no source", this, aCurrentTime));
28574:     return NS_ERROR_DOM_INVALID_STATE_ERR;
33372:   }
28574: 
20627:   // Detect for a NaN and invalid values.
33372:   if (aCurrentTime != aCurrentTime) {
33372:     LOG(PR_LOG_DEBUG, ("%p SetCurrentTime(%f) failed: bad time", this, aCurrentTime));
20627:     return NS_ERROR_FAILURE;
33372:   }
20627: 
28574:   // Clamp the time to [0, duration] as required by the spec
60727:   double clampedTime = NS_MAX(0.0, aCurrentTime);
60727:   double duration = mDecoder->GetDuration();
28574:   if (duration >= 0) {
38390:     clampedTime = NS_MIN(clampedTime, duration);
28574:   }
20627: 
22787:   mPlayingBeforeSeek = IsPotentiallyPlaying();
20776:   // The media backend is responsible for dispatching the timeupdate
20776:   // event if it changes the playback position as a result of the seek.
33372:   LOG(PR_LOG_DEBUG, ("%p SetCurrentTime(%f) starting seek", this, aCurrentTime));
28574:   nsresult rv = mDecoder->Seek(clampedTime);
34207: 
34207:   // We changed whether we're seeking so we need to AddRemoveSelfReference
34207:   AddRemoveSelfReference();
34207: 
20627:   return rv;
15751: }
15751: 
60727: /* readonly attribute double duration; */
60727: NS_IMETHODIMP nsHTMLMediaElement::GetDuration(double *aDuration)
15751: {
60727:   *aDuration = mDecoder ? mDecoder->GetDuration() : std::numeric_limits<double>::quiet_NaN();
15751:   return NS_OK;
15751: }
15751: 
75108: /* readonly attribute nsIDOMHTMLTimeRanges seekable; */
75108: NS_IMETHODIMP nsHTMLMediaElement::GetSeekable(nsIDOMTimeRanges** aSeekable)
75108: {
82292:   nsRefPtr<nsTimeRanges> ranges = new nsTimeRanges();
75108:   if (mDecoder && mReadyState > nsIDOMHTMLMediaElement::HAVE_NOTHING) {
75108:     mDecoder->GetSeekable(ranges);
75108:   }
82292:   ranges.forget(aSeekable);
75108:   return NS_OK;
75108: }
75108: 
75108: 
21017: /* readonly attribute boolean paused; */
79445: NS_IMETHODIMP nsHTMLMediaElement::GetPaused(bool *aPaused)
15751: {
15751:   *aPaused = mPaused;
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* void pause (); */
15751: NS_IMETHODIMP nsHTMLMediaElement::Pause()
15751: {
22787:   if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_EMPTY) {
51938:     LOG(PR_LOG_DEBUG, ("Loading due to Pause()"));
23467:     nsresult rv = Load();
15751:     NS_ENSURE_SUCCESS(rv, rv);
23467:   } else if (mDecoder) {
23467:     mDecoder->Pause();
15751:   }
15751: 
79445:   bool oldPaused = mPaused;
79547:   mPaused = true;
79547:   mAutoplaying = false;
34207:   // We changed mPaused and mAutoplaying which can affect AddRemoveSelfReference
34207:   AddRemoveSelfReference();
15751: 
15751:   if (!oldPaused) {
79547:     FireTimeUpdate(false);
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("pause"));
15751:   }
15751: 
15751:   return NS_OK;
15751: }
15751: 
60727: /* attribute double volume; */
60727: NS_IMETHODIMP nsHTMLMediaElement::GetVolume(double *aVolume)
15751: {
25534:   *aVolume = mVolume;
25534: 
15751:   return NS_OK;
15751: }
15751: 
60727: NS_IMETHODIMP nsHTMLMediaElement::SetVolume(double aVolume)
15751: {
82292:   if (aVolume < 0.0 || aVolume > 1.0)
20036:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
20036: 
25534:   if (aVolume == mVolume)
25534:     return NS_OK;
25534: 
25534:   mVolume = aVolume;
25534: 
51477:   if (mDecoder && !mMuted) {
25534:     mDecoder->SetVolume(mVolume);
51477:   } else if (mAudioStream && !mMuted) {
51477:     mAudioStream->SetVolume(mVolume);
51477:   }
15751: 
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("volumechange"));
25534: 
15751:   return NS_OK;
15751: }
15751: 
51477: NS_IMETHODIMP
51477: nsHTMLMediaElement::GetMozChannels(PRUint32 *aMozChannels)
51477: {
51477:   if (!mDecoder && !mAudioStream) {
51477:     return NS_ERROR_DOM_INVALID_STATE_ERR;
51477:   }
51477: 
51477:   *aMozChannels = mChannels;
51477:   return NS_OK;
51477: }
51477: 
51477: NS_IMETHODIMP
51477: nsHTMLMediaElement::GetMozSampleRate(PRUint32 *aMozSampleRate)
51477: {
51477:   if (!mDecoder && !mAudioStream) {
51477:     return NS_ERROR_DOM_INVALID_STATE_ERR;
51477:   }
51477: 
51477:   *aMozSampleRate = mRate;
51477:   return NS_OK;
51477: }
51477: 
51477: NS_IMETHODIMP
51477: nsHTMLMediaElement::GetMozFrameBufferLength(PRUint32 *aMozFrameBufferLength)
51477: {
51477:   // The framebuffer (via MozAudioAvailable events) is only available
51477:   // when reading vs. writing audio directly.
51477:   if (!mDecoder) {
51477:     return NS_ERROR_DOM_INVALID_STATE_ERR;
51477:   }
51477: 
51477:   *aMozFrameBufferLength = mDecoder->GetFrameBufferLength();
51477:   return NS_OK;
51477: }
51477: 
51477: NS_IMETHODIMP
51477: nsHTMLMediaElement::SetMozFrameBufferLength(PRUint32 aMozFrameBufferLength)
51477: {
51477:   if (!mDecoder)
51477:     return NS_ERROR_DOM_INVALID_STATE_ERR;
51477: 
51477:   return mDecoder->RequestFrameBufferLength(aMozFrameBufferLength);
51477: }
51477: 
15751: /* attribute boolean muted; */
79445: NS_IMETHODIMP nsHTMLMediaElement::GetMuted(bool *aMuted)
15751: {
15751:   *aMuted = mMuted;
15751: 
15751:   return NS_OK;
15751: }
15751: 
79445: NS_IMETHODIMP nsHTMLMediaElement::SetMuted(bool aMuted)
15751: {
25534:   if (aMuted == mMuted)
25534:     return NS_OK;
15751: 
15751:   mMuted = aMuted;
15751: 
25534:   if (mDecoder) {
25534:     mDecoder->SetVolume(mMuted ? 0.0 : mVolume);
51477:   } else if (mAudioStream) {
51477:     mAudioStream->SetVolume(mMuted ? 0.0 : mVolume);
25534:   }
25534: 
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("volumechange"));
25534: 
15751:   return NS_OK;
15751: }
15751: 
82746: class MediaElementSetForURI : public nsURIHashKey {
82746: public:
82746:   MediaElementSetForURI(const nsIURI* aKey) : nsURIHashKey(aKey) {}
82746:   MediaElementSetForURI(const MediaElementSetForURI& toCopy)
82746:     : nsURIHashKey(toCopy), mElements(toCopy.mElements) {}
82746:   nsTArray<nsHTMLMediaElement*> mElements;
82746: };
82746: 
82746: typedef nsTHashtable<MediaElementSetForURI> MediaElementURITable;
82746: // Elements in this table must have non-null mDecoder and mLoadingSrc, and those
82746: // can't change while the element is in the table. The table is keyed by
82746: // the element's mLoadingSrc. Each entry has a list of all elements with the
82746: // same mLoadingSrc.
82746: static MediaElementURITable* gElementTable;
82746: 
87009: #ifdef DEBUG
87009: // Returns the number of times aElement appears in the media element table
87009: // for aURI. If this returns other than 0 or 1, there's a bug somewhere!
87009: static unsigned
87009: MediaElementTableCount(nsHTMLMediaElement* aElement, nsIURI* aURI)
87009: {
87009:   if (!gElementTable || !aElement || !aURI) {
87009:     return 0;
87009:   }
87009:   MediaElementSetForURI* entry = gElementTable->GetEntry(aURI);
87009:   if (!entry) {
87009:     return 0;
87009:   }
87009:   PRUint32 count = 0;
87009:   for (PRUint32 i = 0; i < entry->mElements.Length(); ++i) {
87009:     nsHTMLMediaElement* elem = entry->mElements[i];
87009:     if (elem == aElement) {
87009:       count++;
87009:     }
87009:   }
87009:   return count;
87009: }
87009: #endif
87009: 
82746: void
82746: nsHTMLMediaElement::AddMediaElementToURITable()
82746: {
82746:   NS_ASSERTION(mDecoder && mDecoder->GetStream(), "Call this only with decoder Load called");
87009:   NS_ASSERTION(MediaElementTableCount(this, mLoadingSrc) == 0,
87009:     "Should not have entry for element in element table before addition");
82746:   if (!gElementTable) {
82746:     gElementTable = new MediaElementURITable();
82746:     gElementTable->Init();
82746:   }
82746:   MediaElementSetForURI* entry = gElementTable->PutEntry(mLoadingSrc);
82746:   entry->mElements.AppendElement(this);
87009:   NS_ASSERTION(MediaElementTableCount(this, mLoadingSrc) == 1,
87009:     "Should have a single entry for element in element table after addition");
82746: }
82746: 
82746: void
82746: nsHTMLMediaElement::RemoveMediaElementFromURITable()
82746: {
87009:   NS_ASSERTION(MediaElementTableCount(this, mLoadingSrc) == 1,
87009:     "Before remove, should have a single entry for element in element table");
82746:   NS_ASSERTION(mDecoder, "Don't call this without decoder!");
82746:   NS_ASSERTION(mLoadingSrc, "Can't have decoder without source!");
82746:   if (!gElementTable)
82746:     return;
82746:   MediaElementSetForURI* entry = gElementTable->GetEntry(mLoadingSrc);
82746:   if (!entry)
82746:     return;
82746:   entry->mElements.RemoveElement(this);
82746:   if (entry->mElements.IsEmpty()) {
82746:     gElementTable->RemoveEntry(mLoadingSrc);
82746:     if (gElementTable->Count() == 0) {
82746:       delete gElementTable;
82746:       gElementTable = nsnull;
82746:     }
82746:   }
87009:   NS_ASSERTION(MediaElementTableCount(this, mLoadingSrc) == 0,
87009:     "After remove, should no longer have an entry in element table");
82746: }
82746: 
82746: nsHTMLMediaElement*
82746: nsHTMLMediaElement::LookupMediaElementURITable(nsIURI* aURI)
82746: {
82746:   if (!gElementTable)
82746:     return nsnull;
82746:   MediaElementSetForURI* entry = gElementTable->GetEntry(aURI);
82746:   if (!entry)
82746:     return nsnull;
82746:   for (PRUint32 i = 0; i < entry->mElements.Length(); ++i) {
82746:     nsHTMLMediaElement* elem = entry->mElements[i];
82746:     bool equal;
82746:     // Look for elements that have the same principal.
82746:     // XXX when we implement crossorigin for video, we'll also need to check
82746:     // for the same crossorigin mode here. Ditto for anything else that could
82746:     // cause us to send different headers.
82746:     if (NS_SUCCEEDED(elem->NodePrincipal()->Equals(NodePrincipal(), &equal)) && equal) {
82746:       NS_ASSERTION(elem->mDecoder && elem->mDecoder->GetStream(), "Decoder gone");
82746:       return elem;
82746:     }
82746:   }
82746:   return nsnull;
82746: }
82746: 
78417: nsHTMLMediaElement::nsHTMLMediaElement(already_AddRefed<nsINodeInfo> aNodeInfo)
15751:   : nsGenericHTMLElement(aNodeInfo),
26343:     mCurrentLoadID(0),
22787:     mNetworkState(nsIDOMHTMLMediaElement::NETWORK_EMPTY),
22787:     mReadyState(nsIDOMHTMLMediaElement::HAVE_NOTHING),
26343:     mLoadWaitStatus(NOT_WAITING),
25534:     mVolume(1.0),
51477:     mChannels(0),
51477:     mRate(0),
53830:     mPreloadAction(PRELOAD_UNDEFINED),
20627:     mMediaSize(-1,-1),
58179:     mLastCurrentTime(0.0),
77175:     mFragmentStart(-1.0),
77175:     mFragmentEnd(-1.0),
79547:     mAllowAudioData(false),
79547:     mBegun(false),
79547:     mLoadedFirstFrame(false),
79547:     mAutoplaying(true),
79547:     mAutoplayEnabled(true),
79547:     mPaused(true),
79547:     mMuted(false),
79547:     mPlayingBeforeSeek(false),
79547:     mPausedForInactiveDocument(false),
79547:     mWaitingFired(false),
79547:     mIsRunningLoadMethod(false),
79547:     mIsLoadingFromSourceChildren(false),
79547:     mDelayingLoadEvent(false),
79547:     mIsRunningSelectResource(false),
79547:     mSuspendedAfterFirstFrame(false),
79547:     mAllowSuspendAfterFirstFrame(true),
79547:     mHasPlayedOrSeeked(false),
79547:     mHasSelfReference(false),
79547:     mShuttingDown(false),
79547:     mLoadIsSuspended(false),
79547:     mMediaSecurityVerified(false)
15751: {
33372: #ifdef PR_LOGGING
33372:   if (!gMediaElementLog) {
33372:     gMediaElementLog = PR_NewLogModule("nsMediaElement");
33372:   }
33372:   if (!gMediaElementEventsLog) {
33372:     gMediaElementEventsLog = PR_NewLogModule("nsMediaElementEvents");
33372:   }
33372: #endif
33372: 
28108:   RegisterFreezableElement();
34207:   NotifyOwnerDocumentActivityChanged();
15751: }
15751: 
15751: nsHTMLMediaElement::~nsHTMLMediaElement()
15751: {
34207:   NS_ASSERTION(!mHasSelfReference,
34207:                "How can we be destroyed if we're still holding a self reference?");
34207: 
28108:   UnregisterFreezableElement();
20627:   if (mDecoder) {
82746:     RemoveMediaElementFromURITable();
20627:     mDecoder->Shutdown();
20627:   }
87009: 
87009:   NS_ASSERTION(MediaElementTableCount(this, mLoadingSrc) == 0,
87009:     "Destroyed media element should no longer be in element table");
87009: 
22826:   if (mChannel) {
22826:     mChannel->Cancel(NS_BINDING_ABORTED);
22826:   }
51477:   if (mAudioStream) {
51477:     mAudioStream->Shutdown();
51477:   }
15751: }
15751: 
28486: void nsHTMLMediaElement::StopSuspendingAfterFirstFrame()
28486: {
79547:   mAllowSuspendAfterFirstFrame = false;
28486:   if (!mSuspendedAfterFirstFrame)
28486:     return;
79547:   mSuspendedAfterFirstFrame = false;
28486:   if (mDecoder) {
79547:     mDecoder->Resume(true);
28486:   }
28486: }
28486: 
79445: void nsHTMLMediaElement::SetPlayedOrSeeked(bool aValue)
29590: {
82292:   if (aValue == mHasPlayedOrSeeked) {
29590:     return;
82292:   }
29590: 
29590:   mHasPlayedOrSeeked = aValue;
29590: 
29590:   // Force a reflow so that the poster frame hides or shows immediately.
36655:   nsIFrame* frame = GetPrimaryFrame();
82292:   if (!frame) {
82292:     return;
82292:   }
36655:   frame->PresContext()->PresShell()->FrameNeedsReflow(frame,
29590:                                                       nsIPresShell::eTreeChange,
29590:                                                       NS_FRAME_IS_DIRTY);
29590: }
29590: 
22826: NS_IMETHODIMP nsHTMLMediaElement::Play()
15751: {
28486:   StopSuspendingAfterFirstFrame();
79547:   SetPlayedOrSeeked(true);
28486: 
22787:   if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_EMPTY) {
24918:     nsresult rv = Load();
24918:     NS_ENSURE_SUCCESS(rv, rv);
82746:   }
82746:   if (mLoadIsSuspended) {
50948:     ResumeLoad(PRELOAD_ENOUGH);
82746:   }
82746:   // Even if we just did Load() or ResumeLoad(), we could already have a decoder
82746:   // here if we managed to clone an existing decoder.
82746:   if (mDecoder) {
22783:     if (mDecoder->IsEnded()) {
20715:       SetCurrentTime(0);
20715:     }
34207:     if (!mPausedForInactiveDocument) {
24918:       nsresult rv = mDecoder->Play();
24918:       NS_ENSURE_SUCCESS(rv, rv);
24918:     }
34207:   }
20715: 
15751:   // TODO: If the playback has ended, then the user agent must set
25849:   // seek to the effective start.
21357:   // TODO: The playback rate must be set to the default playback rate.
24918:   if (mPaused) {
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("play"));
24918:     switch (mReadyState) {
63619:     case nsIDOMHTMLMediaElement::HAVE_NOTHING:
63619:       DispatchAsyncEvent(NS_LITERAL_STRING("waiting"));
63619:       break;
24918:     case nsIDOMHTMLMediaElement::HAVE_METADATA:
24918:     case nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA:
79547:       FireTimeUpdate(false);
53767:       DispatchAsyncEvent(NS_LITERAL_STRING("waiting"));
24918:       break;
24918:     case nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA:
24918:     case nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA:
53767:       DispatchAsyncEvent(NS_LITERAL_STRING("playing"));
24918:       break;
24918:     }
24918:   }
15751: 
79547:   mPaused = false;
79547:   mAutoplaying = false;
34207:   // We changed mPaused and mAutoplaying which can affect AddRemoveSelfReference
55966:   // and our preload status.
34207:   AddRemoveSelfReference();
55966:   UpdatePreloadAction();
15751: 
15751:   return NS_OK;
15751: }
15751: 
79445: bool nsHTMLMediaElement::ParseAttribute(PRInt32 aNamespaceID,
15751:                                           nsIAtom* aAttribute,
15751:                                           const nsAString& aValue,
15751:                                           nsAttrValue& aResult)
15751: {
50948:   // Mappings from 'preload' attribute strings to an enumeration.
50948:   static const nsAttrValue::EnumTable kPreloadTable[] = {
50948:     { "",         nsHTMLMediaElement::PRELOAD_ATTR_EMPTY },
50948:     { "none",     nsHTMLMediaElement::PRELOAD_ATTR_NONE },
50948:     { "metadata", nsHTMLMediaElement::PRELOAD_ATTR_METADATA },
50948:     { "auto",     nsHTMLMediaElement::PRELOAD_ATTR_AUTO },
50948:     { 0 }
50948:   };
50948: 
15751:   if (aNamespaceID == kNameSpaceID_None) {
82292:     if (ParseImageAttribute(aAttribute, aValue, aResult)) {
79547:       return true;
15751:     }
82292:     if (aAttribute == nsGkAtoms::preload) {
79547:       return aResult.ParseEnumValue(aValue, kPreloadTable, false);
50948:     }
15751:   }
15751: 
15751:   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
15751:                                               aResult);
15751: }
20627: 
84678: void nsHTMLMediaElement::DoneCreatingElement()
84678: {
84678:    if (HasAttr(kNameSpaceID_None, nsGkAtoms::muted))
84678:      mMuted = true; 
84678: }
84678: 
22826: nsresult nsHTMLMediaElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
15751:                                      nsIAtom* aPrefix, const nsAString& aValue,
79445:                                      bool aNotify)
15751: {
15751:   nsresult rv =
15751:     nsGenericHTMLElement::SetAttr(aNameSpaceID, aName, aPrefix, aValue,
15751:                                   aNotify);
50948:   if (NS_FAILED(rv))
50948:     return rv;
51938:   if (aNameSpaceID == kNameSpaceID_None && aName == nsGkAtoms::src) {
51938:     Load();
51938:   }
28486:   if (aNotify && aNameSpaceID == kNameSpaceID_None) {
51938:     if (aName == nsGkAtoms::autoplay) {
28486:       StopSuspendingAfterFirstFrame();
28486:       if (mReadyState == nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA) {
28486:         NotifyAutoplayDataReady();
28486:       }
34207:       // This attribute can affect AddRemoveSelfReference
34207:       AddRemoveSelfReference();
50948:       UpdatePreloadAction();
50948:     } else if (aName == nsGkAtoms::preload) {
50948:       UpdatePreloadAction();
28486:     }
28486:   }
15751: 
15751:   return rv;
15751: }
15751: 
34207: nsresult nsHTMLMediaElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttr,
79445:                                        bool aNotify)
34207: {
34207:   nsresult rv = nsGenericHTMLElement::UnsetAttr(aNameSpaceID, aAttr, aNotify);
50948:   if (NS_FAILED(rv))
50948:     return rv;
34207:   if (aNotify && aNameSpaceID == kNameSpaceID_None) {
34207:     if (aAttr == nsGkAtoms::autoplay) {
34207:       // This attribute can affect AddRemoveSelfReference
34207:       AddRemoveSelfReference();
50948:       UpdatePreloadAction();
50948:     } else if (aAttr == nsGkAtoms::preload) {
50948:       UpdatePreloadAction();
34207:     }
34207:   }
34207: 
34207:   return rv;
34207: }
34207: 
15751: nsresult nsHTMLMediaElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
15751:                                         nsIContent* aBindingParent,
79445:                                         bool aCompileEventHandlers)
15751: {
57359:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument,
57359:                                                  aParent,
57359:                                                  aBindingParent,
57359:                                                  aCompileEventHandlers);
38651:   if (aDocument) {
35581:     mAutoplayEnabled =
57359:       IsAutoplayEnabled() && (!aDocument || !aDocument->IsStaticDocument()) &&
57359:       !IsEditable();
50948:     // The preload action depends on the value of the autoplay attribute.
50948:     // It's value may have changed, so update it.
50948:     UpdatePreloadAction();
82604: 
82604:     if (aDocument->HasAudioAvailableListeners()) {
82604:       // The document already has listeners for the "MozAudioAvailable"
82604:       // event, so the decoder must be notified so it initiates
82604:       // "MozAudioAvailable" event dispatch.
82604:       NotifyAudioAvailableListener();
82604:     }
38651:   }
15751: 
15751:   return rv;
15751: }
15751: 
79445: void nsHTMLMediaElement::UnbindFromTree(bool aDeep,
79445:                                         bool aNullParent)
15751: {
22787:   if (!mPaused && mNetworkState != nsIDOMHTMLMediaElement::NETWORK_EMPTY)
16341:     Pause();
15751:   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
15751: }
15751: 
48220: #ifdef MOZ_RAW
48220: static const char gRawTypes[][16] = {
48220:   "video/x-raw",
48220:   "video/x-raw-yuv"
48220: };
48220: 
48220: static const char* gRawCodecs[] = {
48220:   nsnull
48220: };
48220: 
79445: static bool IsRawEnabled()
48220: {
70840:   return Preferences::GetBool("media.raw.enabled");
48220: }
48220: 
79445: static bool IsRawType(const nsACString& aType)
48220: {
82292:   if (!IsRawEnabled()) {
79547:     return false;
82292:   }
82292: 
80467:   for (PRUint32 i = 0; i < ArrayLength(gRawTypes); ++i) {
82292:     if (aType.EqualsASCII(gRawTypes[i])) {
79547:       return true;
48220:     }
82292:   }
82292: 
79547:   return false;
48220: }
48220: #endif
21079: #ifdef MOZ_OGG
22874: // See http://www.rfc-editor.org/rfc/rfc5334.txt for the definitions
22874: // of Ogg media types and codec types
46997: const char nsHTMLMediaElement::gOggTypes[3][16] = {
21079:   "video/ogg",
21079:   "audio/ogg",
21079:   "application/ogg"
21079: };
15751: 
46997: char const *const nsHTMLMediaElement::gOggCodecs[3] = {
22874:   "vorbis",
22874:   "theora",
22874:   nsnull
22874: };
22874: 
46997: bool
46997: nsHTMLMediaElement::IsOggEnabled()
22724: {
70840:   return Preferences::GetBool("media.ogg.enabled");
22724: }
22724: 
46997: bool
46997: nsHTMLMediaElement::IsOggType(const nsACString& aType)
21079: {
82292:   if (!IsOggEnabled()) {
79547:     return false;
82292:   }
82292: 
80467:   for (PRUint32 i = 0; i < ArrayLength(gOggTypes); ++i) {
82292:     if (aType.EqualsASCII(gOggTypes[i])) {
79547:       return true;
21079:     }
82292:   }
82292: 
79547:   return false;
21079: }
21079: #endif
21079: 
21394: #ifdef MOZ_WAVE
22874: // See http://www.rfc-editor.org/rfc/rfc2361.txt for the definitions
22874: // of WAVE media types and codec types. However, the audio/vnd.wave
22874: // MIME type described there is not used.
46997: const char nsHTMLMediaElement::gWaveTypes[4][16] = {
21394:   "audio/x-wav",
21394:   "audio/wav",
21394:   "audio/wave",
21394:   "audio/x-pn-wav"
21394: };
21394: 
46997: char const *const nsHTMLMediaElement::gWaveCodecs[2] = {
22874:   "1", // Microsoft PCM Format
22874:   nsnull
22874: };
22874: 
46997: bool
46997: nsHTMLMediaElement::IsWaveEnabled()
22724: {
70840:   return Preferences::GetBool("media.wave.enabled");
22724: }
22724: 
46997: bool
46997: nsHTMLMediaElement::IsWaveType(const nsACString& aType)
21394: {
82292:   if (!IsWaveEnabled()) {
79547:     return false;
82292:   }
82292: 
80467:   for (PRUint32 i = 0; i < ArrayLength(gWaveTypes); ++i) {
82292:     if (aType.EqualsASCII(gWaveTypes[i])) {
79547:       return true;
21394:     }
82292:   }
82292: 
79547:   return false;
21394: }
21394: #endif
21394: 
43339: #ifdef MOZ_WEBM
46997: const char nsHTMLMediaElement::gWebMTypes[2][17] = {
43339:   "video/webm",
43339:   "audio/webm"
43339: };
43339: 
46997: char const *const nsHTMLMediaElement::gWebMCodecs[4] = {
43339:   "vp8",
43339:   "vp8.0",
43339:   "vorbis",
43339:   nsnull
43339: };
43339: 
46997: bool
46997: nsHTMLMediaElement::IsWebMEnabled()
43339: {
70840:   return Preferences::GetBool("media.webm.enabled");
43339: }
43339: 
46997: bool
46997: nsHTMLMediaElement::IsWebMType(const nsACString& aType)
43339: {
82292:   if (!IsWebMEnabled()) {
79547:     return false;
82292:   }
82292: 
80467:   for (PRUint32 i = 0; i < ArrayLength(gWebMTypes); ++i) {
82292:     if (aType.EqualsASCII(gWebMTypes[i])) {
79547:       return true;
43339:     }
82292:   }
82292: 
79547:   return false;
43339: }
43339: #endif
43339: 
21079: /* static */
43339: nsHTMLMediaElement::CanPlayStatus 
43339: nsHTMLMediaElement::CanHandleMediaType(const char* aMIMEType,
46997:                                        char const *const ** aCodecList)
21079: {
48220: #ifdef MOZ_RAW
48220:   if (IsRawType(nsDependentCString(aMIMEType))) {
48220:     *aCodecList = gRawCodecs;
48220:     return CANPLAY_MAYBE;
48220:   }
48220: #endif
21079: #ifdef MOZ_OGG
22874:   if (IsOggType(nsDependentCString(aMIMEType))) {
22874:     *aCodecList = gOggCodecs;
43339:     return CANPLAY_MAYBE;
22874:   }
21079: #endif
21394: #ifdef MOZ_WAVE
22874:   if (IsWaveType(nsDependentCString(aMIMEType))) {
22874:     *aCodecList = gWaveCodecs;
43339:     return CANPLAY_MAYBE;
22874:   }
21394: #endif
43339: #ifdef MOZ_WEBM
43339:   if (IsWebMType(nsDependentCString(aMIMEType))) {
43339:     *aCodecList = gWebMCodecs;
43339:     return CANPLAY_YES;
43339:   }
43339: #endif
43339:   return CANPLAY_NO;
21079: }
21079: 
28759: /* static */
79445: bool nsHTMLMediaElement::ShouldHandleMediaType(const char* aMIMEType)
28759: {
48220: #ifdef MOZ_RAW
48220:   if (IsRawType(nsDependentCString(aMIMEType)))
79547:     return true;
48220: #endif
28759: #ifdef MOZ_OGG
28759:   if (IsOggType(nsDependentCString(aMIMEType)))
79547:     return true;
28759: #endif
43339: #ifdef MOZ_WEBM
43339:   if (IsWebMType(nsDependentCString(aMIMEType)))
79547:     return true;
43339: #endif
28759:   // We should not return true for Wave types, since there are some
28759:   // Wave codecs actually in use in the wild that we don't support, and
28759:   // we should allow those to be handled by plugins or helper apps.
28759:   // Furthermore people can play Wave files on most platforms by other
28759:   // means.
79547:   return false;
28759: }
28759: 
79445: static bool
46997: CodecListContains(char const *const * aCodecs, const nsAString& aCodec)
22874: {
22874:   for (PRInt32 i = 0; aCodecs[i]; ++i) {
22874:     if (aCodec.EqualsASCII(aCodecs[i]))
79547:       return true;
22874:   }
79547:   return false;
22874: }
22874: 
43339: /* static */
43339: nsHTMLMediaElement::CanPlayStatus
43339: nsHTMLMediaElement::GetCanPlay(const nsAString& aType)
22874: {
22874:   nsContentTypeParser parser(aType);
22874:   nsAutoString mimeType;
22874:   nsresult rv = parser.GetType(mimeType);
22874:   if (NS_FAILED(rv))
22874:     return CANPLAY_NO;
22874: 
22874:   NS_ConvertUTF16toUTF8 mimeTypeUTF8(mimeType);
46997:   char const *const * supportedCodecs;
43339:   CanPlayStatus status = CanHandleMediaType(mimeTypeUTF8.get(),
43339:                                             &supportedCodecs);
43339:   if (status == CANPLAY_NO)
22874:     return CANPLAY_NO;
22874: 
22874:   nsAutoString codecs;
22874:   rv = parser.GetParameter("codecs", codecs);
43339:   if (NS_FAILED(rv)) {
22874:     // Parameter not found or whatever
43339:     return status;
43339:   }
22874: 
22874:   CanPlayStatus result = CANPLAY_YES;
22874:   // See http://www.rfc-editor.org/rfc/rfc4281.txt for the description
22874:   // of the 'codecs' parameter
41766:   nsCharSeparatedTokenizer tokenizer(codecs, ',');
79445:   bool expectMoreTokens = false;
22874:   while (tokenizer.hasMoreTokens()) {
22874:     const nsSubstring& token = tokenizer.nextToken();
22874: 
30693:     if (!CodecListContains(supportedCodecs, token)) {
22874:       // Totally unsupported codec
22874:       return CANPLAY_NO;
22874:     }
41764:     expectMoreTokens = tokenizer.lastTokenEndedWithSeparator();
22874:   }
22874:   if (expectMoreTokens) {
22874:     // Last codec name was empty
22874:     return CANPLAY_NO;
22874:   }
22874:   return result;
22874: }
22874: 
22874: NS_IMETHODIMP
22874: nsHTMLMediaElement::CanPlayType(const nsAString& aType, nsAString& aResult)
22874: {
22874:   switch (GetCanPlay(aType)) {
82292:   case CANPLAY_NO:
82292:     aResult.Truncate();
82292:     break;
82292:   case CANPLAY_YES:
82292:     aResult.AssignLiteral("probably");
82292:     break;
22874:   default:
82292:   case CANPLAY_MAYBE:
82292:     aResult.AssignLiteral("maybe");
82292:     break;
22874:   }
22874:   return NS_OK;
22874: }
22874: 
34207: already_AddRefed<nsMediaDecoder>
34207: nsHTMLMediaElement::CreateDecoder(const nsACString& aType)
21079: {
48220: #ifdef MOZ_RAW
48220:   if (IsRawType(aType)) {
48220:     nsRefPtr<nsRawDecoder> decoder = new nsRawDecoder();
82292:     if (decoder->Init(this)) {
82292:       return decoder.forget();
48220:     }
48220:   }
48220: #endif
21079: #ifdef MOZ_OGG
21079:   if (IsOggType(aType)) {
34207:     nsRefPtr<nsOggDecoder> decoder = new nsOggDecoder();
82292:     if (decoder->Init(this)) {
82292:       return decoder.forget();
21079:     }
21079:   }
21079: #endif
21394: #ifdef MOZ_WAVE
21394:   if (IsWaveType(aType)) {
34207:     nsRefPtr<nsWaveDecoder> decoder = new nsWaveDecoder();
82292:     if (decoder->Init(this)) {
82292:       return decoder.forget();
21394:     }
21394:   }
21394: #endif
43339: #ifdef MOZ_WEBM
43339:   if (IsWebMType(aType)) {
43339:     nsRefPtr<nsWebMDecoder> decoder = new nsWebMDecoder();
82292:     if (decoder->Init(this)) {
82292:       return decoder.forget();
43339:     }
43339:   }
43339: #endif
34207:   return nsnull;
21079: }
21079: 
32901: nsresult nsHTMLMediaElement::InitializeDecoderAsClone(nsMediaDecoder* aOriginal)
32901: {
82746:   NS_ASSERTION(mLoadingSrc, "mLoadingSrc must already be set");
87009:   NS_ASSERTION(mDecoder == nsnull, "Shouldn't have a decoder");
82746: 
82745:   nsMediaStream* originalStream = aOriginal->GetStream();
32901:   if (!originalStream)
32901:     return NS_ERROR_FAILURE;
34207:   nsRefPtr<nsMediaDecoder> decoder = aOriginal->Clone();
34207:   if (!decoder)
32901:     return NS_ERROR_FAILURE;
32901: 
34207:   LOG(PR_LOG_DEBUG, ("%p Cloned decoder %p from %p", this, decoder.get(), aOriginal));
33372: 
34207:   if (!decoder->Init(this)) {
87634:     LOG(PR_LOG_DEBUG, ("%p Failed to init cloned decoder %p", this, decoder.get()));
32901:     return NS_ERROR_FAILURE;
32901:   }
32901: 
60727:   double duration = aOriginal->GetDuration();
33856:   if (duration >= 0) {
68450:     decoder->SetDuration(duration);
75108:     decoder->SetSeekable(aOriginal->IsSeekable());
33856:   }
33856: 
34207:   nsMediaStream* stream = originalStream->CloneData(decoder);
32901:   if (!stream) {
87634:     LOG(PR_LOG_DEBUG, ("%p Failed to cloned stream for decoder %p", this, decoder.get()));
32901:     return NS_ERROR_FAILURE;
32901:   }
32901: 
32901:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADING;
32901: 
54993:   nsresult rv = decoder->Load(stream, nsnull, aOriginal);
32901:   if (NS_FAILED(rv)) {
87634:     LOG(PR_LOG_DEBUG, ("%p Failed to load decoder/stream for decoder %p", this, decoder.get()));
32901:     return rv;
32901:   }
32901: 
34207:   return FinishDecoderSetup(decoder);
32901: }
32901: 
21079: nsresult nsHTMLMediaElement::InitializeDecoderForChannel(nsIChannel *aChannel,
21079:                                                          nsIStreamListener **aListener)
21079: {
82746:   NS_ASSERTION(mLoadingSrc, "mLoadingSrc must already be set");
87009:   NS_ASSERTION(mDecoder == nsnull, "Shouldn't have a decoder");
82746: 
21079:   nsCAutoString mimeType;
21079:   aChannel->GetContentType(mimeType);
21079: 
34207:   nsRefPtr<nsMediaDecoder> decoder = CreateDecoder(mimeType);
34207:   if (!decoder) {
86044:     nsAutoString src;
86044:     GetCurrentSrc(src);
86044:     NS_ConvertUTF8toUTF16 mimeUTF16(mimeType);
86044:     const PRUnichar* params[] = { mimeUTF16.get(), src.get() };
86044:     ReportLoadError("MediaLoadUnsupportedMimeType", params, ArrayLength(params));
21079:     return NS_ERROR_FAILURE;
34207:   }
21079: 
34207:   LOG(PR_LOG_DEBUG, ("%p Created decoder %p for type %s", this, decoder.get(), mimeType.get()));
33372: 
22787:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADING;
21079: 
34207:   nsMediaStream* stream = nsMediaStream::Create(decoder, aChannel);
32900:   if (!stream)
32900:     return NS_ERROR_OUT_OF_MEMORY;
32900: 
54993:   nsresult rv = decoder->Load(stream, aListener, nsnull);
32901:   if (NS_FAILED(rv)) {
24918:     return rv;
32901:   }
24918: 
32900:   // Decoder successfully created, the decoder now owns the nsMediaStream
32900:   // which owns the channel.
27217:   mChannel = nsnull;
27217: 
34207:   return FinishDecoderSetup(decoder);
32901: }
32901: 
34207: nsresult nsHTMLMediaElement::FinishDecoderSetup(nsMediaDecoder* aDecoder)
32901: {
82746:   NS_ASSERTION(mLoadingSrc, "mLoadingSrc set up");
82746: 
83059:   nsCAutoString src;
83059:   GetCurrentSpec(src);
84370:   printf("*** nsHTMLElement::FinishDecoderSetup() mDecoder=%p stream=%p src=%s\n",
84370:          aDecoder, aDecoder->GetStream(), src.get());
34207:   mDecoder = aDecoder;
82746:   AddMediaElementToURITable();
51938: 
51477:   // Force a same-origin check before allowing events for this media resource.
79547:   mMediaSecurityVerified = false;
51477: 
34207:   // The new stream has not been suspended by us.
79547:   mPausedForInactiveDocument = false;
34207:   // But we may want to suspend it now.
34207:   // This will also do an AddRemoveSelfReference.
34207:   NotifyOwnerDocumentActivityChanged();
34207: 
32901:   nsresult rv = NS_OK;
32901: 
25534:   mDecoder->SetVolume(mMuted ? 0.0 : mVolume);
25534: 
24918:   if (!mPaused) {
79547:     SetPlayedOrSeeked(true);
34207:     if (!mPausedForInactiveDocument) {
24918:       rv = mDecoder->Play();
24918:     }
34207:   }
24918: 
82604:   if (OwnerDoc()->HasAudioAvailableListeners()) {
82604:     NotifyAudioAvailableListener();
82604:   }
82604: 
87009:   if (NS_FAILED(rv)) {
87009:     RemoveMediaElementFromURITable();
87009:     mDecoder->Shutdown();
87009:     mDecoder = nsnull;
87009:   }
87009: 
87009:   NS_ASSERTION(NS_SUCCEEDED(rv) == (MediaElementTableCount(this, mLoadingSrc) == 1),
87009:     "Media element should have single table entry if decode initialized");
87009: 
79547:   mBegun = true;
24918:   return rv;
21079: }
21079: 
22826: nsresult nsHTMLMediaElement::NewURIFromString(const nsAutoString& aURISpec, nsIURI** aURI)
15751: {
22826:   NS_ENSURE_ARG_POINTER(aURI);
22826: 
22826:   *aURI = nsnull;
22826: 
80526:   nsCOMPtr<nsIDocument> doc = OwnerDoc();
22826: 
22826:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
82292:   nsCOMPtr<nsIURI> uri;
82292:   nsresult rv = nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(uri),
22826:                                                           aURISpec,
22826:                                                           doc,
22826:                                                           baseURI);
22826:   NS_ENSURE_SUCCESS(rv, rv);
22826: 
79445:   bool equal;
22826:   if (aURISpec.IsEmpty() &&
22826:       doc->GetDocumentURI() &&
82292:       NS_SUCCEEDED(doc->GetDocumentURI()->Equals(uri, &equal)) &&
22826:       equal) {
22826:     // It's not possible for a media resource to be embedded in the current
22826:     // document we extracted aURISpec from, so there's no point returning
22826:     // the current document URI just to let the caller attempt and fail to
22826:     // decode it.
22826:     return NS_ERROR_DOM_INVALID_STATE_ERR;
22826:   }
22826: 
82292:   uri.forget(aURI);
22826:   return NS_OK;
22826: }
22826: 
77175: void nsHTMLMediaElement::ProcessMediaFragmentURI()
77175: {
77175:   nsCAutoString ref;
77175:   GetCurrentSpec(ref);
77175:   nsMediaFragmentURIParser parser(ref);
77175:   parser.Parse();
77175:   double start = parser.GetStartTime();
77175:   if (mDecoder) {
77175:     double end = parser.GetEndTime();
77175:     if (end < 0.0 || end > start) {
77175:       mFragmentEnd = end;
77175:     }
77175:     else {
77175:       start = -1.0;
77175:       end = -1.0;
77175:     }
77175:   }
77175:   if (start > 0.0) {
77175:     SetCurrentTime(start);
77175:     mFragmentStart = start;
77175:   }
77175: }
77175: 
51477: void nsHTMLMediaElement::MetadataLoaded(PRUint32 aChannels, PRUint32 aRate)
15751: {
51477:   mChannels = aChannels;
51477:   mRate = aRate;
22787:   ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_METADATA);
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("durationchange"));
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("loadedmetadata"));
77175:   if (mDecoder && mDecoder->IsSeekable()) {
77175:     ProcessMediaFragmentURI();
77175:     mDecoder->SetEndTime(mFragmentEnd);
77175:   }
15751: }
15751: 
79445: void nsHTMLMediaElement::FirstFrameLoaded(bool aResourceFullyLoaded)
15751: {
69729:   ChangeReadyState(aResourceFullyLoaded ?
69729:     nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA :
69729:     nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA);
79547:   ChangeDelayLoadStatus(false);
28486: 
28486:   NS_ASSERTION(!mSuspendedAfterFirstFrame, "Should not have already suspended");
28486: 
28486:   if (mDecoder && mAllowSuspendAfterFirstFrame && mPaused &&
28528:       !aResourceFullyLoaded &&
28486:       !HasAttr(kNameSpaceID_None, nsGkAtoms::autoplay) &&
50948:       mPreloadAction == nsHTMLMediaElement::PRELOAD_METADATA) {
79547:     mSuspendedAfterFirstFrame = true;
28486:     mDecoder->Suspend();
28486:   }
15751: }
15751: 
15751: void nsHTMLMediaElement::ResourceLoaded()
15751: {
79547:   mBegun = false;
33866:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_IDLE;
34207:   AddRemoveSelfReference();
69476:   if (mReadyState >= nsIDOMHTMLMediaElement::HAVE_METADATA) {
22787:     ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA);
69476:   }
51938:   // Ensure a progress event is dispatched at the end of download.
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("progress"));
51938:   // The download has stopped.
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("suspend"));
15751: }
15751: 
15751: void nsHTMLMediaElement::NetworkError()
15751: {
51938:   Error(nsIDOMMediaError::MEDIA_ERR_NETWORK);
15751: }
15751: 
32934: void nsHTMLMediaElement::DecodeError()
32934: {
86044:   nsAutoString src;
86044:   GetCurrentSrc(src);
86044:   const PRUnichar* params[] = { src.get() };
86044:   ReportLoadError("MediaLoadDecodeError", params, ArrayLength(params));
86044: 
54995:   if (mDecoder) {
82746:     RemoveMediaElementFromURITable();
54995:     mDecoder->Shutdown();
54995:     mDecoder = nsnull;
54995:   }
82746:   mLoadingSrc = nsnull;
73701:   if (mIsLoadingFromSourceChildren) {
54995:     mError = nsnull;
69107:     if (mSourceLoadCandidate) {
54995:       DispatchAsyncSourceError(mSourceLoadCandidate);
54995:       QueueLoadFromSourceTask();
54995:     } else {
69107:       NS_WARNING("Should know the source we were loading from!");
69107:     }
69107:   } else {
51938:     Error(nsIDOMMediaError::MEDIA_ERR_DECODE);
51938:   }
54995: }
51938: 
51938: void nsHTMLMediaElement::LoadAborted()
51938: {
51938:   Error(nsIDOMMediaError::MEDIA_ERR_ABORTED);
51938: }
51938: 
51938: void nsHTMLMediaElement::Error(PRUint16 aErrorCode)
51938: {
51938:   NS_ASSERTION(aErrorCode == nsIDOMMediaError::MEDIA_ERR_DECODE ||
51938:                aErrorCode == nsIDOMMediaError::MEDIA_ERR_NETWORK ||
51938:                aErrorCode == nsIDOMMediaError::MEDIA_ERR_ABORTED,
51938:                "Only use nsIDOMMediaError codes!");
51938:   mError = new nsMediaError(aErrorCode);
79547:   mBegun = false;
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("error"));
51938:   if (mReadyState == nsIDOMHTMLMediaElement::HAVE_NOTHING) {
32934:     mNetworkState = nsIDOMHTMLMediaElement::NETWORK_EMPTY;
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("emptied"));
51938:   } else {
51938:     mNetworkState = nsIDOMHTMLMediaElement::NETWORK_IDLE;
51938:   }
34207:   AddRemoveSelfReference();
79547:   ChangeDelayLoadStatus(false);
32934: }
32934: 
20627: void nsHTMLMediaElement::PlaybackEnded()
15751: {
22783:   NS_ASSERTION(mDecoder->IsEnded(), "Decoder fired ended, but not in ended state");
34207:   // We changed the state of IsPlaybackEnded which can affect AddRemoveSelfReference
34207:   AddRemoveSelfReference();
34207: 
74647:   if (mDecoder && mDecoder->IsInfinite()) {
74647:     LOG(PR_LOG_DEBUG, ("%p, got duration by reaching the end of the stream", this));
74647:     DispatchAsyncEvent(NS_LITERAL_STRING("durationchange"));
74647:   }
74647: 
82534:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::loop)) {
82534:     SetCurrentTime(0);
82534:     return;
82534:   }
82534: 
79547:   FireTimeUpdate(false);
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("ended"));
15751: }
15751: 
20627: void nsHTMLMediaElement::SeekStarted()
20627: {
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("seeking"));
79547:   FireTimeUpdate(false);
20627: }
20627: 
20627: void nsHTMLMediaElement::SeekCompleted()
20627: {
79547:   mPlayingBeforeSeek = false;
79547:   SetPlayedOrSeeked(true);
53767:   DispatchAsyncEvent(NS_LITERAL_STRING("seeked"));
34207:   // We changed whether we're seeking so we need to AddRemoveSelfReference
34207:   AddRemoveSelfReference();
20627: }
20627: 
28488: void nsHTMLMediaElement::DownloadSuspended()
28488: {
74296:   DispatchAsyncEvent(NS_LITERAL_STRING("progress"));
28488:   if (mBegun) {
28488:     mNetworkState = nsIDOMHTMLMediaElement::NETWORK_IDLE;
34207:     AddRemoveSelfReference();
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("suspend"));
28488:   }
28488: }
28488: 
28488: void nsHTMLMediaElement::DownloadResumed()
28488: {
28488:   if (mBegun) {
28488:     mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADING;
34207:     AddRemoveSelfReference();
28488:   }
28488: }
28488: 
28488: void nsHTMLMediaElement::DownloadStalled()
28488: {
28488:   if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_LOADING) {
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("stalled"));
28488:   }
28488: }
28488: 
79445: bool nsHTMLMediaElement::ShouldCheckAllowOrigin()
24155: {
79445:   return Preferences::GetBool("media.enforce_same_site_origin", true);
24155: }
24155: 
24919: void nsHTMLMediaElement::UpdateReadyStateForData(NextFrameStatus aNextFrame)
24721: {
24721:   if (mReadyState < nsIDOMHTMLMediaElement::HAVE_METADATA) {
26836:     // aNextFrame might have a next frame because the decoder can advance
26836:     // on its own thread before ResourceLoaded or MetadataLoaded gets
26836:     // a chance to run.
26836:     // The arrival of more data can't change us out of this readyState.
24721:     return;
24721:   }
24721: 
28525:   if (aNextFrame != NEXT_FRAME_AVAILABLE) {
24721:     ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA);
24919:     if (!mWaitingFired && aNextFrame == NEXT_FRAME_UNAVAILABLE_BUFFERING) {
79547:       FireTimeUpdate(false);
53767:       DispatchAsyncEvent(NS_LITERAL_STRING("waiting"));
79547:       mWaitingFired = true;
24919:     }
24721:     return;
24721:   }
24721: 
28567:   // Now see if we should set HAVE_ENOUGH_DATA.
24721:   // If it's something we don't know the size of, then we can't
28567:   // make a real estimate, so we go straight to HAVE_ENOUGH_DATA once
28567:   // we've downloaded enough data that our download rate is considered
28567:   // reliable. We have to move to HAVE_ENOUGH_DATA at some point or
48104:   // autoplay elements for live streams will never play. Otherwise we
48104:   // move to HAVE_ENOUGH_DATA if we can play through the entire media
48104:   // without stopping to buffer.
48104:   nsMediaDecoder::Statistics stats = mDecoder->GetStatistics();
28567:   if (stats.mTotalBytes < 0 ? stats.mDownloadRateReliable :
48104:                               stats.mTotalBytes == stats.mDownloadPosition ||
48104:       mDecoder->CanPlayThrough())
48104:   {
24721:     ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA);
24721:     return;
24721:   }
24721:   ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA);
24721: }
24721: 
33372: #ifdef PR_LOGGING
26326: static const char* gReadyStateToString[] = {
26326:   "HAVE_NOTHING",
26326:   "HAVE_METADATA",
26326:   "HAVE_CURRENT_DATA",
26326:   "HAVE_FUTURE_DATA",
26326:   "HAVE_ENOUGH_DATA"
26326: };
26326: #endif
26326: 
15751: void nsHTMLMediaElement::ChangeReadyState(nsMediaReadyState aState)
15751: {
24721:   nsMediaReadyState oldState = mReadyState;
26326:   mReadyState = aState;
26326: 
26326:   if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_EMPTY ||
26326:       oldState == mReadyState) {
26326:     return;
26326:   }
26326: 
33372:   LOG(PR_LOG_DEBUG, ("%p Ready state changed to %s", this, gReadyStateToString[aState]));
24721: 
22787:   // Handle raising of "waiting" event during seek (see 4.8.10.9)
26326:   if (mPlayingBeforeSeek &&
26326:       oldState < nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA) {
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("waiting"));
24721:   }
20627: 
26326:   if (oldState < nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA &&
26326:       mReadyState >= nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA &&
26326:       !mLoadedFirstFrame)
26326:   {
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("loadeddata"));
79547:     mLoadedFirstFrame = true;
24721:   }
15751: 
26326:   if (mReadyState == nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA) {
79547:     mWaitingFired = false;
24721:   }
15751: 
26326:   if (oldState < nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA &&
26326:       mReadyState >= nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA) {
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("canplay"));
24721:   }
26326: 
26836:   if (mReadyState == nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA) {
26836:     NotifyAutoplayDataReady();
15751:   }
26326: 
26326:   if (oldState < nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA &&
26326:       mReadyState >= nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA &&
24721:       IsPotentiallyPlaying()) {
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("playing"));
24721:   }
26326: 
26326:   if (oldState < nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA &&
26326:       mReadyState >= nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA) {
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("canplaythrough"));
24918:   }
15751: }
15751: 
79445: bool nsHTMLMediaElement::CanActivateAutoplay()
34207: {
34207:   return mAutoplaying &&
34207:          mPaused &&
34207:          HasAttr(kNameSpaceID_None, nsGkAtoms::autoplay) &&
57359:          mAutoplayEnabled &&
57359:          !IsEditable();
34207: }
34207: 
26836: void nsHTMLMediaElement::NotifyAutoplayDataReady()
26836: {
34207:   if (CanActivateAutoplay()) {
79547:     mPaused = false;
34207:     // We changed mPaused which can affect AddRemoveSelfReference
34207:     AddRemoveSelfReference();
34207: 
26836:     if (mDecoder) {
79547:       SetPlayedOrSeeked(true);
26836:       mDecoder->Play();
26836:     }
53767:     DispatchAsyncEvent(NS_LITERAL_STRING("play"));
26836:   }
26836: }
26836: 
39499: ImageContainer* nsHTMLMediaElement::GetImageContainer()
39499: {
39499:   if (mImageContainer)
39499:     return mImageContainer;
39499: 
39499:   // If we have a print surface, this is just a static image so
39499:   // no image container is required
39499:   if (mPrintSurface)
39499:     return nsnull;
39499: 
39499:   // Only video frames need an image container.
77547:   nsCOMPtr<nsIDOMHTMLVideoElement> video = do_QueryObject(this);
39499:   if (!video)
39499:     return nsnull;
39499: 
58813:   nsRefPtr<LayerManager> manager =
80526:     nsContentUtils::PersistentLayerManagerForDocument(OwnerDoc());
39499:   if (!manager)
39499:     return nsnull;
39499: 
39499:   mImageContainer = manager->CreateImageContainer();
69765:   if (manager->IsCompositingCheap()) {
79547:     mImageContainer->SetDelayedConversion(true);
69765:   }
39499:   return mImageContainer;
35581: }
15751: 
51477: nsresult nsHTMLMediaElement::DispatchAudioAvailableEvent(float* aFrameBuffer,
51477:                                                          PRUint32 aFrameBufferLength,
54997:                                                          float aTime)
51477: {
52051:   // Auto manage the memory for the frame buffer. If we fail and return
52051:   // an error, this ensures we free the memory in the frame buffer. Otherwise
52051:   // we hand off ownership of the frame buffer to the audioavailable event,
52051:   // which frees the memory when it's destroyed.
52051:   nsAutoArrayPtr<float> frameBuffer(aFrameBuffer);
52051: 
80526:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(OwnerDoc());
77547:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryObject(this));
70359:   NS_ENSURE_TRUE(domDoc && target, NS_ERROR_INVALID_ARG);
51477: 
51477:   nsCOMPtr<nsIDOMEvent> event;
70359:   nsresult rv = domDoc->CreateEvent(NS_LITERAL_STRING("MozAudioAvailableEvent"),
51477:                                     getter_AddRefs(event));
51477:   nsCOMPtr<nsIDOMNotifyAudioAvailableEvent> audioavailableEvent(do_QueryInterface(event));
51477:   NS_ENSURE_SUCCESS(rv, rv);
51477: 
51477:   rv = audioavailableEvent->InitAudioAvailableEvent(NS_LITERAL_STRING("MozAudioAvailable"),
79547:                                                     true, true, frameBuffer.forget(), aFrameBufferLength,
54997:                                                     aTime, mAllowAudioData);
51477:   NS_ENSURE_SUCCESS(rv, rv);
51477: 
79445:   bool dummy;
51477:   return target->DispatchEvent(event, &dummy);
51477: }
51477: 
53767: nsresult nsHTMLMediaElement::DispatchEvent(const nsAString& aName)
15751: {
53767:   LOG_EVENT(PR_LOG_DEBUG, ("%p Dispatching event %s", this,
33372:                           NS_ConvertUTF16toUTF8(aName).get()));
33372: 
53769:   // Save events that occur while in the bfcache. These will be dispatched
53769:   // if the page comes out of the bfcache.
53769:   if (mPausedForInactiveDocument) {
53769:     mPendingEvents.AppendElement(aName);
53769:     return NS_OK;
53769:   }
53769: 
80526:   return nsContentUtils::DispatchTrustedEvent(OwnerDoc(),
15751:                                               static_cast<nsIContent*>(this),
15751:                                               aName,
79547:                                               false,
79547:                                               true);
15751: }
15751: 
53767: nsresult nsHTMLMediaElement::DispatchAsyncEvent(const nsAString& aName)
15751: {
53767:   LOG_EVENT(PR_LOG_DEBUG, ("%p Queuing event %s", this,
53767:             NS_ConvertUTF16toUTF8(aName).get()));
52464: 
53767:   nsCOMPtr<nsIRunnable> event = new nsAsyncEventRunner(aName, this);
52464:   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
52464:   return NS_OK;
52464: }
52464: 
53769: nsresult nsHTMLMediaElement::DispatchPendingMediaEvents()
53769: {
53769:   NS_ASSERTION(!mPausedForInactiveDocument,
53769:                "Must not be in bfcache when dispatching pending media events");
53769: 
53769:   PRUint32 count = mPendingEvents.Length();
53769:   for (PRUint32 i = 0; i < count; ++i) {
53769:     DispatchAsyncEvent(mPendingEvents[i]);
53769:   }
53769:   mPendingEvents.Clear();
53769: 
53769:   return NS_OK;
53769: }
53769: 
79445: bool nsHTMLMediaElement::IsPotentiallyPlaying() const
20627: {
20627:   // TODO:
20627:   //   playback has not stopped due to errors,
20627:   //   and the element has not paused for user interaction
20627:   return
20627:     !mPaused &&
22787:     (mReadyState == nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA ||
22787:     mReadyState == nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA) &&
20627:     !IsPlaybackEnded();
20627: }
22783: 
79445: bool nsHTMLMediaElement::IsPlaybackEnded() const
20627: {
20627:   // TODO:
25849:   //   the current playback position is equal to the effective end of the media resource.
20627:   //   See bug 449157.
22787:   return mNetworkState >= nsIDOMHTMLMediaElement::HAVE_METADATA &&
79547:     mDecoder ? mDecoder->IsEnded() : false;
20627: }
20627: 
26836: already_AddRefed<nsIPrincipal> nsHTMLMediaElement::GetCurrentPrincipal()
18910: {
18910:   if (!mDecoder)
18910:     return nsnull;
18910: 
18910:   return mDecoder->GetCurrentPrincipal();
18910: }
19770: 
20627: void nsHTMLMediaElement::UpdateMediaSize(nsIntSize size)
20627: {
20627:   mMediaSize = size;
20627: }
20627: 
34207: void nsHTMLMediaElement::NotifyOwnerDocumentActivityChanged()
19770: {
80526:   nsIDocument* ownerDoc = OwnerDoc();
34207:   // Don't pause if we have no ownerDoc. Something native must have created
34207:   // us and be expecting us to work without a document.
79445:   bool pauseForInactiveDocument =
80527:     !ownerDoc->IsActive() || !ownerDoc->IsVisible();
34207: 
34207:   if (pauseForInactiveDocument != mPausedForInactiveDocument) {
34207:     mPausedForInactiveDocument = pauseForInactiveDocument;
19770:     if (mDecoder) {
34207:       if (pauseForInactiveDocument) {
34207:         mDecoder->Pause();
34207:         mDecoder->Suspend();
34207:       } else {
79547:         mDecoder->Resume(false);
53769:         DispatchPendingMediaEvents();
36909:         if (!mPaused && !mDecoder->IsEnded()) {
34207:           mDecoder->Play();
19770:         }
22826:       }
34207:     }
19770:   }
21006: 
34207:   AddRemoveSelfReference();
21006: }
21006: 
34207: void nsHTMLMediaElement::AddRemoveSelfReference()
21006: {
34207:   // XXX we could release earlier here in many situations if we examined
34207:   // which event listeners are attached. Right now we assume there is a
34207:   // potential listener for every event. We would also have to keep the
34207:   // element alive if it was playing and producing audio output --- right now
34207:   // that's covered by the !mPaused check.
80526:   nsIDocument* ownerDoc = OwnerDoc();
34207: 
34207:   // See the comment at the top of this file for the explanation of this
34207:   // boolean expression.
79445:   bool needSelfReference = !mShuttingDown &&
80527:     ownerDoc->IsActive() &&
34207:     (mDelayingLoadEvent ||
34207:      (!mPaused && mDecoder && !mDecoder->IsEnded()) ||
34207:      (mDecoder && mDecoder->IsSeeking()) ||
34207:      CanActivateAutoplay() ||
34207:      mNetworkState == nsIDOMHTMLMediaElement::NETWORK_LOADING);
34207: 
34207:   if (needSelfReference != mHasSelfReference) {
34207:     mHasSelfReference = needSelfReference;
34207:     if (needSelfReference) {
38651:       // The observer service will hold a strong reference to us. This
38651:       // will do to keep us alive. We need to know about shutdown so that
38651:       // we can release our self-reference.
38651:       nsContentUtils::RegisterShutdownObserver(this);
34207:     } else {
34207:       // Dispatch Release asynchronously so that we don't destroy this object
34207:       // inside a call stack of method calls on this object
34207:       nsCOMPtr<nsIRunnable> event =
41361:         NS_NewRunnableMethod(this, &nsHTMLMediaElement::DoRemoveSelfReference);
34207:       NS_DispatchToMainThread(event);
21006:     }
21006:   }
24020: }
25018: 
38651: void nsHTMLMediaElement::DoRemoveSelfReference()
38651: {
38651:   // We don't need the shutdown observer anymore. Unregistering releases
38651:   // its reference to us, which we were using as our self-reference.
38651:   nsContentUtils::UnregisterShutdownObserver(this);
38651: }
38651: 
38651: nsresult nsHTMLMediaElement::Observe(nsISupports* aSubject,
38651:                                      const char* aTopic, const PRUnichar* aData)
38651: {
62475:   NS_ENSURE_TRUE(nsContentUtils::IsCallerChrome(), NS_ERROR_NOT_AVAILABLE);
62475:   
38651:   if (strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID) == 0) {
79547:     mShuttingDown = true;
38651:     AddRemoveSelfReference();
38651:   }
38651:   return NS_OK;
38651: }
38651: 
79445: bool
25018: nsHTMLMediaElement::IsNodeOfType(PRUint32 aFlags) const
25018: {
41646:   return !(aFlags & ~(eCONTENT | eMEDIA));
25018: }
25018: 
51938: void nsHTMLMediaElement::DispatchAsyncSourceError(nsIContent* aSourceElement)
51938: {
51938:   LOG_EVENT(PR_LOG_DEBUG, ("%p Queuing simple source error event", this));
51938: 
51938:   nsCOMPtr<nsIRunnable> event = new nsSourceErrorEventRunner(this, aSourceElement);
51938:   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
51938: }
51938: 
25018: void nsHTMLMediaElement::NotifyAddedSource()
25018: {
51938:   // If a source element is inserted as a child of a media element
51938:   // that has no src attribute and whose networkState has the value
51938:   // NETWORK_EMPTY, the user agent must invoke the media element's
51938:   // resource selection algorithm.
51938:   if (!HasAttr(kNameSpaceID_None, nsGkAtoms::src) &&
51938:       mNetworkState == nsIDOMHTMLMediaElement::NETWORK_EMPTY)
51938:   {
25849:     QueueSelectResourceTask();
51938:   }
51938: 
51938:   // A load was paused in the resource selection algorithm, waiting for
74740:   // a new source child to be added, resume the resource selction algorithm.
51938:   if (mLoadWaitStatus == WAITING_FOR_SOURCE) {
25849:     QueueLoadFromSourceTask();
25018:   }
25018: }
25849: 
51938: nsIContent* nsHTMLMediaElement::GetNextSource()
25849: {
82292:   nsCOMPtr<nsIDOMNode> thisDomNode = do_QueryObject(this);
82292: 
82292:   mSourceLoadCandidate = nsnull;
82292: 
25849:   nsresult rv = NS_OK;
25849:   if (!mSourcePointer) {
25849:     // First time this has been run, create a selection to cover children.
86939:     mSourcePointer = new nsRange();
25849: 
25849:     rv = mSourcePointer->SelectNodeContents(thisDomNode);
25849:     if (NS_FAILED(rv)) return nsnull;
25849: 
79547:     rv = mSourcePointer->Collapse(true);
25849:     if (NS_FAILED(rv)) return nsnull;
25849:   }
25849: 
79547:   while (true) {
25849: #ifdef DEBUG
25849:     nsCOMPtr<nsIDOMNode> startContainer;
25849:     rv = mSourcePointer->GetStartContainer(getter_AddRefs(startContainer));
25849:     if (NS_FAILED(rv)) return nsnull;
25849:     NS_ASSERTION(startContainer == thisDomNode,
25849:                 "Should only iterate over direct children");
25849: #endif
25849: 
25849:     PRInt32 startOffset = 0;
25849:     rv = mSourcePointer->GetStartOffset(&startOffset);
25849:     NS_ENSURE_SUCCESS(rv, nsnull);
25849: 
33856:     if (PRUint32(startOffset) == GetChildCount())
25849:       return nsnull; // No more children.
25849: 
25849:     // Advance the range to the next child.
25849:     rv = mSourcePointer->SetStart(thisDomNode, startOffset + 1);
25849:     NS_ENSURE_SUCCESS(rv, nsnull);
25849: 
25849:     nsIContent* child = GetChildAt(startOffset);
25849: 
51938:     // If child is a <source> element, it is the next candidate.
82292:     if (child && child->IsHTML(nsGkAtoms::source)) {
51938:       mSourceLoadCandidate = child;
51938:       return child;
25849:     }
25849:   }
25849:   NS_NOTREACHED("Execution should not reach here!");
25849:   return nsnull;
25849: }
25850: 
82292: void nsHTMLMediaElement::ChangeDelayLoadStatus(bool aDelay)
82292: {
25850:   if (mDelayingLoadEvent == aDelay)
25850:     return;
25850: 
25850:   mDelayingLoadEvent = aDelay;
25850: 
25850:   if (aDelay) {
80526:     mLoadBlockedDoc = OwnerDoc();
25850:     mLoadBlockedDoc->BlockOnload();
33372:     LOG(PR_LOG_DEBUG, ("%p ChangeDelayLoadStatus(%d) doc=0x%p", this, aDelay, mLoadBlockedDoc.get()));
25850:   } else {
27217:     if (mDecoder) {
27217:       mDecoder->MoveLoadsToBackground();
27217:     }
33372:     LOG(PR_LOG_DEBUG, ("%p ChangeDelayLoadStatus(%d) doc=0x%p", this, aDelay, mLoadBlockedDoc.get()));
38651:     // mLoadBlockedDoc might be null due to GC unlinking
38651:     if (mLoadBlockedDoc) {
79547:       mLoadBlockedDoc->UnblockOnload(false);
25850:       mLoadBlockedDoc = nsnull;
25850:     }
38651:   }
34207: 
34207:   // We changed mDelayingLoadEvent which can affect AddRemoveSelfReference
34207:   AddRemoveSelfReference();
25850: }
27217: 
27217: already_AddRefed<nsILoadGroup> nsHTMLMediaElement::GetDocumentLoadGroup()
27217: {
80527:   return OwnerDoc()->GetDocumentLoadGroup();
27217: }
35581: 
35581: nsresult
35581: nsHTMLMediaElement::CopyInnerTo(nsGenericElement* aDest) const
35581: {
35581:   nsresult rv = nsGenericHTMLElement::CopyInnerTo(aDest);
35581:   NS_ENSURE_SUCCESS(rv, rv);
80526:   if (aDest->OwnerDoc()->IsStaticDocument()) {
35581:     nsHTMLMediaElement* dest = static_cast<nsHTMLMediaElement*>(aDest);
35581:     if (mPrintSurface) {
35581:       dest->mPrintSurface = mPrintSurface;
35581:       dest->mMediaSize = mMediaSize;
35581:     } else {
36655:       nsIFrame* frame = GetPrimaryFrame();
83345:       Element* element;
35581:       if (frame && frame->GetType() == nsGkAtoms::HTMLVideoFrame &&
35581:           static_cast<nsVideoFrame*>(frame)->ShouldDisplayPoster()) {
83345:         nsIContent* content = static_cast<nsVideoFrame*>(frame)->GetPosterImage();
83345:         element = content ? content->AsElement() : NULL;
35581:       } else {
83345:         element = const_cast<nsHTMLMediaElement*>(this);
35581:       }
35581: 
35581:       nsLayoutUtils::SurfaceFromElementResult res =
83345:         nsLayoutUtils::SurfaceFromElement(element,
35581:                                           nsLayoutUtils::SFE_WANT_NEW_SURFACE);
35581:       dest->mPrintSurface = res.mSurface;
35581:       dest->mMediaSize = nsIntSize(res.mSize.width, res.mSize.height);
35581:     }
35581:   }
35581:   return rv;
35581: }
48902: 
51394: nsresult nsHTMLMediaElement::GetBuffered(nsIDOMTimeRanges** aBuffered)
48902: {
82292:   nsRefPtr<nsTimeRanges> ranges = new nsTimeRanges();
48902:   if (mReadyState >= nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA && mDecoder) {
53767:     // If GetBuffered fails we ignore the error result and just return the
53767:     // time ranges we found up till the error.
53767:     mDecoder->GetBuffered(ranges);
48902:   }
82292:   ranges.forget(aBuffered);
48902:   return NS_OK;
48902: }
54200: 
54200: void nsHTMLMediaElement::SetRequestHeaders(nsIHttpChannel* aChannel)
54200: {
54200:   // Send Accept header for video and audio types only (Bug 489071)
54200:   SetAcceptHeader(aChannel);
54200: 
58314:   // Apache doesn't send Content-Length when gzip transfer encoding is used,
58314:   // which prevents us from estimating the video length (if explicit Content-Duration
58314:   // and a length spec in the container are not present either) and from seeking.
58314:   // So, disable the standard "Accept-Encoding: gzip,deflate" that we usually send.
58314:   // See bug 614760.
58314:   aChannel->SetRequestHeader(NS_LITERAL_CSTRING("Accept-Encoding"),
82292:                              EmptyCString(), false);
58314: 
54200:   // Set the Referer header
80527:   aChannel->SetReferrer(OwnerDoc()->GetDocumentURI());
54200: }
58179: 
79445: void nsHTMLMediaElement::FireTimeUpdate(bool aPeriodic)
58179: {
58179:   NS_ASSERTION(NS_IsMainThread(), "Should be on main thread.");
58179: 
58179:   TimeStamp now = TimeStamp::Now();
60727:   double time = 0;
58179:   GetCurrentTime(&time);
58179: 
58179:   // Fire a timupdate event if this is not a periodic update (i.e. it's a
58179:   // timeupdate event mandated by the spec), or if it's a periodic update
58179:   // and TIMEUPDATE_MS has passed since the last timeupdate event fired and
58179:   // the time has changed.
58179:   if (!aPeriodic ||
58179:       (mLastCurrentTime != time &&
58179:        (mTimeUpdateTime.IsNull() ||
58179:         now - mTimeUpdateTime >= TimeDuration::FromMilliseconds(TIMEUPDATE_MS)))) {
58179:     DispatchAsyncEvent(NS_LITERAL_STRING("timeupdate"));
58179:     mTimeUpdateTime = now;
58179:     mLastCurrentTime = time;
58179:   }
77175:   if (mFragmentEnd >= 0.0 && time >= mFragmentEnd) {
77175:     Pause();
77175:     mFragmentEnd = -1.0;
77175:     mFragmentStart = -1.0;
77175:     mDecoder->SetEndTime(mFragmentEnd);
58179:   }
77175: }
77175: 
77175: void nsHTMLMediaElement::GetCurrentSpec(nsCString& aString)
77175: {
82746:   if (mLoadingSrc) {
77175:     mLoadingSrc->GetSpec(aString);
82746:   } else {
82746:     aString.Truncate();
77175:   }
77175: }
77175: 
77175: /* attribute double initialTime; */
77175: NS_IMETHODIMP nsHTMLMediaElement::GetInitialTime(double *aTime)
77175: {
77175:   // If there is no start fragment then the initalTime is zero.
77175:   // Clamp to duration if it is greater than duration.
77175:   double duration = 0.0;
77175:   nsresult rv = GetDuration(&duration);
77175:   NS_ENSURE_SUCCESS(rv, rv);
77175: 
77175:   *aTime = mFragmentStart < 0.0 ? 0.0 : mFragmentStart;
77175:   if (*aTime > duration) {
77175:     *aTime = duration;
77175:   }
77175:   return NS_OK;
77175: }
77175: 
77175: /* attribute double mozFragmentEnd; */
77175: NS_IMETHODIMP nsHTMLMediaElement::GetMozFragmentEnd(double *aTime)
77175: {
77175:   double duration = 0.0;
77175:   nsresult rv = GetDuration(&duration);
77175:   NS_ENSURE_SUCCESS(rv, rv);
77175: 
77175:   // If there is no end fragment, or the fragment end is greater than the
77175:   // duration, return the duration.
77175:   *aTime = (mFragmentEnd < 0.0 || mFragmentEnd > duration) ? duration : mFragmentEnd;
77175:   return NS_OK;
77175: }
82604: 
82604: void nsHTMLMediaElement::NotifyAudioAvailableListener()
82604: {
82604:   if (mDecoder) {
82604:     mDecoder->NotifyAudioAvailableListener();
82604:   }
82604: }
