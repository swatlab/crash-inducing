41369: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
41369:  * ***** BEGIN LICENSE BLOCK *****
41369:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
41369:  *
41369:  * The contents of this file are subject to the Mozilla Public License Version
41369:  * 1.1 (the "License"); you may not use this file except in compliance with
41369:  * the License. You may obtain a copy of the License at
41369:  * http://www.mozilla.org/MPL/
41369:  *
41369:  * Software distributed under the License is distributed on an "AS IS" basis,
41369:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
41369:  * for the specific language governing rights and limitations under the
41369:  * License.
41369:  *
41369:  * The Initial Developer of the Original Code is Mozilla Foundation.
41369:  * Portions created by the Initial Developer are Copyright (C) 2010
41369:  * the Initial Developer. All Rights Reserved.
41369:  *
41369:  * Contributor(s):
41369:  *   Bas Schouten <bschouten@mozilla.com>
42402:  *   Vladimir Vukicevic <vladimir@pobox.com>
41369:  *
41369:  * Alternatively, the contents of this file may be used under the terms of
41369:  * either the GNU General Public License Version 2 or later (the "GPL"), or
41369:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
41369:  * in which case the provisions of the GPL or the LGPL are applicable instead
41369:  * of those above. If you wish to allow use of your version of this file only
41369:  * under the terms of either the GPL or the LGPL, and not to allow others to
41369:  * use your version of this file under the terms of the MPL, indicate your
41369:  * decision by deleting the provisions above and replace them with the notice
41369:  * and other provisions required by the GPL or the LGPL. If you do not delete
41369:  * the provisions above, a recipient may use your version of this file under
41369:  * the terms of any one of the MPL, the GPL or the LGPL.
41369:  *
41369:  * ***** END LICENSE BLOCK ***** */
41369: 
41369: #include "GLContextProvider.h"
42402: #include "GLContext.h"
93376: #include "GLLibraryLoader.h"
41369: #include "nsDebug.h"
41369: #include "nsIWidget.h"
42402: #include "WGLLibrary.h"
44173: #include "gfxASurface.h"
46980: #include "gfxImageSurface.h"
46980: #include "gfxPlatform.h"
46980: #include "gfxWindowsSurface.h"
41369: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
54505: #include "prenv.h"
54505: 
80611: #include "mozilla/Preferences.h"
80611: 
41369: namespace mozilla {
41369: namespace gl {
41369: 
42402: WGLLibrary sWGLLibrary;
41369: 
47908: static HWND gSharedWindow = 0;
47908: static HDC gSharedWindowDC = 0;
47908: static HGLRC gSharedWindowGLContext = 0;
47908: static int gSharedWindowPixelFormat = 0;
47908: 
79445: static bool gUseDoubleBufferedWindows = false;
54505: 
47908: static HWND
47908: CreateDummyWindow(HDC *aWindowDC = nsnull)
47908: {
47908:     WNDCLASSW wc;
47908:     if (!GetClassInfoW(GetModuleHandle(NULL), L"GLContextWGLClass", &wc)) {
47908:         ZeroMemory(&wc, sizeof(WNDCLASSW));
47908:         wc.style = CS_OWNDC;
47908:         wc.hInstance = GetModuleHandle(NULL);
47908:         wc.lpfnWndProc = DefWindowProc;
47908:         wc.lpszClassName = L"GLContextWGLClass";
47908:         if (!RegisterClassW(&wc)) {
47908:             NS_WARNING("Failed to register GLContextWGLClass?!");
47908:             // er. failed to register our class?
47908:             return NULL;
47908:         }
47908:     }
47908: 
47908:     HWND win = CreateWindowW(L"GLContextWGLClass", L"GLContextWGL", 0,
47908:                              0, 0, 16, 16,
47908:                              NULL, NULL, GetModuleHandle(NULL), NULL);
47908:     NS_ENSURE_TRUE(win, NULL);
47908: 
47908:     HDC dc = GetDC(win);
47908:     NS_ENSURE_TRUE(dc, NULL);
47908: 
47908:     if (gSharedWindowPixelFormat == 0) {
47908:         PIXELFORMATDESCRIPTOR pfd;
47908:         ZeroMemory(&pfd, sizeof(PIXELFORMATDESCRIPTOR));
47908:         pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
47908:         pfd.nVersion = 1;
47908:         pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
54505:         if (gUseDoubleBufferedWindows)
54505:             pfd.dwFlags |= PFD_DOUBLEBUFFER;
47908:         pfd.iPixelType = PFD_TYPE_RGBA;
47908:         pfd.cColorBits = 24;
49071:         pfd.cRedBits = 8;
49071:         pfd.cGreenBits = 8;
49071:         pfd.cBlueBits = 8;
49071:         pfd.cAlphaBits = 8;
47908:         pfd.cDepthBits = 0;
47908:         pfd.iLayerType = PFD_MAIN_PLANE;
47908: 
47908:         gSharedWindowPixelFormat = ChoosePixelFormat(dc, &pfd);
47908:     }
47908: 
61757:     if (!gSharedWindowPixelFormat ||
61757:         !SetPixelFormat(dc, gSharedWindowPixelFormat, NULL))
61757:     {
47908:         NS_WARNING("SetPixelFormat failed!");
47908:         DestroyWindow(win);
47908:         return NULL;
47908:     }
47908: 
47908:     if (aWindowDC) {
47908:         *aWindowDC = dc;
47908:     }
47908: 
47908:     return win;
47908: }
42402: 
83210: static inline bool
83210: HasExtension(const char* aExtensions, const char* aRequiredExtension)
83210: {
83210:     return GLContext::ListHasExtension(
83210:         reinterpret_cast<const GLubyte*>(aExtensions), aRequiredExtension);
83210: }
83210: 
79445: bool
42402: WGLLibrary::EnsureInitialized()
41369: {
42402:     if (mInitialized)
80486:         return true;
41369: 
63285:     mozilla::ScopedGfxFeatureReporter reporter("WGL");
63285: 
41369:     if (!mOGLLibrary) {
41369:         mOGLLibrary = PR_LoadLibrary("Opengl32.dll");
41369:         if (!mOGLLibrary) {
41369:             NS_WARNING("Couldn't load OpenGL DLL.");
80486:             return false;
41369:         }
41369:     }
42402: 
54505:     gUseDoubleBufferedWindows = PR_GetEnv("MOZ_WGL_DB") != nsnull;
54505: 
93376:     GLLibraryLoader::SymLoadStruct earlySymbols[] = {
42402:         { (PRFuncPtr*) &fCreateContext, { "wglCreateContext", NULL } },
42402:         { (PRFuncPtr*) &fMakeCurrent, { "wglMakeCurrent", NULL } },
42402:         { (PRFuncPtr*) &fGetProcAddress, { "wglGetProcAddress", NULL } },
42402:         { (PRFuncPtr*) &fDeleteContext, { "wglDeleteContext", NULL } },
42402:         { (PRFuncPtr*) &fGetCurrentContext, { "wglGetCurrentContext", NULL } },
42402:         { (PRFuncPtr*) &fGetCurrentDC, { "wglGetCurrentDC", NULL } },
47908:         { (PRFuncPtr*) &fShareLists, { "wglShareLists", NULL } },
42402:         { NULL, { NULL } }
42402:     };
42402: 
93376:     if (!GLLibraryLoader::LoadSymbols(mOGLLibrary, &earlySymbols[0])) {
42402:         NS_WARNING("Couldn't find required entry points in OpenGL DLL (early init)");
80486:         return false;
41369:     }
42402: 
47908:     // This is ridiculous -- we have to actually create a context to
47908:     // get the OpenGL ICD to load.
47908:     gSharedWindow = CreateDummyWindow(&gSharedWindowDC);
80486:     NS_ENSURE_TRUE(gSharedWindow, false);
42402: 
42402:     // create rendering context
47908:     gSharedWindowGLContext = fCreateContext(gSharedWindowDC);
80486:     NS_ENSURE_TRUE(gSharedWindowGLContext, false);
42402: 
42402:     HGLRC curCtx = fGetCurrentContext();
42402:     HDC curDC = fGetCurrentDC();
42402: 
47908:     if (!fMakeCurrent((HDC)gSharedWindowDC, (HGLRC)gSharedWindowGLContext)) {
42402:         NS_WARNING("wglMakeCurrent failed");
80486:         return false;
42402:     }
42402: 
42402:     // Now we can grab all the other symbols that we couldn't without having
42402:     // a context current.
42402: 
93376:     GLLibraryLoader::SymLoadStruct pbufferSymbols[] = {
42402:         { (PRFuncPtr*) &fCreatePbuffer, { "wglCreatePbufferARB", "wglCreatePbufferEXT", NULL } },
42402:         { (PRFuncPtr*) &fDestroyPbuffer, { "wglDestroyPbufferARB", "wglDestroyPbufferEXT", NULL } },
42402:         { (PRFuncPtr*) &fGetPbufferDC, { "wglGetPbufferDCARB", "wglGetPbufferDCEXT", NULL } },
42402:         { (PRFuncPtr*) &fBindTexImage, { "wglBindTexImageARB", "wglBindTexImageEXT", NULL } },
42402:         { (PRFuncPtr*) &fReleaseTexImage, { "wglReleaseTexImageARB", "wglReleaseTexImageEXT", NULL } },
42402:         { NULL, { NULL } }
42402:     };
42402: 
93376:     GLLibraryLoader::SymLoadStruct pixFmtSymbols[] = {
42402:         { (PRFuncPtr*) &fChoosePixelFormat, { "wglChoosePixelFormatARB", "wglChoosePixelFormatEXT", NULL } },
42402:         { (PRFuncPtr*) &fGetPixelFormatAttribiv, { "wglGetPixelFormatAttribivARB", "wglGetPixelFormatAttribivEXT", NULL } },
42402:         { NULL, { NULL } }
42402:     };
42402: 
93376:     if (!GLLibraryLoader::LoadSymbols(mOGLLibrary, &pbufferSymbols[0],
93376:          (GLLibraryLoader::PlatformLookupFunction)fGetProcAddress))
42402:     {
42402:         // this isn't an error, just means that pbuffers aren't supported
42402:         fCreatePbuffer = nsnull;
42402:     }
42402: 
93376:     if (!GLLibraryLoader::LoadSymbols(mOGLLibrary, &pixFmtSymbols[0],
93376:          (GLLibraryLoader::PlatformLookupFunction)fGetProcAddress))
42402:     {
42402:         // this isn't an error, just means that we don't have the pixel format extension
42402:         fChoosePixelFormat = nsnull;
42402:     }
42402: 
93376:     GLLibraryLoader::SymLoadStruct extensionsSymbols[] = {
83210:         { (PRFuncPtr *) &fGetExtensionsString, { "wglGetExtensionsStringARB", NULL} },
83210:         { NULL, { NULL } }
83210:     };
83210: 
93376:     GLLibraryLoader::SymLoadStruct robustnessSymbols[] = {
83210:         { (PRFuncPtr *) &fCreateContextAttribs, { "wglCreateContextAttribsARB", NULL} },
83210:         { NULL, { NULL } }
83210:     };
83210: 
93376:     if (GLLibraryLoader::LoadSymbols(mOGLLibrary, &extensionsSymbols[0],
93376:         (GLLibraryLoader::PlatformLookupFunction)fGetProcAddress)) {
83210:         const char *wglExts = fGetExtensionsString(gSharedWindowDC);
83210:         if (wglExts && HasExtension(wglExts, "WGL_ARB_create_context")) {
93376:             GLLibraryLoader::LoadSymbols(mOGLLibrary, &robustnessSymbols[0],
93376:             (GLLibraryLoader::PlatformLookupFunction)fGetProcAddress);
83210:             if (HasExtension(wglExts, "WGL_ARB_create_context_robustness")) {
83210:                 mHasRobustness = true;
83210:             }
83210:         }
83210:     }
83210: 
42402:     // reset back to the previous context, just in case
42402:     fMakeCurrent(curDC, curCtx);
42402: 
83210:     if (mHasRobustness) {
83210:         fDeleteContext(gSharedWindowGLContext);
83210: 
83210:         int attribs[] = {
83210:             LOCAL_WGL_CONTEXT_FLAGS_ARB, LOCAL_WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB,
83210:             LOCAL_WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB, LOCAL_WGL_LOSE_CONTEXT_ON_RESET_ARB,
83210:             NULL
83210:         };
83210: 
83210:         gSharedWindowGLContext = fCreateContextAttribs(gSharedWindowDC, NULL, attribs);
83210:         if (!gSharedWindowGLContext) {
83210:             mHasRobustness = false;
83210:             gSharedWindowGLContext = fCreateContext(gSharedWindowDC);
83210:         }
83210:     }
83210: 
80486:     mInitialized = true;
47908: 
47908:     // Call this to create the global GLContext instance,
47908:     // and to check for errors.  Note that this must happen /after/
47908:     // setting mInitialized to TRUE, or an infinite loop results.
47908:     if (GLContextProviderWGL::GetGlobalContext() == nsnull) {
80486:         mInitialized = false;
80486:         return false;
47908:     }
47908: 
63285:     reporter.SetSuccessful();
80486:     return true;
41369: }
41369: 
41369: class GLContextWGL : public GLContext
41369: {
41369: public:
47908:     GLContextWGL(const ContextFormat& aFormat,
47908:                  GLContext *aSharedContext,
47908:                  HDC aDC,
47908:                  HGLRC aContext,
47908:                  HWND aWindow = nsnull,
79445:                  bool aIsOffscreen = false)
47908:         : GLContext(aFormat, aIsOffscreen, aSharedContext),
47908:           mDC(aDC),
47908:           mContext(aContext),
47908:           mWnd(aWindow),
47908:           mPBuffer(NULL),
53689:           mPixelFormat(0),
80486:           mIsDoubleBuffered(false)
47908:     {
47908:     }
42402: 
47908:     GLContextWGL(const ContextFormat& aFormat,
47908:                  GLContext *aSharedContext,
47908:                  HANDLE aPbuffer,
47908:                  HDC aDC,
47908:                  HGLRC aContext,
47908:                  int aPixelFormat)
80486:         : GLContext(aFormat, true, aSharedContext),
47908:           mDC(aDC),
47908:           mContext(aContext),
47908:           mWnd(NULL),
47908:           mPBuffer(aPbuffer),
53689:           mPixelFormat(aPixelFormat),
80486:           mIsDoubleBuffered(false)
47908:     {
42402:     }
41369: 
41369:     ~GLContextWGL()
41369:     {
54505:         MarkDestroyed();
47908: 
41369:         sWGLLibrary.fDeleteContext(mContext);
42402: 
42402:         if (mPBuffer)
42402:             sWGLLibrary.fDestroyPbuffer(mPBuffer);
47908:         if (mWnd)
47908:             DestroyWindow(mWnd);
47908:     }
47908: 
47908:     GLContextType GetContextType() {
47908:         return ContextTypeWGL;
41369:     }
41369: 
79445:     bool Init()
41369:     {
47908:         if (!mDC || !mContext)
80486:             return false;
47908: 
41369:         MakeCurrent();
41369:         SetupLookupFunction();
92137:         if (!InitWithPrefix("gl", true))
92137:             return false;
92137: 
92137:         InitFramebuffers();
92137:         return true;
41369:     }
41369: 
98361:     bool MakeCurrentImpl(bool aForce = false)
41369:     {
98361:         BOOL succeeded = true;
98361: 
98361:         // wglGetCurrentContext seems to just pull the HGLRC out
98361:         // of its TLS slot, so no need to do our own tls slot.
98361:         // You would think that wglMakeCurrent would avoid doing
98361:         // work if mContext was already current, but not so much..
98361:         if (aForce || sWGLLibrary.fGetCurrentContext() != mContext) {
98361:             succeeded = sWGLLibrary.fMakeCurrent(mDC, mContext);
41369:             NS_ASSERTION(succeeded, "Failed to make GL context current!");
98361:         }
42518: 
41369:         return succeeded;
41369:     }
41369: 
79445:     void SetIsDoubleBuffered(bool aIsDB) {
53689:         mIsDoubleBuffered = aIsDB;
53689:     }
53689: 
79445:     virtual bool IsDoubleBuffered() {
53689:         return mIsDoubleBuffered;
53689:     }
53689: 
82479:     bool SupportsRobustness()
82479:     {
83210:         return sWGLLibrary.HasRobustness();
82479:     }
82479: 
79445:     virtual bool SwapBuffers() {
53689:         if (!mIsDoubleBuffered)
80486:             return false;
53689:         return ::SwapBuffers(mDC);
53689:     }
53689: 
79445:     bool SetupLookupFunction()
41369:     {
41369:         mLookupFunc = (PlatformLookupFunction)sWGLLibrary.fGetProcAddress;
80486:         return true;
41369:     }
41369: 
42402:     void *GetNativeData(NativeDataType aType)
42402:     {
42402:         switch (aType) {
42402:         case NativeGLContext:
42402:             return mContext;
42402: 
42402:         default:
42402:             return nsnull;
42402:         }
42402:     }
42402: 
79445:     bool BindTex2DOffscreen(GLContext *aOffscreen);
47908:     void UnbindTex2DOffscreen(GLContext *aOffscreen);
79445:     bool ResizeOffscreen(const gfxIntSize& aNewSize);
47908: 
47908:     HGLRC Context() { return mContext; }
47908: 
47908: protected:
47908:     friend class GLContextProviderWGL;
47908: 
47908:     HDC mDC;
47908:     HGLRC mContext;
47908:     HWND mWnd;
47908:     HANDLE mPBuffer;
47908:     int mPixelFormat;
53689: 
79445:     bool mIsDoubleBuffered;
47908: };
47908: 
79445: bool
47908: GLContextWGL::BindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     if (aOffscreen->GetContextType() != ContextTypeWGL) {
47908:         NS_WARNING("non-WGL context");
80486:         return false;
47908:     }
43425: 
47908:     if (!aOffscreen->IsOffscreen()) {
47908:         NS_WARNING("non-offscreen context");
80486:         return false;
47908:     }
47908: 
47908:     GLContextWGL *offs = static_cast<GLContextWGL*>(aOffscreen);
47908: 
47908:     if (offs->mPBuffer) {
47908:         BOOL ok = sWGLLibrary.fBindTexImage(offs->mPBuffer,
47908:                                             LOCAL_WGL_FRONT_LEFT_ARB);
47908:         if (!ok) {
47908:             NS_WARNING("CanvasLayerOGL::Updated wglBindTexImageARB failed");
80486:             return false;
47908:         }
47908:     } else if (offs->mOffscreenTexture) {
47908:         if (offs->GetSharedContext() != GLContextProviderWGL::GetGlobalContext())
47908:         {
47908:             NS_WARNING("offscreen FBO context can only be bound with context sharing!");
80486:             return false;
47908:         }
47908: 
47908:         fBindTexture(LOCAL_GL_TEXTURE_2D, offs->mOffscreenTexture);
43425:     } else {
47908:         NS_WARNING("don't know how to bind this!");
80486:         return false;
43425:     }
43425: 
80486:     return true;
47908: }
43425: 
47908: void
47908: GLContextWGL::UnbindTex2DOffscreen(GLContext *aOffscreen)
47908: {
47908:     NS_ASSERTION(aOffscreen->GetContextType() == ContextTypeWGL, "wrong type");
47908: 
47908:     GLContextWGL *offs = static_cast<GLContextWGL*>(aOffscreen);
47908:     if (offs->mPBuffer) {
47908:         // XXX so, according to the extension, ReleaseTexImage is not required to
47908:         // preserve color buffer contents.  This sucks, but everywhere that I've
47908:         // tried it the color buffer is preserved.  So let's cross our fingers..
47908:         sWGLLibrary.fReleaseTexImage(offs->mPBuffer, LOCAL_WGL_FRONT_LEFT_ARB);
47908:     }
47908: }
47908: 
80612: 
80612: static bool
80612: GetMaxSize(HDC hDC, int format, gfxIntSize& size)
80612: {
80612:     int query[] = {LOCAL_WGL_MAX_PBUFFER_WIDTH_ARB, LOCAL_WGL_MAX_PBUFFER_HEIGHT_ARB};
80612:     int result[2];
80612: 
80612:     // (HDC hdc, int iPixelFormat, int iLayerPlane, UINT nAttributes, int* piAttributes, int *piValues)
80612:     if (!sWGLLibrary.fGetPixelFormatAttribiv(hDC, format, 0, 2, query, result))
80612:         return false;
80612: 
80612:     size.width = result[0];
80612:     size.height = result[1];
80612:     return true;
80612: }
80612: 
80612: static bool
80612: IsValidSizeForFormat(HDC hDC, int format, const gfxIntSize& requested)
80612: {
80612:     gfxIntSize max;
80612:     if (!GetMaxSize(hDC, format, max))
80612:         return true;
80612: 
80612:     if (requested.width > max.width)
80612:         return false;
80612:     if (requested.height > max.height)
80612:         return false;
80612: 
80612:     return true;
80612: }
80612: 
79445: bool
47908: GLContextWGL::ResizeOffscreen(const gfxIntSize& aNewSize)
47908: {
47908:     if (mPBuffer) {
80612:         if (!IsValidSizeForFormat(gSharedWindowDC, mPixelFormat, aNewSize))
80612:             return false;
80612: 
47908:         int pbattrs[] = {
47908:             LOCAL_WGL_TEXTURE_FORMAT_ARB,
47908:               mCreationFormat.alpha > 0 ? LOCAL_WGL_TEXTURE_RGBA_ARB
47908:                                         : LOCAL_WGL_TEXTURE_RGB_ARB,
47908:             LOCAL_WGL_TEXTURE_TARGET_ARB, LOCAL_WGL_TEXTURE_2D_ARB,
47908:             0
47908:         };
47908: 
47908:         HANDLE newbuf = sWGLLibrary.fCreatePbuffer(gSharedWindowDC, mPixelFormat,
43425:                                                    aNewSize.width, aNewSize.height,
47908:                                                    pbattrs);
43425:         if (!newbuf)
80486:             return false;
43425: 
43425:         bool isCurrent = false;
43425:         if (sWGLLibrary.fGetCurrentContext() == mContext) {
43425:             sWGLLibrary.fMakeCurrent(NULL, NULL);
43425:             isCurrent = true;
43425:         }
43425: 
43425:         sWGLLibrary.fDestroyPbuffer(mPBuffer);
43425: 
43425:         mPBuffer = newbuf;
43425:         mDC = sWGLLibrary.fGetPbufferDC(mPBuffer);
43425: 
47908:         mOffscreenSize = aNewSize;
47908:         mOffscreenActualSize = aNewSize;
47908: 
43425:         MakeCurrent();
47908:         ClearSafely();
43425: 
96935:         return ResizeOffscreenFBOs(aNewSize, false);
43425:     }
43425: 
96935:     return ResizeOffscreenFBOs(aNewSize, true);
47908: }
46980: 
47908: static GLContextWGL *
47908: GetGlobalContextWGL()
47908: {
47908:     return static_cast<GLContextWGL*>(GLContextProviderWGL::GetGlobalContext());
47908: }
41369: 
41369: already_AddRefed<GLContext>
47907: GLContextProviderWGL::CreateForWindow(nsIWidget *aWidget)
41369: {
41369:     if (!sWGLLibrary.EnsureInitialized()) {
41369:         return nsnull;
41369:     }
47908: 
41369:     /**
41369:        * We need to make sure we call SetPixelFormat -after- calling 
41369:        * EnsureInitialized, otherwise it can load/unload the dll and 
41369:        * wglCreateContext will fail.
41369:        */
41369: 
41369:     HDC dc = (HDC)aWidget->GetNativeData(NS_NATIVE_GRAPHIC);
41369: 
47908:     SetPixelFormat(dc, gSharedWindowPixelFormat, NULL);
83210:     HGLRC context;
83210: 
83210:     GLContextWGL *shareContext = GetGlobalContextWGL();
83210: 
83210:     if (sWGLLibrary.HasRobustness()) {
83210:         int attribs[] = {
83210:             LOCAL_WGL_CONTEXT_FLAGS_ARB, LOCAL_WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB,
83210:             LOCAL_WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB, LOCAL_WGL_LOSE_CONTEXT_ON_RESET_ARB,
83210:             NULL
83210:         };
83210: 
83210:         context = sWGLLibrary.fCreateContextAttribs(dc,
83210:                                                     shareContext ? shareContext->Context() : nsnull,
83210:                                                     attribs);
83210:         if (!context && shareContext) {
83210:             context = sWGLLibrary.fCreateContextAttribs(dc, nsnull, attribs);
83210:             if (context) {
83210:                 shareContext = nsnull;
83210:             }
83210:         } else {
83210:             context = sWGLLibrary.fCreateContext(dc);
83210:             if (context && shareContext && !sWGLLibrary.fShareLists(shareContext->Context(), context)) {
83210:                 shareContext = nsnull;
83210:             }
83210:         }
84806:     } else {
84806:         context = sWGLLibrary.fCreateContext(dc);
84806:         if (context &&
84806:             shareContext &&
84806:             !sWGLLibrary.fShareLists(shareContext->Context(), context))
84806:         {
84806:             shareContext = nsnull;
84806:         }
83210:     }
83210: 
41369:     if (!context) {
41369:         return nsnull;
41369:     }
41369: 
47908:     nsRefPtr<GLContextWGL> glContext = new GLContextWGL(ContextFormat(ContextFormat::BasicRGB24),
47908:                                                         shareContext, dc, context);
47908:     if (!glContext->Init()) {
42402:         return nsnull;
42402:     }
42402: 
54505:     glContext->SetIsDoubleBuffered(gUseDoubleBufferedWindows);
54505: 
47908:     return glContext.forget();
47908: }
42402: 
47908: static already_AddRefed<GLContextWGL>
47908: CreatePBufferOffscreenContext(const gfxIntSize& aSize,
47908:                               const ContextFormat& aFormat)
47908: {
47908: #define A1(_a,_x)  do { _a.AppendElement(_x); } while(0)
47908: #define A2(_a,_x,_y)  do { _a.AppendElement(_x); _a.AppendElement(_y); } while(0)
42402: 
47908:     nsTArray<int> attrs;
42402: 
47908:     A2(attrs, LOCAL_WGL_SUPPORT_OPENGL_ARB, LOCAL_GL_TRUE);
47908:     A2(attrs, LOCAL_WGL_DRAW_TO_PBUFFER_ARB, LOCAL_GL_TRUE);
47908:     A2(attrs, LOCAL_WGL_DOUBLE_BUFFER_ARB, LOCAL_GL_FALSE);
42402: 
47908:     A2(attrs, LOCAL_WGL_ACCELERATION_ARB, LOCAL_WGL_FULL_ACCELERATION_ARB);
42402: 
47908:     A2(attrs, LOCAL_WGL_COLOR_BITS_ARB, aFormat.colorBits());
47908:     A2(attrs, LOCAL_WGL_RED_BITS_ARB, aFormat.red);
47908:     A2(attrs, LOCAL_WGL_GREEN_BITS_ARB, aFormat.green);
47908:     A2(attrs, LOCAL_WGL_BLUE_BITS_ARB, aFormat.blue);
47908:     A2(attrs, LOCAL_WGL_ALPHA_BITS_ARB, aFormat.alpha);
42402: 
47908:     A2(attrs, LOCAL_WGL_DEPTH_BITS_ARB, aFormat.depth);
57631:     A2(attrs, LOCAL_WGL_STENCIL_BITS_ARB, aFormat.stencil);
42402: 
47908:     if (aFormat.alpha > 0) {
47908:         A2(attrs, LOCAL_WGL_BIND_TO_TEXTURE_RGBA_ARB, LOCAL_GL_TRUE);
47908:     } else {
47908:         A2(attrs, LOCAL_WGL_BIND_TO_TEXTURE_RGB_ARB, LOCAL_GL_TRUE);
47908:     }
42402: 
47908:     A2(attrs, LOCAL_WGL_DOUBLE_BUFFER_ARB, LOCAL_GL_FALSE);
47908:     A2(attrs, LOCAL_WGL_STEREO_ARB, LOCAL_GL_FALSE);
42402: 
47908:     A1(attrs, 0);
42402: 
47908:     nsTArray<int> pbattrs;
47908:     A2(pbattrs, LOCAL_WGL_TEXTURE_TARGET_ARB, LOCAL_WGL_TEXTURE_2D_ARB);
47908: 
47908:     if (aFormat.alpha > 0) {
47908:         A2(pbattrs, LOCAL_WGL_TEXTURE_FORMAT_ARB, LOCAL_WGL_TEXTURE_RGBA_ARB);
47908:     } else {
47908:         A2(pbattrs, LOCAL_WGL_TEXTURE_FORMAT_ARB, LOCAL_WGL_TEXTURE_RGB_ARB);
47908:     }
47908:     A1(pbattrs, 0);
47908: 
47908:     UINT numFormats = 256;
47908:     int formats[256];
47908: 
47908:     if (!sWGLLibrary.fChoosePixelFormat(gSharedWindowDC,
47908:                                         attrs.Elements(), NULL,
42402:                                         numFormats, formats, &numFormats)
42402:         || numFormats == 0)
41369:     {
41369:         return nsnull;
41369:     }
41369: 
42402:     // XXX add back the priority choosing code here
42402:     int chosenFormat = formats[0];
42402: 
80612:     if (!IsValidSizeForFormat(gSharedWindowDC, chosenFormat, aSize))
80612:         return nsnull;
80612: 
47908:     HANDLE pbuffer = sWGLLibrary.fCreatePbuffer(gSharedWindowDC, chosenFormat,
42402:                                                 aSize.width, aSize.height,
47908:                                                 pbattrs.Elements());
42402:     if (!pbuffer) {
42402:         return nsnull;
42402:     }
42402: 
47908:     HDC pbdc = sWGLLibrary.fGetPbufferDC(pbuffer);
47908:     NS_ASSERTION(pbdc, "expected a dc");
42402: 
83210:     HGLRC context;
83210:     if (sWGLLibrary.HasRobustness()) {
83210:         int attribs[] = {
83210:             LOCAL_WGL_CONTEXT_FLAGS_ARB, LOCAL_WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB,
83210:             LOCAL_WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB, LOCAL_WGL_LOSE_CONTEXT_ON_RESET_ARB,
83210:             NULL
83210:         };
83210: 
83210:         context = sWGLLibrary.fCreateContextAttribs(pbdc, nsnull, attribs);
83210:     } else {
83210:         context = sWGLLibrary.fCreateContext(pbdc);
83210:     }
83210: 
47908:     if (!context) {
47908:         sWGLLibrary.fDestroyPbuffer(pbuffer);
80486:         return false;
47908:     }
47908: 
47908:     nsRefPtr<GLContextWGL> glContext = new GLContextWGL(aFormat,
47908:                                                         nsnull,
47908:                                                         pbuffer,
47908:                                                         pbdc,
47908:                                                         context,
47908:                                                         chosenFormat);
47908: 
47908:     return glContext.forget();
47908: }
47908: 
47908: static already_AddRefed<GLContextWGL>
80615: CreateWindowOffscreenContext(const ContextFormat& aFormat)
47908: {
47908:     // CreateWindowOffscreenContext must return a global-shared context
47908:     GLContextWGL *shareContext = GetGlobalContextWGL();
47908:     if (!shareContext) {
47908:         return nsnull;
47908:     }
47908:     
47908:     HDC dc;
47908:     HWND win = CreateDummyWindow(&dc);
47908:     if (!win) {
47908:         return nsnull;
47908:     }
47908:     
47908:     HGLRC context = sWGLLibrary.fCreateContext(dc);
83210:     if (sWGLLibrary.HasRobustness()) {
83210:         int attribs[] = {
83210:             LOCAL_WGL_CONTEXT_FLAGS_ARB, LOCAL_WGL_CONTEXT_ROBUST_ACCESS_BIT_ARB,
83210:             LOCAL_WGL_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB, LOCAL_WGL_LOSE_CONTEXT_ON_RESET_ARB,
83210:             NULL
83210:         };
47908: 
83210:         context = sWGLLibrary.fCreateContextAttribs(dc, shareContext->Context(), attribs);
83210:     } else {
83210:         context = sWGLLibrary.fCreateContext(dc);
83210:         if (context && shareContext &&
83210:             !sWGLLibrary.fShareLists(shareContext->Context(), context))
83210:         {
47908:             NS_WARNING("wglShareLists failed!");
47908: 
47908:             sWGLLibrary.fDeleteContext(context);
47908:             DestroyWindow(win);
47908:             return nsnull;
47908:         }
83210:     }
83210: 
83210:     if (!context) {
83210:         return nsnull;
83210:     }
47908: 
47908:     nsRefPtr<GLContextWGL> glContext = new GLContextWGL(aFormat, shareContext,
80486:                                                         dc, context, win, true);
47908: 
47908:     return glContext.forget();
47908: }
47908: 
47908: already_AddRefed<GLContext>
47908: GLContextProviderWGL::CreateOffscreen(const gfxIntSize& aSize,
93720:                                       const ContextFormat& aFormat,
93720:                                       const ContextFlags)
47908: {
47908:     if (!sWGLLibrary.EnsureInitialized()) {
47908:         return nsnull;
47908:     }
47908: 
47908:     nsRefPtr<GLContextWGL> glContext;
47908: 
47908:     // Always try to create a pbuffer context first, because we
47908:     // want the context isolation.
80611:     NS_ENSURE_TRUE(Preferences::GetRootBranch(), nsnull);
80611:     const bool preferFBOs = Preferences::GetBool("wgl.prefer-fbo", false);
80611:     if (!preferFBOs &&
80611:         sWGLLibrary.fCreatePbuffer &&
47908:         sWGLLibrary.fChoosePixelFormat)
47908:     {
80900:         glContext = CreatePBufferOffscreenContext(aSize, aFormat);
47908:     }
47908: 
47908:     // If it failed, then create a window context and use a FBO.
47908:     if (!glContext) {
80900:         glContext = CreateWindowOffscreenContext(aFormat);
47908:     }
47908: 
47908:     if (!glContext ||
47908:         !glContext->Init())
47908:     {
47908:         return nsnull;
47908:     }
47908: 
96935:     if (!glContext->ResizeOffscreenFBOs(aSize, !glContext->mPBuffer))
80617:         return nsnull;
80617: 
47908:     glContext->mOffscreenSize = aSize;
47908:     glContext->mOffscreenActualSize = aSize;
47908: 
47908:     return glContext.forget();
42402: }
42402: 
44173: already_AddRefed<GLContext>
47907: GLContextProviderWGL::CreateForNativePixmapSurface(gfxASurface *aSurface)
44173: {
44173:     return nsnull;
44173: }
44173: 
47908: static nsRefPtr<GLContextWGL> gGlobalContext;
47908: 
47908: GLContext *
47908: GLContextProviderWGL::GetGlobalContext()
47908: {
47908:     if (!sWGLLibrary.EnsureInitialized()) {
47908:         return nsnull;
47908:     }
47908: 
47908:     static bool triedToCreateContext = false;
47908: 
47908:     if (!triedToCreateContext && !gGlobalContext) {
47908:         triedToCreateContext = true;
47908: 
47908:         // conveniently, we already have what we need...
47908:         gGlobalContext = new GLContextWGL(ContextFormat(ContextFormat::BasicRGB24), nsnull,
47908:                                           gSharedWindowDC, gSharedWindowGLContext);
47908:         if (!gGlobalContext->Init()) {
47908:             NS_WARNING("Global context GLContext initialization failed?");
47908:             gGlobalContext = nsnull;
80486:             return false;
47908:         }
49071: 
80486:         gGlobalContext->SetIsGlobalSharedContext(true);
47908:     }
47908: 
47908:     return static_cast<GLContext*>(gGlobalContext);
47908: }
47908: 
47967: void
47967: GLContextProviderWGL::Shutdown()
47967: {
54672:     gGlobalContext = nsnull;
47967: }
47967: 
41369: } /* namespace gl */
41369: } /* namespace mozilla */
