33486: /* vim: se cin sw=2 ts=2 et : */
33486: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
33486:  *
33486:  * ***** BEGIN LICENSE BLOCK *****
33486:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33486:  *
33486:  * The contents of this file are subject to the Mozilla Public License Version
33486:  * 1.1 (the "License"); you may not use this file except in compliance with
33486:  * the License. You may obtain a copy of the License at
33486:  * http://www.mozilla.org/MPL/
33486:  *
33486:  * Software distributed under the License is distributed on an "AS IS" basis,
33486:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33486:  * for the specific language governing rights and limitations under the
33486:  * License.
33486:  *
33486:  * The Original Code is mozilla.org code.
33486:  *
33486:  * The Initial Developer of the Original Code is
33486:  * Mozilla Foundation.
33486:  * Portions created by the Initial Developer are Copyright (C) 2009
33486:  * the Initial Developer. All Rights Reserved.
33486:  *
33486:  * Contributor(s):
33486:  *   Rob Arnold <tellrob@gmail.com>
33510:  *   Siddharth Agarwal <sid.bugzilla@gmail.com>
33486:  *
33486:  * Alternatively, the contents of this file may be used under the terms of
33486:  * either the GNU General Public License Version 2 or later (the "GPL"), or
33486:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33486:  * in which case the provisions of the GPL or the LGPL are applicable instead
33486:  * of those above. If you wish to allow use of your version of this file only
33486:  * under the terms of either the GPL or the LGPL, and not to allow others to
33486:  * use your version of this file under the terms of the MPL, indicate your
33486:  * decision by deleting the provisions above and replace them with the notice
33486:  * and other provisions required by the GPL or the LGPL. If you do not delete
33486:  * the provisions above, a recipient may use your version of this file under
33486:  * the terms of any one of the MPL, the GPL or the LGPL.
33486:  *
33486:  * ***** END LICENSE BLOCK ***** */
33486: 
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486: 
33486: #include <nsITaskbarPreviewController.h>
33486: #include "TaskbarWindowPreview.h"
33486: #include "WindowHook.h"
33486: #include "nsUXThemeData.h"
33486: #include "TaskbarPreviewButton.h"
33486: #include "nsWindow.h"
33486: 
33486: namespace mozilla {
33486: namespace widget {
33486: 
33486: namespace {
33486: PRBool WindowHookProc(void *aContext, HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT *aResult)
33486: {
33486:   TaskbarWindowPreview *preview = reinterpret_cast<TaskbarWindowPreview*>(aContext);
33486:   *aResult = preview->WndProc(nMsg, wParam, lParam);
33486:   return PR_TRUE;
33486: }
33486: }
33486: 
33510: NS_IMPL_ISUPPORTS3(TaskbarWindowPreview, nsITaskbarWindowPreview,
33510:                    nsITaskbarProgress, nsISupportsWeakReference)
33510: 
33510: /**
33510:  * These correspond directly to the states defined in nsITaskbarProgress.idl, so
33510:  * they should be kept in sync.
33510:  */
33510: static TBPFLAG sNativeStates[] =
33510: {
33510:   TBPF_NOPROGRESS,
33510:   TBPF_INDETERMINATE,
33510:   TBPF_NORMAL,
33510:   TBPF_ERROR,
33510:   TBPF_PAUSED
33510: };
33486: 
33486: TaskbarWindowPreview::TaskbarWindowPreview(ITaskbarList4 *aTaskbar, nsITaskbarPreviewController *aController, HWND aHWND, nsIDocShell *aShell)
33486:   : TaskbarPreview(aTaskbar, aController, aHWND, aShell),
33486:     mCustomDrawing(PR_FALSE),
33510:     mHaveButtons(PR_FALSE),
33510:     mState(TBPF_NOPROGRESS),
33510:     mCurrentValue(0),
33510:     mMaxValue(0)
33486: {
33486:   // Window previews are visible by default
33486:   (void) SetVisible(PR_TRUE);
33486: 
33486:   memset(mThumbButtons, 0, sizeof mThumbButtons);
33487:   for (PRInt32 i = 0; i < nsITaskbarWindowPreview::NUM_TOOLBAR_BUTTONS; i++) {
33486:     mThumbButtons[i].dwMask = THB_FLAGS | THB_ICON | THB_TOOLTIP;
33486:     mThumbButtons[i].iId = i;
33486:     mThumbButtons[i].dwFlags = THBF_HIDDEN;
33486:   }
33486: 
33510:   WindowHook &hook = GetWindowHook();
33510:   if (!CanMakeTaskbarCalls())
33510:     hook.AddMonitor(nsAppShell::GetTaskbarButtonCreatedMessage(),
33510:                     TaskbarProgressWindowHook, this);
33486: }
33486: 
33486: TaskbarWindowPreview::~TaskbarWindowPreview() {
33486:   if (mWnd)
41139:     DetachFromNSWindow();
33486: }
33486: 
33486: nsresult
33486: TaskbarWindowPreview::ShowActive(PRBool active) {
33486:   return FAILED(mTaskbar->ActivateTab(active ? mWnd : NULL))
33486:        ? NS_ERROR_FAILURE
33486:        : NS_OK;
33486: 
33486: }
33486: 
33486: HWND &
33486: TaskbarWindowPreview::PreviewWindow() {
33486:   return mWnd;
33486: }
33486: 
33486: nsresult
33486: TaskbarWindowPreview::GetButton(PRUint32 index, nsITaskbarPreviewButton **_retVal) {
33487:   if (index >= nsITaskbarWindowPreview::NUM_TOOLBAR_BUTTONS)
33486:     return NS_ERROR_INVALID_ARG;
33486: 
33486:   nsCOMPtr<nsITaskbarPreviewButton> button(do_QueryReferent(mWeakButtons[index]));
33486: 
33486:   if (!button) {
33486:     // Lost reference
33486:     button = new TaskbarPreviewButton(this, index);
33486:     if (!button) {
33486:       return NS_ERROR_OUT_OF_MEMORY;
33486:     }
33486:     mWeakButtons[index] = do_GetWeakReference(button);
33486:   }
33486: 
33486:   if (!mHaveButtons) {
33486:     mHaveButtons = PR_TRUE;
33486: 
33486:     WindowHook &hook = GetWindowHook();
33486:     (void) hook.AddHook(WM_COMMAND, WindowHookProc, this);
33486: 
33487:     if (mVisible && FAILED(mTaskbar->ThumbBarAddButtons(mWnd, nsITaskbarWindowPreview::NUM_TOOLBAR_BUTTONS, mThumbButtons))) {
33486:       return NS_ERROR_FAILURE;
33486:     }
33486:   }
33486:   button.forget(_retVal);
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarWindowPreview::SetEnableCustomDrawing(PRBool aEnable) {
33486:   if (aEnable == mCustomDrawing)
33486:     return NS_OK;
33486:   mCustomDrawing = aEnable;
33486:   TaskbarPreview::EnableCustomDrawing(mWnd, aEnable);
33486: 
33486:   WindowHook &hook = GetWindowHook();
33486:   if (aEnable) {
33486:     (void) hook.AddHook(WM_DWMSENDICONICTHUMBNAIL, WindowHookProc, this);
33486:     (void) hook.AddHook(WM_DWMSENDICONICLIVEPREVIEWBITMAP, WindowHookProc, this);
33486:   } else {
33486:     (void) hook.RemoveHook(WM_DWMSENDICONICLIVEPREVIEWBITMAP, WindowHookProc, this);
33486:     (void) hook.RemoveHook(WM_DWMSENDICONICTHUMBNAIL, WindowHookProc, this);
33486:   }
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarWindowPreview::GetEnableCustomDrawing(PRBool *aEnable) {
33486:   *aEnable = mCustomDrawing;
33486:   return NS_OK;
33486: }
33486: 
33510: NS_IMETHODIMP
33510: TaskbarWindowPreview::SetProgressState(nsTaskbarProgressState aState,
33510:                                        PRUint64 aCurrentValue,
33510:                                        PRUint64 aMaxValue)
33510: {
33510:   NS_ENSURE_ARG_RANGE(aState, 0, NS_ARRAY_LENGTH(sNativeStates) - 1);
33510: 
33510:   TBPFLAG nativeState = sNativeStates[aState];
33510:   if (nativeState == TBPF_NOPROGRESS || nativeState == TBPF_INDETERMINATE) {
33510:     NS_ENSURE_TRUE(aCurrentValue == 0, NS_ERROR_INVALID_ARG);
33510:     NS_ENSURE_TRUE(aMaxValue == 0, NS_ERROR_INVALID_ARG);
33510:   }
33510: 
33510:   if (aCurrentValue > aMaxValue)
33510:     return NS_ERROR_ILLEGAL_VALUE;
33510: 
33510:   mState = nativeState;
33510:   mCurrentValue = aCurrentValue;
33510:   mMaxValue = aMaxValue;
33510: 
33510:   // Only update if we can
33510:   return CanMakeTaskbarCalls() ? UpdateTaskbarProgress() : NS_OK;
33510: }
33510: 
33486: nsresult
33486: TaskbarWindowPreview::UpdateTaskbarProperties() {
33486:   if (mHaveButtons) {
33487:     if (FAILED(mTaskbar->ThumbBarAddButtons(mWnd, nsITaskbarWindowPreview::NUM_TOOLBAR_BUTTONS, mThumbButtons)))
33486:       return NS_ERROR_FAILURE;
33486:   }
33510:   nsresult rv = UpdateTaskbarProgress();
33510:   NS_ENSURE_SUCCESS(rv, rv);
33486:   return TaskbarPreview::UpdateTaskbarProperties();
33486: }
33486: 
33510: nsresult
33510: TaskbarWindowPreview::UpdateTaskbarProgress() {
33510:   HRESULT hr = mTaskbar->SetProgressState(mWnd, mState);
33510:   if (SUCCEEDED(hr) && mState != TBPF_NOPROGRESS &&
33510:       mState != TBPF_INDETERMINATE)
33510:     hr = mTaskbar->SetProgressValue(mWnd, mCurrentValue, mMaxValue);
33510: 
33510:   return SUCCEEDED(hr) ? NS_OK : NS_ERROR_FAILURE;
33510: }
33510: 
33486: LRESULT
33486: TaskbarWindowPreview::WndProc(UINT nMsg, WPARAM wParam, LPARAM lParam) {
33486:   nsRefPtr<TaskbarWindowPreview> kungFuDeathGrip(this);
33486:   switch (nMsg) {
33486:     case WM_COMMAND:
33486:       {
33486:         PRUint32 id = LOWORD(wParam);
33486:         PRUint32 index = id;
33486:         nsCOMPtr<nsITaskbarPreviewButton> button;
33486:         nsresult rv = GetButton(index, getter_AddRefs(button));
33486:         if (NS_SUCCEEDED(rv))
33486:           mController->OnClick(button);
33486:       }
33486:       return 0;
33486:   }
33486:   return TaskbarPreview::WndProc(nMsg, wParam, lParam);
33486: }
33486: 
33510: /* static */
33510: PRBool
33510: TaskbarWindowPreview::TaskbarProgressWindowHook(void *aContext,
33510:                                                 HWND hWnd, UINT nMsg,
33510:                                                 WPARAM wParam, LPARAM lParam,
33510:                                                 LRESULT *aResult)
33510: {
33510:   NS_ASSERTION(nMsg == nsAppShell::GetTaskbarButtonCreatedMessage(),
33510:                "Window hook proc called with wrong message");
33510:   TaskbarWindowPreview *preview =
33510:     reinterpret_cast<TaskbarWindowPreview*>(aContext);
33510:   // Now we can make all the calls to mTaskbar
33510:   preview->UpdateTaskbarProgress();
33510:   return PR_FALSE;
33510: }
33510: 
33486: nsresult
33486: TaskbarWindowPreview::Enable() {
33486:   nsresult rv = TaskbarPreview::Enable();
33486:   NS_ENSURE_SUCCESS(rv, rv);
33486: 
33486:   return FAILED(mTaskbar->AddTab(mWnd))
33486:        ? NS_ERROR_FAILURE
33486:        : NS_OK;
33486: }
33486: 
33486: nsresult
33486: TaskbarWindowPreview::Disable() {
33486:   nsresult rv = TaskbarPreview::Disable();
33486:   NS_ENSURE_SUCCESS(rv, rv);
33486: 
33486:   return FAILED(mTaskbar->DeleteTab(mWnd))
33486:        ? NS_ERROR_FAILURE
33486:        : NS_OK;
33486: }
33486: 
33486: void
41139: TaskbarWindowPreview::DetachFromNSWindow() {
33486:   // Remove the hooks we have for drawing
33486:   SetEnableCustomDrawing(PR_FALSE);
33486: 
33486:   WindowHook &hook = GetWindowHook();
33486:   (void) hook.RemoveHook(WM_COMMAND, WindowHookProc, this);
33510:   (void) hook.RemoveMonitor(nsAppShell::GetTaskbarButtonCreatedMessage(),
33510:                             TaskbarProgressWindowHook, this);
33486: 
41139:   TaskbarPreview::DetachFromNSWindow();
33486: }
33486: 
33486: nsresult
33486: TaskbarWindowPreview::UpdateButtons() {
33486:   NS_ASSERTION(mVisible, "UpdateButtons called on invisible preview");
33486: 
33487:   if (FAILED(mTaskbar->ThumbBarUpdateButtons(mWnd, nsITaskbarWindowPreview::NUM_TOOLBAR_BUTTONS, mThumbButtons)))
33486:     return NS_ERROR_FAILURE;
33486:   return NS_OK;
33486: }
33486: 
33486: nsresult
33486: TaskbarWindowPreview::UpdateButton(PRUint32 index) {
33487:   if (index >= nsITaskbarWindowPreview::NUM_TOOLBAR_BUTTONS)
33486:     return NS_ERROR_INVALID_ARG;
33486:   if (mVisible) {
33486:     if (FAILED(mTaskbar->ThumbBarUpdateButtons(mWnd, 1, &mThumbButtons[index])))
33486:       return NS_ERROR_FAILURE;
33486:   }
33486:   return NS_OK;
33486: }
33486: 
33486: } // namespace widget
33486: } // namespace mozilla
33486: 
33486: #endif // MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486: 
