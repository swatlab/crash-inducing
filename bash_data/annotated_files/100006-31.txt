 29366: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 17947:  * vim: set sw=4 ts=8 et tw=99:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS bytecode descriptors, disassemblers, and decompilers.
     1:  */
 95341: 
 95341: #include "mozilla/FloatingPoint.h"
 95341: #include "mozilla/Util.h"
 95341: 
     1: #ifdef HAVE_MEMORY_H
     1: #include <memory.h>
     1: #endif
     1: #include <stdarg.h>
     1: #include <stdio.h>
     1: #include <stdlib.h>
     1: #include <string.h>
 80468: 
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
     1: #include "jsprf.h"
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsfun.h"
 15613: #include "jsiter.h"
 20908: #include "jsnum.h"
     1: #include "jsobj.h"
     1: #include "jsopcode.h"
     1: #include "jsscope.h"
     1: #include "jsscript.h"
     1: #include "jsstr.h"
     1: 
 82461: #include "ds/Sort.h"
 82461: 
 80964: #include "frontend/BytecodeEmitter.h"
 80506: #include "frontend/TokenStream.h"
 79778: #include "vm/Debugger.h"
 93300: #include "vm/StringBuffer.h"
 79778: 
 75501: #include "jscntxtinlines.h"
 53840: #include "jsobjinlines.h"
 75501: #include "jsopcodeinlines.h"
 32723: 
 15453: #include "jsautooplen.h"
 15453: 
 79981: #include "vm/RegExpObject-inl.h"
 79981: 
 80468: using namespace mozilla;
 40221: using namespace js;
 54707: using namespace js::gc;
 40221: 
 25901: /*
 25901:  * Index limit must stay within 32 bits.
 25901:  */
 84755: JS_STATIC_ASSERT(sizeof(uint32_t) * JS_BITS_PER_BYTE >= INDEX_LIMIT_LOG2 + 1);
 25901: 
 15453: /* Verify JSOP_XXX_LENGTH constant definitions. */
 15453: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format)               \
 15453:     JS_STATIC_ASSERT(op##_LENGTH == length);
 15453: #include "jsopcode.tbl"
 15453: #undef OPDEF
 15453: 
     1: static const char js_incop_strs[][3] = {"++", "--"};
 20943: static const char js_for_each_str[]  = "for each";
     1: 
  1154: const JSCodeSpec js_CodeSpec[] = {
     1: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
  1154:     {length,nuses,ndefs,prec,format},
     1: #include "jsopcode.tbl"
     1: #undef OPDEF
     1: };
     1: 
 91237: unsigned js_NumCodeSpecs = JS_ARRAY_LENGTH(js_CodeSpec);
  1154: 
  1154: /*
  1154:  * Each element of the array is either a source literal associated with JS
  1154:  * bytecode or null.
  1154:  */
  1154: static const char *CodeToken[] = {
  1154: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
  1154:     token,
  1154: #include "jsopcode.tbl"
  1154: #undef OPDEF
  1154: };
  1154: 
  1154: /*
 84803:  * Array of JS bytecode names used by PC count JSON, DEBUG-only js_Disassemble
 84803:  * and JIT debug spew.
  1154:  */
 12410: const char *js_CodeName[] = {
  1154: #define OPDEF(op,val,name,token,length,nuses,ndefs,prec,format) \
  1154:     name,
  1154: #include "jsopcode.tbl"
  1154: #undef OPDEF
  1154: };
     1: 
     1: /************************************************************************/
     1: 
 71699: #define COUNTS_LEN 16
 71699: 
 81592: typedef Vector<char, 8> DupBuffer;
 81592: 
 81592: static bool
 81592: Dup(const char *chars, DupBuffer *cb)
 81592: {
 81592:     return cb->append(chars, strlen(chars) + 1);
 81592: }
 81592: 
 75501: size_t
 84195: js_GetVariableBytecodeLength(jsbytecode *pc)
 16072: {
 91237:     unsigned ncases;
 91450:     int32_t low, high;
 16072: 
 84195:     JSOp op = JSOp(*pc);
 16072:     JS_ASSERT(js_CodeSpec[op].length == -1);
 16072:     switch (op) {
 16072:       case JSOP_TABLESWITCH:
 16072:         /* Structure: default-jump case-low case-high case1-jump ... */
 86877:         pc += JUMP_OFFSET_LEN;
 16072:         low = GET_JUMP_OFFSET(pc);
 16072:         pc += JUMP_OFFSET_LEN;
 16072:         high = GET_JUMP_OFFSET(pc);
 91237:         ncases = (unsigned)(high - low + 1);
 86877:         return 1 + 3 * JUMP_OFFSET_LEN + ncases * JUMP_OFFSET_LEN;
 86877: 
 16072:       default:
 86877:         /* Structure: default-jump case-count (case1-value case1-jump) ... */
 16072:         JS_ASSERT(op == JSOP_LOOKUPSWITCH);
 86877:         pc += JUMP_OFFSET_LEN;
 16072:         ncases = GET_UINT16(pc);
 90965:         return 1 + JUMP_OFFSET_LEN + UINT16_LEN + ncases * (UINT32_INDEX_LEN + JUMP_OFFSET_LEN);
 16072:     }
 16072: }
 16072: 
 86078: static uint32_t
 86078: NumBlockSlots(JSScript *script, jsbytecode *pc)
 86078: {
 86078:     JS_ASSERT(*pc == JSOP_ENTERBLOCK || *pc == JSOP_ENTERLET0 || *pc == JSOP_ENTERLET1);
 86078:     JS_STATIC_ASSERT(JSOP_ENTERBLOCK_LENGTH == JSOP_ENTERLET0_LENGTH);
 86078:     JS_STATIC_ASSERT(JSOP_ENTERBLOCK_LENGTH == JSOP_ENTERLET1_LENGTH);
 86078: 
 89253:     return script->getObject(GET_UINT32_INDEX(pc))->asStaticBlock().slotCount();
 86078: }
 86078: 
 91237: unsigned
 86078: js::StackUses(JSScript *script, jsbytecode *pc)
 18567: {
 86078:     JSOp op = (JSOp) *pc;
 86078:     const JSCodeSpec &cs = js_CodeSpec[op];
 86078:     if (cs.nuses >= 0)
 86078:         return cs.nuses;
 86078: 
 18567:     JS_ASSERT(js_CodeSpec[op].nuses == -1);
 18567:     switch (op) {
 18567:       case JSOP_POPN:
 18567:         return GET_UINT16(pc);
 18567:       case JSOP_LEAVEBLOCK:
 18567:         return GET_UINT16(pc);
 18567:       case JSOP_LEAVEBLOCKEXPR:
 18567:         return GET_UINT16(pc) + 1;
 86078:       case JSOP_ENTERLET0:
 86078:         return NumBlockSlots(script, pc);
 86078:       case JSOP_ENTERLET1:
 86078:         return NumBlockSlots(script, pc) + 1;
 18567:       default:
 18567:         /* stack: fun, this, [argc arguments] */
 57742:         JS_ASSERT(op == JSOP_NEW || op == JSOP_CALL || op == JSOP_EVAL ||
 57712:                   op == JSOP_FUNCALL || op == JSOP_FUNAPPLY);
 18567:         return 2 + GET_ARGC(pc);
 18567:     }
 18567: }
 18567: 
 91237: unsigned
 86078: js::StackDefs(JSScript *script, jsbytecode *pc)
 26729: {
 86078:     JSOp op = (JSOp) *pc;
 86078:     const JSCodeSpec &cs = js_CodeSpec[op];
 86078:     if (cs.ndefs >= 0)
 86078:         return cs.ndefs;
 86078: 
 86078:     uint32_t n = NumBlockSlots(script, pc);
 86078:     return op == JSOP_ENTERLET1 ? n + 1 : n;
 26729: }
 26729: 
 82134: static const char * countBaseNames[] = {
 82134:     "interp",
 82134:     "mjit",
 82134:     "mjit_calls",
 82134:     "mjit_code",
 82134:     "mjit_pics"
 82134: };
 82134: 
 94574: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(countBaseNames) == PCCounts::BASE_LIMIT);
 82134: 
 82134: static const char * countAccessNames[] = {
 82134:     "infer_mono",
 82134:     "infer_di",
 82134:     "infer_poly",
 82134:     "infer_barrier",
 82134:     "infer_nobarrier",
 82134:     "observe_undefined",
 82134:     "observe_null",
 82134:     "observe_boolean",
 82134:     "observe_int32",
 82134:     "observe_double",
 82134:     "observe_string",
 82134:     "observe_object"
 82134: };
 82134: 
 82134: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(countBaseNames) +
 94574:                  JS_ARRAY_LENGTH(countAccessNames) == PCCounts::ACCESS_LIMIT);
 82134: 
 82134: static const char * countElementNames[] = {
 82134:     "id_int",
 82134:     "id_double",
 82134:     "id_other",
 82134:     "id_unknown",
 82134:     "elem_typed",
 82134:     "elem_packed",
 82134:     "elem_dense",
 82134:     "elem_other"
 82134: };
 82134: 
 82134: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(countBaseNames) +
 82134:                  JS_ARRAY_LENGTH(countAccessNames) +
 94574:                  JS_ARRAY_LENGTH(countElementNames) == PCCounts::ELEM_LIMIT);
 82134: 
 82134: static const char * countPropertyNames[] = {
 82134:     "prop_static",
 82134:     "prop_definite",
 82134:     "prop_other"
 82134: };
 82134: 
 82134: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(countBaseNames) +
 82134:                  JS_ARRAY_LENGTH(countAccessNames) +
 94574:                  JS_ARRAY_LENGTH(countPropertyNames) == PCCounts::PROP_LIMIT);
 82134: 
 82134: static const char * countArithNames[] = {
 82134:     "arith_int",
 82134:     "arith_double",
 82134:     "arith_other",
 82134:     "arith_unknown",
 82134: };
 82134: 
 82134: JS_STATIC_ASSERT(JS_ARRAY_LENGTH(countBaseNames) +
 94574:                  JS_ARRAY_LENGTH(countArithNames) == PCCounts::ARITH_LIMIT);
 82134: 
 82134: /* static */ const char *
 94574: PCCounts::countName(JSOp op, size_t which)
 82134: {
 82134:     JS_ASSERT(which < numCounts(op));
 82134: 
 94574:     if (which < BASE_LIMIT)
 82134:         return countBaseNames[which];
 82134: 
 82134:     if (accessOp(op)) {
 94574:         if (which < ACCESS_LIMIT)
 94574:             return countAccessNames[which - BASE_LIMIT];
 82134:         if (elementOp(op))
 94574:             return countElementNames[which - ACCESS_LIMIT];
 82134:         if (propertyOp(op))
 94574:             return countPropertyNames[which - ACCESS_LIMIT];
 82134:         JS_NOT_REACHED("bad op");
 82134:         return NULL;
 82134:     }
 82134: 
 82134:     if (arithOp(op))
 94574:         return countArithNames[which - BASE_LIMIT];
 82134: 
 82134:     JS_NOT_REACHED("bad op");
 82134:     return NULL;
 82134: }
 82134: 
 59886: #ifdef DEBUG
 59886: 
 82134: JS_FRIEND_API(void)
 82134: js_DumpPCCounts(JSContext *cx, JSScript *script, js::Sprinter *sp)
 82134: {
 95113:     JS_ASSERT(script->hasScriptCounts);
 82134: 
 82134:     jsbytecode *pc = script->code;
 82134:     while (pc < script->code + script->length) {
 84195:         JSOp op = JSOp(*pc);
 82134: 
 82134:         int len = js_CodeSpec[op].length;
 82134:         jsbytecode *next = (len != -1) ? pc + len : pc + js_GetVariableBytecodeLength(pc);
 82134: 
 82134:         if (!js_Disassemble1(cx, script, pc, pc - script->code, true, sp))
 82134:             return;
 82134: 
 94574:         size_t total = PCCounts::numCounts(op);
 94574:         double *raw = script->getPCCounts(pc).rawCounts();
 82134: 
 82134:         Sprint(sp, "                  {");
 82134:         bool printed = false;
 82134:         for (size_t i = 0; i < total; i++) {
 82134:             double val = raw[i];
 82134:             if (val) {
 82134:                 if (printed)
 82134:                     Sprint(sp, ", ");
 94574:                 Sprint(sp, "\"%s\": %.0f", PCCounts::countName(op, i), val);
 82134:                 printed = true;
 82134:             }
 82134:         }
 82134:         Sprint(sp, "}\n");
 82134: 
 82134:         pc = next;
 82134:     }
 82134: }
 82134: 
 69852: /*
 69852:  * If pc != NULL, include a prefix indicating whether the PC is at the current line.
 69852:  * If counts != NULL, include a counter of the number of times each op was executed.
 69852:  */
 59886: JS_FRIEND_API(JSBool)
 97353: js_DisassembleAtPC(JSContext *cx, JSScript *script_, JSBool lines, jsbytecode *pc, Sprinter *sp)
 59886: {
 99421:     Rooted<JSScript*> script(cx, script_);
 97353: 
 59886:     jsbytecode *next, *end;
 91237:     unsigned len;
 59886: 
 90229:     sp->put("loc   ");
 69852:     if (lines)
 90229:         sp->put("line");
 90229:     sp->put("  op\n");
 90229:     sp->put("----- ");
 69852:     if (lines)
 90229:         sp->put("----");
 90229:     sp->put("  --\n");
 69852: 
 59886:     next = script->code;
 59886:     end = next + script->length;
 59886:     while (next < end) {
 77659:         if (next == script->main())
 90229:             sp->put("main:\n");
 59886:         if (pc != NULL) {
 59886:             if (pc == next)
 90229:                 sp->put("--> ");
 59886:             else
 90229:                 sp->put("    ");
 59886:         }
 79410:         len = js_Disassemble1(cx, script, next, next - script->code, lines, sp);
 59886:         if (!len)
 59886:             return JS_FALSE;
 59886:         next += len;
 59886:     }
 59886:     return JS_TRUE;
 59886: }
 59886: 
 59886: JS_FRIEND_API(JSBool)
 71699: js_Disassemble(JSContext *cx, JSScript *script, JSBool lines, Sprinter *sp)
 59886: {
 71699:     return js_DisassembleAtPC(cx, script, lines, NULL, sp);
 59886: }
 59886: 
 59886: JS_FRIEND_API(JSBool)
 71699: js_DumpPC(JSContext *cx)
 59886: {
 87952:     Sprinter sprinter(cx);
 87952:     if (!sprinter.init())
 87952:         return JS_FALSE;
 71699:     JSBool ok = js_DisassembleAtPC(cx, cx->fp()->script(), true, cx->regs().pc, &sprinter);
 87952:     fprintf(stdout, "%s", sprinter.string());
 64374:     return ok;
 59886: }
 59886: 
 59886: JSBool
 59886: js_DumpScript(JSContext *cx, JSScript *script)
 59886: {
 87952:     Sprinter sprinter(cx);
 87952:     if (!sprinter.init())
 87952:         return JS_FALSE;
 64374:     JSBool ok = js_Disassemble(cx, script, true, &sprinter);
 87952:     fprintf(stdout, "%s", sprinter.string());
 64374:     return ok;
 59886: }
 59886: 
 77893: static char *
 84755: QuoteString(Sprinter *sp, JSString *str, uint32_t quote);
 77893: 
 59886: static bool
 59886: ToDisassemblySource(JSContext *cx, jsval v, JSAutoByteString *bytes)
 59886: {
 77893:     if (JSVAL_IS_STRING(v)) {
 87952:         Sprinter sprinter(cx);
 87952:         if (!sprinter.init())
 87952:             return false;
 77893:         char *nbytes = QuoteString(&sprinter, JSVAL_TO_STRING(v), '"');
 77893:         if (!nbytes)
 77893:             return false;
 77893:         nbytes = JS_sprintf_append(NULL, "%s", nbytes);
 77893:         if (!nbytes)
 77893:             return false;
 77893:         bytes->initBytes(nbytes);
 77893:         return true;
 77893:     }
 77893: 
 88135:     if (cx->runtime->gcRunning || cx->runtime->noGCOrAllocationCheck) {
 77893:         char *source = JS_sprintf_append(NULL, "<value>");
 77893:         if (!source)
 77893:             return false;
 77893:         bytes->initBytes(source);
 77893:         return true;
 77893:     }
 77893: 
 59886:     if (!JSVAL_IS_PRIMITIVE(v)) {
 59886:         JSObject *obj = JSVAL_TO_OBJECT(v);
 86483:         if (obj->isBlock()) {
 86483:             char *source = JS_sprintf_append(NULL, "depth %d {", obj->asBlock().stackDepth());
 59886:             if (!source)
 59886:                 return false;
 59886: 
 59886:             Shape::Range r = obj->lastProperty()->all();
 99364:             Shape::Range::AutoRooter root(cx, &r);
 97353: 
 59886:             while (!r.empty()) {
 99421:                 Rooted<const Shape*> shape(cx, &r.front());
 97353:                 JSAtom *atom = JSID_IS_INT(shape->propid())
 86078:                                ? cx->runtime->atomState.emptyAtom
 97353:                                : JSID_TO_ATOM(shape->propid());
 86078: 
 59886:                 JSAutoByteString bytes;
 86078:                 if (!js_AtomToPrintableString(cx, atom, &bytes))
 59886:                     return false;
 59886: 
 59886:                 r.popFront();
 59886:                 source = JS_sprintf_append(source, "%s: %d%s",
 97353:                                            bytes.ptr(), shape->shortid(),
 59886:                                            !r.empty() ? ", " : "");
 59886:                 if (!source)
 59886:                     return false;
 59886:             }
 59886: 
 59886:             source = JS_sprintf_append(source, "}");
 59886:             if (!source)
 59886:                 return false;
 59886:             bytes->initBytes(source);
 59886:             return true;
 59886:         }
 59886: 
 86483:         if (obj->isFunction()) {
 83234:             JSString *str = JS_DecompileFunction(cx, obj->toFunction(), JS_DONT_PRETTY_PRINT);
 59886:             if (!str)
 59886:                 return false;
 59886:             return bytes->encode(cx, str);
 59886:         }
 59886: 
 86483:         if (obj->isRegExp()) {
 86483:             JSString *source = obj->asRegExp().toString(cx);
 79981:             if (!source)
 59886:                 return false;
 79981:             JS::Anchor<JSString *> anchor(source);
 79981:             return bytes->encode(cx, source);
 78614:         }
 78614:     }
 78614: 
 78614:     return !!js_ValueToPrintable(cx, v, bytes, true);
 59886: }
 59886: 
 91237: JS_FRIEND_API(unsigned)
     1: js_Disassemble1(JSContext *cx, JSScript *script, jsbytecode *pc,
 91237:                 unsigned loc, JSBool lines, Sprinter *sp)
     1: {
 79778:     JSOp op = (JSOp)*pc;
     1:     if (op >= JSOP_LIMIT) {
     1:         char numBuf1[12], numBuf2[12];
     1:         JS_snprintf(numBuf1, sizeof numBuf1, "%d", op);
     1:         JS_snprintf(numBuf2, sizeof numBuf2, "%d", JSOP_LIMIT);
     1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
     1:                              JSMSG_BYTECODE_TOO_BIG, numBuf1, numBuf2);
     1:         return 0;
     1:     }
 79778:     const JSCodeSpec *cs = &js_CodeSpec[op];
 79778:     ptrdiff_t len = (ptrdiff_t) cs->length;
 64374:     Sprint(sp, "%05u:", loc);
     1:     if (lines)
 64374:         Sprint(sp, "%4u", JS_PCToLineNumber(cx, script, pc));
 64374:     Sprint(sp, "  %s", js_CodeName[op]);
 79778: 
 89253:     switch (JOF_TYPE(cs->format)) {
     1:       case JOF_BYTE:
 76892:           // Scan the trynotes to find the associated catch block
 76892:           // and make the try opcode look like a jump instruction
 76892:           // with an offset. This simplifies code coverage analysis
 76892:           // based on this disassembled output.
 76892:           if (op == JSOP_TRY) {
 97362:               TryNoteArray *trynotes = script->trynotes();
 84755:               uint32_t i;
 76892:               for(i = 0; i < trynotes->length; i++) {
 76892:                   JSTryNote note = trynotes->vector[i];
 76892:                   if (note.kind == JSTRY_CATCH && note.start == loc + 1) {
 76892:                       Sprint(sp, " %u (%+d)",
 76892:                              (unsigned int) (loc+note.length+1),
 76892:                              (int) (note.length+1));
 76892:                       break;
 76892:                   }
 76892:               }
 76892:           }
     1:         break;
     1: 
 86877:       case JOF_JUMP: {
 86877:         ptrdiff_t off = GET_JUMP_OFFSET(pc);
 91237:         Sprint(sp, " %u (%+d)", loc + (int) off, (int) off);
     1:         break;
 79778:       }
     1: 
 95101:       case JOF_SCOPECOORD: {
100006:         unsigned i = GET_UINT16(pc);
100006:         Sprint(sp, " %u", i);
100006:         pc += sizeof(uint16_t);
100006:         i = GET_UINT16(pc);
100006:         Sprint(sp, " %u", i);
100006:         pc += sizeof(uint16_t);
100006:         /* FALL THROUGH */
100006:       }
 89253:       case JOF_ATOM: {
 90965:         Value v = StringValue(script->getAtom(GET_UINT32_INDEX(pc)));
 89253:         JSAutoByteString bytes;
 89253:         if (!ToDisassemblySource(cx, v, &bytes))
 89253:             return 0;
 89253:         Sprint(sp, " %s", bytes.ptr());
 90965:         break;
 90965:       }
 90965: 
 90965:       case JOF_DOUBLE: {
 90965:         Value v = script->getConst(GET_UINT32_INDEX(pc));
 90965:         JSAutoByteString bytes;
 90965:         if (!ToDisassemblySource(cx, v, &bytes))
 90965:             return 0;
 90965:         Sprint(sp, " %s", bytes.ptr());
 89253:         break;
 89253:       }
 89253: 
 89253:       case JOF_OBJECT: {
 89166:         /* Don't call obj.toSource if analysis/inference is active. */
 89166:         if (cx->compartment->activeAnalysis) {
 89166:             Sprint(sp, " object");
 89166:             break;
 89166:         }
 89166: 
 89253:         JSObject *obj = script->getObject(GET_UINT32_INDEX(pc));
 89158:         {
 89158:             JSAutoByteString bytes;
 89253:             if (!ToDisassemblySource(cx, ObjectValue(*obj), &bytes))
 89158:                 return 0;
 89158:             Sprint(sp, " %s", bytes.ptr());
 89158:         }
 89158:         break;
 89158:       }
 89158: 
 87976:       case JOF_REGEXP: {
 87976:         JSObject *obj = script->getRegExp(GET_UINT32_INDEX(pc));
 87976:         JSAutoByteString bytes;
 87976:         if (!ToDisassemblySource(cx, ObjectValue(*obj), &bytes))
 87976:             return 0;
 87976:         Sprint(sp, " %s", bytes.ptr());
 87976:         break;
 87976:       }
 87976: 
     1:       case JOF_TABLESWITCH:
     1:       {
 91450:         int32_t i, low, high;
     1: 
 86877:         ptrdiff_t off = GET_JUMP_OFFSET(pc);
 86877:         jsbytecode *pc2 = pc + JUMP_OFFSET_LEN;
     1:         low = GET_JUMP_OFFSET(pc2);
     1:         pc2 += JUMP_OFFSET_LEN;
     1:         high = GET_JUMP_OFFSET(pc2);
     1:         pc2 += JUMP_OFFSET_LEN;
 91237:         Sprint(sp, " defaultOffset %d low %d high %d", int(off), low, high);
     1:         for (i = low; i <= high; i++) {
 86877:             off = GET_JUMP_OFFSET(pc2);
 91237:             Sprint(sp, "\n\t%d: %d", i, int(off));
 86877:             pc2 += JUMP_OFFSET_LEN;
     1:         }
     1:         len = 1 + pc2 - pc;
     1:         break;
     1:       }
     1: 
     1:       case JOF_LOOKUPSWITCH:
     1:       {
     1:         jsatomid npairs;
     1: 
 86877:         ptrdiff_t off = GET_JUMP_OFFSET(pc);
 86877:         jsbytecode *pc2 = pc + JUMP_OFFSET_LEN;
     1:         npairs = GET_UINT16(pc2);
     1:         pc2 += UINT16_LEN;
 91237:         Sprint(sp, " offset %d npairs %u", int(off), unsigned(npairs));
     1:         while (npairs) {
 90965:             uint32_t constIndex = GET_UINT32_INDEX(pc2);
 90965:             pc2 += UINT32_INDEX_LEN;
 86877:             off = GET_JUMP_OFFSET(pc2);
 86877:             pc2 += JUMP_OFFSET_LEN;
     1: 
 57812:             JSAutoByteString bytes;
 78614:             if (!ToDisassemblySource(cx, script->getConst(constIndex), &bytes))
     1:                 return 0;
 91237:             Sprint(sp, "\n\t%s: %d", bytes.ptr(), int(off));
     1:             npairs--;
     1:         }
     1:         len = 1 + pc2 - pc;
     1:         break;
     1:       }
     1: 
     1:       case JOF_QARG:
 64374:         Sprint(sp, " %u", GET_ARGNO(pc));
     1:         break;
     1: 
 16429:       case JOF_LOCAL:
 64374:         Sprint(sp, " %u", GET_SLOTNO(pc));
     1:         break;
     1: 
 57812:       case JOF_SLOTOBJECT: {
 64374:         Sprint(sp, " %u", GET_SLOTNO(pc));
 89253:         JSObject *obj = script->getObject(GET_UINT32_INDEX(pc + SLOTNO_LEN));
 57812:         JSAutoByteString bytes;
 89253:         if (!ToDisassemblySource(cx, ObjectValue(*obj), &bytes))
     1:             return 0;
 64374:         Sprint(sp, " %s", bytes.ptr());
 57812:         break;
 57812:       }
     1: 
 79778:       {
 79778:         int i;
 79778: 
 79778:       case JOF_UINT16PAIR:
 91450:         i = (int)GET_UINT16(pc);
 79778:         Sprint(sp, " %d", i);
 79778:         pc += UINT16_LEN;
 79778:         /* FALL THROUGH */
 79778: 
 79778:       case JOF_UINT16:
 91450:         i = (int)GET_UINT16(pc);
 79778:         goto print_int;
 79778: 
     1:       case JOF_UINT24:
 15279:         JS_ASSERT(op == JSOP_UINT24 || op == JSOP_NEWARRAY);
 91450:         i = (int)GET_UINT24(pc);
  3328:         goto print_int;
  3328: 
 17899:       case JOF_UINT8:
 87974:         i = GET_UINT8(pc);
 17899:         goto print_int;
 17899: 
  3328:       case JOF_INT8:
  3328:         i = GET_INT8(pc);
  3328:         goto print_int;
  3328: 
  3328:       case JOF_INT32:
  3328:         JS_ASSERT(op == JSOP_INT32);
  3328:         i = GET_INT32(pc);
  3328:       print_int:
 64374:         Sprint(sp, " %d", i);
     1:         break;
 79778:       }
     1: 
     1:       default: {
     1:         char numBuf[12];
     1:         JS_snprintf(numBuf, sizeof numBuf, "%lx", (unsigned long) cs->format);
     1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
     1:                              JSMSG_UNKNOWN_FORMAT, numBuf);
     1:         return 0;
     1:       }
     1:     }
 90229:     sp->put("\n");
     1:     return len;
     1: }
     1: 
     1: #endif /* DEBUG */
     1: 
     1: /************************************************************************/
     1: 
 87952: const size_t Sprinter::DefaultSize = 64;
 87952: 
 87952: bool
 87952: Sprinter::realloc_(size_t newSize)
     1: {
 87952:     JS_ASSERT(newSize > (size_t) offset);
 87952:     char *newBuf = (char *) context->realloc_(base, newSize);
 87952:     if (!newBuf)
 87952:         return false;
 87952:     base = newBuf;
 87952:     size = newSize;
 87952:     base[size - 1] = 0;
 87952:     return true;
 87952: }
 87952: 
 87952: Sprinter::Sprinter(JSContext *cx)
 87952:   : context(cx),
 87952: #ifdef DEBUG
 87952:     initialized(false),
 87952: #endif
 87952:     base(NULL), size(0), offset(0)
 87952: { }
 87952: 
 87952: Sprinter::~Sprinter()
 87952: {
 87952: #ifdef DEBUG
 87952:     if (initialized)
 87952:         checkInvariants();
 87952: #endif
 87952:     context->free_(base);
 87952: }
 87952: 
 87952: bool
 87952: Sprinter::init()
 87952: {
 87952:     JS_ASSERT(!initialized);
 87952:     base = (char *) context->malloc_(DefaultSize);
 79410:     if (!base)
 87952:         return false;
 87952: #ifdef DEBUG
 87952:     initialized = true;
 87952: #endif
 87952:     *base = 0;
 87952:     size = DefaultSize;
 87952:     base[size - 1] = 0;
 87952:     return true;
 87952: }
 87952: 
 87952: void
 87952: Sprinter::checkInvariants() const
 87952: {
 87952:     JS_ASSERT(initialized);
 87952:     JS_ASSERT((size_t) offset < size);
 87952:     JS_ASSERT(base[size - 1] == 0);
 87952: }
 87952: 
 87952: const char *
 87952: Sprinter::string() const
 87952: {
 87952:     return base;
 87952: }
 87952: 
 87952: const char *
 87952: Sprinter::stringEnd() const
 87952: {
 87952:     return base + offset;
 87952: }
 64374: 
 64374: char *
 87952: Sprinter::stringAt(ptrdiff_t off) const
 64374: {
 87952:     JS_ASSERT(off >= 0 && (size_t) off < size);
 87952:     return base + off;
 87952: }
 87952: 
 87952: char &
 87952: Sprinter::operator[](size_t off)
 87952: {
 94837:     JS_ASSERT(off < size);
 87952:     return *(base + off);
 87952: }
 87952: 
 87952: bool
 87952: Sprinter::empty() const
 87952: {
 87952:     return *base == 0;
 87952: }
 87952: 
 87952: char *
 87952: Sprinter::reserve(size_t len)
 87952: {
 87952:     InvariantChecker ic(this);
 87952: 
 87952:     while (len + 1 > size - offset) { /* Include trailing \0 */
 87952:         if (!realloc_(size * 2))
 64374:             return NULL;
 87952:     }
 87952: 
 87952:     char *sb = base + offset;
 87952:     offset += len;
 87952:     return sb;
 87952: }
 87952: 
 87952: char *
 87952: Sprinter::reserveAndClear(size_t len)
 87952: {
 87952:     char *sb = reserve(len);
 87952:     if (sb)
 87952:         memset(sb, 0, len);
 87952:     return sb;
 64374: }
 64374: 
 64374: ptrdiff_t
 87952: Sprinter::put(const char *s, size_t len)
     1: {
 87952:     InvariantChecker ic(this);
 87952: 
 87952:     const char *oldBase = base;
 87952:     const char *oldEnd = base + size;
 87952: 
 87952:     ptrdiff_t oldOffset = offset;
 87952:     char *bp = reserve(len);
 87952:     if (!bp)
     1:         return -1;
     1: 
 87952:     /* s is within the buffer already */
 87952:     if (s >= oldBase && s < oldEnd) {
 87952:         /* buffer was realloc'ed */
 87952:         if (base != oldBase)
 87952:             s = stringAt(s - oldBase);  /* this is where it lives now */
     1:         memmove(bp, s, len);
 87952:     } else {
 88252:         js_memcpy(bp, s, len);
 87952:     }
 87952: 
     1:     bp[len] = 0;
 87952:     return oldOffset;
 87952: }
 87952: 
 87952: ptrdiff_t
 90229: Sprinter::put(const char *s)
 90229: {
 90229:     return put(s, strlen(s));
 90229: }
 90229: 
 90229: ptrdiff_t
 87952: Sprinter::putString(JSString *s)
 87952: {
 87952:     InvariantChecker ic(this);
 87952: 
 87952:     size_t length = s->length();
 87952:     const jschar *chars = s->getChars(context);
 87952:     if (!chars)
 87952:         return -1;
 87952: 
 87952:     size_t size = GetDeflatedStringLength(context, chars, length);
 87952:     if (size == (size_t) -1)
 87952:         return -1;
 87952: 
 87952:     ptrdiff_t oldOffset = offset;
 87952:     char *buffer = reserve(size);
 87952:     if (!buffer)
 87952:         return -1;
 87952:     DeflateStringToBuffer(context, chars, length, buffer, &size);
 87952:     buffer[size] = 0;
 87952: 
 87952:     return oldOffset;
 87952: }
 87952: 
 87952: int
 87952: Sprinter::printf(const char *fmt, ...)
 87952: {
 87952:     InvariantChecker ic(this);
 87952: 
 87952:     do {
 87952:         va_list va;
 87952:         va_start(va, fmt);
 87952:         int i = vsnprintf(base + offset, size - offset, fmt, va);
 87952:         va_end(va);
 87952: 
 87952:         if (i > -1 && (size_t) i < size - offset) {
 87952:             offset += i;
 87952:             return i;
 87952:         }
 87952:     } while (realloc_(size * 2));
 87952: 
 87952:     return -1;
 87952: }
 87952: 
 87952: void
 87952: Sprinter::setOffset(const char *end)
 87952: {
 87952:     JS_ASSERT(end >= base && end < base + size);
 87952:     offset = end - base;
 87952: }
 87952: 
 87952: void
 87952: Sprinter::setOffset(ptrdiff_t off)
 87952: {
 87952:     JS_ASSERT(off >= 0 && (size_t) off < size);
 87952:     offset = off;
 87952: }
 87952: 
 87952: ptrdiff_t
 87952: Sprinter::getOffset() const
 87952: {
     1:     return offset;
     1: }
     1: 
 64374: ptrdiff_t
 87952: Sprinter::getOffsetOf(const char *string) const
 87952: {
 87952:     JS_ASSERT(string >= base && string < base + size);
 87952:     return string - base;
 87952: }
 87952: 
 87952: ptrdiff_t
 87952: js::Sprint(Sprinter *sp, const char *format, ...)
     1: {
     1:     va_list ap;
     1:     char *bp;
     1:     ptrdiff_t offset;
     1: 
     1:     va_start(ap, format);
     1:     bp = JS_vsmprintf(format, ap);      /* XXX vsaprintf */
     1:     va_end(ap);
     1:     if (!bp) {
     1:         JS_ReportOutOfMemory(sp->context);
     1:         return -1;
     1:     }
 90229:     offset = sp->put(bp);
 64559:     sp->context->free_(bp);
     1:     return offset;
     1: }
     1: 
     1: const char js_EscapeMap[] = {
     1:     '\b', 'b',
     1:     '\f', 'f',
     1:     '\n', 'n',
     1:     '\r', 'r',
     1:     '\t', 't',
     1:     '\v', 'v',
     1:     '"',  '"',
     1:     '\'', '\'',
     1:     '\\', '\\',
 81453:     '\0'
     1: };
     1: 
     1: #define DONT_ESCAPE     0x10000
     1: 
     1: static char *
 84755: QuoteString(Sprinter *sp, JSString *str, uint32_t quote)
     1: {
     1:     /* Sample off first for later return value pointer computation. */
 59890:     JSBool dontEscape = (quote & DONT_ESCAPE) != 0;
 59890:     jschar qc = (jschar) quote;
 87952:     ptrdiff_t offset = sp->getOffset();
     1:     if (qc && Sprint(sp, "%c", (char)qc) < 0)
     1:         return NULL;
     1: 
 59890:     const jschar *s = str->getChars(sp->context);
 59890:     if (!s)
 59890:         return NULL;
 59890:     const jschar *z = s + str->length();
 59890: 
     1:     /* Loop control variables: z points at end of string sentinel. */
 59890:     for (const jschar *t = s; t < z; s = ++t) {
     1:         /* Move t forward from s past un-quote-worthy characters. */
 59890:         jschar c = *t;
 74434:         while (c < 127 && isprint(c) && c != qc && c != '\\' && c != '\t') {
     1:             c = *++t;
     1:             if (t == z)
     1:                 break;
     1:         }
 87952: 
 87952:         {
 59890:             ptrdiff_t len = t - s;
 87952:             ptrdiff_t base = sp->getOffset();
 87952:             char *bp = sp->reserve(len);
 87952:             if (!bp)
     1:                 return NULL;
     1: 
 87952:             for (ptrdiff_t i = 0; i < len; ++i)
 87952:                 (*sp)[base + i] = (char) *s++;
 87952:             (*sp)[base + len] = 0;
 87952:         }
     1: 
     1:         if (t == z)
     1:             break;
     1: 
     1:         /* Use js_EscapeMap, \u, or \x only if necessary. */
 59890:         bool ok;
 59890:         const char *e;
 81426:         if (!(c >> 8) && c != 0 && (e = strchr(js_EscapeMap, (int)c)) != NULL) {
     1:             ok = dontEscape
     1:                  ? Sprint(sp, "%c", (char)c) >= 0
     1:                  : Sprint(sp, "\\%c", e[1]) >= 0;
     1:         } else {
 59958:             /*
 59958:              * Use \x only if the high byte is 0 and we're in a quoted string,
 59958:              * because ECMA-262 allows only \u, not \x, in Unicode identifiers
 59958:              * (see bug 621814).
 59958:              */
 59958:             ok = Sprint(sp, (qc && !(c >> 8)) ? "\\x%02X" : "\\u%04X", c) >= 0;
     1:         }
     1:         if (!ok)
     1:             return NULL;
     1:     }
     1: 
     1:     /* Sprint the closing quote and return the quoted string. */
     1:     if (qc && Sprint(sp, "%c", (char)qc) < 0)
     1:         return NULL;
     1: 
     1:     /*
     1:      * If we haven't Sprint'd anything yet, Sprint an empty string so that
 87952:      * the return below gives a valid result.
     1:      */
 87952:     if (offset == sp->getOffset() && Sprint(sp, "") < 0)
     1:         return NULL;
 87952: 
 87952:     return sp->stringAt(offset);
     1: }
     1: 
     1: JSString *
     1: js_QuoteString(JSContext *cx, JSString *str, jschar quote)
     1: {
 87952:     Sprinter sprinter(cx);
 87952:     if (!sprinter.init())
 87952:         return NULL;
 79410:     char *bytes = QuoteString(&sprinter, str, quote);
 79410:     JSString *escstr = bytes ? JS_NewStringCopyZ(cx, bytes) : NULL;
     1:     return escstr;
     1: }
     1: 
     1: /************************************************************************/
     1: 
 84803: /*
 84803:  * Information for associating the decompilation of each opcode in a script
 84803:  * with the place where it appears in the text for the decompilation of the
 84803:  * entire script (or the function containing the script).
 84803:  */
 84803: struct DecompiledOpcode
 84803: {
 84803:     /* Decompiled text of this opcode. */
 84803:     const char *text;
 84803: 
 84803:     /* Bytecode into which this opcode was nested, or NULL. */
 84803:     jsbytecode *parent;
 84803: 
 84803:     /*
 84803:      * Offset into the parent's decompiled text of the decompiled text of this
 84803:      * opcode. For opcodes with a NULL parent, this was emitted directly into
 84803:      * the permanent output at the given offset.
 84803:      */
 84807:     int32_t parentOffset;
 84803: 
 84803:     /*
 84803:      * Surrounded by parentheses when printed, which parentOffset does not
 84803:      * account for.
 84803:      */
 84803:     bool parenthesized;
 84803: 
 84803:     DecompiledOpcode()
 84803:         : text(NULL), parent(NULL), parentOffset(-1), parenthesized(false)
 84803:     {}
 84803: };
 84803: 
 84803: struct JSPrinter
 84803: {
     1:     Sprinter        sprinter;       /* base class state */
 79410:     LifoAlloc       pool;           /* string allocation pool */
 91237:     unsigned           indent;         /* indentation in spaces */
 35113:     bool            pretty;         /* pretty-print: indent, use newlines */
 35113:     bool            grouped;        /* in parenthesized expression context */
 35113:     bool            strict;         /* in code marked strict */
     1:     JSScript        *script;        /* script being printed */
 12981:     jsbytecode      *dvgfence;      /* DecompileExpression fencepost */
 21808:     jsbytecode      **pcstack;      /* DecompileExpression modeled stack */
 13702:     JSFunction      *fun;           /* interpreted function */
 97297:     BindingNames    *localNames;    /* argument and variable names */
 84803:     Vector<DecompiledOpcode> *decompiledOpcodes; /* optional state for decompiled ops */
 84803: 
 84803:     DecompiledOpcode &decompiled(jsbytecode *pc) {
 84803:         JS_ASSERT(decompiledOpcodes);
 84803:         return (*decompiledOpcodes)[pc - script->code];
 84803:     }
     1: };
     1: 
     1: JSPrinter *
 35112: js_NewPrinter(JSContext *cx, const char *name, JSFunction *fun,
 91237:               unsigned indent, JSBool pretty, JSBool grouped, JSBool strict)
     1: {
 79410:     JSPrinter *jp = (JSPrinter *) cx->malloc_(sizeof(JSPrinter));
     1:     if (!jp)
     1:         return NULL;
 87952:     new (&jp->sprinter) Sprinter(cx);
 87952:     if (!jp->sprinter.init())
 87952:         return NULL;
 79410:     new (&jp->pool) LifoAlloc(1024);
 35040:     jp->indent = indent;
 40439:     jp->pretty = !!pretty;
 40439:     jp->grouped = !!grouped;
 40439:     jp->strict = !!strict;
     1:     jp->script = NULL;
     1:     jp->dvgfence = NULL;
 12981:     jp->pcstack = NULL;
 13702:     jp->fun = fun;
  8179:     jp->localNames = NULL;
 84803:     jp->decompiledOpcodes = NULL;
 95100:     if (fun && fun->isInterpreted() && fun->script()->bindings.count() > 0) {
 97297:         jp->localNames = cx->new_<BindingNames>(cx);
 73058:         if (!jp->localNames || !fun->script()->bindings.getLocalNameArray(cx, jp->localNames)) {
 13702:             js_DestroyPrinter(jp);
 13702:             return NULL;
 13702:         }
 13702:     }
     1:     return jp;
     1: }
     1: 
 61225: void
     1: js_DestroyPrinter(JSPrinter *jp)
     1: {
 90598:     JSContext *cx = jp->sprinter.context;
 79410:     jp->pool.freeAll();
 73058:     Foreground::delete_(jp->localNames);
 90598:     jp->sprinter.Sprinter::~Sprinter();
 90598:     cx->free_(jp);
     1: }
     1: 
     1: JSString *
     1: js_GetPrinterOutput(JSPrinter *jp)
     1: {
 84803:     JSContext *cx = jp->sprinter.context;
 87952:     return JS_NewStringCopyZ(cx, jp->sprinter.string());
 84803: }
 84803: 
 84803: /* Mark the parent and offset into the parent's text for a printed opcode. */
 84803: static inline void
 84803: UpdateDecompiledParent(JSPrinter *jp, jsbytecode *pc, jsbytecode *parent, size_t offset)
 84803: {
 84803:     if (jp->decompiledOpcodes && pc) {
 84803:         jp->decompiled(pc).parent = parent;
 84803:         jp->decompiled(pc).parentOffset = offset;
 84803:     }
     1: }
     1: 
  2016: /*
 80964:  * NB: Indexed by SRC_DECL_* defines from frontend/BytecodeEmitter.h.
  2016:  */
  2016: static const char * const var_prefix[] = {"var ", "const ", "let "};
  2016: 
  2016: static const char *
  2016: VarPrefix(jssrcnote *sn)
  2016: {
  2016:     if (sn && (SN_TYPE(sn) == SRC_DECL || SN_TYPE(sn) == SRC_GROUPASSIGN)) {
  2016:         ptrdiff_t type = js_GetSrcNoteOffset(sn, 0);
 91237:         if ((unsigned)type <= SRC_DECL_LET)
  2016:             return var_prefix[type];
  2016:     }
  2016:     return "";
  2016: }
  2016: 
     1: int
     1: js_printf(JSPrinter *jp, const char *format, ...)
     1: {
     1:     va_list ap;
     1:     char *bp, *fp;
     1:     int cc;
     1: 
     1:     if (*format == '\0')
     1:         return 0;
     1: 
     1:     va_start(ap, format);
     1: 
     1:     /* If pretty-printing, expand magic tab into a run of jp->indent spaces. */
     1:     if (*format == '\t') {
     1:         format++;
 35342:         if (jp->pretty && Sprint(&jp->sprinter, "%*s", jp->indent, "") < 0) {
 35342:             va_end(ap);
     1:             return -1;
     1:         }
 35342:     }
     1: 
     1:     /* Suppress newlines (must be once per format, at the end) if not pretty. */
     1:     fp = NULL;
     1:     if (!jp->pretty && format[cc = strlen(format) - 1] == '\n') {
     1:         fp = JS_strdup(jp->sprinter.context, format);
 35342:         if (!fp) {
 35342:             va_end(ap);
     1:             return -1;
 35342:         }
     1:         fp[cc] = '\0';
     1:         format = fp;
     1:     }
     1: 
     1:     /* Allocate temp space, convert format, and put. */
     1:     bp = JS_vsmprintf(format, ap);      /* XXX vsaprintf */
     1:     if (fp) {
 64560:         jp->sprinter.context->free_(fp);
     1:         format = NULL;
     1:     }
     1:     if (!bp) {
     1:         JS_ReportOutOfMemory(jp->sprinter.context);
 35342:         va_end(ap);
     1:         return -1;
     1:     }
     1: 
     1:     cc = strlen(bp);
 90229:     if (jp->sprinter.put(bp, (size_t)cc) < 0)
     1:         cc = -1;
 64560:     jp->sprinter.context->free_(bp);
     1: 
     1:     va_end(ap);
     1:     return cc;
     1: }
     1: 
     1: JSBool
     1: js_puts(JSPrinter *jp, const char *s)
     1: {
 90229:     return jp->sprinter.put(s) >= 0;
     1: }
     1: 
     1: /************************************************************************/
     1: 
 84803: struct SprintStack
 84803: {
     1:     Sprinter    sprinter;       /* sprinter for postfix to infix buffering */
     1:     ptrdiff_t   *offsets;       /* stack of postfix string offsets */
     1:     jsbytecode  *opcodes;       /* parallel stack of JS opcodes */
 84803:     jsbytecode  **bytecodes;    /* actual script bytecode pushing the value */
 91237:     unsigned       top;            /* top of stack index */
 91237:     unsigned       inArrayInit;    /* array initialiser/comprehension level */
  1577:     JSBool      inGenExp;       /* in generator expression */
     1:     JSPrinter   *printer;       /* permanent output goes here */
 87952: 
 87952:     explicit SprintStack(JSContext *cx)
 87952:       : sprinter(cx), offsets(NULL),
 87952:         opcodes(NULL), bytecodes(NULL), top(0), inArrayInit(0),
 87952:         inGenExp(JS_FALSE), printer(NULL)
 87952:     { }
 84803: };
 84803: 
 84803: /*
 84803:  * Set the decompiled text of an opcode, according to an offset into the
 84803:  * print stack's sprinter buffer.
 84803:  */
 84803: static inline bool
 84803: UpdateDecompiledText(SprintStack *ss, jsbytecode *pc, ptrdiff_t todo)
 84803: {
 84803:     JSPrinter *jp = ss->printer;
 84803: 
 84803:     if (jp->decompiledOpcodes && jp->decompiled(pc).text == NULL) {
 87952:         const char *text = ss->sprinter.stringAt(todo);
 84803:         size_t len = strlen(text) + 1;
 84803: 
 87623:         char *ntext = ss->printer->pool.newArrayUninitialized<char>(len);
 84803:         if (!ntext) {
 84803:             js_ReportOutOfMemory(ss->sprinter.context);
 84803:             return false;
 84803:         }
 84803: 
 87623:         js_memcpy(ntext, text, len);
 87623:         jp->decompiled(pc).text = const_cast<const char *>(ntext);
 84803:     }
 84803: 
 84803:     return true;
 84803: }
 84803: 
 84803: static inline const char *
 84803: SprintDupeStr(SprintStack *ss, const char *str)
 84803: {
 84803:     size_t len = strlen(str) + 1;
 84803: 
 84803:     const char *nstr = ss->printer->pool.newArrayUninitialized<char>(len);
 84803:     if (nstr) {
 87623:         js_memcpy((char *) nstr, str, len);
 84803:     } else {
 84803:         js_ReportOutOfMemory(ss->sprinter.context);
 84803:         nstr = "";
 84803:     }
 84803: 
 84803:     return nstr;
 84803: }
 84803: 
 84803: /* Place an opcode's decompiled text into a printer's permanent output. */
 84803: static inline void
 84803: SprintOpcodePermanent(JSPrinter *jp, const char *str, jsbytecode *pc)
 84803: {
 87952:     ptrdiff_t offset = jp->sprinter.getOffset();
 87952:     UpdateDecompiledParent(jp, pc, NULL, offset);
 84803:     js_printf(jp, "%s", str);
 84803: }
 84803: 
 84803: /*
 84803:  * Place an opcode's decompiled text into the printed output for another
 84803:  * opcode parentpc, where startOffset indicates the printer offset for the
 84803:  * start of parentpc.
 84803:  */
 84803: static inline void
 84803: SprintOpcode(SprintStack *ss, const char *str, jsbytecode *pc,
 84803:              jsbytecode *parentpc, ptrdiff_t startOffset)
 84803: {
 84803:     if (startOffset < 0) {
 84803:         JS_ASSERT(ss->sprinter.context->isExceptionPending());
 84803:         return;
 84803:     }
 87952:     ptrdiff_t offset = ss->sprinter.getOffset();
 87952:     UpdateDecompiledParent(ss->printer, pc, parentpc, offset - startOffset);
 90229:     ss->sprinter.put(str);
 84803: }
 84803: 
 84803: /*
 84803:  * Copy the decompiled text for an opcode to all other ops which it was
 84803:  * decomposed into.
 84803:  */
 84803: static inline void
 84803: CopyDecompiledTextForDecomposedOp(JSPrinter *jp, jsbytecode *pc)
 84803: {
 84803:     JS_ASSERT(js_CodeSpec[*pc].format & JOF_DECOMPOSE);
 84803: 
 84803:     if (jp->decompiledOpcodes) {
 84803:         size_t len = GetDecomposeLength(pc, js_CodeSpec[*pc].length);
 84803: 
 84803:         const char *text = jp->decompiled(pc).text;
 84803: 
 84803:         jsbytecode *pc2 = pc + GetBytecodeLength(pc);
 84803:         for (; pc2 < pc + len; pc2 += GetBytecodeLength(pc2)) {
 84803:             jp->decompiled(pc2).text = text;
 84803:             jp->decompiled(pc2).parent = pc;
 84803:             jp->decompiled(pc2).parentOffset = 0;
 84803:         }
 84803:     }
 84803: }
     1: 
     1: /*
 12981:  * Find the depth of the operand stack when the interpreter reaches the given
 12981:  * pc in script. pcstack must have space for least script->depth elements. On
 12981:  * return it will contain pointers to opcodes that populated the interpreter's
 12981:  * current operand stack.
 12981:  *
 12981:  * This function cannot raise an exception or error. However, due to a risk of
 12981:  * potential bugs when modeling the stack, the function returns -1 if it
 12981:  * detects an inconsistency in the model. Such an inconsistency triggers an
 12981:  * assert in a debug build.
 12981:  */
 91237: static int
 12981: ReconstructPCStack(JSContext *cx, JSScript *script, jsbytecode *pc,
 84117:                    jsbytecode **pcstack, jsbytecode **lastDecomposedPC);
 12981: 
 12981: #define FAILED_EXPRESSION_DECOMPILER ((char *) 1)
 12981: 
 12981: /*
 12981:  * Decompile a part of expression up to the given pc. The function returns
 12981:  * NULL on out-of-memory, or the FAILED_EXPRESSION_DECOMPILER sentinel when
 12981:  * the decompiler fails due to a bug and/or unimplemented feature, or the
 12981:  * decompiled string on success.
 12981:  */
 12981: static char *
 13702: DecompileExpression(JSContext *cx, JSScript *script, JSFunction *fun,
 12981:                     jsbytecode *pc);
 12981: 
 12981: /*
     1:  * Get a stacked offset from ss->sprinter.base, or if the stacked value |off|
 12981:  * is negative, fetch the generating pc from printer->pcstack[-2 - off] and
 12981:  * decompile the code that generated the missing value.  This is used when
     1:  * reporting errors, where the model stack will lack |pcdepth| non-negative
 12981:  * offsets (see DecompileExpression and DecompileCode).
     1:  *
     1:  * If the stacked offset is -1, return 0 to index the NUL padding at the start
     1:  * of ss->sprinter.base.  If this happens, it means there is a decompiler bug
     1:  * to fix, but it won't violate memory safety.
     1:  */
     1: static ptrdiff_t
 91237: GetOff(SprintStack *ss, unsigned i)
     1: {
     1:     ptrdiff_t off;
 12981:     jsbytecode *pc;
     1:     char *bytes;
     1: 
     1:     off = ss->offsets[i];
 12981:     if (off >= 0)
 12981:         return off;
 12981: 
 12981:     JS_ASSERT(ss->printer->pcstack);
 23230:     if (off <= -2 && ss->printer->pcstack) {
 12981:         pc = ss->printer->pcstack[-2 - off];
 12981:         bytes = DecompileExpression(ss->sprinter.context, ss->printer->script,
 12981:                                     ss->printer->fun, pc);
     1:         if (!bytes)
     1:             return 0;
 12981:         if (bytes != FAILED_EXPRESSION_DECOMPILER) {
 90229:             off = ss->sprinter.put(bytes);
     1:             if (off < 0)
     1:                 off = 0;
     1:             ss->offsets[i] = off;
 64560:             ss->sprinter.context->free_(bytes);
     1:             return off;
     1:         }
 87952: 
 87952:         if (!*ss->sprinter.string()) {
 87952:             memset(ss->sprinter.stringAt(0), 0, ss->sprinter.getOffset());
 12981:             ss->offsets[i] = -1;
 12981:         }
 12981:     }
 12981:     return 0;
 12981: }
     1: 
     1: static const char *
 91237: GetStr(SprintStack *ss, unsigned i)
     1: {
 87952:     ptrdiff_t off = GetOff(ss, i);
 87952:     return ss->sprinter.stringAt(off);
     1: }
     1: 
 15279: /*
 15279:  * Gap between stacked strings to allow for insertion of parens and commas
 58056:  * when auto-parenthesizing expressions and decompiling array initialisers.
 15279:  */
     1: #define PAREN_SLOP      (2 + 1)
     1: 
 58070: /* Fake opcodes (see jsopcode.h) must not overflow unsigned 8-bit space. */
 58070: JS_STATIC_ASSERT(JSOP_FAKE_LIMIT <= 255);
     1: 
 87952: static inline void
  1577: AddParenSlop(SprintStack *ss)
  1577: {
 87952:     ss->sprinter.reserveAndClear(PAREN_SLOP);
  1577: }
  1577: 
     1: static JSBool
 84803: PushOff(SprintStack *ss, ptrdiff_t off, JSOp op, jsbytecode *pc = NULL)
     1: {
 91237:     unsigned top;
     1: 
     1:     /* ss->top points to the next free slot; be paranoid about overflow. */
     1:     top = ss->top;
 16072:     JS_ASSERT(top < StackDepth(ss->printer->script));
 16072:     if (top >= StackDepth(ss->printer->script)) {
     1:         JS_ReportOutOfMemory(ss->sprinter.context);
     1:         return JS_FALSE;
     1:     }
     1: 
     1:     /* The opcodes stack must contain real bytecodes that index js_CodeSpec. */
     1:     ss->offsets[top] = off;
 26751:     ss->opcodes[top] = jsbytecode((op == JSOP_GETPROP2) ? JSOP_GETPROP
 26751:                                 : (op == JSOP_GETELEM2) ? JSOP_GETELEM
 26751:                                 : op);
 84803:     ss->bytecodes[top] = pc;
     1:     ss->top = ++top;
 87952: 
  1577:     AddParenSlop(ss);
     1:     return JS_TRUE;
     1: }
     1: 
 86078: static bool
 86078: PushStr(SprintStack *ss, const char *str, JSOp op)
 86078: {
 90229:     ptrdiff_t off = ss->sprinter.put(str);
 86078:     if (off < 0)
 86078:         return false;
 86078:     return PushOff(ss, off, op);
 86078: }
 86078: 
     1: static ptrdiff_t
 84803: PopOffPrec(SprintStack *ss, uint8_t prec, jsbytecode **ppc = NULL)
     1: {
 91237:     unsigned top;
 20928:     const JSCodeSpec *topcs;
     1:     ptrdiff_t off;
     1: 
 84803:     if (ppc)
 84803:         *ppc = NULL;
 84803: 
     1:     /* ss->top points to the next free slot; be paranoid about underflow. */
     1:     top = ss->top;
     1:     JS_ASSERT(top != 0);
     1:     if (top == 0)
     1:         return 0;
     1: 
     1:     ss->top = --top;
     1:     off = GetOff(ss, top);
 98643: 
 98643:     int op = ss->opcodes[top];
 98643:     if (op >= JSOP_LIMIT)
 98643:         op = JSOP_NOP;
 98643:     topcs = &js_CodeSpec[op];
 84803: 
 84803:     jsbytecode *pc = ss->bytecodes[top];
 84803:     if (ppc)
 84803:         *ppc = pc;
 84803: 
 20928:     if (topcs->prec != 0 && topcs->prec < prec) {
 87952:         ss->offsets[top] = off - 2;
 87952:         ss->sprinter.setOffset(off - 2);
 87952:         off = Sprint(&ss->sprinter, "(%s)", ss->sprinter.stringAt(off));
 84803:         if (ss->printer->decompiledOpcodes && pc)
 84803:             ss->printer->decompiled(pc).parenthesized = true;
     1:     } else {
 87952:         ss->sprinter.setOffset(off);
     1:     }
     1:     return off;
     1: }
     1: 
     1: static const char *
 84803: PopStrPrec(SprintStack *ss, uint8_t prec, jsbytecode **ppc = NULL)
 20928: {
 20928:     ptrdiff_t off;
 20928: 
 84803:     off = PopOffPrec(ss, prec, ppc);
 87952:     return ss->sprinter.stringAt(off);
 20928: }
 20928: 
 84803: /*
 84803:  * As for PopStrPrec, but duplicates the string into the printer's arena.
 84803:  * Strings returned by PopStrPrec are otherwise invalidated if any new text
 84803:  * is printed into ss.
 84803:  */
 84803: static const char *
 84807: PopStrPrecDupe(SprintStack *ss, uint8_t prec, jsbytecode **ppc = NULL)
 84803: {
 84803:     const char *str = PopStrPrec(ss, prec, ppc);
 84803:     return SprintDupeStr(ss, str);
 84803: }
 84803: 
 20928: static ptrdiff_t
 84803: PopOff(SprintStack *ss, JSOp op, jsbytecode **ppc = NULL)
 20928: {
 84803:     return PopOffPrec(ss, js_CodeSpec[op].prec, ppc);
 20928: }
 20928: 
 20928: static const char *
 84803: PopStr(SprintStack *ss, JSOp op, jsbytecode **ppc = NULL)
     1: {
 84803:     return PopStrPrec(ss, js_CodeSpec[op].prec, ppc);
 84803: }
 84803: 
 84803: static const char *
 84803: PopStrDupe(SprintStack *ss, JSOp op, jsbytecode **ppc = NULL)
 84803: {
 84803:     return PopStrPrecDupe(ss, js_CodeSpec[op].prec, ppc);
 84803: }
 84803: 
 84803: /*
 84803:  * Pop a condition expression for if/while. JSOP_IFEQ's precedence forces
 84803:  * extra parens around assignment, which avoids a strict-mode warning.
 84803:  */
 84803: static const char *
 84803: PopCondStr(SprintStack *ss, jsbytecode **ppc = NULL)
 84803: {
 84803:     JSOp op = (js_CodeSpec[ss->opcodes[ss->top - 1]].format & JOF_SET)
 84803:               ? JSOP_IFEQ
 84803:               : JSOP_NOP;
 84803:     return PopStr(ss, op, ppc);
     1: }
     1: 
 58056: static inline bool
 58056: IsInitializerOp(unsigned char op)
 58056: {
 58056:     return op == JSOP_NEWINIT || op == JSOP_NEWARRAY || op == JSOP_NEWOBJECT;
 58056: }
 58056: 
 82461: struct TableEntry {
     1:     jsval       key;
     1:     ptrdiff_t   offset;
     1:     JSAtom      *label;
 91450:     int         order;          /* source order for stable tableswitch sort */
 82461: };
 82461: 
 82461: inline bool
 82461: CompareTableEntries(const TableEntry &a, const TableEntry &b, bool *lessOrEqualp)
     1: {
 82461:     *lessOrEqualp = (a.offset != b.offset) ? a.offset <= b.offset : a.order <= b.order;
 82461:     return true;
 82460: }
     1: 
   259: static ptrdiff_t
   259: SprintDoubleValue(Sprinter *sp, jsval v, JSOp *opp)
   259: {
 90955:     double d;
   259:     ptrdiff_t todo;
 53852:     char *s;
   259: 
   259:     JS_ASSERT(JSVAL_IS_DOUBLE(v));
 48470:     d = JSVAL_TO_DOUBLE(v);
 95341:     if (MOZ_DOUBLE_IS_NEGATIVE_ZERO(d)) {
 90229:         todo = sp->put("-0");
   259:         *opp = JSOP_NEG;
 95341:     } else if (!MOZ_DOUBLE_IS_FINITE(d)) {
 90229:         /* Don't use Infinity and NaN, as local variables may shadow them. */
 95341:         todo = sp->put(MOZ_DOUBLE_IS_NaN(d)
   259:                        ? "0 / 0"
   259:                        : (d < 0)
   259:                        ? "1 / -0"
   259:                        : "1 / 0");
   259:         *opp = JSOP_DIV;
   259:     } else {
 53852:         ToCStringBuf cbuf;
 53852:         s = NumberToCString(sp->context, &cbuf, d);
   259:         if (!s) {
   259:             JS_ReportOutOfMemory(sp->context);
   259:             return -1;
   259:         }
 93382:         JS_ASSERT(strcmp(s, "Infinity") &&
   259:                   (*s != '-' ||
 93382:                    strcmp(s + 1, "Infinity")) &&
 93382:                   strcmp(s, "NaN"));
   259:         todo = Sprint(sp, s);
   259:     }
   259:     return todo;
   259: }
   259: 
     1: static jsbytecode *
 91237: Decompile(SprintStack *ss, jsbytecode *pc, int nb);
     1: 
     1: static JSBool
 91237: DecompileSwitch(SprintStack *ss, TableEntry *table, unsigned tableLength,
     1:                 jsbytecode *pc, ptrdiff_t switchLength,
     1:                 ptrdiff_t defaultOffset, JSBool isCondSwitch)
     1: {
     1:     JSContext *cx;
     1:     JSPrinter *jp;
   259:     ptrdiff_t off, off2, diff, caseExprOff, todo;
 87952:     const char *rval;
 91237:     unsigned i;
     1:     jsval key;
     1:     JSString *str;
     1: 
     1:     cx = ss->sprinter.context;
     1:     jp = ss->printer;
     1: 
 84803:     jsbytecode *lvalpc;
 84803:     const char *lval = PopStr(ss, JSOP_NOP, &lvalpc);
 84803: 
     1:     /* JSOP_CONDSWITCH doesn't pop, unlike JSOP_{LOOKUP,TABLE}SWITCH. */
 84803:     if (isCondSwitch)
 84803:         ss->top++;
 84803: 
 84803:     js_printf(jp, "\tswitch (");
 84803:     SprintOpcodePermanent(jp, lval, lvalpc);
 84803:     js_printf(jp, ") {\n");
     1: 
     1:     if (tableLength) {
     1:         diff = table[0].offset - defaultOffset;
     1:         if (diff > 0) {
     1:             jp->indent += 2;
     1:             js_printf(jp, "\t%s:\n", js_default_str);
     1:             jp->indent += 2;
 81589:             if (!Decompile(ss, pc + defaultOffset, diff))
     1:                 return JS_FALSE;
     1:             jp->indent -= 4;
     1:         }
     1: 
     1:         caseExprOff = isCondSwitch ? JSOP_CONDSWITCH_LENGTH : 0;
     1: 
     1:         for (i = 0; i < tableLength; i++) {
     1:             off = table[i].offset;
     1:             off2 = (i + 1 < tableLength) ? table[i + 1].offset : switchLength;
     1: 
     1:             key = table[i].key;
     1:             if (isCondSwitch) {
     1:                 ptrdiff_t nextCaseExprOff;
     1: 
     1:                 /*
     1:                  * key encodes the JSOP_CASE bytecode's offset from switchtop.
     1:                  * The next case expression follows immediately, unless we are
     1:                  * at the last case.
     1:                  */
     1:                 nextCaseExprOff = (ptrdiff_t)JSVAL_TO_INT(key);
     1:                 nextCaseExprOff += js_CodeSpec[pc[nextCaseExprOff]].length;
     1:                 jp->indent += 2;
 81589:                 if (!Decompile(ss, pc + caseExprOff, nextCaseExprOff - caseExprOff))
     1:                     return JS_FALSE;
     1:                 caseExprOff = nextCaseExprOff;
     1: 
     1:                 /* Balance the stack as if this JSOP_CASE matched. */
     1:                 --ss->top;
     1:             } else {
     1:                 /*
     1:                  * key comes from an atom, not the decompiler, so we need to
     1:                  * quote it if it's a string literal.  But if table[i].label
     1:                  * is non-null, key was constant-propagated and label is the
     1:                  * name of the const we should show as the case label.  We set
     1:                  * key to undefined so this identifier is escaped, if required
     1:                  * by non-ASCII characters, but not quoted, by QuoteString.
     1:                  */
   259:                 todo = -1;
     1:                 if (table[i].label) {
 64345:                     str = table[i].label;
     1:                     key = JSVAL_VOID;
   259:                 } else if (JSVAL_IS_DOUBLE(key)) {
   259:                     JSOp junk;
   259: 
   259:                     todo = SprintDoubleValue(&ss->sprinter, key, &junk);
 71375:                     if (todo < 0)
 71375:                         return JS_FALSE;
   259:                     str = NULL;
     1:                 } else {
 84160:                     str = ToString(cx, key);
     1:                     if (!str)
     1:                         return JS_FALSE;
     1:                 }
   259:                 if (todo >= 0) {
 87952:                     rval = ss->sprinter.stringAt(todo);
   259:                 } else {
   259:                     rval = QuoteString(&ss->sprinter, str, (jschar)
   259:                                        (JSVAL_IS_STRING(key) ? '"' : 0));
     1:                     if (!rval)
     1:                         return JS_FALSE;
   259:                 }
 87952:                 ss->sprinter.setOffset(rval);
     1:                 jp->indent += 2;
     1:                 js_printf(jp, "\tcase %s:\n", rval);
     1:             }
     1: 
     1:             jp->indent += 2;
     1:             if (off <= defaultOffset && defaultOffset < off2) {
     1:                 diff = defaultOffset - off;
     1:                 if (diff != 0) {
 81589:                     if (!Decompile(ss, pc + off, diff))
     1:                         return JS_FALSE;
     1:                     off = defaultOffset;
     1:                 }
     1:                 jp->indent -= 2;
     1:                 js_printf(jp, "\t%s:\n", js_default_str);
     1:                 jp->indent += 2;
     1:             }
 81589:             if (!Decompile(ss, pc + off, off2 - off))
     1:                 return JS_FALSE;
     1:             jp->indent -= 4;
     1: 
     1:             /* Re-balance as if last JSOP_CASE or JSOP_DEFAULT mismatched. */
     1:             if (isCondSwitch)
     1:                 ++ss->top;
     1:         }
     1:     }
     1: 
     1:     if (defaultOffset == switchLength) {
     1:         jp->indent += 2;
     1:         js_printf(jp, "\t%s:;\n", js_default_str);
     1:         jp->indent -= 2;
     1:     }
     1:     js_printf(jp, "\t}\n");
     1: 
     1:     /* By the end of a JSOP_CONDSWITCH, the discriminant has been popped. */
     1:     if (isCondSwitch)
     1:         --ss->top;
     1:     return JS_TRUE;
     1: }
     1: 
 18594: #define LOCAL_ASSERT_CUSTOM(expr, BAD_EXIT)                                   \
     1:     JS_BEGIN_MACRO                                                            \
     1:         JS_ASSERT(expr);                                                      \
 18594:         if (!(expr)) { BAD_EXIT; }                                            \
     1:     JS_END_MACRO
     1: 
 18594: #define LOCAL_ASSERT_RV(expr, rv)                                             \
 18594:     LOCAL_ASSERT_CUSTOM(expr, return (rv))
 18594: 
  8179: static JSAtom *
 91237: GetArgOrVarAtom(JSPrinter *jp, unsigned slot)
  8179: {
  8179:     LOCAL_ASSERT_RV(jp->fun, NULL);
 95100:     LOCAL_ASSERT_RV(slot < jp->fun->script()->bindings.count(), NULL);
 97297:     JSAtom *name = (*jp->localNames)[slot].maybeAtom;
  8179: #if !JS_HAS_DESTRUCTURING
  8179:     LOCAL_ASSERT_RV(name, NULL);
  8179: #endif
  8179:     return name;
  8179: }
  8179: 
 83365: #define LOCAL_ASSERT(expr)      LOCAL_ASSERT_RV(expr, "")
 83365: 
 83365: static const char *
 91450: GetLocalInSlot(SprintStack *ss, int i, int slot, JSObject *obj)
 83365: {
 83365:     for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
 83365:         const Shape &shape = r.front();
 83365: 
 83371:         if (shape.shortid() == slot) {
 86078:             /* Ignore the empty destructuring dummy. */
 86078:             if (!JSID_IS_ATOM(shape.propid()))
 86078:                 continue;
 83371: 
 83371:             JSAtom *atom = JSID_TO_ATOM(shape.propid());
 83365:             const char *rval = QuoteString(&ss->sprinter, atom, 0);
 83365:             if (!rval)
 83365:                 return NULL;
 83365: 
 87952:             ss->sprinter.setOffset(rval);
 83365:             return rval;
 83365:         }
 83365:     }
 83365: 
 83365:     return GetStr(ss, i);
 83365: }
 83365: 
     1: const char *
 91450: GetLocal(SprintStack *ss, int i)
     1: {
 52503:     ptrdiff_t off = ss->offsets[i];
     1:     if (off >= 0)
 87952:         return ss->sprinter.stringAt(off);
     1: 
     1:     /*
     1:      * We must be called from js_DecompileValueGenerator (via Decompile) when
  3235:      * dereferencing a local that's undefined or null. Search script->objects
     1:      * for the block containing this local by its stack index, i.
 23230:      *
 23230:      * In case of destructuring's use of JSOP_GETLOCAL, however, there may be
 23230:      * no such local. This could mean no blocks (no script objects at all, or
 23230:      * none of the script's object literals are blocks), or the stack slot i is
 23230:      * not in a block. In either case, return GetStr(ss, i).
     1:      */
 52503:     JSScript *script = ss->printer->script;
 97361:     if (!script->hasObjects())
 23230:         return GetStr(ss, i);
 52503: 
 83365:     // In case of a let variable, the stack points to a JSOP_ENTERBLOCK opcode.
 83365:     // Get the object number from the block instead of iterating all objects and
 83365:     // hoping the right object is found.
 83365:     if (off <= -2 && ss->printer->pcstack) {
 83365:         jsbytecode *pc = ss->printer->pcstack[-2 - off];
 83365: 
 83365:         JS_ASSERT(ss->printer->script->code <= pc);
 83365:         JS_ASSERT(pc < (ss->printer->script->code + ss->printer->script->length));
 83365: 
 83365:         if (JSOP_ENTERBLOCK == (JSOp)*pc) {
 89253:             JSObject *obj = script->getObject(GET_UINT32_INDEX(pc));
 83365: 
 52503:             if (obj->isBlock()) {
 86483:                 uint32_t depth = obj->asBlock().stackDepth();
 86483:                 uint32_t count = obj->asBlock().slotCount();
 91688:                 if (uint32_t(i - depth) < uint32_t(count))
 91450:                     return GetLocalInSlot(ss, i, int(i - depth), obj);
 83365:             }
 83365:         }
 83365:     }
 83365: 
 83365:     // Iterate over all objects.
 83365:     for (jsatomid j = 0, n = script->objects()->length; j != n; j++) {
 83365:         JSObject *obj = script->getObject(j);
 83365: 
 83365:         if (obj->isBlock()) {
 86483:             uint32_t depth = obj->asBlock().stackDepth();
 86483:             uint32_t count = obj->asBlock().slotCount();
 91688:             if (uint32_t(i - depth) < uint32_t(count))
 91450:                 return GetLocalInSlot(ss, i, int(i - depth), obj);
 52503:         }
 52503:     }
 52503: 
 52503:     return GetStr(ss, i);
 83365: }
     1: 
     1: #undef LOCAL_ASSERT
     1: 
 95101: /*
 95101:  * If IsVarSlot returns true, the var's atom is returned in *varAtom.
 95101:  * If IsVarSlot returns false (indicating that this is a get of a let binding),
 95101:  * the stack depth of the associated slot is returned in *localSlot.
 95101:  */
 95101: static bool
 95101: IsVarSlot(JSPrinter *jp, jsbytecode *pc, JSAtom **varAtom, int *localSlot)
 16429: {
 95101:     if (JOF_OPTYPE(*pc) == JOF_SCOPECOORD) {
100006:         *varAtom = ScopeCoordinateAtom(jp->script, pc);
 95101:         LOCAL_ASSERT_RV(*varAtom, NULL);
 95101:         return true;
 95101:     }
 95101: 
 95101:     unsigned slot = GET_SLOTNO(pc);
 16429:     if (slot < jp->script->nfixed) {
 95101:         *varAtom = GetArgOrVarAtom(jp, jp->fun->nargs + slot);
 95101:         LOCAL_ASSERT_RV(*varAtom, NULL);
 95101:         return true;
 16429:     }
 16429: 
 16429:     /* We have a local which index is relative to the stack base. */
 16429:     slot -= jp->script->nfixed;
 16429:     JS_ASSERT(slot < StackDepth(jp->script));
 95101:     *localSlot = slot;
 95101:     return false;
 16429: }
 16429: 
 90965: #define LOAD_ATOM(PCOFF) (atom = (jp->script->getAtom(GET_UINT32_INDEX((pc) + PCOFF))))
 32673: 
 86078: typedef Vector<JSAtom *, 8> AtomVector;
 86078: typedef AtomVector::Range AtomRange;
 86078: 
 20908: #if JS_HAS_DESTRUCTURING
 20908: 
 20908: #define LOCAL_ASSERT(expr)  LOCAL_ASSERT_RV(expr, NULL)
 20908: #define LOAD_OP_DATA(pc)    (oplen = (cs = &js_CodeSpec[op=(JSOp)*pc])->length)
 20908: 
     1: static jsbytecode *
 86078: DecompileDestructuring(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc,
 86078:                        AtomRange *letNames = NULL);
 86078: 
 86078: /*
 86078:  * Decompile a single element of a compound {}/[] destructuring lhs, sprinting
 86078:  * the result in-place (without pushing/popping the stack) and advancing the pc
 86078:  * to either the next element or the final pop.
 86078:  *
 86078:  * For normal (SRC_DESTRUCT) destructuring, the names of assigned/initialized
 86078:  * variables are read from their slots. However, for SRC_DESTRUCTLET, the slots
 86078:  * have not been pushed yet; the caller must pass the names to use via
 86078:  * 'letNames'. Each variable initialized in this destructuring lhs results in
 86078:  * popping a name from 'letNames'.
 86078:  */
     1: static jsbytecode *
 86078: DecompileDestructuringLHS(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc, JSBool *hole,
 86078:                           AtomRange *letNames = NULL)
     1: {
     1:     JSPrinter *jp;
     1:     JSOp op;
     1:     const JSCodeSpec *cs;
 91237:     unsigned oplen;
 91450:     int i;
     1:     const char *lval, *xval;
     1:     JSAtom *atom;
     1: 
     1:     *hole = JS_FALSE;
     1:     jp = ss->printer;
     1:     LOAD_OP_DATA(pc);
     1: 
     1:     switch (op) {
     1:       case JSOP_POP:
     1:         *hole = JS_TRUE;
 90229:         if (ss->sprinter.put(", ", 2) < 0)
 81590:             return NULL;
     1:         break;
     1: 
 86078:       case JSOP_PICK:
 86078:         /*
 86078:          * For 'let ([x, y] = y)', the emitter generates
 86078:          *
 86078:          *     push evaluation of y
 86078:          *     dup
 86078:          *   1 one
 86078:          *   2 getelem
 86078:          *   3 pick
 86078:          *   4 two
 86078:          *     getelem
 86078:          *     pick
 86078:          *     pop
 86078:          *
 86078:          * Thus 'x' consists of 1 - 3. The caller (DecompileDestructuring or
 86078:          * DecompileGroupAssignment) will have taken care of 1 - 2, so pc is
 86078:          * now pointing at 3. The pick indicates a primitive let var init so
 86078:          * pop a name and advance the pc to 4.
 86078:          */
 86078:         LOCAL_ASSERT(letNames && !letNames->empty());
 86078:         if (!QuoteString(&ss->sprinter, letNames->popCopyFront(), 0))
 86078:             return NULL;
 86078:         break;
 86078: 
     1:       case JSOP_DUP:
 86078:       {
 86078:         /* Compound lhs, e.g., '[x,y]' in 'let [[x,y], z] = a;'. */
 86078:         pc = DecompileDestructuring(ss, pc, endpc, letNames);
     1:         if (!pc)
     1:             return NULL;
     1:         if (pc == endpc)
     1:             return pc;
     1:         LOAD_OP_DATA(pc);
 86078: 
 86078:         /*
 86078:          * By its post-condition, DecompileDestructuring pushed one string
 86078:          * containing the whole decompiled lhs. Our post-condition is to sprint
 86078:          * in-place so pop/concat this pushed string.
 86078:          */
     1:         lval = PopStr(ss, JSOP_NOP);
 90229:         if (ss->sprinter.put(lval) < 0)
 81590:             return NULL;
 86078: 
     1:         LOCAL_ASSERT(*pc == JSOP_POP);
 86078: 
 86078:         /*
 86078:          * To put block slots in the right place, the emitter follows a
 86078:          * compound lhs with a pick (if at least one slot was pushed). The pick
 86078:          * is not part of the compound lhs so DecompileDestructuring did not
 86078:          * advance over it but it is part of the lhs so advance over it here.
 86078:          */
 86078:         jsbytecode *nextpc = pc + JSOP_POP_LENGTH;
 86078:         LOCAL_ASSERT(nextpc <= endpc);
 86078:         if (letNames && *nextpc == JSOP_PICK) {
 86078:             LOCAL_ASSERT(nextpc < endpc);
 86078:             pc = nextpc;
 86078:             LOAD_OP_DATA(pc);
 86078:         }
 86078:         break;
 86078:       }
     1: 
 95101:       case JSOP_SETALIASEDVAR:
     1:       case JSOP_SETARG:
     1:       case JSOP_SETLOCAL:
 86078:         LOCAL_ASSERT(!letNames);
  1289:         LOCAL_ASSERT(pc[oplen] == JSOP_POP || pc[oplen] == JSOP_POPN);
 82154:         if (op == JSOP_SETARG) {
 82154:             atom = GetArgOrVarAtom(jp, GET_SLOTNO(pc));
 82154:             LOCAL_ASSERT(atom);
 82154:             if (!QuoteString(&ss->sprinter, atom, 0))
 82154:                 return NULL;
 95101:         } else if (IsVarSlot(jp, pc, &atom, &i)) {
 81590:             if (!QuoteString(&ss->sprinter, atom, 0))
 81590:                 return NULL;
  8179:         } else {
 16429:             lval = GetLocal(ss, i);
 90229:             if (!lval || ss->sprinter.put(lval) < 0)
 81590:                 return NULL;
     1:         }
 82154:         pc += oplen;
 82154:         if (pc == endpc)
 82154:             return pc;
 82154:         LOAD_OP_DATA(pc);
 82154:         if (op == JSOP_POPN)
 82154:             return pc;
 82154:         LOCAL_ASSERT(op == JSOP_POP);
     1:         break;
     1: 
 81590:       default: {
 86078:         LOCAL_ASSERT(!letNames);
     1:         /*
     1:          * We may need to auto-parenthesize the left-most value decompiled
     1:          * here, so add back PAREN_SLOP temporarily.  Then decompile until the
     1:          * opcode that would reduce the stack depth to (ss->top-1), which we
     1:          * pass to Decompile encoded as -(ss->top-1) - 1 or just -ss->top for
     1:          * the nb parameter.
     1:          */
 87952:         ptrdiff_t todo = ss->sprinter.getOffset();
 88252:         ss->sprinter.reserve(PAREN_SLOP);
 91237:         pc = Decompile(ss, pc, -((int)ss->top));
     1:         if (!pc)
     1:             return NULL;
     1:         if (pc == endpc)
     1:             return pc;
     1:         LOAD_OP_DATA(pc);
     1:         LOCAL_ASSERT(op == JSOP_ENUMELEM || op == JSOP_ENUMCONSTELEM);
     1:         xval = PopStr(ss, JSOP_NOP);
     1:         lval = PopStr(ss, JSOP_GETPROP);
 87952:         ss->sprinter.setOffset(todo);
     1:         if (*lval == '\0') {
     1:             /* lval is from JSOP_BINDNAME, so just print xval. */
 90229:             todo = ss->sprinter.put(xval);
     1:         } else if (*xval == '\0') {
     1:             /* xval is from JSOP_SETCALL or JSOP_BINDXMLNAME, print lval. */
 90229:             todo = ss->sprinter.put(lval);
     1:         } else {
     1:             todo = Sprint(&ss->sprinter,
  1761:                           (JOF_OPMODE(ss->opcodes[ss->top+1]) == JOF_XMLNAME)
     1:                           ? "%s.%s"
     1:                           : "%s[%s]",
     1:                           lval, xval);
     1:         }
     1:         if (todo < 0)
     1:             return NULL;
 81590:         break;
 81590:       }
 81590:     }
     1: 
     1:     LOCAL_ASSERT(pc < endpc);
     1:     pc += oplen;
     1:     return pc;
     1: }
     1: 
     1: /*
 86078:  * Decompile a destructuring lhs object or array initialiser, including nested
 86078:  * destructuring initialisers. On return a single string is pushed containing
 86078:  * the entire lhs (regardless of how many variables were bound). Thus, the
 86078:  * caller must take care of fixing up the decompiler stack.
     1:  *
 86078:  * See DecompileDestructuringLHS for description of 'letNames'.
     1:  */
     1: static jsbytecode *
 86078: DecompileDestructuring(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc,
 86078:                        AtomRange *letNames)
     1: {
     1:     LOCAL_ASSERT(*pc == JSOP_DUP);
     1:     pc += JSOP_DUP_LENGTH;
     1: 
 86078:     JSContext *cx = ss->sprinter.context;
 86078:     JSPrinter *jp = ss->printer;
 86078:     jsbytecode *startpc = pc;
 86078: 
     1:     /*
     1:      * Set head so we can rewrite '[' to '{' as needed.  Back up PAREN_SLOP
     1:      * chars so the destructuring decompilation accumulates contiguously in
     1:      * ss->sprinter starting with "[".
     1:      */
 90229:     ptrdiff_t head = ss->sprinter.put("[", 1);
     1:     if (head < 0 || !PushOff(ss, head, JSOP_NOP))
     1:         return NULL;
 87952:     ss->sprinter.setOffset(ss->sprinter.getOffset() - PAREN_SLOP);
 87952:     LOCAL_ASSERT(head == ss->sprinter.getOffset() - 1);
 87952:     LOCAL_ASSERT(ss->sprinter[head] == '[');
     1: 
 86078:     int lasti = -1;
     1: 
     1:     while (pc < endpc) {
 11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
 11039:         ptrdiff_t nameoff = -1;
 11039: #endif
 11039: 
 86078:         const JSCodeSpec *cs;
 91237:         unsigned oplen;
 86078:         JSOp op;
     1:         LOAD_OP_DATA(pc);
     1: 
 86078:         int i;
 86078:         double d;
     1:         switch (op) {
     1:           case JSOP_POP:
 86078:             /* Empty destructuring lhs. */
 86078:             LOCAL_ASSERT(startpc == pc);
     1:             pc += oplen;
     1:             goto out;
     1: 
     1:           /* Handle the optimized number-pushing opcodes. */
     1:           case JSOP_ZERO:   d = i = 0; goto do_getelem;
     1:           case JSOP_ONE:    d = i = 1; goto do_getelem;
     1:           case JSOP_UINT16: d = i = GET_UINT16(pc); goto do_getelem;
     1:           case JSOP_UINT24: d = i = GET_UINT24(pc); goto do_getelem;
  3328:           case JSOP_INT8:   d = i = GET_INT8(pc);   goto do_getelem;
  3328:           case JSOP_INT32:  d = i = GET_INT32(pc);  goto do_getelem;
  3328: 
  3328:           case JSOP_DOUBLE:
 90965:             d = jp->script->getConst(GET_UINT32_INDEX(pc)).toDouble();
 95341:             LOCAL_ASSERT(MOZ_DOUBLE_IS_FINITE(d) && !MOZ_DOUBLE_IS_NEGATIVE_ZERO(d));
 91450:             i = (int)d;
     1: 
     1:           do_getelem:
 86078:           {
 86078:             jssrcnote *sn = js_GetSrcNote(jp->script, pc);
     1:             pc += oplen;
     1:             if (pc == endpc)
     1:                 return pc;
     1:             LOAD_OP_DATA(pc);
     1:             LOCAL_ASSERT(op == JSOP_GETELEM);
     1: 
     1:             /* Distinguish object from array by opcode or source note. */
     1:             if (sn && SN_TYPE(sn) == SRC_INITPROP) {
 87952:                 ss->sprinter[head] = '{';
     1:                 if (Sprint(&ss->sprinter, "%g: ", d) < 0)
     1:                     return NULL;
     1:             } else {
     1:                 /* Sanity check for the gnarly control flow above. */
     1:                 LOCAL_ASSERT(i == d);
     1: 
     1:                 /* Fill in any holes (holes at the end don't matter). */
     1:                 while (++lasti < i) {
 90229:                     if (ss->sprinter.put(", ", 2) < 0)
     1:                         return NULL;
     1:                 }
     1:             }
     1:             break;
 86078:           }
     1: 
     1:           case JSOP_GETPROP:
 82152:           case JSOP_LENGTH:
 77343:           {
 86078:             JSAtom *atom;
 69659:             LOAD_ATOM(0);
 87952:             ss->sprinter[head] = '{';
 11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
 87952:             nameoff = ss->sprinter.getOffset();
 11039: #endif
 80633:             if (!QuoteString(&ss->sprinter, atom, IsIdentifier(atom) ? 0 : (jschar)'\''))
     1:                 return NULL;
 90229:             if (ss->sprinter.put(": ", 2) < 0)
     1:                 return NULL;
     1:             break;
 59890:           }
     1: 
     1:           default:
     1:             LOCAL_ASSERT(0);
     1:         }
     1: 
     1:         pc += oplen;
     1:         if (pc == endpc)
     1:             return pc;
     1: 
     1:         /*
     1:          * Decompile the left-hand side expression whose bytecode starts at pc
     1:          * and continues for a bounded number of bytecodes or stack operations
     1:          * (and which in any event stops before endpc).
     1:          */
 86078:         JSBool hole;
 86078:         pc = DecompileDestructuringLHS(ss, pc, endpc, &hole, letNames);
     1:         if (!pc)
     1:             return NULL;
 11039: 
 11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
 11039:         if (nameoff >= 0) {
 11039:             ptrdiff_t offset, initlen;
 11039: 
 87952:             offset = ss->sprinter.getOffset();
 87952:             LOCAL_ASSERT(ss->sprinter[offset] == '\0');
 11039:             initlen = offset - nameoff;
 11039:             LOCAL_ASSERT(initlen >= 4);
 11039: 
 11039:             /* Early check to rule out odd "name: lval" length. */
 11039:             if (((size_t)initlen & 1) == 0) {
 11039:                 size_t namelen;
 11039:                 const char *name;
 11039: 
 11039:                 /*
 11039:                  * Even "name: lval" string length: check for "x: x" and the
 11039:                  * like, and apply the shorthand if we can.
 11039:                  */
 11039:                 namelen = (size_t)(initlen - 2) >> 1;
 87952:                 name = ss->sprinter.stringAt(nameoff);
 11039:                 if (!strncmp(name + namelen, ": ", 2) &&
 11039:                     !strncmp(name, name + namelen + 2, namelen)) {
 11039:                     offset -= namelen + 2;
 87952:                     ss->sprinter[offset] = '\0';
 87952:                     ss->sprinter.setOffset(offset);
 11039:                 }
 11039:             }
 11039:         }
 11039: #endif
 11039: 
     1:         if (pc == endpc || *pc != JSOP_DUP)
     1:             break;
     1: 
     1:         /*
 26956:          * We should stop if JSOP_DUP is either without notes or its note is
 26956:          * not SRC_CONTINUE. The former happens when JSOP_DUP duplicates the
 26956:          * last destructuring reference implementing an op= assignment like in
 26956:          * '([t] = z).y += x'. In the latter case the note is SRC_DESTRUCT and
 26956:          * means another destructuring initialiser abuts this one like in
 26956:          * '[a] = [b] = c'.
     1:          */
 86078:         jssrcnote *sn = js_GetSrcNote(jp->script, pc);
 26956:         if (!sn)
     1:             break;
 26956:         if (SN_TYPE(sn) != SRC_CONTINUE) {
 86078:             LOCAL_ASSERT(SN_TYPE(sn) == SRC_DESTRUCT || SN_TYPE(sn) == SRC_DESTRUCTLET);
 26956:             break;
 26956:         }
     1: 
 90229:         if (!hole && ss->sprinter.put(", ", 2) < 0)
     1:             return NULL;
     1: 
     1:         pc += JSOP_DUP_LENGTH;
     1:     }
     1: 
     1: out:
 87952:     const char *lval = ss->sprinter.stringAt(head);
 90229:     if (ss->sprinter.put((*lval == '[') ? "]" : "}", 1) < 0)
     1:         return NULL;
     1:     return pc;
     1: }
     1: 
     1: static jsbytecode *
     1: DecompileGroupAssignment(SprintStack *ss, jsbytecode *pc, jsbytecode *endpc,
     1:                          jssrcnote *sn, ptrdiff_t *todop)
     1: {
     1:     JSOp op;
     1:     const JSCodeSpec *cs;
 91237:     unsigned oplen, start, end, i;
     1:     ptrdiff_t todo;
     1:     JSBool hole;
     1:     const char *rval;
     1: 
     1:     LOAD_OP_DATA(pc);
 84493:     LOCAL_ASSERT(op == JSOP_GETLOCAL);
     1: 
     1:     todo = Sprint(&ss->sprinter, "%s[", VarPrefix(sn));
     1:     if (todo < 0 || !PushOff(ss, todo, JSOP_NOP))
     1:         return NULL;
 87952:     ss->sprinter.setOffset(ss->sprinter.getOffset() - PAREN_SLOP);
     1: 
     1:     for (;;) {
     1:         pc += oplen;
     1:         if (pc == endpc)
     1:             return pc;
     1:         pc = DecompileDestructuringLHS(ss, pc, endpc, &hole);
     1:         if (!pc)
     1:             return NULL;
     1:         if (pc == endpc)
     1:             return pc;
     1:         LOAD_OP_DATA(pc);
 84493:         if (op != JSOP_GETLOCAL)
     1:             break;
 90229:         if (!hole && ss->sprinter.put(", ", 2) < 0)
     1:             return NULL;
     1:     }
     1: 
  1227:     LOCAL_ASSERT(op == JSOP_POPN);
 90229:     if (ss->sprinter.put("] = [", 5) < 0)
     1:         return NULL;
     1: 
     1:     end = ss->top - 1;
  1289:     start = end - GET_UINT16(pc);
     1:     for (i = start; i < end; i++) {
     1:         rval = GetStr(ss, i);
  1289:         if (Sprint(&ss->sprinter,
  1289:                    (i == start) ? "%s" : ", %s",
     1:                    (i == end - 1 && *rval == '\0') ? ", " : rval) < 0) {
     1:             return NULL;
     1:         }
     1:     }
     1: 
 90229:     if (ss->sprinter.put("]", 1) < 0)
     1:         return NULL;
 87952:     ss->sprinter.setOffset(ss->offsets[i]);
     1:     ss->top = start;
     1:     *todop = todo;
     1:     return pc;
     1: }
     1: 
     1: #undef LOCAL_ASSERT
     1: #undef LOAD_OP_DATA
     1: 
     1: #endif /* JS_HAS_DESTRUCTURING */
     1: 
 81591: #define LOCAL_ASSERT(expr)    LOCAL_ASSERT_RV(expr, false)
 81591: 
 81591: /*
 81591:  * The names of the vars of a let block/expr are stored as the ids of the
 81591:  * shapes of the block object. Shapes are stored in a singly-linked list in
 81591:  * reverse order of addition. This function takes care of putting the names
 81591:  * back in declaration order.
 81591:  */
 81591: static bool
 86483: GetBlockNames(JSContext *cx, StaticBlockObject &blockObj, AtomVector *atoms)
 81591: {
 86483:     size_t numAtoms = blockObj.slotCount();
 81591:     LOCAL_ASSERT(numAtoms > 0);
 81591:     if (!atoms->resize(numAtoms))
 81591:         return false;
 81591: 
 91237:     unsigned i = numAtoms;
 86483:     for (Shape::Range r = blockObj.lastProperty()->all(); !r.empty(); r.popFront()) {
 81591:         const Shape &shape = r.front();
 81591:         LOCAL_ASSERT(shape.hasShortID());
 81591:         --i;
 91237:         LOCAL_ASSERT((unsigned)shape.shortid() == i);
 86078:         (*atoms)[i] = JSID_IS_INT(shape.propid())
 86078:                       ? cx->runtime->atomState.emptyAtom
 86078:                       : JSID_TO_ATOM(shape.propid());
 81591:     }
 81591: 
 81591:     LOCAL_ASSERT(i == 0);
 81591:     return true;
 81591: }
 81591: 
 81591: static bool
 81591: PushBlockNames(JSContext *cx, SprintStack *ss, const AtomVector &atoms)
 81591: {
 81591:     for (size_t i = 0; i < atoms.length(); i++) {
 81591:         const char *name = QuoteString(&ss->sprinter, atoms[i], 0);
 87952:         if (!name || !PushOff(ss, ss->sprinter.getOffsetOf(name), JSOP_ENTERBLOCK))
 81591:             return false;
 81591:     }
 81591:     return true;
 81591: }
 81591: 
 86078: /*
 86078:  * In the scope of a let, the variables' (decompiler) stack slots must contain
 86078:  * the corresponding variable's name. This function updates the N top slots
 86078:  * with the N variable names stored in 'atoms'.
 86078:  */
 86078: static bool
 86078: AssignBlockNamesToPushedSlots(JSContext *cx, SprintStack *ss, const AtomVector &atoms)
 86078: {
 86078:     /* For simplicity, just pop and push. */
 91237:     LOCAL_ASSERT(atoms.length() <= (unsigned)ss->top);
 86078:     for (size_t i = 0; i < atoms.length(); ++i)
 86078:         PopStr(ss, JSOP_NOP);
 86078:     return PushBlockNames(cx, ss, atoms);
 86078: }
 86078: 
 86078: static const char SkipString[] = "/*skip*/";
 86078: static const char DestructuredString[] = "/*destructured*/";
 86078: static const unsigned DestructuredStringLength = ArrayLength(DestructuredString) - 1;
 86078: 
 81592: static ptrdiff_t
 86078: SprintLetBody(JSContext *cx, JSPrinter *jp, SprintStack *ss, jsbytecode *pc, ptrdiff_t bodyLength,
 81592:               const char *headChars)
 81592: {
 81592:     if (pc[bodyLength] == JSOP_LEAVEBLOCK) {
 81592:         js_printf(jp, "\tlet (%s) {\n", headChars);
 81592:         jp->indent += 4;
 81592:         if (!Decompile(ss, pc, bodyLength))
 81592:             return -1;
 81592:         jp->indent -= 4;
 81592:         js_printf(jp, "\t}\n");
 81592:         return -2;
 81592:     }
 81592: 
 81592:     LOCAL_ASSERT_RV(pc[bodyLength] == JSOP_LEAVEBLOCKEXPR, -1);
 81592:     if (!Decompile(ss, pc, bodyLength))
 81592:         return -1;
 81592: 
 81592:     const char *bodyChars = PopStr(ss, JSOP_SETNAME);
 81592:     const char *format = *bodyChars == '{' ? "let (%s) (%s)" : "let (%s) %s";
 81592:     return Sprint(&ss->sprinter, format, headChars, bodyChars);
 81592: }
 81592: 
 84803: /*
 84803:  * Get the token to prefix the '=' in an assignment operation, checking whether
 84803:  * the last operation was a getter, setter or compound assignment. For compound
 84803:  * assignments, marks parents for the lhs and rhs of the operation in the
 84803:  * compound assign. For an assignment such as 'a += b', the lhs will appear
 84803:  * twice in the bytecode, in read and write operations. We defer generation of
 84803:  * the offsets for the initial arithmetic operation until the entire compound
 84803:  * assign has been processed.
 84803:  */
 84803: static const char *
 84803: GetTokenForAssignment(JSPrinter *jp, jssrcnote *sn, JSOp lastop,
 84803:                       jsbytecode *pc, jsbytecode *rvalpc,
 84803:                       jsbytecode **lastlvalpc, jsbytecode **lastrvalpc)
 84803: {
 84803:     const char *token;
 84803:     if (sn && SN_TYPE(sn) == SRC_ASSIGNOP) {
 84803:         if (lastop == JSOP_GETTER) {
 84803:             token = js_getter_str;
 84803:         } else if (lastop == JSOP_SETTER) {
 84803:             token = js_setter_str;
 84803:         } else {
 84803:             token = CodeToken[lastop];
 84803:             if (*lastlvalpc && *lastrvalpc) {
 84803:                 UpdateDecompiledParent(jp, *lastlvalpc, pc, 0);
 84803:                 UpdateDecompiledParent(jp, *lastrvalpc, rvalpc, 0);
 84803:             }
 84803:         }
 84803:     } else {
 84803:         token = "";
 84803:     }
 84803:     *lastlvalpc = NULL;
 84803:     *lastrvalpc = NULL;
 84803:     return token;
 84803: }
 84803: 
 86075: static ptrdiff_t
 86078: SprintNormalFor(JSContext *cx, JSPrinter *jp, SprintStack *ss, const char *initPrefix,
 86078:                 const char *init, jsbytecode *initpc, jsbytecode **ppc, ptrdiff_t *plen)
 86075: {
 86075:     jsbytecode *pc = *ppc;
 86075:     jssrcnote *sn = js_GetSrcNote(jp->script, pc);
 86075:     JS_ASSERT(SN_TYPE(sn) == SRC_FOR);
 86075: 
 86075:     /* Print the keyword and the possibly empty init-part. */
 86078:     js_printf(jp, "\tfor (%s", initPrefix);
 86075:     SprintOpcodePermanent(jp, init, initpc);
 86075:     js_printf(jp, ";");
 86075: 
 86075:     /* Skip the JSOP_NOP or JSOP_POP bytecode. */
 86075:     JS_ASSERT(*pc == JSOP_NOP || *pc == JSOP_POP);
 86075:     pc += JSOP_NOP_LENGTH;
 86075: 
 86075:     /* Get the cond, next, and loop-closing tail offsets. */
 86075:     ptrdiff_t cond = js_GetSrcNoteOffset(sn, 0);
 86075:     ptrdiff_t next = js_GetSrcNoteOffset(sn, 1);
 86075:     ptrdiff_t tail = js_GetSrcNoteOffset(sn, 2);
 86075: 
 91563:     /* Find the loop head, skipping over any leading GOTO or NOP. */
 86075:     jsbytecode *pc2 = pc;
 91563:     if (*pc == JSOP_GOTO || *pc == JSOP_NOP)
 91563:         pc2 += GetBytecodeLength(pc);
 86877:     LOCAL_ASSERT(tail + GET_JUMP_OFFSET(pc + tail) == pc2 - pc);
 86075: 
 86075:     if (cond != tail) {
 86075:         /* Decompile the loop condition. */
 86075:         if (!Decompile(ss, pc + cond, tail - cond))
 86075:             return -1;
 86075:         js_printf(jp, " ");
 86075:         jsbytecode *condpc;
 86075:         const char *cond = PopStr(ss, JSOP_NOP, &condpc);
 86075:         SprintOpcodePermanent(jp, cond, condpc);
 86075:     }
 86075: 
 86075:     /* Need a semicolon whether or not there was a cond. */
 86075:     js_puts(jp, ";");
 86075: 
 86075:     if (next != cond) {
 86075:         /*
 86075:          * Decompile the loop updater. It may end in a JSOP_POP
 86075:          * that we skip; or in a JSOP_POPN that we do not skip,
 86075:          * followed by a JSOP_NOP (skipped as if it's a POP).
 86075:          * We cope with the difference between these two cases
 86075:          * by checking for stack imbalance and popping if there
 86075:          * is an rval.
 86075:          */
 91237:         unsigned saveTop = ss->top;
 86075: 
 86075:         if (!Decompile(ss, pc + next, cond - next - JSOP_POP_LENGTH))
 86075:             return -1;
 86075:         LOCAL_ASSERT(ss->top - saveTop <= 1U);
 86075:         jsbytecode *updatepc = NULL;
 86075:         const char *update = (ss->top == saveTop)
 87952:                              ? ss->sprinter.stringEnd()
 86075:                              : PopStr(ss, JSOP_NOP, &updatepc);
 86075:         js_printf(jp, " ");
 86075:         SprintOpcodePermanent(jp, update, updatepc);
 86075:     }
 86075: 
 86075:     /* Do the loop body. */
 86075:     js_printf(jp, ") {\n");
 86075:     jp->indent += 4;
 86075:     next -= pc2 - pc;
 86075:     if (!Decompile(ss, pc2, next))
 86075:         return -1;
 86075:     jp->indent -= 4;
 86075:     js_printf(jp, "\t}\n");
 86075: 
 86075:     /* Set len so pc skips over the entire loop. */
 86075:     *ppc = pc;
 86075:     *plen = tail + js_CodeSpec[pc[tail]].length;
 86075:     return -2;
 86075: }
 86075: 
 86075: #undef LOCAL_ASSERT
 86075: 
  1577: static JSBool
 91237: InitSprintStack(JSContext *cx, SprintStack *ss, JSPrinter *jp, unsigned depth)
  1577: {
 87952:     if (!ss->sprinter.init())
 87952:         return JS_FALSE;
 87952:     ss->sprinter.setOffset(PAREN_SLOP);
  1577: 
 84803:     /* Allocate the parallel (to avoid padding) offset, opcode and bytecode stacks. */
 79410:     size_t offsetsz = depth * sizeof(ptrdiff_t);
 79410:     size_t opcodesz = depth * sizeof(jsbytecode);
 84803:     size_t bytecodesz = depth * sizeof(jsbytecode *);
 84803:     void *space = cx->tempLifoAlloc().alloc(offsetsz + opcodesz + bytecodesz);
  8296:     if (!space) {
 71371:         js_ReportOutOfMemory(cx);
  1577:         return JS_FALSE;
  8296:     }
  1577:     ss->offsets = (ptrdiff_t *) space;
  1577:     ss->opcodes = (jsbytecode *) ((char *)space + offsetsz);
 84803:     ss->bytecodes = (jsbytecode **) ((char *)space + offsetsz + opcodesz);
  1577: 
  1577:     ss->top = ss->inArrayInit = 0;
  1577:     ss->inGenExp = JS_FALSE;
  1577:     ss->printer = jp;
  1577:     return JS_TRUE;
  1577: }
  1577: 
     1: /*
     1:  * If nb is non-negative, decompile nb bytecodes starting at pc.  Otherwise
     1:  * the decompiler starts at pc and continues until it reaches an opcode for
     1:  * which decompiling would result in the stack depth equaling -(nb + 1).
     1:  */
     1: static jsbytecode *
 91237: Decompile(SprintStack *ss, jsbytecode *pc, int nb)
     1: {
     1:     JSContext *cx;
     1:     JSPrinter *jp, *jp2;
 84803:     jsbytecode *startpc, *endpc, *pc2, *done, *lvalpc, *rvalpc, *xvalpc;
     1:     ptrdiff_t tail, todo, len, oplen, cond, next;
     1:     JSOp op, lastop, saveop;
     1:     const JSCodeSpec *cs;
     1:     jssrcnote *sn, *sn2;
  1154:     const char *lval, *rval, *xval, *fmt, *token;
 91237:     unsigned nuses;
 91450:     int i, argc;
     1:     JSAtom *atom;
     1:     JSObject *obj;
 64329:     JSFunction *fun = NULL; /* init to shut GCC up */
     1:     JSString *str;
     1:     JSBool ok;
 98644:     JSBool foreach;
     1: #if JS_HAS_XML_SUPPORT
 98644:     JSBool inXML, quoteAttr;
     1: #else
     1: #define inXML JS_FALSE
     1: #endif
     1:     jsval val;
     1: 
     1:     static const char exception_cookie[] = "/*EXCEPTION*/";
     1:     static const char retsub_pc_cookie[] = "/*RETSUB_PC*/";
     1:     static const char forelem_cookie[]   = "/*FORELEM*/";
     1:     static const char with_cookie[]      = "/*WITH*/";
     1:     static const char dot_format[]       = "%s.%s";
     1:     static const char index_format[]     = "%s[%s]";
     1:     static const char predot_format[]    = "%s%s.%s";
     1:     static const char postdot_format[]   = "%s.%s%s";
     1:     static const char preindex_format[]  = "%s%s[%s]";
     1:     static const char postindex_format[] = "%s[%s]%s";
     1:     static const char ss_format[]        = "%s%s";
 20943:     static const char sss_format[]       = "%s%s%s";
     1: 
  8285:     /* Argument and variables decompilation uses the following to share code. */
 16072:     JS_STATIC_ASSERT(ARGNO_LEN == SLOTNO_LEN);
  8285: 
     1: /*
     1:  * Local macros
     1:  */
 20928: #define LOCAL_ASSERT(expr)    LOCAL_ASSERT_RV(expr, NULL)
 81589: #define DECOMPILE_CODE_CLEANUP(pc,nb,cleanup) if (!Decompile(ss, pc, nb)) cleanup
 71343: #define DECOMPILE_CODE(pc,nb) DECOMPILE_CODE_CLEANUP(pc,nb,return NULL)
 21441: #define TOP_STR()             GetStr(ss, ss->top - 1)
     1: #define POP_STR()             PopStr(ss, op)
 20928: #define POP_STR_PREC(prec)    PopStrPrec(ss, prec)
 20928: 
 20928: /*
     1:  * Given an atom already fetched from jp->script's atom map, quote/escape its
     1:  * string appropriately into rval, and select fmt from the quoted and unquoted
     1:  * alternatives.
     1:  */
     1: #define GET_QUOTE_AND_FMT(qfmt, ufmt, rval)                                   \
     1:     JS_BEGIN_MACRO                                                            \
     1:         jschar quote_;                                                        \
 80633:         if (!IsIdentifier(atom)) {                                            \
     1:             quote_ = '\'';                                                    \
     1:             fmt = qfmt;                                                       \
     1:         } else {                                                              \
     1:             quote_ = 0;                                                       \
     1:             fmt = ufmt;                                                       \
     1:         }                                                                     \
 64345:         rval = QuoteString(&ss->sprinter, atom, quote_);                      \
 84803:         rval = SprintDupeStr(ss, rval);                                       \
     1:         if (!rval)                                                            \
     1:             return NULL;                                                      \
     1:     JS_END_MACRO
     1: 
  4342: #define GET_SOURCE_NOTE_ATOM(sn, atom)                                        \
  4342:     JS_BEGIN_MACRO                                                            \
  4342:         jsatomid atomIndex_ = (jsatomid) js_GetSrcNoteOffset((sn), 0);        \
  4342:                                                                               \
 77659:         LOCAL_ASSERT(atomIndex_ < jp->script->natoms);                        \
 77659:         (atom) = jp->script->atoms[atomIndex_];                               \
  4342:     JS_END_MACRO
  4342: 
     1: /*
     1:  * Get atom from jp->script's atom map, quote/escape its string appropriately
     1:  * into rval, and select fmt from the quoted and unquoted alternatives.
     1:  */
     1: #define GET_ATOM_QUOTE_AND_FMT(qfmt, ufmt, rval)                              \
     1:     JS_BEGIN_MACRO                                                            \
     1:         LOAD_ATOM(0);                                                         \
     1:         GET_QUOTE_AND_FMT(qfmt, ufmt, rval);                                  \
     1:     JS_END_MACRO
     1: 
 20928: /*
 20928:  * Per spec, new x(y).z means (new x(y))).z. For example new (x(y).z) must
 20928:  * decompile with the constructor parenthesized, but new x.z should not. The
 20928:  * normal rules give x(y).z and x.z identical precedence: both are produced by
 20928:  * JSOP_GETPROP.
 20928:  *
 20928:  * Therefore, we need to know in case JSOP_NEW whether the constructor
 20928:  * expression contains any unparenthesized function calls. So when building a
 20928:  * MemberExpression or CallExpression, we set ss->opcodes[n] to JSOP_CALL if
 20928:  * this is true. x(y).z gets JSOP_CALL, not JSOP_GETPROP.
 20928:  */
 20928: #define PROPAGATE_CALLNESS()                                                  \
 20928:     JS_BEGIN_MACRO                                                            \
 38541:         if (ss->opcodes[ss->top - 1] == JSOP_CALL ||                          \
 38541:             ss->opcodes[ss->top - 1] == JSOP_EVAL ||                          \
 57712:             ss->opcodes[ss->top - 1] == JSOP_FUNCALL ||                       \
 57712:             ss->opcodes[ss->top - 1] == JSOP_FUNAPPLY) {                      \
 20928:             saveop = JSOP_CALL;                                               \
 38541:         }                                                                     \
 20928:     JS_END_MACRO
 20928: 
 84803:     jsbytecode *lastlvalpc = NULL, *lastrvalpc = NULL;
 84803: 
     1:     cx = ss->sprinter.context;
 14767:     JS_CHECK_RECURSION(cx, return NULL);
     1: 
     1:     jp = ss->printer;
     1:     startpc = pc;
     1:     endpc = (nb < 0) ? jp->script->code + jp->script->length : pc + nb;
     1:     tail = -1;
     1:     todo = -2;                  /* NB: different from Sprint() error return. */
     1:     saveop = JSOP_NOP;
     1:     sn = NULL;
     1:     rval = NULL;
 89621:     bool forOf = false;
 98644:     foreach = false;
     1: #if JS_HAS_XML_SUPPORT
 98644:     inXML = quoteAttr = false;
     1: #endif
     1: 
     1:     while (nb < 0 || pc < endpc) {
     1:         /*
     1:          * Move saveop to lastop so prefixed bytecodes can take special action
     1:          * while sharing maximal code.  Set op and saveop to the new bytecode,
     1:          * use op in POP_STR to trigger automatic parenthesization, but push
     1:          * saveop at the bottom of the loop if this op pushes.  Thus op may be
     1:          * set to nop or otherwise mutated to suppress auto-parens.
     1:          */
     1:         lastop = saveop;
     1:         op = (JSOp) *pc;
     1:         cs = &js_CodeSpec[op];
     1:         saveop = op;
     1:         len = oplen = cs->length;
 86078:         nuses = StackUses(jp->script, pc);
 26729: 
 26729:         /*
 26729:          * Here it is possible that nuses > ss->top when the op has a hidden
 26729:          * source note. But when nb < 0 we assume that the caller knows that
 26729:          * Decompile would never meet such opcodes.
 26729:          */
 26729:         if (nb < 0) {
 26729:             LOCAL_ASSERT(ss->top >= nuses);
 91237:             unsigned ndefs = StackDefs(jp->script, pc);
 91237:             if ((unsigned) -(nb + 1) == ss->top - nuses + ndefs)
     1:                 return pc;
 26729:         }
     1: 
  1326:         /*
  1326:          * Save source literal associated with JS now before the following
  1326:          * rewrite changes op. See bug 380197.
  1326:          */
  1326:         token = CodeToken[op];
  1326: 
     1:         if (pc + oplen == jp->dvgfence) {
     1:             /*
     1:              * Rewrite non-get ops to their "get" format if the error is in
 84117:              * the bytecode at pc, or if at an inner opcode of a 'fat' outer
 84117:              * opcode at pc, so we don't decompile more than the error
     1:              * expression.
     1:              */
 84755:             uint32_t format = cs->format;
 84117:             bool matchPC = false;
 97161:             ScriptFrameIter iter(cx);
 92133:             if (!iter.done()) {
 92133:                 jsbytecode *npc = iter.pc();
 84117:                 if (pc == npc) {
 84117:                     matchPC = true;
 84117:                 } else if (format & JOF_DECOMPOSE) {
 84117:                     if (unsigned(npc - pc) < GetDecomposeLength(pc, js_CodeSpec[*pc].length))
 84117:                         matchPC = true;
 84117:                 }
 84117:             }
 84117:             if ((matchPC || (pc == startpc && nuses != 0)) &&
 95101:                 format & (JOF_SET|JOF_DEL|JOF_INCDEC)) {
 84755:                 uint32_t mode = JOF_MODE(format);
     1:                 if (mode == JOF_NAME) {
     1:                     /*
  4380:                      * JOF_NAME does not imply JOF_ATOM, so we must check for
     1:                      * the QARG and QVAR format types, and translate those to
 16429:                      * JSOP_GETARG or JSOP_GETLOCAL appropriately, instead of
 16429:                      * to JSOP_NAME.
     1:                      */
 84755:                     uint32_t type = JOF_TYPE(format);
     1:                     op = (type == JOF_QARG)
     1:                          ? JSOP_GETARG
     1:                          : (type == JOF_LOCAL)
     1:                          ? JSOP_GETLOCAL
 95101:                          : (type == JOF_SCOPECOORD)
 95101:                          ? JSOP_GETALIASEDVAR
     1:                          : JSOP_NAME;
     1: 
 26729:                     JS_ASSERT(js_CodeSpec[op].nuses >= 0);
 26729:                     i = nuses - js_CodeSpec[op].nuses;
     1:                     while (--i >= 0)
     1:                         PopOff(ss, JSOP_NOP);
     1:                 } else {
     1:                     /*
     1:                      * We must replace the faulting pc's bytecode with a
     1:                      * corresponding JSOP_GET* code.  For JSOP_SET{PROP,ELEM},
     1:                      * we must use the "2nd" form of JSOP_GET{PROP,ELEM}, to
     1:                      * throw away the assignment op's right-hand operand and
     1:                      * decompile it as if it were a GET of its left-hand
     1:                      * operand.
     1:                      */
     1:                     if (mode == JOF_PROP) {
  3164:                         op = (JSOp) ((format & JOF_SET)
  3164:                                      ? JSOP_GETPROP2
  3164:                                      : JSOP_GETPROP);
     1:                     } else if (mode == JOF_ELEM) {
  3164:                         op = (JSOp) ((format & JOF_SET)
  3164:                                      ? JSOP_GETELEM2
  3164:                                      : JSOP_GETELEM);
     1:                     } else {
     1:                         /*
 14669:                          * Unknown mode (including mode 0) means that op is
 14669:                          * uncategorized for our purposes, so we must write
 14669:                          * per-op special case code here.
     1:                          */
     1:                         switch (op) {
     1:                           case JSOP_ENUMELEM:
     1:                           case JSOP_ENUMCONSTELEM:
     1:                             op = JSOP_GETELEM;
     1:                             break;
 54420:                           case JSOP_SETXMLNAME:
 54420:                             op = JSOp(JSOP_GETELEM2);
 54420:                             break;
     1:                           default:
     1:                             LOCAL_ASSERT(0);
     1:                         }
     1:                     }
     1:                 }
     1:             }
     1: 
     1:             saveop = op;
     1:             if (op >= JSOP_LIMIT) {
 58071:                 if (op == JSOP_GETPROP2)
     1:                     saveop = JSOP_GETPROP;
 58071:                 else if (op == JSOP_GETELEM2)
     1:                     saveop = JSOP_GETELEM;
     1:             }
     1: 
     1:             jp->dvgfence = NULL;
     1:         }
     1: 
 84803:         jsbytecode *pushpc = pc;
 84803: 
  1154:         if (token) {
 26729:             switch (nuses) {
     1:               case 2:
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 if (sn && SN_TYPE(sn) == SRC_ASSIGNOP) {
     1:                     /*
     1:                      * Avoid over-parenthesizing y in x op= y based on its
     1:                      * expansion: x = x op y (replace y by z = w to see the
     1:                      * problem).
     1:                      */
  3164:                     op = (JSOp) pc[oplen];
 84803:                     rval = PopStr(ss, op, &lastrvalpc);
 84950:                     (void)PopStr(ss, op, &lastlvalpc);
 84950: 
     1:                     /* Print only the right operand of the assignment-op. */
 90229:                     todo = ss->sprinter.put(rval);
     1:                 } else if (!inXML) {
 84803:                     rval = PopStrPrecDupe(ss, cs->prec + !!(cs->format & JOF_LEFTASSOC), &rvalpc);
 84803:                     lval = PopStrPrec(ss, cs->prec + !(cs->format & JOF_LEFTASSOC), &lvalpc);
 87952:                     todo = ss->sprinter.getOffset();
 84803:                     SprintOpcode(ss, lval, lvalpc, pc, todo);
 84803:                     Sprint(&ss->sprinter, " %s ", token);
 84803:                     SprintOpcode(ss, rval, rvalpc, pc, todo);
     1:                 } else {
     1:                     /* In XML, just concatenate the two operands. */
     1:                     LOCAL_ASSERT(op == JSOP_ADD);
 20942:                     rval = POP_STR();
 20942:                     lval = POP_STR();
     1:                     todo = Sprint(&ss->sprinter, ss_format, lval, rval);
     1:                 }
     1:                 break;
     1: 
     1:               case 1:
 84803:                 rval = PopStrDupe(ss, op, &rvalpc);
 90229:                 todo = ss->sprinter.put(token);
 84803:                 SprintOpcode(ss, rval, rvalpc, pc, todo);
     1:                 break;
     1: 
     1:               case 0:
 86078:                 sn = js_GetSrcNote(jp->script, pc);
 86078:                 if (sn && SN_TYPE(sn) == SRC_CONTINUE) {
 86078:                     /* Hoisted let decl (e.g. 'y' in 'let (x) { let y; }'). */
 90229:                     todo = ss->sprinter.put(SkipString);
 90229:                     break;
 90229:                 }
 90229:                 todo = ss->sprinter.put(token);
     1:                 break;
     1: 
     1:               default:
     1:                 todo = -2;
     1:                 break;
     1:             }
     1:         } else {
     1:             switch (op) {
     1:               case JSOP_NOP:
     1:                 /*
     1:                  * Check for a do-while loop, a for-loop with an empty
     1:                  * initializer part, a labeled statement, a function
     1:                  * definition, or try/finally.
     1:                  */
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 todo = -2;
     1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
     1:                   case SRC_WHILE:
 73686:                     /* First instuction (NOP) contains offset to condition */
     1:                     ++pc;
 73686:                     /* Second instruction (TRACE) contains offset to JSOP_IFNE */
 73686:                     sn = js_GetSrcNote(jp->script, pc);
 73686:                     tail = js_GetSrcNoteOffset(sn, 0);
 86877:                     LOCAL_ASSERT(pc[tail] == JSOP_IFNE);
  9832:                     js_printf(jp, "\tdo {\n");
     1:                     jp->indent += 4;
     1:                     DECOMPILE_CODE(pc, tail);
     1:                     jp->indent -= 4;
 84803:                     js_printf(jp, "\t} while (");
 84803:                     rval = PopCondStr(ss, &rvalpc);
 84803:                     SprintOpcodePermanent(jp, rval, rvalpc);
 84803:                     js_printf(jp, ");\n");
     1:                     pc += tail;
     1:                     len = js_CodeSpec[*pc].length;
     1:                     todo = -2;
     1:                     break;
     1: 
     1:                   case SRC_FOR:
 86075:                     /* for loop with empty initializer. */
 86078:                     todo = SprintNormalFor(cx, jp, ss, "", "", NULL, &pc, &len);
     1:                     break;
     1: 
     1:                   case SRC_ENDBRACE:
     1:                     jp->indent -= 4;
     1:                     js_printf(jp, "\t}\n");
     1:                     break;
     1: 
     1:                   case SRC_FUNCDEF:
 32723:                     fun = jp->script->getFunction(js_GetSrcNoteOffset(sn, 0));
     1:                   do_function:
  8179:                     js_puts(jp, "\n");
 35112:                     jp2 = js_NewPrinter(cx, "nested_function", fun,
 35113:                                         jp->indent, jp->pretty, jp->grouped,
 35113:                                         jp->strict);
     1:                     if (!jp2)
     1:                         return NULL;
 13702:                     ok = js_DecompileFunction(jp2);
 87952:                     if (ok && !jp2->sprinter.empty())
 87952:                         js_puts(jp, jp2->sprinter.string());
 61225:                     js_DestroyPrinter(jp2);
     1:                     if (!ok)
     1:                         return NULL;
  8179:                     js_puts(jp, "\n\n");
     1:                     break;
     1: 
     1:                   case SRC_BRACE:
  9832:                     js_printf(jp, "\t{\n");
     1:                     jp->indent += 4;
     1:                     len = js_GetSrcNoteOffset(sn, 0);
     1:                     DECOMPILE_CODE(pc + oplen, len - oplen);
     1:                     jp->indent -= 4;
     1:                     js_printf(jp, "\t}\n");
     1:                     break;
     1: 
     1:                   default:;
     1:                 }
     1:                 break;
     1: 
 82079:               case JSOP_LABEL:
 82079:                 sn = js_GetSrcNote(jp->script, pc);
 82079:                 todo = -2;
 82079:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
 82079:                   case SRC_LABEL:
 82079:                     GET_SOURCE_NOTE_ATOM(sn, atom);
 82079:                     jp->indent -= 4;
 82079:                     rval = QuoteString(&ss->sprinter, atom, 0);
 82079:                     if (!rval)
 82079:                         return NULL;
 87952:                     ss->sprinter.setOffset(rval);
 82079:                     js_printf(jp, "\t%s:\n", rval);
 82079:                     jp->indent += 4;
 82079:                     break;
 82079: 
 82079:                   case SRC_LABELBRACE:
 82079:                     GET_SOURCE_NOTE_ATOM(sn, atom);
 82079:                     rval = QuoteString(&ss->sprinter, atom, 0);
 82079:                     if (!rval)
 82079:                         return NULL;
 87952:                     ss->sprinter.setOffset(rval);
 82079:                     js_printf(jp, "\t%s: {\n", rval);
 82079:                     jp->indent += 4;
 82079:                     break;
 82079: 
 82079:                   default:
 82079:                     JS_NOT_REACHED("JSOP_LABEL without source note");
 82079:                     break;
 82079:                 }
 82079:                 break;
 82079: 
     1:               case JSOP_BINDNAME:
 52825:               case JSOP_BINDGNAME:
     1:                 todo = Sprint(&ss->sprinter, "");
     1:                 break;
     1: 
     1:               case JSOP_TRY:
  9832:                 js_printf(jp, "\ttry {\n");
     1:                 jp->indent += 4;
     1:                 todo = -2;
     1:                 break;
     1: 
     1:               case JSOP_FINALLY:
     1:                 jp->indent -= 4;
  9832:                 js_printf(jp, "\t} finally {\n");
     1:                 jp->indent += 4;
     1: 
     1:                 /*
  1825:                  * We push push the pair of exception/restsub cookies to
  1825:                  * simulate the effects [gosub] or control transfer during
  1825:                  * exception capturing on the stack.
     1:                  */
     1:                 todo = Sprint(&ss->sprinter, exception_cookie);
     1:                 if (todo < 0 || !PushOff(ss, todo, op))
     1:                     return NULL;
     1:                 todo = Sprint(&ss->sprinter, retsub_pc_cookie);
     1:                 break;
     1: 
     1:               case JSOP_RETSUB:
     1:                 rval = POP_STR();
     1:                 LOCAL_ASSERT(strcmp(rval, retsub_pc_cookie) == 0);
     1:                 lval = POP_STR();
     1:                 LOCAL_ASSERT(strcmp(lval, exception_cookie) == 0);
     1:                 todo = -2;
     1:                 break;
     1: 
     1:               case JSOP_GOSUB:
     1:                 /*
 86877:                  * JSOP_GOSUB has no effect on the decompiler's string stack
 86877:                  * because the next op in bytecode order finds the stack
 86877:                  * balanced by a JSOP_RETSUB executed elsewhere.
     1:                  */
     1:                 todo = -2;
     1:                 break;
     1: 
  1227:               case JSOP_POPN:
     1:               {
 91237:                 unsigned newtop, oldtop;
     1: 
     1:                 /*
     1:                  * The compiler models operand stack depth and fixes the stack
     1:                  * pointer on entry to a catch clause based on its depth model.
     1:                  * The decompiler must match the code generator's model, which
     1:                  * is why JSOP_FINALLY pushes a cookie that JSOP_RETSUB pops.
     1:                  */
     1:                 oldtop = ss->top;
  1825:                 newtop = oldtop - GET_UINT16(pc);
     1:                 LOCAL_ASSERT(newtop <= oldtop);
     1:                 todo = -2;
     1: 
  1227:                 sn = js_GetSrcNote(jp->script, pc);
  1227:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
  1227:                     break;
     1: #if JS_HAS_DESTRUCTURING
     1:                 if (sn && SN_TYPE(sn) == SRC_GROUPASSIGN) {
     1:                     todo = Sprint(&ss->sprinter, "%s[] = [",
     1:                                   VarPrefix(sn));
     1:                     if (todo < 0)
     1:                         return NULL;
 91237:                     for (unsigned i = newtop; i < oldtop; i++) {
 87952:                         rval = ss->sprinter.stringAt(ss->offsets[i]);
     1:                         if (Sprint(&ss->sprinter, ss_format,
     1:                                    (i == newtop) ? "" : ", ",
     1:                                    (i == oldtop - 1 && *rval == '\0')
     1:                                    ? ", " : rval) < 0) {
     1:                             return NULL;
     1:                         }
     1:                     }
 90229:                     if (ss->sprinter.put("]", 1) < 0)
     1:                         return NULL;
     1: 
     1:                     /*
 21520:                      * If this is an empty group assignment, we have no stack
 21520:                      * budget into which we can push our result string. Adjust
 21520:                      * ss->sprinter.offset so that our consumer can find the
 21520:                      * empty group assignment decompilation.
 21520:                      */
 21520:                     if (newtop == oldtop) {
 87952:                         ss->sprinter.setOffset(todo);
 21520:                     } else {
 21520:                         /*
     1:                          * Kill newtop before the end_groupassignment: label by
 86078:                          * retracting/popping early.
     1:                          */
 21520:                         LOCAL_ASSERT(newtop < oldtop);
 87952:                         ss->sprinter.setOffset(GetOff(ss, newtop));
     1:                         ss->top = newtop;
     1:                     }
     1: 
     1:                   end_groupassignment:
 21520:                     LOCAL_ASSERT(*pc == JSOP_POPN);
 21520: 
     1:                     /*
     1:                      * Thread directly to the next opcode if we can, to handle
     1:                      * the special cases of a group assignment in the first or
     1:                      * last part of a for(;;) loop head, or in a let block or
     1:                      * expression head.
     1:                      *
     1:                      * NB: todo at this point indexes space in ss->sprinter
     1:                      * that is liable to be overwritten.  The code below knows
     1:                      * exactly how long rval lives, or else copies it down via
 90229:                      * Sprinter::put.
     1:                      */
 87952:                     rval = ss->sprinter.stringAt(todo);
 84803:                     rvalpc = NULL;
     1:                     todo = -2;
     1:                     pc2 = pc + oplen;
 74832: 
 21520:                     if (*pc2 == JSOP_NOP) {
     1:                         sn = js_GetSrcNote(jp->script, pc2);
     1:                         if (sn) {
     1:                             if (SN_TYPE(sn) == SRC_FOR) {
 21520:                                 op = JSOP_NOP;
     1:                                 pc = pc2;
 86078:                                 todo = SprintNormalFor(cx, jp, ss, "", rval, rvalpc, &pc, &len);
 86078:                                 break;
     1:                             }
 21520:                         } else {
 21520:                             /*
 21520:                              * An unnannotated NOP following a POPN must be the
 21520:                              * third part of for(;;) loop head. If the POPN's
 21520:                              * immediate operand is 0, then we may have no slot
 21520:                              * on the sprint-stack in which to push our result
 21520:                              * string. In this case the result can be recovered
 21520:                              * at ss->sprinter.base + ss->sprinter.offset.
 21520:                              */
 21520:                             if (GET_UINT16(pc) == 0)
     1:                                 break;
 90229:                             todo = ss->sprinter.put(rval);
     1:                             saveop = JSOP_NOP;
     1:                         }
     1:                     }
     1: 
     1:                     /*
     1:                      * If control flow reaches this point with todo still -2,
     1:                      * just print rval as an expression statement.
     1:                      */
  9832:                     if (todo == -2)
     1:                         js_printf(jp, "\t%s;\n", rval);
     1:                     break;
     1:                 }
     1: #endif
     1:                 if (newtop < oldtop) {
 87952:                     ss->sprinter.setOffset(GetOff(ss, newtop));
     1:                     ss->top = newtop;
     1:                 }
     1:                 break;
     1:               }
     1: 
     1:               case JSOP_EXCEPTION:
     1:                 /* The catch decompiler handles this op itself. */
     1:                 LOCAL_ASSERT(JS_FALSE);
     1:                 break;
     1: 
     1:               case JSOP_POP:
     1:                 /*
     1:                  * By default, do not automatically parenthesize when popping
     1:                  * a stacked expression decompilation.  We auto-parenthesize
     1:                  * only when JSOP_POP is annotated with SRC_PCDELTA, meaning
     1:                  * comma operator.
     1:                  */
     1:                 op = JSOP_POPV;
     1:                 /* FALL THROUGH */
     1: 
     1:               case JSOP_POPV:
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
     1:                   case SRC_FOR:
     1:                     /* Force parens around 'in' expression at 'for' front. */
     1:                     if (ss->opcodes[ss->top-1] == JSOP_IN)
     1:                         op = JSOP_LSH;
 84803:                     rval = PopStr(ss, op, &rvalpc);
 86078:                     todo = SprintNormalFor(cx, jp, ss, "", rval, rvalpc, &pc, &len);
 86075:                     break;
     1: 
     1:                   case SRC_PCDELTA:
     1:                     /* Comma operator: use JSOP_POP for correct precedence. */
     1:                     op = JSOP_POP;
     1: 
     1:                     /* Pop and save to avoid blowing stack depth budget. */
 84803:                     lval = PopStrDupe(ss, op, &lvalpc);
     1: 
     1:                     /*
     1:                      * The offset tells distance to the end of the right-hand
     1:                      * operand of the comma operator.
     1:                      */
 84803:                     pushpc = pc;
     1:                     done = pc + len;
     1:                     pc += js_GetSrcNoteOffset(sn, 0);
     1:                     len = 0;
     1: 
 84803:                     if (!Decompile(ss, done, pc - done))
     1:                         return NULL;
     1: 
     1:                     /* Pop Decompile result and print comma expression. */
 84803:                     rval = PopStrDupe(ss, op, &rvalpc);
 87952:                     todo = ss->sprinter.getOffset();
 84803:                     SprintOpcode(ss, lval, lvalpc, pushpc, todo);
 90229:                     ss->sprinter.put(", ");
 84803:                     SprintOpcode(ss, rval, rvalpc, pushpc, todo);
     1:                     break;
     1: 
     1:                   case SRC_HIDDEN:
 38549:                     /* Hide this pop, it's from a goto in a with or for/in. */
     1:                     todo = -2;
     1:                     break;
     1: 
 86078:                   case SRC_CONTINUE:
 86078:                     /* Pop the stack, don't print: end of a for-let-in. */
 86078:                     (void) PopOff(ss, op);
 86078:                     todo = -2;
     1:                     break;
     1: 
     1:                   default:
 84803:                   {
     1:                     /* Turn off parens around a yield statement. */
     1:                     if (ss->opcodes[ss->top-1] == JSOP_YIELD)
     1:                         op = JSOP_NOP;
     1: 
 84803:                     jsbytecode *rvalpc;
 84803:                     rval = PopStr(ss, op, &rvalpc);
  1575: 
  1575:                     /*
  1575:                      * Don't emit decompiler-pushed strings that are not
  1575:                      * handled by other opcodes. They are pushed onto the
  1575:                      * stack to help model the interpreter stack and should
  1575:                      * not appear in the decompiler's output.
  1575:                      */
  1575:                     if (*rval != '\0' && (rval[0] != '/' || rval[1] != '*')) {
 84803:                         bool parens =
 84803:                             *rval == '{' ||
     1:                             (strncmp(rval, js_function_str, 8) == 0 &&
 84803:                              rval[8] == ' ');
 84803:                         js_printf(jp, parens ? "\t(" : "\t");
 84803:                         SprintOpcodePermanent(jp, rval, rvalpc);
 84803:                         js_printf(jp, parens ? ");\n" : ";\n");
  1575:                     } else {
  1575:                         LOCAL_ASSERT(*rval == '\0' ||
  1575:                                      strcmp(rval, exception_cookie) == 0);
     1:                     }
     1:                     todo = -2;
     1:                     break;
     1:                   }
 84803:                 }
   351:                 sn = NULL;
     1:                 break;
     1: 
     1:               case JSOP_ENTERWITH:
     1:                 LOCAL_ASSERT(!js_GetSrcNote(jp->script, pc));
 84803:                 rval = PopStr(ss, op, &rvalpc);
 84803:                 js_printf(jp, "\twith (");
 84803:                 SprintOpcodePermanent(jp, rval, rvalpc);
 84803:                 js_printf(jp, ") {\n");
     1:                 jp->indent += 4;
     1:                 todo = Sprint(&ss->sprinter, with_cookie);
     1:                 break;
     1: 
     1:               case JSOP_LEAVEWITH:
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 todo = -2;
     1:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
     1:                     break;
     1:                 rval = POP_STR();
     1:                 LOCAL_ASSERT(strcmp(rval, with_cookie) == 0);
     1:                 jp->indent -= 4;
     1:                 js_printf(jp, "\t}\n");
     1:                 break;
     1: 
  3235:               case JSOP_ENTERBLOCK:
     1:               {
 89253:                 obj = jp->script->getObject(GET_UINT32_INDEX(pc));
 81591:                 AtomVector atoms(cx);
 86483:                 StaticBlockObject &blockObj = obj->asStaticBlock();
 86483: 
 86483:                 if (!GetBlockNames(cx, blockObj, &atoms) || !PushBlockNames(cx, ss, atoms))
     1:                     return NULL;
 81590: 
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
     1: #if JS_HAS_BLOCK_SCOPE
     1:                   case SRC_BRACE:
  9832:                     js_printf(jp, "\t{\n");
     1:                     jp->indent += 4;
     1:                     len = js_GetSrcNoteOffset(sn, 0);
 81590:                     if (!Decompile(ss, pc + oplen, len - oplen))
 81590:                         return NULL;
     1:                     jp->indent -= 4;
     1:                     js_printf(jp, "\t}\n");
     1:                     break;
     1: #endif
     1: 
     1:                   case SRC_CATCH:
     1:                     jp->indent -= 4;
  9832:                     js_printf(jp, "\t} catch (");
     1: 
     1:                     pc2 = pc;
     1:                     pc += oplen;
 81590:                     LOCAL_ASSERT(*pc == JSOP_EXCEPTION);
     1:                     pc += JSOP_EXCEPTION_LENGTH;
   990:                     todo = Sprint(&ss->sprinter, exception_cookie);
 81590:                     if (todo < 0 || !PushOff(ss, todo, JSOP_EXCEPTION))
 81590:                         return NULL;
   990: 
     1:                     if (*pc == JSOP_DUP) {
     1:                         sn2 = js_GetSrcNote(jp->script, pc);
   990:                         if (!sn2 || SN_TYPE(sn2) != SRC_DESTRUCT) {
     1:                             /*
   990:                              * This is a dup to save the exception for later.
   990:                              * It is emitted only when the catch head contains
   190:                              * an exception guard.
     1:                              */
 81590:                             LOCAL_ASSERT(js_GetSrcNoteOffset(sn, 0) != 0);
     1:                             pc += JSOP_DUP_LENGTH;
   990:                             todo = Sprint(&ss->sprinter, exception_cookie);
 81590:                             if (todo < 0 || !PushOff(ss, todo, JSOP_EXCEPTION))
 81590:                                 return NULL;
   990:                         }
   990:                     }
   990: 
     1: #if JS_HAS_DESTRUCTURING
     1:                     if (*pc == JSOP_DUP) {
     1:                         pc = DecompileDestructuring(ss, pc, endpc);
 81590:                         if (!pc)
 81590:                             return NULL;
 81590:                         LOCAL_ASSERT(*pc == JSOP_POP);
     1:                         pc += JSOP_POP_LENGTH;
     1:                         lval = PopStr(ss, JSOP_NOP);
     1:                         js_puts(jp, lval);
     1:                     } else {
     1: #endif
 95101:                         LOCAL_ASSERT(*pc == JSOP_SETLOCAL || *pc == JSOP_SETALIASEDVAR);
 95101:                         pc += js_CodeSpec[*pc].length;
 94278:                         LOCAL_ASSERT(*pc == JSOP_POP);
 94278:                         pc += JSOP_POP_LENGTH;
 86483:                         LOCAL_ASSERT(blockObj.slotCount() >= 1);
 82153:                         if (!QuoteString(&jp->sprinter, atoms[0], 0))
 81590:                             return NULL;
     1: #if JS_HAS_DESTRUCTURING
     1:                     }
     1: #endif
     1: 
  1041:                     /*
  1041:                      * Pop the exception_cookie (or its dup in the case of a
  1041:                      * guarded catch head) off the stack now.
  1041:                      */
  1041:                     rval = PopStr(ss, JSOP_NOP);
 81590:                     LOCAL_ASSERT(strcmp(rval, exception_cookie) == 0);
  1041: 
     1:                     len = js_GetSrcNoteOffset(sn, 0);
     1:                     if (len) {
 25144:                         len -= pc - pc2;
 81590:                         LOCAL_ASSERT(len > 0);
     1:                         js_printf(jp, " if ");
 81590:                         if (!Decompile(ss, pc, len))
 81590:                             return NULL;
     1:                         js_printf(jp, "%s", POP_STR());
     1:                         pc += len;
 86877:                         LOCAL_ASSERT(*pc == JSOP_IFEQ);
     1:                         pc += js_CodeSpec[*pc].length;
     1:                     }
     1: 
     1:                     js_printf(jp, ") {\n");
     1:                     jp->indent += 4;
     1:                     len = 0;
     1:                     break;
 81590:                   default:;
     1:                 }
     1: 
     1:                 todo = -2;
     1:               }
  8285:               break;
     1: 
     1:               case JSOP_LEAVEBLOCK:
     1:               case JSOP_LEAVEBLOCKEXPR:
     1:               {
 91237:                 unsigned top, depth;
     1: 
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 todo = -2;
     1:                 if (op == JSOP_LEAVEBLOCKEXPR) {
     1:                     LOCAL_ASSERT(SN_TYPE(sn) == SRC_PCBASE);
     1:                     rval = POP_STR();
     1:                 } else if (sn) {
     1:                     LOCAL_ASSERT(op == JSOP_LEAVEBLOCK);
     1:                     if (SN_TYPE(sn) == SRC_HIDDEN)
     1:                         break;
   990: 
   990:                     /*
   990:                      * This JSOP_LEAVEBLOCK must be for a catch block. If sn's
   990:                      * offset does not equal the model stack depth, there must
   990:                      * be a copy of the exception value on the stack due to a
   990:                      * catch guard (see above, the JSOP_ENTERBLOCK + SRC_CATCH
   990:                      * case code).
   990:                      */
     1:                     LOCAL_ASSERT(SN_TYPE(sn) == SRC_CATCH);
 91237:                     if ((unsigned)js_GetSrcNoteOffset(sn, 0) != ss->top) {
 91237:                         LOCAL_ASSERT((unsigned)js_GetSrcNoteOffset(sn, 0)
   990:                                      == ss->top - 1);
   990:                         rval = POP_STR();
   990:                         LOCAL_ASSERT(strcmp(rval, exception_cookie) == 0);
   990:                     }
     1:                 }
     1:                 top = ss->top;
     1:                 depth = GET_UINT16(pc);
     1:                 LOCAL_ASSERT(top >= depth);
     1:                 top -= depth;
     1:                 ss->top = top;
 87952:                 ss->sprinter.setOffset(GetOff(ss, top));
     1:                 if (op == JSOP_LEAVEBLOCKEXPR)
 90229:                     todo = ss->sprinter.put(rval);
     1:                 break;
     1:               }
     1: 
 86078:               case JSOP_ENTERLET0:
 86078:               {
 89253:                 obj = jp->script->getObject(GET_UINT32_INDEX(pc));
 86483:                 StaticBlockObject &blockObj = obj->asStaticBlock();
 86078: 
 86078:                 AtomVector atoms(cx);
 86483:                 if (!GetBlockNames(cx, blockObj, &atoms))
 86078:                     return NULL;
 86078: 
 86078:                 sn = js_GetSrcNote(jp->script, pc);
 86078:                 LOCAL_ASSERT(SN_TYPE(sn) == SRC_DECL);
 86078:                 ptrdiff_t letData = js_GetSrcNoteOffset(sn, 0);
 86078:                 bool groupAssign = LetDataToGroupAssign(letData);
 91237:                 unsigned letDepth = blockObj.stackDepth();
 91237:                 LOCAL_ASSERT(letDepth == (unsigned)ss->top - blockObj.slotCount());
 86483:                 LOCAL_ASSERT(atoms.length() == blockObj.slotCount());
 86078: 
 86078:                 /*
 86078:                  * Build the list of decompiled rhs expressions. Do this before
 86078:                  * sprinting the let-head since GetStr can inject stuff on top
 86078:                  * of the stack (in case js_DecompileValueGenerator).
 86078:                  */
 86078:                 Vector<const char *> rhsExprs(cx);
 86078:                 if (!rhsExprs.resize(atoms.length()))
 86081:                     return NULL;
 87952:                 for (size_t i = 0; i < rhsExprs.length(); ++i)
 87952:                     rhsExprs[i] = SprintDupeStr(ss, GetStr(ss, letDepth + i));
 86078: 
 86078:                 /* Build the let head starting at headBegin. */
 87952:                 ptrdiff_t headBegin = ss->sprinter.getOffset();
 86078: 
 86078:                 /*
 86078:                  * For group assignment, prepend the '[lhs-vars] = [' here,
 86078:                  * append rhsExprs in the next loop and append ']' after.
 86078:                  */
 86078:                 if (groupAssign) {
 86078:                     if (Sprint(&ss->sprinter, "[") < 0)
 86081:                         return NULL;
 86078:                     for (size_t i = 0; i < atoms.length(); ++i) {
 86078:                         if (i && Sprint(&ss->sprinter, ", ") < 0)
 86081:                             return NULL;
 86078:                         if (!QuoteString(&ss->sprinter, atoms[i], 0))
 86081:                             return NULL;
 86078:                     }
 86078:                     if (Sprint(&ss->sprinter, "] = [") < 0)
 86081:                         return NULL;
 86078:                 }
 86078: 
 86078:                 for (size_t i = 0; i < atoms.length(); ++i) {
 86078:                     const char *rhs = rhsExprs[i];
 86078:                     if (!strcmp(rhs, SkipString))
 86078:                         continue;
 86078: 
 86078:                     if (i && Sprint(&ss->sprinter, ", ") < 0)
 86081:                         return NULL;
 86078: 
 86078:                     if (groupAssign) {
 90229:                         if (ss->sprinter.put(rhs) < 0)
 86081:                             return NULL;
 86078:                     } else if (!strncmp(rhs, DestructuredString, DestructuredStringLength)) {
 90229:                         if (ss->sprinter.put(rhs + DestructuredStringLength) < 0)
 86081:                             return NULL;
 86078:                     } else {
 86078:                         JS_ASSERT(atoms[i] != cx->runtime->atomState.emptyAtom);
 86078:                         if (!QuoteString(&ss->sprinter, atoms[i], 0))
 86081:                             return NULL;
 86078:                         if (*rhs) {
 86078:                             uint8_t prec = js_CodeSpec[ss->opcodes[letDepth + i]].prec;
 86078:                             const char *fmt = prec && prec < js_CodeSpec[JSOP_SETLOCAL].prec
 86078:                                               ? " = (%s)"
 86078:                                               : " = %s";
 86078:                             if (Sprint(&ss->sprinter, fmt, rhs) < 0)
 86081:                                 return NULL;
 86078:                         }
 86078:                     }
 86078:                 }
 86078: 
 86078:                 if (groupAssign && Sprint(&ss->sprinter, "]") < 0)
 86081:                     return NULL;
 86078: 
 86078:                 /* Clone the let head chars before clobbering the stack. */
 86078:                 DupBuffer head(cx);
 87952:                 if (!Dup(ss->sprinter.stringAt(headBegin), &head))
 86078:                     return NULL;
 86078:                 if (!AssignBlockNamesToPushedSlots(cx, ss, atoms))
 86078:                     return NULL;
 86078: 
 86078:                 /* Detect 'for (let ...)' desugared into 'let (...) {for}'. */
 86078:                 jsbytecode *nextpc = pc + JSOP_ENTERLET0_LENGTH;
 86078:                 if (*nextpc == JSOP_NOP) {
 86078:                     jssrcnote *nextsn = js_GetSrcNote(jp->script, nextpc);
 86078:                     if (nextsn && SN_TYPE(nextsn) == SRC_FOR) {
 86078:                         pc = nextpc;
 86078:                         todo = SprintNormalFor(cx, jp, ss, "let ", head.begin(), pc, &pc, &len);
 86078:                         break;
 86078:                     }
 86078:                 }
 86078: 
 86078:                 /* Decompile the body and then complete the let block/expr. */
 86078:                 len = LetDataToOffset(letData);
 86078:                 pc = nextpc;
 86078:                 saveop = (JSOp) pc[len];
 86078:                 todo = SprintLetBody(cx, jp, ss, pc, len, head.begin());
 86078:                 break;
 86078:               }
 86078: 
 86078:               /*
 86078:                * With 'for (let lhs in rhs)' and 'switch (c) { let-decl }',
 86078:                * placeholder slots have already been pushed (by JSOP_UNDEFINED).
 86078:                * In both the for-let-in and switch-hoisted-let cases:
 86078:                *  - there is a non-let slot on top of the stack (hence enterlet1)
 86078:                *  - there is no further special let-handling required:
 86078:                *    for-let-in will decompile the let head when it decompiles
 86078:                *    the loop body prologue; there is no let head to decompile
 86078:                *    with switch.
 86078:                * Hence, the only thing to do is update the let vars' slots with
 86078:                * their names, taking care to preserve the iter/condition value
 86078:                * on top of the stack.
 86078:                */
 86078:               case JSOP_ENTERLET1:
 86078:               {
 89253:                 obj = jp->script->getObject(GET_UINT32_INDEX(pc));
 86483:                 StaticBlockObject &blockObj = obj->asStaticBlock();
 86078: 
 86078:                 AtomVector atoms(cx);
 86483:                 if (!GetBlockNames(cx, blockObj, &atoms))
 86078:                     return NULL;
 86078: 
 86078:                 LOCAL_ASSERT(js_GetSrcNote(jp->script, pc) == NULL);
 86483:                 LOCAL_ASSERT(ss->top - 1 == blockObj.stackDepth() + blockObj.slotCount());
 86078:                 jsbytecode *nextpc = pc + JSOP_ENTERLET1_LENGTH;
 86877:                 if (*nextpc == JSOP_GOTO) {
 86078:                     LOCAL_ASSERT(SN_TYPE(js_GetSrcNote(jp->script, nextpc)) == SRC_FOR_IN);
 86078:                 } else {
 86078:                     LOCAL_ASSERT(*nextpc == JSOP_CONDSWITCH ||
 86877:                                  *nextpc == JSOP_TABLESWITCH ||
 86877:                                  *nextpc == JSOP_LOOKUPSWITCH);
 86078:                 }
 86078: 
 86078:                 DupBuffer rhs(cx);
 86078:                 if (!Dup(PopStr(ss, JSOP_NOP), &rhs))
 86078:                     return NULL;
 86078:                 if (!AssignBlockNamesToPushedSlots(cx, ss, atoms))
 86078:                     return NULL;
 86078:                 if (!PushStr(ss, rhs.begin(), op))
 86078:                     return NULL;
 86078:                 todo = -2;
 86078:                 break;
 86078:               }
 86078: 
 95101:               case JSOP_CALLALIASEDVAR:
 95101:               case JSOP_GETALIASEDVAR:
     1:               case JSOP_CALLLOCAL:
     1:               case JSOP_GETLOCAL:
 95101:                 if (IsVarSlot(jp, pc, &atom, &i))
 16429:                     goto do_name;
 91237:                 LOCAL_ASSERT((unsigned)i < ss->top);
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1: 
     1: #if JS_HAS_DESTRUCTURING
 23236:                 if (sn && SN_TYPE(sn) == SRC_GROUPASSIGN) {
 23236:                     /*
 23236:                      * Distinguish a js_DecompileValueGenerator call that
 23236:                      * targets op alone, from decompilation of a full group
 23236:                      * assignment sequence, triggered by SRC_GROUPASSIGN
 23236:                      * annotating the first JSOP_GETLOCAL in the sequence.
 23236:                      */
 23236:                     if (endpc - pc > JSOP_GETLOCAL_LENGTH || pc > startpc) {
     1:                         pc = DecompileGroupAssignment(ss, pc, endpc, sn, &todo);
     1:                         if (!pc)
     1:                             return NULL;
  1227:                         LOCAL_ASSERT(*pc == JSOP_POPN);
  1227:                         len = oplen = JSOP_POPN_LENGTH;
     1:                         goto end_groupassignment;
     1:                     }
 23236: 
 23236:                     /* Null sn to prevent bogus VarPrefix'ing below. */
 23236:                     sn = NULL;
 23236:                 }
     1: #endif
     1: 
     1:                 rval = GetLocal(ss, i);
     1:                 todo = Sprint(&ss->sprinter, ss_format, VarPrefix(sn), rval);
     1:                 break;
     1: 
 95101:               case JSOP_SETALIASEDVAR:
     1:               case JSOP_SETLOCAL:
 95101:                 if (IsVarSlot(jp, pc, &atom, &i))
 16429:                     goto do_setname;
 21865:                 lval = GetLocal(ss, i);
 84803:                 rval = PopStrDupe(ss, op, &rvalpc);
     1:                 goto do_setlval;
     1: 
 95101:               case JSOP_INCALIASEDVAR:
 95101:               case JSOP_DECALIASEDVAR:
     1:               case JSOP_INCLOCAL:
     1:               case JSOP_DECLOCAL:
 95101:                 if (IsVarSlot(jp, pc, &atom, &i))
 16429:                     goto do_incatom;
     1:                 lval = GetLocal(ss, i);
     1:                 goto do_inclval;
     1: 
 95101:               case JSOP_ALIASEDVARINC:
 95101:               case JSOP_ALIASEDVARDEC:
     1:               case JSOP_LOCALINC:
     1:               case JSOP_LOCALDEC:
 95101:                 if (IsVarSlot(jp, pc, &atom, &i))
 16429:                     goto do_atominc;
     1:                 lval = GetLocal(ss, i);
     1:                 goto do_lvalinc;
     1: 
     1:               case JSOP_RETRVAL:
     1:                 todo = -2;
     1:                 break;
     1: 
  1967:               case JSOP_RETURN:
  8179:                 LOCAL_ASSERT(jp->fun);
  8179:                 fun = jp->fun;
  1967:                 if (fun->flags & JSFUN_EXPR_CLOSURE) {
 20928:                     /* Turn on parens around comma-expression here. */
 20928:                     op = JSOP_SETNAME;
 84803:                     rval = PopStr(ss, op, &rvalpc);
 84803:                     bool parens = (*rval == '{');
 84803:                     if (parens)
 84803:                         js_printf(jp, "(");
 84803:                     SprintOpcodePermanent(jp, rval, rvalpc);
 84803:                     js_printf(jp, parens ? ")%s" : "%s",
  1967:                               ((fun->flags & JSFUN_LAMBDA) || !fun->atom)
  1967:                               ? ""
  1967:                               : ";");
  1967:                     todo = -2;
  1967:                     break;
  1967:                 }
  1967:                 /* FALL THROUGH */
  1967: 
     1:               case JSOP_SETRVAL:
 84803:                 rval = PopStr(ss, op, &rvalpc);
 84803:                 if (*rval != '\0') {
 84803:                     js_printf(jp, "\t%s ", js_return_str);
 84803:                     SprintOpcodePermanent(jp, rval, rvalpc);
 84803:                     js_printf(jp, ";\n");
 84803:                 } else {
     1:                     js_printf(jp, "\t%s;\n", js_return_str);
 84803:                 }
     1:                 todo = -2;
     1:                 break;
     1: 
     1: #if JS_HAS_GENERATORS
     1:               case JSOP_YIELD:
  1760: #if JS_HAS_GENERATOR_EXPRS
  1760:                 if (!ss->inGenExp || !(sn = js_GetSrcNote(jp->script, pc)))
  1760: #endif
  1760:                 {
  1967:                     /* Turn off most parens. */
  1967:                     op = JSOP_SETNAME;
     1:                     rval = POP_STR();
     1:                     todo = (*rval != '\0')
     1:                            ? Sprint(&ss->sprinter,
     1:                                     (strncmp(rval, js_yield_str, 5) == 0 &&
     1:                                      (rval[5] == ' ' || rval[5] == '\0'))
     1:                                     ? "%s (%s)"
     1:                                     : "%s %s",
     1:                                     js_yield_str, rval)
 90229:                            : ss->sprinter.put(js_yield_str);
     1:                     break;
  1577:                 }
 27012: 
  1760: #if JS_HAS_GENERATOR_EXPRS
  1577:                 LOCAL_ASSERT(SN_TYPE(sn) == SRC_HIDDEN);
  1577:                 /* FALL THROUGH */
  1760: #endif
     1: 
     1:               case JSOP_ARRAYPUSH:
     1:               {
  1967:                 /* Turn off most parens. */
  1967:                 op = JSOP_SETNAME;
  1967: 
  1577:                 /* Pop the expression being pushed or yielded. */
     1:                 rval = POP_STR();
  1577: 
  1577:                 /*
 74052:                  * Skip the for loop head stacked by JSOP_GOTO:SRC_FOR_IN until
 74052:                  * we hit a block local slot (note empty destructuring patterns
 74052:                  * result in unit-count blocks).
  1577:                  */
 91237:                 unsigned pos = ss->top;
 20943:                 while (pos != 0) {
 20943:                     op = (JSOp) ss->opcodes[--pos];
 21441:                     if (op == JSOP_ENTERBLOCK)
  1577:                         break;
  1577:                 }
 20943:                 JS_ASSERT(op == JSOP_ENTERBLOCK);
  1577: 
  1577:                 /*
 20943:                  * Here, forpos must index the space before the left-most |for|
 20943:                  * in the single string of accumulated |for| heads and optional
  1577:                  * final |if (condition)|.
  1577:                  */
 91237:                 unsigned forpos = pos + 1;
  1577:                 LOCAL_ASSERT(forpos < ss->top);
  1577: 
  1577:                 /*
 20943:                  * Now move pos downward over the block's local slots. Even an
 20943:                  * empty destructuring pattern has one (dummy) local.
  1577:                  */
     1:                 while (ss->opcodes[pos] == JSOP_ENTERBLOCK) {
     1:                     if (pos == 0)
     1:                         break;
     1:                     --pos;
     1:                 }
  1577: 
  1760: #if JS_HAS_GENERATOR_EXPRS
  1577:                 if (saveop == JSOP_YIELD) {
  1577:                     /*
  1577:                      * Generator expression: decompile just rval followed by
  1577:                      * the string starting at forpos. Leave the result string
  1577:                      * in ss->offsets[0] so it can be recovered by our caller
  1577:                      * (the JSOP_ANONFUNOBJ with SRC_GENEXP case). Bump the
  1577:                      * top of stack to balance yield, which is an expression
  1577:                      * (so has neutral stack balance).
  1577:                      */
  1577:                     LOCAL_ASSERT(pos == 0);
 87952:                     xval = ss->sprinter.stringAt(ss->offsets[forpos]);
 87952:                     ss->sprinter.setOffset(PAREN_SLOP);
  1577:                     todo = Sprint(&ss->sprinter, ss_format, rval, xval);
  1577:                     if (todo < 0)
  1577:                         return NULL;
  1577:                     ss->offsets[0] = todo;
  1577:                     ++ss->top;
  1577:                     return pc;
  1577:                 }
  1760: #endif /* JS_HAS_GENERATOR_EXPRS */
  1577: 
  1577:                 /*
  1577:                  * Array comprehension: retract the sprinter to the beginning
  1577:                  * of the array initialiser and decompile "[<rval> for ...]".
  1577:                  */
 27012:                 JS_ASSERT(jp->script->nfixed + pos == GET_UINT16(pc));
     1:                 LOCAL_ASSERT(ss->opcodes[pos] == JSOP_NEWINIT);
 27012: 
 74052:                 ptrdiff_t start = ss->offsets[pos];
 87952:                 LOCAL_ASSERT(ss->sprinter[start] == '[' ||
 87952:                              ss->sprinter[start] == '#');
  1577:                 LOCAL_ASSERT(forpos < ss->top);
 87952:                 xval = ss->sprinter.stringAt(ss->offsets[forpos]);
 87952:                 lval = ss->sprinter.stringAt(start);
 87952:                 ss->sprinter.setOffset(lval);
  1577: 
 20943:                 todo = Sprint(&ss->sprinter, sss_format, lval, rval, xval);
     1:                 if (todo < 0)
     1:                     return NULL;
  1577:                 ss->offsets[pos] = todo;
     1:                 todo = -2;
     1:                 break;
     1:               }
 27012: #endif /* JS_HAS_GENERATORS */
     1: 
     1:               case JSOP_THROWING:
     1:                 todo = -2;
     1:                 break;
     1: 
     1:               case JSOP_THROW:
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 todo = -2;
     1:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
     1:                     break;
 84803:                 rval = PopStr(ss, op, &rvalpc);
 84803:                 js_printf(jp, "\t%s ", js_throw_str);
 84803:                 SprintOpcodePermanent(jp, rval, rvalpc);
 84803:                 js_printf(jp, ";\n");
     1:                 break;
     1: 
 21441:               case JSOP_ITER:
 89621:                 forOf = (GET_UINT8(pc) == JSITER_FOR_OF);
 87974:                 foreach = (GET_UINT8(pc) & (JSITER_FOREACH | JSITER_KEYVALUE)) ==
 21441:                           JSITER_FOREACH;
 42641:                 todo = -2;
 42641:                 break;
 42641: 
 42641:               case JSOP_MOREITER:
 42641:                 JS_NOT_REACHED("JSOP_MOREITER");
 21441:                 break;
 21441: 
 21441:               case JSOP_ENDITER:
 21441:                 sn = js_GetSrcNote(jp->script, pc);
 21441:                 todo = -2;
 21441:                 if (sn && SN_TYPE(sn) == SRC_HIDDEN)
 21441:                     break;
 21441:                 (void) PopOff(ss, op);
 21441:                 break;
 21441: 
     1:               case JSOP_GOTO:
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
 20943:                   case SRC_FOR_IN:
 20943:                     /*
 74052:                      * The bytecode around pc looks like this:
 74052:                      *     <<RHS>>
 74052:                      *     iter
 98643:                      * pc: goto C               [src_for_in(B, D)]
 77824:                      *  A: <<LHS = iternext>>
 74052:                      *  B: pop                  [maybe a src_decl_var/let]
 74052:                      *     <<S>>
 74052:                      *  C: moreiter
 98643:                      *     ifne A
 74052:                      *     enditer
 74052:                      *  D: ...
 74052:                      *
 74052:                      * In an array comprehension or generator expression, we
 74052:                      * construct the for-head and store it in the slot pushed
 74052:                      * by JSOP_ITER, then recurse to decompile S. The
 74052:                      * culminating JSOP_ARRAYPUSH or JSOP_YIELD instruction
 74052:                      * (which S must contain, by construction) glues all the
 74052:                      * clauses together.
 74052:                      *
 74052:                      * Otherwise this is a for-in statement. We eagerly output
 74052:                      * the for-head and recurse to decompile the controlled
 74052:                      * statement S.
 74052:                      *
 74052:                      * We never decompile the obligatory JSOP_POP,
 74052:                      * JSOP_MOREITER or JSOP_IFNE, though we do quick asserts
 74052:                      * to check that they are there.
 20943:                      */
 86877:                     cond = GET_JUMP_OFFSET(pc);
 20943:                     next = js_GetSrcNoteOffset(sn, 0);
 20943:                     tail = js_GetSrcNoteOffset(sn, 1);
 77824:                     JS_ASSERT(pc[next] == JSOP_POP);
 87961:                     JS_ASSERT(pc[cond] == JSOP_LOOPENTRY);
 87961:                     cond += JSOP_LOOPENTRY_LENGTH;
 77824:                     JS_ASSERT(pc[cond] == JSOP_MOREITER);
 20943:                     DECOMPILE_CODE(pc + oplen, next - oplen);
 21441:                     lval = POP_STR();
 74052: 
 74052:                     /*
 74052:                      * This string "<next>" comes from jsopcode.tbl. It stands
 74052:                      * for the result pushed by JSOP_ITERNEXT.
 74052:                      */
 77824:                     JS_ASSERT(strcmp(lval + strlen(lval) - 9, " = <next>") == 0);
 74052:                     const_cast<char *>(lval)[strlen(lval) - 9] = '\0';
 42641:                     LOCAL_ASSERT(ss->top >= 1);
 27012: 
 21436:                     if (ss->inArrayInit || ss->inGenExp) {
 42641:                         rval = POP_STR();
 42641:                         if (ss->top >= 1 && ss->opcodes[ss->top - 1] == JSOP_FORLOCAL) {
 87952:                             ss->sprinter.setOffset(ss->offsets[ss->top] - PAREN_SLOP);
 89621:                             if (Sprint(&ss->sprinter, " %s (%s %s %s)",
 20943:                                        foreach ? js_for_each_str : js_for_str,
 89621:                                        lval,
 89621:                                        forOf ? "of" : "in",
 89621:                                        rval) < 0) {
 20943:                                 return NULL;
 20943:                             }
 20943: 
 20943:                             /*
 86078:                              * Do not AddParenSlop here, as we will push the
 20943:                              * top-most offset again, which will add paren slop
 20943:                              * for us. We must push to balance the stack budget
 20943:                              * when nesting for heads in a comprehension.
 20943:                              */
 20943:                             todo = ss->offsets[ss->top - 1];
 20943:                         } else {
 89621:                             todo = Sprint(&ss->sprinter, " %s (%s %s %s)",
 20943:                                           foreach ? js_for_each_str : js_for_str,
 89621:                                           lval,
 89621:                                           forOf ? "of" : "in",
 89621:                                           rval);
 20943:                         }
 20943:                         if (todo < 0 || !PushOff(ss, todo, JSOP_FORLOCAL))
 20943:                             return NULL;
 74052:                         DECOMPILE_CODE(pc + next + JSOP_POP_LENGTH, cond - next - JSOP_POP_LENGTH);
 20943:                     } else {
 20943:                         /*
 20943:                          * As above, rval or an extension of it must remain
 20943:                          * stacked during loop body decompilation.
 20943:                          */
 42641:                         rval = GetStr(ss, ss->top - 1);
 74052:                         xval = VarPrefix(js_GetSrcNote(jp->script, pc + next));
 89621:                         js_printf(jp, "\t%s (%s%s %s %s) {\n",
 20943:                                   foreach ? js_for_each_str : js_for_str,
 89621:                                   xval,
 89621:                                   lval,
 89621:                                   forOf ? "of" : "in",
 89621:                                   rval);
 20943:                         jp->indent += 4;
 74052:                         DECOMPILE_CODE(pc + next + JSOP_POP_LENGTH, cond - next - JSOP_POP_LENGTH);
 20943:                         jp->indent -= 4;
 20943:                         js_printf(jp, "\t}\n");
 20943:                     }
 27012: 
 20943:                     pc += tail;
 86877:                     LOCAL_ASSERT(*pc == JSOP_IFNE);
 20943:                     len = js_CodeSpec[*pc].length;
 20943:                     break;
 20943: 
     1:                   case SRC_WHILE:
 86877:                     cond = GET_JUMP_OFFSET(pc);
     1:                     tail = js_GetSrcNoteOffset(sn, 0);
     1:                     DECOMPILE_CODE(pc + cond, tail - cond);
 84803:                     js_printf(jp, "\twhile (");
 84803:                     rval = PopCondStr(ss, &rvalpc);
 84803:                     SprintOpcodePermanent(jp, rval, rvalpc);
 84803:                     js_printf(jp, ") {\n");
     1:                     jp->indent += 4;
     1:                     DECOMPILE_CODE(pc + oplen, cond - oplen);
     1:                     jp->indent -= 4;
     1:                     js_printf(jp, "\t}\n");
     1:                     pc += tail;
 86877:                     LOCAL_ASSERT(*pc == JSOP_IFNE);
     1:                     len = js_CodeSpec[*pc].length;
     1:                     todo = -2;
     1:                     break;
     1: 
     1:                   case SRC_CONT2LABEL:
  4342:                     GET_SOURCE_NOTE_ATOM(sn, atom);
 64345:                     rval = QuoteString(&ss->sprinter, atom, 0);
     1:                     if (!rval)
     1:                         return NULL;
 87952:                     ss->sprinter.setOffset(rval);
     1:                     js_printf(jp, "\tcontinue %s;\n", rval);
     1:                     break;
     1: 
     1:                   case SRC_CONTINUE:
     1:                     js_printf(jp, "\tcontinue;\n");
     1:                     break;
     1: 
     1:                   case SRC_BREAK2LABEL:
  4342:                     GET_SOURCE_NOTE_ATOM(sn, atom);
 64345:                     rval = QuoteString(&ss->sprinter, atom, 0);
     1:                     if (!rval)
     1:                         return NULL;
 87952:                     ss->sprinter.setOffset(rval);
     1:                     js_printf(jp, "\tbreak %s;\n", rval);
     1:                     break;
     1: 
     1:                   case SRC_HIDDEN:
     1:                     break;
     1: 
     1:                   default:
     1:                     js_printf(jp, "\tbreak;\n");
     1:                     break;
     1:                 }
     1:                 todo = -2;
     1:                 break;
     1: 
     1:               case JSOP_IFEQ:
     1:               {
     1:                 JSBool elseif = JS_FALSE;
     1: 
     1:               if_again:
 86877:                 len = GET_JUMP_OFFSET(pc);
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1: 
     1:                 switch (sn ? SN_TYPE(sn) : SRC_NULL) {
     1:                   case SRC_IF:
     1:                   case SRC_IF_ELSE:
 84803:                     rval = PopCondStr(ss, &rvalpc);
  1577:                     if (ss->inArrayInit || ss->inGenExp) {
     1:                         LOCAL_ASSERT(SN_TYPE(sn) == SRC_IF);
 87952:                         ss->sprinter.setOffset(ss->sprinter.getOffset() - PAREN_SLOP);
     1:                         if (Sprint(&ss->sprinter, " if (%s)", rval) < 0)
     1:                             return NULL;
  1577:                         AddParenSlop(ss);
     1:                     } else {
 84803:                         js_printf(jp, elseif ? " if (" : "\tif (");
 84803:                         SprintOpcodePermanent(jp, rval, rvalpc);
 84803:                         js_printf(jp, ") {\n");
     1:                         jp->indent += 4;
     1:                     }
     1: 
     1:                     if (SN_TYPE(sn) == SRC_IF) {
     1:                         DECOMPILE_CODE(pc + oplen, len - oplen);
     1:                     } else {
  1577:                         LOCAL_ASSERT(!ss->inArrayInit && !ss->inGenExp);
     1:                         tail = js_GetSrcNoteOffset(sn, 0);
     1:                         DECOMPILE_CODE(pc + oplen, tail - oplen);
     1:                         jp->indent -= 4;
     1:                         pc += tail;
 86877:                         LOCAL_ASSERT(*pc == JSOP_GOTO);
     1:                         oplen = js_CodeSpec[*pc].length;
 86877:                         len = GET_JUMP_OFFSET(pc);
     1:                         js_printf(jp, "\t} else");
     1: 
     1:                         /*
     1:                          * If the second offset for sn is non-zero, it tells
     1:                          * the distance from the goto around the else, to the
     1:                          * ifeq for the if inside the else that forms an "if
     1:                          * else if" chain.  Thus cond spans the condition of
     1:                          * the second if, so we simply decompile it and start
     1:                          * over at label if_again.
     1:                          */
 41815:                         cond = js_GetSrcNoteOffset(sn, 1);
     1:                         if (cond != 0) {
 41816:                             cond -= tail;
     1:                             DECOMPILE_CODE(pc + oplen, cond - oplen);
     1:                             pc += cond;
 41969:                             oplen = js_CodeSpec[*pc].length;
     1:                             elseif = JS_TRUE;
     1:                             goto if_again;
     1:                         }
     1: 
  9832:                         js_printf(jp, " {\n");
     1:                         jp->indent += 4;
     1:                         DECOMPILE_CODE(pc + oplen, len - oplen);
     1:                     }
     1: 
  1577:                     if (!ss->inArrayInit && !ss->inGenExp) {
     1:                         jp->indent -= 4;
     1:                         js_printf(jp, "\t}\n");
     1:                     }
     1:                     todo = -2;
     1:                     break;
     1: 
     1:                   case SRC_COND:
 84803:                     xval = PopStrDupe(ss, op, &xvalpc);
     1:                     len = js_GetSrcNoteOffset(sn, 0);
 84803:                     DECOMPILE_CODE(pc + oplen, len - oplen);
 84803:                     lval = PopStrDupe(ss, op, &lvalpc);
 84803:                     pushpc = pc;
     1:                     pc += len;
 86877:                     LOCAL_ASSERT(*pc == JSOP_GOTO);
     1:                     oplen = js_CodeSpec[*pc].length;
 86877:                     len = GET_JUMP_OFFSET(pc);
 84803:                     DECOMPILE_CODE(pc + oplen, len - oplen);
 84803:                     rval = PopStrDupe(ss, op, &rvalpc);
 87952:                     todo = ss->sprinter.getOffset();
 84803:                     SprintOpcode(ss, xval, xvalpc, pushpc, todo);
 90229:                     ss->sprinter.put(" ? ");
 84803:                     SprintOpcode(ss, lval, lvalpc, pushpc, todo);
 90229:                     ss->sprinter.put(" : ");
 84803:                     SprintOpcode(ss, rval, rvalpc, pushpc, todo);
 84803:                     break;
 71343: 
     1:                   default:
     1:                     break;
     1:                 }
     1:                 break;
     1:               }
     1: 
     1:               case JSOP_IFNE:
     1:                 LOCAL_ASSERT(0);
     1:                 break;
     1: 
     1:               case JSOP_OR:
     1:                 xval = "||";
     1: 
     1:               do_logical_connective:
     1:                 /* Top of stack is the first clause in a disjunction (||). */
 84803:                 lval = PopStrDupe(ss, op, &lvalpc);
 86877:                 done = pc + GET_JUMP_OFFSET(pc);
 84803:                 pushpc = pc;
     1:                 pc += len;
 82080:                 JS_ASSERT(*pc == JSOP_POP);
 82080:                 pc += JSOP_POP_LENGTH;
 25144:                 len = done - pc;
 84803:                 if (!Decompile(ss, pc, len))
  1967:                     return NULL;
 84803:                 rval = PopStrDupe(ss, op, &rvalpc);
 84803:                 if (!rval)
 84803:                     return NULL;
 87952:                 todo = ss->sprinter.getOffset();
 84803:                 SprintOpcode(ss, lval, lvalpc, pushpc, todo);
     1:                 if (jp->pretty &&
     1:                     jp->indent + 4 + strlen(lval) + 4 + strlen(rval) > 75) {
 84803:                     Sprint(&ss->sprinter, " %s\n", xval);
 84803:                     Sprint(&ss->sprinter, "%*s", jp->indent + 4, "");
     1:                 } else {
 84803:                     Sprint(&ss->sprinter, " %s ", xval);
 84803:                 }
 84803:                 SprintOpcode(ss, rval, rvalpc, pushpc, todo);
     1:                 break;
     1: 
     1:               case JSOP_AND:
     1:                 xval = "&&";
     1:                 goto do_logical_connective;
     1: 
     1:               case JSOP_ENUMELEM:
     1:               case JSOP_ENUMCONSTELEM:
     1:                 /*
     1:                  * The stack has the object under the (top) index expression.
     1:                  * The "rval" property id is underneath those two on the stack.
     1:                  * The for loop body net and gross lengths can now be adjusted
     1:                  * to account for the length of the indexing expression that
     1:                  * came after JSOP_FORELEM and before JSOP_ENUMELEM.
     1:                  */
     1:                 atom = NULL;
   351:                 op = JSOP_NOP;          /* turn off parens around xval */
     1:                 xval = POP_STR();
     1:                 op = JSOP_GETELEM;      /* lval must have high precedence */
     1:                 lval = POP_STR();
     1:                 op = saveop;
     1:                 rval = POP_STR();
     1:                 LOCAL_ASSERT(strcmp(rval, forelem_cookie) == 0);
 20943:                 if (*xval == '\0') {
 90229:                     todo = ss->sprinter.put(lval);
 20943:                 } else {
 20943:                     todo = Sprint(&ss->sprinter,
 20943:                                   (JOF_OPMODE(lastop) == JOF_XMLNAME)
 20943:                                   ? dot_format
 20943:                                   : index_format,
 20943:                                   lval, xval);
 20943:                 }
 20943:                 break;
     1: 
     1:               case JSOP_GETTER:
     1:               case JSOP_SETTER:
     1:                 todo = -2;
     1:                 break;
     1: 
     1:               case JSOP_DUP2:
     1:                 rval = GetStr(ss, ss->top-2);
 90229:                 todo = ss->sprinter.put(rval);
  3164:                 if (todo < 0 || !PushOff(ss, todo,
  3164:                                          (JSOp) ss->opcodes[ss->top-2])) {
     1:                     return NULL;
  3164:                 }
     1:                 /* FALL THROUGH */
     1: 
     1:               case JSOP_DUP:
     1: #if JS_HAS_DESTRUCTURING
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 if (sn) {
 86078:                     if (SN_TYPE(sn) == SRC_DESTRUCT) {
     1:                         pc = DecompileDestructuring(ss, pc, endpc);
     1:                         if (!pc)
     1:                             return NULL;
 86078: 
 94277:                         /* Left-hand side never needs parens. */
 94277:                         JS_ASSERT(js_CodeSpec[JSOP_POP].prec <= 3);
 94277:                         lval = PopStr(ss, JSOP_POP);
 94277: 
 94277:                         /* Make sure comma-expression on rhs gets parens. */
 94277:                         JS_ASSERT(js_CodeSpec[JSOP_SETNAME].prec > js_CodeSpec[JSOP_POP].prec);
 94277:                         rval = PopStr(ss, JSOP_SETNAME);
     1: 
     1:                         if (strcmp(rval, forelem_cookie) == 0) {
 20943:                             todo = Sprint(&ss->sprinter, ss_format,
 20943:                                           VarPrefix(sn), lval);
 20943: 
 86078:                             /* Skip POP so the SRC_FOR_IN code can pop for itself. */
 20943:                             if (*pc == JSOP_POP)
 20943:                                 len = JSOP_POP_LENGTH;
 20943:                         } else {
     1:                             todo = Sprint(&ss->sprinter, "%s%s = %s",
     1:                                           VarPrefix(sn), lval, rval);
 20943:                         }
 86078: 
 86078:                         op = saveop = JSOP_ENUMELEM;
 86078:                         len = 0;
 86078:                     } else {
 86078:                         LOCAL_ASSERT(SN_TYPE(sn) == SRC_DESTRUCTLET);
 86078: 
 86078:                         ptrdiff_t offsetToLet = js_GetSrcNoteOffset(sn, 0);
 86078:                         LOCAL_ASSERT(*(pc + offsetToLet) == JSOP_ENTERLET0);
 86078: 
 89253:                         obj = jp->script->getObject(GET_UINT32_INDEX(pc + offsetToLet));
 86483:                         StaticBlockObject &blockObj = obj->asStaticBlock();
 86483: 
 86483:                         uint32_t blockDepth = blockObj.stackDepth();
 86078:                         LOCAL_ASSERT(blockDepth < ss->top);
 86483:                         LOCAL_ASSERT(ss->top <= blockDepth + blockObj.slotCount());
 86078: 
 86078:                         AtomVector atoms(cx);
 86483:                         if (!GetBlockNames(cx, blockObj, &atoms))
 86078:                             return NULL;
 86078: 
 86078:                         /*
 86078:                          * Skip any initializers preceding this one. E.g., in
 86078:                          *   let (w=1, x=2, [y,z] = a) { ... }
 86078:                          * skip 'w' and 'x' for the JSOP_DUP of '[y,z] = a'.
 86078:                          */
 86078:                         AtomRange letNames = atoms.all();
 86078:                         uint32_t curDepth = ss->top - 1 /* initializer */;
 86078:                         for (uint32_t i = blockDepth; i < curDepth; ++i)
 86078:                             letNames.popFront();
 86078: 
 86078:                         /*
 86078:                          * Pop and copy the rhs before it gets clobbered.
 86078:                          * Use JSOP_SETLOCAL's precedence since this is =.
 86078:                          */
 86078:                         DupBuffer rhs(cx);
 86078:                         if (!Dup(PopStr(ss, JSOP_SETLOCAL), &rhs))
 86078:                             return NULL;
 86078: 
 86078:                         /* Destructure, tracking how many vars were bound. */
 86078:                         size_t remainBefore = letNames.remain();
 86078:                         pc = DecompileDestructuring(ss, pc, endpc, &letNames);
 86078:                         if (!pc)
 86078:                             return NULL;
 86078:                         size_t remainAfter = letNames.remain();
 86078: 
 86078:                         /*
 86078:                          * Merge the lhs and rhs and prefix with a cookie to
 86078:                          * tell enterlet0 not to prepend "name = ".
 86078:                          */
 86078:                         const char *lhs = PopStr(ss, JSOP_NOP);
 86078:                         ptrdiff_t off = Sprint(&ss->sprinter, "%s%s = %s",
 86078:                                                DestructuredString, lhs, rhs.begin());
 86078:                         if (off < 0 || !PushOff(ss, off, JSOP_NOP))
 86078:                             return NULL;
 86078: 
 86078:                         /*
 86078:                          * Only one slot has been pushed (holding the entire
 86078:                          * decompiled destructuring expression). However, the
 86078:                          * abstract depth needs one slot per bound var, so push
 86078:                          * empty strings for the remainder. We don't have to
 86078:                          * worry about empty destructuring because the parser
 86078:                          * ensures that there is always at least one pushed
 86078:                          * slot for each destructuring lhs.
 86078:                          */
 86078:                         LOCAL_ASSERT(remainBefore >= remainAfter);
 86078:                         LOCAL_ASSERT(remainBefore > remainAfter || remainAfter > 0);
 86078:                         for (size_t i = remainBefore - 1; i > remainAfter; --i) {
 86078:                             if (!PushStr(ss, SkipString, JSOP_NOP))
 86078:                                 return NULL;
 86078:                         }
 86078: 
 86078:                         LOCAL_ASSERT(*pc == JSOP_POP);
 86078:                         pc += JSOP_POP_LENGTH;
 86078: 
 86078:                         /* Eat up the JSOP_UNDEFINED following empty destructuring. */
 86078:                         if (remainBefore == remainAfter) {
 86078:                             LOCAL_ASSERT(*pc == JSOP_UNDEFINED);
 86078:                             pc += JSOP_UNDEFINED_LENGTH;
 86078:                         }
 86078: 
 86078:                         len = 0;
 86078:                         todo = -2;
 86078:                     }
     1:                     break;
     1:                 }
     1: #endif
     1: 
     1:                 rval = GetStr(ss, ss->top-1);
  3164:                 saveop = (JSOp) ss->opcodes[ss->top-1];
 90229:                 todo = ss->sprinter.put(rval);
     1:                 break;
     1: 
 86855:               case JSOP_SWAP:
 86855:                 Swap(ss->offsets[ss->top-1], ss->offsets[ss->top-2]);
 86855:                 Swap(ss->opcodes[ss->top-1], ss->opcodes[ss->top-2]);
 86855:                 Swap(ss->bytecodes[ss->top-1], ss->bytecodes[ss->top-2]);
 86855:                 todo = -2;
 86855:                 break;
 86855: 
     1:               case JSOP_SETARG:
 16429:                 atom = GetArgOrVarAtom(jp, GET_ARGNO(pc));
     1:                 LOCAL_ASSERT(atom);
     1:                 goto do_setname;
     1: 
     1:               case JSOP_SETCONST:
     1:               case JSOP_SETNAME:
 52825:               case JSOP_SETGNAME:
     1:                 LOAD_ATOM(0);
     1: 
     1:               do_setname:
 64345:                 lval = QuoteString(&ss->sprinter, atom, 0);
     1:                 if (!lval)
     1:                     return NULL;
 84803:                 rval = PopStrDupe(ss, op, &rvalpc);
 52825:                 if (op == JSOP_SETNAME || op == JSOP_SETGNAME)
     1:                     (void) PopOff(ss, op);
     1: 
     1:               do_setlval:
     1:                 sn = js_GetSrcNote(jp->script, pc - 1);
 87952:                 todo = ss->sprinter.getOffset();
     1:                 if (sn && SN_TYPE(sn) == SRC_ASSIGNOP) {
 84803:                     const char *token =
 84803:                         GetTokenForAssignment(jp, sn, lastop, pc, rvalpc,
 84803:                                               &lastlvalpc, &lastrvalpc);
 84803:                     Sprint(&ss->sprinter, "%s %s= ", lval, token);
 84803:                     SprintOpcode(ss, rval, rvalpc, pc, todo);
     1:                 } else {
     1:                     sn = js_GetSrcNote(jp->script, pc);
 84803:                     const char *prefix = VarPrefix(sn);
 84803:                     Sprint(&ss->sprinter, "%s%s = ", prefix, lval);
 84803:                     SprintOpcode(ss, rval, rvalpc, pc, todo);
     1:                 }
     1:                 break;
     1: 
     1:               case JSOP_NEW:
     1:               case JSOP_CALL:
     1:               case JSOP_EVAL:
 57712:               case JSOP_FUNCALL:
 57712:               case JSOP_FUNAPPLY:
 84803:               {
     1:                 argc = GET_ARGC(pc);
 84803:                 const char **argv = (const char **)
 64560:                     cx->malloc_((size_t)(argc + 1) * sizeof *argv);
     1:                 if (!argv)
     1:                     return NULL;
 84803:                 jsbytecode **argbytecodes = (jsbytecode **)
 84803:                     cx->malloc_((size_t)(argc + 1) * sizeof *argbytecodes);
 84803:                 if (!argbytecodes) {
 84803:                     cx->free_(argv);
 84803:                     return NULL;
 84803:                 }
     1: 
 23708:                 op = JSOP_SETNAME;
 23708:                 for (i = argc; i > 0; i--)
 84803:                     argv[i] = PopStrDupe(ss, op, &argbytecodes[i]);
     1: 
     1:                 /* Skip the JSOP_PUSHOBJ-created empty string. */
     1:                 LOCAL_ASSERT(ss->top >= 2);
     1:                 (void) PopOff(ss, op);
     1: 
   350:                 /*
   350:                  * Special case: new (x(y)(z)) must be parenthesized like so.
   350:                  * Same for new (x(y).z) -- contrast with new x(y).z.
 20928:                  * See PROPAGATE_CALLNESS.
   350:                  */
  3164:                 op = (JSOp) ss->opcodes[ss->top - 1];
 84803:                 argv[0] = PopStrDupe(ss,
   350:                                      (saveop == JSOP_NEW &&
 21452:                                       (op == JSOP_CALL ||
 21452:                                        op == JSOP_EVAL ||
 57712:                                        op == JSOP_FUNCALL ||
 57712:                                        op == JSOP_FUNAPPLY ||
 86855:                                        op == JSOP_CALLPROP ||
 86855:                                        op == JSOP_CALLELEM))
   350:                                      ? JSOP_NAME
 84803:                                      : saveop,
 84803:                                      &lvalpc);
     1:                 op = saveop;
   350: 
     1:                 lval = "(", rval = ")";
 87952:                 todo = ss->sprinter.getOffset();
     1:                 if (op == JSOP_NEW) {
     1:                     if (argc == 0)
     1:                         lval = rval = "";
 84803:                     Sprint(&ss->sprinter, "%s ", js_new_str);
 84803:                 }
 84803:                 SprintOpcode(ss, argv[0], lvalpc, pc, todo);
 90229:                 ss->sprinter.put(lval);
     1: 
     1:                 for (i = 1; i <= argc; i++) {
 84803:                     SprintOpcode(ss, argv[i], argbytecodes[i], pc, todo);
 84803:                     if (i < argc)
 90229:                         ss->sprinter.put(", ");
 90229:                 }
 90229:                 ss->sprinter.put(rval);
 84803: 
 64560:                 cx->free_(argv);
 84803:                 cx->free_(argbytecodes);
 84803: 
 84803:                 break;
 84803:               }
 57742: 
 57742:               case JSOP_SETCALL:
     1:                 todo = Sprint(&ss->sprinter, "");
     1:                 break;
     1: 
     1:               case JSOP_DELNAME:
     1:                 LOAD_ATOM(0);
 64345:                 lval = QuoteString(&ss->sprinter, atom, 0);
     1:                 if (!lval)
     1:                     return NULL;
 87952:                 ss->sprinter.setOffset(lval);
     1:               do_delete_lval:
     1:                 todo = Sprint(&ss->sprinter, "%s %s", js_delete_str, lval);
     1:                 break;
     1: 
     1:               case JSOP_DELPROP:
     1:                 GET_ATOM_QUOTE_AND_FMT("%s %s[%s]", "%s %s.%s", rval);
 20928:                 op = JSOP_GETPROP;
     1:                 lval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, fmt, js_delete_str, lval, rval);
     1:                 break;
     1: 
     1:               case JSOP_DELELEM:
     1:                 op = JSOP_NOP;          /* turn off parens */
     1:                 xval = POP_STR();
 20928:                 op = JSOP_GETPROP;
     1:                 lval = POP_STR();
     1:                 if (*xval == '\0')
     1:                     goto do_delete_lval;
     1:                 todo = Sprint(&ss->sprinter,
  1761:                               (JOF_OPMODE(lastop) == JOF_XMLNAME)
     1:                               ? "%s %s.%s"
     1:                               : "%s %s[%s]",
     1:                               js_delete_str, lval, xval);
     1:                 break;
     1: 
     1: #if JS_HAS_XML_SUPPORT
     1:               case JSOP_DELDESC:
     1:                 xval = POP_STR();
 20928:                 op = JSOP_GETPROP;
     1:                 lval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, "%s %s..%s",
     1:                               js_delete_str, lval, xval);
     1:                 break;
     1: #endif
     1: 
     1:               case JSOP_TYPEOFEXPR:
     1:               case JSOP_TYPEOF:
     1:               case JSOP_VOID:
 84803:               {
 84803:                 const char *prefix = (op == JSOP_VOID) ? js_void_str : js_typeof_str;
 84803:                 rval = PopStrDupe(ss, op, &rvalpc);
 87952:                 todo = ss->sprinter.getOffset();
 84803:                 Sprint(&ss->sprinter, "%s ", prefix);
 84803:                 SprintOpcode(ss, rval, rvalpc, pc, todo);
 84803:                 break;
 84803:               }
     1: 
     1:               case JSOP_INCARG:
     1:               case JSOP_DECARG:
 16429:                 atom = GetArgOrVarAtom(jp, GET_ARGNO(pc));
     1:                 LOCAL_ASSERT(atom);
     1:                 goto do_incatom;
     1: 
     1:               case JSOP_INCNAME:
     1:               case JSOP_DECNAME:
 52825:               case JSOP_INCGNAME:
 52825:               case JSOP_DECGNAME:
     1:                 LOAD_ATOM(0);
     1:               do_incatom:
 64345:                 lval = QuoteString(&ss->sprinter, atom, 0);
     1:                 if (!lval)
     1:                     return NULL;
 87952:                 ss->sprinter.setOffset(lval);
     1:               do_inclval:
     1:                 todo = Sprint(&ss->sprinter, ss_format,
     1:                               js_incop_strs[!(cs->format & JOF_INC)], lval);
 77380:                 if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
 77380:                     len += GetDecomposeLength(pc, js_CodeSpec[*pc].length);
     1:                 break;
     1: 
     1:               case JSOP_INCPROP:
     1:               case JSOP_DECPROP:
     1:                 GET_ATOM_QUOTE_AND_FMT(preindex_format, predot_format, rval);
     1: 
     1:                 /*
     1:                  * Force precedence below the numeric literal opcodes, so that
     1:                  * 42..foo or 10000..toString(16), e.g., decompile with parens
     1:                  * around the left-hand side of dot.
     1:                  */
     1:                 op = JSOP_GETPROP;
     1:                 lval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, fmt,
     1:                               js_incop_strs[!(cs->format & JOF_INC)],
     1:                               lval, rval);
 77380:                 len += GetDecomposeLength(pc, JSOP_INCPROP_LENGTH);
     1:                 break;
     1: 
     1:               case JSOP_INCELEM:
     1:               case JSOP_DECELEM:
     1:                 op = JSOP_NOP;          /* turn off parens */
     1:                 xval = POP_STR();
     1:                 op = JSOP_GETELEM;
     1:                 lval = POP_STR();
     1:                 if (*xval != '\0') {
     1:                     todo = Sprint(&ss->sprinter,
  1761:                                   (JOF_OPMODE(lastop) == JOF_XMLNAME)
     1:                                   ? predot_format
     1:                                   : preindex_format,
     1:                                   js_incop_strs[!(cs->format & JOF_INC)],
     1:                                   lval, xval);
     1:                 } else {
     1:                     todo = Sprint(&ss->sprinter, ss_format,
     1:                                   js_incop_strs[!(cs->format & JOF_INC)], lval);
     1:                 }
 77380:                 len += GetDecomposeLength(pc, JSOP_INCELEM_LENGTH);
     1:                 break;
     1: 
     1:               case JSOP_ARGINC:
     1:               case JSOP_ARGDEC:
 16429:                 atom = GetArgOrVarAtom(jp, GET_ARGNO(pc));
     1:                 LOCAL_ASSERT(atom);
     1:                 goto do_atominc;
     1: 
     1:               case JSOP_NAMEINC:
     1:               case JSOP_NAMEDEC:
 52825:               case JSOP_GNAMEINC:
 52825:               case JSOP_GNAMEDEC:
     1:                 LOAD_ATOM(0);
     1:               do_atominc:
 64345:                 lval = QuoteString(&ss->sprinter, atom, 0);
     1:                 if (!lval)
     1:                     return NULL;
 87952:                 ss->sprinter.setOffset(lval);
     1:               do_lvalinc:
     1:                 todo = Sprint(&ss->sprinter, ss_format,
     1:                               lval, js_incop_strs[!(cs->format & JOF_INC)]);
 77380:                 if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
 77380:                     len += GetDecomposeLength(pc, js_CodeSpec[*pc].length);
     1:                 break;
     1: 
     1:               case JSOP_PROPINC:
     1:               case JSOP_PROPDEC:
     1:                 GET_ATOM_QUOTE_AND_FMT(postindex_format, postdot_format, rval);
     1: 
     1:                 /*
     1:                  * Force precedence below the numeric literal opcodes, so that
     1:                  * 42..foo or 10000..toString(16), e.g., decompile with parens
     1:                  * around the left-hand side of dot.
     1:                  */
     1:                 op = JSOP_GETPROP;
     1:                 lval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, fmt, lval, rval,
     1:                               js_incop_strs[!(cs->format & JOF_INC)]);
 77380:                 len += GetDecomposeLength(pc, JSOP_PROPINC_LENGTH);
     1:                 break;
     1: 
     1:               case JSOP_ELEMINC:
     1:               case JSOP_ELEMDEC:
     1:                 op = JSOP_NOP;          /* turn off parens */
     1:                 xval = POP_STR();
     1:                 op = JSOP_GETELEM;
     1:                 lval = POP_STR();
     1:                 if (*xval != '\0') {
     1:                     todo = Sprint(&ss->sprinter,
  1761:                                   (JOF_OPMODE(lastop) == JOF_XMLNAME)
     1:                                   ? postdot_format
     1:                                   : postindex_format,
     1:                                   lval, xval,
     1:                                   js_incop_strs[!(cs->format & JOF_INC)]);
     1:                 } else {
     1:                     todo = Sprint(&ss->sprinter, ss_format,
     1:                                   lval, js_incop_strs[!(cs->format & JOF_INC)]);
     1:                 }
 77380:                 len += GetDecomposeLength(pc, JSOP_ELEMINC_LENGTH);
     1:                 break;
     1: 
     1:               case JSOP_GETPROP2:
     1:                 op = JSOP_GETPROP;
     1:                 (void) PopOff(ss, lastop);
     1:                 /* FALL THROUGH */
     1: 
     1:               case JSOP_CALLPROP:
     1:               case JSOP_GETPROP:
     1:               case JSOP_GETXPROP:
 77343:               case JSOP_LENGTH:
     1:                 LOAD_ATOM(0);
     1: 
 84803:                 GET_QUOTE_AND_FMT("[%s]", ".%s", rval);
 20928:                 PROPAGATE_CALLNESS();
 84803:                 lval = PopStr(ss, op, &lvalpc);
 87952:                 todo = ss->sprinter.getOffset();
 84803:                 SprintOpcode(ss, lval, lvalpc, pc, todo);
 84803:                 Sprint(&ss->sprinter, fmt, rval);
     1:                 break;
     1: 
     1:               case JSOP_SETPROP:
 84803:               {
     1:                 LOAD_ATOM(0);
 84803:                 GET_QUOTE_AND_FMT("[%s] %s= ", ".%s %s= ", xval);
 84803:                 rval = PopStrDupe(ss, op, &rvalpc);
     1: 
     1:                 /*
     1:                  * Force precedence below the numeric literal opcodes, so that
     1:                  * 42..foo or 10000..toString(16), e.g., decompile with parens
     1:                  * around the left-hand side of dot.
     1:                  */
     1:                 op = JSOP_GETPROP;
 84803:                 lval = PopStr(ss, op, &lvalpc);
     1:                 sn = js_GetSrcNote(jp->script, pc - 1);
 84803:                 const char *token =
 84803:                     GetTokenForAssignment(jp, sn, lastop, pc, rvalpc,
 84803:                                           &lastlvalpc, &lastrvalpc);
 87952:                 todo = ss->sprinter.getOffset();
 84803:                 SprintOpcode(ss, lval, lvalpc, pc, todo);
 84803:                 Sprint(&ss->sprinter, fmt, xval, token);
 84803:                 SprintOpcode(ss, rval, rvalpc, pc, todo);
 84803:                 break;
 84803:               }
     1: 
     1:               case JSOP_GETELEM2:
     1:                 (void) PopOff(ss, lastop);
     1:                 /* FALL THROUGH */
     1:               case JSOP_CALLELEM:
     1:               case JSOP_GETELEM:
     1:                 op = JSOP_NOP;          /* turn off parens */
 84803:                 xval = PopStrDupe(ss, op, &xvalpc);
     1:                 op = saveop;
 20928:                 PROPAGATE_CALLNESS();
 84803:                 lval = PopStr(ss, op, &lvalpc);
 87952:                 todo = ss->sprinter.getOffset();
 84803:                 SprintOpcode(ss, lval, lvalpc, pc, todo);
 84803:                 if (*xval != '\0') {
 84803:                     bool xml = (JOF_OPMODE(lastop) == JOF_XMLNAME);
 90229:                     ss->sprinter.put(xml ? "." : "[");
 84803:                     SprintOpcode(ss, xval, xvalpc, pc, todo);
 90229:                     ss->sprinter.put(xml ? "" : "]");
     1:                 }
     1:                 break;
     1: 
     1:               case JSOP_SETELEM:
 84803:               {
 84803:                 rval = PopStrDupe(ss, op, &rvalpc);
     1:                 op = JSOP_NOP;          /* turn off parens */
 84803:                 xval = PopStrDupe(ss, op, &xvalpc);
     1:                 cs = &js_CodeSpec[ss->opcodes[ss->top]];
     1:                 op = JSOP_GETELEM;      /* lval must have high precedence */
 84803:                 lval = PopStr(ss, op, &lvalpc);
     1:                 op = saveop;
     1:                 if (*xval == '\0')
     1:                     goto do_setlval;
     1:                 sn = js_GetSrcNote(jp->script, pc - 1);
 84803:                 bool xml = (JOF_MODE(cs->format) == JOF_XMLNAME);
 84803:                 const char *token =
 84803:                     GetTokenForAssignment(jp, sn, lastop, pc, rvalpc,
 84803:                                           &lastlvalpc, &lastrvalpc);
 87952:                 todo = ss->sprinter.getOffset();
 84803:                 SprintOpcode(ss, lval, lvalpc, pc, todo);
 90229:                 ss->sprinter.put(xml ? "." : "[");
 84803:                 SprintOpcode(ss, xval, xvalpc, pc, todo);
 90229:                 ss->sprinter.put(xml ? "" : "]");
 84803:                 Sprint(&ss->sprinter, " %s= ", token);
 84803:                 SprintOpcode(ss, rval, rvalpc, pc, todo);
 84803:                 break;
 84803:               }
     1: 
     1:               case JSOP_CALLARG:
     1:               case JSOP_GETARG:
     1:                 i = GET_ARGNO(pc);
 16429:                 atom = GetArgOrVarAtom(jp, i);
     1: #if JS_HAS_DESTRUCTURING
     1:                 if (!atom) {
     1:                     todo = Sprint(&ss->sprinter, "%s[%d]", js_arguments_str, i);
     1:                     break;
     1:                 }
     1: #else
     1:                 LOCAL_ASSERT(atom);
     1: #endif
     1:                 goto do_name;
     1: 
     1:               case JSOP_CALLNAME:
     1:               case JSOP_NAME:
 52825:               case JSOP_GETGNAME:
 52825:               case JSOP_CALLGNAME:
     1:                 LOAD_ATOM(0);
     1:               do_name:
     1:                 lval = "";
  8656: #if JS_HAS_XML_SUPPORT
     1:               do_qname:
  8656: #endif
     1:                 sn = js_GetSrcNote(jp->script, pc);
 64345:                 rval = QuoteString(&ss->sprinter, atom, inXML ? DONT_ESCAPE : 0);
     1:                 if (!rval)
     1:                     return NULL;
 87952:                 ss->sprinter.setOffset(rval);
 20943:                 todo = Sprint(&ss->sprinter, sss_format,
     1:                               VarPrefix(sn), lval, rval);
     1:                 break;
     1: 
     1:               case JSOP_UINT16:
 91450:                 i = (int) GET_UINT16(pc);
     1:                 goto do_sprint_int;
     1: 
     1:               case JSOP_UINT24:
 91450:                 i = (int) GET_UINT24(pc);
  3328:                 goto do_sprint_int;
  3328: 
  3328:               case JSOP_INT8:
  3328:                 i = GET_INT8(pc);
  3328:                 goto do_sprint_int;
  3328: 
  3328:               case JSOP_INT32:
  3328:                 i = GET_INT32(pc);
     1:               do_sprint_int:
  3328:                 todo = Sprint(&ss->sprinter, "%d", i);
     1:                 break;
     1: 
  8285:               case JSOP_DOUBLE:
 48470:               {
 90965:                 val = jp->script->getConst(GET_UINT32_INDEX(pc));
  3328:                 todo = SprintDoubleValue(&ss->sprinter, val, &saveop);
  8285:                 break;
 48470:               }
  8285: 
  8285:               case JSOP_STRING:
  8285:                 LOAD_ATOM(0);
 64345:                 rval = QuoteString(&ss->sprinter, atom, inXML ? DONT_ESCAPE : '"');
     1:                 if (!rval)
     1:                     return NULL;
 87952:                 todo = ss->sprinter.getOffsetOf(rval);
  8285:                 break;
     1: 
 27012:               case JSOP_LAMBDA:
  1760: #if JS_HAS_GENERATOR_EXPRS
  1577:                 sn = js_GetSrcNote(jp->script, pc);
  1577:                 if (sn && SN_TYPE(sn) == SRC_GENEXP) {
 97297:                     BindingNames *innerLocalNames;
 97297:                     BindingNames *outerLocalNames;
 26970:                     JSScript *inner, *outer;
 84803:                     Vector<DecompiledOpcode> *decompiledOpcodes;
 87952:                     SprintStack ss2(cx);
 27012:                     JSFunction *outerfun;
  1577: 
 89253:                     fun = jp->script->getFunction(GET_UINT32_INDEX(pc));
  1577: 
  1577:                     /*
 80743:                      * All allocation when decompiling is LIFO, using malloc or,
 80743:                      * more commonly, arena-allocating from cx->tempLifoAlloc
 80743:                      * Therefore after InitSprintStack succeeds, we must release
 80743:                      * to mark before returning.
  1577:                      */
 79410:                     LifoAllocScope las(&cx->tempLifoAlloc());
 95100:                     if (fun->script()->bindings.count() > 0) {
 97297:                         innerLocalNames = cx->new_<BindingNames>(cx);
 73058:                         if (!innerLocalNames ||
 86076:                             !fun->script()->bindings.getLocalNameArray(cx, innerLocalNames))
 73058:                         {
  1577:                             return NULL;
 73058:                         }
 59968:                     } else {
 59968:                         innerLocalNames = NULL;
 59968:                     }
 59968:                     inner = fun->script();
 79410:                     if (!InitSprintStack(cx, &ss2, jp, StackDepth(inner)))
 27012:                         return NULL;
  1577:                     ss2.inGenExp = JS_TRUE;
  1577: 
  1577:                     /*
  1577:                      * Recursively decompile this generator function as an
  1577:                      * un-parenthesized generator expression. The ss->inGenExp
  1577:                      * special case of JSOP_YIELD shares array comprehension
  1577:                      * decompilation code that leaves the result as the single
  1577:                      * string pushed on ss2.
  1577:                      */
  1577:                     outer = jp->script;
 27012:                     outerfun = jp->fun;
 27012:                     outerLocalNames = jp->localNames;
 84803:                     decompiledOpcodes = jp->decompiledOpcodes;
 80202:                     LOCAL_ASSERT(UnsignedPtrDiff(pc, outer->code) <= outer->length);
  1577:                     jp->script = inner;
 27012:                     jp->fun = fun;
 27012:                     jp->localNames = innerLocalNames;
 84803:                     jp->decompiledOpcodes = NULL;
 59989: 
 59989:                     /*
 59989:                      * Decompile only the main bytecode, to avoid tripping over
 59989:                      * new prolog ops that have stack effects.
 59989:                      */
 81589:                     ok = Decompile(&ss2, inner->main(), inner->length - inner->mainOffset)
 59989:                          != NULL;
 27012:                     jp->script = outer;
 27012:                     jp->fun = outerfun;
 27012:                     jp->localNames = outerLocalNames;
 84803:                     jp->decompiledOpcodes = decompiledOpcodes;
 79410:                     if (!ok)
  1577:                         return NULL;
  1577: 
  1577:                     /*
  4127:                      * Advance over this op and its global |this| push, and
  1577:                      * arrange to advance over the call to this lambda.
  1577:                      */
  1577:                     pc += len;
 84493:                     LOCAL_ASSERT(*pc == JSOP_UNDEFINED);
 84493:                     pc += JSOP_UNDEFINED_LENGTH;
  1577:                     LOCAL_ASSERT(*pc == JSOP_CALL);
  1577:                     LOCAL_ASSERT(GET_ARGC(pc) == 0);
  1577:                     len = JSOP_CALL_LENGTH;
  1577: 
  1577:                     /*
  1577:                      * Arrange to parenthesize this genexp unless:
  1577:                      *
  1760:                      *  1. It is the complete expression consumed by a control
  1760:                      *     flow bytecode such as JSOP_TABLESWITCH whose syntax
  1760:                      *     always parenthesizes the controlling expression.
 25516:                      *  2. It is the sole argument to a function call.
  1577:                      *
 25516:                      * But if this genexp runs up against endpc, parenthesize
 25516:                      * regardless.  (This can happen if we are called from
 25516:                      * DecompileExpression or recursively from case
 25516:                      * JSOP_{NOP,AND,OR}.)
 25516:                      *
 25516:                      * There's no special case for |if (genexp)| because the
 25516:                      * compiler optimizes that to |if (true)|.
  1577:                      */
 15556:                     pc2 = pc + len;
 33586:                     op = JSOp(*pc2);
 83115:                     if (op == JSOP_LOOPHEAD || op == JSOP_NOP)
 33586:                         pc2 += JSOP_NOP_LENGTH;
 15556:                     LOCAL_ASSERT(pc2 < endpc ||
  1760:                                  endpc < outer->code + outer->length);
  1577:                     LOCAL_ASSERT(ss2.top == 1);
  1577:                     ss2.opcodes[0] = JSOP_POP;
 25516:                     if (pc2 == endpc) {
  1760:                         op = JSOP_SETNAME;
  1760:                     } else {
 15556:                         op = (JSOp) *pc2;
  1760:                         op = ((js_CodeSpec[op].format & JOF_PARENHEAD) ||
 25516:                               ((js_CodeSpec[op].format & JOF_INVOKE) && GET_ARGC(pc2) == 1))
  1577:                              ? JSOP_POP
  1577:                              : JSOP_SETNAME;
  1967: 
  1967:                         /*
 11808:                          * Stack this result as if it's a name and not an
 11808:                          * anonymous function, so it doesn't get decompiled as
 11808:                          * a generator function in a getter or setter context.
 11808:                          * The precedence level is the same for JSOP_NAME and
 27012:                          * JSOP_LAMBDA.
  1967:                          */
  1967:                         LOCAL_ASSERT(js_CodeSpec[JSOP_NAME].prec ==
  1967:                                      js_CodeSpec[saveop].prec);
  1967:                         saveop = JSOP_NAME;
  1760:                     }
  1577: 
  1577:                     /*
 80743:                      * Alas, we have to malloc a copy of the result left on the
 80743:                      * top of ss2 because both ss and ss2 arena-allocate from
 80743:                      * cx's tempLifoAlloc
  1577:                      */
  1577:                     rval = JS_strdup(cx, PopStr(&ss2, op));
 79410:                     las.releaseEarly();
  1577:                     if (!rval)
  1577:                         return NULL;
 90229:                     todo = ss->sprinter.put(rval);
 64560:                     cx->free_((void *)rval);
  1577:                     break;
  1577:                 }
  3235: #endif /* JS_HAS_GENERATOR_EXPRS */
 94152:                 else if (sn && SN_TYPE(sn) == SRC_CONTINUE) {
 94152:                     /*
 94152:                      * Local function definitions have a lambda;setlocal;pop
 94152:                      * triple (annotated with SRC_CONTINUE) in the function
 94152:                      * prologue and a nop (annotated with SRC_FUNCDEF) at the
 94152:                      * actual position where the function definition should
 94152:                      * syntactically appear.
 94152:                      */
 95101:                     jsbytecode *nextpc = pc + JSOP_LAMBDA_LENGTH;
 95101:                     LOCAL_ASSERT(*nextpc == JSOP_SETLOCAL || *nextpc == JSOP_SETALIASEDVAR);
 95101:                     nextpc += js_CodeSpec[*nextpc].length;
 95101:                     LOCAL_ASSERT(*nextpc == JSOP_POP);
 95101:                     nextpc += JSOP_POP_LENGTH;
 95101:                     len = nextpc - pc;
 94152:                     todo = -2;
 94152:                     break;
 94152:                 }
 94152: 
 94152:                 /* Otherwise, this is a lambda expression. */
 89253:                 fun = jp->script->getFunction(GET_UINT32_INDEX(pc));
  3235:                 {
  1967:                     /*
  1967:                      * Always parenthesize expression closures. We can't force
  1967:                      * saveop to a low-precedence op to arrange for auto-magic
  1967:                      * parenthesization without confusing getter/setter code
 27012:                      * that checks for JSOP_LAMBDA.
  1967:                      */
 35040:                     bool grouped = !(fun->flags & JSFUN_EXPR_CLOSURE);
 35113:                     bool strict = jp->script->strictModeCode;
 35040:                     str = js_DecompileToString(cx, "lambda", fun, 0,
 35113:                                                false, grouped, strict,
 35040:                                                js_DecompileFunction);
  4127:                     if (!str)
     1:                         return NULL;
     1:                 }
  4127:               sprint_string:
 90229:                 todo = ss->sprinter.putString(str);
     1:                 break;
     1: 
 27012:               case JSOP_CALLEE:
 27012:                 JS_ASSERT(jp->fun && jp->fun->atom);
 90229:                 todo = ss->sprinter.putString(jp->fun->atom);
 27012:                 break;
 27012: 
  3235:               case JSOP_OBJECT:
 89253:                 obj = jp->script->getObject(GET_UINT32_INDEX(pc));
 59962:                 str = js_ValueToSource(cx, ObjectValue(*obj));
 59962:                 if (!str)
 59962:                     return NULL;
 59962:                 goto sprint_string;
  3235: 
  3235:               case JSOP_REGEXP:
 87976:                 obj = jp->script->getRegExp(GET_UINT32_INDEX(pc));
 86483:                 str = obj->asRegExp().toString(cx);
 79981:                 if (!str)
  3235:                     return NULL;
  4127:                 goto sprint_string;
  3235: 
     1:               case JSOP_TABLESWITCH:
     1:               {
 86877:                 ptrdiff_t off, off2;
 91450:                 int32_t j, n, low, high;
     1:                 TableEntry *table, *tmp;
     1: 
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
     1:                 len = js_GetSrcNoteOffset(sn, 0);
 86877:                 off = GET_JUMP_OFFSET(pc);
 86877:                 pc2 = pc + JUMP_OFFSET_LEN;
     1:                 low = GET_JUMP_OFFSET(pc2);
     1:                 pc2 += JUMP_OFFSET_LEN;
     1:                 high = GET_JUMP_OFFSET(pc2);
     1:                 pc2 += JUMP_OFFSET_LEN;
     1: 
     1:                 n = high - low + 1;
     1:                 if (n == 0) {
     1:                     table = NULL;
     1:                     j = 0;
 82461:                     ok = true;
     1:                 } else {
     1:                     table = (TableEntry *)
 64560:                             cx->malloc_((size_t)n * sizeof *table);
     1:                     if (!table)
     1:                         return NULL;
     1:                     for (i = j = 0; i < n; i++) {
     1:                         table[j].label = NULL;
 86877:                         off2 = GET_JUMP_OFFSET(pc2);
     1:                         if (off2) {
     1:                             sn = js_GetSrcNote(jp->script, pc2);
     1:                             if (sn) {
     1:                                 LOCAL_ASSERT(SN_TYPE(sn) == SRC_LABEL);
  4342:                                 GET_SOURCE_NOTE_ATOM(sn, table[j].label);
     1:                             }
     1:                             table[j].key = INT_TO_JSVAL(low + i);
     1:                             table[j].offset = off2;
     1:                             table[j].order = j;
     1:                             j++;
     1:                         }
 86877:                         pc2 += JUMP_OFFSET_LEN;
     1:                     }
     1:                     tmp = (TableEntry *)
 64560:                           cx->malloc_((size_t)j * sizeof *table);
     1:                     if (tmp) {
 82461:                         MergeSort(table, size_t(j), tmp, CompareTableEntries);
 82461:                         Foreground::free_(tmp);
 82461:                         ok = true;
     1:                     } else {
 82461:                         ok = false;
 82461:                     }
 82461:                 }
 82461: 
 82461:                 if (ok)
 91237:                     ok = DecompileSwitch(ss, table, (unsigned)j, pc, len, off, false);
 64560:                 cx->free_(table);
     1:                 if (!ok)
     1:                     return NULL;
     1:                 todo = -2;
     1:                 break;
     1:               }
     1: 
     1:               case JSOP_LOOKUPSWITCH:
     1:               {
 86877:                 ptrdiff_t off, off2;
     1:                 jsatomid npairs, k;
     1:                 TableEntry *table;
     1: 
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
     1:                 len = js_GetSrcNoteOffset(sn, 0);
 86877:                 off = GET_JUMP_OFFSET(pc);
 86877:                 pc2 = pc + JUMP_OFFSET_LEN;
     1:                 npairs = GET_UINT16(pc2);
     1:                 pc2 += UINT16_LEN;
     1: 
     1:                 table = (TableEntry *)
 64560:                     cx->malloc_((size_t)npairs * sizeof *table);
     1:                 if (!table)
     1:                     return NULL;
     1:                 for (k = 0; k < npairs; k++) {
     1:                     sn = js_GetSrcNote(jp->script, pc2);
     1:                     if (sn) {
     1:                         LOCAL_ASSERT(SN_TYPE(sn) == SRC_LABEL);
  4342:                         GET_SOURCE_NOTE_ATOM(sn, table[k].label);
     1:                     } else {
     1:                         table[k].label = NULL;
     1:                     }
 90965:                     uint32_t constIndex = GET_UINT32_INDEX(pc2);
 90965:                     pc2 += UINT32_INDEX_LEN;
 86877:                     off2 = GET_JUMP_OFFSET(pc2);
 86877:                     pc2 += JUMP_OFFSET_LEN;
 78614:                     table[k].key = jp->script->getConst(constIndex);
     1:                     table[k].offset = off2;
     1:                 }
     1: 
 91237:                 ok = DecompileSwitch(ss, table, (unsigned)npairs, pc, len, off,
     1:                                      JS_FALSE);
 64560:                 cx->free_(table);
     1:                 if (!ok)
     1:                     return NULL;
     1:                 todo = -2;
     1:                 break;
     1:               }
     1: 
     1:               case JSOP_CONDSWITCH:
     1:               {
     1:                 ptrdiff_t off, off2, caseOff;
 91450:                 int ncases;
     1:                 TableEntry *table;
     1: 
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1:                 LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_SWITCH);
     1:                 len = js_GetSrcNoteOffset(sn, 0);
     1:                 off = js_GetSrcNoteOffset(sn, 1);
     1: 
     1:                 /*
     1:                  * Count the cases using offsets from switch to first case,
     1:                  * and case to case, stored in srcnote immediates.
     1:                  */
     1:                 pc2 = pc;
     1:                 off2 = off;
     1:                 for (ncases = 0; off2 != 0; ncases++) {
     1:                     pc2 += off2;
 86877:                     LOCAL_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT);
 86877:                     if (*pc2 == JSOP_DEFAULT) {
     1:                         /* End of cases, but count default as a case. */
     1:                         off2 = 0;
     1:                     } else {
     1:                         sn = js_GetSrcNote(jp->script, pc2);
     1:                         LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
     1:                         off2 = js_GetSrcNoteOffset(sn, 0);
     1:                     }
     1:                 }
     1: 
     1:                 /*
     1:                  * Allocate table and rescan the cases using their srcnotes,
     1:                  * stashing each case's delta from switch top in table[i].key,
     1:                  * and the distance to its statements in table[i].offset.
     1:                  */
     1:                 table = (TableEntry *)
 64560:                     cx->malloc_((size_t)ncases * sizeof *table);
     1:                 if (!table)
     1:                     return NULL;
     1:                 pc2 = pc;
     1:                 off2 = off;
     1:                 for (i = 0; i < ncases; i++) {
     1:                     pc2 += off2;
 86877:                     LOCAL_ASSERT(*pc2 == JSOP_CASE || *pc2 == JSOP_DEFAULT);
     1:                     caseOff = pc2 - pc;
 91450:                     table[i].key = INT_TO_JSVAL((int32_t) caseOff);
 86877:                     table[i].offset = caseOff + GET_JUMP_OFFSET(pc2);
 86877:                     if (*pc2 == JSOP_CASE) {
     1:                         sn = js_GetSrcNote(jp->script, pc2);
     1:                         LOCAL_ASSERT(sn && SN_TYPE(sn) == SRC_PCDELTA);
     1:                         off2 = js_GetSrcNoteOffset(sn, 0);
     1:                     }
     1:                 }
     1: 
     1:                 /*
     1:                  * Find offset of default code by fetching the default offset
     1:                  * from the end of table.  JSOP_CONDSWITCH always has a default
     1:                  * case at the end.
     1:                  */
     1:                 off = JSVAL_TO_INT(table[ncases-1].key);
     1:                 pc2 = pc + off;
 86877:                 off += GET_JUMP_OFFSET(pc2);
     1: 
 91237:                 ok = DecompileSwitch(ss, table, (unsigned)ncases, pc, len, off,
     1:                                      JS_TRUE);
 64560:                 cx->free_(table);
     1:                 if (!ok)
     1:                     return NULL;
     1:                 todo = -2;
     1:                 break;
     1:               }
     1: 
     1:               case JSOP_CASE:
     1:               {
 84803:                 lval = PopStr(ss, op, &lvalpc);
     1:                 if (!lval)
     1:                     return NULL;
 84803:                 js_printf(jp, "\tcase ");
 84803:                 SprintOpcodePermanent(jp, lval, lvalpc);
 84803:                 js_printf(jp, ":\n");
     1:                 todo = -2;
     1:                 break;
     1:               }
     1: 
 18965:               case JSOP_DEFFUN:
 89253:                 fun = jp->script->getFunction(GET_UINT32_INDEX(pc));
     1:                 todo = -2;
     1:                 goto do_function;
     1: 
 15279:               case JSOP_HOLE:
 90229:                 todo = ss->sprinter.put("", 0);
 15279:                 break;
 15279: 
     1:               case JSOP_NEWINIT:
     1:               {
 87974:                 i = GET_UINT8(pc);
 11039:                 LOCAL_ASSERT(i == JSProto_Array || i == JSProto_Object);
  8633: 
 87952:                 todo = ss->sprinter.getOffset();
  8633:                 if (i == JSProto_Array) {
     1:                     ++ss->inArrayInit;
 90229:                     if (ss->sprinter.put("[") < 0)
     1:                         return NULL;
     1:                 } else {
 90229:                     if (ss->sprinter.put("{") < 0)
     1:                         return NULL;
     1:                 }
     1:                 break;
     1:               }
     1: 
 58056:               case JSOP_NEWARRAY:
 58056:               {
 87952:                 todo = ss->sprinter.getOffset();
 58056:                 ++ss->inArrayInit;
 90229:                 if (ss->sprinter.put("[") < 0)
 58056:                     return NULL;
 58056:                 break;
 58056:               }
 58056: 
 58056:               case JSOP_NEWOBJECT:
 58056:               {
 87952:                 todo = ss->sprinter.getOffset();
 90229:                 if (ss->sprinter.put("{") < 0)
 58056:                     return NULL;
 58056:                 break;
 58056:               }
 58056: 
     1:               case JSOP_ENDINIT:
  8633:               {
  8633:                 JSBool inArray;
  8633: 
     1:                 op = JSOP_NOP;           /* turn off parens */
 84803:                 rval = PopStr(ss, op, &rvalpc);
     1:                 sn = js_GetSrcNote(jp->script, pc);
     1: 
     1:                 /* Skip any #n= prefix to find the opening bracket. */
     1:                 for (xval = rval; *xval != '[' && *xval != '{'; xval++)
     1:                     continue;
  8633:                 inArray = (*xval == '[');
  8633:                 if (inArray)
     1:                     --ss->inArrayInit;
 87952:                 todo = ss->sprinter.getOffset();
 84803:                 SprintOpcode(ss, rval, rvalpc, pc, todo);
 84803:                 Sprint(&ss->sprinter, "%s%c",
     1:                        (sn && SN_TYPE(sn) == SRC_CONTINUE) ? ", " : "",
  8633:                        inArray ? ']' : '}');
     1:                 break;
  8633:               }
     1: 
  8633:               {
  8633:                 JSBool isFirst;
 11474:                 const char *maybeComma;
 11474: 
 11474:               case JSOP_INITELEM:
 58056:                 isFirst = IsInitializerOp(ss->opcodes[ss->top - 3]);
 21450: 
 21450:                 /* Turn off most parens. */
 84803:                 rval = PopStr(ss, JSOP_SETNAME, &rvalpc);
 11474: 
 11474:                 /* Turn off all parens for xval and lval, which we control. */
 84803:                 xval = PopStr(ss, JSOP_NOP);
 84803:                 lval = PopStr(ss, JSOP_NOP, &lvalpc);
 11474:                 sn = js_GetSrcNote(jp->script, pc);
 11474: 
 11474:                 if (sn && SN_TYPE(sn) == SRC_INITPROP) {
 11474:                     atom = NULL;
 11474:                     goto do_initprop;
 11474:                 }
 11474:                 maybeComma = isFirst ? "" : ", ";
 84803:                 todo = Sprint(&ss->sprinter, "%s%s", lval, maybeComma);
 84803:                 SprintOpcode(ss, rval, rvalpc, pc, todo);
     1:                 break;
     1: 
     1:               case JSOP_INITPROP:
     1:                 LOAD_ATOM(0);
 80633:                 xval = QuoteString(&ss->sprinter, atom, jschar(IsIdentifier(atom) ? 0 : '\''));
     1:                 if (!xval)
     1:                     return NULL;
 58056:                 isFirst = IsInitializerOp(ss->opcodes[ss->top - 2]);
 84803:                 rval = PopStrDupe(ss, op, &rvalpc);
 84803:                 lval = PopStr(ss, op, &lvalpc);
 11474:                 /* fall through */
 11474: 
     1:               do_initprop:
 87952:                 todo = ss->sprinter.getOffset();
 84803:                 SprintOpcode(ss, lval, lvalpc, pc, todo);
 11474:                 maybeComma = isFirst ? "" : ", ";
     1:                 if (lastop == JSOP_GETTER || lastop == JSOP_SETTER) {
  1967:                     const char *end = rval + strlen(rval);
  1967: 
  1967:                     if (*rval == '(')
  1967:                         ++rval, --end;
  1967:                     LOCAL_ASSERT(strncmp(rval, js_function_str, 8) == 0);
  1967:                     LOCAL_ASSERT(rval[8] == ' ');
     1:                     rval += 8 + 1;
  1967:                     LOCAL_ASSERT(*end ? *end == ')' : end[-1] == '}');
 84803:                     Sprint(&ss->sprinter, "%s%s %s%s%.*s",
 11474:                            maybeComma,
     1:                            (lastop == JSOP_GETTER)
     1:                            ? js_get_str : js_set_str,
     1:                            xval,
   526:                            (rval[0] != '(') ? " " : "",
  1967:                            end - rval, rval);
     1:                 } else {
 84803:                     Sprint(&ss->sprinter, "%s%s: ", maybeComma, xval);
 84803:                     SprintOpcode(ss, rval, rvalpc, pc, todo);
     1:                 }
     1:                 break;
  8633:               }
     1: 
     1:               case JSOP_DEBUGGER:
     1:                 js_printf(jp, "\tdebugger;\n");
     1:                 todo = -2;
     1:                 break;
     1: 
     1: #if JS_HAS_XML_SUPPORT
     1:               case JSOP_STARTXML:
     1:               case JSOP_STARTXMLEXPR:
     1:                 inXML = op == JSOP_STARTXML;
     1:                 todo = -2;
     1:                 break;
     1: 
     1:               case JSOP_DEFXMLNS:
     1:                 rval = POP_STR();
     1:                 js_printf(jp, "\t%s %s %s = %s;\n",
     1:                           js_default_str, js_xml_str, js_namespace_str, rval);
     1:                 todo = -2;
     1:                 break;
     1: 
     1:               case JSOP_ANYNAME:
     1:                 if (pc[JSOP_ANYNAME_LENGTH] == JSOP_TOATTRNAME) {
     1:                     len += JSOP_TOATTRNAME_LENGTH;
 90229:                     todo = ss->sprinter.put("@*", 2);
     1:                 } else {
 90229:                     todo = ss->sprinter.put("*", 1);
     1:                 }
     1:                 break;
 98644: #endif
     1: 
  8285:               case JSOP_QNAMEPART:
  8285:                 LOAD_ATOM(0);
 98644: #if JS_HAS_XML_SUPPORT
     1:                 if (pc[JSOP_QNAMEPART_LENGTH] == JSOP_TOATTRNAME) {
     1:                     saveop = JSOP_TOATTRNAME;
     1:                     len += JSOP_TOATTRNAME_LENGTH;
     1:                     lval = "@";
     1:                     goto do_qname;
     1:                 }
 98644: #endif
     1:                 goto do_name;
  8285: 
 98644: #if JS_HAS_XML_SUPPORT
  8285:               case JSOP_QNAMECONST:
  8285:                 LOAD_ATOM(0);
 64345:                 rval = QuoteString(&ss->sprinter, atom, 0);
     1:                 if (!rval)
     1:                     return NULL;
 87952:                 ss->sprinter.setOffset(rval);
     1:                 lval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, "%s::%s", lval, rval);
  8285:                 break;
     1: 
     1:               case JSOP_QNAME:
     1:                 rval = POP_STR();
     1:                 lval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, "%s::[%s]", lval, rval);
     1:                 break;
     1: 
     1:               case JSOP_TOATTRNAME:
     1:                 op = JSOP_NOP;           /* turn off parens */
     1:                 rval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, "@[%s]", rval);
     1:                 break;
     1: 
     1:               case JSOP_TOATTRVAL:
     1:                 todo = -2;
     1:                 break;
     1: 
     1:               case JSOP_ADDATTRNAME:
     1:                 rval = POP_STR();
     1:                 lval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, "%s %s", lval, rval);
     1:                 /* This gets reset by all XML tag expressions. */
     1:                 quoteAttr = JS_TRUE;
     1:                 break;
     1: 
     1:               case JSOP_ADDATTRVAL:
     1:                 rval = POP_STR();
     1:                 lval = POP_STR();
     1:                 if (quoteAttr)
     1:                     todo = Sprint(&ss->sprinter, "%s=\"%s\"", lval, rval);
     1:                 else
     1:                     todo = Sprint(&ss->sprinter, "%s=%s", lval, rval);
     1:                 break;
     1: 
     1:               case JSOP_BINDXMLNAME:
     1:                 /* Leave the name stacked and push a dummy string. */
     1:                 todo = Sprint(&ss->sprinter, "");
     1:                 break;
     1: 
     1:               case JSOP_SETXMLNAME:
     1:                 /* Pop the r.h.s., the dummy string, and the name. */
 84803:                 rval = PopStrDupe(ss, op, &rvalpc);
     1:                 (void) PopOff(ss, op);
     1:                 lval = POP_STR();
     1:                 goto do_setlval;
     1: 
     1:               case JSOP_XMLELTEXPR:
     1:               case JSOP_XMLTAGEXPR:
     1:                 todo = Sprint(&ss->sprinter, "{%s}", POP_STR());
     1:                 inXML = JS_TRUE;
     1:                 /* If we're an attribute value, we shouldn't quote this. */
     1:                 quoteAttr = JS_FALSE;
     1:                 break;
     1: 
     1:               case JSOP_TOXMLLIST:
     1:                 op = JSOP_NOP;           /* turn off parens */
     1:                 todo = Sprint(&ss->sprinter, "<>%s</>", POP_STR());
     1:                 inXML = JS_FALSE;
     1:                 break;
     1: 
     1:               case JSOP_TOXML:
     1:               case JSOP_CALLXMLNAME:
     1:               case JSOP_XMLNAME:
     1:               case JSOP_FILTER:
     1:                 /* These ops indicate the end of XML expressions. */
     1:                 inXML = JS_FALSE;
     1:                 todo = -2;
     1:                 break;
     1: 
     1:               case JSOP_ENDFILTER:
     1:                 rval = POP_STR();
 20928:                 PROPAGATE_CALLNESS();
     1:                 lval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, "%s.(%s)", lval, rval);
     1:                 break;
     1: 
     1:               case JSOP_DESCENDANTS:
     1:                 rval = POP_STR();
 20928:                 PROPAGATE_CALLNESS();
     1:                 lval = POP_STR();
     1:                 todo = Sprint(&ss->sprinter, "%s..%s", lval, rval);
     1:                 break;
     1: 
  8285:               case JSOP_XMLCDATA:
  8285:                 LOAD_ATOM(0);
 90229:                 todo = ss->sprinter.put("<![CDATA[", 9);
 64345:                 if (!QuoteString(&ss->sprinter, atom, DONT_ESCAPE))
     1:                     return NULL;
 90229:                 ss->sprinter.put("]]>", 3);
  8285:                 break;
  8285: 
  8285:               case JSOP_XMLCOMMENT:
  8285:                 LOAD_ATOM(0);
 90229:                 todo = ss->sprinter.put("<!--", 4);
 64345:                 if (!QuoteString(&ss->sprinter, atom, DONT_ESCAPE))
     1:                     return NULL;
 90229:                 ss->sprinter.put("-->", 3);
  8285:                 break;
  8285: 
  8285:               case JSOP_XMLPI:
  8285:                 LOAD_ATOM(0);
     1:                 rval = JS_strdup(cx, POP_STR());
     1:                 if (!rval)
     1:                     return NULL;
 90229:                 todo = ss->sprinter.put("<?", 2);
 64345:                 ok = QuoteString(&ss->sprinter, atom, 0) &&
     1:                      (*rval == '\0' ||
 90229:                       (ss->sprinter.put(" ", 1) >= 0 &&
 90229:                        ss->sprinter.put(rval)));
 64560:                 cx->free_((char *)rval);
     1:                 if (!ok)
     1:                     return NULL;
 90229:                 ss->sprinter.put("?>", 2);
  8285:                 break;
     1: 
     1:               case JSOP_GETFUNNS:
 90229:                 todo = ss->sprinter.put(js_function_str, 8);
     1:                 break;
     1: #endif /* JS_HAS_XML_SUPPORT */
     1: 
     1:               default:
     1:                 todo = -2;
     1:                 break;
     1:             }
     1:         }
     1: 
 84803:         if (cx->isExceptionPending()) {
 84803:             /* OOMs while printing to a string do not immediately return. */
 84803:             return NULL;
 84803:         }
 84803: 
     1:         if (todo < 0) {
     1:             /* -2 means "don't push", -1 means reported error. */
 84803:             JS_ASSERT(todo == -2);
     1:             if (todo == -1)
     1:                 return NULL;
     1:         } else {
 84803:             if (!UpdateDecompiledText(ss, pushpc, todo))
     1:                 return NULL;
 84803:             if (!PushOff(ss, todo, saveop, pushpc))
 84803:                 return NULL;
 84803:             if (js_CodeSpec[*pc].format & JOF_DECOMPOSE)
 84803:                 CopyDecompiledTextForDecomposedOp(jp, pc);
     1:         }
     1: 
 87044:         if (op == JSOP_CALLXMLNAME) {
 87044:             todo = Sprint(&ss->sprinter, "");
 87044:             if (todo < 0 || !PushOff(ss, todo, saveop))
 87044:                 return NULL;
 87044:         }
 87044: 
     1:         pc += len;
     1:     }
     1: 
     1: /*
     1:  * Undefine local macros.
     1:  */
     1: #undef inXML
     1: #undef DECOMPILE_CODE
 21441: #undef TOP_STR
     1: #undef POP_STR
 21441: #undef POP_STR_PREC
     1: #undef LOCAL_ASSERT
     1: #undef GET_QUOTE_AND_FMT
     1: #undef GET_ATOM_QUOTE_AND_FMT
     1: 
     1:     return pc;
     1: }
     1: 
 12981: static JSBool
 91237: DecompileCode(JSPrinter *jp, JSScript *script, jsbytecode *pc, unsigned len,
 91237:               unsigned pcdepth)
     1: {
 79778:     JSContext *cx = jp->sprinter.context;
 79778: 
 91237:     unsigned depth = StackDepth(script);
     1:     JS_ASSERT(pcdepth <= depth);
     1: 
     1:     /* Initialize a sprinter for use with the offset stack. */
 79410:     LifoAllocScope las(&cx->tempLifoAlloc());
 87952:     SprintStack ss(cx);
 79410:     if (!InitSprintStack(cx, &ss, jp, depth))
 79410:         return false;
     1: 
     1:     /*
     1:      * If we are called from js_DecompileValueGenerator with a portion of
     1:      * script's bytecode that starts with a non-zero model stack depth given
     1:      * by pcdepth, attempt to initialize the missing string offsets in ss to
     1:      * |spindex| negative indexes from fp->sp for the activation fp in which
     1:      * the error arose.
     1:      *
     1:      * See js_DecompileValueGenerator for how its |spindex| parameter is used,
     1:      * and see also GetOff, which makes use of the ss.offsets[i] < -1 that are
     1:      * potentially stored below.
     1:      */
     1:     ss.top = pcdepth;
     1:     if (pcdepth != 0) {
 91237:         for (unsigned i = 0; i < pcdepth; i++) {
 13182:             ss.offsets[i] = -2 - (ptrdiff_t)i;
 12981:             ss.opcodes[i] = *jp->pcstack[i];
     1:         }
     1:     }
     1: 
     1:     /* Call recursive subroutine to do the hard work. */
 79778:     JSScript *oldscript = jp->script;
     1:     jp->script = script;
 81589:     bool ok = Decompile(&ss, pc, len) != NULL;
     1:     jp->script = oldscript;
     1: 
     1:     /* If the given code didn't empty the stack, do it now. */
 14804:     if (ok && ss.top) {
 87952:         const char *last;
     1:         do {
 87952:             last = ss.sprinter.stringAt(PopOff(&ss, JSOP_POP));
     1:         } while (ss.top > pcdepth);
     1:         js_printf(jp, "%s", last);
     1:     }
     1: 
     1:     return ok;
     1: }
     1: 
 62062: /*
 62062:  * Decompile a function body, expression closure expression, or complete
 62062:  * script. Start at |pc|; go to the end of |script|. Include a directive
 62062:  * prologue, if appropriate.
 62062:  */
 62062: static JSBool
 62062: DecompileBody(JSPrinter *jp, JSScript *script, jsbytecode *pc)
 62062: {
 62062:     /* Print a strict mode code directive, if needed. */
 62062:     if (script->strictModeCode && !jp->strict) {
 62062:         if (jp->fun && (jp->fun->flags & JSFUN_EXPR_CLOSURE)) {
 62062:             /*
 62062:              * We have no syntax for strict function expressions;
 62062:              * at least give a hint.
 62062:              */
 62062:             js_printf(jp, "\t/* use strict */ \n");
 62062:         } else {
 62062:             js_printf(jp, "\t\"use strict\";\n");
 62062:         }
 62062:         jp->strict = true;
 62062:     }
 62062: 
 62062:     jsbytecode *end = script->code + script->length;
 62062:     return DecompileCode(jp, script, pc, end - pc, 0);
 62062: }
 62062: 
     1: JSBool
     1: js_DecompileScript(JSPrinter *jp, JSScript *script)
     1: {
 62062:     return DecompileBody(jp, script, script->code);
     1: }
     1: 
 35040: JSString *
 35040: js_DecompileToString(JSContext *cx, const char *name, JSFunction *fun,
 91237:                      unsigned indent, JSBool pretty, JSBool grouped, JSBool strict,
 35378:                      JSDecompilerPtr decompiler)
 35040: {
 35040:     JSPrinter *jp;
 35040:     JSString *str;
 35040: 
 35113:     jp = js_NewPrinter(cx, name, fun, indent, pretty, grouped, strict);
 35040:     if (!jp)
 35040:         return NULL;
 35040:     if (decompiler(jp))
 35040:         str = js_GetPrinterOutput(jp);
 35040:     else
 35040:         str = NULL;
 61225:     js_DestroyPrinter(jp);
 35040:     return str;
 35040: }
 35040: 
     1: static const char native_code_str[] = "\t[native code]\n";
     1: 
 34364: JSBool
 13702: js_DecompileFunctionBody(JSPrinter *jp)
     1: {
     1:     JSScript *script;
  8179: 
 13702:     JS_ASSERT(jp->fun);
  8179:     JS_ASSERT(!jp->script);
 76812:     if (!jp->fun->isInterpreted()) {
     1:         js_printf(jp, native_code_str);
     1:         return JS_TRUE;
     1:     }
 13702: 
 70311:     script = jp->fun->script();
 62062:     return DecompileBody(jp, script, script->code);
     1: }
     1: 
 34364: JSBool
 13702: js_DecompileFunction(JSPrinter *jp)
     1: {
 97353:     JSContext *cx = jp->sprinter.context;
 97353: 
 99421:     RootedFunction fun(cx, jp->fun);
 13702:     JS_ASSERT(fun);
  8179:     JS_ASSERT(!jp->script);
  8179: 
     1:     /*
     1:      * If pretty, conform to ECMA-262 Edition 3, 15.3.4.2, by decompiling a
     1:      * FunctionDeclaration.  Otherwise, check the JSFUN_LAMBDA flag and force
     1:      * an expression by parenthesizing.
     1:      */
     1:     if (jp->pretty) {
     1:         js_printf(jp, "\t");
     1:     } else {
     1:         if (!jp->grouped && (fun->flags & JSFUN_LAMBDA))
     1:             js_puts(jp, "(");
     1:     }
     1: 
     1:     js_printf(jp, "%s ", js_function_str);
 64345:     if (fun->atom && !QuoteString(&jp->sprinter, fun->atom, 0))
     1:         return JS_FALSE;
     1:     js_puts(jp, "(");
     1: 
 76812:     if (!fun->isInterpreted()) {
 13702:         js_printf(jp, ") {\n");
 13702:         jp->indent += 4;
 13702:         js_printf(jp, native_code_str);
 13702:         jp->indent -= 4;
 13702:         js_printf(jp, "\t}");
 13702:     } else {
 70311:         JSScript *script = fun->script();
 32776: #if JS_HAS_DESTRUCTURING
 97353:         SprintStack ss(cx);
     1: #endif
     1: 
  8179:         /* Print the parameters. */
 79778:         jsbytecode *pc = script->main();
 79778:         jsbytecode *endpc = pc + script->length;
 79778:         JSBool ok = JS_TRUE;
     1: 
 34559: #if JS_HAS_DESTRUCTURING
     1:         ss.printer = NULL;
 34559:         jp->script = script;
     1: #endif
     1:         
 99552:         jsbytecode *deftable = NULL;
 99552:         jsbytecode *defbegin = NULL;
 99552:         int32_t deflen = 0;
 99552:         uint16_t defstart = 0;
 99552:         unsigned nformal = fun->nargs - fun->hasRest();
 99552: 
 91237:         for (unsigned i = 0; i < fun->nargs; i++) {
     1:             if (i > 0)
     1:                 js_puts(jp, ", ");
     1: 
 99552:             bool isRest = fun->hasRest() && i == unsigned(fun->nargs) - 1;
 99552:             if (isRest)
 99225:                 js_puts(jp, "...");
 79778:             JSAtom *param = GetArgOrVarAtom(jp, i);
  8179: 
     1: #if JS_HAS_DESTRUCTURING
     1: #define LOCAL_ASSERT(expr)      LOCAL_ASSERT_RV(expr, JS_FALSE)
     1: 
  8179:             if (!param) {
     1:                 ptrdiff_t todo;
     1:                 const char *lval;
     1: 
 99552:                 JS_ASSERT(deflen == 0);
 95101:                 LOCAL_ASSERT(*pc == JSOP_GETARG || *pc == JSOP_GETALIASEDVAR);
 95101:                 pc += js_CodeSpec[*pc].length;
     1:                 LOCAL_ASSERT(*pc == JSOP_DUP);
     1:                 if (!ss.printer) {
 97353:                     ok = InitSprintStack(cx, &ss, jp, StackDepth(script));
     1:                     if (!ok)
     1:                         break;
     1:                 }
     1:                 pc = DecompileDestructuring(&ss, pc, endpc);
     1:                 if (!pc) {
     1:                     ok = JS_FALSE;
     1:                     break;
     1:                 }
     1:                 LOCAL_ASSERT(*pc == JSOP_POP);
     1:                 pc += JSOP_POP_LENGTH;
     1:                 lval = PopStr(&ss, JSOP_NOP);
 90229:                 todo = jp->sprinter.put(lval);
     1:                 if (todo < 0) {
     1:                     ok = JS_FALSE;
     1:                     break;
     1:                 }
     1:                 continue;
     1:             }
     1: 
 99552: #endif
 99552: 
 99552:             // Compute default parameters.
 99552:             if ((*pc == JSOP_REST && pc[1] == JSOP_UNDEFINED) ||
 99552:                 *pc == JSOP_ACTUALSFILLED) {
 99552: #define SKIP(pc, op) LOCAL_ASSERT(*pc == op); pc += js_CodeSpec[op].length;
 99552:                 JS_ASSERT(fun->hasDefaults());
 99552:                 JS_ASSERT(deflen == 0);
 99552:                 if (fun->hasRest()) {
 99552:                     SKIP(pc, JSOP_REST);
 99552:                     SKIP(pc, JSOP_UNDEFINED);
 99552:                     JS_ASSERT(*pc == JSOP_SETARG || *pc == JSOP_SETALIASEDVAR);
 99552:                     pc += js_CodeSpec[*pc].length;
 99552:                     SKIP(pc, JSOP_POP);
 99552:                 }
 99552:                 SKIP(pc, JSOP_ACTUALSFILLED);
 99552:                 JS_ASSERT(*pc == JSOP_TABLESWITCH);
 99552:                 defbegin = pc;
 99552:                 deflen = GET_JUMP_OFFSET(pc);
 99552:                 pc += JUMP_OFFSET_LEN;
 99552:                 defstart = GET_JUMP_OFFSET(pc);
 99552:                 pc += JUMP_OFFSET_LEN;
 99552:                 pc += JUMP_OFFSET_LEN; // Skip high
 99552:                 deftable = pc;
 99552:                 pc = defbegin + deflen;
 99552:                 if (fun->hasRest()) {
 99552:                     SKIP(pc, JSOP_SETARG);
 99552:                     SKIP(pc, JSOP_POP);
 99552:                 }
 99552: #undef SKIP
 99552:             }
 99552: 
     1: #undef LOCAL_ASSERT
 99552: 
 99552:             if (fun->hasDefaults() && deflen && i >= defstart && !isRest) {
 99552: #define TABLE_OFF(off) GET_JUMP_OFFSET(&deftable[(off)*JUMP_OFFSET_LEN])
 99552:                 jsbytecode *casestart = defbegin + TABLE_OFF(i - defstart);
 99552:                 jsbytecode *caseend = defbegin + ((i < nformal - 1) ? TABLE_OFF(i - defstart + 1) : deflen);
 99552: #undef TABLE_OFF
 99552:                 unsigned exprlength = caseend - casestart - js_CodeSpec[JSOP_POP].length;
 99552:                 if (!DecompileCode(jp, script, casestart, exprlength, 0))
 99552:                     return JS_FALSE;
 99552:             } else if (!QuoteString(&jp->sprinter, param, 0)) {
     1:                 ok = JS_FALSE;
     1:                 break;
     1:             }
     1:         }
     1: 
 32776: #if JS_HAS_DESTRUCTURING
  8179:         jp->script = NULL;
     1: #endif
     1:         if (!ok)
     1:             return JS_FALSE;
  1967:         js_printf(jp, ") ");
 60793:         if (!(fun->flags & JSFUN_EXPR_CLOSURE)) {
 60793:             js_printf(jp, "{\n");
     1:             jp->indent += 4;
  1967:         }
  1967: 
 62062:         ok = DecompileBody(jp, script, pc);
  8179:         if (!ok)
     1:             return JS_FALSE;
  1967: 
  1967:         if (!(fun->flags & JSFUN_EXPR_CLOSURE)) {
     1:             jp->indent -= 4;
     1:             js_printf(jp, "\t}");
  1967:         }
 13702:     }
  8179: 
  8179:     if (!jp->pretty && !jp->grouped && (fun->flags & JSFUN_LAMBDA))
     1:         js_puts(jp, ")");
  8179: 
     1:     return JS_TRUE;
     1: }
     1: 
     1: char *
 91237: js_DecompileValueGenerator(JSContext *cx, int spindex, jsval v,
     1:                            JSString *fallback)
     1: {
 69223:     StackFrame *fp;
 53840:     JSScript *script;
 12981:     jsbytecode *pc;
     1: 
 11420:     JS_ASSERT(spindex < 0 ||
 11420:               spindex == JSDVG_IGNORE_STACK ||
 11420:               spindex == JSDVG_SEARCH_STACK);
 11420: 
 71696:     if (!cx->hasfp() || !cx->fp()->isScriptFrame())
     1:         goto do_fallback;
     1: 
 77398:     fp = js_GetTopStackFrame(cx, FRAME_EXPAND_ALL);
 53840:     script = fp->script();
 82642:     pc = cx->regs().pc;
 56720:     JS_ASSERT(script->code <= pc && pc < script->code + script->length);
     1: 
 77659:     if (pc < script->main())
 61232:         goto do_fallback;
 61232: 
     1:     if (spindex != JSDVG_IGNORE_STACK) {
 12579:         jsbytecode **pcstack;
 12579: 
 12579:         /*
 12579:          * Prepare computing pcstack containing pointers to opcodes that
 12579:          * populated interpreter's stack with its current content.
 12579:          */
 12579:         pcstack = (jsbytecode **)
 64560:                   cx->malloc_(StackDepth(script) * sizeof *pcstack);
 12579:         if (!pcstack)
 12579:             return NULL;
 84117:         jsbytecode *lastDecomposedPC = NULL;
 91237:         int pcdepth = ReconstructPCStack(cx, script, pc, pcstack, &lastDecomposedPC);
 12579:         if (pcdepth < 0)
 12579:             goto release_pcstack;
 12579: 
 12579:         if (spindex != JSDVG_SEARCH_STACK) {
     1:             JS_ASSERT(spindex < 0);
 12579:             pcdepth += spindex;
 12579:             if (pcdepth < 0)
 12579:                 goto release_pcstack;
 12579:             pc = pcstack[pcdepth];
 12579:         } else {
     1:             /*
 12579:              * We search from fp->sp to base to find the most recently
 12579:              * calculated value matching v under assumption that it is
 12579:              * it that caused exception, see bug 328664.
     1:              */
100006:             Value *stackBase = fp->base();
 69223:             Value *sp = cx->regs().sp;
 12579:             do {
 16072:                 if (sp == stackBase) {
 12579:                     pcdepth = -1;
 12579:                     goto release_pcstack;
 12579:                 }
 12579:             } while (*--sp != v);
 12579: 
 12579:             /*
 50464:              * The value may have come from beyond stackBase + pcdepth, meaning
 50464:              * that it came from a temporary slot pushed by the interpreter or
 56213:              * arguments pushed for an Invoke call. Only update pc if beneath
 56213:              * stackBase + pcdepth. If above, the value may or may not be
 56213:              * produced by the current pc. Since it takes a fairly contrived
 56213:              * combination of calls to produce a situation where this is not
 56213:              * what we want, we just use the current pc.
 84117:              *
 84117:              * If we are in the middle of a decomposed opcode, use the outer
 84117:              * 'fat' opcode itself. Any source notes for the operation which
 84117:              * are needed during decompilation will be associated with the
 84117:              * outer opcode.
 12579:              */
 84117:             if (sp < stackBase + pcdepth) {
 16072:                 pc = pcstack[sp - stackBase];
 84117:                 if (lastDecomposedPC) {
 84117:                     size_t len = GetDecomposeLength(lastDecomposedPC,
 84117:                                                     js_CodeSpec[*lastDecomposedPC].length);
 84117:                     if (unsigned(pc - lastDecomposedPC) < len)
 84117:                         pc = lastDecomposedPC;
 84117:                 }
 84117:             }
 12579:         }
 12579: 
 12579:       release_pcstack:
 64560:         cx->free_(pcstack);
 12579:         if (pcdepth < 0)
     1:             goto do_fallback;
     1:     }
 12579: 
 21808:     {
 82642:         char *name = DecompileExpression(cx, script, fp->maybeFun(), pc);
 12981:         if (name != FAILED_EXPRESSION_DECOMPILER)
 12981:             return name;
 42717:     }
 12981: 
 12981:   do_fallback:
 12981:     if (!fallback) {
 12981:         fallback = js_ValueToSource(cx, v);
 12981:         if (!fallback)
 12981:             return NULL;
 12981:     }
 59890:     size_t length = fallback->length();
 59890:     const jschar *chars = fallback->getChars(cx);
 59890:     if (!chars)
 59890:         return NULL;
 71337:     return DeflateString(cx, chars, length);
 12981: }
 12981: 
 12981: static char *
 13702: DecompileExpression(JSContext *cx, JSScript *script, JSFunction *fun,
 12981:                     jsbytecode *pc)
 12981: {
 56720:     JS_ASSERT(script->code <= pc && pc < script->code + script->length);
 79778: 
 79778:     JSOp op = (JSOp) *pc;
     1: 
     1:     /* None of these stack-writing ops generates novel values. */
 86877:     JS_ASSERT(op != JSOP_CASE && op != JSOP_DUP && op != JSOP_DUP2);
     1: 
     1:     /*
     1:      * |this| could convert to a very long object initialiser, so cite it by
     1:      * its keyword name instead.
     1:      */
 79778:     if (op == JSOP_THIS)
 79778:         return JS_strdup(cx, js_this_str);
     1: 
     1:     /*
     1:      * JSOP_BINDNAME is special: it generates a value, the base object of a
     1:      * reference.  But if it is the generating op for a diagnostic produced by
     1:      * js_DecompileValueGenerator, the name being bound is irrelevant.  Just
     1:      * fall back to the base object.
     1:      */
 79778:     if (op == JSOP_BINDNAME)
 79778:         return FAILED_EXPRESSION_DECOMPILER;
     1: 
     1:     /* NAME ops are self-contained, others require left or right context. */
 79778:     const JSCodeSpec *cs = &js_CodeSpec[op];
 79778:     jsbytecode *begin = pc;
 79778:     jsbytecode *end = pc + cs->length;
  1761:     switch (JOF_MODE(cs->format)) {
     1:       case JOF_PROP:
     1:       case JOF_ELEM:
     1:       case JOF_XMLNAME:
 79778:       case 0: {
 79778:         jssrcnote *sn = js_GetSrcNote(script, pc);
 79778:         if (!sn)
 79778:             return FAILED_EXPRESSION_DECOMPILER;
     1:         switch (SN_TYPE(sn)) {
     1:           case SRC_PCBASE:
     1:             begin -= js_GetSrcNoteOffset(sn, 0);
     1:             break;
     1:           case SRC_PCDELTA:
     1:             end = begin + js_GetSrcNoteOffset(sn, 0);
     1:             begin += cs->length;
     1:             break;
     1:           default:
 79778:             return FAILED_EXPRESSION_DECOMPILER;
     1:         }
     1:         break;
 79778:       }
     1:       default:;
     1:     }
 86855: 
 86855:     /*
 86855:      * Include the trailing SWAP when decompiling CALLPROP or CALLELEM ops,
 86855:      * so that the result is the entire access rather than the lvalue.
 86855:      */
 86855:     if (op == JSOP_CALLPROP || op == JSOP_CALLELEM) {
 86855:         JS_ASSERT(*end == JSOP_SWAP);
 86855:         end += JSOP_SWAP_LENGTH;
 86855:     }
 86855: 
 79778:     ptrdiff_t len = end - begin;
 79778:     if (len <= 0)
 79778:         return FAILED_EXPRESSION_DECOMPILER;
 79778: 
 79778:     struct Guard {
 79778:         jsbytecode **pcstack;
 79778:         JSPrinter *printer;
 79778:         Guard() : pcstack(NULL), printer(NULL) {}
 79778:         ~Guard() {
 79778:             if (printer)
 79778:                 js_DestroyPrinter(printer);
 79778:             Foreground::free_(pcstack);
 79778:         }
 79778:     } g;
 79778: 
 79778:     g.pcstack = (jsbytecode **)OffTheBooks::malloc_(StackDepth(script) * sizeof *g.pcstack);
 79778:     if (!g.pcstack)
 79778:         return NULL;
 79778: 
 91237:     int pcdepth = ReconstructPCStack(cx, script, begin, g.pcstack, NULL);
 79778:     if (pcdepth < 0)
 79778:          return FAILED_EXPRESSION_DECOMPILER;
 79778: 
 79778:     g.printer = js_NewPrinter(cx, "js_DecompileValueGenerator", fun, 0, false, false, false);
 79778:     if (!g.printer)
 79778:         return NULL;
 79778: 
 79778:     g.printer->dvgfence = end;
 79778:     g.printer->pcstack = g.pcstack;
 91237:     if (!DecompileCode(g.printer, script, begin, (unsigned) len, (unsigned) pcdepth))
 79778:         return NULL;
 79778: 
 87952:     return JS_strdup(cx, g.printer->sprinter.string());
 12579: }
 12579: 
 91237: unsigned
 17862: js_ReconstructStackDepth(JSContext *cx, JSScript *script, jsbytecode *pc)
 17862: {
 84117:     return ReconstructPCStack(cx, script, pc, NULL, NULL);
 17862: }
 17862: 
 27890: #define LOCAL_ASSERT(expr)      LOCAL_ASSERT_RV(expr, -1);
 27890: 
 91237: static int
 27890: SimulateOp(JSContext *cx, JSScript *script, JSOp op, const JSCodeSpec *cs,
 91237:            jsbytecode *pc, jsbytecode **pcstack, unsigned &pcdepth)
 27890: {
 91237:     unsigned nuses = StackUses(script, pc);
 91237:     unsigned ndefs = StackDefs(script, pc);
 27890:     LOCAL_ASSERT(pcdepth >= nuses);
 27890:     pcdepth -= nuses;
 27890:     LOCAL_ASSERT(pcdepth + ndefs <= StackDepth(script));
 27890: 
 27890:     /*
 27890:      * Fill the slots that the opcode defines withs its pc unless it just
 27890:      * reshuffles the stack. In the latter case we want to preserve the
 27890:      * opcode that generated the original value.
 27890:      */
 27890:     switch (op) {
 27890:       default:
 27890:         if (pcstack) {
 91237:             for (unsigned i = 0; i != ndefs; ++i)
 27890:                 pcstack[pcdepth + i] = pc;
 27890:         }
 27890:         break;
 27890: 
 27890:       case JSOP_CASE:
 27890:         /* Keep the switch value. */
 27890:         JS_ASSERT(ndefs == 1);
 27890:         break;
 27890: 
 27890:       case JSOP_DUP:
 27890:         JS_ASSERT(ndefs == 2);
 27890:         if (pcstack)
 27890:             pcstack[pcdepth + 1] = pcstack[pcdepth];
 27890:         break;
 27890: 
 27890:       case JSOP_DUP2:
 27890:         JS_ASSERT(ndefs == 4);
 27890:         if (pcstack) {
 27890:             pcstack[pcdepth + 2] = pcstack[pcdepth];
 27890:             pcstack[pcdepth + 3] = pcstack[pcdepth + 1];
 27890:         }
 27890:         break;
 27890: 
 27890:       case JSOP_SWAP:
 27890:         JS_ASSERT(ndefs == 2);
 27890:         if (pcstack) {
 27890:             jsbytecode *tmp = pcstack[pcdepth + 1];
 27890:             pcstack[pcdepth + 1] = pcstack[pcdepth];
 27890:             pcstack[pcdepth] = tmp;
 27890:         }
 27890:         break;
 27890:     }
 27890:     pcdepth += ndefs;
 27890:     return pcdepth;
 27890: }
 27890: 
 91237: static int
 17947: ReconstructPCStack(JSContext *cx, JSScript *script, jsbytecode *target,
 84117:                    jsbytecode **pcstack, jsbytecode **lastDecomposedPC)
 12579: {
     1:     /*
 12579:      * Walk forward from script->main and compute the stack depth and stack of
 12579:      * operand-generating opcode PCs in pcstack.
 12579:      *
     1:      * FIXME: Code to compute oplen copied from js_Disassemble1 and reduced.
     1:      * FIXME: Optimize to use last empty-stack sequence point.
     1:      */
 27890: 
 62934:     LOCAL_ASSERT(script->code <= target && target < script->code + script->length);
 62934:     jsbytecode *pc = script->code;
 91237:     unsigned pcdepth = 0;
 26729:     ptrdiff_t oplen;
 26729:     for (; pc < target; pc += oplen) {
 84195:         JSOp op = JSOp(*pc);
 26729:         const JSCodeSpec *cs = &js_CodeSpec[op];
     1:         oplen = cs->length;
 16072:         if (oplen < 0)
 16072:             oplen = js_GetVariableBytecodeLength(pc);
     1: 
 84117:         if (cs->format & JOF_DECOMPOSE) {
 84117:             if (lastDecomposedPC)
 84117:                 *lastDecomposedPC = pc;
 77357:             continue;
 84117:         }
 77357: 
     1:         /*
 17947:          * A (C ? T : E) expression requires skipping either T (if target is in
 17947:          * E) or both T and E (if target is after the whole expression) before
 86877:          * adjusting pcdepth based on the JSOP_IFEQ at pc that tests condition
 86877:          * C. We know that the stack depth can't change from what it was with
 86877:          * C on top of stack.
     1:          */
 26729:         jssrcnote *sn = js_GetSrcNote(script, pc);
     1:         if (sn && SN_TYPE(sn) == SRC_COND) {
 26729:             ptrdiff_t jmpoff = js_GetSrcNoteOffset(sn, 0);
 17947:             if (pc + jmpoff < target) {
     1:                 pc += jmpoff;
 84195:                 op = JSOp(*pc);
 86877:                 JS_ASSERT(op == JSOP_GOTO);
     1:                 cs = &js_CodeSpec[op];
     1:                 oplen = cs->length;
 17198:                 JS_ASSERT(oplen > 0);
 86877:                 ptrdiff_t jmplen = GET_JUMP_OFFSET(pc);
 17947:                 if (pc + jmplen < target) {
 91237:                     oplen = (unsigned) jmplen;
     1:                     continue;
     1:                 }
     1: 
     1:                 /*
 17947:                  * Ok, target lies in E. Manually pop C off the model stack,
     1:                  * since we have moved beyond the IFEQ now.
     1:                  */
 26729:                 LOCAL_ASSERT(pcdepth != 0);
     1:                 --pcdepth;
     1:             }
     1:         }
     1: 
 38549:         /* Ignore early-exit code, which is annotated SRC_HIDDEN. */
 38549:         if (sn && SN_TYPE(sn) == SRC_HIDDEN)
     1:             continue;
     1: 
 27890:         if (SimulateOp(cx, script, op, cs, pc, pcstack, pcdepth) < 0)
 27890:             return -1;
 27890: 
     1:     }
 17947:     LOCAL_ASSERT(pc == target);
 12579:     return pcdepth;
 64240: }
 12579: 
 12579: #undef LOCAL_ASSERT
 12579: #undef LOCAL_ASSERT_RV
 64556: 
 64556: namespace js {
 64556: 
 64556: bool
 64556: CallResultEscapes(jsbytecode *pc)
 64556: {
 64556:     /*
 64556:      * If we see any of these sequences, the result is unused:
 64556:      * - call / pop
 64556:      *
 64556:      * If we see any of these sequences, the result is only tested for nullness:
 64556:      * - call / ifeq
 64556:      * - call / not / ifeq
 64556:      */
 64556: 
 64556:     if (*pc != JSOP_CALL)
 64556:         return true;
 64556: 
 64556:     pc += JSOP_CALL_LENGTH;
 64556: 
 64556:     if (*pc == JSOP_POP)
 64556:         return false;
 64556: 
 64556:     if (*pc == JSOP_NOT)
 64556:         pc += JSOP_NOT_LENGTH;
 64556: 
 64556:     return (*pc != JSOP_IFEQ);
 64556: }
 64556: 
 75501: extern bool
 75501: IsValidBytecodeOffset(JSContext *cx, JSScript *script, size_t offset)
 75501: {
 75501:     // This could be faster (by following jump instructions if the target is <= offset).
 84195:     for (BytecodeRange r(script); !r.empty(); r.popFront()) {
 75501:         size_t here = r.frontOffset();
 75501:         if (here >= offset)
 75501:             return here == offset;
 75501:     }
 75501:     return false;
 75501: }
 75501: 
 84803: JS_FRIEND_API(size_t)
 84803: GetPCCountScriptCount(JSContext *cx)
 84803: {
 84803:     JSRuntime *rt = cx->runtime;
 84803: 
 94574:     if (!rt->scriptAndCountsVector)
 84803:         return 0;
 84803: 
 94574:     return rt->scriptAndCountsVector->length();
 84803: }
 84803: 
 84803: enum MaybeComma {NO_COMMA, COMMA};
 84803: 
 84803: static void
 84803: AppendJSONProperty(StringBuffer &buf, const char *name, MaybeComma comma = COMMA)
 84803: {
 84803:     if (comma)
 84803:         buf.append(',');
 84803: 
 84803:     buf.append('\"');
 84803:     buf.appendInflated(name, strlen(name));
 84803:     buf.appendInflated("\":", 2);
 84803: }
 84803: 
 84803: static void
 84803: AppendArrayJSONProperties(JSContext *cx, StringBuffer &buf,
 84803:                           double *values, const char **names, unsigned count, MaybeComma &comma)
 84803: {
 84803:     for (unsigned i = 0; i < count; i++) {
 84803:         if (values[i]) {
 84803:             AppendJSONProperty(buf, names[i], comma);
 84803:             comma = COMMA;
 84803:             NumberValueToStringBuffer(cx, DoubleValue(values[i]), buf);
 84803:         }
 84803:     }
 84803: }
 84803: 
 84803: JS_FRIEND_API(JSString *)
 84803: GetPCCountScriptSummary(JSContext *cx, size_t index)
 84803: {
 84803:     JSRuntime *rt = cx->runtime;
 84803: 
 94574:     if (!rt->scriptAndCountsVector || index >= rt->scriptAndCountsVector->length()) {
 84803:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BUFFER_TOO_SMALL);
 84803:         return NULL;
 84803:     }
 84803: 
 95113:     ScriptAndCounts sac = (*rt->scriptAndCountsVector)[index];
 95113:     JSScript *script = sac.script;
 84803: 
 84803:     /*
 84803:      * OOM on buffer appends here will not be caught immediately, but since
 84803:      * StringBuffer uses a ContextAllocPolicy will trigger an exception on the
 84803:      * context if they occur, which we'll catch before returning.
 84803:      */
 84803:     StringBuffer buf(cx);
 84803: 
 84803:     buf.append('{');
 84803: 
 84803:     AppendJSONProperty(buf, "file", NO_COMMA);
 84803:     JSString *str = JS_NewStringCopyZ(cx, script->filename);
 84803:     if (!str || !(str = JS_ValueToSource(cx, StringValue(str))))
 84803:         return NULL;
 84803:     buf.append(str);
 84803: 
 84803:     AppendJSONProperty(buf, "line");
 84803:     NumberValueToStringBuffer(cx, Int32Value(script->lineno), buf);
 84803: 
 84803:     if (script->function()) {
 84803:         JSAtom *atom = script->function()->atom;
 84803:         if (atom) {
 84803:             AppendJSONProperty(buf, "name");
 84803:             if (!(str = JS_ValueToSource(cx, StringValue(atom))))
 84803:                 return NULL;
 84803:             buf.append(str);
 84803:         }
 84803:     }
 84803: 
 94574:     double baseTotals[PCCounts::BASE_LIMIT] = {0.0};
 94574:     double accessTotals[PCCounts::ACCESS_LIMIT - PCCounts::BASE_LIMIT] = {0.0};
 94574:     double elementTotals[PCCounts::ELEM_LIMIT - PCCounts::ACCESS_LIMIT] = {0.0};
 94574:     double propertyTotals[PCCounts::PROP_LIMIT - PCCounts::ACCESS_LIMIT] = {0.0};
 94574:     double arithTotals[PCCounts::ARITH_LIMIT - PCCounts::BASE_LIMIT] = {0.0};
 84803: 
 84803:     for (unsigned i = 0; i < script->length; i++) {
 95113:         PCCounts &counts = sac.getPCCounts(script->code + i);
 84803:         if (!counts)
 84803:             continue;
 84803: 
 84803:         JSOp op = (JSOp)script->code[i];
 94574:         unsigned numCounts = PCCounts::numCounts(op);
 84803: 
 84803:         for (unsigned j = 0; j < numCounts; j++) {
 84803:             double value = counts.get(j);
 94574:             if (j < PCCounts::BASE_LIMIT) {
 84803:                 baseTotals[j] += value;
 94574:             } else if (PCCounts::accessOp(op)) {
 94574:                 if (j < PCCounts::ACCESS_LIMIT)
 94574:                     accessTotals[j - PCCounts::BASE_LIMIT] += value;
 94574:                 else if (PCCounts::elementOp(op))
 94574:                     elementTotals[j - PCCounts::ACCESS_LIMIT] += value;
 94574:                 else if (PCCounts::propertyOp(op))
 94574:                     propertyTotals[j - PCCounts::ACCESS_LIMIT] += value;
 84803:                 else
 84803:                     JS_NOT_REACHED("Bad opcode");
 94574:             } else if (PCCounts::arithOp(op)) {
 94574:                 arithTotals[j - PCCounts::BASE_LIMIT] += value;
 84803:             } else {
 84803:                 JS_NOT_REACHED("Bad opcode");
 84803:             }
 84803:         }
 84803:     }
 84803: 
 84803:     AppendJSONProperty(buf, "totals");
 84803:     buf.append('{');
 84803: 
 84803:     MaybeComma comma = NO_COMMA;
 84803: 
 84803:     AppendArrayJSONProperties(cx, buf, baseTotals, countBaseNames,
 84803:                               JS_ARRAY_LENGTH(baseTotals), comma);
 84803:     AppendArrayJSONProperties(cx, buf, accessTotals, countAccessNames,
 84803:                               JS_ARRAY_LENGTH(accessTotals), comma);
 84803:     AppendArrayJSONProperties(cx, buf, elementTotals, countElementNames,
 84803:                               JS_ARRAY_LENGTH(elementTotals), comma);
 84803:     AppendArrayJSONProperties(cx, buf, propertyTotals, countPropertyNames,
 84803:                               JS_ARRAY_LENGTH(propertyTotals), comma);
 84803:     AppendArrayJSONProperties(cx, buf, arithTotals, countArithNames,
 84803:                               JS_ARRAY_LENGTH(arithTotals), comma);
 84803: 
 84803:     buf.append('}');
 84803:     buf.append('}');
 84803: 
 84803:     if (cx->isExceptionPending())
 84803:         return NULL;
 84803: 
 84803:     return buf.finishString();
 84803: }
 84803: 
 84803: struct AutoDestroyPrinter
 84803: {
 84803:     JSPrinter *jp;
 84803:     AutoDestroyPrinter(JSPrinter *jp) : jp(jp) {}
 84803:     ~AutoDestroyPrinter() { js_DestroyPrinter(jp); }
 84803: };
 84803: 
 84803: static bool
 95113: GetPCCountJSON(JSContext *cx, const ScriptAndCounts &sac, StringBuffer &buf)
 84803: {
 95113:     JSScript *script = sac.script;
 84803: 
 84803:     buf.append('{');
 84803:     AppendJSONProperty(buf, "text", NO_COMMA);
 84803: 
 84803:     Vector<DecompiledOpcode> decompiledOpcodes(cx);
 84803:     if (!decompiledOpcodes.reserve(script->length))
 84803:         return false;
 84803: 
 84803:     for (unsigned i = 0; i < script->length; i++)
 84803:         decompiledOpcodes.infallibleAppend(DecompiledOpcode());
 84803: 
 84803:     JSFunction *fun = script->function();
 84803:     JSPrinter *jp = js_NewPrinter(cx, "", fun, 4, true, false, false);
 84803:     if (!jp)
 84803:         return false;
 84803:     AutoDestroyPrinter destroy(jp);
 84803: 
 84803:     jp->decompiledOpcodes = &decompiledOpcodes;
 84803: 
 84803:     if (fun) {
 84803:         if (!js_DecompileFunction(jp))
 84803:             return false;
 84803:     } else {
 84803:         if (!js_DecompileScript(jp, script))
 84803:             return false;
 84803:     }
 84803:     JSString *str = js_GetPrinterOutput(jp);
 84803:     if (!str || !(str = JS_ValueToSource(cx, StringValue(str))))
 84803:         return false;
 84803: 
 84803:     buf.append(str);
 84803: 
 84803:     AppendJSONProperty(buf, "opcodes");
 84803:     buf.append('[');
 84803:     bool comma = false;
 84803: 
 84803:     SrcNoteLineScanner scanner(script->notes(), script->lineno);
 84803: 
 84803:     for (jsbytecode *pc = script->code;
 84803:          pc < script->code + script->length;
 84803:          pc += GetBytecodeLength(pc))
 84803:     {
 84803:         size_t offset = pc - script->code;
 84803: 
 84803:         JSOp op = (JSOp) *pc;
 84803: 
 84803:         if (comma)
 84803:             buf.append(',');
 84803:         comma = true;
 84803: 
 84803:         buf.append('{');
 84803: 
 84803:         AppendJSONProperty(buf, "id", NO_COMMA);
 84803:         NumberValueToStringBuffer(cx, Int32Value(pc - script->code), buf);
 84803: 
 84803:         scanner.advanceTo(offset);
 84803: 
 84803:         AppendJSONProperty(buf, "line");
 84803:         NumberValueToStringBuffer(cx, Int32Value(scanner.getLine()), buf);
 84803: 
 84803:         {
 84803:             const char *name = js_CodeName[op];
 84803:             AppendJSONProperty(buf, "name");
 84803:             buf.append('\"');
 84803:             buf.appendInflated(name, strlen(name));
 84803:             buf.append('\"');
 84803:         }
 84803: 
 84803:         DecompiledOpcode *search = &decompiledOpcodes[offset];
 84803:         size_t textBias = 0;
 84803:         while (search->parent) {
 84803:             textBias += search->parentOffset;
 84803:             if (search->parenthesized)
 84803:                 textBias++;
 84803:             search = &decompiledOpcodes[search->parent - script->code];
 84803:         }
 84803: 
 84807:         int32_t printedOffset = search->parentOffset;
 84803:         if (printedOffset != -1) {
 84803:             printedOffset += textBias;
 84803:             if (search->parenthesized)
 84803:                 printedOffset++;
 84803:             AppendJSONProperty(buf, "textOffset");
 84803:             NumberValueToStringBuffer(cx, Int32Value(printedOffset), buf);
 84803:         }
 84803: 
 84803:         const char *text = decompiledOpcodes[offset].text;
 84803:         if (text && *text != 0) {
 84803:             AppendJSONProperty(buf, "text");
 84803:             JSString *str = JS_NewStringCopyZ(cx, text);
 84803:             if (!str || !(str = JS_ValueToSource(cx, StringValue(str))))
 84803:                 return false;
 84803:             buf.append(str);
 84803:         }
 84803: 
 95113:         PCCounts &counts = sac.getPCCounts(pc);
 94574:         unsigned numCounts = PCCounts::numCounts(op);
 84803: 
 84803:         AppendJSONProperty(buf, "counts");
 84803:         buf.append('{');
 84803: 
 84803:         MaybeComma comma = NO_COMMA;
 84803:         for (unsigned i = 0; i < numCounts; i++) {
 84803:             double value = counts.get(i);
 84803:             if (value > 0) {
 94574:                 AppendJSONProperty(buf, PCCounts::countName(op, i), comma);
 84803:                 comma = COMMA;
 84803:                 NumberValueToStringBuffer(cx, DoubleValue(value), buf);
 84803:             }
 84803:         }
 84803: 
 84803:         buf.append('}');
 84803:         buf.append('}');
 84803:     }
 84803: 
 84803:     buf.append(']');
 84803:     buf.append('}');
 84803: 
 84803:     return !cx->isExceptionPending();
 84803: }
 84803: 
 84803: JS_FRIEND_API(JSString *)
 84803: GetPCCountScriptContents(JSContext *cx, size_t index)
 84803: {
 84803:     JSRuntime *rt = cx->runtime;
 84803: 
 94574:     if (!rt->scriptAndCountsVector || index >= rt->scriptAndCountsVector->length()) {
 84803:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BUFFER_TOO_SMALL);
 84803:         return NULL;
 84803:     }
 84803: 
 95113:     const ScriptAndCounts &sac = (*rt->scriptAndCountsVector)[index];
 95113:     JSScript *script = sac.script;
 84803: 
 84803:     StringBuffer buf(cx);
 84803: 
 84803:     if (!script->function() && !script->compileAndGo)
 84803:         return buf.finishString();
 84803: 
 84803:     {
 84803:         JSAutoEnterCompartment ac;
 84803:         if (!ac.enter(cx, script->function() ? (JSObject *) script->function() : script->global()))
 84803:             return NULL;
 84803: 
 95113:         if (!GetPCCountJSON(cx, sac, buf))
 84803:             return NULL;
 84803:     }
 84803: 
 84803:     return buf.finishString();
 84803: }
 84803: 
 64556: } // namespace js
