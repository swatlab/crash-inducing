    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Patrick C. Beard <beard@netscape.com>
    1:  *   Josh Aas <josh@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:   nsPluginsDirDarwin.cpp
    1:   
    1:   Mac OS X implementation of the nsPluginsDir/nsPluginsFile classes.
    1:   
    1:   by Patrick C. Beard.
    1:  */
    1: 
    1: #include "prlink.h"
    1: #include "prnetdb.h"
16668: #include "nsXPCOM.h"
    1: 
    1: #include "nsPluginsDir.h"
19246: #include "nsNPAPIPlugin.h"
    1: #include "nsPluginsDirUtils.h"
    1: 
    1: #include "nsILocalFileMac.h"
    1: 
    1: #include <string.h>
    1: #include <stdio.h>
    1: #include <unistd.h>
    1: #include <fcntl.h>
    1: 
22811: #include <Carbon/Carbon.h>
    1: #include <CoreServices/CoreServices.h>
    1: #include <mach-o/loader.h>
    1: #include <mach-o/fat.h>
    1: 
19246: typedef NS_NPAPIPLUGIN_CALLBACK(const char *, NP_GETMIMEDESCRIPTION) ();
19246: typedef NS_NPAPIPLUGIN_CALLBACK(OSErr, BP_GETSUPPORTEDMIMETYPES) (BPSupportedMIMETypes *mimeInfo, UInt32 flags);
    1: 
    1: 
    1: /*
27323: ** Returns a CFBundleRef if the path refers to a Mac OS X bundle directory.
    1: ** The caller is responsible for calling CFRelease() to deallocate.
    1: */
    1: static CFBundleRef getPluginBundle(const char* path)
    1: {
    1:   CFBundleRef bundle = NULL;
22546:   CFStringRef pathRef = ::CFStringCreateWithCString(NULL, path, kCFStringEncodingUTF8);
    1:   if (pathRef) {
22546:     CFURLRef bundleURL = ::CFURLCreateWithFileSystemPath(NULL, pathRef, kCFURLPOSIXPathStyle, true);
21011:     if (bundleURL) {
22546:       bundle = ::CFBundleCreate(NULL, bundleURL);
22546:       ::CFRelease(bundleURL);
    1:     }
22546:     ::CFRelease(pathRef);
    1:   }
    1:   return bundle;
    1: }
    1: 
    1: static nsresult toCFURLRef(nsIFile* file, CFURLRef& outURL)
    1: {
    1:   nsCOMPtr<nsILocalFileMac> lfm = do_QueryInterface(file);
    1:   if (!lfm)
    1:     return NS_ERROR_FAILURE;
    1:   CFURLRef url;
    1:   nsresult rv = lfm->GetCFURL(&url);
    1:   if (NS_SUCCEEDED(rv))
    1:     outURL = url;
    1:   
    1:   return rv;
    1: }
    1: 
    1: PRBool nsPluginsDir::IsPluginFile(nsIFile* file)
    1: {
19014:   nsCString temp;
19014:   file->GetNativeLeafName(temp);
19014:   /*
19014:    * Don't load the VDP fake plugin, to avoid tripping a bad bug in OS X
19014:    * 10.5.3 (see bug 436575).
19014:    */
19014:   if (!strcmp(temp.get(), "VerifiedDownloadPlugin.plugin")) {
19014:     NS_WARNING("Preventing load of VerifiedDownloadPlugin.plugin (see bug 436575)");
19014:     return PR_FALSE;
19014:   }
19014:     
    1:   CFURLRef pluginURL = NULL;
    1:   if (NS_FAILED(toCFURLRef(file, pluginURL)))
    1:     return PR_FALSE;
    1:   
    1:   PRBool isPluginFile = PR_FALSE;
    1: 
37959:   CFBundleRef pluginBundle = ::CFBundleCreate(kCFAllocatorDefault, pluginURL);
    1:   if (pluginBundle) {
    1:     UInt32 packageType, packageCreator;
37959:     ::CFBundleGetPackageInfo(pluginBundle, &packageType, &packageCreator);
    1:     if (packageType == 'BRPL' || packageType == 'IEPL' || packageType == 'NSPL') {
37959:       isPluginFile = !!::CFBundlePreflightExecutable(pluginBundle, NULL);
    1:     }
22546:     ::CFRelease(pluginBundle);
    1:   }
    1: 
22546:   ::CFRelease(pluginURL);
    1:   return isPluginFile;
    1: }
    1: 
16668: // Caller is responsible for freeing returned buffer.
16668: static char* CFStringRefToUTF8Buffer(CFStringRef cfString)
16668: {
16668:   int bufferLength = ::CFStringGetLength(cfString) + 1;
16668:   char* newBuffer = static_cast<char*>(NS_Alloc(bufferLength));
21011:   if (newBuffer && !::CFStringGetCString(cfString, newBuffer, bufferLength, kCFStringEncodingUTF8)) {
16668:     NS_Free(newBuffer);
16668:     newBuffer = nsnull;
16668:   }
16668:   return newBuffer;
16668: }
16668: 
16668: static void ParsePlistPluginInfo(nsPluginInfo& info, CFBundleRef bundle)
16668: {
16668:   CFTypeRef mimeDict = ::CFBundleGetValueForInfoDictionaryKey(bundle, CFSTR("WebPluginMIMETypes"));
16668:   if (mimeDict && ::CFGetTypeID(mimeDict) == ::CFDictionaryGetTypeID() && ::CFDictionaryGetCount(static_cast<CFDictionaryRef>(mimeDict)) > 0) {
16668:     int mimeDictKeyCount = ::CFDictionaryGetCount(static_cast<CFDictionaryRef>(mimeDict));
16668: 
16668:     // Allocate memory for mime data
16668:     int mimeDataArraySize = mimeDictKeyCount * sizeof(char*);
16668:     info.fMimeTypeArray = static_cast<char**>(NS_Alloc(mimeDataArraySize));
16668:     if (!info.fMimeTypeArray)
16668:       return;
16668:     memset(info.fMimeTypeArray, 0, mimeDataArraySize);
16668:     info.fExtensionArray = static_cast<char**>(NS_Alloc(mimeDataArraySize));
16668:     if (!info.fExtensionArray)
16668:       return;
16668:     memset(info.fExtensionArray, 0, mimeDataArraySize);
16668:     info.fMimeDescriptionArray = static_cast<char**>(NS_Alloc(mimeDataArraySize));
16668:     if (!info.fMimeDescriptionArray)
16668:       return;
16668:     memset(info.fMimeDescriptionArray, 0, mimeDataArraySize);
16668: 
16668:     // Allocate memory for mime dictionary keys and values
16668:     nsAutoArrayPtr<CFTypeRef> keys(new CFTypeRef[mimeDictKeyCount]);
16668:     if (!keys)
16668:       return;
16668:     nsAutoArrayPtr<CFTypeRef> values(new CFTypeRef[mimeDictKeyCount]);
16668:     if (!values)
16668:       return;
16668: 
16668:     // Set the variant count now that we have safely allocated memory
16668:     info.fVariantCount = mimeDictKeyCount;
16668: 
16668:     ::CFDictionaryGetKeysAndValues(static_cast<CFDictionaryRef>(mimeDict), keys, values);
16668:     for (int i = 0; i < mimeDictKeyCount; i++) {
16668:       CFTypeRef mimeString = keys[i];
16668:       if (mimeString && ::CFGetTypeID(mimeString) == ::CFStringGetTypeID()) {
16668:         info.fMimeTypeArray[i] = CFStringRefToUTF8Buffer(static_cast<CFStringRef>(mimeString));
16668:       }
16668:       else {
16668:         info.fVariantCount -= 1;
16668:         continue;
16668:       }
16668:       CFTypeRef mimeDict = values[i];
16668:       if (mimeDict && ::CFGetTypeID(mimeDict) == ::CFDictionaryGetTypeID()) {
16668:         CFTypeRef extensions = ::CFDictionaryGetValue(static_cast<CFDictionaryRef>(mimeDict), CFSTR("WebPluginExtensions"));
16668:         if (extensions && ::CFGetTypeID(extensions) == ::CFArrayGetTypeID()) {
16668:           int extensionCount = ::CFArrayGetCount(static_cast<CFArrayRef>(extensions));
16668:           CFMutableStringRef extensionList = ::CFStringCreateMutable(kCFAllocatorDefault, 0);
16668:           for (int j = 0; j < extensionCount; j++) {
16668:             CFTypeRef extension = ::CFArrayGetValueAtIndex(static_cast<CFArrayRef>(extensions), j);
16668:             if (extension && ::CFGetTypeID(extension) == ::CFStringGetTypeID()) {
16668:               if (j > 0)
16668:                 ::CFStringAppend(extensionList, CFSTR(","));
16668:               ::CFStringAppend(static_cast<CFMutableStringRef>(extensionList), static_cast<CFStringRef>(extension));
16668:             }
16668:           }
16668:           info.fExtensionArray[i] = CFStringRefToUTF8Buffer(static_cast<CFStringRef>(extensionList));
16668:           ::CFRelease(extensionList);
16668:         }
16668:         CFTypeRef description = ::CFDictionaryGetValue(static_cast<CFDictionaryRef>(mimeDict), CFSTR("WebPluginTypeDescription"));
16668:         if (description && ::CFGetTypeID(description) == ::CFStringGetTypeID())
16668:           info.fMimeDescriptionArray[i] = CFStringRefToUTF8Buffer(static_cast<CFStringRef>(description));
16668:       }
16668:     }
16668:   }
16668: }
16668: 
    1: nsPluginFile::nsPluginFile(nsIFile *spec)
    1:     : mPlugin(spec)
    1: {
    1: }
    1: 
    1: nsPluginFile::~nsPluginFile() {}
    1: 
    1: nsresult nsPluginFile::LoadPlugin(PRLibrary* &outLibrary)
    1: {
    1:   if (!mPlugin)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
48021:   // 64-bit NSPR does not (yet) support bundles.  So in 64-bit builds we need
48021:   // (for now) to load the bundle's executable.  However this can cause
48021:   // problems:  CFBundleCreate() doesn't run the bundle's executable's
48021:   // initialization code, while NSAddImage() and dlopen() do run it.  So using
48021:   // NSPR's dyld loading mechanisms here (NSAddImage() or dlopen()) can cause
48021:   // a bundle's initialization code to run earlier than expected, and lead to
48021:   // crashes.  See bug 577967.
48021: #ifdef __LP64__
37985:   char executablePath[PATH_MAX];
37985:   executablePath[0] = '\0';
37985:   nsCAutoString bundlePath;
37985:   mPlugin->GetNativePath(bundlePath);
37985:   CFStringRef pathRef = ::CFStringCreateWithCString(NULL, bundlePath.get(), kCFStringEncodingUTF8);
37985:   if (pathRef) {
37985:     CFURLRef bundleURL = ::CFURLCreateWithFileSystemPath(NULL, pathRef, kCFURLPOSIXPathStyle, true);
37985:     if (bundleURL) {
37985:       CFBundleRef bundle = ::CFBundleCreate(NULL, bundleURL);
37985:       if (bundle) {
37985:         CFURLRef executableURL = ::CFBundleCopyExecutableURL(bundle);
37985:         if (executableURL) {
37985:           if (!::CFURLGetFileSystemRepresentation(executableURL, true, (UInt8*)&executablePath, PATH_MAX))
37985:             executablePath[0] = '\0';
37985:           ::CFRelease(executableURL);
37985:         }
37985:         ::CFRelease(bundle);
37985:       }
37985:       ::CFRelease(bundleURL);
37985:     }
37985:     ::CFRelease(pathRef); 
37985:   }
48021: #else
48021:   nsCAutoString bundlePath;
48021:   mPlugin->GetNativePath(bundlePath);
48021:   const char *executablePath = bundlePath.get();
48021: #endif
37985: 
37985:   outLibrary = PR_LoadLibrary(executablePath);
    1:   pLibrary = outLibrary;
    1:   if (!outLibrary) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: #ifdef DEBUG
37985:   printf("[loaded plugin %s]\n", bundlePath.get());
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: static char* p2cstrdup(StringPtr pstr)
    1: {
    1:   int len = pstr[0];
21011:   char* cstr = static_cast<char*>(NS_Alloc(len + 1));
21011:   if (cstr) {
27323:     memmove(cstr, pstr + 1, len);
    1:     cstr[len] = '\0';
    1:   }
    1:   return cstr;
    1: }
    1: 
    1: static char* GetNextPluginStringFromHandle(Handle h, short *index)
    1: {
    1:   char *ret = p2cstrdup((unsigned char*)(*h + *index));
    1:   *index += (ret ? PL_strlen(ret) : 0) + 1;
    1:   return ret;
    1: }
    1: 
31406: #ifndef __LP64__
22811: static char* GetPluginString(short id, short index)
22811: {
22811:   Str255 str;
22811:   ::GetIndString(str, id, index);
22811:   return p2cstrdup(str);
22811: }
22811: 
22811: // Opens the resource fork for the plugin
22811: // Also checks if the plugin is a CFBundle and opens gets the correct resource
22811: static short OpenPluginResourceFork(nsIFile *pluginFile)
22811: {
22811:   FSSpec spec;
27323:   nsCOMPtr<nsILocalFileMac> lfm = do_QueryInterface(pluginFile);
27323:   if (!lfm || NS_FAILED(lfm->GetFSSpec(&spec)))
27323:     return -1;
27323: 
22811:   Boolean targetIsFolder, wasAliased;
27323:   ::ResolveAliasFile(&spec, true, &targetIsFolder, &wasAliased);
22811:   short refNum = ::FSpOpenResFile(&spec, fsRdPerm);
22811:   if (refNum < 0) {
22811:     nsCString path;
22811:     pluginFile->GetNativePath(path);
22811:     CFBundleRef bundle = getPluginBundle(path.get());
22811:     if (bundle) {
22811:       refNum = CFBundleOpenBundleResourceMap(bundle);
22811:       ::CFRelease(bundle);
22811:     }
22811:   }
22811:   return refNum;
22811: }
22811: 
22811: short nsPluginFile::OpenPluginResource()
22811: {
22811:   return OpenPluginResourceFork(mPlugin);
22811: }
22811: 
22811: class nsAutoCloseResourceObject {
22811: public:
22811:   nsAutoCloseResourceObject(nsIFile *pluginFile)
22811:   {
22811:     mRefNum = OpenPluginResourceFork(pluginFile);
22811:   }
22811:   ~nsAutoCloseResourceObject()
22811:   {
22811:     if (mRefNum > 0)
22811:       ::CloseResFile(mRefNum);
22811:   }
22811:   PRBool ResourceOpened()
22811:   {
22811:     return (mRefNum > 0);
22811:   }
22811: private:
22811:   short mRefNum;
22811: };
31406: #endif
22811: 
22811: /**
22811:  * Obtains all of the information currently available for this plugin.
22811:  */
    1: nsresult nsPluginFile::GetPluginInfo(nsPluginInfo& info)
    1: {
27323:   nsresult rv = NS_OK;
27323: 
    1:   // clear out the info, except for the first field.
22547:   memset(&info, 0, sizeof(info));
    1: 
22811:   // First open up resource we can use to get plugin info.
22811: 
31406: #ifndef __LP64__
22811:   // Try to open a resource fork.
22811:   nsAutoCloseResourceObject resourceObject(mPlugin);
22811:   bool resourceOpened = resourceObject.ResourceOpened();
31406: #endif
31406: 
16668:   // Try to get a bundle reference.
27323:   nsCAutoString path;
27323:   if (NS_FAILED(rv = mPlugin->GetNativePath(path)))
27323:     return rv;
16668:   CFBundleRef bundle = getPluginBundle(path.get());
22811: 
27323:   // fill in full path
27323:   info.fFullPath = PL_strdup(path.get());
27323: 
27323:   // fill in file name
27323:   nsCAutoString fileName;
27323:   if (NS_FAILED(rv = mPlugin->GetNativeLeafName(fileName)))
27323:     return rv;
27323:   info.fFileName = PL_strdup(fileName.get());
27323: 
22811:   // Get fBundle
22811:   if (bundle)
22811:     info.fBundle = PR_TRUE;
16668: 
16668:   // Get fName
16668:   if (bundle) {
16668:     CFTypeRef name = ::CFBundleGetValueForInfoDictionaryKey(bundle, CFSTR("WebPluginName"));
16668:     if (name && ::CFGetTypeID(name) == ::CFStringGetTypeID())
16668:       info.fName = CFStringRefToUTF8Buffer(static_cast<CFStringRef>(name));
16668:   }
31406: #ifndef __LP64__
22811:   if (!info.fName && resourceOpened) {
22811:     // 'STR#', 126, 2 => plugin name.
22811:     info.fName = GetPluginString(126, 2);
22811:   }
31406: #endif
    1: 
16668:   // Get fDescription
16668:   if (bundle) {
16668:     CFTypeRef description = ::CFBundleGetValueForInfoDictionaryKey(bundle, CFSTR("WebPluginDescription"));
16668:     if (description && ::CFGetTypeID(description) == ::CFStringGetTypeID())
16668:       info.fDescription = CFStringRefToUTF8Buffer(static_cast<CFStringRef>(description));
16668:   }
31406: #ifndef __LP64__
22811:   if (!info.fDescription && resourceOpened) {
22811:     // 'STR#', 126, 1 => plugin description.
22811:     info.fDescription = GetPluginString(126, 1);
22811:   }
31406: #endif
    1: 
16668:   // Get fVersion
    1:   if (bundle) {
15947:     // Look for the release version first
16668:     CFTypeRef version = ::CFBundleGetValueForInfoDictionaryKey(bundle, CFSTR("CFBundleShortVersionString"));
16668:     if (!version) // try the build version
16668:       version = ::CFBundleGetValueForInfoDictionaryKey(bundle, kCFBundleVersionKey);
16668:     if (version && ::CFGetTypeID(version) == ::CFStringGetTypeID())
16668:       info.fVersion = CFStringRefToUTF8Buffer(static_cast<CFStringRef>(version));
    1:   }
    1: 
16668:   // The last thing we need to do is get MIME data
16668:   // fVariantCount, fMimeTypeArray, fExtensionArray, fMimeDescriptionArray
16668: 
16668:   // First look for data in a bundle plist
16668:   if (bundle) {
16668:     ParsePlistPluginInfo(info, bundle);
16668:     ::CFRelease(bundle);
16668:     if (info.fVariantCount > 0)
16668:       return NS_OK;    
    1:   }
    1: 
16668:   // It's possible that our plugin has 2 entry points that'll give us mime type
16668:   // info. Quicktime does this to get around the need of having admin rights to
16668:   // change mime info in the resource fork. We need to use this info instead of
16668:   // the resource. See bug 113464.
16668: 
16668:   // Try to get data from NP_GetMIMEDescription
16668:   if (pLibrary) {
16668:     NP_GETMIMEDESCRIPTION pfnGetMimeDesc = (NP_GETMIMEDESCRIPTION)PR_FindFunctionSymbol(pLibrary, NP_GETMIMEDESCRIPTION_NAME); 
16668:     if (pfnGetMimeDesc)
16668:       ParsePluginMimeDescription(pfnGetMimeDesc(), info);
16668:     if (info.fVariantCount)
16668:       return NS_OK;
16668:   }
16668: 
16668:   // We'll fill this in using BP_GetSupportedMIMETypes and/or resource fork data
16668:   BPSupportedMIMETypes mi = {kBPSupportedMIMETypesStructVers_1, NULL, NULL};
16668: 
16668:   // Try to get data from BP_GetSupportedMIMETypes
16668:   if (pLibrary) {
16668:     BP_GETSUPPORTEDMIMETYPES pfnMime = (BP_GETSUPPORTEDMIMETYPES)PR_FindFunctionSymbol(pLibrary, "BP_GetSupportedMIMETypes");
    1:     if (pfnMime && noErr == pfnMime(&mi, 0) && mi.typeStrings) {
    1:       info.fVariantCount = (**(short**)mi.typeStrings) / 2;
    1:       ::HLock(mi.typeStrings);
    1:       if (mi.infoStrings)  // it's possible some plugins have infoStrings missing
    1:         ::HLock(mi.infoStrings);
    1:     }
    1:   }
    1: 
31406: #ifndef __LP64__
22811:   // Try to get data from the resource fork
22811:   if (!info.fVariantCount && resourceObject.ResourceOpened()) {
22811:     mi.typeStrings = ::Get1Resource('STR#', 128);
22811:     if (mi.typeStrings) {
22811:       info.fVariantCount = (**(short**)mi.typeStrings) / 2;
22811:       ::DetachResource(mi.typeStrings);
22811:       ::HLock(mi.typeStrings);
22811:     } else {
22811:       // Don't add this plugin because no mime types could be found
    1:       return NS_ERROR_FAILURE;
22811:     }
22811:     
22811:     mi.infoStrings = ::Get1Resource('STR#', 127);
22811:     if (mi.infoStrings) {
22811:       ::DetachResource(mi.infoStrings);
22811:       ::HLock(mi.infoStrings);
22811:     }
22811:   }
31406: #endif
    1: 
16668:   // Fill in the info struct based on the data in the BPSupportedMIMETypes struct
    1:   int variantCount = info.fVariantCount;
21011:   info.fMimeTypeArray = static_cast<char**>(NS_Alloc(variantCount * sizeof(char*)));
21011:   if (!info.fMimeTypeArray)
21011:     return NS_ERROR_OUT_OF_MEMORY;
21011:   info.fExtensionArray = static_cast<char**>(NS_Alloc(variantCount * sizeof(char*)));
21011:   if (!info.fExtensionArray)
21011:     return NS_ERROR_OUT_OF_MEMORY;
21011:   if (mi.infoStrings) {
21011:     info.fMimeDescriptionArray = static_cast<char**>(NS_Alloc(variantCount * sizeof(char*)));
21011:     if (!info.fMimeDescriptionArray)
21011:       return NS_ERROR_OUT_OF_MEMORY;
21011:   }
21011:   short mimeIndex = 2;
21011:   short descriptionIndex = 2;
    1:   for (int i = 0; i < variantCount; i++) {
    1:     info.fMimeTypeArray[i] = GetNextPluginStringFromHandle(mi.typeStrings, &mimeIndex);
    1:     info.fExtensionArray[i] = GetNextPluginStringFromHandle(mi.typeStrings, &mimeIndex);
    1:     if (mi.infoStrings)
    1:       info.fMimeDescriptionArray[i] = GetNextPluginStringFromHandle(mi.infoStrings, &descriptionIndex);
    1:   }
    1: 
    1:   ::HUnlock(mi.typeStrings);
    1:   ::DisposeHandle(mi.typeStrings);
    1:   if (mi.infoStrings) {
    1:     ::HUnlock(mi.infoStrings);
    1:     ::DisposeHandle(mi.infoStrings);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginFile::FreePluginInfo(nsPluginInfo& info)
    1: {
21011:   NS_Free(info.fName);
21011:   NS_Free(info.fDescription);
    1:   int variantCount = info.fVariantCount;
    1:   for (int i = 0; i < variantCount; i++) {
21011:     NS_Free(info.fMimeTypeArray[i]);
21011:     NS_Free(info.fExtensionArray[i]);
21011:     NS_Free(info.fMimeDescriptionArray[i]);
    1:   }
21011:   NS_Free(info.fMimeTypeArray);
21011:   NS_Free(info.fMimeDescriptionArray);
21011:   NS_Free(info.fExtensionArray);
21011:   NS_Free(info.fFileName);
21011:   NS_Free(info.fFullPath);
21011:   NS_Free(info.fVersion);
    1: 
    1:   return NS_OK;
    1: }
