29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18084:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS parser.
    1:  *
    1:  * This is a recursive-descent parser for the JavaScript language specified by
    1:  * "The JavaScript 1.5 Language Specification".  It uses lexical and semantic
    1:  * feedback to disambiguate non-LL(1) structures.  It generates trees of nodes
80634:  * induced by the recursive parsing (not precise syntax trees, see Parser.h).
    1:  * After tree construction, it rewrites trees to fold constants and evaluate
80634:  * compile-time expressions.  Finally, it calls js::frontend::EmitTree (see
80964:  * BytecodeEmitter.h) to generate bytecode.
    1:  *
    1:  * This parser attempts no error recovery.
    1:  */
80507: 
80507: #include "frontend/Parser.h"
80507: 
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsfun.h"
68933: #include "jsgc.h"
68933: #include "jsgcmark.h"
    1: #include "jsinterp.h"
15613: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
80507: 
80507: #include "frontend/BytecodeCompiler.h"
80964: #include "frontend/BytecodeEmitter.h"
80507: #include "frontend/FoldConstants.h"
80507: #include "frontend/ParseMaps.h"
80506: #include "frontend/TokenStream.h"
80506: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: #include "jsdhash.h"
    1: #endif
    1: 
48470: #include "jsatominlines.h"
52802: #include "jsobjinlines.h"
59968: #include "jsscriptinlines.h"
50491: 
72579: #include "frontend/ParseMaps-inl.h"
80507: #include "frontend/ParseNode-inl.h"
79981: #include "vm/RegExpObject-inl.h"
48470: 
40221: using namespace js;
54707: using namespace js::gc;
80632: using namespace js::frontend;
40221: 
    1: /*
    1:  * Insist that the next token be of type tt, or report errno and return null.
    1:  * NB: this macro uses cx and ts from its lexical environment.
    1:  */
40854: #define MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, __flags)                                     \
    1:     JS_BEGIN_MACRO                                                                          \
40854:         if (tokenStream.getToken((__flags)) != tt) {                                        \
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, errno);                                 \
    1:             return NULL;                                                                    \
    1:         }                                                                                   \
    1:     JS_END_MACRO
40854: #define MUST_MATCH_TOKEN(tt, errno) MUST_MATCH_TOKEN_WITH_FLAGS(tt, errno, 0)
    1: 
72098: Parser::Parser(JSContext *cx, JSPrincipals *prin, StackFrame *cfp, bool foldConstants)
80748:   : AutoGCRooter(cx, PARSER),
53840:     context(cx),
53840:     tokenStream(cx),
53840:     principals(NULL),
53840:     callerFrame(cfp),
71694:     callerVarObj(cfp ? &cfp->varObj() : NULL),
80641:     allocator(cx),
53840:     functionCount(0),
53840:     traceListHead(NULL),
53840:     tc(NULL),
72098:     keepAtoms(cx->runtime),
72098:     foldConstants(foldConstants)
53840: {
72579:     cx->activeCompilations++;
80631:     PodArrayZero(tempFreeList);
53840:     setPrincipals(prin);
53840:     JS_ASSERT_IF(cfp, cfp->isScriptFrame());
53840: }
53840: 
27012: bool
61450: Parser::init(const jschar *base, size_t length, const char *filename, uintN lineno,
61450:              JSVersion version)
 3235: {
27012:     JSContext *cx = context;
72579:     if (!cx->ensureParseMapPool())
72579:         return false;
79410:     tempPoolMark = cx->tempLifoAlloc().mark();
61450:     if (!tokenStream.init(base, length, filename, lineno, version)) {
79410:         cx->tempLifoAlloc().release(tempPoolMark);
27012:         return false;
27012:     }
27012:     return true;
27012: }
27012: 
40860: Parser::~Parser()
27012: {
27012:     JSContext *cx = context;
27012: 
27012:     if (principals)
27012:         JSPRINCIPALS_DROP(cx, principals);
79410:     cx->tempLifoAlloc().release(tempPoolMark);
72579:     cx->activeCompilations--;
26970: }
26970: 
26970: void
40860: Parser::setPrincipals(JSPrincipals *prin)
27012: {
27012:     JS_ASSERT(!principals);
27012:     if (prin)
27012:         JSPRINCIPALS_HOLD(context, prin);
27012:     principals = prin;
27012: }
27012: 
80631: ObjectBox *
40860: Parser::newObjectBox(JSObject *obj)
27012: {
27012:     JS_ASSERT(obj);
 3235: 
 3235:     /*
80743:      * We use JSContext.tempLifoAlloc to allocate parsed objects and place them
80743:      * on a list in this Parser to ensure GC safety. Thus the tempLifoAlloc
80743:      * arenas containing the entries must be alive until we are done with
80743:      * scanning, parsing and code generation for the whole script or top-level
80743:      * function.
 3235:      */
80631:     ObjectBox *objbox = context->tempLifoAlloc().new_<ObjectBox>();
27012:     if (!objbox) {
71371:         js_ReportOutOfMemory(context);
27012:         return NULL;
27012:     }
27012:     objbox->traceLink = traceListHead;
27012:     traceListHead = objbox;
27012:     objbox->emitLink = NULL;
27012:     objbox->object = obj;
59968:     objbox->isFunctionBox = false;
27012:     return objbox;
27012: }
27012: 
80631: FunctionBox *
80631: Parser::newFunctionBox(JSObject *obj, ParseNode *fn, TreeContext *tc)
27012: {
26970:     JS_ASSERT(obj);
40430:     JS_ASSERT(obj->isFunction());
27012: 
27012:     /*
80743:      * We use JSContext.tempLifoAlloc to allocate parsed objects and place them
80743:      * on a list in this Parser to ensure GC safety. Thus the tempLifoAlloc
80743:      * arenas containing the entries must be alive until we are done with
80743:      * scanning, parsing and code generation for the whole script or top-level
80743:      * function.
27012:      */
80631:     FunctionBox *funbox = context->tempLifoAlloc().newPod<FunctionBox>();
27012:     if (!funbox) {
71371:         js_ReportOutOfMemory(context);
27012:         return NULL;
27012:     }
27012:     funbox->traceLink = traceListHead;
27012:     traceListHead = funbox;
27012:     funbox->emitLink = NULL;
27012:     funbox->object = obj;
59968:     funbox->isFunctionBox = true;
27012:     funbox->node = fn;
27012:     funbox->siblings = tc->functionList;
27012:     tc->functionList = funbox;
40860:     ++tc->parser->functionCount;
27012:     funbox->kids = NULL;
27012:     funbox->parent = tc->funbox;
37685:     funbox->methods = NULL;
77343:     new (&funbox->bindings) Bindings(context);
27012:     funbox->queued = false;
28814:     funbox->inLoop = false;
80631:     for (StmtInfo *stmt = tc->topStmt; stmt; stmt = stmt->down) {
28814:         if (STMT_IS_LOOP(stmt)) {
28814:             funbox->inLoop = true;
28814:             break;
28814:         }
28814:     }
27012:     funbox->level = tc->staticLevel;
35113:     funbox->tcflags = (TCF_IN_FUNCTION | (tc->flags & (TCF_COMPILE_N_GO | TCF_STRICT_MODE_CODE)));
61210:     if (tc->innermostWith)
61210:         funbox->tcflags |= TCF_IN_WITH;
27012:     return funbox;
27012: }
26970: 
26970: void
40860: Parser::trace(JSTracer *trc)
27012: {
80631:     ObjectBox *objbox = traceListHead;
27012:     while (objbox) {
54707:         MarkObject(trc, *objbox->object, "parser.object");
59968:         if (objbox->isFunctionBox)
80631:             static_cast<FunctionBox *>(objbox)->bindings.trace(trc);
27012:         objbox = objbox->traceLink;
27012:     }
59968: 
80631:     for (TreeContext *tc = this->tc; tc; tc = tc->parent)
59968:         tc->trace(trc);
27012: }
27012: 
27012: static bool
80631: GenerateBlockIdForStmtNode(ParseNode *pn, TreeContext *tc)
27012: {
27012:     JS_ASSERT(tc->topStmt);
27012:     JS_ASSERT(STMT_MAYBE_SCOPE(tc->topStmt));
82024:     JS_ASSERT(pn->isKind(PNK_LC) || pn->isKind(PNK_LEXICALSCOPE));
27012:     if (!GenerateBlockId(tc, tc->topStmt->blockid))
27012:         return false;
27012:     pn->pn_blockid = tc->topStmt->blockid;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Parse a top-level JS script.
    1:  */
80631: ParseNode *
40860: Parser::parse(JSObject *chain)
27012: {
    1:     /*
    1:      * Protect atoms from being collected by a GC activation, which might
    1:      * - nest on this thread due to out of memory (the so-called "last ditch"
    1:      *   GC attempted within js_NewGCThing), or
    1:      * - run for any reason on another thread if this thread is suspended on
    1:      *   an object lock before it finishes generating bytecode into a script
    1:      *   protected from the GC by a root or a stack frame reference.
    1:      */
80631:     TreeContext globaltc(this);
72579:     if (!globaltc.init(context))
72579:         return NULL;
57829:     globaltc.setScopeChain(chain);
40263:     if (!GenerateBlockId(&globaltc, globaltc.bodyid))
40263:         return NULL;
40263: 
80631:     ParseNode *pn = statements();
    1:     if (pn) {
40354:         if (!tokenStream.matchToken(TOK_EOF)) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:             pn = NULL;
72098:         } else if (foldConstants) {
80631:             if (!FoldConstants(context, pn, &globaltc))
    1:                 pn = NULL;
    1:         }
    1:     }
    1:     return pn;
    1: }
    1: 
47573: JS_STATIC_ASSERT(UpvarCookie::FREE_LEVEL == JS_BITMASK(JSFB_LEVEL_BITS));
28814: 
    1: /*
    1:  * Insist on a final return before control flows out of pn.  Try to be a bit
    1:  * smart about loops: do {...; return e2;} while(0) at the end of a function
    1:  * that contains an early return e1 will get a strict warning.  Similarly for
    1:  * iloops: while (true){...} is treated as though ... returns.
    1:  */
    1: #define ENDS_IN_OTHER   0
    1: #define ENDS_IN_RETURN  1
    1: #define ENDS_IN_BREAK   2
    1: 
    1: static int
80631: HasFinalReturn(ParseNode *pn)
80631: {
80631:     ParseNode *pn2, *pn3;
    1:     uintN rv, rv2, hasDefault;
    1: 
78294:     switch (pn->getKind()) {
82024:       case PNK_LC:
    1:         if (!pn->pn_head)
    1:             return ENDS_IN_OTHER;
27012:         return HasFinalReturn(pn->last());
    1: 
82024:       case PNK_IF:
    1:         if (!pn->pn_kid3)
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_kid2) & HasFinalReturn(pn->pn_kid3);
    1: 
82024:       case PNK_WHILE:
    1:         pn2 = pn->pn_left;
82024:         if (pn2->isKind(PNK_TRUE))
    1:             return ENDS_IN_RETURN;
82024:         if (pn2->isKind(PNK_NUMBER) && pn2->pn_dval)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
82024:       case PNK_DO:
    1:         pn2 = pn->pn_right;
82024:         if (pn2->isKind(PNK_FALSE))
    1:             return HasFinalReturn(pn->pn_left);
82024:         if (pn2->isKind(PNK_TRUE))
    1:             return ENDS_IN_RETURN;
82024:         if (pn2->isKind(PNK_NUMBER)) {
    1:             if (pn2->pn_dval == 0)
    1:                 return HasFinalReturn(pn->pn_left);
    1:             return ENDS_IN_RETURN;
    1:         }
    1:         return ENDS_IN_OTHER;
    1: 
82024:       case PNK_FOR:
    1:         pn2 = pn->pn_left;
78294:         if (pn2->isArity(PN_TERNARY) && !pn2->pn_kid2)
    1:             return ENDS_IN_RETURN;
    1:         return ENDS_IN_OTHER;
    1: 
82024:       case PNK_SWITCH:
    1:         rv = ENDS_IN_RETURN;
    1:         hasDefault = ENDS_IN_OTHER;
    1:         pn2 = pn->pn_right;
82024:         if (pn2->isKind(PNK_LEXICALSCOPE))
27012:             pn2 = pn2->expr();
    1:         for (pn2 = pn2->pn_head; rv && pn2; pn2 = pn2->pn_next) {
82024:             if (pn2->isKind(PNK_DEFAULT))
    1:                 hasDefault = ENDS_IN_RETURN;
    1:             pn3 = pn2->pn_right;
82024:             JS_ASSERT(pn3->isKind(PNK_LC));
    1:             if (pn3->pn_head) {
27012:                 rv2 = HasFinalReturn(pn3->last());
    1:                 if (rv2 == ENDS_IN_OTHER && pn2->pn_next)
    1:                     /* Falling through to next case or default. */;
    1:                 else
    1:                     rv &= rv2;
    1:             }
    1:         }
    1:         /* If a final switch has no default case, we judge it harshly. */
    1:         rv &= hasDefault;
    1:         return rv;
    1: 
82024:       case PNK_BREAK:
    1:         return ENDS_IN_BREAK;
    1: 
82024:       case PNK_WITH:
    1:         return HasFinalReturn(pn->pn_right);
    1: 
82024:       case PNK_RETURN:
    1:         return ENDS_IN_RETURN;
    1: 
82024:       case PNK_COLON:
82024:       case PNK_LEXICALSCOPE:
27012:         return HasFinalReturn(pn->expr());
    1: 
82024:       case PNK_THROW:
    1:         return ENDS_IN_RETURN;
    1: 
82024:       case PNK_TRY:
    1:         /* If we have a finally block that returns, we are done. */
    1:         if (pn->pn_kid3) {
    1:             rv = HasFinalReturn(pn->pn_kid3);
    1:             if (rv == ENDS_IN_RETURN)
    1:                 return rv;
    1:         }
    1: 
    1:         /* Else check the try block and any and all catch statements. */
    1:         rv = HasFinalReturn(pn->pn_kid1);
    1:         if (pn->pn_kid2) {
78294:             JS_ASSERT(pn->pn_kid2->isArity(PN_LIST));
    1:             for (pn2 = pn->pn_kid2->pn_head; pn2; pn2 = pn2->pn_next)
    1:                 rv &= HasFinalReturn(pn2);
    1:         }
    1:         return rv;
    1: 
82024:       case PNK_CATCH:
    1:         /* Check this catch block's body. */
    1:         return HasFinalReturn(pn->pn_kid3);
    1: 
82024:       case PNK_LET:
    1:         /* Non-binary let statements are let declarations. */
78294:         if (!pn->isArity(PN_BINARY))
    1:             return ENDS_IN_OTHER;
    1:         return HasFinalReturn(pn->pn_right);
    1: 
    1:       default:
    1:         return ENDS_IN_OTHER;
    1:     }
    1: }
    1: 
    1: static JSBool
80631: ReportBadReturn(JSContext *cx, TreeContext *tc, ParseNode *pn, uintN flags, uintN errnum,
    1:                 uintN anonerrnum)
    1: {
57812:     JSAutoByteString name;
57829:     if (tc->fun()->atom) {
57829:         if (!js_AtomToPrintableString(cx, tc->fun()->atom, &name))
57812:             return false;
    1:     } else {
    1:         errnum = anonerrnum;
57812:     }
64214:     return ReportCompileErrorNumber(cx, TS(tc->parser), pn, flags, errnum, name.ptr());
    1: }
    1: 
    1: static JSBool
80631: CheckFinalReturn(JSContext *cx, TreeContext *tc, ParseNode *pn)
    1: {
41884:     JS_ASSERT(tc->inFunction());
    1:     return HasFinalReturn(pn) == ENDS_IN_RETURN ||
64214:            ReportBadReturn(cx, tc, pn, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                            JSMSG_NO_RETURN_VALUE, JSMSG_ANON_NO_RETURN_VALUE);
    1: }
    1: 
35323: /*
35324:  * Check that it is permitted to assign to lhs.  Strict mode code may not
35324:  * assign to 'eval' or 'arguments'.
35324:  */
80507: static bool
80631: CheckStrictAssignment(JSContext *cx, TreeContext *tc, ParseNode *lhs)
35324: {
82024:     if (tc->needStrictChecks() && lhs->isKind(PNK_NAME)) {
35324:         JSAtom *atom = lhs->pn_atom;
35324:         JSAtomState *atomState = &cx->runtime->atomState;
35324:         if (atom == atomState->evalAtom || atom == atomState->argumentsAtom) {
57812:             JSAutoByteString name;
57812:             if (!js_AtomToPrintableString(cx, atom, &name) ||
40860:                 !ReportStrictModeError(cx, TS(tc->parser), tc, lhs, JSMSG_DEPRECATED_ASSIGN,
57812:                                        name.ptr())) {
35324:                 return false;
35324:             }
35324:         }
35324:     }
35324:     return true;
35324: }
35324: 
35324: /*
62048:  * Check that it is permitted to introduce a binding for atom.  Strict mode
62048:  * forbids introducing new definitions for 'eval', 'arguments', or for any
62048:  * strict mode reserved keyword.  Use pn for reporting error locations, or use
62048:  * tc's token stream if pn is NULL.
35325:  */
35325: bool
80631: CheckStrictBinding(JSContext *cx, TreeContext *tc, PropertyName *name, ParseNode *pn)
35325: {
35325:     if (!tc->needStrictChecks())
35325:         return true;
35325: 
35325:     JSAtomState *atomState = &cx->runtime->atomState;
80442:     if (name == atomState->evalAtom ||
80442:         name == atomState->argumentsAtom ||
80442:         FindKeyword(name->charsZ(), name->length()))
80442:     {
80442:         JSAutoByteString bytes;
80442:         if (!js_AtomToPrintableString(cx, name, &bytes))
35325:             return false;
80442:         return ReportStrictModeError(cx, TS(tc->parser), tc, pn, JSMSG_BAD_BINDING, bytes.ptr());
35325:     }
62048: 
35325:     return true;
35325: }
35325: 
35323: static bool
80631: ReportBadParameter(JSContext *cx, TreeContext *tc, JSAtom *name, uintN errorNumber)
80631: {
80631:     Definition *dn = tc->decls.lookupFirst(name);
62048:     JSAutoByteString bytes;
62048:     return js_AtomToPrintableString(cx, name, &bytes) &&
62048:            ReportStrictModeError(cx, TS(tc->parser), tc, dn, errorNumber, bytes.ptr());
62048: }
62048: 
62048: /*
62048:  * In strict mode code, all parameter names must be distinct, must not be
62048:  * strict mode reserved keywords, and must not be 'eval' or 'arguments'.  We
62048:  * must perform these checks here, and not eagerly during parsing, because a
62048:  * function's body may turn on strict mode for the function head.
62048:  */
80507: bool
80786: js::CheckStrictParameters(JSContext *cx, TreeContext *tc)
62048: {
62048:     JS_ASSERT(tc->inFunction());
62048: 
62048:     if (!tc->needStrictChecks() || tc->bindings.countArgs() == 0)
35323:         return true;
35323: 
62048:     JSAtom *argumentsAtom = cx->runtime->atomState.argumentsAtom;
62048:     JSAtom *evalAtom = cx->runtime->atomState.evalAtom;
62048: 
62063:     /* name => whether we've warned about the name already */
62063:     HashMap<JSAtom *, bool> parameters(cx);
62048:     if (!parameters.init(tc->bindings.countArgs()))
35323:         return false;
62048: 
62048:     /* Start with lastVariable(), not lastArgument(), for destructuring. */
62048:     for (Shape::Range r = tc->bindings.lastVariable(); !r.empty(); r.popFront()) {
69637:         jsid id = r.front().propid;
62048:         if (!JSID_IS_ATOM(id))
62048:             continue;
62048: 
62048:         JSAtom *name = JSID_TO_ATOM(id);
62048: 
62048:         if (name == argumentsAtom || name == evalAtom) {
62048:             if (!ReportBadParameter(cx, tc, name, JSMSG_BAD_BINDING))
35325:                 return false;
35325:         }
62048: 
62048:         if (tc->inStrictMode() && FindKeyword(name->charsZ(), name->length())) {
62048:             /*
62048:              * JSOPTION_STRICT is supposed to warn about future keywords, too,
62048:              * but we took care of that in the scanner.
62048:              */
62048:             JS_ALWAYS_TRUE(!ReportBadParameter(cx, tc, name, JSMSG_RESERVED_ID));
62048:             return false;
62048:         }
62048: 
62063:         /*
62063:          * Check for a duplicate parameter: warn or report an error exactly
62063:          * once for each duplicated parameter.
62063:          */
62063:         if (HashMap<JSAtom *, bool>::AddPtr p = parameters.lookupForAdd(name)) {
62063:             if (!p->value && !ReportBadParameter(cx, tc, name, JSMSG_DUPLICATE_FORMAL))
62048:                 return false;
62063:             p->value = true;
62063:         } else {
62063:             if (!parameters.add(p, name, false))
62048:                 return false;
35325:         }
62063:     }
35323: 
35323:     return true;
35323: }
35323: 
80631: ParseNode *
40860: Parser::functionBody()
    1: {
74286:     JS_ASSERT(tc->inFunction());
74286: 
80631:     StmtInfo stmtInfo;
80632:     PushStatement(tc, &stmtInfo, STMT_BLOCK, -1);
    1:     stmtInfo.flags = SIF_BODY_BLOCK;
    1: 
74286:     uintN oldflags = tc->flags;
    1:     tc->flags &= ~(TCF_RETURN_EXPR | TCF_RETURN_VOID);
    1: 
80631:     ParseNode *pn;
 1967: #if JS_HAS_EXPR_CLOSURES
40270:     if (tokenStream.currentToken().type == TOK_LC) {
40263:         pn = statements();
 1967:     } else {
82024:         pn = UnaryNode::create(PNK_RETURN, tc);
 1967:         if (pn) {
40263:             pn->pn_kid = assignExpr();
 1967:             if (!pn->pn_kid) {
 1967:                 pn = NULL;
 1967:             } else {
 1967:                 if (tc->flags & TCF_FUN_IS_GENERATOR) {
64214:                     ReportBadReturn(context, tc, pn, JSREPORT_ERROR,
 1967:                                     JSMSG_BAD_GENERATOR_RETURN,
 1967:                                     JSMSG_BAD_ANON_GENERATOR_RETURN);
 1967:                     pn = NULL;
 1967:                 } else {
78294:                     pn->setOp(JSOP_RETURN);
 1967:                     pn->pn_pos.end = pn->pn_kid->pn_pos.end;
 1967:                 }
 1967:             }
 1967:         }
 1967:     }
 1967: #else
40263:     pn = statements();
 1967: #endif
    1: 
10299:     if (pn) {
27012:         JS_ASSERT(!(tc->topStmt->flags & SIF_SCOPE));
80632:         PopStatementTC(tc);
    1: 
    1:         /* Check for falling off the end of a function that returns a value. */
61450:         if (context->hasStrictOption() && (tc->flags & TCF_RETURN_EXPR) &&
40239:             !CheckFinalReturn(context, tc, pn)) {
    1:             pn = NULL;
    1:         }
10299:     }
 8444: 
26827:     tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1:     return pn;
    1: }
    1: 
80631: /* Create a placeholder Definition node for |atom|. */
80631: static Definition *
80631: MakePlaceholder(ParseNode *pn, TreeContext *tc)
80631: {
82024:     Definition *dn = (Definition *) NameNode::create(PNK_NAME, pn->pn_atom, tc);
27012:     if (!dn)
27012:         return NULL;
27012: 
78294:     dn->setOp(JSOP_NOP);
78294:     dn->setDefn(true);
28557:     dn->pn_dflags |= PND_PLACEHOLDER;
72579:     return dn;
27012: }
27012: 
27012: static bool
80631: Define(ParseNode *pn, JSAtom *atom, TreeContext *tc, bool let = false)
27012: {
78294:     JS_ASSERT(!pn->isUsed());
78294:     JS_ASSERT_IF(pn->isDefn(), pn->isPlaceholder());
27012: 
72579:     bool foundLexdep = false;
80631:     Definition *dn = NULL;
27012: 
27012:     if (let)
72579:         dn = tc->decls.lookupFirst(atom);
72579: 
72579:     if (!dn) {
72579:         dn = tc->lexdeps.lookupDefn(atom);
72579:         foundLexdep = !!dn;
72579:     }
72579: 
72579:     if (dn && dn != pn) {
80631:         ParseNode **pnup = &dn->dn_uses;
80631:         ParseNode *pnu;
27012:         uintN start = let ? pn->pn_blockid : tc->bodyid;
27012: 
27012:         while ((pnu = *pnup) != NULL && pnu->pn_blockid >= start) {
78294:             JS_ASSERT(pnu->isUsed());
80631:             pnu->pn_lexdef = (Definition *) pn;
30457:             pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
27012:             pnup = &pnu->pn_link;
27012:         }
27012: 
27012:         if (pnu != dn->dn_uses) {
27012:             *pnup = pn->dn_uses;
27012:             pn->dn_uses = dn->dn_uses;
27012:             dn->dn_uses = pnu;
27012: 
72579:             if ((!pnu || pnu->pn_blockid < tc->bodyid) && foundLexdep)
72579:                 tc->lexdeps->remove(atom);
72579:         }
72579:     }
72579: 
80631:     Definition *toAdd = (Definition *) pn;
72579:     bool ok = let ? tc->decls.addShadow(atom, toAdd) : tc->decls.addUnique(atom, toAdd);
72579:     if (!ok)
27012:         return false;
78294:     pn->setDefn(true);
27012:     pn->pn_dflags &= ~PND_PLACEHOLDER;
59228:     if (!tc->parent)
59228:         pn->pn_dflags |= PND_TOPLEVEL;
27012:     return true;
27012: }
27012: 
27012: static void
80631: ForgetUse(ParseNode *pn)
27012: {
78294:     if (!pn->isUsed()) {
78294:         JS_ASSERT(!pn->isDefn());
27012:         return;
27012:     }
27012: 
80631:     ParseNode **pnup = &pn->lexdef()->dn_uses;
80631:     ParseNode *pnu;
27012:     while ((pnu = *pnup) != pn)
27012:         pnup = &pnu->pn_link;
27012:     *pnup = pn->pn_link;
78294:     pn->setUsed(false);
27012: }
27012: 
80631: static ParseNode *
80631: MakeAssignment(ParseNode *pn, ParseNode *rhs, TreeContext *tc)
80631: {
80640:     ParseNode *lhs = tc->parser->new_<ParseNode>(*pn);
27012:     if (!lhs)
27012:         return NULL;
27012: 
78294:     if (pn->isUsed()) {
80631:         Definition *dn = pn->pn_lexdef;
80631:         ParseNode **pnup = &dn->dn_uses;
27012: 
27012:         while (*pnup != pn)
27012:             pnup = &(*pnup)->pn_link;
27012:         *pnup = lhs;
27012:         lhs->pn_link = pn->pn_link;
27012:         pn->pn_link = NULL;
27012:     }
27012: 
82024:     pn->setKind(PNK_ASSIGN);
78294:     pn->setOp(JSOP_NOP);
78294:     pn->setArity(PN_BINARY);
78294:     pn->setInParens(false);
78294:     pn->setUsed(false);
78294:     pn->setDefn(false);
27012:     pn->pn_left = lhs;
27012:     pn->pn_right = rhs;
27012:     return lhs;
27012: }
27012: 
80631: static ParseNode *
80631: MakeDefIntoUse(Definition *dn, ParseNode *pn, JSAtom *atom, TreeContext *tc)
27012: {
27012:     /*
54840:      * If dn is arg, or in [var, const, let] and has an initializer, then we
54840:      * must rewrite it to be an assignment node, whose freshly allocated
54840:      * left-hand side becomes a use of pn.
27012:      */
27012:     if (dn->isBindingForm()) {
80631:         ParseNode *rhs = dn->expr();
27012:         if (rhs) {
80631:             ParseNode *lhs = MakeAssignment(dn, rhs, tc);
27012:             if (!lhs)
27012:                 return NULL;
27012:             //pn->dn_uses = lhs;
80631:             dn = (Definition *) lhs;
27012:         }
27012: 
78294:         dn->setOp((js_CodeSpec[dn->getOp()].format & JOF_SET) ? JSOP_SETNAME : JSOP_NAME);
80631:     } else if (dn->kind() == Definition::FUNCTION) {
78294:         JS_ASSERT(dn->isOp(JSOP_NOP));
80641:         tc->parser->prepareNodeForMutation(dn);
82024:         dn->setKind(PNK_NAME);
78294:         dn->setArity(PN_NAME);
27012:         dn->pn_atom = atom;
27012:     }
27012: 
27012:     /* Now make dn no longer a definition, rather a use of pn. */
82024:     JS_ASSERT(dn->isKind(PNK_NAME));
78294:     JS_ASSERT(dn->isArity(PN_NAME));
27012:     JS_ASSERT(dn->pn_atom == atom);
27012: 
80631:     for (ParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
78294:         JS_ASSERT(pnu->isUsed());
78294:         JS_ASSERT(!pnu->isDefn());
80631:         pnu->pn_lexdef = (Definition *) pn;
30457:         pn->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
30457:     }
30457:     pn->pn_dflags |= dn->pn_dflags & PND_USE2DEF_FLAGS;
27012:     pn->dn_uses = dn;
27012: 
78294:     dn->setDefn(false);
78294:     dn->setUsed(true);
80631:     dn->pn_lexdef = (Definition *) pn;
47573:     dn->pn_cookie.makeFree();
27012:     dn->pn_dflags &= ~PND_BOUND;
27012:     return dn;
27012: }
27012: 
80507: bool
80786: js::DefineArg(ParseNode *pn, JSAtom *atom, uintN i, TreeContext *tc)
80631: {
27012:     /* Flag tc so we don't have to lookup arguments on every use. */
40860:     if (atom == tc->parser->context->runtime->atomState.argumentsAtom)
27012:         tc->flags |= TCF_FUN_PARAM_ARGUMENTS;
27012: 
27012:     /*
27012:      * Make an argument definition node, distinguished by being in tc->decls
82024:      * but having PNK_NAME kind and JSOP_NOP op. Insert it in a PNK_ARGSBODY
27012:      * list node returned via pn->pn_body.
27012:      */
82024:     ParseNode *argpn = NameNode::create(PNK_NAME, atom, tc);
27012:     if (!argpn)
27012:         return false;
82024:     JS_ASSERT(argpn->isKind(PNK_NAME) && argpn->isOp(JSOP_NOP));
27012: 
27012:     /* Arguments are initialized by definition. */
27012:     argpn->pn_dflags |= PND_INITIALIZED;
27012:     if (!Define(argpn, atom, tc))
27012:         return false;
27012: 
82024:     ParseNode *argsbody = pn->pn_body;
27012:     if (!argsbody) {
82024:         argsbody = ListNode::create(PNK_ARGSBODY, tc);
27012:         if (!argsbody)
27012:             return false;
78294:         argsbody->setOp(JSOP_NOP);
27012:         argsbody->makeEmpty();
27012:         pn->pn_body = argsbody;
27012:     }
27012:     argsbody->append(argpn);
27012: 
78294:     argpn->setOp(JSOP_GETARG);
47573:     argpn->pn_cookie.set(tc->staticLevel, i);
27012:     argpn->pn_dflags |= PND_BOUND;
27012:     return true;
27012: }
27012: 
    1: /*
    1:  * Parameter block types for the several Binder functions.  We use a common
    1:  * helper function signature in order to share code among destructuring and
    1:  * simple variable declaration parsers.  In the destructuring case, the binder
    1:  * function is called indirectly from the variable declaration parser by way
    1:  * of CheckDestructuring and its friends.
    1:  */
    1: typedef JSBool
80631: (*Binder)(JSContext *cx, BindData *data, JSAtom *atom, TreeContext *tc);
    1: 
    1: struct BindData {
29379:     BindData() : fresh(true) {}
29379: 
80631:     ParseNode       *pn;        /* name node for definition processing and
27012:                                    error source coordinates */
    1:     JSOp            op;         /* prolog bytecode or nop */
    1:     Binder          binder;     /* binder, discriminates u */
    1:     union {
    1:         struct {
    1:             uintN   overflow;
    1:         } let;
27012:     };
29379:     bool fresh;
    1: };
    1: 
59968: static bool
80631: BindLocalVariable(JSContext *cx, TreeContext *tc, ParseNode *pn, BindingKind kind)
59968: {
59968:     JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
    1: 
74093:     /* 'arguments' can be bound as a local only via a destructuring formal parameter. */
74093:     JS_ASSERT_IF(pn->pn_atom == cx->runtime->atomState.argumentsAtom, kind == VARIABLE);
74093: 
74093:     uintN index = tc->bindings.countVars();
74093:     if (!tc->bindings.add(cx, pn->pn_atom, kind))
74093:         return false;
74093: 
74093:     pn->pn_cookie.set(tc->staticLevel, index);
74093:     pn->pn_dflags |= PND_BOUND;
59968:     return true;
    1: }
    1: 
    1: #if JS_HAS_DESTRUCTURING
    1: static JSBool
80631: BindDestructuringArg(JSContext *cx, BindData *data, JSAtom *atom, TreeContext *tc)
    1: {
29009:     /* Flag tc so we don't have to lookup arguments on every use. */
40860:     if (atom == tc->parser->context->runtime->atomState.argumentsAtom)
29009:         tc->flags |= TCF_FUN_PARAM_ARGUMENTS;
29009: 
41884:     JS_ASSERT(tc->inFunction());
27012: 
59968:     /*
59968:      * NB: Check tc->decls rather than tc->bindings, because destructuring
59968:      *     bindings aren't added to tc->bindings until after all arguments have
59968:      *     been parsed.
59968:      */
72579:     if (tc->decls.lookupFirst(atom)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), NULL, JSREPORT_ERROR,
40320:                                  JSMSG_DESTRUCT_DUP_ARG);
    1:         return JS_FALSE;
    1:     }
59952: 
80631:     ParseNode *pn = data->pn;
59955: 
59952:     /*
59952:      * Distinguish destructured-to binding nodes as vars, not args, by setting
59952:      * pn_op to JSOP_SETLOCAL. Parser::functionDef checks for this pn_op value
59952:      * when processing the destructuring-assignment AST prelude induced by such
59952:      * destructuring args in Parser::functionArguments.
59955:      *
59955:      * We must set the PND_BOUND flag too to prevent pn_op from being reset to
59955:      * JSOP_SETNAME by BindDestructuringVar. The only field not initialized is
59955:      * pn_cookie; it gets set in functionDef in the first "if (prelude)" block.
59957:      * We have to wait to set the cookie until we can call JSFunction::addLocal
59957:      * with kind = JSLOCAL_VAR, after all JSLOCAL_ARG locals have been added.
59957:      *
59957:      * Thus a destructuring formal parameter binds an ARG (as in arguments[i]
59957:      * element) with a null atom name for the object or array passed in to be
59957:      * destructured, and zero or more VARs (as in named local variables) for
59957:      * the destructured-to identifiers in the property value positions within
59957:      * the object or array destructuring pattern, and all ARGs for the formal
59957:      * parameter list bound as locals before any VAR for a destructured name.
59955:      */
78294:     pn->setOp(JSOP_SETLOCAL);
59955:     pn->pn_dflags |= PND_BOUND;
59955: 
59955:     return Define(pn, atom, tc);
    1: }
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
27012: JSFunction *
80631: Parser::newFunction(TreeContext *tc, JSAtom *atom, FunctionSyntaxKind kind)
72567: {
72567:     JS_ASSERT_IF(kind == Statement, atom != NULL);
27012: 
27012:     /*
27012:      * Find the global compilation context in order to pre-set the newborn
27012:      * function's parent slot to tc->scopeChain. If the global context is a
27012:      * compile-and-go one, we leave the pre-set parent intact; otherwise we
27012:      * clear parent and proto.
27012:      */
27012:     while (tc->parent)
27012:         tc = tc->parent;
72567:     JSObject *parent = tc->inFunction() ? NULL : tc->scopeChain();
72567: 
72567:     JSFunction *fun =
72567:         js_NewFunction(context, NULL, NULL, 0,
72567:                        JSFUN_INTERPRETED | (kind == Expression ? JSFUN_LAMBDA : 0),
72567:                        parent, atom);
41884:     if (fun && !tc->compileAndGo()) {
76812:         fun->clearParent();
77450:         fun->clearType();
13691:     }
13691:     return fun;
 8444: }
 8444: 
25110: static JSBool
40320: MatchOrInsertSemicolon(JSContext *cx, TokenStream *ts)
40320: {
40854:     TokenKind tt = ts->peekTokenSameLine(TSF_OPERAND);
25110:     if (tt == TOK_ERROR)
25110:         return JS_FALSE;
25110:     if (tt != TOK_EOF && tt != TOK_EOL && tt != TOK_SEMI && tt != TOK_RC) {
54158:         /* Advance the scanner for proper error location reporting. */
54158:         ts->getToken(TSF_OPERAND);
40320:         ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR, JSMSG_SEMI_BEFORE_STMNT);
25110:         return JS_FALSE;
25110:     }
40354:     (void) ts->matchToken(TOK_SEMI);
25110:     return JS_TRUE;
25110: }
25110: 
80631: static FunctionBox *
80631: EnterFunction(ParseNode *fn, TreeContext *funtc, JSAtom *funAtom = NULL,
72567:               FunctionSyntaxKind kind = Expression)
40263: {
80631:     TreeContext *tc = funtc->parent;
72567:     JSFunction *fun = tc->parser->newFunction(tc, funAtom, kind);
27012:     if (!fun)
27012:         return NULL;
27012: 
27012:     /* Create box for fun->object early to protect against last-ditch GC. */
80631:     FunctionBox *funbox = tc->parser->newFunctionBox(fun, fn, tc);
27012:     if (!funbox)
27012:         return NULL;
27012: 
27012:     /* Initialize non-default members of funtc. */
27012:     funtc->flags |= funbox->tcflags;
27012:     funtc->blockidGen = tc->blockidGen;
27012:     if (!GenerateBlockId(funtc, funtc->bodyid))
27012:         return NULL;
57829:     funtc->setFunction(fun);
27012:     funtc->funbox = funbox;
27012:     if (!SetStaticLevel(funtc, tc->staticLevel + 1))
27012:         return NULL;
27012: 
27012:     return funbox;
27012: }
27012: 
27012: static bool
80989: DeoptimizeUsesWithin(Definition *dn, const TokenPos &pos)
80989: {
80989:     uintN ndeoptimized = 0;
80989: 
80989:     for (ParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
80989:         JS_ASSERT(pnu->isUsed());
80989:         JS_ASSERT(!pnu->isDefn());
80989:         if (pnu->pn_pos.begin >= pos.begin && pnu->pn_pos.end <= pos.end) {
80989:             pnu->pn_dflags |= PND_DEOPTIMIZED;
80989:             ++ndeoptimized;
80989:         }
80989:     }
80989: 
80989:     return ndeoptimized != 0;
80989: }
80989: 
80989: static bool
80631: LeaveFunction(ParseNode *fn, TreeContext *funtc, PropertyName *funName = NULL,
72567:               FunctionSyntaxKind kind = Expression)
40263: {
80631:     TreeContext *tc = funtc->parent;
27012:     tc->blockidGen = funtc->blockidGen;
27012: 
80631:     FunctionBox *funbox = fn->pn_funbox;
37685:     funbox->tcflags |= funtc->flags & (TCF_FUN_FLAGS | TCF_COMPILE_N_GO | TCF_RETURN_EXPR);
27012: 
27012:     fn->pn_dflags |= PND_INITIALIZED;
27012:     if (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)
27012:         fn->pn_dflags |= PND_BLOCKCHILD;
27012: 
27012:     /*
27012:      * Propagate unresolved lexical names up to tc->lexdeps, and save a copy
27371:      * of funtc->lexdeps in a TOK_UPVARS node wrapping the function's formal
27371:      * params and body. We do this only if there are lexical dependencies not
27371:      * satisfied by the function's declarations, to avoid penalizing functions
27371:      * that use only their arguments and other local bindings.
27012:      */
72579:     if (funtc->lexdeps->count()) {
27371:         int foundCallee = 0;
27012: 
72579:         for (AtomDefnRange r = funtc->lexdeps->all(); !r.empty(); r.popFront()) {
72579:             JSAtom *atom = r.front().key();
80631:             Definition *dn = r.front().value();
27012:             JS_ASSERT(dn->isPlaceholder());
27012: 
80442:             if (atom == funName && kind == Expression) {
78294:                 dn->setOp(JSOP_CALLEE);
47573:                 dn->pn_cookie.set(funtc->staticLevel, UpvarCookie::CALLEE_SLOT);
27012:                 dn->pn_dflags |= PND_BOUND;
27052: 
27052:                 /*
27052:                  * If this named function expression uses its own name other
32658:                  * than to call itself, flag this function specially.
27052:                  */
27052:                 if (dn->isFunArg())
37685:                     funbox->tcflags |= TCF_FUN_USES_OWN_NAME;
27371:                 foundCallee = 1;
27012:                 continue;
27012:             }
27012: 
37685:             if (!(funbox->tcflags & TCF_FUN_SETS_OUTER_NAME) &&
27012:                 dn->isAssigned()) {
27012:                 /*
27012:                  * Make sure we do not fail to set TCF_FUN_SETS_OUTER_NAME if
27012:                  * any use of dn in funtc assigns. See NoteLValue for the easy
27012:                  * backward-reference case; this is the hard forward-reference
27012:                  * case where we pay a higher price.
27012:                  */
80631:                 for (ParseNode *pnu = dn->dn_uses; pnu; pnu = pnu->pn_link) {
27012:                     if (pnu->isAssigned() && pnu->pn_blockid >= funtc->bodyid) {
37685:                         funbox->tcflags |= TCF_FUN_SETS_OUTER_NAME;
27012:                         break;
27012:                     }
27012:                 }
27012:             }
27012: 
80631:             Definition *outer_dn = tc->decls.lookupFirst(atom);
52554: 
52554:             /*
52554:              * Make sure to deoptimize lexical dependencies that are polluted
60547:              * by eval or with, to safely bind globals (see bug 561923).
52554:              */
54840:             if (funtc->callsEval() ||
72579:                 (outer_dn && tc->innermostWith &&
72579:                  outer_dn->pn_pos < tc->innermostWith->pn_pos)) {
52554:                 DeoptimizeUsesWithin(dn, fn->pn_pos);
52554:             }
52554: 
72579:             if (!outer_dn) {
72579:                 AtomDefnAddPtr p = tc->lexdeps->lookupForAdd(atom);
72579:                 if (p) {
72579:                     outer_dn = p.value();
72579:                 } else {
72579:                     /*
72579:                      * Create a new placeholder for our outer lexdep. We could
72579:                      * simply re-use the inner placeholder, but that introduces
72579:                      * subtleties in the case where we find a later definition
72579:                      * that captures an existing lexdep. For example:
57762:                      *
57762:                      *   function f() { function g() { x; } let x; }
57762:                      *
72579:                      * Here, g's TOK_UPVARS node lists the placeholder for x,
72579:                      * which must be captured by the 'let' declaration later,
72579:                      * since 'let's are hoisted.  Taking g's placeholder as our
72579:                      * own would work fine. But consider:
57762:                      *
57762:                      *   function f() { x; { function g() { x; } let x; } }
57762:                      *
72579:                      * Here, the 'let' must not capture all the uses of f's
72579:                      * lexdep entry for x, but it must capture the x node
72579:                      * referred to from g's TOK_UPVARS node.  Always turning
72579:                      * inherited lexdeps into uses of a new outer definition
57762:                      * allows us to handle both these cases in a natural way.
57762:                      */
73941:                     outer_dn = MakePlaceholder(dn, tc);
73941:                     if (!outer_dn || !tc->lexdeps->add(p, atom, outer_dn))
71687:                         return false;
71687:                 }
72579:             }
57762: 
27012:             /*
27012:              * Insert dn's uses list at the front of outer_dn's list.
27012:              *
27012:              * Without loss of generality or correctness, we allow a dn to
27012:              * be in inner and outer lexdeps, since the purpose of lexdeps
27012:              * is one-pass coordination of name use and definition across
27012:              * functions, and if different dn's are used we'll merge lists
27012:              * when leaving the inner function.
27012:              *
27012:              * The dn == outer_dn case arises with generator expressions
27012:              * (see CompExprTransplanter::transplant, the PN_FUNC/PN_NAME
27012:              * case), and nowhere else, currently.
27012:              */
27012:             if (dn != outer_dn) {
80631:                 ParseNode **pnup = &dn->dn_uses;
80631:                 ParseNode *pnu;
27012: 
27012:                 while ((pnu = *pnup) != NULL) {
27012:                     pnu->pn_lexdef = outer_dn;
27012:                     pnup = &pnu->pn_link;
27012:                 }
27012: 
27012:                 /*
27012:                  * Make dn be a use that redirects to outer_dn, because we
27012:                  * can't replace dn with outer_dn in all the pn_namesets in
27012:                  * the AST where it may be. Instead we make it forward to
80631:                  * outer_dn. See Definition::resolve.
27012:                  */
27012:                 *pnup = outer_dn->dn_uses;
27012:                 outer_dn->dn_uses = dn;
28557:                 outer_dn->pn_dflags |= dn->pn_dflags & ~PND_PLACEHOLDER;
78294:                 dn->setDefn(false);
78294:                 dn->setUsed(true);
27012:                 dn->pn_lexdef = outer_dn;
57762:             }
52878: 
52878:             /* Mark the outer dn as escaping. */
52878:             outer_dn->pn_dflags |= PND_CLOSED;
27012:         }
27012: 
72579:         if (funtc->lexdeps->count() - foundCallee != 0) {
80631:             ParseNode *body = fn->pn_body;
27012: 
82024:             fn->pn_body = NameSetNode::create(PNK_UPVARS, tc);
27012:             if (!fn->pn_body)
27012:                 return false;
27371: 
27109:             fn->pn_body->pn_pos = body->pn_pos;
27371:             if (foundCallee)
80442:                 funtc->lexdeps->remove(funName);
72579:             /* Transfer ownership of the lexdep map to the parse node. */
27371:             fn->pn_body->pn_names = funtc->lexdeps;
72579:             funtc->lexdeps.clearMap();
27012:             fn->pn_body->pn_tree = body;
72579:         } else {
72579:             funtc->lexdeps.releaseMap(funtc->parser->context);
72579:         }
72579: 
27012:     }
27012: 
51096:     /*
51096:      * Check whether any parameters have been assigned within this function.
51096:      * In strict mode parameters do not alias arguments[i], and to make the
51096:      * arguments object reflect initial parameter values prior to any mutation
51096:      * we create it eagerly whenever parameters are (or might, in the case of
51096:      * calls to eval) be assigned.
51096:      */
51096:     if (funtc->inStrictMode() && funbox->object->getFunctionPrivate()->nargs > 0) {
72579:         AtomDeclsIter iter(&funtc->decls);
80631:         Definition *dn;
72579: 
72579:         while ((dn = iter()) != NULL) {
80631:             if (dn->kind() == Definition::ARG && dn->isAssigned()) {
51096:                 funbox->tcflags |= TCF_FUN_MUTATES_PARAMETER;
51096:                 break;
51096:             }
51096:         }
51096:     }
51096: 
59968:     funbox->bindings.transfer(funtc->parser->context, &funtc->bindings);
59968: 
27012:     return true;
27012: }
27012: 
52818: static bool
80964: DefineGlobal(ParseNode *pn, BytecodeEmitter *bce, PropertyName *name);
52818: 
59952: /*
59952:  * FIXME? this Parser method was factored from Parser::functionDef with minimal
59968:  * change, hence the funtc ref param and funbox. It probably should match
59968:  * functionBody, etc., and use tc and tc->funbox instead of taking explicit
59968:  * parameters.
59952:  */
51088: bool
80631: Parser::functionArguments(TreeContext &funtc, FunctionBox *funbox, ParseNode **listp)
51088: {
51088:     if (tokenStream.getToken() != TOK_LP) {
51088:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_PAREN_BEFORE_FORMAL);
51088:         return false;
51088:     }
51088: 
51088:     if (!tokenStream.matchToken(TOK_RP)) {
51088: #if JS_HAS_DESTRUCTURING
51088:         JSAtom *duplicatedArg = NULL;
51088:         bool destructuringArg = false;
80631:         ParseNode *list = NULL;
51088: #endif
52503: 
51088:         do {
51088:             switch (TokenKind tt = tokenStream.getToken()) {
51088: #if JS_HAS_DESTRUCTURING
51088:               case TOK_LB:
51088:               case TOK_LC:
51088:               {
51088:                 /* See comment below in the TOK_NAME case. */
51088:                 if (duplicatedArg)
51088:                     goto report_dup_and_destructuring;
51088:                 destructuringArg = true;
51088: 
51088:                 /*
51088:                  * A destructuring formal parameter turns into one or more
51088:                  * local variables initialized from properties of a single
51088:                  * anonymous positional parameter, so here we must tweak our
51088:                  * binder and its data.
51088:                  */
51088:                 BindData data;
51088:                 data.pn = NULL;
51088:                 data.op = JSOP_DEFVAR;
51088:                 data.binder = BindDestructuringArg;
80631:                 ParseNode *lhs = destructuringExpr(&data, tt);
51088:                 if (!lhs)
51088:                     return false;
51088: 
51088:                 /*
51088:                  * Adjust fun->nargs to count the single anonymous positional
51088:                  * parameter that is to be destructured.
51088:                  */
59968:                 uint16 slot;
59968:                 if (!funtc.bindings.addDestructuring(context, &slot))
51088:                     return false;
51088: 
51088:                 /*
51088:                  * Synthesize a destructuring assignment from the single
51088:                  * anonymous positional parameter into the destructuring
51088:                  * left-hand-side expression and accumulate it in list.
51088:                  */
82024:                 ParseNode *rhs =
82024:                     NameNode::create(PNK_NAME, context->runtime->atomState.emptyAtom, &funtc);
51088:                 if (!rhs)
51088:                     return false;
78294:                 rhs->setOp(JSOP_GETARG);
59952:                 rhs->pn_cookie.set(funtc.staticLevel, slot);
51088:                 rhs->pn_dflags |= PND_BOUND;
51088: 
80631:                 ParseNode *item =
82024:                     ParseNode::newBinaryOrAppend(PNK_ASSIGN, JSOP_NOP, lhs, rhs, &funtc);
51088:                 if (!item)
51088:                     return false;
51088:                 if (!list) {
82024:                     list = ListNode::create(PNK_VAR, &funtc);
51088:                     if (!list)
51088:                         return false;
51088:                     list->makeEmpty();
51088:                     *listp = list;
51088:                 }
51088:                 list->append(item);
51088:                 break;
51088:               }
51088: #endif /* JS_HAS_DESTRUCTURING */
51088: 
51088:               case TOK_NAME:
51088:               {
80443:                 PropertyName *name = tokenStream.currentToken().name();
59952: 
51088: #ifdef JS_HAS_DESTRUCTURING
51088:                 /*
59968:                  * ECMA-262 requires us to support duplicate parameter names,
59968:                  * but if the parameter list includes destructuring, we
59968:                  * consider the code to have "opted in" to higher standards and
59968:                  * forbid duplicates. We may see a destructuring parameter
59968:                  * later, so always note duplicates now.
59968:                  *
59968:                  * Duplicates are warned about (strict option) or cause errors
59968:                  * (strict mode code), but we do those tests in one place
59968:                  * below, after having parsed the body in case it begins with a
59968:                  * "use strict"; directive.
59968:                  *
59968:                  * NB: Check funtc.decls rather than funtc.bindings, because
59968:                  *     destructuring bindings aren't added to funtc.bindings
59968:                  *     until after all arguments have been parsed.
52503:                  */
80443:                 if (funtc.decls.lookupFirst(name)) {
80443:                     duplicatedArg = name;
51088:                     if (destructuringArg)
51088:                         goto report_dup_and_destructuring;
51088:                 }
51088: #endif
59952: 
59968:                 uint16 slot;
80443:                 if (!funtc.bindings.addArgument(context, name, &slot))
59952:                     return false;
80443:                 if (!DefineArg(funbox->node, name, slot, &funtc))
51088:                     return false;
51088:                 break;
51088:               }
51088: 
51088:               default:
51088:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_MISSING_FORMAL);
51088:                 /* FALL THROUGH */
51088:               case TOK_ERROR:
51088:                 return false;
51088: 
51088: #if JS_HAS_DESTRUCTURING
51088:               report_dup_and_destructuring:
80631:                 Definition *dn = funtc.decls.lookupFirst(duplicatedArg);
51088:                 reportErrorNumber(dn, JSREPORT_ERROR, JSMSG_DESTRUCT_DUP_ARG);
51088:                 return false;
51088: #endif
51088:             }
51088:         } while (tokenStream.matchToken(TOK_COMMA));
51088: 
51088:         if (tokenStream.getToken() != TOK_RP) {
51088:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_PAREN_AFTER_FORMAL);
51088:             return false;
51088:         }
51088:     }
51088: 
51088:     return true;
51088: }
51088: 
80631: ParseNode *
80442: Parser::functionDef(PropertyName *funName, FunctionType type, FunctionSyntaxKind kind)
80442: {
80442:     JS_ASSERT_IF(kind == Statement, funName);
72567: 
    1:     /* Make a TOK_FUNCTION node. */
82024:     ParseNode *pn = FunctionNode::create(PNK_FUNCTION, tc);
    1:     if (!pn)
    1:         return NULL;
27012:     pn->pn_body = NULL;
47573:     pn->pn_cookie.makeFree();
27012: 
27012:     /*
72567:      * If this is a function expression, mark this function as escaping (as a
72567:      * "funarg") unless it is immediately applied (we clear PND_FUNARG if so --
72567:      * see memberExpr).
72567:      *
72567:      * Treat function sub-statements (those not at body level of a function or
72567:      * program) as escaping funargs, since we can't statically analyze their
72567:      * definitions and uses.
27012:      */
59229:     bool bodyLevel = tc->atBodyLevel();
72567:     pn->pn_dflags = (kind == Expression || !bodyLevel) ? PND_FUNARG : 0;
    1: 
    1:     /*
    1:      * Record names for function statements in tc->decls so we know when to
    1:      * avoid optimizing variable references that might name a function.
    1:      */
72567:     if (kind == Statement) {
80631:         if (Definition *dn = tc->decls.lookupFirst(funName)) {
80631:             Definition::Kind dn_kind = dn->kind();
27012: 
78294:             JS_ASSERT(!dn->isUsed());
78294:             JS_ASSERT(dn->isDefn());
27012: 
80631:             if (context->hasStrictOption() || dn_kind == Definition::CONST) {
57812:                 JSAutoByteString name;
80442:                 if (!js_AtomToPrintableString(context, funName, &name) ||
42671:                     !reportErrorNumber(NULL,
80631:                                        (dn_kind != Definition::CONST)
27012:                                        ? JSREPORT_WARNING | JSREPORT_STRICT
 7984:                                        : JSREPORT_ERROR,
    1:                                        JSMSG_REDECLARED_VAR,
80631:                                        Definition::kindString(dn_kind),
57812:                                        name.ptr())) {
    1:                     return NULL;
    1:                 }
    1:             }
27012: 
59229:             if (bodyLevel) {
80631:                 tc->decls.updateFirst(funName, (Definition *) pn);
78294:                 pn->setDefn(true);
27012:                 pn->dn_uses = dn; /* dn->dn_uses is now pn_link */
27012: 
80442:                 if (!MakeDefIntoUse(dn, pn, funName, tc))
27012:                     return NULL;
27012:             }
59229:         } else if (bodyLevel) {
27012:             /*
27012:              * If this function was used before it was defined, claim the
40239:              * pre-created definition node for this function that primaryExpr
27012:              * put in tc->lexdeps on first forward reference, and recycle pn.
27012:              */
72579: 
80631:             if (Definition *fn = tc->lexdeps.lookupDefn(funName)) {
78294:                 JS_ASSERT(fn->isDefn());
82024:                 fn->setKind(PNK_FUNCTION);
78294:                 fn->setArity(PN_FUNC);
27012:                 fn->pn_pos.begin = pn->pn_pos.begin;
64260: 
64260:                 /*
64260:                  * Set fn->pn_pos.end too, in case of error before we parse the
64260:                  * closing brace.  See bug 640075.
64260:                  */
64260:                 fn->pn_pos.end = pn->pn_pos.end;
64260: 
27012:                 fn->pn_body = NULL;
47573:                 fn->pn_cookie.makeFree();
27012: 
80442:                 tc->lexdeps->remove(funName);
80641:                 freeTree(pn);
27012:                 pn = fn;
27012:             }
27012: 
80442:             if (!Define(pn, funName, tc))
27012:                 return NULL;
27012:         }
    1: 
    1:         /*
59228:          * A function directly inside another's body needs only a local
59228:          * variable to bind its name to its value, and not an activation object
59228:          * property (it might also need the activation property, if the outer
59228:          * function contains with statements, e.g., but the stack slot wins
80964:          * when BytecodeEmitter.cpp's BindNameToSlot can optimize a JSOP_NAME
80634:          * into a JSOP_GETLOCAL bytecode).
    1:          */
59229:         if (bodyLevel && tc->inFunction()) {
27012:             /*
27012:              * Define a local in the outer function so that BindNameToSlot
27012:              * can properly optimize accesses. Note that we need a local
27012:              * variable, not an argument, for the function statement. Thus
27012:              * we add a variable even if a parameter with the given name
27012:              * already exists.
27012:              */
59228:             uintN index;
80442:             switch (tc->bindings.lookup(context, funName, &index)) {
59968:               case NONE:
59968:               case ARGUMENT:
59968:                 index = tc->bindings.countVars();
80442:                 if (!tc->bindings.addVariable(context, funName))
27012:                     return NULL;
27012:                 /* FALL THROUGH */
27012: 
59968:               case VARIABLE:
47573:                 pn->pn_cookie.set(tc->staticLevel, index);
27012:                 pn->pn_dflags |= PND_BOUND;
27012:                 break;
27012: 
27012:               default:;
27012:             }
27012:         }
27012:     }
27012: 
80631:     TreeContext *outertc = tc;
40263: 
40239:     /* Initialize early for possible flags mutation via destructuringExpr. */
80631:     TreeContext funtc(tc->parser);
72579:     if (!funtc.init(context))
72579:         return NULL;
27012: 
80631:     FunctionBox *funbox = EnterFunction(pn, &funtc, funName, kind);
27012:     if (!funbox)
27012:         return NULL;
27012: 
64294:     JSFunction *fun = funbox->function();
 8179: 
    1:     /* Now parse formal argument list and compute fun->nargs. */
80631:     ParseNode *prelude = NULL;
59968:     if (!functionArguments(funtc, funbox, &prelude))
59968:         return NULL;
59968: 
59968:     fun->setArgCount(funtc.bindings.countArgs());
59952: 
59952: #if JS_HAS_DESTRUCTURING
59952:     /*
59952:      * If there were destructuring formal parameters, bind the destructured-to
59952:      * local variables now that we've parsed all the regular and destructuring
59968:      * formal parameters. Because js::Bindings::add must be called first for
59968:      * all ARGUMENTs, then all VARIABLEs and CONSTANTs, and finally all UPVARs,
59968:      * we can't bind vars induced by formal parameter destructuring until after
59968:      * Parser::functionArguments has returned.
59952:      */
59952:     if (prelude) {
72579:         AtomDeclsIter iter(&funtc.decls);
72579: 
80631:         while (Definition *apn = iter()) {
59952:             /* Filter based on pn_op -- see BindDestructuringArg, above. */
78294:             if (!apn->isOp(JSOP_SETLOCAL))
59952:                 continue;
59952: 
74093:             if (!BindLocalVariable(context, &funtc, apn, VARIABLE))
74093:                 return NULL;
59952:         }
59952:     }
59952: #endif
    1: 
72581:     if (type == Getter && fun->nargs > 0) {
51089:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_ACCESSOR_WRONG_ARGS,
51089:                           "getter", "no", "s");
51089:         return NULL;
51089:     }
72581:     if (type == Setter && fun->nargs != 1) {
51089:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_ACCESSOR_WRONG_ARGS,
51089:                           "setter", "one", "");
51089:         return NULL;
51089:     }
51089: 
 1967: #if JS_HAS_EXPR_CLOSURES
51085:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
 1967:     if (tt != TOK_LC) {
40354:         tokenStream.ungetToken();
 1967:         fun->flags |= JSFUN_EXPR_CLOSURE;
 1967:     }
 1967: #else
    1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_BODY);
 1967: #endif
    1: 
80631:     ParseNode *body = functionBody();
    1:     if (!body)
    1:         return NULL;
    1: 
80442:     if (funName && !CheckStrictBinding(context, &funtc, funName, pn))
62048:         return NULL;
62048: 
62048:     if (!CheckStrictParameters(context, &funtc))
35323:         return NULL;
35323: 
 1967: #if JS_HAS_EXPR_CLOSURES
 1967:     if (tt == TOK_LC)
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
72567:     else if (kind == Statement && !MatchOrInsertSemicolon(context, &tokenStream))
25110:         return NULL;
 1967: #else
 1967:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_BODY);
 1967: #endif
40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1: 
51097:     /*
53520:      * Fruit of the poisonous tree: if a closure calls eval, we consider the
53520:      * parent to call eval. We need this for two reasons: (1) the Jaegermonkey
53520:      * optimizations really need to know if eval is called transitively, and
53520:      * (2) in strict mode, eval called transitively requires eager argument
53520:      * creation in strict mode parent functions.
53520:      *
53520:      * For the latter, we really only need to propagate callsEval if both
53520:      * functions are strict mode, but we don't lose much by always propagating.
53520:      * The only optimization we lose this way is in the case where a function
53520:      * is strict, does not mutate arguments, does not call eval directly, but
53520:      * calls eval transitively.
53520:      */
51097:     if (funtc.callsEval())
51097:         outertc->noteCallsEval();
51097: 
    1: #if JS_HAS_DESTRUCTURING
    1:     /*
    1:      * If there were destructuring formal parameters, prepend the initializing
51110:      * comma expression that we synthesized to body. If the body is a return
82024:      * node, we must make a special PNK_SEQ node, to prepend the destructuring
51110:      * code without bracing the decompilation of the function body.
    1:      */
59952:     if (prelude) {
78294:         if (!body->isArity(PN_LIST)) {
80631:             ParseNode *block;
    1: 
82024:             block = ListNode::create(PNK_SEQ, outertc);
    1:             if (!block)
    1:                 return NULL;
    1:             block->pn_pos = body->pn_pos;
27012:             block->initList(body);
    1: 
    1:             body = block;
    1:         }
    1: 
82024:         ParseNode *item = UnaryNode::create(PNK_SEMI, outertc);
    1:         if (!item)
    1:             return NULL;
    1: 
    1:         item->pn_pos.begin = item->pn_pos.end = body->pn_pos.begin;
59952:         item->pn_kid = prelude;
    1:         item->pn_next = body->pn_head;
    1:         body->pn_head = item;
    1:         if (body->pn_tail == &body->pn_head)
    1:             body->pn_tail = &item->pn_next;
    1:         ++body->pn_count;
27012:         body->pn_xflags |= PNX_DESTRUCT;
    1:     }
    1: #endif
    1: 
    1:     /*
    1:      * If we collected flags that indicate nested heavyweight functions, or
27012:      * this function contains heavyweight-making statements (with statement,
27012:      * visible eval call, or assignment to 'arguments'), flag the function as
27012:      * heavyweight (requiring a call object per invocation).
    1:      */
    1:     if (funtc.flags & TCF_FUN_HEAVYWEIGHT) {
    1:         fun->flags |= JSFUN_HEAVYWEIGHT;
40263:         outertc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     } else {
    1:         /*
59229:          * If this function is not at body level of a program or function (i.e.
59229:          * it is a function statement that is not a direct child of a program
59229:          * or function), then our enclosing function, if any, must be
59229:          * heavyweight.
59229:          */
72567:         if (!bodyLevel && kind == Statement)
40263:             outertc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:     }
    1: 
51086:     JSOp op = JSOP_NOP;
72567:     if (kind == Expression) {
27012:         op = JSOP_LAMBDA;
72567:     } else {
72567:         if (!bodyLevel) {
72567:             /*
72567:              * Extension: in non-strict mode code, a function statement not at
72567:              * the top level of a function body or whole program, e.g., in a
72567:              * compound statement such as the "then" part of an "if" statement,
72567:              * binds a closure only if control reaches that sub-statement.
72567:              */
72567:             JS_ASSERT(!outertc->inStrictMode());
18965:             op = JSOP_DEFFUN;
58291:             outertc->noteMightAliasLocals();
    1:         }
72567:     }
    1: 
27012:     funbox->kids = funtc.functionList;
27012: 
27012:     pn->pn_funbox = funbox;
78294:     pn->setOp(op);
28816:     if (pn->pn_body) {
27012:         pn->pn_body->append(body);
28816:         pn->pn_body->pn_pos = body->pn_pos;
28816:     } else {
    1:         pn->pn_body = body;
28816:     }
27012: 
72567:     if (!outertc->inFunction() && bodyLevel && kind == Statement && outertc->compiling()) {
53081:         JS_ASSERT(pn->pn_cookie.isFree());
80964:         if (!DefineGlobal(pn, outertc->asBytecodeEmitter(), funName))
68902:             return NULL;
52818:     }
52818: 
40263:     pn->pn_blockid = outertc->blockid();
40263: 
80442:     if (!LeaveFunction(pn, &funtc, funName, kind))
27012:         return NULL;
27012: 
35113:     /* If the surrounding function is not strict code, reset the lexer. */
51096:     if (!outertc->inStrictMode())
40854:         tokenStream.setStrictMode(false);
35113: 
72567:     return pn;
    1: }
    1: 
80631: ParseNode *
40860: Parser::functionStmt()
40263: {
80442:     PropertyName *name = NULL;
51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME) {
80443:         name = tokenStream.currentToken().name();
51087:     } else {
72567:         /* Unnamed function expressions are forbidden in statement context. */
72567:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_UNNAMED_FUNCTION_STMT);
72567:         return NULL;
51087:     }
60253: 
60253:     /* We forbid function statements in strict mode code. */
60253:     if (!tc->atBodyLevel() && tc->inStrictMode()) {
60253:         reportErrorNumber(NULL, JSREPORT_STRICT_MODE_ERROR, JSMSG_STRICT_FUNCTION_STATEMENT);
60253:         return NULL;
60253:     }
60253: 
72581:     return functionDef(name, Normal, Statement);
40239: }
40239: 
80631: ParseNode *
40860: Parser::functionExpr()
40263: {
80442:     PropertyName *name = NULL;
51087:     if (tokenStream.getToken(TSF_KEYWORD_IS_NAME) == TOK_NAME)
80443:         name = tokenStream.currentToken().name();
51087:     else
51087:         tokenStream.ungetToken();
72581:     return functionDef(name, Normal, Expression);
    1: }
    1: 
    1: /*
60792:  * Recognize Directive Prologue members and directives. Assuming |pn| is a
60792:  * candidate for membership in a directive prologue, recognize directives and
60792:  * set |tc|'s flags accordingly. If |pn| is indeed part of a prologue, set its
60792:  * |pn_prologue| flag.
35113:  *
35113:  * Note that the following is a strict mode function:
35113:  *
35113:  * function foo() {
35113:  *   "blah" // inserted semi colon
35113:  *        "blurgh"
35113:  *   "use\x20loose"
35113:  *   "use strict"
35113:  * }
35113:  *
60792:  * That is, even though "use\x20loose" can never be a directive, now or in the
60792:  * future (because of the hex escape), the Directive Prologue extends through it
60792:  * to the "use strict" statement, which is indeed a directive.
35113:  */
40239: bool
80631: Parser::recognizeDirectivePrologue(ParseNode *pn, bool *isDirectivePrologueMember)
59219: {
60792:     *isDirectivePrologueMember = pn->isStringExprStatement();
59219:     if (!*isDirectivePrologueMember)
59219:         return true;
60792: 
80631:     ParseNode *kid = pn->pn_kid;
60792:     if (kid->isEscapeFreeStringLiteral()) {
60792:         /*
60792:          * Mark this statement as being a possibly legitimate part of a
60792:          * directive prologue, so the byte code emitter won't warn about it
60792:          * being useless code. (We mustn't just omit the statement entirely yet,
60792:          * as it could be producing the value of an eval or JSScript execution.)
60792:          *
60792:          * Note that even if the string isn't one we recognize as a directive,
60792:          * the emitter still shouldn't flag it as useless, as it could become a
60792:          * directive in the future. We don't want to interfere with people
60792:          * taking advantage of directive-prologue-enabled features that appear
60792:          * in other browsers first.
60792:          */
60792:         pn->pn_prologue = true;
60792: 
60792:         JSAtom *directive = kid->pn_atom;
40239:         if (directive == context->runtime->atomState.useStrictAtom) {
59219:             /*
59219:              * Unfortunately, Directive Prologue members in general may contain
59219:              * escapes, even while "use strict" directives may not.  Therefore
59219:              * we must check whether an octal character escape has been seen in
59219:              * any previous directives whenever we encounter a "use strict"
59219:              * directive, so that the octal escape is properly treated as a
59219:              * syntax error.  An example of this case:
59219:              *
59219:              *   function error()
59219:              *   {
59219:              *     "\145"; // octal escape
59219:              *     "use strict"; // retroactively makes "\145" a syntax error
59219:              *   }
59219:              */
59219:             if (tokenStream.hasOctalCharacterEscape()) {
59219:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_DEPRECATED_OCTAL);
59219:                 return false;
59219:             }
59219: 
35113:             tc->flags |= TCF_STRICT_MODE_CODE;
40854:             tokenStream.setStrictMode();
35113:         }
35113:     }
35113:     return true;
35113: }
35113: 
35113: /*
    1:  * Parse the statements in a block, creating a TOK_LC node that lists the
    1:  * statements' trees.  If called from block-parsing code, the caller must
    1:  * match { before and } after.
    1:  */
80631: ParseNode *
40860: Parser::statements()
    1: {
82024:     ParseNode *pn2, *saveBlock;
40320:     TokenKind tt;
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40221: 
82024:     ParseNode *pn = ListNode::create(PNK_LC, tc);
    1:     if (!pn)
    1:         return NULL;
27012:     pn->makeEmpty();
27012:     pn->pn_blockid = tc->blockid();
    1:     saveBlock = tc->blockNode;
    1:     tc->blockNode = pn;
    1: 
59229:     bool inDirectivePrologue = tc->atBodyLevel();
59219:     tokenStream.setOctalCharacterEscape(false);
 9604:     for (;;) {
40854:         tt = tokenStream.peekToken(TSF_OPERAND);
10466:         if (tt <= TOK_EOF || tt == TOK_RC) {
24241:             if (tt == TOK_ERROR) {
40854:                 if (tokenStream.isEOF())
40854:                     tokenStream.setUnexpectedEOF();
40239:                 return NULL;
40239:             }
40239:             break;
40239:         }
40263:         pn2 = statement();
    1:         if (!pn2) {
40854:             if (tokenStream.isEOF())
40854:                 tokenStream.setUnexpectedEOF();
    1:             return NULL;
    1:         }
    1: 
59219:         if (inDirectivePrologue && !recognizeDirectivePrologue(pn2, &inDirectivePrologue))
59219:             return NULL;
35113: 
82024:         if (pn2->isKind(PNK_FUNCTION)) {
10466:             /*
59229:              * PNX_FUNCDEFS notifies the emitter that the block contains body-
10466:              * level function definitions that should be processed before the
10466:              * rest of nodes.
10466:              *
10466:              * TCF_HAS_FUNCTION_STMT is for the TOK_LC case in Statement. It
59229:              * is relevant only for function definitions not at body-level,
10466:              * which we call function statements.
10466:              */
74286:             if (tc->atBodyLevel()) {
27012:                 pn->pn_xflags |= PNX_FUNCDEFS;
74286:             } else {
    1:                 tc->flags |= TCF_HAS_FUNCTION_STMT;
64296:                 /* Function statements extend the Call object at runtime. */
64296:                 tc->noteHasExtensibleScope();
64296:             }
10466:         }
27012:         pn->append(pn2);
    1:     }
    1: 
    1:     /*
    1:      * Handle the case where there was a let declaration under this block.  If
    1:      * it replaced tc->blockNode with a new block node then we must refresh pn
    1:      * and then restore tc->blockNode.
    1:      */
    1:     if (tc->blockNode != pn)
    1:         pn = tc->blockNode;
    1:     tc->blockNode = saveBlock;
    1: 
40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
40860: Parser::condition()
    1: {
80631:     ParseNode *pn;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_COND);
61058:     pn = parenExpr();
    1:     if (!pn)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_COND);
    1: 
31479:     /* Check for (a = b) and warn about possible (a == b) mistype. */
82024:     JS_ASSERT_IF(pn->isKind(PNK_ASSIGN), pn->isOp(JSOP_NOP));
82024:     if (pn->isKind(PNK_ASSIGN) &&
78294:         !pn->isInParens() &&
82023:         !reportErrorNumber(NULL, JSREPORT_WARNING | JSREPORT_STRICT, JSMSG_EQUAL_AS_ASSIGN, ""))
82023:     {
    1:         return NULL;
    1:     }
    1:     return pn;
    1: }
    1: 
80443: static bool
80631: MatchLabel(JSContext *cx, TokenStream *ts, ParseNode *pn)
    1: {
80443:     TokenKind tt = ts->peekTokenSameLine(TSF_OPERAND);
    1:     if (tt == TOK_ERROR)
80443:         return false;
80443:     PropertyName *label;
    1:     if (tt == TOK_NAME) {
40354:         (void) ts->getToken();
80443:         label = ts->currentToken().name();
    1:     } else {
    1:         label = NULL;
    1:     }
    1:     pn->pn_atom = label;
80443:     return true;
    1: }
    1: 
74052: /*
74052:  * Define a let-variable in a block, let-expression, or comprehension scope. tc
74052:  * must already be in such a scope.
74052:  *
74052:  * Throw a SyntaxError if 'atom' is an invalid name. Otherwise create a
74052:  * property for the new variable on the block object, tc->blockChain();
74052:  * populate data->pn->pn_{op,cookie,defn,dflags}; and stash a pointer to
74052:  * data->pn in a slot of the block object.
74052:  */
    1: static JSBool
80631: BindLet(JSContext *cx, BindData *data, JSAtom *atom, TreeContext *tc)
80631: {
80631:     ParseNode *pn;
    1:     JSObject *blockObj;
27012:     jsint n;
27012: 
27012:     /*
59229:      * Body-level 'let' is the same as 'var' currently -- this may change in a
59229:      * successor standard to ES5 that specifies 'let'.
59229:      */
59229:     JS_ASSERT(!tc->atBodyLevel());
27012: 
27012:     pn = data->pn;
80442:     if (!CheckStrictBinding(cx, tc, atom->asPropertyName(), pn))
35325:         return false;
35325: 
54855:     blockObj = tc->blockChain();
80631:     Definition *dn = tc->decls.lookupFirst(atom);
72579:     if (dn && dn->pn_blockid == tc->blockid()) {
57812:         JSAutoByteString name;
57812:         if (js_AtomToPrintableString(cx, atom, &name)) {
40860:             ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 7984:                                      JSREPORT_ERROR, JSMSG_REDECLARED_VAR,
80507:                                      dn->isConst() ? "const" : "variable",
57812:                                      name.ptr());
    1:         }
47497:         return false;
    1:     }
    1: 
14688:     n = OBJ_BLOCK_COUNT(cx, blockObj);
14688:     if (n == JS_BIT(16)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), pn,
27012:                                  JSREPORT_ERROR, data->let.overflow);
47497:         return false;
    1:     }
    1: 
27012:     /*
27012:      * Pass push = true to Define so it pushes an ale ahead of any outer scope.
27012:      * This is balanced by PopStatement, defined immediately below.
27012:      */
27012:     if (!Define(pn, atom, tc, true))
47497:         return false;
27012: 
27012:     /*
27012:      * Assign block-local index to pn->pn_cookie right away, encoding it as an
27012:      * upvar cookie whose skip tells the current static level. The emitter will
27012:      * adjust the node's slot based on its stack depth model -- and, for global
80991:      * and eval code, js::frontend::CompileScript will adjust the slot
80634:      * again to include script->nfixed.
27012:      */
78294:     pn->setOp(JSOP_GETLOCAL);
48585:     pn->pn_cookie.set(tc->staticLevel, uint16(n));
27012:     pn->pn_dflags |= PND_LET | PND_BOUND;
27012: 
27012:     /*
53650:      * Define the let binding's property before storing pn in the the binding's
53650:      * slot indexed by n off the class-reserved slot base.
53650:      */
53650:     const Shape *shape = blockObj->defineBlockVariable(cx, ATOM_TO_JSID(atom), n);
53650:     if (!shape)
47497:         return false;
27012: 
27012:     /*
53650:      * Store pn temporarily in what would be shape-mapped slots in a cloned
53650:      * block object (once the prototype's final population is known, after all
53650:      * 'let' bindings for this block have been parsed). We free these slots in
80964:      * BytecodeEmitter.cpp:EmitEnterBlock so they don't tie up unused space
80634:      * in the so-called "static" prototype Block.
53650:      */
53650:     blockObj->setSlot(shape->slot, PrivateValue(pn));
47497:     return true;
27012: }
27012: 
27012: static void
80631: PopStatement(TreeContext *tc)
80631: {
80631:     StmtInfo *stmt = tc->topStmt;
27012: 
27012:     if (stmt->flags & SIF_SCOPE) {
54855:         JSObject *obj = stmt->blockBox->object;
53650:         JS_ASSERT(!obj->isClonedBlock());
27012: 
52503:         for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront()) {
69637:             JSAtom *atom = JSID_TO_ATOM(r.front().propid);
27012: 
27012:             /* Beware the empty destructuring dummy. */
40860:             if (atom == tc->parser->context->runtime->atomState.emptyAtom)
27012:                 continue;
72579:             tc->decls.remove(atom);
27012:         }
27012:     }
80632:     PopStatementTC(tc);
    1: }
    1: 
27112: static inline bool
80631: OuterLet(TreeContext *tc, StmtInfo *stmt, JSAtom *atom)
27112: {
27112:     while (stmt->downScope) {
80632:         stmt = LexicalLookup(tc, atom, NULL, stmt->downScope);
27112:         if (!stmt)
27112:             return false;
27112:         if (stmt->type == STMT_BLOCK)
27112:             return true;
27112:     }
27112:     return false;
27112: }
27112: 
41817: /*
41817:  * If we are generating global or eval-called-from-global code, bind a "gvar"
41817:  * here, as soon as possible. The JSOP_GETGVAR, etc., ops speed up interpreted
41817:  * global variable access by memoizing name-to-slot mappings during execution
41817:  * of the script prolog (via JSOP_DEFVAR/JSOP_DEFCONST). If the memoization
41817:  * can't be done due to a pre-existing property of the same name as the var or
41817:  * const but incompatible attributes/getter/setter/etc, these ops devolve to
41817:  * JSOP_NAME, etc.
41817:  *
41817:  * For now, don't try to lookup eval frame variables at compile time. This is
41817:  * sub-optimal: we could handle eval-called-from-global-code gvars since eval
41817:  * gets its own script and frame. The eval-from-function-code case is harder,
41817:  * since functions do not atomize gvars and then reserve their atom indexes as
41817:  * stack frame slots.
41817:  */
41817: static bool
80964: DefineGlobal(ParseNode *pn, BytecodeEmitter *bce, PropertyName *name)
80964: {
80990:     GlobalScope *globalScope = bce->globalScope;
52555:     JSObject *globalObj = globalScope->globalObj;
52555: 
80964:     if (!bce->compileAndGo() || !globalObj || bce->compilingForEval())
52555:         return true;
52555: 
80442:     AtomIndexAddPtr p = globalScope->names.lookupForAdd(name);
72579:     if (!p) {
80964:         JSContext *cx = bce->parser->context;
54477: 
54477:         JSObject *holder;
54477:         JSProperty *prop;
80442:         if (!globalObj->lookupProperty(cx, name, &holder, &prop))
52555:             return false;
54477: 
82024:         FunctionBox *funbox = pn->isKind(PNK_FUNCTION) ? pn->pn_funbox : NULL;
54477: 
54477:         GlobalScope::GlobalDef def;
54477:         if (prop) {
54477:             /*
54477:              * A few cases where we don't bother aggressively caching:
54477:              *   1) Function value changes.
54477:              *   2) Configurable properties.
54477:              *   3) Properties without slots, or with getters/setters.
54477:              */
54477:             const Shape *shape = (const Shape *)prop;
54477:             if (funbox ||
54477:                 globalObj != holder ||
54477:                 shape->configurable() ||
54477:                 !shape->hasSlot() ||
54477:                 !shape->hasDefaultGetterOrIsMethod() ||
54477:                 !shape->hasDefaultSetter()) {
52818:                 return true;
52818:             }
54477: 
54477:             def = GlobalScope::GlobalDef(shape->slot);
54477:         } else {
80442:             def = GlobalScope::GlobalDef(name, funbox);
54477:         }
54477: 
54477:         if (!globalScope->defs.append(def))
54477:             return false;
54477: 
72579:         jsatomid index = globalScope->names.count();
80442:         if (!globalScope->names.add(p, name, index))
54477:             return false;
54477: 
72579:         JS_ASSERT(index == globalScope->defs.length() - 1);
54477:     } else {
54477:         /*
54477:          * Functions can be redeclared, and the last one takes effect. Check
54477:          * for this and make sure to rewrite the definition.
54477:          *
54477:          * Note: This could overwrite an existing variable declaration, for
54477:          * example:
53540:          *   var c = []
53540:          *   function c() { }
53540:          *
54477:          * This rewrite is allowed because the function will be statically
54477:          * hoisted to the top of the script, and the |c = []| will just
54477:          * overwrite it at runtime.
54477:          */
82024:         if (pn->isKind(PNK_FUNCTION)) {
78294:             JS_ASSERT(pn->isArity(PN_FUNC));
72579:             jsatomid index = p.value();
54477:             globalScope->defs[index].funbox = pn->pn_funbox;
54477:         }
52818:     }
52818: 
52818:     pn->pn_dflags |= PND_GVAR;
52555: 
52555:     return true;
52555: }
52555: 
52795: static bool
80631: BindTopLevelVar(JSContext *cx, BindData *data, ParseNode *pn, TreeContext *tc)
41817: {
78294:     JS_ASSERT(pn->isOp(JSOP_NAME));
41884:     JS_ASSERT(!tc->inFunction());
41884: 
60145:     /* There's no need to optimize bindings if we're not compiling code. */
60145:     if (!tc->compiling())
52555:         return true;
52555: 
60145:     /*
60145:      * Bindings at top level in eval code aren't like bindings at top level in
60145:      * regular code, and we must handle them specially.
60145:      */
60145:     if (tc->parser->callerFrame) {
60145:         /*
60145:          * If the eval code is not strict mode code, such bindings are created
60145:          * from scratch in the the caller's environment (if the eval is direct)
60145:          * or in the global environment (if the eval is indirect) -- and they
60145:          * can be deleted.  Therefore we can't bind early.
60145:          */
60145:         if (!tc->inStrictMode())
60145:             return true;
60145: 
60145:         /*
60145:          * But if the eval code is strict mode code, bindings are added to a
60145:          * new environment specifically for that eval code's compilation, and
60145:          * they can't be deleted.  Thus strict mode eval code does not affect
60145:          * the caller's environment, and we can bind such names early.  (But
60145:          * note: strict mode eval code can still affect the global environment
60145:          * by performing an indirect eval of non-strict mode code.)
60145:          *
60145:          * However, optimizing such bindings requires either precarious
60145:          * type-punning or, ideally, a new kind of Call object specifically for
60145:          * strict mode eval frames.  Further, strict mode eval is not (yet)
60145:          * common.  So for now (until we rewrite the scope chain to not use
60145:          * objects?) just disable optimizations for top-level names in eval
60145:          * code.
60145:          */
60145:         return true;
60145:     }
41817: 
52825:     if (pn->pn_dflags & PND_CONST)
41817:         return true;
41817: 
60145:     /*
60145:      * If this is a global variable, we're compile-and-go, and a global object
60145:      * is present, try to bake in either an already available slot or a
60145:      * predicted slot that will be defined after compiling is completed.
60145:      */
80964:     return DefineGlobal(pn, tc->asBytecodeEmitter(), pn->pn_atom->asPropertyName());
60145: }
60145: 
60145: static bool
80631: BindFunctionLocal(JSContext *cx, BindData *data, MultiDeclRange &mdl, TreeContext *tc)
60145: {
60145:     JS_ASSERT(tc->inFunction());
60145: 
80631:     ParseNode *pn = data->pn;
74093:     JSAtom *name = pn->pn_atom;
74093: 
74093:     /*
74093:      * Don't create a local variable with the name 'arguments', per ECMA-262.
74093:      * Instead, 'var arguments' always restates that predefined binding of the
74093:      * lexical environment for function activations. Assignments to arguments
74093:      * must be handled specially -- see NoteLValue.
74093:      */
60145:     if (name == cx->runtime->atomState.argumentsAtom) {
78294:         pn->setOp(JSOP_ARGUMENTS);
60145:         pn->pn_dflags |= PND_BOUND;
60145:         return true;
60145:     }
60145: 
60145:     BindingKind kind = tc->bindings.lookup(cx, name, NULL);
60145:     if (kind == NONE) {
60145:         /*
60145:          * Property not found in current variable scope: we have not seen this
60145:          * variable before, so bind a new local variable for it. Any locals
60145:          * declared in a with statement body are handled at runtime, by script
60145:          * prolog JSOP_DEFVAR opcodes generated for global and heavyweight-
60145:          * function-local vars.
60145:          */
60145:         kind = (data->op == JSOP_DEFCONST) ? CONSTANT : VARIABLE;
60145: 
74093:         if (!BindLocalVariable(cx, tc, pn, kind))
60145:             return false;
78294:         pn->setOp(JSOP_GETLOCAL);
60145:         return true;
60145:     }
60145: 
60145:     if (kind == ARGUMENT) {
60145:         JS_ASSERT(tc->inFunction());
80631:         JS_ASSERT(!mdl.empty() && mdl.front()->kind() == Definition::ARG);
60145:     } else {
60145:         JS_ASSERT(kind == VARIABLE || kind == CONSTANT);
60145:     }
60145: 
60145:     return true;
41817: }
41817: 
    1: static JSBool
80631: BindVarOrConst(JSContext *cx, BindData *data, JSAtom *atom, TreeContext *tc)
80631: {
80631:     ParseNode *pn = data->pn;
35325: 
41817:     /* Default best op for pn is JSOP_NAME; we'll try to improve below. */
78294:     pn->setOp(JSOP_NAME);
41817: 
80442:     if (!CheckStrictBinding(cx, tc, atom->asPropertyName(), pn))
35325:         return false;
35325: 
80632:     StmtInfo *stmt = LexicalLookup(tc, atom, NULL);
64237: 
64237:     if (stmt && stmt->type == STMT_WITH) {
29379:         data->fresh = false;
54755:         pn->pn_dflags |= PND_DEOPTIMIZED;
58291:         tc->noteMightAliasLocals();
52825:         return true;
27012:     }
27012: 
72579:     MultiDeclRange mdl = tc->decls.lookupMulti(atom);
27012:     JSOp op = data->op;
27012: 
72579:     if (stmt || !mdl.empty()) {
80631:         Definition *dn = mdl.empty() ? NULL : mdl.front();
80631:         Definition::Kind dn_kind = dn ? dn->kind() : Definition::VAR;
80631: 
80631:         if (dn_kind == Definition::ARG) {
57812:             JSAutoByteString name;
57812:             if (!js_AtomToPrintableString(cx, atom, &name))
 8179:                 return JS_FALSE;
 8179: 
 8179:             if (op == JSOP_DEFCONST) {
40860:                 ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 8179:                                          JSREPORT_ERROR, JSMSG_REDECLARED_PARAM,
57812:                                          name.ptr());
 8179:                 return JS_FALSE;
 8179:             }
40860:             if (!ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 8179:                                           JSREPORT_WARNING | JSREPORT_STRICT,
57812:                                           JSMSG_VAR_HIDES_ARG, name.ptr())) {
 8179:                 return JS_FALSE;
 8179:             }
 8179:         } else {
28167:             bool error = (op == JSOP_DEFCONST ||
80631:                           dn_kind == Definition::CONST ||
80631:                           (dn_kind == Definition::LET &&
28167:                            (stmt->type != STMT_CATCH || OuterLet(tc, stmt, atom))));
28167: 
61450:             if (cx->hasStrictOption()
80631:                 ? op != JSOP_DEFVAR || dn_kind != Definition::VAR
28167:                 : error) {
57812:                 JSAutoByteString name;
57812:                 if (!js_AtomToPrintableString(cx, atom, &name) ||
40860:                     !ReportCompileErrorNumber(cx, TS(tc->parser), pn,
28167:                                               !error
27012:                                               ? JSREPORT_WARNING | JSREPORT_STRICT
27012:                                               : JSREPORT_ERROR,
27012:                                               JSMSG_REDECLARED_VAR,
80631:                                               Definition::kindString(dn_kind),
57812:                                               name.ptr())) {
27012:                     return JS_FALSE;
27012:                 }
27012:             }
27012:         }
27012:     }
27012: 
72579:     if (mdl.empty()) {
27012:         if (!Define(pn, atom, tc))
27012:             return JS_FALSE;
27012:     } else {
27012:         /*
27012:          * A var declaration never recreates an existing binding, it restates
27012:          * it and possibly reinitializes its value. Beware that if pn becomes a
72579:          * use of |mdl.defn()|, and if we have an initializer for this var or
27012:          * const (typically a const would ;-), then pn must be rewritten into a
82024:          * PNK_ASSIGN node. See js::Parser::variables, further below.
27012:          *
27012:          * A case such as let (x = 1) { var x = 2; print(x); } is even harder.
27012:          * There the x definition is hoisted but the x = 2 assignment mutates
27012:          * the block-local binding of x.
27012:          */
80631:         Definition *dn = mdl.front();
27012: 
29379:         data->fresh = false;
29379: 
78294:         if (!pn->isUsed()) {
27012:             /* Make pnu be a fresh name node that uses dn. */
80631:             ParseNode *pnu = pn;
27012: 
78294:             if (pn->isDefn()) {
82024:                 pnu = NameNode::create(PNK_NAME, atom, tc);
27012:                 if (!pnu)
27012:                     return JS_FALSE;
27012:             }
27012: 
27012:             LinkUseToDef(pnu, dn, tc);
78294:             pnu->setOp(JSOP_NAME);
27012:         }
27012: 
72579:         /* Find the first non-let binding of this atom. */
80631:         while (dn->kind() == Definition::LET) {
72579:             mdl.popFront();
72579:             if (mdl.empty())
72579:                 break;
72579:             dn = mdl.front();
72579:         }
72579: 
72579:         if (dn) {
27012:             JS_ASSERT_IF(data->op == JSOP_DEFCONST,
80631:                          dn->kind() == Definition::CONST);
27012:             return JS_TRUE;
27012:         }
27012: 
27012:         /*
27012:          * A var or const that is shadowed by one or more let bindings of the
27012:          * same name, but that has not been declared until this point, must be
27012:          * hoisted above the let bindings.
27012:          */
78294:         if (!pn->isDefn()) {
72579:             if (tc->lexdeps->lookup(atom)) {
72579:                 tc->lexdeps->remove(atom);
27012:             } else {
82024:                 ParseNode *pn2 = NameNode::create(PNK_NAME, atom, tc);
27012:                 if (!pn2)
27012:                     return JS_FALSE;
27012: 
27012:                 /* The token stream may be past the location for pn. */
27012:                 pn2->pn_pos = pn->pn_pos;
27012:                 pn = pn2;
27012:             }
78294:             pn->setOp(JSOP_NAME);
27012:         }
27012: 
80631:         if (!tc->decls.addHoist(atom, (Definition *) pn))
27012:             return JS_FALSE;
78294:         pn->setDefn(true);
27012:         pn->pn_dflags &= ~PND_PLACEHOLDER;
27012:     }
27012: 
27012:     if (data->op == JSOP_DEFCONST)
27012:         pn->pn_dflags |= PND_CONST;
27012: 
60145:     if (tc->inFunction())
74093:         return BindFunctionLocal(cx, data, mdl, tc);
74093: 
74093:     return BindTopLevelVar(cx, data, pn, tc);
    1: }
    1: 
57742: static bool
80631: MakeSetCall(JSContext *cx, ParseNode *pn, TreeContext *tc, uintN msg)
20908: {
78294:     JS_ASSERT(pn->isArity(PN_LIST));
78294:     JS_ASSERT(pn->isOp(JSOP_CALL) || pn->isOp(JSOP_EVAL) ||
78294:               pn->isOp(JSOP_FUNCALL) || pn->isOp(JSOP_FUNAPPLY));
57742:     if (!ReportStrictModeError(cx, TS(tc->parser), tc, pn, msg))
57742:         return false;
57742: 
80631:     ParseNode *pn2 = pn->pn_head;
82024:     if (pn2->isKind(PNK_FUNCTION) && (pn2->pn_funbox->tcflags & TCF_GENEXP_LAMBDA)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), pn, JSREPORT_ERROR, msg);
57742:         return false;
57742:     }
57742:     pn->pn_xflags |= PNX_SETCALL;
57742:     return true;
20908: }
20908: 
27012: static void
80631: NoteLValue(JSContext *cx, ParseNode *pn, TreeContext *tc, uintN dflag = PND_ASSIGNED)
27012: {
78294:     if (pn->isUsed()) {
80631:         Definition *dn = pn->pn_lexdef;
27012: 
27012:         /*
27012:          * Save the win of PND_INITIALIZED if we can prove 'var x;' and 'x = y'
27012:          * occur as direct kids of the same block with no forward refs to x.
27012:          */
28920:         if (!(dn->pn_dflags & (PND_INITIALIZED | PND_CONST | PND_PLACEHOLDER)) &&
28557:             dn->isBlockChild() &&
27012:             pn->isBlockChild() &&
27012:             dn->pn_blockid == pn->pn_blockid &&
28557:             dn->pn_pos.end <= pn->pn_pos.begin &&
27012:             dn->dn_uses == pn) {
27012:             dflag = PND_INITIALIZED;
27012:         }
27012: 
27012:         dn->pn_dflags |= dflag;
27012: 
47573:         if (dn->pn_cookie.isFree() || dn->frameLevel() < tc->staticLevel)
27012:             tc->flags |= TCF_FUN_SETS_OUTER_NAME;
27012:     }
27012: 
27012:     pn->pn_dflags |= dflag;
27012: 
59940:     /*
59940:      * Both arguments and the enclosing function's name are immutable bindings
59940:      * in ES5, so assignments to them must do nothing or throw a TypeError
59940:      * depending on code strictness.  Assignment to arguments is a syntax error
59940:      * in strict mode and thus cannot happen.  Outside strict mode, we optimize
59940:      * away assignment to the function name.  For assignment to function name
59940:      * to fail in strict mode, we must have a binding for it in the scope
59940:      * chain; we ensure this happens by making such functions heavyweight.
59940:      */
51096:     JSAtom *lname = pn->pn_atom;
72073:     if (lname == cx->runtime->atomState.argumentsAtom) {
72073:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
72073:         tc->countArgumentsUse(pn);
72073:     } else if (tc->inFunction() && lname == tc->fun()->atom) {
27012:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
27012:     }
59940: }
27012: 
    1: #if JS_HAS_DESTRUCTURING
    1: 
    1: static JSBool
80631: BindDestructuringVar(JSContext *cx, BindData *data, ParseNode *pn, TreeContext *tc)
    1: {
    1:     JSAtom *atom;
    1: 
    1:     /*
    1:      * Destructuring is a form of assignment, so just as for an initialized
    1:      * simple variable, we must check for assignment to 'arguments' and flag
    1:      * the enclosing function (if any) as heavyweight.
    1:      */
82024:     JS_ASSERT(pn->isKind(PNK_NAME));
    1:     atom = pn->pn_atom;
    1:     if (atom == cx->runtime->atomState.argumentsAtom)
    1:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1: 
    1:     data->pn = pn;
    1:     if (!data->binder(cx, data, atom, tc))
    1:         return JS_FALSE;
27012: 
27012:     /*
27012:      * Select the appropriate name-setting opcode, respecting eager selection
27012:      * done by the data->binder function.
27012:      */
27012:     if (pn->pn_dflags & PND_BOUND) {
60526:         JS_ASSERT(!(pn->pn_dflags & PND_GVAR));
78294:         pn->setOp(pn->isOp(JSOP_ARGUMENTS) ? JSOP_SETNAME : JSOP_SETLOCAL);
 8444:     } else {
78294:         pn->setOp((data->op == JSOP_DEFCONST) ? JSOP_SETCONST : JSOP_SETNAME);
27012:     }
27012: 
27012:     if (data->op == JSOP_DEFCONST)
27012:         pn->pn_dflags |= PND_CONST;
27012: 
27012:     NoteLValue(cx, pn, tc, PND_INITIALIZED);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Here, we are destructuring {... P: Q, ...} = R, where P is any id, Q is any
    1:  * LHS expression except a destructuring initialiser, and R is on the stack.
    1:  * Because R is already evaluated, the usual LHS-specialized bytecodes won't
    1:  * work.  After pushing R[P] we need to evaluate Q's "reference base" QB and
    1:  * then push its property name QN.  At this point the stack looks like
    1:  *
    1:  *   [... R, R[P], QB, QN]
    1:  *
    1:  * We need to set QB[QN] = R[P].  This is a job for JSOP_ENUMELEM, which takes
    1:  * its operands with left-hand side above right-hand side:
    1:  *
    1:  *   [rval, lval, xval]
    1:  *
    1:  * and pops all three values, setting lval[xval] = rval.  But we cannot select
    1:  * JSOP_ENUMELEM yet, because the LHS may turn out to be an arg or local var,
    1:  * which can be optimized further.  So we select JSOP_SETNAME.
    1:  */
    1: static JSBool
80631: BindDestructuringLHS(JSContext *cx, ParseNode *pn, TreeContext *tc)
    1: {
78294:     switch (pn->getKind()) {
82024:       case PNK_NAME:
27012:         NoteLValue(cx, pn, tc);
    1:         /* FALL THROUGH */
27012: 
82024:       case PNK_DOT:
82024:       case PNK_LB:
42747:         /*
42747:          * We may be called on a name node that has already been specialized,
42747:          * in the very weird and ECMA-262-required "for (var [x] = i in o) ..."
42747:          * case. See bug 558633.
42747:          */
78294:         if (!(js_CodeSpec[pn->getOp()].format & JOF_SET))
78294:             pn->setOp(JSOP_SETNAME);
    1:         break;
    1: 
82024:       case PNK_LP:
 7984:         if (!MakeSetCall(cx, pn, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
 1577:             return JS_FALSE;
    1:         break;
    1: 
    1: #if JS_HAS_XML_SUPPORT
82114:       case PNK_XMLUNARY:
82018:         JS_ASSERT(pn->isOp(JSOP_XMLNAME));
78294:         pn->setOp(JSOP_BINDXMLNAME);
    1:         break;
    1: #endif
    1: 
    1:       default:
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), pn,
 7984:                                  JSREPORT_ERROR, JSMSG_BAD_LEFTSIDE_OF_ASS);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
33753:  * Destructuring patterns can appear in two kinds of contexts:
28995:  *
33753:  * - assignment-like: assignment expressions and |for| loop heads.  In
33753:  *   these cases, the patterns' property value positions can be
33753:  *   arbitrary lvalue expressions; the destructuring is just a fancy
33753:  *   assignment.
33753:  *
33753:  * - declaration-like: |var| and |let| declarations, functions' formal
33753:  *   parameter lists, |catch| clauses, and comprehension tails.  In
33753:  *   these cases, the patterns' property value positions must be
33753:  *   simple names; the destructuring defines them as new variables.
33753:  *
33753:  * In both cases, other code parses the pattern as an arbitrary
40239:  * primaryExpr, and then, here in CheckDestructuring, verify that the
33753:  * tree is a valid destructuring expression.
33753:  *
33753:  * In assignment-like contexts, we parse the pattern with the
33753:  * TCF_DECL_DESTRUCTURING flag clear, so the lvalue expressions in the
40239:  * pattern are parsed normally.  primaryExpr links variable references
33753:  * into the appropriate use chains; creates placeholder definitions;
33753:  * and so on.  CheckDestructuring is called with |data| NULL (since we
33753:  * won't be binding any new names), and we specialize lvalues as
68922:  * appropriate.
33753:  *
33753:  * In declaration-like contexts, the normal variable reference
33753:  * processing would just be an obstruction, because we're going to
33753:  * define the names that appear in the property value positions as new
33753:  * variables anyway.  In this case, we parse the pattern with
40239:  * TCF_DECL_DESTRUCTURING set, which directs primaryExpr to leave
33753:  * whatever name nodes it creates unconnected.  Then, here in
33753:  * CheckDestructuring, we require the pattern's property value
33753:  * positions to be simple names, and define them as appropriate to the
33753:  * context.  For these calls, |data| points to the right sort of
33753:  * BindData.
33753:  *
33753:  * See also UndominateInitializers, immediately below. If you change
33753:  * either of these functions, you might have to change the other to
33753:  * match.
    1:  */
68922: static bool
80631: CheckDestructuring(JSContext *cx, BindData *data, ParseNode *left, TreeContext *tc)
68922: {
68922:     bool ok;
    1: 
82024:     if (left->isKind(PNK_ARRAYCOMP)) {
40860:         ReportCompileErrorNumber(cx, TS(tc->parser), left, JSREPORT_ERROR,
40320:                                  JSMSG_ARRAY_COMP_LEFTSIDE);
68922:         return false;
68922:     }
68922: 
82024:     if (left->isKind(PNK_RB)) {
80631:         for (ParseNode *pn = left->pn_head; pn; pn = pn->pn_next) {
    1:             /* Nullary comma is an elision; binary comma is an expression.*/
82024:             if (!pn->isKind(PNK_COMMA) || !pn->isArity(PN_NULLARY)) {
82024:                 if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC)) {
68922:                     ok = CheckDestructuring(cx, data, pn, tc);
    1:                 } else {
    1:                     if (data) {
82024:                         if (!pn->isKind(PNK_NAME)) {
68922:                             ReportCompileErrorNumber(cx, TS(tc->parser), pn, JSREPORT_ERROR,
68922:                                                      JSMSG_NO_VARIABLE_NAME);
68922:                             return false;
68922:                         }
    1:                         ok = BindDestructuringVar(cx, data, pn, tc);
    1:                     } else {
    1:                         ok = BindDestructuringLHS(cx, pn, tc);
    1:                     }
    1:                 }
    1:                 if (!ok)
68922:                     return false;
68922:             }
    1:         }
    1:     } else {
82024:         JS_ASSERT(left->isKind(PNK_RC));
80631:         for (ParseNode *pair = left->pn_head; pair; pair = pair->pn_next) {
82024:             JS_ASSERT(pair->isKind(PNK_COLON));
80631:             ParseNode *pn = pair->pn_right;
    1: 
82024:             if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC)) {
68922:                 ok = CheckDestructuring(cx, data, pn, tc);
    1:             } else if (data) {
82024:                 if (!pn->isKind(PNK_NAME)) {
68922:                     ReportCompileErrorNumber(cx, TS(tc->parser), pn, JSREPORT_ERROR,
68922:                                              JSMSG_NO_VARIABLE_NAME);
68922:                     return false;
68922:                 }
    1:                 ok = BindDestructuringVar(cx, data, pn, tc);
    1:             } else {
    1:                 ok = BindDestructuringLHS(cx, pn, tc);
    1:             }
    1:             if (!ok)
68922:                 return false;
    1:         }
    1:     }
    1: 
14688:     /*
14688:      * The catch/finally handler implementation in the interpreter assumes
14688:      * that any operation that introduces a new scope (like a "let" or "with"
14688:      * block) increases the stack depth. This way, it is possible to restore
14688:      * the scope chain based on stack depth of the handler alone. "let" with
14688:      * an empty destructuring pattern like in
14688:      *
14688:      *   let [] = 1;
14688:      *
14688:      * would violate this assumption as the there would be no let locals to
14688:      * store on the stack. To satisfy it we add an empty property to such
14688:      * blocks so that OBJ_BLOCK_COUNT(cx, blockObj), which gives the number of
14688:      * slots, would be always positive.
14688:      *
14688:      * Note that we add such a property even if the block has locals due to
14688:      * later let declarations in it. We optimize for code simplicity here,
14688:      * not the fastest runtime performance with empty [] or {}.
14688:      */
14688:     if (data &&
14688:         data->binder == BindLet &&
68922:         OBJ_BLOCK_COUNT(cx, tc->blockChain()) == 0 &&
69855:         !DefineNativeProperty(cx, tc->blockChain(),
53650:                               ATOM_TO_JSID(cx->runtime->atomState.emptyAtom),
48470:                               UndefinedValue(), NULL, NULL,
53650:                               JSPROP_ENUMERATE | JSPROP_PERMANENT,
69855:                               Shape::HAS_SHORTID, 0)) {
68922:         return false;
68922:     }
68922: 
68922:     return true;
    1: }
    1: 
28995: /*
68923:  * Extend the pn_pos.end source coordinate of each name in a destructuring
68923:  * binding such as
28995:  *
28995:  *   var [x, y] = [function () y, 42];
28995:  *
68923:  * to cover the entire initializer, so that the initialized bindings do not
68923:  * appear to dominate any closures in the initializer. See bug 496134.
28995:  *
40860:  * The quick-and-dirty dominance computation in Parser::setFunctionKinds is not
40860:  * very precise. With one-pass SSA construction from structured source code
28995:  * (see "Single-Pass Generation of Static Single Assignment Form for Structured
28995:  * Languages", Brandis and Mössenböck), we could do much better.
28995:  *
28995:  * See CheckDestructuring, immediately above. If you change either of these
28995:  * functions, you might have to change the other to match.
28995:  */
68923: static void
80631: UndominateInitializers(ParseNode *left, const TokenPtr &end, TreeContext *tc)
68923: {
82024:     if (left->isKind(PNK_RB)) {
80631:         for (ParseNode *pn = left->pn_head; pn; pn = pn->pn_next) {
28995:             /* Nullary comma is an elision; binary comma is an expression.*/
82024:             if (!pn->isKind(PNK_COMMA) || !pn->isArity(PN_NULLARY)) {
82024:                 if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC))
68923:                     UndominateInitializers(pn, end, tc);
68923:                 else
68923:                     pn->pn_pos.end = end;
68923:             }
28995:         }
28995:     } else {
82024:         JS_ASSERT(left->isKind(PNK_RC));
68923: 
80631:         for (ParseNode *pair = left->pn_head; pair; pair = pair->pn_next) {
82024:             JS_ASSERT(pair->isKind(PNK_COLON));
80631:             ParseNode *pn = pair->pn_right;
82024:             if (pn->isKind(PNK_RB) || pn->isKind(PNK_RC))
68923:                 UndominateInitializers(pn, end, tc);
68923:             else
68923:                 pn->pn_pos.end = end;
68923:         }
68923:     }
28995: }
28995: 
80631: ParseNode *
40860: Parser::destructuringExpr(BindData *data, TokenKind tt)
40239: {
82024:     JS_ASSERT(tokenStream.isCurrentTokenType(tt));
82024: 
33753:     tc->flags |= TCF_DECL_DESTRUCTURING;
80631:     ParseNode *pn = primaryExpr(tt, JS_FALSE);
33753:     tc->flags &= ~TCF_DECL_DESTRUCTURING;
    1:     if (!pn)
    1:         return NULL;
68922:     if (!CheckDestructuring(context, data, pn, tc))
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_DESTRUCTURING */
    1: 
80631: ParseNode *
40860: Parser::returnOrYield(bool useAssignExpr)
40221: {
82024:     TokenKind tt = tokenStream.currentToken().type;
72073:     if (!tc->inFunction()) {
72073:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_RETURN_OR_YIELD,
72073:                           (tt == TOK_RETURN) ? js_return_str : js_yield_str);
    1:         return NULL;
    1:     }
    1: 
82024:     ParseNode *pn = UnaryNode::create((tt == TOK_RETURN) ? PNK_RETURN : PNK_YIELD, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1: #if JS_HAS_GENERATORS
72073:     if (tt == TOK_YIELD) {
72073:         /*
72073:          * If we're within parens, we won't know if this is a generator expression until we see
72073:          * a |for| token, so we have to delay flagging the current function.
72073:          */
72073:         if (tc->parenDepth == 0) {
    1:             tc->flags |= TCF_FUN_IS_GENERATOR;
72073:         } else {
72073:             tc->yieldCount++;
72073:             tc->yieldNode = pn;
72073:         }
72073:     }
    1: #endif
    1: 
    1:     /* This is ugly, but we don't want to require a semicolon. */
82024:     TokenKind tt2 = tokenStream.peekTokenSameLine(TSF_OPERAND);
    1:     if (tt2 == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt2 != TOK_EOF && tt2 != TOK_EOL && tt2 != TOK_SEMI && tt2 != TOK_RC
    1: #if JS_HAS_GENERATORS
  339:         && (tt != TOK_YIELD ||
11844:             (tt2 != tt && tt2 != TOK_RB && tt2 != TOK_RP &&
11844:              tt2 != TOK_COLON && tt2 != TOK_COMMA))
    1: #endif
82024:         )
82024:     {
82024:         ParseNode *pn2 = useAssignExpr ? assignExpr() : expr();
    1:         if (!pn2)
    1:             return NULL;
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_EXPR;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         pn->pn_kid = pn2;
    1:     } else {
    1: #if JS_HAS_GENERATORS
    1:         if (tt == TOK_RETURN)
    1: #endif
    1:             tc->flags |= TCF_RETURN_VOID;
    1:     }
    1: 
    1:     if ((~tc->flags & (TCF_RETURN_EXPR | TCF_FUN_IS_GENERATOR)) == 0) {
    1:         /* As in Python (see PEP-255), disallow return v; in generators. */
64214:         ReportBadReturn(context, tc, pn, JSREPORT_ERROR,
    1:                         JSMSG_BAD_GENERATOR_RETURN,
    1:                         JSMSG_BAD_ANON_GENERATOR_RETURN);
    1:         return NULL;
    1:     }
    1: 
61450:     if (context->hasStrictOption() &&
    1:         (~tc->flags & (TCF_RETURN_EXPR | TCF_RETURN_VOID)) == 0 &&
64214:         !ReportBadReturn(context, tc, pn, JSREPORT_WARNING | JSREPORT_STRICT,
    1:                          JSMSG_NO_RETURN_VALUE,
    1:                          JSMSG_ANON_NO_RETURN_VALUE)) {
    1:         return NULL;
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
80631: static ParseNode *
80631: PushLexicalScope(JSContext *cx, TokenStream *ts, TreeContext *tc, StmtInfo *stmt)
80631: {
82024:     ParseNode *pn = LexicalScopeNode::create(PNK_LEXICALSCOPE, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
80631:     JSObject *obj = js_NewBlockObject(cx);
    1:     if (!obj)
    1:         return NULL;
    1: 
80631:     ObjectBox *blockbox = tc->parser->newObjectBox(obj);
27012:     if (!blockbox)
27012:         return NULL;
27012: 
80632:     PushBlockScope(tc, stmt, blockbox, -1);
78294:     pn->setOp(JSOP_LEAVEBLOCK);
27012:     pn->pn_objbox = blockbox;
47573:     pn->pn_cookie.makeFree();
27012:     pn->pn_dflags = 0;
27012:     if (!GenerateBlockId(tc, stmt->blockid))
27012:         return NULL;
27012:     pn->pn_blockid = stmt->blockid;
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1: 
80631: ParseNode *
40860: Parser::letBlock(JSBool statement)
    1: {
82024:     JS_ASSERT(tokenStream.currentToken().type == TOK_LET);
82024: 
82024:     /* Create the let binary node. */
82024:     ParseNode *pnlet = BinaryNode::create(PNK_LET, tc);
82024:     if (!pnlet)
82024:         return NULL;
82024: 
82024:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_LET);
82024: 
82024:     /* This is a let block or expression of the form: let (a, b, c) .... */
80631:     StmtInfo stmtInfo;
82024:     ParseNode *pnblock = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
    1:     if (!pnblock)
    1:         return NULL;
82024:     ParseNode *pn = pnblock;
    1:     pn->pn_expr = pnlet;
    1: 
40263:     pnlet->pn_left = variables(true);
    1:     if (!pnlet->pn_left)
    1:         return NULL;
27012:     pnlet->pn_left->pn_xflags = PNX_POPVAR;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_LET);
    1: 
40854:     if (statement && !tokenStream.matchToken(TOK_LC, TSF_OPERAND)) {
    1:         /*
54158:          * Strict mode eliminates a grammar ambiguity with unparenthesized
54158:          * LetExpressions in an ExpressionStatement. If followed immediately
54158:          * by an arguments list, it's ambiguous whether the let expression
54158:          * is the callee or the call is inside the let expression body.
54158:          *
54158:          * See bug 569464.
54158:          */
54158:         if (!ReportStrictModeError(context, &tokenStream, tc, pnlet,
54158:                                    JSMSG_STRICT_CODE_LET_EXPR_STMT)) {
54158:             return NULL;
54158:         }
54158: 
54158:         /*
    1:          * If this is really an expression in let statement guise, then we
    1:          * need to wrap the TOK_LET node in a TOK_SEMI node so that we pop
    1:          * the return value of the expression.
    1:          */
82024:         pn = UnaryNode::create(PNK_SEMI, tc);
    1:         if (!pn)
    1:             return NULL;
    1:         pn->pn_num = -1;
    1:         pn->pn_kid = pnblock;
    1: 
    1:         statement = JS_FALSE;
    1:     }
    1: 
    1:     if (statement) {
40263:         pnlet->pn_right = statements();
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_LET);
    1:     } else {
    1:         /*
    1:          * Change pnblock's opcode to the variant that propagates the last
    1:          * result down after popping the block, and clear statement.
    1:          */
78294:         pnblock->setOp(JSOP_LEAVEBLOCKEXPR);
40263:         pnlet->pn_right = assignExpr();
    1:         if (!pnlet->pn_right)
    1:             return NULL;
    1:     }
    1: 
27012:     PopStatement(tc);
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_BLOCK_SCOPE */
    1: 
27012: static bool
80631: PushBlocklikeStatement(StmtInfo *stmt, StmtType type, TreeContext *tc)
27012: {
80632:     PushStatement(tc, stmt, type, -1);
27012:     return GenerateBlockId(tc, stmt->blockid);
27012: }
27012: 
80631: static ParseNode *
80631: NewBindingNode(JSAtom *atom, TreeContext *tc, bool let = false)
80631: {
80631:     ParseNode *pn;
72579:     AtomDefnPtr removal;
72579: 
72579:     if ((pn = tc->decls.lookupFirst(atom))) {
27012:         JS_ASSERT(!pn->isPlaceholder());
27012:     } else {
72579:         removal = tc->lexdeps->lookup(atom);
72579:         pn = removal ? removal.value() : NULL;
72579:         JS_ASSERT_IF(pn, pn->isPlaceholder());
27012:     }
27012: 
27012:     if (pn) {
78294:         JS_ASSERT(pn->isDefn());
27012: 
27012:         /*
27012:          * A let binding at top level becomes a var before we get here, so if
27012:          * pn and tc have the same blockid then that id must not be the bodyid.
27012:          * If pn is a forward placeholder definition from the same or a higher
27012:          * block then we claim it.
27012:          */
27012:         JS_ASSERT_IF(let && pn->pn_blockid == tc->blockid(),
27012:                      pn->pn_blockid != tc->bodyid);
27012: 
27012:         if (pn->isPlaceholder() && pn->pn_blockid >= (let ? tc->blockid() : tc->bodyid)) {
27012:             if (let)
27012:                 pn->pn_blockid = tc->blockid();
27012: 
72579:             tc->lexdeps->remove(removal);
27012:             return pn;
27012:         }
27012:     }
27012: 
27012:     /* Make a new node for this declarator name (or destructuring pattern). */
82024:     JS_ASSERT(tc->parser->tokenStream.currentToken().type == TOK_NAME);
82024:     pn = NameNode::create(PNK_NAME, atom, tc);
27012:     if (!pn)
27012:         return NULL;
72073: 
72073:     if (atom == tc->parser->context->runtime->atomState.argumentsAtom)
72073:         tc->countArgumentsUse(pn);
72073: 
27012:     return pn;
27012: }
27012: 
80631: ParseNode *
57728: Parser::switchStatement()
    1: {
82024:     JS_ASSERT(tc->parser->tokenStream.currentToken().type == TOK_SWITCH);
82024:     ParseNode *pn = BinaryNode::create(PNK_SWITCH, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_SWITCH);
    1: 
    1:     /* pn1 points to the switch's discriminant. */
80631:     ParseNode *pn1 = parenExpr();
    1:     if (!pn1)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_SWITCH);
    1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_SWITCH);
    1: 
27012:     /*
27012:      * NB: we must push stmtInfo before calling GenerateBlockIdForStmtNode
27012:      * because that function states tc->topStmt->blockid.
27012:      */
80631:     StmtInfo stmtInfo;
80632:     PushStatement(tc, &stmtInfo, STMT_SWITCH, -1);
27012: 
    1:     /* pn2 is a list of case nodes. The default case has pn_left == NULL */
82024:     ParseNode *pn2 = ListNode::create(PNK_LC, tc);
    1:     if (!pn2)
    1:         return NULL;
27012:     pn2->makeEmpty();
27012:     if (!GenerateBlockIdForStmtNode(pn2, tc))
27012:         return NULL;
82024:     ParseNode *saveBlock = tc->blockNode;
    1:     tc->blockNode = pn2;
    1: 
82024:     bool seenDefault = false;
57728:     TokenKind tt;
40354:     while ((tt = tokenStream.getToken()) != TOK_RC) {
80631:         ParseNode *pn3;
    1:         switch (tt) {
    1:           case TOK_DEFAULT:
    1:             if (seenDefault) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOO_MANY_DEFAULTS);
    1:                 return NULL;
    1:             }
82024:             seenDefault = true;
82024:             pn3 = BinaryNode::create(PNK_DEFAULT, tc);
82024:             if (!pn3)
82024:                 return NULL;
82024:             break;
    1: 
    1:           case TOK_CASE:
57728:           {
82024:             pn3 = BinaryNode::create(PNK_CASE, tc);
    1:             if (!pn3)
    1:                 return NULL;
40263:             pn3->pn_left = expr();
    1:             if (!pn3->pn_left)
    1:                 return NULL;
82024:             break;
82024:           }
82024: 
82024:           case TOK_ERROR:
82024:             return NULL;
82024: 
82024:           default:
82024:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_SWITCH);
82024:             return NULL;
82024:         }
82024: 
27012:         pn2->append(pn3);
    1:         if (pn2->pn_count == JS_BIT(16)) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOO_MANY_CASES);
    1:             return NULL;
    1:         }
82024: 
    1:         MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_AFTER_CASE);
    1: 
82024:         ParseNode *pn4 = ListNode::create(PNK_LC, tc);
    1:         if (!pn4)
    1:             return NULL;
27012:         pn4->makeEmpty();
40854:         while ((tt = tokenStream.peekToken(TSF_OPERAND)) != TOK_RC &&
    1:                tt != TOK_CASE && tt != TOK_DEFAULT) {
    1:             if (tt == TOK_ERROR)
    1:                 return NULL;
82024:             ParseNode *pn5 = statement();
    1:             if (!pn5)
    1:                 return NULL;
    1:             pn4->pn_pos.end = pn5->pn_pos.end;
27012:             pn4->append(pn5);
40854:         }
    1: 
    1:         /* Fix the PN_LIST so it doesn't begin at the TOK_COLON. */
    1:         if (pn4->pn_head)
    1:             pn4->pn_pos.begin = pn4->pn_head->pn_pos.begin;
    1:         pn3->pn_pos.end = pn4->pn_pos.end;
    1:         pn3->pn_right = pn4;
    1:     }
    1: 
    1:     /*
    1:      * Handle the case where there was a let declaration in any case in
    1:      * the switch body, but not within an inner block.  If it replaced
    1:      * tc->blockNode with a new block node then we must refresh pn2 and
    1:      * then restore tc->blockNode.
    1:      */
    1:     if (tc->blockNode != pn2)
    1:         pn2 = tc->blockNode;
    1:     tc->blockNode = saveBlock;
27012:     PopStatement(tc);
    1: 
40270:     pn->pn_pos.end = pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1:     pn->pn_left = pn1;
    1:     pn->pn_right = pn2;
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
57728: Parser::forStatement()
    1: {
82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_FOR));
82024: 
80631:     ParseNode *pnseq = NULL;
    1: #if JS_HAS_BLOCK_SCOPE
80631:     ParseNode *pnlet = NULL;
80631:     StmtInfo blockInfo;
    1: #endif
    1: 
    1:     /* A FOR node is binary, left is loop control and right is the body. */
82024:     ParseNode *pn = BinaryNode::create(PNK_FOR, tc);
    1:     if (!pn)
    1:         return NULL;
80631:     StmtInfo stmtInfo;
80632:     PushStatement(tc, &stmtInfo, STMT_FOR_LOOP, -1);
    1: 
78294:     pn->setOp(JSOP_ITER);
15613:     pn->pn_iflags = 0;
40354:     if (tokenStream.matchToken(TOK_NAME)) {
80443:         if (tokenStream.currentToken().name() == context->runtime->atomState.eachAtom)
15613:             pn->pn_iflags = JSITER_FOREACH;
    1:         else
40354:             tokenStream.ungetToken();
    1:     }
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
81587: 
81587: #ifdef JS_HAS_BLOCK_SCOPE
27012:     bool let = false;
27012: #endif
27012: 
81587:     /*
81587:      * True if we have 'for (var/let/const ...)', except in the oddball case
81587:      * where 'let' begins a let-expression in 'for (let (...) ...)'.
81587:      */
81587:     bool forDecl = false;
81587: 
81587:     /* Set to 'x' in 'for (x ;... ;...)' or 'for (x in ...)'. */
80631:     ParseNode *pn1;
81587: 
81587:     {
81587:         TokenKind tt = tokenStream.peekToken(TSF_OPERAND);
    1:         if (tt == TOK_SEMI) {
74052:             if (pn->pn_iflags & JSITER_FOREACH) {
74052:                 reportErrorNumber(pn, JSREPORT_ERROR, JSMSG_BAD_FOR_EACH_LOOP);
74052:                 return NULL;
74052:             }
    1: 
    1:             pn1 = NULL;
    1:         } else {
    1:             /*
    1:              * Set pn1 to a var list or an initializing expression.
    1:              *
    1:              * Set the TCF_IN_FOR_INIT flag during parsing of the first clause
    1:              * of the for statement.  This flag will be used by the RelExpr
    1:              * production; if it is set, then the 'in' keyword will not be
    1:              * recognized as an operator, leaving it available to be parsed as
    1:              * part of a for/in loop.
    1:              *
    1:              * A side effect of this restriction is that (unparenthesized)
    1:              * expressions involving an 'in' operator are illegal in the init
    1:              * clause of an ordinary for loop.
    1:              */
    1:             tc->flags |= TCF_IN_FOR_INIT;
    1:             if (tt == TOK_VAR) {
81587:                 forDecl = true;
40354:                 (void) tokenStream.getToken();
40263:                 pn1 = variables(false);
    1: #if JS_HAS_BLOCK_SCOPE
    1:             } else if (tt == TOK_LET) {
27012:                 let = true;
40354:                 (void) tokenStream.getToken();
40354:                 if (tokenStream.peekToken() == TOK_LP) {
40263:                     pn1 = letBlock(JS_FALSE);
    1:                 } else {
81587:                     forDecl = true;
40239:                     pnlet = PushLexicalScope(context, &tokenStream, tc, &blockInfo);
    1:                     if (!pnlet)
    1:                         return NULL;
 9976:                     blockInfo.flags |= SIF_FOR_BLOCK;
40263:                     pn1 = variables(false);
    1:                 }
    1: #endif
    1:             } else {
40263:                 pn1 = expr();
    1:             }
    1:             tc->flags &= ~TCF_IN_FOR_INIT;
    1:             if (!pn1)
    1:                 return NULL;
    1:         }
81587:     }
    1: 
    1:     /*
    1:      * We can be sure that it's a for/in loop if there's still an 'in'
    1:      * keyword here, even if JavaScript recognizes 'in' as an operator,
    1:      * as we've excluded 'in' from being parsed in RelExpr by setting
80631:      * the TCF_IN_FOR_INIT flag in our TreeContext.
80631:      */
82024:     TokenPos pos = tokenStream.currentToken().pos;
82024:     ParseNode *pn2, *pn3, *pn4;
40354:     if (pn1 && tokenStream.matchToken(TOK_IN)) {
74052:         /*
74052:          * Parse the rest of the for/in head.
74052:          *
74052:          * Here pn1 is everything to the left of 'in'. At the end of this block,
74052:          * pn1 is a decl or NULL, pn2 is the assignment target that receives the
74052:          * enumeration value each iteration, and pn3 is the rhs of 'in'.
74052:          */
15613:         pn->pn_iflags |= JSITER_ENUMERATE;
    1:         stmtInfo.type = STMT_FOR_IN_LOOP;
    1: 
    1:         /* Check that the left side of the 'in' is valid. */
81587:         if (forDecl
78294:             ? (pn1->pn_count > 1 || pn1->isOp(JSOP_DEFCONST)
    1: #if JS_HAS_DESTRUCTURING
61450:                || (versionNumber() == JSVERSION_1_7 &&
78294:                    pn->isOp(JSOP_ITER) &&
15613:                    !(pn->pn_iflags & JSITER_FOREACH) &&
82024:                    (pn1->pn_head->isKind(PNK_RC) ||
82024:                     (pn1->pn_head->isKind(PNK_RB) &&
    1:                      pn1->pn_head->pn_count != 2) ||
82024:                     (pn1->pn_head->isKind(PNK_ASSIGN) &&
82024:                      (!pn1->pn_head->pn_left->isKind(PNK_RB) ||
    1:                       pn1->pn_head->pn_left->pn_count != 2))))
    1: #endif
    1:               )
82024:             : (!pn1->isKind(PNK_NAME) &&
82024:                !pn1->isKind(PNK_DOT) &&
    1: #if JS_HAS_DESTRUCTURING
61450:                ((versionNumber() == JSVERSION_1_7 &&
78294:                  pn->isOp(JSOP_ITER) &&
15613:                  !(pn->pn_iflags & JSITER_FOREACH))
82024:                 ? (!pn1->isKind(PNK_RB) || pn1->pn_count != 2)
82024:                 : (!pn1->isKind(PNK_RB) && !pn1->isKind(PNK_RC))) &&
    1: #endif
82024:                !pn1->isKind(PNK_LP) &&
    1: #if JS_HAS_XML_SUPPORT
82114:                !pn1->isKind(PNK_XMLUNARY) &&
    1: #endif
82024:                !pn1->isKind(PNK_LB)))
82024:         {
42671:             reportErrorNumber(pn1, JSREPORT_ERROR, JSMSG_BAD_FOR_LEFTSIDE);
    1:             return NULL;
    1:         }
    1: 
74052:         /*
74052:          * After the following if-else, pn2 will point to the name or
74052:          * destructuring pattern on in's left. pn1 will point to the decl, if
74052:          * any, else NULL. Note that the "declaration with initializer" case
74052:          * rewrites the loop-head, moving the decl and setting pn1 to NULL.
74052:          */
74052:         pn2 = NULL;
27012:         uintN dflag = PND_ASSIGNED;
81587:         if (forDecl) {
74052:             /* Tell EmitVariables that pn1 is part of a for/in. */
27012:             pn1->pn_xflags |= PNX_FORINVAR;
    1: 
    1:             pn2 = pn1->pn_head;
82024:             if ((pn2->isKind(PNK_NAME) && pn2->maybeExpr())
20413: #if JS_HAS_DESTRUCTURING
82024:                 || pn2->isKind(PNK_ASSIGN)
20413: #endif
82024:                 )
82024:             {
74052:                 /*
74052:                  * Declaration with initializer.
74052:                  *
74052:                  * Rewrite 'for (<decl> x = i in o)' where <decl> is 'var' or
74052:                  * 'const' to hoist the initializer or the entire decl out of
81587:                  * the loop head.
74052:                  */
60541: #if JS_HAS_BLOCK_SCOPE
81587:                 if (let) {
60541:                     reportErrorNumber(pn2, JSREPORT_ERROR, JSMSG_INVALID_FOR_IN_INIT);
60541:                     return NULL;
60541:                 }
60541: #endif /* JS_HAS_BLOCK_SCOPE */
60541: 
82024:                 pnseq = ListNode::create(PNK_SEQ, tc);
20413:                 if (!pnseq)
20413:                     return NULL;
20413:                 pnseq->pn_pos.begin = pn->pn_pos.begin;
27012: 
27012:                 dflag = PND_INITIALIZED;
27012: 
20413:                 /*
20413:                  * All of 'var x = i' is hoisted above 'for (x in o)',
20413:                  * so clear PNX_FORINVAR.
20413:                  *
20413:                  * Request JSOP_POP here since the var is for a simple
20413:                  * name (it is not a destructuring binding's left-hand
20413:                  * side) and it has an initializer.
20413:                  */
27012:                 pn1->pn_xflags &= ~PNX_FORINVAR;
27012:                 pn1->pn_xflags |= PNX_POPVAR;
27012:                 pnseq->initList(pn1);
20413: 
20413: #if JS_HAS_DESTRUCTURING
82024:                 if (pn2->isKind(PNK_ASSIGN)) {
74052:                     pn2 = pn2->pn_left;
82024:                     JS_ASSERT(pn2->isKind(PNK_RB) || pn2->isKind(PNK_RC) ||
82024:                               pn2->isKind(PNK_NAME));
74052:                 }
20413: #endif
74052:                 pn1 = NULL;
74052:             }
74052: 
74052:             /*
74052:              * pn2 is part of a declaration. Make a copy that can be passed to
74052:              * EmitAssignment.
74052:              */
74052:             pn2 = CloneLeftHandSide(pn2, tc);
74052:             if (!pn2)
74052:                 return NULL;
74052:         } else {
74052:             /* Not a declaration. */
20413:             pn2 = pn1;
74052:             pn1 = NULL;
74052: 
74052:             if (!setAssignmentLhsOps(pn2, JSOP_NOP))
74052:                 return NULL;
    1:         }
    1: 
78294:         switch (pn2->getKind()) {
82024:           case PNK_NAME:
    1:             /* Beware 'for (arguments in ...)' with or without a 'var'. */
40239:             NoteLValue(context, pn2, tc, dflag);
    1:             break;
    1: 
    1: #if JS_HAS_DESTRUCTURING
82024:           case PNK_ASSIGN:
74052:             JS_NOT_REACHED("forStatement TOK_ASSIGN");
74052:             break;
74052: 
82024:           case PNK_RB:
82024:           case PNK_RC:
61450:             if (versionNumber() == JSVERSION_1_7) {
 1599:                 /*
 1599:                  * Destructuring for-in requires [key, value] enumeration
 1599:                  * in JS1.7.
 1599:                  */
78294:                 JS_ASSERT(pn->isOp(JSOP_ITER));
15613:                 if (!(pn->pn_iflags & JSITER_FOREACH))
15613:                     pn->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
 1599:             }
    1:             break;
    1: #endif
    1: 
    1:           default:;
    1:         }
    1: 
27012:         /*
27012:          * Parse the object expression as the right operand of 'in', first
27012:          * removing the top statement from the statement-stack if this is a
27012:          * 'for (let x in y)' loop.
27012:          */
27012: #if JS_HAS_BLOCK_SCOPE
80631:         StmtInfo *save = tc->topStmt;
27012:         if (let)
27012:             tc->topStmt = save->down;
27012: #endif
74052:         pn3 = expr();
74141:         if (!pn3)
74141:             return NULL;
27012: #if JS_HAS_BLOCK_SCOPE
27012:         if (let)
27012:             tc->topStmt = save;
27012: #endif
27012: 
82024:         pn4 = TernaryNode::create(PNK_IN, tc);
82024:         if (!pn4)
82024:             return NULL;
    1:     } else {
74052:         if (pn->pn_iflags & JSITER_FOREACH) {
74052:             reportErrorNumber(pn, JSREPORT_ERROR, JSMSG_BAD_FOR_EACH_LOOP);
74052:             return NULL;
74052:         }
78294:         pn->setOp(JSOP_NOP);
    1: 
    1:         /* Parse the loop condition or null into pn2. */
    1:         MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_INIT);
81587:         TokenKind tt = tokenStream.peekToken(TSF_OPERAND);
    1:         if (tt == TOK_SEMI) {
    1:             pn2 = NULL;
    1:         } else {
40263:             pn2 = expr();
    1:             if (!pn2)
    1:                 return NULL;
    1:         }
    1: 
    1:         /* Parse the update expression or null into pn3. */
    1:         MUST_MATCH_TOKEN(TOK_SEMI, JSMSG_SEMI_AFTER_FOR_COND);
40854:         tt = tokenStream.peekToken(TSF_OPERAND);
    1:         if (tt == TOK_RP) {
    1:             pn3 = NULL;
    1:         } else {
40263:             pn3 = expr();
    1:             if (!pn3)
    1:                 return NULL;
    1:         }
    1: 
82024:         pn4 = TernaryNode::create(PNK_FORHEAD, tc);
82024:         if (!pn4)
82024:             return NULL;
82024:     }
82024:     pn4->pn_pos = pos;
78294:     pn4->setOp(JSOP_NOP);
    1:     pn4->pn_kid1 = pn1;
    1:     pn4->pn_kid2 = pn2;
    1:     pn4->pn_kid3 = pn3;
    1:     pn->pn_left = pn4;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
    1: 
    1:     /* Parse the loop body into pn->pn_right. */
40263:     pn2 = statement();
    1:     if (!pn2)
    1:         return NULL;
    1:     pn->pn_right = pn2;
    1: 
    1:     /* Record the absolute line number for source note emission. */
    1:     pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
    1:     if (pnlet) {
27012:         PopStatement(tc);
    1:         pnlet->pn_expr = pn;
    1:         pn = pnlet;
    1:     }
    1: #endif
20413:     if (pnseq) {
20413:         pnseq->pn_pos.end = pn->pn_pos.end;
27012:         pnseq->append(pn);
20413:         pn = pnseq;
20413:     }
27012:     PopStatement(tc);
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
57728: Parser::tryStatement()
57728: {
82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_TRY));
    1: 
    1:     /*
    1:      * try nodes are ternary.
40239:      * kid1 is the try statement
    1:      * kid2 is the catch node list or null
40239:      * kid3 is the finally statement
    1:      *
    1:      * catch nodes are ternary.
    1:      * kid1 is the lvalue (TOK_NAME, TOK_LB, or TOK_LC)
    1:      * kid2 is the catch guard or null if no guard
    1:      * kid3 is the catch block
    1:      *
    1:      * catch lvalue nodes are either:
    1:      *   TOK_NAME for a single identifier
    1:      *   TOK_RB or TOK_RC for a destructuring left-hand side
    1:      *
40239:      * finally nodes are TOK_LC statement lists.
40221:      */
82024:     ParseNode *pn = TernaryNode::create(PNK_TRY, tc);
    1:     if (!pn)
    1:         return NULL;
78294:     pn->setOp(JSOP_NOP);
    1: 
    1:     MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_TRY);
80631:     StmtInfo stmtInfo;
27012:     if (!PushBlocklikeStatement(&stmtInfo, STMT_TRY, tc))
27012:         return NULL;
40263:     pn->pn_kid1 = statements();
    1:     if (!pn->pn_kid1)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_TRY);
27012:     PopStatement(tc);
    1: 
82024:     ParseNode *lastCatch;
82024:     ParseNode *catchList = NULL;
57728:     TokenKind tt = tokenStream.getToken();
    1:     if (tt == TOK_CATCH) {
82024:         catchList = ListNode::create(PNK_CATCHLIST, tc);
    1:         if (!catchList)
    1:             return NULL;
27012:         catchList->makeEmpty();
    1:         lastCatch = NULL;
    1: 
    1:         do {
80631:             ParseNode *pnblock;
    1:             BindData data;
    1: 
    1:             /* Check for another catch after unconditional catch. */
    1:             if (lastCatch && !lastCatch->pn_kid2) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_AFTER_GENERAL);
    1:                 return NULL;
    1:             }
    1: 
    1:             /*
    1:              * Create a lexical scope node around the whole catch clause,
    1:              * including the head.
    1:              */
40239:             pnblock = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
    1:             if (!pnblock)
    1:                 return NULL;
    1:             stmtInfo.type = STMT_CATCH;
    1: 
    1:             /*
    1:              * Legal catch forms are:
    1:              *   catch (lhs)
    1:              *   catch (lhs if <boolean_expression>)
    1:              * where lhs is a name or a destructuring left-hand side.
    1:              * (the latter is legal only #ifdef JS_HAS_CATCH_GUARD)
    1:              */
82024:             ParseNode *pn2 = TernaryNode::create(PNK_CATCH, tc);
    1:             if (!pn2)
    1:                 return NULL;
    1:             pnblock->pn_expr = pn2;
    1:             MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_CATCH);
    1: 
    1:             /*
    1:              * Contrary to ECMA Ed. 3, the catch variable is lexically
    1:              * scoped, not a property of a new Object instance.  This is
    1:              * an intentional change that anticipates ECMA Ed. 4.
    1:              */
    1:             data.pn = NULL;
    1:             data.op = JSOP_NOP;
    1:             data.binder = BindLet;
27012:             data.let.overflow = JSMSG_TOO_MANY_CATCH_VARS;
    1: 
40354:             tt = tokenStream.getToken();
80631:             ParseNode *pn3;
    1:             switch (tt) {
    1: #if JS_HAS_DESTRUCTURING
    1:               case TOK_LB:
    1:               case TOK_LC:
40263:                 pn3 = destructuringExpr(&data, tt);
    1:                 if (!pn3)
    1:                     return NULL;
    1:                 break;
    1: #endif
    1: 
    1:               case TOK_NAME:
57728:               {
80443:                 JSAtom *label = tokenStream.currentToken().name();
33754:                 pn3 = NewBindingNode(label, tc, true);
27012:                 if (!pn3)
27012:                     return NULL;
27012:                 data.pn = pn3;
40239:                 if (!data.binder(context, &data, label, tc))
26970:                     return NULL;
    1:                 break;
57728:               }
    1: 
    1:               default:
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_IDENTIFIER);
    1:                 return NULL;
    1:             }
    1: 
    1:             pn2->pn_kid1 = pn3;
    1: #if JS_HAS_CATCH_GUARD
    1:             /*
    1:              * We use 'catch (x if x === 5)' (not 'catch (x : x === 5)')
    1:              * to avoid conflicting with the JS2/ECMAv4 type annotation
    1:              * catchguard syntax.
    1:              */
40354:             if (tokenStream.matchToken(TOK_IF)) {
40263:                 pn2->pn_kid2 = expr();
    1:                 if (!pn2->pn_kid2)
    1:                     return NULL;
    1:             }
    1: #endif
    1:             MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_CATCH);
    1: 
    1:             MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_CATCH);
40263:             pn2->pn_kid3 = statements();
    1:             if (!pn2->pn_kid3)
    1:                 return NULL;
    1:             MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_CATCH);
27012:             PopStatement(tc);
27012: 
27012:             catchList->append(pnblock);
    1:             lastCatch = pn2;
40854:             tt = tokenStream.getToken(TSF_OPERAND);
    1:         } while (tt == TOK_CATCH);
    1:     }
    1:     pn->pn_kid2 = catchList;
    1: 
    1:     if (tt == TOK_FINALLY) {
    1:         MUST_MATCH_TOKEN(TOK_LC, JSMSG_CURLY_BEFORE_FINALLY);
27012:         if (!PushBlocklikeStatement(&stmtInfo, STMT_FINALLY, tc))
27012:             return NULL;
40263:         pn->pn_kid3 = statements();
    1:         if (!pn->pn_kid3)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_AFTER_FINALLY);
27012:         PopStatement(tc);
    1:     } else {
40354:         tokenStream.ungetToken();
    1:     }
    1:     if (!catchList && !pn->pn_kid3) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_OR_FINALLY);
    1:         return NULL;
    1:     }
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
57728: Parser::withStatement()
52554: {
82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_WITH));
82024: 
35305:     /*
35305:      * In most cases, we want the constructs forbidden in strict mode
35305:      * code to be a subset of those that JSOPTION_STRICT warns about, and
40320:      * we should use ReportStrictModeError.  However, 'with' is the sole
35305:      * instance of a construct that is forbidden in strict mode code, but
35305:      * doesn't even merit a warning under JSOPTION_STRICT.  See
35305:      * https://bugzilla.mozilla.org/show_bug.cgi?id=514576#c1.
35305:      */
35305:     if (tc->flags & TCF_STRICT_MODE_CODE) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_STRICT_CODE_WITH);
35305:         return NULL;
35305:     }
35305: 
82024:     ParseNode *pn = BinaryNode::create(PNK_WITH, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_BEFORE_WITH);
80631:     ParseNode *pn2 = parenExpr();
    1:     if (!pn2)
    1:         return NULL;
    1:     MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_WITH);
    1:     pn->pn_left = pn2;
    1: 
80631:     ParseNode *oldWith = tc->innermostWith;
52554:     tc->innermostWith = pn;
52554: 
80631:     StmtInfo stmtInfo;
80632:     PushStatement(tc, &stmtInfo, STMT_WITH, -1);
40263:     pn2 = statement();
    1:     if (!pn2)
    1:         return NULL;
27012:     PopStatement(tc);
    1: 
    1:     pn->pn_pos.end = pn2->pn_pos.end;
    1:     pn->pn_right = pn2;
    1:     tc->flags |= TCF_FUN_HEAVYWEIGHT;
52554:     tc->innermostWith = oldWith;
52554: 
52554:     /*
52554:      * Make sure to deoptimize lexical dependencies inside the |with|
52554:      * to safely optimize binding globals (see bug 561923).
52554:      */
72579:     for (AtomDefnRange r = tc->lexdeps->all(); !r.empty(); r.popFront()) {
80631:         Definition *defn = r.front().value();
80631:         Definition *lexdep = defn->resolve();
52554:         DeoptimizeUsesWithin(lexdep, pn->pn_pos);
52554:     }
52554: 
    1:     return pn;
52554: }
    1: 
    1: #if JS_HAS_BLOCK_SCOPE
80631: ParseNode *
57728: Parser::letStatement()
    1: {
80631:     ParseNode *pn;
57728:     do {
    1:         /* Check for a let statement or let expression. */
40354:         if (tokenStream.peekToken() == TOK_LP) {
40263:             pn = letBlock(JS_TRUE);
78294:             if (!pn || pn->isOp(JSOP_LEAVEBLOCK))
    1:                 return pn;
    1: 
    1:             /* Let expressions require automatic semicolon insertion. */
82024:             JS_ASSERT(pn->isKind(PNK_SEMI) || pn->isOp(JSOP_LEAVEBLOCKEXPR));
    1:             break;
    1:         }
    1: 
    1:         /*
80631:          * This is a let declaration. We must be directly under a block per the
80631:          * proposed ES4 specs, but not an implicit block created due to
 9976:          * 'for (let ...)'. If we pass this error test, make the enclosing
80631:          * StmtInfo be our scope. Further let declarations in this block will
80631:          * find this scope statement and use the same block object.
 9976:          *
 9976:          * If we are the first let declaration in this block (i.e., when the
80631:          * enclosing maybe-scope StmtInfo isn't yet a scope statement) then
 9976:          * we also need to set tc->blockNode to be our TOK_LEXICALSCOPE.
    1:          */
80631:         StmtInfo *stmt = tc->topStmt;
 9976:         if (stmt &&
 9976:             (!STMT_MAYBE_SCOPE(stmt) || (stmt->flags & SIF_FOR_BLOCK))) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_LET_DECL_NOT_IN_BLOCK);
 9832:             return NULL;
    1:         }
    1: 
    1:         if (stmt && (stmt->flags & SIF_SCOPE)) {
54855:             JS_ASSERT(tc->blockChainBox == stmt->blockBox);
    1:         } else {
16379:             if (!stmt || (stmt->flags & SIF_BODY_BLOCK)) {
    1:                 /*
16379:                  * ES4 specifies that let at top level and at body-block scope
16379:                  * does not shadow var, so convert back to var.
    1:                  */
40854:                 tokenStream.mungeCurrentToken(TOK_VAR, JSOP_DEFVAR);
40239: 
40263:                 pn = variables(false);
    1:                 if (!pn)
    1:                     return NULL;
27012:                 pn->pn_xflags |= PNX_POPVAR;
    1:                 break;
    1:             }
    1: 
18084:             /*
18084:              * Some obvious assertions here, but they may help clarify the
18084:              * situation. This stmt is not yet a scope, so it must not be a
27012:              * catch block (catch is a lexical scope by definition).
18084:              */
18084:             JS_ASSERT(!(stmt->flags & SIF_SCOPE));
18084:             JS_ASSERT(stmt != tc->topScopeStmt);
18084:             JS_ASSERT(stmt->type == STMT_BLOCK ||
18084:                       stmt->type == STMT_SWITCH ||
18084:                       stmt->type == STMT_TRY ||
18084:                       stmt->type == STMT_FINALLY);
18084:             JS_ASSERT(!stmt->downScope);
18084: 
    1:             /* Convert the block statement into a scope statement. */
40860:             JSObject *obj = js_NewBlockObject(tc->parser->context);
    1:             if (!obj)
    1:                 return NULL;
27012: 
80631:             ObjectBox *blockbox = tc->parser->newObjectBox(obj);
27012:             if (!blockbox)
    1:                 return NULL;
    1: 
    1:             /*
    1:              * Insert stmt on the tc->topScopeStmt/stmtInfo.downScope linked
    1:              * list stack, if it isn't already there.  If it is there, but it
    1:              * lacks the SIF_SCOPE flag, it must be a try, catch, or finally
    1:              * block.
    1:              */
    1:             stmt->flags |= SIF_SCOPE;
 9832:             stmt->downScope = tc->topScopeStmt;
 9832:             tc->topScopeStmt = stmt;
    1: 
54855:             obj->setParent(tc->blockChain());
56177:             blockbox->parent = tc->blockChainBox;
54855:             tc->blockChainBox = blockbox;
54855:             stmt->blockBox = blockbox;
    1: 
    1: #ifdef DEBUG
80631:             ParseNode *tmp = tc->blockNode;
82024:             JS_ASSERT(!tmp || !tmp->isKind(PNK_LEXICALSCOPE));
    1: #endif
    1: 
    1:             /* Create a new lexical scope node for these statements. */
82024:             ParseNode *pn1 = LexicalScopeNode::create(PNK_LEXICALSCOPE, tc);
    1:             if (!pn1)
    1:                 return NULL;
    1: 
78294:             pn1->setOp(JSOP_LEAVEBLOCK);
    1:             pn1->pn_pos = tc->blockNode->pn_pos;
27012:             pn1->pn_objbox = blockbox;
    1:             pn1->pn_expr = tc->blockNode;
27012:             pn1->pn_blockid = tc->blockNode->pn_blockid;
    1:             tc->blockNode = pn1;
    1:         }
    1: 
40263:         pn = variables(false);
    1:         if (!pn)
    1:             return NULL;
27012:         pn->pn_xflags = PNX_POPVAR;
57728:     } while (0);
57728: 
57728:     /* Check termination of this primitive statement. */
57728:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
57728: }
    1: #endif
    1: 
80631: ParseNode *
57728: Parser::expressionStatement()
57728: {
40354:     tokenStream.ungetToken();
80631:     ParseNode *pn2 = expr();
    1:     if (!pn2)
    1:         return NULL;
    1: 
40354:     if (tokenStream.peekToken() == TOK_COLON) {
82024:         if (!pn2->isKind(PNK_NAME)) {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_LABEL);
    1:             return NULL;
    1:         }
57728:         JSAtom *label = pn2->pn_atom;
80631:         for (StmtInfo *stmt = tc->topStmt; stmt; stmt = stmt->down) {
27012:             if (stmt->type == STMT_LABEL && stmt->label == label) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_DUPLICATE_LABEL);
    1:                 return NULL;
    1:             }
    1:         }
27012:         ForgetUse(pn2);
27012: 
40354:         (void) tokenStream.getToken();
    1: 
    1:         /* Push a label struct and parse the statement. */
80631:         StmtInfo stmtInfo;
80632:         PushStatement(tc, &stmtInfo, STMT_LABEL, -1);
27012:         stmtInfo.label = label;
80631:         ParseNode *pn = statement();
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Normalize empty statement to empty block for the decompiler. */
82024:         if (pn->isKind(PNK_SEMI) && !pn->pn_kid) {
82024:             pn->setKind(PNK_LC);
78294:             pn->setArity(PN_LIST);
27012:             pn->makeEmpty();
    1:         }
    1: 
    1:         /* Pop the label, set pn_expr, and return early. */
27012:         PopStatement(tc);
82024:         pn2->setKind(PNK_COLON);
    1:         pn2->pn_pos.end = pn->pn_pos.end;
    1:         pn2->pn_expr = pn;
    1:         return pn2;
    1:     }
    1: 
82024:     ParseNode *pn = UnaryNode::create(PNK_SEMI, tc);
    1:     if (!pn)
    1:         return NULL;
    1:     pn->pn_pos = pn2->pn_pos;
    1:     pn->pn_kid = pn2;
32658: 
78294:     switch (pn2->getKind()) {
82024:       case PNK_LP:
37685:         /*
37685:          * Flag lambdas immediately applied as statements as instances of
37685:          * the JS "module pattern". See CheckForImmediatelyAppliedLambda.
37685:          */
82024:         if (pn2->pn_head->isKind(PNK_FUNCTION) &&
37685:             !pn2->pn_head->pn_funbox->node->isFunArg()) {
38549:             pn2->pn_head->pn_funbox->tcflags |= TCF_FUN_MODULE_PATTERN;
37685:         }
37685:         break;
82024:       case PNK_ASSIGN:
37685:         /*
37685:          * Keep track of all apparent methods created by assignments such
37685:          * as this.foo = function (...) {...} in a function that could end
40860:          * up a constructor function. See Parser::setFunctionKinds.
37685:          */
82023:         JS_ASSERT(pn2->isOp(JSOP_NOP));
37685:         if (tc->funbox &&
78294:             pn2->pn_left->isOp(JSOP_SETPROP) &&
82024:             pn2->pn_left->pn_expr->isKind(PNK_THIS) &&
82023:             pn2->pn_right->isOp(JSOP_LAMBDA))
82023:         {
78294:             JS_ASSERT(!pn2->isDefn());
78294:             JS_ASSERT(!pn2->isUsed());
37685:             pn2->pn_right->pn_link = tc->funbox->methods;
37685:             tc->funbox->methods = pn2->pn_right;
37685:         }
37685:         break;
37685:       default:;
32658:     }
57728: 
57728:     /* Check termination of this primitive statement. */
57728:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
57728: }
57728: 
80631: ParseNode *
57728: Parser::statement()
57728: {
80631:     ParseNode *pn;
57728: 
57728:     JS_CHECK_RECURSION(context, return NULL);
57728: 
57728:     switch (tokenStream.getToken(TSF_OPERAND)) {
57728:       case TOK_FUNCTION:
57728:       {
57728: #if JS_HAS_XML_SUPPORT
80780:         if (!tc->inStrictMode()) {
57728:             TokenKind tt = tokenStream.peekToken(TSF_KEYWORD_IS_NAME);
57728:             if (tt == TOK_DBLCOLON)
80780:                 return expressionStatement();
80780:         }
57728: #endif
57728:         return functionStmt();
57728:       }
57728: 
57728:       case TOK_IF:
57728:       {
57728:         /* An IF node has three kids: condition, then, and optional else. */
82024:         pn = TernaryNode::create(PNK_IF, tc);
57728:         if (!pn)
57728:             return NULL;
80631:         ParseNode *pn1 = condition();
57728:         if (!pn1)
57728:             return NULL;
80631:         StmtInfo stmtInfo;
80632:         PushStatement(tc, &stmtInfo, STMT_IF, -1);
80631:         ParseNode *pn2 = statement();
57728:         if (!pn2)
57728:             return NULL;
80631:         ParseNode *pn3;
57728:         if (tokenStream.matchToken(TOK_ELSE, TSF_OPERAND)) {
57728:             stmtInfo.type = STMT_ELSE;
57728:             pn3 = statement();
57728:             if (!pn3)
57728:                 return NULL;
57728:             pn->pn_pos.end = pn3->pn_pos.end;
57728:         } else {
57728:             pn3 = NULL;
57728:             pn->pn_pos.end = pn2->pn_pos.end;
57728:         }
57728:         PopStatement(tc);
57728:         pn->pn_kid1 = pn1;
57728:         pn->pn_kid2 = pn2;
57728:         pn->pn_kid3 = pn3;
57728:         return pn;
57728:       }
57728: 
57728:       case TOK_SWITCH:
57728:         return switchStatement();
57728: 
57728:       case TOK_WHILE:
57728:       {
82024:         pn = BinaryNode::create(PNK_WHILE, tc);
57728:         if (!pn)
57728:             return NULL;
80631:         StmtInfo stmtInfo;
80632:         PushStatement(tc, &stmtInfo, STMT_WHILE_LOOP, -1);
80631:         ParseNode *pn2 = condition();
57728:         if (!pn2)
57728:             return NULL;
57728:         pn->pn_left = pn2;
80631:         ParseNode *pn3 = statement();
57728:         if (!pn3)
57728:             return NULL;
57728:         PopStatement(tc);
57728:         pn->pn_pos.end = pn3->pn_pos.end;
57728:         pn->pn_right = pn3;
57728:         return pn;
57728:       }
57728: 
57728:       case TOK_DO:
57728:       {
82024:         pn = BinaryNode::create(PNK_DO, tc);
57728:         if (!pn)
57728:             return NULL;
80631:         StmtInfo stmtInfo;
80632:         PushStatement(tc, &stmtInfo, STMT_DO_LOOP, -1);
80631:         ParseNode *pn2 = statement();
57728:         if (!pn2)
57728:             return NULL;
57728:         pn->pn_left = pn2;
57728:         MUST_MATCH_TOKEN(TOK_WHILE, JSMSG_WHILE_AFTER_DO);
80631:         ParseNode *pn3 = condition();
57728:         if (!pn3)
57728:             return NULL;
57728:         PopStatement(tc);
57728:         pn->pn_pos.end = pn3->pn_pos.end;
57728:         pn->pn_right = pn3;
61450:         if (versionNumber() != JSVERSION_ECMA_3) {
57728:             /*
57728:              * All legacy and extended versions must do automatic semicolon
57728:              * insertion after do-while.  See the testcase and discussion in
57728:              * http://bugzilla.mozilla.org/show_bug.cgi?id=238945.
57728:              */
57728:             (void) tokenStream.matchToken(TOK_SEMI);
57728:             return pn;
57728:         }
57728:         break;
57728:       }
57728: 
57728:       case TOK_FOR:
57728:         return forStatement();
57728: 
57728:       case TOK_TRY:
57728:         return tryStatement();
57728: 
57728:       case TOK_THROW:
57728:       {
82024:         pn = UnaryNode::create(PNK_THROW, tc);
57728:         if (!pn)
57728:             return NULL;
57728: 
57728:         /* ECMA-262 Edition 3 says 'throw [no LineTerminator here] Expr'. */
57728:         TokenKind tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
57728:         if (tt == TOK_ERROR)
57728:             return NULL;
57728:         if (tt == TOK_EOF || tt == TOK_EOL || tt == TOK_SEMI || tt == TOK_RC) {
57728:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
57728:             return NULL;
57728:         }
57728: 
80631:         ParseNode *pn2 = expr();
57728:         if (!pn2)
57728:             return NULL;
57728:         pn->pn_pos.end = pn2->pn_pos.end;
78294:         pn->setOp(JSOP_THROW);
57728:         pn->pn_kid = pn2;
57728:         break;
57728:       }
57728: 
57728:       /* TOK_CATCH and TOK_FINALLY are both handled in the TOK_TRY case */
57728:       case TOK_CATCH:
57728:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CATCH_WITHOUT_TRY);
57728:         return NULL;
57728: 
57728:       case TOK_FINALLY:
57728:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_FINALLY_WITHOUT_TRY);
57728:         return NULL;
57728: 
57728:       case TOK_BREAK:
57728:       {
82024:         pn = NullaryNode::create(PNK_BREAK, tc);
57728:         if (!pn)
57728:             return NULL;
57728:         if (!MatchLabel(context, &tokenStream, pn))
57728:             return NULL;
80631:         StmtInfo *stmt = tc->topStmt;
57728:         JSAtom *label = pn->pn_atom;
57728:         if (label) {
57728:             for (; ; stmt = stmt->down) {
57728:                 if (!stmt) {
57728:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_LABEL_NOT_FOUND);
57728:                     return NULL;
57728:                 }
57728:                 if (stmt->type == STMT_LABEL && stmt->label == label)
57728:                     break;
57728:             }
57728:         } else {
57728:             for (; ; stmt = stmt->down) {
57728:                 if (!stmt) {
57728:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_TOUGH_BREAK);
57728:                     return NULL;
57728:                 }
57728:                 if (STMT_IS_LOOP(stmt) || stmt->type == STMT_SWITCH)
57728:                     break;
57728:             }
57728:         }
57728:         if (label)
57728:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
57728:         break;
57728:       }
57728: 
57728:       case TOK_CONTINUE:
57728:       {
82024:         pn = NullaryNode::create(PNK_CONTINUE, tc);
57728:         if (!pn)
57728:             return NULL;
57728:         if (!MatchLabel(context, &tokenStream, pn))
57728:             return NULL;
80631:         StmtInfo *stmt = tc->topStmt;
57728:         JSAtom *label = pn->pn_atom;
57728:         if (label) {
80631:             for (StmtInfo *stmt2 = NULL; ; stmt = stmt->down) {
57728:                 if (!stmt) {
57728:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_LABEL_NOT_FOUND);
57728:                     return NULL;
57728:                 }
57728:                 if (stmt->type == STMT_LABEL) {
57728:                     if (stmt->label == label) {
57728:                         if (!stmt2 || !STMT_IS_LOOP(stmt2)) {
57728:                             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_CONTINUE);
57728:                             return NULL;
57728:                         }
57728:                         break;
57728:                     }
57728:                 } else {
57728:                     stmt2 = stmt;
57728:                 }
57728:             }
57728:         } else {
57728:             for (; ; stmt = stmt->down) {
57728:                 if (!stmt) {
57728:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_CONTINUE);
57728:                     return NULL;
57728:                 }
57728:                 if (STMT_IS_LOOP(stmt))
57728:                     break;
57728:             }
57728:         }
57728:         if (label)
57728:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
57728:         break;
57728:       }
57728: 
57728:       case TOK_WITH:
57728:         return withStatement();
57728: 
57728:       case TOK_VAR:
57728:         pn = variables(false);
57728:         if (!pn)
57728:             return NULL;
57728: 
57728:         /* Tell js_EmitTree to generate a final POP. */
57728:         pn->pn_xflags |= PNX_POPVAR;
57728:         break;
57728: 
57728: #if JS_HAS_BLOCK_SCOPE
57728:       case TOK_LET:
57728:         return letStatement();
57728: #endif /* JS_HAS_BLOCK_SCOPE */
57728: 
57728:       case TOK_RETURN:
57728:         pn = returnOrYield(false);
57728:         if (!pn)
57728:             return NULL;
57728:         break;
57728: 
57728:       case TOK_LC:
57728:       {
57728:         uintN oldflags;
57728: 
57728:         oldflags = tc->flags;
57728:         tc->flags = oldflags & ~TCF_HAS_FUNCTION_STMT;
80631:         StmtInfo stmtInfo;
57728:         if (!PushBlocklikeStatement(&stmtInfo, STMT_BLOCK, tc))
57728:             return NULL;
57728:         pn = statements();
57728:         if (!pn)
57728:             return NULL;
57728: 
57728:         MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_COMPOUND);
57728:         PopStatement(tc);
57728: 
57728:         /*
57728:          * If we contain a function statement and our container is top-level
57728:          * or another block, flag pn to preserve braces when decompiling.
57728:          */
57728:         if ((tc->flags & TCF_HAS_FUNCTION_STMT) &&
57728:             (!tc->topStmt || tc->topStmt->type == STMT_BLOCK)) {
57728:             pn->pn_xflags |= PNX_NEEDBRACES;
57728:         }
57728:         tc->flags = oldflags | (tc->flags & (TCF_FUN_FLAGS | TCF_RETURN_FLAGS));
57728:         return pn;
57728:       }
57728: 
57728:       case TOK_SEMI:
82024:         pn = UnaryNode::create(PNK_SEMI, tc);
57728:         if (!pn)
57728:             return NULL;
57728:         return pn;
57728: 
57728:       case TOK_DEBUGGER:
82024:         pn = NullaryNode::create(PNK_DEBUGGER, tc);
57728:         if (!pn)
57728:             return NULL;
57728:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
57728:         break;
57728: 
57728: #if JS_HAS_XML_SUPPORT
57728:       case TOK_DEFAULT:
57728:       {
80780:         if (tc->inStrictMode())
80780:             return expressionStatement();
80780: 
82024:         pn = UnaryNode::create(PNK_DEFAULT, tc);
57728:         if (!pn)
57728:             return NULL;
57728:         if (!tokenStream.matchToken(TOK_NAME) ||
80443:             tokenStream.currentToken().name() != context->runtime->atomState.xmlAtom ||
57728:             !tokenStream.matchToken(TOK_NAME) ||
80443:             tokenStream.currentToken().name() != context->runtime->atomState.namespaceAtom ||
82023:             !tokenStream.matchToken(TOK_ASSIGN))
82023:         {
57728:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_DEFAULT_XML_NAMESPACE);
57728:             return NULL;
57728:         }
57728: 
82023:         JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NOP);
82023: 
57728:         /* Is this an E4X dagger I see before me? */
57728:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
80631:         ParseNode *pn2 = expr();
57728:         if (!pn2)
57728:             return NULL;
78294:         pn->setOp(JSOP_DEFXMLNS);
57728:         pn->pn_pos.end = pn2->pn_pos.end;
57728:         pn->pn_kid = pn2;
57728:         break;
57728:       }
57728: #endif
57728: 
57728:       case TOK_ERROR:
57728:         return NULL;
57728: 
57728:       default:
57728:         return expressionStatement();
    1:     }
    1: 
    1:     /* Check termination of this primitive statement. */
40239:     return MatchOrInsertSemicolon(context, &tokenStream) ? pn : NULL;
    1: }
    1: 
80631: ParseNode *
40860: Parser::variables(bool inLetHead)
40221: {
    1:     /*
    1:      * The three options here are:
82024:      * - TOK_VAR: We're parsing var declarations.
    1:      * - TOK_LET: We are parsing a let declaration.
    1:      * - TOK_LP: We are parsing the head of a let block.
82024:      */
82024:     TokenKind tt = tokenStream.currentToken().type;
82024:     JS_ASSERT(tt == TOK_VAR || tt == TOK_LET || tt == TOK_LP);
82024: 
82024:     bool let = (tt == TOK_LET || tt == TOK_LP);
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:     bool popScope = (inLetHead || (let && (tc->flags & TCF_IN_FOR_INIT)));
80631:     StmtInfo *save = tc->topStmt, *saveScope = tc->topScopeStmt;
27012: #endif
27012: 
40239:     /* Make sure that statement set up the tree context correctly. */
82024:     StmtInfo *scopeStmt = tc->topScopeStmt;
    1:     if (let) {
    1:         while (scopeStmt && !(scopeStmt->flags & SIF_SCOPE)) {
    1:             JS_ASSERT(!STMT_MAYBE_SCOPE(scopeStmt));
    1:             scopeStmt = scopeStmt->downScope;
    1:         }
    1:         JS_ASSERT(scopeStmt);
    1:     }
    1: 
82024:     BindData data;
40270:     data.op = let ? JSOP_NOP : tokenStream.currentToken().t_op;
82024:     ParseNode *pn = ListNode::create(tt == TOK_LET ? PNK_LET : tt == TOK_VAR ? PNK_VAR : PNK_LP, tc);
    1:     if (!pn)
    1:         return NULL;
78294:     pn->setOp(data.op);
27012:     pn->makeEmpty();
27012: 
27012:     /*
27012:      * SpiderMonkey const is really "write once per initialization evaluation"
27012:      * var, whereas let is block scoped. ES-Harmony wants block-scoped const so
27012:      * this code will change soon.
    1:      */
    1:     if (let) {
54855:         JS_ASSERT(tc->blockChainBox == scopeStmt->blockBox);
 8444:         data.binder = BindLet;
27012:         data.let.overflow = JSMSG_TOO_MANY_LOCALS;
    1:     } else {
 8444:         data.binder = BindVarOrConst;
    1:     }
    1: 
82024:     ParseNode *pn2;
    1:     do {
40354:         tt = tokenStream.getToken();
    1: #if JS_HAS_DESTRUCTURING
    1:         if (tt == TOK_LB || tt == TOK_LC) {
33753:             tc->flags |= TCF_DECL_DESTRUCTURING;
40263:             pn2 = primaryExpr(tt, JS_FALSE);
33753:             tc->flags &= ~TCF_DECL_DESTRUCTURING;
    1:             if (!pn2)
    1:                 return NULL;
    1: 
68922:             if (!CheckDestructuring(context, &data, pn2, tc))
28995:                 return NULL;
74052:             if ((tc->flags & TCF_IN_FOR_INIT) && tokenStream.peekToken() == TOK_IN) {
27012:                 pn->append(pn2);
    1:                 continue;
    1:             }
    1: 
    1:             MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_BAD_DESTRUCT_DECL);
82023:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NOP);
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save->down;
27012:                 tc->topScopeStmt = saveScope->downScope;
27012:             }
27012: #endif
80631:             ParseNode *init = assignExpr();
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save;
27012:                 tc->topScopeStmt = saveScope;
27012:             }
27012: #endif
27012: 
68923:             if (!init)
68923:                 return NULL;
68923:             UndominateInitializers(pn2, init->pn_pos.end, tc);
28995: 
82024:             pn2 = ParseNode::newBinaryOrAppend(PNK_ASSIGN, JSOP_NOP, pn2, init, tc);
28995:             if (!pn2)
28995:                 return NULL;
27012:             pn->append(pn2);
    1:             continue;
    1:         }
27012: #endif /* JS_HAS_DESTRUCTURING */
    1: 
    1:         if (tt != TOK_NAME) {
74052:             if (tt != TOK_ERROR)
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NO_VARIABLE_NAME);
27012:             return NULL;
27012:         }
27012: 
80443:         PropertyName *name = tokenStream.currentToken().name();
80443:         pn2 = NewBindingNode(name, tc, let);
27012:         if (!pn2)
27012:             return NULL;
27012:         if (data.op == JSOP_DEFCONST)
27012:             pn2->pn_dflags |= PND_CONST;
27012:         data.pn = pn2;
80443:         if (!data.binder(context, &data, name, tc))
26970:             return NULL;
27012:         pn->append(pn2);
    1: 
40354:         if (tokenStream.matchToken(TOK_ASSIGN)) {
82023:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NOP);
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save->down;
27012:                 tc->topScopeStmt = saveScope->downScope;
27012:             }
27012: #endif
80631:             ParseNode *init = assignExpr();
27012: #if JS_HAS_BLOCK_SCOPE
27012:             if (popScope) {
27012:                 tc->topStmt = save;
27012:                 tc->topScopeStmt = saveScope;
27012:             }
27012: #endif
27012:             if (!init)
27012:                 return NULL;
27012: 
78294:             if (pn2->isUsed()) {
27012:                 pn2 = MakeAssignment(pn2, init, tc);
27012:                 if (!pn2)
27012:                     return NULL;
27012:             } else {
27012:                 pn2->pn_expr = init;
27012:             }
27012: 
60526:             JS_ASSERT_IF(pn2->pn_dflags & PND_GVAR, !(pn2->pn_dflags & PND_BOUND));
52555: 
78294:             pn2->setOp(pn2->isOp(JSOP_ARGUMENTS)
27012:                        ? JSOP_SETNAME
27012:                        : (pn2->pn_dflags & PND_BOUND)
27012:                        ? JSOP_SETLOCAL
27012:                        : (data.op == JSOP_DEFCONST)
    1:                        ? JSOP_SETCONST
78294:                        : JSOP_SETNAME);
27012: 
40239:             NoteLValue(context, pn2, tc, data.fresh ? PND_INITIALIZED : PND_ASSIGNED);
27012: 
27012:             /* The declarator's position must include the initializer. */
27012:             pn2->pn_pos.end = init->pn_pos.end;
27012: 
80443:             if (tc->inFunction() && name == context->runtime->atomState.argumentsAtom) {
72073:                 tc->noteArgumentsUse(pn2);
27012:                 if (!let)
    1:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
    1:             }
27012:         }
40354:     } while (tokenStream.matchToken(TOK_COMMA));
    1: 
27012:     pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
40860: Parser::expr()
    1: {
80631:     ParseNode *pn = assignExpr();
40354:     if (pn && tokenStream.matchToken(TOK_COMMA)) {
82024:         ParseNode *pn2 = ListNode::create(PNK_COMMA, tc);
    1:         if (!pn2)
    1:             return NULL;
    1:         pn2->pn_pos.begin = pn->pn_pos.begin;
27012:         pn2->initList(pn);
    1:         pn = pn2;
    1:         do {
    1: #if JS_HAS_GENERATORS
27012:             pn2 = pn->last();
82024:             if (pn2->isKind(PNK_YIELD) && !pn2->isInParens()) {
42671:                 reportErrorNumber(pn2, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
    1:                 return NULL;
    1:             }
    1: #endif
40263:             pn2 = assignExpr();
    1:             if (!pn2)
    1:                 return NULL;
27012:             pn->append(pn2);
40354:         } while (tokenStream.matchToken(TOK_COMMA));
27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     }
    1:     return pn;
    1: }
    1: 
64367: /*
64367:  * For a number of the expression parsers we define an always-inlined version
64367:  * and a never-inlined version (which just calls the always-inlined version).
64367:  * Using the always-inlined version in the hot call-sites givs a ~5% parsing
64367:  * speedup.  These macros help avoid some boilerplate code.
64367:  */
64367: #define BEGIN_EXPR_PARSER(name)                                               \
80631:     JS_ALWAYS_INLINE ParseNode *                                              \
64367:     Parser::name##i()
64367: 
64367: #define END_EXPR_PARSER(name)                                                 \
80631:     JS_NEVER_INLINE ParseNode *                                               \
64367:     Parser::name##n() {                                                       \
64367:         return name##i();                                                     \
64367:     }
64367: 
64367: BEGIN_EXPR_PARSER(mulExpr1)
64367: {
80631:     ParseNode *pn = unaryExpr();
64367: 
64367:     /*
64367:      * Note: unlike addExpr1() et al, we use getToken() here instead of
64367:      * isCurrentTokenType() because unaryExpr() doesn't leave the TokenStream
64367:      * state one past the end of the unary expression.
64367:      */
82024:     TokenKind tt;
82021:     while (pn && ((tt = tokenStream.getToken()) == TOK_STAR || tt == TOK_DIV || tt == TOK_MOD)) {
82024:         ParseNodeKind kind = (tt == TOK_STAR)
82024:                              ? PNK_STAR
82024:                              : (tt == TOK_DIV)
82024:                              ? PNK_DIV
82024:                              : PNK_MOD;
64367:         JSOp op = tokenStream.currentToken().t_op;
82024:         pn = ParseNode::newBinaryOrAppend(kind, op, pn, unaryExpr(), tc);
64367:     }
    1:     return pn;
    1: }
64367: END_EXPR_PARSER(mulExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(addExpr1)
64367: {
80631:     ParseNode *pn = mulExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_PLUS, TOK_MINUS)) {
64367:         TokenKind tt = tokenStream.currentToken().type;
64367:         JSOp op = (tt == TOK_PLUS) ? JSOP_ADD : JSOP_SUB;
82024:         ParseNodeKind kind = (tt == TOK_PLUS) ? PNK_PLUS : PNK_MINUS;
82024:         pn = ParseNode::newBinaryOrAppend(kind, op, pn, mulExpr1n(), tc);
64367:     }
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(addExpr1)
64367: 
82024: inline ParseNodeKind
82024: ShiftTokenToParseNodeKind(const Token &token)
82024: {
82024:     switch (token.type) {
82024:       case TOK_LSH:
82024:         return PNK_LSH;
82024:       case TOK_RSH:
82024:         return PNK_RSH;
82024:       default:
82024:         JS_ASSERT(token.type == TOK_URSH);
82024:         return PNK_URSH;
82024:     }
82024: }
82024: 
64367: BEGIN_EXPR_PARSER(shiftExpr1)
64367: {
82020:     ParseNode *left = addExpr1i();
82020:     while (left && tokenStream.isCurrentTokenShift()) {
82024:         ParseNodeKind kind = ShiftTokenToParseNodeKind(tokenStream.currentToken());
42671:         JSOp op = tokenStream.currentToken().t_op;
82020:         ParseNode *right = addExpr1n();
82020:         if (!right)
82020:             return NULL;
82024:         left = tc->parser->new_<BinaryNode>(kind, op, left, right);
82020:     }
82020:     return left;
64367: }
64367: END_EXPR_PARSER(shiftExpr1)
64367: 
82024: inline ParseNodeKind
82024: RelationalTokenToParseNodeKind(const Token &token)
82024: {
82024:     switch (token.type) {
82024:       case TOK_IN:
82024:         return PNK_IN;
82024:       case TOK_INSTANCEOF:
82024:         return PNK_INSTANCEOF;
82024:       case TOK_LT:
82024:         return PNK_LT;
82024:       case TOK_LE:
82024:         return PNK_LE;
82024:       case TOK_GT:
82024:         return PNK_GT;
82024:       default:
82024:         JS_ASSERT(token.type == TOK_GE);
82024:         return PNK_GE;
82024:     }
82024: }
82024: 
64367: BEGIN_EXPR_PARSER(relExpr1)
64367: {
64367:     uintN inForInitFlag = tc->flags & TCF_IN_FOR_INIT;
64367: 
64367:     /*
64367:      * Uses of the in operator in shiftExprs are always unambiguous,
64367:      * so unset the flag that prohibits recognizing it.
64367:      */
64367:     tc->flags &= ~TCF_IN_FOR_INIT;
64367: 
80631:     ParseNode *pn = shiftExpr1i();
64367:     while (pn &&
82019:            (tokenStream.isCurrentTokenRelational() ||
64367:             /*
64367:              * Recognize the 'in' token as an operator only if we're not
64367:              * currently in the init expr of a for loop.
64367:              */
64367:             (inForInitFlag == 0 && tokenStream.isCurrentTokenType(TOK_IN)) ||
64367:             tokenStream.isCurrentTokenType(TOK_INSTANCEOF))) {
82024:         ParseNodeKind kind = RelationalTokenToParseNodeKind(tokenStream.currentToken());
64367:         JSOp op = tokenStream.currentToken().t_op;
82024:         pn = ParseNode::newBinaryOrAppend(kind, op, pn, shiftExpr1n(), tc);
64367:     }
64367:     /* Restore previous state of inForInit flag. */
64367:     tc->flags |= inForInitFlag;
64367: 
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(relExpr1)
64367: 
82024: inline ParseNodeKind
82024: EqualityTokenToParseNodeKind(const Token &token)
82024: {
82024:     switch (token.type) {
82024:       case TOK_STRICTEQ:
82024:         return PNK_STRICTEQ;
82024:       case TOK_EQ:
82024:         return PNK_EQ;
82024:       case TOK_STRICTNE:
82024:         return PNK_STRICTNE;
82024:       default:
82024:         JS_ASSERT(token.type == TOK_NE);
82024:         return PNK_NE;
82024:     }
82024: }
82024: 
64367: BEGIN_EXPR_PARSER(eqExpr1)
64367: {
82015:     ParseNode *left = relExpr1i();
82015:     while (left && tokenStream.isCurrentTokenEquality()) {
82024:         ParseNodeKind kind = EqualityTokenToParseNodeKind(tokenStream.currentToken());
64367:         JSOp op = tokenStream.currentToken().t_op;
82015:         ParseNode *right = relExpr1n();
82015:         if (!right)
82015:             return NULL;
82024:         left = tc->parser->new_<BinaryNode>(kind, op, left, right);
82015:     }
82015:     return left;
64367: }
64367: END_EXPR_PARSER(eqExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(bitAndExpr1)
64367: {
80631:     ParseNode *pn = eqExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITAND))
82024:         pn = ParseNode::newBinaryOrAppend(PNK_BITAND, JSOP_BITAND, pn, eqExpr1n(), tc);
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(bitAndExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(bitXorExpr1)
64367: {
80631:     ParseNode *pn = bitAndExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITXOR))
82024:         pn = ParseNode::newBinaryOrAppend(PNK_BITXOR, JSOP_BITXOR, pn, bitAndExpr1n(), tc);
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(bitXorExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(bitOrExpr1)
64367: {
80631:     ParseNode *pn = bitXorExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_BITOR))
82024:         pn = ParseNode::newBinaryOrAppend(PNK_BITOR, JSOP_BITOR, pn, bitXorExpr1n(), tc);
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(bitOrExpr1)
64367: 
64367: BEGIN_EXPR_PARSER(andExpr1)
64367: {
80631:     ParseNode *pn = bitOrExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_AND))
82024:         pn = ParseNode::newBinaryOrAppend(PNK_AND, JSOP_AND, pn, bitOrExpr1n(), tc);
64367:     return pn;
64367: }
64367: END_EXPR_PARSER(andExpr1)
64367: 
80631: JS_ALWAYS_INLINE ParseNode *
64367: Parser::orExpr1()
64367: {
80631:     ParseNode *pn = andExpr1i();
64367:     while (pn && tokenStream.isCurrentTokenType(TOK_OR))
82024:         pn = ParseNode::newBinaryOrAppend(PNK_OR, JSOP_OR, pn, andExpr1n(), tc);
64367:     return pn;
64367: }
64367: 
80631: JS_ALWAYS_INLINE ParseNode *
64366: Parser::condExpr1()
64366: {
80631:     ParseNode *pn = orExpr1();
64366:     if (pn && tokenStream.isCurrentTokenType(TOK_HOOK)) {
80631:         ParseNode *pn1 = pn;
82024:         pn = TernaryNode::create(PNK_HOOK, tc);
    1:         if (!pn)
    1:             return NULL;
40327: 
    1:         /*
    1:          * Always accept the 'in' operator in the middle clause of a ternary,
    1:          * where it's unambiguous, even if we might be parsing the init of a
    1:          * for statement.
    1:          */
42671:         uintN oldflags = tc->flags;
    1:         tc->flags &= ~TCF_IN_FOR_INIT;
80631:         ParseNode *pn2 = assignExpr();
    1:         tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1: 
    1:         if (!pn2)
    1:             return NULL;
    1:         MUST_MATCH_TOKEN(TOK_COLON, JSMSG_COLON_IN_COND);
80631:         ParseNode *pn3 = assignExpr();
    1:         if (!pn3)
    1:             return NULL;
    1:         pn->pn_pos.begin = pn1->pn_pos.begin;
    1:         pn->pn_pos.end = pn3->pn_pos.end;
    1:         pn->pn_kid1 = pn1;
    1:         pn->pn_kid2 = pn2;
    1:         pn->pn_kid3 = pn3;
64366:         tokenStream.getToken();     /* need to read one token past the end */
    1:     }
    1:     return pn;
    1: }
    1: 
74052: bool
80631: Parser::setAssignmentLhsOps(ParseNode *pn, JSOp op)
74052: {
78294:     switch (pn->getKind()) {
82024:       case PNK_NAME:
74052:         if (!CheckStrictAssignment(context, tc, pn))
74052:             return false;
78294:         pn->setOp(pn->isOp(JSOP_GETLOCAL) ? JSOP_SETLOCAL : JSOP_SETNAME);
74052:         NoteLValue(context, pn, tc);
74052:         break;
82024:       case PNK_DOT:
78294:         pn->setOp(JSOP_SETPROP);
74052:         break;
82024:       case PNK_LB:
78294:         pn->setOp(JSOP_SETELEM);
74052:         break;
74052: #if JS_HAS_DESTRUCTURING
82024:       case PNK_RB:
82024:       case PNK_RC:
74052:         if (op != JSOP_NOP) {
74052:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_DESTRUCT_ASS);
74052:             return false;
74052:         }
74052:         if (!CheckDestructuring(context, NULL, pn, tc))
74052:             return false;
74052:         break;
74052: #endif
82024:       case PNK_LP:
74052:         if (!MakeSetCall(context, pn, tc, JSMSG_BAD_LEFTSIDE_OF_ASS))
74052:             return false;
74052:         break;
74052: #if JS_HAS_XML_SUPPORT
82114:       case PNK_XMLUNARY:
82018:         JS_ASSERT(pn->isOp(JSOP_XMLNAME));
78294:         pn->setOp(JSOP_SETXMLNAME);
74052:         break;
74052: #endif
74052:       default:
74052:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_LEFTSIDE_OF_ASS);
74052:         return false;
74052:     }
74052:     return true;
74052: }
74052: 
80631: ParseNode *
64367: Parser::assignExpr()
64367: {
64367:     JS_CHECK_RECURSION(context, return NULL);
64367: 
64367: #if JS_HAS_GENERATORS
64367:     if (tokenStream.matchToken(TOK_YIELD, TSF_OPERAND))
64367:         return returnOrYield(true);
64367: #endif
64367: 
82024:     ParseNode *lhs = condExpr1();
82024:     if (!lhs)
82024:         return NULL;
82024: 
82024:     ParseNodeKind kind;
82024:     switch (tokenStream.currentToken().type) {
82024:       case TOK_ASSIGN:       kind = PNK_ASSIGN;       break;
82024:       case TOK_ADDASSIGN:    kind = PNK_ADDASSIGN;    break;
82024:       case TOK_SUBASSIGN:    kind = PNK_SUBASSIGN;    break;
82024:       case TOK_BITORASSIGN:  kind = PNK_BITORASSIGN;  break;
82024:       case TOK_BITXORASSIGN: kind = PNK_BITXORASSIGN; break;
82024:       case TOK_BITANDASSIGN: kind = PNK_BITANDASSIGN; break;
82024:       case TOK_LSHASSIGN:    kind = PNK_LSHASSIGN;    break;
82024:       case TOK_RSHASSIGN:    kind = PNK_RSHASSIGN;    break;
82024:       case TOK_URSHASSIGN:   kind = PNK_URSHASSIGN;   break;
82024:       case TOK_MULASSIGN:    kind = PNK_MULASSIGN;    break;
82024:       case TOK_DIVASSIGN:    kind = PNK_DIVASSIGN;    break;
82024:       case TOK_MODASSIGN:    kind = PNK_MODASSIGN;    break;
82024:       default:
82024:         JS_ASSERT(!tokenStream.isCurrentTokenAssignment());
64367:         tokenStream.ungetToken();
82024:         return lhs;
82024:     }
82024: 
42671:     JSOp op = tokenStream.currentToken().t_op;
82024:     if (!setAssignmentLhsOps(lhs, op))
74052:         return NULL;
74052: 
80631:     ParseNode *rhs = assignExpr();
74052:     if (!rhs)
74052:         return NULL;
82024:     if (lhs->isKind(PNK_NAME) && lhs->isUsed()) {
82024:         Definition *dn = lhs->pn_lexdef;
64367: 
64367:         /*
64367:          * If the definition is not flagged as assigned, we must have imputed
64367:          * the initialized flag to it, to optimize for flat closures. But that
64367:          * optimization uses source coordinates to check dominance relations,
64367:          * so we must extend the end of the definition to cover the right-hand
64367:          * side of this assignment, i.e., the initializer.
64367:          */
64367:         if (!dn->isAssigned()) {
64367:             JS_ASSERT(dn->isInitialized());
64367:             dn->pn_pos.end = rhs->pn_pos.end;
64367:         }
64367:     }
64367: 
82024:     return ParseNode::newBinaryOrAppend(kind, op, lhs, rhs, tc);
80631: }
80631: 
80631: static ParseNode *
80631: SetLvalKid(JSContext *cx, TokenStream *ts, TreeContext *tc, ParseNode *pn, ParseNode *kid,
80631:            const char *name)
    1: {
82024:     if (!kid->isKind(PNK_NAME) &&
82024:         !kid->isKind(PNK_DOT) &&
82024:         (!kid->isKind(PNK_LP) ||
78294:          (!kid->isOp(JSOP_CALL) && !kid->isOp(JSOP_EVAL) &&
78294:           !kid->isOp(JSOP_FUNCALL) && !kid->isOp(JSOP_FUNAPPLY))) &&
    1: #if JS_HAS_XML_SUPPORT
82114:         !kid->isKind(PNK_XMLUNARY) &&
    1: #endif
82024:         !kid->isKind(PNK_LB))
82018:     {
40320:         ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR, JSMSG_BAD_OPERAND, name);
    1:         return NULL;
    1:     }
35324:     if (!CheckStrictAssignment(cx, tc, kid))
35324:         return NULL;
    1:     pn->pn_kid = kid;
    1:     return kid;
    1: }
    1: 
    1: static const char incop_name_str[][10] = {"increment", "decrement"};
    1: 
    1: static JSBool
80631: SetIncOpKid(JSContext *cx, TokenStream *ts, TreeContext *tc, ParseNode *pn, ParseNode *kid,
40320:             TokenKind tt, JSBool preorder)
    1: {
    1:     JSOp op;
    1: 
35324:     kid = SetLvalKid(cx, ts, tc, pn, kid, incop_name_str[tt == TOK_DEC]);
    1:     if (!kid)
    1:         return JS_FALSE;
78294:     switch (kid->getKind()) {
82024:       case PNK_NAME:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCNAME : JSOP_NAMEINC)
    1:              : (preorder ? JSOP_DECNAME : JSOP_NAMEDEC);
27012:         NoteLValue(cx, kid, tc);
    1:         break;
    1: 
82024:       case PNK_DOT:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCPROP : JSOP_PROPINC)
    1:              : (preorder ? JSOP_DECPROP : JSOP_PROPDEC);
    1:         break;
    1: 
82024:       case PNK_LP:
 7984:         if (!MakeSetCall(cx, kid, tc, JSMSG_BAD_INCOP_OPERAND))
 1577:             return JS_FALSE;
    1:         /* FALL THROUGH */
    1: #if JS_HAS_XML_SUPPORT
82114:       case PNK_XMLUNARY:
78294:         if (kid->isOp(JSOP_XMLNAME))
78294:             kid->setOp(JSOP_SETXMLNAME);
    1:         /* FALL THROUGH */
    1: #endif
82024:       case PNK_LB:
    1:         op = (tt == TOK_INC)
    1:              ? (preorder ? JSOP_INCELEM : JSOP_ELEMINC)
    1:              : (preorder ? JSOP_DECELEM : JSOP_ELEMDEC);
    1:         break;
    1: 
    1:       default:
    1:         JS_ASSERT(0);
    1:         op = JSOP_NOP;
    1:     }
78294:     pn->setOp(op);
    1:     return JS_TRUE;
    1: }
    1: 
80631: ParseNode *
82024: Parser::unaryOpExpr(ParseNodeKind kind, JSOp op)
82024: {
82024:     TokenPtr begin = tokenStream.currentToken().pos.begin;
82024:     ParseNode *kid = unaryExpr();
82024:     if (!kid)
82024:         return NULL;
82024:     return new_<UnaryNode>(kind, op, TokenPos::make(begin, kid->pn_pos.end), kid);
82024: }
82024: 
82024: ParseNode *
40860: Parser::unaryExpr()
40221: {
80631:     ParseNode *pn, *pn2;
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40239: 
82024:     switch (TokenKind tt = tokenStream.getToken(TSF_OPERAND)) {
82018:       case TOK_TYPEOF:
82024:         return unaryOpExpr(PNK_TYPEOF, JSOP_TYPEOF);
82018:       case TOK_VOID:
82024:         return unaryOpExpr(PNK_VOID, JSOP_VOID);
82018:       case TOK_NOT:
82024:         return unaryOpExpr(PNK_NOT, JSOP_NOT);
82018:       case TOK_BITNOT:
82024:         return unaryOpExpr(PNK_BITNOT, JSOP_BITNOT);
    1:       case TOK_PLUS:
82024:         return unaryOpExpr(PNK_PLUS, JSOP_POS);
    1:       case TOK_MINUS:
82024:         return unaryOpExpr(PNK_MINUS, JSOP_NEG);
    1: 
    1:       case TOK_INC:
    1:       case TOK_DEC:
82024:         pn = UnaryNode::create((tt == TOK_INC) ? PNK_INC : PNK_DEC, tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn2 = memberExpr(JS_TRUE);
    1:         if (!pn2)
    1:             return NULL;
40239:         if (!SetIncOpKid(context, &tokenStream, tc, pn, pn2, tt, JS_TRUE))
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1:         break;
    1: 
    1:       case TOK_DELETE:
41983:       {
82024:         pn = UnaryNode::create(PNK_DELETE, tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn2 = unaryExpr();
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
    1: 
    1:         /*
    1:          * Under ECMA3, deleting any unary expression is valid -- it simply
31479:          * returns true. Here we fold constants before checking for a call
31479:          * expression, in order to rule out delete of a generator expression.
31479:          */
80631:         if (foldConstants && !FoldConstants(context, pn2, tc))
 1962:             return NULL;
78294:         switch (pn2->getKind()) {
82024:           case PNK_LP:
57742:             if (!(pn2->pn_xflags & PNX_SETCALL)) {
57742:                 /*
57742:                  * Call MakeSetCall to check for errors, but clear PNX_SETCALL
57742:                  * because the optimizer will eliminate the useless delete.
57742:                  */
57742:                 if (!MakeSetCall(context, pn2, tc, JSMSG_BAD_DELETE_OPERAND))
57742:                     return NULL;
57742:                 pn2->pn_xflags &= ~PNX_SETCALL;
 1577:             }
27012:             break;
82024:           case PNK_NAME:
40320:             if (!ReportStrictModeError(context, &tokenStream, tc, pn,
57742:                                        JSMSG_DEPRECATED_DELETE_OPERAND)) {
57742:                 return NULL;
57742:             }
78294:             pn2->setOp(JSOP_DELNAME);
72073:             if (pn2->pn_atom == context->runtime->atomState.argumentsAtom) {
41983:                 tc->flags |= TCF_FUN_HEAVYWEIGHT;
72073:                 tc->countArgumentsUse(pn2);
72073:             }
27012:             break;
27012:           default:;
27012:         }
    1:         pn->pn_kid = pn2;
    1:         break;
41983:       }
    1:       case TOK_ERROR:
    1:         return NULL;
    1: 
    1:       default:
40354:         tokenStream.ungetToken();
40263:         pn = memberExpr(JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1: 
    1:         /* Don't look across a newline boundary for a postfix incop. */
40270:         if (tokenStream.onCurrentLine(pn->pn_pos)) {
40854:             tt = tokenStream.peekTokenSameLine(TSF_OPERAND);
    1:             if (tt == TOK_INC || tt == TOK_DEC) {
40354:                 (void) tokenStream.getToken();
82024:                 pn2 = UnaryNode::create((tt == TOK_INC) ? PNK_INC : PNK_DEC, tc);
    1:                 if (!pn2)
    1:                     return NULL;
40239:                 if (!SetIncOpKid(context, &tokenStream, tc, pn2, pn, tt, JS_FALSE))
    1:                     return NULL;
    1:                 pn2->pn_pos.begin = pn->pn_pos.begin;
    1:                 pn = pn2;
    1:             }
    1:         }
    1:         break;
    1:     }
    1:     return pn;
    1: }
    1: 
 1577: #if JS_HAS_GENERATORS
 1577: 
 1577: /*
27012:  * A dedicated helper for transplanting the comprehension expression E in
27012:  *
27012:  *   [E for (V in I)]   // array comprehension
27012:  *   (E for (V in I))   // generator expression
27012:  *
27012:  * from its initial location in the AST, on the left of the 'for', to its final
27012:  * position on the right. To avoid a separate pass we do this by adjusting the
27012:  * blockids and name binding links that were established when E was parsed.
27012:  *
27012:  * A generator expression desugars like so:
27012:  *
27012:  *   (E for (V in I)) => (function () { for (var V in I) yield E; })()
27012:  *
27012:  * so the transplanter must adjust static level as well as blockid. E's source
27012:  * coordinates in root->pn_pos are critical to deciding which binding links to
27012:  * preserve and which to cut.
27012:  *
27012:  * NB: This is not a general tree transplanter -- it knows in particular that
27012:  * the one or more bindings induced by V have not yet been created.
27012:  */
27012: class CompExprTransplanter {
80631:     ParseNode       *root;
80631:     TreeContext     *tc;
27012:     bool            genexp;
27012:     uintN           adjust;
27012:     uintN           funcLevel;
27012: 
27012:   public:
80631:     CompExprTransplanter(ParseNode *pn, TreeContext *tc, bool ge, uintN adj)
27012:       : root(pn), tc(tc), genexp(ge), adjust(adj), funcLevel(0)
27012:     {
27012:     }
27012: 
80631:     bool transplant(ParseNode *pn);
27012: };
27012: 
27012: /*
72073:  * A helper for lazily checking for the presence of illegal |yield| or |arguments|
73053:  * tokens inside of generator expressions. This must be done lazily since we don't
73053:  * know whether we're in a generator expression until we see the "for" token after
73053:  * we've already parsed the body expression.
73053:  *
73053:  * Use in any context which may turn out to be inside a generator expression. This
73053:  * includes parenthesized expressions and argument lists, and it includes the tail
73053:  * of generator expressions.
73053:  *
73053:  * The guard will keep track of any |yield| or |arguments| tokens that occur while
73053:  * parsing the body. As soon as the parser reaches the end of the body expression,
73053:  * call endBody() to reset the context's state, and then immediately call:
73053:  *
73057:  * - checkValidBody() if this *did* turn out to be a generator expression
73057:  * - maybeNoteGenerator() if this *did not* turn out to be a generator expression
72073:  */
72073: class GenexpGuard {
80631:     TreeContext     *tc;
72073:     uint32          startYieldCount;
72073:     uint32          startArgumentsCount;
72073: 
72073:   public:
80631:     explicit GenexpGuard(TreeContext *tc)
72073:       : tc(tc)
72073:     {
72073:         if (tc->parenDepth == 0) {
72073:             tc->yieldCount = tc->argumentsCount = 0;
72073:             tc->yieldNode = tc->argumentsNode = NULL;
72073:         }
72073:         startYieldCount = tc->yieldCount;
72073:         startArgumentsCount = tc->argumentsCount;
72073:         tc->parenDepth++;
72073:     }
72073: 
72073:     void endBody();
80631:     bool checkValidBody(ParseNode *pn);
80631:     bool maybeNoteGenerator(ParseNode *pn);
72073: };
72073: 
72073: void
72073: GenexpGuard::endBody()
72073: {
72073:     tc->parenDepth--;
72073: }
72073: 
73053: /*
73053:  * Check whether a |yield| or |arguments| token has been encountered in the
73053:  * body expression, and if so, report an error.
73053:  *
73053:  * Call this after endBody() when determining that the body *was* in a
73053:  * generator expression.
73053:  */
72073: bool
80631: GenexpGuard::checkValidBody(ParseNode *pn)
72073: {
72073:     if (tc->yieldCount > startYieldCount) {
80631:         ParseNode *errorNode = tc->yieldNode;
72073:         if (!errorNode)
72073:             errorNode = pn;
72073:         tc->parser->reportErrorNumber(errorNode, JSREPORT_ERROR, JSMSG_BAD_GENEXP_BODY, js_yield_str);
72073:         return false;
72073:     }
72073: 
72073:     if (tc->argumentsCount > startArgumentsCount) {
80631:         ParseNode *errorNode = tc->argumentsNode;
72073:         if (!errorNode)
72073:             errorNode = pn;
72073:         tc->parser->reportErrorNumber(errorNode, JSREPORT_ERROR, JSMSG_BAD_GENEXP_BODY, js_arguments_str);
72073:         return false;
72073:     }
72073: 
72073:     return true;
72073: }
72073: 
72073: /*
73053:  * Check whether a |yield| token has been encountered in the body expression,
73053:  * and if so, note that the current function is a generator function.
73053:  *
73053:  * Call this after endBody() when determining that the body *was not* in a
73053:  * generator expression.
73053:  */
73053: bool
80631: GenexpGuard::maybeNoteGenerator(ParseNode *pn)
73053: {
73053:     if (tc->yieldCount > 0) {
73053:         tc->flags |= TCF_FUN_IS_GENERATOR;
73053:         if (!tc->inFunction()) {
73053:             tc->parser->reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_RETURN_OR_YIELD,
73053:                                           js_yield_str);
73053:             return false;
73053:         }
78006:         if (tc->flags & TCF_RETURN_EXPR) {
78006:             /* At the time we saw the yield, we might not have set TCF_FUN_IS_GENERATOR yet. */
78006:             ReportBadReturn(tc->parser->context, tc, pn, JSREPORT_ERROR,
78006:                             JSMSG_BAD_GENERATOR_RETURN,
78006:                             JSMSG_BAD_ANON_GENERATOR_RETURN);
78006:             return false;
78006:         }
73053:     }
73053:     return true;
73053: }
73053: 
73053: /*
27012:  * Any definitions nested within the comprehension expression of a generator
27012:  * expression must move "down" one static level, which of course increases the
27012:  * upvar-frame-skip count.
27012:  */
28814: static bool
80631: BumpStaticLevel(ParseNode *pn, TreeContext *tc)
27012: {
47573:     if (!pn->pn_cookie.isFree()) {
47573:         uintN level = pn->pn_cookie.level() + 1;
27012: 
27012:         JS_ASSERT(level >= tc->staticLevel);
47573:         if (level >= UpvarCookie::FREE_LEVEL) {
40860:             JS_ReportErrorNumber(tc->parser->context, js_GetErrorMessage, NULL,
28814:                                  JSMSG_TOO_DEEP, js_function_str);
28814:             return false;
28814:         }
28814: 
47573:         pn->pn_cookie.set(level, pn->pn_cookie.slot());
27012:     }
28814:     return true;
27012: }
27012: 
28122: static void
80631: AdjustBlockId(ParseNode *pn, uintN adjust, TreeContext *tc)
28122: {
78294:     JS_ASSERT(pn->isArity(PN_LIST) || pn->isArity(PN_FUNC) || pn->isArity(PN_NAME));
28122:     pn->pn_blockid += adjust;
28122:     if (pn->pn_blockid >= tc->blockidGen)
28122:         tc->blockidGen = pn->pn_blockid + 1;
28122: }
28122: 
27012: bool
80631: CompExprTransplanter::transplant(ParseNode *pn)
27012: {
27012:     if (!pn)
27012:         return true;
27012: 
78294:     switch (pn->getArity()) {
27012:       case PN_LIST:
80631:         for (ParseNode *pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
61059:             if (!transplant(pn2))
61059:                 return false;
61059:         }
27012:         if (pn->pn_pos >= root->pn_pos)
28122:             AdjustBlockId(pn, adjust, tc);
27012:         break;
27012: 
27012:       case PN_TERNARY:
61059:         if (!transplant(pn->pn_kid1) ||
61059:             !transplant(pn->pn_kid2) ||
61059:             !transplant(pn->pn_kid3))
61059:             return false;
27012:         break;
27012: 
27012:       case PN_BINARY:
61059:         if (!transplant(pn->pn_left))
61059:             return false;
28354: 
28354:         /* Binary TOK_COLON nodes can have left == right. See bug 492714. */
61059:         if (pn->pn_right != pn->pn_left) {
61059:             if (!transplant(pn->pn_right))
61059:                 return false;
61059:         }
27012:         break;
27012: 
27012:       case PN_UNARY:
61059:         if (!transplant(pn->pn_kid))
61059:             return false;
27012:         break;
27012: 
27012:       case PN_FUNC:
27012:       {
27012:         /*
27012:          * Only the first level of transplant recursion through functions needs
27012:          * to reparent the funbox, since all descendant functions are correctly
27012:          * linked under the top-most funbox. But every visit to this case needs
27012:          * to update funbox->level.
27012:          *
27012:          * Recall that funbox->level is the static level of the code containing
27012:          * the definition or expression of the function and not the static level
27012:          * of the function's body.
27012:          */
80631:         FunctionBox *funbox = pn->pn_funbox;
27012: 
27012:         funbox->level = tc->staticLevel + funcLevel;
27012:         if (++funcLevel == 1 && genexp) {
80631:             FunctionBox *parent = tc->funbox;
80631: 
80631:             FunctionBox **funboxp = &tc->parent->functionList;
27012:             while (*funboxp != funbox)
27012:                 funboxp = &(*funboxp)->siblings;
27012:             *funboxp = funbox->siblings;
27012: 
27012:             funbox->parent = parent;
27012:             funbox->siblings = parent->kids;
27012:             parent->kids = funbox;
27012:             funbox->level = tc->staticLevel;
27012:         }
27012:         /* FALL THROUGH */
27012:       }
27012: 
27012:       case PN_NAME:
61059:         if (!transplant(pn->maybeExpr()))
61059:             return false;
78294:         if (pn->isArity(PN_FUNC))
27012:             --funcLevel;
27012: 
78294:         if (pn->isDefn()) {
28814:             if (genexp && !BumpStaticLevel(pn, tc))
28814:                 return false;
78294:         } else if (pn->isUsed()) {
78294:             JS_ASSERT(!pn->isOp(JSOP_NOP));
47573:             JS_ASSERT(pn->pn_cookie.isFree());
27012: 
80631:             Definition *dn = pn->pn_lexdef;
78294:             JS_ASSERT(dn->isDefn());
27012: 
27012:             /*
27012:              * Adjust the definition's block id only if it is a placeholder not
27012:              * to the left of the root node, and if pn is the last use visited
27012:              * in the comprehension expression (to avoid adjusting the blockid
27012:              * multiple times).
27012:              *
27012:              * Non-placeholder definitions within the comprehension expression
27012:              * will be visited further below.
27012:              */
27012:             if (dn->isPlaceholder() && dn->pn_pos >= root->pn_pos && dn->dn_uses == pn) {
28814:                 if (genexp && !BumpStaticLevel(dn, tc))
28814:                     return false;
28122:                 AdjustBlockId(dn, adjust, tc);
27012:             }
27012: 
27012:             JSAtom *atom = pn->pn_atom;
27012: #ifdef DEBUG
80632:             StmtInfo *stmt = LexicalLookup(tc, atom, NULL);
27012:             JS_ASSERT(!stmt || stmt != tc->topStmt);
27012: #endif
78294:             if (genexp && !dn->isOp(JSOP_CALLEE)) {
72579:                 JS_ASSERT(!tc->decls.lookupFirst(atom));
27012: 
73066:                 if (dn->pn_pos < root->pn_pos) {
73066:                     /*
73066:                      * The variable originally appeared to be a use of a
73066:                      * definition or placeholder outside the generator, but now
73066:                      * we know it is scoped within the comprehension tail's
73066:                      * clauses. Make it (along with any other uses within the
73066:                      * generator) a use of a new placeholder in the generator's
73066:                      * lexdeps.
73066:                      */
80631:                     Definition *dn2 = MakePlaceholder(pn, tc);
27371:                     if (!dn2)
28814:                         return false;
61060:                     dn2->pn_pos = root->pn_pos;
27371: 
73066:                     /*
73066:                      * Change all uses of |dn| that lie within the generator's
73066:                      * |yield| expression into uses of dn2.
73066:                      */
80631:                     ParseNode **pnup = &dn->dn_uses;
80631:                     ParseNode *pnu;
27371:                     while ((pnu = *pnup) != NULL && pnu->pn_pos >= root->pn_pos) {
27371:                         pnu->pn_lexdef = dn2;
30457:                         dn2->pn_dflags |= pnu->pn_dflags & PND_USE2DEF_FLAGS;
27371:                         pnup = &pnu->pn_link;
27371:                     }
27371:                     dn2->dn_uses = dn->dn_uses;
27371:                     dn->dn_uses = *pnup;
27371:                     *pnup = NULL;
73941:                     if (!tc->lexdeps->put(atom, dn2))
73941:                         return false;
73066:                 } else if (dn->isPlaceholder()) {
73066:                     /*
73066:                      * The variable first occurs free in the 'yield' expression;
73066:                      * move the existing placeholder node (and all its uses)
73066:                      * from the parent's lexdeps into the generator's lexdeps.
73066:                      */
73066:                     tc->parent->lexdeps->remove(atom);
72579:                     if (!tc->lexdeps->put(atom, dn))
72579:                         return false;
27012:                 }
27012:             }
27012:         }
27012: 
27012:         if (pn->pn_pos >= root->pn_pos)
28122:             AdjustBlockId(pn, adjust, tc);
27012:         break;
27012: 
27012:       case PN_NAMESET:
61059:         if (!transplant(pn->pn_tree))
61059:             return false;
27012:         break;
78296: 
78296:       case PN_NULLARY:
78296:         /* Nothing. */
78296:         break;
27012:     }
27012:     return true;
27012: }
27012: 
27012: /*
 1577:  * Starting from a |for| keyword after the first array initialiser element or
 1577:  * an expression in an open parenthesis, parse the tail of the comprehension
 1577:  * or generator expression signified by this |for| keyword in context.
 1577:  *
 1577:  * Return null on failure, else return the top-most parse node for the array
 1577:  * comprehension or generator expression, with a unary node as the body of the
82024:  * (possibly nested) for-loop, initialized by |kind, op, kid|.
 1577:  */
80631: ParseNode *
80631: Parser::comprehensionTail(ParseNode *kid, uintN blockid, bool isGenexp,
82024:                           ParseNodeKind kind, JSOp op)
40239: {
27012:     uintN adjust;
80631:     ParseNode *pn, *pn2, *pn3, **pnp;
80631:     StmtInfo stmtInfo;
 1577:     BindData data;
40320:     TokenKind tt;
 1577: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_FOR);
 1577: 
82024:     if (kind == PNK_SEMI) {
27012:         /*
27012:          * Generator expression desugars to an immediately applied lambda that
27012:          * yields the next value from a for-in loop (possibly nested, and with
27012:          * optional if guard). Make pn be the TOK_LC body node.
 1577:          */
40239:         pn = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
 1577:         if (!pn)
 1577:             return NULL;
27012:         adjust = pn->pn_blockid - blockid;
27012:     } else {
82024:         JS_ASSERT(kind == PNK_ARRAYPUSH);
27012: 
27012:         /*
27012:          * Make a parse-node and literal object representing the block scope of
40239:          * this array comprehension. Our caller in primaryExpr, the TOK_LB case
27012:          * aka the array initialiser case, has passed the blockid to claim for
27012:          * the comprehension's block scope. We allocate that id or one above it
80632:          * here, by calling PushLexicalScope.
27012:          *
27012:          * In the case of a comprehension expression that has nested blocks
27012:          * (e.g., let expressions), we will allocate a higher blockid but then
27012:          * slide all blocks "to the right" to make room for the comprehension's
27012:          * block scope.
27012:          */
27012:         adjust = tc->blockid();
40239:         pn = PushLexicalScope(context, &tokenStream, tc, &stmtInfo);
27012:         if (!pn)
27012:             return NULL;
27012: 
27012:         JS_ASSERT(blockid <= pn->pn_blockid);
27012:         JS_ASSERT(blockid < tc->blockidGen);
27012:         JS_ASSERT(tc->bodyid < blockid);
27012:         pn->pn_blockid = stmtInfo.blockid = blockid;
27012:         JS_ASSERT(adjust < blockid);
27012:         adjust = blockid - adjust;
27012:     }
27012: 
 1577:     pnp = &pn->pn_expr;
 1577: 
82024:     CompExprTransplanter transplanter(kid, tc, kind == PNK_SEMI, adjust);
27012:     transplanter.transplant(kid);
27012: 
 1577:     data.pn = NULL;
 1577:     data.op = JSOP_NOP;
 1577:     data.binder = BindLet;
27012:     data.let.overflow = JSMSG_ARRAY_INIT_TOO_BIG;
27012: 
 1577:     do {
 1577:         /*
 1577:          * FOR node is binary, left is loop control and right is body.  Use
 1577:          * index to count each block-local let-variable on the left-hand side
 1577:          * of the IN.
 1577:          */
82024:         pn2 = BinaryNode::create(PNK_FOR, tc);
 1577:         if (!pn2)
 1577:             return NULL;
 1577: 
78294:         pn2->setOp(JSOP_ITER);
15613:         pn2->pn_iflags = JSITER_ENUMERATE;
40354:         if (tokenStream.matchToken(TOK_NAME)) {
80443:             if (tokenStream.currentToken().name() == context->runtime->atomState.eachAtom)
15613:                 pn2->pn_iflags |= JSITER_FOREACH;
 1577:             else
40354:                 tokenStream.ungetToken();
 1577:         }
 1577:         MUST_MATCH_TOKEN(TOK_LP, JSMSG_PAREN_AFTER_FOR);
 1577: 
72073:         GenexpGuard guard(tc);
72073: 
80443:         PropertyName *name = NULL;
40354:         tt = tokenStream.getToken();
 1577:         switch (tt) {
 1577: #if JS_HAS_DESTRUCTURING
 1577:           case TOK_LB:
 1577:           case TOK_LC:
33753:             tc->flags |= TCF_DECL_DESTRUCTURING;
40263:             pn3 = primaryExpr(tt, JS_FALSE);
33753:             tc->flags &= ~TCF_DECL_DESTRUCTURING;
 1577:             if (!pn3)
 1577:                 return NULL;
 1577:             break;
 1577: #endif
 1577: 
 1577:           case TOK_NAME:
80443:             name = tokenStream.currentToken().name();
 1577: 
 1577:             /*
 1577:              * Create a name node with pn_op JSOP_NAME.  We can't set pn_op to
 1577:              * JSOP_GETLOCAL here, because we don't yet know the block's depth
 1577:              * in the operand stack frame.  The code generator computes that,
 1577:              * and it tries to bind all names to slots, so we must let it do
 1577:              * the deed.
 1577:              */
80443:             pn3 = NewBindingNode(name, tc, true);
 1577:             if (!pn3)
 1577:                 return NULL;
 1577:             break;
 1577: 
 1577:           default:
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NO_VARIABLE_NAME);
 1607: 
 1607:           case TOK_ERROR:
 1577:             return NULL;
 1577:         }
 1577: 
 1577:         MUST_MATCH_TOKEN(TOK_IN, JSMSG_IN_AFTER_FOR_NAME);
80631:         ParseNode *pn4 = expr();
27012:         if (!pn4)
27012:             return NULL;
 1577:         MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_AFTER_FOR_CTRL);
27012: 
72073:         guard.endBody();
72073: 
73053:         if (isGenexp) {
73053:             if (!guard.checkValidBody(pn2))
73053:                 return NULL;
74093:         } else {
78006:             if (!guard.maybeNoteGenerator(pn2))
73053:                 return NULL;
73053:         }
72073: 
27012:         switch (tt) {
27012: #if JS_HAS_DESTRUCTURING
27012:           case TOK_LB:
27012:           case TOK_LC:
68922:             if (!CheckDestructuring(context, &data, pn3, tc))
40239:                 return NULL;
40239: 
61450:             if (versionNumber() == JSVERSION_1_7) {
27012:                 /* Destructuring requires [key, value] enumeration in JS1.7. */
82024:                 if (!pn3->isKind(PNK_RB) || pn3->pn_count != 2) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_FOR_LEFTSIDE);
27012:                     return NULL;
27012:                 }
27012: 
78294:                 JS_ASSERT(pn2->isOp(JSOP_ITER));
27012:                 JS_ASSERT(pn2->pn_iflags & JSITER_ENUMERATE);
27012:                 if (!(pn2->pn_iflags & JSITER_FOREACH))
27012:                     pn2->pn_iflags |= JSITER_FOREACH | JSITER_KEYVALUE;
27012:             }
27012:             break;
27012: #endif
27012: 
27012:           case TOK_NAME:
27012:             data.pn = pn3;
80443:             if (!data.binder(context, &data, name, tc))
27012:                 return NULL;
27012:             break;
27012: 
27012:           default:;
27012:         }
27012: 
74052:         /*
74052:          * Synthesize a declaration. Every definition must appear in the parse
74052:          * tree in order for ComprehensionTranslator to work.
74052:          */
82024:         ParseNode *vars = ListNode::create(PNK_VAR, tc);
74052:         if (!vars)
74052:             return NULL;
78294:         vars->setOp(JSOP_NOP);
74052:         vars->pn_pos = pn3->pn_pos;
74052:         vars->makeEmpty();
74052:         vars->append(pn3);
74052:         vars->pn_xflags |= PNX_FORINVAR;
74052: 
74052:         /* Definitions can't be passed directly to EmitAssignment as lhs. */
74052:         pn3 = CloneLeftHandSide(pn3, tc);
74052:         if (!pn3)
74052:             return NULL;
74052: 
82024:         pn2->pn_left = new_<TernaryNode>(PNK_IN, JSOP_NOP, vars, pn3, pn4);
27012:         if (!pn2->pn_left)
27012:             return NULL;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_right;
40354:     } while (tokenStream.matchToken(TOK_FOR));
40354: 
40354:     if (tokenStream.matchToken(TOK_IF)) {
82024:         pn2 = TernaryNode::create(PNK_IF, tc);
 1577:         if (!pn2)
 1577:             return NULL;
40263:         pn2->pn_kid1 = condition();
 1577:         if (!pn2->pn_kid1)
 1577:             return NULL;
 1577:         *pnp = pn2;
 1577:         pnp = &pn2->pn_kid2;
 1577:     }
 1577: 
82024:     pn2 = UnaryNode::create(kind, tc);
 1577:     if (!pn2)
 1577:         return NULL;
78294:     pn2->setOp(op);
 1577:     pn2->pn_kid = kid;
 1577:     *pnp = pn2;
 1577: 
27012:     PopStatement(tc);
 1577:     return pn;
 1577: }
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
 1577: 
 1577: /*
 1577:  * Starting from a |for| keyword after an expression, parse the comprehension
 1577:  * tail completing this generator expression. Wrap the expression at kid in a
 1577:  * generator function that is immediately called to evaluate to the generator
 1577:  * iterator that is the value of this generator expression.
 1577:  *
61058:  * |kid| must be the expression before the |for| keyword; we return an
61058:  * application of a generator function that includes the |for| loops and
61058:  * |if| guards, with |kid| as the operand of a |yield| expression as the
61058:  * innermost loop body.
 1577:  *
 1577:  * Note how unlike Python, we do not evaluate the expression to the right of
 1577:  * the first |in| in the chain of |for| heads. Instead, a generator expression
 1577:  * is merely sugar for a generator function expression and its application.
 1577:  */
80631: ParseNode *
80631: Parser::generatorExpr(ParseNode *kid)
61058: {
82024:     JS_ASSERT(tokenStream.isCurrentTokenType(TOK_FOR));
82024: 
61058:     /* Create a |yield| node for |kid|. */
82024:     ParseNode *pn = UnaryNode::create(PNK_YIELD, tc);
61058:     if (!pn)
61058:         return NULL;
78294:     pn->setOp(JSOP_YIELD);
78294:     pn->setInParens(true);
 1577:     pn->pn_pos = kid->pn_pos;
 1577:     pn->pn_kid = kid;
31479:     pn->pn_hidden = true;
 1577: 
27012:     /* Make a new node for the desugared generator function. */
82024:     ParseNode *genfn = FunctionNode::create(PNK_FUNCTION, tc);
27012:     if (!genfn)
27012:         return NULL;
78294:     genfn->setOp(JSOP_LAMBDA);
27012:     JS_ASSERT(!genfn->pn_body);
27012:     genfn->pn_dflags = PND_FUNARG;
27012: 
27012:     {
80631:         TreeContext *outertc = tc;
80631:         TreeContext gentc(tc->parser);
72579:         if (!gentc.init(context))
72579:             return NULL;
27012: 
80631:         FunctionBox *funbox = EnterFunction(genfn, &gentc);
27012:         if (!funbox)
27012:             return NULL;
27012: 
27236:         /*
40263:          * We have to dance around a bit to propagate sharp variables from
40263:          * outertc to gentc before setting TCF_HAS_SHARPS implicitly by
40263:          * propagating all of outertc's TCF_FUN_FLAGS flags. As below, we have
40263:          * to be conservative by leaving TCF_HAS_SHARPS set in outertc if we
40263:          * do propagate to gentc.
40263:          */
40263:         if (outertc->flags & TCF_HAS_SHARPS) {
32757:             gentc.flags |= TCF_IN_FUNCTION;
32757:             if (!gentc.ensureSharpSlots())
32757:                 return NULL;
32757:         }
32757: 
32757:         /*
27236:          * We assume conservatively that any deoptimization flag in tc->flags
27236:          * besides TCF_FUN_PARAM_ARGUMENTS can come from the kid. So we
27236:          * propagate these flags into genfn. For code simplicity we also do
27236:          * not detect if the flags were only set in the kid and could be
27236:          * removed from tc->flags.
27236:          */
27236:         gentc.flags |= TCF_FUN_IS_GENERATOR | TCF_GENEXP_LAMBDA |
77343:                        (outertc->flags & (TCF_FUN_FLAGS & ~TCF_FUN_PARAM_ARGUMENTS));
27012:         funbox->tcflags |= gentc.flags;
27012:         genfn->pn_funbox = funbox;
27012:         genfn->pn_blockid = gentc.bodyid;
27012: 
80631:         ParseNode *body = comprehensionTail(pn, outertc->blockid(), true);
 1577:         if (!body)
 1577:             return NULL;
27012:         JS_ASSERT(!genfn->pn_body);
27012:         genfn->pn_body = body;
27012:         genfn->pn_pos.begin = body->pn_pos.begin = kid->pn_pos.begin;
40270:         genfn->pn_pos.end = body->pn_pos.end = tokenStream.currentToken().pos.end;
40221: 
40263:         if (!LeaveFunction(genfn, &gentc))
27012:             return NULL;
27012:     }
27012: 
27012:     /*
27012:      * Our result is a call expression that invokes the anonymous generator
27012:      * function object.
27012:      */
82024:     ParseNode *result = ListNode::create(PNK_LP, tc);
27012:     if (!result)
27012:         return NULL;
78294:     result->setOp(JSOP_CALL);
27012:     result->pn_pos.begin = genfn->pn_pos.begin;
27012:     result->initList(genfn);
27012:     return result;
 1577: }
 1577: 
 1577: static const char js_generator_str[] = "generator";
 1577: 
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: #endif /* JS_HAS_GENERATORS */
 1577: 
40239: JSBool
80631: Parser::argumentList(ParseNode *listNode)
    1: {
40854:     if (tokenStream.matchToken(TOK_RP, TSF_OPERAND))
40854:         return JS_TRUE;
40854: 
72073:     GenexpGuard guard(tc);
72565:     bool arg0 = true;
72073: 
    1:     do {
80631:         ParseNode *argNode = assignExpr();
    1:         if (!argNode)
    1:             return JS_FALSE;
73053:         if (arg0)
72565:             guard.endBody();
72565: 
    1: #if JS_HAS_GENERATORS
82024:         if (argNode->isKind(PNK_YIELD) &&
78294:             !argNode->isInParens() &&
40354:             tokenStream.peekToken() == TOK_COMMA) {
42671:             reportErrorNumber(argNode, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX, js_yield_str);
    1:             return JS_FALSE;
    1:         }
    1: #endif
 1577: #if JS_HAS_GENERATOR_EXPRS
40354:         if (tokenStream.matchToken(TOK_FOR)) {
72073:             if (!guard.checkValidBody(argNode))
72073:                 return JS_FALSE;
61058:             argNode = generatorExpr(argNode);
 1577:             if (!argNode)
 1577:                 return JS_FALSE;
 1577:             if (listNode->pn_count > 1 ||
40354:                 tokenStream.peekToken() == TOK_COMMA) {
42671:                 reportErrorNumber(argNode, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX,
 1577:                                   js_generator_str);
 1577:                 return JS_FALSE;
 1577:             }
73053:         } else
 1577: #endif
78006:         if (arg0 && !guard.maybeNoteGenerator(argNode))
73053:             return JS_FALSE;
73053: 
73053:         arg0 = false;
73053: 
27012:         listNode->append(argNode);
40354:     } while (tokenStream.matchToken(TOK_COMMA));
40354: 
40354:     if (tokenStream.getToken() != TOK_RP) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_PAREN_AFTER_ARGS);
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
27012: /* Check for an immediately-applied (new'ed) lambda and clear PND_FUNARG. */
80631: static ParseNode *
80631: CheckForImmediatelyAppliedLambda(ParseNode *pn)
27012: {
82024:     if (pn->isKind(PNK_FUNCTION)) {
78294:         JS_ASSERT(pn->isArity(PN_FUNC));
27051: 
80631:         FunctionBox *funbox = pn->pn_funbox;
64294:         JS_ASSERT((funbox->function())->flags & JSFUN_LAMBDA);
32658:         if (!(funbox->tcflags & (TCF_FUN_USES_ARGUMENTS | TCF_FUN_USES_OWN_NAME)))
27012:             pn->pn_dflags &= ~PND_FUNARG;
27012:     }
27012:     return pn;
27012: }
27012: 
80631: ParseNode *
40860: Parser::memberExpr(JSBool allowCallSyntax)
    1: {
80631:     ParseNode *pn, *pn2, *pn3;
40221: 
40239:     JS_CHECK_RECURSION(context, return NULL);
    1: 
    1:     /* Check for new expression first. */
40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
    1:     if (tt == TOK_NEW) {
82024:         pn = ListNode::create(PNK_NEW, tc);
    1:         if (!pn)
    1:             return NULL;
40263:         pn2 = memberExpr(JS_FALSE);
    1:         if (!pn2)
    1:             return NULL;
27012:         pn2 = CheckForImmediatelyAppliedLambda(pn2);
78294:         pn->setOp(JSOP_NEW);
27012:         pn->initList(pn2);
    1:         pn->pn_pos.begin = pn2->pn_pos.begin;
    1: 
40354:         if (tokenStream.matchToken(TOK_LP) && !argumentList(pn))
    1:             return NULL;
    1:         if (pn->pn_count > ARGC_LIMIT) {
40239:             JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
    1:                                  JSMSG_TOO_MANY_CON_ARGS);
    1:             return NULL;
    1:         }
27012:         pn->pn_pos.end = pn->last()->pn_pos.end;
    1:     } else {
40263:         pn = primaryExpr(tt, JS_FALSE);
    1:         if (!pn)
    1:             return NULL;
    1: 
82018:         if (pn->isXMLNameOp()) {
82114:             pn = new_<UnaryNode>(PNK_XMLUNARY, JSOP_XMLNAME, pn->pn_pos, pn);
80640:             if (!pn)
80640:                 return NULL;
    1:         }
    1:     }
    1: 
40354:     while ((tt = tokenStream.getToken()) > TOK_EOF) {
    1:         if (tt == TOK_DOT) {
82024:             pn2 = NameNode::create(PNK_DOT, NULL, tc);
    1:             if (!pn2)
    1:                 return NULL;
80780: 
    1: #if JS_HAS_XML_SUPPORT
40854:             tt = tokenStream.getToken(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
64241: 
64241:             /* Treat filters as 'with' statements for name deoptimization. */
80631:             ParseNode *oldWith = tc->innermostWith;
80631:             StmtInfo stmtInfo;
64241:             if (tt == TOK_LP) {
80780:                 if (tc->inStrictMode()) {
80780:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NAME_AFTER_DOT);
80780:                     return NULL;
80780:                 }
80780: 
64241:                 tc->innermostWith = pn;
80632:                 PushStatement(tc, &stmtInfo, STMT_WITH, -1);
64241:             }
64241: 
40263:             pn3 = primaryExpr(tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
31479: 
64241:             if (tt == TOK_LP) {
64241:                 tc->innermostWith = oldWith;
64241:                 PopStatement(tc);
64241:             }
64241: 
31479:             /* Check both tt and pn_type, to distinguish |x.(y)| and |x.y::z| from |x.y|. */
82024:             if (tt == TOK_NAME && pn3->isKind(PNK_NAME)) {
78294:                 pn2->setOp(JSOP_GETPROP);
    1:                 pn2->pn_expr = pn;
    1:                 pn2->pn_atom = pn3->pn_atom;
80641:                 freeTree(pn3);
    1:             } else {
31479:                 if (tt == TOK_LP) {
82024:                     pn2->setKind(PNK_FILTER);
78294:                     pn2->setOp(JSOP_FILTER);
31479: 
31479:                     /* A filtering predicate is like a with statement. */
31479:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
82024:                 } else if (pn3->isXMLPropertyIdentifier()) {
80780:                     JS_ASSERT(!tc->inStrictMode());
82024:                     pn2->setKind(PNK_LB);
78294:                     pn2->setOp(JSOP_GETELEM);
    1:                 } else {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NAME_AFTER_DOT);
    1:                     return NULL;
    1:                 }
78294:                 pn2->setArity(PN_BINARY);
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
    1:             }
    1: #else
40854:             MUST_MATCH_TOKEN_WITH_FLAGS(TOK_NAME, JSMSG_NAME_AFTER_DOT, TSF_KEYWORD_IS_NAME);
78294:             pn2->setOp(JSOP_GETPROP);
    1:             pn2->pn_expr = pn;
80443:             pn2->pn_atom = tokenStream.currentToken().name();
    1: #endif
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: #if JS_HAS_XML_SUPPORT
    1:         } else if (tt == TOK_DBLDOT) {
80780:             if (tc->inStrictMode()) {
80780:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NAME_AFTER_DOT);
80780:                 return NULL;
80780:             }
80780: 
82024:             pn2 = BinaryNode::create(PNK_DBLDOT, tc);
    1:             if (!pn2)
    1:                 return NULL;
40854:             tt = tokenStream.getToken(TSF_OPERAND | TSF_KEYWORD_IS_NAME);
40263:             pn3 = primaryExpr(tt, JS_TRUE);
    1:             if (!pn3)
    1:                 return NULL;
82024:             if (pn3->isKind(PNK_NAME) && !pn3->isInParens()) {
82024:                 pn3->setKind(PNK_STRING);
78294:                 pn3->setArity(PN_NULLARY);
78294:                 pn3->setOp(JSOP_QNAMEPART);
82024:             } else if (!pn3->isXMLPropertyIdentifier()) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_NAME_AFTER_DOT);
    1:                 return NULL;
    1:             }
78294:             pn2->setOp(JSOP_DESCENDANTS);
    1:             pn2->pn_left = pn;
    1:             pn2->pn_right = pn3;
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: #endif
    1:         } else if (tt == TOK_LB) {
82024:             pn2 = BinaryNode::create(PNK_LB, tc);
    1:             if (!pn2)
    1:                 return NULL;
40263:             pn3 = expr();
    1:             if (!pn3)
    1:                 return NULL;
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_IN_INDEX);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: 
18392:             /*
18392:              * Optimize o['p'] to o.p by rewriting pn2, but avoid rewriting
18392:              * o['0'] to use JSOP_GETPROP, to keep fast indexing disjoint in
18392:              * the interpreter from fast property access. However, if the
18392:              * bracketed string is a uint32, we rewrite pn3 to be a number
18392:              * instead of a string.
18392:              */
18392:             do {
82024:                 if (pn3->isKind(PNK_STRING)) {
18392:                     jsuint index;
18392: 
18392:                     if (!js_IdIsIndex(ATOM_TO_JSID(pn3->pn_atom), &index)) {
82024:                         pn2->setKind(PNK_DOT);
78294:                         pn2->setOp(JSOP_GETPROP);
78294:                         pn2->setArity(PN_NAME);
    1:                         pn2->pn_expr = pn;
    1:                         pn2->pn_atom = pn3->pn_atom;
18392:                         break;
18392:                     }
82024:                     pn3->setKind(PNK_NUMBER);
78294:                     pn3->setOp(JSOP_DOUBLE);
18392:                     pn3->pn_dval = index;
18392:                 }
78294:                 pn2->setOp(JSOP_GETELEM);
    1:                 pn2->pn_left = pn;
    1:                 pn2->pn_right = pn3;
18392:             } while (0);
    1:         } else if (allowCallSyntax && tt == TOK_LP) {
82024:             pn2 = ListNode::create(PNK_LP, tc);
    1:             if (!pn2)
    1:                 return NULL;
78294:             pn2->setOp(JSOP_CALL);
27012: 
27012:             pn = CheckForImmediatelyAppliedLambda(pn);
78294:             if (pn->isOp(JSOP_NAME)) {
40239:                 if (pn->pn_atom == context->runtime->atomState.evalAtom) {
27012:                     /* Select JSOP_EVAL and flag tc as heavyweight. */
78294:                     pn2->setOp(JSOP_EVAL);
51096:                     tc->noteCallsEval();
42780:                     tc->flags |= TCF_FUN_HEAVYWEIGHT;
64296:                     /*
64296:                      * In non-strict mode code, direct calls to eval can add
64296:                      * variables to the call object.
64296:                      */
64296:                     if (!tc->inStrictMode())
64296:                         tc->noteHasExtensibleScope();
27012:                 }
78294:             } else if (pn->isOp(JSOP_GETPROP)) {
57712:                 /* Select JSOP_FUNAPPLY given foo.apply(...). */
57712:                 if (pn->pn_atom == context->runtime->atomState.applyAtom)
78294:                     pn2->setOp(JSOP_FUNAPPLY);
57712:                 else if (pn->pn_atom == context->runtime->atomState.callAtom)
78294:                     pn2->setOp(JSOP_FUNCALL);
27012:             }
27012: 
27012:             pn2->initList(pn);
    1:             pn2->pn_pos.begin = pn->pn_pos.begin;
    1: 
40263:             if (!argumentList(pn2))
    1:                 return NULL;
    1:             if (pn2->pn_count > ARGC_LIMIT) {
40239:                 JS_ReportErrorNumber(context, js_GetErrorMessage, NULL,
    1:                                      JSMSG_TOO_MANY_FUN_ARGS);
    1:                 return NULL;
    1:             }
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         } else {
40354:             tokenStream.ungetToken();
    1:             return pn;
    1:         }
    1: 
    1:         pn = pn2;
    1:     }
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
40860: Parser::bracketedExpr()
    1: {
    1:     uintN oldflags;
80631:     ParseNode *pn;
    1: 
    1:     /*
    1:      * Always accept the 'in' operator in a parenthesized expression,
    1:      * where it's unambiguous, even if we might be parsing the init of a
    1:      * for statement.
    1:      */
    1:     oldflags = tc->flags;
    1:     tc->flags &= ~TCF_IN_FOR_INIT;
40263:     pn = expr();
    1:     tc->flags = oldflags | (tc->flags & TCF_FUN_FLAGS);
    1:     return pn;
    1: }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
80631: ParseNode *
40860: Parser::endBracketedExpr()
    1: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
80631:     ParseNode *pn = bracketedExpr();
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_ATTR_EXPR);
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * From the ECMA-357 grammar in 11.1.1 and 11.1.2:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ PropertySelector
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *
    1:  * We adapt AttributeIdentifier and QualifiedIdentier to be LL(1), like so:
    1:  *
    1:  *      AttributeIdentifier:
    1:  *              @ QualifiedIdentifier
    1:  *              @ [ Expression ]
    1:  *
    1:  *      PropertySelector:
    1:  *              Identifier
    1:  *              *
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector :: PropertySelector
    1:  *              PropertySelector :: [ Expression ]
    1:  *              PropertySelector
    1:  *
    1:  * As PrimaryExpression: Identifier is in ECMA-262 and we want the semantics
    1:  * for that rule to result in a name node, but ECMA-357 extends the grammar
    1:  * to include PrimaryExpression: QualifiedIdentifier, we must factor further:
    1:  *
    1:  *      QualifiedIdentifier:
    1:  *              PropertySelector QualifiedSuffix
    1:  *
    1:  *      QualifiedSuffix:
    1:  *              :: PropertySelector
    1:  *              :: [ Expression ]
    1:  *              /nothing/
    1:  *
    1:  * And use this production instead of PrimaryExpression: QualifiedIdentifier:
    1:  *
    1:  *      PrimaryExpression:
    1:  *              Identifier QualifiedSuffix
    1:  *
    1:  * We hoist the :: match into callers of QualifiedSuffix, in order to tweak
    1:  * PropertySelector vs. Identifier pn_arity, pn_op, and other members.
    1:  */
80631: ParseNode *
40860: Parser::propertySelector()
    1: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
82024:     ParseNode *selector;
82024:     if (tokenStream.isCurrentTokenType(TOK_STAR)) {
82024:         selector = NullaryNode::create(PNK_ANYNAME, tc);
82024:         if (!selector)
82024:             return NULL;
82024:         selector->setOp(JSOP_ANYNAME);
82024:         selector->pn_atom = context->runtime->atomState.starAtom;
    1:     } else {
82024:         JS_ASSERT(tokenStream.isCurrentTokenType(TOK_NAME));
82024:         selector = NullaryNode::create(PNK_NAME, tc);
82024:         if (!selector)
82024:             return NULL;
82024:         selector->setOp(JSOP_QNAMEPART);
82024:         selector->setArity(PN_NAME);
82024:         selector->pn_atom = tokenStream.currentToken().name();
82024:         selector->pn_cookie.makeFree();
82024:     }
82024:     return selector;
    1: }
    1: 
80631: ParseNode *
80631: Parser::qualifiedSuffix(ParseNode *pn)
80631: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_DBLCOLON);
82024:     ParseNode *pn2 = NameNode::create(PNK_DBLCOLON, NULL, tc);
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     /* Left operand of :: must be evaluated if it is an identifier. */
78294:     if (pn->isOp(JSOP_QNAMEPART))
78294:         pn->setOp(JSOP_NAME);
    1: 
82024:     TokenKind tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
40239:         /* Inline and specialize propertySelector for JSOP_QNAMECONST. */
78294:         pn2->setOp(JSOP_QNAMECONST);
27012:         pn2->pn_pos.begin = pn->pn_pos.begin;
    1:         pn2->pn_atom = (tt == TOK_STAR)
40239:                        ? context->runtime->atomState.starAtom
80443:                        : tokenStream.currentToken().name();
    1:         pn2->pn_expr = pn;
47573:         pn2->pn_cookie.makeFree();
    1:         return pn2;
    1:     }
    1: 
    1:     if (tt != TOK_LB) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
82024:     ParseNode *pn3 = endBracketedExpr();
    1:     if (!pn3)
    1:         return NULL;
    1: 
78294:     pn2->setOp(JSOP_QNAME);
78294:     pn2->setArity(PN_BINARY);
27012:     pn2->pn_pos.begin = pn->pn_pos.begin;
27012:     pn2->pn_pos.end = pn3->pn_pos.end;
    1:     pn2->pn_left = pn;
    1:     pn2->pn_right = pn3;
    1:     return pn2;
    1: }
    1: 
80631: ParseNode *
40860: Parser::qualifiedIdentifier()
    1: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
80631:     ParseNode *pn = propertySelector();
    1:     if (!pn)
    1:         return NULL;
40354:     if (tokenStream.matchToken(TOK_DBLCOLON)) {
28948:         /* Hack for bug 496316. Slowing down E4X won't make it go away, alas. */
28948:         tc->flags |= TCF_FUN_HEAVYWEIGHT;
40263:         pn = qualifiedSuffix(pn);
28948:     }
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
40860: Parser::attributeIdentifier()
    1: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_AT);
82024:     ParseNode *pn = UnaryNode::create(PNK_AT, tc);
    1:     if (!pn)
    1:         return NULL;
78294:     pn->setOp(JSOP_TOATTRNAME);
82024: 
82024:     ParseNode *pn2;
82024:     TokenKind tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
    1:     if (tt == TOK_STAR || tt == TOK_NAME) {
40263:         pn2 = qualifiedIdentifier();
    1:     } else if (tt == TOK_LB) {
40263:         pn2 = endBracketedExpr();
    1:     } else {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     if (!pn2)
    1:         return NULL;
    1:     pn->pn_kid = pn2;
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Make a TOK_LC unary node whose pn_kid is an expression.
    1:  */
80631: ParseNode *
40860: Parser::xmlExpr(JSBool inTag)
    1: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LC);
82024:     ParseNode *pn = UnaryNode::create(PNK_LC, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
    1:     /*
38596:      * Turn off XML tag mode. We save the old value of the flag because it may
38596:      * already be off: XMLExpr is called both from within a tag, and from
38596:      * within text contained in an element, but outside of any start, end, or
38596:      * point tag.
38596:      */
40854:     bool oldflag = tokenStream.isXMLTagMode();
40854:     tokenStream.setXMLTagMode(false);
82024:     ParseNode *pn2 = expr();
    1:     if (!pn2)
    1:         return NULL;
    1: 
    1:     MUST_MATCH_TOKEN(TOK_RC, JSMSG_CURLY_IN_XML_EXPR);
40854:     tokenStream.setXMLTagMode(oldflag);
    1:     pn->pn_kid = pn2;
78294:     pn->setOp(inTag ? JSOP_XMLTAGEXPR : JSOP_XMLELTEXPR);
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
82024: Parser::atomNode(ParseNodeKind kind, JSOp op)
82024: {
82024:     ParseNode *node = NullaryNode::create(kind, tc);
82024:     if (!node)
82024:         return NULL;
82024:     node->setOp(op);
40854:     const Token &tok = tokenStream.currentToken();
82024:     node->pn_atom = tok.atom();
82024:     return node;
    1: }
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLNameExpr:
    1:  *              XMLName XMLNameExpr?
    1:  *              { Expr } XMLNameExpr?
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according as XMLNameExpr produces
    1:  * a list of names and/or expressions, a single expression, or a single name.
82024:  * If PN_LIST or PN_NULLARY, getKind() will be PNK_XMLNAME.  Otherwise if
82024:  * PN_UNARY, getKind() will be PNK_LC.
    1:  */
80631: ParseNode *
40860: Parser::xmlNameExpr()
    1: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
80631:     ParseNode *pn, *pn2, *list;
40320:     TokenKind tt;
    1: 
    1:     pn = list = NULL;
    1:     do {
40270:         tt = tokenStream.currentToken().type;
    1:         if (tt == TOK_LC) {
40263:             pn2 = xmlExpr(JS_TRUE);
    1:             if (!pn2)
    1:                 return NULL;
    1:         } else {
    1:             JS_ASSERT(tt == TOK_XMLNAME);
82024:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_STRING);
82024:             pn2 = atomNode(PNK_XMLNAME, JSOP_STRING);
    1:             if (!pn2)
    1:                 return NULL;
    1:         }
    1: 
    1:         if (!pn) {
    1:             pn = pn2;
    1:         } else {
    1:             if (!list) {
82024:                 list = ListNode::create(PNK_XMLNAME, tc);
    1:                 if (!list)
    1:                     return NULL;
    1:                 list->pn_pos.begin = pn->pn_pos.begin;
27012:                 list->initList(pn);
27012:                 list->pn_xflags = PNX_CANTFOLD;
    1:                 pn = list;
    1:             }
    1:             pn->pn_pos.end = pn2->pn_pos.end;
27012:             pn->append(pn2);
    1:         }
40354:     } while ((tt = tokenStream.getToken()) == TOK_XMLNAME || tt == TOK_LC);
40354: 
40354:     tokenStream.ungetToken();
    1:     return pn;
    1: }
    1: 
    1: /*
    1:  * Macro to test whether an XMLNameExpr or XMLTagContent node can be folded
    1:  * at compile time into a JSXML tree.
    1:  */
78294: #define XML_FOLDABLE(pn)        ((pn)->isArity(PN_LIST)                     \
27012:                                  ? ((pn)->pn_xflags & PNX_CANTFOLD) == 0    \
82024:                                  : !(pn)->isKind(PNK_LC))
    1: 
    1: /*
    1:  * Parse the productions:
    1:  *
    1:  *      XMLTagContent:
    1:  *              XMLNameExpr
    1:  *              XMLTagContent S XMLNameExpr S? = S? XMLAttr
    1:  *              XMLTagContent S XMLNameExpr S? = S? { Expr }
    1:  *
    1:  * Return a PN_LIST, PN_UNARY, or PN_NULLARY according to how XMLTagContent
    1:  * produces a list of name and attribute values and/or braced expressions, a
    1:  * single expression, or a single name.
    1:  *
82024:  * If PN_LIST or PN_NULLARY, getKind() will be PNK_XMLNAME for the case where
82024:  * XMLTagContent: XMLNameExpr.  If getKind() is not PNK_XMLNAME but getArity()
82024:  * is PN_LIST, getKind() will be tagkind.  If PN_UNARY, getKind() will be
82024:  * PNK_LC and we parsed exactly one expression.
    1:  */
80631: ParseNode *
82024: Parser::xmlTagContent(ParseNodeKind tagkind, JSAtom **namep)
    1: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
80631:     ParseNode *pn, *pn2, *list;
40320:     TokenKind tt;
40221: 
40263:     pn = xmlNameExpr();
    1:     if (!pn)
    1:         return NULL;
78294:     *namep = (pn->isArity(PN_NULLARY)) ? pn->pn_atom : NULL;
    1:     list = NULL;
    1: 
40354:     while (tokenStream.matchToken(TOK_XMLSPACE)) {
40354:         tt = tokenStream.getToken();
    1:         if (tt != TOK_XMLNAME && tt != TOK_LC) {
40354:             tokenStream.ungetToken();
40239:             break;
40239:         }
40239: 
40263:         pn2 = xmlNameExpr();
    1:         if (!pn2)
    1:             return NULL;
    1:         if (!list) {
82024:             list = ListNode::create(tagkind, tc);
    1:             if (!list)
    1:                 return NULL;
    1:             list->pn_pos.begin = pn->pn_pos.begin;
27012:             list->initList(pn);
    1:             pn = list;
    1:         }
27012:         pn->append(pn2);
    1:         if (!XML_FOLDABLE(pn2))
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1: 
40354:         tokenStream.matchToken(TOK_XMLSPACE);
    1:         MUST_MATCH_TOKEN(TOK_ASSIGN, JSMSG_NO_ASSIGN_IN_XML_ATTR);
40354:         tokenStream.matchToken(TOK_XMLSPACE);
40354: 
40354:         tt = tokenStream.getToken();
    1:         if (tt == TOK_XMLATTR) {
82024:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_STRING);
82024:             pn2 = atomNode(PNK_XMLATTR, JSOP_STRING);
    1:         } else if (tt == TOK_LC) {
40263:             pn2 = xmlExpr(JS_TRUE);
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1:         } else {
42671:             reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_ATTR_VALUE);
    1:             return NULL;
    1:         }
    1:         if (!pn2)
    1:             return NULL;
    1:         pn->pn_pos.end = pn2->pn_pos.end;
27012:         pn->append(pn2);
    1:     }
    1: 
    1:     return pn;
    1: }
    1: 
    1: #define XML_CHECK_FOR_ERROR_AND_EOF(tt,result)                                              \
    1:     JS_BEGIN_MACRO                                                                          \
    1:         if ((tt) <= TOK_EOF) {                                                              \
    1:             if ((tt) == TOK_EOF) {                                                          \
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_END_OF_XML_SOURCE);           \
    1:             }                                                                               \
    1:             return result;                                                                  \
    1:         }                                                                                   \
    1:     JS_END_MACRO
    1: 
    1: /*
    1:  * Consume XML element tag content, including the TOK_XMLETAGO (</) sequence
    1:  * that opens the end tag for the container.
    1:  */
40239: JSBool
80631: Parser::xmlElementContent(ParseNode *pn)
40221: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
40854:     tokenStream.setXMLTagMode(false);
    1:     for (;;) {
40854:         TokenKind tt = tokenStream.getToken(TSF_XMLTEXTMODE);
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1: 
    1:         JS_ASSERT(tt == TOK_XMLSPACE || tt == TOK_XMLTEXT);
80443:         JSAtom *textAtom = tokenStream.currentToken().atom();
    1:         if (textAtom) {
    1:             /* Non-zero-length XML text scanned. */
82024:             JS_ASSERT(tokenStream.currentToken().t_op == JSOP_STRING);
82024:             ParseNode *pn2 = atomNode(tt == TOK_XMLSPACE ? PNK_XMLSPACE : PNK_XMLTEXT,
82024:                                       JSOP_STRING);
    1:             if (!pn2)
82024:                 return false;
    1:             pn->pn_pos.end = pn2->pn_pos.end;
27012:             pn->append(pn2);
    1:         }
    1: 
40854:         tt = tokenStream.getToken(TSF_OPERAND);
    1:         XML_CHECK_FOR_ERROR_AND_EOF(tt, JS_FALSE);
    1:         if (tt == TOK_XMLETAGO)
    1:             break;
    1: 
80631:         ParseNode *pn2;
    1:         if (tt == TOK_LC) {
40263:             pn2 = xmlExpr(JS_FALSE);
82024:             if (!pn2)
82024:                 return false;
27012:             pn->pn_xflags |= PNX_CANTFOLD;
    1:         } else if (tt == TOK_XMLSTAGO) {
40263:             pn2 = xmlElementOrList(JS_FALSE);
82024:             if (!pn2)
82024:                 return false;
27012:             pn2->pn_xflags &= ~PNX_XMLROOT;
27012:             pn->pn_xflags |= pn2->pn_xflags;
82024:         } else if (tt == TOK_XMLPI) {
82024:             pn2 = NullaryNode::create(PNK_XMLPI, tc);
82024:             if (!pn2)
82024:                 return false;
82024:             const Token &tok = tokenStream.currentToken();
82024:             pn2->setOp(tok.t_op);
82024:             pn2->pn_pitarget = tok.xmlPITarget();
82024:             pn2->pn_pidata = tok.xmlPIData();
    1:         } else {
82024:             JS_ASSERT(tt == TOK_XMLCDATA || tt == TOK_XMLCOMMENT);
82024:             pn2 = atomNode(tt == TOK_XMLCDATA ? PNK_XMLCDATA : PNK_XMLCOMMENT,
82024:                            tokenStream.currentToken().t_op);
    1:             if (!pn2)
82024:                 return false;
82024:         }
    1:         pn->pn_pos.end = pn2->pn_pos.end;
27012:         pn->append(pn2);
    1:     }
40854:     tokenStream.setXMLTagMode(true);
    1: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLETAGO);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Return a PN_LIST node containing an XML or XMLList Initialiser.
    1:  */
80631: ParseNode *
40860: Parser::xmlElementOrList(JSBool allowList)
    1: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
80631:     ParseNode *pn, *pn2, *list;
40320:     TokenKind tt;
    1:     JSAtom *startAtom, *endAtom;
    1: 
40239:     JS_CHECK_RECURSION(context, return NULL);
40239: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_XMLSTAGO);
82024:     pn = ListNode::create(PNK_XMLSTAGO, tc);
    1:     if (!pn)
    1:         return NULL;
    1: 
40854:     tokenStream.setXMLTagMode(true);
40354:     tt = tokenStream.getToken();
    1:     if (tt == TOK_ERROR)
    1:         return NULL;
    1: 
    1:     if (tt == TOK_XMLNAME || tt == TOK_LC) {
    1:         /*
    1:          * XMLElement.  Append the tag and its contents, if any, to pn.
    1:          */
82024:         pn2 = xmlTagContent(PNK_XMLSTAGO, &startAtom);
    1:         if (!pn2)
    1:             return NULL;
40354:         tokenStream.matchToken(TOK_XMLSPACE);
40354: 
40354:         tt = tokenStream.getToken();
    1:         if (tt == TOK_XMLPTAGC) {
    1:             /* Point tag (/>): recycle pn if pn2 is a list of tag contents. */
82024:             if (pn2->isKind(PNK_XMLSTAGO)) {
27012:                 pn->makeEmpty();
80641:                 freeTree(pn);
    1:                 pn = pn2;
    1:             } else {
82024:                 JS_ASSERT(pn2->isKind(PNK_XMLNAME) || pn2->isKind(PNK_LC));
27012:                 pn->initList(pn2);
    1:                 if (!XML_FOLDABLE(pn2))
27012:                     pn->pn_xflags |= PNX_CANTFOLD;
    1:             }
82024:             pn->setKind(PNK_XMLPTAGC);
27012:             pn->pn_xflags |= PNX_XMLROOT;
    1:         } else {
    1:             /* We had better have a tag-close (>) at this point. */
    1:             if (tt != TOK_XMLTAGC) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
40270:             pn2->pn_pos.end = tokenStream.currentToken().pos.end;
    1: 
    1:             /* Make sure pn2 is a TOK_XMLSTAGO list containing tag contents. */
82024:             if (!pn2->isKind(PNK_XMLSTAGO)) {
27012:                 pn->initList(pn2);
    1:                 if (!XML_FOLDABLE(pn2))
27012:                     pn->pn_xflags |= PNX_CANTFOLD;
    1:                 pn2 = pn;
82024:                 pn = ListNode::create(PNK_XMLTAGC, tc);
    1:                 if (!pn)
    1:                     return NULL;
    1:             }
    1: 
    1:             /* Now make pn a nominal-root TOK_XMLELEM list containing pn2. */
82024:             pn->setKind(PNK_XMLELEM);
27012:             pn->pn_pos.begin = pn2->pn_pos.begin;
27012:             pn->initList(pn2);
    1:             if (!XML_FOLDABLE(pn2))
27012:                 pn->pn_xflags |= PNX_CANTFOLD;
27012:             pn->pn_xflags |= PNX_XMLROOT;
    1: 
    1:             /* Get element contents and delimiting end-tag-open sequence. */
40263:             if (!xmlElementContent(pn))
40239:                 return NULL;
40239: 
40354:             tt = tokenStream.getToken();
    1:             XML_CHECK_FOR_ERROR_AND_EOF(tt, NULL);
    1:             if (tt != TOK_XMLNAME && tt != TOK_LC) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Parse end tag; check mismatch at compile-time if we can. */
82024:             pn2 = xmlTagContent(PNK_XMLETAGO, &endAtom);
    1:             if (!pn2)
    1:                 return NULL;
82024:             if (pn2->isKind(PNK_XMLETAGO)) {
    1:                 /* Oops, end tag has attributes! */
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_TAG_SYNTAX);
    1:                 return NULL;
    1:             }
    1:             if (endAtom && startAtom && endAtom != startAtom) {
    1:                 /* End vs. start tag name mismatch: point to the tag name. */
42671:                 reportErrorNumber(pn2, JSREPORT_UC | JSREPORT_ERROR, JSMSG_XML_TAG_NAME_MISMATCH,
59890:                                   startAtom->chars());
    1:                 return NULL;
    1:             }
    1: 
    1:             /* Make a TOK_XMLETAGO list with pn2 as its single child. */
82024:             JS_ASSERT(pn2->isKind(PNK_XMLNAME) || pn2->isKind(PNK_LC));
82024:             list = ListNode::create(PNK_XMLETAGO, tc);
    1:             if (!list)
    1:                 return NULL;
27012:             list->initList(pn2);
27012:             pn->append(list);
    1:             if (!XML_FOLDABLE(pn2)) {
27012:                 list->pn_xflags |= PNX_CANTFOLD;
27012:                 pn->pn_xflags |= PNX_CANTFOLD;
    1:             }
    1: 
40354:             tokenStream.matchToken(TOK_XMLSPACE);
    1:             MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_TAG_SYNTAX);
    1:         }
    1: 
    1:         /* Set pn_op now that pn has been updated to its final value. */
78294:         pn->setOp(JSOP_TOXML);
    1:     } else if (allowList && tt == TOK_XMLTAGC) {
    1:         /* XMLList Initialiser. */
82024:         pn->setKind(PNK_XMLLIST);
78294:         pn->setOp(JSOP_TOXMLLIST);
27012:         pn->makeEmpty();
27012:         pn->pn_xflags |= PNX_XMLROOT;
40263:         if (!xmlElementContent(pn))
    1:             return NULL;
    1: 
    1:         MUST_MATCH_TOKEN(TOK_XMLTAGC, JSMSG_BAD_XML_LIST_SYNTAX);
    1:     } else {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_NAME_SYNTAX);
    1:         return NULL;
    1:     }
40854:     tokenStream.setXMLTagMode(false);
    1: 
40270:     pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
40860: Parser::xmlElementOrListRoot(JSBool allowList)
    1: {
80780:     JS_ASSERT(!tc->inStrictMode());
80780: 
    1:     /*
    1:      * Force XML support to be enabled so that comments and CDATA literals
    1:      * are recognized, instead of <! followed by -- starting an HTML comment
    1:      * to end of line (used in script tags to hide content from old browsers
    1:      * that don't recognize <script>).
    1:      */
61450:     bool hadXML = tokenStream.hasXML();
61450:     tokenStream.setXML(true);
80631:     ParseNode *pn = xmlElementOrList(allowList);
61450:     tokenStream.setXML(hadXML);
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
40860: Parser::parseXMLText(JSObject *chain, bool allowList)
27012: {
    1:     /*
    1:      * Push a compiler frame if we have no frames, or if the top frame is a
    1:      * lightweight function activation, or if its scope chain doesn't match
    1:      * the one passed to us.
    1:      */
80631:     TreeContext xmltc(this);
72579:     if (!xmltc.init(context))
72579:         return NULL;
80780:     JS_ASSERT(!xmltc.inStrictMode());
57829:     xmltc.setScopeChain(chain);
    1: 
    1:     /* Set XML-only mode to turn off special treatment of {expr} in XML. */
40854:     tokenStream.setXMLOnlyMode();
40854:     TokenKind tt = tokenStream.getToken(TSF_OPERAND);
27012: 
80631:     ParseNode *pn;
    1:     if (tt != TOK_XMLSTAGO) {
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_XML_MARKUP);
    1:         pn = NULL;
    1:     } else {
40263:         pn = xmlElementOrListRoot(allowList);
40239:     }
40854:     tokenStream.setXMLOnlyMode(false);
40854: 
    1:     return pn;
    1: }
    1: 
    1: #endif /* JS_HAS_XMLSUPPORT */
    1: 
27012: #if JS_HAS_BLOCK_SCOPE
27012: /*
27012:  * Check whether blockid is an active scoping statement in tc. This code is
40239:  * necessary to qualify tc->decls.lookup() hits in primaryExpr's TOK_NAME case
27012:  * (below) where the hits come from Scheme-ish let bindings in for loop heads
27012:  * and let blocks and expressions (not let declarations).
27012:  *
27012:  * Unlike let declarations ("let as the new var"), which is a kind of letrec
27012:  * due to hoisting, let in a for loop head, let block, or let expression acts
27012:  * like Scheme's let: initializers are evaluated without the new let bindings
27012:  * being in scope.
27012:  *
27012:  * Name binding analysis is eager with fixups, rather than multi-pass, and let
72579:  * bindings push on the front of the tc->decls AtomDecls (either the singular
72579:  * list or on a hash chain -- see JSAtomMultiList::add*) in order to shadow
72579:  * outer scope bindings of the same name.
27012:  *
27012:  * This simplifies binding lookup code at the price of a linear search here,
27012:  * but only if code uses let (var predominates), and even then this function's
27012:  * loop iterates more than once only in crazy cases.
27012:  */
27371: static inline bool
80631: BlockIdInScope(uintN blockid, TreeContext *tc)
27371: {
27371:     if (blockid > tc->blockid())
27371:         return false;
80631:     for (StmtInfo *stmt = tc->topScopeStmt; stmt; stmt = stmt->downScope) {
27012:         if (stmt->blockid == blockid)
27012:             return true;
27012:     }
27012:     return false;
27012: }
27012: #endif
27012: 
82024: static ParseNode *
82024: PrimaryExprNode(ParseNodeKind kind, JSOp op, TreeContext *tc)
82024: {
82024:     ParseNode *pn = NullaryNode::create(kind, tc);
82024:     if (!pn)
82024:         return NULL;
82024:     pn->setOp(op);
82024:     return pn;
82024: }
82024: 
80631: ParseNode *
40860: Parser::primaryExpr(TokenKind tt, JSBool afterDot)
    1: {
82024:     JS_ASSERT(tokenStream.isCurrentTokenType(tt));
82024: 
80631:     ParseNode *pn, *pn2, *pn3;
    1:     JSOp op;
11139: 
40239:     JS_CHECK_RECURSION(context, return NULL);
11139: 
    1:     switch (tt) {
    1:       case TOK_FUNCTION:
    1: #if JS_HAS_XML_SUPPORT
80780:         if (!tc->inStrictMode() && tokenStream.matchToken(TOK_DBLCOLON, TSF_KEYWORD_IS_NAME)) {
82024:             pn2 = NullaryNode::create(PNK_FUNCTION, tc);
    1:             if (!pn2)
    1:                 return NULL;
40263:             pn = qualifiedSuffix(pn2);
    1:             if (!pn)
    1:                 return NULL;
    1:             break;
    1:         }
    1: #endif
40263:         pn = functionExpr();
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_LB:
    1:       {
    1:         JSBool matched;
    1:         jsuint index;
    1: 
82024:         pn = ListNode::create(PNK_RB, tc);
    1:         if (!pn)
    1:             return NULL;
78294:         pn->setOp(JSOP_NEWINIT);
27012:         pn->makeEmpty();
27012: 
27012: #if JS_HAS_GENERATORS
27012:         pn->pn_blockid = tc->blockidGen;
27012: #endif
    1: 
40854:         matched = tokenStream.matchToken(TOK_RB, TSF_OPERAND);
    1:         if (!matched) {
    1:             for (index = 0; ; index++) {
73495:                 if (index == StackSpace::ARGS_LENGTH_MAX) {
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_ARRAY_INIT_TOO_BIG);
    1:                     return NULL;
    1:                 }
    1: 
40854:                 tt = tokenStream.peekToken(TSF_OPERAND);
    1:                 if (tt == TOK_RB) {
27012:                     pn->pn_xflags |= PNX_ENDCOMMA;
    1:                     break;
    1:                 }
    1: 
    1:                 if (tt == TOK_COMMA) {
    1:                     /* So CURRENT_TOKEN gets TOK_COMMA and not TOK_LB. */
40354:                     tokenStream.matchToken(TOK_COMMA);
82024:                     pn2 = NullaryNode::create(PNK_COMMA, tc);
59962:                     pn->pn_xflags |= PNX_HOLEY | PNX_NONCONST;
    1:                 } else {
40263:                     pn2 = assignExpr();
59962:                     if (pn2 && !pn2->isConstant())
59962:                         pn->pn_xflags |= PNX_NONCONST;
    1:                 }
    1:                 if (!pn2)
    1:                     return NULL;
27012:                 pn->append(pn2);
    1: 
    1:                 if (tt != TOK_COMMA) {
    1:                     /* If we didn't already match TOK_COMMA in above case. */
40354:                     if (!tokenStream.matchToken(TOK_COMMA))
    1:                         break;
    1:                 }
    1:             }
    1: 
    1: #if JS_HAS_GENERATORS
    1:             /*
    1:              * At this point, (index == 0 && pn->pn_count != 0) implies one
26959:              * element initialiser was parsed.
    1:              *
    1:              * An array comprehension of the form:
    1:              *
    1:              *   [i * j for (i in o) for (j in p) if (i != j)]
    1:              *
    1:              * translates to roughly the following let expression:
    1:              *
    1:              *   let (array = new Array, i, j) {
    1:              *     for (i in o) let {
    1:              *       for (j in p)
    1:              *         if (i != j)
    1:              *           array.push(i * j)
    1:              *     }
    1:              *     array
    1:              *   }
    1:              *
    1:              * where array is a nameless block-local variable. The "roughly"
    1:              * means that an implementation may optimize away the array.push.
    1:              * An array comprehension opens exactly one block scope, no matter
    1:              * how many for heads it contains.
    1:              *
    1:              * Each let () {...} or for (let ...) ... compiles to:
    1:              *
    1:              *   JSOP_ENTERBLOCK <o> ... JSOP_LEAVEBLOCK <n>
    1:              *
    1:              * where <o> is a literal object representing the block scope,
    1:              * with <n> properties, naming each var declared in the block.
    1:              *
    1:              * Each var declaration in a let-block binds a name in <o> at
    1:              * compile time, and allocates a slot on the operand stack at
74052:              * runtime via JSOP_ENTERBLOCK. A block-local var is accessed by
74052:              * the JSOP_GETLOCAL and JSOP_SETLOCAL ops. These ops have an
74052:              * immediate operand, the local slot's stack index from fp->spbase.
    1:              *
    1:              * The array comprehension iteration step, array.push(i * j) in
    1:              * the example above, is done by <i * j>; JSOP_ARRAYCOMP <array>,
    1:              * where <array> is the index of array's stack slot.
    1:              */
40354:             if (index == 0 && pn->pn_count != 0 && tokenStream.matchToken(TOK_FOR)) {
80631:                 ParseNode *pnexp, *pntop;
    1: 
    1:                 /* Relabel pn as an array comprehension node. */
82024:                 pn->setKind(PNK_ARRAYCOMP);
    1: 
    1:                 /*
    1:                  * Remove the comprehension expression from pn's linked list
    1:                  * and save it via pnexp.  We'll re-install it underneath the
    1:                  * ARRAYPUSH node after we parse the rest of the comprehension.
    1:                  */
27012:                 pnexp = pn->last();
51110:                 JS_ASSERT(pn->pn_count == 1);
51110:                 pn->pn_count = 0;
51110:                 pn->pn_tail = &pn->pn_head;
    1:                 *pn->pn_tail = NULL;
    1: 
72073:                 pntop = comprehensionTail(pnexp, pn->pn_blockid, false,
82024:                                           PNK_ARRAYPUSH, JSOP_ARRAYPUSH);
    1:                 if (!pntop)
    1:                     return NULL;
27012:                 pn->append(pntop);
    1:             }
    1: #endif /* JS_HAS_GENERATORS */
    1: 
    1:             MUST_MATCH_TOKEN(TOK_RB, JSMSG_BRACKET_AFTER_LIST);
    1:         }
40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         return pn;
    1:       }
    1: 
    1:       case TOK_LC:
    1:       {
80631:         ParseNode *pnval;
    1: 
35310:         /*
60213:          * A map from property names we've seen thus far to a mask of property
60213:          * assignment types, stored and retrieved with ALE_SET_INDEX/ALE_INDEX.
35310:          */
72579:         AtomIndexMap seen(context);
72579: 
60213:         enum AssignmentType {
60213:             GET     = 0x1,
60213:             SET     = 0x2,
60213:             VALUE   = 0x4 | GET | SET
60213:         };
35310: 
82024:         pn = ListNode::create(PNK_RC, tc);
    1:         if (!pn)
    1:             return NULL;
78294:         pn->setOp(JSOP_NEWINIT);
27012:         pn->makeEmpty();
    1: 
    1:         for (;;) {
35310:             JSAtom *atom;
40854:             tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
    1:             switch (tt) {
    1:               case TOK_NUMBER:
82024:                 pn3 = NullaryNode::create(PNK_NUMBER, tc);
33749:                 if (!pn3)
33749:                     return NULL;
80817:                 pn3->pn_dval = tokenStream.currentToken().number();
48470:                 if (!js_ValueToAtom(context, DoubleValue(pn3->pn_dval), &atom))
40794:                     return NULL;
    1:                 break;
    1:               case TOK_NAME:
    1:                 {
80443:                     atom = tokenStream.currentToken().name();
82024:                     if (atom == context->runtime->atomState.getAtom) {
 1478:                         op = JSOP_GETTER;
82024:                     } else if (atom == context->runtime->atomState.setAtom) {
 1478:                         op = JSOP_SETTER;
82024:                     } else {
82024:                         pn3 = NullaryNode::create(PNK_NAME, tc);
82024:                         if (!pn3)
82024:                             return NULL;
82024:                         pn3->pn_atom = atom;
82024:                         break;
82024:                     }
 1478: 
40854:                     tt = tokenStream.getToken(TSF_KEYWORD_IS_NAME);
82024:                     if (tt == TOK_NAME) {
82024:                         atom = tokenStream.currentToken().name();
82024:                         pn3 = NameNode::create(PNK_NAME, atom, tc);
    1:                         if (!pn3)
    1:                             return NULL;
82024:                     } else if (tt == TOK_STRING) {
82024:                         atom = tokenStream.currentToken().atom();
82024:                         pn3 = NameNode::create(PNK_STRING, atom, tc);
82024:                         if (!pn3)
82024:                             return NULL;
40794:                     } else if (tt == TOK_NUMBER) {
82024:                         pn3 = NullaryNode::create(PNK_NUMBER, tc);
40794:                         if (!pn3)
40794:                             return NULL;
80817:                         pn3->pn_dval = tokenStream.currentToken().number();
48470:                         if (!js_ValueToAtom(context, DoubleValue(pn3->pn_dval), &atom))
40794:                             return NULL;
40794:                     } else {
40794:                         tokenStream.ungetToken();
82024:                         pn3 = NullaryNode::create(PNK_NAME, tc);
82024:                         if (!pn3)
82024:                             return NULL;
82024:                         pn3->pn_atom = atom;
82024:                         break;
40794:                     }
    1: 
59962:                     pn->pn_xflags |= PNX_NONCONST;
59962: 
51087:                     /* NB: Getter function in { get x(){} } is unnamed. */
72581:                     pn2 = functionDef(NULL, op == JSOP_GETTER ? Getter : Setter, Expression);
82024:                     pn2 = ParseNode::newBinaryOrAppend(PNK_COLON, op, pn3, pn2, tc);
    1:                     goto skip;
    1:                 }
80443:               case TOK_STRING:
80443:                 atom = tokenStream.currentToken().atom();
82024:                 pn3 = NullaryNode::create(PNK_STRING, tc);
33749:                 if (!pn3)
33749:                     return NULL;
35310:                 pn3->pn_atom = atom;
    1:                 break;
    1:               case TOK_RC:
    1:                 goto end_obj_init;
    1:               default:
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_PROP_ID);
    1:                 return NULL;
    1:             }
    1: 
40855:             op = JSOP_INITPROP;
40354:             tt = tokenStream.getToken();
37685:             if (tt == TOK_COLON) {
40263:                 pnval = assignExpr();
77448: 
77448:                 /*
77448:                  * Treat initializers which mutate __proto__ as non-constant,
77448:                  * so that we can later assume singleton objects delegate to
77448:                  * the default Object.prototype.
77448:                  */
77448:                 if ((pnval && !pnval->isConstant()) ||
77448:                     atom == context->runtime->atomState.protoAtom) {
59962:                     pn->pn_xflags |= PNX_NONCONST;
77448:                 }
37685:             } else {
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 if (tt != TOK_COMMA && tt != TOK_RC) {
11039: #endif
42671:                     reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_COLON_AFTER_ID);
    1:                     return NULL;
11039: #if JS_HAS_DESTRUCTURING_SHORTHAND
11039:                 }
11039: 
11039:                 /*
11039:                  * Support, e.g., |var {x, y} = o| as destructuring shorthand
11039:                  * for |var {x: x, y: y} = o|, per proposed JS2/ES4 for JS1.8.
11039:                  */
40354:                 tokenStream.ungetToken();
81279:                 if (!tokenStream.checkForKeyword(atom->charsZ(), atom->length(), NULL, NULL))
81279:                     return NULL;
59962:                 pn->pn_xflags |= PNX_DESTRUCT | PNX_NONCONST;
11039:                 pnval = pn3;
82024:                 if (pnval->isKind(PNK_NAME)) {
78294:                     pnval->setArity(PN_NAME);
40232:                     ((NameNode *)pnval)->initCommon(tc);
11039:                 }
11039: #endif
11039:             }
11039: 
82024:             pn2 = ParseNode::newBinaryOrAppend(PNK_COLON, op, pn3, pnval, tc);
    1:           skip:
    1:             if (!pn2)
    1:                 return NULL;
27012:             pn->append(pn2);
    1: 
35310:             /*
60213:              * Check for duplicate property names.  Duplicate data properties
60213:              * only conflict in strict mode.  Duplicate getter or duplicate
60213:              * setter halves always conflict.  A data property conflicts with
60213:              * any part of an accessor property.
60213:              */
60213:             AssignmentType assignType;
37685:             if (op == JSOP_INITPROP) {
60213:                 assignType = VALUE;
37685:             } else if (op == JSOP_GETTER) {
60213:                 assignType = GET;
37685:             } else if (op == JSOP_SETTER) {
60213:                 assignType = SET;
37685:             } else {
35310:                 JS_NOT_REACHED("bad opcode in object initializer");
60213:                 assignType = VALUE; /* try to error early */
60213:             }
60213: 
72579:             AtomIndexAddPtr p = seen.lookupForAdd(atom);
72579:             if (p) {
72579:                 jsatomid index = p.value();
72579:                 AssignmentType oldAssignType = AssignmentType(index);
60213:                 if ((oldAssignType & assignType) &&
60213:                     (oldAssignType != VALUE || assignType != VALUE || tc->needStrictChecks()))
60213:                 {
57812:                     JSAutoByteString name;
60213:                     if (!js_AtomToPrintableString(context, atom, &name))
60213:                         return NULL;
60213: 
60213:                     uintN flags = (oldAssignType == VALUE &&
60213:                                    assignType == VALUE &&
60213:                                    !tc->inStrictMode())
60213:                                   ? JSREPORT_WARNING
60213:                                   : JSREPORT_ERROR;
60213:                     if (!ReportCompileErrorNumber(context, &tokenStream, NULL, flags,
60213:                                                   JSMSG_DUPLICATE_PROPERTY, name.ptr()))
60213:                     {
60213:                         return NULL;
60213:                     }
60213:                 }
72579:                 p.value() = assignType | oldAssignType;
35310:             } else {
72579:                 if (!seen.add(p, atom, assignType))
72579:                     return NULL;
35310:             }
35310: 
40354:             tt = tokenStream.getToken();
    1:             if (tt == TOK_RC)
    1:                 goto end_obj_init;
    1:             if (tt != TOK_COMMA) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_CURLY_AFTER_LIST);
    1:                 return NULL;
    1:             }
    1:         }
 1967: 
    1:       end_obj_init:
40270:         pn->pn_pos.end = tokenStream.currentToken().pos.end;
    1:         return pn;
    1:       }
    1: 
 1967: #if JS_HAS_BLOCK_SCOPE
 1967:       case TOK_LET:
40263:         pn = letBlock(JS_FALSE);
 1967:         if (!pn)
 1967:             return NULL;
 1967:         break;
 1967: #endif
 1967: 
    1: #if JS_HAS_SHARP_VARS
    1:       case TOK_DEFSHARP:
82024:         pn = UnaryNode::create(PNK_DEFSHARP, tc);
26959:         if (!pn)
26959:             return NULL;
80817:         pn->pn_num = tokenStream.currentToken().sharpNumber();
40854:         tt = tokenStream.getToken(TSF_OPERAND);
40263:         pn->pn_kid = primaryExpr(tt, JS_FALSE);
26959:         if (!pn->pn_kid)
26959:             return NULL;
82024:         if (pn->pn_kid->isKind(PNK_USESHARP) ||
82024:             pn->pn_kid->isKind(PNK_DEFSHARP) ||
82024:             pn->pn_kid->isKind(PNK_STRING) ||
82024:             pn->pn_kid->isKind(PNK_NUMBER) ||
82024:             pn->pn_kid->isKind(PNK_TRUE) ||
82024:             pn->pn_kid->isKind(PNK_FALSE) ||
82024:             pn->pn_kid->isKind(PNK_NULL) ||
82024:             pn->pn_kid->isKind(PNK_THIS))
82022:         {
42719:             reportErrorNumber(pn->pn_kid, JSREPORT_ERROR, JSMSG_BAD_SHARP_VAR_DEF);
42711:             return NULL;
42711:         }
32729:         if (!tc->ensureSharpSlots())
32729:             return NULL;
26959:         break;
    1: 
    1:       case TOK_USESHARP:
    1:         /* Check for forward/dangling references at runtime, to allow eval. */
82024:         pn = NullaryNode::create(PNK_USESHARP, tc);
    1:         if (!pn)
    1:             return NULL;
32729:         if (!tc->ensureSharpSlots())
32729:             return NULL;
80817:         pn->pn_num = tokenStream.currentToken().sharpNumber();
    1:         break;
    1: #endif /* JS_HAS_SHARP_VARS */
    1: 
    1:       case TOK_LP:
 1577:       {
 1577:         JSBool genexp;
 1577: 
61058:         pn = parenExpr(&genexp);
    1:         if (!pn)
    1:             return NULL;
78294:         pn->setInParens(true);
31479:         if (!genexp)
    1:             MUST_MATCH_TOKEN(TOK_RP, JSMSG_PAREN_IN_PAREN);
    1:         break;
 1577:       }
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_STAR:
40263:         pn = qualifiedIdentifier();
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_AT:
40263:         pn = attributeIdentifier();
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: 
    1:       case TOK_XMLSTAGO:
40263:         pn = xmlElementOrListRoot(JS_TRUE);
    1:         if (!pn)
    1:             return NULL;
    1:         break;
    1: #endif /* JS_HAS_XML_SUPPORT */
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1:       case TOK_XMLCDATA:
82024:         JS_ASSERT(!tc->inStrictMode());
82024:         pn = atomNode(PNK_XMLCDATA, JSOP_XMLCDATA);
82024:         if (!pn)
82024:             return NULL;
82024:         break;
82024: 
    1:       case TOK_XMLCOMMENT:
80780:         JS_ASSERT(!tc->inStrictMode());
82024:         pn = atomNode(PNK_XMLCOMMENT, JSOP_XMLCOMMENT);
82024:         if (!pn)
82024:             return NULL;
82024:         break;
    1: #endif
80780:       case TOK_STRING:
82024:         pn = atomNode(PNK_STRING, JSOP_STRING);
    1:         if (!pn)
    1:             return NULL;
80443:         break;
80443: 
80291: #if JS_HAS_XML_SUPPORT
80443:       case TOK_XMLPI:
80780:         JS_ASSERT(!tc->inStrictMode());
82024:         pn = NullaryNode::create(PNK_XMLPI, tc);
80443:         if (!pn)
80443:             return NULL;
80443:         pn->pn_pitarget = tokenStream.currentToken().xmlPITarget();
80443:         pn->pn_pidata = tokenStream.currentToken().xmlPIData();
80443:         break;
80291: #endif
80286: 
27012:       case TOK_NAME:
82024:         pn = NameNode::create(PNK_NAME, tokenStream.currentToken().name(), tc);
27012:         if (!pn)
27012:             return NULL;
40270:         JS_ASSERT(tokenStream.currentToken().t_op == JSOP_NAME);
78294:         pn->setOp(JSOP_NAME);
27012: 
27012:         if ((tc->flags & (TCF_IN_FUNCTION | TCF_FUN_PARAM_ARGUMENTS)) == TCF_IN_FUNCTION &&
40239:             pn->pn_atom == context->runtime->atomState.argumentsAtom) {
27012:             /*
27012:              * Flag arguments usage so we can avoid unsafe optimizations such
27012:              * as formal parameter assignment analysis (because of the hated
27012:              * feature whereby arguments alias formals). We do this even for
27012:              * a reference of the form foo.arguments, which ancient code may
27012:              * still use instead of arguments (more hate).
27012:              */
72073:             tc->noteArgumentsUse(pn);
27012: 
27012:             /*
27012:              * Bind early to JSOP_ARGUMENTS to relieve later code from having
27012:              * to do this work (new rule for the emitter to count on).
27012:              */
72579:             if (!afterDot && !(tc->flags & TCF_DECL_DESTRUCTURING)
72579:                 && !tc->inStatement(STMT_WITH)) {
78294:                 pn->setOp(JSOP_ARGUMENTS);
27012:                 pn->pn_dflags |= PND_BOUND;
27012:             }
27595:         } else if ((!afterDot
27595: #if JS_HAS_XML_SUPPORT
80780:                     || (!tc->inStrictMode() && tokenStream.peekToken() == TOK_DBLCOLON)
27595: #endif
33753:                    ) && !(tc->flags & TCF_DECL_DESTRUCTURING)) {
72073:             /* In case this is a generator expression outside of any function. */
72073:             if (!tc->inFunction() &&
72073:                 pn->pn_atom == context->runtime->atomState.argumentsAtom) {
72073:                 tc->countArgumentsUse(pn);
72073:             }
72073: 
80632:             StmtInfo *stmt = LexicalLookup(tc, pn->pn_atom, NULL);
54755: 
72579:             MultiDeclRange mdl = tc->decls.lookupMulti(pn->pn_atom);
80631:             Definition *dn;
27012: 
72579:             if (!mdl.empty()) {
72579:                 dn = mdl.front();
27012: #if JS_HAS_BLOCK_SCOPE
28967:                 /*
28967:                  * Skip out-of-scope let bindings along an ALE list or hash
28967:                  * chain. These can happen due to |let (x = x) x| block and
28967:                  * expression bindings, where the x on the right of = comes
28967:                  * from an outer scope. See bug 496532.
28967:                  */
28967:                 while (dn->isLet() && !BlockIdInScope(dn->pn_blockid, tc)) {
72579:                     mdl.popFront();
72579:                     if (mdl.empty())
72579:                         break;
72579:                     dn = mdl.front();
28967:                 }
27012: #endif
27012:             }
27012: 
72579:             if (!mdl.empty()) {
72579:                 dn = mdl.front();
27371:             } else {
72579:                 AtomDefnAddPtr p = tc->lexdeps->lookupForAdd(pn->pn_atom);
72579:                 if (p) {
72579:                     dn = p.value();
27371:                 } else {
27371:                     /*
27371:                      * No definition before this use in any lexical scope.
72579:                      * Create a placeholder definition node to either:
72579:                      * - Be adopted when we parse the real defining
72579:                      *   declaration, or
72579:                      * - Be left as a free variable definition if we never
72579:                      *   see the real definition.
72579:                      */
73941:                     dn = MakePlaceholder(pn, tc);
73941:                     if (!dn || !tc->lexdeps->add(p, dn->pn_atom, dn))
72579:                         return NULL;
27012: 
27012:                     /*
27371:                      * In case this is a forward reference to a function,
27371:                      * we pessimistically set PND_FUNARG if the next token
27371:                      * is not a left parenthesis.
27371:                      *
27371:                      * If the definition eventually parsed into dn is not a
27371:                      * function, this flag won't hurt, and if we do parse a
27371:                      * function with pn's name, then the PND_FUNARG flag is
40239:                      * necessary for safe context->display-based optimiza-
40239:                      * tion of the closure's static link.
27012:                      */
40354:                     if (tokenStream.peekToken() != TOK_LP)
27012:                         dn->pn_dflags |= PND_FUNARG;
27012:                 }
27012:             }
27012: 
78294:             JS_ASSERT(dn->isDefn());
27012:             LinkUseToDef(pn, dn, tc);
27012: 
27012:             /* Here we handle the backward function reference case. */
40354:             if (tokenStream.peekToken() != TOK_LP)
27012:                 dn->pn_dflags |= PND_FUNARG;
27012: 
27012:             pn->pn_dflags |= (dn->pn_dflags & PND_FUNARG);
64237:             if (stmt && stmt->type == STMT_WITH)
54755:                 pn->pn_dflags |= PND_DEOPTIMIZED;
27371:         }
27371: 
    1: #if JS_HAS_XML_SUPPORT
80780:         if (!tc->inStrictMode() && tokenStream.matchToken(TOK_DBLCOLON)) {
    1:             if (afterDot) {
    1:                 /*
40239:                  * Here primaryExpr is called after . or .. followed by a name
27012:                  * followed by ::. This is the only case where a keyword after
27012:                  * . or .. is not treated as a property name.
    1:                  */
62048:                 const KeywordInfo *ki = FindKeyword(pn->pn_atom->charsZ(), pn->pn_atom->length());
62048:                 if (ki) {
62048:                     if (ki->tokentype != TOK_FUNCTION) {
62048:                         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_KEYWORD_NOT_NS);
62048:                         return NULL;
62048:                     }
62048: 
78294:                     pn->setArity(PN_NULLARY);
82024:                     pn->setKind(PNK_FUNCTION);
    1:                 }
    1:             }
40263:             pn = qualifiedSuffix(pn);
    1:             if (!pn)
    1:                 return NULL;
    1:         }
    1: #endif
    1:         break;
    1: 
 6561:       case TOK_REGEXP:
 6561:       {
82024:         pn = NullaryNode::create(PNK_REGEXP, tc);
 6561:         if (!pn)
 6561:             return NULL;
 6561: 
79981:         const jschar *chars = tokenStream.getTokenbuf().begin();
79981:         size_t length = tokenStream.getTokenbuf().length();
80816:         RegExpFlag flags = tokenStream.currentToken().regExpFlags();
79981:         RegExpStatics *res = context->regExpStatics();
79981: 
79981:         RegExpObject *reobj;
79981:         if (context->hasfp())
79981:             reobj = RegExpObject::create(context, res, chars, length, flags, &tokenStream);
79981:         else
79981:             reobj = RegExpObject::createNoStatics(context, chars, length, flags, &tokenStream);
79981: 
79981:         if (!reobj)
79981:             return NULL;
79981: 
41884:         if (!tc->compileAndGo()) {
79981:             reobj->clearParent();
79981:             reobj->clearType();
79981:         }
79981: 
79981:         pn->pn_objbox = tc->parser->newObjectBox(reobj);
27012:         if (!pn->pn_objbox)
 6561:             return NULL;
 6561: 
78294:         pn->setOp(JSOP_REGEXP);
 6561:         break;
 6561:       }
 6561: 
    1:       case TOK_NUMBER:
82024:         pn = NullaryNode::create(PNK_NUMBER, tc);
    1:         if (!pn)
    1:             return NULL;
78294:         pn->setOp(JSOP_DOUBLE);
80817:         pn->pn_dval = tokenStream.currentToken().number();
    1:         break;
    1: 
82022:       case TOK_TRUE:
82024:         return PrimaryExprNode(PNK_TRUE, JSOP_TRUE, tc);
82022:       case TOK_FALSE:
82024:         return PrimaryExprNode(PNK_FALSE, JSOP_FALSE, tc);
82022:       case TOK_THIS:
82024:         return PrimaryExprNode(PNK_THIS, JSOP_THIS, tc);
82022:       case TOK_NULL:
82024:         return PrimaryExprNode(PNK_NULL, JSOP_NULL, tc);
    1: 
    1:       case TOK_ERROR:
    1:         /* The scanner or one of its subroutines reported the error. */
    1:         return NULL;
    1: 
    1:       default:
42671:         reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     return pn;
    1: }
    1: 
80631: ParseNode *
61058: Parser::parenExpr(JSBool *genexp)
40221: {
40320:     TokenPtr begin;
80631:     ParseNode *pn;
 1577: 
40270:     JS_ASSERT(tokenStream.currentToken().type == TOK_LP);
40270:     begin = tokenStream.currentToken().pos.begin;
 1577: 
 1577:     if (genexp)
 1577:         *genexp = JS_FALSE;
72073: 
72073:     GenexpGuard guard(tc);
72073: 
40263:     pn = bracketedExpr();
 1577:     if (!pn)
 1577:         return NULL;
72073:     guard.endBody();
 1577: 
 1577: #if JS_HAS_GENERATOR_EXPRS
40354:     if (tokenStream.matchToken(TOK_FOR)) {
72073:         if (!guard.checkValidBody(pn))
72073:             return NULL;
82024:         JS_ASSERT(!pn->isKind(PNK_YIELD));
82024:         if (pn->isKind(PNK_COMMA) && !pn->isInParens()) {
42671:             reportErrorNumber(pn->last(), JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX,
42671:                               js_generator_str);
 1577:             return NULL;
 1577:         }
61058:         pn = generatorExpr(pn);
27012:         if (!pn)
27012:             return NULL;
26970:         pn->pn_pos.begin = begin;
 1577:         if (genexp) {
40354:             if (tokenStream.getToken() != TOK_RP) {
42671:                 reportErrorNumber(NULL, JSREPORT_ERROR, JSMSG_BAD_GENERATOR_SYNTAX,
42671:                                   js_generator_str);
40221:                 return NULL;
40221:             }
40270:             pn->pn_pos.end = tokenStream.currentToken().pos.end;
 1577:             *genexp = JS_TRUE;
 1577:         }
73053:     } else
 1577: #endif /* JS_HAS_GENERATOR_EXPRS */
 1577: 
78006:     if (!guard.maybeNoteGenerator(pn))
72565:         return NULL;
72073: 
 1577:     return pn;
 1577: }
