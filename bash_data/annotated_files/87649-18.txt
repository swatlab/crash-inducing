37488: /*
37488: # ***** BEGIN LICENSE BLOCK *****
37488: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
37488: #
37488: # The contents of this file are subject to the Mozilla Public License Version
37488: # 1.1 (the "License"); you may not use this file except in compliance with
37488: # the License. You may obtain a copy of the License at
37488: # http://www.mozilla.org/MPL/
37488: #
37488: # Software distributed under the License is distributed on an "AS IS" basis,
37488: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
37488: # for the specific language governing rights and limitations under the
37488: # License.
37488: #
37488: # The Original Code is the Extension Manager.
37488: #
37488: # The Initial Developer of the Original Code is mozilla.org
37488: # Portions created by the Initial Developer are Copyright (C) 2008
37488: # the Initial Developer. All Rights Reserved.
37488: #
37488: # Contributor(s):
37488: #   Dave Townsend <dtownsend@oxymoronical.com>
51519: #   Ben Parr <bparr@bparr.com>
83133: #   Blair McBride <bmcbride@mozilla.com>
37488: #
37488: # Alternatively, the contents of this file may be used under the terms of
37488: # either the GNU General Public License Version 2 or later (the "GPL"), or
37488: # the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
37488: # in which case the provisions of the GPL or the LGPL are applicable instead
37488: # of those above. If you wish to allow use of your version of this file only
37488: # under the terms of either the GPL or the LGPL, and not to allow others to
37488: # use your version of this file under the terms of the MPL, indicate your
37488: # decision by deleting the provisions above and replace them with the notice
37488: # and other provisions required by the GPL or the LGPL. If you do not delete
37488: # the provisions above, a recipient may use your version of this file under
37488: # the terms of any one of the MPL, the GPL or the LGPL.
37488: #
37488: # ***** END LICENSE BLOCK *****
37488: */
37488: 
74689: "use strict";
74689: 
37488: const Cc = Components.classes;
37488: const Ci = Components.interfaces;
47951: const Cu = Components.utils;
37488: 
51520: Components.utils.import("resource://gre/modules/FileUtils.jsm");
51519: Components.utils.import("resource://gre/modules/NetUtil.jsm");
47951: Components.utils.import("resource://gre/modules/Services.jsm");
42076: Components.utils.import("resource://gre/modules/AddonManager.jsm");
82140: Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
37488: 
43746: var EXPORTED_SYMBOLS = [ "AddonRepository" ];
43746: 
51520: const PREF_GETADDONS_CACHE_ENABLED       = "extensions.getAddons.cache.enabled";
62630: const PREF_GETADDONS_CACHE_TYPES         = "extensions.getAddons.cache.types";
62630: const PREF_GETADDONS_CACHE_ID_ENABLED    = "extensions.%ID%.getAddons.cache.enabled"
37488: const PREF_GETADDONS_BROWSEADDONS        = "extensions.getAddons.browseAddons";
51519: const PREF_GETADDONS_BYIDS               = "extensions.getAddons.get.url";
37488: const PREF_GETADDONS_BROWSERECOMMENDED   = "extensions.getAddons.recommended.browseURL";
37488: const PREF_GETADDONS_GETRECOMMENDED      = "extensions.getAddons.recommended.url";
37488: const PREF_GETADDONS_BROWSESEARCHRESULTS = "extensions.getAddons.search.browseURL";
37488: const PREF_GETADDONS_GETSEARCHRESULTS    = "extensions.getAddons.search.url";
37488: 
80774: const PREF_CHECK_COMPATIBILITY_BASE = "extensions.checkCompatibility";
82086: 
82086: const BRANCH_REGEXP                   = /^([^\.]+\.[0-9]+[a-z]*).*/gi;
82086: 
82140: XPCOMUtils.defineLazyGetter(this, "PREF_CHECK_COMPATIBILITY", function () {
80774: #ifdef MOZ_COMPATIBILITY_NIGHTLY
82140:   return PREF_CHECK_COMPATIBILITY_BASE + ".nightly";
80774: #else
82140:   return PREF_CHECK_COMPATIBILITY_BASE + "." +
80774:          Services.appinfo.version.replace(BRANCH_REGEXP, "$1");
80774: #endif
82140: });
80774: 
83133: const PREF_EM_STRICT_COMPATIBILITY       = "extensions.strictCompatibility";
83133: // Note: This has to be kept in sync with the same constant in AddonManager.jsm
83133: const STRICT_COMPATIBILITY_DEFAULT       = true;
83133: 
37488: const XMLURI_PARSE_ERROR  = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
37488: 
51519: const API_VERSION = "1.5";
79913: const DEFAULT_CACHE_TYPES = "extension,theme,locale,dictionary";
51519: 
51520: const KEY_PROFILEDIR = "ProfD";
51520: const FILE_DATABASE  = "addons.sqlite";
83133: const DB_SCHEMA      = 3;
83133: 
83133: const TOOLKIT_ID     = "toolkit@mozilla.org";
51520: 
51520: ["LOG", "WARN", "ERROR"].forEach(function(aName) {
51520:   this.__defineGetter__(aName, function() {
51520:     Components.utils.import("resource://gre/modules/AddonLogging.jsm");
51520: 
51520:     LogManager.getLogger("addons.repository", this);
51520:     return this[aName];
51520:   });
51520: }, this);
51520: 
51520: 
51520: // Add-on properties parsed out of AMO results
51520: // Note: the 'install' property is added for results from
51520: // retrieveRecommendedAddons and searchAddons
51520: const PROP_SINGLE = ["id", "type", "name", "version", "creator", "description",
51520:                      "fullDescription", "developerComments", "eula", "iconURL",
51520:                      "homepageURL", "supportURL", "contributionURL",
51520:                      "contributionAmount", "averageRating", "reviewCount",
51520:                      "reviewURL", "totalDownloads", "weeklyDownloads",
51520:                      "dailyUsers", "sourceURI", "repositoryStatus", "size",
51520:                      "updateDate"];
51520: const PROP_MULTI = ["developers", "screenshots"]
51520: 
51519: // A map between XML keys to AddonSearchResult keys for string values
51519: // that require no extra parsing from XML
51519: const STRING_KEY_MAP = {
51519:   name:               "name",
51519:   version:            "version",
53959:   icon:               "iconURL",
53959:   homepage:           "homepageURL",
53959:   support:            "supportURL"
53959: };
53959: 
53959: // A map between XML keys to AddonSearchResult keys for string values
53959: // that require parsing from HTML
53959: const HTML_KEY_MAP = {
53747:   summary:            "description",
53747:   description:        "fullDescription",
53747:   developer_comments: "developerComments",
53959:   eula:               "eula"
53708: };
53708: 
51519: // A map between XML keys to AddonSearchResult keys for integer values
51519: // that require no extra parsing from XML
51519: const INTEGER_KEY_MAP = {
51519:   total_downloads:  "totalDownloads",
51519:   weekly_downloads: "weeklyDownloads",
51519:   daily_users:      "dailyUsers"
51519: };
51519: 
37488: 
53959: function convertHTMLToPlainText(html) {
53959:   if (!html)
53959:     return html;
53959:   var converter = Cc["@mozilla.org/widget/htmlformatconverter;1"].
53959:                   createInstance(Ci.nsIFormatConverter);
53959: 
53959:   var input = Cc["@mozilla.org/supports-string;1"].
53959:               createInstance(Ci.nsISupportsString);
87639:   input.data = html.replace(/\n/g, "<br>");
53959: 
53959:   var output = {};
53959:   converter.convert("text/html", input, input.data.length, "text/unicode",
53959:                     output, {});
53959: 
53959:   if (output.value instanceof Ci.nsISupportsString)
87639:     return output.value.data.replace(/\r\n/g, "\n");
53959:   return html;
53959: }
53959: 
62630: function getAddonsToCache(aIds, aCallback) {
62630:   try {
62630:     var types = Services.prefs.getCharPref(PREF_GETADDONS_CACHE_TYPES);
62630:   }
62630:   catch (e) { }
62630:   if (!types)
62630:     types = DEFAULT_CACHE_TYPES;
62630: 
62630:   types = types.split(",");
62630: 
62630:   AddonManager.getAddonsByIDs(aIds, function(aAddons) {
62630:     let enabledIds = [];
62630:     for (var i = 0; i < aIds.length; i++) {
62630:       var preference = PREF_GETADDONS_CACHE_ID_ENABLED.replace("%ID%", aIds[i]);
62630:       try {
62630:         if (!Services.prefs.getBoolPref(preference))
62630:           continue;
62630:       } catch(e) {
62630:         // If the preference doesn't exist caching is enabled by default
62630:       }
62630: 
62630:       // The add-ons manager may not know about this ID yet if it is a pending
62630:       // install. In that case we'll just cache it regardless
62630:       if (aAddons[i] && (types.indexOf(aAddons[i].type) == -1))
62630:         continue;
62630: 
62630:       enabledIds.push(aIds[i]);
62630:     }
62630: 
62630:     aCallback(enabledIds);
62630:   });
62630: }
62630: 
43746: function AddonSearchResult(aId) {
43746:   this.id = aId;
37488: }
37488: 
37488: AddonSearchResult.prototype = {
43746:   /**
43746:    * The ID of the add-on
43746:    */
37488:   id: null,
43746: 
43746:   /**
51519:    * The add-on type (e.g. "extension" or "theme")
51519:    */
51519:   type: null,
51519: 
51519:   /**
43746:    * The name of the add-on
43746:    */
37488:   name: null,
43746: 
43746:   /**
43746:    * The version of the add-on
43746:    */
37488:   version: null,
43746: 
43746:   /**
51519:    * The creator of the add-on
51519:    */
51519:   creator: null,
51519: 
51519:   /**
51519:    * The developers of the add-on
51519:    */
51519:   developers: null,
51519: 
51519:   /**
43746:    * A short description of the add-on
43746:    */
37488:   description: null,
43746: 
43746:   /**
43746:    * The full description of the add-on
43746:    */
43746:   fullDescription: null,
43746: 
43746:   /**
51519:    * The developer comments for the add-on. This includes any information
51519:    * that may be helpful to end users that isn't necessarily applicable to
51519:    * the add-on description (e.g. known major bugs)
43746:    */
51519:   developerComments: null,
43746: 
43746:   /**
51519:    * The end-user licensing agreement (EULA) of the add-on
51519:    */
51519:   eula: null,
51519: 
51519:   /**
51519:    * The url of the add-on's icon
43746:    */
37488:   iconURL: null,
43746: 
43746:   /**
43746:    * An array of screenshot urls for the add-on
43746:    */
43746:   screenshots: null,
43746: 
43746:   /**
43746:    * The homepage for the add-on
43746:    */
37488:   homepageURL: null,
43746: 
43746:   /**
51519:    * The support URL for the add-on
43746:    */
51519:   supportURL: null,
51519: 
51519:   /**
51519:    * The contribution url of the add-on
51519:    */
51519:   contributionURL: null,
51519: 
51519:   /**
51519:    * The suggested contribution amount
51519:    */
51519:   contributionAmount: null,
51519: 
51519:   /**
60127:    * The URL to visit in order to purchase the add-on
60127:    */
60127:   purchaseURL: null,
60127: 
60127:   /**
60127:    * The numerical cost of the add-on in some currency, for sorting purposes
60127:    * only
60127:    */
60127:   purchaseAmount: null,
60127: 
60127:   /**
60127:    * The display cost of the add-on, for display purposes only
60127:    */
60127:   purchaseDisplayAmount: null,
60127: 
60127:   /**
51519:    * The rating of the add-on, 0-5
51519:    */
51519:   averageRating: null,
51519: 
51519:   /**
51519:    * The number of reviews for this add-on
51519:    */
51519:   reviewCount: null,
51519: 
51519:   /**
51519:    * The URL to the list of reviews for this add-on
51519:    */
51519:   reviewURL: null,
51519: 
51519:   /**
51519:    * The total number of times the add-on was downloaded
51519:    */
51519:   totalDownloads: null,
51519: 
51519:   /**
51519:    * The number of times the add-on was downloaded the current week
51519:    */
51519:   weeklyDownloads: null,
51519: 
51519:   /**
51519:    * The number of daily users for the add-on
51519:    */
51519:   dailyUsers: null,
37488: 
43746:   /**
43746:    * AddonInstall object generated from the add-on XPI url
43746:    */
43746:   install: null,
43746: 
43746:   /**
51519:    * nsIURI storing where this add-on was installed from
51519:    */
51519:   sourceURI: null,
51519: 
51519:   /**
51519:    * The status of the add-on in the repository (e.g. 4 = "Public")
51519:    */
51519:   repositoryStatus: null,
51519: 
51519:   /**
51519:    * The size of the add-on's files in bytes. For an add-on that have not yet
51519:    * been downloaded this may be an estimated value.
51519:    */
51519:   size: null,
51519: 
51519:   /**
51519:    * The Date that the add-on was most recently updated
51519:    */
51519:   updateDate: null,
51519: 
51519:   /**
43746:    * True or false depending on whether the add-on is compatible with the
60127:    * current version of the application
43746:    */
43746:   isCompatible: true,
43746: 
43746:   /**
60127:    * True or false depending on whether the add-on is compatible with the
60127:    * current platform
60127:    */
60127:   isPlatformCompatible: true,
60127: 
60127:   /**
83133:    * Array of AddonCompatibilityOverride objects, that describe overrides for
83133:    * compatibility with an application versions.
83133:    **/
83133:   compatibilityOverrides: null,
83133: 
83133:   /**
43746:    * True if the add-on has a secure means of updating
43746:    */
43746:   providesUpdatesSecurely: true,
43746: 
43746:   /**
43746:    * The current blocklist state of the add-on
43746:    */
43746:   blocklistState: Ci.nsIBlocklistService.STATE_NOT_BLOCKED,
43746: 
43746:   /**
43746:    * True if this add-on cannot be used in the application based on version
43746:    * compatibility, dependencies and blocklisting
43746:    */
43746:   appDisabled: false,
43746: 
43746:   /**
43746:    * True if the user wants this add-on to be disabled
43746:    */
43746:   userDisabled: false,
43746: 
43746:   /**
43746:    * Indicates what scope the add-on is installed in, per profile, user,
43746:    * system or application
43746:    */
43746:   scope: AddonManager.SCOPE_PROFILE,
43746: 
43746:   /**
43746:    * True if the add-on is currently functional
43746:    */
43746:   isActive: true,
43746: 
43746:   /**
43746:    * A bitfield holding all of the current operations that are waiting to be
43746:    * performed for this add-on
43746:    */
43746:   pendingOperations: AddonManager.PENDING_NONE,
43746: 
43746:   /**
43746:    * A bitfield holding all the the operations that can be performed on
43746:    * this add-on
43746:    */
51519:   permissions: 0,
51519: 
51519:   /**
51519:    * Tests whether this add-on is known to be compatible with a
51519:    * particular application and platform version.
51519:    *
51519:    * @param  appVersion
51519:    *         An application version to test against
51519:    * @param  platformVersion
51519:    *         A platform version to test against
51519:    * @return Boolean representing if the add-on is compatible
51519:    */
51519:   isCompatibleWith: function(aAppVerison, aPlatformVersion) {
51519:     return true;
51519:   },
51519: 
51519:   /**
51519:    * Starts an update check for this add-on. This will perform
51519:    * asynchronously and deliver results to the given listener.
51519:    *
51519:    * @param  aListener
51519:    *         An UpdateListener for the update process
51519:    * @param  aReason
51519:    *         A reason code for performing the update
51519:    * @param  aAppVersion
51519:    *         An application version to check for updates for
51519:    * @param  aPlatformVersion
51519:    *         A platform version to check for updates for
51519:    */
51519:   findUpdates: function(aListener, aReason, aAppVersion, aPlatformVersion) {
51519:     if ("onNoCompatibilityUpdateAvailable" in aListener)
51519:       aListener.onNoCompatibilityUpdateAvailable(this);
51519:     if ("onNoUpdateAvailable" in aListener)
51519:       aListener.onNoUpdateAvailable(this);
51519:     if ("onUpdateFinished" in aListener)
51519:       aListener.onUpdateFinished(this);
51519:   }
51519: }
51519: 
43746: /**
43746:  * The add-on repository is a source of add-ons that can be installed. It can
51519:  * be searched in three ways. The first takes a list of IDs and returns a
51519:  * list of the corresponding add-ons. The second returns a list of add-ons that
51519:  * come highly recommended. This list should change frequently. The third is to
43746:  * search for specific search terms entered by the user. Searches are
43746:  * asynchronous and results should be passed to the provided callback object
43746:  * when complete. The results passed to the callback should only include add-ons
43746:  * that are compatible with the current application and are not already
51519:  * installed.
43746:  */
43746: var AddonRepository = {
51520:   /**
51520:    * Whether caching is currently enabled
51520:    */
51520:   get cacheEnabled() {
51520:     // Act as though caching is disabled if there was an unrecoverable error
51520:     // openning the database.
51520:     if (!AddonDatabase.databaseOk)
51520:       return false;
51520: 
51520:     let preference = PREF_GETADDONS_CACHE_ENABLED;
51520:     let enabled = false;
51520:     try {
51520:       enabled = Services.prefs.getBoolPref(preference);
51520:     } catch(e) {
51520:       WARN("cacheEnabled: Couldn't get pref: " + preference);
51520:     }
51520: 
51520:     return enabled;
51520:   },
51520: 
51520:   // A cache of the add-ons stored in the database
51520:   _addons: null,
51520: 
51520:   // An array of callbacks pending the retrieval of add-ons from AddonDatabase
51520:   _pendingCallbacks: null,
51520: 
51519:   // Whether a search is currently in progress
37488:   _searching: false,
37488: 
37488:   // XHR associated with the current request
37488:   _request: null,
37488: 
43746:   /*
43746:    * Addon search results callback object that contains two functions
43746:    *
43746:    * searchSucceeded - Called when a search has suceeded.
43746:    *
51519:    * @param  aAddons
51519:    *         An array of the add-on results. In the case of searching for
51519:    *         specific terms the ordering of results may be determined by
51519:    *         the search provider.
51519:    * @param  aAddonCount
51519:    *         The length of aAddons
51519:    * @param  aTotalResults
51519:    *         The total results actually available in the repository
43746:    *
43746:    *
43746:    * searchFailed - Called when an error occurred when performing a search.
43746:    */
37488:   _callback: null,
37488: 
37488:   // Maximum number of results to return
37488:   _maxResults: null,
37488:   
43746:   /**
51520:    * Initialize AddonRepository.
51520:    */
51520:   initialize: function() {
51520:     Services.obs.addObserver(this, "xpcom-shutdown", false);
51520:   },
51520: 
51520:   /**
51520:    * Observe xpcom-shutdown notification, so we can shutdown cleanly.
51520:    */
51520:   observe: function (aSubject, aTopic, aData) {
51520:     if (aTopic == "xpcom-shutdown") {
51520:       Services.obs.removeObserver(this, "xpcom-shutdown");
51520:       this.shutdown();
51520:     }
51520:   },
51520: 
51520:   /**
51520:    * Shut down AddonRepository
51520:    */
51520:   shutdown: function() {
51520:     this.cancelSearch();
51520: 
51520:     this._addons = null;
51520:     this._pendingCallbacks = null;
51520:     AddonDatabase.shutdown(function() {
51520:       Services.obs.notifyObservers(null, "addon-repository-shutdown", null);
51520:     });
51520:   },
51520: 
51520:   /**
51520:    * Asynchronously get a cached add-on by id. The add-on (or null if the
51520:    * add-on is not found) is passed to the specified callback. If caching is
51520:    * disabled, null is passed to the specified callback.
51520:    *
51520:    * @param  aId
51520:    *         The id of the add-on to get
51520:    * @param  aCallback
51520:    *         The callback to pass the result back to
51520:    */
51520:   getCachedAddonByID: function(aId, aCallback) {
51520:     if (!aId || !this.cacheEnabled) {
51520:       aCallback(null);
51520:       return;
51520:     }
51520: 
51520:     let self = this;
51520:     function getAddon(aAddons) {
51520:       aCallback((aId in aAddons) ? aAddons[aId] : null);
51520:     }
51520: 
51520:     if (this._addons == null) {
51520:       if (this._pendingCallbacks == null) {
51520:         // Data has not been retrieved from the database, so retrieve it
51520:         this._pendingCallbacks = [];
51520:         this._pendingCallbacks.push(getAddon);
51520:         AddonDatabase.retrieveStoredData(function(aAddons) {
51520:           let pendingCallbacks = self._pendingCallbacks;
51520: 
51520:           // Check if cache was shutdown or deleted before callback was called
51520:           if (pendingCallbacks == null)
51520:             return;
51520: 
51520:           // Callbacks may want to trigger a other caching operations that may
51520:           // affect _addons and _pendingCallbacks, so set to final values early
51520:           self._pendingCallbacks = null;
51520:           self._addons = aAddons;
51520: 
51520:           pendingCallbacks.forEach(function(aCallback) aCallback(aAddons));
51520:         });
51520: 
51520:         return;
51520:       }
51520: 
51520:       // Data is being retrieved from the database, so wait
51520:       this._pendingCallbacks.push(getAddon);
51520:       return;
51520:     }
51520: 
51520:     // Data has been retrieved, so immediately return result
51520:     getAddon(this._addons);
51520:   },
51520: 
51520:   /**
51520:    * Asynchronously repopulate cache so it only contains the add-ons
51520:    * corresponding to the specified ids. If caching is disabled,
51520:    * the cache is completely removed.
51520:    *
51520:    * @param  aIds
51520:    *         The array of add-on ids to repopulate the cache with
51520:    * @param  aCallback
51520:    *         The optional callback to call once complete
51520:    */
51520:   repopulateCache: function(aIds, aCallback) {
51520:     // Completely remove cache if caching is not enabled
51520:     if (!this.cacheEnabled) {
51520:       this._addons = null;
51520:       this._pendingCallbacks = null;
51520:       AddonDatabase.delete(aCallback);
51520:       return;
51520:     }
51520: 
62630:     let self = this;
62630:     getAddonsToCache(aIds, function(aAddons) {
59131:       // Completely remove cache if there are no add-ons to cache
62630:       if (aAddons.length == 0) {
83133:         self._addons = null;
83133:         self._pendingCallbacks = null;
59131:         AddonDatabase.delete(aCallback);
59131:         return;
59131:       }
59131: 
62630:       self.getAddonsByIDs(aAddons, {
51520:         searchSucceeded: function(aAddons) {
51520:           self._addons = {};
51520:           aAddons.forEach(function(aAddon) { self._addons[aAddon.id] = aAddon; });
51520:           AddonDatabase.repopulate(aAddons, aCallback);
51520:         },
51520:         searchFailed: function() {
51520:           WARN("Search failed when repopulating cache");
51520:           if (aCallback)
51520:             aCallback();
51520:         }
51520:       });
62630:     });
51520:   },
51520: 
51520:   /**
51520:    * Asynchronously add add-ons to the cache corresponding to the specified
51520:    * ids. If caching is disabled, the cache is unchanged and the callback is
51520:    * immediatly called if it is defined.
51520:    *
51520:    * @param  aIds
51520:    *         The array of add-on ids to add to the cache
51520:    * @param  aCallback
51520:    *         The optional callback to call once complete
51520:    */
51520:   cacheAddons: function(aIds, aCallback) {
51520:     if (!this.cacheEnabled) {
51520:       if (aCallback)
51520:         aCallback();
51520:       return;
51520:     }
51520: 
62630:     let self = this;
62630:     getAddonsToCache(aIds, function(aAddons) {
59131:       // If there are no add-ons to cache, act as if caching is disabled
62630:       if (aAddons.length == 0) {
59131:         if (aCallback)
59131:           aCallback();
59131:         return;
59131:       }
59131: 
62630:       self.getAddonsByIDs(aAddons, {
51520:         searchSucceeded: function(aAddons) {
51520:           aAddons.forEach(function(aAddon) { self._addons[aAddon.id] = aAddon; });
51520:           AddonDatabase.insertAddons(aAddons, aCallback);
51520:         },
51520:         searchFailed: function() {
51520:           WARN("Search failed when adding add-ons to cache");
51520:           if (aCallback)
51520:             aCallback();
51520:         }
51520:       });
62630:     });
51520:   },
51520: 
51520:   /**
51519:    * The homepage for visiting this repository. If the corresponding preference
51519:    * is not defined, defaults to about:blank.
43746:    */
37488:   get homepageURL() {
51519:     let url = this._formatURLPref(PREF_GETADDONS_BROWSEADDONS, {});
47951:     return (url != null) ? url : "about:blank";
37488:   },
37488: 
43746:   /**
43746:    * Returns whether this instance is currently performing a search. New
43746:    * searches will not be performed while this is the case.
43746:    */
37488:   get isSearching() {
37488:     return this._searching;
37488:   },
37488: 
43746:   /**
43746:    * The url that can be visited to see recommended add-ons in this repository.
51519:    * If the corresponding preference is not defined, defaults to about:blank.
43746:    */
37488:   getRecommendedURL: function() {
51519:     let url = this._formatURLPref(PREF_GETADDONS_BROWSERECOMMENDED, {});
47951:     return (url != null) ? url : "about:blank";
37488:   },
37488: 
43746:   /**
43746:    * Retrieves the url that can be visited to see search results for the given
51519:    * terms. If the corresponding preference is not defined, defaults to
51519:    * about:blank.
43746:    *
51519:    * @param  aSearchTerms
51519:    *         Search terms used to search the repository
43746:    */
37488:   getSearchURL: function(aSearchTerms) {
51519:     let url = this._formatURLPref(PREF_GETADDONS_BROWSESEARCHRESULTS, {
47951:       TERMS : encodeURIComponent(aSearchTerms)
47951:     });
47951:     return (url != null) ? url : "about:blank";
37488:   },
37488: 
43746:   /**
43746:    * Cancels the search in progress. If there is no search in progress this
43746:    * does nothing.
43746:    */
37488:   cancelSearch: function() {
37488:     this._searching = false;
37488:     if (this._request) {
37488:       this._request.abort();
37488:       this._request = null;
37488:     }
37488:     this._callback = null;
51519:   },
51519: 
51519:   /**
51519:    * Begins a search for add-ons in this repository by ID. Results will be
51519:    * passed to the given callback.
51519:    *
51519:    * @param  aIDs
51519:    *         The array of ids to search for
51519:    * @param  aCallback
51519:    *         The callback to pass results to
51519:    */
51519:   getAddonsByIDs: function(aIDs, aCallback) {
51520:     let ids = aIDs.slice(0);
61080: 
61080:     let params = {
51519:       API_VERSION : API_VERSION,
51520:       IDS : ids.map(encodeURIComponent).join(',')
61080:     };
61080: 
61080:     let url = this._formatURLPref(PREF_GETADDONS_BYIDS, params);
51519: 
51519:     let self = this;
83133:     function handleResults(aElements, aTotalResults, aCompatData) {
51519:       // Don't use this._parseAddons() so that, for example,
51519:       // incompatible add-ons are not filtered out
51519:       let results = [];
51519:       for (let i = 0; i < aElements.length && results.length < self._maxResults; i++) {
83133:         let result = self._parseAddon(aElements[i], null, aCompatData);
51519:         if (result == null)
51519:           continue;
51519: 
51519:         // Ignore add-on if it wasn't actually requested
51520:         let idIndex = ids.indexOf(result.addon.id);
51519:         if (idIndex == -1)
51519:           continue;
51519: 
51519:         results.push(result);
51519:         // Ignore this add-on from now on
51520:         ids.splice(idIndex, 1);
51519:       }
51519: 
83133:       // Include any compatibility overrides for addons not hosted by the
83133:       // remote repository.
83133:       for each (let addonCompat in aCompatData) {
83133:         if (addonCompat.hosted)
83133:           continue;
83133: 
83133:         let addon = new AddonSearchResult(addonCompat.id);
83133:         // Compatibility overrides can only be for extensions.
83133:         addon.type = "extension";
83133:         addon.compatibilityOverrides = addonCompat.compatRanges;
83133:         let result = {
83133:           addon: addon,
83133:           xpiURL: null,
83133:           xpiHash: null
83133:         };
83133:         results.push(result);
83133:       }
83133: 
51519:       // aTotalResults irrelevant
51519:       self._reportSuccess(results, -1);
51519:     }
51519: 
51520:     this._beginSearch(url, ids.length, aCallback, handleResults);
37488:   },
37488: 
43746:   /**
43746:    * Begins a search for recommended add-ons in this repository. Results will
43746:    * be passed to the given callback.
43746:    *
51519:    * @param  aMaxResults
51519:    *         The maximum number of results to return
51519:    * @param  aCallback
51519:    *         The callback to pass results to
43746:    */
37488:   retrieveRecommendedAddons: function(aMaxResults, aCallback) {
51519:     let url = this._formatURLPref(PREF_GETADDONS_GETRECOMMENDED, {
47951:       API_VERSION : API_VERSION,
37488: 
47951:       // Get twice as many results to account for potential filtering
47951:       MAX_RESULTS : 2 * aMaxResults
47951:     });
47951: 
51519:     let self = this;
51519:     function handleResults(aElements, aTotalResults) {
51519:       self._getLocalAddonIds(function(aLocalAddonIds) {
51519:         // aTotalResults irrelevant
51519:         self._parseAddons(aElements, -1, aLocalAddonIds);
51519:       });
51519:     }
51519: 
51519:     this._beginSearch(url, aMaxResults, aCallback, handleResults);
37488:   },
37488: 
43746:   /**
43746:    * Begins a search for add-ons in this repository. Results will be passed to
43746:    * the given callback.
43746:    *
51519:    * @param  aSearchTerms
51519:    *         The terms to search for
51519:    * @param  aMaxResults
51519:    *         The maximum number of results to return
51519:    * @param  aCallback
51519:    *         The callback to pass results to
43746:    */
37488:   searchAddons: function(aSearchTerms, aMaxResults, aCallback) {
80774:     let checkCompatibility = true;
80774:     try {
80774:       checkCompatibility = Services.prefs.getBoolPref(PREF_CHECK_COMPATIBILITY);
80774:     } catch(e) { }
84415:     let strictCompatibility = STRICT_COMPATIBILITY_DEFAULT;
84415:     try {
84415:       strictCompatibility = Services.prefs.getBoolPref(PREF_EM_STRICT_COMPATIBILITY);
84415:     } catch(e) { }
80774: 
84415:     let compatMode = "normal";
80774:     if (!checkCompatibility)
84415:       compatMode = "ignore";
84415:     else if (strictCompatibility)
84415:       compatMode = "strict";
84415: 
84415:     let substitutions = {
84415:       API_VERSION : API_VERSION,
84415:       TERMS : encodeURIComponent(aSearchTerms),
84415:       // Get twice as many results to account for potential filtering
84415:       MAX_RESULTS : 2 * aMaxResults,
84415:       COMPATIBILITY_MODE : compatMode,
84415:     };
80774: 
80774:     let url = this._formatURLPref(PREF_GETADDONS_GETSEARCHRESULTS, substitutions);
47951: 
51519:     let self = this;
51519:     function handleResults(aElements, aTotalResults) {
51519:       self._getLocalAddonIds(function(aLocalAddonIds) {
51519:         self._parseAddons(aElements, aTotalResults, aLocalAddonIds);
51519:       });
51519:     }
51519: 
51519:     this._beginSearch(url, aMaxResults, aCallback, handleResults);
37488:   },
37488: 
37488:   // Posts results to the callback
51519:   _reportSuccess: function(aResults, aTotalResults) {
37488:     this._searching = false;
37488:     this._request = null;
37488:     // The callback may want to trigger a new search so clear references early
51519:     let addons = [result.addon for each(result in aResults)];
51519:     let callback = this._callback;
37488:     this._callback = null;
51519:     callback.searchSucceeded(addons, addons.length, aTotalResults);
37488:   },
37488: 
37488:   // Notifies the callback of a failure
43746:   _reportFailure: function() {
37488:     this._searching = false;
37488:     this._request = null;
37488:     // The callback may want to trigger a new search so clear references early
51519:     let callback = this._callback;
37488:     this._callback = null;
37488:     callback.searchFailed();
37488:   },
37488: 
51519:   // Get descendant by unique tag name. Returns null if not unique tag name.
51519:   _getUniqueDescendant: function(aElement, aTagName) {
51519:     let elementsList = aElement.getElementsByTagName(aTagName);
51519:     return (elementsList.length == 1) ? elementsList[0] : null;
51519:   },
51519: 
83133:   // Get direct descendant by unique tag name.
83133:   // Returns null if not unique tag name.
83133:   _getUniqueDirectDescendant: function(aElement, aTagName) {
83133:     let elementsList = Array.filter(aElement.children,
83133:                                     function(aChild) aChild.tagName == aTagName);
83133:     return (elementsList.length == 1) ? elementsList[0] : null;
83133:   },
83133: 
51519:   // Parse out trimmed text content. Returns null if text content empty.
51519:   _getTextContent: function(aElement) {
51519:     let textContent = aElement.textContent.trim();
51519:     return (textContent.length > 0) ? textContent : null;
51519:   },
51519: 
51519:   // Parse out trimmed text content of a descendant with the specified tag name
51519:   // Returns null if the parsing unsuccessful.
51519:   _getDescendantTextContent: function(aElement, aTagName) {
51519:     let descendant = this._getUniqueDescendant(aElement, aTagName);
51519:     return (descendant != null) ? this._getTextContent(descendant) : null;
51519:   },
51519: 
83133:   // Parse out trimmed text content of a direct descendant with the specified
83133:   // tag name.
83133:   // Returns null if the parsing unsuccessful.
83133:   _getDirectDescendantTextContent: function(aElement, aTagName) {
83133:     let descendant = this._getUniqueDirectDescendant(aElement, aTagName);
83133:     return (descendant != null) ? this._getTextContent(descendant) : null;
83133:   },
83133: 
51519:   /*
51519:    * Creates an AddonSearchResult by parsing an <addon> element
51519:    *
51519:    * @param  aElement
51519:    *         The <addon> element to parse
51519:    * @param  aSkip
51519:    *         Object containing ids and sourceURIs of add-ons to skip.
83133:    * @param  aCompatData
83133:    *         Array of parsed addon_compatibility elements to accosiate with the
83133:    *         resulting AddonSearchResult. Optional.
51519:    * @return Result object containing the parsed AddonSearchResult, xpiURL and
51519:    *         xpiHash if the parsing was successful. Otherwise returns null.
51519:    */
83133:   _parseAddon: function(aElement, aSkip, aCompatData) {
51519:     let skipIDs = (aSkip && aSkip.ids) ? aSkip.ids : [];
51519:     let skipSourceURIs = (aSkip && aSkip.sourceURIs) ? aSkip.sourceURIs : [];
37488: 
51519:     let guid = this._getDescendantTextContent(aElement, "guid");
51519:     if (guid == null || skipIDs.indexOf(guid) != -1)
51519:       return null;
42447: 
51519:     let addon = new AddonSearchResult(guid);
51519:     let result = {
43746:       addon: addon,
43746:       xpiURL: null,
43746:       xpiHash: null
43746:     };
51519: 
83133:     if (aCompatData && guid in aCompatData)
83133:       addon.compatibilityOverrides = aCompatData[guid].compatRanges;
83133: 
51519:     let self = this;
51519:     for (let node = aElement.firstChild; node; node = node.nextSibling) {
51519:       if (!(node instanceof Ci.nsIDOMElement))
51519:         continue;
51519: 
51519:       let localName = node.localName;
51519: 
51519:       // Handle case where the wanted string value is located in text content
63111:       // but only if the content is not empty
51519:       if (localName in STRING_KEY_MAP) {
63111:         addon[STRING_KEY_MAP[localName]] = this._getTextContent(node) || addon[STRING_KEY_MAP[localName]];
51519:         continue;
51519:       }
51519: 
53959:       // Handle case where the wanted string value is html located in text content
53959:       if (localName in HTML_KEY_MAP) {
53959:         addon[HTML_KEY_MAP[localName]] = convertHTMLToPlainText(this._getTextContent(node));
53959:         continue;
53959:       }
53959: 
51519:       // Handle case where the wanted integer value is located in text content
51519:       if (localName in INTEGER_KEY_MAP) {
51519:         let value = parseInt(this._getTextContent(node));
51519:         if (value >= 0)
51519:           addon[INTEGER_KEY_MAP[localName]] = value;
51519:         continue;
51519:       }
51519: 
51519:       // Handle cases that aren't as simple as grabbing the text content
51519:       switch (localName) {
51519:         case "type":
51519:           // Map AMO's type id to corresponding string
51519:           let id = parseInt(node.getAttribute("id"));
51519:           switch (id) {
51519:             case 1:
51519:               addon.type = "extension";
43746:               break;
51519:             case 2:
51519:               addon.type = "theme";
43746:               break;
79913:             case 3:
79913:               addon.type = "dictionary";
79913:               break;
51519:             default:
51520:               WARN("Unknown type id when parsing addon: " + id);
37488:           }
37488:           break;
51519:         case "authors":
51519:           let authorNodes = node.getElementsByTagName("author");
51519:           Array.forEach(authorNodes, function(aAuthorNode) {
51519:             let name = self._getDescendantTextContent(aAuthorNode, "name");
51519:             let link = self._getDescendantTextContent(aAuthorNode, "link");
51519:             if (name == null || link == null)
51519:               return;
51519: 
51520:             let author = new AddonManagerPrivate.AddonAuthor(name, link);
51519:             if (addon.creator == null)
51519:               addon.creator = author;
51520:             else {
51520:               if (addon.developers == null)
51520:                 addon.developers = [];
51520: 
51519:               addon.developers.push(author);
51520:             }
51519:           });
37488:           break;
51519:         case "previews":
51519:           let previewNodes = node.getElementsByTagName("preview");
51519:           Array.forEach(previewNodes, function(aPreviewNode) {
77865:             let full = self._getUniqueDescendant(aPreviewNode, "full");
51519:             if (full == null)
51519:               return;
51519: 
77865:             let fullURL = self._getTextContent(full);
77865:             let fullWidth = full.getAttribute("width");
77865:             let fullHeight = full.getAttribute("height");
77865: 
77865:             let thumbnailURL, thumbnailWidth, thumbnailHeight;
77865:             let thumbnail = self._getUniqueDescendant(aPreviewNode, "thumbnail");
77865:             if (thumbnail) {
77865:               thumbnailURL = self._getTextContent(thumbnail);
77865:               thumbnailWidth = thumbnail.getAttribute("width");
77865:               thumbnailHeight = thumbnail.getAttribute("height");
77865:             }
51519:             let caption = self._getDescendantTextContent(aPreviewNode, "caption");
77865:             let screenshot = new AddonManagerPrivate.AddonScreenshot(fullURL, fullWidth, fullHeight,
77865:                                                                      thumbnailURL, thumbnailWidth,
77865:                                                                      thumbnailHeight, caption);
51520: 
51520:             if (addon.screenshots == null)
51520:               addon.screenshots = [];
51519: 
51519:             if (aPreviewNode.getAttribute("primary") == 1)
51519:               addon.screenshots.unshift(screenshot);
51519:             else
51519:               addon.screenshots.push(screenshot);
51519:           });
37488:           break;
37488:         case "learnmore":
51519:           addon.homepageURL = addon.homepageURL || this._getTextContent(node);
37488:           break;
51519:         case "contribution_data":
51519:           let meetDevelopers = this._getDescendantTextContent(node, "meet_developers");
51519:           let suggestedAmount = this._getDescendantTextContent(node, "suggested_amount");
60129:           if (meetDevelopers != null) {
51519:             addon.contributionURL = meetDevelopers;
51519:             addon.contributionAmount = suggestedAmount;
51519:           }
51519:           break
60127:         case "payment_data":
60127:           let link = this._getDescendantTextContent(node, "link");
60127:           let amountTag = this._getUniqueDescendant(node, "amount");
60127:           let amount = parseFloat(amountTag.getAttribute("amount"));
60127:           let displayAmount = this._getTextContent(amountTag);
60127:           if (link != null && amount != null && displayAmount != null) {
60127:             addon.purchaseURL = link;
60127:             addon.purchaseAmount = amount;
60127:             addon.purchaseDisplayAmount = displayAmount;
60127:           }
60127:           break
51519:         case "rating":
51519:           let averageRating = parseInt(this._getTextContent(node));
51519:           if (averageRating >= 0)
51519:             addon.averageRating = Math.min(5, averageRating);
51519:           break;
51519:         case "reviews":
51519:           let url = this._getTextContent(node);
51519:           let num = parseInt(node.getAttribute("num"));
51519:           if (url != null && num >= 0) {
51519:             addon.reviewURL = url;
51519:             addon.reviewCount = num;
51519:           }
51519:           break;
51519:         case "status":
51519:           let repositoryStatus = parseInt(node.getAttribute("id"));
51519:           if (!isNaN(repositoryStatus))
51519:             addon.repositoryStatus = repositoryStatus;
37488:           break;
60127:         case "all_compatible_os":
60127:           let nodes = node.getElementsByTagName("os");
60127:           addon.isPlatformCompatible = Array.some(nodes, function(aNode) {
60127:             let text = aNode.textContent.toLowerCase().trim();
60127:             return text == "all" || text == Services.appinfo.OS.toLowerCase();
60127:           });
60127:           break;
37488:         case "install":
37488:           // No os attribute means the xpi is compatible with any os
37488:           if (node.hasAttribute("os")) {
51519:             let os = node.getAttribute("os").trim().toLowerCase();
37488:             // If the os is not ALL and not the current OS then ignore this xpi
47951:             if (os != "all" && os != Services.appinfo.OS.toLowerCase())
37488:               break;
37488:           }
43746: 
51519:           let xpiURL = this._getTextContent(node);
51519:           if (xpiURL == null)
51519:             break;
43746: 
51519:           if (skipSourceURIs.indexOf(xpiURL) != -1)
51519:             return null;
51519: 
51519:           result.xpiURL = xpiURL;
51519:           addon.sourceURI = NetUtil.newURI(xpiURL);
51519: 
51519:           let size = parseInt(node.getAttribute("size"));
51519:           addon.size = (size >= 0) ? size : null;
51519: 
51519:           let xpiHash = node.getAttribute("hash");
51519:           if (xpiHash != null)
51519:             xpiHash = xpiHash.trim();
51519:           result.xpiHash = xpiHash ? xpiHash : null;
51519:           break;
51519:         case "last_updated":
51519:           let epoch = parseInt(node.getAttribute("epoch"));
51519:           if (!isNaN(epoch))
51519:             addon.updateDate = new Date(1000 * epoch);
37488:           break;
37488:       }
37488:     }
37488: 
51519:     return result;
43746:   },
43746: 
43746:   _parseAddons: function(aElements, aTotalResults, aSkip) {
51519:     let self = this;
51519:     let results = [];
80774: 
80774:     let checkCompatibility = true;
80774:     try {
80774:       checkCompatibility = Services.prefs.getBoolPref(PREF_CHECK_COMPATIBILITY);
80774:     } catch(e) { }
80774: 
83133:     let strictCompatibility = STRICT_COMPATIBILITY_DEFAULT;
83133:     try {
83133:       strictCompatibility = Services.prefs.getBoolPref(PREF_EM_STRICT_COMPATIBILITY);
83133:     } catch (e) {}
83133: 
80774:     function isSameApplication(aAppNode) {
80774:       return self._getTextContent(aAppNode) == Services.appinfo.ID;
80774:     }
80774: 
51519:     for (let i = 0; i < aElements.length && results.length < this._maxResults; i++) {
51519:       let element = aElements[i];
43746: 
51519:       let tags = this._getUniqueDescendant(element, "compatible_applications");
51519:       if (tags == null)
51519:         continue;
51519: 
51519:       let applications = tags.getElementsByTagName("appID");
51519:       let compatible = Array.some(applications, function(aAppNode) {
80774:         if (!isSameApplication(aAppNode))
51519:           return false;
51519: 
51519:         let parent = aAppNode.parentNode;
51519:         let minVersion = self._getDescendantTextContent(parent, "min_version");
51519:         let maxVersion = self._getDescendantTextContent(parent, "max_version");
51519:         if (minVersion == null || maxVersion == null)
51519:           return false;
51519: 
51519:         let currentVersion = Services.appinfo.version;
51519:         return (Services.vc.compare(minVersion, currentVersion) <= 0 &&
83133:                 ((!strictCompatibility) ||
83133:                  Services.vc.compare(currentVersion, maxVersion) <= 0));
51519:       });
51519: 
80774:       // Ignore add-ons not compatible with this Application
80774:       if (!compatible) {
80774:         if (checkCompatibility)
51519:           continue;
51519: 
80774:         if (!Array.some(applications, isSameApplication))
80774:           continue;
80774:       }
80774: 
83133:       // Add-on meets all requirements, so parse out data.
83133:       // Don't pass in compatiblity override data, because that's only returned
83133:       // in GUID searches, which don't use _parseAddons().
51519:       let result = this._parseAddon(element, aSkip);
51519:       if (result == null)
51519:         continue;
51519: 
51519:       // Ignore add-on missing a required attribute
51519:       let requiredAttributes = ["id", "name", "version", "type", "creator"];
51519:       if (requiredAttributes.some(function(aAttribute) !result.addon[aAttribute]))
51519:         continue;
51519: 
60127:       // Add only if the add-on is compatible with the platform
60127:       if (!result.addon.isPlatformCompatible)
60127:         continue;
60127: 
60127:       // Add only if there was an xpi compatible with this OS or there was a
60127:       // way to purchase the add-on
60127:       if (!result.xpiURL && !result.addon.purchaseURL)
51519:         continue;
51519: 
80774:       result.addon.isCompatible = compatible;
80774: 
51519:       results.push(result);
51519:       // Ignore this add-on from now on by adding it to the skip array
51519:       aSkip.ids.push(result.addon.id);
51519:     }
51519: 
51519:     // Immediately report success if no AddonInstall instances to create
51519:     let pendingResults = results.length;
43746:     if (pendingResults == 0) {
51519:       this._reportSuccess(results, aTotalResults);
43746:       return;
43746:     }
43746: 
51519:     // Create an AddonInstall for each result
51519:     let self = this;
51519:     results.forEach(function(aResult) {
51519:       let addon = aResult.addon;
51519:       let callback = function(aInstall) {
43746:         addon.install = aInstall;
43746:         pendingResults--;
43746:         if (pendingResults == 0)
51519:           self._reportSuccess(results, aTotalResults);
43746:       }
43746: 
60127:       if (aResult.xpiURL) {
43746:         AddonManager.getInstallForURL(aResult.xpiURL, callback,
43746:                                       "application/x-xpinstall", aResult.xpiHash,
43746:                                       addon.name, addon.iconURL, addon.version);
60127:       }
60127:       else {
60127:         callback(null);
60127:       }
43746:     });
37488:   },
37488: 
83133:   // Parses addon_compatibility nodes, that describe compatibility overrides.
83133:   _parseAddonCompatElement: function(aResultObj, aElement) {
83133:     let guid = this._getDescendantTextContent(aElement, "guid");
86444:     if (!guid) {
86444:         LOG("Compatibility override is missing guid.");
83133:       return;
86444:     }
83133: 
83133:     let compat = {id: guid};
83133:     compat.hosted = aElement.getAttribute("hosted") != "false";
83133: 
83133:     function findMatchingAppRange(aNodes) {
83133:       let toolkitAppRange = null;
83133:       for (let i = 0; i < aNodes.length; i++) {
83133:         let node = aNodes[i];
83133:         let appID = this._getDescendantTextContent(node, "appID");
83133:         if (appID != Services.appinfo.ID && appID != TOOLKIT_ID)
83133:           continue;
83133: 
83133:         let minVersion = this._getDescendantTextContent(node, "min_version");
83133:         let maxVersion = this._getDescendantTextContent(node, "max_version");
83133:         if (minVersion == null || maxVersion == null)
83133:           continue;
83133: 
83133:         let appRange = { appID: appID,
83133:                          appMinVersion: minVersion,
83133:                          appMaxVersion: maxVersion };
83133: 
83133:         // Only use Toolkit app ranges if no ranges match the application ID.
83133:         if (appID == TOOLKIT_ID)
83133:           toolkitAppRange = appRange;
83133:         else
83133:           return appRange;
83133:       }
83133:       return toolkitAppRange;
83133:     }
83133: 
83133:     function parseRangeNode(aNode) {
83133:       let type = aNode.getAttribute("type");
83133:       // Only "incompatible" (blacklisting) is supported for now.
86444:       if (type != "incompatible") {
86444:         LOG("Compatibility override of unsupported type found.");
83133:         return null;
86444:       }
83133: 
83133:       let override = new AddonManagerPrivate.AddonCompatibilityOverride(type);
83133: 
83133:       override.minVersion = this._getDirectDescendantTextContent(aNode, "min_version");
83133:       override.maxVersion = this._getDirectDescendantTextContent(aNode, "max_version");
83133: 
86444:       if (!override.minVersion) {
86444:         LOG("Compatibility override is missing min_version.");
83133:         return null;
86444:       }
86444:       if (!override.maxVersion) {
86444:         LOG("Compatibility override is missing max_version.");
86444:         return null;
86444:       }
83133: 
83133:       let appRanges = aNode.querySelectorAll("compatible_applications > application");
83133:       let appRange = findMatchingAppRange.bind(this)(appRanges);
86444:       if (!appRange) {
86444:         LOG("Compatibility override is missing a valid application range.");
83133:         return null;
86444:       }
83133: 
83133:       override.appID = appRange.appID;
83133:       override.appMinVersion = appRange.appMinVersion;
83133:       override.appMaxVersion = appRange.appMaxVersion;
83133: 
83133:       return override;
83133:     }
83133: 
83133:     let rangeNodes = aElement.querySelectorAll("version_ranges > version_range");
83133:     compat.compatRanges = Array.map(rangeNodes, parseRangeNode.bind(this))
83133:                                .filter(function(aItem) !!aItem);
83133:     if (compat.compatRanges.length == 0)
83133:       return;
83133: 
83133:     aResultObj[compat.id] = compat;
83133:   },
83133: 
83133:   // Parses addon_compatibility elements.
83133:   _parseAddonCompatData: function(aElements) {
83133:     let compatData = {};
83133:     Array.forEach(aElements, this._parseAddonCompatElement.bind(this, compatData));
83133:     return compatData;
83133:   },
83133: 
51519:   // Begins a new search if one isn't currently executing
51519:   _beginSearch: function(aURI, aMaxResults, aCallback, aHandleResults) {
51519:     if (this._searching || aURI == null || aMaxResults <= 0) {
51519:       aCallback.searchFailed();
37488:       return;
37488:     }
42076: 
51519:     this._searching = true;
51519:     this._callback = aCallback;
51519:     this._maxResults = aMaxResults;
43746: 
61080:     LOG("Requesting " + aURI);
61080: 
37488:     this._request = Cc["@mozilla.org/xmlextras/xmlhttprequest;1"].
37488:                     createInstance(Ci.nsIXMLHttpRequest);
63077:     this._request.mozBackgroundRequest = true;
37488:     this._request.open("GET", aURI, true);
37488:     this._request.overrideMimeType("text/xml");
37488: 
51519:     let self = this;
79462:     this._request.addEventListener("error", function(aEvent) {
79462:       self._reportFailure();
79462:     }, false);
79462:     this._request.addEventListener("load", function(aEvent) {
51519:       let request = aEvent.target;
51519:       let responseXML = request.responseXML;
51519: 
51519:       if (!responseXML || responseXML.documentElement.namespaceURI == XMLURI_PARSE_ERROR ||
51519:           (request.status != 200 && request.status != 0)) {
51519:         self._reportFailure();
51519:         return;
51519:       }
51519: 
51519:       let documentElement = responseXML.documentElement;
51519:       let elements = documentElement.getElementsByTagName("addon");
51519:       let totalResults = elements.length;
51519:       let parsedTotalResults = parseInt(documentElement.getAttribute("total_results"));
51519:       // Parsed value of total results only makes sense if >= elements.length
51519:       if (parsedTotalResults >= totalResults)
51519:         totalResults = parsedTotalResults;
51519: 
83133:       let compatElements = documentElement.getElementsByTagName("addon_compatibility");
83133:       let compatData = self._parseAddonCompatData(compatElements);
83133: 
83133:       aHandleResults(elements, totalResults, compatData);
79462:     }, false);
37488:     this._request.send(null);
47951:   },
47951: 
51519:   // Gets the id's of local add-ons, and the sourceURI's of local installs,
51519:   // passing the results to aCallback
51519:   _getLocalAddonIds: function(aCallback) {
51519:     let self = this;
51519:     let localAddonIds = {ids: null, sourceURIs: null};
51519: 
51519:     AddonManager.getAllAddons(function(aAddons) {
51519:       localAddonIds.ids = [a.id for each (a in aAddons)];
51519:       if (localAddonIds.sourceURIs)
51519:         aCallback(localAddonIds);
51519:     });
51519: 
51519:     AddonManager.getAllInstalls(function(aInstalls) {
51519:       localAddonIds.sourceURIs = [];
51519:       aInstalls.forEach(function(aInstall) {
51519:         if (aInstall.state != AddonManager.STATE_AVAILABLE)
51519:           localAddonIds.sourceURIs.push(aInstall.sourceURI.spec);
51519:       });
51519: 
51519:       if (localAddonIds.ids)
51519:         aCallback(localAddonIds);
51519:     });
51519:   },
51519: 
51519:   // Create url from preference, returning null if preference does not exist
51519:   _formatURLPref: function(aPreference, aSubstitutions) {
51519:     let url = null;
47951:     try {
51519:       url = Services.prefs.getCharPref(aPreference);
47951:     } catch(e) {
51520:       WARN("_formatURLPref: Couldn't get pref: " + aPreference);
47951:       return null;
37488:     }
37488: 
47951:     url = url.replace(/%([A-Z_]+)%/g, function(aMatch, aKey) {
47951:       return (aKey in aSubstitutions) ? aSubstitutions[aKey] : aMatch;
47951:     });
47951: 
47951:     return Services.urlFormatter.formatURL(url);
83133:   },
83133: 
83133:   // Find a AddonCompatibilityOverride that matches a given aAddonVersion and
83133:   // application/platform version.
83133:   findMatchingCompatOverride: function AR_findMatchingCompatOverride(aAddonVersion,
83134:                                                                      aCompatOverrides,
83134:                                                                      aAppVersion,
83134:                                                                      aPlatformVersion) {
83133:     for (let i = 0; i < aCompatOverrides.length; i++) {
83133:       let override = aCompatOverrides[i];
83133: 
83133:       let appVersion = null;
83133:       if (override.appID == TOOLKIT_ID)
83134:         appVersion = aPlatformVersion || Services.appinfo.platformVersion;
83133:       else
83134:         appVersion = aAppVersion || Services.appinfo.version;
83133: 
83133:       if (Services.vc.compare(override.minVersion, aAddonVersion) <= 0 &&
83133:           Services.vc.compare(aAddonVersion, override.maxVersion) <= 0 &&
83133:           Services.vc.compare(override.appMinVersion, appVersion) <= 0 &&
83133:           Services.vc.compare(appVersion, override.appMaxVersion) <= 0) {
83133:         return override;
47951:       }
83133:     }
83133:     return null;
83133:   }
83133: 
51520: };
51520: AddonRepository.initialize();
51520: 
51520: var AddonDatabase = {
51520:   // true if the database connection has been opened
51520:   initialized: false,
51520:   // false if there was an unrecoverable error openning the database
51520:   databaseOk: true,
51520:   // A cache of statements that are used and need to be finalized on shutdown
81454:   asyncStatementsCache: {},
51520: 
81454:   // The queries used by the database
81454:   queries: {
51520:     getAllAddons: "SELECT internal_id, id, type, name, version, " +
51520:                   "creator, creatorURL, description, fullDescription, " +
51520:                   "developerComments, eula, iconURL, homepageURL, supportURL, " +
51520:                   "contributionURL, contributionAmount, averageRating, " +
51520:                   "reviewCount, reviewURL, totalDownloads, weeklyDownloads, " +
51520:                   "dailyUsers, sourceURI, repositoryStatus, size, updateDate " +
51520:                   "FROM addon",
51520: 
51520:     getAllDevelopers: "SELECT addon_internal_id, name, url FROM developer " +
51520:                       "ORDER BY addon_internal_id, num",
51520: 
77865:     getAllScreenshots: "SELECT addon_internal_id, url, width, height, " +
77865:                        "thumbnailURL, thumbnailWidth, thumbnailHeight, caption " +
51520:                        "FROM screenshot ORDER BY addon_internal_id, num",
51520: 
83133:     getAllCompatOverrides: "SELECT addon_internal_id, type, minVersion, " +
83133:                            "maxVersion, appID, appMinVersion, appMaxVersion " +
83133:                            "FROM compatibility_override " +
83133:                            "ORDER BY addon_internal_id, num",
83133: 
51520:     insertAddon: "INSERT INTO addon VALUES (NULL, :id, :type, :name, :version, " +
51520:                  ":creator, :creatorURL, :description, :fullDescription, " +
51520:                  ":developerComments, :eula, :iconURL, :homepageURL, :supportURL, " +
51520:                  ":contributionURL, :contributionAmount, :averageRating, " +
51520:                  ":reviewCount, :reviewURL, :totalDownloads, :weeklyDownloads, " +
51520:                  ":dailyUsers, :sourceURI, :repositoryStatus, :size, :updateDate)",
51520: 
51520:     insertDeveloper:  "INSERT INTO developer VALUES (:addon_internal_id, " +
51520:                       ":num, :name, :url)",
51520: 
77865:     // We specify column names here because the columns
77865:     // could be out of order due to schema changes.
77865:     insertScreenshot: "INSERT INTO screenshot (addon_internal_id, " +
77865:                       "num, url, width, height, thumbnailURL, " +
77865:                       "thumbnailWidth, thumbnailHeight, caption) " +
77865:                       "VALUES (:addon_internal_id, " +
77865:                       ":num, :url, :width, :height, :thumbnailURL, " +
77865:                       ":thumbnailWidth, :thumbnailHeight, :caption)",
51520: 
83133:     insertCompatibilityOverride: "INSERT INTO compatibility_override VALUES " +
83133:                                  "(:addon_internal_id, :num, :type, " +
83133:                                  ":minVersion, :maxVersion, :appID, " +
83133:                                  ":appMinVersion, :appMaxVersion)",
83133: 
51520:     emptyAddon:       "DELETE FROM addon"
51520:   },
51520: 
51520:   /**
51520:    * A helper function to log an SQL error.
51520:    *
51520:    * @param  aError
51520:    *         The storage error code associated with the error
51520:    * @param  aErrorString
51520:    *         An error message
51520:    */
51520:   logSQLError: function AD_logSQLError(aError, aErrorString) {
51520:     ERROR("SQL error " + aError + ": " + aErrorString);
51520:   },
51520: 
51520:   /**
51520:    * A helper function to log any errors that occur during async statements.
51520:    *
51520:    * @param  aError
51520:    *         A mozIStorageError to log
51520:    */
51520:   asyncErrorLogger: function AD_asyncErrorLogger(aError) {
51520:     ERROR("Async SQL error " + aError.result + ": " + aError.message);
51520:   },
51520: 
51520:   /**
51520:    * Synchronously opens a new connection to the database file.
51520:    *
51520:    * @param  aSecondAttempt
51520:    *         Whether this is a second attempt to open the database
51520:    * @return the mozIStorageConnection for the database
51520:    */
51520:   openConnection: function AD_openConnection(aSecondAttempt) {
51520:     this.initialized = true;
51520:     delete this.connection;
51520: 
51520:     let dbfile = FileUtils.getFile(KEY_PROFILEDIR, [FILE_DATABASE], true);
51520:     let dbMissing = !dbfile.exists();
51520: 
79980:     var tryAgain = (function() {
77865:       LOG("Deleting database, and attempting openConnection again");
77865:       this.initialized = false;
77865:       if (this.connection.connectionReady)
77865:         this.connection.close();
77865:       if (dbfile.exists())
77865:         dbfile.remove(false);
77865:       return this.openConnection(true);
79980:     }).bind(this);
77865: 
51520:     try {
51520:       this.connection = Services.storage.openUnsharedDatabase(dbfile);
51520:     } catch (e) {
51520:       this.initialized = false;
57401:       ERROR("Failed to open database", e);
51520:       if (aSecondAttempt || dbMissing) {
51520:         this.databaseOk = false;
51520:         throw e;
47951:       }
77865:       return tryAgain();
51520:     }
51520: 
51520:     this.connection.executeSimpleSQL("PRAGMA locking_mode = EXCLUSIVE");
77865:     if (dbMissing)
51520:       this._createSchema();
51520: 
83133:     try {
77865:       switch (this.connection.schemaVersion) {
77865:         case 0:
83133:           LOG("Recreating database schema");
77865:           this._createSchema();
77865:           break;
77865:         case 1:
83133:           LOG("Upgrading database schema");
77865:           this.connection.executeSimpleSQL("ALTER TABLE screenshot ADD COLUMN width INTEGER");
77865:           this.connection.executeSimpleSQL("ALTER TABLE screenshot ADD COLUMN height INTEGER");
77865:           this.connection.executeSimpleSQL("ALTER TABLE screenshot ADD COLUMN thumbnailWidth INTEGER");
77865:           this.connection.executeSimpleSQL("ALTER TABLE screenshot ADD COLUMN thumbnailHeight INTEGER");
83133:         case 2:
83133:           this.connection.createTable("compatibility_override",
83133:                                       "addon_internal_id INTEGER, " +
83133:                                       "num INTEGER, " +
83133:                                       "type TEXT, " +
83133:                                       "minVersion TEXT, " +
83133:                                       "maxVersion TEXT, " +
83133:                                       "appID TEXT, " +
83133:                                       "appMinVersion TEXT, " +
83133:                                       "appMaxVersion TEXT, " +
83133:                                       "PRIMARY KEY (addon_internal_id, num)");
77865:             this._createIndices();
83133:             this._createTriggers();
77865:             this.connection.schemaVersion = DB_SCHEMA;
83133:         case 3:
83133:           break;
83133:         default:
83133:           return tryAgain();
83133:       }
77865:     } catch (e) {
77865:       ERROR("Failed to create database schema", e);
77865:       this.logSQLError(this.connection.lastError, this.connection.lastErrorString);
77865:       this.connection.rollbackTransaction();
77865:       return tryAgain();
77865:     }
77865: 
51520:     return this.connection;
51520:   },
51520: 
51520:   /**
51520:    * A lazy getter for the database connection.
51520:    */
51520:   get connection() {
51520:     return this.openConnection();
51520:   },
51520: 
51520:   /**
51520:    * Asynchronously shuts down the database connection and releases all
51520:    * cached objects
51520:    *
51520:    * @param  aCallback
51520:    *         An optional callback to call once complete
51520:    */
51520:   shutdown: function AD_shutdown(aCallback) {
51520:     this.databaseOk = true;
51520:     if (!this.initialized) {
51520:       if (aCallback)
51520:         aCallback();
51520:       return;
51520:     }
51520: 
51520:     this.initialized = false;
51520: 
81454:     for each (let stmt in this.asyncStatementsCache)
51520:       stmt.finalize();
81454:     this.asyncStatementsCache = {};
51520: 
51520:     if (this.connection.transactionInProgress) {
51520:       ERROR("Outstanding transaction, rolling back.");
51520:       this.connection.rollbackTransaction();
51520:     }
51520: 
51520:     let connection = this.connection;
51520:     delete this.connection;
51520: 
51520:     // Re-create the connection smart getter to allow the database to be
51520:     // re-loaded during testing.
51520:     this.__defineGetter__("connection", function() {
51520:       return this.openConnection();
51520:     });
51520: 
51520:     connection.asyncClose(aCallback);
51520:   },
51520: 
51520:   /**
51520:    * Asynchronously deletes the database, shutting down the connection
51520:    * first if initialized
51520:    *
51520:    * @param  aCallback
51520:    *         An optional callback to call once complete
51520:    */
51520:   delete: function AD_delete(aCallback) {
51520:     this.shutdown(function() {
51520:       let dbfile = FileUtils.getFile(KEY_PROFILEDIR, [FILE_DATABASE], true);
51520:       if (dbfile.exists())
51520:         dbfile.remove(false);
51520: 
51520:       if (aCallback)
51520:         aCallback();
51520:     });
51520:   },
51520: 
51520:   /**
81454:    * Gets a cached async statement or creates a new statement if it doesn't
81454:    * already exist.
51520:    *
51520:    * @param  aKey
51520:    *         A unique key to reference the statement
81454:    * @return a mozIStorageAsyncStatement for the SQL corresponding to the
81454:    *         unique key
51520:    */
81454:   getAsyncStatement: function AD_getAsyncStatement(aKey) {
81454:     if (aKey in this.asyncStatementsCache)
81454:       return this.asyncStatementsCache[aKey];
51520: 
81454:     let sql = this.queries[aKey];
51520:     try {
81454:       return this.asyncStatementsCache[aKey] = this.connection.createAsyncStatement(sql);
51520:     } catch (e) {
77971:       ERROR("Error creating statement " + aKey + " (" + sql + ")");
51520:       throw e;
51520:     }
51520:   },
51520: 
51520:   /**
51520:    * Asynchronously retrieve all add-ons from the database, and pass it
51520:    * to the specified callback
51520:    *
51520:    * @param  aCallback
51520:    *         The callback to pass the add-ons back to
51520:    */
51520:   retrieveStoredData: function AD_retrieveStoredData(aCallback) {
51520:     let self = this;
51520:     let addons = {};
51520: 
51520:     // Retrieve all data from the addon table
51520:     function getAllAddons() {
81454:       self.getAsyncStatement("getAllAddons").executeAsync({
51520:         handleResult: function(aResults) {
51520:           let row = null;
51520:           while (row = aResults.getNextRow()) {
51520:             let internal_id = row.getResultByName("internal_id");
51520:             addons[internal_id] = self._makeAddonFromAsyncRow(row);
51520:           }
51520:         },
51520: 
51520:         handleError: self.asyncErrorLogger,
51520: 
51520:         handleCompletion: function(aReason) {
51520:           if (aReason != Ci.mozIStorageStatementCallback.REASON_FINISHED) {
51520:             ERROR("Error retrieving add-ons from database. Returning empty results");
51520:             aCallback({});
51520:             return;
51520:           }
51520: 
51520:           getAllDevelopers();
51520:         }
51520:       });
51520:     }
51520: 
51520:     // Retrieve all data from the developer table
51520:     function getAllDevelopers() {
81454:       self.getAsyncStatement("getAllDevelopers").executeAsync({
51520:         handleResult: function(aResults) {
51520:           let row = null;
51520:           while (row = aResults.getNextRow()) {
51520:             let addon_internal_id = row.getResultByName("addon_internal_id");
51520:             if (!(addon_internal_id in addons)) {
51520:               WARN("Found a developer not linked to an add-on in database");
51520:               continue;
51520:             }
51520: 
51520:             let addon = addons[addon_internal_id];
51520:             if (!addon.developers)
51520:               addon.developers = [];
51520: 
51520:             addon.developers.push(self._makeDeveloperFromAsyncRow(row));
51520:           }
51520:         },
51520: 
51520:         handleError: self.asyncErrorLogger,
51520: 
51520:         handleCompletion: function(aReason) {
51520:           if (aReason != Ci.mozIStorageStatementCallback.REASON_FINISHED) {
51520:             ERROR("Error retrieving developers from database. Returning empty results");
51520:             aCallback({});
51520:             return;
51520:           }
51520: 
51520:           getAllScreenshots();
51520:         }
51520:       });
51520:     }
51520: 
51520:     // Retrieve all data from the screenshot table
51520:     function getAllScreenshots() {
81454:       self.getAsyncStatement("getAllScreenshots").executeAsync({
51520:         handleResult: function(aResults) {
51520:           let row = null;
51520:           while (row = aResults.getNextRow()) {
51520:             let addon_internal_id = row.getResultByName("addon_internal_id");
51520:             if (!(addon_internal_id in addons)) {
51520:               WARN("Found a screenshot not linked to an add-on in database");
51520:               continue;
51520:             }
51520: 
51520:             let addon = addons[addon_internal_id];
51520:             if (!addon.screenshots)
51520:               addon.screenshots = [];
51520:             addon.screenshots.push(self._makeScreenshotFromAsyncRow(row));
51520:           }
51520:         },
51520: 
51520:         handleError: self.asyncErrorLogger,
51520: 
51520:         handleCompletion: function(aReason) {
51520:           if (aReason != Ci.mozIStorageStatementCallback.REASON_FINISHED) {
51520:             ERROR("Error retrieving screenshots from database. Returning empty results");
51520:             aCallback({});
51520:             return;
51520:           }
51520: 
83133:           getAllCompatOverrides();
83133:         }
83133:       });
83133:     }
83133: 
83133:     function getAllCompatOverrides() {
83133:       self.getAsyncStatement("getAllCompatOverrides").executeAsync({
83133:         handleResult: function(aResults) {
83133:           let row = null;
83133:           while (row = aResults.getNextRow()) {
83133:             let addon_internal_id = row.getResultByName("addon_internal_id");
83133:             if (!(addon_internal_id in addons)) {
83133:               WARN("Found a compatibility override not linked to an add-on in database");
83133:               continue;
83133:             }
83133: 
83133:             let addon = addons[addon_internal_id];
83133:             if (!addon.compatibilityOverrides)
83133:               addon.compatibilityOverrides = [];
83133:             addon.compatibilityOverrides.push(self._makeCompatOverrideFromAsyncRow(row));
83133:           }
83133:         },
83133: 
83133:         handleError: self.asyncErrorLogger,
83133: 
83133:         handleCompletion: function(aReason) {
83133:           if (aReason != Ci.mozIStorageStatementCallback.REASON_FINISHED) {
83133:             ERROR("Error retrieving compatibility overrides from database. Returning empty results");
83133:             aCallback({});
83133:             return;
83133:           }
83133: 
51520:           let returnedAddons = {};
74689:           for each (let addon in addons)
51520:             returnedAddons[addon.id] = addon;
51520:           aCallback(returnedAddons);
51520:         }
51520:       });
51520:     }
51520: 
51520:     // Begin asynchronous process
51520:     getAllAddons();
51520:   },
51520: 
51520:   /**
51520:    * Asynchronously repopulates the database so it only contains the
51520:    * specified add-ons
51520:    *
51520:    * @param  aAddons
51520:    *         The array of add-ons to repopulate the database with
51520:    * @param  aCallback
51520:    *         An optional callback to call once complete
51520:    */
51520:   repopulate: function AD_repopulate(aAddons, aCallback) {
51520:     let self = this;
51520: 
51520:     // Completely empty the database
81454:     let stmts = [this.getAsyncStatement("emptyAddon")];
51520: 
51520:     this.connection.executeAsync(stmts, stmts.length, {
51520:       handleResult: function() {},
51520:       handleError: self.asyncErrorLogger,
51520: 
51520:       handleCompletion: function(aReason) {
51520:         if (aReason != Ci.mozIStorageStatementCallback.REASON_FINISHED)
51520:           ERROR("Error emptying database. Attempting to continue repopulating database");
51520: 
51520:         // Insert the specified add-ons
51520:         self.insertAddons(aAddons, aCallback);
51520:       }
51520:     });
51520:   },
51520: 
51520:   /**
51520:    * Asynchronously inserts an array of add-ons into the database
51520:    *
51520:    * @param  aAddons
51520:    *         The array of add-ons to insert
51520:    * @param  aCallback
51520:    *         An optional callback to call once complete
51520:    */
51520:   insertAddons: function AD_insertAddons(aAddons, aCallback) {
51520:     let self = this;
51520:     let currentAddon = -1;
51520: 
51520:     // Chain insertions
51520:     function insertNextAddon() {
51520:       if (++currentAddon == aAddons.length) {
51520:         if (aCallback)
51520:           aCallback();
51520:         return;
51520:       }
51520: 
51520:       self._insertAddon(aAddons[currentAddon], insertNextAddon);
51520:     }
51520: 
51520:     insertNextAddon();
51520:   },
51520: 
51520:   /**
51520:    * Inserts an individual add-on into the database. If the add-on already
51520:    * exists in the database (by id), then the specified add-on will not be
51520:    * inserted.
51520:    *
51520:    * @param  aAddon
51520:    *         The add-on to insert into the database
51520:    * @param  aCallback
51520:    *         The callback to call once complete
51520:    */
51520:   _insertAddon: function AD__insertAddon(aAddon, aCallback) {
51520:     let self = this;
51520:     let internal_id = null;
51520:     this.connection.beginTransaction();
51520: 
83133:     // Simultaneously insert the developers, screenshots, and compatibility
83133:     // overrides of the add-on.
83133:     function insertAdditionalData() {
51520:       let stmts = [];
51520: 
51520:       // Initialize statement and parameters for inserting an array
51520:       function initializeArrayInsert(aStatementKey, aArray, aAddParams) {
51520:         if (!aArray || aArray.length == 0)
51520:           return;
51520: 
81454:         let stmt = self.getAsyncStatement(aStatementKey);
51520:         let params = stmt.newBindingParamsArray();
51520:         aArray.forEach(function(aElement, aIndex) {
51520:           aAddParams(params, internal_id, aElement, aIndex);
51520:         });
51520: 
51520:         stmt.bindParameters(params);
51520:         stmts.push(stmt);
51520:       }
51520: 
83133:       // Initialize statements to insert developers, screenshots, and
83133:       // compatibility overrides
51520:       initializeArrayInsert("insertDeveloper", aAddon.developers,
51520:                             self._addDeveloperParams);
51520:       initializeArrayInsert("insertScreenshot", aAddon.screenshots,
51520:                             self._addScreenshotParams);
83133:       initializeArrayInsert("insertCompatibilityOverride",
83133:                             aAddon.compatibilityOverrides,
83133:                             self._addCompatOverrideParams);
51520: 
51520:       // Immediately call callback if nothing to insert
51520:       if (stmts.length == 0) {
51520:         self.connection.commitTransaction();
51520:         aCallback();
51520:         return;
51520:       }
51520: 
51520:       self.connection.executeAsync(stmts, stmts.length, {
51520:         handleResult: function() {},
51520:         handleError: self.asyncErrorLogger,
51520:         handleCompletion: function(aReason) {
51520:           if (aReason != Ci.mozIStorageStatementCallback.REASON_FINISHED) {
83133:             ERROR("Error inserting additional addon metadata into database. Attempting to continue");
51520:             self.connection.rollbackTransaction();
51520:           }
51520:           else {
51520:             self.connection.commitTransaction();
51520:           }
51520: 
51520:           aCallback();
51520:         }
51520:       });
51520:     }
51520: 
51520:     // Insert add-on into database
51520:     this._makeAddonStatement(aAddon).executeAsync({
51520:       handleResult: function() {},
51520:       handleError: self.asyncErrorLogger,
51520: 
51520:       handleCompletion: function(aReason) {
51520:         if (aReason != Ci.mozIStorageStatementCallback.REASON_FINISHED) {
51520:           ERROR("Error inserting add-ons into database. Attempting to continue.");
51520:           self.connection.rollbackTransaction();
51520:           aCallback();
51520:           return;
51520:         }
51520: 
51520:         internal_id = self.connection.lastInsertRowID;
83133:         insertAdditionalData();
51520:       }
51520:     });
51520:   },
51520: 
51520:   /**
51520:    * Make an asynchronous statement that will insert the specified add-on
51520:    *
51520:    * @param  aAddon
51520:    *         The add-on to make the statement for
51520:    * @return The asynchronous mozIStorageStatement
51520:    */
51520:   _makeAddonStatement: function AD__makeAddonStatement(aAddon) {
81454:     let stmt = this.getAsyncStatement("insertAddon");
51520:     let params = stmt.params;
51520: 
51520:     PROP_SINGLE.forEach(function(aProperty) {
51520:       switch (aProperty) {
51520:         case "sourceURI":
51520:           params.sourceURI = aAddon.sourceURI ? aAddon.sourceURI.spec : null;
51520:           break;
51520:         case "creator":
51520:           params.creator =  aAddon.creator ? aAddon.creator.name : null;
51520:           params.creatorURL =  aAddon.creator ? aAddon.creator.url : null;
51520:           break;
51520:         case "updateDate":
51520:           params.updateDate = aAddon.updateDate ? aAddon.updateDate.getTime() : null;
51520:           break;
51520:         default:
51520:           params[aProperty] = aAddon[aProperty];
51520:       }
51520:     });
51520: 
51520:     return stmt;
51520:   },
51520: 
51520:   /**
51520:    * Add developer parameters to the specified mozIStorageBindingParamsArray
51520:    *
51520:    * @param  aParams
51520:    *         The mozIStorageBindingParamsArray to add the parameters to
51520:    * @param  aInternalID
51520:    *         The internal_id of the add-on that this developer is for
51520:    * @param  aDeveloper
51520:    *         The developer to make the parameters from
51520:    * @param  aIndex
51520:    *         The index of this developer
51520:    * @return The asynchronous mozIStorageStatement
51520:    */
51520:   _addDeveloperParams: function AD__addDeveloperParams(aParams, aInternalID,
51520:                                                        aDeveloper, aIndex) {
51520:     let bp = aParams.newBindingParams();
51520:     bp.bindByName("addon_internal_id", aInternalID);
51520:     bp.bindByName("num", aIndex);
51520:     bp.bindByName("name", aDeveloper.name);
51520:     bp.bindByName("url", aDeveloper.url);
51520:     aParams.addParams(bp);
51520:   },
51520: 
51520:   /**
51520:    * Add screenshot parameters to the specified mozIStorageBindingParamsArray
51520:    *
51520:    * @param  aParams
51520:    *         The mozIStorageBindingParamsArray to add the parameters to
51520:    * @param  aInternalID
51520:    *         The internal_id of the add-on that this screenshot is for
51520:    * @param  aScreenshot
51520:    *         The screenshot to make the parameters from
51520:    * @param  aIndex
51520:    *         The index of this screenshot
51520:    */
51520:   _addScreenshotParams: function AD__addScreenshotParams(aParams, aInternalID,
51520:                                                          aScreenshot, aIndex) {
51520:     let bp = aParams.newBindingParams();
51520:     bp.bindByName("addon_internal_id", aInternalID);
51520:     bp.bindByName("num", aIndex);
51520:     bp.bindByName("url", aScreenshot.url);
77865:     bp.bindByName("width", aScreenshot.width);
77865:     bp.bindByName("height", aScreenshot.height);
51520:     bp.bindByName("thumbnailURL", aScreenshot.thumbnailURL);
77865:     bp.bindByName("thumbnailWidth", aScreenshot.thumbnailWidth);
77865:     bp.bindByName("thumbnailHeight", aScreenshot.thumbnailHeight);
51520:     bp.bindByName("caption", aScreenshot.caption);
51520:     aParams.addParams(bp);
51520:   },
51520: 
51520:   /**
83133:    * Add compatibility override parameters to the specified
83133:    * mozIStorageBindingParamsArray.
83133:    *
83133:    * @param  aParams
83133:    *         The mozIStorageBindingParamsArray to add the parameters to
83133:    * @param  aInternalID
83133:    *         The internal_id of the add-on that this override is for
83133:    * @param  aOverride
83133:    *         The override to make the parameters from
83133:    * @param  aIndex
83133:    *         The index of this override
83133:    */
83133:   _addCompatOverrideParams: function AD_addCompatOverrideParams(aParams,
83133:                                                                 aInternalID,
83133:                                                                 aOverride,
83133:                                                                 aIndex) {
83133:     let bp = aParams.newBindingParams();
83133:     bp.bindByName("addon_internal_id", aInternalID);
83133:     bp.bindByName("num", aIndex);
83133:     bp.bindByName("type", aOverride.type);
83133:     bp.bindByName("minVersion", aOverride.minVersion);
83133:     bp.bindByName("maxVersion", aOverride.maxVersion);
83133:     bp.bindByName("appID", aOverride.appID);
83133:     bp.bindByName("appMinVersion", aOverride.appMinVersion);
83133:     bp.bindByName("appMaxVersion", aOverride.appMaxVersion);
83133:     aParams.addParams(bp);
83133:   },
83133: 
83133:   /**
51520:    * Make add-on from an asynchronous row
51520:    * Note: This add-on will be lacking both developers and screenshots
51520:    *
51520:    * @param  aRow
51520:    *         The asynchronous row to use
51520:    * @return The created add-on
51520:    */
51520:   _makeAddonFromAsyncRow: function AD__makeAddonFromAsyncRow(aRow) {
51520:     let addon = {};
51520: 
51520:     PROP_SINGLE.forEach(function(aProperty) {
51520:       let value = aRow.getResultByName(aProperty);
51520: 
51520:       switch (aProperty) {
51520:         case "sourceURI":
51520:           addon.sourceURI = value ? NetUtil.newURI(value) : null;
51520:           break;
51520:         case "creator":
51520:           let creatorURL = aRow.getResultByName("creatorURL");
51520:           if (value || creatorURL)
51520:             addon.creator = new AddonManagerPrivate.AddonAuthor(value, creatorURL);
51520:           else
51520:             addon.creator = null;
51520:           break;
51520:         case "updateDate":
51520:           addon.updateDate = value ? new Date(value) : null;
51520:           break;
51520:         default:
51520:           addon[aProperty] = value;
51520:       }
51520:     });
51520: 
51520:     return addon;
51520:   },
51520: 
51520:   /**
51520:    * Make a developer from an asynchronous row
51520:    *
51520:    * @param  aRow
51520:    *         The asynchronous row to use
51520:    * @return The created developer
51520:    */
51520:   _makeDeveloperFromAsyncRow: function AD__makeDeveloperFromAsyncRow(aRow) {
51520:     let name = aRow.getResultByName("name");
51520:     let url = aRow.getResultByName("url")
51520:     return new AddonManagerPrivate.AddonAuthor(name, url);
51520:   },
51520: 
51520:   /**
51520:    * Make a screenshot from an asynchronous row
51520:    *
51520:    * @param  aRow
51520:    *         The asynchronous row to use
51520:    * @return The created screenshot
51520:    */
51520:   _makeScreenshotFromAsyncRow: function AD__makeScreenshotFromAsyncRow(aRow) {
51520:     let url = aRow.getResultByName("url");
77865:     let width = aRow.getResultByName("width");
77865:     let height = aRow.getResultByName("height");
51520:     let thumbnailURL = aRow.getResultByName("thumbnailURL");
77865:     let thumbnailWidth = aRow.getResultByName("thumbnailWidth");
77865:     let thumbnailHeight = aRow.getResultByName("thumbnailHeight");
51520:     let caption = aRow.getResultByName("caption");
77865:     return new AddonManagerPrivate.AddonScreenshot(url, width, height, thumbnailURL,
77865:                                                    thumbnailWidth, thumbnailHeight, caption);
51520:   },
51520: 
51520:   /**
83133:    * Make a CompatibilityOverride from an asynchronous row
83133:    *
83133:    * @param  aRow
83133:    *         The asynchronous row to use
83133:    * @return The created CompatibilityOverride
83133:    */
83133:   _makeCompatOverrideFromAsyncRow: function AD_makeCompatOverrideFromAsyncRow(aRow) {
83133:     let type = aRow.getResultByName("type");
83133:     let minVersion = aRow.getResultByName("minVersion");
83133:     let maxVersion = aRow.getResultByName("maxVersion");
83133:     let appID = aRow.getResultByName("appID");
83133:     let appMinVersion = aRow.getResultByName("appMinVersion");
83133:     let appMaxVersion = aRow.getResultByName("appMaxVersion");
83133:     return new AddonManagerPrivate.AddonCompatibilityOverride(type,
83133:                                                               minVersion,
83133:                                                               maxVersion,
83133:                                                               appID,
83133:                                                               appMinVersion,
83133:                                                               appMaxVersion);
83133:   },
83133: 
83133:   /**
51520:    * Synchronously creates the schema in the database.
51520:    */
51520:   _createSchema: function AD__createSchema() {
51520:     LOG("Creating database schema");
51520:     this.connection.beginTransaction();
51520: 
51520:     // Any errors in here should rollback
51520:     try {
51520:       this.connection.createTable("addon",
51520:                                   "internal_id INTEGER PRIMARY KEY AUTOINCREMENT, " +
51520:                                   "id TEXT UNIQUE, " +
51520:                                   "type TEXT, " +
51520:                                   "name TEXT, " +
51520:                                   "version TEXT, " +
51520:                                   "creator TEXT, " +
51520:                                   "creatorURL TEXT, " +
51520:                                   "description TEXT, " +
51520:                                   "fullDescription TEXT, " +
51520:                                   "developerComments TEXT, " +
51520:                                   "eula TEXT, " +
51520:                                   "iconURL TEXT, " +
51520:                                   "homepageURL TEXT, " +
51520:                                   "supportURL TEXT, " +
51520:                                   "contributionURL TEXT, " +
51520:                                   "contributionAmount TEXT, " +
51520:                                   "averageRating INTEGER, " +
51520:                                   "reviewCount INTEGER, " +
51520:                                   "reviewURL TEXT, " +
51520:                                   "totalDownloads INTEGER, " +
51520:                                   "weeklyDownloads INTEGER, " +
51520:                                   "dailyUsers INTEGER, " +
51520:                                   "sourceURI TEXT, " +
51520:                                   "repositoryStatus INTEGER, " +
51520:                                   "size INTEGER, " +
51520:                                   "updateDate INTEGER");
51520: 
51520:       this.connection.createTable("developer",
51520:                                   "addon_internal_id INTEGER, " +
51520:                                   "num INTEGER, " +
51520:                                   "name TEXT, " +
51520:                                   "url TEXT, " +
51520:                                   "PRIMARY KEY (addon_internal_id, num)");
51520: 
51520:       this.connection.createTable("screenshot",
51520:                                   "addon_internal_id INTEGER, " +
51520:                                   "num INTEGER, " +
51520:                                   "url TEXT, " +
77865:                                   "width INTEGER, " +
77865:                                   "height INTEGER, " +
51520:                                   "thumbnailURL TEXT, " +
77865:                                   "thumbnailWidth INTEGER, " +
77865:                                   "thumbnailHeight INTEGER, " +
51520:                                   "caption TEXT, " +
51520:                                   "PRIMARY KEY (addon_internal_id, num)");
51520: 
83133:       this.connection.createTable("compatibility_override",
83133:                                   "addon_internal_id INTEGER, " +
83133:                                   "num INTEGER, " +
83133:                                   "type TEXT, " +
83133:                                   "minVersion TEXT, " +
83133:                                   "maxVersion TEXT, " +
83133:                                   "appID TEXT, " +
83133:                                   "appMinVersion TEXT, " +
83133:                                   "appMaxVersion TEXT, " +
83133:                                   "PRIMARY KEY (addon_internal_id, num)");
83133: 
77865:       this._createIndices();
83133:       this._createTriggers();
51520: 
51520:       this.connection.schemaVersion = DB_SCHEMA;
51520:       this.connection.commitTransaction();
51520:     } catch (e) {
57401:       ERROR("Failed to create database schema", e);
51520:       this.logSQLError(this.connection.lastError, this.connection.lastErrorString);
51520:       this.connection.rollbackTransaction();
51520:       throw e;
51520:     }
77865:   },
77865: 
77865:   /**
83133:    * Synchronously creates the triggers in the database.
83133:    */
83133:   _createTriggers: function AD__createTriggers() {
83133:     this.connection.executeSimpleSQL("DROP TRIGGER IF EXISTS delete_addon");
83133:     this.connection.executeSimpleSQL("CREATE TRIGGER delete_addon AFTER DELETE " +
83133:       "ON addon BEGIN " +
83133:       "DELETE FROM developer WHERE addon_internal_id=old.internal_id; " +
83133:       "DELETE FROM screenshot WHERE addon_internal_id=old.internal_id; " +
83133:       "DELETE FROM compatibility_override WHERE addon_internal_id=old.internal_id; " +
83133:       "END");
83133:   },
83133: 
83133:   /**
77865:    * Synchronously creates the indices in the database.
77865:    */
77865:   _createIndices: function AD__createIndices() {
77865:       this.connection.executeSimpleSQL("CREATE INDEX IF NOT EXISTS developer_idx " +
77865:                                        "ON developer (addon_internal_id)");
77865:       this.connection.executeSimpleSQL("CREATE INDEX IF NOT EXISTS screenshot_idx " +
77865:                                        "ON screenshot (addon_internal_id)");
83133:       this.connection.executeSimpleSQL("CREATE INDEX IF NOT EXISTS compatibility_override_idx " +
83133:                                        "ON compatibility_override (addon_internal_id)");
51520:   }
51520: };
