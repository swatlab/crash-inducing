15610: /* -*- Mode: C; tab-width: 8; c-basic-offset: 8 -*- */
15610: /* vim:set softtabstop=8 shiftwidth=8: */
11286: /*-
11286:  * Copyright (C) 2006-2008 Jason Evans <jasone@FreeBSD.org>.
11286:  * All rights reserved.
11286:  *
11286:  * Redistribution and use in source and binary forms, with or without
11286:  * modification, are permitted provided that the following conditions
11286:  * are met:
11286:  * 1. Redistributions of source code must retain the above copyright
11286:  *    notice(s), this list of conditions and the following disclaimer as
11286:  *    the first lines of this file unmodified other than the possible
11286:  *    addition of one or more copyright notices.
11286:  * 2. Redistributions in binary form must reproduce the above copyright
11286:  *    notice(s), this list of conditions and the following disclaimer in
11286:  *    the documentation and/or other materials provided with the
11286:  *    distribution.
11286:  *
11286:  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY
11286:  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
11286:  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
11286:  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE
11286:  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
11286:  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
11286:  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
11286:  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
11286:  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
11286:  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
11286:  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
11286:  *
11286:  *******************************************************************************
11286:  *
11286:  * This allocator implementation is designed to provide scalable performance
11286:  * for multi-threaded programs on multi-processor systems.  The following
11286:  * features are included for this purpose:
11286:  *
11286:  *   + Multiple arenas are used if there are multiple CPUs, which reduces lock
11286:  *     contention and cache sloshing.
11286:  *
11286:  *   + Cache line sharing between arenas is avoided for internal data
11286:  *     structures.
11286:  *
11286:  *   + Memory is managed in chunks and runs (chunks can be split into runs),
11286:  *     rather than as individual pages.  This provides a constant-time
11286:  *     mechanism for associating allocations with particular arenas.
11286:  *
11286:  * Allocation requests are rounded up to the nearest size class, and no record
11286:  * of the original request size is maintained.  Allocations are broken into
11286:  * categories according to size class.  Assuming runtime defaults, 4 kB pages
15460:  * and a 16 byte quantum on a 32-bit system, the size classes in each category
15460:  * are as follows:
11286:  *
11286:  *   |=====================================|
11286:  *   | Category | Subcategory    |    Size |
11286:  *   |=====================================|
11286:  *   | Small    | Tiny           |       2 |
11286:  *   |          |                |       4 |
11286:  *   |          |                |       8 |
11286:  *   |          |----------------+---------|
11286:  *   |          | Quantum-spaced |      16 |
11286:  *   |          |                |      32 |
11286:  *   |          |                |      48 |
11286:  *   |          |                |     ... |
11286:  *   |          |                |     480 |
11286:  *   |          |                |     496 |
11286:  *   |          |                |     512 |
11286:  *   |          |----------------+---------|
11286:  *   |          | Sub-page       |    1 kB |
11286:  *   |          |                |    2 kB |
11286:  *   |=====================================|
11286:  *   | Large                     |    4 kB |
11286:  *   |                           |    8 kB |
11286:  *   |                           |   12 kB |
11286:  *   |                           |     ... |
11286:  *   |                           | 1012 kB |
11286:  *   |                           | 1016 kB |
16218:  *   |                           | 1020 kB |
11286:  *   |=====================================|
11286:  *   | Huge                      |    1 MB |
11286:  *   |                           |    2 MB |
11286:  *   |                           |    3 MB |
11286:  *   |                           |     ... |
11286:  *   |=====================================|
11286:  *
11286:  * A different mechanism is used for each category:
11286:  *
11286:  *   Small : Each size class is segregated into its own set of runs.  Each run
11286:  *           maintains a bitmap of which regions are free/allocated.
11286:  *
11286:  *   Large : Each allocation is backed by a dedicated run.  Metadata are stored
11286:  *           in the associated arena chunk header maps.
11286:  *
11286:  *   Huge : Each allocation is backed by a dedicated contiguous set of chunks.
11286:  *          Metadata are stored in a separate red-black tree.
11286:  *
11286:  *******************************************************************************
11286:  */
11286: 
11286: /*
11286:  * MALLOC_PRODUCTION disables assertions and statistics gathering.  It also
11286:  * defaults the A and J runtime options to off.  These settings are appropriate
11286:  * for production systems.
11286:  */
11286: #ifndef MOZ_MEMORY_DEBUG
11286: #  define	MALLOC_PRODUCTION
11286: #endif
11286: 
15458: /*
15462:  * Use only one arena by default.  Mozilla does not currently make extensive
15462:  * use of concurrent allocation, so the increased fragmentation associated with
15462:  * multiple arenas is not warranted.
15462:  */
15462: #define	MOZ_MEMORY_NARENAS_DEFAULT_ONE
15462: 
15462: /*
15458:  * MALLOC_STATS enables statistics calculation, and is required for
15458:  * jemalloc_stats().
15458:  */
15458: #define MALLOC_STATS
15458: 
11286: #ifndef MALLOC_PRODUCTION
11286:    /*
11286:     * MALLOC_DEBUG enables assertions and other sanity checks, and disables
11286:     * inline functions.
11286:     */
11286: #  define MALLOC_DEBUG
11286: 
11449:    /* Memory filling (junk/zero). */
11449: #  define MALLOC_FILL
11449: 
11449:    /* Allocation tracing. */
16217: #  ifndef MOZ_MEMORY_WINDOWS
11449: #    define MALLOC_UTRACE
16217: #  endif
11449: 
11449:    /* Support optional abort() on OOM. */
11449: #  define MALLOC_XMALLOC
11449: 
11449:    /* Support SYSV semantics. */
11449: #  define MALLOC_SYSV
11286: #endif
11286: 
14259: /*
14259:  * MALLOC_VALIDATE causes malloc_usable_size() to perform some pointer
14259:  * validation.  There are many possible errors that validation does not even
14259:  * attempt to detect.
14259:  */
14259: #define MALLOC_VALIDATE
14259: 
14033: /* Embed no-op macros that support memory allocation tracking via valgrind. */
14033: #ifdef MOZ_VALGRIND
14033: #  define MALLOC_VALGRIND
14033: #endif
14033: #ifdef MALLOC_VALGRIND
14033: #  include <valgrind/valgrind.h>
14033: #else
14033: #  define VALGRIND_MALLOCLIKE_BLOCK(addr, sizeB, rzB, is_zeroed)
14033: #  define VALGRIND_FREELIKE_BLOCK(addr, rzB)
14033: #endif
11286: 
11286: /*
11286:  * MALLOC_BALANCE enables monitoring of arena lock contention and dynamically
11286:  * re-balances arena load if exponentially averaged contention exceeds a
11286:  * certain threshold.
11286:  */
11286: /* #define	MALLOC_BALANCE */
11286: 
15610: #if (!defined(MOZ_MEMORY_WINDOWS) && !defined(MOZ_MEMORY_DARWIN))
15610:    /*
15610:     * MALLOC_PAGEFILE causes all mmap()ed memory to be backed by temporary
15610:     * files, so that if a chunk is mapped, it is guaranteed to be swappable.
15610:     * This avoids asynchronous OOM failures that are due to VM over-commit.
15027:     *
15610:     * XXX OS X over-commits, so we should probably use mmap() instead of
15610:     * vm_allocate(), so that MALLOC_PAGEFILE works.
15610:     */
22569: #define MALLOC_PAGEFILE
15610: #endif
15610: 
15610: #ifdef MALLOC_PAGEFILE
15610: /* Write size when initializing a page file. */
15610: #  define MALLOC_PAGEFILE_WRITE_SIZE 512
15610: #endif
11286: 
11449: #ifdef MOZ_MEMORY_LINUX
11449: #define	_GNU_SOURCE /* For mremap(2). */
11449: #define	issetugid() 0
11449: #if 0 /* Enable in order to test decommit code on Linux. */
11449: #  define MALLOC_DECOMMIT
11449: #endif
11449: #endif
11449: 
26488: #ifndef MOZ_MEMORY_WINCE
11286: #include <sys/types.h>
11286: 
11286: #include <errno.h>
26488: #include <stdlib.h>
26488: #endif
11286: #include <limits.h>
11286: #include <stdarg.h>
11286: #include <stdio.h>
11286: #include <string.h>
11286: 
11286: #ifdef MOZ_MEMORY_WINDOWS
26488: #ifndef MOZ_MEMORY_WINCE
11286: #include <cruntime.h>
11286: #include <internal.h>
26488: #include <io.h>
26488: #else
27812: #include <cmnintrin.h>
26488: #include <crtdefs.h>
26488: #define SIZE_MAX UINT_MAX
26488: #endif
11286: #include <windows.h>
11286: 
11286: #pragma warning( disable: 4267 4996 4146 )
11286: 
34477: #define	bool BOOL
11286: #define	false FALSE
11286: #define	true TRUE
11286: #define	inline __inline
11449: #define	SIZE_T_MAX SIZE_MAX
11286: #define	STDERR_FILENO 2
11286: #define	PATH_MAX MAX_PATH
11286: #define	vsnprintf _vsnprintf
11286: 
26488: #ifndef NO_TLS
11286: static unsigned long tlsIndex = 0xffffffff;
26488: #endif 
11286: 
11286: #define	__thread
26488: #ifdef MOZ_MEMORY_WINCE
26488: #define	_pthread_self() GetCurrentThreadId()
26488: #else
11286: #define	_pthread_self() __threadid()
26488: #endif
11286: #define	issetugid() 0
11286: 
26488: #ifndef MOZ_MEMORY_WINCE
11286: /* use MSVC intrinsics */
11286: #pragma intrinsic(_BitScanForward)
11286: static __forceinline int
11286: ffs(int x)
11286: {
11286: 	unsigned long i;
11286: 
11286: 	if (_BitScanForward(&i, x) != 0)
11286: 		return (i + 1);
11286: 
11286: 	return (0);
11286: }
11286: 
11286: /* Implement getenv without using malloc */
11286: static char mozillaMallocOptionsBuf[64];
11286: 
11286: #define	getenv xgetenv
11286: static char *
11286: getenv(const char *name)
11286: {
11286: 
11286: 	if (GetEnvironmentVariableA(name, (LPSTR)&mozillaMallocOptionsBuf,
11286: 		    sizeof(mozillaMallocOptionsBuf)) > 0)
11286: 		return (mozillaMallocOptionsBuf);
11286: 
11286: 	return (NULL);
11286: }
27812: 
27812: #else /* WIN CE */
27812: 
26488: #define ENOMEM          12
26488: #define EINVAL          22
26488: 
27812: static __forceinline int
26488: ffs(int x)
26488: {
27812: 
27812: 	return 32 - _CountLeadingZeros((-x) & x);
26488: }
26488: #endif
11286: 
11449: typedef unsigned char uint8_t;
11286: typedef unsigned uint32_t;
11286: typedef unsigned long long uint64_t;
11286: typedef unsigned long long uintmax_t;
15460: typedef long ssize_t;
11286: 
11286: #define	MALLOC_DECOMMIT
11286: #endif
11286: 
11286: #ifndef MOZ_MEMORY_WINDOWS
14800: #ifndef MOZ_MEMORY_SOLARIS
11286: #include <sys/cdefs.h>
14800: #endif
11286: #ifndef __DECONST
11286: #  define __DECONST(type, var)	((type)(uintptr_t)(const void *)(var))
11286: #endif
11286: #ifndef MOZ_MEMORY
16218: __FBSDID("$FreeBSD: head/lib/libc/stdlib/malloc.c 180599 2008-07-18 19:35:44Z jasone $");
11286: #include "libc_private.h"
11286: #ifdef MALLOC_DEBUG
11286: #  define _LOCK_DEBUG
11286: #endif
11286: #include "spinlock.h"
11286: #include "namespace.h"
11286: #endif
11286: #include <sys/mman.h>
11286: #ifndef MADV_FREE
11286: #  define MADV_FREE	MADV_DONTNEED
11286: #endif
15610: #ifndef MAP_NOSYNC
15610: #  define MAP_NOSYNC	0
15610: #endif
11286: #include <sys/param.h>
11286: #ifndef MOZ_MEMORY
11286: #include <sys/stddef.h>
11286: #endif
11286: #include <sys/time.h>
11286: #include <sys/types.h>
14800: #ifndef MOZ_MEMORY_SOLARIS
11286: #include <sys/sysctl.h>
14800: #endif
11286: #include <sys/uio.h>
11286: #ifndef MOZ_MEMORY
11286: #include <sys/ktrace.h> /* Must come after several other sys/ includes. */
11286: 
11286: #include <machine/atomic.h>
11286: #include <machine/cpufunc.h>
11286: #include <machine/vmparam.h>
11286: #endif
11286: 
11286: #include <errno.h>
11286: #include <limits.h>
11286: #ifndef SIZE_T_MAX
11449: #  define SIZE_T_MAX	SIZE_MAX
11286: #endif
11286: #include <pthread.h>
11286: #ifdef MOZ_MEMORY_DARWIN
11286: #define _pthread_self pthread_self
11286: #define _pthread_mutex_init pthread_mutex_init
11286: #define _pthread_mutex_trylock pthread_mutex_trylock
11286: #define _pthread_mutex_lock pthread_mutex_lock
11286: #define _pthread_mutex_unlock pthread_mutex_unlock
11286: #endif
11286: #include <sched.h>
11286: #include <stdarg.h>
34477: #include <stdio.h>
11286: #include <stdbool.h>
11286: #include <stdint.h>
11286: #include <stdlib.h>
11286: #include <string.h>
11286: #ifndef MOZ_MEMORY_DARWIN
11286: #include <strings.h>
11286: #endif
11286: #include <unistd.h>
11286: 
11286: #ifdef MOZ_MEMORY_DARWIN
11286: #include <libkern/OSAtomic.h>
11286: #include <mach/mach_error.h>
11286: #include <mach/mach_init.h>
11286: #include <mach/vm_map.h>
11286: #include <malloc/malloc.h>
11286: #endif
11286: 
11286: #ifndef MOZ_MEMORY
11286: #include "un-namespace.h"
11286: #endif
11286: 
11286: #endif
11286: 
15458: #include "jemalloc.h"
15458: 
11286: #ifdef MOZ_MEMORY_DARWIN
11286: static const bool __isthreaded = true;
11286: #endif
11286: 
24522: #if defined(MOZ_MEMORY_SOLARIS) && defined(MAP_ALIGN) && !defined(JEMALLOC_NEVER_USES_MAP_ALIGN)
24522: #define JEMALLOC_USES_MAP_ALIGN	 /* Required on Solaris 10. Might improve performance elsewhere. */
24522: #endif
24522: 
27812: #if defined(MOZ_MEMORY_WINCE) && !defined(MOZ_MEMORY_WINCE6)
27812: #define JEMALLOC_USES_MAP_ALIGN	 /* Required for Windows CE < 6 */
26771: #endif
26771: 
11286: #define __DECONST(type, var) ((type)(uintptr_t)(const void *)(var))
11286: 
15460: #ifdef MOZ_MEMORY_WINDOWS
15460:    /* MSVC++ does not support C99 variable-length arrays. */
15460: #  define RB_NO_C99_VARARRAYS
15460: #endif
15460: #include "rb.h"
15460: 
11286: #ifdef MALLOC_DEBUG
11286:    /* Disable inlining to make debugging easier. */
11286: #ifdef inline
11286: #undef inline
11286: #endif
11286: 
11286: #  define inline
11286: #endif
11286: 
11286: /* Size of stack-allocated buffer passed to strerror_r(). */
11286: #define	STRERROR_BUF		64
11286: 
11286: /* Minimum alignment of allocations is 2^QUANTUM_2POW_MIN bytes. */
11286: #  define QUANTUM_2POW_MIN      4
11286: #ifdef MOZ_MEMORY_SIZEOF_PTR_2POW
11286: #  define SIZEOF_PTR_2POW		MOZ_MEMORY_SIZEOF_PTR_2POW
11286: #else
11286: #  define SIZEOF_PTR_2POW       2
11286: #endif
11286: #define PIC
11286: #ifndef MOZ_MEMORY_DARWIN
11286: static const bool __isthreaded = true;
11286: #else
11286: #  define NO_TLS
11286: #endif
11286: #if 0
11286: #ifdef __i386__
11286: #  define QUANTUM_2POW_MIN	4
11286: #  define SIZEOF_PTR_2POW	2
11286: #  define CPU_SPINWAIT		__asm__ volatile("pause")
11286: #endif
11286: #ifdef __ia64__
11286: #  define QUANTUM_2POW_MIN	4
11286: #  define SIZEOF_PTR_2POW	3
11286: #endif
11286: #ifdef __alpha__
11286: #  define QUANTUM_2POW_MIN	4
11286: #  define SIZEOF_PTR_2POW	3
11286: #  define NO_TLS
11286: #endif
11286: #ifdef __sparc64__
11286: #  define QUANTUM_2POW_MIN	4
11286: #  define SIZEOF_PTR_2POW	3
11286: #  define NO_TLS
11286: #endif
11286: #ifdef __amd64__
11286: #  define QUANTUM_2POW_MIN	4
11286: #  define SIZEOF_PTR_2POW	3
11286: #  define CPU_SPINWAIT		__asm__ volatile("pause")
11286: #endif
11286: #ifdef __arm__
11286: #  define QUANTUM_2POW_MIN	3
11286: #  define SIZEOF_PTR_2POW	2
11286: #  define NO_TLS
11286: #endif
16218: #ifdef __mips__
16218: #  define QUANTUM_2POW_MIN	3
16218: #  define SIZEOF_PTR_2POW	2
16218: #  define NO_TLS
16218: #endif
11286: #ifdef __powerpc__
11286: #  define QUANTUM_2POW_MIN	4
11286: #  define SIZEOF_PTR_2POW	2
11286: #endif
11286: #endif
11286: 
11286: #define	SIZEOF_PTR		(1U << SIZEOF_PTR_2POW)
11286: 
11286: /* sizeof(int) == (1U << SIZEOF_INT_2POW). */
11286: #ifndef SIZEOF_INT_2POW
11286: #  define SIZEOF_INT_2POW	2
11286: #endif
11286: 
11286: /* We can't use TLS in non-PIC programs, since TLS relies on loader magic. */
11286: #if (!defined(PIC) && !defined(NO_TLS))
11286: #  define NO_TLS
11286: #endif
11286: 
11286: #ifdef NO_TLS
11286:    /* MALLOC_BALANCE requires TLS. */
11286: #  ifdef MALLOC_BALANCE
11286: #    undef MALLOC_BALANCE
11286: #  endif
11286: #endif
11286: 
11286: /*
11286:  * Size and alignment of memory chunks that are allocated by the OS's virtual
11286:  * memory system.
11286:  */
27812: #if defined(MOZ_MEMORY_WINCE) && !defined(MOZ_MEMORY_WINCE6)
26488: #define	CHUNK_2POW_DEFAULT	21
26488: #else
11286: #define	CHUNK_2POW_DEFAULT	20
26488: #endif
11449: /* Maximum number of dirty pages per arena. */
15461: #define	DIRTY_MAX_DEFAULT	(1U << 10)
11449: 
11286: /*
11286:  * Maximum size of L1 cache line.  This is used to avoid cache line aliasing,
11286:  * so over-estimates are okay (up to a point), but under-estimates will
11286:  * negatively affect performance.
11286:  */
11286: #define	CACHELINE_2POW		6
11286: #define	CACHELINE		((size_t)(1U << CACHELINE_2POW))
11286: 
11286: /* Smallest size class to support. */
11286: #define	TINY_MIN_2POW		1
11286: 
11286: /*
11286:  * Maximum size class that is a multiple of the quantum, but not (necessarily)
11286:  * a power of 2.  Above this size, allocations are rounded up to the nearest
11286:  * power of 2.
11286:  */
11286: #define	SMALL_MAX_2POW_DEFAULT	9
11286: #define	SMALL_MAX_DEFAULT	(1U << SMALL_MAX_2POW_DEFAULT)
11286: 
11286: /*
11286:  * RUN_MAX_OVRHD indicates maximum desired run header overhead.  Runs are sized
11286:  * as small as possible such that this setting is still honored, without
11286:  * violating other constraints.  The goal is to make runs as small as possible
11286:  * without exceeding a per run external fragmentation threshold.
11286:  *
11286:  * We use binary fixed point math for overhead computations, where the binary
11286:  * point is implicitly RUN_BFP bits to the left.
11286:  *
11286:  * Note that it is possible to set RUN_MAX_OVRHD low enough that it cannot be
11286:  * honored for some/all object sizes, since there is one bit of header overhead
11286:  * per object (plus a constant).  This constraint is relaxed (ignored) for runs
11286:  * that are so small that the per-region overhead is greater than:
11286:  *
11286:  *   (RUN_MAX_OVRHD / (reg_size << (3+RUN_BFP))
11286:  */
11286: #define	RUN_BFP			12
11286: /*                                    \/   Implicit binary fixed point. */
11286: #define	RUN_MAX_OVRHD		0x0000003dU
11286: #define	RUN_MAX_OVRHD_RELAX	0x00001800U
11286: 
16218: /* Put a cap on small object run size.  This overrides RUN_MAX_OVRHD. */
11286: #define	RUN_MAX_SMALL_2POW	15
11286: #define	RUN_MAX_SMALL		(1U << RUN_MAX_SMALL_2POW)
11286: 
11286: /*
11286:  * Hyper-threaded CPUs may need a special instruction inside spin loops in
11286:  * order to yield to another virtual CPU.  If no such instruction is defined
11286:  * above, make CPU_SPINWAIT a no-op.
11286:  */
11286: #ifndef CPU_SPINWAIT
11286: #  define CPU_SPINWAIT
11286: #endif
11286: 
11286: /*
11286:  * Adaptive spinning must eventually switch to blocking, in order to avoid the
11286:  * potential for priority inversion deadlock.  Backing off past a certain point
11286:  * can actually waste time.
11286:  */
11286: #define	SPIN_LIMIT_2POW		11
11286: 
11286: /*
11286:  * Conversion from spinning to blocking is expensive; we use (1U <<
11286:  * BLOCK_COST_2POW) to estimate how many more times costly blocking is than
11286:  * worst-case spinning.
11286:  */
11286: #define	BLOCK_COST_2POW		4
11286: 
11286: #ifdef MALLOC_BALANCE
11286:    /*
11286:     * We use an exponential moving average to track recent lock contention,
11286:     * where the size of the history window is N, and alpha=2/(N+1).
11286:     *
11286:     * Due to integer math rounding, very small values here can cause
11286:     * substantial degradation in accuracy, thus making the moving average decay
11286:     * faster than it would with precise calculation.
11286:     */
11286: #  define BALANCE_ALPHA_INV_2POW	9
11286: 
11286:    /*
11286:     * Threshold value for the exponential moving contention average at which to
11286:     * re-assign a thread.
11286:     */
11286: #  define BALANCE_THRESHOLD_DEFAULT	(1U << (SPIN_LIMIT_2POW-4))
11286: #endif
11286: 
11286: /******************************************************************************/
11286: 
11286: /*
11286:  * Mutexes based on spinlocks.  We can't use normal pthread spinlocks in all
11286:  * places, because they require malloc()ed memory, which causes bootstrapping
11286:  * issues in some cases.
11286:  */
11286: #if defined(MOZ_MEMORY_WINDOWS)
11286: #define malloc_mutex_t CRITICAL_SECTION
11286: #define malloc_spinlock_t CRITICAL_SECTION
11286: #elif defined(MOZ_MEMORY_DARWIN)
11286: typedef struct {
11286: 	OSSpinLock	lock;
11286: } malloc_mutex_t;
11286: typedef struct {
11286: 	OSSpinLock	lock;
11286: } malloc_spinlock_t;
11286: #elif defined(MOZ_MEMORY)
11286: typedef pthread_mutex_t malloc_mutex_t;
11286: typedef pthread_mutex_t malloc_spinlock_t;
11286: #else
11286: /* XXX these should #ifdef these for freebsd (and linux?) only */
11286: typedef struct {
11286: 	spinlock_t	lock;
11286: } malloc_mutex_t;
11286: typedef malloc_spinlock_t malloc_mutex_t;
11286: #endif
11286: 
11286: /* Set to true once the allocator has been initialized. */
11286: static bool malloc_initialized = false;
11286: 
11286: #if defined(MOZ_MEMORY_WINDOWS)
11286: /* No init lock for Windows. */
11286: #elif defined(MOZ_MEMORY_DARWIN)
11286: static malloc_mutex_t init_lock = {OS_SPINLOCK_INIT};
11449: #elif defined(MOZ_MEMORY_LINUX)
11449: static malloc_mutex_t init_lock = PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP;
11286: #elif defined(MOZ_MEMORY)
11286: static malloc_mutex_t init_lock = PTHREAD_MUTEX_INITIALIZER;
11286: #else
11286: static malloc_mutex_t init_lock = {_SPINLOCK_INITIALIZER};
11286: #endif
11286: 
11286: /******************************************************************************/
11286: /*
11286:  * Statistics data structures.
11286:  */
11286: 
11286: #ifdef MALLOC_STATS
11286: 
11286: typedef struct malloc_bin_stats_s malloc_bin_stats_t;
11286: struct malloc_bin_stats_s {
11286: 	/*
11286: 	 * Number of allocation requests that corresponded to the size of this
11286: 	 * bin.
11286: 	 */
11286: 	uint64_t	nrequests;
11286: 
11286: 	/* Total number of runs created for this bin's size class. */
11286: 	uint64_t	nruns;
11286: 
11286: 	/*
11286: 	 * Total number of runs reused by extracting them from the runs tree for
11286: 	 * this bin's size class.
11286: 	 */
11286: 	uint64_t	reruns;
11286: 
11286: 	/* High-water mark for this bin. */
11286: 	unsigned long	highruns;
11286: 
11286: 	/* Current number of runs in this bin. */
11286: 	unsigned long	curruns;
11286: };
11286: 
11286: typedef struct arena_stats_s arena_stats_t;
11286: struct arena_stats_s {
11286: 	/* Number of bytes currently mapped. */
11286: 	size_t		mapped;
11286: 
11286: 	/*
11449: 	 * Total number of purge sweeps, total number of madvise calls made,
11449: 	 * and total pages purged in order to keep dirty unused memory under
11449: 	 * control.
11449: 	 */
11449: 	uint64_t	npurge;
11286: 	uint64_t	nmadvise;
11449: 	uint64_t	purged;
11449: #ifdef MALLOC_DECOMMIT
11449: 	/*
11449: 	 * Total number of decommit/commit operations, and total number of
11449: 	 * pages decommitted.
11449: 	 */
11449: 	uint64_t	ndecommit;
11449: 	uint64_t	ncommit;
11449: 	uint64_t	decommitted;
11449: #endif
11286: 
11286: 	/* Per-size-category statistics. */
11286: 	size_t		allocated_small;
11286: 	uint64_t	nmalloc_small;
11286: 	uint64_t	ndalloc_small;
11286: 
11286: 	size_t		allocated_large;
11286: 	uint64_t	nmalloc_large;
11286: 	uint64_t	ndalloc_large;
11286: 
11286: #ifdef MALLOC_BALANCE
11286: 	/* Number of times this arena reassigned a thread due to contention. */
11286: 	uint64_t	nbalance;
11286: #endif
11286: };
11286: 
11286: typedef struct chunk_stats_s chunk_stats_t;
11286: struct chunk_stats_s {
11286: 	/* Number of chunks that were allocated. */
11286: 	uint64_t	nchunks;
11286: 
11286: 	/* High-water mark for number of chunks allocated. */
11286: 	unsigned long	highchunks;
11286: 
11286: 	/*
11286: 	 * Current number of chunks allocated.  This value isn't maintained for
11286: 	 * any other purpose, so keep track of it in order to be able to set
11286: 	 * highchunks.
11286: 	 */
11286: 	unsigned long	curchunks;
11286: };
11286: 
11286: #endif /* #ifdef MALLOC_STATS */
11286: 
11286: /******************************************************************************/
11286: /*
11286:  * Extent data structures.
11286:  */
11286: 
11286: /* Tree of extents. */
11286: typedef struct extent_node_s extent_node_t;
11286: struct extent_node_s {
11449: 	/* Linkage for the size/address-ordered tree. */
15460: 	rb_node(extent_node_t) link_szad;
11449: 
11286: 	/* Linkage for the address-ordered tree. */
15460: 	rb_node(extent_node_t) link_ad;
11286: 
11286: 	/* Pointer to the extent that this tree node is responsible for. */
11286: 	void	*addr;
11286: 
11286: 	/* Total region size. */
11286: 	size_t	size;
11286: };
15460: typedef rb_tree(extent_node_t) extent_tree_t;
11286: 
11286: /******************************************************************************/
11286: /*
16218:  * Radix tree data structures.
16218:  */
16218: 
16218: #ifdef MALLOC_VALIDATE
16218:    /*
16218:     * Size of each radix tree node (must be a power of 2).  This impacts tree
16218:     * depth.
16218:     */
16218: #  if (SIZEOF_PTR == 4)
16218: #    define MALLOC_RTREE_NODESIZE (1U << 14)
16218: #  else
16218: #    define MALLOC_RTREE_NODESIZE CACHELINE
16218: #  endif
16218: 
16218: typedef struct malloc_rtree_s malloc_rtree_t;
16218: struct malloc_rtree_s {
16218: 	malloc_spinlock_t	lock;
16218: 	void			**root;
16218: 	unsigned		height;
16218: 	unsigned		level2bits[1]; /* Dynamically sized. */
16218: };
16218: #endif
16218: 
16218: /******************************************************************************/
16218: /*
11286:  * Arena data structures.
11286:  */
11286: 
11286: typedef struct arena_s arena_t;
11286: typedef struct arena_bin_s arena_bin_t;
11286: 
16218: /* Each element of the chunk map corresponds to one page within the chunk. */
16218: typedef struct arena_chunk_map_s arena_chunk_map_t;
16218: struct arena_chunk_map_s {
16218: 	/*
16218: 	 * Linkage for run trees.  There are two disjoint uses:
16218: 	 *
16218: 	 * 1) arena_t's runs_avail tree.
16218: 	 * 2) arena_run_t conceptually uses this linkage for in-use non-full
16218: 	 *    runs, rather than directly embedding linkage.
16218: 	 */
16218: 	rb_node(arena_chunk_map_t)	link;
16218: 
16218: 	/*
16218: 	 * Run address (or size) and various flags are stored together.  The bit
16218: 	 * layout looks like (assuming 32-bit system):
16218: 	 *
16218: 	 *   ???????? ???????? ????---- --ckdzla
16218: 	 *
16218: 	 * ? : Unallocated: Run address for first/last pages, unset for internal
16218: 	 *                  pages.
16218: 	 *     Small: Run address.
16218: 	 *     Large: Run size for first page, unset for trailing pages.
16218: 	 * - : Unused.
16218: 	 * c : decommitted?
16218: 	 * k : key?
16218: 	 * d : dirty?
16218: 	 * z : zeroed?
16218: 	 * l : large?
16218: 	 * a : allocated?
16218: 	 *
16218: 	 * Following are example bit patterns for the three types of runs.
16218: 	 *
16218: 	 * r : run address
16218: 	 * s : run size
16218: 	 * x : don't care
16218: 	 * - : 0
16218: 	 * [cdzla] : bit set
16218: 	 *
16218: 	 *   Unallocated:
16218: 	 *     ssssssss ssssssss ssss---- --c-----
16218: 	 *     xxxxxxxx xxxxxxxx xxxx---- ----d---
16218: 	 *     ssssssss ssssssss ssss---- -----z--
16218: 	 *
16218: 	 *   Small:
16218: 	 *     rrrrrrrr rrrrrrrr rrrr---- -------a
16218: 	 *     rrrrrrrr rrrrrrrr rrrr---- -------a
16218: 	 *     rrrrrrrr rrrrrrrr rrrr---- -------a
16218: 	 *
16218: 	 *   Large:
16218: 	 *     ssssssss ssssssss ssss---- ------la
16218: 	 *     -------- -------- -------- ------la
16218: 	 *     -------- -------- -------- ------la
16218: 	 */
16218: 	size_t				bits;
11449: #ifdef MALLOC_DECOMMIT
16218: #define	CHUNK_MAP_DECOMMITTED	((size_t)0x20U)
16218: #endif
16218: #define	CHUNK_MAP_KEY		((size_t)0x10U)
16218: #define	CHUNK_MAP_DIRTY		((size_t)0x08U)
16218: #define	CHUNK_MAP_ZEROED	((size_t)0x04U)
16218: #define	CHUNK_MAP_LARGE		((size_t)0x02U)
16218: #define	CHUNK_MAP_ALLOCATED	((size_t)0x01U)
16218: };
16218: typedef rb_tree(arena_chunk_map_t) arena_avail_tree_t;
16218: typedef rb_tree(arena_chunk_map_t) arena_run_tree_t;
11286: 
11286: /* Arena chunk header. */
11286: typedef struct arena_chunk_s arena_chunk_t;
11286: struct arena_chunk_s {
11286: 	/* Arena that owns the chunk. */
11286: 	arena_t		*arena;
11286: 
15461: 	/* Linkage for the arena's chunks_dirty tree. */
15461: 	rb_node(arena_chunk_t) link_dirty;
15461: 
11449: 	/* Number of dirty pages. */
11449: 	size_t		ndirty;
11449: 
16218: 	/* Map of pages within chunk that keeps track of free/large/small. */
11286: 	arena_chunk_map_t map[1]; /* Dynamically sized. */
11286: };
15460: typedef rb_tree(arena_chunk_t) arena_chunk_tree_t;
11286: 
11286: typedef struct arena_run_s arena_run_t;
11286: struct arena_run_s {
11286: #ifdef MALLOC_DEBUG
11286: 	uint32_t	magic;
11286: #  define ARENA_RUN_MAGIC 0x384adf93
11286: #endif
11286: 
11286: 	/* Bin this run is associated with. */
11286: 	arena_bin_t	*bin;
11286: 
11286: 	/* Index of first element that might have a free region. */
11286: 	unsigned	regs_minelm;
11286: 
11286: 	/* Number of free regions in run. */
11286: 	unsigned	nfree;
11286: 
11286: 	/* Bitmask of in-use regions (0: in use, 1: free). */
11286: 	unsigned	regs_mask[1]; /* Dynamically sized. */
11286: };
11286: 
11286: struct arena_bin_s {
11286: 	/*
11286: 	 * Current run being used to service allocations of this bin's size
11286: 	 * class.
11286: 	 */
11286: 	arena_run_t	*runcur;
11286: 
11286: 	/*
11286: 	 * Tree of non-full runs.  This tree is used when looking for an
11286: 	 * existing run when runcur is no longer usable.  We choose the
11286: 	 * non-full run that is lowest in memory; this policy tends to keep
11286: 	 * objects packed well, and it can also help reduce the number of
11286: 	 * almost-empty chunks.
11286: 	 */
11286: 	arena_run_tree_t runs;
11286: 
11286: 	/* Size of regions in a run for this bin's size class. */
11286: 	size_t		reg_size;
11286: 
11286: 	/* Total size of a run for this bin's size class. */
11286: 	size_t		run_size;
11286: 
11286: 	/* Total number of regions in a run for this bin's size class. */
11286: 	uint32_t	nregs;
11286: 
11286: 	/* Number of elements in a run's regs_mask for this bin's size class. */
11286: 	uint32_t	regs_mask_nelms;
11286: 
11286: 	/* Offset of first region in a run for this bin's size class. */
11286: 	uint32_t	reg0_offset;
11286: 
11286: #ifdef MALLOC_STATS
11286: 	/* Bin statistics. */
11286: 	malloc_bin_stats_t stats;
11286: #endif
11286: };
11286: 
11286: struct arena_s {
11286: #ifdef MALLOC_DEBUG
11286: 	uint32_t		magic;
11286: #  define ARENA_MAGIC 0x947d3d24
11286: #endif
11286: 
11286: 	/* All operations on this arena require that lock be locked. */
11286: #ifdef MOZ_MEMORY
11286: 	malloc_spinlock_t	lock;
11286: #else
11286: 	pthread_mutex_t		lock;
11286: #endif
11286: 
11286: #ifdef MALLOC_STATS
11286: 	arena_stats_t		stats;
11286: #endif
11286: 
16218: 	/* Tree of dirty-page-containing chunks this arena manages. */
16218: 	arena_chunk_tree_t	chunks_dirty;
16218: 
16218: 	/*
16218: 	 * In order to avoid rapid chunk allocation/deallocation when an arena
16218: 	 * oscillates right on the cusp of needing a new chunk, cache the most
16218: 	 * recently freed chunk.  The spare is left in the arena's chunk trees
16218: 	 * until it is deleted.
15461: 	 *
16218: 	 * There is one spare chunk per arena, rather than one spare total, in
16218: 	 * order to avoid interactions between multiple threads that could make
16218: 	 * a single spare inadequate.
16218: 	 */
16218: 	arena_chunk_t		*spare;
15461: 
15461: 	/*
11449: 	 * Current count of pages within unused runs that are potentially
11286: 	 * dirty, and for which madvise(... MADV_FREE) has not been called.  By
11286: 	 * tracking this, we can institute a limit on how much dirty unused
11286: 	 * memory is mapped for each arena.
11286: 	 */
11286: 	size_t			ndirty;
11286: 
11286: 	/*
16218: 	 * Size/address-ordered tree of this arena's available runs.  This tree
16218: 	 * is used for first-best-fit run allocation.
16218: 	 */
16218: 	arena_avail_tree_t	runs_avail;
11286: 
11286: #ifdef MALLOC_BALANCE
11286: 	/*
11286: 	 * The arena load balancing machinery needs to keep track of how much
11286: 	 * lock contention there is.  This value is exponentially averaged.
11286: 	 */
11286: 	uint32_t		contention;
11286: #endif
11286: 
11286: 	/*
11286: 	 * bins is used to store rings of free regions of the following sizes,
11286: 	 * assuming a 16-byte quantum, 4kB pagesize, and default MALLOC_OPTIONS.
11286: 	 *
11286: 	 *   bins[i] | size |
11286: 	 *   --------+------+
11286: 	 *        0  |    2 |
11286: 	 *        1  |    4 |
11286: 	 *        2  |    8 |
11286: 	 *   --------+------+
11286: 	 *        3  |   16 |
11286: 	 *        4  |   32 |
11286: 	 *        5  |   48 |
11286: 	 *        6  |   64 |
11286: 	 *           :      :
11286: 	 *           :      :
11286: 	 *       33  |  496 |
11286: 	 *       34  |  512 |
11286: 	 *   --------+------+
11286: 	 *       35  | 1024 |
11286: 	 *       36  | 2048 |
11286: 	 *   --------+------+
11286: 	 */
11286: 	arena_bin_t		bins[1]; /* Dynamically sized. */
11286: };
11286: 
11286: /******************************************************************************/
11286: /*
11286:  * Data.
11286:  */
11286: 
11286: /* Number of CPUs. */
11286: static unsigned		ncpus;
11286: 
11286: /* VM page size. */
11286: static size_t		pagesize;
11286: static size_t		pagesize_mask;
11286: static size_t		pagesize_2pow;
11286: 
11286: /* Various bin-related settings. */
11286: static size_t		bin_maxclass; /* Max size class for bins. */
11286: static unsigned		ntbins; /* Number of (2^n)-spaced tiny bins. */
11286: static unsigned		nqbins; /* Number of quantum-spaced bins. */
11286: static unsigned		nsbins; /* Number of (2^n)-spaced sub-page bins. */
11286: static size_t		small_min;
11286: static size_t		small_max;
11286: 
11286: /* Various quantum-related settings. */
11286: static size_t		quantum;
11286: static size_t		quantum_mask; /* (quantum - 1). */
11286: 
11286: /* Various chunk-related settings. */
11286: static size_t		chunksize;
11286: static size_t		chunksize_mask; /* (chunksize - 1). */
11449: static size_t		chunk_npages;
11449: static size_t		arena_chunk_header_npages;
11286: static size_t		arena_maxclass; /* Max size class for arenas. */
11286: 
11286: /********/
11286: /*
11286:  * Chunks.
11286:  */
11286: 
16218: #ifdef MALLOC_VALIDATE
16218: static malloc_rtree_t *chunk_rtree;
16218: #endif
16218: 
11286: /* Protects chunk-related data structures. */
11286: static malloc_mutex_t	huge_mtx;
11286: 
11286: /* Tree of chunks that are stand-alone huge allocations. */
15460: static extent_tree_t	huge;
11286: 
11286: #ifdef MALLOC_STATS
11286: /* Huge allocation statistics. */
11286: static uint64_t		huge_nmalloc;
11286: static uint64_t		huge_ndalloc;
11286: static size_t		huge_allocated;
11286: #endif
11286: 
15610: #ifdef MALLOC_PAGEFILE
15610: static char		pagefile_templ[PATH_MAX];
15610: #endif
15610: 
11286: /****************************/
11286: /*
11286:  * base (internal allocation).
11286:  */
11286: 
11286: /*
11286:  * Current pages that are being used for internal memory allocations.  These
11286:  * pages are carved up in cacheline-size quanta, so that there is no chance of
11286:  * false cache line sharing.
11286:  */
11286: static void		*base_pages;
11286: static void		*base_next_addr;
13110: #ifdef MALLOC_DECOMMIT
13110: static void		*base_next_decommitted;
13110: #endif
11286: static void		*base_past_addr; /* Addr immediately past base_pages. */
11449: static extent_node_t	*base_nodes;
11286: static malloc_mutex_t	base_mtx;
11286: #ifdef MALLOC_STATS
11286: static size_t		base_mapped;
11286: #endif
11286: 
11286: /********/
11286: /*
11286:  * Arenas.
11286:  */
11286: 
11286: /*
11286:  * Arenas that are used to service external requests.  Not all elements of the
11286:  * arenas array are necessarily used; arenas are created lazily as needed.
11286:  */
11286: static arena_t		**arenas;
11286: static unsigned		narenas;
11286: #ifndef NO_TLS
11286: #  ifdef MALLOC_BALANCE
11286: static unsigned		narenas_2pow;
11286: #  else
11286: static unsigned		next_arena;
11286: #  endif
11286: #endif
11286: #ifdef MOZ_MEMORY
11286: static malloc_spinlock_t arenas_lock; /* Protects arenas initialization. */
11286: #else
11286: static pthread_mutex_t arenas_lock; /* Protects arenas initialization. */
11286: #endif
11286: 
11286: #ifndef NO_TLS
11286: /*
11286:  * Map of pthread_self() --> arenas[???], used for selecting an arena to use
11286:  * for allocations.
11286:  */
11286: #ifndef MOZ_MEMORY_WINDOWS
11286: static __thread arena_t	*arenas_map;
11286: #endif
11286: #endif
11286: 
11286: #ifdef MALLOC_STATS
11286: /* Chunk statistics. */
11286: static chunk_stats_t	stats_chunks;
11286: #endif
11286: 
11286: /*******************************/
11286: /*
11286:  * Runtime configuration options.
11286:  */
15462: const char	*_malloc_options;
11286: 
11286: #ifndef MALLOC_PRODUCTION
11286: static bool	opt_abort = true;
11449: #ifdef MALLOC_FILL
11286: static bool	opt_junk = true;
11449: #endif
11286: #else
11286: static bool	opt_abort = false;
11449: #ifdef MALLOC_FILL
11286: static bool	opt_junk = false;
11286: #endif
11449: #endif
11449: static size_t	opt_dirty_max = DIRTY_MAX_DEFAULT;
11286: #ifdef MALLOC_BALANCE
11286: static uint64_t	opt_balance_threshold = BALANCE_THRESHOLD_DEFAULT;
11286: #endif
11286: static bool	opt_print_stats = false;
11286: static size_t	opt_quantum_2pow = QUANTUM_2POW_MIN;
11286: static size_t	opt_small_max_2pow = SMALL_MAX_2POW_DEFAULT;
11286: static size_t	opt_chunk_2pow = CHUNK_2POW_DEFAULT;
15610: #ifdef MALLOC_PAGEFILE
22710: static bool	opt_pagefile = false;
15610: #endif
11449: #ifdef MALLOC_UTRACE
11286: static bool	opt_utrace = false;
11449: #endif
11449: #ifdef MALLOC_SYSV
11286: static bool	opt_sysv = false;
11449: #endif
11449: #ifdef MALLOC_XMALLOC
11286: static bool	opt_xmalloc = false;
11449: #endif
11449: #ifdef MALLOC_FILL
11286: static bool	opt_zero = false;
11449: #endif
11286: static int	opt_narenas_lshift = 0;
11286: 
11449: #ifdef MALLOC_UTRACE
11286: typedef struct {
11286: 	void	*p;
11286: 	size_t	s;
11286: 	void	*r;
11286: } malloc_utrace_t;
11286: 
11286: #define	UTRACE(a, b, c)							\
11286: 	if (opt_utrace) {						\
11449: 		malloc_utrace_t ut;					\
11449: 		ut.p = (a);						\
11449: 		ut.s = (b);						\
11449: 		ut.r = (c);						\
11286: 		utrace(&ut, sizeof(ut));				\
11286: 	}
11449: #else
11449: #define	UTRACE(a, b, c)
11286: #endif
11286: 
11286: /******************************************************************************/
11286: /*
11286:  * Begin function prototypes for non-inline static functions.
11286:  */
11286: 
16217: static char	*umax2s(uintmax_t x, char *s);
11286: static bool	malloc_mutex_init(malloc_mutex_t *mutex);
11286: static bool	malloc_spin_init(malloc_spinlock_t *lock);
11286: static void	wrtmessage(const char *p1, const char *p2, const char *p3,
11286: 		const char *p4);
11286: #ifdef MALLOC_STATS
11286: #ifdef MOZ_MEMORY_DARWIN
11286: /* Avoid namespace collision with OS X's malloc APIs. */
15458: #define malloc_printf moz_malloc_printf
11286: #endif
11286: static void	malloc_printf(const char *format, ...);
11286: #endif
11449: static bool	base_pages_alloc_mmap(size_t minsize);
11286: static bool	base_pages_alloc(size_t minsize);
11286: static void	*base_alloc(size_t size);
11286: static void	*base_calloc(size_t number, size_t size);
11286: static extent_node_t *base_node_alloc(void);
11286: static void	base_node_dealloc(extent_node_t *node);
11286: #ifdef MALLOC_STATS
11286: static void	stats_print(arena_t *arena);
11286: #endif
15610: static void	*pages_map(void *addr, size_t size, int pfd);
11286: static void	pages_unmap(void *addr, size_t size);
15610: static void	*chunk_alloc_mmap(size_t size, bool pagefile);
15610: #ifdef MALLOC_PAGEFILE
15610: static int	pagefile_init(size_t size);
15610: static void	pagefile_close(int pfd);
15610: #endif
15610: static void	*chunk_alloc(size_t size, bool zero, bool pagefile);
11449: static void	chunk_dealloc_mmap(void *chunk, size_t size);
11286: static void	chunk_dealloc(void *chunk, size_t size);
11286: #ifndef NO_TLS
11286: static arena_t	*choose_arena_hard(void);
11286: #endif
11449: static void	arena_run_split(arena_t *arena, arena_run_t *run, size_t size,
16218:     bool large, bool zero);
15610: static void arena_chunk_init(arena_t *arena, arena_chunk_t *chunk);
11286: static void	arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk);
15610: static arena_run_t *arena_run_alloc(arena_t *arena, arena_bin_t *bin,
16218:     size_t size, bool large, bool zero);
11286: static void	arena_purge(arena_t *arena);
11449: static void	arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty);
11449: static void	arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk,
16218:     arena_run_t *run, size_t oldsize, size_t newsize);
11449: static void	arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk,
16218:     arena_run_t *run, size_t oldsize, size_t newsize, bool dirty);
11286: static arena_run_t *arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin);
11286: static void *arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin);
11286: static size_t arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size);
11449: #ifdef MALLOC_BALANCE
11449: static void	arena_lock_balance_hard(arena_t *arena);
11449: #endif
11449: static void	*arena_malloc_large(arena_t *arena, size_t size, bool zero);
11286: static void	*arena_palloc(arena_t *arena, size_t alignment, size_t size,
11286:     size_t alloc_size);
11286: static size_t	arena_salloc(const void *ptr);
11449: static void	arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk,
11449:     void *ptr);
11773: static void	arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk,
11449:     void *ptr, size_t size, size_t oldsize);
11773: static bool	arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk,
11449:     void *ptr, size_t size, size_t oldsize);
11773: static bool	arena_ralloc_large(void *ptr, size_t size, size_t oldsize);
11286: static void	*arena_ralloc(void *ptr, size_t size, size_t oldsize);
11286: static bool	arena_new(arena_t *arena);
11286: static arena_t	*arenas_extend(unsigned ind);
11286: static void	*huge_malloc(size_t size, bool zero);
11286: static void	*huge_palloc(size_t alignment, size_t size);
11286: static void	*huge_ralloc(void *ptr, size_t size, size_t oldsize);
11286: static void	huge_dalloc(void *ptr);
11286: static void	malloc_print_stats(void);
11449: #ifndef MOZ_MEMORY_WINDOWS
11449: static
11449: #endif
11449: bool		malloc_init_hard(void);
11286: 
21117: void		_malloc_prefork(void);
21117: void		_malloc_postfork(void);
21117: 
11286: /*
11286:  * End function prototypes.
11286:  */
11286: /******************************************************************************/
16217: 
16217: /*
16217:  * umax2s() provides minimal integer printing functionality, which is
16217:  * especially useful for situations where allocation in vsnprintf() calls would
16217:  * potentially cause deadlock.
16217:  */
16217: #define	UMAX2S_BUFSIZE	21
16217: static char *
16217: umax2s(uintmax_t x, char *s)
16217: {
16217: 	unsigned i;
16217: 
16217: 	i = UMAX2S_BUFSIZE - 1;
16217: 	s[i] = '\0';
16217: 	do {
16217: 		i--;
16217: 		s[i] = "0123456789"[x % 10];
16217: 		x /= 10;
16217: 	} while (x > 0);
16217: 
16217: 	return (&s[i]);
16217: }
16217: 
16217: static void
16217: wrtmessage(const char *p1, const char *p2, const char *p3, const char *p4)
16217: {
26488: #ifdef MOZ_MEMORY_WINCE
26488:        wchar_t buf[1024];
26488: #define WRT_PRINT(s) \
26488:        MultiByteToWideChar(CP_ACP, 0, s, -1, buf, 1024); \
26488:        OutputDebugStringW(buf)
26488: 
26488:        WRT_PRINT(p1);
26488:        WRT_PRINT(p2);
26488:        WRT_PRINT(p3);
26488:        WRT_PRINT(p4);
26488: #else
16217: #if defined(MOZ_MEMORY) && !defined(MOZ_MEMORY_WINDOWS)
16217: #define	_write	write
16217: #endif
16217: 	_write(STDERR_FILENO, p1, (unsigned int) strlen(p1));
16217: 	_write(STDERR_FILENO, p2, (unsigned int) strlen(p2));
16217: 	_write(STDERR_FILENO, p3, (unsigned int) strlen(p3));
16217: 	_write(STDERR_FILENO, p4, (unsigned int) strlen(p4));
26488: #endif
26488: 
16217: }
16217: 
16217: #define _malloc_message malloc_message
16217: 
16217: void	(*_malloc_message)(const char *p1, const char *p2, const char *p3,
16217: 	    const char *p4) = wrtmessage;
16217: 
16217: #ifdef MALLOC_DEBUG
16217: #  define assert(e) do {						\
16217: 	if (!(e)) {							\
16217: 		char line_buf[UMAX2S_BUFSIZE];				\
16217: 		_malloc_message(__FILE__, ":", umax2s(__LINE__,		\
16217: 		    line_buf), ": Failed assertion: ");			\
16217: 		_malloc_message("\"", #e, "\"\n", "");			\
16217: 		abort();						\
16217: 	}								\
16217: } while (0)
16217: #else
16217: #define assert(e)
16217: #endif
16217: 
16217: /******************************************************************************/
11286: /*
11286:  * Begin mutex.  We can't use normal pthread mutexes in all places, because
11286:  * they require malloc()ed memory, which causes bootstrapping issues in some
11286:  * cases.
11286:  */
11286: 
11286: static bool
11286: malloc_mutex_init(malloc_mutex_t *mutex)
11286: {
26488: #if defined(MOZ_MEMORY_WINCE)
26488: 	InitializeCriticalSection(mutex);
26488: #elif defined(MOZ_MEMORY_WINDOWS)
11286: 	if (__isthreaded)
11286: 		if (! __crtInitCritSecAndSpinCount(mutex, _CRT_SPINCOUNT))
11286: 			return (true);
11286: #elif defined(MOZ_MEMORY_DARWIN)
11286: 	mutex->lock = OS_SPINLOCK_INIT;
11449: #elif defined(MOZ_MEMORY_LINUX)
11449: 	pthread_mutexattr_t attr;
11449: 	if (pthread_mutexattr_init(&attr) != 0)
11449: 		return (true);
11449: 	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);
11449: 	if (pthread_mutex_init(mutex, &attr) != 0) {
11449: 		pthread_mutexattr_destroy(&attr);
11449: 		return (true);
11449: 	}
11449: 	pthread_mutexattr_destroy(&attr);
11286: #elif defined(MOZ_MEMORY)
11286: 	if (pthread_mutex_init(mutex, NULL) != 0)
11286: 		return (true);
11286: #else
11286: 	static const spinlock_t lock = _SPINLOCK_INITIALIZER;
11286: 
11286: 	mutex->lock = lock;
11286: #endif
11286: 	return (false);
11286: }
11286: 
11286: static inline void
11286: malloc_mutex_lock(malloc_mutex_t *mutex)
11286: {
11286: 
11286: #if defined(MOZ_MEMORY_WINDOWS)
11286: 	EnterCriticalSection(mutex);
11286: #elif defined(MOZ_MEMORY_DARWIN)
11286: 	OSSpinLockLock(&mutex->lock);
11286: #elif defined(MOZ_MEMORY)
11286: 	pthread_mutex_lock(mutex);
11286: #else
11286: 	if (__isthreaded)
11286: 		_SPINLOCK(&mutex->lock);
11286: #endif
11286: }
11286: 
11286: static inline void
11286: malloc_mutex_unlock(malloc_mutex_t *mutex)
11286: {
11286: 
11286: #if defined(MOZ_MEMORY_WINDOWS)
11286: 	LeaveCriticalSection(mutex);
11286: #elif defined(MOZ_MEMORY_DARWIN)
11286: 	OSSpinLockUnlock(&mutex->lock);
11286: #elif defined(MOZ_MEMORY)
11286: 	pthread_mutex_unlock(mutex);
11286: #else
11286: 	if (__isthreaded)
11286: 		_SPINUNLOCK(&mutex->lock);
11286: #endif
11286: }
11286: 
11286: static bool
11286: malloc_spin_init(malloc_spinlock_t *lock)
11286: {
26488: #if defined(MOZ_MEMORY_WINCE)
26488: 	InitializeCriticalSection(lock);
26488: #elif defined(MOZ_MEMORY_WINDOWS)
11286: 	if (__isthreaded)
11286: 		if (! __crtInitCritSecAndSpinCount(lock, _CRT_SPINCOUNT))
11286: 			return (true);
11286: #elif defined(MOZ_MEMORY_DARWIN)
11286: 	lock->lock = OS_SPINLOCK_INIT;
11449: #elif defined(MOZ_MEMORY_LINUX)
11449: 	pthread_mutexattr_t attr;
11449: 	if (pthread_mutexattr_init(&attr) != 0)
11449: 		return (true);
11449: 	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);
11449: 	if (pthread_mutex_init(lock, &attr) != 0) {
11449: 		pthread_mutexattr_destroy(&attr);
11449: 		return (true);
11449: 	}
11449: 	pthread_mutexattr_destroy(&attr);
11286: #elif defined(MOZ_MEMORY)
11286: 	if (pthread_mutex_init(lock, NULL) != 0)
11286: 		return (true);
11286: #else
11286: 	lock->lock = _SPINLOCK_INITIALIZER;
11286: #endif
11286: 	return (false);
11286: }
11286: 
11286: static inline void
11286: malloc_spin_lock(malloc_spinlock_t *lock)
11286: {
11286: 
11286: #if defined(MOZ_MEMORY_WINDOWS)
11286: 	EnterCriticalSection(lock);
11286: #elif defined(MOZ_MEMORY_DARWIN)
11286: 	OSSpinLockLock(&lock->lock);
11286: #elif defined(MOZ_MEMORY)
11286: 	pthread_mutex_lock(lock);
11286: #else
11286: 	if (__isthreaded)
11286: 		_SPINLOCK(&lock->lock);
11286: #endif
11286: }
11286: 
11286: static inline void
11286: malloc_spin_unlock(malloc_spinlock_t *lock)
11286: {
11286: #if defined(MOZ_MEMORY_WINDOWS)
11286: 	LeaveCriticalSection(lock);
11286: #elif defined(MOZ_MEMORY_DARWIN)
11286: 	OSSpinLockUnlock(&lock->lock);
11286: #elif defined(MOZ_MEMORY)
11286: 	pthread_mutex_unlock(lock);
11286: #else
11286: 	if (__isthreaded)
11286: 		_SPINUNLOCK(&lock->lock);
11286: #endif
11286: }
11286: 
11286: /*
11286:  * End mutex.
11286:  */
11286: /******************************************************************************/
11286: /*
11286:  * Begin spin lock.  Spin locks here are actually adaptive mutexes that block
11286:  * after a period of spinning, because unbounded spinning would allow for
11286:  * priority inversion.
11286:  */
11286: 
11286: #if defined(MOZ_MEMORY) && !defined(MOZ_MEMORY_DARWIN)
11286: #  define	malloc_spin_init	malloc_mutex_init
11286: #  define	malloc_spin_lock	malloc_mutex_lock
11286: #  define	malloc_spin_unlock	malloc_mutex_unlock
11286: #endif
11286: 
11286: #ifndef MOZ_MEMORY
11286: /*
11286:  * We use an unpublished interface to initialize pthread mutexes with an
11286:  * allocation callback, in order to avoid infinite recursion.
11286:  */
11286: int	_pthread_mutex_init_calloc_cb(pthread_mutex_t *mutex,
11286:     void *(calloc_cb)(size_t, size_t));
11286: 
11286: __weak_reference(_pthread_mutex_init_calloc_cb_stub,
11286:     _pthread_mutex_init_calloc_cb);
11286: 
11286: int
11286: _pthread_mutex_init_calloc_cb_stub(pthread_mutex_t *mutex,
11286:     void *(calloc_cb)(size_t, size_t))
11286: {
11286: 
11286: 	return (0);
11286: }
11286: 
11286: static bool
11286: malloc_spin_init(pthread_mutex_t *lock)
11286: {
11286: 
11286: 	if (_pthread_mutex_init_calloc_cb(lock, base_calloc) != 0)
11286: 		return (true);
11286: 
11286: 	return (false);
11286: }
11286: 
11286: static inline unsigned
11286: malloc_spin_lock(pthread_mutex_t *lock)
11286: {
11286: 	unsigned ret = 0;
11286: 
11286: 	if (__isthreaded) {
11286: 		if (_pthread_mutex_trylock(lock) != 0) {
11286: 			unsigned i;
11286: 			volatile unsigned j;
11286: 
11286: 			/* Exponentially back off. */
11286: 			for (i = 1; i <= SPIN_LIMIT_2POW; i++) {
11286: 				for (j = 0; j < (1U << i); j++)
11286: 					ret++;
11286: 
11286: 				CPU_SPINWAIT;
11286: 				if (_pthread_mutex_trylock(lock) == 0)
11286: 					return (ret);
11286: 			}
11286: 
11286: 			/*
11286: 			 * Spinning failed.  Block until the lock becomes
11286: 			 * available, in order to avoid indefinite priority
11286: 			 * inversion.
11286: 			 */
11286: 			_pthread_mutex_lock(lock);
11286: 			assert((ret << BLOCK_COST_2POW) != 0);
11286: 			return (ret << BLOCK_COST_2POW);
11286: 		}
11286: 	}
11286: 
11286: 	return (ret);
11286: }
11286: 
11286: static inline void
11286: malloc_spin_unlock(pthread_mutex_t *lock)
11286: {
11286: 
11286: 	if (__isthreaded)
11286: 		_pthread_mutex_unlock(lock);
11286: }
11286: #endif
11286: 
11286: /*
11286:  * End spin lock.
11286:  */
11286: /******************************************************************************/
11286: /*
11286:  * Begin Utility functions/macros.
11286:  */
11286: 
11286: /* Return the chunk address for allocation address a. */
11286: #define	CHUNK_ADDR2BASE(a)						\
11286: 	((void *)((uintptr_t)(a) & ~chunksize_mask))
11286: 
11286: /* Return the chunk offset of address a. */
11286: #define	CHUNK_ADDR2OFFSET(a)						\
11286: 	((size_t)((uintptr_t)(a) & chunksize_mask))
11286: 
11286: /* Return the smallest chunk multiple that is >= s. */
11286: #define	CHUNK_CEILING(s)						\
11286: 	(((s) + chunksize_mask) & ~chunksize_mask)
11286: 
11286: /* Return the smallest cacheline multiple that is >= s. */
11286: #define	CACHELINE_CEILING(s)						\
11286: 	(((s) + (CACHELINE - 1)) & ~(CACHELINE - 1))
11286: 
11286: /* Return the smallest quantum multiple that is >= a. */
11286: #define	QUANTUM_CEILING(a)						\
11286: 	(((a) + quantum_mask) & ~quantum_mask)
11286: 
11286: /* Return the smallest pagesize multiple that is >= s. */
11286: #define	PAGE_CEILING(s)							\
11286: 	(((s) + pagesize_mask) & ~pagesize_mask)
11286: 
11286: /* Compute the smallest power of 2 that is >= x. */
11286: static inline size_t
11286: pow2_ceil(size_t x)
11286: {
11286: 
11286: 	x--;
11286: 	x |= x >> 1;
11286: 	x |= x >> 2;
11286: 	x |= x >> 4;
11286: 	x |= x >> 8;
11286: 	x |= x >> 16;
11286: #if (SIZEOF_PTR == 8)
11286: 	x |= x >> 32;
11286: #endif
11286: 	x++;
11286: 	return (x);
11286: }
11286: 
14033: #ifdef MALLOC_BALANCE
11286: /*
11286:  * Use a simple linear congruential pseudo-random number generator:
11286:  *
11286:  *   prn(y) = (a*x + c) % m
11286:  *
11286:  * where the following constants ensure maximal period:
11286:  *
11286:  *   a == Odd number (relatively prime to 2^n), and (a-1) is a multiple of 4.
11286:  *   c == Odd number (relatively prime to 2^n).
11286:  *   m == 2^32
11286:  *
11286:  * See Knuth's TAOCP 3rd Ed., Vol. 2, pg. 17 for details on these constraints.
11286:  *
11286:  * This choice of m has the disadvantage that the quality of the bits is
11286:  * proportional to bit position.  For example. the lowest bit has a cycle of 2,
11286:  * the next has a cycle of 4, etc.  For this reason, we prefer to use the upper
11286:  * bits.
11286:  */
11286: #  define PRN_DEFINE(suffix, var, a, c)					\
11286: static inline void							\
11286: sprn_##suffix(uint32_t seed)						\
11286: {									\
11286: 	var = seed;							\
11286: }									\
11286: 									\
11286: static inline uint32_t							\
11286: prn_##suffix(uint32_t lg_range)						\
11286: {									\
11286: 	uint32_t ret, x;						\
11286: 									\
11286: 	assert(lg_range > 0);						\
11286: 	assert(lg_range <= 32);						\
11286: 									\
11286: 	x = (var * (a)) + (c);						\
11286: 	var = x;							\
11286: 	ret = x >> (32 - lg_range);					\
11286: 									\
11286: 	return (ret);							\
11286: }
11286: #  define SPRN(suffix, seed)	sprn_##suffix(seed)
11286: #  define PRN(suffix, lg_range)	prn_##suffix(lg_range)
11286: #endif
11286: 
11286: #ifdef MALLOC_BALANCE
11286: /* Define the PRNG used for arena assignment. */
11286: static __thread uint32_t balance_x;
11286: PRN_DEFINE(balance, balance_x, 1297, 1301)
11286: #endif
11286: 
11449: #ifdef MALLOC_UTRACE
11449: static int
11449: utrace(const void *addr, size_t len)
11449: {
11449: 	malloc_utrace_t *ut = (malloc_utrace_t *)addr;
11449: 
11449: 	assert(len == sizeof(malloc_utrace_t));
11449: 
11449: 	if (ut->p == NULL && ut->s == 0 && ut->r == NULL)
11449: 		malloc_printf("%d x USER malloc_init()\n", getpid());
11449: 	else if (ut->p == NULL && ut->r != NULL) {
11449: 		malloc_printf("%d x USER %p = malloc(%zu)\n", getpid(), ut->r,
11449: 		    ut->s);
11449: 	} else if (ut->p != NULL && ut->r != NULL) {
11449: 		malloc_printf("%d x USER %p = realloc(%p, %zu)\n", getpid(),
11449: 		    ut->r, ut->p, ut->s);
11449: 	} else
11449: 		malloc_printf("%d x USER free(%p)\n", getpid(), ut->p);
11449: 
11449: 	return (0);
11449: }
11449: #endif
11449: 
11286: static inline const char *
11286: _getprogname(void)
11286: {
11286: 
11286: 	return ("<jemalloc>");
11286: }
11286: 
11286: #ifdef MALLOC_STATS
11286: /*
11286:  * Print to stderr in such a way as to (hopefully) avoid memory allocation.
11286:  */
11286: static void
11286: malloc_printf(const char *format, ...)
11286: {
26488: #ifndef WINCE
11286: 	char buf[4096];
11286: 	va_list ap;
11286: 
11286: 	va_start(ap, format);
11286: 	vsnprintf(buf, sizeof(buf), format, ap);
11286: 	va_end(ap);
11286: 	_malloc_message(buf, "", "", "");
26488: #endif
11286: }
11286: #endif
11286: 
11286: /******************************************************************************/
11286: 
13110: #ifdef MALLOC_DECOMMIT
13110: static inline void
13110: pages_decommit(void *addr, size_t size)
13110: {
13110: 
13110: #ifdef MOZ_MEMORY_WINDOWS
13110: 	VirtualFree(addr, size, MEM_DECOMMIT);
13110: #else
13110: 	if (mmap(addr, size, PROT_NONE, MAP_FIXED | MAP_PRIVATE | MAP_ANON, -1,
13110: 	    0) == MAP_FAILED)
13110: 		abort();
13110: #endif
13110: }
13110: 
13110: static inline void
13110: pages_commit(void *addr, size_t size)
13110: {
13110: 
13110: #  ifdef MOZ_MEMORY_WINDOWS
13110: 	VirtualAlloc(addr, size, MEM_COMMIT, PAGE_READWRITE);
13110: #  else
13110: 	if (mmap(addr, size, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_PRIVATE |
13110: 	    MAP_ANON, -1, 0) == MAP_FAILED)
13110: 		abort();
13110: #  endif
13110: }
13110: #endif
13110: 
11449: static bool
11286: base_pages_alloc_mmap(size_t minsize)
11286: {
15610: 	bool ret;
11286: 	size_t csize;
13110: #ifdef MALLOC_DECOMMIT
13110: 	size_t pminsize;
13110: #endif
15610: 	int pfd;
11286: 
11286: 	assert(minsize != 0);
15610: 	csize = CHUNK_CEILING(minsize);
15610: #ifdef MALLOC_PAGEFILE
15610: 	if (opt_pagefile) {
15610: 		pfd = pagefile_init(csize);
15610: 		if (pfd == -1)
11286: 			return (true);
15610: 	} else
15610: #endif
15610: 		pfd = -1;
15610: 	base_pages = pages_map(NULL, csize, pfd);
15610: 	if (base_pages == NULL) {
15610: 		ret = true;
15610: 		goto RETURN;
15610: 	}
11286: 	base_next_addr = base_pages;
11286: 	base_past_addr = (void *)((uintptr_t)base_pages + csize);
13110: #ifdef MALLOC_DECOMMIT
13110: 	/*
13110: 	 * Leave enough pages for minsize committed, since otherwise they would
13110: 	 * have to be immediately recommitted.
13110: 	 */
13110: 	pminsize = PAGE_CEILING(minsize);
13110: 	base_next_decommitted = (void *)((uintptr_t)base_pages + pminsize);
13110: 	if (pminsize < csize)
13110: 		pages_decommit(base_next_decommitted, csize - pminsize);
13110: #endif
11286: #ifdef MALLOC_STATS
11286: 	base_mapped += csize;
11286: #endif
11286: 
15610: 	ret = false;
15610: RETURN:
15610: #ifdef MALLOC_PAGEFILE
15610: 	if (pfd != -1)
15610: 		pagefile_close(pfd);
15610: #endif
11286: 	return (false);
11286: }
11286: 
11286: static bool
11286: base_pages_alloc(size_t minsize)
11286: {
11286: 
11286: 	if (base_pages_alloc_mmap(minsize) == false)
11286: 		return (false);
11286: 
11286: 	return (true);
11286: }
11286: 
11449: static void *
11449: base_alloc(size_t size)
11286: {
11286: 	void *ret;
11286: 	size_t csize;
11286: 
11286: 	/* Round size up to nearest multiple of the cacheline size. */
11286: 	csize = CACHELINE_CEILING(size);
11286: 
11449: 	malloc_mutex_lock(&base_mtx);
11286: 	/* Make sure there's enough space for the allocation. */
11286: 	if ((uintptr_t)base_next_addr + csize > (uintptr_t)base_past_addr) {
15456: 		if (base_pages_alloc(csize)) {
15456: 			malloc_mutex_unlock(&base_mtx);
11286: 			return (NULL);
11286: 		}
15456: 	}
11286: 	/* Allocate. */
11286: 	ret = base_next_addr;
11286: 	base_next_addr = (void *)((uintptr_t)base_next_addr + csize);
13110: #ifdef MALLOC_DECOMMIT
13110: 	/* Make sure enough pages are committed for the new allocation. */
13110: 	if ((uintptr_t)base_next_addr > (uintptr_t)base_next_decommitted) {
13110: 		void *pbase_next_addr =
13110: 		    (void *)(PAGE_CEILING((uintptr_t)base_next_addr));
13110: 
13110: 		pages_commit(base_next_decommitted, (uintptr_t)pbase_next_addr -
13110: 		    (uintptr_t)base_next_decommitted);
13110: 		base_next_decommitted = pbase_next_addr;
13110: 	}
13110: #endif
11286: 	malloc_mutex_unlock(&base_mtx);
14033: 	VALGRIND_MALLOCLIKE_BLOCK(ret, size, 0, false);
11286: 
11286: 	return (ret);
11286: }
11286: 
11286: static void *
11286: base_calloc(size_t number, size_t size)
11286: {
11286: 	void *ret;
11286: 
11286: 	ret = base_alloc(number * size);
14033: #ifdef MALLOC_VALGRIND
14033: 	if (ret != NULL) {
14033: 		VALGRIND_FREELIKE_BLOCK(ret, 0);
14033: 		VALGRIND_MALLOCLIKE_BLOCK(ret, size, 0, true);
14033: 	}
14033: #endif
11286: 	memset(ret, 0, number * size);
11286: 
11286: 	return (ret);
11286: }
11286: 
11286: static extent_node_t *
11286: base_node_alloc(void)
11286: {
11286: 	extent_node_t *ret;
11286: 
11286: 	malloc_mutex_lock(&base_mtx);
11449: 	if (base_nodes != NULL) {
11449: 		ret = base_nodes;
11449: 		base_nodes = *(extent_node_t **)ret;
14033: 		VALGRIND_FREELIKE_BLOCK(ret, 0);
14033: 		VALGRIND_MALLOCLIKE_BLOCK(ret, sizeof(extent_node_t), 0, false);
11286: 		malloc_mutex_unlock(&base_mtx);
11449: 	} else {
11286: 		malloc_mutex_unlock(&base_mtx);
11449: 		ret = (extent_node_t *)base_alloc(sizeof(extent_node_t));
11449: 	}
11286: 
11286: 	return (ret);
11286: }
11286: 
11286: static void
11286: base_node_dealloc(extent_node_t *node)
11286: {
11286: 
11286: 	malloc_mutex_lock(&base_mtx);
14033: 	VALGRIND_FREELIKE_BLOCK(node, 0);
14033: 	VALGRIND_MALLOCLIKE_BLOCK(node, sizeof(extent_node_t *), 0, false);
11449: 	*(extent_node_t **)node = base_nodes;
11449: 	base_nodes = node;
11286: 	malloc_mutex_unlock(&base_mtx);
11286: }
11286: 
11286: /******************************************************************************/
11286: 
11286: #ifdef MALLOC_STATS
11286: static void
11286: stats_print(arena_t *arena)
11286: {
11286: 	unsigned i, gap_start;
11286: 
11449: #ifdef MOZ_MEMORY_WINDOWS
11449: 	malloc_printf("dirty: %Iu page%s dirty, %I64u sweep%s,"
11449: 	    " %I64u madvise%s, %I64u page%s purged\n",
11449: 	    arena->ndirty, arena->ndirty == 1 ? "" : "s",
11449: 	    arena->stats.npurge, arena->stats.npurge == 1 ? "" : "s",
11449: 	    arena->stats.nmadvise, arena->stats.nmadvise == 1 ? "" : "s",
11449: 	    arena->stats.purged, arena->stats.purged == 1 ? "" : "s");
11449: #  ifdef MALLOC_DECOMMIT
11449: 	malloc_printf("decommit: %I64u decommit%s, %I64u commit%s,"
11449: 	    " %I64u page%s decommitted\n",
11449: 	    arena->stats.ndecommit, (arena->stats.ndecommit == 1) ? "" : "s",
11449: 	    arena->stats.ncommit, (arena->stats.ncommit == 1) ? "" : "s",
11449: 	    arena->stats.decommitted,
11449: 	    (arena->stats.decommitted == 1) ? "" : "s");
11449: #  endif
11449: 
11286: 	malloc_printf("            allocated      nmalloc      ndalloc\n");
11286: 	malloc_printf("small:   %12Iu %12I64u %12I64u\n",
11286: 	    arena->stats.allocated_small, arena->stats.nmalloc_small,
11286: 	    arena->stats.ndalloc_small);
11286: 	malloc_printf("large:   %12Iu %12I64u %12I64u\n",
11286: 	    arena->stats.allocated_large, arena->stats.nmalloc_large,
11286: 	    arena->stats.ndalloc_large);
11286: 	malloc_printf("total:   %12Iu %12I64u %12I64u\n",
11286: 	    arena->stats.allocated_small + arena->stats.allocated_large,
11286: 	    arena->stats.nmalloc_small + arena->stats.nmalloc_large,
11286: 	    arena->stats.ndalloc_small + arena->stats.ndalloc_large);
11286: 	malloc_printf("mapped:  %12Iu\n", arena->stats.mapped);
11286: #else
11449: 	malloc_printf("dirty: %zu page%s dirty, %llu sweep%s,"
11449: 	    " %llu madvise%s, %llu page%s purged\n",
11449: 	    arena->ndirty, arena->ndirty == 1 ? "" : "s",
11449: 	    arena->stats.npurge, arena->stats.npurge == 1 ? "" : "s",
11449: 	    arena->stats.nmadvise, arena->stats.nmadvise == 1 ? "" : "s",
11449: 	    arena->stats.purged, arena->stats.purged == 1 ? "" : "s");
11449: #  ifdef MALLOC_DECOMMIT
11449: 	malloc_printf("decommit: %llu decommit%s, %llu commit%s,"
11449: 	    " %llu page%s decommitted\n",
11449: 	    arena->stats.ndecommit, (arena->stats.ndecommit == 1) ? "" : "s",
11449: 	    arena->stats.ncommit, (arena->stats.ncommit == 1) ? "" : "s",
11449: 	    arena->stats.decommitted,
11449: 	    (arena->stats.decommitted == 1) ? "" : "s");
11449: #  endif
11449: 
11449: 	malloc_printf("            allocated      nmalloc      ndalloc\n");
11286: 	malloc_printf("small:   %12zu %12llu %12llu\n",
11286: 	    arena->stats.allocated_small, arena->stats.nmalloc_small,
11286: 	    arena->stats.ndalloc_small);
11286: 	malloc_printf("large:   %12zu %12llu %12llu\n",
11286: 	    arena->stats.allocated_large, arena->stats.nmalloc_large,
11286: 	    arena->stats.ndalloc_large);
11286: 	malloc_printf("total:   %12zu %12llu %12llu\n",
11286: 	    arena->stats.allocated_small + arena->stats.allocated_large,
11286: 	    arena->stats.nmalloc_small + arena->stats.nmalloc_large,
11286: 	    arena->stats.ndalloc_small + arena->stats.ndalloc_large);
11286: 	malloc_printf("mapped:  %12zu\n", arena->stats.mapped);
11286: #endif
11286: 	malloc_printf("bins:     bin   size regs pgs  requests   newruns"
11286: 	    "    reruns maxruns curruns\n");
11286: 	for (i = 0, gap_start = UINT_MAX; i < ntbins + nqbins + nsbins; i++) {
11286: 		if (arena->bins[i].stats.nrequests == 0) {
11286: 			if (gap_start == UINT_MAX)
11286: 				gap_start = i;
11286: 		} else {
11286: 			if (gap_start != UINT_MAX) {
11286: 				if (i > gap_start + 1) {
11286: 					/* Gap of more than one size class. */
11286: 					malloc_printf("[%u..%u]\n",
11286: 					    gap_start, i - 1);
11286: 				} else {
11286: 					/* Gap of one size class. */
11286: 					malloc_printf("[%u]\n", gap_start);
11286: 				}
11286: 				gap_start = UINT_MAX;
11286: 			}
11286: 			malloc_printf(
11286: #if defined(MOZ_MEMORY_WINDOWS)
11286: 			    "%13u %1s %4u %4u %3u %9I64u %9I64u"
11286: 			    " %9I64u %7u %7u\n",
11286: #else
11286: 			    "%13u %1s %4u %4u %3u %9llu %9llu"
11286: 			    " %9llu %7lu %7lu\n",
11286: #endif
11286: 			    i,
11286: 			    i < ntbins ? "T" : i < ntbins + nqbins ? "Q" : "S",
11286: 			    arena->bins[i].reg_size,
11286: 			    arena->bins[i].nregs,
11286: 			    arena->bins[i].run_size >> pagesize_2pow,
11286: 			    arena->bins[i].stats.nrequests,
11286: 			    arena->bins[i].stats.nruns,
11286: 			    arena->bins[i].stats.reruns,
11286: 			    arena->bins[i].stats.highruns,
11286: 			    arena->bins[i].stats.curruns);
11286: 		}
11286: 	}
11286: 	if (gap_start != UINT_MAX) {
11286: 		if (i > gap_start + 1) {
11286: 			/* Gap of more than one size class. */
11286: 			malloc_printf("[%u..%u]\n", gap_start, i - 1);
11286: 		} else {
11286: 			/* Gap of one size class. */
11286: 			malloc_printf("[%u]\n", gap_start);
11286: 		}
11286: 	}
11286: }
11286: #endif
11286: 
11286: /*
11286:  * End Utility functions/macros.
11286:  */
11286: /******************************************************************************/
11286: /*
11286:  * Begin extent tree code.
11286:  */
11286: 
11286: static inline int
11286: extent_szad_comp(extent_node_t *a, extent_node_t *b)
11286: {
11286: 	int ret;
11286: 	size_t a_size = a->size;
11286: 	size_t b_size = b->size;
11286: 
11286: 	ret = (a_size > b_size) - (a_size < b_size);
11286: 	if (ret == 0) {
11286: 		uintptr_t a_addr = (uintptr_t)a->addr;
11286: 		uintptr_t b_addr = (uintptr_t)b->addr;
11286: 
11286: 		ret = (a_addr > b_addr) - (a_addr < b_addr);
11286: 	}
11286: 
11286: 	return (ret);
11286: }
11286: 
15460: /* Wrap red-black tree macros in functions. */
15460: rb_wrap(static, extent_tree_szad_, extent_tree_t, extent_node_t,
15460:     link_szad, extent_szad_comp)
11286: 
11449: static inline int
11449: extent_ad_comp(extent_node_t *a, extent_node_t *b)
11449: {
11449: 	uintptr_t a_addr = (uintptr_t)a->addr;
11449: 	uintptr_t b_addr = (uintptr_t)b->addr;
11449: 
11449: 	return ((a_addr > b_addr) - (a_addr < b_addr));
11449: }
11449: 
15460: /* Wrap red-black tree macros in functions. */
15460: rb_wrap(static, extent_tree_ad_, extent_tree_t, extent_node_t, link_ad,
15460:     extent_ad_comp)
11449: 
11286: /*
11286:  * End extent tree code.
11286:  */
11286: /******************************************************************************/
11286: /*
11286:  * Begin chunk management functions.
11286:  */
11286: 
11286: #ifdef MOZ_MEMORY_WINDOWS
26771: #ifdef MOZ_MEMORY_WINCE
26771: #define ALIGN_ADDR2OFFSET(al, ad) \
26771: 	((uintptr_t)ad & (al - 1))
26771: static void *
26771: pages_map_align(size_t size, int pfd, size_t alignment)
26771: {
26771: 	
26771: 	void *ret; 
26771: 	int offset;
26771: 	if (size % alignment)
26771: 		size += (alignment - (size % alignment));
26771: 	assert(size >= alignment);
26771: 	ret = pages_map(NULL, size, pfd);
26771: 	offset = ALIGN_ADDR2OFFSET(alignment, ret);
26771: 	if (offset) {  
26771: 		/* try to over allocate by the ammount we're offset */
26771: 		void *tmp;
26771: 		pages_unmap(ret, size);
26771: 		tmp = VirtualAlloc(NULL, size + alignment - offset, 
26771: 					 MEM_RESERVE, PAGE_NOACCESS);
26771: 		if (offset == ALIGN_ADDR2OFFSET(alignment, tmp))
26771: 			ret = VirtualAlloc((void*)((intptr_t)tmp + alignment 
26771: 						   - offset), size, MEM_COMMIT,
26771: 					   PAGE_READWRITE);
26771: 		else 
26771: 			VirtualFree(tmp, 0, MEM_RELEASE);
26771: 		offset = ALIGN_ADDR2OFFSET(alignment, ret);
26771: 		
26771: 	
26771: 		if (offset) {  
26771: 			/* over allocate to ensure we have an aligned region */
26771: 			ret = VirtualAlloc(NULL, size + alignment, MEM_RESERVE, 
26771: 					   PAGE_NOACCESS);
26771: 			offset = ALIGN_ADDR2OFFSET(alignment, ret);
26771: 			ret = VirtualAlloc((void*)((intptr_t)ret + 
26771: 						   alignment - offset),
26771: 					   size, MEM_COMMIT, PAGE_READWRITE);
26771: 		}
26771: 	}
26771: 	return (ret);
26771: }
26771: #endif
26771: 
11286: static void *
15610: pages_map(void *addr, size_t size, int pfd)
11286: {
26771: 	void *ret = NULL;
27812: #if defined(MOZ_MEMORY_WINCE) && !defined(MOZ_MEMORY_WINCE6)
26771: 	void *va_ret;
26771: 	assert(addr == NULL);
26771: 	va_ret = VirtualAlloc(addr, size, MEM_RESERVE, PAGE_NOACCESS);
26771: 	if (va_ret)
26771: 		ret = VirtualAlloc(va_ret, size, MEM_COMMIT, PAGE_READWRITE);
26771: 	assert(va_ret == ret);
27812: #else
11286: 	ret = VirtualAlloc(addr, size, MEM_COMMIT | MEM_RESERVE,
11286: 	    PAGE_READWRITE);
26488: #endif
11286: 	return (ret);
11286: }
11286: 
11286: static void
11286: pages_unmap(void *addr, size_t size)
11286: {
26771: 	if (VirtualFree(addr, 0, MEM_RELEASE) == 0) {
27812: #if defined(MOZ_MEMORY_WINCE) && !defined(MOZ_MEMORY_WINCE6)
26771: 		if (GetLastError() == ERROR_INVALID_PARAMETER) {
26771: 			MEMORY_BASIC_INFORMATION info;
26771: 			VirtualQuery(addr, &info, sizeof(info));
26771: 			if (VirtualFree(info.AllocationBase, 0, MEM_RELEASE))
26771: 				return;
26771: 		}
26771: #endif
11286: 		_malloc_message(_getprogname(),
11286: 		    ": (malloc) Error in VirtualFree()\n", "", "");
11286: 		if (opt_abort)
11286: 			abort();
11286: 	}
11286: }
11286: #elif (defined(MOZ_MEMORY_DARWIN))
11286: static void *
15610: pages_map(void *addr, size_t size, int pfd)
11286: {
11286: 	void *ret;
11286: 	kern_return_t err;
11286: 	int flags;
11286: 
11286: 	if (addr != NULL) {
11286: 		ret = addr;
11286: 		flags = 0;
11286: 	} else
11286: 		flags = VM_FLAGS_ANYWHERE;
11286: 
11286: 	err = vm_allocate((vm_map_t)mach_task_self(), (vm_address_t *)&ret,
11286: 	    (vm_size_t)size, flags);
11286: 	if (err != KERN_SUCCESS)
11286: 		ret = NULL;
11286: 
11286: 	assert(ret == NULL || (addr == NULL && ret != addr)
11286: 	    || (addr != NULL && ret == addr));
11286: 	return (ret);
11286: }
11286: 
11286: static void
11286: pages_unmap(void *addr, size_t size)
11286: {
11286: 	kern_return_t err;
11286: 
11286: 	err = vm_deallocate((vm_map_t)mach_task_self(), (vm_address_t)addr,
11286: 	    (vm_size_t)size);
11286: 	if (err != KERN_SUCCESS) {
11286: 		malloc_message(_getprogname(),
11286: 		    ": (malloc) Error in vm_deallocate(): ",
11286: 		    mach_error_string(err), "\n");
11286: 		if (opt_abort)
11286: 			abort();
11286: 	}
11286: }
11449: 
11449: #define	VM_COPY_MIN (pagesize << 5)
11449: static inline void
11449: pages_copy(void *dest, const void *src, size_t n)
11449: {
11449: 
11449: 	assert((void *)((uintptr_t)dest & ~pagesize_mask) == dest);
11449: 	assert(n >= VM_COPY_MIN);
11449: 	assert((void *)((uintptr_t)src & ~pagesize_mask) == src);
11449: 
11449: 	vm_copy(mach_task_self(), (vm_address_t)src, (vm_size_t)n,
11449: 	    (vm_address_t)dest);
11449: }
11286: #else /* MOZ_MEMORY_DARWIN */
24522: #ifdef JEMALLOC_USES_MAP_ALIGN
24522: static void *
26771: pages_map_align(size_t size, int pfd, size_t alignment)
24522: {
24522: 	void *ret;
24522: 
24522: 	/*
24522: 	 * We don't use MAP_FIXED here, because it can cause the *replacement*
24522: 	 * of existing mappings, and we only want to create new mappings.
24522: 	 */
24522: #ifdef MALLOC_PAGEFILE
24522: 	if (pfd != -1) {
26771: 		ret = mmap((void *)alignment, size, PROT_READ | PROT_WRITE, MAP_PRIVATE |
24522: 		    MAP_NOSYNC | MAP_ALIGN, pfd, 0);
24522: 	} else
24522: #endif
24522: 	       {
26771: 		ret = mmap((void *)alignment, size, PROT_READ | PROT_WRITE, MAP_PRIVATE |
24522: 		    MAP_NOSYNC | MAP_ALIGN | MAP_ANON, -1, 0);
24522: 	}
24522: 	assert(ret != NULL);
24522: 
24522: 	if (ret == MAP_FAILED)
24522: 		ret = NULL;
24522: 	return (ret);
24522: }
24522: #endif
24522: 
11286: static void *
15610: pages_map(void *addr, size_t size, int pfd)
11286: {
11286: 	void *ret;
11286: 
11286: 	/*
11286: 	 * We don't use MAP_FIXED here, because it can cause the *replacement*
11286: 	 * of existing mappings, and we only want to create new mappings.
11286: 	 */
15610: #ifdef MALLOC_PAGEFILE
15610: 	if (pfd != -1) {
15610: 		ret = mmap(addr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE |
15610: 		    MAP_NOSYNC, pfd, 0);
15610: 	} else
15610: #endif
15610: 	       {
15610: 		ret = mmap(addr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE |
15610: 		    MAP_ANON, -1, 0);
15610: 	}
11286: 	assert(ret != NULL);
11286: 
11286: 	if (ret == MAP_FAILED)
11286: 		ret = NULL;
11286: 	else if (addr != NULL && ret != addr) {
11286: 		/*
11286: 		 * We succeeded in mapping memory, but not in the right place.
11286: 		 */
11286: 		if (munmap(ret, size) == -1) {
11286: 			char buf[STRERROR_BUF];
11286: 
11286: 			strerror_r(errno, buf, sizeof(buf));
11286: 			_malloc_message(_getprogname(),
11286: 			    ": (malloc) Error in munmap(): ", buf, "\n");
11286: 			if (opt_abort)
11286: 				abort();
11286: 		}
11286: 		ret = NULL;
11286: 	}
11286: 
11286: 	assert(ret == NULL || (addr == NULL && ret != addr)
11286: 	    || (addr != NULL && ret == addr));
11286: 	return (ret);
11286: }
11286: 
11286: static void
11286: pages_unmap(void *addr, size_t size)
11286: {
11286: 
11286: 	if (munmap(addr, size) == -1) {
11286: 		char buf[STRERROR_BUF];
11286: 
11286: 		strerror_r(errno, buf, sizeof(buf));
11286: 		_malloc_message(_getprogname(),
11286: 		    ": (malloc) Error in munmap(): ", buf, "\n");
11286: 		if (opt_abort)
11286: 			abort();
11286: 	}
11286: }
11286: #endif
11286: 
16218: #ifdef MALLOC_VALIDATE
16218: static inline malloc_rtree_t *
16218: malloc_rtree_new(unsigned bits)
16218: {
16218: 	malloc_rtree_t *ret;
16218: 	unsigned bits_per_level, height, i;
16218: 
16218: 	bits_per_level = ffs(pow2_ceil((MALLOC_RTREE_NODESIZE /
16218: 	    sizeof(void *)))) - 1;
16218: 	height = bits / bits_per_level;
16218: 	if (height * bits_per_level != bits)
16218: 		height++;
16218: 	assert(height * bits_per_level >= bits);
16218: 
26488: 	ret = (malloc_rtree_t*)base_calloc(1, sizeof(malloc_rtree_t) + (sizeof(unsigned) *
16218: 	    (height - 1)));
16218: 	if (ret == NULL)
16218: 		return (NULL);
16218: 
16218: 	malloc_spin_init(&ret->lock);
16218: 	ret->height = height;
16218: 	if (bits_per_level * height > bits)
16218: 		ret->level2bits[0] = bits % bits_per_level;
16218: 	else
16218: 		ret->level2bits[0] = bits_per_level;
16218: 	for (i = 1; i < height; i++)
16218: 		ret->level2bits[i] = bits_per_level;
16218: 
26488: 	ret->root = (void**)base_calloc(1, sizeof(void *) << ret->level2bits[0]);
16218: 	if (ret->root == NULL) {
16218: 		/*
16218: 		 * We leak the rtree here, since there's no generic base
16218: 		 * deallocation.
16218: 		 */
16218: 		return (NULL);
16218: 	}
16218: 
16218: 	return (ret);
16218: }
16218: 
16218: /* The least significant bits of the key are ignored. */
11286: static inline void *
16218: malloc_rtree_get(malloc_rtree_t *rtree, uintptr_t key)
16218: {
16218: 	void *ret;
16218: 	uintptr_t subkey;
16218: 	unsigned i, lshift, height, bits;
16218: 	void **node, **child;
16218: 
16218: 	malloc_spin_lock(&rtree->lock);
16218: 	for (i = lshift = 0, height = rtree->height, node = rtree->root;
16218: 	    i < height - 1;
16218: 	    i++, lshift += bits, node = child) {
16218: 		bits = rtree->level2bits[i];
16218: 		subkey = (key << lshift) >> ((SIZEOF_PTR << 3) - bits);
26488: 		child = (void**)node[subkey];
16218: 		if (child == NULL) {
16218: 			malloc_spin_unlock(&rtree->lock);
16218: 			return (NULL);
16218: 		}
16218: 	}
16218: 
16218: 	/* node is a leaf, so it contains values rather than node pointers. */
16218: 	bits = rtree->level2bits[i];
16218: 	subkey = (key << lshift) >> ((SIZEOF_PTR << 3) - bits);
16218: 	ret = node[subkey];
16218: 	malloc_spin_unlock(&rtree->lock);
16218: 
16218: 	return (ret);
16218: }
16218: 
16218: static inline bool
16218: malloc_rtree_set(malloc_rtree_t *rtree, uintptr_t key, void *val)
16218: {
16218: 	uintptr_t subkey;
16218: 	unsigned i, lshift, height, bits;
16218: 	void **node, **child;
16218: 
16218: 	malloc_spin_lock(&rtree->lock);
16218: 	for (i = lshift = 0, height = rtree->height, node = rtree->root;
16218: 	    i < height - 1;
16218: 	    i++, lshift += bits, node = child) {
16218: 		bits = rtree->level2bits[i];
16218: 		subkey = (key << lshift) >> ((SIZEOF_PTR << 3) - bits);
26488: 		child = (void**)node[subkey];
16218: 		if (child == NULL) {
26488: 			child = (void**)base_calloc(1, sizeof(void *) <<
16218: 			    rtree->level2bits[i+1]);
16218: 			if (child == NULL) {
16218: 				malloc_spin_unlock(&rtree->lock);
16218: 				return (true);
16218: 			}
16218: 			node[subkey] = child;
16218: 		}
16218: 	}
16218: 
16218: 	/* node is a leaf, so it contains values rather than node pointers. */
16218: 	bits = rtree->level2bits[i];
16218: 	subkey = (key << lshift) >> ((SIZEOF_PTR << 3) - bits);
16218: 	node[subkey] = val;
16218: 	malloc_spin_unlock(&rtree->lock);
16218: 
16218: 	return (false);
16218: }
16218: #endif
16218: 
16218: static void *
15610: chunk_alloc_mmap(size_t size, bool pagefile)
11286: {
11286: 	void *ret;
24522: #ifndef JEMALLOC_USES_MAP_ALIGN
11286: 	size_t offset;
24522: #endif
15610: 	int pfd;
15610: 
15610: #ifdef MALLOC_PAGEFILE
15610: 	if (opt_pagefile && pagefile) {
15610: 		pfd = pagefile_init(size);
15610: 		if (pfd == -1)
15610: 			return (NULL);
15610: 	} else
15610: #endif
15610: 		pfd = -1;
11286: 
11286: 	/*
11286: 	 * Windows requires that there be a 1:1 mapping between VM
11286: 	 * allocation/deallocation operations.  Therefore, take care here to
11286: 	 * acquire the final result via one mapping operation.  This means
11286: 	 * unmapping any preliminary result that is not correctly aligned.
15610: 	 *
15610: 	 * The MALLOC_PAGEFILE code also benefits from this mapping algorithm,
15610: 	 * since it reduces the number of page files.
15610: 	 */
15610: 
24522: #ifdef JEMALLOC_USES_MAP_ALIGN
26771: 	ret = pages_map_align(size, pfd, chunksize);
24522: #else
15610: 	ret = pages_map(NULL, size, pfd);
11286: 	if (ret == NULL)
15610: 		goto RETURN;
11286: 
11286: 	offset = CHUNK_ADDR2OFFSET(ret);
11286: 	if (offset != 0) {
11286: 		/* Deallocate, then try to allocate at (ret + size - offset). */
11286: 		pages_unmap(ret, size);
15610: 		ret = pages_map((void *)((uintptr_t)ret + size - offset), size,
15610: 		    pfd);
11286: 		while (ret == NULL) {
11286: 			/*
11286: 			 * Over-allocate in order to map a memory region that
11286: 			 * is definitely large enough.
11286: 			 */
15610: 			ret = pages_map(NULL, size + chunksize, -1);
11286: 			if (ret == NULL)
15610: 				goto RETURN;
11286: 			/*
11286: 			 * Deallocate, then allocate the correct size, within
11286: 			 * the over-sized mapping.
11286: 			 */
11286: 			offset = CHUNK_ADDR2OFFSET(ret);
11286: 			pages_unmap(ret, size + chunksize);
11286: 			if (offset == 0)
15610: 				ret = pages_map(ret, size, pfd);
11286: 			else {
11449: 				ret = pages_map((void *)((uintptr_t)ret +
15610: 				    chunksize - offset), size, pfd);
11286: 			}
11286: 			/*
11286: 			 * Failure here indicates a race with another thread, so
11286: 			 * try again.
11286: 			 */
11286: 		}
11286: 	}
15610: RETURN:
24522: #endif
15610: #ifdef MALLOC_PAGEFILE
15610: 	if (pfd != -1)
15610: 		pagefile_close(pfd);
15610: #endif
16218: #ifdef MALLOC_STATS
16218: 	if (ret != NULL)
16218: 		stats_chunks.nchunks += (size / chunksize);
16218: #endif
11286: 	return (ret);
11286: }
15610: 
15610: #ifdef MALLOC_PAGEFILE
15610: static int
15610: pagefile_init(size_t size)
15610: {
15610: 	int ret;
15610: 	size_t i;
15610: 	char pagefile_path[PATH_MAX];
15610: 	char zbuf[MALLOC_PAGEFILE_WRITE_SIZE];
15610: 
15610: 	/*
15610: 	 * Create a temporary file, then immediately unlink it so that it will
15610: 	 * not persist.
15610: 	 */
15610: 	strcpy(pagefile_path, pagefile_templ);
15610: 	ret = mkstemp(pagefile_path);
15610: 	if (ret == -1)
15610: 		return (ret);
15610: 	if (unlink(pagefile_path)) {
15610: 		char buf[STRERROR_BUF];
15610: 
15610: 		strerror_r(errno, buf, sizeof(buf));
15610: 		_malloc_message(_getprogname(), ": (malloc) Error in unlink(\"",
15610: 		    pagefile_path, "\"):");
15610: 		_malloc_message(buf, "\n", "", "");
15610: 		if (opt_abort)
15610: 			abort();
15610: 	}
15610: 
15610: 	/*
15610: 	 * Write sequential zeroes to the file in order to assure that disk
15610: 	 * space is committed, with minimal fragmentation.  It would be
15610: 	 * sufficient to write one zero per disk block, but that potentially
15610: 	 * results in more system calls, for no real gain.
15610: 	 */
15610: 	memset(zbuf, 0, sizeof(zbuf));
15610: 	for (i = 0; i < size; i += sizeof(zbuf)) {
15610: 		if (write(ret, zbuf, sizeof(zbuf)) != sizeof(zbuf)) {
15610: 			if (errno != ENOSPC) {
15610: 				char buf[STRERROR_BUF];
15610: 
15610: 				strerror_r(errno, buf, sizeof(buf));
15610: 				_malloc_message(_getprogname(),
15610: 				    ": (malloc) Error in write(): ", buf, "\n");
15610: 				if (opt_abort)
15610: 					abort();
15610: 			}
15610: 			pagefile_close(ret);
15610: 			return (-1);
15610: 		}
15610: 	}
15610: 
15610: 	return (ret);
15610: }
15610: 
15610: static void
15610: pagefile_close(int pfd)
15610: {
15610: 
15610: 	if (close(pfd)) {
15610: 		char buf[STRERROR_BUF];
15610: 
15610: 		strerror_r(errno, buf, sizeof(buf));
15610: 		_malloc_message(_getprogname(),
15610: 		    ": (malloc) Error in close(): ", buf, "\n");
15610: 		if (opt_abort)
15610: 			abort();
15610: 	}
15610: }
15610: #endif
15610: 
15610: static void *
15610: chunk_alloc(size_t size, bool zero, bool pagefile)
15486: {
15486: 	void *ret;
11286: 
11286: 	assert(size != 0);
11286: 	assert((size & chunksize_mask) == 0);
11286: 
15610: 	ret = chunk_alloc_mmap(size, pagefile);
15610: 	if (ret != NULL) {
11286: 		goto RETURN;
11286: 	}
11286: 
11286: 	/* All strategies for allocation failed. */
11286: 	ret = NULL;
11286: RETURN:
11286: #ifdef MALLOC_STATS
15610: 	if (ret != NULL)
11286: 		stats_chunks.curchunks += (size / chunksize);
11286: 	if (stats_chunks.curchunks > stats_chunks.highchunks)
11286: 		stats_chunks.highchunks = stats_chunks.curchunks;
11286: #endif
11286: 
16218: #ifdef MALLOC_VALIDATE
16218: 	if (ret != NULL) {
16218: 		if (malloc_rtree_set(chunk_rtree, (uintptr_t)ret, ret)) {
16218: 			chunk_dealloc(ret, size);
16218: 			return (NULL);
16218: 		}
16218: 	}
16218: #endif
16218: 
11286: 	assert(CHUNK_ADDR2BASE(ret) == ret);
11286: 	return (ret);
11286: }
11286: 
11449: static void
11286: chunk_dealloc_mmap(void *chunk, size_t size)
11286: {
11286: 
11286: 	pages_unmap(chunk, size);
11286: }
11286: 
11286: static void
11286: chunk_dealloc(void *chunk, size_t size)
11286: {
11286: 
11286: 	assert(chunk != NULL);
11286: 	assert(CHUNK_ADDR2BASE(chunk) == chunk);
11286: 	assert(size != 0);
11286: 	assert((size & chunksize_mask) == 0);
11286: 
11286: #ifdef MALLOC_STATS
11286: 	stats_chunks.curchunks -= (size / chunksize);
11286: #endif
16218: #ifdef MALLOC_VALIDATE
16218: 	malloc_rtree_set(chunk_rtree, (uintptr_t)chunk, NULL);
16218: #endif
11286: 
11286: 	chunk_dealloc_mmap(chunk, size);
11286: }
11286: 
11286: /*
11286:  * End chunk management functions.
11286:  */
11286: /******************************************************************************/
11286: /*
11286:  * Begin arena.
11286:  */
11286: 
11286: /*
11286:  * Choose an arena based on a per-thread value (fast-path code, calls slow-path
11286:  * code if necessary).
11286:  */
11286: static inline arena_t *
11286: choose_arena(void)
11286: {
11286: 	arena_t *ret;
11286: 
11286: 	/*
11286: 	 * We can only use TLS if this is a PIC library, since for the static
11286: 	 * library version, libc's malloc is used by TLS allocation, which
11286: 	 * introduces a bootstrapping issue.
11286: 	 */
11286: #ifndef NO_TLS
11286: 	if (__isthreaded == false) {
11449: 	    /* Avoid the overhead of TLS for single-threaded operation. */
11286: 	    return (arenas[0]);
11286: 	}
11286: 
11286: #  ifdef MOZ_MEMORY_WINDOWS
26488: 	ret = (arena_t*)TlsGetValue(tlsIndex);
11286: #  else
11286: 	ret = arenas_map;
11286: #  endif
11286: 
11286: 	if (ret == NULL) {
11286: 		ret = choose_arena_hard();
11286: 		assert(ret != NULL);
11286: 	}
11286: #else
11286: 	if (__isthreaded && narenas > 1) {
11286: 		unsigned long ind;
11286: 
11286: 		/*
11286: 		 * Hash _pthread_self() to one of the arenas.  There is a prime
11286: 		 * number of arenas, so this has a reasonable chance of
11286: 		 * working.  Even so, the hashing can be easily thwarted by
11286: 		 * inconvenient _pthread_self() values.  Without specific
11286: 		 * knowledge of how _pthread_self() calculates values, we can't
11286: 		 * easily do much better than this.
11286: 		 */
11286: 		ind = (unsigned long) _pthread_self() % narenas;
11286: 
11286: 		/*
11286: 		 * Optimistially assume that arenas[ind] has been initialized.
11286: 		 * At worst, we find out that some other thread has already
11286: 		 * done so, after acquiring the lock in preparation.  Note that
11286: 		 * this lazy locking also has the effect of lazily forcing
11286: 		 * cache coherency; without the lock acquisition, there's no
11286: 		 * guarantee that modification of arenas[ind] by another thread
11286: 		 * would be seen on this CPU for an arbitrary amount of time.
11286: 		 *
11286: 		 * In general, this approach to modifying a synchronized value
11286: 		 * isn't a good idea, but in this case we only ever modify the
11286: 		 * value once, so things work out well.
11286: 		 */
11286: 		ret = arenas[ind];
11286: 		if (ret == NULL) {
11286: 			/*
11286: 			 * Avoid races with another thread that may have already
11286: 			 * initialized arenas[ind].
11286: 			 */
11286: 			malloc_spin_lock(&arenas_lock);
11286: 			if (arenas[ind] == NULL)
11286: 				ret = arenas_extend((unsigned)ind);
11286: 			else
11286: 				ret = arenas[ind];
11286: 			malloc_spin_unlock(&arenas_lock);
11286: 		}
11286: 	} else
11286: 		ret = arenas[0];
11286: #endif
11286: 
11286: 	assert(ret != NULL);
11286: 	return (ret);
11286: }
11286: 
11286: #ifndef NO_TLS
11286: /*
11286:  * Choose an arena based on a per-thread value (slow-path code only, called
11286:  * only by choose_arena()).
11286:  */
11286: static arena_t *
11286: choose_arena_hard(void)
11286: {
11286: 	arena_t *ret;
11286: 
11286: 	assert(__isthreaded);
11286: 
11286: #ifdef MALLOC_BALANCE
15460: 	/* Seed the PRNG used for arena load balancing. */
11286: 	SPRN(balance, (uint32_t)(uintptr_t)(_pthread_self()));
11286: #endif
11286: 
11286: 	if (narenas > 1) {
11286: #ifdef MALLOC_BALANCE
11286: 		unsigned ind;
11286: 
11286: 		ind = PRN(balance, narenas_2pow);
11286: 		if ((ret = arenas[ind]) == NULL) {
11286: 			malloc_spin_lock(&arenas_lock);
11286: 			if ((ret = arenas[ind]) == NULL)
11286: 				ret = arenas_extend(ind);
11286: 			malloc_spin_unlock(&arenas_lock);
11286: 		}
11286: #else
11286: 		malloc_spin_lock(&arenas_lock);
11286: 		if ((ret = arenas[next_arena]) == NULL)
11286: 			ret = arenas_extend(next_arena);
11286: 		next_arena = (next_arena + 1) % narenas;
11286: 		malloc_spin_unlock(&arenas_lock);
11286: #endif
11286: 	} else
11286: 		ret = arenas[0];
11286: 
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: 	TlsSetValue(tlsIndex, ret);
11286: #else
11286: 	arenas_map = ret;
11286: #endif
11286: 
11286: 	return (ret);
11286: }
11286: #endif
11286: 
11286: static inline int
11286: arena_chunk_comp(arena_chunk_t *a, arena_chunk_t *b)
11286: {
11286: 	uintptr_t a_chunk = (uintptr_t)a;
11286: 	uintptr_t b_chunk = (uintptr_t)b;
11286: 
11286: 	assert(a != NULL);
11286: 	assert(b != NULL);
11286: 
11286: 	return ((a_chunk > b_chunk) - (a_chunk < b_chunk));
11286: }
11286: 
15460: /* Wrap red-black tree macros in functions. */
15461: rb_wrap(static, arena_chunk_tree_dirty_, arena_chunk_tree_t,
15461:     arena_chunk_t, link_dirty, arena_chunk_comp)
11286: 
11286: static inline int
16218: arena_run_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
16218: {
16218: 	uintptr_t a_mapelm = (uintptr_t)a;
16218: 	uintptr_t b_mapelm = (uintptr_t)b;
11286: 
11286: 	assert(a != NULL);
11286: 	assert(b != NULL);
11286: 
16218: 	return ((a_mapelm > b_mapelm) - (a_mapelm < b_mapelm));
11286: }
11286: 
15460: /* Wrap red-black tree macros in functions. */
16218: rb_wrap(static, arena_run_tree_, arena_run_tree_t, arena_chunk_map_t, link,
15460:     arena_run_comp)
11286: 
16218: static inline int
16218: arena_avail_comp(arena_chunk_map_t *a, arena_chunk_map_t *b)
16218: {
16218: 	int ret;
16218: 	size_t a_size = a->bits & ~pagesize_mask;
16218: 	size_t b_size = b->bits & ~pagesize_mask;
16218: 
16218: 	ret = (a_size > b_size) - (a_size < b_size);
16218: 	if (ret == 0) {
16218: 		uintptr_t a_mapelm, b_mapelm;
16218: 
16218: 		if ((a->bits & CHUNK_MAP_KEY) == 0)
16218: 			a_mapelm = (uintptr_t)a;
11449: 		else {
16218: 			/*
16218: 			 * Treat keys as though they are lower than anything
16218: 			 * else.
16218: 			 */
16218: 			a_mapelm = 0;
16218: 		}
16218: 		b_mapelm = (uintptr_t)b;
16218: 
16218: 		ret = (a_mapelm > b_mapelm) - (a_mapelm < b_mapelm);
11449: 	}
11286: 
11286: 	return (ret);
11286: }
11286: 
16218: /* Wrap red-black tree macros in functions. */
16218: rb_wrap(static, arena_avail_tree_, arena_avail_tree_t, arena_chunk_map_t, link,
16218:     arena_avail_comp)
11286: 
11286: static inline void *
11286: arena_run_reg_alloc(arena_run_t *run, arena_bin_t *bin)
11286: {
11286: 	void *ret;
11286: 	unsigned i, mask, bit, regind;
11286: 
11286: 	assert(run->magic == ARENA_RUN_MAGIC);
11286: 	assert(run->regs_minelm < bin->regs_mask_nelms);
11286: 
11286: 	/*
11286: 	 * Move the first check outside the loop, so that run->regs_minelm can
11286: 	 * be updated unconditionally, without the possibility of updating it
11286: 	 * multiple times.
11286: 	 */
11286: 	i = run->regs_minelm;
11286: 	mask = run->regs_mask[i];
11286: 	if (mask != 0) {
11286: 		/* Usable allocation found. */
11286: 		bit = ffs((int)mask) - 1;
11286: 
11286: 		regind = ((i << (SIZEOF_INT_2POW + 3)) + bit);
11286: 		assert(regind < bin->nregs);
11286: 		ret = (void *)(((uintptr_t)run) + bin->reg0_offset
11286: 		    + (bin->reg_size * regind));
11286: 
11286: 		/* Clear bit. */
11286: 		mask ^= (1U << bit);
11286: 		run->regs_mask[i] = mask;
11286: 
11286: 		return (ret);
11286: 	}
11286: 
11286: 	for (i++; i < bin->regs_mask_nelms; i++) {
11286: 		mask = run->regs_mask[i];
11286: 		if (mask != 0) {
11286: 			/* Usable allocation found. */
11286: 			bit = ffs((int)mask) - 1;
11286: 
11286: 			regind = ((i << (SIZEOF_INT_2POW + 3)) + bit);
11286: 			assert(regind < bin->nregs);
11286: 			ret = (void *)(((uintptr_t)run) + bin->reg0_offset
11286: 			    + (bin->reg_size * regind));
11286: 
11286: 			/* Clear bit. */
11286: 			mask ^= (1U << bit);
11286: 			run->regs_mask[i] = mask;
11286: 
11286: 			/*
11286: 			 * Make a note that nothing before this element
11286: 			 * contains a free region.
11286: 			 */
11286: 			run->regs_minelm = i; /* Low payoff: + (mask == 0); */
11286: 
11286: 			return (ret);
11286: 		}
11286: 	}
11286: 	/* Not reached. */
11286: 	assert(0);
11286: 	return (NULL);
11286: }
11286: 
11286: static inline void
11286: arena_run_reg_dalloc(arena_run_t *run, arena_bin_t *bin, void *ptr, size_t size)
11286: {
11286: 	/*
11286: 	 * To divide by a number D that is not a power of two we multiply
11286: 	 * by (2^21 / D) and then right shift by 21 positions.
11286: 	 *
11286: 	 *   X / D
11286: 	 *
11286: 	 * becomes
11286: 	 *
11286: 	 *   (X * size_invs[(D >> QUANTUM_2POW_MIN) - 3]) >> SIZE_INV_SHIFT
11286: 	 */
11286: #define	SIZE_INV_SHIFT 21
11286: #define	SIZE_INV(s) (((1U << SIZE_INV_SHIFT) / (s << QUANTUM_2POW_MIN)) + 1)
11286: 	static const unsigned size_invs[] = {
11286: 	    SIZE_INV(3),
11286: 	    SIZE_INV(4), SIZE_INV(5), SIZE_INV(6), SIZE_INV(7),
11286: 	    SIZE_INV(8), SIZE_INV(9), SIZE_INV(10), SIZE_INV(11),
11286: 	    SIZE_INV(12),SIZE_INV(13), SIZE_INV(14), SIZE_INV(15),
11286: 	    SIZE_INV(16),SIZE_INV(17), SIZE_INV(18), SIZE_INV(19),
11286: 	    SIZE_INV(20),SIZE_INV(21), SIZE_INV(22), SIZE_INV(23),
11286: 	    SIZE_INV(24),SIZE_INV(25), SIZE_INV(26), SIZE_INV(27),
11286: 	    SIZE_INV(28),SIZE_INV(29), SIZE_INV(30), SIZE_INV(31)
11286: #if (QUANTUM_2POW_MIN < 4)
11286: 	    ,
11286: 	    SIZE_INV(32), SIZE_INV(33), SIZE_INV(34), SIZE_INV(35),
11286: 	    SIZE_INV(36), SIZE_INV(37), SIZE_INV(38), SIZE_INV(39),
11286: 	    SIZE_INV(40), SIZE_INV(41), SIZE_INV(42), SIZE_INV(43),
11286: 	    SIZE_INV(44), SIZE_INV(45), SIZE_INV(46), SIZE_INV(47),
11286: 	    SIZE_INV(48), SIZE_INV(49), SIZE_INV(50), SIZE_INV(51),
11286: 	    SIZE_INV(52), SIZE_INV(53), SIZE_INV(54), SIZE_INV(55),
11286: 	    SIZE_INV(56), SIZE_INV(57), SIZE_INV(58), SIZE_INV(59),
11286: 	    SIZE_INV(60), SIZE_INV(61), SIZE_INV(62), SIZE_INV(63)
11286: #endif
11286: 	};
11286: 	unsigned diff, regind, elm, bit;
11286: 
11286: 	assert(run->magic == ARENA_RUN_MAGIC);
11286: 	assert(((sizeof(size_invs)) / sizeof(unsigned)) + 3
11286: 	    >= (SMALL_MAX_DEFAULT >> QUANTUM_2POW_MIN));
11286: 
11286: 	/*
11286: 	 * Avoid doing division with a variable divisor if possible.  Using
11286: 	 * actual division here can reduce allocator throughput by over 20%!
11286: 	 */
11286: 	diff = (unsigned)((uintptr_t)ptr - (uintptr_t)run - bin->reg0_offset);
11286: 	if ((size & (size - 1)) == 0) {
11286: 		/*
11286: 		 * log2_table allows fast division of a power of two in the
11286: 		 * [1..128] range.
11286: 		 *
11286: 		 * (x / divisor) becomes (x >> log2_table[divisor - 1]).
11286: 		 */
11286: 		static const unsigned char log2_table[] = {
11286: 		    0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4,
11286: 		    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
11286: 		    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
11286: 		    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,
11286: 		    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
11286: 		    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
11286: 		    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
11286: 		    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7
11286: 		};
11286: 
11286: 		if (size <= 128)
11286: 			regind = (diff >> log2_table[size - 1]);
11286: 		else if (size <= 32768)
11286: 			regind = diff >> (8 + log2_table[(size >> 8) - 1]);
11286: 		else {
11286: 			/*
11449: 			 * The run size is too large for us to use the lookup
11286: 			 * table.  Use real division.
11286: 			 */
11286: 			regind = diff / size;
11286: 		}
11286: 	} else if (size <= ((sizeof(size_invs) / sizeof(unsigned))
11286: 	    << QUANTUM_2POW_MIN) + 2) {
11286: 		regind = size_invs[(size >> QUANTUM_2POW_MIN) - 3] * diff;
11286: 		regind >>= SIZE_INV_SHIFT;
11286: 	} else {
11286: 		/*
11286: 		 * size_invs isn't large enough to handle this size class, so
11286: 		 * calculate regind using actual division.  This only happens
11286: 		 * if the user increases small_max via the 'S' runtime
11286: 		 * configuration option.
11286: 		 */
11286: 		regind = diff / size;
11286: 	};
11286: 	assert(diff == regind * size);
11286: 	assert(regind < bin->nregs);
11286: 
11286: 	elm = regind >> (SIZEOF_INT_2POW + 3);
11286: 	if (elm < run->regs_minelm)
11286: 		run->regs_minelm = elm;
11286: 	bit = regind - (elm << (SIZEOF_INT_2POW + 3));
11286: 	assert((run->regs_mask[elm] & (1U << bit)) == 0);
11286: 	run->regs_mask[elm] |= (1U << bit);
11286: #undef SIZE_INV
11286: #undef SIZE_INV_SHIFT
11286: }
11286: 
11449: static void
16218: arena_run_split(arena_t *arena, arena_run_t *run, size_t size, bool large,
11449:     bool zero)
11286: {
11286: 	arena_chunk_t *chunk;
15461: 	size_t old_ndirty, run_ind, total_pages, need_pages, rem_pages, i;
16218: 
11449: 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
15461: 	old_ndirty = chunk->ndirty;
11449: 	run_ind = (unsigned)(((uintptr_t)run - (uintptr_t)chunk)
11449: 	    >> pagesize_2pow);
16218: 	total_pages = (chunk->map[run_ind].bits & ~pagesize_mask) >>
16218: 	    pagesize_2pow;
11449: 	need_pages = (size >> pagesize_2pow);
11449: 	assert(need_pages > 0);
11449: 	assert(need_pages <= total_pages);
11449: 	rem_pages = total_pages - need_pages;
11449: 
16218: 	arena_avail_tree_remove(&arena->runs_avail, &chunk->map[run_ind]);
16218: 
16218: 	/* Keep track of trailing unused pages for later use. */
16218: 	if (rem_pages > 0) {
16218: 		chunk->map[run_ind+need_pages].bits = (rem_pages <<
16218: 		    pagesize_2pow) | (chunk->map[run_ind+need_pages].bits &
16218: 		    pagesize_mask);
16218: 		chunk->map[run_ind+total_pages-1].bits = (rem_pages <<
16218: 		    pagesize_2pow) | (chunk->map[run_ind+total_pages-1].bits &
16218: 		    pagesize_mask);
16218: 		arena_avail_tree_insert(&arena->runs_avail,
16218: 		    &chunk->map[run_ind+need_pages]);
16218: 	}
16218: 
11449: 	for (i = 0; i < need_pages; i++) {
11286: #ifdef MALLOC_DECOMMIT
11449: 		/*
11449: 		 * Commit decommitted pages if necessary.  If a decommitted
11449: 		 * page is encountered, commit all needed adjacent decommitted
11449: 		 * pages in one operation, in order to reduce system call
11449: 		 * overhead.
11449: 		 */
16218: 		if (chunk->map[run_ind + i].bits & CHUNK_MAP_DECOMMITTED) {
11449: 			size_t j;
11449: 
11449: 			/*
11449: 			 * Advance i+j to just past the index of the last page
11449: 			 * to commit.  Clear CHUNK_MAP_DECOMMITTED along the
11449: 			 * way.
11449: 			 */
11449: 			for (j = 0; i + j < need_pages && (chunk->map[run_ind +
16218: 			    i + j].bits & CHUNK_MAP_DECOMMITTED); j++) {
16218: 				chunk->map[run_ind + i + j].bits ^=
11449: 				    CHUNK_MAP_DECOMMITTED;
11449: 			}
11449: 
11449: 			pages_commit((void *)((uintptr_t)chunk + ((run_ind + i)
11449: 			    << pagesize_2pow)), (j << pagesize_2pow));
11286: #  ifdef MALLOC_STATS
11449: 			arena->stats.ncommit++;
11449: #  endif
15610: 		} else /* No need to zero since commit zeros. */
11449: #endif
11449: 
11449: 		/* Zero if necessary. */
11449: 		if (zero) {
16218: 			if ((chunk->map[run_ind + i].bits & CHUNK_MAP_ZEROED)
11449: 			    == 0) {
15457: 				VALGRIND_MALLOCLIKE_BLOCK((void *)((uintptr_t)
15457: 				    chunk + ((run_ind + i) << pagesize_2pow)),
15457: 				    pagesize, 0, false);
11449: 				memset((void *)((uintptr_t)chunk + ((run_ind
11286: 				    + i) << pagesize_2pow)), 0, pagesize);
15457: 				VALGRIND_FREELIKE_BLOCK((void *)((uintptr_t)
15457: 				    chunk + ((run_ind + i) << pagesize_2pow)),
15457: 				    0);
16218: 				/* CHUNK_MAP_ZEROED is cleared below. */
11449: 			}
11449: 		}
11449: 
11449: 		/* Update dirty page accounting. */
16218: 		if (chunk->map[run_ind + i].bits & CHUNK_MAP_DIRTY) {
11449: 			chunk->ndirty--;
11449: 			arena->ndirty--;
16218: 			/* CHUNK_MAP_DIRTY is cleared below. */
11449: 		}
11449: 
11449: 		/* Initialize the chunk map. */
16218: 		if (large) {
16218: 			chunk->map[run_ind + i].bits = CHUNK_MAP_LARGE
16218: 			    | CHUNK_MAP_ALLOCATED;
11286: 		} else {
16218: 			chunk->map[run_ind + i].bits = (size_t)run
16218: 			    | CHUNK_MAP_ALLOCATED;
16218: 		}
16218: 	}
16218: 
16218: 	/*
16218: 	 * Set the run size only in the first element for large runs.  This is
16218: 	 * primarily a debugging aid, since the lack of size info for trailing
16218: 	 * pages only matters if the application tries to operate on an
16218: 	 * interior pointer.
16218: 	 */
16218: 	if (large)
16218: 		chunk->map[run_ind].bits |= size;
16218: 
15461: 	if (chunk->ndirty == 0 && old_ndirty > 0)
15461: 		arena_chunk_tree_dirty_remove(&arena->chunks_dirty, chunk);
11286: }
11286: 
15610: static void
15610: arena_chunk_init(arena_t *arena, arena_chunk_t *chunk)
15610: {
16218: 	arena_run_t *run;
16218: 	size_t i;
11286: 
14033: 	VALGRIND_MALLOCLIKE_BLOCK(chunk, (arena_chunk_header_npages <<
14033: 	    pagesize_2pow), 0, false);
11286: #ifdef MALLOC_STATS
11286: 	arena->stats.mapped += chunksize;
11286: #endif
11286: 
11286: 	chunk->arena = arena;
11286: 
11286: 	/*
15610: 	 * Claim that no pages are in use, since the header is merely overhead.
11286: 	 */
11449: 	chunk->ndirty = 0;
11449: 
15610: 	/* Initialize the map to contain one maximal free untouched run. */
16218: 	run = (arena_run_t *)((uintptr_t)chunk + (arena_chunk_header_npages <<
16218: 	    pagesize_2pow));
16218: 	for (i = 0; i < arena_chunk_header_npages; i++)
16218: 		chunk->map[i].bits = 0;
16218: 	chunk->map[i].bits = arena_maxclass
11286: #ifdef MALLOC_DECOMMIT
11449: 	    | CHUNK_MAP_DECOMMITTED
11449: #endif
16218: 	    | CHUNK_MAP_ZEROED;
16218: 	for (i++; i < chunk_npages-1; i++) {
16218: 		chunk->map[i].bits =
16218: #ifdef MALLOC_DECOMMIT
16218: 		    CHUNK_MAP_DECOMMITTED |
16218: #endif
16218: 		    CHUNK_MAP_ZEROED;
16218: 	}
16218: 	chunk->map[chunk_npages-1].bits = arena_maxclass
16218: #ifdef MALLOC_DECOMMIT
16218: 	    | CHUNK_MAP_DECOMMITTED
16218: #endif
16218: 	    | CHUNK_MAP_ZEROED;
11449: 
11449: #ifdef MALLOC_DECOMMIT
11449: 	/*
15610: 	 * Start out decommitted, in order to force a closer correspondence
15610: 	 * between dirty pages and committed untouched pages.
11449: 	 */
16218: 	pages_decommit(run, arena_maxclass);
11449: #  ifdef MALLOC_STATS
11449: 	arena->stats.ndecommit++;
15610: 	arena->stats.decommitted += (chunk_npages - arena_chunk_header_npages);
15610: #  endif
15610: #endif
11286: 
16218: 	/* Insert the run into the runs_avail tree. */
16218: 	arena_avail_tree_insert(&arena->runs_avail,
16218: 	    &chunk->map[arena_chunk_header_npages]);
11286: }
11286: 
11286: static void
11286: arena_chunk_dealloc(arena_t *arena, arena_chunk_t *chunk)
11286: {
16218: 
16218: 	if (arena->spare != NULL) {
16218: 		if (arena->spare->ndirty > 0) {
16218: 			arena_chunk_tree_dirty_remove(
16218: 			    &chunk->arena->chunks_dirty, arena->spare);
16218: 			arena->ndirty -= arena->spare->ndirty;
16218: 		}
16218: 		VALGRIND_FREELIKE_BLOCK(arena->spare, 0);
16218: 		chunk_dealloc((void *)arena->spare, chunksize);
16218: #ifdef MALLOC_STATS
16218: 		arena->stats.mapped -= chunksize;
16218: #endif
16218: 	}
16218: 
16218: 	/*
16218: 	 * Remove run from runs_avail, regardless of whether this chunk
11449: 	 * will be cached, so that the arena does not use it.  Dirty page
15461: 	 * flushing only uses the chunks_dirty tree, so leaving this chunk in
15461: 	 * the chunks_* trees is sufficient for that purpose.
11286: 	 */
16218: 	arena_avail_tree_remove(&arena->runs_avail,
16218: 	    &chunk->map[arena_chunk_header_npages]);
16218: 
16218: 	arena->spare = chunk;
11286: }
11286: 
11286: static arena_run_t *
16218: arena_run_alloc(arena_t *arena, arena_bin_t *bin, size_t size, bool large,
15610:     bool zero)
11286: {
11286: 	arena_chunk_t *chunk;
11286: 	arena_run_t *run;
16218: 	arena_chunk_map_t *mapelm, key;
16218: 
16218: 	assert(size <= arena_maxclass);
11286: 	assert((size & pagesize_mask) == 0);
11286: 
15610: 	chunk = NULL;
15610: 	while (true) {
11286: 		/* Search the arena's chunks for the lowest best fit. */
16218: 		key.bits = size | CHUNK_MAP_KEY;
16218: 		mapelm = arena_avail_tree_nsearch(&arena->runs_avail, &key);
16218: 		if (mapelm != NULL) {
26488: 			arena_chunk_t *run_chunk = (arena_chunk_t*)CHUNK_ADDR2BASE(mapelm);
16218: 			size_t pageind = ((uintptr_t)mapelm -
16218: 			    (uintptr_t)run_chunk->map) /
16218: 			    sizeof(arena_chunk_map_t);
16218: 
15610: 			if (chunk != NULL)
15610: 				chunk_dealloc(chunk, chunksize);
16218: 			run = (arena_run_t *)((uintptr_t)run_chunk + (pageind
16218: 			    << pagesize_2pow));
16218: 			arena_run_split(arena, run, size, large, zero);
16218: 			return (run);
16218: 		}
16218: 
16218: 		if (arena->spare != NULL) {
16218: 			/* Use the spare. */
16218: 			chunk = arena->spare;
16218: 			arena->spare = NULL;
16218: 			run = (arena_run_t *)((uintptr_t)chunk +
16218: 			    (arena_chunk_header_npages << pagesize_2pow));
16218: 			/* Insert the run into the runs_avail tree. */
16218: 			arena_avail_tree_insert(&arena->runs_avail,
16218: 			    &chunk->map[arena_chunk_header_npages]);
16218: 			arena_run_split(arena, run, size, large, zero);
11286: 			return (run);
11286: 		}
11286: 
11286: 		/*
15610: 		 * No usable runs.  Create a new chunk from which to allocate
15610: 		 * the run.
15610: 		 */
15610: 		if (chunk == NULL) {
15610: 			chunk = (arena_chunk_t *)chunk_alloc(chunksize, true,
15610: 			    true);
11286: 			if (chunk == NULL)
11286: 				return (NULL);
15610: 		}
15610: 
15610: 		arena_chunk_init(arena, chunk);
15610: 		run = (arena_run_t *)((uintptr_t)chunk +
15610: 		    (arena_chunk_header_npages << pagesize_2pow));
11286: 		/* Update page map. */
16218: 		arena_run_split(arena, run, size, large, zero);
11286: 		return (run);
11286: 	}
15610: }
11286: 
11286: static void
11286: arena_purge(arena_t *arena)
11286: {
11449: 	arena_chunk_t *chunk;
15461: 	size_t i, npages;
11286: #ifdef MALLOC_DEBUG
16218: 	size_t ndirty = 0;
15461: 	rb_foreach_begin(arena_chunk_t, link_dirty, &arena->chunks_dirty,
15461: 	    chunk) {
15461: 		ndirty += chunk->ndirty;
15461: 	} rb_foreach_end(arena_chunk_t, link_dirty, &arena->chunks_dirty, chunk)
15461: 	assert(ndirty == arena->ndirty);
11286: #endif
11449: 	assert(arena->ndirty > opt_dirty_max);
11449: 
11449: #ifdef MALLOC_STATS
11449: 	arena->stats.npurge++;
11449: #endif
11449: 
11449: 	/*
11449: 	 * Iterate downward through chunks until enough dirty memory has been
15461: 	 * purged.  Terminate as soon as possible in order to minimize the
15461: 	 * number of system calls, even if a chunk has only been partially
11449: 	 * purged.
11449: 	 */
15461: 	while (arena->ndirty > (opt_dirty_max >> 1)) {
15461: 		chunk = arena_chunk_tree_dirty_last(&arena->chunks_dirty);
15461: 		assert(chunk != NULL);
15461: 
15461: 		for (i = chunk_npages - 1; chunk->ndirty > 0; i--) {
15461: 			assert(i >= arena_chunk_header_npages);
15461: 
16218: 			if (chunk->map[i].bits & CHUNK_MAP_DIRTY) {
16218: #ifdef MALLOC_DECOMMIT
16218: 				assert((chunk->map[i].bits &
16218: 				    CHUNK_MAP_DECOMMITTED) == 0);
16218: #endif
16218: 				chunk->map[i].bits ^=
11286: #ifdef MALLOC_DECOMMIT
11449: 				    CHUNK_MAP_DECOMMITTED |
11449: #endif
16218: 				    CHUNK_MAP_DIRTY;
11449: 				/* Find adjacent dirty run(s). */
15461: 				for (npages = 1; i > arena_chunk_header_npages
16218: 				    && (chunk->map[i - 1].bits &
16218: 				    CHUNK_MAP_DIRTY); npages++) {
11449: 					i--;
11449: #ifdef MALLOC_DECOMMIT
16218: 					assert((chunk->map[i].bits &
16218: 					    CHUNK_MAP_DECOMMITTED) == 0);
16218: #endif
16218: 					chunk->map[i].bits ^=
16218: #ifdef MALLOC_DECOMMIT
16218: 					    CHUNK_MAP_DECOMMITTED |
16218: #endif
16218: 					    CHUNK_MAP_DIRTY;
15461: 				}
15461: 				chunk->ndirty -= npages;
15461: 				arena->ndirty -= npages;
11449: 
11449: #ifdef MALLOC_DECOMMIT
11449: 				pages_decommit((void *)((uintptr_t)
11449: 				    chunk + (i << pagesize_2pow)),
11449: 				    (npages << pagesize_2pow));
11449: #  ifdef MALLOC_STATS
11449: 				arena->stats.ndecommit++;
11449: 				arena->stats.decommitted += npages;
11449: #  endif
11286: #else
15461: 				madvise((void *)((uintptr_t)chunk + (i <<
16218: 				    pagesize_2pow)), (npages << pagesize_2pow),
15461: 				    MADV_FREE);
11286: #endif
11286: #ifdef MALLOC_STATS
11286: 				arena->stats.nmadvise++;
11449: 				arena->stats.purged += npages;
11449: #endif
15461: 				if (arena->ndirty <= (opt_dirty_max >> 1))
15461: 					break;
15461: 			}
15461: 		}
15461: 
15461: 		if (chunk->ndirty == 0) {
15461: 			arena_chunk_tree_dirty_remove(&arena->chunks_dirty,
15461: 			    chunk);
15461: 		}
15461: 	}
11286: }
11286: 
11286: static void
11449: arena_run_dalloc(arena_t *arena, arena_run_t *run, bool dirty)
11286: {
11286: 	arena_chunk_t *chunk;
11449: 	size_t size, run_ind, run_pages;
11449: 
11286: 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(run);
16218: 	run_ind = (size_t)(((uintptr_t)run - (uintptr_t)chunk)
11286: 	    >> pagesize_2pow);
11286: 	assert(run_ind >= arena_chunk_header_npages);
16218: 	assert(run_ind < chunk_npages);
16218: 	if ((chunk->map[run_ind].bits & CHUNK_MAP_LARGE) != 0)
16218: 		size = chunk->map[run_ind].bits & ~pagesize_mask;
16218: 	else
16218: 		size = run->bin->run_size;
11286: 	run_pages = (size >> pagesize_2pow);
11286: 
16218: 	/* Mark pages as unallocated in the chunk map. */
11449: 	if (dirty) {
11449: 		size_t i;
11449: 
11449: 		for (i = 0; i < run_pages; i++) {
16218: 			assert((chunk->map[run_ind + i].bits & CHUNK_MAP_DIRTY)
16218: 			    == 0);
16218: 			chunk->map[run_ind + i].bits = CHUNK_MAP_DIRTY;
15461: 		}
15461: 
15461: 		if (chunk->ndirty == 0) {
15461: 			arena_chunk_tree_dirty_insert(&arena->chunks_dirty,
15461: 			    chunk);
15461: 		}
15461: 		chunk->ndirty += run_pages;
15461: 		arena->ndirty += run_pages;
16218: 	} else {
11449: 		size_t i;
11449: 
11449: 		for (i = 0; i < run_pages; i++) {
16218: 			chunk->map[run_ind + i].bits &= ~(CHUNK_MAP_LARGE |
16218: 			    CHUNK_MAP_ALLOCATED);
16218: 		}
16218: 	}
16218: 	chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
16218: 	    pagesize_mask);
16218: 	chunk->map[run_ind+run_pages-1].bits = size |
16218: 	    (chunk->map[run_ind+run_pages-1].bits & pagesize_mask);
11449: 
11449: 	/* Try to coalesce forward. */
16218: 	if (run_ind + run_pages < chunk_npages &&
16218: 	    (chunk->map[run_ind+run_pages].bits & CHUNK_MAP_ALLOCATED) == 0) {
16218: 		size_t nrun_size = chunk->map[run_ind+run_pages].bits &
16218: 		    ~pagesize_mask;
16218: 
16218: 		/*
16218: 		 * Remove successor from runs_avail; the coalesced run is
16218: 		 * inserted later.
16218: 		 */
16218: 		arena_avail_tree_remove(&arena->runs_avail,
16218: 		    &chunk->map[run_ind+run_pages]);
16218: 
16218: 		size += nrun_size;
16218: 		run_pages = size >> pagesize_2pow;
16218: 
16218: 		assert((chunk->map[run_ind+run_pages-1].bits & ~pagesize_mask)
16218: 		    == nrun_size);
16218: 		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
16218: 		    pagesize_mask);
16218: 		chunk->map[run_ind+run_pages-1].bits = size |
16218: 		    (chunk->map[run_ind+run_pages-1].bits & pagesize_mask);
11449: 	}
11449: 
11449: 	/* Try to coalesce backward. */
16218: 	if (run_ind > arena_chunk_header_npages && (chunk->map[run_ind-1].bits &
16218: 	    CHUNK_MAP_ALLOCATED) == 0) {
16218: 		size_t prun_size = chunk->map[run_ind-1].bits & ~pagesize_mask;
16218: 
16218: 		run_ind -= prun_size >> pagesize_2pow;
16218: 
16218: 		/*
16218: 		 * Remove predecessor from runs_avail; the coalesced run is
16218: 		 * inserted later.
16218: 		 */
16218: 		arena_avail_tree_remove(&arena->runs_avail,
16218: 		    &chunk->map[run_ind]);
16218: 
16218: 		size += prun_size;
16218: 		run_pages = size >> pagesize_2pow;
16218: 
16218: 		assert((chunk->map[run_ind].bits & ~pagesize_mask) ==
16218: 		    prun_size);
16218: 		chunk->map[run_ind].bits = size | (chunk->map[run_ind].bits &
16218: 		    pagesize_mask);
16218: 		chunk->map[run_ind+run_pages-1].bits = size |
16218: 		    (chunk->map[run_ind+run_pages-1].bits & pagesize_mask);
16218: 	}
16218: 
16218: 	/* Insert into runs_avail, now that coalescing is complete. */
16218: 	arena_avail_tree_insert(&arena->runs_avail, &chunk->map[run_ind]);
11286: 
11286: 	/* Deallocate chunk if it is now completely unused. */
16218: 	if ((chunk->map[arena_chunk_header_npages].bits & (~pagesize_mask |
16218: 	    CHUNK_MAP_ALLOCATED)) == arena_maxclass)
11286: 		arena_chunk_dealloc(arena, chunk);
11286: 
11449: 	/* Enforce opt_dirty_max. */
11449: 	if (arena->ndirty > opt_dirty_max)
11286: 		arena_purge(arena);
11286: }
11286: 
11449: static void
16218: arena_run_trim_head(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
16218:     size_t oldsize, size_t newsize)
16218: {
16218: 	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> pagesize_2pow;
16218: 	size_t head_npages = (oldsize - newsize) >> pagesize_2pow;
16218: 
11449: 	assert(oldsize > newsize);
11449: 
11449: 	/*
16218: 	 * Update the chunk map so that arena_run_dalloc() can treat the
16218: 	 * leading run as separately allocated.
16218: 	 */
16218: 	chunk->map[pageind].bits = (oldsize - newsize) | CHUNK_MAP_LARGE |
16218: 	    CHUNK_MAP_ALLOCATED;
16218: 	chunk->map[pageind+head_npages].bits = newsize | CHUNK_MAP_LARGE |
16218: 	    CHUNK_MAP_ALLOCATED;
16218: 
16218: 	arena_run_dalloc(arena, run, false);
11449: }
11449: 
11449: static void
16218: arena_run_trim_tail(arena_t *arena, arena_chunk_t *chunk, arena_run_t *run,
16218:     size_t oldsize, size_t newsize, bool dirty)
16218: {
16218: 	size_t pageind = ((uintptr_t)run - (uintptr_t)chunk) >> pagesize_2pow;
16218: 	size_t npages = newsize >> pagesize_2pow;
16218: 
11449: 	assert(oldsize > newsize);
11449: 
11449: 	/*
16218: 	 * Update the chunk map so that arena_run_dalloc() can treat the
16218: 	 * trailing run as separately allocated.
16218: 	 */
16218: 	chunk->map[pageind].bits = newsize | CHUNK_MAP_LARGE |
16218: 	    CHUNK_MAP_ALLOCATED;
16218: 	chunk->map[pageind+npages].bits = (oldsize - newsize) | CHUNK_MAP_LARGE
16218: 	    | CHUNK_MAP_ALLOCATED;
11449: 
11449: 	arena_run_dalloc(arena, (arena_run_t *)((uintptr_t)run + newsize),
11449: 	    dirty);
11449: }
11449: 
11286: static arena_run_t *
11286: arena_bin_nonfull_run_get(arena_t *arena, arena_bin_t *bin)
11286: {
16218: 	arena_chunk_map_t *mapelm;
11286: 	arena_run_t *run;
11286: 	unsigned i, remainder;
11286: 
11286: 	/* Look for a usable run. */
16218: 	mapelm = arena_run_tree_first(&bin->runs);
16218: 	if (mapelm != NULL) {
11286: 		/* run is guaranteed to have available space. */
16218: 		arena_run_tree_remove(&bin->runs, mapelm);
16218: 		run = (arena_run_t *)(mapelm->bits & ~pagesize_mask);
11286: #ifdef MALLOC_STATS
11286: 		bin->stats.reruns++;
11286: #endif
11286: 		return (run);
11286: 	}
11286: 	/* No existing runs have any space available. */
11286: 
11286: 	/* Allocate a new run. */
16218: 	run = arena_run_alloc(arena, bin, bin->run_size, false, false);
11286: 	if (run == NULL)
11286: 		return (NULL);
15610: 	/*
15610: 	 * Don't initialize if a race in arena_run_alloc() allowed an existing
15610: 	 * run to become usable.
15610: 	 */
15610: 	if (run == bin->runcur)
15610: 		return (run);
11286: 
14033: 	VALGRIND_MALLOCLIKE_BLOCK(run, sizeof(arena_run_t) + (sizeof(unsigned) *
15457: 	    (bin->regs_mask_nelms - 1)), 0, false);
14033: 
11286: 	/* Initialize run internals. */
11286: 	run->bin = bin;
11286: 
15456: 	for (i = 0; i < bin->regs_mask_nelms - 1; i++)
11286: 		run->regs_mask[i] = UINT_MAX;
11286: 	remainder = bin->nregs & ((1U << (SIZEOF_INT_2POW + 3)) - 1);
15456: 	if (remainder == 0)
15456: 		run->regs_mask[i] = UINT_MAX;
15456: 	else {
11286: 		/* The last element has spare bits that need to be unset. */
11286: 		run->regs_mask[i] = (UINT_MAX >> ((1U << (SIZEOF_INT_2POW + 3))
11286: 		    - remainder));
11286: 	}
11286: 
11286: 	run->regs_minelm = 0;
11286: 
11286: 	run->nfree = bin->nregs;
11286: #ifdef MALLOC_DEBUG
11286: 	run->magic = ARENA_RUN_MAGIC;
11286: #endif
11286: 
11286: #ifdef MALLOC_STATS
11286: 	bin->stats.nruns++;
11286: 	bin->stats.curruns++;
11286: 	if (bin->stats.curruns > bin->stats.highruns)
11286: 		bin->stats.highruns = bin->stats.curruns;
11286: #endif
11286: 	return (run);
11286: }
11286: 
11286: /* bin->runcur must have space available before this function is called. */
11286: static inline void *
11286: arena_bin_malloc_easy(arena_t *arena, arena_bin_t *bin, arena_run_t *run)
11286: {
11286: 	void *ret;
11286: 
11286: 	assert(run->magic == ARENA_RUN_MAGIC);
11286: 	assert(run->nfree > 0);
11286: 
11286: 	ret = arena_run_reg_alloc(run, bin);
11286: 	assert(ret != NULL);
11286: 	run->nfree--;
11286: 
11286: 	return (ret);
11286: }
11286: 
11286: /* Re-fill bin->runcur, then call arena_bin_malloc_easy(). */
11286: static void *
11286: arena_bin_malloc_hard(arena_t *arena, arena_bin_t *bin)
11286: {
11286: 
11286: 	bin->runcur = arena_bin_nonfull_run_get(arena, bin);
11286: 	if (bin->runcur == NULL)
11286: 		return (NULL);
11286: 	assert(bin->runcur->magic == ARENA_RUN_MAGIC);
11286: 	assert(bin->runcur->nfree > 0);
11286: 
11286: 	return (arena_bin_malloc_easy(arena, bin, bin->runcur));
11286: }
11286: 
11286: /*
11286:  * Calculate bin->run_size such that it meets the following constraints:
11286:  *
11286:  *   *) bin->run_size >= min_run_size
11286:  *   *) bin->run_size <= arena_maxclass
11286:  *   *) bin->run_size <= RUN_MAX_SMALL
11286:  *   *) run header overhead <= RUN_MAX_OVRHD (or header overhead relaxed).
11286:  *
11286:  * bin->nregs, bin->regs_mask_nelms, and bin->reg0_offset are
11286:  * also calculated here, since these settings are all interdependent.
11286:  */
11286: static size_t
11286: arena_bin_run_size_calc(arena_bin_t *bin, size_t min_run_size)
11286: {
11286: 	size_t try_run_size, good_run_size;
11286: 	unsigned good_nregs, good_mask_nelms, good_reg0_offset;
11286: 	unsigned try_nregs, try_mask_nelms, try_reg0_offset;
11286: 
11286: 	assert(min_run_size >= pagesize);
11286: 	assert(min_run_size <= arena_maxclass);
11286: 	assert(min_run_size <= RUN_MAX_SMALL);
11286: 
11286: 	/*
11286: 	 * Calculate known-valid settings before entering the run_size
11286: 	 * expansion loop, so that the first part of the loop always copies
11286: 	 * valid settings.
11286: 	 *
11286: 	 * The do..while loop iteratively reduces the number of regions until
11286: 	 * the run header and the regions no longer overlap.  A closed formula
11286: 	 * would be quite messy, since there is an interdependency between the
11286: 	 * header's mask length and the number of regions.
11286: 	 */
11286: 	try_run_size = min_run_size;
11286: 	try_nregs = ((try_run_size - sizeof(arena_run_t)) / bin->reg_size)
11286: 	    + 1; /* Counter-act try_nregs-- in loop. */
11286: 	do {
11286: 		try_nregs--;
11286: 		try_mask_nelms = (try_nregs >> (SIZEOF_INT_2POW + 3)) +
11286: 		    ((try_nregs & ((1U << (SIZEOF_INT_2POW + 3)) - 1)) ? 1 : 0);
11286: 		try_reg0_offset = try_run_size - (try_nregs * bin->reg_size);
11286: 	} while (sizeof(arena_run_t) + (sizeof(unsigned) * (try_mask_nelms - 1))
11286: 	    > try_reg0_offset);
11286: 
11286: 	/* run_size expansion loop. */
11286: 	do {
11286: 		/*
11286: 		 * Copy valid settings before trying more aggressive settings.
11286: 		 */
11286: 		good_run_size = try_run_size;
11286: 		good_nregs = try_nregs;
11286: 		good_mask_nelms = try_mask_nelms;
11286: 		good_reg0_offset = try_reg0_offset;
11286: 
11286: 		/* Try more aggressive settings. */
11286: 		try_run_size += pagesize;
11286: 		try_nregs = ((try_run_size - sizeof(arena_run_t)) /
11286: 		    bin->reg_size) + 1; /* Counter-act try_nregs-- in loop. */
11286: 		do {
11286: 			try_nregs--;
11286: 			try_mask_nelms = (try_nregs >> (SIZEOF_INT_2POW + 3)) +
11286: 			    ((try_nregs & ((1U << (SIZEOF_INT_2POW + 3)) - 1)) ?
11286: 			    1 : 0);
11286: 			try_reg0_offset = try_run_size - (try_nregs *
11286: 			    bin->reg_size);
11286: 		} while (sizeof(arena_run_t) + (sizeof(unsigned) *
11286: 		    (try_mask_nelms - 1)) > try_reg0_offset);
11286: 	} while (try_run_size <= arena_maxclass && try_run_size <= RUN_MAX_SMALL
11286: 	    && RUN_MAX_OVRHD * (bin->reg_size << 3) > RUN_MAX_OVRHD_RELAX
11286: 	    && (try_reg0_offset << RUN_BFP) > RUN_MAX_OVRHD * try_run_size);
11286: 
11286: 	assert(sizeof(arena_run_t) + (sizeof(unsigned) * (good_mask_nelms - 1))
11286: 	    <= good_reg0_offset);
11286: 	assert((good_mask_nelms << (SIZEOF_INT_2POW + 3)) >= good_nregs);
11286: 
11286: 	/* Copy final settings. */
11286: 	bin->run_size = good_run_size;
11286: 	bin->nregs = good_nregs;
11286: 	bin->regs_mask_nelms = good_mask_nelms;
11286: 	bin->reg0_offset = good_reg0_offset;
11286: 
11286: 	return (good_run_size);
11286: }
11286: 
11286: #ifdef MALLOC_BALANCE
11286: static inline void
11286: arena_lock_balance(arena_t *arena)
11286: {
11286: 	unsigned contention;
11286: 
11286: 	contention = malloc_spin_lock(&arena->lock);
11286: 	if (narenas > 1) {
11286: 		/*
11286: 		 * Calculate the exponentially averaged contention for this
11286: 		 * arena.  Due to integer math always rounding down, this value
11286: 		 * decays somewhat faster then normal.
11286: 		 */
11286: 		arena->contention = (((uint64_t)arena->contention
11286: 		    * (uint64_t)((1U << BALANCE_ALPHA_INV_2POW)-1))
11286: 		    + (uint64_t)contention) >> BALANCE_ALPHA_INV_2POW;
11449: 		if (arena->contention >= opt_balance_threshold)
11449: 			arena_lock_balance_hard(arena);
11449: 	}
11449: }
11449: 
11449: static void
11449: arena_lock_balance_hard(arena_t *arena)
11449: {
11286: 	uint32_t ind;
11286: 
11286: 	arena->contention = 0;
11286: #ifdef MALLOC_STATS
11286: 	arena->stats.nbalance++;
11286: #endif
11286: 	ind = PRN(balance, narenas_2pow);
11286: 	if (arenas[ind] != NULL) {
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: 		TlsSetValue(tlsIndex, arenas[ind]);
11286: #else
11286: 		arenas_map = arenas[ind];
11286: #endif
11286: 	} else {
11286: 		malloc_spin_lock(&arenas_lock);
11286: 		if (arenas[ind] != NULL) {
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: 			TlsSetValue(tlsIndex, arenas[ind]);
11286: #else
11286: 			arenas_map = arenas[ind];
11286: #endif
11286: 		} else {
11286: #ifdef MOZ_MEMORY_WINDOWS
11449: 			TlsSetValue(tlsIndex, arenas_extend(ind));
11286: #else
11286: 			arenas_map = arenas_extend(ind);
11286: #endif
11286: 		}
11286: 		malloc_spin_unlock(&arenas_lock);
11286: 	}
11286: }
11449: #endif
11449: 
11449: static inline void *
11449: arena_malloc_small(arena_t *arena, size_t size, bool zero)
11286: {
11286: 	void *ret;
11286: 	arena_bin_t *bin;
11286: 	arena_run_t *run;
11286: 
11286: 	if (size < small_min) {
11286: 		/* Tiny. */
11286: 		size = pow2_ceil(size);
11286: 		bin = &arena->bins[ffs((int)(size >> (TINY_MIN_2POW +
11286: 		    1)))];
11286: #if (!defined(NDEBUG) || defined(MALLOC_STATS))
11286: 		/*
11286: 		 * Bin calculation is always correct, but we may need
11286: 		 * to fix size for the purposes of assertions and/or
11286: 		 * stats accuracy.
11286: 		 */
11286: 		if (size < (1U << TINY_MIN_2POW))
11286: 			size = (1U << TINY_MIN_2POW);
11286: #endif
11286: 	} else if (size <= small_max) {
11286: 		/* Quantum-spaced. */
11286: 		size = QUANTUM_CEILING(size);
11286: 		bin = &arena->bins[ntbins + (size >> opt_quantum_2pow)
11286: 		    - 1];
11286: 	} else {
11286: 		/* Sub-page. */
11286: 		size = pow2_ceil(size);
11286: 		bin = &arena->bins[ntbins + nqbins
11286: 		    + (ffs((int)(size >> opt_small_max_2pow)) - 2)];
11286: 	}
11286: 	assert(size == bin->reg_size);
11286: 
11286: #ifdef MALLOC_BALANCE
11286: 	arena_lock_balance(arena);
11286: #else
11286: 	malloc_spin_lock(&arena->lock);
11286: #endif
11286: 	if ((run = bin->runcur) != NULL && run->nfree > 0)
11286: 		ret = arena_bin_malloc_easy(arena, bin, run);
11286: 	else
11286: 		ret = arena_bin_malloc_hard(arena, bin);
11286: 
11286: 	if (ret == NULL) {
11286: 		malloc_spin_unlock(&arena->lock);
11286: 		return (NULL);
11286: 	}
11286: 
11286: #ifdef MALLOC_STATS
11286: 	bin->stats.nrequests++;
11286: 	arena->stats.nmalloc_small++;
11286: 	arena->stats.allocated_small += size;
11286: #endif
11286: 	malloc_spin_unlock(&arena->lock);
11286: 
14033: 	VALGRIND_MALLOCLIKE_BLOCK(ret, size, 0, zero);
11286: 	if (zero == false) {
11449: #ifdef MALLOC_FILL
11286: 		if (opt_junk)
11286: 			memset(ret, 0xa5, size);
11286: 		else if (opt_zero)
11286: 			memset(ret, 0, size);
11449: #endif
11286: 	} else
11286: 		memset(ret, 0, size);
11449: 
11449: 	return (ret);
11449: }
11449: 
11449: static void *
11449: arena_malloc_large(arena_t *arena, size_t size, bool zero)
11449: {
11449: 	void *ret;
11449: 
11286: 	/* Large allocation. */
11286: 	size = PAGE_CEILING(size);
11286: #ifdef MALLOC_BALANCE
11286: 	arena_lock_balance(arena);
11286: #else
11286: 	malloc_spin_lock(&arena->lock);
11286: #endif
16218: 	ret = (void *)arena_run_alloc(arena, NULL, size, true, zero);
11286: 	if (ret == NULL) {
11286: 		malloc_spin_unlock(&arena->lock);
11286: 		return (NULL);
11286: 	}
11286: #ifdef MALLOC_STATS
11286: 	arena->stats.nmalloc_large++;
11286: 	arena->stats.allocated_large += size;
11286: #endif
11286: 	malloc_spin_unlock(&arena->lock);
11286: 
14033: 	VALGRIND_MALLOCLIKE_BLOCK(ret, size, 0, zero);
11286: 	if (zero == false) {
11449: #ifdef MALLOC_FILL
11286: 		if (opt_junk)
11286: 			memset(ret, 0xa5, size);
11286: 		else if (opt_zero)
11286: 			memset(ret, 0, size);
11449: #endif
11286: 	}
11286: 
11286: 	return (ret);
11286: }
11286: 
11449: static inline void *
11449: arena_malloc(arena_t *arena, size_t size, bool zero)
11286: {
11449: 
11449: 	assert(arena != NULL);
11449: 	assert(arena->magic == ARENA_MAGIC);
11449: 	assert(size != 0);
11449: 	assert(QUANTUM_CEILING(size) <= arena_maxclass);
11449: 
11449: 	if (size <= bin_maxclass) {
11449: 		return (arena_malloc_small(arena, size, zero));
11449: 	} else
11449: 		return (arena_malloc_large(arena, size, zero));
11449: }
11449: 
11449: static inline void *
11449: imalloc(size_t size)
11286: {
11449: 
11449: 	assert(size != 0);
11449: 
11449: 	if (size <= arena_maxclass)
11449: 		return (arena_malloc(choose_arena(), size, false));
11449: 	else
11449: 		return (huge_malloc(size, false));
11449: }
11449: 
11449: static inline void *
11449: icalloc(size_t size)
11449: {
11449: 
11449: 	if (size <= arena_maxclass)
11449: 		return (arena_malloc(choose_arena(), size, true));
11449: 	else
11449: 		return (huge_malloc(size, true));
11286: }
11286: 
11286: /* Only handles large allocations that require more than page alignment. */
11286: static void *
11286: arena_palloc(arena_t *arena, size_t alignment, size_t size, size_t alloc_size)
11286: {
11286: 	void *ret;
11286: 	size_t offset;
11286: 	arena_chunk_t *chunk;
11286: 
11286: 	assert((size & pagesize_mask) == 0);
11286: 	assert((alignment & pagesize_mask) == 0);
11286: 
11286: #ifdef MALLOC_BALANCE
11286: 	arena_lock_balance(arena);
11286: #else
11286: 	malloc_spin_lock(&arena->lock);
11286: #endif
16218: 	ret = (void *)arena_run_alloc(arena, NULL, alloc_size, true, false);
11286: 	if (ret == NULL) {
11286: 		malloc_spin_unlock(&arena->lock);
11286: 		return (NULL);
11286: 	}
11286: 
11286: 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ret);
11286: 
11286: 	offset = (uintptr_t)ret & (alignment - 1);
11286: 	assert((offset & pagesize_mask) == 0);
11286: 	assert(offset < alloc_size);
16218: 	if (offset == 0)
26488: 		arena_run_trim_tail(arena, chunk, (arena_run_t*)ret, alloc_size, size, false);
16218: 	else {
11286: 		size_t leadsize, trailsize;
11286: 
11286: 		leadsize = alignment - offset;
11286: 		if (leadsize > 0) {
26488: 			arena_run_trim_head(arena, chunk, (arena_run_t*)ret, alloc_size,
11449: 			    alloc_size - leadsize);
11286: 			ret = (void *)((uintptr_t)ret + leadsize);
11286: 		}
11286: 
11286: 		trailsize = alloc_size - leadsize - size;
11286: 		if (trailsize != 0) {
11286: 			/* Trim trailing space. */
11286: 			assert(trailsize < alloc_size);
26488: 			arena_run_trim_tail(arena, chunk, (arena_run_t*)ret, size + trailsize,
16218: 			    size, false);
11449: 		}
11286: 	}
11286: 
11286: #ifdef MALLOC_STATS
11286: 	arena->stats.nmalloc_large++;
11286: 	arena->stats.allocated_large += size;
11286: #endif
11286: 	malloc_spin_unlock(&arena->lock);
11286: 
14033: 	VALGRIND_MALLOCLIKE_BLOCK(ret, size, 0, false);
11449: #ifdef MALLOC_FILL
11286: 	if (opt_junk)
11286: 		memset(ret, 0xa5, size);
11286: 	else if (opt_zero)
11286: 		memset(ret, 0, size);
11449: #endif
11449: 	return (ret);
11449: }
11449: 
11449: static inline void *
11449: ipalloc(size_t alignment, size_t size)
11449: {
11449: 	void *ret;
11449: 	size_t ceil_size;
11449: 
11449: 	/*
11449: 	 * Round size up to the nearest multiple of alignment.
11449: 	 *
11449: 	 * This done, we can take advantage of the fact that for each small
11449: 	 * size class, every object is aligned at the smallest power of two
11449: 	 * that is non-zero in the base two representation of the size.  For
11449: 	 * example:
11449: 	 *
11449: 	 *   Size |   Base 2 | Minimum alignment
11449: 	 *   -----+----------+------------------
11449: 	 *     96 |  1100000 |  32
11449: 	 *    144 | 10100000 |  32
11449: 	 *    192 | 11000000 |  64
11449: 	 *
11449: 	 * Depending on runtime settings, it is possible that arena_malloc()
11449: 	 * will further round up to a power of two, but that never causes
11449: 	 * correctness issues.
11449: 	 */
11449: 	ceil_size = (size + (alignment - 1)) & (-alignment);
11449: 	/*
11449: 	 * (ceil_size < size) protects against the combination of maximal
11449: 	 * alignment and size greater than maximal alignment.
11449: 	 */
11449: 	if (ceil_size < size) {
11449: 		/* size_t overflow. */
11449: 		return (NULL);
11449: 	}
11449: 
11449: 	if (ceil_size <= pagesize || (alignment <= pagesize
11449: 	    && ceil_size <= arena_maxclass))
11449: 		ret = arena_malloc(choose_arena(), ceil_size, false);
11449: 	else {
11449: 		size_t run_size;
11449: 
11449: 		/*
11449: 		 * We can't achieve sub-page alignment, so round up alignment
11449: 		 * permanently; it makes later calculations simpler.
11449: 		 */
11449: 		alignment = PAGE_CEILING(alignment);
11449: 		ceil_size = PAGE_CEILING(size);
11449: 		/*
11449: 		 * (ceil_size < size) protects against very large sizes within
11449: 		 * pagesize of SIZE_T_MAX.
11449: 		 *
11449: 		 * (ceil_size + alignment < ceil_size) protects against the
11449: 		 * combination of maximal alignment and ceil_size large enough
11449: 		 * to cause overflow.  This is similar to the first overflow
11449: 		 * check above, but it needs to be repeated due to the new
11449: 		 * ceil_size value, which may now be *equal* to maximal
11449: 		 * alignment, whereas before we only detected overflow if the
11449: 		 * original size was *greater* than maximal alignment.
11449: 		 */
11449: 		if (ceil_size < size || ceil_size + alignment < ceil_size) {
11449: 			/* size_t overflow. */
11449: 			return (NULL);
11449: 		}
11449: 
11449: 		/*
11449: 		 * Calculate the size of the over-size run that arena_palloc()
11449: 		 * would need to allocate in order to guarantee the alignment.
11449: 		 */
11449: 		if (ceil_size >= alignment)
11449: 			run_size = ceil_size + alignment - pagesize;
11449: 		else {
11449: 			/*
11449: 			 * It is possible that (alignment << 1) will cause
11449: 			 * overflow, but it doesn't matter because we also
11449: 			 * subtract pagesize, which in the case of overflow
11449: 			 * leaves us with a very large run_size.  That causes
11449: 			 * the first conditional below to fail, which means
11449: 			 * that the bogus run_size value never gets used for
11449: 			 * anything important.
11449: 			 */
11449: 			run_size = (alignment << 1) - pagesize;
11449: 		}
11449: 
11449: 		if (run_size <= arena_maxclass) {
11449: 			ret = arena_palloc(choose_arena(), alignment, ceil_size,
11449: 			    run_size);
11449: 		} else if (alignment <= chunksize)
11449: 			ret = huge_malloc(ceil_size, false);
11449: 		else
11449: 			ret = huge_palloc(alignment, ceil_size);
11449: 	}
11449: 
11449: 	assert(((uintptr_t)ret & (alignment - 1)) == 0);
11286: 	return (ret);
11286: }
11286: 
11286: /* Return the size of the allocation pointed to by ptr. */
11286: static size_t
11286: arena_salloc(const void *ptr)
11286: {
11286: 	size_t ret;
11286: 	arena_chunk_t *chunk;
16218: 	size_t pageind, mapbits;
11286: 
11286: 	assert(ptr != NULL);
11286: 	assert(CHUNK_ADDR2BASE(ptr) != ptr);
11286: 
11286: 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
11286: 	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> pagesize_2pow);
16218: 	mapbits = chunk->map[pageind].bits;
16218: 	assert((mapbits & CHUNK_MAP_ALLOCATED) != 0);
16218: 	if ((mapbits & CHUNK_MAP_LARGE) == 0) {
16218: 		arena_run_t *run = (arena_run_t *)(mapbits & ~pagesize_mask);
11286: 		assert(run->magic == ARENA_RUN_MAGIC);
11286: 		ret = run->bin->reg_size;
11449: 	} else {
16218: 		ret = mapbits & ~pagesize_mask;
16218: 		assert(ret != 0);
11449: 	}
11449: 
11449: 	return (ret);
11449: }
11449: 
14259: #if (defined(MALLOC_VALIDATE) || defined(MOZ_MEMORY_DARWIN))
14259: /*
14259:  * Validate ptr before assuming that it points to an allocation.  Currently,
14259:  * the following validation is performed:
14259:  *
14259:  * + Check that ptr is not NULL.
14259:  *
14259:  * + Check that ptr lies within a mapped chunk.
14259:  */
14259: static inline size_t
14259: isalloc_validate(const void *ptr)
14259: {
14259: 	arena_chunk_t *chunk;
14259: 
16218: 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
16218: 	if (chunk == NULL)
14259: 		return (0);
14259: 
16218: 	if (malloc_rtree_get(chunk_rtree, (uintptr_t)chunk) == NULL)
16218: 		return (0);
16218: 
14259: 	if (chunk != ptr) {
16218: 		assert(chunk->arena->magic == ARENA_MAGIC);
14259: 		return (arena_salloc(ptr));
14259: 	} else {
14259: 		size_t ret;
14259: 		extent_node_t *node;
14259: 		extent_node_t key;
14259: 
14259: 		/* Chunk. */
14259: 		key.addr = (void *)chunk;
14259: 		malloc_mutex_lock(&huge_mtx);
15460: 		node = extent_tree_ad_search(&huge, &key);
14259: 		if (node != NULL)
14259: 			ret = node->size;
14259: 		else
14259: 			ret = 0;
14259: 		malloc_mutex_unlock(&huge_mtx);
14259: 		return (ret);
14259: 	}
14259: }
14259: #endif
14259: 
11449: static inline size_t
11449: isalloc(const void *ptr)
11449: {
11449: 	size_t ret;
11449: 	arena_chunk_t *chunk;
11449: 
11449: 	assert(ptr != NULL);
11449: 
11449: 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
11449: 	if (chunk != ptr) {
11449: 		/* Region. */
11449: 		assert(chunk->arena->magic == ARENA_MAGIC);
11449: 
11449: 		ret = arena_salloc(ptr);
11449: 	} else {
11449: 		extent_node_t *node, key;
11449: 
11449: 		/* Chunk (huge allocation). */
11449: 
11449: 		malloc_mutex_lock(&huge_mtx);
11449: 
11449: 		/* Extract from tree of huge allocations. */
11449: 		key.addr = __DECONST(void *, ptr);
15460: 		node = extent_tree_ad_search(&huge, &key);
11449: 		assert(node != NULL);
11449: 
11449: 		ret = node->size;
11449: 
11449: 		malloc_mutex_unlock(&huge_mtx);
11449: 	}
11449: 
11449: 	return (ret);
11449: }
11449: 
11449: static inline void
11449: arena_dalloc_small(arena_t *arena, arena_chunk_t *chunk, void *ptr,
16218:     arena_chunk_map_t *mapelm)
11449: {
11449: 	arena_run_t *run;
11449: 	arena_bin_t *bin;
11449: 	size_t size;
11449: 
16218: 	run = (arena_run_t *)(mapelm->bits & ~pagesize_mask);
11449: 	assert(run->magic == ARENA_RUN_MAGIC);
11449: 	bin = run->bin;
11449: 	size = bin->reg_size;
11449: 
11449: #ifdef MALLOC_FILL
11449: 	if (opt_junk)
11449: 		memset(ptr, 0x5a, size);
11449: #endif
11449: 
11449: 	arena_run_reg_dalloc(run, bin, ptr, size);
11449: 	run->nfree++;
11449: 
11449: 	if (run->nfree == bin->nregs) {
11449: 		/* Deallocate run. */
11449: 		if (run == bin->runcur)
11449: 			bin->runcur = NULL;
11449: 		else if (bin->nregs != 1) {
16218: 			size_t run_pageind = (((uintptr_t)run -
16218: 			    (uintptr_t)chunk)) >> pagesize_2pow;
16218: 			arena_chunk_map_t *run_mapelm =
16218: 			    &chunk->map[run_pageind];
11449: 			/*
11449: 			 * This block's conditional is necessary because if the
11449: 			 * run only contains one region, then it never gets
11449: 			 * inserted into the non-full runs tree.
11449: 			 */
16218: 			assert(arena_run_tree_search(&bin->runs, run_mapelm) ==
16218: 			    run_mapelm);
16218: 			arena_run_tree_remove(&bin->runs, run_mapelm);
11449: 		}
11449: #ifdef MALLOC_DEBUG
11449: 		run->magic = 0;
11449: #endif
14033: 		VALGRIND_FREELIKE_BLOCK(run, 0);
11449: 		arena_run_dalloc(arena, run, true);
11449: #ifdef MALLOC_STATS
11449: 		bin->stats.curruns--;
11449: #endif
11449: 	} else if (run->nfree == 1 && run != bin->runcur) {
11449: 		/*
11449: 		 * Make sure that bin->runcur always refers to the lowest
11449: 		 * non-full run, if one exists.
11449: 		 */
11449: 		if (bin->runcur == NULL)
11449: 			bin->runcur = run;
11449: 		else if ((uintptr_t)run < (uintptr_t)bin->runcur) {
11449: 			/* Switch runcur. */
11449: 			if (bin->runcur->nfree > 0) {
16218: 				arena_chunk_t *runcur_chunk =
26488: 				    (arena_chunk_t*)CHUNK_ADDR2BASE(bin->runcur);
16218: 				size_t runcur_pageind =
16218: 				    (((uintptr_t)bin->runcur -
16218: 				    (uintptr_t)runcur_chunk)) >> pagesize_2pow;
16218: 				arena_chunk_map_t *runcur_mapelm =
16218: 				    &runcur_chunk->map[runcur_pageind];
16218: 
11449: 				/* Insert runcur. */
15610: 				assert(arena_run_tree_search(&bin->runs,
16218: 				    runcur_mapelm) == NULL);
16218: 				arena_run_tree_insert(&bin->runs,
16218: 				    runcur_mapelm);
11449: 			}
11449: 			bin->runcur = run;
15610: 		} else {
16218: 			size_t run_pageind = (((uintptr_t)run -
16218: 			    (uintptr_t)chunk)) >> pagesize_2pow;
16218: 			arena_chunk_map_t *run_mapelm =
16218: 			    &chunk->map[run_pageind];
16218: 
16218: 			assert(arena_run_tree_search(&bin->runs, run_mapelm) ==
16218: 			    NULL);
16218: 			arena_run_tree_insert(&bin->runs, run_mapelm);
11449: 		}
15610: 	}
11449: #ifdef MALLOC_STATS
11449: 	arena->stats.allocated_small -= size;
11449: 	arena->stats.ndalloc_small++;
11449: #endif
11449: }
11449: 
11449: static void
11449: arena_dalloc_large(arena_t *arena, arena_chunk_t *chunk, void *ptr)
11449: {
11449: 	/* Large allocation. */
11449: 	malloc_spin_lock(&arena->lock);
11449: 
11449: #ifdef MALLOC_FILL
11449: #ifndef MALLOC_STATS
11449: 	if (opt_junk)
11449: #endif
11449: #endif
11449: 	{
16218: 		size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >>
16218: 		    pagesize_2pow;
16218: 		size_t size = chunk->map[pageind].bits & ~pagesize_mask;
16218: 
11449: #ifdef MALLOC_FILL
11449: #ifdef MALLOC_STATS
11449: 		if (opt_junk)
11449: #endif
11449: 			memset(ptr, 0x5a, size);
11449: #endif
11449: #ifdef MALLOC_STATS
11449: 		arena->stats.allocated_large -= size;
11449: #endif
11449: 	}
11449: #ifdef MALLOC_STATS
11449: 	arena->stats.ndalloc_large++;
11449: #endif
11449: 
11449: 	arena_run_dalloc(arena, (arena_run_t *)ptr, true);
11449: 	malloc_spin_unlock(&arena->lock);
11449: }
11449: 
11449: static inline void
11449: arena_dalloc(arena_t *arena, arena_chunk_t *chunk, void *ptr)
11449: {
11449: 	size_t pageind;
11449: 	arena_chunk_map_t *mapelm;
11449: 
11449: 	assert(arena != NULL);
11449: 	assert(arena->magic == ARENA_MAGIC);
11449: 	assert(chunk->arena == arena);
11449: 	assert(ptr != NULL);
11449: 	assert(CHUNK_ADDR2BASE(ptr) != ptr);
11449: 
11449: 	pageind = (((uintptr_t)ptr - (uintptr_t)chunk) >> pagesize_2pow);
11449: 	mapelm = &chunk->map[pageind];
16218: 	assert((mapelm->bits & CHUNK_MAP_ALLOCATED) != 0);
16218: 	if ((mapelm->bits & CHUNK_MAP_LARGE) == 0) {
11449: 		/* Small allocation. */
11449: 		malloc_spin_lock(&arena->lock);
16218: 		arena_dalloc_small(arena, chunk, ptr, mapelm);
11449: 		malloc_spin_unlock(&arena->lock);
16218: 	} else
11449: 		arena_dalloc_large(arena, chunk, ptr);
14033: 	VALGRIND_FREELIKE_BLOCK(ptr, 0);
11449: }
11449: 
11449: static inline void
11449: idalloc(void *ptr)
11286: {
11286: 	arena_chunk_t *chunk;
11449: 
11449: 	assert(ptr != NULL);
11286: 
11286: 	chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
11449: 	if (chunk != ptr)
11449: 		arena_dalloc(chunk->arena, chunk, ptr);
11449: 	else
11449: 		huge_dalloc(ptr);
11449: }
11449: 
11449: static void
11773: arena_ralloc_large_shrink(arena_t *arena, arena_chunk_t *chunk, void *ptr,
11449:     size_t size, size_t oldsize)
11449: {
11449: 
11449: 	assert(size < oldsize);
11449: 
11286: 	/*
11286: 	 * Shrink the run, and make trailing pages available for other
11286: 	 * allocations.
11286: 	 */
11286: #ifdef MALLOC_BALANCE
11286: 	arena_lock_balance(arena);
11286: #else
11286: 	malloc_spin_lock(&arena->lock);
11286: #endif
16218: 	arena_run_trim_tail(arena, chunk, (arena_run_t *)ptr, oldsize, size,
16218: 	    true);
11286: #ifdef MALLOC_STATS
11286: 	arena->stats.allocated_large -= oldsize - size;
11286: #endif
11286: 	malloc_spin_unlock(&arena->lock);
11449: }
11449: 
11449: static bool
11773: arena_ralloc_large_grow(arena_t *arena, arena_chunk_t *chunk, void *ptr,
11449:     size_t size, size_t oldsize)
11449: {
16218: 	size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> pagesize_2pow;
16218: 	size_t npages = oldsize >> pagesize_2pow;
16218: 
16218: 	assert(oldsize == (chunk->map[pageind].bits & ~pagesize_mask));
11286: 
11286: 	/* Try to extend the run. */
11286: 	assert(size > oldsize);
11286: #ifdef MALLOC_BALANCE
11286: 	arena_lock_balance(arena);
11286: #else
11286: 	malloc_spin_lock(&arena->lock);
11286: #endif
16218: 	if (pageind + npages < chunk_npages && (chunk->map[pageind+npages].bits
16218: 	    & CHUNK_MAP_ALLOCATED) == 0 && (chunk->map[pageind+npages].bits &
16218: 	    ~pagesize_mask) >= size - oldsize) {
11449: 		/*
11449: 		 * The next run is available and sufficiently large.  Split the
11449: 		 * following run, then merge the first part with the existing
16218: 		 * allocation.
16218: 		 */
16218: 		arena_run_split(arena, (arena_run_t *)((uintptr_t)chunk +
16218: 		    ((pageind+npages) << pagesize_2pow)), size - oldsize, true,
16218: 		    false);
16218: 
16218: 		chunk->map[pageind].bits = size | CHUNK_MAP_LARGE |
16218: 		    CHUNK_MAP_ALLOCATED;
16218: 		chunk->map[pageind+npages].bits = CHUNK_MAP_LARGE |
16218: 		    CHUNK_MAP_ALLOCATED;
11449: 
11286: #ifdef MALLOC_STATS
11286: 		arena->stats.allocated_large += size - oldsize;
11286: #endif
11286: 		malloc_spin_unlock(&arena->lock);
11286: 		return (false);
11286: 	}
11286: 	malloc_spin_unlock(&arena->lock);
11286: 
11286: 	return (true);
11286: }
11286: 
11449: /*
11449:  * Try to resize a large allocation, in order to avoid copying.  This will
11449:  * always fail if growing an object, and the following run is already in use.
11449:  */
11449: static bool
11773: arena_ralloc_large(void *ptr, size_t size, size_t oldsize)
11449: {
11773: 	size_t psize;
11773: 
11773: 	psize = PAGE_CEILING(size);
11773: 	if (psize == oldsize) {
11773: 		/* Same size class. */
11773: #ifdef MALLOC_FILL
11773: 		if (opt_junk && size < oldsize) {
11773: 			memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize -
11773: 			    size);
11773: 		}
11773: #endif
11773: 		return (false);
11773: 	} else {
11449: 		arena_chunk_t *chunk;
11449: 		arena_t *arena;
11449: 
11449: 		chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
11449: 		arena = chunk->arena;
11449: 		assert(arena->magic == ARENA_MAGIC);
11449: 
11773: 		if (psize < oldsize) {
11773: #ifdef MALLOC_FILL
11773: 			/* Fill before shrinking in order avoid a race. */
11773: 			if (opt_junk) {
11773: 				memset((void *)((uintptr_t)ptr + size), 0x5a,
11773: 				    oldsize - size);
11773: 			}
11773: #endif
11773: 			arena_ralloc_large_shrink(arena, chunk, ptr, psize,
11773: 			    oldsize);
11449: 			return (false);
11449: 		} else {
11773: 			bool ret = arena_ralloc_large_grow(arena, chunk, ptr,
11773: 			    psize, oldsize);
11773: #ifdef MALLOC_FILL
11773: 			if (ret == false && opt_zero) {
11773: 				memset((void *)((uintptr_t)ptr + oldsize), 0,
11773: 				    size - oldsize);
11773: 			}
11773: #endif
11773: 			return (ret);
11773: 		}
11449: 	}
11449: }
11449: 
11286: static void *
11286: arena_ralloc(void *ptr, size_t size, size_t oldsize)
11286: {
11286: 	void *ret;
11449: 	size_t copysize;
11286: 
11286: 	/* Try to avoid moving the allocation. */
11286: 	if (size < small_min) {
11286: 		if (oldsize < small_min &&
11286: 		    ffs((int)(pow2_ceil(size) >> (TINY_MIN_2POW + 1)))
11286: 		    == ffs((int)(pow2_ceil(oldsize) >> (TINY_MIN_2POW + 1))))
11286: 			goto IN_PLACE; /* Same size class. */
11286: 	} else if (size <= small_max) {
11286: 		if (oldsize >= small_min && oldsize <= small_max &&
11286: 		    (QUANTUM_CEILING(size) >> opt_quantum_2pow)
11286: 		    == (QUANTUM_CEILING(oldsize) >> opt_quantum_2pow))
11286: 			goto IN_PLACE; /* Same size class. */
11286: 	} else if (size <= bin_maxclass) {
11286: 		if (oldsize > small_max && oldsize <= bin_maxclass &&
11286: 		    pow2_ceil(size) == pow2_ceil(oldsize))
11286: 			goto IN_PLACE; /* Same size class. */
11286: 	} else if (oldsize > bin_maxclass && oldsize <= arena_maxclass) {
11286: 		assert(size > bin_maxclass);
11773: 		if (arena_ralloc_large(ptr, size, oldsize) == false)
11773: 			return (ptr);
11286: 	}
11286: 
11286: 	/*
11286: 	 * If we get here, then size and oldsize are different enough that we
11286: 	 * need to move the object.  In that case, fall back to allocating new
11286: 	 * space and copying.
11286: 	 */
11286: 	ret = arena_malloc(choose_arena(), size, false);
11286: 	if (ret == NULL)
11286: 		return (NULL);
11286: 
11286: 	/* Junk/zero-filling were already done by arena_malloc(). */
11449: 	copysize = (size < oldsize) ? size : oldsize;
11449: #ifdef VM_COPY_MIN
11449: 	if (copysize >= VM_COPY_MIN)
11449: 		pages_copy(ret, ptr, copysize);
11286: 	else
11449: #endif
11449: 		memcpy(ret, ptr, copysize);
11286: 	idalloc(ptr);
11286: 	return (ret);
11286: IN_PLACE:
11449: #ifdef MALLOC_FILL
11286: 	if (opt_junk && size < oldsize)
11286: 		memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize - size);
11286: 	else if (opt_zero && size > oldsize)
11286: 		memset((void *)((uintptr_t)ptr + oldsize), 0, size - oldsize);
11449: #endif
11286: 	return (ptr);
11286: }
11286: 
11449: static inline void *
11449: iralloc(void *ptr, size_t size)
11286: {
11449: 	size_t oldsize;
11449: 
11286: 	assert(ptr != NULL);
11449: 	assert(size != 0);
11449: 
11449: 	oldsize = isalloc(ptr);
11449: 
14033: #ifndef MALLOC_VALGRIND
11449: 	if (size <= arena_maxclass)
11449: 		return (arena_ralloc(ptr, size, oldsize));
11449: 	else
11449: 		return (huge_ralloc(ptr, size, oldsize));
14033: #else
14033: 	/*
14033: 	 * Valgrind does not provide a public interface for modifying an
14033: 	 * existing allocation, so use malloc/memcpy/free instead.
14033: 	 */
14033: 	{
14033: 		void *ret = imalloc(size);
14033: 		if (ret != NULL) {
14033: 			if (oldsize < size)
14033: 			    memcpy(ret, ptr, oldsize);
14033: 			else
14033: 			    memcpy(ret, ptr, size);
14033: 			idalloc(ptr);
14033: 		}
14033: 		return (ret);
14033: 	}
14033: #endif
11286: }
11286: 
11286: static bool
11286: arena_new(arena_t *arena)
11286: {
11286: 	unsigned i;
11286: 	arena_bin_t *bin;
11286: 	size_t pow2_size, prev_run_size;
11286: 
11286: 	if (malloc_spin_init(&arena->lock))
11286: 		return (true);
11286: 
11286: #ifdef MALLOC_STATS
11286: 	memset(&arena->stats, 0, sizeof(arena_stats_t));
11286: #endif
11286: 
11286: 	/* Initialize chunks. */
15461: 	arena_chunk_tree_dirty_new(&arena->chunks_dirty);
16218: 	arena->spare = NULL;
11286: 
11286: 	arena->ndirty = 0;
11286: 
16218: 	arena_avail_tree_new(&arena->runs_avail);
11286: 
11286: #ifdef MALLOC_BALANCE
11286: 	arena->contention = 0;
11286: #endif
11286: 
11286: 	/* Initialize bins. */
11286: 	prev_run_size = pagesize;
11286: 
11286: 	/* (2^n)-spaced tiny bins. */
11286: 	for (i = 0; i < ntbins; i++) {
11286: 		bin = &arena->bins[i];
11286: 		bin->runcur = NULL;
15460: 		arena_run_tree_new(&bin->runs);
11286: 
11286: 		bin->reg_size = (1U << (TINY_MIN_2POW + i));
11286: 
11286: 		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
11286: 
11286: #ifdef MALLOC_STATS
11286: 		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
11286: #endif
11286: 	}
11286: 
11286: 	/* Quantum-spaced bins. */
11286: 	for (; i < ntbins + nqbins; i++) {
11286: 		bin = &arena->bins[i];
11286: 		bin->runcur = NULL;
15460: 		arena_run_tree_new(&bin->runs);
11286: 
11286: 		bin->reg_size = quantum * (i - ntbins + 1);
11286: 
11286: 		pow2_size = pow2_ceil(quantum * (i - ntbins + 1));
11286: 		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
11286: 
11286: #ifdef MALLOC_STATS
11286: 		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
11286: #endif
11286: 	}
11286: 
11286: 	/* (2^n)-spaced sub-page bins. */
11286: 	for (; i < ntbins + nqbins + nsbins; i++) {
11286: 		bin = &arena->bins[i];
11286: 		bin->runcur = NULL;
15460: 		arena_run_tree_new(&bin->runs);
11286: 
11286: 		bin->reg_size = (small_max << (i - (ntbins + nqbins) + 1));
11286: 
11286: 		prev_run_size = arena_bin_run_size_calc(bin, prev_run_size);
11286: 
11286: #ifdef MALLOC_STATS
11286: 		memset(&bin->stats, 0, sizeof(malloc_bin_stats_t));
11286: #endif
11286: 	}
11286: 
11286: #ifdef MALLOC_DEBUG
11286: 	arena->magic = ARENA_MAGIC;
11286: #endif
11286: 
11286: 	return (false);
11286: }
11286: 
11286: /* Create a new arena and insert it into the arenas array at index ind. */
11286: static arena_t *
11286: arenas_extend(unsigned ind)
11286: {
11286: 	arena_t *ret;
11286: 
11286: 	/* Allocate enough space for trailing bins. */
11286: 	ret = (arena_t *)base_alloc(sizeof(arena_t)
11286: 	    + (sizeof(arena_bin_t) * (ntbins + nqbins + nsbins - 1)));
11286: 	if (ret != NULL && arena_new(ret) == false) {
11286: 		arenas[ind] = ret;
11286: 		return (ret);
11286: 	}
11286: 	/* Only reached if there is an OOM error. */
11286: 
11286: 	/*
11286: 	 * OOM here is quite inconvenient to propagate, since dealing with it
11286: 	 * would require a check for failure in the fast path.  Instead, punt
11286: 	 * by using arenas[0].  In practice, this is an extremely unlikely
11286: 	 * failure.
11286: 	 */
11286: 	_malloc_message(_getprogname(),
11286: 	    ": (malloc) Error initializing arena\n", "", "");
11286: 	if (opt_abort)
11286: 		abort();
11286: 
11286: 	return (arenas[0]);
11286: }
11286: 
11286: /*
11286:  * End arena.
11286:  */
11286: /******************************************************************************/
11286: /*
11286:  * Begin general internal functions.
11286:  */
11286: 
11286: static void *
11286: huge_malloc(size_t size, bool zero)
11286: {
11286: 	void *ret;
11286: 	size_t csize;
13110: #ifdef MALLOC_DECOMMIT
13110: 	size_t psize;
13110: #endif
11286: 	extent_node_t *node;
11286: 
11286: 	/* Allocate one or more contiguous chunks for this request. */
11286: 
11286: 	csize = CHUNK_CEILING(size);
11286: 	if (csize == 0) {
11286: 		/* size is large enough to cause size_t wrap-around. */
11286: 		return (NULL);
11286: 	}
11286: 
11449: 	/* Allocate an extent node with which to track the chunk. */
11286: 	node = base_node_alloc();
11286: 	if (node == NULL)
11286: 		return (NULL);
11286: 
15610: 	ret = chunk_alloc(csize, zero, true);
11286: 	if (ret == NULL) {
11286: 		base_node_dealloc(node);
11286: 		return (NULL);
11286: 	}
11286: 
11286: 	/* Insert node into huge. */
11286: 	node->addr = ret;
13110: #ifdef MALLOC_DECOMMIT
13110: 	psize = PAGE_CEILING(size);
13110: 	node->size = psize;
13110: #else
11286: 	node->size = csize;
13110: #endif
11286: 
11286: 	malloc_mutex_lock(&huge_mtx);
15460: 	extent_tree_ad_insert(&huge, node);
11286: #ifdef MALLOC_STATS
11286: 	huge_nmalloc++;
13110: #  ifdef MALLOC_DECOMMIT
13110: 	huge_allocated += psize;
13110: #  else
11286: 	huge_allocated += csize;
11286: #  endif
13110: #endif
11286: 	malloc_mutex_unlock(&huge_mtx);
11286: 
13110: #ifdef MALLOC_DECOMMIT
13110: 	if (csize - psize > 0)
13110: 		pages_decommit((void *)((uintptr_t)ret + psize), csize - psize);
13110: #endif
13110: 
14033: #ifdef MALLOC_DECOMMIT
14033: 	VALGRIND_MALLOCLIKE_BLOCK(ret, psize, 0, zero);
14033: #else
14033: 	VALGRIND_MALLOCLIKE_BLOCK(ret, csize, 0, zero);
14033: #endif
14033: 
11449: #ifdef MALLOC_FILL
11286: 	if (zero == false) {
11286: 		if (opt_junk)
13110: #  ifdef MALLOC_DECOMMIT
13110: 			memset(ret, 0xa5, psize);
13110: #  else
11286: 			memset(ret, 0xa5, csize);
13110: #  endif
11286: 		else if (opt_zero)
13110: #  ifdef MALLOC_DECOMMIT
13110: 			memset(ret, 0, psize);
13110: #  else
11286: 			memset(ret, 0, csize);
13110: #  endif
11286: 	}
11449: #endif
11286: 
11286: 	return (ret);
11286: }
11286: 
11286: /* Only handles large allocations that require more than chunk alignment. */
11286: static void *
11286: huge_palloc(size_t alignment, size_t size)
11286: {
11286: 	void *ret;
11286: 	size_t alloc_size, chunk_size, offset;
13110: #ifdef MALLOC_DECOMMIT
13110: 	size_t psize;
13110: #endif
11286: 	extent_node_t *node;
15610: 	int pfd;
11286: 
11286: 	/*
11286: 	 * This allocation requires alignment that is even larger than chunk
11286: 	 * alignment.  This means that huge_malloc() isn't good enough.
11286: 	 *
11286: 	 * Allocate almost twice as many chunks as are demanded by the size or
11286: 	 * alignment, in order to assure the alignment can be achieved, then
11286: 	 * unmap leading and trailing chunks.
11286: 	 */
11286: 	assert(alignment >= chunksize);
11286: 
11286: 	chunk_size = CHUNK_CEILING(size);
11286: 
11286: 	if (size >= alignment)
11286: 		alloc_size = chunk_size + alignment - chunksize;
11286: 	else
11286: 		alloc_size = (alignment << 1) - chunksize;
11286: 
11449: 	/* Allocate an extent node with which to track the chunk. */
11286: 	node = base_node_alloc();
11286: 	if (node == NULL)
11286: 		return (NULL);
11286: 
13110: 	/*
13110: 	 * Windows requires that there be a 1:1 mapping between VM
13110: 	 * allocation/deallocation operations.  Therefore, take care here to
13110: 	 * acquire the final result via one mapping operation.
15610: 	 *
15610: 	 * The MALLOC_PAGEFILE code also benefits from this mapping algorithm,
15610: 	 * since it reduces the number of page files.
15610: 	 */
15610: #ifdef MALLOC_PAGEFILE
15610: 	if (opt_pagefile) {
15610: 		pfd = pagefile_init(size);
15610: 		if (pfd == -1)
15610: 			return (NULL);
15610: 	} else
15610: #endif
15610: 		pfd = -1;
26771: #ifdef JEMALLOC_USES_MAP_ALIGN
26771: 		ret = pages_map_align(chunk_size, pfd, alignment);
26771: #else
13110: 	do {
13110: 		void *over;
13110: 
15610: 		over = chunk_alloc(alloc_size, false, false);
13110: 		if (over == NULL) {
13110: 			base_node_dealloc(node);
15610: 			ret = NULL;
15610: 			goto RETURN;
13110: 		}
13110: 
13110: 		offset = (uintptr_t)over & (alignment - 1);
13110: 		assert((offset & chunksize_mask) == 0);
13110: 		assert(offset < alloc_size);
13110: 		ret = (void *)((uintptr_t)over + offset);
13110: 		chunk_dealloc(over, alloc_size);
15610: 		ret = pages_map(ret, chunk_size, pfd);
13110: 		/*
13110: 		 * Failure here indicates a race with another thread, so try
13110: 		 * again.
13110: 		 */
13110: 	} while (ret == NULL);
26488: #endif
11286: 	/* Insert node into huge. */
11286: 	node->addr = ret;
13110: #ifdef MALLOC_DECOMMIT
13110: 	psize = PAGE_CEILING(size);
13110: 	node->size = psize;
13110: #else
11286: 	node->size = chunk_size;
13110: #endif
11286: 
11286: 	malloc_mutex_lock(&huge_mtx);
15460: 	extent_tree_ad_insert(&huge, node);
11286: #ifdef MALLOC_STATS
11286: 	huge_nmalloc++;
13110: #  ifdef MALLOC_DECOMMIT
13110: 	huge_allocated += psize;
13110: #  else
11286: 	huge_allocated += chunk_size;
11286: #  endif
13110: #endif
11286: 	malloc_mutex_unlock(&huge_mtx);
11286: 
13110: #ifdef MALLOC_DECOMMIT
13110: 	if (chunk_size - psize > 0) {
13110: 		pages_decommit((void *)((uintptr_t)ret + psize),
13110: 		    chunk_size - psize);
13110: 	}
13110: #endif
13110: 
14033: #ifdef MALLOC_DECOMMIT
14033: 	VALGRIND_MALLOCLIKE_BLOCK(ret, psize, 0, false);
14033: #else
14033: 	VALGRIND_MALLOCLIKE_BLOCK(ret, chunk_size, 0, false);
14033: #endif
14033: 
11449: #ifdef MALLOC_FILL
11286: 	if (opt_junk)
13110: #  ifdef MALLOC_DECOMMIT
13110: 		memset(ret, 0xa5, psize);
13110: #  else
11286: 		memset(ret, 0xa5, chunk_size);
13110: #  endif
11286: 	else if (opt_zero)
13110: #  ifdef MALLOC_DECOMMIT
13110: 		memset(ret, 0, psize);
13110: #  else
11286: 		memset(ret, 0, chunk_size);
11449: #  endif
13110: #endif
11286: 
15610: RETURN:
15610: #ifdef MALLOC_PAGEFILE
15610: 	if (pfd != -1)
15610: 		pagefile_close(pfd);
15610: #endif
11286: 	return (ret);
11286: }
11286: 
11286: static void *
11286: huge_ralloc(void *ptr, size_t size, size_t oldsize)
11286: {
11286: 	void *ret;
11449: 	size_t copysize;
11286: 
11286: 	/* Avoid moving the allocation if the size class would not change. */
13110: 
11286: 	if (oldsize > arena_maxclass &&
11286: 	    CHUNK_CEILING(size) == CHUNK_CEILING(oldsize)) {
13110: #ifdef MALLOC_DECOMMIT
13110: 		size_t psize = PAGE_CEILING(size);
13110: #endif
11449: #ifdef MALLOC_FILL
11286: 		if (opt_junk && size < oldsize) {
11286: 			memset((void *)((uintptr_t)ptr + size), 0x5a, oldsize
11286: 			    - size);
13110: 		}
13110: #endif
13110: #ifdef MALLOC_DECOMMIT
13110: 		if (psize < oldsize) {
13110: 			extent_node_t *node, key;
13110: 
13110: 			pages_decommit((void *)((uintptr_t)ptr + psize),
13110: 			    oldsize - psize);
13110: 
13110: 			/* Update recorded size. */
13110: 			malloc_mutex_lock(&huge_mtx);
13110: 			key.addr = __DECONST(void *, ptr);
15460: 			node = extent_tree_ad_search(&huge, &key);
13110: 			assert(node != NULL);
13110: 			assert(node->size == oldsize);
13110: #  ifdef MALLOC_STATS
13110: 			huge_allocated -= oldsize - psize;
13110: #  endif
13110: 			node->size = psize;
13110: 			malloc_mutex_unlock(&huge_mtx);
13110: 		} else if (psize > oldsize) {
13110: 			extent_node_t *node, key;
13110: 
13110: 			pages_commit((void *)((uintptr_t)ptr + oldsize),
13110: 			    psize - oldsize);
13110: 
13110: 			/* Update recorded size. */
13110: 			malloc_mutex_lock(&huge_mtx);
13110: 			key.addr = __DECONST(void *, ptr);
15460: 			node = extent_tree_ad_search(&huge, &key);
13110: 			assert(node != NULL);
13110: 			assert(node->size == oldsize);
13110: #  ifdef MALLOC_STATS
13110: 			huge_allocated += psize - oldsize;
13110: #  endif
13110: 			node->size = psize;
13110: 			malloc_mutex_unlock(&huge_mtx);
13110: 		}
13110: #endif
13110: #ifdef MALLOC_FILL
13110: 		if (opt_zero && size > oldsize) {
11286: 			memset((void *)((uintptr_t)ptr + oldsize), 0, size
11286: 			    - oldsize);
11286: 		}
11449: #endif
11286: 		return (ptr);
11286: 	}
11286: 
11286: 	/*
11286: 	 * If we get here, then size and oldsize are different enough that we
11286: 	 * need to use a different size class.  In that case, fall back to
11286: 	 * allocating new space and copying.
11286: 	 */
11286: 	ret = huge_malloc(size, false);
11286: 	if (ret == NULL)
11286: 		return (NULL);
11286: 
11449: 	copysize = (size < oldsize) ? size : oldsize;
11449: #ifdef VM_COPY_MIN
11449: 	if (copysize >= VM_COPY_MIN)
11449: 		pages_copy(ret, ptr, copysize);
11286: 	else
11449: #endif
11449: 		memcpy(ret, ptr, copysize);
11286: 	idalloc(ptr);
11286: 	return (ret);
11286: }
11286: 
11286: static void
11286: huge_dalloc(void *ptr)
11286: {
11286: 	extent_node_t *node, key;
11286: 
11286: 	malloc_mutex_lock(&huge_mtx);
11286: 
11286: 	/* Extract from tree of huge allocations. */
11286: 	key.addr = ptr;
15460: 	node = extent_tree_ad_search(&huge, &key);
11286: 	assert(node != NULL);
11286: 	assert(node->addr == ptr);
15460: 	extent_tree_ad_remove(&huge, node);
11286: 
11286: #ifdef MALLOC_STATS
11286: 	huge_ndalloc++;
11286: 	huge_allocated -= node->size;
11286: #endif
11286: 
11286: 	malloc_mutex_unlock(&huge_mtx);
11286: 
11286: 	/* Unmap chunk. */
11449: #ifdef MALLOC_FILL
15610: 	if (opt_junk)
11286: 		memset(node->addr, 0x5a, node->size);
11286: #endif
13110: #ifdef MALLOC_DECOMMIT
13110: 	chunk_dealloc(node->addr, CHUNK_CEILING(node->size));
13110: #else
11286: 	chunk_dealloc(node->addr, node->size);
13110: #endif
14033: 	VALGRIND_FREELIKE_BLOCK(node->addr, 0);
11286: 
11286: 	base_node_dealloc(node);
11286: }
11286: 
11286: #ifdef MOZ_MEMORY_BSD
11286: static inline unsigned
11286: malloc_ncpus(void)
11286: {
11286: 	unsigned ret;
11286: 	int mib[2];
11286: 	size_t len;
11286: 
11286: 	mib[0] = CTL_HW;
11286: 	mib[1] = HW_NCPU;
11286: 	len = sizeof(ret);
11286: 	if (sysctl(mib, 2, &ret, &len, (void *) 0, 0) == -1) {
11286: 		/* Error. */
11286: 		return (1);
11286: 	}
11286: 
11286: 	return (ret);
11286: }
11286: #elif (defined(MOZ_MEMORY_LINUX))
11286: #include <fcntl.h>
11286: 
11286: static inline unsigned
11286: malloc_ncpus(void)
11286: {
11286: 	unsigned ret;
11286: 	int fd, nread, column;
21856: 	char buf[1024];
11286: 	static const char matchstr[] = "processor\t:";
21856: 	int i;
11286: 
11286: 	/*
11286: 	 * sysconf(3) would be the preferred method for determining the number
11286: 	 * of CPUs, but it uses malloc internally, which causes untennable
11286: 	 * recursion during malloc initialization.
11286: 	 */
11286: 	fd = open("/proc/cpuinfo", O_RDONLY);
11286: 	if (fd == -1)
11286: 		return (1); /* Error. */
11286: 	/*
11286: 	 * Count the number of occurrences of matchstr at the beginnings of
11286: 	 * lines.  This treats hyperthreaded CPUs as multiple processors.
11286: 	 */
11286: 	column = 0;
11286: 	ret = 0;
11286: 	while (true) {
11286: 		nread = read(fd, &buf, sizeof(buf));
11286: 		if (nread <= 0)
11286: 			break; /* EOF or error. */
21856: 		for (i = 0;i < nread;i++) {
21856: 			char c = buf[i];
21856: 			if (c == '\n')
11286: 				column = 0;
11286: 			else if (column != -1) {
21856: 				if (c == matchstr[column]) {
11286: 					column++;
11286: 					if (column == sizeof(matchstr) - 1) {
11286: 						column = -1;
11286: 						ret++;
11286: 					}
11286: 				} else
11286: 					column = -1;
11286: 			}
11286: 		}
21856: 	}
21856: 
11286: 	if (ret == 0)
11286: 		ret = 1; /* Something went wrong in the parser. */
11449: 	close(fd);
11286: 
11286: 	return (ret);
11286: }
11286: #elif (defined(MOZ_MEMORY_DARWIN))
11286: #include <mach/mach_init.h>
11286: #include <mach/mach_host.h>
11286: 
11286: static inline unsigned
11286: malloc_ncpus(void)
11286: {
11286: 	kern_return_t error;
11286: 	natural_t n;
11286: 	processor_info_array_t pinfo;
11286: 	mach_msg_type_number_t pinfocnt;
11286: 
11286: 	error = host_processor_info(mach_host_self(), PROCESSOR_BASIC_INFO,
11286: 				    &n, &pinfo, &pinfocnt);
11286: 	if (error != KERN_SUCCESS)
11286: 		return (1); /* Error. */
11286: 	else
11286: 		return (n);
11286: }
11286: #elif (defined(MOZ_MEMORY_SOLARIS))
11286: 
11286: static inline unsigned
11286: malloc_ncpus(void)
11286: {
14800: 	return sysconf(_SC_NPROCESSORS_ONLN);
11286: }
11286: #else
11286: static inline unsigned
11286: malloc_ncpus(void)
11286: {
11286: 
11286: 	/*
11286: 	 * We lack a way to determine the number of CPUs on this platform, so
11286: 	 * assume 1 CPU.
11286: 	 */
11286: 	return (1);
11286: }
11286: #endif
11286: 
11286: static void
11286: malloc_print_stats(void)
11286: {
11286: 
11286: 	if (opt_print_stats) {
11286: 		char s[UMAX2S_BUFSIZE];
11286: 		_malloc_message("___ Begin malloc statistics ___\n", "", "",
11286: 		    "");
11286: 		_malloc_message("Assertions ",
11286: #ifdef NDEBUG
11286: 		    "disabled",
11286: #else
11286: 		    "enabled",
11286: #endif
11286: 		    "\n", "");
11286: 		_malloc_message("Boolean MALLOC_OPTIONS: ",
11286: 		    opt_abort ? "A" : "a", "", "");
11449: #ifdef MALLOC_FILL
11286: 		_malloc_message(opt_junk ? "J" : "j", "", "", "");
11449: #endif
15610: #ifdef MALLOC_PAGEFILE
15610: 		_malloc_message(opt_pagefile ? "o" : "O", "", "", "");
11286: #endif
11449: 		_malloc_message("P", "", "", "");
11449: #ifdef MALLOC_UTRACE
11449: 		_malloc_message(opt_utrace ? "U" : "u", "", "", "");
11449: #endif
11449: #ifdef MALLOC_SYSV
11449: 		_malloc_message(opt_sysv ? "V" : "v", "", "", "");
11449: #endif
11449: #ifdef MALLOC_XMALLOC
11449: 		_malloc_message(opt_xmalloc ? "X" : "x", "", "", "");
11449: #endif
11449: #ifdef MALLOC_FILL
11449: 		_malloc_message(opt_zero ? "Z" : "z", "", "", "");
11449: #endif
11449: 		_malloc_message("\n", "", "", "");
11286: 
11286: 		_malloc_message("CPUs: ", umax2s(ncpus, s), "\n", "");
11286: 		_malloc_message("Max arenas: ", umax2s(narenas, s), "\n", "");
11286: #ifdef MALLOC_BALANCE
11286: 		_malloc_message("Arena balance threshold: ",
11286: 		    umax2s(opt_balance_threshold, s), "\n", "");
11286: #endif
11286: 		_malloc_message("Pointer size: ", umax2s(sizeof(void *), s),
11286: 		    "\n", "");
11286: 		_malloc_message("Quantum size: ", umax2s(quantum, s), "\n", "");
11286: 		_malloc_message("Max small size: ", umax2s(small_max, s), "\n",
11286: 		    "");
11449: 		_malloc_message("Max dirty pages per arena: ",
11449: 		    umax2s(opt_dirty_max, s), "\n", "");
11286: 
11286: 		_malloc_message("Chunk size: ", umax2s(chunksize, s), "", "");
11286: 		_malloc_message(" (2^", umax2s(opt_chunk_2pow, s), ")\n", "");
11286: 
11286: #ifdef MALLOC_STATS
11286: 		{
11286: 			size_t allocated, mapped;
11286: #ifdef MALLOC_BALANCE
11286: 			uint64_t nbalance = 0;
11286: #endif
11286: 			unsigned i;
11286: 			arena_t *arena;
11286: 
11286: 			/* Calculate and print allocated/mapped stats. */
11286: 
11286: 			/* arenas. */
11286: 			for (i = 0, allocated = 0; i < narenas; i++) {
11286: 				if (arenas[i] != NULL) {
11286: 					malloc_spin_lock(&arenas[i]->lock);
11286: 					allocated +=
11286: 					    arenas[i]->stats.allocated_small;
11286: 					allocated +=
11286: 					    arenas[i]->stats.allocated_large;
11286: #ifdef MALLOC_BALANCE
11286: 					nbalance += arenas[i]->stats.nbalance;
11286: #endif
11286: 					malloc_spin_unlock(&arenas[i]->lock);
11286: 				}
11286: 			}
11286: 
11286: 			/* huge/base. */
11286: 			malloc_mutex_lock(&huge_mtx);
11286: 			allocated += huge_allocated;
11286: 			mapped = stats_chunks.curchunks * chunksize;
11286: 			malloc_mutex_unlock(&huge_mtx);
11286: 
11286: 			malloc_mutex_lock(&base_mtx);
11286: 			mapped += base_mapped;
11286: 			malloc_mutex_unlock(&base_mtx);
11286: 
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: 			malloc_printf("Allocated: %lu, mapped: %lu\n",
11286: 			    allocated, mapped);
11286: #else
11286: 			malloc_printf("Allocated: %zu, mapped: %zu\n",
11286: 			    allocated, mapped);
11286: #endif
11286: 
11286: #ifdef MALLOC_BALANCE
11286: 			malloc_printf("Arena balance reassignments: %llu\n",
11286: 			    nbalance);
11286: #endif
11286: 
11286: 			/* Print chunk stats. */
11286: 			{
11286: 				chunk_stats_t chunks_stats;
11286: 
11286: 				malloc_mutex_lock(&huge_mtx);
11286: 				chunks_stats = stats_chunks;
11286: 				malloc_mutex_unlock(&huge_mtx);
11286: 
11286: 				malloc_printf("chunks: nchunks   "
11286: 				    "highchunks    curchunks\n");
11286: 				malloc_printf("  %13llu%13lu%13lu\n",
11286: 				    chunks_stats.nchunks,
11286: 				    chunks_stats.highchunks,
11286: 				    chunks_stats.curchunks);
11286: 			}
11286: 
11286: 			/* Print chunk stats. */
11286: 			malloc_printf(
11286: 			    "huge: nmalloc      ndalloc    allocated\n");
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: 			malloc_printf(" %12llu %12llu %12lu\n",
11286: 			    huge_nmalloc, huge_ndalloc, huge_allocated);
11286: #else
11286: 			malloc_printf(" %12llu %12llu %12zu\n",
11286: 			    huge_nmalloc, huge_ndalloc, huge_allocated);
11286: #endif
11286: 			/* Print stats for each arena. */
11286: 			for (i = 0; i < narenas; i++) {
11286: 				arena = arenas[i];
11286: 				if (arena != NULL) {
11286: 					malloc_printf(
11286: 					    "\narenas[%u]:\n", i);
11286: 					malloc_spin_lock(&arena->lock);
11286: 					stats_print(arena);
11286: 					malloc_spin_unlock(&arena->lock);
11286: 				}
11286: 			}
11286: 		}
11286: #endif /* #ifdef MALLOC_STATS */
11286: 		_malloc_message("--- End malloc statistics ---\n", "", "", "");
11286: 	}
11286: }
11286: 
11286: /*
11286:  * FreeBSD's pthreads implementation calls malloc(3), so the malloc
11286:  * implementation has to take pains to avoid infinite recursion during
11286:  * initialization.
11286:  */
26488: #if (defined(MOZ_MEMORY_WINDOWS) || defined(MOZ_MEMORY_DARWIN)) && !defined(MOZ_MEMORY_WINCE)
11449: #define	malloc_init() false
11449: #else
11449: static inline bool
11286: malloc_init(void)
11286: {
11286: 
11286: 	if (malloc_initialized == false)
11286: 		return (malloc_init_hard());
11286: 
11286: 	return (false);
11286: }
11449: #endif
11449: 
26488: #if !defined(MOZ_MEMORY_WINDOWS) || defined(MOZ_MEMORY_WINCE) 
11449: static
11449: #endif
11449: bool
11286: malloc_init_hard(void)
11286: {
11286: 	unsigned i;
11286: 	char buf[PATH_MAX + 1];
11286: 	const char *opts;
11286: 	long result;
11286: #ifndef MOZ_MEMORY_WINDOWS
11286: 	int linklen;
11286: #endif
11286: 
11286: #ifndef MOZ_MEMORY_WINDOWS
11286: 	malloc_mutex_lock(&init_lock);
11286: #endif
11286: 
11286: 	if (malloc_initialized) {
11286: 		/*
11286: 		 * Another thread initialized the allocator before this one
11286: 		 * acquired init_lock.
11286: 		 */
11286: #ifndef MOZ_MEMORY_WINDOWS
11286: 		malloc_mutex_unlock(&init_lock);
11286: #endif
11286: 		return (false);
11286: 	}
11286: 
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: 	/* get a thread local storage index */
11286: 	tlsIndex = TlsAlloc();
11286: #endif
11286: 
11286: 	/* Get page size and number of CPUs */
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: 	{
11286: 		SYSTEM_INFO info;
11286: 
11286: 		GetSystemInfo(&info);
11286: 		result = info.dwPageSize;
11286: 
11286: 		pagesize = (unsigned) result;
11286: 
11286: 		ncpus = info.dwNumberOfProcessors;
11286: 	}
11286: #else
11286: 	ncpus = malloc_ncpus();
11286: 
11286: 	result = sysconf(_SC_PAGESIZE);
11286: 	assert(result != -1);
11286: 
11286: 	pagesize = (unsigned) result;
11286: #endif
11286: 
11286: 	/*
11286: 	 * We assume that pagesize is a power of 2 when calculating
11286: 	 * pagesize_mask and pagesize_2pow.
11286: 	 */
11286: 	assert(((result - 1) & result) == 0);
11286: 	pagesize_mask = result - 1;
11286: 	pagesize_2pow = ffs((int)result) - 1;
11286: 
15610: #ifdef MALLOC_PAGEFILE
15610: 	/*
15610: 	 * Determine where to create page files.  It is insufficient to
15610: 	 * unconditionally use P_tmpdir (typically "/tmp"), since for some
15610: 	 * operating systems /tmp is a separate filesystem that is rather small.
15610: 	 * Therefore prefer, in order, the following locations:
15610: 	 *
15610: 	 * 1) MALLOC_TMPDIR
15610: 	 * 2) TMPDIR
15610: 	 * 3) P_tmpdir
15610: 	 */
15610: 	{
15610: 		char *s;
15610: 		size_t slen;
15610: 		static const char suffix[] = "/jemalloc.XXXXXX";
15610: 
15610: 		if ((s = getenv("MALLOC_TMPDIR")) == NULL && (s =
15610: 		    getenv("TMPDIR")) == NULL)
15610: 			s = P_tmpdir;
15610: 		slen = strlen(s);
15610: 		if (slen + sizeof(suffix) > sizeof(pagefile_templ)) {
15610: 			_malloc_message(_getprogname(),
15610: 			    ": (malloc) Page file path too long\n",
15610: 			    "", "");
15610: 			abort();
15610: 		}
15610: 		memcpy(pagefile_templ, s, slen);
15610: 		memcpy(&pagefile_templ[slen], suffix, sizeof(suffix));
15610: 	}
15610: #endif
15610: 
11286: 	for (i = 0; i < 3; i++) {
11286: 		unsigned j;
11286: 
11286: 		/* Get runtime configuration. */
11286: 		switch (i) {
11286: 		case 0:
11286: #ifndef MOZ_MEMORY_WINDOWS
11286: 			if ((linklen = readlink("/etc/malloc.conf", buf,
11286: 						sizeof(buf) - 1)) != -1) {
11286: 				/*
11286: 				 * Use the contents of the "/etc/malloc.conf"
11286: 				 * symbolic link's name.
11286: 				 */
11286: 				buf[linklen] = '\0';
11286: 				opts = buf;
11286: 			} else
11286: #endif
11286: 			{
11286: 				/* No configuration specified. */
11286: 				buf[0] = '\0';
11286: 				opts = buf;
11286: 			}
11286: 			break;
11286: 		case 1:
11286: 			if (issetugid() == 0 && (opts =
11286: 			    getenv("MALLOC_OPTIONS")) != NULL) {
11286: 				/*
11286: 				 * Do nothing; opts is already initialized to
11286: 				 * the value of the MALLOC_OPTIONS environment
11286: 				 * variable.
11286: 				 */
11286: 			} else {
11286: 				/* No configuration specified. */
11286: 				buf[0] = '\0';
11286: 				opts = buf;
11286: 			}
11286: 			break;
11286: 		case 2:
11286: 			if (_malloc_options != NULL) {
11286: 				/*
11286: 				 * Use options that were compiled into the
11286: 				 * program.
11286: 				 */
11286: 				opts = _malloc_options;
11286: 			} else {
11286: 				/* No configuration specified. */
11286: 				buf[0] = '\0';
11286: 				opts = buf;
11286: 			}
11286: 			break;
11286: 		default:
11286: 			/* NOTREACHED */
11286: 			buf[0] = '\0';
11286: 			opts = buf;
11286: 			assert(false);
11286: 		}
11286: 
11286: 		for (j = 0; opts[j] != '\0'; j++) {
11286: 			unsigned k, nreps;
11286: 			bool nseen;
11286: 
11286: 			/* Parse repetition count, if any. */
11286: 			for (nreps = 0, nseen = false;; j++, nseen = true) {
11286: 				switch (opts[j]) {
11286: 					case '0': case '1': case '2': case '3':
11286: 					case '4': case '5': case '6': case '7':
11286: 					case '8': case '9':
11286: 						nreps *= 10;
11286: 						nreps += opts[j] - '0';
11286: 						break;
11286: 					default:
11286: 						goto MALLOC_OUT;
11286: 				}
11286: 			}
11286: MALLOC_OUT:
11286: 			if (nseen == false)
11286: 				nreps = 1;
11286: 
11286: 			for (k = 0; k < nreps; k++) {
11286: 				switch (opts[j]) {
11286: 				case 'a':
11286: 					opt_abort = false;
11286: 					break;
11286: 				case 'A':
11286: 					opt_abort = true;
11286: 					break;
11286: 				case 'b':
11286: #ifdef MALLOC_BALANCE
11286: 					opt_balance_threshold >>= 1;
11286: #endif
11286: 					break;
11286: 				case 'B':
11286: #ifdef MALLOC_BALANCE
11286: 					if (opt_balance_threshold == 0)
11286: 						opt_balance_threshold = 1;
11286: 					else if ((opt_balance_threshold << 1)
11286: 					    > opt_balance_threshold)
11286: 						opt_balance_threshold <<= 1;
11286: #endif
11286: 					break;
11286: 				case 'f':
11449: 					opt_dirty_max >>= 1;
11286: 					break;
11286: 				case 'F':
11449: 					if (opt_dirty_max == 0)
11449: 						opt_dirty_max = 1;
11449: 					else if ((opt_dirty_max << 1) != 0)
11449: 						opt_dirty_max <<= 1;
11286: 					break;
11449: #ifdef MALLOC_FILL
11286: 				case 'j':
11286: 					opt_junk = false;
11286: 					break;
11286: 				case 'J':
11286: 					opt_junk = true;
11286: 					break;
11449: #endif
11286: 				case 'k':
11286: 					/*
11286: 					 * Chunks always require at least one
11286: 					 * header page, so chunks can never be
11286: 					 * smaller than two pages.
11286: 					 */
11286: 					if (opt_chunk_2pow > pagesize_2pow + 1)
11286: 						opt_chunk_2pow--;
11286: 					break;
11286: 				case 'K':
11449: 					if (opt_chunk_2pow + 1 <
11449: 					    (sizeof(size_t) << 3))
11286: 						opt_chunk_2pow++;
11286: 					break;
11286: 				case 'n':
11286: 					opt_narenas_lshift--;
11286: 					break;
11286: 				case 'N':
11286: 					opt_narenas_lshift++;
11286: 					break;
15610: #ifdef MALLOC_PAGEFILE
15610: 				case 'o':
15610: 					/* Do not over-commit. */
15610: 					opt_pagefile = true;
15610: 					break;
15610: 				case 'O':
15610: 					/* Allow over-commit. */
15610: 					opt_pagefile = false;
15610: 					break;
15610: #endif
11286: 				case 'p':
11286: 					opt_print_stats = false;
11286: 					break;
11286: 				case 'P':
11286: 					opt_print_stats = true;
11286: 					break;
11286: 				case 'q':
11286: 					if (opt_quantum_2pow > QUANTUM_2POW_MIN)
11286: 						opt_quantum_2pow--;
11286: 					break;
11286: 				case 'Q':
11286: 					if (opt_quantum_2pow < pagesize_2pow -
11286: 					    1)
11286: 						opt_quantum_2pow++;
11286: 					break;
11286: 				case 's':
11286: 					if (opt_small_max_2pow >
11286: 					    QUANTUM_2POW_MIN)
11286: 						opt_small_max_2pow--;
11286: 					break;
11286: 				case 'S':
11286: 					if (opt_small_max_2pow < pagesize_2pow
11286: 					    - 1)
11286: 						opt_small_max_2pow++;
11286: 					break;
11449: #ifdef MALLOC_UTRACE
11286: 				case 'u':
11286: 					opt_utrace = false;
11286: 					break;
11286: 				case 'U':
11286: 					opt_utrace = true;
11286: 					break;
11449: #endif
11449: #ifdef MALLOC_SYSV
11286: 				case 'v':
11286: 					opt_sysv = false;
11286: 					break;
11286: 				case 'V':
11286: 					opt_sysv = true;
11286: 					break;
11449: #endif
11449: #ifdef MALLOC_XMALLOC
11286: 				case 'x':
11286: 					opt_xmalloc = false;
11286: 					break;
11286: 				case 'X':
11286: 					opt_xmalloc = true;
11286: 					break;
11449: #endif
11449: #ifdef MALLOC_FILL
11286: 				case 'z':
11286: 					opt_zero = false;
11286: 					break;
11286: 				case 'Z':
11286: 					opt_zero = true;
11286: 					break;
11449: #endif
11286: 				default: {
11286: 					char cbuf[2];
11286: 
11286: 					cbuf[0] = opts[j];
11286: 					cbuf[1] = '\0';
11286: 					_malloc_message(_getprogname(),
11286: 					    ": (malloc) Unsupported character "
11286: 					    "in malloc options: '", cbuf,
11286: 					    "'\n");
11286: 				}
11286: 				}
11286: 			}
11286: 		}
11286: 	}
11286: 
11286: 	/* Take care to call atexit() only once. */
11286: 	if (opt_print_stats) {
11286: #ifndef MOZ_MEMORY_WINDOWS
11286: 		/* Print statistics at exit. */
11286: 		atexit(malloc_print_stats);
11286: #endif
11286: 	}
11286: 
21117: #if (!defined(MOZ_MEMORY_WINDOWS) && !defined(MOZ_MEMORY_DARWIN))
21117: 	/* Prevent potential deadlock on malloc locks after fork. */
21117: 	pthread_atfork(_malloc_prefork, _malloc_postfork, _malloc_postfork);
21117: #endif
21117: 
11286: 	/* Set variables according to the value of opt_small_max_2pow. */
11286: 	if (opt_small_max_2pow < opt_quantum_2pow)
11286: 		opt_small_max_2pow = opt_quantum_2pow;
11286: 	small_max = (1U << opt_small_max_2pow);
11286: 
11286: 	/* Set bin-related variables. */
11286: 	bin_maxclass = (pagesize >> 1);
11286: 	assert(opt_quantum_2pow >= TINY_MIN_2POW);
11286: 	ntbins = opt_quantum_2pow - TINY_MIN_2POW;
11286: 	assert(ntbins <= opt_quantum_2pow);
11286: 	nqbins = (small_max >> opt_quantum_2pow);
11286: 	nsbins = pagesize_2pow - opt_small_max_2pow - 1;
11286: 
11286: 	/* Set variables according to the value of opt_quantum_2pow. */
11286: 	quantum = (1U << opt_quantum_2pow);
11286: 	quantum_mask = quantum - 1;
11286: 	if (ntbins > 0)
11286: 		small_min = (quantum >> 1) + 1;
11286: 	else
11286: 		small_min = 1;
11286: 	assert(small_min <= quantum);
11286: 
11286: 	/* Set variables according to the value of opt_chunk_2pow. */
11286: 	chunksize = (1LU << opt_chunk_2pow);
11286: 	chunksize_mask = chunksize - 1;
11286: 	chunk_npages = (chunksize >> pagesize_2pow);
11286: 	{
11449: 		size_t header_size;
11449: 
11449: 		/*
11449: 		 * Compute the header size such that it is large
11449: 		 * enough to contain the page map and enough nodes for the
11449: 		 * worst case: one node per non-header page plus one extra for
11449: 		 * situations where we briefly have one more node allocated
11449: 		 * than we will need.
11449: 		 */
11449: 		header_size = sizeof(arena_chunk_t) +
16218: 		    (sizeof(arena_chunk_map_t) * (chunk_npages - 1));
11449: 		arena_chunk_header_npages = (header_size >> pagesize_2pow) +
11449: 		    ((header_size & pagesize_mask) != 0);
11286: 	}
11286: 	arena_maxclass = chunksize - (arena_chunk_header_npages <<
11286: 	    pagesize_2pow);
11286: 
24522: #ifdef JEMALLOC_USES_MAP_ALIGN
24522: 	/*
24522: 	 * When using MAP_ALIGN, the alignment parameter must be a power of two
24522: 	 * multiple of the system pagesize, or mmap will fail.
24522: 	 */
24522: 	assert((chunksize % pagesize) == 0);
24522: 	assert((1 << (ffs(chunksize / pagesize) - 1)) == (chunksize/pagesize));
24522: #endif
24522: 
11286: 	UTRACE(0, 0, 0);
11286: 
11286: #ifdef MALLOC_STATS
11286: 	memset(&stats_chunks, 0, sizeof(chunk_stats_t));
11286: #endif
11286: 
11286: 	/* Various sanity checks that regard configuration. */
11286: 	assert(quantum >= sizeof(void *));
11286: 	assert(quantum <= pagesize);
11286: 	assert(chunksize >= pagesize);
11286: 	assert(quantum * 4 <= chunksize);
11286: 
11286: 	/* Initialize chunks data. */
11286: 	malloc_mutex_init(&huge_mtx);
15460: 	extent_tree_ad_new(&huge);
11286: #ifdef MALLOC_STATS
11286: 	huge_nmalloc = 0;
11286: 	huge_ndalloc = 0;
11286: 	huge_allocated = 0;
11286: #endif
11286: 
11286: 	/* Initialize base allocation data structures. */
11286: #ifdef MALLOC_STATS
11286: 	base_mapped = 0;
11286: #endif
11449: 	base_nodes = NULL;
11286: 	malloc_mutex_init(&base_mtx);
11286: 
15462: #ifdef MOZ_MEMORY_NARENAS_DEFAULT_ONE
15462: 	narenas = 1;
15462: #else
11286: 	if (ncpus > 1) {
11286: 		/*
11286: 		 * For SMP systems, create four times as many arenas as there
11286: 		 * are CPUs by default.
11286: 		 */
11286: 		opt_narenas_lshift += 2;
11286: 	}
11286: 
11286: 	/* Determine how many arenas to use. */
11286: 	narenas = ncpus;
15462: #endif
11286: 	if (opt_narenas_lshift > 0) {
11286: 		if ((narenas << opt_narenas_lshift) > narenas)
11286: 			narenas <<= opt_narenas_lshift;
11286: 		/*
11286: 		 * Make sure not to exceed the limits of what base_alloc() can
11286: 		 * handle.
11286: 		 */
11286: 		if (narenas * sizeof(arena_t *) > chunksize)
11286: 			narenas = chunksize / sizeof(arena_t *);
11286: 	} else if (opt_narenas_lshift < 0) {
11286: 		if ((narenas >> -opt_narenas_lshift) < narenas)
11286: 			narenas >>= -opt_narenas_lshift;
11286: 		/* Make sure there is at least one arena. */
11286: 		if (narenas == 0)
11286: 			narenas = 1;
11286: 	}
11286: #ifdef MALLOC_BALANCE
11286: 	assert(narenas != 0);
11286: 	for (narenas_2pow = 0;
11286: 	     (narenas >> (narenas_2pow + 1)) != 0;
11286: 	     narenas_2pow++);
11286: #endif
11286: 
11286: #ifdef NO_TLS
11286: 	if (narenas > 1) {
11286: 		static const unsigned primes[] = {1, 3, 5, 7, 11, 13, 17, 19,
11286: 		    23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,
11286: 		    89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149,
11286: 		    151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,
11286: 		    223, 227, 229, 233, 239, 241, 251, 257, 263};
11286: 		unsigned nprimes, parenas;
11286: 
11286: 		/*
11286: 		 * Pick a prime number of hash arenas that is more than narenas
11286: 		 * so that direct hashing of pthread_self() pointers tends to
11286: 		 * spread allocations evenly among the arenas.
11286: 		 */
11286: 		assert((narenas & 1) == 0); /* narenas must be even. */
11286: 		nprimes = (sizeof(primes) >> SIZEOF_INT_2POW);
11286: 		parenas = primes[nprimes - 1]; /* In case not enough primes. */
11286: 		for (i = 1; i < nprimes; i++) {
11286: 			if (primes[i] > narenas) {
11286: 				parenas = primes[i];
11286: 				break;
11286: 			}
11286: 		}
11286: 		narenas = parenas;
11286: 	}
11286: #endif
11286: 
11286: #ifndef NO_TLS
11286: #  ifndef MALLOC_BALANCE
11286: 	next_arena = 0;
11286: #  endif
11286: #endif
11286: 
11286: 	/* Allocate and initialize arenas. */
11286: 	arenas = (arena_t **)base_alloc(sizeof(arena_t *) * narenas);
11286: 	if (arenas == NULL) {
11286: #ifndef MOZ_MEMORY_WINDOWS
11286: 		malloc_mutex_unlock(&init_lock);
11286: #endif
11286: 		return (true);
11286: 	}
11286: 	/*
11286: 	 * Zero the array.  In practice, this should always be pre-zeroed,
11286: 	 * since it was just mmap()ed, but let's be sure.
11286: 	 */
11286: 	memset(arenas, 0, sizeof(arena_t *) * narenas);
11286: 
11286: 	/*
11286: 	 * Initialize one arena here.  The rest are lazily created in
11286: 	 * choose_arena_hard().
11286: 	 */
11286: 	arenas_extend(0);
11286: 	if (arenas[0] == NULL) {
11286: #ifndef MOZ_MEMORY_WINDOWS
11286: 		malloc_mutex_unlock(&init_lock);
11286: #endif
11286: 		return (true);
11286: 	}
11286: #ifndef NO_TLS
11286: 	/*
11286: 	 * Assign the initial arena to the initial thread, in order to avoid
11286: 	 * spurious creation of an extra arena if the application switches to
11286: 	 * threaded mode.
11286: 	 */
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: 	TlsSetValue(tlsIndex, arenas[0]);
11286: #else
11286: 	arenas_map = arenas[0];
11286: #endif
11286: #endif
11286: 
11286: 	/*
11286: 	 * Seed here for the initial thread, since choose_arena_hard() is only
15460: 	 * called for other threads.  The seed value doesn't really matter.
11286: 	 */
11286: #ifdef MALLOC_BALANCE
11286: 	SPRN(balance, 42);
11286: #endif
11286: 
11286: 	malloc_spin_init(&arenas_lock);
11286: 
16218: #ifdef MALLOC_VALIDATE
16218: 	chunk_rtree = malloc_rtree_new((SIZEOF_PTR << 3) - opt_chunk_2pow);
16218: 	if (chunk_rtree == NULL)
16218: 		return (true);
16218: #endif
16218: 
11286: 	malloc_initialized = true;
11286: #ifndef MOZ_MEMORY_WINDOWS
11286: 	malloc_mutex_unlock(&init_lock);
11286: #endif
11286: 	return (false);
11286: }
11286: 
11286: /* XXX Why not just expose malloc_print_stats()? */
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: void
11286: malloc_shutdown()
11286: {
11449: 
11286: 	malloc_print_stats();
11286: }
11286: #endif
11286: 
11286: /*
11286:  * End general internal functions.
11286:  */
11286: /******************************************************************************/
11286: /*
11286:  * Begin malloc(3)-compatible functions.
11286:  */
11449: 
15458: /*
15458:  * Inline the standard malloc functions if they are being subsumed by Darwin's
15458:  * zone infrastructure.
15458:  */
11286: #ifdef MOZ_MEMORY_DARWIN
15458: #  define ZONE_INLINE	inline
11286: #else
15458: #  define ZONE_INLINE
15458: #endif
15458: 
26488: /* Mangle standard interfaces on Darwin and Windows CE, 
26488:    in order to avoid linking problems. */
27812: #if defined(MOZ_MEMORY_DARWIN)
15458: #define	malloc(a)	moz_malloc(a)
15458: #define	valloc(a)	moz_valloc(a)
15458: #define	calloc(a, b)	moz_calloc(a, b)
15458: #define	realloc(a, b)	moz_realloc(a, b)
15458: #define	free(a)		moz_free(a)
15458: #endif
15458: 
15458: ZONE_INLINE
11286: void *
11286: malloc(size_t size)
11286: {
11286: 	void *ret;
11286: 
11286: 	if (malloc_init()) {
11286: 		ret = NULL;
11286: 		goto RETURN;
11286: 	}
11286: 
11286: 	if (size == 0) {
11449: #ifdef MALLOC_SYSV
11286: 		if (opt_sysv == false)
11449: #endif
11286: 			size = 1;
11449: #ifdef MALLOC_SYSV
11286: 		else {
11286: 			ret = NULL;
11286: 			goto RETURN;
11286: 		}
11449: #endif
11286: 	}
11286: 
11286: 	ret = imalloc(size);
11286: 
11286: RETURN:
11286: 	if (ret == NULL) {
11449: #ifdef MALLOC_XMALLOC
11286: 		if (opt_xmalloc) {
11286: 			_malloc_message(_getprogname(),
11286: 			    ": (malloc) Error in malloc(): out of memory\n", "",
11286: 			    "");
11286: 			abort();
11286: 		}
11449: #endif
11286: 		errno = ENOMEM;
11286: 	}
11286: 
11286: 	UTRACE(0, size, ret);
11286: 	return (ret);
11286: }
11286: 
15458: #ifdef MOZ_MEMORY_SOLARIS
14800: #  ifdef __SUNPRO_C
14800: void *
14800: memalign(size_t alignment, size_t size);
14800: #pragma no_inline(memalign)
15458: #  elif (defined(__GNU_C__))
14800: __attribute__((noinline))
14800: #  endif
15458: #else
15458: inline
15458: #endif
14800: void *
14800: memalign(size_t alignment, size_t size)
14800: {
14800: 	void *ret;
14800: 
14800: 	assert(((alignment - 1) & alignment) == 0 && alignment >=
14800: 	    sizeof(void *));
14800: 
14800: 	if (malloc_init()) {
14800: 		ret = NULL;
14800: 		goto RETURN;
14800: 	}
14800: 
14800: 	ret = ipalloc(alignment, size);
14800: 
14800: RETURN:
14800: #ifdef MALLOC_XMALLOC
14800: 	if (opt_xmalloc && ret == NULL) {
14800: 		_malloc_message(_getprogname(),
14800: 		": (malloc) Error in memalign(): out of memory\n", "", "");
14800: 		abort();
14800: 	}
14800: #endif
14800: 	UTRACE(0, size, ret);
14800: 	return (ret);
14800: }
14800: 
15458: ZONE_INLINE
11286: int
11286: posix_memalign(void **memptr, size_t alignment, size_t size)
11286: {
11286: 	void *result;
11286: 
11286: 	/* Make sure that alignment is a large enough power of 2. */
14800: 	if (((alignment - 1) & alignment) != 0 || alignment < sizeof(void *)) {
11449: #ifdef MALLOC_XMALLOC
11286: 		if (opt_xmalloc) {
11286: 			_malloc_message(_getprogname(),
11286: 			    ": (malloc) Error in posix_memalign(): "
11286: 			    "invalid alignment\n", "", "");
11286: 			abort();
11286: 		}
11449: #endif
14800: 		return (EINVAL);
14800: 	}
14800: 
14800: #ifdef MOZ_MEMORY_DARWIN
14800: 	result = moz_memalign(alignment, size);
14800: #else
14800: 	result = memalign(alignment, size);
14800: #endif
14800: 	if (result == NULL)
14800: 		return (ENOMEM);
11286: 
11286: 	*memptr = result;
14800: 	return (0);
11286: }
11286: 
15458: ZONE_INLINE
11286: void *
11286: valloc(size_t size)
11286: {
11286: #ifdef MOZ_MEMORY_DARWIN
11286: 	return (moz_memalign(pagesize, size));
11286: #else
11286: 	return (memalign(pagesize, size));
11286: #endif
11286: }
11286: 
15458: ZONE_INLINE
11286: void *
11286: calloc(size_t num, size_t size)
11286: {
11286: 	void *ret;
11286: 	size_t num_size;
11286: 
11286: 	if (malloc_init()) {
11286: 		num_size = 0;
11286: 		ret = NULL;
11286: 		goto RETURN;
11286: 	}
11286: 
11286: 	num_size = num * size;
11286: 	if (num_size == 0) {
11449: #ifdef MALLOC_SYSV
11286: 		if ((opt_sysv == false) && ((num == 0) || (size == 0)))
11449: #endif
11286: 			num_size = 1;
11449: #ifdef MALLOC_SYSV
11286: 		else {
11286: 			ret = NULL;
11286: 			goto RETURN;
11286: 		}
11449: #endif
11286: 	/*
11286: 	 * Try to avoid division here.  We know that it isn't possible to
11286: 	 * overflow during multiplication if neither operand uses any of the
11286: 	 * most significant half of the bits in a size_t.
11286: 	 */
11286: 	} else if (((num | size) & (SIZE_T_MAX << (sizeof(size_t) << 2)))
11286: 	    && (num_size / size != num)) {
11286: 		/* size_t overflow. */
11286: 		ret = NULL;
11286: 		goto RETURN;
11286: 	}
11286: 
11286: 	ret = icalloc(num_size);
11286: 
11286: RETURN:
11286: 	if (ret == NULL) {
11449: #ifdef MALLOC_XMALLOC
11286: 		if (opt_xmalloc) {
11286: 			_malloc_message(_getprogname(),
11286: 			    ": (malloc) Error in calloc(): out of memory\n", "",
11286: 			    "");
11286: 			abort();
11286: 		}
11449: #endif
11286: 		errno = ENOMEM;
11286: 	}
11286: 
11286: 	UTRACE(0, num_size, ret);
11286: 	return (ret);
11286: }
11286: 
15458: ZONE_INLINE
11286: void *
11286: realloc(void *ptr, size_t size)
11286: {
11286: 	void *ret;
11286: 
11286: 	if (size == 0) {
11449: #ifdef MALLOC_SYSV
11286: 		if (opt_sysv == false)
11449: #endif
11286: 			size = 1;
11449: #ifdef MALLOC_SYSV
11286: 		else {
11286: 			if (ptr != NULL)
11286: 				idalloc(ptr);
11286: 			ret = NULL;
11286: 			goto RETURN;
11286: 		}
11449: #endif
11286: 	}
11286: 
11286: 	if (ptr != NULL) {
11286: 		assert(malloc_initialized);
11286: 
11286: 		ret = iralloc(ptr, size);
11286: 
11286: 		if (ret == NULL) {
11449: #ifdef MALLOC_XMALLOC
11286: 			if (opt_xmalloc) {
11286: 				_malloc_message(_getprogname(),
11286: 				    ": (malloc) Error in realloc(): out of "
11286: 				    "memory\n", "", "");
11286: 				abort();
11286: 			}
11449: #endif
11286: 			errno = ENOMEM;
11286: 		}
11286: 	} else {
11286: 		if (malloc_init())
11286: 			ret = NULL;
11286: 		else
11286: 			ret = imalloc(size);
11286: 
11286: 		if (ret == NULL) {
11449: #ifdef MALLOC_XMALLOC
11286: 			if (opt_xmalloc) {
11286: 				_malloc_message(_getprogname(),
11286: 				    ": (malloc) Error in realloc(): out of "
11286: 				    "memory\n", "", "");
11286: 				abort();
11286: 			}
11449: #endif
11286: 			errno = ENOMEM;
11286: 		}
11286: 	}
11286: 
11449: #ifdef MALLOC_SYSV
11286: RETURN:
11449: #endif
11286: 	UTRACE(ptr, size, ret);
11286: 	return (ret);
11286: }
11286: 
15458: ZONE_INLINE
11286: void
11286: free(void *ptr)
11286: {
11286: 
11286: 	UTRACE(ptr, 0, 0);
11286: 	if (ptr != NULL) {
11286: 		assert(malloc_initialized);
11286: 
11286: 		idalloc(ptr);
11286: 	}
11286: }
11286: 
11286: /*
11286:  * End malloc(3)-compatible functions.
11286:  */
11286: /******************************************************************************/
11286: /*
11286:  * Begin non-standard functions.
11286:  */
11286: 
11286: size_t
11286: malloc_usable_size(const void *ptr)
11286: {
11286: 
14259: #ifdef MALLOC_VALIDATE
14259: 	return (isalloc_validate(ptr));
14259: #else
11286: 	assert(ptr != NULL);
11286: 
11286: 	return (isalloc(ptr));
14259: #endif
11286: }
11286: 
15458: void
15458: jemalloc_stats(jemalloc_stats_t *stats)
15458: {
15458: 	size_t i;
15458: 
15458: 	assert(stats != NULL);
15458: 
15458: 	/*
15458: 	 * Gather runtime settings.
15458: 	 */
15458: 	stats->opt_abort = opt_abort;
15458: 	stats->opt_junk =
15458: #ifdef MALLOC_FILL
15458: 	    opt_junk ? true :
15458: #endif
15458: 	    false;
15458: 	stats->opt_utrace =
15458: #ifdef MALLOC_UTRACE
15458: 	    opt_utrace ? true :
15458: #endif
15458: 	    false;
15458: 	stats->opt_sysv =
15458: #ifdef MALLOC_SYSV
15458: 	    opt_sysv ? true :
15458: #endif
15458: 	    false;
15458: 	stats->opt_xmalloc =
15458: #ifdef MALLOC_XMALLOC
15458: 	    opt_xmalloc ? true :
15458: #endif
15458: 	    false;
15458: 	stats->opt_zero =
15458: #ifdef MALLOC_FILL
15458: 	    opt_zero ? true :
15458: #endif
15458: 	    false;
15458: 	stats->narenas = narenas;
15458: 	stats->balance_threshold =
15458: #ifdef MALLOC_BALANCE
15458: 	    opt_balance_threshold
15458: #else
15458: 	    SIZE_T_MAX
15458: #endif
15458: 	    ;
15458: 	stats->quantum = quantum;
15458: 	stats->small_max = small_max;
15458: 	stats->large_max = arena_maxclass;
15458: 	stats->chunksize = chunksize;
15458: 	stats->dirty_max = opt_dirty_max;
15458: 
15458: 	/*
15458: 	 * Gather current memory usage statistics.
15458: 	 */
15458: 	stats->mapped = 0;
15458: 	stats->committed = 0;
15458: 	stats->allocated = 0;
15458: 	stats->dirty = 0;
15458: 
15458: 	/* Get huge mapped/allocated. */
15458: 	malloc_mutex_lock(&huge_mtx);
15458: 	stats->mapped += stats_chunks.curchunks * chunksize;
15458: #ifdef MALLOC_DECOMMIT
15458: 	stats->committed += huge_allocated;
15458: #endif
15458: 	stats->allocated += huge_allocated;
15458: 	malloc_mutex_unlock(&huge_mtx);
15458: 
15458: 	/* Get base mapped. */
15458: 	malloc_mutex_lock(&base_mtx);
15458: 	stats->mapped += base_mapped;
15458: #ifdef MALLOC_DECOMMIT
15458: 	stats->committed += base_mapped;
15458: #endif
15458: 	malloc_mutex_unlock(&base_mtx);
15458: 
15458: 	/* Iterate over arenas and their chunks. */
15458: 	for (i = 0; i < narenas; i++) {
15458: 		arena_t *arena = arenas[i];
15458: 		if (arena != NULL) {
15458: 			arena_chunk_t *chunk;
15458: 
15458: 			malloc_spin_lock(&arena->lock);
15458: 			stats->allocated += arena->stats.allocated_small;
15458: 			stats->allocated += arena->stats.allocated_large;
15458: #ifdef MALLOC_DECOMMIT
16218: 			rb_foreach_begin(arena_chunk_t, link_dirty,
16218: 			    &arena->chunks_dirty, chunk) {
15458: 				size_t j;
15458: 
15458: 				for (j = 0; j < chunk_npages; j++) {
16218: 					if ((chunk->map[j].bits &
15458: 					    CHUNK_MAP_DECOMMITTED) == 0)
15458: 						stats->committed += pagesize;
15458: 				}
16218: 			} rb_foreach_end(arena_chunk_t, link_dirty,
16218: 			    &arena->chunks_dirty, chunk)
15458: #endif
15458: 			stats->dirty += (arena->ndirty << pagesize_2pow);
15458: 			malloc_spin_unlock(&arena->lock);
15458: 		}
15458: 	}
15458: 
15458: #ifndef MALLOC_DECOMMIT
15458: 	stats->committed = stats->mapped;
15458: #endif
15458: }
15458: 
11286: #ifdef MOZ_MEMORY_WINDOWS
11286: void*
11286: _recalloc(void *ptr, size_t count, size_t size)
11286: {
11449: 	size_t oldsize = (ptr != NULL) ? isalloc(ptr) : 0;
11286: 	size_t newsize = count * size;
11286: 
11449: 	/*
11449: 	 * In order for all trailing bytes to be zeroed, the caller needs to
11449: 	 * use calloc(), followed by recalloc().  However, the current calloc()
11449: 	 * implementation only zeros the bytes requested, so if recalloc() is
11449: 	 * to work 100% correctly, calloc() will need to change to zero
11449: 	 * trailing bytes.
11449: 	 */
11449: 
11286: 	ptr = realloc(ptr, newsize);
11449: 	if (ptr != NULL && oldsize < newsize) {
11449: 		memset((void *)((uintptr_t)ptr + oldsize), 0, newsize -
11449: 		    oldsize);
11449: 	}
11286: 
11286: 	return ptr;
11286: }
11286: 
11286: /*
11286:  * This impl of _expand doesn't ever actually expand or shrink blocks: it
11286:  * simply replies that you may continue using a shrunk block.
11286:  */
11286: void*
11286: _expand(void *ptr, size_t newsize)
11286: {
11286: 	if (isalloc(ptr) >= newsize)
11286: 		return ptr;
11286: 
11286: 	return NULL;
11286: }
11286: 
11286: size_t
11286: _msize(const void *ptr)
11286: {
11449: 
11286: 	return malloc_usable_size(ptr);
11286: }
11286: #endif
11286: 
11286: /*
11286:  * End non-standard functions.
11286:  */
11286: /******************************************************************************/
11286: /*
11286:  * Begin library-private functions, used by threading libraries for protection
11286:  * of malloc during fork().  These functions are only called if the program is
11286:  * running in threaded mode, so there is no need to check whether the program
11286:  * is threaded here.
11286:  */
11286: 
11286: void
11286: _malloc_prefork(void)
11286: {
11286: 	unsigned i;
11286: 
11286: 	/* Acquire all mutexes in a safe order. */
11286: 
11286: 	malloc_spin_lock(&arenas_lock);
11286: 	for (i = 0; i < narenas; i++) {
11286: 		if (arenas[i] != NULL)
11286: 			malloc_spin_lock(&arenas[i]->lock);
11286: 	}
11286: 	malloc_spin_unlock(&arenas_lock);
11286: 
11286: 	malloc_mutex_lock(&base_mtx);
11286: 
11286: 	malloc_mutex_lock(&huge_mtx);
11286: }
11286: 
11286: void
11286: _malloc_postfork(void)
11286: {
11286: 	unsigned i;
11286: 
11286: 	/* Release all mutexes, now that fork() has completed. */
11286: 
11286: 	malloc_mutex_unlock(&huge_mtx);
11286: 
11286: 	malloc_mutex_unlock(&base_mtx);
11286: 
11286: 	malloc_spin_lock(&arenas_lock);
11286: 	for (i = 0; i < narenas; i++) {
11286: 		if (arenas[i] != NULL)
11286: 			malloc_spin_unlock(&arenas[i]->lock);
11286: 	}
11286: 	malloc_spin_unlock(&arenas_lock);
11286: }
11286: 
11286: /*
11286:  * End library-private functions.
11286:  */
11286: /******************************************************************************/
11286: 
30874: #ifdef HAVE_LIBDL
30874: #  include <dlfcn.h>
30874: #endif
30874: 
11286: #ifdef MOZ_MEMORY_DARWIN
11286: static malloc_zone_t zone;
11286: static struct malloc_introspection_t zone_introspect;
11286: 
11286: static size_t
11286: zone_size(malloc_zone_t *zone, void *ptr)
11286: {
11286: 
11286: 	/*
11286: 	 * There appear to be places within Darwin (such as setenv(3)) that
11286: 	 * cause calls to this function with pointers that *no* zone owns.  If
11286: 	 * we knew that all pointers were owned by *some* zone, we could split
11286: 	 * our zone into two parts, and use one as the default allocator and
11286: 	 * the other as the default deallocator/reallocator.  Since that will
11286: 	 * not work in practice, we must check all pointers to assure that they
11286: 	 * reside within a mapped chunk before determining size.
11286: 	 */
14259: 	return (isalloc_validate(ptr));
11286: }
11286: 
11286: static void *
11286: zone_malloc(malloc_zone_t *zone, size_t size)
11286: {
11286: 
15458: 	return (malloc(size));
11286: }
11286: 
11286: static void *
11286: zone_calloc(malloc_zone_t *zone, size_t num, size_t size)
11286: {
11286: 
15458: 	return (calloc(num, size));
11286: }
11286: 
11286: static void *
11286: zone_valloc(malloc_zone_t *zone, size_t size)
11286: {
11286: 	void *ret = NULL; /* Assignment avoids useless compiler warning. */
11286: 
15458: 	posix_memalign(&ret, pagesize, size);
11286: 
11286: 	return (ret);
11286: }
11286: 
11286: static void
11286: zone_free(malloc_zone_t *zone, void *ptr)
11286: {
11286: 
15458: 	free(ptr);
11286: }
11286: 
11286: static void *
11286: zone_realloc(malloc_zone_t *zone, void *ptr, size_t size)
11286: {
11286: 
15458: 	return (realloc(ptr, size));
11286: }
11286: 
11286: static void *
11286: zone_destroy(malloc_zone_t *zone)
11286: {
11286: 
11286: 	/* This function should never be called. */
11286: 	assert(false);
11286: 	return (NULL);
11286: }
11286: 
11286: static size_t
11286: zone_good_size(malloc_zone_t *zone, size_t size)
11286: {
11286: 	size_t ret;
11286: 	void *p;
11286: 
11286: 	/*
11286: 	 * Actually create an object of the appropriate size, then find out
11286: 	 * how large it could have been without moving up to the next size
11286: 	 * class.
11286: 	 */
15458: 	p = malloc(size);
11286: 	if (p != NULL) {
11286: 		ret = isalloc(p);
15458: 		free(p);
11286: 	} else
11286: 		ret = size;
11286: 
11286: 	return (ret);
11286: }
11286: 
11286: static void
11286: zone_force_lock(malloc_zone_t *zone)
11286: {
11286: 
11286: 	_malloc_prefork();
11286: }
11286: 
11286: static void
11286: zone_force_unlock(malloc_zone_t *zone)
11286: {
11286: 
11286: 	_malloc_postfork();
11286: }
11286: 
11286: static malloc_zone_t *
11286: create_zone(void)
11286: {
11286: 
11286: 	assert(malloc_initialized);
11286: 
11286: 	zone.size = (void *)zone_size;
11286: 	zone.malloc = (void *)zone_malloc;
11286: 	zone.calloc = (void *)zone_calloc;
11286: 	zone.valloc = (void *)zone_valloc;
11286: 	zone.free = (void *)zone_free;
11286: 	zone.realloc = (void *)zone_realloc;
11286: 	zone.destroy = (void *)zone_destroy;
11286: 	zone.zone_name = "jemalloc_zone";
11286: 	zone.batch_malloc = NULL;
11286: 	zone.batch_free = NULL;
11286: 	zone.introspect = &zone_introspect;
11286: 
11286: 	zone_introspect.enumerator = NULL;
11286: 	zone_introspect.good_size = (void *)zone_good_size;
11286: 	zone_introspect.check = NULL;
11286: 	zone_introspect.print = NULL;
11286: 	zone_introspect.log = NULL;
11286: 	zone_introspect.force_lock = (void *)zone_force_lock;
11286: 	zone_introspect.force_unlock = (void *)zone_force_unlock;
11286: 	zone_introspect.statistics = NULL;
11286: 
11286: 	return (&zone);
11286: }
11286: 
11449: __attribute__((constructor))
11286: void
11286: jemalloc_darwin_init(void)
11286: {
11286: 	extern unsigned malloc_num_zones;
11286: 	extern malloc_zone_t **malloc_zones;
11286: 
11449: 	if (malloc_init_hard())
11286: 		abort();
11286: 
11286: 	/*
11286: 	 * The following code is *not* thread-safe, so it's critical that
11286: 	 * initialization be manually triggered.
11286: 	 */
11286: 
11286: 	/* Register the custom zones. */
11286: 	malloc_zone_register(create_zone());
11286: 	assert(malloc_zones[malloc_num_zones - 1] == &zone);
11286: 
11286: 	/*
11286: 	 * Shift malloc_zones around so that zone is first, which makes it the
11286: 	 * default zone.
11286: 	 */
11286: 	assert(malloc_num_zones > 1);
11286: 	memmove(&malloc_zones[1], &malloc_zones[0],
11286: 		sizeof(malloc_zone_t *) * (malloc_num_zones - 1));
11286: 	malloc_zones[0] = &zone;
11286: }
30874: 
30874: #elif defined(__GLIBC__) && !defined(__UCLIBC__)
30874: /*
30874:  * glibc provides the RTLD_DEEPBIND flag for dlopen which can make it possible
30874:  * to inconsistently reference libc's malloc(3)-compatible functions
30874:  * (bug 493541).
30874:  *
30874:  * These definitions interpose hooks in glibc.  The functions are actually
30874:  * passed an extra argument for the caller return address, which will be
30874:  * ignored.
30874:  */
30874: void (*__free_hook)(void *ptr) = free;
30874: void *(*__malloc_hook)(size_t size) = malloc;
30874: void *(*__realloc_hook)(void *ptr, size_t size) = realloc;
30874: void *(*__memalign_hook)(size_t alignment, size_t size) = memalign;
30874: 
30874: #elif defined(RTLD_DEEPBIND)
30874: /*
30874:  * XXX On systems that support RTLD_GROUP or DF_1_GROUP, do their
30874:  * implementations permit similar inconsistencies?  Should STV_SINGLETON
30874:  * visibility be used for interposition where available?
30874:  */
30874: #  error "Interposing malloc is unsafe on this system without libc malloc hooks."
30874: #endif
