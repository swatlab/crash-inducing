    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Brian Ryner    <bryner@brianryner.com>
16225:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * the container for the style sheets that apply to a presentation, and
    1:  * the internal API that the style system exposes for creating (and
    1:  * potentially re-creating) style contexts
    1:  */
    1: 
    1: #include "nsStyleSet.h"
    1: #include "nsNetUtil.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsIDocument.h"
    1: #include "nsRuleWalker.h"
    1: #include "nsStyleContext.h"
    1: #include "nsICSSStyleRule.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsCSSPseudoElements.h"
    1: #include "nsCSSRuleProcessor.h"
    1: #include "nsIContent.h"
    1: #include "nsIFrame.h"
 6876: #include "nsContentUtils.h"
30988: #include "nsRuleProcessorData.h"
33649: #include "nsTransitionManager.h"
    1: 
22737: NS_IMPL_ISUPPORTS1(nsEmptyStyleRule, nsIStyleRule)
22737: 
22737: NS_IMETHODIMP
22737: nsEmptyStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
22737: {
22737:   return NS_OK;
22737: }
22737: 
22737: #ifdef DEBUG
22737: NS_IMETHODIMP
22737: nsEmptyStyleRule::List(FILE* out, PRInt32 aIndent) const
22737: {
22737:   return NS_OK;
22737: }
22737: #endif
22737: 
21924: static const nsStyleSet::sheetType gCSSSheetTypes[] = {
21924:   nsStyleSet::eAgentSheet,
21924:   nsStyleSet::eUserSheet,
21924:   nsStyleSet::eDocSheet,
21924:   nsStyleSet::eOverrideSheet
21924: };
21924: 
    1: nsStyleSet::nsStyleSet()
    1:   : mRuleTree(nsnull),
33020:     mUnusedRuleNodeCount(0),
    1:     mBatching(0),
    1:     mInShutdown(PR_FALSE),
    1:     mAuthorStyleDisabled(PR_FALSE),
24429:     mInReconstruct(PR_FALSE),
    1:     mDirty(0)
    1: {
    1: }
    1: 
    1: nsresult
    1: nsStyleSet::Init(nsPresContext *aPresContext)
    1: {
22737:   mFirstLineRule = new nsEmptyStyleRule;
22737:   mFirstLetterRule = new nsEmptyStyleRule;
22737:   if (!mFirstLineRule || !mFirstLetterRule) {
22737:     return NS_ERROR_OUT_OF_MEMORY;
22737:   }
22737: 
    1:   if (!BuildDefaultStyleData(aPresContext)) {
    1:     mDefaultStyleData.Destroy(0, aPresContext);
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   mRuleTree = nsRuleNode::CreateRootNode(aPresContext);
    1:   if (!mRuleTree) {
    1:     mDefaultStyleData.Destroy(0, aPresContext);
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
33649:   GatherRuleProcessors(eTransitionSheet);
33649: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
 3959: nsStyleSet::BeginReconstruct()
 3959: {
24429:   NS_ASSERTION(!mInReconstruct, "Unmatched begin/end?");
 3959:   NS_ASSERTION(mRuleTree, "Reconstructing before first construction?");
 3959: 
 3959:   // Create a new rule tree root
 3959:   nsRuleNode* newTree =
 3959:     nsRuleNode::CreateRootNode(mRuleTree->GetPresContext());
 3959:   if (!newTree)
 3959:     return NS_ERROR_OUT_OF_MEMORY;
33399: 
33399:   // Save the old rule tree so we can destroy it later
33399:   if (!mOldRuleTrees.AppendElement(mRuleTree)) {
 3959:     newTree->Destroy();
 3959:     return NS_ERROR_OUT_OF_MEMORY;
 3959:   }
 3959: 
24429:   // We need to keep mRoots so that the rule tree GC will only free the
24429:   // rule trees that really aren't referenced anymore (which should be
24429:   // all of them, if there are no bugs in reresolution code).
24429: 
24429:   mInReconstruct = PR_TRUE;
 3959:   mRuleTree = newTree;
 3959: 
 3959:   return NS_OK;
 3959: }
 3959: 
 3959: void
 3959: nsStyleSet::EndReconstruct()
 3959: {
24429:   NS_ASSERTION(mInReconstruct, "Unmatched begin/end?");
24429:   mInReconstruct = PR_FALSE;
23831: #ifdef DEBUG
23831:   for (PRInt32 i = mRoots.Length() - 1; i >= 0; --i) {
23831:     nsRuleNode *n = mRoots[i]->GetRuleNode();
23831:     while (n->GetParent()) {
23831:       n = n->GetParent();
23831:     }
23831:     // Since nsStyleContext's mParent and mRuleNode are immutable, and
23831:     // style contexts own their parents, and nsStyleContext asserts in
23831:     // its constructor that the style context and its parent are in the
23831:     // same rule tree, we don't need to check any of the children of
23831:     // mRoots; we only need to check the rule nodes of mRoots
23831:     // themselves.
23831: 
24429:     NS_ASSERTION(n == mRuleTree, "style context has old rule node");
23831:   }
23831: #endif
24429:   // This *should* destroy the only element of mOldRuleTrees, but in
24429:   // case of some bugs (which would trigger the above assertions), it
24429:   // won't.
24429:   GCRuleTrees();
 3959: }
 3959: 
21209: void
21209: nsStyleSet::SetQuirkStyleSheet(nsIStyleSheet* aQuirkStyleSheet)
21209: {
21209:   NS_ASSERTION(aQuirkStyleSheet, "Must have quirk sheet if this is called");
21209:   NS_ASSERTION(!mQuirkStyleSheet, "Multiple calls to SetQuirkStyleSheet?");
21209:   NS_ASSERTION(mSheets[eAgentSheet].IndexOf(aQuirkStyleSheet) != -1,
21209:                "Quirk style sheet not one of our agent sheets?");
21209:   mQuirkStyleSheet = aQuirkStyleSheet;
21209: }
21209: 
 3959: nsresult
    1: nsStyleSet::GatherRuleProcessors(sheetType aType)
    1: {
    1:   mRuleProcessors[aType] = nsnull;
    1:   if (mAuthorStyleDisabled && (aType == eDocSheet || 
    1:                                aType == ePresHintSheet ||
    1:                                aType == eHTMLPresHintSheet ||
    1:                                aType == eStyleAttrSheet)) {
    1:     //don't regather if this level is disabled
    1:     return NS_OK;
    1:   }
33649:   if (aType == eTransitionSheet) {
33649:     // We have no sheet for the transitions level; just a rule
33649:     // processor.  (XXX: We should probably do this for the other
33649:     // non-CSS levels too!)
33649:     mRuleProcessors[aType] = PresContext()->TransitionManager();
33649:     return NS_OK;
33649:   }
    1:   if (mSheets[aType].Count()) {
    1:     switch (aType) {
    1:       case eAgentSheet:
    1:       case eUserSheet:
    1:       case eDocSheet:
    1:       case eOverrideSheet: {
    1:         // levels containing CSS stylesheets
    1:         nsCOMArray<nsIStyleSheet>& sheets = mSheets[aType];
    1:         nsCOMArray<nsICSSStyleSheet> cssSheets(sheets.Count());
    1:         for (PRInt32 i = 0, i_end = sheets.Count(); i < i_end; ++i) {
    1:           nsCOMPtr<nsICSSStyleSheet> cssSheet = do_QueryInterface(sheets[i]);
    1:           NS_ASSERTION(cssSheet, "not a CSS sheet");
    1:           cssSheets.AppendObject(cssSheet);
    1:         }
21983:         mRuleProcessors[aType] = new nsCSSRuleProcessor(cssSheets, 
21983:                                                         PRUint8(aType));
    1:       } break;
    1: 
    1:       default:
    1:         // levels containing non-CSS stylesheets
    1:         NS_ASSERTION(mSheets[aType].Count() == 1, "only one sheet per level");
    1:         mRuleProcessors[aType] = do_QueryInterface(mSheets[aType][0]);
    1:         break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef DEBUG
    1: #define CHECK_APPLICABLE \
    1: PR_BEGIN_MACRO \
    1:   PRBool applicable = PR_TRUE; \
    1:   aSheet->GetApplicable(applicable); \
    1:   NS_ASSERTION(applicable, "Inapplicable sheet being placed in style set"); \
    1: PR_END_MACRO
    1: #else
    1: #define CHECK_APPLICABLE
    1: #endif
    1: 
    1: nsresult
    1: nsStyleSet::AppendStyleSheet(sheetType aType, nsIStyleSheet *aSheet)
    1: {
    1:   NS_PRECONDITION(aSheet, "null arg");
    1:   CHECK_APPLICABLE;
    1:   mSheets[aType].RemoveObject(aSheet);
    1:   if (!mSheets[aType].AppendObject(aSheet))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   if (!mBatching)
    1:     return GatherRuleProcessors(aType);
    1: 
    1:   mDirty |= 1 << aType;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsStyleSet::PrependStyleSheet(sheetType aType, nsIStyleSheet *aSheet)
    1: {
    1:   NS_PRECONDITION(aSheet, "null arg");
    1:   CHECK_APPLICABLE;
    1:   mSheets[aType].RemoveObject(aSheet);
    1:   if (!mSheets[aType].InsertObjectAt(aSheet, 0))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   if (!mBatching)
    1:     return GatherRuleProcessors(aType);
    1: 
    1:   mDirty |= 1 << aType;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsStyleSet::RemoveStyleSheet(sheetType aType, nsIStyleSheet *aSheet)
    1: {
    1:   NS_PRECONDITION(aSheet, "null arg");
    1: #ifdef DEBUG
    1:   PRBool complete = PR_TRUE;
    1:   aSheet->GetComplete(complete);
    1:   NS_ASSERTION(complete, "Incomplete sheet being removed from style set");
    1: #endif
    1:   mSheets[aType].RemoveObject(aSheet);
    1:   if (!mBatching)
    1:     return GatherRuleProcessors(aType);
    1: 
    1:   mDirty |= 1 << aType;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsStyleSet::ReplaceSheets(sheetType aType,
    1:                           const nsCOMArray<nsIStyleSheet> &aNewSheets)
    1: {
    1:   mSheets[aType].Clear();
    1:   if (!mSheets[aType].AppendObjects(aNewSheets))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   if (!mBatching)
    1:     return GatherRuleProcessors(aType);
    1: 
    1:   mDirty |= 1 << aType;
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsStyleSet::GetAuthorStyleDisabled()
    1: {
    1:   return mAuthorStyleDisabled;
    1: }
    1: 
    1: nsresult
    1: nsStyleSet::SetAuthorStyleDisabled(PRBool aStyleDisabled)
    1: {
    1:   if (aStyleDisabled == !mAuthorStyleDisabled) {
    1:     mAuthorStyleDisabled = aStyleDisabled;
    1:     BeginUpdate();
    1:     mDirty |= 1 << eDocSheet |
    1:               1 << ePresHintSheet |
    1:               1 << eHTMLPresHintSheet |
    1:               1 << eStyleAttrSheet;
    1:     return EndUpdate();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // -------- Doc Sheets
    1: 
    1: nsresult
    1: nsStyleSet::AddDocStyleSheet(nsIStyleSheet* aSheet, nsIDocument* aDocument)
    1: {
    1:   NS_PRECONDITION(aSheet && aDocument, "null arg");
    1:   CHECK_APPLICABLE;
    1: 
    1:   nsCOMArray<nsIStyleSheet>& docSheets = mSheets[eDocSheet];
    1: 
    1:   docSheets.RemoveObject(aSheet);
    1:   // lowest index first
    1:   PRInt32 newDocIndex = aDocument->GetIndexOfStyleSheet(aSheet);
    1:   PRInt32 count = docSheets.Count();
    1:   PRInt32 index;
    1:   for (index = 0; index < count; index++) {
    1:     nsIStyleSheet* sheet = docSheets.ObjectAt(index);
    1:     PRInt32 sheetDocIndex = aDocument->GetIndexOfStyleSheet(sheet);
    1:     if (sheetDocIndex > newDocIndex)
    1:       break;
    1:   }
    1:   if (!docSheets.InsertObjectAt(aSheet, index))
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   if (!mBatching)
    1:     return GatherRuleProcessors(eDocSheet);
    1: 
    1:   mDirty |= 1 << eDocSheet;
    1:   return NS_OK;
    1: }
    1: 
    1: #undef CHECK_APPLICABLE
    1: 
    1: // Batching
    1: void
    1: nsStyleSet::BeginUpdate()
    1: {
    1:   ++mBatching;
    1: }
    1: 
    1: nsresult
    1: nsStyleSet::EndUpdate()
    1: {
    1:   NS_ASSERTION(mBatching > 0, "Unbalanced EndUpdate");
    1:   if (--mBatching) {
    1:     // We're not completely done yet.
    1:     return NS_OK;
    1:   }
    1: 
    1:   for (int i = 0; i < eSheetTypeCount; ++i) {
    1:     if (mDirty & (1 << i)) {
    1:       nsresult rv = GatherRuleProcessors(sheetType(i));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
    1:   mDirty = 0;
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsStyleSet::EnableQuirkStyleSheet(PRBool aEnable)
    1: {
16438: #ifdef DEBUG
21896:   PRBool oldEnabled;
21896:   {
21896:     nsCOMPtr<nsIDOMCSSStyleSheet> domSheet =
21896:       do_QueryInterface(mQuirkStyleSheet);
21896:     domSheet->GetDisabled(&oldEnabled);
21896:     oldEnabled = !oldEnabled;
21896:   }
21896: #endif
21896:   mQuirkStyleSheet->SetEnabled(aEnable);
21896: #ifdef DEBUG
21896:   // This should always be OK, since SetEnabled should call
21896:   // ClearRuleCascades.
21896:   // Note that we can hit this codepath multiple times when document.open()
21896:   // (potentially implied) happens multiple times.
21896:   if (mRuleProcessors[eAgentSheet] && aEnable != oldEnabled) {
16438:     static_cast<nsCSSRuleProcessor*>(static_cast<nsIStyleRuleProcessor*>(
16438:       mRuleProcessors[eAgentSheet]))->AssertQuirksChangeOK();
16438:   }
16438: #endif
    1: }
    1: 
35558: template<class T>
    1: static PRBool
    1: EnumRulesMatching(nsIStyleRuleProcessor* aProcessor, void* aData)
    1: {
35558:   T* data = static_cast<T*>(aData);
    1:   aProcessor->RulesMatching(data);
    1:   return PR_TRUE;
    1: }
    1: 
    1: /**
    1:  * |GetContext| implements sharing of style contexts (not just the data
    1:  * on the rule nodes) between siblings and cousins of the same
    1:  * generation.  (It works for cousins of the same generation since
    1:  * |aParentContext| could itself be a shared context.)
    1:  */
    1: already_AddRefed<nsStyleContext>
    1: nsStyleSet::GetContext(nsPresContext* aPresContext, 
    1:                        nsStyleContext* aParentContext, 
33399:                        nsRuleNode* aRuleNode,
35554:                        nsIAtom* aPseudoTag,
35554:                        nsCSSPseudoElements::Type aPseudoType)
    1: {
35554:   NS_PRECONDITION((!aPseudoTag &&
35554:                    aPseudoType ==
35554:                      nsCSSPseudoElements::ePseudo_NotPseudoElement) ||
35554:                   (aPseudoTag &&
35554:                    nsCSSPseudoElements::GetPseudoType(aPseudoTag) ==
35554:                      aPseudoType),
35554:                   "Pseudo mismatch");
35554: 
    1:   nsStyleContext* result = nsnull;
    1:       
    1:   if (aParentContext)
33399:     result = aParentContext->FindChildWithRules(aPseudoTag, aRuleNode).get();
    1: 
    1: #ifdef NOISY_DEBUG
    1:   if (result)
    1:     fprintf(stdout, "--- SharedSC %d ---\n", ++gSharedCount);
    1:   else
    1:     fprintf(stdout, "+++ NewSC %d +++\n", ++gNewCount);
    1: #endif
    1: 
    1:   if (!result) {
35554:     result = NS_NewStyleContext(aParentContext, aPseudoTag, aPseudoType,
35554:                                 aRuleNode, aPresContext).get();
    1:     if (!aParentContext && result)
    1:       mRoots.AppendElement(result);
    1:   }
35554:   else {
35554:     NS_ASSERTION(result->GetPseudoType() == aPseudoType, "Unexpected type");
35554:     NS_ASSERTION(result->GetPseudo() == aPseudoTag, "Unexpected pseudo");
35554:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: void
    1: nsStyleSet::AddImportantRules(nsRuleNode* aCurrLevelNode,
33399:                               nsRuleNode* aLastPrevLevelNode,
33399:                               nsRuleWalker* aRuleWalker)
    1: {
35613:   NS_ASSERTION(aCurrLevelNode &&
35613:                aCurrLevelNode != aLastPrevLevelNode, "How did we get here?");
    1: 
35529:   nsAutoTArray<nsIStyleRule*, 16> importantRules;
15902:   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
15902:        node = node->GetParent()) {
35529:     // We guarantee that we never walk the root node here, so no need
35529:     // to null-check GetRule().
35529:     nsIStyleRule* impRule = node->GetRule()->GetImportantRule();
    1:     if (impRule)
15902:       importantRules.AppendElement(impRule);
15902:   }
35529: 
35529:   NS_ASSERTION(importantRules.Length() != 0,
35529:                "Why did we think there were important rules?");
15902: 
15902:   for (PRUint32 i = importantRules.Length(); i-- != 0; ) {
33399:     aRuleWalker->Forward(importantRules[i]);
    1:   }
    1: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsStyleSet::AssertNoImportantRules(nsRuleNode* aCurrLevelNode,
    1:                                    nsRuleNode* aLastPrevLevelNode)
    1: {
15902:   if (!aCurrLevelNode)
    1:     return;
    1: 
15902:   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
15902:        node = node->GetParent()) {
15902:     nsIStyleRule* rule = node->GetRule();
35529:     if (rule) {
35529:       NS_ASSERTION(!rule->GetImportantRule(), "Unexpected important rule");
    1:     }
    1:   }
15902: }
    1: 
    1: void
    1: nsStyleSet::AssertNoCSSRules(nsRuleNode* aCurrLevelNode,
    1:                              nsRuleNode* aLastPrevLevelNode)
    1: {
15902:   if (!aCurrLevelNode)
    1:     return;
    1: 
15902:   for (nsRuleNode *node = aCurrLevelNode; node != aLastPrevLevelNode;
15902:        node = node->GetParent()) {
15902:     nsIStyleRule *rule = node->GetRule();
    1:     nsCOMPtr<nsICSSStyleRule> cssRule(do_QueryInterface(rule));
    1:     NS_ASSERTION(!cssRule || !cssRule->Selector(), "Unexpected CSS rule");
    1:   }
15902: }
    1: #endif
    1: 
    1: // Enumerate the rules in a way that cares about the order of the rules.
    1: void
    1: nsStyleSet::FileRules(nsIStyleRuleProcessor::EnumFunc aCollectorFunc, 
35556:                       void* aData, nsIContent* aContent,
35556:                       nsRuleWalker* aRuleWalker)
    1: {
    1:   // Cascading order:
    1:   // [least important]
    1:   //  1. UA normal rules                    = Agent        normal
    1:   //  2. Presentation hints                 = PresHint     normal
    1:   //  3. User normal rules                  = User         normal
    1:   //  4. HTML Presentation hints            = HTMLPresHint normal
    1:   //  5. Author normal rules                = Document     normal
    1:   //  6. Override normal rules              = Override     normal
    1:   //  7. Author !important rules            = Document     !important
    1:   //  8. Override !important rules          = Override     !important
    1:   //  9. User !important rules              = User         !important
    1:   // 10. UA !important rules                = Agent        !important
    1:   // [most important]
    1: 
    1:   NS_PRECONDITION(SheetCount(ePresHintSheet) == 0 ||
    1:                   SheetCount(eHTMLPresHintSheet) == 0,
    1:                   "Can't have both types of preshint sheets at once!");
    1:   
35529:   aRuleWalker->SetLevel(eAgentSheet, PR_FALSE, PR_TRUE);
    1:   if (mRuleProcessors[eAgentSheet])
    1:     (*aCollectorFunc)(mRuleProcessors[eAgentSheet], aData);
35613:   nsRuleNode* lastAgentRN = aRuleWalker->CurrentNode();
35529:   PRBool haveImportantUARules = !aRuleWalker->GetCheckForImportantRules();
    1: 
35529:   aRuleWalker->SetLevel(ePresHintSheet, PR_FALSE, PR_FALSE);
    1:   if (mRuleProcessors[ePresHintSheet])
    1:     (*aCollectorFunc)(mRuleProcessors[ePresHintSheet], aData);
35613:   nsRuleNode* lastPresHintRN = aRuleWalker->CurrentNode();
    1: 
35529:   aRuleWalker->SetLevel(eUserSheet, PR_FALSE, PR_TRUE);
12250:   PRBool skipUserStyles =
35556:     aContent && aContent->IsInNativeAnonymousSubtree();
 1111:   if (!skipUserStyles && mRuleProcessors[eUserSheet]) // NOTE: different
    1:     (*aCollectorFunc)(mRuleProcessors[eUserSheet], aData);
35613:   nsRuleNode* lastUserRN = aRuleWalker->CurrentNode();
35529:   PRBool haveImportantUserRules = !aRuleWalker->GetCheckForImportantRules();
    1: 
35529:   aRuleWalker->SetLevel(eHTMLPresHintSheet, PR_FALSE, PR_FALSE);
    1:   if (mRuleProcessors[eHTMLPresHintSheet])
    1:     (*aCollectorFunc)(mRuleProcessors[eHTMLPresHintSheet], aData);
35613:   nsRuleNode* lastHTMLPresHintRN = aRuleWalker->CurrentNode();
    1:   
35529:   aRuleWalker->SetLevel(eDocSheet, PR_FALSE, PR_TRUE);
    1:   PRBool cutOffInheritance = PR_FALSE;
35556:   if (mBindingManager && aContent) {
    1:     // We can supply additional document-level sheets that should be walked.
35556:     mBindingManager->WalkRules(aCollectorFunc,
35556:                                static_cast<RuleProcessorData*>(aData),
35556:                                &cutOffInheritance);
    1:   }
 1111:   if (!skipUserStyles && !cutOffInheritance &&
 1111:       mRuleProcessors[eDocSheet]) // NOTE: different
    1:     (*aCollectorFunc)(mRuleProcessors[eDocSheet], aData);
35529:   aRuleWalker->SetLevel(eStyleAttrSheet, PR_FALSE,
35529:                         aRuleWalker->GetCheckForImportantRules());
    1:   if (mRuleProcessors[eStyleAttrSheet])
    1:     (*aCollectorFunc)(mRuleProcessors[eStyleAttrSheet], aData);
35613:   nsRuleNode* lastDocRN = aRuleWalker->CurrentNode();
35529:   PRBool haveImportantDocRules = !aRuleWalker->GetCheckForImportantRules();
    1: 
35529:   aRuleWalker->SetLevel(eOverrideSheet, PR_FALSE, PR_TRUE);
    1:   if (mRuleProcessors[eOverrideSheet])
    1:     (*aCollectorFunc)(mRuleProcessors[eOverrideSheet], aData);
35613:   nsRuleNode* lastOvrRN = aRuleWalker->CurrentNode();
35529:   PRBool haveImportantOverrideRules = !aRuleWalker->GetCheckForImportantRules();
    1: 
35529:   if (haveImportantDocRules) {
35529:     aRuleWalker->SetLevel(eDocSheet, PR_TRUE, PR_FALSE);
33399:     AddImportantRules(lastDocRN, lastHTMLPresHintRN, aRuleWalker);  // doc
35529:   }
35529: #ifdef DEBUG
35529:   else {
35529:     AssertNoImportantRules(lastDocRN, lastHTMLPresHintRN);
35529:   }
35529: #endif
35529: 
35529:   if (haveImportantOverrideRules) {
35529:     aRuleWalker->SetLevel(eOverrideSheet, PR_TRUE, PR_FALSE);
33399:     AddImportantRules(lastOvrRN, lastDocRN, aRuleWalker);  // override
35529:   }
35529: #ifdef DEBUG
35529:   else {
35529:     AssertNoImportantRules(lastOvrRN, lastDocRN);
35529:   }
35529: #endif
35529: 
    1: #ifdef DEBUG
    1:   AssertNoCSSRules(lastHTMLPresHintRN, lastUserRN);
    1:   AssertNoImportantRules(lastHTMLPresHintRN, lastUserRN); // HTML preshints
    1: #endif
35529: 
35529:   if (haveImportantUserRules) {
35529:     aRuleWalker->SetLevel(eUserSheet, PR_TRUE, PR_FALSE);
33399:     AddImportantRules(lastUserRN, lastPresHintRN, aRuleWalker); //user
35529:   }
35529: #ifdef DEBUG
35529:   else {
35529:     AssertNoImportantRules(lastUserRN, lastPresHintRN);
35529:   }
35529: #endif
35529: 
    1: #ifdef DEBUG
    1:   AssertNoCSSRules(lastPresHintRN, lastAgentRN);
    1:   AssertNoImportantRules(lastPresHintRN, lastAgentRN); // preshints
    1: #endif
35529: 
35529:   if (haveImportantUARules) {
35529:     aRuleWalker->SetLevel(eAgentSheet, PR_TRUE, PR_FALSE);
35529:     AddImportantRules(lastAgentRN, mRuleTree, aRuleWalker);     //agent
35529:   }
35529: #ifdef DEBUG
35529:   else {
35529:     AssertNoImportantRules(lastAgentRN, mRuleTree);
35529:   }
35529: #endif
    1: 
33649: #ifdef DEBUG
35613:   nsRuleNode *lastImportantRN = aRuleWalker->CurrentNode();
33649: #endif
35529:   aRuleWalker->SetLevel(eTransitionSheet, PR_FALSE, PR_FALSE);
33649:   (*aCollectorFunc)(mRuleProcessors[eTransitionSheet], aData);
33649: #ifdef DEBUG
35613:   AssertNoCSSRules(aRuleWalker->CurrentNode(), lastImportantRN);
35613:   AssertNoImportantRules(aRuleWalker->CurrentNode(), lastImportantRN);
33649: #endif
33649: 
    1: }
    1: 
    1: // Enumerate all the rules in a way that doesn't care about the order
    1: // of the rules and doesn't walk !important-rules.
    1: void
    1: nsStyleSet::WalkRuleProcessors(nsIStyleRuleProcessor::EnumFunc aFunc,
    1:                                RuleProcessorData* aData)
    1: {
    1:   NS_PRECONDITION(SheetCount(ePresHintSheet) == 0 ||
    1:                   SheetCount(eHTMLPresHintSheet) == 0,
    1:                   "Can't have both types of preshint sheets at once!");
    1:   
    1:   if (mRuleProcessors[eAgentSheet])
    1:     (*aFunc)(mRuleProcessors[eAgentSheet], aData);
    1:   if (mRuleProcessors[ePresHintSheet])
    1:     (*aFunc)(mRuleProcessors[ePresHintSheet], aData);
 1111: 
35557:   PRBool skipUserStyles = aData->mContent->IsInNativeAnonymousSubtree();
 1111:   if (!skipUserStyles && mRuleProcessors[eUserSheet]) // NOTE: different
    1:     (*aFunc)(mRuleProcessors[eUserSheet], aData);
 1111: 
    1:   if (mRuleProcessors[eHTMLPresHintSheet])
    1:     (*aFunc)(mRuleProcessors[eHTMLPresHintSheet], aData);
    1:   
    1:   PRBool cutOffInheritance = PR_FALSE;
    1:   if (mBindingManager) {
    1:     // We can supply additional document-level sheets that should be walked.
16231:     mBindingManager->WalkRules(aFunc, aData, &cutOffInheritance);
    1:   }
 1111:   if (!skipUserStyles && !cutOffInheritance &&
 1111:       mRuleProcessors[eDocSheet]) // NOTE: different
    1:     (*aFunc)(mRuleProcessors[eDocSheet], aData);
    1:   if (mRuleProcessors[eStyleAttrSheet])
    1:     (*aFunc)(mRuleProcessors[eStyleAttrSheet], aData);
    1:   if (mRuleProcessors[eOverrideSheet])
    1:     (*aFunc)(mRuleProcessors[eOverrideSheet], aData);
33649:   (*aFunc)(mRuleProcessors[eTransitionSheet], aData);
    1: }
    1: 
    1: PRBool nsStyleSet::BuildDefaultStyleData(nsPresContext* aPresContext)
    1: {
    1:   NS_ASSERTION(!mDefaultStyleData.mResetData &&
    1:                !mDefaultStyleData.mInheritedData,
    1:                "leaking default style data");
    1:   mDefaultStyleData.mResetData = new (aPresContext) nsResetStyleData;
    1:   if (!mDefaultStyleData.mResetData)
    1:     return PR_FALSE;
    1:   mDefaultStyleData.mInheritedData = new (aPresContext) nsInheritedStyleData;
    1:   if (!mDefaultStyleData.mInheritedData)
    1:     return PR_FALSE;
    1: 
    1: #define SSARG_PRESCONTEXT aPresContext
    1: 
    1: #define CREATE_DATA(name, type, args) \
    1:   if (!(mDefaultStyleData.m##type##Data->m##name##Data = \
    1:           new (aPresContext) nsStyle##name args)) \
    1:     return PR_FALSE;
    1: 
    1: #define STYLE_STRUCT_INHERITED(name, checkdata_cb, ctor_args) \
    1:   CREATE_DATA(name, Inherited, ctor_args)
    1: #define STYLE_STRUCT_RESET(name, checkdata_cb, ctor_args) \
    1:   CREATE_DATA(name, Reset, ctor_args)
    1: 
    1: #include "nsStyleStructList.h"
    1: 
    1: #undef STYLE_STRUCT_INHERITED
    1: #undef STYLE_STRUCT_RESET
    1: #undef SSARG_PRESCONTEXT
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsStyleSet::ResolveStyleFor(nsIContent* aContent,
    1:                             nsStyleContext* aParentContext)
    1: {
    1:   NS_ENSURE_FALSE(mInShutdown, nsnull);
    1:   
    1:   nsStyleContext*  result = nsnull;
    1:   nsPresContext* presContext = PresContext();
    1: 
    1:   NS_ASSERTION(aContent, "must have content");
    1:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eELEMENT),
    1:                "content must be element");
    1: 
    1:   if (aContent && presContext) {
33399:     nsRuleWalker ruleWalker(mRuleTree);
33399:     ElementRuleProcessorData data(presContext, aContent, &ruleWalker);
35558:     FileRules(EnumRulesMatching<ElementRuleProcessorData>, &data, aContent,
35558:               &ruleWalker);
33399:     result = GetContext(presContext, aParentContext,
35613:                         ruleWalker.CurrentNode(), nsnull,
35554:                         nsCSSPseudoElements::ePseudo_NotPseudoElement).get();
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
31309: nsStyleSet::ResolveStyleForRules(nsStyleContext* aParentContext,
31309:                                  nsIAtom* aPseudoTag,
35554:                                  nsCSSPseudoElements::Type aPseudoType,
31309:                                  nsRuleNode *aRuleNode,
31309:                                  const nsCOMArray<nsIStyleRule> &aRules)
 3964: {
 3964:   NS_ENSURE_FALSE(mInShutdown, nsnull);
 3964:   nsStyleContext* result = nsnull;
 3964:   nsPresContext *presContext = PresContext();
 3964: 
 3964:   if (presContext) {
33399:     nsRuleWalker ruleWalker(mRuleTree);
31309:     if (aRuleNode)
33399:       ruleWalker.SetCurrentNode(aRuleNode);
31309:     // FIXME: Perhaps this should be passed in, but it probably doesn't
31309:     // matter.
35529:     ruleWalker.SetLevel(eDocSheet, PR_FALSE, PR_FALSE);
31309:     for (PRInt32 i = 0; i < aRules.Count(); i++) {
33399:       ruleWalker.Forward(aRules.ObjectAt(i));
 3964:     }
33399:     result = GetContext(presContext, aParentContext,
35613:                         ruleWalker.CurrentNode(), aPseudoTag,
35554:                         aPseudoType).get();
 3964:   }
 3964:   return result;
 3964: }
 3964: 
 3964: already_AddRefed<nsStyleContext>
    1: nsStyleSet::ResolveStyleForNonElement(nsStyleContext* aParentContext)
    1: {
    1:   nsStyleContext* result = nsnull;
    1:   nsPresContext *presContext = PresContext();
    1: 
    1:   if (presContext) {
33399:     result = GetContext(presContext, aParentContext, mRuleTree,
35554:                         nsCSSAnonBoxes::mozNonElement,
35554:                         nsCSSPseudoElements::ePseudo_AnonBox).get();
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
22737: void
35555: nsStyleSet::WalkRestrictionRule(nsCSSPseudoElements::Type aPseudoType,
33399:                                 nsRuleWalker* aRuleWalker)
22737: {
22737:   // This needs to match GetPseudoRestriction in nsRuleNode.cpp.
35529:   aRuleWalker->SetLevel(eAgentSheet, PR_FALSE, PR_FALSE);
35555:   if (aPseudoType == nsCSSPseudoElements::ePseudo_firstLetter)
33399:     aRuleWalker->Forward(mFirstLetterRule);
35555:   else if (aPseudoType == nsCSSPseudoElements::ePseudo_firstLine)
33399:     aRuleWalker->Forward(mFirstLineRule);
22737: }
35549: 
35555: already_AddRefed<nsStyleContext>
35555: nsStyleSet::ResolvePseudoElementStyle(nsIContent* aParentContent,
35555:                                       nsCSSPseudoElements::Type aType,
35555:                                       nsStyleContext* aParentContext)
35555: {
35555:   NS_ENSURE_FALSE(mInShutdown, nsnull);
35555: 
35555:   NS_ASSERTION(aType < nsCSSPseudoElements::ePseudo_PseudoElementCount,
35555:                "must have pseudo element type");
35555:   NS_ASSERTION(aParentContent &&
35555:                aParentContent->IsNodeOfType(nsINode::eELEMENT),
35555:                "aParentContent must be element");
35555: 
35555:   nsRuleWalker ruleWalker(mRuleTree);
35555:   nsPresContext *presContext = PresContext();
35555:   PseudoElementRuleProcessorData data(presContext, aParentContent, &ruleWalker,
35555:                                       aType);
35555:   WalkRestrictionRule(aType, &ruleWalker);
35558:   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
35558:             aParentContent, &ruleWalker);
35555: 
35613:   return GetContext(presContext, aParentContext, ruleWalker.CurrentNode(),
35555:                     nsCSSPseudoElements::GetPseudoAtom(aType), aType);
35555: }
35555: 
35549: already_AddRefed<nsStyleContext>
35554: nsStyleSet::ProbePseudoElementStyle(nsIContent* aParentContent,
35554:                                     nsCSSPseudoElements::Type aType,
35549:                                     nsStyleContext* aParentContext)
35549: {
35549:   NS_ENSURE_FALSE(mInShutdown, nsnull);
35549:   
35555:   NS_ASSERTION(aType < nsCSSPseudoElements::ePseudo_PseudoElementCount,
35555:                "must have pseudo element type");
35549:   NS_ASSERTION(aParentContent &&
35549:                aParentContent->IsNodeOfType(nsINode::eELEMENT),
35549:                "aParentContent must be element");
35549: 
35555:   nsIAtom* pseudoTag = nsCSSPseudoElements::GetPseudoAtom(aType);
35555: 
35555:   nsPresContext *presContext = PresContext();
35555: 
35549:   nsRuleWalker ruleWalker(mRuleTree);
35555:   PseudoElementRuleProcessorData data(presContext, aParentContent, &ruleWalker,
35555:                                       aType);
35555:   WalkRestrictionRule(aType, &ruleWalker);
35549:   // not the root if there was a restriction rule
35613:   nsRuleNode *adjustedRoot = ruleWalker.CurrentNode();
35558:   FileRules(EnumRulesMatching<PseudoElementRuleProcessorData>, &data,
35558:             aParentContent, &ruleWalker);
35549: 
35613:   nsRuleNode *ruleNode = ruleWalker.CurrentNode();
35555:   if (ruleNode == adjustedRoot) {
35555:     return nsnull;
35549:   }
35549: 
35555:   nsRefPtr<nsStyleContext> result =
35555:     GetContext(presContext, aParentContext, ruleNode, pseudoTag, aType);
35555: 
35549:   // For :before and :after pseudo-elements, having display: none or no
35549:   // 'content' property is equivalent to not having the pseudo-element
35549:   // at all.
35549:   if (result &&
35554:       (pseudoTag == nsCSSPseudoElements::before ||
35554:        pseudoTag == nsCSSPseudoElements::after)) {
35549:     const nsStyleDisplay *display = result->GetStyleDisplay();
35549:     const nsStyleContent *content = result->GetStyleContent();
35549:     // XXXldb What is contentCount for |content: ""|?
35549:     if (display->mDisplay == NS_STYLE_DISPLAY_NONE ||
35549:         content->ContentCount() == 0) {
35549:       result = nsnull;
35549:     }
35549:   }
35549:   
35555:   return result.forget();
35549: }
35542: 
35556: already_AddRefed<nsStyleContext>
35556: nsStyleSet::ResolveAnonymousBoxStyle(nsIAtom* aPseudoTag,
35556:                                      nsStyleContext* aParentContext)
35556: {
35556:   NS_ENSURE_FALSE(mInShutdown, nsnull);
35556: 
35556: #ifdef DEBUG
35556:     PRBool isAnonBox = nsCSSAnonBoxes::IsAnonBox(aPseudoTag)
35556: #ifdef MOZ_XUL
35556:                  && !nsCSSAnonBoxes::IsTreePseudoElement(aPseudoTag)
35556: #endif
35556:       ;
35556:     NS_PRECONDITION(isAnonBox, "Unexpected pseudo");
35556: #endif
35556: 
35556:   nsRuleWalker ruleWalker(mRuleTree);
35556:   nsPresContext *presContext = PresContext();
35556:   AnonBoxRuleProcessorData data(presContext, aPseudoTag, &ruleWalker);
35558:   FileRules(EnumRulesMatching<AnonBoxRuleProcessorData>, &data, nsnull,
35558:             &ruleWalker);
35556: 
35613:   return GetContext(presContext, aParentContext, ruleWalker.CurrentNode(),
35556:                     aPseudoTag, nsCSSPseudoElements::ePseudo_AnonBox);
35556: }
35556: 
35558: #ifdef MOZ_XUL
35558: already_AddRefed<nsStyleContext>
35558: nsStyleSet::ResolveXULTreePseudoStyle(nsIContent* aParentContent,
35558:                                       nsIAtom* aPseudoTag,
35558:                                       nsStyleContext* aParentContext,
35558:                                       nsICSSPseudoComparator* aComparator)
35558: {
35558:   NS_ENSURE_FALSE(mInShutdown, nsnull);
35558: 
35558:   NS_ASSERTION(aPseudoTag, "must have pseudo tag");
35558:   NS_ASSERTION(aParentContent->IsNodeOfType(nsINode::eELEMENT),
35558:                "content (if non-null) must be element");
35558:   NS_ASSERTION(nsCSSAnonBoxes::IsTreePseudoElement(aPseudoTag),
35558:                "Unexpected pseudo");
35558: 
35558:   nsRuleWalker ruleWalker(mRuleTree);
35558:   nsPresContext *presContext = PresContext();
35558: 
35558:   XULTreeRuleProcessorData data(presContext, aParentContent, &ruleWalker,
35558:                                 aPseudoTag, aComparator);
35558:   FileRules(EnumRulesMatching<XULTreeRuleProcessorData>, &data, aParentContent,
35558:             &ruleWalker);
35558: 
35613:   return GetContext(presContext, aParentContext, ruleWalker.CurrentNode(),
35558:                     aPseudoTag, nsCSSPseudoElements::ePseudo_XULTree);
35558: }
35558: #endif
35558: 
21924: PRBool
21924: nsStyleSet::AppendFontFaceRules(nsPresContext* aPresContext,
21983:                                 nsTArray<nsFontFaceRuleContainer>& aArray)
21924: {
21924:   NS_ENSURE_FALSE(mInShutdown, PR_FALSE);
21924: 
21924:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gCSSSheetTypes); ++i) {
21924:     nsCSSRuleProcessor *ruleProc = static_cast<nsCSSRuleProcessor*>
21924:                                     (mRuleProcessors[gCSSSheetTypes[i]].get());
21924:     if (ruleProc && !ruleProc->AppendFontFaceRules(aPresContext, aArray))
21924:       return PR_FALSE;
21924:   }
21924:   return PR_TRUE;
21924: }
21924: 
    1: void
    1: nsStyleSet::BeginShutdown(nsPresContext* aPresContext)
    1: {
    1:   mInShutdown = 1;
    1:   mRoots.Clear(); // no longer valid, since we won't keep it up to date
    1: }
    1: 
    1: void
    1: nsStyleSet::Shutdown(nsPresContext* aPresContext)
    1: {
    1:   mRuleTree->Destroy();
    1:   mRuleTree = nsnull;
    1: 
24429:   // We can have old rule trees either because:
24429:   //   (1) we failed the assertions in EndReconstruct, or
24429:   //   (2) we're shutting down within a reconstruct (see bug 462392)
24429:   for (PRUint32 i = mOldRuleTrees.Length(); i > 0; ) {
24429:     --i;
24429:     mOldRuleTrees[i]->Destroy();
24429:   }
24429:   mOldRuleTrees.Clear();
24429: 
    1:   mDefaultStyleData.Destroy(0, aPresContext);
    1: }
    1: 
33275: static const PRUint32 kGCInterval = 300;
    1: 
    1: void
    1: nsStyleSet::NotifyStyleContextDestroyed(nsPresContext* aPresContext,
    1:                                         nsStyleContext* aStyleContext)
    1: {
    1:   if (mInShutdown)
    1:     return;
    1: 
 8007:   // Remove style contexts from mRoots even if mOldRuleTree is non-null.  This
 8007:   // could be a style context from the new ruletree!
    1:   if (!aStyleContext->GetParent()) {
    1:     mRoots.RemoveElement(aStyleContext);
    1:   }
    1: 
24429:   if (mInReconstruct)
 8007:     return;
 8007: 
33020:   if (mUnusedRuleNodeCount == kGCInterval) {
24429:     GCRuleTrees();
24429:   }
24429: }
24429: 
24429: void
24429: nsStyleSet::GCRuleTrees()
24429: {
33020:   mUnusedRuleNodeCount = 0;
    1: 
24429:   // Mark the style context tree by marking all style contexts which
24429:   // have no parent, which will mark all descendants.  This will reach
24429:   // style contexts in the undisplayed map and "additional style
24429:   // contexts" since they are descendants of the roots.
 3959:   for (PRInt32 i = mRoots.Length() - 1; i >= 0; --i) {
 3959:     mRoots[i]->Mark();
    1:   }
    1: 
    1:   // Sweep the rule tree.
    1: #ifdef DEBUG
    1:   PRBool deleted =
    1: #endif
    1:     mRuleTree->Sweep();
24429:   NS_ASSERTION(!deleted, "Root node must not be gc'd");
24418: 
24429:   // Sweep the old rule trees.
24429:   for (PRUint32 i = mOldRuleTrees.Length(); i > 0; ) {
24429:     --i;
24429:     if (mOldRuleTrees[i]->Sweep()) {
24429:       // It was deleted, as it should be.
24429:       mOldRuleTrees.RemoveElementAt(i);
24429:     } else {
24429:       NS_NOTREACHED("old rule tree still referenced");
24429:     }
    1:   }
    1: }
    1: 
    1: already_AddRefed<nsStyleContext>
    1: nsStyleSet::ReParentStyleContext(nsPresContext* aPresContext,
    1:                                  nsStyleContext* aStyleContext, 
    1:                                  nsStyleContext* aNewParentContext)
    1: {
    1:   NS_ASSERTION(aPresContext, "must have pres context");
    1:   NS_ASSERTION(aStyleContext, "must have style context");
    1: 
    1:   if (aPresContext && aStyleContext) {
    1:     if (aStyleContext->GetParent() == aNewParentContext) {
    1:       aStyleContext->AddRef();
    1:       return aStyleContext;
    1:     }
    1:     else {  // really a new parent
34387:       nsIAtom* pseudoTag = aStyleContext->GetPseudo();
35554:       nsCSSPseudoElements::Type pseudoType = aStyleContext->GetPseudoType();
    1:       nsRuleNode* ruleNode = aStyleContext->GetRuleNode();
    1: 
    1:       already_AddRefed<nsStyleContext> result =
35554:         GetContext(aPresContext, aNewParentContext, ruleNode, pseudoTag,
35554:                    pseudoType);
    1:       return result;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: struct StatefulData : public StateRuleProcessorData {
    1:   StatefulData(nsPresContext* aPresContext,
    1:                nsIContent* aContent, PRInt32 aStateMask)
    1:     : StateRuleProcessorData(aPresContext, aContent, aStateMask),
    1:       mHint(nsReStyleHint(0))
    1:   {}
    1:   nsReStyleHint   mHint;
    1: }; 
    1: 
    1: static PRBool SheetHasStatefulStyle(nsIStyleRuleProcessor* aProcessor,
    1:                                     void *aData)
    1: {
    1:   StatefulData* data = (StatefulData*)aData;
35614:   nsReStyleHint hint = aProcessor->HasStateDependentStyle(data);
    1:   data->mHint = nsReStyleHint(data->mHint | hint);
    1:   return PR_TRUE; // continue
    1: }
    1: 
    1: // Test if style is dependent on content state
    1: nsReStyleHint
    1: nsStyleSet::HasStateDependentStyle(nsPresContext* aPresContext,
    1:                                    nsIContent*     aContent,
    1:                                    PRInt32         aStateMask)
    1: {
    1:   nsReStyleHint result = nsReStyleHint(0);
    1: 
16224:   if (aContent->IsNodeOfType(nsINode::eELEMENT)) {
    1:     StatefulData data(aPresContext, aContent, aStateMask);
    1:     WalkRuleProcessors(SheetHasStatefulStyle, &data);
    1:     result = data.mHint;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: struct AttributeData : public AttributeRuleProcessorData {
    1:   AttributeData(nsPresContext* aPresContext,
 4036:                 nsIContent* aContent, nsIAtom* aAttribute, PRInt32 aModType,
35534:                 PRBool aAttrHasChanged)
 4036:     : AttributeRuleProcessorData(aPresContext, aContent, aAttribute, aModType,
35534:                                  aAttrHasChanged),
    1:       mHint(nsReStyleHint(0))
    1:   {}
    1:   nsReStyleHint   mHint;
    1: }; 
    1: 
    1: static PRBool
    1: SheetHasAttributeStyle(nsIStyleRuleProcessor* aProcessor, void *aData)
    1: {
    1:   AttributeData* data = (AttributeData*)aData;
35533:   nsReStyleHint hint = aProcessor->HasAttributeDependentStyle(data);
    1:   data->mHint = nsReStyleHint(data->mHint | hint);
    1:   return PR_TRUE; // continue
    1: }
    1: 
    1: // Test if style is dependent on content state
    1: nsReStyleHint
    1: nsStyleSet::HasAttributeDependentStyle(nsPresContext* aPresContext,
    1:                                        nsIContent*    aContent,
    1:                                        nsIAtom*       aAttribute,
 3410:                                        PRInt32        aModType,
35534:                                        PRBool         aAttrHasChanged)
    1: {
    1:   nsReStyleHint result = nsReStyleHint(0);
    1: 
16224:   if (aContent->IsNodeOfType(nsINode::eELEMENT)) {
 4036:     AttributeData data(aPresContext, aContent, aAttribute, aModType,
35534:                        aAttrHasChanged);
    1:     WalkRuleProcessors(SheetHasAttributeStyle, &data);
    1:     result = data.mHint;
    1:   }
    1: 
    1:   return result;
    1: }
16225: 
16225: PRBool
16225: nsStyleSet::MediumFeaturesChanged(nsPresContext* aPresContext)
16225: {
16225:   // We can't use WalkRuleProcessors without a content node.
16225:   PRBool stylesChanged = PR_FALSE;
16225:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(mRuleProcessors); ++i) {
16225:     nsIStyleRuleProcessor *processor = mRuleProcessors[i];
16225:     if (!processor) {
16225:       continue;
16225:     }
16225:     PRBool thisChanged = PR_FALSE;
16225:     processor->MediumFeaturesChanged(aPresContext, &thisChanged);
16225:     stylesChanged = stylesChanged || thisChanged;
16225:   }
16225: 
16231:   if (mBindingManager) {
16231:     PRBool thisChanged = PR_FALSE;
16231:     mBindingManager->MediumFeaturesChanged(aPresContext, &thisChanged);
16231:     stylesChanged = stylesChanged || thisChanged;
16231:   }
16231: 
16225:   return stylesChanged;
16225: }
36785: 
36785: nsCSSStyleSheet::EnsureUniqueInnerResult
36785: nsStyleSet::EnsureUniqueInnerOnCSSSheets()
36785: {
36785:   nsAutoTArray<nsCSSStyleSheet*, 32> queue;
36785:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gCSSSheetTypes); ++i) {
36785:     nsCOMArray<nsIStyleSheet> &sheets = mSheets[gCSSSheetTypes[i]];
36785:     for (PRUint32 j = 0, j_end = sheets.Count(); j < j_end; ++j) {
36785:       nsCSSStyleSheet *sheet = static_cast<nsCSSStyleSheet*>(sheets[j]);
36785:       if (!queue.AppendElement(sheet)) {
36785:         return nsCSSStyleSheet::eUniqueInner_CloneFailed;
36785:       }
36785:     }
36785:   }
36785: 
36785:   nsCSSStyleSheet::EnsureUniqueInnerResult res =
36785:     nsCSSStyleSheet::eUniqueInner_AlreadyUnique;
36785:   while (!queue.IsEmpty()) {
36785:     PRUint32 idx = queue.Length() - 1;
36785:     nsCSSStyleSheet *sheet = queue[idx];
36785:     queue.RemoveElementAt(idx);
36785: 
36785:     nsCSSStyleSheet::EnsureUniqueInnerResult sheetRes =
36785:       sheet->EnsureUniqueInner();
36785:     if (sheetRes == nsCSSStyleSheet::eUniqueInner_CloneFailed) {
36785:       return sheetRes;
36785:     }
36785:     if (sheetRes == nsCSSStyleSheet::eUniqueInner_ClonedInner) {
36785:       res = sheetRes;
36785:     }
36785: 
36785:     // Enqueue all the sheet's children.
36785:     if (!sheet->AppendAllChildSheets(queue)) {
36785:       return nsCSSStyleSheet::eUniqueInner_CloneFailed;
36785:     }
36785:   }
36785:   return res;
36785: }
