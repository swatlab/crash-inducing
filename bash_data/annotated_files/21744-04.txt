    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS symbol tables.
    1:  */
    1: #include "jsstddef.h"
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
    1: #include "jsarena.h"
    1: #include "jsbit.h"
    1: #include "jsclist.h"
    1: #include "jsdhash.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
    1: #include "jsdbgapi.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsscope.h"
    1: #include "jsstr.h"
    1: 
    1: JSScope *
    1: js_GetMutableScope(JSContext *cx, JSObject *obj)
    1: {
    1:     JSScope *scope, *newscope;
13705:     JSClass *clasp;
13705:     uint32 freeslot;
    1: 
    1:     scope = OBJ_SCOPE(obj);
    1:     JS_ASSERT(JS_IS_SCOPE_LOCKED(cx, scope));
    1:     if (scope->object == obj)
    1:         return scope;
    1:     newscope = js_NewScope(cx, 0, scope->map.ops, LOCKED_OBJ_GET_CLASS(obj),
    1:                            obj);
    1:     if (!newscope)
    1:         return NULL;
    1:     JS_LOCK_SCOPE(cx, newscope);
    1:     obj->map = js_HoldObjectMap(cx, &newscope->map);
13705:     JS_ASSERT(newscope->map.freeslot == JSSLOT_FREE(STOBJ_GET_CLASS(obj)));
13705:     clasp = STOBJ_GET_CLASS(obj);
13705:     if (clasp->reserveSlots) {
13705:         freeslot = JSSLOT_FREE(clasp) + clasp->reserveSlots(cx, obj);
13705:         if (freeslot > STOBJ_NSLOTS(obj))
13705:             freeslot = STOBJ_NSLOTS(obj);
13705:         if (newscope->map.freeslot < freeslot)
13705:             newscope->map.freeslot = freeslot;
13705:     }
    1:     scope = (JSScope *) js_DropObjectMap(cx, &scope->map, obj);
    1:     JS_TRANSFER_SCOPE_LOCK(cx, scope, newscope);
    1:     return newscope;
    1: }
    1: 
    1: /*
    1:  * JSScope uses multiplicative hashing, _a la_ jsdhash.[ch], but specialized
    1:  * to minimize footprint.  But if a scope has fewer than SCOPE_HASH_THRESHOLD
    1:  * entries, we use linear search and avoid allocating scope->table.
    1:  */
    1: #define SCOPE_HASH_THRESHOLD    6
    1: #define MIN_SCOPE_SIZE_LOG2     4
    1: #define MIN_SCOPE_SIZE          JS_BIT(MIN_SCOPE_SIZE_LOG2)
    1: #define SCOPE_TABLE_NBYTES(n)   ((n) * sizeof(JSScopeProperty *))
    1: 
    1: static void
    1: InitMinimalScope(JSScope *scope)
    1: {
11377:     scope->shape = 0;
    1:     scope->hashShift = JS_DHASH_BITS - MIN_SCOPE_SIZE_LOG2;
    1:     scope->entryCount = scope->removedCount = 0;
    1:     scope->table = NULL;
    1:     scope->lastProp = NULL;
    1: }
    1: 
    1: static JSBool
    1: CreateScopeTable(JSContext *cx, JSScope *scope, JSBool report)
    1: {
    1:     int sizeLog2;
    1:     JSScopeProperty *sprop, **spp;
    1: 
    1:     JS_ASSERT(!scope->table);
    1:     JS_ASSERT(scope->lastProp);
    1: 
    1:     if (scope->entryCount > SCOPE_HASH_THRESHOLD) {
    1:         /*
12307:          * Either we're creating a table for a large scope that was populated
12307:          * via property cache hit logic under JSOP_INITPROP, JSOP_SETNAME, or
12307:          * JSOP_SETPROP; or else calloc failed at least once already. In any
12307:          * event, let's try to grow, overallocating to hold at least twice the
12307:          * current population.
    1:          */
    1:         sizeLog2 = JS_CeilingLog2(2 * scope->entryCount);
    1:         scope->hashShift = JS_DHASH_BITS - sizeLog2;
    1:     } else {
    1:         JS_ASSERT(scope->hashShift == JS_DHASH_BITS - MIN_SCOPE_SIZE_LOG2);
    1:         sizeLog2 = MIN_SCOPE_SIZE_LOG2;
    1:     }
    1: 
    1:     scope->table = (JSScopeProperty **)
    1:         calloc(JS_BIT(sizeLog2), sizeof(JSScopeProperty *));
    1:     if (!scope->table) {
    1:         if (report)
    1:             JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
    1:     js_UpdateMallocCounter(cx, JS_BIT(sizeLog2) * sizeof(JSScopeProperty *));
    1: 
    1:     scope->hashShift = JS_DHASH_BITS - sizeLog2;
    1:     for (sprop = scope->lastProp; sprop; sprop = sprop->parent) {
    1:         spp = js_SearchScope(scope, sprop->id, JS_TRUE);
    1:         SPROP_STORE_PRESERVING_COLLISION(spp, sprop);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSScope *
    1: js_NewScope(JSContext *cx, jsrefcount nrefs, JSObjectOps *ops, JSClass *clasp,
    1:             JSObject *obj)
    1: {
    1:     JSScope *scope;
    1: 
    1:     scope = (JSScope *) JS_malloc(cx, sizeof(JSScope));
    1:     if (!scope)
    1:         return NULL;
    1: 
    1:     js_InitObjectMap(&scope->map, nrefs, ops, clasp);
    1:     scope->object = obj;
    1:     scope->flags = 0;
    1:     InitMinimalScope(scope);
    1: 
    1: #ifdef JS_THREADSAFE
11739:     js_InitTitle(cx, &scope->title);
    1: #endif
    1:     JS_RUNTIME_METER(cx->runtime, liveScopes);
    1:     JS_RUNTIME_METER(cx->runtime, totalScopes);
    1:     return scope;
    1: }
    1: 
    1: #ifdef DEBUG_SCOPE_COUNT
    1: extern void
    1: js_unlog_scope(JSScope *scope);
    1: #endif
    1: 
10217: #if defined DEBUG || defined JS_DUMP_PROPTREE_STATS
10217: # include "jsprf.h"
10217: # define LIVE_SCOPE_METER(cx,expr) JS_LOCK_RUNTIME_VOID(cx->runtime,expr)
10217: #else
10217: # define LIVE_SCOPE_METER(cx,expr) /* nothing */
10217: #endif
10217: 
    1: void
    1: js_DestroyScope(JSContext *cx, JSScope *scope)
    1: {
    1: #ifdef DEBUG_SCOPE_COUNT
    1:     js_unlog_scope(scope);
    1: #endif
    1: 
    1: #ifdef JS_THREADSAFE
11739:     js_FinishTitle(cx, &scope->title);
    1: #endif
    1:     if (scope->table)
    1:         JS_free(cx, scope->table);
    1: 
10217:     LIVE_SCOPE_METER(cx, cx->runtime->liveScopeProps -= scope->entryCount);
    1:     JS_RUNTIME_UNMETER(cx->runtime, liveScopes);
    1:     JS_free(cx, scope);
    1: }
    1: 
10217: #ifdef JS_DUMP_PROPTREE_STATS
    1: typedef struct JSScopeStats {
    1:     jsrefcount          searches;
    1:     jsrefcount          hits;
    1:     jsrefcount          misses;
 3230:     jsrefcount          hashes;
 3230:     jsrefcount          steps;
    1:     jsrefcount          stepHits;
    1:     jsrefcount          stepMisses;
    1:     jsrefcount          adds;
    1:     jsrefcount          redundantAdds;
    1:     jsrefcount          addFailures;
    1:     jsrefcount          changeFailures;
    1:     jsrefcount          compresses;
    1:     jsrefcount          grows;
    1:     jsrefcount          removes;
    1:     jsrefcount          removeFrees;
    1:     jsrefcount          uselessRemoves;
    1:     jsrefcount          shrinks;
    1: } JSScopeStats;
    1: 
10217: JS_FRIEND_DATA(JSScopeStats) js_scope_stats = {0};
    1: 
    1: # define METER(x)       JS_ATOMIC_INCREMENT(&js_scope_stats.x)
    1: #else
    1: # define METER(x)       /* nothing */
    1: #endif
    1: 
 3328: JS_STATIC_ASSERT(sizeof(JSHashNumber) == 4);
 3328: JS_STATIC_ASSERT(sizeof(jsid) == JS_BYTES_PER_WORD);
 3328: 
 3328: #if JS_BYTES_PER_WORD == 4
 3328: # define HASH_ID(id) ((JSHashNumber)(id))
 3328: #elif JS_BYTES_PER_WORD == 8
 3328: # define HASH_ID(id) ((JSHashNumber)(id) ^ (JSHashNumber)((id) >> 32))
 3328: #else
 3328: # error "Unsupported configuration"
 3328: #endif
 3328: 
    1: /*
    1:  * Double hashing needs the second hash code to be relatively prime to table
    1:  * size, so we simply make hash2 odd.  The inputs to multiplicative hash are
 3328:  * the golden ratio, expressed as a fixed-point 32 bit fraction, and the id
 3328:  * itself.
    1:  */
    1: #define SCOPE_HASH0(id)                 (HASH_ID(id) * JS_GOLDEN_RATIO)
    1: #define SCOPE_HASH1(hash0,shift)        ((hash0) >> (shift))
    1: #define SCOPE_HASH2(hash0,log2,shift)   ((((hash0) << (log2)) >> (shift)) | 1)
    1: 
    1: JS_FRIEND_API(JSScopeProperty **)
    1: js_SearchScope(JSScope *scope, jsid id, JSBool adding)
    1: {
    1:     JSHashNumber hash0, hash1, hash2;
    1:     int hashShift, sizeLog2;
    1:     JSScopeProperty *stored, *sprop, **spp, **firstRemoved;
    1:     uint32 sizeMask;
    1: 
    1:     METER(searches);
    1:     if (!scope->table) {
    1:         /* Not enough properties to justify hashing: search from lastProp. */
    1:         JS_ASSERT(!SCOPE_HAD_MIDDLE_DELETE(scope));
    1:         for (spp = &scope->lastProp; (sprop = *spp); spp = &sprop->parent) {
    1:             if (sprop->id == id) {
    1:                 METER(hits);
    1:                 return spp;
    1:             }
    1:         }
    1:         METER(misses);
    1:         return spp;
    1:     }
    1: 
12307:     /* Compute the primary hash address. */
 3230:     METER(hashes);
    1:     hash0 = SCOPE_HASH0(id);
    1:     hashShift = scope->hashShift;
    1:     hash1 = SCOPE_HASH1(hash0, hashShift);
    1:     spp = scope->table + hash1;
    1: 
    1:     /* Miss: return space for a new entry. */
    1:     stored = *spp;
    1:     if (SPROP_IS_FREE(stored)) {
    1:         METER(misses);
    1:         return spp;
    1:     }
    1: 
    1:     /* Hit: return entry. */
    1:     sprop = SPROP_CLEAR_COLLISION(stored);
    1:     if (sprop && sprop->id == id) {
    1:         METER(hits);
    1:         return spp;
    1:     }
    1: 
    1:     /* Collision: double hash. */
    1:     sizeLog2 = JS_DHASH_BITS - hashShift;
    1:     hash2 = SCOPE_HASH2(hash0, sizeLog2, hashShift);
    1:     sizeMask = JS_BITMASK(sizeLog2);
    1: 
    1:     /* Save the first removed entry pointer so we can recycle it if adding. */
    1:     if (SPROP_IS_REMOVED(stored)) {
    1:         firstRemoved = spp;
    1:     } else {
    1:         firstRemoved = NULL;
    1:         if (adding && !SPROP_HAD_COLLISION(stored))
    1:             SPROP_FLAG_COLLISION(spp, sprop);
    1:     }
    1: 
    1:     for (;;) {
    1:         METER(steps);
    1:         hash1 -= hash2;
    1:         hash1 &= sizeMask;
    1:         spp = scope->table + hash1;
    1: 
    1:         stored = *spp;
    1:         if (SPROP_IS_FREE(stored)) {
    1:             METER(stepMisses);
    1:             return (adding && firstRemoved) ? firstRemoved : spp;
    1:         }
    1: 
    1:         sprop = SPROP_CLEAR_COLLISION(stored);
    1:         if (sprop && sprop->id == id) {
    1:             METER(stepHits);
    1:             return spp;
    1:         }
    1: 
    1:         if (SPROP_IS_REMOVED(stored)) {
    1:             if (!firstRemoved)
    1:                 firstRemoved = spp;
    1:         } else {
    1:             if (adding && !SPROP_HAD_COLLISION(stored))
    1:                 SPROP_FLAG_COLLISION(spp, sprop);
    1:         }
    1:     }
    1: 
    1:     /* NOTREACHED */
    1:     return NULL;
    1: }
    1: 
    1: static JSBool
    1: ChangeScope(JSContext *cx, JSScope *scope, int change)
    1: {
    1:     int oldlog2, newlog2;
    1:     uint32 oldsize, newsize, nbytes;
    1:     JSScopeProperty **table, **oldtable, **spp, **oldspp, *sprop;
    1: 
12307:     if (!scope->table)
12307:         return CreateScopeTable(cx, scope, JS_TRUE);
12307: 
    1:     /* Grow, shrink, or compress by changing scope->table. */
    1:     oldlog2 = JS_DHASH_BITS - scope->hashShift;
    1:     newlog2 = oldlog2 + change;
    1:     oldsize = JS_BIT(oldlog2);
    1:     newsize = JS_BIT(newlog2);
    1:     nbytes = SCOPE_TABLE_NBYTES(newsize);
    1:     table = (JSScopeProperty **) calloc(nbytes, 1);
    1:     if (!table) {
    1:         JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /* Now that we have a new table allocated, update scope members. */
    1:     scope->hashShift = JS_DHASH_BITS - newlog2;
    1:     scope->removedCount = 0;
    1:     oldtable = scope->table;
    1:     scope->table = table;
    1: 
    1:     /* Treat the above calloc as a JS_malloc, to match CreateScopeTable. */
    1:     cx->runtime->gcMallocBytes += nbytes;
    1: 
    1:     /* Copy only live entries, leaving removed and free ones behind. */
    1:     for (oldspp = oldtable; oldsize != 0; oldspp++) {
    1:         sprop = SPROP_FETCH(oldspp);
    1:         if (sprop) {
    1:             spp = js_SearchScope(scope, sprop->id, JS_TRUE);
    1:             JS_ASSERT(SPROP_IS_FREE(*spp));
    1:             *spp = sprop;
    1:         }
    1:         oldsize--;
    1:     }
    1: 
    1:     /* Finally, free the old table storage. */
    1:     JS_free(cx, oldtable);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /*
 8367:  * Take care to exclude the mark bits in case we're called from the GC.
    1:  */
11377: #define SPROP_FLAGS_NOT_MATCHED (SPROP_MARK | SPROP_FLAG_SHAPE_REGEN)
    1: 
18907: static JSDHashNumber
    1: js_HashScopeProperty(JSDHashTable *table, const void *key)
    1: {
    1:     const JSScopeProperty *sprop = (const JSScopeProperty *)key;
    1:     JSDHashNumber hash;
    1:     JSPropertyOp gsop;
    1: 
    1:     /* Accumulate from least to most random so the low bits are most random. */
    1:     hash = 0;
    1:     gsop = sprop->getter;
    1:     if (gsop)
10992:         hash = JS_ROTATE_LEFT32(hash, 4) ^ (jsword)gsop;
    1:     gsop = sprop->setter;
    1:     if (gsop)
10992:         hash = JS_ROTATE_LEFT32(hash, 4) ^ (jsword)gsop;
    1: 
10992:     hash = JS_ROTATE_LEFT32(hash, 4)
    1:            ^ (sprop->flags & ~SPROP_FLAGS_NOT_MATCHED);
    1: 
10992:     hash = JS_ROTATE_LEFT32(hash, 4) ^ sprop->attrs;
10992:     hash = JS_ROTATE_LEFT32(hash, 4) ^ sprop->shortid;
10992:     hash = JS_ROTATE_LEFT32(hash, 4) ^ sprop->slot;
10992:     hash = JS_ROTATE_LEFT32(hash, 4) ^ sprop->id;
    1:     return hash;
    1: }
    1: 
    1: #define SPROP_MATCH(sprop, child)                                             \
    1:     SPROP_MATCH_PARAMS(sprop, (child)->id, (child)->getter, (child)->setter,  \
    1:                        (child)->slot, (child)->attrs, (child)->flags,         \
    1:                        (child)->shortid)
    1: 
    1: #define SPROP_MATCH_PARAMS(sprop, aid, agetter, asetter, aslot, aattrs,       \
    1:                            aflags, ashortid)                                  \
    1:     ((sprop)->id == (aid) &&                                                  \
    1:      SPROP_MATCH_PARAMS_AFTER_ID(sprop, agetter, asetter, aslot, aattrs,      \
    1:                                  aflags, ashortid))
    1: 
    1: #define SPROP_MATCH_PARAMS_AFTER_ID(sprop, agetter, asetter, aslot, aattrs,   \
    1:                                     aflags, ashortid)                         \
    1:     ((sprop)->getter == (agetter) &&                                          \
    1:      (sprop)->setter == (asetter) &&                                          \
    1:      (sprop)->slot == (aslot) &&                                              \
    1:      (sprop)->attrs == (aattrs) &&                                            \
    1:      (((sprop)->flags ^ (aflags)) & ~SPROP_FLAGS_NOT_MATCHED) == 0 &&         \
    1:      (sprop)->shortid == (ashortid))
    1: 
18907: static JSBool
    1: js_MatchScopeProperty(JSDHashTable *table,
    1:                       const JSDHashEntryHdr *hdr,
    1:                       const void *key)
    1: {
    1:     const JSPropertyTreeEntry *entry = (const JSPropertyTreeEntry *)hdr;
    1:     const JSScopeProperty *sprop = entry->child;
    1:     const JSScopeProperty *kprop = (const JSScopeProperty *)key;
    1: 
    1:     return SPROP_MATCH(sprop, kprop);
    1: }
    1: 
    1: static const JSDHashTableOps PropertyTreeHashOps = {
    1:     JS_DHashAllocTable,
    1:     JS_DHashFreeTable,
    1:     js_HashScopeProperty,
    1:     js_MatchScopeProperty,
    1:     JS_DHashMoveEntryStub,
    1:     JS_DHashClearEntryStub,
    1:     JS_DHashFinalizeStub,
    1:     NULL
    1: };
    1: 
    1: /*
    1:  * A property tree node on rt->propertyFreeList overlays the following prefix
    1:  * struct on JSScopeProperty.
    1:  */
    1: typedef struct FreeNode {
    1:     jsid                id;
    1:     JSScopeProperty     *next;
    1:     JSScopeProperty     **prevp;
    1: } FreeNode;
    1: 
    1: #define FREENODE(sprop) ((FreeNode *) (sprop))
    1: 
    1: #define FREENODE_INSERT(list, sprop)                                          \
    1:     JS_BEGIN_MACRO                                                            \
    1:         FREENODE(sprop)->next = (list);                                       \
    1:         FREENODE(sprop)->prevp = &(list);                                     \
    1:         if (list)                                                             \
    1:             FREENODE(list)->prevp = &FREENODE(sprop)->next;                   \
    1:         (list) = (sprop);                                                     \
    1:     JS_END_MACRO
    1: 
    1: #define FREENODE_REMOVE(sprop)                                                \
    1:     JS_BEGIN_MACRO                                                            \
    1:         *FREENODE(sprop)->prevp = FREENODE(sprop)->next;                      \
    1:         if (FREENODE(sprop)->next)                                            \
    1:             FREENODE(FREENODE(sprop)->next)->prevp = FREENODE(sprop)->prevp;  \
    1:     JS_END_MACRO
    1: 
14755: /* NB: Called with rt->gcLock held. */
    1: static JSScopeProperty *
    1: NewScopeProperty(JSRuntime *rt)
    1: {
    1:     JSScopeProperty *sprop;
    1: 
    1:     sprop = rt->propertyFreeList;
    1:     if (sprop) {
    1:         FREENODE_REMOVE(sprop);
    1:     } else {
    1:         JS_ARENA_ALLOCATE_CAST(sprop, JSScopeProperty *,
    1:                                &rt->propertyArenaPool,
    1:                                sizeof(JSScopeProperty));
    1:         if (!sprop)
    1:             return NULL;
    1:     }
    1: 
    1:     JS_RUNTIME_METER(rt, livePropTreeNodes);
    1:     JS_RUNTIME_METER(rt, totalPropTreeNodes);
    1:     return sprop;
    1: }
    1: 
    1: #define CHUNKY_KIDS_TAG         ((jsuword)1)
    1: #define KIDS_IS_CHUNKY(kids)    ((jsuword)(kids) & CHUNKY_KIDS_TAG)
    1: #define KIDS_TO_CHUNK(kids)     ((PropTreeKidsChunk *)                        \
    1:                                  ((jsuword)(kids) & ~CHUNKY_KIDS_TAG))
    1: #define CHUNK_TO_KIDS(chunk)    ((JSScopeProperty *)                          \
    1:                                  ((jsuword)(chunk) | CHUNKY_KIDS_TAG))
    1: #define MAX_KIDS_PER_CHUNK      10
    1: #define CHUNK_HASH_THRESHOLD    30
    1: 
    1: typedef struct PropTreeKidsChunk PropTreeKidsChunk;
    1: 
    1: struct PropTreeKidsChunk {
    1:     JSScopeProperty     *kids[MAX_KIDS_PER_CHUNK];
    1:     JSDHashTable        *table;
    1:     PropTreeKidsChunk   *next;
    1: };
    1: 
    1: static PropTreeKidsChunk *
    1: NewPropTreeKidsChunk(JSRuntime *rt)
    1: {
    1:     PropTreeKidsChunk *chunk;
    1: 
 3164:     chunk = (PropTreeKidsChunk *) calloc(1, sizeof *chunk);
    1:     if (!chunk)
    1:         return NULL;
    1:     JS_ASSERT(((jsuword)chunk & CHUNKY_KIDS_TAG) == 0);
    1:     JS_RUNTIME_METER(rt, propTreeKidsChunks);
    1:     return chunk;
    1: }
    1: 
    1: static void
    1: DestroyPropTreeKidsChunk(JSRuntime *rt, PropTreeKidsChunk *chunk)
    1: {
    1:     JS_RUNTIME_UNMETER(rt, propTreeKidsChunks);
    1:     if (chunk->table)
    1:         JS_DHashTableDestroy(chunk->table);
    1:     free(chunk);
    1: }
    1: 
14755: /* NB: Called with rt->gcLock held. */
    1: static JSBool
    1: InsertPropertyTreeChild(JSRuntime *rt, JSScopeProperty *parent,
    1:                         JSScopeProperty *child, PropTreeKidsChunk *sweptChunk)
    1: {
    1:     JSDHashTable *table;
    1:     JSPropertyTreeEntry *entry;
    1:     JSScopeProperty **childp, *kids, *sprop;
    1:     PropTreeKidsChunk *chunk, **chunkp;
    1:     uintN i;
    1: 
    1:     JS_ASSERT(!parent || child->parent != parent);
    1: 
    1:     if (!parent) {
    1:         table = &rt->propertyTreeHash;
    1:         entry = (JSPropertyTreeEntry *)
    1:                 JS_DHashTableOperate(table, child, JS_DHASH_ADD);
    1:         if (!entry)
    1:             return JS_FALSE;
    1:         childp = &entry->child;
    1:         sprop = *childp;
    1:         if (!sprop) {
    1:             *childp = child;
    1:         } else {
    1:             /*
    1:              * A "Duplicate child" case.
    1:              *
    1:              * We can't do away with child, as at least one live scope entry
    1:              * still points at it.  What's more, that scope's lastProp chains
    1:              * through an ancestor line to reach child, and js_Enumerate and
    1:              * others count on this linkage.  We must leave child out of the
    1:              * hash table, and not require it to be there when we eventually
    1:              * GC it (see RemovePropertyTreeChild, below).
    1:              *
    1:              * It is necessary to leave the duplicate child out of the hash
    1:              * table to preserve entry uniqueness.  It is safe to leave the
    1:              * child out of the hash table (unlike the duplicate child cases
    1:              * below), because the child's parent link will be null, which
    1:              * can't dangle.
    1:              */
    1:             JS_ASSERT(sprop != child && SPROP_MATCH(sprop, child));
    1:             JS_RUNTIME_METER(rt, duplicatePropTreeNodes);
    1:         }
    1:     } else {
    1:         childp = &parent->kids;
    1:         kids = *childp;
    1:         if (kids) {
    1:             if (KIDS_IS_CHUNKY(kids)) {
    1:                 chunk = KIDS_TO_CHUNK(kids);
    1: 
    1:                 table = chunk->table;
    1:                 if (table) {
    1:                     entry = (JSPropertyTreeEntry *)
    1:                             JS_DHashTableOperate(table, child, JS_DHASH_ADD);
    1:                     if (!entry)
    1:                         return JS_FALSE;
    1:                     if (!entry->child) {
    1:                         entry->child = child;
    1:                         while (chunk->next)
    1:                             chunk = chunk->next;
    1:                         for (i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
    1:                             childp = &chunk->kids[i];
    1:                             sprop = *childp;
    1:                             if (!sprop)
    1:                                 goto insert;
    1:                         }
    1:                         chunkp = &chunk->next;
    1:                         goto new_chunk;
    1:                     }
    1:                 }
    1: 
    1:                 do {
    1:                     for (i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
    1:                         childp = &chunk->kids[i];
    1:                         sprop = *childp;
    1:                         if (!sprop)
    1:                             goto insert;
    1: 
    1:                         JS_ASSERT(sprop != child);
    1:                         if (SPROP_MATCH(sprop, child)) {
    1:                             /*
    1:                              * Duplicate child, see comment above.  In this
    1:                              * case, we must let the duplicate be inserted at
    1:                              * this level in the tree, so we keep iterating,
    1:                              * looking for an empty slot in which to insert.
    1:                              */
    1:                             JS_ASSERT(sprop != child);
    1:                             JS_RUNTIME_METER(rt, duplicatePropTreeNodes);
    1:                         }
    1:                     }
    1:                     chunkp = &chunk->next;
    1:                 } while ((chunk = *chunkp) != NULL);
    1: 
    1:             new_chunk:
    1:                 if (sweptChunk) {
    1:                     chunk = sweptChunk;
    1:                 } else {
    1:                     chunk = NewPropTreeKidsChunk(rt);
    1:                     if (!chunk)
    1:                         return JS_FALSE;
    1:                 }
    1:                 *chunkp = chunk;
    1:                 childp = &chunk->kids[0];
    1:             } else {
    1:                 sprop = kids;
    1:                 JS_ASSERT(sprop != child);
    1:                 if (SPROP_MATCH(sprop, child)) {
    1:                     /*
    1:                      * Duplicate child, see comment above.  Once again, we
    1:                      * must let duplicates created by deletion pile up in a
    1:                      * kids-chunk-list, in order to find them when sweeping
    1:                      * and thereby avoid dangling parent pointers.
    1:                      */
    1:                     JS_RUNTIME_METER(rt, duplicatePropTreeNodes);
    1:                 }
    1:                 if (sweptChunk) {
    1:                     chunk = sweptChunk;
    1:                 } else {
    1:                     chunk = NewPropTreeKidsChunk(rt);
    1:                     if (!chunk)
    1:                         return JS_FALSE;
    1:                 }
    1:                 parent->kids = CHUNK_TO_KIDS(chunk);
    1:                 chunk->kids[0] = sprop;
    1:                 childp = &chunk->kids[1];
    1:             }
    1:         }
    1:     insert:
    1:         *childp = child;
    1:     }
    1: 
    1:     child->parent = parent;
    1:     return JS_TRUE;
    1: }
    1: 
14755: /* NB: Called with rt->gcLock held. */
    1: static PropTreeKidsChunk *
    1: RemovePropertyTreeChild(JSRuntime *rt, JSScopeProperty *child)
    1: {
    1:     PropTreeKidsChunk *freeChunk;
    1:     JSScopeProperty *parent, *kids, *kid;
    1:     JSDHashTable *table;
    1:     PropTreeKidsChunk *list, *chunk, **chunkp, *lastChunk;
    1:     uintN i, j;
    1:     JSPropertyTreeEntry *entry;
    1: 
    1:     freeChunk = NULL;
    1:     parent = child->parent;
    1:     if (!parent) {
    1:         /*
    1:          * Don't remove child if it is not in rt->propertyTreeHash, but only
    1:          * matches a root child in the table that has compatible members. See
    1:          * the "Duplicate child" comments in InsertPropertyTreeChild, above.
    1:          */
    1:         table = &rt->propertyTreeHash;
    1:     } else {
    1:         kids = parent->kids;
    1:         if (KIDS_IS_CHUNKY(kids)) {
    1:             list = chunk = KIDS_TO_CHUNK(kids);
    1:             chunkp = &list;
    1:             table = chunk->table;
    1: 
    1:             do {
    1:                 for (i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
    1:                     if (chunk->kids[i] == child) {
    1:                         lastChunk = chunk;
    1:                         if (!lastChunk->next) {
    1:                             j = i + 1;
    1:                         } else {
    1:                             j = 0;
    1:                             do {
    1:                                 chunkp = &lastChunk->next;
    1:                                 lastChunk = *chunkp;
    1:                             } while (lastChunk->next);
    1:                         }
    1:                         for (; j < MAX_KIDS_PER_CHUNK; j++) {
    1:                             if (!lastChunk->kids[j])
    1:                                 break;
    1:                         }
    1:                         --j;
    1:                         if (chunk != lastChunk || j > i)
    1:                             chunk->kids[i] = lastChunk->kids[j];
    1:                         lastChunk->kids[j] = NULL;
    1:                         if (j == 0) {
    1:                             *chunkp = NULL;
    1:                             if (!list)
    1:                                 parent->kids = NULL;
    1:                             freeChunk = lastChunk;
    1:                         }
    1:                         goto out;
    1:                     }
    1:                 }
    1: 
    1:                 chunkp = &chunk->next;
    1:             } while ((chunk = *chunkp) != NULL);
    1:         } else {
    1:             table = NULL;
    1:             kid = kids;
    1:             if (kid == child)
    1:                 parent->kids = NULL;
    1:         }
    1:     }
    1: 
    1: out:
    1:     if (table) {
    1:         entry = (JSPropertyTreeEntry *)
    1:                 JS_DHashTableOperate(table, child, JS_DHASH_LOOKUP);
    1: 
    1:         if (entry->child == child)
    1:             JS_DHashTableRawRemove(table, &entry->hdr);
    1:     }
    1:     return freeChunk;
    1: }
    1: 
    1: static JSDHashTable *
    1: HashChunks(PropTreeKidsChunk *chunk, uintN n)
    1: {
    1:     JSDHashTable *table;
    1:     uintN i;
    1:     JSScopeProperty *sprop;
    1:     JSPropertyTreeEntry *entry;
    1: 
    1:     table = JS_NewDHashTable(&PropertyTreeHashOps, NULL,
    1:                              sizeof(JSPropertyTreeEntry),
    1:                              JS_DHASH_DEFAULT_CAPACITY(n + 1));
    1:     if (!table)
    1:         return NULL;
    1:     do {
    1:         for (i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
    1:             sprop = chunk->kids[i];
    1:             if (!sprop)
    1:                 break;
    1:             entry = (JSPropertyTreeEntry *)
    1:                     JS_DHashTableOperate(table, sprop, JS_DHASH_ADD);
    1:             entry->child = sprop;
    1:         }
    1:     } while ((chunk = chunk->next) != NULL);
    1:     return table;
    1: }
    1: 
    1: /*
14755:  * Called without cx->runtime->gcLock held. This function acquires that lock
14755:  * only when inserting a new child.  Thus there may be races to find or add a
14755:  * node that result in duplicates.  We expect such races to be rare!
14755:  *
14755:  * We use rt->gcLock, not rt->rtLock, to allow the GC potentially to nest here
14755:  * under js_GenerateShape.
    1:  */
    1: static JSScopeProperty *
    1: GetPropertyTreeChild(JSContext *cx, JSScopeProperty *parent,
    1:                      JSScopeProperty *child)
    1: {
    1:     JSRuntime *rt;
    1:     JSDHashTable *table;
    1:     JSPropertyTreeEntry *entry;
    1:     JSScopeProperty *sprop;
    1:     PropTreeKidsChunk *chunk;
    1:     uintN i, n;
21744:     uint32 shape;
    1: 
    1:     rt = cx->runtime;
    1:     if (!parent) {
14755:         JS_LOCK_GC(rt);
    1: 
    1:         table = &rt->propertyTreeHash;
    1:         entry = (JSPropertyTreeEntry *)
    1:                 JS_DHashTableOperate(table, child, JS_DHASH_ADD);
    1:         if (!entry)
    1:             goto out_of_memory;
    1: 
    1:         sprop = entry->child;
    1:         if (sprop)
    1:             goto out;
    1:     } else {
    1:         /*
    1:          * Because chunks are appended at the end and never deleted except by
14755:          * the GC, we can search without taking the runtime's GC lock.  We may
14755:          * miss a matching sprop added by another thread, and make a duplicate
14755:          * one, but that is an unlikely, therefore small, cost.  The property
14755:          * tree has extremely low fan-out below its root in popular embeddings
14755:          * with real-world workloads.
    1:          *
    1:          * Patterns such as defining closures that capture a constructor's
    1:          * environment as getters or setters on the new object that is passed
    1:          * in as |this| can significantly increase fan-out below the property
    1:          * tree root -- see bug 335700 for details.
    1:          */
    1:         entry = NULL;
    1:         sprop = parent->kids;
    1:         if (sprop) {
    1:             if (KIDS_IS_CHUNKY(sprop)) {
    1:                 chunk = KIDS_TO_CHUNK(sprop);
    1: 
    1:                 table = chunk->table;
    1:                 if (table) {
14755:                     JS_LOCK_GC(rt);
    1:                     entry = (JSPropertyTreeEntry *)
    1:                             JS_DHashTableOperate(table, child, JS_DHASH_LOOKUP);
    1:                     sprop = entry->child;
    1:                     if (sprop) {
14755:                         JS_UNLOCK_GC(rt);
    1:                         return sprop;
    1:                     }
    1:                     goto locked_not_found;
    1:                 }
    1: 
    1:                 n = 0;
    1:                 do {
    1:                     for (i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
    1:                         sprop = chunk->kids[i];
    1:                         if (!sprop) {
    1:                             n += i;
    1:                             if (n >= CHUNK_HASH_THRESHOLD) {
    1:                                 chunk = KIDS_TO_CHUNK(parent->kids);
    1:                                 if (!chunk->table) {
    1:                                     table = HashChunks(chunk, n);
14755:                                     JS_LOCK_GC(rt);
    1:                                     if (!table)
    1:                                         goto out_of_memory;
    1:                                     if (chunk->table)
    1:                                         JS_DHashTableDestroy(table);
    1:                                     else
    1:                                         chunk->table = table;
    1:                                     goto locked_not_found;
    1:                                 }
    1:                             }
    1:                             goto not_found;
    1:                         }
    1: 
    1:                         if (SPROP_MATCH(sprop, child))
    1:                             return sprop;
    1:                     }
    1:                     n += MAX_KIDS_PER_CHUNK;
    1:                 } while ((chunk = chunk->next) != NULL);
    1:             } else {
    1:                 if (SPROP_MATCH(sprop, child))
    1:                     return sprop;
    1:             }
    1:         }
    1: 
    1:     not_found:
14755:         JS_LOCK_GC(rt);
    1:     }
    1: 
    1: locked_not_found:
21744:     /*
21744:      * Call js_GenerateShape before the allocation to prevent collecting the
21744:      * new property when the shape generation triggers the GC.
21744:      */
21744:     shape = js_GenerateShape(cx, JS_TRUE, NULL);
21744: 
    1:     sprop = NewScopeProperty(rt);
    1:     if (!sprop)
    1:         goto out_of_memory;
    1: 
    1:     sprop->id = child->id;
    1:     sprop->getter = child->getter;
    1:     sprop->setter = child->setter;
    1:     sprop->slot = child->slot;
    1:     sprop->attrs = child->attrs;
    1:     sprop->flags = child->flags;
    1:     sprop->shortid = child->shortid;
    1:     sprop->parent = sprop->kids = NULL;
21744:     sprop->shape = shape;
11377: 
    1:     if (!parent) {
    1:         entry->child = sprop;
    1:     } else {
    1:         if (!InsertPropertyTreeChild(rt, parent, sprop, NULL))
    1:             goto out_of_memory;
    1:     }
    1: 
    1: out:
14755:     JS_UNLOCK_GC(rt);
    1:     return sprop;
    1: 
    1: out_of_memory:
14755:     JS_UNLOCK_GC(rt);
    1:     JS_ReportOutOfMemory(cx);
    1:     return NULL;
    1: }
    1: 
    1: #ifdef DEBUG_notbrendan
    1: #define CHECK_ANCESTOR_LINE(scope, sparse)                                    \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if ((scope)->table) CheckAncestorLine(scope, sparse);                 \
    1:     JS_END_MACRO
    1: 
    1: static void
    1: CheckAncestorLine(JSScope *scope, JSBool sparse)
    1: {
    1:     uint32 size;
    1:     JSScopeProperty **spp, **start, **end, *ancestorLine, *sprop, *aprop;
    1:     uint32 entryCount, ancestorCount;
    1: 
    1:     ancestorLine = SCOPE_LAST_PROP(scope);
    1:     if (ancestorLine)
    1:         JS_ASSERT(SCOPE_HAS_PROPERTY(scope, ancestorLine));
    1: 
    1:     entryCount = 0;
    1:     size = SCOPE_CAPACITY(scope);
    1:     start = scope->table;
    1:     for (spp = start, end = start + size; spp < end; spp++) {
    1:         sprop = SPROP_FETCH(spp);
    1:         if (sprop) {
    1:             entryCount++;
    1:             for (aprop = ancestorLine; aprop; aprop = aprop->parent) {
    1:                 if (aprop == sprop)
    1:                     break;
    1:             }
    1:             JS_ASSERT(aprop);
    1:         }
    1:     }
    1:     JS_ASSERT(entryCount == scope->entryCount);
    1: 
    1:     ancestorCount = 0;
    1:     for (sprop = ancestorLine; sprop; sprop = sprop->parent) {
    1:         if (SCOPE_HAD_MIDDLE_DELETE(scope) &&
    1:             !SCOPE_HAS_PROPERTY(scope, sprop)) {
 8367:             JS_ASSERT(sparse);
    1:             continue;
    1:         }
    1:         ancestorCount++;
    1:     }
    1:     JS_ASSERT(ancestorCount == scope->entryCount);
    1: }
    1: #else
    1: #define CHECK_ANCESTOR_LINE(scope, sparse) /* nothing */
    1: #endif
    1: 
    1: static void
    1: ReportReadOnlyScope(JSContext *cx, JSScope *scope)
    1: {
    1:     JSString *str;
    1:     const char *bytes;
    1: 
    1:     str = js_ValueToString(cx, OBJECT_TO_JSVAL(scope->object));
    1:     if (!str)
    1:         return;
    1:     bytes = js_GetStringBytes(cx, str);
    1:     if (!bytes)
    1:         return;
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_READ_ONLY, bytes);
    1: }
    1: 
    1: JSScopeProperty *
    1: js_AddScopeProperty(JSContext *cx, JSScope *scope, jsid id,
    1:                     JSPropertyOp getter, JSPropertyOp setter, uint32 slot,
    1:                     uintN attrs, uintN flags, intN shortid)
    1: {
    1:     JSScopeProperty **spp, *sprop, *overwriting, **spvec, **spp2, child;
    1:     uint32 size, splen, i;
    1:     int change;
 1695:     JSTempValueRooter tvr;
    1: 
    1:     JS_ASSERT(JS_IS_SCOPE_LOCKED(cx, scope));
    1:     CHECK_ANCESTOR_LINE(scope, JS_TRUE);
    1: 
    1:     /*
    1:      * You can't add properties to a sealed scope.  But note well that you can
    1:      * change property attributes in a sealed scope, even though that replaces
    1:      * a JSScopeProperty * in the scope's hash table -- but no id is added, so
    1:      * the scope remains sealed.
    1:      */
    1:     if (SCOPE_IS_SEALED(scope)) {
    1:         ReportReadOnlyScope(cx, scope);
    1:         return NULL;
    1:     }
    1: 
    1:     /*
    1:      * Normalize stub getter and setter values for faster is-stub testing in
    1:      * the SPROP_CALL_[GS]ETTER macros.
    1:      */
    1:     if (getter == JS_PropertyStub)
    1:         getter = NULL;
    1:     if (setter == JS_PropertyStub)
    1:         setter = NULL;
    1: 
    1:     /*
    1:      * Search for id in order to claim its entry, allocating a property tree
    1:      * node if one doesn't already exist for our parameters.
    1:      */
    1:     spp = js_SearchScope(scope, id, JS_TRUE);
    1:     sprop = overwriting = SPROP_FETCH(spp);
    1:     if (!sprop) {
    1:         JS_COUNT_OPERATION(cx, JSOW_NEW_PROPERTY);
    1: 
    1:         /* Check whether we need to grow, if the load factor is >= .75. */
    1:         size = SCOPE_CAPACITY(scope);
    1:         if (scope->entryCount + scope->removedCount >= size - (size >> 2)) {
    1:             if (scope->removedCount >= size >> 2) {
    1:                 METER(compresses);
    1:                 change = 0;
    1:             } else {
    1:                 METER(grows);
    1:                 change = 1;
    1:             }
    1:             if (!ChangeScope(cx, scope, change) &&
    1:                 scope->entryCount + scope->removedCount == size - 1) {
    1:                 METER(addFailures);
    1:                 return NULL;
    1:             }
    1:             spp = js_SearchScope(scope, id, JS_TRUE);
    1:             JS_ASSERT(!SPROP_FETCH(spp));
    1:         }
    1:     } else {
    1:         /* Property exists: js_SearchScope must have returned a valid entry. */
    1:         JS_ASSERT(!SPROP_IS_REMOVED(*spp));
    1: 
    1:         /*
    1:          * If all property members match, this is a redundant add and we can
    1:          * return early.  If the caller wants to allocate a slot, but doesn't
    1:          * care which slot, copy sprop->slot into slot so we can match sprop,
    1:          * if all other members match.
    1:          */
    1:         if (!(attrs & JSPROP_SHARED) &&
    1:             slot == SPROP_INVALID_SLOT &&
    1:             SPROP_HAS_VALID_SLOT(sprop, scope)) {
    1:             slot = sprop->slot;
    1:         }
    1:         if (SPROP_MATCH_PARAMS_AFTER_ID(sprop, getter, setter, slot, attrs,
    1:                                         flags, shortid)) {
    1:             METER(redundantAdds);
    1:             return sprop;
    1:         }
    1: 
    1:         /*
    1:          * If we are clearing sprop to force an existing property to be
    1:          * overwritten (apart from a duplicate formal parameter), we must
    1:          * unlink it from the ancestor line at scope->lastProp, lazily if
    1:          * sprop is not lastProp.  And we must remove the entry at *spp,
    1:          * precisely so the lazy "middle delete" fixup code further below
    1:          * won't find sprop in scope->table, in spite of sprop being on
    1:          * the ancestor line.
    1:          *
    1:          * When we finally succeed in finding or creating a new sprop
    1:          * and storing its pointer at *spp, we'll use the |overwriting|
    1:          * local saved when we first looked up id to decide whether we're
    1:          * indeed creating a new entry, or merely overwriting an existing
    1:          * property.
    1:          */
    1:         if (sprop == SCOPE_LAST_PROP(scope)) {
    1:             do {
    1:                 SCOPE_REMOVE_LAST_PROP(scope);
    1:                 if (!SCOPE_HAD_MIDDLE_DELETE(scope))
    1:                     break;
    1:                 sprop = SCOPE_LAST_PROP(scope);
    1:             } while (sprop && !SCOPE_HAS_PROPERTY(scope, sprop));
    1:         } else if (!SCOPE_HAD_MIDDLE_DELETE(scope)) {
    1:             /*
    1:              * If we have no hash table yet, we need one now.  The middle
    1:              * delete code is simple-minded that way!
    1:              */
    1:             if (!scope->table) {
    1:                 if (!CreateScopeTable(cx, scope, JS_TRUE))
    1:                     return NULL;
    1:                 spp = js_SearchScope(scope, id, JS_TRUE);
    1:                 sprop = overwriting = SPROP_FETCH(spp);
    1:             }
    1:             SCOPE_SET_MIDDLE_DELETE(scope);
    1:         }
12307:         SCOPE_MAKE_UNIQUE_SHAPE(cx, scope);
    1: 
    1:         /*
    1:          * If we fail later on trying to find or create a new sprop, we will
    1:          * goto fail_overwrite and restore *spp from |overwriting|.  Note that
    1:          * we don't bother to keep scope->removedCount in sync, because we'll
    1:          * fix up *spp and scope->entryCount shortly, no matter how control
    1:          * flow returns from this function.
    1:          */
    1:         if (scope->table)
    1:             SPROP_STORE_PRESERVING_COLLISION(spp, NULL);
    1:         scope->entryCount--;
    1:         CHECK_ANCESTOR_LINE(scope, JS_TRUE);
    1:         sprop = NULL;
    1:     }
    1: 
    1:     if (!sprop) {
    1:         /*
    1:          * If properties were deleted from the middle of the list starting at
    1:          * scope->lastProp, we may need to fork the property tree and squeeze
    1:          * all deleted properties out of scope's ancestor line.  Otherwise we
    1:          * risk adding a node with the same id as a "middle" node, violating
 8367:          * the rule that properties along an ancestor line have distinct ids.
    1:          */
    1:         if (SCOPE_HAD_MIDDLE_DELETE(scope)) {
    1:             JS_ASSERT(scope->table);
    1:             CHECK_ANCESTOR_LINE(scope, JS_TRUE);
    1: 
    1:             splen = scope->entryCount;
    1:             if (splen == 0) {
    1:                 JS_ASSERT(scope->lastProp == NULL);
    1:             } else {
    1:                 /*
    1:                  * Enumerate live entries in scope->table using a temporary
    1:                  * vector, by walking the (possibly sparse, due to deletions)
    1:                  * ancestor line from scope->lastProp.
    1:                  */
    1:                 spvec = (JSScopeProperty **)
    1:                         JS_malloc(cx, SCOPE_TABLE_NBYTES(splen));
    1:                 if (!spvec)
    1:                     goto fail_overwrite;
    1:                 i = splen;
    1:                 sprop = SCOPE_LAST_PROP(scope);
    1:                 JS_ASSERT(sprop);
    1:                 do {
    1:                     /*
    1:                      * NB: test SCOPE_GET_PROPERTY, not SCOPE_HAS_PROPERTY --
    1:                      * the latter insists that sprop->id maps to sprop, while
    1:                      * the former simply tests whether sprop->id is bound in
    1:                      * scope.  We must allow for duplicate formal parameters
    1:                      * along the ancestor line, and fork them as needed.
    1:                      */
    1:                     if (!SCOPE_GET_PROPERTY(scope, sprop->id))
    1:                         continue;
    1: 
    1:                     JS_ASSERT(sprop != overwriting);
    1:                     if (i == 0) {
    1:                         /*
    1:                          * If our original splen estimate, scope->entryCount,
    1:                          * is less than the ancestor line height, there must
    1:                          * be duplicate formal parameters in this (function
    1:                          * object) scope.  Count remaining ancestors in order
    1:                          * to realloc spvec.
    1:                          */
    1:                         JSScopeProperty *tmp = sprop;
    1:                         do {
    1:                             if (SCOPE_GET_PROPERTY(scope, tmp->id))
    1:                                 i++;
    1:                         } while ((tmp = tmp->parent) != NULL);
    1:                         spp2 = (JSScopeProperty **)
    1:                              JS_realloc(cx, spvec, SCOPE_TABLE_NBYTES(splen+i));
    1:                         if (!spp2) {
    1:                             JS_free(cx, spvec);
    1:                             goto fail_overwrite;
    1:                         }
    1: 
    1:                         spvec = spp2;
    1:                         memmove(spvec + i, spvec, SCOPE_TABLE_NBYTES(splen));
    1:                         splen += i;
    1:                     }
    1: 
    1:                     spvec[--i] = sprop;
    1:                 } while ((sprop = sprop->parent) != NULL);
    1:                 JS_ASSERT(i == 0);
    1: 
    1:                 /*
    1:                  * Now loop forward through spvec, forking the property tree
    1:                  * whenever we see a "parent gap" due to deletions from scope.
    1:                  * NB: sprop is null on first entry to the loop body.
    1:                  */
    1:                 do {
    1:                     if (spvec[i]->parent == sprop) {
    1:                         sprop = spvec[i];
    1:                     } else {
    1:                         sprop = GetPropertyTreeChild(cx, sprop, spvec[i]);
    1:                         if (!sprop) {
    1:                             JS_free(cx, spvec);
    1:                             goto fail_overwrite;
    1:                         }
    1: 
    1:                         spp2 = js_SearchScope(scope, sprop->id, JS_FALSE);
    1:                         JS_ASSERT(SPROP_FETCH(spp2) == spvec[i]);
    1:                         SPROP_STORE_PRESERVING_COLLISION(spp2, sprop);
    1:                     }
    1:                 } while (++i < splen);
    1:                 JS_free(cx, spvec);
    1: 
    1:                 /*
    1:                  * Now sprop points to the last property in scope, where the
    1:                  * ancestor line from sprop to the root is dense w.r.t. scope:
    1:                  * it contains no nodes not mapped by scope->table, apart from
    1:                  * any stinking ECMA-mandated duplicate formal parameters.
    1:                  */
    1:                 scope->lastProp = sprop;
    1:                 CHECK_ANCESTOR_LINE(scope, JS_FALSE);
    1:                 JS_RUNTIME_METER(cx->runtime, middleDeleteFixups);
    1:             }
    1: 
    1:             SCOPE_CLR_MIDDLE_DELETE(scope);
    1:         }
    1: 
    1:         /*
    1:          * Aliases share another property's slot, passed in the |slot| param.
    1:          * Shared properties have no slot.  Unshared properties that do not
    1:          * alias another property's slot get one here, but may lose it due to
    1:          * a JS_ClearScope call.
    1:          */
    1:         if (!(flags & SPROP_IS_ALIAS)) {
    1:             if (attrs & JSPROP_SHARED) {
    1:                 slot = SPROP_INVALID_SLOT;
    1:             } else {
    1:                 /*
    1:                  * We may have set slot from a nearly-matching sprop, above.
    1:                  * If so, we're overwriting that nearly-matching sprop, so we
    1:                  * can reuse its slot -- we don't need to allocate a new one.
11835:                  * Similarly, we use a specific slot if provided by the caller.
    1:                  */
11835:                 if (slot == SPROP_INVALID_SLOT &&
11835:                     !js_AllocSlot(cx, scope->object, &slot)) {
    1:                     goto fail_overwrite;
    1:                 }
    1:             }
11835:         }
    1: 
    1:         /*
    1:          * Check for a watchpoint on a deleted property; if one exists, change
    1:          * setter to js_watch_set.
    1:          * XXXbe this could get expensive with lots of watchpoints...
    1:          */
    1:         if (!JS_CLIST_IS_EMPTY(&cx->runtime->watchPointList) &&
    1:             js_FindWatchPoint(cx->runtime, scope, id)) {
 1695:             JS_PUSH_TEMP_ROOT_SPROP(cx, overwriting, &tvr);
    1:             setter = js_WrapWatchedSetter(cx, id, attrs, setter);
 1695:             JS_POP_TEMP_ROOT(cx, &tvr);
    1:             if (!setter)
    1:                 goto fail_overwrite;
    1:         }
    1: 
    1:         /* Find or create a property tree node labeled by our arguments. */
    1:         child.id = id;
    1:         child.getter = getter;
    1:         child.setter = setter;
    1:         child.slot = slot;
    1:         child.attrs = attrs;
    1:         child.flags = flags;
    1:         child.shortid = shortid;
    1:         sprop = GetPropertyTreeChild(cx, scope->lastProp, &child);
    1:         if (!sprop)
    1:             goto fail_overwrite;
    1: 
11377:         /*
11377:          * The scope's shape defaults to its last property's shape, but may
11377:          * be regenerated later as the scope diverges (from the property cache
11377:          * point of view) from the structural type associated with sprop.
11377:          */
12307:         SCOPE_EXTEND_SHAPE(cx, scope, sprop);
11377: 
    1:         /* Store the tree node pointer in the table entry for id. */
    1:         if (scope->table)
    1:             SPROP_STORE_PRESERVING_COLLISION(spp, sprop);
    1:         scope->entryCount++;
    1:         scope->lastProp = sprop;
    1:         CHECK_ANCESTOR_LINE(scope, JS_FALSE);
10217: #ifdef DEBUG
    1:         if (!overwriting) {
10217:             LIVE_SCOPE_METER(cx, ++cx->runtime->liveScopeProps);
    1:             JS_RUNTIME_METER(cx->runtime, totalScopeProps);
    1:         }
10217: #endif
    1: 
    1:         /*
    1:          * If we reach the hashing threshold, try to allocate scope->table.
    1:          * If we can't (a rare event, preceded by swapping to death on most
    1:          * modern OSes), stick with linear search rather than whining about
    1:          * this little set-back.  Therefore we must test !scope->table and
    1:          * scope->entryCount >= SCOPE_HASH_THRESHOLD, not merely whether the
    1:          * entry count just reached the threshold.
    1:          */
    1:         if (!scope->table && scope->entryCount >= SCOPE_HASH_THRESHOLD)
    1:             (void) CreateScopeTable(cx, scope, JS_FALSE);
    1:     }
    1: 
    1:     METER(adds);
    1:     return sprop;
    1: 
    1: fail_overwrite:
    1:     if (overwriting) {
    1:         /*
    1:          * We may or may not have forked overwriting out of scope's ancestor
    1:          * line, so we must check (the alternative is to set a flag above, but
    1:          * that hurts the common, non-error case).  If we did fork overwriting
    1:          * out, we'll add it back at scope->lastProp.  This means enumeration
    1:          * order can change due to a failure to overwrite an id.
    1:          * XXXbe very minor incompatibility
    1:          */
    1:         for (sprop = SCOPE_LAST_PROP(scope); ; sprop = sprop->parent) {
    1:             if (!sprop) {
    1:                 sprop = SCOPE_LAST_PROP(scope);
    1:                 if (overwriting->parent == sprop) {
    1:                     scope->lastProp = overwriting;
    1:                 } else {
    1:                     sprop = GetPropertyTreeChild(cx, sprop, overwriting);
    1:                     if (sprop) {
    1:                         JS_ASSERT(sprop != overwriting);
    1:                         scope->lastProp = sprop;
    1:                     }
    1:                     overwriting = sprop;
    1:                 }
    1:                 break;
    1:             }
    1:             if (sprop == overwriting)
    1:                 break;
    1:         }
    1:         if (overwriting) {
    1:             if (scope->table)
    1:                 SPROP_STORE_PRESERVING_COLLISION(spp, overwriting);
    1:             scope->entryCount++;
    1:         }
    1:         CHECK_ANCESTOR_LINE(scope, JS_TRUE);
    1:     }
    1:     METER(addFailures);
    1:     return NULL;
    1: }
    1: 
    1: JSScopeProperty *
    1: js_ChangeScopePropertyAttrs(JSContext *cx, JSScope *scope,
    1:                             JSScopeProperty *sprop, uintN attrs, uintN mask,
    1:                             JSPropertyOp getter, JSPropertyOp setter)
    1: {
    1:     JSScopeProperty child, *newsprop, **spp;
    1: 
    1:     CHECK_ANCESTOR_LINE(scope, JS_TRUE);
    1: 
    1:     /* Allow only shared (slot-less) => unshared (slot-full) transition. */
    1:     attrs |= sprop->attrs & mask;
    1:     JS_ASSERT(!((attrs ^ sprop->attrs) & JSPROP_SHARED) ||
    1:               !(attrs & JSPROP_SHARED));
    1:     if (getter == JS_PropertyStub)
    1:         getter = NULL;
    1:     if (setter == JS_PropertyStub)
    1:         setter = NULL;
    1:     if (sprop->attrs == attrs &&
    1:         sprop->getter == getter &&
    1:         sprop->setter == setter) {
    1:         return sprop;
    1:     }
    1: 
    1:     child.id = sprop->id;
    1:     child.getter = getter;
    1:     child.setter = setter;
    1:     child.slot = sprop->slot;
    1:     child.attrs = attrs;
    1:     child.flags = sprop->flags;
    1:     child.shortid = sprop->shortid;
    1: 
    1:     if (SCOPE_LAST_PROP(scope) == sprop) {
    1:         /*
    1:          * Optimize the case where the last property added to scope is changed
    1:          * to have a different attrs, getter, or setter.  In the last property
    1:          * case, we need not fork the property tree.  But since we do not call
    1:          * js_AddScopeProperty, we may need to allocate a new slot directly.
    1:          */
    1:         if ((sprop->attrs & JSPROP_SHARED) && !(attrs & JSPROP_SHARED)) {
    1:             JS_ASSERT(child.slot == SPROP_INVALID_SLOT);
    1:             if (!js_AllocSlot(cx, scope->object, &child.slot))
    1:                 return NULL;
    1:         }
    1: 
    1:         newsprop = GetPropertyTreeChild(cx, sprop->parent, &child);
    1:         if (newsprop) {
    1:             spp = js_SearchScope(scope, sprop->id, JS_FALSE);
    1:             JS_ASSERT(SPROP_FETCH(spp) == sprop);
    1: 
    1:             if (scope->table)
    1:                 SPROP_STORE_PRESERVING_COLLISION(spp, newsprop);
    1:             scope->lastProp = newsprop;
    1:             CHECK_ANCESTOR_LINE(scope, JS_TRUE);
    1:         }
    1:     } else {
    1:         /*
    1:          * Let js_AddScopeProperty handle this |overwriting| case, including
    1:          * the conservation of sprop->slot (if it's valid).  We must not call
    1:          * js_RemoveScopeProperty here, it will free a valid sprop->slot and
    1:          * js_AddScopeProperty won't re-allocate it.
    1:          */
    1:         newsprop = js_AddScopeProperty(cx, scope, child.id,
    1:                                        child.getter, child.setter, child.slot,
    1:                                        child.attrs, child.flags, child.shortid);
    1:     }
    1: 
11377:     if (newsprop) {
11377:         if (scope->shape == sprop->shape)
11377:             scope->shape = newsprop->shape;
11377:         else
12307:             SCOPE_MAKE_UNIQUE_SHAPE(cx, scope);
11377:     }
10217: #ifdef JS_DUMP_PROPTREE_STATS
11377:     else
    1:         METER(changeFailures);
    1: #endif
    1:     return newsprop;
    1: }
    1: 
    1: JSBool
    1: js_RemoveScopeProperty(JSContext *cx, JSScope *scope, jsid id)
    1: {
    1:     JSScopeProperty **spp, *stored, *sprop;
    1:     uint32 size;
    1: 
    1:     JS_ASSERT(JS_IS_SCOPE_LOCKED(cx, scope));
    1:     CHECK_ANCESTOR_LINE(scope, JS_TRUE);
    1:     if (SCOPE_IS_SEALED(scope)) {
    1:         ReportReadOnlyScope(cx, scope);
    1:         return JS_FALSE;
    1:     }
    1:     METER(removes);
    1: 
    1:     spp = js_SearchScope(scope, id, JS_FALSE);
    1:     stored = *spp;
    1:     sprop = SPROP_CLEAR_COLLISION(stored);
    1:     if (!sprop) {
    1:         METER(uselessRemoves);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /* Convert from a list to a hash so we can handle "middle deletes". */
    1:     if (!scope->table && sprop != scope->lastProp) {
    1:         if (!CreateScopeTable(cx, scope, JS_TRUE))
    1:             return JS_FALSE;
    1:         spp = js_SearchScope(scope, id, JS_FALSE);
    1:         stored = *spp;
    1:         sprop = SPROP_CLEAR_COLLISION(stored);
    1:     }
    1: 
    1:     /* First, if sprop is unshared and not cleared, free its slot number. */
    1:     if (SPROP_HAS_VALID_SLOT(sprop, scope)) {
    1:         js_FreeSlot(cx, scope->object, sprop->slot);
    1:         JS_ATOMIC_INCREMENT(&cx->runtime->propertyRemovals);
    1:     }
    1: 
    1:     /* Next, remove id by setting its entry to a removed or free sentinel. */
    1:     if (SPROP_HAD_COLLISION(stored)) {
    1:         JS_ASSERT(scope->table);
    1:         *spp = SPROP_REMOVED;
    1:         scope->removedCount++;
    1:     } else {
    1:         METER(removeFrees);
    1:         if (scope->table)
    1:             *spp = NULL;
    1:     }
    1:     scope->entryCount--;
10217:     LIVE_SCOPE_METER(cx, --cx->runtime->liveScopeProps);
    1: 
    1:     /* Update scope->lastProp directly, or set its deferred update flag. */
    1:     if (sprop == SCOPE_LAST_PROP(scope)) {
    1:         do {
    1:             SCOPE_REMOVE_LAST_PROP(scope);
    1:             if (!SCOPE_HAD_MIDDLE_DELETE(scope))
    1:                 break;
    1:             sprop = SCOPE_LAST_PROP(scope);
    1:         } while (sprop && !SCOPE_HAS_PROPERTY(scope, sprop));
    1:     } else if (!SCOPE_HAD_MIDDLE_DELETE(scope)) {
    1:         SCOPE_SET_MIDDLE_DELETE(scope);
    1:     }
12307:     SCOPE_MAKE_UNIQUE_SHAPE(cx, scope);
    1:     CHECK_ANCESTOR_LINE(scope, JS_TRUE);
    1: 
    1:     /* Last, consider shrinking scope's table if its load factor is <= .25. */
    1:     size = SCOPE_CAPACITY(scope);
    1:     if (size > MIN_SCOPE_SIZE && scope->entryCount <= size >> 2) {
    1:         METER(shrinks);
    1:         (void) ChangeScope(cx, scope, -1);
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: void
    1: js_ClearScope(JSContext *cx, JSScope *scope)
    1: {
    1:     CHECK_ANCESTOR_LINE(scope, JS_TRUE);
10217:     LIVE_SCOPE_METER(cx, cx->runtime->liveScopeProps -= scope->entryCount);
    1: 
    1:     if (scope->table)
    1:         free(scope->table);
    1:     SCOPE_CLR_MIDDLE_DELETE(scope);
    1:     InitMinimalScope(scope);
    1:     JS_ATOMIC_INCREMENT(&cx->runtime->propertyRemovals);
    1: }
    1: 
    1: void
  583: js_TraceId(JSTracer *trc, jsid id)
    1: {
 4529:     jsval v;
  583: 
 4529:     v = ID_TO_VALUE(id);
 4529:     JS_CALL_VALUE_TRACER(trc, v, "id");
  583: }
    1: 
  583: #ifdef DEBUG
  583: static void
  583: PrintPropertyGetterOrSetter(JSTracer *trc, char *buf, size_t bufsize)
  583: {
  583:     JSScopeProperty *sprop;
 4529:     jsid id;
  583:     size_t n;
  583:     const char *name;
  583: 
  583:     JS_ASSERT(trc->debugPrinter == PrintPropertyGetterOrSetter);
  583:     sprop = (JSScopeProperty *)trc->debugPrintArg;
 4529:     id = sprop->id;
  583:     name = trc->debugPrintIndex ? js_setter_str : js_getter_str;
  583: 
 8367:     if (JSID_IS_ATOM(id)) {
  583:         n = js_PutEscapedString(buf, bufsize - 1,
 4529:                                 ATOM_TO_STRING(JSID_TO_ATOM(id)), 0);
 4529:         if (n < bufsize - 1)
 8367:             JS_snprintf(buf + n, bufsize - n, " %s", name);
  583:     } else if (JSID_IS_INT(sprop->id)) {
 4529:         JS_snprintf(buf, bufsize, "%d %s", JSID_TO_INT(id), name);
  583:     } else {
  583:         JS_snprintf(buf, bufsize, "<object> %s", name);
  583:     }
  583: }
  583: #endif
  583: 
  583: 
    1: void
  583: js_TraceScopeProperty(JSTracer *trc, JSScopeProperty *sprop)
    1: {
 5975:     if (IS_GC_MARKING_TRACER(trc))
    1:         sprop->flags |= SPROP_MARK;
  583:     TRACE_ID(trc, sprop->id);
    1: 
    1: #if JS_HAS_GETTER_SETTER
    1:     if (sprop->attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
    1:         if (sprop->attrs & JSPROP_GETTER) {
  583:             JS_ASSERT(JSVAL_IS_OBJECT((jsval) sprop->getter));
  583:             JS_SET_TRACING_DETAILS(trc, PrintPropertyGetterOrSetter, sprop, 0);
  583:             JS_CallTracer(trc, JSVAL_TO_OBJECT((jsval) sprop->getter),
  583:                           JSTRACE_OBJECT);
    1:         }
    1:         if (sprop->attrs & JSPROP_SETTER) {
  583:             JS_ASSERT(JSVAL_IS_OBJECT((jsval) sprop->setter));
  583:             JS_SET_TRACING_DETAILS(trc, PrintPropertyGetterOrSetter, sprop, 1);
  583:             JS_CallTracer(trc, JSVAL_TO_OBJECT((jsval) sprop->setter),
  583:                           JSTRACE_OBJECT);
    1:         }
    1:     }
    1: #endif /* JS_HAS_GETTER_SETTER */
    1: }
    1: 
10217: #ifdef JS_DUMP_PROPTREE_STATS
    1: 
    1: #include <stdio.h>
    1: 
    1: static void
10217: MeterKidCount(JSBasicStats *bs, uintN nkids)
    1: {
10217:     JS_BASIC_STATS_ACCUM(bs, nkids);
10217:     bs->hist[JS_MIN(nkids, 10)]++;
    1: }
    1: 
    1: static void
10217: MeterPropertyTree(JSBasicStats *bs, JSScopeProperty *node)
    1: {
    1:     uintN i, nkids;
    1:     JSScopeProperty *kids, *kid;
    1:     PropTreeKidsChunk *chunk;
    1: 
    1:     nkids = 0;
    1:     kids = node->kids;
    1:     if (kids) {
    1:         if (KIDS_IS_CHUNKY(kids)) {
    1:             for (chunk = KIDS_TO_CHUNK(kids); chunk; chunk = chunk->next) {
    1:                 for (i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
    1:                     kid = chunk->kids[i];
    1:                     if (!kid)
    1:                         break;
10217:                     MeterPropertyTree(bs, kid);
    1:                     nkids++;
    1:                 }
    1:             }
    1:         } else {
10217:             MeterPropertyTree(bs, kids);
    1:             nkids = 1;
    1:         }
    1:     }
    1: 
10217:     MeterKidCount(bs, nkids);
    1: }
    1: 
18907: static JSDHashOperator
    1: js_MeterPropertyTree(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
    1:                      void *arg)
    1: {
    1:     JSPropertyTreeEntry *entry = (JSPropertyTreeEntry *)hdr;
10217:     JSBasicStats *bs = (JSBasicStats *)arg;
    1: 
10217:     MeterPropertyTree(bs, entry->child);
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: static void
    1: DumpSubtree(JSContext *cx, JSScopeProperty *sprop, int level, FILE *fp)
    1: {
 4529:     jsval v;
    1:     JSString *str;
    1:     JSScopeProperty *kids, *kid;
    1:     PropTreeKidsChunk *chunk;
    1:     uintN i;
    1: 
    1:     fprintf(fp, "%*sid ", level, "");
 4529:     v = ID_TO_VALUE(sprop->id);
 4529:     if (JSID_IS_INT(sprop->id)) {
 4529:         fprintf(fp, "%d", JSVAL_TO_INT(v));
 4529:     } else {
    1:         if (JSID_IS_ATOM(sprop->id)) {
 4529:             str = JSVAL_TO_STRING(v);
    1:         } else {
10217:             JS_ASSERT(JSID_IS_OBJECT(sprop->id));
 4529:             str = js_ValueToString(cx, v);
 4529:             fputs("object ", fp);
    1:         }
 4529:         if (!str)
 4529:             fputs("<error>", fp);
 4529:         else
 4529:             js_FileEscapedString(fp, str, '"');
 4529:     }
    1: 
10217:     fprintf(fp, " g/s %p/%p slot %u attrs %x flags %x shortid %d\n",
10217:             (void *) sprop->getter, (void *) sprop->setter, sprop->slot,
10217:             sprop->attrs, sprop->flags, sprop->shortid);
    1:     kids = sprop->kids;
    1:     if (kids) {
    1:         ++level;
    1:         if (KIDS_IS_CHUNKY(kids)) {
    1:             chunk = KIDS_TO_CHUNK(kids);
    1:             do {
    1:                 for (i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
    1:                     kid = chunk->kids[i];
    1:                     if (!kid)
    1:                         break;
    1:                     JS_ASSERT(kid->parent == sprop);
    1:                     DumpSubtree(cx, kid, level, fp);
    1:                 }
    1:             } while ((chunk = chunk->next) != NULL);
    1:         } else {
    1:             kid = kids;
    1:             DumpSubtree(cx, kid, level, fp);
    1:         }
    1:     }
    1: }
    1: 
10217: #endif /* JS_DUMP_PROPTREE_STATS */
    1: 
    1: void
    1: js_SweepScopeProperties(JSContext *cx)
    1: {
10217:     JSRuntime *rt = cx->runtime;
    1:     JSArena **ap, *a;
    1:     JSScopeProperty *limit, *sprop, *parent, *kids, *kid;
    1:     uintN liveCount;
    1:     PropTreeKidsChunk *chunk, *nextChunk, *freeChunk;
    1:     uintN i;
    1: 
10217: #ifdef JS_DUMP_PROPTREE_STATS
10217:     JSBasicStats bs;
    1:     uint32 livePropCapacity = 0, totalLiveCount = 0;
    1:     static FILE *logfp;
    1:     if (!logfp)
10217:         logfp = fopen("/tmp/proptree.stats", "w");
    1: 
10217:     JS_BASIC_STATS_INIT(&bs);
10217:     MeterKidCount(&bs, rt->propertyTreeHash.entryCount);
10217:     JS_DHashTableEnumerate(&rt->propertyTreeHash, js_MeterPropertyTree, &bs);
    1: 
    1:     {
10217:         double props, nodes, mean, sigma;
    1: 
10217:         props = rt->liveScopePropsPreSweep;
10217:         nodes = rt->livePropTreeNodes;
10217:         JS_ASSERT(nodes == bs.sum);
10217:         mean = JS_MeanAndStdDevBS(&bs, &sigma);
10217: 
10217:         fprintf(logfp,
10217:                 "props %g nodes %g beta %g meankids %g sigma %g max %u\n",
10217:                 props, nodes, nodes / props, mean, sigma, bs.max);
    1:     }
    1: 
10217:     JS_DumpHistogram(&bs, logfp);
    1: #endif
    1: 
    1:     ap = &rt->propertyArenaPool.first.next;
    1:     while ((a = *ap) != NULL) {
    1:         limit = (JSScopeProperty *) a->avail;
    1:         liveCount = 0;
    1:         for (sprop = (JSScopeProperty *) a->base; sprop < limit; sprop++) {
    1:             /* If the id is null, sprop is already on the freelist. */
    1:             if (sprop->id == JSVAL_NULL)
    1:                 continue;
    1: 
11377:             /*
11377:              * If the mark bit is set, sprop is alive, so clear the mark bit
11377:              * and continue the while loop.
11377:              *
11377:              * Regenerate sprop->shape if it hasn't already been refreshed
11377:              * during the mark phase, when live scopes' lastProp members are
11377:              * followed to update both scope->shape and lastProp->shape.
11377:              */
    1:             if (sprop->flags & SPROP_MARK) {
    1:                 sprop->flags &= ~SPROP_MARK;
11377:                 if (sprop->flags & SPROP_FLAG_SHAPE_REGEN) {
11377:                     sprop->flags &= ~SPROP_FLAG_SHAPE_REGEN;
11377:                 } else {
11377:                     sprop->shape = ++cx->runtime->shapeGen;
11377:                     JS_ASSERT(sprop->shape != 0);
11377:                 }
    1:                 liveCount++;
    1:                 continue;
    1:             }
    1: 
    1:             /* Ok, sprop is garbage to collect: unlink it from its parent. */
    1:             freeChunk = RemovePropertyTreeChild(rt, sprop);
    1: 
    1:             /*
    1:              * Take care to reparent all sprop's kids to their grandparent.
    1:              * InsertPropertyTreeChild can potentially fail for two reasons:
    1:              *
    1:              * 1. If parent is null, insertion into the root property hash
    1:              *    table may fail. We are forced to leave the kid out of the
    1:              *    table (as can already happen with duplicates) but ensure
    1:              *    that the kid's parent pointer is set to null.
    1:              *
    1:              * 2. If parent is non-null, allocation of a new KidsChunk can
    1:              *    fail. To prevent this from happening, we allow sprops's own
    1:              *    chunks to be reused by the grandparent, which removes the
    1:              *    need for InsertPropertyTreeChild to malloc a new KidsChunk.
    1:              *
    1:              *    If sprop does not have chunky kids, then we rely on the
    1:              *    RemovePropertyTreeChild call above (which removed sprop from
    1:              *    its parent) either leaving one free entry, or else returning
    1:              *    the now-unused chunk to us so we can reuse it.
    1:              *
    1:              * We also require the grandparent to have either no kids or else
    1:              * chunky kids. A single non-chunky kid would force a new chunk to
    1:              * be malloced in some cases (if sprop had a single non-chunky
    1:              * kid, or a multiple of MAX_KIDS_PER_CHUNK kids). Note that
    1:              * RemovePropertyTreeChild never converts a single-entry chunky
    1:              * kid back to a non-chunky kid, so we are assured of correct
    1:              * behaviour.
    1:              */
    1:             kids = sprop->kids;
    1:             if (kids) {
    1:                 sprop->kids = NULL;
    1:                 parent = sprop->parent;
    1: 
    1:                 /* Assert that grandparent has no kids or chunky kids. */
    1:                 JS_ASSERT(!parent || !parent->kids ||
    1:                           KIDS_IS_CHUNKY(parent->kids));
    1:                 if (KIDS_IS_CHUNKY(kids)) {
    1:                     chunk = KIDS_TO_CHUNK(kids);
    1:                     do {
    1:                         nextChunk = chunk->next;
    1:                         chunk->next = NULL;
    1:                         for (i = 0; i < MAX_KIDS_PER_CHUNK; i++) {
    1:                             kid = chunk->kids[i];
    1:                             if (!kid)
    1:                                 break;
    1:                             JS_ASSERT(kid->parent == sprop);
    1: 
    1:                             /*
    1:                              * Clear a space in the kids array for possible
    1:                              * re-use by InsertPropertyTreeChild.
    1:                              */
    1:                             chunk->kids[i] = NULL;
    1:                             if (!InsertPropertyTreeChild(rt, parent, kid,
    1:                                                          chunk)) {
    1:                                 /*
    1:                                  * This can happen only if we failed to add an
    1:                                  * entry to the root property hash table.
    1:                                  */
    1:                                 JS_ASSERT(!parent);
    1:                                 kid->parent = NULL;
    1:                             }
    1:                         }
    1:                         if (!chunk->kids[0]) {
    1:                             /* The chunk wasn't reused, so we must free it. */
    1:                             DestroyPropTreeKidsChunk(rt, chunk);
    1:                         }
    1:                     } while ((chunk = nextChunk) != NULL);
    1:                 } else {
    1:                     kid = kids;
    1:                     if (!InsertPropertyTreeChild(rt, parent, kid, freeChunk)) {
    1:                         /*
    1:                          * This can happen only if we failed to add an entry
    1:                          * to the root property hash table.
    1:                          */
    1:                         JS_ASSERT(!parent);
    1:                         kid->parent = NULL;
    1:                     }
    1:                 }
    1:             }
    1: 
    1:             if (freeChunk && !freeChunk->kids[0]) {
    1:                 /* The chunk wasn't reused, so we must free it. */
    1:                 DestroyPropTreeKidsChunk(rt, freeChunk);
    1:             }
    1: 
    1:             /* Clear id so we know (above) that sprop is on the freelist. */
    1:             sprop->id = JSVAL_NULL;
    1:             FREENODE_INSERT(rt->propertyFreeList, sprop);
    1:             JS_RUNTIME_UNMETER(rt, livePropTreeNodes);
    1:         }
    1: 
    1:         /* If a contains no live properties, return it to the malloc heap. */
    1:         if (liveCount == 0) {
    1:             for (sprop = (JSScopeProperty *) a->base; sprop < limit; sprop++)
    1:                 FREENODE_REMOVE(sprop);
    1:             JS_ARENA_DESTROY(&rt->propertyArenaPool, a, ap);
    1:         } else {
10217: #ifdef JS_DUMP_PROPTREE_STATS
    1:             livePropCapacity += limit - (JSScopeProperty *) a->base;
    1:             totalLiveCount += liveCount;
    1: #endif
    1:             ap = &a->next;
    1:         }
    1:     }
    1: 
10217: #ifdef JS_DUMP_PROPTREE_STATS
    1:     fprintf(logfp, "arenautil %g%%\n",
10217:             (totalLiveCount && livePropCapacity)
10217:             ? (totalLiveCount * 100.0) / livePropCapacity
10217:             : 0.0);
 3230: 
 3230: #define RATE(f1, f2) (((double)js_scope_stats.f1 / js_scope_stats.f2) * 100.0)
 3230: 
 3230:     fprintf(logfp, "Scope search stats:\n"
 3230:             "  searches:       %6u\n"
 3230:             "  hits:           %6u %5.2f%% of searches\n"
 3230:             "  misses:         %6u %5.2f%%\n"
 3230:             "  hashes:         %6u %5.2f%%\n"
 3230:             "  steps:          %6u %5.2f%% %5.2f%% of hashes\n"
 3230:             "  stepHits:       %6u %5.2f%% %5.2f%%\n"
 3230:             "  stepMisses:     %6u %5.2f%% %5.2f%%\n"
 3230:             "  adds:           %6u\n"
 3230:             "  redundantAdds:  %6u\n"
 3230:             "  addFailures:    %6u\n"
 3230:             "  changeFailures: %6u\n"
 3230:             "  compresses:     %6u\n"
 3230:             "  grows:          %6u\n"
 3230:             "  removes:        %6u\n"
 3230:             "  removeFrees:    %6u\n"
 3230:             "  uselessRemoves: %6u\n"
 3230:             "  shrinks:        %6u\n",
 3230:             js_scope_stats.searches,
 3230:             js_scope_stats.hits, RATE(hits, searches),
 3230:             js_scope_stats.misses, RATE(misses, searches),
 3230:             js_scope_stats.hashes, RATE(hashes, searches),
 3230:             js_scope_stats.steps, RATE(steps, searches), RATE(steps, hashes),
 3230:             js_scope_stats.stepHits,
 3230:             RATE(stepHits, searches), RATE(stepHits, hashes),
 3230:             js_scope_stats.stepMisses,
 3230:             RATE(stepMisses, searches), RATE(stepMisses, hashes),
 3230:             js_scope_stats.adds,
 3230:             js_scope_stats.redundantAdds,
 3230:             js_scope_stats.addFailures,
 3230:             js_scope_stats.changeFailures,
 3230:             js_scope_stats.compresses,
 3230:             js_scope_stats.grows,
 3230:             js_scope_stats.removes,
 3230:             js_scope_stats.removeFrees,
 3230:             js_scope_stats.uselessRemoves,
 3230:             js_scope_stats.shrinks);
 3230: 
 3230: #undef RATE
 3230: 
    1:     fflush(logfp);
    1: #endif
    1: 
    1: #ifdef DUMP_PROPERTY_TREE
    1:     {
    1:         FILE *dumpfp = fopen("/tmp/proptree.dump", "w");
    1:         if (dumpfp) {
    1:             JSPropertyTreeEntry *pte, *end;
    1: 
    1:             pte = (JSPropertyTreeEntry *) rt->propertyTreeHash.entryStore;
    1:             end = pte + JS_DHASH_TABLE_SIZE(&rt->propertyTreeHash);
    1:             while (pte < end) {
    1:                 if (pte->child)
    1:                     DumpSubtree(cx, pte->child, 0, dumpfp);
    1:                 pte++;
    1:             }
    1:             fclose(dumpfp);
    1:         }
    1:     }
    1: #endif
    1: }
    1: 
    1: JSBool
    1: js_InitPropertyTree(JSRuntime *rt)
    1: {
    1:     if (!JS_DHashTableInit(&rt->propertyTreeHash, &PropertyTreeHashOps, NULL,
    1:                            sizeof(JSPropertyTreeEntry), JS_DHASH_MIN_SIZE)) {
    1:         rt->propertyTreeHash.ops = NULL;
    1:         return JS_FALSE;
    1:     }
  437:     JS_INIT_ARENA_POOL(&rt->propertyArenaPool, "properties",
 5344:                        256 * sizeof(JSScopeProperty), sizeof(void *), NULL);
    1:     return JS_TRUE;
    1: }
    1: 
    1: void
    1: js_FinishPropertyTree(JSRuntime *rt)
    1: {
    1:     if (rt->propertyTreeHash.ops) {
    1:         JS_DHashTableFinish(&rt->propertyTreeHash);
    1:         rt->propertyTreeHash.ops = NULL;
    1:     }
    1:     JS_FinishArenaPool(&rt->propertyArenaPool);
    1: }
