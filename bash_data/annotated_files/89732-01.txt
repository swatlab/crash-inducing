20193: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */ 
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998-1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Doug Turner <dougt@netscape.com>
    1:  *   Dean Tessman <dean_tessman@hotmail.com>
    1:  *   Brodie Thiesfield <brofield@jellycan.com>
    1:  *   Jungshik Shin <jshin@i18nl10n.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
    1: 
    1: #include "nsCOMPtr.h"
84786: #include "nsAutoPtr.h"
    1: #include "nsMemory.h"
    1: 
    1: #include "nsLocalFile.h"
    1: #include "nsIDirectoryEnumerator.h"
    1: #include "nsNativeCharsetUtils.h"
    1: 
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsIComponentManager.h"
    1: #include "prtypes.h"
    1: #include "prio.h"
    1: #include "private/pprio.h"  // To get PR_ImportFile
    1: #include "prprf.h"
    1: #include "prmem.h"
    1: #include "nsHashKeys.h"
    1: 
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: 
    1: #include <direct.h>
    1: #include <windows.h>
89529: #include <shlwapi.h>
16673: #include <aclapi.h>
    1: 
    1: #include "shellapi.h"
    1: #include "shlguid.h"
    1: 
    1: #include  <io.h>
    1: #include  <stdio.h>
    1: #include  <stdlib.h>
    1: #include  <mbstring.h>
    1: 
    1: #include "nsXPIDLString.h"
    1: #include "prproces.h"
    1: 
64576: #include "mozilla/Mutex.h"
    1: #include "SpecialSystemDirectory.h"
    1: 
    1: #include "nsTraceRefcntImpl.h"
    1: 
64576: using namespace mozilla;
64576: 
    1: #define CHECK_mWorkingPath()                    \
    1:     PR_BEGIN_MACRO                              \
    1:         if (mWorkingPath.IsEmpty())             \
    1:             return NS_ERROR_NOT_INITIALIZED;    \
    1:     PR_END_MACRO
    1: 
63998: // CopyFileEx only supports unbuffered I/O in Windows Vista and above
63998: #define COPY_FILE_NO_BUFFERING 0x00001000
63998: 
    1: // _mbsstr isn't declared in w32api headers but it's there in the libs
    1: #ifdef __MINGW32__
    1: extern "C" {
    1: unsigned char *_mbsstr( const unsigned char *str,
    1:                         const unsigned char *substr );
    1: }
    1: #endif
    1: 
27558: #ifndef FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
27558: #define FILE_ATTRIBUTE_NOT_CONTENT_INDEXED  0x00002000
27558: #endif
27558: 
89529: #ifndef DRIVE_REMOTE
89529: #define DRIVE_REMOTE 4
89529: #endif
89529: 
89731: ILCreateFromPathWPtr nsLocalFile::sILCreateFromPathW = NULL;
89731: SHOpenFolderAndSelectItemsPtr nsLocalFile::sSHOpenFolderAndSelectItems = NULL;
89731: 
    1: class nsDriveEnumerator : public nsISimpleEnumerator
    1: {
    1: public:
    1:     nsDriveEnumerator();
    1:     virtual ~nsDriveEnumerator();
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSISIMPLEENUMERATOR
    1:     nsresult Init();
    1: private:
25555:     /* mDrives stores the null-separated drive names.
    1:      * Init sets them.
25555:      * HasMoreElements checks mStartOfCurrentDrive.
25555:      * GetNext advances mStartOfCurrentDrive.
    1:      */
22235:     nsString mDrives;
25555:     nsAString::const_iterator mStartOfCurrentDrive;
25555:     nsAString::const_iterator mEndOfDrivesString;
    1: };
    1: 
    1: //----------------------------------------------------------------------------
    1: // short cut resolver
    1: //----------------------------------------------------------------------------
    1: class ShortcutResolver
    1: {
    1: public:
    1:     ShortcutResolver();
    1:     // nonvirtual since we're not subclassed
    1:     ~ShortcutResolver();
    1: 
    1:     nsresult Init();
    1:     nsresult Resolve(const WCHAR* in, WCHAR* out);
    1: 
    1: private:
64576:     Mutex                  mLock;
84786:     nsRefPtr<IPersistFile> mPersistFile;
84786:     nsRefPtr<IShellLinkW>  mShellLink;
    1: };
    1: 
84786: ShortcutResolver::ShortcutResolver() :
84786:     mLock("ShortcutResolver.mLock")
    1: {
84786:     CoInitialize(NULL);
    1: }
    1: 
    1: ShortcutResolver::~ShortcutResolver()
    1: {
    1:     CoUninitialize();
    1: }
    1: 
    1: nsresult
    1: ShortcutResolver::Init()
    1: {
84786:     // Get a pointer to the IPersistFile interface.
84786:     if (FAILED(CoCreateInstance(CLSID_ShellLink,
    1:                                 NULL,
    1:                                 CLSCTX_INPROC_SERVER,
    1:                                 IID_IShellLinkW,
84786:                                 getter_AddRefs(mShellLink))) ||
84786:         FAILED(mShellLink->QueryInterface(IID_IPersistFile,
84786:                                           getter_AddRefs(mPersistFile)))) {
84786:         mShellLink = nsnull;
84786:         return NS_ERROR_FAILURE;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: // |out| must be an allocated buffer of size MAX_PATH
    1: nsresult
    1: ShortcutResolver::Resolve(const WCHAR* in, WCHAR* out)
    1: {
84786:     if (!mShellLink)
84786:         return NS_ERROR_FAILURE;
84786: 
64576:     MutexAutoLock lock(mLock);
    1: 
84786:     if (FAILED(mPersistFile->Load(in, STGM_READ)) ||
84786:         FAILED(mShellLink->Resolve(nsnull, SLR_NO_UI)) ||
84786:         FAILED(mShellLink->GetPath(out, MAX_PATH, NULL, SLGP_UNCPRIORITY)))
    1:         return NS_ERROR_FAILURE;
    1:     return NS_OK;
    1: }
    1: 
    1: static ShortcutResolver * gResolver = nsnull;
    1: 
    1: static nsresult NS_CreateShortcutResolver()
    1: {
    1:     gResolver = new ShortcutResolver();
    1:     if (!gResolver)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     return gResolver->Init();
    1: }
    1: 
    1: static void NS_DestroyShortcutResolver()
    1: {
    1:     delete gResolver;
    1:     gResolver = nsnull;
    1: }
20187: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: // static helper functions
    1: //-----------------------------------------------------------------------------
    1: 
    1: // certainly not all the error that can be
    1: // encountered, but many of them common ones
    1: static nsresult ConvertWinError(DWORD winErr)
    1: {
    1:     nsresult rv;
    1: 
    1:     switch (winErr)
    1:     {
    1:         case ERROR_FILE_NOT_FOUND:
    1:         case ERROR_PATH_NOT_FOUND:
    1:         case ERROR_INVALID_DRIVE:
    1:             rv = NS_ERROR_FILE_NOT_FOUND;
    1:             break;
    1:         case ERROR_ACCESS_DENIED:
    1:         case ERROR_NOT_SAME_DEVICE:
    1:             rv = NS_ERROR_FILE_ACCESS_DENIED;
    1:             break;
78583:         case ERROR_SHARING_VIOLATION: // CreateFile without sharing flags
78583:         case ERROR_LOCK_VIOLATION: // LockFile, LockFileEx
78583:             rv = NS_ERROR_FILE_IS_LOCKED;
78583:             break;
    1:         case ERROR_NOT_ENOUGH_MEMORY:
    1:         case ERROR_INVALID_BLOCK:
    1:         case ERROR_INVALID_HANDLE:
    1:         case ERROR_ARENA_TRASHED:
    1:             rv = NS_ERROR_OUT_OF_MEMORY;
    1:             break;
    1:         case ERROR_CURRENT_DIRECTORY:
    1:             rv = NS_ERROR_FILE_DIR_NOT_EMPTY;
    1:             break;
    1:         case ERROR_WRITE_PROTECT:
    1:             rv = NS_ERROR_FILE_READ_ONLY;
    1:             break;
    1:         case ERROR_HANDLE_DISK_FULL:
    1:             rv = NS_ERROR_FILE_TOO_BIG;
    1:             break;
    1:         case ERROR_FILE_EXISTS:
    1:         case ERROR_ALREADY_EXISTS:
    1:         case ERROR_CANNOT_MAKE:
    1:             rv = NS_ERROR_FILE_ALREADY_EXISTS;
    1:             break;
    1:         case ERROR_FILENAME_EXCED_RANGE:
    1:             rv = NS_ERROR_FILE_NAME_TOO_LONG;
    1:             break;
    1:         case 0:
    1:             rv = NS_OK;
    1:             break;
    1:         default:
    1:             rv = NS_ERROR_FAILURE;
    1:             break;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: // as suggested in the MSDN documentation on SetFilePointer
    1: static __int64 
    1: MyFileSeek64(HANDLE aHandle, __int64 aDistance, DWORD aMoveMethod)
    1: {
    1:     LARGE_INTEGER li;
    1: 
    1:     li.QuadPart = aDistance;
    1:     li.LowPart = SetFilePointer(aHandle, li.LowPart, &li.HighPart, aMoveMethod);
    1:     if (li.LowPart == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR)
    1:     {
    1:         li.QuadPart = -1;
    1:     }
    1: 
    1:     return li.QuadPart;
    1: }
    1: 
79445: static bool
    1: IsShortcutPath(const nsAString &path)
    1: {
    1:     // Under Windows, the shortcuts are just files with a ".lnk" extension. 
    1:     // Note also that we don't resolve links in the middle of paths.
    1:     // i.e. "c:\foo.lnk\bar.txt" is invalid.
    1:     NS_ABORT_IF_FALSE(!path.IsEmpty(), "don't pass an empty string");
    1:     PRInt32 len = path.Length();
    1:     return (StringTail(path, 4).LowerCaseEqualsASCII(".lnk"));
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // We need the following three definitions to make |OpenFile| convert a file 
    1: // handle to an NSPR file descriptor correctly when |O_APPEND| flag is
    1: // specified. It is defined in a private header of NSPR (primpl.h) we can't
    1: // include. As a temporary workaround until we decide how to extend
    1: // |PR_ImportFile|, we define it here. Currently, |_PR_HAVE_PEEK_BUFFER|
    1: // and |PR_STRICT_ADDR_LEN| are not defined for the 'w95'-dependent portion
    1: // of NSPR so that fields of |PRFilePrivate| #ifdef'd by them are not copied.
    1: // Similarly, |_MDFileDesc| is taken from nsprpub/pr/include/md/_win95.h.
    1: // In an unlikely case we switch to 'NT'-dependent NSPR AND this temporary 
    1: // workaround last beyond the switch, |PRFilePrivate| and |_MDFileDesc| 
    1: // need to be changed to match the definitions for WinNT.
    1: //-----------------------------------------------------------------------------
    1: typedef enum {
    1:     _PR_TRI_TRUE = 1,
    1:     _PR_TRI_FALSE = 0,
    1:     _PR_TRI_UNKNOWN = -1
    1: } _PRTriStateBool;
    1: 
    1: struct _MDFileDesc {
    1:     PROsfd osfd;
    1: };
    1: 
    1: struct PRFilePrivate {
    1:     PRInt32 state;
79445:     bool nonblocking;
    1:     _PRTriStateBool inheritable;
    1:     PRFileDesc *next;
    1:     PRIntn lockCount;   /*   0: not locked
    1:                          *  -1: a native lockfile call is in progress
    1:                          * > 0: # times the file is locked */
79445:     bool    appendMode; 
    1:     _MDFileDesc md;
    1: };
    1: 
    1: //-----------------------------------------------------------------------------
    1: // Six static methods defined below (OpenFile,  FileTimeToPRTime, GetFileInfo,
    1: // OpenDir, CloseDir, ReadDir) should go away once the corresponding 
    1: // UTF-16 APIs are implemented on all the supported platforms (or at least 
    1: // Windows 9x/ME) in NSPR. Currently, they're only implemented on 
    1: // Windows NT4 or later. (bug 330665)
    1: //-----------------------------------------------------------------------------
    1: 
    1: // copied from nsprpub/pr/src/{io/prfile.c | md/windows/w95io.c} : 
    1: // PR_Open and _PR_MD_OPEN
    1: static nsresult
    1: OpenFile(const nsAFlatString &name, PRIntn osflags, PRIntn mode,
    1:          PRFileDesc **fd)
    1: {
    1:     // XXX : 'mode' is not translated !!!
    1:     PRInt32 access = 0;
    1:     PRInt32 flags = 0;
    1:     PRInt32 flag6 = 0;
    1: 
    1:     if (osflags & PR_SYNC) flag6 = FILE_FLAG_WRITE_THROUGH;
    1:  
    1:     if (osflags & PR_RDONLY || osflags & PR_RDWR)
    1:         access |= GENERIC_READ;
    1:     if (osflags & PR_WRONLY || osflags & PR_RDWR)
    1:         access |= GENERIC_WRITE;
    1: 
    1:     if ( osflags & PR_CREATE_FILE && osflags & PR_EXCL )
    1:         flags = CREATE_NEW;
    1:     else if (osflags & PR_CREATE_FILE) {
    1:         if (osflags & PR_TRUNCATE)
    1:             flags = CREATE_ALWAYS;
    1:         else
    1:             flags = OPEN_ALWAYS;
    1:     } else {
    1:         if (osflags & PR_TRUNCATE)
    1:             flags = TRUNCATE_EXISTING;
    1:         else
    1:             flags = OPEN_EXISTING;
    1:     }
    1: 
26480:     if (osflags & nsILocalFile::DELETE_ON_CLOSE) {
26480:       flag6 |= FILE_FLAG_DELETE_ON_CLOSE;
26480:     }
26480: 
79630:     if (osflags && nsILocalFile::OS_READAHEAD) {
79630:       flag6 |= FILE_FLAG_SEQUENTIAL_SCAN;
79630:     }
79630: 
    1:     HANDLE file = ::CreateFileW(name.get(), access,
    1:                                 FILE_SHARE_READ|FILE_SHARE_WRITE,
    1:                                 NULL, flags, flag6, NULL);
    1: 
    1:     if (file == INVALID_HANDLE_VALUE) { 
    1:         *fd = nsnull;
    1:         return ConvertWinError(GetLastError());
    1:     }
    1: 
    1:     *fd = PR_ImportFile((PROsfd) file); 
    1:     if (*fd) {
    1:         // On Windows, _PR_HAVE_O_APPEND is not defined so that we have to
    1:         // add it manually. (see |PR_Open| in nsprpub/pr/src/io/prfile.c)
80486:         (*fd)->secret->appendMode = (PR_APPEND & osflags) ? true : false;
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsresult rv = NS_ErrorAccordingToNSPR();
    1: 
    1:     CloseHandle(file);
    1: 
    1:     return rv;
    1: }
    1: 
    1: // copied from nsprpub/pr/src/{io/prfile.c | md/windows/w95io.c} :
    1: // PR_FileTimeToPRTime and _PR_FileTimeToPRTime
    1: static
    1: void FileTimeToPRTime(const FILETIME *filetime, PRTime *prtm)
    1: {
    1: #ifdef __GNUC__
    1:     const PRTime _pr_filetime_offset = 116444736000000000LL;
    1: #else
    1:     const PRTime _pr_filetime_offset = 116444736000000000i64;
    1: #endif
    1: 
    1:     PR_ASSERT(sizeof(FILETIME) == sizeof(PRTime));
    1:     ::CopyMemory(prtm, filetime, sizeof(PRTime));
    1: #ifdef __GNUC__
    1:     *prtm = (*prtm - _pr_filetime_offset) / 10LL;
    1: #else
    1:     *prtm = (*prtm - _pr_filetime_offset) / 10i64;
    1: #endif
    1: }
    1: 
    1: // copied from nsprpub/pr/src/{io/prfile.c | md/windows/w95io.c} with some
    1: // changes : PR_GetFileInfo64, _PR_MD_GETFILEINFO64
    1: static nsresult
    1: GetFileInfo(const nsAFlatString &name, PRFileInfo64 *info)
    1: {
    1:     WIN32_FILE_ATTRIBUTE_DATA fileData;
    1: 
    1:     if (name.IsEmpty() || name.FindCharInSet(L"?*") != kNotFound)
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     if (!::GetFileAttributesExW(name.get(), GetFileExInfoStandard, &fileData))
    1:         return ConvertWinError(GetLastError());
    1: 
    1:     if (fileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
    1:         info->type = PR_FILE_DIRECTORY;
    1:     } else {
    1:         info->type = PR_FILE_FILE;
    1:     }
    1: 
    1:     info->size = fileData.nFileSizeHigh;
    1:     info->size = (info->size << 32) + fileData.nFileSizeLow;
    1: 
    1:     FileTimeToPRTime(&fileData.ftLastWriteTime, &info->modifyTime);
    1: 
    1:     if (0 == fileData.ftCreationTime.dwLowDateTime &&
    1:             0 == fileData.ftCreationTime.dwHighDateTime) {
    1:         info->creationTime = info->modifyTime;
    1:     } else {
    1:         FileTimeToPRTime(&fileData.ftCreationTime, &info->creationTime);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: struct nsDir
    1: {
    1:     HANDLE   handle; 
    1:     WIN32_FIND_DATAW data;
79445:     bool     firstEntry;
    1: };
    1: 
    1: static nsresult
    1: OpenDir(const nsAFlatString &name, nsDir * *dir)
    1: {
    1:     NS_ENSURE_ARG_POINTER(dir);
    1: 
    1:     *dir = nsnull;
    1:     if (name.Length() + 3 >= MAX_PATH)
    1:         return NS_ERROR_FILE_NAME_TOO_LONG;
    1: 
    1:     nsDir *d  = PR_NEW(nsDir);
    1:     if (!d)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     nsAutoString filename(name);
    1: 
    1:      //If 'name' ends in a slash or backslash, do not append
    1:      //another backslash.
    1:     if (filename.Last() == L'/' || filename.Last() == L'\\')
    1:         filename.AppendASCII("*");
    1:     else 
    1:         filename.AppendASCII("\\*");
    1: 
    1:     filename.ReplaceChar(L'/', L'\\');
    1: 
    1:     d->handle = ::FindFirstFileW(filename.get(), &(d->data) );
    1: 
    1:     if ( d->handle == INVALID_HANDLE_VALUE )
    1:     {
    1:         PR_Free(d);
    1:         return ConvertWinError(GetLastError());
    1:     }
80486:     d->firstEntry = true;
    1: 
    1:     *dir = d;
    1:     return NS_OK;
    1: }
    1: 
    1: static nsresult
    1: ReadDir(nsDir *dir, PRDirFlags flags, nsString& name)
    1: {
    1:     name.Truncate();
    1:     NS_ENSURE_ARG(dir);
    1: 
    1:     while (1) {
    1:         BOOL rv;
    1:         if (dir->firstEntry)
    1:         {
80486:             dir->firstEntry = false;
    1:             rv = 1;
    1:         } else
    1:             rv = ::FindNextFileW(dir->handle, &(dir->data));
    1: 
    1:         if (rv == 0)
    1:             break;
    1: 
    1:         const PRUnichar *fileName;
    1:         nsString tmp;
    1:         fileName = (dir)->data.cFileName;
    1: 
    1:         if ((flags & PR_SKIP_DOT) &&
    1:             (fileName[0] == L'.') && (fileName[1] == L'\0'))
    1:             continue;
    1:         if ((flags & PR_SKIP_DOT_DOT) &&
    1:             (fileName[0] == L'.') && (fileName[1] == L'.') &&
    1:             (fileName[2] == L'\0'))
    1:             continue;
    1: 
    1:         DWORD attrib =  dir->data.dwFileAttributes;
    1:         if ((flags & PR_SKIP_HIDDEN) && (attrib & FILE_ATTRIBUTE_HIDDEN))
    1:             continue;
    1: 
    1:         if (fileName == tmp.get())
    1:             name = tmp;
    1:         else 
    1:             name = fileName;
    1:         return NS_OK;
    1:     }
    1: 
    1:     DWORD err = GetLastError();
    1:     return err == ERROR_NO_MORE_FILES ? NS_OK : ConvertWinError(err);
    1: }
    1: 
    1: static nsresult
84881: CloseDir(nsDir *&d)
    1: {
    1:     NS_ENSURE_ARG(d);
    1: 
    1:     BOOL isOk = FindClose(d->handle);
84881:     // PR_DELETE also nulls out the passed in pointer.
    1:     PR_DELETE(d);
    1:     return isOk ? NS_OK : ConvertWinError(GetLastError());
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsDirEnumerator
    1: //-----------------------------------------------------------------------------
    1: 
    1: class nsDirEnumerator : public nsISimpleEnumerator,
    1:                         public nsIDirectoryEnumerator
    1: {
    1:     public:
    1: 
    1:         NS_DECL_ISUPPORTS
    1: 
    1:         nsDirEnumerator() : mDir(nsnull)
    1:         {
    1:         }
    1: 
    1:         nsresult Init(nsILocalFile* parent)
    1:         {
    1:             nsAutoString filepath;
    1:             parent->GetTarget(filepath);
    1: 
    1:             if (filepath.IsEmpty())
    1:             {
    1:                 parent->GetPath(filepath);
    1:             }
    1: 
    1:             if (filepath.IsEmpty())
    1:             {
    1:                 return NS_ERROR_UNEXPECTED;
    1:             }
    1: 
    1:             nsresult rv = OpenDir(filepath, &mDir);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1: 
    1:             mParent = parent;
    1:             return NS_OK;
    1:         }
    1: 
79445:         NS_IMETHOD HasMoreElements(bool *result)
    1:         {
    1:             nsresult rv;
    1:             if (mNext == nsnull && mDir)
    1:             {
    1:                 nsString name;
    1:                 rv = ReadDir(mDir, PR_SKIP_BOTH, name);
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1:                 if (name.IsEmpty()) 
    1:                 {
    1:                     // end of dir entries
    1:                     if (NS_FAILED(CloseDir(mDir)))
    1:                         return NS_ERROR_FAILURE;
    1: 
80486:                     *result = false;
    1:                     return NS_OK;
    1:                 }
    1: 
    1:                 nsCOMPtr<nsIFile> file;
    1:                 rv = mParent->Clone(getter_AddRefs(file));
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1: 
    1:                 rv = file->Append(name);
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1: 
    1:                 mNext = do_QueryInterface(file);
    1:             }
    1:             *result = mNext != nsnull;
    1:             if (!*result) 
    1:                 Close();
    1:             return NS_OK;
    1:         }
    1: 
    1:         NS_IMETHOD GetNext(nsISupports **result)
    1:         {
    1:             nsresult rv;
79445:             bool hasMore;
    1:             rv = HasMoreElements(&hasMore);
    1:             if (NS_FAILED(rv)) return rv;
    1: 
    1:             *result = mNext;        // might return nsnull
    1:             NS_IF_ADDREF(*result);
    1: 
    1:             mNext = nsnull;
    1:             return NS_OK;
    1:         }
    1: 
    1:         NS_IMETHOD GetNextFile(nsIFile **result)
    1:         {
    1:             *result = nsnull;
79445:             bool hasMore = false;
    1:             nsresult rv = HasMoreElements(&hasMore);
    1:             if (NS_FAILED(rv) || !hasMore)
    1:                 return rv;
    1:             *result = mNext;
    1:             NS_IF_ADDREF(*result);
    1:             mNext = nsnull;
    1:             return NS_OK;
    1:         }
    1: 
    1:         NS_IMETHOD Close()
    1:         {
    1:             if (mDir)
    1:             {
    1:                 nsresult rv = CloseDir(mDir);
    1:                 NS_ASSERTION(NS_SUCCEEDED(rv), "close failed");
    1:                 if (NS_FAILED(rv))
    1:                     return NS_ERROR_FAILURE;
    1:             }
    1:             return NS_OK;
    1:         }
    1: 
    1:         // dtor can be non-virtual since there are no subclasses, but must be
    1:         // public to use the class on the stack.
    1:         ~nsDirEnumerator()
    1:         {
    1:             Close();
    1:         }
    1: 
    1:     protected:
    1:         nsDir*                  mDir;
    1:         nsCOMPtr<nsILocalFile>  mParent;
    1:         nsCOMPtr<nsILocalFile>  mNext;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS2(nsDirEnumerator, nsISimpleEnumerator, nsIDirectoryEnumerator)
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile <public>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsLocalFile::nsLocalFile()
80486:   : mDirty(true)
80486:   , mFollowSymlinks(false)
    1: {
    1: }
    1: 
46997: nsresult
    1: nsLocalFile::nsLocalFileConstructor(nsISupports* outer, const nsIID& aIID, void* *aInstancePtr)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aInstancePtr);
    1:     NS_ENSURE_NO_AGGREGATION(outer);
    1: 
    1:     nsLocalFile* inst = new nsLocalFile();
    1:     if (inst == NULL)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     nsresult rv = inst->QueryInterface(aIID, aInstancePtr);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         delete inst;
    1:         return rv;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile::nsISupports
    1: //-----------------------------------------------------------------------------
    1: 
11159: NS_IMPL_THREADSAFE_ISUPPORTS4(nsLocalFile,
    1:                               nsILocalFile,
    1:                               nsIFile,
    1:                               nsILocalFileWin,
    1:                               nsIHashable)
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile <private>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsLocalFile::nsLocalFile(const nsLocalFile& other)
80486:   : mDirty(true)
20214:   , mFollowSymlinks(other.mFollowSymlinks)
    1:   , mWorkingPath(other.mWorkingPath)
    1: {
    1: }
    1: 
    1: // Resolve the shortcut file from mWorkingPath and write the path 
    1: // it points to into mResolvedPath.
    1: nsresult
    1: nsLocalFile::ResolveShortcut()
    1: {
    1:     // we can't do anything without the resolver
    1:     if (!gResolver)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     mResolvedPath.SetLength(MAX_PATH);
    1:     if (mResolvedPath.Length() != MAX_PATH)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     PRUnichar *resolvedPath = mResolvedPath.BeginWriting();
    1: 
    1:     // resolve this shortcut
    1:     nsresult rv = gResolver->Resolve(mWorkingPath.get(), resolvedPath);
    1: 
    1:     size_t len = NS_FAILED(rv) ? 0 : wcslen(resolvedPath);
    1:     mResolvedPath.SetLength(len);
    1: 
    1:     return rv;
    1: }
    1: 
    1: // Resolve any shortcuts and stat the resolved path. After a successful return
    1: // the path is guaranteed valid and the members of mFileInfo64 can be used.
    1: nsresult
    1: nsLocalFile::ResolveAndStat()
    1: {
20214:     // if we aren't dirty then we are already done
20214:     if (!mDirty)
20214:         return NS_OK;
20214: 
    1:     // we can't resolve/stat anything that isn't a valid NSPR addressable path
    1:     if (mWorkingPath.IsEmpty())
    1:         return NS_ERROR_FILE_INVALID_PATH;
    1: 
    1:     // this is usually correct
    1:     mResolvedPath.Assign(mWorkingPath);
    1: 
    1:     // slutty hack designed to work around bug 134796 until it is fixed
    1:     nsAutoString nsprPath(mWorkingPath.get());
    1:     if (mWorkingPath.Length() == 2 && mWorkingPath.CharAt(1) == L':') 
    1:         nsprPath.AppendASCII("\\");
    1: 
    1:     // first we will see if the working path exists. If it doesn't then
    1:     // there is nothing more that can be done
78583:     nsresult rv = GetFileInfo(nsprPath, &mFileInfo64);
78583:     if (NS_FAILED(rv))
78583:         return rv;
    1: 
    1:     // if this isn't a shortcut file or we aren't following symlinks then we're done 
    1:     if (!mFollowSymlinks 
    1:         || mFileInfo64.type != PR_FILE_FILE 
    1:         || !IsShortcutPath(mWorkingPath))
    1:     {
80486:         mDirty = false;
    1:         return NS_OK;
    1:     }
    1: 
    1:     // we need to resolve this shortcut to what it points to, this will
    1:     // set mResolvedPath. Even if it fails we need to have the resolved
    1:     // path equal to working path for those functions that always use
    1:     // the resolved path.
78583:     rv = ResolveShortcut();
    1:     if (NS_FAILED(rv))
    1:     {
    1:         mResolvedPath.Assign(mWorkingPath);
    1:         return rv;
    1:     }
    1: 
    1:     // get the details of the resolved path
78583:     rv = GetFileInfo(mResolvedPath, &mFileInfo64);
78583:     if (NS_FAILED(rv))
78583:         return rv;
    1: 
80486:     mDirty = false;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile::nsIFile,nsILocalFile
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Clone(nsIFile **file)
    1: {
    1:     // Just copy-construct ourselves
    1:     *file = new nsLocalFile(*this);
    1:     if (!*file)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ADDREF(*file);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::InitWithFile(nsILocalFile *aFile)
    1: {
    1:     NS_ENSURE_ARG(aFile);
    1:     
    1:     nsAutoString path;
    1:     aFile->GetPath(path);
    1:     if (path.IsEmpty())
    1:         return NS_ERROR_INVALID_ARG;
    1:     return InitWithPath(path); 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::InitWithPath(const nsAString &filePath)
    1: {
20214:     MakeDirty();
20214: 
    1:     nsAString::const_iterator begin, end;
    1:     filePath.BeginReading(begin);
    1:     filePath.EndReading(end);
    1: 
    1:     // input string must not be empty
    1:     if (begin == end)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     PRUnichar firstChar = *begin;
    1:     PRUnichar secondChar = *(++begin);
    1: 
    1:     // just do a sanity check.  if it has any forward slashes, it is not a Native path
    1:     // on windows.  Also, it must have a colon at after the first char.
25735:     if (FindCharInReadable(L'/', begin, end))
25735:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
25735: 
25735:     if (secondChar != L':' && (secondChar != L'\\' || firstChar != L'\\'))
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
25735: 
89732:     if (secondChar == L':') {
89732:         // Make sure we have a valid drive, later code assumes the drive letter
89732:         // is a single char a-z or A-Z.
89732:         if (PathGetDriveNumberW(filePath.Data()) == -1) {
89732:             return NS_ERROR_FILE_UNRECOGNIZED_PATH;
89732:         }
89732:     }
89732: 
25735:     mWorkingPath = filePath;
    1:     // kill any trailing '\'
25735:     if (mWorkingPath.Last() == L'\\')
25735:         mWorkingPath.Truncate(mWorkingPath.Length() - 1);
25735: 
    1:     return NS_OK;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::OpenNSPRFileDesc(PRInt32 flags, PRInt32 mode, PRFileDesc **_retval)
    1: {
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv) && rv != NS_ERROR_FILE_NOT_FOUND)
    1:         return rv;
    1: 
    1:     return OpenFile(mResolvedPath, flags, mode, _retval);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::OpenANSIFileDesc(const char *mode, FILE * *_retval)
    1: {
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv) && rv != NS_ERROR_FILE_NOT_FOUND)
    1:         return rv;
    1: 
    1:     *_retval = _wfopen(mResolvedPath.get(), NS_ConvertASCIItoUTF16(mode).get());
    1:     if (*_retval)
    1:         return NS_OK;
    1: 
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Create(PRUint32 type, PRUint32 attributes)
    1: {
    1:     if (type != NORMAL_FILE_TYPE && type != DIRECTORY_TYPE)
    1:         return NS_ERROR_FILE_UNKNOWN_TYPE;
    1: 
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv) && rv != NS_ERROR_FILE_NOT_FOUND)
    1:         return rv;
    1: 
    1:     // create directories to target
    1:     //
    1:     // A given local file can be either one of these forms:
    1:     //
    1:     //   - normal:    X:\some\path\on\this\drive
    1:     //                       ^--- start here
    1:     //
    1:     //   - UNC path:  \\machine\volume\some\path\on\this\drive
    1:     //                                     ^--- start here
    1:     //
    1:     // Skip the first 'X:\' for the first form, and skip the first full
    1:     // '\\machine\volume\' segment for the second form.
    1: 
    1:     PRUnichar* path = mResolvedPath.BeginWriting();
    1: 
    1:     if (path[0] == L'\\' && path[1] == L'\\')
    1:     {
    1:         // dealing with a UNC path here; skip past '\\machine\'
    1:         path = wcschr(path + 2, L'\\');
    1:         if (!path)
    1:             return NS_ERROR_FILE_INVALID_PATH;
    1:         ++path;
    1:     }
    1: 
    1:     // search for first slash after the drive (or volume) name
    1:     PRUnichar* slash = wcschr(path, L'\\');
    1: 
78634:     nsresult directoryCreateError = NS_OK;
    1:     if (slash)
    1:     {
    1:         // skip the first '\\'
    1:         ++slash;
    1:         slash = wcschr(slash, L'\\');
    1: 
    1:         while (slash)
    1:         {
    1:             *slash = L'\0';
    1: 
    1:             if (!::CreateDirectoryW(mResolvedPath.get(), NULL)) {
    1:                 rv = ConvertWinError(GetLastError());
78634:                 if (NS_ERROR_FILE_NOT_FOUND == rv &&
78634:                     NS_ERROR_FILE_ACCESS_DENIED == directoryCreateError) {
78634:                     // If a previous CreateDirectory failed due to access, return that.
78634:                     return NS_ERROR_FILE_ACCESS_DENIED;
78634:                 }
    1:                 // perhaps the base path already exists, or perhaps we don't have
    1:                 // permissions to create the directory.  NOTE: access denied could
    1:                 // occur on a parent directory even though it exists.
78634:                 else if (NS_ERROR_FILE_ALREADY_EXISTS != rv &&
78634:                          NS_ERROR_FILE_ACCESS_DENIED != rv) {
    1:                     return rv;
    1:                 }
78634: 
78634:                 directoryCreateError = rv;
78634:             }
    1:             *slash = L'\\';
    1:             ++slash;
    1:             slash = wcschr(slash, L'\\');
    1:         }
    1:     }
    1: 
    1:     if (type == NORMAL_FILE_TYPE)
    1:     {
    1:         PRFileDesc* file;
 7847:         rv = OpenFile(mResolvedPath,
    1:                       PR_RDONLY | PR_CREATE_FILE | PR_APPEND | PR_EXCL, attributes,
    1:                       &file);
 7847:         if (file)
    1:             PR_Close(file);
24322: 
24322:         if (rv == NS_ERROR_FILE_ACCESS_DENIED)
24322:         {
24322:             // need to return already-exists for directories (bug 452217)
79445:             bool isdir;
24322:             if (NS_SUCCEEDED(IsDirectory(&isdir)) && isdir)
24322:                 rv = NS_ERROR_FILE_ALREADY_EXISTS;
78634:         } else if (NS_ERROR_FILE_NOT_FOUND == rv && 
78634:                    NS_ERROR_FILE_ACCESS_DENIED == directoryCreateError) {
78634:             // If a previous CreateDirectory failed due to access, return that.
78634:             return NS_ERROR_FILE_ACCESS_DENIED;
24322:         }
 7847:         return rv;
    1:     }
    1: 
    1:     if (type == DIRECTORY_TYPE)
    1:     {
78634:         if (!::CreateDirectoryW(mResolvedPath.get(), NULL)) {
78634:           rv = ConvertWinError(GetLastError());
78634:           if (NS_ERROR_FILE_NOT_FOUND == rv && 
78634:               NS_ERROR_FILE_ACCESS_DENIED == directoryCreateError) {
78634:               // If a previous CreateDirectory failed due to access, return that.
78634:               return NS_ERROR_FILE_ACCESS_DENIED;
78634:           } else {
78634:               return rv;
78634:           }
78634:         }
    1:         else
    1:             return NS_OK;
    1:     }
    1: 
    1:     return NS_ERROR_FILE_UNKNOWN_TYPE;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Append(const nsAString &node)
    1: {
    1:     // append this path, multiple components are not permitted
80486:     return AppendInternal(PromiseFlatString(node), false);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::AppendRelativePath(const nsAString &node)
    1: {
    1:     // append this path, multiple components are permitted
80486:     return AppendInternal(PromiseFlatString(node), true);
    1: }
    1: 
    1: 
    1: nsresult
79445: nsLocalFile::AppendInternal(const nsAFlatString &node, bool multipleComponents)
    1: {
    1:     if (node.IsEmpty())
    1:         return NS_OK;
    1: 
    1:     // check the relative path for validity
    1:     if (node.First() == L'\\'                                   // can't start with an '\'
    1:         || node.FindChar(L'/') != kNotFound                     // can't contain /
    1:         || node.EqualsASCII(".."))                              // can't be ..
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
    1:     if (multipleComponents)
    1:     {
    1:         // can't contain .. as a path component. Ensure that the valid components
    1:         // "foo..foo", "..foo", and "foo.." are not falsely detected,
    1:         // but the invalid paths "..\", "foo\..", "foo\..\foo", 
    1:         // "..\foo", etc are.
    1:         NS_NAMED_LITERAL_STRING(doubleDot, "\\.."); 
    1:         nsAString::const_iterator start, end, offset;
    1:         node.BeginReading(start);
    1:         node.EndReading(end);
    1:         offset = end; 
    1:         while (FindInReadable(doubleDot, start, offset))
    1:         {
    1:             if (offset == end || *offset == L'\\')
    1:                 return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1:             start = offset;
    1:             offset = end;
    1:         }
    1:         
    1:         // catches the remaining cases of prefixes 
    1:         if (StringBeginsWith(node, NS_LITERAL_STRING("..\\")))
    1:             return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1:     }
    1:     // single components can't contain '\'
    1:     else if (node.FindChar(L'\\') != kNotFound)
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
20214:     MakeDirty();
20214:     
    1:     mWorkingPath.Append(NS_LITERAL_STRING("\\") + node);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: #define TOUPPER(u) (((u) >= L'a' && (u) <= L'z') ? \
    1:                     (u) - (L'a' - L'A') : (u))
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Normalize()
    1: {
    1:     // XXX See bug 187957 comment 18 for possible problems with this implementation.
    1:     
    1:     if (mWorkingPath.IsEmpty())
    1:         return NS_OK;
    1: 
    1:     nsAutoString path(mWorkingPath);
    1: 
    1:     // find the index of the root backslash for the path. Everything before 
    1:     // this is considered fully normalized and cannot be ascended beyond 
    1:     // using ".."  For a local drive this is the first slash (e.g. "c:\").
    1:     // For a UNC path it is the slash following the share name 
    1:     // (e.g. "\\server\share\").
    1:     PRInt32 rootIdx = 2;        // default to local drive
    1:     if (path.First() == L'\\')   // if a share then calculate the rootIdx
    1:     {
    1:         rootIdx = path.FindChar(L'\\', 2);   // skip \\ in front of the server
    1:         if (rootIdx == kNotFound)
    1:             return NS_OK;                   // already normalized
    1:         rootIdx = path.FindChar(L'\\', rootIdx+1);
    1:         if (rootIdx == kNotFound)
    1:             return NS_OK;                   // already normalized
    1:     }
    1:     else if (path.CharAt(rootIdx) != L'\\')
    1:     {
    1:         // The path has been specified relative to the current working directory 
    1:         // for that drive. To normalize it, the current working directory for 
    1:         // that drive needs to be inserted before the supplied relative path
    1:         // which will provide an absolute path (and the rootIdx will still be 2).
    1:         WCHAR cwd[MAX_PATH];
    1:         WCHAR * pcwd = cwd;
    1:         int drive = TOUPPER(path.First()) - 'A' + 1;
12888:         /* We need to worry about IPH, for details read bug 419326.
12888:          * _getdrives - http://msdn2.microsoft.com/en-us/library/xdhk0xd2.aspx 
12888:          * uses a bitmask, bit 0 is 'a:'
12888:          * _chdrive - http://msdn2.microsoft.com/en-us/library/0d1409hb.aspx
12888:          * _getdcwd - http://msdn2.microsoft.com/en-us/library/7t2zk3s4.aspx
12888:          * take an int, 1 is 'a:'.
12888:          *
12888:          * Because of this, we need to do some math. Subtract 1 to convert from
12888:          * _chdrive/_getdcwd format to _getdrives drive numbering.
12888:          * Shift left x bits to convert from integer indexing to bitfield indexing.
12888:          * And of course, we need to find out if the drive is in the bitmask.
12888:          *
12888:          * If we're really unlucky, we can still lose, but only if the user
12888:          * manages to eject the drive between our call to _getdrives() and
12888:          * our *calls* to _wgetdcwd.
12888:          */
12888:         if (!((1 << (drive - 1)) & _getdrives()))
12888:             return NS_ERROR_FILE_INVALID_PATH;
    1:         if (!_wgetdcwd(drive, pcwd, MAX_PATH))
    1:             pcwd = _wgetdcwd(drive, 0, 0);
    1:         if (!pcwd)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         nsAutoString currentDir(pcwd);
    1:         if (pcwd != cwd)
    1:             free(pcwd);
    1: 
    1:         if (currentDir.Last() == '\\')
    1:             path.Replace(0, 2, currentDir);
    1:         else
    1:             path.Replace(0, 2, currentDir + NS_LITERAL_STRING("\\"));
    1:     }
    1:     NS_POSTCONDITION(0 < rootIdx && rootIdx < (PRInt32)path.Length(), "rootIdx is invalid");
    1:     NS_POSTCONDITION(path.CharAt(rootIdx) == '\\', "rootIdx is invalid");
    1: 
    1:     // if there is nothing following the root path then it is already normalized
    1:     if (rootIdx + 1 == (PRInt32)path.Length())
    1:         return NS_OK;
    1: 
    1:     // assign the root
    1:     const PRUnichar * pathBuffer = path.get();  // simplify access to the buffer
    1:     mWorkingPath.SetCapacity(path.Length()); // it won't ever grow longer
    1:     mWorkingPath.Assign(pathBuffer, rootIdx);
    1: 
    1:     // Normalize the path components. The actions taken are:
    1:     //
    1:     //  "\\"    condense to single backslash
    1:     //  "."     remove from path
    1:     //  ".."    up a directory
    1:     //  "..."   remove from path (any number of dots > 2)
    1:     //
    1:     // The last form is something that Windows 95 and 98 supported and 
    1:     // is a shortcut for changing up multiple directories. Windows XP
    1:     // and ilk ignore it in a path, as is done here.
    1:     PRInt32 len, begin, end = rootIdx;
    1:     while (end < (PRInt32)path.Length())
    1:     {
    1:         // find the current segment (text between the backslashes) to 
    1:         // be examined, this will set the following variables:
    1:         //  begin == index of first char in segment
    1:         //  end   == index 1 char after last char in segment
    1:         //  len   == length of segment 
    1:         begin = end + 1;
    1:         end = path.FindChar('\\', begin);
    1:         if (end == kNotFound)
    1:             end = path.Length();
    1:         len = end - begin;
    1:         
    1:         // ignore double backslashes
    1:         if (len == 0)
    1:             continue;
    1:         
    1:         // len != 0, and interesting paths always begin with a dot
    1:         if (pathBuffer[begin] == '.')
    1:         {
    1:             // ignore single dots
    1:             if (len == 1)
    1:                 continue;   
    1: 
    1:             // handle multiple dots
    1:             if (len >= 2 && pathBuffer[begin+1] == L'.')
    1:             {
    1:                 // back up a path component on double dot
    1:                 if (len == 2)
    1:                 {
    1:                     PRInt32 prev = mWorkingPath.RFindChar('\\');
    1:                     if (prev >= rootIdx)
    1:                         mWorkingPath.Truncate(prev);
    1:                     continue;
    1:                 }
    1: 
    1:                 // length is > 2 and the first two characters are dots. 
    1:                 // if the rest of the string is dots, then ignore it.
    1:                 int idx = len - 1;
    1:                 for (; idx >= 2; --idx) 
    1:                 {
    1:                     if (pathBuffer[begin+idx] != L'.')
    1:                         break;
    1:                 }
    1: 
    1:                 // this is true if the loop above didn't break
    1:                 // and all characters in this segment are dots.
    1:                 if (idx < 2) 
    1:                     continue;
    1:             }
    1:         }
    1: 
    1:         // add the current component to the path, including the preceding backslash
    1:         mWorkingPath.Append(pathBuffer + begin - 1, len + 1);
    1:     }
    1: 
    1:     // kill trailing dots and spaces.
    1:     PRInt32 filePathLen = mWorkingPath.Length() - 1;
    1:     while(filePathLen > 0 && (mWorkingPath[filePathLen] == L' ' ||
    1:           mWorkingPath[filePathLen] == L'.'))
    1:     {
    1:         mWorkingPath.Truncate(filePathLen--);
    1:     } 
    1: 
20214:     MakeDirty();
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetLeafName(nsAString &aLeafName)
    1: {
    1:     aLeafName.Truncate();
    1: 
    1:     if (mWorkingPath.IsEmpty())
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
    1:     PRInt32 offset = mWorkingPath.RFindChar(L'\\');
    1: 
    1:     // if the working path is just a node without any lashes.
    1:     if (offset == kNotFound)
    1:         aLeafName = mWorkingPath;
    1:     else
    1:         aLeafName = Substring(mWorkingPath, offset + 1);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetLeafName(const nsAString &aLeafName)
    1: {
20214:     MakeDirty();
20214: 
    1:     if (mWorkingPath.IsEmpty())
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
    1:     // cannot use nsCString::RFindChar() due to 0x5c problem
    1:     PRInt32 offset = mWorkingPath.RFindChar(L'\\');
    1:     if (offset)
    1:     {
    1:         mWorkingPath.Truncate(offset+1);
    1:     }
    1:     mWorkingPath.Append(aLeafName);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetPath(nsAString &_retval)
    1: {
    1:     _retval = mWorkingPath;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetCanonicalPath(nsAString &aResult)
    1: {
    1:     EnsureShortPath();
    1:     aResult.Assign(mShortWorkingPath);
    1:     return NS_OK;
    1: }
    1: 
    1: typedef struct {
    1:     WORD wLanguage;
    1:     WORD wCodePage;
    1: } LANGANDCODEPAGE;
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetVersionInfoField(const char* aField, nsAString& _retval)
    1: {
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     rv = NS_ERROR_FAILURE;
    1: 
    1:     // Cast away const-ness here because WinAPI functions don't understand it, 
    1:     // the path is used for [in] parameters only however so it's safe. 
 3233:     WCHAR *path = const_cast<WCHAR*>(mFollowSymlinks ? mResolvedPath.get() 
    1:                                                         : mWorkingPath.get());
    1: 
    1:     DWORD dummy;
    1:     DWORD size = ::GetFileVersionInfoSizeW(path, &dummy);
    1:     if (!size)
    1:         return rv;
    1: 
    1:     void* ver = calloc(size, 1);
    1:     if (!ver)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (::GetFileVersionInfoW(path, 0, size, ver)) 
    1:     {
    1:         LANGANDCODEPAGE* translate = nsnull;
    1:         UINT pageCount;
    1:         BOOL queryResult = ::VerQueryValueW(ver, L"\\VarFileInfo\\Translation", 
    1:                                             (void**)&translate, &pageCount);
    1:         if (queryResult && translate) 
    1:         {
    1:             for (PRInt32 i = 0; i < 2; ++i) 
    1:             { 
    1:                 PRUnichar subBlock[MAX_PATH];
    1:                 _snwprintf(subBlock, MAX_PATH,
    1:                            L"\\StringFileInfo\\%04x%04x\\%s", 
    1:                            (i == 0 ? translate[0].wLanguage 
    1:                                    : ::GetUserDefaultLangID()),
    1:                            translate[0].wCodePage,
    1:                            NS_ConvertASCIItoUTF16(
    1:                                nsDependentCString(aField)).get());
    1:                 subBlock[MAX_PATH - 1] = 0;
    1:                 LPVOID value = nsnull;
    1:                 UINT size;
    1:                 queryResult = ::VerQueryValueW(ver, subBlock, &value, &size);
    1:                 if (queryResult && value)
    1:                 {
 3233:                     _retval.Assign(static_cast<PRUnichar*>(value));
    1:                     if (!_retval.IsEmpty()) 
    1:                     {
    1:                         rv = NS_OK;
    1:                         break;
    1:                     }
    1:                 }
    1:             }
    1:         }
    1:     }
    1:     free(ver);
    1:     
    1:     return rv;
    1: }
    1: 
89529: /** 
89529:  * Determines if the drive type for the specified file is rmeote or local.
89529:  * 
89529:  * @param path   The path of the file to check
89529:  * @param remote Out parameter, on function success holds true if the specified
89529:  *               file path is remote, or false if the file path is local.
89529:  * @return true  on success. The return value implies absolutely nothing about
89529:  *               wether the file is local or remote.
89529: */
89529: static bool
89529: IsRemoteFilePath(LPCWSTR path, bool &remote)
89529: {
89529:   // Obtain the parent directory path and make sure it ends with
89529:   // a trailing backslash.
89529:   WCHAR dirPath[MAX_PATH + 1] = { 0 };
89529:   wcsncpy(dirPath, path, MAX_PATH);
89529:   if (!PathRemoveFileSpecW(dirPath)) {
89529:     return false;
89529:   }
89529:   size_t len = wcslen(dirPath);
89529:   // In case the dirPath holds exaclty MAX_PATH and remains unchanged, we
89529:   // recheck the required length here since we need to terminate it with
89529:   // a backslash.
89529:   if (len >= MAX_PATH) {
89529:     return false;
89529:   }
89529: 
89529:   dirPath[len] = L'\\';
89529:   dirPath[len + 1] = L'\0';
89529:   UINT driveType = GetDriveTypeW(dirPath);
89529:   remote = driveType == DRIVE_REMOTE;
89529:   return true;
89529: }
89529: 
    1: nsresult
    1: nsLocalFile::CopySingleFile(nsIFile *sourceFile, nsIFile *destParent,
    1:                             const nsAString &newName, 
79445:                             bool followSymlinks, bool move,
79445:                             bool skipNtfsAclReset)
    1: {
    1:     nsresult rv;
    1:     nsAutoString filePath;
    1: 
    1:     // get the path that we are going to copy to.
    1:     // Since windows does not know how to auto
    1:     // resolve shortcuts, we must work with the
    1:     // target.
    1:     nsAutoString destPath;
    1:     destParent->GetTarget(destPath);
    1: 
    1:     destPath.AppendASCII("\\");
    1: 
    1:     if (newName.IsEmpty())
    1:     {
    1:         nsAutoString aFileName;
    1:         sourceFile->GetLeafName(aFileName);
    1:         destPath.Append(aFileName);
    1:     }
    1:     else
    1:     {
    1:         destPath.Append(newName);
    1:     }
    1: 
    1: 
    1:     if (followSymlinks)
    1:     {
    1:         rv = sourceFile->GetTarget(filePath);
    1:         if (filePath.IsEmpty())
    1:             rv = sourceFile->GetPath(filePath);
    1:     }
    1:     else
    1:     {
    1:         rv = sourceFile->GetPath(filePath);
    1:     }
    1: 
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
63998:     // Pass the flag COPY_FILE_NO_BUFFERING to CopyFileEx as we may be copying
63998:     // to a SMBV2 remote drive. Without this parameter subsequent append mode
63998:     // file writes can cause the resultant file to become corrupt. We only need to do 
63998:     // this if the major version of Windows is > 5(Only Windows Vista and above 
89529:     // can support SMBV2).  With a 7200RPM hard drive:
89529:     // Copying a 1KB file with COPY_FILE_NO_BUFFERING takes about 30-60ms.
89529:     // Copying a 1KB file without COPY_FILE_NO_BUFFERING takes < 1ms.
89529:     // So we only use COPY_FILE_NO_BUFFERING when we have a remote drive.
    1:     int copyOK;
63998:     DWORD dwVersion = GetVersion();
63998:     DWORD dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));
63998:     DWORD dwCopyFlags = 0;
89529:     if (dwMajorVersion > 5) {
89529:         bool path1Remote, path2Remote;
89529:         if (!IsRemoteFilePath(filePath.get(), path1Remote) || 
89529:             !IsRemoteFilePath(destPath.get(), path2Remote) ||
89529:             path1Remote || path2Remote) {
63998:             dwCopyFlags = COPY_FILE_NO_BUFFERING;
89529:         }
89529:     }
    1:     
    1:     if (!move)
63998:         copyOK = ::CopyFileExW(filePath.get(), destPath.get(), NULL, NULL, NULL, dwCopyFlags);
24900:     else {
42578:         DWORD status;
42578:         if (FileEncryptionStatusW(filePath.get(), &status)
42578:             && status == FILE_IS_ENCRYPTED)
42578:         {
63998:             dwCopyFlags |= COPY_FILE_ALLOW_DECRYPTED_DESTINATION;
63998:             copyOK = CopyFileExW(filePath.get(), destPath.get(), NULL, NULL, NULL, dwCopyFlags);
42578: 
42578:             if (copyOK)
42578:                 DeleteFileW(filePath.get());
42578:         }
42578:         else
42578:         {
 5567:             copyOK = ::MoveFileExW(filePath.get(), destPath.get(),
89600:                                    MOVEFILE_REPLACE_EXISTING);
63998:             
63998:             // Check if copying the source file to a different volume,
63998:             // as this could be an SMBV2 mapped drive.
63998:             if (!copyOK && GetLastError() == ERROR_NOT_SAME_DEVICE)
63998:             {
63998:                 copyOK = CopyFileExW(filePath.get(), destPath.get(), NULL, NULL, NULL, dwCopyFlags);
63998:             
63998:                 if (copyOK)
63998:                     DeleteFile(filePath.get());
63998:             }
42578:         }
24900:     }
 5567: 
63998:     if (!copyOK)  // CopyFileEx and MoveFileEx return zero at failure.
    1:         rv = ConvertWinError(GetLastError());
74491:     else if (move && !skipNtfsAclReset)
16673:     {
74491:         // Set security permissions to inherit from parent.
74491:         // Note: propagates to all children: slow for big file trees
26831:         PACL pOldDACL = NULL;
26831:         PSECURITY_DESCRIPTOR pSD = NULL;
26831:         ::GetNamedSecurityInfoW((LPWSTR)destPath.get(), SE_FILE_OBJECT,
26831:                                 DACL_SECURITY_INFORMATION,
26831:                                 NULL, NULL, &pOldDACL, NULL, &pSD);
26831:         if (pOldDACL)
16673:             ::SetNamedSecurityInfoW((LPWSTR)destPath.get(), SE_FILE_OBJECT,
16673:                                     DACL_SECURITY_INFORMATION |
16673:                                     UNPROTECTED_DACL_SECURITY_INFORMATION,
26831:                                     NULL, NULL, pOldDACL, NULL);
26831:         if (pSD)
26831:             LocalFree((HLOCAL)pSD);
16673:     }
69184: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
79445: nsLocalFile::CopyMove(nsIFile *aParentDir, const nsAString &newName, bool followSymlinks, bool move)
    1: {
    1:     nsCOMPtr<nsIFile> newParentDir = aParentDir;
    1:     // check to see if this exists, otherwise return an error.
    1:     // we will check this by resolving.  If the user wants us
    1:     // to follow links, then we are talking about the target,
    1:     // hence we can use the |followSymlinks| parameter.
    1:     nsresult rv  = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (!newParentDir)
    1:     {
    1:         // no parent was specified.  We must rename.
    1:         if (newName.IsEmpty())
    1:             return NS_ERROR_INVALID_ARG;
    1: 
    1:         rv = GetParent(getter_AddRefs(newParentDir));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     if (!newParentDir)
    1:         return NS_ERROR_FILE_DESTINATION_NOT_DIR;
    1: 
    1:     // make sure it exists and is a directory.  Create it if not there.
79445:     bool exists;
    1:     newParentDir->Exists(&exists);
    1:     if (!exists)
    1:     {
    1:         rv = newParentDir->Create(DIRECTORY_TYPE, 0644);  // TODO, what permissions should we use
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1:     else
    1:     {
79445:         bool isDir;
    1:         newParentDir->IsDirectory(&isDir);
37970:         if (!isDir)
    1:         {
    1:             if (followSymlinks)
    1:             {
79445:                 bool isLink;
    1:                 newParentDir->IsSymlink(&isLink);
    1:                 if (isLink)
    1:                 {
    1:                     nsAutoString target;
    1:                     newParentDir->GetTarget(target);
    1: 
    1:                     nsCOMPtr<nsILocalFile> realDest = new nsLocalFile();
    1:                     if (realDest == nsnull)
    1:                         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:                     rv = realDest->InitWithPath(target);
    1: 
    1:                     if (NS_FAILED(rv))
    1:                         return rv;
    1: 
    1:                     return CopyMove(realDest, newName, followSymlinks, move);
    1:                 }
    1:             }
    1:             else
    1:             {
    1:                 return NS_ERROR_FILE_DESTINATION_NOT_DIR;
    1:             }
    1:         }
    1:     }
    1: 
    1:     // Try different ways to move/copy files/directories
79445:     bool done = false;
79445:     bool isDir;
    1:     IsDirectory(&isDir);
79445:     bool isSymlink;
    1:     IsSymlink(&isSymlink);
    1: 
    1:     // Try to move the file or directory, or try to copy a single file (or non-followed symlink)
    1:     if (move || !isDir || (isSymlink && !followSymlinks))
    1:     {
    1:         // Copy/Move single file, or move a directory
74491:         rv = CopySingleFile(this, newParentDir, newName, followSymlinks, move,
74491:                             !aParentDir);
    1:         done = NS_SUCCEEDED(rv);
    1:         // If we are moving a directory and that fails, fallback on directory
    1:         // enumeration.  See bug 231300 for details.
    1:         if (!done && !(move && isDir))
    1:             return rv;  
    1:     }
    1:     
    1:     // Not able to copy or move directly, so enumerate it
    1:     if (!done)
    1:     {
    1:         // create a new target destination in the new parentDir;
    1:         nsCOMPtr<nsIFile> target;
    1:         rv = newParentDir->Clone(getter_AddRefs(target));
    1: 
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsAutoString allocatedNewName;
    1:         if (newName.IsEmpty())
    1:         {
79445:             bool isLink;
    1:             IsSymlink(&isLink);
    1:             if (isLink)
    1:             {
    1:                 nsAutoString temp;
    1:                 GetTarget(temp);
    1:                 PRInt32 offset = temp.RFindChar(L'\\'); 
    1:                 if (offset == kNotFound)
    1:                     allocatedNewName = temp;
    1:                 else 
    1:                     allocatedNewName = Substring(temp, offset + 1);
    1:             }
    1:             else
    1:             {
    1:                 GetLeafName(allocatedNewName);// this should be the leaf name of the
    1:             }
    1:         }
    1:         else
    1:         {
    1:             allocatedNewName = newName;
    1:         }
    1: 
    1:         rv = target->Append(allocatedNewName);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         allocatedNewName.Truncate();
    1: 
    1:         // check if the destination directory already exists
    1:         target->Exists(&exists);
    1:         if (!exists)
    1:         {
    1:             // if the destination directory cannot be created, return an error
    1:             rv = target->Create(DIRECTORY_TYPE, 0644);  // TODO, what permissions should we use
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
    1:         else
    1:         {
    1:             // check if the destination directory is writable and empty
79445:             bool isWritable;
    1: 
    1:             target->IsWritable(&isWritable);
    1:             if (!isWritable)
    1:                 return NS_ERROR_FILE_ACCESS_DENIED;
    1: 
    1:             nsCOMPtr<nsISimpleEnumerator> targetIterator;
    1:             rv = target->GetDirectoryEntries(getter_AddRefs(targetIterator));
80584:             if (NS_FAILED(rv))
80584:                 return rv;
    1: 
79445:             bool more;
    1:             targetIterator->HasMoreElements(&more);
    1:             // return error if target directory is not empty
    1:             if (more)
    1:                 return NS_ERROR_FILE_DIR_NOT_EMPTY;
    1:         }
    1: 
    1:         nsDirEnumerator dirEnum;
    1: 
    1:         rv = dirEnum.Init(this);
    1:         if (NS_FAILED(rv)) {
    1:             NS_WARNING("dirEnum initialization failed");
    1:             return rv;
    1:         }
    1: 
79445:         bool more;
    1:         while (NS_SUCCEEDED(dirEnum.HasMoreElements(&more)) && more)
    1:         {
    1:             nsCOMPtr<nsISupports> item;
    1:             nsCOMPtr<nsIFile> file;
    1:             dirEnum.GetNext(getter_AddRefs(item));
    1:             file = do_QueryInterface(item);
    1:             if (file)
    1:             {
79445:                 bool isDir, isLink;
    1: 
    1:                 file->IsDirectory(&isDir);
    1:                 file->IsSymlink(&isLink);
    1: 
    1:                 if (move)
    1:                 {
    1:                     if (followSymlinks)
    1:                         return NS_ERROR_FAILURE;
    1: 
    1:                     rv = file->MoveTo(target, EmptyString());
    1:                     NS_ENSURE_SUCCESS(rv,rv);
    1:                 }
    1:                 else
    1:                 {
    1:                     if (followSymlinks)
    1:                         rv = file->CopyToFollowingLinks(target, EmptyString());
    1:                     else
    1:                         rv = file->CopyTo(target, EmptyString());
    1:                     NS_ENSURE_SUCCESS(rv,rv);
    1:                 }
    1:             }
    1:         }
    1:         // we've finished moving all the children of this directory
    1:         // in the new directory.  so now delete the directory
    1:         // note, we don't need to do a recursive delete.
    1:         // MoveTo() is recursive.  At this point,
    1:         // we've already moved the children of the current folder
    1:         // to the new location.  nothing should be left in the folder.
    1:         if (move)
    1:         {
80486:           rv = Remove(false /* recursive */);
    1:           NS_ENSURE_SUCCESS(rv,rv);
    1:         }
    1:     }
    1: 
    1: 
    1:     // If we moved, we want to adjust this.
    1:     if (move)
    1:     {
20214:         MakeDirty();
20214: 
    1:         nsAutoString newParentPath;
    1:         newParentDir->GetPath(newParentPath);
    1: 
    1:         if (newParentPath.IsEmpty())
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         if (newName.IsEmpty())
    1:         {
    1:             nsAutoString aFileName;
    1:             GetLeafName(aFileName);
    1: 
    1:             InitWithPath(newParentPath);
    1:             Append(aFileName);
    1:         }
    1:         else
    1:         {
    1:             InitWithPath(newParentPath);
    1:             Append(newName);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::CopyTo(nsIFile *newParentDir, const nsAString &newName)
    1: {
80486:     return CopyMove(newParentDir, newName, false, false);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::CopyToFollowingLinks(nsIFile *newParentDir, const nsAString &newName)
    1: {
80486:     return CopyMove(newParentDir, newName, true, false);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::MoveTo(nsIFile *newParentDir, const nsAString &newName)
    1: {
80486:     return CopyMove(newParentDir, newName, false, true);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Load(PRLibrary * *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
79445:     bool isFile;
    1:     nsresult rv = IsFile(&isFile);
    1: 
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (! isFile)
    1:         return NS_ERROR_FILE_IS_DIRECTORY;
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
80486:     nsTraceRefcntImpl::SetActivityIsLegal(false);
    1: #endif
    1: 
    1:     PRLibSpec libSpec;
    1:     libSpec.value.pathname_u = mResolvedPath.get();
    1:     libSpec.type = PR_LibSpec_PathnameU;
    1:     *_retval =  PR_LoadLibraryWithFlags(libSpec, 0);
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
80486:     nsTraceRefcntImpl::SetActivityIsLegal(true);
    1: #endif
    1: 
    1:     if (*_retval)
    1:         return NS_OK;
    1:     return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Remove(bool recursive)
    1: {
    1:     // NOTE:
    1:     //
    1:     // if the working path points to a shortcut, then we will only
    1:     // delete the shortcut itself.  even if the shortcut points to
    1:     // a directory, we will not recurse into that directory or 
    1:     // delete that directory itself.  likewise, if the shortcut
    1:     // points to a normal file, we will not delete the real file.
    1:     // this is done to be consistent with the other platforms that
    1:     // behave this way.  we do this even if the followLinks attribute
    1:     // is set to true.  this helps protect against misuse that could
    1:     // lead to security bugs (e.g., bug 210588).
    1:     //
    1:     // Since shortcut files are no longer permitted to be used as unix-like
    1:     // symlinks interspersed in the path (e.g. "c:/file.lnk/foo/bar.txt")
    1:     // this processing is a lot simpler. Even if the shortcut file is 
    1:     // pointing to a directory, only the mWorkingPath value is used and so
    1:     // only the shortcut file will be deleted.
    1: 
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
79445:     bool isDir, isLink;
    1:     nsresult rv;
    1:     
80486:     isDir = false;
    1:     rv = IsSymlink(&isLink);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // only check to see if we have a directory if it isn't a link
    1:     if (!isLink)
    1:     {
    1:         rv = IsDirectory(&isDir);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     if (isDir)
    1:     {
    1:         if (recursive)
    1:         {
    1:             nsDirEnumerator dirEnum;
    1: 
    1:             rv = dirEnum.Init(this);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1: 
79445:             bool more;
    1:             while (NS_SUCCEEDED(dirEnum.HasMoreElements(&more)) && more)
    1:             {
    1:                 nsCOMPtr<nsISupports> item;
    1:                 dirEnum.GetNext(getter_AddRefs(item));
    1:                 nsCOMPtr<nsIFile> file = do_QueryInterface(item);
    1:                 if (file)
    1:                     file->Remove(recursive);
    1:             }
    1:         }
22244:         if (RemoveDirectoryW(mWorkingPath.get()) == 0)
22244:             return ConvertWinError(GetLastError());
    1:     }
    1:     else
    1:     {
22244:         if (DeleteFileW(mWorkingPath.get()) == 0)
22244:             return ConvertWinError(GetLastError());
    1:     }
    1: 
20214:     MakeDirty();
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetLastModifiedTime(PRInt64 *aLastModifiedTime)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(aLastModifiedTime);
    1:  
    1:     // get the modified time of the target as determined by mFollowSymlinks
80486:     // If true, then this will be for the target of the shortcut file, 
    1:     // otherwise it will be for the shortcut file itself (i.e. the same 
    1:     // results as GetLastModifiedTimeOfLink)
    1: 
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // microseconds -> milliseconds
    1:     PRInt64 usecPerMsec;
    1:     LL_I2L(usecPerMsec, PR_USEC_PER_MSEC);
    1:     LL_DIV(*aLastModifiedTime, mFileInfo64.modifyTime, usecPerMsec);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetLastModifiedTimeOfLink(PRInt64 *aLastModifiedTime)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(aLastModifiedTime);
    1:  
    1:     // The caller is assumed to have already called IsSymlink 
    1:     // and to have found that this file is a link. 
    1: 
    1:     PRFileInfo64 info;
    1:     nsresult rv = GetFileInfo(mWorkingPath, &info);
    1:     if (NS_FAILED(rv)) 
    1:         return rv;
    1: 
    1:     // microseconds -> milliseconds
    1:     PRInt64 usecPerMsec;
    1:     LL_I2L(usecPerMsec, PR_USEC_PER_MSEC);
    1:     LL_DIV(*aLastModifiedTime, info.modifyTime, usecPerMsec);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetLastModifiedTime(PRInt64 aLastModifiedTime)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // set the modified time of the target as determined by mFollowSymlinks
80486:     // If true, then this will be for the target of the shortcut file, 
    1:     // otherwise it will be for the shortcut file itself (i.e. the same 
    1:     // results as SetLastModifiedTimeOfLink)
    1: 
    1:     rv = SetModDate(aLastModifiedTime, mResolvedPath.get());
20214:     if (NS_SUCCEEDED(rv))
20214:         MakeDirty();
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetLastModifiedTimeOfLink(PRInt64 aLastModifiedTime)
    1: {
    1:     // The caller is assumed to have already called IsSymlink 
    1:     // and to have found that this file is a link. 
20214: 
20214:     nsresult rv = SetModDate(aLastModifiedTime, mWorkingPath.get());
20214:     if (NS_SUCCEEDED(rv))
20214:         MakeDirty();
20214: 
20214:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsLocalFile::SetModDate(PRInt64 aLastModifiedTime, const PRUnichar *filePath)
    1: {
40601:     // The FILE_FLAG_BACKUP_SEMANTICS is required in order to change the
40601:     // modification time for directories.
    1:     HANDLE file = ::CreateFileW(filePath,          // pointer to name of the file
    1:                                 GENERIC_WRITE,     // access (write) mode
    1:                                 0,                 // share mode
    1:                                 NULL,              // pointer to security attributes
    1:                                 OPEN_EXISTING,     // how to create
40601:                                 FILE_FLAG_BACKUP_SEMANTICS,  // file attributes
    1:                                 NULL);
    1: 
    1:     if (file == INVALID_HANDLE_VALUE)
    1:     {
    1:         return ConvertWinError(GetLastError());
    1:     }
    1: 
60707:     FILETIME ft;
    1:     SYSTEMTIME st;
    1:     PRExplodedTime pret;
    1: 
    1:     // PR_ExplodeTime expects usecs...
60707:     PR_ExplodeTime(aLastModifiedTime * PR_USEC_PER_MSEC, PR_GMTParameters, &pret);
    1:     st.wYear            = pret.tm_year;
    1:     st.wMonth           = pret.tm_month + 1; // Convert start offset -- Win32: Jan=1; NSPR: Jan=0
    1:     st.wDayOfWeek       = pret.tm_wday;
    1:     st.wDay             = pret.tm_mday;
    1:     st.wHour            = pret.tm_hour;
    1:     st.wMinute          = pret.tm_min;
    1:     st.wSecond          = pret.tm_sec;
    1:     st.wMilliseconds    = pret.tm_usec/1000;
    1: 
    1:     nsresult rv = NS_OK;
    1:     // if at least one of these fails...
60707:     if (!(SystemTimeToFileTime(&st, &ft) != 0 &&
    1:           SetFileTime(file, NULL, &ft, &ft) != 0))
    1:     {
    1:       rv = ConvertWinError(GetLastError());
    1:     }
    1: 
    1:     CloseHandle(file);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetPermissions(PRUint32 *aPermissions)
    1: {
    1:     NS_ENSURE_ARG(aPermissions);
    1: 
    1:     // get the permissions of the target as determined by mFollowSymlinks
80486:     // If true, then this will be for the target of the shortcut file, 
    1:     // otherwise it will be for the shortcut file itself (i.e. the same 
    1:     // results as GetPermissionsOfLink)
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
79445:     bool isWritable, isExecutable;
    1:     IsWritable(&isWritable);
    1:     IsExecutable(&isExecutable);
    1: 
    1:     *aPermissions = PR_IRUSR|PR_IRGRP|PR_IROTH;         // all read
    1:     if (isWritable)
    1:         *aPermissions |= PR_IWUSR|PR_IWGRP|PR_IWOTH;    // all write
    1:     if (isExecutable)
    1:         *aPermissions |= PR_IXUSR|PR_IXGRP|PR_IXOTH;    // all execute
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetPermissionsOfLink(PRUint32 *aPermissions)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(aPermissions);
    1: 
    1:     // The caller is assumed to have already called IsSymlink 
    1:     // and to have found that this file is a link. It is not 
    1:     // possible for a link file to be executable.
    1: 
    1:     DWORD word = ::GetFileAttributesW(mWorkingPath.get());
    1:     if (word == INVALID_FILE_ATTRIBUTES)
    1:         return NS_ERROR_FILE_INVALID_PATH;
    1: 
79445:     bool isWritable = !(word & FILE_ATTRIBUTE_READONLY);
    1:     *aPermissions = PR_IRUSR|PR_IRGRP|PR_IROTH;         // all read
    1:     if (isWritable)
    1:         *aPermissions |= PR_IWUSR|PR_IWGRP|PR_IWOTH;    // all write
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetPermissions(PRUint32 aPermissions)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     // set the permissions of the target as determined by mFollowSymlinks
80486:     // If true, then this will be for the target of the shortcut file, 
    1:     // otherwise it will be for the shortcut file itself (i.e. the same 
    1:     // results as SetPermissionsOfLink)
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // windows only knows about the following permissions
    1:     int mode = 0;
    1:     if (aPermissions & (PR_IRUSR|PR_IRGRP|PR_IROTH))    // any read
    1:         mode |= _S_IREAD;
    1:     if (aPermissions & (PR_IWUSR|PR_IWGRP|PR_IWOTH))    // any write
    1:         mode |= _S_IWRITE;
    1: 
    1:     if (_wchmod(mResolvedPath.get(), mode) == -1)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetPermissionsOfLink(PRUint32 aPermissions)
    1: {
    1:     // The caller is assumed to have already called IsSymlink 
    1:     // and to have found that this file is a link. 
    1: 
    1:     // windows only knows about the following permissions
    1:     int mode = 0;
    1:     if (aPermissions & (PR_IRUSR|PR_IRGRP|PR_IROTH))    // any read
    1:         mode |= _S_IREAD;
    1:     if (aPermissions & (PR_IWUSR|PR_IWGRP|PR_IWOTH))    // any write
    1:         mode |= _S_IWRITE;
    1: 
    1:     if (_wchmod(mWorkingPath.get(), mode) == -1)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetFileSize(PRInt64 *aFileSize)
    1: {
    1:     NS_ENSURE_ARG(aFileSize);
    1: 
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *aFileSize = mFileInfo64.size;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetFileSizeOfLink(PRInt64 *aFileSize)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(aFileSize);
    1: 
    1:     // The caller is assumed to have already called IsSymlink 
    1:     // and to have found that this file is a link. 
    1: 
    1:     PRFileInfo64 info;
    1:     if (NS_FAILED(GetFileInfo(mWorkingPath, &info)))
    1:         return NS_ERROR_FILE_INVALID_PATH;
    1: 
    1:     *aFileSize = info.size;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetFileSize(PRInt64 aFileSize)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     HANDLE hFile = ::CreateFileW(mResolvedPath.get(),// pointer to name of the file
    1:                                  GENERIC_WRITE,      // access (write) mode
    1:                                  FILE_SHARE_READ,    // share mode
    1:                                  NULL,               // pointer to security attributes
    1:                                  OPEN_EXISTING,          // how to create
    1:                                  FILE_ATTRIBUTE_NORMAL,  // file attributes
    1:                                  NULL);
    1:     if (hFile == INVALID_HANDLE_VALUE)
20214:     {
    1:         return ConvertWinError(GetLastError());
20214:     }
    1: 
    1:     // seek the file pointer to the new, desired end of file
    1:     // and then truncate the file at that position
    1:     rv = NS_ERROR_FAILURE;
    1:     aFileSize = MyFileSeek64(hFile, aFileSize, FILE_BEGIN);
    1:     if (aFileSize != -1 && SetEndOfFile(hFile))
20214:     {
20214:         MakeDirty();
    1:         rv = NS_OK;
20214:     }
    1: 
    1:     CloseHandle(hFile);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetDiskSpaceAvailable(PRInt64 *aDiskSpaceAvailable)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(aDiskSpaceAvailable);
    1: 
    1:     ResolveAndStat();
    1: 
77252:     if (mFileInfo64.type == PR_FILE_FILE) {
77252:       // Since GetDiskFreeSpaceExW works only on directories, use the parent.
77252:       nsCOMPtr<nsIFile> parent;
77252:       if (NS_SUCCEEDED(GetParent(getter_AddRefs(parent))) && parent) {
77252:         nsCOMPtr<nsILocalFile> localParent = do_QueryInterface(parent);
77252:         return localParent->GetDiskSpaceAvailable(aDiskSpaceAvailable);
77252:       }
77252:     }
77252: 
    1:     ULARGE_INTEGER liFreeBytesAvailableToCaller, liTotalNumberOfBytes;
    1:     if (::GetDiskFreeSpaceExW(mResolvedPath.get(), &liFreeBytesAvailableToCaller, 
    1:                               &liTotalNumberOfBytes, NULL))
    1:     {
    1:         *aDiskSpaceAvailable = liFreeBytesAvailableToCaller.QuadPart;
    1:         return NS_OK;
    1:     }
    1:     *aDiskSpaceAvailable = 0;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetParent(nsIFile * *aParent)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG_POINTER(aParent);
    1: 
   70:     // A two-character path must be a drive such as C:, so it has no parent
   70:     if (mWorkingPath.Length() == 2) {
   70:         *aParent = nsnull;
   70:         return NS_OK;
   70:     }
   70: 
   70:     PRInt32 offset = mWorkingPath.RFindChar(PRUnichar('\\'));
    1:     // adding this offset check that was removed in bug 241708 fixes mail
    1:     // directories that aren't relative to/underneath the profile dir.
    1:     // e.g., on a different drive. Before you remove them, please make
    1:     // sure local mail directories that aren't underneath the profile dir work.
    1:     if (offset == kNotFound)
    1:       return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
   70:     // A path of the form \\NAME is a top-level path and has no parent
   70:     if (offset == 1 && mWorkingPath[0] == L'\\') {
    1:         *aParent = nsnull;
    1:         return NS_OK;
    1:     }
   70: 
   70:     nsAutoString parentPath(mWorkingPath);
   70: 
    1:     if (offset > 0)
    1:         parentPath.Truncate(offset);
    1:     else
    1:         parentPath.AssignLiteral("\\\\.");
    1: 
    1:     nsCOMPtr<nsILocalFile> localFile;
    1:     nsresult rv = NS_NewLocalFile(parentPath, mFollowSymlinks, getter_AddRefs(localFile));
    1: 
78635:     if (NS_SUCCEEDED(rv) && localFile) {
    1:         return CallQueryInterface(localFile, aParent);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Exists(bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
20214:     MakeDirty();
    1:     nsresult rv = ResolveAndStat();
78583:     *_retval = NS_SUCCEEDED(rv) || rv == NS_ERROR_FILE_IS_LOCKED;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsWritable(bool *aIsWritable)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     // The read-only attribute on a FAT directory only means that it can't 
    1:     // be deleted. It is still possible to modify the contents of the directory.
    1:     nsresult rv = IsDirectory(aIsWritable);
78635:     if (rv == NS_ERROR_FILE_ACCESS_DENIED) {
80486:       *aIsWritable = true;
78635:       return NS_OK;
78635:     } else if (rv == NS_ERROR_FILE_IS_LOCKED) {
78635:       // If the file is normally allowed write access
78635:       // we should still return that the file is writable.
78635:     } else if (NS_FAILED(rv)) {
    1:         return rv;
78635:     }
    1:     if (*aIsWritable)
    1:         return NS_OK;
    1: 
    1:     // writable if the file doesn't have the readonly attribute
    1:     rv = HasFileAttribute(FILE_ATTRIBUTE_READONLY, aIsWritable);
78635:     if (rv == NS_ERROR_FILE_ACCESS_DENIED) {
80486:         *aIsWritable = false;
78635:         return NS_OK;
78635:     } else if (rv == NS_ERROR_FILE_IS_LOCKED) {
78635:       // If the file is normally allowed write access
78635:       // we should still return that the file is writable.
78635:     } else if (NS_FAILED(rv)) {
    1:         return rv;
78635:     }
    1:     *aIsWritable = !*aIsWritable;
    1: 
78635:     // If the read only attribute is not set, check to make sure
78635:     // we can open the file with write access.
78635:     if (*aIsWritable) {
78635:         PRFileDesc* file;
78635:         rv = OpenFile(mResolvedPath, PR_WRONLY, 0, &file);
78635:         if (NS_SUCCEEDED(rv)) {
78635:             PR_Close(file);
78635:         } else if (rv == NS_ERROR_FILE_ACCESS_DENIED) {
78635:           *aIsWritable = false;
78635:         } else if (rv == NS_ERROR_FILE_IS_LOCKED) {
78635:             // If it is locked and read only we would have 
78635:             // gotten access denied
78635:             *aIsWritable = true; 
78635:         } else {
78635:             return rv;
78635:         }
78635:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsReadable(bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
80486:     *_retval = true;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsExecutable(bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1:     
    1:     nsresult rv;
    1: 
    1:     // only files can be executables
79445:     bool isFile;
    1:     rv = IsFile(&isFile);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     if (!isFile)
    1:         return NS_OK;
    1: 
    1:     //TODO: shouldn't we be checking mFollowSymlinks here?
79445:     bool symLink;
    1:     rv = IsSymlink(&symLink);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsAutoString path;
    1:     if (symLink)
    1:         GetTarget(path);
    1:     else
    1:         GetPath(path);
    1: 
    1:     // kill trailing dots and spaces.
    1:     PRInt32 filePathLen = path.Length() - 1;
    1:     while(filePathLen > 0 && (path[filePathLen] == L' ' || path[filePathLen] == L'.'))
    1:     {
    1:         path.Truncate(filePathLen--);
    1:     } 
    1: 
    1:     // Get extension.
    1:     PRInt32 dotIdx = path.RFindChar(PRUnichar('.'));
    1:     if ( dotIdx != kNotFound ) {
    1:         // Convert extension to lower case.
    1:         PRUnichar *p = path.BeginWriting();
    1:         for( p+= dotIdx + 1; *p; p++ )
    1:             *p +=  (*p >= L'A' && *p <= L'Z') ? 'a' - 'A' : 0; 
    1:         
    1:         // Search for any of the set of executable extensions.
 5569:         static const char * const executableExts[] = {
    1:             "ad",
    1:             "ade",         // access project extension
    1:             "adp",
71404:             "air",         // Adobe AIR installer
    1:             "app",         // executable application
    1:             "application", // from bug 348763
    1:             "asp",
    1:             "bas",
    1:             "bat",
    1:             "chm",
    1:             "cmd",
    1:             "com",
    1:             "cpl",
    1:             "crt",
    1:             "exe",
    1:             "fxp",         // FoxPro compiled app
    1:             "hlp",
    1:             "hta",
    1:             "inf",
    1:             "ins",
    1:             "isp",
71404:             "jar",         // java application bundle
    1:             "js",
    1:             "jse",
    1:             "lnk",
    1:             "mad",         // Access Module Shortcut
    1:             "maf",         // Access
    1:             "mag",         // Access Diagram Shortcut
    1:             "mam",         // Access Macro Shortcut
    1:             "maq",         // Access Query Shortcut
    1:             "mar",         // Access Report Shortcut
    1:             "mas",         // Access Stored Procedure
    1:             "mat",         // Access Table Shortcut
    1:             "mau",         // Media Attachment Unit
    1:             "mav",         // Access View Shortcut
    1:             "maw",         // Access Data Access Page
    1:             "mda",         // Access Add-in, MDA Access 2 Workgroup
    1:             "mdb",
    1:             "mde",
    1:             "mdt",         // Access Add-in Data
    1:             "mdw",         // Access Workgroup Information
    1:             "mdz",         // Access Wizard Template
    1:             "msc",
    1:             "msh",         // Microsoft Shell
    1:             "mshxml",      // Microsoft Shell
    1:             "msi",
    1:             "msp",
    1:             "mst",
    1:             "ops",         // Office Profile Settings
    1:             "pcd",
    1:             "pif",
    1:             "plg",         // Developer Studio Build Log
    1:             "prf",         // windows system file
    1:             "prg",
    1:             "pst",
    1:             "reg",
    1:             "scf",         // Windows explorer command
    1:             "scr",
    1:             "sct",
    1:             "shb",
    1:             "shs",
    1:             "url",
    1:             "vb",
    1:             "vbe",
    1:             "vbs",
    1:             "vsd",
    1:             "vsmacros",    // Visual Studio .NET Binary-based Macro Project
    1:             "vss",
    1:             "vst",
    1:             "vsw",
    1:             "ws",
    1:             "wsc",
    1:             "wsf",
 5569:             "wsh"};
 5569:         nsDependentSubstring ext = Substring(path, dotIdx + 1);
89732:         for ( size_t i = 0; i < ArrayLength(executableExts); i++ ) {
 5569:             if ( ext.EqualsASCII(executableExts[i])) {
    1:                 // Found a match.  Set result and quit.
80486:                 *_retval = true;
    1:                 break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsDirectory(bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(_retval);
    1: 
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *_retval = (mFileInfo64.type == PR_FILE_DIRECTORY); 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsFile(bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(_retval);
    1: 
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *_retval = (mFileInfo64.type == PR_FILE_FILE); 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsHidden(bool *_retval)
    1: {
    1:     return HasFileAttribute(FILE_ATTRIBUTE_HIDDEN, _retval);
    1: }
    1: 
    1: nsresult
79445: nsLocalFile::HasFileAttribute(DWORD fileAttrib, bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(_retval);
    1: 
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // get the file attributes for the correct item depending on following symlinks
    1:     const PRUnichar *filePath = mFollowSymlinks ? 
    1:                                 mResolvedPath.get() : mWorkingPath.get();
    1:     DWORD word = ::GetFileAttributesW(filePath);
    1: 
    1:     *_retval = ((word & fileAttrib) != 0);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsSymlink(bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(_retval);
    1: 
    1:     // unless it is a valid shortcut path it's not a symlink
    1:     if (!IsShortcutPath(mWorkingPath))
    1:     {
80486:         *_retval = false;
    1:         return NS_OK;
    1:     }
    1: 
    1:     // we need to know if this is a file or directory
    1:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // it's only a shortcut if it is a file
    1:     *_retval = (mFileInfo64.type == PR_FILE_FILE);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsSpecial(bool *_retval)
    1: {
    1:     return HasFileAttribute(FILE_ATTRIBUTE_SYSTEM, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Equals(nsIFile *inFile, bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(inFile);
    1:     NS_ENSURE_ARG(_retval);
    1: 
    1:     EnsureShortPath();
    1: 
    1:     nsCOMPtr<nsILocalFileWin> lf(do_QueryInterface(inFile));
    1:     if (!lf) {
80486:         *_retval = false;
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsAutoString inFilePath;
    1:     lf->GetCanonicalPath(inFilePath);
    1: 
    1:     // Ok : Win9x
    1:     *_retval = _wcsicmp(mShortWorkingPath.get(), inFilePath.get()) == 0; 
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Contains(nsIFile *inFile, bool recur, bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
80486:     *_retval = false;
    1: 
    1:     nsAutoString myFilePath;
    1:     if (NS_FAILED(GetTarget(myFilePath)))
    1:         GetPath(myFilePath);
    1: 
    1:     PRUint32 myFilePathLen = myFilePath.Length();
    1: 
    1:     nsAutoString inFilePath;
    1:     if (NS_FAILED(inFile->GetTarget(inFilePath)))
    1:         inFile->GetPath(inFilePath);
    1: 
    1:     // make sure that the |inFile|'s path has a trailing separator.
    1:     if (inFilePath.Length() >= myFilePathLen && inFilePath[myFilePathLen] == L'\\')
    1:     {
    1:         if (_wcsnicmp(myFilePath.get(), inFilePath.get(), myFilePathLen) == 0)
    1:         {
80486:             *_retval = true;
    1:         }
    1: 
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetTarget(nsAString &_retval)
    1: {
    1:     _retval.Truncate();
    1: #if STRICT_FAKE_SYMLINKS
79445:     bool symLink;
    1: 
    1:     nsresult rv = IsSymlink(&symLink);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (!symLink)
    1:     {
    1:         return NS_ERROR_FILE_INVALID_PATH;
    1:     }
    1: #endif
    1:     ResolveAndStat();
    1: 
    1:     _retval = mResolvedPath;
    1:     return NS_OK;
    1: }
    1: 
    1: 
79445: /* attribute bool followLinks; */
    1: NS_IMETHODIMP
79445: nsLocalFile::GetFollowLinks(bool *aFollowLinks)
    1: {
    1:     *aFollowLinks = mFollowSymlinks;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
79445: nsLocalFile::SetFollowLinks(bool aFollowLinks)
    1: {
20214:     MakeDirty();
    1:     mFollowSymlinks = aFollowLinks;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetDirectoryEntries(nsISimpleEnumerator * *entries)
    1: {
    1:     nsresult rv;
    1: 
    1:     *entries = nsnull;
    1:     if (mWorkingPath.EqualsLiteral("\\\\.")) {
    1:         nsDriveEnumerator *drives = new nsDriveEnumerator;
    1:         if (!drives)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         NS_ADDREF(drives);
    1:         rv = drives->Init();
    1:         if (NS_FAILED(rv)) {
    1:             NS_RELEASE(drives);
    1:             return rv;
    1:         }
    1:         *entries = drives;
    1:         return NS_OK;
    1:     }
    1: 
79445:     bool isDir;
    1:     rv = IsDirectory(&isDir);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     if (!isDir)
    1:         return NS_ERROR_FILE_NOT_DIRECTORY;
    1: 
    1:     nsDirEnumerator* dirEnum = new nsDirEnumerator();
    1:     if (dirEnum == nsnull)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(dirEnum);
    1:     rv = dirEnum->Init(this);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         NS_RELEASE(dirEnum);
    1:         return rv;
    1:     }
    1: 
    1:     *entries = dirEnum;
20187: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetPersistentDescriptor(nsACString &aPersistentDescriptor)
    1: {
    1:     CopyUTF16toUTF8(mWorkingPath, aPersistentDescriptor);
    1:     return NS_OK;
    1: }   
    1:     
    1: NS_IMETHODIMP
    1: nsLocalFile::SetPersistentDescriptor(const nsACString &aPersistentDescriptor)
    1: {
    1:     if (IsUTF8(aPersistentDescriptor))
    1:         return InitWithPath(NS_ConvertUTF8toUTF16(aPersistentDescriptor));
    1:     else
    1:         return InitWithNativePath(aPersistentDescriptor);
    1: }   
    1: 
27558: /* attrib unsigned long fileAttributesWin; */
89731: static bool IsXPOrGreater()
89731: {
89731:     OSVERSIONINFO osvi;
89731: 
89731:     ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
89731:     osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
89731: 
89731:     GetVersionEx(&osvi);
89731: 
89731:     return ((osvi.dwMajorVersion > 5) ||
89731:        ((osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion >= 1)));
89731: }
89731: 
27558: NS_IMETHODIMP
27558: nsLocalFile::GetFileAttributesWin(PRUint32 *aAttribs)
27558: {
27558:     *aAttribs = 0;
27558:     DWORD dwAttrs = GetFileAttributesW(mWorkingPath.get());
27558:     if (dwAttrs == INVALID_FILE_ATTRIBUTES)
27558:       return NS_ERROR_FILE_INVALID_PATH;
27558: 
27558:     if (!(dwAttrs & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED))
27558:         *aAttribs |= WFA_SEARCH_INDEXED;
27558: 
27558:     return NS_OK;
27558: }   
27558:     
27558: NS_IMETHODIMP
27558: nsLocalFile::SetFileAttributesWin(PRUint32 aAttribs)
27558: {
27558:     DWORD dwAttrs = GetFileAttributesW(mWorkingPath.get());
27558:     if (dwAttrs == INVALID_FILE_ATTRIBUTES)
27558:       return NS_ERROR_FILE_INVALID_PATH;
27558: 
89731:     if (IsXPOrGreater()) {
27558:       if (aAttribs & WFA_SEARCH_INDEXED) {
27558:           dwAttrs &= ~FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
27558:       } else {
27558:           dwAttrs |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
27558:       }
89731:     }
27558: 
27558:     if (SetFileAttributesW(mWorkingPath.get(), dwAttrs) == 0)
27558:       return NS_ERROR_FAILURE;
27558:     return NS_OK;
27558: }   
27558: 
27558: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Reveal()
    1: {
    1:     // make sure mResolvedPath is set
89731:     nsresult rv = ResolveAndStat();
    1:     if (NS_FAILED(rv) && rv != NS_ERROR_FILE_NOT_FOUND)
    1:         return rv;
    1: 
89731:     // First try revealing with the shell, and if that fails fall back
89731:     // to the classic way using explorer.exe command line parameters
89731:     rv = RevealUsingShell();
89731:     if (NS_FAILED(rv)) {
89731:       rv = RevealClassic();
89731:     }
89731: 
89731:     return rv;
89731: }
89731: 
89731: nsresult
89731: nsLocalFile::RevealClassic()
89731: {
89731:   // use the full path to explorer for security
89731:   nsCOMPtr<nsILocalFile> winDir;
89731:   nsresult rv = GetSpecialSystemDirectory(Win_WindowsDirectory, getter_AddRefs(winDir));
89731:   NS_ENSURE_SUCCESS(rv, rv);
89731:   nsAutoString explorerPath;
89731:   rv = winDir->GetPath(explorerPath);  
89731:   NS_ENSURE_SUCCESS(rv, rv);
89731:   explorerPath.AppendLiteral("\\explorer.exe");
89731: 
89731:   // Always open a new window for files because Win2K doesn't appear to select
89731:   // the file if a window showing that folder was already open. If the resolved 
89731:   // path is a directory then instead of opening the parent and selecting it, 
89731:   // we open the directory itself.
89731:   nsAutoString explorerParams;
89731:   if (mFileInfo64.type != PR_FILE_DIRECTORY) // valid because we ResolveAndStat above
89731:     explorerParams.AppendLiteral("/n,/select,");
89731:   explorerParams.Append(L'\"');
89731:   explorerParams.Append(mResolvedPath);
89731:   explorerParams.Append(L'\"');
89731: 
89731:   if (::ShellExecuteW(NULL, L"open", explorerPath.get(), explorerParams.get(),
89731:     NULL, SW_SHOWNORMAL) <= (HINSTANCE) 32)
89731:     return NS_ERROR_FAILURE;
89731: 
89731:   return NS_OK;
89731: }
89731: 
89731: nsresult 
89731: nsLocalFile::RevealUsingShell()
89731: {
89731:   // All of these shell32.dll related pointers should be non NULL 
89731:   // on XP and later.
89731:   if (!sILCreateFromPathW || !sSHOpenFolderAndSelectItems) {
89731:     return NS_ERROR_FAILURE;
89731:   }
89731: 
89731:   bool isDirectory;
89731:   nsresult rv = IsDirectory(&isDirectory);
89731:   NS_ENSURE_SUCCESS(rv, rv);
89731: 
78046:   HRESULT hr;
78046:   if (isDirectory) {
78046:     // We have a directory so we should open the directory itself.
89731:     ITEMIDLIST *dir = sILCreateFromPathW(mResolvedPath.get());
78046:     if (!dir) {
78046:       return NS_ERROR_FAILURE;
78046:     }
78046: 
78046:     const ITEMIDLIST* selection[] = { dir };
80742:     UINT count = ArrayLength(selection);
78046: 
78046:     //Perform the open of the directory.
89731:     hr = sSHOpenFolderAndSelectItems(dir, count, selection, 0);
78196:     CoTaskMemFree(dir);
78046:   }
78046:   else {
78046:     // Obtain the parent path of the item we are revealing.
78046:     nsCOMPtr<nsIFile> parentDirectory;
78046:     rv = GetParent(getter_AddRefs(parentDirectory));
78046:     NS_ENSURE_SUCCESS(rv, rv);
78046:     nsAutoString parentDirectoryPath;
78046:     rv = parentDirectory->GetPath(parentDirectoryPath);
78046:     NS_ENSURE_SUCCESS(rv, rv);
78046: 
78046:     // We have a file so we should open the parent directory.
89731:     ITEMIDLIST *dir = sILCreateFromPathW(parentDirectoryPath.get());
78046:     if (!dir) {
78046:       return NS_ERROR_FAILURE;
78046:     }
78046: 
78046:     // Set the item in the directory to select to the file we want to reveal.
89731:     ITEMIDLIST *item = sILCreateFromPathW(mResolvedPath.get());
78046:     if (!item) {
78196:       CoTaskMemFree(dir);
78046:       return NS_ERROR_FAILURE;
78046:     }
78046:     
78046:     const ITEMIDLIST* selection[] = { item };
80742:     UINT count = ArrayLength(selection);
78046: 
78046:     //Perform the selection of the file.
89731:     hr = sSHOpenFolderAndSelectItems(dir, count, selection, 0);
78046: 
78196:     CoTaskMemFree(dir);
78196:     CoTaskMemFree(item);
78046:   }
78046:   
78046:   if (SUCCEEDED(hr)) {
78046:     return NS_OK;
78046:   }
78046:   else {
78046:     return NS_ERROR_FAILURE;
78046:   }
78046: }
78046: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Launch()
    1: {
    1:     const nsString &path = mWorkingPath;
    1:     
    1:     // use the app registry name to launch a shell execute....
22244:     SHELLEXECUTEINFOW seinfo;
22244:     memset(&seinfo, 0, sizeof(seinfo));
22244:     seinfo.cbSize = sizeof(SHELLEXECUTEINFOW);
22244:     seinfo.fMask  = NULL;
22244:     seinfo.hwnd   = NULL;
22244:     seinfo.lpVerb = NULL;
22244:     seinfo.lpFile = path.get();
22244:     seinfo.lpParameters =  NULL;
22244:     seinfo.lpDirectory  = NULL;
22244:     seinfo.nShow  = SW_SHOWNORMAL;
22244:     
22244:     if (ShellExecuteExW(&seinfo))
22244:         return NS_OK;
22244:     DWORD r = GetLastError();
    1:     // if the file has no association, we launch windows' "what do you want to do" dialog
    1:     if (r == SE_ERR_NOASSOC) {
    1:         nsAutoString shellArg;
    1:         shellArg.Assign(NS_LITERAL_STRING("shell32.dll,OpenAs_RunDLL ") + path);
22244:         seinfo.lpFile = L"RUNDLL32.EXE";
22244:         seinfo.lpParameters = shellArg.get();
22244:         if (ShellExecuteExW(&seinfo))
22244:             return NS_OK;
22244:         r = GetLastError();
    1:     }
    1:     if (r < 32) {
    1:         switch (r) {
    1:           case 0:
    1:           case SE_ERR_OOM:
    1:               return NS_ERROR_OUT_OF_MEMORY;
    1:           case ERROR_FILE_NOT_FOUND:
    1:               return NS_ERROR_FILE_NOT_FOUND;
    1:           case ERROR_PATH_NOT_FOUND:
    1:               return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1:           case ERROR_BAD_FORMAT:
    1:               return NS_ERROR_FILE_CORRUPTED;
    1:           case SE_ERR_ACCESSDENIED:
    1:               return NS_ERROR_FILE_ACCESS_DENIED;
    1:           case SE_ERR_ASSOCINCOMPLETE:
    1:           case SE_ERR_NOASSOC:
    1:               return NS_ERROR_UNEXPECTED;
    1:           case SE_ERR_DDEBUSY:
    1:           case SE_ERR_DDEFAIL:
    1:           case SE_ERR_DDETIMEOUT:
    1:               return NS_ERROR_NOT_AVAILABLE;
    1:           case SE_ERR_DLLNOTFOUND:
    1:               return NS_ERROR_FAILURE;
    1:           case SE_ERR_SHARE:
    1:               return NS_ERROR_FILE_IS_LOCKED;
    1:           default:
    1:               return NS_ERROR_FILE_EXECUTION_FAILED;
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
79445: NS_NewLocalFile(const nsAString &path, bool followLinks, nsILocalFile* *result)
    1: {
    1:     nsLocalFile* file = new nsLocalFile();
    1:     if (file == nsnull)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(file);
    1:     
    1:     file->SetFollowLinks(followLinks);
    1: 
    1:     if (!path.IsEmpty()) {
    1:         nsresult rv = file->InitWithPath(path);
    1:         if (NS_FAILED(rv)) {
    1:             NS_RELEASE(file);
    1:             return rv;
    1:         }
    1:     }
    1: 
    1:     *result = file;
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // Native (lossy) interface
    1: //-----------------------------------------------------------------------------
    1:   
    1: NS_IMETHODIMP
    1: nsLocalFile::InitWithNativePath(const nsACString &filePath)
    1: {
    1:    nsAutoString tmp;
    1:    nsresult rv = NS_CopyNativeToUnicode(filePath, tmp);
    1:    if (NS_SUCCEEDED(rv))
    1:        return InitWithPath(tmp);
    1: 
    1:    return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::AppendNative(const nsACString &node)
    1: {
    1:     nsAutoString tmp;
    1:     nsresult rv = NS_CopyNativeToUnicode(node, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return Append(tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::AppendRelativeNativePath(const nsACString &node)
    1: {
    1:     nsAutoString tmp;
    1:     nsresult rv = NS_CopyNativeToUnicode(node, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return AppendRelativePath(tmp);
    1:     return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetNativeLeafName(nsACString &aLeafName)
    1: {
    1:     //NS_WARNING("This API is lossy. Use GetLeafName !");
    1:     nsAutoString tmp;
    1:     nsresult rv = GetLeafName(tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         rv = NS_CopyUnicodeToNative(tmp, aLeafName);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetNativeLeafName(const nsACString &aLeafName)
    1: {
    1:     nsAutoString tmp;
    1:     nsresult rv = NS_CopyNativeToUnicode(aLeafName, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return SetLeafName(tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetNativePath(nsACString &_retval)
    1: {
    1:     //NS_WARNING("This API is lossy. Use GetPath !");
    1:     nsAutoString tmp;
    1:     nsresult rv = GetPath(tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         rv = NS_CopyUnicodeToNative(tmp, _retval);
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetNativeCanonicalPath(nsACString &aResult)
    1: {
34850:     NS_WARNING("This method is lossy. Use GetCanonicalPath !");
    1:     EnsureShortPath();
    1:     NS_CopyUnicodeToNative(mShortWorkingPath, aResult);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::CopyToNative(nsIFile *newParentDir, const nsACString &newName)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     if (newName.IsEmpty())
    1:         return CopyTo(newParentDir, EmptyString());
    1: 
    1:     nsAutoString tmp;
    1:     nsresult rv = NS_CopyNativeToUnicode(newName, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return CopyTo(newParentDir, tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::CopyToFollowingLinksNative(nsIFile *newParentDir, const nsACString &newName)
    1: {
    1:     if (newName.IsEmpty())
    1:         return CopyToFollowingLinks(newParentDir, EmptyString());
    1: 
    1:     nsAutoString tmp;
    1:     nsresult rv = NS_CopyNativeToUnicode(newName, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return CopyToFollowingLinks(newParentDir, tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::MoveToNative(nsIFile *newParentDir, const nsACString &newName)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     if (newName.IsEmpty())
    1:         return MoveTo(newParentDir, EmptyString());
    1: 
    1:     nsAutoString tmp;
    1:     nsresult rv = NS_CopyNativeToUnicode(newName, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return MoveTo(newParentDir, tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetNativeTarget(nsACString &_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_WARNING("This API is lossy. Use GetTarget !");
    1:     nsAutoString tmp;
    1:     nsresult rv = GetTarget(tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         rv = NS_CopyUnicodeToNative(tmp, _retval);
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
79445: NS_NewNativeLocalFile(const nsACString &path, bool followLinks, nsILocalFile* *result)
    1: {
    1:     nsAutoString buf;
    1:     nsresult rv = NS_CopyNativeToUnicode(path, buf);
    1:     if (NS_FAILED(rv)) {
    1:         *result = nsnull;
    1:         return rv;
    1:     }
    1:     return NS_NewLocalFile(buf, followLinks, result);
    1: }
    1: 
    1: void
    1: nsLocalFile::EnsureShortPath()
    1: {
    1:     if (!mShortWorkingPath.IsEmpty())
    1:         return;
69184: 
79474:     WCHAR shortPath[MAX_PATH + 1];
79474:     DWORD lengthNeeded = ::GetShortPathNameW(mWorkingPath.get(), shortPath,
80467:                                              ArrayLength(shortPath));
79474:     // If an error occurred then lengthNeeded is set to 0 or the length of the
79474:     // needed buffer including NULL termination.  If it succeeds the number of
79474:     // wide characters not including NULL termination is returned.
80467:     if (lengthNeeded != 0 && lengthNeeded < ArrayLength(shortPath))
79474:         mShortWorkingPath.Assign(shortPath);
    1:     else
    1:         mShortWorkingPath.Assign(mWorkingPath);
    1: }
    1: 
    1: // nsIHashable
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Equals(nsIHashable* aOther, bool *aResult)
    1: {
    1:     nsCOMPtr<nsIFile> otherfile(do_QueryInterface(aOther));
    1:     if (!otherfile) {
80486:         *aResult = false;
    1:         return NS_OK;
    1:     }
    1: 
    1:     return Equals(otherfile, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetHashCode(PRUint32 *aResult)
    1: {
    1:     // In order for short and long path names to hash to the same value we
    1:     // always hash on the short pathname.
    1:     EnsureShortPath();
    1: 
    1:     *aResult = HashString(mShortWorkingPath);
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile <static members>
    1: //-----------------------------------------------------------------------------
    1: 
    1: void
    1: nsLocalFile::GlobalInit()
    1: {
    1:     nsresult rv = NS_CreateShortcutResolver();
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Shortcut resolver could not be created");
89731: 
89731:     // shell32.dll should be loaded already, so we are not actually 
89731:     // loading the library here.
89731:     HMODULE hLibShell = GetModuleHandleW(L"shell32.dll");
89731:     if (hLibShell) {
89731:       // ILCreateFromPathW is available in XP and up.
89731:       sILCreateFromPathW = (ILCreateFromPathWPtr) 
89731:                             GetProcAddress(hLibShell, 
89731:                                            "ILCreateFromPathW");
89731: 
89731:       // SHOpenFolderAndSelectItems is available in XP and up.
89731:       sSHOpenFolderAndSelectItems = (SHOpenFolderAndSelectItemsPtr) 
89731:                                      GetProcAddress(hLibShell, 
89731:                                                     "SHOpenFolderAndSelectItems");
89731:     }
    1: }
    1: 
    1: void
    1: nsLocalFile::GlobalShutdown()
    1: {
    1:     NS_DestroyShortcutResolver();
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsDriveEnumerator, nsISimpleEnumerator)
    1: 
    1: nsDriveEnumerator::nsDriveEnumerator()
    1: {
    1: }
    1: 
    1: nsDriveEnumerator::~nsDriveEnumerator()
    1: {
    1: }
    1: 
    1: nsresult nsDriveEnumerator::Init()
    1: {
    1:     /* If the length passed to GetLogicalDriveStrings is smaller
    1:      * than the length of the string it would return, it returns
    1:      * the length required for the string. */
25555:     DWORD length = GetLogicalDriveStringsW(0, 0);
    1:     /* The string is null terminated */
    1:     if (!EnsureStringLength(mDrives, length+1))
    1:         return NS_ERROR_OUT_OF_MEMORY;
22235:     if (!GetLogicalDriveStringsW(length, mDrives.BeginWriting()))
    1:         return NS_ERROR_FAILURE;
25555:     mDrives.BeginReading(mStartOfCurrentDrive);
25555:     mDrives.EndReading(mEndOfDrivesString);
    1:     return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDriveEnumerator::HasMoreElements(bool *aHasMore)
    1: {
25555:     *aHasMore = *mStartOfCurrentDrive != L'\0';
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDriveEnumerator::GetNext(nsISupports **aNext)
    1: {
25555:     /* GetLogicalDrives stored in mDrives is a concatenation
25555:      * of null terminated strings, followed by a null terminator.
25555:      * mStartOfCurrentDrive is an iterator pointing at the first
25555:      * character of the current drive. */
25555:     if (*mStartOfCurrentDrive == L'\0') {
    1:         *aNext = nsnull;
    1:         return NS_OK;
    1:     }
25555: 
25555:     nsAString::const_iterator driveEnd = mStartOfCurrentDrive;
25555:     FindCharInReadable(L'\0', driveEnd, mEndOfDrivesString);
25555:     nsString drive(Substring(mStartOfCurrentDrive, driveEnd));
25555:     mStartOfCurrentDrive = ++driveEnd;
25555: 
    1:     nsILocalFile *file;
80486:     nsresult rv = NS_NewLocalFile(drive, false, &file);
    1: 
    1:     *aNext = file;
    1:     return rv;
    1: }
