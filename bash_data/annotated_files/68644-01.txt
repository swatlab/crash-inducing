 3410: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Code.
    1:  *
    1:  * The Initial Developer of the Original Code is
57116:  * the Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Jonas Sicking <jonas@sicking.cc> (original developer)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsScriptElement.h"
51350: #include "mozilla/dom/Element.h"
 3439: #include "nsContentUtils.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsPresContext.h"
    1: #include "nsScriptLoader.h"
    1: #include "nsIParser.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsGkAtoms.h"
58891: #include "nsContentSink.h"
    1: 
51350: using namespace mozilla::dom;
51350: 
    1: NS_IMETHODIMP
    1: nsScriptElement::ScriptAvailable(nsresult aResult,
    1:                                  nsIScriptElement *aElement,
    1:                                  PRBool aIsInline,
    1:                                  nsIURI *aURI,
    1:                                  PRInt32 aLineNo)
    1: {
    1:   if (!aIsInline && NS_FAILED(aResult)) {
    1:     nsCOMPtr<nsIContent> cont =
    1:       do_QueryInterface((nsIScriptElement*) this);
    1: 
39823:     nsRefPtr<nsPresContext> presContext =
 3439:       nsContentUtils::GetContextForContent(cont);
    1: 
    1:     nsEventStatus status = nsEventStatus_eIgnore;
    1:     nsScriptErrorEvent event(PR_TRUE, NS_LOAD_ERROR);
    1: 
    1:     event.lineNr = aLineNo;
    1: 
    1:     NS_NAMED_LITERAL_STRING(errorString, "Error loading script");
    1:     event.errorMsg = errorString.get();
    1: 
    1:     nsCAutoString spec;
    1:     aURI->GetSpec(spec);
    1: 
    1:     NS_ConvertUTF8toUTF16 fileName(spec);
    1:     event.fileName = fileName.get();
    1: 
    1:     nsEventDispatcher::Dispatch(cont, presContext, &event, nsnull, &status);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptElement::ScriptEvaluated(nsresult aResult,
    1:                                  nsIScriptElement *aElement,
    1:                                  PRBool aIsInline)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (!aIsInline) {
    1:     nsCOMPtr<nsIContent> cont =
    1:       do_QueryInterface((nsIScriptElement*) this);
    1: 
39823:     nsRefPtr<nsPresContext> presContext =
 3439:       nsContentUtils::GetContextForContent(cont);
    1: 
    1:     nsEventStatus status = nsEventStatus_eIgnore;
    1:     PRUint32 type = NS_SUCCEEDED(aResult) ? NS_LOAD : NS_LOAD_ERROR;
    1:     nsEvent event(PR_TRUE, type);
    1:     if (type == NS_LOAD) {
    1:       // Load event doesn't bubble.
    1:       event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
    1:     }
    1: 
    1:     nsEventDispatcher::Dispatch(cont, presContext, &event, nsnull, &status);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsScriptElement::CharacterDataChanged(nsIDocument *aDocument,
    1:                                       nsIContent* aContent,
    1:                                       CharacterDataChangeInfo* aInfo)
    1: {
    1:   MaybeProcessScript();
    1: }
    1: 
    1: void
    1: nsScriptElement::AttributeChanged(nsIDocument* aDocument,
51350:                                   Element* aElement,
    1:                                   PRInt32 aNameSpaceID,
    1:                                   nsIAtom* aAttribute,
35535:                                   PRInt32 aModType)
    1: {
    1:   MaybeProcessScript();
    1: }
    1: 
    1: void
    1: nsScriptElement::ContentAppended(nsIDocument* aDocument,
    1:                                  nsIContent* aContainer,
42107:                                  nsIContent* aFirstNewContent,
    1:                                  PRInt32 aNewIndexInContainer)
    1: {
    1:   MaybeProcessScript();
    1: }
    1: 
    1: void
    1: nsScriptElement::ContentInserted(nsIDocument *aDocument,
    1:                                  nsIContent* aContainer,
    1:                                  nsIContent* aChild,
    1:                                  PRInt32 aIndexInContainer)
    1: {
    1:   MaybeProcessScript();
    1: }
    1: 
    1: nsresult
    1: nsScriptElement::MaybeProcessScript()
    1: {
    1:   nsCOMPtr<nsIContent> cont =
    1:     do_QueryInterface((nsIScriptElement*) this);
    1: 
    1:   NS_ASSERTION(cont->DebugGetSlots()->mMutationObservers.Contains(this),
    1:                "You forgot to add self as observer");
    1: 
54758:   if (mAlreadyStarted || !mDoneAddingChildren || !cont->IsInDoc() ||
23652:       mMalformed || !HasScriptContent()) {
23652:     return NS_OK;
23652:   }
23652: 
35606:   FreezeUriAsyncDefer();
35606: 
54758:   mAlreadyStarted = PR_TRUE;
58891: 
58891:   nsIDocument* ownerDoc = cont->GetOwnerDoc();
58891:   nsCOMPtr<nsIParser> parser = ((nsIScriptElement*) this)->GetCreatorParser();
58891:   if (parser) {
68644:     nsCOMPtr<nsIContentSink> sink = parser->GetContentSink();
68644:     if (sink) {
68644:       nsCOMPtr<nsIDocument> parserDoc = do_QueryInterface(sink->GetTarget());
58891:       if (ownerDoc != parserDoc) {
58891:         // Willful violation of HTML5 as of 2010-12-01
58891:         return NS_OK;
58891:       }
58891:     }
68644:   }
58891: 
58891:   nsRefPtr<nsScriptLoader> loader = ownerDoc->ScriptLoader();
57116:   nsresult scriptresult = loader->ProcessScriptElement(this);
    1: 
    1:   // The only error we don't ignore is NS_ERROR_HTMLPARSER_BLOCK
    1:   // However we don't want to override other success values
    1:   // (such as NS_CONTENT_SCRIPT_IS_EVENTHANDLER)
    1:   if (NS_FAILED(scriptresult) &&
    1:       scriptresult != NS_ERROR_HTMLPARSER_BLOCK) {
    1:     scriptresult = NS_OK;
    1:   }
    1: 
    1:   return scriptresult;
    1: }
