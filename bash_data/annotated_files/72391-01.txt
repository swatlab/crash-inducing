72260: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
72260: /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
72260: /* ***** BEGIN LICENSE BLOCK *****
72260:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
72260:  *
72260:  * The contents of this file are subject to the Mozilla Public License Version
72260:  * 1.1 (the "License"); you may not use this file except in compliance with
72260:  * the License. You may obtain a copy of the License at
72260:  * http://www.mozilla.org/MPL/
72260:  *
72260:  * Software distributed under the License is distributed on an "AS IS" basis,
72260:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
72260:  * for the specific language governing rights and limitations under the
72260:  * License.
72260:  *
72260:  * The Original Code is an implementation of CSS3 text-overflow.
72260:  *
72260:  * The Initial Developer of the Original Code is the Mozilla Foundation.
72260:  * Portions created by the Initial Developer are Copyright (C) 2011
72260:  * the Initial Developer. All Rights Reserved.
72260:  *
72260:  * Contributor(s):
72260:  *   Mats Palmgren <matspal@gmail.com> (original author)
72260:  *
72260:  * Alternatively, the contents of this file may be used under the terms of
72260:  * either the GNU General Public License Version 2 or later (the "GPL"), or
72260:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
72260:  * in which case the provisions of the GPL or the LGPL are applicable instead
72260:  * of those above. If you wish to allow use of your version of this file only
72260:  * under the terms of either the GPL or the LGPL, and not to allow others to
72260:  * use your version of this file under the terms of the MPL, indicate your
72260:  * decision by deleting the provisions above and replace them with the notice
72260:  * and other provisions required by the GPL or the LGPL. If you do not delete
72260:  * the provisions above, a recipient may use your version of this file under
72260:  * the terms of any one of the MPL, the GPL or the LGPL.
72260:  *
72260:  * ***** END LICENSE BLOCK ***** */
72260: 
72260: #include "TextOverflow.h"
72260: 
72260: // Please maintain alphabetical order below
72260: #include "nsBlockFrame.h"
72260: #include "nsCaret.h"
72260: #include "nsContentUtils.h"
72260: #include "nsIScrollableFrame.h"
72260: #include "nsLayoutUtils.h"
72260: #include "nsPresContext.h"
72260: #include "nsRect.h"
72260: #include "nsRenderingContext.h"
72260: #include "nsTextFrame.h"
72260: 
72260: namespace mozilla {
72260: namespace css {
72260: 
72260: static const PRUnichar kEllipsisChar[] = { 0x2026, 0x0 };
72260: static const PRUnichar kASCIIPeriodsChar[] = { '.', '.', '.', 0x0 };
72260: 
72260: // Return an ellipsis if the font supports it,
72260: // otherwise use three ASCII periods as fallback.
72260: static nsDependentString GetEllipsis(nsIFrame* aFrame)
72260: {
72260:   // Check if the first font supports Unicode ellipsis.
72260:   nsRefPtr<nsFontMetrics> fm;
72260:   nsLayoutUtils::GetFontMetricsForFrame(aFrame, getter_AddRefs(fm));
72260:   gfxFontGroup* fontGroup = fm->GetThebesFontGroup();
72260:   gfxFont* firstFont = fontGroup->GetFontAt(0);
72260:   return firstFont && firstFont->HasCharacter(kEllipsisChar[0])
72260:     ? nsDependentString(kEllipsisChar,
72260:                         NS_ARRAY_LENGTH(kEllipsisChar) - 1)
72260:     : nsDependentString(kASCIIPeriodsChar,
72260:                         NS_ARRAY_LENGTH(kASCIIPeriodsChar) - 1);
72260: }
72260: 
72260: static nsIFrame*
72260: GetSelfOrNearestBlock(nsIFrame* aFrame)
72260: {
72260:   return nsLayoutUtils::GetAsBlock(aFrame) ? aFrame :
72260:          nsLayoutUtils::FindNearestBlockAncestor(aFrame);
72260: }
72260: 
72260: // Return true if the frame is an atomic inline-level element.
72260: // It's not supposed to be called for block frames since we never
72260: // process block descendants for text-overflow.
72260: static bool
72260: IsAtomicElement(nsIFrame* aFrame, const nsIAtom* aFrameType)
72260: {
72260:   NS_PRECONDITION(!aFrame->GetStyleDisplay()->IsBlockOutside(),
72260:                   "unexpected block frame");
72260: 
72260:   if (aFrame->IsFrameOfType(nsIFrame::eReplaced)) {
72260:     if (aFrameType != nsGkAtoms::textFrame &&
72260:         aFrameType != nsGkAtoms::brFrame) {
72260:       return true;
72260:     }
72260:   }
72260:   return aFrame->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_INLINE;
72260: }
72260: 
72260: static bool
72260: IsFullyClipped(nsTextFrame* aFrame, nscoord aLeft, nscoord aRight,
72260:                nscoord* aSnappedLeft, nscoord* aSnappedRight)
72260: {
72260:   *aSnappedLeft = aLeft;
72260:   *aSnappedRight = aRight;
72260:   if (aLeft <= 0 && aRight <= 0) {
72260:     return false;
72260:   }
72260:   nsRefPtr<nsRenderingContext> rc =
72260:     aFrame->PresContext()->PresShell()->GetReferenceRenderingContext();
72260:   return rc &&
72260:     !aFrame->MeasureCharClippedText(rc->ThebesContext(), aLeft, aRight,
72260:                                     aSnappedLeft, aSnappedRight);
72260: }
72260: 
72260: static bool
72260: IsHorizontalOverflowVisible(nsIFrame* aFrame)
72260: {
72260:   NS_PRECONDITION(nsLayoutUtils::GetAsBlock(aFrame) != nsnull,
72260:                   "expected a block frame");
72260: 
72260:   nsIFrame* f = aFrame;
72260:   while (f && f->GetStyleContext()->GetPseudo()) {
72260:     f = f->GetParent();
72260:   }
72260:   return !f || f->GetStyleDisplay()->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE;
72260: }
72260: 
72260: static nsDisplayItem*
72260: ClipMarker(nsDisplayListBuilder* aBuilder,
72260:            nsIFrame*             aFrame,
72260:            nsDisplayItem*        aMarker,
72260:            const nsRect&         aContentArea,
72260:            nsRect*               aMarkerRect)
72260: {
72260:   nsDisplayItem* item = aMarker;
72260:   nscoord rightOverflow = aMarkerRect->XMost() - aContentArea.XMost();
72260:   if (rightOverflow > 0) {
72260:     // Marker overflows on the right side (content width < marker width).
72260:     aMarkerRect->width -= rightOverflow;
72260:     item = new (aBuilder)
72260:       nsDisplayClip(aBuilder, aFrame, aMarker, *aMarkerRect);
72260:   } else {
72260:     nscoord leftOverflow = aContentArea.x - aMarkerRect->x;
72260:     if (leftOverflow > 0) {
72260:       // Marker overflows on the left side
72260:       aMarkerRect->width -= leftOverflow;
72260:       aMarkerRect->x += leftOverflow;
72260:       item = new (aBuilder)
72260:         nsDisplayClip(aBuilder, aFrame, aMarker, *aMarkerRect);
72260:     }
72260:   }
72260:   return item;
72260: }
72260: 
72260: static void
72260: InflateLeft(nsRect* aRect, bool aInfinity, nscoord aDelta)
72260: {
72260:   nscoord xmost = aRect->XMost();
72260:   if (aInfinity) {
72260:     aRect->x = nscoord_MIN;
72260:   } else {
72260:     aRect->x -= aDelta;
72260:   }
72260:   aRect->width = NS_MAX(xmost - aRect->x, 0);
72260: }
72260: 
72260: static void
72260: InflateRight(nsRect* aRect, bool aInfinity, nscoord aDelta)
72260: {
72260:   if (aInfinity) {
72260:     aRect->width = nscoord_MAX;
72260:   } else {
72260:     aRect->width = NS_MAX(aRect->width + aDelta, 0);
72260:   }
72260: }
72260: 
72260: static bool
72260: IsFrameDescendantOfAny(nsIFrame* aChild,
72260:                        const TextOverflow::FrameHashtable& aSetOfFrames,
72260:                        nsIFrame* aCommonAncestor)
72260: {
72391:   for (nsIFrame* f = aChild; f && f != aCommonAncestor;
72260:        f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
72260:     if (aSetOfFrames.GetEntry(f)) {
72260:       return true;
72260:     }
72260:   }
72260:   return false;
72260: }
72260: 
72260: class nsDisplayTextOverflowMarker : public nsDisplayItem
72260: {
72260: public:
72260:   nsDisplayTextOverflowMarker(nsDisplayListBuilder* aBuilder, nsIFrame* aFrame,
72260:                               const nsRect& aRect, nscoord aAscent,
72260:                               const nsString& aString)
72260:     : nsDisplayItem(aBuilder, aFrame), mRect(aRect), mString(aString),
72260:       mAscent(aAscent) {
72260:     MOZ_COUNT_CTOR(nsDisplayTextOverflowMarker);
72260:   }
72260: #ifdef NS_BUILD_REFCNT_LOGGING
72260:   virtual ~nsDisplayTextOverflowMarker() {
72260:     MOZ_COUNT_DTOR(nsDisplayTextOverflowMarker);
72260:   }
72260: #endif
72260:   virtual nsRect GetBounds(nsDisplayListBuilder* aBuilder) {
72260:     return mRect;
72260:   }
72260:   virtual void Paint(nsDisplayListBuilder* aBuilder,
72260:                      nsRenderingContext* aCtx);
72260:   NS_DISPLAY_DECL_NAME("TextOverflow", TYPE_TEXT_OVERFLOW)
72260: private:
72260:   nsRect          mRect;   // in reference frame coordinates
72260:   const nsString  mString; // the marker text
72260:   nscoord         mAscent; // baseline for the marker text in mRect
72260: };
72260: 
72260: void
72260: nsDisplayTextOverflowMarker::Paint(nsDisplayListBuilder* aBuilder,
72260:                                    nsRenderingContext*   aCtx)
72260: {
72260:   nsStyleContext* sc = mFrame->GetStyleContext();
72260:   nsLayoutUtils::SetFontFromStyle(aCtx, sc);
72260:   aCtx->SetColor(nsLayoutUtils::GetTextColor(mFrame));
72260:   nsPoint baselinePt = mRect.TopLeft();
72260:   baselinePt.y += mAscent;
72260:   nsLayoutUtils::DrawString(mFrame, aCtx, mString.get(), mString.Length(),
72260:                             baselinePt);
72260: }
72260: 
72260: /* static */ TextOverflow*
72260: TextOverflow::WillProcessLines(nsDisplayListBuilder*   aBuilder,
72260:                                const nsDisplayListSet& aLists,
72260:                                nsIFrame*               aBlockFrame)
72260: {
72260:   if (!CanHaveTextOverflow(aBuilder, aBlockFrame)) {
72260:     return nsnull;
72260:   }
72260: 
72260:   nsAutoPtr<TextOverflow> textOverflow(new TextOverflow);
72260:   textOverflow->mBuilder = aBuilder;
72260:   textOverflow->mBlock = aBlockFrame;
72260:   textOverflow->mMarkerList = aLists.PositionedDescendants();
72260:   textOverflow->mContentArea = aBlockFrame->GetContentRectRelativeToSelf();
72260:   nsIScrollableFrame* scroll =
72260:     nsLayoutUtils::GetScrollableFrameFor(aBlockFrame);
72260:   textOverflow->mCanHaveHorizontalScrollbar = false;
72260:   if (scroll) {
72260:     textOverflow->mCanHaveHorizontalScrollbar =
72260:       scroll->GetScrollbarStyles().mHorizontal != NS_STYLE_OVERFLOW_HIDDEN;
72260:     textOverflow->mContentArea.MoveBy(scroll->GetScrollPosition());
72260:   }
72260:   textOverflow->mBlockIsRTL =
72260:     aBlockFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
72260:   const nsStyleTextReset* style = aBlockFrame->GetStyleTextReset();
72260:   textOverflow->mLeft.Init(style->mTextOverflow);
72260:   textOverflow->mRight.Init(style->mTextOverflow);
72260:   // The left/right marker string is setup in ExamineLineFrames when a line
72260:   // has overflow on that side.
72260: 
72260:   return textOverflow.forget();
72260: }
72260: 
72260: void
72260: TextOverflow::DidProcessLines()
72260: {
72260:   nsIScrollableFrame* scroll = nsLayoutUtils::GetScrollableFrameFor(mBlock);
72260:   if (scroll) {
72260:     // Create a dummy item covering the entire area, it doesn't paint
72260:     // but reports true for IsVaryingRelativeToMovingFrame().
72260:     nsIFrame* scrollFrame = do_QueryFrame(scroll);
72260:     nsDisplayItem* marker = new (mBuilder)
72260:       nsDisplayForcePaintOnScroll(mBuilder, scrollFrame);
72260:     if (marker) {
72260:       mMarkerList->AppendNewToBottom(marker);
72260:       mBlock->PresContext()->SetHasFixedBackgroundFrame();
72260:     }
72260:   }
72260: }
72260: 
72260: void
72260: TextOverflow::ExamineFrameSubtree(nsIFrame*       aFrame,
72260:                                   const nsRect&   aContentArea,
72260:                                   const nsRect&   aInsideMarkersArea,
72260:                                   FrameHashtable* aFramesToHide,
72260:                                   AlignmentEdges* aAlignmentEdges)
72260: {
72260:   const nsIAtom* frameType = aFrame->GetType();
72260:   if (frameType == nsGkAtoms::brFrame) {
72260:     return;
72260:   }
72260:   const bool isAtomic = IsAtomicElement(aFrame, frameType);
72260:   if (aFrame->GetStyleVisibility()->IsVisible()) {
72260:     nsRect childRect = aFrame->GetScrollableOverflowRect() +
72260:                        aFrame->GetOffsetTo(mBlock);
72260:     bool overflowLeft = childRect.x < aContentArea.x;
72260:     bool overflowRight = childRect.XMost() > aContentArea.XMost();
72260:     if (overflowLeft) {
72260:       mLeft.mHasOverflow = true;
72260:     }
72260:     if (overflowRight) {
72260:       mRight.mHasOverflow = true;
72260:     }
72260:     if (isAtomic && (overflowLeft || overflowRight)) {
72260:       aFramesToHide->PutEntry(aFrame);
72260:     } else if (isAtomic || frameType == nsGkAtoms::textFrame) {
72260:       AnalyzeMarkerEdges(aFrame, frameType, aInsideMarkersArea,
72260:                          aFramesToHide, aAlignmentEdges);
72260:     }
72260:   }
72260:   if (isAtomic) {
72260:     return;
72260:   }
72260: 
72260:   nsIFrame* child = aFrame->GetFirstChild(nsnull);
72260:   while (child) {
72260:     ExamineFrameSubtree(child, aContentArea, aInsideMarkersArea,
72260:                         aFramesToHide, aAlignmentEdges);
72260:     child = child->GetNextSibling();
72260:   }
72260: }
72260: 
72260: void
72260: TextOverflow::AnalyzeMarkerEdges(nsIFrame*       aFrame,
72260:                                  const nsIAtom*  aFrameType,
72260:                                  const nsRect&   aInsideMarkersArea,
72260:                                  FrameHashtable* aFramesToHide,
72260:                                  AlignmentEdges* aAlignmentEdges)
72260: {
72260:   nsRect borderRect(aFrame->GetOffsetTo(mBlock), aFrame->GetSize());
72260:   nscoord leftOverlap =
72260:     NS_MAX(aInsideMarkersArea.x - borderRect.x, 0);
72260:   nscoord rightOverlap =
72260:     NS_MAX(borderRect.XMost() - aInsideMarkersArea.XMost(), 0);
72260:   bool insideLeftEdge = aInsideMarkersArea.x <= borderRect.XMost();
72260:   bool insideRightEdge = borderRect.x <= aInsideMarkersArea.XMost();
72260: 
72260:   if ((leftOverlap > 0 && insideLeftEdge) ||
72260:       (rightOverlap > 0 && insideRightEdge)) {
72260:     if (aFrameType == nsGkAtoms::textFrame &&
72260:         aInsideMarkersArea.x < aInsideMarkersArea.XMost()) {
72260:       // a clipped text frame and there is some room between the markers
72260:       nscoord snappedLeft, snappedRight;
72260:       bool isFullyClipped =
72260:         IsFullyClipped(static_cast<nsTextFrame*>(aFrame),
72260:                        leftOverlap, rightOverlap, &snappedLeft, &snappedRight);
72260:       if (!isFullyClipped) {
72260:         nsRect snappedRect = borderRect;
72260:         if (leftOverlap > 0) {
72260:           snappedRect.x += snappedLeft;
72260:           snappedRect.width -= snappedLeft;
72260:         }
72260:         if (rightOverlap > 0) {
72260:           snappedRect.width -= snappedRight;
72260:         }
72260:         aAlignmentEdges->Accumulate(snappedRect);
72260:       }
72260:     } else if (IsAtomicElement(aFrame, aFrameType)) {
72260:       aFramesToHide->PutEntry(aFrame);
72260:     }
72260:   } else if (!insideLeftEdge || !insideRightEdge) {
72260:     // frame is outside
72260:     if (IsAtomicElement(aFrame, aFrameType)) {
72260:       aFramesToHide->PutEntry(aFrame);
72260:     }
72260:   } else {
72260:     // frame is inside
72260:     aAlignmentEdges->Accumulate(borderRect);
72260:   }
72260: }
72260: 
72260: void
72260: TextOverflow::ExamineLineFrames(nsLineBox*      aLine,
72260:                                 FrameHashtable* aFramesToHide,
72260:                                 AlignmentEdges* aAlignmentEdges)
72260: {
72260:   // Scrolling to the end position can leave some text still overflowing due to
72260:   // pixel snapping behaviour in our scrolling code so we move the edges 1px
72260:   // outward to avoid triggering a text-overflow marker for such overflow.
72260:   nsRect contentArea = mContentArea;
72260:   const nscoord scrollAdjust = mCanHaveHorizontalScrollbar ?
72260:     mBlock->PresContext()->AppUnitsPerDevPixel() : 0;
72260:   InflateLeft(&contentArea,
72260:               mLeft.mStyle->mType == NS_STYLE_TEXT_OVERFLOW_CLIP,
72260:               scrollAdjust);
72260:   InflateRight(&contentArea,
72260:                mRight.mStyle->mType == NS_STYLE_TEXT_OVERFLOW_CLIP,
72260:                scrollAdjust);
72260:   nsRect lineRect = aLine->GetScrollableOverflowArea();
72260:   const bool leftOverflow = lineRect.x < contentArea.x;
72260:   const bool rightOverflow = lineRect.XMost() > contentArea.XMost();
72260:   if (!leftOverflow && !rightOverflow) {
72260:     // The line does not overflow - no need to traverse the frame tree.
72260:     return;
72260:   }
72260: 
72260:   PRUint32 pass = 0;
72260:   bool guessLeft =
72260:     mLeft.mStyle->mType != NS_STYLE_TEXT_OVERFLOW_CLIP && leftOverflow;
72260:   bool guessRight =
72260:     mRight.mStyle->mType != NS_STYLE_TEXT_OVERFLOW_CLIP && rightOverflow;
72260:   do {
72260:     // Setup marker strings as needed.
72260:     if (guessLeft || guessRight) {
72260:       mLeft.SetupString(mBlock);
72260:       mRight.mMarkerString = mLeft.mMarkerString;
72260:       mRight.mWidth = mLeft.mWidth;
72260:       mRight.mInitialized = mLeft.mInitialized;
72260:     }
72260:     
72260:     // If there is insufficient space for both markers then keep the one on the
72260:     // end side per the block's 'direction'.
72260:     nscoord rightMarkerWidth = mRight.mWidth;
72260:     nscoord leftMarkerWidth = mLeft.mWidth;
72260:     if (leftOverflow && rightOverflow &&
72260:         leftMarkerWidth + rightMarkerWidth > contentArea.width) {
72260:       if (mBlockIsRTL) {
72260:         rightMarkerWidth = 0;
72260:       } else {
72260:         leftMarkerWidth = 0;
72260:       }
72260:     }
72260: 
72260:     // Calculate the area between the potential markers aligned at the
72260:     // block's edge.
72260:     nsRect insideMarkersArea = mContentArea;
72260:     InflateLeft(&insideMarkersArea, !guessLeft, -leftMarkerWidth);
72260:     InflateRight(&insideMarkersArea, !guessRight, -rightMarkerWidth);
72260: 
72260:     // Analyze the frames on aLine for the overflow situation at the content
72260:     // edges and at the edges of the area between the markers.
72260:     PRInt32 n = aLine->GetChildCount();
72260:     nsIFrame* child = aLine->mFirstChild;
72260:     for (; n-- > 0; child = child->GetNextSibling()) {
72260:       ExamineFrameSubtree(child, contentArea, insideMarkersArea,
72260:                           aFramesToHide, aAlignmentEdges);
72260:     }
72260:     if (guessLeft == mLeft.IsNeeded() && guessRight == mRight.IsNeeded()) {
72260:       break;
72260:     } else {
72260:       guessLeft = mLeft.IsNeeded();
72260:       guessRight = mRight.IsNeeded();
72260:       mLeft.Reset();
72260:       mRight.Reset();
72260:       aFramesToHide->Clear();
72260:     }
72260:     NS_ASSERTION(pass == 0, "2nd pass should never guess wrong");
72260:   } while (++pass != 2);
72260: }
72260: 
72260: void
72260: TextOverflow::ProcessLine(const nsDisplayListSet& aLists,
72260:                           nsLineBox*              aLine)
72260: {
72260:   NS_ASSERTION(mLeft.mStyle->mType != NS_STYLE_TEXT_OVERFLOW_CLIP ||
72260:                mRight.mStyle->mType != NS_STYLE_TEXT_OVERFLOW_CLIP,
72260:                "TextOverflow with 'clip' for both sides");
72260:   mLeft.Reset();
72260:   mRight.Reset();
72260:   FrameHashtable framesToHide;
72260:   if (!framesToHide.Init(100)) {
72260:     return;
72260:   }
72260:   AlignmentEdges alignmentEdges;
72260:   ExamineLineFrames(aLine, &framesToHide, &alignmentEdges);
72260:   bool needLeft = mLeft.IsNeeded();
72260:   bool needRight = mRight.IsNeeded();
72260:   if (!needLeft && !needRight) {
72260:     return;
72260:   }
72260:   NS_ASSERTION(mLeft.mStyle->mType != NS_STYLE_TEXT_OVERFLOW_CLIP ||
72260:                !needLeft, "left marker for 'clip'");
72260:   NS_ASSERTION(mRight.mStyle->mType != NS_STYLE_TEXT_OVERFLOW_CLIP ||
72260:                !needRight, "right marker for 'clip'");
72260: 
72260:   // If there is insufficient space for both markers then keep the one on the
72260:   // end side per the block's 'direction'.
72260:   if (needLeft && needRight &&
72260:       mLeft.mWidth + mRight.mWidth > mContentArea.width) {
72260:     if (mBlockIsRTL) {
72260:       needRight = false;
72260:     } else {
72260:       needLeft = false;
72260:     }
72260:   }
72260:   nsRect insideMarkersArea = mContentArea;
72260:   if (needLeft) {
72260:     InflateLeft(&insideMarkersArea, false, -mLeft.mWidth);
72260:   }
72260:   if (needRight) {
72260:     InflateRight(&insideMarkersArea, false, -mRight.mWidth);
72260:   }
72260:   if (!mCanHaveHorizontalScrollbar && alignmentEdges.mAssigned) {
72260:     nsRect alignmentRect = nsRect(alignmentEdges.x, insideMarkersArea.y,
72260:                                   alignmentEdges.Width(), 1);
72260:     insideMarkersArea.IntersectRect(insideMarkersArea, alignmentRect);
72260:   }
72260: 
72260:   // Clip and remove display items as needed at the final marker edges.
72260:   nsDisplayList* lists[] = { aLists.Content(), aLists.PositionedDescendants() };
72260:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(lists); ++i) {
72260:     PruneDisplayListContents(lists[i], framesToHide, insideMarkersArea);
72260:   }
72260:   CreateMarkers(aLine, needLeft, needRight, insideMarkersArea);
72260: }
72260: 
72260: void
72260: TextOverflow::PruneDisplayListContents(nsDisplayList*        aList,
72260:                                        const FrameHashtable& aFramesToHide,
72260:                                        const nsRect&         aInsideMarkersArea)
72260: {
72260:   nsDisplayList saved;
72260:   nsDisplayItem* item;
72260:   while ((item = aList->RemoveBottom())) {
72260:     nsIFrame* itemFrame = item->GetUnderlyingFrame();
72260:     if (itemFrame && IsFrameDescendantOfAny(itemFrame, aFramesToHide, mBlock)) {
72260:       item->~nsDisplayItem();
72260:       continue;
72260:     }
72260: 
72260:     nsDisplayList* wrapper = item->GetList();
72260:     if (wrapper) {
72260:       if (!itemFrame || GetSelfOrNearestBlock(itemFrame) == mBlock) {
72260:         PruneDisplayListContents(wrapper, aFramesToHide, aInsideMarkersArea);
72260:       }
72260:     }
72260: 
72260:     nsCharClipDisplayItem* charClip = itemFrame ? 
72260:       nsCharClipDisplayItem::CheckCast(item) : nsnull;
72260:     if (charClip && GetSelfOrNearestBlock(itemFrame) == mBlock) {
72260:       nsRect rect = itemFrame->GetScrollableOverflowRect() +
72260:                     itemFrame->GetOffsetTo(mBlock);
72260:       if (mLeft.IsNeeded() && rect.x < aInsideMarkersArea.x) {
72260:         charClip->mLeftEdge = aInsideMarkersArea.x - rect.x;
72260:       }
72260:       if (mRight.IsNeeded() && rect.XMost() > aInsideMarkersArea.XMost()) {
72260:         charClip->mRightEdge = rect.XMost() - aInsideMarkersArea.XMost();
72260:       }
72260:     }
72260: 
72260:     saved.AppendToTop(item);
72260:   }
72260:   aList->AppendToTop(&saved);
72260: }
72260: 
72260: /* static */ bool
72260: TextOverflow::CanHaveTextOverflow(nsDisplayListBuilder* aBuilder,
72260:                                   nsIFrame*             aBlockFrame)
72260: {
72260:   const nsStyleTextReset* style = aBlockFrame->GetStyleTextReset();
72260:   // Nothing to do for text-overflow:clip or if 'overflow-x:visible'
72260:   // or if we're just building items for event processing.
72260:   if ((style->mTextOverflow.mType == NS_STYLE_TEXT_OVERFLOW_CLIP) ||
72260:       IsHorizontalOverflowVisible(aBlockFrame) ||
72260:       aBuilder->IsForEventDelivery()) {
72260:     return false;
72260:   }
72260: 
72260:   // Inhibit the markers if a descendant content owns the caret.
72260:   nsRefPtr<nsCaret> caret = aBlockFrame->PresContext()->PresShell()->GetCaret();
72260:   PRBool visible = PR_FALSE;
72260:   if (caret && NS_SUCCEEDED(caret->GetCaretVisible(&visible)) && visible) {
72260:     nsCOMPtr<nsISelection> domSelection = caret->GetCaretDOMSelection();
72260:     if (domSelection) {
72260:       nsCOMPtr<nsIDOMNode> node;
72260:       domSelection->GetFocusNode(getter_AddRefs(node));
72260:       nsCOMPtr<nsIContent> content = do_QueryInterface(node);
72260:       if (content && nsContentUtils::ContentIsDescendantOf(content,
72260:                        aBlockFrame->GetContent())) {
72260:         return false;
72260:       }
72260:     }
72260:   }
72260:   return true;
72260: }
72260: 
72260: void
72260: TextOverflow::CreateMarkers(const nsLineBox* aLine,
72260:                             bool             aCreateLeft,
72260:                             bool             aCreateRight,
72260:                             const nsRect&    aInsideMarkersArea) const
72260: {
72260:   if (aCreateLeft) {
72260:     nsRect markerRect = nsRect(aInsideMarkersArea.x - mLeft.mWidth,
72260:                                aLine->mBounds.y,
72260:                                mLeft.mWidth, aLine->mBounds.height);
72260:     markerRect += mBuilder->ToReferenceFrame(mBlock);
72260:     nsDisplayItem* marker = new (mBuilder)
72260:       nsDisplayTextOverflowMarker(mBuilder, mBlock, markerRect,
72260:                                   aLine->GetAscent(), mLeft.mMarkerString);
72260:     if (marker) {
72260:       marker = ClipMarker(mBuilder, mBlock, marker,
72260:                           mContentArea + mBuilder->ToReferenceFrame(mBlock),
72260:                           &markerRect);
72260:     }
72260:     mMarkerList->AppendNewToTop(marker);
72260:   }
72260: 
72260:   if (aCreateRight) {
72260:     nsRect markerRect = nsRect(aInsideMarkersArea.XMost(),
72260:                                aLine->mBounds.y,
72260:                                mRight.mWidth, aLine->mBounds.height);
72260:     markerRect += mBuilder->ToReferenceFrame(mBlock);
72260:     nsDisplayItem* marker = new (mBuilder)
72260:       nsDisplayTextOverflowMarker(mBuilder, mBlock, markerRect,
72260:                                   aLine->GetAscent(), mRight.mMarkerString);
72260:     if (marker) {
72260:       marker = ClipMarker(mBuilder, mBlock, marker,
72260:                           mContentArea + mBuilder->ToReferenceFrame(mBlock),
72260:                           &markerRect);
72260:     }
72260:     mMarkerList->AppendNewToTop(marker);
72260:   }
72260: }
72260: 
72260: void
72260: TextOverflow::Marker::SetupString(nsIFrame* aFrame)
72260: {
72260:   if (mInitialized) {
72260:     return;
72260:   }
72260:   nsRefPtr<nsRenderingContext> rc =
72260:     aFrame->PresContext()->PresShell()->GetReferenceRenderingContext();
72260:   nsLayoutUtils::SetFontFromStyle(rc, aFrame->GetStyleContext());
72260: 
72260:   mMarkerString = mStyle->mType == NS_STYLE_TEXT_OVERFLOW_ELLIPSIS ?
72260:                     GetEllipsis(aFrame) : mStyle->mString;
72260:   mWidth = nsLayoutUtils::GetStringWidth(aFrame, rc, mMarkerString.get(),
72260:                                          mMarkerString.Length());
72260:   mInitialized = true;
72260: }
72260: 
72260: }  // namespace css
72260: }  // namespace mozilla
