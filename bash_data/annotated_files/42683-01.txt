37042: /* -*- Mode: c++; c-basic-offset: 4; tab-width: 40; indent-tabs-mode: nil -*- */
39911: /* vim: set ts=40 sw=4 et tw=99: */
37042: /* ***** BEGIN LICENSE BLOCK *****
37042:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
37042:  *
37042:  * The contents of this file are subject to the Mozilla Public License Version
37042:  * 1.1 (the "License"); you may not use this file except in compliance with
37042:  * the License. You may obtain a copy of the License at
37042:  * http://www.mozilla.org/MPL/
37042:  *
37042:  * Software distributed under the License is distributed on an "AS IS" basis,
37042:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
37042:  * for the specific language governing rights and limitations under the
37042:  * License.
37042:  *
37042:  * The Original Code is Mozilla WebGL impl
37042:  *
37042:  * The Initial Developer of the Original Code is
39422:  *   Mozilla Foundation
37042:  * Portions created by the Initial Developer are Copyright (C) 2009
37042:  * the Initial Developer. All Rights Reserved.
37042:  *
37042:  * Contributor(s):
37042:  *   Vladimir Vukicevic <vladimir@pobox.com>
37042:  *
37042:  * Alternatively, the contents of this file may be used under the terms of
37042:  * either of the GNU General Public License Version 2 or later (the "GPL"),
37042:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
37042:  * in which case the provisions of the GPL or the LGPL are applicable instead
37042:  * of those above. If you wish to allow use of your version of this file only
37042:  * under the terms of either the GPL or the LGPL, and not to allow others to
37042:  * use your version of this file under the terms of the MPL, indicate your
37042:  * decision by deleting the provisions above and replace them with the notice
37042:  * and other provisions required by the GPL or the LGPL. If you do not delete
37042:  * the provisions above, a recipient may use your version of this file under
37042:  * the terms of any one of the MPL, the GPL or the LGPL.
37042:  *
37042:  * ***** END LICENSE BLOCK ***** */
37042: 
40406: #define __STDC_LIMIT_MACROS
40406: 
37042: #include <string.h>
37042: 
37042: #include "jstypes.h"
37042: #include "jsstdint.h"
37042: #include "jsutil.h"
37042: #include "jshash.h"
37042: #include "jsprf.h"
37042: #include "jsapi.h"
37042: #include "jsarray.h"
37042: #include "jsatom.h"
37042: #include "jsbool.h"
37042: #include "jsbuiltins.h"
37042: #include "jscntxt.h"
37042: #include "jsversion.h"
37042: #include "jsgc.h"
37042: #include "jsinterp.h"
37042: #include "jslock.h"
37042: #include "jsnum.h"
37042: #include "jsobj.h"
37042: #include "jsstaticcheck.h"
37042: #include "jsbit.h"
37042: #include "jsvector.h"
37042: #include "jstypedarray.h"
37042: 
40796: #include "jsobjinlines.h"
40796: 
37042: using namespace js;
37042: 
37042: /*
37042:  * ArrayBuffer
37042:  *
37042:  * This class holds the underlying raw buffer that the TypedArray classes
37042:  * access.  It can be created explicitly and passed to a TypedArray, or
37042:  * can be created implicitly by constructing a TypedArray with a size.
37042:  */
37416: ArrayBuffer *
37042: ArrayBuffer::fromJSObject(JSObject *obj)
37042: {
37042:     JS_ASSERT(obj->getClass() == &ArrayBuffer::jsclass);
37042:     return reinterpret_cast<ArrayBuffer*>(obj->getPrivate());
37042: }
37042: 
37042: JSBool
37042: ArrayBuffer::prop_getByteLength(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
37042: {
37042:     ArrayBuffer *abuf = ArrayBuffer::fromJSObject(obj);
37042:     if (abuf)
37042:         *vp = INT_TO_JSVAL(jsint(abuf->byteLength));
37042:     return true;
37042: }
37042: 
37042: void
37042: ArrayBuffer::class_finalize(JSContext *cx, JSObject *obj)
37042: {
37042:     ArrayBuffer *abuf = ArrayBuffer::fromJSObject(obj);
37042:     if (abuf)
37042:         abuf->freeStorage(cx);
37042:     delete abuf;
37042: }
37042: 
37042: /*
37042:  * new ArrayBuffer(byteLength)
37042:  */
37042: JSBool
37042: ArrayBuffer::class_constructor(JSContext *cx, JSObject *obj,
37042:                                uintN argc, jsval *argv, jsval *rval)
37042: {
37042:     if (!JS_IsConstructing(cx)) {
40858:         obj = NewObject(cx, &ArrayBuffer::jsclass, NULL, NULL);
37042:         if (!obj)
37042:             return false;
37042:         *rval = OBJECT_TO_JSVAL(obj);
37042:     }
37042: 
40636:     return create(cx, obj, argc, argv, rval);
40636: }
40636: 
40636: bool
40636: ArrayBuffer::create(JSContext *cx, JSObject *obj,
40636:                     uintN argc, jsval *argv, jsval *rval)
40636: {
40636:     if (!obj) {
40870:         obj = NewObject(cx, &ArrayBuffer::jsclass, NULL, NULL);
40636:         if (!obj)
40636:             return false;
40636:         *rval = OBJECT_TO_JSVAL(obj);
40636:     }
40636: 
37042:     if (argc == 0) {
37042:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                              JSMSG_TYPED_ARRAY_BAD_ARGS);
37042:         return false;
37042:     }
37042: 
40828:     int32_t nbytes;
40828:     if (!ValueToECMAInt32(cx, argv[0], &nbytes))
37042:         return false;
37042:     if (nbytes < 0 || !INT_FITS_IN_JSVAL(nbytes)) {
37042:         /*
37042:          * We're just not going to support arrays that are bigger than what will fit
37042:          * as an integer jsval; if someone actually ever complains (validly), then we
37042:          * can fix.
37042:          */
37042:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                              JSMSG_BAD_ARRAY_LENGTH);
37042:         return false;
37042:     }
37042: 
37042:     ArrayBuffer *abuf = new ArrayBuffer();
37042:     if (!abuf) {
37042:         JS_ReportOutOfMemory(cx);
37042:         return false;
37042:     }
37042: 
37042:     if (!abuf->allocateStorage(cx, nbytes)) {
37042:         delete abuf;
37042:         return false;
37042:     }
37042: 
37042:     obj->setPrivate(abuf);
37042:     return true;
37042: }
37042: 
37042: bool
37042: ArrayBuffer::allocateStorage(JSContext *cx, uint32 nbytes)
37042: {
37042:     JS_ASSERT(data == 0);
37042: 
37042:     if (nbytes) {
37042:         data = cx->calloc(nbytes);
37042:         if (!data) {
37042:             JS_ReportOutOfMemory(cx);
37042:             return false;
37042:         }
37042:     }
37042: 
37042:     byteLength = nbytes;
37042:     return true;
37042: }
37042: 
37042: void
37042: ArrayBuffer::freeStorage(JSContext *cx)
37042: {
37042:     if (data) {
37042:         cx->free(data);
37042: #ifdef DEBUG
37042:         // the destructor asserts that data is 0 in debug builds
37042:         data = NULL;
37042: #endif
37042:     }
37042: }
37042: 
37042: ArrayBuffer::~ArrayBuffer()
37042: {
37042:     JS_ASSERT(data == NULL);
37042: }
37042: 
37042: /*
37042:  * TypedArray
37042:  *
37042:  * The non-templated base class for the specific typed implementations.
37042:  * This class holds all the member variables that are used by
37042:  * the subclasses.
37042:  */
37042: 
37416: TypedArray *
37042: TypedArray::fromJSObject(JSObject *obj)
37042: {
37042:     return reinterpret_cast<TypedArray*>(obj->getPrivate());
37042: }
37042: 
37042: inline bool
37042: TypedArray::isArrayIndex(JSContext *cx, jsid id, jsuint *ip)
37042: {
37042:     jsuint index;
37042:     if (js_IdIsIndex(id, &index) && index < length) {
37042:         if (ip)
37042:             *ip = index;
37042:         return true;
37042:     }
37042: 
37042:     return false;
37042: }
37042: 
37042: JSBool
37042: TypedArray::prop_getBuffer(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
37042: {
37042:     TypedArray *tarray = fromJSObject(obj);
37042:     if (tarray)
37042:         *vp = OBJECT_TO_JSVAL(tarray->bufferJS);
37042:     return true;
37042: }
37042: 
37042: JSBool
37042: TypedArray::prop_getByteOffset(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
37042: {
37042:     TypedArray *tarray = fromJSObject(obj);
37042:     if (tarray)
37042:         *vp = INT_TO_JSVAL(tarray->byteOffset);
37042:     return true;
37042: }
37042: 
37042: JSBool
37042: TypedArray::prop_getByteLength(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
37042: {
37042:     TypedArray *tarray = fromJSObject(obj);
37042:     if (tarray)
37042:         *vp = INT_TO_JSVAL(tarray->byteLength);
37042:     return true;
37042: }
37042: 
37042: JSBool
37042: TypedArray::prop_getLength(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
37042: {
37042:     TypedArray *tarray = fromJSObject(obj);
37042:     if (tarray)
37042:         *vp = INT_TO_JSVAL(tarray->length);
37042:     return true;
37042: }
37042: 
37042: JSBool
37042: TypedArray::obj_lookupProperty(JSContext *cx, JSObject *obj, jsid id,
37042:                                JSObject **objp, JSProperty **propp)
37042: {
37042:     TypedArray *tarray = fromJSObject(obj);
37042:     JS_ASSERT(tarray);
37042: 
37042:     if (tarray->isArrayIndex(cx, id)) {
37042:         *propp = (JSProperty *) id;
37042:         *objp = obj;
37042:         return true;
37042:     }
37042: 
39928:     JSObject *proto = obj->getProto();
37042:     if (!proto) {
37042:         *objp = NULL;
37042:         *propp = NULL;
37042:         return true;
37042:     }
37042: 
37042:     return proto->lookupProperty(cx, id, objp, propp);
37042: }
37042: 
37042: void
37042: TypedArray::obj_dropProperty(JSContext *cx, JSObject *obj, JSProperty *prop)
37042: {
37042: #ifdef DEBUG
37042:     TypedArray *tarray = fromJSObject(obj);
37042:     JS_ASSERT_IF(tarray, tarray->isArrayIndex(cx, (jsid) prop));
37042: #endif
37042: }
37042: 
37042: void
37042: TypedArray::obj_trace(JSTracer *trc, JSObject *obj)
37042: {
37042:     TypedArray *tarray = fromJSObject(obj);
37042:     JS_ASSERT(tarray);
37042: 
37042:     obj->traceProtoAndParent(trc);
37042: 
37042:     JS_CALL_OBJECT_TRACER(trc, tarray->bufferJS, "typedarray.buffer");
37042: }
37042: 
37042: JSBool
37042: TypedArray::obj_getAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
37042:                               uintN *attrsp)
37042: {
37042:     *attrsp = (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom))
37042:               ? JSPROP_PERMANENT | JSPROP_READONLY
37042:               : JSPROP_PERMANENT | JSPROP_ENUMERATE;
37042:     return true;
37042: }
37042: 
37042: JSBool
37042: TypedArray::obj_setAttributes(JSContext *cx, JSObject *obj, jsid id, JSProperty *prop,
37042:                               uintN *attrsp)
37042: {
37042:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                          JSMSG_CANT_SET_ARRAY_ATTRS);
37042:     return false;
37042: }
37042: 
38514: /* Helper clamped uint8 type */
38514: 
38514: int32 JS_FASTCALL
38514: js_TypedArray_uint8_clamp_double(const double x)
38514: {
38514:     // Not < so that NaN coerces to 0
38514:     if (!(x >= 0))
38514:         return 0;
38514: 
38514:     if (x > 255)
38514:         return 255;
38514: 
38514:     jsdouble toTruncate = x + 0.5;
38514:     JSUint8 y = JSUint8(toTruncate);
38514: 
38514:     /*
38514:      * now val is rounded to nearest, ties rounded up.  We want
38514:      * rounded to nearest ties to even, so check whether we had a
38514:      * tie.
38514:      */
38514:     if (y == toTruncate) {
38514:         /*
38514:          * It was a tie (since adding 0.5 gave us the exact integer
38514:          * we want).  Since we rounded up, we either already have an
38514:          * even number or we have an odd number but the number we
38514:          * want is one less.  So just unconditionally masking out the
38514:          * ones bit should do the trick to get us the value we
38514:          * want.
38514:          */
38514:         return (y & ~1);
38514:     }
38514: 
38514:     return y;
38514: }
38514: 
39910: JS_DEFINE_CALLINFO_1(extern, INT32, js_TypedArray_uint8_clamp_double, DOUBLE, 1, nanojit::ACC_NONE)
38514: 
38514: 
38514: struct uint8_clamped {
38514:     uint8 val;
38514: 
38514:     uint8_clamped() { }
38514:     uint8_clamped(const uint8_clamped& other) : val(other.val) { }
38514: 
38514:     // invoke our assignment helpers for constructor conversion
38514:     uint8_clamped(uint8 x)    { *this = x; }
38514:     uint8_clamped(uint16 x)   { *this = x; }
38514:     uint8_clamped(uint32 x)   { *this = x; }
38514:     uint8_clamped(int8 x)     { *this = x; }
38514:     uint8_clamped(int16 x)    { *this = x; }
38514:     uint8_clamped(int32 x)    { *this = x; }
38514:     uint8_clamped(jsdouble x) { *this = x; }
38514: 
38514:     inline uint8_clamped& operator= (const uint8_clamped& x) {
38514:         val = x.val;
38514:         return *this;
38514:     }
38514: 
38514:     inline uint8_clamped& operator= (uint8 x) {
38514:         val = x;
38514:         return *this;
38514:     }
38514: 
38514:     inline uint8_clamped& operator= (uint16 x) {
40294:         val = (x > 255) ? 255 : uint8(x);
38514:         return *this;
38514:     }
38514: 
38514:     inline uint8_clamped& operator= (uint32 x) {
40294:         val = (x > 255) ? 255 : uint8(x);
38514:         return *this;
38514:     }
38514: 
38514:     inline uint8_clamped& operator= (int8 x) {
38514:         val = (x >= 0) ? uint8(x) : 0;
38514:         return *this;
38514:     }
38514: 
38514:     inline uint8_clamped& operator= (int16 x) {
38514:         val = (x >= 0)
38514:               ? ((x < 255)
38514:                  ? uint8(x)
38514:                  : 255)
38514:               : 0;
38514:         return *this;
38514:     }
38514: 
38514:     inline uint8_clamped& operator= (int32 x) { 
38514:         val = (x >= 0)
38514:               ? ((x < 255)
38514:                  ? uint8(x)
38514:                  : 255)
38514:               : 0;
38514:         return *this;
38514:     }
38514: 
38514:     inline uint8_clamped& operator= (const jsdouble x) { 
39928:         val = uint8(js_TypedArray_uint8_clamp_double(x));
38514:         return *this;
38514:     }
38514: 
38514:     inline operator uint8() const {
38514:         return val;
38514:     }
38514: };
38514: 
38514: /* Make sure the compiler isn't doing some funky stuff */
38514: JS_STATIC_ASSERT(sizeof(uint8_clamped) == 1);
38514: 
37042: template<typename NativeType> static inline const int TypeIDOfType();
37042: template<> inline const int TypeIDOfType<int8>() { return TypedArray::TYPE_INT8; }
37042: template<> inline const int TypeIDOfType<uint8>() { return TypedArray::TYPE_UINT8; }
37042: template<> inline const int TypeIDOfType<int16>() { return TypedArray::TYPE_INT16; }
37042: template<> inline const int TypeIDOfType<uint16>() { return TypedArray::TYPE_UINT16; }
37042: template<> inline const int TypeIDOfType<int32>() { return TypedArray::TYPE_INT32; }
37042: template<> inline const int TypeIDOfType<uint32>() { return TypedArray::TYPE_UINT32; }
37042: template<> inline const int TypeIDOfType<float>() { return TypedArray::TYPE_FLOAT32; }
38512: template<> inline const int TypeIDOfType<double>() { return TypedArray::TYPE_FLOAT64; }
38514: template<> inline const int TypeIDOfType<uint8_clamped>() { return TypedArray::TYPE_UINT8_CLAMPED; }
37042: 
40294: template<typename NativeType> static inline const bool TypeIsUnsigned() { return false; }
40294: template<> inline const bool TypeIsUnsigned<uint8>() { return true; }
40294: template<> inline const bool TypeIsUnsigned<uint16>() { return true; }
40294: template<> inline const bool TypeIsUnsigned<uint32>() { return true; }
40294: 
40294: template<typename NativeType> static inline const bool TypeIsFloatingPoint() { return false; }
40294: template<> inline const bool TypeIsFloatingPoint<float>() { return true; }
40294: template<> inline const bool TypeIsFloatingPoint<double>() { return true; }
40294: 
37042: template<typename NativeType> class TypedArrayTemplate;
37042: 
37042: typedef TypedArrayTemplate<int8> Int8Array;
37042: typedef TypedArrayTemplate<uint8> Uint8Array;
37042: typedef TypedArrayTemplate<int16> Int16Array;
37042: typedef TypedArrayTemplate<uint16> Uint16Array;
37042: typedef TypedArrayTemplate<int32> Int32Array;
37042: typedef TypedArrayTemplate<uint32> Uint32Array;
37042: typedef TypedArrayTemplate<float> Float32Array;
38512: typedef TypedArrayTemplate<double> Float64Array;
38514: typedef TypedArrayTemplate<uint8_clamped> Uint8ClampedArray;
37042: 
37042: template<typename NativeType>
37042: class TypedArrayTemplate
37042:   : public TypedArray
37042: {
37042:   public:
37042:     typedef TypedArrayTemplate<NativeType> ThisTypeArray;
40294:     static const int ArrayTypeID() { return TypeIDOfType<NativeType>(); }
40294:     static const bool ArrayTypeIsUnsigned() { return TypeIsUnsigned<NativeType>(); }
40294:     static const bool ArrayTypeIsFloatingPoint() { return TypeIsFloatingPoint<NativeType>(); }
37042: 
37042:     static JSObjectOps fastObjectOps;
37042:     static JSObjectMap fastObjectMap;
37042: 
37042:     static JSFunctionSpec jsfuncs[];
37042: 
37042:     static inline JSClass *slowClass()
37042:     {
40294:         return &TypedArray::slowClasses[ArrayTypeID()];
37042:     }
37042: 
37042:     static inline JSClass *fastClass()
37042:     {
40294:         return &TypedArray::fastClasses[ArrayTypeID()];
37042:     }
37042: 
37042:     static JSObjectOps *getObjectOps(JSContext *cx, JSClass *clasp)
37042:     {
37042:         return &fastObjectOps;
37042:     }
37042: 
37042:     static JSBool
37042:     obj_getProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
37042:     {
37042:         ThisTypeArray *tarray = ThisTypeArray::fromJSObject(obj);
37042:         JS_ASSERT(tarray);
37042: 
37042:         if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)) {
37042:             *vp = INT_TO_JSVAL(tarray->length);
37042:             return true;
37042:         }
37042: 
37042:         jsuint index;
37042:         if (tarray->isArrayIndex(cx, id, &index)) {
37042:             // this inline function is specialized for each type
37042:             tarray->copyIndexToValue(cx, index, vp);
37042:         } else {
37042:             JSObject *obj2;
37042:             JSProperty *prop;
37042:             JSScopeProperty *sprop;
37042: 
39928:             JSObject *proto = obj->getProto();
37042:             if (!proto) {
37042:                 *vp = JSVAL_VOID;
37042:                 return true;
37042:             }
37042: 
37042:             *vp = JSVAL_VOID;
37042:             if (js_LookupPropertyWithFlags(cx, proto, id, cx->resolveFlags, &obj2, &prop) < 0)
37042:                 return false;
37042: 
37042:             if (prop) {
40430:                 if (obj2->isNative()) {
37042:                     sprop = (JSScopeProperty *) prop;
37042:                     if (!js_NativeGet(cx, obj, obj2, sprop, JSGET_METHOD_BARRIER, vp))
37042:                         return false;
37042:                 }
37042:                 obj2->dropProperty(cx, prop);
37042:             }
37042:         }
37042: 
37042:         return true;
37042:     }
37042: 
37042:     static JSBool
37042:     obj_setProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
37042:     {
37042:         ThisTypeArray *tarray = ThisTypeArray::fromJSObject(obj);
37042:         JS_ASSERT(tarray);
37042: 
37042:         if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)) {
37042:             *vp = INT_TO_JSVAL(tarray->length);
37042:             return true;
37042:         }
37042: 
37042:         jsuint index;
37042:         // We can't just chain to js_SetProperty, because we're not a normal object.
37042:         if (!tarray->isArrayIndex(cx, id, &index)) {
38927: #if 0
37042:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                  JSMSG_TYPED_ARRAY_BAD_INDEX);
37042:             return false;
38927: #endif
38927:             // Silent ignore is better than an exception here, because
38927:             // at some point we may want to support other properties on
38927:             // these objects.  This is especially true when these arrays
38927:             // are used to implement HTML Canvas 2D's PixelArray objects,
38927:             // which used to be plain old arrays.
38927:             *vp = JSVAL_VOID;
38927:             return true;
37042:         }
37042: 
37042:         if (JSVAL_IS_INT(*vp)) {
37042:             tarray->setIndex(index, NativeType(JSVAL_TO_INT(*vp)));
40294:             return true;
40294:         }
40294: 
40294:         jsdouble d;
40294: 
40294:         if (JSVAL_IS_DOUBLE(*vp)) {
40294:             d = *JSVAL_TO_DOUBLE(*vp);
40294:         } else if (JSVAL_IS_NULL(*vp)) {
40294:             d = 0.0f;
40294:         } else if (JSVAL_IS_PRIMITIVE(*vp)) {
40294:             JS_ASSERT(JSVAL_IS_STRING(*vp) || JSVAL_IS_SPECIAL(*vp));
40294:             if (JSVAL_IS_STRING(*vp)) {
40828:                 // note that ValueToNumber will always succeed with a string arg
40828:                 ValueToNumber(cx, *vp, &d);
40294:             } else if (*vp == JSVAL_VOID) {
40294:                 d = js_NaN;
37042:             } else {
40294:                 d = (double) JSVAL_TO_BOOLEAN(*vp);
40294:             }
40294:         } else {
40294:             // non-primitive assignments become NaN or 0 (for float/int arrays)
40294:             d = js_NaN;
40294:         }
40294: 
40294:         // If the array is an integer array, we only handle up to
40294:         // 32-bit ints from this point on.  if we want to handle
40294:         // 64-bit ints, we'll need some changes.
40294: 
40294:         // Assign based on characteristics of the destination type
40294:         if (ArrayTypeIsFloatingPoint()) {
37042:             tarray->setIndex(index, NativeType(d));
40294:         } else if (ArrayTypeIsUnsigned()) {
40294:             JS_ASSERT(sizeof(NativeType) <= 4);
40294:             uint32 n = js_DoubleToECMAUint32(d);
40294:             tarray->setIndex(index, NativeType(n));
40294:         } else if (ArrayTypeID() == TypedArray::TYPE_UINT8_CLAMPED) {
40294:             // The uint8_clamped type has a special rounding converter
40294:             // for doubles.
40294:             tarray->setIndex(index, NativeType(d));
40294:         } else {
40294:             JS_ASSERT(sizeof(NativeType) <= 4);
40294:             int32 n = js_DoubleToECMAInt32(d);
40294:             tarray->setIndex(index, NativeType(n));
37042:         }
37042: 
37042:         return true;
37042:     }
37042: 
37042:     static JSBool
37042:     obj_defineProperty(JSContext *cx, JSObject *obj, jsid id, jsval value,
37042:                        JSPropertyOp getter, JSPropertyOp setter, uintN attrs)
37042:     {
37042:         if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom))
37042:             return true;
37042: 
37042:         return obj_setProperty(cx, obj, id, &value);
37042:     }
37042: 
37042:     static JSBool
37042:     obj_deleteProperty(JSContext *cx, JSObject *obj, jsval id, jsval *rval)
37042:     {
37042:         if (id == ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)) {
37042:             *rval = JSVAL_FALSE;
37042:             return true;
37042:         }
37042: 
37042:         TypedArray *tarray = TypedArray::fromJSObject(obj);
37042:         JS_ASSERT(tarray);
37042: 
37042:         if (tarray->isArrayIndex(cx, id)) {
37042:             *rval = JSVAL_FALSE;
37042:             return true;
37042:         }
37042: 
37042:         *rval = JSVAL_TRUE;
37042:         return true;
37042:     }
37042: 
37042:     static JSBool
37042:     obj_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
37042:                   jsval *statep, jsid *idp)
37042:     {
37042:         ThisTypeArray *tarray = ThisTypeArray::fromJSObject(obj);
37042:         JS_ASSERT(tarray);
37042: 
37042:         jsint curVal;
37042:         switch (enum_op) {
37042:           case JSENUMERATE_INIT:
37042:             *statep = JSVAL_ZERO;
37042:             if (idp)
37042:                 *idp = INT_TO_JSID(tarray->length);
37042:             break;
37042: 
37042:           case JSENUMERATE_NEXT:
37042:             curVal = JSVAL_TO_INT(*statep);
37042:             *idp = INT_TO_JSID(curVal);
37042:             *statep = (curVal == int32(tarray->length))
37042:                       ? JSVAL_NULL
37042:                       : INT_TO_JSVAL(curVal+1);
37042:             break;
37042: 
37042:           case JSENUMERATE_DESTROY:
37042:             *statep = JSVAL_NULL;
37042:             break;
37042:         }
37042: 
37042:         return true;
37042:     }
37042: 
38633:     static JSType
38633:     obj_typeOf(JSContext *cx, JSObject *obj)
38633:     {
38633:         return JSTYPE_OBJECT;
38633:     }
38633: 
37042:     /*
37042:      * new [Type]Array(length)
37042:      * new [Type]Array(otherTypedArray)
37042:      * new [Type]Array(JSArray)
37042:      * new [Type]Array(ArrayBuffer, [optional] byteOffset, [optional] length)
37042:      */
37042:     static JSBool
37042:     class_constructor(JSContext *cx, JSObject *obj,
37042:                       uintN argc, jsval *argv, jsval *rval)
37042:     {
37042:         //
37042:         // Note: this is a constructor for slowClass, not fastClass!
37042:         //
37042: 
37042:         if (!JS_IsConstructing(cx)) {
40858:             obj = NewObject(cx, slowClass(), NULL, NULL);
37042:             if (!obj)
37042:                 return false;
37042:             *rval = OBJECT_TO_JSVAL(obj);
37042:         }
37042: 
40636:         return create(cx, obj, argc, argv, rval);
40636:     }
40636: 
40636:     static bool
40636:     create(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
40636:     {
40636:         if (!obj) {
40870:             obj = NewObject(cx, slowClass(), NULL, NULL);
40636:             if (!obj)
40636:                 return false;
40636:             *rval = OBJECT_TO_JSVAL(obj);
40636:         }
40636: 
37042:         ThisTypeArray *tarray = 0;
37042: 
37042:         // must have at least one arg
37042:         if (argc == 0) {
37042:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                  JSMSG_TYPED_ARRAY_BAD_ARGS);
37042:             return false;
37042:         }
37042: 
37042:         // figure out the type of the first argument
37042:         if (JSVAL_IS_INT(argv[0])) {
37042:             int32 len = JSVAL_TO_INT(argv[0]);
37042:             if (len < 0) {
37042:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                      JSMSG_BAD_ARRAY_LENGTH);
37042: 
37042:                 return false;
37042:             }
37042: 
37042:             tarray = new ThisTypeArray();
37042:             if (!tarray) {
37042:                 JS_ReportOutOfMemory(cx);
37042:                 return false;
37042:             }
37042: 
37042:             if (!tarray->init(cx, len)) {
37042:                 delete tarray;
37042:                 return false;
37042:             }
42683:         } else if (!JSVAL_IS_PRIMITIVE(argv[0])) {
40828:             int32_t byteOffset = -1;
40828:             int32_t length = -1;
37042: 
37042:             if (argc > 1) {
40828:                 if (!ValueToInt32(cx, argv[1], &byteOffset))
37042:                     return false;
37042:                 if (byteOffset < 0) {
37042:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                          JSMSG_TYPED_ARRAY_NEGATIVE_ARG, "1");
37042:                     return false;
37042:                 }
37042:             }
37042: 
37042:             if (argc > 2) {
40828:                 if (!ValueToInt32(cx, argv[2], &length))
37042:                     return false;
37042:                 if (length < 0) {
37042:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                          JSMSG_TYPED_ARRAY_NEGATIVE_ARG, "2");
37042:                     return false;
37042:                 }
37042:             }
37042: 
37042:             tarray = new ThisTypeArray();
37042:             if (!tarray) {
37042:                 JS_ReportOutOfMemory(cx);
37042:                 return false;
37042:             }
37042: 
37042:             if (!tarray->init(cx, JSVAL_TO_OBJECT(argv[0]), byteOffset, length)) {
37042:                 delete tarray;
37042:                 return false;
37042:             }
37042:         } else {
37042:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                  JSMSG_TYPED_ARRAY_BAD_ARGS);
37042:             return false;
37042:         }
37042: 
37042:         makeFastWithPrivate(cx, obj, tarray);
37042:         return true;
37042:     }
37042: 
37042:     static void
37042:     class_finalize(JSContext *cx, JSObject *obj)
37042:     {
37042:         ThisTypeArray *tarray = ThisTypeArray::fromJSObject(obj);
37042:         delete tarray;
37042:     }
37042: 
37042:     /* slice(start[, end]) */
37042:     static JSBool
37042:     fun_slice(JSContext *cx, uintN argc, jsval *vp)
37042:     {
37042:         jsval *argv;
37042:         JSObject *obj;
37042: 
37042:         argv = JS_ARGV(cx, vp);
37042:         obj = JS_THIS_OBJECT(cx, vp);
37042: 
37042:         ThisTypeArray *tarray = ThisTypeArray::fromJSObject(obj);
37042:         if (!tarray)
37042:             return true;
37042: 
37042:         // these are the default values
40828:         int32_t begin = 0, end = tarray->length;
40828:         int32_t length = int32(tarray->length);
37042: 
37042:         if (argc > 0) {
40828:             if (!ValueToInt32(cx, argv[0], &begin))
37042:                 return false;
37042:             if (begin < 0) {
37042:                 begin += length;
37042:                 if (begin < 0)
37042:                     begin = 0;
37042:             } else if (begin > length) {
37042:                 begin = length;
37042:             }
37042: 
37042:             if (argc > 1) {
40828:                 if (!ValueToInt32(cx, argv[1], &end))
37042:                     return false;
37042:                 if (end < 0) {
37042:                     end += length;
37042:                     if (end < 0)
37042:                         end = 0;
37042:                 } else if (end > length) {
37042:                     end = length;
37042:                 }
37042:             }
37042:         }
37042: 
37042:         if (begin > end)
37042:             begin = end;
37042: 
37042:         ThisTypeArray *ntarray = tarray->slice(begin, end);
37042:         if (!ntarray) {
37042:             // this should rarely ever happen
37042:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                  JSMSG_TYPED_ARRAY_BAD_ARGS);
37042:             return false;
37042:         }
37042: 
37042:         // note the usage of JS_NewObject here -- we don't want the
37042:         // constructor to be called!
37042:         JSObject *nobj = JS_NewObject(cx, slowClass(), NULL, NULL);
40823:         if (!nobj) {
40823:             delete ntarray;
37042:             return false;
40823:         }
37042: 
37042:         makeFastWithPrivate(cx, nobj, ntarray);
37042: 
37042:         *vp = OBJECT_TO_JSVAL(nobj);
37042:         return true;
37042:     }
37042: 
37042:     static ThisTypeArray *
37042:     fromJSObject(JSObject *obj)
37042:     {
37042:         JS_ASSERT(obj->getClass() == fastClass());
37042:         return reinterpret_cast<ThisTypeArray*>(obj->getPrivate());
37042:     }
37042: 
37042:     // helper used by both the constructor and Slice()
37042:     static void
37042:     makeFastWithPrivate(JSContext *cx, JSObject *obj, ThisTypeArray *tarray)
37042:     {
37042:         JS_ASSERT(obj->getClass() == slowClass());
37042: 
37042:         obj->setPrivate(tarray);
37042: 
37042:         // now munge the classword and make this into a fast typed
37042:         // array class, since it's an instance
37042:         obj->classword ^= jsuword(slowClass());
37042:         obj->classword |= jsuword(fastClass());
37042: 
37042:         obj->map = &fastObjectMap;
37042:     }
37042: 
37042:   public:
37042:     TypedArrayTemplate() { }
37042: 
37042:     bool
37042:     init(JSContext *cx, uint32 len)
37042:     {
40294:         type = ArrayTypeID();
37042:         return createBufferWithSizeAndCount(cx, sizeof(NativeType), len);
37042:     }
37042: 
37042:     bool
37042:     init(JSContext *cx, JSObject *other, int32 byteOffsetInt = -1, int32 lengthInt = -1)
37042:     {
40294:         type = ArrayTypeID();
37042: 
37042:         //printf ("Constructing with type %d other %p offset %d length %d\n", type, other, byteOffset, length);
37042: 
37042:         if (JS_IsArrayObject(cx, other)) {
37042:             jsuint len;
37042:             if (!JS_GetArrayLength(cx, other, &len))
37042:                 return false;
37042:             if (!createBufferWithSizeAndCount(cx, sizeof(NativeType), len))
37042:                 return false;
37042:             if (!copyFrom(cx, other, len))
37042:                 return false;
37042:         } else if (js_IsTypedArray(other)) {
37042:             TypedArray *tarray = TypedArray::fromJSObject(other);
37042: 
37042:             //printf ("SizeAndCount: %d %d\n", sizeof(NativeType), tarray->length);
37042: 
37042:             if (!createBufferWithSizeAndCount(cx, sizeof(NativeType), tarray->length))
37042:                 return false;
37042:             if (!copyFrom(tarray))
37042:                 return false;
37042:         } else if (other->getClass() == &ArrayBuffer::jsclass) {
37042:             ArrayBuffer *abuf = ArrayBuffer::fromJSObject(other);
37042: 
37042:             //printf ("buffer: %d %d %d\n", abuf->byteLength, abuf->byteLength / sizeof(NativeType), len * sizeof(NativeType) == abuf->byteLength);
37042:             uint32 boffset = (byteOffsetInt < 0) ? 0 : uint32(byteOffsetInt);
37042: 
37042:             if (boffset > abuf->byteLength || boffset % sizeof(NativeType) != 0) {
37042:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                      JSMSG_TYPED_ARRAY_BAD_ARGS);
37042:                 return false; // invalid byteOffset
37042:             }
37042: 
37042:             uint32 len;
37042:             if (lengthInt < 0) {
37042:                 len = (abuf->byteLength - boffset) / sizeof(NativeType);
37042:                 if (len * sizeof(NativeType) != (abuf->byteLength - boffset)) {
37042:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                          JSMSG_TYPED_ARRAY_BAD_ARGS);
37042:                     return false; // given byte array doesn't map exactly to sizeof(NativeType)*N
37042:                 }
37042:             } else {
37042:                 len = (uint32) lengthInt;
37042:             }
37042: 
40406:             // Go slowly and check for overflow.
40406:             uint32 arrayByteLength = len*sizeof(NativeType);
40406:             if (uint32(len) >= INT32_MAX / sizeof(NativeType) ||
40406:                 uint32(boffset) >= INT32_MAX - arrayByteLength)
40406:             {
40406:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
40406:                                      JSMSG_TYPED_ARRAY_BAD_ARGS);
40406:                 return false; // overflow occurred along the way when calculating boffset+len*sizeof(NativeType)
40406:             }
40406: 
40406:             if (arrayByteLength + boffset > abuf->byteLength) {
37042:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                      JSMSG_TYPED_ARRAY_BAD_ARGS);
37042:                 return false; // boffset+len is too big for the arraybuffer
37042:             }
37042: 
37042:             buffer = abuf;
37042:             bufferJS = other;
37042:             byteOffset = boffset;
40406:             byteLength = arrayByteLength;
37042:             length = len;
37042:             data = abuf->offsetData(boffset);
37042:         } else {
37042:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                  JSMSG_TYPED_ARRAY_BAD_ARGS);
37042:             return false;
37042:         }
37042: 
37042:         return true;
37042:     }
37042: 
37042:     const NativeType
37042:     getIndex(uint32 index) const
37042:     {
37042:         return *(static_cast<const NativeType*>(data) + index);
37042:     }
37042: 
37042:     void
37042:     setIndex(uint32 index, NativeType val)
37042:     {
37042:         *(static_cast<NativeType*>(data) + index) = val;
37042:     }
37042: 
37042:     inline void copyIndexToValue(JSContext *cx, uint32 index, jsval *vp);
37042: 
37042:     ThisTypeArray *
37042:     slice(uint32 begin, uint32 end)
37042:     {
37042:         if (begin > length || end > length)
37042:             return NULL;
37042: 
37042:         ThisTypeArray *tarray = new ThisTypeArray();
37042:         if (!tarray)
37042:             return NULL;
37042: 
37042:         tarray->buffer = buffer;
37042:         tarray->bufferJS = bufferJS;
37042:         tarray->byteOffset = byteOffset + begin * sizeof(NativeType);
37042:         tarray->byteLength = (end - begin) * sizeof(NativeType);
37042:         tarray->length = end - begin;
37042:         tarray->type = type;
37042:         tarray->data = buffer->offsetData(tarray->byteOffset);
37042: 
37042:         return tarray;
37042:     }
37042: 
37042:   protected:
40294:     static NativeType
40294:     nativeFromValue(JSContext *cx, jsval v)
40294:     {
40294:         if (JSVAL_IS_INT(v))
40294:             return NativeType(JSVAL_TO_INT(v));
40294: 
40294:         if (JSVAL_IS_DOUBLE(v))
40294:             return NativeType(*JSVAL_TO_DOUBLE(v));
40294: 
40294:         if (JSVAL_IS_PRIMITIVE(v) && v != JSVAL_HOLE) {
40828:             jsdouble dval;
40828:             ValueToNumber(cx, v, &dval);
40294:             return NativeType(dval);
40294:         }
40294: 
40294:         if (ArrayTypeIsFloatingPoint())
40294:             return NativeType(js_NaN);
40294: 
40294:         return NativeType(int32(0));
40294:     }
40294:     
37042:     bool
37042:     copyFrom(JSContext *cx, JSObject *ar, jsuint len)
37042:     {
37042:         NativeType *dest = static_cast<NativeType*>(data);
37042: 
41782:         if (ar->isDenseArray() && ar->getDenseArrayCapacity() >= len) {
40796:             JS_ASSERT(ar->getArrayLength() == len);
37042: 
41782:             jsval *src = ar->getDenseArrayElements();
37042: 
37042:             for (uintN i = 0; i < len; ++i) {
37042:                 jsval v = *src++;
40294:                 *dest++ = nativeFromValue(cx, v);
37042:             }
37042:         } else {
37042:             // slow path
37042:             jsval v;
37042: 
37042:             for (uintN i = 0; i < len; ++i) {
40405:                 if (!ar->getProperty(cx, INT_TO_JSID(i), &v))
37042:                     return false;
40294:                 *dest++ = nativeFromValue(cx, v);
37042:             }
37042:         }
37042: 
37042:         return true;
37042:     }
37042: 
37042:     bool
37042:     copyFrom(TypedArray *tarray)
37042:     {
37042:         NativeType *dest = static_cast<NativeType*>(data);
37042: 
37042:         if (tarray->type == type) {
37042:             memcpy(dest, tarray->data, tarray->byteLength);
37042:             return true;
37042:         }
37042: 
37042:         switch (tarray->type) {
37042:           case TypedArray::TYPE_INT8: {
37042:             int8 *src = static_cast<int8*>(tarray->data);
37042:             for (uintN i = 0; i < length; ++i)
37042:                 *dest++ = NativeType(*src++);
37042:             break;
37042:           }
38514:           case TypedArray::TYPE_UINT8:
38514:           case TypedArray::TYPE_UINT8_CLAMPED: {
37042:             uint8 *src = static_cast<uint8*>(tarray->data);
37042:             for (uintN i = 0; i < length; ++i)
37042:                 *dest++ = NativeType(*src++);
37042:             break;
37042:           }
37042:           case TypedArray::TYPE_INT16: {
37042:             int16 *src = static_cast<int16*>(tarray->data);
37042:             for (uintN i = 0; i < length; ++i)
37042:                 *dest++ = NativeType(*src++);
37042:             break;
37042:           }
37042:           case TypedArray::TYPE_UINT16: {
37042:             uint16 *src = static_cast<uint16*>(tarray->data);
37042:             for (uintN i = 0; i < length; ++i)
37042:                 *dest++ = NativeType(*src++);
37042:             break;
37042:           }
37042:           case TypedArray::TYPE_INT32: {
37042:             int32 *src = static_cast<int32*>(tarray->data);
37042:             for (uintN i = 0; i < length; ++i)
37042:                 *dest++ = NativeType(*src++);
37042:             break;
37042:           }
37042:           case TypedArray::TYPE_UINT32: {
37042:             uint32 *src = static_cast<uint32*>(tarray->data);
37042:             for (uintN i = 0; i < length; ++i)
37042:                 *dest++ = NativeType(*src++);
37042:             break;
37042:           }
37042:           case TypedArray::TYPE_FLOAT32: {
37042:             float *src = static_cast<float*>(tarray->data);
37042:             for (uintN i = 0; i < length; ++i)
37042:                 *dest++ = NativeType(*src++);
37042:             break;
37042:           }
38512:           case TypedArray::TYPE_FLOAT64: {
38512:             double *src = static_cast<double*>(tarray->data);
38512:             for (uintN i = 0; i < length; ++i)
38512:                 *dest++ = NativeType(*src++);
38512:             break;
38512:           }
37042:           default:
37042:             JS_NOT_REACHED("copyFrom with a TypedArray of unknown type");
37042:             break;
37042:         }
37042: 
37042:         return true;
37042:     }
37042: 
37042:     bool
37042:     createBufferWithSizeAndCount(JSContext *cx, uint32 size, uint32 count)
37042:     {
40406:         JS_ASSERT(size != 0);
40406: 
40406:         if (size != 0 && count >= INT32_MAX / size) {
37042:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                  JSMSG_NEED_DIET, "size and count");
37042:             return false;
37042:         }
37042: 
40406:         int32 bytelen = size * count;
37042:         if (!createBufferWithByteLength(cx, bytelen))
37042:             return false;
37042: 
37042:         length = count;
37042:         return true;
37042:     }
37042: 
37042:     bool
37042:     createBufferWithByteLength(JSContext *cx, int32 bytes)
37042:     {
37042:         if (!INT_FITS_IN_JSVAL(bytes)) {
37042:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
37042:                                  JSMSG_NEED_DIET, "byte length");
37042:             return false;
37042:         }
37042: 
37042:         jsval argv = INT_TO_JSVAL(bytes);
37042:         JSObject *obj = JS_ConstructObjectWithArguments(cx, &ArrayBuffer::jsclass, NULL, NULL,
37042:                                                         1, &argv);
37042:         if (!obj)
37042:             return false;
37042: 
37042:         bufferJS = obj;
37042:         buffer = ArrayBuffer::fromJSObject(obj);
37042: 
37042:         byteOffset = 0;
37042:         byteLength = bytes;
37042:         data = buffer->data;
37042: 
37042:         return true;
37042:     }
37042: };
37042: 
37042: // this default implementation is only valid for integer types
37042: // less than 32-bits in size.
37042: template<typename NativeType>
37042: void
37042: TypedArrayTemplate<NativeType>::copyIndexToValue(JSContext *cx, uint32 index, jsval *vp)
37042: {
37042:     JS_STATIC_ASSERT(sizeof(NativeType) < 4);
37042: 
37042:     *vp = INT_TO_JSVAL(getIndex(index));
37042: }
37042: 
37042: // and we need to specialize for 32-bit integers and floats
37042: template<>
37042: void
37042: TypedArrayTemplate<int32>::copyIndexToValue(JSContext *cx, uint32 index, jsval *vp)
37042: {
37042:     int32 val = getIndex(index);
37042:     if (INT_FITS_IN_JSVAL(val)) {
37042:         *vp = INT_TO_JSVAL(val);
37042:     } else {
37042:         jsdouble *dp = js_NewWeaklyRootedDouble(cx, jsdouble(val));
37042:         *vp = dp ? DOUBLE_TO_JSVAL(dp) : JSVAL_VOID;
37042:     }
37042: }
37042: 
37042: template<>
37042: void
37042: TypedArrayTemplate<uint32>::copyIndexToValue(JSContext *cx, uint32 index, jsval *vp)
37042: {
37042:     uint32 val = getIndex(index);
37042:     if (val < uint32(JSVAL_INT_MAX)) {
37042:         *vp = INT_TO_JSVAL(int32(val));
37042:     } else {
37042:         jsdouble *dp = js_NewWeaklyRootedDouble(cx, jsdouble(val));
37042:         *vp = dp ? DOUBLE_TO_JSVAL(dp) : JSVAL_VOID;
37042:     }
37042: }
37042: 
37042: template<>
37042: void
37042: TypedArrayTemplate<float>::copyIndexToValue(JSContext *cx, uint32 index, jsval *vp)
37042: {
37042:     float val = getIndex(index);
37042:     if (!js_NewWeaklyRootedNumber(cx, jsdouble(val), vp))
37042:         *vp = JSVAL_VOID;
37042: }
37042: 
38512: template<>
38512: void
38512: TypedArrayTemplate<double>::copyIndexToValue(JSContext *cx, uint32 index, jsval *vp)
38512: {
38512:     double val = getIndex(index);
38512:     if (!js_NewWeaklyRootedNumber(cx, jsdouble(val), vp))
38512:         *vp = JSVAL_VOID;
38512: }
38512: 
37042: /***
37042:  *** JS impl
37042:  ***/
37042: 
37042: /*
37042:  * ArrayBuffer (base)
37042:  */
37042: 
37042: JSClass ArrayBuffer::jsclass = {
37042:     "ArrayBuffer",
37416:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_CACHED_PROTO(JSProto_ArrayBuffer),
37042:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
37042:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, ArrayBuffer::class_finalize,
37042:     JSCLASS_NO_OPTIONAL_MEMBERS
37042: };
37042: 
37042: JSPropertySpec ArrayBuffer::jsprops[] = {
37042:     { "byteLength",
37042:       -1, JSPROP_SHARED | JSPROP_PERMANENT | JSPROP_READONLY,
37042:       ArrayBuffer::prop_getByteLength, ArrayBuffer::prop_getByteLength },
37042:     {0,0,0,0,0}
37042: };
37042: 
37042: /*
37042:  * shared TypedArray
37042:  */
37042: 
37042: JSPropertySpec TypedArray::jsprops[] = {
37042:     { js_length_str,
37042:       -1, JSPROP_SHARED | JSPROP_PERMANENT | JSPROP_READONLY,
37042:       TypedArray::prop_getLength, TypedArray::prop_getLength },
37042:     { "byteLength",
37042:       -1, JSPROP_SHARED | JSPROP_PERMANENT | JSPROP_READONLY,
37042:       TypedArray::prop_getByteLength, TypedArray::prop_getByteLength },
37042:     { "byteOffset",
37042:       -1, JSPROP_SHARED | JSPROP_PERMANENT | JSPROP_READONLY,
37042:       TypedArray::prop_getByteOffset, TypedArray::prop_getByteOffset },
37042:     { "buffer",
37042:       -1, JSPROP_SHARED | JSPROP_PERMANENT | JSPROP_READONLY,
37042:       TypedArray::prop_getBuffer, TypedArray::prop_getBuffer },
37042:     {0,0,0,0,0}
37042: };
37042: 
37042: 
37042: /*
37042:  * TypedArray boilerplate
37042:  */
37042: 
37042: #define IMPL_TYPED_ARRAY_STATICS(_typedArray)                                  \
37042: template<> JSObjectMap _typedArray::fastObjectMap(&_typedArray::fastObjectOps, \
37042:                                                   JSObjectMap::SHAPELESS);     \
37042: template<> JSObjectOps _typedArray::fastObjectOps = {                          \
37042:     &_typedArray::fastObjectMap,                                               \
37042:     _typedArray::obj_lookupProperty,                                           \
37042:     _typedArray::obj_defineProperty,                                           \
37042:     _typedArray::obj_getProperty,                                              \
37042:     _typedArray::obj_setProperty,                                              \
37042:     _typedArray::obj_getAttributes,                                            \
37042:     _typedArray::obj_setAttributes,                                            \
37042:     _typedArray::obj_deleteProperty,                                           \
37042:     js_DefaultValue,                                                           \
37042:     _typedArray::obj_enumerate,                                                \
37042:     js_CheckAccess,                                                            \
38633:     _typedArray::obj_typeOf,                                                   \
38633:     _typedArray::obj_trace,                                                    \
37042:     NULL,                                                                      \
37042:     _typedArray::obj_dropProperty,                                             \
37042:     NULL, NULL, NULL,                                                          \
37042:     NULL                                                                       \
37042: };                                                                             \
37042: template<> JSFunctionSpec _typedArray::jsfuncs[] = {                           \
37416:     JS_FN("slice", _typedArray::fun_slice, 2, 0),                              \
37042:     JS_FS_END                                                                  \
37042: }
37042: 
37042: #define IMPL_TYPED_ARRAY_SLOW_CLASS(_typedArray)                               \
37042: {                                                                              \
37042:     #_typedArray,                                                              \
37416:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_CACHED_PROTO(JSProto_##_typedArray),     \
37042:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,        \
37042:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, JS_FinalizeStub,         \
37042:     JSCLASS_NO_OPTIONAL_MEMBERS                                                \
37042: }
37042: 
37042: #define IMPL_TYPED_ARRAY_FAST_CLASS(_typedArray)                               \
37042: {                                                                              \
37042:     #_typedArray,                                                              \
37042:     JSCLASS_HAS_PRIVATE,                                                       \
37042:     JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,        \
37042:     JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub,                          \
37042:     _typedArray::class_finalize,                                               \
37042:     _typedArray::getObjectOps, NULL, NULL, NULL,                               \
37042:     NULL, NULL, NULL, NULL                                                     \
37042: }
37042: 
37042: #define INIT_TYPED_ARRAY_CLASS(_typedArray,_type)                              \
37042: do {                                                                           \
37042:     proto = js_InitClass(cx, obj, NULL,                                        \
37042:                          &TypedArray::slowClasses[TypedArray::_type],          \
37042:                          _typedArray::class_constructor, 3,                    \
37042:                          _typedArray::jsprops,                                 \
37042:                          _typedArray::jsfuncs,                                 \
37042:                          NULL, NULL);                                          \
37042:     if (!proto)                                                                \
37042:         return NULL;                                                           \
37042:     proto->setPrivate(0);                                                      \
37042: } while (0)
37042: 
37042: IMPL_TYPED_ARRAY_STATICS(Int8Array);
37042: IMPL_TYPED_ARRAY_STATICS(Uint8Array);
37042: IMPL_TYPED_ARRAY_STATICS(Int16Array);
37042: IMPL_TYPED_ARRAY_STATICS(Uint16Array);
37042: IMPL_TYPED_ARRAY_STATICS(Int32Array);
37042: IMPL_TYPED_ARRAY_STATICS(Uint32Array);
37042: IMPL_TYPED_ARRAY_STATICS(Float32Array);
38512: IMPL_TYPED_ARRAY_STATICS(Float64Array);
38514: IMPL_TYPED_ARRAY_STATICS(Uint8ClampedArray);
37042: 
37042: JSClass TypedArray::fastClasses[TYPE_MAX] = {
37042:     IMPL_TYPED_ARRAY_FAST_CLASS(Int8Array),
37042:     IMPL_TYPED_ARRAY_FAST_CLASS(Uint8Array),
37042:     IMPL_TYPED_ARRAY_FAST_CLASS(Int16Array),
37042:     IMPL_TYPED_ARRAY_FAST_CLASS(Uint16Array),
37042:     IMPL_TYPED_ARRAY_FAST_CLASS(Int32Array),
37042:     IMPL_TYPED_ARRAY_FAST_CLASS(Uint32Array),
38512:     IMPL_TYPED_ARRAY_FAST_CLASS(Float32Array),
38514:     IMPL_TYPED_ARRAY_FAST_CLASS(Float64Array),
38514:     IMPL_TYPED_ARRAY_FAST_CLASS(Uint8ClampedArray)
37042: };
37042: 
37042: JSClass TypedArray::slowClasses[TYPE_MAX] = {
37042:     IMPL_TYPED_ARRAY_SLOW_CLASS(Int8Array),
37042:     IMPL_TYPED_ARRAY_SLOW_CLASS(Uint8Array),
37042:     IMPL_TYPED_ARRAY_SLOW_CLASS(Int16Array),
37042:     IMPL_TYPED_ARRAY_SLOW_CLASS(Uint16Array),
37042:     IMPL_TYPED_ARRAY_SLOW_CLASS(Int32Array),
37042:     IMPL_TYPED_ARRAY_SLOW_CLASS(Uint32Array),
38512:     IMPL_TYPED_ARRAY_SLOW_CLASS(Float32Array),
38514:     IMPL_TYPED_ARRAY_SLOW_CLASS(Float64Array),
38514:     IMPL_TYPED_ARRAY_SLOW_CLASS(Uint8ClampedArray)
37042: };
37042: 
37416: JS_FRIEND_API(JSObject *)
37042: js_InitTypedArrayClasses(JSContext *cx, JSObject *obj)
37042: {
37416:     /* Idempotency required: we initialize several things, possibly lazily. */
37416:     JSObject *stop;
37416:     if (!js_GetClassObject(cx, obj, JSProto_ArrayBuffer, &stop))
37416:         return NULL;
37416:     if (stop)
37416:         return stop;
37416: 
37042:     JSObject *proto;
37042: 
37042:     INIT_TYPED_ARRAY_CLASS(Int8Array,TYPE_INT8);
37042:     INIT_TYPED_ARRAY_CLASS(Uint8Array,TYPE_UINT8);
37042:     INIT_TYPED_ARRAY_CLASS(Int16Array,TYPE_INT16);
37042:     INIT_TYPED_ARRAY_CLASS(Uint16Array,TYPE_UINT16);
37042:     INIT_TYPED_ARRAY_CLASS(Int32Array,TYPE_INT32);
37042:     INIT_TYPED_ARRAY_CLASS(Uint32Array,TYPE_UINT32);
37042:     INIT_TYPED_ARRAY_CLASS(Float32Array,TYPE_FLOAT32);
38512:     INIT_TYPED_ARRAY_CLASS(Float64Array,TYPE_FLOAT64);
38514:     INIT_TYPED_ARRAY_CLASS(Uint8ClampedArray,TYPE_UINT8_CLAMPED);
37042: 
37042:     proto = js_InitClass(cx, obj, NULL, &ArrayBuffer::jsclass,
37042:                          ArrayBuffer::class_constructor, 1,
37042:                          ArrayBuffer::jsprops, NULL, NULL, NULL);
37042:     if (!proto)
37042:         return NULL;
37042: 
37416:     proto->setPrivate(NULL);
37042:     return proto;
37042: }
37042: 
37042: JS_FRIEND_API(JSBool)
37042: js_IsArrayBuffer(JSObject *obj)
37042: {
37042:     return obj && obj->getClass() == &ArrayBuffer::jsclass;
37042: }
37042: 
37042: JS_FRIEND_API(JSBool)
37042: js_IsTypedArray(JSObject *obj)
37042: {
37042:     return obj &&
37042:            obj->getClass() >= &TypedArray::fastClasses[0] &&
37042:            obj->getClass() <  &TypedArray::fastClasses[TypedArray::TYPE_MAX];
37042: }
37042: 
37042: JS_FRIEND_API(JSObject *)
37042: js_CreateArrayBuffer(JSContext *cx, jsuint nbytes)
37042: {
40402:     AutoValueRooter tvr(cx);
40411:     if (!js_NewNumberInRootedValue(cx, jsdouble(nbytes), tvr.addr()))
40411:         return NULL;
37042: 
40402:     AutoValueRooter rval(cx);
40636:     if (!ArrayBuffer::create(cx, NULL, 1, tvr.addr(), rval.addr()))
37042:         return NULL;
37042: 
37042:     return JSVAL_TO_OBJECT(rval.value());
37042: }
37042: 
40294: static inline JSBool
37042: TypedArrayConstruct(JSContext *cx, jsint atype, uintN argc, jsval *argv, jsval *rv)
37042: {
37042:     switch (atype) {
37042:       case TypedArray::TYPE_INT8:
40636:         return !!Int8Array::create(cx, NULL, argc, argv, rv);
37042: 
37042:       case TypedArray::TYPE_UINT8:
40636:         return !!Uint8Array::create(cx, NULL, argc, argv, rv);
37042: 
37042:       case TypedArray::TYPE_INT16:
40636:         return !!Int16Array::create(cx, NULL, argc, argv, rv);
37042: 
37042:       case TypedArray::TYPE_UINT16:
40636:         return !!Uint16Array::create(cx, NULL, argc, argv, rv);
37042: 
37042:       case TypedArray::TYPE_INT32:
40636:         return !!Int32Array::create(cx, NULL, argc, argv, rv);
37042: 
37042:       case TypedArray::TYPE_UINT32:
40636:         return !!Uint32Array::create(cx, NULL, argc, argv, rv);
37042: 
37042:       case TypedArray::TYPE_FLOAT32:
40636:         return !!Float32Array::create(cx, NULL, argc, argv, rv);
37042: 
38512:       case TypedArray::TYPE_FLOAT64:
40636:         return !!Float64Array::create(cx, NULL, argc, argv, rv);
38512: 
38514:       case TypedArray::TYPE_UINT8_CLAMPED:
40636:         return !!Uint8ClampedArray::create(cx, NULL, argc, argv, rv);
38514: 
37042:       default:
37042:         JS_NOT_REACHED("shouldn't have gotten here");
37498:         return false;
37042:     }
37042: }
37042: 
37042: JS_FRIEND_API(JSObject *)
37042: js_CreateTypedArray(JSContext *cx, jsint atype, jsuint nelements)
37042: {
37042:     JS_ASSERT(atype >= 0 && atype < TypedArray::TYPE_MAX);
37042: 
40791:     jsval vals[2] = { JSVAL_NULL, JSVAL_NULL };
40402:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(vals), vals);
37042: 
37042:     if (!js_NewNumberInRootedValue(cx, jsdouble(nelements), &vals[0]))
37042:         return NULL;
37042: 
37042:     if (!TypedArrayConstruct(cx, atype, 1, &vals[0], &vals[1]))
37042:         return NULL;
37042: 
37042:     return JSVAL_TO_OBJECT(vals[1]);
37042: }
37042: 
37042: JS_FRIEND_API(JSObject *)
37042: js_CreateTypedArrayWithArray(JSContext *cx, jsint atype, JSObject *arrayArg)
37042: {
37042:     JS_ASSERT(atype >= 0 && atype < TypedArray::TYPE_MAX);
37042: 
40791:     jsval vals[2] = { JSVAL_NULL, JSVAL_NULL };
40402:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(vals), vals);
37042: 
37042:     vals[0] = OBJECT_TO_JSVAL(arrayArg);
37042: 
37042:     if (!TypedArrayConstruct(cx, atype, 1, &vals[0], &vals[1]))
37042:         return NULL;
37042: 
37042:     return JSVAL_TO_OBJECT(vals[1]);
37042: }
37042: 
37042: JS_FRIEND_API(JSObject *)
37042: js_CreateTypedArrayWithBuffer(JSContext *cx, jsint atype, JSObject *bufArg,
37042:                               jsint byteoffset, jsint length)
37042: {
37042:     JS_ASSERT(atype >= 0 && atype < TypedArray::TYPE_MAX);
37042:     JS_ASSERT(bufArg && ArrayBuffer::fromJSObject(bufArg));
40411:     JS_ASSERT_IF(byteoffset < 0, length < 0);
37042: 
40791:     jsval vals[4] = { JSVAL_NULL, JSVAL_NULL, JSVAL_NULL, JSVAL_NULL };
40402:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(vals), vals);
37042: 
37042:     int argc = 1;
37042:     vals[0] = OBJECT_TO_JSVAL(bufArg);
37042: 
37042:     if (byteoffset >= 0) {
40411:         if (!js_NewNumberInRootedValue(cx, jsdouble(byteoffset), &vals[argc]))
40411:             return NULL;
40411: 
37042:         argc++;
37042:     }
37042: 
37042:     if (length >= 0) {
40411:         if (!js_NewNumberInRootedValue(cx, jsdouble(length), &vals[argc]))
40411:             return NULL;
40411: 
37042:         argc++;
37042:     }
37042: 
37042:     if (!TypedArrayConstruct(cx, atype, argc, &vals[0], &vals[3]))
37042:         return NULL;
37042: 
37042:     return JSVAL_TO_OBJECT(vals[3]);
37042: }
37042: 
40555: JS_FRIEND_API(JSBool)
40555: js_ReparentTypedArrayToScope(JSContext *cx, JSObject *obj, JSObject *scope)
40555: {
40555:     scope = JS_GetGlobalForObject(cx, scope);
40555:     if (!scope)
40555:         return JS_FALSE;
40555: 
40555:     if (!js_IsTypedArray(obj))
40555:         return JS_FALSE;
40555: 
40555:     TypedArray *typedArray = TypedArray::fromJSObject(obj);
40555: 
40555:     JSObject *buffer = typedArray->bufferJS;
40555:     JS_ASSERT(js_IsArrayBuffer(buffer));
40555: 
40555:     JSObject *proto;
40555:     JSProtoKey key =
40555:         JSCLASS_CACHED_PROTO_KEY(&TypedArray::slowClasses[typedArray->type]);
40555:     if (!js_GetClassPrototype(cx, scope, key, &proto))
40555:         return JS_FALSE;
40555: 
40555:     obj->setProto(proto);
40555:     obj->setParent(scope);
40555: 
40555:     key = JSCLASS_CACHED_PROTO_KEY(&ArrayBuffer::jsclass);
40555:     if (!js_GetClassPrototype(cx, scope, key, &proto))
40555:         return JS_FALSE;
40555: 
40555:     buffer->setProto(proto);
40555:     buffer->setParent(scope);
40555: 
40555:     return JS_TRUE;
40555: }
