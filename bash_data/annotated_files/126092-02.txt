     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim: set ts=2 sw=2 et tw=80: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #include "nsCOMPtr.h"
     1: #include "nsTableFrame.h"
 68481: #include "nsRenderingContext.h"
     1: #include "nsStyleContext.h"
     1: #include "nsStyleConsts.h"
     1: #include "nsIContent.h"
     1: #include "nsCellMap.h"
     1: #include "nsTableCellFrame.h"
     1: #include "nsHTMLParts.h"
     1: #include "nsTableColFrame.h"
     1: #include "nsTableColGroupFrame.h"
     1: #include "nsTableRowFrame.h"
     1: #include "nsTableRowGroupFrame.h"
     1: #include "nsTableOuterFrame.h"
     1: #include "nsTablePainter.h"
     1: 
     1: #include "BasicTableLayoutStrategy.h"
     1: #include "FixedTableLayoutStrategy.h"
     1: 
     1: #include "nsPresContext.h"
     1: #include "nsCSSRendering.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsCSSAnonBoxes.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIDOMHTMLElement.h"
     1: #include "nsIDOMHTMLBodyElement.h"
     1: #include "nsFrameManager.h"
108290: #include "nsError.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsCSSFrameConstructor.h"
     1: #include "nsStyleSet.h"
     1: #include "nsDisplayList.h"
 35706: #include "nsIScrollableFrame.h"
 40181: #include "nsCSSProps.h"
120353: #include "mozilla/Likely.h"
124775: #include <cstdlib> // for std::abs(int/long)
124775: #include <cmath> // for std::abs(float/double)
     1: 
 39965: using namespace mozilla;
 88122: using namespace mozilla::layout;
 39965: 
     1: /********************************************************************************
     1:  ** nsTableReflowState                                                         **
     1:  ********************************************************************************/
     1: 
     1: struct nsTableReflowState {
     1: 
     1:   // the real reflow state
     1:   const nsHTMLReflowState& reflowState;
     1: 
     1:   // The table's available size
     1:   nsSize availSize;
     1: 
     1:   // Stationary x-offset
     1:   nscoord x;
     1: 
     1:   // Running y-offset
     1:   nscoord y;
     1: 
     1:   nsTableReflowState(nsPresContext&           aPresContext,
     1:                      const nsHTMLReflowState& aReflowState,
     1:                      nsTableFrame&            aTableFrame,
     1:                      nscoord                  aAvailWidth,
     1:                      nscoord                  aAvailHeight)
     1:     : reflowState(aReflowState)
     1:   {
     1:     Init(aPresContext, aTableFrame, aAvailWidth, aAvailHeight);
     1:   }
     1: 
     1:   void Init(nsPresContext&  aPresContext,
     1:             nsTableFrame&   aTableFrame,
     1:             nscoord         aAvailWidth,
     1:             nscoord         aAvailHeight)
     1:   {
     1:     nsTableFrame* table = (nsTableFrame*)aTableFrame.GetFirstInFlow();
     1:     nsMargin borderPadding = table->GetChildAreaOffset(&reflowState);
     1:     nscoord cellSpacingX = table->GetCellSpacingX();
     1: 
     1:     x = borderPadding.left + cellSpacingX;
     1:     y = borderPadding.top; //cellspacing added during reflow
     1: 
     1:     availSize.width  = aAvailWidth;
     1:     if (NS_UNCONSTRAINEDSIZE != availSize.width) {
     1:       availSize.width -= borderPadding.left + borderPadding.right
     1:                          + (2 * cellSpacingX);
 32531:       availSize.width = NS_MAX(0, availSize.width);
     1:     }
     1: 
     1:     availSize.height = aAvailHeight;
     1:     if (NS_UNCONSTRAINEDSIZE != availSize.height) {
     1:       availSize.height -= borderPadding.top + borderPadding.bottom
     1:                           + (2 * table->GetCellSpacingY());
 32531:       availSize.height = NS_MAX(0, availSize.height);
     1:     }
     1:   }
     1: 
     1:   nsTableReflowState(nsPresContext&           aPresContext,
     1:                      const nsHTMLReflowState& aReflowState,
     1:                      nsTableFrame&            aTableFrame)
     1:     : reflowState(aReflowState)
     1:   {
     1:     Init(aPresContext, aTableFrame, aReflowState.availableWidth, aReflowState.availableHeight);
     1:   }
     1: 
     1: };
     1: 
     1: /********************************************************************************
     1:  ** nsTableFrame                                                               **
     1:  ********************************************************************************/
     1: 
     1: struct BCPropertyData
     1: {
 82828:   BCPropertyData() : mTopBorderWidth(0), mRightBorderWidth(0),
 82828:                      mBottomBorderWidth(0), mLeftBorderWidth(0),
 82828:                      mLeftCellBorderWidth(0), mRightCellBorderWidth(0) {}
 87904:   nsIntRect mDamageArea;
     1:   BCPixelSize mTopBorderWidth;
     1:   BCPixelSize mRightBorderWidth;
     1:   BCPixelSize mBottomBorderWidth;
     1:   BCPixelSize mLeftBorderWidth;
 24768:   BCPixelSize mLeftCellBorderWidth;
 24768:   BCPixelSize mRightCellBorderWidth;
     1: };
     1: 
 78202: nsIFrame*
 90155: nsTableFrame::GetParentStyleContextFrame() const
     1: {
     1:   // Since our parent, the table outer frame, returned this frame, we
     1:   // must return whatever our parent would normally have returned.
     1: 
     1:   NS_PRECONDITION(mParent, "table constructed without outer table");
 34387:   if (!mContent->GetParent() && !GetStyleContext()->GetPseudo()) {
  1270:     // We're the root.  We have no style context parent.
106838:     return nullptr;
 78202:   }
 78202: 
 78202:   return static_cast<nsFrame*>(GetParent())->DoGetParentStyleContextFrame();
     1: }
     1: 
     1: 
     1: nsIAtom*
     1: nsTableFrame::GetType() const
     1: {
     1:   return nsGkAtoms::tableFrame;
     1: }
     1: 
     1: 
     1: nsTableFrame::nsTableFrame(nsStyleContext* aContext)
 86231:   : nsContainerFrame(aContext),
106838:     mCellMap(nullptr),
106838:     mTableLayoutStrategy(nullptr)
     1: {
 87442:   memset(&mBits, 0, sizeof(mBits));
     1: }
     1: 
 23554: NS_QUERYFRAME_HEAD(nsTableFrame)
 86231: NS_QUERYFRAME_TAIL_INHERITING(nsContainerFrame)
     1: 
     1: NS_IMETHODIMP
     1: nsTableFrame::Init(nsIContent*      aContent,
     1:                    nsIFrame*        aParent,
     1:                    nsIFrame*        aPrevInFlow)
     1: {
 87444:   NS_PRECONDITION(!mCellMap, "Init called twice");
 87444:   NS_PRECONDITION(!aPrevInFlow ||
 87444:                   aPrevInFlow->GetType() == nsGkAtoms::tableFrame,
 87444:                   "prev-in-flow must be of same type");
     1: 
     1:   // Let the base class do its processing
 87444:   nsresult rv = nsContainerFrame::Init(aContent, aParent, aPrevInFlow);
     1: 
     1:   // see if border collapse is on, if so set it
     1:   const nsStyleTableBorder* tableStyle = GetStyleTableBorder();
 79445:   bool borderCollapse = (NS_STYLE_BORDER_COLLAPSE == tableStyle->mBorderCollapse);
     1:   SetBorderCollapse(borderCollapse);
 89904: 
 87444:   // Create the cell map if this frame is the first-in-flow.
     1:   if (!aPrevInFlow) {
     1:     mCellMap = new nsTableCellMap(*this, borderCollapse);
     1:     if (!mCellMap)
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1: 
     1:   if (aPrevInFlow) {
     1:     // set my width, because all frames in a table flow are the same width and
     1:     // code in nsTableOuterFrame depends on this being set
     1:     mRect.width = aPrevInFlow->GetSize().width;
     1:   }
     1:   else {
     1:     NS_ASSERTION(!mTableLayoutStrategy, "strategy was created before Init was called");
     1:     // create the strategy
     1:     if (IsAutoLayout())
     1:       mTableLayoutStrategy = new BasicTableLayoutStrategy(this);
     1:     else
     1:       mTableLayoutStrategy = new FixedTableLayoutStrategy(this);
     1:     if (!mTableLayoutStrategy)
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsTableFrame::~nsTableFrame()
     1: {
     1:   delete mCellMap;
     1:   delete mTableLayoutStrategy;
     1: }
     1: 
     1: void
 36647: nsTableFrame::DestroyFrom(nsIFrame* aDestructRoot)
 36647: {
 36647:   mColGroups.DestroyFramesFrom(aDestructRoot);
 86231:   nsContainerFrame::DestroyFrom(aDestructRoot);
     1: }
     1: 
     1: // Make sure any views are positioned properly
     1: void
     1: nsTableFrame::RePositionViews(nsIFrame* aFrame)
     1: {
     1:   nsContainerFrame::PositionFrameView(aFrame);
     1:   nsContainerFrame::PositionChildViews(aFrame);
     1: }
     1: 
 79445: static bool
     1: IsRepeatedFrame(nsIFrame* kidFrame)
     1: {
     1:   return (kidFrame->GetType() == nsGkAtoms::tableRowFrame ||
     1:           kidFrame->GetType() == nsGkAtoms::tableRowGroupFrame) &&
     1:          (kidFrame->GetStateBits() & NS_REPEATED_ROW_OR_ROWGROUP);
     1: }
     1: 
 79445: bool
 42270: nsTableFrame::PageBreakAfter(nsIFrame* aSourceFrame,
     1:                              nsIFrame* aNextFrame)
     1: {
 42270:   const nsStyleDisplay* display = aSourceFrame->GetStyleDisplay();
 42270:   nsTableRowGroupFrame* prevRg = do_QueryFrame(aSourceFrame);
     1:   // don't allow a page break after a repeated element ...
 42878:   if ((display->mBreakAfter || (prevRg && prevRg->HasInternalBreakAfter())) &&
 42270:       !IsRepeatedFrame(aSourceFrame)) {
     1:     return !(aNextFrame && IsRepeatedFrame(aNextFrame)); // or before
     1:   }
     1: 
     1:   if (aNextFrame) {
     1:     display = aNextFrame->GetStyleDisplay();
     1:     // don't allow a page break before a repeated element ...
 42270:      nsTableRowGroupFrame* nextRg = do_QueryFrame(aNextFrame);
 42878:     if ((display->mBreakBefore ||
 42878:         (nextRg && nextRg->HasInternalBreakBefore())) &&
 42270:         !IsRepeatedFrame(aNextFrame)) {
 42270:       return !IsRepeatedFrame(aSourceFrame); // or after
     1:     }
     1:   }
 80486:   return false;
     1: }
     1: 
     1: // XXX this needs to be cleaned up so that the frame constructor breaks out col group
     1: // frames into a separate child list, bug 343048.
     1: NS_IMETHODIMP
 77154: nsTableFrame::SetInitialChildList(ChildListID     aListID,
 30790:                                   nsFrameList&    aChildList)
     1: {
     1: 
     1:   if (!mFrames.IsEmpty() || !mColGroups.IsEmpty()) {
     1:     // We already have child frames which means we've already been
     1:     // initialized
     1:     NS_NOTREACHED("unexpected second call to SetInitialChildList");
     1:     return NS_ERROR_UNEXPECTED;
     1:   }
 77154:   if (aListID != kPrincipalList) {
 77154:     // All we know about is the principal child list.
     1:     NS_NOTREACHED("unknown frame list");
     1:     return NS_ERROR_INVALID_ARG;
     1:   }
     1: 
 30790:   // XXXbz the below code is an icky cesspit that's only needed in its current
 30790:   // form for two reasons:
 30790:   // 1) Both rowgroups and column groups come in on the principal child list.
 32843:   while (aChildList.NotEmpty()) {
 30790:     nsIFrame* childFrame = aChildList.FirstChild();
 32843:     aChildList.RemoveFirstChild();
     1:     const nsStyleDisplay* childDisplay = childFrame->GetStyleDisplay();
 30790: 
 32843:     if (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == childDisplay->mDisplay) {
     1:       NS_ASSERTION(nsGkAtoms::tableColGroupFrame == childFrame->GetType(),
     1:                    "This is not a colgroup");
106838:       mColGroups.AppendFrame(nullptr, childFrame);
 32843:     }
 32843:     else { // row groups and unknown frames go on the main list for now
106838:       mFrames.AppendFrame(nullptr, childFrame);
     1:     }
 30790:   }
     1: 
     1:   // If we have a prev-in-flow, then we're a table that has been split and
     1:   // so don't treat this like an append
     1:   if (!GetPrevInFlow()) {
     1:     // process col groups first so that real cols get constructed before
     1:     // anonymous ones due to cells in rows.
 30941:     InsertColGroups(0, mColGroups);
 30941:     InsertRowGroups(mFrames);
 16346:     // calc collapsing borders
 16346:     if (IsBorderCollapse()) {
 82828:       SetFullBCDamageArea();
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void nsTableFrame::AttributeChangedFor(nsIFrame*       aFrame,
     1:                                        nsIContent*     aContent,
     1:                                        nsIAtom*        aAttribute)
     1: {
 26583:   nsTableCellFrame *cellFrame = do_QueryFrame(aFrame);
 26583:   if (cellFrame) {
     1:     if ((nsGkAtoms::rowspan == aAttribute) ||
     1:         (nsGkAtoms::colspan == aAttribute)) {
     1:       nsTableCellMap* cellMap = GetCellMap();
     1:       if (cellMap) {
     1:         // for now just remove the cell from the map and reinsert it
108991:         int32_t rowIndex, colIndex;
     1:         cellFrame->GetRowIndex(rowIndex);
     1:         cellFrame->GetColIndex(colIndex);
     1:         RemoveCell(cellFrame, rowIndex);
 24724:         nsAutoTArray<nsTableCellFrame*, 1> cells;
     1:         cells.AppendElement(cellFrame);
     1:         InsertCells(cells, rowIndex, colIndex - 1);
     1: 
     1:         // XXX Should this use eStyleChange?  It currently doesn't need
     1:         // to, but it might given more optimization.
  1158:         PresContext()->PresShell()->
  1158:           FrameNeedsReflow(this, nsIPresShell::eTreeChange, NS_FRAME_IS_DIRTY);
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: 
     1: /* ****** CellMap methods ******* */
     1: 
     1: /* return the effective col count */
108991: int32_t nsTableFrame::GetEffectiveColCount() const
108991: {
108991:   int32_t colCount = GetColCount();
 19643:   if (LayoutStrategy()->GetType() == nsITableLayoutStrategy::Auto) {
 19643:     nsTableCellMap* cellMap = GetCellMap();
 19643:     if (!cellMap) {
 19643:       return 0;
 19643:     }
     1:     // don't count cols at the end that don't have originating cells
108991:     for (int32_t colX = colCount - 1; colX >= 0; colX--) {
 19643:       if (cellMap->GetNumCellsOriginatingInCol(colX) > 0) {
 19643:         break;
 19643:       }
     1:       colCount--;
     1:     }
     1:   }
     1:   return colCount;
     1: }
     1: 
108991: int32_t nsTableFrame::GetIndexOfLastRealCol()
108991: {
108991:   int32_t numCols = mColFrames.Length();
     1:   if (numCols > 0) {
108991:     for (int32_t colX = numCols - 1; colX >= 0; colX--) {
     1:       nsTableColFrame* colFrame = GetColFrame(colX);
     1:       if (colFrame) {
     1:         if (eColAnonymousCell != colFrame->GetColType()) {
     1:           return colX;
     1:         }
     1:       }
     1:     }
     1:   }
     1:   return -1;
     1: }
     1: 
     1: nsTableColFrame*
108991: nsTableFrame::GetColFrame(int32_t aColIndex) const
     1: {
     1:   NS_ASSERTION(!GetPrevInFlow(), "GetColFrame called on next in flow");
108991:   int32_t numCols = mColFrames.Length();
     1:   if ((aColIndex >= 0) && (aColIndex < numCols)) {
 24724:     return mColFrames.ElementAt(aColIndex);
     1:   }
     1:   else {
     1:     NS_ERROR("invalid col index");
106838:     return nullptr;
     1:   }
     1: }
     1: 
108991: int32_t nsTableFrame::GetEffectiveRowSpan(int32_t                 aRowIndex,
     1:                                           const nsTableCellFrame& aCell) const
     1: {
     1:   nsTableCellMap* cellMap = GetCellMap();
106838:   NS_PRECONDITION (nullptr != cellMap, "bad call, cellMap not yet allocated.");
     1: 
108991:   int32_t colIndex;
     1:   aCell.GetColIndex(colIndex);
     1:   return cellMap->GetEffectiveRowSpan(aRowIndex, colIndex);
     1: }
     1: 
108991: int32_t nsTableFrame::GetEffectiveRowSpan(const nsTableCellFrame& aCell,
     1:                                           nsCellMap*              aCellMap)
     1: {
     1:   nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT1(1);
     1: 
108991:   int32_t colIndex, rowIndex;
     1:   aCell.GetColIndex(colIndex);
     1:   aCell.GetRowIndex(rowIndex);
     1: 
     1:   if (aCellMap)
 80486:     return aCellMap->GetRowSpan(rowIndex, colIndex, true);
     1:   else
     1:     return tableCellMap->GetEffectiveRowSpan(rowIndex, colIndex);
     1: }
     1: 
108991: int32_t nsTableFrame::GetEffectiveColSpan(const nsTableCellFrame& aCell,
     1:                                           nsCellMap*              aCellMap) const
     1: {
     1:   nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT1(1);
     1: 
108991:   int32_t colIndex, rowIndex;
     1:   aCell.GetColIndex(colIndex);
     1:   aCell.GetRowIndex(rowIndex);
 79445:   bool ignore;
     1: 
     1:   if (aCellMap)
     1:     return aCellMap->GetEffectiveColSpan(*tableCellMap, rowIndex, colIndex, ignore);
     1:   else
     1:     return tableCellMap->GetEffectiveColSpan(rowIndex, colIndex);
     1: }
     1: 
108991: bool nsTableFrame::HasMoreThanOneCell(int32_t aRowIndex) const
     1: {
     1:   nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT1(1);
     1:   return tableCellMap->HasMoreThanOneCell(aRowIndex);
     1: }
     1: 
108991: void nsTableFrame::AdjustRowIndices(int32_t         aRowIndex,
108991:                                     int32_t         aAdjustment)
     1: {
     1:   // Iterate over the row groups and adjust the row indices of all rows
     1:   // whose index is >= aRowIndex.
  2141:   RowGroupArray rowGroups;
  2141:   OrderRowGroups(rowGroups);
  2141: 
108991:   for (uint32_t rgX = 0; rgX < rowGroups.Length(); rgX++) {
  2141:     rowGroups[rgX]->AdjustRowIndices(aRowIndex, aAdjustment);
     1:   }
     1: }
     1: 
     1: 
 30941: void nsTableFrame::ResetRowIndices(const nsFrameList::Slice& aRowGroupsToExclude)
     1: {
     1:   // Iterate over the row groups and adjust the row indices of all rows
     1:   // omit the rowgroups that will be inserted later
  2141:   RowGroupArray rowGroups;
  2141:   OrderRowGroups(rowGroups);
     1: 
108991:   int32_t rowIndex = 0;
 37262:   nsTHashtable<nsPtrHashKey<nsTableRowGroupFrame> > excludeRowGroups;
 98908:   excludeRowGroups.Init();
 30941:   nsFrameList::Enumerator excludeRowGroupsEnumerator(aRowGroupsToExclude);
 37262:   while (!excludeRowGroupsEnumerator.AtEnd()) {
 37262:     excludeRowGroups.PutEntry(static_cast<nsTableRowGroupFrame*>(excludeRowGroupsEnumerator.get()));
 30941:     excludeRowGroupsEnumerator.Next();
     1:   }
     1: 
108991:   for (uint32_t rgX = 0; rgX < rowGroups.Length(); rgX++) {
  2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
 37262:     if (!excludeRowGroups.GetEntry(rgFrame)) {
 77154:       const nsFrameList& rowFrames = rgFrame->PrincipalChildList();
 30941:       for (nsFrameList::Enumerator rows(rowFrames); !rows.AtEnd(); rows.Next()) {
 30941:         if (NS_STYLE_DISPLAY_TABLE_ROW==rows.get()->GetStyleDisplay()->mDisplay) {
 30941:           ((nsTableRowFrame *)rows.get())->SetRowIndex(rowIndex);
     1:           rowIndex++;
     1:         }
     1:       }
     1:     }
     1:   }
     1: }
108991: void nsTableFrame::InsertColGroups(int32_t                   aStartColIndex,
 30941:                                    const nsFrameList::Slice& aColGroups)
     1: {
108991:   int32_t colIndex = aStartColIndex;
 30941:   nsFrameList::Enumerator colGroups(aColGroups);
 30941:   for (; !colGroups.AtEnd(); colGroups.Next()) {
100081:     MOZ_ASSERT(colGroups.get()->GetType() == nsGkAtoms::tableColGroupFrame);
 30941:     nsTableColGroupFrame* cgFrame =
 30941:       static_cast<nsTableColGroupFrame*>(colGroups.get());
     1:     cgFrame->SetStartColumnIndex(colIndex);
 30941:     // XXXbz this sucks.  AddColsToTable will actually remove colgroups from
 30941:     // the list we're traversing!  Need to fix things here.  :( I guess this is
 30941:     // why the old code used pointer-to-last-frame as opposed to
 30941:     // pointer-to-frame-after-last....
 30941: 
 30941:     // How about dealing with this by storing a const reference to the
 30941:     // mNextSibling of the framelist's last frame, instead of storing a pointer
 30941:     // to the first-after-next frame?  Will involve making nsFrameList friend
 30941:     // of nsIFrame, but it's time for that anyway.
 80486:     cgFrame->AddColsToTable(colIndex, false,
 77154:                               colGroups.get()->PrincipalChildList());
108991:     int32_t numCols = cgFrame->GetColCount();
     1:     colIndex += numCols;
     1:   }
 30941: 
 30941:   nsFrameList::Enumerator remainingColgroups = colGroups.GetUnlimitedEnumerator();
 30941:   if (!remainingColgroups.AtEnd()) {
 30941:     nsTableColGroupFrame::ResetColIndices(
 30941:       static_cast<nsTableColGroupFrame*>(remainingColgroups.get()), colIndex);
     1:   }
     1: }
     1: 
     1: void nsTableFrame::InsertCol(nsTableColFrame& aColFrame,
108991:                              int32_t          aColIndex)
     1: {
 24724:   mColFrames.InsertElementAt(aColIndex, &aColFrame);
     1:   nsTableColType insertedColType = aColFrame.GetColType();
108991:   int32_t numCacheCols = mColFrames.Length();
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   if (cellMap) {
108991:     int32_t numMapCols = cellMap->GetColCount();
     1:     if (numCacheCols > numMapCols) {
 79445:       bool removedFromCache = false;
     1:       if (eColAnonymousCell != insertedColType) {
 24724:         nsTableColFrame* lastCol = mColFrames.ElementAt(numCacheCols - 1);
     1:         if (lastCol) {
     1:           nsTableColType lastColType = lastCol->GetColType();
     1:           if (eColAnonymousCell == lastColType) {
     1:             // remove the col from the cache
     1:             mColFrames.RemoveElementAt(numCacheCols - 1);
     1:             // remove the col from the eColGroupAnonymousCell col group
     1:             nsTableColGroupFrame* lastColGroup = (nsTableColGroupFrame *)mColGroups.LastChild();
     1:             if (lastColGroup) {
 80486:               lastColGroup->RemoveChild(*lastCol, false);
 62632: 
     1:               // remove the col group if it is empty
     1:               if (lastColGroup->GetColCount() <= 0) {
     1:                 mColGroups.DestroyFrame((nsIFrame*)lastColGroup);
     1:               }
 62632:             }
 80486:             removedFromCache = true;
     1:           }
     1:         }
     1:       }
     1:       if (!removedFromCache) {
     1:         cellMap->AddColsAtEnd(1);
     1:       }
     1:     }
     1:   }
     1:   // for now, just bail and recalc all of the collapsing borders
     1:   if (IsBorderCollapse()) {
 87904:     nsIntRect damageArea(aColIndex, 0, 1, GetRowCount());
 82828:     AddBCDamageArea(damageArea);
     1:   }
     1: }
     1: 
     1: void nsTableFrame::RemoveCol(nsTableColGroupFrame* aColGroupFrame,
108991:                              int32_t               aColIndex,
 79445:                              bool                  aRemoveFromCache,
 79445:                              bool                  aRemoveFromCellMap)
     1: {
     1:   if (aRemoveFromCache) {
     1:     mColFrames.RemoveElementAt(aColIndex);
     1:   }
     1:   if (aRemoveFromCellMap) {
     1:     nsTableCellMap* cellMap = GetCellMap();
     1:     if (cellMap) {
 30207:       AppendAnonymousColFrames(1);
     1:     }
     1:   }
     1:   // for now, just bail and recalc all of the collapsing borders
     1:   if (IsBorderCollapse()) {
 87904:     nsIntRect damageArea(0, 0, GetColCount(), GetRowCount());
 82828:     AddBCDamageArea(damageArea);
     1:   }
     1: }
     1: 
     1: /** Get the cell map for this table frame.  It is not always mCellMap.
     1:   * Only the firstInFlow has a legit cell map
     1:   */
     1: nsTableCellMap* nsTableFrame::GetCellMap() const
     1: {
     1:   nsTableFrame* firstInFlow = (nsTableFrame *)GetFirstInFlow();
     1:   return firstInFlow->mCellMap;
     1: }
     1: 
     1: // XXX this needs to be moved to nsCSSFrameConstructor
     1: nsTableColGroupFrame*
     1: nsTableFrame::CreateAnonymousColGroupFrame(nsTableColGroupType aColGroupType)
     1: {
     1:   nsIContent* colGroupContent = GetContent();
   238:   nsPresContext* presContext = PresContext();
     1:   nsIPresShell *shell = presContext->PresShell();
     1: 
     1:   nsRefPtr<nsStyleContext> colGroupStyle;
 35554:   colGroupStyle = shell->StyleSet()->
 35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::tableColGroup, mStyleContext);
     1:   // Create a col group frame
     1:   nsIFrame* newFrame = NS_NewTableColGroupFrame(shell, colGroupStyle);
     1:   if (newFrame) {
     1:     ((nsTableColGroupFrame *)newFrame)->SetColType(aColGroupType);
106838:     newFrame->Init(colGroupContent, this, nullptr);
     1:   }
     1:   return (nsTableColGroupFrame *)newFrame;
     1: }
     1: 
     1: void
108991: nsTableFrame::AppendAnonymousColFrames(int32_t aNumColsToAdd)
 30207: {
     1:   // get the last col group frame
 30786:   nsTableColGroupFrame* colGroupFrame =
 30786:     static_cast<nsTableColGroupFrame*>(mColGroups.LastChild());
 30786: 
 30786:   if (!colGroupFrame ||
 30786:       (colGroupFrame->GetColType() != eColGroupAnonymousCell)) {
108991:     int32_t colIndex = (colGroupFrame) ?
 30207:                         colGroupFrame->GetStartColumnIndex() +
 30207:                         colGroupFrame->GetColCount() : 0;
 30207:     colGroupFrame = CreateAnonymousColGroupFrame(eColGroupAnonymousCell);
     1:     if (!colGroupFrame) {
     1:       return;
     1:     }
 30207:     // add the new frame to the child list
 30207:     mColGroups.AppendFrame(this, colGroupFrame);
     1:     colGroupFrame->SetStartColumnIndex(colIndex);
     1:   }
 30786:   AppendAnonymousColFrames(colGroupFrame, aNumColsToAdd, eColAnonymousCell,
 80486:                            true);
 30207: 
     1: }
     1: 
     1: // XXX this needs to be moved to nsCSSFrameConstructor
     1: // Right now it only creates the col frames at the end
     1: void
 30786: nsTableFrame::AppendAnonymousColFrames(nsTableColGroupFrame* aColGroupFrame,
108991:                                        int32_t               aNumColsToAdd,
     1:                                        nsTableColType        aColType,
 79445:                                        bool                  aAddToTable)
     1: {
     1:   NS_PRECONDITION(aColGroupFrame, "null frame");
  8770:   NS_PRECONDITION(aColType != eColAnonymousCol, "Shouldn't happen");
  8770: 
 30786:   nsIPresShell *shell = PresContext()->PresShell();
     1: 
     1:   // Get the last col frame
 32843:   nsFrameList newColFrames;
     1: 
108991:   int32_t startIndex = mColFrames.Length();
108991:   int32_t lastIndex  = startIndex + aNumColsToAdd - 1;
108991: 
108991:   for (int32_t childX = startIndex; childX <= lastIndex; childX++) {
     1:     nsIContent* iContent;
     1:     nsRefPtr<nsStyleContext> styleContext;
     1:     nsStyleContext* parentStyleContext;
     1: 
  8770:     // all anonymous cols that we create here use a pseudo style context of the
  8770:     // col group
     1:     iContent = aColGroupFrame->GetContent();
     1:     parentStyleContext = aColGroupFrame->GetStyleContext();
 35554:     styleContext = shell->StyleSet()->
 35554:       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::tableCol, parentStyleContext);
     1:     // ASSERTION to check for bug 54454 sneaking back in...
     1:     NS_ASSERTION(iContent, "null content in CreateAnonymousColFrames");
     1: 
     1:     // create the new col frame
     1:     nsIFrame* colFrame = NS_NewTableColFrame(shell, styleContext);
     1:     ((nsTableColFrame *) colFrame)->SetColType(aColType);
106838:     colFrame->Init(iContent, aColGroupFrame, nullptr);
106838: 
106838:     newColFrames.AppendFrame(nullptr, colFrame);
 30786:   }
 30786:   nsFrameList& cols = aColGroupFrame->GetWritableChildList();
 30786:   nsIFrame* oldLastCol = cols.LastChild();
 30941:   const nsFrameList::Slice& newCols =
106838:     cols.InsertFrames(nullptr, oldLastCol, newColFrames);
 30786:   if (aAddToTable) {
     1:     // get the starting col index in the cache
108991:     int32_t startColIndex;
 30786:     if (oldLastCol) {
 30786:       startColIndex =
 30786:         static_cast<nsTableColFrame*>(oldLastCol)->GetColIndex() + 1;
 30786:     } else {
 30786:       startColIndex = aColGroupFrame->GetStartColumnIndex();
 30786:     }
 30786: 
 80486:     aColGroupFrame->AddColsToTable(startColIndex, true, newCols);
     1:   }
     1: }
     1: 
     1: void
     1: nsTableFrame::MatchCellMapToColCache(nsTableCellMap* aCellMap)
     1: {
108991:   int32_t numColsInMap   = GetColCount();
108991:   int32_t numColsInCache = mColFrames.Length();
108991:   int32_t numColsToAdd = numColsInMap - numColsInCache;
     1:   if (numColsToAdd > 0) {
     1:     // this sets the child list, updates the col cache and cell map
 30207:     AppendAnonymousColFrames(numColsToAdd);
     1:   }
     1:   if (numColsToAdd < 0) {
108991:     int32_t numColsNotRemoved = DestroyAnonymousColFrames(-numColsToAdd);
     1:     // if the cell map has fewer cols than the cache, correct it
     1:     if (numColsNotRemoved > 0) {
     1:       aCellMap->AddColsAtEnd(numColsNotRemoved);
     1:     }
     1:   }
     1:   if (numColsToAdd && HasZeroColSpans()) {
 80486:     SetNeedColSpanExpansion(true);
     1:   }
     1:   if (NeedColSpanExpansion()) {
     1:     // This flag can be set in two ways -- either by changing
     1:     // the number of columns (that happens in the block above),
     1:     // or by adding a cell with colspan="0" to the cellmap.  To
     1:     // handle the latter case we need to explicitly check the
     1:     // flag here -- it may be set even if the number of columns
     1:     // did not change.
     1:     //
     1:     // @see nsCellMap::AppendCell
     1: 
     1:     aCellMap->ExpandZeroColSpans();
     1:   }
     1: }
     1: 
     1: void
     1: nsTableFrame::DidResizeColumns()
     1: {
     1:   NS_PRECONDITION(!GetPrevInFlow(),
     1:                   "should only be called on first-in-flow");
     1:   if (mBits.mResizedColumns)
     1:     return; // already marked
     1: 
     1:   for (nsTableFrame *f = this; f;
  3233:        f = static_cast<nsTableFrame*>(f->GetNextInFlow()))
 80486:     f->mBits.mResizedColumns = true;
     1: }
     1: 
     1: void
     1: nsTableFrame::AppendCell(nsTableCellFrame& aCellFrame,
108991:                          int32_t           aRowIndex)
     1: {
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   if (cellMap) {
 87904:     nsIntRect damageArea(0,0,0,0);
 80486:     cellMap->AppendCell(aCellFrame, aRowIndex, true, damageArea);
     1:     MatchCellMapToColCache(cellMap);
     1:     if (IsBorderCollapse()) {
 82828:       AddBCDamageArea(damageArea);
     1:     }
     1:   }
     1: }
     1: 
 24724: void nsTableFrame::InsertCells(nsTArray<nsTableCellFrame*>& aCellFrames,
108991:                                int32_t                      aRowIndex,
108991:                                int32_t                      aColIndexBefore)
     1: {
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   if (cellMap) {
 87904:     nsIntRect damageArea(0,0,0,0);
     1:     cellMap->InsertCells(aCellFrames, aRowIndex, aColIndexBefore, damageArea);
     1:     MatchCellMapToColCache(cellMap);
     1:     if (IsBorderCollapse()) {
 82828:       AddBCDamageArea(damageArea);
     1:     }
     1:   }
     1: }
     1: 
     1: // this removes the frames from the col group and table, but not the cell map
108991: int32_t
108991: nsTableFrame::DestroyAnonymousColFrames(int32_t aNumFrames)
     1: {
     1:   // only remove cols that are of type eTypeAnonymous cell (they are at the end)
108991:   int32_t endIndex   = mColFrames.Length() - 1;
108991:   int32_t startIndex = (endIndex - aNumFrames) + 1;
108991:   int32_t numColsRemoved = 0;
108991:   for (int32_t colX = endIndex; colX >= startIndex; colX--) {
     1:     nsTableColFrame* colFrame = GetColFrame(colX);
     1:     if (colFrame && (eColAnonymousCell == colFrame->GetColType())) {
     1:       nsTableColGroupFrame* cgFrame =
  3233:         static_cast<nsTableColGroupFrame*>(colFrame->GetParent());
     1:       // remove the frame from the colgroup
 80486:       cgFrame->RemoveChild(*colFrame, false);
     1:       // remove the frame from the cache, but not the cell map
106838:       RemoveCol(nullptr, colX, true, false);
     1:       numColsRemoved++;
     1:     }
     1:     else {
     1:       break;
     1:     }
     1:   }
     1:   return (aNumFrames - numColsRemoved);
     1: }
     1: 
     1: void nsTableFrame::RemoveCell(nsTableCellFrame* aCellFrame,
108991:                               int32_t           aRowIndex)
     1: {
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   if (cellMap) {
 87904:     nsIntRect damageArea(0,0,0,0);
     1:     cellMap->RemoveCell(aCellFrame, aRowIndex, damageArea);
     1:     MatchCellMapToColCache(cellMap);
     1:     if (IsBorderCollapse()) {
 82828:       AddBCDamageArea(damageArea);
     1:     }
     1:   }
     1: }
     1: 
108991: int32_t
 37262: nsTableFrame::GetStartRowIndex(nsTableRowGroupFrame* aRowGroupFrame)
     1: {
  2141:   RowGroupArray orderedRowGroups;
  2141:   OrderRowGroups(orderedRowGroups);
     1: 
108991:   int32_t rowIndex = 0;
108991:   for (uint32_t rgIndex = 0; rgIndex < orderedRowGroups.Length(); rgIndex++) {
  2141:     nsTableRowGroupFrame* rgFrame = orderedRowGroups[rgIndex];
 37262:     if (rgFrame == aRowGroupFrame) {
     1:       break;
     1:     }
108991:     int32_t numRows = rgFrame->GetRowCount();
     1:     rowIndex += numRows;
     1:   }
     1:   return rowIndex;
     1: }
     1: 
     1: // this cannot extend beyond a single row group
 37262: void nsTableFrame::AppendRows(nsTableRowGroupFrame*       aRowGroupFrame,
108991:                               int32_t                     aRowIndex,
 24724:                               nsTArray<nsTableRowFrame*>& aRowFrames)
     1: {
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   if (cellMap) {
108991:     int32_t absRowIndex = GetStartRowIndex(aRowGroupFrame) + aRowIndex;
 80486:     InsertRows(aRowGroupFrame, aRowFrames, absRowIndex, true);
     1:   }
     1: }
     1: 
     1: // this cannot extend beyond a single row group
108991: int32_t
 37262: nsTableFrame::InsertRows(nsTableRowGroupFrame*       aRowGroupFrame,
 24724:                          nsTArray<nsTableRowFrame*>& aRowFrames,
108991:                          int32_t                     aRowIndex,
 79445:                          bool                        aConsiderSpans)
     1: {
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   printf("=== insertRowsBefore firstRow=%d \n", aRowIndex);
 80486:   Dump(true, false, true);
     1: #endif
     1: 
108991:   int32_t numColsToAdd = 0;
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   if (cellMap) {
 87904:     nsIntRect damageArea(0,0,0,0);
108991:     int32_t origNumRows = cellMap->GetRowCount();
108991:     int32_t numNewRows = aRowFrames.Length();
     1:     cellMap->InsertRows(aRowGroupFrame, aRowFrames, aRowIndex, aConsiderSpans, damageArea);
     1:     MatchCellMapToColCache(cellMap);
     1:     if (aRowIndex < origNumRows) {
     1:       AdjustRowIndices(aRowIndex, numNewRows);
     1:     }
     1:     // assign the correct row indices to the new rows. If they were adjusted above
     1:     // it may not have been done correctly because each row is constructed with index 0
108991:     for (int32_t rowY = 0; rowY < numNewRows; rowY++) {
 29425:       nsTableRowFrame* rowFrame = aRowFrames.ElementAt(rowY);
 29425:       rowFrame->SetRowIndex(aRowIndex + rowY);
     1:     }
     1:     if (IsBorderCollapse()) {
 82828:       AddBCDamageArea(damageArea);
     1:     }
     1:   }
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   printf("=== insertRowsAfter \n");
 80486:   Dump(true, false, true);
     1: #endif
     1: 
     1:   return numColsToAdd;
     1: }
     1: 
     1: // this cannot extend beyond a single row group
     1: void nsTableFrame::RemoveRows(nsTableRowFrame& aFirstRowFrame,
108991:                               int32_t          aNumRowsToRemove,
 79445:                               bool             aConsiderSpans)
     1: {
     1: #ifdef TBD_OPTIMIZATION
     1:   // decide if we need to rebalance. we have to do this here because the row group
     1:   // cannot do it when it gets the dirty reflow corresponding to the frame being destroyed
 79445:   bool stopTelling = false;
     1:   for (nsIFrame* kidFrame = aFirstFrame.FirstChild(); (kidFrame && !stopAsking);
     1:        kidFrame = kidFrame->GetNextSibling()) {
 26583:     nsTableCellFrame *cellFrame = do_QueryFrame(kidFrame);
 26583:     if (cellFrame) {
     1:       stopTelling = tableFrame->CellChangedWidth(*cellFrame, cellFrame->GetPass1MaxElementWidth(),
 80486:                                                  cellFrame->GetMaximumWidth(), true);
     1:     }
     1:   }
     1:   // XXX need to consider what happens if there are cells that have rowspans
     1:   // into the deleted row. Need to consider moving rows if a rebalance doesn't happen
     1: #endif
     1: 
108991:   int32_t firstRowIndex = aFirstRowFrame.GetRowIndex();
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   printf("=== removeRowsBefore firstRow=%d numRows=%d\n", firstRowIndex, aNumRowsToRemove);
 80486:   Dump(true, false, true);
     1: #endif
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   if (cellMap) {
 87904:     nsIntRect damageArea(0,0,0,0);
     1:     cellMap->RemoveRows(firstRowIndex, aNumRowsToRemove, aConsiderSpans, damageArea);
     1:     MatchCellMapToColCache(cellMap);
     1:     if (IsBorderCollapse()) {
 82828:       AddBCDamageArea(damageArea);
     1:     }
     1:   }
     1:   AdjustRowIndices(firstRowIndex, -aNumRowsToRemove);
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   printf("=== removeRowsAfter\n");
 80486:   Dump(true, true, true);
     1: #endif
     1: }
     1: 
     1: // collect the rows ancestors of aFrame
108991: int32_t
     1: nsTableFrame::CollectRows(nsIFrame*                   aFrame,
 24724:                           nsTArray<nsTableRowFrame*>& aCollection)
     1: {
 37262:   NS_PRECONDITION(aFrame, "null frame");
108991:   int32_t numRows = 0;
 77154:   nsIFrame* childFrame = aFrame->GetFirstPrincipalChild();
     1:   while (childFrame) {
 37262:     aCollection.AppendElement(static_cast<nsTableRowFrame*>(childFrame));
     1:     numRows++;
     1:     childFrame = childFrame->GetNextSibling();
     1:   }
     1:   return numRows;
     1: }
     1: 
     1: void
 30941: nsTableFrame::InsertRowGroups(const nsFrameList::Slice& aRowGroups)
     1: {
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   printf("=== insertRowGroupsBefore\n");
 80486:   Dump(true, false, true);
     1: #endif
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   if (cellMap) {
  2141:     RowGroupArray orderedRowGroups;
  2141:     OrderRowGroups(orderedRowGroups);
  2141: 
 24724:     nsAutoTArray<nsTableRowFrame*, 8> rows;
     1:     // Loop over the rowgroups and check if some of them are new, if they are
     1:     // insert cellmaps in the order that is predefined by OrderRowGroups,
 30941:     // XXXbz this code is O(N*M) where N is number of new rowgroups
 30941:     // and M is number of rowgroups we have!
108991:     uint32_t rgIndex;
  2141:     for (rgIndex = 0; rgIndex < orderedRowGroups.Length(); rgIndex++) {
 30941:       for (nsFrameList::Enumerator rowgroups(aRowGroups); !rowgroups.AtEnd();
 30941:            rowgroups.Next()) {
 37262:         if (orderedRowGroups[rgIndex] == rowgroups.get()) {
  2141:           nsTableRowGroupFrame* priorRG =
106838:             (0 == rgIndex) ? nullptr : orderedRowGroups[rgIndex - 1];
     1:           // create and add the cell map for the row group
 37262:           cellMap->InsertGroupCellMap(orderedRowGroups[rgIndex], priorRG);
     1: 
     1:           break;
     1:         }
     1:       }
     1:     }
     1:     cellMap->Synchronize(this);
 30941:     ResetRowIndices(aRowGroups);
     1: 
     1:     //now that the cellmaps are reordered too insert the rows
  2141:     for (rgIndex = 0; rgIndex < orderedRowGroups.Length(); rgIndex++) {
 30941:       for (nsFrameList::Enumerator rowgroups(aRowGroups); !rowgroups.AtEnd();
 30941:            rowgroups.Next()) {
 37262:         if (orderedRowGroups[rgIndex] == rowgroups.get()) {
  2141:           nsTableRowGroupFrame* priorRG =
106838:             (0 == rgIndex) ? nullptr : orderedRowGroups[rgIndex - 1];
     1:           // collect the new row frames in an array and add them to the table
108991:           int32_t numRows = CollectRows(rowgroups.get(), rows);
     1:           if (numRows > 0) {
108991:             int32_t rowIndex = 0;
     1:             if (priorRG) {
108991:               int32_t priorNumRows = priorRG->GetRowCount();
     1:               rowIndex = priorRG->GetStartRowIndex() + priorNumRows;
     1:             }
 80486:             InsertRows(orderedRowGroups[rgIndex], rows, rowIndex, true);
     1:             rows.Clear();
     1:           }
     1:           break;
     1:         }
     1:       }
     1:     }
     1: 
     1:   }
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   printf("=== insertRowGroupsAfter\n");
 80486:   Dump(true, true, true);
     1: #endif
     1: }
     1: 
     1: 
     1: /////////////////////////////////////////////////////////////////////////////
     1: // Child frame enumeration
     1: 
 91756: const nsFrameList&
 77152: nsTableFrame::GetChildList(ChildListID aListID) const
 77152: {
 77152:   if (aListID == kColGroupList) {
 30783:     return mColGroups;
 30783:   }
 86231:   return nsContainerFrame::GetChildList(aListID);
 77152: }
 77152: 
 77152: void
 77152: nsTableFrame::GetChildLists(nsTArray<ChildList>* aLists) const
 77152: {
 86231:   nsContainerFrame::GetChildLists(aLists);
 77152:   mColGroups.AppendIfNonempty(aLists, kColGroupList);
     1: }
     1: 
 13961: nsRect
 95051: nsDisplayTableItem::GetBounds(nsDisplayListBuilder* aBuilder, bool* aSnap) {
 95051:   *aSnap = false;
 80311:   return mFrame->GetVisualOverflowRectRelativeToSelf() + ToReferenceFrame();
 13961: }
 13961: 
 79445: bool
 50392: nsDisplayTableItem::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
 50392:                                                    nsIFrame* aFrame)
 13961: {
 13961:   if (!mPartHasFixedBackground)
 80486:     return false;
 13961: 
 50392:   // If aFrame is mFrame or an ancestor in this document, and aFrame is
 50392:   // not the viewport frame, then moving aFrame will move mFrame
 50392:   // relative to the viewport, so our fixed-pos background will change.
 50392:   return mFrame == aFrame ||
 50392:     nsLayoutUtils::IsProperAncestorFrame(aFrame, mFrame);
 13961: }
 13961: 
 13961: /* static */ void
 13961: nsDisplayTableItem::UpdateForFrameBackground(nsIFrame* aFrame)
 13961: {
 40177:   nsStyleContext *bgSC;
 40177:   if (!nsCSSRendering::FindBackground(aFrame->PresContext(), aFrame, &bgSC))
 13961:     return;
 40177:   if (!bgSC->GetStyleBackground()->HasFixedBackground())
 13961:     return;
 13961: 
 80486:   mPartHasFixedBackground = true;
 13961: }
 13961: 
 13961: class nsDisplayTableBorderBackground : public nsDisplayTableItem {
     1: public:
 51260:   nsDisplayTableBorderBackground(nsDisplayListBuilder* aBuilder,
 51260:                                  nsTableFrame* aFrame) :
 51260:     nsDisplayTableItem(aBuilder, aFrame) {
     1:     MOZ_COUNT_CTOR(nsDisplayTableBorderBackground);
     1:   }
     1: #ifdef NS_BUILD_REFCNT_LOGGING
     1:   virtual ~nsDisplayTableBorderBackground() {
     1:     MOZ_COUNT_DTOR(nsDisplayTableBorderBackground);
     1:   }
     1: #endif
     1: 
 33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
 68481:                      nsRenderingContext* aCtx);
 47732:   NS_DISPLAY_DECL_NAME("TableBorderBackground", TYPE_TABLE_BORDER_BACKGROUND)
     1: };
     1: 
     1: void
     1: nsDisplayTableBorderBackground::Paint(nsDisplayListBuilder* aBuilder,
 68481:                                       nsRenderingContext* aCtx)
     1: {
  3233:   static_cast<nsTableFrame*>(mFrame)->
 33368:     PaintTableBorderBackground(*aCtx, mVisibleRect,
 51261:                                ToReferenceFrame(),
 32425:                                aBuilder->GetBackgroundPaintFlags());
     1: }
     1: 
108991: static int32_t GetTablePartRank(nsDisplayItem* aItem)
     1: {
     1:   nsIAtom* type = aItem->GetUnderlyingFrame()->GetType();
     1:   if (type == nsGkAtoms::tableFrame)
     1:     return 0;
     1:   if (type == nsGkAtoms::tableRowGroupFrame)
     1:     return 1;
     1:   if (type == nsGkAtoms::tableRowFrame)
     1:     return 2;
     1:   return 3;
     1: }
     1: 
 79445: static bool CompareByTablePartRank(nsDisplayItem* aItem1, nsDisplayItem* aItem2,
     1:                                      void* aClosure)
     1: {
     1:   return GetTablePartRank(aItem1) <= GetTablePartRank(aItem2);
     1: }
     1: 
     1: /* static */ nsresult
     1: nsTableFrame::GenericTraversal(nsDisplayListBuilder* aBuilder, nsFrame* aFrame,
     1:                                const nsRect& aDirtyRect, const nsDisplayListSet& aLists)
     1: {
     1:   // This is similar to what nsContainerFrame::BuildDisplayListForNonBlockChildren
     1:   // does, except that we allow the children's background and borders to go
     1:   // in our BorderBackground list. This doesn't really affect background
     1:   // painting --- the children won't actually draw their own backgrounds
     1:   // because the nsTableFrame already drew them, unless a child has its own
     1:   // stacking context, in which case the child won't use its passed-in
     1:   // BorderBackground list anyway. It does affect cell borders though; this
     1:   // lets us get cell borders into the nsTableFrame's BorderBackground list.
 77154:   nsIFrame* kid = aFrame->GetFirstPrincipalChild();
     1:   while (kid) {
     1:     nsresult rv = aFrame->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     kid = kid->GetNextSibling();
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* static */ nsresult
     1: nsTableFrame::DisplayGenericTablePart(nsDisplayListBuilder* aBuilder,
     1:                                       nsFrame* aFrame,
     1:                                       const nsRect& aDirtyRect,
     1:                                       const nsDisplayListSet& aLists,
 13961:                                       nsDisplayTableItem* aDisplayItem,
     1:                                       DisplayGenericTablePartTraversal aTraversal)
     1: {
     1:   nsDisplayList eventsBorderBackground;
     1:   // If we need to sort the event backgrounds, then we'll put descendants'
     1:   // display items into their own set of lists.
 79445:   bool sortEventBackgrounds = aDisplayItem && aBuilder->IsForEventDelivery();
     1:   nsDisplayListCollection separatedCollection;
     1:   const nsDisplayListSet* lists = sortEventBackgrounds ? &separatedCollection : &aLists;
     1: 
 13961:   nsAutoPushCurrentTableItem pushTableItem;
 13961:   if (aDisplayItem) {
 13961:     pushTableItem.Push(aBuilder, aDisplayItem);
 13961:   }
 35635: 
 35635:   if (aFrame->IsVisibleForPainting(aBuilder)) {
 13961:     nsDisplayTableItem* currentItem = aBuilder->GetCurrentTableItem();
 35636:     // currentItem may be null, when none of the table parts have a
 35636:     // background or border
 35636:     if (currentItem) {
 13961:       currentItem->UpdateForFrameBackground(aFrame);
 35636:     }
 13961: 
 24818:     // Paint the outset box-shadows for the table frames
106838:     bool hasBoxShadow = aFrame->GetStyleBorder()->mBoxShadow != nullptr;
 24818:     if (hasBoxShadow) {
 51260:       nsresult rv = lists->BorderBackground()->AppendNewToTop(
 51260:           new (aBuilder) nsDisplayBoxShadowOuter(aBuilder, aFrame));
 22191:       NS_ENSURE_SUCCESS(rv, rv);
 22191:     }
 22191: 
     1:     // Create dedicated background display items per-frame when we're
     1:     // handling events.
     1:     // XXX how to handle collapsed borders?
 35635:     if (aBuilder->IsForEventDelivery()) {
122084:       nsresult rv = nsDisplayBackgroundImage::AppendBackgroundItemsToTop(aBuilder, aFrame,
113850:                                                                     lists->BorderBackground());
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1: 
 24818:     // Paint the inset box-shadows for the table frames
 24818:     if (hasBoxShadow) {
 51260:       nsresult rv = lists->BorderBackground()->AppendNewToTop(
 51260:           new (aBuilder) nsDisplayBoxShadowInner(aBuilder, aFrame));
 24818:       NS_ENSURE_SUCCESS(rv, rv);
 24818:     }
 35635:   }
 24818: 
     1:   nsresult rv = aTraversal(aBuilder, aFrame, aDirtyRect, *lists);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (sortEventBackgrounds) {
     1:     // Ensure that the table frame event background goes before the
     1:     // table rowgroups event backgrounds, before the table row event backgrounds,
     1:     // before everything else (cells and their blocks)
106838:     separatedCollection.BorderBackground()->Sort(aBuilder, CompareByTablePartRank, nullptr);
     1:     separatedCollection.MoveTo(aLists);
     1:   }
     1: 
     1:   return aFrame->DisplayOutline(aBuilder, aLists);
     1: }
     1: 
 35635: #ifdef DEBUG
 79445: static bool
 35635: IsFrameAllowedInTable(nsIAtom* aType)
 35635: {
 35635:   return IS_TABLE_CELL(aType) ||
 35635:          nsGkAtoms::tableRowFrame == aType ||
 35635:          nsGkAtoms::tableRowGroupFrame == aType ||
 35635:          nsGkAtoms::scrollFrame == aType ||
 35635:          nsGkAtoms::tableFrame == aType ||
 35635:          nsGkAtoms::tableColFrame == aType ||
 35635:          nsGkAtoms::tableColGroupFrame == aType;
 35635: }
 35635: #endif
 35635: 
 79445: static bool
 38078: AnyTablePartHasBorderOrBackground(nsIFrame* aStart, nsIFrame* aEnd)
 38078: {
 38078:   for (nsIFrame* f = aStart; f != aEnd; f = f->GetNextSibling()) {
 37806:     NS_ASSERTION(IsFrameAllowedInTable(f->GetType()), "unexpected frame type");
 37806: 
115305:     if (FrameHasBorderOrBackground(f))
 80486:       return true;
 35636: 
 37806:     nsTableCellFrame *cellFrame = do_QueryFrame(f);
 35635:     if (cellFrame)
 37806:       continue;
 37806: 
106838:     if (AnyTablePartHasBorderOrBackground(f->PrincipalChildList().FirstChild(), nullptr))
 80486:       return true;
 80486:   }
 80486: 
 80486:   return false;
 35635: }
 35635: 
     1: // table paint code is concerned primarily with borders and bg color
     1: // SEC: TODO: adjust the rect for captions
     1: NS_IMETHODIMP
     1: nsTableFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                const nsRect&           aDirtyRect,
     1:                                const nsDisplayListSet& aLists)
     1: {
     1:   DO_GLOBAL_REFLOW_COUNT_DSP_COLOR("nsTableFrame", NS_RGB(255,128,255));
     1: 
106838:   nsDisplayTableItem* item = nullptr;
 94622:   if (IsVisibleInSelection(aBuilder)) {
 30511:     if (GetStyleVisibility()->IsVisible()) {
 30511:       nsMargin deflate = GetDeflationForBackground(PresContext());
 30511:       // If 'deflate' is (0,0,0,0) then we can paint the table background
 30511:       // in its own display item, so do that to take advantage of
 30511:       // opacity and visibility optimizations
 68635:       if (deflate == nsMargin(0, 0, 0, 0)) {
122084:         nsDisplayBackgroundImage* bg;
 95349:         nsresult rv = DisplayBackgroundUnconditional(aBuilder, aLists, false, &bg);
 30511:         NS_ENSURE_SUCCESS(rv, rv);
 30511:       }
 30511:     }
 30511:     
 37459:     // This background is created if any of the table parts are visible,
 37459:     // or if we're doing event handling (since DisplayGenericTablePart
 37459:     // needs the item for the |sortEventBackgrounds|-dependent code).
 35635:     // Specific visibility decisions are delegated to the table background
 35635:     // painter, which handles borders and backgrounds for the table.
 37459:     if (aBuilder->IsForEventDelivery() ||
 38078:         AnyTablePartHasBorderOrBackground(this, GetNextSibling()) ||
106838:         AnyTablePartHasBorderOrBackground(mColGroups.FirstChild(), nullptr)) {
 51260:       item = new (aBuilder) nsDisplayTableBorderBackground(aBuilder, this);
 13961:       nsresult rv = aLists.BorderBackground()->AppendNewToTop(item);
     1:       NS_ENSURE_SUCCESS(rv, rv);
 35635:     }
 94622:   }
 13961:   return DisplayGenericTablePart(aBuilder, this, aDirtyRect, aLists, item);
     1: }
     1: 
 30511: nsMargin
 30511: nsTableFrame::GetDeflationForBackground(nsPresContext* aPresContext) const
 30511: {
 30511:   if (eCompatibility_NavQuirks != aPresContext->CompatibilityMode() ||
 30511:       !IsBorderCollapse())
 30511:     return nsMargin(0,0,0,0);
 30511: 
 30511:   return GetOuterBCBorder();
 30511: }
 30511: 
     1: // XXX We don't put the borders and backgrounds in tree order like we should.
     1: // That requires some major surgery which we aren't going to do right now.
     1: void
 68481: nsTableFrame::PaintTableBorderBackground(nsRenderingContext& aRenderingContext,
     1:                                          const nsRect& aDirtyRect,
108991:                                          nsPoint aPt, uint32_t aBGPaintFlags)
     1: {
   238:   nsPresContext* presContext = PresContext();
     1: 
     1:   TableBackgroundPainter painter(this, TableBackgroundPainter::eOrigin_Table,
 13405:                                  presContext, aRenderingContext,
 32425:                                  aDirtyRect, aPt, aBGPaintFlags);
 30511:   nsMargin deflate = GetDeflationForBackground(presContext);
 30511:   // If 'deflate' is (0,0,0,0) then we'll paint the table background
 30511:   // in a separate display item, so don't do it here.
 68635:   nsresult rv = painter.PaintTable(this, deflate, deflate != nsMargin(0, 0, 0, 0));
     1:   if (NS_FAILED(rv)) return;
     1: 
     1:   if (GetStyleVisibility()->IsVisible()) {
     1:     if (!IsBorderCollapse()) {
107846:       int skipSides = GetSkipSides();
 13405:       nsRect rect(aPt, mRect.Size());
     1:       nsCSSRendering::PaintBorder(presContext, aRenderingContext, this,
 40180:                                   aDirtyRect, rect, mStyleContext, skipSides);
     1:     }
     1:     else {
 13405:       // XXX we should probably get rid of this translation at some stage
 13405:       // But that would mean modifying PaintBCBorders, ugh
 68481:       nsRenderingContext::AutoPushTranslation translate(&aRenderingContext, aPt);
 13405:       PaintBCBorders(aRenderingContext, aDirtyRect - aPt);
     1:     }
     1:   }
     1: }
     1: 
107846: int
     1: nsTableFrame::GetSkipSides() const
     1: {
107846:   int skip = 0;
     1:   // frame attribute was accounted for in nsHTMLTableElement::MapTableBorderInto
     1:   // account for pagination
106838:   if (nullptr != GetPrevInFlow()) {
     1:     skip |= 1 << NS_SIDE_TOP;
     1:   }
106838:   if (nullptr != GetNextInFlow()) {
     1:     skip |= 1 << NS_SIDE_BOTTOM;
     1:   }
     1:   return skip;
     1: }
     1: 
     1: void
     1: nsTableFrame::SetColumnDimensions(nscoord         aHeight,
     1:                                   const nsMargin& aBorderPadding)
     1: {
     1:   nscoord cellSpacingX = GetCellSpacingX();
     1:   nscoord cellSpacingY = GetCellSpacingY();
     1:   nscoord colHeight = aHeight -= aBorderPadding.top + aBorderPadding.bottom +
     1:                                  2* cellSpacingY;
     1: 
 16348:   nsTableIterator iter(mColGroups);
 16348:   nsIFrame* colGroupFrame = iter.First();
 79445:   bool tableIsLTR = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
108991:   int32_t colX =tableIsLTR ? 0 : NS_MAX(0, GetColCount() - 1);
108991:   int32_t tableColIncr = tableIsLTR ? 1 : -1;
     1:   nsPoint colGroupOrigin(aBorderPadding.left + cellSpacingX,
     1:                          aBorderPadding.top + cellSpacingY);
100081:   while (colGroupFrame) {
100081:     MOZ_ASSERT(colGroupFrame->GetType() == nsGkAtoms::tableColGroupFrame);
     1:     nscoord colGroupWidth = 0;
 16348:     nsTableIterator iterCol(*colGroupFrame);
 16348:     nsIFrame* colFrame = iterCol.First();
     1:     nsPoint colOrigin(0,0);
100081:     while (colFrame) {
     1:       if (NS_STYLE_DISPLAY_TABLE_COLUMN ==
     1:           colFrame->GetStyleDisplay()->mDisplay) {
     1:         NS_ASSERTION(colX < GetColCount(), "invalid number of columns");
     1:         nscoord colWidth = GetColumnWidth(colX);
     1:         nsRect colRect(colOrigin.x, colOrigin.y, colWidth, colHeight);
     1:         colFrame->SetRect(colRect);
     1:         colOrigin.x += colWidth + cellSpacingX;
     1:         colGroupWidth += colWidth + cellSpacingX;
 16348:         colX += tableColIncr;
 16348:       }
 16348:       colFrame = iterCol.Next();
     1:     }
     1:     if (colGroupWidth) {
     1:       colGroupWidth -= cellSpacingX;
     1:     }
     1: 
     1:     nsRect colGroupRect(colGroupOrigin.x, colGroupOrigin.y, colGroupWidth, colHeight);
     1:     colGroupFrame->SetRect(colGroupRect);
 16348:     colGroupFrame = iter.Next();
     1:     colGroupOrigin.x += colGroupWidth + cellSpacingX;
     1:   }
     1: }
     1: 
     1: // SEC: TODO need to worry about continuing frames prev/next in flow for splitting across pages.
     1: 
     1: // XXX this could be made more general to handle row modifications that change the
     1: // table height, but first we need to scrutinize every Invalidate
 11285: void
 11285: nsTableFrame::ProcessRowInserted(nscoord aNewHeight)
 11285: {
 80486:   SetRowInserted(false); // reset the bit that got us here
  2141:   nsTableFrame::RowGroupArray rowGroups;
 11285:   OrderRowGroups(rowGroups);
     1:   // find the row group containing the inserted row
108991:   for (uint32_t rgX = 0; rgX < rowGroups.Length(); rgX++) {
  2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
  2141:     NS_ASSERTION(rgFrame, "Must have rgFrame here");
 77154:     nsIFrame* childFrame = rgFrame->GetFirstPrincipalChild();
     1:     // find the row that was inserted first
     1:     while (childFrame) {
 26583:       nsTableRowFrame *rowFrame = do_QueryFrame(childFrame);
 26583:       if (rowFrame) {
     1:         if (rowFrame->IsFirstInserted()) {
 80486:           rowFrame->SetFirstInserted(false);
     1:           // damage the table from the 1st row inserted to the end of the table
115328:           nsIFrame::InvalidateFrame();
 11285:           // XXXbz didn't we do this up front?  Why do we need to do it again?
 80486:           SetRowInserted(false);
     1:           return; // found it, so leave
     1:         }
     1:       }
     1:       childFrame = childFrame->GetNextSibling();
     1:     }
     1:   }
     1: }
     1: 
     1: /* virtual */ void
     1: nsTableFrame::MarkIntrinsicWidthsDirty()
     1: {
 57471:   nsITableLayoutStrategy* tls = LayoutStrategy();
120353:   if (MOZ_UNLIKELY(!tls)) {
 57471:     // This is a FrameNeedsReflow() from nsBlockFrame::RemoveFrame()
 57471:     // walking up the ancestor chain in a table next-in-flow.  In this case
 57471:     // our original first-in-flow (which owns the TableLayoutStrategy) has
 57471:     // already been destroyed and unhooked from the flow chain and thusly
 57471:     // LayoutStrategy() returns null.  All the frames in the flow will be
 57471:     // destroyed so no need to mark anything dirty here.  See bug 595758.
 57471:     return;
 57471:   }
 57471:   tls->MarkIntrinsicWidthsDirty();
     1: 
     1:   // XXXldb Call SetBCDamageArea?
     1: 
 86231:   nsContainerFrame::MarkIntrinsicWidthsDirty();
     1: }
     1: 
     1: /* virtual */ nscoord
 68481: nsTableFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   if (NeedToCalcBCBorders())
     1:     CalcBCBorders();
     1: 
     1:   ReflowColGroups(aRenderingContext);
     1: 
     1:   return LayoutStrategy()->GetMinWidth(aRenderingContext);
     1: }
     1: 
     1: /* virtual */ nscoord
 68481: nsTableFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
     1: {
     1:   if (NeedToCalcBCBorders())
     1:     CalcBCBorders();
     1: 
     1:   ReflowColGroups(aRenderingContext);
     1: 
 80486:   return LayoutStrategy()->GetPrefWidth(aRenderingContext, false);
     1: }
     1: 
     1: /* virtual */ nsIFrame::IntrinsicWidthOffsetData
 68481: nsTableFrame::IntrinsicWidthOffsets(nsRenderingContext* aRenderingContext)
     1: {
     1:   IntrinsicWidthOffsetData result =
 86231:     nsContainerFrame::IntrinsicWidthOffsets(aRenderingContext);
     1: 
 79490:   result.hMargin = 0;
 79490:   result.hPctMargin = 0;
 79490: 
     1:   if (IsBorderCollapse()) {
     1:     result.hPadding = 0;
     1:     result.hPctPadding = 0;
     1: 
     1:     nsMargin outerBC = GetIncludedOuterBCBorder();
     1:     result.hBorder = outerBC.LeftRight();
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
     1: /* virtual */ nsSize
 68481: nsTableFrame::ComputeSize(nsRenderingContext *aRenderingContext,
     1:                           nsSize aCBSize, nscoord aAvailableWidth,
     1:                           nsSize aMargin, nsSize aBorder, nsSize aPadding,
108991:                           uint32_t aFlags)
     1: {
     1:   nsSize result =
 86231:     nsContainerFrame::ComputeSize(aRenderingContext, aCBSize, aAvailableWidth,
 93353:                                   aMargin, aBorder, aPadding, aFlags);
     1: 
 88122:   // If we're a container for font size inflation, then shrink
 88122:   // wrapping inside of us should not apply font size inflation.
 98992:   AutoMaybeDisableFontInflation an(this);
 88122: 
     1:   // Tables never shrink below their min width.
     1:   nscoord minWidth = GetMinWidth(aRenderingContext);
     1:   if (minWidth > result.width)
     1:     result.width = minWidth;
     1: 
     1:   return result;
     1: }
     1: 
     1: nscoord
 68481: nsTableFrame::TableShrinkWidthToFit(nsRenderingContext *aRenderingContext,
     1:                                     nscoord aWidthInCB)
     1: {
 88122:   // If we're a container for font size inflation, then shrink
 88122:   // wrapping inside of us should not apply font size inflation.
 98992:   AutoMaybeDisableFontInflation an(this);
 88122: 
     1:   nscoord result;
     1:   nscoord minWidth = GetMinWidth(aRenderingContext);
     1:   if (minWidth > aWidthInCB) {
     1:     result = minWidth;
     1:   } else {
     1:     // Tables shrink width to fit with a slightly different algorithm
     1:     // from the one they use for their intrinsic widths (the difference
     1:     // relates to handling of percentage widths on columns).  So this
     1:     // function differs from nsFrame::ShrinkWidthToFit by only the
     1:     // following line.
     1:     // Since we've already called GetMinWidth, we don't need to do any
     1:     // of the other stuff GetPrefWidth does.
     1:     nscoord prefWidth =
 80486:       LayoutStrategy()->GetPrefWidth(aRenderingContext, true);
     1:     if (prefWidth > aWidthInCB) {
     1:       result = aWidthInCB;
     1:     } else {
     1:       result = prefWidth;
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
     1: /* virtual */ nsSize
 68481: nsTableFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
     1:                               nsSize aCBSize, nscoord aAvailableWidth,
     1:                               nsSize aMargin, nsSize aBorder, nsSize aPadding,
 79445:                               bool aShrinkWrap)
     1: {
     1:   // Tables always shrink-wrap.
     1:   nscoord cbBased = aAvailableWidth - aMargin.width - aBorder.width -
     1:                     aPadding.width;
     1:   return nsSize(TableShrinkWidthToFit(aRenderingContext, cbBased),
     1:                 NS_UNCONSTRAINEDSIZE);
     1: }
     1: 
  2765: // Return true if aParentReflowState.frame or any of its ancestors within
  2765: // the containing table have non-auto height. (e.g. pct or fixed height)
 79445: bool
  2765: nsTableFrame::AncestorsHaveStyleHeight(const nsHTMLReflowState& aParentReflowState)
  2765: {
  2765:   for (const nsHTMLReflowState* rs = &aParentReflowState;
  2765:        rs && rs->frame; rs = rs->parentReflowState) {
  2765:     nsIAtom* frameType = rs->frame->GetType();
     1:     if (IS_TABLE_CELL(frameType)                     ||
     1:         (nsGkAtoms::tableRowFrame      == frameType) ||
     1:         (nsGkAtoms::tableRowGroupFrame == frameType)) {
 51406:       const nsStyleCoord &height = rs->mStylePosition->mHeight;
123833:       // calc() with percentages treated like 'auto' on internal table elements
123833:       if (height.GetUnit() != eStyleUnit_Auto &&
123833:           (!height.IsCalcUnit() || !height.HasPercent())) {
 80486:         return true;
     1:       }
     1:     }
     1:     else if (nsGkAtoms::tableFrame == frameType) {
     1:       // we reached the containing table, so always return
  2765:       if (rs->mStylePosition->mHeight.GetUnit() != eStyleUnit_Auto) {
 80486:         return true;
 80486:       }
 80486:       else return false;
 80486:     }
 80486:   }
 80486:   return false;
     1: }
     1: 
     1: // See if a special height reflow needs to occur and if so, call RequestSpecialHeightReflow
     1: void
     1: nsTableFrame::CheckRequestSpecialHeightReflow(const nsHTMLReflowState& aReflowState)
     1: {
 51406:   NS_ASSERTION(IS_TABLE_CELL(aReflowState.frame->GetType()) ||
 51406:                aReflowState.frame->GetType() == nsGkAtoms::tableRowFrame ||
 51406:                aReflowState.frame->GetType() == nsGkAtoms::tableRowGroupFrame ||
 51406:                aReflowState.frame->GetType() == nsGkAtoms::tableFrame,
 51406:                "unexpected frame type");
     1:   if (!aReflowState.frame->GetPrevInFlow() &&  // 1st in flow
  4166:       (NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight() ||  // no computed height
  4166:        0                    == aReflowState.ComputedHeight()) &&
  2765:       eStyleUnit_Percent == aReflowState.mStylePosition->mHeight.GetUnit() && // pct height
  2765:       nsTableFrame::AncestorsHaveStyleHeight(*aReflowState.parentReflowState)) {
     1:     nsTableFrame::RequestSpecialHeightReflow(aReflowState);
     1:   }
     1: }
     1: 
     1: // Notify the frame and its ancestors (up to the containing table) that a special
     1: // height reflow will occur. During a special height reflow, a table, row group,
     1: // row, or cell returns the last size it was reflowed at. However, the table may
     1: // change the height of row groups, rows, cells in DistributeHeightToRows after.
     1: // And the row group can change the height of rows, cells in CalculateRowHeights.
     1: void
     1: nsTableFrame::RequestSpecialHeightReflow(const nsHTMLReflowState& aReflowState)
     1: {
     1:   // notify the frame and its ancestors of the special reflow, stopping at the containing table
     1:   for (const nsHTMLReflowState* rs = &aReflowState; rs && rs->frame; rs = rs->parentReflowState) {
     1:     nsIAtom* frameType = rs->frame->GetType();
 35640:     NS_ASSERTION(IS_TABLE_CELL(frameType) ||
 35640:                  nsGkAtoms::tableRowFrame == frameType ||
 35640:                  nsGkAtoms::tableRowGroupFrame == frameType ||
 35640:                  nsGkAtoms::tableFrame == frameType,
 35640:                  "unexpected frame type");
     1: 
     1:     rs->frame->AddStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
     1:     if (nsGkAtoms::tableFrame == frameType) {
     1:       NS_ASSERTION(rs != &aReflowState,
     1:                    "should not request special height reflow for table");
     1:       // always stop when we reach a table
     1:       break;
     1:     }
     1:   }
     1: }
     1: 
     1: /******************************************************************************************
     1:  * Before reflow, intrinsic width calculation is done using GetMinWidth
     1:  * and GetPrefWidth.  This used to be known as pass 1 reflow.
     1:  *
     1:  * After the intrinsic width calculation, the table determines the
     1:  * column widths using BalanceColumnWidths() and
     1:  * then reflows each child again with a constrained avail width. This reflow is referred to
     1:  * as the pass 2 reflow.
     1:  *
     1:  * A special height reflow (pass 3 reflow) can occur during an initial or resize reflow
     1:  * if (a) a row group, row, cell, or a frame inside a cell has a percent height but no computed
     1:  * height or (b) in paginated mode, a table has a height. (a) supports percent nested tables
     1:  * contained inside cells whose heights aren't known until after the pass 2 reflow. (b) is
     1:  * necessary because the table cannot split until after the pass 2 reflow. The mechanics of
     1:  * the special height reflow (variety a) are as follows:
     1:  *
     1:  * 1) Each table related frame (table, row group, row, cell) implements NeedsSpecialReflow()
     1:  *    to indicate that it should get the reflow. It does this when it has a percent height but
     1:  *    no computed height by calling CheckRequestSpecialHeightReflow(). This method calls
     1:  *    RequestSpecialHeightReflow() which calls SetNeedSpecialReflow() on its ancestors until
     1:  *    it reaches the containing table and calls SetNeedToInitiateSpecialReflow() on it. For
     1:  *    percent height frames inside cells, during DidReflow(), the cell's NotifyPercentHeight()
     1:  *    is called (the cell is the reflow state's mPercentHeightObserver in this case).
     1:  *    NotifyPercentHeight() calls RequestSpecialHeightReflow().
     1:  *
     1:  * 2) After the pass 2 reflow, if the table's NeedToInitiateSpecialReflow(true) was called, it
     1:  *    will do the special height reflow, setting the reflow state's mFlags.mSpecialHeightReflow
     1:  *    to true and mSpecialHeightInitiator to itself. It won't do this if IsPrematureSpecialHeightReflow()
     1:  *    returns true because in that case another special height reflow will be coming along with the
     1:  *    containing table as the mSpecialHeightInitiator. It is only relevant to do the reflow when
     1:  *    the mSpecialHeightInitiator is the containing table, because if it is a remote ancestor, then
     1:  *    appropriate heights will not be known.
     1:  *
     1:  * 3) Since the heights of the table, row groups, rows, and cells was determined during the pass 2
     1:  *    reflow, they return their last desired sizes during the special height reflow. The reflow only
     1:  *    permits percent height frames inside the cells to resize based on the cells height and that height
     1:  *    was determined during the pass 2 reflow.
     1:  *
     1:  * So, in the case of deeply nested tables, all of the tables that were told to initiate a special
     1:  * reflow will do so, but if a table is already in a special reflow, it won't inititate the reflow
     1:  * until the current initiator is its containing table. Since these reflows are only received by
     1:  * frames that need them and they don't cause any rebalancing of tables, the extra overhead is minimal.
     1:  *
     1:  * The type of special reflow that occurs during printing (variety b) follows the same mechanism except
     1:  * that all frames will receive the reflow even if they don't really need them.
     1:  *
     1:  * Open issues with the special height reflow:
     1:  *
     1:  * 1) At some point there should be 2 kinds of special height reflows because (a) and (b) above are
     1:  *    really quite different. This would avoid unnecessary reflows during printing.
     1:  * 2) When a cell contains frames whose percent heights > 100%, there is data loss (see bug 115245).
     1:  *    However, this can also occur if a cell has a fixed height and there is no special height reflow.
     1:  *
     1:  * XXXldb Special height reflow should really be its own method, not
     1:  * part of nsIFrame::Reflow.  It should then call nsIFrame::Reflow on
     1:  * the contents of the cells to do the necessary vertical resizing.
     1:  *
     1:  ******************************************************************************************/
     1: 
     1: /* Layout the entire inner table. */
     1: NS_METHOD nsTableFrame::Reflow(nsPresContext*           aPresContext,
     1:                                nsHTMLReflowMetrics&     aDesiredSize,
     1:                                const nsHTMLReflowState& aReflowState,
     1:                                nsReflowStatus&          aStatus)
     1: {
     1:   DO_GLOBAL_REFLOW_COUNT("nsTableFrame");
     1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
 79445:   bool isPaginated = aPresContext->IsPaginated();
     1: 
     1:   aStatus = NS_FRAME_COMPLETE;
     1:   if (!GetPrevInFlow() && !mTableLayoutStrategy) {
 80486:     NS_ASSERTION(false, "strategy should have been created in Init");
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1:   nsresult rv = NS_OK;
     1: 
     1:   // see if collapsing borders need to be calculated
     1:   if (!GetPrevInFlow() && IsBorderCollapse() && NeedToCalcBCBorders()) {
     1:     CalcBCBorders();
     1:   }
     1: 
     1:   aDesiredSize.width = aReflowState.availableWidth;
     1: 
     1:   // Check for an overflow list, and append any row group frames being pushed
     1:   MoveOverflowToChildList(aPresContext);
     1: 
 79445:   bool haveDesiredHeight = false;
 80486:   SetHaveReflowedColGroups(false);
     1: 
 21894:   // Reflow the entire table (pass 2 and possibly pass 3). This phase is necessary during a
 21894:   // constrained initial reflow and other reflows which require either a strategy init or balance.
 21894:   // This isn't done during an unconstrained reflow, because it will occur later when the parent
 21894:   // reflows with a constrained width.
 21894:   if (NS_SUBTREE_DIRTY(this) ||
 21894:       aReflowState.ShouldReflowAllKids() ||
 21894:       IsGeometryDirty() ||
 21894:       aReflowState.mFlags.mVResize) {
 21894: 
 21894:     if (aReflowState.ComputedHeight() != NS_UNCONSTRAINEDSIZE ||
  2543:         // Also check mVResize, to handle the first Reflow preceding a
  2543:         // special height Reflow, when we've already had a special height
  2543:         // Reflow (where mComputedHeight would not be
  2543:         // NS_UNCONSTRAINEDSIZE, but without a style change in between).
  2543:         aReflowState.mFlags.mVResize) {
  1589:       // XXX Eventually, we should modify DistributeHeightToRows to use
  1589:       // nsTableRowFrame::GetHeight instead of nsIFrame::GetSize().height.
  1589:       // That way, it will make its calculations based on internal table
  1589:       // frame heights as they are before they ever had any extra height
  1589:       // distributed to them.  In the meantime, this reflows all the
  1589:       // internal table frames, which restores them to their state before
  1589:       // DistributeHeightToRows was called.
  1589:       SetGeometryDirty();
  1589:     }
  1589: 
 79445:     bool needToInitiateSpecialReflow =
 21893:       !!(GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
     1:     // see if an extra reflow will be necessary in pagination mode when there is a specified table height
     1:     if (isPaginated && !GetPrevInFlow() && (NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight)) {
     1:       nscoord tableSpecifiedHeight = CalcBorderBoxHeight(aReflowState);
     1:       if ((tableSpecifiedHeight > 0) &&
     1:           (tableSpecifiedHeight != NS_UNCONSTRAINEDSIZE)) {
 80486:         needToInitiateSpecialReflow = true;
     1:       }
     1:     }
106838:     nsIFrame* lastChildReflowed = nullptr;
     1: 
  6738:     NS_ASSERTION(!aReflowState.mFlags.mSpecialHeightReflow,
  6738:                  "Shouldn't be in special height reflow here!");
     1: 
     1:     // do the pass 2 reflow unless this is a special height reflow and we will be
     1:     // initiating a special height reflow
     1:     // XXXldb I changed this.  Should I change it back?
     1: 
     1:     // if we need to initiate a special height reflow, then don't constrain the
     1:     // height of the reflow before that
     1:     nscoord availHeight = needToInitiateSpecialReflow
     1:                           ? NS_UNCONSTRAINEDSIZE : aReflowState.availableHeight;
     1: 
     1:     ReflowTable(aDesiredSize, aReflowState, availHeight,
     1:                 lastChildReflowed, aStatus);
     1: 
     1:     // reevaluate special height reflow conditions
     1:     if (GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT)
 80486:       needToInitiateSpecialReflow = true;
     1: 
     1:     // XXXldb Are all these conditions correct?
     1:     if (needToInitiateSpecialReflow && NS_FRAME_IS_COMPLETE(aStatus)) {
     1:       // XXXldb Do we need to set the mVResize flag on any reflow states?
     1: 
  6738:       nsHTMLReflowState &mutable_rs =
  6738:         const_cast<nsHTMLReflowState&>(aReflowState);
  6738: 
     1:       // distribute extra vertical space to rows
     1:       CalcDesiredHeight(aReflowState, aDesiredSize);
 80486:       mutable_rs.mFlags.mSpecialHeightReflow = true;
     1: 
     1:       ReflowTable(aDesiredSize, aReflowState, aReflowState.availableHeight,
     1:                   lastChildReflowed, aStatus);
     1: 
     1:       if (lastChildReflowed && NS_FRAME_IS_NOT_COMPLETE(aStatus)) {
     1:         // if there is an incomplete child, then set the desired height to include it but not the next one
     1:         nsMargin borderPadding = GetChildAreaOffset(&aReflowState);
     1:         aDesiredSize.height = borderPadding.bottom + GetCellSpacingY() +
     1:                               lastChildReflowed->GetRect().YMost();
     1:       }
 80486:       haveDesiredHeight = true;
 80486: 
 80486:       mutable_rs.mFlags.mSpecialHeightReflow = false;
  6738:     }
     1:   }
 16484:   else {
 16484:     // Calculate the overflow area contribution from our children.
 77154:     for (nsIFrame* kid = GetFirstPrincipalChild(); kid; kid = kid->GetNextSibling()) {
 55039:       ConsiderChildOverflow(aDesiredSize.mOverflowAreas, kid);
 16484:     }
 16484:   }
     1: 
     1:   aDesiredSize.width = aReflowState.ComputedWidth() +
     1:                        aReflowState.mComputedBorderPadding.LeftRight();
     1:   if (!haveDesiredHeight) {
     1:     CalcDesiredHeight(aReflowState, aDesiredSize);
     1:   }
     1:   if (IsRowInserted()) {
 11285:     ProcessRowInserted(aDesiredSize.height);
     1:   }
     1: 
     1:   nsMargin borderPadding = GetChildAreaOffset(&aReflowState);
     1:   SetColumnDimensions(aDesiredSize.height, borderPadding);
     1:   if (NeedToCollapse() &&
     1:       (NS_UNCONSTRAINEDSIZE != aReflowState.availableWidth)) {
     1:     AdjustForCollapsingRowsCols(aDesiredSize, borderPadding);
     1:   }
     1: 
     1:   // make sure the table overflow area does include the table rect.
     1:   nsRect tableRect(0, 0, aDesiredSize.width, aDesiredSize.height) ;
     1: 
 87630:   if (!ApplyOverflowClipping(this, aReflowState.mStyleDisplay)) {
     1:     // collapsed border may leak out
     1:     nsMargin bcMargin = GetExcludedOuterBCBorder();
     1:     tableRect.Inflate(bcMargin);
     1:   }
 55039:   aDesiredSize.mOverflowAreas.UnionAllWith(tableRect);
     1: 
115328:   if ((GetStateBits() & NS_FRAME_FIRST_REFLOW) ||
115328:       nsSize(aDesiredSize.width, aDesiredSize.height) != mRect.Size()) {
115328:       nsIFrame::InvalidateFrame();
115328:   }
115328: 
     1:   FinishAndStoreOverflow(&aDesiredSize);
     1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
     1:   return rv;
     1: }
     1: 
 87626: bool
 87626: nsTableFrame::UpdateOverflow()
 87626: {
 87626:   nsRect bounds(nsPoint(0, 0), GetSize());
 87626: 
 87626:   // As above in Reflow, make sure the table overflow area includes the table
 87626:   // rect, and check for collapsed borders leaking out.
 87630:   if (!ApplyOverflowClipping(this, GetStyleDisplay())) {
 87626:     nsMargin bcMargin = GetExcludedOuterBCBorder();
 87626:     bounds.Inflate(bcMargin);
 87626:   }
 87626: 
 87626:   nsOverflowAreas overflowAreas(bounds, bounds);
 87626:   nsLayoutUtils::UnionChildOverflow(this, overflowAreas);
 87626: 
 87626:   return FinishAndStoreOverflow(overflowAreas, GetSize());
 87626: }
 87626: 
     1: nsresult
     1: nsTableFrame::ReflowTable(nsHTMLReflowMetrics&     aDesiredSize,
     1:                           const nsHTMLReflowState& aReflowState,
     1:                           nscoord                  aAvailHeight,
     1:                           nsIFrame*&               aLastChildReflowed,
     1:                           nsReflowStatus&          aStatus)
     1: {
     1:   nsresult rv = NS_OK;
106838:   aLastChildReflowed = nullptr;
     1: 
     1:   if (!GetPrevInFlow()) {
     1:     mTableLayoutStrategy->ComputeColumnWidths(aReflowState);
     1:   }
     1:   // Constrain our reflow width to the computed table width (of the 1st in flow).
     1:   // and our reflow height to our avail height minus border, padding, cellspacing
     1:   aDesiredSize.width = aReflowState.ComputedWidth() +
     1:                        aReflowState.mComputedBorderPadding.LeftRight();
   238:   nsTableReflowState reflowState(*PresContext(), aReflowState, *this,
     1:                                  aDesiredSize.width, aAvailHeight);
     1:   ReflowChildren(reflowState, aStatus, aLastChildReflowed,
 55038:                  aDesiredSize.mOverflowAreas);
     1: 
     1:   ReflowColGroups(aReflowState.rendContext);
     1:   return rv;
     1: }
     1: 
     1: nsIFrame*
     1: nsTableFrame::GetFirstBodyRowGroupFrame()
     1: {
106838:   nsIFrame* headerFrame = nullptr;
106838:   nsIFrame* footerFrame = nullptr;
106838: 
106838:   for (nsIFrame* kidFrame = mFrames.FirstChild(); nullptr != kidFrame; ) {
     1:     const nsStyleDisplay* childDisplay = kidFrame->GetStyleDisplay();
     1: 
     1:     // We expect the header and footer row group frames to be first, and we only
     1:     // allow one header and one footer
     1:     if (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == childDisplay->mDisplay) {
     1:       if (headerFrame) {
     1:         // We already have a header frame and so this header frame is treated
     1:         // like an ordinary body row group frame
     1:         return kidFrame;
     1:       }
     1:       headerFrame = kidFrame;
     1: 
     1:     } else if (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == childDisplay->mDisplay) {
     1:       if (footerFrame) {
     1:         // We already have a footer frame and so this footer frame is treated
     1:         // like an ordinary body row group frame
     1:         return kidFrame;
     1:       }
     1:       footerFrame = kidFrame;
     1: 
     1:     } else if (NS_STYLE_DISPLAY_TABLE_ROW_GROUP == childDisplay->mDisplay) {
     1:       return kidFrame;
     1:     }
     1: 
     1:     // Get the next child
     1:     kidFrame = kidFrame->GetNextSibling();
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: // Table specific version that takes into account repeated header and footer
     1: // frames when continuing table frames
     1: void
 37262: nsTableFrame::PushChildren(const RowGroupArray& aRowGroups,
108991:                            int32_t aPushFrom)
     1: {
     1:   NS_PRECONDITION(aPushFrom > 0, "pushing first child");
     1: 
     1:   // extract the frames from the array into a sibling list
     1:   nsFrameList frames;
108991:   uint32_t childX;
 37262:   for (childX = aPushFrom; childX < aRowGroups.Length(); ++childX) {
 37262:     nsTableRowGroupFrame* rgFrame = aRowGroups[childX];
 58965:     if (!rgFrame->IsRepeatable()) {
 37262:       mFrames.RemoveFrame(rgFrame);
106838:       frames.AppendFrame(nullptr, rgFrame);
     1:     }
     1:   }
     1: 
 57069:   if (frames.IsEmpty()) {
 57069:     return;
 57069:   }
 57069: 
 57069:   nsTableFrame* nextInFlow = static_cast<nsTableFrame*>(GetNextInFlow());
 57069:   if (nextInFlow) {
 57069:     // Insert the frames after any repeated header and footer frames.
     1:     nsIFrame* firstBodyFrame = nextInFlow->GetFirstBodyRowGroupFrame();
106838:     nsIFrame* prevSibling = nullptr;
     1:     if (firstBodyFrame) {
 33388:       prevSibling = firstBodyFrame->GetPrevSibling();
     1:     }
     1:     // When pushing and pulling frames we need to check for whether any
     1:     // views need to be reparented.
 30941:     ReparentFrameViewList(PresContext(), frames, this, nextInFlow);
 30941:     nextInFlow->mFrames.InsertFrames(nextInFlow, prevSibling,
 30941:                                      frames);
     1:   }
 57069:   else {
 57069:     // Add the frames to our overflow list.
 30781:     SetOverflowFrames(PresContext(), frames);
 30781:   }
 30781: }
     1: 
     1: // collapsing row groups, rows, col groups and cols are accounted for after both passes of
     1: // reflow so that it has no effect on the calculations of reflow.
     1: void
     1: nsTableFrame::AdjustForCollapsingRowsCols(nsHTMLReflowMetrics& aDesiredSize,
     1:                                           nsMargin             aBorderPadding)
     1: {
     1:   nscoord yTotalOffset = 0; // total offset among all rows in all row groups
     1: 
 28441:   // reset the bit, it will be set again if row/rowgroup or col/colgroup are
 28441:   // collapsed
 80486:   SetNeedToCollapse(false);
     1: 
     1:   // collapse the rows and/or row groups as necessary
     1:   // Get the ordered children
  2141:   RowGroupArray rowGroups;
  2141:   OrderRowGroups(rowGroups);
 29426: 
 29426:   nsTableFrame* firstInFlow = static_cast<nsTableFrame*> (GetFirstInFlow());
 29426:   nscoord width = firstInFlow->GetCollapsedWidth(aBorderPadding);
     1:   nscoord rgWidth = width - 2 * GetCellSpacingX();
 55024:   nsOverflowAreas overflow;
     1:   // Walk the list of children
108991:   for (uint32_t childX = 0; childX < rowGroups.Length(); childX++) {
  2141:     nsTableRowGroupFrame* rgFrame = rowGroups[childX];
  2141:     NS_ASSERTION(rgFrame, "Must have row group frame here");
     1:     yTotalOffset += rgFrame->CollapseRowGroupIfNecessary(yTotalOffset, rgWidth);
 55024:     ConsiderChildOverflow(overflow, rgFrame);
     1:   }
     1: 
     1:   aDesiredSize.height -= yTotalOffset;
     1:   aDesiredSize.width   = width;
 55024:   overflow.UnionAllWith(nsRect(0, 0, aDesiredSize.width, aDesiredSize.height));
 55024:   FinishAndStoreOverflow(overflow,
     1:                          nsSize(aDesiredSize.width, aDesiredSize.height));
     1: }
     1: 
 29426: 
     1: nscoord
     1: nsTableFrame::GetCollapsedWidth(nsMargin aBorderPadding)
     1: {
 29426:   NS_ASSERTION(!GetPrevInFlow(), "GetCollapsedWidth called on next in flow");
     1:   nscoord cellSpacingX = GetCellSpacingX();
     1:   nscoord width = cellSpacingX;
     1:   width += aBorderPadding.left + aBorderPadding.right;
     1:   for (nsIFrame* groupFrame = mColGroups.FirstChild(); groupFrame;
     1:          groupFrame = groupFrame->GetNextSibling()) {
     1:     const nsStyleVisibility* groupVis = groupFrame->GetStyleVisibility();
 79445:     bool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE == groupVis->mVisible);
     1:     nsTableColGroupFrame* cgFrame = (nsTableColGroupFrame*)groupFrame;
     1:     for (nsTableColFrame* colFrame = cgFrame->GetFirstColumn(); colFrame;
     1:          colFrame = colFrame->GetNextCol()) {
     1:       const nsStyleDisplay* colDisplay = colFrame->GetStyleDisplay();
108991:       int32_t colX = colFrame->GetColIndex();
     1:       if (NS_STYLE_DISPLAY_TABLE_COLUMN == colDisplay->mDisplay) {
     1:         const nsStyleVisibility* colVis = colFrame->GetStyleVisibility();
 79445:         bool collapseCol = (NS_STYLE_VISIBILITY_COLLAPSE == colVis->mVisible);
108991:         int32_t colWidth = GetColumnWidth(colX);
     1:         if (!collapseGroup && !collapseCol) {
     1:           width += colWidth;
 19643:           if (ColumnHasCellSpacingBefore(colX))
     1:             width += cellSpacingX;
     1:         }
 29426:         else {
 80486:           SetNeedToCollapse(true);
 29426:         }
     1:       }
     1:     }
     1:   }
     1:   return width;
     1: }
     1: 
 20614: /* virtual */ void
 20836: nsTableFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
 20836: {
108322:   nsContainerFrame::DidSetStyleContext(aOldStyleContext);
108322: 
 20836:   if (!aOldStyleContext) //avoid this on init
 20836:     return;
 20836: 
 20836:   if (IsBorderCollapse() &&
 20836:       BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
 82828:     SetFullBCDamageArea();
 20836:   }
 20836: 
 20614:   //avoid this on init or nextinflow
 20614:   if (!mTableLayoutStrategy || GetPrevInFlow())
 20614:     return;
 20614: 
 79445:   bool isAuto = IsAutoLayout();
 20614:   if (isAuto != (LayoutStrategy()->GetType() == nsITableLayoutStrategy::Auto)) {
 20614:     nsITableLayoutStrategy* temp;
 20614:     if (isAuto)
 20614:       temp = new BasicTableLayoutStrategy(this);
 20614:     else
 20614:       temp = new FixedTableLayoutStrategy(this);
 20614: 
 20614:     if (temp) {
 20614:       delete mTableLayoutStrategy;
 20614:       mTableLayoutStrategy = temp;
 20614:     }
 20614:   }
 20614: }
     1: 
     1: 
     1: 
     1: NS_IMETHODIMP
 77154: nsTableFrame::AppendFrames(ChildListID     aListID,
 30941:                            nsFrameList&    aFrameList)
     1: {
 77154:   NS_ASSERTION(aListID == kPrincipalList || aListID == kColGroupList,
     1:                "unexpected child list");
     1: 
     1:   // Because we actually have two child lists, one for col group frames and one
     1:   // for everything else, we need to look at each frame individually
     1:   // XXX The frame construction code should be separating out child frames
     1:   // based on the type, bug 343048.
 30941:   while (!aFrameList.IsEmpty()) {
 30941:     nsIFrame* f = aFrameList.FirstChild();
 30941:     aFrameList.RemoveFrame(f);
     1: 
     1:     // See what kind of frame we have
     1:     const nsStyleDisplay* display = f->GetStyleDisplay();
     1: 
     1:     if (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == display->mDisplay) {
 30941:       nsTableColGroupFrame* lastColGroup =
 30941:         nsTableColGroupFrame::GetLastRealColGroup(this);
108991:       int32_t startColIndex = (lastColGroup)
     1:         ? lastColGroup->GetStartColumnIndex() + lastColGroup->GetColCount() : 0;
106838:       mColGroups.InsertFrame(nullptr, lastColGroup, f);
     1:       // Insert the colgroup and its cols into the table
 30941:       InsertColGroups(startColIndex,
 30941:                       nsFrameList::Slice(mColGroups, f, f->GetNextSibling()));
     1:     } else if (IsRowGroup(display->mDisplay)) {
     1:       // Append the new row group frame to the sibling chain
106838:       mFrames.AppendFrame(nullptr, f);
     1: 
     1:       // insert the row group and its rows into the table
106838:       InsertRowGroups(nsFrameList::Slice(mFrames, f, nullptr));
     1:     } else {
     1:       // Nothing special to do, just add the frame to our child list
 30941:       NS_NOTREACHED("How did we get here?  Frame construction screwed up");
106838:       mFrames.AppendFrame(nullptr, f);
     1:     }
     1:   }
     1: 
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   printf("=== TableFrame::AppendFrames\n");
 80486:   Dump(true, true, true);
     1: #endif
  1158:   PresContext()->PresShell()->FrameNeedsReflow(this, nsIPresShell::eTreeChange,
  1158:                                                NS_FRAME_HAS_DIRTY_CHILDREN);
     1:   SetGeometryDirty();
     1: 
     1:   return NS_OK;
     1: }
     1: 
100082: // Needs to be at file scope or ArrayLength fails to compile.
100082: struct ChildListInsertions {
100082:   nsIFrame::ChildListID mID;
100082:   nsFrameList mList;
100082: };
100082: 
     1: NS_IMETHODIMP
 77154: nsTableFrame::InsertFrames(ChildListID     aListID,
     1:                            nsIFrame*       aPrevFrame,
 30941:                            nsFrameList&    aFrameList)
     1: {
100082:   // The frames in aFrameList can be a mix of row group frames and col group
100082:   // frames. The problem is that they should go in separate child lists so
100082:   // we need to deal with that here...
     1:   // XXX The frame construction code should be separating out child frames
     1:   // based on the type, bug 343048.
 19815: 
     1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
     1:                "inserting after sibling frame with different parent");
     1: 
 27678:   if ((aPrevFrame && !aPrevFrame->GetNextSibling()) ||
 77154:       (!aPrevFrame && GetChildList(aListID).IsEmpty())) {
 27678:     // Treat this like an append; still a workaround for bug 343048.
 77154:     return AppendFrames(aListID, aFrameList);
 27678:   }
 27678: 
100082:   // Collect ColGroupFrames into a separate list and insert those separately
100082:   // from the other frames (bug 759249).
100082:   ChildListInsertions insertions[2]; // ColGroup, other
100082:   const nsStyleDisplay* display = aFrameList.FirstChild()->GetStyleDisplay();
100082:   nsFrameList::FrameLinkEnumerator e(aFrameList);
100082:   for (; !aFrameList.IsEmpty(); e.Next()) {
100082:     nsIFrame* next = e.NextFrame();
100082:     if (!next || next->GetStyleDisplay()->mDisplay != display->mDisplay) {
100082:       nsFrameList head = aFrameList.ExtractHead(e);
100082:       if (display->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) {
100082:         insertions[0].mID = kColGroupList;
106838:         insertions[0].mList.AppendFrames(nullptr, head);
100082:       } else {
100082:         insertions[1].mID = kPrincipalList;
106838:         insertions[1].mList.AppendFrames(nullptr, head);
100082:       }
100082:       if (!next) {
100082:         break;
100082:       }
100082:       display = next->GetStyleDisplay();
100082:     }
100082:   }
108991:   for (uint32_t i = 0; i < ArrayLength(insertions); ++i) {
100082:     // We pass aPrevFrame for both ColGroup and other frames since
100082:     // HomogenousInsertFrames will only use it if it's a suitable
100082:     // prev-sibling for the frames in the frame list.
100082:     if (!insertions[i].mList.IsEmpty()) {
100082:       HomogenousInsertFrames(insertions[i].mID, aPrevFrame,
100082:                              insertions[i].mList);
100082:     }
100082:   }
100082:   return NS_OK;
100082: }
100082: 
100082: void
100082: nsTableFrame::HomogenousInsertFrames(ChildListID     aListID,
100082:                                      nsIFrame*       aPrevFrame,
100082:                                      nsFrameList&    aFrameList)
100082: {
     1:   // See what kind of frame we have
 30941:   const nsStyleDisplay* display = aFrameList.FirstChild()->GetStyleDisplay();
 19815: #ifdef DEBUG
100082:   // Verify that either all siblings have display:table-column-group, or they
100082:   // all have display values different from table-column-group.
 30941:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
 30941:     const nsStyleDisplay* nextDisplay = e.get()->GetStyleDisplay();
100082:     MOZ_ASSERT((display->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) ==
 19815:                (nextDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP),
 19815:                "heterogenous childlist");
 19815:   }
 19815: #endif
     1:   if (aPrevFrame) {
     1:     const nsStyleDisplay* prevDisplay = aPrevFrame->GetStyleDisplay();
     1:     // Make sure they belong on the same frame list
     1:     if ((display->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) !=
     1:         (prevDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP)) {
     1:       // the previous frame is not valid, see comment at ::AppendFrames
     1:       // XXXbz Using content indices here means XBL will get screwed
     1:       // over...  Oh, well.
 30941:       nsIFrame* pseudoFrame = aFrameList.FirstChild();
     1:       nsIContent* parentContent = GetContent();
     1:       nsIContent* content;
106838:       aPrevFrame = nullptr;
     1:       while (pseudoFrame  && (parentContent ==
     1:                               (content = pseudoFrame->GetContent()))) {
 77154:         pseudoFrame = pseudoFrame->GetFirstPrincipalChild();
     1:       }
     1:       nsCOMPtr<nsIContent> container = content->GetParent();
120353:       if (MOZ_LIKELY(container)) { // XXX need this null-check, see bug 411823.
108991:         int32_t newIndex = container->IndexOf(content);
     1:         nsIFrame* kidFrame;
 79445:         bool isColGroup = (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP ==
     1:                              display->mDisplay);
 20832:         nsTableColGroupFrame* lastColGroup;
     1:         if (isColGroup) {
     1:           kidFrame = mColGroups.FirstChild();
 30941:           lastColGroup = nsTableColGroupFrame::GetLastRealColGroup(this);
     1:         }
     1:         else {
     1:           kidFrame = mFrames.FirstChild();
     1:         }
     1:         // Important: need to start at a value smaller than all valid indices
108991:         int32_t lastIndex = -1;
     1:         while (kidFrame) {
     1:           if (isColGroup) {
 20832:             if (kidFrame == lastColGroup) {
 20832:               aPrevFrame = kidFrame; // there is no real colgroup after this one
 20832:               break;
     1:             }
     1:           }
     1:           pseudoFrame = kidFrame;
     1:           while (pseudoFrame  && (parentContent ==
     1:                                   (content = pseudoFrame->GetContent()))) {
 77154:             pseudoFrame = pseudoFrame->GetFirstPrincipalChild();
     1:           }
108991:           int32_t index = container->IndexOf(content);
     1:           if (index > lastIndex && index < newIndex) {
     1:             lastIndex = index;
     1:             aPrevFrame = kidFrame;
     1:           }
     1:           kidFrame = kidFrame->GetNextSibling();
     1:         }
     1:       }
     1:     }
 10306:   }
     1:   if (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == display->mDisplay) {
100082:     NS_ASSERTION(aListID == kColGroupList, "unexpected child list");
 30941:     // Insert the column group frames
 30941:     const nsFrameList::Slice& newColgroups =
106838:       mColGroups.InsertFrames(nullptr, aPrevFrame, aFrameList);
     1:     // find the starting col index for the first new col group
108991:     int32_t startColIndex = 0;
     1:     if (aPrevFrame) {
     1:       nsTableColGroupFrame* prevColGroup =
     1:         (nsTableColGroupFrame*)GetFrameAtOrBefore(this, aPrevFrame,
     1:                                                   nsGkAtoms::tableColGroupFrame);
     1:       if (prevColGroup) {
     1:         startColIndex = prevColGroup->GetStartColumnIndex() + prevColGroup->GetColCount();
     1:       }
     1:     }
 30941:     InsertColGroups(startColIndex, newColgroups);
     1:   } else if (IsRowGroup(display->mDisplay)) {
 77154:     NS_ASSERTION(aListID == kPrincipalList, "unexpected child list");
     1:     // Insert the frames in the sibling chain
 30941:     const nsFrameList::Slice& newRowGroups =
106838:       mFrames.InsertFrames(nullptr, aPrevFrame, aFrameList);
     1: 
 30941:     InsertRowGroups(newRowGroups);
     1:   } else {
 77154:     NS_ASSERTION(aListID == kPrincipalList, "unexpected child list");
 30941:     NS_NOTREACHED("How did we even get here?");
     1:     // Just insert the frame and don't worry about reflowing it
106838:     mFrames.InsertFrames(nullptr, aPrevFrame, aFrameList);
100082:     return;
     1:   }
     1: 
  1158:   PresContext()->PresShell()->FrameNeedsReflow(this, nsIPresShell::eTreeChange,
  1158:                                                NS_FRAME_HAS_DIRTY_CHILDREN);
     1:   SetGeometryDirty();
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   printf("=== TableFrame::InsertFrames\n");
 80486:   Dump(true, true, true);
     1: #endif
100082:   return;
     1: }
     1: 
124532: void
124532: nsTableFrame::DoRemoveFrame(ChildListID     aListID,
     1:                             nsIFrame*       aOldFrame)
     1: {
 77154:   if (aListID == kColGroupList) {
     1:     nsIFrame* nextColGroupFrame = aOldFrame->GetNextSibling();
     1:     nsTableColGroupFrame* colGroup = (nsTableColGroupFrame*)aOldFrame;
108991:     int32_t firstColIndex = colGroup->GetStartColumnIndex();
108991:     int32_t lastColIndex  = firstColIndex + colGroup->GetColCount() - 1;
     1:     mColGroups.DestroyFrame(aOldFrame);
     1:     nsTableColGroupFrame::ResetColIndices(nextColGroupFrame, firstColIndex);
     1:     // remove the cols from the table
108991:     int32_t colX;
     1:     for (colX = lastColIndex; colX >= firstColIndex; colX--) {
 24724:       nsTableColFrame* colFrame = mColFrames.SafeElementAt(colX);
     1:       if (colFrame) {
 80486:         RemoveCol(colGroup, colX, true, false);
     1:       }
     1:     }
     1: 
108991:     int32_t numAnonymousColsToAdd = GetColCount() - mColFrames.Length();
     1:     if (numAnonymousColsToAdd > 0) {
     1:       // this sets the child list, updates the col cache and cell map
 30207:       AppendAnonymousColFrames(numAnonymousColsToAdd);
     1:     }
     1: 
     1:   } else {
 77154:     NS_ASSERTION(aListID == kPrincipalList, "unexpected child list");
 37262:     nsTableRowGroupFrame* rgFrame =
 37262:       static_cast<nsTableRowGroupFrame*>(aOldFrame);
     1:     // remove the row group from the cell map
     1:     nsTableCellMap* cellMap = GetCellMap();
     1:     if (cellMap) {
     1:       cellMap->RemoveGroupCellMap(rgFrame);
     1:     }
     1: 
     1:     // remove the row group frame from the sibling chain
     1:     mFrames.DestroyFrame(aOldFrame);
     1: 
 37262:     // the removal of a row group changes the cellmap, the columns might change
     1:     if (cellMap) {
     1:       cellMap->Synchronize(this);
 30941:       // Create an empty slice
106838:       ResetRowIndices(nsFrameList::Slice(mFrames, nullptr, nullptr));
 87904:       nsIntRect damageArea;
106838:       cellMap->RebuildConsideringCells(nullptr, nullptr, 0, 0, false, damageArea);
     1: 
124532:       ((nsTableFrame*)GetFirstInFlow())->MatchCellMapToColCache(cellMap);
124532:     }
124532:   }
124532: }
124532: 
124532: NS_IMETHODIMP
124532: nsTableFrame::RemoveFrame(ChildListID     aListID,
124532:                           nsIFrame*       aOldFrame)
124532: {
124532:   NS_ASSERTION(aListID == kColGroupList ||
124532:                NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP !=
124532:                  aOldFrame->GetStyleDisplay()->mDisplay,
124532:                "Wrong list name; use kColGroupList iff colgroup");
124532:   nsIPresShell* shell = PresContext()->PresShell();
124532:   nsTableFrame* lastParent = nullptr;
124532:   while (aOldFrame) {
124532:     nsIFrame* oldFrameNextContinuation = aOldFrame->GetNextContinuation();
124532:     nsTableFrame* parent = static_cast<nsTableFrame*>(aOldFrame->GetParent());
124532:     if (parent != lastParent) {
124532:       parent->DrainSelfOverflowList();
124532:     }
124532:     parent->DoRemoveFrame(aListID, aOldFrame);
124532:     aOldFrame = oldFrameNextContinuation;
124532:     if (parent != lastParent) {
     1:       // for now, just bail and recalc all of the collapsing borders
 37262:       // as the cellmap changes we need to recalc
124532:       if (parent->IsBorderCollapse()) {
124532:         parent->SetFullBCDamageArea();
124532:       }
124532:       parent->SetGeometryDirty();
124532:       shell->FrameNeedsReflow(parent, nsIPresShell::eTreeChange,
  1158:                               NS_FRAME_HAS_DIRTY_CHILDREN);
124532:       lastParent = parent;
124532:     }
124532:   }
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   printf("=== TableFrame::RemoveFrame\n");
 80486:   Dump(true, true, true);
     1: #endif
     1:   return NS_OK;
     1: }
     1: 
     1: /* virtual */ nsMargin
     1: nsTableFrame::GetUsedBorder() const
     1: {
     1:   if (!IsBorderCollapse())
 86231:     return nsContainerFrame::GetUsedBorder();
     1: 
     1:   return GetIncludedOuterBCBorder();
     1: }
     1: 
     1: /* virtual */ nsMargin
     1: nsTableFrame::GetUsedPadding() const
     1: {
     1:   if (!IsBorderCollapse())
 86231:     return nsContainerFrame::GetUsedPadding();
     1: 
     1:   return nsMargin(0,0,0,0);
     1: }
     1: 
 79490: /* virtual */ nsMargin
 79490: nsTableFrame::GetUsedMargin() const
 79490: {
 79490:   // The margin is inherited to the outer table frame via
 79490:   // the ::-moz-table-outer rule in ua.css.
 79490:   return nsMargin(0, 0, 0, 0);
 79490: }
 79490: 
 39965: // Destructor function for BCPropertyData properties
 39965: static void
 39965: DestroyBCProperty(void* aPropertyValue)
 39965: {
 39965:   delete static_cast<BCPropertyData*>(aPropertyValue);
 39965: }
 39965: 
 39965: NS_DECLARE_FRAME_PROPERTY(TableBCProperty, DestroyBCProperty)
 39965: 
 82828: BCPropertyData*
 82828: nsTableFrame::GetBCProperty(bool aCreateIfNecessary) const
 82828: {
 82828:   FrameProperties props = Properties();
 82828:   BCPropertyData* value = static_cast<BCPropertyData*>
 82828:                           (props.Get(TableBCProperty()));
 82828:   if (!value && aCreateIfNecessary) {
 82828:     value = new BCPropertyData();
 82828:     props.Set(TableBCProperty(), value);
 82828:   }
 82828: 
 82828:   return value;
 82828: }
 82828: 
     1: static void
 34593: DivideBCBorderSize(BCPixelSize  aPixelSize,
 34593:                    BCPixelSize& aSmallHalf,
 34593:                    BCPixelSize& aLargeHalf)
     1: {
     1:   aSmallHalf = aPixelSize / 2;
     1:   aLargeHalf = aPixelSize - aSmallHalf;
     1: }
     1: 
     1: nsMargin
     1: nsTableFrame::GetOuterBCBorder() const
     1: {
     1:   if (NeedToCalcBCBorders())
  3233:     const_cast<nsTableFrame*>(this)->CalcBCBorders();
     1: 
     1:   nsMargin border(0, 0, 0, 0);
108991:   int32_t p2t = nsPresContext::AppUnitsPerCSSPixel();
 82828:   BCPropertyData* propData = GetBCProperty();
     1:   if (propData) {
 24768:     border.top    = BC_BORDER_TOP_HALF_COORD(p2t, propData->mTopBorderWidth);
 24768:     border.right  = BC_BORDER_RIGHT_HALF_COORD(p2t, propData->mRightBorderWidth);
 24768:     border.bottom = BC_BORDER_BOTTOM_HALF_COORD(p2t, propData->mBottomBorderWidth);
 24768:     border.left   = BC_BORDER_LEFT_HALF_COORD(p2t, propData->mLeftBorderWidth);
     1:   }
     1:   return border;
     1: }
     1: 
     1: nsMargin
     1: nsTableFrame::GetIncludedOuterBCBorder() const
     1: {
 24768:   if (NeedToCalcBCBorders())
 24768:     const_cast<nsTableFrame*>(this)->CalcBCBorders();
 24768: 
     1:   nsMargin border(0, 0, 0, 0);
108991:   int32_t p2t = nsPresContext::AppUnitsPerCSSPixel();
 82828:   BCPropertyData* propData = GetBCProperty();
 24768:   if (propData) {
 24768:     border.top += BC_BORDER_TOP_HALF_COORD(p2t, propData->mTopBorderWidth);
 24768:     border.right += BC_BORDER_RIGHT_HALF_COORD(p2t, propData->mRightCellBorderWidth);
 24768:     border.bottom += BC_BORDER_BOTTOM_HALF_COORD(p2t, propData->mBottomBorderWidth);
 24768:     border.left += BC_BORDER_LEFT_HALF_COORD(p2t, propData->mLeftCellBorderWidth);
 24768:   }
     1:   return border;
     1: }
     1: 
     1: nsMargin
     1: nsTableFrame::GetExcludedOuterBCBorder() const
     1: {
 24768:   return GetOuterBCBorder() - GetIncludedOuterBCBorder();
     1: }
 30511: 
     1: static
     1: void GetSeparateModelBorderPadding(const nsHTMLReflowState* aReflowState,
     1:                                    nsStyleContext&          aStyleContext,
     1:                                    nsMargin&                aBorderPadding)
     1: {
     1:   // XXXbz Either we _do_ have a reflow state and then we can use its
     1:   // mComputedBorderPadding or we don't and then we get the padding
     1:   // wrong!
     1:   const nsStyleBorder* border = aStyleContext.GetStyleBorder();
 99855:   aBorderPadding = border->GetComputedBorder();
     1:   if (aReflowState) {
     1:     aBorderPadding += aReflowState->mComputedPadding;
     1:   }
     1: }
     1: 
     1: nsMargin
     1: nsTableFrame::GetChildAreaOffset(const nsHTMLReflowState* aReflowState) const
     1: {
     1:   nsMargin offset(0,0,0,0);
     1:   if (IsBorderCollapse()) {
 24768:     offset = GetIncludedOuterBCBorder();
     1:   }
     1:   else {
     1:     GetSeparateModelBorderPadding(aReflowState, *mStyleContext, offset);
     1:   }
     1:   return offset;
     1: }
     1: 
     1: void
     1: nsTableFrame::InitChildReflowState(nsHTMLReflowState& aReflowState)
     1: {
     1:   nsMargin collapseBorder;
     1:   nsMargin padding(0,0,0,0);
106838:   nsMargin* pCollapseBorder = nullptr;
   238:   nsPresContext* presContext = PresContext();
     1:   if (IsBorderCollapse()) {
 37262:     nsTableRowGroupFrame* rgFrame =
 37262:        static_cast<nsTableRowGroupFrame*>(aReflowState.frame);
     1:     pCollapseBorder = rgFrame->GetBCBorderWidth(collapseBorder);
     1:   }
     1:   aReflowState.Init(presContext, -1, -1, pCollapseBorder, &padding);
     1: 
     1:   NS_ASSERTION(!mBits.mResizedColumns ||
     1:                !aReflowState.parentReflowState->mFlags.mSpecialHeightReflow,
     1:                "should not resize columns on special height reflow");
     1:   if (mBits.mResizedColumns) {
 80486:     aReflowState.mFlags.mHResize = true;
     1:   }
     1: }
     1: 
     1: // Position and size aKidFrame and update our reflow state. The origin of
     1: // aKidRect is relative to the upper-left origin of our frame
     1: void nsTableFrame::PlaceChild(nsTableReflowState&  aReflowState,
     1:                               nsIFrame*            aKidFrame,
 11384:                               nsHTMLReflowMetrics& aKidDesiredSize,
 13144:                               const nsRect&        aOriginalKidRect,
 55037:                               const nsRect&        aOriginalKidVisualOverflow)
 11384: {
115328:   bool isFirstReflow =
115328:     (aKidFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) != 0;
115328: 
     1:   // Place and size the child
106838:   FinishReflowChild(aKidFrame, PresContext(), nullptr, aKidDesiredSize,
     1:                     aReflowState.x, aReflowState.y, 0);
     1: 
115328:   InvalidateTableFrame(aKidFrame, aOriginalKidRect, aOriginalKidVisualOverflow,
115328:                        isFirstReflow);
115328: 
     1:   // Adjust the running y-offset
     1:   aReflowState.y += aKidDesiredSize.height;
     1: 
     1:   // If our height is constrained, then update the available height
     1:   if (NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height) {
     1:     aReflowState.availSize.height -= aKidDesiredSize.height;
     1:   }
     1: }
     1: 
     1: void
 37262: nsTableFrame::OrderRowGroups(RowGroupArray& aChildren,
 37262:                              nsTableRowGroupFrame** aHead,
 37262:                              nsTableRowGroupFrame** aFoot) const
     1: {
     1:   aChildren.Clear();
106838:   nsTableRowGroupFrame* head = nullptr;
106838:   nsTableRowGroupFrame* foot = nullptr;
     1: 
     1:   nsIFrame* kidFrame = mFrames.FirstChild();
     1:   while (kidFrame) {
     1:     const nsStyleDisplay* kidDisplay = kidFrame->GetStyleDisplay();
 37262:     nsTableRowGroupFrame* rowGroup =
 37262:       static_cast<nsTableRowGroupFrame*>(kidFrame);
 37262: 
     1:     switch (kidDisplay->mDisplay) {
     1:     case NS_STYLE_DISPLAY_TABLE_HEADER_GROUP:
     1:       if (head) { // treat additional thead like tbody
  2141:         aChildren.AppendElement(rowGroup);
     1:       }
     1:       else {
  2141:         head = rowGroup;
     1:       }
     1:       break;
     1:     case NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP:
  2141:       if (foot) { // treat additional tfoot like tbody
  2141:         aChildren.AppendElement(rowGroup);
     1:       }
     1:       else {
  2141:         foot = rowGroup;
  2141:       }
  2141:       break;
  2141:     case NS_STYLE_DISPLAY_TABLE_ROW_GROUP:
  2141:       aChildren.AppendElement(rowGroup);
     1:       break;
     1:     default:
  2141:       NS_NOTREACHED("How did this produce an nsTableRowGroupFrame?");
  2141:       // Just ignore it
  2141:       break;
  2141:     }
     1:     // Get the next sibling but skip it if it's also the next-in-flow, since
     1:     // a next-in-flow will not be part of the current table.
     1:     while (kidFrame) {
     1:       nsIFrame* nif = kidFrame->GetNextInFlow();
     1:       kidFrame = kidFrame->GetNextSibling();
     1:       if (kidFrame != nif)
     1:         break;
     1:     }
     1:   }
  2141: 
     1:   // put the thead first
     1:   if (head) {
  2141:     aChildren.InsertElementAt(0, head);
  2141:   }
 37262:   if (aHead)
 37262:     *aHead = head;
     1:   // put the tfoot after the last tbody
     1:   if (foot) {
  2141:     aChildren.AppendElement(foot);
  2141:   }
 37262:   if (aFoot)
 37262:     *aFoot = foot;
 37262: }
 37262: 
 37262: nsTableRowGroupFrame*
 37262: nsTableFrame::GetTHead() const
 37262: {
  2141:   nsIFrame* kidFrame = mFrames.FirstChild();
  2141:   while (kidFrame) {
 37262:     if (kidFrame->GetStyleDisplay()->mDisplay ==
 37262:           NS_STYLE_DISPLAY_TABLE_HEADER_GROUP) {
 37262:       return static_cast<nsTableRowGroupFrame*>(kidFrame);
  2141:     }
  2141: 
  2141:     // Get the next sibling but skip it if it's also the next-in-flow, since
  2141:     // a next-in-flow will not be part of the current table.
  2141:     while (kidFrame) {
  2141:       nsIFrame* nif = kidFrame->GetNextInFlow();
  2141:       kidFrame = kidFrame->GetNextSibling();
  2141:       if (kidFrame != nif)
  2141:         break;
  2141:     }
  2141:   }
  2141: 
106838:   return nullptr;
  2141: }
  2141: 
  2141: nsTableRowGroupFrame*
 37262: nsTableFrame::GetTFoot() const
  2141: {
  2141:   nsIFrame* kidFrame = mFrames.FirstChild();
  2141:   while (kidFrame) {
  2141:     if (kidFrame->GetStyleDisplay()->mDisplay ==
 37262:           NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP) {
 37262:       return static_cast<nsTableRowGroupFrame*>(kidFrame);
  2141:     }
  2141: 
  2141:     // Get the next sibling but skip it if it's also the next-in-flow, since
  2141:     // a next-in-flow will not be part of the current table.
  2141:     while (kidFrame) {
  2141:       nsIFrame* nif = kidFrame->GetNextInFlow();
  2141:       kidFrame = kidFrame->GetNextSibling();
  2141:       if (kidFrame != nif)
  2141:         break;
  2141:     }
  2141:   }
  2141: 
106838:   return nullptr;
  2141: }
  2141: 
 79445: static bool
  8727: IsRepeatable(nscoord aFrameHeight, nscoord aPageHeight)
  8727: {
  8727:   return aFrameHeight < (aPageHeight / 4);
  8727: }
  8727: 
  8727: nsresult
  8727: nsTableFrame::SetupHeaderFooterChild(const nsTableReflowState& aReflowState,
  8727:                                      nsTableRowGroupFrame* aFrame,
  8727:                                      nscoord* aDesiredHeight)
  8727: {
  8727:   nsPresContext* presContext = PresContext();
  8727:   nscoord pageHeight = presContext->GetPageSize().height;
  8727: 
  8727:   // Reflow the child with unconstrainted height
  8727:   nsHTMLReflowState kidReflowState(presContext, aReflowState.reflowState,
  8727:                                    aFrame,
  8727:                                    nsSize(aReflowState.availSize.width, NS_UNCONSTRAINEDSIZE),
 80486:                                    -1, -1, false);
  8727:   InitChildReflowState(kidReflowState);
 80486:   kidReflowState.mFlags.mIsTopOfPage = true;
  8727:   nsHTMLReflowMetrics desiredSize;
  8727:   desiredSize.width = desiredSize.height = 0;
  8727:   nsReflowStatus status;
  8727:   nsresult rv = ReflowChild(aFrame, presContext, desiredSize, kidReflowState,
  8727:                             aReflowState.x, aReflowState.y, 0, status);
  8727:   NS_ENSURE_SUCCESS(rv, rv);
  8727:   // The child will be reflowed again "for real" so no need to place it now
  8727: 
  8727:   aFrame->SetRepeatable(IsRepeatable(desiredSize.height, pageHeight));
  8727:   *aDesiredHeight = desiredSize.height;
  8727:   return NS_OK;
     1: }
     1: 
 42270: void 
 42270: nsTableFrame::PlaceRepeatedFooter(nsTableReflowState& aReflowState,
 42270:                                   nsTableRowGroupFrame *aTfoot,
 42270:                                   nscoord aFooterHeight)
 42270: {
 42270:   nsPresContext* presContext = PresContext();
 42270:   nsSize kidAvailSize(aReflowState.availSize);
 42270:   kidAvailSize.height = aFooterHeight;
 42270:   nsHTMLReflowState footerReflowState(presContext,
 42270:                                       aReflowState.reflowState,
 42270:                                       aTfoot, kidAvailSize,
 80486:                                       -1, -1, false);
 42270:   InitChildReflowState(footerReflowState);
 42270:   aReflowState.y += GetCellSpacingY();
 42270: 
 42270:   nsRect origTfootRect = aTfoot->GetRect();
 55037:   nsRect origTfootVisualOverflow = aTfoot->GetVisualOverflowRect();
 42270:           
 42270:   nsReflowStatus footerStatus;
 42270:   nsHTMLReflowMetrics desiredSize;
 42270:   desiredSize.width = desiredSize.height = 0;
 42270:   ReflowChild(aTfoot, presContext, desiredSize, footerReflowState,
 42270:               aReflowState.x, aReflowState.y,
 42270:               NS_FRAME_INVALIDATE_ON_MOVE, footerStatus);
 42270:   PlaceChild(aReflowState, aTfoot, desiredSize, origTfootRect,
 55037:              origTfootVisualOverflow);
 42270: }
 42270:                     
     1: // Reflow the children based on the avail size and reason in aReflowState
     1: // update aReflowMetrics a aStatus
 55038: nsresult
     1: nsTableFrame::ReflowChildren(nsTableReflowState& aReflowState,
     1:                              nsReflowStatus&     aStatus,
     1:                              nsIFrame*&          aLastChildReflowed,
 55038:                              nsOverflowAreas&    aOverflowAreas)
     1: {
     1:   aStatus = NS_FRAME_COMPLETE;
106838:   aLastChildReflowed = nullptr;
106838: 
106838:   nsIFrame* prevKidFrame = nullptr;
     1:   nsresult  rv = NS_OK;
     1:   nscoord   cellSpacingY = GetCellSpacingY();
     1: 
   238:   nsPresContext* presContext = PresContext();
     1:   // XXXldb Should we be checking constrained height instead?
 75395:   // tables are not able to pull back children from its next inflow, so even
 75395:   // under paginated contexts tables are should not paginate if they are inside
 75395:   // column set
 79445:   bool isPaginated = presContext->IsPaginated() &&
 75395:                        NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height &&
 75395:                        aReflowState.reflowState.mFlags.mTableIsSplittable;
     1: 
 55038:   aOverflowAreas.Clear();
     1: 
 79445:   bool reflowAllKids = aReflowState.reflowState.ShouldReflowAllKids() ||
  1589:                          mBits.mResizedColumns ||
  1589:                          IsGeometryDirty();
     1: 
 37262:   RowGroupArray rowGroups;
     1:   nsTableRowGroupFrame *thead, *tfoot;
 37262:   OrderRowGroups(rowGroups, &thead, &tfoot);
 79445:   bool pageBreak = false;
  8727:   nscoord footerHeight = 0;
  8727: 
  8727:   // Determine the repeatablility of headers and footers, and also the desired
  8727:   // height of any repeatable footer.
  8727:   // The repeatability of headers on continued tables is handled
  8727:   // when they are created in nsCSSFrameConstructor::CreateContinuingTableFrame.
  8727:   // We handle the repeatability of footers again here because we need to
  8727:   // determine the footer's height anyway. We could perhaps optimize by
  8727:   // using the footer's prev-in-flow's height instead of reflowing it again,
  8727:   // but there's no real need.
  8727:   if (isPaginated) {
  8727:     if (thead && !GetPrevInFlow()) {
  8727:       nscoord desiredHeight;
  8727:       rv = SetupHeaderFooterChild(aReflowState, thead, &desiredHeight);
  8727:       if (NS_FAILED(rv))
  8727:         return rv;
  8727:     }
  8727:     if (tfoot) {
  8727:       rv = SetupHeaderFooterChild(aReflowState, tfoot, &footerHeight);
  8727:       if (NS_FAILED(rv))
  8727:         return rv;
  8727:     }
  8727:   }
 42270:    // if the child is a tbody in paginated mode reduce the height by a repeated footer
 79445:   bool allowRepeatedFooter = false;
108991:   for (uint32_t childX = 0; childX < rowGroups.Length(); childX++) {
  2141:     nsIFrame* kidFrame = rowGroups[childX];
     1:     // Get the frame state bits
     1:     // See if we should only reflow the dirty child frames
     1:     if (reflowAllKids ||
  1158:         NS_SUBTREE_DIRTY(kidFrame) ||
     1:         (aReflowState.reflowState.mFlags.mSpecialHeightReflow &&
     1:          (isPaginated || (kidFrame->GetStateBits() &
     1:                           NS_FRAME_CONTAINS_RELATIVE_HEIGHT)))) {
     1:       if (pageBreak) {
 42270:         if (allowRepeatedFooter) {
 42270:           PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
 42270:         }
 75396:         else if (tfoot && tfoot->IsRepeatable()) {
 80486:           tfoot->SetRepeatable(false);
 75396:         }
 75396:         PushChildren(rowGroups, childX);
     1:         aStatus = NS_FRAME_NOT_COMPLETE;
     1:         break;
     1:       }
     1: 
     1:       nsSize kidAvailSize(aReflowState.availSize);
 80486:       allowRepeatedFooter = false;
     1:       if (isPaginated && (NS_UNCONSTRAINEDSIZE != kidAvailSize.height)) {
 37262:         nsTableRowGroupFrame* kidRG =
 37262:           static_cast<nsTableRowGroupFrame*>(kidFrame);
  8727:         if (kidRG != thead && kidRG != tfoot && tfoot && tfoot->IsRepeatable()) {
  8727:           // the child is a tbody and there is a repeatable footer
  8727:           NS_ASSERTION(tfoot == rowGroups[rowGroups.Length() - 1], "Missing footer!");
  8727:           if (footerHeight + cellSpacingY < kidAvailSize.height) {
 80486:             allowRepeatedFooter = true;
  8727:             kidAvailSize.height -= footerHeight + cellSpacingY;
     1:           }
     1:         }
     1:       }
     1: 
     1:       nsRect oldKidRect = kidFrame->GetRect();
 55037:       nsRect oldKidVisualOverflow = kidFrame->GetVisualOverflowRect();
     1: 
     1:       nsHTMLReflowMetrics desiredSize;
     1:       desiredSize.width = desiredSize.height = 0;
     1: 
     1:       // Reflow the child into the available space
     1:       nsHTMLReflowState kidReflowState(presContext, aReflowState.reflowState,
     1:                                        kidFrame, kidAvailSize,
 80486:                                        -1, -1, false);
     1:       InitChildReflowState(kidReflowState);
     1: 
 14430:       // If this isn't the first row group, and the previous row group has a
 14430:       // nonzero YMost, then we can't be at the top of the page.
121350:       // We ignore a repeated head row group in this check to avoid causing
 14430:       // infinite loops in some circumstances - see bug 344883.
121350:       if (childX > ((thead && IsRepeatedFrame(thead)) ? 1 : 0) &&
 14430:           (rowGroups[childX - 1]->GetRect().YMost() > 0)) {
 80486:         kidReflowState.mFlags.mIsTopOfPage = false;
     1:       }
     1:       aReflowState.y += cellSpacingY;
     1:       if (NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height) {
     1:         aReflowState.availSize.height -= cellSpacingY;
     1:       }
     1:       // record the presence of a next in flow, it might get destroyed so we
     1:       // need to reorder the row group array
 79445:       bool reorder = false;
     1:       if (kidFrame->GetNextInFlow())
 80486:         reorder = true;
     1: 
     1:       rv = ReflowChild(kidFrame, presContext, desiredSize, kidReflowState,
 11384:                        aReflowState.x, aReflowState.y,
 11384:                        NS_FRAME_INVALIDATE_ON_MOVE, aStatus);
     1: 
     1:       if (reorder) {
     1:         // reorder row groups the reflow may have changed the nextinflows
 37262:         OrderRowGroups(rowGroups, &thead, &tfoot);
  2141:         childX = rowGroups.IndexOf(kidFrame);
  2141:         if (childX == RowGroupArray::NoIndex) {
  2141:           // XXXbz can this happen?
 37262:           childX = rowGroups.Length();
     1:         }
     1:       }
121350:       if (isPaginated && !NS_FRAME_IS_FULLY_COMPLETE(aStatus) &&
121350:           ShouldAvoidBreakInside(aReflowState.reflowState)) {
121350:         aStatus = NS_INLINE_LINE_BREAK_BEFORE();
121350:         break;
121350:       }
     1:       // see if the rowgroup did not fit on this page might be pushed on
     1:       // the next page
121350:       if (isPaginated &&
121350:           (NS_INLINE_IS_BREAK_BEFORE(aStatus) ||
121350:            (NS_FRAME_IS_COMPLETE(aStatus) &&
     1:             (NS_UNCONSTRAINEDSIZE != kidReflowState.availableHeight) &&
121350:             kidReflowState.availableHeight < desiredSize.height))) {
121350:         if (ShouldAvoidBreakInside(aReflowState.reflowState)) {
121350:           aStatus = NS_INLINE_LINE_BREAK_BEFORE();
121350:           break;
121350:         }
     1:         // if we are on top of the page place with dataloss
     1:         if (kidReflowState.mFlags.mIsTopOfPage) {
  2141:           if (childX+1 < rowGroups.Length()) {
  2141:             nsIFrame* nextRowGroupFrame = rowGroups[childX + 1];
     1:             if (nextRowGroupFrame) {
 13144:               PlaceChild(aReflowState, kidFrame, desiredSize, oldKidRect,
 55037:                          oldKidVisualOverflow);
 42270:               if (allowRepeatedFooter) {
 42270:                 PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
 42270:               }
 75396:               else if (tfoot && tfoot->IsRepeatable()) {
 80486:                 tfoot->SetRepeatable(false);
 75396:               }
     1:               aStatus = NS_FRAME_NOT_COMPLETE;
     1:               PushChildren(rowGroups, childX + 1);
     1:               aLastChildReflowed = kidFrame;
     1:               break;
     1:             }
     1:           }
     1:         }
     1:         else { // we are not on top, push this rowgroup onto the next page
     1:           if (prevKidFrame) { // we had a rowgroup before so push this
 42270:             if (allowRepeatedFooter) {
 42270:               PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
 42270:             }
 75396:             else if (tfoot && tfoot->IsRepeatable()) {
 80486:               tfoot->SetRepeatable(false);
 75396:             }
     1:             aStatus = NS_FRAME_NOT_COMPLETE;
     1:             PushChildren(rowGroups, childX);
     1:             aLastChildReflowed = prevKidFrame;
     1:             break;
     1:           }
 74400:           else { // we can't push so lets make clear how much space we need
 74400:             PlaceChild(aReflowState, kidFrame, desiredSize, oldKidRect,
 74400:                                      oldKidVisualOverflow);
 74400:             aLastChildReflowed = kidFrame;
 74400:             if (allowRepeatedFooter) {
 74400:               PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
 74400:               aLastChildReflowed = tfoot;
 74400:             }
 74400:             break;
 74400:           }
     1:         }
     1:       }
     1: 
     1:       aLastChildReflowed   = kidFrame;
     1: 
 80486:       pageBreak = false;
     1:       // see if there is a page break after this row group or before the next one
     1:       if (NS_FRAME_IS_COMPLETE(aStatus) && isPaginated &&
     1:           (NS_UNCONSTRAINEDSIZE != kidReflowState.availableHeight)) {
  2141:         nsIFrame* nextKid =
106838:           (childX + 1 < rowGroups.Length()) ? rowGroups[childX + 1] : nullptr;
 42270:         pageBreak = PageBreakAfter(kidFrame, nextKid);
     1:       }
     1: 
     1:       // Place the child
 13144:       PlaceChild(aReflowState, kidFrame, desiredSize, oldKidRect,
 55037:                  oldKidVisualOverflow);
     1: 
     1:       // Remember where we just were in case we end up pushing children
     1:       prevKidFrame = kidFrame;
     1: 
     1:       // Special handling for incomplete children
     1:       if (NS_FRAME_IS_NOT_COMPLETE(aStatus)) {
 64107:         nsIFrame* kidNextInFlow = kidFrame->GetNextInFlow();
     1:         if (!kidNextInFlow) {
     1:           // The child doesn't have a next-in-flow so create a continuing
     1:           // frame. This hooks the child into the flow
     1:           rv = presContext->PresShell()->FrameConstructor()->
 32841:             CreateContinuingFrame(presContext, kidFrame, this, &kidNextInFlow);
     1:           if (NS_FAILED(rv)) {
     1:             aStatus = NS_FRAME_COMPLETE;
     1:             break;
     1:           }
     1: 
126092:           // Insert the kid's new next-in-flow into our sibling list...
106838:           mFrames.InsertFrame(nullptr, kidFrame, kidNextInFlow);
126092:           // and in rowGroups after childX so that it will get pushed below.
 37262:           rowGroups.InsertElementAt(childX + 1,
 37262:                       static_cast <nsTableRowGroupFrame*>(kidNextInFlow));
126092:         }
 32841: 
     1:         // We've used up all of our available space so push the remaining
126092:         // children.
 75396:         if (allowRepeatedFooter) {
 75396:           PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
 75396:         }
 75396:         else if (tfoot && tfoot->IsRepeatable()) {
 80486:           tfoot->SetRepeatable(false);
 75396:         }
126092: 
     1:         nsIFrame* nextSibling = kidFrame->GetNextSibling();
126092:         if (nextSibling) {
     1:           PushChildren(rowGroups, childX + 1);
     1:         }
     1:         break;
     1:       }
     1:     }
     1:     else { // it isn't being reflowed
     1:       aReflowState.y += cellSpacingY;
     1:       nsRect kidRect = kidFrame->GetRect();
     1:       if (kidRect.y != aReflowState.y) {
115328:         // invalidate the old position
115328:         kidFrame->InvalidateFrameSubtree();
     1:         kidRect.y = aReflowState.y;
     1:         kidFrame->SetRect(kidRect);        // move to the new position
     1:         RePositionViews(kidFrame);
115328:         // invalidate the new position
115328:         kidFrame->InvalidateFrameSubtree();
     1:       }
     1:       aReflowState.y += kidRect.height;
     1: 
     1:       // If our height is constrained then update the available height.
     1:       if (NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height) {
     1:         aReflowState.availSize.height -= cellSpacingY + kidRect.height;
     1:       }
     1:     }
 55038:     ConsiderChildOverflow(aOverflowAreas, kidFrame);
     1:   }
     1: 
     1:   // We've now propagated the column resizes and geometry changes to all
     1:   // the children.
 80486:   mBits.mResizedColumns = false;
     1:   ClearGeometryDirty();
     1: 
     1:   return rv;
     1: }
     1: 
     1: void
 68481: nsTableFrame::ReflowColGroups(nsRenderingContext *aRenderingContext)
     1: {
     1:   if (!GetPrevInFlow() && !HaveReflowedColGroups()) {
     1:     nsHTMLReflowMetrics kidMet;
   238:     nsPresContext *presContext = PresContext();
     1:     for (nsIFrame* kidFrame = mColGroups.FirstChild(); kidFrame;
     1:          kidFrame = kidFrame->GetNextSibling()) {
  4768:       if (NS_SUBTREE_DIRTY(kidFrame)) {
     1:         // The column groups don't care about dimensions or reflow states.
     1:         nsHTMLReflowState kidReflowState(presContext, kidFrame,
     1:                                        aRenderingContext, nsSize(0,0));
     1:         nsReflowStatus cgStatus;
     1:         ReflowChild(kidFrame, presContext, kidMet, kidReflowState, 0, 0, 0,
     1:                     cgStatus);
106838:         FinishReflowChild(kidFrame, presContext, nullptr, kidMet, 0, 0, 0);
     1:       }
  4768:     }
 80486:     SetHaveReflowedColGroups(true);
     1:   }
     1: }
     1: 
     1: void
     1: nsTableFrame::CalcDesiredHeight(const nsHTMLReflowState& aReflowState, nsHTMLReflowMetrics& aDesiredSize)
     1: {
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   if (!cellMap) {
 80486:     NS_ASSERTION(false, "never ever call me until the cell map is built!");
     1:     aDesiredSize.height = 0;
     1:     return;
     1:   }
     1:   nscoord  cellSpacingY = GetCellSpacingY();
     1:   nsMargin borderPadding = GetChildAreaOffset(&aReflowState);
     1: 
 37262:   // get the natural height based on the last child's (row group) rect
 37262:   RowGroupArray rowGroups;
 37262:   OrderRowGroups(rowGroups);
 37262:   if (rowGroups.IsEmpty()) {
     1:     // tables can be used as rectangular items without content
     1:     nscoord tableSpecifiedHeight = CalcBorderBoxHeight(aReflowState);
     1:     if ((NS_UNCONSTRAINEDSIZE != tableSpecifiedHeight) &&
     1:         (tableSpecifiedHeight > 0) &&
   238:         eCompatibility_NavQuirks != PresContext()->CompatibilityMode()) {
     1:           // empty tables should not have a size in quirks mode
     1:       aDesiredSize.height = tableSpecifiedHeight;
     1:     }
     1:     else
     1:       aDesiredSize.height = 0;
     1:     return;
     1:   }
108991:   int32_t rowCount = cellMap->GetRowCount();
108991:   int32_t colCount = cellMap->GetColCount();
     1:   nscoord desiredHeight = borderPadding.top + borderPadding.bottom;
     1:   if (rowCount > 0 && colCount > 0) {
     1:     desiredHeight += cellSpacingY;
108991:     for (uint32_t rgX = 0; rgX < rowGroups.Length(); rgX++) {
  2141:       desiredHeight += rowGroups[rgX]->GetSize().height + cellSpacingY;
     1:     }
     1:   }
     1: 
     1:   // see if a specified table height requires dividing additional space to rows
     1:   if (!GetPrevInFlow()) {
     1:     nscoord tableSpecifiedHeight = CalcBorderBoxHeight(aReflowState);
     1:     if ((tableSpecifiedHeight > 0) &&
     1:         (tableSpecifiedHeight != NS_UNCONSTRAINEDSIZE) &&
     1:         (tableSpecifiedHeight > desiredHeight)) {
     1:       // proportionately distribute the excess height to unconstrained rows in each
  1589:       // unconstrained row group.
     1:       DistributeHeightToRows(aReflowState, tableSpecifiedHeight - desiredHeight);
     1:       // this might have changed the overflow area incorporate the childframe overflow area.
     1:       for (nsIFrame* kidFrame = mFrames.FirstChild(); kidFrame; kidFrame = kidFrame->GetNextSibling()) {
 55039:         ConsiderChildOverflow(aDesiredSize.mOverflowAreas, kidFrame);
     1:       }
     1:       desiredHeight = tableSpecifiedHeight;
     1:     }
     1:   }
     1:   aDesiredSize.height = desiredHeight;
     1: }
     1: 
     1: static
     1: void ResizeCells(nsTableFrame& aTableFrame)
     1: {
  2141:   nsTableFrame::RowGroupArray rowGroups;
  2141:   aTableFrame.OrderRowGroups(rowGroups);
     1:   nsHTMLReflowMetrics tableDesiredSize;
     1:   nsRect tableRect = aTableFrame.GetRect();
     1:   tableDesiredSize.width = tableRect.width;
     1:   tableDesiredSize.height = tableRect.height;
 55039:   tableDesiredSize.SetOverflowAreasToDesiredBounds();
     1: 
108991:   for (uint32_t rgX = 0; rgX < rowGroups.Length(); rgX++) {
  2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
     1: 
     1:     nsRect rowGroupRect = rgFrame->GetRect();
     1:     nsHTMLReflowMetrics groupDesiredSize;
     1:     groupDesiredSize.width = rowGroupRect.width;
     1:     groupDesiredSize.height = rowGroupRect.height;
 55039:     groupDesiredSize.SetOverflowAreasToDesiredBounds();
 55039: 
     1:     nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
     1:     while (rowFrame) {
     1:       rowFrame->DidResize();
 55039:       rgFrame->ConsiderChildOverflow(groupDesiredSize.mOverflowAreas, rowFrame);
     1:       rowFrame = rowFrame->GetNextRow();
     1:     }
 55024:     rgFrame->FinishAndStoreOverflow(&groupDesiredSize);
 55039:     tableDesiredSize.mOverflowAreas.UnionWith(groupDesiredSize.mOverflowAreas +
 55039:                                               rgFrame->GetPosition());
     1:   }
 55024:   aTableFrame.FinishAndStoreOverflow(&tableDesiredSize);
     1: }
     1: 
     1: void
     1: nsTableFrame::DistributeHeightToRows(const nsHTMLReflowState& aReflowState,
     1:                                      nscoord                  aAmount)
     1: {
     1:   nscoord cellSpacingY = GetCellSpacingY();
     1: 
     1:   nsMargin borderPadding = GetChildAreaOffset(&aReflowState);
     1: 
  2141:   RowGroupArray rowGroups;
  2141:   OrderRowGroups(rowGroups);
     1: 
     1:   nscoord amountUsed = 0;
     1:   // distribute space to each pct height row whose row group doesn't have a computed
     1:   // height, and base the pct on the table height. If the row group had a computed
     1:   // height, then this was already done in nsTableRowGroupFrame::CalculateRowHeights
  4166:   nscoord pctBasis = aReflowState.ComputedHeight() - (GetCellSpacingY() * (GetRowCount() + 1));
     1:   nscoord yOriginRG = borderPadding.top + GetCellSpacingY();
     1:   nscoord yEndRG = yOriginRG;
108991:   uint32_t rgX;
  2141:   for (rgX = 0; rgX < rowGroups.Length(); rgX++) {
  2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
     1:     nscoord amountUsedByRG = 0;
     1:     nscoord yOriginRow = 0;
     1:     nsRect rgRect = rgFrame->GetRect();
  2141:     if (!rgFrame->HasStyleHeight()) {
     1:       nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
     1:       while (rowFrame) {
     1:         nsRect rowRect = rowFrame->GetRect();
     1:         if ((amountUsed < aAmount) && rowFrame->HasPctHeight()) {
     1:           nscoord pctHeight = rowFrame->GetHeight(pctBasis);
 32531:           nscoord amountForRow = NS_MIN(aAmount - amountUsed, pctHeight - rowRect.height);
     1:           if (amountForRow > 0) {
 11384:             nsRect oldRowRect = rowRect;
     1:             rowRect.height += amountForRow;
 11384:             // XXXbz we don't need to change rowRect.y to be yOriginRow?
     1:             rowFrame->SetRect(rowRect);
     1:             yOriginRow += rowRect.height + cellSpacingY;
     1:             yEndRG += rowRect.height + cellSpacingY;
     1:             amountUsed += amountForRow;
     1:             amountUsedByRG += amountForRow;
     1:             //rowFrame->DidResize();
     1:             nsTableFrame::RePositionViews(rowFrame);
115328: 
115328:             rgFrame->InvalidateFrameWithRect(oldRowRect);
115328:             rgFrame->InvalidateFrame();
     1:           }
     1:         }
     1:         else {
 11384:           if (amountUsed > 0 && yOriginRow != rowRect.y &&
 11384:               !(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
115328:             rowFrame->InvalidateFrameSubtree();
     1:             rowFrame->SetPosition(nsPoint(rowRect.x, yOriginRow));
     1:             nsTableFrame::RePositionViews(rowFrame);
115328:             rowFrame->InvalidateFrameSubtree();
     1:           }
     1:           yOriginRow += rowRect.height + cellSpacingY;
     1:           yEndRG += rowRect.height + cellSpacingY;
     1:         }
     1:         rowFrame = rowFrame->GetNextRow();
     1:       }
     1:       if (amountUsed > 0) {
115328:         if (rgRect.y != yOriginRG) {
115328:           rgFrame->InvalidateFrameSubtree();
115328:         }
115328: 
 11384:         nsRect origRgRect = rgRect;
115328:         nsRect origRgVisualOverflow = rgFrame->GetVisualOverflowRect();
 11384: 
     1:         rgRect.y = yOriginRG;
     1:         rgRect.height += amountUsedByRG;
 11384: 
     1:         rgFrame->SetRect(rgRect);
115328: 
115328:         nsTableFrame::InvalidateTableFrame(rgFrame, origRgRect,
115328:                                            origRgVisualOverflow, false);
 11384:       }
 11384:     }
 16448:     else if (amountUsed > 0 && yOriginRG != rgRect.y) {
115328:       rgFrame->InvalidateFrameSubtree();
 16448:       rgFrame->SetPosition(nsPoint(rgRect.x, yOriginRG));
     1:       // Make sure child views are properly positioned
     1:       nsTableFrame::RePositionViews(rgFrame);
115328:       rgFrame->InvalidateFrameSubtree();
     1:     }
     1:     yOriginRG = yEndRG;
     1:   }
     1: 
     1:   if (amountUsed >= aAmount) {
     1:     ResizeCells(*this);
     1:     return;
     1:   }
     1: 
  9138:   // get the first row without a style height where its row group has an
  9138:   // unconstrained height
106838:   nsTableRowGroupFrame* firstUnStyledRG  = nullptr;
106838:   nsTableRowFrame*      firstUnStyledRow = nullptr;
  2141:   for (rgX = 0; rgX < rowGroups.Length() && !firstUnStyledRG; rgX++) {
  2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
  2141:     if (!rgFrame->HasStyleHeight()) {
     1:       nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
     1:       while (rowFrame) {
     1:         if (!rowFrame->HasStyleHeight()) {
     1:           firstUnStyledRG = rgFrame;
     1:           firstUnStyledRow = rowFrame;
     1:           break;
     1:         }
     1:         rowFrame = rowFrame->GetNextRow();
     1:       }
     1:     }
     1:   }
     1: 
106838:   nsTableRowFrame* lastEligibleRow = nullptr;
  9138:   // Accumulate the correct divisor. This will be the total total height of all
  9138:   // unstyled rows inside unstyled row groups, unless there are none, in which
  9138:   // case, it will be number of all rows. If the unstyled rows don't have a
  9138:   // height, divide the space equally among them.
     1:   nscoord divisor = 0;
108991:   int32_t eligibleRows = 0;
 79445:   bool expandEmptyRows = false;
  9138: 
  9138:   if (!firstUnStyledRow) {
  9138:     // there is no unstyled row
  9138:     divisor = GetRowCount();
  9138:   }
  9138:   else {
  2141:     for (rgX = 0; rgX < rowGroups.Length(); rgX++) {
  2141:       nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
  2141:       if (!firstUnStyledRG || !rgFrame->HasStyleHeight()) {
     1:         nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
     1:         while (rowFrame) {
     1:           if (!firstUnStyledRG || !rowFrame->HasStyleHeight()) {
  9138:             NS_ASSERTION(rowFrame->GetSize().height >= 0,
  9138:                          "negative row frame height");
     1:             divisor += rowFrame->GetSize().height;
  9138:             eligibleRows++;
  9138:             lastEligibleRow = rowFrame;
     1:           }
     1:           rowFrame = rowFrame->GetNextRow();
     1:         }
     1:       }
     1:     }
  9138:     if (divisor <= 0) {
  9138:       if (eligibleRows > 0) {
 80486:         expandEmptyRows = true;
  9138:       }
  9138:       else {
     1:         NS_ERROR("invalid divisor");
     1:         return;
     1:       }
  9138:     }
  9138:   }
     1:   // allocate the extra height to the unstyled row groups and rows
  9138:   nscoord heightToDistribute = aAmount - amountUsed;
     1:   yOriginRG = borderPadding.top + cellSpacingY;
     1:   yEndRG = yOriginRG;
  2141:   for (rgX = 0; rgX < rowGroups.Length(); rgX++) {
  2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
     1:     nscoord amountUsedByRG = 0;
     1:     nscoord yOriginRow = 0;
     1:     nsRect rgRect = rgFrame->GetRect();
 55037:     nsRect rgVisualOverflow = rgFrame->GetVisualOverflowRect();
  9138:     // see if there is an eligible row group or we distribute to all rows
  9138:     if (!firstUnStyledRG || !rgFrame->HasStyleHeight() || !eligibleRows) {
     1:       nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
     1:       while (rowFrame) {
     1:         nsRect rowRect = rowFrame->GetRect();
 55037:         nsRect rowVisualOverflow = rowFrame->GetVisualOverflowRect();
  9138:         // see if there is an eligible row or we distribute to all rows
  9138:         if (!firstUnStyledRow || !rowFrame->HasStyleHeight() || !eligibleRows) {
  9138:           float ratio;
  9138:           if (eligibleRows) {
  9138:             if (!expandEmptyRows) {
  9138:               // The amount of additional space each row gets is proportional to
  9138:               // its height
  9138:               ratio = float(rowRect.height) / float(divisor);
  7988:             } else {
  9138:               // empty rows get all the same additional space
  9138:               ratio = 1.0f / float(eligibleRows);
  9138:             }
  9138:           }
  9138:           else {
  9138:             // all rows get the same additional space
  9138:             ratio = 1.0f / float(divisor);
  9138:           }
  9138:           // give rows their additional space, except for the last row which
  9138:           // gets the remainder
  9138:           nscoord amountForRow = (rowFrame == lastEligibleRow)
  9138:                                  ? aAmount - amountUsed : NSToCoordRound(((float)(heightToDistribute)) * ratio);
 32531:           amountForRow = NS_MIN(amountForRow, aAmount - amountUsed);
 11384: 
115328:           if (yOriginRow != rowRect.y) {
115328:             rowFrame->InvalidateFrameSubtree();
115328:           }
115328: 
     1:           // update the row height
 11384:           nsRect newRowRect(rowRect.x, yOriginRow, rowRect.width,
 11384:                             rowRect.height + amountForRow);
     1:           rowFrame->SetRect(newRowRect);
 11384: 
     1:           yOriginRow += newRowRect.height + cellSpacingY;
     1:           yEndRG += newRowRect.height + cellSpacingY;
     1: 
     1:           amountUsed += amountForRow;
     1:           amountUsedByRG += amountForRow;
     1:           NS_ASSERTION((amountUsed <= aAmount), "invalid row allocation");
     1:           //rowFrame->DidResize();
     1:           nsTableFrame::RePositionViews(rowFrame);
115328: 
115328:           nsTableFrame::InvalidateTableFrame(rowFrame, rowRect, rowVisualOverflow,
115328:                                              false);
     1:         }
     1:         else {
 11384:           if (amountUsed > 0 && yOriginRow != rowRect.y) {
115328:             rowFrame->InvalidateFrameSubtree();
     1:             rowFrame->SetPosition(nsPoint(rowRect.x, yOriginRow));
     1:             nsTableFrame::RePositionViews(rowFrame);
115328:             rowFrame->InvalidateFrameSubtree();
     1:           }
     1:           yOriginRow += rowRect.height + cellSpacingY;
     1:           yEndRG += rowRect.height + cellSpacingY;
     1:         }
     1:         rowFrame = rowFrame->GetNextRow();
     1:       }
     1:       if (amountUsed > 0) {
115328:         if (rgRect.y != yOriginRG) {
115328:           rgFrame->InvalidateFrameSubtree();
115328:         }
115328: 
 11384:         rgFrame->SetRect(nsRect(rgRect.x, yOriginRG, rgRect.width,
 11384:                                 rgRect.height + amountUsedByRG));
115328: 
115328:         nsTableFrame::InvalidateTableFrame(rgFrame, rgRect, rgVisualOverflow,
115328:                                            false);
     1:       }
     1:       // Make sure child views are properly positioned
     1:     }
 16448:     else if (amountUsed > 0 && yOriginRG != rgRect.y) {
115328:       rgFrame->InvalidateFrameSubtree();
 16448:       rgFrame->SetPosition(nsPoint(rgRect.x, yOriginRG));
     1:       // Make sure child views are properly positioned
     1:       nsTableFrame::RePositionViews(rgFrame);
115328:       rgFrame->InvalidateFrameSubtree();
     1:     }
     1:     yOriginRG = yEndRG;
     1:   }
     1: 
     1:   ResizeCells(*this);
     1: }
     1: 
108991: int32_t nsTableFrame::GetColumnWidth(int32_t aColIndex)
     1: {
 87439:   nsTableFrame* firstInFlow = static_cast<nsTableFrame*>(GetFirstInFlow());
     1:   if (this == firstInFlow) {
     1:     nsTableColFrame* colFrame = GetColFrame(aColIndex);
 87439:     return colFrame ? colFrame->GetFinalWidth() : 0;
 87439:   }
 87439:   return firstInFlow->GetColumnWidth(aColIndex);
     1: }
     1: 
     1: // XXX: could cache this.  But be sure to check style changes if you do!
     1: nscoord nsTableFrame::GetCellSpacingX()
     1: {
     1:   if (IsBorderCollapse())
     1:     return 0;
     1: 
 19206:   return GetStyleTableBorder()->mBorderSpacingX;
     1: }
     1: 
     1: // XXX: could cache this. But be sure to check style changes if you do!
     1: nscoord nsTableFrame::GetCellSpacingY()
     1: {
     1:   if (IsBorderCollapse())
     1:     return 0;
     1: 
 19206:   return GetStyleTableBorder()->mBorderSpacingY;
     1: }
     1: 
     1: 
     1: /* virtual */ nscoord
     1: nsTableFrame::GetBaseline() const
     1: {
     1:   nscoord ascent = 0;
  2141:   RowGroupArray orderedRowGroups;
  2141:   OrderRowGroups(orderedRowGroups);
106838:   nsTableRowFrame* firstRow = nullptr;
108991:   for (uint32_t rgIndex = 0; rgIndex < orderedRowGroups.Length(); rgIndex++) {
  2141:     nsTableRowGroupFrame* rgFrame = orderedRowGroups[rgIndex];
     1:     if (rgFrame->GetRowCount()) {
     1:       firstRow = rgFrame->GetFirstRow();
     1:       ascent = rgFrame->GetRect().y + firstRow->GetRect().y + firstRow->GetRowBaseline();
     1:       break;
     1:     }
     1:   }
     1:   if (!firstRow)
     1:     ascent = GetRect().height;
     1:   return ascent;
     1: }
     1: /* ----- global methods ----- */
     1: 
     1: nsIFrame*
     1: NS_NewTableFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsTableFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsTableFrame)
 32423: 
     1: nsTableFrame*
 87441: nsTableFrame::GetTableFrame(nsIFrame* aFrame)
 87441: {
 87441:   for (nsIFrame* ancestor = aFrame->GetParent(); ancestor;
 87441:        ancestor = ancestor->GetParent()) {
 87441:     if (nsGkAtoms::tableFrame == ancestor->GetType()) {
 87441:       return static_cast<nsTableFrame*>(ancestor);
 87441:     }
 87441:   }
 87441:   NS_RUNTIMEABORT("unable to find table parent");
106838:   return nullptr;
     1: }
     1: 
 79445: bool
     1: nsTableFrame::IsAutoHeight()
     1: {
 51406:   const nsStyleCoord &height = GetStylePosition()->mHeight;
 51406:   // Don't consider calc() here like this quirk for percent.
 51406:   return height.GetUnit() == eStyleUnit_Auto ||
 51406:          (height.GetUnit() == eStyleUnit_Percent &&
 51406:           height.GetPercentValue() <= 0.0f);
     1: }
     1: 
     1: nscoord
     1: nsTableFrame::CalcBorderBoxHeight(const nsHTMLReflowState& aState)
     1: {
  4166:   nscoord height = aState.ComputedHeight();
     1:   if (NS_AUTOHEIGHT != height) {
 24768:     nsMargin borderPadding = GetChildAreaOffset(&aState);
     1:     height += borderPadding.top + borderPadding.bottom;
     1:   }
 32531:   height = NS_MAX(0, height);
     1: 
     1:   return height;
     1: }
     1: 
 79445: bool
     1: nsTableFrame::IsAutoLayout()
     1: {
  1068:   if (GetStyleTable()->mLayoutStrategy == NS_STYLE_TABLE_LAYOUT_AUTO)
 80486:     return true;
     1:   // a fixed-layout inline-table must have a width
  8046:   // and tables with 'width: -moz-max-content' must be auto-layout
  1068:   // (at least as long as FixedTableLayoutStrategy::GetPrefWidth returns
  1068:   // nscoord_MAX)
  1068:   const nsStyleCoord &width = GetStylePosition()->mWidth;
  7085:   return (width.GetUnit() == eStyleUnit_Auto) ||
  1068:          (width.GetUnit() == eStyleUnit_Enumerated &&
  8046:           width.GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT);
     1: }
     1: 
     1: #ifdef DEBUG
     1: NS_IMETHODIMP
     1: nsTableFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:   return MakeFrameName(NS_LITERAL_STRING("Table"), aResult);
     1: }
     1: #endif
     1: 
     1: // Find the closet sibling before aPriorChildFrame (including aPriorChildFrame) that
     1: // is of type aChildType
     1: nsIFrame*
     1: nsTableFrame::GetFrameAtOrBefore(nsIFrame*       aParentFrame,
     1:                                  nsIFrame*       aPriorChildFrame,
     1:                                  nsIAtom*        aChildType)
     1: {
106838:   nsIFrame* result = nullptr;
     1:   if (!aPriorChildFrame) {
     1:     return result;
     1:   }
     1:   if (aChildType == aPriorChildFrame->GetType()) {
     1:     return aPriorChildFrame;
     1:   }
     1: 
     1:   // aPriorChildFrame is not of type aChildType, so we need start from
     1:   // the beginnng and find the closest one
106838:   nsIFrame* lastMatchingFrame = nullptr;
 77154:   nsIFrame* childFrame = aParentFrame->GetFirstPrincipalChild();
     1:   while (childFrame && (childFrame != aPriorChildFrame)) {
     1:     if (aChildType == childFrame->GetType()) {
     1:       lastMatchingFrame = childFrame;
     1:     }
     1:     childFrame = childFrame->GetNextSibling();
     1:   }
     1:   return lastMatchingFrame;
     1: }
     1: 
     1: #ifdef DEBUG
     1: void
     1: nsTableFrame::DumpRowGroup(nsIFrame* aKidFrame)
     1: {
 37262:   if (!aKidFrame)
 37262:     return;
 37262: 
 77154:   nsIFrame* cFrame = aKidFrame->GetFirstPrincipalChild();
 26583:   while (cFrame) {
 26583:     nsTableRowFrame *rowFrame = do_QueryFrame(cFrame);
 26583:     if (rowFrame) {
 37269:       printf("row(%d)=%p ", rowFrame->GetRowIndex(),
 37269:              static_cast<void*>(rowFrame));
 77154:       nsIFrame* childFrame = cFrame->GetFirstPrincipalChild();
 26583:       while (childFrame) {
 26583:         nsTableCellFrame *cellFrame = do_QueryFrame(childFrame);
 26583:         if (cellFrame) {
108991:           int32_t colIndex;
 26583:           cellFrame->GetColIndex(colIndex);
 37834:           printf("cell(%d)=%p ", colIndex, static_cast<void*>(childFrame));
 26583:         }
 26583:         childFrame = childFrame->GetNextSibling();
     1:       }
     1:       printf("\n");
     1:     }
     1:     else {
     1:       DumpRowGroup(rowFrame);
     1:     }
 26583:     cFrame = cFrame->GetNextSibling();
     1:   }
     1: }
     1: 
     1: void
 79445: nsTableFrame::Dump(bool            aDumpRows,
 79445:                    bool            aDumpCols,
 79445:                    bool            aDumpCellMap)
     1: {
     1:   printf("***START TABLE DUMP*** \n");
     1:   // dump the columns widths array
     1:   printf("mColWidths=");
108991:   int32_t numCols = GetColCount();
108991:   int32_t colX;
     1:   for (colX = 0; colX < numCols; colX++) {
     1:     printf("%d ", GetColumnWidth(colX));
     1:   }
     1:   printf("\n");
     1: 
     1:   if (aDumpRows) {
     1:     nsIFrame* kidFrame = mFrames.FirstChild();
     1:     while (kidFrame) {
     1:       DumpRowGroup(kidFrame);
     1:       kidFrame = kidFrame->GetNextSibling();
     1:     }
     1:   }
     1: 
     1:   if (aDumpCols) {
     1: 	  // output col frame cache
     1:     printf("\n col frame cache ->");
     1: 	   for (colX = 0; colX < numCols; colX++) {
 24724:       nsTableColFrame* colFrame = mColFrames.ElementAt(colX);
     1:       if (0 == (colX % 8)) {
     1:         printf("\n");
     1:       }
 37269:       printf ("%d=%p ", colX, static_cast<void*>(colFrame));
     1:       nsTableColType colType = colFrame->GetColType();
     1:       switch (colType) {
     1:       case eColContent:
     1:         printf(" content ");
     1:         break;
     1:       case eColAnonymousCol:
     1:         printf(" anonymous-column ");
     1:         break;
     1:       case eColAnonymousColGroup:
     1:         printf(" anonymous-colgroup ");
     1:         break;
     1:       case eColAnonymousCell:
     1:         printf(" anonymous-cell ");
     1:         break;
     1:       }
     1:     }
     1:     printf("\n colgroups->");
     1:     for (nsIFrame* childFrame = mColGroups.FirstChild(); childFrame;
     1:          childFrame = childFrame->GetNextSibling()) {
     1:       if (nsGkAtoms::tableColGroupFrame == childFrame->GetType()) {
     1:         nsTableColGroupFrame* colGroupFrame = (nsTableColGroupFrame *)childFrame;
     1:         colGroupFrame->Dump(1);
     1:       }
     1:     }
     1:     for (colX = 0; colX < numCols; colX++) {
     1:       printf("\n");
     1:       nsTableColFrame* colFrame = GetColFrame(colX);
     1:       colFrame->Dump(1);
     1:     }
     1:   }
     1:   if (aDumpCellMap) {
     1:     nsTableCellMap* cellMap = GetCellMap();
     1:     cellMap->Dump();
     1:   }
     1:   printf(" ***END TABLE DUMP*** \n");
     1: }
     1: #endif
     1: 
     1: // nsTableIterator
     1: nsTableIterator::nsTableIterator(nsIFrame& aSource)
     1: {
 77154:   nsIFrame* firstChild = aSource.GetFirstPrincipalChild();
     1:   Init(firstChild);
     1: }
     1: 
     1: nsTableIterator::nsTableIterator(nsFrameList& aSource)
     1: {
     1:   nsIFrame* firstChild = aSource.FirstChild();
     1:   Init(firstChild);
     1: }
     1: 
     1: void nsTableIterator::Init(nsIFrame* aFirstChild)
     1: {
     1:   mFirstListChild = aFirstChild;
     1:   mFirstChild     = aFirstChild;
106838:   mCurrentChild   = nullptr;
 80486:   mLeftToRight    = true;
     1:   mCount          = -1;
     1: 
     1:   if (!mFirstChild) {
     1:     return;
     1:   }
     1: 
     1:   nsTableFrame* table = nsTableFrame::GetTableFrame(mFirstChild);
     1:   mLeftToRight = (NS_STYLE_DIRECTION_LTR ==
     1:                   table->GetStyleVisibility()->mDirection);
     1: 
     1:   if (!mLeftToRight) {
     1:     mCount = 0;
     1:     nsIFrame* nextChild = mFirstChild->GetNextSibling();
106838:     while (nullptr != nextChild) {
     1:       mCount++;
     1:       mFirstChild = nextChild;
     1:       nextChild = nextChild->GetNextSibling();
     1:     }
     1:   }
     1: }
     1: 
     1: nsIFrame* nsTableIterator::First()
     1: {
     1:   mCurrentChild = mFirstChild;
     1:   return mCurrentChild;
     1: }
     1: 
     1: nsIFrame* nsTableIterator::Next()
     1: {
     1:   if (!mCurrentChild) {
106838:     return nullptr;
     1:   }
     1: 
     1:   if (mLeftToRight) {
     1:     mCurrentChild = mCurrentChild->GetNextSibling();
     1:     return mCurrentChild;
     1:   }
     1:   else {
     1:     nsIFrame* targetChild = mCurrentChild;
106838:     mCurrentChild = nullptr;
     1:     nsIFrame* child = mFirstListChild;
     1:     while (child && (child != targetChild)) {
     1:       mCurrentChild = child;
     1:       child = child->GetNextSibling();
     1:     }
     1:     return mCurrentChild;
     1:   }
     1: }
     1: 
 79445: bool nsTableIterator::IsLeftToRight()
     1: {
     1:   return mLeftToRight;
     1: }
     1: 
108991: int32_t nsTableIterator::Count()
     1: {
     1:   if (-1 == mCount) {
     1:     mCount = 0;
     1:     nsIFrame* child = mFirstListChild;
106838:     while (nullptr != child) {
     1:       mCount++;
     1:       child = child->GetNextSibling();
     1:     }
     1:   }
     1:   return mCount;
     1: }
     1: 
 79445: bool
108991: nsTableFrame::ColumnHasCellSpacingBefore(int32_t aColIndex) const
 19643: {
 19643:   // Since fixed-layout tables should not have their column sizes change
 19643:   // as they load, we assume that all columns are significant.
 19643:   if (LayoutStrategy()->GetType() == nsITableLayoutStrategy::Fixed)
 80486:     return true;
 27451:   // the first column is always significant
 27451:   if (aColIndex == 0)
 80486:     return true;
     1:   nsTableCellMap* cellMap = GetCellMap();
 19643:   if (!cellMap)
 80486:     return false;
 19643:   return cellMap->GetNumCellsOriginatingInCol(aColIndex) > 0;
     1: }
     1: 
     1: /********************************************************************************
     1:  * Collapsing Borders
     1:  *
     1:  *  The CSS spec says to resolve border conflicts in this order:
     1:  *  1) any border with the style HIDDEN wins
     1:  *  2) the widest border with a style that is not NONE wins
     1:  *  3) the border styles are ranked in this order, highest to lowest precedence:
     1:  *     double, solid, dashed, dotted, ridge, outset, groove, inset
     1:  *  4) borders that are of equal width and style (differ only in color) have this precedence:
     1:  *     cell, row, rowgroup, col, colgroup, table
     1:  *  5) if all border styles are NONE, then that's the computed border style.
     1:  *******************************************************************************/
     1: 
 82828: #ifdef DEBUG
 82828: #define VerifyNonNegativeDamageRect(r)                                  \
 82828:   NS_ASSERTION((r).x >= 0, "negative col index");                       \
 82828:   NS_ASSERTION((r).y >= 0, "negative row index");                       \
 82828:   NS_ASSERTION((r).width >= 0, "negative horizontal damage");           \
 82828:   NS_ASSERTION((r).height >= 0, "negative vertical damage");
 82828: #define VerifyDamageRect(r)                                             \
 82828:   VerifyNonNegativeDamageRect(r);                                       \
 82828:   NS_ASSERTION((r).XMost() <= GetColCount(),                            \
 82828:                "horizontal damage extends outside table");              \
 82828:   NS_ASSERTION((r).YMost() <= GetRowCount(),                            \
 82828:                "vertical damage extends outside table");
 82828: #endif
 82828: 
     1: void
 87904: nsTableFrame::AddBCDamageArea(const nsIntRect& aValue)
 82828: {
 82828:   NS_ASSERTION(IsBorderCollapse(), "invalid AddBCDamageArea call");
 82828: #ifdef DEBUG
 82828:   VerifyDamageRect(aValue);
 82828: #endif
 82828: 
 80486:   SetNeedToCalcBCBorders(true);
     1:   // Get the property
 82828:   BCPropertyData* value = GetBCProperty(true);
 82828:   if (value) {
 82828: #ifdef DEBUG
 82828:     VerifyNonNegativeDamageRect(value->mDamageArea);
 82828: #endif
 82828:     // Clamp the old damage area to the current table area in case it shrunk.
108991:     int32_t cols = GetColCount();
 82828:     if (value->mDamageArea.XMost() > cols) {
 82828:       if (value->mDamageArea.x > cols) {
 82828:         value->mDamageArea.x = cols;
 82828:         value->mDamageArea.width = 0;
 82828:       }
 82828:       else {
 82828:         value->mDamageArea.width = cols - value->mDamageArea.x;
 82828:       }
 82828:     }
108991:     int32_t rows = GetRowCount();
 82828:     if (value->mDamageArea.YMost() > rows) {
 82828:       if (value->mDamageArea.y > rows) {
 82828:         value->mDamageArea.y = rows;
 82828:         value->mDamageArea.height = 0;
 82828:       }
 82828:       else {
 82828:         value->mDamageArea.height = rows - value->mDamageArea.y;
 82828:       }
 82828:     }
 82828: 
 82828:     // Construct a union of the new and old damage areas.
 82828:     value->mDamageArea.UnionRect(value->mDamageArea, aValue);
 82828:   }
 82828: }
 82828: 
 82828: 
 82828: void
 82828: nsTableFrame::SetFullBCDamageArea()
 82828: {
 82828:   NS_ASSERTION(IsBorderCollapse(), "invalid SetFullBCDamageArea call");
 82828: 
 82828:   SetNeedToCalcBCBorders(true);
 82828: 
 82828:   BCPropertyData* value = GetBCProperty(true);
 82828:   if (value) {
 87904:     value->mDamageArea = nsIntRect(0, 0, GetColCount(), GetRowCount());
 82828:   }
 82828: }
 82828: 
 29425: 
 29425: /* BCCellBorder represents a border segment which can be either a horizontal
 29425:  * or a vertical segment. For each segment we need to know the color, width,
 29425:  * style, who owns it and how long it is in cellmap coordinates.
 29425:  * Ownership of these segments is important to calculate which corners should
 29425:  * be bevelled. This structure has dual use, its used first to compute the
 29425:  * dominant border for horizontal and vertical segments and to store the
 29425:  * preliminary computed border results in the BCCellBorders structure.
 29425:  * This temporary storage is not symmetric with respect to horizontal and
 29425:  * vertical border segments, its always column oriented. For each column in
 29425:  * the cellmap there is a temporary stored vertical and horizontal segment.
 29425:  * XXX_Bernd this asymmetry is the root of those rowspan bc border errors
 29425:  */
 29425: struct BCCellBorder
 29425: {
 29425:   BCCellBorder() { Reset(0, 1); }
108991:   void Reset(uint32_t aRowIndex, uint32_t aRowSpan);
 29425:   nscolor       color;    // border segment color
 29425:   BCPixelSize   width;    // border segment width in pixel coordinates !!
108991:   uint8_t       style;    // border segment style, possible values are defined
 29425:                           // in nsStyleConsts.h as NS_STYLE_BORDER_STYLE_*
 29425:   BCBorderOwner owner;    // border segment owner, possible values are defined
 29425:                           // in celldata.h. In the cellmap for each border
 29425:                           // segment we store the owner and later when
 29425:                           // painting we know the owner and can retrieve the
 29425:                           // style info from the corresponding frame
108991:   int32_t       rowIndex; // rowIndex of temporary stored horizontal border
 29425:                           // segments relative to the table
108991:   int32_t       rowSpan;  // row span of temporary stored horizontal border
 29425:                           // segments
 29425: };
 29425: 
 29425: void
108991: BCCellBorder::Reset(uint32_t aRowIndex,
108991:                     uint32_t aRowSpan)
 29425: {
 29425:   style = NS_STYLE_BORDER_STYLE_NONE;
 29425:   color = 0;
 29425:   width = 0;
 29425:   owner = eTableOwner;
 29425:   rowIndex = aRowIndex;
 29425:   rowSpan  = aRowSpan;
 29425: }
 29425: 
 29425: class BCMapCellIterator;
 29425: 
     1: /*****************************************************************
 29425:  *  BCMapCellInfo
 29425:  * This structure stores information about the cellmap and all involved
 29425:  * table related frames that are used during the computation of winning borders
 29425:  * in CalcBCBorders so that they do need to be looked up again and again when
 29425:  * iterating over the cells.
     1:  ****************************************************************/
     1: struct BCMapCellInfo
     1: {
 29425:   BCMapCellInfo(nsTableFrame* aTableFrame);
 29425:   void ResetCellInfo();
 29425:   void SetInfo(nsTableRowFrame*   aNewRow,
108991:                int32_t            aColIndex,
 29425:                BCCellData*        aCellData,
 29425:                BCMapCellIterator* aIter,
106838:                nsCellMap*         aCellMap = nullptr);
 29425:   // The BCMapCellInfo has functions to set the continous
 29425:   // border widths (see nsTablePainter.cpp for a description of the continous
 29425:   // borders concept). The widths are computed inside these functions based on
 29425:   // the current position inside the table and the cached frames that correspond
 29425:   // to this position. The widths are stored in member variables of the internal
 29425:   // table frames.
 29425:   void SetTableTopLeftContBCBorder();
 29425:   void SetRowGroupLeftContBCBorder();
 29425:   void SetRowGroupRightContBCBorder();
 29425:   void SetRowGroupBottomContBCBorder();
 29425:   void SetRowLeftContBCBorder();
 29425:   void SetRowRightContBCBorder();
 29425:   void SetColumnTopRightContBCBorder();
 29425:   void SetColumnBottomContBCBorder();
 29425:   void SetColGroupBottomContBCBorder();
 29425:   void SetInnerRowGroupBottomContBCBorder(const nsIFrame* aNextRowGroup,
 29425:                                           nsTableRowFrame* aNextRow);
 29425: 
 29425:   // functions to set the border widths on the table related frames, where the
 29425:   // knowledge about the current position in the table is used.
 29425:   void SetTableTopBorderWidth(BCPixelSize aWidth);
108991:   void SetTableLeftBorderWidth(int32_t aRowY, BCPixelSize aWidth);
108991:   void SetTableRightBorderWidth(int32_t aRowY, BCPixelSize aWidth);
 29425:   void SetTableBottomBorderWidth(BCPixelSize aWidth);
 29425:   void SetLeftBorderWidths(BCPixelSize aWidth);
 29425:   void SetRightBorderWidths(BCPixelSize aWidth);
 29425:   void SetTopBorderWidths(BCPixelSize aWidth);
 29425:   void SetBottomBorderWidths(BCPixelSize aWidth);
 29425: 
 29425:   // functions to compute the borders; they depend on the
 29425:   // knowledge about the current position in the table. The edge functions
 29425:   // should be called if a table edge is involved, otherwise the internal
 29425:   // functions should be called.
 29425:   BCCellBorder GetTopEdgeBorder();
 29425:   BCCellBorder GetBottomEdgeBorder();
 29425:   BCCellBorder GetLeftEdgeBorder();
 29425:   BCCellBorder GetRightEdgeBorder();
 29425:   BCCellBorder GetRightInternalBorder();
 29425:   BCCellBorder GetLeftInternalBorder();
 29425:   BCCellBorder GetTopInternalBorder();
 29425:   BCCellBorder GetBottomInternalBorder();
 29425: 
 29425:   // functions to set the interal position information
108991:   void SetColumn(int32_t aColX);
 29425:   // Increment the row as we loop over the rows of a rowspan
 79445:   void IncrementRow(bool aResetToTopRowOfCell = false);
 29425: 
 29425:   // Helper functions to get extent of the cell
108991:   int32_t GetCellEndRowIndex() const;
108991:   int32_t GetCellEndColIndex() const;
 29425: 
 29425:   // storage of table information
 29425:   nsTableFrame*         mTableFrame;
108991:   int32_t               mNumTableRows;
108991:   int32_t               mNumTableCols;
 29425:   BCPropertyData*       mTableBCData;
 29425: 
 29425:   // storage of table ltr information, the border collapse code swaps the sides
 29425:   // to account for rtl tables, this is done through mStartSide and mEndSide
 79445:   bool                  mTableIsLTR;
 41419:   mozilla::css::Side    mStartSide;
 41419:   mozilla::css::Side    mEndSide;
 29425: 
 29425:   // a cell can only belong to one rowgroup
 29425:   nsTableRowGroupFrame* mRowGroup;
 29425: 
 29425:   // a cell with a rowspan has a top and a bottom row, and rows in between
 29425:   nsTableRowFrame*      mTopRow;
 29425:   nsTableRowFrame*      mBottomRow;
 29425:   nsTableRowFrame*      mCurrentRowFrame;
 29425: 
 29425:   // a cell with a colspan has a left and right column and columns in between
 29425:   // they can belong to different colgroups
 29425:   nsTableColGroupFrame* mColGroup;
 29425:   nsTableColGroupFrame* mCurrentColGroupFrame;
 29425: 
 29425:   nsTableColFrame*      mLeftCol;
 29425:   nsTableColFrame*      mRightCol;
 29425:   nsTableColFrame*      mCurrentColFrame;
 29425: 
 29425:   // cell information
 29425:   BCCellData*           mCellData;
 29425:   nsBCTableCellFrame*   mCell;
 29425: 
108991:   int32_t               mRowIndex;
108991:   int32_t               mRowSpan;
108991:   int32_t               mColIndex;
108991:   int32_t               mColSpan;
 29425: 
 29425:   // flags to describe the position of the cell with respect to the row- and
 29425:   // colgroups, for instance mRgAtTop documents that the top cell border hits
 29425:   // a rowgroup border
 79445:   bool                  mRgAtTop;
 79445:   bool                  mRgAtBottom;
 79445:   bool                  mCgAtLeft;
 79445:   bool                  mCgAtRight;
 29425: 
     1: };
     1: 
 29425: 
 29425: BCMapCellInfo::BCMapCellInfo(nsTableFrame* aTableFrame)
 29425: {
 29425:   mTableFrame = aTableFrame;
 29425:   mTableIsLTR =
 29425:     aTableFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
 29425:   if (mTableIsLTR) {
 29425:     mStartSide = NS_SIDE_LEFT;
 29425:     mEndSide = NS_SIDE_RIGHT;
 29425:   }
 29425:   else {
 29425:     mStartSide = NS_SIDE_RIGHT;
 29425:     mEndSide = NS_SIDE_LEFT;
 29425:   }
 29425:   mNumTableRows = mTableFrame->GetRowCount();
 29425:   mNumTableCols = mTableFrame->GetColCount();
 39965:   mTableBCData = static_cast<BCPropertyData*>
 39965:     (mTableFrame->Properties().Get(TableBCProperty()));
 29425: 
 29425:   ResetCellInfo();
 29425: }
 29425: 
 29425: void BCMapCellInfo::ResetCellInfo()
 29425: {
106838:   mCellData  = nullptr;
106838:   mRowGroup  = nullptr;
106838:   mTopRow    = nullptr;
106838:   mBottomRow = nullptr;
106838:   mColGroup  = nullptr;
106838:   mLeftCol   = nullptr;
106838:   mRightCol  = nullptr;
106838:   mCell      = nullptr;
 29425:   mRowIndex  = mRowSpan = mColIndex = mColSpan = 0;
 80486:   mRgAtTop = mRgAtBottom = mCgAtLeft = mCgAtRight = false;
 29425: }
 29425: 
108991: inline int32_t BCMapCellInfo::GetCellEndRowIndex() const
 29425: {
 29425:   return mRowIndex + mRowSpan - 1;
 29425: }
 29425: 
108991: inline int32_t BCMapCellInfo::GetCellEndColIndex() const
 29425: {
 29425:   return mColIndex + mColSpan - 1;
 29425: }
 29425: 
     1: 
     1: class BCMapCellIterator
     1: {
     1: public:
 29425:   BCMapCellIterator(nsTableFrame* aTableFrame,
 87904:                     const nsIntRect& aDamageArea);
     1: 
     1:   void First(BCMapCellInfo& aMapCellInfo);
     1: 
     1:   void Next(BCMapCellInfo& aMapCellInfo);
     1: 
     1:   void PeekRight(BCMapCellInfo& aRefInfo,
108991:                  uint32_t     aRowIndex,
     1:                  BCMapCellInfo& aAjaInfo);
     1: 
     1:   void PeekBottom(BCMapCellInfo& aRefInfo,
108991:                   uint32_t     aColIndex,
     1:                   BCMapCellInfo& aAjaInfo);
     1: 
 79445:   bool IsNewRow() { return mIsNewRow; }
     1: 
     1:   nsTableRowFrame* GetPrevRow() const { return mPrevRow; }
 29425:   nsTableRowFrame* GetCurrentRow() const { return mRow; }
 29425:   nsTableRowGroupFrame* GetCurrentRowGroup() const { return mRowGroup;}
     1: 
108991:   int32_t    mRowGroupStart;
108991:   int32_t    mRowGroupEnd;
 79445:   bool       mAtEnd;
     1:   nsCellMap* mCellMap;
     1: 
     1: private:
106838:   bool SetNewRow(nsTableRowFrame* row = nullptr);
 79445:   bool SetNewRowGroup(bool aFindFirstDamagedRow);
     1: 
 29425:   nsTableFrame*         mTableFrame;
     1:   nsTableCellMap*       mTableCellMap;
  2141:   nsTableFrame::RowGroupArray mRowGroups;
     1:   nsTableRowGroupFrame* mRowGroup;
108991:   int32_t               mRowGroupIndex;
108991:   uint32_t              mNumTableRows;
     1:   nsTableRowFrame*      mRow;
     1:   nsTableRowFrame*      mPrevRow;
 79445:   bool                  mIsNewRow;
108991:   int32_t               mRowIndex;
108991:   uint32_t              mNumTableCols;
108991:   int32_t               mColIndex;
     1:   nsPoint               mAreaStart;
     1:   nsPoint               mAreaEnd;
     1: };
     1: 
 29425: BCMapCellIterator::BCMapCellIterator(nsTableFrame* aTableFrame,
 87904:                                      const nsIntRect& aDamageArea)
     1: :mTableFrame(aTableFrame)
     1: {
 29425:   mTableCellMap  = aTableFrame->GetCellMap();
     1: 
     1:   mAreaStart.x   = aDamageArea.x;
     1:   mAreaStart.y   = aDamageArea.y;
     1:   mAreaEnd.y     = aDamageArea.y + aDamageArea.height - 1;
     1:   mAreaEnd.x     = aDamageArea.x + aDamageArea.width - 1;
     1: 
 29425:   mNumTableRows  = mTableFrame->GetRowCount();
106838:   mRow           = nullptr;
     1:   mRowIndex      = 0;
 29425:   mNumTableCols  = mTableFrame->GetColCount();
     1:   mColIndex      = 0;
     1:   mRowGroupIndex = -1;
     1: 
     1:   // Get the ordered row groups
 29425:   aTableFrame->OrderRowGroups(mRowGroups);
     1: 
 80486:   mAtEnd = true; // gets reset when First() is called
     1: }
     1: 
 29425: // fill fields that we need for border collapse computation on a given cell
     1: void
 29425: BCMapCellInfo::SetInfo(nsTableRowFrame*   aNewRow,
108991:                        int32_t            aColIndex,
 29425:                        BCCellData*        aCellData,
 29425:                        BCMapCellIterator* aIter,
     1:                        nsCellMap*         aCellMap)
     1: {
 29425:   // fill the cell information
 29425:   mCellData = aCellData;
 29425:   mColIndex = aColIndex;
 29425: 
 29425:   // initialize the row information if it was not previously set for cells in
 29425:   // this row
 29425:   mRowIndex = 0;
 29425:   if (aNewRow) {
 29425:     mTopRow = aNewRow;
 29425:     mRowIndex = aNewRow->GetRowIndex();
 29425:   }
 29425: 
 29425:   // fill cell frame info and row information
106838:   mCell      = nullptr;
 29425:   mRowSpan   = 1;
 29425:   mColSpan   = 1;
     1:   if (aCellData) {
 29425:     mCell = static_cast<nsBCTableCellFrame*>(aCellData->GetCellFrame());
 29425:     if (mCell) {
 29425:       if (!mTopRow) {
 29425:         mTopRow = static_cast<nsTableRowFrame*>(mCell->GetParent());
 29425:         if (!mTopRow) ABORT0();
 29425:         mRowIndex = mTopRow->GetRowIndex();
 29425:       }
 29425:       mColSpan = mTableFrame->GetEffectiveColSpan(*mCell, aCellMap);
 29425:       mRowSpan = mTableFrame->GetEffectiveRowSpan(*mCell, aCellMap);
 29425:     }
 29425:   }
 29425: 
 29425:   if (!mTopRow) {
 29425:     mTopRow = aIter->GetCurrentRow();
 29425:   }
 29425:   if (1 == mRowSpan) {
 29425:     mBottomRow = mTopRow;
     1:   }
     1:   else {
 29425:     mBottomRow = mTopRow->GetNextRow();
 29425:     if (mBottomRow) {
108991:       for (int32_t spanY = 2; mBottomRow && (spanY < mRowSpan); spanY++) {
 29425:         mBottomRow = mBottomRow->GetNextRow();
 29425:       }
 29425:       NS_ASSERTION(mBottomRow, "spanned row not found");
     1:     }
     1:     else {
 80486:       NS_ASSERTION(false, "error in cell map");
 29425:       mRowSpan = 1;
 29425:       mBottomRow = mTopRow;
 29425:     }
 29425:   }
     1:   // row group frame info
 29425:   // try to reuse the rgStart and rgEnd from the iterator as calls to
 29425:   // GetRowCount() are computationally expensive and should be avoided if
 29425:   // possible
108991:   uint32_t rgStart  = aIter->mRowGroupStart;
108991:   uint32_t rgEnd    = aIter->mRowGroupEnd;
 37262:   mRowGroup = static_cast<nsTableRowGroupFrame*>(mTopRow->GetParent());
 29425:   if (mRowGroup != aIter->GetCurrentRowGroup()) {
 29425:     rgStart = mRowGroup->GetStartRowIndex();
 29425:     rgEnd   = rgStart + mRowGroup->GetRowCount() - 1;
 29425:   }
108991:   uint32_t rowIndex = mTopRow->GetRowIndex();
 29425:   mRgAtTop    = (rgStart == rowIndex);
 29425:   mRgAtBottom = (rgEnd == rowIndex + mRowSpan - 1);
     1: 
     1:    // col frame info
 29425:   mLeftCol = mTableFrame->GetColFrame(aColIndex);
 29425:   if (!mLeftCol) ABORT0();
 29425: 
 29425:   mRightCol = mLeftCol;
 29425:   if (mColSpan > 1) {
 29425:     nsTableColFrame* colFrame = mTableFrame->GetColFrame(aColIndex +
 29425:                                                          mColSpan -1);
 29425:     if (!colFrame) ABORT0();
 29425:     mRightCol = colFrame;
     1:   }
     1: 
     1:   // col group frame info
 29425:   mColGroup = static_cast<nsTableColGroupFrame*>(mLeftCol->GetParent());
108991:   int32_t cgStart = mColGroup->GetStartColumnIndex();
108991:   int32_t cgEnd = NS_MAX(0, cgStart + mColGroup->GetColCount() - 1);
 29425:   mCgAtLeft  = (cgStart == aColIndex);
 29425:   mCgAtRight = (cgEnd == aColIndex + mColSpan - 1);
     1: }
     1: 
 79445: bool
     1: BCMapCellIterator::SetNewRow(nsTableRowFrame* aRow)
     1: {
 80486:   mAtEnd   = true;
     1:   mPrevRow = mRow;
     1:   if (aRow) {
     1:     mRow = aRow;
     1:   }
     1:   else if (mRow) {
     1:     mRow = mRow->GetNextRow();
     1:   }
     1:   if (mRow) {
     1:     mRowIndex = mRow->GetRowIndex();
     1:     // get to the first entry with an originating cell
108991:     int32_t rgRowIndex = mRowIndex - mRowGroupStart;
108991:     if (uint32_t(rgRowIndex) >= mCellMap->mRows.Length())
 80486:       ABORT1(false);
     1:     const nsCellMap::CellDataArray& row = mCellMap->mRows[rgRowIndex];
     1: 
     1:     for (mColIndex = mAreaStart.x; mColIndex <= mAreaEnd.x; mColIndex++) {
     1:       CellData* cellData = row.SafeElementAt(mColIndex);
     1:       if (!cellData) { // add a dead cell data
 87904:         nsIntRect damageArea;
106838:         cellData = mCellMap->AppendCell(*mTableCellMap, nullptr, rgRowIndex,
 82828:                                         false, 0, damageArea);
 82828:         if (!cellData) ABORT1(false);
     1:       }
     1:       if (cellData && (cellData->IsOrig() || cellData->IsDead())) {
     1:         break;
     1:       }
     1:     }
 80486:     mIsNewRow = true;
 80486:     mAtEnd    = false;
 80486:   }
 80486:   else ABORT1(false);
     1: 
     1:   return !mAtEnd;
     1: }
     1: 
 79445: bool
 79445: BCMapCellIterator::SetNewRowGroup(bool aFindFirstDamagedRow)
     1: {
 80486:    mAtEnd = true;
108991:   int32_t numRowGroups = mRowGroups.Length();
106838:   mCellMap = nullptr;
  9141:   for (mRowGroupIndex++; mRowGroupIndex < numRowGroups; mRowGroupIndex++) {
  2141:     mRowGroup = mRowGroups[mRowGroupIndex];
108991:     int32_t rowCount = mRowGroup->GetRowCount();
     1:     mRowGroupStart = mRowGroup->GetStartRowIndex();
     1:     mRowGroupEnd   = mRowGroupStart + rowCount - 1;
  9141:     if (rowCount > 0) {
     1:       mCellMap = mTableCellMap->GetMapFor(mRowGroup, mCellMap);
 80486:       if (!mCellMap) ABORT1(false);
     1:       nsTableRowFrame* firstRow = mRowGroup->GetFirstRow();
     1:       if (aFindFirstDamagedRow) {
     1:         if ((mAreaStart.y >= mRowGroupStart) && (mAreaStart.y <= mRowGroupEnd)) {
     1:           // the damage area starts in the row group
     1:           if (aFindFirstDamagedRow) {
     1:             // find the correct first damaged row
108991:             int32_t numRows = mAreaStart.y - mRowGroupStart;
108991:             for (int32_t i = 0; i < numRows; i++) {
  2141:               firstRow = firstRow->GetNextRow();
 80486:               if (!firstRow) ABORT1(false);
     1:             }
     1:           }
     1:         }
     1:         else {
     1:           continue;
     1:         }
     1:       }
     1:       if (SetNewRow(firstRow)) { // sets mAtEnd
     1:         break;
     1:       }
     1:     }
     1:   }
     1: 
     1:   return !mAtEnd;
     1: }
     1: 
     1: void
     1: BCMapCellIterator::First(BCMapCellInfo& aMapInfo)
     1: {
 29425:   aMapInfo.ResetCellInfo();
     1: 
 80486:   SetNewRowGroup(true); // sets mAtEnd
     1:   while (!mAtEnd) {
     1:     if ((mAreaStart.y >= mRowGroupStart) && (mAreaStart.y <= mRowGroupEnd)) {
 29425:       BCCellData* cellData =
 29425:         static_cast<BCCellData*>(mCellMap->GetDataAt(mAreaStart.y -
 29425:                                                       mRowGroupStart,
 29425:                                                       mAreaStart.x));
 64009:       if (cellData && (cellData->IsOrig() || cellData->IsDead())) {
 29425:         aMapInfo.SetInfo(mRow, mAreaStart.x, cellData, this);
 64009:         return;
     1:       }
     1:       else {
 29425:         NS_ASSERTION(((0 == mAreaStart.x) && (mRowGroupStart == mAreaStart.y)) ,
 29425:                      "damage area expanded incorrectly");
 64009:       }
     1:     }
 80486:     SetNewRowGroup(true); // sets mAtEnd
     1:   }
     1: }
     1: 
     1: void
     1: BCMapCellIterator::Next(BCMapCellInfo& aMapInfo)
     1: {
     1:   if (mAtEnd) ABORT0();
 29425:   aMapInfo.ResetCellInfo();
     1: 
 80486:   mIsNewRow = false;
     1:   mColIndex++;
     1:   while ((mRowIndex <= mAreaEnd.y) && !mAtEnd) {
     1:     for (; mColIndex <= mAreaEnd.x; mColIndex++) {
108991:       int32_t rgRowIndex = mRowIndex - mRowGroupStart;
 29425:       BCCellData* cellData =
 29425:          static_cast<BCCellData*>(mCellMap->GetDataAt(rgRowIndex, mColIndex));
     1:       if (!cellData) { // add a dead cell data
 87904:         nsIntRect damageArea;
 29425:         cellData =
106838:           static_cast<BCCellData*>(mCellMap->AppendCell(*mTableCellMap, nullptr,
 82828:                                                          rgRowIndex, false, 0,
 29425:                                                          damageArea));
 29425:         if (!cellData) ABORT0();
     1:       }
     1:       if (cellData && (cellData->IsOrig() || cellData->IsDead())) {
 29425:         aMapInfo.SetInfo(mRow, mColIndex, cellData, this);
     1:         return;
     1:       }
     1:     }
     1:     if (mRowIndex >= mRowGroupEnd) {
 80486:       SetNewRowGroup(false); // could set mAtEnd
     1:     }
     1:     else {
     1:       SetNewRow(); // could set mAtEnd
     1:     }
     1:   }
 80486:   mAtEnd = true;
     1: }
     1: 
     1: void
     1: BCMapCellIterator::PeekRight(BCMapCellInfo&   aRefInfo,
108991:                              uint32_t         aRowIndex,
     1:                              BCMapCellInfo&   aAjaInfo)
     1: {
 29425:   aAjaInfo.ResetCellInfo();
108991:   int32_t colIndex = aRefInfo.mColIndex + aRefInfo.mColSpan;
108991:   uint32_t rgRowIndex = aRowIndex - mRowGroupStart;
     1: 
 29425:   BCCellData* cellData =
 29425:     static_cast<BCCellData*>(mCellMap->GetDataAt(rgRowIndex, colIndex));
     1:   if (!cellData) { // add a dead cell data
     1:     NS_ASSERTION(colIndex < mTableCellMap->GetColCount(), "program error");
 87904:     nsIntRect damageArea;
 29425:     cellData =
106838:       static_cast<BCCellData*>(mCellMap->AppendCell(*mTableCellMap, nullptr,
 82828:                                                      rgRowIndex, false, 0,
 29425:                                                      damageArea));
 29425:     if (!cellData) ABORT0();
     1:   }
106838:   nsTableRowFrame* row = nullptr;
     1:   if (cellData->IsRowSpan()) {
     1:     rgRowIndex -= cellData->GetRowSpanOffset();
 29425:     cellData =
 29425:       static_cast<BCCellData*>(mCellMap->GetDataAt(rgRowIndex, colIndex));
     1:     if (!cellData)
     1:       ABORT0();
     1:   }
     1:   else {
     1:     row = mRow;
     1:   }
 29425:   aAjaInfo.SetInfo(row, colIndex, cellData, this);
     1: }
     1: 
     1: void
     1: BCMapCellIterator::PeekBottom(BCMapCellInfo&   aRefInfo,
108991:                               uint32_t         aColIndex,
     1:                               BCMapCellInfo&   aAjaInfo)
     1: {
 29425:   aAjaInfo.ResetCellInfo();
108991:   int32_t rowIndex = aRefInfo.mRowIndex + aRefInfo.mRowSpan;
108991:   int32_t rgRowIndex = rowIndex - mRowGroupStart;
     1:   nsTableRowGroupFrame* rg = mRowGroup;
     1:   nsCellMap* cellMap = mCellMap;
106838:   nsTableRowFrame* nextRow = nullptr;
     1:   if (rowIndex > mRowGroupEnd) {
108991:     int32_t nextRgIndex = mRowGroupIndex;
     1:     do {
     1:       nextRgIndex++;
  2141:       rg = mRowGroups.SafeElementAt(nextRgIndex);
     1:       if (rg) {
     1:         cellMap = mTableCellMap->GetMapFor(rg, cellMap); if (!cellMap) ABORT0();
     1:         rgRowIndex = 0;
     1:         nextRow = rg->GetFirstRow();
     1:       }
     1:     }
     1:     while (rg && !nextRow);
     1:     if(!rg) return;
     1:   }
     1:   else {
     1:     // get the row within the same row group
     1:     nextRow = mRow;
108991:     for (int32_t i = 0; i < aRefInfo.mRowSpan; i++) {
     1:       nextRow = nextRow->GetNextRow(); if (!nextRow) ABORT0();
     1:     }
     1:   }
     1: 
 29425:   BCCellData* cellData =
 29425:     static_cast<BCCellData*>(cellMap->GetDataAt(rgRowIndex, aColIndex));
     1:   if (!cellData) { // add a dead cell data
     1:     NS_ASSERTION(rgRowIndex < cellMap->GetRowCount(), "program error");
 87904:     nsIntRect damageArea;
 29425:     cellData =
106838:       static_cast<BCCellData*>(cellMap->AppendCell(*mTableCellMap, nullptr,
 82828:                                                     rgRowIndex, false, 0,
 29425:                                                     damageArea));
 29425:     if (!cellData) ABORT0();
     1:   }
     1:   if (cellData->IsColSpan()) {
     1:     aColIndex -= cellData->GetColSpanOffset();
 29425:     cellData =
 29425:       static_cast<BCCellData*>(cellMap->GetDataAt(rgRowIndex, aColIndex));
 29425:   }
 29425:   aAjaInfo.SetInfo(nextRow, aColIndex, cellData, this, cellMap);
     1: }
     1: 
     1: // Assign priorities to border styles. For example, styleToPriority(NS_STYLE_BORDER_STYLE_SOLID)
     1: // will return the priority of NS_STYLE_BORDER_STYLE_SOLID.
108991: static uint8_t styleToPriority[13] = { 0,  // NS_STYLE_BORDER_STYLE_NONE
     1:                                        2,  // NS_STYLE_BORDER_STYLE_GROOVE
     1:                                        4,  // NS_STYLE_BORDER_STYLE_RIDGE
     1:                                        5,  // NS_STYLE_BORDER_STYLE_DOTTED
     1:                                        6,  // NS_STYLE_BORDER_STYLE_DASHED
     1:                                        7,  // NS_STYLE_BORDER_STYLE_SOLID
     1:                                        8,  // NS_STYLE_BORDER_STYLE_DOUBLE
     1:                                        1,  // NS_STYLE_BORDER_STYLE_INSET
     1:                                        3,  // NS_STYLE_BORDER_STYLE_OUTSET
     1:                                        9 };// NS_STYLE_BORDER_STYLE_HIDDEN
     1: // priority rules follow CSS 2.1 spec
     1: // 'hidden', 'double', 'solid', 'dashed', 'dotted', 'ridge', 'outset', 'groove',
     1: // and the lowest: 'inset'. none is even weaker
 80486: #define CELL_CORNER true
     1: 
     1: /** return the border style, border color for a given frame and side
     1:   * @param aFrame           - query the info for this frame
     1:   * @param aSide            - the side of the frame
     1:   * @param aStyle           - the border style
     1:   * @param aColor           - the border color
     1:   * @param aTableIsLTR      - table direction is LTR
     1:   */
     1: static void
     1: GetColorAndStyle(const nsIFrame*  aFrame,
 41419:                  mozilla::css::Side aSide,
108991:                  uint8_t&         aStyle,
     1:                  nscolor&         aColor,
 79445:                  bool             aTableIsLTR)
     1: {
     1:   NS_PRECONDITION(aFrame, "null frame");
     1:   // initialize out arg
     1:   aColor = 0;
     1:   const nsStyleBorder* styleData = aFrame->GetStyleBorder();
     1:   if(!aTableIsLTR) { // revert the directions
     1:     if (NS_SIDE_RIGHT == aSide) {
     1:       aSide = NS_SIDE_LEFT;
     1:     }
     1:     else if (NS_SIDE_LEFT == aSide) {
     1:       aSide = NS_SIDE_RIGHT;
     1:     }
     1:   }
     1:   aStyle = styleData->GetBorderStyle(aSide);
     1: 
     1:   if ((NS_STYLE_BORDER_STYLE_NONE == aStyle) ||
     1:       (NS_STYLE_BORDER_STYLE_HIDDEN == aStyle)) {
     1:     return;
     1:   }
 40181:   aColor = aFrame->GetStyleContext()->GetVisitedDependentColor(
 40181:              nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_color)[aSide]);
     1: }
     1: 
     1: /** coerce the paint style as required by CSS2.1
     1:   * @param aFrame           - query the info for this frame
     1:   * @param aSide            - the side of the frame
     1:   * @param aStyle           - the border style
     1:   * @param aColor           - the border color
     1:   * @param aTableIsLTR      - table direction is LTR
     1:   */
     1: static void
     1: GetPaintStyleInfo(const nsIFrame*  aFrame,
 41419:                   mozilla::css::Side aSide,
108991:                   uint8_t&         aStyle,
     1:                   nscolor&         aColor,
 79445:                   bool             aTableIsLTR)
 36972: {
 36972:   GetColorAndStyle(aFrame, aSide, aStyle, aColor, aTableIsLTR);
     1:   if (NS_STYLE_BORDER_STYLE_INSET    == aStyle) {
     1:     aStyle = NS_STYLE_BORDER_STYLE_RIDGE;
     1:   }
     1:   else if (NS_STYLE_BORDER_STYLE_OUTSET    == aStyle) {
     1:     aStyle = NS_STYLE_BORDER_STYLE_GROOVE;
     1:   }
     1: }
     1: 
     1: /** return the border style, border color and the width in pixel for a given
     1:   * frame and side
     1:   * @param aFrame           - query the info for this frame
     1:   * @param aSide            - the side of the frame
     1:   * @param aStyle           - the border style
     1:   * @param aColor           - the border color
     1:   * @param aTableIsLTR      - table direction is LTR
     1:   * @param aWidth           - the border width in px.
     1:   * @param aTwipsToPixels   - conversion factor from twips to pixel
     1:   */
     1: static void
     1: GetColorAndStyle(const nsIFrame*  aFrame,
 41419:                  mozilla::css::Side aSide,
108991:                  uint8_t&         aStyle,
     1:                  nscolor&         aColor,
 79445:                  bool             aTableIsLTR,
 29425:                  BCPixelSize&     aWidth)
     1: {
 36972:   GetColorAndStyle(aFrame, aSide, aStyle, aColor, aTableIsLTR);
     1:   if ((NS_STYLE_BORDER_STYLE_NONE == aStyle) ||
     1:       (NS_STYLE_BORDER_STYLE_HIDDEN == aStyle)) {
     1:     aWidth = 0;
     1:     return;
     1:   }
     1:   const nsStyleBorder* styleData = aFrame->GetStyleBorder();
     1:   nscoord width;
     1:   if(!aTableIsLTR) { // revert the directions
     1:     if (NS_SIDE_RIGHT == aSide) {
     1:       aSide = NS_SIDE_LEFT;
     1:     }
     1:     else if (NS_SIDE_LEFT == aSide) {
     1:       aSide = NS_SIDE_RIGHT;
     1:     }
     1:   }
 99856:   width = styleData->GetComputedBorderWidth(aSide);
     1:   aWidth = nsPresContext::AppUnitsToIntCSSPixels(width);
     1: }
     1: 
 20836: class nsDelayedCalcBCBorders : public nsRunnable {
 20836: public:
 20836:   nsDelayedCalcBCBorders(nsIFrame* aFrame) :
 20836:     mFrame(aFrame) {}
 20836: 
 20836:   NS_IMETHOD Run() {
 20836:     if (mFrame) {
 20836:       nsTableFrame* tableFrame = static_cast <nsTableFrame*>(mFrame.GetFrame());
 20836:       if (tableFrame->NeedToCalcBCBorders()) {
 20836:         tableFrame->CalcBCBorders();
 20836:       }
 20836:     }
 20836:     return NS_OK;
 20836:   }
 20836: private:
 20836:   nsWeakFrame mFrame;
 20836: };
 20836: 
 79445: bool
 20836: nsTableFrame::BCRecalcNeeded(nsStyleContext* aOldStyleContext,
 20836:                              nsStyleContext* aNewStyleContext)
 20836: {
 21170:   // Attention: the old style context is the one we're forgetting,
 21170:   // and hence possibly completely bogus for GetStyle* purposes.
 21170:   // We use PeekStyleData instead.
 21170: 
 38860:   const nsStyleBorder* oldStyleData = aOldStyleContext->PeekStyleBorder();
 21170:   if (!oldStyleData)
 80486:     return false;
 21170: 
 21170:   const nsStyleBorder* newStyleData = aNewStyleContext->GetStyleBorder();
 21170:   nsChangeHint change = newStyleData->CalcDifference(*oldStyleData);
 21325:   if (!change)
 80486:     return false;
111493:   if (change & nsChangeHint_NeedReflow)
 80486:     return true; // the caller only needs to mark the bc damage area
 21325:   if (change & nsChangeHint_RepaintFrame) {
 21170:     // we need to recompute the borders and the caller needs to mark
 21170:     // the bc damage area
 21200:     // XXX In principle this should only be necessary for border style changes
 21200:     // However the bc painting code tries to maximize the drawn border segments
 21200:     // so it stores in the cellmap where a new border segment starts and this
 21200:     // introduces a unwanted cellmap data dependence on color
 21170:     nsCOMPtr<nsIRunnable> evt = new nsDelayedCalcBCBorders(this);
 21170:     NS_DispatchToCurrentThread(evt);
 80486:     return true;
 80486:   }
 80486:   return false;
 20836: }
     1: 
     1: 
     1: // Compare two border segments, this comparison depends whether the two
     1: // segments meet at a corner and whether the second segment is horizontal.
     1: // The return value is whichever of aBorder1 or aBorder2 dominates.
     1: static const BCCellBorder&
 79445: CompareBorders(bool                aIsCorner, // Pass true for corner calculations
     1:                const BCCellBorder& aBorder1,
     1:                const BCCellBorder& aBorder2,
 79445:                bool                aSecondIsHorizontal,
106838:                bool*             aFirstDominates = nullptr)
 79445: {
 79445:   bool firstDominates = true;
     1: 
     1:   if (NS_STYLE_BORDER_STYLE_HIDDEN == aBorder1.style) {
 80486:     firstDominates = (aIsCorner) ? false : true;
     1:   }
     1:   else if (NS_STYLE_BORDER_STYLE_HIDDEN == aBorder2.style) {
 80486:     firstDominates = (aIsCorner) ? true : false;
     1:   }
     1:   else if (aBorder1.width < aBorder2.width) {
 80486:     firstDominates = false;
     1:   }
     1:   else if (aBorder1.width == aBorder2.width) {
     1:     if (styleToPriority[aBorder1.style] < styleToPriority[aBorder2.style]) {
 80486:       firstDominates = false;
     1:     }
     1:     else if (styleToPriority[aBorder1.style] == styleToPriority[aBorder2.style]) {
     1:       if (aBorder1.owner == aBorder2.owner) {
     1:         firstDominates = !aSecondIsHorizontal;
     1:       }
     1:       else if (aBorder1.owner < aBorder2.owner) {
 80486:         firstDominates = false;
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (aFirstDominates)
     1:     *aFirstDominates = firstDominates;
     1: 
     1:   if (firstDominates)
     1:     return aBorder1;
     1:   return aBorder2;
     1: }
     1: 
     1: /** calc the dominant border by considering the table, row/col group, row/col,
 36972:   * cell.
     1:   * Depending on whether the side is vertical or horizontal and whether
     1:   * adjacent frames are taken into account the ownership of a single border
     1:   * segment is defined. The return value is the dominating border
     1:   * The cellmap stores only top and left borders for each cellmap position.
     1:   * If the cell border is owned by the cell that is left of the border
     1:   * it will be an adjacent owner aka eAjaCellOwner. See celldata.h for the other
     1:   * scenarios with a adjacent owner.
     1:   * @param xxxFrame         - the frame for style information, might be zero if
     1:   *                           it should not be considered
     1:   * @param aSide            - side of the frames that should be considered
     1:   * @param aAja             - the border comparison takes place from the point of
     1:   *                           a frame that is adjacent to the cellmap entry, for
     1:   *                           when a cell owns its lower border it will be the
     1:   *                           adjacent owner as in the cellmap only top and left
     1:   *                           borders are stored.
     1:   * @param aTwipsToPixels   - conversion factor as borders need to be drawn pixel
     1:   *                           aligned.
     1:   */
     1: static BCCellBorder
     1: CompareBorders(const nsIFrame*  aTableFrame,
     1:                const nsIFrame*  aColGroupFrame,
     1:                const nsIFrame*  aColFrame,
     1:                const nsIFrame*  aRowGroupFrame,
     1:                const nsIFrame*  aRowFrame,
     1:                const nsIFrame*  aCellFrame,
 79445:                bool             aTableIsLTR,
 41419:                mozilla::css::Side aSide,
 79445:                bool             aAja)
     1: {
     1:   BCCellBorder border, tempBorder;
 79445:   bool horizontal = (NS_SIDE_TOP == aSide) || (NS_SIDE_BOTTOM == aSide);
     1: 
     1:   // start with the table as dominant if present
     1:   if (aTableFrame) {
 36972:     GetColorAndStyle(aTableFrame, aSide, border.style, border.color, aTableIsLTR, border.width);
     1:     border.owner = eTableOwner;
     1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
     1:       return border;
     1:     }
     1:   }
     1:   // see if the colgroup is dominant
     1:   if (aColGroupFrame) {
 36972:     GetColorAndStyle(aColGroupFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
     1:     tempBorder.owner = (aAja && !horizontal) ? eAjaColGroupOwner : eColGroupOwner;
 80486:     // pass here and below false for aSecondIsHorizontal as it is only used for corner calculations.
 80486:     border = CompareBorders(!CELL_CORNER, border, tempBorder, false);
     1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
     1:       return border;
     1:     }
     1:   }
     1:   // see if the col is dominant
     1:   if (aColFrame) {
 36972:     GetColorAndStyle(aColFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
     1:     tempBorder.owner = (aAja && !horizontal) ? eAjaColOwner : eColOwner;
 80486:     border = CompareBorders(!CELL_CORNER, border, tempBorder, false);
     1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
     1:       return border;
     1:     }
     1:   }
     1:   // see if the rowgroup is dominant
     1:   if (aRowGroupFrame) {
 36972:     GetColorAndStyle(aRowGroupFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
     1:     tempBorder.owner = (aAja && horizontal) ? eAjaRowGroupOwner : eRowGroupOwner;
 80486:     border = CompareBorders(!CELL_CORNER, border, tempBorder, false);
     1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
     1:       return border;
     1:     }
     1:   }
     1:   // see if the row is dominant
     1:   if (aRowFrame) {
 36972:     GetColorAndStyle(aRowFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
     1:     tempBorder.owner = (aAja && horizontal) ? eAjaRowOwner : eRowOwner;
 80486:     border = CompareBorders(!CELL_CORNER, border, tempBorder, false);
     1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
     1:       return border;
     1:     }
     1:   }
     1:   // see if the cell is dominant
     1:   if (aCellFrame) {
 36972:     GetColorAndStyle(aCellFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
     1:     tempBorder.owner = (aAja) ? eAjaCellOwner : eCellOwner;
 80486:     border = CompareBorders(!CELL_CORNER, border, tempBorder, false);
     1:   }
     1:   return border;
     1: }
     1: 
 79445: static bool
 41419: Perpendicular(mozilla::css::Side aSide1,
 41419:               mozilla::css::Side aSide2)
     1: {
     1:   switch (aSide1) {
     1:   case NS_SIDE_TOP:
     1:     return (NS_SIDE_BOTTOM != aSide2);
     1:   case NS_SIDE_RIGHT:
     1:     return (NS_SIDE_LEFT != aSide2);
     1:   case NS_SIDE_BOTTOM:
     1:     return (NS_SIDE_TOP != aSide2);
     1:   default: // NS_SIDE_LEFT
     1:     return (NS_SIDE_RIGHT != aSide2);
     1:   }
     1: }
     1: 
     1: // XXX allocate this as number-of-cols+1 instead of number-of-cols+1 * number-of-rows+1
     1: struct BCCornerInfo
     1: {
 41419:   BCCornerInfo() { ownerColor = 0; ownerWidth = subWidth = ownerElem = subSide =
 41419:                    subElem = hasDashDot = numSegs = bevel = 0; ownerSide = NS_SIDE_TOP;
     1:                    ownerStyle = 0xFF; subStyle = NS_STYLE_BORDER_STYLE_SOLID;  }
 41419:   void Set(mozilla::css::Side aSide,
     1:            BCCellBorder  border);
     1: 
 41419:   void Update(mozilla::css::Side aSide,
     1:               BCCellBorder  border);
     1: 
     1:   nscolor   ownerColor;     // color of borderOwner
108991:   uint16_t  ownerWidth;     // pixel width of borderOwner
108991:   uint16_t  subWidth;       // pixel width of the largest border intersecting the border perpendicular
     1:                             // to ownerSide
108991:   uint32_t  ownerSide:2;    // mozilla::css::Side (e.g NS_SIDE_TOP, NS_SIDE_RIGHT, etc) of the border
 41421:                             // owning the corner relative to the corner
108991:   uint32_t  ownerElem:3;    // elem type (e.g. eTable, eGroup, etc) owning the corner
108991:   uint32_t  ownerStyle:8;   // border style of ownerElem
108991:   uint32_t  subSide:2;      // side of border with subWidth relative to the corner
108991:   uint32_t  subElem:3;      // elem type (e.g. eTable, eGroup, etc) of sub owner
108991:   uint32_t  subStyle:8;     // border style of subElem
108991:   uint32_t  hasDashDot:1;   // does a dashed, dotted segment enter the corner, they cannot be beveled
108991:   uint32_t  numSegs:3;      // number of segments entering corner
108991:   uint32_t  bevel:1;        // is the corner beveled (uses the above two fields together with subWidth)
108991:   uint32_t  unused:1;
     1: };
     1: 
     1: void
 41419: BCCornerInfo::Set(mozilla::css::Side aSide,
     1:                   BCCellBorder  aBorder)
     1: {
     1:   ownerElem  = aBorder.owner;
     1:   ownerStyle = aBorder.style;
     1:   ownerWidth = aBorder.width;
     1:   ownerColor = aBorder.color;
     1:   ownerSide  = aSide;
     1:   hasDashDot = 0;
     1:   numSegs    = 0;
     1:   if (aBorder.width > 0) {
     1:     numSegs++;
     1:     hasDashDot = (NS_STYLE_BORDER_STYLE_DASHED == aBorder.style) ||
     1:                  (NS_STYLE_BORDER_STYLE_DOTTED == aBorder.style);
     1:   }
     1:   bevel      = 0;
     1:   subWidth   = 0;
     1:   // the following will get set later
     1:   subSide    = ((aSide == NS_SIDE_LEFT) || (aSide == NS_SIDE_RIGHT)) ? NS_SIDE_TOP : NS_SIDE_LEFT;
     1:   subElem    = eTableOwner;
     1:   subStyle   = NS_STYLE_BORDER_STYLE_SOLID;
     1: }
     1: 
     1: void
 41419: BCCornerInfo::Update(mozilla::css::Side aSide,
     1:                      BCCellBorder  aBorder)
     1: {
 79445:   bool existingWins = false;
     1:   if (0xFF == ownerStyle) { // initial value indiating that it hasn't been set yet
     1:     Set(aSide, aBorder);
     1:   }
     1:   else {
 79445:     bool horizontal = (NS_SIDE_LEFT == aSide) || (NS_SIDE_RIGHT == aSide); // relative to the corner
     1:     BCCellBorder oldBorder, tempBorder;
     1:     oldBorder.owner  = (BCBorderOwner) ownerElem;
     1:     oldBorder.style =  ownerStyle;
     1:     oldBorder.width =  ownerWidth;
     1:     oldBorder.color =  ownerColor;
     1: 
 41421:     mozilla::css::Side oldSide  = mozilla::css::Side(ownerSide);
     1: 
     1:     tempBorder = CompareBorders(CELL_CORNER, oldBorder, aBorder, horizontal, &existingWins);
     1: 
     1:     ownerElem  = tempBorder.owner;
     1:     ownerStyle = tempBorder.style;
     1:     ownerWidth = tempBorder.width;
     1:     ownerColor = tempBorder.color;
     1:     if (existingWins) { // existing corner is dominant
 41421:       if (::Perpendicular(mozilla::css::Side(ownerSide), aSide)) {
     1:         // see if the new sub info replaces the old
     1:         BCCellBorder subBorder;
     1:         subBorder.owner = (BCBorderOwner) subElem;
     1:         subBorder.style =  subStyle;
     1:         subBorder.width =  subWidth;
     1:         subBorder.color = 0; // we are not interested in subBorder color
 79445:         bool firstWins;
     1: 
     1:         tempBorder = CompareBorders(CELL_CORNER, subBorder, aBorder, horizontal, &firstWins);
     1: 
     1:         subElem  = tempBorder.owner;
     1:         subStyle = tempBorder.style;
     1:         subWidth = tempBorder.width;
     1:         if (!firstWins) {
     1:           subSide = aSide;
     1:         }
     1:       }
     1:     }
     1:     else { // input args are dominant
     1:       ownerSide = aSide;
 41421:       if (::Perpendicular(oldSide, mozilla::css::Side(ownerSide))) {
     1:         subElem  = oldBorder.owner;
     1:         subStyle = oldBorder.style;
     1:         subWidth = oldBorder.width;
     1:         subSide  = oldSide;
     1:       }
     1:     }
     1:     if (aBorder.width > 0) {
     1:       numSegs++;
     1:       if (!hasDashDot && ((NS_STYLE_BORDER_STYLE_DASHED == aBorder.style) ||
     1:                           (NS_STYLE_BORDER_STYLE_DOTTED == aBorder.style))) {
     1:         hasDashDot = 1;
     1:       }
     1:     }
     1: 
     1:     // bevel the corner if only two perpendicular non dashed/dotted segments enter the corner
     1:     bevel = (2 == numSegs) && (subWidth > 1) && (0 == hasDashDot);
     1:   }
     1: }
     1: 
     1: struct BCCorners
     1: {
108991:   BCCorners(int32_t aNumCorners,
108991:             int32_t aStartIndex);
     1: 
     1:   ~BCCorners() { delete [] corners; }
     1: 
108991:   BCCornerInfo& operator [](int32_t i) const
     1:   { NS_ASSERTION((i >= startIndex) && (i <= endIndex), "program error");
 81029:     return corners[clamped(i, startIndex, endIndex) - startIndex]; }
     1: 
108991:   int32_t       startIndex;
108991:   int32_t       endIndex;
     1:   BCCornerInfo* corners;
     1: };
     1: 
108991: BCCorners::BCCorners(int32_t aNumCorners,
108991:                      int32_t aStartIndex)
     1: {
     1:   NS_ASSERTION((aNumCorners > 0) && (aStartIndex >= 0), "program error");
     1:   startIndex = aStartIndex;
     1:   endIndex   = aStartIndex + aNumCorners - 1;
     1:   corners    = new BCCornerInfo[aNumCorners];
     1: }
     1: 
     1: 
     1: struct BCCellBorders
     1: {
108991:   BCCellBorders(int32_t aNumBorders,
108991:                 int32_t aStartIndex);
     1: 
     1:   ~BCCellBorders() { delete [] borders; }
     1: 
108991:   BCCellBorder& operator [](int32_t i) const
     1:   { NS_ASSERTION((i >= startIndex) && (i <= endIndex), "program error");
 81029:     return borders[clamped(i, startIndex, endIndex) - startIndex]; }
     1: 
108991:   int32_t       startIndex;
108991:   int32_t       endIndex;
     1:   BCCellBorder* borders;
     1: };
     1: 
108991: BCCellBorders::BCCellBorders(int32_t aNumBorders,
108991:                              int32_t aStartIndex)
     1: {
     1:   NS_ASSERTION((aNumBorders > 0) && (aStartIndex >= 0), "program error");
     1:   startIndex = aStartIndex;
     1:   endIndex   = aStartIndex + aNumBorders - 1;
     1:   borders    = new BCCellBorder[aNumBorders];
     1: }
     1: 
     1: // this function sets the new border properties and returns true if the border
 34593: // segment will start a new segment and not be accumulated into the previous
 34593: // segment.
 79445: static bool
     1: SetBorder(const BCCellBorder&   aNewBorder,
     1:           BCCellBorder&         aBorder)
     1: {
 79445:   bool changed = (aNewBorder.style != aBorder.style) ||
     1:                    (aNewBorder.width != aBorder.width) ||
     1:                    (aNewBorder.color != aBorder.color);
     1:   aBorder.color        = aNewBorder.color;
     1:   aBorder.width        = aNewBorder.width;
     1:   aBorder.style        = aNewBorder.style;
     1:   aBorder.owner        = aNewBorder.owner;
     1: 
     1:   return changed;
     1: }
     1: 
     1: // this function will set the horizontal border. It will return true if the
     1: // existing segment will not be continued. Having a vertical owner of a corner
     1: // should also start a new segment.
 79445: static bool
     1: SetHorBorder(const BCCellBorder& aNewBorder,
     1:              const BCCornerInfo& aCorner,
     1:              BCCellBorder&       aBorder)
     1: {
 79445:   bool startSeg = ::SetBorder(aNewBorder, aBorder);
     1:   if (!startSeg) {
     1:     startSeg = ((NS_SIDE_LEFT != aCorner.ownerSide) && (NS_SIDE_RIGHT != aCorner.ownerSide));
     1:   }
     1:   return startSeg;
     1: }
     1: 
     1: // Make the damage area larger on the top and bottom by at least one row and on the left and right
     1: // at least one column. This is done so that adjacent elements are part of the border calculations.
     1: // The extra segments and borders outside the actual damage area will not be updated in the cell map,
     1: // because they in turn would need info from adjacent segments outside the damage area to be accurate.
     1: void
 87904: nsTableFrame::ExpandBCDamageArea(nsIntRect& aRect) const
     1: {
108991:   int32_t numRows = GetRowCount();
108991:   int32_t numCols = GetColCount();
108991: 
108991:   int32_t dStartX = aRect.x;
108991:   int32_t dEndX   = aRect.XMost() - 1;
108991:   int32_t dStartY = aRect.y;
108991:   int32_t dEndY   = aRect.YMost() - 1;
     1: 
     1:   // expand the damage area in each direction
     1:   if (dStartX > 0) {
     1:     dStartX--;
     1:   }
     1:   if (dEndX < (numCols - 1)) {
     1:     dEndX++;
     1:   }
     1:   if (dStartY > 0) {
     1:     dStartY--;
     1:   }
     1:   if (dEndY < (numRows - 1)) {
     1:     dEndY++;
     1:   }
     1:   // Check the damage area so that there are no cells spanning in or out. If there are any then
     1:   // make the damage area as big as the table, similarly to the way the cell map decides whether
     1:   // to rebuild versus expand. This could be optimized to expand to the smallest area that contains
     1:   // no spanners, but it may not be worth the effort in general, and it would need to be done in the
     1:   // cell map as well.
 79445:   bool haveSpanner = false;
     1:   if ((dStartX > 0) || (dEndX < (numCols - 1)) || (dStartY > 0) || (dEndY < (numRows - 1))) {
     1:     nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT0();
     1:     // Get the ordered row groups
  2141:     RowGroupArray rowGroups;
  2141:     OrderRowGroups(rowGroups);
     1: 
     1:     // Scope outside loop to be used as hint.
106838:     nsCellMap* cellMap = nullptr;
108991:     for (uint32_t rgX = 0; rgX < rowGroups.Length(); rgX++) {
  2141:       nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
108991:       int32_t rgStartY = rgFrame->GetStartRowIndex();
108991:       int32_t rgEndY   = rgStartY + rgFrame->GetRowCount() - 1;
     1:       if (dEndY < rgStartY)
     1:         break;
     1:       cellMap = tableCellMap->GetMapFor(rgFrame, cellMap);
     1:       if (!cellMap) ABORT0();
     1:       // check for spanners from above and below
     1:       if ((dStartY > 0) && (dStartY >= rgStartY) && (dStartY <= rgEndY)) {
108991:         if (uint32_t(dStartY - rgStartY) >= cellMap->mRows.Length())
     1:           ABORT0();
     1:         const nsCellMap::CellDataArray& row =
     1:           cellMap->mRows[dStartY - rgStartY];
108991:         for (int32_t x = dStartX; x <= dEndX; x++) {
     1:           CellData* cellData = row.SafeElementAt(x);
     1:           if (cellData && (cellData->IsRowSpan())) {
 80486:              haveSpanner = true;
     1:              break;
     1:           }
     1:         }
     1:         if (dEndY < rgEndY) {
108991:           if (uint32_t(dEndY + 1 - rgStartY) >= cellMap->mRows.Length())
     1:             ABORT0();
     1:           const nsCellMap::CellDataArray& row2 =
     1:             cellMap->mRows[dEndY + 1 - rgStartY];
108991:           for (int32_t x = dStartX; x <= dEndX; x++) {
     1:             CellData* cellData = row2.SafeElementAt(x);
     1:             if (cellData && (cellData->IsRowSpan())) {
 80486:               haveSpanner = true;
     1:               break;
     1:             }
     1:           }
     1:         }
     1:       }
     1:       // check for spanners on the left and right
108991:       int32_t iterStartY = -1;
108991:       int32_t iterEndY   = -1;
     1:       if ((dStartY >= rgStartY) && (dStartY <= rgEndY)) {
     1:         // the damage area starts in the row group
     1:         iterStartY = dStartY;
 32531:         iterEndY   = NS_MIN(dEndY, rgEndY);
     1:       }
     1:       else if ((dEndY >= rgStartY) && (dEndY <= rgEndY)) {
     1:         // the damage area ends in the row group
     1:         iterStartY = rgStartY;
 86847:         iterEndY   = dEndY;
     1:       }
     1:       else if ((rgStartY >= dStartY) && (rgEndY <= dEndY)) {
     1:         // the damage area contains the row group
     1:         iterStartY = rgStartY;
     1:         iterEndY   = rgEndY;
     1:       }
     1:       if ((iterStartY >= 0) && (iterEndY >= 0)) {
108991:         for (int32_t y = iterStartY; y <= iterEndY; y++) {
108991:           if (uint32_t(y - rgStartY) >= cellMap->mRows.Length())
     1:             ABORT0();
     1:           const nsCellMap::CellDataArray& row =
     1:             cellMap->mRows[y - rgStartY];
     1:           CellData* cellData = row.SafeElementAt(dStartX);
     1:           if (cellData && (cellData->IsColSpan())) {
 80486:             haveSpanner = true;
     1:             break;
     1:           }
     1:           if (dEndX < (numCols - 1)) {
     1:             cellData = row.SafeElementAt(dEndX + 1);
     1:             if (cellData && (cellData->IsColSpan())) {
 80486:               haveSpanner = true;
     1:               break;
     1:             }
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
     1:   if (haveSpanner) {
     1:     // make the damage area the whole table
     1:     aRect.x      = 0;
     1:     aRect.y      = 0;
     1:     aRect.width  = numCols;
     1:     aRect.height = numRows;
     1:   }
     1:   else {
     1:     aRect.x      = dStartX;
     1:     aRect.y      = dStartY;
     1:     aRect.width  = 1 + dEndX - dStartX;
     1:     aRect.height = 1 + dEndY - dStartY;
     1:   }
     1: }
     1: 
     1: 
 80486: #define ADJACENT    true
 80486: #define HORIZONTAL  true
 29425: 
 29425: void
 29425: BCMapCellInfo::SetTableTopLeftContBCBorder()
 29425: {
 29425:   BCCellBorder currentBorder;
 29425:   //calculate continuous top first row & rowgroup border: special case
 29425:   //because it must include the table in the collapse
 29425:   if (mTopRow) {
106838:     currentBorder = CompareBorders(mTableFrame, nullptr, nullptr, mRowGroup,
106838:                                    mTopRow, nullptr, mTableIsLTR,
 36972:                                    NS_SIDE_TOP, !ADJACENT);
 29425:     mTopRow->SetContinuousBCBorderWidth(NS_SIDE_TOP, currentBorder.width);
 29425:   }
 29425:   if (mCgAtRight && mColGroup) {
 29425:     //calculate continuous top colgroup border once per colgroup
106838:     currentBorder = CompareBorders(mTableFrame, mColGroup, nullptr, mRowGroup,
106838:                                    mTopRow, nullptr, mTableIsLTR,
 36972:                                    NS_SIDE_TOP, !ADJACENT);
 29425:     mColGroup->SetContinuousBCBorderWidth(NS_SIDE_TOP, currentBorder.width);
 29425:   }
 29425:   if (0 == mColIndex) {
106838:     currentBorder = CompareBorders(mTableFrame, mColGroup, mLeftCol, nullptr,
106838:                                    nullptr, nullptr, mTableIsLTR, NS_SIDE_LEFT,
 36972:                                    !ADJACENT);
 29425:     mTableFrame->SetContinuousLeftBCBorderWidth(currentBorder.width);
 29425:   }
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetRowGroupLeftContBCBorder()
 29425: {
 29425:   BCCellBorder currentBorder;
 29425:   //get row group continuous borders
 29425:   if (mRgAtBottom && mRowGroup) { //once per row group, so check for bottom
 29425:      currentBorder = CompareBorders(mTableFrame, mColGroup, mLeftCol, mRowGroup,
106838:                                     nullptr, nullptr, mTableIsLTR, NS_SIDE_LEFT,
 36972:                                     !ADJACENT);
 29425:      mRowGroup->SetContinuousBCBorderWidth(mStartSide, currentBorder.width);
 29425:   }
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetRowGroupRightContBCBorder()
 29425: {
 29425:   BCCellBorder currentBorder;
 29425:   //get row group continuous borders
 29425:   if (mRgAtBottom && mRowGroup) { //once per mRowGroup, so check for bottom
 29425:     currentBorder = CompareBorders(mTableFrame, mColGroup, mRightCol, mRowGroup,
106838:                                    nullptr, nullptr, mTableIsLTR, NS_SIDE_RIGHT,
 36972:                                    ADJACENT);
 29425:     mRowGroup->SetContinuousBCBorderWidth(mEndSide, currentBorder.width);
 29425:   }
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetColumnTopRightContBCBorder()
 29425: {
 29425:   BCCellBorder currentBorder;
 29425:   //calculate column continuous borders
 29425:   //we only need to do this once, so we'll do it only on the first row
 29425:   currentBorder = CompareBorders(mTableFrame, mCurrentColGroupFrame,
106838:                                  mCurrentColFrame, mRowGroup, mTopRow, nullptr,
 36972:                                  mTableIsLTR, NS_SIDE_TOP, !ADJACENT);
 29425:   ((nsTableColFrame*) mCurrentColFrame)->SetContinuousBCBorderWidth(NS_SIDE_TOP,
 29425:                                                            currentBorder.width);
 29425:   if (mNumTableCols == GetCellEndColIndex() + 1) {
 29425:     currentBorder = CompareBorders(mTableFrame, mCurrentColGroupFrame,
106838:                                    mCurrentColFrame, nullptr, nullptr, nullptr,
 36972:                                    mTableIsLTR, NS_SIDE_RIGHT, !ADJACENT);
 29425:   }
 29425:   else {
106838:     currentBorder = CompareBorders(nullptr, mCurrentColGroupFrame,
106838:                                    mCurrentColFrame, nullptr,nullptr, nullptr,
 36972:                                    mTableIsLTR, NS_SIDE_RIGHT, !ADJACENT);
 29425:   }
 29425:   mCurrentColFrame->SetContinuousBCBorderWidth(NS_SIDE_RIGHT,
 29425:                                                currentBorder.width);
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetColumnBottomContBCBorder()
 29425: {
 29425:   BCCellBorder currentBorder;
 29425:   //get col continuous border
 29425:   currentBorder = CompareBorders(mTableFrame, mCurrentColGroupFrame,
 29425:                                  mCurrentColFrame, mRowGroup, mBottomRow,
106838:                                  nullptr, mTableIsLTR, NS_SIDE_BOTTOM, ADJACENT);
 29425:   mCurrentColFrame->SetContinuousBCBorderWidth(NS_SIDE_BOTTOM,
 29425:                                                currentBorder.width);
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetColGroupBottomContBCBorder()
 29425: {
 29425:   BCCellBorder currentBorder;
 29425:   if (mColGroup) {
106838:     currentBorder = CompareBorders(mTableFrame, mColGroup, nullptr, mRowGroup,
106838:                                    mBottomRow, nullptr, mTableIsLTR,
 29425:                                    NS_SIDE_BOTTOM, ADJACENT);
 29425:     mColGroup->SetContinuousBCBorderWidth(NS_SIDE_BOTTOM, currentBorder.width);
 29425:   }
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetRowGroupBottomContBCBorder()
 29425: {
 29425:   BCCellBorder currentBorder;
 29425:   if (mRowGroup) {
106838:     currentBorder = CompareBorders(mTableFrame, nullptr, nullptr, mRowGroup,
106838:                                    mBottomRow, nullptr, mTableIsLTR,
 29425:                                    NS_SIDE_BOTTOM, ADJACENT);
 29425:     mRowGroup->SetContinuousBCBorderWidth(NS_SIDE_BOTTOM, currentBorder.width);
 29425:   }
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetInnerRowGroupBottomContBCBorder(const nsIFrame* aNextRowGroup,
 29425:                                                   nsTableRowFrame* aNextRow)
 29425: {
 29425:   BCCellBorder currentBorder, adjacentBorder;
 29425: 
106838:   const nsIFrame* rowgroup = (mRgAtBottom) ? mRowGroup : nullptr;
106838:   currentBorder = CompareBorders(nullptr, nullptr, nullptr, rowgroup, mBottomRow,
106838:                                  nullptr, mTableIsLTR, NS_SIDE_BOTTOM, ADJACENT);
106838: 
106838:   adjacentBorder = CompareBorders(nullptr, nullptr, nullptr, aNextRowGroup,
106838:                                   aNextRow, nullptr, mTableIsLTR, NS_SIDE_TOP,
 36972:                                   !ADJACENT);
 80486:   currentBorder = CompareBorders(false, currentBorder, adjacentBorder,
 29425:                                  HORIZONTAL);
 29425:   if (aNextRow) {
 29425:     aNextRow->SetContinuousBCBorderWidth(NS_SIDE_TOP, currentBorder.width);
 29425:   }
 29425:   if (mRgAtBottom && mRowGroup) {
 29425:     mRowGroup->SetContinuousBCBorderWidth(NS_SIDE_BOTTOM, currentBorder.width);
 29425:   }
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetRowLeftContBCBorder()
 29425: {
 29425:   //get row continuous borders
 29425:   if (mCurrentRowFrame) {
 29425:     BCCellBorder currentBorder;
 29425:     currentBorder = CompareBorders(mTableFrame, mColGroup, mLeftCol, mRowGroup,
106838:                                    mCurrentRowFrame, nullptr, mTableIsLTR,
 36972:                                    NS_SIDE_LEFT, !ADJACENT);
 29425:     mCurrentRowFrame->SetContinuousBCBorderWidth(mStartSide,
 29425:                                                  currentBorder.width);
 29425:   }
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetRowRightContBCBorder()
 29425: {
 29425:   if (mCurrentRowFrame) {
 29425:     BCCellBorder currentBorder;
 29425:     currentBorder = CompareBorders(mTableFrame, mColGroup, mRightCol, mRowGroup,
106838:                                    mCurrentRowFrame, nullptr, mTableIsLTR,
 36972:                                    NS_SIDE_RIGHT, ADJACENT);
 29425:     mCurrentRowFrame->SetContinuousBCBorderWidth(mEndSide,
 29425:                                                  currentBorder.width);
 29425:   }
 29425: }
 29425: void
 29425: BCMapCellInfo::SetTableTopBorderWidth(BCPixelSize aWidth)
 29425: {
 39019:   mTableBCData->mTopBorderWidth = NS_MAX(mTableBCData->mTopBorderWidth, aWidth);
 29425: }
 29425: 
 29425: void
108991: BCMapCellInfo::SetTableLeftBorderWidth(int32_t aRowY, BCPixelSize aWidth)
 29425: {
 29425:   // update the left/right first cell border
 29425:   if (aRowY == 0) {
 29425:     if (mTableIsLTR) {
 29425:       mTableBCData->mLeftCellBorderWidth = aWidth;
 29425:     }
 29425:     else {
 29425:       mTableBCData->mRightCellBorderWidth = aWidth;
 29425:     }
 29425:   }
 39019:   mTableBCData->mLeftBorderWidth = NS_MAX(mTableBCData->mLeftBorderWidth,
 39019:                                           aWidth);
 29425: }
 29425: 
 29425: void
108991: BCMapCellInfo::SetTableRightBorderWidth(int32_t aRowY, BCPixelSize aWidth)
 29425: {
 29425:   // update the left/right first cell border
 29425:   if (aRowY == 0) {
 29425:     if (mTableIsLTR) {
 29425:       mTableBCData->mRightCellBorderWidth = aWidth;
 29425:     }
 29425:     else {
 29425:       mTableBCData->mLeftCellBorderWidth = aWidth;
 29425:     }
 29425:   }
 39019:   mTableBCData->mRightBorderWidth = NS_MAX(mTableBCData->mRightBorderWidth,
 39019:                                            aWidth);
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetRightBorderWidths(BCPixelSize aWidth)
 29425: {
 29425:    // update the borders of the cells and cols affected
 29425:   if (mCell) {
 32531:     mCell->SetBorderWidth(mEndSide, NS_MAX(aWidth,
 29425:                           mCell->GetBorderWidth(mEndSide)));
 29425:   }
 29425:   if (mRightCol) {
 29425:     BCPixelSize half = BC_BORDER_LEFT_HALF(aWidth);
 32531:     mRightCol->SetRightBorderWidth(NS_MAX(nscoord(half),
 29425:                                    mRightCol->GetRightBorderWidth()));
 29425:   }
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetBottomBorderWidths(BCPixelSize aWidth)
 29425: {
 29425:   // update the borders of the affected cells and rows
 29425:   if (mCell) {
 32531:     mCell->SetBorderWidth(NS_SIDE_BOTTOM, NS_MAX(aWidth,
 29425:                           mCell->GetBorderWidth(NS_SIDE_BOTTOM)));
 29425:   }
 29425:   if (mBottomRow) {
 29425:     BCPixelSize half = BC_BORDER_TOP_HALF(aWidth);
 32531:     mBottomRow->SetBottomBCBorderWidth(NS_MAX(nscoord(half),
 29425:                                        mBottomRow->GetBottomBCBorderWidth()));
 29425:   }
 29425: }
 29425: void
 29425: BCMapCellInfo::SetTopBorderWidths(BCPixelSize aWidth)
 29425: {
 29425:  if (mCell) {
 32531:      mCell->SetBorderWidth(NS_SIDE_TOP, NS_MAX(aWidth,
 29425:                            mCell->GetBorderWidth(NS_SIDE_TOP)));
 29425:   }
 29425:   if (mTopRow) {
 29425:     BCPixelSize half = BC_BORDER_BOTTOM_HALF(aWidth);
 32531:     mTopRow->SetTopBCBorderWidth(NS_MAX(nscoord(half),
 32531:                                         mTopRow->GetTopBCBorderWidth()));
 29425:   }
 29425: }
 29425: void
 29425: BCMapCellInfo::SetLeftBorderWidths(BCPixelSize aWidth)
 29425: {
 29425:   if (mCell) {
 32531:     mCell->SetBorderWidth(mStartSide, NS_MAX(aWidth,
 29425:                           mCell->GetBorderWidth(mStartSide)));
 29425:   }
 29425:   if (mLeftCol) {
 29425:     BCPixelSize half = BC_BORDER_RIGHT_HALF(aWidth);
 32531:     mLeftCol->SetLeftBorderWidth(NS_MAX(nscoord(half),
 32531:                                         mLeftCol->GetLeftBorderWidth()));
 29425:   }
 29425: }
 29425: 
 29425: void
 29425: BCMapCellInfo::SetTableBottomBorderWidth(BCPixelSize aWidth)
 29425: {
 39019:   mTableBCData->mBottomBorderWidth = NS_MAX(mTableBCData->mBottomBorderWidth,
 39019:                                             aWidth);
 29425: }
 29425: 
 29425: void
108991: BCMapCellInfo::SetColumn(int32_t aColX)
 29425: {
 29425:   mCurrentColFrame = mTableFrame->GetColFrame(aColX);
 29425:   if (!mCurrentColFrame) {
 29425:     NS_ERROR("null mCurrentColFrame");
 29425:   }
 29425:   mCurrentColGroupFrame = static_cast<nsTableColGroupFrame*>
 29425:                             (mCurrentColFrame->GetParent());
 29425:   if (!mCurrentColGroupFrame) {
 29425:     NS_ERROR("null mCurrentColGroupFrame");
 29425:   }
 29425: }
 29425: 
 29425: void
 79445: BCMapCellInfo::IncrementRow(bool aResetToTopRowOfCell)
 29425: {
 29425:   mCurrentRowFrame = (aResetToTopRowOfCell) ? mTopRow :
 29425:                                                 mCurrentRowFrame->GetNextRow();
 29425: }
 29425: 
 29425: BCCellBorder
 29425: BCMapCellInfo::GetTopEdgeBorder()
 29425: {
 29425:   return CompareBorders(mTableFrame, mCurrentColGroupFrame, mCurrentColFrame,
 36972:                         mRowGroup, mTopRow, mCell, mTableIsLTR, NS_SIDE_TOP,
 36972:                         !ADJACENT);
 29425: }
 29425: 
 29425: BCCellBorder
 29425: BCMapCellInfo::GetBottomEdgeBorder()
 29425: {
 29425:   return CompareBorders(mTableFrame, mCurrentColGroupFrame, mCurrentColFrame,
 36972:                         mRowGroup, mBottomRow, mCell, mTableIsLTR,
 29425:                         NS_SIDE_BOTTOM, ADJACENT);
 29425: }
 29425: BCCellBorder
 29425: BCMapCellInfo::GetLeftEdgeBorder()
 29425: {
 29425:   return CompareBorders(mTableFrame, mColGroup, mLeftCol, mRowGroup,
 36972:                         mCurrentRowFrame, mCell, mTableIsLTR, NS_SIDE_LEFT,
 36972:                         !ADJACENT);
 29425: }
 29425: BCCellBorder
 29425: BCMapCellInfo::GetRightEdgeBorder()
 29425: {
 29425:   return CompareBorders(mTableFrame, mColGroup, mRightCol, mRowGroup,
 36972:                         mCurrentRowFrame, mCell, mTableIsLTR, NS_SIDE_RIGHT,
 36972:                         ADJACENT);
 29425: }
 29425: BCCellBorder
 29425: BCMapCellInfo::GetRightInternalBorder()
 29425: {
106838:   const nsIFrame* cg = (mCgAtRight) ? mColGroup : nullptr;
106838:   return CompareBorders(nullptr, cg, mRightCol, nullptr, nullptr, mCell,
 36972:                         mTableIsLTR, NS_SIDE_RIGHT, ADJACENT);
 29425: }
 29425: 
 29425: BCCellBorder
 29425: BCMapCellInfo::GetLeftInternalBorder()
 29425: {
106838:   const nsIFrame* cg = (mCgAtLeft) ? mColGroup : nullptr;
106838:   return CompareBorders(nullptr, cg, mLeftCol, nullptr, nullptr, mCell,
 36972:                         mTableIsLTR, NS_SIDE_LEFT, !ADJACENT);
 29425: }
 29425: 
 29425: BCCellBorder
 29425: BCMapCellInfo::GetBottomInternalBorder()
 29425: {
106838:   const nsIFrame* rg = (mRgAtBottom) ? mRowGroup : nullptr;
106838:   return CompareBorders(nullptr, nullptr, nullptr, rg, mBottomRow, mCell,
 36972:                         mTableIsLTR, NS_SIDE_BOTTOM, ADJACENT);
 29425: }
 29425: 
 29425: BCCellBorder
 29425: BCMapCellInfo::GetTopInternalBorder()
 29425: {
106838:   const nsIFrame* rg = (mRgAtTop) ? mRowGroup : nullptr;
106838:   return CompareBorders(nullptr, nullptr, nullptr, rg, mTopRow, mCell,
 36972:                         mTableIsLTR, NS_SIDE_TOP, !ADJACENT);
 29425: }
 29425: 
     1: /* Here is the order for storing border edges in the cell map as a cell is processed. There are
     1:    n=colspan top and bottom border edges per cell and n=rowspan left and right border edges per cell.
     1: 
     1:    1) On the top edge of the table, store the top edge. Never store the top edge otherwise, since
     1:       a bottom edge from a cell above will take care of it.
     1:    2) On the left edge of the table, store the left edge. Never store the left edge othewise, since
     1:       a right edge from a cell to the left will take care of it.
     1:    3) Store the right edge (or edges if a row span)
     1:    4) Store the bottom edge (or edges if a col span)
     1: 
     1:    Since corners are computed with only an array of BCCornerInfo indexed by the number-of-cols, corner
     1:    calculations are somewhat complicated. Using an array with number-of-rows * number-of-col entries
     1:    would simplify this, but at an extra in memory cost of nearly 12 bytes per cell map entry. Collapsing
     1:    borders already have about an extra 8 byte per cell map entry overhead (this could be
     1:    reduced to 4 bytes if we are willing to not store border widths in nsTableCellFrame), Here are the
     1:    rules in priority order for storing cornes in the cell map as a cell is processed. top-left means the
     1:    left endpoint of the border edge on the top of the cell. There are n=colspan top and bottom border
     1:    edges per cell and n=rowspan left and right border edges per cell.
     1: 
     1:    1) On the top edge of the table, store the top-left corner, unless on the left edge of the table.
     1:       Never store the top-right corner, since it will get stored as a right-top corner.
     1:    2) On the left edge of the table, store the left-top corner. Never store the left-bottom corner,
     1:       since it will get stored as a bottom-left corner.
     1:    3) Store the right-top corner if (a) it is the top right corner of the table or (b) it is not on
     1:       the top edge of the table. Never store the right-bottom corner since it will get stored as a
     1:       bottom-right corner.
     1:    4) Store the bottom-right corner, if it is the bottom right corner of the table. Never store it
     1:       otherwise, since it will get stored as either a right-top corner by a cell below or
     1:       a bottom-left corner from a cell to the right.
     1:    5) Store the bottom-left corner, if (a) on the bottom edge of the table or (b) if the left edge hits
     1:       the top side of a colspan in its interior. Never store the corner otherwise, since it will
     1:       get stored as a right-top corner by a cell from below.
     1: 
     1:    XXX the BC-RTL hack - The correct fix would be a rewrite as described in bug 203686.
     1:    In order to draw borders in rtl conditions somehow correct, the existing structure which relies
     1:    heavily on the assumption that the next cell sibling will be on the right side, has been modified.
     1:    We flip the border during painting and during style lookup. Look for tableIsLTR for places where
     1:    the flipping is done.
     1:  */
     1: 
 29425: 
     1: 
     1: // Calc the dominant border at every cell edge and corner within the current damage area
     1: void
     1: nsTableFrame::CalcBCBorders()
     1: {
     1:   NS_ASSERTION(IsBorderCollapse(),
     1:                "calling CalcBCBorders on separated-border table");
     1:   nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT0();
108991:   int32_t numRows = GetRowCount();
108991:   int32_t numCols = GetColCount();
     1:   if (!numRows || !numCols)
     1:     return; // nothing to do
     1: 
     1:   // Get the property holding the table damage area and border widths
 82828:   BCPropertyData* propData = GetBCProperty();
     1:   if (!propData) ABORT0();
     1: 
 29425: 
 29425: 
     1:   // calculate an expanded damage area
 87904:   nsIntRect damageArea(propData->mDamageArea);
     1:   ExpandBCDamageArea(damageArea);
     1: 
 29425:   // segments that are on the table border edges need
 29425:   // to be initialized only once
 79445:   bool tableBorderReset[4];
108991:   for (uint32_t sideX = NS_SIDE_TOP; sideX <= NS_SIDE_LEFT; sideX++) {
 80486:     tableBorderReset[sideX] = false;
     1:   }
     1: 
     1:   // vertical borders indexed in x-direction (cols)
 29425:   BCCellBorders lastVerBorders(damageArea.width + 1, damageArea.x);
 29425:   if (!lastVerBorders.borders) ABORT0();
     1:   BCCellBorder  lastTopBorder, lastBottomBorder;
     1:   // horizontal borders indexed in x-direction (cols)
 29425:   BCCellBorders lastBottomBorders(damageArea.width + 1, damageArea.x);
 29425:   if (!lastBottomBorders.borders) ABORT0();
 79445:   bool startSeg;
 79445:   bool gotRowBorder = false;
     1: 
 29425:   BCMapCellInfo  info(this), ajaInfo(this);
 29425: 
     1:   BCCellBorder currentBorder, adjacentBorder;
 29425:   BCCorners topCorners(damageArea.width + 1, damageArea.x);
 29425:   if (!topCorners.corners) ABORT0();
 29425:   BCCorners bottomCorners(damageArea.width + 1, damageArea.x);
 29425:   if (!bottomCorners.corners) ABORT0();
 29425: 
 29425:   BCMapCellIterator iter(this, damageArea);
     1:   for (iter.First(info); !iter.mAtEnd; iter.Next(info)) {
     1:     // see if lastTopBorder, lastBottomBorder need to be reset
     1:     if (iter.IsNewRow()) {
 80486:       gotRowBorder = false;
 29425:       lastTopBorder.Reset(info.mRowIndex, info.mRowSpan);
 29425:       lastBottomBorder.Reset(info.GetCellEndRowIndex() + 1, info.mRowSpan);
 29425:     }
 29425:     else if (info.mColIndex > damageArea.x) {
 29425:       lastBottomBorder = lastBottomBorders[info.mColIndex - 1];
 29425:       if (info.mRowIndex >
 29425:           (lastBottomBorder.rowIndex - lastBottomBorder.rowSpan)) {
     1:         // the top border's left edge butts against the middle of a rowspan
 29425:         lastTopBorder.Reset(info.mRowIndex, info.mRowSpan);
 29425:       }
 29425:       if (lastBottomBorder.rowIndex > (info.GetCellEndRowIndex() + 1)) {
     1:         // the bottom border's left edge butts against the middle of a rowspan
 29425:         lastBottomBorder.Reset(info.GetCellEndRowIndex() + 1, info.mRowSpan);
     1:       }
     1:     }
     1: 
 29425:     // find the dominant border considering the cell's top border and the table,
 29425:     // row group, row if the border is at the top of the table, otherwise it was
 29425:     // processed in a previous row
 29425:     if (0 == info.mRowIndex) {
     1:       if (!tableBorderReset[NS_SIDE_TOP]) {
     1:         propData->mTopBorderWidth = 0;
 80486:         tableBorderReset[NS_SIDE_TOP] = true;
     1:       }
108991:       for (int32_t colX = info.mColIndex; colX <= info.GetCellEndColIndex();
 29425:            colX++) {
 29425:         info.SetColumn(colX);
 29425:         currentBorder = info.GetTopEdgeBorder();
     1:         // update/store the top left & top right corners of the seg
     1:         BCCornerInfo& tlCorner = topCorners[colX]; // top left
     1:         if (0 == colX) {
 29425:           // we are on right hand side of the corner
 29425:           tlCorner.Set(NS_SIDE_RIGHT, currentBorder);
     1:         }
     1:         else {
     1:           tlCorner.Update(NS_SIDE_RIGHT, currentBorder);
 29425:           tableCellMap->SetBCBorderCorner(eTopLeft, *iter.mCellMap, 0, 0, colX,
 41421:                                           mozilla::css::Side(tlCorner.ownerSide),
 41421:                                           tlCorner.subWidth,
 29425:                                           tlCorner.bevel);
     1:         }
     1:         topCorners[colX + 1].Set(NS_SIDE_LEFT, currentBorder); // top right
     1:         // update lastTopBorder and see if a new segment starts
     1:         startSeg = SetHorBorder(currentBorder, tlCorner, lastTopBorder);
     1:         // store the border segment in the cell map
 29425:         tableCellMap->SetBCBorderEdge(NS_SIDE_TOP, *iter.mCellMap, 0, 0, colX,
 29425:                                       1, currentBorder.owner,
 29425:                                       currentBorder.width, startSeg);
 29425: 
 29425:         info.SetTableTopBorderWidth(currentBorder.width);
 29425:         info.SetTopBorderWidths(currentBorder.width);
 29425:         info.SetColumnTopRightContBCBorder();
 29425:       }
 29425:       info.SetTableTopLeftContBCBorder();
     1:     }
     1:     else {
 29425:       // see if the top border needs to be the start of a segment due to a
 29425:       // vertical border owning the corner
 29425:       if (info.mColIndex > 0) {
 29425:         BCData& data = info.mCellData->mData;
     1:         if (!data.IsTopStart()) {
 41419:           mozilla::css::Side cornerSide;
 79445:           bool bevel;
     1:           data.GetCorner(cornerSide, bevel);
     1:           if ((NS_SIDE_TOP == cornerSide) || (NS_SIDE_BOTTOM == cornerSide)) {
 80486:             data.SetTopStart(true);
     1:           }
     1:         }
     1:       }
     1:     }
     1: 
 29425:     // find the dominant border considering the cell's left border and the
 29425:     // table, col group, col if the border is at the left of the table,
 29425:     // otherwise it was processed in a previous col
 29425:     if (0 == info.mColIndex) {
     1:       if (!tableBorderReset[NS_SIDE_LEFT]) {
     1:         propData->mLeftBorderWidth = 0;
 80486:         tableBorderReset[NS_SIDE_LEFT] = true;
     1:       }
106838:       info.mCurrentRowFrame = nullptr;
108991:       for (int32_t rowY = info.mRowIndex; rowY <= info.GetCellEndRowIndex();
 29425:            rowY++) {
 29425:         info.IncrementRow(rowY == info.mRowIndex);
 29425:         currentBorder = info.GetLeftEdgeBorder();
 29425:         BCCornerInfo& tlCorner = (0 == rowY) ? topCorners[0] : bottomCorners[0];
     1:         tlCorner.Update(NS_SIDE_BOTTOM, currentBorder);
 29425:         tableCellMap->SetBCBorderCorner(eTopLeft, *iter.mCellMap,
 29425:                                         iter.mRowGroupStart, rowY, 0,
 41421:                                         mozilla::css::Side(tlCorner.ownerSide),
 41421:                                         tlCorner.subWidth,
 29425:                                         tlCorner.bevel);
     1:         bottomCorners[0].Set(NS_SIDE_TOP, currentBorder); // bottom left
 29425: 
     1:         // update lastVerBordersBorder and see if a new segment starts
     1:         startSeg = SetBorder(currentBorder, lastVerBorders[0]);
     1:         // store the border segment in the cell map
 29425:         tableCellMap->SetBCBorderEdge(NS_SIDE_LEFT, *iter.mCellMap,
 29425:                                       iter.mRowGroupStart, rowY, info.mColIndex,
 29425:                                       1, currentBorder.owner,
 29425:                                       currentBorder.width, startSeg);
 29425:         info.SetTableLeftBorderWidth(rowY , currentBorder.width);
 29425:         info.SetLeftBorderWidths(currentBorder.width);
 29425:         info.SetRowLeftContBCBorder();
 29425:       }
 29425:       info.SetRowGroupLeftContBCBorder();
 29425:     }
 29425: 
 29425:     // find the dominant border considering the cell's right border, adjacent
 29425:     // cells and the table, row group, row
 29425:     if (info.mNumTableCols == info.GetCellEndColIndex() + 1) {
 29425:       // touches right edge of table
     1:       if (!tableBorderReset[NS_SIDE_RIGHT]) {
     1:         propData->mRightBorderWidth = 0;
 80486:         tableBorderReset[NS_SIDE_RIGHT] = true;
     1:       }
106838:       info.mCurrentRowFrame = nullptr;
108991:       for (int32_t rowY = info.mRowIndex; rowY <= info.GetCellEndRowIndex();
 29425:            rowY++) {
 29425:         info.IncrementRow(rowY == info.mRowIndex);
 29425:         currentBorder = info.GetRightEdgeBorder();
     1:         // update/store the top right & bottom right corners
 29425:         BCCornerInfo& trCorner = (0 == rowY) ?
 29425:                                  topCorners[info.GetCellEndColIndex() + 1] :
 29425:                                  bottomCorners[info.GetCellEndColIndex() + 1];
     1:         trCorner.Update(NS_SIDE_BOTTOM, currentBorder);   // top right
 29425:         tableCellMap->SetBCBorderCorner(eTopRight, *iter.mCellMap,
 29425:                                         iter.mRowGroupStart, rowY,
 29425:                                         info.GetCellEndColIndex(),
 41421:                                         mozilla::css::Side(trCorner.ownerSide),
 41421:                                         trCorner.subWidth,
 29425:                                         trCorner.bevel);
 29425:         BCCornerInfo& brCorner = bottomCorners[info.GetCellEndColIndex() + 1];
     1:         brCorner.Set(NS_SIDE_TOP, currentBorder); // bottom right
 29425:         tableCellMap->SetBCBorderCorner(eBottomRight, *iter.mCellMap,
 29425:                                         iter.mRowGroupStart, rowY,
 29425:                                         info.GetCellEndColIndex(),
 41421:                                         mozilla::css::Side(brCorner.ownerSide),
 41421:                                         brCorner.subWidth,
 29425:                                         brCorner.bevel);
     1:         // update lastVerBorders and see if a new segment starts
 29425:         startSeg = SetBorder(currentBorder,
 29425:                              lastVerBorders[info.GetCellEndColIndex() + 1]);
     1:         // store the border segment in the cell map and update cellBorders
 29425:         tableCellMap->SetBCBorderEdge(NS_SIDE_RIGHT, *iter.mCellMap,
 29425:                                       iter.mRowGroupStart, rowY,
 29425:                                       info.GetCellEndColIndex(), 1,
 29425:                                       currentBorder.owner, currentBorder.width,
 29425:                                       startSeg);
 29425:         info.SetTableRightBorderWidth(rowY, currentBorder.width);
 29425:         info.SetRightBorderWidths(currentBorder.width);
 29425:         info.SetRowRightContBCBorder();
 29425:       }
 29425:       info.SetRowGroupRightContBCBorder();
     1:     }
     1:     else {
108991:       int32_t segLength = 0;
 29425:       BCMapCellInfo priorAjaInfo(this);
108991:       for (int32_t rowY = info.mRowIndex; rowY <= info.GetCellEndRowIndex();
 29425:            rowY += segLength) {
 29425:         iter.PeekRight(info, rowY, ajaInfo);
 29425:         currentBorder  = info.GetRightInternalBorder();
 29425:         adjacentBorder = ajaInfo.GetLeftInternalBorder();
 29425:         currentBorder = CompareBorders(!CELL_CORNER, currentBorder,
 29425:                                         adjacentBorder, !HORIZONTAL);
 29425: 
 32531:         segLength = NS_MAX(1, ajaInfo.mRowIndex + ajaInfo.mRowSpan - rowY);
 32531:         segLength = NS_MIN(segLength, info.mRowIndex + info.mRowSpan - rowY);
     1: 
     1:         // update lastVerBorders and see if a new segment starts
 29425:         startSeg = SetBorder(currentBorder,
 29425:                              lastVerBorders[info.GetCellEndColIndex() + 1]);
     1:         // store the border segment in the cell map and update cellBorders
 29425:         if (info.GetCellEndColIndex() < damageArea.XMost() &&
 29425:             rowY >= damageArea.y && rowY < damageArea.YMost()) {
 29425:           tableCellMap->SetBCBorderEdge(NS_SIDE_RIGHT, *iter.mCellMap,
 29425:                                         iter.mRowGroupStart, rowY,
 29425:                                         info.GetCellEndColIndex(), segLength,
 29425:                                         currentBorder.owner,
 29425:                                         currentBorder.width, startSeg);
 29425:           info.SetRightBorderWidths(currentBorder.width);
 29425:           ajaInfo.SetLeftBorderWidths(currentBorder.width);
     1:         }
     1:         // update the top right corner
 79445:         bool hitsSpanOnRight = (rowY > ajaInfo.mRowIndex) &&
 29425:                                   (rowY < ajaInfo.mRowIndex + ajaInfo.mRowSpan);
 29425:         BCCornerInfo* trCorner = ((0 == rowY) || hitsSpanOnRight) ?
 29425:                                  &topCorners[info.GetCellEndColIndex() + 1] :
 29425:                                  &bottomCorners[info.GetCellEndColIndex() + 1];
     1:         trCorner->Update(NS_SIDE_BOTTOM, currentBorder);
 29425:         // if this is not the first time through,
 29425:         // consider the segment to the right
 29425:         if (rowY != info.mRowIndex) {
 29425:           currentBorder  = priorAjaInfo.GetBottomInternalBorder();
 29425:           adjacentBorder = ajaInfo.GetTopInternalBorder();
 29425:           currentBorder = CompareBorders(!CELL_CORNER, currentBorder,
 29425:                                           adjacentBorder, HORIZONTAL);
     1:           trCorner->Update(NS_SIDE_RIGHT, currentBorder);
     1:         }
     1:         // store the top right corner in the cell map
 29425:         if (info.GetCellEndColIndex() < damageArea.XMost() &&
 29425:             rowY >= damageArea.y) {
 29425:           if (0 != rowY) {
 29425:             tableCellMap->SetBCBorderCorner(eTopRight, *iter.mCellMap,
 29425:                                             iter.mRowGroupStart, rowY,
 29425:                                             info.GetCellEndColIndex(),
 41421:                                             mozilla::css::Side(trCorner->ownerSide),
 29425:                                             trCorner->subWidth,
 29425:                                             trCorner->bevel);
     1:           }
     1:           // store any corners this cell spans together with the aja cell
108991:           for (int32_t rX = rowY + 1; rX < rowY + segLength; rX++) {
 29425:             tableCellMap->SetBCBorderCorner(eBottomRight, *iter.mCellMap,
 29425:                                             iter.mRowGroupStart, rX,
 29425:                                             info.GetCellEndColIndex(),
 41421:                                             mozilla::css::Side(trCorner->ownerSide),
 80486:                                             trCorner->subWidth, false);
     1:           }
     1:         }
     1:         // update bottom right corner, topCorners, bottomCorners
 29425:         hitsSpanOnRight = (rowY + segLength <
 29425:                            ajaInfo.mRowIndex + ajaInfo.mRowSpan);
 29425:         BCCornerInfo& brCorner = (hitsSpanOnRight) ?
 29425:                                  topCorners[info.GetCellEndColIndex() + 1] :
 29425:                                  bottomCorners[info.GetCellEndColIndex() + 1];
     1:         brCorner.Set(NS_SIDE_TOP, currentBorder);
     1:         priorAjaInfo = ajaInfo;
     1:       }
     1:     }
108991:     for (int32_t colX = info.mColIndex + 1; colX <= info.GetCellEndColIndex();
 29425:          colX++) {
     1:       lastVerBorders[colX].Reset(0,1);
     1:     }
     1: 
 29425:     // find the dominant border considering the cell's bottom border, adjacent
 29425:     // cells and the table, row group, row
 29425:     if (info.mNumTableRows == info.GetCellEndRowIndex() + 1) {
 29425:       // touches bottom edge of table
     1:       if (!tableBorderReset[NS_SIDE_BOTTOM]) {
     1:         propData->mBottomBorderWidth = 0;
 80486:         tableBorderReset[NS_SIDE_BOTTOM] = true;
     1:       }
108991:       for (int32_t colX = info.mColIndex; colX <= info.GetCellEndColIndex();
 29425:            colX++) {
 29425:         info.SetColumn(colX);
 29425:         currentBorder = info.GetBottomEdgeBorder();
     1:         // update/store the bottom left & bottom right corners
     1:         BCCornerInfo& blCorner = bottomCorners[colX]; // bottom left
     1:         blCorner.Update(NS_SIDE_RIGHT, currentBorder);
 29425:         tableCellMap->SetBCBorderCorner(eBottomLeft, *iter.mCellMap,
 29425:                                         iter.mRowGroupStart,
 29425:                                         info.GetCellEndRowIndex(),
 41421:                                         colX,
 41421:                                         mozilla::css::Side(blCorner.ownerSide),
 29425:                                         blCorner.subWidth, blCorner.bevel);
     1:         BCCornerInfo& brCorner = bottomCorners[colX + 1]; // bottom right
     1:         brCorner.Update(NS_SIDE_LEFT, currentBorder);
 29425:         if (info.mNumTableCols == colX + 1) { // lower right corner of the table
 29425:           tableCellMap->SetBCBorderCorner(eBottomRight, *iter.mCellMap,
 29425:                                           iter.mRowGroupStart,
 29425:                                           info.GetCellEndRowIndex(),colX,
 41421:                                           mozilla::css::Side(brCorner.ownerSide),
 41421:                                           brCorner.subWidth,
 80486:                                           brCorner.bevel, true);
     1:         }
     1:         // update lastBottomBorder and see if a new segment starts
     1:         startSeg = SetHorBorder(currentBorder, blCorner, lastBottomBorder);
     1:         if (!startSeg) {
 29425:            // make sure that we did not compare apples to oranges i.e. the
 29425:            // current border should be a continuation of the lastBottomBorder,
 29425:            // as it is a bottom border
 29425:            // add 1 to the info.GetCellEndRowIndex()
 29425:            startSeg = (lastBottomBorder.rowIndex !=
 29425:                        (info.GetCellEndRowIndex() + 1));
     1:         }
     1:         // store the border segment in the cell map and update cellBorders
 29425:         tableCellMap->SetBCBorderEdge(NS_SIDE_BOTTOM, *iter.mCellMap,
 29425:                                       iter.mRowGroupStart,
 29425:                                       info.GetCellEndRowIndex(),
 29425:                                       colX, 1, currentBorder.owner,
 29425:                                       currentBorder.width, startSeg);
     1:         // update lastBottomBorders
 29425:         lastBottomBorder.rowIndex = info.GetCellEndRowIndex() + 1;
 29425:         lastBottomBorder.rowSpan = info.mRowSpan;
     1:         lastBottomBorders[colX] = lastBottomBorder;
 29425: 
 29425:         info.SetBottomBorderWidths(currentBorder.width);
 29425:         info.SetTableBottomBorderWidth(currentBorder.width);
 29425:         info.SetColumnBottomContBCBorder();
 29425:       }
 29425:       info.SetRowGroupBottomContBCBorder();
 29425:       info.SetColGroupBottomContBCBorder();
     1:     }
     1:     else {
108991:       int32_t segLength = 0;
108991:       for (int32_t colX = info.mColIndex; colX <= info.GetCellEndColIndex();
 29425:            colX += segLength) {
     1:         iter.PeekBottom(info, colX, ajaInfo);
 29425:         currentBorder  = info.GetBottomInternalBorder();
 29425:         adjacentBorder = ajaInfo.GetTopInternalBorder();
 29425:         currentBorder = CompareBorders(!CELL_CORNER, currentBorder,
 29425:                                         adjacentBorder, HORIZONTAL);
 32531:         segLength = NS_MAX(1, ajaInfo.mColIndex + ajaInfo.mColSpan - colX);
 32531:         segLength = NS_MIN(segLength, info.mColIndex + info.mColSpan - colX);
     1: 
     1:         // update, store the bottom left corner
     1:         BCCornerInfo& blCorner = bottomCorners[colX]; // bottom left
 79445:         bool hitsSpanBelow = (colX > ajaInfo.mColIndex) &&
 29425:                                (colX < ajaInfo.mColIndex + ajaInfo.mColSpan);
 79445:         bool update = true;
 29425:         if ((colX == info.mColIndex) && (colX > damageArea.x)) {
108991:           int32_t prevRowIndex = lastBottomBorders[colX - 1].rowIndex;
 29425:           if (prevRowIndex > info.GetCellEndRowIndex() + 1) {
 29425:             // hits a rowspan on the right
 80486:             update = false;
 29425:             // the corner was taken care of during the cell on the left
 29425:           }
 29425:           else if (prevRowIndex < info.GetCellEndRowIndex() + 1) {
 29425:             // spans below the cell to the left
     1:             topCorners[colX] = blCorner;
     1:             blCorner.Set(NS_SIDE_RIGHT, currentBorder);
 80486:             update = false;
     1:           }
     1:         }
     1:         if (update) {
     1:           blCorner.Update(NS_SIDE_RIGHT, currentBorder);
     1:         }
 29425:         if (info.GetCellEndRowIndex() < damageArea.YMost() &&
 29425:             (colX >= damageArea.x)) {
     1:           if (hitsSpanBelow) {
 29425:             tableCellMap->SetBCBorderCorner(eBottomLeft, *iter.mCellMap,
 29425:                                             iter.mRowGroupStart,
 29425:                                             info.GetCellEndRowIndex(), colX,
 41421:                                             mozilla::css::Side(blCorner.ownerSide),
 29425:                                             blCorner.subWidth, blCorner.bevel);
     1:           }
     1:           // store any corners this cell spans together with the aja cell
108991:           for (int32_t cX = colX + 1; cX < colX + segLength; cX++) {
     1:             BCCornerInfo& corner = bottomCorners[cX];
     1:             corner.Set(NS_SIDE_RIGHT, currentBorder);
 29425:             tableCellMap->SetBCBorderCorner(eBottomLeft, *iter.mCellMap,
 29425:                                             iter.mRowGroupStart,
 29425:                                             info.GetCellEndRowIndex(), cX,
 41421:                                             mozilla::css::Side(corner.ownerSide),
 41421:                                             corner.subWidth,
 80486:                                             false);
     1:           }
     1:         }
     1:         // update lastBottomBorders and see if a new segment starts
     1:         startSeg = SetHorBorder(currentBorder, blCorner, lastBottomBorder);
     1:         if (!startSeg) {
 29425:            // make sure that we did not compare apples to oranges i.e. the
 29425:            // current border should be a continuation of the lastBottomBorder,
 29425:            // as it is a bottom border
 29425:            // add 1 to the info.GetCellEndRowIndex()
 29425:            startSeg = (lastBottomBorder.rowIndex !=
 29425:                        info.GetCellEndRowIndex() + 1);
 29425:         }
 29425:         lastBottomBorder.rowIndex = info.GetCellEndRowIndex() + 1;
 29425:         lastBottomBorder.rowSpan = info.mRowSpan;
108991:         for (int32_t cX = colX; cX < colX + segLength; cX++) {
     1:           lastBottomBorders[cX] = lastBottomBorder;
     1:         }
     1: 
     1:         // store the border segment the cell map and update cellBorders
 29425:         if (info.GetCellEndRowIndex() < damageArea.YMost() &&
 29425:             (colX >= damageArea.x) &&
 29425:             (colX < damageArea.XMost())) {
 29425:           tableCellMap->SetBCBorderEdge(NS_SIDE_BOTTOM, *iter.mCellMap,
 29425:                                         iter.mRowGroupStart,
 29425:                                         info.GetCellEndRowIndex(),
 29425:                                         colX, segLength, currentBorder.owner,
 29425:                                         currentBorder.width, startSeg);
 29425:           info.SetBottomBorderWidths(currentBorder.width);
 29425:           ajaInfo.SetTopBorderWidths(currentBorder.width);
     1:         }
     1:         // update bottom right corner
     1:         BCCornerInfo& brCorner = bottomCorners[colX + segLength];
     1:         brCorner.Update(NS_SIDE_LEFT, currentBorder);
     1:       }
 29425:       if (!gotRowBorder && 1 == info.mRowSpan &&
 29425:           (ajaInfo.mTopRow || info.mRgAtBottom)) {
     1:         //get continuous row/row group border
     1:         //we need to check the row group's bottom border if this is
     1:         //the last row in the row group, but only a cell with rowspan=1
     1:         //will know whether *this* row is at the bottom
 29425:         const nsIFrame* nextRowGroup = (ajaInfo.mRgAtTop) ? ajaInfo.mRowGroup :
106838:                                                              nullptr;
 29425:         info.SetInnerRowGroupBottomContBCBorder(nextRowGroup, ajaInfo.mTopRow);
 80486:         gotRowBorder = true;
     1:       }
     1:     }
     1: 
 29425:     // see if the cell to the right had a rowspan and its lower left border
 29425:     // needs be joined with this one's bottom
 29425:     // if  there is a cell to the right and the cell to right was a rowspan
 29425:     if ((info.mNumTableCols != info.GetCellEndColIndex() + 1) &&
 29425:         (lastBottomBorders[info.GetCellEndColIndex() + 1].rowSpan > 1)) {
 29425:       BCCornerInfo& corner = bottomCorners[info.GetCellEndColIndex() + 1];
 29425:       if ((NS_SIDE_TOP != corner.ownerSide) &&
 29425:           (NS_SIDE_BOTTOM != corner.ownerSide)) {
 29425:         // not a vertical owner
     1:         BCCellBorder& thisBorder = lastBottomBorder;
 29425:         BCCellBorder& nextBorder = lastBottomBorders[info.mColIndex + 1];
 29425:         if ((thisBorder.color == nextBorder.color) &&
 29425:             (thisBorder.width == nextBorder.width) &&
     1:             (thisBorder.style == nextBorder.style)) {
 29425:           // set the flag on the next border indicating it is not the start of a
 29425:           // new segment
     1:           if (iter.mCellMap) {
 62666:             tableCellMap->ResetTopStart(NS_SIDE_BOTTOM, *iter.mCellMap,
 29425:                                         info.GetCellEndRowIndex(),
 29425:                                         info.GetCellEndColIndex() + 1);
 29425:           }
 29425:         }
 29425:       }
 29425:     }
 29425:   } // for (iter.First(info); info.mCell; iter.Next(info)) {
     1:   // reset the bc flag and damage area
 80486:   SetNeedToCalcBCBorders(false);
 87904:   propData->mDamageArea = nsIntRect(0,0,0,0);
     1: #ifdef DEBUG_TABLE_CELLMAP
     1:   mCellMap->Dump();
     1: #endif
     1: }
     1: 
 34593: class BCPaintBorderIterator;
 34593: 
 34593: struct BCVerticalSeg
 34593: {
 34593:   BCVerticalSeg();
 34593: 
 34593:   void Start(BCPaintBorderIterator& aIter,
 34593:              BCBorderOwner          aBorderOwner,
 34593:              BCPixelSize            aVerSegWidth,
 34593:              BCPixelSize            aHorSegHeight);
 34593: 
 34593:   void Initialize(BCPaintBorderIterator& aIter);
 34593:   void GetBottomCorner(BCPaintBorderIterator& aIter,
 34593:                        BCPixelSize            aHorSegHeight);
 34593: 
 34593: 
 34593:    void Paint(BCPaintBorderIterator& aIter,
 68481:               nsRenderingContext&   aRenderingContext,
 34593:               BCPixelSize            aHorSegHeight);
 34593:   void AdvanceOffsetY();
 34593:   void IncludeCurrentBorder(BCPaintBorderIterator& aIter);
 34593: 
 34593: 
 34593:   union {
 34593:     nsTableColFrame*  mCol;
108991:     int32_t           mColWidth;
 34593:   };
 34593:   nscoord               mOffsetX;    // x-offset with respect to the table edge
 34593:   nscoord               mOffsetY;    // y-offset with respect to the table edge
 34593:   nscoord               mLength;     // vertical length including corners
 34593:   BCPixelSize           mWidth;      // width in pixels
 34593: 
 34593:   nsTableCellFrame*     mAjaCell;       // previous sibling to the first cell
 34593:                                         // where the segment starts, it can be
 34593:                                         // the owner of a segment
 34593:   nsTableCellFrame*     mFirstCell;     // cell at the start of the segment
 34593:   nsTableRowGroupFrame* mFirstRowGroup; // row group at the start of the segment
 34593:   nsTableRowFrame*      mFirstRow;      // row at the start of the segment
 34593:   nsTableCellFrame*     mLastCell;      // cell at the current end of the
 34593:                                         // segment
 34593: 
 34593: 
108991:   uint8_t               mOwner;         // owner of the border, defines the
 34593:                                         // style
 41419:   mozilla::css::Side    mTopBevelSide;  // direction to bevel at the top
 34593:   nscoord               mTopBevelOffset; // how much to bevel at the top
 34593:   BCPixelSize           mBottomHorSegHeight; // height of the crossing
 34593:                                         //horizontal border
 34593:   nscoord               mBottomOffset;  // how much longer is the segment due
 34593:                                         // to the horizontal border, by this
 34593:                                         // amount the next segment needs to be
 34593:                                         // shifted.
 79445:   bool                  mIsBottomBevel; // should we bevel at the bottom
 34593: };
 34593: 
 34593: struct BCHorizontalSeg
 34593: {
 34593:   BCHorizontalSeg();
 34593: 
 34593:   void Start(BCPaintBorderIterator& aIter,
 34593:              BCBorderOwner          aBorderOwner,
 34593:              BCPixelSize            aBottomVerSegWidth,
 34593:              BCPixelSize            aHorSegHeight);
 34593:    void GetRightCorner(BCPaintBorderIterator& aIter,
 34593:                        BCPixelSize            aLeftSegWidth);
108991:    void AdvanceOffsetX(int32_t aIncrement);
 34593:    void IncludeCurrentBorder(BCPaintBorderIterator& aIter);
 34593:    void Paint(BCPaintBorderIterator& aIter,
 68481:               nsRenderingContext&   aRenderingContext);
 34593: 
 34593:   nscoord            mOffsetX;       // x-offset with respect to the table edge
 34593:   nscoord            mOffsetY;       // y-offset with respect to the table edge
 34593:   nscoord            mLength;        // horizontal length including corners
 34593:   BCPixelSize        mWidth;         // border width in pixels
 34593:   nscoord            mLeftBevelOffset;   // how much to bevel at the left
 41419:   mozilla::css::Side mLeftBevelSide;     // direction to bevel at the left
 79445:   bool               mIsRightBevel;      // should we bevel at the right end
 34593:   nscoord            mRightBevelOffset;  // how much to bevel at the right
 41419:   mozilla::css::Side mRightBevelSide;    // direction to bevel at the right
 34593:   nscoord            mEndOffset;         // how much longer is the segment due
 34593:                                          // to the vertical border, by this
 34593:                                          // amount the next segment needs to be
 34593:                                          // shifted.
108991:   uint8_t            mOwner;             // owner of the border, defines the
 34593:                                          // style
 34593:   nsTableCellFrame*  mFirstCell;         // cell at the start of the segment
 34593:   nsTableCellFrame*  mAjaCell;           // neighboring cell to the first cell
 34593:                                          // where the segment starts, it can be
 34593:                                          // the owner of a segment
 34593: };
 34593: 
     1: // Iterates over borders (left border, corner, top border) in the cell map within a damage area
     1: // from left to right, top to bottom. All members are in terms of the 1st in flow frames, except
     1: // where suffixed by InFlow.
 34593: class BCPaintBorderIterator
     1: {
     1: public:
 34593: 
 34593: 
 34593:   BCPaintBorderIterator(nsTableFrame* aTable);
 34593:   ~BCPaintBorderIterator() { if (mVerInfo) {
 34593:                               delete [] mVerInfo;
 34593:                            }}
 34593:   void Reset();
 34593: 
 87904:   /**
 87904:    * Determine the damage area in terms of rows and columns and finalize
 87904:    * mInitialOffsetX and mInitialOffsetY.
 87904:    * @param aDirtyRect - dirty rect in table coordinates
 87904:    * @return - true if we need to paint something given dirty rect
 87904:    */
 87904:   bool SetDamageArea(const nsRect& aDamageRect);
     1:   void First();
     1:   void Next();
 68481:   void AccumulateOrPaintHorizontalSegment(nsRenderingContext& aRenderingContext);
 68481:   void AccumulateOrPaintVerticalSegment(nsRenderingContext& aRenderingContext);
 34593:   void ResetVerInfo();
108991:   void StoreColumnWidth(int32_t aIndex);
 79445:   bool VerticalSegmentOwnsCorner();
 34593: 
 34593:   nsTableFrame*         mTable;
 34593:   nsTableFrame*         mTableFirstInFlow;
 34593:   nsTableCellMap*       mTableCellMap;
 34593:   nsCellMap*            mCellMap;
 79445:   bool                  mTableIsLTR;
108991:   int32_t               mColInc;            // +1 for ltr -1 for rtl
 34593:   const nsStyleBackground* mTableBgColor;
 34593:   nsTableFrame::RowGroupArray mRowGroups;
 34593: 
 34593:   nsTableRowGroupFrame* mPrevRg;
 34593:   nsTableRowGroupFrame* mRg;
 79445:   bool                  mIsRepeatedHeader;
 79445:   bool                  mIsRepeatedFooter;
 34593:   nsTableRowGroupFrame* mStartRg; // first row group in the damagearea
108991:   int32_t               mRgIndex; // current row group index in the
 34593:                                         // mRowgroups array
108991:   int32_t               mFifRgFirstRowIndex; // start row index of the first in
 34593:                                            // flow of the row group
108991:   int32_t               mRgFirstRowIndex; // row index of the first row in the
 34593:                                           // row group
108991:   int32_t               mRgLastRowIndex; // row index of the last row in the row
 34593:                                          // group
108991:   int32_t               mNumTableRows;   // number of rows in the table and all
 34593:                                          // continuations
108991:   int32_t               mNumTableCols;   // number of columns in the table
108991:   int32_t               mColIndex;       // with respect to the table
108991:   int32_t               mRowIndex;       // with respect to the table
108991:   int32_t               mRepeatedHeaderRowIndex; // row index in a repeated
 34593:                                             //header, it's equivalent to
 34593:                                             // mRowIndex when we're in a repeated
 34593:                                             // header, and set to the last row
 34593:                                             // index of a repeated header when
 34593:                                             // we're not
 79445:   bool                  mIsNewRow;
 79445:   bool                  mAtEnd;             // the iterator cycled over all
 34593:                                              // borders
 34593:   nsTableRowFrame*      mPrevRow;
 34593:   nsTableRowFrame*      mRow;
 34593:   nsTableRowFrame*      mStartRow;    //first row in a inside the damagearea
 34593: 
 34593: 
 34593:   // cell properties
 34593:   nsTableCellFrame*     mPrevCell;
 34593:   nsTableCellFrame*     mCell;
 34593:   BCCellData*           mPrevCellData;
 34593:   BCCellData*           mCellData;
 34593:   BCData*               mBCData;
 34593: 
 79445:   bool                  IsTableTopMost()    {return (mRowIndex == 0) && !mTable->GetPrevInFlow();}
 79445:   bool                  IsTableRightMost()  {return (mColIndex >= mNumTableCols);}
 79445:   bool                  IsTableBottomMost() {return (mRowIndex >= mNumTableRows) && !mTable->GetNextInFlow();}
 79445:   bool                  IsTableLeftMost()   {return (mColIndex == 0);}
 79445:   bool                  IsDamageAreaTopMost()    {return (mRowIndex == mDamageArea.y);}
 79445:   bool                  IsDamageAreaRightMost()  {return (mColIndex >= mDamageArea.XMost());}
 79445:   bool                  IsDamageAreaBottomMost() {return (mRowIndex >= mDamageArea.YMost());}
 79445:   bool                  IsDamageAreaLeftMost()   {return (mColIndex == mDamageArea.x);}
108991:   int32_t               GetRelativeColIndex() {return (mColIndex - mDamageArea.x);}
 34593: 
 87904:   nsIntRect             mDamageArea;        // damageArea in cellmap coordinates
 79445:   bool                  IsAfterRepeatedHeader() { return !mIsRepeatedHeader && (mRowIndex == (mRepeatedHeaderRowIndex + 1));}
 79445:   bool                  StartRepeatedFooter() {return mIsRepeatedFooter && (mRowIndex == mRgFirstRowIndex) && (mRowIndex != mDamageArea.y);}
 34593:   nscoord               mInitialOffsetX;  // offsetX of the first border with
 34593:                                             // respect to the table
 34593:   nscoord               mInitialOffsetY;    // offsetY of the first border with
 34593:                                             // respect to the table
 34593:   nscoord               mNextOffsetY;       // offsetY of the next segment
 34593:   BCVerticalSeg*        mVerInfo; // this array is used differently when
 34593:                                   // horizontal and vertical borders are drawn
 34593:                                   // When horizontal border are drawn we cache
 34593:                                   // the column widths and the width of the
 34593:                                   // vertical borders that arrive from top
 34593:                                   // When we draw vertical borders we store
 34593:                                   // lengths and width for vertical borders
 34593:                                   // before they are drawn while we  move over
 34593:                                   // the columns in the damage area
 34593:                                   // It has one more elements than columns are
 34593:                                   //in the table.
 34593:   BCHorizontalSeg       mHorSeg;            // the horizontal segment while we
 34593:                                             // move over the colums
 34593:   BCPixelSize           mPrevHorSegHeight;  // the height of the previous
 34593:                                             // horizontal border
     1: 
     1: private:
     1: 
106838:   bool SetNewRow(nsTableRowFrame* aRow = nullptr);
 79445:   bool SetNewRowGroup();
108991:   void   SetNewData(int32_t aRowIndex, int32_t aColIndex);
     1: 
     1: };
     1: 
 34593: 
 34593: 
 34593: BCPaintBorderIterator::BCPaintBorderIterator(nsTableFrame* aTable)
 34593: {
 34593:   mTable      = aTable;
106838:   mVerInfo    = nullptr;
106838:   nsMargin childAreaOffset = mTable->GetChildAreaOffset(nullptr);
 34593:   mTableFirstInFlow    = (nsTableFrame*) mTable->GetFirstInFlow();
 34593:   mTableCellMap        = mTable->GetCellMap();
 34593:   // y position of first row in damage area
 87904:   mInitialOffsetY = mTable->GetPrevInFlow() ? 0 : childAreaOffset.top;
 34593:   mNumTableRows  = mTable->GetRowCount();
 34593:   mNumTableCols  = mTable->GetColCount();
 34593: 
 34593:   // Get the ordered row groups
 34593:   mTable->OrderRowGroups(mRowGroups);
 37318:   // initialize to a non existing index
 37318:   mRepeatedHeaderRowIndex = -99;
 34593: 
 34593:   mTableIsLTR = mTable->GetStyleVisibility()->mDirection ==
 34593:                    NS_STYLE_DIRECTION_LTR;
 34593:   mColInc = (mTableIsLTR) ? 1 : -1;
 34593: 
 40588:   nsIFrame* bgFrame =
 40588:     nsCSSRendering::FindNonTransparentBackgroundFrame(aTable);
 40588:   mTableBgColor = bgFrame->GetStyleBackground();
 34593: }
 34593: 
 79445: bool
 87904: BCPaintBorderIterator::SetDamageArea(const nsRect& aDirtyRect)
 34593: {
 34593: 
108991:   uint32_t startRowIndex, endRowIndex, startColIndex, endColIndex;
 34593:   startRowIndex = endRowIndex = startColIndex = endColIndex = 0;
 79445:   bool done = false;
 79445:   bool haveIntersect = false;
 87904:   // find startRowIndex, endRowIndex
 87904:   nscoord rowY = mInitialOffsetY;
108991:   for (uint32_t rgX = 0; rgX < mRowGroups.Length() && !done; rgX++) {
 34593:     nsTableRowGroupFrame* rgFrame = mRowGroups[rgX];
 34593:     for (nsTableRowFrame* rowFrame = rgFrame->GetFirstRow(); rowFrame;
 34593:          rowFrame = rowFrame->GetNextRow()) {
 34593:       // conservatively estimate the half border widths outside the row
 34593:       nscoord topBorderHalf    = (mTable->GetPrevInFlow()) ? 0 :
 34593:        nsPresContext::CSSPixelsToAppUnits(rowFrame->GetTopBCBorderWidth() + 1);
 34593:       nscoord bottomBorderHalf = (mTable->GetNextInFlow()) ? 0 :
 34593:         nsPresContext::CSSPixelsToAppUnits(rowFrame->GetBottomBCBorderWidth() + 1);
 34593:       // get the row rect relative to the table rather than the row group
 34593:       nsSize rowSize = rowFrame->GetSize();
 34593:       if (haveIntersect) {
 34593:         if (aDirtyRect.YMost() >= (rowY - topBorderHalf)) {
 34593:           nsTableRowFrame* fifRow =
 87439:             static_cast<nsTableRowFrame*>(rowFrame->GetFirstInFlow());
 34593:           endRowIndex = fifRow->GetRowIndex();
 34593:         }
 80486:         else done = true;
 34593:       }
 34593:       else {
 34593:         if ((rowY + rowSize.height + bottomBorderHalf) >= aDirtyRect.y) {
 34593:           mStartRg  = rgFrame;
 34593:           mStartRow = rowFrame;
 34593:           nsTableRowFrame* fifRow =
 87439:             static_cast<nsTableRowFrame*>(rowFrame->GetFirstInFlow());
 34593:           startRowIndex = endRowIndex = fifRow->GetRowIndex();
 80486:           haveIntersect = true;
 34593:         }
 34593:         else {
 34593:           mInitialOffsetY += rowSize.height;
 34593:         }
 34593:       }
 34593:       rowY += rowSize.height;
 34593:     }
 34593:   }
 34593:   mNextOffsetY = mInitialOffsetY;
 34593: 
 34593:   // XXX comment refers to the obsolete NS_FRAME_OUTSIDE_CHILDREN flag
 34593:   // XXX but I don't understand it, so not changing it for now
 34593:   // outer table borders overflow the table, so the table might be
 34593:   // target to other areas as the NS_FRAME_OUTSIDE_CHILDREN is set
 34593:   // on the table
 34593:   if (!haveIntersect)
 80486:     return false;
 34593:   // find startColIndex, endColIndex, startColX
 80486:   haveIntersect = false;
 34593:   if (0 == mNumTableCols)
 80486:     return false;
108991:   int32_t leftCol, rightCol; // columns are in the range [leftCol, rightCol)
 34593: 
106838:   nsMargin childAreaOffset = mTable->GetChildAreaOffset(nullptr);
 34593:   if (mTableIsLTR) {
 34593:     mInitialOffsetX = childAreaOffset.left; // x position of first col in
 34593:                                             // damage area
 34593:     leftCol = 0;
 34593:     rightCol = mNumTableCols;
 34593:   } else {
 34593:     // x position of first col in damage area
 34593:     mInitialOffsetX = mTable->GetRect().width - childAreaOffset.right;
 34593:     leftCol = mNumTableCols-1;
 34593:     rightCol = -1;
 34593:   }
 34593:   nscoord x = 0;
108991:   int32_t colX;
 34593:   for (colX = leftCol; colX != rightCol; colX += mColInc) {
 34593:     nsTableColFrame* colFrame = mTableFirstInFlow->GetColFrame(colX);
 80486:     if (!colFrame) ABORT1(false);
 34593:     // get the col rect relative to the table rather than the col group
 34593:     nsSize size = colFrame->GetSize();
 34593:     if (haveIntersect) {
 87905:       // conservatively estimate the left half border width outside the col
 87905:       nscoord leftBorderHalf =
 87905:         nsPresContext::CSSPixelsToAppUnits(colFrame->GetLeftBorderWidth() + 1);
 34593:       if (aDirtyRect.XMost() >= (x - leftBorderHalf)) {
 34593:         endColIndex = colX;
 34593:       }
 34593:       else break;
 34593:     }
 34593:     else {
 87905:       // conservatively estimate the right half border width outside the col
 87905:       nscoord rightBorderHalf =
 87905:         nsPresContext::CSSPixelsToAppUnits(colFrame->GetRightBorderWidth() + 1);
 34593:       if ((x + size.width + rightBorderHalf) >= aDirtyRect.x) {
 34593:         startColIndex = endColIndex = colX;
 80486:         haveIntersect = true;
 34593:       }
 34593:       else {
 34593:         mInitialOffsetX += mColInc * size.width;
 34593:       }
 34593:     }
 34593:     x += size.width;
 34593:   }
 34593:   if (!mTableIsLTR) {
108991:     uint32_t temp;
 34593:     mInitialOffsetX = mTable->GetRect().width - childAreaOffset.right;
 34593:     temp = startColIndex; startColIndex = endColIndex; endColIndex = temp;
108991:     for (uint32_t column = 0; column < startColIndex; column++) {
 34593:       nsTableColFrame* colFrame = mTableFirstInFlow->GetColFrame(column);
 80486:       if (!colFrame) ABORT1(false);
 34593:       nsSize size = colFrame->GetSize();
 34593:       mInitialOffsetX += mColInc * size.width;
 34593:     }
 34593:   }
 34593:   if (!haveIntersect)
 80486:     return false;
 87904:   mDamageArea = nsIntRect(startColIndex, startRowIndex,
124775:                           1 + std::abs(int32_t(endColIndex - startColIndex)),
 34593:                           1 + endRowIndex - startRowIndex);
 34593: 
 34593:   Reset();
 34593:   mVerInfo = new BCVerticalSeg[mDamageArea.width + 1];
 34593:   if (!mVerInfo)
 80486:     return false;
 80486:   return true;
 34591: }
 34591: 
 34591: void
 34593: BCPaintBorderIterator::Reset()
 34593: {
 80486:   mAtEnd = true; // gets reset when First() is called
 34593:   mRg = mStartRg;
106838:   mPrevRow  = nullptr;
 34593:   mRow      = mStartRow;
 34593:   mRowIndex      = 0;
 34593:   mColIndex      = 0;
 34593:   mRgIndex       = -1;
106838:   mPrevCell      = nullptr;
106838:   mCell          = nullptr;
106838:   mPrevCellData  = nullptr;
106838:   mCellData      = nullptr;
106838:   mBCData        = nullptr;
 34593:   ResetVerInfo();
 34593: }
 34593: 
 34593: /**
 34593:  * Set the iterator data to a new cellmap coordinate
 34593:  * @param aRowIndex - the row index
 34593:  * @param aColIndex - the col index
 34593:  */
 34591: void
108991: BCPaintBorderIterator::SetNewData(int32_t aY,
108991:                                 int32_t aX)
 34591: {
 34593:   if (!mTableCellMap || !mTableCellMap->mBCInfo) ABORT0();
 34593: 
 34593:   mColIndex    = aX;
 34593:   mRowIndex    = aY;
 34593:   mPrevCellData = mCellData;
 34593:   if (IsTableRightMost() && IsTableBottomMost()) {
106838:    mCell = nullptr;
 34593:    mBCData = &mTableCellMap->mBCInfo->mLowerRightCorner;
 34593:   }
 34593:   else if (IsTableRightMost()) {
106838:     mCellData = nullptr;
 34593:     mBCData = &mTableCellMap->mBCInfo->mRightBorders.ElementAt(aY);
 34593:   }
 34593:   else if (IsTableBottomMost()) {
106838:     mCellData = nullptr;
 34593:     mBCData = &mTableCellMap->mBCInfo->mBottomBorders.ElementAt(aX);
 34591:   }
 34591:   else {
108991:     if (uint32_t(mRowIndex - mFifRgFirstRowIndex) < mCellMap->mRows.Length()) {
106838:       mBCData = nullptr;
 34593:       mCellData =
 34593:         (BCCellData*)mCellMap->mRows[mRowIndex - mFifRgFirstRowIndex].SafeElementAt(mColIndex);
 34593:       if (mCellData) {
 34593:         mBCData = &mCellData->mData;
 34593:         if (!mCellData->IsOrig()) {
 34593:           if (mCellData->IsRowSpan()) {
 34593:             aY -= mCellData->GetRowSpanOffset();
 34593:           }
 34593:           if (mCellData->IsColSpan()) {
 34593:             aX -= mCellData->GetColSpanOffset();
 34591:           }
 34591:           if ((aX >= 0) && (aY >= 0)) {
 34593:             mCellData = (BCCellData*)mCellMap->mRows[aY - mFifRgFirstRowIndex][aX];
 34593:           }
 34593:         }
 34593:         if (mCellData->IsOrig()) {
 34593:           mPrevCell = mCell;
 34593:           mCell = mCellData->GetCellFrame();
 34593:         }
 34593:       }
 34593:     }
 34593:   }
 34593: }
 34593: 
 34593: /**
 34593:  * Set the iterator to a new row
 34593:  * @param aRow - the new row frame, if null the iterator will advance to the
 34593:  *               next row
 34593:  */
 79445: bool
 34593: BCPaintBorderIterator::SetNewRow(nsTableRowFrame* aRow)
 34593: {
 34593:   mPrevRow = mRow;
 34593:   mRow     = (aRow) ? aRow : mRow->GetNextRow();
 34593:   if (mRow) {
 80486:     mIsNewRow = true;
 34593:     mRowIndex = mRow->GetRowIndex();
 34593:     mColIndex = mDamageArea.x;
 34593:     mPrevHorSegHeight = 0;
 34593:     if (mIsRepeatedHeader) {
 34593:       mRepeatedHeaderRowIndex = mRowIndex;
 34593:     }
 34591:   }
 34591:   else {
 80486:     mAtEnd = true;
 34593:   }
 34593:   return !mAtEnd;
 34593: }
 34593: 
 34593: /**
 34593:  * Advance the iterator to the next row group
 34593:  */
 79445: bool
 34593: BCPaintBorderIterator::SetNewRowGroup()
 34593: {
 34593: 
 34593:   mRgIndex++;
 34593: 
 80486:   mIsRepeatedHeader = false;
 80486:   mIsRepeatedFooter = false;
 34593: 
 38996:   NS_ASSERTION(mRgIndex >= 0, "mRgIndex out of bounds");
108991:   if (uint32_t(mRgIndex) < mRowGroups.Length()) {
 34593:     mPrevRg = mRg;
 34593:     mRg = mRowGroups[mRgIndex];
 87906:     nsTableRowGroupFrame* fifRg =
 87906:       static_cast<nsTableRowGroupFrame*>(mRg->GetFirstInFlow());
 87906:     mFifRgFirstRowIndex = fifRg->GetStartRowIndex();
 34593:     mRgFirstRowIndex    = mRg->GetStartRowIndex();
 34593:     mRgLastRowIndex     = mRgFirstRowIndex + mRg->GetRowCount() - 1;
 34593: 
 34593:     if (SetNewRow(mRg->GetFirstRow())) {
106838:       mCellMap = mTableCellMap->GetMapFor(fifRg, nullptr);
 80486:       if (!mCellMap) ABORT1(false);
 34593:     }
 34593:     if (mRg && mTable->GetPrevInFlow() && !mRg->GetPrevInFlow()) {
 34593:       // if mRowGroup doesn't have a prev in flow, then it may be a repeated
 34593:       // header or footer
 34593:       const nsStyleDisplay* display = mRg->GetStyleDisplay();
 34593:       if (mRowIndex == mDamageArea.y) {
 34593:         mIsRepeatedHeader = (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == display->mDisplay);
 34591:       }
 34591:       else {
 34593:         mIsRepeatedFooter = (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == display->mDisplay);
 34591:       }
 34591:     }
 34591:   }
 34591:   else {
 80486:     mAtEnd = true;
 34593:   }
 34593:   return !mAtEnd;
 34593: }
 34593: 
 34593: /**
 34593:  *  Move the iterator to the first position in the damageArea
 34593:  */
 34591: void
 34593: BCPaintBorderIterator::First()
 34593: {
 34593:   if (!mTable || (mDamageArea.x >= mNumTableCols) ||
 34593:       (mDamageArea.y >= mNumTableRows)) ABORT0();
 34593: 
 80486:   mAtEnd = false;
 34593: 
108991:   uint32_t numRowGroups = mRowGroups.Length();
108991:   for (uint32_t rgY = 0; rgY < numRowGroups; rgY++) {
 34593:     nsTableRowGroupFrame* rowG = mRowGroups[rgY];
108991:     int32_t start = rowG->GetStartRowIndex();
108991:     int32_t end   = start + rowG->GetRowCount() - 1;
 34593:     if ((mDamageArea.y >= start) && (mDamageArea.y <= end)) {
 34593:       mRgIndex = rgY - 1; // SetNewRowGroup increments rowGroupIndex
 34591:       if (SetNewRowGroup()) {
 34593:         while ((mRowIndex < mDamageArea.y) && !mAtEnd) {
 34591:           SetNewRow();
 34591:         }
 34593:         if (!mAtEnd) {
 34593:           SetNewData(mDamageArea.y, mDamageArea.x);
 34591:         }
 34591:       }
 34591:       return;
 34591:     }
 34591:   }
 80486:   mAtEnd = true;
 34593: }
 34593: 
 34593: /**
 34593:  * Advance the iterator to the next position
 34593:  */
 34591: void
 34593: BCPaintBorderIterator::Next()
 34593: {
 34593:   if (mAtEnd) ABORT0();
 80486:   mIsNewRow = false;
 34593: 
 34593:   mColIndex++;
 34593:   if (mColIndex > mDamageArea.XMost()) {
 34593:     mRowIndex++;
 34593:     if (mRowIndex == mDamageArea.YMost()) {
 34593:       mColIndex = mDamageArea.x;
 34593:     }
 34593:     else if (mRowIndex < mDamageArea.YMost()) {
 34593:       if (mRowIndex <= mRgLastRowIndex) {
 34591:         SetNewRow();
 34591:       }
 34591:       else {
 34591:         SetNewRowGroup();
 34591:       }
 34591:     }
 34591:     else {
 80486:       mAtEnd = true;
 34593:     }
 34593:   }
 34593:   if (!mAtEnd) {
 34593:     SetNewData(mRowIndex, mColIndex);
 34593:   }
 34593: }
 34593: 
 34593: // XXX if CalcVerCornerOffset and CalcHorCornerOffset remain similar, combine
 34593: // them
 34593: /** Compute the vertical offset of a vertical border segment
 34593:   * @param aCornerOwnerSide - which side owns the corner
 34593:   * @param aCornerSubWidth  - how wide is the nonwinning side of the corner
 34593:   * @param aHorWidth        - how wide is the horizontal edge of the corner
 34593:   * @param aIsStartOfSeg    - does this corner start a new segment
 34593:   * @param aIsBevel         - is this corner beveled
 34593:   * @return                 - offset in twips
 34593:   */
 34591: static nscoord
 41419: CalcVerCornerOffset(mozilla::css::Side aCornerOwnerSide,
 34593:                     BCPixelSize aCornerSubWidth,
 34593:                     BCPixelSize aHorWidth,
 79445:                     bool        aIsStartOfSeg,
 79445:                     bool        aIsBevel)
 34591: {
 34591:   nscoord offset = 0;
 34593:   // XXX These should be replaced with appropriate side-specific macros (which?)
 34593:   BCPixelSize smallHalf, largeHalf;
 34593:   if ((NS_SIDE_TOP == aCornerOwnerSide) ||
 34593:       (NS_SIDE_BOTTOM == aCornerOwnerSide)) {
 34591:     DivideBCBorderSize(aCornerSubWidth, smallHalf, largeHalf);
 34591:     if (aIsBevel) {
 34591:       offset = (aIsStartOfSeg) ? -largeHalf : smallHalf;
 34591:     }
 34591:     else {
 34591:       offset = (NS_SIDE_TOP == aCornerOwnerSide) ? smallHalf : -largeHalf;
 34591:     }
 34591:   }
 34591:   else {
 34591:     DivideBCBorderSize(aHorWidth, smallHalf, largeHalf);
 34591:     if (aIsBevel) {
 34591:       offset = (aIsStartOfSeg) ? -largeHalf : smallHalf;
 34591:     }
 34591:     else {
 34591:       offset = (aIsStartOfSeg) ? smallHalf : -largeHalf;
 34591:     }
 34591:   }
 34591:   return nsPresContext::CSSPixelsToAppUnits(offset);
 34591: }
 34591: 
 34591: /** Compute the horizontal offset of a horizontal border segment
 34591:   * @param aCornerOwnerSide - which side owns the corner
 34591:   * @param aCornerSubWidth  - how wide is the nonwinning side of the corner
 34591:   * @param aVerWidth        - how wide is the vertical edge of the corner
 34591:   * @param aIsStartOfSeg    - does this corner start a new segment
 34591:   * @param aIsBevel         - is this corner beveled
 34591:   * @param aTableIsLTR      - direction, the computation depends on ltr or rtl
 34593:   * @return                 - offset in twips
 34587:   */
 34591: static nscoord
 41419: CalcHorCornerOffset(mozilla::css::Side aCornerOwnerSide,
 34593:                     BCPixelSize aCornerSubWidth,
 34593:                     BCPixelSize aVerWidth,
 79445:                     bool        aIsStartOfSeg,
 79445:                     bool        aIsBevel,
 79445:                     bool        aTableIsLTR)
 34591: {
 34591:   nscoord offset = 0;
 34593:   // XXX These should be replaced with appropriate side-specific macros (which?)
 34593:   BCPixelSize smallHalf, largeHalf;
 34593:   if ((NS_SIDE_LEFT == aCornerOwnerSide) ||
 34593:       (NS_SIDE_RIGHT == aCornerOwnerSide)) {
 34591:     if (aTableIsLTR) {
 34591:       DivideBCBorderSize(aCornerSubWidth, smallHalf, largeHalf);
 34591:     }
 34591:     else {
 34591:       DivideBCBorderSize(aCornerSubWidth, largeHalf, smallHalf);
 34591:     }
 34591:     if (aIsBevel) {
 34591:       offset = (aIsStartOfSeg) ? -largeHalf : smallHalf;
 34591:     }
 34591:     else {
 34591:       offset = (NS_SIDE_LEFT == aCornerOwnerSide) ? smallHalf : -largeHalf;
 34591:     }
 34591:   }
 34591:   else {
 34591:     if (aTableIsLTR) {
 34591:       DivideBCBorderSize(aVerWidth, smallHalf, largeHalf);
 34591:     }
 34591:     else {
 34591:       DivideBCBorderSize(aVerWidth, largeHalf, smallHalf);
 34591:     }
 34591:     if (aIsBevel) {
 34591:       offset = (aIsStartOfSeg) ? -largeHalf : smallHalf;
 34591:     }
 34591:     else {
 34591:       offset = (aIsStartOfSeg) ? smallHalf : -largeHalf;
 34591:     }
 34591:   }
 34591:   return nsPresContext::CSSPixelsToAppUnits(offset);
 34591: }
 34591: 
 34593: BCVerticalSeg::BCVerticalSeg()
 34593: {
106838:   mCol = nullptr;
106838:   mFirstCell = mLastCell = mAjaCell = nullptr;
 41419:   mOffsetX = mOffsetY = mLength = mWidth = mTopBevelOffset = 0;
 41419:   mTopBevelSide = NS_SIDE_TOP;
 34593:   mOwner = eCellOwner;
 34593: }
 34593: 
 34593: /**
 34593:  * Start a new vertical segment
 34593:  * @param aIter         - iterator containing the structural information
 34593:  * @param aBorderOwner  - determines the border style
 34593:  * @param aVerSegWidth  - the width of segment in pixel
 34593:  * @param aHorSegHeight - the width of the horizontal segment joining the corner
 34593:  *                        at the start
 34593:  */
 34593: void
 34593: BCVerticalSeg::Start(BCPaintBorderIterator& aIter,
 34591:                      BCBorderOwner          aBorderOwner,
 34593:                      BCPixelSize            aVerSegWidth,
 34593:                      BCPixelSize            aHorSegHeight)
 34591: {
 41419:   mozilla::css::Side ownerSide   = NS_SIDE_TOP;
 79445:   bool bevel       = false;
 34593: 
 34593: 
 34593:   nscoord cornerSubWidth  = (aIter.mBCData) ?
 34593:                                aIter.mBCData->GetCorner(ownerSide, bevel) : 0;
 34593: 
 79445:   bool    topBevel        = (aVerSegWidth > 0) ? bevel : false;
 71173:   BCPixelSize maxHorSegHeight = NS_MAX(aIter.mPrevHorSegHeight, aHorSegHeight);
 34593:   nscoord offset          = CalcVerCornerOffset(ownerSide, cornerSubWidth,
 80486:                                                 maxHorSegHeight, true,
 34593:                                                 topBevel);
 34593: 
 87904:   mTopBevelOffset = topBevel ?
 34593:     nsPresContext::CSSPixelsToAppUnits(maxHorSegHeight): 0;
 34593:   // XXX this assumes that only corners where 2 segments join can be beveled
 34593:   mTopBevelSide     = (aHorSegHeight > 0) ? NS_SIDE_RIGHT : NS_SIDE_LEFT;
 34593:   mOffsetY      += offset;
 34593:   mLength        = -offset;
 34593:   mWidth         = aVerSegWidth;
 34593:   mOwner         = aBorderOwner;
 34593:   mFirstCell     = aIter.mCell;
 34593:   mFirstRowGroup = aIter.mRg;
 34593:   mFirstRow      = aIter.mRow;
 34593:   if (aIter.GetRelativeColIndex() > 0) {
 34593:     mAjaCell = aIter.mVerInfo[aIter.GetRelativeColIndex() - 1].mLastCell;
 34593:   }
 34593: }
 34593: 
 34593: /**
 34593:  * Initialize the vertical segments with information that will persist for any
 34593:  * vertical segment in this column
 34593:  * @param aIter - iterator containing the structural information
 34591:  */
 34591: void
 34593: BCVerticalSeg::Initialize(BCPaintBorderIterator& aIter)
 34593: {
108991:   int32_t relColIndex = aIter.GetRelativeColIndex();
 34593:   mCol = aIter.IsTableRightMost() ? aIter.mVerInfo[relColIndex - 1].mCol :
 34593:            aIter.mTableFirstInFlow->GetColFrame(aIter.mColIndex);
 34593:   if (!mCol) ABORT0();
 34593:   if (0 == relColIndex) {
 34593:     mOffsetX = aIter.mInitialOffsetX;
 34593:   }
 34593:   // set colX for the next column
 34593:   if (!aIter.IsDamageAreaRightMost()) {
 34593:     aIter.mVerInfo[relColIndex + 1].mOffsetX = mOffsetX +
 34593:                                          aIter.mColInc * mCol->GetSize().width;
 34593:   }
 34593:   mOffsetY = aIter.mInitialOffsetY;
 34593:   mLastCell = aIter.mCell;
 34593: }
 34593: 
 34593: /**
 34593:  * Compute the offsets for the bottom corner of a vertical segment
 34593:  * @param aIter         - iterator containing the structural information
 34593:  * @param aHorSegHeight - the width of the horizontal segment joining the corner
 34593:  *                        at the start
 34593:  */
 34591: void
 34593: BCVerticalSeg::GetBottomCorner(BCPaintBorderIterator& aIter,
 34593:                                BCPixelSize            aHorSegHeight)
 34593: {
 41419:    mozilla::css::Side ownerSide = NS_SIDE_TOP;
 34593:    nscoord cornerSubWidth = 0;
 79445:    bool bevel = false;
 34593:    if (aIter.mBCData) {
 34593:      cornerSubWidth = aIter.mBCData->GetCorner(ownerSide, bevel);
 34593:    }
 80486:    mIsBottomBevel = (mWidth > 0) ? bevel : false;
 71173:    mBottomHorSegHeight = NS_MAX(aIter.mPrevHorSegHeight, aHorSegHeight);
 34593:    mBottomOffset = CalcVerCornerOffset(ownerSide, cornerSubWidth,
 34593:                                     mBottomHorSegHeight,
 80486:                                     false, mIsBottomBevel);
 34593:    mLength += mBottomOffset;
 34593: }
 34593: 
 34593: /**
 34593:  * Paint the vertical segment
 34593:  * @param aIter         - iterator containing the structural information
 34593:  * @param aRenderingContext - the rendering context
 34593:  * @param aHorSegHeight - the width of the horizontal segment joining the corner
 34593:  *                        at the start
 34593:  */
 34593: void
 34593: BCVerticalSeg::Paint(BCPaintBorderIterator& aIter,
 68481:                      nsRenderingContext&   aRenderingContext,
 34593:                      BCPixelSize            aHorSegHeight)
 34593: {
     1:   // get the border style, color and paint the segment
 41419:   mozilla::css::Side side = (aIter.IsDamageAreaRightMost()) ? NS_SIDE_RIGHT :
 34593:                                                     NS_SIDE_LEFT;
108991:   int32_t relColIndex = aIter.GetRelativeColIndex();
 34593:   nsTableColFrame* col           = mCol; if (!col) ABORT0();
 34593:   nsTableCellFrame* cell         = mFirstCell; // ???
106838:   nsIFrame* owner = nullptr;
108991:   uint8_t style = NS_STYLE_BORDER_STYLE_SOLID;
     1:   nscolor color = 0xFFFFFFFF;
 34593: 
 34593:   switch (mOwner) {
     1:     case eTableOwner:
 36972:       owner = aIter.mTable;
     1:       break;
     1:     case eAjaColGroupOwner:
     1:       side = NS_SIDE_RIGHT;
 34593:       if (!aIter.IsTableRightMost() && (relColIndex > 0)) {
 34593:         col = aIter.mVerInfo[relColIndex - 1].mCol;
     1:       } // and fall through
     1:     case eColGroupOwner:
     1:       if (col) {
 36972:         owner = col->GetParent();
     1:       }
     1:       break;
     1:     case eAjaColOwner:
     1:       side = NS_SIDE_RIGHT;
 34593:       if (!aIter.IsTableRightMost() && (relColIndex > 0)) {
 34593:         col = aIter.mVerInfo[relColIndex - 1].mCol;
     1:       } // and fall through
     1:     case eColOwner:
 36972:       owner = col;
     1:       break;
     1:     case eAjaRowGroupOwner:
 34593:       NS_ERROR("a neighboring rowgroup can never own a vertical border");
 34593:       // and fall through
     1:     case eRowGroupOwner:
 34593:       NS_ASSERTION(aIter.IsTableLeftMost() || aIter.IsTableRightMost(),
 34593:                   "row group can own border only at table edge");
 36972:       owner = mFirstRowGroup;
     1:       break;
     1:     case eAjaRowOwner:
 80486:       NS_ASSERTION(false, "program error"); // and fall through
     1:     case eRowOwner:
 34593:       NS_ASSERTION(aIter.IsTableLeftMost() || aIter.IsTableRightMost(),
 34593:                    "row can own border only at table edge");
 36972:       owner = mFirstRow;
     1:       break;
     1:     case eAjaCellOwner:
     1:       side = NS_SIDE_RIGHT;
 34593:       cell = mAjaCell; // and fall through
     1:     case eCellOwner:
 36972:       owner = cell;
     1:       break;
     1:   }
 36972:   if (owner) {
 36972:     ::GetPaintStyleInfo(owner, side, style, color, aIter.mTableIsLTR);
 36972:   }
 34593:   BCPixelSize smallHalf, largeHalf;
 34593:   DivideBCBorderSize(mWidth, smallHalf, largeHalf);
 34593:   nsRect segRect(mOffsetX - nsPresContext::CSSPixelsToAppUnits(largeHalf),
 34593:                  mOffsetY,
 34593:                  nsPresContext::CSSPixelsToAppUnits(mWidth), mLength);
 34593:   nscoord bottomBevelOffset = (mIsBottomBevel) ?
 34593:                   nsPresContext::CSSPixelsToAppUnits(mBottomHorSegHeight) : 0;
 41419:   mozilla::css::Side bottomBevelSide = ((aHorSegHeight > 0) ^ !aIter.mTableIsLTR) ?
 34593:                             NS_SIDE_RIGHT : NS_SIDE_LEFT;
 41419:   mozilla::css::Side topBevelSide = ((mTopBevelSide == NS_SIDE_RIGHT) ^ !aIter.mTableIsLTR)?
 34593:                          NS_SIDE_RIGHT : NS_SIDE_LEFT;
 34593:   nsCSSRendering::DrawTableBorderSegment(aRenderingContext, style, color,
 34593:                                          aIter.mTableBgColor, segRect,
 34593:                                          nsPresContext::AppUnitsPerCSSPixel(),
 34593:                                          topBevelSide, mTopBevelOffset,
     1:                                          bottomBevelSide, bottomBevelOffset);
 34593: }
 34593: 
 34593: /**
 34593:  * Advance the start point of a segment
 34593:  */
 34593: void
 34593: BCVerticalSeg::AdvanceOffsetY()
 34593: {
 34593:   mOffsetY +=  mLength - mBottomOffset;
 34593: }
 34593: 
 34593: /**
 34593:  * Accumulate the current segment
 34593:  */
 34593: void
 34593: BCVerticalSeg::IncludeCurrentBorder(BCPaintBorderIterator& aIter)
 34593: {
 34593:   mLastCell = aIter.mCell;
 34593:   mLength  += aIter.mRow->GetRect().height;
 34593: }
 34593: 
 34593: BCHorizontalSeg::BCHorizontalSeg()
 34593: {
 34593:   mOffsetX = mOffsetY = mLength = mWidth =  mLeftBevelOffset = 0;
 41419:   mLeftBevelSide = NS_SIDE_TOP;
106838:   mFirstCell = mAjaCell = nullptr;
 34593: }
 34593: 
 34593: /** Initialize a horizontal border segment for painting
 34593:   * @param aIter              - iterator storing the current and adjacent frames
 34593:   * @param aBorderOwner       - which frame owns the border
 34593:   * @param aBottomVerSegWidth - vertical segment width coming from up
 34593:   * @param aHorSegHeight      - the height of the segment
 34593:   +  */
 34593: void
 34593: BCHorizontalSeg::Start(BCPaintBorderIterator& aIter,
 34593:                        BCBorderOwner        aBorderOwner,
 34593:                        BCPixelSize          aBottomVerSegWidth,
 34593:                        BCPixelSize          aHorSegHeight)
 34593: {
 41419:   mozilla::css::Side cornerOwnerSide = NS_SIDE_TOP;
 79445:   bool bevel     = false;
 34593: 
 34593:   mOwner = aBorderOwner;
 34593:   nscoord cornerSubWidth  = (aIter.mBCData) ?
 34593:                              aIter.mBCData->GetCorner(cornerOwnerSide,
 34593:                                                        bevel) : 0;
 34593: 
 79445:   bool    leftBevel = (aHorSegHeight > 0) ? bevel : false;
108991:   int32_t relColIndex = aIter.GetRelativeColIndex();
 71173:   nscoord maxVerSegWidth = NS_MAX(aIter.mVerInfo[relColIndex].mWidth,
 34593:                                   aBottomVerSegWidth);
 34593:   nscoord offset = CalcHorCornerOffset(cornerOwnerSide, cornerSubWidth,
 80486:                                        maxVerSegWidth, true, leftBevel,
 34593:                                        aIter.mTableIsLTR);
 34593:   mLeftBevelOffset = (leftBevel && (aHorSegHeight > 0)) ? maxVerSegWidth : 0;
 34593:   // XXX this assumes that only corners where 2 segments join can be beveled
 34593:   mLeftBevelSide   = (aBottomVerSegWidth > 0) ? NS_SIDE_BOTTOM : NS_SIDE_TOP;
 34593:   if (aIter.mTableIsLTR) {
 34593:     mOffsetX += offset;
     1:   }
     1:   else {
 34593:     mOffsetX -= offset;
 34593:   }
 34593:   mLength          = -offset;
 34593:   mWidth           = aHorSegHeight;
 34593:   mFirstCell       = aIter.mCell;
106838:   mAjaCell         = (aIter.IsDamageAreaTopMost()) ? nullptr :
 34593:                      aIter.mVerInfo[relColIndex].mLastCell;
 34593: }
 34593: 
 34593: /**
 34593:  * Compute the offsets for the right corner of a horizontal segment
 34593:  * @param aIter         - iterator containing the structural information
 34593:  * @param aLeftSegWidth - the width of the vertical segment joining the corner
 34593:  *                        at the start
 34593:  */
 34593: void
 34593: BCHorizontalSeg::GetRightCorner(BCPaintBorderIterator& aIter,
 34593:                                 BCPixelSize            aLeftSegWidth)
 34593: {
 41419:   mozilla::css::Side ownerSide = NS_SIDE_TOP;
 34593:   nscoord cornerSubWidth = 0;
 79445:   bool bevel = false;
 34593:   if (aIter.mBCData) {
 34593:     cornerSubWidth = aIter.mBCData->GetCorner(ownerSide, bevel);
 34593:   }
 34593: 
 34593:   mIsRightBevel = (mWidth > 0) ? bevel : 0;
108991:   int32_t relColIndex = aIter.GetRelativeColIndex();
 71173:   nscoord verWidth = NS_MAX(aIter.mVerInfo[relColIndex].mWidth, aLeftSegWidth);
 34593:   mEndOffset = CalcHorCornerOffset(ownerSide, cornerSubWidth, verWidth,
 80486:                                    false, mIsRightBevel, aIter.mTableIsLTR);
 34593:   mLength += mEndOffset;
 34593:   mRightBevelOffset = (mIsRightBevel) ?
 34593:                        nsPresContext::CSSPixelsToAppUnits(verWidth) : 0;
 34593:   mRightBevelSide = (aLeftSegWidth > 0) ? NS_SIDE_BOTTOM : NS_SIDE_TOP;
 34593: }
 34593: 
 34593: /**
 34593:  * Paint the horizontal segment
 34593:  * @param aIter         - iterator containing the structural information
 34593:  * @param aRenderingContext - the rendering context
 34593:  */
 34593: void
 34593: BCHorizontalSeg::Paint(BCPaintBorderIterator& aIter,
 68481:                        nsRenderingContext&   aRenderingContext)
 34593: {
     1:   // get the border style, color and paint the segment
 41419:   mozilla::css::Side side = (aIter.IsDamageAreaBottomMost()) ? NS_SIDE_BOTTOM :
 34593:                                                      NS_SIDE_TOP;
 34593:   nsIFrame* rg   = aIter.mRg;  if (!rg) ABORT0();
 34593:   nsIFrame* row  = aIter.mRow; if (!row) ABORT0();
 39021:   nsIFrame* cell = mFirstCell;
     1:   nsIFrame* col;
106838:   nsIFrame* owner = nullptr;
     1: 
108991:   uint8_t style = NS_STYLE_BORDER_STYLE_SOLID;
     1:   nscolor color = 0xFFFFFFFF;
 36972: 
 34593: 
 34593:   switch (mOwner) {
     1:     case eTableOwner:
 36972:       owner = aIter.mTable;
     1:       break;
     1:     case eAjaColGroupOwner:
 34593:       NS_ERROR("neighboring colgroups can never own a horizontal border");
 34593:       // and fall through
 36972:     case eColGroupOwner:
 34593:       NS_ASSERTION(aIter.IsTableTopMost() || aIter.IsTableBottomMost(),
 34593:                    "col group can own border only at the table edge");
 34593:       col = aIter.mTableFirstInFlow->GetColFrame(aIter.mColIndex - 1);
 34593:       if (!col) ABORT0();
 36972:       owner = col->GetParent();
     1:       break;
     1:     case eAjaColOwner:
 34593:       NS_ERROR("neighboring column can never own a horizontal border");
 34593:       // and fall through
     1:     case eColOwner:
 34593:       NS_ASSERTION(aIter.IsTableTopMost() || aIter.IsTableBottomMost(),
 34593:                    "col can own border only at the table edge");
 36972:       owner = aIter.mTableFirstInFlow->GetColFrame(aIter.mColIndex - 1);
     1:       break;
     1:     case eAjaRowGroupOwner:
     1:       side = NS_SIDE_BOTTOM;
 34593:       rg = (aIter.IsTableBottomMost()) ? aIter.mRg : aIter.mPrevRg;
 34593:       // and fall through
     1:     case eRowGroupOwner:
 36972:       owner = rg;
     1:       break;
     1:     case eAjaRowOwner:
     1:       side = NS_SIDE_BOTTOM;
 34593:       row = (aIter.IsTableBottomMost()) ? aIter.mRow : aIter.mPrevRow;
 34593:       // and fall through
     1:       case eRowOwner:
 36972:       owner = row;
     1:       break;
     1:     case eAjaCellOwner:
     1:       side = NS_SIDE_BOTTOM;
 34593:       // if this is null due to the damage area origin-y > 0, then the border
 34593:       // won't show up anyway
 34593:       cell = mAjaCell;
     1:       // and fall through
     1:     case eCellOwner:
 36972:       owner = cell;
     1:       break;
     1:   }
 36972:   if (owner) {
 36972:     ::GetPaintStyleInfo(owner, side, style, color, aIter.mTableIsLTR);
 36972:   }
 34593:   BCPixelSize smallHalf, largeHalf;
 34593:   DivideBCBorderSize(mWidth, smallHalf, largeHalf);
 34593:   nsRect segRect(mOffsetX,
 34593:                  mOffsetY - nsPresContext::CSSPixelsToAppUnits(largeHalf),
 34593:                  mLength,
 34593:                  nsPresContext::CSSPixelsToAppUnits(mWidth));
 34593:   if (aIter.mTableIsLTR) {
 34593:     nsCSSRendering::DrawTableBorderSegment(aRenderingContext, style, color,
 34593:                                            aIter.mTableBgColor, segRect,
 34593:                                            nsPresContext::AppUnitsPerCSSPixel(),
 34593:                                            mLeftBevelSide,
 34593:                                            nsPresContext::CSSPixelsToAppUnits(mLeftBevelOffset),
 34593:                                            mRightBevelSide, mRightBevelOffset);
 34593:   }
 34593:   else {
 34591:     segRect.x -= segRect.width;
 34593:     nsCSSRendering::DrawTableBorderSegment(aRenderingContext, style, color,
 34593:                                            aIter.mTableBgColor, segRect,
 34593:                                            nsPresContext::AppUnitsPerCSSPixel(),
 34593:                                            mRightBevelSide, mRightBevelOffset,
 34593:                                            mLeftBevelSide,
 34593:                                            nsPresContext::CSSPixelsToAppUnits(mLeftBevelOffset));
 34593:   }
 34593: }
 34593: 
 34593: /**
 34593:  * Advance the start point of a segment
 34593:  */
 34593: void
108991: BCHorizontalSeg::AdvanceOffsetX(int32_t aIncrement)
 34593: {
 34593:   mOffsetX += aIncrement * (mLength - mEndOffset);
 34593: }
 34593: 
 34593: /**
 34593:  * Accumulate the current segment
 34593:  */
 34593: void
 34593: BCHorizontalSeg::IncludeCurrentBorder(BCPaintBorderIterator& aIter)
 34593: {
 34593:   mLength += aIter.mVerInfo[aIter.GetRelativeColIndex()].mColWidth;
 34593: }
 34593: 
 34593: /**
 34593:  * store the column width information while painting horizontal segment
 34593:  */
 34593: void
108991: BCPaintBorderIterator::StoreColumnWidth(int32_t aIndex)
 34593: {
 34593:   if (IsTableRightMost()) {
 34593:       mVerInfo[aIndex].mColWidth = mVerInfo[aIndex - 1].mColWidth;
 34587:   }
 34587:   else {
 34593:     nsTableColFrame* col = mTableFirstInFlow->GetColFrame(mColIndex);
 34593:     if (!col) ABORT0();
 34593:     mVerInfo[aIndex].mColWidth = col->GetSize().width;
 34593:   }
 34593: }
 34593: /**
 34593:  * Determine if a vertical segment owns the corder
 34593:  */
 79445: bool
 34593: BCPaintBorderIterator::VerticalSegmentOwnsCorner()
 34593: {
 41419:   mozilla::css::Side cornerOwnerSide = NS_SIDE_TOP;
 79445:   bool bevel = false;
 85981:   if (mBCData) {
 85981:     mBCData->GetCorner(cornerOwnerSide, bevel);
 85981:   }
 34593:   // unitialized ownerside, bevel
 34593:   return  (NS_SIDE_TOP == cornerOwnerSide) ||
 34593:           (NS_SIDE_BOTTOM == cornerOwnerSide);
 34593: }
 34593: 
 34593: /**
 34593:  * Paint if necessary a horizontal segment, otherwise accumulate it
 34593:  * @param aRenderingContext - the rendering context
 34593:  */
 34593: void
 68481: BCPaintBorderIterator::AccumulateOrPaintHorizontalSegment(nsRenderingContext& aRenderingContext)
 34593: {
 34593: 
108991:   int32_t relColIndex = GetRelativeColIndex();
 34593:   // store the current col width if it hasn't been already
 34593:   if (mVerInfo[relColIndex].mColWidth < 0) {
 34593:     StoreColumnWidth(relColIndex);
 34593:   }
 34593: 
 34593:   BCBorderOwner borderOwner = eCellOwner;
 34593:   BCBorderOwner ignoreBorderOwner;
 79445:   bool isSegStart = true;
 79445:   bool ignoreSegStart;
 34593: 
 87904:   nscoord leftSegWidth =
 87904:     mBCData ? mBCData->GetLeftEdge(ignoreBorderOwner, ignoreSegStart) : 0;
 87904:   nscoord topSegHeight =
 87904:     mBCData ? mBCData->GetTopEdge(borderOwner, isSegStart) : 0;
 34593: 
 34593:   if (mIsNewRow || (IsDamageAreaLeftMost() && IsDamageAreaBottomMost())) {
 34593:     // reset for every new row and on the bottom of the last row
 34593:     mHorSeg.mOffsetY = mNextOffsetY;
 34593:     mNextOffsetY     = mNextOffsetY + mRow->GetSize().height;
 34593:     mHorSeg.mOffsetX = mInitialOffsetX;
 34593:     mHorSeg.Start(*this, borderOwner, leftSegWidth, topSegHeight);
 34593:   }
 34593: 
 34593:   if (!IsDamageAreaLeftMost() && (isSegStart || IsDamageAreaRightMost() ||
 34593:                                   VerticalSegmentOwnsCorner())) {
 34593:     // paint the previous seg or the current one if IsDamageAreaRightMost()
 34593:     if (mHorSeg.mLength > 0) {
 34593:       mHorSeg.GetRightCorner(*this, leftSegWidth);
 34593:       if (mHorSeg.mWidth > 0) {
 34593:         mHorSeg.Paint(*this, aRenderingContext);
 34593:       }
 34593:       mHorSeg.AdvanceOffsetX(mColInc);
 34593:     }
 34593:     mHorSeg.Start(*this, borderOwner, leftSegWidth, topSegHeight);
 34593:   }
 34593:   mHorSeg.IncludeCurrentBorder(*this);
 34593:   mVerInfo[relColIndex].mWidth = leftSegWidth;
 34593:   mVerInfo[relColIndex].mLastCell = mCell;
 34593: }
 34593: /**
 34593:  * Paint if necessary a vertical segment, otherwise  it
 34593:  * @param aRenderingContext - the rendering context
 34593:  */
 34593: void
 68481: BCPaintBorderIterator::AccumulateOrPaintVerticalSegment(nsRenderingContext& aRenderingContext)
 34593: {
 34593:   BCBorderOwner borderOwner = eCellOwner;
 34593:   BCBorderOwner ignoreBorderOwner;
 79445:   bool isSegStart = true;
 79445:   bool ignoreSegStart;
 34593: 
 87904:   nscoord verSegWidth  =
 87904:     mBCData ? mBCData->GetLeftEdge(borderOwner, isSegStart) : 0;
 87904:   nscoord horSegHeight =
 87904:     mBCData ? mBCData->GetTopEdge(ignoreBorderOwner, ignoreSegStart) : 0;
 34593: 
108991:   int32_t relColIndex = GetRelativeColIndex();
 34593:   BCVerticalSeg& verSeg = mVerInfo[relColIndex];
 34593:   if (!verSeg.mCol) { // on the first damaged row and the first segment in the
 34593:                       // col
 34593:     verSeg.Initialize(*this);
 34593:     verSeg.Start(*this, borderOwner, verSegWidth, horSegHeight);
 34593:   }
 34593: 
 34593:   if (!IsDamageAreaTopMost() && (isSegStart || IsDamageAreaBottomMost() ||
 34593:                                  IsAfterRepeatedHeader() ||
 34593:                                  StartRepeatedFooter())) {
 34593:     // paint the previous seg or the current one if IsDamageAreaBottomMost()
 34593:     if (verSeg.mLength > 0) {
 34593:       verSeg.GetBottomCorner(*this, horSegHeight);
 34593:       if (verSeg.mWidth > 0) {
 34593:         verSeg.Paint(*this, aRenderingContext, horSegHeight);
 34593:       }
 34593:       verSeg.AdvanceOffsetY();
 34593:     }
 34593:     verSeg.Start(*this, borderOwner, verSegWidth, horSegHeight);
 34593:   }
 34593:   verSeg.IncludeCurrentBorder(*this);
 34593:   mPrevHorSegHeight = horSegHeight;
 34593: }
 34593: 
 34593: /**
 34593:  * Reset the vertical information cache
 34593:  */
 34593: void
 34593: BCPaintBorderIterator::ResetVerInfo()
 34593: {
 34593:   if (mVerInfo) {
 34593:     memset(mVerInfo, 0, mDamageArea.width * sizeof(BCVerticalSeg));
 34593:     // XXX reinitialize properly
108991:     for (int32_t xIndex = 0; xIndex < mDamageArea.width; xIndex++) {
 34593:       mVerInfo[xIndex].mColWidth = -1;
 34593:     }
 34593:   }
 34593: }
 34593: 
 34593: /**
 34593:  * Method to paint BCBorders, this does not use currently display lists although
 34593:  * it will do this in future
 34593:  * @param aRenderingContext - the rendering context
 34593:  * @param aDirtyRect        - inside this rectangle the BC Borders will redrawn
 34593:  */
 34593: void
 68481: nsTableFrame::PaintBCBorders(nsRenderingContext& aRenderingContext,
 34593:                              const nsRect&        aDirtyRect)
 34593: {
 34593:   // We first transfer the aDirtyRect into cellmap coordinates to compute which
 34593:   // cell borders need to be painted
 34593:   BCPaintBorderIterator iter(this);
 34593:   if (!iter.SetDamageArea(aDirtyRect))
 34593:     return;
 34593: 
 34593:   // First, paint all of the vertical borders from top to bottom and left to
 34593:   // right as they become complete. They are painted first, since they are less
 34593:   // efficient to paint than horizontal segments. They were stored with as few
 34593:   // segments as possible (since horizontal borders are painted last and
 34593:   // possibly over them). For every cell in a row that fails in the damage are
 34593:   // we look up if the current border would start a new segment, if so we paint
 34593:   // the previously stored vertical segment and start a new segment. After
 34593:   // this we  the now active segment with the current border. These
 34593:   // segments are stored in mVerInfo to be used on the next row
 34593:   for (iter.First(); !iter.mAtEnd; iter.Next()) {
 34593:     iter.AccumulateOrPaintVerticalSegment(aRenderingContext);
 34593:   }
 34593: 
 34593:   // Next, paint all of the horizontal border segments from top to bottom reuse
 34593:   // the mVerInfo array to keep track of col widths and vertical segments for
 34593:   // corner calculations
 34593:   iter.Reset();
 34593:   for (iter.First(); !iter.mAtEnd; iter.Next()) {
 34593:     iter.AccumulateOrPaintHorizontalSegment(aRenderingContext);
 34593:   }
     1: }
     1: 
108991: bool nsTableFrame::RowHasSpanningCells(int32_t aRowIndex, int32_t aNumEffCols)
 79445: {
 79445:   bool result = false;
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   NS_PRECONDITION (cellMap, "bad call, cellMap not yet allocated.");
     1:   if (cellMap) {
     1:     result = cellMap->RowHasSpanningCells(aRowIndex, aNumEffCols);
     1:   }
     1:   return result;
     1: }
     1: 
108991: bool nsTableFrame::RowIsSpannedInto(int32_t aRowIndex, int32_t aNumEffCols)
 79445: {
 79445:   bool result = false;
     1:   nsTableCellMap* cellMap = GetCellMap();
     1:   NS_PRECONDITION (cellMap, "bad call, cellMap not yet allocated.");
     1:   if (cellMap) {
     1:     result = cellMap->RowIsSpannedInto(aRowIndex, aNumEffCols);
     1:   }
     1:   return result;
     1: }
115328: 
115328: /* static */
115328: void
115328: nsTableFrame::InvalidateTableFrame(nsIFrame* aFrame,
115328:                                    const nsRect& aOrigRect,
115328:                                    const nsRect& aOrigVisualOverflow,
115328:                                    bool aIsFirstReflow)
115328: {
115328:   nsIFrame* parent = aFrame->GetParent();
115328:   NS_ASSERTION(parent, "What happened here?");
115328: 
115328:   if (parent->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
115328:     // Don't bother; we'll invalidate the parent's overflow rect when
115328:     // we finish reflowing it.
115328:     return;
115328:   }
115328: 
115328:   // The part that looks at both the rect and the overflow rect is a
115328:   // bit of a hack.  See nsBlockFrame::ReflowLine for an eloquent
115328:   // description of its hackishness.
115328:   //
115328:   // This doesn't really make sense now that we have DLBI.
115328:   // This code can probably be simplified a fair bit.
115328:   nsRect visualOverflow = aFrame->GetVisualOverflowRect();
115328:   if (aIsFirstReflow ||
115328:       aOrigRect.TopLeft() != aFrame->GetPosition() ||
115328:       aOrigVisualOverflow.TopLeft() != visualOverflow.TopLeft()) {
115328:     // Invalidate the old and new overflow rects.  Note that if the
115328:     // frame moved, we can't just use aOrigVisualOverflow, since it's in
115328:     // coordinates relative to the old position.  So invalidate via
115328:     // aFrame's parent, and reposition that overflow rect to the right
115328:     // place.
115328:     // XXXbz this doesn't handle outlines, does it?
115328:     aFrame->InvalidateFrame();
115328:     parent->InvalidateFrameWithRect(aOrigVisualOverflow + aOrigRect.TopLeft());
125547:   } else if (aOrigRect.Size() != aFrame->GetSize() ||
125547:              aOrigVisualOverflow.Size() != visualOverflow.Size()){
125547:     aFrame->InvalidateFrameWithRect(aOrigVisualOverflow);
115328:     aFrame->InvalidateFrame();
115328:     parent->InvalidateFrameWithRect(aOrigRect);;
115328:     parent->InvalidateFrame();
115328:   }
115328: }
