 76059: //* -*- Mode: c++; c-basic-offset: 4; tab-width: 40; indent-tabs-mode: nil -*- */
 75615: /* vim: set ts=40 sw=4 et tw=99: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 75615: 
 75615: /* Definitions related to javascript type inference. */
 75615: 
 75615: #ifndef jsinfer_h___
 75615: #define jsinfer_h___
 75615: 
 76185: #include "jsalloc.h"
 79734: #include "jsfriendapi.h"
 75615: #include "jsprvtd.h"
 75615: 
 79410: #include "ds/LifoAlloc.h"
 82129: #include "gc/Barrier.h"
 97570: #include "gc/Heap.h"
 80202: #include "js/HashTable.h"
 75615: 
 88579: namespace JS {
 88579: struct TypeInferenceSizes;
 88579: }
 88579: 
 75615: namespace js {
 75615: namespace types {
 75615: 
 77353: /* Type set entry for either a JSObject with singleton type or a non-singleton TypeObject. */
 77353: struct TypeObjectKey {
 77353:     static intptr_t keyBits(TypeObjectKey *obj) { return (intptr_t) obj; }
 77353:     static TypeObjectKey *getKey(TypeObjectKey *obj) { return obj; }
 77353: };
 75615: 
 75615: /*
 77361:  * Information about a single concrete type. We pack this into a single word,
 77361:  * where small values are particular primitive or other singleton types, and
 77361:  * larger values are either specific JS objects or type objects.
 75615:  */
 77353: class Type
 77353: {
 86976:     uintptr_t data;
 86976:     Type(uintptr_t data) : data(data) {}
 75615: 
 77353:   public:
 75615: 
 86976:     uintptr_t raw() const { return data; }
 75615: 
 77353:     bool isPrimitive() const {
 77353:         return data < JSVAL_TYPE_OBJECT;
 75615:     }
 75615: 
 77353:     bool isPrimitive(JSValueType type) const {
 77353:         JS_ASSERT(type < JSVAL_TYPE_OBJECT);
 86976:         return (uintptr_t) type == data;
 75615:     }
 75615: 
 77353:     JSValueType primitive() const {
 77353:         JS_ASSERT(isPrimitive());
 77353:         return (JSValueType) data;
 77353:     }
 77353: 
 77353:     bool isAnyObject() const {
 77353:         return data == JSVAL_TYPE_OBJECT;
 77353:     }
 77353: 
 77353:     bool isUnknown() const {
 77353:         return data == JSVAL_TYPE_UNKNOWN;
 77353:     }
 77353: 
 77353:     /* Accessors for types that are either JSObject or TypeObject. */
 77353: 
 77353:     bool isObject() const {
 77353:         JS_ASSERT(!isAnyObject() && !isUnknown());
 77353:         return data > JSVAL_TYPE_UNKNOWN;
 77353:     }
 77353: 
 97880:     inline TypeObjectKey *objectKey() const;
 77353: 
 77353:     /* Accessors for JSObject types */
 77353: 
 77353:     bool isSingleObject() const {
 77353:         return isObject() && !!(data & 1);
 77353:     }
 77353: 
 97880:     inline JSObject *singleObject() const;
 77353: 
 77353:     /* Accessors for TypeObject types */
 77353: 
 77353:     bool isTypeObject() const {
 77353:         return isObject() && !(data & 1);
 77353:     }
 77353: 
 97880:     inline TypeObject *typeObject() const;
 77353: 
 77353:     bool operator == (Type o) const { return data == o.data; }
 77353:     bool operator != (Type o) const { return data != o.data; }
 77353: 
 77353:     static inline Type UndefinedType() { return Type(JSVAL_TYPE_UNDEFINED); }
 77353:     static inline Type NullType()      { return Type(JSVAL_TYPE_NULL); }
 77353:     static inline Type BooleanType()   { return Type(JSVAL_TYPE_BOOLEAN); }
 77353:     static inline Type Int32Type()     { return Type(JSVAL_TYPE_INT32); }
 77353:     static inline Type DoubleType()    { return Type(JSVAL_TYPE_DOUBLE); }
 77353:     static inline Type StringType()    { return Type(JSVAL_TYPE_STRING); }
 95100:     static inline Type MagicArgType()  { return Type(JSVAL_TYPE_MAGIC); }
 77353:     static inline Type AnyObjectType() { return Type(JSVAL_TYPE_OBJECT); }
 77353:     static inline Type UnknownType()   { return Type(JSVAL_TYPE_UNKNOWN); }
 77353: 
 77353:     static inline Type PrimitiveType(JSValueType type) {
 77353:         JS_ASSERT(type < JSVAL_TYPE_UNKNOWN);
 77353:         return Type(type);
 77353:     }
 77353: 
 77353:     static inline Type ObjectType(JSObject *obj);
 77353:     static inline Type ObjectType(TypeObject *obj);
 77353:     static inline Type ObjectType(TypeObjectKey *obj);
 77353: };
 77353: 
 75615: /* Get the type of a jsval, or zero for an unknown special value. */
 77353: inline Type GetValueType(JSContext *cx, const Value &val);
 75615: 
 75615: /*
 75718:  * Type inference memory management overview.
 75718:  *
 75718:  * Inference constructs a global web of constraints relating the contents of
 76059:  * type sets particular to various scripts and type objects within a
 77372:  * compartment. This data can consume a significant amount of memory, and to
 77372:  * avoid this building up we try to clear it with some regularity. On each GC
 77372:  * which occurs while we are not actively working with inference or other
 77372:  * analysis information, we clear out all generated constraints, all type sets
 77372:  * describing stack types within scripts, and (normally) all data describing
 77439:  * type objects for particular JS objects (see the lazy type objects overview
 77439:  * below). JIT code depends on this data and is cleared as well.
 77439:  *
 77439:  * All this data is allocated into compartment->pool. Some type inference data
 77439:  * lives across GCs: type sets for scripts and non-singleton type objects, and
 77439:  * propeties for such type objects. This data is also allocated into
 77439:  * compartment->pool, but everything still live is copied to a new arena on GC.
 75718:  */
 75718: 
 75718: /*
 75615:  * A constraint which listens to additions to a type set and propagates those
 75615:  * changes to other type sets.
 75615:  */
 75615: class TypeConstraint
 75615: {
 75615: public:
 75638: #ifdef DEBUG
 75638:     const char *kind_;
 75638:     const char *kind() const { return kind_; }
 75638: #else
 75638:     const char *kind() const { return NULL; }
 75615: #endif
 75615: 
 75615:     /* Next constraint listening to the same type set. */
 75615:     TypeConstraint *next;
 75615: 
 77353:     TypeConstraint(const char *kind)
 77353:         : next(NULL)
 75615:     {
 75638: #ifdef DEBUG
 75638:         this->kind_ = kind;
 75615: #endif
 75615:     }
 75615: 
 75615:     /* Register a new type for the set this constraint is listening to. */
 77353:     virtual void newType(JSContext *cx, TypeSet *source, Type type) = 0;
 75625: 
 75625:     /*
 75944:      * For constraints attached to an object property's type set, mark the
 75944:      * property as having been configured or received an own property.
 75944:      */
 75944:     virtual void newPropertyState(JSContext *cx, TypeSet *source) {}
 75944: 
 75944:     /*
 77361:      * For constraints attached to the JSID_EMPTY type set on an object, mark a
 77361:      * change in one of the object's dynamic property flags. If force is set,
 77361:      * recompilation is always triggered.
 75625:      */
 76097:     virtual void newObjectState(JSContext *cx, TypeObject *object, bool force) {}
 75625: };
 75625: 
 77361: /* Flags and other state stored in TypeSet::flags */
 75720: enum {
 77353:     TYPE_FLAG_UNDEFINED =  0x1,
 77353:     TYPE_FLAG_NULL      =  0x2,
 77353:     TYPE_FLAG_BOOLEAN   =  0x4,
 77353:     TYPE_FLAG_INT32     =  0x8,
 77353:     TYPE_FLAG_DOUBLE    = 0x10,
 77353:     TYPE_FLAG_STRING    = 0x20,
 77353:     TYPE_FLAG_LAZYARGS  = 0x40,
 77353:     TYPE_FLAG_ANYOBJECT = 0x80,
 75720: 
 77361:     /* Mask/shift for the number of objects in objectSet */
 77361:     TYPE_FLAG_OBJECT_COUNT_MASK   = 0xff00,
 77361:     TYPE_FLAG_OBJECT_COUNT_SHIFT  = 8,
 77361:     TYPE_FLAG_OBJECT_COUNT_LIMIT  =
 77361:         TYPE_FLAG_OBJECT_COUNT_MASK >> TYPE_FLAG_OBJECT_COUNT_SHIFT,
 77361: 
 77361:     /* Whether the contents of this type set are totally unknown. */
 77361:     TYPE_FLAG_UNKNOWN             = 0x00010000,
 77361: 
 77361:     /* Mask of normal type flags on a type set. */
 77361:     TYPE_FLAG_BASE_MASK           = 0x000100ff,
 75720: 
 75948:     /* Flags for type sets which are on object properties. */
 75948: 
 77361:     /*
 77361:      * Whether there are subset constraints propagating the possible types
 77361:      * for this property inherited from the object's prototypes. Reset on GC.
 77361:      */
 77439:     TYPE_FLAG_PROPAGATED_PROPERTY = 0x00020000,
 77361: 
 75948:     /* Whether this property has ever been directly written. */
 77439:     TYPE_FLAG_OWN_PROPERTY        = 0x00040000,
 75944: 
 75944:     /*
 75948:      * Whether the property has ever been deleted or reconfigured to behave
 75948:      * differently from a normal native property (e.g. made non-writable or
 75948:      * given a scripted getter or setter).
 75944:      */
 77439:     TYPE_FLAG_CONFIGURED_PROPERTY = 0x00080000,
 77353: 
 75948:     /*
 75948:      * Whether the property is definitely in a particular inline slot on all
 75948:      * objects from which it has not been deleted or reconfigured. Implies
 75948:      * OWN_PROPERTY and unlike OWN/CONFIGURED property, this cannot change.
 75948:      */
 77439:     TYPE_FLAG_DEFINITE_PROPERTY   = 0x00100000,
 75948: 
 75948:     /* If the property is definite, mask and shift storing the slot. */
 77361:     TYPE_FLAG_DEFINITE_MASK       = 0x0f000000,
 77364:     TYPE_FLAG_DEFINITE_SHIFT      = 24
 75720: };
 84755: typedef uint32_t TypeFlags;
 75720: 
 77361: /* Flags and other state stored in TypeObject::flags */
 76044: enum {
 77361:     /* Objects with this type are functions. */
 77361:     OBJECT_FLAG_FUNCTION              = 0x1,
 77361: 
 77361:     /* If set, newScript information should not be installed on this object. */
 77361:     OBJECT_FLAG_NEW_SCRIPT_CLEARED    = 0x2,
 77361: 
 77361:     /*
 77361:      * If set, type constraints covering the correctness of the newScript
 77361:      * definite properties need to be regenerated before compiling any jitcode
 77361:      * which depends on this information.
 77361:      */
 77361:     OBJECT_FLAG_NEW_SCRIPT_REGENERATE = 0x4,
 77361: 
 77361:     /*
 77361:      * Whether we have ensured all type sets in the compartment contain
 77361:      * ANYOBJECT instead of this object.
 77361:      */
 77361:     OBJECT_FLAG_SETS_MARKED_UNKNOWN   = 0x8,
 77361: 
 77361:     /* Mask/shift for the number of properties in propertySet */
 77361:     OBJECT_FLAG_PROPERTY_COUNT_MASK   = 0xfff0,
 77361:     OBJECT_FLAG_PROPERTY_COUNT_SHIFT  = 4,
 77361:     OBJECT_FLAG_PROPERTY_COUNT_LIMIT  =
 77361:         OBJECT_FLAG_PROPERTY_COUNT_MASK >> OBJECT_FLAG_PROPERTY_COUNT_SHIFT,
 77361: 
 76044:     /*
 77884:      * Some objects are not dense arrays, or are dense arrays whose length
 84755:      * property does not fit in an int32_t.
 76044:      */
 80271:     OBJECT_FLAG_NON_DENSE_ARRAY       = 0x00010000,
 76044: 
 76044:     /* Whether any objects this represents are not packed arrays. */
 80271:     OBJECT_FLAG_NON_PACKED_ARRAY      = 0x00020000,
 76044: 
 76179:     /* Whether any objects this represents are not typed arrays. */
 80271:     OBJECT_FLAG_NON_TYPED_ARRAY       = 0x00040000,
 76179: 
 76128:     /* Whether any represented script is considered uninlineable. */
 93250:     OBJECT_FLAG_UNINLINEABLE          = 0x00080000,
 76044: 
 76128:     /* Whether any objects have an equality hook. */
 93250:     OBJECT_FLAG_SPECIAL_EQUALITY      = 0x00100000,
 76128: 
 76128:     /* Whether any objects have been iterated over. */
 93250:     OBJECT_FLAG_ITERATED              = 0x00200000,
 77884: 
 77884:     /* Outer function which has been marked reentrant. */
 93250:     OBJECT_FLAG_REENTRANT_FUNCTION    = 0x00400000,
 80271: 
 80271:     /* For a global object, whether flags were set on the RegExpStatics. */
 93250:     OBJECT_FLAG_REGEXP_FLAGS_SET      = 0x00800000,
 77361: 
 77361:     /* Flags which indicate dynamic properties of represented objects. */
 93250:     OBJECT_FLAG_DYNAMIC_MASK          = 0x00ff0000,
 77353: 
 77353:     /*
 77361:      * Whether all properties of this object are considered unknown.
 77361:      * If set, all flags in DYNAMIC_MASK will also be set.
 77353:      */
 80271:     OBJECT_FLAG_UNKNOWN_PROPERTIES    = 0x80000000,
 77353: 
 77361:     /* Mask for objects created with unknown properties. */
 77361:     OBJECT_FLAG_UNKNOWN_MASK =
 77361:         OBJECT_FLAG_DYNAMIC_MASK
 77361:       | OBJECT_FLAG_UNKNOWN_PROPERTIES
 77361:       | OBJECT_FLAG_SETS_MARKED_UNKNOWN
 76044: };
 84755: typedef uint32_t TypeObjectFlags;
 75720: 
 75615: /* Information about the set of types associated with an lvalue. */
 75919: class TypeSet
 75615: {
 77361:     /* Flags for this type set. */
 77361:     TypeFlags flags;
 75615: 
 75720:     /* Possible objects this type set can represent. */
 77353:     TypeObjectKey **objectSet;
 75615: 
 75919:   public:
 75919: 
 75615:     /* Chain of constraints which propagate changes out from this type set. */
 75615:     TypeConstraint *constraintList;
 75615: 
 75718:     TypeSet()
 77361:         : flags(0), objectSet(NULL), constraintList(NULL)
 75718:     {}
 75615: 
 75638:     void print(JSContext *cx);
 75615: 
 94740:     inline void sweep(JSCompartment *compartment);
 88579:     inline size_t computedSizeOfExcludingThis();
 75720: 
 75615:     /* Whether this set contains a specific type. */
 77353:     inline bool hasType(Type type);
 75615: 
 77460:     TypeFlags baseFlags() const { return flags & TYPE_FLAG_BASE_MASK; }
 77460:     bool unknown() const { return !!(flags & TYPE_FLAG_UNKNOWN); }
 77460:     bool unknownObject() const { return !!(flags & (TYPE_FLAG_UNKNOWN | TYPE_FLAG_ANYOBJECT)); }
 75697: 
 77460:     bool empty() const { return !baseFlags() && !baseObjectCount(); }
 77460: 
 77460:     bool hasAnyFlag(TypeFlags flags) const {
 77361:         JS_ASSERT((flags & TYPE_FLAG_BASE_MASK) == flags);
 77361:         return !!(baseFlags() & flags);
 77361:     }
 77361: 
 77460:     bool isOwnProperty(bool configurable) const {
 77361:         return flags & (configurable ? TYPE_FLAG_CONFIGURED_PROPERTY : TYPE_FLAG_OWN_PROPERTY);
 77361:     }
 77460:     bool isDefiniteProperty() const { return flags & TYPE_FLAG_DEFINITE_PROPERTY; }
 77460:     unsigned definiteSlot() const {
 75948:         JS_ASSERT(isDefiniteProperty());
 77361:         return flags >> TYPE_FLAG_DEFINITE_SHIFT;
 75948:     }
 75948: 
 75615:     /*
 75615:      * Add a type to this set, calling any constraint handlers if this is a new
 75615:      * possible type.
 75615:      */
 77353:     inline void addType(JSContext *cx, Type type);
 75794: 
 75944:     /* Mark this type set as representing an own property or configured property. */
 75944:     inline void setOwnProperty(JSContext *cx, bool configured);
 75944: 
 75919:     /*
 75919:      * Iterate through the objects in this set. getObjectCount overapproximates
 75919:      * in the hash case (see SET_ARRAY_SIZE in jsinferinlines.h), and getObject
 75919:      * may return NULL.
 75919:      */
 75919:     inline unsigned getObjectCount();
 77353:     inline TypeObjectKey *getObject(unsigned i);
 77353:     inline JSObject *getSingleObject(unsigned i);
 77353:     inline TypeObject *getTypeObject(unsigned i);
 76059: 
 75948:     void setOwnProperty(bool configurable) {
 77361:         flags |= TYPE_FLAG_OWN_PROPERTY;
 75948:         if (configurable)
 77361:             flags |= TYPE_FLAG_CONFIGURED_PROPERTY;
 75948:     }
 75948:     void setDefinite(unsigned slot) {
 75948:         JS_ASSERT(slot <= (TYPE_FLAG_DEFINITE_MASK >> TYPE_FLAG_DEFINITE_SHIFT));
 77361:         flags |= TYPE_FLAG_DEFINITE_PROPERTY | (slot << TYPE_FLAG_DEFINITE_SHIFT);
 75948:     }
 75948: 
 77361:     bool hasPropagatedProperty() { return !!(flags & TYPE_FLAG_PROPAGATED_PROPERTY); }
 77361:     void setPropagatedProperty() { flags |= TYPE_FLAG_PROPAGATED_PROPERTY; }
 77361: 
 77884:     enum FilterKind {
 77884:         FILTER_ALL_PRIMITIVES,
 77884:         FILTER_NULL_VOID,
 77884:         FILTER_VOID
 77884:     };
 77884: 
 75615:     /* Add specific kinds of constraints to this set. */
 75625:     inline void add(JSContext *cx, TypeConstraint *constraint, bool callExisting = true);
 77353:     void addSubset(JSContext *cx, TypeSet *target);
 76103:     void addGetProperty(JSContext *cx, JSScript *script, jsbytecode *pc,
 75708:                         TypeSet *target, jsid id);
 76103:     void addSetProperty(JSContext *cx, JSScript *script, jsbytecode *pc,
 75708:                         TypeSet *target, jsid id);
 76136:     void addCallProperty(JSContext *cx, JSScript *script, jsbytecode *pc, jsid id);
 77399:     void addSetElement(JSContext *cx, JSScript *script, jsbytecode *pc,
 77399:                        TypeSet *objectTypes, TypeSet *valueTypes);
 75615:     void addCall(JSContext *cx, TypeCallsite *site);
 93651:     void addArith(JSContext *cx, JSScript *script, jsbytecode *pc,
 93651:                   TypeSet *target, TypeSet *other = NULL);
 75708:     void addTransformThis(JSContext *cx, JSScript *script, TypeSet *target);
 78457:     void addPropagateThis(JSContext *cx, JSScript *script, jsbytecode *pc,
 78457:                           Type type, TypeSet *types = NULL);
 77884:     void addFilterPrimitives(JSContext *cx, TypeSet *target, FilterKind filter);
 76103:     void addSubsetBarrier(JSContext *cx, JSScript *script, jsbytecode *pc, TypeSet *target);
 75718: 
 75625:     /*
 77439:      * Make an type set with the specified debugging name, not embedded in
 77439:      * another structure.
 75625:      */
 76175:     static TypeSet *make(JSContext *cx, const char *name);
 75625: 
 75775:     /*
 75893:      * Methods for JIT compilation. If a script is currently being compiled
 75893:      * (see AutoEnterCompilation) these will add constraints ensuring that if
 75893:      * the return value change in the future due to new type information, the
 75893:      * currently compiled script will be marked for recompilation.
 75775:      */
 75615: 
 75870:     /* Completely freeze the contents of this type set. */
 75893:     void addFreeze(JSContext *cx);
 75870: 
 75775:     /* Get any type tag which all values in this set must have. */
 75893:     JSValueType getKnownTypeTag(JSContext *cx);
 75622: 
 95100:     bool isMagicArguments(JSContext *cx) { return getKnownTypeTag(cx) == JSVAL_TYPE_MAGIC; }
 76128: 
 76044:     /* Whether the type set or a particular object has any of a set of flags. */
 76044:     bool hasObjectFlags(JSContext *cx, TypeObjectFlags flags);
 76044:     static bool HasObjectFlags(JSContext *cx, TypeObject *object, TypeObjectFlags flags);
 75919: 
 77414:     /*
 77414:      * Watch for a generic object state change on a type object. This currently
 77414:      * includes reallocations of slot pointers for global objects, and changes
 77414:      * to newScript data on types.
 77414:      */
 77414:     static void WatchObjectStateChange(JSContext *cx, TypeObject *object);
 75944: 
 75944:     /*
 75944:      * For type sets on a property, return true if the property has any 'own'
 75944:      * values assigned. If configurable is set, return 'true' if the property
 75944:      * has additionally been reconfigured as non-configurable, non-enumerable
 75944:      * or non-writable (this only applies to properties that have changed after
 75944:      * having been created, not to e.g. properties non-writable on creation).
 75944:      */
 77361:     bool isOwnProperty(JSContext *cx, TypeObject *object, bool configurable);
 75944: 
 75677:     /* Get whether this type set is non-empty. */
 75893:     bool knownNonEmpty(JSContext *cx);
 75761: 
 80557:     /* Get whether this type set is known to be a subset of other. */
 80557:     bool knownSubset(JSContext *cx, TypeSet *other);
 80557: 
 77347:     /*
 77347:      * Get the typed array type of all objects in this set. Returns
 77347:      * TypedArray::TYPE_MAX if the set contains different array types.
 77347:      */
 77347:     int getTypedArrayType(JSContext *cx);
 77347: 
 77353:     /* Get the single value which can appear in this type set, otherwise NULL. */
 77353:     JSObject *getSingleton(JSContext *cx, bool freeze = true);
 76057: 
 77884:     /* Whether all objects in this set are parented to a particular global. */
 77884:     bool hasGlobalObject(JSContext *cx, JSObject *global);
 77884: 
 77361:     inline void clearObjects();
 77361: 
 82129:     /*
 82129:      * Whether a location with this TypeSet needs a write barrier (i.e., whether
 82129:      * it can hold GC things). The type set is frozen if no barrier is needed.
 82129:      */
 82129:     bool needsBarrier(JSContext *cx);
 82129: 
 82129:     /* The type set is frozen if no barrier is needed. */
 82129:     bool propertyNeedsBarrier(JSContext *cx, jsid id);
 82129: 
 75761:   private:
 84755:     uint32_t baseObjectCount() const {
 77460:         return (flags & TYPE_FLAG_OBJECT_COUNT_MASK) >> TYPE_FLAG_OBJECT_COUNT_SHIFT;
 77460:     }
 84755:     inline void setBaseObjectCount(uint32_t count);
 75794: };
 75794: 
 76059: /*
 77361:  * Handler which persists information about dynamic types pushed within a
 77361:  * script which can affect its behavior and are not covered by JOF_TYPESET ops,
 77361:  * such as integer operations which overflow to a double. These persist across
 77399:  * GCs, and are used to re-seed script types when they are reanalyzed.
 76059:  */
 77361: struct TypeResult
 76059: {
 84755:     uint32_t offset;
 77361:     Type type;
 77361:     TypeResult *next;
 76059: 
 84755:     TypeResult(uint32_t offset, Type type)
 77361:         : offset(offset), type(type), next(NULL)
 77361:     {}
 76059: };
 76059: 
 76061: /*
 76165:  * Type barriers overview.
 76165:  *
 76165:  * Type barriers are a technique for using dynamic type information to improve
 76165:  * the inferred types within scripts. At certain opcodes --- those with the
 76165:  * JOF_TYPESET format --- we will construct a type set storing the set of types
 76165:  * which we have observed to be pushed at that opcode, and will only use those
 76165:  * observed types when doing propagation downstream from the bytecode. For
 76165:  * example, in the following script:
 76165:  *
 76165:  * function foo(x) {
 76165:  *   return x.f + 10;
 76165:  * }
 76165:  *
 76165:  * Suppose we know the type of 'x' and that the type of its 'f' property is
 76165:  * either an int or float. To account for all possible behaviors statically,
 76165:  * we would mark the result of the 'x.f' access as an int or float, as well
 76165:  * as the result of the addition and the return value of foo (and everywhere
 76165:  * the result of 'foo' is used). When dealing with polymorphic code, this is
 76165:  * undesirable behavior --- the type imprecision surrounding the polymorphism
 76165:  * will tend to leak to many places in the program.
 76165:  *
 76165:  * Instead, we will keep track of the types that have been dynamically observed
 76165:  * to have been produced by the 'x.f', and only use those observed types
 76165:  * downstream from the access. If the 'x.f' has only ever produced integers,
 76165:  * we will treat its result as an integer and mark the result of foo as an
 76165:  * integer.
 76165:  *
 76165:  * The set of observed types will be a subset of the set of possible types,
 76165:  * and if the two sets are different, a type barriers will be added at the
 76165:  * bytecode which checks the dynamic result every time the bytecode executes
 76165:  * and makes sure it is in the set of observed types. If it is not, that
 76165:  * observed set is updated, and the new type information is automatically
 76165:  * propagated along the already-generated type constraints to the places
 76165:  * where the result of the bytecode is used.
 76165:  *
 76165:  * Observing new types at a bytecode removes type barriers at the bytecode
 76165:  * (this removal happens lazily, see ScriptAnalysis::pruneTypeBarriers), and if
 76165:  * all type barriers at a bytecode are removed --- the set of observed types
 76165:  * grows to match the set of possible types --- then the result of the bytecode
 76165:  * no longer needs to be dynamically checked (unless the set of possible types
 76165:  * grows, triggering the generation of new type barriers).
 77442:  *
 77442:  * Barriers are only relevant for accesses on properties whose types inference
 77442:  * actually tracks (see propertySet comment under TypeObject). Accesses on
 77442:  * other properties may be able to produce additional unobserved types even
 77442:  * without a barrier present, and can only be compiled to jitcode with special
 77442:  * knowledge of the property in question (e.g. for lengths of arrays, or
 77442:  * elements of typed arrays).
 76165:  */
 76165: 
 76165: /*
 76061:  * Barrier introduced at some bytecode. These are added when, during inference,
 76061:  * we block a type from being propagated as would normally be done for a subset
 76061:  * constraint. The propagation is technically possible, but we suspect it will
 76061:  * not happen dynamically and this type needs to be watched for. These are only
 76061:  * added at reads of properties and at scripted call sites.
 76061:  */
 76061: struct TypeBarrier
 76061: {
 76061:     /* Next barrier on the same bytecode. */
 76061:     TypeBarrier *next;
 76061: 
 76061:     /* Target type set into which propagation was blocked. */
 76061:     TypeSet *target;
 76061: 
 76061:     /*
 76061:      * Type which was not added to the target. If target ends up containing the
 76061:      * type somehow, this barrier can be removed.
 76061:      */
 77353:     Type type;
 77353: 
 77460:     /*
 77460:      * If specified, this barrier can be removed if object has a non-undefined
 77460:      * value in property id.
 77460:      */
 77460:     JSObject *singleton;
 77460:     jsid singletonId;
 77460: 
 77460:     TypeBarrier(TypeSet *target, Type type, JSObject *singleton, jsid singletonId)
 77460:         : next(NULL), target(target), type(type),
 77460:           singleton(singleton), singletonId(singletonId)
 77353:     {}
 76061: };
 76061: 
 75641: /* Type information about a property. */
 75641: struct Property
 75615: {
 75641:     /* Identifier for this property, JSID_VOID for the aggregate integer index property. */
 82129:     HeapId id;
 75638: 
 75641:     /* Possible types for this property, including types inherited from prototypes. */
 75641:     TypeSet types;
 75615: 
 82129:     inline Property(jsid id);
 82129:     inline Property(const Property &o);
 77439: 
 84755:     static uint32_t keyBits(jsid id) { return uint32_t(JSID_BITS(id)); }
 75641:     static jsid getKey(Property *p) { return p->id; }
 75615: };
 75615: 
 76059: /*
 76059:  * Information attached to a TypeObject if it is always constructed using 'new'
 77361:  * on a particular script. This is used to manage state related to the definite
 77361:  * properties on the type object: these definite properties depend on type
 77361:  * information which could change as the script executes (e.g. a scripted
 77361:  * setter is added to a prototype object), and we need to ensure both that the
 77361:  * appropriate type constraints are in place when necessary, and that we can
 77361:  * remove the definite property information and repair the JS stack if the
 77361:  * constraints are violated.
 76059:  */
 76059: struct TypeNewScript
 76059: {
 82129:     HeapPtrFunction fun;
 76059: 
 77775:     /* Allocation kind to use for newly constructed objects. */
 77775:     gc::AllocKind allocKind;
 76059: 
 77361:     /*
 77361:      * Shape to use for newly constructed objects. Reflects all definite
 77361:      * properties the object will have.
 77361:      */
 90419:     HeapPtrShape  shape;
 76059: 
 76059:     /*
 76059:      * Order in which properties become initialized. We need this in case a
 77361:      * scripted setter is added to one of the object's prototypes while it is
 77361:      * in the middle of being initialized, so we can walk the stack and fixup
 77361:      * any objects which look for in-progress objects which were prematurely
 77361:      * set with their final shape. Initialization can traverse stack frames,
 76059:      * in which case FRAME_PUSH/FRAME_POP are used.
 76059:      */
 76059:     struct Initializer {
 76059:         enum Kind {
 76059:             SETPROP,
 76059:             FRAME_PUSH,
 76059:             FRAME_POP,
 76059:             DONE
 76059:         } kind;
 84755:         uint32_t offset;
 84755:         Initializer(Kind kind, uint32_t offset)
 76059:           : kind(kind), offset(offset)
 76059:         {}
 76059:     };
 76059:     Initializer *initializerList;
 82129: 
 82129:     static inline void writeBarrierPre(TypeNewScript *newScript);
 82129:     static inline void writeBarrierPost(TypeNewScript *newScript, void *addr);
 76059: };
 76059: 
 77353: /*
 77353:  * Lazy type objects overview.
 77353:  *
 77353:  * Type objects which represent at most one JS object are constructed lazily.
 77353:  * These include types for native functions, standard classes, scripted
 77353:  * functions defined at the top level of global/eval scripts, and in some
 77353:  * other cases. Typical web workloads often create many windows (and many
 77353:  * copies of standard natives) and many scripts, with comparatively few
 77353:  * non-singleton types.
 77353:  *
 77372:  * We can recover the type information for the object from examining it,
 77372:  * so don't normally track the possible types of its properties as it is
 77372:  * updated. Property type sets for the object are only constructed when an
 77372:  * analyzed script attaches constraints to it: the script is querying that
 77372:  * property off the object or another which delegates to it, and the analysis
 77372:  * information is sensitive to changes in the property's type. Future changes
 77372:  * to the property (whether those uncovered by analysis or those occurring
 77372:  * in the VM) will treat these properties like those of any other type object.
 77353:  *
 77372:  * When a GC occurs, we wipe out all analysis information for all the
 77372:  * compartment's scripts, so can destroy all properties on singleton type
 77372:  * objects at the same time. If there is no reference on the stack to the
 77372:  * type object itself, the type object is also destroyed, and the JS object
 77372:  * reverts to having a lazy type.
 77353:  */
 77353: 
 75615: /* Type information about an object accessed by a script. */
 77361: struct TypeObject : gc::Cell
 75615: {
 75679:     /* Prototype shared by objects using this type. */
 82129:     HeapPtrObject proto;
 75679: 
 77353:     /*
 77353:      * Whether there is a singleton JS object with this type. That JS object
 77353:      * must appear in type sets instead of this; we include the back reference
 77353:      * here to allow reverting the JS object to a lazy type.
 77353:      */
 82129:     HeapPtrObject singleton;
 77353: 
 83249:     /*
 83249:      * Value held by singleton if this is a standin type for a singleton JS
 83249:      * object whose type has not been constructed yet.
 83249:      */
 83249:     static const size_t LAZY_SINGLETON = 1;
 83249:     bool lazy() const { return singleton == (JSObject *) LAZY_SINGLETON; }
 75615: 
 77361:     /* Flags for this object. */
 75919:     TypeObjectFlags flags;
 75919: 
 77353:     /*
 75761:      * Estimate of the contribution of this object to the type sets it appears in.
 75761:      * This is the sum of the sizes of those sets at the point when the object
 75761:      * was added.
 75761:      *
 75761:      * When the contribution exceeds the CONTRIBUTION_LIMIT, any type sets the
 75761:      * object is added to are instead marked as unknown. If we get to this point
 75761:      * we are probably not adding types which will let us do meaningful optimization
 75761:      * later, and we want to ensure in such cases that our time/space complexity
 75761:      * is linear, not worst-case cubic as it would otherwise be.
 75761:      */
 84755:     uint32_t contribution;
 84755:     static const uint32_t CONTRIBUTION_LIMIT = 2000;
 75761: 
 75761:     /*
 83297:      * If non-NULL, objects of this type have always been constructed using
 83297:      * 'new' on the specified script, which adds some number of properties to
 83297:      * the object in a definite order before the object escapes.
 83297:      */
 83301:     HeapPtr<TypeNewScript> newScript;
 83297: 
 83297:     /*
 76083:      * Properties of this object. This may contain JSID_VOID, representing the
 77361:      * types of all integer indexes of the object, and/or JSID_EMPTY, holding
 77442:      * constraints listening to changes to the object's state.
 77442:      *
 77442:      * The type sets in the properties of a type object describe the possible
 77442:      * values that can be read out of that property in actual JS objects.
 77442:      * Properties only account for native properties (those with a slot and no
 77442:      * specialized getter hook) and the elements of dense arrays. For accesses
 77442:      * on such properties, the correspondence is as follows:
 76083:      *
 77460:      * 1. If the type has unknownProperties(), the possible properties and
 77460:      *    value types for associated JSObjects are unknown.
 76083:      *
 77460:      * 2. Otherwise, for any JSObject obj with TypeObject type, and any jsid id
 77460:      *    which is a property in obj, before obj->getProperty(id) the property
 77460:      *    in type for id must reflect the result of the getProperty.
 77460:      *
 77460:      *    There is an exception for properties of singleton JS objects which
 77460:      *    are undefined at the point where the property was (lazily) generated.
 77460:      *    In such cases the property type set will remain empty, and the
 77460:      *    'undefined' type will only be added after a subsequent assignment or
 77460:      *    deletion. After these properties have been assigned a defined value,
 77460:      *    the only way they can become undefined again is after such an assign
 77460:      *    or deletion.
 76083:      *
 76083:      * We establish these by using write barriers on calls to setProperty and
 77442:      * defineProperty which are on native properties, and by using the inference
 77442:      * analysis to determine the side effects of code which is JIT-compiled.
 75615:      */
 75641:     Property **propertySet;
 75615: 
 77884:     /* If this is an interpreted function, the function object. */
 82129:     HeapPtrFunction interpretedFunction;
 76175: 
 83297: #if JS_BITS_PER_WORD == 32
 83297:     void *padding;
 83297: #endif
 83297: 
 77461:     inline TypeObject(JSObject *proto, bool isFunction, bool unknown);
 75679: 
 77361:     bool isFunction() { return !!(flags & OBJECT_FLAG_FUNCTION); }
 75615: 
 77361:     bool hasAnyFlags(TypeObjectFlags flags) {
 77361:         JS_ASSERT((flags & OBJECT_FLAG_DYNAMIC_MASK) == flags);
 77361:         return !!(this->flags & flags);
 77361:     }
 77361:     bool hasAllFlags(TypeObjectFlags flags) {
 77361:         JS_ASSERT((flags & OBJECT_FLAG_DYNAMIC_MASK) == flags);
 77361:         return (this->flags & flags) == flags;
 77361:     }
 77361: 
 77361:     bool unknownProperties() {
 77361:         JS_ASSERT_IF(flags & OBJECT_FLAG_UNKNOWN_PROPERTIES,
 77361:                      hasAllFlags(OBJECT_FLAG_DYNAMIC_MASK));
 77361:         return !!(flags & OBJECT_FLAG_UNKNOWN_PROPERTIES);
 77361:     }
 75919: 
 75641:     /*
 75641:      * Get or create a property of this object. Only call this for properties which
 75641:      * a script accesses explicitly. 'assign' indicates whether this is for an
 75641:      * assignment, and the own types of the property will be used instead of
 75641:      * aggregate types.
 75641:      */
 75641:     inline TypeSet *getProperty(JSContext *cx, jsid id, bool assign);
 75615: 
 77361:     /* Get a property only if it already exists. */
 77361:     inline TypeSet *maybeGetProperty(JSContext *cx, jsid id);
 77353: 
 75919:     inline unsigned getPropertyCount();
 75919:     inline Property *getProperty(unsigned i);
 75919: 
 76179:     /* Set flags on this object which are implied by the specified key. */
 77361:     inline void setFlagsFromKey(JSContext *cx, JSProtoKey kind);
 76179: 
 77884:     /*
 77884:      * Get the global object which all objects of this type are parented to,
 77884:      * or NULL if there is none known.
 77884:      */
 77884:     inline JSObject *getGlobal();
 77884: 
 75641:     /* Helpers */
 75640: 
 75720:     bool addProperty(JSContext *cx, jsid id, Property **pprop);
 76059:     bool addDefiniteProperties(JSContext *cx, JSObject *obj);
 77361:     bool matchDefiniteProperties(JSObject *obj);
 75641:     void addPrototype(JSContext *cx, TypeObject *proto);
 77353:     void addPropertyType(JSContext *cx, jsid id, Type type);
 76148:     void addPropertyType(JSContext *cx, jsid id, const Value &value);
 77353:     void addPropertyType(JSContext *cx, const char *name, Type type);
 76148:     void addPropertyType(JSContext *cx, const char *name, const Value &value);
 76148:     void markPropertyConfigured(JSContext *cx, jsid id);
 77414:     void markStateChange(JSContext *cx);
 75919:     void setFlags(JSContext *cx, TypeObjectFlags flags);
 75641:     void markUnknown(JSContext *cx);
 75948:     void clearNewScript(JSContext *cx);
 77361:     void getFromPrototypes(JSContext *cx, jsid id, TypeSet *types, bool force = false);
 75615: 
 75638:     void print(JSContext *cx);
 77361: 
 77361:     inline void clearProperties();
 94740:     inline void sweep(FreeOp *fop);
 77439: 
 88579:     inline size_t computedSizeOfExcludingThis();
 88579: 
 88579:     void sizeOfExcludingThis(TypeInferenceSizes *sizes, JSMallocSizeOfFun mallocSizeOf);
 77361: 
 77361:     /*
 77361:      * Type objects don't have explicit finalizers. Memory owned by a type
 77361:      * object pending deletion is released when weak references are sweeped
 77361:      * from all the compartment's type objects.
 77361:      */
 94738:     void finalize(FreeOp *fop) {}
 77361: 
 82129:     static inline void writeBarrierPre(TypeObject *type);
 82129:     static inline void writeBarrierPost(TypeObject *type, void *addr);
 83302:     static inline void readBarrier(TypeObject *type);
 82129: 
 86437:     static inline ThingRootKind rootKind() { return THING_ROOT_TYPE_OBJECT; }
 86437: 
 77361:   private:
 84755:     inline uint32_t basePropertyCount() const;
 84755:     inline void setBasePropertyCount(uint32_t count);
 79734: 
 79734:     static void staticAsserts() {
 79734:         JS_STATIC_ASSERT(offsetof(TypeObject, proto) == offsetof(js::shadow::TypeObject, proto));
 79734:     }
 75615: };
 75615: 
 81205: /*
 83297:  * Entries for the per-compartment set of type objects which are the default
 83297:  * 'new' or the lazy types of some prototype.
 83297:  */
 83297: struct TypeObjectEntry
 83297: {
 83297:     typedef JSObject *Lookup;
 83297: 
 83297:     static inline HashNumber hash(JSObject *base);
 83297:     static inline bool match(TypeObject *key, JSObject *lookup);
 83297: };
 86321: typedef HashSet<ReadBarriered<TypeObject>, TypeObjectEntry, SystemAllocPolicy> TypeObjectSet;
 77361: 
 76151: /* Whether to use a new type object when calling 'new' at script/pc. */
 76151: bool
 76151: UseNewType(JSContext *cx, JSScript *script, jsbytecode *pc);
 76151: 
 93664: /* Whether to use a new type object for an initializer opcode at script/pc. */
 93664: bool
 93664: UseNewTypeForInitializer(JSContext *cx, JSScript *script, jsbytecode *pc);
 93664: 
 76151: /*
 86292:  * Whether Array.prototype, or an object on its proto chain, has an
 86292:  * indexed property.
 86292:  */
 86292: bool
 86292: ArrayPrototypeHasIndexedProperty(JSContext *cx, JSScript *script);
 86292: 
 86292: /*
 75708:  * Type information about a callsite. this is separated from the bytecode
 75708:  * information itself so we can handle higher order functions not called
 75708:  * directly via a bytecode.
 75708:  */
 75708: struct TypeCallsite
 75708: {
 75708:     JSScript *script;
 76103:     jsbytecode *pc;
 75708: 
 75708:     /* Whether this is a 'NEW' call. */
 75708:     bool isNew;
 75708: 
 75708:     /* Types of each argument to the call. */
 97661:     unsigned argumentCount;
 75708:     TypeSet **argumentTypes;
 75708: 
 75708:     /* Types of the this variable. */
 75708:     TypeSet *thisTypes;
 75708: 
 75708:     /* Type set receiving the return value of this call. */
 75708:     TypeSet *returnTypes;
 75708: 
 76103:     inline TypeCallsite(JSContext *cx, JSScript *script, jsbytecode *pc,
 75708:                         bool isNew, unsigned argumentCount);
 76158: };
 75708: 
 77884: /*
 77884:  * Information attached to outer and inner function scripts nested in one
 77884:  * another for tracking the reentrance state for outer functions. This state is
 77884:  * used to generate fast accesses to the args and vars of the outer function.
 77884:  *
 77884:  * A function is non-reentrant if, at any point in time, only the most recent
 77884:  * activation (i.e. call object) is live. An activation is live if either the
 77884:  * activation is on the stack, or a transitive inner function parented to the
 77884:  * activation is on the stack.
 77884:  *
 77884:  * Because inner functions can be (and, quite often, are) stored in object
 77884:  * properties and it is difficult to build a fast and robust escape analysis
 77884:  * to cope with such flow, we detect reentrance dynamically. For the outer
 77884:  * function, we keep track of the call object for the most recent activation,
 77884:  * and the number of frames for the function and its inner functions which are
 77884:  * on the stack.
 77884:  *
 77884:  * If the outer function is called while frames associated with a previous
 77884:  * activation are on the stack, the outer function is reentrant. If an inner
 77884:  * function is called whose scope does not match the most recent activation,
 77884:  * the outer function is reentrant.
 77884:  *
 77884:  * The situation gets trickier when there are several levels of nesting.
 77884:  *
 77884:  * function foo() {
 77884:  *   var a;
 77884:  *   function bar() {
 77884:  *     var b;
 77884:  *     function baz() { return a + b; }
 77884:  *   }
 77884:  * }
 77884:  *
 77884:  * At calls to 'baz', we don't want to do the scope check for the activations
 77884:  * of both 'foo' and 'bar', but rather 'bar' only. For this to work, a call to
 77884:  * 'baz' which is a reentrant call on 'foo' must also be a reentrant call on
 77884:  * 'bar'. When 'foo' is called, we clear the most recent call object for 'bar'.
 77884:  */
 77884: struct TypeScriptNesting
 77884: {
 77884:     /*
 77884:      * If this is an inner function, the outer function. If non-NULL, this will
 77884:      * be the immediate nested parent of the script (even if that parent has
 77884:      * been marked reentrant). May be NULL even if the script has a nested
 77884:      * parent, if NAME accesses cannot be tracked into the parent (either the
 77884:      * script extends its scope with eval() etc., or the parent can make new
 77884:      * scope chain objects with 'let' or 'with').
 77884:      */
 77884:     JSScript *parent;
 77884: 
 77884:     /* If this is an outer function, list of inner functions. */
 77884:     JSScript *children;
 77884: 
 77884:     /* Link for children list of parent. */
 77884:     JSScript *next;
 77884: 
 77884:     /* If this is an outer function, the most recent activation. */
100006:     JSObject *activeCall;
 77884: 
 77884:     /*
 77884:      * If this is an outer function, pointers to the most recent activation's
 77884:      * arguments and variables arrays. These could be referring either to stack
 77884:      * values in activeCall's frame (if it has not finished yet) or to the
 77884:      * internal slots of activeCall (if the frame has finished). Pointers to
 77884:      * these fields can be embedded directly in JIT code (though remember to
 77884:      * use 'addDependency == true' when calling resolveNameAccess).
 77884:      */
 82129:     const Value *argArray;
 82129:     const Value *varArray;
 77884: 
 77884:     /* Number of frames for this function on the stack. */
 84755:     uint32_t activeFrames;
 77884: 
 77884:     TypeScriptNesting() { PodZero(this); }
 77884:     ~TypeScriptNesting();
 77884: };
 77884: 
 77884: /* Construct nesting information for script wrt its parent. */
 77884: bool CheckScriptNesting(JSContext *cx, JSScript *script);
 77884: 
 77884: /* Track nesting state when calling or finishing an outer/inner function. */
 77884: void NestingPrologue(JSContext *cx, StackFrame *fp);
 77884: void NestingEpilogue(StackFrame *fp);
 77884: 
 76158: /* Persistent type information for a script, retained across GCs. */
 77884: class TypeScript
 76158: {
 77884:     friend struct ::JSScript;
 77884: 
 77391:     /* Analysis information for the script, cleared on each GC. */
 77391:     analyze::ScriptAnalysis *analysis;
 76158: 
 77884:     /*
 77884:      * Information about the scope in which a script executes. This information
 77884:      * is not set until the script has executed at least once and SetScope
 77884:      * called, before that 'global' will be poisoned per GLOBAL_MISSING_SCOPE.
 77884:      */
 77884:     static const size_t GLOBAL_MISSING_SCOPE = 0x1;
 77884: 
 77884:     /* Global object for the script, if compileAndGo. */
 82129:     HeapPtr<GlobalObject> global;
 77884: 
 81205:   public:
 81205: 
 77884:     /* Nesting state for outer or inner function scripts. */
 77884:     TypeScriptNesting *nesting;
 77884: 
 77884:     /* Dynamic types generated at points within this script. */
 77884:     TypeResult *dynamicList;
 77884: 
 83302:     inline TypeScript();
 77884: 
 82129:     bool hasScope() { return size_t(global.get()) != GLOBAL_MISSING_SCOPE; }
 77884: 
 77391:     /* Array of type type sets for variables and JOF_TYPESET ops. */
 86976:     TypeSet *typeArray() { return (TypeSet *) (uintptr_t(this) + sizeof(TypeScript)); }
 76158: 
 77391:     static inline unsigned NumTypeSets(JSScript *script);
 76158: 
 77884:     static bool SetScope(JSContext *cx, JSScript *script, JSObject *scope);
 76158: 
 77391:     static inline TypeSet *ReturnTypes(JSScript *script);
 77391:     static inline TypeSet *ThisTypes(JSScript *script);
 77391:     static inline TypeSet *ArgTypes(JSScript *script, unsigned i);
 77391:     static inline TypeSet *LocalTypes(JSScript *script, unsigned i);
 76158: 
 76158:     /* Follows slot layout in jsanalyze.h, can get this/arg/local type sets. */
 77391:     static inline TypeSet *SlotTypes(JSScript *script, unsigned slot);
 76158: 
 76158: #ifdef DEBUG
 76158:     /* Check that correct types were inferred for the values pushed by this bytecode. */
 77391:     static void CheckBytecode(JSContext *cx, JSScript *script, jsbytecode *pc, const js::Value *sp);
 76158: #endif
 76158: 
 76158:     /* Get the default 'new' object for a given standard class, per the script's global. */
 77391:     static inline TypeObject *StandardType(JSContext *cx, JSScript *script, JSProtoKey kind);
 76158: 
 76158:     /* Get a type object for an allocation site in this script. */
 93664:     static inline TypeObject *InitObject(JSContext *cx, JSScript *script, jsbytecode *pc, JSProtoKey kind);
 76158: 
 76165:     /*
 76165:      * Monitor a bytecode pushing a value which is not accounted for by the
 76165:      * inference type constraints, such as integer overflow.
 76165:      */
 77391:     static inline void MonitorOverflow(JSContext *cx, JSScript *script, jsbytecode *pc);
 77391:     static inline void MonitorString(JSContext *cx, JSScript *script, jsbytecode *pc);
 77391:     static inline void MonitorUnknown(JSContext *cx, JSScript *script, jsbytecode *pc);
 76158: 
 87809:     static inline void GetPcScript(JSContext *cx, JSScript **script, jsbytecode **pc);
 87809:     static inline void MonitorOverflow(JSContext *cx);
 87809:     static inline void MonitorString(JSContext *cx);
 87809:     static inline void MonitorUnknown(JSContext *cx);
 87809: 
 76165:     /*
 76165:      * Monitor a bytecode pushing any value. This must be called for any opcode
 76165:      * which is JOF_TYPESET, and where either the script has not been analyzed
 76165:      * by type inference or where the pc has type barriers. For simplicity, we
 76165:      * always monitor JOF_TYPESET opcodes in the interpreter and stub calls,
 76165:      * and only look at barriers when generating JIT code for the script.
 76165:      */
 77391:     static inline void Monitor(JSContext *cx, JSScript *script, jsbytecode *pc,
 80962:                                const js::Value &val);
 88054:     static inline void Monitor(JSContext *cx, const js::Value &rval);
 76158: 
 76158:     /* Monitor an assignment at a SETELEM on a non-integer identifier. */
 91183:     static inline void MonitorAssign(JSContext *cx, JSObject *obj, jsid id);
 76158: 
 77391:     /* Add a type for a variable in a script. */
 77391:     static inline void SetThis(JSContext *cx, JSScript *script, Type type);
 77391:     static inline void SetThis(JSContext *cx, JSScript *script, const js::Value &value);
 77391:     static inline void SetLocal(JSContext *cx, JSScript *script, unsigned local, Type type);
 77391:     static inline void SetLocal(JSContext *cx, JSScript *script, unsigned local, const js::Value &value);
 77391:     static inline void SetArgument(JSContext *cx, JSScript *script, unsigned arg, Type type);
 80962:     static inline void SetArgument(JSContext *cx, JSScript *script, unsigned arg, const js::Value &value);
 76158: 
 94740:     static void Sweep(FreeOp *fop, JSScript *script);
 77884:     inline void trace(JSTracer *trc);
 77353:     void destroy();
 75718: };
 75708: 
 75770: struct ArrayTableKey;
 86321: typedef HashMap<ArrayTableKey,ReadBarriered<TypeObject>,ArrayTableKey,SystemAllocPolicy> ArrayTypeTable;
 75770: 
 75770: struct ObjectTableKey;
 75770: struct ObjectTableEntry;
 75771: typedef HashMap<ObjectTableKey,ObjectTableEntry,ObjectTableKey,SystemAllocPolicy> ObjectTypeTable;
 75770: 
 77361: struct AllocationSiteKey;
 86321: typedef HashMap<AllocationSiteKey,ReadBarriered<TypeObject>,AllocationSiteKey,SystemAllocPolicy> AllocationSiteTable;
 77361: 
 87654: struct RecompileInfo
 87654: {
 87654:     JSScript *script;
 87654:     bool constructing : 1;
 98147:     bool barriers : 1;
 98147:     uint32_t chunkIndex:30;
 87654: 
 87654:     bool operator == (const RecompileInfo &o) const {
 98147:         return script == o.script
 98147:             && constructing == o.constructing
 98147:             && barriers == o.barriers
 98147:             && chunkIndex == o.chunkIndex;
 87654:     }
 87654: };
 87654: 
 75615: /* Type information for a compartment. */
 75615: struct TypeCompartment
 75615: {
 97661:     /* Constraint solving worklist structures. */
 97661: 
 97661:     /*
 97661:      * Worklist of types which need to be propagated to constraints. We use a
 97661:      * worklist to avoid blowing the native stack.
 97661:      */
 97661:     struct PendingWork
 97661:     {
 97661:         TypeConstraint *constraint;
 97661:         TypeSet *source;
 97661:         Type type;
 97661:     };
 97661:     PendingWork *pendingArray;
 97661:     unsigned pendingCount;
 97661:     unsigned pendingCapacity;
 97661: 
 97661:     /* Whether we are currently resolving the pending worklist. */
 97661:     bool resolving;
 97661: 
 75720:     /* Whether type inference is enabled in this compartment. */
 75720:     bool inferenceEnabled;
 75720: 
 76128:     /*
 75720:      * Bit set if all current types must be marked as unknown, and all scripts
 75720:      * recompiled. Caused by OOM failure within inference operations.
 75720:      */
 75720:     bool pendingNukeTypes;
 75720: 
 97661:     /* Number of scripts in this compartment. */
 97661:     unsigned scriptCount;
 97661: 
 75636:     /* Pending recompilations to perform before execution of JIT code can resume. */
 87654:     Vector<RecompileInfo> *pendingRecompiles;
 75636: 
 75883:     /*
 75883:      * Number of recompilation events and inline frame expansions that have
 75883:      * occurred in this compartment. If these change, code should not count on
 75883:      * compiled code or the current stack being intact.
 75883:      */
 75883:     unsigned recompilations;
 75883:     unsigned frameExpansions;
 75883: 
 75893:     /*
 75893:      * Script currently being compiled. All constraints which look for type
 75893:      * changes inducing recompilation are keyed to this script. Note: script
 75893:      * compilation is not reentrant.
 75893:      */
 87654:     RecompileInfo compiledInfo;
 75893: 
 77361:     /* Table for referencing types of objects keyed to an allocation site. */
 77361:     AllocationSiteTable *allocationSiteTable;
 77361: 
 75770:     /* Tables for determining types of singleton/JSON objects. */
 75770: 
 75770:     ArrayTypeTable *arrayTypeTable;
 75770:     ObjectTypeTable *objectTypeTable;
 75770: 
 76020:     void fixArrayType(JSContext *cx, JSObject *obj);
 76020:     void fixObjectType(JSContext *cx, JSObject *obj);
 75770: 
 75615:     /* Logging fields */
 75615: 
 75615:     /* Counts of stack type sets with some number of possible operand types. */
 75615:     static const unsigned TYPE_COUNT_LIMIT = 4;
 75615:     unsigned typeCounts[TYPE_COUNT_LIMIT];
 75615:     unsigned typeCountOver;
 75615: 
 75720:     void init(JSContext *cx);
 75770:     ~TypeCompartment();
 75615: 
 77361:     inline JSCompartment *compartment();
 77361: 
 75615:     /* Add a type to register with a list of constraints. */
 77353:     inline void addPending(JSContext *cx, TypeConstraint *constraint, TypeSet *source, Type type);
 80429:     bool growPendingArray(JSContext *cx);
 75615: 
 75615:     /* Resolve pending type registrations, excluding delayed ones. */
 75615:     inline void resolvePending(JSContext *cx);
 75615: 
 77440:     /* Prints results of this compartment if spew is enabled or force is set. */
 77440:     void print(JSContext *cx, bool force);
 75615: 
 76179:     /*
 76179:      * Make a function or non-function object associated with an optional
 76179:      * script. The 'key' parameter here may be an array, typed array, function
 76179:      * or JSProto_Object to indicate a type whose class is unknown (not just
 76179:      * js_ObjectClass).
 76179:      */
 75718:     TypeObject *newTypeObject(JSContext *cx, JSScript *script,
 77361:                               JSProtoKey kind, JSObject *proto, bool unknown = false);
 75615: 
 77361:     /* Make an object for an allocation site. */
 77361:     TypeObject *newAllocationSiteTypeObject(JSContext *cx, const AllocationSiteKey &key);
 75708: 
 94740:     void nukeTypes(FreeOp *fop);
 94740:     void processPendingRecompiles(FreeOp *fop);
 75720: 
 75720:     /* Mark all types as needing destruction once inference has 'finished'. */
 75720:     void setPendingNukeTypes(JSContext *cx);
 94740:     void setPendingNukeTypesNoReport();
 75720: 
 75720:     /* Mark a script as needing recompilation once inference has finished. */
 87654:     void addPendingRecompile(JSContext *cx, const RecompileInfo &info);
 87654:     void addPendingRecompile(JSContext *cx, JSScript *script, jsbytecode *pc);
 75636: 
 75615:     /* Monitor future effects on a bytecode. */
 84755:     void monitorBytecode(JSContext *cx, JSScript *script, uint32_t offset,
 76175:                          bool returnOnly = false);
 75760: 
 77353:     /* Mark any type set containing obj as having a generic object type. */
 77353:     void markSetsUnknown(JSContext *cx, TypeObject *obj);
 77353: 
 94740:     void sweep(FreeOp *fop);
 77353:     void finalizeObjects();
 75718: };
 75637: 
 75638: enum SpewChannel {
 75638:     ISpewOps,      /* ops: New constraints and types. */
 75638:     ISpewResult,   /* result: Final type sets. */
 75638:     SPEW_COUNT
 75638: };
 75638: 
 75638: #ifdef DEBUG
 75638: 
 76184: const char * InferSpewColorReset();
 76182: const char * InferSpewColor(TypeConstraint *constraint);
 76182: const char * InferSpewColor(TypeSet *types);
 76182: 
 75638: void InferSpew(SpewChannel which, const char *fmt, ...);
 77353: const char * TypeString(Type type);
 77461: const char * TypeObjectString(TypeObject *type);
 76128: 
 75737: /* Check that the type property for id in obj contains value. */
 75737: bool TypeHasProperty(JSContext *cx, TypeObject *obj, jsid id, const Value &value);
 75737: 
 75638: #else
 75638: 
 76182: inline const char * InferSpewColorReset() { return NULL; }
 76182: inline const char * InferSpewColor(TypeConstraint *constraint) { return NULL; }
 76182: inline const char * InferSpewColor(TypeSet *types) { return NULL; }
 75638: inline void InferSpew(SpewChannel which, const char *fmt, ...) {}
 77353: inline const char * TypeString(Type type) { return NULL; }
 77461: inline const char * TypeObjectString(TypeObject *type) { return NULL; }
 75638: 
 75638: #endif
 75638: 
 75640: /* Print a warning, dump state and abort the program. */
 75640: void TypeFailure(JSContext *cx, const char *fmt, ...);
 75640: 
 75615: } /* namespace types */
 75615: } /* namespace js */
 75615: 
 83276: namespace JS {
 83276:     template<> class AnchorPermitted<js::types::TypeObject *> { };
 83276: }
 83276: 
 75615: #endif // jsinfer_h___
