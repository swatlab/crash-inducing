    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
42549:   // So SSE.h will include emmintrin.h in an appropriate way:
42549: #define MOZILLA_SSE_INCLUDE_HEADER_FOR_SSE2
42549: 
    1: #include "nsUCSupport.h"
    1: #include "nsUTF8ToUnicode.h"
42549: #include "mozilla/SSE.h"
32176: 
    1: #define UNICODE_BYTE_ORDER_MARK    0xFEFF
    1: 
    1: //----------------------------------------------------------------------
    1: // Class nsUTF8ToUnicode [implementation]
    1: 
    1: nsUTF8ToUnicode::nsUTF8ToUnicode()
    1: : nsBasicDecoderSupport()
    1: {
    1:   Reset();
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // Subclassing of nsTableDecoderSupport class [implementation]
    1: 
    1: /**
    1:  * Normally the maximum length of the output of the UTF8 decoder in UTF16
    1:  *  code units is the same as the length of the input in UTF8 code units,
    1:  *  since 1-byte, 2-byte and 3-byte UTF-8 sequences decode to a single
    1:  *  UTF-16 character, and 4-byte UTF-8 sequences decode to a surrogate pair.
    1:  *
    1:  * However, there is an edge case where the output can be longer than the
    1:  *  input: if the previous buffer ended with an incomplete multi-byte
    1:  *  sequence and this buffer does not begin with a valid continuation
48213:  *  byte, we will return NS_ERROR_ILLEGAL_INPUT and the caller may insert a
    1:  *  replacement character in the output buffer which corresponds to no
    1:  *  character in the input buffer. So in the worst case the destination
    1:  *  will need to be one code unit longer than the source.
    1:  *  See bug 301797.
    1:  */
    1: NS_IMETHODIMP nsUTF8ToUnicode::GetMaxLength(const char * aSrc,
    1:                                             PRInt32 aSrcLength,
    1:                                             PRInt32 * aDestLength)
    1: {
    1:   *aDestLength = aSrcLength + 1;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // Subclassing of nsBasicDecoderSupport class [implementation]
    1: 
    1: NS_IMETHODIMP nsUTF8ToUnicode::Reset()
    1: {
    1: 
    1:   mUcs4  = 0;     // cached Unicode character
    1:   mState = 0;     // cached expected number of octets after the current octet
    1:                   // until the beginning of the next UTF8 character sequence
    1:   mBytes = 1;     // cached expected number of octets in the current sequence
    1:   mFirst = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // Subclassing of nsBasicDecoderSupport class [implementation]
    1: 
32176: // Fast ASCII -> UTF16 inner loop implementations
32176: //
32176: // Convert_ascii_run will update src and dst to the new values, and
32176: // len must be the maximum number ascii chars that it would be valid
32176: // to take from src and place into dst.  (That is, the minimum of the
32176: // number of bytes left in src and the number of unichars available in
32176: // dst.)
32176: 
42549: #ifdef MOZILLA_COMPILE_WITH_SSE2
32176: 
32176: static inline void
32176: Convert_ascii_run (const char *&src,
32176:                    PRUnichar *&dst,
32176:                    PRInt32 len)
32176: {
42549:   if (len > 15 && mozilla::use_sse2()) {
32176:     __m128i in, out1, out2;
32176:     __m128d *outp1, *outp2;
32176:     __m128i zeroes;
32176:     PRUint32 offset;
32176: 
32176:     // align input to 16 bytes
32176:     while ((NS_PTR_TO_UINT32(src) & 15) && len > 0) {
32176:       if (*src & 0x80U)
32176:         return;
32176:       *dst++ = (PRUnichar) *src++;
32176:       len--;
32176:     }
32176: 
32176:     zeroes = _mm_setzero_si128();
32176: 
32176:     offset = NS_PTR_TO_UINT32(dst) & 15;
32176: 
32176:     // Note: all these inner loops have to break, not return; we need
32176:     // to let the single-char loop below catch any leftover
32176:     // byte-at-a-time ASCII chars, since this function must consume
32176:     // all available ASCII chars before it returns
32176: 
32176:     if (offset == 0) {
32176:       while (len > 15) {
32176:         in = _mm_load_si128((__m128i *) src); 
32176:         if (_mm_movemask_epi8(in))
32176:           break;
32176:         out1 = _mm_unpacklo_epi8(in, zeroes);
32176:         out2 = _mm_unpackhi_epi8(in, zeroes);
32176:         _mm_stream_si128((__m128i *) dst, out1);
32176:         _mm_stream_si128((__m128i *) (dst + 8), out2);
32176:         dst += 16;
32176:         src += 16;
32176:         len -= 16;
32176:       }
32176:     } else if (offset == 8) {
32176:       outp1 = (__m128d *) &out1;
32176:       outp2 = (__m128d *) &out2;
32176:       while (len > 15) {
32176:         in = _mm_load_si128((__m128i *) src); 
32176:         if (_mm_movemask_epi8(in))
32176:           break;
32176:         out1 = _mm_unpacklo_epi8(in, zeroes);
32176:         out2 = _mm_unpackhi_epi8(in, zeroes);
32176:         _mm_storel_epi64((__m128i *) dst, out1);
32176:         _mm_storel_epi64((__m128i *) (dst + 8), out2);
32176:         _mm_storeh_pd((double *) (dst + 4), *outp1);
32176:         _mm_storeh_pd((double *) (dst + 12), *outp2);
32176:         src += 16;
32176:         dst += 16;
32176:         len -= 16;
32176:       }
32176:     } else {
32176:       while (len > 15) {
32176:         in = _mm_load_si128((__m128i *) src);
32176:         if (_mm_movemask_epi8(in))
32176:           break;
32176:         out1 = _mm_unpacklo_epi8(in, zeroes);
32176:         out2 = _mm_unpackhi_epi8(in, zeroes);
32176:         _mm_storeu_si128((__m128i *) dst, out1);
32176:         _mm_storeu_si128((__m128i *) (dst + 8), out2);
32176:         src += 16;
32176:         dst += 16;
32176:         len -= 16;
32176:       }
32176:     }
32176:   }
32176: 
32176:   // finish off a byte at a time
32176: 
32176:   while (len-- > 0 && (*src & 0x80U) == 0) {
32176:     *dst++ = (PRUnichar) *src++;
32176:   }
32176: }
32176: 
32176: #elif defined(__arm__) || defined(_M_ARM)
32176: 
32176: // on ARM, do extra work to avoid byte/halfword reads/writes by
32176: // reading/writing a word at a time for as long as we can
32176: static inline void
32176: Convert_ascii_run (const char *&src,
32176:                    PRUnichar *&dst,
32176:                    PRInt32 len)
32176: {
32176:   const PRUint32 *src32;
32176:   PRUint32 *dst32;
32176: 
32176:   // with some alignments, we'd never actually break out of the slow loop, so
32176:   // check and do the faster slow loop
32176:   if ((((NS_PTR_TO_UINT32(dst) & 3) == 0) && ((NS_PTR_TO_UINT32(src) & 1) == 0)) ||
32176:       (((NS_PTR_TO_UINT32(dst) & 3) == 2) && ((NS_PTR_TO_UINT32(src) & 1) == 1)))
32176:   {
32176:     while (((NS_PTR_TO_UINT32(src) & 3) ||
32176:             (NS_PTR_TO_UINT32(dst) & 3)) &&
32176:            len > 0)
32176:     {
32176:       if (*src & 0x80U)
32176:         return;
32176:       *dst++ = (PRUnichar) *src++;
32176:       len--;
32176:     }
32176:   } else {
32176:     goto finish;
32176:   }
32176: 
32176:   // then go 4 bytes at a time
32176:   src32 = (const PRUint32*) src;
32176:   dst32 = (PRUint32*) dst;
32176: 
32176:   while (len > 4) {
32176:     PRUint32 in = *src32++;
32176: 
32176:     if (in & 0x80808080U) {
32176:       src32--;
32176:       break;
32176:     }
32176: 
32176:     *dst32++ = ((in & 0x000000ff) >>  0) | ((in & 0x0000ff00) << 8);
32176:     *dst32++ = ((in & 0x00ff0000) >> 16) | ((in & 0xff000000) >> 8);
32176: 
32176:     len -= 4;
32176:   }
32176: 
32176:   src = (const char *) src32;
32176:   dst = (PRUnichar *) dst32;
32176: 
32176: finish:
32176:   while (len-- > 0 && (*src & 0x80U) == 0) {
32176:     *dst++ = (PRUnichar) *src++;
32176:   }
32176: }
32176: 
32176: #else /* generic code */
32176: 
32176: static inline void
32176: Convert_ascii_run (const char *&src,
32176:                    PRUnichar *&dst,
32176:                    PRInt32 len)
32176: {
32176:   while (len-- > 0 && (*src & 0x80U) == 0) {
32176:     *dst++ = (PRUnichar) *src++;
32176:   }
32176: }
32176: 
32176: #endif
    1: 
    1: NS_IMETHODIMP nsUTF8ToUnicode::Convert(const char * aSrc,
    1:                                        PRInt32 * aSrcLength,
    1:                                        PRUnichar * aDest,
    1:                                        PRInt32 * aDestLength)
    1: {
    1:   PRUint32 aSrcLen   = (PRUint32) (*aSrcLength);
    1:   PRUint32 aDestLen = (PRUint32) (*aDestLength);
    1: 
    1:   const char *in, *inend;
    1:   inend = aSrc + aSrcLen;
    1: 
    1:   PRUnichar *out, *outend;
    1:   outend = aDest + aDestLen;
    1: 
    1:   nsresult res = NS_OK; // conversion result
    1: 
32176:   // alias these locally for speed
32176:   PRInt32 mUcs4 = this->mUcs4;
32176:   PRUint8 mState = this->mState;
32176:   PRUint8 mBytes = this->mBytes;
32176:   PRUint8 mFirst = this->mFirst;
32176: 
    1:   // Set mFirst to PR_FALSE now so we don't have to every time through the ASCII
    1:   // branch within the loop.
    1:   if (mFirst && aSrcLen && (0 == (0x80 & (*aSrc))))
    1:     mFirst = PR_FALSE;
    1: 
    1:   for (in = aSrc, out = aDest; ((in < inend) && (out < outend)); ++in) {
    1:     if (0 == mState) {
    1:       // When mState is zero we expect either a US-ASCII character or a
    1:       // multi-octet sequence.
    1:       if (0 == (0x80 & (*in))) {
32176:         PRInt32 max_loops = PR_MIN(inend - in, outend - out);
32176:         Convert_ascii_run(in, out, max_loops);
32176:         --in; // match the rest of the cases
    1:         mBytes = 1;
    1:       } else if (0xC0 == (0xE0 & (*in))) {
    1:         // First octet of 2 octet sequence
    1:         mUcs4 = (PRUint32)(*in);
    1:         mUcs4 = (mUcs4 & 0x1F) << 6;
    1:         mState = 1;
    1:         mBytes = 2;
    1:       } else if (0xE0 == (0xF0 & (*in))) {
    1:         // First octet of 3 octet sequence
    1:         mUcs4 = (PRUint32)(*in);
    1:         mUcs4 = (mUcs4 & 0x0F) << 12;
    1:         mState = 2;
    1:         mBytes = 3;
    1:       } else if (0xF0 == (0xF8 & (*in))) {
    1:         // First octet of 4 octet sequence
    1:         mUcs4 = (PRUint32)(*in);
    1:         mUcs4 = (mUcs4 & 0x07) << 18;
    1:         mState = 3;
    1:         mBytes = 4;
    1:       } else if (0xF8 == (0xFC & (*in))) {
    1:         /* First octet of 5 octet sequence.
    1:          *
    1:          * This is illegal because the encoded codepoint must be either
    1:          * (a) not the shortest form or
    1:          * (b) outside the Unicode range of 0-0x10FFFF.
    1:          * Rather than trying to resynchronize, we will carry on until the end
    1:          * of the sequence and let the later error handling code catch it.
    1:          */
    1:         mUcs4 = (PRUint32)(*in);
    1:         mUcs4 = (mUcs4 & 0x03) << 24;
    1:         mState = 4;
    1:         mBytes = 5;
    1:       } else if (0xFC == (0xFE & (*in))) {
    1:         // First octet of 6 octet sequence, see comments for 5 octet sequence.
    1:         mUcs4 = (PRUint32)(*in);
    1:         mUcs4 = (mUcs4 & 1) << 30;
    1:         mState = 5;
    1:         mBytes = 6;
    1:       } else {
    1:         /* Current octet is neither in the US-ASCII range nor a legal first
    1:          * octet of a multi-octet sequence.
    1:          *
    1:          * Return an error condition. Caller is responsible for flushing and
    1:          * refilling the buffer and resetting state.
    1:          */
48213:         res = NS_ERROR_ILLEGAL_INPUT;
    1:         break;
    1:       }
    1:     } else {
    1:       // When mState is non-zero, we expect a continuation of the multi-octet
    1:       // sequence
    1:       if (0x80 == (0xC0 & (*in))) {
    1:         // Legal continuation.
    1:         PRUint32 shift = (mState - 1) * 6;
    1:         PRUint32 tmp = *in;
    1:         tmp = (tmp & 0x0000003FL) << shift;
    1:         mUcs4 |= tmp;
    1: 
    1:         if (0 == --mState) {
    1:           /* End of the multi-octet sequence. mUcs4 now contains the final
    1:            * Unicode codepoint to be output
    1:            *
    1:            * Check for illegal sequences and codepoints.
    1:            */
    1: 
    1:           // From Unicode 3.1, non-shortest form is illegal
    1:           if (((2 == mBytes) && (mUcs4 < 0x0080)) ||
    1:               ((3 == mBytes) && (mUcs4 < 0x0800)) ||
    1:               ((4 == mBytes) && (mUcs4 < 0x10000)) ||
    1:               (4 < mBytes) ||
    1:               // From Unicode 3.2, surrogate characters are illegal
    1:               ((mUcs4 & 0xFFFFF800) == 0xD800) ||
    1:               // Codepoints outside the Unicode range are illegal
    1:               (mUcs4 > 0x10FFFF)) {
48213:             res = NS_ERROR_ILLEGAL_INPUT;
    1:             break;
    1:           }
    1:           if (mUcs4 > 0xFFFF) {
    1:             // mUcs4 is in the range 0x10000 - 0x10FFFF. Output a UTF-16 pair
    1:             mUcs4 -= 0x00010000;
    1:             *out++ = 0xD800 | (0x000003FF & (mUcs4 >> 10));
    1:             *out++ = 0xDC00 | (0x000003FF & mUcs4);
    1:           } else if (UNICODE_BYTE_ORDER_MARK != mUcs4 || !mFirst) {
    1:             // Don't output the BOM only if it is the first character
    1:             *out++ = mUcs4;
    1:           }
    1:           //initialize UTF8 cache
    1:           mUcs4  = 0;
    1:           mState = 0;
    1:           mBytes = 1;
    1:           mFirst = PR_FALSE;
    1:         }
    1:       } else {
    1:         /* ((0xC0 & (*in) != 0x80) && (mState != 0))
    1:          * 
    1:          * Incomplete multi-octet sequence. Unconsume this
    1:          * octet and return an error condition. Caller is responsible
    1:          * for flushing and refilling the buffer and resetting state.
    1:          */
    1:         in--;
48213:         res = NS_ERROR_ILLEGAL_INPUT;
    1:         break;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // output not finished, output buffer too short
    1:   if ((NS_OK == res) && (in < inend) && (out >= outend))
    1:     res = NS_OK_UDEC_MOREOUTPUT;
    1: 
    1:   // last UCS4 is incomplete, make sure the caller
    1:   // returns with properly aligned continuation of the buffer
    1:   if ((NS_OK == res) && (mState != 0))
    1:     res = NS_OK_UDEC_MOREINPUT;
    1: 
    1:   *aSrcLength = in - aSrc;
    1:   *aDestLength = out - aDest;
    1: 
32176:   this->mUcs4 = mUcs4;
32176:   this->mState = mState;
32176:   this->mBytes = mBytes;
32176:   this->mFirst = mFirst;
32176: 
    1:   return(res);
    1: }
