50525: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
50525: /* ***** BEGIN LICENSE BLOCK *****
50525:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
50525:  *
50525:  * The contents of this file are subject to the Mozilla Public License Version
50525:  * 1.1 (the "License"); you may not use this file except in compliance with
50525:  * the License. You may obtain a copy of the License at
50525:  * http://www.mozilla.org/MPL/
50525:  *
50525:  * Software distributed under the License is distributed on an "AS IS" basis,
50525:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
50525:  * for the specific language governing rights and limitations under the
50525:  * License.
50525:  *
50525:  * The Original Code is mozilla.org code.
50525:  *
50525:  * The Initial Developer of the Original Code is
50525:  * Mozilla Foundation.
50525:  * Portions created by the Initial Developer are Copyright (C) 2010
50525:  * the Initial Developer. All Rights Reserved.
50525:  *
50525:  * Contributor(s):
51578:  *   Jonathan Griffin <jgriffin@mozilla.com>
50525:  *
50525:  * Alternatively, the contents of this file may be used under the terms of
50525:  * either the GNU General Public License Version 2 or later (the "GPL"), or
50525:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
50525:  * in which case the provisions of the GPL or the LGPL are applicable instead
50525:  * of those above. If you wish to allow use of your version of this file only
50525:  * under the terms of either the GPL or the LGPL, and not to allow others to
50525:  * use your version of this file under the terms of the MPL, indicate your
50525:  * decision by deleting the provisions above and replace them with the notice
50525:  * and other provisions required by the GPL or the LGPL. If you do not delete
50525:  * the provisions above, a recipient may use your version of this file under
50525:  * the terms of any one of the MPL, the GPL or the LGPL.
50525:  *
50525:  * ***** END LICENSE BLOCK ***** */
50525: 
80467: #include "mozilla/Util.h"
80467: 
51578: #include <windows.h>
61175: #include <setupapi.h>
50525: #include "gfxWindowsPlatform.h"
50525: #include "GfxInfo.h"
59414: #include "GfxInfoWebGL.h"
51578: #include "nsUnicharUtils.h"
51578: #include "mozilla/FunctionTimer.h"
56956: #include "prenv.h"
56956: #include "prprf.h"
60890: #include "GfxDriverInfo.h"
72430: #include "mozilla/Preferences.h"
84604: #include "nsPrintfCString.h"
50525: 
70361: #if defined(MOZ_CRASHREPORTER)
51579: #include "nsExceptionHandler.h"
51579: #include "nsICrashReporter.h"
51579: #define NS_CRASHREPORTER_CONTRACTID "@mozilla.org/toolkit/crash-reporter;1"
51579: #endif
51579: 
80467: using namespace mozilla;
50525: using namespace mozilla::widget;
50525: 
60896: #ifdef DEBUG
60896: NS_IMPL_ISUPPORTS_INHERITED1(GfxInfo, GfxInfoBase, nsIGfxInfoDebug)
60896: #endif
60896: 
61025: static const PRUint32 allWindowsVersions = 0xffffffff;
61594: 
61025: #define V(a,b,c,d) GFX_DRIVER_VERSION(a,b,c,d)
61025: 
61025: 
60895: GfxInfo::GfxInfo()
84604:  :  mWindowsVersion(0),
79626:     mHasDualGPU(false),
79626:     mIsGPU2Active(false)
60895: {
60895: }
60895: 
51677: /* GetD2DEnabled and GetDwriteEnabled shouldn't be called until after gfxPlatform initialization
51677:  * has occurred because they depend on it for information. (See bug 591561) */
51736: nsresult
79445: GfxInfo::GetD2DEnabled(bool *aEnabled)
50525: {
50525:   *aEnabled = gfxWindowsPlatform::GetPlatform()->GetRenderMode() == gfxWindowsPlatform::RENDER_DIRECT2D;
50525:   return NS_OK;
50525: }
50655: 
51736: nsresult
79445: GfxInfo::GetDWriteEnabled(bool *aEnabled)
50655: {
50655:   *aEnabled = gfxWindowsPlatform::GetPlatform()->DWriteEnabled();
50655:   return NS_OK;
50655: }
51578: 
72430: nsresult
79445: GfxInfo::GetAzureEnabled(bool *aEnabled)
72430: {
79626:   *aEnabled = false;
72430: 
79445:   bool d2dEnabled = 
72430:     gfxWindowsPlatform::GetPlatform()->GetRenderMode() == gfxWindowsPlatform::RENDER_DIRECT2D;
72430: 
72430:   if (d2dEnabled) {
79445:     bool azure = false;
72430:     nsresult rv = mozilla::Preferences::GetBool("gfx.canvas.azure.enabled", &azure);
72430: 
72430:     if (NS_SUCCEEDED(rv) && azure) {
79626:       *aEnabled = true;
72430:     }
72430:   }
72430: 
72430:   return NS_OK;
72430: }
72430: 
60493: /* readonly attribute DOMString DWriteVersion; */
60493: NS_IMETHODIMP
60493: GfxInfo::GetDWriteVersion(nsAString & aDwriteVersion)
60493: {
69151:   gfxWindowsPlatform::GetDLLVersion(L"dwrite.dll", aDwriteVersion);
60493:   return NS_OK;
60493: }
60493: 
69664: #define PIXEL_STRUCT_RGB  1
69664: #define PIXEL_STRUCT_BGR  2
69664: 
69664: /* readonly attribute DOMString cleartypeParameters; */
69664: NS_IMETHODIMP
69664: GfxInfo::GetCleartypeParameters(nsAString & aCleartypeParams)
69664: {
69664:   nsTArray<ClearTypeParameterInfo> clearTypeParams;
69664: 
69664:   gfxWindowsPlatform::GetPlatform()->GetCleartypeParams(clearTypeParams);
69664:   PRUint32 d, numDisplays = clearTypeParams.Length();
69664:   bool displayNames = (numDisplays > 1);
69664:   bool foundData = false;
69664:   nsString outStr;
69664:   WCHAR valStr[256];
69664: 
69664:   for (d = 0; d < numDisplays; d++) {
69664:     ClearTypeParameterInfo& params = clearTypeParams[d];
69664: 
69664:     if (displayNames) {
80467:       swprintf_s(valStr, ArrayLength(valStr),
69664:                  L"%s [ ", params.displayName.get());
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (params.gamma >= 0) {
69664:       foundData = true;
80467:       swprintf_s(valStr, ArrayLength(valStr),
69664:                  L"Gamma: %d ", params.gamma);
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (params.pixelStructure >= 0) {
69664:       foundData = true;
69664:       if (params.pixelStructure == PIXEL_STRUCT_RGB ||
69664:           params.pixelStructure == PIXEL_STRUCT_BGR)
69664:       {
80467:         swprintf_s(valStr, ArrayLength(valStr),
69664:                    L"Pixel Structure: %s ",
69664:                    (params.pixelStructure == PIXEL_STRUCT_RGB ?
69664:                       L"RGB" : L"BGR"));
69664:       } else {
80467:         swprintf_s(valStr, ArrayLength(valStr),
69664:                    L"Pixel Structure: %d ", params.pixelStructure);
69664:       }
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (params.clearTypeLevel >= 0) {
69664:       foundData = true;
80467:       swprintf_s(valStr, ArrayLength(valStr),
69664:                  L"ClearType Level: %d ", params.clearTypeLevel);
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (params.enhancedContrast >= 0) {
69664:       foundData = true;
80467:       swprintf_s(valStr, ArrayLength(valStr),
69664:                  L"Enhanced Contrast: %d ", params.enhancedContrast);
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (displayNames) {
69664:       outStr.Append(L"] ");
69664:     }
69664:   }
69664: 
69664:   if (foundData) {
69664:     aCleartypeParams.Assign(outStr);
69664:     return NS_OK;
69664:   }
69664:   return NS_ERROR_FAILURE;
69664: }
69664: 
54670: static nsresult GetKeyValue(const WCHAR* keyLocation, const WCHAR* keyName, nsAString& destString, int type)
51578: {
51578:   HKEY key;
51578:   DWORD dwcbData;
51578:   DWORD dValue;
51676:   DWORD resultType;
51578:   LONG result;
51578:   nsresult retval = NS_OK;
51578: 
51578:   result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, keyLocation, 0, KEY_QUERY_VALUE, &key);
51578:   if (result != ERROR_SUCCESS) {
51578:     return NS_ERROR_FAILURE;
51578:   }
51578: 
51578:   switch (type) {
51578:     case REG_DWORD: {
51578:       // We only use this for vram size
51578:       dwcbData = sizeof(dValue);
51676:       result = RegQueryValueExW(key, keyName, NULL, &resultType, (LPBYTE)&dValue, &dwcbData);
51676:       if (result == ERROR_SUCCESS && resultType == REG_DWORD) {
51676:         dValue = dValue / 1024 / 1024;
54145:         destString.AppendInt(PRInt32(dValue));
51676:       } else {
51578:         retval = NS_ERROR_FAILURE;
51578:       }
51578:       break;
51578:     }
51578:     case REG_MULTI_SZ: {
51578:       // A chain of null-separated strings; we convert the nulls to spaces
51676:       WCHAR wCharValue[1024];
51676:       dwcbData = sizeof(wCharValue);
51676: 
51676:       result = RegQueryValueExW(key, keyName, NULL, &resultType, (LPBYTE)wCharValue, &dwcbData);
51676:       if (result == ERROR_SUCCESS && resultType == REG_MULTI_SZ) {
51676:         // This bit here could probably be cleaner.
51676:         bool isValid = false;
51676: 
51676:         DWORD strLen = dwcbData/sizeof(wCharValue[0]);
51676:         for (DWORD i = 0; i < strLen; i++) {
51676:           if (wCharValue[i] == '\0') {
51676:             if (i < strLen - 1 && wCharValue[i + 1] == '\0') {
51676:               isValid = true;
51676:               break;
51676:             } else {
51676:               wCharValue[i] = ' ';
51676:             }
51676:           }
51676:         }
51676: 
51676:         // ensure wCharValue is null terminated
51676:         wCharValue[strLen-1] = '\0';
51676: 
51676:         if (isValid)
51676:           destString = wCharValue;
51676: 
51676:       } else {
51578:         retval = NS_ERROR_FAILURE;
51578:       }
51676: 
51578:       break;
51578:     }
51578:   }
51578:   RegCloseKey(key);
51578: 
51578:   return retval;
51578: }
51578: 
51578: // The driver ID is a string like PCI\VEN_15AD&DEV_0405&SUBSYS_040515AD, possibly
51578: // followed by &REV_XXXX.  We uppercase the string, and strip the &REV_ part
51578: // from it, if found.
54670: static void normalizeDriverId(nsString& driverid) {
51578:   ToUpperCase(driverid);
51578:   PRInt32 rev = driverid.Find(NS_LITERAL_CSTRING("&REV_"));
51578:   if (rev != -1) {
51578:     driverid.Cut(rev, driverid.Length());
51578:   }
51578: }
51578: 
61175: // Setup API functions
61175: typedef HDEVINFO (WINAPI*SetupDiGetClassDevsWFunc)(
61175:   CONST GUID *ClassGuid,
61175:   PCWSTR Enumerator,
61175:   HWND hwndParent,
61175:   DWORD Flags
61175: );
61175: typedef BOOL (WINAPI*SetupDiEnumDeviceInfoFunc)(
61175:   HDEVINFO DeviceInfoSet,
61175:   DWORD MemberIndex,
61175:   PSP_DEVINFO_DATA DeviceInfoData
61175: );
61175: typedef BOOL (WINAPI*SetupDiGetDeviceRegistryPropertyWFunc)(
61175:   HDEVINFO DeviceInfoSet,
61175:   PSP_DEVINFO_DATA DeviceInfoData,
61175:   DWORD Property,
61175:   PDWORD PropertyRegDataType,
61175:   PBYTE PropertyBuffer,
61175:   DWORD PropertyBufferSize,
61175:   PDWORD RequiredSize
61175: );
61175: typedef BOOL (WINAPI*SetupDiDestroyDeviceInfoListFunc)(
61175:   HDEVINFO DeviceInfoSet
61175: );
61175: 
76921: // The device ID is a string like PCI\VEN_15AD&DEV_0405&SUBSYS_040515AD
76921: // this function is used to extract the id's out of it
76921: PRUint32
76921: ParseIDFromDeviceID(const nsAString &key, const char *prefix, int length)
76921: {
76921:   nsAutoString id(key);
76921:   ToUpperCase(id);
76921:   PRInt32 start = id.Find(prefix);
76921:   if (start != -1) {
76921:     id.Cut(0, start + strlen(prefix));
76921:     id.Truncate(length);
76921:   }
76921:   nsresult err;
76921:   return id.ToInteger(&err, 16);
76921: }
51578: 
51578: /* Other interesting places for info:
51578:  *   IDXGIAdapter::GetDesc()
51578:  *   IDirectDraw7::GetAvailableVidMem()
51578:  *   e->GetAvailableTextureMem()
51578:  * */
51578: 
51578: #define DEVICE_KEY_PREFIX L"\\Registry\\Machine\\"
60893: nsresult
51736: GfxInfo::Init()
51578: {
51578:   NS_TIME_FUNCTION;
51578: 
60893:   nsresult rv = GfxInfoBase::Init();
60893: 
51676:   DISPLAY_DEVICEW displayDevice;
51676:   displayDevice.cb = sizeof(displayDevice);
51578:   int deviceIndex = 0;
51578: 
58229:   mDeviceKeyDebug = NS_LITERAL_STRING("PrimarySearch");
58229: 
51676:   while (EnumDisplayDevicesW(NULL, deviceIndex, &displayDevice, 0)) {
58229:     if (displayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) {
58229:       mDeviceKeyDebug = NS_LITERAL_STRING("NullSearch");
51578:       break;
58229:     }
51578:     deviceIndex++;
51578:   }
51578: 
51578:   // make sure the string is NULL terminated
80467:   if (wcsnlen(displayDevice.DeviceKey, ArrayLength(displayDevice.DeviceKey))
80467:       == ArrayLength(displayDevice.DeviceKey)) {
51578:     // we did not find a NULL
60893:     return rv;
51578:   }
51578: 
58229:   mDeviceKeyDebug = displayDevice.DeviceKey;
58229: 
58229:   /* DeviceKey is "reserved" according to MSDN so we'll be careful with it */
58229:   /* check that DeviceKey begins with DEVICE_KEY_PREFIX */
58229:   /* some systems have a DeviceKey starting with \REGISTRY\Machine\ so we need to compare case insenstively */
80467:   if (_wcsnicmp(displayDevice.DeviceKey, DEVICE_KEY_PREFIX, ArrayLength(DEVICE_KEY_PREFIX)-1) != 0)
60893:     return rv;
58229: 
51578:   // chop off DEVICE_KEY_PREFIX
80467:   mDeviceKey = displayDevice.DeviceKey + ArrayLength(DEVICE_KEY_PREFIX)-1;
51578: 
51676:   mDeviceID = displayDevice.DeviceID;
51676:   mDeviceString = displayDevice.DeviceString;
51578: 
51578: 
61175:   HMODULE setupapi = LoadLibraryW(L"setupapi.dll");
51578: 
61175:   if (setupapi) {
61175:     SetupDiGetClassDevsWFunc setupGetClassDevs = (SetupDiGetClassDevsWFunc)
61175:       GetProcAddress(setupapi, "SetupDiGetClassDevsW");
61175:     SetupDiEnumDeviceInfoFunc setupEnumDeviceInfo = (SetupDiEnumDeviceInfoFunc)
61175:       GetProcAddress(setupapi, "SetupDiEnumDeviceInfo");
61175:     SetupDiGetDeviceRegistryPropertyWFunc setupGetDeviceRegistryProperty = (SetupDiGetDeviceRegistryPropertyWFunc)
61175:       GetProcAddress(setupapi, "SetupDiGetDeviceRegistryPropertyW");
61175:     SetupDiDestroyDeviceInfoListFunc setupDestroyDeviceInfoList = (SetupDiDestroyDeviceInfoListFunc)
61175:       GetProcAddress(setupapi, "SetupDiDestroyDeviceInfoList");
61175: 
61175:     if (setupGetClassDevs &&
61175:         setupEnumDeviceInfo &&
61175:         setupGetDeviceRegistryProperty &&
61175:         setupDestroyDeviceInfoList) {
61175:       /* create a device information set composed of the current display device */
72255:       HDEVINFO devinfo = setupGetClassDevs(NULL, mDeviceID.get(), NULL,
61175:                                            DIGCF_PRESENT | DIGCF_PROFILE | DIGCF_ALLCLASSES);
61175: 
61175:       if (devinfo != INVALID_HANDLE_VALUE) {
61175:         HKEY key;
61175:         LONG result;
61175:         WCHAR value[255];
61175:         DWORD dwcbData;
61175:         SP_DEVINFO_DATA devinfoData;
61175:         DWORD memberIndex = 0;
61175: 
61175:         devinfoData.cbSize = sizeof(devinfoData);
61175:         NS_NAMED_LITERAL_STRING(driverKeyPre, "System\\CurrentControlSet\\Control\\Class\\");
61175:         /* enumerate device information elements in the device information set */
61175:         while (setupEnumDeviceInfo(devinfo, memberIndex++, &devinfoData)) {
61175:           /* get a string that identifies the device's driver key */
61175:           if (setupGetDeviceRegistryProperty(devinfo,
61175:                                              &devinfoData,
61175:                                              SPDRP_DRIVER,
61175:                                              NULL,
61175:                                              (PBYTE)value,
61175:                                              sizeof(value),
61175:                                              NULL)) {
61175:             nsAutoString driverKey(driverKeyPre);
61175:             driverKey += value;
61175:             result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, driverKey.BeginReading(), 0, KEY_QUERY_VALUE, &key);
61175:             if (result == ERROR_SUCCESS) {
61175:               /* we've found the driver we're looking for */
61175:               dwcbData = sizeof(value);
61175:               result = RegQueryValueExW(key, L"DriverVersion", NULL, NULL, (LPBYTE)value, &dwcbData);
61175:               if (result == ERROR_SUCCESS)
61175:                 mDriverVersion = value;
61175:               dwcbData = sizeof(value);
61175:               result = RegQueryValueExW(key, L"DriverDate", NULL, NULL, (LPBYTE)value, &dwcbData);
61175:               if (result == ERROR_SUCCESS)
61175:                 mDriverDate = value;
61175:               RegCloseKey(key); 
61175:               break;
61175:             }
61175:           }
51578:         }
51578: 
61175:         setupDestroyDeviceInfoList(devinfo);
51578:       }
82073: 
84604:       mAdapterVendorID.AppendPrintf("0x%04x", ParseIDFromDeviceID(mDeviceID, "VEN_", 4));
84604:       mAdapterDeviceID.AppendPrintf("0x%04x", ParseIDFromDeviceID(mDeviceID, "&DEV_", 4));
82073:       mAdapterSubsysID  = ParseIDFromDeviceID(mDeviceID,  "&SUBSYS_", 8);
82073: 
82073:       // We now check for second display adapter.
82073: 
82073:       // Device interface class for display adapters.
82073:       CLSID GUID_DISPLAY_DEVICE_ARRIVAL;
82073:       HRESULT hresult = CLSIDFromString(L"{1CA05180-A699-450A-9A0C-DE4FBE3DDD89}",
82073:                                    &GUID_DISPLAY_DEVICE_ARRIVAL);
82073:       if (hresult == NOERROR) {
82073:         devinfo = setupGetClassDevs(&GUID_DISPLAY_DEVICE_ARRIVAL, NULL, NULL,
82073:                                            DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
82073: 
82073:         if (devinfo != INVALID_HANDLE_VALUE) {
82073:           HKEY key;
82073:           LONG result;
82073:           WCHAR value[255];
82073:           DWORD dwcbData;
82073:           SP_DEVINFO_DATA devinfoData;
82073:           DWORD memberIndex = 0;
82073:           devinfoData.cbSize = sizeof(devinfoData);
82073: 
82073:           nsAutoString adapterDriver2;
82073:           nsAutoString deviceID2;
82073:           nsAutoString driverVersion2;
82073:           nsAutoString driverDate2;
82073:           PRUint32 adapterVendorID2;
82073:           PRUint32 adapterDeviceID2;
82073: 
82073:           NS_NAMED_LITERAL_STRING(driverKeyPre, "System\\CurrentControlSet\\Control\\Class\\");
82073:           /* enumerate device information elements in the device information set */
82073:           while (setupEnumDeviceInfo(devinfo, memberIndex++, &devinfoData)) {
82073:             /* get a string that identifies the device's driver key */
82073:             if (setupGetDeviceRegistryProperty(devinfo,
82073:                                                &devinfoData,
82073:                                                SPDRP_DRIVER,
82073:                                                NULL,
82073:                                                (PBYTE)value,
82073:                                                sizeof(value),
82073:                                                NULL)) {
82073:               nsAutoString driverKey2(driverKeyPre);
82073:               driverKey2 += value;
82073:               result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, driverKey2.BeginReading(), 0, KEY_QUERY_VALUE, &key);
82073:               if (result == ERROR_SUCCESS) {
82073:                 dwcbData = sizeof(value);
82073:                 result = RegQueryValueExW(key, L"MatchingDeviceId", NULL, NULL, (LPBYTE)value, &dwcbData);
82073:                 if (result != ERROR_SUCCESS) {
82073:                   continue;
82073:                 }
82073:                 deviceID2 = value;
84604:                 nsAutoString adapterVendorID2String;
84604:                 nsAutoString adapterDeviceID2String;
82073:                 adapterVendorID2 = ParseIDFromDeviceID(deviceID2, "VEN_", 4);
84604:                 adapterVendorID2String.AppendPrintf("0x%04x", adapterVendorID2);
82073:                 adapterDeviceID2 = ParseIDFromDeviceID(deviceID2, "&DEV_", 4);
84604:                 adapterDeviceID2String.AppendPrintf("0x%04x", adapterDeviceID2);
84604:                 if (mAdapterVendorID == adapterVendorID2String &&
84604:                     mAdapterDeviceID == adapterDeviceID2String) {
82073:                   RegCloseKey(key);
82073:                   continue;
82073:                 }
82073: 
82073:                 // If this device is missing driver information, it is unlikely to
82073:                 // be a real display adapter.
82073:                 if (NS_FAILED(GetKeyValue(driverKey2.BeginReading(), L"InstalledDisplayDrivers",
82073:                                adapterDriver2, REG_MULTI_SZ))) {
82073:                   RegCloseKey(key);
82073:                   continue;
82073:                 }
82073:                 dwcbData = sizeof(value);
82073:                 result = RegQueryValueExW(key, L"DriverVersion", NULL, NULL, (LPBYTE)value, &dwcbData);
82073:                 if (result != ERROR_SUCCESS) {
82073:                   RegCloseKey(key);
82073:                   continue;
82073:                 }
82073:                 driverVersion2 = value;
82073:                 dwcbData = sizeof(value);
82073:                 result = RegQueryValueExW(key, L"DriverDate", NULL, NULL, (LPBYTE)value, &dwcbData);
82073:                 if (result != ERROR_SUCCESS) {
82073:                   RegCloseKey(key);
82073:                   continue;
82073:                 }
82073:                 driverDate2 = value;
82073:                 dwcbData = sizeof(value);
82073:                 result = RegQueryValueExW(key, L"Device Description", NULL, NULL, (LPBYTE)value, &dwcbData);
82073:                 RegCloseKey(key);
82073:                 if (result == ERROR_SUCCESS) {
82073:                   mHasDualGPU = true;
82073:                   mDeviceString2 = value;
82073:                   mDeviceID2 = deviceID2;
82073:                   mDeviceKey2 = driverKey2;
82073:                   mDriverVersion2 = driverVersion2;
82073:                   mDriverDate2 = driverDate2;
84604:                   mAdapterVendorID2.AppendPrintf("0x%04x", adapterVendorID2);
84604:                   mAdapterDeviceID2.AppendPrintf("0x%04x", adapterDeviceID2);
82073:                   mAdapterSubsysID2 = ParseIDFromDeviceID(mDeviceID2, "&SUBSYS_", 8);
82073:                   break;
82073:                 }
82073:               }
82073:             }
82073:           }
82073: 
82073:           setupDestroyDeviceInfoList(devinfo);
82073:         }
82073:       }
82073: 
82073: 
51578:     }
51578: 
61175:     FreeLibrary(setupapi);
61175:   }
51579: 
60895:   const char *spoofedDriverVersionString = PR_GetEnv("MOZ_GFX_SPOOF_DRIVER_VERSION");
60895:   if (spoofedDriverVersionString) {
60895:     mDriverVersion.AssignASCII(spoofedDriverVersionString);
60895:   }
60895: 
60895:   const char *spoofedVendor = PR_GetEnv("MOZ_GFX_SPOOF_VENDOR_ID");
60895:   if (spoofedVendor) {
84604:     mAdapterVendorID.AssignASCII(spoofedVendor);
60895:   }
60895: 
79626:   mHasDriverVersionMismatch = false;
84604:   if (mAdapterVendorID == GfxDriverInfo::GetDeviceVendor(VendorIntel)) {
61025:     // we've had big crashers (bugs 590373 and 595364) apparently correlated
69151:     // with bad Intel driver installations where the DriverVersion reported
69151:     // by the registry was not the version of the DLL.
79445:     bool is64bitApp = sizeof(void*) == 8;
61526:     const PRUnichar *dllFileName = is64bitApp
61025:                                  ? L"igd10umd64.dll"
61025:                                  : L"igd10umd32.dll";
61025:     nsString dllVersion;
69151:     gfxWindowsPlatform::GetDLLVersion((PRUnichar*)dllFileName, dllVersion);
61025: 
61025:     PRUint64 dllNumericVersion = 0, driverNumericVersion = 0;
61025:     ParseDriverVersion(dllVersion, &dllNumericVersion);
61025:     ParseDriverVersion(mDriverVersion, &driverNumericVersion);
61025: 
69151:     // if GetDLLVersion fails, it gives "0.0.0.0"
69151:     // so if GetDLLVersion failed, we get dllNumericVersion = 0
61025:     // so this test implicitly handles the case where GetDLLVersion failed
61025:     if (dllNumericVersion != driverNumericVersion)
79626:       mHasDriverVersionMismatch = true;
61025:   }
61025: 
60895:   const char *spoofedDevice = PR_GetEnv("MOZ_GFX_SPOOF_DEVICE_ID");
60895:   if (spoofedDevice) {
84604:     mAdapterDeviceID.AssignASCII(spoofedDevice);
60895:   }
60895: 
60896:   const char *spoofedWindowsVersion = PR_GetEnv("MOZ_GFX_SPOOF_WINDOWS_VERSION");
60896:   if (spoofedWindowsVersion) {
60896:     PR_sscanf(spoofedWindowsVersion, "%x", &mWindowsVersion);
60896:   } else {
60896:     mWindowsVersion = gfxWindowsPlatform::WindowsOSVersion();
60896:   }
60896: 
60893:   AddCrashReportAnnotations();
51579: 
60893:   return rv;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDescription; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDescription(nsAString & aAdapterDescription)
51578: {
51578:   aAdapterDescription = mDeviceString;
51578:   return NS_OK;
51578: }
51578: 
76321: /* readonly attribute DOMString adapterDescription2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDescription2(nsAString & aAdapterDescription)
76321: {
76321:   aAdapterDescription = mDeviceString2;
76321:   return NS_OK;
76321: }
76321: 
51578: /* readonly attribute DOMString adapterRAM; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterRAM(nsAString & aAdapterRAM)
51578: {
51578:   if (NS_FAILED(GetKeyValue(mDeviceKey.BeginReading(), L"HardwareInformation.MemorySize", aAdapterRAM, REG_DWORD)))
51578:     aAdapterRAM = L"Unknown";
51578:   return NS_OK;
51578: }
51578: 
76321: /* readonly attribute DOMString adapterRAM2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterRAM2(nsAString & aAdapterRAM)
76321: {
82073:   if (!mHasDualGPU) {
82073:     aAdapterRAM.AssignLiteral("");
82073:   } else if (NS_FAILED(GetKeyValue(mDeviceKey2.BeginReading(), L"HardwareInformation.MemorySize", aAdapterRAM, REG_DWORD))) {
76321:     aAdapterRAM = L"Unknown";
82073:   }
76321:   return NS_OK;
76321: }
76321: 
51578: /* readonly attribute DOMString adapterDriver; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDriver(nsAString & aAdapterDriver)
51578: {
51578:   if (NS_FAILED(GetKeyValue(mDeviceKey.BeginReading(), L"InstalledDisplayDrivers", aAdapterDriver, REG_MULTI_SZ)))
51578:     aAdapterDriver = L"Unknown";
51578:   return NS_OK;
51578: }
51578: 
76321: /* readonly attribute DOMString adapterDriver2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriver2(nsAString & aAdapterDriver)
76321: {
82073:   if (!mHasDualGPU) {
82073:     aAdapterDriver.AssignLiteral("");
82073:   } else if (NS_FAILED(GetKeyValue(mDeviceKey2.BeginReading(), L"InstalledDisplayDrivers", aAdapterDriver, REG_MULTI_SZ))) {
76321:     aAdapterDriver = L"Unknown";
82073:   }
76321:   return NS_OK;
76321: }
76321: 
51578: /* readonly attribute DOMString adapterDriverVersion; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDriverVersion(nsAString & aAdapterDriverVersion)
51578: {
51578:   aAdapterDriverVersion = mDriverVersion;
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDriverDate; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDriverDate(nsAString & aAdapterDriverDate)
51578: {
51578:   aAdapterDriverDate = mDriverDate;
51578:   return NS_OK;
51578: }
51578: 
76321: /* readonly attribute DOMString adapterDriverVersion2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriverVersion2(nsAString & aAdapterDriverVersion)
76321: {
76321:   aAdapterDriverVersion = mDriverVersion2;
76321:   return NS_OK;
76321: }
76321: 
76321: /* readonly attribute DOMString adapterDriverDate2; */
76321: NS_IMETHODIMP
76321: GfxInfo::GetAdapterDriverDate2(nsAString & aAdapterDriverDate)
76321: {
76321:   aAdapterDriverDate = mDriverDate2;
76321:   return NS_OK;
76321: }
76321: 
84604: /* readonly attribute DOMString adapterVendorID; */
51736: NS_IMETHODIMP
84604: GfxInfo::GetAdapterVendorID(nsAString & aAdapterVendorID)
51578: {
84604:   aAdapterVendorID = mAdapterVendorID;
51578:   return NS_OK;
51578: }
51578: 
84604: /* readonly attribute DOMString adapterVendorID2; */
76321: NS_IMETHODIMP
84604: GfxInfo::GetAdapterVendorID2(nsAString & aAdapterVendorID)
76321: {
84604:   aAdapterVendorID = mAdapterVendorID2;
76321:   return NS_OK;
76321: }
76321: 
84604: /* readonly attribute DOMString adapterDeviceID; */
51736: NS_IMETHODIMP
84604: GfxInfo::GetAdapterDeviceID(nsAString & aAdapterDeviceID)
51578: {
84604:   aAdapterDeviceID = mAdapterDeviceID;
51578:   return NS_OK;
51578: }
51579: 
84604: /* readonly attribute DOMString adapterDeviceID2; */
76321: NS_IMETHODIMP
84604: GfxInfo::GetAdapterDeviceID2(nsAString & aAdapterDeviceID)
76321: {
84604:   aAdapterDeviceID = mAdapterDeviceID2;
76321:   return NS_OK;
76321: }
76321: 
76321: /* readonly attribute boolean isGPU2Active; */
76321: NS_IMETHODIMP
79445: GfxInfo::GetIsGPU2Active(bool* aIsGPU2Active)
76321: {
76321:   *aIsGPU2Active = mIsGPU2Active;
76321:   return NS_OK;
76321: }
76321: 
70361: #if defined(MOZ_CRASHREPORTER)
61737: /* Cisco's VPN software can cause corruption of the floating point state.
61737:  * Make a note of this in our crash reports so that some weird crashes
61737:  * make more sense */
61737: static void
61737: CheckForCiscoVPN() {
61737:   LONG result;
61737:   HKEY key;
61737:   /* This will give false positives, but hopefully no false negatives */
61737:   result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Software\\Cisco Systems\\VPN Client", 0, KEY_QUERY_VALUE, &key);
61737:   if (result == ERROR_SUCCESS) {
61737:     RegCloseKey(key);
61737:     CrashReporter::AppendAppNotesToCrashReport(NS_LITERAL_CSTRING("Cisco VPN\n"));
61737:   }
61737: }
61737: #endif
61737: 
51736: void
51736: GfxInfo::AddCrashReportAnnotations()
51579: {
70361: #if defined(MOZ_CRASHREPORTER)
61737:   CheckForCiscoVPN();
61737: 
84604:   nsString deviceID, vendorID;
84604:   nsCString narrowDeviceID, narrowVendorID;
61024:   nsAutoString adapterDriverVersionString;
51579: 
84604:   GetAdapterDeviceID(deviceID);
84604:   CopyUTF16toUTF8(deviceID, narrowDeviceID);
84604:   GetAdapterVendorID(vendorID);
84604:   CopyUTF16toUTF8(vendorID, narrowVendorID);
61024:   GetAdapterDriverVersion(adapterDriverVersionString);
51579: 
51579:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterVendorID"),
84604:                                      narrowVendorID);
51579:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterDeviceID"),
84604:                                      narrowDeviceID);
51579:   
51579:   /* Add an App Note for now so that we get the data immediately. These
51579:    * can go away after we store the above in the socorro db */
51733:   nsCAutoString note;
51733:   /* AppendPrintf only supports 32 character strings, mrghh. */
84604:   note.Append("AdapterVendorID: ");
84604:   note.Append(narrowVendorID);
84604:   note.Append(", AdapterDeviceID: ");
84604:   note.Append(narrowDeviceID);
84604:   note.AppendPrintf(", AdapterSubsysID: %08x, ", mAdapterSubsysID);
84604:   note.Append("AdapterDriverVersion: ");
61024:   note.Append(NS_LossyConvertUTF16toASCII(adapterDriverVersionString));
58229: 
84604:   if (vendorID == GfxDriverInfo::GetDeviceVendor(VendorAll)) {
58229:     /* if we didn't find a valid vendorID lets append the mDeviceID string to try to find out why */
84604:     note.Append(", ");
84604:     note.AppendWithConversion(mDeviceID);
84604:     note.Append(", ");
84604:     note.AppendWithConversion(mDeviceKeyDebug);
83428:     LossyAppendUTF16toASCII(mDeviceKeyDebug, note);
58229:   }
58229:   note.Append("\n");
51733: 
76321:   if (mHasDualGPU) {
84604:     nsString deviceID2, vendorID2;
76321:     nsAutoString adapterDriverVersionString2;
84604:     nsCString narrowDeviceID2, narrowVendorID2;
76321: 
83428:     note.AppendLiteral("Has dual GPUs. GPU #2: ");
84604:     GetAdapterDeviceID2(deviceID2);
84604:     CopyUTF16toUTF8(deviceID2, narrowDeviceID2);
84604:     GetAdapterVendorID2(vendorID2);
84604:     CopyUTF16toUTF8(vendorID2, narrowVendorID2);
76321:     GetAdapterDriverVersion2(adapterDriverVersionString2);
84604:     note.Append("AdapterVendorID2: ");
84604:     note.Append(narrowVendorID2);
84604:     note.Append(", AdapterDeviceID2: ");
84604:     note.Append(narrowDeviceID2);
84604:     note.AppendPrintf(", AdapterSubsysID2: %08x, ", mAdapterSubsysID2);
76321:     note.AppendPrintf("AdapterDriverVersion2: ");
76321:     note.Append(NS_LossyConvertUTF16toASCII(adapterDriverVersionString2));
76321:   }
51733:   CrashReporter::AppendAppNotesToCrashReport(note);
51579: 
51579: #endif
51579: }
51736: 
60890: static OperatingSystem
60890: WindowsVersionToOperatingSystem(PRInt32 aWindowsVersion)
51736: {
60890:   switch(aWindowsVersion) {
60890:     case gfxWindowsPlatform::kWindows2000:
60890:       return DRIVER_OS_WINDOWS_2000;
60890:     case gfxWindowsPlatform::kWindowsXP:
60890:       return DRIVER_OS_WINDOWS_XP;
60890:     case gfxWindowsPlatform::kWindowsServer2003:
60890:       return DRIVER_OS_WINDOWS_SERVER_2003;
60890:     case gfxWindowsPlatform::kWindowsVista:
60890:       return DRIVER_OS_WINDOWS_VISTA;
60890:     case gfxWindowsPlatform::kWindows7:
60890:       return DRIVER_OS_WINDOWS_7;
60890:     case gfxWindowsPlatform::kWindowsUnknown:
60890:     default:
60890:       return DRIVER_OS_UNKNOWN;
60890:     };
51736: }
51736: 
84603: const nsTArray<GfxDriverInfo>&
81328: GfxInfo::GetGfxDriverInfo()
81328: {
84603:   if (!mDriverInfo->Length()) {
84603:     /*
84603:      * NVIDIA entries
84603:      */
84603:     APPEND_TO_DRIVER_BLOCKLIST( DRIVER_OS_WINDOWS_XP,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorNVIDIA), GfxDriverInfo::allDevices,
84603:       GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
84603:       DRIVER_LESS_THAN, V(6,14,12,5721), "257.21" );
84603:     APPEND_TO_DRIVER_BLOCKLIST( DRIVER_OS_WINDOWS_VISTA,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorNVIDIA), GfxDriverInfo::allDevices,
84603:       GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
84603:       DRIVER_LESS_THAN, V(8,17,12,5721), "257.21" );
84603:     APPEND_TO_DRIVER_BLOCKLIST( DRIVER_OS_WINDOWS_7,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorNVIDIA), GfxDriverInfo::allDevices,
84603:       GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
84603:       DRIVER_LESS_THAN, V(8,17,12,5721), "257.21" );
84603: 
84603:     /*
84603:      * AMD/ATI entries
84603:      */
84603:     APPEND_TO_DRIVER_BLOCKLIST( DRIVER_OS_ALL,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorATI), GfxDriverInfo::allDevices,
84603:       GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
84603:       DRIVER_LESS_THAN, V(8,741,0,0), "10.6" );
84603:     APPEND_TO_DRIVER_BLOCKLIST( DRIVER_OS_ALL,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorAMD), GfxDriverInfo::allDevices,
84603:       GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
84603:       DRIVER_LESS_THAN, V(8,741,0,0), "10.6" );
84603: 
84603:     /* OpenGL on any ATI/AMD hardware is discouraged
84603:      * See:
84603:      *  bug 619773 - WebGL: Crash with blue screen : "NMI: Parity Check / Memory Parity Error"
84603:      *  bugs 584403, 584404, 620924 - crashes in atioglxx
84603:      *  + many complaints about incorrect rendering
84603:      */
84603:     APPEND_TO_DRIVER_BLOCKLIST2( DRIVER_OS_ALL,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorATI), GfxDriverInfo::allDevices,
84603:       nsIGfxInfo::FEATURE_OPENGL_LAYERS, nsIGfxInfo::FEATURE_DISCOURAGED,
84603:       DRIVER_LESS_THAN, GfxDriverInfo::allDriverVersions );
84603:     APPEND_TO_DRIVER_BLOCKLIST2( DRIVER_OS_ALL,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorATI), GfxDriverInfo::allDevices,
84603:       nsIGfxInfo::FEATURE_WEBGL_OPENGL, nsIGfxInfo::FEATURE_DISCOURAGED,
84603:       DRIVER_LESS_THAN, GfxDriverInfo::allDriverVersions );
84603:     APPEND_TO_DRIVER_BLOCKLIST2( DRIVER_OS_ALL,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorAMD), GfxDriverInfo::allDevices,
84603:       nsIGfxInfo::FEATURE_OPENGL_LAYERS, nsIGfxInfo::FEATURE_DISCOURAGED,
84603:       DRIVER_LESS_THAN, GfxDriverInfo::allDriverVersions );
84603:     APPEND_TO_DRIVER_BLOCKLIST2( DRIVER_OS_ALL,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorAMD), GfxDriverInfo::allDevices,
84603:       nsIGfxInfo::FEATURE_WEBGL_OPENGL, nsIGfxInfo::FEATURE_DISCOURAGED,
84603:       DRIVER_LESS_THAN, GfxDriverInfo::allDriverVersions );
84603: 
84603:     /*
84603:      * Intel entries
84603:      */
84603: 
84603:     /* implement the blocklist from bug 594877
84603:      * Block all features on any drivers before this, as there's a crash when a MS Hotfix is installed.
84603:      * The crash itself is Direct2D-related, but for safety we block all features.
84603:      */
84603:     #define IMPLEMENT_INTEL_DRIVER_BLOCKLIST(winVer, devFamily, driverVer)                                                      \
84603:       APPEND_TO_DRIVER_BLOCKLIST2( winVer,                                                                                      \
84604:         (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorIntel), (GfxDeviceFamily*) GfxDriverInfo::GetDeviceFamily(devFamily), \
84603:         GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,                                                 \
84603:         DRIVER_LESS_THAN, driverVer )
84603: 
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, IntelGMA500,   V(6,14,11,1018));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, IntelGMA900,   V(6,14,10,4764));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, IntelGMA950,   V(6,14,10,4926));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, IntelGMA3150,  V(6,14,10,5260));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, IntelGMAX3000, V(6,14,10,5218));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, IntelGMAX4500HD, V(6,14,10,5284));
84603: 
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, IntelGMA500,   V(7,14,10,1006));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, IntelGMA900,   GfxDriverInfo::allDriverVersions);
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, IntelGMA950,   V(7,14,10,1504));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, IntelGMA3150,  V(7,14,10,2124));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, IntelGMAX3000, V(7,15,10,1666));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, IntelGMAX4500HD, V(8,15,10,2202));
84603: 
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, IntelGMA500,   V(5,0,0,2026));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, IntelGMA900,   GfxDriverInfo::allDriverVersions);
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, IntelGMA950,   V(8,15,10,1930));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, IntelGMA3150,  V(8,14,10,2117));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, IntelGMAX3000, V(8,15,10,1930));
84604:     IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, IntelGMAX4500HD, V(8,15,10,2202));
84603: 
84603:     /* OpenGL on any Intel hardware is discouraged */
84603:     APPEND_TO_DRIVER_BLOCKLIST2( DRIVER_OS_ALL,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorIntel), GfxDriverInfo::allDevices,
84603:       nsIGfxInfo::FEATURE_OPENGL_LAYERS, nsIGfxInfo::FEATURE_DISCOURAGED,
84603:       DRIVER_LESS_THAN, GfxDriverInfo::allDriverVersions );
84603:     APPEND_TO_DRIVER_BLOCKLIST2( DRIVER_OS_ALL,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorIntel), GfxDriverInfo::allDevices,
84603:       nsIGfxInfo::FEATURE_WEBGL_OPENGL, nsIGfxInfo::FEATURE_DISCOURAGED,
84603:       DRIVER_LESS_THAN, GfxDriverInfo::allDriverVersions );
84604: 
84604:     /* Disable D3D9 layers on NVIDIA 6100/6150/6200 series due to glitches
84604:      * whilst scrolling. See bugs: 612007, 644787 & 645872.
84604:      */
84604:     APPEND_TO_DRIVER_BLOCKLIST2( DRIVER_OS_ALL,
84604:       (nsAString&) GfxDriverInfo::GetDeviceVendor(VendorNVIDIA), (GfxDeviceFamily*) GfxDriverInfo::GetDeviceFamily(NvidiaBlockD3D9Layers),
84604:       nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS, nsIGfxInfo::FEATURE_BLOCKED_DEVICE,
84604:       DRIVER_LESS_THAN, GfxDriverInfo::allDriverVersions );
84603:   }
84603:   return *mDriverInfo;
81328: }
81328: 
55059: nsresult
81328: GfxInfo::GetFeatureStatusImpl(PRInt32 aFeature,
81328:                               PRInt32 *aStatus, 
81328:                               nsAString & aSuggestedDriverVersion, 
84603:                               const nsTArray<GfxDriverInfo>& aDriverInfo,
81328:                               OperatingSystem* aOS /* = nsnull */)
51736: {
84607:   NS_ENSURE_ARG_POINTER(aStatus);
79626:   aSuggestedDriverVersion.SetIsVoid(true);
84607:   OperatingSystem os = WindowsVersionToOperatingSystem(mWindowsVersion);
84607:   *aStatus = nsIGfxInfo::FEATURE_STATUS_UNKNOWN;
84607:   if (aOS)
84607:     *aOS = os;
55059: 
84607:   // Don't evaluate special cases if we're checking the downloaded blocklist.
84607:   if (!aDriverInfo.Length()) {
84604:     nsAutoString adapterVendorID;
84604:     nsAutoString adapterDeviceID;
51736:     nsAutoString adapterDriverVersionString;
84604:     if (NS_FAILED(GetAdapterVendorID(adapterVendorID)) ||
84604:         NS_FAILED(GetAdapterDeviceID(adapterDeviceID)) ||
51736:         NS_FAILED(GetAdapterDriverVersion(adapterDriverVersionString)))
51736:     {
51736:       return NS_ERROR_FAILURE;
51736:     }
51736: 
85783:     if (!adapterVendorID.Equals(GfxDriverInfo::GetDeviceVendor(VendorIntel), nsCaseInsensitiveStringComparator()) &&
85783:         !adapterVendorID.Equals(GfxDriverInfo::GetDeviceVendor(VendorNVIDIA), nsCaseInsensitiveStringComparator()) &&
85783:         !adapterVendorID.Equals(GfxDriverInfo::GetDeviceVendor(VendorAMD), nsCaseInsensitiveStringComparator()) &&
85783:         !adapterVendorID.Equals(GfxDriverInfo::GetDeviceVendor(VendorATI), nsCaseInsensitiveStringComparator()) &&
61612:         // FIXME - these special hex values are currently used in xpcshell tests introduced by
61612:         // bug 625160 patch 8/8. Maybe these tests need to be adjusted now that we're only whitelisting
61612:         // intel/ati/nvidia.
84604:         !adapterVendorID.LowerCaseEqualsLiteral("0xabcd") &&
84604:         !adapterVendorID.LowerCaseEqualsLiteral("0xdcba") &&
84604:         !adapterVendorID.LowerCaseEqualsLiteral("0xabab") &&
84604:         !adapterVendorID.LowerCaseEqualsLiteral("0xdcdc"))
61595:     {
61595:       *aStatus = FEATURE_BLOCKED_DEVICE;
61595:       return NS_OK;
61595:     }
61595: 
51736:     PRUint64 driverVersion;
51736:     if (!ParseDriverVersion(adapterDriverVersionString, &driverVersion)) {
51736:       return NS_ERROR_FAILURE;
51736:     }
51736: 
84603:     // special-case the WinXP test slaves: they have out-of-date drivers, but we still want to
84603:     // whitelist them, actually we do know that this combination of device and driver version
84603:     // works well.
84603:     if (mWindowsVersion == gfxWindowsPlatform::kWindowsXP &&
85783:         adapterVendorID.Equals(GfxDriverInfo::GetDeviceVendor(VendorNVIDIA), nsCaseInsensitiveStringComparator()) &&
84604:         adapterDeviceID.LowerCaseEqualsLiteral("0x0861") && // GeForce 9400
84603:         driverVersion == V(6,14,11,7756))
84603:     {
84603:       *aStatus = FEATURE_NO_INFO;
84603:       return NS_OK;
84603:     }
84603: 
56956:     if (aFeature == FEATURE_DIRECT3D_9_LAYERS &&
60896:         mWindowsVersion < gfxWindowsPlatform::kWindowsXP)
56956:     {
56956:       *aStatus = FEATURE_BLOCKED_OS_VERSION;
56956:       return NS_OK;
56956:     }
56956: 
63229:     // ANGLE currently uses D3D10 <-> D3D9 interop, which crashes on Optimus
63229:     // machines.
63229:     if (aFeature == FEATURE_WEBGL_ANGLE &&
63229:         gfxWindowsPlatform::IsOptimus())
63229:     {
63229:       *aStatus = FEATURE_BLOCKED_DEVICE;
63229:       return NS_OK;
63229:     }
63229: 
61661:     // Windows Server 2003 should be just like Windows XP for present purpose, but still has a different version number.
61661:     // OTOH Windows Server 2008 R1 and R2 already have the same version numbers as Vista and Seven respectively
61661:     if (os == DRIVER_OS_WINDOWS_SERVER_2003)
61661:       os = DRIVER_OS_WINDOWS_XP;
61661: 
61025:     if (mHasDriverVersionMismatch) {
61025:       if (aFeature == nsIGfxInfo::FEATURE_DIRECT3D_10_LAYERS ||
61025:           aFeature == nsIGfxInfo::FEATURE_DIRECT3D_10_1_LAYERS ||
61025:           aFeature == nsIGfxInfo::FEATURE_DIRECT2D)
61025:       {
61025:         *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
61025:         return NS_OK;
61025:       }
61025:     }
84607:   }
61594: 
81328:   return GfxInfoBase::GetFeatureStatusImpl(aFeature, aStatus, aSuggestedDriverVersion, aDriverInfo, &os);
51736: }
60896: 
60896: #ifdef DEBUG
60896: 
60896: // Implement nsIGfxInfoDebug
60896: 
84610: /* void spoofVendorID (in DOMString aVendorID); */
84610: NS_IMETHODIMP GfxInfo::SpoofVendorID(const nsAString & aVendorID)
60896: {
84610:   mAdapterVendorID = aVendorID;
60896:   return NS_OK;
60896: }
60896: 
60896: /* void spoofDeviceID (in unsigned long aDeviceID); */
84610: NS_IMETHODIMP GfxInfo::SpoofDeviceID(const nsAString & aDeviceID)
60896: {
84610:   mAdapterDeviceID = aDeviceID;
60896:   return NS_OK;
60896: }
60896: 
60896: /* void spoofDriverVersion (in DOMString aDriverVersion); */
60896: NS_IMETHODIMP GfxInfo::SpoofDriverVersion(const nsAString & aDriverVersion)
60896: {
60896:   mDriverVersion = aDriverVersion;
60896:   return NS_OK;
60896: }
60896: 
60896: /* void spoofOSVersion (in unsigned long aVersion); */
60896: NS_IMETHODIMP GfxInfo::SpoofOSVersion(PRUint32 aVersion)
60896: {
60896:   mWindowsVersion = aVersion;
60896:   return NS_OK;
60896: }
60896: 
60896: #endif
