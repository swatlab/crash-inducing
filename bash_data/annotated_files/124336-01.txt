 54707: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 54707:  * vim: set ts=4 sw=4 et tw=99:
 54707:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 54707: 
 56574: #include "jscntxt.h"
116270: #include "jsdate.h"
 54707: #include "jscompartment.h"
 54707: #include "jsgc.h"
 56574: #include "jsiter.h"
 72075: #include "jsmath.h"
 54707: #include "jsproxy.h"
 54707: #include "jsscope.h"
 74472: #include "jswatchpoint.h"
 62594: #include "jswrapper.h"
 86104: 
 61427: #include "assembler/wtf/Platform.h"
 97569: #include "gc/Marking.h"
 86104: #include "js/MemoryMetrics.h"
 56773: #include "methodjit/MethodJIT.h"
 54707: #include "methodjit/PolyIC.h"
 54707: #include "methodjit/MonoIC.h"
 98147: #include "methodjit/Retcon.h"
 76244: #include "vm/Debugger.h"
 86104: #include "yarr/BumpPointerAllocator.h"
 54707: 
 54707: #include "jsgcinlines.h"
 82129: #include "jsobjinlines.h"
 64285: #include "jsscopeinlines.h"
121078: #ifdef JS_ION
111804: #include "ion/IonCompartment.h"
113147: #include "ion/Ion.h"
121078: #endif
 54707: 
 62572: #if ENABLE_YARR_JIT
 62572: #include "assembler/jit/ExecutableAllocator.h"
 62572: #endif
 62572: 
 54707: using namespace js;
 54707: using namespace js::gc;
 54707: 
121250: using mozilla::DebugOnly;
121250: 
 54707: JSCompartment::JSCompartment(JSRuntime *rt)
 59735:   : rt(rt),
 59735:     principals(NULL),
102757:     global_(NULL),
105981: #ifdef JSGC_GENERATIONAL
105981:     gcStoreBuffer(&gcNursery),
105981: #endif
124291:     needsBarrier_(false),
120697:     ionUsingBarriers_(false),
108294:     gcScheduled(false),
108294:     gcState(NoGC),
 98147:     gcPreserveCode(false),
 60258:     gcBytes(0),
 60258:     gcTriggerBytes(0),
104267:     gcHeapGrowthFactor(3.0),
 64258:     hold(false),
102716:     isSystemCompartment(false),
 98147:     lastCodeRelease(0),
109045:     analysisLifoAlloc(LIFO_ALLOC_PRIMARY_CHUNK_SIZE),
109045:     typeLifoAlloc(LIFO_ALLOC_PRIMARY_CHUNK_SIZE),
 59735:     data(NULL),
 59922:     active(false),
121539:     scheduledForDestruction(false),
121539:     maybeAlive(true),
 98147:     lastAnimationTime(0),
 89918:     regExps(rt),
 63147:     propertyTree(thisForCtor()),
 91825:     gcMallocAndFreeBytes(0),
 91825:     gcTriggerMallocAndFreeBytes(0),
124078:     gcIncomingGrayPointers(NULL),
124081:     gcLiveArrayBuffers(NULL),
124083:     gcWeakMapList(NULL),
 91825:     gcMallocBytes(0),
 76246:     debugModeBits(rt->debugMode ? DebugFromC : 0),
 95113:     watchpointMap(NULL),
 95139:     scriptCountsMap(NULL),
124082:     debugScriptMap(NULL),
124082:     debugScopes(NULL)
111821: #ifdef JS_ION
111821:     , ionCompartment_(NULL)
111821: #endif
 54707: {
120874:     setGCMaxMallocBytes(rt->gcMaxMallocBytes * 0.9);
 54707: }
 54707: 
 54707: JSCompartment::~JSCompartment()
 54707: {
111805: #ifdef JS_ION
113642:     js_delete(ionCompartment_);
111805: #endif
111805: 
110933:     js_delete(watchpointMap);
110933:     js_delete(scriptCountsMap);
110933:     js_delete(debugScriptMap);
124082:     js_delete(debugScopes);
124082: }
 54707: 
 54707: bool
 77343: JSCompartment::init(JSContext *cx)
 54707: {
116270:     /*
116270:      * As a hack, we clear our timezone cache every time we create a new
116270:      * compartment.  This ensures that the cache is always relatively fresh, but
116270:      * shouldn't interfere with benchmarks which create tons of date objects
116270:      * (unless they also create tons of iframes, which seems unlikely).
116270:      */
116270:     js_ClearDateCaches();
116270: 
 77343:     activeAnalysis = activeInference = false;
 77343:     types.init(cx);
 77343: 
 56773:     if (!crossCompartmentWrappers.init())
 56773:         return false;
 56773: 
 89918:     if (!regExps.init(cx))
 89918:         return false;
 89918: 
105981: #ifdef JSGC_GENERATIONAL
105981:     /*
105981:      * If we are in the middle of post-barrier verification, we need to
105981:      * immediately begin collecting verification data on new compartments.
105981:      */
105981:     if (rt->gcVerifyPostData) {
105981:         if (!gcNursery.enable())
105981:             return false;
105981: 
105981:         if (!gcStoreBuffer.enable())
105981:             return false;
113885:     } else {
113885:         gcNursery.disable();
113885:         gcStoreBuffer.disable();
105981:     }
105981: #endif
105981: 
 84195:     return debuggees.init();
 54707: }
 54707: 
 98147: void
120697: JSCompartment::setNeedsBarrier(bool needs, ShouldUpdateIon updateIon)
 98147: {
 98147: #ifdef JS_METHODJIT
108442:     /* ClearAllFrames calls compileBarriers() and needs the old value. */
108442:     bool old = compileBarriers();
108442:     if (compileBarriers(needs) != old)
 98147:         mjit::ClearAllFrames(this);
 98147: #endif
113147: 
113147: #ifdef JS_ION
120697:     if (updateIon == UpdateIon && needs != ionUsingBarriers_) {
113147:         ion::ToggleBarriers(this, needs);
120697:         ionUsingBarriers_ = needs;
120697:     }
113147: #endif
113147: 
 98147:     needsBarrier_ = needs;
 98147: }
 98147: 
111804: #ifdef JS_ION
121876: ion::IonRuntime *
121876: JSRuntime::createIonRuntime(JSContext *cx)
121876: {
121876:     ionRuntime_ = cx->new_<ion::IonRuntime>();
121876: 
121876:     if (!ionRuntime_)
121876:         return NULL;
121876: 
121876:     if (!ionRuntime_->initialize(cx)) {
121876:         js_delete(ionRuntime_);
121876:         ionRuntime_ = NULL;
121876: 
121876:         if (cx->runtime->atomsCompartment->ionCompartment_) {
121876:             js_delete(cx->runtime->atomsCompartment->ionCompartment_);
121876:             cx->runtime->atomsCompartment->ionCompartment_ = NULL;
121876:         }
121876: 
121876:         return NULL;
121876:     }
121876: 
121876:     return ionRuntime_;
121876: }
121876: 
111804: bool
111805: JSCompartment::ensureIonCompartmentExists(JSContext *cx)
111804: {
111804:     using namespace js::ion;
111804:     if (ionCompartment_)
111804:         return true;
111804: 
121876:     IonRuntime *ionRuntime = cx->runtime->getIonRuntime(cx);
121876:     if (!ionRuntime)
121876:         return false;
121876: 
120113:     /* Set the compartment early, so linking works. */
121876:     ionCompartment_ = cx->new_<IonCompartment>(ionRuntime);
120113: 
121876:     if (!ionCompartment_)
120104:         return false;
111805: 
123581:     if (!ionCompartment_->initialize(cx)) {
123581:         js_delete(ionCompartment_);
123581:         ionCompartment_ = NULL;
123581:         return false;
123581:     }
123581: 
111804:     return true;
111804: }
111804: #endif
111804: 
 98430: static bool
107154: WrapForSameCompartment(JSContext *cx, HandleObject obj, Value *vp)
 98430: {
 98430:     JS_ASSERT(cx->compartment == obj->compartment());
107154:     if (!cx->runtime->sameCompartmentWrapObjectCallback) {
107154:         vp->setObject(*obj);
107154:         return true;
107154:     }
107154: 
107154:     JSObject *wrapped = cx->runtime->sameCompartmentWrapObjectCallback(cx, obj);
107154:     if (!wrapped)
 98430:         return false;
107154:     vp->setObject(*wrapped);
 98430:     return true;
 98430: }
 98430: 
 54707: bool
121493: JSCompartment::wrap(JSContext *cx, Value *vp, JSObject *existing)
 54707: {
 54707:     JS_ASSERT(cx->compartment == this);
121493:     JS_ASSERT_IF(existing, existing->compartment() == cx->compartment);
121493:     JS_ASSERT_IF(existing, vp->isObject());
121493:     JS_ASSERT_IF(existing, IsDeadProxyObject(existing));
 54707: 
 91237:     unsigned flags = 0;
 54707: 
121496:     JS_CHECK_CHROME_RECURSION(cx, return false);
 54707: 
102262: #ifdef DEBUG
102262:     struct AutoDisableProxyCheck {
102262:         JSRuntime *runtime;
102262:         AutoDisableProxyCheck(JSRuntime *rt) : runtime(rt) {
102262:             runtime->gcDisableStrictProxyCheckingCount++;
102262:         }
102262:         ~AutoDisableProxyCheck() { runtime->gcDisableStrictProxyCheckingCount--; }
102262:     } adpc(rt);
102262: #endif
102262: 
 54707:     /* Only GC things have to be wrapped or copied. */
 54707:     if (!vp->isMarkable())
 54707:         return true;
 54707: 
 54862:     if (vp->isString()) {
 54862:         JSString *str = vp->toString();
 54862: 
 54862:         /* If the string is already in this compartment, we are done. */
 64345:         if (str->compartment() == this)
 54862:             return true;
 54862: 
 54862:         /* If the string is an atom, we don't have to copy. */
 64343:         if (str->isAtom()) {
 64345:             JS_ASSERT(str->compartment() == cx->runtime->atomsCompartment);
 54862:             return true;
 54862:         }
 54862:     }
 54862: 
 55628:     /*
 55628:      * Wrappers should really be parented to the wrapped parent of the wrapped
 55628:      * object, but in that case a wrapped global object would have a NULL
 77544:      * parent without being a proper global object (JSCLASS_IS_GLOBAL). Instead,
 55628:      * we parent all wrappers to the global object in their home compartment.
 55628:      * This loses us some transparency, and is generally very cheesy.
 55628:      */
109255:     HandleObject global = cx->global();
 55628: 
 54707:     /* Unwrap incoming objects. */
 54707:     if (vp->isObject()) {
102586:         Rooted<JSObject*> obj(cx, &vp->toObject());
 54707: 
 54862:         if (obj->compartment() == this)
 98430:             return WrapForSameCompartment(cx, obj, vp);
 54707: 
 56574:         /* Translate StopIteration singleton. */
103636:         if (obj->isStopIteration()) {
103636:             RootedValue vvp(cx, *vp);
109255:             bool result = js_FindClassObject(cx, JSProto_StopIteration, &vvp);
103636:             *vp = vvp;
103636:             return result;
103636:         }
 56574: 
 98429:         /* Unwrap the object, but don't unwrap outer windows. */
 98429:         obj = UnwrapObject(&vp->toObject(), /* stopAtOuter = */ true, &flags);
 98429: 
 79734:         if (obj->compartment() == this)
 98430:             return WrapForSameCompartment(cx, obj, vp);
 55628: 
 60246:         if (cx->runtime->preWrapObjectCallback) {
 55628:             obj = cx->runtime->preWrapObjectCallback(cx, global, obj, flags);
 55628:             if (!obj)
 55628:                 return false;
 60246:         }
 55611: 
 98430:         if (obj->compartment() == this)
 98430:             return WrapForSameCompartment(cx, obj, vp);
 55611:         vp->setObject(*obj);
 55611: 
 55628: #ifdef DEBUG
 55628:         {
102586:             JSObject *outer = GetOuterObject(cx, obj);
 55628:             JS_ASSERT(outer && outer == obj);
 55628:         }
 55628: #endif
 54707:     }
 54707: 
 99421:     RootedValue key(cx, *vp);
 99135: 
 54707:     /* If we already have a wrapper for this value, use it. */
 99135:     if (WrapperMap::Ptr p = crossCompartmentWrappers.lookup(key)) {
 54707:         *vp = p->value;
 62594:         if (vp->isObject()) {
 99421:             RootedObject obj(cx, &vp->toObject());
 79734:             JS_ASSERT(obj->isCrossCompartmentWrapper());
115021:             JS_ASSERT(obj->getParent() == global);
 62594:         }
 54707:         return true;
 54707:     }
 54707: 
 54707:     if (vp->isString()) {
 99421:         RootedValue orig(cx, *vp);
114424:         JSStableString *str = vp->toString()->ensureStable(cx);
114424:         if (!str)
 59890:             return false;
118470:         JSString *wrapped = js_NewStringCopyN(cx, str->chars().get(), str->length());
 54707:         if (!wrapped)
 54707:             return false;
 54707:         vp->setString(wrapped);
124336:         if (!crossCompartmentWrappers.put(orig, *vp))
124336:             return false;
124336: 
124336:         if (str->compartment()->isGCMarking()) {
124336:             /*
124336:              * All string wrappers are dropped when collection starts, but we
124336:              * just created a new one.  Mark the wrapped string to stop it being
124336:              * finalized, because if it was then the pointer in this
124336:              * compartment's wrapper map would be left dangling.
124336:              */
124336:             JSString *tmp = str;
124336:             MarkStringUnbarriered(&rt->gcMarker, &tmp, "wrapped string");
124336:             JS_ASSERT(tmp == str);
124336:         }
124336: 
124336:         return true;
 54707:     }
 54707: 
 99421:     RootedObject obj(cx, &vp->toObject());
 54707: 
115024:     JSObject *proto = Proxy::LazyProto;
121493:     if (existing) {
121539:         /* Is it possible to reuse |existing|? */
121493:         if (!existing->getTaggedProto().isLazy() ||
121493:             existing->getClass() != &ObjectProxyClass ||
121493:             existing->getParent() != global ||
121493:             obj->isCallable())
121493:         {
121493:             existing = NULL;
121493:         }
121493:     }
 54707: 
 54707:     /*
 55580:      * We hand in the original wrapped object into the wrap hook to allow
 55580:      * the wrap hook to reason over what wrappers are currently applied
 55580:      * to the object.
 55580:      */
121493:     RootedObject wrapper(cx);
121493:     wrapper = cx->runtime->wrapObjectCallback(cx, existing, obj, proto, global, flags);
 55580:     if (!wrapper)
 55580:         return false;
 55580: 
103589:     // We maintain the invariant that the key in the cross-compartment wrapper
103589:     // map is always directly wrapped by the value.
103637:     JS_ASSERT(Wrapper::wrappedObject(wrapper) == &key.get().toObject());
103589: 
 55580:     vp->setObject(*wrapper);
 55580: 
 99135:     if (!crossCompartmentWrappers.put(key, *vp))
 55580:         return false;
 55580: 
 54707:     return true;
 54707: }
 54707: 
 54707: bool
 54707: JSCompartment::wrap(JSContext *cx, JSString **strp)
 54707: {
 99421:     RootedValue value(cx, StringValue(*strp));
 97353:     if (!wrap(cx, value.address()))
 54707:         return false;
103637:     *strp = value.get().toString();
 54707:     return true;
 54707: }
 54707: 
 54707: bool
 82129: JSCompartment::wrap(JSContext *cx, HeapPtrString *strp)
 82129: {
 99421:     RootedValue value(cx, StringValue(*strp));
 97353:     if (!wrap(cx, value.address()))
 82129:         return false;
103637:     *strp = value.get().toString();
 82129:     return true;
 82129: }
 82129: 
 82129: bool
121493: JSCompartment::wrap(JSContext *cx, JSObject **objp, JSObject *existing)
 54707: {
 54707:     if (!*objp)
 54707:         return true;
 99421:     RootedValue value(cx, ObjectValue(**objp));
121493:     if (!wrap(cx, value.address(), existing))
 54707:         return false;
103637:     *objp = &value.get().toObject();
 54707:     return true;
 54707: }
 54707: 
 54707: bool
 54707: JSCompartment::wrapId(JSContext *cx, jsid *idp)
 54707: {
 54707:     if (JSID_IS_INT(*idp))
 54707:         return true;
 99421:     RootedValue value(cx, IdToValue(*idp));
 97353:     if (!wrap(cx, value.address()))
 54707:         return false;
103637:     return ValueToId(cx, value.get(), idp);
 54707: }
 54707: 
 54707: bool
 54707: JSCompartment::wrap(JSContext *cx, PropertyOp *propp)
 54707: {
 54707:     Value v = CastAsObjectJsval(*propp);
 54707:     if (!wrap(cx, &v))
 54707:         return false;
 54707:     *propp = CastAsPropertyOp(v.toObjectOrNull());
 54707:     return true;
 54707: }
 54707: 
 54707: bool
 62395: JSCompartment::wrap(JSContext *cx, StrictPropertyOp *propp)
 62395: {
 62395:     Value v = CastAsObjectJsval(*propp);
 62395:     if (!wrap(cx, &v))
 62395:         return false;
 62395:     *propp = CastAsStrictPropertyOp(v.toObjectOrNull());
 62395:     return true;
 62395: }
 62395: 
 62395: bool
 54707: JSCompartment::wrap(JSContext *cx, PropertyDescriptor *desc)
 54707: {
 54707:     return wrap(cx, &desc->obj) &&
 54707:            (!(desc->attrs & JSPROP_GETTER) || wrap(cx, &desc->getter)) &&
 54707:            (!(desc->attrs & JSPROP_SETTER) || wrap(cx, &desc->setter)) &&
 54707:            wrap(cx, &desc->value);
 54707: }
 54707: 
 54707: bool
 54707: JSCompartment::wrap(JSContext *cx, AutoIdVector &props)
 54707: {
 54707:     jsid *vector = props.begin();
 91450:     int length = props.length();
 54707:     for (size_t n = 0; n < size_t(length); ++n) {
 54707:         if (!wrapId(cx, &vector[n]))
 54707:             return false;
 54707:     }
 54707:     return true;
 54707: }
 54707: 
 62077: /*
 62077:  * This method marks pointers that cross compartment boundaries. It should be
 64258:  * called only for per-compartment GCs, since full GCs naturally follow pointers
 62077:  * across compartments.
 62077:  */
 62077: void
 64258: JSCompartment::markCrossCompartmentWrappers(JSTracer *trc)
 62077: {
 94620:     JS_ASSERT(!isCollecting());
 64258: 
 90302:     for (WrapperMap::Enum e(crossCompartmentWrappers); !e.empty(); e.popFront()) {
 99135:         Value v = e.front().value;
101637:         if (e.front().key.kind == CrossCompartmentKey::ObjectWrapper) {
 99385:             JSObject *wrapper = &v.toObject();
 99385: 
 99135:             /*
 99135:              * We have a cross-compartment wrapper. Its private pointer may
 99135:              * point into the compartment being collected, so we should mark it.
 99135:              */
 99385:             Value referent = GetProxyPrivate(wrapper);
 99135:             MarkValueRoot(trc, &referent, "cross-compartment wrapper");
 99385:             JS_ASSERT(referent == GetProxyPrivate(wrapper));
 99385: 
 99385:             if (IsFunctionProxy(wrapper)) {
 99385:                 Value call = GetProxyCall(wrapper);
 99385:                 MarkValueRoot(trc, &call, "cross-compartment wrapper");
 99385:                 JS_ASSERT(call == GetProxyCall(wrapper));
 99385:             }
 99135:         }
 90302:     }
 62077: }
 62077: 
 62060: void
111817: JSCompartment::mark(JSTracer *trc)
111817: {
111895: #ifdef JS_ION
111817:     if (ionCompartment_)
111817:         ionCompartment_->mark(trc, this);
111895: #endif
111817: }
111817: 
111817: void
 77343: JSCompartment::markTypes(JSTracer *trc)
 77343: {
 77441:     /*
 77441:      * Mark all scripts, type objects and singleton JS objects in the
 77441:      * compartment. These can be referred to directly by type sets, which we
 77441:      * cannot modify while code which depends on these type sets is active.
 77441:      */
113151:     JS_ASSERT(activeAnalysis || isPreservingCode());
 77343: 
 77659:     for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
 77659:         JSScript *script = i.get<JSScript>();
 90409:         MarkScriptRoot(trc, &script, "mark_types_script");
 90409:         JS_ASSERT(script == i.get<JSScript>());
 77343:     }
 77343: 
 98898:     for (size_t thingKind = FINALIZE_OBJECT0; thingKind < FINALIZE_OBJECT_LIMIT; thingKind++) {
 98898:         ArenaHeader *aheader = arenas.getFirstArena(static_cast<AllocKind>(thingKind));
 98898:         if (aheader)
 98898:             rt->gcMarker.pushArenaList(aheader);
 98754:     }
 77441: 
 90409:     for (CellIterUnderGC i(this, FINALIZE_TYPE_OBJECT); !i.done(); i.next()) {
 90409:         types::TypeObject *type = i.get<types::TypeObject>();
 90409:         MarkTypeObjectRoot(trc, &type, "mark_types_scan");
 90409:         JS_ASSERT(type == i.get<types::TypeObject>());
 90409:     }
 77441: }
 77343: 
 77343: void
109114: JSCompartment::discardJitCode(FreeOp *fop, bool discardConstraints)
 54707: {
 98147: #ifdef JS_METHODJIT
 98147: 
 80819:     /*
 80819:      * Kick all frames on the stack into the interpreter, and release all JIT
113151:      * code in the compartment unless code is being preserved, in which case
 98147:      * purge all caches in the JIT scripts. Even if we are not releasing all
 98147:      * JIT code, we still need to release code for scripts which are in the
 98147:      * middle of a native or getter stub call, as these stubs will have been
 98147:      * redirected to the interpoline.
 80819:      */
 80819:     mjit::ClearAllFrames(this);
 80819: 
113147:     if (isPreservingCode()) {
113345:         PurgeJITCaches(this);
 98147:     } else {
113151: # ifdef JS_ION
113151:         /* Only mark OSI points if code is being discarded. */
113151:         ion::InvalidateAll(fop, this);
113151: # endif
 78389:         for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
 78389:             JSScript *script = i.get<JSScript>();
 94740:             mjit::ReleaseScriptCode(fop, script);
113132: # ifdef JS_ION
113132:             ion::FinishInvalidation(fop, script);
113132: # endif
 80819: 
 80819:             /*
 80819:              * Use counts for scripts are reset on GC. After discarding code we
 98147:              * need to let it warm back up to get information such as which
 98147:              * opcodes are setting array holes or accessing getter properties.
 80819:              */
 80819:             script->resetUseCount();
 78413:         }
107981: 
109114:         types.sweepCompilerOutputs(fop, discardConstraints);
 98147:     }
 98147: 
 98147: #endif /* JS_METHODJIT */
 82095: }
 78413: 
108441: bool
108441: JSCompartment::isDiscardingJitCode(JSTracer *trc)
108441: {
108441:     if (!IS_GC_MARKING_TRACER(trc))
108441:         return false;
108441: 
108441:     return !gcPreserveCode;
108441: }
108441: 
 90410: void
 94738: JSCompartment::sweep(FreeOp *fop, bool releaseTypes)
 90410: {
103939:     {
103939:         gcstats::AutoPhase ap(rt->gcStats, gcstats::PHASE_SWEEP_DISCARD_CODE);
109114:         discardJitCode(fop, !activeAnalysis && !gcPreserveCode);
103939:     }
103939: 
103939:     /* This function includes itself in PHASE_SWEEP_TABLES. */
 99573:     sweepCrossCompartmentWrappers();
 90410: 
103939:     {
103939:         gcstats::AutoPhase ap(rt->gcStats, gcstats::PHASE_SWEEP_TABLES);
103939: 
 90410:         /* Remove dead references held weakly by the compartment. */
 90410: 
 94738:         sweepBaseShapeTable();
 94738:         sweepInitialShapeTable();
 94738:         sweepNewTypeObjectTable(newTypeObjects);
 94738:         sweepNewTypeObjectTable(lazyTypeObjects);
 94738:         sweepBreakpoints(fop);
 90410: 
124075:         if (global_ && IsObjectAboutToBeFinalized(&global_))
103784:             global_ = NULL;
103784: 
112198: #ifdef JS_ION
112198:         if (ionCompartment_)
112964:             ionCompartment_->sweep(fop);
112198: #endif
 90302: 
120788:         /*
120788:          * JIT code increments activeUseCount for any RegExpShared used by jit
120788:          * code for the lifetime of the JIT script. Thus, we must perform
120788:          * sweeping after clearing jit code.
120788:          */
 98147:         regExps.sweep(rt);
124082: 
124082:         if (debugScopes)
124082:             debugScopes->sweep(rt);
124083: 
124083:         /* Finalize unreachable (key,value) pairs in all weak maps. */
124083:         WeakMapBase::sweepCompartment(this);
103939:     }
 98147: 
 98147:     if (!activeAnalysis && !gcPreserveCode) {
109114:         JS_ASSERT(!types.constrainedOutputs);
 82095:         gcstats::AutoPhase ap(rt->gcStats, gcstats::PHASE_DISCARD_ANALYSIS);
 82095: 
 77892:         /*
 77892:          * Clear the analysis pool, but don't release its data yet. While
 77439:          * sweeping types any live data will be allocated into the pool.
 77439:          */
 79410:         LifoAlloc oldAlloc(typeLifoAlloc.defaultChunkSize());
 79410:         oldAlloc.steal(&typeLifoAlloc);
 77439: 
 77439:         /*
 80819:          * Periodically release observed types for all scripts. This is safe to
 80819:          * do when there are no frames for the compartment on the stack.
 80819:          */
 80819:         if (active)
 80819:             releaseTypes = false;
 80819: 
 80819:         /*
 77353:          * Sweep analysis information and everything depending on it from the
 77353:          * compartment, including all remaining mjit code if inference is
 77353:          * enabled in the compartment.
 77353:          */
 77353:         if (types.inferenceEnabled) {
 93368:             gcstats::AutoPhase ap2(rt->gcStats, gcstats::PHASE_DISCARD_TI);
 93368: 
 77659:             for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
115105:                 RawScript script = i.get<JSScript>();
 77439:                 if (script->types) {
 94740:                     types::TypeScript::Sweep(fop, script);
 77439: 
 80819:                     if (releaseTypes) {
 77439:                         script->types->destroy();
 77439:                         script->types = NULL;
 77439:                     }
 77439:                 }
 77343:             }
 77343:         }
 77343: 
 93368:         {
 93368:             gcstats::AutoPhase ap2(rt->gcStats, gcstats::PHASE_SWEEP_TYPES);
 94740:             types.sweep(fop);
 93368:         }
 77361: 
 93368:         {
 93368:             gcstats::AutoPhase ap2(rt->gcStats, gcstats::PHASE_CLEAR_SCRIPT_ANALYSIS);
 77659:             for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
 77659:                 JSScript *script = i.get<JSScript>();
 77884:                 script->clearAnalysis();
109045:                 script->clearPropertyReadTypes();
 77353:             }
 77343:         }
103939: 
103939:         {
103939:             gcstats::AutoPhase ap2(rt->gcStats, gcstats::PHASE_FREE_TI_ARENA);
109045:             rt->freeLifoAlloc.transferFrom(&analysisLifoAlloc);
106660:             rt->freeLifoAlloc.transferFrom(&oldAlloc);
103939:         }
 93368:     }
 59895: 
 59895:     active = false;
 54707: }
 54707: 
 99573: /*
 99573:  * Remove dead wrappers from the table. We must sweep all compartments, since
 99573:  * string entries in the crossCompartmentWrappers table are not marked during
 99573:  * markCrossCompartmentWrappers.
 99573:  */
 99573: void
 99573: JSCompartment::sweepCrossCompartmentWrappers()
 99573: {
124080:     gcstats::AutoPhase ap1(rt->gcStats, gcstats::PHASE_SWEEP_TABLES);
124080:     gcstats::AutoPhase ap2(rt->gcStats, gcstats::PHASE_SWEEP_TABLES_WRAPPER);
103939: 
 99573:     /* Remove dead wrappers from the table. */
 99573:     for (WrapperMap::Enum e(crossCompartmentWrappers); !e.empty(); e.popFront()) {
101637:         CrossCompartmentKey key = e.front().key;
124075:         bool keyDying = IsCellAboutToBeFinalized(&key.wrapped);
124075:         bool valDying = IsValueAboutToBeFinalized(e.front().value.unsafeGet());
124075:         bool dbgDying = key.debugger && IsObjectAboutToBeFinalized(&key.debugger);
124077:         if (keyDying || valDying || dbgDying) {
124077:             JS_ASSERT(key.kind != CrossCompartmentKey::StringWrapper);
 99573:             e.removeFront();
124077:         } else if (key.wrapped != e.front().key.wrapped || key.debugger != e.front().key.debugger) {
 99573:             e.rekeyFront(key);
 99573:         }
 99573:     }
124077: }
 99573: 
 54707: void
 91250: JSCompartment::purge()
 54707: {
 61432:     dtoaCache.purge();
 54707: }
 59735: 
 88570: void
 88570: JSCompartment::resetGCMallocBytes()
 88570: {
 99043:     gcMallocBytes = ptrdiff_t(gcMaxMallocBytes);
 88570: }
 88570: 
 88570: void
 88570: JSCompartment::setGCMaxMallocBytes(size_t value)
 88570: {
 99043:     /*
 99043:      * For compatibility treat any value that exceeds PTRDIFF_T_MAX to
 99043:      * mean that value.
 99043:      */
 99043:     gcMaxMallocBytes = (ptrdiff_t(value) >= 0) ? value : size_t(-1) >> 1;
 88570:     resetGCMallocBytes();
 88570: }
 88570: 
 88570: void
 88570: JSCompartment::onTooMuchMalloc()
 88570: {
 88570:     TriggerCompartmentGC(this, gcreason::TOO_MUCH_MALLOC);
 88570: }
 88570: 
 88570: 
 75402: bool
 91250: JSCompartment::hasScriptsOnStack()
 75489: {
118567:     for (AllFramesIter afi(rt->stackSpace); !afi.done(); ++afi) {
118567: #ifdef JS_ION
118567:         // If this is an Ion frame, check the IonActivation instead
118567:         if (afi.isIon())
118567:             continue;
118567: #endif
118567:         if (afi.interpFrame()->script()->compartment() == this)
 75489:             return true;
 75489:     }
118567: #ifdef JS_ION
118567:     for (ion::IonActivationIterator iai(rt); iai.more(); ++iai) {
118567:         if (iai.activation()->compartment() == this)
118567:             return true;
118567:     }
118567: #endif
 75489:     return false;
 75489: }
 75489: 
 75489: bool
 98493: JSCompartment::setDebugModeFromC(JSContext *cx, bool b, AutoDebugModeGC &dmgc)
 75489: {
 75489:     bool enabledBefore = debugMode();
 91237:     bool enabledAfter = (debugModeBits & ~unsigned(DebugFromC)) || b;
 75489: 
 75489:     // Debug mode can be enabled only when no scripts from the target
 75489:     // compartment are on the stack. It would even be incorrect to discard just
 75489:     // the non-live scripts' JITScripts because they might share ICs with live
 75489:     // scripts (bug 632343).
 75489:     //
 75489:     // We do allow disabling debug mode while scripts are on the stack.  In
 75489:     // that case the debug-mode code for those scripts remains, so subsequently
 75489:     // hooks may be called erroneously, even though debug mode is supposedly
 75489:     // off, and we have to live with it.
 75489:     //
 75489:     bool onStack = false;
 75489:     if (enabledBefore != enabledAfter) {
 91250:         onStack = hasScriptsOnStack();
 75489:         if (b && onStack) {
 75489:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_DEBUG_NOT_IDLE);
 75489:             return false;
 75489:         }
 75489:     }
 75489: 
 91237:     debugModeBits = (debugModeBits & ~unsigned(DebugFromC)) | (b ? DebugFromC : 0);
 75489:     JS_ASSERT(debugMode() == enabledAfter);
 98921:     if (enabledBefore != enabledAfter) {
 98493:         updateForDebugMode(cx->runtime->defaultFreeOp(), dmgc);
 98921:         if (!enabledAfter)
124082:             DebugScopes::onCompartmentLeaveDebugMode(this);
 98921:     }
 75489:     return true;
 75489: }
 75489: 
 75489: void
 98493: JSCompartment::updateForDebugMode(FreeOp *fop, AutoDebugModeGC &dmgc)
 75489: {
 91250:     for (ContextIter acx(rt); !acx.done(); acx.next()) {
 91250:         if (acx->compartment == this)
 91250:             acx->updateJITEnabled();
 77166:     }
 77166: 
 75489: #ifdef JS_METHODJIT
 75497:     bool enabled = debugMode();
 75497: 
102509:     JS_ASSERT_IF(enabled, !hasScriptsOnStack());
 75489: 
 91287:     for (gc::CellIter i(this, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
 77659:         JSScript *script = i.get<JSScript>();
 75497:         script->debugMode = enabled;
 75489:     }
 97686: 
102509:     // When we change a compartment's debug mode, whether we're turning it
102509:     // on or off, we must always throw away all analyses: debug mode
102509:     // affects various aspects of the analysis, which then get baked into
102509:     // SSA results, which affects code generation in complicated ways. We
102509:     // must also throw away all JIT code, as its soundness depends on the
102509:     // analyses.
102509:     //
102509:     // It suffices to do a garbage collection cycle or to finish the
102509:     // ongoing GC cycle. The necessary cleanup happens in
102509:     // JSCompartment::sweep.
 98493:     //
 98493:     // dmgc makes sure we can't forget to GC, but it is also important not
 98493:     // to run any scripts in this compartment until the dmgc is destroyed.
 98493:     // That is the caller's responsibility.
103783:     if (!rt->isHeapBusy())
 98493:         dmgc.scheduleGC(this);
 75489: #endif
 75489: }
 75497: 
 75497: bool
 75497: JSCompartment::addDebuggee(JSContext *cx, js::GlobalObject *global)
 75497: {
 75497:     bool wasEnabled = debugMode();
 75497:     if (!debuggees.put(global)) {
 75497:         js_ReportOutOfMemory(cx);
 75497:         return false;
 75497:     }
 75497:     debugModeBits |= DebugFromJS;
 98493:     if (!wasEnabled) {
 98493:         AutoDebugModeGC dmgc(cx->runtime);
 98493:         updateForDebugMode(cx->runtime->defaultFreeOp(), dmgc);
 98493:     }
 75497:     return true;
 75497: }
 75497: 
 75497: void
 94740: JSCompartment::removeDebuggee(FreeOp *fop,
 75497:                               js::GlobalObject *global,
 75497:                               js::GlobalObjectSet::Enum *debuggeesEnum)
 75497: {
 75497:     bool wasEnabled = debugMode();
 75497:     JS_ASSERT(debuggees.has(global));
 75497:     if (debuggeesEnum)
 75497:         debuggeesEnum->removeFront();
 75497:     else
 75497:         debuggees.remove(global);
 75497: 
 75497:     if (debuggees.empty()) {
 75497:         debugModeBits &= ~DebugFromJS;
 98493:         if (wasEnabled && !debugMode()) {
 98493:             AutoDebugModeGC dmgc(rt);
124082:             DebugScopes::onCompartmentLeaveDebugMode(this);
 98493:             updateForDebugMode(fop, dmgc);
 98493:         }
 75497:     }
 75497: }
 75506: 
 84195: void
 94959: JSCompartment::clearBreakpointsIn(FreeOp *fop, js::Debugger *dbg, JSObject *handler)
 75506: {
 91287:     for (gc::CellIter i(this, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
 84195:         JSScript *script = i.get<JSScript>();
 84195:         if (script->hasAnyBreakpointsOrStepMode())
 94959:             script->clearBreakpointsIn(fop, dbg, handler);
 75506:     }
 75506: }
 75506: 
 75506: void
 94959: JSCompartment::clearTraps(FreeOp *fop)
 75506: {
 91287:     for (gc::CellIter i(this, gc::FINALIZE_SCRIPT); !i.done(); i.next()) {
 84195:         JSScript *script = i.get<JSScript>();
 84195:         if (script->hasAnyBreakpointsOrStepMode())
 94959:             script->clearTraps(fop);
 75506:     }
 75506: }
 75506: 
 75506: void
 94738: JSCompartment::sweepBreakpoints(FreeOp *fop)
 75506: {
124080:     gcstats::AutoPhase ap(rt->gcStats, gcstats::PHASE_SWEEP_TABLES_BREAKPOINT);
124080: 
 94738:     if (JS_CLIST_IS_EMPTY(&rt->debuggerList))
 84195:         return;
 76243: 
 84195:     for (CellIterUnderGC i(this, FINALIZE_SCRIPT); !i.done(); i.next()) {
 84195:         JSScript *script = i.get<JSScript>();
 84195:         if (!script->hasAnyBreakpointsOrStepMode())
 84195:             continue;
124075:         bool scriptGone = IsScriptAboutToBeFinalized(&script);
 99246:         JS_ASSERT(script == i.get<JSScript>());
 84195:         for (unsigned i = 0; i < script->length; i++) {
 84195:             BreakpointSite *site = script->getBreakpointSite(script->code + i);
 84195:             if (!site)
 84195:                 continue;
 84195:             // nextbp is necessary here to avoid possibly reading *bp after
 84195:             // destroying it.
 76233:             Breakpoint *nextbp;
 76233:             for (Breakpoint *bp = site->firstBreakpoint(); bp; bp = nextbp) {
 76233:                 nextbp = bp->nextInSite();
124075:                 if (scriptGone || IsObjectAboutToBeFinalized(&bp->debugger->toJSObjectRef()))
 94740:                     bp->destroy(fop);
 75506:             }
 84195:         }
 75506:     }
 75506: }
 82129: 
118353: void
118353: JSCompartment::sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf, size_t *compartmentObject,
118353:                                    TypeInferenceSizes *tiSizes, size_t *shapesCompartmentTables,
118353:                                    size_t *crossCompartmentWrappersArg, size_t *regexpCompartment,
118353:                                    size_t *debuggeesSet)
 86104: {
118353:     *compartmentObject = mallocSizeOf(this);
118353:     sizeOfTypeInferenceData(tiSizes, mallocSizeOf);
118353:     *shapesCompartmentTables = baseShapes.sizeOfExcludingThis(mallocSizeOf)
 88579:                              + initialShapes.sizeOfExcludingThis(mallocSizeOf)
 88579:                              + newTypeObjects.sizeOfExcludingThis(mallocSizeOf)
 88579:                              + lazyTypeObjects.sizeOfExcludingThis(mallocSizeOf);
118353:     *crossCompartmentWrappersArg = crossCompartmentWrappers.sizeOfExcludingThis(mallocSizeOf);
118353:     *regexpCompartment = regExps.sizeOfExcludingThis(mallocSizeOf);
118353:     *debuggeesSet = debuggees.sizeOfExcludingThis(mallocSizeOf);
 86104: }
