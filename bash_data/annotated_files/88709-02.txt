    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Scott Collins <scc@mozilla.org> (original author of nsCOMPtr)
    1:  *   L. David Baron <dbaron@dbaron.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsAutoPtr_h___
    1: #define nsAutoPtr_h___
    1: 
    1:   // Wrapping includes can speed up compiles (see "Large Scale C++ Software Design")
    1: #ifndef nsCOMPtr_h___
16558:   // For |already_AddRefed|, |NSCAP_Zero|,
    1:   // |NSCAP_DONT_PROVIDE_NONCONST_OPEQ|,
    1:   // |NSCAP_FEATURE_INLINE_STARTASSIGNMENT|
    1: #include "nsCOMPtr.h"
    1: #endif
    1: 
    1: /*****************************************************************************/
    1: 
    1: // template <class T> class nsAutoPtrGetterTransfers;
    1: 
    1: template <class T>
    1: class nsAutoPtr
    1:   {
    1:     private:
    1:       void**
    1:       begin_assignment()
    1:         {
    1:           assign(0);
 3233:           return reinterpret_cast<void**>(&mRawPtr);
    1:         }
    1: 
    1:       void
    1:       assign( T* newPtr )
    1:         {
88709:           NS_ABORT_IF_FALSE(mRawPtr != newPtr || !newPtr, "This makes no sense!");
    1:           T* oldPtr = mRawPtr;
    1:           mRawPtr = newPtr;
    1:           delete oldPtr;
    1:         }
    1: 
    1:       // |class Ptr| helps us prevent implicit "copy construction"
    1:       // through |operator T*() const| from a |const nsAutoPtr<T>|
    1:       // because two implicit conversions in a row aren't allowed.
    1:       // It still allows assignment from T* through implicit conversion
    1:       // from |T*| to |nsAutoPtr<T>::Ptr|
    1:       class Ptr
    1:         {
    1:           public:
    1:             Ptr( T* aPtr )
    1:                   : mPtr(aPtr)
    1:               {
    1:               }
    1: 
    1:             operator T*() const
    1:               {
    1:                 return mPtr;
    1:               }
    1: 
    1:           private:
    1:             T* mPtr;
    1:         };
    1: 
    1:     private:
    1:       T* mRawPtr;
    1: 
    1:     public:
    1:       typedef T element_type;
    1:       
    1:      ~nsAutoPtr()
    1:         {
    1:           delete mRawPtr;
    1:         }
    1: 
    1:         // Constructors
    1: 
    1:       nsAutoPtr()
    1:             : mRawPtr(0)
    1:           // default constructor
    1:         {
    1:         }
    1: 
    1:       nsAutoPtr( Ptr aRawPtr )
    1:             : mRawPtr(aRawPtr)
    1:           // construct from a raw pointer (of the right type)
    1:         {
    1:         }
    1: 
    1:       nsAutoPtr( nsAutoPtr<T>& aSmartPtr )
    1:             : mRawPtr( aSmartPtr.forget() )
    1:           // Construct by transferring ownership from another smart pointer.
    1:         {
    1:         }
    1: 
    1: 
    1:         // Assignment operators
    1: 
    1:       nsAutoPtr<T>&
    1:       operator=( T* rhs )
    1:           // assign from a raw pointer (of the right type)
    1:         {
    1:           assign(rhs);
    1:           return *this;
    1:         }
    1: 
    1:       nsAutoPtr<T>& operator=( nsAutoPtr<T>& rhs )
    1:           // assign by transferring ownership from another smart pointer.
    1:         {
    1:           assign(rhs.forget());
    1:           return *this;
    1:         }
    1: 
    1:         // Other pointer operators
    1: 
    1:       T*
    1:       get() const
    1:           /*
    1:             Prefer the implicit conversion provided automatically by
    1:             |operator T*() const|.  Use |get()| _only_ to resolve
    1:             ambiguity.
    1:           */
    1:         {
    1:           return mRawPtr;
    1:         }
    1: 
    1:       operator T*() const
    1:           /*
    1:             ...makes an |nsAutoPtr| act like its underlying raw pointer
    1:             type  whenever it is used in a context where a raw pointer
    1:             is expected.  It is this operator that makes an |nsAutoPtr|
    1:             substitutable for a raw pointer.
    1: 
    1:             Prefer the implicit use of this operator to calling |get()|,
    1:             except where necessary to resolve ambiguity.
    1:           */
    1:         {
    1:           return get();
    1:         }
    1: 
    1:       T*
    1:       forget()
    1:         {
    1:           T* temp = mRawPtr;
    1:           mRawPtr = 0;
    1:           return temp;
    1:         }
    1: 
    1:       T*
    1:       operator->() const
    1:         {
    1:           NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL nsAutoPtr with operator->().");
    1:           return get();
    1:         }
    1: 
34397:       // This operator is needed for gcc <= 4.0.* and for Sun Studio; it
34397:       // causes internal compiler errors for some MSVC versions.  (It's not
34397:       // clear to me whether it should be needed.)
34397: #ifndef _MSC_VER
34397:       template <class U, class V>
34397:       U&
34397:       operator->*(U V::* aMember)
34397:         {
34397:           NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL nsAutoPtr with operator->*().");
34397:           return get()->*aMember;
34397:         }
34397: #endif
34397: 
    1:       nsAutoPtr<T>*
    1:       get_address()
    1:           // This is not intended to be used by clients.  See |address_of|
    1:           // below.
    1:         {
    1:           return this;
    1:         }
    1: 
    1:       const nsAutoPtr<T>*
    1:       get_address() const
    1:           // This is not intended to be used by clients.  See |address_of|
    1:           // below.
    1:         {
    1:           return this;
    1:         }
    1: 
    1:     public:
    1:       T&
    1:       operator*() const
    1:         {
    1:           NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL nsAutoPtr with operator*().");
    1:           return *get();
    1:         }
    1: 
    1:       T**
    1:       StartAssignment()
    1:         {
    1: #ifndef NSCAP_FEATURE_INLINE_STARTASSIGNMENT
 3233:           return reinterpret_cast<T**>(begin_assignment());
    1: #else
    1:           assign(0);
 3233:           return reinterpret_cast<T**>(&mRawPtr);
    1: #endif
    1:         }
    1:   };
    1: 
    1: template <class T>
    1: inline
    1: nsAutoPtr<T>*
    1: address_of( nsAutoPtr<T>& aPtr )
    1:   {
    1:     return aPtr.get_address();
    1:   }
    1: 
    1: template <class T>
    1: inline
    1: const nsAutoPtr<T>*
    1: address_of( const nsAutoPtr<T>& aPtr )
    1:   {
    1:     return aPtr.get_address();
    1:   }
    1: 
    1: template <class T>
    1: class nsAutoPtrGetterTransfers
    1:     /*
    1:       ...
    1: 
    1:       This class is designed to be used for anonymous temporary objects in the
    1:       argument list of calls that return COM interface pointers, e.g.,
    1: 
    1:         nsAutoPtr<IFoo> fooP;
    1:         ...->GetTransferedPointer(getter_Transfers(fooP))
    1: 
    1:       DO NOT USE THIS TYPE DIRECTLY IN YOUR CODE.  Use |getter_Transfers()| instead.
    1: 
    1:       When initialized with a |nsAutoPtr|, as in the example above, it returns
    1:       a |void**|, a |T**|, or an |nsISupports**| as needed, that the
    1:       outer call (|GetTransferedPointer| in this case) can fill in.
    1: 
    1:       This type should be a nested class inside |nsAutoPtr<T>|.
    1:     */
    1:   {
    1:     public:
    1:       explicit
    1:       nsAutoPtrGetterTransfers( nsAutoPtr<T>& aSmartPtr )
    1:           : mTargetSmartPtr(aSmartPtr)
    1:         {
    1:           // nothing else to do
    1:         }
    1: 
    1:       operator void**()
    1:         {
 3233:           return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
    1:         }
    1: 
    1:       operator T**()
    1:         {
    1:           return mTargetSmartPtr.StartAssignment();
    1:         }
    1: 
    1:       T*&
    1:       operator*()
    1:         {
    1:           return *(mTargetSmartPtr.StartAssignment());
    1:         }
    1: 
    1:     private:
    1:       nsAutoPtr<T>& mTargetSmartPtr;
    1:   };
    1: 
    1: template <class T>
    1: inline
    1: nsAutoPtrGetterTransfers<T>
    1: getter_Transfers( nsAutoPtr<T>& aSmartPtr )
    1:     /*
    1:       Used around a |nsAutoPtr| when 
    1:       ...makes the class |nsAutoPtrGetterTransfers<T>| invisible.
    1:     */
    1:   {
    1:     return nsAutoPtrGetterTransfers<T>(aSmartPtr);
    1:   }
    1: 
    1: 
    1: 
    1:   // Comparing two |nsAutoPtr|s
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const nsAutoPtr<T>& lhs, const nsAutoPtr<U>& rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs.get());
    1:   }
    1: 
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const nsAutoPtr<T>& lhs, const nsAutoPtr<U>& rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs.get());
    1:   }
    1: 
    1: 
    1:   // Comparing an |nsAutoPtr| to a raw pointer
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const nsAutoPtr<T>& lhs, const U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const U* lhs, const nsAutoPtr<T>& rhs )
    1:   {
 3233:     return static_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const nsAutoPtr<T>& lhs, const U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const U* lhs, const nsAutoPtr<T>& rhs )
    1:   {
 3233:     return static_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
    1:   }
    1: 
    1:   // To avoid ambiguities caused by the presence of builtin |operator==|s
    1:   // creating a situation where one of the |operator==| defined above
    1:   // has a better conversion for one argument and the builtin has a
    1:   // better conversion for the other argument, define additional
    1:   // |operator==| without the |const| on the raw pointer.
    1:   // See bug 65664 for details.
    1: 
    1: #ifndef NSCAP_DONT_PROVIDE_NONCONST_OPEQ
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const nsAutoPtr<T>& lhs, U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) == const_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( U* lhs, const nsAutoPtr<T>& rhs )
    1:   {
 3233:     return const_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const nsAutoPtr<T>& lhs, U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) != const_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( U* lhs, const nsAutoPtr<T>& rhs )
    1:   {
 3233:     return const_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
    1:   }
    1: #endif
    1: 
    1: 
    1: 
    1:   // Comparing an |nsAutoPtr| to |0|
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( const nsAutoPtr<T>& lhs, NSCAP_Zero* rhs )
    1:     // specifically to allow |smartPtr == 0|
    1:   {
 3233:     return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( NSCAP_Zero* lhs, const nsAutoPtr<T>& rhs )
    1:     // specifically to allow |0 == smartPtr|
    1:   {
 3233:     return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator!=( const nsAutoPtr<T>& lhs, NSCAP_Zero* rhs )
    1:     // specifically to allow |smartPtr != 0|
    1:   {
 3233:     return static_cast<const void*>(lhs.get()) != reinterpret_cast<const void*>(rhs);
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator!=( NSCAP_Zero* lhs, const nsAutoPtr<T>& rhs )
    1:     // specifically to allow |0 != smartPtr|
    1:   {
 3233:     return reinterpret_cast<const void*>(lhs) != static_cast<const void*>(rhs.get());
    1:   }
    1: 
    1: 
    1: #ifdef HAVE_CPP_TROUBLE_COMPARING_TO_ZERO
    1: 
    1:   // We need to explicitly define comparison operators for `int'
    1:   // because the compiler is lame.
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( const nsAutoPtr<T>& lhs, int rhs )
    1:     // specifically to allow |smartPtr == 0|
    1:   {
 3233:     return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( int lhs, const nsAutoPtr<T>& rhs )
    1:     // specifically to allow |0 == smartPtr|
    1:   {
 3233:     return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
    1:   }
    1: 
    1: #endif // !defined(HAVE_CPP_TROUBLE_COMPARING_TO_ZERO)
    1: 
    1: /*****************************************************************************/
    1: 
    1: // template <class T> class nsAutoArrayPtrGetterTransfers;
    1: 
    1: template <class T>
    1: class nsAutoArrayPtr
    1:   {
    1:     private:
    1:       void**
    1:       begin_assignment()
    1:         {
    1:           assign(0);
 3233:           return reinterpret_cast<void**>(&mRawPtr);
    1:         }
    1: 
    1:       void
    1:       assign( T* newPtr )
    1:         {
    1:           T* oldPtr = mRawPtr;
    1:           mRawPtr = newPtr;
    1:           delete [] oldPtr;
    1:         }
    1: 
    1:     private:
    1:       T* mRawPtr;
    1: 
    1:     public:
    1:       typedef T element_type;
    1:       
    1:      ~nsAutoArrayPtr()
    1:         {
    1:           delete [] mRawPtr;
    1:         }
    1: 
    1:         // Constructors
    1: 
    1:       nsAutoArrayPtr()
    1:             : mRawPtr(0)
    1:           // default constructor
    1:         {
    1:         }
    1: 
    1:       nsAutoArrayPtr( T* aRawPtr )
    1:             : mRawPtr(aRawPtr)
    1:           // construct from a raw pointer (of the right type)
    1:         {
    1:         }
    1: 
    1:       nsAutoArrayPtr( nsAutoArrayPtr<T>& aSmartPtr )
    1:             : mRawPtr( aSmartPtr.forget() )
    1:           // Construct by transferring ownership from another smart pointer.
    1:         {
    1:         }
    1: 
    1: 
    1:         // Assignment operators
    1: 
    1:       nsAutoArrayPtr<T>&
    1:       operator=( T* rhs )
    1:           // assign from a raw pointer (of the right type)
    1:         {
    1:           assign(rhs);
    1:           return *this;
    1:         }
    1: 
    1:       nsAutoArrayPtr<T>& operator=( nsAutoArrayPtr<T>& rhs )
    1:           // assign by transferring ownership from another smart pointer.
    1:         {
    1:           assign(rhs.forget());
    1:           return *this;
    1:         }
    1: 
    1:         // Other pointer operators
    1: 
    1:       T*
    1:       get() const
    1:           /*
    1:             Prefer the implicit conversion provided automatically by
    1:             |operator T*() const|.  Use |get()| _only_ to resolve
    1:             ambiguity.
    1:           */
    1:         {
    1:           return mRawPtr;
    1:         }
    1: 
    1:       operator T*() const
    1:           /*
    1:             ...makes an |nsAutoArrayPtr| act like its underlying raw pointer
    1:             type  whenever it is used in a context where a raw pointer
    1:             is expected.  It is this operator that makes an |nsAutoArrayPtr|
    1:             substitutable for a raw pointer.
    1: 
    1:             Prefer the implicit use of this operator to calling |get()|,
    1:             except where necessary to resolve ambiguity.
    1:           */
    1:         {
    1:           return get();
    1:         }
    1: 
    1:       T*
    1:       forget()
    1:         {
    1:           T* temp = mRawPtr;
    1:           mRawPtr = 0;
    1:           return temp;
    1:         }
    1: 
    1:       T*
    1:       operator->() const
    1:         {
    1:           NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL nsAutoArrayPtr with operator->().");
    1:           return get();
    1:         }
    1: 
    1:       nsAutoArrayPtr<T>*
    1:       get_address()
    1:           // This is not intended to be used by clients.  See |address_of|
    1:           // below.
    1:         {
    1:           return this;
    1:         }
    1: 
    1:       const nsAutoArrayPtr<T>*
    1:       get_address() const
    1:           // This is not intended to be used by clients.  See |address_of|
    1:           // below.
    1:         {
    1:           return this;
    1:         }
    1: 
    1:     public:
    1:       T&
    1:       operator*() const
    1:         {
    1:           NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL nsAutoArrayPtr with operator*().");
    1:           return *get();
    1:         }
    1: 
    1:       T**
    1:       StartAssignment()
    1:         {
    1: #ifndef NSCAP_FEATURE_INLINE_STARTASSIGNMENT
 3233:           return reinterpret_cast<T**>(begin_assignment());
    1: #else
    1:           assign(0);
 3233:           return reinterpret_cast<T**>(&mRawPtr);
    1: #endif
    1:         }
    1:   };
    1: 
    1: template <class T>
    1: inline
    1: nsAutoArrayPtr<T>*
    1: address_of( nsAutoArrayPtr<T>& aPtr )
    1:   {
    1:     return aPtr.get_address();
    1:   }
    1: 
    1: template <class T>
    1: inline
    1: const nsAutoArrayPtr<T>*
    1: address_of( const nsAutoArrayPtr<T>& aPtr )
    1:   {
    1:     return aPtr.get_address();
    1:   }
    1: 
    1: template <class T>
    1: class nsAutoArrayPtrGetterTransfers
    1:     /*
    1:       ...
    1: 
    1:       This class is designed to be used for anonymous temporary objects in the
    1:       argument list of calls that return COM interface pointers, e.g.,
    1: 
    1:         nsAutoArrayPtr<IFoo> fooP;
    1:         ...->GetTransferedPointer(getter_Transfers(fooP))
    1: 
    1:       DO NOT USE THIS TYPE DIRECTLY IN YOUR CODE.  Use |getter_Transfers()| instead.
    1: 
    1:       When initialized with a |nsAutoArrayPtr|, as in the example above, it returns
    1:       a |void**|, a |T**|, or an |nsISupports**| as needed, that the
    1:       outer call (|GetTransferedPointer| in this case) can fill in.
    1: 
    1:       This type should be a nested class inside |nsAutoArrayPtr<T>|.
    1:     */
    1:   {
    1:     public:
    1:       explicit
    1:       nsAutoArrayPtrGetterTransfers( nsAutoArrayPtr<T>& aSmartPtr )
    1:           : mTargetSmartPtr(aSmartPtr)
    1:         {
    1:           // nothing else to do
    1:         }
    1: 
    1:       operator void**()
    1:         {
 3233:           return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
    1:         }
    1: 
    1:       operator T**()
    1:         {
    1:           return mTargetSmartPtr.StartAssignment();
    1:         }
    1: 
    1:       T*&
    1:       operator*()
    1:         {
    1:           return *(mTargetSmartPtr.StartAssignment());
    1:         }
    1: 
    1:     private:
    1:       nsAutoArrayPtr<T>& mTargetSmartPtr;
    1:   };
    1: 
    1: template <class T>
    1: inline
    1: nsAutoArrayPtrGetterTransfers<T>
    1: getter_Transfers( nsAutoArrayPtr<T>& aSmartPtr )
    1:     /*
    1:       Used around a |nsAutoArrayPtr| when 
    1:       ...makes the class |nsAutoArrayPtrGetterTransfers<T>| invisible.
    1:     */
    1:   {
    1:     return nsAutoArrayPtrGetterTransfers<T>(aSmartPtr);
    1:   }
    1: 
    1: 
    1: 
    1:   // Comparing two |nsAutoArrayPtr|s
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const nsAutoArrayPtr<T>& lhs, const nsAutoArrayPtr<U>& rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs.get());
    1:   }
    1: 
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const nsAutoArrayPtr<T>& lhs, const nsAutoArrayPtr<U>& rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs.get());
    1:   }
    1: 
    1: 
    1:   // Comparing an |nsAutoArrayPtr| to a raw pointer
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const nsAutoArrayPtr<T>& lhs, const U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const U* lhs, const nsAutoArrayPtr<T>& rhs )
    1:   {
 3233:     return static_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const nsAutoArrayPtr<T>& lhs, const U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const U* lhs, const nsAutoArrayPtr<T>& rhs )
    1:   {
 3233:     return static_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
    1:   }
    1: 
    1:   // To avoid ambiguities caused by the presence of builtin |operator==|s
    1:   // creating a situation where one of the |operator==| defined above
    1:   // has a better conversion for one argument and the builtin has a
    1:   // better conversion for the other argument, define additional
    1:   // |operator==| without the |const| on the raw pointer.
    1:   // See bug 65664 for details.
    1: 
    1: #ifndef NSCAP_DONT_PROVIDE_NONCONST_OPEQ
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const nsAutoArrayPtr<T>& lhs, U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) == const_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( U* lhs, const nsAutoArrayPtr<T>& rhs )
    1:   {
 3233:     return const_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const nsAutoArrayPtr<T>& lhs, U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) != const_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( U* lhs, const nsAutoArrayPtr<T>& rhs )
    1:   {
 3233:     return const_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
    1:   }
    1: #endif
    1: 
    1: 
    1: 
    1:   // Comparing an |nsAutoArrayPtr| to |0|
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( const nsAutoArrayPtr<T>& lhs, NSCAP_Zero* rhs )
    1:     // specifically to allow |smartPtr == 0|
    1:   {
 3233:     return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( NSCAP_Zero* lhs, const nsAutoArrayPtr<T>& rhs )
    1:     // specifically to allow |0 == smartPtr|
    1:   {
 3233:     return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator!=( const nsAutoArrayPtr<T>& lhs, NSCAP_Zero* rhs )
    1:     // specifically to allow |smartPtr != 0|
    1:   {
 3233:     return static_cast<const void*>(lhs.get()) != reinterpret_cast<const void*>(rhs);
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator!=( NSCAP_Zero* lhs, const nsAutoArrayPtr<T>& rhs )
    1:     // specifically to allow |0 != smartPtr|
    1:   {
 3233:     return reinterpret_cast<const void*>(lhs) != static_cast<const void*>(rhs.get());
    1:   }
    1: 
    1: 
    1: #ifdef HAVE_CPP_TROUBLE_COMPARING_TO_ZERO
    1: 
    1:   // We need to explicitly define comparison operators for `int'
    1:   // because the compiler is lame.
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( const nsAutoArrayPtr<T>& lhs, int rhs )
    1:     // specifically to allow |smartPtr == 0|
    1:   {
 3233:     return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( int lhs, const nsAutoArrayPtr<T>& rhs )
    1:     // specifically to allow |0 == smartPtr|
    1:   {
 3233:     return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
    1:   }
    1: 
    1: #endif // !defined(HAVE_CPP_TROUBLE_COMPARING_TO_ZERO)
    1: 
    1: 
    1: /*****************************************************************************/
    1: 
    1: // template <class T> class nsRefPtrGetterAddRefs;
    1: 
    1: template <class T>
    1: class nsRefPtr
    1:   {
    1:     private:
    1: 
    1:       void
    1:       assign_with_AddRef( T* rawPtr )
    1:         {
    1:           if ( rawPtr )
    1:             rawPtr->AddRef();
    1:           assign_assuming_AddRef(rawPtr);
    1:         }
    1: 
    1:       void**
    1:       begin_assignment()
    1:         {
    1:           assign_assuming_AddRef(0);
 3233:           return reinterpret_cast<void**>(&mRawPtr);
    1:         }
    1: 
    1:       void
    1:       assign_assuming_AddRef( T* newPtr )
    1:         {
    1:           T* oldPtr = mRawPtr;
    1:           mRawPtr = newPtr;
    1:           if ( oldPtr )
    1:             oldPtr->Release();
    1:         }
    1: 
    1:     private:
    1:       T* mRawPtr;
    1: 
    1:     public:
    1:       typedef T element_type;
    1:       
    1:      ~nsRefPtr()
    1:         {
    1:           if ( mRawPtr )
    1:             mRawPtr->Release();
    1:         }
    1: 
    1:         // Constructors
    1: 
    1:       nsRefPtr()
    1:             : mRawPtr(0)
    1:           // default constructor
    1:         {
    1:         }
    1: 
    1:       nsRefPtr( const nsRefPtr<T>& aSmartPtr )
    1:             : mRawPtr(aSmartPtr.mRawPtr)
    1:           // copy-constructor
    1:         {
    1:           if ( mRawPtr )
    1:             mRawPtr->AddRef();
    1:         }
    1: 
    1:       nsRefPtr( T* aRawPtr )
    1:             : mRawPtr(aRawPtr)
    1:           // construct from a raw pointer (of the right type)
    1:         {
    1:           if ( mRawPtr )
    1:             mRawPtr->AddRef();
    1:         }
    1: 
38802:       template <typename I>
38802:       nsRefPtr( const already_AddRefed<I>& aSmartPtr )
    1:             : mRawPtr(aSmartPtr.mRawPtr)
    1:           // construct from |dont_AddRef(expr)|
    1:         {
    1:         }
    1: 
41309:       nsRefPtr( const nsCOMPtr_helper& helper )
41309:         {
41309:           void* newRawPtr;
41309:           if (NS_FAILED(helper(NS_GET_TEMPLATE_IID(T), &newRawPtr)))
41309:             newRawPtr = 0;
41309:           mRawPtr = static_cast<T*>(newRawPtr);
41309:         }
41309: 
    1:         // Assignment operators
    1: 
    1:       nsRefPtr<T>&
    1:       operator=( const nsRefPtr<T>& rhs )
    1:           // copy assignment operator
    1:         {
    1:           assign_with_AddRef(rhs.mRawPtr);
    1:           return *this;
    1:         }
    1: 
    1:       nsRefPtr<T>&
    1:       operator=( T* rhs )
    1:           // assign from a raw pointer (of the right type)
    1:         {
    1:           assign_with_AddRef(rhs);
    1:           return *this;
    1:         }
    1: 
38802:       template <typename I>
    1:       nsRefPtr<T>&
38802:       operator=( const already_AddRefed<I>& rhs )
    1:           // assign from |dont_AddRef(expr)|
    1:         {
    1:           assign_assuming_AddRef(rhs.mRawPtr);
    1:           return *this;
    1:         }
    1: 
41309:       nsRefPtr<T>&
41309:       operator=( const nsCOMPtr_helper& helper )
41309:         {
41309:           void* newRawPtr;
41309:           if (NS_FAILED(helper(NS_GET_TEMPLATE_IID(T), &newRawPtr)))
41309:             newRawPtr = 0;
41309:           assign_assuming_AddRef(static_cast<T*>(newRawPtr));
41309:           return *this;
41309:         }
41309: 
    1:         // Other pointer operators
    1: 
    1:       void
    1:       swap( nsRefPtr<T>& rhs )
    1:           // ...exchange ownership with |rhs|; can save a pair of refcount operations
    1:         {
    1:           T* temp = rhs.mRawPtr;
    1:           rhs.mRawPtr = mRawPtr;
    1:           mRawPtr = temp;
    1:         }
    1: 
    1:       void
    1:       swap( T*& rhs )
    1:           // ...exchange ownership with |rhs|; can save a pair of refcount operations
    1:         {
    1:           T* temp = rhs;
    1:           rhs = mRawPtr;
    1:           mRawPtr = temp;
    1:         }
    1: 
 5401:       already_AddRefed<T>
 5401:       forget()
 5401:           // return the value of mRawPtr and null out mRawPtr. Useful for
 5401:           // already_AddRefed return values.
 5401:         {
 5401:           T* temp = 0;
 5401:           swap(temp);
 5401:           return temp;
 5401:         }
 5401: 
28076:       template <typename I>
 7805:       void
28076:       forget( I** rhs)
 7805:           // Set the target of rhs to the value of mRawPtr and null out mRawPtr.
 7805:           // Useful to avoid unnecessary AddRef/Release pairs with "out"
28076:           // parameters where rhs bay be a T** or an I** where I is a base class
28076:           // of T.
 7805:         {
 7805:           NS_ASSERTION(rhs, "Null pointer passed to forget!");
28076:           *rhs = mRawPtr;
28076:           mRawPtr = 0;
 7805:         }
 7805: 
    1:       T*
    1:       get() const
    1:           /*
16558:             Prefer the implicit conversion provided automatically by |operator T*() const|.
    1:             Use |get()| to resolve ambiguity or to get a castable pointer.
    1:           */
    1:         {
 3233:           return const_cast<T*>(mRawPtr);
    1:         }
    1: 
16558:       operator T*() const
    1:           /*
16558:             ...makes an |nsRefPtr| act like its underlying raw pointer type whenever it
16558:             is used in a context where a raw pointer is expected.  It is this operator
    1:             that makes an |nsRefPtr| substitutable for a raw pointer.
    1: 
16558:             Prefer the implicit use of this operator to calling |get()|, except where
16558:             necessary to resolve ambiguity.
    1:           */
    1:         {
16558:           return get();
    1:         }
    1: 
84524:       T*
    1:       operator->() const
    1:         {
    1:           NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL nsRefPtr with operator->().");
84524:           return get();
    1:         }
    1: 
34397:       // This operator is needed for gcc <= 4.0.* and for Sun Studio; it
34397:       // causes internal compiler errors for some MSVC versions.  (It's not
34397:       // clear to me whether it should be needed.)
34397: #ifndef _MSC_VER
34397:       template <class U, class V>
34397:       U&
34397:       operator->*(U V::* aMember)
34397:         {
34397:           NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL nsRefPtr with operator->*().");
34397:           return get()->*aMember;
34397:         }
34397: #endif
34397: 
    1:       nsRefPtr<T>*
    1:       get_address()
    1:           // This is not intended to be used by clients.  See |address_of|
    1:           // below.
    1:         {
    1:           return this;
    1:         }
    1: 
    1:       const nsRefPtr<T>*
    1:       get_address() const
    1:           // This is not intended to be used by clients.  See |address_of|
    1:           // below.
    1:         {
    1:           return this;
    1:         }
    1: 
    1:     public:
16558:       T&
    1:       operator*() const
    1:         {
    1:           NS_PRECONDITION(mRawPtr != 0, "You can't dereference a NULL nsRefPtr with operator*().");
16558:           return *get();
    1:         }
    1: 
    1:       T**
    1:       StartAssignment()
    1:         {
    1: #ifndef NSCAP_FEATURE_INLINE_STARTASSIGNMENT
 3233:           return reinterpret_cast<T**>(begin_assignment());
    1: #else
    1:           assign_assuming_AddRef(0);
 3233:           return reinterpret_cast<T**>(&mRawPtr);
    1: #endif
    1:         }
    1:   };
    1: 
    1: template <class T>
    1: inline
    1: nsRefPtr<T>*
    1: address_of( nsRefPtr<T>& aPtr )
    1:   {
    1:     return aPtr.get_address();
    1:   }
    1: 
    1: template <class T>
    1: inline
    1: const nsRefPtr<T>*
    1: address_of( const nsRefPtr<T>& aPtr )
    1:   {
    1:     return aPtr.get_address();
    1:   }
    1: 
    1: template <class T>
    1: class nsRefPtrGetterAddRefs
    1:     /*
    1:       ...
    1: 
    1:       This class is designed to be used for anonymous temporary objects in the
    1:       argument list of calls that return COM interface pointers, e.g.,
    1: 
    1:         nsRefPtr<IFoo> fooP;
    1:         ...->GetAddRefedPointer(getter_AddRefs(fooP))
    1: 
    1:       DO NOT USE THIS TYPE DIRECTLY IN YOUR CODE.  Use |getter_AddRefs()| instead.
    1: 
    1:       When initialized with a |nsRefPtr|, as in the example above, it returns
    1:       a |void**|, a |T**|, or an |nsISupports**| as needed, that the
    1:       outer call (|GetAddRefedPointer| in this case) can fill in.
    1: 
    1:       This type should be a nested class inside |nsRefPtr<T>|.
    1:     */
    1:   {
    1:     public:
    1:       explicit
    1:       nsRefPtrGetterAddRefs( nsRefPtr<T>& aSmartPtr )
    1:           : mTargetSmartPtr(aSmartPtr)
    1:         {
    1:           // nothing else to do
    1:         }
    1: 
    1:       operator void**()
    1:         {
 3233:           return reinterpret_cast<void**>(mTargetSmartPtr.StartAssignment());
    1:         }
    1: 
    1:       operator T**()
    1:         {
    1:           return mTargetSmartPtr.StartAssignment();
    1:         }
    1: 
    1:       T*&
    1:       operator*()
    1:         {
    1:           return *(mTargetSmartPtr.StartAssignment());
    1:         }
    1: 
    1:     private:
    1:       nsRefPtr<T>& mTargetSmartPtr;
    1:   };
    1: 
    1: template <class T>
    1: inline
    1: nsRefPtrGetterAddRefs<T>
    1: getter_AddRefs( nsRefPtr<T>& aSmartPtr )
    1:     /*
    1:       Used around a |nsRefPtr| when 
    1:       ...makes the class |nsRefPtrGetterAddRefs<T>| invisible.
    1:     */
    1:   {
    1:     return nsRefPtrGetterAddRefs<T>(aSmartPtr);
    1:   }
    1: 
    1: 
    1: 
    1:   // Comparing two |nsRefPtr|s
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const nsRefPtr<T>& lhs, const nsRefPtr<U>& rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs.get());
    1:   }
    1: 
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const nsRefPtr<T>& lhs, const nsRefPtr<U>& rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs.get());
    1:   }
    1: 
    1: 
    1:   // Comparing an |nsRefPtr| to a raw pointer
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const nsRefPtr<T>& lhs, const U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) == static_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const U* lhs, const nsRefPtr<T>& rhs )
    1:   {
 3233:     return static_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const nsRefPtr<T>& lhs, const U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) != static_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const U* lhs, const nsRefPtr<T>& rhs )
    1:   {
 3233:     return static_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
    1:   }
    1: 
    1:   // To avoid ambiguities caused by the presence of builtin |operator==|s
    1:   // creating a situation where one of the |operator==| defined above
    1:   // has a better conversion for one argument and the builtin has a
    1:   // better conversion for the other argument, define additional
    1:   // |operator==| without the |const| on the raw pointer.
    1:   // See bug 65664 for details.
    1: 
    1: #ifndef NSCAP_DONT_PROVIDE_NONCONST_OPEQ
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( const nsRefPtr<T>& lhs, U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) == const_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator==( U* lhs, const nsRefPtr<T>& rhs )
    1:   {
 3233:     return const_cast<const U*>(lhs) == static_cast<const T*>(rhs.get());
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( const nsRefPtr<T>& lhs, U* rhs )
    1:   {
 3233:     return static_cast<const T*>(lhs.get()) != const_cast<const U*>(rhs);
    1:   }
    1: 
    1: template <class T, class U>
    1: inline
77297: bool
    1: operator!=( U* lhs, const nsRefPtr<T>& rhs )
    1:   {
 3233:     return const_cast<const U*>(lhs) != static_cast<const T*>(rhs.get());
    1:   }
    1: #endif
    1: 
    1: 
    1: 
    1:   // Comparing an |nsRefPtr| to |0|
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( const nsRefPtr<T>& lhs, NSCAP_Zero* rhs )
    1:     // specifically to allow |smartPtr == 0|
    1:   {
 3233:     return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( NSCAP_Zero* lhs, const nsRefPtr<T>& rhs )
    1:     // specifically to allow |0 == smartPtr|
    1:   {
 3233:     return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator!=( const nsRefPtr<T>& lhs, NSCAP_Zero* rhs )
    1:     // specifically to allow |smartPtr != 0|
    1:   {
 3233:     return static_cast<const void*>(lhs.get()) != reinterpret_cast<const void*>(rhs);
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator!=( NSCAP_Zero* lhs, const nsRefPtr<T>& rhs )
    1:     // specifically to allow |0 != smartPtr|
    1:   {
 3233:     return reinterpret_cast<const void*>(lhs) != static_cast<const void*>(rhs.get());
    1:   }
    1: 
    1: 
    1: #ifdef HAVE_CPP_TROUBLE_COMPARING_TO_ZERO
    1: 
    1:   // We need to explicitly define comparison operators for `int'
    1:   // because the compiler is lame.
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( const nsRefPtr<T>& lhs, int rhs )
    1:     // specifically to allow |smartPtr == 0|
    1:   {
 3233:     return static_cast<const void*>(lhs.get()) == reinterpret_cast<const void*>(rhs);
    1:   }
    1: 
    1: template <class T>
    1: inline
77297: bool
    1: operator==( int lhs, const nsRefPtr<T>& rhs )
    1:     // specifically to allow |0 == smartPtr|
    1:   {
 3233:     return reinterpret_cast<const void*>(lhs) == static_cast<const void*>(rhs.get());
    1:   }
    1: 
    1: #endif // !defined(HAVE_CPP_TROUBLE_COMPARING_TO_ZERO)
    1: 
38781: template <class SourceType, class DestinationType>
38781: inline
38781: nsresult
38781: CallQueryInterface( nsRefPtr<SourceType>& aSourcePtr, DestinationType** aDestPtr )
38781:   {
38781:     return CallQueryInterface(aSourcePtr.get(), aDestPtr);
38781:   }
38781: 
    1: /*****************************************************************************/
    1: 
41309: template<class T>
41309: class nsQueryObject : public nsCOMPtr_helper
41309: {
41309: public:
41309:   nsQueryObject(T* aRawPtr)
41309:     : mRawPtr(aRawPtr) {}
41309: 
41309:   virtual nsresult NS_FASTCALL operator()( const nsIID& aIID, void** aResult ) const {
41309:     nsresult status = mRawPtr ? mRawPtr->QueryInterface(aIID, aResult)
41309:                               : NS_ERROR_NULL_POINTER;
41309:     return status;
41309:   }
41309: private:
41309:   T* mRawPtr;
41309: };
41309: 
41309: template<class T>
41309: class nsQueryObjectWithError : public nsCOMPtr_helper
41309: {
41309: public:
41309:   nsQueryObjectWithError(T* aRawPtr, nsresult* aErrorPtr)
41309:     : mRawPtr(aRawPtr), mErrorPtr(aErrorPtr) {}
41309: 
41309:   virtual nsresult NS_FASTCALL operator()( const nsIID& aIID, void** aResult ) const {
41309:     nsresult status = mRawPtr ? mRawPtr->QueryInterface(aIID, aResult)
41309:                               : NS_ERROR_NULL_POINTER;
41309:     if (mErrorPtr)
41309:       *mErrorPtr = status;
41309:     return status;
41309:   }
41309: private:
41309:   T* mRawPtr;
41309:   nsresult* mErrorPtr;
41309: };
41309: 
41309: template<class T>
41309: inline
41309: nsQueryObject<T>
41309: do_QueryObject(T* aRawPtr)
41309: {
41309:   return nsQueryObject<T>(aRawPtr);
41309: }
41309: 
41309: template<class T>
41309: inline
41309: nsQueryObject<T>
41309: do_QueryObject(nsCOMPtr<T>& aRawPtr)
41309: {
41309:   return nsQueryObject<T>(aRawPtr);
41309: }
41309: 
41309: template<class T>
41309: inline
41309: nsQueryObject<T>
41309: do_QueryObject(nsRefPtr<T>& aRawPtr)
41309: {
41309:   return nsQueryObject<T>(aRawPtr);
41309: }
41309: 
41309: template<class T>
41309: inline
41309: nsQueryObjectWithError<T>
41309: do_QueryObject(T* aRawPtr, nsresult* aErrorPtr)
41309: {
41309:   return nsQueryObjectWithError<T>(aRawPtr, aErrorPtr);
41309: }
41309: 
41309: template<class T>
41309: inline
41309: nsQueryObjectWithError<T>
41309: do_QueryObject(nsCOMPtr<T>& aRawPtr, nsresult* aErrorPtr)
41309: {
41309:   return nsQueryObjectWithError<T>(aRawPtr, aErrorPtr);
41309: }
41309: 
41309: template<class T>
41309: inline
41309: nsQueryObjectWithError<T>
41309: do_QueryObject(nsRefPtr<T>& aRawPtr, nsresult* aErrorPtr)
41309: {
41309:   return nsQueryObjectWithError<T>(aRawPtr, aErrorPtr);
41309: }
41309: 
41309: /*****************************************************************************/
41309: 
    1: #endif // !defined(nsAutoPtr_h___)
