    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Witte (dwitte@stanford.edu)
    1:  *   Michiel van Leeuwen (mvl@exedo.nl)
20636:  *   Michael Ventnor <m.ventnor@gmail.com>
20636:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsCookieService_h__
    1: #define nsCookieService_h__
    1: 
 2796: #include "nsICookieService.h"
    1: #include "nsICookieManager.h"
    1: #include "nsICookieManager2.h"
    1: #include "nsIObserver.h"
    1: #include "nsWeakReference.h"
    1: 
    1: #include "nsCookie.h"
    1: #include "nsString.h"
    1: #include "nsTHashtable.h"
    1: 
    1: struct nsCookieAttributes;
    1: struct nsListIter;
    1: struct nsEnumerationData;
    1: 
    1: class nsICookiePermission;
 8702: class nsIEffectiveTLDService;
    1: class nsIPrefBranch;
    1: class nsIObserverService;
    1: class nsIURI;
    1: class nsIChannel;
 2508: class mozIStorageConnection;
 2508: class mozIStorageStatement;
    1: 
    1: // hash entry class
    1: class nsCookieEntry : public PLDHashEntryHdr
    1: {
    1:   public:
    1:     // Hash methods
    1:     typedef const char* KeyType;
    1:     typedef const char* KeyTypePointer;
    1: 
    1:     // do nothing with aHost - we require mHead to be set before we're live!
30354:     explicit
    1:     nsCookieEntry(KeyTypePointer aHost)
    1:      : mHead(nsnull)
    1:     {
    1:     }
    1: 
    1:     nsCookieEntry(const nsCookieEntry& toCopy)
    1:     {
    1:       // if we end up here, things will break. nsTHashtable shouldn't
    1:       // allow this, since we set ALLOW_MEMMOVE to true.
    1:       NS_NOTREACHED("nsCookieEntry copy constructor is forbidden!");
    1:     }
    1: 
    1:     ~nsCookieEntry()
    1:     {
    1:       // walk the linked list, and de-link everything by releasing & nulling.
    1:       // this allows the parent host entry to be deleted by the hashtable.
    1:       // note: we know mHead cannot be null here - we always set mHead to a
    1:       // valid nsCookie (if it were null, the hashtable wouldn't be able to find
    1:       // this entry, because the key string is provided by mHead).
    1:       nsCookie *current = mHead, *next;
    1:       do {
    1:         next = current->Next();
    1:         NS_RELEASE(current);
    1:       } while ((current = next));
    1:     }
    1: 
    1:     KeyType GetKey() const
    1:     {
    1:       return HostPtr();
    1:     }
    1: 
    1:     PRBool KeyEquals(KeyTypePointer aKey) const
    1:     {
    1:       return !strcmp(HostPtr(), aKey);
    1:     }
    1: 
    1:     static KeyTypePointer KeyToPointer(KeyType aKey)
    1:     {
    1:       return aKey;
    1:     }
    1: 
    1:     static PLDHashNumber HashKey(KeyTypePointer aKey)
    1:     {
    1:       // PL_DHashStringKey doesn't use the table parameter, so we can safely
    1:       // pass nsnull
    1:       return PL_DHashStringKey(nsnull, aKey);
    1:     }
    1: 
    1:     enum { ALLOW_MEMMOVE = PR_TRUE };
    1: 
    1:     // get methods
    1:     inline const nsDependentCString Host() const { return mHead->Host(); }
    1: 
    1:     // linked list management helper
    1:     inline nsCookie*& Head() { return mHead; }
    1: 
    1:     inline KeyTypePointer HostPtr() const
    1:     {
    1:       return mHead->Host().get();
    1:     }
    1: 
    1:   private:
    1:     nsCookie *mHead;
    1: };
    1: 
33960: // encapsulates in-memory and on-disk DB states, so we can
33960: // conveniently switch state when entering or exiting private browsing.
33960: struct DBState
33960: {
33960:   DBState() : cookieCount(0) { }
33960: 
33960:   nsTHashtable<nsCookieEntry>     hostTable;
33960:   PRUint32                        cookieCount;
33960:   nsCOMPtr<mozIStorageConnection> dbConn;
33960:   nsCOMPtr<mozIStorageStatement>  stmtInsert;
33960:   nsCOMPtr<mozIStorageStatement>  stmtDelete;
33960:   nsCOMPtr<mozIStorageStatement>  stmtUpdate;
33960: };
33960: 
    1: /******************************************************************************
    1:  * nsCookieService:
    1:  * class declaration
    1:  ******************************************************************************/
    1: 
 2796: class nsCookieService : public nsICookieService
    1:                       , public nsICookieManager2
    1:                       , public nsIObserver
    1:                       , public nsSupportsWeakReference
    1: {
    1:   public:
    1:     // nsISupports
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIOBSERVER
    1:     NS_DECL_NSICOOKIESERVICE
    1:     NS_DECL_NSICOOKIEMANAGER
    1:     NS_DECL_NSICOOKIEMANAGER2
    1: 
    1:     nsCookieService();
    1:     virtual ~nsCookieService();
    1:     static nsCookieService*       GetSingleton();
    1:     nsresult                      Init();
    1: 
    1:   protected:
    1:     void                          PrefChanged(nsIPrefBranch *aPrefBranch);
33960:     nsresult                      InitDB();
33960:     nsresult                      TryInitDB(PRBool aDeleteExistingDB);
 2508:     nsresult                      CreateTable();
22579:     void                          CloseDB();
    1:     nsresult                      Read();
12921:     void                          GetCookieInternal(nsIURI *aHostURI, nsIChannel *aChannel, PRBool aHttpBound, char **aCookie);
12921:     nsresult                      SetCookieStringInternal(nsIURI *aHostURI, nsIPrompt *aPrompt, const char *aCookieHeader, const char *aServerTime, nsIChannel *aChannel, PRBool aFromHttp);
 2793:     PRBool                        SetCookieInternal(nsIURI *aHostURI, nsIChannel *aChannel, nsDependentCString &aCookieHeader, PRInt64 aServerTime, PRBool aFromHttp);
30480:     void                          AddInternal(nsCookie *aCookie, PRInt64 aCurrentTime, nsIURI *aHostURI, const char *aCookieHeader, PRBool aFromHttp);
    1:     void                          RemoveCookieFromList(nsListIter &aIter);
 2508:     PRBool                        AddCookieToList(nsCookie *aCookie, PRBool aWriteToDB = PR_TRUE);
 8141:     void                          UpdateCookieInList(nsCookie *aCookie, PRInt64 aLastAccessed);
    1:     static PRBool                 GetTokenValue(nsASingleFragmentCString::const_char_iterator &aIter, nsASingleFragmentCString::const_char_iterator &aEndIter, nsDependentCSubstring &aTokenString, nsDependentCSubstring &aTokenValue, PRBool &aEqualsFound);
    1:     static PRBool                 ParseAttributes(nsDependentCString &aCookieHeader, nsCookieAttributes &aCookie);
 8702:     PRBool                        IsForeign(nsIURI *aHostURI, nsIURI *aFirstURI);
12921:     PRUint32                      CheckPrefs(nsIURI *aHostURI, nsIChannel *aChannel, const char *aCookieHeader);
 8702:     PRBool                        CheckDomain(nsCookieAttributes &aCookie, nsIURI *aHostURI);
    1:     static PRBool                 CheckPath(nsCookieAttributes &aCookie, nsIURI *aHostURI);
 2626:     static PRBool                 GetExpiry(nsCookieAttributes &aCookie, PRInt64 aServerTime, PRInt64 aCurrentTime);
    1:     void                          RemoveAllFromMemory();
30480:     void                          RemoveExpiredCookies(PRInt64 aCurrentTime);
14075:     PRBool                        FindCookie(const nsAFlatCString &aHost, const nsAFlatCString &aName, const nsAFlatCString &aPath, nsListIter &aIter, PRInt64 aCurrentTime);
30480:     void                          FindOldestCookie(nsEnumerationData &aData);
 1128:     PRUint32                      CountCookiesFromHostInternal(const nsACString &aHost, nsEnumerationData &aData);
    1:     void                          NotifyRejected(nsIURI *aHostURI);
30480:     void                          NotifyChanged(nsICookie2 *aCookie, const PRUnichar *aData);
    1: 
    1:   protected:
33960:     // cached members.
    1:     nsCOMPtr<nsIObserverService>     mObserverService;
    1:     nsCOMPtr<nsICookiePermission>    mPermissionService;
 8702:     nsCOMPtr<nsIEffectiveTLDService> mTLDService;
    1: 
33960:     // we have two separate DB states: one for normal browsing and one for
33960:     // private browsing, switching between them as appropriate. this state
33960:     // encapsulates both the in-memory table and the on-disk DB.
33960:     // note that the private states' dbConn should always be null - we never
33960:     // want to be dealing with the on-disk DB when in private browsing.
33960:     DBState                      *mDBState;
33960:     DBState                       mDefaultDBState;
33960:     DBState                       mPrivateDBState;
    1: 
    1:     // cached prefs
 2626:     PRUint8                       mCookiesPermissions;   // BEHAVIOR_{ACCEPT, REJECTFOREIGN, REJECT}
    1:     PRUint16                      mMaxNumberOfCookies;
    1:     PRUint16                      mMaxCookiesPerHost;
    1: 
    1:     // private static member, used to cache a ptr to nsCookieService,
    1:     // so we can make nsCookieService a singleton xpcom object.
    1:     static nsCookieService        *gCookieService;
    1: 
    1:     // this callback needs access to member functions
30480:     friend PLDHashOperator removeExpiredCallback(nsCookieEntry *aEntry, void *aArg);
    1: };
    1: 
    1: #endif // nsCookieService_h__
