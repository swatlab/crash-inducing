10026: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
10026: /* ***** BEGIN LICENSE BLOCK *****
10026:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
10026:  *
10026:  * The contents of this file are subject to the Mozilla Public License Version
10026:  * 1.1 (the "License"); you may not use this file except in compliance with
10026:  * the License. You may obtain a copy of the License at
10026:  * http://www.mozilla.org/MPL/
10026:  *
10026:  * Software distributed under the License is distributed on an "AS IS" basis,
10026:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
10026:  * for the specific language governing rights and limitations under the
10026:  * License.
10026:  *
10026:  * The Original Code is MathML DOM code.
10026:  *
10026:  * The Initial Developer of the Original Code is
10026:  * mozilla.org.
10026:  * Portions created by the Initial Developer are Copyright (C) 2007
10026:  * the Initial Developer. All Rights Reserved.
10026:  *
10026:  * Contributor(s):
10026:  *    Vlad Sukhoy <vladimir.sukhoy@gmail.com> (original developer)
10026:  *    Daniel Kraft <d@domob.eu> (nsMathMLElement patch, attachment 262925)
42299:  *    Frederic Wang <fred.wang@free.fr>
10026:  *
10026:  * Alternatively, the contents of this file may be used under the terms of
10026:  * either the GNU General Public License Version 2 or later (the "GPL"), or
10026:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
10026:  * in which case the provisions of the GPL or the LGPL are applicable instead
10026:  * of those above. If you wish to allow use of your version of this file only
10026:  * under the terms of either the GPL or the LGPL, and not to allow others to
10026:  * use your version of this file under the terms of the MPL, indicate your
10026:  * decision by deleting the provisions above and replace them with the notice
10026:  * and other provisions required by the GPL or the LGPL. If you do not delete
10026:  * the provisions above, a recipient may use your version of this file under
10026:  * the terms of any one of the MPL, the GPL or the LGPL.
10026:  *
10026:  * ***** END LICENSE BLOCK ***** */
10026: 
10026: #include "nsMathMLElement.h"
10026: #include "nsDOMClassInfoID.h" // for eDOMClassInfo_MathElement_id.
10026: #include "nsGkAtoms.h"
10026: #include "nsCRT.h"
10026: #include "nsRuleData.h"
10026: #include "nsCSSValue.h"
10026: #include "nsMappedAttributes.h"
10026: #include "nsStyleConsts.h"
10026: #include "nsIDocument.h"
68780: #include "nsEventStates.h"
10026: #include "nsIPresShell.h"
10026: #include "nsPresContext.h"
10026: #include "nsDOMClassInfoID.h"
14228: #include "mozAutoDocUpdate.h"
10026: 
10026: //----------------------------------------------------------------------
10026: // nsISupports methods:
10026: 
48124: DOMCI_NODE_DATA(MathMLElement, nsMathMLElement)
40490: 
21291: NS_INTERFACE_TABLE_HEAD(nsMathMLElement)
21291:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsMathMLElement)
21291:     NS_INTERFACE_TABLE_ENTRY(nsMathMLElement, nsIDOMNode)
21291:     NS_INTERFACE_TABLE_ENTRY(nsMathMLElement, nsIDOMElement)
21291:   NS_OFFSET_AND_INTERFACE_TABLE_END
21291:   NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MathMLElement)
21291: NS_ELEMENT_INTERFACE_MAP_END
10026: 
10026: NS_IMPL_ADDREF_INHERITED(nsMathMLElement, nsMathMLElementBase)
10026: NS_IMPL_RELEASE_INHERITED(nsMathMLElement, nsMathMLElementBase)
10026: 
10026: nsresult
10026: nsMathMLElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
10026:                             nsIContent* aBindingParent,
10026:                             PRBool aCompileEventHandlers)
10026: {
33777:   static const char kMathMLStyleSheetURI[] = "resource://gre-resources/mathml.css";
10026: 
10026:   nsresult rv = nsMathMLElementBase::BindToTree(aDocument, aParent,
10026:                                                 aBindingParent,
10026:                                                 aCompileEventHandlers);
10026:   NS_ENSURE_SUCCESS(rv, rv);
10026: 
10026:   if (aDocument && !aDocument->GetMathMLEnabled()) {
10026:     // Enable MathML and setup the style sheet during binding, not element
10026:     // construction, because we could move a MathML element from the document
10026:     // that created it to another document.
10026:     aDocument->SetMathMLEnabled();
10026:     aDocument->EnsureCatalogStyleSheet(kMathMLStyleSheetURI);
10026: 
36917:     // Rebuild style data for the presshell, because style system
10026:     // optimizations may have taken place assuming MathML was disabled.
10026:     // (See nsRuleNode::CheckSpecifiedProperties.)
46225:     nsCOMPtr<nsIPresShell> shell = aDocument->GetShell();
36917:     if (shell) {
22339:       shell->GetPresContext()->PostRebuildAllStyleDataEvent(nsChangeHint(0));
10026:     }
10026:   }
10026: 
10026:   return rv;
10026: }
10026: 
10026: PRBool
10026: nsMathMLElement::ParseAttribute(PRInt32 aNamespaceID,
10026:                                 nsIAtom* aAttribute,
10026:                                 const nsAString& aValue,
10026:                                 nsAttrValue& aResult)
10026: {
10026:   if (aNamespaceID == kNameSpaceID_None) {
10026:     if (aAttribute == nsGkAtoms::color ||
10026:         aAttribute == nsGkAtoms::mathcolor_ ||
10026:         aAttribute == nsGkAtoms::background ||
10026:         aAttribute == nsGkAtoms::mathbackground_) {
47856:       return aResult.ParseColor(aValue);
10026:     }
10026:   }
10026: 
10026:   return nsMathMLElementBase::ParseAttribute(aNamespaceID, aAttribute,
10026:                                              aValue, aResult);
10026: }
10026: 
10026: static nsGenericElement::MappedAttributeEntry sTokenStyles[] = {
10026:   { &nsGkAtoms::mathsize_ },
10026:   { &nsGkAtoms::fontsize_ },
10026:   { &nsGkAtoms::color },
10026:   { &nsGkAtoms::fontfamily_ },
10026:   { nsnull }
10026: };
10026: 
10026: static nsGenericElement::MappedAttributeEntry sEnvironmentStyles[] = {
10026:   { &nsGkAtoms::scriptlevel_ },
10026:   { &nsGkAtoms::scriptminsize_ },
10026:   { &nsGkAtoms::scriptsizemultiplier_ },
10026:   { &nsGkAtoms::background },
10026:   { nsnull }
10026: };
10026: 
42299: static nsGenericElement::MappedAttributeEntry sCommonPresStyles[] = {
42299:   { &nsGkAtoms::mathcolor_ },
42299:   { &nsGkAtoms::mathbackground_ },
42299:   { nsnull }
42299: };
42299: 
10026: PRBool
10026: nsMathMLElement::IsAttributeMapped(const nsIAtom* aAttribute) const
10026: {
10026:   static const MappedAttributeEntry* const tokenMap[] = {
42299:     sTokenStyles,
42299:     sCommonPresStyles
10026:   };
10026:   static const MappedAttributeEntry* const mstyleMap[] = {
10026:     sTokenStyles,
42299:     sEnvironmentStyles,
42299:     sCommonPresStyles
42299:   };
42299:   static const MappedAttributeEntry* const commonPresMap[] = {
42299:     sCommonPresStyles
10026:   };
10026:   
10026:   // We don't support mglyph (yet).
10026:   nsIAtom* tag = Tag();
10026:   if (tag == nsGkAtoms::ms_ || tag == nsGkAtoms::mi_ ||
10026:       tag == nsGkAtoms::mn_ || tag == nsGkAtoms::mo_ ||
42299:       tag == nsGkAtoms::mtext_ || tag == nsGkAtoms::mspace_)
10026:     return FindAttributeDependence(aAttribute, tokenMap,
10026:                                    NS_ARRAY_LENGTH(tokenMap));
70469:   if (tag == nsGkAtoms::mstyle_)
10026:     return FindAttributeDependence(aAttribute, mstyleMap,
10026:                                    NS_ARRAY_LENGTH(mstyleMap));
42299: 
42299:   if (tag == nsGkAtoms::maction_ ||
42299:       tag == nsGkAtoms::maligngroup_ ||
42299:       tag == nsGkAtoms::malignmark_ ||
70469:       tag == nsGkAtoms::math ||
42299:       tag == nsGkAtoms::menclose_ ||
42299:       tag == nsGkAtoms::merror_ ||
42299:       tag == nsGkAtoms::mfenced_ ||
42299:       tag == nsGkAtoms::mfrac_ ||
42299:       tag == nsGkAtoms::mover_ ||
42299:       tag == nsGkAtoms::mpadded_ ||
42299:       tag == nsGkAtoms::mphantom_ ||
42299:       tag == nsGkAtoms::mprescripts_ ||
42299:       tag == nsGkAtoms::mroot_ ||
42299:       tag == nsGkAtoms::mrow_ ||
42299:       tag == nsGkAtoms::msqrt_ ||
42299:       tag == nsGkAtoms::msub_ ||
42299:       tag == nsGkAtoms::msubsup_ ||
42299:       tag == nsGkAtoms::msup_ ||
42299:       tag == nsGkAtoms::mtable_ ||
42299:       tag == nsGkAtoms::mtd_ ||
42299:       tag == nsGkAtoms::mtr_ ||
42299:       tag == nsGkAtoms::munder_ ||
42299:       tag == nsGkAtoms::munderover_ ||
42299:       tag == nsGkAtoms::none) {
42299:     return FindAttributeDependence(aAttribute, commonPresMap,
42299:                                    NS_ARRAY_LENGTH(commonPresMap));
42299:   }
42299: 
10026:   return PR_FALSE;
10026: }
10026: 
10026: nsMapRuleToAttributesFunc
10026: nsMathMLElement::GetAttributeMappingFunction() const
10026: {
10026:   // It doesn't really matter what our tag is here, because only attributes
10026:   // that satisfy IsAttributeMapped will be stored in the mapped attributes
10026:   // list and available to the mapping function
10026:   return &MapMathMLAttributesInto;
10026: }
10026: 
10026: // ================
10026: // Utilities for parsing and retrieving numeric values
10026: 
10026: /*
10026: The REC says:
10026:   An explicit plus sign ('+') is not allowed as part of a numeric value
10026:   except when it is specifically listed in the syntax (as a quoted '+'
10026:   or "+"),
10026: 
10026:   Units allowed
10026:   ID  Description
10026:   em  ems (font-relative unit traditionally used for horizontal lengths)
10026:   ex  exs (font-relative unit traditionally used for vertical lengths)
10026:   px  pixels, or pixel size of a "typical computer display"
10026:   in  inches (1 inch = 2.54 centimeters)
10026:   cm  centimeters
10026:   mm  millimeters
10026:   pt  points (1 point = 1/72 inch)
10026:   pc  picas (1 pica = 12 points)
10026:   %   percentage of default value
10026: 
10026: Implementation here:
10026:   The numeric value is valid only if it is of the form [-] nnn.nnn
10026:   [h/v-unit]
10026: */
10026: 
10026: /* static */ PRBool
10026: nsMathMLElement::ParseNumericValue(const nsString& aString,
10026:                                    nsCSSValue&     aCSSValue,
11299:                                    PRUint32        aFlags)
10026: {
10026:   nsAutoString str(aString);
10026:   str.CompressWhitespace(); // aString is const in this code...
10026: 
10026:   PRInt32 stringLength = str.Length();
10026:   if (!stringLength)
10026:     return PR_FALSE;
10026: 
10026:   nsAutoString number, unit;
10026: 
10026:   // see if the negative sign is there
10026:   PRInt32 i = 0;
10026:   PRUnichar c = str[0];
10026:   if (c == '-') {
10026:     number.Append(c);
10026:     i++;
10026: 
10026:     // skip any space after the negative sign
10026:     if (i < stringLength && nsCRT::IsAsciiSpace(str[i]))
10026:       i++;
10026:   }
10026: 
10026:   // Gather up characters that make up the number
10026:   PRBool gotDot = PR_FALSE;
10026:   for ( ; i < stringLength; i++) {
10026:     c = str[i];
10026:     if (gotDot && c == '.')
10026:       return PR_FALSE;  // two dots encountered
10026:     else if (c == '.')
10026:       gotDot = PR_TRUE;
10026:     else if (!nsCRT::IsAsciiDigit(c)) {
10026:       str.Right(unit, stringLength - i);
10026:       // some authors leave blanks before the unit, but that shouldn't
10026:       // be allowed, so don't CompressWhitespace on 'unit'.
10026:       break;
10026:     }
10026:     number.Append(c);
10026:   }
10026: 
10026:   // Convert number to floating point
10026:   PRInt32 errorCode;
10026:   float floatValue = number.ToFloat(&errorCode);
10026:   if (NS_FAILED(errorCode))
10026:     return PR_FALSE;
11299:   if (floatValue < 0 && !(aFlags & PARSE_ALLOW_NEGATIVE))
11299:     return PR_FALSE;
10026: 
10026:   nsCSSUnit cssUnit;
10026:   if (unit.IsEmpty()) {
11299:     if (aFlags & PARSE_ALLOW_UNITLESS) {
11299:       // no explicit unit, this is a number that will act as a multiplier
11299:       cssUnit = eCSSUnit_Number;
11299:     } else {
11299:       // We are supposed to have a unit, but there isn't one.
10026:       // If the value is 0 we can just call it "pixels" otherwise
10026:       // this is illegal.
10026:       if (floatValue != 0.0)
10026:         return PR_FALSE;
10026:       cssUnit = eCSSUnit_Pixel;
10026:     }
10026:   }
10026:   else if (unit.EqualsLiteral("%")) {
10026:     aCSSValue.SetPercentValue(floatValue / 100.0f);
10026:     return PR_TRUE;
10026:   }
10026:   else if (unit.EqualsLiteral("em")) cssUnit = eCSSUnit_EM;
10026:   else if (unit.EqualsLiteral("ex")) cssUnit = eCSSUnit_XHeight;
10026:   else if (unit.EqualsLiteral("px")) cssUnit = eCSSUnit_Pixel;
10026:   else if (unit.EqualsLiteral("in")) cssUnit = eCSSUnit_Inch;
10026:   else if (unit.EqualsLiteral("cm")) cssUnit = eCSSUnit_Centimeter;
10026:   else if (unit.EqualsLiteral("mm")) cssUnit = eCSSUnit_Millimeter;
10026:   else if (unit.EqualsLiteral("pt")) cssUnit = eCSSUnit_Point;
10026:   else if (unit.EqualsLiteral("pc")) cssUnit = eCSSUnit_Pica;
10026:   else // unexpected unit
10026:     return PR_FALSE;
10026: 
10026:   aCSSValue.SetFloatValue(floatValue, cssUnit);
10026:   return PR_TRUE;
10026: }
10026: 
10026: void
10026: nsMathMLElement::MapMathMLAttributesInto(const nsMappedAttributes* aAttributes,
10026:                                          nsRuleData* aData)
10026: {
10026:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Font)) {
10026:     const nsAttrValue* value =
10026:       aAttributes->GetAttr(nsGkAtoms::scriptsizemultiplier_);
63742:     nsCSSValue* scriptSizeMultiplier =
63742:       aData->ValueForScriptSizeMultiplier();
10026:     if (value && value->Type() == nsAttrValue::eString &&
63742:         scriptSizeMultiplier->GetUnit() == eCSSUnit_Null) {
10026:       nsAutoString str(value->GetStringValue());
10026:       str.CompressWhitespace();
10026:       // MathML numbers can't have leading '+'
10026:       if (str.Length() > 0 && str.CharAt(0) != '+') {
10026:         PRInt32 errorCode;
10026:         float floatValue = str.ToFloat(&errorCode);
10026:         // Negative scriptsizemultipliers are not parsed
10026:         if (NS_SUCCEEDED(errorCode) && floatValue >= 0.0f) {
63742:           scriptSizeMultiplier->SetFloatValue(floatValue, eCSSUnit_Number);
10026:         }
10026:       }
10026:     }
10026: 
10026:     value = aAttributes->GetAttr(nsGkAtoms::scriptminsize_);
63742:     nsCSSValue* scriptMinSize = aData->ValueForScriptMinSize();
10026:     if (value && value->Type() == nsAttrValue::eString &&
63742:         scriptMinSize->GetUnit() == eCSSUnit_Null) {
63742:       ParseNumericValue(value->GetStringValue(), *scriptMinSize, 0);
10026:     }
10026: 
10026:     value = aAttributes->GetAttr(nsGkAtoms::scriptlevel_);
63742:     nsCSSValue* scriptLevel = aData->ValueForScriptLevel();
10026:     if (value && value->Type() == nsAttrValue::eString &&
63742:         scriptLevel->GetUnit() == eCSSUnit_Null) {
10026:       nsAutoString str(value->GetStringValue());
10026:       str.CompressWhitespace();
10026:       if (str.Length() > 0) {
10026:         PRInt32 errorCode;
10026:         PRInt32 intValue = str.ToInteger(&errorCode);
10026:         if (NS_SUCCEEDED(errorCode)) {
10026:           // This is kind of cheesy ... if the scriptlevel has a sign,
10026:           // then it's a relative value and we store the nsCSSValue as an
10026:           // Integer to indicate that. Otherwise we store it as a Number
10026:           // to indicate that the scriptlevel is absolute.
10026:           PRUnichar ch = str.CharAt(0);
10026:           if (ch == '+' || ch == '-') {
63742:             scriptLevel->SetIntValue(intValue, eCSSUnit_Integer);
10026:           } else {
63742:             scriptLevel->SetFloatValue(intValue, eCSSUnit_Number);
10026:           }
10026:         }
10026:       }
10026:     }
10026: 
10026:     PRBool parseSizeKeywords = PR_TRUE;
10026:     value = aAttributes->GetAttr(nsGkAtoms::mathsize_);
10026:     if (!value) {
10026:       parseSizeKeywords = PR_FALSE;
10026:       value = aAttributes->GetAttr(nsGkAtoms::fontsize_);
10026:     }
63742:     nsCSSValue* fontSize = aData->ValueForFontSize();
10026:     if (value && value->Type() == nsAttrValue::eString &&
63742:         fontSize->GetUnit() == eCSSUnit_Null) {
10026:       nsAutoString str(value->GetStringValue());
63742:       if (!ParseNumericValue(str, *fontSize, 0) &&
10026:           parseSizeKeywords) {
10026:         static const char sizes[3][7] = { "small", "normal", "big" };
10026:         static const PRInt32 values[NS_ARRAY_LENGTH(sizes)] = {
10026:           NS_STYLE_FONT_SIZE_SMALL, NS_STYLE_FONT_SIZE_MEDIUM,
10026:           NS_STYLE_FONT_SIZE_LARGE
10026:         };
10026:         str.CompressWhitespace();
29635:         for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(sizes); ++i) {
10026:           if (str.EqualsASCII(sizes[i])) {
63742:             fontSize->SetIntValue(values[i], eCSSUnit_Enumerated);
10026:             break;
10026:           }
10026:         }
10026:       }
10026:     }
10026: 
10026:     value = aAttributes->GetAttr(nsGkAtoms::fontfamily_);
63742:     nsCSSValue* fontFamily = aData->ValueForFontFamily();
10026:     if (value && value->Type() == nsAttrValue::eString &&
63742:         fontFamily->GetUnit() == eCSSUnit_Null) {
63742:       fontFamily->SetStringValue(value->GetStringValue(), eCSSUnit_Families);
10026:     }
10026:   }
10026: 
10026:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)) {
10026:     const nsAttrValue* value =
10026:       aAttributes->GetAttr(nsGkAtoms::mathbackground_);
10026:     if (!value) {
10026:       value = aAttributes->GetAttr(nsGkAtoms::background);
10026:     }
63742:     nsCSSValue* backgroundColor = aData->ValueForBackgroundColor();
63742:     if (value && backgroundColor->GetUnit() == eCSSUnit_Null) {
10026:       nscolor color;
10026:       if (value->GetColorValue(color)) {
63742:         backgroundColor->SetColorValue(color);
10026:       }
10026:     }
10026:   }
10026: 
10026:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Color)) {
10026:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::mathcolor_);
10026:     if (!value) {
10026:       value = aAttributes->GetAttr(nsGkAtoms::color);
10026:     }
10026:     nscolor color;
63742:     nsCSSValue* colorValue = aData->ValueForColor();
10026:     if (value && value->GetColorValue(color) &&
63742:         colorValue->GetUnit() == eCSSUnit_Null) {
63742:       colorValue->SetColorValue(color);
10026:     }
10026:   }
10026: }
10026: 
10026: NS_IMPL_ELEMENT_CLONE(nsMathMLElement)
10026: 
56168: nsEventStates
10026: nsMathMLElement::IntrinsicState() const
10026: {
10026:   return nsMathMLElementBase::IntrinsicState() |
56168:     (mIncrementScriptLevel ? NS_EVENT_STATE_INCREMENT_SCRIPT_LEVEL : nsEventStates());
10026: }
10026: 
10026: PRBool
10026: nsMathMLElement::IsNodeOfType(PRUint32 aFlags) const
10026: {
41646:   return !(aFlags & ~eCONTENT);
10026: }
10026: 
10026: void
10026: nsMathMLElement::SetIncrementScriptLevel(PRBool aIncrementScriptLevel,
10026:                                          PRBool aNotify)
10026: {
10026:   if (aIncrementScriptLevel == mIncrementScriptLevel)
10026:     return;
10026:   mIncrementScriptLevel = aIncrementScriptLevel;
10026: 
10026:   NS_ASSERTION(aNotify, "We always notify!");
10026: 
10026:   nsIDocument* doc = GetCurrentDoc();
10026:   if (!doc)
10026:     return;
10026: 
10026:   mozAutoDocUpdate upd(doc, UPDATE_CONTENT_STATE, PR_TRUE);
64120:   doc->ContentStateChanged(this, NS_EVENT_STATE_INCREMENT_SCRIPT_LEVEL);
10026: }
