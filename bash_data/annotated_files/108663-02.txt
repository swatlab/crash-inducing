     1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JavaScript Debugging support - Script support
     1:  */
     1: 
     1: #include "jsd.h"
 59931: #include "jsfriendapi.h"
     1: 
     1: /* Comment this out to disable (NT specific) dumping as we go */
     1: /*
     1: ** #ifdef DEBUG      
     1: ** #define JSD_DUMP 1
     1: ** #endif            
     1: */
     1: 
     1: #define NOT_SET_YET -1
     1: 
     1: /***************************************************************************/
     1: 
     1: #ifdef DEBUG
     1: void JSD_ASSERT_VALID_SCRIPT(JSDScript* jsdscript)
     1: {
     1:     JS_ASSERT(jsdscript);
     1:     JS_ASSERT(jsdscript->script);
     1: }
     1: void JSD_ASSERT_VALID_EXEC_HOOK(JSDExecHook* jsdhook)
     1: {
     1:     JS_ASSERT(jsdhook);
     1:     JS_ASSERT(jsdhook->hook);
     1: }
     1: #endif
     1: 
     1: #ifdef LIVEWIRE
     1: static JSBool
     1: HasFileExtention(const char* name, const char* ext)
     1: {
     1:     int i;
     1:     int len = strlen(ext);
     1:     const char* p = strrchr(name,'.');
     1:     if( !p )
     1:         return JS_FALSE;
     1:     p++;
     1:     for(i = 0; i < len; i++ )
     1:     {
     1:         JS_ASSERT(islower(ext[i]));
     1:         if( 0 == p[i] || tolower(p[i]) != ext[i] )
     1:             return JS_FALSE;
     1:     }
     1:     if( 0 != p[i] )
     1:         return JS_FALSE;
     1:     return JS_TRUE;
     1: }    
     1: #endif /* LIVEWIRE */
     1: 
     1: static JSDScript*
     1: _newJSDScript(JSDContext*  jsdc,
     1:               JSContext    *cx,
 84198:               JSScript     *script)
     1: {
     1:     JSDScript*  jsdscript;
 91237:     unsigned     lineno;
     1:     const char* raw_filename;
     1: 
     1:     JS_ASSERT(JSD_SCRIPTS_LOCKED(jsdc));
     1: 
     1:     /* these are inlined javascript: urls and we can't handle them now */
 91237:     lineno = (unsigned) JS_GetScriptBaseLineNumber(cx, script);
     1:     if( lineno == 0 )
     1:         return NULL;
     1: 
     1:     jsdscript = (JSDScript*) calloc(1, sizeof(JSDScript));
     1:     if( ! jsdscript )
     1:         return NULL;
     1: 
     1:     raw_filename = JS_GetScriptFilename(cx,script);
     1: 
     1:     JS_HashTableAdd(jsdc->scriptsTable, (void *)script, (void *)jsdscript);
     1:     JS_APPEND_LINK(&jsdscript->links, &jsdc->scripts);
     1:     jsdscript->jsdc         = jsdc;
     1:     jsdscript->script       = script;  
     1:     jsdscript->lineBase     = lineno;
 91237:     jsdscript->lineExtent   = (unsigned)NOT_SET_YET;
     1:     jsdscript->data         = NULL;
     1: #ifndef LIVEWIRE
     1:     jsdscript->url          = (char*) jsd_BuildNormalizedURL(raw_filename);
     1: #else
     1:     jsdscript->app = LWDBG_GetCurrentApp();    
     1:     if( jsdscript->app && raw_filename )
     1:     {
     1:         jsdscript->url = jsdlw_BuildAppRelativeFilename(jsdscript->app, raw_filename);
     1:         if( function )
     1:         {
 57814:             JSString* funid = JS_GetFunctionId(function);
 57814:             char* funbytes;
 57814:             const char* funnanme;
 57814:             if( fuinid )
 57814:             {
 57814:                 funbytes = JS_EncodeString(cx, funid);
 57814:                 funname = funbytes ? funbytes : "";
 57814:             }
 57814:             else
 57814:             {
 57814:                 funbytes = NULL;
 57814:                 funname = "anonymous";
 57814:             }
     1:             jsdscript->lwscript = 
 57814:                 LWDBG_GetScriptOfFunction(jsdscript->app,funname);
 57814:             JS_Free(cx, funbytes);
     1:     
     1:             /* also, make sure this file is added to filelist if is .js file */
     1:             if( HasFileExtention(raw_filename,"js") || 
     1:                 HasFileExtention(raw_filename,"sjs") )
     1:             {
     1:                 jsdlw_PreLoadSource(jsdc, jsdscript->app, raw_filename, JS_FALSE);
     1:             }
     1:         }
     1:         else
     1:         {
     1:             jsdscript->lwscript = LWDBG_GetCurrentTopLevelScript();
     1:         }
     1:     }
     1: #endif
     1: 
     1:     JS_INIT_CLIST(&jsdscript->hooks);
     1:     
     1:     return jsdscript;
     1: }           
     1: 
     1: static void 
     1: _destroyJSDScript(JSDContext*  jsdc,
     1:                   JSDScript*   jsdscript)
     1: {
     1:     JS_ASSERT(JSD_SCRIPTS_LOCKED(jsdc));
     1: 
     1:     /* destroy all hooks */
     1:     jsd_ClearAllExecutionHooksForScript(jsdc, jsdscript);
     1: 
     1:     JS_REMOVE_LINK(&jsdscript->links);
     1:     if(jsdscript->url)
     1:         free(jsdscript->url);
     1: 
     1:     if (jsdscript->profileData)
     1:         free(jsdscript->profileData);
     1:     
     1:     free(jsdscript);
     1: }
     1: 
     1: /***************************************************************************/
     1: 
     1: #ifdef JSD_DUMP
     1: #ifndef XP_WIN
     1: void
     1: OutputDebugString (char *buf)
     1: {
     1:     fprintf (stderr, "%s", buf);
     1: }
     1: #endif
     1: 
     1: static void
     1: _dumpJSDScript(JSDContext* jsdc, JSDScript* jsdscript, const char* leadingtext)
     1: {
     1:     const char* name;
 58976:     JSString* fun;
 91237:     unsigned base;
 91237:     unsigned extent;
     1:     char Buf[256];
 58976:     size_t n;
     1: 
     1:     name   = jsd_GetScriptFilename(jsdc, jsdscript);
 61691:     fun    = jsd_GetScriptFunctionId(jsdc, jsdscript);
     1:     base   = jsd_GetScriptBaseLineNumber(jsdc, jsdscript);
     1:     extent = jsd_GetScriptLineExtent(jsdc, jsdscript);
 58976:     n = size_t(snprintf(Buf, sizeof(Buf), "%sscript=%08X, %s, ",
 58976:                         leadingtext, (unsigned) jsdscript->script,
 58976:                         name ? name : "no URL"));
 58976:     if (n + 1 < sizeof(Buf)) {
 58976:         if (fun) {
 58976:             n += size_t(snprintf(Buf + n, sizeof(Buf) - n, "%s", "no fun"));
 58976:         } else {
 59889:             n += JS_PutEscapedFlatString(Buf + n, sizeof(Buf) - n,
 59889:                                          JS_ASSERT_STRING_IS_FLAT(fun), 0);
 58976:             Buf[sizeof(Buf) - 1] = '\0';
 58976:         }
 58976:         if (n + 1 < sizeof(Buf))
 58976:             snprintf(Buf + n, sizeof(Buf) - n, ", %d-%d\n", base, base + extent - 1);
 58976:     }
     1:     OutputDebugString( Buf );
     1: }
     1: 
     1: static void
     1: _dumpJSDScriptList( JSDContext* jsdc )
     1: {
     1:     JSDScript* iterp = NULL;
     1:     JSDScript* jsdscript = NULL;
     1:     
     1:     OutputDebugString( "*** JSDScriptDump\n" );
     1:     while( NULL != (jsdscript = jsd_IterateScripts(jsdc, &iterp)) )
     1:         _dumpJSDScript( jsdc, jsdscript, "  script: " );
     1: }
     1: #endif /* JSD_DUMP */
     1: 
     1: /***************************************************************************/
 18907: static JSHashNumber
     1: jsd_hash_script(const void *key)
     1: {
 58603:     return ((JSHashNumber)(ptrdiff_t) key) >> 2; /* help lame MSVC1.5 on Win16 */
     1: }
     1: 
 18907: static void *
     1: jsd_alloc_script_table(void *priv, size_t size)
     1: {
     1:     return malloc(size);
     1: }
     1: 
 18907: static void
 29324: jsd_free_script_table(void *priv, void *item, size_t size)
     1: {
     1:     free(item);
     1: }
     1: 
 18907: static JSHashEntry *
     1: jsd_alloc_script_entry(void *priv, const void *item)
     1: {
     1:     return (JSHashEntry*) malloc(sizeof(JSHashEntry));
     1: }
     1: 
 18907: static void
 91237: jsd_free_script_entry(void *priv, JSHashEntry *he, unsigned flag)
     1: {
     1:     if (flag == HT_FREE_ENTRY)
     1:     {
     1:         _destroyJSDScript((JSDContext*) priv, (JSDScript*) he->value);
     1:         free(he);
     1:     }
     1: }
     1: 
     1: static JSHashAllocOps script_alloc_ops = {
     1:     jsd_alloc_script_table, jsd_free_script_table,
     1:     jsd_alloc_script_entry, jsd_free_script_entry
     1: };
     1: 
     1: #ifndef JSD_SCRIPT_HASH_SIZE
     1: #define JSD_SCRIPT_HASH_SIZE 1024
     1: #endif
     1: 
     1: JSBool
     1: jsd_InitScriptManager(JSDContext* jsdc)
     1: {
     1:     JS_INIT_CLIST(&jsdc->scripts);
     1:     jsdc->scriptsTable = JS_NewHashTable(JSD_SCRIPT_HASH_SIZE, jsd_hash_script,
     1:                                          JS_CompareValues, JS_CompareValues,
     1:                                          &script_alloc_ops, (void*) jsdc);
 58603:     return !!jsdc->scriptsTable;
     1: }
     1: 
     1: void
     1: jsd_DestroyScriptManager(JSDContext* jsdc)
     1: {
     1:     JSD_LOCK_SCRIPTS(jsdc);
     1:     if (jsdc->scriptsTable)
     1:         JS_HashTableDestroy(jsdc->scriptsTable);
     1:     JSD_UNLOCK_SCRIPTS(jsdc);
     1: }
     1: 
     1: JSDScript*
     1: jsd_FindJSDScript( JSDContext*  jsdc,
     1:                    JSScript     *script )
     1: {
     1:     JS_ASSERT(JSD_SCRIPTS_LOCKED(jsdc));
     1:     return (JSDScript*) JS_HashTableLookup(jsdc->scriptsTable, (void *)script);
     1: }
     1: 
 26156: JSDScript *
 26156: jsd_FindOrCreateJSDScript(JSDContext    *jsdc,
 26156:                           JSContext     *cx,
 26156:                           JSScript      *script,
 26156:                           JSStackFrame  *fp)
 26156: {
 26156:     JSDScript *jsdscript;
 26156:     JS_ASSERT(JSD_SCRIPTS_LOCKED(jsdc));
 26156: 
 26156:     jsdscript = jsd_FindJSDScript(jsdc, script);
 26156:     if (jsdscript)
 26156:         return jsdscript;
 26156: 
 26879:     /* Fallback for unknown scripts: create a new script. */
 26156:     if (!fp)
 26156:         JS_FrameIterator(cx, &fp);
 26156:     if (fp)
 84198:         jsdscript = _newJSDScript(jsdc, cx, script);
 26156: 
 26156:     return jsdscript;
 26156: }
 26156: 
     1: JSDProfileData*
     1: jsd_GetScriptProfileData(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (!script->profileData)
     1:         script->profileData = (JSDProfileData*)calloc(1, sizeof(JSDProfileData));
     1: 
     1:     return script->profileData;
     1: }
     1: 
 84755: uint32_t
     1: jsd_GetScriptFlags(JSDContext *jsdc, JSDScript *script)
     1: {
     1:     return script->flags;
     1: }
     1: 
     1: void
 84755: jsd_SetScriptFlags(JSDContext *jsdc, JSDScript *script, uint32_t flags)
     1: {
     1:     script->flags = flags;
     1: }
     1: 
 91237: unsigned
     1: jsd_GetScriptCallCount(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (script->profileData)
     1:         return script->profileData->callCount;
     1: 
     1:     return 0;
     1: }
     1: 
 91237: unsigned
     1: jsd_GetScriptMaxRecurseDepth(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (script->profileData)
     1:         return script->profileData->maxRecurseDepth;
     1: 
     1:     return 0;
     1: }
     1: 
 90955: double
     1: jsd_GetScriptMinExecutionTime(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (script->profileData)
     1:         return script->profileData->minExecutionTime;
     1: 
     1:     return 0.0;
     1: }
     1: 
 90955: double
     1: jsd_GetScriptMaxExecutionTime(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (script->profileData)
     1:         return script->profileData->maxExecutionTime;
     1: 
     1:     return 0.0;
     1: }
     1: 
 90955: double
     1: jsd_GetScriptTotalExecutionTime(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (script->profileData)
     1:         return script->profileData->totalExecutionTime;
     1: 
     1:     return 0.0;
     1: }
     1: 
 90955: double
     1: jsd_GetScriptMinOwnExecutionTime(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (script->profileData)
     1:         return script->profileData->minOwnExecutionTime;
     1: 
     1:     return 0.0;
     1: }
     1: 
 90955: double
     1: jsd_GetScriptMaxOwnExecutionTime(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (script->profileData)
     1:         return script->profileData->maxOwnExecutionTime;
     1: 
     1:     return 0.0;
     1: }
     1: 
 90955: double
     1: jsd_GetScriptTotalOwnExecutionTime(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (script->profileData)
     1:         return script->profileData->totalOwnExecutionTime;
     1: 
     1:     return 0.0;
     1: }
     1: 
     1: void
     1: jsd_ClearScriptProfileData(JSDContext* jsdc, JSDScript *script)
     1: {
     1:     if (script->profileData)
     1:     {
     1:         free(script->profileData);
     1:         script->profileData = NULL;
     1:     }
     1: }    
     1: 
     1: JSScript *
     1: jsd_GetJSScript (JSDContext *jsdc, JSDScript *script)
     1: {
     1:     return script->script;
     1: }
     1: 
     1: JSFunction *
     1: jsd_GetJSFunction (JSDContext *jsdc, JSDScript *script)
     1: {
 84198:     return JS_GetScriptFunction(jsdc->dumbContext, script->script);
     1: }
     1: 
     1: JSDScript*
     1: jsd_IterateScripts(JSDContext* jsdc, JSDScript **iterp)
     1: {
     1:     JSDScript *jsdscript = *iterp;
     1:     
     1:     JS_ASSERT(JSD_SCRIPTS_LOCKED(jsdc));
     1: 
     1:     if( !jsdscript )
     1:         jsdscript = (JSDScript *)jsdc->scripts.next;
     1:     if( jsdscript == (JSDScript *)&jsdc->scripts )
     1:         return NULL;
     1:     *iterp = (JSDScript*) jsdscript->links.next;
     1:     return jsdscript;
     1: }
     1: 
     1: void *
     1: jsd_SetScriptPrivate(JSDScript *jsdscript, void *data)
     1: {
     1:     void *rval = jsdscript->data;
     1:     jsdscript->data = data;
     1:     return rval;
     1: }
     1: 
     1: void *
     1: jsd_GetScriptPrivate(JSDScript *jsdscript)
     1: {
     1:     return jsdscript->data;
     1: }
     1: 
     1: JSBool
     1: jsd_IsActiveScript(JSDContext* jsdc, JSDScript *jsdscript)
     1: {
     1:     JSDScript *current;
     1: 
     1:     JS_ASSERT(JSD_SCRIPTS_LOCKED(jsdc));
     1: 
     1:     for( current = (JSDScript *)jsdc->scripts.next;
     1:          current != (JSDScript *)&jsdc->scripts;
     1:          current = (JSDScript *)current->links.next )
     1:     {
     1:         if(jsdscript == current)
     1:             return JS_TRUE;
     1:     }
     1:     return JS_FALSE;
     1: }        
     1: 
     1: const char*
     1: jsd_GetScriptFilename(JSDContext* jsdc, JSDScript *jsdscript)
     1: {
     1:     return jsdscript->url;
     1: }
     1: 
 58976: JSString*
 61691: jsd_GetScriptFunctionId(JSDContext* jsdc, JSDScript *jsdscript)
     1: {
 58976:     JSString* str;
 84198:     JSFunction *fun = jsd_GetJSFunction(jsdc, jsdscript);
 58976: 
 84198:     if( ! fun )
     1:         return NULL;
 84198:     str = JS_GetFunctionId(fun);
 59931: 
 59931:     /* For compatibility we return "anonymous", not an empty string here. */
 59931:     return str ? str : JS_GetAnonymousString(jsdc->jsrt);
     1: }
     1: 
 91237: unsigned
     1: jsd_GetScriptBaseLineNumber(JSDContext* jsdc, JSDScript *jsdscript)
     1: {
     1:     return jsdscript->lineBase;
     1: }
     1: 
 91237: unsigned
     1: jsd_GetScriptLineExtent(JSDContext* jsdc, JSDScript *jsdscript)
     1: {
     1:     if( NOT_SET_YET == (int)jsdscript->lineExtent )
     1:         jsdscript->lineExtent = JS_GetScriptLineExtent(jsdc->dumbContext, jsdscript->script);
     1:     return jsdscript->lineExtent;
     1: }
     1: 
 86976: uintptr_t
 91237: jsd_GetClosestPC(JSDContext* jsdc, JSDScript* jsdscript, unsigned line)
     1: {
 86976:     uintptr_t pc;
 62384:     JSCrossCompartmentCall *call;
 62384: 
 77537:     if( !jsdscript )
 77537:         return 0;
 56201: #ifdef LIVEWIRE
 77537:     if( jsdscript->lwscript )
 56201:     {
 91237:         unsigned newline;
 56201:         jsdlw_RawToProcessedLineNumber(jsdc, jsdscript, line, &newline);
 56201:         if( line != newline )
 56201:             line = newline;
 56201:     }
 56201: #endif
 56201: 
 62384:     call = JS_EnterCrossCompartmentCallScript(jsdc->dumbContext, jsdscript->script);
 62384:     if(!call)
 62384:         return 0;
 86976:     pc = (uintptr_t) JS_LineNumberToPC(jsdc->dumbContext, jsdscript->script, line );
 62384:     JS_LeaveCrossCompartmentCall(call);
 62384:     return pc;
     1: }
     1: 
 91237: unsigned
 86976: jsd_GetClosestLine(JSDContext* jsdc, JSDScript* jsdscript, uintptr_t pc)
     1: {
 62384:     JSCrossCompartmentCall *call;
 91237:     unsigned first = jsdscript->lineBase;
 91237:     unsigned last = first + jsd_GetScriptLineExtent(jsdc, jsdscript) - 1;
 91237:     unsigned line = 0;
 62384: 
 62384:     call = JS_EnterCrossCompartmentCallScript(jsdc->dumbContext, jsdscript->script);
 62384:     if(!call)
 62384:         return 0;
 62384:     if (pc)
 62384:         line = JS_PCToLineNumber(jsdc->dumbContext, jsdscript->script, (jsbytecode*)pc);
 62384:     JS_LeaveCrossCompartmentCall(call);
     1: 
     1:     if( line < first )
     1:         return first;
     1:     if( line > last )
     1:         return last;
     1: 
     1: #ifdef LIVEWIRE
     1:     if( jsdscript && jsdscript->lwscript )
     1:     {
 91237:         unsigned newline;
     1:         jsdlw_ProcessedToRawLineNumber(jsdc, jsdscript, line, &newline);
     1:         line = newline;
     1:     }
     1: #endif
     1: 
     1:     return line;    
     1: }
     1: 
     1: JSBool
 71318: jsd_GetLinePCs(JSDContext* jsdc, JSDScript* jsdscript,
 91237:                unsigned startLine, unsigned maxLines,
 91237:                unsigned* count, unsigned** retLines, uintptr_t** retPCs)
 71318: {
 71318:     JSCrossCompartmentCall *call;
 91237:     unsigned first = jsdscript->lineBase;
 91237:     unsigned last = first + jsd_GetScriptLineExtent(jsdc, jsdscript) - 1;
 71318:     JSBool ok;
 91237:     unsigned *lines;
 71318:     jsbytecode **pcs;
 91237:     unsigned i;
 71318: 
 71318:     if (last < startLine)
 71318:         return JS_TRUE;
 71318: 
 71318:     call = JS_EnterCrossCompartmentCallScript(jsdc->dumbContext, jsdscript->script);
 71318:     if (!call)
 71318:         return JS_FALSE;
 71318: 
 71318:     ok = JS_GetLinePCs(jsdc->dumbContext, jsdscript->script,
 71318:                        startLine, maxLines,
 71318:                        count, retLines, &pcs);
 71318: 
 71318:     if (ok) {
 71318:         if (retPCs) {
 71318:             for (i = 0; i < *count; ++i) {
 71318:                 (*retPCs)[i] = (*pcs)[i];
 71318:             }
 71318:         }
 71318: 
 71318:         JS_free(jsdc->dumbContext, pcs);
 71318:     }
 71318: 
 71318:     JS_LeaveCrossCompartmentCall(call);
 71318:     return ok;
 71318: }
 71318: 
 71318: JSBool
     1: jsd_SetScriptHook(JSDContext* jsdc, JSD_ScriptHookProc hook, void* callerdata)
     1: {
     1:     JSD_LOCK();
     1:     jsdc->scriptHook = hook;
     1:     jsdc->scriptHookData = callerdata;
     1:     JSD_UNLOCK();
     1:     return JS_TRUE;
     1: }
     1: 
     1: JSBool
     1: jsd_GetScriptHook(JSDContext* jsdc, JSD_ScriptHookProc* hook, void** callerdata)
     1: {
     1:     JSD_LOCK();
     1:     if( hook )
     1:         *hook = jsdc->scriptHook;
     1:     if( callerdata )
     1:         *callerdata = jsdc->scriptHookData;
     1:     JSD_UNLOCK();
     1:     return JS_TRUE;
     1: }    
     1: 
 59882: JSBool
 59882: jsd_EnableSingleStepInterrupts(JSDContext* jsdc, JSDScript* jsdscript, JSBool enable)
 59882: {
 62384:     JSCrossCompartmentCall *call;
 59882:     JSBool rv;
 62384:     call = JS_EnterCrossCompartmentCallScript(jsdc->dumbContext, jsdscript->script);
 62384:     if(!call)
 62384:         return JS_FALSE;
 59882:     JSD_LOCK();
 59882:     rv = JS_SetSingleStepMode(jsdc->dumbContext, jsdscript->script, enable);
 59882:     JSD_UNLOCK();
 62384:     JS_LeaveCrossCompartmentCall(call);
 59882:     return rv;
 59882: }
 59882: 
 59882: 
     1: /***************************************************************************/
     1: 
 18907: void
     1: jsd_NewScriptHookProc( 
     1:                 JSContext   *cx,
     1:                 const char  *filename,      /* URL this script loads from */
 91237:                 unsigned       lineno,         /* line where this script starts */
     1:                 JSScript    *script,
     1:                 JSFunction  *fun,                
     1:                 void*       callerdata )
     1: {
     1:     JSDScript* jsdscript = NULL;
     1:     JSDContext* jsdc = (JSDContext*) callerdata;
     1:     JSD_ScriptHookProc      hook;
     1:     void*                   hookData;
     1:     
     1:     JSD_ASSERT_VALID_CONTEXT(jsdc);
     1: 
     1:     if( JSD_IS_DANGEROUS_THREAD(jsdc) )
     1:         return;
     1:     
     1:     JSD_LOCK_SCRIPTS(jsdc);
 84198:     jsdscript = _newJSDScript(jsdc, cx, script);
     1:     JSD_UNLOCK_SCRIPTS(jsdc);
     1:     if( ! jsdscript )
     1:         return;
     1: 
     1: #ifdef JSD_DUMP
     1:     JSD_LOCK_SCRIPTS(jsdc);
     1:     _dumpJSDScript(jsdc, jsdscript, "***NEW Script: ");
     1:     _dumpJSDScriptList( jsdc );
     1:     JSD_UNLOCK_SCRIPTS(jsdc);
     1: #endif /* JSD_DUMP */
     1: 
     1:     /* local in case jsdc->scriptHook gets cleared on another thread */
     1:     JSD_LOCK();
     1:     hook = jsdc->scriptHook;
108663:     if( hook )
108663:         jsdscript->flags = jsdscript->flags | JSD_SCRIPT_CALL_DESTROY_HOOK_BIT;
     1:     hookData = jsdc->scriptHookData;
     1:     JSD_UNLOCK();
     1: 
     1:     if( hook )
     1:         hook(jsdc, jsdscript, JS_TRUE, hookData);
     1: }
     1: 
 18907: void
     1: jsd_DestroyScriptHookProc( 
 97529:                 JSFreeOp    *fop,
     1:                 JSScript    *script,
     1:                 void*       callerdata )
     1: {
     1:     JSDScript* jsdscript = NULL;
     1:     JSDContext* jsdc = (JSDContext*) callerdata;
     1:     JSD_ScriptHookProc      hook;
     1:     void*                   hookData;
     1:     
     1:     JSD_ASSERT_VALID_CONTEXT(jsdc);
     1: 
     1:     if( JSD_IS_DANGEROUS_THREAD(jsdc) )
     1:         return;
     1:     
     1:     JSD_LOCK_SCRIPTS(jsdc);
     1:     jsdscript = jsd_FindJSDScript(jsdc, script);
     1:     JSD_UNLOCK_SCRIPTS(jsdc);
     1: 
     1:     if( ! jsdscript )
     1:         return;
     1: 
     1: #ifdef JSD_DUMP
     1:     JSD_LOCK_SCRIPTS(jsdc);
     1:     _dumpJSDScript(jsdc, jsdscript, "***DESTROY Script: ");
     1:     JSD_UNLOCK_SCRIPTS(jsdc);
     1: #endif /* JSD_DUMP */
     1: 
     1:     /* local in case hook gets cleared on another thread */
     1:     JSD_LOCK();
108663:     hook = (jsdscript->flags & JSD_SCRIPT_CALL_DESTROY_HOOK_BIT) ? jsdc->scriptHook : NULL;
     1:     hookData = jsdc->scriptHookData;
     1:     JSD_UNLOCK();
     1: 
     1:     if( hook )
     1:         hook(jsdc, jsdscript, JS_FALSE, hookData);
     1: 
     1:     JSD_LOCK_SCRIPTS(jsdc);
     1:     JS_HashTableRemove(jsdc->scriptsTable, (void *)script);
     1:     JSD_UNLOCK_SCRIPTS(jsdc);
     1: 
     1: #ifdef JSD_DUMP
     1:     JSD_LOCK_SCRIPTS(jsdc);
     1:     _dumpJSDScriptList(jsdc);
     1:     JSD_UNLOCK_SCRIPTS(jsdc);
     1: #endif /* JSD_DUMP */
     1: }                
     1: 
     1: 
     1: /***************************************************************************/
     1: 
     1: static JSDExecHook*
 86976: _findHook(JSDContext* jsdc, JSDScript* jsdscript, uintptr_t pc)
     1: {
     1:     JSDExecHook* jsdhook;
     1:     JSCList* list = &jsdscript->hooks;
     1: 
     1:     for( jsdhook = (JSDExecHook*)list->next;
     1:          jsdhook != (JSDExecHook*)list;
     1:          jsdhook = (JSDExecHook*)jsdhook->links.next )
     1:     {
     1:         if (jsdhook->pc == pc)
     1:             return jsdhook;
     1:     }
     1:     return NULL;
     1: }
     1: 
     1: static JSBool
     1: _isActiveHook(JSDContext* jsdc, JSScript *script, JSDExecHook* jsdhook)
     1: {
     1:     JSDExecHook* current;
     1:     JSCList* list;
     1:     JSDScript* jsdscript;
     1: 
     1:     JSD_LOCK_SCRIPTS(jsdc);
     1:     jsdscript = jsd_FindJSDScript(jsdc, script);
     1:     if( ! jsdscript)
     1:     {
     1:         JSD_UNLOCK_SCRIPTS(jsdc);
     1:         return JS_FALSE;
     1:     }
     1: 
     1:     list = &jsdscript->hooks;
     1: 
     1:     for( current = (JSDExecHook*)list->next;
     1:          current != (JSDExecHook*)list;
     1:          current = (JSDExecHook*)current->links.next )
     1:     {
     1:         if(current == jsdhook)
     1:         {
     1:             JSD_UNLOCK_SCRIPTS(jsdc);
     1:             return JS_TRUE;
     1:         }
     1:     }
     1:     JSD_UNLOCK_SCRIPTS(jsdc);
     1:     return JS_FALSE;
     1: }
     1: 
     1: 
 18907: JSTrapStatus
     1: jsd_TrapHandler(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
 41863:                 jsval closure)
     1: {
 41863:     JSDExecHook* jsdhook = (JSDExecHook*) JSVAL_TO_PRIVATE(closure);
     1:     JSD_ExecutionHookProc hook;
     1:     void* hookData;
     1:     JSDContext*  jsdc;
     1:     JSDScript* jsdscript;
     1: 
     1:     JSD_LOCK();
     1: 
     1:     if( NULL == (jsdc = jsd_JSDContextForJSContext(cx)) ||
     1:         ! _isActiveHook(jsdc, script, jsdhook) )
     1:     {
     1:         JSD_UNLOCK();
     1:         return JSTRAP_CONTINUE;
     1:     }
     1: 
     1:     JSD_ASSERT_VALID_EXEC_HOOK(jsdhook);
 86976:     JS_ASSERT(!jsdhook->pc || jsdhook->pc == (uintptr_t)pc);
     1:     JS_ASSERT(jsdhook->jsdscript->script == script);
     1:     JS_ASSERT(jsdhook->jsdscript->jsdc == jsdc);
     1: 
     1:     hook = jsdhook->hook;
     1:     hookData = jsdhook->callerdata;
     1:     jsdscript = jsdhook->jsdscript;
     1: 
     1:     /* do not use jsdhook-> after this point */
     1:     JSD_UNLOCK();
     1: 
     1:     if( ! jsdc || ! jsdc->inited )
     1:         return JSTRAP_CONTINUE;
     1: 
     1:     if( JSD_IS_DANGEROUS_THREAD(jsdc) )
     1:         return JSTRAP_CONTINUE;
     1: 
     1: #ifdef LIVEWIRE
 86976:     if( ! jsdlw_UserCodeAtPC(jsdc, jsdscript, (uintptr_t)pc) )
     1:         return JSTRAP_CONTINUE;
     1: #endif
     1: 
     1:     return jsd_CallExecutionHook(jsdc, cx, JSD_HOOK_BREAKPOINT,
     1:                                  hook, hookData, rval);
     1: }
     1: 
     1: 
     1: 
     1: JSBool
     1: jsd_SetExecutionHook(JSDContext*           jsdc, 
     1:                      JSDScript*            jsdscript,
 86976:                      uintptr_t             pc,
     1:                      JSD_ExecutionHookProc hook,
     1:                      void*                 callerdata)
     1: {
     1:     JSDExecHook* jsdhook;
 62384:     JSBool rv;
 62384:     JSCrossCompartmentCall *call;
     1: 
     1:     JSD_LOCK();
     1:     if( ! hook )
     1:     {
     1:         jsd_ClearExecutionHook(jsdc, jsdscript, pc);
     1:         JSD_UNLOCK();
     1:         return JS_TRUE;
     1:     }
     1: 
     1:     jsdhook = _findHook(jsdc, jsdscript, pc);
     1:     if( jsdhook )
     1:     {
     1:         jsdhook->hook       = hook;
     1:         jsdhook->callerdata = callerdata;
 11475:         JSD_UNLOCK();
     1:         return JS_TRUE;
     1:     }
     1:     /* else... */
     1: 
     1:     jsdhook = (JSDExecHook*)calloc(1, sizeof(JSDExecHook));
 11475:     if( ! jsdhook ) {
 11475:         JSD_UNLOCK();
     1:         return JS_FALSE;
 11475:     }
     1:     jsdhook->jsdscript  = jsdscript;
     1:     jsdhook->pc         = pc;
     1:     jsdhook->hook       = hook;
     1:     jsdhook->callerdata = callerdata;
     1: 
 62384:     call = JS_EnterCrossCompartmentCallScript(jsdc->dumbContext, jsdscript->script);
 62384:     if(!call) {
 62384:         free(jsdhook);
 62384:         JSD_UNLOCK();
 62384:         return JS_FALSE;
 62384:     }
 62384: 
 62384:     rv = JS_SetTrap(jsdc->dumbContext, jsdscript->script, 
     1:                     (jsbytecode*)pc, jsd_TrapHandler,
 62384:                     PRIVATE_TO_JSVAL(jsdhook));
 62384: 
 62384:     JS_LeaveCrossCompartmentCall(call);
 62384: 
 62384:     if ( ! rv ) {
     1:         free(jsdhook);
 11475:         JSD_UNLOCK();
     1:         return JS_FALSE;
     1:     }
     1: 
     1:     JS_APPEND_LINK(&jsdhook->links, &jsdscript->hooks);
     1:     JSD_UNLOCK();
     1: 
     1:     return JS_TRUE;
     1: }
     1: 
     1: JSBool
     1: jsd_ClearExecutionHook(JSDContext*           jsdc, 
     1:                        JSDScript*            jsdscript,
 86976:                        uintptr_t             pc)
     1: {
 62384:     JSCrossCompartmentCall *call;
     1:     JSDExecHook* jsdhook;
     1: 
     1:     JSD_LOCK();
     1: 
     1:     jsdhook = _findHook(jsdc, jsdscript, pc);
     1:     if( ! jsdhook )
     1:     {
     1:         JSD_UNLOCK();
     1:         return JS_FALSE;
     1:     }
     1: 
 62384:     call = JS_EnterCrossCompartmentCallScript(jsdc->dumbContext, jsdscript->script);
 62384:     if(!call) {
 62384:         JSD_UNLOCK();
 62384:         return JS_FALSE;
 62384:     }
 62384: 
     1:     JS_ClearTrap(jsdc->dumbContext, jsdscript->script, 
     1:                  (jsbytecode*)pc, NULL, NULL );
     1: 
 62384:     JS_LeaveCrossCompartmentCall(call);
 62384: 
     1:     JS_REMOVE_LINK(&jsdhook->links);
     1:     free(jsdhook);
     1: 
     1:     JSD_UNLOCK();
     1:     return JS_TRUE;
     1: }
     1: 
     1: JSBool
     1: jsd_ClearAllExecutionHooksForScript(JSDContext* jsdc, JSDScript* jsdscript)
     1: {
     1:     JSDExecHook* jsdhook;
     1:     JSCList* list = &jsdscript->hooks;
     1: 
     1:     JSD_LOCK();
     1: 
     1:     while( (JSDExecHook*)list != (jsdhook = (JSDExecHook*)list->next) )
     1:     {
     1:         JS_REMOVE_LINK(&jsdhook->links);
     1:         free(jsdhook);
     1:     }
     1: 
 62384:     /* No cross-compartment call here because we may be in the middle of GC */
     1:     JS_ClearScriptTraps(jsdc->dumbContext, jsdscript->script);
     1:     JSD_UNLOCK();
     1: 
     1:     return JS_TRUE;
     1: }
     1: 
     1: JSBool
     1: jsd_ClearAllExecutionHooks(JSDContext* jsdc)
     1: {
     1:     JSDScript* jsdscript;
     1:     JSDScript* iterp = NULL;
     1: 
     1:     JSD_LOCK();
     1:     while( NULL != (jsdscript = jsd_IterateScripts(jsdc, &iterp)) )
     1:         jsd_ClearAllExecutionHooksForScript(jsdc, jsdscript);
     1:     JSD_UNLOCK();
     1:     return JS_TRUE;
     1: }
     1: 
     1: void
     1: jsd_ScriptCreated(JSDContext* jsdc,
     1:                   JSContext   *cx,
     1:                   const char  *filename,    /* URL this script loads from */
 91237:                   unsigned       lineno,       /* line where this script starts */
     1:                   JSScript    *script,
     1:                   JSFunction  *fun)
     1: {
     1:     jsd_NewScriptHookProc(cx, filename, lineno, script, fun, jsdc);
     1: }
     1: 
     1: void
     1: jsd_ScriptDestroyed(JSDContext* jsdc,
 97529:                     JSFreeOp    *fop,
     1:                     JSScript    *script)
     1: {
 97529:     jsd_DestroyScriptHookProc(fop, script, jsdc);
     1: }
