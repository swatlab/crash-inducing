   1: /* -*- Mode: objc; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License
   1:  * Version 1.1 (the "License"); you may not use this file except in
   1:  * compliance with the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is 
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Josh Aas <josh@mozilla.com>
   1:  *   Mark Mentovai <mark@moxienet.com>
   1:  *   HÃ¥kan Waara <hwaara@gmail.com>
   1:  *   Stuart Morgan <stuart.morgan@alumni.case.edu>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or 
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include <unistd.h>
   1:  
   1: #include "nsChildView.h"
3574: #include "nsCocoaWindow.h"
   1: 
   1: #include "nsCOMPtr.h"
   1: #include "nsToolkit.h"
   1: #include "prmem.h"
   1: #include "nsCRT.h"
   1: #include "nsplugindefs.h"
4842: #include "nsThreadUtils.h"
4842: #include "nsIPrefService.h"
4842: #include "nsIPrefBranch.h"
   1: 
   1: #include "nsIFontMetrics.h"
   1: #include "nsIDeviceContext.h"
   1: #include "nsIRegion.h"
   1: #include "nsIRollupListener.h"
   1: #include "nsIEventSink.h"
   1: #include "nsIScrollableView.h"
   1: #include "nsIViewManager.h"
   1: #include "nsIInterfaceRequestor.h"
   1: #include "nsIServiceManager.h"
3545: #include "nsILocalFile.h"
3545: #include "nsILocalFileMac.h"
   1: #include "nsGfxCIID.h"
   1: 
   1: #include "nsDragService.h"
   1: #include "nsCursorManager.h"
   1: #include "nsWindowMap.h"
   1: #include "nsCocoaUtils.h"
   1: 
   1: #include "gfxContext.h"
   1: #include "gfxQuartzSurface.h"
   1: 
   1: #undef DEBUG_IME
   1: #undef DEBUG_UPDATE
   1: #undef INVALIDATE_DEBUGGING  // flash areas as they are invalidated
   1: 
5676: #ifdef MOZ_LOGGING
5676: #define FORCE_PR_LOG
5676: #endif
5676: #include "prlog.h"
5676: 
3545: #ifdef PR_LOGGING
3545: PRLogModuleInfo* sCocoaLog = nsnull;
3545: #endif
3545: 
5762: // npapi.h defines NPEventType_AdjustCursorEvent but we don't want to include npapi.h here.
5762: // We need to send this in the "what" field for certain native plugin events. WebKit does
5762: // this as well.
5762: #define adjustCursorEvent 33
5762: 
   1: extern "C" {
   1:   CG_EXTERN void CGContextResetCTM(CGContextRef);
   1:   CG_EXTERN void CGContextSetCTM(CGContextRef, CGAffineTransform);
   1:   CG_EXTERN void CGContextResetClip(CGContextRef);
   1: }
   1: 
3592: extern nsISupportsArray *gDraggedTransferables;
3592: 
 539: PRBool nsTSMManager::sIsIMEEnabled = PR_TRUE;
 539: PRBool nsTSMManager::sIsRomanKeyboardsOnly = PR_FALSE;
4726: PRBool nsTSMManager::sIgnoreCommit = PR_FALSE;
 539: NSView<mozView>* nsTSMManager::sComposingView = nsnull;
4726: TSMDocumentID nsTSMManager::sDocumentID = nsnull;
4726: NSString* nsTSMManager::sComposingString = nsnull;
 539: 
   1: static NS_DEFINE_CID(kRegionCID, NS_REGION_CID);
   1: static NSView* sLastViewEntered = nil;
   1: #ifdef INVALIDATE_DEBUGGING
   1: static void blinkRect(Rect* r);
   1: static void blinkRgn(RgnHandle rgn);
   1: #endif
   1: 
   1: nsIRollupListener * gRollupListener = nsnull;
   1: nsIWidget         * gRollupWidget   = nsnull;
   1: 
   1: 
   1: @interface ChildView(Private)
   1: 
   1: // sets up our view, attaching it to its owning gecko view
   1: - (id)initWithFrame:(NSRect)inFrame geckoChild:(nsChildView*)inChild eventSink:(nsIEventSink*)inSink;
   1: 
   1: // sends gecko an ime composition event
   1: - (nsRect) sendCompositionEvent:(PRInt32)aEventType;
   1: 
   1: // sends gecko an ime text event
   1: - (void) sendTextEvent:(PRUnichar*) aBuffer 
   1:                        attributedString:(NSAttributedString*) aString
   1:                        selectedRange:(NSRange)selRange
   1:                        markedRange:(NSRange)markRange
   1:                        doCommit:(BOOL)doCommit;
   1: 
2315: // do generic gecko event setup with a generic cocoa event. accepts nil inEvent.
2315: - (void) convertGenericCocoaEvent:(NSEvent*)inEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent;
2315: 
2315: // set up a gecko mouse event based on a cocoa mouse event
2315: - (void) convertCocoaMouseEvent:(NSEvent*)aMouseEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent;
2315: 
2315: // set up a gecko key event based on a cocoa key event
2315: - (void) convertCocoaKeyEvent:(NSEvent*)aKeyEvent toGeckoEvent:(nsKeyEvent*)outGeckoEvent;
   1: 
   1: - (NSMenu*)contextMenu;
   1: - (TopLevelWindowData*)ensureWindowData;
   1: 
   1: - (void)setIsPluginView:(BOOL)aIsPlugin;
 130: - (BOOL)isPluginView;
   1: 
   1: - (BOOL)childViewHasPlugin;
   1: 
   1: - (BOOL)isRectObscuredBySubview:(NSRect)inRect;
   1: 
   1: - (void)processPendingRedraws;
   1: 
3574: - (BOOL)maybeRerouteMouseEventToRollupWidget:(NSEvent *)anEvent;
3574: 
3574: + (BOOL)mouseEventIsOverRollupWidget:(NSEvent *)anEvent;
3574: 
3574: - (void)maybeInitContextMenuTracking;
3574: 
4842: - (nsChildView *)getGeckoChild;
4842: 
   1: #if USE_CLICK_HOLD_CONTEXTMENU
   1:  // called on a timer two seconds after a mouse down to see if we should display
   1:  // a context menu (click-hold)
   1: - (void)clickHoldCallback:(id)inEvent;
   1: #endif
   1: 
   1: #ifdef ACCESSIBILITY
   1: - (id<mozAccessible>)accessible;
   1: #endif
   1: 
   1: @end
   1: 
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: /* Convenience routines to go from a gecko rect to cocoa NSRects and back
   1:  *
   1:  * Gecko rects (nsRect) contain an origin (x,y) in a coordinate
   1:  * system with (0,0) in the top-left of the screen. Cocoa rects
   1:  * (NSRect) contain an origin (x,y) in a coordinate system with
   1:  * (0,0) in the bottom-left of the screen. Both nsRect and NSRect
   1:  * contain width/height info, with no difference in their use.
   1:  * If a Cocoa rect is from a flipped view, there is no need to
   1:  * convert coordinate systems.
   1:  */
   1: 
   1: 
   1: static inline void
   1: GeckoRectToNSRect(const nsRect & inGeckoRect, NSRect & outCocoaRect)
   1: {
   1:   outCocoaRect.origin.x = inGeckoRect.x;
   1:   outCocoaRect.origin.y = inGeckoRect.y;
   1:   outCocoaRect.size.width = inGeckoRect.width;
   1:   outCocoaRect.size.height = inGeckoRect.height;
   1: }
   1: 
   1: static inline void
   1: NSRectToGeckoRect(const NSRect & inCocoaRect, nsRect & outGeckoRect)
   1: {
3233:   outGeckoRect.x = static_cast<nscoord>(inCocoaRect.origin.x);
3233:   outGeckoRect.y = static_cast<nscoord>(inCocoaRect.origin.y);
3233:   outGeckoRect.width = static_cast<nscoord>(inCocoaRect.size.width);
3233:   outGeckoRect.height = static_cast<nscoord>(inCocoaRect.size.height);
   1: }
   1: 
   1: 
   1: static inline void 
   1: ConvertGeckoRectToMacRect(const nsRect& aRect, Rect& outMacRect)
   1: {
   1:   outMacRect.left = aRect.x;
   1:   outMacRect.top = aRect.y;
   1:   outMacRect.right = aRect.x + aRect.width;
   1:   outMacRect.bottom = aRect.y + aRect.height;
   1: }
   1: 
   1: // Flips a screen coordinate from a point in the cocoa coordinate system (bottom-left rect) to a point
   1: // that is a "flipped" cocoa coordinate system (starts in the top-left).
   1: static inline void
   1: FlipCocoaScreenCoordinate (NSPoint &inPoint)
   1: {  
4864:   inPoint.y = FlippedScreenY(inPoint.y);
   1: }
   1:   
   1: 
   1: static PRUint32
   1: UnderlineAttributeToTextRangeType(PRUint32 aUnderlineStyle, NSRange selRange)
   1: {
   1: #ifdef DEBUG_IME
   1:   NSLog(@"****in underlineAttributeToTextRangeType = %d", aUnderlineStyle);
   1: #endif
   1: 
   1:   // For more info on the underline attribute, please see: 
   1:   // http://developer.apple.com/techpubs/macosx/Cocoa/TasksAndConcepts/ProgrammingTopics/AttributedStrings/Tasks/AccessingAttrs.html
   1:   // We are not clear where the define for value 2 is right now. 
   1:   // To see this value in japanese ime, type 'aaaaaaaaa' and hit space to make the
   1:   // ime send you some part of text in 1 (NSSingleUnderlineStyle) and some part in 2. 
   1:   // ftang will ask apple for more details
   1:   //
   1:   // it probably means show 1-pixel thickness underline vs 2-pixel thickness
   1:   
   1:   PRUint32 attr;
   1:   if (selRange.length == 0) {
   1:     switch (aUnderlineStyle) {
   1:       case 1:
   1:         attr = NS_TEXTRANGE_RAWINPUT;
   1:         break;
   1:       case 2:
   1:       default:
   1:         attr = NS_TEXTRANGE_SELECTEDRAWTEXT;
   1:         break;
   1:     }
   1:   }
   1:   else {
   1:     switch (aUnderlineStyle) {
   1:       case 1:
   1:         attr = NS_TEXTRANGE_CONVERTEDTEXT;
   1:         break;
   1:       case 2:
   1:       default:
   1:         attr = NS_TEXTRANGE_SELECTEDCONVERTEDTEXT;
   1:         break;
   1:     }
   1:   }
   1:   return attr;
   1: }
   1: 
   1: 
   1: static PRUint32
   1: CountRanges(NSAttributedString *aString)
   1: {
   1:   // Iterate through aString for the NSUnderlineStyleAttributeName and count the 
   1:   // different segments adjusting limitRange as we go.
   1:   PRUint32 count = 0;
   1:   NSRange effectiveRange;
   1:   NSRange limitRange = NSMakeRange(0, [aString length]);
   1:   while (limitRange.length > 0) {
   1:     [aString attribute:NSUnderlineStyleAttributeName 
   1:                atIndex:limitRange.location 
   1:  longestEffectiveRange:&effectiveRange
   1:                inRange:limitRange];
   1:     limitRange = NSMakeRange(NSMaxRange(effectiveRange), 
   1:                              NSMaxRange(limitRange) - NSMaxRange(effectiveRange));
   1:     count++;
   1:   }
   1:   return count;
   1: }
   1: 
   1: 
   1: static void
   1: ConvertAttributeToGeckoRange(NSAttributedString *aString, NSRange markRange, NSRange selRange, PRUint32 inCount, nsTextRange* aRanges)
   1: {
   1:   // Convert the Cocoa range into the nsTextRange Array used in Gecko.
   1:   // Iterate through the attributed string and map the underline attribute to Gecko IME textrange attributes.
   1:   // We may need to change the code here if we change the implementation of validAttributesForMarkedText.
   1:   PRUint32 i = 0;
   1:   NSRange effectiveRange;
   1:   NSRange limitRange = NSMakeRange(0, [aString length]);
   1:   while ((limitRange.length > 0) && (i < inCount)) {
   1:     id attributeValue = [aString attribute:NSUnderlineStyleAttributeName 
   1:                               atIndex:limitRange.location 
   1:                               longestEffectiveRange:&effectiveRange
   1:                               inRange:limitRange];
   1:     aRanges[i].mStartOffset = effectiveRange.location;                         
   1:     aRanges[i].mEndOffset = NSMaxRange(effectiveRange);                         
   1:     aRanges[i].mRangeType = UnderlineAttributeToTextRangeType([attributeValue intValue], selRange); 
   1:     limitRange = NSMakeRange(NSMaxRange(effectiveRange), 
   1:                              NSMaxRange(limitRange) - NSMaxRange(effectiveRange));
   1:     i++;
   1:   }
   1:   // Get current caret position.
   1:   // Caret is indicator of insertion point, so mEndOffset = 0.
   1:   aRanges[i].mStartOffset = selRange.location + selRange.length;                         
   1:   aRanges[i].mEndOffset = 0;                         
   1:   aRanges[i].mRangeType = NS_TEXTRANGE_CARETPOSITION;
   1: }
   1: 
   1: 
   1: static void
   1: FillTextRangeInTextEvent(nsTextEvent *aTextEvent, NSAttributedString* aString, NSRange markRange, NSRange selRange)
   1: { 
   1:   // Count the number of segments in the attributed string and add one more count for sending current caret position to Gecko.
   1:   // Allocate the right size of nsTextRange and draw caret at right position.
   1:   // Convert the attributed string into an array of nsTextRange and get current caret position by calling above functions.
   1:   PRUint32 count = CountRanges(aString) + 1;
   1:   aTextEvent->rangeArray = new nsTextRange[count];
   1:   if (aTextEvent->rangeArray)
   1:   {
   1:     aTextEvent->rangeCount = count;
   1:     ConvertAttributeToGeckoRange(aString, markRange, selRange, aTextEvent->rangeCount,  aTextEvent->rangeArray);
   1:   } 
   1: }
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: nsChildView::nsChildView() : nsBaseWidget()
   1: , mView(nsnull)
   1: , mParentView(nsnull)
   1: , mParentWidget(nsnull)
   1: , mDestructorCalled(PR_FALSE)
   1: , mVisible(PR_FALSE)
   1: , mDrawing(PR_FALSE)
   1: , mAcceptFocusOnClick(PR_TRUE)
   1: , mLiveResizeInProgress(PR_FALSE)
 130: , mIsPluginView(PR_FALSE)
   1: , mPluginDrawing(PR_FALSE)
 130: , mPluginIsCG(PR_FALSE)
   1: {
3545: #ifdef PR_LOGGING
3545:   if (!sCocoaLog)
3545:     sCocoaLog = PR_NewLogModule("nsCocoaWidgets");
3545: #endif
3545: 
5676:   SetBackgroundColor(NS_RGB(255, 255, 255));
5676:   SetForegroundColor(NS_RGB(0, 0, 0));
   1: }
   1: 
   1: 
   1: nsChildView::~nsChildView()
   1: {
   1:   // notify the children that we're gone
   1:   for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
3233:     nsChildView* childView = static_cast<nsChildView*>(kid);
   1:     childView->mParentWidget = nsnull;
   1:   }
   1: 
   1:   TearDownView(); // should have already been done from Destroy
   1: }
   1: 
   1: 
   1: NS_IMPL_ISUPPORTS_INHERITED3(nsChildView, nsBaseWidget, nsIPluginWidget, nsIKBStateControl, nsIEventSink)
   1: 
   1: 
   1: // Utility method for implementing both Create(nsIWidget ...)
   1: // and Create(nsNativeWidget...)
   1: nsresult nsChildView::StandardCreate(nsIWidget *aParent,
   1:                       const nsRect &aRect,
   1:                       EVENT_CALLBACK aHandleEventFunction,
   1:                       nsIDeviceContext *aContext,
   1:                       nsIAppShell *aAppShell,
   1:                       nsIToolkit *aToolkit,
   1:                       nsWidgetInitData *aInitData,
   1:                       nsNativeWidget aNativeParent)
   1: {
   1:   mBounds = aRect;
   1: 
   1:   BaseCreate(aParent, aRect, aHandleEventFunction, 
   1:               aContext, aAppShell, aToolkit, aInitData);
   1: 
   1:   // inherit things from the parent view and create our parallel 
   1:   // NSView in the Cocoa display system
   1:   mParentView = nil;
   1:   if (aParent) {
   1:     SetBackgroundColor(aParent->GetBackgroundColor());
   1:     SetForegroundColor(aParent->GetForegroundColor());
   1: 
   1:     // inherit the top-level window. NS_NATIVE_WIDGET is always a NSView
   1:     // regardless of if we're asking a window or a view (for compatibility
   1:     // with windows).
   1:     mParentView = (NSView*)aParent->GetNativeData(NS_NATIVE_WIDGET); 
   1:     mParentWidget = aParent;   
   1:   }
   1:   else
3233:     mParentView = reinterpret_cast<NSView*>(aNativeParent);
   1:   
   1:   // create our parallel NSView and hook it up to our parent. Recall
   1:   // that NS_NATIVE_WIDGET is the NSView.
   1:   NSRect r;
   1:   GeckoRectToNSRect(mBounds, r);
   1:   mView = [CreateCocoaView(r) retain];
   1:   if (!mView) return NS_ERROR_FAILURE;
   1:   
   1: #if DEBUG
   1:   // if our parent is a popup window, we're most certainly coming from a <select> list dropdown which
   1:   // we handle in a different way than other platforms. It's ok that we don't have a parent
   1:   // view because we bailed before even creating the cocoa widgetry and as a result, we
   1:   // don't need to assert. However, if that's not the case, we definitely want to assert
   1:   // to show views aren't getting correctly parented.
   1:   if (aParent) {
   1:     nsWindowType windowType;
   1:     aParent->GetWindowType(windowType);
   1:     if (windowType != eWindowType_popup)
   1:       NS_ASSERTION(mParentView && mView, "couldn't hook up new NSView in hierarchy");
   1:   }
   1:   else {
   1:     NS_ASSERTION(mParentView && mView, "couldn't hook up new NSView in hierarchy");
   1:   }
   1: #endif
   1: 
   1:   // If this view was created in a Gecko view hierarchy, the initial state
   1:   // is hidden.  If the view is attached only to a native NSView but has
   1:   // no Gecko parent (as in embedding), the initial state is visible.
   1:   if (mParentWidget)
   1:     [mView setHidden:YES];
   1:   else
   1:     mVisible = PR_TRUE;
   1: 
   1:   // Hook it up in the NSView hierarchy.
   1:   if (mParentView) {
   1:     NSWindow* window = [mParentView window];
   1:     if (!window &&
   1:         [mParentView respondsToSelector:@selector(nativeWindow)])
   1:       window = [mParentView nativeWindow];
   1: 
   1:     [mView setNativeWindow:window];
   1: 
   1:     [mParentView addSubview:mView];
   1:   }
   1: 
   1:   // if this is a ChildView, make sure that our per-window data
   1:   // is set up
   1:   if ([mView isKindOfClass:[ChildView class]])
   1:     [(ChildView*)mView ensureWindowData];
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Creates the appropriate child view. Override to create something other than
   1: // our |ChildView| object. Autoreleases, so caller must retain.
   1: NSView*
   1: nsChildView::CreateCocoaView(NSRect inFrame)
   1: {
   1:   return [[[ChildView alloc] initWithFrame:inFrame geckoChild:this eventSink:nsnull] autorelease];
   1: }
   1: 
   1: 
   1: void nsChildView::TearDownView()
   1: {
   1:   if (!mView)
   1:     return;
   1: 
   1:   NSWindow* win = [mView window];
   1:   NSResponder* responder = [win firstResponder];
   1:   
   1:   // We're being unhooked from the view hierarchy, don't leave our view
   1:   // or a child view as the window first responder.
   1:   if (responder && [responder isKindOfClass:[NSView class]] &&
   1:       [(NSView*)responder isDescendantOf:mView]) {
   1:     [win makeFirstResponder: [mView superview]];
   1:   }
   1: 
2000:   // If mView is win's contentView, win (mView's NSWindow) "owns" mView --
2000:   // win has retained mView, and will detach it from the view hierarchy and
2000:   // release it when necessary (when win is itself destroyed (in a call to
2000:   // [win dealloc])).  So all we need to do here is call [mView release] (to
2000:   // match the call to [mView retain] in nsChildView::StandardCreate()).
2000:   // Also calling [mView removeFromSuperviewWithoutNeedingDisplay] causes
2000:   // mView to be released again and dealloced, while remaining win's
2000:   // contentView.  So if we do that here, win will (for a short while) have
2000:   // an invalid contentView (for the consequences see bmo bugs 381087 and
2000:   // 374260).
2000:   if ([mView isEqual:[win contentView]]) {
   1:     [mView release];
2000:   } else {
2000:     // Stop NSView hierarchy being changed during [ChildView drawRect:]
2000:     [mView performSelectorOnMainThread:@selector(delayedTearDown) withObject:nil waitUntilDone:false];
2000:   }
   1:   mView = nil;
   1: }
   1: 
   1: 
   1: // create a nsChildView
   1: NS_IMETHODIMP nsChildView::Create(nsIWidget *aParent,
   1:                       const nsRect &aRect,
   1:                       EVENT_CALLBACK aHandleEventFunction,
   1:                       nsIDeviceContext *aContext,
   1:                       nsIAppShell *aAppShell,
   1:                       nsIToolkit *aToolkit,
   1:                       nsWidgetInitData *aInitData)
   1: {  
   1:   return(StandardCreate(aParent, aRect, aHandleEventFunction, aContext,
   1:                         aAppShell, aToolkit, aInitData, nsnull));
   1: }
   1: 
   1: 
   1: // Creates a main nsChildView using a native widget (an NSView)
   1: NS_IMETHODIMP nsChildView::Create(nsNativeWidget aNativeParent,
   1:                       const nsRect &aRect,
   1:                       EVENT_CALLBACK aHandleEventFunction,
   1:                       nsIDeviceContext *aContext,
   1:                       nsIAppShell *aAppShell,
   1:                       nsIToolkit *aToolkit,
   1:                       nsWidgetInitData *aInitData)
   1: {
   1:   // what we're passed in |aNativeParent| is an NSView. 
   1:   return(StandardCreate(nsnull, aRect, aHandleEventFunction, aContext,
   1:                         aAppShell, aToolkit, aInitData, aNativeParent));
   1: }
   1: 
   1: 
   1: // Close this nsChildView
   1: NS_IMETHODIMP nsChildView::Destroy()
   1: {
   1:   if (mOnDestroyCalled)
   1:     return NS_OK;
   1:   mOnDestroyCalled = PR_TRUE;
   1: 
   1:   [mView widgetDestroyed];
   1: 
   1:   nsBaseWidget::OnDestroy();
   1:   nsBaseWidget::Destroy();
   1: 
   1:   ReportDestroyEvent(); // beard: this seems to cause the window to be deleted. moved all release code to destructor.
   1:   mParentWidget = nil;
   1: 
   1:   TearDownView();
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: #if 0
   1: static void PrintViewHierarchy(NSView *view)
   1: {
   1:   while (view) {
   1:     NSLog(@"  view is %x, frame %@", view, NSStringFromRect([view frame]));
   1:     view = [view superview];
   1:   }
   1: }
   1: #endif
   1: 
   1: 
   1: 
   1: // Return native data according to aDataType
   1: void* nsChildView::GetNativeData(PRUint32 aDataType)
   1: {
   1:   void* retVal = nsnull;
   1: 
   1:   switch (aDataType) 
   1:   {
6013:     case NS_NATIVE_WIDGET:
   1:     case NS_NATIVE_DISPLAY:
   1:       retVal = (void*)mView;
   1:       break;
   1: 
   1:     case NS_NATIVE_WINDOW:
   1:       retVal = [mView nativeWindow];
   1:       break;
   1: 
6013:     case NS_NATIVE_GRAPHIC:
6013:       NS_ASSERTION(0, "Requesting NS_NATIVE_GRAPHIC on a Mac OS X child view!");
6013:       retVal = nsnull;
   1:       break;
   1: 
   1:     case NS_NATIVE_OFFSETX:
   1:       retVal = 0;
   1:       break;
   1: 
   1:     case NS_NATIVE_OFFSETY:
   1:       retVal = 0;
   1:       break;
   1: 
   1:     case NS_NATIVE_PLUGIN_PORT:
 130: #ifndef NP_NO_QUICKDRAW
 130:     case NS_NATIVE_PLUGIN_PORT_QD:
   1:     {
 130:       mPluginIsCG = PR_FALSE;
 130:       mIsPluginView = PR_TRUE;
   1:       if ([mView isKindOfClass:[ChildView class]])
   1:         [(ChildView*)mView setIsPluginView:YES];
   1: 
   1:       NSWindow* window = [mView nativeWindow];
   1:       if (window) {
   1:         WindowRef topLevelWindow = (WindowRef)[window windowRef];
   1:         if (topLevelWindow) {
 130:           mPluginPort.qdPort.port = ::GetWindowPort(topLevelWindow);
   1: 
   1:           NSPoint viewOrigin = [mView convertPoint:NSZeroPoint toView:nil];
   1:           NSRect frame = [[window contentView] frame];
   1:           viewOrigin.y = frame.size.height - viewOrigin.y;
   1:           
   1:           // need to convert view's origin to window coordinates.
   1:           // then, encode as "SetOrigin" ready values.
 130:           mPluginPort.qdPort.portx = (PRInt32)-viewOrigin.x;
 130:           mPluginPort.qdPort.porty = (PRInt32)-viewOrigin.y;
 130:         }
 130:       }
 130: 
 130:       retVal = (void*)&mPluginPort;
 130:       break;
 130:     }
 130: #endif
 130: 
 130:     case NS_NATIVE_PLUGIN_PORT_CG:
 130:     {
 130:       mPluginIsCG = PR_TRUE;
 130:       mIsPluginView = PR_TRUE;
 130:       if ([mView isKindOfClass:[ChildView class]])
 130:         [(ChildView*)mView setIsPluginView:YES];
 130: 
 130:       if ([NSView focusView] == mView)
 130:         mPluginPort.cgPort.context = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
 130:       else
 130:         mPluginPort.cgPort.context = NULL;
 130: 
 130:       NSWindow* window = [mView nativeWindow];
 130:       if (window) {
 130:         WindowRef topLevelWindow = (WindowRef)[window windowRef];
 130:         mPluginPort.cgPort.window = topLevelWindow;
 130:       }
 130: 
 130:       retVal = (void*)&mPluginPort;
   1:       break;
   1:     }
   1:   }
   1: 
   1:   return retVal;
   1: }
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: // Return PR_TRUE if the whether the component is visible, PR_FALSE otherwise
   1: NS_IMETHODIMP nsChildView::IsVisible(PRBool& outState)
   1: {
   1:   if (!mVisible) {
   1:     outState = mVisible;
   1:   }
   1:   else {
   1:     // mVisible does not accurately reflect the state of a hidden tabbed view
   1:     // so verify that the view has a window as well
   1:     outState = ([mView window] != nil);
   1:     // now check native widget hierarchy visibility
   1:     if (outState && NSIsEmptyRect([mView visibleRect])) {
   1:       outState = PR_FALSE;
   1:     }
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Hide or show this component
   1: NS_IMETHODIMP nsChildView::Show(PRBool aState)
   1: {
   1:   if (aState != mVisible) {
   1:     [mView setHidden:!aState];
   1:     mVisible = aState;
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: nsIWidget*
   1: nsChildView::GetParent(void)
   1: {
   1:   return mParentWidget;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::ModalEventFilter(PRBool aRealEvent, void *aEvent,
   1:                                             PRBool *aForWindow)
   1: {
   1:   if (aForWindow)
   1:     *aForWindow = PR_FALSE;
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::Enable(PRBool aState)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::IsEnabled(PRBool *aState)
   1: {
   1:   // unimplemented
   1:   if (aState)
   1:    *aState = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::SetFocus(PRBool aRaise)
   1: {
   1:   NSWindow* window = [mView window];
   1:   if (window)
   1:     [window makeFirstResponder:mView];
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Set the colormap of the window
   1: NS_IMETHODIMP nsChildView::SetColorMap(nsColorMap *aColorMap)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::SetMenuBar(nsIMenuBar * aMenuBar)
   1: {
   1:   return NS_ERROR_FAILURE; // subviews don't have menu bars
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::ShowMenuBar(PRBool aShow)
   1: {
   1:   return NS_ERROR_FAILURE; // subviews don't have menu bars
   1: }
   1: 
   1: 
   1: nsIMenuBar* nsChildView::GetMenuBar()
   1: {
   1:   return nsnull; // subviews don't have menu bars
   1: }
   1: 
   1: 
   1: // Override to set the cursor on the mac
   1: NS_IMETHODIMP nsChildView::SetCursor(nsCursor aCursor)
   1: {
   1:   nsBaseWidget::SetCursor(aCursor);
   1:   [[nsCursorManager sharedInstance] setCursor: aCursor];
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // implement to fix "hidden virtual function" warning
   1: NS_IMETHODIMP nsChildView::SetCursor(imgIContainer* aCursor,
   1:                                       PRUint32 aHotspotX, PRUint32 aHotspotY)
   1: {
   1:   return nsBaseWidget::SetCursor(aCursor, aHotspotX, aHotspotY);
   1: }
   1: 
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: // Get this component dimension
   1: NS_IMETHODIMP nsChildView::GetBounds(nsRect &aRect)
   1: {
   1:   aRect = mBounds;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_METHOD nsChildView::SetBounds(const nsRect &aRect)
   1: {
   1:   nsresult rv = Inherited::SetBounds(aRect);
   1:   if (NS_SUCCEEDED(rv)) {
   1:     NSRect r;
   1:     GeckoRectToNSRect(aRect, r);
   1:     [mView setFrame:r];
   1:   }
   1: 
   1:   return rv;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::ConstrainPosition(PRBool aAllowSlop,
   1:                                              PRInt32 *aX, PRInt32 *aY)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Move this component, aX and aY are in the parent widget coordinate system
   1: NS_IMETHODIMP nsChildView::Move(PRInt32 aX, PRInt32 aY)
   1: {
   1:   return MoveWithRepaintOption(aX, aY, PR_TRUE);
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::MoveWithRepaintOption(PRInt32 aX, PRInt32 aY, PRBool aRepaint)
   1: {
   1:   if ((mBounds.x != aX) || (mBounds.y != aY)) {
   1:     // Invalidate the current location
   1:     if (mVisible && aRepaint)
   1:       [[mView superview] setNeedsDisplayInRect: [mView frame]];    //XXX needed?
   1:         
   1:     // Set the bounds
   1:     mBounds.x = aX;
   1:     mBounds.y = aY;
   1:    
   1:     NSRect r;
   1:     GeckoRectToNSRect(mBounds, r);
   1:     [mView setFrame:r];
   1: 
   1:     if (mVisible && aRepaint)
   1:       [mView setNeedsDisplay:YES];
   1: 
   1:     // Report the event
   1:     ReportMoveEvent();
   1:   }
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Resize this component
   1: NS_IMETHODIMP nsChildView::Resize(PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
   1: {
   1:   if ((mBounds.width != aWidth) || (mBounds.height != aHeight)) {
   1:     // Set the bounds
   1:     mBounds.width  = aWidth;
   1:     mBounds.height = aHeight;
   1: 
   1:     if (mVisible && aRepaint)
   1:       [[mView superview] setNeedsDisplayInRect: [mView frame]];    //XXX needed?
   1:     
   1:     NSRect r;
   1:     GeckoRectToNSRect(mBounds, r);
   1:     [mView setFrame:r];
   1: 
   1:     if (mVisible && aRepaint)
   1:       [mView setNeedsDisplay:YES];
   1: 
   1:     // Report the event
   1:     ReportSizeEvent();
   1:   }
   1:  
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Resize this component
   1: NS_IMETHODIMP nsChildView::Resize(PRInt32 aX, PRInt32 aY, PRInt32 aWidth, PRInt32 aHeight, PRBool aRepaint)
   1: {
   1:   MoveWithRepaintOption(aX, aY, aRepaint);
   1:   Resize(aWidth, aHeight, aRepaint);
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_METHOD nsChildView::GetPreferredSize(PRInt32& aWidth, PRInt32& aHeight)
   1: {
   1:   return NS_ERROR_FAILURE; // nobody call this anywhere in the code
   1: }
   1: 
   1: 
   1: NS_METHOD nsChildView::SetPreferredSize(PRInt32 aWidth, PRInt32 aHeight)
   1: {
   1:   return NS_ERROR_FAILURE; // nobody call this anywhere in the code
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::BeginResizingChildren(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::EndResizingChildren(void)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::GetPluginClipRect(nsRect& outClipRect, nsPoint& outOrigin, PRBool& outWidgetVisible)
   1: {
 130:   NS_ASSERTION(mIsPluginView, "GetPluginClipRect must only be called on a plugin widget");
 130:   if (!mIsPluginView) return NS_ERROR_FAILURE;
   1:   
   1:   NSWindow* window = [mView nativeWindow];
   1:   if (!window) return NS_ERROR_FAILURE;
   1:   
   1:   NSPoint viewOrigin = [mView convertPoint:NSZeroPoint toView:nil];
   1:   NSRect frame = [[window contentView] frame];
   1:   viewOrigin.y = frame.size.height - viewOrigin.y;
   1:   
   1:   // set up the clipping region for plugins.
   1:   NSRect visibleBounds = [mView visibleRect];
   1:   NSPoint clipOrigin   = [mView convertPoint:visibleBounds.origin toView:nil];
   1:   
   1:   // Convert from cocoa to QuickDraw coordinates
   1:   clipOrigin.y = frame.size.height - clipOrigin.y;
   1:   
   1:   outClipRect.x = (nscoord)clipOrigin.x;
   1:   outClipRect.y = (nscoord)clipOrigin.y;
   1:   
   1:   
   1:   PRBool isVisible;
   1:   IsVisible(isVisible);
   1:   if (isVisible && [mView window] != nil) {
   1:     outClipRect.width  = (nscoord)visibleBounds.size.width;
   1:     outClipRect.height = (nscoord)visibleBounds.size.height;
   1:     outWidgetVisible = PR_TRUE;
   1:   }
   1:   else {
   1:     outClipRect.width = 0;
   1:     outClipRect.height = 0;
   1:     outWidgetVisible = PR_FALSE;
   1:   }
   1: 
   1:   // need to convert view's origin to window coordinates.
   1:   // then, encode as "SetOrigin" ready values.
   1:   outOrigin.x = (nscoord)-viewOrigin.x;
   1:   outOrigin.y = (nscoord)-viewOrigin.y;
   1:   
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::StartDrawPlugin()
   1: {
 130:   NS_ASSERTION(mIsPluginView, "StartDrawPlugin must only be called on a plugin widget");
 130:   if (!mIsPluginView) return NS_ERROR_FAILURE;
 130: 
 130:   // nothing to do if this is a CoreGraphics plugin
 130:   if (mPluginIsCG)
 130:     return NS_OK;
   1: 
   1:   // prevent reentrant drawing
   1:   if (mPluginDrawing)
   1:     return NS_ERROR_FAILURE;
   1:   
   1:   NSWindow* window = [mView nativeWindow];
   1:   if (!window)
   1:     return NS_ERROR_FAILURE;
   1:   
   1:   // It appears that the WindowRef from which we get the plugin port undergoes the
   1:   // traditional BeginUpdate/EndUpdate cycle, which, if you recall, sets the visible
   1:   // region to the intersection of the visible region and the update region. Since
   1:   // we don't know here if we're being drawn inside a BeginUpdate/EndUpdate pair
   1:   // (which seem to occur in [NSWindow display]), and we don't want to have the burden
   1:   // of correctly doing Carbon invalidates of the plugin rect, we manually set the
   1:   // visible region to be the entire port every time.
   1:   RgnHandle pluginRegion = ::NewRgn();
   1:   if (pluginRegion) {
 130:     PRBool portChanged = (mPluginPort.qdPort.port != CGrafPtr(GetQDGlobalsThePort()));
   1:     CGrafPtr oldPort;
   1:     GDHandle oldDevice;
   1: 
   1:     if (portChanged) {
   1:       ::GetGWorld(&oldPort, &oldDevice);
 130:       ::SetGWorld(mPluginPort.qdPort.port, ::IsPortOffscreen(mPluginPort.qdPort.port) ? nsnull : ::GetMainDevice());
   1:     }
   1: 
   1:     ::SetOrigin(0, 0);
   1:     
   1:     nsRect clipRect; // this is in native window coordinates
   1:     nsPoint origin;
   1:     PRBool visible;
   1:     GetPluginClipRect(clipRect, origin, visible);
   1:     
   1:     // XXX if we're not visible, set an empty clip region?
   1:     Rect pluginRect;
   1:     ConvertGeckoRectToMacRect(clipRect, pluginRect);
   1:     
   1:     ::RectRgn(pluginRegion, &pluginRect);
 130:     ::SetPortVisibleRegion(mPluginPort.qdPort.port, pluginRegion);
 130:     ::SetPortClipRegion(mPluginPort.qdPort.port, pluginRegion);
   1:     
   1:     // now set up the origin for the plugin
   1:     ::SetOrigin(origin.x, origin.y);
   1:     
   1:     ::DisposeRgn(pluginRegion);
   1: 
   1:     if (portChanged)
   1:       ::SetGWorld(oldPort, oldDevice);
   1:   }
   1: 
   1:   mPluginDrawing = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::EndDrawPlugin()
   1: {
 130:   NS_ASSERTION(mIsPluginView, "EndDrawPlugin must only be called on a plugin widget");
 130:   if (!mIsPluginView) return NS_ERROR_FAILURE;
 130: 
   1:   mPluginDrawing = PR_FALSE;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: void nsChildView::LiveResizeStarted()
   1: {
   1:   // XXX todo. Use this to disable Java async redraw during resize
   1:   mLiveResizeInProgress = PR_TRUE;
   1: }
   1: 
   1: 
   1: void nsChildView::LiveResizeEnded()
   1: {
   1:   mLiveResizeInProgress = PR_FALSE;
   1: }
   1: 
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: #ifdef INVALIDATE_DEBUGGING
   1: 
   1: static Boolean KeyDown(const UInt8 theKey)
   1: {
   1:   KeyMap map;
   1:   GetKeys(map);
   1:   return ((*((UInt8 *)map + (theKey >> 3)) >> (theKey & 7)) & 1) != 0;
   1: }
   1: 
   1: static Boolean caps_lock()
   1: {
   1:   return KeyDown(0x39);
   1: }
   1: 
   1: static void blinkRect(Rect* r)
   1: {
   1:   StRegionFromPool oldClip;
   1:   if (oldClip != NULL)
   1:     ::GetClip(oldClip);
   1: 
   1:   ::ClipRect(r);
   1:   ::InvertRect(r);
   1:   UInt32 end = ::TickCount() + 5;
   1:   while (::TickCount() < end) ;
   1:   ::InvertRect(r);
   1: 
   1:   if (oldClip != NULL)
   1:     ::SetClip(oldClip);
   1: }
   1: 
   1: static void blinkRgn(RgnHandle rgn)
   1: {
   1:   StRegionFromPool oldClip;
   1:   if (oldClip != NULL)
   1:     ::GetClip(oldClip);
   1: 
   1:   ::SetClip(rgn);
   1:   ::InvertRgn(rgn);
   1:   UInt32 end = ::TickCount() + 5;
   1:   while (::TickCount() < end) ;
   1:   ::InvertRgn(rgn);
   1: 
   1:   if (oldClip != NULL)
   1:     ::SetClip(oldClip);
   1: }
   1: 
   1: #endif
   1: 
   1: 
   1: // Invalidate this component's visible area
   1: NS_IMETHODIMP nsChildView::Invalidate(PRBool aIsSynchronous)
   1: {
   1:   if (!mView || !mVisible)
   1:     return NS_OK;
   1: 
   1:   if (aIsSynchronous) {
   1:     [mView display];
   1:   }
   1:   else if ([NSView focusView]) {
   1:     // if a view is focussed (i.e. being drawn), then postpone the invalidate so that we
   1:     // don't lose it.
   1:     [mView setNeedsPendingDisplay];
   1:   }
   1:   else {
   1:     [mView setNeedsDisplay:YES];
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Invalidate this component's visible area
   1: NS_IMETHODIMP nsChildView::Invalidate(const nsRect &aRect, PRBool aIsSynchronous)
   1: {
   1:   if (!mView || !mVisible)
   1:     return NS_OK;
   1: 
   1:   NSRect r;
   1:   GeckoRectToNSRect(aRect, r);
   1:   
   1:   if (aIsSynchronous) {
   1:     [mView displayRect:r];
   1:   }
   1:   else if ([NSView focusView]) {
   1:     // if a view is focussed (i.e. being drawn), then postpone the invalidate so that we
   1:     // don't lose it.
   1:     [mView setNeedsPendingDisplayInRect:r];
   1:   }
   1:   else {
   1:     [mView setNeedsDisplayInRect:r];
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Validate the widget
   1: NS_IMETHODIMP nsChildView::Validate()
   1: {
   1:   [mView setNeedsDisplay:NO];
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Invalidate this component's visible area
   1: NS_IMETHODIMP nsChildView::InvalidateRegion(const nsIRegion *aRegion, PRBool aIsSynchronous)
   1: {
   1:   if (!mView || !mVisible)
   1:     return NS_OK;
   1: 
   1:   // FIXME rewrite to use a Cocoa region when nsIRegion isn't a QD Region
   1:   NSRect r;
   1:   nsRect bounds;
3233:   nsIRegion* region = const_cast<nsIRegion*>(aRegion);     // ugh. this method should be const
   1:   region->GetBoundingBox ( &bounds.x, &bounds.y, &bounds.width, &bounds.height );
   1:   GeckoRectToNSRect(bounds, r);
   1:   
   1:   if ( aIsSynchronous )
   1:     [mView displayRect:r];
   1:   else
   1:     [mView setNeedsDisplayInRect:r];
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: inline PRUint16 COLOR8TOCOLOR16(PRUint8 color8)
   1: {
   1:   // return (color8 == 0xFF ? 0xFFFF : (color8 << 8));
   1:   return (color8 << 8) | color8;  /* (color8 * 257) == (color8 * 0x0101) */
   1: }
   1: 
   1: 
   1: // Dummy impl, meant to be overridden
   1: PRBool
   1: nsChildView::OnPaint(nsPaintEvent &event)
   1: {
   1:   return PR_TRUE;
   1: }
   1: 
   1: 
   1: // this is handled for us by UpdateWidget
   1: NS_IMETHODIMP nsChildView::Update()
   1: {
   1:   // Update means "Flush any pending changes right now."  It does *not* mean
   1:   // repaint the world. :) -- dwh
   1:   [mView displayIfNeeded];
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: // Scroll the bits of a view and its children
   1: // FIXME: I'm sure the invalidating can be optimized, just no time now.
   1: NS_IMETHODIMP nsChildView::Scroll(PRInt32 aDx, PRInt32 aDy, nsRect *aClipRect)
   1: {
   1:   BOOL viewWasDirty = NO;
   1:   if (mVisible) {
   1:     viewWasDirty = [mView needsDisplay];
   1: 
   1:     NSSize scrollVector = {aDx,aDy};
   1:     [mView scrollRect: [mView visibleRect] by:scrollVector];
   1:   }
   1:   
   1:   // Scroll the children (even if the widget is not visible)
   1:   for (nsIWidget* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
   1:     // We use resize rather than move since it gives us control
   1:     // over repainting.  We can scroll like a bat out of hell
   1:     // by not wasting time invalidating the widgets, since it's
   1:     // completely unnecessary to do so.
   1:     nsRect bounds;
   1:     kid->GetBounds(bounds);
   1:     kid->Resize(bounds.x + aDx, bounds.y + aDy, bounds.width, bounds.height, PR_FALSE);
   1:   }
   1: 
   1:   if (mVisible) {
   1:     if (viewWasDirty) {
   1:       [mView setNeedsDisplay:YES];
   1:     }
   1:     else {
   1:       NSRect frame = [mView visibleRect];
   1:       NSRect horizInvalid = frame;
   1:       NSRect vertInvalid = frame;
   1:   
   1:       if (aDx != 0) {
   1:         horizInvalid.size.width = abs(aDx);
   1:         if (aDx < 0)
   1:           horizInvalid.origin.x = frame.origin.x + frame.size.width + aDx;
   1:         [mView setNeedsDisplayInRect: horizInvalid];
   1:       }
   1: 
   1:       if (aDy != 0) {
   1:         vertInvalid.size.height = abs(aDy);
   1:         if (aDy < 0)
   1:           vertInvalid.origin.y = frame.origin.y + frame.size.height + aDy;
   1:         [mView setNeedsDisplayInRect: vertInvalid];
   1:       }
   1: 
   1:       // We also need to check for any ChildViews which overlap this widget
   1:       // but are not descendent widgets.  If there are any, we need to
   1:       // invalidate the area of this view that these ChildViews will have been
   1:       // blitted into, since these widgets aren't supposed to scroll with
   1:       // this widget.
   1: 
   1:       // To do this, start at the root Gecko NSView, and walk down along
   1:       // our ancestor view chain, looking at all the subviews in each level
   1:       // of the hierarchy.  If we find a non-ancestor view that overlaps
   1:       // this view, invalidate the area around it.
   1: 
   1:       // We need to convert all rects to a common ancestor view to intersect
   1:       // them, since a view's frame is in the coordinate space of its parent.
   1:       // Use mParentView as the frame of reference.
   1:       NSRect selfFrame = [mParentView convertRect:[mView frame] fromView:[mView superview]];
   1:       NSView* view = mParentView;
   1:       BOOL selfLevel = NO;
   1: 
   1:       while (!selfLevel) {
   1:         NSView* nextAncestorView = nil;
   1:         NSArray* subviews = [view subviews];
   1:         for (unsigned int i = 0; i < [subviews count]; ++i) {
   1:           NSView* subView = [subviews objectAtIndex: i];
   1:           if (subView == mView)
   1:             selfLevel = YES;
   1:           else if ([mView isDescendantOf:subView])
   1:             nextAncestorView = subView;
   1:           else {
   1:             NSRect intersectArea = NSIntersectionRect([mParentView convertRect:[subView frame] fromView:[subView superview]], selfFrame);
   1:             if (!NSIsEmptyRect(intersectArea)) {
   1:               NSPoint origin = [mView convertPoint:intersectArea.origin fromView:mParentView];
   1: 
   1:               if (aDy != 0) {
   1:                 vertInvalid.origin.x = origin.x;
   1:                 if (aDy < 0)  // scrolled down, invalidate above
   1:                   vertInvalid.origin.y = origin.y + aDy;
   1:                 else          // invalidate below
   1:                   vertInvalid.origin.y = origin.y + intersectArea.size.height;
   1:                 vertInvalid.size.width = intersectArea.size.width;
   1:                 [mView setNeedsDisplayInRect: vertInvalid];
   1:               }
   1: 
   1:               if (aDx != 0) {
   1:                 horizInvalid.origin.y = origin.y;
   1:                 if (aDx < 0)  // scrolled right, invalidate to the left
   1:                   horizInvalid.origin.x = origin.x + aDx;
   1:                 else          // invalidate to the right
   1:                   horizInvalid.origin.x = origin.x + intersectArea.size.width;
   1:                 horizInvalid.size.height = intersectArea.size.height;
   1:                 [mView setNeedsDisplayInRect: horizInvalid];
   1:               }
   1:             }
   1:           }
   1:         }
   1:         view = nextAncestorView;
   1:       }
   1:     }
   1:   }
   1:   
   1:   // This is an evil hack that doesn't always work.
   1:   // 
   1:   // Drawing plugins in a Cocoa environment is tricky, because the
   1:   // plugins are living in a Carbon WindowRef/BeginUpdate/EndUpdate
   1:   // world, and Cocoa has its own notion of dirty rectangles. Throw
   1:   // Quartz Extreme and QuickTime into the mix, and things get bad.
   1:   // 
   1:   // This code is working around a cosmetic issue seen when Quartz Extreme
   1:   // is active, and you're scrolling a page with a QuickTime plugin; areas
   1:   // outside the plugin fail to scroll properly. This [display] ensures that
   1:   // the view is properly drawn before the next Scroll call.
   1:   //
   1:   // The time this doesn't work is when you're scrolling a page containing
   1:   // an iframe which in turn contains a plugin.
   1:   //
   1:   // This is turned off because it makes scrolling pages with plugins slow.
   1:   // 
   1:   //if ([mView childViewHasPlugin])
   1:   //  [mView display];
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
6118: // Invokes callback and ProcessEvent methods on Event Listener object
   1: NS_IMETHODIMP nsChildView::DispatchEvent(nsGUIEvent* event, nsEventStatus& aStatus)
   1: {
   1:   aStatus = nsEventStatus_eIgnore;
   1: 
   1:   if (mDestructorCalled)
   1:     return NS_OK;
   1:   
   1:   nsCOMPtr<nsIWidget> kungFuDeathGrip(event->widget);
   1:   nsCOMPtr<nsIWidget> kungFuDeathGrip2;
   1:   if (mParentWidget) {
   1:     nsWindowType type;
   1:     mParentWidget->GetWindowType(type);
   1:     if (type == eWindowType_popup) {
4173:       // use the parent popup's widget if there is no view
4173:       void* clientData = nsnull;
4173:       if (event->widget)
4173:         event->widget->GetClientData(clientData);
4173:       if (!clientData) {
   1:         event->widget = mParentWidget;
   1:         kungFuDeathGrip2 = mParentWidget;
   1:       }
   1:     }
4173:   }
   1: 
   1:   if (mEventCallback)
   1:     aStatus = (*mEventCallback)(event);
   1: 
   1:   // dispatch to event listener if event was not consumed
   1:   if (mEventListener && aStatus != nsEventStatus_eConsumeNoDefault)
6118:     aStatus = mEventListener->ProcessEvent(*event);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: PRBool nsChildView::DispatchWindowEvent(nsGUIEvent &event)
   1: {
   1:   nsEventStatus status;
   1:   DispatchEvent(&event, status);
   1:   return ConvertStatus(status);
   1: }
   1: 
   1: 
   1: // Deal with all sort of mouse event
   1: PRBool nsChildView::DispatchMouseEvent(nsMouseEvent &aEvent)
   1: {
   1:   PRBool result = PR_FALSE;
   1: 
   1:   // call the event callback 
   1:   if (mEventCallback)
   1:     return DispatchWindowEvent(aEvent);
   1: 
   1:   if (mMouseListener) {
   1:     switch (aEvent.message) {
   1:       case NS_MOUSE_MOVE:
   1:         result = ConvertStatus(mMouseListener->MouseMoved(aEvent));
   1:         break;
   1: 
   1:       case NS_MOUSE_BUTTON_DOWN:
   1:         result = ConvertStatus(mMouseListener->MousePressed(aEvent));
   1:         break;
   1: 
   1:       case NS_MOUSE_BUTTON_UP:
   1:         result = ConvertStatus(mMouseListener->MouseReleased(aEvent));
   1:         result = ConvertStatus(mMouseListener->MouseClicked(aEvent));
   1:         break;
   1:     } // switch
   1:   }
   1: 
   1:   return result;
   1: }
   1: 
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: PRBool nsChildView::ReportDestroyEvent()
   1: {
   1:   nsGUIEvent event(PR_TRUE, NS_DESTROY, this);
   1:   event.time = PR_IntervalNow();
3653:   return DispatchWindowEvent(event);
   1: }
   1: 
   1: 
   1: PRBool nsChildView::ReportMoveEvent()
   1: {
   1:   nsGUIEvent moveEvent(PR_TRUE, NS_MOVE, this);
   1:   moveEvent.refPoint.x = mBounds.x;
   1:   moveEvent.refPoint.y = mBounds.y;
   1:   moveEvent.time       = PR_IntervalNow();
3653:   return DispatchWindowEvent(moveEvent);
   1: }
   1: 
   1: 
   1: PRBool nsChildView::ReportSizeEvent()
   1: {
   1:   nsSizeEvent sizeEvent(PR_TRUE, NS_SIZE, this);
   1:   sizeEvent.time        = PR_IntervalNow();
   1:   sizeEvent.windowSize  = &mBounds;
   1:   sizeEvent.mWinWidth   = mBounds.width;
   1:   sizeEvent.mWinHeight  = mBounds.height;
3653:   return DispatchWindowEvent(sizeEvent);
   1: }
   1: 
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: /*  Calculate the x and y offsets for this particular widget
   1:  *  @update  ps 09/22/98
   1:  *  @param   aX -- x offset amount
   1:  *  @param   aY -- y offset amount 
   1:  *  @return  NOTHING
   1:  */
   1: NS_IMETHODIMP nsChildView::CalcOffset(PRInt32 &aX,PRInt32 &aY)
   1: {
   1:   aX = aY = 0;
   1:   NSRect bounds = {{0, 0}, {0, 0}};
   1:   bounds = [mView convertRect:bounds toView:nil];
3233:   aX += static_cast<PRInt32>(bounds.origin.x);
3233:   aY += static_cast<PRInt32>(bounds.origin.y);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Find if a point in local coordinates is inside this object
   1: PRBool nsChildView::PointInWidget(Point aThePoint)
   1: {
   1:   // get the origin in local coordinates
   1:   nsPoint widgetOrigin(0, 0);
   1:   LocalToWindowCoordinate(widgetOrigin);
   1: 
   1:   // get rectangle relatively to the parent
   1:   nsRect widgetRect;
   1:   GetBounds(widgetRect);
   1: 
   1:   // convert the topLeft corner to local coordinates
   1:   widgetRect.MoveBy(widgetOrigin.x, widgetOrigin.y);
   1: 
   1:   // finally tell whether it's a hit
   1:   return widgetRect.Contains(aThePoint.h, aThePoint.v);
   1: }
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: //    Convert the given rect to global coordinates.
   1: //    @param aLocalRect  -- rect in local coordinates of this widget
   1: //    @param aGlobalRect -- |aLocalRect| in global coordinates
   1: NS_IMETHODIMP nsChildView::WidgetToScreen(const nsRect& aLocalRect, nsRect& aGlobalRect)
   1: {
   1:   NSRect temp;
   1:   GeckoRectToNSRect(aLocalRect, temp);
   1:   
   1:   // 1. First translate this rect into window coords. The returned rect is always in
   1:   //    bottom-left coordinates.
   1:   //
   1:   //    NOTE: convertRect:toView:nil doesn't care if |mView| is a flipped view (with
   1:   //          top-left coords) and so assumes that our passed-in rect's origin is in
   1:   //          bottom-left coordinates. We adjust this further down, by subtracting
   1:   //          the final screen rect's origin by the rect's height, to get the origo
   1:   //          where we want it.
   1:   temp = [mView convertRect:temp toView:nil];  
   1:   
   1:   // 2. We turn the window-coord rect's origin into screen (still bottom-left) coords.
   1:   temp.origin = [[mView nativeWindow] convertBaseToScreen:temp.origin];
   1:   
   1:   // 3. Since we're dealing in bottom-left coords, we need to make it top-left coords
   1:   //    before we pass it back to Gecko.
   1:   FlipCocoaScreenCoordinate(temp.origin);
   1:   
   1:   // 4. If this is rect has a size (and is not simply a point), it is important to account 
   1:   //    for the fact that convertRect:toView:nil thought our passed-in point was in bottom-left 
   1:   //    coords in step #1. Thus, we subtract the rect's height, to get the top-left rect's origin 
   1:   //     where we want it.
   1:   temp.origin.y -= temp.size.height;
   1:   
   1:   NSRectToGeckoRect(temp, aGlobalRect);
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: //    Convert the given rect to local coordinates.
   1: //    @param aGlobalRect  -- rect in screen coordinates 
   1: //    @param aLocalRect -- |aGlobalRect| in coordinates of this widget
   1: NS_IMETHODIMP nsChildView::ScreenToWidget(const nsRect& aGlobalRect, nsRect& aLocalRect)
   1: {
   1:   NSRect temp;
   1:   GeckoRectToNSRect(aGlobalRect, temp);
   1:   FlipCocoaScreenCoordinate(temp.origin);
   1: 
   1:   temp.origin = [[mView nativeWindow] convertScreenToBase:temp.origin];   // convert to screen coords
   1:   temp = [mView convertRect:temp fromView:nil];                     // convert to window coords
   1: 
   1:   NSRectToGeckoRect(temp, aLocalRect);
   1:   
   1:   return NS_OK;
   1: } 
   1: 
   1: 
   1: // Convert the coordinates to some device coordinates so GFX can draw.
   1: void nsChildView::ConvertToDeviceCoordinates(nscoord &aX, nscoord &aY)
   1: {
   1:   PRInt32 offX = 0, offY = 0;
   1:   this->CalcOffset(offX,offY);
   1: 
   1:   aX += offX;
   1:   aY += offY;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::CaptureRollupEvents(nsIRollupListener * aListener, 
   1:                                                PRBool aDoCapture, 
   1:                                                PRBool aConsumeRollupEvent)
   1: {
   1:   // this never gets called, only top-level windows can be rollup widgets
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::SetTitle(const nsAString& title)
   1: {
3653:   // child views don't have titles
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP nsChildView::GetAttention(PRInt32 aCycleCount)
   1: {
   1:   [NSApp requestUserAttention:NSInformationalRequest];
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: // Force Input Method Editor to commit the uncommited input
   1: // Note that this and other nsIKBStateControl methods don't necessarily
   1: // get called on the same ChildView that input is going through.
   1: NS_IMETHODIMP nsChildView::ResetInputState()
   1: {
   1: #ifdef DEBUG_IME
   1:   NSLog(@"**** ResetInputState");
   1: #endif
   1: 
 539:   nsTSMManager::CommitIME();
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // 'open' means that it can take non-ASCII chars
   1: NS_IMETHODIMP nsChildView::SetIMEOpenState(PRBool aState)
   1: {
 539: #ifdef DEBUG_IME
 539:   NSLog(@"**** SetIMEOpenState aState = %d", aState);
 539: #endif
 539: 
 539:   nsTSMManager::SetIMEOpenState(aState);
 539:   return NS_OK;
   1: }
   1: 
   1: 
   1: // 'open' means that it can take non-ASCII chars
   1: NS_IMETHODIMP nsChildView::GetIMEOpenState(PRBool* aState)
   1: {
 539: #ifdef DEBUG_IME
 539:   NSLog(@"**** GetIMEOpenState");
 539: #endif
 539: 
 539:   *aState = nsTSMManager::GetIMEOpenState();
 539:   return NS_OK;
 539: }
 539: 
 539: 
 539: NS_IMETHODIMP nsChildView::SetIMEEnabled(PRUint32 aState)
   1: {
 539: #ifdef DEBUG_IME
 539:   NSLog(@"**** SetIMEEnabled aState = %d", aState);
 539: #endif
 539: 
 539:   switch (aState) {
 539:     case nsIKBStateControl::IME_STATUS_ENABLED:
 539:       nsTSMManager::SetRomanKeyboardsOnly(PR_FALSE);
 539:       nsTSMManager::EnableIME(PR_TRUE);
 539:       break;
 539:     case nsIKBStateControl::IME_STATUS_DISABLED:
 539:       nsTSMManager::SetRomanKeyboardsOnly(PR_FALSE);
 539:       nsTSMManager::EnableIME(PR_FALSE);
 539:       break;
 539:     case nsIKBStateControl::IME_STATUS_PASSWORD:
 539:       nsTSMManager::SetRomanKeyboardsOnly(PR_TRUE);
 539:       nsTSMManager::EnableIME(PR_FALSE);
 539:       break;
 539:     default:
 539:       NS_ERROR("not implemented!");
 539:   }
 539:   return NS_OK;
 539: }
 539: 
 539: 
 539: NS_IMETHODIMP nsChildView::GetIMEEnabled(PRUint32* aState)
   1: {
 539: #ifdef DEBUG_IME
 539:   NSLog(@"**** GetIMEEnabled");
 539: #endif
 539: 
 539:   if (nsTSMManager::IsIMEEnabled())
 539:     *aState = nsIKBStateControl::IME_STATUS_ENABLED;
 539:   else if (nsTSMManager::IsRomanKeyboardsOnly())
 539:     *aState = nsIKBStateControl::IME_STATUS_PASSWORD;
 539:   else
 539:     *aState = nsIKBStateControl::IME_STATUS_DISABLED;
 539:   return NS_OK;
   1: }
   1: 
   1: 
   1: // Destruct and don't commit the IME composition string.
   1: NS_IMETHODIMP nsChildView::CancelIMEComposition()
   1: {
   1: #ifdef DEBUG_IME
   1:   NSLog(@"**** CancelIMEComposition");
   1: #endif
   1: 
 539:   nsTSMManager::CancelIME();
   1:   return NS_OK;
   1: }
   1: 
   1: 
2475: NS_IMETHODIMP nsChildView::GetToggledKeyState(PRUint32 aKeyCode,
2475:                                               PRBool* aLEDState)
2475: {
2475: #ifdef DEBUG_IME
2475:   NSLog(@"**** GetToggledKeyState");
2475: #endif
2475:   NS_ENSURE_ARG_POINTER(aLEDState);
2475:   PRUint32 key;
2475:   switch (aKeyCode) {
2475:     case NS_VK_CAPS_LOCK:
2475:       key = alphaLock;
2475:       break;
2475:     case NS_VK_NUM_LOCK:
2475:       key = kEventKeyModifierNumLockMask;
2475:       break;
2475:     // Mac doesn't support SCROLL_LOCK state.
2475:     default:
2475:       return NS_ERROR_NOT_IMPLEMENTED;
2475:   }
2475:   PRUint32 modifierFlags = ::GetCurrentKeyModifiers();
2475:   *aLEDState = (modifierFlags & key) != 0;
2475:   return NS_OK;
2475: }
2475: 
2475: 
   1: #pragma mark -
   1: 
   1: 
   1: // Handle an event coming into us and send it to gecko.
   1: NS_IMETHODIMP
   1: nsChildView::DispatchEvent(void* anEvent, PRBool *_retval)
   1: {
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // The drag manager has let us know that something related to a drag has
   1: // occurred in this window. It could be any number of things, ranging from 
   1: // a drop, to a drag enter/leave, or a drag over event. The actual event
   1: // is passed in |aMessage| and is passed along to our event handler so Gecko
   1: // knows about it.
   1: NS_IMETHODIMP
   1: nsChildView::DragEvent(PRUint32 aMessage, PRInt16 aMouseGlobalX, PRInt16 aMouseGlobalY,
   1:                          PRUint16 aKeyModifiers, PRBool *_retval)
   1: {
   1:   // ensure that this is going to a ChildView (not something else like a
   1:   // scrollbar). I think it's safe to just bail at this point if it's not
   1:   // what we expect it to be
   1:   if (![mView isKindOfClass:[ChildView class]]) {
   1:     *_retval = PR_FALSE;
   1:     return NS_OK;
   1:   }
   1: 
   1:   // set up gecko event
   1:   nsMouseEvent geckoEvent(PR_TRUE, aMessage, nsnull, nsMouseEvent::eReal);
2315:   [(ChildView*)mView convertGenericCocoaEvent:nil toGeckoEvent:&geckoEvent];
   1: 
   1:   // Use our own coordinates in the gecko event.
   1:   // Convert event from gecko global coords to gecko view coords.
   1:   NSPoint localPoint = NSMakePoint(aMouseGlobalX, aMouseGlobalY);
   1:   FlipCocoaScreenCoordinate(localPoint);
   1:   localPoint = [[mView window] convertScreenToBase:localPoint];
   1:   localPoint = [mView convertPoint:localPoint fromView:nil];
3233:   geckoEvent.refPoint.x = static_cast<nscoord>(localPoint.x);
3233:   geckoEvent.refPoint.y = static_cast<nscoord>(localPoint.y);
   1: 
   1:   DispatchWindowEvent(geckoEvent);
   1: 
   1:   // we handled the event
   1:   *_retval = PR_TRUE;
   1:   return NS_OK;
   1: }
   1: 
   1: 
   1: // The cocoa view calls DispatchWindowEvent() directly, so no need for this
   1: NS_IMETHODIMP
   1: nsChildView::Scroll(PRBool aVertical, PRInt16 aNumLines, PRInt16 aMouseLocalX, 
   1:                     PRInt16 aMouseLocalY, PRBool *_retval)
   1: {
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: 
   1: NS_IMETHODIMP
   1: nsChildView::Idle()
   1: {
   1:   // do some idle stuff?
   1:   return NS_ERROR_NOT_IMPLEMENTED;
   1: }
   1: 
   1: 
   1: gfxASurface*
   1: nsChildView::GetThebesSurface()
   1: {
   1:   if (!mTempThebesSurface) {
   1:     mTempThebesSurface = new gfxQuartzSurface(gfxSize(1, 1), gfxASurface::ImageFormatARGB32);
   1:   }
   1: 
1556:   return mTempThebesSurface;
   1: }
   1: 
   1: 
   1: #ifdef ACCESSIBILITY
   1: void
   1: nsChildView::GetDocumentAccessible(nsIAccessible** aAccessible)
   1: {
   1:   *aAccessible = nsnull;
   1:   
   1:   nsCOMPtr<nsIAccessible> accessible = do_QueryReferent(mAccessible);
   1:   if (!mAccessible) {
   1:     // need to fetch the accessible anew, because it has gone away.
   1:     nsEventStatus status;
   1:     nsAccessibleEvent event(PR_TRUE, NS_GETACCESSIBLE, this);
   1:     DispatchEvent(&event, status);
   1:   
   1:     // cache the accessible in our weak ptr
   1:     mAccessible = do_GetWeakReference(event.accessible);
   1:     
   1:     // now try again
   1:     accessible = do_QueryReferent(mAccessible);
   1:   }
   1:   
   1:   NS_IF_ADDREF(*aAccessible = accessible.get());
   1: 
   1:   return;
   1: }
   1: #endif
   1: 
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: @implementation ChildView
   1: 
   1: 
   1: // globalDragPboard is non-null during native drag sessions that did not originate
   1: // in our native NSView (it is set in |draggingEntered:|). It is unset when the
   1: // drag session ends for this view, either with the mouse exiting or when a drop
   1: // occurs in this view.
   1: NSPasteboard* globalDragPboard = nil;
   1: 
   1: 
6245: // gLastDragView and gLastDragEvent are only non-null during calls to |mouseDragged:|
   1: // in our native NSView. They are used to communicate information to the drag service
   1: // during drag invocation (starting a drag in from the view). All drag service drag
   1: // invocations happen only while these two global variables are non-null, while |mouseDragged:|
   1: // is on the stack.
6245: NSView* gLastDragView = nil;
6245: NSEvent* gLastDragEvent = nil;
   1: 
   1: 
   1: // initWithFrame:geckoChild:eventSink:
   1: - (id)initWithFrame:(NSRect)inFrame geckoChild:(nsChildView*)inChild eventSink:(nsIEventSink*)inSink
   1: {
   1:   if ((self = [super initWithFrame:inFrame])) {
   1:     mGeckoChild = inChild;
   1:     mIsPluginView = NO;
   1:     mCurKeyEvent = nil;
   1:     mKeyHandled = PR_FALSE;
   1:     
   1:     // initialization for NSTextInput
   1:     mMarkedRange.location = NSNotFound;
   1:     mMarkedRange.length = 0;
   1:     mSelectedRange.location = NSNotFound;
   1:     mSelectedRange.length = 0;
   1:     mLastMenuForEventEvent = nil;
   1:     mDragService = nsnull;
   1:   }
   1:   
   1:   // register for things we'll take from other applications
3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView initWithFrame: registering drag types\n"));
   1:   [self registerForDraggedTypes:[NSArray arrayWithObjects:NSFilenamesPboardType,
   1:                                                           NSStringPboardType,
   1:                                                           NSURLPboardType,
3545:                                                           NSFilesPromisePboardType,
1933:                                                           kWildcardPboardType,
   1:                                                           nil]];
   1: 
   1:   return self;
   1: }
   1: 
   1: 
   1: - (void)dealloc
   1: {
   1:   [mPendingDirtyRects release];
   1:   [mLastMenuForEventEvent release];
   1:   
   1:   if (sLastViewEntered == self)
   1:     sLastViewEntered = nil;
   1: 
6013:   [super dealloc];    
6013: 
6013:   // This sets the current port to _savePort.
6013:   // todo: Only do if a Quickdraw plugin is present in the hierarchy!
6013:   ::SetPort(NULL);
   1: }
   1: 
   1: 
   1: - (void)widgetDestroyed
   1: {
   1:   mGeckoChild = nsnull;
   1: }
   1: 
   1: 
   1: // mozView method, return our gecko child view widget. Note this does not AddRef.
   1: - (nsIWidget*) widget
   1: {
3233:   return static_cast<nsIWidget*>(mGeckoChild);
   1: }
   1: 
   1: 
   1: // mozView method, get the window that this view is associated with
   1: - (NSWindow*)nativeWindow
   1: {
   1:   NSWindow* currWin = [self window];
   1:   if (currWin)
   1:      return currWin;
   1:   else
   1:      return mWindow;
   1: }
   1: 
   1: 
   1: // mozView method, set the NSWindow that this view is associated with (even when
   1: // not in the view hierarchy).
   1: - (void)setNativeWindow:(NSWindow*)aWindow
   1: {
   1:   mWindow = aWindow;
   1: }
   1: 
   1: 
   1: - (void)setNeedsPendingDisplay
   1: {
   1:   mPendingFullDisplay = YES;
   1:   [self performSelector:@selector(processPendingRedraws) withObject:nil afterDelay:0];
   1: }
   1: 
   1: 
   1: - (void)setNeedsPendingDisplayInRect:(NSRect)invalidRect
   1: {
   1:   if (!mPendingDirtyRects)
   1:     mPendingDirtyRects = [[NSMutableArray alloc] initWithCapacity:1];
   1:   [mPendingDirtyRects addObject:[NSValue valueWithRect:invalidRect]];
   1:   [self performSelector:@selector(processPendingRedraws) withObject:nil afterDelay:0];
   1: }
   1: 
   1: 
   1: // Clears the queue of any pending invalides
   1: - (void)processPendingRedraws
   1: {
   1:   if (mPendingFullDisplay) {
   1:     [self setNeedsDisplay:YES];
   1:   }
   1:   else {
   1:     unsigned int count = [mPendingDirtyRects count];
   1:     for (unsigned int i = 0; i < count; ++i) {
   1:       [self setNeedsDisplayInRect:[[mPendingDirtyRects objectAtIndex:i] rectValue]];
   1:     }
   1:   }
   1:   mPendingFullDisplay = NO;
   1:   [mPendingDirtyRects release];
   1:   mPendingDirtyRects = nil;
   1: }
   1: 
   1: 
   1: - (NSString*)description
   1: {
   1:   return [NSString stringWithFormat:@"ChildView %p, gecko child %p, frame %@", self, mGeckoChild, NSStringFromRect([self frame])];
   1: }
   1: 
   1: 
   1: // Find the nearest scrollable view for this ChildView
   1: // (recall that views are not refcounted)
   1: - (nsIScrollableView*) getScrollableView
   1: {
   1:   nsIScrollableView* scrollableView = nsnull;
   1: 
   1:   ChildView* currView = self;
   1:   // we have to loop up through superviews in case the view that received the
   1:   // mouseDown is in fact a plugin view with no scrollbars
   1:   while (currView) {
   1:     // This is a hack I learned in nsView::GetViewFor(nsIWidget* aWidget)
   1:     // that I'm not sure is kosher. If anyone knows a better way to get
   1:     // the view for a widget, I'd love to hear it. --Nathan
   1: 
   1:     void* clientData;
   1:     [currView widget]->GetClientData(clientData);
   1: 
   1:     nsISupports* data = (nsISupports*)clientData;
   1:     nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(data));
   1:     if (req) {
   1:       req->GetInterface(NS_GET_IID(nsIScrollableView), (void**)&scrollableView);
   1:       if (scrollableView)
   1:         break;
   1:     }
   1: 
   1:     if ([[currView superview] isMemberOfClass:[ChildView class]])
   1:         currView = (ChildView*)[currView superview];
   1:     else
   1:         currView = nil;
   1:   }
   1: 
   1:   return scrollableView;
   1: }
   1: 
   1: 
   1: // set the closed hand cursor and record the starting scroll positions
   1: - (void) startHandScroll:(NSEvent*)theEvent
   1: {
2462:   if (!mGeckoChild)
2462:     return;
2462: 
   1:   mHandScrollStartMouseLoc = [[self window] convertBaseToScreen:[theEvent locationInWindow]];
   1: 
   1:   nsIScrollableView* aScrollableView = [self getScrollableView]; 
   1: 
   1:   // if we succeeded in getting aScrollableView
   1:   if (aScrollableView) {
   1:     aScrollableView->GetScrollPosition(mHandScrollStartScrollX, mHandScrollStartScrollY);
   1:     mGeckoChild->SetCursor(eCursor_grabbing);
   1:     mInHandScroll = TRUE;
   1:   }
   1: }
   1: 
   1: 
   1: // update the scroll position based on the new mouse coordinates
   1: - (void) updateHandScroll:(NSEvent*)theEvent
   1: {
2462:   if (!mGeckoChild)
2462:     return;
2462: 
   1:   nsIScrollableView* aScrollableView = [self getScrollableView];
   1:   if (!aScrollableView)
   1:     return;
   1: 
   1:   NSPoint newMouseLoc = [[self window] convertBaseToScreen:[theEvent locationInWindow]];
   1: 
   1:   PRInt32 deltaX = (PRInt32)(mHandScrollStartMouseLoc.x - newMouseLoc.x);
   1:   PRInt32 deltaY = (PRInt32)(newMouseLoc.y - mHandScrollStartMouseLoc.y);
   1: 
   1:   // convert to the nsIView coordinates
   1:   PRInt32 p2a = mGeckoChild->GetDeviceContext()->AppUnitsPerDevPixel();
   1:   nscoord newX = mHandScrollStartScrollX + NSIntPixelsToAppUnits(deltaX, p2a);
   1:   nscoord newY = mHandScrollStartScrollY + NSIntPixelsToAppUnits(deltaY, p2a);
   1:   aScrollableView->ScrollTo(newX, newY, NS_VMREFRESH_IMMEDIATE);
   1: }
   1: 
   1: 
   1: // Return true if the correct modifiers are pressed to perform hand scrolling.
   1: + (BOOL) areHandScrollModifiers:(unsigned int)modifiers
   1: {
   1:   // The command and option key should be held down.  Ignore capsLock by
   1:   // setting it explicitly to match.
   1:   modifiers |= NSAlphaShiftKeyMask;
   1:   return (modifiers & NSDeviceIndependentModifierFlagsMask) ==
   1:       (NSAlphaShiftKeyMask | NSCommandKeyMask | NSAlternateKeyMask);
   1: }
   1: 
   1: 
   1: // If the user is pressing the hand scroll modifiers, then set
   1: // the hand scroll cursor.
   1: - (void) setHandScrollCursor:(NSEvent*)theEvent
   1: {
2462:   if (!mGeckoChild)
2462:     return;
2462: 
   1:   BOOL inMouseView = NO;
   1: 
   1:   // check to see if the user has hand scroll modifiers held down; if so, 
   1:   // find out if the cursor is in an ChildView
   1:   if ([ChildView areHandScrollModifiers:[theEvent modifierFlags]]) {
   1:     NSPoint pointInWindow = [[self window] mouseLocationOutsideOfEventStream];
   1: 
   1:     NSView* mouseView = [[[self window] contentView] hitTest:pointInWindow];
   1:     inMouseView = (mouseView != nil && [mouseView isMemberOfClass:[ChildView class]]);   
   1:   }
   1:   if (inMouseView) {
   1:       mGeckoChild->SetCursor(eCursor_grab);
   1:   } else {
   1:     nsCursor cursor = mGeckoChild->GetCursor();
   1:     if (!mInHandScroll) {
   1:       if (cursor == eCursor_grab || cursor == eCursor_grabbing)
   1:         mGeckoChild->SetCursor(eCursor_standard);
   1:     }
   1:   }
   1: }
   1: 
   1: 
   1: // reset the scroll flag and cursor
   1: - (void) stopHandScroll:(NSEvent*)theEvent
   1: {
   1:   mInHandScroll = FALSE;
   1:   [self setHandScrollCursor:theEvent];
   1: }
   1: 
   1: 
   1: // When smooth scrolling is turned on on panther, the parent of a scrollbar (which
   1: // I guess they assume is a NSScrollView) gets called with this method. I have no
   1: // idea what the correct return value is, but we have to have this otherwise the scrollbar
   1: // will not continuously respond when the mouse is held down in the pageup/down area.
   1: -(float)_destinationFloatValueForScroller:(id)scroller
   1: {
   1:   return [scroller floatValue];
   1: }
   1: 
   1: 
   1: // Override in order to keep our mouse enter/exit tracking rect in sync with
   1: // the frame of the view
   1: - (void)setFrame:(NSRect)frameRect
   1: {  
   1:   [super setFrame:frameRect];
   1:   if (mMouseEnterExitTag)
   1:     [self removeTrackingRect:mMouseEnterExitTag];
   1: 
   1:   if ([self window])
   1:     mMouseEnterExitTag = [self addTrackingRect:[self bounds]
   1:                                          owner:self
   1:                                       userData:nil
   1:                                   assumeInside:[[self window] acceptsMouseMovedEvents]];
   1: }
   1: 
   1: 
   1: // Make the origin of this view the topLeft corner (gecko origin) rather
   1: // than the bottomLeft corner (standard cocoa origin).
   1: - (BOOL)isFlipped
   1: {
   1:   return YES;
   1: }
   1: 
   1: 
   1: - (BOOL)isOpaque
   1: {
   1:   // this will be NO when we can do transparent windows/views
   1:   return YES;
   1: }
   1: 
   1: 
   1: -(void)setIsPluginView:(BOOL)aIsPlugin
   1: {
   1:   mIsPluginView = aIsPlugin;
   1: }
   1: 
   1: 
 130: -(BOOL)isPluginView
   1: {
   1:   return mIsPluginView;
   1: }
   1: 
   1: 
   1: - (BOOL)childViewHasPlugin
   1: {
   1:   NSArray* subviews = [self subviews];
   1:   for (unsigned int i = 0; i < [subviews count]; i ++) {
   1:     id subview = [subviews objectAtIndex:i];
 130:     if ([subview respondsToSelector:@selector(isPluginView)] && [subview isPluginView])
   1:       return YES;
   1:   }
   1:   
   1:   return NO;
   1: }
   1: 
   1: 
4208: - (void)sendFocusEvent:(PRUint32)eventType
4208: {
4208:   if (!mGeckoChild)
4208:     return;
4208: 
4208:   nsEventStatus status = nsEventStatus_eIgnore;
4208:   nsGUIEvent focusGuiEvent(PR_TRUE, eventType, mGeckoChild);
4208:   focusGuiEvent.time = PR_IntervalNow();
4208:   mGeckoChild->DispatchEvent(&focusGuiEvent, status);
4208: }
4208: 
4208: 
   1: // We accept key and mouse events, so don't keep passing them up the chain. Allow
   1: // this to be a 'focussed' widget for event dispatch
   1: - (BOOL)acceptsFirstResponder
   1: {
   1:   return YES;
   1: }
   1: 
   1: 
   1: - (void)viewWillMoveToWindow:(NSWindow *)newWindow
   1: {
   1:   if (mMouseEnterExitTag)
   1:     [self removeTrackingRect:mMouseEnterExitTag];
   1: 
   1:   [super viewWillMoveToWindow:newWindow];
   1: }
   1: 
   1: 
   1: - (void)viewDidMoveToWindow
   1: {
   1:   if ([self window])
   1:     mMouseEnterExitTag = [self addTrackingRect:[self bounds] owner:self
   1:                                       userData:nil assumeInside: [[self window]
   1:                                       acceptsMouseMovedEvents]];
   1: 
   1:   [super viewDidMoveToWindow];
   1: }
   1: 
   1: 
   1: - (void)viewWillStartLiveResize
   1: {
   1:   if (mGeckoChild && mIsPluginView)
   1:     mGeckoChild->LiveResizeStarted();
   1:   
   1:   [super viewWillStartLiveResize];
   1: }
   1: 
   1: 
   1: - (void)viewDidEndLiveResize
   1: {
   1:   if (mGeckoChild && mIsPluginView)
   1:     mGeckoChild->LiveResizeEnded();
   1: 
   1:   [super viewDidEndLiveResize];
   1: }
   1: 
   1: 
   1: - (void)scrollRect:(NSRect)aRect by:(NSSize)offset
   1: {
   1:   // Update any pending dirty rects to reflect the new scroll position
   1:   if (mPendingDirtyRects) {
   1:     unsigned int count = [mPendingDirtyRects count];
   1:     for (unsigned int i = 0; i < count; ++i) {
   1:       NSRect oldRect = [[mPendingDirtyRects objectAtIndex:i] rectValue];
   1:       NSRect newRect = NSOffsetRect(oldRect, offset.width, offset.height);
   1:       [mPendingDirtyRects replaceObjectAtIndex:i
   1:                                     withObject:[NSValue valueWithRect:newRect]];
   1:     }
   1:   }
   1:   [super scrollRect:aRect by:offset];
   1: }
   1: 
   1: 
   1: - (BOOL)mouseDownCanMoveWindow
   1: {
   1:   return NO;
   1: }
   1: 
   1: 
   1: - (void)lockFocus
   1: {
   1:   // Set the current GrafPort to a "safe" port before calling [NSQuickDrawView lockFocus],
   1:   // so that the NSQuickDrawView stashes a pointer to this known-good port internally.
   1:   // It will set the port back to this port on destruction.
6013:   ::SetPort(NULL);  // todo: only do if a Quickdraw plugin is present in the hierarchy!
   1:   [super lockFocus];
   1: }
   1: 
   1: 
   1: // The display system has told us that a portion of our view is dirty. Tell
   1: // gecko to paint it
   1: - (void)drawRect:(NSRect)aRect
   1: {
   1:   PRBool isVisible;
   1:   if (!mGeckoChild || NS_FAILED(mGeckoChild->IsVisible(isVisible)) || !isVisible)
   1:     return;
   1:   
   1:   // Workaround for the fact that NSQuickDrawViews can't be opaque; see if the rect
   1:   // being drawn is covered by a subview, and, if so, just bail.
   1:   if ([self isRectObscuredBySubview:aRect])
   1:     return;
   1: 
   1:   CGContextRef cgContext = (CGContextRef)[[NSGraphicsContext currentContext] graphicsPort];
   1: 
   1:   nsRect geckoBounds;
   1:   mGeckoChild->GetBounds(geckoBounds);
   1: 
   1:   NSRect bounds = [self bounds];
   1:   nsRefPtr<gfxQuartzSurface> targetSurface =
 314:     new gfxQuartzSurface(cgContext, gfxSize(bounds.size.width, bounds.size.height));
   1: 
   1: #ifdef DEBUG_UPDATE
   1:   fprintf (stderr, "---- Update[%p][%p] [%f %f %f %f] cgc: %p\n  gecko bounds: [%d %d %d %d]\n",
   1:            self, mGeckoChild,
   1:            aRect.origin.x, aRect.origin.y, aRect.size.width, aRect.size.height, cgContext,
   1:            geckoBounds.x, geckoBounds.y, geckoBounds.width, geckoBounds.height);
   1: 
   1:   CGAffineTransform xform = CGContextGetCTM(cgContext);
   1:   fprintf (stderr, "  xform in: [%f %f %f %f %f %f]\n", xform.a, xform.b, xform.c, xform.d, xform.tx, xform.ty);
   1: #endif
   1: 
   1:   nsRefPtr<gfxContext> targetContext = new gfxContext(targetSurface);
   1: 
   1:   nsCOMPtr<nsIRenderingContext> rc;
   1:   mGeckoChild->GetDeviceContext()->CreateRenderingContextInstance(*getter_AddRefs(rc));
   1:   rc->Init(mGeckoChild->GetDeviceContext(), targetContext);
   1: 
   1:   /* clip and build a region */
   1:   nsCOMPtr<nsIRegion> rgn(do_CreateInstance(kRegionCID));
   1:   if (rgn)
   1:     rgn->Init();
   1: 
   1:   const NSRect *rects;
   1:   int count, i;
   1:   [self getRectsBeingDrawn:&rects count:&count];
   1:   for (i = 0; i < count; ++i) {
   1:     const NSRect& r = rects[i];
   1: 
   1:     // add to the region
   1:     if (rgn)
   1:       rgn->Union((PRInt32)r.origin.x, (PRInt32)r.origin.y, (PRInt32)r.size.width, (PRInt32)r.size.height);
   1: 
   1:     // to the context for clipping
   1:     targetContext->Rectangle(gfxRect(r.origin.x, r.origin.y, r.size.width, r.size.height));
   1:   }
   1:   targetContext->Clip();
   1:   
   1:   // bounding box of the dirty area
   1:   nsRect fullRect;
   1:   NSRectToGeckoRect(aRect, fullRect);
   1: 
   1:   nsPaintEvent paintEvent(PR_TRUE, NS_PAINT, mGeckoChild);
   1:   paintEvent.renderingContext = rc;
   1:   paintEvent.rect = &fullRect;
   1:   paintEvent.region = rgn;
   1: 
   1:   mGeckoChild->DispatchWindowEvent(paintEvent);
   1: 
   1:   paintEvent.renderingContext = nsnull;
   1:   paintEvent.region = nsnull;
   1: 
   1:   targetContext = nsnull;
   1:   targetSurface = nsnull;
   1: 
   1:   // note that the cairo surface *MUST* be destroyed at this point,
   1:   // or bad things will happen (since we can't keep the cgContext around
   1:   // beyond this drawRect message handler)
   1: 
   1: #ifdef DEBUG_UPDATE
   1:   fprintf (stderr, "  window coords: [%d %d %d %d]\n", fullRect.x, fullRect.y, fullRect.width, fullRect.height);
   1:   fprintf (stderr, "---- update done ----\n");
   1: 
   1: #if 0
   1:   CGContextSetRGBStrokeColor (cgContext,
   1:                             ((((unsigned long)self) & 0xff)) / 255.0,
   1:                             ((((unsigned long)self) & 0xff00) >> 8) / 255.0,
   1:                             ((((unsigned long)self) & 0xff0000) >> 16) / 255.0,
   1:                             0.5);
   1: #endif 
   1:   CGContextSetRGBStrokeColor (cgContext, 1, 0, 0, 0.8);
   1:   CGContextSetLineWidth (cgContext, 4.0);
   1:   CGContextStrokeRect (cgContext,
   1:                        CGRectMake(aRect.origin.x, aRect.origin.y, aRect.size.width, aRect.size.height));
   1: #endif
   1: }
   1: 
   1: 
   1: - (BOOL)isRectObscuredBySubview:(NSRect)inRect
   1: {
   1:   unsigned int numSubviews = [[self subviews] count];
   1:   for (unsigned int i = 0; i < numSubviews; i++) {
   1:     NSRect subviewFrame = [[[self subviews] objectAtIndex:i] frame];
   1:     if (NSContainsRect(subviewFrame, inRect))
   1:       return YES;
   1:   }
   1:   
   1:   return NO;
   1: }
   1: 
   1: 
3595: // Allows us to turn off setting up the clip region
   1: // before each drawRect. We already clip within gecko.
   1: - (BOOL)wantsDefaultClipping
   1: {
   1:   return NO;
   1: }
   1: 
   1: 
   1: #if USE_CLICK_HOLD_CONTEXTMENU
   1: //
   1: // -clickHoldCallback:
   1: //
   1: // called from a timer two seconds after a mouse down to see if we should display
   1: // a context menu (click-hold). |anEvent| is the original mouseDown event. If we're
   1: // still in that mouseDown by this time, put up the context menu, otherwise just
   1: // fuhgeddaboutit. |anEvent| has been retained by the OS until after this callback
   1: // fires so we're ok there.
   1: //
   1: // This code currently messes in a bunch of edge cases (bugs 234751, 232964, 232314)
   1: // so removing it until we get it straightened out.
   1: //
   1: - (void)clickHoldCallback:(id)theEvent;
   1: {
   1:   if( theEvent == [NSApp currentEvent] ) {
   1:     // we're still in the middle of the same mousedown event here, activate
   1:     // click-hold context menu by triggering the right mouseDown action.
   1:     NSEvent* clickHoldEvent = [NSEvent mouseEventWithType:NSRightMouseDown
   1:                                                   location:[theEvent locationInWindow]
   1:                                              modifierFlags:[theEvent modifierFlags]
   1:                                                  timestamp:[theEvent timestamp]
   1:                                               windowNumber:[theEvent windowNumber]
   1:                                                    context:[theEvent context]
   1:                                                eventNumber:[theEvent eventNumber]
   1:                                                 clickCount:[theEvent clickCount]
   1:                                                   pressure:[theEvent pressure]];
   1:     [self rightMouseDown:clickHoldEvent];
   1:   }
   1: }
   1: #endif
   1: 
   1: 
3574: // If gRollupWidget exists, mouse events (except for mouseDown events) that
3574: // happen over it should be rerouted to it if they've been sent elsewhere.
3574: // Returns 'true' if the event was rerouted, 'false' otherwise.  This is
3574: // needed when the user tries to navigate a context menu while keeping the
3574: // mouse-button down (left or right mouse button) -- the OS thinks this is a
3574: // dragging operation, so it sends events (mouseMoved and mouseUp) to the
3574: // window where the dragging operation started (the parent of the context
3574: // menu window).  It's also needed to work around a bizarre Apple bug -- if
3574: // (while a context menu is open) you move the mouse over another app's window
3574: // and then back over the context menu, mouseMoved events will be sent to the
3574: // window underneath the context menu.
3574: - (BOOL)maybeRerouteMouseEventToRollupWidget:(NSEvent *)anEvent
3574: {
3574:   if (!gRollupWidget)
3574:     return PR_FALSE;
3574: 
3574:   // Return PR_FALSE if we can't get ctxMenuWindow or if our window is already
3574:   // a context menu.
3574:   NSWindow *ctxMenuWindow = (NSWindow*) gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
3574:   if (!ctxMenuWindow || (mWindow == ctxMenuWindow))
3574:     return PR_FALSE;
3574: 
3574:   NSPoint windowEventLocation = [anEvent locationInWindow];
3574:   NSPoint screenEventLocation = [mWindow convertBaseToScreen:windowEventLocation];
3574:   if (!NSPointInRect(screenEventLocation, [ctxMenuWindow frame]))
3574:     return PR_FALSE;
3574: 
3574:   NSEventType type = [anEvent type];
3574:   NSPoint locationInCtxMenuWindow = [ctxMenuWindow convertScreenToBase:screenEventLocation];
3574:   NSEvent *newEvent = nil;
3574: 
3574:   // If anEvent is a mouseUp event, send an extra mouseDown event before
3574:   // sending a mouseUp event -- this is needed to support selection by
3574:   // dragging the mouse to a menu item and then releasing it.  We retain
3574:   // ctxMenuWindow in case it gets destroyed as a result of the extra
3574:   // mouseDown (and release it below).
3574:   if ((type == NSLeftMouseUp) || (type == NSRightMouseUp)) {
3574:     [ctxMenuWindow retain];
3574:     NSEventType extraEventType;
3574:     switch (type) {
3574:       case NSLeftMouseUp:
3574:         extraEventType = NSLeftMouseDown;
3574:         break;
3574:       case NSRightMouseUp:
3574:         extraEventType = NSRightMouseDown;
3574:         break;
3574:       default:
3574:         extraEventType = (NSEventType) 0;
3574:         break;
3574:     }
3574:     newEvent = [NSEvent mouseEventWithType:extraEventType
3574:                                   location:locationInCtxMenuWindow
3574:                              modifierFlags:[anEvent modifierFlags]
3574:                                  timestamp:GetCurrentEventTime()
3574:                               windowNumber:[ctxMenuWindow windowNumber]
3574:                                    context:nil
3574:                                eventNumber:0
3574:                                 clickCount:1
3574:                                   pressure:0.0];
3574:     [ctxMenuWindow sendEvent:newEvent];
3574:   }
3574: 
3574:   newEvent = [NSEvent mouseEventWithType:type
3574:                                 location:locationInCtxMenuWindow
3574:                            modifierFlags:[anEvent modifierFlags]
3574:                                timestamp:GetCurrentEventTime()
3574:                             windowNumber:[ctxMenuWindow windowNumber]
3574:                                  context:nil
3574:                              eventNumber:0
3574:                               clickCount:1
3574:                                 pressure:0.0];
3574:   [ctxMenuWindow sendEvent:newEvent];
3574: 
3574:   if ((type == NSLeftMouseUp) || (type == NSRightMouseUp))
3574:     [ctxMenuWindow release];
3574: 
3574:   return PR_TRUE;
3574: }
3574: 
3574: 
3574: + (BOOL)mouseEventIsOverRollupWidget:(NSEvent *)anEvent
3574: {
3574:   if (!gRollupWidget)
3574:     return PR_FALSE;
3574:   NSWindow *ctxMenuWindow = (NSWindow*) gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
3574:   if (!ctxMenuWindow)
3574:     return PR_FALSE;
3574:   NSPoint windowEventLocation = [anEvent locationInWindow];
3574:   NSPoint screenEventLocation = [[anEvent window] convertBaseToScreen:windowEventLocation];
3574:   return NSPointInRect(screenEventLocation, [ctxMenuWindow frame]);
3574: }
3574: 
3574: 
3574: // If we've just created a non-native context menu, we need to mark it as
3574: // such and let the OS (and other programs) know when it opens and closes
3574: // (this is how the OS knows to close other programs' context menus when
3574: // ours open).  We send the initial notification here, but others are sent
3574: // in nsCocoaWindow::Show().
3574: - (void)maybeInitContextMenuTracking
3574: {
3574:   if (!gRollupWidget)
3574:     return;
3574:   NSWindow *ctxMenuWindow = (NSWindow*)
3574:     gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
3574:   if (!ctxMenuWindow || ![ctxMenuWindow isKindOfClass:[PopupWindow class]])
3574:     return;
3574:   [[NSDistributedNotificationCenter defaultCenter]
3574:     postNotificationName:@"com.apple.HIToolbox.beginMenuTrackingNotification"
3574:                   object:@"org.mozilla.gecko.PopupWindow"];
3574:   [(PopupWindow*) ctxMenuWindow setIsContextMenu:YES];
3574: }
3574: 
3574: 
4842: - (nsChildView *)getGeckoChild
4842: {
4842:   return mGeckoChild;
4842: }
4842: 
4842: 
4842: // Browsers that use non-native context menus (e.g. Cocoa widgets Firefox as
4842: // opposed to Camino) need to postpone generating a context menu until after
4842: // the previous one (if one exists) has had a chance to close.  The reason why
4842: // is that, as of the fix for bmo bug 279703, non-native context menus are
4842: // hidden asynchronously (after a call to gRollupListener->Rollup()), using an
4842: // nsXULPopupHidingEvent.  If we don't asynchronously generate non-native
4842: // context menus, only the first control-click or right-click in a window will
4842: // display a context menu.  This change resolves bmo bug 389542.
4842: class nsNonNativeContextMenuEvent : public nsRunnable {
4842:   public:
4842:     nsNonNativeContextMenuEvent(ChildView *baseView, NSEvent *triggerEvent) {
4842:       mBaseView = [baseView retain];
4842:       mTriggerEvent = [triggerEvent retain];
4842:     }
4842: 
4842:     virtual ~nsNonNativeContextMenuEvent() {
4842:       [mBaseView release];
4842:       [mTriggerEvent release];
4842:     }
4842: 
4842:     NS_IMETHOD Run() {
4842:       if (!mBaseView || !mTriggerEvent)
4842:         return NS_ERROR_FAILURE;
4842:       nsChildView *geckoChild = [mBaseView getGeckoChild];
4842:       if (!geckoChild)
4842:         return NS_ERROR_FAILURE;
4842:       nsMouseEvent geckoEvent(PR_TRUE, NS_CONTEXTMENU, nsnull, nsMouseEvent::eReal);
4842:       [mBaseView convertCocoaMouseEvent:mTriggerEvent toGeckoEvent:&geckoEvent];
4842:       geckoEvent.button = nsMouseEvent::eRightButton;
4842:       geckoChild->DispatchMouseEvent(geckoEvent);
4842:       [mBaseView maybeInitContextMenuTracking];
4842:       return NS_OK;
4842:     }
4842: 
4842:   private:
4842:     ChildView *mBaseView;
4842:     NSEvent *mTriggerEvent;
4842: };
4842: 
4842: 
   1: - (void)mouseDown:(NSEvent *)theEvent
   1: {
   1:   // Make sure this view is not in the rollup widget. The fastest way to do this
   1:   // is by comparing native window pointers. Also don't roll up if we just put
   1:   // the popup up in an earlier menuForEvent: event.
   1:   if (mLastMenuForEventEvent != theEvent && gRollupWidget != nsnull) {
   1:     NSWindow *ourNativeWindow = [self nativeWindow];
   1:     NSWindow *rollupNativeWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
   1:     if (ourNativeWindow != rollupNativeWindow) {
   1:       // roll up any popups
   1:       if (gRollupListener != nsnull) {
   1:         gRollupListener->Rollup();
   1:         // If we rolled up a popup, we don't want to pass the click down to gecko.
   1:         // This happens e.g. when you click a popupmenubutton (the menu opens), then click 
   1:         // on the popupmenubutton a second time, which should hide the menu.
   1:         return;
   1:       }
   1:     }
   1:   }
   1:   
   1:   unsigned int modifierFlags = [theEvent modifierFlags];
   1:   
   1:   // if the command and alt keys are held down, initiate hand scrolling
   1:   if ([ChildView areHandScrollModifiers:modifierFlags]) {
   1:     [self startHandScroll: theEvent];
   1:     // needed to change the focus, among other things, since we don't
   1:     // get to do that below.
   1:     [super mouseDown:theEvent];
   1:     return; // do not pass this mousedown event to gecko
   1:   }
   1: 
   1: #if USE_CLICK_HOLD_CONTEXTMENU
   1:   // fire off timer to check for click-hold after two seconds. retains |theEvent|
   1:   [self performSelector:@selector(clickHoldCallback:) withObject:theEvent afterDelay:2.0];
   1: #endif
   1: 
 656:   // in order to send gecko events we'll need a gecko widget
 656:   if (!mGeckoChild)
 656:     return;
 656: 
   1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
   1:   geckoEvent.clickCount = [theEvent clickCount];
   1:   if (modifierFlags & NSControlKeyMask)
   1:     geckoEvent.button = nsMouseEvent::eRightButton;
   1:   else
   1:     geckoEvent.button = nsMouseEvent::eLeftButton;
   1: 
2315:   // create native EventRecord for use by plugins
   1:   EventRecord macEvent;
   1:   macEvent.what = mouseDown;
   1:   macEvent.message = 0;
   1:   macEvent.when = ::TickCount();
   1:   ::GetGlobalMouse(&macEvent.where);
   1:   macEvent.modifiers = GetCurrentKeyModifiers();
   1:   geckoEvent.nativeMsg = &macEvent;
   1: 
   1:   mGeckoChild->DispatchMouseEvent(geckoEvent);
   1: 
   1:   // XXX maybe call markedTextSelectionChanged:client: here?
   1: }
   1: 
   1: 
   1: - (void)mouseUp:(NSEvent *)theEvent
   1: {
   1:   if (mInHandScroll) {
   1:     [self updateHandScroll:theEvent];
   1:     [self stopHandScroll:theEvent];
   1:     return;
   1:   }
2315: 
3574:   if ([self maybeRerouteMouseEventToRollupWidget:theEvent])
3574:     return;
3574: 
2315:   if (!mGeckoChild)
2315:     return;
2315: 
   1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
2315: 
2315:   // create native EventRecord for use by plugins
   1:   EventRecord macEvent;
   1:   macEvent.what = mouseUp;
   1:   macEvent.message = 0;
   1:   macEvent.when = ::TickCount();
   1:   ::GetGlobalMouse(&macEvent.where);
   1:   macEvent.modifiers = GetCurrentKeyModifiers();
   1:   geckoEvent.nativeMsg = &macEvent;
   1: 
   1:   mGeckoChild->DispatchMouseEvent(geckoEvent);
   1: }
   1: 
   1: 
5762: // sends a mouse enter or exit event into gecko
5762: static nsEventStatus SendGeckoMouseEnterOrExitEvent(PRBool isTrusted,
 455:                                                     PRUint32 msg,
 455:                                                     nsIWidget *widget,
 455:                                                     nsMouseEvent::reasonType aReason,
 455:                                                     NSPoint* localEventLocation)
 455: {
 455:   if (!widget || !localEventLocation)
 455:     return nsEventStatus_eIgnore;
 455: 
 455:   nsMouseEvent event(isTrusted, msg, widget, aReason);
 455:   event.refPoint.x = nscoord((PRInt32)localEventLocation->x);
 455:   event.refPoint.y = nscoord((PRInt32)localEventLocation->y);
2315: 
5762:   EventRecord macEvent;
5762:   macEvent.what = adjustCursorEvent;
5762:   macEvent.message = 0;
5762:   macEvent.when = ::TickCount();
5762:   ::GetGlobalMouse(&macEvent.where);
5762:   macEvent.modifiers = GetCurrentKeyModifiers();
5762:   event.nativeMsg = &macEvent;
5762: 
2315:   nsEventStatus status;
 455:   widget->DispatchEvent(&event, status);
 455:   return status;
 455: }
 455: 
 455: 
   1: - (void)mouseMoved:(NSEvent*)theEvent
   1: {
 455:   NSPoint windowEventLocation = [theEvent locationInWindow];
 455:   NSPoint screenEventLocation = [mWindow convertBaseToScreen:windowEventLocation];
 455:   NSPoint viewEventLocation = [self convertPoint:windowEventLocation fromView:nil];
 455: 
3574:   // Installing a mouseMoved handler on the EventMonitor target (in
3574:   // nsToolkit::RegisterForAllProcessMouseEvents()) means that some of the
3574:   // events received here come from other processes.  For this reason we need
3574:   // to avoid processing them unless they're over a context menu -- otherwise
3574:   // tooltips and other mouse-hover effects will "work" even when our app
3574:   // doesn't have the focus.
3574:   if (![NSApp isActive] && ![ChildView mouseEventIsOverRollupWidget:theEvent]) {
3574:     if (sLastViewEntered) {
3574:       nsIWidget* lastViewEnteredWidget = [(NSView<mozView>*)sLastViewEntered widget];
5762:       SendGeckoMouseEnterOrExitEvent(PR_TRUE, NS_MOUSE_EXIT, lastViewEnteredWidget, nsMouseEvent::eReal, &viewEventLocation);
3574:       sLastViewEntered = nil;
3574:     }
3574:     return;
3574:   }
3574: 
3574:   if ([self maybeRerouteMouseEventToRollupWidget:theEvent])
3574:     return;
3574: 
3574:   // If this is a popup window and the event is not over it, then we may want
3574:   // to send the event to another window.  (Even with bmo bug 378645 fixed
3574:   // ("popup windows still receive native mouse move events after being
3574:   // closed"), the following is still needed to deal with mouseMoved events
3574:   // that happen over other objects while a context menu is up (and has the
3574:   // focus).)
 766:   if ([mWindow level] == NSPopUpMenuWindowLevel &&
 766:       !NSPointInRect(screenEventLocation, [mWindow frame])) {
 766:     NSWindow* otherWindowForEvent = nil;
 766:     
 766:     // look for another popup window that is under the mouse
   1:     NSArray* appWindows = [NSApp windows];
   1:     unsigned int appWindowsCount = [appWindows count];
   1:     for (unsigned int i = 0; i < appWindowsCount; i++) {
   1:       NSWindow* currentWindow = [appWindows objectAtIndex:i];
 766:       if (currentWindow != mWindow &&
   1:           [currentWindow level] == NSPopUpMenuWindowLevel &&
   1:           [currentWindow isVisible] &&
 766:           NSPointInRect(screenEventLocation, [currentWindow frame])) {
 766:         // found another popup window to send the event to
 766:         otherWindowForEvent = currentWindow;
 766:         break;
 766:       }
 766:     }
 766:     
 766:     if (!otherWindowForEvent) {
 766:       // If the event is outside this active popup window but not over another popup window,
 766:       // see if the event is over the main window and route it there if so.
 766:       NSWindow* mainWindow = [NSApp mainWindow];
 766:       if (NSPointInRect(screenEventLocation, [mainWindow frame])) {
 766:         otherWindowForEvent = mainWindow;
 766:       }
 766:     }
 766:     
 766:     if (otherWindowForEvent) {
 766:       NSPoint locationInOtherWindow = [otherWindowForEvent convertScreenToBase:screenEventLocation];
 766:       NSView* targetView = [[otherWindowForEvent contentView] hitTest:locationInOtherWindow];
 766:       if (targetView) {
   1:         NSEvent* newEvent = [NSEvent mouseEventWithType:NSMouseMoved
 455:                                                location:locationInOtherWindow
   1:                                           modifierFlags:[theEvent modifierFlags]
   1:                                               timestamp:[theEvent timestamp]
 766:                                            windowNumber:[otherWindowForEvent windowNumber]
   1:                                                 context:nil
   1:                                             eventNumber:[theEvent eventNumber]
   1:                                              clickCount:0
   1:                                                pressure:0.0];
 766:         [targetView mouseMoved:newEvent];
 766:       }
   1:       return;
   1:     }
 766:     // at this point we mimic GTK2 by sending the event to our popup window if we
 766:     // couldn't find an alternative
   1:   }
   1: 
 455:   NSView* view = [[mWindow contentView] hitTest:windowEventLocation];
 455:   if (view) {
 455:     // we shouldn't handle this if the hit view is not us
   1:     if (view != (NSView*)self) {
   1:       [view mouseMoved:theEvent];
   1:       return;      
   1:     }
 455:   }
 455:   else {
 455:     // If the hit test returned nil then the mouse isn't over the window. If thse mouse
 455:     // exited the window then send mouse exit to the last view in the window it was over.
 455:     if (sLastViewEntered) {
 455:       // NSLog(@"sending NS_MOUSE_EXIT event with point %f,%f\n", viewEventLocation.x, viewEventLocation.y);
 455:       nsIWidget* lastViewEnteredWidget = [(NSView<mozView>*)sLastViewEntered widget];
5762:       SendGeckoMouseEnterOrExitEvent(PR_TRUE, NS_MOUSE_EXIT, lastViewEnteredWidget, nsMouseEvent::eReal, &viewEventLocation);
 455:       sLastViewEntered = nil;      
 455:     }
 455:     return;
 455:   }
 455: 
 455:   // At this point we are supposed to handle this event. If we were not the last view entered, then
 455:   // we should send an exit event to the last view entered and an enter event to ourselves.  
2462:   if (!mGeckoChild)
2462:     return;
2462: 
 455:   if (sLastViewEntered != self) {
2462:     if (sLastViewEntered) {
 455:       // NSLog(@"sending NS_MOUSE_EXIT event with point %f,%f\n", viewEventLocation.x, viewEventLocation.y);
 455:       nsIWidget* lastViewEnteredWidget = [(NSView<mozView>*)sLastViewEntered widget];
5762:       SendGeckoMouseEnterOrExitEvent(PR_TRUE, NS_MOUSE_EXIT, lastViewEnteredWidget, nsMouseEvent::eReal, &viewEventLocation);
 455:     }
 455: 
 455:     // NSLog(@"sending NS_MOUSE_ENTER event with point %f,%f\n", viewEventLocation.x, viewEventLocation.y);
5762:     SendGeckoMouseEnterOrExitEvent(PR_TRUE, NS_MOUSE_ENTER, mGeckoChild, nsMouseEvent::eReal, &viewEventLocation);
 455: 
 455:     // mark this view as the last view entered
 455:     sLastViewEntered = (NSView*)self;
 455: 
 455:     // checks to see if we should change to the hand cursor
 455:     [self setHandScrollCursor:theEvent];
 455:   }
   1: 
   1:   // check if we are in a hand scroll or if the user
   1:   // has command and alt held down; if so,  we do not want
   1:   // gecko messing with the cursor.
   1:   if ([ChildView areHandScrollModifiers:[theEvent modifierFlags]])
   1:     return;
   1: 
   1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
2315: 
2315:   // create native EventRecord for use by plugins
   1:   EventRecord macEvent;
5762:   macEvent.what = adjustCursorEvent;
   1:   macEvent.message = 0;
   1:   macEvent.when = ::TickCount();
   1:   ::GetGlobalMouse(&macEvent.where);
   1:   macEvent.modifiers = GetCurrentKeyModifiers();
   1:   geckoEvent.nativeMsg = &macEvent;
   1: 
   1:   mGeckoChild->DispatchMouseEvent(geckoEvent);
   1: }
   1: 
   1: 
   1: - (void)mouseDragged:(NSEvent*)theEvent
   1: {
3574:   if ([self maybeRerouteMouseEventToRollupWidget:theEvent])
3574:     return;
3574: 
2462:   if (!mGeckoChild)
2462:     return;
2462: 
   1:   // if the handscroll flag is set, steal this event
   1:   if (mInHandScroll) {
   1:     [self updateHandScroll:theEvent];
   1:     return;
   1:   }
   1: 
6245:   gLastDragView = self;
6245:   gLastDragEvent = theEvent;
   1: 
   1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
2315: 
2315:   // create native EventRecord for use by plugins
   1:   EventRecord macEvent;
   1:   macEvent.what = nullEvent;
   1:   macEvent.message = 0;
   1:   macEvent.when = ::TickCount();
   1:   ::GetGlobalMouse(&macEvent.where);
   1:   macEvent.modifiers = btnState | GetCurrentKeyModifiers();
   1:   geckoEvent.nativeMsg = &macEvent;
   1: 
   1:   mGeckoChild->DispatchMouseEvent(geckoEvent);    
   1: 
6245:   gLastDragView = nil;
6245:   gLastDragEvent = nil;
   1:   // XXX maybe call markedTextSelectionChanged:client: here?
   1: }
   1: 
   1: 
   1: - (void)rightMouseDown:(NSEvent *)theEvent
   1: {  
   1:   // Make sure this view is not in the rollup widget. The fastest way to do this
   1:   // is by comparing native window pointers. Also don't roll up if we just put
   1:   // the popup up in an earlier menuForEvent: event.
   1:   if (mLastMenuForEventEvent != theEvent && gRollupWidget != nsnull) {
   1:     NSWindow *ourNativeWindow = [self nativeWindow];
   1:     NSWindow *rollupNativeWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
   1:     if (ourNativeWindow != rollupNativeWindow) {
   1:       // roll up any popups
   1:       if (gRollupListener != nsnull)
   1:         gRollupListener->Rollup();
   1:     }
   1:   }
   1: 
2462:   if (!mGeckoChild)
2462:     return;
2462:   
   1:   // The right mouse went down, fire off a right mouse down event to gecko
   1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
   1:   geckoEvent.button = nsMouseEvent::eRightButton;
2315:   geckoEvent.clickCount = [theEvent clickCount];
2315: 
2315:   // create native EventRecord for use by plugins
   1:   EventRecord macEvent;
   1:   macEvent.what = mouseDown;
   1:   macEvent.message = 0;
   1:   macEvent.when = ::TickCount();
   1:   ::GetGlobalMouse(&macEvent.where);
   1:   macEvent.modifiers = controlKey;  // fake a context menu click
   1:   geckoEvent.nativeMsg = &macEvent;
   1: 
   1:   PRBool handled = mGeckoChild->DispatchMouseEvent(geckoEvent);
   1:   if (!handled)
   1:     [super rightMouseDown:theEvent]; // let the superview do context menu stuff
   1: }
   1: 
   1: 
   1: - (void)rightMouseUp:(NSEvent *)theEvent
   1: {
3574:   if ([self maybeRerouteMouseEventToRollupWidget:theEvent])
3574:     return;
3574: 
2462:   if (!mGeckoChild)
2462:     return;
2462:   
   1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
   1:   geckoEvent.button = nsMouseEvent::eRightButton;
2315:   geckoEvent.clickCount = [theEvent clickCount];
2315: 
2315:   // create native EventRecord for use by plugins
   1:   EventRecord macEvent;
   1:   macEvent.what = mouseUp;
   1:   macEvent.message = 0;
   1:   macEvent.when = ::TickCount();
   1:   ::GetGlobalMouse(&macEvent.where);
   1:   macEvent.modifiers = controlKey;  // fake a context menu click
   1:   geckoEvent.nativeMsg = &macEvent;
   1: 
   1:   PRBool handled = mGeckoChild->DispatchMouseEvent(geckoEvent);
   1:   if (!handled)
   1:     [super rightMouseUp:theEvent];
   1: }
   1: 
   1: 
3574: - (void)rightMouseDragged:(NSEvent*)theEvent
3574: {
3574:   if ([self maybeRerouteMouseEventToRollupWidget:theEvent])
3574:     return;
3574: 
3574:   if (!mGeckoChild)
3574:     return;
3574: 
3574:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
3574:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
3574:   geckoEvent.button = nsMouseEvent::eRightButton;
3574: 
3574:   // send event into Gecko by going directly to the
3574:   // the widget.
3574:   mGeckoChild->DispatchMouseEvent(geckoEvent);
3574: }
3574: 
3574: 
   1: - (void)otherMouseDown:(NSEvent *)theEvent
   1: {
3574:   // If our view isn't the rollup widget, roll up any context menu that may
3574:   // currently be open -- otherwise a disfunctional context menu will appear
3574:   // alongside the autoscroll popup (if autoscroll is enabled).
3574:   if (gRollupWidget && gRollupListener) {
3574:     NSWindow *ourNativeWindow = [self nativeWindow];
3574:     NSWindow *rollupNativeWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
3574:     if (ourNativeWindow != rollupNativeWindow)
3574:       gRollupListener->Rollup();
3574:   }
3574: 
2462:   if (!mGeckoChild)
2462:     return;
2462: 
   1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_DOWN, nsnull, nsMouseEvent::eReal);
2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
2315:   geckoEvent.button = nsMouseEvent::eMiddleButton;
   1:   geckoEvent.clickCount = [theEvent clickCount];
2315: 
   1:   mGeckoChild->DispatchMouseEvent(geckoEvent);
   1: }
   1: 
   1: 
   1: - (void)otherMouseUp:(NSEvent *)theEvent
   1: {
2462:   if (!mGeckoChild)
2462:     return;
2462: 
   1:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_BUTTON_UP, nsnull, nsMouseEvent::eReal);
2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
   1:   geckoEvent.button = nsMouseEvent::eMiddleButton;
   1: 
   1:   mGeckoChild->DispatchMouseEvent(geckoEvent);
   1: }
   1: 
   1: 
3574: - (void)otherMouseDragged:(NSEvent*)theEvent
3574: {
3574:   if (!mGeckoChild)
3574:     return;
3574: 
3574:   nsMouseEvent geckoEvent(PR_TRUE, NS_MOUSE_MOVE, nsnull, nsMouseEvent::eReal);
3574:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
3574:   geckoEvent.button = nsMouseEvent::eMiddleButton;
3574: 
3574:   // send event into Gecko by going directly to the
3574:   // the widget.
3574:   mGeckoChild->DispatchMouseEvent(geckoEvent);
3574: }
3574: 
3574: 
   1: // Handle an NSScrollWheel event for a single axis only.
   1: -(void)scrollWheel:(NSEvent*)theEvent forAxis:(enum nsMouseScrollEvent::nsMouseScrollFlags)inAxis
   1: {
2462:   if (!mGeckoChild)
2462:     return;
2462: 
   1:   float scrollDelta;
   1: 
   1:   if (inAxis & nsMouseScrollEvent::kIsVertical)
   1:     scrollDelta = -[theEvent deltaY];
   1:   else if (inAxis & nsMouseScrollEvent::kIsHorizontal)
   1:     scrollDelta = -[theEvent deltaX];
   1:   else
   1:     // Caller screwed up
   1:     return;
   1: 
   1:   if (scrollDelta == 0)
   1:     // No sense in firing off a Gecko event.  Note that as of 10.4 Tiger,
   1:     // a single NSScrollWheel event might result in deltaX = deltaY = 0.
   1:     return;
   1:   
   1:   nsMouseScrollEvent geckoEvent(PR_TRUE, NS_MOUSE_SCROLL, nsnull);
2315:   [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
   1:   geckoEvent.scrollFlags |= inAxis;
   1: 
   1:   // Gecko only understands how to scroll by an integer value.  Using floor
   1:   // and ceil is better than truncating the fraction, especially when
   1:   // |delta| < 1.
   1:   if (scrollDelta < 0)
   1:     geckoEvent.delta = (PRInt32)floorf(scrollDelta);
   1:   else
   1:     geckoEvent.delta = (PRInt32)ceilf(scrollDelta);
   1: 
   1:   mGeckoChild->DispatchWindowEvent(geckoEvent);
   1: 
   1:   // dispatch scroll wheel carbon event for plugins
   1:   {
   1:     EventRef theEvent;
   1:     OSStatus err = ::MacCreateEvent(NULL,
   1:                           kEventClassMouse,
   1:                           kEventMouseWheelMoved,
   1:                           TicksToEventTime(TickCount()),
   1:                           kEventAttributeUserEvent,
   1:                           &theEvent);
   1:     if (err == noErr) {
   1:       EventMouseWheelAxis axis;
   1:       if (inAxis & nsMouseScrollEvent::kIsVertical)
   1:         axis = kEventMouseWheelAxisY;
   1:       else if (inAxis & nsMouseScrollEvent::kIsHorizontal)
   1:         axis = kEventMouseWheelAxisX;
   1:       
   1:       SetEventParameter(theEvent,
   1:                             kEventParamMouseWheelAxis,
   1:                             typeMouseWheelAxis,
   1:                             sizeof(EventMouseWheelAxis),
   1:                             &axis);
   1: 
   1:       SInt32 delta = (SInt32)-geckoEvent.delta;
   1:       SetEventParameter(theEvent,
   1:                             kEventParamMouseWheelDelta,
   1:                             typeLongInteger,
   1:                             sizeof(SInt32),
   1:                             &delta);
   1: 
   1:       Point mouseLoc;
   1:       ::GetGlobalMouse(&mouseLoc);
   1:       SetEventParameter(theEvent,
   1:                             kEventParamMouseLocation,
   1:                             typeQDPoint,
   1:                             sizeof(Point),
   1:                             &mouseLoc);
   1:       
1016:       ::SendEventToEventTarget(theEvent, GetWindowEventTarget((WindowRef)[[self window] windowRef]));
   1:       ReleaseEvent(theEvent);
   1:     }
   1:   }
   1: }
   1: 
   1: 
   1: -(void)scrollWheel:(NSEvent*)theEvent
   1: {
   1:   // close popups if we're supposed to...
   1:   if (gRollupListener && gRollupWidget &&
   1:       [self window] != gRollupWidget->GetNativeData(NS_NATIVE_WINDOW)) {
   1:     PRBool rollup = PR_FALSE;
   1:     gRollupListener->ShouldRollupOnMouseWheelEvent(&rollup);
4358:     if (rollup) {
   1:       gRollupListener->Rollup();
4358:     } else {
4358:       // Don't pass this event to Gecko if we're not supposed to close the
4358:       // popup.  Otherwise the background window will scroll when a custom
4358:       // context menu or the autoscroll popup is open (and the mouse isn't
4358:       // over the popup) -- which doesn't seem right.  This change resolves
4358:       // bmo bug 344367.
4358:       return;
4358:     }
   1:   }
   1:   
   1:   // It's possible for a single NSScrollWheel event to carry both useful
   1:   // deltaX and deltaY, for example, when the "wheel" is a trackpad.
   1:   // NSMouseScrollEvent can only carry one axis at a time, so the system
   1:   // event will be split into two Gecko events if necessary.
   1:   [self scrollWheel:theEvent forAxis:nsMouseScrollEvent::kIsVertical];
   1:   [self scrollWheel:theEvent forAxis:nsMouseScrollEvent::kIsHorizontal];
   1: }
   1: 
   1: 
   1: -(NSMenu*)menuForEvent:(NSEvent*)theEvent
   1: {
2462:   if (!mGeckoChild || [self isPluginView])
   1:     return nil;
   1: 
4842:   // Roll up a non-native context menu if one is open and we're not it.  We do
4842:   // this check here (as well as in mouseDown: and rightMouseDown:) because
4842:   // sometimes menuForEvent: is called before the associated mouse-down
4842:   // method is called.
4842:   if (gRollupWidget) {
4842:     NSWindow *ourNativeWindow = [self nativeWindow];
4842:     NSWindow *rollupNativeWindow = (NSWindow*)gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
4842:     if (ourNativeWindow != rollupNativeWindow) {
4842:       // roll up any popups
4842:       if (gRollupListener != nsnull)
4842:         gRollupListener->Rollup();
4842:     }
4842:   }
4842:   
   1:   [mLastMenuForEventEvent release];
   1:   mLastMenuForEventEvent = [theEvent retain];
   1:   
4842:   // If we're running in a browser that (like Camino) uses native context
4842:   // menus, fire a context menu event into Gecko here.  Otherwise (if we're
4842:   // using non-native context menus) we need to open the context menu
4842:   // asynchronously.
4842:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
4842:   if (prefs) {
4842:     PRBool useNativeContextMenus;
4842:     nsresult rv = prefs->GetBoolPref("ui.use_native_popup_windows", &useNativeContextMenus);
4842:     if (NS_SUCCEEDED(rv) && useNativeContextMenus) {
   1:       nsMouseEvent geckoEvent(PR_TRUE, NS_CONTEXTMENU, nsnull, nsMouseEvent::eReal);
2315:       [self convertCocoaMouseEvent:theEvent toGeckoEvent:&geckoEvent];
   1:       geckoEvent.button = nsMouseEvent::eRightButton;
   1:       mGeckoChild->DispatchMouseEvent(geckoEvent);
4842:     } else {
4842:       nsIRunnable *contextMenuEvent = new nsNonNativeContextMenuEvent(self, theEvent);
4842:       NS_DispatchToCurrentThread(contextMenuEvent);
4842:     }
4842:   }
3574:   
   1:   // Go up our view chain to fetch the correct menu to return.
   1:   return [self contextMenu];
   1: }
   1: 
   1: 
   1: - (NSMenu*)contextMenu
   1: {
   1:   NSView* superView = [self superview];
   1:   if ([superView respondsToSelector:@selector(contextMenu)])
   1:     return [(NSView<mozView>*)superView contextMenu];
   1: 
   1:   return nil;
   1: }
   1: 
   1: 
   1: - (TopLevelWindowData*)ensureWindowData
   1: {
   1:   WindowDataMap* windowMap = [WindowDataMap sharedWindowDataMap];
   1: 
   1:   TopLevelWindowData* windowData = [windowMap dataForWindow:mWindow];
   1:   if (mWindow && !windowData)
   1:   {
   1:     windowData = [[TopLevelWindowData alloc] initWithWindow:mWindow];
   1:     [windowMap setData:windowData forWindow:mWindow]; // takes ownership
   1:     [windowData release];
   1:   }
   1:   return windowData;
   1: }
   1: 
   1: 
   1: static PRBool ConvertUnicodeToCharCode(PRUnichar inUniChar, unsigned char* outChar)
   1: {
   1:   UnicodeToTextInfo converterInfo;
   1:   TextEncoding      systemEncoding;
   1:   Str255            convertedString;
   1:   OSStatus          err;
   1:   
   1:   *outChar = 0;
   1:   
   1:   err = ::UpgradeScriptInfoToTextEncoding(smSystemScript, kTextLanguageDontCare, kTextRegionDontCare, NULL, &systemEncoding);
   1:   if (err != noErr)
   1:     return PR_FALSE;
   1:   
   1:   err = ::CreateUnicodeToTextInfoByEncoding(systemEncoding, &converterInfo);
   1:   if (err != noErr)
   1:     return PR_FALSE;
   1:   
   1:   err = ::ConvertFromUnicodeToPString(converterInfo, sizeof(PRUnichar), &inUniChar, convertedString);
   1:   if (err != noErr)
   1:     return PR_FALSE;
   1: 
   1:   *outChar = convertedString[1];
   1:   ::DisposeUnicodeToTextInfo(&converterInfo);
   1:   return PR_TRUE;
   1: }
   1: 
   1: 
   1: static void ConvertCocoaKeyEventToMacEvent(NSEvent* cocoaEvent, EventRecord& macEvent, PRUint32 keyType = 0)
   1: {
   1:     UInt32 charCode = 0;
   1:     if ([cocoaEvent type] == NSFlagsChanged) {
   1:       macEvent.what = keyType == NS_KEY_DOWN ? keyDown : keyUp;
   1:     } else {
   1:       charCode = [[cocoaEvent characters] characterAtIndex:0];
   1:       if ([cocoaEvent type] == NSKeyDown)
   1:         macEvent.what = [cocoaEvent isARepeat] ? autoKey : keyDown;
   1:       else
   1:         macEvent.what = keyUp;
   1:     }
   1: 
   1:     if (charCode >= 0x0080) {
   1:         switch (charCode) {
   1:         case NSUpArrowFunctionKey:
   1:             charCode = kUpArrowCharCode;
   1:             break;
   1:         case NSDownArrowFunctionKey:
   1:             charCode = kDownArrowCharCode;
   1:             break;
   1:         case NSLeftArrowFunctionKey:
   1:             charCode = kLeftArrowCharCode;
   1:             break;
   1:         case NSRightArrowFunctionKey:
   1:             charCode = kRightArrowCharCode;
   1:             break;
   1:         default:
   1:             unsigned char convertedCharCode;
   1:             if (ConvertUnicodeToCharCode(charCode, &convertedCharCode))
   1:               charCode = convertedCharCode;
   1:             //NSLog(@"charcode is %d, converted to %c, char is %@", charCode, convertedCharCode, [cocoaEvent characters]);
   1:             break;
   1:         }
   1:     }
   1:     macEvent.message = (charCode & 0x00FF) | ([cocoaEvent keyCode] << 8);
   1:     macEvent.when = ::TickCount();
   1:     ::GetGlobalMouse(&macEvent.where);
   1:     macEvent.modifiers = ::GetCurrentKeyModifiers();
   1: }
   1: 
   1: // Key code constants
   1: enum
   1: {
   1:   kEscapeKeyCode      = 0x35,
   1:   kCommandKeyCode     = 0x37,
   1:   kShiftKeyCode       = 0x38,
   1:   kCapsLockKeyCode    = 0x39,
   1:   kControlKeyCode     = 0x3B,
   1:   kOptionkeyCode      = 0x3A, // both left and right option keys
   1:   kClearKeyCode       = 0x47,
   1:   
   1:   // function keys
   1:   kF1KeyCode          = 0x7A,
   1:   kF2KeyCode          = 0x78,
   1:   kF3KeyCode          = 0x63,
   1:   kF4KeyCode          = 0x76,
   1:   kF5KeyCode          = 0x60,
   1:   kF6KeyCode          = 0x61,
   1:   kF7KeyCode          = 0x62,
   1:   kF8KeyCode          = 0x64,
   1:   kF9KeyCode          = 0x65,
   1:   kF10KeyCode         = 0x6D,
   1:   kF11KeyCode         = 0x67,
   1:   kF12KeyCode         = 0x6F,
   1:   kF13KeyCode         = 0x69,
   1:   kF14KeyCode         = 0x6B,
   1:   kF15KeyCode         = 0x71,
   1:   
   1:   kPrintScreenKeyCode = kF13KeyCode,
   1:   kScrollLockKeyCode  = kF14KeyCode,
   1:   kPauseKeyCode       = kF15KeyCode,
   1:   
   1:   // keypad
   1:   kKeypad0KeyCode     = 0x52,
   1:   kKeypad1KeyCode     = 0x53,
   1:   kKeypad2KeyCode     = 0x54,
   1:   kKeypad3KeyCode     = 0x55,
   1:   kKeypad4KeyCode     = 0x56,
   1:   kKeypad5KeyCode     = 0x57,
   1:   kKeypad6KeyCode     = 0x58,
   1:   kKeypad7KeyCode     = 0x59,
   1:   kKeypad8KeyCode     = 0x5B,
   1:   kKeypad9KeyCode     = 0x5C,
   1: 
2959: // The following key codes are not defined until Mac OS X 10.5
2959: #if MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_4
2959:   kVK_ANSI_1          = 0x12,
2959:   kVK_ANSI_2          = 0x13,
2959:   kVK_ANSI_3          = 0x14,
2959:   kVK_ANSI_4          = 0x15,
2959:   kVK_ANSI_5          = 0x17,
2959:   kVK_ANSI_6          = 0x16,
2959:   kVK_ANSI_7          = 0x1A,
2959:   kVK_ANSI_8          = 0x1C,
2959:   kVK_ANSI_9          = 0x19,
2959:   kVK_ANSI_0          = 0x1D,
2959: #endif
2959: 
   1:   kKeypadMultiplyKeyCode  = 0x43,
   1:   kKeypadAddKeyCode       = 0x45,
   1:   kKeypadSubtractKeyCode  = 0x4E,
   1:   kKeypadDecimalKeyCode   = 0x41,
   1:   kKeypadDivideKeyCode    = 0x4B,
   1:   kKeypadEqualsKeyCode    = 0x51, // no correpsonding gecko key code
   1:   kEnterKeyCode           = 0x4C,
   1:   kReturnKeyCode          = 0x24,
   1:   kPowerbookEnterKeyCode  = 0x34, // Enter on Powerbook's keyboard is different
   1:   
   1:   kInsertKeyCode          = 0x72, // also help key
   1:   kDeleteKeyCode          = 0x75, // also forward delete key
   1:   kTabKeyCode             = 0x30,
   1:   kBackspaceKeyCode       = 0x33,
   1:   kHomeKeyCode            = 0x73, 
   1:   kEndKeyCode             = 0x77,
   1:   kPageUpKeyCode          = 0x74,
   1:   kPageDownKeyCode        = 0x79,
   1:   kLeftArrowKeyCode       = 0x7B,
   1:   kRightArrowKeyCode      = 0x7C,
   1:   kUpArrowKeyCode         = 0x7E,
   1:   kDownArrowKeyCode       = 0x7D
   1: };
   1: 
   1: 
   1: static PRUint32 ConvertMacToGeckoKeyCode(UInt32 keyCode, nsKeyEvent* aKeyEvent, NSString* characters)
   1: {
   1:   PRUint32 geckoKeyCode = 0;
   1:   PRUint8 charCode = 0;
   1:   if ([characters length])
   1:     charCode = [characters characterAtIndex: 0];
   1: 
   1:   switch (keyCode)
   1:   {
   1:     // modifiers. We don't get separate events for these
   1:     case kEscapeKeyCode:        geckoKeyCode = NS_VK_ESCAPE;         break;
   1:     case kCommandKeyCode:       geckoKeyCode = NS_VK_META;           break;
   1:     case kShiftKeyCode:         geckoKeyCode = NS_VK_SHIFT;          break;
   1:     case kCapsLockKeyCode:      geckoKeyCode = NS_VK_CAPS_LOCK;      break;
   1:     case kControlKeyCode:       geckoKeyCode = NS_VK_CONTROL;        break;
   1:     case kOptionkeyCode:        geckoKeyCode = NS_VK_ALT;            break;
   1:     case kClearKeyCode:         geckoKeyCode = NS_VK_CLEAR;          break;
   1: 
   1:     // function keys
   1:     case kF1KeyCode:            geckoKeyCode = NS_VK_F1;             break;
   1:     case kF2KeyCode:            geckoKeyCode = NS_VK_F2;             break;
   1:     case kF3KeyCode:            geckoKeyCode = NS_VK_F3;             break;
   1:     case kF4KeyCode:            geckoKeyCode = NS_VK_F4;             break;
   1:     case kF5KeyCode:            geckoKeyCode = NS_VK_F5;             break;
   1:     case kF6KeyCode:            geckoKeyCode = NS_VK_F6;             break;
   1:     case kF7KeyCode:            geckoKeyCode = NS_VK_F7;             break;
   1:     case kF8KeyCode:            geckoKeyCode = NS_VK_F8;             break;
   1:     case kF9KeyCode:            geckoKeyCode = NS_VK_F9;             break;
   1:     case kF10KeyCode:           geckoKeyCode = NS_VK_F10;            break;
   1:     case kF11KeyCode:           geckoKeyCode = NS_VK_F11;            break;
   1:     case kF12KeyCode:           geckoKeyCode = NS_VK_F12;            break;
   1:     // case kF13KeyCode:           geckoKeyCode = NS_VK_F13;            break;    // clash with the 3 below
   1:     // case kF14KeyCode:           geckoKeyCode = NS_VK_F14;            break;
   1:     // case kF15KeyCode:           geckoKeyCode = NS_VK_F15;            break;
   1:     case kPauseKeyCode:         geckoKeyCode = NS_VK_PAUSE;          break;
   1:     case kScrollLockKeyCode:    geckoKeyCode = NS_VK_SCROLL_LOCK;    break;
   1:     case kPrintScreenKeyCode:   geckoKeyCode = NS_VK_PRINTSCREEN;    break;
   1: 
   1:     // keypad
   1:     case kKeypad0KeyCode:       geckoKeyCode = NS_VK_NUMPAD0;        break;
   1:     case kKeypad1KeyCode:       geckoKeyCode = NS_VK_NUMPAD1;        break;
   1:     case kKeypad2KeyCode:       geckoKeyCode = NS_VK_NUMPAD2;        break;
   1:     case kKeypad3KeyCode:       geckoKeyCode = NS_VK_NUMPAD3;        break;
   1:     case kKeypad4KeyCode:       geckoKeyCode = NS_VK_NUMPAD4;        break;
   1:     case kKeypad5KeyCode:       geckoKeyCode = NS_VK_NUMPAD5;        break;
   1:     case kKeypad6KeyCode:       geckoKeyCode = NS_VK_NUMPAD6;        break;
   1:     case kKeypad7KeyCode:       geckoKeyCode = NS_VK_NUMPAD7;        break;
   1:     case kKeypad8KeyCode:       geckoKeyCode = NS_VK_NUMPAD8;        break;
   1:     case kKeypad9KeyCode:       geckoKeyCode = NS_VK_NUMPAD9;        break;
   1: 
   1:     case kKeypadMultiplyKeyCode:  geckoKeyCode = NS_VK_MULTIPLY;     break;
   1:     case kKeypadAddKeyCode:       geckoKeyCode = NS_VK_ADD;          break;
   1:     case kKeypadSubtractKeyCode:  geckoKeyCode = NS_VK_SUBTRACT;     break;
   1:     case kKeypadDecimalKeyCode:   geckoKeyCode = NS_VK_DECIMAL;      break;
   1:     case kKeypadDivideKeyCode:    geckoKeyCode = NS_VK_DIVIDE;       break;
   1: 
   1:     // these may clash with forward delete and help
   1:     case kInsertKeyCode:        geckoKeyCode = NS_VK_INSERT;         break;
   1:     case kDeleteKeyCode:        geckoKeyCode = NS_VK_DELETE;         break;
   1: 
   1:     case kBackspaceKeyCode:     geckoKeyCode = NS_VK_BACK;           break;
   1:     case kTabKeyCode:           geckoKeyCode = NS_VK_TAB;            break;
   1:     case kHomeKeyCode:          geckoKeyCode = NS_VK_HOME;           break;
   1:     case kEndKeyCode:           geckoKeyCode = NS_VK_END;            break;
   1:     case kPageUpKeyCode:        geckoKeyCode = NS_VK_PAGE_UP;        break;
   1:     case kPageDownKeyCode:      geckoKeyCode = NS_VK_PAGE_DOWN;      break;
   1:     case kLeftArrowKeyCode:     geckoKeyCode = NS_VK_LEFT;           break;
   1:     case kRightArrowKeyCode:    geckoKeyCode = NS_VK_RIGHT;          break;
   1:     case kUpArrowKeyCode:       geckoKeyCode = NS_VK_UP;             break;
   1:     case kDownArrowKeyCode:     geckoKeyCode = NS_VK_DOWN;           break;
2959:     case kVK_ANSI_1:            geckoKeyCode = NS_VK_1;              break;
2959:     case kVK_ANSI_2:            geckoKeyCode = NS_VK_2;              break;
2959:     case kVK_ANSI_3:            geckoKeyCode = NS_VK_3;              break;
2959:     case kVK_ANSI_4:            geckoKeyCode = NS_VK_4;              break;
2959:     case kVK_ANSI_5:            geckoKeyCode = NS_VK_5;              break;
2959:     case kVK_ANSI_6:            geckoKeyCode = NS_VK_6;              break;
2959:     case kVK_ANSI_7:            geckoKeyCode = NS_VK_7;              break;
2959:     case kVK_ANSI_8:            geckoKeyCode = NS_VK_8;              break;
2959:     case kVK_ANSI_9:            geckoKeyCode = NS_VK_9;              break;
2959:     case kVK_ANSI_0:            geckoKeyCode = NS_VK_0;              break;
   1: 
   1:     default:
   1:       // if we haven't gotten the key code already, look at the char code
   1:       switch (charCode)
   1:       {
   1:         case kReturnCharCode:       geckoKeyCode = NS_VK_RETURN;        break;
   1:         case kEnterCharCode:        geckoKeyCode = NS_VK_RETURN;        break;
   1:         case ' ':                   geckoKeyCode = NS_VK_SPACE;         break;
   1:         case ';':                   geckoKeyCode = NS_VK_SEMICOLON;     break;
   1:         case '=':                   geckoKeyCode = NS_VK_EQUALS;        break;
   1:         case ',':                   geckoKeyCode = NS_VK_COMMA;         break;
   1:         case '.':                   geckoKeyCode = NS_VK_PERIOD;        break;
   1:         case '/':                   geckoKeyCode = NS_VK_SLASH;         break;
   1:         case '`':                   geckoKeyCode = NS_VK_BACK_QUOTE;    break;
   1:         case '{':
   1:         case '[':                   geckoKeyCode = NS_VK_OPEN_BRACKET;  break;
   1:         case '\\':                  geckoKeyCode = NS_VK_BACK_SLASH;    break;
   1:         case '}':
   1:         case ']':                   geckoKeyCode = NS_VK_CLOSE_BRACKET; break;
   1:         case '\'':
   1:         case '"':                   geckoKeyCode = NS_VK_QUOTE;         break;
   1: 
   1:         default:
2959:           if (charCode >= 'a' && charCode <= 'z') // lowercase
   1:             geckoKeyCode = toupper(charCode);
   1:           else if (charCode >= 'A' && charCode <= 'Z') // uppercase
   1:             geckoKeyCode = charCode;
   1:             break;
   1:       }
   1:   }
   1: 
   1:   return geckoKeyCode;
   1: }
   1: 
   1: 
   1: static PRBool IsSpecialGeckoKey(UInt32 macKeyCode)
   1: {
   1:   PRBool  isSpecial;
   1:   
   1:   // this table is used to determine which keys are special and should not generate a charCode
   1:   switch (macKeyCode)
   1:   {
   1:     // modifiers - we don't get separate events for these yet
   1:     case kEscapeKeyCode:
   1:     case kShiftKeyCode:
   1:     case kCommandKeyCode:
   1:     case kCapsLockKeyCode:
   1:     case kControlKeyCode:
   1:     case kOptionkeyCode:
   1:     case kClearKeyCode:
   1:       
   1:       // function keys
   1:     case kF1KeyCode:
   1:     case kF2KeyCode:
   1:     case kF3KeyCode:
   1:     case kF4KeyCode:
   1:     case kF5KeyCode:
   1:     case kF6KeyCode:
   1:     case kF7KeyCode:
   1:     case kF8KeyCode:
   1:     case kF9KeyCode:
   1:     case kF10KeyCode:
   1:     case kF11KeyCode:
   1:     case kF12KeyCode:
   1:     case kPauseKeyCode:
   1:     case kScrollLockKeyCode:
   1:     case kPrintScreenKeyCode:
   1:       
   1:     case kInsertKeyCode:
   1:     case kDeleteKeyCode:
   1:     case kTabKeyCode:
   1:     case kBackspaceKeyCode:
   1:       
   1:     case kHomeKeyCode:
   1:     case kEndKeyCode:
   1:     case kPageUpKeyCode:
   1:     case kPageDownKeyCode:
   1:     case kLeftArrowKeyCode:
   1:     case kRightArrowKeyCode:
   1:     case kUpArrowKeyCode:
   1:     case kDownArrowKeyCode:
   1:     case kReturnKeyCode:
   1:     case kEnterKeyCode:
   1:     case kPowerbookEnterKeyCode:
   1:       isSpecial = PR_TRUE;
   1:       break;
   1:       
   1:     default:
   1:       isSpecial = PR_FALSE;
   1:       break;
   1:   }
   1:   
   1:   return isSpecial;
   1: }
   1: 
   1: 
2315: // Basic conversion for cocoa to gecko events, common to all conversions.
2315: // Note that it is OK for inEvent to be nil.
2315: - (void) convertGenericCocoaEvent:(NSEvent*)inEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent
   1: {
2315:   NS_ASSERTION(outGeckoEvent, "convertGenericCocoaEvent:toGeckoEvent: requires non-null outGeckoEvent");
2315:   if (!outGeckoEvent)
2315:     return;
2315: 
2315:   outGeckoEvent->widget = [self widget];
2315:   outGeckoEvent->time = PR_IntervalNow();
2315:   outGeckoEvent->nativeMsg = inEvent;
2315: 
2315:   if (inEvent) {
2315:     unsigned int modifiers = [inEvent modifierFlags];
2315:     outGeckoEvent->isShift   = ((modifiers & NSShiftKeyMask) != 0);
2315:     outGeckoEvent->isControl = ((modifiers & NSControlKeyMask) != 0);
2315:     outGeckoEvent->isAlt     = ((modifiers & NSAlternateKeyMask) != 0);
2315:     outGeckoEvent->isMeta    = ((modifiers & NSCommandKeyMask) != 0);
2315:   }
2315: }
2315: 
2315: 
2315: - (void) convertCocoaMouseEvent:(NSEvent*)aMouseEvent toGeckoEvent:(nsInputEvent*)outGeckoEvent
2315: {
2315:   NS_ASSERTION(aMouseEvent && outGeckoEvent, "convertCocoaMouseEvent:toGeckoEvent: requires non-null arguments");
2315:   if (!aMouseEvent || !outGeckoEvent)
2315:     return;
2315: 
2315:   [self convertGenericCocoaEvent:aMouseEvent toGeckoEvent:outGeckoEvent];
2315: 
2315:   // convert point to view coordinate system
2315:   NSPoint localPoint = [self convertPoint:[aMouseEvent locationInWindow] fromView:nil];
3233:   outGeckoEvent->refPoint.x = static_cast<nscoord>(localPoint.x);
3233:   outGeckoEvent->refPoint.y = static_cast<nscoord>(localPoint.y);
2315: }
2315: 
2315: 
2315: - (void) convertCocoaKeyEvent:(NSEvent*)aKeyEvent toGeckoEvent:(nsKeyEvent*)outGeckoEvent
2315: {
2315:   NS_ASSERTION(aKeyEvent && outGeckoEvent, "convertCocoaKeyEvent:toGeckoEvent: requires non-null arguments");
2315:   if (!aKeyEvent || !outGeckoEvent)
2315:     return;
2315: 
2315:   [self convertGenericCocoaEvent:aKeyEvent toGeckoEvent:outGeckoEvent];
2315: 
2315:   // coords for key events are always 0,0
   1:   outGeckoEvent->refPoint.x = outGeckoEvent->refPoint.y = 0;
   1: 
   1:   // Initialize whether or not we are using charCodes to false.
   1:   outGeckoEvent->isChar = PR_FALSE;
   1: 
   1:   // Check to see if the message is a key press that does not involve
   1:   // one of our special key codes.
   1:   if (outGeckoEvent->message == NS_KEY_PRESS && !IsSpecialGeckoKey([aKeyEvent keyCode])) {
2315:     outGeckoEvent->isChar = PR_TRUE; // this is not a special key
   1:     
   1:     outGeckoEvent->charCode = 0;
   1:     outGeckoEvent->keyCode  = 0;
   1:     
   1:     NSString* unmodifiedChars = [aKeyEvent charactersIgnoringModifiers];
   1:     if ([unmodifiedChars length] > 0)
   1:       outGeckoEvent->charCode = [unmodifiedChars characterAtIndex:0];
   1:     
   1:     // convert control-modified charCode to raw charCode (with appropriate case)
   1:     if (outGeckoEvent->isControl && outGeckoEvent->charCode <= 26)
   1:       outGeckoEvent->charCode += (outGeckoEvent->isShift) ? ('A' - 1) : ('a' - 1);
   1:     
   1:     // gecko also wants charCode to be in the appropriate case
   1:     if (outGeckoEvent->isShift && (outGeckoEvent->charCode >= 'a' && outGeckoEvent->charCode <= 'z'))
   1:       outGeckoEvent->charCode -= 32; // convert to uppercase
   1:   }
   1:   else {
   1:     NSString* characters = nil;
   1:     if ([aKeyEvent type] != NSFlagsChanged)
2959:       characters = [aKeyEvent charactersIgnoringModifiers];
   1:     
   1:     outGeckoEvent->keyCode = ConvertMacToGeckoKeyCode([aKeyEvent keyCode], outGeckoEvent, characters);
   1:     outGeckoEvent->charCode = 0;
   1:   } 
   1: 
   1:   if (outGeckoEvent->message == NS_KEY_PRESS && !outGeckoEvent->isMeta && outGeckoEvent->keyCode != NS_VK_PAGE_UP && 
   1:       outGeckoEvent->keyCode != NS_VK_PAGE_DOWN)
 603:     [NSCursor setHiddenUntilMouseMoves:YES];
   1: }
   1: 
   1: 
2315: - (nsRect)sendCompositionEvent:(PRInt32) aEventType
2315: {
2315: #ifdef DEBUG_IME
2315:   NSLog(@"****in sendCompositionEvent; type = %d", aEventType);
2315: #endif
2315: 
2462:   if (!mGeckoChild)
2462:     return nsRect(0, 0, 0, 0);
2462: 
2315:   // static void init_composition_event( *aEvent, int aType)
2315:   nsCompositionEvent event(PR_TRUE, aEventType, mGeckoChild);
2315:   event.time = PR_IntervalNow();
2315:   mGeckoChild->DispatchWindowEvent(event);
2315:   return event.theReply.mCursorPosition;
2315: }
2315: 
2315: 
2315: - (void)sendTextEvent:(PRUnichar*) aBuffer 
2315:                       attributedString:(NSAttributedString*) aString  
2315:                       selectedRange:(NSRange) selRange 
2315:                       markedRange:(NSRange) markRange
2315:                       doCommit:(BOOL) doCommit
2315: {
2315: #ifdef DEBUG_IME
2315:   NSLog(@"****in sendTextEvent; string = '%@'", aString);
2315:   NSLog(@" markRange = %d, %d;  selRange = %d, %d", markRange.location, markRange.length, selRange.location, selRange.length);
2315: #endif
2315: 
2462:   if (!mGeckoChild)
2462:     return;
2462: 
2315:   nsTextEvent textEvent(PR_TRUE, NS_TEXT_TEXT, mGeckoChild);
2315:   textEvent.time = PR_IntervalNow();
2315:   textEvent.theText = aBuffer;
2315:   if (!doCommit)
2315:     FillTextRangeInTextEvent(&textEvent, aString, markRange, selRange);
2315: 
2315:   mGeckoChild->DispatchWindowEvent(textEvent);
2315:   if (textEvent.rangeArray)
2315:     delete [] textEvent.rangeArray;
2315: }
2315: 
2315: 
2315: #pragma mark -
2315: // NSTextInput implementation
2315: 
2315: #define MAX_BUFFER_SIZE 32
2315: 
2315: 
2315: - (void)insertText:(id)insertString
2315: {
2315: #if DEBUG_IME
2315:   NSLog(@"****in insertText: '%@'", insertString);
2315:   NSLog(@" markRange = %d, %d;  selRange = %d, %d", mMarkedRange.location, mMarkedRange.length, mSelectedRange.location, mSelectedRange.length);
2315: #endif
2462:   if (!mGeckoChild)
2462:     return;
2315: 
4726:   id arp = [[NSAutoreleasePool alloc] init];
4726: 
2315:   if (![insertString isKindOfClass:[NSAttributedString class]])
2315:     insertString = [[[NSAttributedString alloc] initWithString:insertString] autorelease];
2315: 
2315:   NSString *tmpStr = [insertString string];
2315:   unsigned int len = [tmpStr length];
4726:   if (!nsTSMManager::IsComposing() && len == 0) {
4726:     [arp release];
4726:     return; // nothing to do
4726:   }
2315:   PRUnichar buffer[MAX_BUFFER_SIZE];
2315:   PRUnichar *bufPtr = (len >= MAX_BUFFER_SIZE) ? new PRUnichar[len + 1] : buffer;
2315:   [tmpStr getCharacters: bufPtr];
4726:   bufPtr[len] = PRUnichar('\0');
2315: 
2315:   if (len == 1 && !nsTSMManager::IsComposing()) {
2315:     // dispatch keypress event with char instead of textEvent
2315:     nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_PRESS, mGeckoChild);
2315:     geckoEvent.time      = PR_IntervalNow();
2315:     geckoEvent.charCode  = bufPtr[0]; // gecko expects OS-translated unicode
2315:     geckoEvent.isChar    = PR_TRUE;
2315:     geckoEvent.isShift   = ([mCurKeyEvent modifierFlags] & NSShiftKeyMask) != 0;
2315:     if (mKeyHandled)
2315:       geckoEvent.flags |= NS_EVENT_FLAG_NO_DEFAULT;
2315:     // don't set other modifiers from the current event, because here in
2315:     // -insertText: they've already been taken into account in creating
2315:     // the input string.
2315:         
2315:     // create native EventRecord for use by plugins
2315:     EventRecord macEvent;
2315:     if (mCurKeyEvent) {
2315:       ConvertCocoaKeyEventToMacEvent(mCurKeyEvent, macEvent);
2315:       geckoEvent.nativeMsg = &macEvent;
2315:     }
2315: 
2315:     mGeckoChild->DispatchWindowEvent(geckoEvent);
2315:   }
2315:   else {
2315:     if (!nsTSMManager::IsComposing()) {
2315:       // send start composition event to gecko
2315:       [self sendCompositionEvent: NS_COMPOSITION_START];
2315:       nsTSMManager::StartComposing(self);
2315:     }
2315: 
4726:     if (nsTSMManager::IgnoreCommit()) {
4726:       tmpStr = [tmpStr init];
4726:       len = 0;
4726:       bufPtr[0] = PRUnichar('\0');
4726:       insertString =
4726:         [[[NSAttributedString alloc] initWithString:tmpStr] autorelease];
4726:     }
4726:     // dispatch textevent
2315:     [self sendTextEvent:bufPtr attributedString:insertString
2315:                                selectedRange:NSMakeRange(0, len)
2315:                                markedRange:mMarkedRange
2315:                                doCommit:YES];
2315: 
2315:     // send end composition event to gecko
2315:     [self sendCompositionEvent: NS_COMPOSITION_END];
2315:     nsTSMManager::EndComposing();
2315:     mSelectedRange = mMarkedRange = NSMakeRange(NSNotFound, 0);
2315:   }
2315: 
2315:   if (bufPtr != buffer)
2315:     delete[] bufPtr;
4726: 
4726:   [arp release];
2315: }
2315: 
2315: 
2315: - (void)insertNewline:(id)sender
2315: {
2315:   // dummy impl, does nothing other than stop the beeping when hitting return
2315: }
2315: 
2315: 
2315: - (void) doCommandBySelector:(SEL)aSelector
2315: { 
2315: #if DEBUG_IME 
2315:   NSLog(@"**** in doCommandBySelector %s (ignore %d)", aSelector, mIgnoreDoCommand);
2315: #endif
2315:   if (mIgnoreDoCommand)
2315:     return;
2315: 
2315:   if (aSelector == @selector(insertNewline:)) {
2315:     [self insertText:@"\n"];
2315:     return;
2315:   }
2315: 
2315:   [super doCommandBySelector:aSelector];
2315: }
2315: 
2315: 
2315: - (void) setMarkedText:(id)aString selectedRange:(NSRange)selRange
2315: {
2315: #if DEBUG_IME 
2315:   NSLog(@"****in setMarkedText location: %d, length: %d", selRange.location, selRange.length);
2315:   NSLog(@" markRange = %d, %d;  selRange = %d, %d", mMarkedRange.location, mMarkedRange.length, mSelectedRange.location, mSelectedRange.length);
2315:   NSLog(@" aString = '%@'", aString);
2315: #endif
2315: 
4726:   id arp = [[NSAutoreleasePool alloc] init];
4726: 
2315:   if (![aString isKindOfClass:[NSAttributedString class]])
2315:     aString = [[[NSAttributedString alloc] initWithString:aString] autorelease];
2315: 
2315:   mSelectedRange = selRange;
2315: 
2315:   NSMutableAttributedString *mutableAttribStr = aString;
2315:   NSString *tmpStr = [mutableAttribStr string];
2315:   unsigned int len = [tmpStr length];
2315:   PRUnichar buffer[MAX_BUFFER_SIZE];
2315:   PRUnichar *bufPtr = (len >= MAX_BUFFER_SIZE) ? new PRUnichar[len + 1] : buffer;
2315:   [tmpStr getCharacters: bufPtr];
4726:   bufPtr[len] = PRUnichar('\0');
2315: 
2315: #if DEBUG_IME 
2315:   printf("****in setMarkedText, len = %d, text = ", len);
2315:   PRUint32 n = 0;
2315:   PRUint32 maxlen = len > 12 ? 12 : len;
4726:   for (PRUnichar *a = bufPtr; (*a != PRUnichar('\0')) && n<maxlen; a++, n++) printf((*a&0xff80) ? "\\u%4X" : "%c", *a); 
2315:   printf("\n");
2315: #endif
2315: 
2315:   mMarkedRange.location = 0;
2315:   mMarkedRange.length = len;
2315: 
2315:   if (!nsTSMManager::IsComposing()) {
2315:     [self sendCompositionEvent:NS_COMPOSITION_START];
2315:     nsTSMManager::StartComposing(self);
2315:   }
2315: 
4726:   nsTSMManager::UpdateComposing(tmpStr);
4726: 
2315:   [self sendTextEvent:bufPtr attributedString:aString
2315:                              selectedRange:selRange
2315:                              markedRange:mMarkedRange
2315:                              doCommit:NO];
2315: 
2315:   if (nsTSMManager::IsComposing() && len == 0)
4726:     nsTSMManager::CommitIME();
2315:   
2315:   if (bufPtr != buffer)
2315:     delete[] bufPtr;
4726: 
4726:   [arp release];
2315: }
2315: 
2315: 
2315: - (void) unmarkText
2315: {
2315: #if DEBUG_IME
2315:   NSLog(@"****in unmarkText");
2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
2315:   NSLog(@" selectedRange = %d, %d", mSelectedRange.location, mSelectedRange.length);
2315: #endif
4726:   nsTSMManager::CommitIME();
2315: }
2315: 
2315: 
2315: - (BOOL) hasMarkedText
2315: {
2315:   return (mMarkedRange.location != NSNotFound) && (mMarkedRange.length != 0);
2315: }
2315: 
2315: 
2315: - (long) conversationIdentifier
2315: {
2315:   return (long)self;
2315: }
2315: 
2315: 
2315: - (NSAttributedString *) attributedSubstringFromRange:(NSRange)theRange
2315: {
2315: #if DEBUG_IME
2315:   NSLog(@"****in attributedSubstringFromRange");
2315:   NSLog(@" theRange      = %d, %d", theRange.location, theRange.length);
2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
2315:   NSLog(@" selectedRange = %d, %d", mSelectedRange.location, mSelectedRange.length);
2315: #endif
2462:   if (!mGeckoChild)
2462:     return nil;
2462: 
2462:   nsReconversionEvent reconversionEvent(PR_TRUE, NS_RECONVERSION_QUERY, mGeckoChild);
2315:   reconversionEvent.time = PR_IntervalNow();
2315: 
2315:   nsresult rv = mGeckoChild->DispatchWindowEvent(reconversionEvent);
2315:   PRUnichar* reconvstr;
2462:   if (NS_SUCCEEDED(rv) && (reconvstr = reconversionEvent.theReply.mReconversionString)) {
2315:     NSAttributedString* result = [[[NSAttributedString alloc] initWithString:[NSString stringWithCharacters:reconvstr length:nsCRT::strlen(reconvstr)]
2315:                                                                   attributes:nil] autorelease];
2315:     nsMemory::Free(reconvstr);
2315:     return result;
2315:   }
2315: 
2315:   return nil;
2315: }
2315: 
2315: 
2315: - (NSRange) markedRange
2315: {
2315: #if DEBUG_IME
2315:   NSLog(@"****in markedRange");
2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
2315:   NSLog(@" selectedRange = %d, %d", mSelectedRange.location, mSelectedRange.length);
2315: #endif
2315: 
2315:   if (![self hasMarkedText]) {
2315:     return NSMakeRange(NSNotFound, 0);
2315:   }
2315: 
2315:   return mMarkedRange;
2315: }
2315: 
2315: 
2315: - (NSRange) selectedRange
2315: {
2315: #if DEBUG_IME
2315:   NSLog(@"****in selectedRange");
2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
2315:   NSLog(@" selectedRange = %d, %d", mSelectedRange.location, mSelectedRange.length);
2315: #endif
2315: 
2315:   return mSelectedRange;
2315: }
2315: 
2315: 
2315: - (NSRect) firstRectForCharacterRange:(NSRange)theRange
2315: {
2315: #if DEBUG_IME
2315:   NSLog(@"****in firstRectForCharacterRange");
2315:   NSLog(@" theRange      = %d, %d", theRange.location, theRange.length);
2315:   NSLog(@" markedRange   = %d, %d", mMarkedRange.location, mMarkedRange.length);
2315:   NSLog(@" selectedRange = %d, %d", mSelectedRange.location, mSelectedRange.length);
2315: #endif
2315: 
2315:   nsRect compositionRect = [self sendCompositionEvent:NS_COMPOSITION_QUERY];
2315: 
2315:   NSRect rangeRect;
2315:   GeckoRectToNSRect(compositionRect, rangeRect);
2315: 
2315:   // convert to window coords
2315:   rangeRect = [self convertRect:rangeRect toView:nil];
2315:   // convert to cocoa screen coords
2315:   rangeRect.origin = [[self nativeWindow] convertBaseToScreen:rangeRect.origin];
2315:   return rangeRect;
2315: }
2315: 
2315: 
2315: - (unsigned int)characterIndexForPoint:(NSPoint)thePoint
2315: {
2315: #if DEBUG_IME
2315:   NSLog(@"****in characterIndexForPoint");
2315:   NSLog(@" markRange = %d, %d;  selectRange = %d, %d", mMarkedRange.location, mMarkedRange.length, mSelectedRange.location, mSelectedRange.length);
2315: #endif
2315: 
2315:   // To implement this, we'd have to grovel in text frames looking at text offsets.
2315:   return 0;
2315: }
2315: 
2315: 
2315: - (NSArray*) validAttributesForMarkedText
2315: {
2315: #if DEBUG_IME
2315:   NSLog(@"****in validAttributesForMarkedText");
2315:   NSLog(@" markRange = %d, %d;  selectRange = %d, %d", mMarkedRange.location, mMarkedRange.length, mSelectedRange.location, mSelectedRange.length);
2315: #endif
2315: 
2315:   //return [NSArray arrayWithObjects:NSUnderlineStyleAttributeName, NSMarkedClauseSegmentAttributeName, NSTextInputReplacementRangeAttributeName, nil];
2315:   return [NSArray array]; // empty array; we don't support any attributes right now
2315: }
2315: 
2315: 
2315: #pragma mark -
2315: 
2315: 
2315: // Handle matching cocoa IME with gecko key events. Sends a key down and key press
2315: // event to gecko.
2315: - (void)keyDown:(NSEvent*)theEvent
2315: {
2462:   if (!mGeckoChild)
2462:     return;
2462: 
2315:   mCurKeyEvent = theEvent;
2315: 
2315:   BOOL nonDeadKeyPress = [[theEvent characters] length] > 0;
2315: 
2315:   // if we have a dead-key event, we won't get a character
2315:   // since we have no character, there isn't any point to generating
2315:   // a gecko event until they have dead key events
2315:   if (![theEvent isARepeat] && nonDeadKeyPress) {
2315:     // Fire a key down. We'll fire key presses via -insertText:
2315:     nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_DOWN, nsnull);
2315:     [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
2315: 
2315:     // create native EventRecord for use by plugins
2315:     EventRecord macEvent;
2315:     ConvertCocoaKeyEventToMacEvent(theEvent, macEvent);
2315:     geckoEvent.nativeMsg = &macEvent;
2315:     mKeyHandled = mGeckoChild->DispatchWindowEvent(geckoEvent);
2315:   }
2315: 
2315:   // Check to see if we are still the first responder.
2315:   // The key down event may have shifted the focus, in which
2315:   // case we should not fire the key press.
2315:   NSResponder* resp = [[self window] firstResponder];
2315:   if (resp != (NSResponder*)self) {
2315:     mCurKeyEvent = nil;
2315:     return;
2315:   }
2315: 
2315:   PRBool dispatchedKeyPress = PR_FALSE;
2315:   if (nonDeadKeyPress) {
2315:     nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_PRESS, nsnull);
2315:     [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
2315: 
2315:     if (mKeyHandled)
2315:       geckoEvent.flags |= NS_EVENT_FLAG_NO_DEFAULT;
2315: 
2315:     // if this is a non-letter keypress, or the control key is down,
2315:     // dispatch the keydown to gecko, so that we trap delete,
2315:     // control-letter combinations etc before Cocoa tries to use
2315:     // them for keybindings.
2315:     if ((!geckoEvent.isChar || geckoEvent.isControl) &&
2315:         !nsTSMManager::IsComposing()) {
2315:       // create native EventRecord for use by plugins
2315:       EventRecord macEvent;
2315:       ConvertCocoaKeyEventToMacEvent(theEvent, macEvent);
2315:       geckoEvent.nativeMsg = &macEvent;
2315: 
2315:       mIgnoreDoCommand = mGeckoChild->DispatchWindowEvent(geckoEvent);
2315:       dispatchedKeyPress = PR_TRUE;
2315:     }
2315:   }
2315: 
2315:   // We should send this event to the superclass if IME is enabled.
2315:   // Otherwise, we need to suppress IME composition. We can do it by
2315:   // not sending this event to the superclass. But in that case,
2315:   // we need to call insertText ourselves.
2315:   if (nsTSMManager::IsIMEEnabled())
2315:     [super interpretKeyEvents:[NSArray arrayWithObject:theEvent]];
2315:   else if (nonDeadKeyPress && !dispatchedKeyPress)
2315:     [self insertText:[theEvent characters]];
2315: 
2315:   mIgnoreDoCommand = NO;
2315:   mCurKeyEvent = nil;
2315:   mKeyHandled = PR_FALSE;
2315: }
2315: 
2315: 
2315: - (void)keyUp:(NSEvent*)theEvent
2315: {
2315:   // if we don't have any characters we can't generate a keyUp event
2462:   if (!mGeckoChild || [[theEvent characters] length] == 0)
2315:     return;
2315: 
2315:   // Fire a key up.
2315:   nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_UP, nsnull);
2315:   [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
2315: 
2315:   // create native EventRecord for use by plugins
2315:   EventRecord macEvent;
2315:   ConvertCocoaKeyEventToMacEvent(theEvent, macEvent);
2315:   geckoEvent.nativeMsg = &macEvent;
2315: 
2315:   mGeckoChild->DispatchWindowEvent(geckoEvent);
2315: }
2315: 
2315: 
2315: - (BOOL)performKeyEquivalent:(NSEvent*)theEvent
2315: {
2462:   // don't bother if we don't have a gecko widget or we're in composition
2462:   if (!mGeckoChild || nsTSMManager::IsComposing())
2315:     return NO;
2315: 
2315:   // see if the menu system will handle the event
2315:   if ([[NSApp mainMenu] performKeyEquivalent:theEvent])
2315:     return YES;
2315: 
2315:   // don't handle this if certain modifiers are down - those should
2315:   // be sent as normal key up/down events and cocoa will do so automatically
2315:   // if we reject here
2315:   unsigned int modifierFlags = [theEvent modifierFlags];
2315:   if ((modifierFlags & NSFunctionKeyMask) || (modifierFlags & NSNumericPadKeyMask))
2315:     return NO;
2315: 
2315:   // handle the event ourselves
2315:   nsKeyEvent geckoEvent(PR_TRUE, NS_KEY_PRESS, nsnull);
2315:   [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
2315: 
2315:   // create native EventRecord for use by plugins
2315:   EventRecord macEvent;
2315:   ConvertCocoaKeyEventToMacEvent(theEvent, macEvent);
2315:   geckoEvent.nativeMsg = &macEvent;
2315: 
2315:   return (BOOL)mGeckoChild->DispatchWindowEvent(geckoEvent);
2315: }
2315: 
2315: 
2315: - (void)flagsChanged:(NSEvent*)theEvent
2315: {
2462:   if (!mGeckoChild)
2462:     return;
2462: 
2315:   // Fire key up/down events for the modifier keys (shift, alt, ctrl, command).
2315:   if ([theEvent type] == NSFlagsChanged) {
2315:     unsigned int modifiers =
2315:       [theEvent modifierFlags] & NSDeviceIndependentModifierFlagsMask;
2315:     const PRUint32 kModifierMaskTable[] =
2315:       { NSShiftKeyMask, NSControlKeyMask, NSAlternateKeyMask, NSCommandKeyMask };
2315:     const PRUint32 kModifierCount = sizeof(kModifierMaskTable) /
2315:                                     sizeof(kModifierMaskTable[0]);
2315: 
2315:     for (PRUint32 i = 0; i < kModifierCount; i++) {
2315:       PRUint32 modifierBit = kModifierMaskTable[i];
2315:       if ((modifiers & modifierBit) != (mLastModifierState & modifierBit)) {
2315:         PRUint32 message = ((modifiers & modifierBit) != 0 ? NS_KEY_DOWN :
2315:                                                              NS_KEY_UP);
2315: 
2315:         // Fire a key event.
2315:         nsKeyEvent geckoEvent(PR_TRUE, message, nsnull);
2315:         [self convertCocoaKeyEvent:theEvent toGeckoEvent:&geckoEvent];
2315: 
2315:         // create native EventRecord for use by plugins
2315:         EventRecord macEvent;
2315:         ConvertCocoaKeyEventToMacEvent(theEvent, macEvent, message);
2315:         geckoEvent.nativeMsg = &macEvent;
2315: 
2315:         mGeckoChild->DispatchWindowEvent(geckoEvent);
2315: 
2315:         // Stop if focus has changed.
2315:         // Check to see if we are still the first responder.
2315:         NSResponder* resp = [[self window] firstResponder];
2315:         if (resp != (NSResponder*)self)
2315:           break;
2315:       }
2315:     }
2315: 
2315:     mLastModifierState = modifiers;
2315:   }
2315: 
2315:   // check if the hand scroll cursor needs to be set/unset
2315:   [self setHandScrollCursor:theEvent];
2315: }
2315: 
2315: 
2315: // This method is called when we are about to be focused.
2315: - (BOOL)becomeFirstResponder
2315: {
2462:   if (!mGeckoChild)
2462:     return NO;
2315: 
4208:   [self sendFocusEvent:NS_GOTFOCUS];
2315: 
2315:   return [super becomeFirstResponder];
2315: }
2315: 
2315: 
2315: // This method is called when are are about to lose focus.
2677: // We must always call through to our superclass, even when mGeckoChild is
2677: // nil -- otherwise the keyboard focus can end up in the wrong NSView.
2315: - (BOOL)resignFirstResponder
2315: {
4726:   nsTSMManager::CommitIME();
4726: 
4208:   if (mGeckoChild)
4208:     [self sendFocusEvent:NS_LOSTFOCUS];
2315: 
2315:   return [super resignFirstResponder];
2315: }
2315: 
2315: 
2315: - (void)viewsWindowDidBecomeKey
2315: {
2315:   if (!mGeckoChild)
2462:     return;
2315: 
2315:   // check to see if the window implements the mozWindow protocol. This
2315:   // allows embedders to avoid re-entrant calls to -makeKeyAndOrderFront,
2315:   // which can happen because these activate/focus calls propagate out
2315:   // to the embedder via nsIEmbeddingSiteWindow::SetFocus().
2315:   BOOL isMozWindow = [[self window] respondsToSelector:@selector(setSuppressMakeKeyFront:)];
2315:   if (isMozWindow)
2315:     [[self window] setSuppressMakeKeyFront:YES];
2315: 
4208:   [self sendFocusEvent:NS_GOTFOCUS];
4208:   [self sendFocusEvent:NS_ACTIVATE];
2315: 
2315:   if (isMozWindow)
2315:     [[self window] setSuppressMakeKeyFront:NO];
2315: }
2315: 
2315: 
2315: - (void)viewsWindowDidResignKey
2315: {
2315:   if (!mGeckoChild)
2462:     return;
2315: 
4726:   nsTSMManager::CommitIME();
4726: 
4208:   [self sendFocusEvent:NS_DEACTIVATE];
4208:   [self sendFocusEvent:NS_LOSTFOCUS];
2315: }
2315: 
2315: 
2677: // If the call to removeFromSuperview isn't delayed from nsChildView::
2677: // TearDownView(), the NSView hierarchy might get changed during calls to
2677: // [ChildView drawRect:], which leads to "beyond bounds" exceptions in
2677: // NSCFArray.  For more info see bmo bug 373122.  Apple's docs claim that
2315: // removeFromSuperviewWithoutNeedingDisplay "can be safely invoked during
2315: // display" (whatever "display" means).  But it's _not_ true that it can be
2677: // safely invoked during calls to [NSView drawRect:].  We use
2677: // removeFromSuperview here because there's no longer any danger of being
2677: // "invoked during display", and because doing do clears up bmo bug 384343.
2315: - (void)delayedTearDown
2315: {
2677:   [self removeFromSuperview];
2315:   [self release];
2315: }
2315: 
2315: 
   1: #pragma mark -
   1: 
   1: 
   1: // drag'n'drop stuff
   1: #define kDragServiceContractID "@mozilla.org/widget/dragservice;1"
   1: 
   1: 
   1: // This is a utility function used by NSView drag event methods
   1: // to send events. It contains all of the logic needed for Gecko
   1: // dragging to work. Returns YES if the event was handled, NO
   1: // if it wasn't.
   1: - (BOOL)doDragAction:(PRUint32)aMessage sender:(id)aSender
   1: {
2958:   if (!mGeckoChild)
   1:     return NO;
   1: 
3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView doDragAction: entered\n"));
3545: 
2958:   if (!mDragService) {
2958:     CallGetService(kDragServiceContractID, &mDragService);
2958:     NS_ASSERTION(mDragService, "Couldn't get a drag service - big problem!");
2958:     if (!mDragService)
2958:       return NO;
2958:   }
2958: 
   1:   if (aMessage == NS_DRAGDROP_ENTER)
   1:     mDragService->StartDragSession();
   1: 
   1:   nsCOMPtr<nsIDragSession> dragSession;
   1:   mDragService->GetCurrentSession(getter_AddRefs(dragSession));
   1:   if (dragSession) {
 482:     if (aMessage == NS_DRAGDROP_OVER) {
 482:       // fire the drag event at the source. Just ignore whether it was
 482:       // cancelled or not as there isn't actually a means to stop the drag
 482:       mDragService->FireDragEventAtSource(NS_DRAGDROP_DRAG);
   1:       dragSession->SetCanDrop(PR_FALSE);
 482:     }
   1:     else if (aMessage == NS_DRAGDROP_DROP) {
   1:       // We make the assuption that the dragOver handlers have correctly set
   1:       // the |canDrop| property of the Drag Session.
   1:       PRBool canDrop = PR_FALSE;
   1:       if (!NS_SUCCEEDED(dragSession->GetCanDrop(&canDrop)) || !canDrop)
   1:         return NO;
   1:     }
   1:     
   1:     unsigned int modifierFlags = [[NSApp currentEvent] modifierFlags];
   1:     PRUint32 action = nsIDragService::DRAGDROP_ACTION_MOVE;
   1:     // force copy = option, alias = cmd-option, default is move
   1:     if (modifierFlags & NSAlternateKeyMask) {
   1:       if (modifierFlags & NSCommandKeyMask)
   1:         action = nsIDragService::DRAGDROP_ACTION_LINK;
   1:       else
   1:         action = nsIDragService::DRAGDROP_ACTION_COPY;
   1:     }
   1:     dragSession->SetDragAction(action);
   1:   }
   1: 
   1:   NSPoint dragLocation = [aSender draggingLocation];
   1:   dragLocation = [[self window] convertBaseToScreen:dragLocation];
   1:   FlipCocoaScreenCoordinate(dragLocation);
   1: 
   1:   // Pass into Gecko for handling.
   1:   PRBool handled = PR_FALSE;
   1:   mGeckoChild->DragEvent(aMessage, (PRInt16)dragLocation.x,
   1:                          (PRInt16)dragLocation.y, 0, &handled);
   1: 
   1:   if (aMessage == NS_DRAGDROP_EXIT && dragSession) {
   1:     nsCOMPtr<nsIDOMNode> sourceNode;
   1:     dragSession->GetSourceNode(getter_AddRefs(sourceNode));
   1:     if (!sourceNode) {
   1:       // We're leaving a window while doing a drag that was
   1:       // initiated in a different app. End the drag session,
   1:       // since we're done with it for now (until the user
   1:       // drags back into mozilla).
 482:       mDragService->EndDragSession(PR_FALSE);
   1:     }
   1:   }
   1: 
   1:   return handled ? YES : NO;
   1: }
   1: 
   1: 
   1: - (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender
   1: {
3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingEntered: entered\n"));
3545:   
   1:   // there should never be a globalDragPboard when "draggingEntered:" is
   1:   // called, but just in case we'll take care of it here.
   1:   [globalDragPboard release];
   1: 
   1:   // Set the global drag pasteboard that will be used for this drag session.
   1:   // This will be set back to nil when the drag session ends (mouse exits
   1:   // the view or a drop happens within the view).
   1:   globalDragPboard = [[sender draggingPasteboard] retain];
   1: 
   1:   BOOL handled = [self doDragAction:NS_DRAGDROP_ENTER sender:sender];
   1: 
   1:   return handled ? NSDragOperationGeneric : NSDragOperationNone;
   1: }
   1: 
   1: 
   1: - (NSDragOperation)draggingUpdated:(id <NSDraggingInfo>)sender
   1: {
3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingUpdated: entered\n"));
3545: 
   1:   BOOL handled = [self doDragAction:NS_DRAGDROP_OVER sender:sender];
   1:   return handled ? NSDragOperationGeneric : NSDragOperationNone;
   1: }
   1: 
   1: 
   1: - (void)draggingExited:(id <NSDraggingInfo>)sender
   1: {
3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView draggingExited: entered\n"));
3545: 
   1:   [self doDragAction:NS_DRAGDROP_EXIT sender:sender];
2958: }
2958: 
2958: 
2958: - (BOOL)performDragOperation:(id <NSDraggingInfo>)sender
2958: {
2958:   return [self doDragAction:NS_DRAGDROP_DROP sender:sender];
2958: }
2958: 
2958: 
2958: // NSDraggingSource
2958: - (void)draggedImage:(NSImage *)anImage endedAt:(NSPoint)aPoint operation:(NSDragOperation)operation
2958: {
3592:   gDraggedTransferables = nsnull;
3592: 
2958:   if (!mDragService) {
2958:     CallGetService(kDragServiceContractID, &mDragService);
2958:     NS_ASSERTION(mDragService, "Couldn't get a drag service - big problem!");
2958:   }
2958: 
2958:   if (mDragService) {
2958:     mDragService->EndDragSession(PR_TRUE);
2958:     NS_RELEASE(mDragService);
2958:   }
2958: 
   1:   [globalDragPboard release];
   1:   globalDragPboard = nil;
   1: }
   1: 
   1: 
2958: // NSDraggingSource
2958: // this is just implemented so we comply with the NSDraggingSource informal protocol
2958: - (unsigned int)draggingSourceOperationMaskForLocal:(BOOL)isLocal
   1: {
2958:   return UINT_MAX;
   1: }
   1: 
3545: // This method is a callback typically invoked in response to a drag ending on the desktop
3545: // or a Findow folder window; the argument passed is a path to the drop location, to be used
3545: // in constructing a complete pathname for the file(s) we want to create as a result of
3545: // the drag.
3545: - (NSArray *)namesOfPromisedFilesDroppedAtDestination:(id <NSDraggingInfo>)dropDestination
3545: {
3545:   nsresult rv;
3545: 
3545:   PR_LOG(sCocoaLog, PR_LOG_ALWAYS, ("ChildView namesOfPromisedFilesDroppedAtDestination: entering callback for promised files\n"));
3545: 
3545:   nsCOMPtr<nsILocalFile> targFile;
3545:   NS_NewLocalFile(EmptyString(), PR_TRUE, getter_AddRefs(targFile));
3545:   nsCOMPtr<nsILocalFileMac> macLocalFile = do_QueryInterface(targFile);
3545:   if (!macLocalFile) {
3545:     NS_ERROR("No Mac local file");
3545:     return nil;
3545:   }
3545: 
3545:   if (!NS_SUCCEEDED(macLocalFile->InitWithCFURL((CFURLRef)dropDestination))) {
3545:     NS_ERROR("failed InitWithCFURL");
3545:     return nil;
3545:   }
3545: 
3592:   if (!gDraggedTransferables)
3592:     return nil;
3545: 
3545:   PRUint32 transferableCount;
3592:   rv = gDraggedTransferables->Count(&transferableCount);
3545:   if (NS_FAILED(rv))
3545:     return nil;
3545: 
3545:   for (PRUint32 i = 0; i < transferableCount; i++) {
3545:     nsCOMPtr<nsISupports> genericItem;
3592:     gDraggedTransferables->GetElementAt(i, getter_AddRefs(genericItem));
3545:     nsCOMPtr<nsITransferable> item(do_QueryInterface(genericItem));
3545:     if (!item) {
3545:       NS_ERROR("no transferable");
3545:       return nil;
3545:     }
3545: 
3545:     item->SetTransferData(kFilePromiseDirectoryMime, macLocalFile, sizeof(nsILocalFile*));
3545:     
3545:     // now request the kFilePromiseMime data, which will invoke the data provider
3545:     // If successful, the returned data is a reference to the resulting file.
3545:     nsCOMPtr<nsISupports> fileDataPrimitive;
3545:     PRUint32 dataSize = 0;
3545:     item->GetTransferData(kFilePromiseMime, getter_AddRefs(fileDataPrimitive), &dataSize);
3545:   }
3545:   
3545:   NSPasteboard* generalPboard = [NSPasteboard pasteboardWithName:NSDragPboard];
3545:   NSData* data = [generalPboard dataForType:@"application/x-moz-file-promise-dest-filename"];
3545:   NSString* name = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
3545:   NSArray* rslt = [NSArray arrayWithObject:name];
3545: 
3545:   [name release];
3545: 
3545:   return rslt;
3545: }
   1: 
   1: #pragma mark -
   1: 
   1: 
   1: #ifdef ACCESSIBILITY
   1: 
   1: /* Every ChildView has a corresponding mozDocAccessible object that is doing all
   1:    the heavy lifting. The topmost ChildView corresponds to a mozRootAccessible
   1:    object.
   1: 
   1:    All ChildView needs to do is to route all accessibility calls (from the NSAccessibility APIs)
   1:    down to its object, pretending that they are the same.
   1: */
   1: - (id<mozAccessible>)accessible
   1: {
2462:   if (!mGeckoChild)
2462:     return nil;
2462: 
   1:   id<mozAccessible> nativeAccessible = nil;
   1:   
   1:   nsCOMPtr<nsIAccessible> accessible;
   1:   mGeckoChild->GetDocumentAccessible(getter_AddRefs(accessible));
   1:   
   1:   if (accessible)
   1:     accessible->GetNativeInterface((void**)&nativeAccessible);
   1: 
   1: #ifdef DEBUG_hakan
   1:   NSAssert(![nativeAccessible isExpired], @"native acc is expired!!!");
   1: #endif
   1:   
   1:   return nativeAccessible;
   1: }
   1: 
   1: /* Implementation of formal mozAccessible formal protocol (enabling mozViews
   1:    to talk to mozAccessible objects in the accessibility module). */
   1: 
   1: - (BOOL)hasRepresentedView
   1: {
   1:   return YES;
   1: }
   1: 
   1: - (id)representedView
   1: {
   1:   return self;
   1: }
   1: 
   1: - (BOOL)isRoot
   1: {
   1:   return [[self accessible] isRoot];
   1: }
   1: 
   1: #ifdef DEBUG
   1: - (void)printHierarchy
   1: {
   1:   [[self accessible] printHierarchy];
   1: }
   1: #endif
   1: 
   1: #pragma mark -
   1: 
   1: // general
   1: 
   1: - (BOOL)accessibilityIsIgnored
   1: {
   1:   return [[self accessible] accessibilityIsIgnored];
   1: }
   1: 
   1: - (id)accessibilityHitTest:(NSPoint)point
   1: {
   1:   return [[self accessible] accessibilityHitTest:point];
   1: }
   1: 
   1: - (id)accessibilityFocusedUIElement
   1: {
   1:   return [[self accessible] accessibilityFocusedUIElement];
   1: }
   1: 
   1: // actions
   1: 
   1: - (NSArray*)accessibilityActionNames
   1: {
   1:   return [[self accessible] accessibilityActionNames];
   1: }
   1: 
   1: - (NSString*)accessibilityActionDescription:(NSString*)action
   1: {
   1:   return [[self accessible] accessibilityActionDescription:action];
   1: }
   1: 
   1: - (void)accessibilityPerformAction:(NSString*)action
   1: {
   1:   return [[self accessible] accessibilityPerformAction:action];
   1: }
   1: 
   1: // attributes
   1: 
   1: - (NSArray*)accessibilityAttributeNames
   1: {
   1:   return [[self accessible] accessibilityAttributeNames];
   1: }
   1: 
   1: - (BOOL)accessibilityIsAttributeSettable:(NSString*)attribute
   1: {
   1:   return [[self accessible] accessibilityIsAttributeSettable:attribute];
   1: }
   1: 
   1: - (id)accessibilityAttributeValue:(NSString*)attribute
   1: {
   1:   id<mozAccessible> accessible = [self accessible];
   1:   
   1:   // if we're the root (topmost) accessible, we need to return our native AXParent as we
   1:   // traverse outside to the hierarchy of whoever embeds us. thus, fall back on NSView's
   1:   // default implementation for this attribute.
   1:   if ([attribute isEqualToString:NSAccessibilityParentAttribute] && [accessible isRoot]) {
   1:     id parentAccessible = [super accessibilityAttributeValue:attribute];
   1:     return parentAccessible;
   1:   }
   1: 
   1:   return [accessible accessibilityAttributeValue:attribute];
   1: }
   1: 
   1: #endif /* ACCESSIBILITY */
   1: 
   1: @end
 539: 
 539: 
 539: #pragma mark -
 539: 
 539: 
 539: PRBool
 539: nsTSMManager::GetIMEOpenState()
 539: {
 539:   return GetScriptManagerVariable(smKeyScript) != smRoman ? PR_TRUE : PR_FALSE;
 539: }
 539: 
 539: 
 539: void
 539: nsTSMManager::StartComposing(NSView<mozView>* aComposingView)
 539: {
 539:   if (sComposingView && sComposingView != sComposingView)
 539:     CommitIME();
 539:   sComposingView = aComposingView;
4726:   sDocumentID = ::TSMGetActiveDocument();
4726: }
4726: 
4726: 
4726: void
4726: nsTSMManager::UpdateComposing(NSString* aComposingString)
4726: {
4726:   sComposingString = aComposingString;
4726:   [sComposingString retain];
 539: }
 539: 
 539: 
 539: void
 539: nsTSMManager::EndComposing()
 539: {
 539:   sComposingView = nsnull;
4726:   if (sComposingString) {
4726:     [sComposingString release];
4726:     sComposingString = nsnull;
4726:   }
4726:   sDocumentID = nsnull;
 539: }
 539: 
 539: 
 539: void
 539: nsTSMManager::EnableIME(PRBool aEnable)
 539: {
 539:   if (aEnable == sIsIMEEnabled)
 539:     return;
 539:   CommitIME();
 539:   sIsIMEEnabled = aEnable;
 539: }
 539: 
 539: 
 539: void
 539: nsTSMManager::SetIMEOpenState(PRBool aOpen)
 539: {
 539:   if (aOpen == GetIMEOpenState())
 539:     return;
 539:   CommitIME();
 539:   KeyScript(aOpen ? smKeySwapScript : smKeyRoman);
 539: }
 539: 
 539: 
 539: #define ENABLE_ROMAN_KYBDS_ONLY -23
 539: void
 539: nsTSMManager::SetRomanKeyboardsOnly(PRBool aRomanOnly)
 539: {
 539:   if (aRomanOnly == sIsRomanKeyboardsOnly)
 539:     return;
 539:   CommitIME();
 539:   KeyScript(aRomanOnly ? ENABLE_ROMAN_KYBDS_ONLY : smKeyEnableKybds);
 539:   sIsRomanKeyboardsOnly = aRomanOnly;
 539: }
 539: 
 539: 
 539: void
4726: nsTSMManager::KillComposing()
4726: {
4726:   // Force commit the current composition
4726:   // XXX Don't use NSInputManager. Because it cannot control the non-forcused
4726:   // input manager, therefore, on deactivating a window, it does not work fine.
4726:   NS_ASSERTION(sDocumentID, "The TSMDocumentID is null");
4726:   ::FixTSMDocument(sDocumentID);
4726: }
4726: 
4726: 
4726: void
 539: nsTSMManager::CommitIME()
 539: {
4726:   if (!IsComposing())
 539:     return;
4726:   KillComposing();
4726:   if (!IsComposing())
4726:     return;
4726:   // If the composing transaction is still there, KillComposing only kills the
4726:   // composing in TSM. We also need to kill the our composing transaction too.
4726:   NSAttributedString* str =
4726:     [[NSAttributedString alloc] initWithString:sComposingString];
4726:   [sComposingView insertText:str];
4726:   [str release];
 539: }
 539: 
 539: 
 539: void
 539: nsTSMManager::CancelIME()
 539: {
4726:   if (!IsComposing())
 539:     return;
4726:   // For canceling the current composing, we need to ignore the param of
4726:   // insertText. But this code is ugly...
4726:   sIgnoreCommit = PR_TRUE;
4726:   KillComposing();
4726:   sIgnoreCommit = PR_FALSE;
4726:   if (!IsComposing())
4726:     return;
4726:   // If the composing transaction is still there, KillComposing only kills the
4726:   // composing in TSM. We also need to kill the our composing transaction too.
4726:   NSAttributedString* str = [[NSAttributedString alloc] initWithString:@""];
4726:   [sComposingView insertText:str];
4726:   [str release];
4726: }
