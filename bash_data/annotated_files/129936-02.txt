 81024: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 81024: 
 84348: #include <stdlib.h>
 84690: #include <signal.h>
103095: #include <stdarg.h>
 98874: #include "mozilla/ThreadLocal.h"
 81024: #include "nscore.h"
 84182: #include "mozilla/TimeStamp.h"
 93230: #include "mozilla/Util.h"
108148: #include "nsAlgorithm.h"
129543: #include <algorithm>
 84182: 
124674: 
103915: /* QT has a #define for the word "slots" and jsfriendapi.h has a struct with
103915:  * this variable name, causing compilation problems. Alleviate this for now by
103915:  * removing this #define */
103915: #ifdef MOZ_WIDGET_QT
103915: #undef slots
103915: #endif
103915: #include "jsfriendapi.h"
103915: 
 84182: using mozilla::TimeStamp;
 84182: using mozilla::TimeDuration;
 81024: 
 98874: struct ProfileStack;
 98874: class TableTicker;
124674: class JSCustomObject;
 98874: 
 99088: extern mozilla::ThreadLocal<ProfileStack *> tlsStack;
 99088: extern mozilla::ThreadLocal<TableTicker *> tlsTicker;
 84289: extern bool stack_key_initialized;
 81024: 
 87692: #ifndef SAMPLE_FUNCTION_NAME
 87692: # ifdef __GNUC__
 87692: #  define SAMPLE_FUNCTION_NAME __FUNCTION__
 87692: # elif defined(_MSC_VER)
 87692: #  define SAMPLE_FUNCTION_NAME __FUNCTION__
 87692: # else
 87692: #  define SAMPLE_FUNCTION_NAME __func__  // defined in C99, supported in various C++ compilers. Just raw function name.
 87692: # endif
 87692: #endif
 87692: 
 84886: #define SAMPLER_INIT() mozilla_sampler_init()
124674: #define SAMPLER_SHUTDOWN() mozilla_sampler_shutdown()
 87178: #define SAMPLER_START(entries, interval, features, featureCount) mozilla_sampler_start(entries, interval, features, featureCount)
 84886: #define SAMPLER_STOP() mozilla_sampler_stop()
 84886: #define SAMPLER_IS_ACTIVE() mozilla_sampler_is_active()
 84182: #define SAMPLER_RESPONSIVENESS(time) mozilla_sampler_responsiveness(time)
 84182: #define SAMPLER_GET_RESPONSIVENESS() mozilla_sampler_get_responsiveness()
111209: #define SAMPLER_FRAME_NUMBER(frameNumber) mozilla_sampler_frame_number(frameNumber)
 84886: #define SAMPLER_SAVE() mozilla_sampler_save()
 84886: #define SAMPLER_GET_PROFILE() mozilla_sampler_get_profile()
 91957: #define SAMPLER_GET_PROFILE_DATA(ctx) mozilla_sampler_get_profile_data(ctx)
 87178: #define SAMPLER_GET_FEATURES() mozilla_sampler_get_features()
 87692: // we want the class and function name but can't easily get that using preprocessor macros
 87692: // __func__ doesn't have the class name and __PRETTY_FUNCTION__ has the parameters
 95735: 
 95735: #define SAMPLER_APPEND_LINE_NUMBER_PASTE(id, line) id ## line
 95735: #define SAMPLER_APPEND_LINE_NUMBER_EXPAND(id, line) SAMPLER_APPEND_LINE_NUMBER_PASTE(id, line)
 95735: #define SAMPLER_APPEND_LINE_NUMBER(id) SAMPLER_APPEND_LINE_NUMBER_EXPAND(id, __LINE__)
 95735: 
108148: #define SAMPLE_LABEL(name_space, info) mozilla::SamplerStackFrameRAII SAMPLER_APPEND_LINE_NUMBER(sampler_raii)(name_space "::" info, __LINE__)
108148: #define SAMPLE_LABEL_PRINTF(name_space, info, ...) mozilla::SamplerStackFramePrintfRAII SAMPLER_APPEND_LINE_NUMBER(sampler_raii)(name_space "::" info, __LINE__, __VA_ARGS__)
 84886: #define SAMPLE_MARKER(info) mozilla_sampler_add_marker(info)
 81024: 
123586: #define SAMPLER_PRINT_LOCATION() mozilla_sampler_print_location()
123586: 
 84290: /* we duplicate this code here to avoid header dependencies
 84290:  * which make it more difficult to include in other places */
 84290: #if defined(_M_X64) || defined(__x86_64__)
 84290: #define V8_HOST_ARCH_X64 1
 84290: #elif defined(_M_IX86) || defined(__i386__) || defined(__i386)
 84290: #define V8_HOST_ARCH_IA32 1
 84290: #elif defined(__ARMEL__)
 84290: #define V8_HOST_ARCH_ARM 1
 84290: #else
 84290: #warning Please add support for your architecture in chromium_types.h
 84290: #endif
 84290: 
114818: /* FIXME/bug 789667: memory constraints wouldn't much of a problem for
114818:  * this small a sample buffer size, except that serializing the
114818:  * profile data is extremely, unnecessarily memory intensive. */
114818: #ifdef MOZ_WIDGET_GONK
114818: # define PLATFORM_LIKELY_MEMORY_CONSTRAINED
114818: #endif
114818: 
119320: #if !defined(PLATFORM_LIKELY_MEMORY_CONSTRAINED) && !defined(ARCH_ARMV6)
111235: # define PROFILE_DEFAULT_ENTRY 1000000
114818: #else
114818: # define PROFILE_DEFAULT_ENTRY 100000
114818: #endif
114818: 
114820: #if defined(PLATFORM_LIKELY_MEMORY_CONSTRAINED)
114820: /* A 1ms sampling interval has been shown to be a large perf hit
114820:  * (10fps) on memory-contrained (low-end) platforms, and additionally
114820:  * to yield different results from the profiler.  Where this is the
114820:  * important case, b2g, there are also many gecko processes which
114820:  * magnify these effects. */
114820: # define PROFILE_DEFAULT_INTERVAL 10
114820: #elif defined(ANDROID)
 93709: // We use a lower frequency on Android, in order to make things work
 93709: // more smoothly on phones.  This value can be adjusted later with
 93709: // some libunwind optimizations.
 93709: // In one sample measurement on Galaxy Nexus, out of about 700 backtraces,
 93709: // 60 of them took more than 25ms, and the average and standard deviation
 93709: // were 6.17ms and 9.71ms respectively.
 95805: 
 95805: // For now since we don't support stackwalking let's use 1ms since it's fast
 95805: // enough.
 95805: #define PROFILE_DEFAULT_INTERVAL 1
 93709: #else
 95805: #define PROFILE_DEFAULT_INTERVAL 1
 93709: #endif
 93709: #define PROFILE_DEFAULT_FEATURES NULL
 93709: #define PROFILE_DEFAULT_FEATURE_COUNT 0
 84290: 
 81024: // STORE_SEQUENCER: Because signals can interrupt our profile modification
 81024: //                  we need to make stores are not re-ordered by the compiler
 81024: //                  or hardware to make sure the profile is consistent at
 81024: //                  every point the signal can fire.
 84290: #ifdef V8_HOST_ARCH_ARM
 81024: // TODO Is there something cheaper that will prevent
 81024: //      memory stores from being reordered
 84290: 
 84290: typedef void (*LinuxKernelMemoryBarrierFunc)(void);
 84290: LinuxKernelMemoryBarrierFunc pLinuxKernelMemoryBarrier __attribute__((weak)) =
 84290:     (LinuxKernelMemoryBarrierFunc) 0xffff0fa0;
 84290: 
 84290: # define STORE_SEQUENCER() pLinuxKernelMemoryBarrier()
 84290: #elif defined(V8_HOST_ARCH_IA32) || defined(V8_HOST_ARCH_X64)
 84348: # if defined(_MSC_VER)
127676: #if _MSC_VER > 1400
127676: #  include <intrin.h>
127676: #else // _MSC_VER > 1400
 88104:     // MSVC2005 has a name collision bug caused when both <intrin.h> and <winnt.h> are included together.
 88104: #ifdef _WINNT_
 84348: #  define _interlockedbittestandreset _interlockedbittestandreset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
 84348: #  define _interlockedbittestandset _interlockedbittestandset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
 84348: #  include <intrin.h>
 87692: #else
 87692: #  include <intrin.h>
 87692: #  define _interlockedbittestandreset _interlockedbittestandreset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
 87692: #  define _interlockedbittestandset _interlockedbittestandset_NAME_CHANGED_TO_AVOID_MSVS2005_ERROR
 87692: #endif
 84348:    // Even though MSVC2005 has the intrinsic _ReadWriteBarrier, it fails to link to it when it's
 84348:    // not explicitly declared.
 84348: #  pragma intrinsic(_ReadWriteBarrier)
127676: #endif // _MSC_VER > 1400
 84348: #  define STORE_SEQUENCER() _ReadWriteBarrier();
 84348: # elif defined(__INTEL_COMPILER)
 84348: #  define STORE_SEQUENCER() __memory_barrier();
 84348: # elif __GNUC__
 84348: #  define STORE_SEQUENCER() asm volatile("" ::: "memory");
 84348: # else
 84348: #  error "Memory clobber not supported for your compiler."
 84348: # endif
 81024: #else
 81024: # error "Memory clobber not supported for your platform."
 81024: #endif
 81024: 
 81024: // Returns a handdle to pass on exit. This can check that we are popping the
 81024: // correct callstack.
108148: inline void* mozilla_sampler_call_enter(const char *aInfo, void *aFrameAddress = NULL, bool aCopy = false, uint32_t line = 0);
 81024: inline void  mozilla_sampler_call_exit(void* handle);
 81024: inline void  mozilla_sampler_add_marker(const char *aInfo);
 81024: 
 87178: void mozilla_sampler_start(int aEntries, int aInterval, const char** aFeatures, uint32_t aFeatureCount);
 84182: void mozilla_sampler_stop();
 84182: bool mozilla_sampler_is_active();
 84182: void mozilla_sampler_responsiveness(TimeStamp time);
111209: void mozilla_sampler_frame_number(int frameNumber);
 87177: const double* mozilla_sampler_get_responsiveness();
 84182: void mozilla_sampler_save();
 84182: char* mozilla_sampler_get_profile();
 91957: JSObject *mozilla_sampler_get_profile_data(JSContext *aCx);
 87178: const char** mozilla_sampler_get_features();
 81024: void mozilla_sampler_init();
124674: void mozilla_sampler_shutdown();
123586: void mozilla_sampler_print_location();
129261: // Lock the profiler. When locked the profiler is (1) stopped,
129261: // (2) profile data is cleared, (3) profiler-locked is fired.
129261: // This is used to lock down the profiler during private browsing
129261: void mozilla_sampler_lock();
129261: // Unlock the profiler, leaving it stopped and fires profiler-unlocked.
129261: void mozilla_sampler_unlock();
123586: 
 81024: namespace mozilla {
 81024: 
 81024: class NS_STACK_CLASS SamplerStackFrameRAII {
 81024: public:
 87692:   // we only copy the strings at save time, so to take multiple parameters we'd need to copy them then.
108148:   SamplerStackFrameRAII(const char *aInfo, uint32_t line) {
108148:     mHandle = mozilla_sampler_call_enter(aInfo, this, false, line);
 81024:   }
 81024:   ~SamplerStackFrameRAII() {
 81024:     mozilla_sampler_call_exit(mHandle);
 81024:   }
 81024: private:
 81024:   void* mHandle;
 81024: };
 81024: 
103095: static const int SAMPLER_MAX_STRING = 128;
103095: class NS_STACK_CLASS SamplerStackFramePrintfRAII {
103095: public:
103095:   // we only copy the strings at save time, so to take multiple parameters we'd need to copy them then.
108148:   SamplerStackFramePrintfRAII(const char *aDefault, uint32_t line, const char *aFormat, ...) {
103095:     if (mozilla_sampler_is_active()) {
103095:       va_list args;
103095:       va_start(args, aFormat);
103095:       char buff[SAMPLER_MAX_STRING];
103095: 
103095:       // We have to use seperate printf's because we're using
103095:       // the vargs.
103095: #if _MSC_VER
103095:       _vsnprintf(buff, SAMPLER_MAX_STRING, aFormat, args);
103095:       _snprintf(mDest, SAMPLER_MAX_STRING, "%s %s", aDefault, buff);
103095: #else
103095:       vsnprintf(buff, SAMPLER_MAX_STRING, aFormat, args);
103095:       snprintf(mDest, SAMPLER_MAX_STRING, "%s %s", aDefault, buff);
103095: #endif
108148:       mHandle = mozilla_sampler_call_enter(mDest, this, true, line);
103095:       va_end(args);
103095:     } else {
108148:       mHandle = mozilla_sampler_call_enter(aDefault, NULL, false, line);
103095:     }
103095:   }
103095:   ~SamplerStackFramePrintfRAII() {
103095:     mozilla_sampler_call_exit(mHandle);
103095:   }
103095: private:
103095:   char mDest[SAMPLER_MAX_STRING];
103095:   void* mHandle;
103095: };
103095: 
 81024: } //mozilla
 81024: 
108148: // A stack entry exists to allow the JS engine to inform SPS of the current
108148: // backtrace, but also to instrument particular points in C++ in case stack
108148: // walking is not available on the platform we are running on.
108148: //
108148: // Each entry has a descriptive string, a relevant stack address, and some extra
108148: // information the JS engine might want to inform SPS of. This class inherits
108148: // from the JS engine's version of the entry to ensure that the size and layout
108148: // of the two representations are consistent.
108148: class StackEntry : public js::ProfileEntry
103095: {
103095: public:
108148: 
108148:   bool isCopyLabel() volatile {
108148:     return !((uintptr_t)stackAddress() & 0x1);
103095:   }
103095: 
108148:   void setStackAddressCopy(void *sp, bool copy) volatile {
108148:     // Tagged pointer. Less significant bit used to track if mLabel needs a
108148:     // copy. Note that we don't need the last bit of the stack address for
108148:     // proper ordering. This is optimized for encoding within the JS engine's
108148:     // instrumentation, so we do the extra work here of encoding a bit.
108148:     // Last bit 1 = Don't copy, Last bit 0 = Copy.
108148:     if (copy) {
108148:       setStackAddress(reinterpret_cast<void*>(
108148:                         reinterpret_cast<uintptr_t>(sp) & ~0x1));
108148:     } else {
108148:       setStackAddress(reinterpret_cast<void*>(
108148:                         reinterpret_cast<uintptr_t>(sp) | 0x1));
103095:     }
108148:   }
103095: };
103095: 
 81024: // the SamplerStack members are read by signal
 81024: // handlers, so the mutation of them needs to be signal-safe.
 92114: struct ProfileStack
 81024: {
 81024: public:
 92114:   ProfileStack()
 81024:     : mStackPointer(0)
 81024:     , mMarkerPointer(0)
 81024:     , mQueueClearMarker(false)
115634:     , mRuntime(NULL)
104209:     , mStartJSSampling(false)
 81024:   { }
 81024: 
 81024:   void addMarker(const char *aMarker)
 81024:   {
125654:     char* markerCopy = strdup(aMarker);
125654:     mSignalLock = true;
125654:     STORE_SEQUENCER();
125654: 
 81024:     if (mQueueClearMarker) {
 81024:       clearMarkers();
 81024:     }
 81024:     if (!aMarker) {
 81024:       return; //discard
 81024:     }
 93674:     if (size_t(mMarkerPointer) == mozilla::ArrayLength(mMarkers)) {
 81024:       return; //array full, silently drop
 81024:     }
125654:     mMarkers[mMarkerPointer] = markerCopy;
125654:     mMarkerPointer++;
125654: 
125654:     mSignalLock = false;
 81024:     STORE_SEQUENCER();
 81024:   }
 81024: 
 81024:   // called within signal. Function must be reentrant
 81024:   const char* getMarker(int aMarkerId)
 81024:   {
125654:     // if mSignalLock then the stack is inconsistent because it's being
125654:     // modified by the profiled thread. Post pone these markers
125654:     // for the next sample. The odds of a livelock are nearly impossible
125654:     // and would show up in a profile as many sample in 'addMarker' thus
125654:     // we ignore this scenario.
125654:     // if mQueueClearMarker then we've the sampler thread has already
125654:     // thread the markers then they are pending deletion.
125654:     if (mSignalLock || mQueueClearMarker || aMarkerId < 0 ||
 94800:       static_cast<mozilla::sig_safe_t>(aMarkerId) >= mMarkerPointer) {
 81024:       return NULL;
 81024:     }
 81024:     return mMarkers[aMarkerId];
 81024:   }
 81024: 
 81024:   // called within signal. Function must be reentrant
 81024:   void clearMarkers()
 81024:   {
125654:     for (mozilla::sig_safe_t i = 0; i < mMarkerPointer; i++) {
125654:       free(mMarkers[i]);
125654:     }
 81024:     mMarkerPointer = 0;
 81024:     mQueueClearMarker = false;
 81024:   }
 81024: 
108148:   void push(const char *aName, uint32_t line)
 81024:   {
108148:     push(aName, NULL, false, line);
103095:   }
103095: 
108148:   void push(const char *aName, void *aStackAddress, bool aCopy, uint32_t line)
103095:   {
 93674:     if (size_t(mStackPointer) >= mozilla::ArrayLength(mStack)) {
103915:       mStackPointer++;
 81024:       return;
 81024:     }
 81024: 
 81024:     // Make sure we increment the pointer after the name has
 81024:     // been written such that mStack is always consistent.
108148:     mStack[mStackPointer].setLabel(aName);
108148:     mStack[mStackPointer].setStackAddressCopy(aStackAddress, aCopy);
108148:     mStack[mStackPointer].setLine(line);
103095: 
 81024:     // Prevent the optimizer from re-ordering these instructions
 84348:     STORE_SEQUENCER();
 81024:     mStackPointer++;
 81024:   }
 81024:   void pop()
 81024:   {
 81024:     mStackPointer--;
 81024:   }
 81024:   bool isEmpty()
 81024:   {
 81024:     return mStackPointer == 0;
 81024:   }
108148:   uint32_t stackSize() const
108148:   {
129543:     return std::min<uint32_t>(mStackPointer, mozilla::ArrayLength(mStack));
108148:   }
 81024: 
103915:   void sampleRuntime(JSRuntime *runtime) {
103915:     mRuntime = runtime;
129936:     if (!runtime) {
129936:       // JS shut down
129936:       return;
129936:     }
129936: 
103915:     JS_STATIC_ASSERT(sizeof(mStack[0]) == sizeof(js::ProfileEntry));
104307:     js::SetRuntimeProfilingStack(runtime,
103915:                                  (js::ProfileEntry*) mStack,
103915:                                  (uint32_t*) &mStackPointer,
103915:                                  mozilla::ArrayLength(mStack));
104307:     if (mStartJSSampling)
104307:       enableJSSampling();
104307:   }
104307:   void enableJSSampling() {
104307:     if (mRuntime) {
104307:       js::EnableRuntimeProfilingStack(mRuntime, true);
104209:       mStartJSSampling = false;
104209:     } else {
104209:       mStartJSSampling = true;
104209:     }
103915:   }
104307:   void disableJSSampling() {
104209:     mStartJSSampling = false;
104209:     if (mRuntime)
104307:       js::EnableRuntimeProfilingStack(mRuntime, false);
103915:   }
103915: 
 81024:   // Keep a list of active checkpoints
103095:   StackEntry volatile mStack[1024];
 81024:   // Keep a list of active markers to be applied to the next sample taken
125654:   char* mMarkers[1024];
108148:  private:
108148:   // This may exceed the length of mStack, so instead use the stackSize() method
108148:   // to determine the number of valid samples in mStack
125654:   mozilla::sig_safe_t mStackPointer;
125654:   // If this is set then it's not safe to read mStackPointer from the signal handler
125654:   volatile bool mSignalLock;
108148:  public:
 84348:   volatile mozilla::sig_safe_t mMarkerPointer;
 81024:   // We don't want to modify _markers from within the signal so we allow
 81024:   // it to queue a clear operation.
 84348:   volatile mozilla::sig_safe_t mQueueClearMarker;
103915:   // The runtime which is being sampled
103915:   JSRuntime *mRuntime;
104209:   // Start JS Profiling when possible
104209:   bool mStartJSSampling;
 81024: };
 81024: 
103915: inline ProfileStack* mozilla_profile_stack(void)
103915: {
103915:   if (!stack_key_initialized)
103915:     return NULL;
103915:   return tlsStack.get();
103915: }
103915: 
108148: inline void* mozilla_sampler_call_enter(const char *aInfo, void *aFrameAddress,
108148:                                         bool aCopy, uint32_t line)
 81024: {
 84289:   // check if we've been initialized to avoid calling pthread_getspecific
 98877:   // with a null tlsStack which will return undefined results.
 84289:   if (!stack_key_initialized)
 84289:     return NULL;
 84289: 
 98877:   ProfileStack *stack = tlsStack.get();
 84289:   // we can't infer whether 'stack' has been initialized
 84289:   // based on the value of stack_key_intiailized because
 84289:   // 'stack' is only intialized when a thread is being
 84289:   // profiled.
 81024:   if (!stack) {
 81024:     return stack;
 81024:   }
108148:   stack->push(aInfo, aFrameAddress, aCopy, line);
 81024: 
 81024:   // The handle is meant to support future changes
 81024:   // but for now it is simply use to save a call to
 81024:   // pthread_getspecific on exit. It also supports the
 81024:   // case where the sampler is initialized between
 81024:   // enter and exit.
 81024:   return stack;
 81024: }
 81024: 
 81024: inline void mozilla_sampler_call_exit(void *aHandle)
 81024: {
 81024:   if (!aHandle)
 81024:     return;
 81024: 
 92114:   ProfileStack *stack = (ProfileStack*)aHandle;
 81024:   stack->pop();
 81024: }
 81024: 
 81024: inline void mozilla_sampler_add_marker(const char *aMarker)
 81024: {
119845:   if (!stack_key_initialized)
119845:     return;
119845: 
125654:   // Don't insert a marker if we're not profiling to avoid
125654:   // the heap copy (malloc).
125654:   if (!mozilla_sampler_is_active()) {
125654:     return;
125654:   }
125654: 
 98877:   ProfileStack *stack = tlsStack.get();
 81024:   if (!stack) {
 81024:     return;
 81024:   }
 81024:   stack->addMarker(aMarker);
 81024: }
 81024: 
