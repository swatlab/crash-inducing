29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
18830:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS function support.
    1:  */
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsbit.h"
55477: #include "jsutil.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
31823: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
21866: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
52503: #include "jspropertytree.h"
47498: #include "jsproxy.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
    1: #include "jsexn.h"
18989: #include "jsstaticcheck.h"
32710: #include "jstracer.h"
    1: 
    1: #if JS_HAS_GENERATORS
    1: # include "jsiter.h"
    1: #endif
    1: 
11435: #if JS_HAS_XDR
11435: # include "jsxdrapi.h"
11435: #endif
11435: 
53520: #ifdef JS_METHODJIT
53520: #include "methodjit/MethodJIT.h"
53520: #endif
53520: 
30283: #include "jsatominlines.h"
42714: #include "jscntxtinlines.h"
51095: #include "jsfuninlines.h"
53840: #include "jsinterpinlines.h"
40410: #include "jsobjinlines.h"
30283: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
51090: inline JSObject *
51090: JSObject::getThrowTypeError() const
51090: {
51090:     return &getGlobal()->getReservedSlot(JSRESERVED_GLOBAL_THROWTYPEERROR).toObject();
51090: }
51090: 
    1: JSBool
48470: js_GetArgsValue(JSContext *cx, JSStackFrame *fp, Value *vp)
    1: {
    1:     JSObject *argsobj;
    1: 
53840:     if (fp->hasOverriddenArgs()) {
50510:         JS_ASSERT(fp->hasCallObj());
31823:         jsid id = ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
53840:         return fp->callObj().getProperty(cx, id, vp);
    1:     }
    1:     argsobj = js_GetArgsObject(cx, fp);
    1:     if (!argsobj)
    1:         return JS_FALSE;
48470:     vp->setObject(*argsobj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
48470: js_GetArgsProperty(JSContext *cx, JSStackFrame *fp, jsid id, Value *vp)
    1: {
53840:     JS_ASSERT(fp->isFunctionFrame());
53840: 
53840:     if (fp->hasOverriddenArgs()) {
50510:         JS_ASSERT(fp->hasCallObj());
31823: 
31823:         jsid argumentsid = ATOM_TO_JSID(cx->runtime->atomState.argumentsAtom);
48470:         Value v;
53840:         if (!fp->callObj().getProperty(cx, argumentsid, &v))
31823:             return false;
31823: 
    1:         JSObject *obj;
48470:         if (v.isPrimitive()) {
31823:             obj = js_ValueToNonNullObject(cx, v);
    1:             if (!obj)
31823:                 return false;
    1:         } else {
48470:             obj = &v.toObject();
    1:         }
31501:         return obj->getProperty(cx, id, vp);
    1:     }
    1: 
48470:     vp->setUndefined();
    1:     if (JSID_IS_INT(id)) {
31823:         uint32 arg = uint32(JSID_TO_INT(id));
50510:         JSObject *argsobj = fp->maybeArgsObj();
51120:         if (arg < fp->numActualArgs()) {
31823:             if (argsobj) {
48470:                 if (argsobj->getArgsElement(arg).isMagic(JS_ARGS_HOLE))
31823:                     return argsobj->getProperty(cx, id, vp);
31823:             }
53840:             *vp = fp->canonicalActualArg(arg);
    1:         } else {
    1:             /*
    1:              * Per ECMA-262 Ed. 3, 10.1.8, last bulleted item, do not share
    1:              * storage between the formal parameter and arguments[k] for all
 4127:              * fp->argc <= k && k < fp->fun->nargs.  For example, in
    1:              *
    1:              *   function f(x) { x = 42; return arguments[0]; }
    1:              *   f();
    1:              *
    1:              * the call to f should return undefined, not 42.  If fp->argsobj
    1:              * is null at this point, as it would be in the example, return
    1:              * undefined in *vp.
    1:              */
31823:             if (argsobj)
31823:                 return argsobj->getProperty(cx, id, vp);
    1:         }
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
50510:         JSObject *argsobj = fp->maybeArgsObj();
40864:         if (argsobj && argsobj->isArgsLengthOverridden())
31823:             return argsobj->getProperty(cx, id, vp);
51120:         vp->setInt32(fp->numActualArgs());
    1:     }
31823:     return true;
    1: }
31823: 
31823: static JSObject *
53840: NewArguments(JSContext *cx, JSObject *parent, uint32 argc, JSObject &callee)
31823: {
40405:     JSObject *proto;
40405:     if (!js_GetClassPrototype(cx, parent, JSProto_Object, &proto))
31823:         return NULL;
31823: 
55746:     JS_STATIC_ASSERT(JSObject::ARGS_CLASS_RESERVED_SLOTS == 2);
55746:     JSObject *argsobj = js_NewGCObject(cx, FINALIZE_OBJECT2);
40405:     if (!argsobj)
40405:         return NULL;
40405: 
52503:     ArgumentsData *data = (ArgumentsData *)
52503:         cx->malloc(offsetof(ArgumentsData, slots) + argc * sizeof(Value));
52503:     if (!data)
52503:         return NULL;
52503:     SetValueRangeToUndefined(data->slots, argc);
52503: 
52503:     /* Can't fail from here on, so initialize everything in argsobj. */
55746:     argsobj->init(cx, callee.getFunctionPrivate()->inStrictMode()
52503:                   ? &StrictArgumentsClass
52503:                   : &js_ArgumentsClass,
55746:                   proto, parent, NULL, false);
52503: 
52503:     argsobj->setMap(cx->runtime->emptyArgumentsShape);
52503: 
40864:     argsobj->setArgsLength(argc);
52503:     argsobj->setArgsData(data);
53840:     data->callee.setObject(callee);
51095: 
31823:     return argsobj;
31823: }
31823: 
55479: struct STATIC_SKIP_INFERENCE PutArg
31823: {
53840:     PutArg(Value *dst) : dst(dst) {}
53840:     Value *dst;
53840:     void operator()(uintN, Value *src) {
53840:         if (!dst->isMagic(JS_ARGS_HOLE))
53840:             *dst = *src;
53840:         ++dst;
31823:     }
53840: };
53840: 
    1: JSObject *
    1: js_GetArgsObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     /*
    1:      * We must be in a function activation; the function must be lightweight
    1:      * or else fp must have a variable object.
    1:      */
53840:     JS_ASSERT_IF(fp->fun()->isHeavyweight(), fp->hasCallObj());
53840: 
53840:     while (fp->isEvalOrDebuggerFrame())
53840:         fp = fp->prev();
    1: 
    1:     /* Create an arguments object for fp only if it lacks one. */
50510:     if (fp->hasArgsObj())
53840:         return &fp->argsObj();
    1: 
47497:     /* Compute the arguments object's parent slot from fp's scope chain. */
53840:     JSObject *global = fp->scopeChain().getGlobal();
53840:     JSObject *argsobj = NewArguments(cx, global, fp->numActualArgs(), fp->callee());
31447:     if (!argsobj)
31823:         return argsobj;
31447: 
51097:     /*
52503:      * Strict mode functions have arguments objects that copy the initial
52503:      * actual parameter values.  It is the caller's responsibility to get the
52503:      * arguments object before any parameters are modified!  (The emitter
52503:      * ensures this by synthesizing an arguments access at the start of any
52503:      * strict mode function that contains an assignment to a parameter, or
52503:      * that calls eval.)  Non-strict mode arguments use the frame pointer to
52503:      * retrieve up-to-date parameter values.
51097:      */
52503:     if (argsobj->isStrictArguments())
53840:         fp->forEachCanonicalActualArg(PutArg(argsobj->getArgsData()->slots));
52503:     else
31452:         argsobj->setPrivate(fp);
51097: 
53840:     fp->setArgsObj(*argsobj);
    1:     return argsobj;
    1: }
    1: 
31823: void
    1: js_PutArgsObject(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     JSObject &argsobj = fp->argsObj();
53840:     if (argsobj.isNormalArguments()) {
53840:         JS_ASSERT(argsobj.getPrivate() == fp);
53840:         fp->forEachCanonicalActualArg(PutArg(argsobj.getArgsData()->slots));
53840:         argsobj.setPrivate(NULL);
51097:     } else {
53840:         JS_ASSERT(!argsobj.getPrivate());
51097:     }
54832:     fp->clearArgsObj();
31823: }
    1: 
52503: #ifdef JS_TRACER
52503: 
    1: /*
31823:  * Traced versions of js_GetArgsObject and js_PutArgsObject.
    1:  */
31824: JSObject * JS_FASTCALL
53840: js_NewArgumentsOnTrace(JSContext *cx, JSObject *parent, uint32 argc, JSObject *callee)
31823: {
53840:     JSObject *argsobj = NewArguments(cx, parent, argc, *callee);
33110:     if (!argsobj)
33110:         return NULL;
51097: 
52503:     if (argsobj->isStrictArguments()) {
51097:         /*
51097:          * Strict mode callers must copy arguments into the created arguments
52503:          * object. The trace-JITting code is in TraceRecorder::newArguments.
51097:          */
51097:         JS_ASSERT(!argsobj->getPrivate());
51097:     } else {
52503:         argsobj->setPrivate(JS_ARGUMENTS_OBJECT_ON_TRACE);
51097:     }
51097: 
32709:     return argsobj;
    1: }
53840: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_NewArgumentsOnTrace, CONTEXT, OBJECT, UINT32, OBJECT,
49124:                      0, nanojit::ACCSET_STORE_ANY)
31823: 
31823: /* FIXME change the return type to void. */
31823: JSBool JS_FASTCALL
53840: js_PutArgumentsOnTrace(JSContext *cx, JSObject *argsobj, Value *args)
31823: {
51097:     JS_ASSERT(argsobj->isNormalArguments());
52503:     JS_ASSERT(argsobj->getPrivate() == JS_ARGUMENTS_OBJECT_ON_TRACE);
53840: 
53840:     /*
53840:      * TraceRecorder::putActivationObjects builds a single, contiguous array of
53840:      * the arguments, regardless of whether #actuals > #formals so there is no
53840:      * need to worry about actual vs. formal arguments.
53840:      */
53840:     Value *srcend = args + argsobj->getArgsInitialLength();
53840:     Value *dst = argsobj->getArgsData()->slots;
53840:     for (Value *src = args; src != srcend; ++src, ++dst) {
53840:         if (!dst->isMagic(JS_ARGS_HOLE))
53840:             *dst = *src;
53840:     }
53840: 
34328:     argsobj->setPrivate(NULL);
31823:     return true;
    1: }
53840: JS_DEFINE_CALLINFO_3(extern, BOOL, js_PutArgumentsOnTrace, CONTEXT, OBJECT, VALUEPTR, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
31823: 
52503: #endif /* JS_TRACER */
52503: 
    1: static JSBool
48470: args_delProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
40405:     JS_ASSERT(obj->isArguments());
    1: 
48470:     if (JSID_IS_INT(id)) {
48470:         uintN arg = uintN(JSID_TO_INT(id));
51091:         if (arg < obj->getArgsInitialLength())
48470:             obj->setArgsElement(arg, MagicValue(JS_ARGS_HOLE));
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
40864:         obj->setArgsLengthOverridden();
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom)) {
48470:         obj->setArgsCallee(MagicValue(JS_ARGS_HOLE));
    1:     }
31447:     return true;
    1: }
    1: 
28952: static JS_REQUIRES_STACK JSObject *
50500: WrapEscapingClosure(JSContext *cx, JSStackFrame *fp, JSFunction *fun)
28952: {
29009:     JS_ASSERT(fun->optimizedClosure());
28952:     JS_ASSERT(!fun->u.i.wrapper);
28952: 
28952:     /*
28952:      * We do not attempt to reify Call and Block objects on demand for outer
28952:      * scopes. This could be done (see the "v8" patch in bug 494235) but it is
28952:      * fragile in the face of ongoing compile-time optimization. Instead, the
28952:      * _DBG* opcodes used by wrappers created here must cope with unresolved
28952:      * upvars and throw them as reference errors. Caveat debuggers!
28952:      */
56729:     JSObject *scopeChain = GetScopeChain(cx, fp);
28952:     if (!scopeChain)
28952:         return NULL;
28952: 
50500:     JSObject *wfunobj = NewFunction(cx, scopeChain);
28952:     if (!wfunobj)
28952:         return NULL;
48470:     AutoObjectRooter tvr(cx, wfunobj);
28952: 
28952:     JSFunction *wfun = (JSFunction *) wfunobj;
32684:     wfunobj->setPrivate(wfun);
52503:     wfun->nargs = fun->nargs;
28952:     wfun->flags = fun->flags | JSFUN_HEAVYWEIGHT;
52503:     wfun->u.i.nvars = fun->u.i.nvars;
52503:     wfun->u.i.nupvars = fun->u.i.nupvars;
28952:     wfun->u.i.skipmin = fun->u.i.skipmin;
28952:     wfun->u.i.wrapper = true;
28952:     wfun->u.i.script = NULL;
52503:     wfun->u.i.names = fun->u.i.names;
28952:     wfun->atom = fun->atom;
28952: 
28952:     JSScript *script = fun->u.i.script;
32723:     jssrcnote *snbase = script->notes();
28952:     jssrcnote *sn = snbase;
28952:     while (!SN_IS_TERMINATOR(sn))
28952:         sn = SN_NEXT(sn);
28952:     uintN nsrcnotes = (sn - snbase) + 1;
28952: 
28952:     /* NB: GC must not occur before wscript is homed in wfun->u.i.script. */
54840:     JSScript *wscript = JSScript::NewScript(cx, script->length, nsrcnotes,
28952:                                             script->atomMap.length,
28952:                                             (script->objectsOffset != 0)
32723:                                             ? script->objects()->length
28952:                                             : 0,
28952:                                             fun->u.i.nupvars,
28952:                                             (script->regexpsOffset != 0)
32723:                                             ? script->regexps()->length
28952:                                             : 0,
28952:                                             (script->trynotesOffset != 0)
32723:                                             ? script->trynotes()->length
48470:                                             : 0,
48470:                                             (script->constOffset != 0)
48470:                                             ? script->consts()->length
52684:                                             : 0,
52555:                                             (script->globalsOffset != 0)
52555:                                             ? script->globals()->length
54840:                                             : 0,
54840:                                             script->nClosedArgs,
54840:                                             script->nClosedVars);
28952:     if (!wscript)
28952:         return NULL;
28952: 
28952:     memcpy(wscript->code, script->code, script->length);
28952:     wscript->main = wscript->code + (script->main - script->code);
28952: 
32723:     memcpy(wscript->notes(), snbase, nsrcnotes * sizeof(jssrcnote));
28952:     memcpy(wscript->atomMap.vector, script->atomMap.vector,
28952:            wscript->atomMap.length * sizeof(JSAtom *));
28952:     if (script->objectsOffset != 0) {
32723:         memcpy(wscript->objects()->vector, script->objects()->vector,
32723:                wscript->objects()->length * sizeof(JSObject *));
28952:     }
28952:     if (script->regexpsOffset != 0) {
32723:         memcpy(wscript->regexps()->vector, script->regexps()->vector,
32723:                wscript->regexps()->length * sizeof(JSObject *));
28952:     }
28952:     if (script->trynotesOffset != 0) {
32723:         memcpy(wscript->trynotes()->vector, script->trynotes()->vector,
32723:                wscript->trynotes()->length * sizeof(JSTryNote));
28952:     }
52555:     if (script->globalsOffset != 0) {
52555:         memcpy(wscript->globals()->vector, script->globals()->vector,
52555:                wscript->globals()->length * sizeof(GlobalSlotArray::Entry));
52555:     }
54840:     if (script->nClosedArgs + script->nClosedVars != 0)
54840:         script->copyClosedSlotsTo(wscript);
28952: 
28952:     if (wfun->u.i.nupvars != 0) {
32723:         JS_ASSERT(wfun->u.i.nupvars == wscript->upvars()->length);
32723:         memcpy(wscript->upvars()->vector, script->upvars()->vector,
28952:                wfun->u.i.nupvars * sizeof(uint32));
28952:     }
28952: 
28952:     jsbytecode *pc = wscript->code;
28952:     while (*pc != JSOP_STOP) {
52503:         /* FIXME should copy JSOP_TRAP? */
28952:         JSOp op = js_GetOpcode(cx, wscript, pc);
28952:         const JSCodeSpec *cs = &js_CodeSpec[op];
28952:         ptrdiff_t oplen = cs->length;
28952:         if (oplen < 0)
28952:             oplen = js_GetVariableBytecodeLength(pc);
28952: 
28952:         /*
53650:          * Rewrite JSOP_{GET,CALL}FCSLOT as JSOP_{GET,CALL}UPVAR_DBG for the
28952:          * case where fun is an escaping flat closure. This works because the
53650:          * UPVAR and FCSLOT ops by design have the same format: an upvar index
28952:          * immediate operand.
28952:          */
28952:         switch (op) {
28952:           case JSOP_GETUPVAR:       *pc = JSOP_GETUPVAR_DBG; break;
28952:           case JSOP_CALLUPVAR:      *pc = JSOP_CALLUPVAR_DBG; break;
52503:           case JSOP_GETFCSLOT:      *pc = JSOP_GETUPVAR_DBG; break;
52503:           case JSOP_CALLFCSLOT:     *pc = JSOP_CALLUPVAR_DBG; break;
28952:           case JSOP_DEFFUN_FC:      *pc = JSOP_DEFFUN_DBGFC; break;
28952:           case JSOP_DEFLOCALFUN_FC: *pc = JSOP_DEFLOCALFUN_DBGFC; break;
28952:           case JSOP_LAMBDA_FC:      *pc = JSOP_LAMBDA_DBGFC; break;
28952:           default:;
28952:         }
28952:         pc += oplen;
28952:     }
28952: 
28952:     /*
29009:      * Fill in the rest of wscript. This means if you add members to JSScript
29009:      * you must update this code. FIXME: factor into JSScript::clone method.
28952:      */
53848:     wscript->setVersion(script->getVersion());
28952:     wscript->nfixed = script->nfixed;
28952:     wscript->filename = script->filename;
28952:     wscript->lineno = script->lineno;
28952:     wscript->nslots = script->nslots;
28952:     wscript->staticLevel = script->staticLevel;
28952:     wscript->principals = script->principals;
54840:     wscript->noScriptRval = script->noScriptRval;
54840:     wscript->savedCallerFun = script->savedCallerFun;
54840:     wscript->hasSharps = script->hasSharps;
54840:     wscript->strictModeCode = script->strictModeCode;
54840:     wscript->compileAndGo = script->compileAndGo;
54840:     wscript->usesEval = script->usesEval;
54840:     wscript->usesArguments = script->usesArguments;
54840:     wscript->warnedAboutTwoArgumentEval = script->warnedAboutTwoArgumentEval;
28952:     if (wscript->principals)
28952:         JSPRINCIPALS_HOLD(cx, wscript->principals);
28952: #ifdef CHECK_SCRIPT_OWNER
28952:     wscript->owner = script->owner;
28952: #endif
28952: 
28952:     /* Deoptimize wfun from FUN_{FLAT,NULL}_CLOSURE to FUN_INTERPRETED. */
28952:     FUN_SET_KIND(wfun, JSFUN_INTERPRETED);
28952:     wfun->u.i.script = wscript;
28952:     return wfunobj;
28952: }
28952: 
    1: static JSBool
48470: ArgGetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
49124:     LeaveTrace(cx);
49124: 
48470:     if (!InstanceOf(cx, obj, &js_ArgumentsClass, NULL))
31447:         return true;
31447: 
48470:     if (JSID_IS_INT(id)) {
31447:         /*
31447:          * arg can exceed the number of arguments if a script changed the
31447:          * prototype to point to another Arguments object with a bigger argc.
31447:          */
48470:         uintN arg = uintN(JSID_TO_INT(id));
51091:         if (arg < obj->getArgsInitialLength()) {
55525:             JS_ASSERT(!obj->getArgsElement(arg).isMagic(JS_ARGS_HOLE));
57596:             if (obj->getArgsElement(arg).isMagic(JS_ARGS_HOLE))
57596:                 *(int *) 0xe0 = 0;
55525:             if (JSStackFrame *fp = (JSStackFrame *) obj->getPrivate())
53840:                 *vp = fp->canonicalActualArg(arg);
55525:             else
55525:                 *vp = obj->getArgsElement(arg);
31823:         }
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
40864:         if (!obj->isArgsLengthOverridden())
51091:             vp->setInt32(obj->getArgsInitialLength());
31447:     } else {
48470:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
48470:         const Value &v = obj->getArgsCallee();
48470:         if (!v.isMagic(JS_ARGS_HOLE)) {
29009:             /*
29009:              * If this function or one in it needs upvars that reach above it
29009:              * in the scope chain, it must not be a null closure (it could be a
29009:              * flat closure, or an unoptimized closure -- the latter itself not
29009:              * necessarily heavyweight). Rather than wrap here, we simply throw
29009:              * to reduce code size and tell debugger users the truth instead of
29009:              * passing off a fibbing wrapper.
29009:              */
48470:             if (GET_FUNCTION_PRIVATE(cx, &v.toObject())->needsWrapper()) {
28964:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28964:                                      JSMSG_OPTIMIZED_CLOSURE_LEAK);
31447:                 return false;
28964:             }
31823:             *vp = v;
28964:         }
    1:     }
31447:     return true;
    1: }
    1: 
    1: static JSBool
48470: ArgSetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
35056: #ifdef JS_TRACER
35054:     // To be able to set a property here on trace, we would have to make
35054:     // sure any updates also get written back to the trace native stack.
35054:     // For simplicity, we just leave trace, since this is presumably not
35054:     // a common operation.
35054:     if (JS_ON_TRACE(cx)) {
37741:         DeepBail(cx);
35054:         return false;
35054:     }
35056: #endif
35054: 
48470:     if (!InstanceOf(cx, obj, &js_ArgumentsClass, NULL))
31447:         return true;
31447: 
48470:     if (JSID_IS_INT(id)) {
48470:         uintN arg = uintN(JSID_TO_INT(id));
51091:         if (arg < obj->getArgsInitialLength()) {
31823:             JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
31823:             if (fp) {
54844:                 JSScript *script = fp->functionScript();
54844:                 if (script->usesArguments)
53840:                     fp->canonicalActualArg(arg) = *vp;
31823:                 return true;
31823:             }
31447:         }
31447:     } else {
48470:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom) ||
48470:                   JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom));
31447:     }
31823: 
31823:     /*
31823:      * For simplicity we use delete/set to replace the property with one
51095:      * backed by the default Object getter and setter. Note that we rely on
51095:      * args_delProperty to clear the corresponding reserved slot so the GC can
31823:      * collect its value.
31823:      */
40389:     AutoValueRooter tvr(cx);
54169:     return js_DeleteProperty(cx, obj, id, tvr.addr(), false) &&
54169:            js_SetProperty(cx, obj, id, vp, false);
31447: }
31447: 
31447: static JSBool
48470: args_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
31447:              JSObject **objp)
31447: {
51095:     JS_ASSERT(obj->isNormalArguments());
31823: 
31447:     *objp = NULL;
48470:     bool valid = false;
51099:     uintN attrs = JSPROP_SHARED;
48470:     if (JSID_IS_INT(id)) {
48470:         uint32 arg = uint32(JSID_TO_INT(id));
51099:         attrs = JSPROP_ENUMERATE | JSPROP_SHARED;
51091:         if (arg < obj->getArgsInitialLength() && !obj->getArgsElement(arg).isMagic(JS_ARGS_HOLE))
48470:             valid = true;
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
40864:         if (!obj->isArgsLengthOverridden())
48470:             valid = true;
48470:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom)) {
51095:         if (!obj->getArgsCallee().isMagic(JS_ARGS_HOLE))
51095:             valid = true;
31447:     }
31823: 
48470:     if (valid) {
48470:         Value tmp = UndefinedValue();
51099:         if (!js_DefineProperty(cx, obj, id, &tmp, ArgGetter, ArgSetter, attrs))
31823:             return JS_FALSE;
31447:         *objp = obj;
31823:     }
31447:     return true;
31447: }
31447: 
31447: static JSBool
31447: args_enumerate(JSContext *cx, JSObject *obj)
31447: {
51095:     JS_ASSERT(obj->isNormalArguments());
31447: 
    1:     /*
31823:      * Trigger reflection in args_resolve using a series of js_LookupProperty
31823:      * calls.
    1:      */
51091:     int argc = int(obj->getArgsInitialLength());
31447:     for (int i = -2; i != argc; i++) {
31447:         jsid id = (i == -2)
31447:                   ? ATOM_TO_JSID(cx->runtime->atomState.lengthAtom)
31447:                   : (i == -1)
31447:                   ? ATOM_TO_JSID(cx->runtime->atomState.calleeAtom)
48470:                   : INT_TO_JSID(i);
31447: 
31447:         JSObject *pobj;
31447:         JSProperty *prop;
31447:         if (!js_LookupProperty(cx, obj, id, &pobj, &prop))
31447:             return false;
    1:     }
31447:     return true;
    1: }
    1: 
56593: static JSBool
51095: StrictArgGetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
51095: {
51095:     LeaveTrace(cx);
51095: 
51095:     if (!InstanceOf(cx, obj, &StrictArgumentsClass, NULL))
51095:         return true;
51095: 
51095:     if (JSID_IS_INT(id)) {
51095:         /*
51095:          * arg can exceed the number of arguments if a script changed the
51095:          * prototype to point to another Arguments object with a bigger argc.
51095:          */
51095:         uintN arg = uintN(JSID_TO_INT(id));
51095:         if (arg < obj->getArgsInitialLength()) {
51095:             const Value &v = obj->getArgsElement(arg);
51095:             if (!v.isMagic(JS_ARGS_HOLE))
51095:                 *vp = v;
51095:         }
51095:     } else {
51095:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
51095:         if (!obj->isArgsLengthOverridden())
51095:             vp->setInt32(obj->getArgsInitialLength());
51095:     }
51095:     return true;
51095: }
51095: 
56593: static JSBool
51095: StrictArgSetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
51095: {
51095:     if (!InstanceOf(cx, obj, &StrictArgumentsClass, NULL))
51095:         return true;
51095: 
51095:     if (JSID_IS_INT(id)) {
51095:         uintN arg = uintN(JSID_TO_INT(id));
51095:         if (arg < obj->getArgsInitialLength()) {
51095:             obj->setArgsElement(arg, *vp);
51095:             return true;
51095:         }
51095:     } else {
51095:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
51095:     }
51095: 
51095:     /*
51095:      * For simplicity we use delete/set to replace the property with one
51095:      * backed by the default Object getter and setter. Note that we rely on
51095:      * args_delProperty to clear the corresponding reserved slot so the GC can
51095:      * collect its value.
51095:      */
51095:     AutoValueRooter tvr(cx);
54169:     return js_DeleteProperty(cx, obj, id, tvr.addr(), true) &&
54169:            js_SetProperty(cx, obj, id, vp, true);
51095: }
51095: 
56593: static JSBool
51095: strictargs_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags, JSObject **objp)
51095: {
51095:     JS_ASSERT(obj->isStrictArguments());
51095: 
51095:     *objp = NULL;
51095:     bool valid = false;
51099:     uintN attrs = JSPROP_SHARED;
51095:     if (JSID_IS_INT(id)) {
51095:         uint32 arg = uint32(JSID_TO_INT(id));
51099:         attrs = JSPROP_SHARED | JSPROP_ENUMERATE;
51095:         if (arg < obj->getArgsInitialLength() && !obj->getArgsElement(arg).isMagic(JS_ARGS_HOLE))
51095:             valid = true;
51095:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
51095:         if (!obj->isArgsLengthOverridden())
51095:             valid = true;
51095:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.calleeAtom)) {
51095:         Value tmp = UndefinedValue();
51095:         PropertyOp throwTypeError = CastAsPropertyOp(obj->getThrowTypeError());
51095:         uintN attrs = JSPROP_PERMANENT | JSPROP_GETTER | JSPROP_SETTER | JSPROP_SHARED;
51095:         if (!js_DefineProperty(cx, obj, id, &tmp, throwTypeError, throwTypeError, attrs))
51095:             return false;
51095: 
51095:         *objp = obj;
51095:         return true;
51095:     } else if (JSID_IS_ATOM(id, cx->runtime->atomState.callerAtom)) {
51095:         /*
51095:          * Strict mode arguments objects have an immutable poison-pill caller
51095:          * property that throws a TypeError on getting or setting.
51095:          */
51095:         PropertyOp throwTypeError = CastAsPropertyOp(obj->getThrowTypeError());
51095:         Value tmp = UndefinedValue();
51095:         if (!js_DefineProperty(cx, obj, id, &tmp, throwTypeError, throwTypeError,
51095:                                JSPROP_PERMANENT | JSPROP_GETTER | JSPROP_SETTER | JSPROP_SHARED)) {
51095:             return false;
51095:         }
51095: 
51095:         *objp = obj;
51095:         return true;
51095:     }
51095: 
51095:     if (valid) {
51095:         Value tmp = UndefinedValue();
51099:         if (!js_DefineProperty(cx, obj, id, &tmp, StrictArgGetter, StrictArgSetter, attrs))
51099:             return false;
51095:         *objp = obj;
51095:     }
51095:     return true;
51095: }
51095: 
56593: static JSBool
51095: strictargs_enumerate(JSContext *cx, JSObject *obj)
51095: {
51095:     JS_ASSERT(obj->isStrictArguments());
51095: 
51095:     /*
51095:      * Trigger reflection in strictargs_resolve using a series of
56567:      * js_LookupProperty calls.
51095:      */
51095:     JSObject *pobj;
51095:     JSProperty *prop;
51095: 
51095:     // length
51095:     if (!js_LookupProperty(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom), &pobj, &prop))
51095:         return false;
51095: 
51095:     // callee
51095:     if (!js_LookupProperty(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.calleeAtom), &pobj, &prop))
51095:         return false;
51095: 
51095:     // caller
51095:     if (!js_LookupProperty(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.callerAtom), &pobj, &prop))
51095:         return false;
51095: 
51095:     for (uint32 i = 0, argc = obj->getArgsInitialLength(); i < argc; i++) {
51095:         if (!js_LookupProperty(cx, obj, INT_TO_JSID(i), &pobj, &prop))
51095:             return false;
51095:     }
51095: 
51095:     return true;
51095: }
51095: 
52503: static void
52503: args_finalize(JSContext *cx, JSObject *obj)
52503: {
52503:     cx->free((void *) obj->getArgsData());
52503: }
52503: 
    1: /*
42714:  * If a generator's arguments or call object escapes, and the generator frame
42714:  * is not executing, the generator object needs to be marked because it is not
42714:  * otherwise reachable. An executing generator is rooted by its invocation.  To
42714:  * distinguish the two cases (which imply different access paths to the
42714:  * generator object), we use the JSFRAME_FLOATING_GENERATOR flag, which is only
42714:  * set on the JSStackFrame kept in the generator object's JSGenerator.
    1:  */
52503: static inline void
52503: MaybeMarkGenerator(JSTracer *trc, JSObject *obj)
    1: {
52503: #if JS_HAS_GENERATORS
31823:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
42714:     if (fp && fp->isFloatingGenerator()) {
52503:         JSObject *genobj = js_FloatingFrameToGenerator(fp)->obj;
53840:         MarkObject(trc, *genobj, "generator object");
  583:     }
52503: #endif
    1: }
52503: 
52503: static void
52503: args_trace(JSTracer *trc, JSObject *obj)
52503: {
52503:     JS_ASSERT(obj->isArguments());
52503:     if (obj->getPrivate() == JS_ARGUMENTS_OBJECT_ON_TRACE) {
52503:         JS_ASSERT(!obj->isStrictArguments());
52503:         return;
52503:     }
52503: 
52503:     ArgumentsData *data = obj->getArgsData();
52503:     if (data->callee.isObject())
53840:         MarkObject(trc, data->callee.toObject(), js_callee_str);
52503:     MarkValueRange(trc, obj->getArgsInitialLength(), data->slots, js_arguments_str);
52503: 
52503:     MaybeMarkGenerator(trc, obj);
52503: }
    1: 
    1: /*
52503:  * The Arguments classes aren't initialized via js_InitClass, because arguments
48462:  * objects have the initial value of Object.prototype as their [[Prototype]].
48462:  * However, Object.prototype.toString.call(arguments) === "[object Arguments]"
51095:  * per ES5 (although not ES3), so the class name is "Arguments" rather than
48462:  * "Object".
    1:  *
    1:  * The JSClass functions below collaborate to lazily reflect and synchronize
    1:  * actual argument values, argument count, and callee function object stored
    1:  * in a JSStackFrame with their corresponding property values in the frame's
    1:  * arguments object.
    1:  */
48470: Class js_ArgumentsClass = {
48462:     "Arguments",
31823:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
52503:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::ARGS_CLASS_RESERVED_SLOTS) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
48622:     PropertyStub,   /* addProperty */
48622:     args_delProperty,
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     args_enumerate,
48622:     (JSResolveOp) args_resolve,
48622:     ConvertStub,
52503:     args_finalize,  /* finalize   */
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     NULL,           /* xdrObject   */
48622:     NULL,           /* hasInstance */
52503:     JS_CLASS_TRACE(args_trace)
    1: };
    1: 
51095: namespace js {
51095: 
51095: /*
51095:  * Strict mode arguments is significantly less magical than non-strict mode
51095:  * arguments, so it is represented by a different class while sharing some
51095:  * functionality.
51095:  */
51095: Class StrictArgumentsClass = {
51095:     "Arguments",
51095:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
52503:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::ARGS_CLASS_RESERVED_SLOTS) |
51095:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
51095:     PropertyStub,   /* addProperty */
51095:     args_delProperty,
51095:     PropertyStub,   /* getProperty */
51095:     PropertyStub,   /* setProperty */
51095:     strictargs_enumerate,
51095:     reinterpret_cast<JSResolveOp>(strictargs_resolve),
51095:     ConvertStub,
52503:     args_finalize,  /* finalize   */
51095:     NULL,           /* reserved0   */
51095:     NULL,           /* checkAccess */
51095:     NULL,           /* call        */
51095:     NULL,           /* construct   */
51095:     NULL,           /* xdrObject   */
51095:     NULL,           /* hasInstance */
52503:     JS_CLASS_TRACE(args_trace)
51095: };
51095: 
51095: }
51095: 
28952: /*
28952:  * A Declarative Environment object stores its active JSStackFrame pointer in
28952:  * its private slot, just as Call and Arguments objects do.
28952:  */
48470: Class js_DeclEnvClass = {
27319:     js_Object_str,
28952:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub
27319: };
27319: 
29888: static JSBool
48470: CheckForEscapingClosure(JSContext *cx, JSObject *obj, Value *vp)
28952: {
52503:     JS_ASSERT(obj->isCall() || obj->getClass() == &js_DeclEnvClass);
28952: 
48470:     const Value &v = *vp;
48470: 
48470:     JSObject *funobj;
48470:     if (IsFunctionObject(v, &funobj)) {
28952:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
28952: 
28952:         /*
28952:          * Any escaping null or flat closure that reaches above itself or
28952:          * contains nested functions that reach above it must be wrapped.
28952:          * We can wrap only when this Call or Declarative Environment obj
28952:          * still has an active stack frame associated with it.
28952:          */
29009:         if (fun->needsWrapper()) {
37741:             LeaveTrace(cx);
29888: 
31823:             JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
28952:             if (fp) {
50500:                 JSObject *wrapper = WrapEscapingClosure(cx, fp, fun);
28952:                 if (!wrapper)
28952:                     return false;
48470:                 vp->setObject(*wrapper);
28952:                 return true;
28952:             }
28952: 
28952:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28952:                                  JSMSG_OPTIMIZED_CLOSURE_LEAK);
28952:             return false;
28952:         }
28952:     }
28952:     return true;
28952: }
28952: 
29888: static JSBool
48470: CalleeGetter(JSContext *cx, JSObject *obj, jsid id, Value *vp)
28952: {
28952:     return CheckForEscapingClosure(cx, obj, vp);
28952: }
28952: 
37694: static JSObject *
53840: NewCallObject(JSContext *cx, JSFunction *fun, JSObject &scopeChain, JSObject &callee)
37694: {
55746:     size_t vars = fun->countArgsAndVars();
55746:     size_t slots = JSObject::CALL_RESERVED_SLOTS + vars;
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(slots);
55746: 
55746:     JSObject *callobj = js_NewGCObject(cx, kind);
43221:     if (!callobj)
37694:         return NULL;
43221: 
55746:     /* Init immediately to avoid GC seeing a half-init'ed object. */
55746:     callobj->init(cx, &js_CallClass, NULL, &scopeChain, NULL, false);
52503:     callobj->setMap(fun->u.i.names);
52503: 
52503:     /* This must come after callobj->lastProp has been set. */
55746:     if (!callobj->ensureInstanceReservedSlots(cx, vars))
43221:         return NULL;
52503: 
52503: #ifdef DEBUG
52503:     for (Shape::Range r = callobj->lastProp; !r.empty(); r.popFront()) {
52503:         const Shape &s = r.front();
52503:         if (s.slot != SHAPE_INVALID_SLOT) {
53652:             JS_ASSERT(s.slot + 1 == callobj->slotSpan());
52503:             break;
52503:         }
52503:     }
52503: #endif
53840: 
53840:     callobj->setCallObjCallee(callee);
37694:     return callobj;
37694: }
37694: 
47497: static inline JSObject *
47497: NewDeclEnvObject(JSContext *cx, JSStackFrame *fp)
47497: {
55746:     JSObject *envobj = js_NewGCObject(cx, FINALIZE_OBJECT2);
47497:     if (!envobj)
47497:         return NULL;
47497: 
55746:     envobj->init(cx, &js_DeclEnvClass, NULL, &fp->scopeChain(), fp, false);
52503:     envobj->setMap(cx->runtime->emptyDeclEnvShape);
47497:     return envobj;
47497: }
47497: 
    1: JSObject *
25217: js_GetCallObject(JSContext *cx, JSStackFrame *fp)
    1: {
    1:     /* Create a call object for fp only if it lacks one. */
53840:     JS_ASSERT(fp->isFunctionFrame());
50510:     if (fp->hasCallObj())
53840:         return &fp->callObj();
    1: 
25217: #ifdef DEBUG
25217:     /* A call object should be a frame's outermost scope chain element.  */
53840:     Class *clasp = fp->scopeChain().getClass();
52503:     if (clasp == &js_WithClass || clasp == &js_BlockClass)
53840:         JS_ASSERT(fp->scopeChain().getPrivate() != js_FloatingFrameIfGenerator(cx, fp));
52503:     else if (clasp == &js_CallClass)
53840:         JS_ASSERT(fp->scopeChain().getPrivate() != fp);
25217: #endif
    1: 
25217:     /*
27319:      * Create the call object, using the frame's enclosing scope as its
27319:      * parent, and link the call to its stack frame. For a named function
27319:      * expression Call's parent points to an environment object holding
27319:      * function's name.
25217:      */
51056:     JSAtom *lambdaName =
53840:         (fp->fun()->flags & JSFUN_LAMBDA) ? fp->fun()->atom : NULL;
27319:     if (lambdaName) {
47497:         JSObject *envobj = NewDeclEnvObject(cx, fp);
47497:         if (!envobj)
27660:             return NULL;
47497: 
47497:         /* Root envobj before js_DefineNativeProperty (-> JSClass.addProperty). */
53840:         fp->setScopeChainNoCallObj(*envobj);
53840:         if (!js_DefineNativeProperty(cx, &fp->scopeChain(), ATOM_TO_JSID(lambdaName),
53840:                                      ObjectValue(fp->callee()),
28952:                                      CalleeGetter, NULL,
28312:                                      JSPROP_PERMANENT | JSPROP_READONLY,
28312:                                      0, 0, NULL)) {
28312:             return NULL;
28312:         }
27319:     }
27539: 
53840:     JSObject *callobj = NewCallObject(cx, fp->fun(), fp->scopeChain(), fp->callee());
37694:     if (!callobj)
    1:         return NULL;
15588: 
31452:     callobj->setPrivate(fp);
53840:     JS_ASSERT(fp->fun() == fp->callee().getFunctionPrivate());
    1: 
25217:     /*
25217:      * Push callobj on the top of the scope chain, and make it the
25217:      * variables object.
25217:      */
53840:     fp->setScopeChainAndCallObj(*callobj);
    1:     return callobj;
    1: }
    1: 
37694: JSObject * JS_FASTCALL
37694: js_CreateCallObjectOnTrace(JSContext *cx, JSFunction *fun, JSObject *callee, JSObject *scopeChain)
37694: {
37694:     JS_ASSERT(!js_IsNamedLambda(fun));
53840:     JS_ASSERT(scopeChain);
53840:     return NewCallObject(cx, fun, *scopeChain, *callee);
37694: }
37694: 
39910: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_CreateCallObjectOnTrace, CONTEXT, FUNCTION, OBJECT, OBJECT,
48613:                      0, nanojit::ACCSET_STORE_ANY)
37694: 
37694: inline static void
53840: CopyValuesToCallObject(JSObject &callobj, uintN nargs, Value *argv, uintN nvars, Value *slots)
37694: {
55746:     JS_ASSERT(callobj.numSlots() >= JSObject::CALL_RESERVED_SLOTS + nargs + nvars);
55746:     Value *base = callobj.getSlots() + JSObject::CALL_RESERVED_SLOTS;
55746:     memcpy(base, argv, nargs * sizeof(Value));
55746:     memcpy(base + nargs, slots, nvars * sizeof(Value));
37694: }
37694: 
31823: void
    1: js_PutCallObject(JSContext *cx, JSStackFrame *fp)
    1: {
53840:     JSObject &callobj = fp->callObj();
31447: 
31823:     /* Get the arguments object to snapshot fp's actual argument values. */
50510:     if (fp->hasArgsObj()) {
53840:         if (!fp->hasOverriddenArgs())
53840:             callobj.setCallObjArguments(ObjectValue(fp->argsObj()));
31823:         js_PutArgsObject(cx, fp);
31447:     }
31447: 
53840:     JSFunction *fun = fp->fun();
53840:     JS_ASSERT(fun == callobj.getCallObjCalleeFunction());
31447:     uintN n = fun->countArgsAndVars();
    1: 
15588:     if (n != 0) {
55746:         JS_ASSERT(JSFunction::CLASS_RESERVED_SLOTS + n <= callobj.numSlots());
53840: 
53520:         uint32 nargs = fun->nargs;
53520:         uint32 nvars = fun->u.i.nvars;
53520: 
53840:         JSScript *script = fun->u.i.script;
54897:         if (script->usesEval
54897: #ifdef JS_METHODJIT
54897:             || script->debugMode
54897: #endif
54897:             ) {
54840:             CopyValuesToCallObject(callobj, nargs, fp->formalArgs(), nvars, fp->slots());
54840:         } else {
54840:             /*
54840:              * For each arg & var that is closed over, copy it from the stack
54840:              * into the call object.
54840:              */
54840:             JSScript *script = fun->u.i.script;
54840:             uint32 nclosed = script->nClosedArgs;
54840:             for (uint32 i = 0; i < nclosed; i++) {
54840:                 uint32 e = script->getClosedArg(i);
55746:                 callobj.setSlot(JSObject::CALL_RESERVED_SLOTS + e, fp->formalArg(e));
54840:             }
54840: 
54840:             nclosed = script->nClosedVars;
54840:             for (uint32 i = 0; i < nclosed; i++) {
54840:                 uint32 e = script->getClosedVar(i);
55746:                 callobj.setSlot(JSObject::CALL_RESERVED_SLOTS + nargs + e, fp->slots()[e]);
53520:             }
53520:         }
15588:     }
30732: 
30732:     /* Clear private pointers to fp, which is about to go away (js_Invoke). */
37694:     if (js_IsNamedLambda(fun)) {
53840:         JSObject *env = callobj.getParent();
28952: 
40410:         JS_ASSERT(env->getClass() == &js_DeclEnvClass);
32684:         JS_ASSERT(env->getPrivate() == fp);
31452:         env->setPrivate(NULL);
28952:     }
28952: 
53840:     callobj.setPrivate(NULL);
54832:     fp->clearCallObj();
    1: }
    1: 
37694: JSBool JS_FASTCALL
53840: js_PutCallObjectOnTrace(JSContext *cx, JSObject *callobj, uint32 nargs, Value *argv,
48470:                         uint32 nvars, Value *slots)
37694: {
53840:     JS_ASSERT(callobj->isCall());
53840:     JS_ASSERT(!callobj->getPrivate());
37694: 
37694:     uintN n = nargs + nvars;
37694:     if (n != 0)
53840:         CopyValuesToCallObject(*callobj, nargs, argv, nvars, slots);
37694: 
37694:     return true;
37694: }
37694: 
48470: JS_DEFINE_CALLINFO_6(extern, BOOL, js_PutCallObjectOnTrace, CONTEXT, OBJECT, UINT32, VALUEPTR,
48613:                      UINT32, VALUEPTR, 0, nanojit::ACCSET_STORE_ANY)
37694: 
39916: enum JSCallPropertyKind {
13706:     JSCPK_ARGUMENTS,
13706:     JSCPK_ARG,
39916:     JSCPK_VAR,
39916:     JSCPK_UPVAR
39916: };
13706: 
13706: static JSBool
48470: CallPropertyOp(JSContext *cx, JSObject *obj, jsid id, Value *vp,
39916:                JSCallPropertyKind kind, JSBool setter = false)
13706: {
52503:     JS_ASSERT(obj->isCall());
39919: 
39919:     uintN i = 0;
39919:     if (kind != JSCPK_ARGUMENTS) {
48470:         JS_ASSERT((int16) JSID_TO_INT(id) == JSID_TO_INT(id));
48470:         i = (uint16) JSID_TO_INT(id);
39919:     }
39916: 
48470:     Value *array;
39916:     if (kind == JSCPK_UPVAR) {
53840:         JSObject &callee = obj->getCallObjCallee();
39916: 
39916: #ifdef DEBUG
53840:         JSFunction *callee_fun = (JSFunction *) callee.getPrivate();
39916:         JS_ASSERT(FUN_FLAT_CLOSURE(callee_fun));
39916:         JS_ASSERT(i < callee_fun->u.i.nupvars);
39916: #endif
39916: 
53840:         array = callee.getFlatClosureUpvars();
39916:     } else {
53840:         JSFunction *fun = obj->getCallObjCalleeFunction();
39916:         JS_ASSERT_IF(kind == JSCPK_ARG, i < fun->nargs);
39916:         JS_ASSERT_IF(kind == JSCPK_VAR, i < fun->u.i.nvars);
39916: 
39916:         JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
13706: 
13706:         if (kind == JSCPK_ARGUMENTS) {
13706:             if (setter) {
15588:                 if (fp)
53840:                     fp->setOverriddenArgs();
53840:                 obj->setCallObjArguments(*vp);
15588:             } else {
53840:                 if (fp && !fp->hasOverriddenArgs()) {
13706:                     JSObject *argsobj;
13706: 
13706:                     argsobj = js_GetArgsObject(cx, fp);
13706:                     if (!argsobj)
39916:                         return false;
48470:                     vp->setObject(*argsobj);
15588:                 } else {
53840:                     *vp = obj->getCallObjArguments();
15588:                 }
13706:             }
39916:             return true;
13706:         }
13706: 
15588:         if (!fp) {
55746:             i += JSObject::CALL_RESERVED_SLOTS;
15588:             if (kind == JSCPK_VAR)
15588:                 i += fun->nargs;
15588:             else
15588:                 JS_ASSERT(kind == JSCPK_ARG);
52503: 
55746:             array = obj->getSlots();
52503:         } else if (kind == JSCPK_ARG) {
53840:             array = fp->formalArgs();
13706:         } else {
13706:             JS_ASSERT(kind == JSCPK_VAR);
42714:             array = fp->slots();
13706:         }
39916:     }
39916: 
25514:     if (setter) {
25514:         GC_POKE(cx, array[i]);
13706:         array[i] = *vp;
25514:     } else {
13706:         *vp = array[i];
25514:     }
39916:     return true;
    1: }
    1: 
    1: static JSBool
48470: GetCallArguments(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARGUMENTS);
13706: }
13706: 
13706: static JSBool
48470: SetCallArguments(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARGUMENTS, true);
13706: }
13706: 
13706: JSBool
48470: js_GetCallArg(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARG);
13706: }
13706: 
30848: JSBool
48470: SetCallArg(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_ARG, true);
39916: }
39916: 
39916: JSBool
48470: GetFlatUpvar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
39916: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_UPVAR);
39916: }
39916: 
39916: JSBool
48470: SetFlatUpvar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
39916: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_UPVAR, true);
13706: }
13706: 
13706: JSBool
48470: js_GetCallVar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_VAR);
29009: }
29009: 
29009: JSBool
48470: js_GetCallVarChecked(JSContext *cx, JSObject *obj, jsid id, Value *vp)
29009: {
39916:     if (!CallPropertyOp(cx, obj, id, vp, JSCPK_VAR))
39916:         return false;
28952: 
28952:     return CheckForEscapingClosure(cx, obj, vp);
13706: }
13706: 
30848: JSBool
48470: SetCallVar(JSContext *cx, JSObject *obj, jsid id, Value *vp)
13706: {
39916:     return CallPropertyOp(cx, obj, id, vp, JSCPK_VAR, true);
13706: }
13706: 
48470: #if JS_TRACER
30848: JSBool JS_FASTCALL
48470: js_SetCallArg(JSContext *cx, JSObject *obj, jsid slotid, ValueArgType arg)
30848: {
48470:     Value argcopy = ValueArgToConstRef(arg);
48470:     return CallPropertyOp(cx, obj, slotid, &argcopy, JSCPK_ARG, true);
30848: }
48470: JS_DEFINE_CALLINFO_4(extern, BOOL, js_SetCallArg, CONTEXT, OBJECT, JSID, VALUE, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
30848: 
30848: JSBool JS_FASTCALL
48470: js_SetCallVar(JSContext *cx, JSObject *obj, jsid slotid, ValueArgType arg)
30848: {
48470:     Value argcopy = ValueArgToConstRef(arg);
48470:     return CallPropertyOp(cx, obj, slotid, &argcopy, JSCPK_VAR, true);
30848: }
48470: JS_DEFINE_CALLINFO_4(extern, BOOL, js_SetCallVar, CONTEXT, OBJECT, JSID, VALUE, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
48470: #endif
30848: 
 3624: static JSBool
48470: call_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:              JSObject **objp)
    1: {
52503:     JS_ASSERT(obj->isCall());
39928:     JS_ASSERT(!obj->getProto());
28397: 
48470:     if (!JSID_IS_ATOM(id))
    1:         return JS_TRUE;
    1: 
52503: #ifdef DEBUG
53840:     JSFunction *fun = obj->getCallObjCalleeFunction();
52503:     JS_ASSERT(fun->lookupLocal(cx, JSID_TO_ATOM(id), NULL) == JSLOCAL_NONE);
52503: #endif
 3624: 
 3624:     /*
 3624:      * Resolve arguments so that we never store a particular Call object's
 3624:      * arguments object reference in a Call prototype's |arguments| slot.
55563:      *
55563:      * Include JSPROP_ENUMERATE for consistency with all other Call object
55563:      * properties; see JSFunction::addLocal and js::Interpret's JSOP_DEFFUN
55563:      * rebinding-Call-property logic.
 3624:      */
48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.argumentsAtom)) {
48470:         if (!js_DefineNativeProperty(cx, obj, id, UndefinedValue(),
13706:                                      GetCallArguments, SetCallArguments,
55563:                                      JSPROP_PERMANENT | JSPROP_SHARED | JSPROP_ENUMERATE,
28397:                                      0, 0, NULL, JSDNP_DONT_PURGE)) {
 3624:             return JS_FALSE;
 3624:         }
 3624:         *objp = obj;
 3624:         return JS_TRUE;
 2464:     }
27012: 
27012:     /* Control flow reaches here only if id was not resolved. */
    1:     return JS_TRUE;
    1: }
    1: 
52503: static void
52503: call_trace(JSTracer *trc, JSObject *obj)
52503: {
52503:     JS_ASSERT(obj->isCall());
53859:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
53859:     if (fp) {
53859:         /*
53859:          * FIXME: Hide copies of stack values rooted by fp from the Cycle
53859:          * Collector, which currently lacks a non-stub Unlink implementation
53859:          * for JS objects (including Call objects), so is unable to collect
53859:          * cycles involving Call objects whose frames are active without this
53859:          * hiding hack.
53859:          */
55746:         uintN first = JSObject::CALL_RESERVED_SLOTS;
53859:         uintN count = fp->fun()->countArgsAndVars();
55746: 
55746:         JS_ASSERT(obj->numSlots() >= first + count);
55746:         SetValueRangeToUndefined(obj->getSlots() + first, count);
53859:     }
52503: 
52503:     MaybeMarkGenerator(trc, obj);
52503: }
52503: 
48470: JS_PUBLIC_DATA(Class) js_CallClass = {
27539:     "Call",
15588:     JSCLASS_HAS_PRIVATE |
53840:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::CALL_RESERVED_SLOTS) |
27539:     JSCLASS_NEW_RESOLVE | JSCLASS_IS_ANONYMOUS | JSCLASS_MARK_IS_TRACE,
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
52503:     JS_EnumerateStub,
48622:     (JSResolveOp)call_resolve,
56604:     NULL,           /* convert: Leave it NULL so we notice if calls ever escape */
48622:     NULL,           /* finalize */
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     NULL,           /* xdrObject   */
48622:     NULL,           /* hasInstance */
52503:     JS_CLASS_TRACE(call_trace)
    1: };
    1: 
48676: bool
48676: JSStackFrame::getValidCalleeObject(JSContext *cx, Value *vp)
48676: {
53840:     if (!isFunctionFrame()) {
53840:         vp->setUndefined();
48676:         return true;
48676:     }
48676: 
53840:     JSFunction *fun = this->fun();
51056: 
48676:     /*
52503:      * See the equivalent condition in ArgGetter for the 'callee' id case, but
48676:      * note that here we do not want to throw, since this escape can happen via
48676:      * a foo.caller reference alone, without any debugger or indirect eval. And
48676:      * alas, it seems foo.caller is still used on the Web.
48676:      */
48676:     if (fun->needsWrapper()) {
50500:         JSObject *wrapper = WrapEscapingClosure(cx, this, fun);
48676:         if (!wrapper)
48676:             return false;
48676:         vp->setObject(*wrapper);
48676:         return true;
48676:     }
48676: 
53840:     JSObject &funobj = callee();
53840:     vp->setObject(funobj);
48676: 
48676:     /*
48676:      * Check for an escape attempt by a joined function object, which must go
48676:      * through the frame's |this| object's method read barrier for the method
48676:      * atom by which it was uniquely associated with a property.
48676:      */
53840:     const Value &thisv = functionThis();
53840:     if (thisv.isObject()) {
53840:         JS_ASSERT(funobj.getFunctionPrivate() == fun);
53840: 
53840:         if (&fun->compiledFunObj() == &funobj && fun->methodAtom()) {
53840:             JSObject *thisp = &thisv.toObject();
48676:             JS_ASSERT(thisp->canHaveMethodBarrier());
48676: 
52503:             if (thisp->hasMethodBarrier()) {
52503:                 const Shape *shape = thisp->nativeLookup(ATOM_TO_JSID(fun->methodAtom()));
48676: 
48676:                 /*
48676:                  * The method property might have been deleted while the method
52503:                  * barrier flag stuck, so we must lookup and test here.
48676:                  *
48676:                  * Two cases follow: the method barrier was not crossed yet, so
48676:                  * we cross it here; the method barrier *was* crossed, in which
48676:                  * case we must fetch and validate the cloned (unjoined) funobj
48676:                  * in the method property's slot.
48676:                  *
48676:                  * In either case we must allow for the method property to have
48676:                  * been replaced, or its value to have been overwritten.
48676:                  */
52503:                 if (shape) {
53840:                     if (shape->isMethod() && &shape->methodObject() == &funobj) {
52503:                         if (!thisp->methodReadBarrier(cx, *shape, vp))
48676:                             return false;
53840:                         calleeValue().setObject(vp->toObject());
48676:                         return true;
48676:                     }
52503:                     if (shape->hasSlot()) {
52503:                         Value v = thisp->getSlot(shape->slot);
48676:                         JSObject *clone;
48676: 
48676:                         if (IsFunctionObject(v, &clone) &&
48676:                             GET_FUNCTION_PRIVATE(cx, clone) == fun &&
48676:                             clone->hasMethodObj(*thisp)) {
53840:                             JS_ASSERT(clone != &funobj);
48676:                             *vp = v;
53840:                             calleeValue().setObject(*clone);
48676:                             return true;
48676:                         }
48676:                     }
48676:                 }
48676: 
48676:                 /*
48676:                  * If control flows here, we can't find an already-existing
48676:                  * clone (or force to exist a fresh clone) created via thisp's
48676:                  * method read barrier, so we must clone fun and store it in
48676:                  * fp's callee to avoid re-cloning upon repeated foo.caller
48676:                  * access. It seems that there are no longer any properties
48676:                  * referring to fun.
48676:                  */
53840:                 JSObject *newfunobj = CloneFunctionObject(cx, fun, fun->getParent());
53840:                 if (!newfunobj)
48676:                     return false;
53840:                 newfunobj->setMethodObj(*thisp);
53840:                 calleeValue().setObject(*newfunobj);
48676:                 return true;
48676:             }
48676:         }
48676:     }
48676: 
48676:     return true;
48676: }
48676: 
31823: /* Generic function tinyids. */
31823: enum {
31823:     FUN_ARGUMENTS   = -1,       /* predefined arguments local variable */
31823:     FUN_LENGTH      = -2,       /* number of actual args, arity if inactive */
31823:     FUN_ARITY       = -3,       /* number of formal parameters; desired argc */
31823:     FUN_NAME        = -4,       /* function name, "" if anonymous */
31823:     FUN_CALLER      = -5        /* Function.prototype.caller, backward compat */
31823: };
31823: 
    1: static JSBool
48470: fun_getProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
48470:     if (!JSID_IS_INT(id))
48676:         return true;
43287: 
48470:     jsint slot = JSID_TO_INT(id);
    1: 
    1:     /*
    1:      * Loop because getter and setter can be delegated from another class,
31823:      * but loop only for FUN_LENGTH because we must pretend that f.length
    1:      * is in each function instance f, per ECMA-262, instead of only in the
    1:      * Function.prototype object (we use JSPROP_PERMANENT with JSPROP_SHARED
    1:      * to make it appear so).
    1:      *
51090:      * This code couples tightly to the attributes for lazyFunctionDataProps[]
51090:      * and poisonPillProps[] initializers below, and to js_SetProperty and
51090:      * js_HasOwnProperty.
    1:      *
    1:      * It's important to allow delegating objects, even though they inherit
    1:      * this getter (fun_getProperty), to override arguments, arity, caller,
31823:      * and name.  If we didn't return early for slot != FUN_LENGTH, we would
    1:      * clobber *vp with the native property value, instead of letting script
    1:      * override that value in delegating objects.
    1:      *
    1:      * Note how that clobbering is what simulates JSPROP_READONLY for all of
    1:      * the non-standard properties when the directly addressed object (obj)
    1:      * is a function object (i.e., when this loop does not iterate).
    1:      */
43287:     JSFunction *fun;
    1:     while (!(fun = (JSFunction *)
48470:                    GetInstancePrivate(cx, obj, &js_FunctionClass, NULL))) {
31823:         if (slot != FUN_LENGTH)
48676:             return true;
39928:         obj = obj->getProto();
    1:         if (!obj)
48676:             return true;
    1:     }
    1: 
    1:     /* Find fun's top-most activation record. */
43287:     JSStackFrame *fp;
22652:     for (fp = js_GetTopStackFrame(cx);
53840:          fp && (fp->maybeFun() != fun || fp->isEvalOrDebuggerFrame());
53840:          fp = fp->prev()) {
    1:         continue;
    1:     }
    1: 
    1:     switch (slot) {
31823:       case FUN_ARGUMENTS:
    1:         /* Warn if strict about f.arguments or equivalent unqualified uses. */
    1:         if (!JS_ReportErrorFlagsAndNumber(cx,
    1:                                           JSREPORT_WARNING | JSREPORT_STRICT,
    1:                                           js_GetErrorMessage, NULL,
    1:                                           JSMSG_DEPRECATED_USAGE,
    1:                                           js_arguments_str)) {
48676:             return false;
    1:         }
    1:         if (fp) {
    1:             if (!js_GetArgsValue(cx, fp, vp))
48676:                 return false;
    1:         } else {
48470:             vp->setNull();
    1:         }
    1:         break;
    1: 
31823:       case FUN_LENGTH:
    1:       case FUN_ARITY:
48470:         vp->setInt32(fun->nargs);
    1:         break;
    1: 
    1:       case FUN_NAME:
48470:         vp->setString(fun->atom ? ATOM_TO_STRING(fun->atom)
48470:                                 : cx->runtime->emptyString);
    1:         break;
    1: 
    1:       case FUN_CALLER:
48470:         vp->setNull();
53840:         if (fp && fp->prev() && !fp->prev()->getValidCalleeObject(cx, vp))
48676:             return false;
48676: 
48676:         if (vp->isObject()) {
52496:             JSObject &caller = vp->toObject();
52496: 
48656:             /* Censor the caller if it is from another compartment. */
56578:             if (caller.getCompartment() != cx->compartment) {
48470:                 vp->setNull();
52496:             } else if (caller.isFunction() && caller.getFunctionPrivate()->inStrictMode()) {
52496:                 JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
52496:                                              JSMSG_CALLER_IS_STRICT);
52496:                 return false;
52496:             }
18870:         }
    1:         break;
    1: 
    1:       default:
    1:         /* XXX fun[0] and fun.arguments[0] are equivalent. */
53840:         if (fp && fp->isFunctionFrame() && uint16(slot) < fp->numFormalArgs())
53840:             *vp = fp->formalArg(slot);
    1:         break;
    1:     }
    1: 
48676:     return true;
    1: }
    1: 
51090: struct LazyFunctionDataProp {
18830:     uint16      atomOffset;
18830:     int8        tinyid;
18830:     uint8       attrs;
43287: };
18830: 
51090: struct PoisonPillProp {
51090:     uint16       atomOffset;
51090:     int8         tinyid;
51090: };
51090: 
51090: /* NB: no sentinels at ends -- use JS_ARRAY_LENGTH to bound loops. */
51090: 
56593: static const LazyFunctionDataProp lazyFunctionDataProps[] = {
54169:     {ATOM_OFFSET(arity),     FUN_ARITY,      JSPROP_PERMANENT|JSPROP_READONLY},
54169:     {ATOM_OFFSET(name),      FUN_NAME,       JSPROP_PERMANENT|JSPROP_READONLY},
18830: };
18830: 
51090: /* Properties censored into [[ThrowTypeError]] in strict mode. */
56593: static const PoisonPillProp poisonPillProps[] = {
51090:     {ATOM_OFFSET(arguments), FUN_ARGUMENTS },
51090:     {ATOM_OFFSET(caller),    FUN_CALLER    },
51090: };
51090: 
    1: static JSBool
47569: fun_enumerate(JSContext *cx, JSObject *obj)
47569: {
47569:     JS_ASSERT(obj->isFunction());
47569: 
51682:     jsid id;
52503:     bool found;
51682: 
54410:     if (!obj->isBoundFunction()) {
51682:         id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
52503:         if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
47569:             return false;
51682:     }
51682: 
47569:     id = ATOM_TO_JSID(cx->runtime->atomState.lengthAtom);
52503:     if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
47569:         return false;
47569: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(lazyFunctionDataProps); i++) {
51090:         const LazyFunctionDataProp &lfp = lazyFunctionDataProps[i];
47569:         id = ATOM_TO_JSID(OFFSET_TO_ATOM(cx->runtime, lfp.atomOffset));
52503:         if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
47569:             return false;
47569:     }
47569: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(poisonPillProps); i++) {
51090:         const PoisonPillProp &p = poisonPillProps[i];
51090:         id = ATOM_TO_JSID(OFFSET_TO_ATOM(cx->runtime, p.atomOffset));
52503:         if (!obj->hasProperty(cx, id, &found, JSRESOLVE_QUALIFIED))
51090:             return false;
51090:     }
51090: 
47569:     return true;
47569: }
47569: 
47569: static JSBool
48470: fun_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:             JSObject **objp)
    1: {
48470:     if (!JSID_IS_ATOM(id))
55498:         return true;
    1: 
51682:     JSFunction *fun = obj->getFunctionPrivate();
 2803: 
55498:     if (JSID_IS_ATOM(id, cx->runtime->atomState.classPrototypeAtom)) {
 2803:         /*
55498:          * Native or "built-in" functions do not have a .prototype property per
55498:          * ECMA-262 (all editions). Built-in constructor functions, e.g. Object
55498:          * and Function to name two conspicuous examples, do have a .prototype
55498:          * property, but it is created eagerly by js_InitClass (jsobj.cpp).
55498:          *
55498:          * ES5 15.3.4: the non-native function object named Function.prototype
55498:          * must not have a .prototype property.
55498:          *
55498:          * ES5 15.3.4.5: bound functions don't have a prototype property. The
55498:          * isNative() test covers this case because bound functions are native
55498:          * functions by definition/construction.
 2803:          */
55498:         if (fun->isNative() || fun->isFunctionPrototype())
55498:             return true;
55498: 
55498:         /*
55498:          * Assert that fun is not a compiler-created function object, which
55498:          * must never leak to script or embedding code and then be mutated.
55498:          * Also assert that obj is not bound, per the ES5 15.3.4.5 ref above.
55498:          */
40405:         JS_ASSERT(!IsInternalFunctionObject(obj));
55498:         JS_ASSERT(!obj->isBoundFunction());
55498: 
55498:         /* No need to reflect fun.prototype in 'fun.prototype = ... '. */
55498:         if (flags & JSRESOLVE_ASSIGNING)
55498:             return true;
51682: 
    1:         /*
47497:          * Make the prototype object an instance of Object with the same parent
47497:          * as the function object itself.
    1:          */
47497:         JSObject *parent = obj->getParent();
47497:         JSObject *proto;
47497:         if (!js_GetClassPrototype(cx, parent, JSProto_Object, &proto))
55498:             return false;
47497:         proto = NewNativeClassInstance(cx, &js_ObjectClass, proto, parent);
    1:         if (!proto)
55498:             return false;
    1: 
    1:         /*
    1:          * ECMA (15.3.5.2) says that constructor.prototype is DontDelete for
    1:          * user-defined functions, but DontEnum | ReadOnly | DontDelete for
    1:          * native "system" constructors such as Object or Function.  So lazily
    1:          * set the former here in fun_resolve, but eagerly define the latter
52503:          * in js_InitClass, with the right attributes.
    1:          */
32671:         if (!js_SetClassPrototype(cx, obj, proto, JSPROP_PERMANENT))
55498:             return false;
32671: 
    1:         *objp = obj;
55498:         return true;
 2803:     }
 2803: 
55498:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
43287:         JS_ASSERT(!IsInternalFunctionObject(obj));
55498:         if (!js_DefineNativeProperty(cx, obj, id, Int32Value(fun->nargs),
48470:                                      PropertyStub, PropertyStub,
43287:                                      JSPROP_PERMANENT | JSPROP_READONLY, 0, 0, NULL)) {
55498:             return false;
43287:         }
43287:         *objp = obj;
55498:         return true;
43287:     }
43287: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(lazyFunctionDataProps); i++) {
51090:         const LazyFunctionDataProp *lfp = &lazyFunctionDataProps[i];
 2803: 
55498:         if (JSID_IS_ATOM(id, OFFSET_TO_ATOM(cx->runtime, lfp->atomOffset))) {
40405:             JS_ASSERT(!IsInternalFunctionObject(obj));
33604: 
55498:             if (!js_DefineNativeProperty(cx, obj, id, UndefinedValue(),
48470:                                          fun_getProperty, PropertyStub,
52503:                                          lfp->attrs, Shape::HAS_SHORTID,
18830:                                          lfp->tinyid, NULL)) {
55498:                 return false;
 2803:             }
 2803:             *objp = obj;
55498:             return true;
 2803:         }
    1:     }
    1: 
51090:     for (uintN i = 0; i < JS_ARRAY_LENGTH(poisonPillProps); i++) {
51090:         const PoisonPillProp &p = poisonPillProps[i];
51090: 
55498:         if (JSID_IS_ATOM(id, OFFSET_TO_ATOM(cx->runtime, p.atomOffset))) {
51090:             JS_ASSERT(!IsInternalFunctionObject(obj));
51090: 
51090:             PropertyOp getter, setter;
51090:             uintN attrs = JSPROP_PERMANENT;
54410:             if (fun->inStrictMode() || obj->isBoundFunction()) {
51090:                 JSObject *throwTypeError = obj->getThrowTypeError();
51090: 
51090:                 getter = CastAsPropertyOp(throwTypeError);
51090:                 setter = CastAsPropertyOp(throwTypeError);
51090:                 attrs |= JSPROP_GETTER | JSPROP_SETTER;
51090:             } else {
51090:                 getter = fun_getProperty;
51090:                 setter = PropertyStub;
51090:             }
51090: 
55498:             if (!js_DefineNativeProperty(cx, obj, id, UndefinedValue(),
51090:                                          getter, setter,
52503:                                          attrs, Shape::HAS_SHORTID,
51090:                                          p.tinyid, NULL)) {
55498:                 return false;
51090:             }
51090:             *objp = obj;
55498:             return true;
51090:         }
51090:     }
51090: 
55498:     return true;
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: /* XXX store parent and proto, if defined */
28093: JSBool
28093: js_XDRFunctionObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSFunction *fun;
28952:     uint32 firstword;           /* flag telling whether fun->atom is non-null,
28952:                                    plus for fun->u.i.skipmin, fun->u.i.wrapper,
28952:                                    and 14 bits reserved for future use */
27012:     uintN nargs, nvars, nupvars, n;
28952:     uint32 localsword;          /* word for argument and variable counts */
28952:     uint32 flagsword;           /* word for fun->u.i.nupvars and fun->flags */
    1: 
    1:     cx = xdr->cx;
    1:     if (xdr->mode == JSXDR_ENCODE) {
13702:         fun = GET_FUNCTION_PRIVATE(cx, *objp);
    1:         if (!FUN_INTERPRETED(fun)) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_NOT_SCRIPTED_FUNCTION,
    1:                                  JS_GetFunctionName(fun));
40389:             return false;
    1:         }
28952:         if (fun->u.i.wrapper) {
28952:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
28952:                                  JSMSG_XDR_CLOSURE_WRAPPER,
28952:                                  JS_GetFunctionName(fun));
40389:             return false;
28952:         }
28952:         JS_ASSERT((fun->u.i.wrapper & ~1U) == 0);
28952:         firstword = (fun->u.i.skipmin << 2) | (fun->u.i.wrapper << 1) | !!fun->atom;
13691:         nargs = fun->nargs;
13702:         nvars = fun->u.i.nvars;
27012:         nupvars = fun->u.i.nupvars;
 8179:         localsword = (nargs << 16) | nvars;
27012:         flagsword = (nupvars << 16) | fun->flags;
    1:     } else {
13702:         fun = js_NewFunction(cx, NULL, NULL, 0, JSFUN_INTERPRETED, NULL, NULL);
    1:         if (!fun)
40389:             return false;
39930:         FUN_OBJECT(fun)->clearParent();
39928:         FUN_OBJECT(fun)->clearProto();
 8179: #ifdef __GNUC__
27012:         nvars = nargs = nupvars = 0;    /* quell GCC uninitialized warning */
 8179: #endif
    1:     }
    1: 
48470:     AutoObjectRooter tvr(cx, FUN_OBJECT(fun));
    1: 
28952:     if (!JS_XDRUint32(xdr, &firstword))
40389:         return false;
48480:     if ((firstword & 1U) && !js_XDRAtom(xdr, &fun->atom))
40389:         return false;
 8179:     if (!JS_XDRUint32(xdr, &localsword) ||
    1:         !JS_XDRUint32(xdr, &flagsword)) {
40389:         return false;
    1:     }
    1: 
 8179:     if (xdr->mode == JSXDR_DECODE) {
 8179:         nargs = localsword >> 16;
27012:         nvars = uint16(localsword);
27012:         JS_ASSERT((flagsword & JSFUN_KINDMASK) >= JSFUN_INTERPRETED);
27012:         nupvars = flagsword >> 16;
27012:         fun->flags = uint16(flagsword);
28952:         fun->u.i.skipmin = uint16(firstword >> 2);
33166:         fun->u.i.wrapper = JSPackedBool((firstword >> 1) & 1);
 8179:     }
    1: 
    1:     /* do arguments and local vars */
27012:     n = nargs + nvars + nupvars;
13824:     if (n != 0) {
47609:         void *mark;
 8179:         uintN i;
47609:         uintN bitmapLength;
47609:         uint32 *bitmap;
11435:         jsuword *names;
11435:         JSAtom *name;
 8337:         JSLocalKind localKind;
47609: 
40389:         bool ok = true;
47609:         mark = JS_ARENA_MARK(&xdr->cx->tempPool);
 8179: 
11435:         /*
11435:          * From this point the control must flow via the label release_mark.
11435:          *
11435:          * To xdr the names we prefix the names with a bitmap descriptor and
11435:          * then xdr the names as strings. For argument names (indexes below
11435:          * nargs) the corresponding bit in the bitmap is unset when the name
11435:          * is null. Such null names are not encoded or decoded. For variable
11435:          * names (indexes starting from nargs) bitmap's bit is set when the
11435:          * name is declared as const, not as ordinary var.
11435:          * */
27012:         MUST_FLOW_THROUGH("release_mark");
47609:         bitmapLength = JS_HOWMANY(n, JS_BITS_PER_UINT32);
47609:         JS_ARENA_ALLOCATE_CAST(bitmap, uint32 *, &xdr->cx->tempPool,
47609:                                bitmapLength * sizeof *bitmap);
 8179:         if (!bitmap) {
 8296:             js_ReportOutOfScriptQuota(xdr->cx);
40389:             ok = false;
 8179:             goto release_mark;
 8179:         }
    1:         if (xdr->mode == JSXDR_ENCODE) {
52503:             names = fun->getLocalNameArray(xdr->cx, &xdr->cx->tempPool);
11435:             if (!names) {
40389:                 ok = false;
11435:                 goto release_mark;
 8179:             }
40229:             PodZero(bitmap, bitmapLength);
11435:             for (i = 0; i != n; ++i) {
13691:                 if (i < fun->nargs
11435:                     ? JS_LOCAL_NAME_TO_ATOM(names[i]) != NULL
11435:                     : JS_LOCAL_NAME_IS_CONST(names[i])) {
11435:                     bitmap[i >> JS_BITS_PER_UINT32_LOG2] |=
11435:                         JS_BIT(i & (JS_BITS_PER_UINT32 - 1));
11435:                 }
11435:             }
11435:         }
11435: #ifdef __GNUC__
11435:         else {
11435:             names = NULL;   /* quell GCC uninitialized warning */
11435:         }
11435: #endif
 8179:         for (i = 0; i != bitmapLength; ++i) {
40439:             ok = !!JS_XDRUint32(xdr, &bitmap[i]);
 8179:             if (!ok)
 8179:                 goto release_mark;
 8179:         }
 8179:         for (i = 0; i != n; ++i) {
 8179:             if (i < nargs &&
11435:                 !(bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
 8179:                   JS_BIT(i & (JS_BITS_PER_UINT32 - 1)))) {
 8179:                 if (xdr->mode == JSXDR_DECODE) {
52503:                     ok = !!fun->addLocal(xdr->cx, NULL, JSLOCAL_ARG);
 8179:                     if (!ok)
 8179:                         goto release_mark;
 8179:                 } else {
11435:                     JS_ASSERT(!JS_LOCAL_NAME_TO_ATOM(names[i]));
 8179:                 }
 8179:                 continue;
 8179:             }
 8179:             if (xdr->mode == JSXDR_ENCODE)
11435:                 name = JS_LOCAL_NAME_TO_ATOM(names[i]);
48480:             ok = !!js_XDRAtom(xdr, &name);
 8179:             if (!ok)
 8179:                 goto release_mark;
 8179:             if (xdr->mode == JSXDR_DECODE) {
 8179:                 localKind = (i < nargs)
 8179:                             ? JSLOCAL_ARG
27012:                             : (i < nargs + nvars)
27012:                             ? (bitmap[i >> JS_BITS_PER_UINT32_LOG2] &
 8179:                                JS_BIT(i & (JS_BITS_PER_UINT32 - 1))
 8179:                                ? JSLOCAL_CONST
27012:                                : JSLOCAL_VAR)
27012:                             : JSLOCAL_UPVAR;
52503:                 ok = !!fun->addLocal(xdr->cx, name, localKind);
 8179:                 if (!ok)
 8179:                     goto release_mark;
 8179:             }
 8179:         }
    1: 
 8179:       release_mark:
47609:         JS_ARENA_RELEASE(&xdr->cx->tempPool, mark);
 8179:         if (!ok)
40389:             return false;
    1: 
 8367:         if (xdr->mode == JSXDR_DECODE)
52503:             fun->freezeLocalNames(cx);
    1:     }
    1: 
34290:     if (!js_XDRScript(xdr, &fun->u.i.script, false, NULL))
40389:         return false;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
13824:         *objp = FUN_OBJECT(fun);
34290:         if (fun->u.i.script != JSScript::emptyScript()) {
11377: #ifdef CHECK_SCRIPT_OWNER
13702:             fun->u.i.script->owner = NULL;
11377: #endif
    1:             js_CallNewScriptHook(cx, fun->u.i.script, fun);
    1:         }
34290:     }
    1: 
40389:     return true;
    1: }
    1: 
    1: #else  /* !JS_HAS_XDR */
    1: 
28093: #define js_XDRFunctionObject NULL
    1: 
    1: #endif /* !JS_HAS_XDR */
    1: 
    1: /*
    1:  * [[HasInstance]] internal method for Function objects: fetch the .prototype
    1:  * property of its 'this' parameter, and walks the prototype chain of v (only
    1:  * if v is an object) returning true if .prototype is found.
    1:  */
    1: static JSBool
48470: fun_hasInstance(JSContext *cx, JSObject *obj, const Value *v, JSBool *bp)
    1: {
51682:     while (obj->isFunction()) {
54410:         if (!obj->isBoundFunction())
51682:             break;
51682:         obj = obj->getBoundFunctionTarget();
51682:     }
51682: 
31823:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
48470:     Value pval;
31823:     if (!obj->getProperty(cx, id, &pval))
    1:         return JS_FALSE;
    1: 
48470:     if (pval.isPrimitive()) {
    1:         /*
    1:          * Throw a runtime error if instanceof is called on a function that
    1:          * has a non-object as its .prototype value.
    1:          */
48470:         js_ReportValueError(cx, JSMSG_BAD_PROTOTYPE, -1, ObjectValue(*obj), NULL);
    1:         return JS_FALSE;
    1:     }
    1: 
48470:     *bp = js_IsDelegate(cx, &pval.toObject(), *v);
48470:     return JS_TRUE;
    1: }
    1: 
  583: static void
  583: fun_trace(JSTracer *trc, JSObject *obj)
    1: {
13691:     /* A newborn function object may have a not yet initialized private slot. */
31452:     JSFunction *fun = (JSFunction *) obj->getPrivate();
13824:     if (!fun)
13824:         return;
13824: 
52503:     if (fun != obj) {
52503:         /* obj is a cloned function object, trace the clone-parent, fun. */
53840:         MarkObject(trc, *fun, "private");
52503: 
52503:         /* The function could be a flat closure with upvar copies in the clone. */
52503:         if (FUN_FLAT_CLOSURE(fun) && fun->u.i.nupvars)
52503:             MarkValueRange(trc, fun->u.i.nupvars, obj->getFlatClosureUpvars(), "upvars");
13824:         return;
13824:     }
52503: 
  254:     if (fun->atom)
52503:         MarkString(trc, ATOM_TO_STRING(fun->atom), "atom");
52503: 
13824:     if (FUN_INTERPRETED(fun)) {
13824:         if (fun->u.i.script)
  583:             js_TraceScript(trc, fun->u.i.script);
52503:         for (const Shape *shape = fun->u.i.names; shape; shape = shape->previous())
52503:             shape->trace(trc);
13824:     }
13824: }
13824: 
13824: static void
13824: fun_finalize(JSContext *cx, JSObject *obj)
13824: {
52503:     /* Ignore newborn function objects. */
31823:     JSFunction *fun = (JSFunction *) obj->getPrivate();
52503:     if (!fun)
13824:         return;
13824: 
52503:     /* Cloned function objects may be flat closures with upvars to free. */
52503:     if (fun != obj) {
52503:         if (FUN_FLAT_CLOSURE(fun) && fun->u.i.nupvars != 0)
52503:             cx->free((void *) obj->getFlatClosureUpvars());
52503:         return;
52503:     }
52503: 
13824:     /*
13824:      * Null-check of u.i.script is required since the parser sets interpreted
13824:      * very early.
13824:      */
52503:     if (FUN_INTERPRETED(fun) && fun->u.i.script)
13824:         js_DestroyScript(cx, fun->u.i.script);
    1: }
    1: 
32729: int
32729: JSFunction::sharpSlotBase(JSContext *cx)
32729: {
32729: #if JS_HAS_SHARP_VARS
32729:     JSAtom *name = js_Atomize(cx, "#array", 6, 0);
32729:     if (name) {
32771:         uintN index = uintN(-1);
32757: #ifdef DEBUG
32757:         JSLocalKind kind =
32757: #endif
52503:             lookupLocal(cx, name, &index);
32757:         JS_ASSERT(kind == JSLOCAL_VAR);
32729:         return int(index);
32729:     }
32729: #endif
32729:     return -1;
32729: }
32729: 
30732: uint32
52503: JSFunction::countUpvarSlots() const
30732: {
30732:     JS_ASSERT(FUN_INTERPRETED(this));
30732: 
37029:     return (u.i.nupvars == 0) ? 0 : u.i.script->upvars()->length;
30732: }
30732: 
    1: /*
    1:  * Reserve two slots in all function objects for XPConnect.  Note that this
    1:  * does not bloat every instance, only those on which reserved slots are set,
    1:  * and those on which ad-hoc properties are defined.
    1:  */
48470: JS_PUBLIC_DATA(Class) js_FunctionClass = {
    1:     js_Function_str,
48676:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE |
52503:     JSCLASS_HAS_RESERVED_SLOTS(JSFunction::CLASS_RESERVED_SLOTS) |
  583:     JSCLASS_MARK_IS_TRACE | JSCLASS_HAS_CACHED_PROTO(JSProto_Function),
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     fun_enumerate,
48622:     (JSResolveOp)fun_resolve,
48622:     ConvertStub,
48622:     fun_finalize,
48622:     NULL,           /* reserved0   */
48622:     NULL,           /* checkAccess */
48622:     NULL,           /* call        */
48622:     NULL,           /* construct   */
48622:     js_XDRFunctionObject,
48622:     fun_hasInstance,
48622:     JS_CLASS_TRACE(fun_trace)
    1: };
    1: 
47498: JSString *
47498: fun_toStringHelper(JSContext *cx, JSObject *obj, uintN indent)
    1: {
47498:     if (!obj->isFunction()) {
47514:         if (obj->isFunctionProxy())
47498:             return JSProxy::fun_toString(cx, obj, indent);
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_INCOMPATIBLE_PROTO,
    1:                              js_Function_str, js_toString_str,
47498:                              "object");
47498:         return NULL;
    1:     }
    1: 
47498:     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, obj);
47498:     if (!fun)
47498:         return NULL;
47498:     return JS_DecompileFunction(cx, fun, indent);
    1: }
    1: 
    1: static JSBool
48470: fun_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     JS_ASSERT(IsFunctionObject(vp[0]));
47498:     uint32_t indent = 0;
47498: 
47498:     if (argc != 0 && !ValueToECMAUint32(cx, vp[2], &indent))
47498:         return false;
47498: 
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
47498:     if (!obj)
47498:         return false;
47498: 
47498:     JSString *str = fun_toStringHelper(cx, obj, indent);
47498:     if (!str)
47498:         return false;
47498: 
48470:     vp->setString(str);
47498:     return true;
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: static JSBool
48470: fun_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     JS_ASSERT(IsFunctionObject(vp[0]));
48470: 
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
47498:     if (!obj)
47498:         return false;
47498: 
47498:     JSString *str = fun_toStringHelper(cx, obj, JS_DONT_PRETTY_PRINT);
47498:     if (!str)
47498:         return false;
47498: 
48470:     vp->setString(str);
47498:     return true;
    1: }
    1: #endif
    1: 
29887: JSBool
48470: js_fun_call(JSContext *cx, uintN argc, Value *vp)
    1: {
37741:     LeaveTrace(cx);
29887: 
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
40867:     if (!obj)
    1:         return JS_FALSE;
48470:     Value fval = vp[1];
    1: 
38638:     if (!js_IsCallable(fval)) {
48470:         JSString *str = js_ValueToString(cx, fval);
    1:         if (str) {
    1:             const char *bytes = js_GetStringBytes(cx, str);
    1: 
    1:             if (bytes) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_INCOMPATIBLE_PROTO,
21473:                                      js_Function_str, js_call_str,
    1:                                      bytes);
    1:             }
    1:         }
    1:         return JS_FALSE;
    1:     }
    1: 
48470:     Value *argv = vp + 2;
55712:     Value thisv;
    1:     if (argc == 0) {
55712:         thisv.setUndefined();
    1:     } else {
55713:         thisv = argv[0];
55713: 
    1:         argc--;
    1:         argv++;
    1:     }
    1: 
    1:     /* Allocate stack space for fval, obj, and the args. */
42714:     InvokeArgsGuard args;
53840:     if (!cx->stack().pushInvokeArgs(cx, argc, &args))
    1:         return JS_FALSE;
    1: 
55712:     /* Push fval, thisv, and the args. */
50468:     args.callee() = fval;
55712:     args.thisv() = thisv;
50468:     memcpy(args.argv(), argv, argc * sizeof *argv);
42714: 
48470:     bool ok = Invoke(cx, args, 0);
50468:     *vp = args.rval();
    1:     return ok;
    1: }
    1: 
55479: struct STATIC_SKIP_INFERENCE CopyNonHoleArgs
53840: {
53840:     CopyNonHoleArgs(JSObject *aobj, Value *dst) : aobj(aobj), dst(dst) {}
53840:     JSObject *aobj;
53840:     Value *dst;
53840:     void operator()(uintN argi, Value *src) {
53840:         if (aobj->getArgsElement(argi).isMagic(JS_ARGS_HOLE))
53840:             dst->setUndefined();
53840:         else
53840:             *dst = *src;
53840:         ++dst;
53840:     }
53840: };
53840: 
48590: /* ES5 15.3.4.3 */
29887: JSBool
48470: js_fun_apply(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
40867:     if (!obj)
48590:         return false;
48590: 
48590:     /* Step 1. */
48470:     Value fval = vp[1];
38638:     if (!js_IsCallable(fval)) {
48590:         if (JSString *str = js_ValueToString(cx, fval)) {
48590:             if (const char *bytes = js_GetStringBytes(cx, str)) {
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_INCOMPATIBLE_PROTO,
21473:                                      js_Function_str, js_apply_str,
    1:                                      bytes);
    1:             }
    1:         }
48590:         return false;
    1:     }
    1: 
48590:     /* Step 2. */
48590:     if (argc < 2 || vp[3].isNullOrUndefined())
48590:         return js_fun_call(cx, (argc > 0) ? 1 : 0, vp);
48590: 
48590:     /* Step 3. */
48590:     if (!vp[3].isObject()) {
48590:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_APPLY_ARGS, js_apply_str);
48590:         return false;
48590:     }
48590: 
48590:     /*
48590:      * Steps 4-5 (note erratum removing steps originally numbered 5 and 7 in
48590:      * original version of ES5).
48590:      */
56565:     JSObject *aobj = &vp[3].toObject();
48590:     jsuint length;
48590:     if (aobj->isArray()) {
48590:         length = aobj->getArrayLength();
48590:     } else if (aobj->isArguments() && !aobj->isArgsLengthOverridden()) {
51091:         length = aobj->getArgsInitialLength();
    1:     } else {
48590:         Value &lenval = vp[0];
48590:         if (!aobj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom), &lenval))
48590:             return false;
48590: 
48590:         if (lenval.isInt32()) {
48590:             length = jsuint(lenval.toInt32()); /* jsuint cast does ToUint32 */
48590:         } else {
48590:             JS_STATIC_ASSERT(sizeof(jsuint) == sizeof(uint32_t));
48590:             if (!ValueToECMAUint32(cx, lenval, (uint32_t *)&length))
48590:                 return false;
    1:         }
    1:     }
    1: 
48590:     LeaveTrace(cx);
48590: 
48590:     /* Step 6. */
48590:     uintN n = uintN(JS_MIN(length, JS_ARGS_LENGTH_MAX));
42714: 
42714:     InvokeArgsGuard args;
53840:     if (!cx->stack().pushInvokeArgs(cx, n, &args))
48590:         return false;
    1: 
    1:     /* Push fval, obj, and aobj's elements as args. */
50468:     args.callee() = fval;
55713:     args.thisv() = vp[2];
48590: 
48590:     /* Steps 7-8. */
40864:     if (aobj && aobj->isArguments() && !aobj->isArgsLengthOverridden()) {
40405:         /*
40405:          * Two cases, two loops: note how in the case of an active stack frame
40405:          * backing aobj, even though we copy from fp->argv, we still must check
41871:          * aobj->getArgsElement(i) for a hole, to handle a delete on the
41871:          * corresponding arguments element. See args_delProperty.
40405:          */
40405:         JSStackFrame *fp = (JSStackFrame *) aobj->getPrivate();
50468:         Value *argv = args.argv();
40405:         if (fp) {
53840:             JS_ASSERT(fp->numActualArgs() <= JS_ARGS_LENGTH_MAX);
53840:             fp->forEachCanonicalActualArg(CopyNonHoleArgs(aobj, argv));
40405:         } else {
48590:             for (uintN i = 0; i < n; i++) {
50468:                 argv[i] = aobj->getArgsElement(i);
50468:                 if (argv[i].isMagic(JS_ARGS_HOLE))
50468:                     argv[i].setUndefined();
40405:             }
40405:         }
40405:     } else {
50468:         Value *argv = args.argv();
48590:         for (uintN i = 0; i < n; i++) {
50468:             if (!aobj->getProperty(cx, INT_TO_JSID(jsint(i)), &argv[i]))
42714:                 return JS_FALSE;
    1:         }
40405:     }
    1: 
48590:     /* Step 9. */
48590:     if (!Invoke(cx, args, 0))
48590:         return false;
50468:     *vp = args.rval();
48590:     return true;
    1: }
    1: 
56593: static JSBool
51682: CallOrConstructBoundFunction(JSContext *cx, uintN argc, Value *vp);
51682: 
51682: inline bool
51682: JSObject::initBoundFunction(JSContext *cx, const Value &thisArg,
51682:                             const Value *args, uintN argslen)
51682: {
51682:     JS_ASSERT(isFunction());
54410: 
54410:     flags |= JSObject::BOUND_FUNCTION;
55746:     getSlotRef(JSSLOT_BOUND_FUNCTION_THIS) = thisArg;
55746:     getSlotRef(JSSLOT_BOUND_FUNCTION_ARGS_COUNT).setPrivateUint32(argslen);
51682:     if (argslen != 0) {
52503:         /* FIXME? Burn memory on an empty scope whose shape covers the args slots. */
52503:         EmptyShape *empty = EmptyShape::create(cx, clasp);
52503:         if (!empty)
52503:             return false;
52503: 
53652:         empty->slotSpan += argslen;
52503:         map = empty;
52503: 
52503:         if (!ensureInstanceReservedSlots(cx, argslen))
51682:             return false;
51682: 
55746:         JS_ASSERT(numSlots() >= argslen + FUN_CLASS_RESERVED_SLOTS);
55746:         memcpy(getSlots() + FUN_CLASS_RESERVED_SLOTS, args, argslen * sizeof(Value));
51682:     }
51682:     return true;
51682: }
51682: 
51682: inline JSObject *
51682: JSObject::getBoundFunctionTarget() const
51682: {
51682:     JS_ASSERT(isFunction());
54410:     JS_ASSERT(isBoundFunction());
51682: 
51682:     /* Bound functions abuse |parent| to store their target function. */
51682:     return getParent();
51682: }
51682: 
51682: inline const js::Value &
51682: JSObject::getBoundFunctionThis() const
51682: {
51682:     JS_ASSERT(isFunction());
54410:     JS_ASSERT(isBoundFunction());
51682: 
55746:     return getSlot(JSSLOT_BOUND_FUNCTION_THIS);
51682: }
51682: 
51682: inline const js::Value *
51682: JSObject::getBoundFunctionArguments(uintN &argslen) const
51682: {
51682:     JS_ASSERT(isFunction());
54410:     JS_ASSERT(isBoundFunction());
51682: 
55746:     argslen = getSlot(JSSLOT_BOUND_FUNCTION_ARGS_COUNT).toPrivateUint32();
55746:     JS_ASSERT_IF(argslen > 0, numSlots() >= argslen);
55746: 
55746:     return getSlots() + FUN_CLASS_RESERVED_SLOTS;
51682: }
51682: 
51682: /* ES5 15.3.4.5.1 and 15.3.4.5.2. */
56593: static JSBool
51682: CallOrConstructBoundFunction(JSContext *cx, uintN argc, Value *vp)
51682: {
51682:     JSObject *obj = &vp[0].toObject();
51682:     JS_ASSERT(obj->isFunction());
54410:     JS_ASSERT(obj->isBoundFunction());
51682: 
51682:     LeaveTrace(cx);
51682: 
53557:     bool constructing = IsConstructing(vp);
51682: 
51682:     /* 15.3.4.5.1 step 1, 15.3.4.5.2 step 3. */
51682:     uintN argslen;
51682:     const Value *boundArgs = obj->getBoundFunctionArguments(argslen);
51682: 
51682:     if (argc + argslen > JS_ARGS_LENGTH_MAX) {
51682:         js_ReportAllocationOverflow(cx);
51682:         return false;
51682:     }
51682: 
51682:     /* 15.3.4.5.1 step 3, 15.3.4.5.2 step 1. */
51682:     JSObject *target = obj->getBoundFunctionTarget();
51682: 
51682:     /* 15.3.4.5.1 step 2. */
51682:     const Value &boundThis = obj->getBoundFunctionThis();
51682: 
51682:     InvokeArgsGuard args;
53840:     if (!cx->stack().pushInvokeArgs(cx, argc + argslen, &args))
51682:         return false;
51682: 
51682:     /* 15.3.4.5.1, 15.3.4.5.2 step 4. */
51682:     memcpy(args.argv(), boundArgs, argslen * sizeof(Value));
51682:     memcpy(args.argv() + argslen, vp + 2, argc * sizeof(Value));
51682: 
51682:     /* 15.3.4.5.1, 15.3.4.5.2 step 5. */
51682:     args.callee().setObject(*target);
51682: 
55713:     if (!constructing)
55713:         args.thisv() = boundThis;
51682: 
51682:     if (constructing ? !InvokeConstructor(cx, args) : !Invoke(cx, args, 0))
51682:         return false;
51682: 
51682:     *vp = args.rval();
51682:     return true;
51682: }
51682: 
51682: /* ES5 15.3.4.5. */
56593: static JSBool
51682: fun_bind(JSContext *cx, uintN argc, Value *vp)
51682: {
51682:     /* Step 1. */
51682:     JSObject *target = ComputeThisFromVp(cx, vp);
51682:     if (!target)
51682:         return false;
51682: 
51682:     /* Step 2. */
56565:     if (!target->isCallable()) {
51682:         if (JSString *str = js_ValueToString(cx, vp[1])) {
51682:             if (const char *bytes = js_GetStringBytes(cx, str)) {
51682:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
51682:                                      JSMSG_INCOMPATIBLE_PROTO,
51682:                                      js_Function_str, "bind", bytes);
51682:             }
51682:         }
51682:         return false;
51682:     }
51682: 
51682:     /* Step 3. */
51682:     Value *args = NULL;
51682:     uintN argslen = 0;
51682:     if (argc > 1) {
51682:         args = vp + 3;
51682:         argslen = argc - 1;
51682:     }
51682: 
51682:     /* Steps 15-16. */
51682:     uintN length = 0;
51682:     if (target->isFunction()) {
51682:         uintN nargs = target->getFunctionPrivate()->nargs;
51682:         if (nargs > argslen)
51682:             length = nargs - argslen;
51682:     }
51682: 
51682:     /* Step 4-6, 10-11. */
51682:     JSAtom *name = target->isFunction() ? target->getFunctionPrivate()->atom : NULL;
51682: 
51682:     /* NB: Bound functions abuse |parent| to store their target. */
51682:     JSObject *funobj =
53557:         js_NewFunction(cx, NULL, CallOrConstructBoundFunction, length,
53557:                        JSFUN_CONSTRUCTOR, target, name);
51682:     if (!funobj)
51682:         return false;
51682: 
51682:     /* Steps 7-9. */
51682:     Value thisArg = argc >= 1 ? vp[2] : UndefinedValue();
51682:     if (!funobj->initBoundFunction(cx, thisArg, args, argslen))
51682:         return false;
51682: 
51682:     /* Steps 17, 19-21 are handled by fun_resolve. */
51682:     /* Step 18 is the default for new functions. */
51682: 
51682:     /* Step 22. */
51682:     vp->setObject(*funobj);
51682:     return true;
51682: }
51682: 
    1: static JSFunctionSpec function_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,   fun_toSource,   0,0),
    1: #endif
16519:     JS_FN(js_toString_str,   fun_toString,   0,0),
21473:     JS_FN(js_apply_str,      js_fun_apply,   2,0),
21473:     JS_FN(js_call_str,       js_fun_call,    1,0),
51682:     JS_FN("bind",            fun_bind,       1,0),
 4127:     JS_FS_END
    1: };
    1: 
    1: static JSBool
53557: Function(JSContext *cx, uintN argc, Value *vp)
    1: {
53557:     JSObject *obj = NewFunction(cx, NULL);
    1:     if (!obj)
    1:         return JS_FALSE;
53557: 
53557:     /* N.B. overwriting callee with return value */
53557:     JSObject *parent = vp[0].toObject().getParent();
53557:     vp[0].setObject(*obj);
    1: 
    1:     /*
    1:      * NB: (new Function) is not lexically closed by its caller, it's just an
    1:      * anonymous function in the top-level scope that its constructor inhabits.
    1:      * Thus 'var x = 42; f = new Function("return x"); print(f())' prints 42,
    1:      * and so would a call to f from another top-level's script or function.
    1:      *
    1:      * In older versions, before call objects, a new Function was adopted by
    1:      * its running context's globalObject, which might be different from the
    1:      * top-level reachable from scopeChain (in HTML frames, e.g.).
    1:      */
53557:     JSFunction *fun = js_NewFunction(cx, obj, NULL, 0, JSFUN_LAMBDA | JSFUN_INTERPRETED,
13702:                                      parent, cx->runtime->atomState.anonymousAtom);
    1:     if (!fun)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Function is static and not called directly by other functions in this
    1:      * file, therefore it is callable only as a native function by js_Invoke.
    1:      * Find the scripted caller, possibly skipping other native frames such as
    1:      * are built for Function.prototype.call or .apply activations that invoke
    1:      * Function indirectly from a script.
    1:      */
53557:     JSStackFrame *caller = js_GetScriptedCaller(cx, NULL);
53557:     uintN lineno;
53557:     const char *filename;
53557:     JSPrincipals *principals;
    1:     if (caller) {
53557:         JSObject *callee = &JS_CALLEE(cx, vp).toObject();
53557:         principals = js_EvalFramePrincipals(cx, callee, caller);
12690:         filename = js_ComputeFilename(cx, caller, principals, &lineno);
    1:     } else {
    1:         filename = NULL;
    1:         lineno = 0;
    1:         principals = NULL;
    1:     }
    1: 
    1:     /* Belt-and-braces: check that the caller has access to parent. */
    1:     if (!js_CheckPrincipalsAccess(cx, parent, principals,
    1:                                   CLASS_ATOM(cx, Function))) {
    1:         return JS_FALSE;
    1:     }
    1: 
39061:     /*
39061:      * CSP check: whether new Function() is allowed at all.
39061:      * Report errors via CSP is done in the script security manager.
39061:      * js_CheckContentSecurityPolicy is defined in jsobj.cpp
39061:      */
39061:     if (!js_CheckContentSecurityPolicy(cx)) {
48676:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CSP_BLOCKED_FUNCTION);
39061:         return JS_FALSE;
39061:     }
39061: 
53557:     Value *argv = vp + 2;
53557:     uintN n = argc ? argc - 1 : 0;
    1:     if (n > 0) {
 6561:         enum { OK, BAD, BAD_FORMAL } state;
 6561: 
    1:         /*
    1:          * Collect the function-argument arguments into one string, separated
    1:          * by commas, then make a tokenstream from that string, and scan it to
    1:          * get the arguments.  We need to throw the full scanner at the
    1:          * problem, because the argument string can legitimately contain
    1:          * comments and linefeeds.  XXX It might be better to concatenate
    1:          * everything up into a function definition and pass it to the
    1:          * compiler, but doing it this way is less of a delta from the old
    1:          * code.  See ECMA 15.3.2.1.
    1:          */
 6561:         state = BAD_FORMAL;
53557:         size_t args_length = 0;
53557:         for (uintN i = 0; i < n; i++) {
    1:             /* Collect the lengths for all the function-argument arguments. */
53557:             JSString *arg = js_ValueToString(cx, argv[i]);
    1:             if (!arg)
    1:                 return JS_FALSE;
48470:             argv[i].setString(arg);
    1: 
    1:             /*
    1:              * Check for overflow.  The < test works because the maximum
    1:              * JSString length fits in 2 fewer bits than size_t has.
    1:              */
53557:             size_t old_args_length = args_length;
29366:             args_length = old_args_length + arg->length();
    1:             if (args_length < old_args_length) {
12983:                 js_ReportAllocationOverflow(cx);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1: 
    1:         /* Add 1 for each joining comma and check for overflow (two ways). */
53557:         size_t old_args_length = args_length;
    1:         args_length = old_args_length + n - 1;
    1:         if (args_length < old_args_length ||
    1:             args_length >= ~(size_t)0 / sizeof(jschar)) {
12983:             js_ReportAllocationOverflow(cx);
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /*
    1:          * Allocate a string to hold the concatenated arguments, including room
    1:          * for a terminating 0.  Mark cx->tempPool for later release, to free
    1:          * collected_args and its tokenstream in one swoop.
    1:          */
53557:         void *mark = JS_ARENA_MARK(&cx->tempPool);
53557:         jschar *cp;
47609:         JS_ARENA_ALLOCATE_CAST(cp, jschar *, &cx->tempPool,
47609:                                (args_length+1) * sizeof(jschar));
    1:         if (!cp) {
 8296:             js_ReportOutOfScriptQuota(cx);
    1:             return JS_FALSE;
    1:         }
53557:         jschar *collected_args = cp;
    1: 
    1:         /*
    1:          * Concatenate the arguments into the new string, separated by commas.
    1:          */
53557:         for (uintN i = 0; i < n; i++) {
53557:             JSString *arg = argv[i].toString();
53557:             size_t arg_length = arg->length();
29366:             (void) js_strncpy(cp, arg->chars(), arg_length);
    1:             cp += arg_length;
    1: 
    1:             /* Add separating comma or terminating 0. */
    1:             *cp++ = (i + 1 < n) ? ',' : 0;
    1:         }
    1: 
 6561:         /* Initialize a tokenstream that reads from the given string. */
53557:         TokenStream ts(cx);
53848:         if (!ts.init(cx->findVersion(), collected_args, args_length, NULL, filename, lineno)) {
47609:             JS_ARENA_RELEASE(&cx->tempPool, mark);
    1:             return JS_FALSE;
    1:         }
    1: 
    1:         /* The argument string may be empty or contain no tokens. */
53557:         TokenKind tt = ts.getToken();
    1:         if (tt != TOK_EOF) {
    1:             for (;;) {
    1:                 /*
    1:                  * Check that it's a name.  This also implicitly guards against
    1:                  * TOK_ERROR, which was already reported.
    1:                  */
    1:                 if (tt != TOK_NAME)
 6561:                     goto after_args;
    1: 
    1:                 /*
 8444:                  * Get the atom corresponding to the name from the token
 8444:                  * stream; we're assured at this point that it's a valid
 8444:                  * identifier.
    1:                  */
53557:                 JSAtom *atom = ts.currentToken().t_atom;
    1: 
 8179:                 /* Check for a duplicate parameter name. */
52503:                 if (fun->lookupLocal(cx, atom, NULL) != JSLOCAL_NONE) {
 8179:                     const char *name;
 8179: 
 8179:                     name = js_AtomToPrintableString(cx, atom);
53557:                     if (!name && ReportCompileErrorNumber(cx, &ts, NULL,
40320:                                                           JSREPORT_WARNING | JSREPORT_STRICT,
53557:                                                           JSMSG_DUPLICATE_FORMAL, name)) {
 6561:                         goto after_args;
    1:                     }
53557:                 }
52503:                 if (!fun->addLocal(cx, atom, JSLOCAL_ARG))
 6561:                     goto after_args;
    1: 
    1:                 /*
    1:                  * Get the next token.  Stop on end of stream.  Otherwise
    1:                  * insist on a comma, get another name, and iterate.
    1:                  */
40354:                 tt = ts.getToken();
    1:                 if (tt == TOK_EOF)
    1:                     break;
    1:                 if (tt != TOK_COMMA)
 6561:                     goto after_args;
40354:                 tt = ts.getToken();
    1:             }
    1:         }
    1: 
 6561:         state = OK;
 6561:       after_args:
40854:         if (state == BAD_FORMAL && !ts.isError()) {
 6561:             /*
 6561:              * Report "malformed formal parameter" iff no illegal char or
 6561:              * similar scanner error was already reported.
 6561:              */
 6561:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 6561:                                  JSMSG_BAD_FORMAL);
 6561:         }
40270:         ts.close();
47609:         JS_ARENA_RELEASE(&cx->tempPool, mark);
 6561:         if (state != OK)
    1:             return JS_FALSE;
    1:     }
    1: 
53557:     JSString *str;
    1:     if (argc) {
    1:         str = js_ValueToString(cx, argv[argc-1]);
    1:         if (!str)
    1:             return JS_FALSE;
48470:         argv[argc-1].setString(str);
 4076:     } else {
 4076:         str = cx->runtime->emptyString;
    1:     }
    1: 
40860:     return Compiler::compileFunctionBody(cx, fun, principals,
29366:                                          str->chars(), str->length(),
 8444:                                          filename, lineno);
    1: }
    1: 
56593: static JSBool
51090: ThrowTypeError(JSContext *cx, uintN argc, Value *vp)
51090: {
51090:     JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
51090:                                  JSMSG_THROW_TYPE_ERROR);
51090:     return false;
51090: }
51090: 
    1: JSObject *
    1: js_InitFunctionClass(JSContext *cx, JSObject *obj)
    1: {
51090:     JSObject *proto = js_InitClass(cx, obj, NULL, &js_FunctionClass, Function, 1,
43287:                                    NULL, function_methods, NULL, NULL);
    1:     if (!proto)
    1:         return NULL;
51090: 
51090:     JSFunction *fun = js_NewFunction(cx, proto, NULL, 0, JSFUN_INTERPRETED, obj, NULL);
    1:     if (!fun)
33178:         return NULL;
55498:     fun->flags |= JSFUN_PROTOTYPE;
34290:     fun->u.i.script = JSScript::emptyScript();
51090: 
51090:     if (obj->getClass()->flags & JSCLASS_IS_GLOBAL) {
51090:         /* ES5 13.2.3: Construct the unique [[ThrowTypeError]] function object. */
51090:         JSObject *throwTypeError =
51090:             js_NewFunction(cx, NULL, reinterpret_cast<Native>(ThrowTypeError), 0,
53557:                            0, obj, NULL);
51090:         if (!throwTypeError)
51090:             return NULL;
51090: 
51090:         JS_ALWAYS_TRUE(js_SetReservedSlot(cx, obj, JSRESERVED_GLOBAL_THROWTYPEERROR,
51090:                                           ObjectValue(*throwTypeError)));
51090:     }
51090: 
    1:     return proto;
    1: }
    1: 
    1: JSFunction *
48470: js_NewFunction(JSContext *cx, JSObject *funobj, Native native, uintN nargs,
    1:                uintN flags, JSObject *parent, JSAtom *atom)
    1: {
    1:     JSFunction *fun;
    1: 
    1:     if (funobj) {
40430:         JS_ASSERT(funobj->isFunction());
39930:         funobj->setParent(parent);
    1:     } else {
50500:         funobj = NewFunction(cx, parent);
    1:         if (!funobj)
    1:             return NULL;
    1:     }
31452:     JS_ASSERT(!funobj->getPrivate());
13824:     fun = (JSFunction *) funobj;
    1: 
    1:     /* Initialize all function members. */
39928:     fun->nargs = uint16(nargs);
53557:     fun->flags = flags & (JSFUN_FLAGS_MASK | JSFUN_KINDMASK | JSFUN_TRCINFO);
27012:     if ((flags & JSFUN_KINDMASK) >= JSFUN_INTERPRETED) {
13702:         JS_ASSERT(!native);
13702:         JS_ASSERT(nargs == 0);
13702:         fun->u.i.nvars = 0;
18308:         fun->u.i.nupvars = 0;
28952:         fun->u.i.skipmin = 0;
28952:         fun->u.i.wrapper = false;
13702:         fun->u.i.script = NULL;
52503:         fun->u.i.names = cx->runtime->emptyCallShape;
13702:     } else {
25887:         fun->u.n.clasp = NULL;
32669:         if (flags & JSFUN_TRCINFO) {
20408: #ifdef JS_TRACER
32669:             JSNativeTraceInfo *trcinfo =
32669:                 JS_FUNC_TO_DATA_PTR(JSNativeTraceInfo *, native);
48470:             fun->u.n.native = (js::Native) trcinfo->native;
25887:             fun->u.n.trcinfo = trcinfo;
20408: #else
25887:             fun->u.n.trcinfo = NULL;
20408: #endif
20408:         } else {
20408:             fun->u.n.native = native;
25887:             fun->u.n.trcinfo = NULL;
20408:         }
28086:         JS_ASSERT(fun->u.n.native);
13702:     }
    1:     fun->atom = atom;
    1: 
13824:     /* Set private to self to indicate non-cloned fully initialized function. */
31452:     FUN_OBJECT(fun)->setPrivate(fun);
    1:     return fun;
    1: }
    1: 
37694: JSObject * JS_FASTCALL
38604: js_CloneFunctionObject(JSContext *cx, JSFunction *fun, JSObject *parent,
38604:                        JSObject *proto)
    1: {
38604:     JS_ASSERT(parent);
38604:     JS_ASSERT(proto);
38604: 
55633:     JSObject *clone;
55633:     if (cx->compartment == fun->compartment()) {
13482:         /*
27012:          * The cloned function object does not need the extra JSFunction members
27012:          * beyond JSObject as it points to fun via the private slot.
13482:          */
55633:         clone = NewNativeClassInstance(cx, &js_FunctionClass, proto, parent);
13824:         if (!clone)
    1:             return NULL;
31452:         clone->setPrivate(fun);
55633:     } else {
55633:         /*
55633:          * Across compartments we have to deep copy JSFunction and clone the
55633:          * script (for interpreted functions).
55633:          */
55633:         clone = NewFunction(cx, parent);
55633:         if (!clone)
55633:             return NULL;
55633:         JSFunction *cfun = (JSFunction *) clone;
55633:         cfun->nargs = fun->nargs;
55633:         cfun->flags = fun->flags;
55633:         cfun->u = fun->getFunctionPrivate()->u;
55633:         cfun->atom = fun->atom;
55633:         clone->setPrivate(cfun);
55633:         if (cfun->isInterpreted()) {
55633:             JSScript *script = cfun->u.i.script;
55633:             JS_ASSERT(script);
55633:             if (script != JSScript::emptyScript()) {
55633:                 JS_ASSERT(script->compartment == fun->compartment());
55633:                 JS_ASSERT(script->compartment != cx->compartment);
55633:                 cfun->u.i.script = js_CloneScript(cx, script);
55633:                 if (!cfun->u.i.script)
55633:                     return NULL;
55633:                 JS_ASSERT(cfun->u.i.script != JSScript::emptyScript());
55633: #ifdef CHECK_SCRIPT_OWNER
55633:                 cfun->u.i.script->owner = NULL;
55633: #endif
55633:                 js_CallNewScriptHook(cx, cfun->u.i.script, cfun);
55633:             }
55633:         }
55633:     }
13824:     return clone;
    1: }
    1: 
38604: #ifdef JS_TRACER
39910: JS_DEFINE_CALLINFO_4(extern, OBJECT, js_CloneFunctionObject, CONTEXT, FUNCTION, OBJECT, OBJECT, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
38604: #endif
37694: 
28923: /*
28923:  * Create a new flat closure, but don't initialize the imported upvar
28923:  * values. The tracer calls this function and then initializes the upvar
28923:  * slots on trace.
28923:  */
28923: JSObject * JS_FASTCALL
28923: js_AllocFlatClosure(JSContext *cx, JSFunction *fun, JSObject *scopeChain)
27012: {
27012:     JS_ASSERT(FUN_FLAT_CLOSURE(fun));
28994:     JS_ASSERT((fun->u.i.script->upvarsOffset
32723:                ? fun->u.i.script->upvars()->length
28994:                : 0) == fun->u.i.nupvars);
27012: 
38604:     JSObject *closure = CloneFunctionObject(cx, fun, scopeChain);
31073:     if (!closure)
27012:         return closure;
31073: 
52503:     uint32 nslots = fun->countUpvarSlots();
47497:     if (nslots == 0)
31073:         return closure;
52503: 
52503:     Value *upvars = (Value *) cx->malloc(nslots * sizeof(Value));
52503:     if (!upvars)
27012:         return NULL;
27012: 
52503:     closure->setFlatClosureUpvars(upvars);
28923:     return closure;
28923: }
28923: 
28923: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_AllocFlatClosure,
48613:                      CONTEXT, FUNCTION, OBJECT, 0, nanojit::ACCSET_STORE_ANY)
28923: 
38563: JS_REQUIRES_STACK JSObject *
55527: js_NewFlatClosure(JSContext *cx, JSFunction *fun, JSOp op, size_t oplen)
28923: {
38563:     /*
38563:      * Flat closures can be partial, they may need to search enclosing scope
38563:      * objects via JSOP_NAME, etc.
38563:      */
56729:     JSObject *scopeChain = GetScopeChainFast(cx, cx->fp(), op, oplen);
38563:     if (!scopeChain)
38563:         return NULL;
38563: 
38563:     JSObject *closure = js_AllocFlatClosure(cx, fun, scopeChain);
28994:     if (!closure || fun->u.i.nupvars == 0)
28994:         return closure;
28923: 
52503:     Value *upvars = closure->getFlatClosureUpvars();
52503:     uintN level = fun->u.i.script->staticLevel;
32723:     JSUpvarArray *uva = fun->u.i.script->upvars();
52503: 
27168:     for (uint32 i = 0, n = uva->length; i < n; i++)
52503:         upvars[i] = GetUpvar(cx, level, uva->vector[i]);
27012: 
27012:     return closure;
27012: }
27012: 
28952: JSObject *
28952: js_NewDebuggableFlatClosure(JSContext *cx, JSFunction *fun)
28952: {
53840:     JS_ASSERT(cx->fp()->fun()->flags & JSFUN_HEAVYWEIGHT);
53840:     JS_ASSERT(!cx->fp()->fun()->optimizedClosure());
39916:     JS_ASSERT(FUN_FLAT_CLOSURE(fun));
28952: 
51446:     return WrapEscapingClosure(cx, cx->fp(), fun);
28952: }
28952: 
    1: JSFunction *
48470: js_DefineFunction(JSContext *cx, JSObject *obj, JSAtom *atom, Native native,
    1:                   uintN nargs, uintN attrs)
    1: {
48470:     PropertyOp gsop;
26970:     JSFunction *fun;
    1: 
27012:     if (attrs & JSFUN_STUB_GSOPS) {
27012:         /*
27012:          * JSFUN_STUB_GSOPS is a request flag only, not stored in fun->flags or
27012:          * the defined property's attributes. This allows us to encode another,
27012:          * internal flag using the same bit, JSFUN_EXPR_CLOSURE -- see jsfun.h
27012:          * for more on this.
27012:          */
27012:         attrs &= ~JSFUN_STUB_GSOPS;
48470:         gsop = PropertyStub;
27012:     } else {
27012:         gsop = NULL;
27012:     }
50489:     fun = js_NewFunction(cx, NULL, native, nargs,
53557:                          attrs & (JSFUN_FLAGS_MASK | JSFUN_TRCINFO),
53557:                          obj, atom);
    1:     if (!fun)
    1:         return NULL;
48470:     if (!obj->defineProperty(cx, ATOM_TO_JSID(atom), ObjectValue(*fun),
32573:                              gsop, gsop, attrs & ~JSFUN_FLAGS_MASK)) {
    1:         return NULL;
    1:     }
    1:     return fun;
    1: }
    1: 
    1: #if (JSV2F_CONSTRUCT & JSV2F_SEARCH_STACK)
    1: # error "JSINVOKE_CONSTRUCT and JSV2F_SEARCH_STACK are not disjoint!"
    1: #endif
    1: 
    1: JSFunction *
48470: js_ValueToFunction(JSContext *cx, const Value *vp, uintN flags)
    1: {
48470:     JSObject *funobj;
48470:     if (!IsFunctionObject(*vp, &funobj)) {
    1:         js_ReportIsNotFunction(cx, vp, flags);
    1:         return NULL;
    1:     }
48470:     return GET_FUNCTION_PRIVATE(cx, funobj);
    1: }
    1: 
    1: JSObject *
48470: js_ValueToFunctionObject(JSContext *cx, Value *vp, uintN flags)
    1: {
48470:     JSObject *funobj;
51075:     if (!IsFunctionObject(*vp, &funobj)) {
51075:         js_ReportIsNotFunction(cx, vp, flags);
    1:         return NULL;
    1:     }
51075: 
51075:     return funobj;
    1: }
    1: 
    1: JSObject *
48470: js_ValueToCallableObject(JSContext *cx, Value *vp, uintN flags)
    1: {
48470:     if (vp->isObject()) {
48470:         JSObject *callable = &vp->toObject();
48470:         if (callable->isCallable())
26059:             return callable;
    1:     }
51075: 
51075:     js_ReportIsNotFunction(cx, vp, flags);
51075:     return NULL;
    1: }
    1: 
    1: void
48470: js_ReportIsNotFunction(JSContext *cx, const Value *vp, uintN flags)
    1: {
42717:     const char *name = NULL, *source = NULL;
40389:     AutoValueRooter tvr(cx);
43211:     uintN error = (flags & JSV2F_CONSTRUCT) ? JSMSG_NOT_CONSTRUCTOR : JSMSG_NOT_FUNCTION;
42717:     LeaveTrace(cx);
50464: 
50464:     /*
50464:      * We try to the print the code that produced vp if vp is a value in the
50464:      * most recent interpreted stack frame. Note that additional values, not
50464:      * directly produced by the script, may have been pushed onto the frame's
53568:      * expression stack (e.g. by pushInvokeArgs) thereby incrementing sp past
50464:      * the depth simulated by ReconstructPCStack. Since we must pass an offset
50464:      * from the top of the simulated stack to js_ReportValueError3, it is
50464:      * important to do bounds checking using the simulated, rather than actual,
50464:      * stack depth.
50464:      */
50464:     ptrdiff_t spindex = 0;
50464: 
42717:     FrameRegsIter i(cx);
42717:     while (!i.done() && !i.pc())
42717:         ++i;
42717: 
50464:     if (!i.done()) {
53840:         uintN depth = js_ReconstructStackDepth(cx, i.fp()->script(), i.pc());
50464:         Value *simsp = i.fp()->base() + depth;
50464:         JS_ASSERT(simsp <= i.sp());
50464:         if (i.fp()->base() <= vp && vp < simsp)
50464:             spindex = vp - simsp;
50464:     }
50464: 
50464:     if (!spindex)
50464:         spindex = ((flags & JSV2F_SEARCH_STACK) ? JSDVG_SEARCH_STACK : JSDVG_IGNORE_STACK);
42717: 
42717:     js_ReportValueError3(cx, error, spindex, *vp, NULL, name, source);
    1: }
 8179: 
52503: const Shape *
52503: JSFunction::lastArg() const
52503: {
52503:     const Shape *shape = lastVar();
52503:     if (u.i.nvars != 0) {
52503:         while (shape->previous() && shape->getter() != js_GetCallArg)
52503:             shape = shape->previous();
52503:     }
52503:     return shape;
52503: }
52503: 
52503: const Shape *
52503: JSFunction::lastVar() const
52503: {
52503:     const Shape *shape = u.i.names;
52503:     if (u.i.nupvars != 0) {
52503:         while (shape->getter() == GetFlatUpvar)
52503:             shape = shape->previous();
52503:     }
52503:     return shape;
52503: }
52503: 
52503: bool
52503: JSFunction::addLocal(JSContext *cx, JSAtom *atom, JSLocalKind kind)
52503: {
52503:     JS_ASSERT(FUN_INTERPRETED(this));
52503:     JS_ASSERT(!u.i.script);
52503: 
 8367:     /*
52503:      * We still follow 10.2.3 of ES3 and make argument and variable properties
52503:      * of the Call objects enumerable. ES5 reformulated all of its Clause 10 to
52503:      * avoid objects as activations, something we should do too.
 8367:      */
52503:     uintN attrs = JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_SHARED;
 8179:     uint16 *indexp;
52503:     PropertyOp getter, setter;
55746:     uint32 slot = JSObject::CALL_RESERVED_SLOTS;
52503: 
 8179:     if (kind == JSLOCAL_ARG) {
52503:         JS_ASSERT(u.i.nupvars == 0);
52503: 
52503:         indexp = &nargs;
52503:         getter = js_GetCallArg;
52503:         setter = SetCallArg;
52503:         slot += nargs;
18308:     } else if (kind == JSLOCAL_UPVAR) {
52503:         indexp = &u.i.nupvars;
52503:         getter = GetFlatUpvar;
52503:         setter = SetFlatUpvar;
52503:         slot = SHAPE_INVALID_SLOT;
 8367:     } else {
52503:         JS_ASSERT(u.i.nupvars == 0);
52503: 
52503:         indexp = &u.i.nvars;
52503:         getter = js_GetCallVar;
52503:         setter = SetCallVar;
 8367:         if (kind == JSLOCAL_CONST)
52503:             attrs |= JSPROP_READONLY;
 8367:         else
 8367:             JS_ASSERT(kind == JSLOCAL_VAR);
52503:         slot += nargs + u.i.nvars;
 8367:     }
52503: 
 8179:     if (*indexp == JS_BITMASK(16)) {
 8179:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8179:                              (kind == JSLOCAL_ARG)
 8179:                              ? JSMSG_TOO_MANY_FUN_ARGS
16072:                              : JSMSG_TOO_MANY_LOCALS);
52503:         return false;
 8179:     }
52503: 
52503:     Shape **listp = &u.i.names;
52503:     Shape *parent = *listp;
52503:     jsid id;
52503: 
52503:     /*
52503:      * The destructuring formal parameter parser adds a null atom, which we
52503:      * encode as an INT id. The parser adds such locals after adding vars for
52503:      * the destructured-to parameter bindings -- those must be vars to avoid
52503:      * aliasing arguments[i] for any i -- so we must switch u.i.names to a
52507:      * dictionary list to cope with insertion "in the middle" of an index-named
52503:      * shape for the object or array argument.
52503:      */
52507:     bool findArgInsertionPoint = false;
52503:     if (!atom) {
52503:         JS_ASSERT(kind == JSLOCAL_ARG);
52503:         if (u.i.nvars != 0) {
52503:             /*
52503:              * A dictionary list needed only if the destructing pattern wasn't
52503:              * empty, i.e., there were vars for its destructured-to bindings.
52503:              */
52503:             if (!parent->inDictionary() && !(parent = Shape::newDictionaryList(cx, listp)))
52503:                 return false;
52507:             findArgInsertionPoint = true;
52507:         }
52507:         id = INT_TO_JSID(nargs);
52507:     } else {
52507:         if (kind == JSLOCAL_ARG && parent->inDictionary())
52507:             findArgInsertionPoint = true;
52507:         id = ATOM_TO_JSID(atom);
52507:     }
52507: 
52507:     if (findArgInsertionPoint) {
52503:         while (parent->parent && parent->getter() != js_GetCallArg) {
52503:             ++parent->slot;
53652:             JS_ASSERT(parent->slot == parent->slotSpan);
53652:             ++parent->slotSpan;
52503:             listp = &parent->parent;
52503:             parent = *listp;
 8179:         }
52503:     }
52503: 
52503:     Shape child(id, getter, setter, slot, attrs, Shape::HAS_SHORTID, *indexp);
52503: 
52503:     Shape *shape = parent->getChild(cx, child, listp);
52503:     if (!shape)
52503:         return false;
52503: 
52503:     JS_ASSERT_IF(!shape->inDictionary(), u.i.names == shape);
 8179:     ++*indexp;
52503:     return true;
 8179: }
 8179: 
 8179: JSLocalKind
52503: JSFunction::lookupLocal(JSContext *cx, JSAtom *atom, uintN *indexp)
 8179: {
52503:     JS_ASSERT(FUN_INTERPRETED(this));
52503: 
52503:     Shape *shape = SHAPE_FETCH(Shape::search(&u.i.names, ATOM_TO_JSID(atom)));
52503:     if (shape) {
52503:         JSLocalKind localKind;
52503: 
52503:         if (shape->getter() == js_GetCallArg)
52503:             localKind = JSLOCAL_ARG;
52503:         else if (shape->getter() == GetFlatUpvar)
52503:             localKind = JSLOCAL_UPVAR;
52503:         else if (!shape->writable())
52503:             localKind = JSLOCAL_CONST;
52503:         else
52503:             localKind = JSLOCAL_VAR;
52503: 
 8367:         if (indexp)
52503:             *indexp = shape->shortid;
52503:         return localKind;
 8367:     }
 8367:     return JSLOCAL_NONE;
 8367: }
 8367: 
52503: jsuword *
52503: JSFunction::getLocalNameArray(JSContext *cx, JSArenaPool *pool)
52503: {
52503:     JS_ASSERT(hasLocalNames());
52503: 
52503:     uintN n = countLocalNames();
11435:     jsuword *names;
11435: 
11435:     /*
11435:      * No need to check for overflow of the allocation size as we are making a
11435:      * copy of already allocated data. As such it must fit size_t.
11435:      */
52503:     JS_ARENA_ALLOCATE_CAST(names, jsuword *, pool, size_t(n) * sizeof *names);
 8179:     if (!names) {
 8296:         js_ReportOutOfScriptQuota(cx);
 8179:         return NULL;
 8179:     }
 8179: 
52503: #ifdef DEBUG
52503:     for (uintN i = 0; i != n; i++)
52503:         names[i] = 0xdeadbeef;
 8179: #endif
52503: 
52503:     for (Shape::Range r = u.i.names; !r.empty(); r.popFront()) {
52503:         const Shape &shape = r.front();
52503:         uintN index = uint16(shape.shortid);
52503:         jsuword constFlag = 0;
52503: 
52503:         if (shape.getter() == js_GetCallArg) {
52503:             JS_ASSERT(index < nargs);
52503:         } else if (shape.getter() == GetFlatUpvar) {
52503:             JS_ASSERT(index < u.i.nupvars);
52503:             index += nargs + u.i.nvars;
52503:         } else {
52503:             JS_ASSERT(index < u.i.nvars);
52503:             index += nargs;
52503:             if (!shape.writable())
52503:                 constFlag = 1;
52503:         }
52503: 
52503:         JSAtom *atom;
52503:         if (JSID_IS_ATOM(shape.id)) {
52503:             atom = JSID_TO_ATOM(shape.id);
52503:         } else {
52503:             JS_ASSERT(JSID_IS_INT(shape.id));
52503:             JS_ASSERT(shape.getter() == js_GetCallArg);
52503:             atom = NULL;
52503:         }
52503: 
52503:         names[index] = jsuword(atom);
52503:     }
52503: 
 8367: #ifdef DEBUG
52503:     for (uintN i = 0; i != n; i++)
52503:         JS_ASSERT(names[i] != 0xdeadbeef);
 8367: #endif
 8179:     return names;
 8179: }
 8179: 
52503: void
52503: JSFunction::freezeLocalNames(JSContext *cx)
 8367: {
52503:     JS_ASSERT(FUN_INTERPRETED(this));
52503: 
52503:     Shape *shape = u.i.names;
52503:     if (shape->inDictionary()) {
52503:         do {
52503:             JS_ASSERT(!shape->frozen());
52503:             shape->setFrozen();
52503:         } while ((shape = shape->parent) != NULL);
 8367:     }
 8367: }
 8367: 
 8367: /*
52503:  * This method is called only if we parsed a duplicate formal. Let's use the
52503:  * simplest possible algorithm, risking O(n^2) pain -- anyone dup'ing formals
52503:  * is asking for it!
 8367:  */
35409: JSAtom *
35409: JSFunction::findDuplicateFormal() const
35323: {
51095:     JS_ASSERT(isInterpreted());
51095: 
35323:     if (nargs <= 1)
35323:         return NULL;
35323: 
52503:     for (Shape::Range r = lastArg(); !r.empty(); r.popFront()) {
52503:         const Shape &shape = r.front();
52503:         for (Shape::Range r2 = shape.previous(); !r2.empty(); r2.popFront()) {
52503:             if (r2.front().id == shape.id)
52503:                 return JSID_TO_ATOM(shape.id);
35323:         }
35323:     }
35323:     return NULL;
35323: }
