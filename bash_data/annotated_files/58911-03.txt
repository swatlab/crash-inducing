    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Implementation of DOM Core's nsIDOMDocumentType node.
    1:  */
    1: 
    1: #include "nsDOMDocumentType.h"
    1: #include "nsDOMAttributeMap.h"
    1: #include "nsIDOMNamedNodeMap.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDOMString.h"
    1: #include "nsIDOM3Node.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsIDocument.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIDOMDocument.h"
    1: 
    1: nsresult
    1: NS_NewDOMDocumentType(nsIDOMDocumentType** aDocType,
    1:                       nsNodeInfoManager *aNodeInfoManager,
    1:                       nsIPrincipal *aPrincipal,
    1:                       nsIAtom *aName,
    1:                       nsIDOMNamedNodeMap *aEntities,
    1:                       nsIDOMNamedNodeMap *aNotations,
    1:                       const nsAString& aPublicId,
    1:                       const nsAString& aSystemId,
    1:                       const nsAString& aInternalSubset)
    1: {
    1:   NS_PRECONDITION(aNodeInfoManager || aPrincipal,
    1:                   "Must have a principal if no nodeinfo manager.");
    1:   NS_ENSURE_ARG_POINTER(aDocType);
    1:   NS_ENSURE_ARG_POINTER(aName);
    1: 
    1:   nsresult rv;
    1: 
    1:   nsRefPtr<nsNodeInfoManager> nimgr;
    1:   if (aNodeInfoManager) {
    1:     nimgr = aNodeInfoManager;
    1:   }
    1:   else {
    1:     nimgr = new nsNodeInfoManager();
    1:     NS_ENSURE_TRUE(nimgr, NS_ERROR_OUT_OF_MEMORY);
    1:     
    1:     rv = nimgr->Init(nsnull);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nimgr->SetDocumentPrincipal(aPrincipal);
    1:   }
    1: 
    1:   nsCOMPtr<nsINodeInfo> ni;
19197:   ni = nimgr->GetNodeInfo(nsGkAtoms::documentTypeNodeName, nsnull,
19197:                           kNameSpaceID_None);
19747:   NS_ENSURE_TRUE(ni, NS_ERROR_OUT_OF_MEMORY);
    1: 
48124:   *aDocType = new nsDOMDocumentType(ni.forget(), aName, aEntities, aNotations,
    1:                                     aPublicId, aSystemId, aInternalSubset);
    1:   if (!*aDocType) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ADDREF(*aDocType);
    1: 
    1:   return NS_OK;
    1: }
    1: 
48124: nsDOMDocumentType::nsDOMDocumentType(already_AddRefed<nsINodeInfo> aNodeInfo,
    1:                                      nsIAtom *aName,
    1:                                      nsIDOMNamedNodeMap *aEntities,
    1:                                      nsIDOMNamedNodeMap *aNotations,
    1:                                      const nsAString& aPublicId,
    1:                                      const nsAString& aSystemId,
    1:                                      const nsAString& aInternalSubset) :
    1:   nsGenericDOMDataNode(aNodeInfo),
    1:   mName(aName),
    1:   mEntities(aEntities),
    1:   mNotations(aNotations),
    1:   mPublicId(aPublicId),
    1:   mSystemId(aSystemId),
    1:   mInternalSubset(aInternalSubset)
    1: {
    1: }
    1: 
    1: nsDOMDocumentType::~nsDOMDocumentType()
    1: {
    1: }
    1: 
48124: DOMCI_NODE_DATA(DocumentType, nsDOMDocumentType)
    1: 
    1: // QueryInterface implementation for nsDOMDocumentType
21218: NS_INTERFACE_TABLE_HEAD(nsDOMDocumentType)
21218:   NS_NODE_INTERFACE_TABLE2(nsDOMDocumentType, nsIDOMNode, nsIDOMDocumentType)
21218:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDOMDocumentType)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DocumentType)
    1: NS_INTERFACE_MAP_END_INHERITING(nsGenericDOMDataNode)
    1: 
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsDOMDocumentType, nsGenericDOMDataNode)
    1: NS_IMPL_RELEASE_INHERITED(nsDOMDocumentType, nsGenericDOMDataNode)
    1: 
    1: PRBool
    1: nsDOMDocumentType::IsNodeOfType(PRUint32 aFlags) const
    1: {
    1:   // Don't claim to be eDATA_NODE since we're just inheriting
    1:   // nsGenericDOMDataNode for convinience. Doctypes aren't really
    1:   // data nodes (they have a null .nodeValue and don't implement
    1:   // nsIDOMCharacterData)
    1:   return !(aFlags & ~eCONTENT);
    1: }
    1: 
    1: const nsTextFragment*
    1: nsDOMDocumentType::GetText()
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsDOMDocumentType::GetName(nsAString& aName)
    1: {
39102:   mName->ToString(aName);
39102:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsDOMDocumentType::GetEntities(nsIDOMNamedNodeMap** aEntities)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aEntities);
    1: 
    1:   *aEntities = mEntities;
    1: 
    1:   NS_IF_ADDREF(*aEntities);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP    
    1: nsDOMDocumentType::GetNotations(nsIDOMNamedNodeMap** aNotations)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aNotations);
    1: 
    1:   *aNotations = mNotations;
    1: 
    1:   NS_IF_ADDREF(*aNotations);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMDocumentType::GetPublicId(nsAString& aPublicId)
    1: {
    1:   aPublicId = mPublicId;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMDocumentType::GetSystemId(nsAString& aSystemId)
    1: {
    1:   aSystemId = mSystemId;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMDocumentType::GetInternalSubset(nsAString& aInternalSubset)
    1: {
    1:   aInternalSubset = mInternalSubset;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMDocumentType::GetNodeName(nsAString& aNodeName)
    1: {
39102:   mName->ToString(aNodeName);
39102:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMDocumentType::GetNodeValue(nsAString& aNodeValue)
    1: {
    1:   SetDOMStringToNull(aNodeValue);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMDocumentType::SetNodeValue(const nsAString& aNodeValue)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMDocumentType::GetNodeType(PRUint16* aNodeType)
    1: {
    1:   *aNodeType = nsIDOMNode::DOCUMENT_TYPE_NODE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsGenericDOMDataNode*
    1: nsDOMDocumentType::CloneDataNode(nsINodeInfo *aNodeInfo, PRBool aCloneText) const
    1: {
48124:   nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
48124:   return new nsDOMDocumentType(ni.forget(), mName, mEntities, mNotations,
11169:                                mPublicId, mSystemId, mInternalSubset);
    1: }
    1: 
    1: nsresult
    1: nsDOMDocumentType::BindToTree(nsIDocument *aDocument, nsIContent *aParent,
    1:                               nsIContent *aBindingParent,
    1:                               PRBool aCompileEventHandlers)
    1: {
    1:   if (!HasSameOwnerDoc(NODE_FROM(aParent, aDocument))) {
    1:     NS_ASSERTION(!GetOwnerDoc(), "Need to adopt or import first!");
    1: 
    1:     // DocumentType nodes are the only nodes that can have a null ownerDocument
    1:     // according to the DOM spec, so we need to give them a new nodeinfo in that
    1:     // case.
    1:     // XXX We may want to move this to nsDOMImplementation::CreateDocument if
    1:     //     we want to rely on the nodeinfo and wrappers being right before
39585:     //     getting into ReplaceOrInsertBefore or doInsertChildAt. That would
    1:     //     break inserting DOMDocumentType nodes through other DOM methods
    1:     //     though.
    1:     nsNodeInfoManager *nimgr = aParent ?
    1:       aParent->NodeInfo()->NodeInfoManager() :
    1:       aDocument->NodeInfoManager();
    1:     nsCOMPtr<nsINodeInfo> newNodeInfo;
19197:     newNodeInfo = nimgr->GetNodeInfo(mNodeInfo->NameAtom(),
    1:                                      mNodeInfo->GetPrefixAtom(),
19197:                                      mNodeInfo->NamespaceID());
19747:     NS_ENSURE_TRUE(newNodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     mNodeInfo.swap(newNodeInfo);
    1: 
58908:     nsCOMPtr<nsIDocument> oldOwnerDoc =
58908:       do_QueryInterface(nsContentUtils::GetDocumentFromContext());
58908:     nsIDocument *newOwnerDoc = nimgr->GetDocument();
58908:     if (oldOwnerDoc && newOwnerDoc) {
    1:       nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1: 
    1:       JSContext *cx = nsnull;
58908:       JSObject *oldScope = nsnull, *newScope = nsnull;
58908:       nsresult rv = nsContentUtils::GetContextAndScopes(oldOwnerDoc, newOwnerDoc, &cx,
58908:                                                         &oldScope, &newScope);
    1:       if (cx && xpc) {
    1:         nsISupports *node = NS_ISUPPORTS_CAST(nsIContent*, this);
    1:         nsCOMPtr<nsIXPConnectJSObjectHolder> oldWrapper;
    1:         rv = xpc->ReparentWrappedNativeIfFound(cx, oldScope, newScope, node,
    1:                                                getter_AddRefs(oldWrapper));
    1:       }
    1: 
    1:       if (NS_FAILED(rv)) {
    1:         mNodeInfo.swap(newNodeInfo);
    1: 
    1:         return rv;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return nsGenericDOMDataNode::BindToTree(aDocument, aParent, aBindingParent,
    1:                                           aCompileEventHandlers);
    1: }
