 43113: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 43113: /* vim:set ts=4 sw=4 sts=4 et cin: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43113: 
 43113: #include "nsHttp.h"
 43113: #include "nsHttpHandler.h"
 43113: #include "nsHttpChannel.h"
 43113: #include "nsHttpConnection.h"
 43113: #include "nsHttpResponseHead.h"
 43113: #include "nsHttpTransaction.h"
 43113: #include "nsHttpAuthCache.h"
 43113: #include "nsStandardURL.h"
 43113: #include "nsIHttpChannel.h"
 43113: #include "nsIURL.h"
 43113: #include "nsIStandardURL.h"
 43113: #include "nsICacheService.h"
 43113: #include "nsICategoryManager.h"
 43113: #include "nsCategoryManagerUtils.h"
 43113: #include "nsICacheService.h"
 43113: #include "nsIPrefService.h"
 90037: #include "nsIPrefBranch.h"
 43113: #include "nsIPrefLocalizedString.h"
 43113: #include "nsISocketProviderService.h"
 43113: #include "nsISocketProvider.h"
 43113: #include "nsPrintfCString.h"
 43113: #include "nsCOMPtr.h"
 43113: #include "nsNetCID.h"
 43113: #include "prprf.h"
 43113: #include "nsReadableUtils.h"
 43113: #include "nsQuickSort.h"
 43113: #include "nsNetUtil.h"
 43113: #include "nsIOService.h"
 48304: #include "nsAsyncRedirectVerifyHelper.h"
 56650: #include "nsSocketTransportService2.h"
 81029: #include "nsAlgorithm.h"
 99497: #include "ASpdySession.h"
 43113: 
 43113: #include "nsIXULAppInfo.h"
 43113: 
 46672: #include "mozilla/net/NeckoChild.h"
 46672: 
 63458: #if defined(XP_UNIX)
 43113: #include <sys/utsname.h>
 43113: #endif
 43113: 
 43113: #if defined(XP_WIN)
 43113: #include <windows.h>
 43113: #endif
 43113: 
 43113: #if defined(XP_MACOSX)
 43113: #include <CoreServices/CoreServices.h>
 43113: #endif
 43113: 
 43113: #if defined(XP_OS2)
 43113: #define INCL_DOSMISC
 43113: #include <os2.h>
 43113: #endif
 43113: 
 46517: //-----------------------------------------------------------------------------
 81029: using namespace mozilla;
 46790: using namespace mozilla::net;
 46672: #include "mozilla/net/HttpChannelChild.h"
 46517: 
 43113: #include "mozilla/FunctionTimer.h"
 43113: 
 43113: #ifdef DEBUG
 43113: // defined by the socket transport service while active
 43113: extern PRThread *gSocketThread;
 43113: #endif
 43113: 
 43113: static NS_DEFINE_CID(kIOServiceCID, NS_IOSERVICE_CID);
 43113: static NS_DEFINE_CID(kStreamConverterServiceCID, NS_STREAMCONVERTERSERVICE_CID);
 43113: static NS_DEFINE_CID(kCookieServiceCID, NS_COOKIESERVICE_CID);
 43113: static NS_DEFINE_CID(kCacheServiceCID, NS_CACHESERVICE_CID);
 43113: static NS_DEFINE_CID(kSocketProviderServiceCID, NS_SOCKETPROVIDERSERVICE_CID);
 43113: 
 43113: #define UA_PREF_PREFIX          "general.useragent."
 48898: #ifdef XP_WIN
 48898: #define UA_SPARE_PLATFORM
 48898: #endif
 43113: 
 43113: #define HTTP_PREF_PREFIX        "network.http."
 43113: #define INTL_ACCEPT_LANGUAGES   "intl.accept_languages"
 43113: #define NETWORK_ENABLEIDN       "network.enableIDN"
 43113: #define BROWSER_PREF_PREFIX     "browser.cache."
 61491: #define DONOTTRACK_HEADER_ENABLED "privacy.donottrackheader.enabled"
 91115: #define TELEMETRY_ENABLED        "toolkit.telemetry.enabled"
 91115: #define ALLOW_EXPERIMENTS        "network.allow-experiments"
 43113: 
 43113: #define UA_PREF(_pref) UA_PREF_PREFIX _pref
 43113: #define HTTP_PREF(_pref) HTTP_PREF_PREFIX _pref
 43113: #define BROWSER_PREF(_pref) BROWSER_PREF_PREFIX _pref
 43113: 
 43113: #define NS_HTTP_PROTOCOL_FLAGS (URI_STD | ALLOWS_PROXY | ALLOWS_PROXY_HTTP | URI_LOADABLE_BY_ANYONE)
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: static nsresult
 43113: NewURI(const nsACString &aSpec,
 43113:        const char *aCharset,
 43113:        nsIURI *aBaseURI,
 43113:        PRInt32 aDefaultPort,
 43113:        nsIURI **aURI)
 43113: {
 43113:     nsStandardURL *url = new nsStandardURL();
 43113:     if (!url)
 43113:         return NS_ERROR_OUT_OF_MEMORY;
 43113:     NS_ADDREF(url);
 43113: 
 43113:     nsresult rv = url->Init(nsIStandardURL::URLTYPE_AUTHORITY,
 43113:                             aDefaultPort, aSpec, aCharset, aBaseURI);
 43113:     if (NS_FAILED(rv)) {
 43113:         NS_RELEASE(url);
 43113:         return rv;
 43113:     }
 43113: 
 43113:     *aURI = url; // no QI needed
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpHandler <public>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: nsHttpHandler *gHttpHandler = nsnull;
 43113: 
 43113: nsHttpHandler::nsHttpHandler()
 43113:     : mConnMgr(nsnull)
 43113:     , mHttpVersion(NS_HTTP_VERSION_1_1)
 43113:     , mProxyHttpVersion(NS_HTTP_VERSION_1_1)
 43113:     , mCapabilities(NS_HTTP_ALLOW_KEEPALIVE)
 43113:     , mProxyCapabilities(NS_HTTP_ALLOW_KEEPALIVE)
 43113:     , mReferrerLevel(0xff) // by default we always send a referrer
 80486:     , mFastFallbackToIPv4(false)
 90872:     , mIdleTimeout(PR_SecondsToInterval(10))
 90872:     , mSpdyTimeout(PR_SecondsToInterval(180))
 43113:     , mMaxRequestAttempts(10)
 43113:     , mMaxRequestDelay(10)
 64613:     , mIdleSynTimeout(250)
 43113:     , mMaxConnections(24)
 43113:     , mMaxConnectionsPerServer(8)
 43113:     , mMaxPersistentConnectionsPerServer(2)
 43113:     , mMaxPersistentConnectionsPerProxy(4)
 93840:     , mMaxPipelinedRequests(32)
 93840:     , mMaxOptimisticPipelinedRequests(4)
 93840:     , mPipelineAggressive(false)
 93843:     , mMaxPipelineObjectSize(300000)
 95197:     , mPipelineRescheduleOnTimeout(true)
 95197:     , mPipelineRescheduleTimeout(PR_MillisecondsToInterval(1500))
 94625:     , mPipelineReadTimeout(PR_MillisecondsToInterval(30000))
 43113:     , mRedirectionLimit(10)
 43113:     , mPhishyUserPassLength(1)
 43113:     , mQoSBits(0x00)
 80486:     , mPipeliningOverSSL(false)
 93839:     , mEnforceAssocReq(false)
 43113:     , mLastUniqueID(NowInSeconds())
 43113:     , mSessionStartTime(0)
 51553:     , mLegacyAppName("Mozilla")
 51553:     , mLegacyAppVersion("5.0")
 51719:     , mProduct("Gecko")
 80486:     , mUserAgentIsDirty(true)
 80486:     , mUseCache(true)
 80486:     , mPromptTempRedirect(true)
 80486:     , mSendSecureXSiteReferrer(true)
 80486:     , mEnablePersistentHttpsCaching(false)
 80486:     , mDoNotTrackEnabled(false)
 91115:     , mTelemetryEnabled(false)
 91115:     , mAllowExperiments(true)
 84549:     , mEnableSpdy(false)
 99498:     , mSpdyV2(true)
 99498:     , mSpdyV3(true)
 84549:     , mCoalesceSpdy(true)
 84549:     , mUseAlternateProtocol(false)
 99497:     , mSpdySendingChunkSize(ASpdySession::kSendingChunkSize)
 90872:     , mSpdyPingThreshold(PR_SecondsToInterval(44))
 90872:     , mSpdyPingTimeout(PR_SecondsToInterval(8))
 43113: {
 43113: #if defined(PR_LOGGING)
 43113:     gHttpLog = PR_NewLogModule("nsHttp");
 43113: #endif
 43113: 
 43113:     LOG(("Creating nsHttpHandler [this=%x].\n", this));
 43113: 
 43113:     NS_ASSERTION(!gHttpHandler, "HTTP handler already created!");
 43113:     gHttpHandler = this;
 43113: }
 43113: 
 43113: nsHttpHandler::~nsHttpHandler()
 43113: {
 43113:     LOG(("Deleting nsHttpHandler [this=%x]\n", this));
 43113: 
 43113:     // make sure the connection manager is shutdown
 43113:     if (mConnMgr) {
 43113:         mConnMgr->Shutdown();
 43113:         NS_RELEASE(mConnMgr);
 43113:     }
 43113: 
 46672:     // Note: don't call NeckoChild::DestroyNeckoChild() here, as it's too late
 46672:     // and it'll segfault.  NeckoChild will get cleaned up by process exit.
 46672: 
 43113:     nsHttp::DestroyAtomTable();
 43113: 
 43113:     gHttpHandler = nsnull;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpHandler::Init()
 43113: {
 43113:     NS_TIME_FUNCTION;
 43113: 
 43113:     nsresult rv;
 43113: 
 43113:     LOG(("nsHttpHandler::Init\n"));
 43113: 
 43113:     rv = nsHttp::CreateAtomTable();
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 43113:     mIOService = do_GetService(NS_IOSERVICE_CONTRACTID, &rv);
 43113:     if (NS_FAILED(rv)) {
 43113:         NS_WARNING("unable to continue without io service");
 43113:         return rv;
 43113:     }
 43113: 
 46672:     if (IsNeckoChild())
 46517:         NeckoChild::InitNeckoChild();
 46517: 
 43113:     InitUserAgentComponents();
 43113: 
 43113:     // monitor some preference changes
 90037:     nsCOMPtr<nsIPrefBranch> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
 43113:     if (prefBranch) {
 80486:         prefBranch->AddObserver(HTTP_PREF_PREFIX, this, true);
 80486:         prefBranch->AddObserver(UA_PREF_PREFIX, this, true);
 80486:         prefBranch->AddObserver(INTL_ACCEPT_LANGUAGES, this, true); 
 80486:         prefBranch->AddObserver(NETWORK_ENABLEIDN, this, true);
 80486:         prefBranch->AddObserver(BROWSER_PREF("disk_cache_ssl"), this, true);
 80486:         prefBranch->AddObserver(DONOTTRACK_HEADER_ENABLED, this, true);
 91115:         prefBranch->AddObserver(TELEMETRY_ENABLED, this, true);
 43113: 
 43113:         PrefsChanged(prefBranch, nsnull);
 43113:     }
 43113: 
 90477:     mMisc.AssignLiteral("rv:" MOZILLA_UAVERSION);
 43113: 
 51553:     nsCOMPtr<nsIXULAppInfo> appInfo =
 51553:         do_GetService("@mozilla.org/xre/app-info;1");
 51553: 
 51553:     mAppName.AssignLiteral(MOZ_APP_UA_NAME);
 51553:     if (mAppName.Length() == 0 && appInfo) {
 98402:         // Try to get the UA name from appInfo, falling back to the name
 98402:         appInfo->GetUAName(mAppName);
 98402:         if (mAppName.Length() == 0) {
 51553:           appInfo->GetName(mAppName);
 98402:         }
 51553:         appInfo->GetVersion(mAppVersion);
 51889:         mAppName.StripChars(" ()<>@,;:\\\"/[]?={}");
 51553:     } else {
 51732:         mAppVersion.AssignLiteral(MOZ_APP_UA_VERSION);
 51553:     }
 51553: 
 43113: #if DEBUG
 43113:     // dump user agent prefs
 51553:     LOG(("> legacy-app-name = %s\n", mLegacyAppName.get()));
 51553:     LOG(("> legacy-app-version = %s\n", mLegacyAppVersion.get()));
 43113:     LOG(("> platform = %s\n", mPlatform.get()));
 43113:     LOG(("> oscpu = %s\n", mOscpu.get()));
 43113:     LOG(("> misc = %s\n", mMisc.get()));
 43113:     LOG(("> product = %s\n", mProduct.get()));
 43113:     LOG(("> product-sub = %s\n", mProductSub.get()));
 51553:     LOG(("> app-name = %s\n", mAppName.get()));
 51553:     LOG(("> app-version = %s\n", mAppVersion.get()));
 51553:     LOG(("> compat-firefox = %s\n", mCompatFirefox.get()));
 43113:     LOG(("> user-agent = %s\n", UserAgent().get()));
 43113: #endif
 43113: 
 43113:     mSessionStartTime = NowInSeconds();
 43113: 
 43113:     rv = mAuthCache.Init();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     rv = InitConnectionMgr();
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
100274: #ifdef ANDROID
 90477:     mProductSub.AssignLiteral(MOZILLA_UAVERSION);
100274: #else
100274:     mProductSub.AssignLiteral(MOZ_UA_BUILDID);
100274: #endif
100274:     if (mProductSub.IsEmpty() && appInfo)
100274:         appInfo->GetPlatformBuildID(mProductSub);
100274:     if (mProductSub.Length() > 8)
100274:         mProductSub.SetLength(8);
 43113: 
 43113:     // Startup the http category
 43113:     // Bring alive the objects in the http-protocol-startup category
 43113:     NS_CreateServicesFromCategory(NS_HTTP_STARTUP_CATEGORY,
 43113:                                   static_cast<nsISupports*>(static_cast<void*>(this)),
 43113:                                   NS_HTTP_STARTUP_TOPIC);    
 43113:     
 43113:     mObserverService = mozilla::services::GetObserverService();
 43113:     if (mObserverService) {
 80486:         mObserverService->AddObserver(this, "profile-change-net-teardown", true);
 80486:         mObserverService->AddObserver(this, "profile-change-net-restore", true);
 80486:         mObserverService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, true);
 80486:         mObserverService->AddObserver(this, "net:clear-active-logins", true);
 80486:         mObserverService->AddObserver(this, "net:prune-dead-connections", true);
 94990:         mObserverService->AddObserver(this, "net:failed-to-process-uri-content", true);
 43113:     }
 43113:  
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpHandler::InitConnectionMgr()
 43113: {
 43113:     NS_TIME_FUNCTION;
 43113: 
 43113:     nsresult rv;
 43113: 
 43113:     if (!mConnMgr) {
 43113:         mConnMgr = new nsHttpConnectionMgr();
 43113:         if (!mConnMgr)
 43113:             return NS_ERROR_OUT_OF_MEMORY;
 43113:         NS_ADDREF(mConnMgr);
 43113:     }
 43113: 
 43113:     rv = mConnMgr->Init(mMaxConnections,
 43113:                         mMaxConnectionsPerServer,
 43113:                         mMaxConnectionsPerServer,
 43113:                         mMaxPersistentConnectionsPerServer,
 43113:                         mMaxPersistentConnectionsPerProxy,
 43113:                         mMaxRequestDelay,
 93840:                         mMaxPipelinedRequests,
 93840:                         mMaxOptimisticPipelinedRequests);
 43113:     return rv;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpHandler::AddStandardRequestHeaders(nsHttpHeaderArray *request,
 43113:                                          PRUint8 caps,
 79445:                                          bool useProxy)
 43113: {
 43113:     nsresult rv;
 43113: 
 43113:     // Add the "User-Agent" header
 43113:     rv = request->SetHeader(nsHttp::User_Agent, UserAgent());
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // MIME based content negotiation lives!
 43113:     // Add the "Accept" header
 43113:     rv = request->SetHeader(nsHttp::Accept, mAccept);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // Add the "Accept-Language" header
 43113:     if (!mAcceptLanguages.IsEmpty()) {
 43113:         // Add the "Accept-Language" header
 43113:         rv = request->SetHeader(nsHttp::Accept_Language, mAcceptLanguages);
 43113:         if (NS_FAILED(rv)) return rv;
 43113:     }
 43113: 
 43113:     // Add the "Accept-Encoding" header
 43113:     rv = request->SetHeader(nsHttp::Accept_Encoding, mAcceptEncodings);
 43113:     if (NS_FAILED(rv)) return rv;
 43113: 
 43113:     // RFC2616 section 19.6.2 states that the "Connection: keep-alive"
 43113:     // and "Keep-alive" request headers should not be sent by HTTP/1.1
 43113:     // user-agents.  Otherwise, problems with proxy servers (especially
 43113:     // transparent proxies) can result.
 43113:     //
 43113:     // However, we need to send something so that we can use keepalive
 43113:     // with HTTP/1.0 servers/proxies. We use "Proxy-Connection:" when 
 64672:     // we're talking to an http proxy, and "Connection:" otherwise.
 64672:     // We no longer send the Keep-Alive request header.
 43113:     
 43113:     NS_NAMED_LITERAL_CSTRING(close, "close");
 43113:     NS_NAMED_LITERAL_CSTRING(keepAlive, "keep-alive");
 43113: 
 43113:     const nsACString *connectionType = &close;
 43113:     if (caps & NS_HTTP_ALLOW_KEEPALIVE) {
 43113:         connectionType = &keepAlive;
 43113:     } else if (useProxy) {
 43113:         // Bug 92006
 43113:         request->SetHeader(nsHttp::Connection, close);
 43113:     }
 43113: 
 61491:     // Add the "Do-Not-Track" header
 61491:     if (mDoNotTrackEnabled) {
 61491:       rv = request->SetHeader(nsHttp::DoNotTrack,
 61491:                               NS_LITERAL_CSTRING("1"));
 61491:       if (NS_FAILED(rv)) return rv;
 61491:     }
 61491: 
 43113:     const nsHttpAtom &header = useProxy ? nsHttp::Proxy_Connection
 43113:                                         : nsHttp::Connection;
 43113:     return request->SetHeader(header, *connectionType);
 43113: }
 43113: 
 79445: bool
 43113: nsHttpHandler::IsAcceptableEncoding(const char *enc)
 43113: {
 43113:     if (!enc)
 80486:         return false;
 43113: 
 43113:     // HTTP 1.1 allows servers to send x-gzip and x-compress instead
 43113:     // of gzip and compress, for example.  So, we'll always strip off
 43113:     // an "x-" prefix before matching the encoding to one we claim
 43113:     // to accept.
 43113:     if (!PL_strncasecmp(enc, "x-", 2))
 43113:         enc += 2;
 43113:     
 43113:     return nsHttp::FindToken(mAcceptEncodings.get(), enc, HTTP_LWS ",") != nsnull;
 43113: }
 43113: 
 43113: nsresult
100634: nsHttpHandler::GetCacheSession(nsCacheStoragePolicy storagePolicy,
100634:                                bool isPrivate,
100634:                                nsICacheSession **result)
100634: {
100634:     nsresult rv;
100634: 
100634:     // Skip cache if disabled in preferences
100634:     if (!mUseCache)
100634:         return NS_ERROR_NOT_AVAILABLE;
100634: 
100634:     // We want to get the pointer to the cache service each time we're called,
100634:     // because it's possible for some add-ons (such as Google Gears) to swap
100634:     // in new cache services on the fly, and we want to pick them up as
100634:     // appropriate.
100634:     nsCOMPtr<nsICacheService> serv = do_GetService(NS_CACHESERVICE_CONTRACTID,
100634:                                                    &rv);
100634:     if (NS_FAILED(rv)) return rv;
100634: 
100634:     const char *sessionName = "HTTP";
100634:     switch (storagePolicy) {
100634:     case nsICache::STORE_IN_MEMORY:
100634:         sessionName = isPrivate ? "HTTP-memory-only-PB" : "HTTP-memory-only";
100634:         break;
100634:     case nsICache::STORE_OFFLINE:
100634:         sessionName = "HTTP-offline";
100634:         break;
100634:     default:
100634:         break;
100634:     }
100634: 
100634:     nsCOMPtr<nsICacheSession> cacheSession;
100634:     rv = serv->CreateSession(sessionName,
100634:                              storagePolicy,
100634:                              nsICache::STREAM_BASED,
100634:                              getter_AddRefs(cacheSession));
100634:     if (NS_FAILED(rv)) return rv;
100634: 
100634:     rv = cacheSession->SetDoomEntriesIfExpired(false);
100634:     if (NS_FAILED(rv)) return rv;
100634: 
100634:     NS_ADDREF(*result = cacheSession);
100634: 
100634:     return NS_OK;
100634: }
100634: 
100634: nsresult
 43113: nsHttpHandler::GetStreamConverterService(nsIStreamConverterService **result)
 43113: {
 43113:     if (!mStreamConvSvc) {
 43113:         nsresult rv;
 43113:         mStreamConvSvc = do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID, &rv);
 43113:         if (NS_FAILED(rv)) return rv;
 43113:     }
 43113:     *result = mStreamConvSvc;
 43113:     NS_ADDREF(*result);
 43113:     return NS_OK;
 43113: }
 43113: 
 51363: nsIStrictTransportSecurityService*
 51363: nsHttpHandler::GetSTSService()
 51363: {
 51363:     if (!mSTSService)
 51363:       mSTSService = do_GetService(NS_STSSERVICE_CONTRACTID);
 51363:     return mSTSService;
 51363: }
 51363: 
 43113: nsICookieService *
 43113: nsHttpHandler::GetCookieService()
 43113: {
 43113:     if (!mCookieService)
 43113:         mCookieService = do_GetService(NS_COOKIESERVICE_CONTRACTID);
 43113:     return mCookieService;
 43113: }
 43113: 
 43113: nsresult 
 43113: nsHttpHandler::GetIOService(nsIIOService** result)
 43113: {
 43113:     NS_ADDREF(*result = mIOService);
 43113:     return NS_OK;
 43113: }
 43113: 
 91115: PRUint32
 91115: nsHttpHandler::Get32BitsOfPseudoRandom()
 91115: {
 91115:     // only confirm rand seeding on socket thread
 91115:     NS_ABORT_IF_FALSE(PR_GetCurrentThread() == gSocketThread, "wrong thread");
 91115: 
 91115:     // rand() provides different amounts of PRNG on different platforms.
 91115:     // 15 or 31 bits are common amounts.
 91115: 
 91115:     PR_STATIC_ASSERT(RAND_MAX >= 0xfff);
 91115:     
 91115: #if RAND_MAX < 0xffffU
 91115:     return ((PRUint16) rand() << 20) |
 91115:             (((PRUint16) rand() & 0xfff) << 8) |
 91115:             ((PRUint16) rand() & 0xff);
 91115: #elif RAND_MAX < 0xffffffffU
 91115:     return ((PRUint16) rand() << 16) | ((PRUint16) rand() & 0xffff);
 91115: #else
 91115:     return (PRUint32) rand();
 91115: #endif
 91115: }
 43113: 
 43113: void
 43113: nsHttpHandler::NotifyObservers(nsIHttpChannel *chan, const char *event)
 43113: {
 43113:     LOG(("nsHttpHandler::NotifyObservers [chan=%x event=\"%s\"]\n", chan, event));
 43113:     if (mObserverService)
 43113:         mObserverService->NotifyObservers(chan, event, nsnull);
 43113: }
 43113: 
 43113: nsresult
 48304: nsHttpHandler::AsyncOnChannelRedirect(nsIChannel* oldChan, nsIChannel* newChan,
 43113:                                  PRUint32 flags)
 43113: {
 48304:     // TODO E10S This helper has to be initialized on the other process
 48304:     nsRefPtr<nsAsyncRedirectVerifyHelper> redirectCallbackHelper =
 48304:         new nsAsyncRedirectVerifyHelper();
 43113: 
 48304:     return redirectCallbackHelper->Init(oldChan, newChan, flags);
 43113: }
 43113: 
 43113: /* static */ nsresult
 43113: nsHttpHandler::GenerateHostPort(const nsCString& host, PRInt32 port,
 43113:                                 nsCString& hostLine)
 43113: {
 86082:     return NS_GenerateHostPort(host, port, hostLine);
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpHandler <private>
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: const nsAFlatCString &
 43113: nsHttpHandler::UserAgent()
 43113: {
 43113:     if (mUserAgentOverride) {
 43113:         LOG(("using general.useragent.override : %s\n", mUserAgentOverride.get()));
 43113:         return mUserAgentOverride;
 43113:     }
 43113: 
 43113:     if (mUserAgentIsDirty) {
 43113:         BuildUserAgent();
 80486:         mUserAgentIsDirty = false;
 43113:     }
 43113: 
 43113:     return mUserAgent;
 43113: }
 43113: 
 43113: void
 43113: nsHttpHandler::BuildUserAgent()
 43113: {
 43113:     LOG(("nsHttpHandler::BuildUserAgent\n"));
 43113: 
 51553:     NS_ASSERTION(!mLegacyAppName.IsEmpty() &&
 51553:                  !mLegacyAppVersion.IsEmpty() &&
 43113:                  !mPlatform.IsEmpty() &&
 43113:                  !mOscpu.IsEmpty(),
 43113:                  "HTTP cannot send practical requests without this much");
 43113: 
 43113:     // preallocate to worst-case size, which should always be better
 43113:     // than if we didn't preallocate at all.
 51553:     mUserAgent.SetCapacity(mLegacyAppName.Length() + 
 51553:                            mLegacyAppVersion.Length() + 
 48898: #ifndef UA_SPARE_PLATFORM
 43113:                            mPlatform.Length() + 
 48898: #endif
 43113:                            mOscpu.Length() +
 43113:                            mMisc.Length() +
 43113:                            mProduct.Length() +
 43113:                            mProductSub.Length() +
 51553:                            mAppName.Length() +
 51553:                            mAppVersion.Length() +
 51553:                            mCompatFirefox.Length() +
 89116:                            mCompatDevice.Length() +
 55839:                            13);
 43113: 
 43113:     // Application portion
 51553:     mUserAgent.Assign(mLegacyAppName);
 43113:     mUserAgent += '/';
 51553:     mUserAgent += mLegacyAppVersion;
 43113:     mUserAgent += ' ';
 43113: 
 43113:     // Application comment
 43113:     mUserAgent += '(';
 48898: #ifndef UA_SPARE_PLATFORM
 43113:     mUserAgent += mPlatform;
 43113:     mUserAgent.AppendLiteral("; ");
 48898: #endif
 98949: #if defined(ANDROID) || defined(MOZ_PLATFORM_MAEMO)
 89116:     if (!mCompatDevice.IsEmpty()) {
 89116:         mUserAgent += mCompatDevice;
 89116:         mUserAgent.AppendLiteral("; ");
 89116:     }
 89116: #else
 43113:     mUserAgent += mOscpu;
 43113:     mUserAgent.AppendLiteral("; ");
 89116: #endif
 43113:     mUserAgent += mMisc;
 43113:     mUserAgent += ')';
 43113: 
 43113:     // Product portion
 43113:     mUserAgent += ' ';
 43113:     mUserAgent += mProduct;
 43113:     mUserAgent += '/';
 43113:     mUserAgent += mProductSub;
 43113: 
 51554:     // "Firefox/x.y.z" compatibility token
 51554:     if (!mCompatFirefox.IsEmpty()) {
 51554:         mUserAgent += ' ';
 51554:         mUserAgent += mCompatFirefox;
 51554:     }
 51554: 
 51554:     // App portion
 51554:     mUserAgent += ' ';
 51554:     mUserAgent += mAppName;
 51554:     mUserAgent += '/';
 51554:     mUserAgent += mAppVersion;
 43113: }
 43113: 
 43113: #ifdef XP_WIN
 43113: #define WNT_BASE "Windows NT %ld.%ld"
 43113: #define W64_PREFIX "; Win64"
 43113: #endif
 43113: 
 43113: void
 43113: nsHttpHandler::InitUserAgentComponents()
 43113: {
 43113:     // Gather platform.
 43113:     mPlatform.AssignLiteral(
 43113: #if defined(ANDROID)
 43113:     "Android"
 43113: #elif defined(XP_OS2)
 43113:     "OS/2"
 43113: #elif defined(XP_WIN)
 43113:     "Windows"
 43113: #elif defined(XP_MACOSX)
 43113:     "Macintosh"
 51502: #elif defined(MOZ_PLATFORM_MAEMO)
 51502:     "Maemo"
 43113: #elif defined(MOZ_X11)
 43113:     "X11"
 43113: #else
 43113:     "?"
 43113: #endif
 43113:     );
 43113: 
 98949: #if defined(ANDROID) || defined(MOZ_PLATFORM_MAEMO)
 89116:     nsCOMPtr<nsIPropertyBag2> infoService = do_GetService("@mozilla.org/system-info;1");
 89116:     NS_ASSERTION(infoService, "Could not find a system info service");
 89116: 
 89829:     bool isTablet = false;
 89116:     infoService->GetPropertyAsBool(NS_LITERAL_STRING("tablet"), &isTablet);
 89116:     if (isTablet)
 89116:         mCompatDevice.AssignLiteral("Tablet");
 89116:     else
 89116:         mCompatDevice.AssignLiteral("Mobile");
 89116: #endif
 89116: 
 43113:     // Gather OS/CPU.
 43113: #if defined(XP_OS2)
 43113:     ULONG os2ver = 0;
 43113:     DosQuerySysInfo(QSV_VERSION_MINOR, QSV_VERSION_MINOR,
 43113:                     &os2ver, sizeof(os2ver));
 43113:     if (os2ver == 11)
 43113:         mOscpu.AssignLiteral("2.11");
 43113:     else if (os2ver == 30)
 43113:         mOscpu.AssignLiteral("Warp 3");
 43113:     else if (os2ver == 40)
 43113:         mOscpu.AssignLiteral("Warp 4");
 43113:     else if (os2ver == 45)
 43113:         mOscpu.AssignLiteral("Warp 4.5");
 43113: 
 69468: #elif defined(XP_WIN)
 43113:     OSVERSIONINFO info = { sizeof(OSVERSIONINFO) };
 43113:     if (GetVersionEx(&info)) {
 43113:         const char *format;
 69468: #if defined _M_IA64
 43113:         format = WNT_BASE W64_PREFIX "; IA64";
 43113: #elif defined _M_X64 || defined _M_AMD64
 43113:         format = WNT_BASE W64_PREFIX "; x64";
 43113: #else
 43113:         BOOL isWow64 = FALSE;
 90802:         if (!IsWow64Process(GetCurrentProcess(), &isWow64)) {
 43113:             isWow64 = FALSE;
 43113:         }
 43113:         format = isWow64
 43113:           ? WNT_BASE "; WOW64"
 43113:           : WNT_BASE;
 43113: #endif
 43113:         char *buf = PR_smprintf(format,
 43113:                                 info.dwMajorVersion,
 43113:                                 info.dwMinorVersion);
 43113:         if (buf) {
 43113:             mOscpu = buf;
 43113:             PR_smprintf_free(buf);
 43113:         }
 43113:     }
 43113: #elif defined (XP_MACOSX)
 43113: #if defined(__ppc__)
 43113:     mOscpu.AssignLiteral("PPC Mac OS X");
 43113: #elif defined(__i386__) || defined(__x86_64__)
 43113:     mOscpu.AssignLiteral("Intel Mac OS X");
 43113: #endif
 43113:     SInt32 majorVersion, minorVersion;
 43113:     if ((::Gestalt(gestaltSystemVersionMajor, &majorVersion) == noErr) &&
 43113:         (::Gestalt(gestaltSystemVersionMinor, &minorVersion) == noErr)) {
 43113:         mOscpu += nsPrintfCString(" %d.%d", majorVersion, minorVersion);
 43113:     }
 63458: #elif defined (XP_UNIX)
 43113:     struct utsname name;
 43113:     
 43113:     int ret = uname(&name);
 43113:     if (ret >= 0) {
 43113:         nsCAutoString buf;
 43113:         buf =  (char*)name.sysname;
 43113: 
 43113:         if (strcmp(name.machine, "x86_64") == 0 &&
 43113:             sizeof(void *) == sizeof(PRInt32)) {
 43113:             // We're running 32-bit code on x86_64. Make this browser
 43113:             // look like it's running on i686 hardware, but append "
 43113:             // (x86_64)" to the end of the oscpu identifier to be able
 43113:             // to differentiate this from someone running 64-bit code
 43113:             // on x86_64..
 43113: 
 51573:             buf += " i686 on x86_64";
 43113:         } else {
 43113:             buf += ' ';
 43113: 
 43113: #ifdef AIX
 43113:             // AIX uname returns machine specific info in the uname.machine
 43113:             // field and does not return the cpu type like other platforms.
 43113:             // We use the AIX version and release numbers instead.
 43113:             buf += (char*)name.version;
 43113:             buf += '.';
 43113:             buf += (char*)name.release;
 43113: #else
 43113:             buf += (char*)name.machine;
 43113: #endif
 43113:         }
 43113: 
 43113:         mOscpu.Assign(buf);
 43113:     }
 43113: #endif
 43113: 
 80486:     mUserAgentIsDirty = true;
 43113: }
 43113: 
 80847: PRUint32
 80847: nsHttpHandler::MaxSocketCount()
 80847: {
 80847:     PR_CallOnce(&nsSocketTransportService::gMaxCountInitOnce,
 80847:                 nsSocketTransportService::DiscoverMaxCount);
 80847:     // Don't use the full max count because sockets can be held in
 80847:     // the persistent connection pool for a long time and that could
 80847:     // starve other users.
 80847: 
 80847:     PRUint32 maxCount = nsSocketTransportService::gMaxCount;
 80847:     if (maxCount <= 8)
 80847:         maxCount = 1;
 80847:     else
 80847:         maxCount -= 8;
 80847: 
 80847:     return maxCount;
 80847: }
 80847: 
 43113: void
 43113: nsHttpHandler::PrefsChanged(nsIPrefBranch *prefs, const char *pref)
 43113: {
 43113:     nsresult rv = NS_OK;
 43113:     PRInt32 val;
 43113: 
 43113:     LOG(("nsHttpHandler::PrefsChanged [pref=%s]\n", pref));
 43113: 
 43113: #define PREF_CHANGED(p) ((pref == nsnull) || !PL_strcmp(pref, p))
 43113: #define MULTI_PREF_CHANGED(p) \
 43113:   ((pref == nsnull) || !PL_strncmp(pref, p, sizeof(p) - 1))
 43113: 
 43113:     //
 43113:     // UA components
 43113:     //
 43113: 
 79445:     bool cVar = false;
 51553: 
 51553:     if (PREF_CHANGED(UA_PREF("compatMode.firefox"))) {
 51553:         rv = prefs->GetBoolPref(UA_PREF("compatMode.firefox"), &cVar);
 51553:         if (NS_SUCCEEDED(rv) && cVar) {
 51675:             mCompatFirefox.AssignLiteral("Firefox/" MOZ_UA_FIREFOX_VERSION);
 51553:         } else {
 51553:             mCompatFirefox.Truncate();
 43113:         }
 80486:         mUserAgentIsDirty = true;
 43113:     }
 43113: 
 43113:     // general.useragent.override
 43113:     if (PREF_CHANGED(UA_PREF("override"))) {
 43113:         prefs->GetCharPref(UA_PREF("override"),
 43113:                             getter_Copies(mUserAgentOverride));
 80486:         mUserAgentIsDirty = true;
 43113:     }
 43113: 
 43113:     //
 43113:     // HTTP options
 43113:     //
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("keep-alive.timeout"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("keep-alive.timeout"), &val);
 43113:         if (NS_SUCCEEDED(rv))
 90872:             mIdleTimeout = PR_SecondsToInterval(clamped(val, 1, 0xffff));
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("request.max-attempts"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("request.max-attempts"), &val);
 43113:         if (NS_SUCCEEDED(rv))
 81029:             mMaxRequestAttempts = (PRUint16) clamped(val, 1, 0xffff);
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("request.max-start-delay"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("request.max-start-delay"), &val);
 43113:         if (NS_SUCCEEDED(rv)) {
 81029:             mMaxRequestDelay = (PRUint16) clamped(val, 0, 0xffff);
 43113:             if (mConnMgr)
 43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_REQUEST_DELAY,
 43113:                                       mMaxRequestDelay);
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("max-connections"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("max-connections"), &val);
 43113:         if (NS_SUCCEEDED(rv)) {
 80847: 
 81029:             mMaxConnections = (PRUint16) clamped((PRUint32)val,
 81029:                                                  (PRUint32)1, MaxSocketCount());
 80847: 
 43113:             if (mConnMgr)
 43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_CONNECTIONS,
 43113:                                       mMaxConnections);
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("max-connections-per-server"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("max-connections-per-server"), &val);
 43113:         if (NS_SUCCEEDED(rv)) {
 81029:             mMaxConnectionsPerServer = (PRUint8) clamped(val, 1, 0xff);
 43113:             if (mConnMgr) {
 43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_CONNECTIONS_PER_HOST,
 43113:                                       mMaxConnectionsPerServer);
 43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_CONNECTIONS_PER_PROXY,
 43113:                                       mMaxConnectionsPerServer);
 43113:             }
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("max-persistent-connections-per-server"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("max-persistent-connections-per-server"), &val);
 43113:         if (NS_SUCCEEDED(rv)) {
 81029:             mMaxPersistentConnectionsPerServer = (PRUint8) clamped(val, 1, 0xff);
 43113:             if (mConnMgr)
 43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PERSISTENT_CONNECTIONS_PER_HOST,
 43113:                                       mMaxPersistentConnectionsPerServer);
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("max-persistent-connections-per-proxy"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("max-persistent-connections-per-proxy"), &val);
 43113:         if (NS_SUCCEEDED(rv)) {
 81029:             mMaxPersistentConnectionsPerProxy = (PRUint8) clamped(val, 1, 0xff);
 43113:             if (mConnMgr)
 43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PERSISTENT_CONNECTIONS_PER_PROXY,
 43113:                                       mMaxPersistentConnectionsPerProxy);
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("sendRefererHeader"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("sendRefererHeader"), &val);
 43113:         if (NS_SUCCEEDED(rv))
 81029:             mReferrerLevel = (PRUint8) clamped(val, 0, 0xff);
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("redirection-limit"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("redirection-limit"), &val);
 43113:         if (NS_SUCCEEDED(rv))
 81029:             mRedirectionLimit = (PRUint8) clamped(val, 0, 0xff);
 43113:     }
 43113: 
 64613:     if (PREF_CHANGED(HTTP_PREF("connection-retry-timeout"))) {
 64613:         rv = prefs->GetIntPref(HTTP_PREF("connection-retry-timeout"), &val);
 64613:         if (NS_SUCCEEDED(rv))
 81029:             mIdleSynTimeout = (PRUint16) clamped(val, 0, 3000);
 64613:     }
 64613: 
 77314:     if (PREF_CHANGED(HTTP_PREF("fast-fallback-to-IPv4"))) {
 77314:         rv = prefs->GetBoolPref(HTTP_PREF("fast-fallback-to-IPv4"), &cVar);
 77314:         if (NS_SUCCEEDED(rv))
 77314:             mFastFallbackToIPv4 = cVar;
 77314:     }
 77314: 
 43113:     if (PREF_CHANGED(HTTP_PREF("version"))) {
 43113:         nsXPIDLCString httpVersion;
 43113:         prefs->GetCharPref(HTTP_PREF("version"), getter_Copies(httpVersion));
 43113:         if (httpVersion) {
 43113:             if (!PL_strcmp(httpVersion, "1.1"))
 43113:                 mHttpVersion = NS_HTTP_VERSION_1_1;
 43113:             else if (!PL_strcmp(httpVersion, "0.9"))
 43113:                 mHttpVersion = NS_HTTP_VERSION_0_9;
 43113:             else
 43113:                 mHttpVersion = NS_HTTP_VERSION_1_0;
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("proxy.version"))) {
 43113:         nsXPIDLCString httpVersion;
 43113:         prefs->GetCharPref(HTTP_PREF("proxy.version"), getter_Copies(httpVersion));
 43113:         if (httpVersion) {
 43113:             if (!PL_strcmp(httpVersion, "1.1"))
 43113:                 mProxyHttpVersion = NS_HTTP_VERSION_1_1;
 43113:             else
 43113:                 mProxyHttpVersion = NS_HTTP_VERSION_1_0;
 43113:             // it does not make sense to issue a HTTP/0.9 request to a proxy server
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("keep-alive"))) {
 43113:         rv = prefs->GetBoolPref(HTTP_PREF("keep-alive"), &cVar);
 43113:         if (NS_SUCCEEDED(rv)) {
 43113:             if (cVar)
 43113:                 mCapabilities |= NS_HTTP_ALLOW_KEEPALIVE;
 43113:             else
 43113:                 mCapabilities &= ~NS_HTTP_ALLOW_KEEPALIVE;
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("proxy.keep-alive"))) {
 43113:         rv = prefs->GetBoolPref(HTTP_PREF("proxy.keep-alive"), &cVar);
 43113:         if (NS_SUCCEEDED(rv)) {
 43113:             if (cVar)
 43113:                 mProxyCapabilities |= NS_HTTP_ALLOW_KEEPALIVE;
 43113:             else
 43113:                 mProxyCapabilities &= ~NS_HTTP_ALLOW_KEEPALIVE;
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("pipelining"))) {
 43113:         rv = prefs->GetBoolPref(HTTP_PREF("pipelining"), &cVar);
 43113:         if (NS_SUCCEEDED(rv)) {
 43113:             if (cVar)
 43113:                 mCapabilities |=  NS_HTTP_ALLOW_PIPELINING;
 43113:             else
 43113:                 mCapabilities &= ~NS_HTTP_ALLOW_PIPELINING;
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("pipelining.maxrequests"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("pipelining.maxrequests"), &val);
 43113:         if (NS_SUCCEEDED(rv)) {
 93840:             mMaxPipelinedRequests = clamped(val, 1, 0xffff);
 43113:             if (mConnMgr)
 43113:                 mConnMgr->UpdateParam(nsHttpConnectionMgr::MAX_PIPELINED_REQUESTS,
 43113:                                       mMaxPipelinedRequests);
 43113:         }
 43113:     }
 43113: 
 93840:     if (PREF_CHANGED(HTTP_PREF("pipelining.max-optimistic-requests"))) {
 93840:         rv = prefs->
 93840:             GetIntPref(HTTP_PREF("pipelining.max-optimistic-requests"), &val);
 93840:         if (NS_SUCCEEDED(rv)) {
 93840:             mMaxOptimisticPipelinedRequests = clamped(val, 1, 0xffff);
 93840:             if (mConnMgr)
 93840:                 mConnMgr->UpdateParam
 93840:                     (nsHttpConnectionMgr::MAX_OPTIMISTIC_PIPELINED_REQUESTS,
 93840:                      mMaxOptimisticPipelinedRequests);
 93840:         }
 93840:     }
 93840: 
 93840:     if (PREF_CHANGED(HTTP_PREF("pipelining.aggressive"))) {
 93840:         rv = prefs->GetBoolPref(HTTP_PREF("pipelining.aggressive"), &cVar);
 93840:         if (NS_SUCCEEDED(rv))
 93840:             mPipelineAggressive = cVar;
 93840:     }
 93840: 
 93843:     if (PREF_CHANGED(HTTP_PREF("pipelining.maxsize"))) {
 93843:         rv = prefs->GetIntPref(HTTP_PREF("pipelining.maxsize"), &val);
 93843:         if (NS_SUCCEEDED(rv)) {
 93843:             mMaxPipelineObjectSize =
 93843:                 static_cast<PRInt64>(clamped(val, 1000, 100000000));
 93843:         }
 93843:     }
 93843: 
 95197:     // Determines whether or not to actually reschedule after the
 95197:     // reschedule-timeout has expired
 95197:     if (PREF_CHANGED(HTTP_PREF("pipelining.reschedule-on-timeout"))) {
 95197:         rv = prefs->GetBoolPref(HTTP_PREF("pipelining.reschedule-on-timeout"),
 95197:                                 &cVar);
 95197:         if (NS_SUCCEEDED(rv))
 95197:             mPipelineRescheduleOnTimeout = cVar;
 95197:     }
 95197: 
 95197:     // The amount of time head of line blocking is allowed (in ms)
 95197:     // before the blocked transactions are moved to another pipeline
 95197:     if (PREF_CHANGED(HTTP_PREF("pipelining.reschedule-timeout"))) {
 95197:         rv = prefs->GetIntPref(HTTP_PREF("pipelining.reschedule-timeout"),
 95197:                                &val);
 95197:         if (NS_SUCCEEDED(rv)) {
 95197:             mPipelineRescheduleTimeout =
 95197:                 PR_MillisecondsToInterval((PRUint16) clamped(val, 500, 0xffff));
 95197:         }
 95197:     }
 95197: 
 95197:     // The amount of time a pipelined transaction is allowed to wait before
 95197:     // being canceled and retried in a non-pipeline connection
 93844:     if (PREF_CHANGED(HTTP_PREF("pipelining.read-timeout"))) {
 93844:         rv = prefs->GetIntPref(HTTP_PREF("pipelining.read-timeout"), &val);
 93844:         if (NS_SUCCEEDED(rv)) {
 93844:             mPipelineReadTimeout =
 95197:                 PR_MillisecondsToInterval((PRUint16) clamped(val, 5000,
 95197:                                                              0xffff));
 93844:         }
 93844:     }
 93844: 
 43113:     if (PREF_CHANGED(HTTP_PREF("pipelining.ssl"))) {
 43113:         rv = prefs->GetBoolPref(HTTP_PREF("pipelining.ssl"), &cVar);
 43113:         if (NS_SUCCEEDED(rv))
 43113:             mPipeliningOverSSL = cVar;
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("proxy.pipelining"))) {
 43113:         rv = prefs->GetBoolPref(HTTP_PREF("proxy.pipelining"), &cVar);
 43113:         if (NS_SUCCEEDED(rv)) {
 43113:             if (cVar)
 43113:                 mProxyCapabilities |=  NS_HTTP_ALLOW_PIPELINING;
 43113:             else
 43113:                 mProxyCapabilities &= ~NS_HTTP_ALLOW_PIPELINING;
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("qos"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("qos"), &val);
 43113:         if (NS_SUCCEEDED(rv))
 81029:             mQoSBits = (PRUint8) clamped(val, 0, 0xff);
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("sendSecureXSiteReferrer"))) {
 43113:         rv = prefs->GetBoolPref(HTTP_PREF("sendSecureXSiteReferrer"), &cVar);
 43113:         if (NS_SUCCEEDED(rv))
 43113:             mSendSecureXSiteReferrer = cVar;
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("accept.default"))) {
 43113:         nsXPIDLCString accept;
 43113:         rv = prefs->GetCharPref(HTTP_PREF("accept.default"),
 43113:                                   getter_Copies(accept));
 43113:         if (NS_SUCCEEDED(rv))
 43113:             SetAccept(accept);
 43113:     }
 43113:     
 43113:     if (PREF_CHANGED(HTTP_PREF("accept-encoding"))) {
 43113:         nsXPIDLCString acceptEncodings;
 43113:         rv = prefs->GetCharPref(HTTP_PREF("accept-encoding"),
 43113:                                   getter_Copies(acceptEncodings));
 43113:         if (NS_SUCCEEDED(rv))
 43113:             SetAcceptEncodings(acceptEncodings);
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("use-cache"))) {
 43113:         rv = prefs->GetBoolPref(HTTP_PREF("use-cache"), &cVar);
 43113:         if (NS_SUCCEEDED(rv)) {
 43113:             mUseCache = cVar;
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("default-socket-type"))) {
 43113:         nsXPIDLCString sval;
 43113:         rv = prefs->GetCharPref(HTTP_PREF("default-socket-type"),
 43113:                                 getter_Copies(sval));
 43113:         if (NS_SUCCEEDED(rv)) {
 43113:             if (sval.IsEmpty())
 43113:                 mDefaultSocketType.Adopt(0);
 43113:             else {
 43113:                 // verify that this socket type is actually valid
 43113:                 nsCOMPtr<nsISocketProviderService> sps(
 43113:                         do_GetService(NS_SOCKETPROVIDERSERVICE_CONTRACTID));
 43113:                 if (sps) {
 43113:                     nsCOMPtr<nsISocketProvider> sp;
 43113:                     rv = sps->GetSocketProvider(sval, getter_AddRefs(sp));
 43113:                     if (NS_SUCCEEDED(rv)) {
 43113:                         // OK, this looks like a valid socket provider.
 43113:                         mDefaultSocketType.Assign(sval);
 43113:                     }
 43113:                 }
 43113:             }
 43113:         }
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("prompt-temp-redirect"))) {
 43113:         rv = prefs->GetBoolPref(HTTP_PREF("prompt-temp-redirect"), &cVar);
 43113:         if (NS_SUCCEEDED(rv)) {
 43113:             mPromptTempRedirect = cVar;
 43113:         }
 43113:     }
 43113: 
 93839:     if (PREF_CHANGED(HTTP_PREF("assoc-req.enforce"))) {
 93839:         cVar = false;
 93839:         rv = prefs->GetBoolPref(HTTP_PREF("assoc-req.enforce"), &cVar);
 93839:         if (NS_SUCCEEDED(rv))
 93839:             mEnforceAssocReq = cVar;
 93839:     }
 93839: 
 43113:     // enable Persistent caching for HTTPS - bug#205921    
 43113:     if (PREF_CHANGED(BROWSER_PREF("disk_cache_ssl"))) {
 80486:         cVar = false;
 43113:         rv = prefs->GetBoolPref(BROWSER_PREF("disk_cache_ssl"), &cVar);
 43113:         if (NS_SUCCEEDED(rv))
 43113:             mEnablePersistentHttpsCaching = cVar;
 43113:     }
 43113: 
 43113:     if (PREF_CHANGED(HTTP_PREF("phishy-userpass-length"))) {
 43113:         rv = prefs->GetIntPref(HTTP_PREF("phishy-userpass-length"), &val);
 43113:         if (NS_SUCCEEDED(rv))
 81029:             mPhishyUserPassLength = (PRUint8) clamped(val, 0, 0xff);
 43113:     }
 43113: 
 84549:     if (PREF_CHANGED(HTTP_PREF("spdy.enabled"))) {
 84549:         rv = prefs->GetBoolPref(HTTP_PREF("spdy.enabled"), &cVar);
 84549:         if (NS_SUCCEEDED(rv))
 84549:             mEnableSpdy = cVar;
 84549:     }
 84549: 
 99498:     if (PREF_CHANGED(HTTP_PREF("spdy.enabled.v2"))) {
 99498:         rv = prefs->GetBoolPref(HTTP_PREF("spdy.enabled.v2"), &cVar);
 99498:         if (NS_SUCCEEDED(rv))
 99498:             mSpdyV2 = cVar;
 99498:     }
 99498: 
 99498:     if (PREF_CHANGED(HTTP_PREF("spdy.enabled.v3"))) {
 99498:         rv = prefs->GetBoolPref(HTTP_PREF("spdy.enabled.v3"), &cVar);
 99498:         if (NS_SUCCEEDED(rv))
 99498:             mSpdyV3 = cVar;
 99498:     }
 99498: 
 84549:     if (PREF_CHANGED(HTTP_PREF("spdy.coalesce-hostnames"))) {
 84549:         rv = prefs->GetBoolPref(HTTP_PREF("spdy.coalesce-hostnames"), &cVar);
 84549:         if (NS_SUCCEEDED(rv))
 84549:             mCoalesceSpdy = cVar;
 84549:     }
 84549: 
 84549:     if (PREF_CHANGED(HTTP_PREF("spdy.use-alternate-protocol"))) {
 84549:         rv = prefs->GetBoolPref(HTTP_PREF("spdy.use-alternate-protocol"),
 84549:                                 &cVar);
 84549:         if (NS_SUCCEEDED(rv))
 84549:             mUseAlternateProtocol = cVar;
 84549:     }
 84549: 
 84549:     if (PREF_CHANGED(HTTP_PREF("spdy.timeout"))) {
 84549:         rv = prefs->GetIntPref(HTTP_PREF("spdy.timeout"), &val);
 84549:         if (NS_SUCCEEDED(rv))
 90872:             mSpdyTimeout = PR_SecondsToInterval(clamped(val, 1, 0xffff));
 84549:     }
 84549: 
 88247:     if (PREF_CHANGED(HTTP_PREF("spdy.chunk-size"))) {
 88247:         rv = prefs->GetIntPref(HTTP_PREF("spdy.chunk-size"), &val);
 88247:         if (NS_SUCCEEDED(rv))
 88247:             mSpdySendingChunkSize = (PRUint32) clamped(val, 1, 0x7fffffff);
 88247:     }
 88247: 
 90872:     // The amount of idle seconds on a spdy connection before initiating a
 90872:     // server ping. 0 will disable.
 90872:     if (PREF_CHANGED(HTTP_PREF("spdy.ping-threshold"))) {
 90872:         rv = prefs->GetIntPref(HTTP_PREF("spdy.ping-threshold"), &val);
 90872:         if (NS_SUCCEEDED(rv))
 90872:             mSpdyPingThreshold =
 90872:                 PR_SecondsToInterval((PRUint16) clamped(val, 0, 0x7fffffff));
 90872:     }
 90872: 
 90872:     // The amount of seconds to wait for a spdy ping response before
 90872:     // closing the session.
 90872:     if (PREF_CHANGED(HTTP_PREF("spdy.ping-timeout"))) {
 90872:         rv = prefs->GetIntPref(HTTP_PREF("spdy.ping-timeout"), &val);
 90872:         if (NS_SUCCEEDED(rv))
 90872:             mSpdyPingTimeout =
 90872:                 PR_SecondsToInterval((PRUint16) clamped(val, 0, 0x7fffffff));
 90872:     }
 90872: 
100626:     // on transition of network.http.diagnostics to true print
100626:     // a bunch of information to the console
100626:     if (pref && PREF_CHANGED(HTTP_PREF("diagnostics"))) {
100626:         rv = prefs->GetBoolPref(HTTP_PREF("diagnostics"), &cVar);
100626:         if (NS_SUCCEEDED(rv) && cVar) {
100626:             if (mConnMgr)
100626:                 mConnMgr->PrintDiagnostics();
100626:         }
100626:     }
 43113:     //
 43113:     // INTL options
 43113:     //
 43113: 
 43113:     if (PREF_CHANGED(INTL_ACCEPT_LANGUAGES)) {
 43113:         nsCOMPtr<nsIPrefLocalizedString> pls;
 43113:         prefs->GetComplexValue(INTL_ACCEPT_LANGUAGES,
 43113:                                 NS_GET_IID(nsIPrefLocalizedString),
 43113:                                 getter_AddRefs(pls));
 43113:         if (pls) {
 43113:             nsXPIDLString uval;
 43113:             pls->ToString(getter_Copies(uval));
 43113:             if (uval)
 43113:                 SetAcceptLanguages(NS_ConvertUTF16toUTF8(uval).get());
 43113:         } 
 43113:     }
 43113: 
 43113:     //
 43113:     // IDN options
 43113:     //
 43113: 
 43113:     if (PREF_CHANGED(NETWORK_ENABLEIDN)) {
 79445:         bool enableIDN = false;
 43113:         prefs->GetBoolPref(NETWORK_ENABLEIDN, &enableIDN);
 43113:         // No locking is required here since this method runs in the main
 43113:         // UI thread, and so do all the methods in nsHttpChannel.cpp
 43113:         // (mIDNConverter is used by nsHttpChannel)
 43113:         if (enableIDN && !mIDNConverter) {
 43113:             mIDNConverter = do_GetService(NS_IDNSERVICE_CONTRACTID);
 43113:             NS_ASSERTION(mIDNConverter, "idnSDK not installed");
 43113:         }
 43113:         else if (!enableIDN && mIDNConverter)
 43113:             mIDNConverter = nsnull;
 43113:     }
 43113: 
 61491:     //
 61491:     // Tracking options
 61491:     //
 61491: 
 61491:     if (PREF_CHANGED(DONOTTRACK_HEADER_ENABLED)) {
 80486:         cVar = false;
 61491:         rv = prefs->GetBoolPref(DONOTTRACK_HEADER_ENABLED, &cVar);
 61491:         if (NS_SUCCEEDED(rv)) {
 61491:             mDoNotTrackEnabled = cVar;
 61491:         }
 61491:     }
 61491: 
 91115:     //
 91115:     // Telemetry
 91115:     //
 91115: 
 91115:     if (PREF_CHANGED(TELEMETRY_ENABLED)) {
 91115:         cVar = false;
 91115:         rv = prefs->GetBoolPref(TELEMETRY_ENABLED, &cVar);
 91115:         if (NS_SUCCEEDED(rv)) {
 91115:             mTelemetryEnabled = cVar;
 91115:         }
 91115:     }
 91115: 
 91115:     //
 91115:     // network.allow-experiments
 91115:     //
 91115: 
 91115:     if (PREF_CHANGED(ALLOW_EXPERIMENTS)) {
 91115:         cVar = true;
 91115:         rv = prefs->GetBoolPref(ALLOW_EXPERIMENTS, &cVar);
 91115:         if (NS_SUCCEEDED(rv)) {
 91115:             mAllowExperiments = cVar;
 91115:         }
 91115:     }
 91115: 
 43113: #undef PREF_CHANGED
 43113: #undef MULTI_PREF_CHANGED
 43113: }
 43113: 
 43113: /**
 43113:  *  Allocates a C string into that contains a ISO 639 language list
 43113:  *  notated with HTTP "q" values for output with a HTTP Accept-Language
 43113:  *  header. Previous q values will be stripped because the order of
 43113:  *  the langs imply the q value. The q values are calculated by dividing
 43113:  *  1.0 amongst the number of languages present.
 43113:  *
 43113:  *  Ex: passing: "en, ja"
 43113:  *      returns: "en,ja;q=0.5"
 43113:  *
 43113:  *      passing: "en, ja, fr_CA"
 43113:  *      returns: "en,ja;q=0.7,fr_CA;q=0.3"
 43113:  */
 43113: static nsresult
 43113: PrepareAcceptLanguages(const char *i_AcceptLanguages, nsACString &o_AcceptLanguages)
 43113: {
 43113:     if (!i_AcceptLanguages)
 43113:         return NS_OK;
 43113: 
 43113:     PRUint32 n, size, wrote;
 43113:     double q, dec;
 43113:     char *p, *p2, *token, *q_Accept, *o_Accept;
 43113:     const char *comma;
 43113:     PRInt32 available;
 43113: 
 43113:     o_Accept = nsCRT::strdup(i_AcceptLanguages);
 43113:     if (!o_Accept)
 43113:         return NS_ERROR_OUT_OF_MEMORY;
 43113:     for (p = o_Accept, n = size = 0; '\0' != *p; p++) {
 43113:         if (*p == ',') n++;
 43113:             size++;
 43113:     }
 43113: 
 43113:     available = size + ++n * 11 + 1;
 43113:     q_Accept = new char[available];
 43113:     if (!q_Accept) {
 43113:         nsCRT::free(o_Accept);
 43113:         return NS_ERROR_OUT_OF_MEMORY;
 43113:     }
 43113:     *q_Accept = '\0';
 43113:     q = 1.0;
 43113:     dec = q / (double) n;
 43113:     n = 0;
 43113:     p2 = q_Accept;
 43113:     for (token = nsCRT::strtok(o_Accept, ",", &p);
 43113:          token != (char *) 0;
 43113:          token = nsCRT::strtok(p, ",", &p))
 43113:     {
 43113:         token = net_FindCharNotInSet(token, HTTP_LWS);
 43113:         char* trim;
 43113:         trim = net_FindCharInSet(token, ";" HTTP_LWS);
 43113:         if (trim != (char*)0)  // remove "; q=..." if present
 43113:             *trim = '\0';
 43113: 
 43113:         if (*token != '\0') {
 43113:             comma = n++ != 0 ? "," : ""; // delimiter if not first item
 43113:             PRUint32 u = QVAL_TO_UINT(q);
 43113:             if (u < 10)
 43113:                 wrote = PR_snprintf(p2, available, "%s%s;q=0.%u", comma, token, u);
 43113:             else
 43113:                 wrote = PR_snprintf(p2, available, "%s%s", comma, token);
 43113:             q -= dec;
 43113:             p2 += wrote;
 43113:             available -= wrote;
 43113:             NS_ASSERTION(available > 0, "allocated string not long enough");
 43113:         }
 43113:     }
 43113:     nsCRT::free(o_Accept);
 43113: 
 43113:     o_AcceptLanguages.Assign((const char *) q_Accept);
 43113:     delete [] q_Accept;
 43113: 
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpHandler::SetAcceptLanguages(const char *aAcceptLanguages) 
 43113: {
 43113:     nsCAutoString buf;
 43113:     nsresult rv = PrepareAcceptLanguages(aAcceptLanguages, buf);
 43113:     if (NS_SUCCEEDED(rv))
 43113:         mAcceptLanguages.Assign(buf);
 43113:     return rv;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpHandler::SetAccept(const char *aAccept) 
 43113: {
 43113:     mAccept = aAccept;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: nsresult
 43113: nsHttpHandler::SetAcceptEncodings(const char *aAcceptEncodings) 
 43113: {
 43113:     mAcceptEncodings = aAcceptEncodings;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpHandler::nsISupports
 43113: //-----------------------------------------------------------------------------
 43113: 
 96927: NS_IMPL_THREADSAFE_ISUPPORTS6(nsHttpHandler,
 43113:                               nsIHttpProtocolHandler,
 43113:                               nsIProxiedProtocolHandler,
 43113:                               nsIProtocolHandler,
 43113:                               nsIObserver,
 96927:                               nsISupportsWeakReference,
 96927:                               nsISpeculativeConnect)
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpHandler::nsIProtocolHandler
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetScheme(nsACString &aScheme)
 43113: {
 43113:     aScheme.AssignLiteral("http");
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetDefaultPort(PRInt32 *result)
 43113: {
 43113:     *result = NS_HTTP_DEFAULT_PORT;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetProtocolFlags(PRUint32 *result)
 43113: {
 43113:     *result = NS_HTTP_PROTOCOL_FLAGS;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::NewURI(const nsACString &aSpec,
 43113:                       const char *aCharset,
 43113:                       nsIURI *aBaseURI,
 43113:                       nsIURI **aURI)
 43113: {
 43113:     LOG(("nsHttpHandler::NewURI\n"));
 43113:     return ::NewURI(aSpec, aCharset, aBaseURI, NS_HTTP_DEFAULT_PORT, aURI);
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::NewChannel(nsIURI *uri, nsIChannel **result)
 43113: {
 43113:     LOG(("nsHttpHandler::NewChannel\n"));
 43113: 
 43113:     NS_ENSURE_ARG_POINTER(uri);
 43113:     NS_ENSURE_ARG_POINTER(result);
 43113: 
 79445:     bool isHttp = false, isHttps = false;
 43113: 
 43113:     // Verify that we have been given a valid scheme
 43113:     nsresult rv = uri->SchemeIs("http", &isHttp);
 43113:     if (NS_FAILED(rv)) return rv;
 43113:     if (!isHttp) {
 43113:         rv = uri->SchemeIs("https", &isHttps);
 43113:         if (NS_FAILED(rv)) return rv;
 43113:         if (!isHttps) {
 43113:             NS_WARNING("Invalid URI scheme");
 43113:             return NS_ERROR_UNEXPECTED;
 43113:         }
 43113:     }
 43113:     
 43113:     return NewProxiedChannel(uri, nsnull, result);
 43113: }
 43113: 
 43113: NS_IMETHODIMP 
 79445: nsHttpHandler::AllowPort(PRInt32 port, const char *scheme, bool *_retval)
 43113: {
 43113:     // don't override anything.  
 80486:     *_retval = false;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpHandler::nsIProxiedProtocolHandler
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::NewProxiedChannel(nsIURI *uri,
 43113:                                  nsIProxyInfo* givenProxyInfo,
 43113:                                  nsIChannel **result)
 43113: {
 46790:     nsRefPtr<HttpBaseChannel> httpChannel;
 46404: 
 43113:     LOG(("nsHttpHandler::NewProxiedChannel [proxyInfo=%p]\n",
 43113:         givenProxyInfo));
 43113:     
 43113:     nsCOMPtr<nsProxyInfo> proxyInfo;
 43113:     if (givenProxyInfo) {
 43113:         proxyInfo = do_QueryInterface(givenProxyInfo);
 43113:         NS_ENSURE_ARG(proxyInfo);
 43113:     }
 43113: 
 79445:     bool https;
 43113:     nsresult rv = uri->SchemeIs("https", &https);
 43113:     if (NS_FAILED(rv))
 43113:         return rv;
 43113: 
 46672:     if (IsNeckoChild()) {
 46790:         httpChannel = new HttpChannelChild();
 67579:     } else {
 46790:         httpChannel = new nsHttpChannel();
 46672:     }
 43113: 
 43113:     // select proxy caps if using a non-transparent proxy.  SSL tunneling
 43113:     // should not use proxy settings.
 43113:     PRInt8 caps;
 43113:     if (proxyInfo && !nsCRT::strcmp(proxyInfo->Type(), "http") && !https)
 43113:         caps = mProxyCapabilities;
 43113:     else
 43113:         caps = mCapabilities;
 43113: 
 43113:     if (https) {
 43113:         // enable pipelining over SSL if requested
 43113:         if (mPipeliningOverSSL)
 43113:             caps |= NS_HTTP_ALLOW_PIPELINING;
 43113: 
 67579:         if (!IsNeckoChild()) {
 43113:             // HACK: make sure PSM gets initialized on the main thread.
 58031:             net_EnsurePSMInit();
 43113:         }
 54830:     }
 43113: 
 43113:     rv = httpChannel->Init(uri, caps, proxyInfo);
 46790:     if (NS_FAILED(rv))
 46790:         return rv;
 43113: 
 46790:     httpChannel.forget(result);
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpHandler::nsIHttpProtocolHandler
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetUserAgent(nsACString &value)
 43113: {
 43113:     value = UserAgent();
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetAppName(nsACString &value)
 43113: {
 51553:     value = mLegacyAppName;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetAppVersion(nsACString &value)
 43113: {
 51553:     value = mLegacyAppVersion;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetProduct(nsACString &value)
 43113: {
 43113:     value = mProduct;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetProductSub(nsACString &value)
 43113: {
 43113:     value = mProductSub;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetPlatform(nsACString &value)
 43113: {
 43113:     value = mPlatform;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetOscpu(nsACString &value)
 43113: {
 43113:     value = mOscpu;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::GetMisc(nsACString &value)
 43113: {
 43113:     value = mMisc;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpHandler::nsIObserver
 43113: //-----------------------------------------------------------------------------
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpHandler::Observe(nsISupports *subject,
 43113:                        const char *topic,
 43113:                        const PRUnichar *data)
 43113: {
 43113:     LOG(("nsHttpHandler::Observe [topic=\"%s\"]\n", topic));
 43113: 
 43113:     if (strcmp(topic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID) == 0) {
 43113:         nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(subject);
 43113:         if (prefBranch)
 43113:             PrefsChanged(prefBranch, NS_ConvertUTF16toUTF8(data).get());
 43113:     }
 43113:     else if (strcmp(topic, "profile-change-net-teardown")    == 0 ||
 43113:              strcmp(topic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)    == 0) {
 43113: 
 43113:         // clear cache of all authentication credentials.
 43113:         mAuthCache.ClearAll();
 43113: 
 43113:         // ensure connection manager is shutdown
 43113:         if (mConnMgr)
 43113:             mConnMgr->Shutdown();
 43113: 
 43113:         // need to reset the session start time since cache validation may
 43113:         // depend on this value.
 43113:         mSessionStartTime = NowInSeconds();
 43113:     }
 43113:     else if (strcmp(topic, "profile-change-net-restore") == 0) {
 43113:         // initialize connection manager
 43113:         InitConnectionMgr();
 43113:     }
 43113:     else if (strcmp(topic, "net:clear-active-logins") == 0) {
 43113:         mAuthCache.ClearAll();
 43113:     }
 55823:     else if (strcmp(topic, "net:prune-dead-connections") == 0) {
 55823:         if (mConnMgr) {
 55823:             mConnMgr->PruneDeadConnections();
 55823:         }
 55823:     }
 94990:     else if (strcmp(topic, "net:failed-to-process-uri-content") == 0) {
 93847:         nsCOMPtr<nsIURI> uri = do_QueryInterface(subject);
 93847:         if (uri && mConnMgr)
 93847:             mConnMgr->ReportFailedToProcess(uri);
 93847:     }
 43113:   
 43113:     return NS_OK;
 43113: }
 43113: 
 96927: // nsISpeculativeConnect
 96927: 
 96927: NS_IMETHODIMP
 96927: nsHttpHandler::SpeculativeConnect(nsIURI *aURI,
 96927:                                   nsIInterfaceRequestor *aCallbacks,
 96927:                                   nsIEventTarget *aTarget)
 96927: {
 96927:     nsIStrictTransportSecurityService* stss = gHttpHandler->GetSTSService();
 96927:     bool isStsHost = false;
 96927:     if (!stss)
 96927:         return NS_OK;
 96927:     
 96927:     nsCOMPtr<nsIURI> clone;
 96927:     if (NS_SUCCEEDED(stss->IsStsURI(aURI, &isStsHost)) && isStsHost) {
 96927:         if (NS_SUCCEEDED(aURI->Clone(getter_AddRefs(clone)))) {
 96927:             clone->SetScheme(NS_LITERAL_CSTRING("https"));
 96927:             aURI = clone.get();
 96927:         }
 96927:     }
 96927: 
 96927:     nsCAutoString scheme;
 96927:     nsresult rv = aURI->GetScheme(scheme);
 96927:     if (NS_FAILED(rv))
 96927:         return rv;
 96927: 
 96927:     // If this is HTTPS, make sure PSM is initialized as the channel
 96927:     // creation path may have been bypassed
 96927:     if (scheme.EqualsLiteral("https")) {
 96927:         if (!IsNeckoChild()) {
 96927:             // make sure PSM gets initialized on the main thread.
 96927:             net_EnsurePSMInit();
 96927:         }
 96927:     }
 96927:     // Ensure that this is HTTP or HTTPS, otherwise we don't do preconnect here
 96927:     else if (!scheme.EqualsLiteral("http"))
 96927:         return NS_ERROR_UNEXPECTED;
 96927: 
 96927:     // Construct connection info object
 96927:     bool usingSSL = false;
 96927:     rv = aURI->SchemeIs("https", &usingSSL);
 96927:     if (NS_FAILED(rv))
 96927:         return rv;
 96927: 
 96927:     nsCAutoString host;
 96927:     rv = aURI->GetAsciiHost(host);
 96927:     if (NS_FAILED(rv))
 96927:         return rv;
 96927: 
 96927:     PRInt32 port = -1;
 96927:     rv = aURI->GetPort(&port);
 96927:     if (NS_FAILED(rv))
 96927:         return rv;
 96927: 
 96927:     nsHttpConnectionInfo *ci =
 96927:         new nsHttpConnectionInfo(host, port, nsnull, usingSSL);
 96927: 
 96927:     return SpeculativeConnect(ci, aCallbacks, aTarget);
 96927: }
 96927: 
 43113: //-----------------------------------------------------------------------------
 43113: // nsHttpsHandler implementation
 43113: //-----------------------------------------------------------------------------
 43113: 
 96927: NS_IMPL_THREADSAFE_ISUPPORTS5(nsHttpsHandler,
 43113:                               nsIHttpProtocolHandler,
 43113:                               nsIProxiedProtocolHandler,
 43113:                               nsIProtocolHandler,
 96927:                               nsISupportsWeakReference,
 96927:                               nsISpeculativeConnect)
 43113: 
 43113: nsresult
 43113: nsHttpsHandler::Init()
 43113: {
 43113:     nsCOMPtr<nsIProtocolHandler> httpHandler(
 43113:             do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http"));
 43113:     NS_ASSERTION(httpHandler.get() != nsnull, "no http handler?");
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpsHandler::GetScheme(nsACString &aScheme)
 43113: {
 43113:     aScheme.AssignLiteral("https");
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpsHandler::GetDefaultPort(PRInt32 *aPort)
 43113: {
 43113:     *aPort = NS_HTTPS_DEFAULT_PORT;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpsHandler::GetProtocolFlags(PRUint32 *aProtocolFlags)
 43113: {
 43113:     *aProtocolFlags = NS_HTTP_PROTOCOL_FLAGS;
 43113:     return NS_OK;
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpsHandler::NewURI(const nsACString &aSpec,
 43113:                        const char *aOriginCharset,
 43113:                        nsIURI *aBaseURI,
 43113:                        nsIURI **_retval)
 43113: {
 43113:     return ::NewURI(aSpec, aOriginCharset, aBaseURI, NS_HTTPS_DEFAULT_PORT, _retval);
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 43113: nsHttpsHandler::NewChannel(nsIURI *aURI, nsIChannel **_retval)
 43113: {
 43113:     NS_ABORT_IF_FALSE(gHttpHandler, "Should have a HTTP handler by now.");
 43113:     if (!gHttpHandler)
 43113:       return NS_ERROR_UNEXPECTED;
 43113:     return gHttpHandler->NewChannel(aURI, _retval);
 43113: }
 43113: 
 43113: NS_IMETHODIMP
 79445: nsHttpsHandler::AllowPort(PRInt32 aPort, const char *aScheme, bool *_retval)
 43113: {
 43113:     // don't override anything.  
 80486:     *_retval = false;
 43113:     return NS_OK;
 43113: }
