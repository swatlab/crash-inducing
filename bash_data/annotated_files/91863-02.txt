    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Alex Fritze <alex.fritze@crocodile-clips.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
88281: #include "nsSVGElement.h"
88281: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nsSVGSVGElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsRange.h"
    1: #include "nsIDOMAttr.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsMutationEvent.h"
 8335: #include "nsXBLPrototypeBinding.h"
    1: #include "nsBindingManager.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsDOMError.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIXBLService.h"
    1: #include "nsGkAtoms.h"
63693: #include "mozilla/css/StyleRule.h"
    1: #include "nsRuleWalker.h"
47937: #include "mozilla/css/Declaration.h"
    1: #include "nsCSSProps.h"
38849: #include "nsCSSParser.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsIScriptGlobalObject.h"
72328: #include "nsEventListenerManager.h"
    1: #include "nsSVGUtils.h"
    1: #include "nsSVGLength2.h"
    1: #include "nsSVGNumber2.h"
72919: #include "nsSVGNumberPair.h"
 6045: #include "nsSVGInteger.h"
72919: #include "nsSVGIntegerPair.h"
 6788: #include "nsSVGAngle.h"
 6325: #include "nsSVGBoolean.h"
 5347: #include "nsSVGEnum.h"
24554: #include "nsSVGViewBox.h"
15353: #include "nsSVGString.h"
58554: #include "SVGAnimatedNumberList.h"
47840: #include "SVGAnimatedLengthList.h"
58893: #include "SVGAnimatedPointList.h"
57113: #include "SVGAnimatedPathSegList.h"
78865: #include "SVGAnimatedTransformList.h"
86429: #include "DOMSVGTests.h"
 5347: #include "nsIDOMSVGUnitTypes.h"
 5729: #include "nsSVGRect.h"
23697: #include "nsIFrame.h"
 6944: #include "prdtoa.h"
    1: #include <stdarg.h>
39488: #include "nsSMILMappedAttribute.h"
41504: #include "SVGMotionSMILAttr.h"
90211: #include "nsAttrValueOrString.h"
    1: 
48193: using namespace mozilla;
48193: 
40718: // This is needed to ensure correct handling of calls to the
40718: // vararg-list methods in this file:
40718: //   nsSVGElement::GetAnimated{Length,Number,Integer}Values
40718: // See bug 547964 for details:
40718: PR_STATIC_ASSERT(sizeof(void*) == sizeof(nsnull));
40718: 
40718: 
 5347: nsSVGEnumMapping nsSVGElement::sSVGUnitTypesMap[] = {
 5347:   {&nsGkAtoms::userSpaceOnUse, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_USERSPACEONUSE},
 5347:   {&nsGkAtoms::objectBoundingBox, nsIDOMSVGUnitTypes::SVG_UNIT_TYPE_OBJECTBOUNDINGBOX},
 5347:   {nsnull, 0}
 5347: };
 5347: 
48124: nsSVGElement::nsSVGElement(already_AddRefed<nsINodeInfo> aNodeInfo)
79555:   : nsSVGElementBase(aNodeInfo)
    1: {
    1: }
    1: 
    1: nsresult
    1: nsSVGElement::Init()
    1: {
    1:   // Set up length attributes - can't do this in the constructor
    1:   // because we can't do a virtual call at that point
    1: 
    1:   LengthAttributesInfo lengthInfo = GetLengthInfo();
    1: 
    1:   PRUint32 i;
    1:   for (i = 0; i < lengthInfo.mLengthCount; i++) {
 8288:     lengthInfo.Reset(i);
    1:   }
    1: 
    1:   NumberAttributesInfo numberInfo = GetNumberInfo();
    1: 
    1:   for (i = 0; i < numberInfo.mNumberCount; i++) {
 8288:     numberInfo.Reset(i);
    1:   }
    1: 
72919:   NumberPairAttributesInfo numberPairInfo = GetNumberPairInfo();
72919: 
72919:   for (i = 0; i < numberPairInfo.mNumberPairCount; i++) {
72919:     numberPairInfo.Reset(i);
72919:   }
72919: 
 6045:   IntegerAttributesInfo integerInfo = GetIntegerInfo();
 6045: 
 6045:   for (i = 0; i < integerInfo.mIntegerCount; i++) {
 8288:     integerInfo.Reset(i);
 6045:   }
 6045: 
72919:   IntegerPairAttributesInfo integerPairInfo = GetIntegerPairInfo();
72919: 
72919:   for (i = 0; i < integerPairInfo.mIntegerPairCount; i++) {
72919:     integerPairInfo.Reset(i);
72919:   }
72919: 
 6788:   AngleAttributesInfo angleInfo = GetAngleInfo();
 6788: 
 6788:   for (i = 0; i < angleInfo.mAngleCount; i++) {
 8288:     angleInfo.Reset(i);
 6788:   }
 6788: 
 6325:   BooleanAttributesInfo booleanInfo = GetBooleanInfo();
 6325: 
 6325:   for (i = 0; i < booleanInfo.mBooleanCount; i++) {
 8288:     booleanInfo.Reset(i);
 6325:   }
 6325: 
 5347:   EnumAttributesInfo enumInfo = GetEnumInfo();
 5347: 
 5347:   for (i = 0; i < enumInfo.mEnumCount; i++) {
 8288:     enumInfo.Reset(i);
 5347:   }
 5347: 
24554:   nsSVGViewBox *viewBox = GetViewBox();
24554: 
24554:   if (viewBox) {
24554:     viewBox->Init();
24554:   }
24554: 
59470:   SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
23313:     GetPreserveAspectRatio();
23313: 
23313:   if (preserveAspectRatio) {
23313:     preserveAspectRatio->Init();
23313:   }
23313: 
47840:   LengthListAttributesInfo lengthListInfo = GetLengthListInfo();
47840: 
47840:   for (i = 0; i < lengthListInfo.mLengthListCount; i++) {
47840:     lengthListInfo.Reset(i);
47840:   }
47840: 
58554:   NumberListAttributesInfo numberListInfo = GetNumberListInfo();
58554: 
58554:   for (i = 0; i < numberListInfo.mNumberListCount; i++) {
58554:     numberListInfo.Reset(i);
58554:   }
58554: 
58893:   // No need to reset SVGPointList since the default value is always the same
58893:   // (an empty list).
58893: 
58893:   // No need to reset SVGPathData since the default value is always the same
57113:   // (an empty list).
57113: 
15353:   StringAttributesInfo stringInfo = GetStringInfo();
15353: 
15353:   for (i = 0; i < stringInfo.mStringCount; i++) {
15353:     stringInfo.Reset(i);
15353:   }
15353: 
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsISupports methods
    1: 
 4306: NS_IMPL_ADDREF_INHERITED(nsSVGElement, nsSVGElementBase)
 4306: NS_IMPL_RELEASE_INHERITED(nsSVGElement, nsSVGElementBase)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsSVGElement)
    1: // provided by nsGenericElement:
    1: //  NS_INTERFACE_MAP_ENTRY(nsIContent)
 4306: NS_INTERFACE_MAP_END_INHERITING(nsSVGElementBase)
    1: 
    1: //----------------------------------------------------------------------
    1: // Implementation
    1:   
    1: //----------------------------------------------------------------------
    1: // nsIContent methods
    1: 
    1: nsresult
 9755: nsSVGElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
 9755:                          nsIContent* aBindingParent,
79445:                          bool aCompileEventHandlers)
 9755: {
 9755:   nsresult rv = nsSVGElementBase::BindToTree(aDocument, aParent,
 9755:                                              aBindingParent,
 9755:                                              aCompileEventHandlers);
 9755:   NS_ENSURE_SUCCESS(rv, rv);
 9755: 
67608:   if (!MayHaveStyle()) {
 9755:     return NS_OK;
 9755:   }
 9755:   const nsAttrValue* oldVal = mAttrsAndChildren.GetAttr(nsGkAtoms::style);
 9755: 
 9755:   if (oldVal && oldVal->Type() == nsAttrValue::eCSSStyleRule) {
 9755:     // we need to force a reparse because the baseURI of the document
38452:     // may have changed, and in particular because we may be clones of
38452:     // XBL anonymous content now being bound to the document we should
38452:     // render in and due to the hacky way in which we implement the
38452:     // interaction of XBL and SVG resources.  Once we have a sane
38452:     // ownerDocument on XBL anonymous content, this can all go away.
 9755:     nsAttrValue attrValue;
 9755:     nsAutoString stringValue;
 9755:     oldVal->ToString(stringValue);
11871:     // Force in data doc, since we already have a style rule
80486:     ParseStyleAttribute(stringValue, attrValue, true);
 9755:     // Don't bother going through SetInlineStyleRule, we don't want to fire off
 9755:     // mutation events or document notifications anyway
 9755:     rv = mAttrsAndChildren.SetAndTakeAttr(nsGkAtoms::style, attrValue);
 9755:     NS_ENSURE_SUCCESS(rv, rv);
 9755:   }
 9755: 
 9755:   return NS_OK;
 9755: }
 9755: 
 9755: nsresult
32412: nsSVGElement::AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
90061:                            const nsAttrValue* aValue, bool aNotify)
    1: {
90211:   // We don't currently use nsMappedAttributes within SVG. If this changes, we
90211:   // need to be very careful because some nsAttrValues used by SVG point to
90211:   // member data of SVG elements and if an nsAttrValue outlives the SVG element
90211:   // whose data it points to (by virtue of being stored in
90211:   // mAttrsAndChildren->mMappedAttributes, meaning it's shared between
90211:   // elements), the pointer will dangle. See bug 724680.
90211:   NS_ABORT_IF_FALSE(!mAttrsAndChildren.HasMappedAttrs(),
90211:     "Unexpected use of nsMappedAttributes within SVG");
90211: 
    1:   // If this is an svg presentation attribute we need to map it into
    1:   // the content stylerule.
    1:   // XXX For some reason incremental mapping doesn't work, so for now
    1:   // just delete the style rule and lazily reconstruct it in
    1:   // GetContentStyleRule()
    1:   if (aNamespaceID == kNameSpaceID_None && IsAttributeMapped(aName)) {
    1:     mContentStyleRule = nsnull;
    1:   }
    1: 
    1:   if (IsEventName(aName) && aValue) {
90061:     NS_ABORT_IF_FALSE(aValue->Type() == nsAttrValue::eString,
90061:       "Expected string value for script body");
90061:     nsresult rv = AddScriptEventListener(GetEventNameForAttr(aName),
90061:                                          aValue->GetStringValue());
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
 4306:   return nsSVGElementBase::AfterSetAttr(aNamespaceID, aName, aValue, aNotify);
    1: }
    1: 
79445: bool
    1: nsSVGElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                              nsIAtom* aAttribute,
    1:                              const nsAString& aValue,
    1:                              nsAttrValue& aResult)
    1: {
23133:   nsresult rv = NS_OK;
79445:   bool foundMatch = false;
90210:   bool didSetResult = false;
90210: 
    1:   if (aNamespaceID == kNameSpaceID_None) {
 5347: 
    1:     // Check for nsSVGLength2 attribute
    1:     LengthAttributesInfo lengthInfo = GetLengthInfo();
 6788: 
 6788:     PRUint32 i;
15353:     for (i = 0; i < lengthInfo.mLengthCount; i++) {
    1:       if (aAttribute == *lengthInfo.mLengthInfo[i].mName) {
80486:         rv = lengthInfo.mLengths[i].SetBaseValueString(aValue, this, false);
 8288:         if (NS_FAILED(rv)) {
 8288:           lengthInfo.Reset(i);
90211:         } else {
90211:           aResult.SetTo(lengthInfo.mLengths[i], &aValue);
90211:           didSetResult = true;
 8288:         }
80486:         foundMatch = true;
15353:         break;
 5347:       }
 5347:     }
 5347: 
15353:     if (!foundMatch) {
47840:       // Check for SVGAnimatedLengthList attribute
47840:       LengthListAttributesInfo lengthListInfo = GetLengthListInfo();
47840:       for (i = 0; i < lengthListInfo.mLengthListCount; i++) {
47840:         if (aAttribute == *lengthListInfo.mLengthListInfo[i].mName) {
47840:           rv = lengthListInfo.mLengthLists[i].SetBaseValueString(aValue);
47840:           if (NS_FAILED(rv)) {
47840:             lengthListInfo.Reset(i);
90212:           } else {
90212:             aResult.SetTo(lengthListInfo.mLengthLists[i].GetBaseValue(),
90212:                           &aValue);
90212:             didSetResult = true;
47840:           }
80486:           foundMatch = true;
47840:           break;
47840:         }
47840:       }
47840:     }
47840: 
47840:     if (!foundMatch) {
58554:       // Check for SVGAnimatedNumberList attribute
58554:       NumberListAttributesInfo numberListInfo = GetNumberListInfo();
58554:       for (i = 0; i < numberListInfo.mNumberListCount; i++) {
58554:         if (aAttribute == *numberListInfo.mNumberListInfo[i].mName) {
58554:           rv = numberListInfo.mNumberLists[i].SetBaseValueString(aValue);
58554:           if (NS_FAILED(rv)) {
58554:             numberListInfo.Reset(i);
90222:           } else {
90222:             aResult.SetTo(numberListInfo.mNumberLists[i].GetBaseValue(),
90222:                           &aValue);
90222:             didSetResult = true;
58554:           }
80486:           foundMatch = true;
58554:           break;
58554:         }
58554:       }
58554:     }
58554: 
58554:     if (!foundMatch) {
58893:       // Check for SVGAnimatedPointList attribute
58893:       if (GetPointListAttrName() == aAttribute) {
58893:         SVGAnimatedPointList* pointList = GetAnimatedPointList();
58893:         if (pointList) {
90223:           pointList->SetBaseValueString(aValue);
90223:           // The spec says we parse everything up to the failure, so we DON'T
90223:           // need to check the result of SetBaseValueString or call
90223:           // pointList->ClearBaseValue() if it fails
90223:           aResult.SetTo(pointList->GetBaseValue(), &aValue);
90223:           didSetResult = true;
80486:           foundMatch = true;
58893:         }
58893:       }
58893:     }
58893: 
58893:     if (!foundMatch) {
57113:       // Check for SVGAnimatedPathSegList attribute
57113:       if (GetPathDataAttrName() == aAttribute) {
57113:         SVGAnimatedPathSegList* segList = GetAnimPathSegList();
57113:         if (segList) {
90224:           segList->SetBaseValueString(aValue);
90224:           // The spec says we parse everything up to the failure, so we DON'T
90224:           // need to check the result of SetBaseValueString or call
90224:           // segList->ClearBaseValue() if it fails
90224:           aResult.SetTo(segList->GetBaseValue(), &aValue);
90224:           didSetResult = true;
80486:           foundMatch = true;
57113:         }
57113:       }
57113:     }
57113: 
57113:     if (!foundMatch) {
 5347:       // Check for nsSVGNumber2 attribute
 5347:       NumberAttributesInfo numberInfo = GetNumberInfo();
15353:       for (i = 0; i < numberInfo.mNumberCount; i++) {
 5347:         if (aAttribute == *numberInfo.mNumberInfo[i].mName) {
80122:           rv = numberInfo.mNumbers[i].SetBaseValueString(aValue, this);
 8288:           if (NS_FAILED(rv)) {
 8288:             numberInfo.Reset(i);
90213:           } else {
90213:             aResult.SetTo(numberInfo.mNumbers[i].GetBaseValue(), &aValue);
90213:             didSetResult = true;
 8288:           }
80486:           foundMatch = true;
15353:           break;
15353:         }
 5347:       }
 5347:     }
 5347: 
15353:     if (!foundMatch) {
72919:       // Check for nsSVGNumberPair attribute
72919:       NumberPairAttributesInfo numberPairInfo = GetNumberPairInfo();
72919:       for (i = 0; i < numberPairInfo.mNumberPairCount; i++) {
72919:         if (aAttribute == *numberPairInfo.mNumberPairInfo[i].mName) {
80122:           rv = numberPairInfo.mNumberPairs[i].SetBaseValueString(aValue, this);
72919:           if (NS_FAILED(rv)) {
72919:             numberPairInfo.Reset(i);
90214:           } else {
90214:             aResult.SetTo(numberPairInfo.mNumberPairs[i], &aValue);
90214:             didSetResult = true;
72919:           }
80486:           foundMatch = true;
72919:           break;
72919:         }
72919:       }
72919:     }
72919: 
72919:     if (!foundMatch) {
 6045:       // Check for nsSVGInteger attribute
 6045:       IntegerAttributesInfo integerInfo = GetIntegerInfo();
15353:       for (i = 0; i < integerInfo.mIntegerCount; i++) {
 6045:         if (aAttribute == *integerInfo.mIntegerInfo[i].mName) {
80122:           rv = integerInfo.mIntegers[i].SetBaseValueString(aValue, this);
 8288:           if (NS_FAILED(rv)) {
 8288:             integerInfo.Reset(i);
90215:           } else {
90215:             aResult.SetTo(integerInfo.mIntegers[i].GetBaseValue(), &aValue);
90215:             didSetResult = true;
 8288:           }
80486:           foundMatch = true;
15353:           break;
15353:         }
 6045:       }
 6045:     }
 6045: 
15353:     if (!foundMatch) {
72919:       // Check for nsSVGIntegerPair attribute
72919:       IntegerPairAttributesInfo integerPairInfo = GetIntegerPairInfo();
72919:       for (i = 0; i < integerPairInfo.mIntegerPairCount; i++) {
72919:         if (aAttribute == *integerPairInfo.mIntegerPairInfo[i].mName) {
90216:           rv =
90216:             integerPairInfo.mIntegerPairs[i].SetBaseValueString(aValue, this);
72919:           if (NS_FAILED(rv)) {
72919:             integerPairInfo.Reset(i);
90216:           } else {
90216:             aResult.SetTo(integerPairInfo.mIntegerPairs[i], &aValue);
90216:             didSetResult = true;
72919:           }
80486:           foundMatch = true;
72919:           break;
72919:         }
72919:       }
72919:     }
72919: 
72919:     if (!foundMatch) {
 6788:       // Check for nsSVGAngle attribute
 6788:       AngleAttributesInfo angleInfo = GetAngleInfo();
15353:       for (i = 0; i < angleInfo.mAngleCount; i++) {
 6788:         if (aAttribute == *angleInfo.mAngleInfo[i].mName) {
80486:           rv = angleInfo.mAngles[i].SetBaseValueString(aValue, this, false);
 8288:           if (NS_FAILED(rv)) {
 8288:             angleInfo.Reset(i);
90217:           } else {
90217:             aResult.SetTo(angleInfo.mAngles[i], &aValue);
90217:             didSetResult = true;
 8288:           }
80486:           foundMatch = true;
15353:           break;
15353:         }
 6788:       }
 6788:     }
 6788: 
15353:     if (!foundMatch) {
 6325:       // Check for nsSVGBoolean attribute
 6325:       BooleanAttributesInfo booleanInfo = GetBooleanInfo();
15353:       for (i = 0; i < booleanInfo.mBooleanCount; i++) {
 6325:         if (aAttribute == *booleanInfo.mBooleanInfo[i].mName) {
90218:           nsCOMPtr<nsIAtom> valAtom = do_GetAtom(aValue);
90218:           rv = booleanInfo.mBooleans[i].SetBaseValueAtom(valAtom, this);
 8288:           if (NS_FAILED(rv)) {
 8288:             booleanInfo.Reset(i);
90218:           } else {
90218:             aResult.SetTo(valAtom);
90218:             didSetResult = true;
 8288:           }
80486:           foundMatch = true;
15353:           break;
15353:         }
 6325:       }
 6325:     }
 6325: 
15353:     if (!foundMatch) {
 5347:       // Check for nsSVGEnum attribute
 5347:       EnumAttributesInfo enumInfo = GetEnumInfo();
15353:       for (i = 0; i < enumInfo.mEnumCount; i++) {
 5347:         if (aAttribute == *enumInfo.mEnumInfo[i].mName) {
90210:           nsCOMPtr<nsIAtom> valAtom = do_GetAtom(aValue);
90210:           rv = enumInfo.mEnums[i].SetBaseValueAtom(valAtom, this);
 8288:           if (NS_FAILED(rv)) {
 8288:             enumInfo.Reset(i);
90210:           } else {
90210:             aResult.SetTo(valAtom);
90210:             didSetResult = true;
 8288:           }
80486:           foundMatch = true;
15353:           break;
15353:         }
 5347:       }
 5347:     }
23313: 
24554:     if (!foundMatch) {
86429:       // Check for conditional processing attributes
86429:       nsCOMPtr<DOMSVGTests> tests(do_QueryInterface(this));
86429:       if (tests && tests->ParseConditionalProcessingAttribute(
86429:                             aAttribute, aValue, aResult)) {
86429:         foundMatch = true;
86429:       }
86429:     }
86429: 
86429:     if (!foundMatch) {
86429:       // Check for StringList attribute
86429:       StringListAttributesInfo stringListInfo = GetStringListInfo();
86429:       for (i = 0; i < stringListInfo.mStringListCount; i++) {
86429:         if (aAttribute == *stringListInfo.mStringListInfo[i].mName) {
90227:           rv = stringListInfo.mStringLists[i].SetValue(aValue);
86429:           if (NS_FAILED(rv)) {
86429:             stringListInfo.Reset(i);
90227:           } else {
90227:             aResult.SetTo(stringListInfo.mStringLists[i], &aValue);
90227:             didSetResult = true;
86429:           }
86429:           foundMatch = true;
86429:           break;
86429:         }
86429:       }
86429:     }
86429: 
86429:     if (!foundMatch) {
24554:       // Check for nsSVGViewBox attribute
24554:       if (aAttribute == nsGkAtoms::viewBox) {
24554:         nsSVGViewBox* viewBox = GetViewBox();
24554:         if (viewBox) {
80122:           rv = viewBox->SetBaseValueString(aValue, this);
24554:           if (NS_FAILED(rv)) {
24554:             viewBox->Init();
90221:           } else {
90221:             aResult.SetTo(*viewBox, &aValue);
90221:             didSetResult = true;
24554:           }
80486:           foundMatch = true;
24554:         }
59470:       // Check for SVGAnimatedPreserveAspectRatio attribute
24554:       } else if (aAttribute == nsGkAtoms::preserveAspectRatio) {
59470:         SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
23313:           GetPreserveAspectRatio();
23313:         if (preserveAspectRatio) {
80122:           rv = preserveAspectRatio->SetBaseValueString(aValue, this);
23313:           if (NS_FAILED(rv)) {
23313:             preserveAspectRatio->Init();
90220:           } else {
90220:             aResult.SetTo(*preserveAspectRatio, &aValue);
90220:             didSetResult = true;
23313:           }
80486:           foundMatch = true;
23313:         }
78865:       // Check for SVGAnimatedTransformList attribute
78865:       } else if (GetTransformListAttrName() == aAttribute) {
78865:         SVGAnimatedTransformList *transformList = GetAnimatedTransformList();
78865:         if (transformList) {
78865:           rv = transformList->SetBaseValueString(aValue);
78865:           if (NS_FAILED(rv)) {
78865:             transformList->ClearBaseValue();
90225:           } else {
90225:             aResult.SetTo(transformList->GetBaseValue(), &aValue);
90225:             didSetResult = true;
78865:           }
80486:           foundMatch = true;
78865:         }
23313:       }
    1:     }
24554:   }
    1: 
15353:   if (!foundMatch) {
15353:     // Check for nsSVGString attribute
15353:     StringAttributesInfo stringInfo = GetStringInfo();
15353:     for (PRUint32 i = 0; i < stringInfo.mStringCount; i++) {
15353:       if (aNamespaceID == stringInfo.mStringInfo[i].mNamespaceID &&
15353:           aAttribute == *stringInfo.mStringInfo[i].mName) {
80486:         stringInfo.mStrings[i].SetBaseValue(aValue, this, false);
80486:         foundMatch = true;
15353:         break;
15353:       }
15353:     }
15353:   }
15353: 
23133:   if (foundMatch) {
23133:     if (NS_FAILED(rv)) {
80526:       ReportAttributeParseFailure(OwnerDoc(), aAttribute, aValue);
80486:       return false;
23133:     }
90210:     if (!didSetResult) {
23133:       aResult.SetTo(aValue);
90210:     }
80486:     return true;
23133:   }
23133: 
 4306:   return nsSVGElementBase::ParseAttribute(aNamespaceID, aAttribute, aValue,
    1:                                           aResult);
    1: }
    1: 
80038: void
80038: nsSVGElement::UnsetAttrInternal(PRInt32 aNamespaceID, nsIAtom* aName,
79445:                                 bool aNotify)
    1: {
38454:   // XXXbz there's a bunch of redundancy here with AfterSetAttr.
38454:   // Maybe consolidate?
38454: 
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     // If this is an svg presentation attribute, remove rule to force an update
    1:     if (IsAttributeMapped(aName))
    1:       mContentStyleRule = nsnull;
    1: 
    1:     if (IsEventName(aName)) {
80486:       nsEventListenerManager* manager = GetListenerManager(false);
    1:       if (manager) {
    1:         nsIAtom* eventName = GetEventNameForAttr(aName);
    1:         manager->RemoveScriptEventListener(eventName);
    1:       }
80038:       return;
15353:     }
15353:     
    1:     // Check if this is a length attribute going away
    1:     LengthAttributesInfo lenInfo = GetLengthInfo();
    1: 
15353:     for (PRUint32 i = 0; i < lenInfo.mLengthCount; i++) {
    1:       if (aName == *lenInfo.mLengthInfo[i].mName) {
90211:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
 8288:         lenInfo.Reset(i);
80038:         return;
    1:       }
15353:     }
15353: 
47840:     // Check if this is a length list attribute going away
47840:     LengthListAttributesInfo lengthListInfo = GetLengthListInfo();
47840: 
47840:     for (PRUint32 i = 0; i < lengthListInfo.mLengthListCount; i++) {
47840:       if (aName == *lengthListInfo.mLengthListInfo[i].mName) {
90212:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
47840:         lengthListInfo.Reset(i);
80038:         return;
47840:       }
47840:     }
47840: 
58554:     // Check if this is a number list attribute going away
58554:     NumberListAttributesInfo numberListInfo = GetNumberListInfo();
58554: 
58554:     for (PRUint32 i = 0; i < numberListInfo.mNumberListCount; i++) {
58554:       if (aName == *numberListInfo.mNumberListInfo[i].mName) {
90222:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
58554:         numberListInfo.Reset(i);
80038:         return;
58554:       }
58554:     }
58554: 
58893:     // Check if this is a point list attribute going away
58893:     if (GetPointListAttrName() == aName) {
58893:       SVGAnimatedPointList *pointList = GetAnimatedPointList();
58893:       if (pointList) {
90223:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
58893:         pointList->ClearBaseValue();
80038:         return;
58893:       }
58893:     }
58893: 
57113:     // Check if this is a path segment list attribute going away
57113:     if (GetPathDataAttrName() == aName) {
57113:       SVGAnimatedPathSegList *segList = GetAnimPathSegList();
57113:       if (segList) {
90224:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
57113:         segList->ClearBaseValue();
80038:         return;
57113:       }
57113:     }
57113: 
    1:     // Check if this is a number attribute going away
    1:     NumberAttributesInfo numInfo = GetNumberInfo();
    1: 
15353:     for (PRUint32 i = 0; i < numInfo.mNumberCount; i++) {
    1:       if (aName == *numInfo.mNumberInfo[i].mName) {
 8288:         numInfo.Reset(i);
80038:         return;
    1:       }
    1:     }
 5347: 
72919:     // Check if this is a number pair attribute going away
72919:     NumberPairAttributesInfo numPairInfo = GetNumberPairInfo();
72919: 
72919:     for (PRUint32 i = 0; i < numPairInfo.mNumberPairCount; i++) {
72919:       if (aName == *numPairInfo.mNumberPairInfo[i].mName) {
90214:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
72919:         numPairInfo.Reset(i);
80038:         return;
72919:       }
72919:     }
72919: 
 6045:     // Check if this is an integer attribute going away
 6045:     IntegerAttributesInfo intInfo = GetIntegerInfo();
 6045: 
15353:     for (PRUint32 i = 0; i < intInfo.mIntegerCount; i++) {
 6045:       if (aName == *intInfo.mIntegerInfo[i].mName) {
 8288:         intInfo.Reset(i);
80038:         return;
 6045:       }
 6045:     }
 6045: 
72919:     // Check if this is an integer pair attribute going away
72919:     IntegerPairAttributesInfo intPairInfo = GetIntegerPairInfo();
72919: 
72919:     for (PRUint32 i = 0; i < intPairInfo.mIntegerPairCount; i++) {
72919:       if (aName == *intPairInfo.mIntegerPairInfo[i].mName) {
90216:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
72919:         intPairInfo.Reset(i);
80038:         return;
72919:       }
72919:     }
72919: 
 6788:     // Check if this is an angle attribute going away
 6788:     AngleAttributesInfo angleInfo = GetAngleInfo();
 6788: 
15353:     for (PRUint32 i = 0; i < angleInfo.mAngleCount; i++) {
 6788:       if (aName == *angleInfo.mAngleInfo[i].mName) {
90217:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
 8288:         angleInfo.Reset(i);
80038:         return;
 6788:       }
 6788:     }
 6788: 
 6325:     // Check if this is a boolean attribute going away
 6325:     BooleanAttributesInfo boolInfo = GetBooleanInfo();
 6325: 
15353:     for (PRUint32 i = 0; i < boolInfo.mBooleanCount; i++) {
 6325:       if (aName == *boolInfo.mBooleanInfo[i].mName) {
 8288:         boolInfo.Reset(i);
80038:         return;
 6325:       }
 6325:     }
 6325: 
 6045:     // Check if this is an enum attribute going away
 5347:     EnumAttributesInfo enumInfo = GetEnumInfo();
 5347: 
15353:     for (PRUint32 i = 0; i < enumInfo.mEnumCount; i++) {
 5347:       if (aName == *enumInfo.mEnumInfo[i].mName) {
 8288:         enumInfo.Reset(i);
80038:         return;
15353:       }
 5347:     }
23313: 
24554:     // Check if this is a nsViewBox attribute going away
24554:     if (aName == nsGkAtoms::viewBox) {
24554:       nsSVGViewBox* viewBox = GetViewBox();
24554:       if (viewBox) {
90221:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
24554:         viewBox->Init();
80038:         return;
64109:       }
24554:     }
80038: 
23313:     // Check if this is a preserveAspectRatio attribute going away
64109:     if (aName == nsGkAtoms::preserveAspectRatio) {
59470:       SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
23313:         GetPreserveAspectRatio();
23313:       if (preserveAspectRatio) {
90220:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
23313:         preserveAspectRatio->Init();
80038:         return;
23313:       }
23313:     }
78865: 
78865:     // Check if this is a transform list attribute going away
78865:     if (GetTransformListAttrName() == aName) {
78865:       SVGAnimatedTransformList *transformList = GetAnimatedTransformList();
78865:       if (transformList) {
90225:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
78865:         transformList->ClearBaseValue();
80038:         return;
78865:       }
78865:     }
86429: 
86429:     // Check for conditional processing attributes
86429:     nsCOMPtr<DOMSVGTests> tests(do_QueryInterface(this));
86429:     if (tests && tests->IsConditionalProcessingAttribute(aName)) {
90227:       MaybeSerializeAttrBeforeRemoval(aName, aNotify);
86429:       tests->UnsetAttr(aName);
86429:       return;
86429:     }
86429: 
86429:     // Check if this is a string list attribute going away
86429:     StringListAttributesInfo stringListInfo = GetStringListInfo();
86429: 
86429:     for (PRUint32 i = 0; i < stringListInfo.mStringListCount; i++) {
86429:       if (aName == *stringListInfo.mStringListInfo[i].mName) {
90227:         MaybeSerializeAttrBeforeRemoval(aName, aNotify);
86429:         stringListInfo.Reset(i);
86429:         return;
86429:       }
86429:     }
24554:   }
 5729: 
15353:   // Check if this is a string attribute going away
15353:   StringAttributesInfo stringInfo = GetStringInfo();
15353: 
15353:   for (PRUint32 i = 0; i < stringInfo.mStringCount; i++) {
15353:     if (aNamespaceID == stringInfo.mStringInfo[i].mNamespaceID &&
15353:         aName == *stringInfo.mStringInfo[i].mName) {
15353:       stringInfo.Reset(i);
80038:       return;
80038:     }
15353:   }
15353: }
15353: 
80038: nsresult
80038: nsSVGElement::UnsetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
80038:                         bool aNotify)
80038: {
80038:   UnsetAttrInternal(aNamespaceID, aName, aNotify);
80038:   return nsSVGElementBase::UnsetAttr(aNamespaceID, aName, aNotify);
 8288: }
 8288: 
16389: nsChangeHint
16389: nsSVGElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
16389:                                      PRInt32 aModType) const
16389: {
16389:   nsChangeHint retval =
16389:     nsSVGElementBase::GetAttributeChangeHint(aAttribute, aModType);
16389: 
86429:   nsCOMPtr<DOMSVGTests> tests(do_QueryInterface(const_cast<nsSVGElement*>(this)));
86429:   if (tests && tests->IsConditionalProcessingAttribute(aAttribute)) {
16389:     // It would be nice to only reconstruct the frame if the value returned by
86429:     // DOMSVGTests::PassesConditionalProcessingTests has changed, but we don't
86429:     // know that
16389:     NS_UpdateHint(retval, nsChangeHint_ReconstructFrame);
16389:   }
16389:   return retval;
16389: }
16389: 
79445: bool
    1: nsSVGElement::IsNodeOfType(PRUint32 aFlags) const
    1: {
84223:   return !(aFlags & ~eCONTENT);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsSVGElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
    1: {
    1: #ifdef DEBUG
    1: //  printf("nsSVGElement(%p)::WalkContentStyleRules()\n", this);
    1: #endif
    1:   if (!mContentStyleRule)
    1:     UpdateContentStyleRule();
    1: 
35577:   if (mContentStyleRule) {
35577:     mContentStyleRule->RuleMatched();
    1:     aRuleWalker->Forward(mContentStyleRule);
35577:   }
    1: 
39488:   // Update & walk the animated content style rule, to include style from
39488:   // animated mapped attributes.  But first, get nsPresContext to check
39488:   // whether this is a "no-animation restyle". (This should match the check
39488:   // in nsHTMLCSSStyleSheet::RulesMatching(), where we determine whether to
39488:   // apply the SMILOverrideStyle.)
80526:   nsIDocument* doc = OwnerDoc();
46225:   nsIPresShell* shell = doc->GetShell();
39488:   nsPresContext* context = shell ? shell->GetPresContext() : nsnull;
39488:   if (context && context->IsProcessingRestyles() &&
39488:       !context->IsProcessingAnimationStyleChange()) {
39488:     // Any style changes right now could trigger CSS Transitions. We don't
39488:     // want that to happen from SMIL-animated value of mapped attrs, so
39488:     // ignore animated value for now, and request an animation restyle to
39488:     // get our animated value noticed.
46468:     shell->RestyleForAnimation(this, eRestyle_Self);
39488:   } else {
39488:     // Ok, this is an animation restyle -- go ahead and update/walk the
39488:     // animated content style rule.
63693:     css::StyleRule* animContentStyleRule = GetAnimatedContentStyleRule();
39488:     if (!animContentStyleRule) {
39488:       UpdateAnimatedContentStyleRule();
39488:       animContentStyleRule = GetAnimatedContentStyleRule();
39488:     }
39488:     if (animContentStyleRule) {
39488:       animContentStyleRule->RuleMatched();
39488:       aRuleWalker->Forward(animContentStyleRule);
39488:     }
39488:   }
39488: 
    1:   return NS_OK;
    1: }
    1: 
90456: NS_IMETHODIMP_(bool)
90456: nsSVGElement::IsAttributeMapped(const nsIAtom* name) const
90456: {
90456:   if (name == nsGkAtoms::lang) {
90456:     return true;
90456:   }
90456:   return nsSVGElementBase::IsAttributeMapped(name);
90456: }
90456: 
    1: // PresentationAttributes-FillStroke
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFillStrokeMap[] = {
    1:   { &nsGkAtoms::fill },
    1:   { &nsGkAtoms::fill_opacity },
    1:   { &nsGkAtoms::fill_rule },
    1:   { &nsGkAtoms::stroke },
    1:   { &nsGkAtoms::stroke_dasharray },
    1:   { &nsGkAtoms::stroke_dashoffset },
    1:   { &nsGkAtoms::stroke_linecap },
    1:   { &nsGkAtoms::stroke_linejoin },
    1:   { &nsGkAtoms::stroke_miterlimit },
    1:   { &nsGkAtoms::stroke_opacity },
    1:   { &nsGkAtoms::stroke_width },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Graphics
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sGraphicsMap[] = {
    1:   { &nsGkAtoms::clip_path },
    1:   { &nsGkAtoms::clip_rule },
    1:   { &nsGkAtoms::colorInterpolation },
    1:   { &nsGkAtoms::cursor },
    1:   { &nsGkAtoms::display },
    1:   { &nsGkAtoms::filter },
    1:   { &nsGkAtoms::image_rendering },
    1:   { &nsGkAtoms::mask },
    1:   { &nsGkAtoms::opacity },
    1:   { &nsGkAtoms::pointer_events },
    1:   { &nsGkAtoms::shape_rendering },
    1:   { &nsGkAtoms::text_rendering },
    1:   { &nsGkAtoms::visibility },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-TextContentElements
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sTextContentElementsMap[] = {
    1:   { &nsGkAtoms::alignment_baseline },
    1:   { &nsGkAtoms::baseline_shift },
    1:   { &nsGkAtoms::direction },
    1:   { &nsGkAtoms::dominant_baseline },
    1:   { &nsGkAtoms::glyph_orientation_horizontal },
    1:   { &nsGkAtoms::glyph_orientation_vertical },
    1:   { &nsGkAtoms::kerning },
    1:   { &nsGkAtoms::letter_spacing },
    1:   { &nsGkAtoms::text_anchor },
    1:   { &nsGkAtoms::text_decoration },
    1:   { &nsGkAtoms::unicode_bidi },
    1:   { &nsGkAtoms::word_spacing },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-FontSpecification
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFontSpecificationMap[] = {
    1:   { &nsGkAtoms::font_family },
    1:   { &nsGkAtoms::font_size },
    1:   { &nsGkAtoms::font_size_adjust },
    1:   { &nsGkAtoms::font_stretch },
    1:   { &nsGkAtoms::font_style },
    1:   { &nsGkAtoms::font_variant },
    1:   { &nsGkAtoms::fontWeight },  
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-GradientStop
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sGradientStopMap[] = {
    1:   { &nsGkAtoms::stop_color },
    1:   { &nsGkAtoms::stop_opacity },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Viewports
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sViewportsMap[] = {
    1:   { &nsGkAtoms::overflow },
    1:   { &nsGkAtoms::clip },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Makers
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sMarkersMap[] = {
    1:   { &nsGkAtoms::marker_end },
    1:   { &nsGkAtoms::marker_mid },
    1:   { &nsGkAtoms::marker_start },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Color
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sColorMap[] = {
    1:   { &nsGkAtoms::color },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-Filters
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFiltersMap[] = {
    1:   { &nsGkAtoms::colorInterpolationFilters },
    1:   { nsnull }
    1: };
    1: 
    1: // PresentationAttributes-feFlood
    1: /* static */ const nsGenericElement::MappedAttributeEntry
    1: nsSVGElement::sFEFloodMap[] = {
    1:   { &nsGkAtoms::flood_color },
    1:   { &nsGkAtoms::flood_opacity },
    1:   { nsnull }
    1: };
    1: 
 4029: // PresentationAttributes-LightingEffects
 4029: /* static */ const nsGenericElement::MappedAttributeEntry
 4029: nsSVGElement::sLightingEffectsMap[] = {
 4029:   { &nsGkAtoms::lighting_color },
 4029:   { nsnull }
 4029: };
 4029: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMNode methods
    1: 
    1: NS_IMETHODIMP
79445: nsSVGElement::IsSupported(const nsAString& aFeature, const nsAString& aVersion, bool* aReturn)
    1: {
33633:   return nsGenericElement::IsSupported(aFeature, aVersion, aReturn); 
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMElement methods
    1: 
    1: // forwarded to nsGenericElement implementations
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMSVGElement methods
    1: 
    1: /* attribute DOMString id; */
    1: NS_IMETHODIMP nsSVGElement::GetId(nsAString & aId)
    1: {
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::id, aId);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsSVGElement::SetId(const nsAString & aId)
    1: {
80486:   return SetAttr(kNameSpaceID_None, nsGkAtoms::id, aId, true);
    1: }
    1: 
    1: /* readonly attribute nsIDOMSVGSVGElement ownerSVGElement; */
    1: NS_IMETHODIMP
    1: nsSVGElement::GetOwnerSVGElement(nsIDOMSVGSVGElement * *aOwnerSVGElement)
    1: {
64140:   NS_IF_ADDREF(*aOwnerSVGElement = GetCtx());
    1: 
64140:   if (*aOwnerSVGElement || Tag() == nsGkAtoms::svg) {
64140:     // If we found something or we're the outermost SVG element, that's OK.
10072:     return NS_OK;
10072:   }
64140:   // Otherwise, we've got an invalid structure
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* readonly attribute nsIDOMSVGElement viewportElement; */
    1: NS_IMETHODIMP
    1: nsSVGElement::GetViewportElement(nsIDOMSVGElement * *aViewportElement)
    1: {
30596:   *aViewportElement = nsSVGUtils::GetNearestViewportElement(this).get();
30596:   return NS_OK;
    1: }
    1: 
39487: //------------------------------------------------------------------------
39487: // Helper class: MappedAttrParser, for parsing values of mapped attributes
47936: 
47936: namespace {
47936: 
39487: class MappedAttrParser {
39487: public:
47936:   MappedAttrParser(css::Loader* aLoader,
39487:                    nsIURI* aDocURI,
39487:                    already_AddRefed<nsIURI> aBaseURI,
39487:                    nsIPrincipal* aNodePrincipal);
39487:   ~MappedAttrParser();
39487: 
39487:   // Parses a mapped attribute value.
39487:   void ParseMappedAttrValue(nsIAtom* aMappedAttrName,
39487:                             nsAString& aMappedAttrValue);
39487: 
39487:   // If we've parsed any values for mapped attributes, this method returns
63693:   // a new already_AddRefed css::StyleRule that incorporates the parsed
39487:   // values. Otherwise, this method returns null.
63693:   already_AddRefed<css::StyleRule> CreateStyleRule();
39487: 
39487: private:
39487:   // MEMBER DATA
39487:   // -----------
39487:   nsCSSParser       mParser;
39487: 
39487:   // Arguments for nsCSSParser::ParseProperty
39487:   nsIURI*           mDocURI;
39487:   nsCOMPtr<nsIURI>  mBaseURI;
39487:   nsIPrincipal*     mNodePrincipal;
39487: 
39487:   // Declaration for storing parsed values (lazily initialized)
47936:   css::Declaration* mDecl;
39487: };
39487: 
47936: MappedAttrParser::MappedAttrParser(css::Loader* aLoader,
39487:                                    nsIURI* aDocURI,
39487:                                    already_AddRefed<nsIURI> aBaseURI,
39487:                                    nsIPrincipal* aNodePrincipal)
39487:   : mParser(aLoader), mDocURI(aDocURI), mBaseURI(aBaseURI),
39487:     mNodePrincipal(aNodePrincipal), mDecl(nsnull)
39487: {
39487:   // SVG and CSS differ slightly in their interpretation of some of
39487:   // the attributes.  SVG allows attributes of the form: font-size="5"
39487:   // (style="font-size: 5" if using a style attribute)
39487:   // where CSS requires units: font-size="5pt" (style="font-size: 5pt")
39487:   // Set a flag to pass information to the parser so that we can use
39487:   // the CSS parser to parse the font-size attribute.  Note that this
39487:   // does *not* affect the use of CSS stylesheets, which will still
39487:   // require units.
80486:   mParser.SetSVGMode(true);
39487: }
39487: 
39487: MappedAttrParser::~MappedAttrParser()
39487: {
39487:   NS_ABORT_IF_FALSE(!mDecl,
39487:                     "If mDecl was initialized, it should have been converted "
39487:                     "into a style rule (and had its pointer cleared)");
39487: }
39487: 
39487: void
39487: MappedAttrParser::ParseMappedAttrValue(nsIAtom* aMappedAttrName,
39487:                                        nsAString& aMappedAttrValue)
39487: {
39487:   if (!mDecl) {
47936:     mDecl = new css::Declaration();
39487:     mDecl->InitializeEmpty();
39487:   }
39487: 
39487:   // Get the nsCSSProperty ID for our mapped attribute.
39487:   nsCSSProperty propertyID =
52031:     nsCSSProps::LookupProperty(nsDependentAtomString(aMappedAttrName));
90456:   if (propertyID != eCSSProperty_UNKNOWN) {
79445:     bool changed; // outparam for ParseProperty. (ignored)
39487:     mParser.ParseProperty(propertyID, aMappedAttrValue, mDocURI, mBaseURI,
80486:                           mNodePrincipal, mDecl, &changed, false);
90456:     return;
90456:   }
90456:   NS_ABORT_IF_FALSE(aMappedAttrName == nsGkAtoms::lang,
90456:                     "Only 'lang' should be unrecognized!");
90456:   // nsCSSParser doesn't know about 'lang', so we need to handle it specially.
90456:   if (aMappedAttrName == nsGkAtoms::lang) {
90456:     propertyID = eCSSProperty__x_lang;
90456:     nsCSSExpandedDataBlock block;
90456:     mDecl->ExpandTo(&block);
90456:     nsCSSValue cssValue(PromiseFlatString(aMappedAttrValue), eCSSUnit_Ident);
90456:     block.AddLonghandProperty(propertyID, cssValue);
90456:     mDecl->ValueAppended(propertyID);
90456:     mDecl->CompressFrom(&block);
90456:   }
39487: }
39487: 
63693: already_AddRefed<css::StyleRule>
39487: MappedAttrParser::CreateStyleRule()
39487: {
39487:   if (!mDecl) {
39487:     return nsnull; // No mapped attributes were parsed
39487:   }
39487: 
64685:   nsRefPtr<css::StyleRule> rule = new css::StyleRule(nsnull, mDecl);
39487:   mDecl = nsnull; // We no longer own the declaration -- drop our pointer to it
39487:   return rule.forget();
39487: }
39487: 
47936: } // anonymous namespace
47936: 
    1: //----------------------------------------------------------------------
    1: // Implementation Helpers:
    1: 
79445: bool
    1: nsSVGElement::IsEventName(nsIAtom* aName)
    1: {
80486:   return false;
    1: }
    1: 
    1: void
    1: nsSVGElement::UpdateContentStyleRule()
    1: {
    1:   NS_ASSERTION(!mContentStyleRule, "we already have a content style rule");
    1: 
38849:   PRUint32 attrCount = mAttrsAndChildren.AttrCount();
38849:   if (!attrCount) {
38849:     // nothing to do
38849:     return;
38849:   }
38849: 
80526:   nsIDocument* doc = OwnerDoc();
39487:   MappedAttrParser mappedAttrParser(doc->CSSLoader(), doc->GetDocumentURI(),
39487:                                     GetBaseURI(), NodePrincipal());
38849: 
38849:   for (PRUint32 i = 0; i < attrCount; ++i) {
38849:     const nsAttrName* attrName = mAttrsAndChildren.AttrNameAt(i);
38849:     if (!attrName->IsAtom() || !IsAttributeMapped(attrName->Atom()))
38849:       continue;
38849: 
90456:     if (attrName->NamespaceID() != kNameSpaceID_None &&
90456:         !attrName->Equals(nsGkAtoms::lang, kNameSpaceID_XML)) {
90456:       continue;
90456:     }
90456: 
90456:     if (attrName->Equals(nsGkAtoms::lang, kNameSpaceID_None) &&
90456:         HasAttr(kNameSpaceID_XML, nsGkAtoms::lang)) {
90456:       continue; // xml:lang has precedence
90456:     }
90456: 
86211:     if (Tag() == nsGkAtoms::svg) {
86211:       // Special case: we don't want <svg> 'width'/'height' mapped into style
86211:       // if the attribute value isn't a valid <length> according to SVG (which
86211:       // only supports a subset of the CSS <length> values). We don't enforce
86211:       // this by checking the attribute value in nsSVGSVGElement::
86211:       // IsAttributeMapped since we don't want that method to depend on the
86211:       // value of the attribute that is being checked. Rather we just prevent
86211:       // the actual mapping here, as necessary.
86211:       if (attrName->Atom() == nsGkAtoms::width &&
86211:           !GetAnimatedLength(nsGkAtoms::width)->HasBaseVal()) {
86211:         continue;
86211:       }
86211:       if (attrName->Atom() == nsGkAtoms::height &&
86211:           !GetAnimatedLength(nsGkAtoms::height)->HasBaseVal()) {
86211:         continue;
86211:       }
86211:     }
86211: 
    1:     nsAutoString value;
    1:     mAttrsAndChildren.AttrAt(i)->ToString(value);
39487:     mappedAttrParser.ParseMappedAttrValue(attrName->Atom(), value);
    1:   }
39487:   mContentStyleRule = mappedAttrParser.CreateStyleRule();
    1: }
    1: 
39488: static void
39488: ParseMappedAttrAnimValueCallback(void*    aObject,
39488:                                  nsIAtom* aPropertyName,
39488:                                  void*    aPropertyValue,
39488:                                  void*    aData)
39488: {
39488:   NS_ABORT_IF_FALSE(aPropertyName != SMIL_MAPPED_ATTR_STYLERULE_ATOM,
39488:                     "animated content style rule should have been removed "
39488:                     "from properties table already (we're rebuilding it now)");
39488: 
39488:   MappedAttrParser* mappedAttrParser =
39488:     static_cast<MappedAttrParser*>(aData);
39488: 
39488:   nsStringBuffer* valueBuf = static_cast<nsStringBuffer*>(aPropertyValue);
39488:   nsAutoString value;
39488:   PRUint32 len = NS_strlen(static_cast<PRUnichar*>(valueBuf->Data()));
39488:   valueBuf->ToString(len, value);
39488: 
39488:   mappedAttrParser->ParseMappedAttrValue(aPropertyName, value);
39488: }
39488: 
39488: // Callback for freeing animated content style rule, in property table.
39488: static void
39488: ReleaseStyleRule(void*    aObject,       /* unused */
39488:                  nsIAtom* aPropertyName,
39488:                  void*    aPropertyValue,
39488:                  void*    aData          /* unused */)
39488: {
39488:   NS_ABORT_IF_FALSE(aPropertyName == SMIL_MAPPED_ATTR_STYLERULE_ATOM,
39488:                     "unexpected property name, for "
39488:                     "animated content style rule");
63693:   css::StyleRule* styleRule = static_cast<css::StyleRule*>(aPropertyValue);
39488:   NS_ABORT_IF_FALSE(styleRule, "unexpected null style rule");
39488:   styleRule->Release();
39488: }
39488: 
39488: void
39488: nsSVGElement::UpdateAnimatedContentStyleRule()
39488: {
39488:   NS_ABORT_IF_FALSE(!GetAnimatedContentStyleRule(),
39488:                     "Animated content style rule already set");
39488: 
80526:   nsIDocument* doc = OwnerDoc();
39488:   if (!doc) {
39488:     NS_ERROR("SVG element without owner document");
39488:     return;
39488:   }
39488: 
39488:   MappedAttrParser mappedAttrParser(doc->CSSLoader(), doc->GetDocumentURI(),
39488:                                     GetBaseURI(), NodePrincipal());
41182:   doc->PropertyTable(SMIL_MAPPED_ATTR_ANIMVAL)->
41182:     Enumerate(this, ParseMappedAttrAnimValueCallback, &mappedAttrParser);
39488:  
63693:   nsRefPtr<css::StyleRule>
39488:     animContentStyleRule(mappedAttrParser.CreateStyleRule());
39488: 
39488:   if (animContentStyleRule) {
58643: #ifdef DEBUG
58643:     nsresult rv =
58643: #endif
58643:       SetProperty(SMIL_MAPPED_ATTR_ANIMVAL,
39488:                   SMIL_MAPPED_ATTR_STYLERULE_ATOM,
58643:                   animContentStyleRule.get(),
58643:                   ReleaseStyleRule);
39488:     animContentStyleRule.forget();
39488:     NS_ABORT_IF_FALSE(rv == NS_OK,
39488:                       "SetProperty failed (or overwrote something)");
39488:   }
39488: }
39488: 
63693: css::StyleRule*
39488: nsSVGElement::GetAnimatedContentStyleRule()
39488: {
39488:   return
63693:     static_cast<css::StyleRule*>(GetProperty(SMIL_MAPPED_ATTR_ANIMVAL,
39488:                                              SMIL_MAPPED_ATTR_STYLERULE_ATOM,
39488:                                              nsnull));
39488: }
39488: 
90211: /**
90211:  * Helper methods for the type-specific WillChangeXXX methods.
90211:  *
90211:  * This method sends out appropriate pre-change notifications so that selector
90211:  * restyles (e.g. due to changes that cause |elem[attr="val"]| to start/stop
90211:  * matching) work, and it returns an nsAttrValue that _may_ contain the
90211:  * attribute's pre-change value.
90211:  *
90211:  * The nsAttrValue returned by this method depends on whether there are
90211:  * mutation event listeners listening for changes to this element's attributes.
90211:  * If not, then the object returned is empty. If there are, then the
90211:  * nsAttrValue returned contains a serialized copy of the attribute's value
90211:  * prior to the change, and this object should be passed to the corresponding
90211:  * DidChangeXXX method call (assuming a WillChangeXXX call is required for the
90211:  * SVG type - see comment below). This is necessary so that the 'prevValue'
90211:  * property of the mutation event that is dispatched will correctly contain the
90211:  * old value.
90211:  *
90211:  * The reason we need to serialize the old value if there are mutation
90211:  * event listeners is because the underlying nsAttrValue for the attribute
90211:  * points directly to a parsed representation of the attribute (e.g. an
90211:  * SVGAnimatedLengthList*) that is a member of the SVG element. That object
90211:  * will have changed by the time DidChangeXXX has been called, so without the
90211:  * serialization of the old attribute value that we provide, DidChangeXXX
90211:  * would have no way to get the old value to pass to SetAttrAndNotify.
90211:  *
90211:  * We only return the old value when there are mutation event listeners because
90211:  * it's not needed otherwise, and because it's expensive to serialize the old
90211:  * value. This is especially true for list type attributes, which may be built
90211:  * up via the SVG DOM resulting in a large number of Will/DidModifyXXX calls
90211:  * before the script finally finishes setting the attribute.
90211:  *
90211:  * Note that unlike using SetParsedAttr, using Will/DidChangeXXX does NOT check
90211:  * and filter out redundant changes. Before calling WillChangeXXX, the caller
90211:  * should check whether the new and old values are actually the same, and skip
90211:  * calling Will/DidChangeXXX if they are.
90211:  *
90211:  * Also note that not all SVG types use this scheme. For types that can be
90211:  * represented by an nsAttrValue without pointing back to an SVG object (e.g.
90211:  * enums, booleans, integers) we can simply use SetParsedAttr which will do all
90211:  * of the above for us. For such types there is no matching WillChangeXXX
90211:  * method, only DidChangeXXX which calls SetParsedAttr.
90211:  */
90211: nsAttrValue
90211: nsSVGElement::WillChangeValue(nsIAtom* aName)
90211: {
90211:   // We need an empty attr value:
90211:   //   a) to pass to BeforeSetAttr when GetParsedAttr returns nsnull
90211:   //   b) to store the old value in the case we have mutation listeners
90211:   // We can use the same value for both purposes since (a) happens before (b).
90211:   // Also, we should be careful to always return this value to benefit from
90211:   // return value optimization.
90211:   nsAttrValue emptyOrOldAttrValue;
90211:   const nsAttrValue* attrValue = GetParsedAttr(aName);
90211: 
90211:   // This is not strictly correct--the attribute value parameter for
90211:   // BeforeSetAttr should reflect the value that *will* be set but that implies
90211:   // allocating, e.g. an extra nsSVGLength2, and isn't necessary at the moment
90211:   // since no SVG elements overload BeforeSetAttr. For now we just pass the
90211:   // current value.
90211:   nsAttrValueOrString attrStringOrValue(attrValue ? *attrValue
90211:                                                   : emptyOrOldAttrValue);
90211:   DebugOnly<nsresult> rv =
90211:     BeforeSetAttr(kNameSpaceID_None, aName, &attrStringOrValue,
90211:                   kNotifyDocumentObservers);
90211:   // SVG elements aren't expected to overload BeforeSetAttr in such a way that
90211:   // it may fail. So long as this is the case we don't need to check and pass on
90211:   // the return value which simplifies the calling code significantly.
90211:   NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "Unexpected failure from BeforeSetAttr");
90211: 
90211:   // We only need to set the old value if we have listeners since otherwise it
90211:   // isn't used.
90211:   if (attrValue &&
90211:       nsContentUtils::HasMutationListeners(this,
90211:                                            NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
90211:                                            this)) {
90211:     emptyOrOldAttrValue.SetToSerialized(*attrValue);
90211:   }
90211: 
90211:   PRUint8 modType = attrValue
90211:                   ? static_cast<PRUint8>(nsIDOMMutationEvent::MODIFICATION)
90211:                   : static_cast<PRUint8>(nsIDOMMutationEvent::ADDITION);
90211:   nsNodeUtils::AttributeWillChange(this, kNameSpaceID_None, aName, modType);
90211: 
90211:   return emptyOrOldAttrValue;
90211: }
90211: 
90211: /**
90211:  * Helper methods for the type-specific DidChangeXXX methods.
90211:  *
90211:  * aEmptyOrOldValue will normally be the object returned from the corresponding
90211:  * WillChangeXXX call. This is because:
90211:  * a) WillChangeXXX will ensure the object is set when we have mutation
90211:  *    listeners, and
90211:  * b) WillChangeXXX will ensure the object represents a serialized version of
90211:  *    the old attribute value so that the value doesn't change when the
90211:  *    underlying SVG type is updated.
90211:  */
90211: void
90211: nsSVGElement::DidChangeValue(nsIAtom* aName,
90211:                              const nsAttrValue& aEmptyOrOldValue,
90211:                              nsAttrValue& aNewValue)
90211: {
90211:   bool hasListeners =
90211:     nsContentUtils::HasMutationListeners(this,
90211:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
90211:                                          this);
90211:   PRUint8 modType = HasAttr(kNameSpaceID_None, aName)
90211:                   ? static_cast<PRUint8>(nsIDOMMutationEvent::MODIFICATION)
90211:                   : static_cast<PRUint8>(nsIDOMMutationEvent::ADDITION);
90211:   SetAttrAndNotify(kNameSpaceID_None, aName, nsnull, aEmptyOrOldValue,
90211:                    aNewValue, modType, hasListeners, kNotifyDocumentObservers,
90211:                    kCallAfterSetAttr);
90211: }
90211: 
90211: void
90211: nsSVGElement::MaybeSerializeAttrBeforeRemoval(nsIAtom* aName, bool aNotify)
90211: {
90211:   if (!aNotify ||
90211:       !nsContentUtils::HasMutationListeners(this,
90211:                                             NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
90211:                                             this)) {
90211:     return;
90211:   }
90211: 
91863:   const nsAttrValue* attrValue = mAttrsAndChildren.GetAttr(aName);
91863:   if (!attrValue)
91863:     return;
91863: 
90211:   nsAutoString serializedValue;
91863:   attrValue->ToString(serializedValue);
91863:   nsAttrValue oldAttrValue(serializedValue);
91863:   mAttrsAndChildren.SetAndTakeAttr(aName, oldAttrValue);
90211: }
90211: 
    1: /* static */
    1: nsIAtom* nsSVGElement::GetEventNameForAttr(nsIAtom* aAttr)
    1: {
    1:   if (aAttr == nsGkAtoms::onload)
    1:     return nsGkAtoms::onSVGLoad;
    1:   if (aAttr == nsGkAtoms::onunload)
    1:     return nsGkAtoms::onSVGUnload;
    1:   if (aAttr == nsGkAtoms::onabort)
    1:     return nsGkAtoms::onSVGAbort;
    1:   if (aAttr == nsGkAtoms::onerror)
    1:     return nsGkAtoms::onSVGError;
    1:   if (aAttr == nsGkAtoms::onresize)
    1:     return nsGkAtoms::onSVGResize;
    1:   if (aAttr == nsGkAtoms::onscroll)
    1:     return nsGkAtoms::onSVGScroll;
    1:   if (aAttr == nsGkAtoms::onzoom)
    1:     return nsGkAtoms::onSVGZoom;
48450:   if (aAttr == nsGkAtoms::onbegin)
48450:     return nsGkAtoms::onbeginEvent;
48450:   if (aAttr == nsGkAtoms::onrepeat)
48450:     return nsGkAtoms::onrepeatEvent;
48450:   if (aAttr == nsGkAtoms::onend)
48450:     return nsGkAtoms::onendEvent;
    1: 
    1:   return aAttr;
    1: }
    1: 
    1: nsSVGSVGElement *
71887: nsSVGElement::GetCtx() const
    1: {
67658:   nsIContent* ancestor = GetFlattenedTreeParent();
64140: 
84637:   while (ancestor && ancestor->IsSVG()) {
64140:     nsIAtom* tag = ancestor->Tag();
64140:     if (tag == nsGkAtoms::foreignObject) {
64140:       return nsnull;
64140:     }
64140:     if (tag == nsGkAtoms::svg) {
64140:       return static_cast<nsSVGSVGElement*>(ancestor);
64140:     }
67658:     ancestor = ancestor->GetFlattenedTreeParent();
64140:   }
64140: 
64140:   // we don't have an ancestor <svg> element...
64140:   return nsnull;
    1: }
    1: 
27899: /* virtual */ gfxMatrix
90361: nsSVGElement::PrependLocalTransformsTo(const gfxMatrix &aMatrix,
90361:                                        TransformTypes aWhich) const
27899: {
27899:   return aMatrix;
27899: }
27899: 
    1: nsSVGElement::LengthAttributesInfo
    1: nsSVGElement::GetLengthInfo()
    1: {
    1:   return LengthAttributesInfo(nsnull, nsnull, 0);
    1: }
    1: 
 8288: void nsSVGElement::LengthAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mLengths[aAttrEnum].Init(mLengthInfo[aAttrEnum].mCtxType,
 8288:                            aAttrEnum,
 8288:                            mLengthInfo[aAttrEnum].mDefaultValue,
 8288:                            mLengthInfo[aAttrEnum].mDefaultUnitType);
 8288: }
 8288: 
    1: void
72186: nsSVGElement::SetLength(nsIAtom* aName, const nsSVGLength2 &aLength)
72186: {
72186:   LengthAttributesInfo lengthInfo = GetLengthInfo();
72186: 
72186:   for (PRUint32 i = 0; i < lengthInfo.mLengthCount; i++) {
72186:     if (aName == *lengthInfo.mLengthInfo[i].mName) {
72186:       lengthInfo.mLengths[i] = aLength;
80038:       DidAnimateLength(i);
72186:       return;
72186:     }
72186:   }
72186:   NS_ABORT_IF_FALSE(false, "no length found to set");
72186: }
72186: 
90211: nsAttrValue
90211: nsSVGElement::WillChangeLength(PRUint8 aAttrEnum)
90211: {
90211:   return WillChangeValue(*GetLengthInfo().mLengthInfo[aAttrEnum].mName);
90211: }
90211: 
72186: void
90211: nsSVGElement::DidChangeLength(PRUint8 aAttrEnum,
90211:                               const nsAttrValue& aEmptyOrOldValue)
    1: {
    1:   LengthAttributesInfo info = GetLengthInfo();
    1: 
    1:   NS_ASSERTION(info.mLengthCount > 0,
    1:                "DidChangeLength on element with no length attribs");
    1:   NS_ASSERTION(aAttrEnum < info.mLengthCount, "aAttrEnum out of range");
    1: 
90211:   nsAttrValue newValue;
90211:   newValue.SetTo(info.mLengths[aAttrEnum], nsnull);
90211: 
90211:   DidChangeValue(*info.mLengthInfo[aAttrEnum].mName, aEmptyOrOldValue,
90211:                  newValue);
    1: }
    1: 
    1: void
23697: nsSVGElement::DidAnimateLength(PRUint8 aAttrEnum)
23697: {
23697:   nsIFrame* frame = GetPrimaryFrame();
23697: 
23697:   if (frame) {
23697:     LengthAttributesInfo info = GetLengthInfo();
23697:     frame->AttributeChanged(kNameSpaceID_None,
23697:                             *info.mLengthInfo[aAttrEnum].mName,
23697:                             nsIDOMMutationEvent::MODIFICATION);
23697:   }
23697: }
23697: 
86211: nsSVGLength2*
86211: nsSVGElement::GetAnimatedLength(const nsIAtom *aAttrName)
86211: {
86211:   LengthAttributesInfo lengthInfo = GetLengthInfo();
86211: 
86211:   for (PRUint32 i = 0; i < lengthInfo.mLengthCount; i++) {
86211:     if (aAttrName == *lengthInfo.mLengthInfo[i].mName) {
86211:       return &lengthInfo.mLengths[i];
86211:     }
86211:   }
86211:   NS_ABORT_IF_FALSE(false, "no matching length found");
86211:   return nsnull;
86211: }
86211: 
23697: void
    1: nsSVGElement::GetAnimatedLengthValues(float *aFirst, ...)
    1: {
    1:   LengthAttributesInfo info = GetLengthInfo();
    1: 
    1:   NS_ASSERTION(info.mLengthCount > 0,
    1:                "GetAnimatedLengthValues on element with no length attribs");
    1: 
    1:   nsSVGSVGElement *ctx = nsnull;
    1: 
    1:   float *f = aFirst;
    1:   PRUint32 i = 0;
    1: 
    1:   va_list args;
    1:   va_start(args, aFirst);
    1: 
    1:   while (f && i < info.mLengthCount) {
 2755:     PRUint8 type = info.mLengths[i].GetSpecifiedUnitType();
    1:     if (!ctx) {
    1:       if (type != nsIDOMSVGLength::SVG_LENGTHTYPE_NUMBER &&
    1:           type != nsIDOMSVGLength::SVG_LENGTHTYPE_PX)
    1:         ctx = GetCtx();
    1:     }
 2755:     if (type == nsIDOMSVGLength::SVG_LENGTHTYPE_EMS ||
 2755:         type == nsIDOMSVGLength::SVG_LENGTHTYPE_EXS)
 2755:       *f = info.mLengths[i++].GetAnimValue(this);
 2755:     else
    1:       *f = info.mLengths[i++].GetAnimValue(ctx);
    1:     f = va_arg(args, float*);
    1:   }
    1: 
    1:   va_end(args);
    1: }
    1: 
47840: nsSVGElement::LengthListAttributesInfo
47840: nsSVGElement::GetLengthListInfo()
47840: {
47840:   return LengthListAttributesInfo(nsnull, nsnull, 0);
47840: }
47840: 
47840: void
47840: nsSVGElement::LengthListAttributesInfo::Reset(PRUint8 aAttrEnum)
47840: {
47840:   mLengthLists[aAttrEnum].ClearBaseValue(aAttrEnum);
47840:   // caller notifies
47840: }
47840: 
90212: nsAttrValue
90212: nsSVGElement::WillChangeLengthList(PRUint8 aAttrEnum)
90212: {
90212:   return WillChangeValue(*GetLengthListInfo().mLengthListInfo[aAttrEnum].mName);
90212: }
90212: 
47840: void
90212: nsSVGElement::DidChangeLengthList(PRUint8 aAttrEnum,
90212:                                   const nsAttrValue& aEmptyOrOldValue)
47840: {
47840:   LengthListAttributesInfo info = GetLengthListInfo();
47840: 
47840:   NS_ASSERTION(info.mLengthListCount > 0,
47840:                "DidChangeLengthList on element with no length list attribs");
47840:   NS_ASSERTION(aAttrEnum < info.mLengthListCount, "aAttrEnum out of range");
47840: 
90212:   nsAttrValue newValue;
90212:   newValue.SetTo(info.mLengthLists[aAttrEnum].GetBaseValue(), nsnull);
90212: 
90212:   DidChangeValue(*info.mLengthListInfo[aAttrEnum].mName, aEmptyOrOldValue,
90212:                  newValue);
47840: }
47840: 
47840: void
47840: nsSVGElement::DidAnimateLengthList(PRUint8 aAttrEnum)
47840: {
47840:   nsIFrame* frame = GetPrimaryFrame();
47840: 
47840:   if (frame) {
47840:     LengthListAttributesInfo info = GetLengthListInfo();
47840:     frame->AttributeChanged(kNameSpaceID_None,
47840:                             *info.mLengthListInfo[aAttrEnum].mName,
47840:                             nsIDOMMutationEvent::MODIFICATION);
47840:   }
47840: }
47840: 
47840: void
47840: nsSVGElement::GetAnimatedLengthListValues(SVGUserUnitList *aFirst, ...)
47840: {
47840:   LengthListAttributesInfo info = GetLengthListInfo();
47840: 
47840:   NS_ASSERTION(info.mLengthListCount > 0,
47840:                "GetAnimatedLengthListValues on element with no length list attribs");
47840: 
47840:   SVGUserUnitList *list = aFirst;
47840:   PRUint32 i = 0;
47840: 
47840:   va_list args;
47840:   va_start(args, aFirst);
47840: 
47840:   while (list && i < info.mLengthListCount) {
47840:     list->Init(&(info.mLengthLists[i].GetAnimValue()), this, info.mLengthListInfo[i].mAxis);
47840:     ++i;
47840:     list = va_arg(args, SVGUserUnitList*);
47840:   }
47840: 
47840:   va_end(args);
47840: }
47840: 
47840: SVGAnimatedLengthList*
47840: nsSVGElement::GetAnimatedLengthList(PRUint8 aAttrEnum)
47840: {
47840:   LengthListAttributesInfo info = GetLengthListInfo();
47840:   if (aAttrEnum < info.mLengthListCount) {
47840:     return &(info.mLengthLists[aAttrEnum]);
47840:   }
47840:   NS_NOTREACHED("Bad attrEnum");
47840:   return nsnull;
47840: }
47840: 
57113: 
58554: nsSVGElement::NumberListAttributesInfo
58554: nsSVGElement::GetNumberListInfo()
58554: {
58554:   return NumberListAttributesInfo(nsnull, nsnull, 0);
58554: }
58554: 
58554: void
58554: nsSVGElement::NumberListAttributesInfo::Reset(PRUint8 aAttrEnum)
58554: {
58554:   NS_ABORT_IF_FALSE(aAttrEnum < mNumberListCount, "Bad attr enum");
58554:   mNumberLists[aAttrEnum].ClearBaseValue(aAttrEnum);
58554:   // caller notifies
58554: }
58554: 
90222: nsAttrValue
90222: nsSVGElement::WillChangeNumberList(PRUint8 aAttrEnum)
90222: {
90222:   return WillChangeValue(*GetNumberListInfo().mNumberListInfo[aAttrEnum].mName);
90222: }
90222: 
58554: void
90222: nsSVGElement::DidChangeNumberList(PRUint8 aAttrEnum,
90222:                                   const nsAttrValue& aEmptyOrOldValue)
58554: {
58554:   NumberListAttributesInfo info = GetNumberListInfo();
58554: 
58554:   NS_ABORT_IF_FALSE(info.mNumberListCount > 0,
58554:     "DidChangeNumberList on element with no number list attribs");
90222:   NS_ABORT_IF_FALSE(aAttrEnum < info.mNumberListCount,
90222:     "aAttrEnum out of range");
58554: 
90222:   nsAttrValue newValue;
90222:   newValue.SetTo(info.mNumberLists[aAttrEnum].GetBaseValue(), nsnull);
58554: 
90222:   DidChangeValue(*info.mNumberListInfo[aAttrEnum].mName, aEmptyOrOldValue,
90222:                  newValue);
58554: }
58554: 
58554: void
58554: nsSVGElement::DidAnimateNumberList(PRUint8 aAttrEnum)
58554: {
58554:   nsIFrame* frame = GetPrimaryFrame();
58554: 
58554:   if (frame) {
58554:     NumberListAttributesInfo info = GetNumberListInfo();
58554:     NS_ABORT_IF_FALSE(aAttrEnum < info.mNumberListCount, "aAttrEnum out of range");
58554: 
58554:     frame->AttributeChanged(kNameSpaceID_None,
58554:                             *info.mNumberListInfo[aAttrEnum].mName,
58554:                             nsIDOMMutationEvent::MODIFICATION);
58554:   }
58554: }
58554: 
58554: SVGAnimatedNumberList*
58554: nsSVGElement::GetAnimatedNumberList(PRUint8 aAttrEnum)
58554: {
58554:   NumberListAttributesInfo info = GetNumberListInfo();
58554:   if (aAttrEnum < info.mNumberListCount) {
58554:     return &(info.mNumberLists[aAttrEnum]);
58554:   }
80486:   NS_ABORT_IF_FALSE(false, "Bad attrEnum");
58554:   return nsnull;
58554: }
58554: 
58554: SVGAnimatedNumberList*
58554: nsSVGElement::GetAnimatedNumberList(nsIAtom *aAttrName)
58554: {
58554:   NumberListAttributesInfo info = GetNumberListInfo();
58554:   for (PRUint32 i = 0; i < info.mNumberListCount; i++) {
58554:     if (aAttrName == *info.mNumberListInfo[i].mName) {
58554:       return &info.mNumberLists[i];
58554:     }
58554:   }
80486:   NS_ABORT_IF_FALSE(false, "Bad caller");
58554:   return nsnull;
58554: }
58554: 
90223: nsAttrValue
90223: nsSVGElement::WillChangePointList()
90223: {
90223:   NS_ABORT_IF_FALSE(GetPointListAttrName(),
90223:                     "Changing non-existent point list?");
90223:   return WillChangeValue(GetPointListAttrName());
90223: }
90223: 
57113: void
90223: nsSVGElement::DidChangePointList(const nsAttrValue& aEmptyOrOldValue)
58893: {
90223:   NS_ABORT_IF_FALSE(GetPointListAttrName(),
90223:                     "Changing non-existent point list?");
58893: 
90223:   nsAttrValue newValue;
90223:   newValue.SetTo(GetAnimatedPointList()->GetBaseValue(), nsnull);
58893: 
90223:   DidChangeValue(GetPointListAttrName(), aEmptyOrOldValue, newValue);
58893: }
58893: 
58893: void
58893: nsSVGElement::DidAnimatePointList()
58893: {
58893:   NS_ABORT_IF_FALSE(GetPointListAttrName(),
58893:                     "Animating non-existent path data?");
58893: 
58893:   nsIFrame* frame = GetPrimaryFrame();
58893: 
58893:   if (frame) {
58893:     frame->AttributeChanged(kNameSpaceID_None,
58893:                             GetPointListAttrName(),
58893:                             nsIDOMMutationEvent::MODIFICATION);
58893:   }
58893: }
58893: 
90224: nsAttrValue
90224: nsSVGElement::WillChangePathSegList()
90224: {
90224:   NS_ABORT_IF_FALSE(GetPathDataAttrName(),
90224:                     "Changing non-existent path seg list?");
90224:   return WillChangeValue(GetPathDataAttrName());
90224: }
90224: 
58893: void
90224: nsSVGElement::DidChangePathSegList(const nsAttrValue& aEmptyOrOldValue)
57113: {
90224:   NS_ABORT_IF_FALSE(GetPathDataAttrName(),
90224:                     "Changing non-existent path seg list?");
57113: 
90224:   nsAttrValue newValue;
90224:   newValue.SetTo(GetAnimPathSegList()->GetBaseValue(), nsnull);
57113: 
90224:   DidChangeValue(GetPathDataAttrName(), aEmptyOrOldValue, newValue);
57113: }
57113: 
57113: void
57113: nsSVGElement::DidAnimatePathSegList()
57113: {
57113:   NS_ABORT_IF_FALSE(GetPathDataAttrName(),
58893:                     "Animating non-existent path data?");
57113: 
57113:   nsIFrame* frame = GetPrimaryFrame();
57113: 
57113:   if (frame) {
57113:     frame->AttributeChanged(kNameSpaceID_None,
57113:                             GetPathDataAttrName(),
57113:                             nsIDOMMutationEvent::MODIFICATION);
57113:   }
57113: }
57113: 
    1: nsSVGElement::NumberAttributesInfo
    1: nsSVGElement::GetNumberInfo()
    1: {
    1:   return NumberAttributesInfo(nsnull, nsnull, 0);
    1: }
    1: 
 8288: void nsSVGElement::NumberAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mNumbers[aAttrEnum].Init(aAttrEnum,
 8288:                            mNumberInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
    1: void
90213: nsSVGElement::DidChangeNumber(PRUint8 aAttrEnum)
    1: {
    1:   NumberAttributesInfo info = GetNumberInfo();
    1: 
    1:   NS_ASSERTION(info.mNumberCount > 0,
    1:                "DidChangeNumber on element with no number attribs");
    1:   NS_ASSERTION(aAttrEnum < info.mNumberCount, "aAttrEnum out of range");
    1: 
90213:   nsAttrValue attrValue;
90213:   attrValue.SetTo(info.mNumbers[aAttrEnum].GetBaseValue(), nsnull);
90213: 
61741:   SetParsedAttr(kNameSpaceID_None, *info.mNumberInfo[aAttrEnum].mName, nsnull,
80486:                 attrValue, true);
    1: }
    1: 
    1: void
37220: nsSVGElement::DidAnimateNumber(PRUint8 aAttrEnum)
37220: {
37220:   nsIFrame* frame = GetPrimaryFrame();
37220: 
37220:   if (frame) {
37220:     NumberAttributesInfo info = GetNumberInfo();
37220:     frame->AttributeChanged(kNameSpaceID_None,
37220:                             *info.mNumberInfo[aAttrEnum].mName,
37220:                             nsIDOMMutationEvent::MODIFICATION);
37220:   }
37220: }
37220: 
37220: void
    1: nsSVGElement::GetAnimatedNumberValues(float *aFirst, ...)
    1: {
    1:   NumberAttributesInfo info = GetNumberInfo();
    1: 
    1:   NS_ASSERTION(info.mNumberCount > 0,
    1:                "GetAnimatedNumberValues on element with no number attribs");
    1: 
    1:   float *f = aFirst;
    1:   PRUint32 i = 0;
    1: 
    1:   va_list args;
    1:   va_start(args, aFirst);
    1: 
    1:   while (f && i < info.mNumberCount) {
38700:     *f = info.mNumbers[i++].GetAnimValue();
    1:     f = va_arg(args, float*);
    1:   }
    1:   va_end(args);
    1: }
    1: 
72919: nsSVGElement::NumberPairAttributesInfo
72919: nsSVGElement::GetNumberPairInfo()
72919: {
72919:   return NumberPairAttributesInfo(nsnull, nsnull, 0);
72919: }
72919: 
72919: void nsSVGElement::NumberPairAttributesInfo::Reset(PRUint8 aAttrEnum)
72919: {
72919:   mNumberPairs[aAttrEnum].Init(aAttrEnum,
72919:                                mNumberPairInfo[aAttrEnum].mDefaultValue1,
72919:                                mNumberPairInfo[aAttrEnum].mDefaultValue2);
72919: }
72919: 
90214: nsAttrValue
90214: nsSVGElement::WillChangeNumberPair(PRUint8 aAttrEnum)
90214: {
90214:   return WillChangeValue(*GetNumberPairInfo().mNumberPairInfo[aAttrEnum].mName);
90214: }
90214: 
72919: void
90214: nsSVGElement::DidChangeNumberPair(PRUint8 aAttrEnum,
90214:                                   const nsAttrValue& aEmptyOrOldValue)
72919: {
72919:   NumberPairAttributesInfo info = GetNumberPairInfo();
72919: 
72919:   NS_ASSERTION(info.mNumberPairCount > 0,
72919:                "DidChangePairNumber on element with no number pair attribs");
72919:   NS_ASSERTION(aAttrEnum < info.mNumberPairCount, "aAttrEnum out of range");
72919: 
90214:   nsAttrValue newValue;
90214:   newValue.SetTo(info.mNumberPairs[aAttrEnum], nsnull);
90214: 
90214:   DidChangeValue(*info.mNumberPairInfo[aAttrEnum].mName, aEmptyOrOldValue,
90214:                  newValue);
72919: }
72919: 
72919: void
72919: nsSVGElement::DidAnimateNumberPair(PRUint8 aAttrEnum)
72919: {
72919:   nsIFrame* frame = GetPrimaryFrame();
72919: 
72919:   if (frame) {
72919:     NumberPairAttributesInfo info = GetNumberPairInfo();
72919:     frame->AttributeChanged(kNameSpaceID_None,
72919:                             *info.mNumberPairInfo[aAttrEnum].mName,
72919:                             nsIDOMMutationEvent::MODIFICATION);
72919:   }
72919: }
72919: 
 6045: nsSVGElement::IntegerAttributesInfo
 6045: nsSVGElement::GetIntegerInfo()
 6045: {
 6045:   return IntegerAttributesInfo(nsnull, nsnull, 0);
 6045: }
 6045: 
 8288: void nsSVGElement::IntegerAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mIntegers[aAttrEnum].Init(aAttrEnum,
 8288:                             mIntegerInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
 6045: void
90215: nsSVGElement::DidChangeInteger(PRUint8 aAttrEnum)
 6045: {
 6045:   IntegerAttributesInfo info = GetIntegerInfo();
 6045: 
 6045:   NS_ASSERTION(info.mIntegerCount > 0,
 6045:                "DidChangeInteger on element with no integer attribs");
 6045:   NS_ASSERTION(aAttrEnum < info.mIntegerCount, "aAttrEnum out of range");
 6045: 
90215:   nsAttrValue attrValue;
90215:   attrValue.SetTo(info.mIntegers[aAttrEnum].GetBaseValue(), nsnull);
 6045: 
61741:   SetParsedAttr(kNameSpaceID_None, *info.mIntegerInfo[aAttrEnum].mName, nsnull,
80486:                 attrValue, true);
 6045: }
 6045: 
 6045: void
38297: nsSVGElement::DidAnimateInteger(PRUint8 aAttrEnum)
38297: {
38297:   nsIFrame* frame = GetPrimaryFrame();
38297:   
38297:   if (frame) {
38297:     IntegerAttributesInfo info = GetIntegerInfo();
38297:     frame->AttributeChanged(kNameSpaceID_None,
38297:                             *info.mIntegerInfo[aAttrEnum].mName,
38297:                             nsIDOMMutationEvent::MODIFICATION);
38297:   }
38297: }
38297: 
38297: void
 6045: nsSVGElement::GetAnimatedIntegerValues(PRInt32 *aFirst, ...)
 6045: {
 6045:   IntegerAttributesInfo info = GetIntegerInfo();
 6045: 
 6045:   NS_ASSERTION(info.mIntegerCount > 0,
 6045:                "GetAnimatedIntegerValues on element with no integer attribs");
 6045: 
 6045:   PRInt32 *n = aFirst;
 6045:   PRUint32 i = 0;
 6045: 
 6045:   va_list args;
 6045:   va_start(args, aFirst);
 6045: 
 6045:   while (n && i < info.mIntegerCount) {
38700:     *n = info.mIntegers[i++].GetAnimValue();
 6045:     n = va_arg(args, PRInt32*);
 6045:   }
 6045:   va_end(args);
 6045: }
 6045: 
72919: nsSVGElement::IntegerPairAttributesInfo
72919: nsSVGElement::GetIntegerPairInfo()
72919: {
72919:   return IntegerPairAttributesInfo(nsnull, nsnull, 0);
72919: }
72919: 
72919: void nsSVGElement::IntegerPairAttributesInfo::Reset(PRUint8 aAttrEnum)
72919: {
72919:   mIntegerPairs[aAttrEnum].Init(aAttrEnum,
72919:                                 mIntegerPairInfo[aAttrEnum].mDefaultValue1,
72919:                                 mIntegerPairInfo[aAttrEnum].mDefaultValue2);
72919: }
72919: 
90216: nsAttrValue
90216: nsSVGElement::WillChangeIntegerPair(PRUint8 aAttrEnum)
90216: {
90216:   return WillChangeValue(
90216:     *GetIntegerPairInfo().mIntegerPairInfo[aAttrEnum].mName);
90216: }
90216: 
72919: void
90216: nsSVGElement::DidChangeIntegerPair(PRUint8 aAttrEnum,
90216:                                    const nsAttrValue& aEmptyOrOldValue)
72919: {
72919:   IntegerPairAttributesInfo info = GetIntegerPairInfo();
72919: 
72919:   NS_ASSERTION(info.mIntegerPairCount > 0,
72919:                "DidChangeIntegerPair on element with no integer pair attribs");
72919:   NS_ASSERTION(aAttrEnum < info.mIntegerPairCount, "aAttrEnum out of range");
72919: 
90216:   nsAttrValue newValue;
90216:   newValue.SetTo(info.mIntegerPairs[aAttrEnum], nsnull);
72919: 
90216:   DidChangeValue(*info.mIntegerPairInfo[aAttrEnum].mName, aEmptyOrOldValue,
90216:                  newValue);
72919: }
72919: 
72919: void
72919: nsSVGElement::DidAnimateIntegerPair(PRUint8 aAttrEnum)
72919: {
72919:   nsIFrame* frame = GetPrimaryFrame();
72919:   
72919:   if (frame) {
72919:     IntegerPairAttributesInfo info = GetIntegerPairInfo();
72919:     frame->AttributeChanged(kNameSpaceID_None,
72919:                             *info.mIntegerPairInfo[aAttrEnum].mName,
72919:                             nsIDOMMutationEvent::MODIFICATION);
72919:   }
72919: }
72919: 
 6788: nsSVGElement::AngleAttributesInfo
 6788: nsSVGElement::GetAngleInfo()
 6788: {
 6788:   return AngleAttributesInfo(nsnull, nsnull, 0);
 6788: }
 6788: 
 8288: void nsSVGElement::AngleAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mAngles[aAttrEnum].Init(aAttrEnum, 
 8288:                           mAngleInfo[aAttrEnum].mDefaultValue,
 8288:                           mAngleInfo[aAttrEnum].mDefaultUnitType);
 8288: }
 8288: 
90217: nsAttrValue
90217: nsSVGElement::WillChangeAngle(PRUint8 aAttrEnum)
90217: {
90217:   return WillChangeValue(*GetAngleInfo().mAngleInfo[aAttrEnum].mName);
90217: }
90217: 
 6788: void
90217: nsSVGElement::DidChangeAngle(PRUint8 aAttrEnum,
90217:                              const nsAttrValue& aEmptyOrOldValue)
 6788: {
 6788:   AngleAttributesInfo info = GetAngleInfo();
 6788: 
 6788:   NS_ASSERTION(info.mAngleCount > 0,
 6788:                "DidChangeAngle on element with no angle attribs");
 6788:   NS_ASSERTION(aAttrEnum < info.mAngleCount, "aAttrEnum out of range");
 6788: 
90217:   nsAttrValue newValue;
90217:   newValue.SetTo(info.mAngles[aAttrEnum], nsnull);
 6788: 
90217:   DidChangeValue(*info.mAngleInfo[aAttrEnum].mName, aEmptyOrOldValue, newValue);
 6788: }
 6788: 
38295: void
38295: nsSVGElement::DidAnimateAngle(PRUint8 aAttrEnum)
38295: {
38295:   nsIFrame* frame = GetPrimaryFrame();
38295: 
38295:   if (frame) {
38295:     AngleAttributesInfo info = GetAngleInfo();
38295:     frame->AttributeChanged(kNameSpaceID_None,
38295:                             *info.mAngleInfo[aAttrEnum].mName,
38295:                             nsIDOMMutationEvent::MODIFICATION);
38295:   }
38295: }
38295: 
 6325: nsSVGElement::BooleanAttributesInfo
 6325: nsSVGElement::GetBooleanInfo()
 6325: {
 6325:   return BooleanAttributesInfo(nsnull, nsnull, 0);
 6325: }
 6325: 
 8288: void nsSVGElement::BooleanAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mBooleans[aAttrEnum].Init(aAttrEnum,
 8288:                             mBooleanInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
 6325: void
90218: nsSVGElement::DidChangeBoolean(PRUint8 aAttrEnum)
 6325: {
 6325:   BooleanAttributesInfo info = GetBooleanInfo();
 6325: 
 6325:   NS_ASSERTION(info.mBooleanCount > 0,
 6788:                "DidChangeBoolean on element with no boolean attribs");
 6325:   NS_ASSERTION(aAttrEnum < info.mBooleanCount, "aAttrEnum out of range");
 6325: 
90218:   nsAttrValue attrValue(info.mBooleans[aAttrEnum].GetBaseValueAtom());
61741:   SetParsedAttr(kNameSpaceID_None, *info.mBooleanInfo[aAttrEnum].mName, nsnull,
80486:                 attrValue, true);
 6325: }
 6325: 
37456: void
37456: nsSVGElement::DidAnimateBoolean(PRUint8 aAttrEnum)
37456: {
37456:   nsIFrame* frame = GetPrimaryFrame();
37456:   
37456:   if (frame) {
37456:     BooleanAttributesInfo info = GetBooleanInfo();
37456:     frame->AttributeChanged(kNameSpaceID_None,
37456:                             *info.mBooleanInfo[aAttrEnum].mName,
37456:                             nsIDOMMutationEvent::MODIFICATION);
37456:   }
37456: }
37456: 
 5347: nsSVGElement::EnumAttributesInfo
 5347: nsSVGElement::GetEnumInfo()
 5347: {
 5347:   return EnumAttributesInfo(nsnull, nsnull, 0);
 5347: }
 5347: 
 8288: void nsSVGElement::EnumAttributesInfo::Reset(PRUint8 aAttrEnum)
 8288: {
 8288:   mEnums[aAttrEnum].Init(aAttrEnum,
 8288:                          mEnumInfo[aAttrEnum].mDefaultValue);
 8288: }
 8288: 
 5347: void
90210: nsSVGElement::DidChangeEnum(PRUint8 aAttrEnum)
 5347: {
 5347:   EnumAttributesInfo info = GetEnumInfo();
 5347: 
 5347:   NS_ASSERTION(info.mEnumCount > 0,
 6045:                "DidChangeEnum on element with no enum attribs");
 5347:   NS_ASSERTION(aAttrEnum < info.mEnumCount, "aAttrEnum out of range");
 5347: 
90210:   nsAttrValue attrValue(info.mEnums[aAttrEnum].GetBaseValueAtom(this));
61741:   SetParsedAttr(kNameSpaceID_None, *info.mEnumInfo[aAttrEnum].mName, nsnull,
80486:                 attrValue, true);
 5347: }
 5347: 
37442: void
37442: nsSVGElement::DidAnimateEnum(PRUint8 aAttrEnum)
37442: {
37442:   nsIFrame* frame = GetPrimaryFrame();
37442: 
37442:   if (frame) {
37442:     EnumAttributesInfo info = GetEnumInfo();
37442:     frame->AttributeChanged(kNameSpaceID_None,
37442:                             *info.mEnumInfo[aAttrEnum].mName,
37442:                             nsIDOMMutationEvent::MODIFICATION);
37442:   }
37442: }
37442: 
24554: nsSVGViewBox *
24554: nsSVGElement::GetViewBox()
24554: {
24554:   return nsnull;
24554: }
24554: 
90221: nsAttrValue
90221: nsSVGElement::WillChangeViewBox()
90221: {
90221:   return WillChangeValue(nsGkAtoms::viewBox);
90221: }
90221: 
24554: void
90221: nsSVGElement::DidChangeViewBox(const nsAttrValue& aEmptyOrOldValue)
24554: {
24554:   nsSVGViewBox *viewBox = GetViewBox();
24554: 
24554:   NS_ASSERTION(viewBox, "DidChangeViewBox on element with no viewBox attrib");
24554: 
90221:   nsAttrValue newValue;
90221:   newValue.SetTo(*viewBox, nsnull);
24554: 
90221:   DidChangeValue(nsGkAtoms::viewBox, aEmptyOrOldValue, newValue);
24554: }
24554: 
38296: void
38296: nsSVGElement::DidAnimateViewBox()
38296: {
38296:   nsIFrame* frame = GetPrimaryFrame();
38296:   
38296:   if (frame) {
38296:     frame->AttributeChanged(kNameSpaceID_None,
38296:                             nsGkAtoms::viewBox,
38296:                             nsIDOMMutationEvent::MODIFICATION);
38296:   }
38296: }
38296: 
59470: SVGAnimatedPreserveAspectRatio *
23313: nsSVGElement::GetPreserveAspectRatio()
23313: {
23313:   return nsnull;
23313: }
23313: 
90220: nsAttrValue
90220: nsSVGElement::WillChangePreserveAspectRatio()
90220: {
90220:   return WillChangeValue(nsGkAtoms::preserveAspectRatio);
90220: }
90220: 
23313: void
90220: nsSVGElement::DidChangePreserveAspectRatio(const nsAttrValue& aEmptyOrOldValue)
23313: {
59470:   SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
59470:     GetPreserveAspectRatio();
23313: 
23313:   NS_ASSERTION(preserveAspectRatio,
90220:                "DidChangePreserveAspectRatio on element with no "
90220:                "preserveAspectRatio attrib");
23313: 
90220:   nsAttrValue newValue;
90220:   newValue.SetTo(*preserveAspectRatio, nsnull);
23313: 
90220:   DidChangeValue(nsGkAtoms::preserveAspectRatio, aEmptyOrOldValue, newValue);
23313: }
23313: 
37974: void
37974: nsSVGElement::DidAnimatePreserveAspectRatio()
37974: {
37974:   nsIFrame* frame = GetPrimaryFrame();
37974:   
37974:   if (frame) {
37974:     frame->AttributeChanged(kNameSpaceID_None,
37974:                             nsGkAtoms::preserveAspectRatio,
37974:                             nsIDOMMutationEvent::MODIFICATION);
37974:   }
37974: }
37974: 
90225: nsAttrValue
90225: nsSVGElement::WillChangeTransformList()
90225: {
90225:   return WillChangeValue(GetTransformListAttrName());
90225: }
90225: 
38843: void
90225: nsSVGElement::DidChangeTransformList(const nsAttrValue& aEmptyOrOldValue)
38843: {
90225:   NS_ABORT_IF_FALSE(GetTransformListAttrName(),
90225:                     "Changing non-existent transform list?");
90225: 
90225:   nsAttrValue newValue;
90225:   newValue.SetTo(GetAnimatedTransformList()->GetBaseValue(), nsnull);
90225: 
90225:   DidChangeValue(GetTransformListAttrName(), aEmptyOrOldValue, newValue);
78865: }
78865: 
78865: void
78865: nsSVGElement::DidAnimateTransformList()
78865: {
78865:   NS_ABORT_IF_FALSE(GetTransformListAttrName(),
78865:                     "Animating non-existent transform data?");
78865: 
38843:   nsIFrame* frame = GetPrimaryFrame();
38843: 
38843:   if (frame) {
38843:     frame->AttributeChanged(kNameSpaceID_None,
78865:                             GetTransformListAttrName(),
38843:                             nsIDOMMutationEvent::MODIFICATION);
38843:   }
38843: }
38843: 
15353: nsSVGElement::StringAttributesInfo
15353: nsSVGElement::GetStringInfo()
15353: {
15353:   return StringAttributesInfo(nsnull, nsnull, 0);
15353: }
15353: 
15353: void nsSVGElement::StringAttributesInfo::Reset(PRUint8 aAttrEnum)
15353: {
15353:   mStrings[aAttrEnum].Init(aAttrEnum);
15353: }
15353: 
24028: void nsSVGElement::GetStringBaseValue(PRUint8 aAttrEnum, nsAString& aResult) const
15353: {
24028:   nsSVGElement::StringAttributesInfo info = const_cast<nsSVGElement*>(this)->GetStringInfo();
15353: 
15353:   NS_ASSERTION(info.mStringCount > 0,
24028:                "GetBaseValue on element with no string attribs");
24028: 
24028:   NS_ASSERTION(aAttrEnum < info.mStringCount, "aAttrEnum out of range");
24028: 
24028:   GetAttr(info.mStringInfo[aAttrEnum].mNamespaceID,
24028:           *info.mStringInfo[aAttrEnum].mName, aResult);
24028: }
24028: 
24028: void nsSVGElement::SetStringBaseValue(PRUint8 aAttrEnum, const nsAString& aValue)
24028: {
24028:   nsSVGElement::StringAttributesInfo info = GetStringInfo();
24028: 
24028:   NS_ASSERTION(info.mStringCount > 0,
24028:                "SetBaseValue on element with no string attribs");
15353: 
15353:   NS_ASSERTION(aAttrEnum < info.mStringCount, "aAttrEnum out of range");
15353: 
15353:   SetAttr(info.mStringInfo[aAttrEnum].mNamespaceID,
80486:           *info.mStringInfo[aAttrEnum].mName, aValue, true);
15353: }
15353: 
55139: void
55139: nsSVGElement::DidAnimateString(PRUint8 aAttrEnum)
55139: {
55139:   nsIFrame* frame = GetPrimaryFrame();
55139: 
55139:   if (frame) {
55139:     StringAttributesInfo info = GetStringInfo();
55139:     frame->AttributeChanged(info.mStringInfo[aAttrEnum].mNamespaceID,
55139:                             *info.mStringInfo[aAttrEnum].mName,
55139:                             nsIDOMMutationEvent::MODIFICATION);
55139:   }
55139: }
55139: 
86429: nsSVGElement::StringListAttributesInfo
86429: nsSVGElement::GetStringListInfo()
86429: {
86429:   return StringListAttributesInfo(nsnull, nsnull, 0);
86429: }
86429: 
90227: nsAttrValue
90227: nsSVGElement::WillChangeStringList(bool aIsConditionalProcessingAttribute,
90227:                                    PRUint8 aAttrEnum)
90227: {
90227:   nsIAtom* name;
90227:   if (aIsConditionalProcessingAttribute) {
90227:     nsCOMPtr<DOMSVGTests> tests(do_QueryInterface(this));
90227:     name = tests->GetAttrName(aAttrEnum);
90227:   } else {
90227:     name = *GetStringListInfo().mStringListInfo[aAttrEnum].mName;
90227:   }
90227:   return WillChangeValue(name);
90227: }
90227: 
86429: void
86429: nsSVGElement::DidChangeStringList(bool aIsConditionalProcessingAttribute,
90227:                                   PRUint8 aAttrEnum,
90227:                                   const nsAttrValue& aEmptyOrOldValue)
86429: {
90227:   nsIAtom* name;
90227:   nsAttrValue newValue;
90227:   nsCOMPtr<DOMSVGTests> tests;
90227: 
86429:   if (aIsConditionalProcessingAttribute) {
90227:     tests = do_QueryInterface(this);
90227:     name = tests->GetAttrName(aAttrEnum);
90227:     tests->GetAttrValue(aAttrEnum, newValue);
90227:   } else {
86429:     StringListAttributesInfo info = GetStringListInfo();
86429: 
86429:     NS_ASSERTION(info.mStringListCount > 0,
86429:                  "DidChangeStringList on element with no string list attribs");
86429:     NS_ASSERTION(aAttrEnum < info.mStringListCount, "aAttrEnum out of range");
86429: 
90227:     name = *info.mStringListInfo[aAttrEnum].mName;
90227:     newValue.SetTo(info.mStringLists[aAttrEnum], nsnull);
90227:   }
90227: 
90227:   DidChangeValue(name, aEmptyOrOldValue, newValue);
90227: 
90227:   if (aIsConditionalProcessingAttribute) {
90227:     tests->MaybeInvalidate();
90227:   }
86429: }
86429: 
86429: void
86429: nsSVGElement::StringListAttributesInfo::Reset(PRUint8 aAttrEnum)
86429: {
86429:   mStringLists[aAttrEnum].Clear();
86429:   // caller notifies
86429: }
86429: 
15523: nsresult
    1: nsSVGElement::ReportAttributeParseFailure(nsIDocument* aDocument,
    1:                                           nsIAtom* aAttribute,
    1:                                           const nsAString& aValue)
    1: {
    1:   const nsAFlatString& attributeValue = PromiseFlatString(aValue);
39101:   const PRUnichar *strings[] = { aAttribute->GetUTF16String(),
39101:                                  attributeValue.get() };
    1:   return nsSVGUtils::ReportToConsole(aDocument,
    1:                                      "AttributeParseWarning",
80467:                                      strings, ArrayLength(strings));
    1: }
    1: 
    1: void
    1: nsSVGElement::RecompileScriptEventListeners()
    1: {
    1:   PRInt32 i, count = mAttrsAndChildren.AttrCount();
    1:   for (i = 0; i < count; ++i) {
    1:     const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
    1: 
    1:     // Eventlistenener-attributes are always in the null namespace
    1:     if (!name->IsAtom()) {
    1:         continue;
    1:     }
    1: 
    1:     nsIAtom *attr = name->Atom();
    1:     if (!IsEventName(attr)) {
    1:       continue;
    1:     }
    1: 
    1:     nsAutoString value;
    1:     GetAttr(kNameSpaceID_None, attr, value);
80486:     AddScriptEventListener(GetEventNameForAttr(attr), value, true);
    1:   }
    1: }
23697: 
23697: nsISMILAttr*
55139: nsSVGElement::GetAnimatedAttr(PRInt32 aNamespaceID, nsIAtom* aName)
23697: {
55139:   if (aNamespaceID == kNameSpaceID_None) {
23931:     // Transforms:
78865:     if (GetTransformListAttrName() == aName) {
78865:       SVGAnimatedTransformList* transformList = GetAnimatedTransformList();
78865:       return transformList ?  transformList->ToSMILAttr(this) : nsnull;
23931:     }
23931: 
41504:     // Motion (fake 'attribute' for animateMotion)
41504:     if (aName == nsGkAtoms::mozAnimateMotionDummyAttr) {
48193:       return new SVGMotionSMILAttr(this);
41504:     }
41504: 
23697:     // Lengths:
23697:     LengthAttributesInfo info = GetLengthInfo();
23697:     for (PRUint32 i = 0; i < info.mLengthCount; i++) {
23697:       if (aName == *info.mLengthInfo[i].mName) {
23697:         return info.mLengths[i].ToSMILAttr(this);
23697:       }
23697:     }
23697: 
37220:     // Numbers:
37220:     {
37220:       NumberAttributesInfo info = GetNumberInfo();
37220:       for (PRUint32 i = 0; i < info.mNumberCount; i++) {
37220:         if (aName == *info.mNumberInfo[i].mName) {
37220:           return info.mNumbers[i].ToSMILAttr(this);
37220:         }
37220:       }
37220:     }
37220: 
72919:     // Number Pairs:
72919:     {
72919:       NumberPairAttributesInfo info = GetNumberPairInfo();
72919:       for (PRUint32 i = 0; i < info.mNumberPairCount; i++) {
72919:         if (aName == *info.mNumberPairInfo[i].mName) {
72919:           return info.mNumberPairs[i].ToSMILAttr(this);
72919:         }
72919:       }
72919:     }
72919: 
38297:     // Integers:
38297:     {
38297:       IntegerAttributesInfo info = GetIntegerInfo();
38297:       for (PRUint32 i = 0; i < info.mIntegerCount; i++) {
38297:         if (aName == *info.mIntegerInfo[i].mName) {
38297:           return info.mIntegers[i].ToSMILAttr(this);
38297:         }
38297:       }
38297:     }
38297: 
72919:     // Integer Pairs:
72919:     {
72919:       IntegerPairAttributesInfo info = GetIntegerPairInfo();
72919:       for (PRUint32 i = 0; i < info.mIntegerPairCount; i++) {
72919:         if (aName == *info.mIntegerPairInfo[i].mName) {
72919:           return info.mIntegerPairs[i].ToSMILAttr(this);
72919:         }
72919:       }
72919:     }
72919: 
37442:     // Enumerations:
37442:     {
37442:       EnumAttributesInfo info = GetEnumInfo();
37442:       for (PRUint32 i = 0; i < info.mEnumCount; i++) {
37442:         if (aName == *info.mEnumInfo[i].mName) {
37442:           return info.mEnums[i].ToSMILAttr(this);
37442:         }
37442:       }
37442:     }
37442: 
37456:     // Booleans:
37456:     {
37456:       BooleanAttributesInfo info = GetBooleanInfo();
37456:       for (PRUint32 i = 0; i < info.mBooleanCount; i++) {
37456:         if (aName == *info.mBooleanInfo[i].mName) {
37456:           return info.mBooleans[i].ToSMILAttr(this);
37456:         }
37456:       }
37456:     }
37456: 
38295:     // Angles:
38295:     {
38295:       AngleAttributesInfo info = GetAngleInfo();
38295:       for (PRUint32 i = 0; i < info.mAngleCount; i++) {
38295:         if (aName == *info.mAngleInfo[i].mName) {
38295:           return info.mAngles[i].ToSMILAttr(this);
38295:         }
38295:       }
38295:     }
38295: 
38296:     // viewBox:
38296:     if (aName == nsGkAtoms::viewBox) {
38296:       nsSVGViewBox *viewBox = GetViewBox();
38296:       return viewBox ? viewBox->ToSMILAttr(this) : nsnull;
38296:     }
38296: 
37974:     // preserveAspectRatio:
37974:     if (aName == nsGkAtoms::preserveAspectRatio) {
59470:       SVGAnimatedPreserveAspectRatio *preserveAspectRatio =
59470:         GetPreserveAspectRatio();
59470:       return preserveAspectRatio ?
59470:         preserveAspectRatio->ToSMILAttr(this) : nsnull;
37974:     }
37974: 
58554:     // NumberLists:
58554:     {
58554:       NumberListAttributesInfo info = GetNumberListInfo();
58554:       for (PRUint32 i = 0; i < info.mNumberListCount; i++) {
58554:         if (aName == *info.mNumberListInfo[i].mName) {
58554:           NS_ABORT_IF_FALSE(i <= UCHAR_MAX, "Too many attributes");
58554:           return info.mNumberLists[i].ToSMILAttr(this, PRUint8(i));
58554:         }
58554:       }
58554:     }
58554: 
47840:     // LengthLists:
47840:     {
47840:       LengthListAttributesInfo info = GetLengthListInfo();
47840:       for (PRUint32 i = 0; i < info.mLengthListCount; i++) {
47840:         if (aName == *info.mLengthListInfo[i].mName) {
47840:           NS_ABORT_IF_FALSE(i <= UCHAR_MAX, "Too many attributes");
47840:           return info.mLengthLists[i].ToSMILAttr(this,
47840:                                                  PRUint8(i),
47840:                                                  info.mLengthListInfo[i].mAxis,
47840:                                                  info.mLengthListInfo[i].mCouldZeroPadList);
47840:         }
47840:       }
47840:     }
47840: 
58893:     // PointLists:
58893:     {
58893:       if (GetPointListAttrName() == aName) {
58893:         SVGAnimatedPointList *pointList = GetAnimatedPointList();
58893:         if (pointList) {
58893:           return pointList->ToSMILAttr(this);
58893:         }
58893:       }
58893:     }
58893: 
57113:     // PathSegLists:
57113:     {
57113:       if (GetPathDataAttrName() == aName) {
57113:         SVGAnimatedPathSegList *segList = GetAnimPathSegList();
57113:         if (segList) {
57113:           return segList->ToSMILAttr(this);
57113:         }
57113:       }
57113:     }
57113: 
39488:     // Mapped attributes:
39488:     if (IsAttributeMapped(aName)) {
52031:       nsCSSProperty prop =
52031:         nsCSSProps::LookupProperty(nsDependentAtomString(aName));
39488:       // Check IsPropertyAnimatable to avoid attributes that...
39488:       //  - map to explicitly unanimatable properties (e.g. 'direction')
39488:       //  - map to unsupported attributes (e.g. 'glyph-orientation-horizontal')
39488:       if (nsSMILCSSProperty::IsPropertyAnimatable(prop)) {
39488:         return new nsSMILMappedAttribute(prop, this);
39488:       }
39488:     }
64109:   }
64109: 
64109:   // Strings
64109:   {
64109:     StringAttributesInfo info = GetStringInfo();
64109:     for (PRUint32 i = 0; i < info.mStringCount; i++) {
64109:       if (aNamespaceID == info.mStringInfo[i].mNamespaceID &&
64109:           aName == *info.mStringInfo[i].mName) {
64109:         return info.mStrings[i].ToSMILAttr(this);
64109:       }
64109:     }
64109:   }
39488: 
23697:   return nsnull;
23697: }
24029: 
24029: void
24029: nsSVGElement::AnimationNeedsResample()
24029: {
24029:   nsIDocument* doc = GetCurrentDoc();
38869:   if (doc && doc->HasAnimationController()) {
38869:     doc->GetAnimationController()->SetResampleNeeded();
24029:   }
24029: }
24029: 
24029: void
24029: nsSVGElement::FlushAnimations()
24029: {
24029:   nsIDocument* doc = GetCurrentDoc();
38869:   if (doc && doc->HasAnimationController()) {
38869:     doc->GetAnimationController()->FlushResampleRequests();
24029:   }
24029: }
