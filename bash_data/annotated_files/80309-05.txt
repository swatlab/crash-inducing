    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the nsSessionStore component.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Simon Bünzli <zeniko@gmail.com>
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
10092:  *   Dietrich Ayala <dietrich@mozilla.com>
21242:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
55806:  *   Michael Kraft <morac99-firefox2@yahoo.com>
27669:  *   Paul O’Shannessy <paul@oshannessy.com>
30959:  *   Nils Maier <maierman@web.de>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /**
    1:  * Session Storage and Restoration
    1:  * 
    1:  * Overview
    1:  * This service keeps track of a user's session, storing the various bits
20072:  * required to return the browser to its current state. The relevant data is 
    1:  * stored in memory, and is periodically saved to disk in a file in the 
    1:  * profile directory. The service is started at first window load, in
    1:  * delayedStartup, and will restore the session from the data received from
    1:  * the nsSessionStartup service.
    1:  */
    1: 
    1: /* :::::::: Constants and Helpers ::::::::::::::: */
    1: 
    1: const Cc = Components.classes;
    1: const Ci = Components.interfaces;
    1: const Cr = Components.results;
 5152: const Cu = Components.utils;
    1: 
    1: const STATE_STOPPED = 0;
    1: const STATE_RUNNING = 1;
    1: const STATE_QUITTING = -1;
    1: 
    1: const STATE_STOPPED_STR = "stopped";
    1: const STATE_RUNNING_STR = "running";
    1: 
55807: const TAB_STATE_NEEDS_RESTORE = 1;
55807: const TAB_STATE_RESTORING = 2;
55807: 
    1: const PRIVACY_NONE = 0;
    1: const PRIVACY_ENCRYPTED = 1;
    1: const PRIVACY_FULL = 2;
    1: 
10182: const NOTIFY_WINDOWS_RESTORED = "sessionstore-windows-restored";
34612: const NOTIFY_BROWSER_STATE_RESTORED = "sessionstore-browser-state-restored";
10182: 
76378: // Maximum number of tabs to restore simultaneously. Previously controlled by
76378: // the browser.sessionstore.max_concurrent_tabs pref.
76378: const MAX_CONCURRENT_TAB_RESTORES = 3;
76378: 
    1: // global notifications observed
    1: const OBSERVING = [
    1:   "domwindowopened", "domwindowclosed",
    1:   "quit-application-requested", "quit-application-granted",
30959:   "browser-lastwindow-close-granted",
21242:   "quit-application", "browser:purge-session-history",
24996:   "private-browsing", "browser:purge-domain-data",
24996:   "private-browsing-change-granted"
    1: ];
    1: 
    1: /*
    1: XUL Window properties to (re)store
 6431: Restored in restoreDimensions()
    1: */
    1: const WINDOW_ATTRIBUTES = ["width", "height", "screenX", "screenY", "sizemode"];
    1: 
    1: /* 
    1: Hideable window features to (re)store
    1: Restored in restoreWindowFeatures()
    1: */
    1: const WINDOW_HIDEABLE_FEATURES = [
    1:   "menubar", "toolbar", "locationbar", 
    1:   "personalbar", "statusbar", "scrollbars"
    1: ];
    1: 
    1: /*
    1: docShell capabilities to (re)store
    1: Restored in restoreHistory()
    1: eg: browser.docShell["allow" + aCapability] = false;
28793: 
28793: XXX keep these in sync with all the attributes starting
28793:     with "allow" in /docshell/base/nsIDocShell.idl
    1: */
    1: const CAPABILITIES = [
28793:   "Subframes", "Plugins", "Javascript", "MetaRedirects", "Images",
72454:   "DNSPrefetch", "Auth", "WindowControl"
    1: ];
    1: 
43419: // These keys are for internal use only - they shouldn't be part of the JSON
43419: // that gets saved to disk nor part of the strings returned by the API.
72193: const INTERNAL_KEYS = ["_tabStillLoading", "_hosts", "_formDataSaved",
74495:                        "_shouldRestore", "_host", "_scheme"];
43419: 
54279: // These are tab events that we listen to.
60684: const TAB_EVENTS = ["TabOpen", "TabClose", "TabSelect", "TabShow", "TabHide",
60684:                     "TabPinned", "TabUnpinned"];
54279: 
34827: #ifndef XP_WIN
34827: #define BROKEN_WM_Z_ORDER
34827: #endif
34827: 
 9672: Cu.import("resource://gre/modules/XPCOMUtils.jsm");
39650: Cu.import("resource://gre/modules/Services.jsm");
74262: // debug.js adds NS_ASSERT. cf. bug 669196
74262: Cu.import("resource://gre/modules/debug.js");
    1: 
36318: XPCOMUtils.defineLazyGetter(this, "NetUtil", function() {
31302:   Cu.import("resource://gre/modules/NetUtil.jsm");
31302:   return NetUtil;
31302: });
31302: 
36318: XPCOMUtils.defineLazyServiceGetter(this, "CookieSvc",
36318:   "@mozilla.org/cookiemanager;1", "nsICookieManager2");
36318: 
36318: #ifdef MOZ_CRASH_REPORTER
36318: XPCOMUtils.defineLazyServiceGetter(this, "CrashReporter",
36318:   "@mozilla.org/xre/app-info;1", "nsICrashReporter");
36318: #endif
36318: 
36318: XPCOMUtils.defineLazyServiceGetter(this, "SecuritySvc",
36318:   "@mozilla.org/scriptsecuritymanager;1", "nsIScriptSecurityManager");
36318: 
36318: function debug(aMsg) {
36318:   aMsg = ("SessionStore: " + aMsg).replace(/\S{80}/g, "$&\n");
39650:   Services.console.logStringMessage(aMsg);
36318: }
36318: 
    1: /* :::::::: The Service ::::::::::::::: */
    1: 
    1: function SessionStoreService() {
63914:   XPCOMUtils.defineLazyGetter(this, "_prefBranch", function () {
63914:     return Cc["@mozilla.org/preferences-service;1"].
63914:            getService(Ci.nsIPrefService).getBranch("browser.").
63914:            QueryInterface(Ci.nsIPrefBranch2);
63914:   });
63914: 
63914:   // minimal interval between two save operations (in milliseconds)
63914:   XPCOMUtils.defineLazyGetter(this, "_interval", function () {
63914:     // used often, so caching/observing instead of fetching on-demand
63914:     this._prefBranch.addObserver("sessionstore.interval", this, true);
63914:     return this._prefBranch.getIntPref("sessionstore.interval");
63914:   });
63914: 
63914:   // when crash recovery is disabled, session data is not written to disk
63914:   XPCOMUtils.defineLazyGetter(this, "_resume_from_crash", function () {
63914:     // get crash recovery state from prefs and allow for proper reaction to state changes
63914:     this._prefBranch.addObserver("sessionstore.resume_from_crash", this, true);
63914:     return this._prefBranch.getBoolPref("sessionstore.resume_from_crash");
63914:   });
    1: }
    1: 
    1: SessionStoreService.prototype = {
 9672:   classID: Components.ID("{5280606b-2510-4fe0-97ef-9b5a22eafe6b}"),
 9672:   QueryInterface: XPCOMUtils.generateQI([Ci.nsISessionStore,
 9672:                                          Ci.nsIDOMEventListener,
 9672:                                          Ci.nsIObserver,
 9672:                                          Ci.nsISupportsWeakReference]),
    1: 
20315:   // xul:tab attributes to (re)store (extensions might want to hook in here);
20315:   // the favicon is always saved for the about:sessionrestore page
74566:   xulAttributes: {"image": true},
    1: 
    1:   // set default load state
    1:   _loadState: STATE_STOPPED,
    1: 
34612:   // During the initial restore and setBrowserState calls tracks the number of
34612:   // windows yet to be restored
76365:   _restoreCount: -1,
10182: 
34612:   // whether a setBrowserState call is in progress
34612:   _browserSetState: false,
34612: 
    1:   // time in milliseconds (Date.now()) when the session was last written to file
    1:   _lastSaveTime: 0,
    1: 
72191:   // time in milliseconds when the session was started (saved across sessions),
72191:   // defaults to now if no session was restored or timestamp doesn't exist
72191:   _sessionStartTime: Date.now(),
72191: 
    1:   // states for all currently opened windows
    1:   _windows: {},
    1: 
27669:   // states for all recently closed windows
27669:   _closedWindows: [],
    1: 
    1:   // not-"dirty" windows usually don't need to have their data updated
    1:   _dirtyWindows: {},
    1: 
25810:   // collection of session states yet to be restored
25810:   _statesToRestore: {},
25810: 
20315:   // counts the number of crashes since the last clean start
20315:   _recentCrashes: 0,
20315: 
21242:   // whether we are in private browsing mode
21242:   _inPrivateBrowsing: false,
21242: 
30959:   // whether the last window was closed and should be restored
30959:   _restoreLastWindow: false,
30959: 
54279:   // tabs to restore in order
77573:   _tabsToRestore: { priority: [], visible: [], hidden: [] },
54279:   _tabsRestoringCount: 0,
54279: 
76378:   // overrides MAX_CONCURRENT_TAB_RESTORES and _restoreHiddenTabs when true
76378:   _restoreOnDemand: false,
54279: 
70123:   // whether to restore hidden tabs or not, pref controlled.
70123:   _restoreHiddenTabs: null,
70123: 
74895:   // The state from the previous session (after restoring pinned tabs). This
74895:   // state is persisted and passed through to the next session during an app
74895:   // restart to make the third party add-on warning not trash the deferred
74895:   // session
52403:   _lastSessionState: null,
52403: 
54913:   // Whether we've been initialized
54913:   _initialized: false,
54913: 
55806:   // The original "sessionstore.resume_session_once" preference value before it
55806:   // was modified by saveState.  saveState will set the
55806:   // "sessionstore.resume_session_once" to true when the
55806:   // the "sessionstore.resume_from_crash" preference is false (crash recovery
55806:   // is disabled) so that pinned tabs will be restored in the case of a
55806:   // crash.  This variable is used to restore the original value so the
55806:   // previous session is not always restored when
55806:   // "sessionstore.resume_from_crash" is true.
55806:   _resume_session_once_on_shutdown: null,
55806: 
52403: /* ........ Public Getters .............. */
52403: 
52403:   get canRestoreLastSession() {
52403:     // Always disallow restoring the previous session when in private browsing
52403:     return this._lastSessionState && !this._inPrivateBrowsing;
52403:   },
52403: 
52403:   set canRestoreLastSession(val) {
52403:     // Cheat a bit; only allow false.
52403:     if (val)
52403:       return;
52403:     this._lastSessionState = null;
52403:   },
52403: 
    1: /* ........ Global Event Handlers .............. */
    1: 
    1:   /**
    1:    * Initialize the component
    1:    */
54913:   initService: function() {
    1:     OBSERVING.forEach(function(aTopic) {
39650:       Services.obs.addObserver(this, aTopic, true);
    1:     }, this);
    1: 
34263:     var pbs = Cc["@mozilla.org/privatebrowsing;1"].
34263:               getService(Ci.nsIPrivateBrowsingService);
34263:     this._inPrivateBrowsing = pbs.privateBrowsingEnabled;
21242: 
76378:     // Do pref migration before we store any values and start observing changes
76378:     this._migratePrefs();
76378: 
    1:     // observe prefs changes so we can modify stored data to match
    1:     this._prefBranch.addObserver("sessionstore.max_tabs_undo", this, true);
27669:     this._prefBranch.addObserver("sessionstore.max_windows_undo", this, true);
    1:     
25194:     // this pref is only read at startup, so no need to observe it
25194:     this._sessionhistory_max_entries =
25194:       this._prefBranch.getIntPref("sessionhistory.max_entries");
25194: 
76378:     this._restoreOnDemand =
76378:       this._prefBranch.getBoolPref("sessionstore.restore_on_demand");
76378:     this._prefBranch.addObserver("sessionstore.restore_on_demand", this, true);
54279: 
70123:     this._restoreHiddenTabs =
70123:       this._prefBranch.getBoolPref("sessionstore.restore_hidden_tabs");
70123:     this._prefBranch.addObserver("sessionstore.restore_hidden_tabs", this, true);
70123: 
54279:     // Make sure gRestoreTabsProgressListener has a reference to sessionstore
54279:     // so that it can make calls back in
54279:     gRestoreTabsProgressListener.ss = this;
54279: 
    1:     // get file references
39650:     this._sessionFile = Services.dirsvc.get("ProfD", Ci.nsILocalFile);
    1:     this._sessionFileBackup = this._sessionFile.clone();
    1:     this._sessionFile.append("sessionstore.js");
    1:     this._sessionFileBackup.append("sessionstore.bak");
    1: 
    1:     // get string containing session state
    1:     var ss = Cc["@mozilla.org/browser/sessionstartup;1"].
    1:              getService(Ci.nsISessionStartup);
52403:     try {
52403:       if (ss.doRestore() ||
52403:           ss.sessionType == Ci.nsISessionStartup.DEFER_SESSION)
73919:         this._initialState = ss.state;
    1:     }
    1:     catch(ex) { dump(ex + "\n"); } // no state to restore, which is ok
    1: 
73919:     if (this._initialState) {
    1:       try {
52403:         // If we're doing a DEFERRED session, then we want to pull pinned tabs
52403:         // out so they can be restored.
52403:         if (ss.sessionType == Ci.nsISessionStartup.DEFER_SESSION) {
73919:           let [iniState, remainingState] = this._prepDataForDeferredRestore(this._initialState);
52403:           // If we have a iniState with windows, that means that we have windows
52403:           // with app tabs to restore.
52403:           if (iniState.windows.length)
52403:             this._initialState = iniState;
73919:           else
73919:             this._initialState = null;
52403:           if (remainingState.windows.length)
52403:             this._lastSessionState = remainingState;
52403:         }
52403:         else {
74895:           // Get the last deferred session in case the user still wants to
74895:           // restore it
74895:           this._lastSessionState = this._initialState.lastSessionState;
74895: 
18927:           let lastSessionCrashed =
    1:             this._initialState.session && this._initialState.session.state &&
    1:             this._initialState.session.state == STATE_RUNNING_STR;
18927:           if (lastSessionCrashed) {
20315:             this._recentCrashes = (this._initialState.session &&
20315:                                    this._initialState.session.recentCrashes || 0) + 1;
20315:             
25810:             if (this._needsRestorePage(this._initialState, this._recentCrashes)) {
20315:               // replace the crashed session with a restore-page-only session
25810:               let pageData = {
25810:                 url: "about:sessionrestore",
73919:                 formdata: { "#sessionData": JSON.stringify(this._initialState) }
25810:               };
25810:               this._initialState = { windows: [{ tabs: [{ entries: [pageData] }] }] };
25810:             }
18927:           }
    1: 
72191:           // Load the session start time from the previous state
72191:           this._sessionStartTime = this._initialState.session &&
72191:                                    this._initialState.session.startTime ||
72191:                                    this._sessionStartTime;
72191: 
16425:           // make sure that at least the first window doesn't have anything hidden
    1:           delete this._initialState.windows[0].hidden;
33956:           // Since nothing is hidden in the first window, it cannot be a popup
33956:           delete this._initialState.windows[0].isPopup;
76364:           // We don't want to minimize and then open a window at startup.
76364:           if (this._initialState.windows[0].sizemode == "minimized")
76364:             this._initialState.windows[0].sizemode = "normal";
    1:         }
52403:       }
    1:       catch (ex) { debug("The session file is invalid: " + ex); }
    1:     }
    1: 
51017:     if (this._resume_from_crash) {
51017:       // create a backup if the session data file exists
21042:       try {
21042:         if (this._sessionFileBackup.exists())
21042:           this._sessionFileBackup.remove(false);
21042:         if (this._sessionFile.exists())
21042:           this._sessionFile.copyTo(null, this._sessionFileBackup.leafName);
21042:       }
21042:       catch (ex) { Cu.reportError(ex); } // file was write-locked?
21042:     }
    1: 
18841:     // at this point, we've as good as resumed the session, so we can
18841:     // clear the resume_session_once flag, if it's set
18841:     if (this._loadState != STATE_QUITTING &&
18841:         this._prefBranch.getBoolPref("sessionstore.resume_session_once"))
18841:       this._prefBranch.setBoolPref("sessionstore.resume_session_once", false);
18841: 
54913:     this._initialized = true;
54913:   },
54913: 
54913:   /**
54913:    * Start tracking a window.
58256:    * This function also initializes the component if it's not already
58256:    * initialized.
54913:    */
54913:   init: function sss_init(aWindow) {
58256:     // Initialize the service if needed.
58256:     if (!this._initialized)
58256:       this.initService();
58256: 
54913:     if (!aWindow || this._loadState == STATE_RUNNING) {
54913:       // make sure that all browser windows which try to initialize
54913:       // SessionStore are really tracked by it
54913:       if (aWindow && (!aWindow.__SSi || !this._windows[aWindow.__SSi]))
54913:         this.onLoad(aWindow);
54913:       // If init is being called with a null window, it's possible that we
54913:       // just want to tell sessionstore that a session is live (as is the case
54913:       // with starting Firefox with -private, for example; see bug 568816),
54913:       // so we should mark the load state as running to make sure that
54913:       // things like setBrowserState calls will succeed in restoring the session.
54913:       if (!aWindow && this._loadState == STATE_STOPPED)
54913:         this._loadState = STATE_RUNNING;
54913:       return;
54913:     }
54913: 
    1:     // As this is called at delayedStartup, restoration must be initiated here
    1:     this.onLoad(aWindow);
    1:   },
    1: 
    1:   /**
    1:    * Called on application shutdown, after notifications:
    1:    * quit-application-granted, quit-application
    1:    */
    1:   _uninit: function sss_uninit() {
51017:     // save all data for session resuming
    1:     this.saveState(true);
51017: 
54279:     // clear out _tabsToRestore in case it's still holding refs
77573:     this._tabsToRestore.priority = null;
54279:     this._tabsToRestore.visible = null;
54279:     this._tabsToRestore.hidden = null;
54279: 
54279:     // remove the ref to us from the progress listener
54279:     gRestoreTabsProgressListener.ss = null;
54279: 
    1:     // Make sure to break our cycle with the save timer
    1:     if (this._saveTimer) {
    1:       this._saveTimer.cancel();
    1:       this._saveTimer = null;
    1:     }
    1:   },
    1: 
76378:   _migratePrefs: function sss__migratePrefs() {
76378:     // Added For Firefox 8
76378:     // max_concurrent_tabs is going away. We're going to hard code a max value
76378:     // (MAX_CONCURRENT_TAB_RESTORES) and start using a boolean pref restore_on_demand.
76378:     if (this._prefBranch.prefHasUserValue("sessionstore.max_concurrent_tabs") &&
76378:         !this._prefBranch.prefHasUserValue("sessionstore.restore_on_demand")) {
76378:       let maxConcurrentTabs =
76378:         this._prefBranch.getIntPref("sessionstore.max_concurrent_tabs");
76378:       this._prefBranch.setBoolPref("sessionstore.restore_on_demand", maxConcurrentTabs == 0);
76378:       this._prefBranch.clearUserPref("sessionstore.max_concurrent_tabs");
76378:     }
76378:   },
76378: 
    1:   /**
    1:    * Handle notifications
    1:    */
    1:   observe: function sss_observe(aSubject, aTopic, aData) {
    1:     // for event listeners
    1:     var _this = this;
    1: 
    1:     switch (aTopic) {
    1:     case "domwindowopened": // catch new windows
    1:       aSubject.addEventListener("load", function(aEvent) {
    1:         aEvent.currentTarget.removeEventListener("load", arguments.callee, false);
    1:         _this.onLoad(aEvent.currentTarget);
    1:       }, false);
    1:       break;
    1:     case "domwindowclosed": // catch closed windows
    1:       this.onClose(aSubject);
    1:       break;
    1:     case "quit-application-requested":
    1:       // get a current snapshot of all windows
    1:       this._forEachBrowserWindow(function(aWindow) {
    1:         this._collectWindowData(aWindow);
    1:       });
77866:       // we must cache this because _getMostRecentBrowserWindow will always
77866:       // return null by the time quit-application occurs
77866:       var activeWindow = this._getMostRecentBrowserWindow();
77866:       if (activeWindow)
77866:         this.activeWindowSSiCache = activeWindow.__SSi || "";
    1:       this._dirtyWindows = [];
    1:       break;
    1:     case "quit-application-granted":
    1:       // freeze the data at what we've got (ignoring closing windows)
    1:       this._loadState = STATE_QUITTING;
    1:       break;
30959:     case "browser-lastwindow-close-granted":
30959:       // last browser window is quitting.
51017:       // remember to restore the last window when another browser window is opened
30959:       // do not account for pref(resume_session_once) at this point, as it might be
30959:       // set by another observer getting this notice after us
30959:       this._restoreLastWindow = true;
30959:       break;
    1:     case "quit-application":
28642:       if (aData == "restart") {
    1:         this._prefBranch.setBoolPref("sessionstore.resume_session_once", true);
60650:         // The browser:purge-session-history notification fires after the
60650:         // quit-application notification so unregister the
60650:         // browser:purge-session-history notification to prevent clearing
60650:         // session data on disk on a restart.  It is also unnecessary to
60650:         // perform any other sanitization processing on a restart as the
60650:         // browser is about to exit anyway.
60650:         Services.obs.removeObserver(this, "browser:purge-session-history");
28642:       }
55806:       else if (this._resume_session_once_on_shutdown != null) {
55806:         // if the sessionstore.resume_session_once preference was changed by
55806:         // saveState because crash recovery is disabled then restore the
55806:         // preference back to the value it was prior to that.  This will prevent
55806:         // SessionStore from always restoring the session when crash recovery is
55806:         // disabled.
55806:         this._prefBranch.setBoolPref("sessionstore.resume_session_once",
55806:                                      this._resume_session_once_on_shutdown);
55806:       }
74895: 
74895:       if (aData != "restart") {
74895:         // Throw away the previous session on shutdown
74895:         this._lastSessionState = null;
74895:       }
74895: 
    1:       this._loadState = STATE_QUITTING; // just to be sure
    1:       this._uninit();
    1:       break;
    1:     case "browser:purge-session-history": // catch sanitization 
60650:       this._clearDisk();
60650:       // If the browser is shutting down, simply return after clearing the
60650:       // session data on disk as this notification fires after the
60650:       // quit-application notification so the browser is about to exit.
60650:       if (this._loadState == STATE_QUITTING)
60650:         return;
74564:       this._lastSessionState = null;
18959:       let openWindows = {};
    1:       this._forEachBrowserWindow(function(aWindow) {
55807:         Array.forEach(aWindow.gBrowser.tabs, function(aTab) {
55807:           delete aTab.linkedBrowser.__SS_data;
55807:           if (aTab.linkedBrowser.__SS_restoreState)
55807:             this._resetTabRestoringState(aTab);
    1:         });
18959:         openWindows[aWindow.__SSi] = true;
    1:       });
18959:       // also clear all data about closed tabs and windows
25366:       for (let ix in this._windows) {
18959:         if (ix in openWindows)
18959:           this._windows[ix]._closedTabs = [];
18959:         else
18959:           delete this._windows[ix];
18959:       }
27669:       // also clear all data about closed windows
27669:       this._closedWindows = [];
    1:       // give the tabbrowsers a chance to clear their histories first
    1:       var win = this._getMostRecentBrowserWindow();
    1:       if (win)
    1:         win.setTimeout(function() { _this.saveState(true); }, 0);
18959:       else if (this._loadState == STATE_RUNNING)
    1:         this.saveState(true);
21419:       // Delete the private browsing backed up state, if any
21419:       if ("_stateBackup" in this)
21419:         delete this._stateBackup;
72193: 
72193:       this._clearRestoringWindows();
    1:       break;
24094:     case "browser:purge-domain-data":
24094:       // does a session history entry contain a url for the given domain?
24094:       function containsDomain(aEntry) {
24094:         try {
24094:           if (this._getURIFromString(aEntry.url).host.hasRootDomain(aData))
24094:             return true;
24094:         }
24094:         catch (ex) { /* url had no host at all */ }
24094:         return aEntry.children && aEntry.children.some(containsDomain, this);
24094:       }
24094:       // remove all closed tabs containing a reference to the given domain
24094:       for (let ix in this._windows) {
24094:         let closedTabs = this._windows[ix]._closedTabs;
24094:         for (let i = closedTabs.length - 1; i >= 0; i--) {
24094:           if (closedTabs[i].state.entries.some(containsDomain, this))
24094:             closedTabs.splice(i, 1);
24094:         }
24094:       }
27669:       // remove all open & closed tabs containing a reference to the given
27669:       // domain in closed windows
27669:       for (let ix = this._closedWindows.length - 1; ix >= 0; ix--) {
27669:         let closedTabs = this._closedWindows[ix]._closedTabs;
27669:         let openTabs = this._closedWindows[ix].tabs;
27669:         let openTabCount = openTabs.length;
27669:         for (let i = closedTabs.length - 1; i >= 0; i--)
27669:           if (closedTabs[i].state.entries.some(containsDomain, this))
27669:             closedTabs.splice(i, 1);
27669:         for (let j = openTabs.length - 1; j >= 0; j--) {
27669:           if (openTabs[j].entries.some(containsDomain, this)) {
27669:             openTabs.splice(j, 1);
27669:             if (this._closedWindows[ix].selected > j)
27669:               this._closedWindows[ix].selected--;
27669:           }
27669:         }
27669:         if (openTabs.length == 0) {
27669:           this._closedWindows.splice(ix, 1);
27669:         }
27669:         else if (openTabs.length != openTabCount) {
27669:           // Adjust the window's title if we removed an open tab
27669:           let selectedTab = openTabs[this._closedWindows[ix].selected - 1];
27669:           // some duplication from restoreHistory - make sure we get the correct title
27669:           let activeIndex = (selectedTab.index || selectedTab.entries.length) - 1;
27669:           if (activeIndex >= selectedTab.entries.length)
27669:             activeIndex = selectedTab.entries.length - 1;
27669:           this._closedWindows[ix].title = selectedTab.entries[activeIndex].title;
27669:         }
27669:       }
24094:       if (this._loadState == STATE_RUNNING)
24094:         this.saveState(true);
72193: 
72193:       this._clearRestoringWindows();
24094:       break;
    1:     case "nsPref:changed": // catch pref changes
    1:       switch (aData) {
    1:       // if the user decreases the max number of closed tabs they want
    1:       // preserved update our internal states to match that max
    1:       case "sessionstore.max_tabs_undo":
25366:         for (let ix in this._windows) {
78670:           this._windows[ix]._closedTabs.splice(this._prefBranch.getIntPref("sessionstore.max_tabs_undo"), this._windows[ix]._closedTabs.length);
    1:         }
    1:         break;
27669:       case "sessionstore.max_windows_undo":
27669:         this._capClosedWindows();
27669:         break;
    1:       case "sessionstore.interval":
    1:         this._interval = this._prefBranch.getIntPref("sessionstore.interval");
    1:         // reset timer and save
    1:         if (this._saveTimer) {
    1:           this._saveTimer.cancel();
    1:           this._saveTimer = null;
    1:         }
    1:         this.saveStateDelayed(null, -1);
    1:         break;
    1:       case "sessionstore.resume_from_crash":
 3455:         this._resume_from_crash = this._prefBranch.getBoolPref("sessionstore.resume_from_crash");
55806:         // restore original resume_session_once preference if set in saveState
55806:         if (this._resume_session_once_on_shutdown != null) {
55806:           this._prefBranch.setBoolPref("sessionstore.resume_session_once",
55806:                                        this._resume_session_once_on_shutdown);
55806:           this._resume_session_once_on_shutdown = null;
55806:         }
    1:         // either create the file with crash recovery information or remove it
    1:         // (when _loadState is not STATE_RUNNING, that file is used for session resuming instead)
51017:         if (!this._resume_from_crash)
51017:           this._clearDisk();
50886:         this.saveState(true);
    1:         break;
76378:       case "sessionstore.restore_on_demand":
76378:         this._restoreOnDemand =
76378:           this._prefBranch.getBoolPref("sessionstore.restore_on_demand");
54279:         break;
70123:       case "sessionstore.restore_hidden_tabs":
70123:         this._restoreHiddenTabs =
70123:           this._prefBranch.getBoolPref("sessionstore.restore_hidden_tabs");
70123:         break;
    1:       }
    1:       break;
    1:     case "timer-callback": // timer call back for delayed saving
    1:       this._saveTimer = null;
    1:       this.saveState();
    1:       break;
21242:     case "private-browsing":
21242:       switch (aData) {
21242:       case "enter":
21242:         this._inPrivateBrowsing = true;
21242:         break;
21242:       case "exit":
21242:         aSubject.QueryInterface(Ci.nsISupportsPRBool);
21242:         let quitting = aSubject.data;
25858:         if (quitting) {
21242:           // save the backed up state with session set to stopped,
74687:           // otherwise resuming next time would look like a crash.
74687:           // Whether we restore the session upon resume will be determined by the
74687:           // usual startup prefs, so we will have the same behavior regardless of
74687:           // whether the browser was closed while in normal or private browsing mode.
21242:           if ("_stateBackup" in this) {
21242:             var oState = this._stateBackup;
21242:             oState.session = { state: STATE_STOPPED_STR };
21242: 
21242:             this._saveStateObject(oState);
21242:           }
21242:         }
21242:         else
21242:           this._inPrivateBrowsing = false;
21242:         delete this._stateBackup;
21242:         break;
21242:       }
72193: 
72193:       this._clearRestoringWindows();
21242:       break;
24996:     case "private-browsing-change-granted":
24996:       if (aData == "enter") {
24996:         this.saveState(true);
43419:         // We stringify & parse the current state so that we have have an object
43419:         // that won't change. _getCurrentState returns an object with references
43419:         // to objects that can change (specifically this._windows[x]).
43419:         this._stateBackup = JSON.parse(this._toJSONString(this._getCurrentState(true)));
24996:       }
54279:       // Make sure _tabsToRestore is cleared. It will be repopulated when
54279:       // entering/exiting private browsing (by calls to setBrowserState).
54279:       this._resetRestoringState();
72193: 
72193:       this._clearRestoringWindows();
24996:       break;
    1:     }
    1:   },
    1: 
    1: /* ........ Window Event Handlers .............. */
    1: 
    1:   /**
    1:    * Implement nsIDOMEventListener for handling various window and tab events
    1:    */
    1:   handleEvent: function sss_handleEvent(aEvent) {
31572:     var win = aEvent.currentTarget.ownerDocument.defaultView;
    1:     switch (aEvent.type) {
    1:       case "load":
39464:         // If __SS_restore_data is set, then we need to restore the document
39464:         // (form data, scrolling, etc.). This will only happen when a tab is
39464:         // first restored.
39464:         if (aEvent.currentTarget.__SS_restore_data)
39464:           this.restoreDocument(win, aEvent.currentTarget, aEvent);
39464:         // We still need to call onTabLoad, so fall through to "pageshow" case.
    1:       case "pageshow":
31572:         this.onTabLoad(win, aEvent.currentTarget, aEvent);
    1:         break;
18836:       case "change":
    1:       case "input":
    1:       case "DOMAutoComplete":
31572:         this.onTabInput(win, aEvent.currentTarget);
    1:         break;
    1:       case "TabOpen":
54278:         this.onTabAdd(win, aEvent.originalTarget);
54278:         break;
    1:       case "TabClose":
28756:         // aEvent.detail determines if the tab was closed by moving to a different window
28756:         if (!aEvent.detail)
31572:           this.onTabClose(win, aEvent.originalTarget);
54278:         this.onTabRemove(win, aEvent.originalTarget);
    1:         break;
    1:       case "TabSelect":
31572:         this.onTabSelect(win);
    1:         break;
54279:       case "TabShow":
63109:         this.onTabShow(win, aEvent.originalTarget);
54279:         break;
54279:       case "TabHide":
63109:         this.onTabHide(win, aEvent.originalTarget);
54279:         break;
60684:       case "TabPinned":
60684:       case "TabUnpinned":
60684:         this.saveStateDelayed(win);
60684:         break;
    1:     }
72193: 
72193:     this._clearRestoringWindows();
    1:   },
    1: 
    1:   /**
    1:    * If it's the first window load since app start...
    1:    * - determine if we're reloading after a crash or a forced-restart
    1:    * - restore window state
    1:    * - restart downloads
    1:    * Set up event listeners for this window's tabs
    1:    * @param aWindow
    1:    *        Window reference
    1:    */
    1:   onLoad: function sss_onLoad(aWindow) {
    1:     // return if window has already been initialized
    1:     if (aWindow && aWindow.__SSi && this._windows[aWindow.__SSi])
    1:       return;
    1: 
    1:     // ignore non-browser windows and windows opened while shutting down
    1:     if (aWindow.document.documentElement.getAttribute("windowtype") != "navigator:browser" ||
    1:         this._loadState == STATE_QUITTING)
    1:       return;
    1: 
    1:     // assign it a unique identifier (timestamp)
68410:     aWindow.__SSi = "window" + Date.now();
    1: 
    1:     // and create its data object
76934:     this._windows[aWindow.__SSi] = { tabs: [], selected: 0, _closedTabs: [], busy: false };
35634:     if (!this._isWindowLoaded(aWindow))
35634:       this._windows[aWindow.__SSi]._restoring = true;
18833:     if (!aWindow.toolbar.visible)
18833:       this._windows[aWindow.__SSi].isPopup = true;
    1:     
    1:     // perform additional initialization when the first window is loading
    1:     if (this._loadState == STATE_STOPPED) {
    1:       this._loadState = STATE_RUNNING;
    1:       this._lastSaveTime = Date.now();
    1:       
    1:       // restore a crashed session resp. resume the last session if requested
    1:       if (this._initialState) {
    1:         // make sure that the restored tabs are first in the window
    1:         this._initialState._firstTabs = true;
10182:         this._restoreCount = this._initialState.windows ? this._initialState.windows.length : 0;
51017:         this.restoreWindow(aWindow, this._initialState,
51017:                            this._isCmdLineEmpty(aWindow, this._initialState));
    1:         delete this._initialState;
25810:         
30959:         // _loadState changed from "stopped" to "running"
30959:         // force a save operation so that crashes happening during startup are correctly counted
25810:         this.saveState(true);
    1:       }
10182:       else {
10182:         // Nothing to restore, notify observers things are complete.
39650:         Services.obs.notifyObservers(null, NOTIFY_WINDOWS_RESTORED, "");
25810:         
25810:         // the next delayed save request should execute immediately
25810:         this._lastSaveTime -= this._interval;
21413:       }
 7161:     }
25810:     // this window was opened by _openWindowWithState
25810:     else if (!this._isWindowLoaded(aWindow)) {
25810:       let followUp = this._statesToRestore[aWindow.__SS_restoreID].windows.length == 1;
25810:       this.restoreWindow(aWindow, this._statesToRestore[aWindow.__SS_restoreID], true, followUp);
25810:     }
30959:     else if (this._restoreLastWindow && aWindow.toolbar.visible &&
51017:              this._closedWindows.length &&
30959:              !this._inPrivateBrowsing) {
30959:       // default to the most-recently closed window
30959:       // don't use popup windows
57161:       let closedWindowState = null;
57161:       let closedWindowIndex;
57161:       for (let i = 0; i < this._closedWindows.length; i++) {
57161:         // Take the first non-popup, point our object at it, and break out.
57161:         if (!this._closedWindows[i].isPopup) {
57161:           closedWindowState = this._closedWindows[i];
57161:           closedWindowIndex = i;
57161:           break;
57161:         }
57161:       }
57161: 
57161:       if (closedWindowState) {
57161:         let newWindowState;
69822: #ifndef XP_MACOSX
69822:         if (!this._doResumeSession()) {
69822: #endif
57161:           // We want to split the window up into pinned tabs and unpinned tabs.
57161:           // Pinned tabs should be restored. If there are any remaining tabs,
57161:           // they should be added back to _closedWindows.
57161:           // We'll cheat a little bit and reuse _prepDataForDeferredRestore
57161:           // even though it wasn't built exactly for this.
57161:           let [appTabsState, normalTabsState] =
73919:             this._prepDataForDeferredRestore({ windows: [closedWindowState] });
57161: 
57161:           // These are our pinned tabs, which we should restore
57161:           if (appTabsState.windows.length) {
57161:             newWindowState = appTabsState.windows[0];
57161:             delete newWindowState.__lastSessionWindowID;
57161:           }
57161: 
57161:           // In case there were no unpinned tabs, remove the window from _closedWindows
57161:           if (!normalTabsState.windows.length) {
57161:             this._closedWindows.splice(closedWindowIndex, 1);
57161:           }
57161:           // Or update _closedWindows with the modified state
57161:           else {
57161:             delete normalTabsState.windows[0].__lastSessionWindowID;
57161:             this._closedWindows[closedWindowIndex] = normalTabsState.windows[0];
57161:           }
69822: #ifndef XP_MACOSX
69822:         }
69822:         else {
57161:           // If we're just restoring the window, make sure it gets removed from
57161:           // _closedWindows.
57161:           this._closedWindows.splice(closedWindowIndex, 1);
57161:           newWindowState = closedWindowState;
57161:           delete newWindowState.hidden;
69822:         }
57161: #endif
57161:         if (newWindowState) {
57161:           // Ensure that the window state isn't hidden
51017:           this._restoreCount = 1;
57161:           let state = { windows: [newWindowState] };
51017:           this.restoreWindow(aWindow, state, this._isCmdLineEmpty(aWindow, state));
51017:         }
30959:       }
30959:       // we actually restored the session just now.
30959:       this._prefBranch.setBoolPref("sessionstore.resume_session_once", false);
30959:     }
30959:     if (this._restoreLastWindow && aWindow.toolbar.visible) {
30959:       // always reset (if not a popup window)
30959:       // we don't want to restore a window directly after, for example,
30959:       // undoCloseWindow was executed.
30959:       this._restoreLastWindow = false;
30959:     }
    1: 
31572:     var tabbrowser = aWindow.gBrowser;
    1:     
    1:     // add tab change listeners to all already existing tabs
54278:     for (let i = 0; i < tabbrowser.tabs.length; i++) {
54278:       this.onTabAdd(aWindow, tabbrowser.tabs[i], true);
    1:     }
54279:     // notification of tab add/remove/selection/show/hide
54279:     TAB_EVENTS.forEach(function(aEvent) {
54279:       tabbrowser.tabContainer.addEventListener(aEvent, this, true);
54279:     }, this);
    1:   },
    1: 
    1:   /**
    1:    * On window close...
    1:    * - remove event listeners from tabs
    1:    * - save all window data
    1:    * @param aWindow
    1:    *        Window reference
    1:    */
    1:   onClose: function sss_onClose(aWindow) {
25810:     // this window was about to be restored - conserve its original data, if any
25810:     let isFullyLoaded = this._isWindowLoaded(aWindow);
25810:     if (!isFullyLoaded) {
25810:       if (!aWindow.__SSi)
68410:         aWindow.__SSi = "window" + Date.now();
39305:       this._windows[aWindow.__SSi] = this._statesToRestore[aWindow.__SS_restoreID];
25810:       delete this._statesToRestore[aWindow.__SS_restoreID];
25810:       delete aWindow.__SS_restoreID;
25810:     }
25810:     
    1:     // ignore windows not tracked by SessionStore
    1:     if (!aWindow.__SSi || !this._windows[aWindow.__SSi]) {
    1:       return;
    1:     }
    1: 
71576:     // notify that the session store will stop tracking this window so that
71576:     // extensions can store any data about this window in session store before
71576:     // that's not possible anymore
71576:     let event = aWindow.document.createEvent("Events");
71576:     event.initEvent("SSWindowClosing", true, false);
71576:     aWindow.dispatchEvent(event);
71576: 
 6431:     if (this.windowToFocus && this.windowToFocus == aWindow) {
 6431:       delete this.windowToFocus;
 6431:     }
 6431:     
31572:     var tabbrowser = aWindow.gBrowser;
    1: 
54279:     TAB_EVENTS.forEach(function(aEvent) {
54279:       tabbrowser.tabContainer.removeEventListener(aEvent, this, true);
54279:     }, this);
54279: 
54279:     // remove the progress listener for this window
54279:     tabbrowser.removeTabsProgressListener(gRestoreTabsProgressListener);
    1: 
25810:     let winData = this._windows[aWindow.__SSi];
    1:     if (this._loadState == STATE_RUNNING) { // window not closed during a regular shut-down 
    1:       // update all window data for a last time
    1:       this._collectWindowData(aWindow);
    1:       
25810:       if (isFullyLoaded) {
27669:         winData.title = aWindow.content.document.title || tabbrowser.selectedTab.label;
27669:         winData.title = this._replaceLoadingTitle(winData.title, tabbrowser,
27669:                                                   tabbrowser.selectedTab);
27669:         this._updateCookies([winData]);
25810:       }
    1: 
72193: #ifndef XP_MACOSX
72193:       // Until we decide otherwise elsewhere, this window is part of a series
72193:       // of closing windows to quit.
72193:       winData._shouldRestore = true;
72193: #endif
72193: 
61591:       // save the window if it has multiple tabs or a single saveable tab
28756:       if (winData.tabs.length > 1 ||
61591:           (winData.tabs.length == 1 && this._shouldSaveTabState(winData.tabs[0]))) {
76934:         // we don't want to save the busy state
76934:         delete winData.busy;
76934: 
27669:         this._closedWindows.unshift(winData);
27669:         this._capClosedWindows();
28756:       }
27669:       
    1:       // clear this window from the list
    1:       delete this._windows[aWindow.__SSi];
    1:       
    1:       // save the state without this window to disk
    1:       this.saveStateDelayed();
    1:     }
    1:     
54278:     for (let i = 0; i < tabbrowser.tabs.length; i++) {
54278:       this.onTabRemove(aWindow, tabbrowser.tabs[i], true);
11207:     }
11207:     
 4316:     // cache the window state until the window is completely gone
25810:     aWindow.__SS_dyingCache = winData;
 4316:     
    1:     delete aWindow.__SSi;
    1:   },
    1: 
    1:   /**
    1:    * set up listeners for a new tab
    1:    * @param aWindow
    1:    *        Window reference
54278:    * @param aTab
54278:    *        Tab reference
    1:    * @param aNoNotification
    1:    *        bool Do not save state if we're updating an existing tab
    1:    */
54278:   onTabAdd: function sss_onTabAdd(aWindow, aTab, aNoNotification) {
54278:     let browser = aTab.linkedBrowser;
54278:     browser.addEventListener("load", this, true);
54278:     browser.addEventListener("pageshow", this, true);
54278:     browser.addEventListener("change", this, true);
54278:     browser.addEventListener("input", this, true);
54278:     browser.addEventListener("DOMAutoComplete", this, true);
    1: 
    1:     if (!aNoNotification) {
    1:       this.saveStateDelayed(aWindow);
    1:     }
34412: 
34412:     this._updateCrashReportURL(aWindow);
    1:   },
    1: 
    1:   /**
    1:    * remove listeners for a tab
    1:    * @param aWindow
    1:    *        Window reference
54278:    * @param aTab
54278:    *        Tab reference
    1:    * @param aNoNotification
    1:    *        bool Do not save state if we're updating an existing tab
    1:    */
54278:   onTabRemove: function sss_onTabRemove(aWindow, aTab, aNoNotification) {
54278:     let browser = aTab.linkedBrowser;
54278:     browser.removeEventListener("load", this, true);
54278:     browser.removeEventListener("pageshow", this, true);
54278:     browser.removeEventListener("change", this, true);
54278:     browser.removeEventListener("input", this, true);
54278:     browser.removeEventListener("DOMAutoComplete", this, true);
54278: 
54278:     delete browser.__SS_data;
    1: 
55807:     // If this tab was in the middle of restoring or still needs to be restored,
55807:     // we need to reset that state. If the tab was restoring, we will attempt to
55807:     // restore the next tab.
55807:     let previousState;
55807:     if (previousState = browser.__SS_restoreState) {
55807:       this._resetTabRestoringState(aTab);
55807:       if (previousState == TAB_STATE_RESTORING)
55807:         this.restoreNextTab();
55807:     }
54279: 
    1:     if (!aNoNotification) {
    1:       this.saveStateDelayed(aWindow);
    1:     }
    1:   },
    1: 
    1:   /**
20072:    * When a tab closes, collect its properties
    1:    * @param aWindow
    1:    *        Window reference
    1:    * @param aTab
31572:    *        Tab reference
    1:    */
    1:   onTabClose: function sss_onTabClose(aWindow, aTab) {
 9057:     // notify the tabbrowser that the tab state will be retrieved for the last time
 9057:     // (so that extension authors can easily set data on soon-to-be-closed tabs)
 9057:     var event = aWindow.document.createEvent("Events");
 9057:     event.initEvent("SSTabClosing", true, false);
 9057:     aTab.dispatchEvent(event);
 9057:     
    1:     var maxTabsUndo = this._prefBranch.getIntPref("sessionstore.max_tabs_undo");
    1:     // don't update our internal state if we don't have to
    1:     if (maxTabsUndo == 0) {
    1:       return;
    1:     }
    1:     
    1:     // make sure that the tab related data is up-to-date
 8900:     var tabState = this._collectTabData(aTab);
 8900:     this._updateTextAndScrollDataForTab(aWindow, aTab.linkedBrowser, tabState);
    1: 
    1:     // store closed-tab data for undo
61591:     if (this._shouldSaveTabState(tabState)) {
18964:       let tabTitle = aTab.label;
18964:       let tabbrowser = aWindow.gBrowser;
27669:       tabTitle = this._replaceLoadingTitle(tabTitle, tabbrowser, aTab);
18964:       
    1:       this._windows[aWindow.__SSi]._closedTabs.unshift({
    1:         state: tabState,
18964:         title: tabTitle,
 5527:         image: aTab.getAttribute("image"),
    1:         pos: aTab._tPos
    1:       });
    1:       var length = this._windows[aWindow.__SSi]._closedTabs.length;
    1:       if (length > maxTabsUndo)
    1:         this._windows[aWindow.__SSi]._closedTabs.splice(maxTabsUndo, length - maxTabsUndo);
    1:     }
    1:   },
    1: 
    1:   /**
    1:    * When a tab loads, save state.
    1:    * @param aWindow
    1:    *        Window reference
31572:    * @param aBrowser
31572:    *        Browser reference
    1:    * @param aEvent
    1:    *        Event obj
    1:    */
31572:   onTabLoad: function sss_onTabLoad(aWindow, aBrowser, aEvent) { 
    1:     // react on "load" and solitary "pageshow" events (the first "pageshow"
    1:     // following "load" is too late for deleting the data caches)
59697:     // It's possible to get a load event after calling stop on a browser (when
59697:     // overwriting tabs). We want to return early if the tab hasn't been restored yet.
59697:     if ((aEvent.type != "load" && !aEvent.persisted) ||
59697:         (aBrowser.__SS_restoreState &&
59697:          aBrowser.__SS_restoreState == TAB_STATE_NEEDS_RESTORE)) {
    1:       return;
    1:     }
    1:     
31572:     delete aBrowser.__SS_data;
    1:     this.saveStateDelayed(aWindow);
 3394:     
 3394:     // attempt to update the current URL we send in a crash report
 3394:     this._updateCrashReportURL(aWindow);
    1:   },
    1: 
    1:   /**
31572:    * Called when a browser sends the "input" notification 
    1:    * @param aWindow
    1:    *        Window reference
31572:    * @param aBrowser
31572:    *        Browser reference
    1:    */
31572:   onTabInput: function sss_onTabInput(aWindow, aBrowser) {
31572:     if (aBrowser.__SS_data)
31572:       delete aBrowser.__SS_data._formDataSaved;
18836:     
    1:     this.saveStateDelayed(aWindow, 3000);
    1:   },
    1: 
    1:   /**
    1:    * When a tab is selected, save session data
    1:    * @param aWindow
    1:    *        Window reference
    1:    */
31572:   onTabSelect: function sss_onTabSelect(aWindow) {
    1:     if (this._loadState == STATE_RUNNING) {
31572:       this._windows[aWindow.__SSi].selected = aWindow.gBrowser.tabContainer.selectedIndex;
 3394: 
54279:       let tab = aWindow.gBrowser.selectedTab;
55807:       // If __SS_restoreState is still on the browser and it is
55807:       // TAB_STATE_NEEDS_RESTORE, then then we haven't restored
54279:       // this tab yet. Explicitly call restoreTab to kick off the restore.
55807:       if (tab.linkedBrowser.__SS_restoreState &&
55807:           tab.linkedBrowser.__SS_restoreState == TAB_STATE_NEEDS_RESTORE)
54279:         this.restoreTab(tab);
54279: 
 3394:       // attempt to update the current URL we send in a crash report
 3394:       this._updateCrashReportURL(aWindow);
    1:     }
    1:   },
    1: 
63109:   onTabShow: function sss_onTabShow(aWindow, aTab) {
54279:     // If the tab hasn't been restored yet, move it into the right _tabsToRestore bucket
55807:     if (aTab.linkedBrowser.__SS_restoreState &&
55807:         aTab.linkedBrowser.__SS_restoreState == TAB_STATE_NEEDS_RESTORE) {
78670:       this._tabsToRestore.hidden.splice(this._tabsToRestore.hidden.indexOf(aTab), this._tabsToRestore.hidden.length);
54279:       // Just put it at the end of the list of visible tabs;
54279:       this._tabsToRestore.visible.push(aTab);
70123: 
70123:       // let's kick off tab restoration again to ensure this tab gets restored
70123:       // with "restore_hidden_tabs" == false (now that it has become visible)
70123:       this.restoreNextTab();
54279:     }
63109: 
63109:     // Default delay of 2 seconds gives enough time to catch multiple TabShow
63109:     // events due to changing groups in Panorama.
63109:     this.saveStateDelayed(aWindow);
54279:   },
54279: 
63109:   onTabHide: function sss_onTabHide(aWindow, aTab) {
54279:     // If the tab hasn't been restored yet, move it into the right _tabsToRestore bucket
55807:     if (aTab.linkedBrowser.__SS_restoreState &&
55807:         aTab.linkedBrowser.__SS_restoreState == TAB_STATE_NEEDS_RESTORE) {
78670:       this._tabsToRestore.visible.splice(this._tabsToRestore.visible.indexOf(aTab), this._tabsToRestore.visible.length);
54279:       // Just put it at the end of the list of hidden tabs;
54279:       this._tabsToRestore.hidden.push(aTab);
54279:     }
63109: 
63109:     // Default delay of 2 seconds gives enough time to catch multiple TabHide
63109:     // events due to changing groups in Panorama.
63109:     this.saveStateDelayed(aWindow);
54279:   },
54279: 
    1: /* ........ nsISessionStore API .............. */
    1: 
    1:   getBrowserState: function sss_getBrowserState() {
    1:     return this._toJSONString(this._getCurrentState());
    1:   },
    1: 
    1:   setBrowserState: function sss_setBrowserState(aState) {
35664:     this._handleClosedWindows();
35664: 
25810:     try {
43419:       var state = JSON.parse(aState);
25810:     }
25810:     catch (ex) { /* invalid state object - don't restore anything */ }
25810:     if (!state || !state.windows)
25810:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
25810: 
34612:     this._browserSetState = true;
34612: 
54279:     // Make sure _tabsToRestore is emptied out
54279:     this._resetRestoringState();
54279: 
    1:     var window = this._getMostRecentBrowserWindow();
    1:     if (!window) {
34612:       this._restoreCount = 1;
25810:       this._openWindowWithState(state);
    1:       return;
    1:     }
    1: 
    1:     // close all other browser windows
    1:     this._forEachBrowserWindow(function(aWindow) {
    1:       if (aWindow != window) {
    1:         aWindow.close();
35664:         this.onClose(aWindow);
    1:       }
    1:     });
    1: 
35664:     // make sure closed window data isn't kept
35664:     this._closedWindows = [];
35664: 
35664:     // determine how many windows are meant to be restored
35664:     this._restoreCount = state.windows ? state.windows.length : 0;
35664: 
    1:     // restore to the given state
25810:     this.restoreWindow(window, state, true);
    1:   },
    1: 
    1:   getWindowState: function sss_getWindowState(aWindow) {
20334:     if (!aWindow.__SSi && !aWindow.__SS_dyingCache)
20334:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
20334:     
20334:     if (!aWindow.__SSi)
 4316:       return this._toJSONString({ windows: [aWindow.__SS_dyingCache] });
    1:     return this._toJSONString(this._getWindowState(aWindow));
    1:   },
    1: 
    1:   setWindowState: function sss_setWindowState(aWindow, aState, aOverwrite) {
20334:     if (!aWindow.__SSi)
20334:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
20334:     
43419:     this.restoreWindow(aWindow, aState, aOverwrite);
    1:   },
    1: 
11329:   getTabState: function sss_getTabState(aTab) {
20334:     if (!aTab.ownerDocument || !aTab.ownerDocument.defaultView.__SSi)
20334:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
20334:     
11329:     var tabState = this._collectTabData(aTab);
11329:     
11329:     var window = aTab.ownerDocument.defaultView;
11329:     this._updateTextAndScrollDataForTab(window, aTab.linkedBrowser, tabState);
11329:     
11329:     return this._toJSONString(tabState);
11329:   },
11329: 
11329:   setTabState: function sss_setTabState(aTab, aState) {
43419:     var tabState = JSON.parse(aState);
20334:     if (!tabState.entries || !aTab.ownerDocument || !aTab.ownerDocument.defaultView.__SSi)
20334:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
20334:     
11329:     var window = aTab.ownerDocument.defaultView;
76934:     this._setWindowStateBusy(window);
21415:     this.restoreHistoryPrecursor(window, [aTab], [tabState], 0, 0, 0);
11329:   },
11329: 
60277:   duplicateTab: function sss_duplicateTab(aWindow, aTab, aDelta) {
20334:     if (!aTab.ownerDocument || !aTab.ownerDocument.defaultView.__SSi ||
20334:         !aWindow.getBrowser)
20334:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
20334: 
11329:     var tabState = this._collectTabData(aTab, true);
11329:     var sourceWindow = aTab.ownerDocument.defaultView;
11329:     this._updateTextAndScrollDataForTab(sourceWindow, aTab.linkedBrowser, tabState, true);
60277:     tabState.index += aDelta;
60277:     tabState.index = Math.max(1, Math.min(tabState.index, tabState.entries.length));
60939:     tabState.pinned = false;
11329: 
76934:     this._setWindowStateBusy(aWindow);
52468:     let newTab = aTab == aWindow.gBrowser.selectedTab ?
52468:       aWindow.gBrowser.addTab(null, {relatedToCurrent: true, ownerTab: aTab}) :
52468:       aWindow.gBrowser.addTab();
21415:     this.restoreHistoryPrecursor(aWindow, [newTab], [tabState], 0, 0, 0);
11329: 
11329:     return newTab;
11329:   },
11329: 
    1:   getClosedTabCount: function sss_getClosedTabCount(aWindow) {
 4316:     if (!aWindow.__SSi && aWindow.__SS_dyingCache)
 4316:       return aWindow.__SS_dyingCache._closedTabs.length;
 6064:     if (!aWindow.__SSi)
20334:       // XXXzeniko shouldn't we throw here?
 6064:       return 0; // not a browser window, or not otherwise tracked by SS.
 4316:     
    1:     return this._windows[aWindow.__SSi]._closedTabs.length;
    1:   },
    1: 
20334:   getClosedTabData: function sss_getClosedTabDataAt(aWindow) {
20334:     if (!aWindow.__SSi && !aWindow.__SS_dyingCache)
20334:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
    1:     
20334:     if (!aWindow.__SSi)
 4316:       return this._toJSONString(aWindow.__SS_dyingCache._closedTabs);
    1:     return this._toJSONString(this._windows[aWindow.__SSi]._closedTabs);
    1:   },
    1: 
    1:   undoCloseTab: function sss_undoCloseTab(aWindow, aIndex) {
20334:     if (!aWindow.__SSi)
20334:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
20334:     
    1:     var closedTabs = this._windows[aWindow.__SSi]._closedTabs;
    1: 
    1:     // default to the most-recently closed tab
    1:     aIndex = aIndex || 0;
20334:     if (!(aIndex in closedTabs))
20334:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
    1:     
    1:     // fetch the data of closed tab, while removing it from the array
20334:     let closedTab = closedTabs.splice(aIndex, 1).shift();
20334:     let closedTabState = closedTab.state;
    1: 
76934:     this._setWindowStateBusy(aWindow);
    1:     // create a new tab
20334:     let browser = aWindow.gBrowser;
21415:     let tab = browser.addTab();
    1: 
48060:     // restore tab content
48060:     this.restoreHistoryPrecursor(aWindow, [tab], [closedTabState], 1, 0, 0);
48060:       
    1:     // restore the tab's position
19827:     browser.moveTabTo(tab, closedTab.pos);
    1: 
    1:     // focus the tab's content area
20334:     let content = browser.getBrowserForTab(tab).contentWindow;
    1:     aWindow.setTimeout(function() { content.focus(); }, 0);
19827:     
19827:     return tab;
    1:   },
    1: 
26991:   forgetClosedTab: function sss_forgetClosedTab(aWindow, aIndex) {
26991:     if (!aWindow.__SSi)
26991:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
26991:     
26991:     var closedTabs = this._windows[aWindow.__SSi]._closedTabs;
26991: 
26991:     // default to the most-recently closed tab
26991:     aIndex = aIndex || 0;
26991:     if (!(aIndex in closedTabs))
26991:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
26991:     
26991:     // remove closed tab from the array
26991:     closedTabs.splice(aIndex, 1);
26991:   },
26991: 
27669:   getClosedWindowCount: function sss_getClosedWindowCount() {
27669:     return this._closedWindows.length;
27669:   },
27669: 
27669:   getClosedWindowData: function sss_getClosedWindowData() {
27669:     return this._toJSONString(this._closedWindows);
27669:   },
27669: 
27669:   undoCloseWindow: function sss_undoCloseWindow(aIndex) {
31991:     if (!(aIndex in this._closedWindows))
27669:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
27669: 
27669:     // reopen the window
27669:     let state = { windows: this._closedWindows.splice(aIndex, 1) };
27669:     let window = this._openWindowWithState(state);
27669:     this.windowToFocus = window;
27669:     return window;
27669:   },
27669: 
31340:   forgetClosedWindow: function sss_forgetClosedWindow(aIndex) {
31340:     // default to the most-recently closed window
31340:     aIndex = aIndex || 0;
31340:     if (!(aIndex in this._closedWindows))
31340:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
31340:     
31340:     // remove closed window from the array
31340:     this._closedWindows.splice(aIndex, 1);
31340:   },
31340: 
    1:   getWindowValue: function sss_getWindowValue(aWindow, aKey) {
    1:     if (aWindow.__SSi) {
    1:       var data = this._windows[aWindow.__SSi].extData || {};
    1:       return data[aKey] || "";
    1:     }
20334:     if (aWindow.__SS_dyingCache) {
 4316:       data = aWindow.__SS_dyingCache.extData || {};
 4316:       return data[aKey] || "";
 4316:     }
20334:     throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
    1:   },
    1: 
    1:   setWindowValue: function sss_setWindowValue(aWindow, aKey, aStringValue) {
    1:     if (aWindow.__SSi) {
    1:       if (!this._windows[aWindow.__SSi].extData) {
    1:         this._windows[aWindow.__SSi].extData = {};
    1:       }
    1:       this._windows[aWindow.__SSi].extData[aKey] = aStringValue;
    1:       this.saveStateDelayed(aWindow);
    1:     }
    1:     else {
20334:       throw (Components.returnCode = Cr.NS_ERROR_INVALID_ARG);
    1:     }
    1:   },
    1: 
    1:   deleteWindowValue: function sss_deleteWindowValue(aWindow, aKey) {
20334:     if (aWindow.__SSi && this._windows[aWindow.__SSi].extData &&
20334:         this._windows[aWindow.__SSi].extData[aKey])
    1:       delete this._windows[aWindow.__SSi].extData[aKey];
    1:   },
    1: 
    1:   getTabValue: function sss_getTabValue(aTab, aKey) {
56515:     let data = {};
56515:     if (aTab.__SS_extdata) {
56515:       data = aTab.__SS_extdata;
56515:     }
56515:     else if (aTab.linkedBrowser.__SS_data && aTab.linkedBrowser.__SS_data.extData) {
56515:       // If the tab hasn't been fully restored, get the data from the to-be-restored data
56515:       data = aTab.linkedBrowser.__SS_data.extData;
56515:     }
    1:     return data[aKey] || "";
    1:   },
    1: 
    1:   setTabValue: function sss_setTabValue(aTab, aKey, aStringValue) {
56515:     // If the tab hasn't been restored, then set the data there, otherwise we
56515:     // could lose newly added data.
56515:     let saveTo;
56515:     if (aTab.__SS_extdata) {
56515:       saveTo = aTab.__SS_extdata;
56515:     }
56515:     else if (aTab.linkedBrowser.__SS_data && aTab.linkedBrowser.__SS_data.extData) {
56515:       saveTo = aTab.linkedBrowser.__SS_data.extData;
56515:     }
56515:     else {
    1:       aTab.__SS_extdata = {};
56515:       saveTo = aTab.__SS_extdata;
56515:     }
56515:     saveTo[aKey] = aStringValue;
    1:     this.saveStateDelayed(aTab.ownerDocument.defaultView);
    1:   },
    1: 
    1:   deleteTabValue: function sss_deleteTabValue(aTab, aKey) {
59696:     // We want to make sure that if data is accessed early, we attempt to delete
59696:     // that data from __SS_data as well. Otherwise we'll throw in cases where
59696:     // data can be set or read.
59696:     let deleteFrom;
59696:     if (aTab.__SS_extdata) {
59696:       deleteFrom = aTab.__SS_extdata;
59696:     }
59696:     else if (aTab.linkedBrowser.__SS_data && aTab.linkedBrowser.__SS_data.extData) {
59696:       deleteFrom = aTab.linkedBrowser.__SS_data.extData;
59696:     }
59696: 
59696:     if (deleteFrom && deleteFrom[aKey])
59696:       delete deleteFrom[aKey];
    1:   },
    1: 
    1:   persistTabAttribute: function sss_persistTabAttribute(aName) {
74566:     if (aName in this.xulAttributes)
20318:       return; // this attribute is already being tracked
20318:     
74566:     this.xulAttributes[aName] = true;
    1:     this.saveStateDelayed();
    1:   },
    1: 
52403:   /**
52403:    * Restores the session state stored in _lastSessionState. This will attempt
52403:    * to merge data into the current session. If a window was opened at startup
52403:    * with pinned tab(s), then the remaining data from the previous session for
52403:    * that window will be opened into that winddow. Otherwise new windows will
52403:    * be opened.
52403:    */
52403:   restoreLastSession: function sss_restoreLastSession() {
52403:     // Use the public getter since it also checks PB mode
52403:     if (!this.canRestoreLastSession)
52403:       throw (Components.returnCode = Cr.NS_ERROR_FAILURE);
52403: 
52403:     // First collect each window with its id...
52403:     let windows = {};
52403:     this._forEachBrowserWindow(function(aWindow) {
52403:       if (aWindow.__SS_lastSessionWindowID)
52403:         windows[aWindow.__SS_lastSessionWindowID] = aWindow;
52403:     });
52403: 
52403:     let lastSessionState = this._lastSessionState;
52403: 
52403:     // This shouldn't ever be the case...
52403:     if (!lastSessionState.windows.length)
52403:       throw (Components.returnCode = Cr.NS_ERROR_UNEXPECTED);
52403: 
52403:     // We're technically doing a restore, so set things up so we send the
52403:     // notification when we're done. We want to send "sessionstore-browser-state-restored".
52403:     this._restoreCount = lastSessionState.windows.length;
52403:     this._browserSetState = true;
52403: 
62634:     // We want to re-use the last opened window instead of opening a new one in
62634:     // the case where it's "empty" and not associated with a window in the session.
62634:     // We will do more processing via _prepWindowToRestoreInto if we need to use
62634:     // the lastWindow.
62634:     let lastWindow = this._getMostRecentBrowserWindow();
62634:     let canUseLastWindow = lastWindow &&
62634:                            !lastWindow.__SS_lastSessionWindowID;
77866:     let lastSessionFocusedWindow = null;
77866:     this.windowToFocus = lastWindow;
77866: 
77866:     // move the last focused window to the start of the array so that we
77866:     // minimize window movement (see bug 669272)
77866:     lastSessionState.windows.unshift(
77866:       lastSessionState.windows.splice(lastSessionState.selectedWindow - 1, 1)[0]);
62634: 
52403:     // Restore into windows or open new ones as needed.
52403:     for (let i = 0; i < lastSessionState.windows.length; i++) {
52403:       let winState = lastSessionState.windows[i];
52403:       let lastSessionWindowID = winState.__lastSessionWindowID;
52403:       // delete lastSessionWindowID so we don't add that to the window again
52403:       delete winState.__lastSessionWindowID;
62634: 
62634:       // See if we can use an open window. First try one that is associated with
62634:       // the state we're trying to restore and then fallback to the last selected
62634:       // window.
62634:       let windowToUse = windows[lastSessionWindowID];
62634:       if (!windowToUse && canUseLastWindow) {
62634:         windowToUse = lastWindow;
62634:         canUseLastWindow = false;
62634:       }
62634: 
62634:       let [canUseWindow, canOverwriteTabs] = this._prepWindowToRestoreInto(windowToUse);
62634: 
62634:       // If there's a window already open that we can restore into, use that
62634:       if (canUseWindow) {
52403:         // Since we're not overwriting existing tabs, we want to merge _closedTabs,
52403:         // putting existing ones first. Then make sure we're respecting the max pref.
52403:         if (winState._closedTabs && winState._closedTabs.length) {
62634:           let curWinState = this._windows[windowToUse.__SSi];
52403:           curWinState._closedTabs = curWinState._closedTabs.concat(winState._closedTabs);
78670:           curWinState._closedTabs.splice(this._prefBranch.getIntPref("sessionstore.max_tabs_undo"), curWinState._closedTabs.length);
52403:         }
52403: 
52403:         // Restore into that window - pretend it's a followup since we'll already
52403:         // have a focused window.
52403:         //XXXzpao This is going to merge extData together (taking what was in
62634:         //        winState over what is in the window already. The hack we have
62634:         //        in _preWindowToRestoreInto will prevent most (all?) Panorama
62634:         //        weirdness but we will still merge other extData.
52403:         //        Bug 588217 should make this go away by merging the group data.
62634:         this.restoreWindow(windowToUse, { windows: [winState] }, canOverwriteTabs, true);
77866:         if (i == 0)
77866:           lastSessionFocusedWindow = windowToUse;
77866: 
77866:         // if we overwrote the tabs for our last focused window, we should
77866:         // give focus to the window that had it in the previous session
77866:         if (canOverwriteTabs && windowToUse == lastWindow)
77866:           this.windowToFocus = lastSessionFocusedWindow;
52403:       }
52403:       else {
77866:         let win = this._openWindowWithState({ windows: [winState] });
77866:         if (i == 0)
77866:           lastSessionFocusedWindow = win;
52403:       }
52403:     }
52403: 
52403:     // Merge closed windows from this session with ones from last session
52403:     if (lastSessionState._closedWindows) {
52403:       this._closedWindows = this._closedWindows.concat(lastSessionState._closedWindows);
52403:       this._capClosedWindows();
52403:     }
72191: 
72191:     // Set data that persists between sessions
52403:     this._recentCrashes = lastSessionState.session &&
52403:                           lastSessionState.session.recentCrashes || 0;
72191:     this._sessionStartTime = lastSessionState.session &&
72191:                              lastSessionState.session.startTime ||
72191:                              this._sessionStartTime;
52403: 
52403:     this._lastSessionState = null;
52403:   },
52403: 
62634: 
62634:   /**
62634:    * See if aWindow is usable for use when restoring a previous session via
62634:    * restoreLastSession. If usable, prepare it for use.
62634:    *
62634:    * @param aWindow
62634:    *        the window to inspect & prepare
62634:    * @returns [canUseWindow, canOverwriteTabs]
62634:    *          canUseWindow: can the window be used to restore into
62634:    *          canOverwriteTabs: all of the current tabs are home pages and we
62634:    *                            can overwrite them
62634:    */
62634:   _prepWindowToRestoreInto: function sss__prepWindowToRestoreInto(aWindow) {
62634:     if (!aWindow)
62634:       return [false, false];
62634: 
62634:     // We might be able to overwrite the existing tabs instead of just adding
62634:     // the previous session's tabs to the end. This will be set if possible.
62634:     let canOverwriteTabs = false;
62634: 
62634:     // Step 1 of processing:
62634:     // Inspect extData for Panorama identifiers. If found, then we want to
62634:     // inspect further. If there is a single group, then we can use this
62634:     // window. If there are multiple groups then we won't use this window.
62634:     let data = this.getWindowValue(aWindow, "tabview-group");
62634:     if (data) {
62634:       data = JSON.parse(data);
62634: 
62634:       // Multiple keys means multiple groups, which means we don't want to use this window.
62634:       if (Object.keys(data).length > 1) {
62634:         return [false, false];
62634:       }
62634:       else {
62634:         // If there is only one group, then we want to ensure that its group id
62634:         // is 0. This is how Panorama forces group merging when new tabs are opened.
62634:         //XXXzpao This is a hack and the proper fix really belongs in Panorama.
62634:         let groupKey = Object.keys(data)[0];
62634:         if (groupKey !== "0") {
62634:           data["0"] = data[groupKey];
62634:           delete data[groupKey];
62634:           this.setWindowValue(aWindow, "tabview-groups", JSON.stringify(data));
62634:         }
62634:       }
62634:     }
62634: 
62634:     // Step 2 of processing:
62634:     // If we're still here, then the window is usable. Look at the open tabs in
62634:     // comparison to home pages. If all the tabs are home pages then we'll end
62634:     // up overwriting all of them. Otherwise we'll just close the tabs that
62634:     // match home pages.
62634:     let homePages = aWindow.gHomeButton.getHomePage().split("|");
62634:     let removableTabs = [];
62634:     let tabbrowser = aWindow.gBrowser;
62634:     let normalTabsLen = tabbrowser.tabs.length - tabbrowser._numPinnedTabs;
62634:     for (let i = tabbrowser._numPinnedTabs; i < tabbrowser.tabs.length; i++) {
62634:       let tab = tabbrowser.tabs[i];
62634:       if (homePages.indexOf(tab.linkedBrowser.currentURI.spec) != -1) {
62634:         removableTabs.push(tab);
62634:       }
62634:     }
62634: 
62634:     if (tabbrowser.tabs.length == removableTabs.length) {
62634:       canOverwriteTabs = true;
62634:     }
62634:     else {
62634:       // If we're not overwriting all of the tabs, then close the home tabs.
62634:       for (let i = removableTabs.length - 1; i >= 0; i--) {
62634:         tabbrowser.removeTab(removableTabs.pop(), { animate: false });
62634:       }
62634:     }
62634: 
62634:     return [true, canOverwriteTabs];
62634:   },
62634: 
    1: /* ........ Saving Functionality .............. */
    1: 
    1:   /**
    1:    * Store all session data for a window
    1:    * @param aWindow
    1:    *        Window reference
    1:    */
55806:   _saveWindowHistory: function sss_saveWindowHistory(aWindow) {
32885:     var tabbrowser = aWindow.gBrowser;
39702:     var tabs = tabbrowser.tabs;
 8900:     var tabsData = this._windows[aWindow.__SSi].tabs = [];
    1:     
55806:     for (var i = 0; i < tabs.length; i++)
 8900:       tabsData.push(this._collectTabData(tabs[i]));
 8900:     
 8900:     this._windows[aWindow.__SSi].selected = tabbrowser.mTabBox.selectedIndex + 1;
 8900:   },
 8900: 
 8900:   /**
 8900:    * Collect data related to a single tab
 8900:    * @param aTab
 8900:    *        tabbrowser tab
11329:    * @param aFullData
11329:    *        always return privacy sensitive data (use with care)
 8900:    * @returns object
 8900:    */
11329:   _collectTabData: function sss_collectTabData(aTab, aFullData) {
18879:     var tabData = { entries: [] };
 8900:     var browser = aTab.linkedBrowser;
    1:     
 8900:     if (!browser || !browser.currentURI)
    1:       // can happen when calling this function right after .addTab()
 8900:       return tabData;
56389:     else if (browser.__SS_data && browser.__SS_data._tabStillLoading) {
 2188:       // use the data to be restored when the tab hasn't been completely loaded
56389:       tabData = browser.__SS_data;
56389:       if (aTab.pinned)
56389:         tabData.pinned = true;
56389:       else
56389:         delete tabData.pinned;
58659:       tabData.hidden = aTab.hidden;
58659: 
58659:       // If __SS_extdata is set then we'll use that since it might be newer.
58659:       if (aTab.__SS_extdata)
58659:         tabData.extData = aTab.__SS_extdata;
58659:       // If it exists but is empty then a key was likely deleted. In that case just
58659:       // delete extData.
58659:       if (tabData.extData && !Object.keys(tabData.extData).length)
58659:         delete tabData.extData;
56389:       return tabData;
56389:     }
 6835:     
    1:     var history = null;
    1:     try {
    1:       history = browser.sessionHistory;
    1:     }
    1:     catch (ex) { } // this could happen if we catch a tab during (de)initialization
    1:     
25194:     // XXXzeniko anchor navigation doesn't reset __SS_data, so we could reuse
25194:     //           data even when we shouldn't (e.g. Back, different anchor)
31572:     if (history && browser.__SS_data &&
31572:         browser.__SS_data.entries[history.index] &&
61090:         browser.__SS_data.entries[history.index].url == browser.currentURI.spec &&
25194:         history.index < this._sessionhistory_max_entries - 1 && !aFullData) {
31572:       tabData = browser.__SS_data;
    1:       tabData.index = history.index + 1;
    1:     }
    1:     else if (history && history.count > 0) {
74262:       try {
52403:         for (var j = 0; j < history.count; j++) {
52403:           let entry = this._serializeHistoryEntry(history.getEntryAtIndex(j, false),
74725:                                                   aFullData, aTab.pinned);
52403:           tabData.entries.push(entry);
52403:         }
74262:         // If we make it through the for loop, then we're ok and we should clear
74262:         // any indicator of brokenness.
74262:         delete aTab.__SS_broken_history;
74262:       }
74262:       catch (ex) {
74262:         // In some cases, getEntryAtIndex will throw. This seems to be due to
74262:         // history.count being higher than it should be. By doing this in a
74262:         // try-catch, we'll update history to where it breaks, assert for
74262:         // non-release builds, and still save sessionstore.js. We'll track if
74262:         // we've shown the assert for this tab so we only show it once.
74262:         // cf. bug 669196.
74262:         if (!aTab.__SS_broken_history) {
74262:           // First Focus the window & tab we're having trouble with.
74262:           aTab.ownerDocument.defaultView.focus();
74262:           aTab.ownerDocument.defaultView.gBrowser.selectedTab = aTab;
74262:           NS_ASSERT(false, "SessionStore failed gathering complete history " +
74262:                            "for the focused window/tab. See bug 669196.");
74262:           aTab.__SS_broken_history = true;
74262:         }
74262:       }
13181:       tabData.index = history.index + 1;
    1: 
11329:       // make sure not to cache privacy sensitive data which shouldn't get out
11329:       if (!aFullData)
31572:         browser.__SS_data = tabData;
    1:     }
18879:     else if (browser.currentURI.spec != "about:blank" ||
18879:              browser.contentDocument.body.hasChildNodes()) {
    1:       tabData.entries[0] = { url: browser.currentURI.spec };
    1:       tabData.index = 1;
    1:     }
34841: 
34841:     // If there is a userTypedValue set, then either the user has typed something
34841:     // in the URL bar, or a new tab was opened with a URI to load. userTypedClear
34841:     // is used to indicate whether the tab was in some sort of loading state with
34841:     // userTypedValue.
34841:     if (browser.userTypedValue) {
34841:       tabData.userTypedValue = browser.userTypedValue;
34841:       tabData.userTypedClear = browser.userTypedClear;
56389:     } else {
56389:       delete tabData.userTypedValue;
56389:       delete tabData.userTypedClear;
32380:     }
 6835: 
47832:     if (aTab.pinned)
47832:       tabData.pinned = true;
56389:     else
56389:       delete tabData.pinned;
49635:     tabData.hidden = aTab.hidden;
47832: 
 6835:     var disallow = [];
 8900:     for (var i = 0; i < CAPABILITIES.length; i++)
 6835:       if (!browser.docShell["allow" + CAPABILITIES[i]])
 6835:         disallow.push(CAPABILITIES[i]);
 8900:     if (disallow.length > 0)
    1:       tabData.disallow = disallow.join(",");
 8887:     else if (tabData.disallow)
 8887:       delete tabData.disallow;
    1:     
17048:     tabData.attributes = {};
74566:     for (let name in this.xulAttributes) {
74566:       if (aTab.hasAttribute(name))
74566:         tabData.attributes[name] = aTab.getAttribute(name);
 6835:     }
    1:     
 8900:     if (aTab.__SS_extdata)
 8900:       tabData.extData = aTab.__SS_extdata;
 8887:     else if (tabData.extData)
 8887:       delete tabData.extData;
    1:     
19833:     if (history && browser.docShell instanceof Ci.nsIDocShell)
52403:       this._serializeSessionStorage(tabData, history, browser.docShell, aFullData,
52403:                                     aTab.pinned);
19833:     
 8900:     return tabData;
    1:   },
    1: 
    1:   /**
    1:    * Get an object that is a serialized representation of a History entry
    1:    * Used for data storage
    1:    * @param aEntry
    1:    *        nsISHEntry instance
11329:    * @param aFullData
11329:    *        always return privacy sensitive data (use with care)
52403:    * @param aIsPinned
52403:    *        the tab is pinned and should be treated differently for privacy
    1:    * @returns object
    1:    */
52403:   _serializeHistoryEntry:
74725:     function sss_serializeHistoryEntry(aEntry, aFullData, aIsPinned) {
 6913:     var entry = { url: aEntry.URI.spec };
    1: 
74495:     try {
74495:       entry._host = aEntry.URI.host;
74495:       entry._scheme = aEntry.URI.scheme;
74495:     }
74495:     catch (ex) {
74495:       // We just won't attempt to get cookies for this entry.
74495:     }
74495: 
    1:     if (aEntry.title && aEntry.title != entry.url) {
    1:       entry.title = aEntry.title;
    1:     }
    1:     if (aEntry.isSubFrame) {
    1:       entry.subframe = true;
    1:     }
    1:     if (!(aEntry instanceof Ci.nsISHEntry)) {
    1:       return entry;
    1:     }
    1:     
    1:     var cacheKey = aEntry.cacheKey;
 6913:     if (cacheKey && cacheKey instanceof Ci.nsISupportsPRUint32 &&
 6913:         cacheKey.data != 0) {
 6007:       // XXXbz would be better to have cache keys implement
 6007:       // nsISerializable or something.
    1:       entry.cacheKey = cacheKey.data;
    1:     }
    1:     entry.ID = aEntry.ID;
59695:     entry.docshellID = aEntry.docshellID;
    1:     
29350:     if (aEntry.referrerURI)
29350:       entry.referrer = aEntry.referrerURI.spec;
29350: 
 6913:     if (aEntry.contentType)
 6007:       entry.contentType = aEntry.contentType;
 6007:     
    1:     var x = {}, y = {};
    1:     aEntry.getScrollPosition(x, y);
 6913:     if (x.value != 0 || y.value != 0)
    1:       entry.scroll = x.value + "," + y.value;
    1:     
    1:     try {
    1:       var prefPostdata = this._prefBranch.getIntPref("sessionstore.postdata");
52403:       if (aEntry.postData && (aFullData || prefPostdata &&
52403:             this._checkPrivacyLevel(aEntry.URI.schemeIs("https"), aIsPinned))) {
    1:         aEntry.postData.QueryInterface(Ci.nsISeekableStream).
    1:                         seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
 6007:         var stream = Cc["@mozilla.org/binaryinputstream;1"].
 6007:                      createInstance(Ci.nsIBinaryInputStream);
 6007:         stream.setInputStream(aEntry.postData);
 6007:         var postBytes = stream.readByteArray(stream.available());
 6007:         var postdata = String.fromCharCode.apply(null, postBytes);
11329:         if (aFullData || prefPostdata == -1 ||
 6007:             postdata.replace(/^(Content-.*\r\n)+(\r\n)*/, "").length <=
 6007:               prefPostdata) {
 6007:           // We can stop doing base64 encoding once our serialization into JSON
 6007:           // is guaranteed to handle all chars in strings, including embedded
 6007:           // nulls.
 6007:           entry.postdata_b64 = btoa(postdata);
    1:         }
    1:       }
    1:     }
    1:     catch (ex) { debug(ex); } // POSTDATA is tricky - especially since some extensions don't get it right
    1: 
 6007:     if (aEntry.owner) {
 6007:       // Not catching anything specific here, just possible errors
 6007:       // from writeCompoundObject and the like.
 6007:       try {
 6007:         var binaryStream = Cc["@mozilla.org/binaryoutputstream;1"].
 6007:                            createInstance(Ci.nsIObjectOutputStream);
 6007:         var pipe = Cc["@mozilla.org/pipe;1"].createInstance(Ci.nsIPipe);
 6007:         pipe.init(false, false, 0, 0xffffffff, null);
 6007:         binaryStream.setOutputStream(pipe.outputStream);
 6007:         binaryStream.writeCompoundObject(aEntry.owner, Ci.nsISupports, true);
 6007:         binaryStream.close();
 6007: 
 6007:         // Now we want to read the data from the pipe's input end and encode it.
 6007:         var scriptableStream = Cc["@mozilla.org/binaryinputstream;1"].
 6007:                                createInstance(Ci.nsIBinaryInputStream);
 6007:         scriptableStream.setInputStream(pipe.inputStream);
 6007:         var ownerBytes =
 6007:           scriptableStream.readByteArray(scriptableStream.available());
 6007:         // We can stop doing base64 encoding once our serialization into JSON
 6007:         // is guaranteed to handle all chars in strings, including embedded
 6007:         // nulls.
 6007:         entry.owner_b64 = btoa(String.fromCharCode.apply(null, ownerBytes));
 6007:       }
 6007:       catch (ex) { debug(ex); }
 6007:     }
 6007: 
80309:     if (aEntry.docIdentifier) {
80309:       entry.docIdentifier = aEntry.docIdentifier;
80309:     }
37802: 
69563:     if (aEntry.stateData != null) {
69563:       entry.structuredCloneState = aEntry.stateData.getDataAsBase64();
69563:       entry.structuredCloneVersion = aEntry.stateData.formatVersion;
37802:     }
37802: 
    1:     if (!(aEntry instanceof Ci.nsISHContainer)) {
    1:       return entry;
    1:     }
    1:     
 6913:     if (aEntry.childCount > 0) {
 6913:       entry.children = [];
    1:       for (var i = 0; i < aEntry.childCount; i++) {
    1:         var child = aEntry.GetChildAt(i);
    1:         if (child) {
52403:           entry.children.push(this._serializeHistoryEntry(child, aFullData,
74725:                                                           aIsPinned));
    1:         }
    1:         else { // to maintain the correct frame order, insert a dummy entry 
    1:           entry.children.push({ url: "about:blank" });
    1:         }
17039:         // don't try to restore framesets containing wyciwyg URLs (cf. bug 424689 and bug 450595)
17039:         if (/^wyciwyg:\/\//.test(entry.children[i].url)) {
17039:           delete entry.children;
17039:           break;
17039:         }
    1:       }
 6913:     }
    1:     
    1:     return entry;
    1:   },
    1: 
    1:   /**
19833:    * Updates all sessionStorage "super cookies"
19833:    * @param aTabData
19833:    *        The data object for a specific tab
19833:    * @param aHistory
19833:    *        That tab's session history
19833:    * @param aDocShell
19833:    *        That tab's docshell (containing the sessionStorage)
19833:    * @param aFullData
19833:    *        always return privacy sensitive data (use with care)
52403:    * @param aIsPinned
52403:    *        the tab is pinned and should be treated differently for privacy
19833:    */
19833:   _serializeSessionStorage:
52403:     function sss_serializeSessionStorage(aTabData, aHistory, aDocShell, aFullData, aIsPinned) {
19833:     let storageData = {};
19833:     let hasContent = false;
19833: 
19833:     for (let i = 0; i < aHistory.count; i++) {
74686:       let uri;
74686:       try {
74686:         uri = aHistory.getEntryAtIndex(i, false).URI;
74686:       }
74686:       catch (ex) {
74686:         // Chances are that this is getEntryAtIndex throwing, as seen in bug 669196.
74686:         // We've already asserted in _collectTabData, so we won't show that again.
74686:         continue;
74686:       }
28676:       // sessionStorage is saved per origin (cf. nsDocShell::GetSessionStorageForURI)
20322:       let domain = uri.spec;
20322:       try {
20322:         if (uri.host)
20322:           domain = uri.prePath;
20322:       }
20322:       catch (ex) { /* this throws for host-less URIs (such as about: or jar:) */ }
52403:       if (storageData[domain] ||
52403:           !(aFullData || this._checkPrivacyLevel(uri.schemeIs("https"), aIsPinned)))
19833:         continue;
19833: 
20322:       let storage, storageItemCount = 0;
20314:       try {
36318:         var principal = SecuritySvc.getCodebasePrincipal(uri);
28792: 
28792:         // Using getSessionStorageForPrincipal instead of getSessionStorageForURI
28792:         // just to be able to pass aCreate = false, that avoids creation of the
28792:         // sessionStorage object for the page earlier than the page really
28792:         // requires it. It was causing problems while accessing a storage when
28792:         // a page later changed its domain.
37608:         storage = aDocShell.getSessionStorageForPrincipal(principal, "", false);
28792:         if (storage)
20314:           storageItemCount = storage.length;
20322:       }
20322:       catch (ex) { /* sessionStorage might throw if it's turned off, see bug 458954 */ }
20314:       if (storageItemCount == 0)
19833:         continue;
19833: 
20322:       let data = storageData[domain] = {};
20314:       for (let j = 0; j < storageItemCount; j++) {
19833:         try {
19833:           let key = storage.key(j);
19833:           let item = storage.getItem(key);
28676:           data[key] = item;
19833:         }
19833:         catch (ex) { /* XXXzeniko this currently throws for secured items (cf. bug 442048) */ }
19833:       }
19833:       hasContent = true;
19833:     }
19833: 
19833:     if (hasContent)
19833:       aTabData.storage = storageData;
19833:   },
19833: 
19833:   /**
 8900:    * go through all tabs and store the current scroll positions
    1:    * and innerHTML content of WYSIWYG editors
    1:    * @param aWindow
    1:    *        Window reference
    1:    */
    1:   _updateTextAndScrollData: function sss_updateTextAndScrollData(aWindow) {
32885:     var browsers = aWindow.gBrowser.browsers;
51018:     this._windows[aWindow.__SSi].tabs.forEach(function (tabData, i) {
31572:       if (browsers[i].__SS_data &&
31572:           browsers[i].__SS_data._tabStillLoading)
51018:         return; // ignore incompletely initialized tabs
51018:       try {
 8900:         this._updateTextAndScrollDataForTab(aWindow, browsers[i], tabData);
 8900:       }
 8900:       catch (ex) { debug(ex); } // get as much data as possible, ignore failures (might succeed the next time)
51018:     }, this);
 8900:   },
 8900: 
 8900:   /**
 8900:    * go through all frames and store the current scroll positions
 8900:    * and innerHTML content of WYSIWYG editors
 8900:    * @param aWindow
 8900:    *        Window reference
 8900:    * @param aBrowser
 8900:    *        single browser reference
 8900:    * @param aTabData
 8900:    *        tabData object to add the information to
11329:    * @param aFullData
11329:    *        always return privacy sensitive data (use with care)
 8900:    */
 8900:   _updateTextAndScrollDataForTab:
11329:     function sss_updateTextAndScrollDataForTab(aWindow, aBrowser, aTabData, aFullData) {
11329:     var tabIndex = (aTabData.index || aTabData.entries.length) - 1;
11329:     // entry data needn't exist for tabs just initialized with an incomplete session state
18836:     if (!aTabData.entries[tabIndex])
18836:       return;
18836:     
20034:     let selectedPageStyle = aBrowser.markupDocumentViewer.authorStyleDisabled ? "_nostyle" :
20034:                             this._getSelectedPageStyle(aBrowser.contentWindow);
20034:     if (selectedPageStyle)
20034:       aTabData.pageStyle = selectedPageStyle;
20034:     else if (aTabData.pageStyle)
20034:       delete aTabData.pageStyle;
20034:     
 8900:     this._updateTextAndScrollDataForFrame(aWindow, aBrowser.contentWindow,
18836:                                           aTabData.entries[tabIndex],
52403:                                           !aTabData._formDataSaved, aFullData,
52403:                                           !!aTabData.pinned);
18836:     aTabData._formDataSaved = true;
18836:     if (aBrowser.currentURI.spec == "about:config")
18836:       aTabData.entries[tabIndex].formdata = {
55686:         "#textbox": aBrowser.contentDocument.getElementById("textbox").value
18836:       };
 8900:   },
 8900: 
 8900:   /**
18836:    * go through all subframes and store all form data, the current
18836:    * scroll positions and innerHTML content of WYSIWYG editors
 8900:    * @param aWindow
 8900:    *        Window reference
 8900:    * @param aContent
 8900:    *        frame reference
 8900:    * @param aData
 8900:    *        part of a tabData object to add the information to
18836:    * @param aUpdateFormData
18836:    *        update all form data for this tab
11329:    * @param aFullData
11329:    *        always return privacy sensitive data (use with care)
52403:    * @param aIsPinned
52403:    *        the tab is pinned and should be treated differently for privacy
 8900:    */
 8900:   _updateTextAndScrollDataForFrame:
18836:     function sss_updateTextAndScrollDataForFrame(aWindow, aContent, aData,
52403:                                                  aUpdateFormData, aFullData, aIsPinned) {
    1:     for (var i = 0; i < aContent.frames.length; i++) {
 8900:       if (aData.children && aData.children[i])
18836:         this._updateTextAndScrollDataForFrame(aWindow, aContent.frames[i],
52403:                                               aData.children[i], aUpdateFormData,
52403:                                               aFullData, aIsPinned);
    1:     }
 8900:     var isHTTPS = this._getURIFromString((aContent.parent || aContent).
    1:                                          document.location.href).schemeIs("https");
52403:     if (aFullData || this._checkPrivacyLevel(isHTTPS, aIsPinned) ||
20315:         aContent.top.document.location.href == "about:sessionrestore") {
18836:       if (aFullData || aUpdateFormData) {
18836:         let formData = this._collectFormDataForFrame(aContent.document);
18836:         if (formData)
18836:           aData.formdata = formData;
18836:         else if (aData.formdata)
18836:           delete aData.formdata;
18836:       }
18836:       
18836:       // designMode is undefined e.g. for XUL documents (as about:config)
18836:       if ((aContent.document.designMode || "") == "on") {
11329:         if (aData.innerHTML === undefined && !aFullData) {
    1:           // we get no "input" events from iframes - listen for keypress here
18836:           let _this = this;
 8900:           aContent.addEventListener("keypress", function(aEvent) {
18836:             _this.saveStateDelayed(aWindow, 3000);
18836:           }, true);
    1:         }
    1:         aData.innerHTML = aContent.document.body.innerHTML;
    1:       }
18836:     }
26725: 
26725:     // get scroll position from nsIDOMWindowUtils, since it allows avoiding a
26725:     // flush of layout
26725:     let domWindowUtils = aContent.QueryInterface(Ci.nsIInterfaceRequestor)
26725:                                  .getInterface(Ci.nsIDOMWindowUtils);
26725:     let scrollX = {}, scrollY = {};
26725:     domWindowUtils.getScrollXY(false, scrollX, scrollY);
26725:     aData.scroll = scrollX.value + "," + scrollY.value;
    1:   },
    1: 
    1:   /**
20034:    * determine the title of the currently enabled style sheet (if any)
20034:    * and recurse through the frameset if necessary
20034:    * @param   aContent is a frame reference
20034:    * @returns the title style sheet determined to be enabled (empty string if none)
20034:    */
20034:   _getSelectedPageStyle: function sss_getSelectedPageStyle(aContent) {
20034:     const forScreen = /(?:^|,)\s*(?:all|screen)\s*(?:,|$)/i;
20034:     for (let i = 0; i < aContent.document.styleSheets.length; i++) {
20034:       let ss = aContent.document.styleSheets[i];
20034:       let media = ss.media.mediaText;
20034:       if (!ss.disabled && ss.title && (!media || forScreen.test(media)))
20034:         return ss.title
20034:     }
20034:     for (let i = 0; i < aContent.frames.length; i++) {
20034:       let selectedPageStyle = this._getSelectedPageStyle(aContent.frames[i]);
20034:       if (selectedPageStyle)
20034:         return selectedPageStyle;
20034:     }
20034:     return "";
20034:   },
20034: 
20034:   /**
18836:    * collect the state of all form elements
18836:    * @param aDocument
18836:    *        document reference
18836:    */
18836:   _collectFormDataForFrame: function sss_collectFormDataForFrame(aDocument) {
20319:     let formNodes = aDocument.evaluate(XPathHelper.restorableFormNodes, aDocument,
20319:                                        XPathHelper.resolveNS,
18836:                                        Ci.nsIDOMXPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);
18836:     let node = formNodes.iterateNext();
18836:     if (!node)
18836:       return null;
18836: 
30663:     const MAX_GENERATED_XPATHS = 100;
30663:     let generatedCount = 0;
30663: 
18836:     let data = {};
18836:     do {
39647:       let nId = node.id;
39647:       let hasDefaultValue = true;
39647:       let value;
39647: 
30663:       // Only generate a limited number of XPath expressions for perf reasons (cf. bug 477564)
39647:       if (!nId && generatedCount > MAX_GENERATED_XPATHS)
30663:         continue;
30663: 
39647:       if (node instanceof Ci.nsIDOMHTMLInputElement ||
39647:           node instanceof Ci.nsIDOMHTMLTextAreaElement) {
39647:         switch (node.type) {
39647:           case "checkbox":
39647:           case "radio":
39647:             value = node.checked;
39647:             hasDefaultValue = value == node.defaultChecked;
39647:             break;
39647:           case "file":
39647:             value = { type: "file", fileList: node.mozGetFileNameArray() };
39647:             hasDefaultValue = !value.fileList.length;
39647:             break;
39647:           default: // text, textarea
39647:             value = node.value;
39647:             hasDefaultValue = value == node.defaultValue;
39647:             break;
22800:         }
39647:       }
39647:       else if (!node.multiple) {
39647:         // <select>s without the multiple attribute are hard to determine the
39647:         // default value, so assume we don't have the default.
39647:         hasDefaultValue = false;
39647:         value = node.selectedIndex;
39647:       }
18836:       else {
39647:         // <select>s with the multiple attribute are easier to determine the
39647:         // default value since each <option> has a defaultSelected
39647:         let options = Array.map(node.options, function(aOpt, aIx) {
39647:           let oSelected = aOpt.selected;
39647:           hasDefaultValue = hasDefaultValue && (oSelected == aOpt.defaultSelected);
39647:           return oSelected ? aIx : -1;
39647:         });
39647:         value = options.filter(function(aIx) aIx >= 0);
18836:       }
39647:       // In order to reduce XPath generation (which is slow), we only save data
39647:       // for form fields that have been changed. (cf. bug 537289)
39647:       if (!hasDefaultValue) {
39647:         if (nId) {
39647:           data["#" + nId] = value;
39647:         }
39647:         else {
39647:           generatedCount++;
39647:           data[XPathHelper.generate(node)] = value;
39647:         }
39647:       }
39647: 
18836:     } while ((node = formNodes.iterateNext()));
18836: 
18836:     return data;
18836:   },
18836: 
18836:   /**
52403:    * extract the base domain from a history entry and its children
52403:    * @param aEntry
52403:    *        the history entry, serialized
52403:    * @param aHosts
52403:    *        the hash that will be used to store hosts eg, { hostname: true }
52403:    * @param aCheckPrivacy
52403:    *        should we check the privacy level for https
52403:    * @param aIsPinned
52403:    *        is the entry we're evaluating for a pinned tab; used only if
52403:    *        aCheckPrivacy
52403:    */
52403:   _extractHostsForCookies:
52403:     function sss__extractHostsForCookies(aEntry, aHosts, aCheckPrivacy, aIsPinned) {
74495: 
74495:     // _host and _scheme may not be set (for about: urls for example), in which
74495:     // case testing _scheme will be sufficient.
74495:     if (/https?/.test(aEntry._scheme) && !aHosts[aEntry._host] &&
52403:         (!aCheckPrivacy ||
74495:          this._checkPrivacyLevel(aEntry._scheme == "https", aIsPinned))) {
52403:       // By setting this to true or false, we can determine when looking at
52403:       // the host in _updateCookies if we should check for privacy.
74495:       aHosts[aEntry._host] = aIsPinned;
74495:     }
74495:     else if (aEntry._scheme == "file") {
74495:       aHosts[aEntry._host] = true;
74495:     }
74495: 
52403:     if (aEntry.children) {
52403:       aEntry.children.forEach(function(entry) {
52403:         this._extractHostsForCookies(entry, aHosts, aCheckPrivacy, aIsPinned);
52403:       }, this);
52403:     }
52403:   },
52403: 
52403:   /**
    1:    * store all hosts for a URL
    1:    * @param aWindow
    1:    *        Window reference
    1:    */
    1:   _updateCookieHosts: function sss_updateCookieHosts(aWindow) {
    1:     var hosts = this._windows[aWindow.__SSi]._hosts = {};
    1: 
52403:     this._windows[aWindow.__SSi].tabs.forEach(function(aTabData) {
52403:       aTabData.entries.forEach(function(entry) {
52403:         this._extractHostsForCookies(entry, hosts, true, !!aTabData.pinned);
52403:       }, this);
52403:     }, this);
    1:   },
    1: 
    1:   /**
    1:    * Serialize cookie data
    1:    * @param aWindows
    1:    *        array of Window references
    1:    */
    1:   _updateCookies: function sss_updateCookies(aWindows) {
30354:     function addCookieToHash(aHash, aHost, aPath, aName, aCookie) {
30354:       // lazily build up a 3-dimensional hash, with
30354:       // aHost, aPath, and aName as keys
30354:       if (!aHash[aHost])
30354:         aHash[aHost] = {};
30354:       if (!aHash[aHost][aPath])
30354:         aHash[aHost][aPath] = {};
30354:       aHash[aHost][aPath][aName] = aCookie;
30354:     }
30354: 
    1:     // collect the cookies per window
 2811:     for (var i = 0; i < aWindows.length; i++)
 2811:       aWindows[i].cookies = [];
    1: 
30354:     var jscookies = {};
30378:     var _this = this;
 2811:     // MAX_EXPIRY should be 2^63-1, but JavaScript can't handle that precision
 2811:     var MAX_EXPIRY = Math.pow(2, 62);
30354:     aWindows.forEach(function(aWindow) {
52403:       if (!aWindow._hosts)
52403:         return;
52403:       for (var [host, isPinned] in Iterator(aWindow._hosts)) {
73797:         let list;
73797:         try {
73797:           list = CookieSvc.getCookiesFromHost(host);
73797:         }
73797:         catch (ex) {
73797:           debug("getCookiesFromHost failed. Host: " + host);
73797:         }
73797:         while (list && list.hasMoreElements()) {
30354:           var cookie = list.getNext().QueryInterface(Ci.nsICookie2);
52403:           // aWindow._hosts will only have hosts with the right privacy rules,
52403:           // so there is no need to do anything special with this call to
52403:           // _checkPrivacyLevel.
52403:           if (cookie.isSession && _this._checkPrivacyLevel(cookie.isSecure, isPinned)) {
30354:             // use the cookie's host, path, and name as keys into a hash,
30354:             // to make sure we serialize each cookie only once
30966:             if (!(cookie.host in jscookies &&
30966:                   cookie.path in jscookies[cookie.host] &&
30966:                   cookie.name in jscookies[cookie.host][cookie.path])) {
30354:               var jscookie = { "host": cookie.host, "value": cookie.value };
 2811:               // only add attributes with non-default values (saving a few bits)
 2811:               if (cookie.path) jscookie.path = cookie.path;
 2811:               if (cookie.name) jscookie.name = cookie.name;
 2811:               if (cookie.isSecure) jscookie.secure = true;
 2811:               if (cookie.isHttpOnly) jscookie.httponly = true;
 2811:               if (cookie.expiry < MAX_EXPIRY) jscookie.expiry = cookie.expiry;
30354: 
30354:               addCookieToHash(jscookies, cookie.host, cookie.path, cookie.name, jscookie);
    1:             }
30354:             aWindow.cookies.push(jscookies[cookie.host][cookie.path][cookie.name]);
    1:           }
    1:         }
    1:       }
30378:     });
    1: 
    1:     // don't include empty cookie sections
 2811:     for (i = 0; i < aWindows.length; i++)
 2811:       if (aWindows[i].cookies.length == 0)
    1:         delete aWindows[i].cookies;
    1:   },
    1: 
    1:   /**
    1:    * Store window dimensions, visibility, sidebar
    1:    * @param aWindow
    1:    *        Window reference
    1:    */
    1:   _updateWindowFeatures: function sss_updateWindowFeatures(aWindow) {
    1:     var winData = this._windows[aWindow.__SSi];
    1:     
    1:     WINDOW_ATTRIBUTES.forEach(function(aAttr) {
 8887:       winData[aAttr] = this._getWindowDimension(aWindow, aAttr);
    1:     }, this);
    1:     
 8887:     var hidden = WINDOW_HIDEABLE_FEATURES.filter(function(aItem) {
 8887:       return aWindow[aItem] && !aWindow[aItem].visible;
 6913:     });
 6913:     if (hidden.length != 0)
 6913:       winData.hidden = hidden.join(",");
 8887:     else if (winData.hidden)
 8887:       delete winData.hidden;
    1: 
 6913:     var sidebar = aWindow.document.getElementById("sidebar-box").getAttribute("sidebarcommand");
 6913:     if (sidebar)
 6913:       winData.sidebar = sidebar;
 8887:     else if (winData.sidebar)
 8887:       delete winData.sidebar;
    1:   },
    1: 
    1:   /**
51017:    * gather session data as object
18927:    * @param aUpdateAll
18927:    *        Bool update all windows 
51017:    * @param aPinnedOnly
51017:    *        Bool collect pinned tabs only
51017:    * @returns object
    1:    */
51017:   _getCurrentState: function sss_getCurrentState(aUpdateAll, aPinnedOnly) {
35664:     this._handleClosedWindows();
35664: 
    1:     var activeWindow = this._getMostRecentBrowserWindow();
    1:     
    1:     if (this._loadState == STATE_RUNNING) {
    1:       // update the data for all windows with activities since the last save operation
    1:       this._forEachBrowserWindow(function(aWindow) {
25810:         if (!this._isWindowLoaded(aWindow)) // window data is still in _statesToRestore
25810:           return;
18927:         if (aUpdateAll || this._dirtyWindows[aWindow.__SSi] || aWindow == activeWindow) {
55806:           this._collectWindowData(aWindow);
    1:         }
    1:         else { // always update the window features (whose change alone never triggers a save operation)
    1:           this._updateWindowFeatures(aWindow);
    1:         }
35664:       });
    1:       this._dirtyWindows = [];
    1:     }
    1:     
    1:     // collect the data for all windows
    1:     var total = [], windows = [];
18833:     var nonPopupCount = 0;
    1:     var ix;
    1:     for (ix in this._windows) {
35634:       if (this._windows[ix]._restoring) // window data is still in _statesToRestore
35634:         continue;
    1:       total.push(this._windows[ix]);
    1:       windows.push(ix);
18833:       if (!this._windows[ix].isPopup)
18833:         nonPopupCount++;
    1:     }
    1:     this._updateCookies(total);
    1: 
25810:     // collect the data for all windows yet to be restored
25810:     for (ix in this._statesToRestore) {
25810:       for each (let winData in this._statesToRestore[ix].windows) {
25810:         total.push(winData);
25810:         if (!winData.isPopup)
25810:           nonPopupCount++;
25810:       }
25810:     }
25810: 
27669:     // shallow copy this._closedWindows to preserve current state
27669:     let lastClosedWindowsCopy = this._closedWindows.slice();
27669: 
25697: #ifndef XP_MACOSX
54481:     // If no non-popup browser window remains open, return the state of the last
54481:     // closed window(s). We only want to do this when we're actually "ending"
54481:     // the session.
54481:     //XXXzpao We should do this for _restoreLastWindow == true, but that has
54481:     //        its own check for popups. c.f. bug 597619
54481:     if (nonPopupCount == 0 && lastClosedWindowsCopy.length > 0 &&
54481:         this._loadState == STATE_QUITTING) {
18833:       // prepend the last non-popup browser window, so that if the user loads more tabs
18833:       // at startup we don't accidentally add them to a popup window
27669:       do {
27669:         total.unshift(lastClosedWindowsCopy.shift())
27669:       } while (total[0].isPopup)
    1:     }
25697: #endif
25697: 
51017:     if (aPinnedOnly) {
55806:       // perform a deep copy so that existing session variables are not changed.
55806:       total = JSON.parse(this._toJSONString(total));
51017:       total = total.filter(function (win) {
51017:         win.tabs = win.tabs.filter(function (tab) tab.pinned);
55806:         // remove closed tabs
55806:         win._closedTabs = [];
55806:         // correct selected tab index if it was stripped out
55806:         if (win.selected > win.tabs.length)
55806:           win.selected = 1;
51017:         return win.tabs.length > 0;
51017:       });
51017:       if (total.length == 0)
51017:         return null;
51017: 
51017:       lastClosedWindowsCopy = [];
51017:     }
51017: 
 6431:     if (activeWindow) {
 6431:       this.activeWindowSSiCache = activeWindow.__SSi || "";
 6431:     }
36319:     ix = windows.indexOf(this.activeWindowSSiCache);
55806:     // We don't want to restore focus to a minimized window or a window which had all its
55806:     // tabs stripped out (doesn't exist).
55806:     if (ix != -1 && total[ix] && total[ix].sizemode == "minimized")
36319:       ix = -1;
    1: 
78045:     return { windows: total, selectedWindow: ix + 1, _closedWindows: lastClosedWindowsCopy };
    1:   },
    1: 
    1:   /**
    1:    * serialize session data for a window 
    1:    * @param aWindow
    1:    *        Window reference
    1:    * @returns string
    1:    */
    1:   _getWindowState: function sss_getWindowState(aWindow) {
25810:     if (!this._isWindowLoaded(aWindow))
25810:       return this._statesToRestore[aWindow.__SS_restoreID];
25810:     
    1:     if (this._loadState == STATE_RUNNING) {
    1:       this._collectWindowData(aWindow);
    1:     }
    1:     
    1:     var total = [this._windows[aWindow.__SSi]];
    1:     this._updateCookies(total);
    1:     
    1:     return { windows: total };
    1:   },
    1: 
55806:   _collectWindowData: function sss_collectWindowData(aWindow) {
25810:     if (!this._isWindowLoaded(aWindow))
25810:       return;
25810:     
    1:     // update the internal state data for this window
55806:     this._saveWindowHistory(aWindow);
    1:     this._updateTextAndScrollData(aWindow);
    1:     this._updateCookieHosts(aWindow);
    1:     this._updateWindowFeatures(aWindow);
    1: 
52403:     // Make sure we keep __SS_lastSessionWindowID around for cases like entering
52403:     // or leaving PB mode.
52403:     if (aWindow.__SS_lastSessionWindowID)
52403:       this._windows[aWindow.__SSi].__lastSessionWindowID =
52403:         aWindow.__SS_lastSessionWindowID;
52403: 
    1:     this._dirtyWindows[aWindow.__SSi] = false;
    1:   },
    1: 
    1: /* ........ Restoring Functionality .............. */
    1: 
    1:   /**
    1:    * restore features to a single window
    1:    * @param aWindow
    1:    *        Window reference
    1:    * @param aState
    1:    *        JS object or its eval'able source
    1:    * @param aOverwriteTabs
    1:    *        bool overwrite existing tabs w/ new ones
 6431:    * @param aFollowUp
 6431:    *        bool this isn't the restoration of the first window
    1:    */
 6431:   restoreWindow: function sss_restoreWindow(aWindow, aState, aOverwriteTabs, aFollowUp) {
 6431:     if (!aFollowUp) {
 6431:       this.windowToFocus = aWindow;
 6431:     }
    1:     // initialize window if necessary
    1:     if (aWindow && (!aWindow.__SSi || !this._windows[aWindow.__SSi]))
    1:       this.onLoad(aWindow);
    1: 
    1:     try {
43419:       var root = typeof aState == "string" ? JSON.parse(aState) : aState;
    1:       if (!root.windows[0]) {
34612:         this._sendRestoreCompletedNotifications();
    1:         return; // nothing to restore
    1:       }
    1:     }
    1:     catch (ex) { // invalid state object - don't restore anything 
    1:       debug(ex);
34612:       this._sendRestoreCompletedNotifications();
    1:       return;
    1:     }
    1: 
59698:     // We're not returning from this before we end up calling restoreHistoryPrecursor
59698:     // for this window, so make sure we send the SSWindowStateBusy event.
76934:     this._setWindowStateBusy(aWindow);
59698: 
27669:     if (root._closedWindows)
27669:       this._closedWindows = root._closedWindows;
27669: 
    1:     var winData;
77866:     if (!root.selectedWindow) {
77866:       root.selectedWindow = 0;
77866:     } else {
77866:       // put the selected window at the beginning of the array to ensure that
77866:       // it gets restored first
77866:       root.windows.unshift(root.windows.splice(root.selectedWindow - 1, 1)[0]);
 6431:     }
    1:     // open new windows for all further window entries of a multi-window session
    1:     // (unless they don't contain any tab data)
    1:     for (var w = 1; w < root.windows.length; w++) {
    1:       winData = root.windows[w];
    1:       if (winData && winData.tabs && winData.tabs[0]) {
 6431:         var window = this._openWindowWithState({ windows: [winData] });
    1:       }
 6431:     }
    1:     winData = root.windows[0];
    1:     if (!winData.tabs) {
    1:       winData.tabs = [];
    1:     }
16987:     // don't restore a single blank tab when we've had an external
16987:     // URL passed in for loading at startup (cf. bug 357419)
18879:     else if (root._firstTabs && !aOverwriteTabs && winData.tabs.length == 1 &&
18879:              (!winData.tabs[0].entries || winData.tabs[0].entries.length == 0)) {
16987:       winData.tabs = [];
16987:     }
    1: 
26294:     var tabbrowser = aWindow.gBrowser;
    1:     var openTabCount = aOverwriteTabs ? tabbrowser.browsers.length : -1;
    1:     var newTabCount = winData.tabs.length;
26294:     var tabs = [];
26294: 
26294:     // disable smooth scrolling while adding, moving, removing and selecting tabs
26294:     var tabstrip = tabbrowser.tabContainer.mTabstrip;
26294:     var smoothScroll = tabstrip.smoothScroll;
26294:     tabstrip.smoothScroll = false;
    1: 
78647:     // unpin all tabs to ensure they are not reordered in the next loop
78647:     if (aOverwriteTabs) {
78647:       for (let t = tabbrowser._numPinnedTabs - 1; t > -1; t--)
78647:         tabbrowser.unpinTab(tabbrowser.tabs[t]);
78647:     }
78647: 
26149:     // make sure that the selected tab won't be closed in order to
26149:     // prevent unnecessary flickering
26149:     if (aOverwriteTabs && tabbrowser.selectedTab._tPos >= newTabCount)
26149:       tabbrowser.moveTabTo(tabbrowser.selectedTab, newTabCount - 1);
26149: 
    1:     for (var t = 0; t < newTabCount; t++) {
43571:       tabs.push(t < openTabCount ?
43571:                 tabbrowser.tabs[t] :
43571:                 tabbrowser.addTab("about:blank", {skipAnimation: true}));
    1:       // when resuming at startup: add additionally requested pages to the end
    1:       if (!aOverwriteTabs && root._firstTabs) {
21415:         tabbrowser.moveTabTo(tabs[t], t);
    1:       }
47832: 
47832:       if (winData.tabs[t].pinned)
47832:         tabbrowser.pinTab(tabs[t]);
55352: 
55352:       if (winData.tabs[t].hidden)
55352:         tabbrowser.hideTab(tabs[t]);
55352:       else
55352:         tabbrowser.showTab(tabs[t]);
    1:     }
    1: 
55807:     // If overwriting tabs, we want to reset each tab's "restoring" state. Since
55807:     // we're overwriting those tabs, they should no longer be restoring. The
55807:     // tabs will be rebuilt and marked if they need to be restored after loading
55807:     // state (in restoreHistoryPrecursor).
54607:     if (aOverwriteTabs) {
55807:       for (let i = 0; i < tabbrowser.tabs.length; i++) {
55807:         if (tabbrowser.browsers[i].__SS_restoreState)
55807:           this._resetTabRestoringState(tabbrowser.tabs[i]);
55807:       }
54607:     }
54607: 
54607:     // We want to set up a counter on the window that indicates how many tabs
54607:     // in this window are unrestored. This will be used in restoreNextTab to
54607:     // determine if gRestoreTabsProgressListener should be removed from the window.
54607:     // If we aren't overwriting existing tabs, then we want to add to the existing
54607:     // count in case there are still tabs restoring.
54607:     if (!aWindow.__SS_tabsToRestore)
54607:       aWindow.__SS_tabsToRestore = 0;
54607:     if (aOverwriteTabs)
54607:       aWindow.__SS_tabsToRestore = newTabCount;
54607:     else
54607:       aWindow.__SS_tabsToRestore += newTabCount;
54607: 
52403:     // We want to correlate the window with data from the last session, so
52403:     // assign another id if we have one. Otherwise clear so we don't do
52403:     // anything with it.
52403:     delete aWindow.__SS_lastSessionWindowID;
52403:     if (winData.__lastSessionWindowID)
52403:       aWindow.__SS_lastSessionWindowID = winData.__lastSessionWindowID;
52403: 
    1:     // when overwriting tabs, remove all superflous ones
25365:     if (aOverwriteTabs && newTabCount < openTabCount) {
39702:       Array.slice(tabbrowser.tabs, newTabCount, openTabCount)
25365:            .forEach(tabbrowser.removeTab, tabbrowser);
    1:     }
    1:     
    1:     if (aOverwriteTabs) {
 6431:       this.restoreWindowFeatures(aWindow, winData);
26040:       delete this._windows[aWindow.__SSi].extData;
    1:     }
    1:     if (winData.cookies) {
    1:       this.restoreCookies(winData.cookies);
    1:     }
    1:     if (winData.extData) {
26040:       if (!this._windows[aWindow.__SSi].extData) {
22799:         this._windows[aWindow.__SSi].extData = {};
    1:       }
    1:       for (var key in winData.extData) {
    1:         this._windows[aWindow.__SSi].extData[key] = winData.extData[key];
    1:       }
    1:     }
26040:     if (aOverwriteTabs || root._firstTabs) {
26040:       this._windows[aWindow.__SSi]._closedTabs = winData._closedTabs || [];
    1:     }
    1:     
21415:     this.restoreHistoryPrecursor(aWindow, tabs, winData.tabs,
21415:       (aOverwriteTabs ? (parseInt(winData.selected) || 1) : 0), 0, 0);
21044: 
62634:     // This will force the keypress listener that Panorama has to attach if it
62634:     // isn't already. This will be the case if tab view wasn't entered or there
62634:     // were only visible tabs when TabView.init was first called.
62634:     aWindow.TabView.init();
62634: 
26294:     // set smoothScroll back to the original value
26294:     tabstrip.smoothScroll = smoothScroll;
26294: 
34612:     this._sendRestoreCompletedNotifications();
    1:   },
    1: 
    1:   /**
    1:    * Manage history restoration for a window
21415:    * @param aWindow
21415:    *        Window to restore the tabs into
    1:    * @param aTabs
21415:    *        Array of tab references
21415:    * @param aTabData
21411:    *        Array of tab data
    1:    * @param aSelectTab
    1:    *        Index of selected tab
11329:    * @param aIx
11329:    *        Index of the next tab to check readyness for
    1:    * @param aCount
    1:    *        Counter for number of times delaying b/c browser or history aren't ready
    1:    */
21415:   restoreHistoryPrecursor:
21415:     function sss_restoreHistoryPrecursor(aWindow, aTabs, aTabData, aSelectTab, aIx, aCount) {
32885:     var tabbrowser = aWindow.gBrowser;
    1: 
    1:     // make sure that all browsers and their histories are available
    1:     // - if one's not, resume this check in 100ms (repeat at most 10 times)
    1:     for (var t = aIx; t < aTabs.length; t++) {
    1:       try {
21415:         if (!tabbrowser.getBrowserForTab(aTabs[t]).webNavigation.sessionHistory) {
    1:           throw new Error();
    1:         }
    1:       }
    1:       catch (ex) { // in case browser or history aren't ready yet 
    1:         if (aCount < 10) {
    1:           var restoreHistoryFunc = function(self) {
21415:             self.restoreHistoryPrecursor(aWindow, aTabs, aTabData, aSelectTab, aIx, aCount + 1);
    1:           }
    1:           aWindow.setTimeout(restoreHistoryFunc, 100, this);
    1:           return;
    1:         }
    1:       }
    1:     }
    1: 
61753:     if (!this._isWindowLoaded(aWindow)) {
61753:       // from now on, the data will come from the actual window
61753:       delete this._statesToRestore[aWindow.__SS_restoreID];
61753:       delete aWindow.__SS_restoreID;
61753:       delete this._windows[aWindow.__SSi]._restoring;
61753:     }
61753: 
61753:     if (aTabs.length == 0) {
61753:       // this is normally done in restoreHistory() but as we're returning early
61753:       // here we need to take care of it.
76934:       this._setWindowStateReady(aWindow);
61753:       return;
61753:     }
61753: 
62496:     let unhiddenTabs = aTabData.filter(function (aData) !aData.hidden).length;
62496: 
62496:     // if all tabs to be restored are hidden, make the first one visible
62496:     if (unhiddenTabs == 0) {
62496:       aTabData[0].hidden = false;
62496:     } else if (aTabs.length > 1) {
51576:       // Load hidden tabs last, by pushing them to the end of the list
62496:       for (let t = 0, tabsToReorder = aTabs.length - unhiddenTabs; tabsToReorder > 0; ) {
54607:         if (aTabData[t].hidden) {
51576:           aTabs = aTabs.concat(aTabs.splice(t, 1));
51576:           aTabData = aTabData.concat(aTabData.splice(t, 1));
51576:           if (aSelectTab > t)
51576:             --aSelectTab;
62496:           --tabsToReorder;
51576:           continue;
51576:         }
51576:         ++t;
51576:       }
51576: 
26151:       // Determine if we can optimize & load visible tabs first
30167:       let maxVisibleTabs = Math.ceil(tabbrowser.tabContainer.mTabstrip.scrollClientSize /
58138:                                      aTabs[unhiddenTabs - 1].getBoundingClientRect().width);
26151: 
26151:       // make sure we restore visible tabs first, if there are enough
51576:       if (maxVisibleTabs < unhiddenTabs && aSelectTab > 1) {
26151:         let firstVisibleTab = 0;
51576:         if (unhiddenTabs - maxVisibleTabs > aSelectTab) {
26151:           // aSelectTab is leftmost since we scroll to it when possible
26151:           firstVisibleTab = aSelectTab - 1;
26151:         } else {
26151:           // aSelectTab is rightmost or no more room to scroll right
51576:           firstVisibleTab = unhiddenTabs - maxVisibleTabs;
26151:         }
26151:         aTabs = aTabs.splice(firstVisibleTab, maxVisibleTabs).concat(aTabs);
26151:         aTabData = aTabData.splice(firstVisibleTab, maxVisibleTabs).concat(aTabData);
26151:         aSelectTab -= firstVisibleTab;
26151:       }
61753:     }
26151: 
    1:     // make sure to restore the selected tab first (if any)
    1:     if (aSelectTab-- && aTabs[aSelectTab]) {
    1:       aTabs.unshift(aTabs.splice(aSelectTab, 1)[0]);
21415:       aTabData.unshift(aTabData.splice(aSelectTab, 1)[0]);
21415:       tabbrowser.selectedTab = aTabs[0];
    1:     }
    1: 
54607:     // Prepare the tabs so that they can be properly restored. We'll pin/unpin
54607:     // and show/hide tabs as necessary. We'll also set the labels, user typed
54607:     // value, and attach a copy of the tab's data in case we close it before
54607:     // it's been restored.
54607:     for (t = 0; t < aTabs.length; t++) {
54607:       let tab = aTabs[t];
54607:       let browser = tabbrowser.getBrowserForTab(tab);
54607:       let tabData = aTabData[t];
54607: 
54607:       if (tabData.pinned)
54607:         tabbrowser.pinTab(tab);
54607:       else
54607:         tabbrowser.unpinTab(tab);
55352: 
55352:       if (tabData.hidden)
55352:         tabbrowser.hideTab(tab);
55352:       else
55352:         tabbrowser.showTab(tab);
54607: 
74566:       for (let name in tabData.attributes)
74566:         this.xulAttributes[name] = true;
74566: 
54607:       tabData._tabStillLoading = true;
54607: 
54607:       // keep the data around to prevent dataloss in case
54607:       // a tab gets closed before it's been properly restored
54607:       browser.__SS_data = tabData;
55807:       browser.__SS_restoreState = TAB_STATE_NEEDS_RESTORE;
78997:       tab.setAttribute("pending", "true");
54607: 
58572:       // Make sure that set/getTabValue will set/read the correct data by
58572:       // wiping out any current value in tab.__SS_extdata.
58572:       delete tab.__SS_extdata;
58572: 
54607:       if (!tabData.entries || tabData.entries.length == 0) {
54607:         // make sure to blank out this tab's content
54607:         // (just purging the tab's history won't be enough)
54607:         browser.contentDocument.location = "about:blank";
54607:         continue;
54607:       }
54607: 
54607:       browser.stop(); // in case about:blank isn't done yet
54607: 
54607:       // wall-paper fix for bug 439675: make sure that the URL to be loaded
54607:       // is always visible in the address bar
54607:       let activeIndex = (tabData.index || tabData.entries.length) - 1;
54607:       let activePageData = tabData.entries[activeIndex] || null;
61590:       let uri = activePageData ? activePageData.url || null : null;
61590:       browser.userTypedValue = uri;
61590: 
61590:       // Also make sure currentURI is set so that switch-to-tab works before
61590:       // the tab is restored. We'll reset this to about:blank when we try to
61590:       // restore the tab to ensure that docshell doeesn't get confused.
61590:       if (uri)
61590:         browser.docShell.setCurrentURI(this._getURIFromString(uri));
54607: 
54607:       // If the page has a title, set it.
54620:       if (activePageData) {
54620:         if (activePageData.title) {
54607:           tab.label = activePageData.title;
54620:           tab.crop = "end";
54620:         } else if (activePageData.url != "about:blank") {
54620:           tab.label = activePageData.url;
54620:           tab.crop = "center";
54620:         }
54620:       }
54607:     }
54607: 
37802:     // helper hashes for ensuring unique frame IDs and unique document
37802:     // identifiers.
 2647:     var idMap = { used: {} };
37802:     var docIdentMap = {};
37802:     this.restoreHistory(aWindow, aTabs, aTabData, idMap, docIdentMap);
    1:   },
    1: 
    1:   /**
    1:    * Restory history for a window
    1:    * @param aWindow
    1:    *        Window reference
    1:    * @param aTabs
21415:    *        Array of tab references
21415:    * @param aTabData
    1:    *        Array of tab data
    1:    * @param aIdMap
    1:    *        Hash for ensuring unique frame IDs
    1:    */
37802:   restoreHistory:
37802:     function sss_restoreHistory(aWindow, aTabs, aTabData, aIdMap, aDocIdentMap) {
    1:     var _this = this;
21415:     while (aTabs.length > 0 && (!aTabData[0]._tabStillLoading || !aTabs[0].parentNode)) {
    1:       aTabs.shift(); // this tab got removed before being completely restored
21415:       aTabData.shift();
    1:     }
    1:     if (aTabs.length == 0) {
59698:       // At this point we're essentially ready for consumers to read/write data
59698:       // via the sessionstore API so we'll send the SSWindowStateReady event.
76934:       this._setWindowStateReady(aWindow);
    1:       return; // no more tabs to restore
    1:     }
    1:     
21415:     var tab = aTabs.shift();
21415:     var tabData = aTabData.shift();
    1: 
32885:     var browser = aWindow.gBrowser.getBrowserForTab(tab);
    1:     var history = browser.webNavigation.sessionHistory;
    1:     
    1:     if (history.count > 0) {
    1:       history.PurgeHistory(history.count);
    1:     }
    1:     history.QueryInterface(Ci.nsISHistoryInternal);
    1: 
54693:     browser.__SS_shistoryListener = new SessionStoreSHistoryListener(this, tab);
54693:     history.addSHistoryListener(browser.__SS_shistoryListener);
54693: 
    1:     if (!tabData.entries) {
    1:       tabData.entries = [];
    1:     }
    1:     if (tabData.extData) {
22462:       tab.__SS_extdata = {};
22462:       for (let key in tabData.extData)
22462:         tab.__SS_extdata[key] = tabData.extData[key];
    1:     }
22462:     else
22462:       delete tab.__SS_extdata;
    1:     
    1:     for (var i = 0; i < tabData.entries.length; i++) {
32330:       //XXXzpao Wallpaper patch for bug 514751
32330:       if (!tabData.entries[i].url)
32330:         continue;
37802:       history.addEntry(this._deserializeHistoryEntry(tabData.entries[i],
37802:                                                      aIdMap, aDocIdentMap), true);
    1:     }
    1:     
    1:     // make sure to reset the capabilities and attributes, in case this tab gets reused
    1:     var disallow = (tabData.disallow)?tabData.disallow.split(","):[];
    1:     CAPABILITIES.forEach(function(aCapability) {
    1:       browser.docShell["allow" + aCapability] = disallow.indexOf(aCapability) == -1;
    1:     });
74566:     for (let name in this.xulAttributes)
74566:       tab.removeAttribute(name);
17048:     for (let name in tabData.attributes)
17048:       tab.setAttribute(name, tabData.attributes[name]);
    1:     
19833:     if (tabData.storage && browser.docShell instanceof Ci.nsIDocShell)
19833:       this._deserializeSessionStorage(tabData.storage, browser.docShell);
19833:     
    1:     // notify the tabbrowser that the tab chrome has been restored
    1:     var event = aWindow.document.createEvent("Events");
    1:     event.initEvent("SSTabRestoring", true, false);
    1:     tab.dispatchEvent(event);
    1: 
54279:     // Restore the history in the next tab
54279:     aWindow.setTimeout(function(){
54279:       _this.restoreHistory(aWindow, aTabs, aTabData, aIdMap, aDocIdentMap);
54279:     }, 0);
54279: 
76378:     // This could cause us to ignore MAX_CONCURRENT_TAB_RESTORES a bit, but
54279:     // it ensures each window will have its selected tab loaded.
54279:     if (aWindow.gBrowser.selectedBrowser == browser) {
54279:       this.restoreTab(tab);
54279:     }
54279:     else {
54279:       // Put the tab into the right bucket
77573:       if (tabData.pinned)
77573:         this._tabsToRestore.priority.push(tab);
77573:       else if (tabData.hidden)
54279:         this._tabsToRestore.hidden.push(tab);
54279:       else
54279:         this._tabsToRestore.visible.push(tab);
54279:       this.restoreNextTab();
54279:     }
54279:   },
54279: 
55807:   /**
55807:    * Restores the specified tab. If the tab can't be restored (eg, no history or
55807:    * calling gotoIndex fails), then state changes will be rolled back.
55807:    * This method will check if gTabsProgressListener is attached to the tab's
55807:    * window, ensuring that we don't get caught without one.
55807:    * This method removes the session history listener right before starting to
55807:    * attempt a load. This will prevent cases of "stuck" listeners.
55807:    * If this method returns false, then it is up to the caller to decide what to
55807:    * do. In the common case (restoreNextTab), we will want to then attempt to
55807:    * restore the next tab. In the other case (selecting the tab, reloading the
55807:    * tab), the caller doesn't actually want to do anything if no page is loaded.
55807:    *
55807:    * @param aTab
55807:    *        the tab to restore
55807:    *
55807:    * @returns true/false indicating whether or not a load actually happened
55807:    */
55807:   restoreTab: function sss_restoreTab(aTab) {
54607:     let window = aTab.ownerDocument.defaultView;
54279:     let browser = aTab.linkedBrowser;
54279:     let tabData = browser.__SS_data;
54279: 
55807:     // There are cases within where we haven't actually started a load. In that
55807:     // that case we'll reset state changes we made and return false to the caller
55807:     // can handle appropriately.
55807:     let didStartLoad = false;
55807: 
55807:     // Make sure that the tabs progress listener is attached to this window
55807:     this._ensureTabsProgressListener(window);
55807: 
55807:     // Make sure that this tab is removed from _tabsToRestore
55807:     this._removeTabFromTabsToRestore(aTab);
54279: 
54279:     // Increase our internal count.
54279:     this._tabsRestoringCount++;
54279: 
55807:     // Set this tab's state to restoring
55807:     browser.__SS_restoreState = TAB_STATE_RESTORING;
78997:     aTab.removeAttribute("pending");
55807: 
55807:     // Remove the history listener, since we no longer need it once we start restoring
55807:     this._removeSHistoryListener(aTab);
54279: 
18879:     let activeIndex = (tabData.index || tabData.entries.length) - 1;
18879:     if (activeIndex >= tabData.entries.length)
18879:       activeIndex = tabData.entries.length - 1;
68795:     // Reset currentURI.  This creates a new session history entry with a new
68795:     // doc identifier, so we need to explicitly save and restore the old doc
68795:     // identifier (corresponding to the SHEntry at activeIndex) below.
61590:     browser.webNavigation.setCurrentURI(this._getURIFromString("about:blank"));
54279:     // Attach data that will be restored on "load" event, after tab is restored.
54279:     if (activeIndex > -1) {
54279:       // restore those aspects of the currently active documents which are not
54279:       // preserved in the plain history entries (mainly scroll state and text data)
54279:       browser.__SS_restore_data = tabData.entries[activeIndex] || {};
54279:       browser.__SS_restore_pageStyle = tabData.pageStyle || "";
54279:       browser.__SS_restore_tab = aTab;
80309:       browser.__SS_restore_docIdentifier = curSHEntry.docIdentifier;
56132:       didStartLoad = true;
17158:       try {
59695:         // In order to work around certain issues in session history, we need to
59695:         // force session history to update its internal index and call reload
68731:         // instead of gotoIndex. See bug 597315.
59695:         browser.webNavigation.sessionHistory.getEntryAtIndex(activeIndex, true);
72412:         browser.webNavigation.sessionHistory.reloadCurrentEntry();
17158:       }
18879:       catch (ex) {
18879:         // ignore page load errors
54279:         aTab.removeAttribute("busy");
56132:         didStartLoad = false;
55807:       }
18879:     }
    1: 
34841:     // Handle userTypedValue. Setting userTypedValue seems to update gURLbar
54279:     // as needed. Calling loadURI will cancel form filling in restoreDocument
34841:     if (tabData.userTypedValue) {
34841:       browser.userTypedValue = tabData.userTypedValue;
54279:       if (tabData.userTypedClear) {
58570:         // Make it so that we'll enter restoreDocument on page load. We will
58570:         // fire SSTabRestored from there. We don't have any form data to restore
58570:         // so we can just set the URL to null.
58570:         browser.__SS_restore_data = { url: null };
58570:         browser.__SS_restore_tab = aTab;
73799:         if (didStartLoad)
73799:           browser.stop();
55807:         didStartLoad = true;
73799:         browser.loadURIWithFlags(tabData.userTypedValue,
73799:                                  Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP);
34841:       }
55807:     }
55807: 
55807:     // If we didn't start a load, then we won't reset this tab through the usual
58570:     // channel (via the progress listener), so reset the tab ourselves. We will
58570:     // also send SSTabRestored since this tab has technically been restored.
58570:     if (!didStartLoad) {
58570:       this._sendTabRestoredNotification(aTab);
55807:       this._resetTabRestoringState(aTab);
58570:     }
55807: 
55807:     return didStartLoad;
54279:   },
54279: 
55807:   /**
55807:    * This _attempts_ to restore the next available tab. If the restore fails,
55807:    * then we will attempt the next one.
55807:    * There are conditions where this won't do anything:
55807:    *   if we're in the process of quitting
55807:    *   if there are no tabs to restore
55807:    *   if we have already reached the limit for number of tabs to restore
55807:    */
55807:   restoreNextTab: function sss_restoreNextTab() {
54279:     // If we call in here while quitting, we don't actually want to do anything
54279:     if (this._loadState == STATE_QUITTING)
54279:       return;
54279: 
54279:     // If it's not possible to restore anything, then just bail out.
77573:     if ((!this._tabsToRestore.priority.length && this._restoreOnDemand) ||
76378:         this._tabsRestoringCount >= MAX_CONCURRENT_TAB_RESTORES)
54279:       return;
54279: 
77573:     // Look in priority, then visible, then hidden
54279:     let nextTabArray;
77573:     if (this._tabsToRestore.priority.length) {
77573:       nextTabArray = this._tabsToRestore.priority
77573:     }
77573:     else if (this._tabsToRestore.visible.length) {
54279:       nextTabArray = this._tabsToRestore.visible;
54279:     }
70123:     else if (this._restoreHiddenTabs && this._tabsToRestore.hidden.length) {
54279:       nextTabArray = this._tabsToRestore.hidden;
54279:     }
54279: 
54279:     if (nextTabArray) {
54279:       let tab = nextTabArray.shift();
55807:       let didStartLoad = this.restoreTab(tab);
55807:       // If we don't start a load in the restored tab (eg, no entries) then we
55807:       // want to attempt to restore the next tab.
55807:       if (!didStartLoad)
55807:         this.restoreNextTab();
54279:     }
    1:   },
    1: 
    1:   /**
    1:    * expands serialized history data into a session-history-entry instance
    1:    * @param aEntry
    1:    *        Object containing serialized history data for a URL
    1:    * @param aIdMap
    1:    *        Hash for ensuring unique frame IDs
    1:    * @returns nsISHEntry
    1:    */
37802:   _deserializeHistoryEntry:
37802:     function sss_deserializeHistoryEntry(aEntry, aIdMap, aDocIdentMap) {
37802: 
    1:     var shEntry = Cc["@mozilla.org/browser/session-history-entry;1"].
    1:                   createInstance(Ci.nsISHEntry);
    1: 
39650:     shEntry.setURI(this._getURIFromString(aEntry.url));
    1:     shEntry.setTitle(aEntry.title || aEntry.url);
 6913:     if (aEntry.subframe)
    1:       shEntry.setIsSubFrame(aEntry.subframe || false);
    1:     shEntry.loadType = Ci.nsIDocShellLoadInfo.loadHistory;
 6913:     if (aEntry.contentType)
 6007:       shEntry.contentType = aEntry.contentType;
29350:     if (aEntry.referrer)
39650:       shEntry.referrerURI = this._getURIFromString(aEntry.referrer);
    1: 
    1:     if (aEntry.cacheKey) {
    1:       var cacheKey = Cc["@mozilla.org/supports-PRUint32;1"].
    1:                      createInstance(Ci.nsISupportsPRUint32);
    1:       cacheKey.data = aEntry.cacheKey;
    1:       shEntry.cacheKey = cacheKey;
    1:     }
 6913: 
    1:     if (aEntry.ID) {
    1:       // get a new unique ID for this frame (since the one from the last
    1:       // start might already be in use)
    1:       var id = aIdMap[aEntry.ID] || 0;
    1:       if (!id) {
68410:         for (id = Date.now(); id in aIdMap.used; id++);
    1:         aIdMap[aEntry.ID] = id;
    1:         aIdMap.used[id] = true;
    1:       }
    1:       shEntry.ID = id;
    1:     }
    1: 
59695:     if (aEntry.docshellID)
59695:       shEntry.docshellID = aEntry.docshellID;
59695: 
69563:     if (aEntry.structuredCloneState && aEntry.structuredCloneVersion) {
69563:       shEntry.stateData =
69563:         Cc["@mozilla.org/docshell/structured-clone-container;1"].
69563:         createInstance(Ci.nsIStructuredCloneContainer);
69563: 
69563:       shEntry.stateData.initFromBase64(aEntry.structuredCloneState,
69563:                                        aEntry.structuredCloneVersion);
37802:     }
37802: 
 6913:     if (aEntry.scroll) {
    1:       var scrollPos = (aEntry.scroll || "0,0").split(",");
    1:       scrollPos = [parseInt(scrollPos[0]) || 0, parseInt(scrollPos[1]) || 0];
    1:       shEntry.setScrollPosition(scrollPos[0], scrollPos[1]);
 6913:     }
    1: 
39463:     if (aEntry.postdata_b64) {
39463:       var postdata = atob(aEntry.postdata_b64);
    1:       var stream = Cc["@mozilla.org/io/string-input-stream;1"].
    1:                    createInstance(Ci.nsIStringInputStream);
 6007:       stream.setData(postdata, postdata.length);
    1:       shEntry.postData = stream;
    1:     }
    1: 
37802:     if (aEntry.docIdentifier) {
80309:       // Get a new document identifier for this entry to ensure that history
80309:       // entries after a session restore are considered to have different
80309:       // documents from the history entries before the session restore.
80309:       // Document identifiers are 64-bit ints, so JS will loose precision and
80309:       // start assigning all entries the same doc identifier if these ever get
80309:       // large enough.
80309:       //
80309:       // It's a potential security issue if document identifiers aren't
80309:       // globally unique, but shEntry.setUniqueDocIdentifier() below guarantees
80309:       // that we won't re-use a doc identifier within a given instance of the
80309:       // application.
80309:       let ident = aDocIdentMap[aEntry.docIdentifier];
80309:       if (!ident) {
80309:         shEntry.setUniqueDocIdentifier();
80309:         aDocIdentMap[aEntry.docIdentifier] = shEntry.docIdentifier;
37802:       }
37802:       else {
80309:         shEntry.docIdentifier = ident;
37802:       }
37802:     }
37802: 
39463:     if (aEntry.owner_b64) {
 6007:       var ownerInput = Cc["@mozilla.org/io/string-input-stream;1"].
 6007:                        createInstance(Ci.nsIStringInputStream);
 6007:       var binaryData = atob(aEntry.owner_b64);
 6007:       ownerInput.setData(binaryData, binaryData.length);
 6007:       var binaryStream = Cc["@mozilla.org/binaryinputstream;1"].
 6007:                          createInstance(Ci.nsIObjectInputStream);
 6007:       binaryStream.setInputStream(ownerInput);
 6007:       try { // Catch possible deserialization exceptions
 6007:         shEntry.owner = binaryStream.readObject(true);
 6007:       } catch (ex) { debug(ex); }
 6007:     }
 6007: 
    1:     if (aEntry.children && shEntry instanceof Ci.nsISHContainer) {
    1:       for (var i = 0; i < aEntry.children.length; i++) {
32330:         //XXXzpao Wallpaper patch for bug 514751
32330:         if (!aEntry.children[i].url)
32330:           continue;
37802:         shEntry.AddChild(this._deserializeHistoryEntry(aEntry.children[i], aIdMap,
37802:                                                        aDocIdentMap), i);
    1:       }
    1:     }
    1:     
    1:     return shEntry;
    1:   },
    1: 
    1:   /**
19833:    * restores all sessionStorage "super cookies"
19833:    * @param aStorageData
19833:    *        Storage data to be restored
19833:    * @param aDocShell
19833:    *        A tab's docshell (containing the sessionStorage)
19833:    */
19833:   _deserializeSessionStorage: function sss_deserializeSessionStorage(aStorageData, aDocShell) {
19833:     for (let url in aStorageData) {
39650:       let uri = this._getURIFromString(url);
37608:       let storage = aDocShell.getSessionStorageForURI(uri, "");
19833:       for (let key in aStorageData[url]) {
19833:         try {
28676:           storage.setItem(key, aStorageData[url][key]);
19833:         }
19833:         catch (ex) { Cu.reportError(ex); } // throws e.g. for URIs that can't have sessionStorage
19833:       }
19833:     }
19833:   },
19833: 
19833:   /**
    1:    * Restore properties to a loaded document
    1:    */
39464:   restoreDocument: function sss_restoreDocument(aWindow, aBrowser, aEvent) {
    1:     // wait for the top frame to be loaded completely
    1:     if (!aEvent || !aEvent.originalTarget || !aEvent.originalTarget.defaultView || aEvent.originalTarget.defaultView != aEvent.originalTarget.defaultView.top) {
    1:       return;
    1:     }
    1: 
21763:     // always call this before injecting content into a document!
21763:     function hasExpectedURL(aDocument, aURL)
21763:       !aURL || aURL.replace(/#.*/, "") == aDocument.location.href.replace(/#.*/, "");
21763: 
21763:     function restoreFormData(aDocument, aData, aURL) {
18836:       for (let key in aData) {
21763:         if (!hasExpectedURL(aDocument, aURL))
21763:           return;
21763: 
18836:         let node = key.charAt(0) == "#" ? aDocument.getElementById(key.slice(1)) :
18836:                                           XPathHelper.resolve(aDocument, key);
18836:         if (!node)
18836:           continue;
18836: 
18836:         let value = aData[key];
22800:         if (typeof value == "string" && node.type != "file") {
24732:           if (node.value == value)
24732:             continue; // don't dispatch an input event for no change
24732: 
18836:           node.value = value;
18836: 
18836:           let event = aDocument.createEvent("UIEvents");
18836:           event.initUIEvent("input", true, true, aDocument.defaultView, 0);
18836:           node.dispatchEvent(event);
18836:         }
18836:         else if (typeof value == "boolean")
18836:           node.checked = value;
18836:         else if (typeof value == "number")
18836:           try {
18836:             node.selectedIndex = value;
18836:           } catch (ex) { /* throws for invalid indices */ }
34164:         else if (value && value.fileList && value.type == "file" && node.type == "file")
34164:           node.mozSetFileNameArray(value.fileList, value.fileList.length);
18836:         else if (value && typeof value.indexOf == "function" && node.options) {
18836:           Array.forEach(node.options, function(aOpt, aIx) {
18836:             aOpt.selected = value.indexOf(aIx) > -1;
18836:           });
18836:         }
18836:         // NB: dispatching "change" events might have unintended side-effects
18836:       }
18836:     }
18836: 
39464:     let selectedPageStyle = aBrowser.__SS_restore_pageStyle;
    1:     function restoreTextDataAndScrolling(aContent, aData, aPrefix) {
18836:       if (aData.formdata)
21763:         restoreFormData(aContent.document, aData.formdata, aData.url);
    1:       if (aData.innerHTML) {
39464:         aWindow.setTimeout(function() {
21763:           if (aContent.document.designMode == "on" &&
21763:               hasExpectedURL(aContent.document, aData.url)) {
21763:             aContent.document.body.innerHTML = aData.innerHTML;
20763:           }
21763:         }, 0);
    1:       }
41351:       var match;
41351:       if (aData.scroll && (match = /(\d+),(\d+)/.exec(aData.scroll)) != null) {
41351:         aContent.scrollTo(match[1], match[2]);
    1:       }
20034:       Array.forEach(aContent.document.styleSheets, function(aSS) {
20034:         aSS.disabled = aSS.title && aSS.title != selectedPageStyle;
20034:       });
    1:       for (var i = 0; i < aContent.frames.length; i++) {
21763:         if (aData.children && aData.children[i] &&
21763:           hasExpectedURL(aContent.document, aData.url)) {
21704:           restoreTextDataAndScrolling(aContent.frames[i], aData.children[i], aPrefix + i + "|");
    1:         }
    1:       }
    1:     }
    1: 
18880:     // don't restore text data and scrolling state if the user has navigated
18880:     // away before the loading completed (except for in-page navigation)
39464:     if (hasExpectedURL(aEvent.originalTarget, aBrowser.__SS_restore_data.url)) {
    1:       var content = aEvent.originalTarget.defaultView;
39464:       restoreTextDataAndScrolling(content, aBrowser.__SS_restore_data, "");
39464:       aBrowser.markupDocumentViewer.authorStyleDisabled = selectedPageStyle == "_nostyle";
58570:     }
    1: 
80309:     if (aBrowser.__SS_restore_docIdentifier) {
80309:       let sh = aBrowser.webNavigation.sessionHistory;
80309:       sh.getEntryAtIndex(sh.index, false).QueryInterface(Ci.nsISHEntry).
80309:          docIdentifier = aBrowser.__SS_restore_docIdentifier;
80309:     }
80309: 
    1:     // notify the tabbrowser that this document has been completely restored
58570:     this._sendTabRestoredNotification(aBrowser.__SS_restore_tab);
    1: 
39464:     delete aBrowser.__SS_restore_data;
39464:     delete aBrowser.__SS_restore_pageStyle;
39464:     delete aBrowser.__SS_restore_tab;
80309:     delete aBrowser.__SS_restore_docIdentifier;
    1:   },
    1: 
    1:   /**
    1:    * Restore visibility and dimension features to a window
    1:    * @param aWindow
    1:    *        Window reference
    1:    * @param aWinData
    1:    *        Object containing session data for the window
    1:    */
 6431:   restoreWindowFeatures: function sss_restoreWindowFeatures(aWindow, aWinData) {
    1:     var hidden = (aWinData.hidden)?aWinData.hidden.split(","):[];
    1:     WINDOW_HIDEABLE_FEATURES.forEach(function(aItem) {
    1:       aWindow[aItem].visible = hidden.indexOf(aItem) == -1;
    1:     });
    1:     
30745:     if (aWinData.isPopup) {
18833:       this._windows[aWindow.__SSi].isPopup = true;
30745:       if (aWindow.gURLBar) {
30745:         aWindow.gURLBar.readOnly = true;
30745:         aWindow.gURLBar.setAttribute("enablehistory", "false");
30745:       }
30745:     }
30745:     else {
18833:       delete this._windows[aWindow.__SSi].isPopup;
30745:       if (aWindow.gURLBar) {
30745:         aWindow.gURLBar.readOnly = false;
30745:         aWindow.gURLBar.setAttribute("enablehistory", "true");
30745:       }
30745:     }
18833: 
    1:     var _this = this;
    1:     aWindow.setTimeout(function() {
 6431:       _this.restoreDimensions.apply(_this, [aWindow, aWinData.width || 0, 
    1:         aWinData.height || 0, "screenX" in aWinData ? aWinData.screenX : NaN,
    1:         "screenY" in aWinData ? aWinData.screenY : NaN,
    1:         aWinData.sizemode || "", aWinData.sidebar || ""]);
    1:     }, 0);
    1:   },
    1: 
    1:   /**
    1:    * Restore a window's dimensions
    1:    * @param aWidth
    1:    *        Window width
    1:    * @param aHeight
    1:    *        Window height
    1:    * @param aLeft
    1:    *        Window left
    1:    * @param aTop
    1:    *        Window top
    1:    * @param aSizeMode
    1:    *        Window size mode (eg: maximized)
    1:    * @param aSidebar
    1:    *        Sidebar command
    1:    */
 6431:   restoreDimensions: function sss_restoreDimensions(aWindow, aWidth, aHeight, aLeft, aTop, aSizeMode, aSidebar) {
    1:     var win = aWindow;
    1:     var _this = this;
    1:     function win_(aName) { return _this._getWindowDimension(win, aName); }
    1:     
    1:     // only modify those aspects which aren't correct yet
    1:     if (aWidth && aHeight && (aWidth != win_("width") || aHeight != win_("height"))) {
    1:       aWindow.resizeTo(aWidth, aHeight);
    1:     }
    1:     if (!isNaN(aLeft) && !isNaN(aTop) && (aLeft != win_("screenX") || aTop != win_("screenY"))) {
    1:       aWindow.moveTo(aLeft, aTop);
    1:     }
24996:     if (aSizeMode && win_("sizemode") != aSizeMode)
24996:     {
22798:       switch (aSizeMode)
22798:       {
22798:       case "maximized":
    1:         aWindow.maximize();
24996:         break;
22798:       case "minimized":
22798:         aWindow.minimize();
24996:         break;
24996:       case "normal":
    1:         aWindow.restore();
24996:         break;
24996:       }
    1:     }
    1:     var sidebar = aWindow.document.getElementById("sidebar-box");
    1:     if (sidebar.getAttribute("sidebarcommand") != aSidebar) {
    1:       aWindow.toggleSidebar(aSidebar);
    1:     }
    1:     // since resizing/moving a window brings it to the foreground,
 6431:     // we might want to re-focus the last focused window
32068:     if (this.windowToFocus && this.windowToFocus.content) {
18878:       this.windowToFocus.content.focus();
    1:     }
    1:   },
    1: 
    1:   /**
39463:    * Restores cookies
    1:    * @param aCookies
 2811:    *        Array of cookie objects
    1:    */
    1:   restoreCookies: function sss_restoreCookies(aCookies) {
 2811:     // MAX_EXPIRY should be 2^63-1, but JavaScript can't handle that precision
 2811:     var MAX_EXPIRY = Math.pow(2, 62);
39634:     for (let i = 0; i < aCookies.length; i++) {
 2811:       var cookie = aCookies[i];
    1:       try {
36318:         CookieSvc.add(cookie.host, cookie.path || "", cookie.name || "",
36318:                       cookie.value, !!cookie.secure, !!cookie.httponly, true,
36318:                       "expiry" in cookie ? cookie.expiry : MAX_EXPIRY);
    1:       }
 5152:       catch (ex) { Cu.reportError(ex); } // don't let a single cookie stop recovering
    1:     }
    1:   },
    1: 
    1: /* ........ Disk Access .............. */
    1: 
    1:   /**
    1:    * save state delayed by N ms
    1:    * marks window as dirty (i.e. data update can't be skipped)
    1:    * @param aWindow
    1:    *        Window reference
    1:    * @param aDelay
    1:    *        Milliseconds to delay
    1:    */
    1:   saveStateDelayed: function sss_saveStateDelayed(aWindow, aDelay) {
    1:     if (aWindow) {
    1:       this._dirtyWindows[aWindow.__SSi] = true;
    1:     }
    1: 
51017:     if (!this._saveTimer && !this._inPrivateBrowsing) {
    1:       // interval until the next disk operation is allowed
    1:       var minimalDelay = this._lastSaveTime + this._interval - Date.now();
    1:       
    1:       // if we have to wait, set a timer, otherwise saveState directly
    1:       aDelay = Math.max(minimalDelay, aDelay || 2000);
    1:       if (aDelay > 0) {
    1:         this._saveTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
    1:         this._saveTimer.init(this, aDelay, Ci.nsITimer.TYPE_ONE_SHOT);
    1:       }
    1:       else {
    1:         this.saveState();
    1:       }
    1:     }
    1:   },
    1: 
    1:   /**
    1:    * save state to disk
    1:    * @param aUpdateAll
    1:    *        Bool update all windows 
    1:    */
    1:   saveState: function sss_saveState(aUpdateAll) {
21242:     // if we're in private browsing mode, do nothing
21242:     if (this._inPrivateBrowsing)
21242:       return;
21242: 
52403:     // If crash recovery is disabled, we only want to resume with pinned tabs
52403:     // if we crash.
52403:     let pinnedOnly = this._loadState == STATE_RUNNING && !this._resume_from_crash;
51017: 
51017:     var oState = this._getCurrentState(aUpdateAll, pinnedOnly);
51017:     if (!oState)
51017:       return;
51017: 
72193: #ifndef XP_MACOSX
72193:     // We want to restore closed windows that are marked with _shouldRestore.
72193:     // We're doing this here because we want to control this only when saving
72193:     // the file.
72193:     while (oState._closedWindows.length) {
72193:       let i = oState._closedWindows.length - 1;
72193:       if (oState._closedWindows[i]._shouldRestore) {
72193:         oState.windows.unshift(oState._closedWindows.pop());
72193:       }
72193:       else {
72193:         // We only need to go until we hit !needsRestore since we're going in reverse
72193:         break;
72193:       }
72193:     }
72193: #endif
72193: 
55806:     if (pinnedOnly) {
55806:       // Save original resume_session_once preference for when quiting browser,
55806:       // otherwise session will be restored next time browser starts and we
55806:       // only want it to be restored in the case of a crash.
55806:       if (this._resume_session_once_on_shutdown == null) {
55806:         this._resume_session_once_on_shutdown =
55806:           this._prefBranch.getBoolPref("sessionstore.resume_session_once");
51017:         this._prefBranch.setBoolPref("sessionstore.resume_session_once", true);
55806:         // flush the preference file so preference will be saved in case of a crash
55806:         Services.prefs.savePrefFile(null);
55806:       }
55806:     }
51017: 
78045:     oState.session = {
78045:       state: this._loadState == STATE_RUNNING ? STATE_RUNNING_STR : STATE_STOPPED_STR,
78045:       lastUpdate: Date.now(),
78045:       startTime: this._sessionStartTime
78045:     };
78045:     if (this._recentCrashes)
78045:       oState.session.recentCrashes = this._recentCrashes;
78045: 
74895:     // Persist the last session if we deferred restoring it
74895:     if (this._lastSessionState)
74895:       oState.lastSessionState = this._lastSessionState;
74895: 
21242:     this._saveStateObject(oState);
21242:   },
21242: 
21242:   /**
21242:    * write a state object to disk
21242:    */
21242:   _saveStateObject: function sss_saveStateObject(aStateObj) {
17138:     var stateString = Cc["@mozilla.org/supports-string;1"].
17138:                         createInstance(Ci.nsISupportsString);
43419:     stateString.data = this._toJSONString(aStateObj);
17138: 
39650:     Services.obs.notifyObservers(stateString, "sessionstore-state-write", "");
17138: 
17138:     // don't touch the file if an observer has deleted all state data
17138:     if (stateString.data)
17138:       this._writeFile(this._sessionFile, stateString.data);
17138: 
    1:     this._lastSaveTime = Date.now();
    1:   },
    1: 
    1:   /**
    1:    * delete session datafile and backup
    1:    */
    1:   _clearDisk: function sss_clearDisk() {
    1:     if (this._sessionFile.exists()) {
    1:       try {
    1:         this._sessionFile.remove(false);
    1:       }
    1:       catch (ex) { dump(ex + '\n'); } // couldn't remove the file - what now?
    1:     }
    1:     if (this._sessionFileBackup.exists()) {
    1:       try {
    1:         this._sessionFileBackup.remove(false);
    1:       }
    1:       catch (ex) { dump(ex + '\n'); } // couldn't remove the file - what now?
    1:     }
    1:   },
    1: 
    1: /* ........ Auxiliary Functions .............. */
    1: 
    1:   /**
    1:    * call a callback for all currently opened browser windows
    1:    * (might miss the most recent one)
    1:    * @param aFunc
    1:    *        Callback each window is passed to
    1:    */
    1:   _forEachBrowserWindow: function sss_forEachBrowserWindow(aFunc) {
39650:     var windowsEnum = Services.wm.getEnumerator("navigator:browser");
    1:     
    1:     while (windowsEnum.hasMoreElements()) {
    1:       var window = windowsEnum.getNext();
34827:       if (window.__SSi && !window.closed) {
    1:         aFunc.call(this, window);
    1:       }
    1:     }
    1:   },
    1: 
    1:   /**
    1:    * Returns most recent window
    1:    * @returns Window reference
    1:    */
    1:   _getMostRecentBrowserWindow: function sss_getMostRecentBrowserWindow() {
39650:     var win = Services.wm.getMostRecentWindow("navigator:browser");
34827:     if (!win)
34827:       return null;
34827:     if (!win.closed)
34827:       return win;
34827: 
34827: #ifdef BROKEN_WM_Z_ORDER
34827:     win = null;
39650:     var windowsEnum = Services.wm.getEnumerator("navigator:browser");
34827:     // this is oldest to newest, so this gets a bit ugly
34827:     while (windowsEnum.hasMoreElements()) {
34827:       let nextWin = windowsEnum.getNext();
34827:       if (!nextWin.closed)
34827:         win = nextWin;
34827:     }
34827:     return win;
34827: #else
36318:     var windowsEnum =
39650:       Services.wm.getZOrderDOMWindowEnumerator("navigator:browser", true);
34827:     while (windowsEnum.hasMoreElements()) {
34827:       win = windowsEnum.getNext();
34827:       if (!win.closed)
34827:         return win;
34827:     }
34827:     return null;
34827: #endif
    1:   },
    1: 
    1:   /**
35664:    * Calls onClose for windows that are determined to be closed but aren't
35664:    * destroyed yet, which would otherwise cause getBrowserState and
35664:    * setBrowserState to treat them as open windows.
35664:    */
35664:   _handleClosedWindows: function sss_handleClosedWindows() {
39650:     var windowsEnum = Services.wm.getEnumerator("navigator:browser");
35664: 
35664:     while (windowsEnum.hasMoreElements()) {
35664:       var window = windowsEnum.getNext();
35664:       if (window.closed) {
35664:         this.onClose(window);
35664:       }
35664:     }
35664:   },
35664: 
35664:   /**
    1:    * open a new browser window for a given session state
    1:    * called when restoring a multi-window session
    1:    * @param aState
    1:    *        Object containing session data
    1:    */
    1:   _openWindowWithState: function sss_openWindowWithState(aState) {
    1:     var argString = Cc["@mozilla.org/supports-string;1"].
    1:                     createInstance(Ci.nsISupportsString);
    1:     argString.data = "";
    1: 
36317:     // Build feature string
36317:     let features = "chrome,dialog=no,all";
36317:     let winState = aState.windows[0];
36317:     WINDOW_ATTRIBUTES.forEach(function(aFeature) {
36317:       // Use !isNaN as an easy way to ignore sizemode and check for numbers
36317:       if (aFeature in winState && !isNaN(winState[aFeature]))
36317:         features += "," + aFeature + "=" + winState[aFeature];
36317:     });
36317: 
36318:     var window =
39650:       Services.ww.openWindow(null, this._prefBranch.getCharPref("chromeURL"),
36318:                              "_blank", features, argString);
    1: 
25810:     do {
25810:       var ID = "window" + Math.random();
25810:     } while (ID in this._statesToRestore);
25810:     this._statesToRestore[(window.__SS_restoreID = ID)] = aState;
 6431: 
 6431:     return window;
    1:   },
    1: 
    1:   /**
55807:    * Gets the tab for the given browser. This should be marginally better
55807:    * than using tabbrowser's getTabForContentWindow. This assumes the browser
55807:    * is the linkedBrowser of a tab, not a dangling browser.
55807:    *
55807:    * @param aBrowser
55807:    *        The browser from which to get the tab.
55807:    */
55807:   _getTabForBrowser: function sss_getTabForBrowser(aBrowser) {
55807:     let window = aBrowser.ownerDocument.defaultView;
55807:     for (let i = 0; i < window.gBrowser.tabs.length; i++) {
55807:       let tab = window.gBrowser.tabs[i];
55807:       if (tab.linkedBrowser == aBrowser)
55807:         return tab;
55807:     }
55807:   },
55807: 
55807: 
55807:   /**
    1:    * Whether or not to resume session, if not recovering from a crash.
    1:    * @returns bool
    1:    */
    1:   _doResumeSession: function sss_doResumeSession() {
    1:     return this._prefBranch.getIntPref("startup.page") == 3 ||
    1:            this._prefBranch.getBoolPref("sessionstore.resume_session_once");
    1:   },
    1: 
    1:   /**
    1:    * whether the user wants to load any other page at startup
    1:    * (except the homepage) - needed for determining whether to overwrite the current tabs
    1:    * C.f.: nsBrowserContentHandler's defaultArgs implementation.
    1:    * @returns bool
    1:    */
51017:   _isCmdLineEmpty: function sss_isCmdLineEmpty(aWindow, aState) {
51017:     var pinnedOnly = aState.windows &&
51017:                      aState.windows.every(function (win)
51017:                        win.tabs.every(function (tab) tab.pinned));
51017: 
51017:     if (!pinnedOnly) {
51017:       let defaultArgs = Cc["@mozilla.org/browser/clh;1"].
    1:                         getService(Ci.nsIBrowserHandler).defaultArgs;
51017:       if (aWindow.arguments &&
51017:           aWindow.arguments[0] &&
    1:           aWindow.arguments[0] == defaultArgs)
    1:         aWindow.arguments[0] = null;
51017:     }
    1: 
    1:     return !aWindow.arguments || !aWindow.arguments[0];
    1:   },
    1: 
    1:   /**
    1:    * don't save sensitive data if the user doesn't want to
    1:    * (distinguishes between encrypted and non-encrypted sites)
    1:    * @param aIsHTTPS
    1:    *        Bool is encrypted
52403:    * @param aUseDefaultPref
52403:    *        don't do normal check for deferred
    1:    * @returns bool
    1:    */
52403:   _checkPrivacyLevel: function sss_checkPrivacyLevel(aIsHTTPS, aUseDefaultPref) {
52403:     let pref = "sessionstore.privacy_level";
52403:     // If we're in the process of quitting and we're not autoresuming the session
52403:     // then we should treat it as a deferred session. We have a different privacy
52403:     // pref for that case.
52403:     if (!aUseDefaultPref && this._loadState == STATE_QUITTING && !this._doResumeSession())
52403:       pref = "sessionstore.privacy_level_deferred";
52403:     return this._prefBranch.getIntPref(pref) < (aIsHTTPS ? PRIVACY_ENCRYPTED : PRIVACY_FULL);
    1:   },
    1: 
    1:   /**
    1:    * on popup windows, the XULWindow's attributes seem not to be set correctly
    1:    * we use thus JSDOMWindow attributes for sizemode and normal window attributes
    1:    * (and hope for reasonable values when maximized/minimized - since then
    1:    * outerWidth/outerHeight aren't the dimensions of the restored window)
    1:    * @param aWindow
    1:    *        Window reference
    1:    * @param aAttribute
    1:    *        String sizemode | width | height | other window attribute
    1:    * @returns string
    1:    */
    1:   _getWindowDimension: function sss_getWindowDimension(aWindow, aAttribute) {
    1:     if (aAttribute == "sizemode") {
    1:       switch (aWindow.windowState) {
30075:       case aWindow.STATE_FULLSCREEN:
    1:       case aWindow.STATE_MAXIMIZED:
    1:         return "maximized";
    1:       case aWindow.STATE_MINIMIZED:
    1:         return "minimized";
    1:       default:
    1:         return "normal";
    1:       }
    1:     }
    1:     
    1:     var dimension;
    1:     switch (aAttribute) {
    1:     case "width":
    1:       dimension = aWindow.outerWidth;
    1:       break;
    1:     case "height":
    1:       dimension = aWindow.outerHeight;
    1:       break;
    1:     default:
    1:       dimension = aAttribute in aWindow ? aWindow[aAttribute] : "";
    1:       break;
    1:     }
    1:     
    1:     if (aWindow.windowState == aWindow.STATE_NORMAL) {
    1:       return dimension;
    1:     }
    1:     return aWindow.document.documentElement.getAttribute(aAttribute) || dimension;
    1:   },
    1: 
    1:   /**
    1:    * Get nsIURI from string
    1:    * @param string
    1:    * @returns nsIURI
    1:    */
    1:   _getURIFromString: function sss_getURIFromString(aString) {
39650:     return Services.io.newURI(aString, null, null);
    1:   },
    1: 
    1:   /**
 3394:    * Annotate a breakpad crash report with the currently selected tab's URL.
 3394:    */
 3394:   _updateCrashReportURL: function sss_updateCrashReportURL(aWindow) {
36318: #ifdef MOZ_CRASH_REPORTER
 3454:     try {
32885:       var currentURI = aWindow.gBrowser.currentURI.clone();
17131:       // if the current URI contains a username/password, remove it
17131:       try {
17131:         currentURI.userPass = "";
17131:       }
17131:       catch (ex) { } // ignore failures on about: URIs
17131: 
36318:       CrashReporter.annotateCrashReport("URL", currentURI.spec);
 3394:     }
 7212:     catch (ex) {
 7212:       // don't make noise when crashreporter is built but not enabled
 7212:       if (ex.result != Components.results.NS_ERROR_NOT_INITIALIZED)
 7212:         debug(ex);
 7212:     }
36318: #endif
 3394:   },
 3394: 
 3394:   /**
20449:    * @param aState is a session state
20449:    * @param aRecentCrashes is the number of consecutive crashes
20449:    * @returns whether a restore page will be needed for the session state
20449:    */
20449:   _needsRestorePage: function sss_needsRestorePage(aState, aRecentCrashes) {
20449:     const SIX_HOURS_IN_MS = 6 * 60 * 60 * 1000;
20449:     
27393:     // don't display the page when there's nothing to restore
27393:     let winData = aState.windows || null;
27393:     if (!winData || winData.length == 0)
27393:       return false;
27393:     
20449:     // don't wrap a single about:sessionrestore page
27393:     if (winData.length == 1 && winData[0].tabs &&
20449:         winData[0].tabs.length == 1 && winData[0].tabs[0].entries &&
20449:         winData[0].tabs[0].entries.length == 1 &&
20449:         winData[0].tabs[0].entries[0].url == "about:sessionrestore")
20449:       return false;
20449:     
20843:     // don't automatically restore in Safe Mode
39650:     if (Services.appinfo.inSafeMode)
20843:       return true;
20843:     
20449:     let max_resumed_crashes =
20449:       this._prefBranch.getIntPref("sessionstore.max_resumed_crashes");
20449:     let sessionAge = aState.session && aState.session.lastUpdate &&
20449:                      (Date.now() - aState.session.lastUpdate);
20449:     
20449:     return max_resumed_crashes != -1 &&
20449:            (aRecentCrashes > max_resumed_crashes ||
20449:             sessionAge && sessionAge >= SIX_HOURS_IN_MS);
20449:   },
20449: 
20449:   /**
61591:    * Determine if the tab state we're passed is something we should save. This
61591:    * is used when closing a tab or closing a window with a single tab
61591:    *
61591:    * @param aTabState
61591:    *        The current tab state
61591:    * @returns boolean
61591:    */
61591:   _shouldSaveTabState: function sss__shouldSaveTabState(aTabState) {
61591:     // If the tab has only the transient about:blank history entry, no other
61591:     // session history, and no userTypedValue, then we don't actually want to
61591:     // store this tab's data.
61591:     return aTabState.entries.length &&
61591:            !(aTabState.entries.length == 1 &&
61591:              aTabState.entries[0].url == "about:blank" &&
61591:              !aTabState.userTypedValue);
61591:   },
61591: 
61591:   /**
52403:    * This is going to take a state as provided at startup (via
52403:    * nsISessionStartup.state) and split it into 2 parts. The first part
52403:    * (defaultState) will be a state that should still be restored at startup,
52403:    * while the second part (state) is a state that should be saved for later.
52403:    * defaultState will be comprised of windows with only pinned tabs, extracted
52403:    * from state. It will contain the cookies that go along with the history
52403:    * entries in those tabs. It will also contain window position information.
52403:    *
52403:    * defaultState will be restored at startup. state will be placed into
52403:    * this._lastSessionState and will be kept in case the user explicitly wants
52403:    * to restore the previous session (publicly exposed as restoreLastSession).
52403:    *
73919:    * @param state
73919:    *        The state, presumably from nsISessionStartup.state
52403:    * @returns [defaultState, state]
52403:    */
73919:   _prepDataForDeferredRestore: function sss__prepDataForDeferredRestore(state) {
52403:     let defaultState = { windows: [], selectedWindow: 1 };
52403: 
52403:     state.selectedWindow = state.selectedWindow || 1;
52403: 
52403:     // Look at each window, remove pinned tabs, adjust selectedindex,
52403:     // remove window if necessary.
52403:     for (let wIndex = 0; wIndex < state.windows.length;) {
52403:       let window = state.windows[wIndex];
52403:       window.selected = window.selected || 1;
52403:       // We're going to put the state of the window into this object
52403:       let pinnedWindowState = { tabs: [], cookies: []};
52403:       for (let tIndex = 0; tIndex < window.tabs.length;) {
52403:         if (window.tabs[tIndex].pinned) {
52403:           // Adjust window.selected
52403:           if (tIndex + 1 < window.selected)
52403:             window.selected -= 1;
52403:           else if (tIndex + 1 == window.selected)
52403:             pinnedWindowState.selected = pinnedWindowState.tabs.length + 2;
52403:             // + 2 because the tab isn't actually in the array yet
52403: 
52403:           // Now add the pinned tab to our window
52403:           pinnedWindowState.tabs =
52403:             pinnedWindowState.tabs.concat(window.tabs.splice(tIndex, 1));
52403:           // We don't want to increment tIndex here.
52403:           continue;
52403:         }
52403:         tIndex++;
52403:       }
52403: 
52403:       // At this point the window in the state object has been modified (or not)
52403:       // We want to build the rest of this new window object if we have pinnedTabs.
52403:       if (pinnedWindowState.tabs.length) {
52403:         // First get the other attributes off the window
52403:         WINDOW_ATTRIBUTES.forEach(function(attr) {
52403:           if (attr in window) {
52403:             pinnedWindowState[attr] = window[attr];
52403:             delete window[attr];
52403:           }
52403:         });
52403:         // We're just copying position data into the pinned window.
52403:         // Not copying over:
52403:         // - _closedTabs
52403:         // - extData
52403:         // - isPopup
52403:         // - hidden
52403: 
52403:         // Assign a unique ID to correlate the window to be opened with the
52403:         // remaining data
52403:         window.__lastSessionWindowID = pinnedWindowState.__lastSessionWindowID
68410:                                      = "" + Date.now() + Math.random();
52403: 
52403:         // Extract the cookies that belong with each pinned tab
52403:         this._splitCookiesFromWindow(window, pinnedWindowState);
52403: 
52403:         // Actually add this window to our defaultState
52403:         defaultState.windows.push(pinnedWindowState);
52403:         // Remove the window from the state if it doesn't have any tabs
52403:         if (!window.tabs.length) {
52403:           if (wIndex + 1 <= state.selectedWindow)
52403:             state.selectedWindow -= 1;
52403:           else if (wIndex + 1 == state.selectedWindow)
52403:             defaultState.selectedIndex = defaultState.windows.length + 1;
52403: 
52403:           state.windows.splice(wIndex, 1);
52403:           // We don't want to increment wIndex here.
52403:           continue;
52403:         }
52403: 
52403: 
52403:       }
52403:       wIndex++;
52403:     }
52403: 
52403:     return [defaultState, state];
52403:   },
52403: 
52403:   /**
52403:    * Splits out the cookies from aWinState into aTargetWinState based on the
52403:    * tabs that are in aTargetWinState.
52403:    * This alters the state of aWinState and aTargetWinState.
52403:    */
52403:   _splitCookiesFromWindow:
52403:     function sss__splitCookiesFromWindow(aWinState, aTargetWinState) {
52403:     if (!aWinState.cookies || !aWinState.cookies.length)
52403:       return;
52403: 
52403:     // Get the hosts for history entries in aTargetWinState
52403:     let cookieHosts = {};
52403:     aTargetWinState.tabs.forEach(function(tab) {
52403:       tab.entries.forEach(function(entry) {
52403:         this._extractHostsForCookies(entry, cookieHosts, false)
52403:       }, this);
52403:     }, this);
52403: 
52403:     // By creating a regex we reduce overhead and there is only one loop pass
52403:     // through either array (cookieHosts and aWinState.cookies).
52403:     let hosts = Object.keys(cookieHosts).join("|").replace("\\.", "\\.", "g");
52403:     let cookieRegex = new RegExp(".*(" + hosts + ")");
52403:     for (let cIndex = 0; cIndex < aWinState.cookies.length;) {
52403:       if (cookieRegex.test(aWinState.cookies[cIndex].host)) {
52403:         aTargetWinState.cookies =
52403:           aTargetWinState.cookies.concat(aWinState.cookies.splice(cIndex, 1));
52403:         continue;
52403:       }
52403:       cIndex++;
52403:     }
52403:   },
52403: 
52403:   /**
    1:    * Converts a JavaScript object into a JSON string
 5152:    * (see http://www.json.org/ for more information).
    1:    *
21415:    * The inverse operation consists of JSON.parse(JSON_string).
    1:    *
    1:    * @param aJSObject is the object to be converted
21415:    * @returns the object's JSON representation
    1:    */
    1:   _toJSONString: function sss_toJSONString(aJSObject) {
52403:     // We never want to save __lastSessionWindowID across sessions, but we do
52403:     // want it exported to consumers when running (eg. Private Browsing).
52403:     let internalKeys = INTERNAL_KEYS;
52403:     if (this._loadState == STATE_QUITTING) {
52403:       internalKeys = internalKeys.slice();
52403:       internalKeys.push("__lastSessionWindowID");
52403:     }
43419:     function exclude(key, value) {
43419:       // returning undefined results in the exclusion of that key
52403:       return internalKeys.indexOf(key) == -1 ? value : undefined;
27171:     }
43419:     return JSON.stringify(aJSObject, exclude);
    1:   },
    1: 
35664:   _sendRestoreCompletedNotifications: function sss_sendRestoreCompletedNotifications() {
76365:     // not all windows restored, yet
76365:     if (this._restoreCount > 1) {
21044:       this._restoreCount--;
76365:       return;
76365:     }
76365: 
76365:     // observers were already notified
76365:     if (this._restoreCount == -1)
76365:       return;
76365: 
21044:     // This was the last window restored at startup, notify observers.
39650:     Services.obs.notifyObservers(null,
34612:       this._browserSetState ? NOTIFY_BROWSER_STATE_RESTORED : NOTIFY_WINDOWS_RESTORED,
34612:       "");
76365: 
34612:     this._browserSetState = false;
76365:     this._restoreCount = -1;
21044:   },
21044: 
25810:    /**
76934:    * Set the given window's busy state
76934:    * @param aWindow the window
76934:    * @param aValue the window's busy state
76934:    */
76934:   _setWindowStateBusyValue:
76934:     function sss__changeWindowStateBusyValue(aWindow, aValue) {
76934: 
76934:     this._windows[aWindow.__SSi].busy = aValue;
76934: 
76934:     // Keep the to-be-restored state in sync because that is returned by
76934:     // getWindowState() as long as the window isn't loaded, yet.
76934:     if (!this._isWindowLoaded(aWindow)) {
76934:       let stateToRestore = this._statesToRestore[aWindow.__SS_restoreID].windows[0];
76934:       stateToRestore.busy = aValue;
76934:     }
76934:   },
76934: 
76934:   /**
76934:    * Set the given window's state to 'not busy'.
76934:    * @param aWindow the window
76934:    */
76934:   _setWindowStateReady: function sss__setWindowStateReady(aWindow) {
76934:     this._setWindowStateBusyValue(aWindow, false);
76934:     this._sendWindowStateEvent(aWindow, "Ready");
76934:   },
76934: 
76934:   /**
76934:    * Set the given window's state to 'busy'.
76934:    * @param aWindow the window
76934:    */
76934:   _setWindowStateBusy: function sss__setWindowStateBusy(aWindow) {
76934:     this._setWindowStateBusyValue(aWindow, true);
76934:     this._sendWindowStateEvent(aWindow, "Busy");
76934:   },
76934: 
76934:   /**
59698:    * Dispatch an SSWindowState_____ event for the given window.
59698:    * @param aWindow the window
59698:    * @param aType the type of event, SSWindowState will be prepended to this string
59698:    */
59698:   _sendWindowStateEvent: function sss__sendWindowStateEvent(aWindow, aType) {
59698:     let event = aWindow.document.createEvent("Events");
59698:     event.initEvent("SSWindowState" + aType, true, false);
59698:     aWindow.dispatchEvent(event);
59698:   },
59698: 
59698:   /**
58570:    * Dispatch the SSTabRestored event for the given tab.
58570:    * @param aTab the which has been restored
58570:    */
58570:   _sendTabRestoredNotification: function sss__sendTabRestoredNotification(aTab) {
58570:       let event = aTab.ownerDocument.createEvent("Events");
58570:       event.initEvent("SSTabRestored", true, false);
58570:       aTab.dispatchEvent(event);
58570:   },
58570: 
58570:   /**
25810:    * @param aWindow
25810:    *        Window reference
25810:    * @returns whether this window's data is still cached in _statesToRestore
25810:    *          because it's not fully loaded yet
25810:    */
25810:   _isWindowLoaded: function sss_isWindowLoaded(aWindow) {
25810:     return !aWindow.__SS_restoreID;
25810:   },
25810: 
27669:   /**
27669:    * Replace "Loading..." with the tab label (with minimal side-effects)
27669:    * @param aString is the string the title is stored in
27669:    * @param aTabbrowser is a tabbrowser object, containing aTab
27669:    * @param aTab is the tab whose title we're updating & using
27669:    *
27669:    * @returns aString that has been updated with the new title
27669:    */
27669:   _replaceLoadingTitle : function sss_replaceLoadingTitle(aString, aTabbrowser, aTab) {
55383:     if (aString == aTabbrowser.mStringBundle.getString("tabs.connecting")) {
27669:       aTabbrowser.setTabTitle(aTab);
27669:       [aString, aTab.label] = [aTab.label, aString];
27669:     }
27669:     return aString;
27669:   },
27669: 
27669:   /**
27669:    * Resize this._closedWindows to the value of the pref, except in the case
27669:    * where we don't have any non-popup windows on Windows and Linux. Then we must
27669:    * resize such that we have at least one non-popup window.
27669:    */
27669:   _capClosedWindows : function sss_capClosedWindows() {
27669:     let maxWindowsUndo = this._prefBranch.getIntPref("sessionstore.max_windows_undo");
27669:     if (this._closedWindows.length <= maxWindowsUndo)
27669:       return;
27669:     let spliceTo = maxWindowsUndo;
27669: #ifndef XP_MACOSX
27669:     let normalWindowIndex = 0;
27669:     // try to find a non-popup window in this._closedWindows
27669:     while (normalWindowIndex < this._closedWindows.length &&
29620:            !!this._closedWindows[normalWindowIndex].isPopup)
27669:       normalWindowIndex++;
27669:     if (normalWindowIndex >= maxWindowsUndo)
27669:       spliceTo = normalWindowIndex + 1;
27669: #endif
78670:     this._closedWindows.splice(spliceTo, this._closedWindows.length);
27669:   },
27669: 
72193:   _clearRestoringWindows: function sss__clearRestoringWindows() {
72193:     for (let i = 0; i < this._closedWindows.length; i++) {
72193:       delete this._closedWindows[i]._shouldRestore;
72193:     }
72193:   },
72193: 
54279:   /**
54279:    * Reset state to prepare for a new session state to be restored.
54279:    */
54279:   _resetRestoringState: function sss__initRestoringState() {
77573:     this._tabsToRestore = { priority: [], visible: [], hidden: [] };
54279:     this._tabsRestoringCount = 0;
54279:   },
54279: 
54693:   /**
54693:    * Reset the restoring state for a particular tab. This will be called when
55807:    * removing a tab or when a tab needs to be reset (it's being overwritten).
54693:    *
54693:    * @param aTab
54693:    *        The tab that will be "reset"
54693:    */
55807:   _resetTabRestoringState: function sss__resetTabRestoringState(aTab) {
55807:     let window = aTab.ownerDocument.defaultView;
54607:     let browser = aTab.linkedBrowser;
54607: 
55807:     // Keep the tab's previous state for later in this method
55807:     let previousState = browser.__SS_restoreState;
55807: 
55807:     // The browser is no longer in any sort of restoring state.
55807:     delete browser.__SS_restoreState;
55807: 
55807:     // We want to decrement window.__SS_tabsToRestore here so that we always
55807:     // decrement it AFTER a tab is done restoring or when a tab gets "reset".
55807:     window.__SS_tabsToRestore--;
55807: 
55807:     // Remove the progress listener if we should.
55807:     this._removeTabsProgressListener(window);
55807: 
55807:     if (previousState == TAB_STATE_RESTORING) {
70116:       if (this._tabsRestoringCount)
55807:         this._tabsRestoringCount--;
55807:     }
55807:     else if (previousState == TAB_STATE_NEEDS_RESTORE) {
55807:       // Make sure the session history listener is removed. This is normally
55807:       // done in restoreTab, but this tab is being removed before that gets called.
55807:       this._removeSHistoryListener(aTab);
55807: 
55807:       // Make sure that the tab is removed from the list of tabs to restore.
55807:       // Again, this is normally done in restoreTab, but that isn't being called
55807:       // for this tab.
55807:       this._removeTabFromTabsToRestore(aTab);
55807:     }
55807:   },
55807: 
55807:   /**
77573:    * Remove the tab from this._tabsToRestore[priority/visible/hidden]
55807:    *
55807:    * @param aTab
55807:    */
55807:   _removeTabFromTabsToRestore: function sss__removeTabFromTabsToRestore(aTab) {
77573:     // We'll always check priority first since we don't have an indicator if
77573:     // a tab will be there or not.
77573:     let arr = this._tabsToRestore.priority;
55807:     let index = arr.indexOf(aTab);
77573:     if (index == -1) {
77573:       arr = this._tabsToRestore[aTab.hidden ? "hidden" : "visible"];
77573:       index = arr.indexOf(aTab);
77573:     }
55807:     if (index > -1)
55807:       arr.splice(index, 1);
55807:   },
55807: 
55807:   /**
55807:    * Add the tabs progress listener to the window if it isn't already
55807:    *
55807:    * @param aWindow
55807:    *        The window to add our progress listener to
55807:    */
55807:   _ensureTabsProgressListener: function sss__ensureTabsProgressListener(aWindow) {
55807:     let tabbrowser = aWindow.gBrowser;
55807:     if (tabbrowser.mTabsProgressListeners.indexOf(gRestoreTabsProgressListener) == -1)
55807:       tabbrowser.addTabsProgressListener(gRestoreTabsProgressListener);
55807:   },
55807: 
55807:   /**
55807:    * Attempt to remove the tabs progress listener from the window.
55807:    *
55807:    * @param aWindow
55807:    *        The window from which to remove our progress listener from
55807:    */
55807:   _removeTabsProgressListener: function sss__removeTabsProgressListener(aWindow) {
55807:     // If there are no tabs left to restore (or restoring) in this window, then
55807:     // we can safely remove the progress listener from this window.
55807:     if (!aWindow.__SS_tabsToRestore)
55807:       aWindow.gBrowser.removeTabsProgressListener(gRestoreTabsProgressListener);
55807:   },
55807: 
55807:   /**
55807:    * Remove the session history listener from the tab's browser if there is one.
55807:    *
55807:    * @param aTab
55807:    *        The tab who's browser to remove the listener
55807:    */
55807:   _removeSHistoryListener: function sss__removeSHistoryListener(aTab) {
55807:     let browser = aTab.linkedBrowser;
54809:     if (browser.__SS_shistoryListener) {
54809:       browser.webNavigation.sessionHistory.
54809:                             removeSHistoryListener(browser.__SS_shistoryListener);
54693:       delete browser.__SS_shistoryListener;
54809:     }
54607:   },
54607: 
    1: /* ........ Storage API .............. */
    1: 
    1:   /**
    1:    * write file to disk
    1:    * @param aFile
    1:    *        nsIFile
    1:    * @param aData
    1:    *        String data
    1:    */
    1:   _writeFile: function sss_writeFile(aFile, aData) {
31302:     // Initialize the file output stream.
31302:     var ostream = Cc["@mozilla.org/network/safe-file-output-stream;1"].
    1:                   createInstance(Ci.nsIFileOutputStream);
63331:     ostream.init(aFile, 0x02 | 0x08 | 0x20, 0600, ostream.DEFER_OPEN);
31302: 
31302:     // Obtain a converter to convert our data to a UTF-8 encoded input stream.
    1:     var converter = Cc["@mozilla.org/intl/scriptableunicodeconverter"].
    1:                     createInstance(Ci.nsIScriptableUnicodeConverter);
    1:     converter.charset = "UTF-8";
31302: 
31302:     // Asynchronously copy the data to the file.
31302:     var istream = converter.convertToInputStream(aData);
31302:     var self = this;
31302:     NetUtil.asyncCopy(istream, ostream, function(rc) {
31302:       if (Components.isSuccessCode(rc)) {
39650:         Services.obs.notifyObservers(null,
31302:                                      "sessionstore-state-write-complete",
31302:                                      "");
    1:       }
31302:     });
    1:   }
    1: };
    1: 
18836: let XPathHelper = {
18836:   // these two hashes should be kept in sync
18836:   namespaceURIs:     { "xhtml": "http://www.w3.org/1999/xhtml" },
18836:   namespacePrefixes: { "http://www.w3.org/1999/xhtml": "xhtml" },
18836: 
18836:   /**
18836:    * Generates an approximate XPath query to an (X)HTML node
18836:    */
18836:   generate: function sss_xph_generate(aNode) {
18836:     // have we reached the document node already?
18836:     if (!aNode.parentNode)
18836:       return "";
18836:     
36958:     // Access localName, namespaceURI just once per node since it's expensive.
36958:     let nNamespaceURI = aNode.namespaceURI;
36958:     let nLocalName = aNode.localName;
36958: 
36958:     let prefix = this.namespacePrefixes[nNamespaceURI] || null;
36958:     let tag = (prefix ? prefix + ":" : "") + this.escapeName(nLocalName);
18836:     
18836:     // stop once we've found a tag with an ID
18836:     if (aNode.id)
18836:       return "//" + tag + "[@id=" + this.quoteArgument(aNode.id) + "]";
18836:     
18836:     // count the number of previous sibling nodes of the same tag
18836:     // (and possible also the same name)
18836:     let count = 0;
18836:     let nName = aNode.name || null;
18836:     for (let n = aNode; (n = n.previousSibling); )
36958:       if (n.localName == nLocalName && n.namespaceURI == nNamespaceURI &&
18836:           (!nName || n.name == nName))
18836:         count++;
18836:     
18836:     // recurse until hitting either the document node or an ID'd node
18836:     return this.generate(aNode.parentNode) + "/" + tag +
18836:            (nName ? "[@name=" + this.quoteArgument(nName) + "]" : "") +
18836:            (count ? "[" + (count + 1) + "]" : "");
18836:   },
18836: 
18836:   /**
18836:    * Resolves an XPath query generated by XPathHelper.generate
18836:    */
18836:   resolve: function sss_xph_resolve(aDocument, aQuery) {
18836:     let xptype = Ci.nsIDOMXPathResult.FIRST_ORDERED_NODE_TYPE;
18836:     return aDocument.evaluate(aQuery, aDocument, this.resolveNS, xptype, null).singleNodeValue;
18836:   },
18836: 
18836:   /**
18836:    * Namespace resolver for the above XPath resolver
18836:    */
18836:   resolveNS: function sss_xph_resolveNS(aPrefix) {
18836:     return XPathHelper.namespaceURIs[aPrefix] || null;
18836:   },
18836: 
18836:   /**
27209:    * @returns valid XPath for the given node (usually just the local name itself)
27209:    */
27209:   escapeName: function sss_xph_escapeName(aName) {
27209:     // we can't just use the node's local name, if it contains
27209:     // special characters (cf. bug 485482)
27209:     return /^\w+$/.test(aName) ? aName :
27209:            "*[local-name()=" + this.quoteArgument(aName) + "]";
27209:   },
27209: 
27209:   /**
18836:    * @returns a properly quoted string to insert into an XPath query
18836:    */
18836:   quoteArgument: function sss_xph_quoteArgument(aArg) {
18836:     return !/'/.test(aArg) ? "'" + aArg + "'" :
18836:            !/"/.test(aArg) ? '"' + aArg + '"' :
18836:            "concat('" + aArg.replace(/'+/g, "',\"$&\",'") + "')";
20319:   },
20319: 
20319:   /**
20319:    * @returns an XPath query to all savable form field nodes
20319:    */
20319:   get restorableFormNodes() {
20319:     // for a comprehensive list of all available <INPUT> types see
20319:     // http://mxr.mozilla.org/mozilla-central/search?string=kInputTypeTable
20319:     let ignoreTypes = ["password", "hidden", "button", "image", "submit", "reset"];
20319:     // XXXzeniko work-around until lower-case has been implemented (bug 398389)
20319:     let toLowerCase = '"ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz"';
20319:     let ignore = "not(translate(@type, " + toLowerCase + ")='" +
20319:       ignoreTypes.join("' or translate(@type, " + toLowerCase + ")='") + "')";
20319:     let formNodesXPath = "//textarea|//select|//xhtml:textarea|//xhtml:select|" +
20319:       "//input[" + ignore + "]|//xhtml:input[" + ignore + "]";
20319:     
20319:     delete this.restorableFormNodes;
20319:     return (this.restorableFormNodes = formNodesXPath);
18836:   }
18836: };
18836: 
54279: // This is used to help meter the number of restoring tabs. This is the control
54279: // point for telling the next tab to restore. It gets attached to each gBrowser
54279: // via gBrowser.addTabsProgressListener
54279: let gRestoreTabsProgressListener = {
54279:   ss: null,
54279:   onStateChange: function (aBrowser, aWebProgress, aRequest, aStateFlags, aStatus) {
54693:     // Ignore state changes on browsers that we've already restored and state
54693:     // changes that aren't applicable.
55807:     if (aBrowser.__SS_restoreState == TAB_STATE_RESTORING &&
54693:         aStateFlags & Ci.nsIWebProgressListener.STATE_STOP &&
54279:         aStateFlags & Ci.nsIWebProgressListener.STATE_IS_NETWORK &&
54279:         aStateFlags & Ci.nsIWebProgressListener.STATE_IS_WINDOW) {
54809:       // We need to reset the tab before starting the next restore.
55807:       let tab = this.ss._getTabForBrowser(aBrowser);
55807:       this.ss._resetTabRestoringState(tab);
55807:       this.ss.restoreNextTab();
54279:     }
54279:   }
54279: }
54279: 
54693: // A SessionStoreSHistoryListener will be attached to each browser before it is
54693: // restored. We need to catch reloads that occur before the tab is restored
54693: // because otherwise, docShell will reload an old URI (usually about:blank).
54693: function SessionStoreSHistoryListener(ss, aTab) {
54693:   this.tab = aTab;
54693:   this.ss = ss;
54693: }
54693: SessionStoreSHistoryListener.prototype = {
54693:   QueryInterface: XPCOMUtils.generateQI([Ci.nsISHistoryListener,
54693:                                          Ci.nsISupportsWeakReference]),
54693:   browser: null,
54693:   ss: null,
54693:   OnHistoryNewEntry: function(aNewURI) { },
54693:   OnHistoryGoBack: function(aBackURI) { return true; },
54693:   OnHistoryGoForward: function(aForwardURI) { return true; },
54693:   OnHistoryGotoIndex: function(aIndex, aGotoURI) { return true; },
54693:   OnHistoryPurge: function(aNumEntries) { return true; },
54693:   OnHistoryReload: function(aReloadURI, aReloadFlags) {
54693:     // On reload, we want to make sure that session history loads the right
55807:     // URI. In order to do that, we will juet call restoreTab. That will remove
55807:     // the history listener and load the right URI.
55807:     this.ss.restoreTab(this.tab);
54693:     // Returning false will stop the load that docshell is attempting.
54693:     return false;
54693:   }
54693: }
54693: 
54693: 
24094: // see nsPrivateBrowsingService.js
24094: String.prototype.hasRootDomain = function hasRootDomain(aDomain)
24094: {
24094:   let index = this.indexOf(aDomain);
24094:   if (index == -1)
24094:     return false;
24094: 
24094:   if (this == aDomain)
24094:     return true;
24094: 
24094:   let prevChar = this[index - 1];
24094:   return (index == (this.length - aDomain.length)) &&
24094:          (prevChar == "." || prevChar == "/");
24094: }
24094: 
47015: var NSGetFactory = XPCOMUtils.generateNSGetFactory([SessionStoreService]);
