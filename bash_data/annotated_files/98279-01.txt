85022: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
85022: /* vim: set ts=2 et sw=2 tw=80: */
85022: /* ***** BEGIN LICENSE BLOCK *****
85022:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
85022:  *
85022:  * The contents of this file are subject to the Mozilla Public License Version
85022:  * 1.1 (the "License"); you may not use this file except in compliance with
85022:  * the License. You may obtain a copy of the License at
85022:  * http://www.mozilla.org/MPL/
85022:  *
85022:  * Software distributed under the License is distributed on an "AS IS" basis,
85022:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
85022:  * for the specific language governing rights and limitations under the
85022:  * License.
85022:  *
85022:  * The Original Code is Indexed Database.
85022:  *
85022:  * The Initial Developer of the Original Code is The Mozilla Foundation.
85022:  * Portions created by the Initial Developer are Copyright (C) 2010
85022:  * the Initial Developer. All Rights Reserved.
85022:  *
85022:  * Contributor(s):
85023:  *   Jan Varga <Jan.Varga@gmail.com>
85023:  *   Jonas Sicking <jonas@sicking.cc>
85022:  *
85022:  * Alternatively, the contents of this file may be used under the terms of
85022:  * either the GNU General Public License Version 2 or later (the "GPL"), or
85022:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
85022:  * in which case the provisions of the GPL or the LGPL are applicable instead
85022:  * of those above. If you wish to allow use of your version of this file only
85022:  * under the terms of either the GPL or the LGPL, and not to allow others to
85022:  * use your version of this file under the terms of the MPL, indicate your
85022:  * decision by deleting the provisions above and replace them with the notice
85022:  * and other provisions required by the GPL or the LGPL. If you do not delete
85022:  * the provisions above, a recipient may use your version of this file under
85022:  * the terms of any one of the MPL, the GPL or the LGPL.
85022:  *
85022:  * ***** END LICENSE BLOCK ***** */
85022: 
95341: #include "mozilla/FloatingPoint.h"
95341: 
85022: #include "Key.h"
85022: #include "nsIStreamBufferAccess.h"
87274: #include "jsfriendapi.h"
86689: #include "nsAlgorithm.h"
85022: #include "nsContentUtils.h"
85022: #include "nsJSUtils.h"
86103: #include "xpcpublic.h"
85022: 
85022: USING_INDEXEDDB_NAMESPACE
85022: 
85022: /*
85022:  Here's how we encode keys:
85022: 
85022:  Basic strategy is the following
85022: 
85022:  Numbers: 1 n n n n n n n n    ("n"s are encoded 64bit float)
85022:  Dates:   2 n n n n n n n n    ("n"s are encoded 64bit float)
85022:  Strings: 3 s s s ... 0        ("s"s are encoded unicode bytes)
85022:  Arrays:  4 i i i ... 0        ("i"s are encoded array items)
85022: 
85022: 
85022:  When encoding floats, 64bit IEEE 754 are almost sortable, except that
85022:  positive sort lower than negative, and negative sort descending. So we use
85022:  the following encoding:
85022:  
85022:  value < 0 ?
85022:    (-to64bitInt(value)) :
85022:    (to64bitInt(value) | 0x8000000000000000)
85022: 
85022: 
85022:  When encoding strings, we use variable-size encoding per the following table
85022:  
85022:  Chars 0         - 7E           are encoded as 0xxxxxxx with 1 added
85022:  Chars 7F        - (3FFF+7F)    are encoded as 10xxxxxx xxxxxxxx with 7F subtracted
85022:  Chars (3FFF+80) - FFFF         are encoded as 11xxxxxx xxxxxxxx xx000000
85022: 
85022:  This ensures that the first byte is never encoded as 0, which means that the
85022:  string terminator (per basic-stategy table) sorts before any character.
85022:  The reason that (3FFF+80) - FFFF is encoded "shifted up" 6 bits is to maximize
85022:  the chance that the last character is 0. See below for why.
85022: 
85022: 
85022:  When encoding Arrays, we use an additional trick. Rather than adding a byte
85022:  containing the value '4' to indicate type, we instead add 4 to the next byte.
85022:  This is usually the byte containing the type of the first item in the array.
85022:  So simple examples are
85022: 
85022:  ["foo"]       7 s s s 0 0                              // 7 is 3 + 4
85022:  [1, 2]        5 n n n n n n n n 1 n n n n n n n n 0    // 5 is 1 + 4
85022: 
85022:  Whe do this iteratively if the first item in the array is also an array
85022: 
85022:  [["foo"]]    11 s s s 0 0 0
85022: 
85022:  However, to avoid overflow in the byte, we only do this 3 times. If the first
85022:  item in an array is an array, and that array also has an array as first item,
85022:  we simply write out the total value accumulated so far and then follow the
85022:  "normal" rules.
85022: 
85022:  [[["foo"]]]  12 3 s s s 0 0 0 0
85022: 
85022:  There is another edge case that can happen though, which is that the array
85022:  doesn't have a first item to which we can add 4 to the type. Instead the
85022:  next byte would normally be the array terminator (per basic-strategy table)
85022:  so we simply add the 4 there.
85022: 
85022:  [[]]         8 0             // 8 is 4 + 4 + 0
85022:  []           4               // 4 is 4 + 0
85022:  [[], "foo"]  8 3 s s s 0 0   // 8 is 4 + 4 + 0
85022: 
85022:  Note that the max-3-times rule kicks in before we get a chance to add to the
85022:  array terminator
85022: 
85022:  [[[]]]       12 0 0 0        // 12 is 4 + 4 + 4
85022: 
85022:  We could use a much higher number than 3 at no complexity or performance cost,
85022:  however it seems unlikely that it'll make a practical difference, and the low
85022:  limit makes testing eaiser.
85022: 
85022: 
85022:  As a final optimization we do a post-encoding step which drops all 0s at the
85022:  end of the encoded buffer.
85022:  
85022:  "foo"         // 3 s s s
85022:  1             // 1 bf f0
85022:  ["a", "b"]    // 7 s 3 s
85022:  [1, 2]        // 5 bf f0 0 0 0 0 0 0 1 c0
85022:  [[]]          // 8
85022: */
85022: 
85022: const int MaxArrayCollapse = 3;
85022: 
98279: const int MaxRecursionDepth = 256;
98279: 
85022: nsresult
98279: Key::EncodeJSValInternal(JSContext* aCx, const jsval aVal,
98279:                          PRUint8 aTypeOffset, PRUint16 aRecursionDepth)
85022: {
98279:   NS_ENSURE_TRUE(aRecursionDepth < MaxRecursionDepth, NS_ERROR_DOM_INDEXEDDB_DATA_ERR);
98279: 
85022:   PR_STATIC_ASSERT(eMaxType * MaxArrayCollapse < 256);
85022: 
85022:   if (JSVAL_IS_STRING(aVal)) {
85022:     nsDependentJSString str;
85022:     if (!str.init(aCx, aVal)) {
98279:       return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
85022:     }
85022:     EncodeString(str, aTypeOffset);
85022:     return NS_OK;
85022:   }
85022: 
85022:   if (JSVAL_IS_INT(aVal)) {
85022:     EncodeNumber((double)JSVAL_TO_INT(aVal), eFloat + aTypeOffset);
85022:     return NS_OK;
85022:   }
85022: 
85022:   if (JSVAL_IS_DOUBLE(aVal)) {
85022:     double d = JSVAL_TO_DOUBLE(aVal);
95341:     if (MOZ_DOUBLE_IS_NaN(d)) {
85022:       return NS_ERROR_DOM_INDEXEDDB_DATA_ERR;
85022:     }
85022:     EncodeNumber(d, eFloat + aTypeOffset);
85022:     return NS_OK;
85022:   }
85022: 
85022:   if (!JSVAL_IS_PRIMITIVE(aVal)) {
85022:     JSObject* obj = JSVAL_TO_OBJECT(aVal);
85022:     if (JS_IsArrayObject(aCx, obj)) {
85022:       aTypeOffset += eMaxType;
85022: 
85022:       if (aTypeOffset == eMaxType * MaxArrayCollapse) {
85022:         mBuffer.Append(aTypeOffset);
85022:         aTypeOffset = 0;
85022:       }
85022:       NS_ASSERTION((aTypeOffset % eMaxType) == 0 &&
85022:                    aTypeOffset < (eMaxType * MaxArrayCollapse),
85022:                    "Wrong typeoffset");
85022: 
91688:       uint32_t length;
85022:       if (!JS_GetArrayLength(aCx, obj, &length)) {
85022:         return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
85022:       }
85022: 
91688:       for (uint32_t index = 0; index < length; index++) {
85022:         jsval val;
85022:         if (!JS_GetElement(aCx, obj, index, &val)) {
85022:           return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
85022:         }
85022: 
98279:         nsresult rv = EncodeJSValInternal(aCx, val, aTypeOffset,
98279:                                           aRecursionDepth + 1);
85022:         NS_ENSURE_SUCCESS(rv, rv);
85022: 
85022:         aTypeOffset = 0;
85022:       }
85022: 
85022:       mBuffer.Append(eTerminator + aTypeOffset);
85022: 
85022:       return NS_OK;
85022:     }
85022: 
85022:     if (JS_ObjectIsDate(aCx, obj)) {
85022:       EncodeNumber(js_DateGetMsecSinceEpoch(aCx, obj), eDate + aTypeOffset);
85022:       return NS_OK;
85022:     }
85022:   }
85022: 
85022:   return NS_ERROR_DOM_INDEXEDDB_DATA_ERR;
85022: }
85022: 
85022: // static
85022: nsresult
98279: Key::DecodeJSValInternal(const unsigned char*& aPos, const unsigned char* aEnd,
98279:                          JSContext* aCx, PRUint8 aTypeOffset, jsval* aVal,
98279:                          PRUint16 aRecursionDepth)
85022: {
98279:   NS_ENSURE_TRUE(aRecursionDepth < MaxRecursionDepth, NS_ERROR_DOM_INDEXEDDB_DATA_ERR);
98279: 
85022:   if (*aPos - aTypeOffset >= eArray) {
85022:     JSObject* array = JS_NewArrayObject(aCx, 0, nsnull);
85022:     if (!array) {
85022:       NS_WARNING("Failed to make array!");
85022:       return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
85022:     }
85022: 
85022:     aTypeOffset += eMaxType;
85022: 
85022:     if (aTypeOffset == eMaxType * MaxArrayCollapse) {
85022:       ++aPos;
85022:       aTypeOffset = 0;
85022:     }
85022: 
91688:     uint32_t index = 0;
85022:     while (aPos < aEnd && *aPos - aTypeOffset != eTerminator) {
85022:       jsval val;
98279:       nsresult rv = DecodeJSValInternal(aPos, aEnd, aCx, aTypeOffset,
98279:                                         &val, aRecursionDepth + 1);
85022:       NS_ENSURE_SUCCESS(rv, rv);
85022: 
85022:       aTypeOffset = 0;
85022: 
85022:       if (!JS_SetElement(aCx, array, index++, &val)) {
85022:         NS_WARNING("Failed to set array element!");
85022:         return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
85022:       }
85022:     }
85022: 
85022:     NS_ASSERTION(aPos >= aEnd || (*aPos % eMaxType) == eTerminator,
85022:                  "Should have found end-of-array marker");
85022:     ++aPos;
85022: 
85022:     *aVal = OBJECT_TO_JSVAL(array);
85022:   }
85022:   else if (*aPos - aTypeOffset == eString) {
85022:     nsString key;
85022:     DecodeString(aPos, aEnd, key);
86103:     if (!xpc::StringToJsval(aCx, key, aVal)) {
85022:       return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
85022:     }
85022:   }
85022:   else if (*aPos - aTypeOffset == eDate) {
90955:     double msec = static_cast<double>(DecodeNumber(aPos, aEnd));
85022:     JSObject* date = JS_NewDateObjectMsec(aCx, msec);
85022:     if (!date) {
85022:       NS_WARNING("Failed to make date!");
85022:       return NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR;
85022:     }
85022: 
85022:     *aVal = OBJECT_TO_JSVAL(date);
85022:   }
85022:   else if (*aPos - aTypeOffset == eFloat) {
85022:     *aVal = DOUBLE_TO_JSVAL(DecodeNumber(aPos, aEnd));
85022:   }
85022:   else {
85022:     NS_NOTREACHED("Unknown key type!");
85022:   }
85022: 
85022:   return NS_OK;
85022: }
85022: 
85022: #define ONE_BYTE_LIMIT 0x7E
85022: #define TWO_BYTE_LIMIT (0x3FFF+0x7F)
85022: 
85022: #define ONE_BYTE_ADJUST 1
85022: #define TWO_BYTE_ADJUST (-0x7F)
85022: #define THREE_BYTE_SHIFT 6
85022: 
85022: void
85022: Key::EncodeString(const nsAString& aString, PRUint8 aTypeOffset)
85022: {
85022:   // First measure how long the encoded string will be.
85022: 
85022:   // The +2 is for initial 3 and trailing 0. We'll compensate for multi-byte
85022:   // chars below.
85022:   PRUint32 size = aString.Length() + 2;
85022:   
85022:   const PRUnichar* start = aString.BeginReading();
85022:   const PRUnichar* end = aString.EndReading();
85022:   for (const PRUnichar* iter = start; iter < end; ++iter) {
85022:     if (*iter > ONE_BYTE_LIMIT) {
85022:       size += *iter > TWO_BYTE_LIMIT ? 2 : 1;
85022:     }
85022:   }
85022: 
85022:   // Allocate memory for the new size
85022:   PRUint32 oldLen = mBuffer.Length();
85022:   char* buffer;
85022:   if (!mBuffer.GetMutableData(&buffer, oldLen + size)) {
85022:     return;
85022:   }
85022:   buffer += oldLen;
85022: 
85022:   // Write type marker
85022:   *(buffer++) = eString + aTypeOffset;
85022: 
85022:   // Encode string
85022:   for (const PRUnichar* iter = start; iter < end; ++iter) {
85022:     if (*iter <= ONE_BYTE_LIMIT) {
85022:       *(buffer++) = *iter + ONE_BYTE_ADJUST;
85022:     }
85022:     else if (*iter <= TWO_BYTE_LIMIT) {
85022:       PRUnichar c = PRUnichar(*iter) + TWO_BYTE_ADJUST + 0x8000;
85022:       *(buffer++) = (char)(c >> 8);
85022:       *(buffer++) = (char)(c & 0xFF);
85022:     }
85022:     else {
85022:       PRUint32 c = (PRUint32(*iter) << THREE_BYTE_SHIFT) | 0x00C00000;
85022:       *(buffer++) = (char)(c >> 16);
85022:       *(buffer++) = (char)(c >> 8);
85022:       *(buffer++) = (char)c;
85022:     }
85022:   }
85022: 
85022:   // Write end marker
85022:   *(buffer++) = eTerminator;
85022:   
85022:   NS_ASSERTION(buffer == mBuffer.EndReading(), "Wrote wrong number of bytes");
85022: }
85022: 
85022: // static
85022: void
85022: Key::DecodeString(const unsigned char*& aPos, const unsigned char* aEnd,
85022:                   nsString& aString)
85022: {
85022:   NS_ASSERTION(*aPos % eMaxType == eString, "Don't call me!");
85022: 
85022:   const unsigned char* buffer = aPos + 1;
85022: 
85022:   // First measure how big the decoded string will be.
85022:   PRUint32 size = 0;
85022:   const unsigned char* iter; 
85022:   for (iter = buffer; iter < aEnd && *iter != eTerminator; ++iter) {
85022:     if (*iter & 0x80) {
85022:       iter += (*iter & 0x40) ? 2 : 1;
85022:     }
85022:     ++size;
85022:   }
85022:   
85022:   // Set end so that we don't have to check for null termination in the loop
85022:   // below
85022:   if (iter < aEnd) {
85022:     aEnd = iter;
85022:   }
85022: 
85022:   PRUnichar* out;
85022:   if (size && !aString.GetMutableData(&out, size)) {
85022:     return;
85022:   }
85022: 
85022:   for (iter = buffer; iter < aEnd;) {
85022:     if (!(*iter & 0x80)) {
85022:       *out = *(iter++) - ONE_BYTE_ADJUST;
85022:     }
85022:     else if (!(*iter & 0x40)) {
85022:       PRUnichar c = (PRUnichar(*(iter++)) << 8);
85022:       if (iter < aEnd) {
85022:         c |= *(iter++);
85022:       }
85022:       *out = c - TWO_BYTE_ADJUST - 0x8000;
85022:     }
85022:     else {
85022:       PRUint32 c = PRUint32(*(iter++)) << (16 - THREE_BYTE_SHIFT);
85022:       if (iter < aEnd) {
85022:         c |= PRUint32(*(iter++)) << (8 - THREE_BYTE_SHIFT);
85022:       }
85022:       if (iter < aEnd) {
85022:         c |= *(iter++) >> THREE_BYTE_SHIFT;
85022:       }
85022:       *out = (PRUnichar)c;
85022:     }
85022:     
85022:     ++out;
85022:   }
85022:   
85022:   NS_ASSERTION(!size || out == aString.EndReading(),
85022:                "Should have written the whole string");
85022:   
85022:   aPos = iter + 1;
85022: }
85022: 
85022: union Float64Union {
85022:   double d;
85022:   PRUint64 u;
85022: }; 
85022: 
85022: void
85022: Key::EncodeNumber(double aFloat, PRUint8 aType)
85022: {
85022:   // Allocate memory for the new size
85022:   PRUint32 oldLen = mBuffer.Length();
85022:   char* buffer;
85022:   if (!mBuffer.GetMutableData(&buffer, oldLen + 1 + sizeof(double))) {
85022:     return;
85022:   }
85022:   buffer += oldLen;
85022: 
85022:   *(buffer++) = aType;
85022: 
85022:   Float64Union pun;
85022:   pun.d = aFloat;
85022:   PRUint64 number = pun.u & PR_UINT64(0x8000000000000000) ?
85022:                     -pun.u :
85022:                     (pun.u | PR_UINT64(0x8000000000000000));
85022: 
86689:   number = NS_SWAP64(number);
86689:   memcpy(buffer, &number, sizeof(number));
85022: }
85022: 
85022: // static
85022: double
85022: Key::DecodeNumber(const unsigned char*& aPos, const unsigned char* aEnd)
85022: {
85022:   NS_ASSERTION(*aPos % eMaxType == eFloat ||
85022:                *aPos % eMaxType == eDate, "Don't call me!");
85022: 
85022:   ++aPos;
86689: 
85022:   PRUint64 number = 0;
86689:   memcpy(&number, aPos, NS_MIN<size_t>(sizeof(number), aEnd - aPos));
86689:   number = NS_SWAP64(number);
86689: 
86689:   aPos += sizeof(number);
85022: 
85022:   Float64Union pun;
85022:   pun.u = number & PR_UINT64(0x8000000000000000) ?
85022:           (number & ~PR_UINT64(0x8000000000000000)) :
85022:           -number;
85022: 
85022:   return pun.d;
85022: }
