52557: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52557:  * vim: set ts=4 sw=4 et tw=99:
52557:  *
52557:  * ***** BEGIN LICENSE BLOCK *****
52557:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52557:  *
52557:  * The contents of this file are subject to the Mozilla Public License Version
52557:  * 1.1 (the "License"); you may not use this file except in compliance with
52557:  * the License. You may obtain a copy of the License at
52557:  * http://www.mozilla.org/MPL/
52557:  *
52557:  * Software distributed under the License is distributed on an "AS IS" basis,
52557:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52557:  * for the specific language governing rights and limitations under the
52557:  * License.
52557:  *
52557:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52557:  * May 28, 2008.
52557:  *
52557:  * The Initial Developer of the Original Code is
52557:  *   Brendan Eich <brendan@mozilla.org>
52557:  *
52557:  * Contributor(s):
52557:  *
52557:  * Alternatively, the contents of this file may be used under the terms of
52557:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52557:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52557:  * in which case the provisions of the GPL or the LGPL are applicable instead
52557:  * of those above. If you wish to allow use of your version of this file only
52557:  * under the terms of either the GPL or the LGPL, and not to allow others to
52557:  * use your version of this file under the terms of the MPL, indicate your
52557:  * decision by deleting the provisions above and replace them with the notice
52557:  * and other provisions required by the GPL or the LGPL. If you do not delete
52557:  * the provisions above, a recipient may use your version of this file under
52557:  * the terms of any one of the MPL, the GPL or the LGPL.
52557:  *
52557:  * ***** END LICENSE BLOCK ***** */
52557: 
52557: #include "MethodJIT.h"
52557: #include "Logging.h"
52557: #include "assembler/jit/ExecutableAllocator.h"
52557: #include "jstracer.h"
52853: #include "BaseAssembler.h"
52880: #include "MonoIC.h"
52880: #include "PolyIC.h"
53168: #include "TrampolineCompiler.h"
53422: #include "jscntxtinlines.h"
52557: 
52557: using namespace js;
52557: using namespace js::mjit;
52557: 
53471: /*
53471:  * Explanation of VMFrame activation and various helper thunks below.
53471:  *
53471:  * JaegerTrampoline  - Executes a method JIT-compiled JSFunction. This function
53471:  *    creates a VMFrame on the machine stack and calls into JIT'd code. The JIT'd
53471:  *    code will eventually return to the VMFrame.
53471:  *
53472:  *  - Called from C++ function EnterMethodJIT.
53471:  *  - Parameters: cx, fp, code, stackLimit, safePoint
53471:  *  - Notes: safePoint is used in combination with SafePointTrampoline,
53471:  *           explained further down.
53471:  *
53471:  * JaegerThrowpoline - Calls into an exception handler from JIT'd code, and if a
53471:  *    scripted exception handler is not found, unwinds the VMFrame and returns
53471:  *    to C++.
53471:  *
53471:  *  - To start exception handling, we return from a stub call to the throwpoline.
53471:  *  - On entry to the throwpoline, the normal conditions of the jit-code ABI
53471:  *    are satisfied.
53471:  *  - To do the unwinding and find out where to continue executing, we call
53471:  *    js_InternalThrow.
53471:  *  - js_InternalThrow may return 0, which means the place to continue, if any,
53471:  *    is above this JaegerShot activation, so we just return, in the same way
53471:  *    the trampoline does.
53472:  *  - Otherwise, js_InternalThrow returns a jit-code address to continue execution
53472:  *    at. Because the jit-code ABI conditions are satisfied, we can just jump to
53472:  *    that point.
53471:  *
53471:  *
53471:  * SafePointTrampoline  - Inline script calls link their return addresses through
53471:  *    JSStackFrame::ncode. This includes the return address that unwinds back
53471:  *    to JaegerTrampoline. However, the tracer integration code often wants to
53471:  *    enter a method JIT'd function at an arbitrary safe point. Safe points
53471:  *    do not have the return address linking code that the method prologue has.
53471:  *    SafePointTrampoline is a thunk which correctly links the initial return
53472:  *    address. It is used in JaegerShotAtSafePoint, and passed as the "script
53472:  *    code" parameter. Using the "safePoint" parameter to JaegerTrampoline, it
53472:  *    correctly jumps to the intended point in the method.
53471:  *
53471:  *  - Used by JaegerTrampoline()
53471:  *
53471:  * InjectJaegerReturn - Implements the tail of InlineReturn. This is needed for
53471:  *    tracer integration, where a "return" opcode might not be a safe-point,
53471:  *    and thus the return path must be injected by hijacking the stub return
53471:  *    address.
53471:  *
53471:  *  - Used by RunTracer()
53471:  */
53471: 
52853: #ifdef JS_METHODJIT_PROFILE_STUBS
53137: static const size_t STUB_CALLS_FOR_OP_COUNT = 255;
53137: static uint32 StubCallsForOp[STUB_CALLS_FOR_OP_COUNT];
52853: #endif
52853: 
52557: extern "C" void JS_FASTCALL
53168: PushActiveVMFrame(VMFrame &f)
53168: {
53168:     f.previous = JS_METHODJIT_DATA(f.cx).activeFrame;
53168:     JS_METHODJIT_DATA(f.cx).activeFrame = &f;
53168: }
53168: 
53168: extern "C" void JS_FASTCALL
53168: PopActiveVMFrame(VMFrame &f)
53168: {
53168:     JS_ASSERT(JS_METHODJIT_DATA(f.cx).activeFrame);
53168:     JS_METHODJIT_DATA(f.cx).activeFrame = JS_METHODJIT_DATA(f.cx).activeFrame->previous;    
53168: }
53168: 
53168: extern "C" void JS_FASTCALL
52557: SetVMFrameRegs(VMFrame &f)
52557: {
52557:     f.oldRegs = f.cx->regs;
52557:     f.cx->setCurrentRegs(&f.regs);
52557: }
52557: 
52557: extern "C" void JS_FASTCALL
52557: UnsetVMFrameRegs(VMFrame &f)
52557: {
52557:     *f.oldRegs = f.regs;
52557:     f.cx->setCurrentRegs(f.oldRegs);
52557: }
52557: 
52557: #if defined(__APPLE__) || defined(XP_WIN)
52557: # define SYMBOL_STRING(name) "_" #name
52557: #else
52557: # define SYMBOL_STRING(name) #name
52557: #endif
52557: 
52557: JS_STATIC_ASSERT(offsetof(JSFrameRegs, sp) == 0);
52557: 
52557: #if defined(__linux__) && defined(JS_CPU_X64)
52557: # define SYMBOL_STRING_RELOC(name) #name "@plt"
52557: #else
52557: # define SYMBOL_STRING_RELOC(name) SYMBOL_STRING(name)
52557: #endif
52557: 
52557: #if defined(XP_MACOSX)
52557: # define HIDE_SYMBOL(name) ".private_extern _" #name
52557: #elif defined(__linux__)
52557: # define HIDE_SYMBOL(name) ".hidden" #name
52557: #else
52557: # define HIDE_SYMBOL(name)
52557: #endif
52557: 
52557: #if defined(__GNUC__)
52557: 
52557: /* If this assert fails, you need to realign VMFrame to 16 bytes. */
52557: #ifdef JS_CPU_ARM
52557: JS_STATIC_ASSERT(sizeof(VMFrame) % 8 == 0);
52557: #else
52557: JS_STATIC_ASSERT(sizeof(VMFrame) % 16 == 0);
52557: #endif
52557: 
52557: # if defined(JS_CPU_X64)
52557: 
52557: /*
52557:  *    *** DANGER ***
52557:  * If these assertions break, update the constants below.
52557:  *    *** DANGER ***
52557:  */
53162: JS_STATIC_ASSERT(offsetof(VMFrame, savedRBX) == 0x58);
53483: JS_STATIC_ASSERT(offsetof(VMFrame, regs.fp) == 0x38);
52557: 
53476: JS_STATIC_ASSERT(JSVAL_TAG_MASK == 0xFFFF800000000000LL);
53476: JS_STATIC_ASSERT(JSVAL_PAYLOAD_MASK == 0x00007FFFFFFFFFFFLL);
53476: 
52557: asm volatile (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerTrampoline) "\n"
52557: SYMBOL_STRING(JaegerTrampoline) ":"       "\n"
52557:     /* Prologue. */
52557:     "pushq %rbp"                         "\n"
52557:     "movq %rsp, %rbp"                    "\n"
52557:     /* Save non-volatile registers. */
52557:     "pushq %r12"                         "\n"
52557:     "pushq %r13"                         "\n"
52557:     "pushq %r14"                         "\n"
52557:     "pushq %r15"                         "\n"
52557:     "pushq %rbx"                         "\n"
52557: 
53476:     /* Load mask registers. */
53476:     "movq $0xFFFF800000000000, %r13"     "\n"
53476:     "movq $0x00007FFFFFFFFFFF, %r14"     "\n"
53476: 
52557:     /* Build the JIT frame.
52557:      * rdi = cx
52557:      * rsi = fp
52557:      * rcx = inlineCallCount
52557:      * fp must go into rbx
52557:      */
53422:     "pushq %rsi"                         "\n" /* entryFp */
53422:     "pushq %rcx"                         "\n" /* inlineCallCount */
53422:     "pushq %rdi"                         "\n" /* cx */
53422:     "pushq %rsi"                         "\n" /* fp */
52557:     "movq  %rsi, %rbx"                   "\n"
52557: 
52557:     /* Space for the rest of the VMFrame. */
53471:     "subq  $0x28, %rsp"                  "\n"
52557: 
53471:     /*
53471:      * This is actually part of the VMFrame, but we need to save |r8| for
53471:      * SafePointTrampoline.
53471:      */
53471:     "pushq %r8"                          "\n"
53471: 
53471:     /* Set cx->regs and set the active frame. Save rdx and align frame in one. */
52557:     "pushq %rdx"                         "\n"
52557:     "movq  %rsp, %rdi"                   "\n"
52557:     "call " SYMBOL_STRING_RELOC(SetVMFrameRegs) "\n"
53168:     "movq  %rsp, %rdi"                   "\n"
53168:     "call " SYMBOL_STRING_RELOC(PushActiveVMFrame) "\n"
52557: 
52557:     /*
53472:      * Jump into into the JIT'd code.
52557:      */
53471:     "call *0(%rsp)"                      "\n"
53471:     "movq %rsp, %rdi"                    "\n"
53168:     "call " SYMBOL_STRING_RELOC(PopActiveVMFrame) "\n"
53471:     "movq %rsp, %rdi"                    "\n"
52557:     "call " SYMBOL_STRING_RELOC(UnsetVMFrameRegs) "\n"
52557: 
53471:     "addq $0x58, %rsp"                   "\n"
52557:     "popq %rbx"                          "\n"
52557:     "popq %r15"                          "\n"
52557:     "popq %r14"                          "\n"
52557:     "popq %r13"                          "\n"
52557:     "popq %r12"                          "\n"
52557:     "popq %rbp"                          "\n"
52557:     "movq $1, %rax"                      "\n"
52557:     "ret"                                "\n"
52557: );
52557: 
52557: asm volatile (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerThrowpoline)  "\n"
52557: SYMBOL_STRING(JaegerThrowpoline) ":"        "\n"
52557:     "movq %rsp, %rdi"                       "\n"
52557:     "call " SYMBOL_STRING_RELOC(js_InternalThrow) "\n"
52557:     "testq %rax, %rax"                      "\n"
52557:     "je   throwpoline_exit"                 "\n"
52557:     "jmp  *%rax"                            "\n"
52557:   "throwpoline_exit:"                       "\n"
53168:     "movq %rsp, %rdi"                       "\n"
53168:     "call " SYMBOL_STRING_RELOC(PopActiveVMFrame) "\n"
53162:     "addq $0x58, %rsp"                      "\n"
52557:     "popq %rbx"                             "\n"
52557:     "popq %r15"                             "\n"
52557:     "popq %r14"                             "\n"
52557:     "popq %r13"                             "\n"
52557:     "popq %r12"                             "\n"
52557:     "popq %rbp"                             "\n"
53169:     "xorq %rax,%rax"                        "\n"
52557:     "ret"                                   "\n"
52557: );
52557: 
53372: JS_STATIC_ASSERT(offsetof(JSStackFrame, ncode) == 0x60);
53483: JS_STATIC_ASSERT(offsetof(VMFrame, regs.fp) == 0x38);
53372: 
52557: asm volatile (
52557: ".text\n"
53471: ".globl " SYMBOL_STRING(SafePointTrampoline)   "\n"
53471: SYMBOL_STRING(SafePointTrampoline) ":"         "\n"
53471:     "popq %rax"                             "\n"
53471:     "movq %rax, 0x60(%rbx)"                 "\n"
53471:     "jmp  *8(%rsp)"                         "\n"
53471: );
53471: 
53471: asm volatile (
53471: ".text\n"
53471: ".globl " SYMBOL_STRING(InjectJaegerReturn)   "\n"
53471: SYMBOL_STRING(InjectJaegerReturn) ":"         "\n"
53475:     "movq 0x40(%rbx), %rcx"                 "\n" /* load Value into typeReg */
53475:     "movq 0x60(%rbx), %rax"                 "\n" /* fp->ncode */
53372: 
53475:     /* Reimplementation of PunboxAssembler::loadValueAsComponents() */
53476:     "movq %r14, %rdx"                       "\n" /* payloadReg = payloadMaskReg */
53475:     "andq %rcx, %rdx"                       "\n"
53475:     "xorq %rdx, %rcx"                       "\n"
53372: 
53422:     "movq 0x38(%rsp), %rbx"                 "\n" /* f.fp */
53475:     "jmp *%rax"                             "\n" /* return. */
52557: );
52557: 
52557: # elif defined(JS_CPU_X86)
52557: 
52557: /*
52557:  *    *** DANGER ***
52557:  * If these assertions break, update the constants below. The throwpoline
52557:  * should have the offset of savedEBX plus 4, because it needs to clean
52557:  * up the argument.
52557:  *    *** DANGER ***
52557:  */
52557: JS_STATIC_ASSERT(offsetof(VMFrame, savedEBX) == 0x2c);
53483: JS_STATIC_ASSERT(offsetof(VMFrame, regs.fp) == 0x1C);
52557: 
52557: asm volatile (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerTrampoline) "\n"
52557: SYMBOL_STRING(JaegerTrampoline) ":"       "\n"
52557:     /* Prologue. */
52557:     "pushl %ebp"                         "\n"
52557:     "movl %esp, %ebp"                    "\n"
52557:     /* Save non-volatile registers. */
52557:     "pushl %esi"                         "\n"
52557:     "pushl %edi"                         "\n"
52557:     "pushl %ebx"                         "\n"
52557: 
52557:     /* Build the JIT frame. Push fields in order, 
52557:      * then align the stack to form esp == VMFrame. */
53471:     "movl  12(%ebp), %ebx"               "\n"   /* load fp */
53422:     "pushl %ebx"                         "\n"   /* entryFp */
53471:     "pushl 20(%ebp)"                     "\n"   /* stackLimit */
53471:     "pushl 8(%ebp)"                      "\n"   /* cx */
53471:     "pushl %ebx"                         "\n"   /* fp */
53471:     "subl $0x1C, %esp"                   "\n"
52557: 
52557:     /* Jump into the JIT'd code. */
52557:     "movl  %esp, %ecx"                   "\n"
52557:     "call " SYMBOL_STRING_RELOC(SetVMFrameRegs) "\n"
53168:     "movl  %esp, %ecx"                   "\n"
53168:     "call " SYMBOL_STRING_RELOC(PushActiveVMFrame) "\n"
52557: 
53471:     "call  *16(%ebp)"                    "\n"
53471:     "movl  %esp, %ecx"                   "\n"
53168:     "call " SYMBOL_STRING_RELOC(PopActiveVMFrame) "\n"
53471:     "movl  %esp, %ecx"                   "\n"
52557:     "call " SYMBOL_STRING_RELOC(UnsetVMFrameRegs) "\n"
52557: 
53471:     "addl $0x2C, %esp"                   "\n"
52557:     "popl %ebx"                          "\n"
52557:     "popl %edi"                          "\n"
52557:     "popl %esi"                          "\n"
52557:     "popl %ebp"                          "\n"
52557:     "movl $1, %eax"                      "\n"
52557:     "ret"                                "\n"
52557: );
52557: 
52557: asm volatile (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerThrowpoline)  "\n"
52557: SYMBOL_STRING(JaegerThrowpoline) ":"        "\n"
52557:     /* Align the stack to 16 bytes. */
52557:     "pushl %esp"                         "\n"
52557:     "pushl (%esp)"                       "\n"
52557:     "pushl (%esp)"                       "\n"
52557:     "pushl (%esp)"                       "\n"
52557:     "call " SYMBOL_STRING_RELOC(js_InternalThrow) "\n"
52557:     /* Bump the stack by 0x2c, as in the basic trampoline, but
52557:      * also one more word to clean up the stack for js_InternalThrow,
52557:      * and another to balance the alignment above. */
52557:     "addl $0x10, %esp"                   "\n"
52557:     "testl %eax, %eax"                   "\n"
52557:     "je   throwpoline_exit"              "\n"
52557:     "jmp  *%eax"                         "\n"
52557:   "throwpoline_exit:"                    "\n"
53168:     "movl %esp, %ecx"                    "\n"
53168:     "call " SYMBOL_STRING_RELOC(PopActiveVMFrame) "\n"
52557:     "addl $0x2c, %esp"                   "\n"
52557:     "popl %ebx"                          "\n"
52557:     "popl %edi"                          "\n"
52557:     "popl %esi"                          "\n"
52557:     "popl %ebp"                          "\n"
52557:     "xorl %eax, %eax"                    "\n"
52557:     "ret"                                "\n"
52557: );
52557: 
53370: JS_STATIC_ASSERT(offsetof(JSStackFrame, ncode) == 0x3C);
53483: JS_STATIC_ASSERT(offsetof(VMFrame, regs.fp) == 0x1C);
53370: 
52557: asm volatile (
52557: ".text\n"
53471: ".globl " SYMBOL_STRING(InjectJaegerReturn)   "\n"
53471: SYMBOL_STRING(InjectJaegerReturn) ":"         "\n"
53370:     "movl 0x28(%ebx), %edx"                 "\n" /* fp->rval data */
53370:     "movl 0x2C(%ebx), %ecx"                 "\n" /* fp->rval type */
53370:     "movl 0x3C(%ebx), %eax"                 "\n" /* fp->ncode */
53422:     "movl 0x1C(%esp), %ebx"                 "\n" /* f.fp */
53471:     "pushl %eax"                            "\n"
53133:     "ret"                                   "\n"
52557: );
52557: 
53471: /*
53471:  * Take the fifth parameter from JaegerShot() and jump to it. This makes it so
53471:  * we can jump into arbitrary JIT code, which won't have the frame-fixup prologue.
53471:  */
53471: asm volatile (
53471: ".text\n"
53471: ".globl " SYMBOL_STRING(SafePointTrampoline)   "\n"
53471: SYMBOL_STRING(SafePointTrampoline) ":"         "\n"
53471:     "popl %eax"                             "\n"
53471:     "movl %eax, 0x3C(%ebx)"                 "\n"
53471:     "jmp  *24(%ebp)"                        "\n"
53471: );
53471: 
52557: # elif defined(JS_CPU_ARM)
52557: 
53361: JS_STATIC_ASSERT(sizeof(VMFrame) == 80);
53430: JS_STATIC_ASSERT(offsetof(VMFrame, savedLR) ==          (4*19));
53430: JS_STATIC_ASSERT(offsetof(VMFrame, entryFp) ==          (4*10));
53430: JS_STATIC_ASSERT(offsetof(VMFrame, stackLimit) ==       (4*9));
53430: JS_STATIC_ASSERT(offsetof(VMFrame, cx) ==               (4*8));
53483: JS_STATIC_ASSERT(offsetof(VMFrame, regs.fp) ==          (4*7));
53430: JS_STATIC_ASSERT(offsetof(VMFrame, oldRegs) ==          (4*4));
53430: JS_STATIC_ASSERT(offsetof(VMFrame, previous) ==         (4*3));
53471: JS_STATIC_ASSERT(offsetof(JSStackFrame, ncode) == 60);
52557: 
52557: asm volatile (
52557: ".text\n"
53471: ".globl " SYMBOL_STRING(InjectJaegerReturn)   "\n"
53471: SYMBOL_STRING(InjectJaegerReturn) ":"         "\n"
52557:     /* Restore frame regs. */
53471:     "ldr r1, [r11, #40]"                    "\n" /* fp->rval data */
53471:     "ldr r2, [r11, #44]"                    "\n" /* fp->rval type */
53471:     "ldr r0, [r11, #60]"                    "\n" /* fp->ncode */
53471:     "ldr r11, [sp, #28]"                    "\n" /* load f.fp */
52557:     "bx  r0"                                "\n"
52557: );
52557: 
52557: asm volatile (
52557: ".text\n"
53471: ".globl " SYMBOL_STRING(SafePointTrampoline)  "\n"
53471: SYMBOL_STRING(SafePointTrampoline) ":"
53472:     /*
53472:      * On entry to SafePointTrampoline:
53472:      *         r11 = fp
53472:      *      sp[80] = safePoint
53472:      */
53472:     "ldr    ip, [sp, #80]"                  "\n"
53472:     /* Save the return address (in JaegerTrampoline) to fp->ncode. */
53471:     "str    lr, [r11, #60]"                 "\n"
53472:     /* Jump to 'safePoint' via 'ip' because a load into the PC from an address on
53472:      * the stack looks like a return, and may upset return stack prediction. */
53472:     "bx     ip"                             "\n"
53471: );
53471: 
53471: asm volatile (
53471: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerTrampoline)   "\n"
52557: SYMBOL_STRING(JaegerTrampoline) ":"         "\n"
53361:     /*
53361:      * On entry to JaegerTrampoline:
53361:      *         r0 = cx
53361:      *         r1 = fp
53361:      *         r2 = code
53472:      *         r3 = stackLimit
53472:      *      sp[0] = safePoint
53361:      *
53361:      * The VMFrame for ARM looks like this:
52557:      *  [ lr        ]   \
52557:      *  [ r11       ]   |
52557:      *  [ r10       ]   |
52557:      *  [ r9        ]   | Callee-saved registers.                             
52557:      *  [ r8        ]   | VFP registers d8-d15 may be required here too, but  
52557:      *  [ r7        ]   | unconditionally preserving them might be expensive
52557:      *  [ r6        ]   | considering that we might not use them anyway.
52557:      *  [ r5        ]   |
52557:      *  [ r4        ]   /
53430:      *  [ entryFp   ]
53430:      *  [ stkLimit  ]
53361:      *  [ cx        ]
53493:      *  [ regs.fp   ]
53493:      *  [ regs.pc   ]
53361:      *  [ regs.sp   ]
53361:      *  [ oldRegs   ]
53361:      *  [ previous  ]
53472:      *  [ args.ptr3 ]
53472:      *  [ args.ptr2 ]
53361:      *  [ args.ptr  ]
52557:      */
52557:     
53472:     /* Push callee-saved registers. */
53361: "   push    {r4-r11,lr}"                        "\n"
53361:     /* Push interesting VMFrame content. */
53430: "   push    {r1}"                               "\n"    /* entryFp */
53430: "   push    {r3}"                               "\n"    /* stackLimit */
53430: "   push    {r0}"                               "\n"    /* cx */
53493: "   push    {r1}"                               "\n"    /* regs.fp */
53361:     /* Remaining fields are set elsewhere, but we need to leave space for them. */
53430: "   sub     sp, sp, #(4*7)"                     "\n"
52557: 
53472:     /* Preserve 'code' (r2) in an arbitrary callee-saved register. */
53472: "   mov     r4, r2"                             "\n"
53472:     /* Preserve 'fp' (r1) in r11 (JSFrameReg) for SafePointTrampoline. */
53472: "   mov     r11, r1"                            "\n"
53472: 
52557: "   mov     r0, sp"                             "\n"
53361: "   bl  " SYMBOL_STRING_RELOC(SetVMFrameRegs)   "\n"
53361: "   mov     r0, sp"                             "\n"
53361: "   bl  " SYMBOL_STRING_RELOC(PushActiveVMFrame)"\n"
52557: 
53471:     /* Call the compiled JavaScript function. */
53361: "   blx     r4"                                 "\n"
52557: 
53361:     /* Tidy up. */
52557: "   mov     r0, sp"                             "\n"
53361: "   bl  " SYMBOL_STRING_RELOC(PopActiveVMFrame) "\n"
53361: "   mov     r0, sp"                             "\n"
53361: "   bl  " SYMBOL_STRING_RELOC(UnsetVMFrameRegs) "\n"
52557: 
52557:     /* Skip past the parameters we pushed (such as cx and the like). */
53430: "   add     sp, sp, #(4*7 + 4*4)"               "\n"
52557: 
52557:     /* Set a 'true' return value to indicate successful completion. */
52557: "   mov     r0, #1"                         "\n"
53361: "   pop     {r4-r11,pc}"                    "\n"
52557: );
52557: 
52557: asm volatile (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerThrowpoline)  "\n"
52557: SYMBOL_STRING(JaegerThrowpoline) ":"        "\n"
53472:     /* Find the VMFrame pointer for js_InternalThrow. */
52557: "   mov     r0, sp"                         "\n"
52557: 
52557:     /* Call the utility function that sets up the internal throw routine. */
53361: "   bl  " SYMBOL_STRING_RELOC(js_InternalThrow) "\n"
52557:     
53472:     /* If js_InternalThrow found a scripted handler, jump to it. Otherwise, tidy
53472:      * up and return. */
52557: "   cmp     r0, #0"                         "\n"
52557: "   bxne    r0"                             "\n"
52557: 
53472:     /* Tidy up, then return '0' to represent an unhandled exception. */
53472: "   mov     r0, sp"                             "\n"
53472: "   bl  " SYMBOL_STRING_RELOC(PopActiveVMFrame) "\n"
53430: "   add     sp, sp, #(4*7 + 4*4)"               "\n"
53472: "   mov     r0, #0"                         "\n"
53361: "   pop     {r4-r11,pc}"                    "\n"
52557: );
52557: 
52557: asm volatile (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerStubVeneer)   "\n"
52557: SYMBOL_STRING(JaegerStubVeneer) ":"         "\n"
52557:     /* We enter this function as a veneer between a compiled method and one of the js_ stubs. We
52557:      * need to store the LR somewhere (so it can be modified in case on an exception) and then
52557:      * branch to the js_ stub as if nothing had happened.
52557:      * The arguments are identical to those for js_* except that the target function should be in
53361:      * 'ip'. */
53361: "   push    {ip,lr}"                        "\n"
52557: "   blx     ip"                             "\n"
53361: "   pop     {ip,pc}"                        "\n"
52557: );
52557: 
52557: # else
52557: #  error "Unsupported CPU!"
52557: # endif
52557: #elif defined(_MSC_VER)
52557: 
52557: #if defined(JS_CPU_X86)
52557: 
52557: /*
52557:  *    *** DANGER ***
52557:  * If these assertions break, update the constants below. The throwpoline
52557:  * should have the offset of savedEBX plus 4, because it needs to clean
52557:  * up the argument.
52557:  *    *** DANGER ***
52557:  */
52557: JS_STATIC_ASSERT(offsetof(VMFrame, savedEBX) == 0x2c);
53482: JS_STATIC_ASSERT(offsetof(VMFrame, regs.fp) == 0x1C);
52557: 
52557: extern "C" {
52557: 
53471:     __declspec(naked) void InjectJaegerReturn()
52557:     {
52557:         __asm {
53133:             mov edx, [ebx + 0x28];
53133:             mov ecx, [ebx + 0x2C];
53133:             mov eax, [ebx + 0x3C];
53422:             mov ebx, [esp + 0x1C];
53471:             push eax;
53133:             ret;
52557:         }
52557:     }
52557: 
53471:     __declspec(naked) void SafePointTrampoline()
53471:     {
53471:         __asm {
53471:             pop eax;
53471:             mov [ebx + 0x3C], eax;
53471:             jmp [ebp + 24];
53471:         }
53471:     }
53471: 
52557:     __declspec(naked) JSBool JaegerTrampoline(JSContext *cx, JSStackFrame *fp, void *code,
53471:                                               Value *stackLimit, void *safePoint)
52557:     {
52557:         __asm {
52557:             /* Prologue. */
52557:             push ebp;
52557:             mov ebp, esp;
52557:             /* Save non-volatile registers. */
52557:             push esi;
52557:             push edi;
52557:             push ebx;
52557: 
52557:             /* Build the JIT frame. Push fields in order, 
52557:              * then align the stack to form esp == VMFrame. */
53422:             mov  ebx, [ebp + 12];
53422:             push ebx;
52557:             push [ebp + 20];
52557:             push [ebp + 8];
53422:             push ebx;
53471:             sub  esp, 0x1C;
52557: 
52557:             /* Jump into into the JIT'd code. */
52557:             mov  ecx, esp;
52557:             call SetVMFrameRegs;
53169:             mov  ecx, esp;
53169:             call PushActiveVMFrame;
52557: 
53471:             call [ebp + 16];
53471:             mov  ecx, esp;
53169:             call PopActiveVMFrame;
53471:             mov  ecx, esp;
52557:             call UnsetVMFrameRegs;
52557: 
53471:             add esp, 0x2C;
52557: 
52557:             pop ebx;
52557:             pop edi;
52557:             pop esi;
52557:             pop ebp;
52557:             mov eax, 1;
52557:             ret;
52557:         }
52557:     }
52557: 
52557:     extern "C" void *js_InternalThrow(js::VMFrame &f);
52557: 
52557:     __declspec(naked) void *JaegerThrowpoline(js::VMFrame *vmFrame) {
52557:         __asm {
52557:             /* Align the stack to 16 bytes. */
52557:             push esp;
52557:             push [esp];
52557:             push [esp];
52557:             push [esp];
52557:             call js_InternalThrow;
52557:             /* Bump the stack by 0x2c, as in the basic trampoline, but
52557:              * also one more word to clean up the stack for js_InternalThrow,
52557:              * and another to balance the alignment above. */
52557:             add esp, 0x10;
52557:             test eax, eax;
52557:             je throwpoline_exit;
52557:             jmp eax;
52557:         throwpoline_exit:
53169:             mov ecx, esp;
53169:             call PopActiveVMFrame;
52557:             add esp, 0x2c;
52557:             pop ebx;
52557:             pop edi;
52557:             pop esi;
52557:             pop ebp;
52557:             xor eax, eax
52557:             ret;
52557:         }
52557:     }
52557: }
52557: 
52557: #elif defined(JS_CPU_X64)
52557: 
52557: /*
52557:  *    *** DANGER ***
52557:  * If these assertions break, update the constants below.
52557:  *    *** DANGER ***
52557:  */
53477: JS_STATIC_ASSERT(offsetof(VMFrame, savedRBX) == 0x58);
53483: JS_STATIC_ASSERT(offsetof(VMFrame, regs.fp) == 0x38);
53477: JS_STATIC_ASSERT(offsetof(JSStackFrame, ncode) == 0x60);
53477: JS_STATIC_ASSERT(JSVAL_TAG_MASK == 0xFFFF800000000000LL);
53477: JS_STATIC_ASSERT(JSVAL_PAYLOAD_MASK == 0x00007FFFFFFFFFFFLL);
52557: 
52557: // Windows x64 uses assembler version since compiler doesn't support
52557: // inline assembler
52557: #else
52557: #  error "Unsupported CPU!"
52557: #endif
52557: 
52557: #endif                   /* _MSC_VER */
52557: 
52557: bool
52557: ThreadData::Initialize()
52557: {
52557:     execPool = new JSC::ExecutableAllocator();
52557:     if (!execPool)
52557:         return false;
52557:     
53168:     TrampolineCompiler tc(execPool, &trampolines);
53168:     if (!tc.compile()) {
53168:         delete execPool;
53168:         return false;
53168:     }
53168: 
53137: #ifdef JS_METHODJIT_PROFILE_STUBS
53137:     for (size_t i = 0; i < STUB_CALLS_FOR_OP_COUNT; ++i)
53137:         StubCallsForOp[i] = 0;
53137: #endif
53137: 
53168:     activeFrame = NULL;
53168: 
52557:     return true;
52557: }
52557: 
52557: void
52557: ThreadData::Finish()
52557: {
53168:     TrampolineCompiler::release(&trampolines);
52557:     delete execPool;
52853: #ifdef JS_METHODJIT_PROFILE_STUBS
52853:     FILE *fp = fopen("/tmp/stub-profiling", "wt");
52853: # define OPDEF(op,val,name,image,length,nuses,ndefs,prec,format) \
52853:     fprintf(fp, "%03d %s %d\n", val, #op, StubCallsForOp[val]);
52853: # include "jsopcode.tbl"
52853: # undef OPDEF
52853:     fclose(fp);
52853: #endif
52557: }
52557: 
52557: extern "C" JSBool JaegerTrampoline(JSContext *cx, JSStackFrame *fp, void *code,
53471:                                    Value *stackLimit, void *safePoint);
53471: extern "C" void SafePointTrampoline();
52557: 
53471: static inline JSBool
53471: EnterMethodJIT(JSContext *cx, JSStackFrame *fp, void *code, void *safePoint)
52557: {
52557:     JS_ASSERT(cx->regs);
52557:     JS_CHECK_RECURSION(cx, return JS_FALSE;);
52557: 
52557: #ifdef JS_METHODJIT_SPEW
52557:     Profiler prof;
53471:     JSScript *script = fp->getScript();
52557: 
53471:     JaegerSpew(JSpew_Prof, "%s jaeger script: %s, line %d\n",
53471:                safePoint ? "dropping" : "entering",
53471:                script->filename, script->lineno);
52557:     prof.start();
52557: #endif
52557: 
52557: #ifdef DEBUG
52557:     JSStackFrame *checkFp = fp;
52557: #endif
53422: 
53422:     Value *stackLimit = cx->stack().makeStackLimit(reinterpret_cast<Value*>(fp));
52557: 
52557:     JSAutoResolveFlags rf(cx, JSRESOLVE_INFER);
53471:     JSBool ok = JaegerTrampoline(cx, fp, code, stackLimit, safePoint);
52557: 
53482:     JS_ASSERT(checkFp == cx->fp());
52557: 
52557: #ifdef JS_METHODJIT_SPEW
52557:     prof.stop();
52557:     JaegerSpew(JSpew_Prof, "script run took %d ms\n", prof.time_ms());
52557: #endif
52557: 
52557:     return ok;
52557: }
52557: 
53471: JSBool
53471: mjit::JaegerShot(JSContext *cx)
53471: {
53482:     JSScript *script = cx->fp()->getScript();
53471: 
53471:     JS_ASSERT(script->ncode && script->ncode != JS_UNJITTABLE_METHOD);
53471: 
53471: #ifdef JS_TRACER
53471:     if (TRACE_RECORDER(cx))
53471:         AbortRecording(cx, "attempt to enter method JIT while recording");
53471: #endif
53471: 
53471:     JS_ASSERT(cx->regs->pc == script->code);
53471: 
53498:     return EnterMethodJIT(cx, cx->fp(), script->jit->invoke, NULL);
53471: }
53471: 
53471: JSBool
53471: js::mjit::JaegerShotAtSafePoint(JSContext *cx, void *safePoint)
53471: {
53471: #ifdef JS_TRACER
53471:     JS_ASSERT(!TRACE_RECORDER(cx));
53471: #endif
53471: 
53471:     void *code = JS_FUNC_TO_DATA_PTR(void *, SafePointTrampoline);
53471: 
53482:     return EnterMethodJIT(cx, cx->fp(), code, safePoint);
53471: }
53471: 
52880: template <typename T>
52880: static inline void Destroy(T &t)
52880: {
52880:     t.~T();
52880: }
52880: 
52559: void
52559: mjit::ReleaseScriptCode(JSContext *cx, JSScript *script)
52559: {
53498:     if (script->jit) {
53168: #if defined DEBUG && (defined JS_CPU_X86 || defined JS_CPU_X64) 
53498:         memset(script->jit->invoke, 0xcc, script->jit->inlineLength +
53498:                script->jit->outOfLineLength);
53168: #endif
53498:         script->jit->execPool->release();
53498:         script->jit->execPool = NULL;
52559:         // Releasing the execPool takes care of releasing the code.
52559:         script->ncode = NULL;
52559: 
53119: #if defined JS_POLYIC
53498:         for (uint32 i = 0; i < script->jit->nPICs; i++) {
52880:             script->pics[i].releasePools();
52880:             Destroy(script->pics[i].execPools);
52880:         }
52559: #endif
53499:         cx->free(script->jit);
52559:     }
52559: }
52559: 
52853: #ifdef JS_METHODJIT_PROFILE_STUBS
52853: void JS_FASTCALL
52853: mjit::ProfileStubCall(VMFrame &f)
52853: {
52853:     JSOp op = JSOp(*f.regs.pc);
52853:     StubCallsForOp[op]++;
52853: }
52853: #endif
52853: 
53422: bool
53422: VMFrame::slowEnsureSpace(uint32 nslots)
53422: {
53423:     return cx->stack().ensureSpace(cx, reinterpret_cast<Value*>(entryFp), regs.sp,
53422:                                    stackLimit, nslots);
53422: }
53422: 
