19246: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
19246: /* ***** BEGIN LICENSE BLOCK *****
19246:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19246:  *
19246:  * The contents of this file are subject to the Mozilla Public License Version
19246:  * 1.1 (the "License"); you may not use this file except in compliance with
19246:  * the License. You may obtain a copy of the License at
19246:  * http://www.mozilla.org/MPL/
19246:  *
19246:  * Software distributed under the License is distributed on an "AS IS" basis,
19246:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19246:  * for the specific language governing rights and limitations under the
19246:  * License.
19246:  *
19246:  * The Original Code is mozilla.org code.
19246:  *
19246:  * The Initial Developer of the Original Code is
19246:  * Netscape Communications Corporation.
19246:  * Portions created by the Initial Developer are Copyright (C) 1998
19246:  * the Initial Developer. All Rights Reserved.
19246:  *
19246:  * Contributor(s):
19246:  *   Josh Aas <josh@mozilla.com>
19246:  *
19246:  * Alternatively, the contents of this file may be used under the terms of
19246:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19246:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19246:  * in which case the provisions of the GPL or the LGPL are applicable instead
19246:  * of those above. If you wish to allow use of your version of this file only
19246:  * under the terms of either the GPL or the LGPL, and not to allow others to
19246:  * use your version of this file under the terms of the MPL, indicate your
19246:  * decision by deleting the provisions above and replace them with the notice
19246:  * and other provisions required by the GPL or the LGPL. If you do not delete
19246:  * the provisions above, a recipient may use your version of this file under
19246:  * the terms of any one of the MPL, the GPL or the LGPL.
19246:  *
19246:  * ***** END LICENSE BLOCK ***** */
19246: 
36001: #ifdef MOZ_IPC
36001: #include "base/basictypes.h"
36001: #endif 
36001: 
19246: #include "prtypes.h"
19246: #include "prmem.h"
35740: #include "prenv.h"
19246: #include "prclist.h"
19246: #include "nsAutoLock.h"
19246: #include "nsNPAPIPlugin.h"
19246: #include "nsNPAPIPluginInstance.h"
19246: #include "nsNPAPIPluginStreamListener.h"
19246: #include "nsIServiceManager.h"
19246: #include "nsThreadUtils.h"
24475: #include "nsIPrivateBrowsingService.h"
19246: 
19246: #include "nsIPluginStreamListener.h"
19246: #include "nsPluginsDir.h"
19246: #include "nsPluginSafety.h"
19246: #include "nsIPrefService.h"
19246: #include "nsIPrefBranch.h"
19246: #include "nsPluginLogging.h"
19246: 
19246: #include "nsIJSContextStack.h"
19246: 
19246: #include "nsIDOMElement.h"
19246: #include "nsIDOMDocument.h"
19246: #include "nsPIDOMWindow.h"
19246: #include "nsIDocument.h"
19246: #include "nsIScriptGlobalObject.h"
19246: #include "nsIScriptContext.h"
19246: #include "nsDOMJSUtils.h"
19246: #include "nsIPrincipal.h"
19246: 
33405: #include "jscntxt.h"
33405: 
19246: #include "nsIXPConnect.h"
19246: 
19246: #include "nsIObserverService.h"
19246: #include <prinrval.h>
19246: 
19246: #ifdef XP_MACOSX
19246: #include <Carbon/Carbon.h>
19246: #endif
19246: 
19246: // needed for nppdf plugin
19246: #ifdef MOZ_WIDGET_GTK2
19246: #include <gdk/gdk.h>
19246: #include <gdk/gdkx.h>
19246: #include "gtk2xtbin.h"
19246: #endif
19246: 
32955: #ifdef XP_OS2
32955: #define INCL_DOS
32955: #define INCL_DOSERRORS
32955: #include <os2.h>
32955: #endif
32955: 
19246: #include "nsJSNPRuntime.h"
23571: #include "nsIHttpAuthManager.h"
23571: #include "nsICookieService.h"
19246: 
36010: #include "mozilla/PluginLibrary.h"
36010: using mozilla::PluginLibrary;
36010: 
36010: #include "mozilla/PluginPRLibrary.h"
36010: using mozilla::PluginPRLibrary;
35802: 
35802: #ifdef MOZ_IPC
35893: #include "mozilla/plugins/PluginModuleParent.h"
35893: using mozilla::plugins::PluginModuleParent;
35802: #endif
35740: 
37780: static NPNetscapeFuncs sBrowserFuncs;
19246: static PRLock *sPluginThreadAsyncCallLock = nsnull;
19246: static PRCList sPendingAsyncCalls = PR_INIT_STATIC_CLIST(&sPendingAsyncCalls);
19246: 
19246: // POST/GET stream type
19246: enum eNPPStreamTypeInternal {
19246:   eNPPStreamTypeInternal_Get,
19246:   eNPPStreamTypeInternal_Post
19246: };
19246: 
19246: static NS_DEFINE_IID(kMemoryCID, NS_MEMORY_CID);
19246: 
36125: using namespace mozilla::plugins::parent;
19246: 
19246: // This function sends a notification using the observer service to any object
19246: // registered to listen to the "experimental-notify-plugin-call" subject.
19246: // Each "experimental-notify-plugin-call" notification carries with it the run
19246: // time value in milliseconds that the call took to execute.
19246: void NS_NotifyPluginCall(PRIntervalTime startTime) 
19246: {
19246:   PRIntervalTime endTime = PR_IntervalNow() - startTime;
19246:   nsCOMPtr<nsIObserverService> notifyUIService =
19246:     do_GetService("@mozilla.org/observer-service;1");
28733:   if (!notifyUIService)
28733:     return;
28733: 
19246:   float runTimeInSeconds = float(endTime) / PR_TicksPerSecond();
19246:   nsAutoString runTimeString;
19246:   runTimeString.AppendFloat(runTimeInSeconds);
19246:   const PRUnichar* runTime = runTimeString.get();
19246:   notifyUIService->NotifyObservers(nsnull, "experimental-notify-plugin-call",
19246:                                    runTime);
19246: }
19246: 
19246: void
37780: nsNPAPIPlugin::CheckClassInitialized()
19246: {
19246:   static PRBool initialized = PR_FALSE;
19246: 
19246:   if (initialized)
19246:     return;
19246: 
19246:   // XXX It'd be nice to make this const and initialize it statically...
37780:   sBrowserFuncs.size = sizeof(sBrowserFuncs);
37780:   sBrowserFuncs.version = (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR;
37780:   sBrowserFuncs.geturl = ((NPN_GetURLProcPtr)_geturl);
37780:   sBrowserFuncs.posturl = ((NPN_PostURLProcPtr)_posturl);
37780:   sBrowserFuncs.requestread = ((NPN_RequestReadProcPtr)_requestread);
37780:   sBrowserFuncs.newstream = ((NPN_NewStreamProcPtr)_newstream);
37780:   sBrowserFuncs.write = ((NPN_WriteProcPtr)_write);
37780:   sBrowserFuncs.destroystream = ((NPN_DestroyStreamProcPtr)_destroystream);
37780:   sBrowserFuncs.status = ((NPN_StatusProcPtr)_status);
37780:   sBrowserFuncs.uagent = ((NPN_UserAgentProcPtr)_useragent);
37780:   sBrowserFuncs.memalloc = ((NPN_MemAllocProcPtr)_memalloc);
37780:   sBrowserFuncs.memfree = ((NPN_MemFreeProcPtr)_memfree);
37780:   sBrowserFuncs.memflush = ((NPN_MemFlushProcPtr)_memflush);
37780:   sBrowserFuncs.reloadplugins = ((NPN_ReloadPluginsProcPtr)_reloadplugins);
37780:   sBrowserFuncs.getJavaEnv = ((NPN_GetJavaEnvProcPtr)_getJavaEnv);
37780:   sBrowserFuncs.getJavaPeer = ((NPN_GetJavaPeerProcPtr)_getJavaPeer);
37780:   sBrowserFuncs.geturlnotify = ((NPN_GetURLNotifyProcPtr)_geturlnotify);
37780:   sBrowserFuncs.posturlnotify = ((NPN_PostURLNotifyProcPtr)_posturlnotify);
37780:   sBrowserFuncs.getvalue = ((NPN_GetValueProcPtr)_getvalue);
37780:   sBrowserFuncs.setvalue = ((NPN_SetValueProcPtr)_setvalue);
37780:   sBrowserFuncs.invalidaterect = ((NPN_InvalidateRectProcPtr)_invalidaterect);
37780:   sBrowserFuncs.invalidateregion = ((NPN_InvalidateRegionProcPtr)_invalidateregion);
37780:   sBrowserFuncs.forceredraw = ((NPN_ForceRedrawProcPtr)_forceredraw);
37780:   sBrowserFuncs.getstringidentifier = ((NPN_GetStringIdentifierProcPtr)_getstringidentifier);
37780:   sBrowserFuncs.getstringidentifiers = ((NPN_GetStringIdentifiersProcPtr)_getstringidentifiers);
37780:   sBrowserFuncs.getintidentifier = ((NPN_GetIntIdentifierProcPtr)_getintidentifier);
37780:   sBrowserFuncs.identifierisstring = ((NPN_IdentifierIsStringProcPtr)_identifierisstring);
37780:   sBrowserFuncs.utf8fromidentifier = ((NPN_UTF8FromIdentifierProcPtr)_utf8fromidentifier);
37780:   sBrowserFuncs.intfromidentifier = ((NPN_IntFromIdentifierProcPtr)_intfromidentifier);
37780:   sBrowserFuncs.createobject = ((NPN_CreateObjectProcPtr)_createobject);
37780:   sBrowserFuncs.retainobject = ((NPN_RetainObjectProcPtr)_retainobject);
37780:   sBrowserFuncs.releaseobject = ((NPN_ReleaseObjectProcPtr)_releaseobject);
37780:   sBrowserFuncs.invoke = ((NPN_InvokeProcPtr)_invoke);
37780:   sBrowserFuncs.invokeDefault = ((NPN_InvokeDefaultProcPtr)_invokeDefault);
37780:   sBrowserFuncs.evaluate = ((NPN_EvaluateProcPtr)_evaluate);
37780:   sBrowserFuncs.getproperty = ((NPN_GetPropertyProcPtr)_getproperty);
37780:   sBrowserFuncs.setproperty = ((NPN_SetPropertyProcPtr)_setproperty);
37780:   sBrowserFuncs.removeproperty = ((NPN_RemovePropertyProcPtr)_removeproperty);
37780:   sBrowserFuncs.hasproperty = ((NPN_HasPropertyProcPtr)_hasproperty);
37780:   sBrowserFuncs.hasmethod = ((NPN_HasMethodProcPtr)_hasmethod);
37780:   sBrowserFuncs.enumerate = ((NPN_EnumerateProcPtr)_enumerate);
37780:   sBrowserFuncs.construct = ((NPN_ConstructProcPtr)_construct);
37780:   sBrowserFuncs.releasevariantvalue = ((NPN_ReleaseVariantValueProcPtr)_releasevariantvalue);
37780:   sBrowserFuncs.setexception = ((NPN_SetExceptionProcPtr)_setexception);
37780:   sBrowserFuncs.pushpopupsenabledstate = ((NPN_PushPopupsEnabledStateProcPtr)_pushpopupsenabledstate);
37780:   sBrowserFuncs.poppopupsenabledstate = ((NPN_PopPopupsEnabledStateProcPtr)_poppopupsenabledstate);
37780:   sBrowserFuncs.pluginthreadasynccall = ((NPN_PluginThreadAsyncCallProcPtr)_pluginthreadasynccall);
37780:   sBrowserFuncs.getvalueforurl = ((NPN_GetValueForURLPtr)_getvalueforurl);
37780:   sBrowserFuncs.setvalueforurl = ((NPN_SetValueForURLPtr)_setvalueforurl);
37780:   sBrowserFuncs.getauthenticationinfo = ((NPN_GetAuthenticationInfoPtr)_getauthenticationinfo);
37780:   sBrowserFuncs.scheduletimer = ((NPN_ScheduleTimerPtr)_scheduletimer);
37780:   sBrowserFuncs.unscheduletimer = ((NPN_UnscheduleTimerPtr)_unscheduletimer);
37780:   sBrowserFuncs.popupcontextmenu = ((NPN_PopUpContextMenuPtr)_popupcontextmenu);
37780:   sBrowserFuncs.convertpoint = ((NPN_ConvertPointPtr)_convertpoint);
20125: 
20125:   if (!sPluginThreadAsyncCallLock)
20125:     sPluginThreadAsyncCallLock = nsAutoLock::NewLock("sPluginThreadAsyncCallLock");
19246: 
19246:   initialized = PR_TRUE;
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN callbacks initialized\n"));
19246: }
19246: 
30057: NS_IMPL_ISUPPORTS1(nsNPAPIPlugin, nsIPlugin)
19246: 
35740: nsNPAPIPlugin::nsNPAPIPlugin(NPPluginFuncs* callbacks, 
36010:                              PluginLibrary* aLibrary)
19246: {
37780:   memset((void*) &mPluginFuncs, 0, sizeof(mPluginFuncs));
37780: 
37780:   mPluginFuncs.size = sizeof(mPluginFuncs);
37780:   mLibrary = nsnull;
19246: 
19246: #if defined(XP_WIN) || defined(XP_OS2)
37780:   // On Windows and OS/2 we need to keep a direct reference to
37780:   // the plugin's function struct, we can't just copy it. See
37780:   // Mozilla bug 85334.
19246: 
36010:   NPError gepError;
37780:   nsresult gepResult = aLibrary->NP_GetEntryPoints(&mPluginFuncs, &gepError);
36010:   if (gepResult != NS_OK || gepError != NPERR_NO_ERROR)
19246:     return;
19246: 
37780:   NS_ASSERTION(HIBYTE(mPluginFuncs.version) >= NP_VERSION_MAJOR,
19246:                "callback version is less than NP version");
19246: 
19246: #elif defined(XP_MACOSX)
19246:   NPPluginFuncs np_callbacks;
19246:   memset((void*) &np_callbacks, 0, sizeof(np_callbacks));
19246:   np_callbacks.size = sizeof(np_callbacks);
19246: 
36010:   if (!aLibrary->HasRequiredFunctions()) {
22537:     NS_WARNING("Not all necessary functions exposed by plugin, it will not load.");
22537:     return;
22537:   }
22537: 
19246:   // we call NP_Initialize before getting function pointers to match
19246:   // WebKit's behavior. They implemented this first on Mac OS X.
36010:   NPError initError;
37780:   nsresult initResult = aLibrary->NP_Initialize(&(sBrowserFuncs), &initError);
36010:   if (initResult != NS_OK || initError != NPERR_NO_ERROR)
19246:     return;
36010:   NPError gepError;
36010:   nsresult gepResult = aLibrary->NP_GetEntryPoints(&np_callbacks, &gepError);
36010:   if (gepResult != NS_OK || gepError != NPERR_NO_ERROR)
19246:     return;
19246: 
37780:   mPluginFuncs.version = np_callbacks.version;
37780:   mPluginFuncs.newp = (NPP_NewProcPtr)np_callbacks.newp;
37780:   mPluginFuncs.destroy = (NPP_DestroyProcPtr)np_callbacks.destroy;
37780:   mPluginFuncs.setwindow = (NPP_SetWindowProcPtr)np_callbacks.setwindow;
37780:   mPluginFuncs.newstream = (NPP_NewStreamProcPtr)np_callbacks.newstream;
37780:   mPluginFuncs.destroystream = (NPP_DestroyStreamProcPtr)np_callbacks.destroystream;
37780:   mPluginFuncs.asfile = (NPP_StreamAsFileProcPtr)np_callbacks.asfile;
37780:   mPluginFuncs.writeready = (NPP_WriteReadyProcPtr)np_callbacks.writeready;
37780:   mPluginFuncs.write = (NPP_WriteProcPtr)np_callbacks.write;
37780:   mPluginFuncs.print = (NPP_PrintProcPtr)np_callbacks.print;
37780:   mPluginFuncs.event = (NPP_HandleEventProcPtr)np_callbacks.event;
37780:   mPluginFuncs.urlnotify = (NPP_URLNotifyProcPtr)np_callbacks.urlnotify;
37780:   mPluginFuncs.getvalue = (NPP_GetValueProcPtr)np_callbacks.getvalue;
37780:   mPluginFuncs.setvalue = (NPP_SetValueProcPtr)np_callbacks.setvalue;
19246: #else // for everyone else
37780:   memcpy((void*) &mPluginFuncs, (void*) callbacks, sizeof(mPluginFuncs));
19246: #endif
19246: 
37780:   mLibrary = aLibrary;
37780:   mLibrary->SetPlugin(this);
19246: }
19246: 
30212: nsNPAPIPlugin::~nsNPAPIPlugin()
19246: {
19246:   // reset the callbacks list
37780:   memset((void*) &mPluginFuncs, 0, sizeof(mPluginFuncs));
37780:   delete mLibrary;
37780:   mLibrary = NULL;
19246: }
19246: 
22811: 
22811: #if defined(XP_MACOSX)
22811: void
22811: nsNPAPIPlugin::SetPluginRefNum(short aRefNum)
22811: {
37780:   mPluginRefNum = aRefNum;
22811: }
22811: #endif
22811: 
36304: #ifdef MOZ_IPC
36304: void
36304: nsNPAPIPlugin::PluginCrashed()
36304: {
36304:   nsRefPtr<nsPluginHost> host = dont_AddRef(nsPluginHost::GetInst());
36304:   host->PluginCrashed(this);
36304: }
36304: #endif
36304: 
35811: namespace {
35811: 
35811: #ifdef MOZ_IPC
35811: 
35811: inline PRBool
37609: OOPPluginsEnabled(const char* aFilePath)
35811: {
35811:   if (PR_GetEnv("MOZ_DISABLE_OOP_PLUGINS")) {
35811:     return PR_FALSE;
35811:   }
35811: 
36981: #ifdef XP_WIN
36981:   OSVERSIONINFO osVerInfo = {0};
36981:   osVerInfo.dwOSVersionInfoSize = sizeof(osVerInfo);
36981:   GetVersionEx(&osVerInfo);
36981:   // Always disabled on 2K or less. (bug 536303)
36981:   if (osVerInfo.dwMajorVersion < 5 ||
36981:       (osVerInfo.dwMajorVersion == 5 && osVerInfo.dwMinorVersion == 0))
36981:     return PR_FALSE;
36981: #endif
36981: 
37609:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
37609:   if (!prefs) {
37609:     return PR_FALSE;
37609:   }
37609: 
37609:   // Get per-library whitelist/blacklist pref string
37609:   // "dom.ipc.plugins.enabled.filename.dll" and fall back to the default value
37609:   // of "dom.ipc.plugins.enabled"
37609: 
37609:   nsCAutoString pluginLibPref(aFilePath);
37609:   PRInt32 slashPos = pluginLibPref.RFindCharInSet("/\\");
37609:   if (kNotFound == slashPos)
37609:     return PR_FALSE;
37609:   pluginLibPref.Cut(0, slashPos + 1);
37609:   ToLowerCase(pluginLibPref);
37609:   pluginLibPref.Insert("dom.ipc.plugins.enabled.", 0);
37609: 
37609:   PRBool oopPluginsEnabled = PR_FALSE;
37609:   if (NS_SUCCEEDED(prefs->GetBoolPref(pluginLibPref.get(),
37609:                                       &oopPluginsEnabled)))
37609:     return oopPluginsEnabled;
37609: 
37609:   oopPluginsEnabled = PR_FALSE;
37609:   prefs->GetBoolPref("dom.ipc.plugins.enabled", &oopPluginsEnabled);
37609:   return oopPluginsEnabled;
35811: }
35811: 
35811: #endif // MOZ_IPC
35811: 
36010: inline PluginLibrary*
36010: GetNewPluginLibrary(const char* aFilePath,
35811:                     PRLibrary* aLibrary)
35811: {
35811: #ifdef MOZ_IPC
37609:   if (aFilePath && OOPPluginsEnabled(aFilePath)) {
36010:     return PluginModuleParent::LoadModule(aFilePath);
35811:   }
35811: #endif
36010:   return new PluginPRLibrary(aFilePath, aLibrary);
35811: }
35811: 
35811: } /* anonymous namespace */
35811: 
19246: // Creates the nsNPAPIPlugin object. One nsNPAPIPlugin object exists per plugin (not instance).
19246: nsresult
29020: nsNPAPIPlugin::CreatePlugin(const char* aFilePath, PRLibrary* aLibrary,
29020:                             nsIPlugin** aResult)
19246: {
19246:   CheckClassInitialized();
19246: 
19246: #if defined(XP_UNIX) && !defined(XP_MACOSX)
19246:   nsNPAPIPlugin *plptr;
19246: 
19246:   NPPluginFuncs callbacks;
19246:   memset((void*) &callbacks, 0, sizeof(callbacks));
19246:   callbacks.size = sizeof(callbacks);
19246: 
36010:   PluginLibrary* pluginLib = GetNewPluginLibrary(aFilePath, aLibrary);
19246: 
19246:   // create the new plugin handler
36010:   *aResult = plptr = new nsNPAPIPlugin(&callbacks, pluginLib);
19246: 
19246:   if (*aResult == NULL)
19246:     return NS_ERROR_OUT_OF_MEMORY;
19246: 
19246:   NS_ADDREF(*aResult);
19246: 
29020:   // Do not initialize if the file path is NULL.
29020:   if (!aFilePath)
19246:     return NS_OK;
19246: 
19246:   // we must init here because the plugin may call NPN functions
19246:   // when we call into the NP_Initialize entry point - NPN functions
19246:   // require that mBrowserManager be set up
19246:   plptr->Initialize();
19246: 
36010:   NPError initError;
37780:   nsresult initResult = pluginLib->NP_Initialize(&(sBrowserFuncs),&callbacks, &initError);
36102:   if (initResult != NS_OK || initError != NPERR_NO_ERROR) {
36102:     NS_RELEASE(*aResult);
21231:     return NS_ERROR_UNEXPECTED;
36102:   }
19246: 
19246:   // now copy function table back to nsNPAPIPlugin instance
37780:   memcpy((void*) &(plptr->mPluginFuncs), (void*)&callbacks, sizeof(callbacks));
19246: #endif
19246: 
19246: #ifdef XP_WIN
36010:   PluginLibrary* pluginLib = GetNewPluginLibrary(aFilePath, aLibrary);
35746: 
19246:   // Note: on Windows, we must use the fCallback because plugins may
19246:   // change the function table. The Shockwave installer makes changes
19246:   // in the table while running
36010:   *aResult = new nsNPAPIPlugin(nsnull, pluginLib);
19246: 
19246:   if (*aResult == NULL)
19246:     return NS_ERROR_OUT_OF_MEMORY;
19246: 
19246:   NS_ADDREF(*aResult);
19246: 
19246:   // we must init here because the plugin may call NPN functions
19246:   // when we call into the NP_Initialize entry point - NPN functions
19246:   // require that mBrowserManager be set up
19246:   if (NS_FAILED((*aResult)->Initialize())) {
19246:     NS_RELEASE(*aResult);
19246:     return NS_ERROR_FAILURE;
19246:   }
19246: 
36010:   NPError initError;
37780:   nsresult initResult = pluginLib->NP_Initialize(&(sBrowserFuncs), &initError);
36010:   if (initResult != NS_OK || initError != NPERR_NO_ERROR)
36010:     return NS_ERROR_FAILURE;
19246: #endif
19246: 
19246: #ifdef XP_OS2
36039:   PluginLibrary* pluginLib = GetNewPluginLibrary(aFilePath, aLibrary);
36039: 
19246:   // create the new plugin handler
36039:   *aResult = new nsNPAPIPlugin(nsnull, pluginLib);
19246: 
19246:   if (*aResult == NULL)
19246:     return NS_ERROR_OUT_OF_MEMORY;
19246: 
19246:   NS_ADDREF(*aResult);
19246: 
19246:   // we must init here because the plugin may call NPN functions
19246:   // when we call into the NP_Initialize entry point - NPN functions
19246:   // require that mBrowserManager be set up
19246:   if (NS_FAILED((*aResult)->Initialize())) {
19246:     NS_RELEASE(*aResult);
19246:     return NS_ERROR_FAILURE;
19246:   }
19246: 
19246:   NP_PLUGININIT pfnInitialize =
19246:     (NP_PLUGININIT)PR_FindSymbol(aLibrary, "NP_Initialize");
19246: 
21231:   if (!pfnInitialize)
21231:     return NS_ERROR_UNEXPECTED;
19246: 
19246:   // Fixes problem where the OS/2 native multimedia plugins weren't
19246:   // working on mozilla though did work on 4.x.  Problem is that they
19246:   // expect the current working directory to be the plugins dir.
19246:   // Since these plugins are no longer maintained and they represent
19246:   // the majority of the OS/2 plugin contingency, we'll have to make
19246:   // them work here.
19246: 
19246: #define MAP_DISKNUM_TO_LETTER(n) ('A' + (n - 1))
19246: #define MAP_LETTER_TO_DISKNUM(c) (toupper(c)-'A'+1)
19246: 
19246:   unsigned long origDiskNum, pluginDiskNum, logicalDisk;
19246: 
19246:   char pluginPath[CCHMAXPATH], origPath[CCHMAXPATH];
29020:   strcpy(pluginPath, aFilePath);
19246:   char* slash = strrchr(pluginPath, '\\');
19246:   *slash = '\0';
19246: 
19246:   DosQueryCurrentDisk( &origDiskNum, &logicalDisk );
19246:   pluginDiskNum = MAP_LETTER_TO_DISKNUM(pluginPath[0]);
19246: 
19246:   origPath[0] = MAP_DISKNUM_TO_LETTER(origDiskNum);
19246:   origPath[1] = ':';
19246:   origPath[2] = '\\';
19246: 
19246:   ULONG len = CCHMAXPATH-3;
19246:   APIRET rc = DosQueryCurrentDir(0, &origPath[3], &len);
19246:   NS_ASSERTION(NO_ERROR == rc,"DosQueryCurrentDir failed");
19246: 
19246:   BOOL bChangedDir = FALSE;
19246:   BOOL bChangedDisk = FALSE;
19246:   if (pluginDiskNum != origDiskNum) {
19246:     rc = DosSetDefaultDisk(pluginDiskNum);
19246:     NS_ASSERTION(NO_ERROR == rc,"DosSetDefaultDisk failed");
19246:     bChangedDisk = TRUE;
19246:   }
19246: 
19246:   if (stricmp(origPath, pluginPath) != 0) {
19246:     rc = DosSetCurrentDir(pluginPath);
19246:     NS_ASSERTION(NO_ERROR == rc,"DosSetCurrentDir failed");
19246:     bChangedDir = TRUE;
19246:   }
19246: 
37780:   nsresult rv = pfnInitialize(&(sBrowserFuncs));
19246: 
19246:   if (bChangedDisk) {
19246:     rc= DosSetDefaultDisk(origDiskNum);
19246:     NS_ASSERTION(NO_ERROR == rc,"DosSetDefaultDisk failed");
19246:   }
19246:   if (bChangedDir) {
19246:     rc = DosSetCurrentDir(origPath);
19246:     NS_ASSERTION(NO_ERROR == rc,"DosSetCurrentDir failed");
19246:   }
19246: 
19246:   if (!NS_SUCCEEDED(rv)) {
19246:     return NS_ERROR_UNEXPECTED;
19246:   }
19246: #endif
19246: 
19246: #if defined(XP_MACOSX)
31406: #ifndef __LP64__
22811:   short appRefNum = ::CurResFile();
22811:   short pluginRefNum;
22811: 
19246:   nsCOMPtr<nsILocalFile> pluginPath;
29020:   NS_NewNativeLocalFile(nsDependentCString(aFilePath), PR_TRUE,
19246:                         getter_AddRefs(pluginPath));
19246:   nsPluginFile pluginFile(pluginPath);
31406: 
22811:   pluginRefNum = pluginFile.OpenPluginResource();
31406: #endif
19246: 
36010:   PluginLibrary* pluginLib = GetNewPluginLibrary(aFilePath, aLibrary);
36010:   nsNPAPIPlugin* plugin = new nsNPAPIPlugin(nsnull, pluginLib);
31406: #ifndef __LP64__
22811:   ::UseResFile(appRefNum);
31406: #endif
19246:   if (!plugin)
19246:     return NS_ERROR_OUT_OF_MEMORY;
19246: 
19246:   *aResult = plugin;
19246: 
19246:   NS_ADDREF(*aResult);
19246:   if (NS_FAILED((*aResult)->Initialize())) {
19246:     NS_RELEASE(*aResult);
19246:     return NS_ERROR_FAILURE;
19246:   }
22811: 
31406: #ifndef __LP64__
22811:   plugin->SetPluginRefNum(pluginRefNum);
19246: #endif
31406: #endif
19246: 
19246: #ifdef XP_BEOS
19246:   // I just copied UNIX version.
19246:   // Makoto Hamanaka <VYA04230@nifty.com>
19246: 
36039:   // XXX this code won't compile with the new e10s changes
36039: 
19246:   nsNPAPIPlugin *plptr;
19246: 
19246:   NPPluginFuncs callbacks;
19246:   memset((void*) &callbacks, 0, sizeof(callbacks));
19246:   callbacks.size = sizeof(callbacks);
19246: 
19246:   NP_PLUGINSHUTDOWN pfnShutdown =
19246:     (NP_PLUGINSHUTDOWN)PR_FindSymbol(aLibrary, "NP_Shutdown");
19246: 
19246:   // create the new plugin handler
21231:   *aResult = plptr = new nsNPAPIPlugin(&callbacks, aLibrary, pfnShutdown);
19246: 
19246:   if (*aResult == NULL)
19246:     return NS_ERROR_OUT_OF_MEMORY;
19246: 
19246:   NS_ADDREF(*aResult);
19246: 
19246:   // we must init here because the plugin may call NPN functions
19246:   // when we call into the NP_Initialize entry point - NPN functions
19246:   // require that mBrowserManager be set up
19246:   plptr->Initialize();
19246: 
19246:   NP_PLUGINUNIXINIT pfnInitialize =
19246:     (NP_PLUGINUNIXINIT)PR_FindSymbol(aLibrary, "NP_Initialize");
19246: 
21231:   if (!pfnInitialize)
19246:     return NS_ERROR_FAILURE;
19246: 
37780:   if (pfnInitialize(&(sBrowserFuncs),&callbacks) != NS_OK)
19246:     return NS_ERROR_FAILURE;
19246: 
19246:   // now copy function table back to nsNPAPIPlugin instance
37780:   memcpy((void*) &(plptr->mPluginFuncs), (void*)&callbacks, sizeof(callbacks));
19246: #endif
19246: 
19246:   return NS_OK;
19246: }
19246: 
30057: NS_METHOD
30057: nsNPAPIPlugin::CreatePluginInstance(nsIPluginInstance **aResult)
19246: {
21231:   if (!aResult)
19246:     return NS_ERROR_NULL_POINTER;
19246: 
19246:   *aResult = NULL;
19246: 
37841:   nsRefPtr<nsNPAPIPluginInstance> inst =
37841:     new nsNPAPIPluginInstance(&mPluginFuncs, mLibrary);
19246:   if (!inst)
19246:     return NS_ERROR_OUT_OF_MEMORY;
19246: 
30057:   NS_ADDREF(inst);
30057:   *aResult = static_cast<nsIPluginInstance*>(inst);
19246:   return NS_OK;
19246: }
19246: 
19246: nsresult
37780: nsNPAPIPlugin::Initialize()
19246: {
37780:   if (!mLibrary)
19246:     return NS_ERROR_FAILURE;
19246:   return NS_OK;
19246: }
19246: 
19246: nsresult
37780: nsNPAPIPlugin::Shutdown()
19246: {
19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
19246:                  ("NPP Shutdown to be called: this=%p\n", this));
19246: 
36010:   NPError shutdownError;
37780:   mLibrary->NP_Shutdown(&shutdownError);
36010: #ifdef XP_MACOSX
37780:   if (shutdownError == NS_OK && mPluginRefNum > 0)
37780:     ::CloseResFile(mPluginRefNum);
19246: #endif
19246:   return NS_OK;
19246: }
19246: 
19246: nsresult
19246: nsNPAPIPlugin::GetMIMEDescription(const char* *resultingDesc)
19246: {
37780:   nsresult gmdResult = mLibrary->NP_GetMIMEDescription(resultingDesc);
36010:   if (gmdResult != NS_OK) {
36010:     return gmdResult;
36010:   }
19246: 
19246:   return NS_OK;
19246: }
19246: 
19246: nsresult
32799: nsNPAPIPlugin::GetValue(NPPVariable variable, void *value)
19246: {
19246:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("nsNPAPIPlugin::GetValue called: this=%p, variable=%d\n", this, variable));
19246: 
36010:   NPError gvError;
37780:   mLibrary->NP_GetValue(nsnull, variable, value, &gvError);
36010: 
36010:   return gvError;
19246: }
19246: 
19246: // Create a new NPP GET or POST (given in the type argument) url
19246: // stream that may have a notify callback
19246: NPError
19246: MakeNewNPAPIStreamInternal(NPP npp, const char *relativeURL, const char *target,
19246:                           eNPPStreamTypeInternal type,
19246:                           PRBool bDoNotify = PR_FALSE,
19246:                           void *notifyData = nsnull, uint32_t len = 0,
19246:                           const char *buf = nsnull, NPBool file = PR_FALSE)
19246: {
19246:   if (!npp)
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
21231:   if (!inst)
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
29574:   nsCOMPtr<nsIPluginHost> pluginHost = do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
29574:   NS_ASSERTION(pluginHost, "failed to get plugin host");
29574:   if (!pluginHost) return NPERR_GENERIC_ERROR;
19246: 
19246:   nsCOMPtr<nsIPluginStreamListener> listener;
21231:   if (!target)
19246:     ((nsNPAPIPluginInstance*)inst)->NewNotifyStream(getter_AddRefs(listener),
19246:                                                     notifyData,
19246:                                                     bDoNotify, relativeURL);
19246: 
19246:   switch (type) {
19246:   case eNPPStreamTypeInternal_Get:
19246:     {
29574:       if (NS_FAILED(pluginHost->GetURL(inst, relativeURL, target, listener)))
19246:         return NPERR_GENERIC_ERROR;
19246:       break;
19246:     }
19246:   case eNPPStreamTypeInternal_Post:
19246:     {
29574:       if (NS_FAILED(pluginHost->PostURL(inst, relativeURL, len, buf, file, target,
19246:                                 listener)))
19246:         return NPERR_GENERIC_ERROR;
19246:       break;
19246:     }
19246:   default:
31561:     NS_ERROR("how'd I get here");
19246:   }
19246: 
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
36125: #if defined(MOZ_MEMORY_WINDOWS) && !defined(MOZ_MEMORY_WINCE)
36125: extern "C" size_t malloc_usable_size(const void *ptr);
36125: #endif
36125: 
36125: namespace {
36125: 
36125: static char *gNPPException;
36125: 
36125: // A little helper class used to wrap up plugin manager streams (that is,
36125: // streams from the plugin to the browser).
36125: class nsNPAPIStreamWrapper : nsISupports
36125: {
36125: public:
36125:   NS_DECL_ISUPPORTS
36125: 
36125: protected:
36125:   nsIOutputStream *fStream;
36125:   NPStream        fNPStream;
36125: 
36125: public:
36125:   nsNPAPIStreamWrapper(nsIOutputStream* stream);
36125:   ~nsNPAPIStreamWrapper();
36125: 
36125:   void GetStream(nsIOutputStream* &result);
37780:   NPStream* GetNPStream() { return &fNPStream; }
36125: };
36125: 
36125: class nsPluginThreadRunnable : public nsRunnable,
36125:                                public PRCList
36125: {
36125: public:
36125:   nsPluginThreadRunnable(NPP instance, PluginThreadCallback func,
36125:                          void *userData);
36125:   virtual ~nsPluginThreadRunnable();
36125: 
36125:   NS_IMETHOD Run();
36125: 
36125:   PRBool IsForInstance(NPP instance)
36125:   {
36125:     return (mInstance == instance);
36125:   }
36125: 
36125:   void Invalidate()
36125:   {
36125:     mFunc = nsnull;
36125:   }
36125: 
36125:   PRBool IsValid()
36125:   {
36125:     return (mFunc != nsnull);
36125:   }
36125: 
36125: private:  
36125:   NPP mInstance;
36125:   PluginThreadCallback mFunc;
36125:   void *mUserData;
36125: };
36125: 
36125: static nsIDocument *
36125: GetDocumentFromNPP(NPP npp)
36125: {
36125:   NS_ENSURE_TRUE(npp, nsnull);
36125: 
36125:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
36125:   NS_ENSURE_TRUE(inst, nsnull);
36125: 
36125:   PluginDestructionGuard guard(inst);
36125: 
36125:   nsCOMPtr<nsIPluginInstanceOwner> owner;
36125:   inst->GetOwner(getter_AddRefs(owner));
36125:   NS_ENSURE_TRUE(owner, nsnull);
36125: 
36125:   nsCOMPtr<nsIDocument> doc;
36125:   owner->GetDocument(getter_AddRefs(doc));
36125: 
36125:   return doc;
36125: }
36125: 
36125: static JSContext *
36125: GetJSContextFromDoc(nsIDocument *doc)
36125: {
36125:   nsIScriptGlobalObject *sgo = doc->GetScriptGlobalObject();
36125:   NS_ENSURE_TRUE(sgo, nsnull);
36125: 
36125:   nsIScriptContext *scx = sgo->GetContext();
36125:   NS_ENSURE_TRUE(scx, nsnull);
36125: 
36125:   return (JSContext *)scx->GetNativeContext();
36125: }
36125: 
36125: static JSContext *
36125: GetJSContextFromNPP(NPP npp)
36125: {
36125:   nsIDocument *doc = GetDocumentFromNPP(npp);
36125:   NS_ENSURE_TRUE(doc, nsnull);
36125: 
36125:   return GetJSContextFromDoc(doc);
36125: }
36125: 
36125: static NPIdentifier
36125: doGetIdentifier(JSContext *cx, const NPUTF8* name)
36125: {
36125:   NS_ConvertUTF8toUTF16 utf16name(name);
36125: 
36125:   JSString *str = ::JS_InternUCStringN(cx, (jschar *)utf16name.get(),
36125:                                        utf16name.Length());
36125: 
36125:   if (!str)
36125:     return NULL;
36125: 
36125:   return (NPIdentifier)STRING_TO_JSVAL(str);
36125: }
36125: 
36125: #if defined(MOZ_MEMORY_WINDOWS) && !defined(MOZ_MEMORY_WINCE)
36125: BOOL
36125: InHeap(HANDLE hHeap, LPVOID lpMem)
36125: {
36125:   BOOL success = FALSE;
36125:   PROCESS_HEAP_ENTRY he;
36125:   he.lpData = NULL;
36125:   while (HeapWalk(hHeap, &he) != 0) {
36125:     if (he.lpData == lpMem) {
36125:       success = TRUE;
36125:       break;
36125:     }
36125:   }
36125:   HeapUnlock(hHeap);
36125:   return success;
36125: }
36125: #endif
36125: 
36125: } /* anonymous namespace */
36125: 
36125: NS_IMPL_ISUPPORTS1(nsNPAPIStreamWrapper, nsISupports)
36125: 
36125: nsNPAPIStreamWrapper::nsNPAPIStreamWrapper(nsIOutputStream* stream)
36125: : fStream(stream)
36125: {
36125:   NS_ASSERTION(stream, "bad stream");
36125: 
36125:   fStream = stream;
36125:   NS_ADDREF(fStream);
36125: 
36125:   memset(&fNPStream, 0, sizeof(fNPStream));
36125:   fNPStream.ndata = (void*) this;
36125: }
36125: 
37780: nsNPAPIStreamWrapper::~nsNPAPIStreamWrapper()
36125: {
36125:   fStream->Close();
36125:   NS_IF_RELEASE(fStream);
36125: }
36125: 
36125: void
36125: nsNPAPIStreamWrapper::GetStream(nsIOutputStream* &result)
36125: {
36125:   result = fStream;
36125:   NS_IF_ADDREF(fStream);
36125: }
36125: 
36125: NPPExceptionAutoHolder::NPPExceptionAutoHolder()
36125:   : mOldException(gNPPException)
36125: {
36125:   gNPPException = nsnull;
36125: }
36125: 
36125: NPPExceptionAutoHolder::~NPPExceptionAutoHolder()
36125: {
36125:   NS_ASSERTION(!gNPPException, "NPP exception not properly cleared!");
36125: 
36125:   gNPPException = mOldException;
36125: }
36125: 
36125: nsPluginThreadRunnable::nsPluginThreadRunnable(NPP instance,
36125:                                                PluginThreadCallback func,
36125:                                                void *userData)
36125:   : mInstance(instance), mFunc(func), mUserData(userData)
36125: {
36125:   if (!sPluginThreadAsyncCallLock) {
36125:     // Failed to create lock, not much we can do here then...
36125:     mFunc = nsnull;
36125: 
36125:     return;
36125:   }
36125: 
36125:   PR_INIT_CLIST(this);
36125: 
36125:   {
36125:     nsAutoLock lock(sPluginThreadAsyncCallLock);
36125: 
36125:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
36355:     if (!inst || !inst->IsRunning()) {
36125:       // The plugin was stopped, ignore this async call.
36125:       mFunc = nsnull;
36125: 
36125:       return;
36125:     }
36125: 
36125:     PR_APPEND_LINK(this, &sPendingAsyncCalls);
36125:   }
36125: }
36125: 
36125: nsPluginThreadRunnable::~nsPluginThreadRunnable()
36125: {
36125:   if (!sPluginThreadAsyncCallLock) {
36125:     return;
36125:   }
36125: 
36125:   {
36125:     nsAutoLock lock(sPluginThreadAsyncCallLock);
36125: 
36125:     PR_REMOVE_LINK(this);
36125:   }
36125: }
36125: 
36125: NS_IMETHODIMP
36125: nsPluginThreadRunnable::Run()
36125: {
36125:   if (mFunc) {
36125:     PluginDestructionGuard guard(mInstance);
36125: 
36125:     NS_TRY_SAFE_CALL_VOID(mFunc(mUserData), nsnull, nsnull);
36125:   }
36125: 
36125:   return NS_OK;
36125: }
36125: 
36125: void
36125: OnPluginDestroy(NPP instance)
36125: {
36125:   if (!sPluginThreadAsyncCallLock) {
36125:     return;
36125:   }
36125: 
36125:   {
36125:     nsAutoLock lock(sPluginThreadAsyncCallLock);
36125: 
36125:     if (PR_CLIST_IS_EMPTY(&sPendingAsyncCalls)) {
36125:       return;
36125:     }
36125: 
36125:     nsPluginThreadRunnable *r =
36125:       (nsPluginThreadRunnable *)PR_LIST_HEAD(&sPendingAsyncCalls);
36125: 
36125:     do {
36125:       if (r->IsForInstance(instance)) {
36125:         r->Invalidate();
36125:       }
36125: 
36125:       r = (nsPluginThreadRunnable *)PR_NEXT_LINK(r);
36125:     } while (r != &sPendingAsyncCalls);
36125:   }
36125: }
36125: 
36125: void
36125: OnShutdown()
36125: {
36125:   NS_ASSERTION(PR_CLIST_IS_EMPTY(&sPendingAsyncCalls),
36125:                "Pending async plugin call list not cleaned up!");
36125: 
36125:   if (sPluginThreadAsyncCallLock) {
36125:     nsAutoLock::DestroyLock(sPluginThreadAsyncCallLock);
36125: 
36125:     sPluginThreadAsyncCallLock = nsnull;
36125:   }
36125: }
36125: 
36125: void
36125: EnterAsyncPluginThreadCallLock()
36125: {
36125:   if (sPluginThreadAsyncCallLock) {
36125:     PR_Lock(sPluginThreadAsyncCallLock);
36125:   }
36125: }
36125: 
36125: void
36125: ExitAsyncPluginThreadCallLock()
36125: {
36125:   if (sPluginThreadAsyncCallLock) {
36125:     PR_Unlock(sPluginThreadAsyncCallLock);
36125:   }
36125: }
36125: 
36125: NPP NPPStack::sCurrentNPP = nsnull;
36125: 
36125: const char *
36125: PeekException()
36125: {
36125:   return gNPPException;
36125: }
36125: 
36125: void
36125: PopException()
36125: {
36125:   NS_ASSERTION(gNPPException, "Uh, no NPP exception to pop!");
36125: 
36125:   if (gNPPException) {
36125:     free(gNPPException);
36125: 
36125:     gNPPException = nsnull;
36125:   }
36125: }
36125: 
19246: //
19246: // Static callbacks that get routed back through the new C++ API
19246: //
19246: 
36125: namespace mozilla {
36125: namespace plugins {
36125: namespace parent {
36125: 
19246: NPError NP_CALLBACK
19246: _geturl(NPP npp, const char* relativeURL, const char* target)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturl called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPN_GetURL: npp=%p, target=%s, url=%s\n", (void *)npp, target,
19246:    relativeURL));
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   // Block Adobe Acrobat from loading URLs that are not http:, https:,
19246:   // or ftp: URLs if the given target is null.
21231:   if (!target && relativeURL &&
19246:       (strncmp(relativeURL, "http:", 5) != 0) &&
19246:       (strncmp(relativeURL, "https:", 6) != 0) &&
19246:       (strncmp(relativeURL, "ftp:", 4) != 0)) {
19246:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
19246: 
37525:     
37525:     const char *name;
37525:     nsRefPtr<nsPluginHost> host = dont_AddRef(nsPluginHost::GetInst());
37525:     host->GetPluginName(inst, &name);
19246: 
19246:     if (name && strstr(name, "Adobe") && strstr(name, "Acrobat")) {
19246:       return NPERR_NO_ERROR;
19246:     }
19246:   }
19246: 
19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
19246:                                     eNPPStreamTypeInternal_Get);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _geturlnotify(NPP npp, const char* relativeURL, const char* target,
19246:               void* notifyData)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturlnotify called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:     ("NPN_GetURLNotify: npp=%p, target=%s, notify=%p, url=%s\n", (void*)npp,
19246:      target, notifyData, relativeURL));
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
19246:                                     eNPPStreamTypeInternal_Get, PR_TRUE,
19246:                                     notifyData);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _posturlnotify(NPP npp, const char *relativeURL, const char *target,
19246:                uint32_t len, const char *buf, NPBool file, void *notifyData)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturlnotify called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
36110:   if (!buf)
36110:     return NPERR_INVALID_PARAM;
36110: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_PostURLNotify: npp=%p, target=%s, len=%d, file=%d, "
19246:                   "notify=%p, url=%s, buf=%s\n",
19246:                   (void*)npp, target, len, file, notifyData, relativeURL,
19246:                   buf));
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
19246:                                     eNPPStreamTypeInternal_Post, PR_TRUE,
19246:                                     notifyData, len, buf, file);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _posturl(NPP npp, const char *relativeURL, const char *target,
19246:          uint32_t len, const char *buf, NPBool file)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturl called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_PostURL: npp=%p, target=%s, file=%d, len=%d, url=%s, "
19246:                   "buf=%s\n",
19246:                   (void*)npp, target, file, len, relativeURL, buf));
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
19246:                                     eNPPStreamTypeInternal_Post, PR_FALSE, nsnull,
19246:                                     len, buf, file);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _newstream(NPP npp, NPMIMEType type, const char* target, NPStream* *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_newstream called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPN_NewStream: npp=%p, type=%s, target=%s\n", (void*)npp,
19246:    (const char *)type, target));
19246: 
19246:   NPError err = NPERR_INVALID_INSTANCE_ERROR;
19246:   if (npp && npp->ndata) {
19246:     nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
19246: 
19246:     PluginDestructionGuard guard(inst);
19246: 
19246:     nsCOMPtr<nsIOutputStream> stream;
29834:     if (NS_SUCCEEDED(inst->NewStreamFromPlugin((const char*) type, target,
19246:                                                getter_AddRefs(stream)))) {
19246:       nsNPAPIStreamWrapper* wrapper = new nsNPAPIStreamWrapper(stream);
19246:       if (wrapper) {
19246:         (*result) = wrapper->GetNPStream();
19246:         err = NPERR_NO_ERROR;
19246:       } else {
19246:         err = NPERR_OUT_OF_MEMORY_ERROR;
19246:       }
19246:     } else {
19246:       err = NPERR_GENERIC_ERROR;
19246:     }
19246:   }
19246:   return err;
19246: }
19246: 
19246: int32_t NP_CALLBACK
19246: _write(NPP npp, NPStream *pstream, int32_t len, void *buffer)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
19246:     return 0;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_Write: npp=%p, url=%s, len=%d, buffer=%s\n", (void*)npp,
19246:                   pstream->url, len, (char*)buffer));
19246: 
19246:   // negative return indicates failure to the plugin
19246:   if (!npp)
19246:     return -1;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   nsNPAPIStreamWrapper* wrapper = (nsNPAPIStreamWrapper*) pstream->ndata;
21231:   NS_ASSERTION(wrapper, "null stream");
21231:   if (!wrapper)
19246:     return -1;
19246: 
19246:   nsIOutputStream* stream;
19246:   wrapper->GetStream(stream);
19246: 
19246:   PRUint32 count = 0;
19246:   nsresult rv = stream->Write((char *)buffer, len, &count);
19246:   NS_RELEASE(stream);
19246: 
19246:   if (rv != NS_OK)
19246:     return -1;
19246: 
19246:   return (int32_t)count;
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _destroystream(NPP npp, NPStream *pstream, NPError reason)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_DestroyStream: npp=%p, url=%s, reason=%d\n", (void*)npp,
19246:                   pstream->url, (int)reason));
19246: 
19246:   if (!npp)
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   nsCOMPtr<nsIPluginStreamListener> listener =
19246:     do_QueryInterface((nsISupports *)pstream->ndata);
19246: 
19246:   // DestroyStream can kill two kinds of streams: NPP derived and NPN derived.
19246:   // check to see if they're trying to kill a NPP stream
19246:   if (listener) {
19246:     // Tell the stream listner that the stream is now gone.
19246:     listener->OnStopBinding(nsnull, NS_BINDING_ABORTED);
19246: 
19246:     // FIXME: http://bugzilla.mozilla.org/show_bug.cgi?id=240131
19246:     //
19246:     // Is it ok to leave pstream->ndata set here, and who releases it
19246:     // (or is it even properly ref counted)? And who closes the stream
19246:     // etc?
19246:   } else {
19246:     nsNPAPIStreamWrapper* wrapper = (nsNPAPIStreamWrapper *)pstream->ndata;
21231:     NS_ASSERTION(wrapper, "null wrapper");
21231: 
21231:     if (!wrapper)
19246:       return NPERR_INVALID_PARAM;
19246: 
19246:     // This will release the wrapped nsIOutputStream.
19246:     delete wrapper;
19246:     pstream->ndata = nsnull;
19246:   }
19246: 
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
19246: void NP_CALLBACK
19246: _status(NPP npp, const char *message)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_status called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_Status: npp=%p, message=%s\n",
19246:                                      (void*)npp, message));
19246: 
19246:   if (!npp || !npp->ndata) {
19246:     NS_WARNING("_status: npp or npp->ndata == 0");
19246:     return;
19246:   }
19246: 
19246:   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
29834:   inst->ShowStatus(message);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _memfree (void *ptr)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memfree called from the wrong thread\n"));
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFree: ptr=%p\n", ptr));
19246: 
19246:   if (ptr)
19246:     nsMemory::Free(ptr);
19246: }
19246: 
19246: uint32_t NP_CALLBACK
19246: _memflush(uint32_t size)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memflush called from the wrong thread\n"));
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFlush: size=%d\n", size));
19246: 
19246:   nsMemory::HeapMinimize(PR_TRUE);
19246:   return 0;
19246: }
19246: 
19246: void NP_CALLBACK
19246: _reloadplugins(NPBool reloadPages)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_reloadplugins called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_ReloadPlugins: reloadPages=%d\n", reloadPages));
19246: 
29574:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
29574:   if (!pluginHost)
19246:     return;
19246: 
29574:   pluginHost->ReloadPlugins(reloadPages);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _invalidaterect(NPP npp, NPRect *invalidRect)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidaterect called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_InvalidateRect: npp=%p, top=%d, left=%d, bottom=%d, "
19246:                   "right=%d\n", (void *)npp, invalidRect->top,
19246:                   invalidRect->left, invalidRect->bottom, invalidRect->right));
19246: 
19246:   if (!npp || !npp->ndata) {
19246:     NS_WARNING("_invalidaterect: npp or npp->ndata == 0");
19246:     return;
19246:   }
19246: 
19246:   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
32799:   inst->InvalidateRect((NPRect *)invalidRect);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _invalidateregion(NPP npp, NPRegion invalidRegion)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidateregion called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:                  ("NPN_InvalidateRegion: npp=%p, region=%p\n", (void*)npp,
19246:                   (void*)invalidRegion));
19246: 
19246:   if (!npp || !npp->ndata) {
19246:     NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
19246:     return;
19246:   }
19246: 
19246:   nsIPluginInstance *inst = (nsIPluginInstance *)npp->ndata;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
32799:   inst->InvalidateRegion((NPRegion)invalidRegion);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _forceredraw(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_forceredraw called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_ForceDraw: npp=%p\n", (void*)npp));
19246: 
19246:   if (!npp || !npp->ndata) {
19246:     NS_WARNING("_forceredraw: npp or npp->ndata == 0");
19246:     return;
19246:   }
19246: 
19246:   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
29603:   inst->ForceRedraw();
19246: }
19246: 
19246: NPObject* NP_CALLBACK
19246: _getwindowobject(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getwindowobject called from the wrong thread\n"));
19246:     return nsnull;
19246:   }
19246:   JSContext *cx = GetJSContextFromNPP(npp);
19246:   NS_ENSURE_TRUE(cx, nsnull);
19246: 
19246:   // Using ::JS_GetGlobalObject(cx) is ok here since the window we
19246:   // want to return here is the outer window, *not* the inner (since
19246:   // we don't know what the plugin will do with it).
19246:   return nsJSObjWrapper::GetNewOrUsed(npp, cx, ::JS_GetGlobalObject(cx));
19246: }
19246: 
19246: NPObject* NP_CALLBACK
19246: _getpluginelement(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getpluginelement called from the wrong thread\n"));
19246:     return nsnull;
19246:   }
32369: 
32369:   nsNPAPIPluginInstance* inst = static_cast<nsNPAPIPluginInstance*>(npp->ndata);
32369:   if (!inst)
19246:     return nsnull;
32369: 
19246:   nsCOMPtr<nsIDOMElement> element;
32369:   inst->GetDOMElement(getter_AddRefs(element));
32369: 
32369:   if (!element)
32369:     return nsnull;
19246: 
19246:   JSContext *cx = GetJSContextFromNPP(npp);
19246:   NS_ENSURE_TRUE(cx, nsnull);
19246: 
19246:   nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID()));
19246:   NS_ENSURE_TRUE(xpc, nsnull);
19246: 
19246:   nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
19246:   xpc->WrapNative(cx, ::JS_GetGlobalObject(cx), element,
19246:                   NS_GET_IID(nsIDOMElement),
19246:                   getter_AddRefs(holder));
19246:   NS_ENSURE_TRUE(holder, nsnull);
19246: 
19246:   JSObject* obj = nsnull;
19246:   holder->GetJSObject(&obj);
19246:   NS_ENSURE_TRUE(obj, nsnull);
19246: 
19246:   return nsJSObjWrapper::GetNewOrUsed(npp, cx, obj);
19246: }
19246: 
19246: NPIdentifier NP_CALLBACK
19246: _getstringidentifier(const NPUTF8* name)
19246: {
19246:   if (!name) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifier: passed null name"));
19246:     return NULL;
19246:   }
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
19246:   }
19246: 
19246:   nsCOMPtr<nsIThreadJSContextStack> stack =
19246:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
19246:   if (!stack)
19246:     return NULL;
19246: 
19246:   JSContext *cx = nsnull;
19246:   stack->GetSafeJSContext(&cx);
19246:   if (!cx)
19246:     return NULL;
19246: 
19246:   JSAutoRequest ar(cx);
19246:   return doGetIdentifier(cx, name);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
19246:                       NPIdentifier *identifiers)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifiers called from the wrong thread\n"));
19246:   }
19246:   nsCOMPtr<nsIThreadJSContextStack> stack =
19246:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
19246:   if (!stack)
19246:     return;
19246: 
19246:   JSContext *cx = nsnull;
19246:   stack->GetSafeJSContext(&cx);
19246:   if (!cx)
19246:     return;
19246: 
19246:   JSAutoRequest ar(cx);
19246: 
19246:   for (int32_t i = 0; i < nameCount; ++i) {
19246:     if (names[i]) {
19246:       identifiers[i] = doGetIdentifier(cx, names[i]);
19246:     } else {
19246:       NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifiers: passed null name"));
19246:       identifiers[i] = NULL;
19246:     }
19246:   }
19246: }
19246: 
19246: NPIdentifier NP_CALLBACK
19246: _getintidentifier(int32_t intid)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
19246:   }
19246:   return (NPIdentifier)INT_TO_JSVAL(intid);
19246: }
19246: 
19246: NPUTF8* NP_CALLBACK
19246: _utf8fromidentifier(NPIdentifier identifier)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_utf8fromidentifier called from the wrong thread\n"));
19246:   }
19246:   if (!identifier)
19246:     return NULL;
19246: 
19246:   jsval v = (jsval)identifier;
19246: 
19246:   if (!JSVAL_IS_STRING(v)) {
19246:     return nsnull;
19246:   }
19246: 
19246:   JSString *str = JSVAL_TO_STRING(v);
19246: 
19246:   return
19246:     ToNewUTF8String(nsDependentString((PRUnichar *)::JS_GetStringChars(str),
19246:                                       ::JS_GetStringLength(str)));
19246: }
19246: 
19246: int32_t NP_CALLBACK
19246: _intfromidentifier(NPIdentifier identifier)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_intfromidentifier called from the wrong thread\n"));
19246:   }
19246:   jsval v = (jsval)identifier;
19246: 
19246:   if (!JSVAL_IS_INT(v)) {
19246:     return PR_INT32_MIN;
19246:   }
19246: 
19246:   return JSVAL_TO_INT(v);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _identifierisstring(NPIdentifier identifier)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_identifierisstring called from the wrong thread\n"));
19246:   }
19246:   jsval v = (jsval)identifier;
19246: 
19246:   return JSVAL_IS_STRING(v);
19246: }
19246: 
19246: NPObject* NP_CALLBACK
19246: _createobject(NPP npp, NPClass* aClass)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_createobject called from the wrong thread\n"));
19246:     return nsnull;
19246:   }
19246:   if (!npp) {
19246:     NS_ERROR("Null npp passed to _createobject()!");
19246: 
19246:     return nsnull;
19246:   }
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   if (!aClass) {
19246:     NS_ERROR("Null class passed to _createobject()!");
19246: 
19246:     return nsnull;
19246:   }
19246: 
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPObject *npobj;
19246: 
19246:   if (aClass->allocate) {
19246:     npobj = aClass->allocate(npp, aClass);
19246:   } else {
19246:     npobj = (NPObject *)PR_Malloc(sizeof(NPObject));
19246:   }
19246: 
19246:   if (npobj) {
19246:     npobj->_class = aClass;
19246:     npobj->referenceCount = 1;
36078:     NS_LOG_ADDREF(npobj, 1, "BrowserNPObject", sizeof(NPObject));
19246:   }
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("Created NPObject %p, NPClass %p\n", npobj, aClass));
19246: 
19246:   return npobj;
19246: }
19246: 
19246: NPObject* NP_CALLBACK
19246: _retainobject(NPObject* npobj)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_retainobject called from the wrong thread\n"));
19246:   }
19246:   if (npobj) {
36078:     int32_t refCnt = PR_AtomicIncrement((PRInt32*)&npobj->referenceCount);
36078:     NS_LOG_ADDREF(npobj, refCnt, "BrowserNPObject", sizeof(NPObject));
19246:   }
19246: 
19246:   return npobj;
19246: }
19246: 
19246: void NP_CALLBACK
19246: _releaseobject(NPObject* npobj)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releaseobject called from the wrong thread\n"));
19246:   }
19246:   if (!npobj)
19246:     return;
19246: 
19246:   int32_t refCnt = PR_AtomicDecrement((PRInt32*)&npobj->referenceCount);
36078:   NS_LOG_RELEASE(npobj, refCnt, "BrowserNPObject");
19246: 
19246:   if (refCnt == 0) {
19246:     nsNPObjWrapper::OnDestroy(npobj);
19246: 
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                    ("Deleting NPObject %p, refcount hit 0\n", npobj));
19246: 
19246:     if (npobj->_class && npobj->_class->deallocate) {
19246:       npobj->_class->deallocate(npobj);
19246:     } else {
19246:       PR_Free(npobj);
19246:     }
19246:   }
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
19246:         uint32_t argCount, NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invoke called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->invoke)
19246:     return false;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_Invoke(npp %p, npobj %p, method %p, args %d\n", npp,
19246:                   npobj, method, argCount));
19246: 
19246:   return npobj->_class->invoke(npobj, method, args, argCount, result);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
19246:                uint32_t argCount, NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invokedefault called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->invokeDefault)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_InvokeDefault(npp %p, npobj %p, args %d\n", npp,
19246:                   npobj, argCount));
19246: 
19246:   return npobj->_class->invokeDefault(npobj, args, argCount, result);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_evaluate called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp)
19246:     return false;
19246: 
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   nsIDocument *doc = GetDocumentFromNPP(npp);
19246:   NS_ENSURE_TRUE(doc, false);
19246: 
19246:   JSContext *cx = GetJSContextFromDoc(doc);
19246:   NS_ENSURE_TRUE(cx, false);
19246: 
36570:   nsCOMPtr<nsIScriptContext> scx = GetScriptContextFromJSContext(cx);
36570:   NS_ENSURE_TRUE(scx, false);
36570: 
19246:   JSObject *obj =
19246:     nsNPObjWrapper::GetNewOrUsed(npp, cx, npobj);
19246: 
19246:   if (!obj) {
19246:     return false;
19246:   }
19246: 
19246:   // Root obj and the rval (below).
19246:   jsval vec[] = { OBJECT_TO_JSVAL(obj), JSVAL_NULL };
19246:   JSAutoTempValueRooter tvr(cx, NS_ARRAY_LENGTH(vec), vec);
19246:   jsval *rval = &vec[1];
19246: 
19246:   if (result) {
19246:     // Initialize the out param to void
19246:     VOID_TO_NPVARIANT(*result);
19246:   }
19246: 
22867:   if (!script || !script->UTF8Length || !script->UTF8Characters) {
19246:     // Nothing to evaluate.
19246: 
19246:     return true;
19246:   }
19246: 
22867:   NS_ConvertUTF8toUTF16 utf16script(script->UTF8Characters,
22867:                                     script->UTF8Length);
19246: 
19246:   nsIPrincipal *principal = doc->NodePrincipal();
19246: 
19246:   nsCAutoString specStr;
19246:   const char *spec;
19246: 
19246:   nsCOMPtr<nsIURI> uri;
19246:   principal->GetURI(getter_AddRefs(uri));
19246: 
19246:   if (uri) {
19246:     uri->GetSpec(specStr);
19246:     spec = specStr.get();
19246:   } else {
19246:     // No URI in a principal means it's the system principal. If the
19246:     // document URI is a chrome:// URI, pass that in as the URI of the
19246:     // script, else pass in null for the filename as there's no way to
19246:     // know where this document really came from. Passing in null here
19246:     // also means that the script gets treated by XPConnect as if it
19246:     // needs additional protection, which is what we want for unknown
19246:     // chrome code anyways.
19246: 
19246:     uri = doc->GetDocumentURI();
19246:     PRBool isChrome = PR_FALSE;
19246: 
19246:     if (uri && NS_SUCCEEDED(uri->SchemeIs("chrome", &isChrome)) && isChrome) {
19246:       uri->GetSpec(specStr);
19246:       spec = specStr.get();
19246:     } else {
19246:       spec = nsnull;
19246:     }
19246:   }
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_Evaluate(npp %p, npobj %p, script <<<%s>>>) called\n",
22867:                   npp, npobj, script->UTF8Characters));
19246: 
19246:   nsresult rv = scx->EvaluateStringWithValue(utf16script, obj, principal,
19246:                                              spec, 0, 0, rval, nsnull);
19246: 
19246:   return NS_SUCCEEDED(rv) &&
19246:          (!result || JSValToNPVariant(npp, cx, *rval, result));
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
19246:              NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getproperty called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->getProperty)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_GetProperty(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, property));
19246: 
19246:   return npobj->_class->getProperty(npobj, property, result);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
19246:              const NPVariant *value)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setproperty called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->setProperty)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_SetProperty(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, property));
19246: 
19246:   return npobj->_class->setProperty(npobj, property, value);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_removeproperty called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->removeProperty)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_RemoveProperty(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, property));
19246: 
19246:   return npobj->_class->removeProperty(npobj, property);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasproperty called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasProperty)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_HasProperty(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, propertyName));
19246: 
19246:   return npobj->_class->hasProperty(npobj, propertyName);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasmethod called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasMethod)
19246:     return false;
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_HasMethod(npp %p, npobj %p, property %p) called\n",
19246:                   npp, npobj, methodName));
19246: 
23760:   return npobj->_class->hasMethod(npobj, methodName);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
19246:            uint32_t *count)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_enumerate called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class)
19246:     return false;
19246: 
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
19246:                  ("NPN_Enumerate(npp %p, npobj %p) called\n", npp, npobj));
19246: 
19246:   if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(npobj->_class) ||
19246:       !npobj->_class->enumerate) {
19246:     *identifier = 0;
19246:     *count = 0;
19246:     return true;
19246:   }
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   return npobj->_class->enumerate(npobj, identifier, count);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _construct(NPP npp, NPObject* npobj, const NPVariant *args,
19246:                uint32_t argCount, NPVariant *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_construct called from the wrong thread\n"));
19246:     return false;
19246:   }
19246:   if (!npp || !npobj || !npobj->_class ||
19246:       !NP_CLASS_STRUCT_VERSION_HAS_CTOR(npobj->_class) ||
19246:       !npobj->_class->construct) {
19246:     return false;
19246:   }
19246: 
19246:   NPPExceptionAutoHolder nppExceptionHolder;
19246:   NPPAutoPusher nppPusher(npp);
19246: 
19246:   return npobj->_class->construct(npobj, args, argCount, result);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _releasevariantvalue(NPVariant* variant)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releasevariantvalue called from the wrong thread\n"));
19246:   }
19246:   switch (variant->type) {
19246:   case NPVariantType_Void :
19246:   case NPVariantType_Null :
19246:   case NPVariantType_Bool :
19246:   case NPVariantType_Int32 :
19246:   case NPVariantType_Double :
19246:     break;
19246:   case NPVariantType_String :
19246:     {
19246:       const NPString *s = &NPVARIANT_TO_STRING(*variant);
19246: 
22867:       if (s->UTF8Characters) {
26495: #if defined(MOZ_MEMORY_WINDOWS) && !defined(MOZ_MEMORY_WINCE)
22867:         if (malloc_usable_size((void *)s->UTF8Characters) != 0) {
22867:           PR_Free((void *)s->UTF8Characters);
19246:         } else {
22867:           void *p = (void *)s->UTF8Characters;
19246:           DWORD nheaps = 0;
19246:           nsAutoTArray<HANDLE, 50> heaps;
19246:           nheaps = GetProcessHeaps(0, heaps.Elements());
19246:           heaps.AppendElements(nheaps);
19246:           GetProcessHeaps(nheaps, heaps.Elements());
19246:           for (DWORD i = 0; i < nheaps; i++) {
19246:             if (InHeap(heaps[i], p)) {
19246:               HeapFree(heaps[i], 0, p);
19246:               break;
19246:             }
19246:           }
19246:         }
19246: #else
22867:         PR_Free((void *)s->UTF8Characters);
19246: #endif
19246:       }
19246:       break;
19246:     }
19246:   case NPVariantType_Object:
19246:     {
19246:       NPObject *npobj = NPVARIANT_TO_OBJECT(*variant);
19246: 
19246:       if (npobj)
19246:         _releaseobject(npobj);
19246: 
19246:       break;
19246:     }
19246:   default:
19246:     NS_ERROR("Unknown NPVariant type!");
19246:   }
19246: 
19246:   VOID_TO_NPVARIANT(*variant);
19246: }
19246: 
19246: bool NP_CALLBACK
19246: _tostring(NPObject* npobj, NPVariant *result)
19246: {
19246:   NS_ERROR("Write me!");
19246: 
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_tostring called from the wrong thread\n"));
19246:     return false;
19246:   }
19246: 
19246:   return false;
19246: }
19246: 
19246: void NP_CALLBACK
19246: _setexception(NPObject* npobj, const NPUTF8 *message)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setexception called from the wrong thread\n"));
19246:     return;
19246:   }
19246: 
34415:   if (!message) return;
34415: 
19246:   if (gNPPException) {
19246:     // If a plugin throws multiple exceptions, we'll only report the
19246:     // last one for now.
19246:     free(gNPPException);
19246:   }
19246: 
19246:   gNPPException = strdup(message);
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _getvalue(NPP npp, NPNVariable variable, void *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getvalue called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetValue: npp=%p, var=%d\n",
19246:                                      (void*)npp, (int)variable));
19246: 
19246:   nsresult res;
19246: 
19246:   PluginDestructionGuard guard(npp);
19246: 
19246:   switch(variable) {
19246: #if defined(XP_UNIX) && !defined(XP_MACOSX)
19246:   case NPNVxDisplay : {
19246: #ifdef MOZ_WIDGET_GTK2
19246:     if (npp) {
19246:       nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
19246:       PRBool windowless = PR_FALSE;
32799:       inst->IsWindowless(&windowless);
19246:       NPBool needXEmbed = PR_FALSE;
19246:       if (!windowless) {
32799:         inst->GetValueFromPlugin(NPPVpluginNeedsXEmbed, &needXEmbed);
19246:       }
19246:       if (windowless || needXEmbed) {
19246:         (*(Display **)result) = GDK_DISPLAY();
19246:         return NPERR_NO_ERROR;
19246:       }
19246:     }
19246:     // adobe nppdf calls XtGetApplicationNameAndClass(display,
19246:     // &instance, &class) we have to init Xt toolkit before get
19246:     // XtDisplay just call gtk_xtbin_new(w,0) once
19246:     static GtkWidget *gtkXtBinHolder = 0;
19246:     if (!gtkXtBinHolder) {
27011:       gtkXtBinHolder = gtk_xtbin_new(gdk_get_default_root_window(),0);
19246:       // it crashes on destroy, let it leak
19246:       // gtk_widget_destroy(gtkXtBinHolder);
19246:     }
19246:     (*(Display **)result) =  GTK_XTBIN(gtkXtBinHolder)->xtdisplay;
19246:     return NPERR_NO_ERROR;
19246: #endif
19246:     return NPERR_GENERIC_ERROR;
19246:   }
19246: 
19246:   case NPNVxtAppContext:
19246:     return NPERR_GENERIC_ERROR;
19246: #endif
19246: 
19246: #if defined(XP_WIN) || defined(XP_OS2) || defined(MOZ_WIDGET_GTK2)
19246:   case NPNVnetscapeWindow: {
19246:     if (!npp || !npp->ndata)
19246:       return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
19246: 
29834:     nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:     inst->GetOwner(getter_AddRefs(owner));
29834:     NS_ENSURE_TRUE(owner, nsnull);
29834: 
29834:     if (NS_SUCCEEDED(owner->GetNetscapeWindow(result))) {
19246:       return NPERR_NO_ERROR;
19246:     }
19246:     return NPERR_GENERIC_ERROR;
19246:   }
19246: #endif
19246: 
19246:   case NPNVjavascriptEnabledBool: {
19246:     *(NPBool*)result = PR_FALSE;
19246:     nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
19246:     if (prefs) {
19246:       PRBool js = PR_FALSE;;
19246:       res = prefs->GetBoolPref("javascript.enabled", &js);
19246:       if (NS_SUCCEEDED(res))
19246:         *(NPBool*)result = js;
19246:     }
19246:     return NPERR_NO_ERROR;
19246:   }
19246: 
19246:   case NPNVasdEnabledBool:
19246:     *(NPBool*)result = PR_FALSE;
19246:     return NPERR_NO_ERROR;
19246: 
19246:   case NPNVisOfflineBool: {
19246:     PRBool offline = PR_FALSE;
19246:     nsCOMPtr<nsIIOService> ioservice =
19246:       do_GetService(NS_IOSERVICE_CONTRACTID, &res);
19246:     if (NS_SUCCEEDED(res))
19246:       res = ioservice->GetOffline(&offline);
19246:     if (NS_FAILED(res))
19246:       return NPERR_GENERIC_ERROR;
19246: 
19246:     *(NPBool*)result = offline;
19246:     return NPERR_NO_ERROR;
19246:   }
19246: 
19246:   case NPNVToolkit: {
19246: #ifdef MOZ_WIDGET_GTK2
19246:     *((NPNToolkitType*)result) = NPNVGtk2;
19246: #endif
19246: 
19246:     if (*(NPNToolkitType*)result)
19246:         return NPERR_NO_ERROR;
19246: 
19246:     return NPERR_GENERIC_ERROR;
19246:   }
19246: 
19246:   case NPNVSupportsXEmbedBool: {
19246: #ifdef MOZ_WIDGET_GTK2
19246:     *(NPBool*)result = PR_TRUE;
19246: #else
19246:     *(NPBool*)result = PR_FALSE;
19246: #endif
19246:     return NPERR_NO_ERROR;
19246:   }
19246: 
19246:   case NPNVWindowNPObject: {
19246:     *(NPObject **)result = _getwindowobject(npp);
19246: 
36128:     return *(NPObject **)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
19246:   }
19246: 
19246:   case NPNVPluginElementNPObject: {
19246:     *(NPObject **)result = _getpluginelement(npp);
19246: 
37830:     return *(NPObject **)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
19246:   }
19246: 
19246:   case NPNVSupportsWindowless: {
19246: #if defined(XP_WIN) || defined(XP_MACOSX) || (defined(MOZ_X11) && defined(MOZ_WIDGET_GTK2))
19246:     *(NPBool*)result = PR_TRUE;
19246: #else
19246:     *(NPBool*)result = PR_FALSE;
19246: #endif
19246:     return NPERR_NO_ERROR;
19246:   }
19246: 
24475:   case NPNVprivateModeBool: {
24475:     nsCOMPtr<nsIPrivateBrowsingService> pbs = do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
24475:     if (pbs) {
24904:       PRBool enabled;
24904:       pbs->GetPrivateBrowsingEnabled(&enabled);
24904:       *(NPBool*)result = (NPBool)enabled;
24475:       return NPERR_NO_ERROR;
24475:     }
24475:     return NPERR_GENERIC_ERROR;
24475:   }
24475: 
34217: #ifdef MOZ_PLATFORM_HILDON
34217:   case NPNVSupportsWindowlessLocal: {
34217:     *(NPBool*)result = PR_TRUE;
34217:     return NPERR_NO_ERROR;
34217:   }
34217: #endif
34217: 
19246: #ifdef XP_MACOSX
19246:   case NPNVpluginDrawingModel: {
19246:     if (npp) {
19246:       nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
19246:       if (inst) {
32799:         NPDrawingModel drawingModel;
32799:         inst->GetDrawingModel((PRInt32*)&drawingModel);
32799:         *(NPDrawingModel*)result = drawingModel;
19246:         return NPERR_NO_ERROR;
19246:       }
19246:     }
19246:     else {
19246:       return NPERR_GENERIC_ERROR;
19246:     }
19246:   }
19246: 
19246: #ifndef NP_NO_QUICKDRAW
19246:   case NPNVsupportsQuickDrawBool: {
19246:     *(NPBool*)result = PR_TRUE;
19246:     
19246:     return NPERR_NO_ERROR;
19246:   }
19246: #endif
19246: 
19246:   case NPNVsupportsCoreGraphicsBool: {
19246:     *(NPBool*)result = PR_TRUE;
19246:     
19246:     return NPERR_NO_ERROR;
19246:   }
32019: 
32019: #ifndef NP_NO_CARBON
32019:   case NPNVsupportsCarbonBool: {
32019:     *(NPBool*)result = PR_TRUE;
32019: 
32019:     return NPERR_NO_ERROR;
32019:   }
32019: #endif
32019:   case NPNVsupportsCocoaBool: {
32019:     *(NPBool*)result = PR_TRUE;
32019: 
32019:     return NPERR_NO_ERROR;
32019:   }
19246: #endif
19246: 
30374:   // we no longer hand out any XPCOM objects, except on WINCE,
30374:   // where it's needed for the ActiveX shunt that makes Flash
30374:   // work until we get an NPAPI plugin there.
30374: #ifdef WINCE
30374:   case NPNVDOMWindow: {
30374:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
30374:     NS_ENSURE_TRUE(inst, NPERR_GENERIC_ERROR);
30374: 
30374:     nsIDOMWindow *domWindow = inst->GetDOMWindow().get();
30374: 
30374:     if (domWindow) {
30374:       // Pass over ownership of domWindow to the caller.
30374:       (*(nsIDOMWindow**)result) = domWindow;
30374:       return NPERR_NO_ERROR;
30374:     }
30374: 
30374:     return NPERR_GENERIC_ERROR;
30374:   }
30374: 
30374:   case NPNVDOMElement: {
30374:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
30374:     NS_ENSURE_TRUE(inst, NPERR_GENERIC_ERROR);
30374: 
30374:     nsCOMPtr<nsIDOMElement> e;
30374:     inst->GetDOMElement(getter_AddRefs(e));
30374:     if (e) {
30374:       NS_ADDREF(*(nsIDOMElement**)result = e.get());
30374:       return NPERR_NO_ERROR;
30374:     }
30374: 
30374:     return NPERR_GENERIC_ERROR;
30374:   }
35279: #else
35279:   case NPNVDOMElement:
35279:     // fall through
35279:   case NPNVDOMWindow:
35279:     // fall through
30374: #endif /* WINCE */
35279:   case NPNVserviceManager:
35279:     // old XPCOM objects, no longer supported, but null out the out
35279:     // param to avoid crashing plugins that still try to use this.
35279:     *(nsISupports**)result = nsnull;
35279:     // fall through
19246:   default:
19246:     return NPERR_GENERIC_ERROR;
19246:   }
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _setvalue(NPP npp, NPPVariable variable, void *result)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setvalue called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_SetValue: npp=%p, var=%d\n",
19246:                                      (void*)npp, (int)variable));
19246: 
19246:   if (!npp)
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
19246: 
21231:   NS_ASSERTION(inst, "null instance");
21231: 
21231:   if (!inst)
19246:     return NPERR_INVALID_INSTANCE_ERROR;
19246: 
19246:   PluginDestructionGuard guard(inst);
19246: 
19246:   switch (variable) {
19246: 
19246:     // we should keep backward compatibility with NPAPI where the
19246:     // actual pointer value is checked rather than its content
19246:     // when passing booleans
19246:     case NPPVpluginWindowBool: {
22548: #ifdef XP_MACOSX
22548:       // This setting doesn't apply to OS X (only to Windows and Unix/Linux).
22548:       // See https://developer.mozilla.org/En/NPN_SetValue#section_5.  Return
22548:       // NPERR_NO_ERROR here to conform to other browsers' behavior on OS X
22548:       // (e.g. Safari and Opera).
22548:       return NPERR_NO_ERROR;
22548: #else
19246:       NPBool bWindowless = (result == nsnull);
19246:       return inst->SetWindowless(bWindowless);
22548: #endif
19246:     }
34217: #ifdef MOZ_PLATFORM_HILDON
34217:     case NPPVpluginWindowlessLocalBool: {
34217:       NPBool bWindowlessLocal = (result != nsnull);
34217:       return inst->SetWindowlessLocal(bWindowlessLocal);
34217:     }
34217: #endif
19246:     case NPPVpluginTransparentBool: {
19246:       NPBool bTransparent = (result != nsnull);
19246:       return inst->SetTransparent(bTransparent);
19246:     }
19246: 
19246:     case NPPVjavascriptPushCallerBool:
19246:       {
19246:         nsresult rv;
19246:         nsCOMPtr<nsIJSContextStack> contextStack =
19246:           do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
19246:         if (NS_SUCCEEDED(rv)) {
19246:           NPBool bPushCaller = (result != nsnull);
19246:           if (bPushCaller) {
19246:             JSContext *cx;
29808:             rv = inst->GetJSContext(&cx);
19246:             if (NS_SUCCEEDED(rv))
19246:               rv = contextStack->Push(cx);
19246:           } else {
19246:             rv = contextStack->Pop(nsnull);
19246:           }
19246:         }
19246:         return NS_SUCCEEDED(rv) ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
19246:       }
19246: 
19246:     case NPPVpluginKeepLibraryInMemory: {
19246:       NPBool bCached = (result != nsnull);
19246:       return inst->SetCached(bCached);
19246:     }
19246: 
19246:     case NPPVpluginWantsAllNetworkStreams: {
19246:       PRBool bWantsAllNetworkStreams = (result != nsnull);
19246:       return inst->SetWantsAllNetworkStreams(bWantsAllNetworkStreams);
19246:     }
19246: 
19246: #ifdef XP_MACOSX
19246:     case NPPVpluginDrawingModel: {
19246:       if (inst) {
31406:         inst->SetDrawingModel((NPDrawingModel)NS_PTR_TO_INT32(result));
19246:         return NPERR_NO_ERROR;
19246:       }
19246:       else {
19246:         return NPERR_GENERIC_ERROR;
19246:       }
19246:     }
32019: 
32019:     case NPPVpluginEventModel: {
32019:       if (inst) {
32019:         inst->SetEventModel((NPEventModel)NS_PTR_TO_INT32(result));
32019:         return NPERR_NO_ERROR;
32019:       }
32019:       else {
32019:         return NPERR_GENERIC_ERROR;
32019:       }
32019:     }
19246: #endif
19246: 
19246:     default:
26261:       return NPERR_GENERIC_ERROR;
19246:   }
19246: }
19246: 
19246: NPError NP_CALLBACK
19246: _requestread(NPStream *pstream, NPByteRange *rangeList)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_requestread called from the wrong thread\n"));
19246:     return NPERR_INVALID_PARAM;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_RequestRead: stream=%p\n",
19246:                                      (void*)pstream));
19246: 
19246: #ifdef PLUGIN_LOGGING
19246:   for(NPByteRange * range = rangeList; range != nsnull; range = range->next)
19246:     PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY,
19246:     ("%i-%i", range->offset, range->offset + range->length - 1));
19246: 
19246:   PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY, ("\n\n"));
19246:   PR_LogFlush();
19246: #endif
19246: 
19246:   if (!pstream || !rangeList || !pstream->ndata)
19246:     return NPERR_INVALID_PARAM;
19246: 
19246:   nsNPAPIPluginStreamListener* streamlistener = (nsNPAPIPluginStreamListener*)pstream->ndata;
19246: 
32799:   PRInt32 streamtype = NP_NORMAL;
19246: 
19246:   streamlistener->GetStreamType(&streamtype);
19246: 
32799:   if (streamtype != NP_SEEK)
19246:     return NPERR_STREAM_NOT_SEEKABLE;
19246: 
19246:   if (streamlistener->mStreamInfo)
32799:     streamlistener->mStreamInfo->RequestRead((NPByteRange *)rangeList);
19246: 
19246:   return NS_OK;
19246: }
19246: 
19246: // Deprecated, only stubbed out
19246: void* NP_CALLBACK /* OJI type: JRIEnv* */
37780: _getJavaEnv()
19246: {
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaEnv\n"));
19246:   return NULL;
19246: }
19246: 
19246: const char * NP_CALLBACK
19246: _useragent(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_useragent called from the wrong thread\n"));
19246:     return nsnull;
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_UserAgent: npp=%p\n", (void*)npp));
19246: 
29574:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
29574:   if (!pluginHost)
19246:     return nsnull;
19246: 
19246:   const char *retstr;
29574:   nsresult rv = pluginHost->UserAgent(&retstr);
19246:   if (NS_FAILED(rv))
19246:     return nsnull;
19246: 
19246:   return retstr;
19246: }
19246: 
19246: void * NP_CALLBACK
19246: _memalloc (uint32_t size)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN_memalloc called from the wrong thread\n"));
19246:   }
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemAlloc: size=%d\n", size));
19246:   return nsMemory::Alloc(size);
19246: }
19246: 
19246: // Deprecated, only stubbed out
19246: void* NP_CALLBACK /* OJI type: jref */
19246: _getJavaPeer(NPP npp)
19246: {
19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaPeer: npp=%p\n", (void*)npp));
19246:   return NULL;
19246: }
19246: 
19246: void NP_CALLBACK
19246: _pushpopupsenabledstate(NPP npp, NPBool enabled)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_pushpopupsenabledstate called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
19246:   if (!inst)
19246:     return;
19246: 
19246:   inst->PushPopupsEnabledState(enabled);
19246: }
19246: 
19246: void NP_CALLBACK
19246: _poppopupsenabledstate(NPP npp)
19246: {
19246:   if (!NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_poppopupsenabledstate called from the wrong thread\n"));
19246:     return;
19246:   }
19246:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
19246:   if (!inst)
19246:     return;
19246: 
19246:   inst->PopPopupsEnabledState();
19246: }
19246: 
19246: void NP_CALLBACK
19246: _pluginthreadasynccall(NPP instance, PluginThreadCallback func, void *userData)
19246: {
19246:   if (NS_IsMainThread()) {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from the main thread\n"));
19246:   } else {
19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from a non main thread\n"));
19246:   }
19246:   nsRefPtr<nsPluginThreadRunnable> evt =
19246:     new nsPluginThreadRunnable(instance, func, userData);
19246: 
19246:   if (evt && evt->IsValid()) {
19246:     NS_DispatchToMainThread(evt);
19246:   }
19246: }
19246: 
23571: NPError NP_CALLBACK
23571: _getvalueforurl(NPP instance, NPNURLVariable variable, const char *url,
23571:                 char **value, uint32_t *len)
23571: {
23571:   if (!instance) {
23571:     return NPERR_INVALID_PARAM;
23571:   }
23571: 
23571:   if (!url || !*url || !len) {
23571:     return NPERR_INVALID_URL;
23571:   }
23571: 
23571:   *len = 0;
23571: 
23571:   switch (variable) {
23571:   case NPNURLVProxy:
23571:     {
29574:       nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
29574: 
29574:       if (pluginHost && NS_SUCCEEDED(pluginHost->FindProxyForURL(url, value))) {
23571:         *len = *value ? PL_strlen(*value) : 0;
23571:         return NPERR_NO_ERROR;
23571:       }
23571:       break;
23571:     }
23571:   case NPNURLVCookie:
23571:     {
23571:       nsCOMPtr<nsICookieService> cookieService =
23571:         do_GetService(NS_COOKIESERVICE_CONTRACTID);
23571: 
23571:       if (!cookieService)
23571:         return NPERR_GENERIC_ERROR;
23571: 
23571:       // Make an nsURI from the url argument
23571:       nsCOMPtr<nsIURI> uri;
23571:       if (NS_FAILED(NS_NewURI(getter_AddRefs(uri), nsDependentCString(url)))) {
23571:         return NPERR_GENERIC_ERROR;
23571:       }
23571: 
23571:       nsXPIDLCString cookieStr;
35232:       nsresult cookieReturn = cookieService->GetCookieString(uri, nsnull,
35232:                                                              getter_Copies(cookieStr));
35232:       if (NS_FAILED(cookieReturn) || !cookieStr) {
23571:         return NPERR_GENERIC_ERROR;
23571:       }
23571: 
23571:       *value = PL_strndup(cookieStr, cookieStr.Length());
23571: 
23571:       if (*value) {
23571:         *len = cookieStr.Length();
23571: 
23571:         return NPERR_NO_ERROR;
23571:       }
23571:     }
23571: 
23571:     break;
23571:   default:
23571:     // Fall through and return an error...
23571:     ;
23571:   }
23571: 
23571:   return NPERR_GENERIC_ERROR;
23571: }
23571: 
23571: NPError NP_CALLBACK
23571: _setvalueforurl(NPP instance, NPNURLVariable variable, const char *url,
23571:                 const char *value, uint32_t len)
23571: {
23571:   if (!instance) {
23571:     return NPERR_INVALID_PARAM;
23571:   }
23571: 
23571:   if (!url || !*url) {
23571:     return NPERR_INVALID_URL;
23571:   }
23571: 
23571:   switch (variable) {
23571:   case NPNURLVCookie:
23571:     {
29204:       if (!url || !value || (0 >= len))
29204:         return NPERR_INVALID_PARAM;
29204: 
29204:       nsresult rv = NS_ERROR_FAILURE;
29204:       nsCOMPtr<nsIIOService> ioService(do_GetService(NS_IOSERVICE_CONTRACTID, &rv));
29204:       if (NS_FAILED(rv))
29204:         return NPERR_GENERIC_ERROR;
29204: 
29204:       nsCOMPtr<nsICookieService> cookieService = do_GetService(NS_COOKIESERVICE_CONTRACTID, &rv);
29204:       if (NS_FAILED(rv))
29204:         return NPERR_GENERIC_ERROR;
29204: 
29204:       nsCOMPtr<nsIURI> uriIn;
29204:       rv = ioService->NewURI(nsDependentCString(url), nsnull, nsnull, getter_AddRefs(uriIn));
29204:       if (NS_FAILED(rv))
29204:         return NPERR_GENERIC_ERROR;
29204: 
29204:       nsCOMPtr<nsIPrompt> prompt;
29956:       nsPluginHost::GetPrompt(nsnull, getter_AddRefs(prompt));
29204: 
29204:       char *cookie = (char*)value;
29204:       char c = cookie[len];
29204:       cookie[len] = '\0';
29204:       rv = cookieService->SetCookieString(uriIn, prompt, cookie, nsnull);
29204:       cookie[len] = c;
29204:       if (NS_SUCCEEDED(rv))
23571:         return NPERR_NO_ERROR;
23571:     }
23571: 
23571:     break;
23571:   case NPNURLVProxy:
23571:     // We don't support setting proxy values, fall through...
23571:   default:
23571:     // Fall through and return an error...
23571:     ;
23571:   }
23571: 
23571:   return NPERR_GENERIC_ERROR;
23571: }
23571: 
23571: NPError NP_CALLBACK
23571: _getauthenticationinfo(NPP instance, const char *protocol, const char *host,
23571:                        int32_t port, const char *scheme, const char *realm,
23571:                        char **username, uint32_t *ulen, char **password,
23571:                        uint32_t *plen)
23571: {
23571:   if (!instance || !protocol || !host || !scheme || !realm || !username ||
23571:       !ulen || !password || !plen)
23571:     return NPERR_INVALID_PARAM;
23571: 
23571:   *username = nsnull;
23571:   *password = nsnull;
23571:   *ulen = 0;
23571:   *plen = 0;
23571: 
23571:   nsDependentCString proto(protocol);
23571: 
23571:   if (!proto.LowerCaseEqualsLiteral("http") &&
23571:       !proto.LowerCaseEqualsLiteral("https"))
23571:     return NPERR_GENERIC_ERROR;
23571: 
23571:   nsCOMPtr<nsIHttpAuthManager> authManager =
23571:     do_GetService("@mozilla.org/network/http-auth-manager;1");
23571:   if (!authManager)
23571:     return NPERR_GENERIC_ERROR;
23571: 
23571:   nsAutoString unused, uname16, pwd16;
23571:   if (NS_FAILED(authManager->GetAuthIdentity(proto, nsDependentCString(host),
23571:                                              port, nsDependentCString(scheme),
23571:                                              nsDependentCString(realm),
23571:                                              EmptyCString(), unused, uname16,
23571:                                              pwd16))) {
23571:     return NPERR_GENERIC_ERROR;
23571:   }
23571: 
23571:   NS_ConvertUTF16toUTF8 uname8(uname16);
23571:   NS_ConvertUTF16toUTF8 pwd8(pwd16);
23571: 
23571:   *username = ToNewCString(uname8);
23571:   *ulen = *username ? uname8.Length() : 0;
23571: 
23571:   *password = ToNewCString(pwd8);
23571:   *plen = *password ? pwd8.Length() : 0;
23571: 
23571:   return NPERR_NO_ERROR;
23571: }
23571: 
29937: uint32_t NP_CALLBACK
36125: _scheduletimer(NPP instance, uint32_t interval, NPBool repeat, PluginTimerFunc timerFunc)
29937: {
29937:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
29937:   if (!inst)
29937:     return 0;
29937: 
29937:   return inst->ScheduleTimer(interval, repeat, timerFunc);
29937: }
29937: 
29937: void NP_CALLBACK
29937: _unscheduletimer(NPP instance, uint32_t timerID)
29937: {
29937:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
29937:   if (!inst)
29937:     return;
29937: 
29937:   inst->UnscheduleTimer(timerID);
29937: }
29937: 
32019: NPError NP_CALLBACK
32019: _popupcontextmenu(NPP instance, NPMenu* menu)
32019: {
32019:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
32019:   if (!inst)
32019:     return NPERR_GENERIC_ERROR;
32019: 
32019:   return inst->PopUpContextMenu(menu);
32019: }
32019: 
32019: NPBool NP_CALLBACK
32019: _convertpoint(NPP instance, double sourceX, double sourceY, NPCoordinateSpace sourceSpace, double *destX, double *destY, NPCoordinateSpace destSpace)
32019: {
32019:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
32019:   if (!inst)
32019:     return PR_FALSE;
32019: 
32019:   return inst->ConvertPoint(sourceX, sourceY, sourceSpace, destX, destY, destSpace);
32019: }
32019: 
36125: } /* namespace parent */
36125: } /* namespace plugins */
36125: } /* namespace mozilla */
