    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Josh Aas <josh@mozilla.com>
37530:  *   Thomas K. Dyas <tom.dyas@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
36741: #include <objc/objc-runtime.h>
36741: 
    1: #include "nsMenuBarX.h"
    1: #include "nsMenuX.h"
15578: #include "nsMenuItemX.h"
15578: #include "nsMenuUtilsX.h"
13608: #include "nsCocoaUtils.h"
13608: #include "nsCocoaWindow.h"
37545: #include "nsToolkit.h"
50708: #include "nsChildView.h"
    1: 
15578: #include "nsCOMPtr.h"
15578: #include "nsString.h"
80435: #include "nsGkAtoms.h"
15578: #include "nsGUIEvent.h"
15578: #include "nsObjCExceptions.h"
15578: #include "nsHashtable.h"
15578: #include "nsThreadUtils.h"
15578: 
15578: #include "nsIContent.h"
15561: #include "nsIWidget.h"
15561: #include "nsIDocument.h"
15578: #include "nsIDOMDocument.h"
15578: #include "nsIDOMElement.h"
15561: 
    1: NativeMenuItemTarget* nsMenuBarX::sNativeEventTarget = nil;
13928: nsMenuBarX* nsMenuBarX::sLastGeckoMenuBarPainted = nsnull;
    1: NSMenu* sApplicationMenu = nil;
    1: BOOL gSomeMenuBarPainted = NO;
    1: 
    1: // We keep references to the first quit and pref item content nodes we find, which
    1: // will be from the hidden window. We use these when the document for the current
    1: // window does not have a quit or pref item. We don't need strong refs here because
    1: // these items are always strong ref'd by their owning menu bar (instance variable).
  164: static nsIContent* sAboutItemContent  = nsnull;
53746: static nsIContent* sUpdateItemContent = nsnull;
  164: static nsIContent* sPrefItemContent   = nsnull;
    1: static nsIContent* sQuitItemContent   = nsnull;
    1: 
15578: NS_IMPL_ISUPPORTS1(nsNativeMenuServiceX, nsINativeMenuService)
15578: 
15578: NS_IMETHODIMP nsNativeMenuServiceX::CreateNativeMenuBar(nsIWidget* aParent, nsIContent* aMenuBarNode)
    1: {
15578:   NS_ASSERTION(NS_IsMainThread(), "Attempting to create native menu bar on wrong thread!");
15578: 
15578:   nsRefPtr<nsMenuBarX> mb = new nsMenuBarX();
15578:   if (!mb)
15578:     return NS_ERROR_OUT_OF_MEMORY;
15578: 
15578:   return mb->Create(aParent, aMenuBarNode);
    1: }
    1: 
    1: nsMenuBarX::nsMenuBarX()
37530: : nsMenuGroupOwnerX(), mParentWindow(nsnull)
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11881: 
16264:   mNativeMenu = [[GeckoNSMenu alloc] initWithTitle:@"MainMenuBar"];
    1: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: nsMenuBarX::~nsMenuBarX()
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11881: 
14477:   if (nsMenuBarX::sLastGeckoMenuBarPainted == this)
14477:     nsMenuBarX::sLastGeckoMenuBarPainted = nsnull;
14477: 
    1:   // the quit/pref items of a random window might have been used if there was no
    1:   // hidden window, thus we need to invalidate the weak references.
  164:   if (sAboutItemContent == mAboutItemContent)
  164:     sAboutItemContent = nsnull;
53746:   if (sUpdateItemContent == mUpdateItemContent)
53746:     sUpdateItemContent = nsnull;
    1:   if (sQuitItemContent == mQuitItemContent)
    1:     sQuitItemContent = nsnull;
    1:   if (sPrefItemContent == mPrefItemContent)
    1:     sPrefItemContent = nsnull;
    1: 
37617:   // make sure we unregister ourselves as a content observer
37617:   UnregisterForContentChanges(mContent);
    1: 
15578:   // We have to manually clear the array here because clearing causes menu items
15578:   // to call back into the menu bar to unregister themselves. We don't want to
15578:   // depend on member variable ordering to ensure that the array gets cleared
15578:   // before the registration hash table is destroyed.
15578:   mMenuArray.Clear();
15578: 
16264:   [mNativeMenu release];
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
15578: nsresult nsMenuBarX::Create(nsIWidget* aParent, nsIContent* aContent)
    1: {
15578:   if (!aParent || !aContent)
15578:     return NS_ERROR_INVALID_ARG;
15578: 
16264:   mParentWindow = aParent;
15578:   mContent = aContent;
15578: 
15578:   AquifyMenuBar();
15578: 
37530:   nsresult rv = nsMenuGroupOwnerX::Create(aContent);
37530:   if (NS_FAILED(rv))
37530:     return rv;
15578: 
37617:   RegisterForContentChanges(aContent, this);
37617: 
16264:   ConstructNativeMenus();
16264: 
16264:   // Give this to the parent window. The parent takes ownership.
27089:   static_cast<nsCocoaWindow*>(mParentWindow)->SetMenuBar(this);
27089: 
27089:   return NS_OK;
16264: }
16264: 
16264: void nsMenuBarX::ConstructNativeMenus()
16264: {
15578:   PRUint32 count = mContent->GetChildCount();
15578:   for (PRUint32 i = 0; i < count; i++) { 
15578:     nsIContent *menuContent = mContent->GetChildAt(i);
16264:     if (menuContent &&
80435:         menuContent->Tag() == nsGkAtoms::menu &&
33329:         menuContent->IsXUL()) {
15578:       nsMenuX* newMenu = new nsMenuX();
15578:       if (newMenu) {
16264:         nsresult rv = newMenu->Create(this, this, menuContent);
15578:         if (NS_SUCCEEDED(rv))
16264:           InsertMenuAtIndex(newMenu, GetMenuCount());
15578:         else
15578:           delete newMenu;
15578:       }
15578:     }
15578:   }  
15578: }
15578: 
15578: PRUint32 nsMenuBarX::GetMenuCount()
15578: {
15578:   return mMenuArray.Length();
15578: }
15578: 
16264: bool nsMenuBarX::MenuContainsAppMenu()
16264: {
16264:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
16264: 
16264:   return ([mNativeMenu numberOfItems] > 0 &&
16264:           [[mNativeMenu itemAtIndex:0] submenu] == sApplicationMenu);
16264: 
16264:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(false);
16264: }
16264: 
16264: nsresult nsMenuBarX::InsertMenuAtIndex(nsMenuX* aMenu, PRUint32 aIndex)
15578: {
15578:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
15578: 
15578:   // If we haven't created a global Application menu yet, do it.
15578:   if (!sApplicationMenu) {
15578:     nsresult rv = NS_OK; // avoid warning about rv being unused
15578:     rv = CreateApplicationMenu(aMenu);
15578:     NS_ASSERTION(NS_SUCCEEDED(rv), "Can't create Application menu");
15578: 
15578:     // Hook the new Application menu up to the menu bar.
15578:     NSMenu* mainMenu = [NSApp mainMenu];
15578:     NS_ASSERTION([mainMenu numberOfItems] > 0, "Main menu does not have any items, something is terribly wrong!");
15578:     [[mainMenu itemAtIndex:0] setSubmenu:sApplicationMenu];
15578:   }
15578: 
16264:   // add menu to array that owns our menus
16264:   mMenuArray.InsertElementAt(aIndex, aMenu);
15578: 
16264:   // hook up submenus
15578:   nsIContent* menuContent = aMenu->Content();
15578:   if (menuContent->GetChildCount() > 0 &&
15578:       !nsMenuUtilsX::NodeIsHiddenOrCollapsed(menuContent)) {
24131:     int insertionIndex = nsMenuUtilsX::CalculateNativeInsertionPoint(this, aMenu);
16264:     if (MenuContainsAppMenu())
24131:       insertionIndex++;
24131:     [mNativeMenu insertItem:aMenu->NativeMenuItem() atIndex:insertionIndex];
15578:   }
15578: 
15578:   return NS_OK;
15578: 
15578:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
15578: }
15578: 
16264: void nsMenuBarX::RemoveMenuAtIndex(PRUint32 aIndex)
15578: {
15578:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
15578: 
15578:   NS_ASSERTION(aIndex < mMenuArray.Length(), "Attempting submenu removal with bad index!");
15578: 
15578:   // Our native menu and our internal menu object array might be out of sync.
15578:   // This happens, for example, when a submenu is hidden. Because of this we
15578:   // should not assume that a native submenu is hooked up.
16264:   NSMenuItem* nativeMenuItem = mMenuArray[aIndex]->NativeMenuItem();
16264:   int nativeMenuItemIndex = [mNativeMenu indexOfItem:nativeMenuItem];
16264:   if (nativeMenuItemIndex != -1)
16264:     [mNativeMenu removeItemAtIndex:nativeMenuItemIndex];
16264: 
15578:   mMenuArray.RemoveElementAt(aIndex);
15578: 
15578:   NS_OBJC_END_TRY_ABORT_BLOCK;
15578: }
15578: 
37617: void nsMenuBarX::ObserveAttributeChanged(nsIDocument* aDocument,
37617:                                          nsIContent* aContent,
37617:                                          nsIAtom* aAttribute)
37617: {
37617: }
37617: 
37617: void nsMenuBarX::ObserveContentRemoved(nsIDocument* aDocument,
37617:                                        nsIContent* aChild, 
37617:                                        PRInt32 aIndexInContainer)
37617: {
37617:   RemoveMenuAtIndex(aIndexInContainer);
37617: }
37617: 
37617: void nsMenuBarX::ObserveContentInserted(nsIDocument* aDocument,
71208:                                         nsIContent* aContainer,
71208:                                         nsIContent* aChild)
37617: {
37617:   nsMenuX* newMenu = new nsMenuX();
37617:   if (newMenu) {
37617:     nsresult rv = newMenu->Create(this, this, aChild);
37617:     if (NS_SUCCEEDED(rv))
71208:       InsertMenuAtIndex(newMenu, aContainer->IndexOf(aChild));
37617:     else
37617:       delete newMenu;
37617:   }
37617: }
37617: 
21081: void nsMenuBarX::ForceUpdateNativeMenuAt(const nsAString& indexString)
21081: {
21081:   NSString* locationString = [NSString stringWithCharacters:indexString.BeginReading() length:indexString.Length()];
21081:   NSArray* indexes = [locationString componentsSeparatedByString:@"|"];
21081:   unsigned int indexCount = [indexes count];
21081:   if (indexCount == 0)
21081:     return;
21081: 
21081:   nsMenuX* currentMenu = NULL;
21081:   int targetIndex = [[indexes objectAtIndex:0] intValue];
21081:   int visible = 0;
21081:   PRUint32 length = mMenuArray.Length();
21081:   // first find a menu in the menu bar
21081:   for (unsigned int i = 0; i < length; i++) {
21081:     nsMenuX* menu = mMenuArray[i];
21081:     if (!nsMenuUtilsX::NodeIsHiddenOrCollapsed(menu->Content())) {
21081:       visible++;
21081:       if (visible == (targetIndex + 1)) {
21081:         currentMenu = menu;
21081:         break;
21081:       }
21081:     }
21081:   }
21081: 
21081:   if (!currentMenu)
21081:     return;
21081: 
21081:   // fake open/close to cause lazy update to happen so submenus populate
31539:   currentMenu->MenuOpened();
31539:   currentMenu->MenuClosed();
21081: 
21081:   // now find the correct submenu
21081:   for (unsigned int i = 1; currentMenu && i < indexCount; i++) {
21081:     targetIndex = [[indexes objectAtIndex:i] intValue];
21081:     visible = 0;
21081:     length = currentMenu->GetItemCount();
21081:     for (unsigned int j = 0; j < length; j++) {
21081:       nsMenuObjectX* targetMenu = currentMenu->GetItemAt(j);
21081:       if (!targetMenu)
21081:         return;
21081:       if (!nsMenuUtilsX::NodeIsHiddenOrCollapsed(targetMenu->Content())) {
21081:         visible++;
21081:         if (targetMenu->MenuObjectType() == eSubmenuObjectType && visible == (targetIndex + 1)) {
21081:           currentMenu = static_cast<nsMenuX*>(targetMenu);
21081:           // fake open/close to cause lazy update to happen
31539:           currentMenu->MenuOpened();
31539:           currentMenu->MenuClosed();
21081:           break;
21081:         }
21081:       }
21081:     }
21081:   }
21081: }
21081: 
16264: // Calling this forces a full reload of the menu system, reloading all native
16264: // menus and their items.
16264: // Without this testing is hard because changes to the DOM affect the native
16264: // menu system lazily.
16264: void nsMenuBarX::ForceNativeMenuReload()
16264: {
16264:   // tear down everything
16264:   while (GetMenuCount() > 0)
16264:     RemoveMenuAtIndex(0);
16264: 
16264:   // construct everything
16264:   ConstructNativeMenus();
16264: }
16264: 
15578: nsMenuX* nsMenuBarX::GetMenuAt(PRUint32 aIndex)
15578: {
15578:   if (mMenuArray.Length() <= aIndex) {
15578:     NS_ERROR("Requesting menu at invalid index!");
15578:     return NULL;
15578:   }
15578:   return mMenuArray[aIndex];
15578: }
15578: 
37545: nsMenuX* nsMenuBarX::GetXULHelpMenu()
37545: {
37545:   // The Help menu is usually (always?) the last one, so we start there and
37545:   // count back.
37545:   for (PRInt32 i = GetMenuCount() - 1; i >= 0; --i) {
37545:     nsMenuX* aMenu = GetMenuAt(i);
37545:     if (aMenu && nsMenuX::IsXULHelpMenu(aMenu->Content()))
37545:       return aMenu;
37545:   }
37545:   return nil;
37545: }
37545: 
37545: // On SnowLeopard and later we must tell the OS which is our Help menu.
37545: // Otherwise it will only add Spotlight for Help (the Search item) to our
37545: // Help menu if its label/title is "Help" -- i.e. if the menu is in English.
37545: // This resolves bugs 489196 and 539317.
37545: void nsMenuBarX::SetSystemHelpMenu()
37545: {
37545:   if (!nsToolkit::OnSnowLeopardOrLater())
37545:     return;
37545:   nsMenuX* xulHelpMenu = GetXULHelpMenu();
37545:   if (xulHelpMenu) {
37545:     NSMenu* helpMenu = (NSMenu*)xulHelpMenu->NativeData();
37545:     if (helpMenu)
37545:       [NSApp setHelpMenu:helpMenu];
37545:   }
37545: }
37545: 
15578: nsresult nsMenuBarX::Paint()
15578: {
15578:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
15578: 
16264:   // Don't try to optimize anything in this painting by checking
16264:   // sLastGeckoMenuBarPainted because the menubar can be manipulated by
16264:   // native dialogs and sheet code and other things besides this paint method.
15578: 
16264:   // We have to keep the same menu item for the Application menu so we keep
16264:   // passing it along.
16264:   NSMenu* outgoingMenu = [NSApp mainMenu];
16264:   NS_ASSERTION([outgoingMenu numberOfItems] > 0, "Main menu does not have any items, something is terribly wrong!");
16264: 
16264:   NSMenuItem* appMenuItem = [[outgoingMenu itemAtIndex:0] retain];
16264:   [outgoingMenu removeItemAtIndex:0];
16264:   [mNativeMenu insertItem:appMenuItem atIndex:0];
16264:   [appMenuItem release];
15578: 
15578:   // Set menu bar and event target.
16264:   [NSApp setMainMenu:mNativeMenu];
37545:   SetSystemHelpMenu();
15578:   nsMenuBarX::sLastGeckoMenuBarPainted = this;
15578: 
15578:   gSomeMenuBarPainted = YES;
15578: 
15578:   return NS_OK;
15578: 
15578:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
15578: }
15578: 
32925: // Returns the 'key' attribute of the 'shortcutID' object (if any) in the
32925: // currently active menubar's DOM document.  'shortcutID' should be the id
32925: // (i.e. the name) of a component that defines a commonly used (and
32925: // localized) cmd+key shortcut, and belongs to a keyset containing similar
32925: // objects.  For example "key_selectAll".  Returns a value that can be
32925: // compared to the first character of [NSEvent charactersIgnoringModifiers]
32925: // when [NSEvent modifierFlags] == NSCommandKeyMask.
33318: char nsMenuBarX::GetLocalizedAccelKey(const char *shortcutID)
32925: {
32925:   if (!sLastGeckoMenuBarPainted)
32925:     return 0;
32925: 
32925:   nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(sLastGeckoMenuBarPainted->mDocument));
32925:   if (!domDoc)
32925:     return 0;
32925: 
32925:   NS_ConvertASCIItoUTF16 shortcutIDStr((const char *)shortcutID);
32925:   nsCOMPtr<nsIDOMElement> shortcutElement;
32925:   domDoc->GetElementById(shortcutIDStr, getter_AddRefs(shortcutElement));
32925:   nsCOMPtr<nsIContent> shortcutContent = do_QueryInterface(shortcutElement);
32925:   if (!shortcutContent)
32925:     return 0;
32925: 
32925:   nsAutoString key;
80435:   shortcutContent->GetAttr(kNameSpaceID_None, nsGkAtoms::key, key);
32925:   NS_LossyConvertUTF16toASCII keyASC(key.get());
32925:   const char *keyASCPtr = keyASC.get();
32925:   if (!keyASCPtr)
32925:     return 0;
32925:   // If keyID's 'key' attribute isn't exactly one character long, it's not
32925:   // what we're looking for.
32925:   if (strlen(keyASCPtr) != sizeof(char))
32925:     return 0;
32925:   // Make sure retval is lower case.
32925:   char retval = tolower(keyASCPtr[0]);
32925: 
32925:   return retval;
32925: }
32925: 
15578: // Hide the item in the menu by setting the 'hidden' attribute. Returns it in |outHiddenNode| so
15578: // the caller can hang onto it if they so choose. It is acceptable to pass nsull
15578: // for |outHiddenNode| if the caller doesn't care about the hidden node.
15578: void nsMenuBarX::HideItem(nsIDOMDocument* inDoc, const nsAString & inID, nsIContent** outHiddenNode)
15578: {
15578:   nsCOMPtr<nsIDOMElement> menuItem;
15578:   inDoc->GetElementById(inID, getter_AddRefs(menuItem));  
15578:   nsCOMPtr<nsIContent> menuContent(do_QueryInterface(menuItem));
15578:   if (menuContent) {
80435:     menuContent->SetAttr(kNameSpaceID_None, nsGkAtoms::hidden, NS_LITERAL_STRING("true"), false);
15578:     if (outHiddenNode) {
15578:       *outHiddenNode = menuContent.get();
15578:       NS_IF_ADDREF(*outHiddenNode);
15578:     }
15578:   }
15578: }
15578: 
15578: // Do what is necessary to conform to the Aqua guidelines for menus.
15578: void nsMenuBarX::AquifyMenuBar()
15578: {
15578:   nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(mContent->GetDocument()));
    1:   if (domDoc) {
  184:     // remove the "About..." item and its separator
  184:     HideItem(domDoc, NS_LITERAL_STRING("aboutSeparator"), nsnull);
  164:     HideItem(domDoc, NS_LITERAL_STRING("aboutName"), getter_AddRefs(mAboutItemContent));
  164:     if (!sAboutItemContent)
  164:       sAboutItemContent = mAboutItemContent;
  164: 
53746:     // Hide the software update menu item, since it belongs in the application
53746:     // menu on Mac OS X.
53746:     HideItem(domDoc, NS_LITERAL_STRING("updateSeparator"), nsnull);
53746:     HideItem(domDoc, NS_LITERAL_STRING("checkForUpdates"), getter_AddRefs(mUpdateItemContent));
53746:     if (!sUpdateItemContent)
53746:       sUpdateItemContent = mUpdateItemContent;
53746: 
    1:     // remove quit item and its separator
    1:     HideItem(domDoc, NS_LITERAL_STRING("menu_FileQuitSeparator"), nsnull);
    1:     HideItem(domDoc, NS_LITERAL_STRING("menu_FileQuitItem"), getter_AddRefs(mQuitItemContent));
    1:     if (!sQuitItemContent)
    1:       sQuitItemContent = mQuitItemContent;
    1:     
    1:     // remove prefs item and its separator, but save off the pref content node
    1:     // so we can invoke its command later.
    1:     HideItem(domDoc, NS_LITERAL_STRING("menu_PrefsSeparator"), nsnull);
    1:     HideItem(domDoc, NS_LITERAL_STRING("menu_preferences"), getter_AddRefs(mPrefItemContent));
    1:     if (!sPrefItemContent)
    1:       sPrefItemContent = mPrefItemContent;
    1: 
    1:     // hide items that we use for the Application menu
    1:     HideItem(domDoc, NS_LITERAL_STRING("menu_mac_services"), nsnull);
    1:     HideItem(domDoc, NS_LITERAL_STRING("menu_mac_hide_app"), nsnull);
    1:     HideItem(domDoc, NS_LITERAL_STRING("menu_mac_hide_others"), nsnull);
    1:     HideItem(domDoc, NS_LITERAL_STRING("menu_mac_show_all"), nsnull);
    1:   }
 5479: }
    1: 
    1: // for creating menu items destined for the Application menu
15578: NSMenuItem* nsMenuBarX::CreateNativeAppMenuItem(nsMenuX* inMenu, const nsAString& nodeID, SEL action,
    1:                                                 int tag, NativeMenuItemTarget* target)
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
11881: 
15578:   nsCOMPtr<nsIDocument> doc = inMenu->Content()->GetDocument();
    1:   if (!doc)
    1:     return nil;
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domdoc(do_QueryInterface(doc));
    1:   if (!domdoc)
    1:     return nil;
    1: 
    1:   // Get information from the gecko menu item
    1:   nsAutoString label;
    1:   nsAutoString modifiers;
    1:   nsAutoString key;
    1:   nsCOMPtr<nsIDOMElement> menuItem;
    1:   domdoc->GetElementById(nodeID, getter_AddRefs(menuItem));
    1:   if (menuItem) {
    1:     menuItem->GetAttribute(NS_LITERAL_STRING("label"), label);
    1:     menuItem->GetAttribute(NS_LITERAL_STRING("modifiers"), modifiers);
    1:     menuItem->GetAttribute(NS_LITERAL_STRING("key"), key);
    1:   }
    1:   else {
    1:     return nil;
    1:   }
    1: 
    1:   // Get more information about the key equivalent. Start by
    1:   // finding the key node we need.
    1:   NSString* keyEquiv = nil;
    1:   unsigned int macKeyModifiers = 0;
    1:   if (!key.IsEmpty()) {
    1:     nsCOMPtr<nsIDOMElement> keyElement;
    1:     domdoc->GetElementById(key, getter_AddRefs(keyElement));
    1:     if (keyElement) {
    1:       nsCOMPtr<nsIContent> keyContent (do_QueryInterface(keyElement));
    1:       // first grab the key equivalent character
    1:       nsAutoString keyChar(NS_LITERAL_STRING(" "));
80435:       keyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::key, keyChar);
    1:       if (!keyChar.EqualsLiteral(" ")) {
    1:         keyEquiv = [[NSString stringWithCharacters:keyChar.get() length:keyChar.Length()] lowercaseString];
    1:       }
    1:       // now grab the key equivalent modifiers
    1:       nsAutoString modifiersStr;
80435:       keyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::modifiers, modifiersStr);
15578:       PRUint8 geckoModifiers = nsMenuUtilsX::GeckoModifiersForNodeAttribute(modifiersStr);
15578:       macKeyModifiers = nsMenuUtilsX::MacModifiersForGeckoModifiers(geckoModifiers);
    1:     }
    1:   }
    1:   // get the label into NSString-form
    1:   NSString* labelString = [NSString stringWithCharacters:label.get() length:label.Length()];
    1:   
    1:   if (!labelString)
    1:     labelString = @"";
    1:   if (!keyEquiv)
    1:     keyEquiv = @"";
    1: 
    1:   // put together the actual NSMenuItem
    1:   NSMenuItem* newMenuItem = [[NSMenuItem alloc] initWithTitle:labelString action:action keyEquivalent:keyEquiv];
    1:   
    1:   [newMenuItem setTag:tag];
    1:   [newMenuItem setTarget:target];
    1:   [newMenuItem setKeyEquivalentModifierMask:macKeyModifiers];
    1: 
37530:   MenuItemInfo * info = [[MenuItemInfo alloc] initWithMenuGroupOwner:this];
37530:   [newMenuItem setRepresentedObject:info];
37530:   [info release];
37530:   
    1:   return newMenuItem;
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
    1: }
    1: 
 5479: // build the Application menu shared by all menu bars
15578: nsresult nsMenuBarX::CreateApplicationMenu(nsMenuX* inMenu)
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11881: 
    1:   // At this point, the application menu is the application menu from
    1:   // the nib in cocoa widgets. We do not have a way to create an application
    1:   // menu manually, so we grab the one from the nib and use that.
    1:   sApplicationMenu = [[[[NSApp mainMenu] itemAtIndex:0] submenu] retain];
    1:   
    1: /*
    1:   We support the following menu items here:
    1: 
    1:   Menu Item                DOM Node ID             Notes
    1:   
53746:   ========================
    1:   = About This App       = <- aboutName
53746:   = Check for Updates... = <- checkForUpdates
53746:   ========================
    1:   = Preferences...       = <- menu_preferences
53746:   ========================
    1:   = Services     >       = <- menu_mac_services    <- (do not define key equivalent)
53746:   ======================== 
    1:   = Hide App             = <- menu_mac_hide_app
    1:   = Hide Others          = <- menu_mac_hide_others
    1:   = Show All             = <- menu_mac_show_all
53746:   ======================== 
    1:   = Quit                 = <- menu_FileQuitItem
53746:   ======================== 
    1:   
    1:   If any of them are ommitted from the application's DOM, we just don't add
    1:   them. We always add a "Quit" item, but if an app developer does not provide a
    1:   DOM node with the right ID for the Quit item, we add it in English. App
    1:   developers need only add each node with a label and a key equivalent (if they
    1:   want one). Other attributes are optional. Like so:
    1:   
    1:   <menuitem id="menu_preferences"
    1:          label="&preferencesCmdMac.label;"
    1:            key="open_prefs_key"/>
    1:   
    1:   We need to use this system for localization purposes, until we have a better way
    1:   to define the Application menu to be used on Mac OS X.
    1: */
    1: 
    1:   if (sApplicationMenu) {
    1:     // This code reads attributes we are going to care about from the DOM elements
    1: 
    1:     NSMenuItem *itemBeingAdded = nil;
53746:     BOOL addAboutSeparator = FALSE;
    1: 
    1:     // Add the About menu item
    1:     itemBeingAdded = CreateNativeAppMenuItem(inMenu, NS_LITERAL_STRING("aboutName"), @selector(menuItemHit:),
    1:                                              eCommand_ID_About, nsMenuBarX::sNativeEventTarget);
    1:     if (itemBeingAdded) {
    1:       [sApplicationMenu addItem:itemBeingAdded];
    1:       [itemBeingAdded release];
    1:       itemBeingAdded = nil;
    1: 
53746:       addAboutSeparator = TRUE;
53746:     }
53746: 
53746:     // Add the software update menu item
53746:     itemBeingAdded = CreateNativeAppMenuItem(inMenu, NS_LITERAL_STRING("checkForUpdates"), @selector(menuItemHit:),
53746:                                              eCommand_ID_Update, nsMenuBarX::sNativeEventTarget);
53746:     if (itemBeingAdded) {
53746:       [sApplicationMenu addItem:itemBeingAdded];
53746:       [itemBeingAdded release];
53746:       itemBeingAdded = nil;
53746: 
53746:       addAboutSeparator = TRUE;
53746:     }
53746: 
53746:     // Add separator if either the About item or software update item exists
53746:     if (addAboutSeparator)
    1:       [sApplicationMenu addItem:[NSMenuItem separatorItem]];
    1: 
    1:     // Add the Preferences menu item
    1:     itemBeingAdded = CreateNativeAppMenuItem(inMenu, NS_LITERAL_STRING("menu_preferences"), @selector(menuItemHit:),
    1:                                              eCommand_ID_Prefs, nsMenuBarX::sNativeEventTarget);
    1:     if (itemBeingAdded) {
    1:       [sApplicationMenu addItem:itemBeingAdded];
    1:       [itemBeingAdded release];
    1:       itemBeingAdded = nil;
    1: 
16036:       // Add separator after Preferences menu
    1:       [sApplicationMenu addItem:[NSMenuItem separatorItem]];
    1:     }
    1: 
    1:     // Add Services menu item
    1:     itemBeingAdded = CreateNativeAppMenuItem(inMenu, NS_LITERAL_STRING("menu_mac_services"), nil,
    1:                                              0, nil);
    1:     if (itemBeingAdded) {
    1:       [sApplicationMenu addItem:itemBeingAdded];
    1:       
    1:       // set this menu item up as the Mac OS X Services menu
36741:       NSMenu* servicesMenu = [[GeckoServicesNSMenu alloc] initWithTitle:@""];
    1:       [itemBeingAdded setSubmenu:servicesMenu];
    1:       [NSApp setServicesMenu:servicesMenu];
    1:       
    1:       [itemBeingAdded release];
    1:       itemBeingAdded = nil;
    1:       
    1:       // Add separator after Services menu
    1:       [sApplicationMenu addItem:[NSMenuItem separatorItem]];      
    1:     }
    1:     
    1:     BOOL addHideShowSeparator = FALSE;
    1:     
    1:     // Add menu item to hide this application
50708:     itemBeingAdded = CreateNativeAppMenuItem(inMenu, NS_LITERAL_STRING("menu_mac_hide_app"), @selector(menuItemHit:),
50708:                                              eCommand_ID_HideApp, nsMenuBarX::sNativeEventTarget);
    1:     if (itemBeingAdded) {
    1:       [sApplicationMenu addItem:itemBeingAdded];
    1:       [itemBeingAdded release];
    1:       itemBeingAdded = nil;
    1:       
    1:       addHideShowSeparator = TRUE;
    1:     }
    1:     
    1:     // Add menu item to hide other applications
50708:     itemBeingAdded = CreateNativeAppMenuItem(inMenu, NS_LITERAL_STRING("menu_mac_hide_others"), @selector(menuItemHit:),
50708:                                              eCommand_ID_HideOthers, nsMenuBarX::sNativeEventTarget);
    1:     if (itemBeingAdded) {
    1:       [sApplicationMenu addItem:itemBeingAdded];
    1:       [itemBeingAdded release];
    1:       itemBeingAdded = nil;
    1:       
    1:       addHideShowSeparator = TRUE;
    1:     }
    1:     
    1:     // Add menu item to show all applications
50708:     itemBeingAdded = CreateNativeAppMenuItem(inMenu, NS_LITERAL_STRING("menu_mac_show_all"), @selector(menuItemHit:),
50708:                                              eCommand_ID_ShowAll, nsMenuBarX::sNativeEventTarget);
    1:     if (itemBeingAdded) {
    1:       [sApplicationMenu addItem:itemBeingAdded];
    1:       [itemBeingAdded release];
    1:       itemBeingAdded = nil;
    1:       
    1:       addHideShowSeparator = TRUE;
    1:     }
    1:     
    1:     // Add a separator after the hide/show menus if at least one exists
    1:     if (addHideShowSeparator)
    1:       [sApplicationMenu addItem:[NSMenuItem separatorItem]];
    1:     
    1:     // Add quit menu item
    1:     itemBeingAdded = CreateNativeAppMenuItem(inMenu, NS_LITERAL_STRING("menu_FileQuitItem"), @selector(menuItemHit:),
    1:                                              eCommand_ID_Quit, nsMenuBarX::sNativeEventTarget);
    1:     if (itemBeingAdded) {
    1:       [sApplicationMenu addItem:itemBeingAdded];
    1:       [itemBeingAdded release];
    1:       itemBeingAdded = nil;
    1:     }
    1:     else {
    1:       // the current application does not have a DOM node for "Quit". Add one
    1:       // anyway, in English.
    1:       NSMenuItem* defaultQuitItem = [[[NSMenuItem alloc] initWithTitle:@"Quit" action:@selector(menuItemHit:)
    1:                                                          keyEquivalent:@"q"] autorelease];
    1:       [defaultQuitItem setTarget:nsMenuBarX::sNativeEventTarget];
    1:       [defaultQuitItem setTag:eCommand_ID_Quit];
    1:       [sApplicationMenu addItem:defaultQuitItem];
    1:     }
    1:   }
    1:   
    1:   return (sApplicationMenu) ? NS_OK : NS_ERROR_FAILURE;
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
15578: void nsMenuBarX::SetParent(nsIWidget* aParent)
    1: {
16264:   mParentWindow = aParent;
    1: }
    1: 
13608: 
 5479: //
14024: // Objective-C class used to allow us to have keyboard commands
14024: // look like they are doing something but actually do nothing.
14024: // We allow mouse actions to work normally.
14024: //
14024: 
50708: // Controls whether or not native menu items should invoke their commands.
50708: static BOOL gMenuItemsExecuteCommands = YES;
14024: 
14024: @implementation GeckoNSMenu
14024: 
50708: // Keyboard commands should not cause menu items to invoke their
50708: // commands when there is a key window because we'd rather send
50708: // the keyboard command to the window. We still have the menus
50708: // go through the mechanics so they'll give the proper visual
50708: // feedback.
14024: - (BOOL)performKeyEquivalent:(NSEvent *)theEvent
14024: {
50708:   // We've noticed that Mac OS X expects this check in subclasses before
50708:   // calling NSMenu's "performKeyEquivalent:".
50708:   //
50708:   // There is no case in which we'd need to do anything or return YES
50708:   // when we have no items so we can just do this check first.
50708:   if ([self numberOfItems] <= 0) {
50448:     return NO;
14024:   }
14024: 
50708:   NSWindow *keyWindow = [NSApp keyWindow];
50708: 
50708:   // If there is no key window then just behave normally. This
50708:   // probably means that this menu is associated with Gecko's
50708:   // hidden window.
50708:   if (!keyWindow) {
50708:     return [super performKeyEquivalent:theEvent];
14738:   }
14738: 
50708:   // Plugins normally eat all keyboard commands, this hack mitigates
50708:   // the problem.
50708:   BOOL handleForPluginHack = NO;
50708:   NSResponder *firstResponder = [keyWindow firstResponder];
50708:   if (firstResponder &&
50708:       [firstResponder isKindOfClass:[ChildView class]] &&
50708:       [(ChildView*)firstResponder isPluginView]) {
50708:     handleForPluginHack = YES;
50708:     // Maintain a list of cmd+key combinations that we never act on (in the
50708:     // browser) when the keyboard focus is in a plugin.  What a particular
50708:     // cmd+key combo means here (to the browser) is governed by browser.dtd,
50708:     // which "contains the browser main menu items".
50708:     UInt32 modifierFlags = [theEvent modifierFlags] & NSDeviceIndependentModifierFlagsMask;
50708:     if (modifierFlags == NSCommandKeyMask) {
50708:       NSString *unmodchars = [theEvent charactersIgnoringModifiers];
50708:       if ([unmodchars length] == 1) {
50708:         if ([unmodchars characterAtIndex:0] == nsMenuBarX::GetLocalizedAccelKey("key_selectAll")) {
50708:           handleForPluginHack = NO;
50708:         }
50708:       }
50708:     }
50708:   }
50708: 
50708:   gMenuItemsExecuteCommands = handleForPluginHack;
50708:   [super performKeyEquivalent:theEvent];
50708:   gMenuItemsExecuteCommands = YES; // return to default
50708: 
50708:   // Return YES if we invoked a command and there is now no key window or we changed
50708:   // the first responder. In this case we do not want to propagate the event because
50708:   // we don't want it handled again.
50708:   if (handleForPluginHack) {
50708:     if (![NSApp keyWindow] || [[NSApp keyWindow] firstResponder] != firstResponder) {
50708:       return YES;
50708:     }
50708:   }
50708: 
50708:   // Return NO so that we can handle the event via NSView's "keyDown:".
50708:   return NO;
14024: }
14024: 
14024: @end
14024: 
14024: //
    1: // Objective-C class used as action target for menu items
 5479: //
 5479: 
    1: @implementation NativeMenuItemTarget
    1: 
    1: // called when some menu item in this menu gets hit
    1: -(IBAction)menuItemHit:(id)sender
    1: {
11881:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11881: 
83012:   // menuGroupOwner below is an nsMenuBarX object, which we sometimes access
83012:   // after it's been deleted, causing crashes (see bug 704866 and bug 670914).
83012:   // To fix this "correctly", in nsMenuBarX::~nsMenuBarX() we'd need to
83012:   // iterate through every NSMenuItem in nsMenuBarX::mNativeMenu and its
83012:   // submenus, which might be quite time consuming.  (For every NSMenuItem
83012:   // that has a "representedObject" that's a MenuItemInfo object, we'd need
83012:   // need to null out its "menuGroupOwner" if it's the same as the nsMenuBarX
83012:   // object being destroyed.)  But if the nsMenuBarX object being destroyed
83012:   // corresponds to the currently focused window, it's likely that the
83012:   // nsMenuBarX destructor will null out sLastGeckoMenuBarPainted.  So we can
83012:   // probably eliminate most of these crashes if we use this variable being
83012:   // null as an indicator that we're likely to crash below when we dereference
83012:   // menuGroupOwner.
83012:   if (!nsMenuBarX::sLastGeckoMenuBarPainted) {
83012:     return;
83012:   }
83012: 
50708:   if (!gMenuItemsExecuteCommands) {
50708:     return;
50708:   }
50708: 
14024:   int tag = [sender tag];
37530: 
37530:   MenuItemInfo* info = [sender representedObject];
37530:   if (!info)
14477:     return;
14024: 
37530:   nsMenuGroupOwnerX* menuGroupOwner = [info menuGroupOwner];
37530:   if (!menuGroupOwner)
37530:     return;
37530: 
37530:   nsMenuBarX* menuBar = nsnull;
37530:   if (menuGroupOwner->MenuObjectType() == eMenuBarObjectType)
37530:     menuBar = static_cast<nsMenuBarX*>(menuGroupOwner);
37530: 
14024:   // Do special processing if this is for an app-global command.
14024:   if (tag == eCommand_ID_About) {
13928:     nsIContent* mostSpecificContent = sAboutItemContent;
13928:     if (menuBar && menuBar->mAboutItemContent)
13928:       mostSpecificContent = menuBar->mAboutItemContent;
15578:     nsMenuUtilsX::DispatchCommandTo(mostSpecificContent);
50708:     return;
    1:   }
53746:   else if (tag == eCommand_ID_Update) {
53746:     nsIContent* mostSpecificContent = sUpdateItemContent;
53746:     if (menuBar && menuBar->mUpdateItemContent)
53746:       mostSpecificContent = menuBar->mUpdateItemContent;
53746:     nsMenuUtilsX::DispatchCommandTo(mostSpecificContent);
53746:   }
14024:   else if (tag == eCommand_ID_Prefs) {
13928:     nsIContent* mostSpecificContent = sPrefItemContent;
13928:     if (menuBar && menuBar->mPrefItemContent)
13928:       mostSpecificContent = menuBar->mPrefItemContent;
15578:     nsMenuUtilsX::DispatchCommandTo(mostSpecificContent);
50708:     return;
50708:   }
50708:   else if (tag == eCommand_ID_HideApp) {
50708:     [NSApp hide:sender];
50708:     return;
50708:   }
50708:   else if (tag == eCommand_ID_HideOthers) {
50708:     [NSApp hideOtherApplications:sender];
50708:     return;
50708:   }
50708:   else if (tag == eCommand_ID_ShowAll) {
50708:     [NSApp unhideAllApplications:sender];
50708:     return;
    1:   }
14024:   else if (tag == eCommand_ID_Quit) {
13928:     nsIContent* mostSpecificContent = sQuitItemContent;
13928:     if (menuBar && menuBar->mQuitItemContent)
13928:       mostSpecificContent = menuBar->mQuitItemContent;
13928:     // If we have some content for quit we execute it. Otherwise we send a native app terminate
13928:     // message. If you want to stop a quit from happening, provide quit content and return
13928:     // the event as unhandled.
14024:     if (mostSpecificContent) {
15578:       nsMenuUtilsX::DispatchCommandTo(mostSpecificContent);
14024:     }
14024:     else {
13928:       [NSApp terminate:nil];
50708:     }
14024:     return;
14024:   }
14024: 
13928:   // given the commandID, look it up in our hashtable and dispatch to
15578:   // that menu item.
37530:   if (menuGroupOwner) {
37530:     nsMenuItemX* menuItem = menuGroupOwner->GetMenuItemForCommandID(static_cast<PRUint32>(tag));
15578:     if (menuItem)
15578:       menuItem->DoCommand();
    1:   }
11881: 
11881:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: @end
36741: 
36741: // Objective-C class used for menu items on the Services menu to allow Gecko
36741: // to override their standard behavior in order to stop key equivalents from
50708: // firing in certain instances. When gMenuItemsExecuteCommands is NO, we return
36741: // a dummy target and action instead of the actual target and action.
36741: 
36741: @implementation GeckoServicesNSMenuItem
36741: 
36741: - (id) target
36741: {
36741:   id realTarget = [super target];
50708:   if (gMenuItemsExecuteCommands)
36741:     return realTarget;
36741:   else
50708:     return realTarget ? self : nil;
36741: }
36741: 
36741: - (SEL) action
36741: {
36741:   SEL realAction = [super action];
50708:   if (gMenuItemsExecuteCommands)
36741:     return realAction;
36741:   else
50708:     return realAction ? @selector(_doNothing:) : NULL;
36741: }
36741: 
36741: - (void) _doNothing:(id)sender
36741: {
36741: }
36741: 
36741: @end
36741: 
36741: // Objective-C class used as the Services menu so that Gecko can override the
36741: // standard behavior of the Services menu in order to stop key equivalents
36741: // from firing in certain instances.
36741: 
36741: @implementation GeckoServicesNSMenu
36741: 
36741: - (void)addItem:(NSMenuItem *)newItem
36741: {
36741:   [self _overrideClassOfMenuItem:newItem];
36741:   [super addItem:newItem];
36741: }
36741: 
36741: - (NSMenuItem *)addItemWithTitle:(NSString *)aString action:(SEL)aSelector keyEquivalent:(NSString *)keyEquiv
36741: {
36741:   NSMenuItem * newItem = [super addItemWithTitle:aString action:aSelector keyEquivalent:keyEquiv];
36741:   [self _overrideClassOfMenuItem:newItem];
36741:   return newItem;
36741: }
36741: 
36741: - (void)insertItem:(NSMenuItem *)newItem atIndex:(NSInteger)index
36741: {
36741:   [self _overrideClassOfMenuItem:newItem];
36741:   [super insertItem:newItem atIndex:index];
36741: }
36741: 
36741: - (NSMenuItem *)insertItemWithTitle:(NSString *)aString action:(SEL)aSelector  keyEquivalent:(NSString *)keyEquiv atIndex:(NSInteger)index
36741: {
36741:   NSMenuItem * newItem = [super insertItemWithTitle:aString action:aSelector keyEquivalent:keyEquiv atIndex:index];
36741:   [self _overrideClassOfMenuItem:newItem];
36741:   return newItem;
36741: }
36741: 
36741: - (void) _overrideClassOfMenuItem:(NSMenuItem *)menuItem
36741: {
36741:   if ([menuItem class] == [NSMenuItem class])
36741:     object_setClass(menuItem, [GeckoServicesNSMenuItem class]);
36741: }
36741: 
36741: @end
