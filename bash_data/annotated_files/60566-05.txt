35117: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35117:  * vim: set ts=8 sw=4 et tw=99:
35117:  *
35117:  * ***** BEGIN LICENSE BLOCK *****
35117:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35117:  *
35117:  * The contents of this file are subject to the Mozilla Public License Version
35117:  * 1.1 (the "License"); you may not use this file except in compliance with
35117:  * the License. You may obtain a copy of the License at
35117:  * http://www.mozilla.org/MPL/
35117:  *
35117:  * Software distributed under the License is distributed on an "AS IS" basis,
35117:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35117:  * for the specific language governing rights and limitations under the
35117:  * License.
35117:  *
35117:  * The Original Code is Mozilla Communicator client code, released
35117:  * March 31, 1998.
35117:  *
35117:  * The Initial Developer of the Original Code is
35117:  * Netscape Communications Corporation.
35117:  * Portions created by the Initial Developer are Copyright (C) 1998
35117:  * the Initial Developer. All Rights Reserved.
35117:  *
35117:  * Contributor(s):
35117:  *
35117:  * Alternatively, the contents of this file may be used under the terms of
35117:  * either of the GNU General Public License Version 2 or later (the "GPL"),
35117:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35117:  * in which case the provisions of the GPL or the LGPL are applicable instead
35117:  * of those above. If you wish to allow use of your version of this file only
35117:  * under the terms of either the GPL or the LGPL, and not to allow others to
35117:  * use your version of this file under the terms of the MPL, indicate your
35117:  * decision by deleting the provisions above and replace them with the notice
35117:  * and other provisions required by the GPL or the LGPL. If you do not delete
35117:  * the provisions above, a recipient may use your version of this file under
35117:  * the terms of any one of the MPL, the GPL or the LGPL.
35117:  *
35117:  * ***** END LICENSE BLOCK ***** */
35117: 
35117: #ifndef jsobjinlines_h___
35117: #define jsobjinlines_h___
35117: 
52503: #include <new>
40901: #include "jsdate.h"
52503: #include "jsfun.h"
40901: #include "jsiter.h"
52503: #include "jslock.h"
40900: #include "jsobj.h"
53555: #include "jsprobes.h"
52503: #include "jspropertytree.h"
35117: #include "jsscope.h"
47497: #include "jsstaticcheck.h"
42693: #include "jsxml.h"
42693: 
52503: /* Headers included for inline implementations used by this header. */
52503: #include "jsbool.h"
47447: #include "jscntxt.h"
52503: #include "jsnum.h"
40858: #include "jsscopeinlines.h"
52503: #include "jsstr.h"
40858: 
54707: #include "jsgcinlines.h"
54707: #include "jsprobes.h"
54707: 
54563: inline bool
54563: JSObject::preventExtensions(JSContext *cx, js::AutoIdVector *props)
52503: {
54563:     JS_ASSERT(isExtensible());
54563: 
54563:     if (js::FixOp fix = getOps()->fix) {
54563:         bool success;
54563:         if (!fix(cx, this, &success, props))
54563:             return false;
54563:         if (!success) {
54563:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_CHANGE_EXTENSIBILITY);
54563:             return false;
54563:         }
54563:     } else {
54563:         if (!GetPropertyNames(cx, this, JSITER_HIDDEN | JSITER_OWNONLY, props))
54563:             return false;
54563:     }
54563: 
52503:     if (isNative())
54563:         extensibleShapeChange(cx);
54563: 
54563:     flags |= NOT_EXTENSIBLE;
54563:     return true;
52503: }
52503: 
52503: inline bool
57748: JSObject::brand(JSContext *cx)
52503: {
52503:     JS_ASSERT(!generic());
52503:     JS_ASSERT(!branded());
52503:     JS_ASSERT(isNative());
52503:     generateOwnShape(cx);
52503:     if (js_IsPropertyCacheDisabled(cx))  // check for rt->shapeGen overflow
52503:         return false;
52503:     flags |= BRANDED;
52503:     return true;
52503: }
52503: 
52503: inline bool
52503: JSObject::unbrand(JSContext *cx)
52503: {
52503:     JS_ASSERT(isNative());
59227:     if (branded()) {
59227:         generateOwnShape(cx);
59227:         if (js_IsPropertyCacheDisabled(cx))  // check for rt->shapeGen overflow
59227:             return false;
59227:         flags &= ~BRANDED;
59227:     }
52503:     setGeneric();
52503:     return true;
52503: }
52503: 
54707: inline void
57806: JSObject::syncSpecialEquality()
57806: {
57806:     if (clasp->ext.equality)
57806:         flags |= JSObject::HAS_EQUALITY;
57806: }
57806: 
57806: inline void
57817: JSObject::finalize(JSContext *cx)
54707: {
54707:     /* Cope with stillborn objects that have no map. */
54707:     if (!map)
54707:         return;
54707: 
54707:     /* Finalize obj first, in case it needs map and slots. */
54707:     js::Class *clasp = getClass();
54707:     if (clasp->finalize)
54707:         clasp->finalize(cx, this);
54707: 
54707:     js::Probes::finalizeObject(this);
54707: 
54707:     finish(cx);
54707: }
54707: 
52503: /*
52503:  * Property read barrier for deferred cloning of compiler-created function
52503:  * objects optimized as typically non-escaping, ad-hoc methods in obj.
52503:  */
52503: inline bool
52503: JSObject::methodReadBarrier(JSContext *cx, const js::Shape &shape, js::Value *vp)
52503: {
52503:     JS_ASSERT(canHaveMethodBarrier());
52503:     JS_ASSERT(hasMethodBarrier());
52503:     JS_ASSERT(nativeContains(shape));
52503:     JS_ASSERT(shape.isMethod());
52503:     JS_ASSERT(&shape.methodObject() == &vp->toObject());
52503: 
52503:     JSObject *funobj = &vp->toObject();
52503:     JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
52503:     JS_ASSERT(fun == funobj && FUN_NULL_CLOSURE(fun));
52503: 
52503:     funobj = CloneFunctionObject(cx, fun, funobj->getParent());
52503:     if (!funobj)
52503:         return false;
52503:     funobj->setMethodObj(*this);
52503: 
52503:     vp->setObject(*funobj);
56760:     if (!js_SetPropertyHelper(cx, this, shape.id, 0, vp, false))
52503:         return false;
52503: 
52503: #ifdef DEBUG
52503:     if (cx->runtime->functionMeterFilename) {
52503:         JS_FUNCTION_METER(cx, mreadbarrier);
52503: 
52503:         typedef JSRuntime::FunctionCountMap HM;
52503:         HM &h = cx->runtime->methodReadBarrierCountMap;
52503:         HM::AddPtr p = h.lookupForAdd(fun);
52503:         if (!p) {
52503:             h.add(p, fun, 1);
52503:         } else {
52503:             JS_ASSERT(p->key == fun);
52503:             ++p->value;
52503:         }
52503:     }
52503: #endif
52503:     return true;
52503: }
52503: 
52503: static JS_ALWAYS_INLINE bool
52503: ChangesMethodValue(const js::Value &prev, const js::Value &v)
52503: {
52503:     JSObject *prevObj;
52503:     return prev.isObject() && (prevObj = &prev.toObject())->isFunction() &&
52503:            (!v.isObject() || &v.toObject() != prevObj);
52503: }
52503: 
52503: inline bool
52503: JSObject::methodWriteBarrier(JSContext *cx, const js::Shape &shape, const js::Value &v)
52503: {
59227:     if (brandedOrHasMethodBarrier() && shape.slot != SHAPE_INVALID_SLOT) {
56567:         const js::Value &prev = nativeGetSlot(shape.slot);
52503: 
52503:         if (ChangesMethodValue(prev, v)) {
52503:             JS_FUNCTION_METER(cx, mwritebarrier);
52503:             return methodShapeChange(cx, shape);
52503:         }
52503:     }
52503:     return true;
52503: }
52503: 
52503: inline bool
52503: JSObject::methodWriteBarrier(JSContext *cx, uint32 slot, const js::Value &v)
52503: {
59227:     if (brandedOrHasMethodBarrier()) {
56567:         const js::Value &prev = nativeGetSlot(slot);
52503: 
52503:         if (ChangesMethodValue(prev, v)) {
52503:             JS_FUNCTION_METER(cx, mwslotbarrier);
52503:             return methodShapeChange(cx, slot);
52503:         }
52503:     }
52503:     return true;
52503: }
52503: 
52503: inline bool
52503: JSObject::ensureClassReservedSlots(JSContext *cx)
52503: {
52503:     return !nativeEmpty() || ensureClassReservedSlotsForEmptyObject(cx);
52503: }
52503: 
48470: inline js::Value
47404: JSObject::getReservedSlot(uintN index) const
47404: {
55746:     return (index < numSlots()) ? getSlot(index) : js::UndefinedValue();
47404: }
47404: 
40901: inline bool
48676: JSObject::canHaveMethodBarrier() const
48676: {
48676:     return isObject() || isFunction() || isPrimitive() || isDate();
48676: }
48676: 
48676: inline bool
40901: JSObject::isPrimitive() const
40901: {
40901:     return isNumber() || isString() || isBoolean();
40901: }
40901: 
48470: inline const js::Value &
40901: JSObject::getPrimitiveThis() const
40901: {
40901:     JS_ASSERT(isPrimitive());
55746:     return getSlot(JSSLOT_PRIMITIVE_THIS);
40901: }
40901: 
40901: inline void
48470: JSObject::setPrimitiveThis(const js::Value &pthis)
40901: {
40901:     JS_ASSERT(isPrimitive());
55746:     setSlot(JSSLOT_PRIMITIVE_THIS, pthis);
40901: }
40901: 
58534: inline /* gc::FinalizeKind */ unsigned
58534: JSObject::finalizeKind() const
58056: {
58534:     return js::gc::FinalizeKind(arena()->header()->thingKind);
58056: }
58056: 
55746: inline size_t
55746: JSObject::numFixedSlots() const
40797: {
55746:     if (isFunction())
55746:         return JSObject::FUN_CLASS_RESERVED_SLOTS;
55746:     if (!hasSlotsArray())
55746:         return capacity;
58534:     return js::gc::GetGCKindSlots(js::gc::FinalizeKind(finalizeKind()));
55746: }
55746: 
55746: inline size_t
55746: JSObject::slotsAndStructSize(uint32 nslots) const
55746: {
55746:     bool isFun = isFunction() && this == (JSObject*) getPrivate();
55746: 
55746:     int ndslots = hasSlotsArray() ? nslots : 0;
55746:     int nfslots = isFun ? 0 : numFixedSlots();
55746: 
55746:     return sizeof(js::Value) * (ndslots + nfslots)
55746:            + isFun ? sizeof(JSFunction) : sizeof(JSObject);
40797: }
40797: 
40796: inline uint32
40796: JSObject::getArrayLength() const
40796: {
40796:     JS_ASSERT(isArray());
55746:     return (uint32)(size_t) getPrivate();
40796: }
40796: 
40901: inline void
48537: JSObject::setArrayLength(uint32 length)
40901: {
48537:     JS_ASSERT(isArray());
55746:     setPrivate((void*) length);
41850: }
41850: 
41850: inline uint32
55746: JSObject::getDenseArrayCapacity()
41782: {
41782:     JS_ASSERT(isDenseArray());
55746:     return numSlots();
55746: }
55746: 
55746: inline js::Value*
55746: JSObject::getDenseArrayElements()
55746: {
55746:     JS_ASSERT(isDenseArray());
55746:     return getSlots();
55746: }
55746: 
55746: inline const js::Value &
55746: JSObject::getDenseArrayElement(uintN idx)
55746: {
55746:     JS_ASSERT(isDenseArray());
55746:     return getSlot(idx);
55746: }
55746: 
55746: inline js::Value *
55746: JSObject::addressOfDenseArrayElement(uintN idx)
55746: {
55746:     JS_ASSERT(isDenseArray());
55746:     return &getSlotRef(idx);
54426: }
54426: 
54426: inline void
55746: JSObject::setDenseArrayElement(uintN idx, const js::Value &val)
54426: {
54426:     JS_ASSERT(isDenseArray());
55746:     setSlot(idx, val);
54426: }
54426: 
54426: inline void
55746: JSObject::shrinkDenseArrayElements(JSContext *cx, uintN cap)
54425: {
54425:     JS_ASSERT(isDenseArray());
55746:     shrinkSlots(cx, cap);
40796: }
40796: 
35117: inline void
40864: JSObject::setArgsLength(uint32 argc)
40864: {
40864:     JS_ASSERT(isArguments());
40864:     JS_ASSERT(argc <= JS_ARGS_LENGTH_MAX);
51092:     JS_ASSERT(UINT32_MAX > (uint64(argc) << ARGS_PACKED_BITS_COUNT));
55746:     getSlotRef(JSSLOT_ARGS_LENGTH).setInt32(argc << ARGS_PACKED_BITS_COUNT);
40864:     JS_ASSERT(!isArgsLengthOverridden());
40864: }
40864: 
40864: inline uint32
51091: JSObject::getArgsInitialLength() const
40864: {
40864:     JS_ASSERT(isArguments());
55746:     uint32 argc = uint32(getSlot(JSSLOT_ARGS_LENGTH).toInt32()) >> ARGS_PACKED_BITS_COUNT;
40864:     JS_ASSERT(argc <= JS_ARGS_LENGTH_MAX);
40864:     return argc;
40864: }
40864: 
40864: inline void
40864: JSObject::setArgsLengthOverridden()
40864: {
40864:     JS_ASSERT(isArguments());
55746:     getSlotRef(JSSLOT_ARGS_LENGTH).getInt32Ref() |= ARGS_LENGTH_OVERRIDDEN_BIT;
40864: }
40864: 
40864: inline bool
41871: JSObject::isArgsLengthOverridden() const
40864: {
40864:     JS_ASSERT(isArguments());
55746:     const js::Value &v = getSlot(JSSLOT_ARGS_LENGTH);
51092:     return v.toInt32() & ARGS_LENGTH_OVERRIDDEN_BIT;
40864: }
40864: 
52503: inline js::ArgumentsData *
52503: JSObject::getArgsData() const
52503: {
52503:     JS_ASSERT(isArguments());
55746:     return (js::ArgumentsData *) getSlot(JSSLOT_ARGS_DATA).toPrivate();
52503: }
52503: 
52503: inline void
52503: JSObject::setArgsData(js::ArgumentsData *data)
52503: {
52503:     JS_ASSERT(isArguments());
55746:     getSlotRef(JSSLOT_ARGS_DATA).setPrivate(data);
52503: }
52503: 
48470: inline const js::Value &
40864: JSObject::getArgsCallee() const
40864: {
52503:     return getArgsData()->callee;
40864: }
40864: 
40864: inline void
48470: JSObject::setArgsCallee(const js::Value &callee)
40864: {
52503:     getArgsData()->callee = callee;
40864: }
40864: 
48470: inline const js::Value &
41871: JSObject::getArgsElement(uint32 i) const
41871: {
41871:     JS_ASSERT(isArguments());
52503:     JS_ASSERT(i < getArgsInitialLength());
52503:     return getArgsData()->slots[i];
41871: }
41871: 
48470: inline js::Value *
57714: JSObject::getArgsElements() const
57714: {
57714:     JS_ASSERT(isArguments());
57714:     return getArgsData()->slots;
57714: }
57714: 
57714: inline js::Value *
55746: JSObject::addressOfArgsElement(uint32 i)
48470: {
48470:     JS_ASSERT(isArguments());
52503:     JS_ASSERT(i < getArgsInitialLength());
52503:     return &getArgsData()->slots[i];
48470: }
48470: 
41871: inline void
48470: JSObject::setArgsElement(uint32 i, const js::Value &v)
41871: {
41871:     JS_ASSERT(isArguments());
52503:     JS_ASSERT(i < getArgsInitialLength());
52503:     getArgsData()->slots[i] = v;
41871: }
41871: 
60243: inline bool
60243: JSObject::callIsForEval() const
60243: {
60243:     JS_ASSERT(isCall());
60243:     JS_ASSERT(getSlot(JSSLOT_CALL_CALLEE).isObjectOrNull());
60243:     JS_ASSERT_IF(getSlot(JSSLOT_CALL_CALLEE).isObject(),
60243:                  getSlot(JSSLOT_CALL_CALLEE).toObject().isFunction());
60243:     return getSlot(JSSLOT_CALL_CALLEE).isNull();
60243: }
60243: 
59969: inline JSStackFrame *
59969: JSObject::maybeCallObjStackFrame() const
59969: {
59969:     JS_ASSERT(isCall());
59969:     return reinterpret_cast<JSStackFrame *>(getPrivate());
59969: }
59969: 
53840: inline void
60146: JSObject::setCallObjCallee(JSObject *callee)
53840: {
53840:     JS_ASSERT(isCall());
60146:     JS_ASSERT_IF(callee, callee->isFunction());
60146:     return getSlotRef(JSSLOT_CALL_CALLEE).setObjectOrNull(callee);
53840: }
53840: 
60146: inline JSObject *
53840: JSObject::getCallObjCallee() const
53840: {
53840:     JS_ASSERT(isCall());
60146:     return getSlot(JSSLOT_CALL_CALLEE).toObjectOrNull();
53840: }
53840: 
53840: inline JSFunction *
53840: JSObject::getCallObjCalleeFunction() const
53840: {
53840:     JS_ASSERT(isCall());
55746:     return getSlot(JSSLOT_CALL_CALLEE).toObject().getFunctionPrivate();
53840: }
53840: 
53840: inline const js::Value &
53840: JSObject::getCallObjArguments() const
53840: {
53840:     JS_ASSERT(isCall());
60243:     JS_ASSERT(!callIsForEval());
55746:     return getSlot(JSSLOT_CALL_ARGUMENTS);
53840: }
53840: 
53840: inline void
53840: JSObject::setCallObjArguments(const js::Value &v)
53840: {
53840:     JS_ASSERT(isCall());
60243:     JS_ASSERT(!callIsForEval());
55746:     setSlot(JSSLOT_CALL_ARGUMENTS, v);
53840: }
53840: 
48470: inline const js::Value &
59969: JSObject::callObjArg(uintN i) const
59969: {
59969:     JS_ASSERT(isCall());
59969:     JS_ASSERT(i < getCallObjCalleeFunction()->nargs);
59969:     return getSlot(JSObject::CALL_RESERVED_SLOTS + i);
59969: }
59969: 
59969: inline js::Value &
59969: JSObject::callObjArg(uintN i)
59969: {
59969:     JS_ASSERT(isCall());
59969:     JS_ASSERT(i < getCallObjCalleeFunction()->nargs);
59969:     return getSlotRef(JSObject::CALL_RESERVED_SLOTS + i);
59969: }
59969: 
59969: inline const js::Value &
59969: JSObject::callObjVar(uintN i) const
59969: {
59969:     JSFunction *fun = getCallObjCalleeFunction();
59969:     JS_ASSERT(fun->nargs == fun->script()->bindings.countArgs());
59969:     JS_ASSERT(i < fun->script()->bindings.countVars());
59969:     return getSlot(JSObject::CALL_RESERVED_SLOTS + fun->nargs + i);
59969: }
59969: 
59969: inline js::Value &
59969: JSObject::callObjVar(uintN i)
59969: {
59969:     JSFunction *fun = getCallObjCalleeFunction();
59969:     JS_ASSERT(fun->nargs == fun->script()->bindings.countArgs());
59969:     JS_ASSERT(i < fun->script()->bindings.countVars());
59969:     return getSlotRef(JSObject::CALL_RESERVED_SLOTS + fun->nargs + i);
59969: }
59969: 
59969: inline const js::Value &
40901: JSObject::getDateUTCTime() const
40901: {
40901:     JS_ASSERT(isDate());
55746:     return getSlot(JSSLOT_DATE_UTC_TIME);
40901: }
40901: 
40901: inline void 
48470: JSObject::setDateUTCTime(const js::Value &time)
40901: {
40901:     JS_ASSERT(isDate());
55746:     setSlot(JSSLOT_DATE_UTC_TIME, time);
40901: }
40901: 
52503: inline js::Value *
52503: JSObject::getFlatClosureUpvars() const
52503: {
59969: #ifdef DEBUG
59969:     JSFunction *fun = getFunctionPrivate();
59969:     JS_ASSERT(fun->isFlatClosure());
59969:     JS_ASSERT(fun->script()->bindings.countUpvars() == fun->script()->upvars()->length);
59969: #endif
55746:     return (js::Value *) getSlot(JSSLOT_FLAT_CLOSURE_UPVARS).toPrivate();
52503: }
52503: 
52503: inline js::Value
52503: JSObject::getFlatClosureUpvar(uint32 i) const
52503: {
59968:     JS_ASSERT(i < getFunctionPrivate()->script()->bindings.countUpvars());
52503:     return getFlatClosureUpvars()[i];
52503: }
52503: 
59969: inline js::Value &
59969: JSObject::getFlatClosureUpvar(uint32 i)
59969: {
59969:     JS_ASSERT(i < getFunctionPrivate()->script()->bindings.countUpvars());
59969:     return getFlatClosureUpvars()[i];
59969: }
59969: 
52503: inline void
52503: JSObject::setFlatClosureUpvars(js::Value *upvars)
52503: {
52503:     JS_ASSERT(isFunction());
52503:     JS_ASSERT(FUN_FLAT_CLOSURE(getFunctionPrivate()));
55746:     getSlotRef(JSSLOT_FLAT_CLOSURE_UPVARS).setPrivate(upvars);
52503: }
52503: 
48676: inline bool
48676: JSObject::hasMethodObj(const JSObject& obj) const
48676: {
55746:     return JSSLOT_FUN_METHOD_OBJ < numSlots() &&
55746:            getSlot(JSSLOT_FUN_METHOD_OBJ).isObject() &&
55746:            &getSlot(JSSLOT_FUN_METHOD_OBJ).toObject() == &obj;
48676: }
48676: 
48676: inline void
48676: JSObject::setMethodObj(JSObject& obj)
48676: {
55746:     getSlotRef(JSSLOT_FUN_METHOD_OBJ).setObject(obj);
48676: }
48676: 
55632: inline js::NativeIterator *
42641: JSObject::getNativeIterator() const
42641: {
55632:     return (js::NativeIterator *) getPrivate();
42641: }
42641: 
42641: inline void
55632: JSObject::setNativeIterator(js::NativeIterator *ni)
42641: {
42641:     setPrivate(ni);
42641: }
42641: 
59890: inline JSLinearString *
59890: JSObject::getNamePrefix() const
59890: {
59890:     JS_ASSERT(isNamespace() || isQName());
59890:     const js::Value &v = getSlot(JSSLOT_NAME_PREFIX);
59890:     return !v.isUndefined() ? v.toString()->assertIsLinear() : NULL;
59890: }
59890: 
42693: inline jsval
59890: JSObject::getNamePrefixVal() const
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
55746:     return js::Jsvalify(getSlot(JSSLOT_NAME_PREFIX));
42693: }
42693: 
42693: inline void
59890: JSObject::setNamePrefix(JSLinearString *prefix)
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
59890:     setSlot(JSSLOT_NAME_PREFIX, prefix ? js::StringValue(prefix) : js::UndefinedValue());
59890: }
59890: 
59890: inline void
59890: JSObject::clearNamePrefix()
59890: {
59890:     JS_ASSERT(isNamespace() || isQName());
59890:     setSlot(JSSLOT_NAME_PREFIX, js::UndefinedValue());
59890: }
59890: 
59890: inline JSLinearString *
59890: JSObject::getNameURI() const
59890: {
59890:     JS_ASSERT(isNamespace() || isQName());
59890:     const js::Value &v = getSlot(JSSLOT_NAME_URI);
59890:     return !v.isUndefined() ? v.toString()->assertIsLinear() : NULL;
42693: }
42693: 
42693: inline jsval
59890: JSObject::getNameURIVal() const
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
55746:     return js::Jsvalify(getSlot(JSSLOT_NAME_URI));
42693: }
42693: 
42693: inline void
59890: JSObject::setNameURI(JSLinearString *uri)
42693: {
42693:     JS_ASSERT(isNamespace() || isQName());
59890:     setSlot(JSSLOT_NAME_URI, uri ? js::StringValue(uri) : js::UndefinedValue());
42693: }
42693: 
42693: inline jsval
42693: JSObject::getNamespaceDeclared() const
42693: {
42693:     JS_ASSERT(isNamespace());
55746:     return js::Jsvalify(getSlot(JSSLOT_NAMESPACE_DECLARED));
42693: }
42693: 
42693: inline void
42693: JSObject::setNamespaceDeclared(jsval decl)
42693: {
42693:     JS_ASSERT(isNamespace());
55746:     setSlot(JSSLOT_NAMESPACE_DECLARED, js::Valueify(decl));
42693: }
42693: 
59890: inline JSLinearString *
59890: JSObject::getQNameLocalName() const
59890: {
59890:     JS_ASSERT(isQName());
59890:     const js::Value &v = getSlot(JSSLOT_QNAME_LOCAL_NAME);
59890:     return !v.isUndefined() ? v.toString()->assertIsLinear() : NULL;
59890: }
59890: 
42693: inline jsval
59890: JSObject::getQNameLocalNameVal() const
42693: {
42693:     JS_ASSERT(isQName());
55746:     return js::Jsvalify(getSlot(JSSLOT_QNAME_LOCAL_NAME));
42693: }
42693: 
42693: inline void
59890: JSObject::setQNameLocalName(JSLinearString *name)
42693: {
42693:     JS_ASSERT(isQName());
59890:     setSlot(JSSLOT_QNAME_LOCAL_NAME, name ? js::StringValue(name) : js::UndefinedValue());
42693: }
42693: 
47417: inline JSObject *
47417: JSObject::getWithThis() const
47417: {
55746:     return &getSlot(JSSLOT_WITH_THIS).toObject();
47417: }
47417: 
47417: inline void
47417: JSObject::setWithThis(JSObject *thisp)
47417: {
55746:     getSlotRef(JSSLOT_WITH_THIS).setObject(*thisp);
47417: }
47417: 
40864: inline void
55746: JSObject::init(JSContext *cx, js::Class *aclasp, JSObject *proto, JSObject *parent,
55746:                void *priv, bool useHoles)
35117: {
52503:     clasp = aclasp;
59911:     flags = 0;
52503: 
52503: #ifdef DEBUG
52503:     /*
52503:      * NB: objShape must not be set here; rather, the caller must call setMap
52503:      * or setSharedNonNativeMap after calling init. To defend this requirement
52503:      * we set map to null in DEBUG builds, and set objShape to a value we then
52503:      * assert obj->shape() never returns.
52503:      */
52503:     map = NULL;
52503:     objShape = JSObjectMap::INVALID_SHAPE;
52503: #endif
52503: 
52503:     setProto(proto);
52503:     setParent(parent);
52503: 
55746:     privateData = priv;
55746:     slots = fixedSlots();
55746: 
55746:     /*
55746:      * Fill the fixed slots with undefined or array holes.  This object must
55746:      * already have its capacity filled in, as by js_NewGCObject.
55746:      */
55746:     JS_ASSERT(capacity == numFixedSlots());
55746:     ClearValueRange(slots, capacity, useHoles);
52503: 
55746:     emptyShapes = NULL;
53638: }
53638: 
53638: inline void
52503: JSObject::finish(JSContext *cx)
52503: {
52503: #ifdef DEBUG
52503:     if (isNative())
52503:         JS_LOCK_RUNTIME_VOID(cx->runtime, cx->runtime->liveObjectProps -= propertyCount());
52503: #endif
52503:     if (hasSlotsArray())
52503:         freeSlotsArray(cx);
55748:     if (emptyShapes)
55748:         cx->free(emptyShapes);
52503: }
52503: 
55746: inline bool
55746: JSObject::initSharingEmptyShape(JSContext *cx,
55746:                                 js::Class *aclasp,
52503:                                 JSObject *proto,
52503:                                 JSObject *parent,
55746:                                 void *privateValue,
55746:                                 /* js::gc::FinalizeKind */ unsigned kind)
52503: {
55746:     init(cx, aclasp, proto, parent, privateValue, false);
52503: 
55746:     JS_ASSERT(!isDenseArray());
55746: 
55746:     js::EmptyShape *empty = proto->getEmptyShape(cx, aclasp, kind);
55746:     if (!empty)
55746:         return false;
55746: 
54426:     setMap(empty);
55746:     return true;
53638: }
53638: 
53638: inline void
36997: JSObject::freeSlotsArray(JSContext *cx)
36997: {
36997:     JS_ASSERT(hasSlotsArray());
55746:     cx->free(slots);
55746: }
55746: 
55746: inline void
55746: JSObject::revertToFixedSlots(JSContext *cx)
55746: {
55746:     JS_ASSERT(hasSlotsArray());
55746:     size_t fixed = numFixedSlots();
55746:     JS_ASSERT(capacity >= fixed);
55746:     memcpy(fixedSlots(), slots, fixed * sizeof(js::Value));
55746:     freeSlotsArray(cx);
55746:     slots = fixedSlots();
55746:     capacity = fixed;
36997: }
36997: 
37685: inline bool
52503: JSObject::hasProperty(JSContext *cx, jsid id, bool *foundp, uintN flags)
37685: {
52503:     JSObject *pobj;
52503:     JSProperty *prop;
52503:     JSAutoResolveFlags rf(cx, flags);
52503:     if (!lookupProperty(cx, id, &pobj, &prop))
37685:         return false;
52503:     *foundp = !!prop;
52503:     return true;
37685: }
52503: 
52503: inline bool
52503: JSObject::isCallable()
52503: {
52503:     return isFunction() || getClass()->call;
37685: }
52503: 
52503: static inline bool
52503: js_IsCallable(const js::Value &v)
52503: {
52503:     return v.isObject() && v.toObject().isCallable();
37685: }
37685: 
40388: namespace js {
40388: 
48470: class AutoPropDescArrayRooter : private AutoGCRooter
40388: {
40388:   public:
48470:     AutoPropDescArrayRooter(JSContext *cx)
40388:       : AutoGCRooter(cx, DESCRIPTORS), descriptors(cx)
40388:     { }
40388: 
48470:     PropDesc *append() {
48470:         if (!descriptors.append(PropDesc()))
40388:             return NULL;
40388:         return &descriptors.back();
40388:     }
40388: 
48470:     PropDesc& operator[](size_t i) {
40388:         JS_ASSERT(i < descriptors.length());
40388:         return descriptors[i];
40388:     }
40388: 
40388:     friend void AutoGCRooter::trace(JSTracer *trc);
40388: 
40388:   private:
48470:     PropDescArray descriptors;
40388: };
40388: 
48470: class AutoPropertyDescriptorRooter : private AutoGCRooter, public PropertyDescriptor
42733: {
42733:   public:
48470:     AutoPropertyDescriptorRooter(JSContext *cx) : AutoGCRooter(cx, DESCRIPTOR) {
42733:         obj = NULL;
42733:         attrs = 0;
48470:         getter = setter = (PropertyOp) NULL;
48470:         value.setUndefined();
42733:     }
42733: 
52503:     AutoPropertyDescriptorRooter(JSContext *cx, PropertyDescriptor *desc)
52503:       : AutoGCRooter(cx, DESCRIPTOR)
52503:     {
47498:         obj = desc->obj;
47498:         attrs = desc->attrs;
47498:         getter = desc->getter;
47498:         setter = desc->setter;
47498:         value = desc->value;
47498:     }
47498: 
42733:     friend void AutoGCRooter::trace(JSTracer *trc);
42733: };
42733: 
40858: static inline bool
55746: InitScopeForObject(JSContext* cx, JSObject* obj, js::Class *clasp, JSObject* proto,
55746:                    gc::FinalizeKind kind)
40858: {
48622:     JS_ASSERT(clasp->isNative());
40858:     JS_ASSERT(proto == obj->getProto());
40858: 
52503:     /* Share proto's emptyShape only if obj is similar to proto. */
52503:     js::EmptyShape *empty = NULL;
40858: 
52503:     if (proto) {
52503:         if (proto->canProvideEmptyShape(clasp)) {
55746:             empty = proto->getEmptyShape(cx, clasp, kind);
52503:             if (!empty)
40858:                 goto bad;
40858:         }
40858:     }
40858: 
52503:     if (!empty) {
52503:         empty = js::EmptyShape::create(cx, clasp);
52503:         if (!empty)
40858:             goto bad;
55746:         uint32 freeslot = JSSLOT_FREE(clasp);
55746:         if (freeslot > obj->numSlots() && !obj->allocSlots(cx, freeslot))
40858:             goto bad;
40858:     }
40858: 
52503:     obj->setMap(empty);
40858:     return true;
40858: 
40858:   bad:
40858:     /* The GC nulls map initially. It should still be null on error. */
40858:     JS_ASSERT(!obj->map);
40858:     return false;
40858: }
40858: 
47497: /*
47497:  * Helper optimized for creating a native instance of the given class (not the
50450:  * class's prototype object). Use this in preference to NewObject, but use
50450:  * NewBuiltinClassInstance if you need the default class prototype as proto,
50450:  * and its parent global as parent.
47497:  */
40858: static inline JSObject *
55746: NewNativeClassInstance(JSContext *cx, Class *clasp, JSObject *proto,
55746:                        JSObject *parent, gc::FinalizeKind kind)
47497: {
47497:     JS_ASSERT(proto);
47497:     JS_ASSERT(proto->isNative());
47497:     JS_ASSERT(parent);
47497: 
47497:     /*
47497:      * Allocate an object from the GC heap and initialize all its fields before
50450:      * doing any operation that can potentially trigger GC.
47497:      */
55746:     JSObject* obj = js_NewGCObject(cx, kind);
50450: 
47497:     if (obj) {
47497:         /*
47497:          * Default parent to the parent of the prototype, which was set from
47497:          * the parent of the prototype's constructor.
47497:          */
55746:         bool useHoles = (clasp == &js_ArrayClass);
55746:         obj->init(cx, clasp, proto, parent, NULL, useHoles);
47497: 
52503:         JS_ASSERT(proto->canProvideEmptyShape(clasp));
55746:         js::EmptyShape *empty = proto->getEmptyShape(cx, clasp, kind);
47497: 
52503:         if (empty)
52503:             obj->setMap(empty);
52503:         else
47497:             obj = NULL;
47497:     }
47497: 
47497:     return obj;
47497: }
47497: 
55746: static inline JSObject *
55746: NewNativeClassInstance(JSContext *cx, Class *clasp, JSObject *proto, JSObject *parent)
55746: {
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(JSCLASS_RESERVED_SLOTS(clasp));
55746:     return NewNativeClassInstance(cx, clasp, proto, parent, kind);
55746: }
55746: 
47497: bool
47497: FindClassPrototype(JSContext *cx, JSObject *scope, JSProtoKey protoKey, JSObject **protop,
48470:                    Class *clasp);
47497: 
47497: /*
47497:  * Helper used to create Boolean, Date, RegExp, etc. instances of built-in
48470:  * classes with class prototypes of the same Class. See, e.g., jsdate.cpp,
47497:  * jsregexp.cpp, and js_PrimitiveToObject in jsobj.cpp. Use this to get the
47497:  * right default proto and parent for clasp in cx.
47497:  */
47497: static inline JSObject *
55746: NewBuiltinClassInstance(JSContext *cx, Class *clasp, gc::FinalizeKind kind)
47497: {
47497:     VOUCH_DOES_NOT_REQUIRE_STACK();
47497: 
47497:     JSProtoKey protoKey = JSCLASS_CACHED_PROTO_KEY(clasp);
47497:     JS_ASSERT(protoKey != JSProto_Null);
47497: 
47497:     /* NB: inline-expanded and specialized version of js_GetClassPrototype. */
47535:     JSObject *global;
51446:     if (!cx->hasfp()) {
47535:         global = cx->globalObject;
47535:         OBJ_TO_INNER_OBJECT(cx, global);
47535:         if (!global)
47535:             return NULL;
47535:     } else {
53840:         global = cx->fp()->scopeChain().getGlobal();
47535:     }
60566:     JS_ASSERT(global->isGlobal());
47497: 
48470:     const Value &v = global->getReservedSlot(JSProto_LIMIT + protoKey);
47497:     JSObject *proto;
48470:     if (v.isObject()) {
48470:         proto = &v.toObject();
47497:         JS_ASSERT(proto->getParent() == global);
47497:     } else {
47497:         if (!FindClassPrototype(cx, global, protoKey, &proto, clasp))
47497:             return NULL;
47497:     }
47497: 
55746:     return NewNativeClassInstance(cx, clasp, proto, global, kind);
55746: }
55746: 
55746: static inline JSObject *
55746: NewBuiltinClassInstance(JSContext *cx, Class *clasp)
55746: {
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(JSCLASS_RESERVED_SLOTS(clasp));
55746:     return NewBuiltinClassInstance(cx, clasp, kind);
47497: }
47497: 
50450: static inline JSProtoKey
50450: GetClassProtoKey(js::Class *clasp)
50450: {
50450:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
50450:     if (key != JSProto_Null)
50450:         return key;
50450:     if (clasp->flags & JSCLASS_IS_ANONYMOUS)
50450:         return JSProto_Object;
50450:     return JSProto_Null;
50450: }
50450: 
50450: namespace WithProto {
50450:     enum e {
50450:         Class = 0,
50450:         Given = 1
50450:     };
50450: }
50450: 
47497: /*
50450:  * Create an instance of any class, native or not, JSFunction-sized or not.
50450:  *
50450:  * If withProto is 'Class':
50450:  *    If proto is null:
50450:  *      for a built-in class:
50450:  *        use the memoized original value of the class constructor .prototype
50450:  *        property object
50450:  *      else if available
50450:  *        the current value of .prototype
50450:  *      else
50450:  *        Object.prototype.
50450:  *
50450:  *    If parent is null, default it to proto->getParent() if proto is non
50450:  *    null, else to null.
50450:  *
50450:  * If withProto is 'Given':
50450:  *    We allocate an object with exactly the given proto.  A null parent
50450:  *    defaults to proto->getParent() if proto is non-null (else to null).
50450:  *
50450:  * If isFunction is true, return a JSFunction-sized object. If isFunction is
50450:  * false, return a normal object.
50450:  *
50450:  * Note that as a template, there will be lots of instantiations, which means
50450:  * the internals will be specialized based on the template parameters.
47497:  */
59234: static JS_ALWAYS_INLINE bool
59234: FindProto(JSContext *cx, js::Class *clasp, JSObject *parent, JSObject ** proto)
59234: {
59234:     JSProtoKey protoKey = GetClassProtoKey(clasp);
59234:     if (!js_GetClassPrototype(cx, parent, protoKey, proto, clasp))
59234:         return false;
59234:     if (!(*proto) && !js_GetClassPrototype(cx, parent, JSProto_Object, proto))
59234:         return false;
59234: 
59234:     return true;
59234: }
59234: 
50450: namespace detail
40858: {
50450: template <bool withProto, bool isFunction>
50450: static JS_ALWAYS_INLINE JSObject *
55746: NewObject(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
55746:           gc::FinalizeKind kind)
50450: {
50450:     /* Bootstrap the ur-object, and make it the default prototype object. */
50450:     if (withProto == WithProto::Class && !proto) {
59234:         if (!FindProto (cx, clasp, parent, &proto))
50450:           return NULL;
50450:     }
50450: 
40858:     /*
40858:      * Allocate an object from the GC heap and initialize all its fields before
40858:      * doing any operation that can potentially trigger GC. Functions have a
40858:      * larger non-standard allocation size.
50450:      *
50450:      * The should be specialized by the template.
40858:      */
55746:     JSObject* obj = isFunction ? js_NewGCFunction(cx) : js_NewGCObject(cx, kind);
40858:     if (!obj)
40858:         goto out;
40858: 
55746:     /* This needs to match up with the size of JSFunction::data_padding. */
55746:     JS_ASSERT_IF(isFunction, kind == gc::FINALIZE_OBJECT2);
55746: 
40858:     /*
40858:      * Default parent to the parent of the prototype, which was set from
40858:      * the parent of the prototype's constructor.
40858:      */
55746:     obj->init(cx, clasp, proto,
55746:               (!parent && proto) ? proto->getParent() : parent,
55746:               NULL, clasp == &js_ArrayClass);
40858: 
48622:     if (clasp->isNative()) {
55746:         if (!InitScopeForObject(cx, obj, clasp, proto, kind)) {
40858:             obj = NULL;
40858:             goto out;
40858:         }
40858:     } else {
52503:         obj->setSharedNonNativeMap();
40858:     }
40858: 
40858: out:
53555:     Probes::createObject(cx, obj);
40858:     return obj;
40858: }
55746: } /* namespace detail */
40858: 
50450: static JS_ALWAYS_INLINE JSObject *
50500: NewFunction(JSContext *cx, JSObject *parent)
50450: {
55746:     return detail::NewObject<WithProto::Class, true>(cx, &js_FunctionClass, NULL, parent,
55746:                                                      gc::FINALIZE_OBJECT2);
55746: }
55746: 
55746: template <WithProto::e withProto>
55746: static JS_ALWAYS_INLINE JSObject *
55746: NewNonFunction(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
55746:                gc::FinalizeKind kind)
55746: {
55746:     return detail::NewObject<withProto, false>(cx, clasp, proto, parent, kind);
50450: }
50450: 
50450: template <WithProto::e withProto>
50450: static JS_ALWAYS_INLINE JSObject *
50450: NewNonFunction(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent)
50450: {
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(JSCLASS_RESERVED_SLOTS(clasp));
55746:     return detail::NewObject<withProto, false>(cx, clasp, proto, parent, kind);
55746: }
55746: 
55746: template <WithProto::e withProto>
55746: static JS_ALWAYS_INLINE JSObject *
55746: NewObject(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent,
55746:           gc::FinalizeKind kind)
55746: {
55746:     if (clasp == &js_FunctionClass)
55746:         return detail::NewObject<withProto, true>(cx, clasp, proto, parent, kind);
55746:     return detail::NewObject<withProto, false>(cx, clasp, proto, parent, kind);
50450: }
50450: 
50450: template <WithProto::e withProto>
50450: static JS_ALWAYS_INLINE JSObject *
48470: NewObject(JSContext *cx, js::Class *clasp, JSObject *proto, JSObject *parent)
40858: {
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(JSCLASS_RESERVED_SLOTS(clasp));
55746:     return NewObject<withProto>(cx, clasp, proto, parent, kind);
55746: }
55746: 
55746: /*
55746:  * As for js_GetGCObjectKind, where numSlots is a guess at the final size of
55746:  * the object, zero if the final size is unknown.
55746:  */
55746: static inline gc::FinalizeKind
55746: GuessObjectGCKind(size_t numSlots, bool isArray)
55746: {
55746:     if (numSlots)
55746:         return gc::GetGCObjectKind(numSlots);
55746:     return isArray ? gc::FINALIZE_OBJECT8 : gc::FINALIZE_OBJECT4;
55746: }
55746: 
55746: /*
55746:  * Get the GC kind to use for scripted 'new' on the given class.
55746:  * FIXME bug 547327: estimate the size from the allocation site.
55746:  */
55746: static inline gc::FinalizeKind
55746: NewObjectGCKind(JSContext *cx, js::Class *clasp)
55746: {
55746:     if (clasp == &js_ArrayClass || clasp == &js_SlowArrayClass)
55746:         return gc::FINALIZE_OBJECT8;
55746:     if (clasp == &js_FunctionClass)
55746:         return gc::FINALIZE_OBJECT2;
55746:     return gc::FINALIZE_OBJECT4;
40858: }
40858: 
58056: /* Make an object with pregenerated shape from a NEWOBJECT bytecode. */
58056: static inline JSObject *
58056: CopyInitializerObject(JSContext *cx, JSObject *baseobj)
58056: {
58056:     JS_ASSERT(baseobj->getClass() == &js_ObjectClass);
58056:     JS_ASSERT(!baseobj->inDictionaryMode());
58056: 
58534:     gc::FinalizeKind kind = gc::FinalizeKind(baseobj->finalizeKind());
58056:     JSObject *obj = NewBuiltinClassInstance(cx, &js_ObjectClass, kind);
58056: 
58056:     if (!obj || !obj->ensureSlots(cx, baseobj->numSlots()))
58056:         return NULL;
58056: 
58056:     obj->flags = baseobj->flags;
58056:     obj->lastProp = baseobj->lastProp;
58056:     obj->objShape = baseobj->objShape;
58056: 
58056:     return obj;
58056: }
58056: 
47497: } /* namespace js */
40388: 
35117: #endif /* jsobjinlines_h___ */
