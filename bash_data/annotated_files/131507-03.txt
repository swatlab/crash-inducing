131499: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-*/
131499: /* This Source Code Form is subject to the terms of the Mozilla Public
131499:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
131499:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
131499: 
131499: #include "AudioNodeStream.h"
131499: 
131499: #include "MediaStreamGraphImpl.h"
131499: #include "AudioNodeEngine.h"
131499: 
131499: using namespace mozilla::dom;
131499: 
131499: namespace mozilla {
131499: 
131499: /**
131499:  * An AudioNodeStream produces a single audio track with ID
131499:  * AUDIO_NODE_STREAM_TRACK_ID. This track has rate IdealAudioRate().
131499:  * Each chunk in the track is a single block of WEBAUDIO_BLOCK_SIZE samples.
131499:  */
131499: static const int AUDIO_NODE_STREAM_TRACK_ID = 1;
131499: 
131499: AudioNodeStream::~AudioNodeStream()
131499: {
131499: }
131499: 
131499: void
131499: AudioNodeStream::SetStreamTimeParameter(uint32_t aIndex, MediaStream* aRelativeToStream,
131499:                                         double aStreamTime)
131499: {
131499:   class Message : public ControlMessage {
131499:   public:
131499:     Message(AudioNodeStream* aStream, uint32_t aIndex, MediaStream* aRelativeToStream,
131499:             double aStreamTime)
131499:       : ControlMessage(aStream), mStreamTime(aStreamTime),
131499:         mRelativeToStream(aRelativeToStream), mIndex(aIndex) {}
131499:     virtual void Run()
131499:     {
131499:       static_cast<AudioNodeStream*>(mStream)->
131499:           SetStreamTimeParameterImpl(mIndex, mRelativeToStream, mStreamTime);
131499:     }
131499:     double mStreamTime;
131499:     MediaStream* mRelativeToStream;
131499:     uint32_t mIndex;
131499:   };
131499: 
131499:   MOZ_ASSERT(this);
131499:   GraphImpl()->AppendMessage(new Message(this, aIndex, aRelativeToStream, aStreamTime));
131499: }
131499: 
131499: void
131499: AudioNodeStream::SetStreamTimeParameterImpl(uint32_t aIndex, MediaStream* aRelativeToStream,
131499:                                             double aStreamTime)
131499: {
131499:   StreamTime streamTime = std::max<MediaTime>(0, SecondsToMediaTime(aStreamTime));
131499:   GraphTime graphTime = aRelativeToStream->StreamTimeToGraphTime(streamTime);
131499:   StreamTime thisStreamTime = GraphTimeToStreamTimeOptimistic(graphTime);
131499:   TrackTicks ticks = TimeToTicksRoundDown(IdealAudioRate(), thisStreamTime);
131499:   mEngine->SetStreamTimeParameter(aIndex, ticks);
131499: }
131499: 
131499: void
131499: AudioNodeStream::SetDoubleParameter(uint32_t aIndex, double aValue)
131499: {
131499:   class Message : public ControlMessage {
131499:   public:
131499:     Message(AudioNodeStream* aStream, uint32_t aIndex, double aValue)
131499:       : ControlMessage(aStream), mValue(aValue), mIndex(aIndex) {}
131499:     virtual void Run()
131499:     {
131499:       static_cast<AudioNodeStream*>(mStream)->Engine()->
131499:           SetDoubleParameter(mIndex, mValue);
131499:     }
131499:     double mValue;
131499:     uint32_t mIndex;
131499:   };
131499: 
131499:   MOZ_ASSERT(this);
131499:   GraphImpl()->AppendMessage(new Message(this, aIndex, aValue));
131499: }
131499: 
131499: void
131499: AudioNodeStream::SetInt32Parameter(uint32_t aIndex, int32_t aValue)
131499: {
131499:   class Message : public ControlMessage {
131499:   public:
131499:     Message(AudioNodeStream* aStream, uint32_t aIndex, int32_t aValue)
131499:       : ControlMessage(aStream), mValue(aValue), mIndex(aIndex) {}
131499:     virtual void Run()
131499:     {
131499:       static_cast<AudioNodeStream*>(mStream)->Engine()->
131499:           SetInt32Parameter(mIndex, mValue);
131499:     }
131499:     int32_t mValue;
131499:     uint32_t mIndex;
131499:   };
131499: 
131499:   MOZ_ASSERT(this);
131499:   GraphImpl()->AppendMessage(new Message(this, aIndex, aValue));
131499: }
131499: 
131499: void
131499: AudioNodeStream::SetBuffer(already_AddRefed<ThreadSharedFloatArrayBufferList> aBuffer)
131499: {
131499:   class Message : public ControlMessage {
131499:   public:
131499:     Message(AudioNodeStream* aStream,
131499:             already_AddRefed<ThreadSharedFloatArrayBufferList> aBuffer)
131499:       : ControlMessage(aStream), mBuffer(aBuffer) {}
131499:     virtual void Run()
131499:     {
131499:       static_cast<AudioNodeStream*>(mStream)->Engine()->
131499:           SetBuffer(mBuffer.forget());
131499:     }
131499:     nsRefPtr<ThreadSharedFloatArrayBufferList> mBuffer;
131499:   };
131499: 
131499:   MOZ_ASSERT(this);
131499:   GraphImpl()->AppendMessage(new Message(this, aBuffer));
131499: }
131499: 
131499: StreamBuffer::Track*
131499: AudioNodeStream::EnsureTrack()
131499: {
131499:   StreamBuffer::Track* track = mBuffer.FindTrack(AUDIO_NODE_STREAM_TRACK_ID);
131499:   if (!track) {
131499:     nsAutoPtr<MediaSegment> segment(new AudioSegment());
131499:     for (uint32_t j = 0; j < mListeners.Length(); ++j) {
131499:       MediaStreamListener* l = mListeners[j];
131499:       l->NotifyQueuedTrackChanges(Graph(), AUDIO_NODE_STREAM_TRACK_ID, IdealAudioRate(), 0,
131499:                                   MediaStreamListener::TRACK_EVENT_CREATED,
131499:                                   *segment);
131499:     }
131499:     track = &mBuffer.AddTrack(AUDIO_NODE_STREAM_TRACK_ID, IdealAudioRate(), 0, segment.forget());
131499:   }
131499:   return track;
131499: }
131499: 
131499: AudioChunk*
131499: AudioNodeStream::ObtainInputBlock(AudioChunk* aTmpChunk)
131499: {
131499:   uint32_t inputCount = mInputs.Length();
131499:   uint32_t outputChannelCount = 0;
131499:   nsAutoTArray<AudioChunk*,250> inputChunks;
131499:   for (uint32_t i = 0; i < inputCount; ++i) {
131499:     MediaStream* s = mInputs[i]->GetSource();
131499:     AudioNodeStream* a = s->AsAudioNodeStream();
131499:     MOZ_ASSERT(a);
131499:     if (a->IsFinishedOnGraphThread()) {
131499:       continue;
131499:     }
131499:     AudioChunk* chunk = a->mLastChunk;
131499:     // XXX when we implement DelayNode, this will no longer be true and we'll
131499:     // need to treat a null chunk (when the DelayNode hasn't had a chance
131499:     // to produce data yet) as silence here.
131499:     MOZ_ASSERT(chunk);
131499:     if (chunk->IsNull()) {
131499:       continue;
131499:     }
131499: 
131499:     inputChunks.AppendElement(chunk);
131499:     outputChannelCount =
131499:       GetAudioChannelsSuperset(outputChannelCount, chunk->mChannelData.Length());
131499:   }
131499: 
131499:   uint32_t inputChunkCount = inputChunks.Length();
131499:   if (inputChunkCount == 0) {
131499:     aTmpChunk->SetNull(WEBAUDIO_BLOCK_SIZE);
131499:     return aTmpChunk;
131499:   }
131499: 
131499:   if (inputChunkCount == 1) {
131499:     return inputChunks[0];
131499:   }
131499: 
131499:   AllocateAudioBlock(outputChannelCount, aTmpChunk);
131499: 
131499:   for (uint32_t i = 0; i < inputChunkCount; ++i) {
131499:     AudioChunk* chunk = inputChunks[i];
131499:     nsAutoTArray<const void*,GUESS_AUDIO_CHANNELS> channels;
131499:     channels.AppendElements(chunk->mChannelData);
131499:     if (channels.Length() < outputChannelCount) {
131499:       AudioChannelsUpMix(&channels, outputChannelCount, nullptr);
131499:       NS_ASSERTION(outputChannelCount == channels.Length(),
131499:                    "We called GetAudioChannelsSuperset to avoid this");
131499:     }
131499: 
131499:     for (uint32_t c = 0; c < channels.Length(); ++c) {
131499:       const float* inputData = static_cast<const float*>(channels[c]);
131499:       float* outputData = static_cast<float*>(const_cast<void*>(aTmpChunk->mChannelData[c]));
131499:       if (inputData) {
131499:         if (i == 0) {
131499:           AudioBlockCopyChannelWithScale(inputData, chunk->mVolume, outputData);
131499:         } else {
131499:           AudioBlockAddChannelWithScale(inputData, chunk->mVolume, outputData);
131499:         }
131499:       } else {
131499:         if (i == 0) {
131499:           memset(outputData, 0, WEBAUDIO_BLOCK_SIZE*sizeof(float));
131499:         }
131499:       }
131499:     }
131499:   }
131499: 
131499:   return aTmpChunk;
131499: }
131499: 
131499: // The MediaStreamGraph guarantees that this is actually one block, for
131499: // AudioNodeStreams.
131499: void
131499: AudioNodeStream::ProduceOutput(GraphTime aFrom, GraphTime aTo)
131499: {
131499:   StreamBuffer::Track* track = EnsureTrack();
131499: 
131499:   AudioChunk outputChunk;
131499:   AudioSegment* segment = track->Get<AudioSegment>();
131499: 
131499:   if (mInCycle) {
131499:     // XXX DelayNode not supported yet so just produce silence
131499:     outputChunk.SetNull(WEBAUDIO_BLOCK_SIZE);
131499:   } else {
131499:     AudioChunk tmpChunk;
131499:     AudioChunk* inputChunk = ObtainInputBlock(&tmpChunk);
131499:     bool finished = false;
131499:     mEngine->ProduceAudioBlock(this, *inputChunk, &outputChunk, &finished);
131499:     if (finished) {
131499:       FinishOutput();
131499:     }
131499:   }
131499: 
131499:   mLastChunk = segment->AppendAndConsumeChunk(&outputChunk);
131499: 
131499:   for (uint32_t j = 0; j < mListeners.Length(); ++j) {
131499:     MediaStreamListener* l = mListeners[j];
131499:     AudioChunk copyChunk = *mLastChunk;
131499:     AudioSegment tmpSegment;
131499:     tmpSegment.AppendAndConsumeChunk(&copyChunk);
131499:     l->NotifyQueuedTrackChanges(Graph(), AUDIO_NODE_STREAM_TRACK_ID,
131499:                                 IdealAudioRate(), segment->GetDuration(), 0,
131499:                                 tmpSegment);
131499:   }
131499: }
131499: 
131499: TrackTicks
131499: AudioNodeStream::GetCurrentPosition()
131499: {
131499:   return EnsureTrack()->Get<AudioSegment>()->GetDuration();
131499: }
131499: 
131499: void
131499: AudioNodeStream::FinishOutput()
131499: {
131499:   if (IsFinishedOnGraphThread()) {
131499:     return;
131499:   }
131499: 
131499:   StreamBuffer::Track* track = EnsureTrack();
131499:   track->SetEnded();
131499:   FinishOnGraphThread();
131499: 
131499:   for (uint32_t j = 0; j < mListeners.Length(); ++j) {
131499:     MediaStreamListener* l = mListeners[j];
131499:     AudioSegment emptySegment;
131499:     l->NotifyQueuedTrackChanges(Graph(), AUDIO_NODE_STREAM_TRACK_ID,
131499:                                 IdealAudioRate(),
131499:                                 track->GetSegment()->GetDuration(),
131499:                                 MediaStreamListener::TRACK_EVENT_ENDED, emptySegment);
131499:   }
131499: }
131499: 
131499: }
