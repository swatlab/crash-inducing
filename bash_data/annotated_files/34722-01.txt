26627: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
26627:  * ***** BEGIN LICENSE BLOCK *****
26627:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
26627:  *
26627:  * The contents of this file are subject to the Mozilla Public License Version
26627:  * 1.1 (the "License"); you may not use this file except in compliance with
26627:  * the License. You may obtain a copy of the License at
26627:  * http://www.mozilla.org/MPL/
26627:  *
26627:  * Software distributed under the License is distributed on an "AS IS" basis,
26627:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
26627:  * for the specific language governing rights and limitations under the
26627:  * License.
26627:  *
26627:  * The Original Code is Mozilla Corporation code.
26627:  *
26627:  * The Initial Developer of the Original Code is Mozilla Corporation.
26627:  * Portions created by the Initial Developer are Copyright (C) 2006-2009
26627:  * the Initial Developer. All Rights Reserved.
26627:  *
26627:  * Contributor(s):
26627:  *   Vladimir Vukicevic <vladimir@pobox.com>
26627:  *   Masayuki Nakano <masayuki@d-toybox.com>
26627:  *   John Daggett <jdaggett@mozilla.com>
26627:  *   Jonathan Kew <jfkthame@gmail.com>
26627:  *
26627:  * Alternatively, the contents of this file may be used under the terms of
26627:  * either the GNU General Public License Version 2 or later (the "GPL"), or
26627:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
26627:  * in which case the provisions of the GPL or the LGPL are applicable instead
26627:  * of those above. If you wish to allow use of your version of this file only
26627:  * under the terms of either the GPL or the LGPL, and not to allow others to
26627:  * use your version of this file under the terms of the MPL, indicate your
26627:  * decision by deleting the provisions above and replace them with the notice
26627:  * and other provisions required by the GPL or the LGPL. If you do not delete
26627:  * the provisions above, a recipient may use your version of this file under
26627:  * the terms of any one of the MPL, the GPL or the LGPL.
26627:  *
26627:  * ***** END LICENSE BLOCK ***** */
26627: 
26627: #include "prtypes.h"
26627: #include "prmem.h"
26627: #include "nsString.h"
26627: #include "nsBidiUtils.h"
26627: 
26627: #include "gfxTypes.h"
26627: 
26627: #include "nsPromiseFlatString.h"
26627: 
26627: #include "gfxContext.h"
26627: #include "gfxPlatform.h"
26627: #include "gfxPlatformMac.h"
26627: #include "gfxCoreTextFonts.h"
26627: 
26627: #include "gfxFontTest.h"
26627: #include "gfxFontUtils.h"
26627: 
26627: #include "cairo-quartz.h"
26627: 
26627: #include "gfxQuartzSurface.h"
31590: #include "gfxMacPlatformFontList.h"
26627: #include "gfxUserFontSet.h"
26627: 
26627: #include "nsUnicodeRange.h"
26627: 
26627: // Uncomment this to dump all text runs created to the log (if enabled)
26627: //#define DUMP_TEXT_RUNS
26627: 
26627: #ifdef DUMP_TEXT_RUNS
26627: static PRLogModuleInfo *gCoreTextTextRunLog = PR_NewLogModule("coreTextTextRun");
26627: #endif
26627: 
26627: #define ROUND(x) (floor((x) + 0.5))
26627: 
26627: 
26627: // standard font descriptors that we construct the first time they're needed
26627: CTFontDescriptorRef gfxCoreTextFont::sDefaultFeaturesDescriptor = NULL;
26627: CTFontDescriptorRef gfxCoreTextFont::sDisableLigaturesDescriptor = NULL;
26627: 
30358: #ifdef DEBUG_jonathan
30358: static void dumpFontDescCallback(const void *key, const void *value, void *context)
30358: {
30358:     CFStringRef attribute = (CFStringRef)key;
30358:     CFTypeRef setting = (CFTypeRef)value;
30358:     fprintf(stderr, "attr: "); CFShow(attribute);
30358:     fprintf(stderr, "    = "); CFShow(setting);
30358:     fprintf(stderr, "\n");
30358: }
30358: 
30358: static void
30358: dumpFontDescriptor(CTFontRef font)
30358: {
30358:     CTFontDescriptorRef desc = CTFontCopyFontDescriptor(font);
30358:     CFDictionaryRef dict = CTFontDescriptorCopyAttributes(desc);
30358:     CFRelease(desc);
30358:     CFDictionaryApplyFunction(dict, &dumpFontDescCallback, 0);
30358:     CFRelease(dict);
30358: }
30358: #endif
26627: 
26627: gfxCoreTextFont::gfxCoreTextFont(MacOSFontEntry *aFontEntry,
26627:                                  const gfxFontStyle *aFontStyle,
26627:                                  PRBool aNeedsBold)
26627:     : gfxFont(aFontEntry, aFontStyle),
26627:       mFontStyle(aFontStyle),
34722:       mCTFont(nsnull),
34722:       mAttributesDict(nsnull),
26627:       mHasMetrics(PR_FALSE),
34722:       mFontFace(nsnull),
34722:       mScaledFont(nsnull),
26627:       mAdjustedSize(0.0f)
26627: {
26627:     mATSFont = aFontEntry->GetFontRef();
26627: 
26627:     // determine whether synthetic bolding is needed
26627:     PRInt8 baseWeight, weightDistance;
26627:     mFontStyle->ComputeWeightAndOffset(&baseWeight, &weightDistance);
26627:     PRUint16 targetWeight = (baseWeight * 100) + (weightDistance * 100);
26627: 
26627:     // synthetic bolding occurs when font itself is not a bold-face and either the absolute weight
26627:     // is at least 600 or the relative weight (e.g. 402) implies a darker face than the ones available.
26627:     // note: this means that (1) lighter styles *never* synthetic bold and (2) synthetic bolding always occurs
26627:     // at the first bolder step beyond available faces, no matter how light the boldest face
26627:     if (!aFontEntry->IsBold()
26627:         && ((weightDistance == 0 && targetWeight >= 600) || (weightDistance > 0 && aNeedsBold)))
26627:     {
26627:         mSyntheticBoldOffset = 1;  // devunit offset when double-striking text to fake boldness
26627:     }
26627: 
26627:     // InitMetrics will create the mCTFont (possibly taking account of sizeAdjust)
26627:     InitMetrics();
26627:     if (!mIsValid) {
26627:         return;
26627:     }
26627: 
26627:     // Set up the default attribute dictionary that we will need each time we create a CFAttributedString
26627:     mAttributesDict =
26627:         CFDictionaryCreate(kCFAllocatorDefault,
26627:                            (const void**) &kCTFontAttributeName,
26627:                            (const void**) &mCTFont,
26627:                            1, // count of attributes
26627:                            &kCFTypeDictionaryKeyCallBacks,
26627:                            &kCFTypeDictionaryValueCallBacks);
26627: 
26627:     // Remaining initialization is largely based on CommonInit() in the gfxAtsuiFont code
27622:     CGFontRef cgFont = ::CGFontCreateWithPlatformFont(&mATSFont);
27622:     mFontFace = cairo_quartz_font_face_create_for_cgfont(cgFont);
27622:     ::CGFontRelease(cgFont);
26627: 
34722:     cairo_status_t cairoerr = cairo_font_face_status(mFontFace);
34722:     if (cairoerr != CAIRO_STATUS_SUCCESS) {
34722:         mIsValid = PR_FALSE;
34722: #ifdef DEBUG
34722:         char warnBuf[1024];
34722:         sprintf(warnBuf, "Failed to create Cairo font face: %s status: %d",
34722:                 NS_ConvertUTF16toUTF8(GetName()).get(), cairoerr);
34722:         NS_WARNING(warnBuf);
34722: #endif
34722:         return;
34722:     }
34722: 
26627:     cairo_matrix_t sizeMatrix, ctm;
26627:     cairo_matrix_init_identity(&ctm);
26627:     cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
26627: 
26627:     // synthetic oblique by skewing via the font matrix
26627:     PRBool needsOblique =
26627:         (mFontEntry != NULL) &&
26627:         (!mFontEntry->IsItalic() && (mFontStyle->style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)));
26627: 
26627:     if (needsOblique) {
26627:         double skewfactor = (needsOblique ? Fix2X(kATSItalicQDSkew) : 0);
26627: 
26627:         cairo_matrix_t style;
26627:         cairo_matrix_init(&style,
26627:                           1,                //xx
26627:                           0,                //yx
26627:                           -1 * skewfactor,   //xy
26627:                           1,                //yy
26627:                           0,                //x0
26627:                           0);               //y0
26627:         cairo_matrix_multiply(&sizeMatrix, &sizeMatrix, &style);
26627:     }
26627: 
26627:     cairo_font_options_t *fontOptions = cairo_font_options_create();
34722:     // if this fails (out of memory), the pointer is still safe to use
34722:     // although we're almost certainly going to fail below anyway
26627: 
26627:     // turn off font anti-aliasing based on user pref setting
26627:     if (mAdjustedSize <= (float) gfxPlatformMac::GetPlatform()->GetAntiAliasingThreshold()) {
26627:         cairo_font_options_set_antialias(fontOptions, CAIRO_ANTIALIAS_NONE);
26627:         //printf("font: %s, size: %f, disabling anti-aliasing\n", NS_ConvertUTF16toUTF8(GetName()).get(), mAdjustedSize);
26627:     }
26627: 
26627:     mScaledFont = cairo_scaled_font_create(mFontFace, &sizeMatrix, &ctm, fontOptions);
26627:     cairo_font_options_destroy(fontOptions);
26627: 
34722:     cairoerr = cairo_scaled_font_status(mScaledFont);
26627:     if (cairoerr != CAIRO_STATUS_SUCCESS) {
26627:         mIsValid = PR_FALSE;
26627: #ifdef DEBUG
26627:         char warnBuf[1024];
34722:         sprintf(warnBuf, "Failed to create scaled font: %s status: %d",
34722:                 NS_ConvertUTF16toUTF8(GetName()).get(), cairoerr);
26627:         NS_WARNING(warnBuf);
26627: #endif
26627:     }
26627: }
26627: 
26627: static double
26627: RoundToNearestMultiple(double aValue, double aFraction)
26627: {
26627:   return floor(aValue/aFraction + 0.5)*aFraction;
26627: }
26627: 
26627: PRBool
26627: gfxCoreTextFont::SetupCairoFont(gfxContext *aContext)
26627: {
26627:     cairo_scaled_font_t *scaledFont = CairoScaledFont();
26627:     if (cairo_scaled_font_status(scaledFont) != CAIRO_STATUS_SUCCESS) {
26627:         // Don't cairo_set_scaled_font as that would propagate the error to
26627:         // the cairo_t, precluding any further drawing.
26627:         return PR_FALSE;
26627:     }
26627:     cairo_set_scaled_font(aContext->GetCairo(), scaledFont);
26627:     return PR_TRUE;
26627: }
26627: 
26627: float
26627: gfxCoreTextFont::GetCharWidth(PRUnichar aUniChar, PRUint32 *aGlyphID)
26627: {
26627:     UniChar c = aUniChar;
26627:     CGGlyph glyph;
26627:     if (CTFontGetGlyphsForCharacters(mCTFont, &c, &glyph, 1)) {
26627:         CGSize advance;
26627:         CTFontGetAdvancesForGlyphs(mCTFont,
26627:                                    kCTFontHorizontalOrientation,
26627:                                    &glyph,
26627:                                    &advance,
26627:                                    1);
26627:         if (aGlyphID != nsnull)
26627:             *aGlyphID = glyph;
26627:         return advance.width;
26627:     }
26627: 
26627:     // couldn't get glyph for the char
26627:     if (aGlyphID != nsnull)
26627:         *aGlyphID = 0;
26627:     return 0;
26627: }
26627: 
26627: float
26627: gfxCoreTextFont::GetCharHeight(PRUnichar aUniChar)
26627: {
26627:     UniChar c = aUniChar;
26627:     CGGlyph glyph;
26627:     if (CTFontGetGlyphsForCharacters(mCTFont, &c, &glyph, 1)) {
26627:         CGRect boundingRect;
26627:         CTFontGetBoundingRectsForGlyphs(mCTFont,
26627:                                         kCTFontHorizontalOrientation,
26627:                                         &glyph,
26627:                                         &boundingRect,
26627:                                         1);
26627:         return boundingRect.size.height;
26627:     }
26627: 
26627:     // couldn't get glyph for the char
26627:     return 0;
26627: }
26627: 
26627: gfxCoreTextFont::~gfxCoreTextFont()
26627: {
34722:     if (mScaledFont)
26627:         cairo_scaled_font_destroy(mScaledFont);
34722:     if (mFontFace)
26627:         cairo_font_face_destroy(mFontFace);
26627: 
34722:     if (mAttributesDict)
26627:         CFRelease(mAttributesDict);
34722:     if (mCTFont)
26627:         CFRelease(mCTFont);
26627: }
26627: 
26627: MacOSFontEntry*
26627: gfxCoreTextFont::GetFontEntry()
26627: {
26627:     return static_cast<MacOSFontEntry*>(mFontEntry.get());
26627: }
26627: 
26627: PRBool
26627: gfxCoreTextFont::TestCharacterMap(PRUint32 aCh)
26627: {
26627:     return mIsValid && GetFontEntry()->TestCharacterMap(aCh);
26627: }
26627: 
26627: void
26627: gfxCoreTextFont::InitMetrics()
26627: {
26627:     if (mHasMetrics)
26627:         return;
26627: 
26627:     gfxFloat size =
26627:         PR_MAX(((mAdjustedSize != 0.0f) ? mAdjustedSize : GetStyle()->size), 1.0f);
26627: 
26627:     if (mCTFont != NULL) {
26627:         CFRelease(mCTFont);
26627:         mCTFont = NULL;
26627:     }
26627: 
26627:     ATSFontMetrics atsMetrics;
26627:     OSStatus err;
26627: 
26627:     err = ATSFontGetHorizontalMetrics(mATSFont, kATSOptionFlagsDefault,
26627:                                       &atsMetrics);
26627:     if (err != noErr) {
26627:         mIsValid = PR_FALSE;
26627: 
26627: #ifdef DEBUG
26627:         char warnBuf[1024];
26627:         sprintf(warnBuf, "Bad font metrics for: %s err: %8.8x",
26627:                 NS_ConvertUTF16toUTF8(GetName()).get(), PRUint32(err));
26627:         NS_WARNING(warnBuf);
26627: #endif
26627:         return;
26627:     }
26627: 
26627:     // prefer to get xHeight from ATS metrics (unhinted) rather than Core Text (hinted),
26627:     // see bug 429605.
26627:     if (atsMetrics.xHeight > 0) {
26627:         mMetrics.xHeight = atsMetrics.xHeight * size;
26627:     } else {
26627:         mCTFont = CTFontCreateWithPlatformFont(mATSFont, size, NULL, GetDefaultFeaturesDescriptor());
26627:         mMetrics.xHeight = CTFontGetXHeight(mCTFont);
26627:     }
26627: 
26627:     if (mAdjustedSize == 0.0f) {
26627:         if (mMetrics.xHeight != 0.0f && GetStyle()->sizeAdjust != 0.0f) {
26627:             gfxFloat aspect = mMetrics.xHeight / size;
26627:             mAdjustedSize = GetStyle()->GetAdjustedSize(aspect);
26627: 
26627:             // the recursive call to InitMetrics will re-create mCTFont, with adjusted size,
26627:             // and then continue to set up the rest of the metrics fields
26627:             InitMetrics();
26627:             return;
26627:         }
26627:         mAdjustedSize = size;
26627:     }
26627: 
26627:     // create the CTFontRef if we didn't already do so above
26627:     if (mCTFont == NULL)
26627:         mCTFont = CTFontCreateWithPlatformFont(mATSFont, size, NULL, GetDefaultFeaturesDescriptor());
26627: 
26627:     mMetrics.superscriptOffset = mMetrics.xHeight;
26627:     mMetrics.subscriptOffset = mMetrics.xHeight;
26627:     mMetrics.underlineSize = CTFontGetUnderlineThickness(mCTFont);
26627:     mMetrics.underlineOffset = CTFontGetUnderlinePosition(mCTFont);
26627:     mMetrics.strikeoutSize = mMetrics.underlineSize;
26627:     mMetrics.strikeoutOffset = mMetrics.xHeight / 2;
26627: 
26627:     mMetrics.externalLeading = CTFontGetLeading(mCTFont);
26627:     mMetrics.emHeight = size;
26627: //    mMetrics.maxAscent = CTFontGetAscent(mCTFont);
26627: //    mMetrics.maxDescent = CTFontGetDescent(mCTFont);
26627:     // using the ATS metrics rather than CT gives us results more consistent with the ATSUI path
26627:     mMetrics.maxAscent =
26627:       NS_ceil(RoundToNearestMultiple(atsMetrics.ascent * size, 1/1024.0));
26627:     mMetrics.maxDescent =
26627:       NS_ceil(-RoundToNearestMultiple(atsMetrics.descent * size, 1/1024.0));
26627: 
26627:     mMetrics.maxHeight = mMetrics.maxAscent + mMetrics.maxDescent;
26627:     if (mMetrics.maxHeight - mMetrics.emHeight > 0.0)
26627:         mMetrics.internalLeading = mMetrics.maxHeight - mMetrics.emHeight;
26627:     else
26627:         mMetrics.internalLeading = 0.0;
26627: 
26627:     mMetrics.maxAdvance = atsMetrics.maxAdvanceWidth * size + mSyntheticBoldOffset;
26627: 
26627:     mMetrics.emAscent = mMetrics.maxAscent * mMetrics.emHeight / mMetrics.maxHeight;
26627:     mMetrics.emDescent = mMetrics.emHeight - mMetrics.emAscent;
26627: 
26627:     PRUint32 glyphID;
26627:     float xWidth = GetCharWidth('x', &glyphID);
26627:     if (atsMetrics.avgAdvanceWidth != 0.0)
26627:         mMetrics.aveCharWidth = PR_MIN(atsMetrics.avgAdvanceWidth * size, xWidth);
26627:     else if (glyphID != 0)
26627:         mMetrics.aveCharWidth = xWidth;
26627:     else
26627:         mMetrics.aveCharWidth = mMetrics.maxAdvance;
26627:     mMetrics.aveCharWidth += mSyntheticBoldOffset;
26627: 
26627:     if (GetFontEntry()->IsFixedPitch()) {
26627:         // Some Quartz fonts are fixed pitch, but there's some glyph with a bigger
26627:         // advance than the average character width... this forces
26627:         // those fonts to be recognized like fixed pitch fonts by layout.
26627:         mMetrics.maxAdvance = mMetrics.aveCharWidth;
26627:     }
26627: 
26627:     mMetrics.spaceWidth = GetCharWidth(' ', &glyphID);
26627:     mSpaceGlyph = glyphID;
26627: 
26627:     mMetrics.zeroOrAveCharWidth = GetCharWidth('0', &glyphID);
26627:     if (glyphID == 0)
26627:         mMetrics.zeroOrAveCharWidth = mMetrics.aveCharWidth;
26627: 
26627:     mHasMetrics = PR_TRUE;
26627: 
26627:     SanitizeMetrics(&mMetrics, GetFontEntry()->mIsBadUnderlineFont);
26627: 
26627: #if 0
26627:     fprintf (stderr, "Font: %p (%s) size: %f\n", this,
26627:              NS_ConvertUTF16toUTF8(GetName()).get(), mStyle.size);
26627: //    fprintf (stderr, "    fbounds.origin.x %f y %f size.width %f height %f\n", fbounds.origin.x, fbounds.origin.y, fbounds.size.width, fbounds.size.height);
26627:     fprintf (stderr, "    emHeight: %f emAscent: %f emDescent: %f\n", mMetrics.emHeight, mMetrics.emAscent, mMetrics.emDescent);
26627:     fprintf (stderr, "    maxAscent: %f maxDescent: %f maxAdvance: %f\n", mMetrics.maxAscent, mMetrics.maxDescent, mMetrics.maxAdvance);
26627:     fprintf (stderr, "    internalLeading: %f externalLeading: %f\n", mMetrics.internalLeading, mMetrics.externalLeading);
26627:     fprintf (stderr, "    spaceWidth: %f aveCharWidth: %f xHeight: %f\n", mMetrics.spaceWidth, mMetrics.aveCharWidth, mMetrics.xHeight);
26627:     fprintf (stderr, "    uOff: %f uSize: %f stOff: %f stSize: %f suOff: %f suSize: %f\n", mMetrics.underlineOffset, mMetrics.underlineSize, mMetrics.strikeoutOffset, mMetrics.strikeoutSize, mMetrics.superscriptOffset, mMetrics.subscriptOffset);
26627: #endif
26627: }
26627: 
26627: // Construct the font attribute descriptor that we'll apply by default when creating a CTFontRef.
26627: // This will turn off line-edge swashes by default, because we don't know the actual line breaks
26627: // when doing glyph shaping.
26627: void
26627: gfxCoreTextFont::CreateDefaultFeaturesDescriptor()
26627: {
26627:     if (sDefaultFeaturesDescriptor != NULL)
26627:         return;
26627: 
26627:     SInt16 val = kSmartSwashType;
26627:     CFNumberRef swashesType =
26627:         CFNumberCreate(kCFAllocatorDefault,
26627:                        kCFNumberSInt16Type,
26627:                        &val);
26627:     val = kLineInitialSwashesOffSelector;
26627:     CFNumberRef lineInitialsOffSelector =
26627:         CFNumberCreate(kCFAllocatorDefault,
26627:                        kCFNumberSInt16Type,
26627:                        &val);
26627: 
26627:     CFTypeRef keys[]   = { kCTFontFeatureTypeIdentifierKey,
26627:                            kCTFontFeatureSelectorIdentifierKey };
26627:     CFTypeRef values[] = { swashesType,
26627:                            lineInitialsOffSelector };
26627:     CFDictionaryRef featureSettings[2];
26627:     featureSettings[0] =
26627:         CFDictionaryCreate(kCFAllocatorDefault,
26627:                            (const void **) keys,
26627:                            (const void **) values,
26627:                            NS_ARRAY_LENGTH(keys),
26627:                            &kCFTypeDictionaryKeyCallBacks,
26627:                            &kCFTypeDictionaryValueCallBacks);
26627:     CFRelease(lineInitialsOffSelector);
26627: 
26627:     val = kLineFinalSwashesOffSelector;
26627:     CFNumberRef lineFinalsOffSelector =
26627:         CFNumberCreate(kCFAllocatorDefault,
26627:                        kCFNumberSInt16Type,
26627:                        &val);
26627:     values[1] = lineFinalsOffSelector;
26627:     featureSettings[1] =
26627:         CFDictionaryCreate(kCFAllocatorDefault,
26627:                            (const void **) keys,
26627:                            (const void **) values,
26627:                            NS_ARRAY_LENGTH(keys),
26627:                            &kCFTypeDictionaryKeyCallBacks,
26627:                            &kCFTypeDictionaryValueCallBacks);
26627:     CFRelease(lineFinalsOffSelector);
26627:     CFRelease(swashesType);
26627: 
26627:     CFArrayRef featuresArray =
26627:         CFArrayCreate(kCFAllocatorDefault,
26627:                       (const void **) featureSettings,
26627:                       NS_ARRAY_LENGTH(featureSettings),
26627:                       &kCFTypeArrayCallBacks);
26627:     CFRelease(featureSettings[0]);
26627:     CFRelease(featureSettings[1]);
26627: 
26627:     const CFTypeRef attrKeys[]   = { kCTFontFeatureSettingsAttribute };
26627:     const CFTypeRef attrValues[] = { featuresArray };
26627:     CFDictionaryRef attributesDict =
26627:         CFDictionaryCreate(kCFAllocatorDefault,
26627:                            (const void **) attrKeys,
26627:                            (const void **) attrValues,
26627:                            NS_ARRAY_LENGTH(attrKeys),
26627:                            &kCFTypeDictionaryKeyCallBacks,
26627:                            &kCFTypeDictionaryValueCallBacks);
26627:     CFRelease(featuresArray);
26627: 
26627:     sDefaultFeaturesDescriptor =
26627:         CTFontDescriptorCreateWithAttributes(attributesDict);
26627:     CFRelease(attributesDict);
26627: }
26627: 
30358: // Create a CTFontRef for an ATS font ref, with the Common Ligatures feature disabled [static]
26627: CTFontRef
30358: gfxCoreTextFont::CreateCTFontWithDisabledLigatures(ATSFontRef aFontRef, CGFloat aSize)
26627: {
26627:     if (sDisableLigaturesDescriptor == NULL) {
26627:         // initialize cached descriptor to turn off the Common Ligatures feature
26627:         SInt16 val = kLigaturesType;
26627:         CFNumberRef ligaturesType =
26627:             CFNumberCreate(kCFAllocatorDefault,
26627:                            kCFNumberSInt16Type,
26627:                            &val);
26627:         val = kCommonLigaturesOffSelector;
26627:         CFNumberRef commonLigaturesOffSelector =
26627:             CFNumberCreate(kCFAllocatorDefault,
26627:                            kCFNumberSInt16Type,
26627:                            &val);
26627: 
26627:         const CFTypeRef keys[]   = { kCTFontFeatureTypeIdentifierKey,
26627:                                      kCTFontFeatureSelectorIdentifierKey };
26627:         const CFTypeRef values[] = { ligaturesType,
26627:                                      commonLigaturesOffSelector };
26627:         CFDictionaryRef featureSettingDict =
26627:             CFDictionaryCreate(kCFAllocatorDefault,
26627:                                (const void **) keys,
26627:                                (const void **) values,
26627:                                NS_ARRAY_LENGTH(keys),
26627:                                &kCFTypeDictionaryKeyCallBacks,
26627:                                &kCFTypeDictionaryValueCallBacks);
26627:         CFRelease(ligaturesType);
26627:         CFRelease(commonLigaturesOffSelector);
26627: 
26627:         CFArrayRef featuresArray =
26627:             CFArrayCreate(kCFAllocatorDefault,
26627:                           (const void **) &featureSettingDict,
26627:                           1,
26627:                           &kCFTypeArrayCallBacks);
26627:         CFRelease(featureSettingDict);
26627: 
26627:         CFDictionaryRef attributesDict =
26627:             CFDictionaryCreate(kCFAllocatorDefault,
26627:                                (const void **) &kCTFontFeatureSettingsAttribute,
26627:                                (const void **) &featuresArray,
26627:                                1, // count of keys & values
26627:                                &kCFTypeDictionaryKeyCallBacks,
26627:                                &kCFTypeDictionaryValueCallBacks);
26627:         CFRelease(featuresArray);
26627: 
26627:         sDisableLigaturesDescriptor =
30358:             CTFontDescriptorCreateCopyWithAttributes(GetDefaultFeaturesDescriptor(), attributesDict);
26627:         CFRelease(attributesDict);
26627:     }
26627: 
30358:     return CTFontCreateWithPlatformFont(aFontRef, aSize, NULL, sDisableLigaturesDescriptor);
26627: }
26627: 
26627: void
26627: gfxCoreTextFont::Shutdown() // [static]
26627: {
26627:     if (sDisableLigaturesDescriptor != NULL) {
26627:         CFRelease(sDisableLigaturesDescriptor);
26627:         sDisableLigaturesDescriptor = NULL;
26627:     }        
26627:     if (sDefaultFeaturesDescriptor != NULL) {
26627:         CFRelease(sDefaultFeaturesDescriptor);
26627:         sDefaultFeaturesDescriptor = NULL;
26627:     }
26627: }
26627: 
26627: 
26627: /**
26627:  * Look up the font in the gfxFont cache. If we don't find it, create one.
26627:  * In either case, add a ref and return it ---
26627:  * except for OOM in which case we do nothing and return null.
26627:  */
26627: 
26627: static already_AddRefed<gfxCoreTextFont>
26627: GetOrMakeCTFont(MacOSFontEntry *aFontEntry, const gfxFontStyle *aStyle, PRBool aNeedsBold)
26627: {
26627:     // the font entry name is the psname, not the family name
26627:     nsRefPtr<gfxFont> font = gfxFontCache::GetCache()->Lookup(aFontEntry->Name(), aStyle);
26627:     if (!font) {
26627:         gfxCoreTextFont *newFont = new gfxCoreTextFont(aFontEntry, aStyle, aNeedsBold);
26627:         if (!newFont)
26627:             return nsnull;
26627:         if (!newFont->Valid()) {
26627:             delete newFont;
26627:             return nsnull;
26627:         }
26627:         font = newFont;
26627:         gfxFontCache::GetCache()->AddNew(font);
26627:     }
26627:     gfxFont *f = nsnull;
26627:     font.swap(f);
26627:     return static_cast<gfxCoreTextFont *>(f);
26627: }
26627: 
26627: 
26627: gfxCoreTextFontGroup::gfxCoreTextFontGroup(const nsAString& families,
26627:                                            const gfxFontStyle *aStyle,
26627:                                            gfxUserFontSet *aUserFontSet)
26627:     : gfxFontGroup(families, aStyle, aUserFontSet)
26627: {
26627:     ForEachFont(FindCTFont, this);
26627: 
26627:     if (mFonts.Length() == 0) {
26627:         // XXX this will generate a list of the lang groups for which we have no
26627:         // default fonts for on the mac; we should fix this!
26627:         // Known:
26627:         // ja x-beng x-devanagari x-tamil x-geor x-ethi x-gujr x-mlym x-armn
26627:         // x-orya x-telu x-knda x-sinh
26627: 
26627:         //fprintf (stderr, "gfxCoreTextFontGroup: %s [%s] -> %d fonts found\n", NS_ConvertUTF16toUTF8(families).get(), aStyle->langGroup.get(), mFonts.Length());
26627: 
26627:         // If we get here, we most likely didn't have a default font for
26627:         // a specific langGroup.  Let's just pick the default OSX
26627:         // user font.
26627: 
26627:         PRBool needsBold;
31590:         MacOSFontEntry *defaultFont = static_cast<MacOSFontEntry*>
31590:             (gfxMacPlatformFontList::PlatformFontList()->GetDefaultFont(aStyle, needsBold));
26627:         NS_ASSERTION(defaultFont, "invalid default font returned by GetDefaultFont");
26627: 
26627:         nsRefPtr<gfxCoreTextFont> font = GetOrMakeCTFont(defaultFont, aStyle, needsBold);
26627:         if (font) {
26627:             mFonts.AppendElement(font);
26627:         }
26627:     }
26627: 
26627:     mPageLang = gfxPlatform::GetFontPrefLangFor(mStyle.langGroup.get());
26627: 
26627:     if (!mStyle.systemFont) {
26627:         for (PRUint32 i = 0; i < mFonts.Length(); ++i) {
26627:             gfxCoreTextFont* font = static_cast<gfxCoreTextFont*>(mFonts[i].get());
26627:             if (font->GetFontEntry()->mIsBadUnderlineFont) {
26627:                 gfxFloat first = mFonts[0]->GetMetrics().underlineOffset;
26627:                 gfxFloat bad = font->GetMetrics().underlineOffset;
26627:                 mUnderlineOffset = PR_MIN(first, bad);
26627:                 break;
26627:             }
26627:         }
26627:     }
26627: }
26627: 
26627: PRBool
26627: gfxCoreTextFontGroup::FindCTFont(const nsAString& aName,
26627:                                  const nsACString& aGenericName,
31590:                                  void *aClosure)
26627: {
31590:     gfxCoreTextFontGroup *fontGroup = static_cast<gfxCoreTextFontGroup*>(aClosure);
26627:     const gfxFontStyle *fontStyle = fontGroup->GetStyle();
26627: 
26627: 
26627:     PRBool needsBold;
26627:     MacOSFontEntry *fe = nsnull;
26627: 
26627:     // first, look up in the user font set
26627:     gfxUserFontSet *fs = fontGroup->GetUserFontSet();
26627:     gfxFontEntry *gfe;
26627:     if (fs && (gfe = fs->FindFontEntry(aName, *fontStyle, needsBold))) {
26627:         // assume for now platform font if not SVG
26627:         fe = static_cast<MacOSFontEntry*> (gfe);
26627:     }
26627: 
26627:     // nothing in the user font set ==> check system fonts
26627:     if (!fe) {
31590:         fe = static_cast<MacOSFontEntry*>
31590:             (gfxMacPlatformFontList::PlatformFontList()->FindFontForFamily(aName, fontStyle, needsBold));
26627:     }
26627: 
26627:     if (fe && !fontGroup->HasFont(fe->GetFontRef())) {
26627:         nsRefPtr<gfxCoreTextFont> font = GetOrMakeCTFont(fe, fontStyle, needsBold);
26627:         if (font) {
26627:             fontGroup->mFonts.AppendElement(font);
26627:         }
26627:     }
26627: 
26627:     return PR_TRUE;
26627: }
26627: 
26627: gfxFontGroup *
26627: gfxCoreTextFontGroup::Copy(const gfxFontStyle *aStyle)
26627: {
26627:     return new gfxCoreTextFontGroup(mFamilies, aStyle, mUserFontSet);
26627: }
26627: 
26627: #define UNICODE_LRO 0x202d
26627: #define UNICODE_RLO 0x202e
26627: #define UNICODE_PDF 0x202c
26627: 
26627: inline void
26627: AppendDirectionalIndicatorStart(PRUint32 aFlags, nsAString& aString)
26627: {
26627:     static const PRUnichar overrides[2] = { UNICODE_LRO, UNICODE_RLO };
26627:     aString.Append(overrides[(aFlags & gfxTextRunFactory::TEXT_IS_RTL) != 0]);    
26627:     aString.Append(' ');
26627: }
26627: 
26627: inline void
26627: AppendDirectionalIndicatorEnd(PRBool aNeedDirection, nsAString& aString)
26627: {
26627:     // append a space (always, for consistent treatment of last char,
26627:     // and a direction control if required (we skip this for 8-bit text,
26627:     // which is known to be unidirectional LTR, unless the direction was
26627:     // forced RTL via overrides)
26627:     aString.Append(' ');
26627:     if (!aNeedDirection)
26627:         return;
26627: 
26627:     aString.Append('.');
26627:     aString.Append(UNICODE_PDF);
26627: }
26627: 
26627: gfxTextRun *
26627: gfxCoreTextFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
26627:                                   const Parameters *aParams, PRUint32 aFlags)
26627: {
27157:     NS_ASSERTION(aLength > 0, "should use MakeEmptyTextRun for zero-length text");
26627:     NS_ASSERTION(aFlags & TEXT_IS_8BIT, "should be marked 8bit");
26627:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
26627:     if (!textRun)
26627:         return nsnull;
26627: 
26627:     nsDependentCSubstring cString(reinterpret_cast<const char*>(aString),
26627:                                   reinterpret_cast<const char*>(aString) + aLength);
26627: 
26627:     nsAutoString utf16;
26627:     PRBool wrapBidi = (aFlags & TEXT_IS_RTL) != 0;
26627:     if (wrapBidi)
26627:         AppendDirectionalIndicatorStart(aFlags, utf16);
26627:     PRUint32 startOffset = utf16.Length();
26627:     AppendASCIItoUTF16(cString, utf16);
26627:     AppendDirectionalIndicatorEnd(wrapBidi, utf16);
26627: 
26627:     InitTextRun(textRun, utf16.get(), utf16.Length(), startOffset, aLength);
26627: 
26627:     textRun->FetchGlyphExtents(aParams->mContext);
26627: 
26627:     return textRun;
26627: }
26627: 
26627: gfxTextRun *
26627: gfxCoreTextFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,
26627:                                   const Parameters *aParams, PRUint32 aFlags)
26627: {
27157:     NS_ASSERTION(aLength > 0, "should use MakeEmptyTextRun for zero-length text");
26627:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
26627:     if (!textRun)
26627:         return nsnull;
26627: 
26627:     gfxPlatformMac::SetupClusterBoundaries(textRun, aString);
26627: 
26627:     nsAutoString utf16;
26627:     AppendDirectionalIndicatorStart(aFlags, utf16);
26627:     PRUint32 startOffset = utf16.Length();
26627:     utf16.Append(aString, aLength);
26627:     // Ensure that none of the whitespace in the run is considered "trailing"
26627:     // by CoreText's bidi algorithm
26627:     AppendDirectionalIndicatorEnd(PR_TRUE, utf16);
26627: 
26627:     InitTextRun(textRun, utf16.get(), utf16.Length(), startOffset, aLength);
26627: 
26627:     textRun->FetchGlyphExtents(aParams->mContext);
26627: 
26627:     return textRun;
26627: }
26627: 
26627: #define SMALL_GLYPH_RUN 128 // preallocated size of our auto arrays for per-glyph data;
26627:                             // some testing indicates that 90%+ of glyph runs will fit
26627:                             // without requiring a separate allocation
26627: 
26627: void
26627: gfxCoreTextFontGroup::InitTextRun(gfxTextRun *aTextRun,
26627:                                   const PRUnichar *aString,
26627:                                   PRUint32 aTotalLength,
26627:                                   PRUint32 aLayoutStart,
26627:                                   PRUint32 aLayoutLength)
26627: {
26627:     PRBool disableLigatures = (aTextRun->GetFlags() & TEXT_DISABLE_OPTIONAL_LIGATURES) != 0;
26627: 
26627:     gfxCoreTextFont *mainFont = static_cast<gfxCoreTextFont*>(mFonts[0].get());
26627: 
26627: #ifdef DUMP_TEXT_RUNS
26627:     NS_ConvertUTF16toUTF8 str(aString, aTotalLength);
26627:     NS_ConvertUTF16toUTF8 families(mFamilies);
26627:     PR_LOG(gCoreTextTextRunLog, PR_LOG_DEBUG,\
26627:            ("MakeTextRun %p fontgroup %p (%s) lang: %s len %d TEXTRUN \"%s\" ENDTEXTRUN\n",
26627:             aTextRun, this, families.get(), mStyle.langGroup.get(), aTotalLength, str.get()));
26627: #endif
26627: 
26627:     // This is awfully verbose, but the idea is simply to create a CFAttributedString
26627:     // with our text and style info, then we can use CoreText to do layout with it
26627:     CFStringRef stringObj =
26627:         CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault,
26627:                                            aString,
26627:                                            aTotalLength,
26627:                                            kCFAllocatorNull);
26627: 
26627:     CFDictionaryRef attrObj;
26627:     if (disableLigatures) {
26627:         // For letterspacing (or maybe other situations) we need to make a copy of the CTFont
26627:         // with the ligature feature disabled
30358:         CTFontRef ctFont =
30358:             gfxCoreTextFont::CreateCTFontWithDisabledLigatures(mainFont->GetATSFont(),
30358:                                                                CTFontGetSize(mainFont->GetCTFont()));
26627: 
26627:         // Set up the initial font, for the (common) case of a monostyled textRun
26627:         attrObj =
26627:             CFDictionaryCreate(kCFAllocatorDefault,
26627:                                (const void**) &kCTFontAttributeName,
30358:                                (const void**) &ctFont,
26627:                                1, // count of attributes
26627:                                &kCFTypeDictionaryKeyCallBacks,
26627:                                &kCFTypeDictionaryValueCallBacks);
30358:         // Having created the dict, we're finished with our ligature-disabled CTFontRef
30358:         CFRelease(ctFont);
26627:     } else {
26627:         attrObj = mainFont->GetAttributesDictionary();
26627:         CFRetain(attrObj);
26627:     }
26627: 
26627:     // Now we can create an attributed string
26627:     CFAttributedStringRef attrStringObj =
26627:         CFAttributedStringCreate(kCFAllocatorDefault, stringObj, attrObj);
26627:     CFRelease(stringObj);
26627:     CFRelease(attrObj);
26627: 
26627:     // Note that the attributed string is currently not mutable;
26627:     // if we need to change attributes of a range, we'll first make a mutable copy
26627:     CFMutableAttributedStringRef mutableStringObj = NULL;
26627: 
26627:     PRUint32 runStart = aLayoutStart;
26627:     nsAutoTArray<gfxTextRange,3> fontRanges;
26627:     ComputeRanges(fontRanges, aString, runStart, runStart + aLayoutLength);
26627:     PRUint32 numRanges = fontRanges.Length();
26627: 
26627:     nsAutoTArray<PRPackedBool,SMALL_GLYPH_RUN> unmatchedArray;
26627:     PRPackedBool *unmatched = NULL;
26627: 
26627:     for (PRUint32 r = 0; r < numRanges; r++) {
26627:         const gfxTextRange& range = fontRanges[r];
26627:         UniCharCount matchedLength = range.Length();
26627:         gfxCoreTextFont *matchedFont =
26627:             static_cast<gfxCoreTextFont*> (range.font ? range.font.get() : nsnull);
26627: 
26627: #ifdef DUMP_TEXT_RUNS
26627:         PR_LOG(gCoreTextTextRunLog, PR_LOG_DEBUG,
26627:                ("InitTextRun %p fontgroup %p font %p match %s (%d-%d)", aTextRun, this, matchedFont,
26627:                    (matchedFont ? NS_ConvertUTF16toUTF8(matchedFont->GetUniqueName()).get() : "<null>"),
26627:                    runStart, matchedLength));
26627: #endif
26627: 
26627:         if (matchedFont) {
26627:             // apply the appropriate font to the run, if it's not the primary font that was already set
26627:             if (matchedFont != mainFont) {
26627:                 CTFontRef matchedCTFont = matchedFont->GetCTFont();
26627:                 if (disableLigatures)
30358:                     matchedCTFont = gfxCoreTextFont::CreateCTFontWithDisabledLigatures(matchedFont->GetATSFont(),
30358:                                                                                        CTFontGetSize(matchedCTFont));
26627:                 // if necessary, make a mutable copy of the string
26627:                 if (!mutableStringObj) {
26627:                     mutableStringObj =
26627:                         CFAttributedStringCreateMutableCopy(kCFAllocatorDefault,
26627:                                                             0,
26627:                                                             attrStringObj);
26627:                     CFRelease(attrStringObj);
26627:                 }
26627:                 CFAttributedStringSetAttribute(mutableStringObj,
26627:                                                CFRangeMake(runStart, matchedLength),
26627:                                                kCTFontAttributeName,
26627:                                                matchedCTFont);
26627:                 if (disableLigatures)
26627:                     CFRelease(matchedCTFont);
26627:             }
26627: 
27838:             aTextRun->AddGlyphRun(matchedFont, runStart-aLayoutStart, (matchedLength > 0));
26627: 
26627:         } else {
26627:             // no font available, so record missing glyph info instead
26627:             if (unmatched == NULL) {
26627:                 if (unmatchedArray.SetLength(aTotalLength)) {
26627:                     unmatched = unmatchedArray.Elements();
26627:                     memset(unmatched, PR_FALSE, aTotalLength*sizeof(PRPackedBool));
26627:                 }
26627:             }
26627: 
26627:             // create the glyph run before calling SetMissing Glyph
26627:             aTextRun->AddGlyphRun(mainFont, runStart-aLayoutStart, matchedLength);
26627: 
26627:             for (PRUint32 index = runStart; index < runStart + matchedLength; index++) {
26627:                 // Record the char code so we can draw a box with the Unicode value; also need to
26627:                 // replace char(s) in the string with SPACE because CoreText crashes on missing chars :(
26627:                 if (!mutableStringObj) {
26627:                     mutableStringObj =
26627:                         CFAttributedStringCreateMutableCopy(kCFAllocatorDefault,
26627:                                                             0,
26627:                                                             attrStringObj);
26627:                     CFRelease(attrStringObj);
26627:                 }
26627: 
26627:                 if (NS_IS_HIGH_SURROGATE(aString[index]) &&
26627:                     index + 1 < aTotalLength &&
26627:                     NS_IS_LOW_SURROGATE(aString[index+1])) {
26627:                     aTextRun->SetMissingGlyph(index-aLayoutStart,
26627:                                               SURROGATE_TO_UCS4(aString[index],
26627:                                                                 aString[index+1]));
26627:                     CFAttributedStringReplaceString(mutableStringObj,
26627:                                                     CFRangeMake(index, 2),
26627:                                                     CFSTR("  "));
26627:                     index++;
26627:                 } else {
26627:                     aTextRun->SetMissingGlyph(index-aLayoutStart, aString[index]);
26627:                     CFAttributedStringReplaceString(mutableStringObj,
26627:                                                     CFRangeMake(index, 1),
26627:                                                     CFSTR(" "));
26627:                 }
26627:             }
26627: 
26627:             // We have to remember the indices of unmatched chars to avoid overwriting
26627:             // their glyph (actually char code) data with the space glyph later,
26627:             // while we're retrieving actual glyph data from CoreText runs.
26627:             if (unmatched)
26627:                 memset(unmatched + runStart, PR_TRUE, matchedLength);
26627:         }
26627: 
26627:         runStart += matchedLength;
26627:     }
26627: 
26627:     // Create the CoreText line from our string, then we're done with it
26627:     CTLineRef line;
26627:     if (mutableStringObj) {
26627:         line = CTLineCreateWithAttributedString(mutableStringObj);
26627:         CFRelease(mutableStringObj);
26627:     } else {
26627:         line = CTLineCreateWithAttributedString(attrStringObj);
26627:         CFRelease(attrStringObj);
26627:     }
26627: 
26627:     // and finally retrieve the glyph data and store into the gfxTextRun
26627:     CFArrayRef glyphRuns = CTLineGetGlyphRuns(line);
26627:     PRUint32 numRuns = CFArrayGetCount(glyphRuns);
26627: 
26627:     // Iterate through the glyph runs. Note that they may extend into the wrapper
26627:     // area, so we have to be careful not to include the extra glyphs from there
26627:     for (PRUint32 runIndex = 0; runIndex < numRuns; runIndex++) {
26627:         CTRunRef aCTRun = (CTRunRef)CFArrayGetValueAtIndex(glyphRuns, runIndex);
26627:         if (SetGlyphsFromRun(aTextRun, aCTRun, unmatched, aLayoutStart, aLayoutLength) != NS_OK)
26627:             break;
26627:     } // end loop over each CTRun in the CTLine
26627: 
26627:     CFRelease(line);
26627: 
26627:     // It's possible for CoreText to omit glyph runs if it decides they contain
26627:     // only invisibles (e.g., U+FEFF, see reftest 474417-1). In this case, we
26627:     // need to eliminate them from the glyph run array to avoid drawing "partial
26627:     // ligatures" with the wrong font.
26627:     aTextRun->SanitizeGlyphRuns();
26627: 
26627:     // Is this actually necessary? Without it, gfxTextRun::CopyGlyphDataFrom may assert
26627:     // "Glyphruns not coalesced", but does that matter?
26627:     aTextRun->SortGlyphRuns();
26627: }
26627: 
26627: nsresult
26627: gfxCoreTextFontGroup::SetGlyphsFromRun(gfxTextRun *aTextRun,
26627:                                        CTRunRef aCTRun,
26627:                                        const PRPackedBool *aUnmatched,
26627:                                        PRInt32 aLayoutStart,
26627:                                        PRInt32 aLayoutLength)
26627: {
26627:     // The textRun has been bidi-wrapped (if necessary);
26627:     // aLayoutStart and aLayoutLength define the range of characters
26627:     // within the textRun that are "real" data we need to handle.
26627:     // aCTRun is a glyph run from the CoreText layout process.
26627: 
26627:     PRBool isLTR = !aTextRun->IsRightToLeft();
26627:     PRInt32 direction = isLTR ? 1 : -1;
26627: 
26627:     PRInt32 numGlyphs = CTRunGetGlyphCount(aCTRun);
26627:     if (numGlyphs == 0)
26627:         return NS_OK;
26627: 
26627:     // skip the run if it is entirely outside the real text range
26627:     CFRange stringRange = CTRunGetStringRange(aCTRun);
26627:     if (stringRange.location >= aLayoutStart + aLayoutLength ||
26627:         stringRange.location + stringRange.length <= aLayoutStart)
26627:         return NS_OK;
26627: 
26627:     // retrieve the laid-out glyph data from the CTRun
26627:     nsAutoArrayPtr<CGGlyph> glyphsArray;
26627:     nsAutoArrayPtr<CGPoint> positionsArray;
26627:     nsAutoArrayPtr<CFIndex> glyphToCharArray;
26627:     const CGGlyph* glyphs = NULL;
26627:     const CGPoint* positions = NULL;
26627:     const CFIndex* glyphToChar = NULL;
26627: 
26627:     // Testing indicates that CTRunGetGlyphsPtr (almost?) always succeeds,
26627:     // and so allocating a new array and copying data with CTRunGetGlyphs
26627:     // will be extremely rare.
26627:     // If this were not the case, we could use an nsAutoTArray<> to
26627:     // try and avoid the heap allocation for small runs.
26627:     // It's possible that some future change to CoreText will mean that
26627:     // CTRunGetGlyphsPtr fails more often; if this happens, nsAutoTArray<>
26627:     // may become an attractive option.
26627:     glyphs = CTRunGetGlyphsPtr(aCTRun);
26627:     if (glyphs == NULL) {
26627:         glyphsArray = new CGGlyph[numGlyphs];
26627:         if (!glyphsArray)
26627:             return NS_ERROR_OUT_OF_MEMORY;
26627:         CTRunGetGlyphs(aCTRun, CFRangeMake(0, 0), glyphsArray.get());
26627:         glyphs = glyphsArray.get();
26627:     }
26627: 
26627:     positions = CTRunGetPositionsPtr(aCTRun);
26627:     if (positions == NULL) {
26627:         positionsArray = new CGPoint[numGlyphs];
26627:         if (!positionsArray)
26627:             return NS_ERROR_OUT_OF_MEMORY;
26627:         CTRunGetPositions(aCTRun, CFRangeMake(0, 0), positionsArray.get());
26627:         positions = positionsArray.get();
26627:     }
26627: 
26627:     // String indices from CoreText are relative to the line, not the current run
26627:     glyphToChar = CTRunGetStringIndicesPtr(aCTRun);
26627:     if (glyphToChar == NULL) {
26627:         glyphToCharArray = new CFIndex[numGlyphs];
26627:         if (!glyphToCharArray)
26627:             return NS_ERROR_OUT_OF_MEMORY;
26627:         CTRunGetStringIndices(aCTRun, CFRangeMake(0, 0), glyphToCharArray.get());
26627:         glyphToChar = glyphToCharArray.get();
26627:     }
26627: 
26627:     double runWidth = CTRunGetTypographicBounds(aCTRun, CFRangeMake(0, 0), NULL, NULL, NULL);
26627: 
26627:     nsAutoTArray<gfxTextRun::DetailedGlyph,1> detailedGlyphs;
26627:     gfxTextRun::CompressedGlyph g;
26627:     const PRUint32 appUnitsPerDevUnit = aTextRun->GetAppUnitsPerDevUnit();
26627: 
26627:     // CoreText gives us the glyphindex-to-charindex mapping, which relates each glyph
26627:     // to a source text character; we also need the charindex-to-glyphindex mapping to
26627:     // find the glyph for a given char. Note that some chars may not map to any glyph
26627:     // (ligature continuations), and some may map to several glyphs (eg Indic split vowels).
26627:     // We set the glyph index to NO_GLYPH for chars that have no associated glyph, and we
26627:     // record the last glyph index for cases where the char maps to several glyphs,
26627:     // so that our clumping will include all the glyph fragments for the character.
26627:     // The charToGlyph array is indexed by char position within the stringRange of the run.
26627:     
26627:     static const PRInt32 NO_GLYPH = -1;
26627:     nsAutoTArray<PRInt32,SMALL_GLYPH_RUN> charToGlyphArray;
26627:     if (!charToGlyphArray.SetLength(stringRange.length))
26627:         return NS_ERROR_OUT_OF_MEMORY;
26627:     PRInt32 *charToGlyph = charToGlyphArray.Elements();
26627:     for (PRInt32 offset = 0; offset < stringRange.length; ++offset)
26627:         charToGlyph[offset] = NO_GLYPH;
26627:     for (PRInt32 g = 0; g < numGlyphs; ++g)
26627:         // charToGlyph array is indexed by char position within the run, not the whole line
26627:         charToGlyph[glyphToChar[g]-stringRange.location] = g;
26627: 
26627:     // Find character and glyph clumps that correspond, allowing for ligatures,
26627:     // indic reordering, split glyphs, etc.
26627:     //
26627:     // The idea is that we'll find a character sequence starting at the first char of stringRange,
26627:     // and extend it until it includes the character associated with the first glyph;
26627:     // we also extend it as long as there are "holes" in the range of glyphs. So we
26627:     // will eventually have a contiguous sequence of characters, starting at the beginning
26627:     // of the range, that map to a contiguous sequence of glyphs, starting at the beginning
26627:     // of the glyph array. That's a clump; then we update the starting positions and repeat.
26627:     //
26627:     // NB: In the case of RTL layouts, we iterate over the stringRange in reverse.
26627:     //
26627:     // This may find characters that fall outside the range aLayoutStart:aLayoutLength,
26627:     // so we won't necessarily use everything we find here.
26627: 
26627:     PRInt32 glyphStart = 0; // looking for a clump that starts at this glyph index
26627:     PRInt32 charStart = isLTR ?
26627:         0 : stringRange.length-1; // and this char index (relative to stringRange.location)
26627: 
26627:     while (glyphStart < numGlyphs) { // keep finding groups until all glyphs are accounted for
26627: 
27838:         PRBool inOrder = PR_TRUE;
27838:         PRInt32 charEnd = glyphToChar[glyphStart] - stringRange.location;
26627:         PRInt32 glyphEnd = glyphStart;
27838:         PRInt32 charLimit = isLTR ? stringRange.length : -1;
27838:         do {
27838:             // This is normally executed once for each iteration of the outer loop,
27838:             // but in unusual cases where the character/glyph association is complex,
27838:             // the initial character range might correspond to a non-contiguous
27838:             // glyph range with "holes" in it. If so, we will repeat this loop to
27838:             // extend the character range until we have a contiguous glyph sequence.
27838:             charEnd += direction;
27838:             while (charEnd != charLimit && charToGlyph[charEnd] == NO_GLYPH) {
27838:                 charEnd += direction;
27838:             }
26627: 
27838:             // find the maximum glyph index covered by the clump so far
27838:             for (PRInt32 i = charStart; i != charEnd; i += direction) {
27838:                 if (charToGlyph[i] != NO_GLYPH) {
27838:                     glyphEnd = PR_MAX(glyphEnd, charToGlyph[i] + 1); // update extent of glyph range
27838:                 }
27838:             }
26627: 
27838:             if (glyphEnd == glyphStart + 1) {
27838:                 // for the common case of a single-glyph clump, we can skip the following checks
27838:                 break;
27838:             }
26627: 
27838:             if (glyphEnd == glyphStart) {
27838:                 // no glyphs, try to extend the clump
27838:                 continue;
27838:             }
26627: 
27838:             // check whether all glyphs in the range are associated with the characters
27838:             // in our clump; if not, we have a discontinuous range, and should extend it
27838:             // unless we've reached the end of the text
27838:             PRBool allGlyphsAreWithinCluster = PR_TRUE;
27838:             PRInt32 prevGlyphCharIndex = charStart;
27838:             for (PRInt32 i = glyphStart; i < glyphEnd; ++i) {
27838:                 PRInt32 glyphCharIndex = glyphToChar[i] - stringRange.location;
26627:                 if (isLTR) {
27838:                     if (glyphCharIndex < charStart || glyphCharIndex >= charEnd) {
27838:                         allGlyphsAreWithinCluster = PR_FALSE;
27838:                         break;
27838:                     }
27838:                     if (glyphCharIndex < prevGlyphCharIndex) {
27838:                         inOrder = PR_FALSE;
27838:                     }
27838:                     prevGlyphCharIndex = glyphCharIndex;
26627:                 } else {
27838:                     if (glyphCharIndex > charStart || glyphCharIndex <= charEnd) {
27838:                         allGlyphsAreWithinCluster = PR_FALSE;
27838:                         break;
26627:                     }
27838:                     if (glyphCharIndex > prevGlyphCharIndex) {
27838:                         inOrder = PR_FALSE;
27838:                     }
27838:                     prevGlyphCharIndex = glyphCharIndex;
27838:                 }
27838:             }
27838:             if (allGlyphsAreWithinCluster) {
27838:                 break;
27838:             }
27838:         } while (charEnd != charLimit);
26627: 
26627:         NS_ASSERTION(glyphStart < glyphEnd, "character/glyph clump contains no glyphs!");
26627:         NS_ASSERTION(charStart != charEnd, "character/glyph contains no characters!");
26627: 
26627:         // Now charStart..charEnd is a ligature clump, corresponding to glyphStart..glyphEnd;
26627:         // Set baseCharIndex to the char we'll actually attach the glyphs to (1st of ligature),
26627:         // and endCharIndex to the limit (position beyond the last char).
26627:         PRInt32 baseCharIndex, endCharIndex;
26627:         if (isLTR) {
26627:             while (charEnd < stringRange.length && charToGlyph[charEnd] == NO_GLYPH)
26627:                 charEnd++;
26627:             baseCharIndex = charStart + stringRange.location;
26627:             endCharIndex = charEnd + stringRange.location;
26627:         } else {
26627:             while (charEnd >= 0 && charToGlyph[charEnd] == NO_GLYPH)
26627:                 charEnd--;
26627:             baseCharIndex = charEnd + stringRange.location + 1;
26627:             endCharIndex = charStart + stringRange.location + 1;
26627:         }
26627: 
27838:         // Then we check if the clump falls outside our actual string range; if so, just go to the next.
32840:         if (endCharIndex <= aLayoutStart || baseCharIndex >= aLayoutStart + aLayoutLength) {
26627:             glyphStart = glyphEnd;
26627:             charStart = charEnd;
26627:             continue;
26627:         }
27838:         // Ensure we won't try to go beyond the valid length of the textRun's text
32840:         baseCharIndex = PR_MAX(baseCharIndex, aLayoutStart);
26627:         endCharIndex = PR_MIN(endCharIndex, aLayoutStart + aLayoutLength);
26627: 
26627:         // for missing glyphs, we already recorded the info in the textRun
26627:         if (aUnmatched && aUnmatched[baseCharIndex]) {
26627:             glyphStart = glyphEnd;
26627:             charStart = charEnd;
26627:             continue;
26627:         }
26627: 
26627:         // Now we're ready to set the glyph info in the textRun; measure the glyph width
26627:         // of the first (perhaps only) glyph, to see if it is "Simple"
26627:         double toNextGlyph;
26627:         if (glyphStart < numGlyphs-1)
26627:             toNextGlyph = positions[glyphStart+1].x - positions[glyphStart].x;
26627:         else
26627:             toNextGlyph = positions[0].x + runWidth - positions[glyphStart].x;
26627:         PRInt32 advance = PRInt32(toNextGlyph * appUnitsPerDevUnit);
26627: 
26627:         // Check if it's a simple one-to-one mapping
26627:         PRInt32 glyphsInClump = glyphEnd - glyphStart;
26627:         if (glyphsInClump == 1 &&
26627:             gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyphs[glyphStart]) &&
26627:             gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
26627:             aTextRun->IsClusterStart(baseCharIndex - aLayoutStart) &&
26627:             positions[glyphStart].y == 0.0)
26627:         {
26627:             aTextRun->SetSimpleGlyph(baseCharIndex - aLayoutStart,
26627:                                      g.SetSimpleGlyph(advance, glyphs[glyphStart]));
26627:         } else {
26627:             // collect all glyphs in a list to be assigned to the first char;
26627:             // there must be at least one in the clump, and we already measured its advance,
26627:             // hence the placement of the loop-exit test and the measurement of the next glyph
26627:             while (1) {
26627:                 gfxTextRun::DetailedGlyph *details = detailedGlyphs.AppendElement();
26627:                 details->mGlyphID = glyphs[glyphStart];
26627:                 details->mXOffset = 0;
26627:                 details->mYOffset = -positions[glyphStart].y * appUnitsPerDevUnit;
26627:                 details->mAdvance = advance;
26627:                 if (++glyphStart >= glyphEnd)
26627:                    break;
26627:                 if (glyphStart < numGlyphs-1)
26627:                     toNextGlyph = positions[glyphStart+1].x - positions[glyphStart].x;
26627:                 else
26627:                     toNextGlyph = positions[0].x + runWidth - positions[glyphStart].x;
26627:                 advance = PRInt32(toNextGlyph * appUnitsPerDevUnit);
26627:             }
26627: 
26627:             gfxTextRun::CompressedGlyph g;
26627:             g.SetComplex(aTextRun->IsClusterStart(baseCharIndex - aLayoutStart),
26627:                          PR_TRUE, detailedGlyphs.Length());
26627:             aTextRun->SetGlyphs(baseCharIndex - aLayoutStart, g, detailedGlyphs.Elements());
26627: 
26627:             detailedGlyphs.Clear();
26627:         }
26627: 
26627:         // the rest of the chars in the group are ligature continuations, no associated glyphs
26627:         while (++baseCharIndex != endCharIndex &&
26627:             (baseCharIndex - aLayoutStart) < aLayoutLength) {
27838:             g.SetComplex(inOrder && aTextRun->IsClusterStart(baseCharIndex - aLayoutStart),
26627:                          PR_FALSE, 0);
26627:             aTextRun->SetGlyphs(baseCharIndex - aLayoutStart, g, nsnull);
26627:         }
26627: 
26627:         glyphStart = glyphEnd;
26627:         charStart = charEnd;
26627:     }
26627: 
26627:     return NS_OK;
26627: }
26627: 
26627: PRBool
26627: gfxCoreTextFontGroup::HasFont(ATSFontRef aFontRef)
26627: {
26627:     for (PRUint32 i = 0; i < mFonts.Length(); ++i) {
26627:         if (aFontRef == static_cast<gfxCoreTextFont *>(mFonts.ElementAt(i).get())->GetATSFont())
26627:             return PR_TRUE;
26627:     }
26627:     return PR_FALSE;
26627: }
26627: 
26627: struct PrefFontCallbackData {
31590:     PrefFontCallbackData(nsTArray<nsRefPtr<gfxFontFamily> >& aFamiliesArray)
26627:         : mPrefFamilies(aFamiliesArray)
26627:     {}
26627: 
31590:     nsTArray<nsRefPtr<gfxFontFamily> >& mPrefFamilies;
26627: 
26627:     static PRBool AddFontFamilyEntry(eFontPrefLang aLang, const nsAString& aName, void *aClosure)
26627:     {
31590:         PrefFontCallbackData *prefFontData = static_cast<PrefFontCallbackData*>(aClosure);
26627: 
31590:         gfxFontFamily *family = gfxMacPlatformFontList::PlatformFontList()->FindFamily(aName);
26627:         if (family) {
26627:             prefFontData->mPrefFamilies.AppendElement(family);
26627:         }
26627:         return PR_TRUE;
26627:     }
26627: };
26627: 
26627: 
26627: already_AddRefed<gfxFont>
26627: gfxCoreTextFontGroup::WhichPrefFontSupportsChar(PRUint32 aCh)
26627: {
26627:     gfxFont *font;
26627: 
26627:     // FindCharUnicodeRange only supports BMP character points and there are no non-BMP fonts in prefs
26627:     if (aCh > 0xFFFF)
26627:         return nsnull;
26627: 
26627:     // get the pref font list if it hasn't been set up already
26627:     PRUint32 unicodeRange = FindCharUnicodeRange(aCh);
26627:     eFontPrefLang charLang = gfxPlatformMac::GetFontPrefLangFor(unicodeRange);
26627: 
26627:     // if the last pref font was the first family in the pref list, no need to recheck through a list of families
26627:     if (mLastPrefFont && charLang == mLastPrefLang &&
26627:         mLastPrefFirstFont && mLastPrefFont->TestCharacterMap(aCh)) {
26627:         font = mLastPrefFont;
26627:         NS_ADDREF(font);
26627:         return font;
26627:     }
26627: 
26627:     // based on char lang and page lang, set up list of pref lang fonts to check
26627:     eFontPrefLang prefLangs[kMaxLenPrefLangList];
26627:     PRUint32 i, numLangs = 0;
26627: 
26627:     gfxPlatformMac *macPlatform = gfxPlatformMac::GetPlatform();
26627:     macPlatform->GetLangPrefs(prefLangs, numLangs, charLang, mPageLang);
26627: 
26627:     for (i = 0; i < numLangs; i++) {
31590:         nsAutoTArray<nsRefPtr<gfxFontFamily>, 5> families;
26627:         eFontPrefLang currentLang = prefLangs[i];
26627: 
31590:         gfxMacPlatformFontList *fc = gfxMacPlatformFontList::PlatformFontList();
26627: 
26627:         // get the pref families for a single pref lang
26627:         if (!fc->GetPrefFontFamilyEntries(currentLang, &families)) {
26627:             eFontPrefLang prefLangsToSearch[1] = { currentLang };
26627:             PrefFontCallbackData prefFontData(families);
26627:             gfxPlatform::ForEachPrefFont(prefLangsToSearch, 1, PrefFontCallbackData::AddFontFamilyEntry,
26627:                                            &prefFontData);
26627:             fc->SetPrefFontFamilyEntries(currentLang, families);
26627:         }
26627: 
26627:         // find the first pref font that includes the character
26627:         PRUint32  i, numPrefs;
26627:         numPrefs = families.Length();
26627:         for (i = 0; i < numPrefs; i++) {
26627:             // look up the appropriate face
31590:             gfxFontFamily *family = families[i];
26627:             if (!family) continue;
26627: 
26627:             // if a pref font is used, it's likely to be used again in the same text run.
26627:             // the style doesn't change so the face lookup can be cached rather than calling
26627:             // GetOrMakeCTFont repeatedly.  speeds up FindFontForChar lookup times for subsequent
26627:             // pref font lookups
26627:             if (family == mLastPrefFamily && mLastPrefFont->TestCharacterMap(aCh)) {
26627:                 font = mLastPrefFont;
26627:                 NS_ADDREF(font);
26627:                 return font;
26627:             }
26627: 
26627:             PRBool needsBold;
31590:             MacOSFontEntry *fe =
31590:                 static_cast<MacOSFontEntry*>(family->FindFontForStyle(mStyle, needsBold));
26627:             // if ch in cmap, create and return a gfxFont
26627:             if (fe && fe->TestCharacterMap(aCh)) {
26627:                 nsRefPtr<gfxCoreTextFont> prefFont = GetOrMakeCTFont(fe, &mStyle, needsBold);
26627:                 if (!prefFont) continue;
26627:                 mLastPrefFamily = family;
26627:                 mLastPrefFont = prefFont;
26627:                 mLastPrefLang = charLang;
26627:                 mLastPrefFirstFont = (i == 0);
31590:                 nsRefPtr<gfxFont> font2 = prefFont.get();
26627:                 return font2.forget();
26627:             }
26627: 
26627:         }
26627:     }
26627: 
26627:     return nsnull;
26627: }
26627: 
26627: already_AddRefed<gfxFont>
26627: gfxCoreTextFontGroup::WhichSystemFontSupportsChar(PRUint32 aCh)
26627: {
31590:     MacOSFontEntry *fe = static_cast<MacOSFontEntry*>
31590:         (gfxMacPlatformFontList::PlatformFontList()->FindFontForChar(aCh, GetFontAt(0)));
26627:     if (fe) {
26627:         nsRefPtr<gfxCoreTextFont> ctFont = GetOrMakeCTFont(fe, &mStyle, PR_FALSE); // ignore bolder considerations in system fallback case...
31590:         nsRefPtr<gfxFont> font = ctFont.get();
26627:         return font.forget();
26627:     }
26627: 
26627:     return nsnull;
26627: }
26627: 
26627: void
26627: gfxCoreTextFontGroup::UpdateFontList()
26627: {
26627:     // if user font set is set, check to see if font list needs updating
26627:     if (mUserFontSet && mCurrGeneration != GetGeneration()) {
26627:         // xxx - can probably improve this to detect when all fonts were found, so no need to update list
26627:         mFonts.Clear();
26627:         ForEachFont(FindCTFont, this);
26627:         mCurrGeneration = GetGeneration();
26627:     }
26627: }
