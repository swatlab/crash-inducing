     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /** @file
 50549:  * This file declares the RasterImage class, which
 50549:  * handles static and animated rasterized images.
     1:  *
     1:  * @author  Stuart Parmenter <pavlov@netscape.com>
     1:  * @author  Chris Saari <saari@netscape.com>
     1:  * @author  Arron Mogge <paper@animecity.nu>
     1:  * @author  Andrew Smith <asmith15@learn.senecac.on.ca>
     1:  */
     1: 
 50549: #ifndef mozilla_imagelib_RasterImage_h_
 50549: #define mozilla_imagelib_RasterImage_h_
     1: 
115644: #include "mozilla/Mutex.h"
 50545: #include "Image.h"
     1: #include "nsCOMArray.h"
     1: #include "nsCOMPtr.h"
     1: #include "imgIContainer.h"
     1: #include "nsIProperties.h"
     1: #include "nsITimer.h"
     1: #include "nsWeakReference.h"
  7009: #include "nsTArray.h"
 30479: #include "imgFrame.h"
 32424: #include "nsThreadUtils.h"
 50548: #include "DiscardTracker.h"
 74883: #include "mozilla/TimeStamp.h"
 78660: #include "mozilla/Telemetry.h"
 89821: #include "mozilla/LinkedList.h"
106631: #include "mozilla/StaticPtr.h"
 52150: #ifdef DEBUG
 52150:   #include "imgIContainerDebug.h"
 52150: #endif
     1: 
 50546: class imgIDecoder;
 82104: class imgIContainerObserver;
 50546: class nsIInputStream;
 50546: 
 50549: #define NS_RASTERIMAGE_CID \
 48934: { /* 376ff2c1-9bf6-418a-b143-3340c00112f7 */         \
 30479:      0x376ff2c1,                                     \
 30479:      0x9bf6,                                         \
 30479:      0x418a,                                         \
 30479:     {0xb1, 0x43, 0x33, 0x40, 0xc0, 0x01, 0x12, 0xf7} \
     1: }
     1: 
     1: /**
     1:  * Handles static and animated image containers.
     1:  *
     1:  *
     1:  * @par A Quick Walk Through
     1:  * The decoder initializes this class and calls AppendFrame() to add a frame.
 50549:  * Once RasterImage detects more than one frame, it starts the animation
 82104:  * with StartAnimation(). Note that the invalidation events for RasterImage are
 82104:  * generated automatically using nsRefreshDriver.
     1:  *
     1:  * @par
 82104:  * StartAnimation() initializes the animation helper object and sets the time
 82104:  * the first frame was displayed to the current clock time.
     1:  *
     1:  * @par
 82104:  * When the refresh driver corresponding to the imgIContainer that this image is
 82104:  * a part of notifies the RasterImage that it's time to invalidate,
 82104:  * RequestRefresh() is called with a given TimeStamp to advance to. As long as
 82104:  * the timeout of the given frame (the frame's "delay") plus the time that frame
 82104:  * was first displayed is less than or equal to the TimeStamp given,
 82104:  * RequestRefresh() calls AdvanceFrame().
 82104:  *
 82104:  * @par
 82104:  * AdvanceFrame() is responsible for advancing a single frame of the animation.
 82104:  * It can return true, meaning that the frame advanced, or false, meaning that
 82104:  * the frame failed to advance (usually because the next frame hasn't been
 82104:  * decoded yet). It is also responsible for performing the final animation stop
 82104:  * procedure if the final frame of a non-looping animation is reached.
     1:  *
     1:  * @par
     1:  * Each frame can have a different method of removing itself. These are
     1:  * listed as imgIContainer::cDispose... constants.  Notify() calls 
     1:  * DoComposite() to handle any special frame destruction.
     1:  *
     1:  * @par
     1:  * The basic path through DoComposite() is:
     1:  * 1) Calculate Area that needs updating, which is at least the area of
     1:  *    aNextFrame.
     1:  * 2) Dispose of previous frame.
     1:  * 3) Draw new image onto compositingFrame.
     1:  * See comments in DoComposite() for more information and optimizations.
     1:  *
     1:  * @par
 50549:  * The rest of the RasterImage specific functions are used by DoComposite to
     1:  * destroy the old frame and build the new one.
     1:  *
     1:  * @note
 42263:  * <li> "Mask", "Alpha", and "Alpha Level" are interchangeable phrases in
 50549:  * respects to RasterImage.
     1:  *
     1:  * @par
     1:  * <li> GIFs never have more than a 1 bit alpha.
     1:  * <li> APNGs may have a full alpha channel.
     1:  *
     1:  * @par
     1:  * <li> Background color specified in GIF is ignored by web browsers.
     1:  *
     1:  * @par
     1:  * <li> If Frame 3 wants to dispose by restoring previous, what it wants is to
     1:  * restore the composition up to and including Frame 2, as well as Frame 2s
     1:  * disposal.  So, in the middle of DoComposite when composing Frame 3, right
     1:  * after destroying Frame 2's area, we copy compositingFrame to
     1:  * prevCompositingFrame.  When DoComposite gets called to do Frame 4, we
     1:  * copy prevCompositingFrame back, and then draw Frame 4 on top.
     1:  *
     1:  * @par
     1:  * The mAnim structure has members only needed for animated images, so
     1:  * it's not allocated until the second frame is added.
     1:  *
     1:  * @note
     1:  * mAnimationMode, mLoopCount and mObserver are not in the mAnim structure
     1:  * because the first two have public setters and the observer we only get
     1:  * in Init().
     1:  */
 50549: 
 50549: namespace mozilla {
 82042: namespace layers {
 82042: class LayerManager;
 82042: class ImageContainer;
115336: class Image;
 82042: }
 87852: namespace image {
 50549: 
 51242: class Decoder;
 50549: 
 74888: class RasterImage : public Image
 52150:                   , public nsIProperties
 52150:                   , public nsSupportsWeakReference
 52150: #ifdef DEBUG
 52150:                   , public imgIContainerDebug
 52150: #endif
     1: {
     1: public:
     1:   NS_DECL_ISUPPORTS
  2663:   NS_DECL_NSIPROPERTIES
 52150: #ifdef DEBUG
 52150:   NS_DECL_IMGICONTAINERDEBUG
 52150: #endif
     1: 
 57656:   // BEGIN NS_DECL_IMGICONTAINER (minus GetAnimationMode/SetAnimationMode)
 57655:   // ** Don't edit this chunk except to mirror changes in imgIContainer.idl **
108991:   NS_IMETHOD GetWidth(int32_t *aWidth);
108991:   NS_IMETHOD GetHeight(int32_t *aHeight);
108991:   NS_IMETHOD GetType(uint16_t *aType);
108991:   NS_IMETHOD_(uint16_t) GetType(void);
106218:   NS_IMETHOD GetAnimated(bool *aAnimated);
106218:   NS_IMETHOD GetCurrentFrameIsOpaque(bool *aCurrentFrameIsOpaque);
108991:   NS_IMETHOD GetFrame(uint32_t aWhichFrame, uint32_t aFlags, gfxASurface **_retval);
106217:   NS_IMETHOD GetImageContainer(mozilla::layers::ImageContainer **_retval);
108991:   NS_IMETHOD CopyFrame(uint32_t aWhichFrame, uint32_t aFlags, gfxImageSurface **_retval);
108991:   NS_IMETHOD ExtractFrame(uint32_t aWhichFrame, const nsIntRect & aRect, uint32_t aFlags, imgIContainer **_retval);
108991:   NS_IMETHOD Draw(gfxContext *aContext, gfxPattern::GraphicsFilter aFilter, const gfxMatrix & aUserSpaceToImageSpace, const gfxRect & aFill, const nsIntRect & aSubimage, const nsIntSize & aViewportSize, uint32_t aFlags);
 57655:   NS_IMETHOD_(nsIFrame *) GetRootLayoutFrame(void);
106218:   NS_IMETHOD RequestDecode(void);
106218:   NS_IMETHOD LockImage(void);
106218:   NS_IMETHOD UnlockImage(void);
106218:   NS_IMETHOD RequestDiscard(void);
106218:   NS_IMETHOD ResetAnimation(void);
 82096:   NS_IMETHOD_(void) RequestRefresh(const mozilla::TimeStamp& aTime);
 57655:   // END NS_DECL_IMGICONTAINER
 57655: 
106838:   RasterImage(imgStatusTracker* aStatusTracker = nullptr);
 50549:   virtual ~RasterImage();
     1: 
 52149:   virtual nsresult StartAnimation();
 52149:   virtual nsresult StopAnimation();
 52149: 
 50555:   // Methods inherited from Image
 50555:   nsresult Init(imgIDecoderObserver* aObserver,
 50555:                 const char* aMimeType,
 53660:                 const char* aURIString,
108991:                 uint32_t aFlags);
 51294:   void     GetCurrentFrameRect(nsIntRect& aRect);
 50555: 
 50555:   // Raster-specific methods
 50556:   static NS_METHOD WriteToRasterImage(nsIInputStream* aIn, void* aClosure,
 50556:                                       const char* aFromRawSegment,
108991:                                       uint32_t aToOffset, uint32_t aCount,
108991:                                       uint32_t* aWriteCount);
 32424: 
 51295:   /* The index of the current frame that would be drawn if the image was to be
 51295:    * drawn now. */
108991:   uint32_t GetCurrentFrameIndex();
 51295: 
 51295:   /* The total number of frames in this image. */
108991:   uint32_t GetNumFrames();
 51295: 
 90638:   virtual size_t HeapSizeOfSourceWithComputedFallback(nsMallocSizeOfFun aMallocSizeOf) const;
 90638:   virtual size_t HeapSizeOfDecodedWithComputedFallback(nsMallocSizeOfFun aMallocSizeOf) const;
 90638:   virtual size_t NonHeapSizeOfDecoded() const;
 90638:   virtual size_t OutOfProcessSizeOfDecoded() const;
 42553: 
 46991:   /* Triggers discarding. */
 60418:   void Discard(bool force = false);
 60418:   void ForceDiscard() { Discard(/* force = */ true); }
 46991: 
 50553:   /* Callbacks for decoders */
108991:   nsresult SetFrameDisposalMethod(uint32_t aFrameNum,
108991:                                   int32_t aDisposalMethod);
108991:   nsresult SetFrameTimeout(uint32_t aFrameNum, int32_t aTimeout);
108991:   nsresult SetFrameBlendMethod(uint32_t aFrameNum, int32_t aBlendMethod);
108991:   nsresult SetFrameHasNoAlpha(uint32_t aFrameNum);
108991:   nsresult SetFrameAsNonPremult(uint32_t aFrameNum, bool aIsNonPremult);
 50553: 
 50553:   /**
 50553:    * Sets the size of the container. This should only be called by the
 50553:    * decoder. This function may be called multiple times, but will throw an
 50553:    * error if subsequent calls do not match the first.
 50553:    */
108991:   nsresult SetSize(int32_t aWidth, int32_t aHeight);
 50553: 
 50553: 
 50553:   /**
 73884:    * Ensures that a given frame number exists with the given parameters, and
 73884:    * returns pointers to the data storage for that frame.
 73884:    * It is not possible to create sparse frame arrays; you can only append
 73884:    * frames to the current frame array.
 50553:    */
108991:   nsresult EnsureFrame(uint32_t aFramenum, int32_t aX, int32_t aY,
108991:                        int32_t aWidth, int32_t aHeight,
 50553:                        gfxASurface::gfxImageFormat aFormat,
108991:                        uint8_t aPaletteDepth,
108991:                        uint8_t** imageData,
108991:                        uint32_t* imageLength,
108991:                        uint32_t** paletteData,
108991:                        uint32_t* paletteLength);
 50553: 
 73884:   /**
 73884:    * A shorthand for EnsureFrame, above, with aPaletteDepth = 0 and paletteData
 73884:    * and paletteLength set to null.
 73884:    */
108991:   nsresult EnsureFrame(uint32_t aFramenum, int32_t aX, int32_t aY,
108991:                        int32_t aWidth, int32_t aHeight,
 73884:                        gfxASurface::gfxImageFormat aFormat,
108991:                        uint8_t** imageData,
108991:                        uint32_t* imageLength);
 73884: 
108991:   void FrameUpdated(uint32_t aFrameNum, nsIntRect& aUpdatedRect);
 50553: 
 50553:   /* notification that the entire image has been decoded */
 50553:   nsresult DecodingComplete();
 50553: 
 50553:   /**
 50553:    * Number of times to loop the image.
 50553:    * @note -1 means forever.
 50553:    */
108991:   void     SetLoopCount(int32_t aLoopCount);
 50553: 
 50553:   /* Add compressed source data to the imgContainer.
 50553:    *
 50553:    * The decoder will use this data, either immediately or at draw time, to
 50553:    * decode the image.
 50553:    *
 50553:    * XXX This method's only caller (WriteToContainer) ignores the return
 50553:    * value. Should this just return void?
 50553:    */
108991:   nsresult AddSourceData(const char *aBuffer, uint32_t aCount);
 50553: 
 50553:   /* Called after the all the source data has been added with addSourceData. */
 71631:   nsresult SourceDataComplete();
 50553: 
 50553:   /* Called for multipart images when there's a new source image to add. */
114642:   nsresult NewSourceData();
 50553: 
 50553:   /**
 50553:    * A hint of the number of bytes of source data that the image contains. If
 50553:    * called early on, this can help reduce copying and reallocations by
 50553:    * appropriately preallocating the source data buffer.
 50553:    *
 50553:    * We take this approach rather than having the source data management code do
 50553:    * something more complicated (like chunklisting) because HTTP is by far the
 50553:    * dominant source of images, and the Content-Length header is quite reliable.
 50553:    * Thus, pre-allocation simplifies code and reduces the total number of
 50553:    * allocations.
 50553:    */
108991:   nsresult SetSourceSizeHint(uint32_t sizeHint);
 50553: 
 50553:   // "Blend" method indicates how the current image is combined with the
 50553:   // previous image.
 50553:   enum {
 50553:     // All color components of the frame, including alpha, overwrite the current
 50553:     // contents of the frame's output buffer region
 50553:     kBlendSource =  0,
 50553: 
 50553:     // The frame should be composited onto the output buffer based on its alpha,
 50553:     // using a simple OVER operation
 50553:     kBlendOver
 50553:   };
 50553: 
 50553:   enum {
 50553:     kDisposeClearAll         = -1, // Clear the whole image, revealing
 50553:                                    // what was there before the gif displayed
 50553:     kDisposeNotSpecified,   // Leave frame, let new frame draw on top
 50553:     kDisposeKeep,           // Leave frame, let new frame draw on top
 50553:     kDisposeClear,          // Clear the frame's area, revealing bg
 50553:     kDisposeRestorePrevious // Restore the previous (composited) frame
 50553:   };
 50553: 
 53674:   const char* GetURIString() { return mURIString.get();}
 53674: 
115543:   // Called from module startup. Sets up RasterImage to be used.
115543:   static void Initialize();
115543: 
     1: private:
     1:   struct Anim
     1:   {
     1:     //! Area of the first frame that needs to be redrawn on subsequent loops.
     1:     nsIntRect                  firstFrameRefreshArea;
108991:     uint32_t                   currentAnimationFrameIndex; // 0 to numFrames-1
 82104: 
 82104:     // the time that the animation advanced to the current frame
 82104:     TimeStamp                  currentAnimationFrameTime;
 82104: 
     1:     //! Track the last composited frame for Optimizations (See DoComposite code)
108991:     int32_t                    lastCompositedFrameIndex;
     1:     /** For managing blending of frames
     1:      *
     1:      * Some animations will use the compositingFrame to composite images
     1:      * and just hand this back to the caller when it is time to draw the frame.
     1:      * NOTE: When clearing compositingFrame, remember to set
     1:      *       lastCompositedFrameIndex to -1.  Code assume that if
     1:      *       lastCompositedFrameIndex >= 0 then compositingFrame exists.
     1:      */
 30479:     nsAutoPtr<imgFrame>        compositingFrame;
     1:     /** the previous composited frame, for DISPOSE_RESTORE_PREVIOUS
     1:      *
     1:      * The Previous Frame (all frames composited up to the current) needs to be
     1:      * stored in cases where the image specifies it wants the last frame back
     1:      * when it's done with the current frame.
     1:      */
 30479:     nsAutoPtr<imgFrame>        compositingPrevFrame;
     1: 
     1:     Anim() :
     1:       firstFrameRefreshArea(),
     1:       currentAnimationFrameIndex(0),
 82104:       lastCompositedFrameIndex(-1) {}
 82104:     ~Anim() {}
     1:   };
     1: 
 39120:   /**
 89821:    * DecodeWorker keeps a linked list of DecodeRequests to keep track of the
 89821:    * images it needs to decode.
 89821:    *
 89821:    * Each RasterImage has a single DecodeRequest member.
 89821:    */
 89821:   struct DecodeRequest : public LinkedListElement<DecodeRequest>
 89821:   {
 89821:     DecodeRequest(RasterImage* aImage)
 89821:       : mImage(aImage)
 89821:       , mIsASAP(false)
 89821:     {
 89821:     }
 89821: 
 89821:     RasterImage* const mImage;
 89821: 
 89821:     /* Keeps track of how much time we've burned decoding this particular decode
 89821:      * request. */
 89821:     TimeDuration mDecodeTime;
 89821: 
 89821:     /* True if we need to handle this decode as soon as possible. */
 89821:     bool mIsASAP;
 89821:   };
 89821: 
 89821:   /*
 89821:    * DecodeWorker is a singleton class we use when decoding large images.
 89821:    *
 89821:    * When we wish to decode an image larger than
 89821:    * image.mem.max_bytes_for_sync_decode, we call DecodeWorker::RequestDecode()
 89821:    * for the image.  This adds the image to a queue of pending requests and posts
 89821:    * the DecodeWorker singleton to the event queue, if it's not already pending
 89821:    * there.
 89821:    *
 89821:    * When the DecodeWorker is run from the event queue, it decodes the image (and
 89821:    * all others it's managing) in chunks, periodically yielding control back to
 89821:    * the event loop.
 89821:    *
 89821:    * An image being decoded may have one of two priorities: normal or ASAP.  ASAP
 89821:    * images are always decoded before normal images.  (We currently give ASAP
 89821:    * priority to images which appear onscreen but are not yet decoded.)
 89821:    */
 89821:   class DecodeWorker : public nsRunnable
 89821:   {
 89821:   public:
 89821:     static DecodeWorker* Singleton();
 89821: 
 89821:     /**
 89821:      * Ask the DecodeWorker to asynchronously decode this image.
 89821:      */
 89821:     void RequestDecode(RasterImage* aImg);
 89821: 
 89821:     /**
108319:      * Decode aImg for a short amount of time, and post the remainder to the
108319:      * queue.
108319:      */
108319:     void DecodeABitOf(RasterImage* aImg);
108319: 
108319:     /**
 89821:      * Give this image ASAP priority; it will be decoded before all non-ASAP
 89821:      * images.  You can call MarkAsASAP before or after you call RequestDecode
 89821:      * for the image, but if you MarkAsASAP before you call RequestDecode, you
 89821:      * still need to call RequestDecode.
 89821:      *
 89821:      * StopDecoding() resets the image's ASAP flag.
 89821:      */
 89821:     void MarkAsASAP(RasterImage* aImg);
 89821: 
 89821:     /**
 89821:      * Ask the DecodeWorker to stop decoding this image.  Internally, we also
 89821:      * call this function when we finish decoding an image.
 89821:      *
 89821:      * Since the DecodeWorker keeps raw pointers to RasterImages, make sure you
 89821:      * call this before a RasterImage is destroyed!
 89821:      */
 89821:     void StopDecoding(RasterImage* aImg);
 89821: 
 89821:     /**
 89821:      * Synchronously decode the beginning of the image until we run out of
 89821:      * bytes or we get the image's size.  Note that this done on a best-effort
 89821:      * basis; if the size is burried too deep in the image, we'll give up.
 89821:      *
 89821:      * @return NS_ERROR if an error is encountered, and NS_OK otherwise.  (Note
 89821:      *         that we return NS_OK even when the size was not found.)
 89821:      */
 89821:     nsresult DecodeUntilSizeAvailable(RasterImage* aImg);
 89821: 
 89821:     NS_IMETHOD Run();
 89821: 
 89821:   private: /* statics */
106631:     static StaticRefPtr<DecodeWorker> sSingleton;
 89821: 
 89821:   private: /* methods */
 89821:     DecodeWorker()
 89821:       : mPendingInEventLoop(false)
 89821:     {}
 89821: 
 89821:     /* Post ourselves to the event loop if we're not currently pending. */
 89821:     void EnsurePendingInEventLoop();
 89821: 
 89821:     /* Add the given request to the appropriate list of decode requests, but
 89821:      * don't ensure that we're pending in the event loop. */
 89821:     void AddDecodeRequest(DecodeRequest* aRequest);
 89821: 
 89821:     enum DecodeType {
 89821:       DECODE_TYPE_NORMAL,
 89821:       DECODE_TYPE_UNTIL_SIZE
 89821:     };
 89821: 
 89821:     /* Decode some chunks of the given image.  If aDecodeType is UNTIL_SIZE,
 89821:      * decode until we have the image's size, then stop. */
 89821:     nsresult DecodeSomeOfImage(RasterImage* aImg,
 89821:                                DecodeType aDecodeType = DECODE_TYPE_NORMAL);
 89821: 
 89821:   private: /* members */
 89821: 
 89821:     LinkedList<DecodeRequest> mASAPDecodeRequests;
 89821:     LinkedList<DecodeRequest> mNormalDecodeRequests;
 89821: 
 89821:     /* True if we've posted ourselves to the event loop and expect Run() to
 89821:      * be called sometime in the future. */
 89821:     bool mPendingInEventLoop;
 89821:   };
 89821: 
115644:   struct ScaleRequest : public LinkedListElement<ScaleRequest>
115644:   {
115644:     ScaleRequest(RasterImage* aImage)
115644:       : image(aImage)
115644:       , srcFrame(nullptr)
115644:       , dstFrame(nullptr)
115644:       , scale(0, 0)
115644:       , done(false)
115644:       , stopped(false)
115644:       , srcDataLocked(false)
115644:     {};
115644: 
115644:     bool LockSourceData()
115644:     {
115644:       if (!srcDataLocked) {
115644:         bool success = true;
115644:         success = success && NS_SUCCEEDED(image->LockImage());
115644:         success = success && NS_SUCCEEDED(srcFrame->LockImageData());
115644:         srcDataLocked = success;
115644:       }
115644:       return srcDataLocked;
115644:     }
115644: 
115644:     bool UnlockSourceData()
115644:     {
115644:       bool success = true;
115644:       if (srcDataLocked) {
115644:         success = success && NS_SUCCEEDED(image->UnlockImage());
115644:         success = success && NS_SUCCEEDED(srcFrame->UnlockImageData());
115644: 
115644:         // If unlocking fails, there's nothing we can do to make it work, so we
115644:         // claim that we're not locked regardless.
115644:         srcDataLocked = false;
115644:       }
115644:       return success;
115644:     }
115644: 
115644:     static void Stop(RasterImage* aImg);
115644: 
115644:     RasterImage* const image;
115955:     nsRefPtr<RasterImage> kungFuDeathGrip;
115644:     imgFrame *srcFrame;
115644:     nsAutoPtr<imgFrame> dstFrame;
115644:     gfxSize scale;
115644:     bool done;
115644:     bool stopped;
115644:     bool srcDataLocked;
115644:   };
115644: 
115644:   class ScaleWorker : public nsRunnable
115644:   {
115644:   public:
115644:     static ScaleWorker* Singleton();
115644: 
115644:     NS_IMETHOD Run();
115644: 
115644:   /* statics */
115644:     static nsRefPtr<ScaleWorker> sSingleton;
115644: 
115644:   private: /* methods */
115644:     ScaleWorker()
115644:       : mRequestsMutex("RasterImage.ScaleWorker.mRequestsMutex")
115644:       , mInitialized(false)
115644:     {};
115644: 
115644:     // Note: you MUST call RequestScale with the ScaleWorker mutex held.
115644:     void RequestScale(RasterImage* aImg);
115644: 
115644:   private: /* members */
115644: 
115644:     friend class RasterImage;
115644:     LinkedList<ScaleRequest> mScaleRequests;
115644:     Mutex mRequestsMutex;
115644:     bool mInitialized;
115644:   };
115644: 
115644:   class DrawWorker : public nsRunnable
115644:   {
115644:   public:
115644:     static DrawWorker* Singleton();
115644: 
115644:     NS_IMETHOD Run();
115644: 
115644:   /* statics */
115644:     static nsRefPtr<DrawWorker> sSingleton;
115644: 
115644:   private: /* methods */
115644:     DrawWorker() {};
115644: 
115644:     void RequestDraw(RasterImage* aImg);
115644: 
115644:   private: /* members */
115644: 
115644:     friend class RasterImage;
115644:     LinkedList<ScaleRequest> mDrawRequests;
115644:   };
115644: 
115644:   void DrawWithPreDownscaleIfNeeded(imgFrame *aFrame,
115644:                                     gfxContext *aContext,
115644:                                     gfxPattern::GraphicsFilter aFilter,
115644:                                     const gfxMatrix &aUserSpaceToImageSpace,
115644:                                     const gfxRect &aFill,
115644:                                     const nsIntRect &aSubimage);
115644: 
 89821:   /**
 82104:    * Advances the animation. Typically, this will advance a single frame, but it
 82104:    * may advance multiple frames. This may happen if we have infrequently
 82104:    * "ticking" refresh drivers (e.g. in background tabs), or extremely short-
 82104:    * lived animation frames.
 82104:    *
 82104:    * @param aTime the time that the animation should advance to. This will
 82104:    *              typically be <= TimeStamp::Now().
 82104:    *
 82104:    * @param [out] aDirtyRect a pointer to an nsIntRect which encapsulates the
 82104:    *        area to be repainted after the frame is advanced.
 82104:    *
 82104:    * @returns true, if the frame was successfully advanced, false if it was not
 82104:    *          able to be advanced (e.g. the frame to which we want to advance is
 82104:    *          still decoding). Note: If false is returned, then aDirtyRect will
 82104:    *          remain unmodified.
 82104:    */
 82104:   bool AdvanceFrame(mozilla::TimeStamp aTime, nsIntRect* aDirtyRect);
 82104: 
 82104:   /**
 39120:    * Deletes and nulls out the frame in mFrames[framenum].
 39120:    *
 39120:    * Does not change the size of mFrames.
 39120:    *
 39120:    * @param framenum The index of the frame to be deleted. 
 39120:    *                 Must lie in [0, mFrames.Length() )
 39120:    */
108991:   void DeleteImgFrame(uint32_t framenum);
 39120: 
108991:   imgFrame* GetImgFrameNoDecode(uint32_t framenum);
108991:   imgFrame* GetImgFrame(uint32_t framenum);
108991:   imgFrame* GetDrawableImgFrame(uint32_t framenum);
 30479:   imgFrame* GetCurrentImgFrame();
 34809:   imgFrame* GetCurrentDrawableImgFrame();
108991:   uint32_t GetCurrentImgFrameIndex() const;
 82104:   mozilla::TimeStamp GetCurrentImgFrameEndTime() const;
     1:   
 74720:   inline void EnsureAnimExists()
 32424:   {
 32424:     if (!mAnim) {
 32424: 
 32424:       // Create the animation context
     1:       mAnim = new Anim();
 32424: 
 32515:       // We don't support discarding animated images (See bug 414259).
 32515:       // Lock the image and throw away the key.
 32515:       // 
 32515:       // Note that this is inefficient, since we could get rid of the source
 32515:       // data too. However, doing this is actually hard, because we're probably
 32515:       // calling ensureAnimExists mid-decode, and thus we're decoding out of
 32515:       // the source buffer. Since we're going to fix this anyway later, and
 32515:       // since we didn't kill the source data in the old world either, locking
 32515:       // is acceptable for the moment.
 32515:       LockImage();
 82104: 
 82104:       // Notify our observers that we are starting animation.
 82104:       mStatusTracker->RecordImageIsAnimated();
 32424:     }
     1:   }
     1: 
     1:   /** Function for doing the frame compositing of animations
     1:    *
     1:    * @param aDirtyRect  Area that the display will need to update
     1:    * @param aPrevFrame  Last Frame seen/processed
     1:    * @param aNextFrame  Frame we need to incorperate/display
     1:    * @param aNextFrameIndex Position of aNextFrame in mFrames list
     1:    */
 80037:   nsresult DoComposite(nsIntRect* aDirtyRect,
 30479:                        imgFrame* aPrevFrame,
 30479:                        imgFrame* aNextFrame,
108991:                        int32_t aNextFrameIndex);
     1: 
  2200:   /** Clears an area of <aFrame> with transparent black.
     1:    *
     1:    * @param aFrame Target Frame
     1:    *
  2200:    * @note Does also clears the transparancy mask
     1:    */
 30479:   static void ClearFrame(imgFrame* aFrame);
  2200: 
     1:   //! @overload
 30479:   static void ClearFrame(imgFrame* aFrame, nsIntRect &aRect);
     1:   
 30479:   //! Copy one frames's image and mask into another
 79445:   static bool CopyFrameImage(imgFrame *aSrcFrame,
 30479:                                imgFrame *aDstFrame);
     1:   
 30479:   /** Draws one frames's image to into another,
  5275:    * at the position specified by aRect
  5275:    *
  5275:    * @param aSrcFrame  Frame providing the source image
  5275:    * @param aDstFrame  Frame where the image is drawn into
  5275:    * @param aRect      The position and size to draw the image
  5275:    */
 30479:   static nsresult DrawFrameTo(imgFrame *aSrcFrame,
 30479:                               imgFrame *aDstFrame,
  5275:                               nsIntRect& aRect);
  5275: 
108991:   nsresult InternalAddFrameHelper(uint32_t framenum, imgFrame *frame,
108991:                                   uint8_t **imageData, uint32_t *imageLength,
108991:                                   uint32_t **paletteData, uint32_t *paletteLength);
108991:   nsresult InternalAddFrame(uint32_t framenum, int32_t aX, int32_t aY, int32_t aWidth, int32_t aHeight,
108991:                             gfxASurface::gfxImageFormat aFormat, uint8_t aPaletteDepth,
108991:                             uint8_t **imageData, uint32_t *imageLength,
108991:                             uint32_t **paletteData, uint32_t *paletteLength);
 30479: 
108991:   bool ApplyDecodeFlags(uint32_t aNewFlags);
108318: 
115336:   already_AddRefed<layers::Image> GetCurrentImage();
115336:   void UpdateImageContainer();
115336: 
115336:   void SetInUpdateImageContainer(bool aInUpdate) { mInUpdateImageContainer = aInUpdate; }
115336:   bool IsInUpdateImageContainer() { return mInUpdateImageContainer; }
115336: 
 30479: private: // data
 30479: 
     1:   nsIntSize                  mSize;
     1: 
 60418:   // Whether mFrames below were decoded using any special flags.
 60418:   // Some flags (e.g. unpremultiplied data) may not be compatible
 60418:   // with the browser's needs for displaying the image to the user.
 60418:   // As such, we may need to redecode if we're being asked for
 60418:   // a frame with different flags.  0 indicates default flags.
 60418:   //
 60418:   // Valid flag bits are imgIContainer::FLAG_DECODE_NO_PREMULTIPLY_ALPHA
 60418:   // and imgIContainer::FLAG_DECODE_NO_COLORSPACE_CONVERSION.
108991:   uint32_t                   mFrameDecodeFlags;
 60418: 
 30479:   //! All the frames of the image
 32424:   // IMPORTANT: if you use mFrames in a method, call EnsureImageIsDecoded() first 
 32424:   // to ensure that the frames actually exist (they may have been discarded to save
 32424:   // memory, or we may be decoding on draw).
 30479:   nsTArray<imgFrame *>       mFrames;
     1:   
     1:   nsCOMPtr<nsIProperties>    mProperties;
     1: 
 32424:   // IMPORTANT: if you use mAnim in a method, call EnsureImageIsDecoded() first to ensure
 32424:   // that the frames actually exist (they may have been discarded to save memory, or
 32424:   // we maybe decoding on draw).
 50549:   RasterImage::Anim*        mAnim;
     1:   
     1:   //! # loops remaining before animation stops (-1 no stop)
108991:   int32_t                    mLoopCount;
     1:   
 32424:   //! imgIDecoderObserver
     1:   nsWeakPtr                  mObserver;
  7009: 
 32424:   // Discard members
108991:   uint32_t                   mLockCount;
 93271:   DiscardTracker::Node       mDiscardTrackerNode;
  7009: 
 32424:   // Source data members
 71472:   FallibleTArray<char>       mSourceData;
 32424:   nsCString                  mSourceDataMimeType;
 53660:   nsCString                  mURIString;
 32424: 
 50549:   friend class DiscardTracker;
 32424: 
 32424:   // Decoder and friends
 51242:   nsRefPtr<Decoder>              mDecoder;
 89821:   DecodeRequest                  mDecodeRequest;
108991:   uint32_t                       mBytesDecoded;
 32424: 
 78068:   // How many times we've decoded this image.
 78068:   // This is currently only used for statistics
108991:   int32_t                        mDecodeCount;
 78068: 
 82042:   // Cached value for GetImageContainer.
 82042:   nsRefPtr<mozilla::layers::ImageContainer> mImageContainer;
 82042: 
 52150: #ifdef DEBUG
108991:   uint32_t                       mFramesNotified;
 52150: #endif
 52150: 
 42233:   // Boolean flags (clustered together to conserve space):
 79445:   bool                       mHasSize:1;       // Has SetSize() been called?
 79445:   bool                       mDecodeOnDraw:1;  // Decoding on draw?
 79445:   bool                       mMultipart:1;     // Multipart?
 79445:   bool                       mDiscardable:1;   // Is container discardable?
 79445:   bool                       mHasSourceData:1; // Do we have source data?
 42233: 
 42233:   // Do we have the frames in decoded form?
 79445:   bool                       mDecoded:1;
 79445:   bool                       mHasBeenDecoded:1;
 42233: 
 79445:   bool                       mInDecoder:1;
 42233: 
 52149:   // Whether the animation can stop, due to running out
 52149:   // of frames, or no more owning request
 79445:   bool                       mAnimationFinished:1;
 52149: 
114209:   // Whether we're calling Decoder::Finish() from ShutdownDecoder.
114209:   bool                       mFinishing:1;
114209: 
115336:   bool                       mInUpdateImageContainer:1;
115336: 
 32424:   // Decoding
 32424:   nsresult WantDecodedFrames();
 32424:   nsresult SyncDecode();
 51244:   nsresult InitDecoder(bool aDoSizeDecode);
108991:   nsresult WriteToDecoder(const char *aBuffer, uint32_t aCount);
108991:   nsresult DecodeSomeData(uint32_t aMaxBytes);
 79445:   bool     IsDecodeFinished();
 75292:   TimeStamp mDrawStartTime;
 32424: 
115644:   inline bool CanScale(gfxPattern::GraphicsFilter aFilter, gfxSize aScale);
115644:   ScaleRequest mScaleRequest;
115644: 
 32424:   // Decoder shutdown
 32424:   enum eShutdownIntent {
 32424:     eShutdownIntent_Done        = 0,
 32424:     eShutdownIntent_Interrupted = 1,
 32424:     eShutdownIntent_Error       = 2,
 32424:     eShutdownIntent_AllCount    = 3
 32424:   };
 32424:   nsresult ShutdownDecoder(eShutdownIntent aIntent);
 32424: 
 32424:   // Helpers
 32424:   void DoError();
 74943:   bool CanDiscard();
 74943:   bool CanForciblyDiscard();
 74943:   bool DiscardingActive();
 90638:   bool StoringSourceData() const;
 32424: 
 52149: protected:
 74943:   bool ShouldAnimate();
     1: };
     1: 
 32424: // Asynchronous Decode Requestor
 32424: //
 32424: // We use this class when someone calls requestDecode() from within a decode
 32424: // notification. Since requestDecode() involves modifying the decoder's state
 32424: // (for example, possibly shutting down a header-only decode and starting a
 32424: // full decode), we don't want to do this from inside a decoder.
 32424: class imgDecodeRequestor : public nsRunnable
 32424: {
 32424:   public:
 32424:     imgDecodeRequestor(imgIContainer *aContainer) {
 32424:       mContainer = do_GetWeakReference(aContainer);
 32424:     }
 32424:     NS_IMETHOD Run() {
 32424:       nsCOMPtr<imgIContainer> con = do_QueryReferent(mContainer);
 32424:       if (con)
 32424:         con->RequestDecode();
 32424:       return NS_OK;
 32424:     }
 32424: 
 32424:   private:
 32424:     nsWeakPtr mContainer;
 32424: };
 32424: 
 87852: } // namespace image
 50549: } // namespace mozilla
 32424: 
 50549: #endif /* mozilla_imagelib_RasterImage_h_ */
