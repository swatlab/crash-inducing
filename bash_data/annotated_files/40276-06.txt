    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
34352:  * vim: set ts=4 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsinterp_h___
    1: #define jsinterp_h___
    1: /*
    1:  * JS interpreter interface.
    1:  */
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
16072: #include "jsfun.h"
11377: #include "jsopcode.h"
16072: #include "jsscript.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
13168: typedef struct JSFrameRegs {
13168:     jsbytecode      *pc;            /* program counter */
13168:     jsval           *sp;            /* stack pointer */
13168: } JSFrameRegs;
13168: 
37777: 
    1: /*
    1:  * JS stack frame, may be allocated on the C stack by native callers.  Always
    1:  * allocated on cx->stackPool for calls from the interpreter to an interpreted
    1:  * function.
    1:  *
    1:  * NB: This struct is manually initialized in jsinterp.c and jsiter.c.  If you
    1:  * add new members, update both files.  But first, try to remove members.  The
    1:  * sharp* and xml* members should be moved onto the stack as local variables
    1:  * with well-known slots, if possible.
    1:  */
    1: struct JSStackFrame {
13168:     JSFrameRegs     *regs;
21685:     jsbytecode      *imacpc;        /* null or interpreter macro call pc */
16072:     jsval           *slots;         /* variables, locals and operand stack */
    1:     JSObject        *callobj;       /* lazily created Call object */
31823:     jsval           argsobj;        /* lazily created arguments object, must be
31823:                                        JSVAL_OBJECT */
    1:     JSScript        *script;        /* script being interpreted */
    1:     JSFunction      *fun;           /* function being called or null */
32774:     jsval           thisv;          /* "this" pointer if in method */
    1:     uintN           argc;           /* actual argument count */
    1:     jsval           *argv;          /* base of argument stack slots */
    1:     jsval           rval;           /* function return value */
    1:     JSStackFrame    *down;          /* previous frame */
    1:     void            *annotation;    /* used by Java security */
26238: 
26238:     /*
26238:      * We can't determine in advance which local variables can live on
26238:      * the stack and be freed when their dynamic scope ends, and which
26238:      * will be closed over and need to live in the heap.  So we place
26238:      * variables on the stack initially, note when they are closed
26238:      * over, and copy those that are out to the heap when we leave
26238:      * their dynamic scope.
26238:      *
26238:      * The bytecode compiler produces a tree of block objects
26238:      * accompanying each JSScript representing those lexical blocks in
26238:      * the script that have let-bound variables associated with them.
26238:      * These block objects are never modified, and never become part
26238:      * of any function's scope chain.  Their parent slots point to the
26238:      * innermost block that encloses them, or are NULL in the
26238:      * outermost blocks within a function or in eval or global code.
26238:      *
26238:      * When we are in the static scope of such a block, blockChain
26238:      * points to its compiler-allocated block object; otherwise, it is
26238:      * NULL.
26238:      *
26238:      * scopeChain is the current scope chain, including 'call' and
26238:      * 'block' objects for those function calls and lexical blocks
26238:      * whose static scope we are currently executing in, and 'with'
26238:      * objects for with statements; the chain is typically terminated
26238:      * by a global object.  However, as an optimization, the young end
26238:      * of the chain omits block objects we have not yet cloned.  To
26238:      * create a closure, we clone the missing blocks from blockChain
26238:      * (which is always current), place them at the head of
26238:      * scopeChain, and use that for the closure's scope chain.  If we
26238:      * never close over a lexical block, we never place a mutable
26238:      * clone of it on scopeChain.
26238:      *
26238:      * This lazy cloning is implemented in js_GetScopeChain, which is
26238:      * also used in some other cases --- entering 'with' blocks, for
26238:      * example.
26238:      */
39911:     union {
26238:         JSObject    *scopeChain;
39911:         jsval       scopeChainVal;
39911:     };
26238:     JSObject        *blockChain;
26238: 
    1:     uint32          flags;          /* frame flags -- see below */
18308:     JSStackFrame    *displaySave;   /* previous value of display entry for
27012:                                        script->staticLevel */
27234: 
27239:     inline void assertValidStackDepth(uintN depth);
31447: 
31823:     void putActivationObjects(JSContext *cx) {
31447:         /*
31447:          * The order of calls here is important as js_PutCallObject needs to
31447:          * access argsobj.
31447:          */
31447:         if (callobj) {
31823:             js_PutCallObject(cx, this);
31447:             JS_ASSERT(!argsobj);
31447:         } else if (argsobj) {
31823:             js_PutArgsObject(cx, this);
31447:         }
31447:     }
31939: 
34352:     jsval calleeValue() {
34352:         JS_ASSERT(argv);
34352:         return argv[-2];
34352:     }
34352: 
34352:     JSObject *calleeObject() {
34352:         JS_ASSERT(argv);
34352:         return JSVAL_TO_OBJECT(argv[-2]);
34352:     }
34352: 
31939:     JSObject *callee() {
31939:         return argv ? JSVAL_TO_OBJECT(argv[-2]) : NULL;
31939:     }
37777: 
37777:     /*
37777:      * Get the object associated with the Execution Context's
37777:      * VariableEnvironment (ES5 10.3). The given CallStack must contain this
37777:      * stack frame.
37777:      */
37777:     JSObject *varobj(js::CallStack *cs);
37777: 
37777:     /* Short for: varobj(cx->activeCallStack()). */
37777:     JSObject *varobj(JSContext *cx);
    1: };
    1: 
21685: #ifdef __cplusplus
21685: static JS_INLINE uintN
21685: FramePCOffset(JSStackFrame* fp)
21685: {
21685:     return uintN((fp->imacpc ? fp->imacpc : fp->regs->pc) - fp->script->code);
21685: }
21685: #endif
21685: 
16284: static JS_INLINE jsval *
16072: StackBase(JSStackFrame *fp)
16072: {
16072:     return fp->slots + fp->script->nfixed;
16072: }
16072: 
39928: #ifdef DEBUG
27239: void
27239: JSStackFrame::assertValidStackDepth(uintN depth)
27239: {
27239:     JS_ASSERT(0 <= regs->sp - StackBase(this));
27239:     JS_ASSERT(depth <= uintptr_t(regs->sp - StackBase(this)));
27239: }
39928: #else
39928: void
39928: JSStackFrame::assertValidStackDepth(uintN /*depth*/){}
39928: #endif
27239: 
16284: static JS_INLINE uintN
16072: GlobalVarCount(JSStackFrame *fp)
16072: {
16072:     JS_ASSERT(!fp->fun);
37029:     return fp->script->nfixed;
16072: }
16072: 
    1: typedef struct JSInlineFrame {
    1:     JSStackFrame    frame;          /* base struct */
13168:     JSFrameRegs     callerRegs;     /* parent's frame registers */
    1:     void            *mark;          /* mark before inline frame */
    1:     void            *hookData;      /* debugger call hook data */
    1:     JSVersion       callerVersion;  /* dynamic version of calling script */
    1: } JSInlineFrame;
    1: 
    1: /* JS stack frame flags. */
    1: #define JSFRAME_CONSTRUCTING   0x01 /* frame is for a constructor invocation */
32774: #define JSFRAME_COMPUTED_THIS  0x02 /* frame.thisv was computed already and
32774:                                        JSVAL_IS_OBJECT(thisv) */
 6040: #define JSFRAME_ASSIGNING      0x04 /* a complex (not simplex JOF_ASSIGNING) op
    1:                                        is currently assigning to a property */
 6040: #define JSFRAME_DEBUGGER       0x08 /* frame for JS_EvaluateInStackFrame */
 6040: #define JSFRAME_EVAL           0x10 /* frame for obj_eval */
18955: #define JSFRAME_ROOTED_ARGV    0x20 /* frame.argv is rooted by the caller */
 8444: #define JSFRAME_YIELDING       0x40 /* js_Interpret dispatched JSOP_YIELD */
11672: #define JSFRAME_ITERATOR       0x80 /* trying to get an iterator for for-in */
11672: #define JSFRAME_GENERATOR     0x200 /* frame belongs to generator-iterator */
31823: #define JSFRAME_OVERRIDE_ARGS 0x400 /* overridden arguments local variable */
    1: 
 8444: #define JSFRAME_SPECIAL       (JSFRAME_DEBUGGER | JSFRAME_EVAL)
 8444: 
11377: /*
33123:  * Property cache with structurally typed capabilities for invalidation, for
33123:  * polymorphic callsite method/get/set speedups.  For details, see
33123:  * <https://developer.mozilla.org/en/SpiderMonkey/Internals/Property_cache>.
33123:  */
33123: #define PROPERTY_CACHE_LOG2     12
33123: #define PROPERTY_CACHE_SIZE     JS_BIT(PROPERTY_CACHE_LOG2)
33123: #define PROPERTY_CACHE_MASK     JS_BITMASK(PROPERTY_CACHE_LOG2)
33123: 
33123: /*
33123:  * Add kshape rather than xor it to avoid collisions between nearby bytecode
33123:  * that are evolving an object by setting successive properties, incrementing
33123:  * the object's scope->shape on each set.
33123:  */
33123: #define PROPERTY_CACHE_HASH(pc,kshape)                                        \
33123:     (((((jsuword)(pc) >> PROPERTY_CACHE_LOG2) ^ (jsuword)(pc)) + (kshape)) &  \
33123:      PROPERTY_CACHE_MASK)
33123: 
33123: #define PROPERTY_CACHE_HASH_PC(pc,kshape)                                     \
33123:     PROPERTY_CACHE_HASH(pc, kshape)
33123: 
33123: #define PROPERTY_CACHE_HASH_ATOM(atom,obj)                                    \
33123:     PROPERTY_CACHE_HASH((jsuword)(atom) >> 2, OBJ_SHAPE(obj))
33123: 
33123: /*
33123:  * Property cache value capability macros.
33123:  */
33123: #define PCVCAP_PROTOBITS        4
33123: #define PCVCAP_PROTOSIZE        JS_BIT(PCVCAP_PROTOBITS)
33123: #define PCVCAP_PROTOMASK        JS_BITMASK(PCVCAP_PROTOBITS)
33123: 
33123: #define PCVCAP_SCOPEBITS        4
33123: #define PCVCAP_SCOPESIZE        JS_BIT(PCVCAP_SCOPEBITS)
33123: #define PCVCAP_SCOPEMASK        JS_BITMASK(PCVCAP_SCOPEBITS)
33123: 
33123: #define PCVCAP_TAGBITS          (PCVCAP_PROTOBITS + PCVCAP_SCOPEBITS)
33123: #define PCVCAP_TAGMASK          JS_BITMASK(PCVCAP_TAGBITS)
33123: #define PCVCAP_TAG(t)           ((t) & PCVCAP_TAGMASK)
33123: 
33123: #define PCVCAP_MAKE(t,s,p)      ((uint32(t) << PCVCAP_TAGBITS) |              \
33123:                                  ((s) << PCVCAP_PROTOBITS) |                  \
33123:                                  (p))
33123: #define PCVCAP_SHAPE(t)         ((t) >> PCVCAP_TAGBITS)
33123: 
33123: #define SHAPE_OVERFLOW_BIT      JS_BIT(32 - PCVCAP_TAGBITS)
33123: 
33123: struct JSPropCacheEntry {
33123:     jsbytecode          *kpc;           /* pc if vcap tag is <= 1, else atom */
33123:     jsuword             kshape;         /* key shape if pc, else obj for atom */
33123:     jsuword             vcap;           /* value capability, see above */
33123:     jsuword             vword;          /* value word, see PCVAL_* below */
33123: 
33123:     bool adding() const {
33123:         return PCVCAP_TAG(vcap) == 0 && kshape != PCVCAP_SHAPE(vcap);
33123:     }
33123: 
33123:     bool directHit() const {
33123:         return PCVCAP_TAG(vcap) == 0 && kshape == PCVCAP_SHAPE(vcap);
33123:     }
33123: };
33123: 
33123: /*
33123:  * Special value for functions returning JSPropCacheEntry * to distinguish
33123:  * between failure and no no-cache-fill cases.
33123:  */
33123: #define JS_NO_PROP_CACHE_FILL ((JSPropCacheEntry *) NULL + 1)
33123: 
33123: #if defined DEBUG_brendan || defined DEBUG_brendaneich
33123: #define JS_PROPERTY_CACHE_METERING 1
33123: #endif
33123: 
33123: typedef struct JSPropertyCache {
33123:     JSPropCacheEntry    table[PROPERTY_CACHE_SIZE];
33123:     JSBool              empty;
33123: #ifdef JS_PROPERTY_CACHE_METERING
33123:     JSPropCacheEntry    *pctestentry;   /* entry of the last PC-based test */
33123:     uint32              fills;          /* number of cache entry fills */
33123:     uint32              nofills;        /* couldn't fill (e.g. default get) */
33123:     uint32              rofills;        /* set on read-only prop can't fill */
33123:     uint32              disfills;       /* fill attempts on disabled cache */
33123:     uint32              oddfills;       /* fill attempt after setter deleted */
33123:     uint32              modfills;       /* fill that rehashed to a new entry */
33123:     uint32              brandfills;     /* scope brandings to type structural
33123:                                            method fills */
33123:     uint32              noprotos;       /* resolve-returned non-proto pobj */
33123:     uint32              longchains;     /* overlong scope and/or proto chain */
33123:     uint32              recycles;       /* cache entries recycled by fills */
33123:     uint32              pcrecycles;     /* pc-keyed entries recycled by atom-
33123:                                            keyed fills */
33123:     uint32              tests;          /* cache probes */
33123:     uint32              pchits;         /* fast-path polymorphic op hits */
33123:     uint32              protopchits;    /* pchits hitting immediate prototype */
33123:     uint32              initests;       /* cache probes from JSOP_INITPROP */
33123:     uint32              inipchits;      /* init'ing next property pchit case */
33123:     uint32              inipcmisses;    /* init'ing next property pc misses */
33123:     uint32              settests;       /* cache probes from JOF_SET opcodes */
33123:     uint32              addpchits;      /* adding next property pchit case */
33123:     uint32              setpchits;      /* setting existing property pchit */
33123:     uint32              setpcmisses;    /* setting/adding property pc misses */
33123:     uint32              setmisses;      /* JSOP_SET{NAME,PROP} total misses */
33123:     uint32              idmisses;       /* slow-path key id == atom misses */
33123:     uint32              komisses;       /* slow-path key object misses */
33123:     uint32              vcmisses;       /* value capability misses */
33123:     uint32              misses;         /* cache misses */
33123:     uint32              flushes;        /* cache flushes */
33123:     uint32              pcpurges;       /* shadowing purges on proto chain */
33123: # define PCMETER(x)     x
33123: #else
33123: # define PCMETER(x)     ((void)0)
33123: #endif
33123: } JSPropertyCache;
33123: 
33123: /*
33123:  * Property cache value tagging/untagging macros.
33123:  */
33123: #define PCVAL_OBJECT            0
33123: #define PCVAL_SLOT              1
33123: #define PCVAL_SPROP             2
33123: 
33123: #define PCVAL_TAGBITS           2
33123: #define PCVAL_TAGMASK           JS_BITMASK(PCVAL_TAGBITS)
33123: #define PCVAL_TAG(v)            ((v) & PCVAL_TAGMASK)
33123: #define PCVAL_CLRTAG(v)         ((v) & ~(jsuword)PCVAL_TAGMASK)
33123: #define PCVAL_SETTAG(v,t)       ((jsuword)(v) | (t))
33123: 
33123: #define PCVAL_NULL              0
33123: #define PCVAL_IS_NULL(v)        ((v) == PCVAL_NULL)
33123: 
33123: #define PCVAL_IS_OBJECT(v)      (PCVAL_TAG(v) == PCVAL_OBJECT)
33123: #define PCVAL_TO_OBJECT(v)      ((JSObject *) (v))
33123: #define OBJECT_TO_PCVAL(obj)    ((jsuword) (obj))
33123: 
33123: #define PCVAL_OBJECT_TO_JSVAL(v) OBJECT_TO_JSVAL(PCVAL_TO_OBJECT(v))
33123: #define JSVAL_OBJECT_TO_PCVAL(v) OBJECT_TO_PCVAL(JSVAL_TO_OBJECT(v))
33123: 
33123: #define PCVAL_IS_SLOT(v)        ((v) & PCVAL_SLOT)
33123: #define PCVAL_TO_SLOT(v)        ((jsuint)(v) >> 1)
33123: #define SLOT_TO_PCVAL(i)        (((jsuword)(i) << 1) | PCVAL_SLOT)
33123: 
33123: #define PCVAL_IS_SPROP(v)       (PCVAL_TAG(v) == PCVAL_SPROP)
33123: #define PCVAL_TO_SPROP(v)       ((JSScopeProperty *) PCVAL_CLRTAG(v))
33123: #define SPROP_TO_PCVAL(sprop)   PCVAL_SETTAG(sprop, PCVAL_SPROP)
33123: 
38504: inline bool
38504: js_MatchPropertyCacheShape(JSContext *cx, JSObject *obj, uint32 shape);
38504: 
33123: /*
33123:  * Fill property cache entry for key cx->fp->pc, optimized value word computed
33123:  * from obj and sprop, and entry capability forged from 24-bit OBJ_SHAPE(obj),
33123:  * 4-bit scopeIndex, and 4-bit protoIndex.
33123:  *
33123:  * Return the filled cache entry or JS_NO_PROP_CACHE_FILL if caching was not
33123:  * possible.
33123:  */
33123: extern JS_REQUIRES_STACK JSPropCacheEntry *
33123: js_FillPropertyCache(JSContext *cx, JSObject *obj,
33123:                      uintN scopeIndex, uintN protoIndex, JSObject *pobj,
33123:                      JSScopeProperty *sprop, JSBool adding);
33123: 
33123: /*
33123:  * Property cache lookup macros. PROPERTY_CACHE_TEST is designed to inline the
33123:  * fast path in js_Interpret, so it makes "just-so" restrictions on parameters,
33123:  * e.g. pobj and obj should not be the same variable, since for JOF_PROP-mode
33123:  * opcodes, obj must not be changed because of a cache miss.
33123:  *
33123:  * On return from PROPERTY_CACHE_TEST, if atom is null then obj points to the
33123:  * scope chain element in which the property was found, pobj is locked, and
33123:  * entry is valid. If atom is non-null then no object is locked but entry is
33123:  * still set correctly for use, e.g., by js_FillPropertyCache and atom should
33123:  * be used as the id to find.
33123:  *
33123:  * We must lock pobj on a hit in order to close races with threads that might
33123:  * be deleting a property from its scope, or otherwise invalidating property
33123:  * caches (on all threads) by re-generating scope->shape.
33123:  */
33123: #define PROPERTY_CACHE_TEST(cx, pc, obj, pobj, entry, atom)                   \
33123:     do {                                                                      \
33123:         JSPropertyCache *cache_ = &JS_PROPERTY_CACHE(cx);                     \
33123:         uint32 kshape_ = (JS_ASSERT(OBJ_IS_NATIVE(obj)), OBJ_SHAPE(obj));     \
33123:         entry = &cache_->table[PROPERTY_CACHE_HASH_PC(pc, kshape_)];          \
33123:         PCMETER(cache_->pctestentry = entry);                                 \
33123:         PCMETER(cache_->tests++);                                             \
33123:         JS_ASSERT(&obj != &pobj);                                             \
33123:         if (entry->kpc == pc && entry->kshape == kshape_) {                   \
33123:             JSObject *tmp_;                                                   \
33123:             pobj = obj;                                                       \
33123:             JS_ASSERT(PCVCAP_TAG(entry->vcap) <= 1);                          \
33123:             if (PCVCAP_TAG(entry->vcap) == 1 &&                               \
39928:                 (tmp_ = pobj->getProto()) != NULL) {                          \
33123:                 pobj = tmp_;                                                  \
33123:             }                                                                 \
33123:                                                                               \
38504:             if (js_MatchPropertyCacheShape(cx,pobj,PCVCAP_SHAPE(entry->vcap))){\
33123:                 PCMETER(cache_->pchits++);                                    \
33123:                 PCMETER(!PCVCAP_TAG(entry->vcap) || cache_->protopchits++);   \
33123:                 atom = NULL;                                                  \
33123:                 break;                                                        \
33123:             }                                                                 \
33123:         }                                                                     \
33123:         atom = js_FullTestPropertyCache(cx, pc, &obj, &pobj, &entry);         \
33123:         if (atom)                                                             \
33123:             PCMETER(cache_->misses++);                                        \
33123:     } while (0)
33123: 
33123: extern JS_REQUIRES_STACK JSAtom *
33123: js_FullTestPropertyCache(JSContext *cx, jsbytecode *pc,
33123:                          JSObject **objp, JSObject **pobjp,
33123:                          JSPropCacheEntry **entryp);
33123: 
33123: /* The property cache does not need a destructor. */
33123: #define js_FinishPropertyCache(cache) ((void) 0)
33123: 
33123: extern void
33123: js_PurgePropertyCache(JSContext *cx, JSPropertyCache *cache);
33123: 
33123: extern void
33123: js_PurgePropertyCacheForScript(JSContext *cx, JSScript *script);
33123: 
33123: /*
11377:  * Interpreter stack arena-pool alloc and free functions.
11377:  */
24499: extern JS_REQUIRES_STACK JS_FRIEND_API(jsval *)
    1: js_AllocStack(JSContext *cx, uintN nslots, void **markp);
    1: 
24499: extern JS_REQUIRES_STACK JS_FRIEND_API(void)
    1: js_FreeStack(JSContext *cx, void *mark);
    1: 
    1: /*
    1:  * Refresh and return fp->scopeChain.  It may be stale if block scopes are
    1:  * active but not yet reflected by objects in the scope chain.  If a block
    1:  * scope contains a with, eval, XML filtering predicate, or similar such
    1:  * dynamically scoped construct, then compile-time block scope at fp->blocks
    1:  * must reflect at runtime.
    1:  */
    1: extern JSObject *
    1: js_GetScopeChain(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /*
 4127:  * Given a context and a vector of [callee, this, args...] for a function that
 4127:  * was specified with a JSFUN_THISP_PRIMITIVE flag, get the primitive value of
 4127:  * |this| into *thisvp. In doing so, if |this| is an object, insist it is an
 4127:  * instance of clasp and extract its private slot value to return via *thisvp.
 4127:  *
 4127:  * NB: this function loads and uses *vp before storing *thisvp, so the two may
 4127:  * alias the same jsval.
 4127:  */
 4127: extern JSBool
 4127: js_GetPrimitiveThis(JSContext *cx, jsval *vp, JSClass *clasp, jsval *thisvp);
 4127: 
 4127: /*
 2383:  * For a call with arguments argv including argv[-1] (nominal |this|) and
 2383:  * argv[-2] (callee) replace null |this| with callee's parent, replace
 2383:  * primitive values with the equivalent wrapper objects and censor activation
 2383:  * objects as, per ECMA-262, they may not be referred to by |this|. argv[-1]
 2383:  * must not be a JSVAL_VOID.
    1:  */
11774: extern JSObject *
11774: js_ComputeThis(JSContext *cx, JSBool lazy, jsval *argv);
    1: 
12551: extern const uint16 js_PrimitiveTestFlags[];
12551: 
12551: #define PRIMITIVE_THIS_TEST(fun,thisv)                                        \
15521:     (JS_ASSERT(!JSVAL_IS_VOID(thisv)),                                        \
13702:      JSFUN_THISP_TEST(JSFUN_THISP_FLAGS((fun)->flags),                        \
12551:                       js_PrimitiveTestFlags[JSVAL_TAG(thisv) - 1]))
12551: 
30597: #ifdef __cplusplus /* Aargh, libgjs, bug 492720. */
30597: static JS_INLINE JSObject *
27470: js_ComputeThisForFrame(JSContext *cx, JSStackFrame *fp)
27470: {
27470:     if (fp->flags & JSFRAME_COMPUTED_THIS)
32774:         return JSVAL_TO_OBJECT(fp->thisv);  /* JSVAL_COMPUTED_THIS invariant */
27470:     JSObject* obj = js_ComputeThis(cx, JS_TRUE, fp->argv);
27470:     if (!obj)
27470:         return NULL;
32774:     fp->thisv = OBJECT_TO_JSVAL(obj);
27470:     fp->flags |= JSFRAME_COMPUTED_THIS;
27470:     return obj;
27470: }
30597: #endif
27470: 
12551: /*
    1:  * NB: js_Invoke requires that cx is currently running JS (i.e., that cx->fp
 6040:  * is non-null), and that vp points to the callee, |this| parameter, and
 6040:  * actual arguments of the call. [vp .. vp + 2 + argc) must belong to the last
11758:  * JS stack segment that js_AllocStack allocated. The function may use the
11758:  * space available after vp + 2 + argc in the stack segment for temporaries,
11758:  * so the caller should not use that space for values that must be preserved
11758:  * across the call.
    1:  */
24499: extern JS_REQUIRES_STACK JS_FRIEND_API(JSBool)
 6040: js_Invoke(JSContext *cx, uintN argc, jsval *vp, uintN flags);
    1: 
    1: /*
    1:  * Consolidated js_Invoke flags simply rename certain JSFRAME_* flags, so that
    1:  * we can share bits stored in JSStackFrame.flags and passed to:
    1:  *
    1:  *   js_Invoke
    1:  *   js_InternalInvoke
    1:  *   js_ValueToFunction
    1:  *   js_ValueToFunctionObject
    1:  *   js_ValueToCallableObject
    1:  *   js_ReportIsNotFunction
    1:  *
    1:  * See jsfun.h for the latter four and flag renaming macros.
    1:  */
    1: #define JSINVOKE_CONSTRUCT      JSFRAME_CONSTRUCTING
    1: #define JSINVOKE_ITERATOR       JSFRAME_ITERATOR
    1: 
    1: /*
    1:  * Mask to isolate construct and iterator flags for use with jsfun.h functions.
    1:  */
    1: #define JSINVOKE_FUNFLAGS       (JSINVOKE_CONSTRUCT | JSINVOKE_ITERATOR)
    1: 
    1: /*
    1:  * "Internal" calls may come from C or C++ code using a JSContext on which no
    1:  * JS is running (!cx->fp), so they may need to push a dummy JSStackFrame.
    1:  */
    1: #define js_InternalCall(cx,obj,fval,argc,argv,rval)                           \
    1:     js_InternalInvoke(cx, obj, fval, 0, argc, argv, rval)
    1: 
    1: #define js_InternalConstruct(cx,obj,fval,argc,argv,rval)                      \
    1:     js_InternalInvoke(cx, obj, fval, JSINVOKE_CONSTRUCT, argc, argv, rval)
    1: 
    1: extern JSBool
    1: js_InternalInvoke(JSContext *cx, JSObject *obj, jsval fval, uintN flags,
    1:                   uintN argc, jsval *argv, jsval *rval);
    1: 
    1: extern JSBool
    1: js_InternalGetOrSet(JSContext *cx, JSObject *obj, jsid id, jsval fval,
    1:                     JSAccessMode mode, uintN argc, jsval *argv, jsval *rval);
    1: 
28134: extern JS_FORCES_STACK JSBool
    1: js_Execute(JSContext *cx, JSObject *chain, JSScript *script,
    1:            JSStackFrame *down, uintN flags, jsval *result);
    1: 
24499: extern JS_REQUIRES_STACK JSBool
19577: js_InvokeConstructor(JSContext *cx, uintN argc, JSBool clampReturn, jsval *vp);
12551: 
22652: extern JS_REQUIRES_STACK JSBool
12688: js_Interpret(JSContext *cx);
12551: 
12551: #define JSPROP_INITIALIZER 0x100   /* NB: Not a valid property attribute. */
12551: 
12551: extern JSBool
    1: js_CheckRedeclaration(JSContext *cx, JSObject *obj, jsid id, uintN attrs,
    1:                       JSObject **objp, JSProperty **propp);
    1: 
    1: extern JSBool
 9560: js_StrictlyEqual(JSContext *cx, jsval lval, jsval rval);
    1: 
32760: /* === except that NaN is the same as NaN and -0 is not the same as +0. */
32760: extern JSBool
32760: js_SameValue(jsval v1, jsval v2, JSContext *cx);
32760: 
26280: extern JSBool
26280: js_InternNonIntElementId(JSContext *cx, JSObject *obj, jsval idval, jsid *idp);
26280: 
15996: /*
27169:  * Given an active context, a static scope level, and an upvar cookie, return
27169:  * the value of the upvar.
27169:  */
28275: extern jsval&
27169: js_GetUpvar(JSContext *cx, uintN level, uintN cookie);
27169: 
27169: /*
15996:  * JS_LONE_INTERPRET indicates that the compiler should see just the code for
15996:  * the js_Interpret function when compiling jsinterp.cpp. The rest of the code
15996:  * from the file should be visible only when compiling jsinvoke.cpp. It allows
15996:  * platform builds to optimize selectively js_Interpret when the granularity
15996:  * of the optimizations with the given compiler is a compilation unit.
15996:  *
15996:  * JS_STATIC_INTERPRET is the modifier for functions defined in jsinterp.cpp
15996:  * that only js_Interpret calls. When JS_LONE_INTERPRET is true all such
15996:  * functions are declared below.
15996:  */
15996: #ifndef JS_LONE_INTERPRET
15996: # ifdef _MSC_VER
15996: #  define JS_LONE_INTERPRET 0
15996: # else
15996: #  define JS_LONE_INTERPRET 1
15996: # endif
15996: #endif
15996: 
33933: #define JS_MAX_INLINE_CALL_COUNT 3000
33933: 
15996: #if !JS_LONE_INTERPRET
15996: # define JS_STATIC_INTERPRET    static
15996: #else
15996: # define JS_STATIC_INTERPRET
15996: 
24499: extern JS_REQUIRES_STACK jsval *
15996: js_AllocRawStack(JSContext *cx, uintN nslots, void **markp);
15996: 
24499: extern JS_REQUIRES_STACK void
15996: js_FreeRawStack(JSContext *cx, void *mark);
15996: 
15996: /*
15996:  * ECMA requires "the global object", but in embeddings such as the browser,
15996:  * which have multiple top-level objects (windows, frames, etc. in the DOM),
15996:  * we prefer fun's parent.  An example that causes this code to run:
15996:  *
15996:  *   // in window w1
15996:  *   function f() { return this }
15996:  *   function g() { return f }
15996:  *
15996:  *   // in window w2
15996:  *   var h = w1.g()
15996:  *   alert(h() == w1)
15996:  *
15996:  * The alert should display "true".
15996:  */
15996: extern JSObject *
15996: js_ComputeGlobalThis(JSContext *cx, JSBool lazy, jsval *argv);
15996: 
22652: extern JS_REQUIRES_STACK JSBool
12551: js_EnterWith(JSContext *cx, jsint stackIndex);
12551: 
22652: extern JS_REQUIRES_STACK void
12551: js_LeaveWith(JSContext *cx);
12551: 
22652: extern JS_REQUIRES_STACK JSClass *
12551: js_IsActiveWithOrBlock(JSContext *cx, JSObject *obj, int stackDepth);
12551: 
12551: /*
12551:  * Unwind block and scope chains to match the given depth. The function sets
12551:  * fp->sp on return to stackDepth.
12551:  */
22652: extern JS_REQUIRES_STACK JSBool
12551: js_UnwindScope(JSContext *cx, JSStackFrame *fp, jsint stackDepth,
12551:                JSBool normalUnwind);
    1: 
    1: extern JSBool
12579: js_OnUnknownMethod(JSContext *cx, jsval *vp);
12579: 
12551: /*
12611:  * Find the results of incrementing or decrementing *vp. For pre-increments,
12611:  * both *vp and *vp2 will contain the result on return. For post-increments,
12611:  * vp will contain the original value converted to a number and vp2 will get
12611:  * the result. Both vp and vp2 must be roots.
12611:  */
12611: extern JSBool
12611: js_DoIncDec(JSContext *cx, const JSCodeSpec *cs, jsval *vp, jsval *vp2);
12611: 
12611: /*
15453:  * Opcode tracing helper. When len is not 0, cx->fp->regs->pc[-len] gives the
15453:  * previous opcode.
15453:  */
22652: extern JS_REQUIRES_STACK void
26954: js_TraceOpcode(JSContext *cx);
15453: 
15453: /*
12551:  * JS_OPMETER helper functions.
12551:  */
12551: extern void
12551: js_MeterOpcodePair(JSOp op1, JSOp op2);
12551: 
12551: extern void
12551: js_MeterSlotOpcode(JSOp op, uint32 slot);
    1: 
15996: #endif /* JS_LONE_INTERPRET */
15996: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jsinterp_h___ */
