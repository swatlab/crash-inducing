11914: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
11914: /* vim: set ts=2 sw=2 et tw=80: */
11914: /* ***** BEGIN LICENSE BLOCK *****
11914:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
11914:  *
11914:  * The contents of this file are subject to the Mozilla Public License Version
11914:  * 1.1 (the "License"); you may not use this file except in compliance with
11914:  * the License. You may obtain a copy of the License at
11914:  * http://www.mozilla.org/MPL/
11914:  *
11914:  * Software distributed under the License is distributed on an "AS IS" basis,
11914:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
11914:  * for the specific language governing rights and limitations under the
11914:  * License.
11914:  *
11914:  * The Original Code is mozilla.org code.
11914:  *
11914:  * The Initial Developer of the Original Code is
11914:  * Mozilla Japan.
11914:  * Portions created by the Initial Developer are Copyright (C) 2008
11914:  * the Initial Developer. All Rights Reserved.
11914:  *
11914:  * Contributor(s):
11914:  *   Masayuki Nakano <masayuki@d-toybox.com>
24836:  *   Ningjie Chen <chenn@email.uc.edu>
11914:  *
11914:  * Alternatively, the contents of this file may be used under the terms of
11914:  * either of the GNU General Public License Version 2 or later (the "GPL"),
11914:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
11914:  * in which case the provisions of the GPL or the LGPL are applicable instead
11914:  * of those above. If you wish to allow use of your version of this file only
11914:  * under the terms of either the GPL or the LGPL, and not to allow others to
11914:  * use your version of this file under the terms of the MPL, indicate your
11914:  * decision by deleting the provisions above and replace them with the notice
11914:  * and other provisions required by the GPL or the LGPL. If you do not delete
11914:  * the provisions above, a recipient may use your version of this file under
11914:  * the terms of any one of the MPL, the GPL or the LGPL.
11914:  *
11914:  * ***** END LICENSE BLOCK ***** */
11914: 
24836: #include "nsContentEventHandler.h"
11914: #include "nsCOMPtr.h"
11914: #include "nsPresContext.h"
11914: #include "nsIPresShell.h"
11914: #include "nsISelection.h"
11914: #include "nsIDOMRange.h"
11914: #include "nsRange.h"
11914: #include "nsGUIEvent.h"
15969: #include "nsCaret.h"
26757: #include "nsCopySupport.h"
11914: #include "nsFrameSelection.h"
11914: #include "nsIFrame.h"
11914: #include "nsIView.h"
11914: #include "nsIContentIterator.h"
11914: #include "nsTextFragment.h"
11914: #include "nsTextFrame.h"
24836: #include "nsISelectionController.h"
24836: #include "nsISelectionPrivate.h"
24836: #include "nsContentUtils.h"
28352: #include "nsLayoutUtils.h"
24836: #include "nsIMEStateManager.h"
63215: #include "nsIObjectFrame.h"
11914: 
11914: nsresult NS_NewContentIterator(nsIContentIterator** aInstancePtrResult);
11914: 
11914: /******************************************************************/
24836: /* nsContentEventHandler                                          */
11914: /******************************************************************/
11914: 
24836: nsContentEventHandler::nsContentEventHandler(
11914:                               nsPresContext* aPresContext) :
11914:   mPresContext(aPresContext),
11914:   mPresShell(aPresContext->GetPresShell()), mSelection(nsnull),
11914:   mFirstSelectedRange(nsnull), mRootContent(nsnull)
11914: {
11914: }
11914: 
11914: nsresult
39629: nsContentEventHandler::InitCommon()
11914: {
11914:   if (mSelection)
11914:     return NS_OK;
11914: 
39629:   NS_ENSURE_TRUE(mPresShell, NS_ERROR_NOT_AVAILABLE);
11914: 
26883:   // If text frame which has overflowing selection underline is dirty,
26883:   // we need to flush the pending reflow here.
39668:   mPresShell->FlushPendingNotifications(Flush_Layout);
26883: 
48929:   // Flushing notifications can cause mPresShell to be destroyed (bug 577963).
48929:   NS_ENSURE_TRUE(!mPresShell->IsDestroying(), NS_ERROR_FAILURE);
48929: 
39646:   nsCopySupport::GetSelectionForCopy(mPresShell->GetDocument(),
39646:                                      getter_AddRefs(mSelection));
26757: 
11914:   nsCOMPtr<nsIDOMRange> firstRange;
39668:   nsresult rv = mSelection->GetRangeAt(0, getter_AddRefs(firstRange));
11914:   // This shell doesn't support selection.
11914:   if (NS_FAILED(rv))
11914:     return NS_ERROR_NOT_AVAILABLE;
86939:   mFirstSelectedRange = static_cast<nsRange*>(firstRange.get());
11914: 
11914:   nsINode* startNode = mFirstSelectedRange->GetStartParent();
11914:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
36868:   nsINode* endNode = mFirstSelectedRange->GetEndParent();
36868:   NS_ENSURE_TRUE(endNode, NS_ERROR_FAILURE);
36868: 
36868:   // See bug 537041 comment 5, the range could have removed node.
36868:   NS_ENSURE_TRUE(startNode->GetCurrentDoc() == mPresShell->GetDocument(),
36868:                  NS_ERROR_NOT_AVAILABLE);
36868:   NS_ASSERTION(startNode->GetCurrentDoc() == endNode->GetCurrentDoc(),
36868:                "mFirstSelectedRange crosses the document boundary");
36868: 
11914:   mRootContent = startNode->GetSelectionRootContent(mPresShell);
11914:   NS_ENSURE_TRUE(mRootContent, NS_ERROR_FAILURE);
39629:   return NS_OK;
39629: }
39629: 
39629: nsresult
39629: nsContentEventHandler::Init(nsQueryContentEvent* aEvent)
39629: {
39629:   NS_ASSERTION(aEvent, "aEvent must not be null");
39629: 
39629:   nsresult rv = InitCommon();
39629:   NS_ENSURE_SUCCESS(rv, rv);
39629: 
80486:   aEvent->mSucceeded = false;
11914: 
11914:   aEvent->mReply.mContentsRoot = mRootContent.get();
11914: 
79445:   bool isCollapsed;
39629:   rv = mSelection->GetIsCollapsed(&isCollapsed);
39629:   NS_ENSURE_SUCCESS(rv, NS_ERROR_NOT_AVAILABLE);
39629:   aEvent->mReply.mHasSelection = !isCollapsed;
39629: 
40045:   nsRefPtr<nsCaret> caret = mPresShell->GetCaret();
40045:   NS_ASSERTION(caret, "GetCaret returned null");
39425: 
16548:   nsRect r;
39425:   nsIFrame* frame = caret->GetGeometry(mSelection, &r);
39425:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
39425: 
47148:   aEvent->mReply.mFocusedWidget = frame->GetNearestWidget();
16548: 
11914:   return NS_OK;
11914: }
11914: 
39629: nsresult
39629: nsContentEventHandler::Init(nsSelectionEvent* aEvent)
39629: {
39629:   NS_ASSERTION(aEvent, "aEvent must not be null");
39629: 
39629:   nsresult rv = InitCommon();
39629:   NS_ENSURE_SUCCESS(rv, rv);
39629: 
80486:   aEvent->mSucceeded = false;
39629: 
39629:   return NS_OK;
39629: }
39629: 
24836: // Editor places a bogus BR node under its root content if the editor doesn't
24836: // have any text. This happens even for single line editors.
24836: // When we get text content and when we change the selection,
24836: // we don't want to include the bogus BRs at the end.
79445: static bool IsContentBR(nsIContent* aContent)
24836: {
33329:   return aContent->IsHTML() &&
24836:          aContent->Tag() == nsGkAtoms::br &&
24836:          !aContent->AttrValueIs(kNameSpaceID_None,
24836:                                 nsGkAtoms::type,
24836:                                 nsGkAtoms::moz,
24836:                                 eIgnoreCase) &&
24836:          !aContent->AttrValueIs(kNameSpaceID_None,
24836:                                 nsGkAtoms::mozeditorbogusnode,
24836:                                 nsGkAtoms::_true,
24836:                                 eIgnoreCase);
24836: }
24836: 
11914: static void ConvertToNativeNewlines(nsAFlatString& aString)
11914: {
11914: #if defined(XP_MACOSX)
11914:   aString.ReplaceSubstring(NS_LITERAL_STRING("\n"), NS_LITERAL_STRING("\r"));
11914: #elif defined(XP_WIN)
11914:   aString.ReplaceSubstring(NS_LITERAL_STRING("\n"), NS_LITERAL_STRING("\r\n"));
11914: #endif
11914: }
11914: 
11914: static void AppendString(nsAString& aString, nsIContent* aContent)
11914: {
11914:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
11914:                "aContent is not a text node!");
11914:   const nsTextFragment* text = aContent->GetText();
11914:   if (!text)
11914:     return;
11914:   text->AppendTo(aString);
11914: }
11914: 
11914: static void AppendSubString(nsAString& aString, nsIContent* aContent,
11914:                             PRUint32 aXPOffset, PRUint32 aXPLength)
11914: {
11914:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
11914:                "aContent is not a text node!");
11914:   const nsTextFragment* text = aContent->GetText();
11914:   if (!text)
11914:     return;
11914:   text->AppendTo(aString, PRInt32(aXPOffset), PRInt32(aXPLength));
11914: }
11914: 
72586: #if defined(XP_WIN)
88528: static PRUint32 CountNewlinesInXPLength(nsIContent* aContent,
88528:                                         PRUint32 aXPLength)
72586: {
72586:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
72586:                "aContent is not a text node!");
72586:   const nsTextFragment* text = aContent->GetText();
72586:   if (!text)
72586:     return 0;
89551:   // For automated tests, we should abort on debug build.
89551:   NS_ABORT_IF_FALSE(
89551:     (aXPLength == PR_UINT32_MAX || aXPLength <= text->GetLength()),
89551:     "aXPLength is out-of-bounds");
88528:   const PRUint32 length = NS_MIN(aXPLength, text->GetLength());
72586:   PRUint32 newlines = 0;
88527:   for (PRUint32 i = 0; i < length; ++i) {
72586:     if (text->CharAt(i) == '\n') {
72586:       ++newlines;
72586:     }
72586:   }
72586:   return newlines;
72586: }
88528: 
88528: static PRUint32 CountNewlinesInNativeLength(nsIContent* aContent,
88528:                                             PRUint32 aNativeLength)
88528: {
88528:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
88528:                "aContent is not a text node!");
88528:   const nsTextFragment* text = aContent->GetText();
88528:   if (!text) {
88528:     return 0;
88528:   }
89551:   // For automated tests, we should abort on debug build.
89551:   NS_ABORT_IF_FALSE(
89551:     (aNativeLength == PR_UINT32_MAX || aNativeLength <= text->GetLength() * 2),
89551:     "aNativeLength is unexpected value");
88528:   const PRUint32 xpLength = text->GetLength();
88528:   PRUint32 newlines = 0;
88528:   for (PRUint32 i = 0, nativeOffset = 0;
88528:        i < xpLength && nativeOffset < aNativeLength;
88528:        ++i, ++nativeOffset) {
89551:     // For automated tests, we should abort on debug build.
89551:     NS_ABORT_IF_FALSE(i < text->GetLength(), "i is out-of-bounds");
88528:     if (text->CharAt(i) == '\n') {
88528:       ++newlines;
88528:       ++nativeOffset;
88528:     }
88528:   }
88528:   return newlines;
88528: }
72586: #endif
72586: 
72587: static PRUint32 GetNativeTextLength(nsIContent* aContent, PRUint32 aMaxLength = PR_UINT32_MAX)
11914: {
72586:   if (aContent->IsNodeOfType(nsINode::eTEXT)) {
72586:     PRUint32 textLengthDifference =
72586: #if defined(XP_MACOSX)
72586:       // On Mac, the length of a native newline ("\r") is equal to the length of
72586:       // the XP newline ("\n"), so the native length is the same as the XP length.
72586:       0;
72586: #elif defined(XP_WIN)
72586:       // On Windows, the length of a native newline ("\r\n") is twice the length of
72586:       // the XP newline ("\n"), so XP length is equal to the length of the native
72586:       // offset plus the number of newlines encountered in the string.
88528:       CountNewlinesInXPLength(aContent, aMaxLength);
72586: #else
72586:       // On other platforms, the native and XP newlines are the same.
72586:       0;
72586: #endif
72586: 
72586:     const nsTextFragment* text = aContent->GetText();
72586:     if (!text)
72586:       return 0;
72587:     PRUint32 length = NS_MIN(text->GetLength(), aMaxLength);
72587:     return length + textLengthDifference;
72586:   } else if (IsContentBR(aContent)) {
72586: #if defined(XP_WIN)
72586:     // Length of \r\n
72586:     return 2;
72586: #else
72586:     return 1;
72586: #endif
72586:   }
72586:   return 0;
11914: }
11914: 
11914: static PRUint32 ConvertToXPOffset(nsIContent* aContent, PRUint32 aNativeOffset)
11914: {
72586: #if defined(XP_MACOSX)
72586:   // On Mac, the length of a native newline ("\r") is equal to the length of
72586:   // the XP newline ("\n"), so the native offset is the same as the XP offset.
72586:   return aNativeOffset;
72586: #elif defined(XP_WIN)
72586:   // On Windows, the length of a native newline ("\r\n") is twice the length of
72586:   // the XP newline ("\n"), so XP offset is equal to the length of the native
72586:   // offset minus the number of newlines encountered in the string.
88528:   return aNativeOffset - CountNewlinesInNativeLength(aContent, aNativeOffset);
72586: #else
72586:   // On other platforms, the native and XP newlines are the same.
72586:   return aNativeOffset;
72586: #endif
11914: }
11914: 
86939: static nsresult GenerateFlatTextContent(nsRange* aRange,
11914:                                         nsAFlatString& aString)
11914: {
11914:   nsCOMPtr<nsIContentIterator> iter;
11914:   nsresult rv = NS_NewContentIterator(getter_AddRefs(iter));
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   NS_ASSERTION(iter, "NS_NewContentIterator succeeded, but the result is null");
86939:   iter->Init(aRange);
11914: 
11914:   NS_ASSERTION(aString.IsEmpty(), "aString must be empty string");
11914: 
11914:   nsINode* startNode = aRange->GetStartParent();
35245:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
11914:   nsINode* endNode = aRange->GetEndParent();
35245:   NS_ENSURE_TRUE(endNode, NS_ERROR_FAILURE);
11914: 
11914:   if (startNode == endNode && startNode->IsNodeOfType(nsINode::eTEXT)) {
11914:     nsIContent* content = static_cast<nsIContent*>(startNode);
11914:     AppendSubString(aString, content, aRange->StartOffset(),
11914:                     aRange->EndOffset() - aRange->StartOffset());
11914:     ConvertToNativeNewlines(aString);
11914:     return NS_OK;
11914:   }
11914: 
11914:   nsAutoString tmpStr;
11914:   for (; !iter->IsDone(); iter->Next()) {
20503:     nsINode* node = iter->GetCurrentNode();
20503:     if (!node || !node->IsNodeOfType(nsINode::eCONTENT))
11914:       continue;
20503:     nsIContent* content = static_cast<nsIContent*>(node);
11914: 
11914:     if (content->IsNodeOfType(nsINode::eTEXT)) {
11914:       if (content == startNode)
11914:         AppendSubString(aString, content, aRange->StartOffset(),
11914:                         content->TextLength() - aRange->StartOffset());
11914:       else if (content == endNode)
11914:         AppendSubString(aString, content, 0, aRange->EndOffset());
11914:       else
11914:         AppendString(aString, content);
24836:     } else if (IsContentBR(content))
11914:         aString.Append(PRUnichar('\n'));
11914:   }
11914:   ConvertToNativeNewlines(aString);
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::ExpandToClusterBoundary(nsIContent* aContent,
79445:                                                     bool aForward,
11914:                                                     PRUint32* aXPOffset)
11914: {
11914:   // XXX This method assumes that the frame boundaries must be cluster
11914:   // boundaries. It's false, but no problem now, maybe.
11914:   if (!aContent->IsNodeOfType(nsINode::eTEXT) ||
11914:       *aXPOffset == 0 || *aXPOffset == aContent->TextLength())
11914:     return NS_OK;
24836: 
24836:   NS_ASSERTION(*aXPOffset >= 0 && *aXPOffset <= aContent->TextLength(),
24836:                "offset is out of range.");
24836: 
70097:   nsRefPtr<nsFrameSelection> fs = mPresShell->FrameSelection();
11914:   PRInt32 offsetInFrame;
11914:   nsFrameSelection::HINT hint =
11914:     aForward ? nsFrameSelection::HINTLEFT : nsFrameSelection::HINTRIGHT;
11914:   nsIFrame* frame = fs->GetFrameForNodeOffset(aContent, PRInt32(*aXPOffset),
11914:                                               hint, &offsetInFrame);
11914:   if (!frame) {
11914:     // This content doesn't have any frames, we only can check surrogate pair...
11914:     const nsTextFragment* text = aContent->GetText();
11914:     NS_ENSURE_TRUE(text, NS_ERROR_FAILURE);
11914:     if (NS_IS_LOW_SURROGATE(text->CharAt(*aXPOffset)) &&
11914:         NS_IS_HIGH_SURROGATE(text->CharAt(*aXPOffset - 1)))
11914:       *aXPOffset += aForward ? 1 : -1;
11914:     return NS_OK;
11914:   }
11914:   PRInt32 startOffset, endOffset;
11914:   nsresult rv = frame->GetOffsets(startOffset, endOffset);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   if (*aXPOffset == PRUint32(startOffset) || *aXPOffset == PRUint32(endOffset))
11914:     return NS_OK;
11914:   if (frame->GetType() != nsGkAtoms::textFrame)
11914:     return NS_ERROR_FAILURE;
11914:   nsTextFrame* textFrame = static_cast<nsTextFrame*>(frame);
24836:   PRInt32 newOffsetInFrame = *aXPOffset - startOffset;
11914:   newOffsetInFrame += aForward ? -1 : 1;
11914:   textFrame->PeekOffsetCharacter(aForward, &newOffsetInFrame);
11914:   *aXPOffset = startOffset + newOffsetInFrame;
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::SetRangeFromFlatTextOffset(
86939:                               nsRange* aRange,
11914:                               PRUint32 aNativeOffset,
11914:                               PRUint32 aNativeLength,
79445:                               bool aExpandToClusterBoundaries)
11914: {
11914:   nsCOMPtr<nsIContentIterator> iter;
11914:   nsresult rv = NS_NewContentIterator(getter_AddRefs(iter));
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914:   NS_ASSERTION(iter, "NS_NewContentIterator succeeded, but the result is null");
11914:   rv = iter->Init(mRootContent);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
11914:   PRUint32 nativeOffset = 0;
11914:   PRUint32 nativeEndOffset = aNativeOffset + aNativeLength;
20503:   nsCOMPtr<nsIContent> content;
11914:   for (; !iter->IsDone(); iter->Next()) {
20503:     nsINode* node = iter->GetCurrentNode();
20503:     if (!node || !node->IsNodeOfType(nsINode::eCONTENT))
11914:       continue;
20503:     nsIContent* content = static_cast<nsIContent*>(node);
11914: 
11914:     PRUint32 nativeTextLength;
11914:     nativeTextLength = GetNativeTextLength(content);
11914:     if (nativeTextLength == 0)
11914:       continue;
11914: 
11914:     if (nativeOffset <= aNativeOffset &&
11914:         aNativeOffset < nativeOffset + nativeTextLength) {
11914:       nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(content));
11914:       NS_ASSERTION(domNode, "aContent doesn't have nsIDOMNode!");
11914: 
11914:       PRUint32 xpOffset =
11914:         content->IsNodeOfType(nsINode::eTEXT) ?
11914:           ConvertToXPOffset(content, aNativeOffset - nativeOffset) : 0;
11914: 
11914:       if (aExpandToClusterBoundaries) {
80486:         rv = ExpandToClusterBoundary(content, false, &xpOffset);
11914:         NS_ENSURE_SUCCESS(rv, rv);
11914:       }
11914: 
86939:       rv = aRange->SetStart(domNode, PRInt32(xpOffset));
11914:       NS_ENSURE_SUCCESS(rv, rv);
11914:       if (aNativeLength == 0) {
11914:         // Ensure that the end offset and the start offset are same.
86939:         rv = aRange->SetEnd(domNode, PRInt32(xpOffset));
11914:         NS_ENSURE_SUCCESS(rv, rv);
11914:         return NS_OK;
11914:       }
11914:     }
11914:     if (nativeEndOffset <= nativeOffset + nativeTextLength) {
11914:       nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(content));
11914:       NS_ASSERTION(domNode, "aContent doesn't have nsIDOMNode!");
11914: 
11914:       PRUint32 xpOffset;
11914:       if (content->IsNodeOfType(nsINode::eTEXT)) {
11914:         xpOffset = ConvertToXPOffset(content, nativeEndOffset - nativeOffset);
11914:         if (aExpandToClusterBoundaries) {
80486:           rv = ExpandToClusterBoundary(content, true, &xpOffset);
11914:           NS_ENSURE_SUCCESS(rv, rv);
11914:         }
11914:       } else {
11914:         // Use first position of next node, because the end node is ignored
11914:         // by ContentIterator when the offset is zero.
11914:         xpOffset = 0;
11914:         iter->Next();
11914:         if (iter->IsDone())
11914:           break;
11914:         domNode = do_QueryInterface(iter->GetCurrentNode());
11914:       }
11914: 
86939:       rv = aRange->SetEnd(domNode, PRInt32(xpOffset));
11914:       NS_ENSURE_SUCCESS(rv, rv);
11914:       return NS_OK;
11914:     }
11914: 
11914:     nativeOffset += nativeTextLength;
11914:   }
11914: 
11914:   if (nativeOffset < aNativeOffset)
11914:     return NS_ERROR_FAILURE;
11914: 
11914:   nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(mRootContent));
11914:   NS_ASSERTION(domNode, "lastContent doesn't have nsIDOMNode!");
11914:   if (!content) {
86939:     rv = aRange->SetStart(domNode, 0);
11914:     NS_ENSURE_SUCCESS(rv, rv);
11914:   }
86939:   rv = aRange->SetEnd(domNode, PRInt32(mRootContent->GetChildCount()));
11914:   NS_ASSERTION(NS_SUCCEEDED(rv), "nsIDOMRange::SetEnd failed");
11914:   return rv;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::OnQuerySelectedText(nsQueryContentEvent* aEvent)
11914: {
11914:   nsresult rv = Init(aEvent);
11914:   if (NS_FAILED(rv))
11914:     return rv;
11914: 
11914:   NS_ASSERTION(aEvent->mReply.mString.IsEmpty(),
11914:                "The reply string must be empty");
11914: 
24836:   rv = GetFlatTextOffsetOfRange(mRootContent,
24836:                                 mFirstSelectedRange, &aEvent->mReply.mOffset);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
24836:   nsCOMPtr<nsIDOMNode> anchorDomNode, focusDomNode;
24836:   rv = mSelection->GetAnchorNode(getter_AddRefs(anchorDomNode));
24836:   NS_ENSURE_TRUE(anchorDomNode, NS_ERROR_FAILURE);
24836:   rv = mSelection->GetFocusNode(getter_AddRefs(focusDomNode));
24836:   NS_ENSURE_TRUE(focusDomNode, NS_ERROR_FAILURE);
24836: 
24836:   PRInt32 anchorOffset, focusOffset;
24836:   rv = mSelection->GetAnchorOffset(&anchorOffset);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836:   rv = mSelection->GetFocusOffset(&focusOffset);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
24836:   nsCOMPtr<nsINode> anchorNode(do_QueryInterface(anchorDomNode));
24836:   nsCOMPtr<nsINode> focusNode(do_QueryInterface(focusDomNode));
24836:   NS_ENSURE_TRUE(anchorNode && focusNode, NS_ERROR_UNEXPECTED);
11914: 
24836:   PRInt16 compare = nsContentUtils::ComparePoints(anchorNode, anchorOffset,
24836:                                                   focusNode, focusOffset);
24836:   aEvent->mReply.mReversed = compare > 0;
24836: 
24836:   if (compare) {
86939:     rv = GenerateFlatTextContent(mFirstSelectedRange, aEvent->mReply.mString);
11914:     NS_ENSURE_SUCCESS(rv, rv);
11914:   }
11914: 
80486:   aEvent->mSucceeded = true;
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::OnQueryTextContent(nsQueryContentEvent* aEvent)
11914: {
11914:   nsresult rv = Init(aEvent);
11914:   if (NS_FAILED(rv))
11914:     return rv;
11914: 
11914:   NS_ASSERTION(aEvent->mReply.mString.IsEmpty(),
11914:                "The reply string must be empty");
11914: 
86939:   nsRefPtr<nsRange> range = new nsRange();
11914:   rv = SetRangeFromFlatTextOffset(range, aEvent->mInput.mOffset,
80486:                                   aEvent->mInput.mLength, false);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
11914:   rv = GenerateFlatTextContent(range, aEvent->mReply.mString);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
80486:   aEvent->mSucceeded = true;
11914: 
11914:   return NS_OK;
11914: }
11914: 
24836: // Adjust to use a child node if possible
24836: // to make the returned rect more accurate
24836: static nsINode* AdjustTextRectNode(nsINode* aNode,
24836:                                    PRInt32& aOffset)
24836: {
24836:   PRInt32 childCount = PRInt32(aNode->GetChildCount());
24836:   nsINode* node = aNode;
24836:   if (childCount) {
24836:     if (aOffset < childCount) {
24836:       node = aNode->GetChildAt(aOffset);
24836:       aOffset = 0;
24836:     } else if (aOffset == childCount) {
24836:       node = aNode->GetChildAt(childCount - 1);
24836:       aOffset = node->IsNodeOfType(nsINode::eTEXT) ?
24836:           static_cast<nsIContent*>(node)->TextLength() : 1;
24836:     }
24836:   }
24836:   return node;
24836: }
24836: 
24836: // Similar to nsFrameSelection::GetFrameForNodeOffset,
24836: // but this is more flexible for OnQueryTextRect to use
36655: static nsresult GetFrameForTextRect(nsINode* aNode,
24836:                                     PRInt32 aOffset,
79445:                                     bool aHint,
24836:                                     nsIFrame** aReturnFrame)
24836: {
24836:   NS_ENSURE_TRUE(aNode && aNode->IsNodeOfType(nsINode::eCONTENT),
24836:                  NS_ERROR_UNEXPECTED);
24836:   nsIContent* content = static_cast<nsIContent*>(aNode);
36655:   nsIFrame* frame = content->GetPrimaryFrame();
24836:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
24836:   PRInt32 childOffset = 0;
24836:   return frame->GetChildFrameContainingOffset(aOffset, aHint, &childOffset,
24836:                                               aReturnFrame);
24836: }
24836: 
24831: nsresult
24836: nsContentEventHandler::OnQueryTextRect(nsQueryContentEvent* aEvent)
24823: {
24836:   nsresult rv = Init(aEvent);
24836:   if (NS_FAILED(rv))
24836:     return rv;
24836: 
86939:   nsRefPtr<nsRange> range = new nsRange();
24836:   rv = SetRangeFromFlatTextOffset(range, aEvent->mInput.mOffset,
80486:                                   aEvent->mInput.mLength, true);
24831:   NS_ENSURE_SUCCESS(rv, rv);
24831: 
24836:   // used to iterate over all contents and their frames
24836:   nsCOMPtr<nsIContentIterator> iter;
24836:   rv = NS_NewContentIterator(getter_AddRefs(iter));
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836:   iter->Init(range);
24831:   NS_ENSURE_SUCCESS(rv, rv);
24831: 
24836:   // get the starting frame
24836:   PRInt32 offset = range->StartOffset();
24836:   nsINode* node = iter->GetCurrentNode();
24836:   if (!node) {
24836:     node = AdjustTextRectNode(range->GetStartParent(), offset);
24836:   }
24836:   nsIFrame* firstFrame = nsnull;
80486:   rv = GetFrameForTextRect(node, offset, true, &firstFrame);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24831: 
24836:   // get the starting frame rect
24836:   nsRect rect(nsPoint(0, 0), firstFrame->GetRect().Size());
24836:   rv = ConvertToRootViewRelativeOffset(firstFrame, rect);
24831:   NS_ENSURE_SUCCESS(rv, rv);
24836:   nsRect frameRect = rect;
24836:   nsPoint ptOffset;
24836:   firstFrame->GetPointFromOffset(offset, &ptOffset);
24836:   // minus 1 to avoid creating an empty rect
24836:   rect.x += ptOffset.x - 1;
24836:   rect.width -= ptOffset.x - 1;
24836: 
24836:   // get the ending frame
24836:   offset = range->EndOffset();
24836:   node = AdjustTextRectNode(range->GetEndParent(), offset);
24836:   nsIFrame* lastFrame = nsnull;
36655:   rv = GetFrameForTextRect(node, offset, range->Collapsed(), &lastFrame);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   // iterate over all covered frames
24836:   for (nsIFrame* frame = firstFrame; frame != lastFrame;) {
24836:     frame = frame->GetNextContinuation();
24836:     if (!frame) {
24836:       do {
24836:         iter->Next();
24836:         node = iter->GetCurrentNode();
24836:         if (!node || !node->IsNodeOfType(nsINode::eCONTENT))
24836:           continue;
36655:         frame = static_cast<nsIContent*>(node)->GetPrimaryFrame();
24836:       } while (!frame && !iter->IsDone());
24836:       if (!frame) {
24836:         // this can happen when the end offset of the range is 0.
24836:         frame = lastFrame;
24836:       }
24836:     }
24836:     frameRect.SetRect(nsPoint(0, 0), frame->GetRect().Size());
24836:     rv = ConvertToRootViewRelativeOffset(frame, frameRect);
24836:     NS_ENSURE_SUCCESS(rv, rv);
24836:     if (frame != lastFrame) {
24836:       // not last frame, so just add rect to previous result
24836:       rect.UnionRect(rect, frameRect);
24836:     }
24823:   }
24823: 
24836:   // get the ending frame rect
24836:   lastFrame->GetPointFromOffset(offset, &ptOffset);
24836:   // minus 1 to avoid creating an empty rect
24836:   frameRect.width -= lastFrame->GetRect().width - ptOffset.x - 1;
24831: 
24836:   if (firstFrame == lastFrame) {
24836:     rect.IntersectRect(rect, frameRect);
24836:   } else {
24836:     rect.UnionRect(rect, frameRect);
24836:   }
24836:   aEvent->mReply.mRect =
28113:       rect.ToOutsidePixels(mPresContext->AppUnitsPerDevPixel());
80486:   aEvent->mSucceeded = true;
24831:   return NS_OK;
24823: }
24823: 
24746: nsresult
24836: nsContentEventHandler::OnQueryEditorRect(nsQueryContentEvent* aEvent)
24726: {
24823:   nsresult rv = Init(aEvent);
24823:   if (NS_FAILED(rv))
24823:     return rv;
24823: 
36655:   nsIFrame* frame = mRootContent->GetPrimaryFrame();
24836:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
24836: 
24836:   // get rect for first frame
24836:   nsRect resultRect(nsPoint(0, 0), frame->GetRect().Size());
24836:   rv = ConvertToRootViewRelativeOffset(frame, resultRect);
24746:   NS_ENSURE_SUCCESS(rv, rv);
24746: 
24836:   // account for any additional frames
24836:   while ((frame = frame->GetNextContinuation()) != nsnull) {
24836:     nsRect frameRect(nsPoint(0, 0), frame->GetRect().Size());
24836:     rv = ConvertToRootViewRelativeOffset(frame, frameRect);
24836:     NS_ENSURE_SUCCESS(rv, rv);
24836:     resultRect.UnionRect(resultRect, frameRect);
24836:   }
24836: 
24836:   aEvent->mReply.mRect =
28113:       resultRect.ToOutsidePixels(mPresContext->AppUnitsPerDevPixel());
80486:   aEvent->mSucceeded = true;
24746:   return NS_OK;
24726: }
24726: 
11914: nsresult
24836: nsContentEventHandler::OnQueryCaretRect(nsQueryContentEvent* aEvent)
11914: {
11914:   nsresult rv = Init(aEvent);
11914:   if (NS_FAILED(rv))
11914:     return rv;
11914: 
40045:   nsRefPtr<nsCaret> caret = mPresShell->GetCaret();
40045:   NS_ASSERTION(caret, "GetCaret returned null");
11914: 
11914:   // When the selection is collapsed and the queried offset is current caret
11914:   // position, we should return the "real" caret rect.
79445:   bool selectionIsCollapsed;
11914:   rv = mSelection->GetIsCollapsed(&selectionIsCollapsed);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
11914:   if (selectionIsCollapsed) {
11914:     PRUint32 offset;
24836:     rv = GetFlatTextOffsetOfRange(mRootContent, mFirstSelectedRange, &offset);
11914:     NS_ENSURE_SUCCESS(rv, rv);
11914:     if (offset == aEvent->mInput.mOffset) {
23738:       nsRect rect;
39425:       nsIFrame* caretFrame = caret->GetGeometry(mSelection, &rect);
39425:       if (!caretFrame)
39425:         return NS_ERROR_FAILURE;
39629:       rv = ConvertToRootViewRelativeOffset(caretFrame, rect);
39629:       NS_ENSURE_SUCCESS(rv, rv);
24836:       aEvent->mReply.mRect =
39425:         rect.ToOutsidePixels(caretFrame->PresContext()->AppUnitsPerDevPixel());
80486:       aEvent->mSucceeded = true;
11914:       return NS_OK;
11914:     }
11914:   }
11914: 
11914:   // Otherwise, we should set the guessed caret rect.
86939:   nsRefPtr<nsRange> range = new nsRange();
80486:   rv = SetRangeFromFlatTextOffset(range, aEvent->mInput.mOffset, 0, true);
11914:   NS_ENSURE_SUCCESS(rv, rv);
11914: 
24836:   PRInt32 offsetInFrame;
24836:   nsIFrame* frame;
24836:   rv = GetStartFrameAndOffset(range, &frame, &offsetInFrame);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   nsPoint posInFrame;
24836:   rv = frame->GetPointFromOffset(range->StartOffset(), &posInFrame);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   nsRect rect;
24836:   rect.x = posInFrame.x;
24836:   rect.y = posInFrame.y;
24836:   rect.width = caret->GetCaretRect().width;
24836:   rect.height = frame->GetSize().height;
24836: 
24836:   rv = ConvertToRootViewRelativeOffset(frame, rect);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   aEvent->mReply.mRect =
28113:       rect.ToOutsidePixels(mPresContext->AppUnitsPerDevPixel());
80486:   aEvent->mSucceeded = true;
24836:   return NS_OK;
11914: }
11914: 
11914: nsresult
26757: nsContentEventHandler::OnQueryContentState(nsQueryContentEvent * aEvent)
26757: {
26757:   nsresult rv = Init(aEvent);
26757:   if (NS_FAILED(rv))
26757:     return rv;
26757:   
80486:   aEvent->mSucceeded = true;
26757: 
26757:   return NS_OK;
26757: }
26757: 
26757: nsresult
26757: nsContentEventHandler::OnQuerySelectionAsTransferable(nsQueryContentEvent* aEvent)
26757: {
26757:   nsresult rv = Init(aEvent);
26757:   if (NS_FAILED(rv))
26757:     return rv;
26757: 
26757:   if (!aEvent->mReply.mHasSelection) {
80486:     aEvent->mSucceeded = true;
26757:     aEvent->mReply.mTransferable = nsnull;
26757:     return NS_OK;
26757:   }
26757: 
26757:   nsCOMPtr<nsIDocument> doc = mPresShell->GetDocument();
26757:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
26757: 
26757:   rv = nsCopySupport::GetTransferableForSelection(mSelection, doc, getter_AddRefs(aEvent->mReply.mTransferable));
26757:   NS_ENSURE_SUCCESS(rv, rv);
26757: 
80486:   aEvent->mSucceeded = true;
26757:   return NS_OK;
26757: }
26757: 
26757: nsresult
28352: nsContentEventHandler::OnQueryCharacterAtPoint(nsQueryContentEvent* aEvent)
28352: {
28352:   nsresult rv = Init(aEvent);
28352:   if (NS_FAILED(rv))
28352:     return rv;
28352: 
28352:   nsIFrame* rootFrame = mPresShell->GetRootFrame();
39629:   NS_ENSURE_TRUE(rootFrame, NS_ERROR_FAILURE);
47148:   nsIWidget* rootWidget = rootFrame->GetNearestWidget();
39629:   NS_ENSURE_TRUE(rootWidget, NS_ERROR_FAILURE);
39629: 
39629:   // The root frame's widget might be different, e.g., the event was fired on
39629:   // a popup but the rootFrame is the document root.
39629:   if (rootWidget != aEvent->widget) {
39629:     NS_PRECONDITION(aEvent->widget, "The event must have the widget");
39629:     nsIView* view = nsIView::GetViewFor(aEvent->widget);
39629:     NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
86849:     rootFrame = view->GetFrame();
39629:     NS_ENSURE_TRUE(rootFrame, NS_ERROR_FAILURE);
47148:     rootWidget = rootFrame->GetNearestWidget();
39629:     NS_ENSURE_TRUE(rootWidget, NS_ERROR_FAILURE);
39629:   }
39629: 
80486:   nsQueryContentEvent eventOnRoot(true, NS_QUERY_CHARACTER_AT_POINT,
39629:                                   rootWidget);
39629:   eventOnRoot.refPoint = aEvent->refPoint;
39629:   if (rootWidget != aEvent->widget) {
39629:     eventOnRoot.refPoint += aEvent->widget->WidgetToScreenOffset();
39629:     eventOnRoot.refPoint -= rootWidget->WidgetToScreenOffset();
39629:   }
28352:   nsPoint ptInRoot =
39629:     nsLayoutUtils::GetEventCoordinatesRelativeTo(&eventOnRoot, rootFrame);
39629: 
28352:   nsIFrame* targetFrame = nsLayoutUtils::GetFrameForPoint(rootFrame, ptInRoot);
40130:   if (!targetFrame || targetFrame->GetType() != nsGkAtoms::textFrame ||
40130:       !targetFrame->GetContent() ||
40130:       !nsContentUtils::ContentIsDescendantOf(targetFrame->GetContent(),
40130:                                              mRootContent)) {
28352:     // there is no character at the point.
28352:     aEvent->mReply.mOffset = nsQueryContentEvent::NOT_FOUND;
80486:     aEvent->mSucceeded = true;
28352:     return NS_OK;
28352:   }
47902:   nsPoint ptInTarget = ptInRoot + rootFrame->GetOffsetToCrossDoc(targetFrame);
47902:   PRInt32 rootAPD = rootFrame->PresContext()->AppUnitsPerDevPixel();
47902:   PRInt32 targetAPD = targetFrame->PresContext()->AppUnitsPerDevPixel();
47902:   ptInTarget = ptInTarget.ConvertAppUnits(rootAPD, targetAPD);
47902: 
28352:   nsTextFrame* textframe = static_cast<nsTextFrame*>(targetFrame);
28352:   nsIFrame::ContentOffsets offsets =
28352:     textframe->GetCharacterOffsetAtFramePoint(ptInTarget);
28352:   NS_ENSURE_TRUE(offsets.content, NS_ERROR_FAILURE);
28352:   PRUint32 nativeOffset;
28352:   rv = GetFlatTextOffsetOfRange(mRootContent, offsets.content, offsets.offset,
28352:                                 &nativeOffset);
28352:   NS_ENSURE_SUCCESS(rv, rv);
28352: 
80486:   nsQueryContentEvent textRect(true, NS_QUERY_TEXT_RECT, aEvent->widget);
28352:   textRect.InitForQueryTextRect(nativeOffset, 1);
28352:   rv = OnQueryTextRect(&textRect);
28352:   NS_ENSURE_SUCCESS(rv, rv);
28352:   NS_ENSURE_TRUE(textRect.mSucceeded, NS_ERROR_FAILURE);
28352: 
28352:   // currently, we don't need to get the actual text.
28352:   aEvent->mReply.mOffset = nativeOffset;
28352:   aEvent->mReply.mRect = textRect.mReply.mRect;
80486:   aEvent->mSucceeded = true;
28352:   return NS_OK;
28352: }
28352: 
28352: nsresult
63215: nsContentEventHandler::OnQueryDOMWidgetHittest(nsQueryContentEvent* aEvent)
63215: {
63215:   nsresult rv = Init(aEvent);
63215:   if (NS_FAILED(rv))
63215:     return rv;
63215: 
80486:   aEvent->mReply.mWidgetIsHit = false;
63215: 
63215:   NS_ENSURE_TRUE(aEvent->widget, NS_ERROR_FAILURE);
63215: 
63215:   nsIDocument* doc = mPresShell->GetDocument();
63215:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
63215:   nsIFrame* docFrame = mPresShell->GetRootFrame();
63215:   NS_ENSURE_TRUE(docFrame, NS_ERROR_FAILURE);
63215: 
63215:   nsIntPoint eventLoc =
63215:     aEvent->refPoint + aEvent->widget->WidgetToScreenOffset();
63215:   nsIntRect docFrameRect = docFrame->GetScreenRect(); // Returns CSS pixels
63215:   eventLoc.x = mPresContext->DevPixelsToIntCSSPixels(eventLoc.x);
63215:   eventLoc.y = mPresContext->DevPixelsToIntCSSPixels(eventLoc.y);
63215:   eventLoc.x -= docFrameRect.x;
63215:   eventLoc.y -= docFrameRect.y;
63215: 
63215:   nsCOMPtr<nsIDOMElement> elementUnderMouse;
80486:   doc->ElementFromPointHelper(eventLoc.x, eventLoc.y, false, false,
63215:                               getter_AddRefs(elementUnderMouse));
63215:   nsCOMPtr<nsIContent> contentUnderMouse = do_QueryInterface(elementUnderMouse);
63215:   if (contentUnderMouse) {
63215:     nsIWidget* targetWidget = nsnull;
63215:     nsIFrame* targetFrame = contentUnderMouse->GetPrimaryFrame();
63215:     nsIObjectFrame* pluginFrame = do_QueryFrame(targetFrame);
63215:     if (pluginFrame) {
63215:       targetWidget = pluginFrame->GetWidget();
63215:     } else if (targetFrame) {
63215:       targetWidget = targetFrame->GetNearestWidget();
63215:     }
63215:     if (aEvent->widget == targetWidget)
80486:       aEvent->mReply.mWidgetIsHit = true;
63215:   }
63215: 
80486:   aEvent->mSucceeded = true;
63215:   return NS_OK;
63215: }
63215: 
63215: nsresult
24836: nsContentEventHandler::GetFlatTextOffsetOfRange(nsIContent* aRootContent,
24836:                                                 nsINode* aNode,
24836:                                                 PRInt32 aNodeOffset,
11914:                                                 PRUint32* aNativeOffset)
11914: {
11914:   NS_ASSERTION(aNativeOffset, "param is invalid");
11914: 
86939:   nsRefPtr<nsRange> prev = new nsRange();
24836:   nsCOMPtr<nsIDOMNode> rootDOMNode(do_QueryInterface(aRootContent));
86939:   prev->SetStart(rootDOMNode, 0);
11914: 
24836:   nsCOMPtr<nsIDOMNode> startDOMNode(do_QueryInterface(aNode));
11914:   NS_ASSERTION(startDOMNode, "startNode doesn't have nsIDOMNode");
86939:   prev->SetEnd(startDOMNode, aNodeOffset);
11914: 
72587:   nsCOMPtr<nsIContentIterator> iter;
72587:   nsresult rv = NS_NewContentIterator(getter_AddRefs(iter));
11914:   NS_ENSURE_SUCCESS(rv, rv);
72587:   NS_ASSERTION(iter, "NS_NewContentIterator succeeded, but the result is null");
86939:   iter->Init(prev);
72587: 
72587:   nsCOMPtr<nsINode> startNode = do_QueryInterface(startDOMNode);
72587:   nsINode* endNode = aNode;
72587: 
72587:   *aNativeOffset = 0;
72587:   for (; !iter->IsDone(); iter->Next()) {
72587:     nsINode* node = iter->GetCurrentNode();
72587:     if (!node || !node->IsNodeOfType(nsINode::eCONTENT))
72587:       continue;
72587:     nsIContent* content = static_cast<nsIContent*>(node);
72587: 
72587:     if (node->IsNodeOfType(nsINode::eTEXT)) {
72587:       // Note: our range always starts from offset 0
72587:       if (node == endNode)
72587:         *aNativeOffset += GetNativeTextLength(content, aNodeOffset);
72587:       else
72587:         *aNativeOffset += GetNativeTextLength(content);
72587:     } else if (IsContentBR(content)) {
72587: #if defined(XP_WIN)
72587:       // On Windows, the length of the newline is 2.
72587:       *aNativeOffset += 2;
72587: #else
72587:       // On other platforms, the length of the newline is 1.
72587:       *aNativeOffset += 1;
72587: #endif
72587:     }
72587:   }
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::GetFlatTextOffsetOfRange(nsIContent* aRootContent,
86939:                                                 nsRange* aRange,
24836:                                                 PRUint32* aNativeOffset)
24836: {
24836:   nsINode* startNode = aRange->GetStartParent();
24836:   NS_ENSURE_TRUE(startNode, NS_ERROR_FAILURE);
24836:   PRInt32 startOffset = aRange->StartOffset();
24836:   return GetFlatTextOffsetOfRange(aRootContent, startNode, startOffset,
24836:                                   aNativeOffset);
24836: }
24836: 
24836: nsresult
86939: nsContentEventHandler::GetStartFrameAndOffset(nsRange* aRange,
11914:                                               nsIFrame** aFrame,
11914:                                               PRInt32* aOffsetInFrame)
11914: {
11914:   NS_ASSERTION(aRange && aFrame && aOffsetInFrame, "params are invalid");
11914: 
11914:   nsIContent* content = nsnull;
11914:   nsINode* node = aRange->GetStartParent();
11914:   if (node && node->IsNodeOfType(nsINode::eCONTENT))
11914:     content = static_cast<nsIContent*>(node);
11914:   NS_ASSERTION(content, "the start node doesn't have nsIContent!");
11914: 
70097:   nsRefPtr<nsFrameSelection> fs = mPresShell->FrameSelection();
11914:   *aFrame = fs->GetFrameForNodeOffset(content, aRange->StartOffset(),
11914:                                       fs->GetHint(), aOffsetInFrame);
11914:   NS_ENSURE_TRUE((*aFrame), NS_ERROR_FAILURE);
11914:   NS_ASSERTION((*aFrame)->GetType() == nsGkAtoms::textFrame,
11914:                "The frame is not textframe");
11914:   return NS_OK;
11914: }
11914: 
11914: nsresult
24836: nsContentEventHandler::ConvertToRootViewRelativeOffset(nsIFrame* aFrame,
11914:                                                        nsRect& aRect)
11914: {
11914:   NS_ASSERTION(aFrame, "aFrame must not be null");
11914: 
11914:   nsIView* view = nsnull;
11914:   nsPoint posInView;
11914:   aFrame->GetOffsetFromView(posInView, &view);
11914:   if (!view)
11914:     return NS_ERROR_FAILURE;
11914:   aRect += posInView + view->GetOffsetTo(nsnull);
11914:   return NS_OK;
11914: }
24836: 
24836: static void AdjustRangeForSelection(nsIContent* aRoot,
24836:                                     nsINode** aNode,
24836:                                     PRInt32* aOffset)
24836: {
24836:   nsINode* node = *aNode;
24836:   PRInt32 offset = *aOffset;
24836:   if (aRoot != node && node->GetParent() &&
24836:       !node->IsNodeOfType(nsINode::eTEXT)) {
24836:     node = node->GetParent();
24836:     offset = node->IndexOf(*aNode) + (offset ? 1 : 0);
24836:   }
33329:   
33329:   nsIContent* brContent = node->GetChildAt(offset - 1);
33329:   while (brContent && brContent->IsHTML()) {
24836:     if (brContent->Tag() != nsGkAtoms::br || IsContentBR(brContent))
24836:       break;
33329:     brContent = node->GetChildAt(--offset - 1);
24836:   }
24836:   *aNode = node;
38390:   *aOffset = NS_MAX(offset, 0);
24836: }
24836: 
24836: nsresult
24836: nsContentEventHandler::OnSelectionEvent(nsSelectionEvent* aEvent)
24836: {
80486:   aEvent->mSucceeded = false;
24836: 
24836:   // Get selection to manipulate
39629:   // XXX why do we need to get them from ISM? This method should work fine
39629:   //     without ISM.
24836:   nsresult rv = nsIMEStateManager::
39629:       GetFocusSelectionAndRoot(getter_AddRefs(mSelection),
24836:                                getter_AddRefs(mRootContent));
39629:   if (rv != NS_ERROR_NOT_AVAILABLE) {
24836:     NS_ENSURE_SUCCESS(rv, rv);
39629:   } else {
39629:     rv = Init(aEvent);
39629:     NS_ENSURE_SUCCESS(rv, rv);
39629:   }
24836: 
24836:   // Get range from offset and length
24836:   nsRefPtr<nsRange> range = new nsRange();
24836:   NS_ENSURE_TRUE(range, NS_ERROR_OUT_OF_MEMORY);
39777:   rv = SetRangeFromFlatTextOffset(range, aEvent->mOffset, aEvent->mLength,
39777:                                   aEvent->mExpandToClusterBoundary);
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
24836:   nsINode* startNode = range->GetStartParent();
24836:   nsINode* endNode = range->GetEndParent();
24836:   PRInt32 startOffset = range->StartOffset();
24836:   PRInt32 endOffset = range->EndOffset();
24836:   AdjustRangeForSelection(mRootContent, &startNode, &startOffset);
24836:   AdjustRangeForSelection(mRootContent, &endNode, &endOffset);
24836: 
24836:   nsCOMPtr<nsIDOMNode> startDomNode(do_QueryInterface(startNode));
24836:   nsCOMPtr<nsIDOMNode> endDomNode(do_QueryInterface(endNode));
24836:   NS_ENSURE_TRUE(startDomNode && endDomNode, NS_ERROR_UNEXPECTED);
24836: 
75112:   nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(mSelection));
24836:   selPrivate->StartBatchChanges();
24836: 
24836:   // Clear selection first before setting
39629:   rv = mSelection->RemoveAllRanges();
24836:   // Need to call EndBatchChanges at the end even if call failed
24836:   if (NS_SUCCEEDED(rv)) {
24836:     if (aEvent->mReversed) {
39629:       rv = mSelection->Collapse(endDomNode, endOffset);
24836:     } else {
39629:       rv = mSelection->Collapse(startDomNode, startOffset);
24836:     }
24836:     if (NS_SUCCEEDED(rv) &&
24836:         (startDomNode != endDomNode || startOffset != endOffset)) {
24836:       if (aEvent->mReversed) {
39629:         rv = mSelection->Extend(startDomNode, startOffset);
24836:       } else {
39629:         rv = mSelection->Extend(endDomNode, endOffset);
24836:       }
24836:     }
24836:   }
24836:   selPrivate->EndBatchChanges();
24836:   NS_ENSURE_SUCCESS(rv, rv);
24836: 
75112:   selPrivate->ScrollIntoView(
80486:       nsISelectionController::SELECTION_FOCUS_REGION, false, -1, -1);
80486:   aEvent->mSucceeded = true;
24836:   return NS_OK;
24836: }
