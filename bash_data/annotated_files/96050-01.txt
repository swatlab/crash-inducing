33486: /* vim: se cin sw=2 ts=2 et : */
33486: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
33486:  *
33486:  * ***** BEGIN LICENSE BLOCK *****
33486:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33486:  *
33486:  * The contents of this file are subject to the Mozilla Public License Version
33486:  * 1.1 (the "License"); you may not use this file except in compliance with
33486:  * the License. You may obtain a copy of the License at
33486:  * http://www.mozilla.org/MPL/
33486:  *
33486:  * Software distributed under the License is distributed on an "AS IS" basis,
33486:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33486:  * for the specific language governing rights and limitations under the
33486:  * License.
33486:  *
33486:  * The Original Code is mozilla.org code.
33486:  *
33486:  * The Initial Developer of the Original Code is
33486:  * Mozilla Foundation.
33486:  * Portions created by the Initial Developer are Copyright (C) 2009
33486:  * the Initial Developer. All Rights Reserved.
33486:  *
33486:  * Contributor(s):
33486:  *   Rob Arnold <tellrob@gmail.com>
50903:  *   Jim Mathies <jmathies@mozilla.com>
33486:  *
33486:  * Alternatively, the contents of this file may be used under the terms of
33486:  * either the GNU General Public License Version 2 or later (the "GPL"), or
33486:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33486:  * in which case the provisions of the GPL or the LGPL are applicable instead
33486:  * of those above. If you wish to allow use of your version of this file only
33486:  * under the terms of either the GPL or the LGPL, and not to allow others to
33486:  * use your version of this file under the terms of the MPL, indicate your
33486:  * decision by deleting the provisions above and replace them with the notice
33486:  * and other provisions required by the GPL or the LGPL. If you do not delete
33486:  * the provisions above, a recipient may use your version of this file under
33486:  * the terms of any one of the MPL, the GPL or the LGPL.
33486:  *
33486:  * ***** END LICENSE BLOCK ***** */
33486: 
33486: #include "TaskbarPreview.h"
33486: #include <nsITaskbarPreviewController.h>
33486: #include <windows.h>
33486: 
33486: #include <nsError.h>
33486: #include <nsCOMPtr.h>
33486: #include <nsIWidget.h>
33486: #include <nsIBaseWindow.h>
33486: #include <nsIObserverService.h>
33486: #include <nsServiceManagerUtils.h>
33486: 
33486: #include "nsUXThemeData.h"
33486: #include "nsWindow.h"
33486: #include "nsAppShell.h"
33486: #include "TaskbarPreviewButton.h"
86569: #include "WinUtils.h"
33486: 
33486: #include <nsIBaseWindow.h>
33486: #include <nsICanvasRenderingContextInternal.h>
33486: #include <nsIDOMCanvasRenderingContext2D.h>
33486: #include <imgIContainer.h>
33486: #include <nsIDocShell.h>
33486: 
33486: // Defined in dwmapi in a header that needs a higher numbered _WINNT #define
33486: #define DWM_SIT_DISPLAYFRAME 0x1
33486: 
33486: namespace mozilla {
33486: namespace widget {
33486: 
33486: namespace {
50903: 
50903: // Shared by all TaskbarPreviews to avoid the expensive creation process.
50903: // Manually refcounted (see gInstCount) by the ctor and dtor of TaskbarPreview.
50903: // This is done because static constructors aren't allowed for perf reasons.
50903: nsIDOMCanvasRenderingContext2D* gCtx = NULL;
50903: // Used in tracking the number of previews. Used in freeing
50903: // the static 2d rendering context on shutdown.
50903: PRUint32 gInstCount = 0;
50903: 
50903: /* Helper method to lazily create a canvas rendering context and associate a given
50903:  * surface with it.
33486:  *
33486:  * @param shell The docShell used by the canvas context for text settings and other
33486:  *              misc things.
33486:  * @param surface The gfxSurface backing the context
33486:  * @param width The width of the given surface
33486:  * @param height The height of the given surface
33486:  */
33486: nsresult
50903: GetRenderingContext(nsIDocShell *shell, gfxASurface *surface,
50903:                     PRUint32 width, PRUint32 height) {
33486:   nsresult rv;
50903:   nsCOMPtr<nsIDOMCanvasRenderingContext2D> ctx = gCtx;
33486: 
50903:   if (!ctx) {
50903:     // create the canvas rendering context
73024:     ctx = do_CreateInstance("@mozilla.org/content/2dthebes-canvas-rendering-context;1", &rv);
50903:     if (NS_FAILED(rv)) {
73024:       NS_WARNING("Could not create nsICanvasRenderingContext2D for tab previews!");
50903:       return rv;
50903:     }
50903:     gCtx = ctx;
78894:     NS_ADDREF(gCtx);
50903:   }
50903: 
50903:   nsCOMPtr<nsICanvasRenderingContextInternal> ctxI = do_QueryInterface(ctx, &rv);
50903:   if (NS_FAILED(rv))
50903:     return rv;
50903: 
50903:   // Set the surface we'll use to render.
50903:   return ctxI->InitializeWithSurface(shell, surface, width, height);
50903: }
50903: 
50903: /* Helper method for freeing surface resources associated with the rendering context.
50903:  */
50903: void
50903: ResetRenderingContext() {
50903:   if (!gCtx)
50903:     return;
50903: 
50903:   nsresult rv;
50903:   nsCOMPtr<nsICanvasRenderingContextInternal> ctxI = do_QueryInterface(gCtx, &rv);
50903:   if (NS_FAILED(rv))
50903:     return;
50903:   if (NS_FAILED(ctxI->Reset())) {
50903:     NS_RELEASE(gCtx);
50903:     gCtx = nsnull;
50903:   }
33486: }
33486: 
33486: }
33486: 
33486: TaskbarPreview::TaskbarPreview(ITaskbarList4 *aTaskbar, nsITaskbarPreviewController *aController, HWND aHWND, nsIDocShell *aShell)
33486:   : mTaskbar(aTaskbar),
33486:     mController(aController),
33486:     mWnd(aHWND),
79626:     mVisible(false),
33486:     mDocShell(do_GetWeakReference(aShell))
33486: {
33486:   // TaskbarPreview may outlive the WinTaskbar that created it
33486:   ::CoInitialize(NULL);
33486: 
50903:   gInstCount++;
50903: 
33486:   WindowHook &hook = GetWindowHook();
33486:   hook.AddMonitor(WM_DESTROY, MainWindowHook, this);
33486: }
33486: 
33486: TaskbarPreview::~TaskbarPreview() {
33486:   // Avoid dangling pointer
33486:   if (sActivePreview == this)
33486:     sActivePreview = nsnull;
33486: 
41139:   // Our subclass should have invoked DetachFromNSWindow already.
41139:   NS_ASSERTION(!mWnd, "TaskbarPreview::DetachFromNSWindow was not called before destruction");
33486: 
33486:   // Make sure to release before potentially uninitializing COM
33486:   mTaskbar = NULL;
33486: 
50903:   if (--gInstCount == 0)
50903:     NS_IF_RELEASE(gCtx);
50903: 
33486:   ::CoUninitialize();
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::SetController(nsITaskbarPreviewController *aController) {
33486:   NS_ENSURE_ARG(aController);
33486: 
33486:   mController = aController;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::GetController(nsITaskbarPreviewController **aController) {
33486:   NS_ADDREF(*aController = mController);
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::GetTooltip(nsAString &aTooltip) {
33486:   aTooltip = mTooltip;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::SetTooltip(const nsAString &aTooltip) {
33486:   mTooltip = aTooltip;
33486:   return CanMakeTaskbarCalls() ? UpdateTooltip() : NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
79445: TaskbarPreview::SetVisible(bool visible) {
33486:   if (mVisible == visible) return NS_OK;
33486:   mVisible = visible;
33486: 
39717:   // If the nsWindow has already been destroyed but the caller is still trying
39717:   // to use it then just pretend that everything succeeded.  The caller doesn't
39717:   // actually have a way to detect this since it's the same case as when we
39717:   // CanMakeTaskbarCalls returns false.
39717:   if (!mWnd)
39717:     return NS_OK;
39717: 
33486:   return visible ? Enable() : Disable();
33486: }
33486: 
33486: NS_IMETHODIMP
79445: TaskbarPreview::GetVisible(bool *visible) {
33486:   *visible = mVisible;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
79445: TaskbarPreview::SetActive(bool active) {
33486:   if (active)
33486:     sActivePreview = this;
33486:   else if (sActivePreview == this)
33486:     sActivePreview = NULL;
33486: 
33486:   return CanMakeTaskbarCalls() ? ShowActive(active) : NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
79445: TaskbarPreview::GetActive(bool *active) {
33486:   *active = sActivePreview == this;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: TaskbarPreview::Invalidate() {
33486:   if (!mVisible)
33486:     return NS_ERROR_FAILURE;
33486: 
33486:   // DWM Composition is required for previews
33486:   if (!nsUXThemeData::CheckForCompositor())
33486:     return NS_OK;
33486: 
33486:   HWND previewWindow = PreviewWindow();
33486:   return FAILED(nsUXThemeData::dwmInvalidateIconicBitmapsPtr(previewWindow))
33486:        ? NS_ERROR_FAILURE
33486:        : NS_OK;
33486: }
33486: 
33486: nsresult
33486: TaskbarPreview::UpdateTaskbarProperties() {
33486:   nsresult rv = UpdateTooltip();
33486: 
33486:   // If we are the active preview and our window is the active window, restore
33486:   // our active state - otherwise some other non-preview window is now active
33486:   // and should be displayed as so.
33486:   if (sActivePreview == this) {
33486:     if (mWnd == ::GetActiveWindow()) {
79626:       nsresult rvActive = ShowActive(true);
33486:       if (NS_FAILED(rvActive))
33486:         rv = rvActive;
33486:     } else {
33486:       sActivePreview = nsnull;
33486:     }
33486:   }
33486:   return rv;
33486: }
33486: 
33486: nsresult
33486: TaskbarPreview::Enable() {
33486:   nsresult rv = NS_OK;
33486:   if (CanMakeTaskbarCalls()) {
33486:     rv = UpdateTaskbarProperties();
33486:   } else {
33486:     WindowHook &hook = GetWindowHook();
33486:     hook.AddMonitor(nsAppShell::GetTaskbarButtonCreatedMessage(), MainWindowHook, this);
33486:   }
33486:   return rv;
33486: }
33486: 
33486: nsresult
33486: TaskbarPreview::Disable() {
33486:   WindowHook &hook = GetWindowHook();
33486:   (void) hook.RemoveMonitor(nsAppShell::GetTaskbarButtonCreatedMessage(), MainWindowHook, this);
33486: 
33486:   return NS_OK;
33486: }
33486: 
79445: bool
79413: TaskbarPreview::IsWindowAvailable() const {
79413:   if (mWnd) {
86569:     nsWindow* win = WinUtils::GetNSWindowPtr(mWnd);
79413:     if(win && !win->HasDestroyStarted()) {
79626:       return true;
79413:     }
79413:   }
79626:   return false;
79413: }
79413: 
33486: void
41139: TaskbarPreview::DetachFromNSWindow() {
33486:   WindowHook &hook = GetWindowHook();
33486:   hook.RemoveMonitor(WM_DESTROY, MainWindowHook, this);
33486:   mWnd = NULL;
33486: }
33486: 
33486: LRESULT
33486: TaskbarPreview::WndProc(UINT nMsg, WPARAM wParam, LPARAM lParam) {
33486:   switch (nMsg) {
33486:     case WM_DWMSENDICONICTHUMBNAIL:
33486:       {
33486:         PRUint32 width = HIWORD(lParam);
33486:         PRUint32 height = LOWORD(lParam);
33486:         float aspectRatio = width/float(height);
33486: 
33486:         nsresult rv;
33486:         float preferredAspectRatio;
33486:         rv = mController->GetThumbnailAspectRatio(&preferredAspectRatio);
33486:         if (NS_FAILED(rv))
33486:           break;
33486: 
33486:         PRUint32 thumbnailWidth = width;
33486:         PRUint32 thumbnailHeight = height;
33486: 
33486:         if (aspectRatio > preferredAspectRatio) {
33486:           thumbnailWidth = PRUint32(thumbnailHeight * preferredAspectRatio);
33486:         } else {
33486:           thumbnailHeight = PRUint32(thumbnailWidth / preferredAspectRatio);
33486:         }
33486: 
79626:         DrawBitmap(thumbnailWidth, thumbnailHeight, false);
33486:       }
33486:       break;
33486:     case WM_DWMSENDICONICLIVEPREVIEWBITMAP:
33486:       {
33486:         PRUint32 width, height;
33486:         nsresult rv;
33486:         rv = mController->GetWidth(&width);
33486:         if (NS_FAILED(rv))
33486:           break;
33486:         rv = mController->GetHeight(&height);
33486:         if (NS_FAILED(rv))
33486:           break;
33486: 
79626:         DrawBitmap(width, height, true);
33486:       }
33486:       break;
33486:   }
33486:   return ::DefWindowProcW(PreviewWindow(), nMsg, wParam, lParam);
33486: }
33486: 
79445: bool
33486: TaskbarPreview::CanMakeTaskbarCalls() {
39717:   // If the nsWindow has already been destroyed and we know it but our caller
39717:   // clearly doesn't so we can't make any calls.
39717:   if (!mWnd)
79626:     return false;
39717:   // Certain functions like SetTabOrder seem to require a visible window. During
39717:   // window close, the window seems to be hidden before being destroyed.
39717:   if (!::IsWindowVisible(mWnd))
79626:     return false;
39717:   if (mVisible) {
86569:     nsWindow *window = WinUtils::GetNSWindowPtr(mWnd);
39717:     NS_ASSERTION(window, "Could not get nsWindow from HWND");
39717:     return window->HasTaskbarIconBeenCreated();
39717:   }
79626:   return false;
33486: }
33486: 
33486: WindowHook&
33486: TaskbarPreview::GetWindowHook() {
86569:   nsWindow *window = WinUtils::GetNSWindowPtr(mWnd);
33486:   NS_ASSERTION(window, "Cannot use taskbar previews in an embedded context!");
33486: 
33486:   return window->GetWindowHook();
33486: }
33486: 
33486: void
79445: TaskbarPreview::EnableCustomDrawing(HWND aHWND, bool aEnable) {
79583:   BOOL enabled = aEnable;
33486:   nsUXThemeData::dwmSetWindowAttributePtr(
33486:       aHWND,
33486:       DWMWA_FORCE_ICONIC_REPRESENTATION,
79583:       &enabled,
79583:       sizeof(enabled));
33486: 
33486:   nsUXThemeData::dwmSetWindowAttributePtr(
33486:       aHWND,
33486:       DWMWA_HAS_ICONIC_BITMAP,
79583:       &enabled,
79583:       sizeof(enabled));
33486: }
33486: 
33486: 
33486: nsresult
33486: TaskbarPreview::UpdateTooltip() {
33486:   NS_ASSERTION(CanMakeTaskbarCalls() && mVisible, "UpdateTooltip called on invisible tab preview");
33486: 
33486:   if (FAILED(mTaskbar->SetThumbnailTooltip(PreviewWindow(), mTooltip.get())))
33486:     return NS_ERROR_FAILURE;
33486:   return NS_OK;
33486: }
33486: 
33486: void
79445: TaskbarPreview::DrawBitmap(PRUint32 width, PRUint32 height, bool isPreview) {
33486:   nsresult rv;
33486:   nsRefPtr<gfxWindowsSurface> surface = new gfxWindowsSurface(gfxIntSize(width, height), gfxASurface::ImageFormatARGB32);
33486: 
33486:   nsCOMPtr<nsIDocShell> shell = do_QueryReferent(mDocShell);
33486: 
33486:   if (!shell)
33486:     return;
33486: 
50903:   rv = GetRenderingContext(shell, surface, width, height);
50903:   if (NS_FAILED(rv))
50903:     return;
33486: 
79445:   bool drawFrame = false;
33486:   if (isPreview)
50903:     rv = mController->DrawPreview(gCtx, &drawFrame);
33486:   else
50903:     rv = mController->DrawThumbnail(gCtx, width, height, &drawFrame);
33486: 
33486:   if (NS_FAILED(rv))
33486:     return;
33486: 
33486:   HDC hDC = surface->GetDC();
33486:   HBITMAP hBitmap = (HBITMAP)GetCurrentObject(hDC, OBJ_BITMAP);
33486: 
33486:   DWORD flags = drawFrame ? DWM_SIT_DISPLAYFRAME : 0;
33486:   POINT pptClient = { 0, 0 };
33486:   if (isPreview)
33486:     nsUXThemeData::dwmSetIconicLivePreviewBitmapPtr(PreviewWindow(), hBitmap, &pptClient, flags);
33486:   else
33486:     nsUXThemeData::dwmSetIconicThumbnailPtr(PreviewWindow(), hBitmap, flags);
50903: 
50903:   ResetRenderingContext();
33486: }
33486: 
33486: /* static */
79445: bool
33486: TaskbarPreview::MainWindowHook(void *aContext,
33486:                                HWND hWnd, UINT nMsg,
33486:                                WPARAM wParam, LPARAM lParam,
33486:                                LRESULT *aResult)
33486: {
33486:   NS_ASSERTION(nMsg == nsAppShell::GetTaskbarButtonCreatedMessage() ||
33486:                nMsg == WM_DESTROY,
33486:                "Window hook proc called with wrong message");
33486:   TaskbarPreview *preview = reinterpret_cast<TaskbarPreview*>(aContext);
33486:   if (nMsg == WM_DESTROY) {
33486:     // nsWindow is being destroyed
41139:     // We can't really do anything at this point including removing hooks
41139:     preview->mWnd = NULL;
33486:   } else {
86569:     nsWindow *window = WinUtils::GetNSWindowPtr(preview->mWnd);
96050:     if (window) {
33486:       window->SetHasTaskbarIconBeenCreated();
33486: 
33486:       if (preview->mVisible)
33486:         preview->UpdateTaskbarProperties();
33486:     }
96050:   }
79626:   return false;
33486: }
33486: 
33486: TaskbarPreview *
33486: TaskbarPreview::sActivePreview = nsnull;
33486: 
33486: } // namespace widget
33486: } // namespace mozilla
33486: 
